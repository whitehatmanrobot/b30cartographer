o->dwAutoNameFormat != PLA_SLF_NAME_NONE ){
                if( !bLogSet ){
                    strUnder = L"";
                }
            }else if( ! bLogSet ){
                pdhStatus = PDH_INVALID_ARGUMENT;
                goto cleanup;
            }

            if( ! bLogSet && ! bBang ){
                strWhack = L"!";
            }else{
                strWhack = L"";
            }

            if( StrCmpNI( strDefaultDir, L"SQL:", 4 ) != 0 ){
                strSQL = L"SQL:";
            }
        }else{
            pdhStatus = PDH_INVALID_ARGUMENT;
            goto cleanup;
        }

    }else{
        WCHAR fname[_MAX_FNAME];
        WCHAR ext[_MAX_EXT];

        if( PlaiIsStringEmpty( strDefaultDir ) ){
            strDefaultDir = L"%SystemDrive%\\PerfLogs";
        }else if( strDefaultDir[wcslen(strDefaultDir)-1] == L'\\' ){
            strWhack = L"";
        }

        if( PlaiIsStringEmpty( strBaseFileName ) ){
            if( (pInfo->dwMask & PLA_INFO_FLAG_AUTOFORMAT) && 
                PLA_SLF_NAME_NONE == pInfo->dwAutoNameFormat ){

                pdhStatus = PDH_INVALID_ARGUMENT;
                goto cleanup;
            }else{
                strBaseFileName = L"";
                strUnder = L"";
            }
        }

        _wsplitpath( strBaseFileName, NULL, NULL, fname, ext );
        
        if( _wcsicmp( ext, L".etl" ) == 0 ||
            _wcsicmp( ext, L".blg" ) == 0 ||
            _wcsicmp( ext, L".csv" ) == 0 ||
            _wcsicmp( ext, L".tsv" ) == 0 ){

            if( wcslen( fname ) < _MAX_PATH ){
                StringCchCopy( strBuffer, _MAX_PATH, fname );
                strBaseFileName = strBuffer;
            }
        }

    }

    cchTotalSize = 32;  // padding for cnf suffix and sql prefix
    cchTotalSize += BYTE_SIZE( strBaseFileName ) / sizeof(WCHAR);
    cchTotalSize += BYTE_SIZE( strDefaultDir ) / sizeof(WCHAR);

    strLocalFileName = (LPWSTR)G_ALLOC( cchTotalSize * sizeof(WCHAR) );

    if( NULL == strLocalFileName ){
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto cleanup;
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_AUTOFORMAT ){
        dwSwitch = pInfo->dwAutoNameFormat;
    }else{
        // default
        dwSwitch = PLA_SLF_NAME_NONE;
    }
    
    switch( dwSwitch ){
    case PLA_SLF_NAME_NONE:
        StringCchPrintf( strLocalFileName, cchTotalSize,
            L"%s%s%s%s", 
            strSQL, strDefaultDir, strWhack, strBaseFileName ); 
        break;
    case PLA_SLF_NAME_MMDDHH:
        StringCchPrintf( strLocalFileName, cchTotalSize,
            L"%s%s%s%s%s%02d%02d%02d", 
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, st.wMonth, st.wDay, st.wHour ); 
        break;
    case PLA_SLF_NAME_NNNNNN:
        StringCchPrintf( strLocalFileName, cchTotalSize,
            L"%s%s%s%s%s%06d", 
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, pInfo->dwLogFileSerialNumber );
        break;
    case PLA_SLF_NAME_YYYYDDD:
        StringCchPrintf( strLocalFileName, cchTotalSize,
            L"%s%s%s%s%s%04d%03d", 
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, st.wYear, PlaiJulianDate( st ) );
        break;
    case PLA_SLF_NAME_YYYYMM:
        StringCchPrintf( strLocalFileName, cchTotalSize,
            L"%s%s%s%s%s%04d%02d", 
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, st.wYear, st.wMonth );
        break;
    case PLA_SLF_NAME_YYYYMMDD:
        StringCchPrintf( strLocalFileName, cchTotalSize,
            L"%s%s%s%s%s%04d%02d%02d", 
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, st.wYear, st.wMonth, st.wDay );
        break;
    case PLA_SLF_NAME_YYYYMMDDHH:
        StringCchPrintf( strLocalFileName, cchTotalSize,
            L"%s%s%s%s%s%04d%02d%02d%02d",
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, st.wYear, st.wMonth, st.wDay, st.wHour );
        break;
    case PLA_SLF_NAME_MMDDHHMM:
        StringCchPrintf( strLocalFileName, cchTotalSize,
            L"%s%s%s%s%s%02d%02d%02d%02d", 
            strSQL, strDefaultDir, strWhack, strBaseFileName, strUnder, st.wMonth, st.wDay, st.wHour, st.wMinute ); 
        break;
    }

    if( (pInfo->dwMask & PLA_INFO_FLAG_CRTNEWFILE) && 
        PLA_AUTO_MODE_NONE != pInfo->ptCreateNewFile.dwAutoMode ){
        
        dwFlags |= PLA_FILENAME_USE_SUBEXT;

        // default the CNF number.
        if ( 0 == pInfo->dwReserved1 ) {
            pInfo->dwReserved1 = 1;
        }
    }

    if( dwFlags & PLA_FILENAME_USE_SUBEXT ){
        if( dwFlags & PLA_FILENAME_GET_SUBFMT ){
            StringCchCat( strLocalFileName, cchTotalSize, L"_%03d" );
        }else if( dwFlags & PLA_FILENAME_GET_SUBXXX ){
            StringCchCat( strLocalFileName, cchTotalSize, L"_xxx" );
        }else{
            StringCchPrintf( buffer, 128, L"_%03d", pInfo->dwReserved1 );
            StringCchCat( strLocalFileName, cchTotalSize, buffer );
        }
    }

    if( pInfo->dwMask & PLA_INFO_FLAG_FORMAT ){
        dwSwitch = (pInfo->dwFileFormat & 0x0000FFFF);
    }else{
        dwSwitch = PLA_NUM_FILE_TYPES;
    }
    switch( dwSwitch ){
    case PLA_CSV_FILE:
        StringCchCat( strLocalFileName, cchTotalSize, L".csv" );
        break;
    case PLA_TSV_FILE:
        StringCchCat( strLocalFileName, cchTotalSize, L".tsv" );
        break;
    case PLA_BIN_FILE:
    case PLA_BIN_CIRC_FILE:
        StringCchCat( strLocalFileName, cchTotalSize, L".blg" );
        break;
    case PLA_CIRC_TRACE_FILE:
    case PLA_SEQ_TRACE_FILE:
        StringCchCat( strLocalFileName, cchTotalSize, L".etl" );
        break;
    case PLA_SQL_LOG:
        break;
    }

    if( !(dwFlags & PLA_FILENAME_NOEXPANDEV) ){
        
        if( NULL == strFileName ){
            strExpand = buffer;
            cchSize = 128;
            pdhStatus = PDH_INSUFFICIENT_BUFFER;
        }else{
            strExpand = strFileName;
            cchSize = (*pcchBufferSize);
        }

        cchExpanded = ExpandEnvironmentStrings( strLocalFileName, strExpand, cchSize );

        if( cchExpanded == 0 ){
            DWORD dwStatus = GetLastError();
            pdhStatus = PlaiErrorToPdhStatus( dwStatus );
        }else{
            cchTotalSize = cchExpanded;
            if( NULL != strFileName && *pcchBufferSize < cchTotalSize ){
                pdhStatus = PDH_INSUFFICIENT_BUFFER;
            }
        }
    }else{
        
        cchTotalSize = wcslen( strLocalFileName ) + 1;

        if( NULL == strFileName ){
            pdhStatus = PDH_INSUFFICIENT_BUFFER;
        }else{
            if( cchTotalSize <= *pcchBufferSize ){
                StringCchCopy( strFileName, *pcchBufferSize, strLocalFileName );
                strExpand = strFileName;
            }else{
                pdhStatus = PDH_INSUFFICIENT_BUFFER;
            }
        }
    }

    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = PlaiScanForInvalidChar( strExpand );
    }

cleanup:

    G_FREE( strLocalFileName );
    *pcchBufferSize = cchTotalSize;
    
    return pdhStatus;
}

PDH_FUNCTION
PdhPlaGetLogFileNameA(
    LPSTR strName,
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo,
    DWORD dwFlags,
    LPDWORD pcchBufferSize,
    LPSTR strFileName
    )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaGetLogFileNameW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo,
    DWORD dwFlags,
    LPDWORD pcchBufferSize, 
    LPWSTR strFileName
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PPDH_PLA_INFO_W pLocalInfo = NULL;
    LPWSTR strFolder = NULL;
    LPWSTR strLocalFileName = NULL;
    DWORD cbSize;

    __try{
        if( pInfo == NULL ){
        
            DWORD dwInfoSize = 0;
        
            pdhStatus = PdhPlaGetInfoW( strName, strComputer, &dwInfoSize, pLocalInfo );
            CHECK_STATUS(pdhStatus);

            pLocalInfo = (PPDH_PLA_INFO)G_ALLOC(dwInfoSize);
            if( NULL != pLocalInfo ){
            
                ZeroMemory( pLocalInfo, dwInfoSize );

                pLocalInfo->dwMask = PLA_INFO_CREATE_FILENAME;

                pdhStatus = PdhPlaGetInfoW( strName, strComputer, &dwInfoSize, pLocalInfo );
                CHECK_STATUS(pdhStatus);
            }else{
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                goto cleanup;
            }
    
    
        }else{

            pLocalInfo = (PPDH_PLA_INFO)G_ALLOC(sizeof(PDH_PLA_INFO) );

            if( NULL != pLocalInfo ){
                memcpy( pLocalInfo, pInfo, sizeof(PDH_PLA_INFO) );
            }else{
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                goto cleanup;
            }
        }

        if( !(pLocalInfo->dwMask & PLA_INFO_FLAG_TYPE) || PLA_ALERT == pLocalInfo->dwType ){

            if( *pcchBufferSize > 1 && strFileName != NULL ){
                strFileName[0] = L'\0';
            }
            *pcchBufferSize = 1;
            goto cleanup;
        }

        if( ((dwFlags & PLA_FILENAME_CURRENTLOG) ||
            ((pLocalInfo->dwMask & PLA_INFO_FLAG_STATUS) && 
            PLA_QUERY_RUNNING == pLocalInfo->dwStatus)) && 
            !(dwFlags & PLA_FILENAME_CREATEONLY) ){

            if( NULL != strName ){
        
                HKEY    hkeyQuery = NULL;
        
                pdhStatus = PlaiConnectAndLockQuery ( strComputer, strName, hkeyQuery, FALSE );
        
                if( ERROR_SUCCESS == pdhStatus ){
    
                    cbSize = 0;
                    pdhStatus = PlaiReadRegistryStringValue( hkeyQuery, szCurrentLogFile, 0, &strLocalFileName, &cbSize );
                
                    RELEASE_MUTEX(hPdhPlaMutex);
                
                    if( NULL != hkeyQuery ){
                        RegCloseKey( hkeyQuery );
                    }
            
                    if( pdhStatus == ERROR_SUCCESS ){
                        if( strFileName != NULL && *pcchBufferSize >= (cbSize/sizeof(WCHAR)) ){
                            StringCchCopy( strFileName, *pcchBufferSize, strLocalFileName );
                        }else{
                            if( NULL != strFileName ){
                                pdhStatus = PDH_INSUFFICIENT_BUFFER;
                            }
                        }
                        *pcchBufferSize = (cbSize/sizeof(WCHAR));
                        goto cleanup;
                    }
                }
            }
        }

        if( !(pLocalInfo->dwMask & PLA_INFO_FLAG_DEFAULTDIR) || 
            PlaiIsStringEmpty( pLocalInfo->strDefaultDir ) ){
        
            HKEY hkeyLogs = NULL;
            
            pdhStatus = PlaiConnectToRegistry( strComputer, hkeyLogs, FALSE );
            CHECK_STATUS( pdhStatus );

            cbSize = 0;
            pdhStatus = PlaiReadRegistryStringValue( 
                            hkeyLogs, 
                            L"DefaultLogFileFolder", 
                            READ_REG_MUI, 
                            &strFolder, 
                            &cbSize 
                        );
            if( hkeyLogs != NULL ){
                RegCloseKey ( hkeyLogs );
            }
            CHECK_STATUS(pdhStatus);

            pLocalInfo->strDefaultDir = strFolder;
            pLocalInfo->dwMask |= PLA_INFO_FLAG_DEFAULTDIR;
        }    
    
        if( ! PlaiIsLocalComputer( strComputer ) ){
            dwFlags |= PLA_FILENAME_NOEXPANDEV;
        }

        pdhStatus = PlaiGetLogFileName( dwFlags, pLocalInfo, pcchBufferSize, strFileName );
    
        if(ERROR_SUCCESS == pdhStatus){ 
            pdhStatus = PdhiPlaFormatBlanksW( strComputer, strFileName );
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

cleanup:
   
    G_FREE( pLocalInfo );
    G_FREE( strFolder );
    G_FREE( strLocalFileName );

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhlog\log_wmi.h ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    log_wmi.h

Abstract:
    <abstract>
--*/

#ifndef _LOG_WMI_H_
#define _LOG_WMI_H_

#define WMILOG_VERSION ((DWORD) (0x000006FF))

PDH_FUNCTION
PdhiOpenInputWmiLog(
    PPDHI_LOG pLog
);

PDH_FUNCTION
PdhiOpenOutputWmiLog(
    PPDHI_LOG pLog
);

PDH_FUNCTION
PdhiCloseWmiLog(
    PPDHI_LOG pLog,
    DWORD     dwFlags
);

PDH_FUNCTION
PdhiGetWmiLogFileSize(
    PPDHI_LOG   pLog,
    LONGLONG  * llSize
);

PDH_FUNCTION
PdhiWriteWmiLogHeader(
    PPDHI_LOG pLog,
    LPCWSTR   szUserCaption
);

PDH_FUNCTION
PdhiWriteWmiLogRecord(
    PPDHI_LOG    pLog,
    SYSTEMTIME * stTimeStamp,
    LPCWSTR      szUserString
);

PDH_FUNCTION
PdhiRewindWmiLog(
    PPDHI_LOG  pLog
);

PDH_FUNCTION
PdhiReadWmiHeaderRecord(
    PPDHI_LOG  pLog,
    LPVOID     pRecord,
    DWORD      dwMaxSize
);

PDH_FUNCTION
PdhiReadNextWmiRecord(
    PPDHI_LOG  pLog,
    LPVOID     pRecord,
    DWORD      dwMaxSize,
    BOOLEAN    bAllCounter
);

PDH_FUNCTION
PdhiReadTimeWmiRecord(
    PPDHI_LOG  pLog,
    ULONGLONG  TimeStamp,
    LPVOID     pRecord,
    DWORD      dwMaxSize
);

PDH_FUNCTION
PdhiGetTimeRangeFromWmiLog(
    PPDHI_LOG      hLog,
    LPDWORD        pdwNumEntries,
    PPDH_TIME_INFO pInfo,
    LPDWORD        pdwBufferSize
);

PDH_FUNCTION
PdhiEnumMachinesFromWmiLog(
    PPDHI_LOG   pLog,
    LPVOID      pBuffer,
    LPDWORD     lpdwBufferSize,
    BOOL        bUnicodeDest
);

PDH_FUNCTION
PdhiEnumObjectsFromWmiLog(
    PPDHI_LOG pLog,
    LPCWSTR   szMachineName,
    LPVOID    pBuffer,
    LPDWORD   pcchBufferSize,
    DWORD     dwDetailLevel,
    BOOL      bUnicodeDest
);

PDH_FUNCTION
PdhiEnumObjectItemsFromWmiLog(
    PPDHI_LOG          pLog,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
);

PDH_FUNCTION
PdhiGetWmiLogCounterInfo(
    PPDHI_LOG     pLog,
    PPDHI_COUNTER pCounter
);

#endif   // _LOG_WMI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhpla\regutil.cpp ===
/*****************************************************************************\

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#include <assert.h>
#include <windows.h>
#include <string.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <pdh.h>

#include <pdhp.h>
#include <ntsecapi.h>

#include <shlwapi.h>
#include <shlwapip.h>

#include "plogman.h"

PDH_FUNCTION
PlaiReadRegistryPlaTime (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    PPLA_TIME_INFO  pstiData
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;
    PLA_TIME_INFO   slqLocal;

    memset (&slqLocal, 0, sizeof(PLA_TIME_INFO));

    dwStatus = RegQueryValueExW (
        hKey,
        cwszValueName,
        NULL,
        &dwType,
        NULL,
        &dwBufferSize );

    if ( ERROR_SUCCESS == dwStatus ) {
        if ( (dwBufferSize == sizeof(PLA_TIME_INFO)) && ( REG_BINARY == dwType ) ) {
            // then there's something to read
            dwType = 0;
            dwStatus = RegQueryValueExW (
                hKey,
                cwszValueName,
                NULL,
                &dwType,
                (LPBYTE)&slqLocal,
                &dwBufferSize);
        } else {
            // nothing to read
            dwStatus = ERROR_NO_DATA;
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        *pstiData = slqLocal;
    }

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiWriteRegistryPlaTime (
    HKEY     hKey,
    LPCWSTR cwszValueName,
    PPLA_TIME_INFO  pstiData
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(PLA_TIME_INFO);

    dwStatus = RegSetValueExW (
        hKey,
        cwszValueName,
        0L,
        REG_BINARY,
        (CONST BYTE *)pstiData,
        dwValue);

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiReadRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    LPDWORD  pdwValue
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(DWORD);
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;

    dwStatus = RegQueryValueExW (
        hKey,
        cwszValueName,
        NULL,
        &dwType,
        NULL,
        &dwBufferSize );

    if ( ERROR_SUCCESS == dwStatus ) {
        if ( ( dwBufferSize == sizeof(DWORD) )
                && ( ( REG_DWORD == dwType ) || ( REG_BINARY == dwType ) ) ) {
            // then there's something to read
            dwType = 0;
            dwStatus = RegQueryValueExW (
                hKey,
                cwszValueName,
                NULL,
                &dwType,
                (LPBYTE)&dwValue,
                &dwBufferSize);
        } else {
            // nothing to read
            dwStatus = ERROR_NO_DATA;
        }
    } // else hr has error.

    if ( ERROR_SUCCESS == dwStatus ) {
        *pdwValue = dwValue;
    }

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiWriteRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    LPDWORD  pdwValue
)
{
    DWORD dwType = REG_DWORD;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(DWORD);

    dwStatus = RegSetValueExW (
        hKey,
        cwszValueName,
        0L,
        dwType,
        (CONST BYTE *)pdwValue,
        dwValue);

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiReadRegistryStringValue(
    HKEY    hKey,
    LPCWSTR strKey,
    DWORD   dwFlags,
    LPWSTR* pszBuffer,
    DWORD*  dwBufLen
    )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwDataType;
    DWORD   dwDataSize = 0;
    LPWSTR  pBuffer;
    
    dwStatus = RegQueryValueExW(
             hKey,
             strKey,
             NULL,
             &dwDataType,
             (LPBYTE)NULL,
             (LPDWORD)&dwDataSize
        );

    if( (dwFlags & READ_REG_MUI) ){
        if( dwDataSize < 1024 ){
            dwDataSize = 1024;
        }
        dwStatus = ERROR_SUCCESS;
    }    

    if( ERROR_SUCCESS == dwStatus ){

        pBuffer = *pszBuffer;

        if( pBuffer == NULL || dwDataSize > G_SIZE(pBuffer) ){
            
            if( pBuffer != NULL ){
                pBuffer = (LPWSTR)G_REALLOC( pBuffer, dwDataSize );
            }else{
                pBuffer = (LPWSTR)G_ALLOC( dwDataSize );
            }

            if( pBuffer ){
                *pszBuffer = pBuffer;
            }else{
                G_FREE( (*pszBuffer) );
                return ERROR_OUTOFMEMORY;
            }
        }
        
        if( dwFlags & READ_REG_MUI ){

            const int cBuffer = 512;
            WCHAR strKeyIndirect[cBuffer];
            LPWSTR szIndirect = L" Indirect";
            
            if( wcslen(strKey) + wcslen( szIndirect ) + sizeof(WCHAR ) > cBuffer ){
                dwStatus = ERROR_INVALID_DATA;
            }else{
                StringCchPrintfW( strKeyIndirect, cBuffer, L"%s%s", strKey, szIndirect );

                dwStatus = SHLoadRegUIStringW (
                        hKey,
                        strKeyIndirect,
                        *pszBuffer,
                        dwDataSize/sizeof(WCHAR)
                    );

                if( ERROR_SUCCESS == dwStatus ){
                    *dwBufLen = (DWORD)((char*)&(*pszBuffer)[wcslen(*pszBuffer)]  
                                        - (char*)&(*pszBuffer)[0]);
                    *dwBufLen += sizeof(WCHAR);
                }else{
                    *dwBufLen = 0;
                }
            }

        }

        if( !(dwFlags & READ_REG_MUI) ||
            ((dwFlags & READ_REG_MUI) && ERROR_SUCCESS != dwStatus) ){
            
            dwStatus = RegQueryValueExW(
                     hKey,
                     strKey,
                     NULL,
                     &dwDataType,
                     (LPBYTE)*pszBuffer,
                     (LPDWORD)&dwDataSize
                );
            
            if( dwStatus == ERROR_SUCCESS ){
                *dwBufLen = dwDataSize;
            }else{
                *dwBufLen = 0;
            }
        }
    }

    if( ERROR_SUCCESS == dwStatus && !(dwFlags&READ_REG_BLOB) ){
        (*pszBuffer)[(*dwBufLen/sizeof(WCHAR))-1] = L'\0';
    }
    
    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiWriteRegistryStringValue (
    HKEY    hKey,
    LPCWSTR cwszValueName,
    DWORD   dwType,
    LPCWSTR pszBuffer,
    DWORD   cbBufferLength
)
{
    //  writes the contents of pszBuffer to szValue under hKey
    
    DWORD  dwStatus = ERROR_SUCCESS;
    CONST BYTE *pLclBuffer;

    if ( NULL == pszBuffer ) {
        // substitute an empty string
        pLclBuffer = (CONST BYTE *)L"\0";
        cbBufferLength = sizeof(WCHAR);
    } else {
        // use args passed in
        pLclBuffer = (CONST BYTE *)pszBuffer;
        if( cbBufferLength == 0 ){
            cbBufferLength = BYTE_SIZE( pszBuffer ) + (DWORD)sizeof(UNICODE_NULL);
        }
    }

    dwStatus = RegSetValueExW (hKey,
        cwszValueName,
        0L,
        dwType,
        (CONST BYTE *)pLclBuffer,
        cbBufferLength );

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiWriteRegistryLastModified( HKEY hkeyQuery )
{
    DWORD dwStatus = ERROR_SUCCESS;

    PLA_TIME_INFO   plqLastModified;
    SYSTEMTIME      stLocalTime;
    FILETIME        ftModified;

    RegFlushKey( hkeyQuery );

    dwStatus = RegQueryInfoKey ( 
                hkeyQuery,
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                NULL,           
                &ftModified );

    if( ERROR_SUCCESS != dwStatus ) {
        GetLocalTime (&stLocalTime);
        SystemTimeToFileTime (&stLocalTime, &ftModified);
    }

    plqLastModified.wDataType = PLA_TT_DTYPE_DATETIME;
    plqLastModified.wTimeType = PLA_TT_TTYPE_LAST_MODIFIED;
    plqLastModified.dwAutoMode = PLA_AUTO_MODE_NONE;
    plqLastModified.llDateTime = *(LONGLONG *)&ftModified;

    if( ERROR_SUCCESS == dwStatus ){
        return PlaiWriteRegistryPlaTime (
                            hkeyQuery, 
                            L"Last Modified",
                            &plqLastModified
                        );
    }

    return PlaiErrorToPdhStatus( dwStatus );
}

DWORD 
PlaiCreateQuery( 
        HKEY    hkeyMachine,
        HKEY&   rhkeyLogQueries 
    )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hkeySysmonLog;
    DWORD   dwDisposition;
    
    rhkeyLogQueries = NULL;

    dwStatus = RegOpenKeyExW (
                    hkeyMachine,
                    L"System\\CurrentControlSet\\Services\\SysmonLog",
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkeySysmonLog);
    
    if ( ERROR_SUCCESS == dwStatus ) {
        // Create registry subkey for Log Queries
        dwStatus = RegCreateKeyExW (
                        hkeySysmonLog,
                        L"Log Queries",
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &rhkeyLogQueries,
                        &dwDisposition);
        
        RegCloseKey( hkeySysmonLog );
    }

    return dwStatus;
}

PDH_FUNCTION
PdhiPlaGetVersion(
    LPCWSTR strComputer,
    PPLA_VERSION pVersion )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hkeyMachine = HKEY_LOCAL_MACHINE;    
    HKEY    hkeyQuery = NULL;
    DWORD   cbBufferSize = 0;
    DWORD   dwType;
    WCHAR   szRegValue[MAX_PATH];
    PLA_VERSION version;

    ZeroMemory( &version, sizeof(PLA_VERSION) );

    if ( NULL != strComputer ) {
        if ( wcslen( strComputer) ) {

            dwStatus = RegConnectRegistryW (
                        strComputer,
                        HKEY_LOCAL_MACHINE,
                        &hkeyMachine 
                    );  
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {

        dwStatus = RegOpenKeyExW (
                hkeyMachine,
                L"Software\\Microsoft\\Windows NT\\CurrentVersion",
                0,
                KEY_READ,
                &hkeyQuery 
            );

        if( ERROR_SUCCESS == dwStatus ){
            dwStatus = RegQueryValueExW (
                    hkeyQuery,
                    L"CurrentVersion",
                    NULL,
                    &dwType,
                    NULL,
                    &cbBufferSize
                );

            if( ERROR_SUCCESS == dwStatus ) {
                if( (MAX_PATH*sizeof(WCHAR) > cbBufferSize ) && 
                    (sizeof(WCHAR) < cbBufferSize) &&
                    (REG_SZ == dwType ) )
                {
                    ZeroMemory ( szRegValue, MAX_PATH ); 

                    dwStatus = RegQueryValueExW (
                                hkeyQuery,
                                L"CurrentVersion",
                                NULL,
                                &dwType,
                                (LPBYTE)szRegValue,
                                &cbBufferSize
                            );

                    if ( ERROR_SUCCESS == dwStatus ) {
                        version.dwMajorVersion = _wtol ( szRegValue );
                    }
                }
            }
        }

        if( ERROR_SUCCESS == dwStatus ){
            dwStatus = RegQueryValueExW (
                    hkeyQuery,
                    L"CurrentBuildNumber",
                    NULL,
                    &dwType,
                    NULL,
                    &cbBufferSize
                );

            if( ERROR_SUCCESS == dwStatus ) {
                if( (MAX_PATH*sizeof(WCHAR) > cbBufferSize ) && 
                    (sizeof(WCHAR) < cbBufferSize) &&
                    (REG_SZ == dwType ) )
                {
                    ZeroMemory ( szRegValue, MAX_PATH ); 

                    dwStatus = RegQueryValueExW (
                                hkeyQuery,
                                L"CurrentBuildNumber",
                                NULL,
                                &dwType,
                                (LPBYTE)szRegValue,
                                &cbBufferSize
                            );

                    if ( ERROR_SUCCESS == dwStatus ) {
                        version.dwBuild = _wtol ( szRegValue );
                    }
                }
            }
        }
    }

    memcpy( pVersion, &version, sizeof(PLA_VERSION) );
    
    if ( NULL != hkeyMachine && HKEY_LOCAL_MACHINE != hkeyMachine ) {
        RegCloseKey ( hkeyMachine );
    }
    
    if( NULL != hkeyQuery ){
        RegCloseKey( hkeyQuery );
    }

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiConnectToRegistry(
    LPCWSTR strComputer,
    HKEY& rhkeyLogQueries,
    BOOL bQueries,
    BOOL bWrite )
{
    DWORD dwStatus = ERROR_SUCCESS;
    HKEY    hkeyMachine = HKEY_LOCAL_MACHINE;    

    if ( NULL != strComputer ) {
        if( wcslen( strComputer ) ){
            dwStatus = RegConnectRegistryW (
                strComputer,
                HKEY_LOCAL_MACHINE,
                &hkeyMachine );        
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        if( bQueries ){
            if ( bWrite ) {
                dwStatus = RegOpenKeyExW (
                    hkeyMachine,
                    L"System\\CurrentControlSet\\Services\\SysmonLog\\Log Queries",
                    0,
                    KEY_READ|KEY_WRITE,
                    &rhkeyLogQueries ); 
            }else{
                dwStatus = RegOpenKeyExW (
                    hkeyMachine,
                    L"System\\CurrentControlSet\\Services\\SysmonLog\\Log Queries",
                    0,
                    KEY_READ,
                    &rhkeyLogQueries ); 
            }
        }else{
            dwStatus = RegOpenKeyExW (
                hkeyMachine,
                L"System\\CurrentControlSet\\Services\\SysmonLog",
                0,
                KEY_READ,
                &rhkeyLogQueries ); 
        }

        if ( ERROR_SUCCESS != dwStatus ) {
            dwStatus = PlaiCreateQuery( hkeyMachine, rhkeyLogQueries );
        }
    } 
    
    if ( NULL != hkeyMachine && HKEY_LOCAL_MACHINE != hkeyMachine ) {
        RegCloseKey ( hkeyMachine );
    }

    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiConnectAndLockQuery (
    LPCWSTR strComputer,
    LPCWSTR strQuery,
    HKEY&   rhkeyQuery,
    BOOL    bWrite  )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY  hkeyQuery = NULL;
    HKEY  hkeyLogQueries = NULL;

    rhkeyQuery = NULL;
    dwStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhPlaMutex);
    
    if( ERROR_SUCCESS == dwStatus || WAIT_ABANDONED == dwStatus ){

        pdhStatus = PlaiConnectToRegistry (
                    strComputer,
                    hkeyLogQueries,
                    TRUE,
                    bWrite
                );

        if( ERROR_SUCCESS == pdhStatus ){
            DWORD nCollections = 0;
            DWORD nMaxSubKeyLength = 0;

            dwStatus = RegQueryInfoKey(
                        hkeyLogQueries,
                        NULL,
                        NULL,
                        NULL,
                        &nCollections,
                        &nMaxSubKeyLength,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL 
                    );

            if( ERROR_SUCCESS == dwStatus ){
            
                LPWSTR strCollection;
                LPWSTR strQueryName = NULL;
                DWORD dwQueryName = 0;

                DWORD dwSize = (sizeof(WCHAR)*(nMaxSubKeyLength+1));

                strCollection = (LPWSTR)G_ALLOC( dwSize );

                if( strCollection ){

                    dwStatus = ERROR_FILE_NOT_FOUND;
                    
                    for( ULONG i = 0; i<nCollections; i++ ){
                        dwStatus = RegEnumKey( hkeyLogQueries, i, strCollection, dwSize );
                        if( ERROR_SUCCESS == dwStatus ) {

                            dwStatus = RegOpenKeyExW (
                                    hkeyLogQueries,
                                    strCollection,
                                    0,
                                    bWrite ? KEY_READ | KEY_WRITE : KEY_READ,
                                    &hkeyQuery 
                                );

                            if( ERROR_SUCCESS == dwStatus ){
                                if( !_wcsicmp( strCollection, strQuery ) ){
                                    break;
                                }

                                PlaiReadRegistryStringValue( hkeyQuery, szCollection, READ_REG_MUI, &strQueryName, &dwQueryName );
                            
                                if( strQueryName != NULL && !_wcsicmp( strQueryName, strQuery ) ){
                                    break;
                                }
                                dwStatus = ERROR_FILE_NOT_FOUND;
                                if ( NULL != hkeyQuery ) {
                                    RegCloseKey ( hkeyQuery );
                                }
                            }
                        }
                    }

                    G_FREE( strQueryName );
                    G_FREE( strCollection );

                }else{
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            }
        }

        if( NULL != hkeyLogQueries ){
            RegCloseKey ( hkeyLogQueries );
        }

        if( ERROR_SUCCESS != dwStatus || ERROR_SUCCESS != pdhStatus){
            RELEASE_MUTEX( hPdhPlaMutex );
        }else{
            rhkeyQuery = hkeyQuery;
        }
    }

    if( ERROR_SUCCESS != pdhStatus ){
        return pdhStatus;
    }else{
        return PlaiErrorToPdhStatus( dwStatus );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhpla\plogman.h ===
/*****************************************************************************\

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#ifndef _PLOGMAN_H_04262000_
#define _PLOGMAN_H_04262000_

#include "pdhidef.h"
#include <strsafe.h>

#define _SECOND ((ULONGLONG) 10000000)
#define _MINUTE (60 * _SECOND)
#define _HOUR   (60 * _MINUTE)
#define _DAY    (24 * _HOUR)

#define  VALIDATE_QUERY( x ) if( NULL == x ){ return PDH_INVALID_ARGUMENT; }




#define  PLA_ACCOUNT_BUFFER       256

extern LPCWSTR szCollection;

#define READ_REG_MUI    0x000000001
#define READ_REG_BLOB   0x000000002

#define CHECK_STATUS( s )  if( ERROR_SUCCESS != s ){ goto cleanup; }

#define FILE_TICS_PER_DAY  ((LONGLONG)((LONGLONG)10000 * (LONGLONG)1000 * (LONGLONG)86400))
#define PLA_ENGLISH        (PRIMARYLANGID(GetUserDefaultUILanguage())==LANG_ENGLISH)

#define BYTE_SIZE( s )   (s ? ((DWORD)((BYTE*)&s[wcslen(s)]-(BYTE*)&s[0])) : 0)

#define SEVERITY( s )    ((ULONG)s >> 30)

// Registry

PDH_FUNCTION
PlaiReadRegistryPlaTime (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    PPLA_TIME_INFO  pstiData
);

PDH_FUNCTION
PlaiWriteRegistryPlaTime (
    HKEY     hKey,
    LPCWSTR cwszValueName,
    PPLA_TIME_INFO  pstiData
);

PDH_FUNCTION
PlaiReadRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    LPDWORD  pdwValue
);

PDH_FUNCTION
PlaiWriteRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  cwszValueName,
    LPDWORD  pdwValue
);

PDH_FUNCTION
PlaiReadRegistryStringValue(
    HKEY    hKey,
    LPCWSTR strKey,
    DWORD   dwFlags,
    LPWSTR* pszBuffer,
    DWORD*  dwBufLen
    );

PDH_FUNCTION
PlaiWriteRegistryStringValue (
    HKEY    hKey,
    LPCWSTR cwszValueName,
    DWORD   dwType,
    LPCWSTR pszBuffer,
    DWORD   dwBufLen
);

PDH_FUNCTION 
PlaiWriteRegistryLastModified( 
    HKEY hkeyQuery
);

DWORD
PlaiCreateQuery( 
    HKEY    hkeyMachine,
    HKEY&   rhkeyLogQueries 
);

PDH_FUNCTION
PlaiConnectToRegistry(
    LPCWSTR szComputerName,
    HKEY& rhkeyLogQueries,
    BOOL bQueries,
    BOOL bWrite = TRUE
);

PDH_FUNCTION
PlaiConnectAndLockQuery (
    LPCWSTR szComputerName,
    LPCWSTR szQueryName,
    HKEY&   rhkeyQuery,
    BOOL    bWrite = TRUE 
);

// Wbem Functions
PDH_FUNCTION
PdhPlaWbemSetRunAs( 
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

// Internal

PDH_FUNCTION
PlaiErrorToPdhStatus( 
    DWORD dwStatus 
);

PDH_FUNCTION
PlaiSetItemList(
    HKEY    hkeyQuery,
    PPDH_PLA_ITEM_W pItems
);

PDH_FUNCTION
PlaiSetRunAs(
    HKEY hkeyQuery,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION
PlaiRemoveRepeat( 
    HKEY hkeyQuery 
);

PDH_FUNCTION
PlaiSetInfo(
    LPWSTR strComputer,
    HKEY hkeyQuery,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PlaiScanForInvalidChar( 
    LPWSTR strScan 
);

PDH_FUNCTION
PlaiAddItem( 
    HKEY hkeyQuery,
    PPDH_PLA_ITEM_W pItem 
);

#endif //_PLOGMAN_H_04262000_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhui\datasrc.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    datasrc.c

Abstract:

    data source selection dialog box functions

Revision History

    Bob Watson (a-robw) Feb-95  Created

--*/
#include <windows.h>
#include "mbctype.h"
#include "strsafe.h"
#include <pdh.h>
#include "pdhidef.h"
#include "pdhdlgs.h"
#include "pdhmsg.h"
#include "strings.h"
#include "browsdlg.h"

//
//  Constants used in this module
//
ULONG
PdhiDatasrcaulControlIdToHelpIdMap[] =
{
    IDC_CURRENT_ACTIVITY,       IDH_CURRENT_ACTIVITY,
    IDC_DATA_FROM_LOG_FILE,     IDH_DATA_FROM_LOG_FILE,
    IDC_LOG_FILE_EDIT,          IDH_LOG_FILE_EDIT,
    0,0
};

STATIC_BOOL
DataSrcDlg_RadioButton(
    HWND  hDlg,
    WORD  wNotifyMsg,
    WORD  wCtrlId
)
{
    int  nShowEdit      = FALSE;
    int  nShowBrowseBtn = FALSE;
    int  nShowRegBtn    = FALSE;
    int  nShowWbemBtn   = FALSE;
    BOOL bReturn        = FALSE;

    switch (wNotifyMsg) {
    case BN_CLICKED:
        switch (wCtrlId) {
        case IDC_CURRENT_ACTIVITY:
            nShowEdit      = FALSE;
            nShowBrowseBtn = FALSE;
            nShowRegBtn    = TRUE;
            nShowWbemBtn   = TRUE;
            break;

        case IDC_DATA_FROM_LOG_FILE:
            nShowEdit      = TRUE;
            nShowBrowseBtn = TRUE;
            nShowRegBtn    = FALSE;
            nShowWbemBtn   = FALSE;
            break;

        case IDC_PERF_REG:
        case IDC_WBEM_NS:
            bReturn = TRUE;
            break;
        }
        if (! bReturn) {
            EnableWindow(GetDlgItem(hDlg, IDC_LOG_FILE_EDIT), nShowEdit);
            EnableWindow(GetDlgItem(hDlg, IDC_BROWSE_LOG_FILES), nShowBrowseBtn);
            EnableWindow(GetDlgItem(hDlg, IDC_PERF_REG), nShowRegBtn);
            EnableWindow(GetDlgItem(hDlg, IDC_WBEM_NS), nShowWbemBtn);
            bReturn = TRUE;
        }
        break;

    default:
        break;
    }
    return bReturn;
}

STATIC_BOOL
DataSrcDlg_BROWSE_LOG_FILES(
    HWND  hDlg,
    WORD  wNotifyMsg,
    HWND  hWndControl
)
{
    BOOL bReturn = FALSE;

    UNREFERENCED_PARAMETER(hWndControl);
    
    switch (wNotifyMsg) {
    case BN_CLICKED:
        {
            LPWSTR szEditBoxString = NULL;
            DWORD  cchStringLen    = SMALL_BUFFER_SIZE;

            szEditBoxString = G_ALLOC(cchStringLen * sizeof(WCHAR));
            if (szEditBoxString != NULL) {
                // get the current filename
                SendDlgItemMessageW(hDlg,
                                    IDC_LOG_FILE_EDIT,
                                    WM_GETTEXT,
                                    (WPARAM) cchStringLen,
                                    (LPARAM) szEditBoxString);
                if (PdhiBrowseDataSource(hDlg, szEditBoxString, & cchStringLen, TRUE)) {
                    // then update the edit box and set focus to it.
                    SendDlgItemMessageW(hDlg,
                                        IDC_LOG_FILE_EDIT,
                                        WM_SETTEXT,
                                        (WPARAM) 0,
                                        (LPARAM) szEditBoxString);
                }
            }
        }
        bReturn = TRUE;
        break;

    default:
        break;
    }
    return bReturn;
}

STATIC_BOOL
DataSrcDlg_OK(
    HWND hDlg,
    WORD wNotifyMsg,
    HWND hWndControl
)
{
    PPDHI_DATA_SOURCE_INFO  pInfo;
    HCURSOR                 hOldCursor;
    DWORD                   dwFileNameLength;
    BOOL                    bReturn = FALSE;

    UNREFERENCED_PARAMETER(hWndControl);

    switch (wNotifyMsg) {
    case BN_CLICKED:
        pInfo = (PPDHI_DATA_SOURCE_INFO) GetWindowLongPtrW (hDlg, DWLP_USER);
        if (pInfo != NULL) {
            hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            // get data from dialog box
            if (IsDlgButtonChecked(hDlg, IDC_CURRENT_ACTIVITY) == 1) {
                if (IsDlgButtonChecked(hDlg, IDC_WBEM_NS) == 1) {
                    // then a WBEM Name Space is selected so get the name
                    pInfo->dwFlags = PDHI_DATA_SOURCE_WBEM_NAMESPACE;
                    dwFileNameLength = lstrlenW(cszWMI);
                    if (dwFileNameLength < pInfo->cchBufferLength) {
                        StringCchCopyW(pInfo->szDataSourceFile, pInfo->cchBufferLength, cszWMI);
                        pInfo->cchBufferLength = dwFileNameLength;
                    }
                    else {
                        // buffer is too small for the file name
                        // so return the required size but no string
                        * pInfo->szDataSourceFile = L'\0';
                        pInfo->cchBufferLength = dwFileNameLength;
                    }
                }
                else if (IsDlgButtonChecked (hDlg, IDC_PERF_REG) == 1) {
                    // then current activity is selected so set flags
                    pInfo->dwFlags            = PDHI_DATA_SOURCE_CURRENT_ACTIVITY;
                    * pInfo->szDataSourceFile = L'\0';
                    pInfo->cchBufferLength    = 0;
                }
            }
            else if (IsDlgButtonChecked (hDlg, IDC_DATA_FROM_LOG_FILE) == 1) {
                // then a log file is selected so get the log file name
                pInfo->dwFlags = PDHI_DATA_SOURCE_LOG_FILE;
                dwFileNameLength = (DWORD)SendDlgItemMessageW(hDlg, IDC_LOG_FILE_EDIT, WM_GETTEXTLENGTH, 0, 0);
                if (dwFileNameLength < pInfo->cchBufferLength) {
                    pInfo->cchBufferLength = (DWORD) SendDlgItemMessageW(hDlg,
                                                                         IDC_LOG_FILE_EDIT,
                                                                         WM_GETTEXT,
                                                                         (WPARAM) pInfo->cchBufferLength,
                                                                         (LPARAM) pInfo->szDataSourceFile);
                }
                else {
                    // buffer is too small for the file name
                    // so return the required size but no string
                    * pInfo->szDataSourceFile = L'\0';
                    pInfo->cchBufferLength    = dwFileNameLength;
                }
            }
            SetCursor(hOldCursor);
            EndDialog(hDlg, IDOK);
        }
        else {
            // unable to locate data block so no data can be returned.
            EndDialog(hDlg, IDCANCEL);
        }
        bReturn = TRUE;
        break;

    default:
        break;
    }
    return bReturn;
}

STATIC_BOOL
DataSrcDlg_CANCEL(
    HWND    hDlg,
    WORD    wNotifyMsg,
    HWND    hWndControl
)
{
    BOOL bReturn = FALSE;
    UNREFERENCED_PARAMETER(hWndControl);

    switch (wNotifyMsg) {
    case BN_CLICKED:
        EndDialog(hDlg, IDCANCEL);
        bReturn = TRUE;
        break;

    default:
        break;
    }
    return bReturn;
}

STATIC_BOOL
DataSrcDlg_HELP_BTN(
    HWND    hDlg,
    WORD    wNotifyMsg,
    HWND    hWndControl
)
{
    UNREFERENCED_PARAMETER(hDlg);
    UNREFERENCED_PARAMETER(wNotifyMsg);
    UNREFERENCED_PARAMETER(hWndControl);
    return FALSE;
}

STATIC_BOOL
DataSrcDlg_WM_INITDIALOG(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    // LPARAM is the pointer to the structure used for the data source info
    BOOL                    bReturn = TRUE;
    PPDHI_DATA_SOURCE_INFO  pInfo;
    HCURSOR                 hOldCursor;
    int                     nButton;
    int                     nShowEdit;
    int                     nShowBrowse;
    int                     nShowRegBtn;
    int                     nShowWbemBtn;
    HWND                    hwndFocus;
    LPWSTR                  szDisplayString;

    UNREFERENCED_PARAMETER(wParam);

    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // must have a pointer to the information structure in the LPARAM
    if (lParam == 0) {
        SetLastError(PDH_INVALID_ARGUMENT);
        EndDialog(hDlg, IDCANCEL);
        goto INIT_EXIT;
    }

    pInfo = (PPDHI_DATA_SOURCE_INFO) lParam;
    SetWindowLongPtrW(hDlg, DWLP_USER, (LONG_PTR) pInfo);

    // initialize the dialog box settings

    SendDlgItemMessageW(hDlg, IDC_LOG_FILE_EDIT, EM_LIMITTEXT, (WPARAM) MAX_PATH - 1, 0);

    if (pInfo->dwFlags & PDHI_DATA_SOURCE_CURRENT_ACTIVITY) {
        // check the correct radio button
        nButton      = IDC_PERF_REG;
        nShowEdit    = FALSE;
        nShowBrowse  = FALSE;
        nShowRegBtn  = TRUE;
        nShowWbemBtn = TRUE;
        hwndFocus    = GetDlgItem(hDlg, IDC_PERF_REG);
    }
    else if (pInfo->dwFlags & PDHI_DATA_SOURCE_LOG_FILE) {
        // check the correct radio button
        nButton      = IDC_DATA_FROM_LOG_FILE;
        nShowEdit    = TRUE;
        nShowBrowse  = TRUE;
        nShowRegBtn  = FALSE;
        nShowWbemBtn = FALSE;
        // load log file to edit window
        SendDlgItemMessageW(hDlg, IDC_LOG_FILE_EDIT, WM_SETTEXT, (WPARAM) 0, (LPARAM) pInfo->szDataSourceFile);
        hwndFocus = GetDlgItem(hDlg, IDC_LOG_FILE_EDIT);
    }
    else if (pInfo->dwFlags & PDHI_DATA_SOURCE_WBEM_NAMESPACE) {
        // check the correct radio button
        nButton      = IDC_WBEM_NS;
        nShowEdit    = FALSE;
        nShowBrowse  = FALSE;
        nShowRegBtn  = TRUE;
        nShowWbemBtn = TRUE;
        // if the file name has a "WBEM:" in the front, then remove it
        if (DataSourceTypeW(pInfo->szDataSourceFile) == DATA_SOURCE_WBEM) {
            if (pInfo->szDataSourceFile[1] == L'B' || pInfo->szDataSourceFile[1] == L'b') {
                // szDataSource begins with "WBEM:"
                szDisplayString = & pInfo->szDataSourceFile[lstrlenW(cszWBEM)];
            }
            else {
                // szDataSource begins with "WMI:"
                szDisplayString = & pInfo->szDataSourceFile[lstrlenW(cszWMI)];
            }
        }
        else {
            szDisplayString = pInfo->szDataSourceFile;
        }
        hwndFocus = GetDlgItem(hDlg, IDC_WBEM_NS);
    }
    else {
        // invalid selection
        SetLastError(PDH_INVALID_ARGUMENT);
        EndDialog(hDlg, IDCANCEL);
        goto INIT_EXIT;
    }

    if (nShowEdit) {
        // if this isn't selected, then set it so that it acts like the
        // default
        CheckRadioButton(hDlg, IDC_PERF_REG, IDC_WBEM_NS, IDC_PERF_REG);
        CheckRadioButton(hDlg, IDC_CURRENT_ACTIVITY, IDC_DATA_FROM_LOG_FILE, IDC_DATA_FROM_LOG_FILE);
    }
    else {
        CheckRadioButton(hDlg, IDC_CURRENT_ACTIVITY, IDC_DATA_FROM_LOG_FILE, IDC_CURRENT_ACTIVITY);
        CheckRadioButton(hDlg, IDC_PERF_REG, IDC_WBEM_NS, nButton);
    }

    // disable the edit window and browser button
    EnableWindow(GetDlgItem(hDlg, IDC_LOG_FILE_EDIT), nShowEdit);
    EnableWindow(GetDlgItem(hDlg, IDC_BROWSE_LOG_FILES), nShowBrowse);
    EnableWindow(GetDlgItem(hDlg, IDC_PERF_REG), nShowRegBtn);
    EnableWindow(GetDlgItem(hDlg, IDC_WBEM_NS), nShowWbemBtn);

    SetFocus(hwndFocus);
    bReturn = FALSE;

INIT_EXIT:
    // restore Cursor
    SetCursor (hOldCursor);

    return bReturn;
}

STATIC_BOOL
DataSrcDlg_WM_COMMAND(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    BOOL bReturn    = FALSE;
    WORD wNotifyMsg = HIWORD(wParam);

    switch (LOWORD(wParam)) {   // select on the control ID
    case IDOK:
        bReturn = DataSrcDlg_OK (hDlg, wNotifyMsg, (HWND)lParam);
        break;

    case IDCANCEL:
        bReturn = DataSrcDlg_CANCEL (hDlg, wNotifyMsg, (HWND)lParam);
        break;

    case IDC_HELP_BTN:
        bReturn = DataSrcDlg_HELP_BTN (hDlg, wNotifyMsg, (HWND)lParam);
        break;

    case IDC_BROWSE_LOG_FILES:
        bReturn = DataSrcDlg_BROWSE_LOG_FILES (hDlg, wNotifyMsg, (HWND)lParam);
        break;

    case IDC_CURRENT_ACTIVITY:
    case IDC_DATA_FROM_LOG_FILE:
    case IDC_PERF_REG:
    case IDC_WBEM_NS:
        bReturn = DataSrcDlg_RadioButton (hDlg, wNotifyMsg, LOWORD(wParam));
        break;

    default:
        break;
    }
    return bReturn;
}

STATIC_BOOL
DataSrcDlg_WM_SYSCOMMAND(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    BOOL bReturn = FALSE;
    UNREFERENCED_PARAMETER(lParam);

    switch (wParam) {
    case SC_CLOSE:
        EndDialog(hDlg, IDOK);
        bReturn = TRUE;
        break;

    default:
        break;
    }
    return bReturn;
}

STATIC_BOOL
DataSrcDlg_WM_CLOSE(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER(hDlg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    return TRUE;
}

STATIC_BOOL
DataSrcDlg_WM_DESTROY(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER(hDlg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    return TRUE;
}

INT_PTR
CALLBACK
DataSrcDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    BOOL bReturn = FALSE;

    switch (message) {
    case WM_INITDIALOG:
        bReturn = DataSrcDlg_WM_INITDIALOG(hDlg, wParam, lParam);
        break;

    case WM_COMMAND:
        bReturn = DataSrcDlg_WM_COMMAND(hDlg, wParam, lParam);
        break;

    case WM_SYSCOMMAND:
        bReturn = DataSrcDlg_WM_SYSCOMMAND(hDlg, wParam, lParam);
        break;

    case WM_CLOSE:
        bReturn = DataSrcDlg_WM_CLOSE(hDlg, wParam, lParam);
        break;

    case WM_DESTROY:
        bReturn = DataSrcDlg_WM_DESTROY(hDlg, wParam, lParam);
        break;

    case WM_CONTEXTMENU:
        {
            INT  iCtrlID = GetDlgCtrlID((HWND) wParam);
            if (0 != iCtrlID) {
                LPWSTR pszHelpFilePath = NULL;
                DWORD  dwLen           = 2 * (MAX_PATH + 1);

                pszHelpFilePath = G_ALLOC(dwLen * sizeof(WCHAR));
                if (pszHelpFilePath != NULL) {
                    if (GetWindowsDirectoryW(pszHelpFilePath, dwLen) > 0) {
                        StringCchCatW(pszHelpFilePath, dwLen, L"\\help\\sysmon.hlp");
                        bReturn = WinHelpW((HWND) wParam,
                                           pszHelpFilePath,
                                           HELP_CONTEXTMENU,
                                           (DWORD_PTR) PdhiDatasrcaulControlIdToHelpIdMap);
                    }
                    G_FREE(pszHelpFilePath);
                }
            }
        }
        break;

    case WM_HELP:
        {
            LPWSTR     pszHelpFilePath = NULL;
            DWORD      dwLen           = 2 * (MAX_PATH + 1);
            LPHELPINFO pInfo           = (LPHELPINFO) lParam;

            if (pInfo->iContextType == HELPINFO_WINDOW) {
                pszHelpFilePath = G_ALLOC(dwLen * sizeof(WCHAR));
                if (pszHelpFilePath != NULL) {
                    if (GetWindowsDirectoryW(pszHelpFilePath, dwLen) > 0) {
                        StringCchCatW(pszHelpFilePath, dwLen, L"\\help\\sysmon.hlp");
                        bReturn = WinHelpW((HWND) wParam,
                                           pszHelpFilePath,
                                           HELP_CONTEXTMENU,
                                           (DWORD_PTR) PdhiDatasrcaulControlIdToHelpIdMap);
                    }
                    G_FREE(pszHelpFilePath);
                }
            }
        } 
        break;

    default:
        break;
    }
    return bReturn;
}

PDH_FUNCTION
PdhSelectDataSourceW(
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPWSTR  szDataSource,
    IN  LPDWORD pcchBufferLength
)
{
    PDHI_DATA_SOURCE_INFO   dsInfo;
    WCHAR                   wTest;
    DWORD                   dwTest;
    PDH_STATUS              pdhStatus     = ERROR_SUCCESS;
    int                     nDlgBoxStatus;
    LPWSTR                  szLocalPath;
    DWORD                   dwLocalLength = 0;

    // TODO post W2k1: PdhiBrowseDataSource should be in try_except

    if (szDataSource == NULL || pcchBufferLength == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        // test buffers and access
        __try {
            // test reading length buffer
            dwLocalLength = * pcchBufferLength;
            dwTest        = dwLocalLength;

            // try reading & writing to the first and last chars in the buffer
            wTest           = szDataSource[0];
            szDataSource[0] = L'\0';
            szDataSource[0] = wTest;

            dwTest --;
            wTest                = szDataSource[dwTest];
            szDataSource[dwTest] = L'\0';
            szDataSource[dwTest] = wTest;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        szLocalPath = G_ALLOC(dwLocalLength * sizeof(WCHAR));
        if (szLocalPath == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else {
            // copy the caller's buffer to the local buffer
            StringCchCopyW(szLocalPath, dwLocalLength, szDataSource);
        }

        if (pdhStatus == ERROR_SUCCESS) {
            if (dwFlags & PDH_FLAGS_FILE_BROWSER_ONLY) {
                PdhiBrowseDataSource( hWndOwner, (LPVOID) szDataSource, & dwLocalLength, TRUE);
            }
            else {
                // show the selection dialog as well
                if (* szDataSource == 0) {
                    // then using current activity
                    dsInfo.dwFlags = PDHI_DATA_SOURCE_CURRENT_ACTIVITY;
                }
                else {
                    if (IsWbemDataSource (szDataSource)) {
                        dsInfo.dwFlags = PDHI_DATA_SOURCE_WBEM_NAMESPACE;
                    }
                    else {
                        dsInfo.dwFlags = PDHI_DATA_SOURCE_LOG_FILE;
                    }
                }
                dsInfo.szDataSourceFile = szLocalPath;
                dsInfo.cchBufferLength  = dwLocalLength;

                // call dialog box
                nDlgBoxStatus = (INT) DialogBoxParamW((HINSTANCE) ThisDLLHandle,
                                                      MAKEINTRESOURCEW(IDD_DATA_SOURCE),
                                                      hWndOwner,
                                                      DataSrcDlgProc,
                                                      (LPARAM) & dsInfo);
                if (nDlgBoxStatus == IDOK) {
                    pdhStatus     = ERROR_SUCCESS;
                    dwLocalLength = dsInfo.cchBufferLength;
                    __try {
                        StringCchCopyW(szDataSource, dwLocalLength, szLocalPath);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } // else, leave the caller's buffer alone
            }

            if (pdhStatus == ERROR_SUCCESS) {
                __try {
                    * pcchBufferLength = dwLocalLength;
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        }
        G_FREE (szLocalPath);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhSelectDataSourceA(
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPSTR   szDataSource,
    IN  LPDWORD pcchBufferLength
)
{
    CHAR        cTest;
    DWORD       dwTest;
    PDH_STATUS  pdhStatus     = ERROR_SUCCESS;
    LPWSTR      szWideBuffer;
    DWORD       dwLocalLength = 0;

    // TODO post W2k1: PdhiBrowseDataSource should be in try_except

    if (szDataSource == NULL || pcchBufferLength == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        // test buffers and access
        __try {
            // test reading length buffer
            dwLocalLength = * pcchBufferLength;
            dwTest        = dwLocalLength;

            // try reading & writing to the first and last chars in the buffer
            cTest           = szDataSource[0];
            szDataSource[0] = '\0';
            szDataSource[0] = cTest;

            dwTest --;
            cTest                = szDataSource[dwTest];
            szDataSource[dwTest] = '\0';
            szDataSource[dwTest] = cTest;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwFlags & PDH_FLAGS_FILE_BROWSER_ONLY) {
            PdhiBrowseDataSource(hWndOwner, (LPVOID) szDataSource, & dwLocalLength, FALSE);
        }
        else {
            // allocate a temporary bufer and convert the ANSI string to a wide
            szWideBuffer = PdhiMultiByteToWideChar(_getmbcp(), szDataSource);
            if (szWideBuffer != NULL) {
                pdhStatus = PdhSelectDataSourceW(hWndOwner, dwFlags, szWideBuffer, & dwLocalLength);
                if (pdhStatus == ERROR_SUCCESS) {
                    // if a null string was returned, then set the argument
                    // to null since the conversion routine will not convert
                    // a null wide string to a null ansi string.
                    if (* szWideBuffer == L'\0') {
                        * szDataSource =  '\0';
                    }
                    else {
                        pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(), szWideBuffer, szDataSource, & dwLocalLength);
                    }
                }
                G_FREE (szWideBuffer);
            }
            else {
                // unable to allocate temporary buffer
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }

        if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
            __try {
                * pcchBufferLength = dwLocalLength;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
    }
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhui\browsdlg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    browsdlg.h

Abstract:

    data types and definitions used by counter browser dialog functions

--*/
#ifndef _BROWSDLG_H_
#define _BROWSDLG_H_

// browsdlg.h
//
typedef struct _PDHI_BROWSE_DLG_INFO {
    PPDH_BROWSE_DLG_CONFIG_W    pWideStruct;
    PPDH_BROWSE_DLG_CONFIG_A    pAnsiStruct;
    HLOG                        hDataSource;
} PDHI_BROWSE_DLG_INFO, *PPDHI_BROWSE_DLG_INFO;

typedef struct _PDHI_BROWSE_DIALOG_DATA {
    PPDHI_BROWSE_DLG_INFO pDlgData;
    WCHAR                 szLastMachineName[MAX_PATH];
    BOOL                  bShowIndex;
    BOOL                  bWildCardInstances;
    BOOL                  bSelectAllInstances;
    BOOL                  bSelectAllCounters;
    BOOL                  bIncludeMachineInPath;
    BOOL                  bLocalCountersOnly;
    BOOL                  bSelectMultipleCounters;
    BOOL                  bAddMultipleCounters;
    BOOL                  bHideDetailLevel;
    BOOL                  bInitializePath;
    BOOL                  bDisableMachineSelection;
    BOOL                  bIncludeCostlyObjects;
    BOOL                  bShowObjects;
    WPARAM                wpLastMachineSel;
    DWORD                 dwCurrentDetailLevel;
} PDHI_BROWSE_DIALOG_DATA, * PPDHI_BROWSE_DIALOG_DATA;

typedef struct _PDHI_DETAIL_INFO {
    DWORD   dwLevelValue;
    DWORD   dwStringResourceId;
} PDHI_DETAIL_INFO, FAR * LPPDHI_DETAIL_INFO;

INT_PTR
CALLBACK
BrowseCounterDlgProc(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

// datasrc.h
//
typedef struct _PDHI_DATA_SOURCE_INFO {
    DWORD   dwFlags;
    LPWSTR  szDataSourceFile;
    DWORD   cchBufferLength;
} PDHI_DATA_SOURCE_INFO, * PPDHI_DATA_SOURCE_INFO;

#define PDHI_DATA_SOURCE_CURRENT_ACTIVITY   0x00000001
#define PDHI_DATA_SOURCE_LOG_FILE           0x00000002
#define PDHI_DATA_SOURCE_WBEM_NAMESPACE     0x00000004

INT_PTR
CALLBACK
DataSrcDlgProc (
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

// expldlg.h
//
#define EDM_EXPLAIN_DLG_CLOSING (WM_USER + 0x100)
#define EDM_UPDATE_EXPLAIN_TEXT (WM_USER + 0x101)
#define EDM_UPDATE_TITLE_TEXT   (WM_USER + 0x102)

INT_PTR
CALLBACK
ExplainTextDlgProc(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

#endif // _BROWSDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhpla\wmiutil.cpp ===
/*****************************************************************************\

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#include <assert.h>
#include <windows.h>
#include <tchar.h>
#include <pdh.h>
#include <pdhp.h>
#include <pdhmsg.h>

#include "plogman.h"

PDH_FUNCTION
PdhPlaWbemConnect( LPWSTR strComputer, IWbemClassObject** pWbemClass, IWbemServices** pWbemServices )
{
    HRESULT hr;
    IWbemLocator *pLocator = NULL;
    LPCWSTR szRootOld = L"root\\wmi";
    LPCWSTR szRootNew = L"root\\perfmon";
    LPCWSTR szMask = L"\\\\%s\\%s";
    BSTR bszClass = SysAllocString(L"SysmonLog");
    BSTR bszNamespaceOld = NULL;
    BSTR bszNamespaceNew = NULL;
    LPWSTR buffer = NULL;

    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if( S_FALSE == hr ){
        // This thread already called CoInitialize
        hr = ERROR_SUCCESS;
    }

    if( NULL != strComputer ){
        DWORD dwSize = wcslen(szRootNew) + wcslen(strComputer) + wcslen( szMask );
        buffer = (LPWSTR)G_ALLOC( dwSize * sizeof(WCHAR) );
        if( buffer == NULL ){
            hr = ERROR_OUTOFMEMORY;
            goto cleanup;
        }
        hr = StringCchPrintf( buffer, dwSize, szMask, strComputer, szRootOld );
        bszNamespaceOld = SysAllocString( buffer );

        hr = StringCchPrintf( buffer, dwSize, szMask, strComputer, szRootNew );
        bszNamespaceNew = SysAllocString( buffer );
    }else{
        bszNamespaceOld = SysAllocString( szRootOld );
        bszNamespaceNew = SysAllocString( szRootNew );
    }

    *pWbemServices = NULL;
    *pWbemClass = NULL;

    hr = CoCreateInstance(
                CLSID_WbemLocator, 
                0, 
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator, 
                (LPVOID*)&pLocator
            );
    CHECK_STATUS( hr );

    hr = pLocator->ConnectServer( 
                bszNamespaceNew, 
                NULL, 
                NULL, 
                NULL, 
                0, 
                NULL, 
                NULL, 
                pWbemServices 
            );

    if( FAILED(hr) ){

        hr = pLocator->ConnectServer( 
                    bszNamespaceOld, 
                    NULL, 
                    NULL, 
                    NULL, 
                    0, 
                    NULL, 
                    NULL, 
                    pWbemServices 
                );
    }

    CHECK_STATUS( hr );

    hr = CoSetProxyBlanket(
            *pWbemServices,
            RPC_C_AUTHN_WINNT,
            RPC_C_AUTHZ_NONE,
            NULL,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, 
            EOAC_NONE
        );                     
    CHECK_STATUS( hr );
    
    hr = (*pWbemServices)->GetObject( bszClass, 0, NULL, pWbemClass, NULL);
    CHECK_STATUS( hr );

cleanup:
    if( pLocator != NULL ){
        pLocator->Release();
    }
    if( ERROR_SUCCESS != hr ){
        if( *pWbemClass != NULL ){
            (*pWbemClass)->Release();
            *pWbemClass = NULL;
        }
        if( *pWbemServices != NULL ){
            (*pWbemServices)->Release();
            *pWbemServices = NULL;
        }
    }
    G_FREE( buffer );
    SysFreeString( bszNamespaceNew );
    SysFreeString( bszNamespaceOld );
    SysFreeString( bszClass );
    
    return hr;
}

PDH_FUNCTION
PdhPlaWbemSetRunAs( 
        LPWSTR strName,
        LPWSTR strComputer,
        LPWSTR strUser,
        LPWSTR strPassword
    )
{
    HRESULT hr = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    IWbemClassObject* pWbemClass = NULL;
    IWbemServices* pWbemServices = NULL;

    __try{
    
        BSTR bszMethodName = SysAllocString( L"SetRunAs" );
        BSTR bszUser = SysAllocString(L"User");
        BSTR bszPassword = SysAllocString(L"Password");
        BSTR bszReturn = SysAllocString(L"ReturnValue");
        LPCWSTR szInstanceMask = L"SysmonLog.Name=\"%s\"";

        IWbemClassObject* pOutInst = NULL;
        IWbemClassObject* pInClass = NULL;
        IWbemClassObject* pInInst = NULL;

        VARIANT var;
        CIMTYPE vtType;
        LONG nFlavor;

        LPWSTR buffer = NULL;
        DWORD dwSize = wcslen( szInstanceMask ) + wcslen( strName );
        buffer = (LPWSTR)G_ALLOC( dwSize * sizeof(WCHAR) );
        if( NULL == buffer ){
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto cleanup;
        }
        hr = StringCchPrintf( buffer, dwSize, szInstanceMask, strName );
        BSTR bszInstancePath = SysAllocString( buffer );

        hr = PdhPlaWbemConnect( strComputer, &pWbemClass, &pWbemServices );
        CHECK_STATUS( hr );

        hr = pWbemClass->GetMethod( bszMethodName, 0, &pInClass, NULL); 
        CHECK_STATUS( hr );

        hr = pInClass->SpawnInstance(0, &pInInst);
        CHECK_STATUS( hr );

        var.vt = VT_BSTR;
        var.bstrVal= SysAllocString( strUser );
        hr = pInInst->Put( bszUser, 0, &var, 0);
        VariantClear(&var);
        CHECK_STATUS( hr );

        var.vt = VT_BSTR;
        var.bstrVal= SysAllocString( strPassword );
        hr = pInInst->Put(bszPassword, 0, &var, 0);
        VariantClear(&var);
        CHECK_STATUS( hr );

        hr = pWbemServices->ExecMethod( bszInstancePath, bszMethodName, 0, NULL, pInInst, &pOutInst, NULL);
        CHECK_STATUS( hr );

        if( pOutInst != NULL ){
            hr = pOutInst->Get( bszReturn, 0, &var, &vtType, &nFlavor );
            CHECK_STATUS( hr );

            if( var.vt == VT_I4 ){
                pdhStatus = var.lVal;
            }
            VariantClear(&var);
        }

cleanup:
        if( pWbemClass != NULL ){
            pWbemClass->Release();
        }
        if( pWbemServices != NULL ){
            pWbemServices->Release();
        }
        if( pInInst != NULL ){
            pInInst->Release();
        }
        if( pOutInst != NULL ){
            pOutInst->Release();
        }

        SysFreeString( bszInstancePath );
        SysFreeString( bszMethodName );
        SysFreeString( bszUser );
        SysFreeString( bszPassword );
        SysFreeString( bszReturn );
    
        G_FREE( buffer );

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        hr = GetLastError();
    }

    if( ERROR_SUCCESS != pdhStatus ){
        return pdhStatus;
    }

    return PlaiErrorToPdhStatus( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhui\browsdlg.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    browsdlg.c

Abstract:

    counter name browsing dialog box functions

Revision History

    Bob Watson (a-robw) Oct-95  Created

--*/
#include <windows.h>
#include <winperf.h>
#include "mbctype.h"
#include "strsafe.h"
#include "pdh.h"
#include "pdhidef.h"
#include "pdhdlgs.h"
#include "pdhmsg.h"
#include "perftype.h"
#include "strings.h"
#include "browsdlg.h"
#include "resource.h"

#pragma warning ( disable : 4213)

// global data strings to load into combo box to select counter filtering level

ULONG
PdhiBrowseraulControlIdToHelpIdMap[] =
{
    IDC_USE_LOCAL_MACHINE,      IDH_USE_LOCAL_MACHINE,
    IDC_SELECT_MACHINE,         IDH_SELECT_MACHINE,
    IDC_MACHINE_COMBO,          IDH_MACHINE_COMBO,
    IDC_COUNTER_DETAIL_COMBO,   IDH_COUNTER_DETAIL_COMBO,
    IDC_OBJECT_COMBO,           IDH_OBJECT_COMBO,
    IDC_ALL_COUNTERS,           IDH_ALL_COUNTERS,
    IDC_USE_COUNTER_LIST,       IDH_USE_COUNTER_LIST,
    IDC_COUNTER_LIST,           IDH_COUNTER_LIST,
    IDC_ALL_INSTANCES,          IDH_ALL_INSTANCES,
    IDC_USE_INSTANCE_LIST,      IDH_USE_INSTANCE_LIST,
    IDC_INSTANCE_LIST,          IDH_INSTANCE_LIST,
    IDC_EXPLAIN_BTN,            IDH_EXPLAIN_BTN,
    IDC_OBJECT_LIST,            IDH_OBJECT_LIST,
    0,0
};

PDHI_DETAIL_INFO PdhiDetailInfo[] = {
    { PERF_DETAIL_NOVICE,    IDS_DETAIL_NOVICE   },
    { PERF_DETAIL_ADVANCED,  IDS_DETAIL_ADVANCED },
    { PERF_DETAIL_EXPERT,    IDS_DETAIL_EXPERT   },
    { PERF_DETAIL_WIZARD,    IDS_DETAIL_WIZARD   },
    { 0,0 }
};

static HWND hExplainDlg = NULL;

//
//  Function references
//

STATIC_BOOL
PdhiLoadMachineObjects(
    HWND    hDlg,
    BOOL    bRefresh
);

STATIC_BOOL
PdhiLoadCountersAndInstances(
    HWND    hDlg
);

STATIC_BOOL
PdhiBrowseCtrDlg_MACHINE_BUTTON(
    HWND    hDlg,
    WORD    wNotifyMsg,
    HWND    hWndControl
);

__inline
PDH_STATUS
PdhiCopyString(
    LPBYTE  * pszNextString,
    LPWSTR    szWorkBuffer,
    LPDWORD   pdwRemaining,
    BOOL      bUnicode
)
{
    PDH_STATUS pdhStatus    = ERROR_SUCCESS;
    DWORD      dwSize       = 0;
    DWORD      dwRemaining  = * pdwRemaining;
    LPBYTE     szNextString = * pszNextString;

    if (bUnicode) {
        dwSize = lstrlenW(szWorkBuffer);
        if (dwSize < dwRemaining) {
            StringCchCopyW((LPWSTR) szNextString, dwRemaining, szWorkBuffer);
            szNextString += dwSize * sizeof(WCHAR);
            * ((LPWSTR) szNextString) = L'\0';
            szNextString += sizeof(WCHAR);
        }
        else {
            pdhStatus = PDH_MORE_DATA;
        }
        dwSize ++;
    }
    else {
        dwSize    = dwRemaining;
        pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(), szWorkBuffer, (LPSTR) szNextString, & dwSize);
        if (pdhStatus == ERROR_SUCCESS) {
            szNextString = szNextString + sizeof(CHAR) * (lstrlenA((LPSTR) szNextString) + 1);
        }
    }

    if (dwRemaining >= dwSize) {
        dwRemaining -= dwSize;
    }
    else {
        dwRemaining = 0;
        pdhStatus   = PDH_MORE_DATA;
    }

    * pdwRemaining  = dwRemaining;
    * pszNextString = szNextString;
    return pdhStatus;
}

LPWSTR
PdhiGetDlgText(
    HWND  hDlg,
    INT   hDlgItem
)
{
    LPWSTR szText   = NULL;
    DWORD  dwLength = 0;
    HWND   hWndItem = GetDlgItem(hDlg, hDlgItem);

    if (hWndItem != NULL) {
        dwLength = GetWindowTextLength(hWndItem);
        if (dwLength != 0) {
            dwLength ++;
            szText = G_ALLOC(dwLength * sizeof(WCHAR));
            if (szText != NULL) {
                GetWindowTextW(hWndItem, szText, dwLength);
            }
        }
    }
    return szText;
}

LRESULT
PdhiGetListText(
    HWND     hDlg,
    INT      iDlgItem,
    INT      iItem,
    LPWSTR * lpszName,
    PDWORD   pdwLength
)
{
    LPWSTR  szText   = * lpszName;
    DWORD   dwLength = * pdwLength;
    HWND    hWndItem = GetDlgItem(hDlg, iDlgItem);
    LRESULT iTextLen = LB_ERR;

    if (hWndItem != NULL) {
        iTextLen = SendMessageW(hWndItem,  LB_GETTEXTLEN, iItem, 0);
        if (iTextLen != LB_ERR) {
            if (((DWORD) (iTextLen + 1)) > dwLength) {
                LPWSTR szTmp  = szText;
                dwLength  = (DWORD) iTextLen + 1;
                if (szTmp == NULL) {
                    szText = G_ALLOC(dwLength * sizeof(WCHAR));
                }
                else {
                    szText = G_REALLOC(szTmp, dwLength * sizeof(WCHAR));
                }
                if (szText == NULL) {
                    G_FREE(szTmp);
                }
            }
            if (szText != NULL) {
                ZeroMemory(szText, dwLength * sizeof(WCHAR));
                iTextLen = SendMessageW(hWndItem, LB_GETTEXT, iItem, (LPARAM) szText);
            }
        }
    }
    * pdwLength = dwLength;
    * lpszName  = szText;
    return iTextLen;
}

STATIC_BOOL
PdhiLoadNewMachine(
    HWND    hDlg,
    LPCWSTR szNewMachineName,
    BOOL    bAdd
)
/*++
Routine Description:
    Connects to a new machine and loads the necessary performance data
        from that machine.

Arguments:
    IN  HWND    hDlg
        Handle to dialog box containing the combo & list boxes to fill
    IN  LPCWSTR szNewMachineName
        Machine name to open and obtain data from

Return Value:
    TRUE new machine connected and data loaded
    FALSE unable to connect to machine or obtain performance data from it.
--*/
{
    HWND                     hWndMachineCombo;
    PPDHI_BROWSE_DIALOG_DATA pData;
    LONG                     lMatchIndex;
    PDH_STATUS               status;
    int                      mbStatus;
    BOOL                     bReturn = FALSE;
    DWORD                    dwDataSourceType;
    LPWSTR                   szMsg;

    // acquire the data block associated with this dialog instance
    pData = (PPDHI_BROWSE_DIALOG_DATA) GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData != NULL) {
        // get window handle of the dialog box
        hWndMachineCombo = GetDlgItem(hDlg, IDC_MACHINE_COMBO);

        // not in list so try to add it as long as the data source
        // is "Current Activity" (ie. == NULL)  For Log Files, only
        // the machines listed may be selected.

        dwDataSourceType = DataSourceTypeH(pData->pDlgData->hDataSource);
        if (dwDataSourceType != DATA_SOURCE_LOGFILE) {
            PPERF_MACHINE pMachine = GetMachine(
                            (LPWSTR) szNewMachineName, 0, PDH_GM_UPDATE_NAME | PDH_GM_UPDATE_PERFNAME_ONLY);
            if (pMachine != NULL) {
                pMachine->dwRefCount --;
                RELEASE_MUTEX(pMachine->hMutex);

                if (pMachine->dwStatus == ERROR_SUCCESS) {
                    if (bAdd) {
                        // if successful, add string to combo box
                        lMatchIndex = (LONG) SendMessageW(hWndMachineCombo, CB_ADDSTRING, 0, (LPARAM) szNewMachineName);
                        SendMessageW(hWndMachineCombo, CB_SETCURSEL, (WPARAM) lMatchIndex, 0);
                    }
                    // update other controls in this dialog
                    PdhiLoadMachineObjects(hDlg, FALSE);   // no need to update since it was just connected
                    PdhiLoadCountersAndInstances(hDlg);
                    SendMessageW(hDlg, WM_COMMAND,
                                 MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                                 (LPARAM) GetDlgItem(hDlg, IDC_COUNTER_LIST));
                    bReturn = TRUE;
                }
                else {
                    SetLastError(pMachine->dwStatus);
                }
            }
            if (! bReturn) {
                status = GetLastError();
                if (status == PDH_QUERY_PERF_DATA_TIMEOUT) {
                    szMsg = GetStringResource(IDS_COLLECT_TIMEOUT);
                }
                else {
                    szMsg = GetStringResource(IDS_ERR_UNABLE_TO_CONNECT);
                }
                if (szMsg != NULL) {
                    mbStatus = MessageBoxW(hDlg, szMsg, NULL, MB_ICONEXCLAMATION | MB_TASKMODAL | MB_OK);
                    if (mbStatus == IDCANCEL) {
                        SetFocus(GetDlgItem(hDlg, IDC_MACHINE_COMBO));
                    }
                    else {
                        SendMessageW(hWndMachineCombo, CB_SETCURSEL, pData->wpLastMachineSel, 0);
                    }
                    G_FREE(szMsg);
                }
                else {
                    MessageBeep(MB_ICONEXCLAMATION);
                }
            }
        }
        else {
            szMsg = GetStringResource(IDS_ERR_MACHINE_NOT_IN_LOGFILE);
            if (szMsg != NULL) {
                mbStatus = MessageBoxW(hDlg, szMsg, NULL, MB_ICONEXCLAMATION | MB_TASKMODAL | MB_OK);
                G_FREE (szMsg);
            }
            else {
                MessageBeep(MB_ICONEXCLAMATION);
            }
            // re-select the last machine

            lMatchIndex = (long) SendMessageW(hWndMachineCombo,
                                              CB_FINDSTRINGEXACT,
                                              (WPARAM) -1,
                                              (LPARAM) pData->szLastMachineName);
            SendMessageW(hWndMachineCombo, CB_SETCURSEL, (WPARAM) lMatchIndex, 0);
        }
    }
    return bReturn;
}

STATIC_BOOL
PdhiSelectItemsInPath(
    HWND hDlg
)
/*++
Routine Description:
    Selects the items in the list box based on the counter path
        string in the shared buffer.

Arguments:
    IN  HWND    hDlg
        Handle to the dialog window containing the controls

Return Value:
    TRUE if successful,
    FALSE if not
--*/
{
    // regular stack variables
    PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElementsW = NULL;
    PPDH_COUNTER_PATH_ELEMENTS_A pCounterPathElementsA = NULL;
    LPWSTR                       wszMachineName        = NULL;
    PDH_STATUS                   status;
    PPDHI_BROWSE_DIALOG_DATA     pData;
    BOOL                         bReturn               = FALSE;
    DWORD                        dwBufferSize;
    HWND                         hWndMachineCombo;
    HWND                         hWndObjectCombo;
    HWND                         hWndCounterList;
    HWND                         hWndInstanceList;
    LONG                         lIndex;

    // reset the last error value
    SetLastError(ERROR_SUCCESS);

    // get this dialog's user data
    pData = (PPDHI_BROWSE_DIALOG_DATA) GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
        goto Cleanup;
    }

    hWndMachineCombo = GetDlgItem(hDlg, IDC_MACHINE_COMBO);
    if (pData->bShowObjects) {
        hWndObjectCombo  = GetDlgItem(hDlg, IDC_OBJECT_LIST);
        if (hWndMachineCombo == NULL || hWndObjectCombo == NULL) {
            goto Cleanup;
        }
    }
    else {
        hWndObjectCombo  = GetDlgItem(hDlg, IDC_OBJECT_COMBO);
        hWndCounterList  = GetDlgItem(hDlg, IDC_COUNTER_LIST);
        hWndInstanceList = GetDlgItem(hDlg, IDC_INSTANCE_LIST);
        if (hWndMachineCombo == NULL || hWndObjectCombo == NULL
                    || hWndCounterList == NULL || hWndInstanceList == NULL) {
            goto Cleanup;
        }
    }

    // Call the right conversion function based on user's buffer

    if (pData->pDlgData->pWideStruct != NULL) {
        // UNICODE/ wide characters
        dwBufferSize = sizeof(PDH_COUNTER_PATH_ELEMENTS_W) + (PDH_MAX_COUNTER_PATH + 5) * sizeof(WCHAR);
        pCounterPathElementsW = (PPDH_COUNTER_PATH_ELEMENTS_W) G_ALLOC(dwBufferSize);
        if (pCounterPathElementsW == NULL) {
            status = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else {
            status = PdhParseCounterPathW(pData->pDlgData->pWideStruct->szReturnPathBuffer,
                                          pCounterPathElementsW,
                                          & dwBufferSize,
                                          0);
            while (status == PDH_MORE_DATA) {
                G_FREE(pCounterPathElementsW);
                pCounterPathElementsW = (PPDH_COUNTER_PATH_ELEMENTS_W) G_ALLOC(dwBufferSize);
                if (pCounterPathElementsW == NULL) {
                    status = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                else {
                    status = PdhParseCounterPathW(pData->pDlgData->pWideStruct->szReturnPathBuffer,
                                                  pCounterPathElementsW,
                                                  & dwBufferSize,
                                                  0);
                }
            }
        }
        if (status == ERROR_SUCCESS) {
            // select entry in each list box
            // select machine entry. Load machine if necessary
            lIndex = (LONG) SendMessageW(hWndMachineCombo,
                                         CB_FINDSTRINGEXACT,
                                         (WPARAM) -1,
                                         (LPARAM) pCounterPathElementsW->szMachineName);
            if (lIndex == CB_ERR) {
                // try adding the machine
                if (! PdhiLoadNewMachine(hDlg, pCounterPathElementsW->szMachineName, TRUE)) {
                    // give up
                    goto Cleanup;
                }
            }
            else {
                // the machine has been found so select it
                SendMessageW(hWndMachineCombo, CB_SETCURSEL, (WPARAM) lIndex, 0);
                // update other fields
                // no need to update since it was just connected
                if (! PdhiLoadNewMachine(hDlg, pCounterPathElementsW->szMachineName, FALSE)) {
                    // give up
                    goto Cleanup;
                }
            }

            // select the current object
            lIndex = (LONG) SendMessageW(hWndObjectCombo,
                                         CB_FINDSTRING,
                                        (WPARAM) -1,
                                        (LPARAM) pCounterPathElementsW->szObjectName);
            if (lIndex != CB_ERR) {
                SendMessageW(hWndObjectCombo, CB_SETCURSEL, (WPARAM) lIndex, 0);

                if (pData->bShowObjects) {
                    bReturn = TRUE;
                }
                else {
                    // update the counters for this object
                    PdhiLoadCountersAndInstances(hDlg);
                    // now select the counter
                    lIndex = (LONG)SendMessageW(hWndCounterList,
                                                LB_FINDSTRING,
                                                (WPARAM) -1,
                                                (LPARAM) pCounterPathElementsW->szCounterName);
                    if (lIndex != LB_ERR) {
                        if (pData->bSelectMultipleCounters) {
                            SendMessageW(hWndCounterList, LB_SETSEL, FALSE, (LPARAM) -1);
                            SendMessageW(hWndCounterList, LB_SETSEL, TRUE, lIndex);
                            SendMessageW(hWndCounterList, LB_SETCARETINDEX, (WPARAM) lIndex, MAKELPARAM(FALSE, 0));
                        }
                        else {
                            SendMessageW(hWndCounterList, LB_SETCURSEL, lIndex, 0);
                        }
                        // display explain text if necessary
                        SendMessageW(hDlg,
                                     WM_COMMAND,
                                     MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                                     (LPARAM) GetDlgItem(hDlg, IDC_COUNTER_LIST));
                        bReturn = TRUE;
                    }
                }
            }
        } // else unable to read path so exit
    }
    else {
        // ANSI characters
        dwBufferSize = sizeof(PDH_COUNTER_PATH_ELEMENTS_W) + (PDH_MAX_COUNTER_PATH + 5) * sizeof(CHAR);
        pCounterPathElementsA = (PPDH_COUNTER_PATH_ELEMENTS_A) G_ALLOC(dwBufferSize);
        if (pCounterPathElementsA == NULL) {
            status = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else {
            status = PdhParseCounterPathA(pData->pDlgData->pAnsiStruct->szReturnPathBuffer,
                                          pCounterPathElementsA,
                                          & dwBufferSize,
                                          0);
            while (status == PDH_MORE_DATA) {
                G_FREE(pCounterPathElementsA);
                pCounterPathElementsA = (PPDH_COUNTER_PATH_ELEMENTS_A) G_ALLOC(dwBufferSize);
                if (pCounterPathElementsA == NULL) {
                    status = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                else {
                    status = PdhParseCounterPathA(pData->pDlgData->pAnsiStruct->szReturnPathBuffer,
                                                  pCounterPathElementsA,
                                                  & dwBufferSize,
                                                  0);
                }
            }
        }
        if (status == ERROR_SUCCESS) {
            // select entry in each list box
            // select machine entry. Load machine if necessary

            lIndex = (LONG) SendMessageA(hWndMachineCombo,
                                         CB_FINDSTRINGEXACT,
                                         (WPARAM) -1,
                                         (LPARAM) pCounterPathElementsA->szMachineName);
            if (lIndex == CB_ERR) {
                // try adding the machine
                // convert ansi buffer to wide char first
                wszMachineName = PdhiMultiByteToWideChar(_getmbcp(), pCounterPathElementsA->szMachineName);
                if (wszMachineName == NULL) {
                    goto Cleanup;
                }
                if (! PdhiLoadNewMachine(hDlg, wszMachineName, TRUE)) {
                    // give up
                    goto Cleanup;
                }
            }
            else {
                // the machine has been found so select it
                SendMessageA(hWndMachineCombo, CB_SETCURSEL, (WPARAM) lIndex, 0);
                // update other fields
                PdhiLoadMachineObjects(hDlg, FALSE);   // no need to update since it was just connected
            }

            // select the current object
            lIndex = (LONG) SendMessageA(hWndObjectCombo,
                                         CB_FINDSTRING,
                                         (WPARAM) -1,
                                         (LPARAM) pCounterPathElementsA->szObjectName);
            if (lIndex != CB_ERR) {
                SendMessageA(hWndObjectCombo, CB_SETCURSEL, (WPARAM) lIndex, 0);
                if (pData->bShowObjects) {
                    bReturn = TRUE;
                }
                else {
                    // update the counters for this object
                    PdhiLoadCountersAndInstances(hDlg);
                    // now select the counter
                    lIndex = (LONG)SendMessageA(hWndCounterList,
                                                LB_FINDSTRING,
                                                (WPARAM) -1,
                                                (LPARAM) pCounterPathElementsA->szCounterName);
                    if (lIndex != LB_ERR) {
                        if (pData->bSelectMultipleCounters) {
                            SendMessageA(hWndCounterList, LB_SETSEL, FALSE, (LPARAM) -1);
                            SendMessageA(hWndCounterList, LB_SETSEL, TRUE, lIndex);
                            SendMessageA(hWndCounterList, LB_SETCARETINDEX, (WPARAM) lIndex, MAKELPARAM(FALSE, 0));
                        }
                        else {
                            SendMessageA(hWndCounterList, LB_SETCURSEL, lIndex, 0);
                        }
                        // display explain text if necessary
                        SendMessage(hDlg,
                                    WM_COMMAND,
                                    MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                                    (LPARAM) GetDlgItem(hDlg, IDC_COUNTER_LIST));
                        bReturn = TRUE;
                    }
                }
            }
        } // else unable to read path so exit
    }

Cleanup:
    G_FREE(pCounterPathElementsW);
    G_FREE(pCounterPathElementsA);
    G_FREE(wszMachineName);
    return bReturn;
}

STATIC_DWORD
PdhiLoadDetailLevelCombo(
    HWND    hDlg,
    DWORD   dwInitialLevel
)
/*++
Routine Description:
    Loads the Detail Level Combo box with the strings and ID's
        defined by the PdhiDetailInfo string array above.

Arguments:
    IN  HWND    hDlg
        Handle to the dialog box containing the combo box
    IN  DWORD   dwInitialLevel
        the intitial detail level to select in the combo box.

Return Value:
    Returns the selected level or 0 if an error ocurred.
--*/
{
    HWND    hWndCombo;
    DWORD   dwIndex;
    DWORD   dwStringLength;
    DWORD   dwDefaultIndex  = 0;
    DWORD   dwSelectedLevel = 0;
    DWORD   dwThisCbIndex;
    WCHAR   szTempBuffer[MAX_PATH + 1]; // for loading string resource

    hWndCombo = GetDlgItem(hDlg, IDC_COUNTER_DETAIL_COMBO);

    // load all combo box strings from static data array defined above
    for (dwIndex = 0; PdhiDetailInfo[dwIndex].dwLevelValue > 0; dwIndex ++) {
        // load the string resource for this string
        ZeroMemory(szTempBuffer, (MAX_PATH + 1) * sizeof(WCHAR));
        dwStringLength = LoadStringW(ThisDLLHandle,
                                     PdhiDetailInfo[dwIndex].dwStringResourceId,
                                     szTempBuffer,
                                     MAX_PATH);
        if (dwStringLength == 0) {
            // unable to read the string in, so
            // substitute the value for the string
            _ltow(PdhiDetailInfo[dwIndex].dwLevelValue, szTempBuffer, 10);
        }
        // load the strings into the combo box in the same order they
        // were described in the array above
        dwThisCbIndex = (DWORD) SendMessageW(hWndCombo, CB_INSERTSTRING, (WPARAM) -1, (LPARAM) szTempBuffer);

        // set the initial CB entry to the highest item <= to the
        // desired default level
        if (dwThisCbIndex != CB_ERR) {
            // set item data to be the corresponding detail level
            SendMessageW(hWndCombo,
                         CB_SETITEMDATA,
                         (WPARAM) dwThisCbIndex,
                         (LPARAM) PdhiDetailInfo[dwIndex].dwLevelValue);
            // save default selection if it matches.
            if (PdhiDetailInfo[dwIndex].dwLevelValue <= dwInitialLevel) {
                dwDefaultIndex  = dwThisCbIndex;
                dwSelectedLevel = PdhiDetailInfo[dwIndex].dwLevelValue;
            }
        }
    }
    // select desired default entry
    SendMessageW(hWndCombo, CB_SETCURSEL, (WPARAM) dwDefaultIndex, 0);

    return dwSelectedLevel;
}

STATIC_BOOL
PdhiLoadKnownMachines(
    HWND    hDlg
)
/*++
Routine Description:
    Get the list of machines that are currently connected and disply
        them in the machine list box.

Arguments:
    IN  HWND    hDlg
        Handle to the dialog window containing the controls

Return Value:
    TRUE if successful,
    FALSE if not
--*/
{
    LPWSTR                    mszMachineList = NULL;
    LPWSTR                    szThisMachine;
    DWORD                     dwLength;
    PDH_STATUS                status;
    HWND                      hMachineListWnd;
    HCURSOR                   hOldCursor;
    PPDHI_BROWSE_DIALOG_DATA  pData;
    BOOL                      bReturn = FALSE;

    // display wait cursor since this is potentially time consuming
    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // get this dialog's user data
    pData = (PPDHI_BROWSE_DIALOG_DATA) GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
        goto Cleanup;
    }


    // get window handle to Machine list combo box
    hMachineListWnd = GetDlgItem(hDlg, IDC_MACHINE_COMBO);

    // clear machine combo box
    SendMessageW(hMachineListWnd, CB_RESETCONTENT, 0, 0);

    // get list of connected machines from PDH library
    dwLength = 0;
    status   = PdhEnumMachinesHW(pData->pDlgData->hDataSource, mszMachineList, & dwLength);
    while (status == PDH_MORE_DATA) {
        G_FREE(mszMachineList);
        mszMachineList = G_ALLOC(dwLength * sizeof(WCHAR));
        if (mszMachineList == NULL) {
            status = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else {
            status = PdhEnumMachinesHW(pData->pDlgData->hDataSource, mszMachineList, & dwLength);
        }
    }

    if (status == ERROR_SUCCESS) {
        long lMatchIndex;

        // update the combo box
        // go through MSZ and load each string into combo box
        for (szThisMachine = mszMachineList; * szThisMachine != L'\0'; szThisMachine += lstrlenW(szThisMachine) + 1) {
            // add to the list box and let the list box sort them
            SendMessageW(hMachineListWnd, CB_ADDSTRING, 0, (LPARAM) szThisMachine);
        }
        lMatchIndex = (long) SendMessageW(hMachineListWnd,
                                          CB_FINDSTRINGEXACT,
                                          (WPARAM) -1,
                                          (LPARAM) szStaticLocalMachineName);
        if (lMatchIndex == CB_ERR) {
            lMatchIndex = 0;
        }
        SendMessageW(hMachineListWnd, CB_SETCURSEL, (WPARAM) lMatchIndex, 0);

        // the "current" machine has not been defined, then
        // do it now
        GetWindowTextW(hMachineListWnd, (LPWSTR) pData->szLastMachineName, MAX_PATH);

        bReturn = TRUE;
    }
    else {
        // no machines, so select local button and disable the edit window
        CheckRadioButton(hDlg, IDC_USE_LOCAL_MACHINE, IDC_SELECT_MACHINE, IDC_USE_LOCAL_MACHINE);
        PdhiBrowseCtrDlg_MACHINE_BUTTON(hDlg, BN_CLICKED, GetDlgItem(hDlg, IDC_USE_LOCAL_MACHINE));
        bReturn = TRUE;
    }

Cleanup:
    // restore cursor
    SetCursor(hOldCursor);
    G_FREE(mszMachineList);
    // return status of function

    return bReturn;
}

STATIC_BOOL
PdhiLoadMachineObjects(
    HWND    hDlg,
    BOOL    bRefresh
)
/*++
Routine Description:
    For the currently selected machine, load the object list box
        with the objects supported by that machine. If the bRefresh
        flag is TRUE, then query the system for the current perf data
        before loading the list box.

Arguments:
    IN  HWND    hDlg
        Window handle of parent dialog box
    IN  BOOL    bRefresh
        TRUE = Query performance data of system before updating
        FALSE = Use the current system perf data to load the objects from

Return Value:
    TRUE if successful,
    FALSE if not

--*/
{
    LPWSTR                   szMachineName   = NULL;
    LPWSTR                   szDefaultObject = NULL;
    LPWSTR                   mszObjectList   = NULL;
    DWORD                    dwLength;
    LPWSTR                   szThisObject;
    HCURSOR                  hOldCursor;
    HWND                     hObjectListWnd;
    PPDHI_BROWSE_DIALOG_DATA pData;
    PDH_STATUS               pdhStatus;
    DWORD                    dwReturn;
    DWORD                    dwDetailLevel;
    LPWSTR                   szMsg;
    LRESULT                  nEntry;
    DWORD                    dwFlags;

    // save old cursor and display wait cursor
    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // get the pointer to the dialog's user data
    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
        pdhStatus = PDH_INVALID_HANDLE;
        goto Cleanup;
    }

    hObjectListWnd = pData->bShowObjects ? GetDlgItem(hDlg, IDC_OBJECT_LIST) : GetDlgItem(hDlg, IDC_OBJECT_COMBO);
    if (hObjectListWnd == NULL) {
        pdhStatus = PDH_INVALID_HANDLE;
        goto Cleanup;
    }

    szMachineName = PdhiGetDlgText(hDlg, IDC_MACHINE_COMBO);
    if (szMachineName == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    if (lstrcmpiW(szMachineName, pData->szLastMachineName) != 0) {
        StringCchCopyW(pData->szLastMachineName, MAX_PATH, szMachineName);
    }

    if (! pData->bShowObjects) {
        // first clear out any old contents
        SendMessageW(hObjectListWnd, CB_RESETCONTENT, 0, 0);
    }
    else {
        SendMessageW(hObjectListWnd, LB_RESETCONTENT, 0, 0);
    }

    // get object list from the PDH
    dwDetailLevel  = pData->dwCurrentDetailLevel;
    dwDetailLevel |= pData->bIncludeCostlyObjects ? PERF_DETAIL_COSTLY : 0;
    dwLength       = 0;
    pdhStatus      = PdhEnumObjectsHW(pData->pDlgData->hDataSource,
                                      szMachineName,
                                      mszObjectList,
                                      & dwLength,
                                      dwDetailLevel,
                                      bRefresh);
    while (pdhStatus == PDH_MORE_DATA) {
        // then realloc and try again, but only once
        G_FREE(mszObjectList);
        mszObjectList = G_ALLOC (dwLength * sizeof(WCHAR));
        if (mszObjectList == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else {
            // No need to call RegQueryValueEx(HKEY_PERFORMANCE_DATA, "Global", ...) again.
            // The first one already does that.
            //
            pdhStatus = PdhEnumObjectsHW(pData->pDlgData->hDataSource,
                                         szMachineName,
                                         mszObjectList,
                                         & dwLength,
                                         dwDetailLevel,
                                         FALSE);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        EnableWindow(hObjectListWnd, TRUE);
        // load object list to the list (combo) box
        for (szThisObject = mszObjectList; *szThisObject != L'\0'; szThisObject += lstrlenW(szThisObject) + 1) {
            if (pData->bShowObjects) {
                DWORD dwCounterListLength  = 0;
                DWORD dwInstanceListLength = 0;

                pdhStatus = PdhEnumObjectItemsHW(pData->pDlgData->hDataSource,
                                                 szMachineName,
                                                 szThisObject,
                                                 NULL,
                                                 & dwCounterListLength,
                                                 NULL,
                                                 & dwInstanceListLength,
                                                 PERF_DETAIL_WIZARD,
                                                 0);
                if (pdhStatus != ERROR_SUCCESS && pdhStatus != PDH_MORE_DATA) {
                    dwInstanceListLength = 0;
                }
                if (dwInstanceListLength == 0 || dwInstanceListLength > 2) {
                    // send to list box control
                    nEntry = SendMessageW(hObjectListWnd, LB_ADDSTRING, 0, (LPARAM) szThisObject);
                    dwFlags = 0;
                    if (dwInstanceListLength > 2) {
                        dwFlags |= PDH_OBJECT_HAS_INSTANCES;
                    }
                    SendMessageW(hObjectListWnd, LB_SETITEMDATA, (WPARAM) nEntry, (LPARAM) dwFlags);                
                }
                pdhStatus = ERROR_SUCCESS;
            }
            else {
                // send to combo box
                // add each string...
                SendMessageW(hObjectListWnd, CB_ADDSTRING, 0, (LPARAM)szThisObject);
            }
        }

        if (! pData->bShowObjects) {
            // get default Object
            dwLength  = 0;
            pdhStatus = PdhGetDefaultPerfObjectHW(pData->pDlgData->hDataSource,
                                                  szMachineName,
                                                  szDefaultObject,
                                                  & dwLength);
            while (pdhStatus == PDH_MORE_DATA) {
                G_FREE(szDefaultObject);
                szDefaultObject = G_ALLOC(dwLength * sizeof(WCHAR));
                if (szDefaultObject == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                else {
                    pdhStatus = PdhGetDefaultPerfObjectHW(pData->pDlgData->hDataSource,
                                                          szMachineName,
                                                          szDefaultObject,
                                                          & dwLength);
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                // and select it if it's present (which it should be)
                dwReturn = (DWORD) SendMessageW(hObjectListWnd, CB_SELECTSTRING, (WPARAM) -1, (LPARAM) szDefaultObject);
                if (dwReturn == CB_ERR) pdhStatus = PDH_CSTATUS_NO_OBJECT;
            }
            if (pdhStatus != ERROR_SUCCESS) {
                // default object not found in list so select the first one
                SendMessageW(hObjectListWnd, CB_SETCURSEL, 0, 0);
            }
        }
    }
    else {
        // unable to obtain object list so display message and disable list
        szMsg = GetStringResource(IDS_BRWS_NO_OBJECTS);
        if (szMsg != NULL) {
            if (! pData->bShowObjects) {
                SendMessageW(hObjectListWnd, CB_ADDSTRING, 0, (LPARAM) szMsg);
            }
            else {
                SendMessageW(hObjectListWnd, LB_ADDSTRING, 0, (LPARAM) szMsg);
            }
            G_FREE(szMsg);
            EnableWindow(hObjectListWnd, FALSE);       
        }
    }

Cleanup:
    // restore cursor
    SetCursor(hOldCursor);

    G_FREE(szMachineName);
    G_FREE(szDefaultObject);
    G_FREE(mszObjectList);

    // return status
    return (pdhStatus == ERROR_SUCCESS) ? (TRUE) : (FALSE);
}

STATIC_BOOL
PdhiLoadCountersAndInstances(
    HWND    hDlg
)
/*++
Routine Description:
    Load the counters and instances of the selected object on the
        current machine

Arguments:
    IN  HWND    hDlg
        Window handle of the dialog box containing these controls

Return Value:
    TRUE if successful,
    FALSE if not
--*/
{
    LPWSTR                   szMachineName    = NULL;
    LPWSTR                   szObjectName     = NULL;
    DWORD                    dwLength;
    LPWSTR                   szDefaultCounter = NULL;
    LPWSTR                   szInstanceString = NULL;
    LPWSTR                   szIndexStringPos;
    DWORD                    dwDefaultIndex;
    DWORD                    dwCounterListLength;
    DWORD                    dwInstanceListLength;
    DWORD                    dwInstanceMatch;
    DWORD                    dwInstanceIndex;
    DWORD                    dwInstanceCount;
    LPWSTR                   szThisItem;
    HWND                     hWndCounterListBox;
    HWND                     hWndInstanceListBox;
    HCURSOR                  hOldCursor;
    PPDHI_BROWSE_DIALOG_DATA pData;
    PDH_STATUS               pdhStatus;
    LPWSTR                   mszCounterList  = NULL;
    LPWSTR                   mszInstanceList = NULL;
    LPWSTR                   mszTmpList;
    LPWSTR                   szMsg;
    HDC                      hDcListBox;
    SIZE                     Size;
    LONG                     dwHorizExtent;
    BOOL                     bReturn = FALSE;

    // save current cursor and display wait cursor
    hOldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

    // get the pointer to the dialog's user data
    pData = (PPDHI_BROWSE_DIALOG_DATA) GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
        pdhStatus = PDH_INVALID_HANDLE;
        goto Cleanup;
    }

    hWndCounterListBox  = GetDlgItem(hDlg, IDC_COUNTER_LIST);
    hWndInstanceListBox = GetDlgItem(hDlg, IDC_INSTANCE_LIST);
    if (hWndCounterListBox == NULL || hWndInstanceListBox == NULL) {
        pdhStatus = PDH_INVALID_HANDLE;
        goto Cleanup;
    }

    szMachineName = PdhiGetDlgText(hDlg, IDC_MACHINE_COMBO);
    szObjectName  = PdhiGetDlgText(hDlg, IDC_OBJECT_COMBO);
    if (szMachineName == NULL || szObjectName == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    dwCounterListLength  = 0;
    dwInstanceListLength = 0;
    pdhStatus = PdhEnumObjectItemsHW(pData->pDlgData->hDataSource,
                                     szMachineName,
                                     szObjectName,
                                     mszCounterList,
                                     & dwCounterListLength,
                                     mszInstanceList,
                                     & dwInstanceListLength,
                                     pData->dwCurrentDetailLevel,
                                     0);
    while (pdhStatus == PDH_MORE_DATA) {
        if (dwCounterListLength > 0) {
            G_FREE(mszCounterList);
            mszCounterList  = G_ALLOC(dwCounterListLength  * sizeof(WCHAR));
            if (mszCounterList == NULL) pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        if (dwInstanceListLength > 0) {
            G_FREE(mszInstanceList);
            mszInstanceList = G_ALLOC(dwInstanceListLength * sizeof(WCHAR));
            if (mszInstanceList == NULL) pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }

        if (pdhStatus != PDH_MEMORY_ALLOCATION_FAILURE) {
            pdhStatus = PdhEnumObjectItemsHW(pData->pDlgData->hDataSource,
                                             szMachineName,
                                             szObjectName,
                                             mszCounterList,
                                             & dwCounterListLength,
                                             mszInstanceList,
                                             & dwInstanceListLength,
                                             pData->dwCurrentDetailLevel,
                                             0);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        //reset contents of both list boxes
        SendMessageW(hWndCounterListBox,  LB_RESETCONTENT, 0, 0);
        SendMessageW(hWndInstanceListBox, LB_RESETCONTENT, 0, 0);

        // enable both list boxes
        EnableWindow(hWndInstanceListBox, TRUE);
        EnableWindow(hWndCounterListBox,  TRUE);

        // now fill 'em up
        // start with the counters
        hDcListBox = GetDC(hWndCounterListBox);
        if (hDcListBox == NULL) {
            goto Cleanup;
        }

        dwHorizExtent = 0;
        if (dwCounterListLength > 0 && mszCounterList != NULL) {
            for (szThisItem = mszCounterList; * szThisItem != L'\0'; szThisItem += lstrlenW(szThisItem) + 1) {
                if (GetTextExtentPoint32W(hDcListBox, szThisItem, lstrlenW(szThisItem), & Size)) {
                    if (Size.cx > dwHorizExtent) {
                        dwHorizExtent = Size.cx;
                    }
                }
                SendMessageW(hWndCounterListBox, LB_ADDSTRING, 0, (LPARAM) szThisItem);
            }
            SendMessageW(hWndCounterListBox, LB_SETHORIZONTALEXTENT, (WPARAM) dwHorizExtent, 0);
        }
        ReleaseDC(hWndCounterListBox, hDcListBox);

        // once the list box has been loaded see if we want to keep it
        // enabled. It's filled regardless just so the user can see some
        // of the entries, even if they have this disabled by the "all"
        // counter button

        if (pData->bSelectAllCounters) {
            // disable instance list
            EnableWindow(hWndCounterListBox, FALSE);
        }
        else {
            // set the default selection if there are entries in the
            // list box and use the correct message depending on the
            // selection options
            // set the default counter
            dwLength  = 0;
            pdhStatus = PdhGetDefaultPerfCounterHW(pData->pDlgData->hDataSource,
                                                   szMachineName,
                                                   szObjectName,
                                                   szDefaultCounter,
                                                   & dwLength);
            while (pdhStatus == PDH_MORE_DATA) {
                G_FREE(szDefaultCounter);
                szDefaultCounter = G_ALLOC(dwLength * sizeof(WCHAR));
                if (szDefaultCounter == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                else {
                    pdhStatus = PdhGetDefaultPerfCounterHW(pData->pDlgData->hDataSource,
                                                           szMachineName,
                                                           szObjectName,
                                                           szDefaultCounter,
                                                           & dwLength);
                }
            }
            if (pdhStatus != ERROR_SUCCESS) {
                dwDefaultIndex = 0;
            }
            else {
                dwDefaultIndex = (DWORD)SendMessageW(hWndCounterListBox,
                                                     LB_FINDSTRINGEXACT,
                                                     (WPARAM) -1,
                                                     (LPARAM) szDefaultCounter);
                if (dwDefaultIndex == LB_ERR) dwDefaultIndex = 0;
            }

            if (pData->bSelectMultipleCounters) {
                SendMessageW(hWndCounterListBox, LB_SETSEL, TRUE, dwDefaultIndex);
                SendMessageW(hWndCounterListBox, LB_SETCARETINDEX, (WPARAM) dwDefaultIndex, MAKELPARAM(FALSE, 0));
            }
            else {
                SendMessageW (hWndCounterListBox, LB_SETCURSEL, dwDefaultIndex, 0);
            }
        }

        // now the instance list
        if (mszInstanceList != NULL && dwInstanceListLength > 0) {
            // there's at least one entry, so prepare the list box
            // enable the list box and the instance radio buttons on the
            //  assumption that they will be used. this is tested later.
            EnableWindow(hWndInstanceListBox, TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_ALL_INSTANCES), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_USE_INSTANCE_LIST), TRUE);

            dwInstanceCount = 0;
            dwLength        = 0;

            // load instance entries
            hDcListBox = GetDC(hWndInstanceListBox);
            if (hDcListBox == NULL) {
                goto Cleanup;
            }
            dwHorizExtent = 0;
            for (szThisItem = mszInstanceList; * szThisItem != L'\0'; szThisItem += lstrlenW(szThisItem) + 1) {
                // see if the index number should be displayed
                if (pData->bShowIndex) {
                    // if so, it must be derived,
                    // this is accomplished by making an index entry starting
                    // at 1, and looking for a match in the current entries.
                    // if a match is found, then the index is incremented and
                    // the process is repeated until the specified
                    // instance is not found. The first value not found is
                    // then the index entry for that item.
                    //
                    // first see if there's an undecorated one in the list box
                    // if not then add this one
                    if (dwLength < (DWORD) (lstrlenW(szThisItem) + 32)) {
                        LPWSTR szTmp     = szInstanceString;
                        dwLength         = lstrlenW(szThisItem) + 32;
                        if (szTmp == NULL) {
                            szInstanceString = G_ALLOC(dwLength * sizeof(WCHAR));
                        }
                        else {
                            szInstanceString = G_REALLOC(szTmp, dwLength * sizeof(WCHAR));
                        }
                        if (szInstanceString == NULL) { G_FREE(szTmp); goto Cleanup; }
                    }
                    ZeroMemory(szInstanceString, dwLength * sizeof(WCHAR));
                    StringCchCopyW(szInstanceString, dwLength, szThisItem);
                    dwInstanceMatch = (DWORD) -1;
                    dwInstanceMatch = (DWORD) SendMessageW(hWndInstanceListBox,
                                                           LB_FINDSTRINGEXACT,
                                                           (WPARAM) dwInstanceMatch,
                                                           (LPARAM) szInstanceString);
                    if (dwInstanceMatch == LB_ERR) {
                        // then this is the first one so add it in the 
                        // undecorated form 
                        if (GetTextExtentPoint32W(hDcListBox, szInstanceString, lstrlenW(szInstanceString), & Size)) {
                            if (Size.cx > dwHorizExtent) {
                                dwHorizExtent = Size.cx;
                                SendMessageW(hWndInstanceListBox, LB_SETHORIZONTALEXTENT, (WPARAM) dwHorizExtent, 0);
                            }
                        }
                        SendMessageW(hWndInstanceListBox, LB_ADDSTRING, 0, (LPARAM) szInstanceString);
                    }
                    else {
                        // there's already a plain one, so increment through
                        // the index values and find one that's not in the
                        // list already
                        dwInstanceIndex = 1;
                        dwInstanceMatch = (DWORD) -1;
                        StringCchCatW(szInstanceString, dwLength, cszPoundSign);
                        szIndexStringPos = & szInstanceString[lstrlenW(szInstanceString)];
                        do {
                            _ltow((long) dwInstanceIndex ++, szIndexStringPos, 10);
                            dwInstanceMatch = (DWORD) SendMessageW(hWndInstanceListBox,
                                                                   LB_FINDSTRINGEXACT,
                                                                   (WPARAM) dwInstanceMatch,
                                                                   (LPARAM) szInstanceString);
                        }
                        while (dwInstanceMatch != LB_ERR);
                        // add the last entry checked (the first one not found)
                        // to the list box now.
                        if (GetTextExtentPoint32W(hDcListBox, szInstanceString, lstrlenW(szInstanceString), & Size)) {
                            if (Size.cx > dwHorizExtent) {
                                dwHorizExtent = Size.cx;
                                SendMessageW (hWndInstanceListBox, LB_SETHORIZONTALEXTENT, (WPARAM) dwHorizExtent, 0);
                            }
                        }
                        SendMessageW (hWndInstanceListBox, LB_ADDSTRING, 0, (LPARAM) szInstanceString);
                    }
                }
                else {
                    // index values are not required so just add the string
                    // to the list box
                    if (GetTextExtentPoint32W(hDcListBox, szThisItem, lstrlenW(szThisItem), & Size)) {
                        if (Size.cx > dwHorizExtent) {
                            dwHorizExtent = Size.cx;
                            SendMessageW(hWndInstanceListBox,  LB_SETHORIZONTALEXTENT, (WPARAM) dwHorizExtent, 0);
                        }
                    }
                    SendMessageW (hWndInstanceListBox, LB_ADDSTRING, 0, (LPARAM) szThisItem);
                }
                dwInstanceCount++;
            }

            ReleaseDC(hWndInstanceListBox, hDcListBox);

            if (dwInstanceCount == 0) {
                // disable the OK/Add button, since this object has no
                // current instances to monitor
                EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
                szMsg = GetStringResource(IDS_BRWS_NO_INSTANCES);
                if (szMsg != NULL) {
                    SendMessageW(hWndInstanceListBox, LB_ADDSTRING, 0, (LPARAM) szMsg);
                    G_FREE(szMsg);
                }
                EnableWindow(GetDlgItem(hDlg, IDC_ALL_INSTANCES), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_USE_INSTANCE_LIST), FALSE);
                EnableWindow(hWndInstanceListBox, FALSE);
            }
            else {
                // enable the OK/Add button since there is some monitorable
                // instance(s)
                EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_ALL_INSTANCES), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_USE_INSTANCE_LIST), TRUE);
                EnableWindow(hWndInstanceListBox, TRUE);
            }
            // once the list box has been loaded see if we want to keep it
            // enabled. It's filled regardless just so the user can see some
            // of the entries, even if they have this disabled by the "all"
            // instance button

            if (pData->bSelectAllInstances) {
                // disable instance list
                EnableWindow(hWndInstanceListBox, FALSE);
            }
            else {
                // set the default selection if there are entries in the
                // list box and use the correct message depending on the
                // selection options
                if ((dwInstanceCount > 0) && (SendMessageW(hWndInstanceListBox, LB_GETCOUNT, 0, 0) != LB_ERR)) {
                    if (pData->bSelectMultipleCounters) {
                        SendMessageW(hWndInstanceListBox, LB_SETSEL, TRUE, 0);
                    }
                    else {
                        SendMessageW(hWndInstanceListBox, LB_SETCURSEL, 0, 0);
                    }
                }
            }
        }
        else {
            // there are no instances of this counter so display the
            // string and disable the buttons and the list box
            EnableWindow(hWndInstanceListBox, FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ALL_INSTANCES), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_USE_INSTANCE_LIST), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
        }
    }
    else {
        // unable to retrieve the counters and instances so
        // clear and then...
        SendMessageW(hWndCounterListBox,  LB_RESETCONTENT, 0, 0);
        SendMessageW(hWndInstanceListBox, LB_RESETCONTENT, 0, 0);
        // disable the windows
        szMsg = GetStringResource(IDS_BRWS_NO_INSTANCES);
        if (szMsg != NULL) {
            SendMessageW(hWndInstanceListBox, LB_ADDSTRING, 0, (LPARAM) szMsg);
            G_FREE(szMsg);
        }
        szMsg = GetStringResource(IDS_BRWS_NO_COUNTERS);
        if (szMsg != NULL) {
            SendMessageW(hWndCounterListBox, LB_ADDSTRING, 0, (LPARAM) szMsg);
            G_FREE(szMsg);
        }
        EnableWindow(hWndInstanceListBox, FALSE);
        EnableWindow(hWndCounterListBox, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_ALL_INSTANCES), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_USE_INSTANCE_LIST), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
    }
    bReturn = TRUE;

Cleanup:
    // restore the cursor to it's original shape
    SetCursor(hOldCursor);

    G_FREE(szMachineName);
    G_FREE(szObjectName);
    G_FREE(szDefaultCounter);
    G_FREE(szInstanceString);
    G_FREE(mszCounterList);
    G_FREE(mszInstanceList);

    // return status
    return bReturn;
}

STATIC_PDH_FUNCTION
PdhiCompileSelectedObjectsT(
    HWND    hDlg,
    LPVOID  pUsersPathBuffer,
    DWORD   cchUsersPathLength,
    BOOL    bUnicode
)
/*++
Routine Description:
    Scans the selected objects, counter, instances and builds a multi-SZ
        string containing the expanded path of all the selections, unless
        the wild card syntax is specified.

Arguments:
    IN  HWND    hDlg
        Window Handle of Dialog containing the controls
    IN  LPVOID  pUsersPathBuffer
        pointer to the caller's buffer that will receive the MSZ string
    IN  DWORD   cchUsersPathLength
        size of caller's buffer in characters
    IN  BOOL    bUnicode
        size of characters to return: TRUE = WCHAR, FALSE = CHAR

Return Value:
    WIN32 Status of function completion
        ERROR_SUCCESS if successful
--*/
{
    LPWSTR                      lszMachineName = NULL;
    LPWSTR                      lszObjectName  = NULL;
    DWORD                       dwObjectName   = 0;
    LPWSTR                      szWorkBuffer   = NULL;
    DWORD                       dwWorkBuffer   = 0;
    LRESULT                     iNumEntries;
    int                         iThisEntry;
    LRESULT                     iCurSelState;
    LRESULT                     iTextLen;
    LRESULT                     dwObjectFlags;
    DWORD                       dwBufferRemaining;
    DWORD                       dwSize1;
    PDH_COUNTER_PATH_ELEMENTS_W lszPath;
    LPVOID                      szCounterStart;
    PDH_STATUS                  pdhStatus = ERROR_SUCCESS;
    PPDHI_BROWSE_DIALOG_DATA    pData;

    // get pointer to dialog user data
    pData = (PPDHI_BROWSE_DIALOG_DATA) GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
        pdhStatus = PDH_NO_DIALOG_DATA;
        goto Cleanup;
    }

    // clear user's string
    if (pUsersPathBuffer != NULL) {
        // clear first four bytes of string
        * ((LPDWORD) pUsersPathBuffer) = 0;
        dwBufferRemaining              = cchUsersPathLength;
        szCounterStart                 = pUsersPathBuffer;
    }
    else {
        pdhStatus = PDH_INVALID_BUFFER; // no point in continuing if the caller doesn't have a buffer
        goto Cleanup;
    }

    // each counter path string is built by setting the elements of
    // the counter data structure and then calling the MakeCounterPath
    // function to build the string
    // build base string using selected machine & objects from list

    if (pData->bIncludeMachineInPath) {
        lszMachineName = PdhiGetDlgText(hDlg, IDC_MACHINE_COMBO);
        if (lszMachineName == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        lszPath.szMachineName = lszMachineName;
    }
    else {
        lszPath.szMachineName = NULL;
    }

    // Get number of objects currently listed in the list box

    iNumEntries = SendMessageW(GetDlgItem(hDlg, IDC_OBJECT_LIST), LB_GETCOUNT, 0, 0);
    if (iNumEntries != LB_ERR) {
        lszPath.szCounterName    = (LPWSTR) cszSplat;  // wildcard counter entry
        lszPath.szParentInstance = NULL;               // no parent instances
        lszPath.dwInstanceIndex  = ((DWORD) -1);       // no index numbers

        for (iThisEntry = 0; iThisEntry < iNumEntries; iThisEntry++) {
            iCurSelState = SendMessageW(GetDlgItem(hDlg, IDC_OBJECT_LIST), LB_GETSEL, (WPARAM) iThisEntry, 0);
            if (iCurSelState > 0) {
                // then get the string and add it to the list
                iTextLen = PdhiGetListText(hDlg, IDC_OBJECT_LIST, iThisEntry, & lszObjectName, & dwObjectName);
                dwObjectFlags = SendMessage(GetDlgItem(hDlg, IDC_OBJECT_LIST),
                                            LB_GETITEMDATA,
                                            (WPARAM) iThisEntry,
                                            0);
                if (iTextLen != LB_ERR) {
                    if (lszObjectName != NULL) {
                        // build path elements
                        lszPath.szObjectName = lszObjectName;
                        if (dwObjectFlags & PDH_OBJECT_HAS_INSTANCES) {
                            lszPath.szInstanceName = (LPWSTR) cszSplat; // wildcard instance entry
                        }
                        else {
                            lszPath.szInstanceName = NULL;              // no instance
                        }
                        dwSize1   = dwWorkBuffer;
                        pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
                        while (pdhStatus == PDH_MORE_DATA) {
                            G_FREE(szWorkBuffer);
                            dwWorkBuffer = dwSize1;
                            szWorkBuffer = G_ALLOC(dwWorkBuffer * sizeof(WCHAR));
                            if (szWorkBuffer == NULL) {
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                            else {
                                pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
                            }
                        }
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
                else {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                if (pdhStatus == ERROR_SUCCESS) {
                    // add the string if there's room
                    pdhStatus = PdhiCopyString(
                                    & ((LPBYTE) szCounterStart), szWorkBuffer, & dwBufferRemaining, bUnicode);
                }
            } // else, item isn't selected so skip
        } // end for each item in the list box

        if (bUnicode) {
            * ((LPWSTR) szCounterStart) ++ = L'\0'; // terminate MSZ
        }
        else {
            * ((LPSTR) szCounterStart) ++ = '\0';   // terminate MSZ
        }
    }

Cleanup:
    G_FREE(lszMachineName);
    G_FREE(lszObjectName);
    G_FREE(szWorkBuffer);
    return pdhStatus;
}

STATIC_PDH_FUNCTION
PdhiCompileSelectedObjectsW(
    HWND    hDlg,
    LPWSTR  szUsersPathBuffer,
    DWORD   cchUsersPathLength
)
{
    return PdhiCompileSelectedObjectsT(hDlg, (LPVOID) szUsersPathBuffer, cchUsersPathLength, TRUE);
}

STATIC_PDH_FUNCTION
PdhiCompileSelectedObjectsA(
    HWND    hDlg,
    LPSTR   szUsersPathBuffer,
    DWORD   cchUsersPathLength
)
{
    return PdhiCompileSelectedObjectsT(hDlg, (LPVOID) szUsersPathBuffer, cchUsersPathLength, FALSE);
}

STATIC_PDH_FUNCTION
PdhiCompileSelectedCountersT(
    HWND    hDlg,
    LPVOID  pUsersPathBuffer,
    DWORD   cchUsersPathLength,
    BOOL    bUnicode
)
/*++
Routine Description:
    Scans the selected objects, counter, instances and builds a multi-SZ
        string containing the expanded path of all the selections, unless
        the wild card syntax is specified.

Arguments:
    IN  HWND    hDlg
        Window Handle of Dialog containing the controls
    IN  LPVOID  pUsersPathBuffer
        pointer to the caller's buffer that will receive the MSZ string
    IN  DWORD   cchUsersPathLength
        size of caller's buffer in characters
    IN  BOOL    bUnicode
        size of characters to return: TRUE = WCHAR, FALSE = CHAR

Return Value:
    WIN32 Status of function completion
        ERROR_SUCCESS if successful
--*/
{
    LPWSTR                      lszMachineName     = NULL;
    LPWSTR                      lszObjectName      = NULL;
    LPWSTR                      lszFullInstance    = NULL;
    DWORD                       dwFullInstance     = 0;
    LPWSTR                      lszInstanceName    = NULL;
    DWORD                       dwInstanceName     = 0;
    LPWSTR                      lszParentInstance  = NULL;
    DWORD                       dwParentInstance   = 0;
    LPWSTR                      lszCounterName     = NULL;
    DWORD                       dwCounterName      = 0;
    LPWSTR                      szWorkBuffer       = NULL;
    DWORD                       dwWorkBuffer       = 0;
    DWORD                       dwBufferRemaining;
    DWORD                       dwCountCounters;
    DWORD                       dwThisCounter;
    DWORD                       dwCountInstances;
    DWORD                       dwThisInstance;
    DWORD                       dwSize1;
    DWORD                       dwSize2;
    PDH_COUNTER_PATH_ELEMENTS_W lszPath;
    LPVOID                      szCounterStart;
    HWND                        hWndCounterList;
    HWND                        hWndInstanceList;
    BOOL                        bSel;
    PDH_STATUS                  pdhStatus = ERROR_SUCCESS;
    PPDHI_BROWSE_DIALOG_DATA    pData;
    LRESULT                     iTextLen;

    // get pointer to dialog user data
    pData = (PPDHI_BROWSE_DIALOG_DATA) GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
        pdhStatus = PDH_NO_DIALOG_DATA;
        goto Cleanup;
    }

    // clear user's string
    if (pUsersPathBuffer != NULL) {
        // clear first four bytes of string
        * ((LPDWORD) pUsersPathBuffer) = 0;
        dwBufferRemaining              = cchUsersPathLength;
        szCounterStart                 = pUsersPathBuffer;
    }
    else {
        pdhStatus = PDH_INVALID_BUFFER; // no point in continuing if the caller doesn't have a buffer
        goto Cleanup;
    }

    // each counter path string is built by setting the elements of
    // the counter data structure and then calling the MakeCounterPath
    // function to build the string
    // build base string using selected machine and object

    if (pData->bIncludeMachineInPath) {
        lszMachineName = PdhiGetDlgText(hDlg, IDC_MACHINE_COMBO);
        if (lszMachineName == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        lszPath.szMachineName = lszMachineName;
    }
    else {
        lszPath.szMachineName = NULL;
    }

    lszObjectName = PdhiGetDlgText(hDlg, IDC_OBJECT_COMBO);
    if (lszObjectName == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    lszPath.szObjectName = lszObjectName;

    hWndCounterList  = GetDlgItem(hDlg, IDC_COUNTER_LIST);
    hWndInstanceList = GetDlgItem(hDlg, IDC_INSTANCE_LIST);

    if (pData->bSelectMultipleCounters) {
        if (pData->bWildCardInstances && pData->bSelectAllInstances) {
            if (IsWindowEnabled(GetDlgItem(hDlg, IDC_ALL_INSTANCES))) {
                // then this object has instances and we want ALL of them
                lszPath.szInstanceName   = (LPWSTR) cszSplat;      // wildcard instances
                lszPath.szParentInstance = NULL;
                lszPath.dwInstanceIndex  = (DWORD) -1;
            }
            else {
                // this object has no instances
                lszPath.szInstanceName   = NULL;
                lszPath.szParentInstance = NULL;
                lszPath.dwInstanceIndex  = (DWORD) -1;
            }
            // make a counter path for each selected counter
            if (pData->bSelectAllCounters) {
                lszPath.szCounterName = (LPWSTR) cszSplat;    // wildcard counters

                dwSize1   = dwWorkBuffer;
                pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
                while (pdhStatus == PDH_MORE_DATA) {
                    G_FREE(szWorkBuffer);
                    dwWorkBuffer = dwSize1;
                    szWorkBuffer = G_ALLOC(dwWorkBuffer * sizeof(WCHAR));
                    if (szWorkBuffer == NULL) {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                    else {
                        pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
                    }
                }
                if (pdhStatus == ERROR_SUCCESS) {
                    // add the string if there's room
                    pdhStatus = PdhiCopyString(& ((LPBYTE) szCounterStart),
                                               szWorkBuffer,
                                               & dwBufferRemaining,
                                               bUnicode);
                }
            }
            else {
                dwCountCounters = (DWORD)SendMessageW(hWndCounterList, LB_GETCOUNT, 0, 0);
                for (dwThisCounter = 0; dwThisCounter < dwCountCounters; dwThisCounter++) {
                    if (SendMessageW(hWndCounterList, LB_GETSEL, (WPARAM) dwThisCounter, 0) > 0) {
                        iTextLen = PdhiGetListText(
                                        hDlg, IDC_COUNTER_LIST, dwThisCounter, & lszCounterName, & dwCounterName);
                        if (iTextLen == LB_ERR) continue;
                        if (lszCounterName == NULL) {
                            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            goto Cleanup;
                        }
                        lszPath.szCounterName = lszCounterName;
                        dwSize1   = dwWorkBuffer;
                        pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
                        while (pdhStatus == PDH_MORE_DATA) {
                            G_FREE(szWorkBuffer);
                            dwWorkBuffer = dwSize1;
                            szWorkBuffer = G_ALLOC(dwWorkBuffer * sizeof(WCHAR));
                            if (szWorkBuffer == NULL) {
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                            else {
                                pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
                            }
                        }
                        if (pdhStatus == ERROR_SUCCESS) {
                            // add the string if there's room
                            pdhStatus = PdhiCopyString(& ((LPBYTE) szCounterStart),
                                                       szWorkBuffer,
                                                       & dwBufferRemaining,
                                                       bUnicode);
                        }
                    } // end if this counter was selected
                } // end for each counter in object list box
            } 
        }
        else {
            // get selected instances from list
            dwCountCounters = (DWORD)SendMessageW(hWndCounterList, LB_GETCOUNT, 0, 0);
            for (dwThisCounter = 0; dwThisCounter < dwCountCounters; dwThisCounter++) {
                bSel = (BOOL) SendMessageW(hWndCounterList, LB_GETSEL, (WPARAM) dwThisCounter, 0);
                if (bSel || pData->bSelectAllCounters) {
                    iTextLen = PdhiGetListText(
                                    hDlg, IDC_COUNTER_LIST, dwThisCounter, & lszCounterName, & dwCounterName);
                    if (iTextLen == LB_ERR) continue;
                    if (lszCounterName == NULL) {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                    lszPath.szCounterName = lszCounterName;
                    if (IsWindowEnabled(hWndInstanceList) || pData->bSelectAllInstances) {
                        dwCountInstances = (DWORD)SendMessageW(hWndInstanceList, LB_GETCOUNT, 0, 0);
                        for (dwThisInstance = 0; dwThisInstance < dwCountInstances; dwThisInstance++) {
                            if (SendMessageW(hWndInstanceList, LB_GETSEL, (WPARAM) dwThisInstance, 0)
                                                    || pData->bSelectAllInstances) {
                                iTextLen = PdhiGetListText(
                                        hDlg, IDC_INSTANCE_LIST, dwThisInstance, & lszFullInstance, & dwFullInstance);
                                if (iTextLen == LB_ERR) continue;
                                if (lszFullInstance == NULL) {
                                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                    goto Cleanup;
                                }
                                lszPath.szInstanceName = lszFullInstance;
                                dwSize1                = dwInstanceName;
                                dwSize2                = dwParentInstance;
                                if (lszInstanceName != NULL) {
                                    ZeroMemory(lszInstanceName, dwInstanceName * sizeof(WCHAR));
                                }
                                if (lszParentInstance != NULL) {
                                    ZeroMemory(lszParentInstance, dwParentInstance * sizeof(WCHAR));
                                }
                                pdhStatus = PdhParseInstanceNameW(lszFullInstance,
                                                                  lszInstanceName,
                                                                  & dwSize1,
                                                                  lszParentInstance,
                                                                  & dwSize2,
                                                                  & lszPath.dwInstanceIndex);
                                while (pdhStatus == PDH_MORE_DATA) {
                                    if (dwSize1 > 0 && dwSize1 > dwInstanceName) {
                                        G_FREE(lszInstanceName);
                                        dwInstanceName  = dwSize1;
                                        lszInstanceName = G_ALLOC(dwInstanceName * sizeof(WCHAR));
                                        if (lszInstanceName == NULL) pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                    }
                                    if (dwSize2 > 0 && dwSize2 > dwParentInstance) {
                                        G_FREE(lszParentInstance);
                                        dwParentInstance  = dwSize2;
                                        lszParentInstance = G_ALLOC(dwParentInstance * sizeof(WCHAR));
                                        if (lszParentInstance == NULL) pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                    }
                                    if (pdhStatus != PDH_MEMORY_ALLOCATION_FAILURE) {
                                        pdhStatus = PdhParseInstanceNameW(lszFullInstance,
                                                                          lszInstanceName,
                                                                          & dwSize1,
                                                                          lszParentInstance,
                                                                          & dwSize2,
                                                                          & lszPath.dwInstanceIndex);
                                    }
                                }
                                if (pdhStatus == ERROR_SUCCESS) {
                                    // parse instance name adds in the default index if one is
                                    // not present. so if it's not wanted, this will remove it
                                    if (!pData->bShowIndex) {
                                        lszPath.dwInstanceIndex = (DWORD) -1;
                                    }
                                    else {
                                        // only add in the instance # if it's not 0
                                        if (lszPath.dwInstanceIndex == 0) {
                                            lszPath.dwInstanceIndex = (DWORD) -1;
                                        }
                                    }
                                    if (dwInstanceName > 1) {
                                        lszPath.szInstanceName = lszInstanceName;
                                    }
                                    else {
                                        lszPath.szInstanceName = NULL;
                                    }
                                    if (dwParentInstance > 1) {
                                        lszPath.szParentInstance = lszParentInstance;
                                    }
                                    else {
                                        lszPath.szParentInstance = NULL;
                                    }
                                }
                                else {
                                    // ignore the instances
                                    lszPath.szInstanceName   = NULL;
                                    lszPath.szParentInstance = NULL;
                                }

                                dwSize1   = dwWorkBuffer;
                                pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
                                while (pdhStatus == PDH_MORE_DATA) {
                                    G_FREE(szWorkBuffer);
                                    dwWorkBuffer = dwSize1;
                                    szWorkBuffer = G_ALLOC(dwWorkBuffer * sizeof(WCHAR));
                                    if (szWorkBuffer == NULL) {
                                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                    }
                                    else {
                                        pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
                                    }
                                }
                                if (pdhStatus == ERROR_SUCCESS) {
                                    pdhStatus = PdhiCopyString(& ((LPBYTE) szCounterStart),
                                                               szWorkBuffer,
                                                               & dwBufferRemaining,
                                                               bUnicode);
                                }
                            } // end if instance is selected
                        } // end for each instance in list
                    }
                    else {
                        // this counter has no instances so process now
                        lszPath.szInstanceName   = NULL;
                        lszPath.szParentInstance = NULL;
                        lszPath.dwInstanceIndex  = (DWORD)-1;

                        dwSize1   = dwWorkBuffer;
                        pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
                        while (pdhStatus == PDH_MORE_DATA) {
                            G_FREE(szWorkBuffer);
                            dwWorkBuffer = dwSize1;
                            szWorkBuffer = G_ALLOC(dwWorkBuffer * sizeof(WCHAR));
                            if (szWorkBuffer == NULL) {
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                            else {
                                pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
                            }
                        }
                        if (pdhStatus == ERROR_SUCCESS) {
                            pdhStatus = PdhiCopyString(& ((LPBYTE) szCounterStart),
                                                       szWorkBuffer,
                                                       & dwBufferRemaining,
                                                       bUnicode);
                        }
                    } // end if counter has instances
                } // else counter is not selected
            } // end for each counter in list
        }
    } // end if not wild card instances
    else {
        dwThisCounter = (DWORD) SendMessageW(hWndCounterList, LB_GETCURSEL, 0, 0);
        if (dwThisCounter == LB_ERR) {
            // counter not found so select 0
            dwThisCounter = 0;
        }
        iTextLen = PdhiGetListText(hDlg, IDC_COUNTER_LIST, dwThisCounter, & lszCounterName, & dwCounterName);
        if (iTextLen == LB_ERR) {
            pdhStatus = PDH_INVALID_DATA;
            goto Cleanup;
        } 
        else if (lszCounterName == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        lszPath.szCounterName = lszCounterName;

        // only single selections are allowed
        if (pData->bWildCardInstances && pData->bSelectAllInstances) {
            lszPath.szInstanceName   = (LPWSTR) cszSplat;   // wildcard instances
            lszPath.szParentInstance = NULL;
            lszPath.dwInstanceIndex  = (DWORD) -1;

            dwSize1   = dwWorkBuffer;
            pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
            while (pdhStatus == PDH_MORE_DATA) {
                G_FREE(szWorkBuffer);
                dwWorkBuffer = dwSize1;
                szWorkBuffer = G_ALLOC(dwWorkBuffer * sizeof(WCHAR));
                if (szWorkBuffer == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                else {
                    pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                pdhStatus = PdhiCopyString(& ((LPBYTE) szCounterStart),
                                           szWorkBuffer,
                                           & dwBufferRemaining,
                                           bUnicode);
            }
        }
        else {
            // get selected instance from list
            if (IsWindowEnabled(hWndInstanceList)) {
                dwThisInstance = (DWORD)SendMessageW(hWndInstanceList, LB_GETCURSEL, 0, 0);
                if (dwThisInstance == LB_ERR) {
                    // instance not found so select 0
                    dwThisInstance = 0;
                }
                iTextLen = PdhiGetListText(
                                hDlg, IDC_INSTANCE_LIST, dwThisInstance, & lszFullInstance, & dwFullInstance);
                if (iTextLen == LB_ERR) {
                     pdhStatus = PDH_INVALID_DATA;
                     goto Cleanup;
                }
                else if (lszFullInstance == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    goto Cleanup;
                }
                lszPath.szCounterName = lszCounterName;
                dwSize1               = dwInstanceName;
                dwSize2               = dwParentInstance;
                if (lszInstanceName != NULL) {
                    ZeroMemory(lszInstanceName, dwInstanceName * sizeof(WCHAR));
                }
                if (lszParentInstance != NULL) {
                    ZeroMemory(lszParentInstance, dwParentInstance * sizeof(WCHAR));
                }
                pdhStatus = PdhParseInstanceNameW(lszFullInstance,
                                                  lszInstanceName,
                                                  & dwSize1,
                                                  lszParentInstance,
                                                  & dwSize2,
                                                  & lszPath.dwInstanceIndex);
                while (pdhStatus == PDH_MORE_DATA) {
                    if (dwSize1 > 0 && dwSize1 > dwInstanceName) {
                        G_FREE(lszInstanceName);
                        dwInstanceName  = dwSize1;
                        lszInstanceName = G_ALLOC(dwInstanceName * sizeof(WCHAR));
                        if (lszInstanceName == NULL) pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                    if (dwSize2 > 0 && dwSize2 > dwParentInstance) {
                        G_FREE(lszParentInstance);
                        dwParentInstance  = dwSize2;
                        lszParentInstance = G_ALLOC(dwParentInstance * sizeof(WCHAR));
                        if (lszParentInstance == NULL) pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                    if (pdhStatus != PDH_MEMORY_ALLOCATION_FAILURE) {
                        pdhStatus = PdhParseInstanceNameW(lszFullInstance,
                                                          lszInstanceName,
                                                          & dwSize1,
                                                          lszParentInstance,
                                                          & dwSize2,
                                                          & lszPath.dwInstanceIndex);
                    }
                }
                if (pdhStatus == ERROR_SUCCESS ) {
                    // parse instance name adds in the default index of one is
                    // not present. so if it's not wanted, this will remove it
                    if (!pData->bShowIndex) {
                        lszPath.dwInstanceIndex = (DWORD) -1;
                    }
                    // size values include trailing NULL char so
                    // strings must be > 1 char in length to have some
                    // text since a length of 1 would imply only a
                    // NULL character.
                    if (dwInstanceName > 1) {
                        lszPath.szInstanceName = lszInstanceName;
                    }
                    else {
                        lszPath.szInstanceName = NULL;
                    }
                    if (dwParentInstance > 1) {
                        lszPath.szParentInstance = lszParentInstance;
                    }
                    else {
                        lszPath.szParentInstance = NULL;
                    }
                }
                else {
                    // skip this instance
                    lszPath.szParentInstance = NULL;
                    lszPath.szInstanceName   = NULL;
                    lszPath.dwInstanceIndex  = (DWORD) -1;
                 }
            }
            else {
                // this counter has no instances so process now
                lszPath.szInstanceName   = NULL;
                lszPath.szParentInstance = NULL;
                lszPath.dwInstanceIndex  = (DWORD) -1;
            } // end if counter has instances

            dwSize1   = dwWorkBuffer;
            pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
            while (pdhStatus == PDH_MORE_DATA) {
                G_FREE(szWorkBuffer);
                dwWorkBuffer = dwSize1;
                szWorkBuffer = G_ALLOC(dwWorkBuffer * sizeof(WCHAR));
                if (szWorkBuffer == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                else {
                    pdhStatus = PdhMakeCounterPathW(& lszPath, szWorkBuffer, & dwSize1, 0);
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                pdhStatus = PdhiCopyString(& ((LPBYTE) szCounterStart),
                                           szWorkBuffer,
                                           & dwBufferRemaining,
                                           bUnicode);
            }
        } // end if not wild card instances
    }

    if (bUnicode) {
        * ((LPWSTR) szCounterStart) ++ = L'\0'; // terminate MSZ
    }
    else {
        * ((LPSTR) szCounterStart) ++  = '\0';  // terminate MSZ
    }

Cleanup:
    G_FREE(lszMachineName);
    G_FREE(lszObjectName);
    G_FREE(lszCounterName);
    G_FREE(lszInstanceName);
    G_FREE(lszParentInstance);
    G_FREE(szWorkBuffer);
    return pdhStatus;
}

STATIC_PDH_FUNCTION
PdhiCompileSelectedCountersW(
    HWND    hDlg,
    LPWSTR  szUsersPathBuffer,
    DWORD   cchUsersPathLength
)
/*++
Routine Description:
    UNICODE function wrapper for base function which scans the selected
        objects, counter, instances and builds a multi-SZ string containing
        the expanded path of all the selections, unless the wild card
        syntax is specified.

Arguments:
    IN  HWND    hDlg
        Window Handle of Dialog containing the controls
    IN  LPWSTR  szUsersPathBuffer
        pointer to the caller's buffer that will receive the MSZ
        wide characters string
    IN  DWORD   cchUsersPathLength
        size of caller's buffer in characters

Return Value:
    WIN32 Status of function completion
        ERROR_SUCCESS if successful
--*/
{
    return PdhiCompileSelectedCountersT(hDlg, (LPVOID) szUsersPathBuffer, cchUsersPathLength, TRUE);
}

STATIC_PDH_FUNCTION
PdhiCompileSelectedCountersA(
    HWND    hDlg,
    LPSTR   szUsersPathBuffer,
    DWORD   cchUsersPathLength
)
/*++
Routine Description:
    ANSI function wrapper for base function which scans the selected
        objects, counter, instances and builds a multi-SZ string containing
        the expanded path of all the selections, unless the wild card
        syntax is specified.

Arguments:
    IN  HWND    hDlg
        Window Handle of Dialog containing the controls
    IN  LPsSTR  szUsersPathBuffer
        pointer to the caller's buffer that will receive the MSZ
        single-byte characters string
    IN  DWORD   cchUsersPathLength
        size of caller's buffer in characters

Return Value:
    WIN32 Status of function completion
        ERROR_SUCCESS if successful
--*/
{
    return PdhiCompileSelectedCountersT(hDlg, (LPVOID) szUsersPathBuffer, cchUsersPathLength, FALSE);
}

STATIC_BOOL
PdhiBrowseCtrDlg_MACHINE_COMBO(
    HWND    hDlg,
    WORD    wNotifyMsg,
    HWND    hWndControl
)
/*++
Routine Description:
    Processes the windows messags sent by the Machine selection combo box

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the control
    IN  WORD    wNotifyMsg
        Notification message sent by the control
    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    LPWSTR                    szNewMachineName = NULL;
    DWORD                     dwNewMachineName = 0;
    HWND                      hWndMachineCombo = hWndControl;
    long                      lMatchIndex;
    HCURSOR                   hOldCursor;
    PPDHI_BROWSE_DIALOG_DATA  pData;
    BOOL                      bReturn          = FALSE;

    pData = (PPDHI_BROWSE_DIALOG_DATA) GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData != NULL) {
        switch (wNotifyMsg) {
        case CBN_KILLFOCUS:
            // the user has left the control so see if there's a new
            // machine name that will need to be connected to and loaded

            // display the wait cursor as this could take a while
            hOldCursor = SetCursor(LoadCursor (NULL, IDC_WAIT));

            // Get current combo box text
            dwNewMachineName = GetWindowTextLength(hWndMachineCombo);
            if (dwNewMachineName != 0) {
                dwNewMachineName ++;
                szNewMachineName = G_ALLOC(dwNewMachineName * sizeof(WCHAR));
                if (szNewMachineName != NULL) {
                    GetWindowTextW(hWndMachineCombo, szNewMachineName, dwNewMachineName);

                    // see if it's in the combo box already
                    lMatchIndex = (long) SendMessageW(hWndMachineCombo,
                                                      CB_FINDSTRINGEXACT,
                                                      (WPARAM) -1,
                                                      (LPARAM) szNewMachineName);
                    // if name is in list, then select it and initialize the dialog
                    // update the current counter list & data block for this machine
                    // in the process.
                    if (lMatchIndex != CB_ERR) {
                        // this name is already in the list so see if it's the same as the last selected machine
                        if (lstrcmpiW(szNewMachineName, pData->szLastMachineName) != 0) {
                            // this is a different machine so  update the display
                            SendMessageW(hWndMachineCombo, CB_SETCURSEL, (WPARAM) lMatchIndex, 0);
                            if (DataSourceTypeH(pData->pDlgData->hDataSource) != DATA_SOURCE_LOGFILE) {
                                if (PdhiLoadNewMachine(hDlg, szNewMachineName, FALSE)) {
                                    // display explain text if necessary
                                    SendMessageW(hDlg,
                                                 WM_COMMAND,
                                                 MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                                                 (LPARAM) GetDlgItem(hDlg, IDC_COUNTER_LIST));
                                    StringCchCopyW(pData->szLastMachineName, MAX_PATH, szNewMachineName);
                                }
                            }
                            else {
                                PdhiLoadMachineObjects(hDlg, TRUE);
                                PdhiLoadCountersAndInstances(hDlg);
                            }
                        }
                    }
                    else {
                        if (PdhiLoadNewMachine(hDlg, szNewMachineName, TRUE)) {
                            // new machine loaded and selected so save the name.
                            StringCchCopyW(pData->szLastMachineName, MAX_PATH, szNewMachineName);
                        }
                    }
                    G_FREE(szNewMachineName);
                }
            }
            SetCursor (hOldCursor);
            bReturn = TRUE;
            break;

        default:
            break;
        }
    }

    return bReturn;
}

STATIC_BOOL
PdhiBrowseCtrDlg_MACHINE_BUTTON(
    HWND    hDlg,
    WORD    wNotifyMsg,
    HWND    hWndControl
)
/*++
Routine Description:
    Processes the windows message that occurs when one of the
        machine context selection buttons in pressed in the dialog

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls
    IN  WORD    wNotifyMsg
        Notification message sent by the button
    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    BOOL                     bMode;
    PPDHI_BROWSE_DIALOG_DATA pData;
    HWND                     hWndMachineCombo;
    BOOL                     bReturn = FALSE;

    UNREFERENCED_PARAMETER(hWndControl);
    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData != NULL) {
        switch (wNotifyMsg) {
        case BN_CLICKED:
            // select the current display and processing mode based
            // on the button that his currently checked.
            bMode = ! (BOOL) IsDlgButtonChecked(hDlg, IDC_USE_LOCAL_MACHINE);
            EnableWindow(GetDlgItem(hDlg, IDC_MACHINE_COMBO), bMode);
            if (! bMode) {
                hWndMachineCombo = GetDlgItem(hDlg, IDC_MACHINE_COMBO);
                // then this is a Local machine query so
                // make sure the machine name is set to the local machine
                SetWindowTextW(hWndMachineCombo, szStaticLocalMachineName);
                PdhiBrowseCtrDlg_MACHINE_COMBO(hDlg, CBN_KILLFOCUS, hWndMachineCombo);
            }
            pData->bIncludeMachineInPath = bMode;
            bReturn = TRUE;
            break;

        default:
            break;
        }
    }
    return bReturn;
}

STATIC_BOOL
PdhiBrowseCtrDlg_OBJECT_COMBO(
    HWND hDlg,
    WORD wNotifyMsg,
    HWND hWndControl
)
/*++
Routine Description:
    Processes the windows messags sent by the Object selection combo box.

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the control
    IN  WORD    wNotifyMsg
        Notification message sent by the control
    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    BOOL bReturn = FALSE;

    UNREFERENCED_PARAMETER(hWndControl);

    switch (wNotifyMsg) {
    case CBN_SELCHANGE:
        PdhiLoadCountersAndInstances(hDlg);
        SendMessageW(hDlg,
                     WM_COMMAND,
                     MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                     (LPARAM) GetDlgItem(hDlg, IDC_COUNTER_LIST));
        bReturn = TRUE;
        break;

    default:
        break;
    }
    return bReturn;
}

STATIC_BOOL
PdhiBrowseCtrDlg_COUNTER_LIST(
    HWND hDlg,
    WORD wNotifyMsg,
    HWND hWndControl
)
/*++
Routine Description:
    Processes the windows messags sent by the Object selection combo box.

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the control
    IN  WORD    wNotifyMsg
        Notification message sent by the control
    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    LPWSTR  szMachineName   = NULL;
    LPWSTR  szObjectName    = NULL;
    LPWSTR  szCounterName   = NULL;
    LPWSTR  szDisplayString = NULL;
    LRESULT lDisplayString;
    DWORD   dwDisplayString;
    LPWSTR  szExplainText   = NULL;
    WCHAR   szNullDisplay[1];
    BOOL    bFreeExplain    = FALSE;
    LONG    lIndex;
    BOOL    bReturn         = FALSE;

    UNREFERENCED_PARAMETER (hWndControl);
    switch (wNotifyMsg) {
    case LBN_SELCHANGE:
        bReturn = TRUE;
        if (hExplainDlg != NULL) {
            szMachineName = PdhiGetDlgText(hDlg, IDC_MACHINE_COMBO);
            szObjectName  = PdhiGetDlgText(hDlg, IDC_OBJECT_COMBO);
            if (szMachineName == NULL || szObjectName == NULL) break;

            lIndex = (LONG) SendDlgItemMessageW(hDlg, IDC_COUNTER_LIST, LB_GETCARETINDEX, 0, 0);
            if (lIndex != LB_ERR) {
                lDisplayString = SendDlgItemMessageW(hDlg, IDC_COUNTER_LIST, LB_GETTEXTLEN, (WPARAM) lIndex, 0L);
                if (lDisplayString != LB_ERR) {
                    szCounterName = G_ALLOC(sizeof(WCHAR) * ((DWORD) lDisplayString + 1));
                    if (szCounterName == NULL) break;

                    lIndex = (LONG) SendDlgItemMessageW(
                                    hDlg, IDC_COUNTER_LIST, LB_GETTEXT, (WPARAM) lIndex, (LPARAM) szCounterName);

                    if (dwPdhiLocalDefaultDataSource == DATA_SOURCE_WBEM) {
                        PDH_STATUS Status    = PDH_MORE_DATA;
                        DWORD      dwExplain = 0;

                        szExplainText = NULL;
                        while (Status == PDH_MORE_DATA) {
                            dwExplain += MAX_PATH;
                            G_FREE(szExplainText);
                            szExplainText = G_ALLOC(dwExplain * sizeof(WCHAR));
                            if (szExplainText == NULL) {
                                bFreeExplain = FALSE;
                                Status = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                            else {
                                bFreeExplain = TRUE;
                                Status = PdhiGetWbemExplainText(szMachineName,
                                                                szObjectName,
                                                                szCounterName,
                                                                szExplainText,
                                                                & dwExplain);
                            }
                        }
                        if (Status != ERROR_SUCCESS) {
                            if (bFreeExplain) {
                                bFreeExplain = FALSE;
                                G_FREE(szExplainText);
                            }
                            szExplainText = NULL;
                        }
                    }
                    else {
                        szExplainText = PdhiGetExplainText(szMachineName, szObjectName, szCounterName);
                    }
                    dwDisplayString = lstrlenW(szMachineName) + lstrlenW(szObjectName) + lstrlenW(szCounterName) + 3;
                    szDisplayString = G_ALLOC(dwDisplayString * sizeof(WCHAR));
                    if (szDisplayString != NULL) {
                        StringCchPrintfW(szDisplayString,
                                         dwDisplayString,
                                         L"%ws\\%ws\\%ws",
                                         szMachineName,
                                         szObjectName,
                                         szCounterName);
                    }
                    else {
                        szNullDisplay[0] = L'\0';
                        szDisplayString  = szNullDisplay;
                    }
                }
                else {
                    szExplainText    = NULL;
                    szNullDisplay[0] = L'\0';
                    szDisplayString  = szNullDisplay;
                }
            }
            else {
                szExplainText    = NULL;
                szNullDisplay[0] = L'\0';
                szDisplayString  = szNullDisplay;
            }
            SendMessageW(hExplainDlg, EDM_UPDATE_EXPLAIN_TEXT, 0, (LPARAM) szExplainText);
            SendMessageW(hExplainDlg, EDM_UPDATE_TITLE_TEXT,   0, (LPARAM) szDisplayString);
        }
    }

    G_FREE(szMachineName);
    G_FREE(szObjectName);
    G_FREE(szCounterName);
    if (szDisplayString != szNullDisplay) G_FREE(szDisplayString);
    if (bFreeExplain)                     G_FREE(szExplainText);

    return bReturn;
}

STATIC_BOOL
PdhiBrowseCtrDlg_OBJECT_LIST(
    HWND    hDlg,
    WORD    wNotifyMsg,
    HWND    hWndControl
)
/*++

Routine Description:

    Processes the windows messags sent by the Object selection combo box.

Arguments:

    IN  HWND    hDlg
        Window Handle to the dialog box containing the control

    IN  WORD    wNotifyMsg
        Notification message sent by the control

    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:

    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message

--*/
{
    LPWSTR  szMachineName   = NULL;
    LPWSTR  szObjectName    = NULL;
    LPWSTR  szDisplayString = NULL;
    LRESULT lDisplayString;
    DWORD   dwDisplayString;
    LPWSTR  szExplainText   = NULL;
    WCHAR   szNullDisplay[1];
    BOOL    bFreeExplain    = FALSE;
    LONG    lIndex;
    BOOL    bReturn         = FALSE;

    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
    case LBN_SELCHANGE:
        bReturn = TRUE;
        if (hExplainDlg != NULL) {
            szMachineName = PdhiGetDlgText(hDlg, IDC_MACHINE_COMBO);
            if (szMachineName == NULL) break;

            lIndex = (LONG) SendDlgItemMessageW(hDlg, IDC_OBJECT_LIST, LB_GETCARETINDEX, 0, 0);
            if (lIndex != LB_ERR) {
                lDisplayString = SendDlgItemMessageW(hDlg, IDC_OBJECT_LIST, LB_GETTEXTLEN, (WPARAM) lIndex, 0L);
                if (lDisplayString != LB_ERR) {
                    szObjectName = G_ALLOC(sizeof(WCHAR) * ((DWORD) lDisplayString + 1));
                    if (szObjectName == NULL) break;

                    lIndex = (LONG) SendDlgItemMessageW(
                                    hDlg, IDC_OBJECT_LIST, LB_GETTEXT, (WPARAM) lIndex, (LPARAM) szObjectName);

                    if (dwPdhiLocalDefaultDataSource == DATA_SOURCE_WBEM) {
                        PDH_STATUS Status    = PDH_MORE_DATA;
                        DWORD      dwExplain = 0;

                        szExplainText = NULL;
                        while (Status == PDH_MORE_DATA) {
                            dwExplain += MAX_PATH;
                            G_FREE(szExplainText);
                            szExplainText = G_ALLOC(dwExplain * sizeof(WCHAR));
                            if (szExplainText == NULL) {
                                bFreeExplain = FALSE;
                                Status = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                            else {
                                bFreeExplain = TRUE;
                                Status = PdhiGetWbemExplainText(szMachineName,
                                                                szObjectName,
                                                                NULL,
                                                                szExplainText,
                                                                & dwExplain);
                            }
                        }
                        if (Status != ERROR_SUCCESS) {
                            if (bFreeExplain) {
                                bFreeExplain = FALSE;
                                G_FREE(szExplainText);
                            }
                            szExplainText = NULL;
                        }
                    }
                    else {
                        szExplainText = PdhiGetExplainText( szMachineName, szObjectName, NULL);
                    }

                    dwDisplayString = lstrlenW(szMachineName) + lstrlenW(szObjectName) + 2;
                    szDisplayString = G_ALLOC(dwDisplayString * sizeof(WCHAR));
                    if (szDisplayString != NULL) {
                        StringCchPrintfW(szDisplayString, dwDisplayString, L"%ws\\%ws", szMachineName, szObjectName);
                    }
                    else {
                        szNullDisplay[0] = L'\0';
                        szDisplayString  = szNullDisplay;
                    }
                }
                else {
                    szExplainText    = NULL;
                    szNullDisplay[0] = L'\0';
                    szDisplayString  = szNullDisplay;
                }
            }
            else {
                szExplainText    = NULL;
                szNullDisplay[0] = L'\0';
                szDisplayString  = szNullDisplay;
            }
            SendMessageW(hExplainDlg, EDM_UPDATE_EXPLAIN_TEXT, 0, (LPARAM) szExplainText);
            SendMessageW(hExplainDlg, EDM_UPDATE_TITLE_TEXT,   0, (LPARAM) szDisplayString);
        }
    }

    G_FREE(szMachineName);
    G_FREE(szObjectName);
    if (szDisplayString != szNullDisplay) G_FREE(szDisplayString);
    if (bFreeExplain) G_FREE(szExplainText);
    return bReturn;
}

STATIC_BOOL
PdhiBrowseCtrDlg_DETAIL_COMBO(
    HWND    hDlg,
    WORD    wNotifyMsg,
    HWND    hWndControl
)
/*++
Routine Description:
    Processes the windows messags sent by the Detail Level Combo box.

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the control
    IN  WORD    wNotifyMsg
        Notification message sent by the control
    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    DWORD                    dwCurSel;
    PPDHI_BROWSE_DIALOG_DATA pData;
    BOOL                     bReturn = FALSE;

    pData = (PPDHI_BROWSE_DIALOG_DATA) GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData != NULL) {
        switch (wNotifyMsg) {
        case CBN_SELCHANGE:
            dwCurSel = (DWORD) SendMessageW(hWndControl, CB_GETCURSEL, 0, 0);
            if (dwCurSel != CB_ERR) {
                pData->dwCurrentDetailLevel = (DWORD) SendMessageW(hWndControl,
                                                                   CB_GETITEMDATA,
                                                                   (WPARAM) dwCurSel,
                                                                   0);
                // update all the windows to show the new level
                PdhiLoadMachineObjects(hDlg, FALSE);
                PdhiLoadCountersAndInstances(hDlg);
                // display explain text if necessary
                SendMessageW(hDlg,
                             WM_COMMAND,
                             MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                             (LPARAM) GetDlgItem(hDlg, IDC_COUNTER_LIST));
            }
            bReturn = TRUE;
            break;

        default:
            break;
        }
    }
    return bReturn;
}

STATIC_BOOL
PdhiBrowseCtrDlg_INSTANCE_BUTTON(
    HWND    hDlg,
    WORD    wNotifyMsg,
    HWND    hWndControl
)
/*++
Routine Description:
    Processes the windows messags sent by the Instance configuration
        selection buttons

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the control
    IN  WORD    wNotifyMsg
        Notification message sent by the control
    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    BOOL                       bMode;
    HWND                       hWndInstanceList;
    PPDHI_BROWSE_DIALOG_DATA   pData;
    BOOL                       bReturn = FALSE;

    UNREFERENCED_PARAMETER(hWndControl);
    pData = (PPDHI_BROWSE_DIALOG_DATA) GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData != NULL) {
        switch (wNotifyMsg) {
        case BN_CLICKED:
            bMode            = (BOOL) IsDlgButtonChecked(hDlg, IDC_ALL_INSTANCES);
            hWndInstanceList = GetDlgItem(hDlg, IDC_INSTANCE_LIST);
            // if "Select ALL" then clear list box selections and disable
            // the list box
            if (bMode) {
                SendMessageW(hWndInstanceList, LB_SETSEL, FALSE, (LPARAM) -1);
            }
            else {
                LRESULT dwCountInstance = SendMessage(hWndInstanceList, LB_GETCOUNT, 0, 0);
                LRESULT dwThisInstance  = 0;
                BOOL    bSelection      = FALSE;

                for (dwThisInstance = 0; ! bSelection && dwThisInstance < dwCountInstance; dwThisInstance ++) {
                    bSelection = (BOOL) SendMessage(hWndInstanceList, LB_GETSEL, (WPARAM) dwThisInstance, 0);
                }
                if (! bSelection) {
                    SendMessageW(hWndInstanceList, LB_SETSEL, TRUE, (LPARAM) 0);
                }
            }
            EnableWindow(hWndInstanceList, !bMode);
            pData->bSelectAllInstances = bMode;
            bReturn = TRUE;
            break;

        default:
            break;
        }
    }
    return bReturn;
}

STATIC_BOOL
PdhiBrowseCtrDlg_COUNTER_BUTTON(
    HWND    hDlg,
    WORD    wNotifyMsg,
    HWND    hWndControl
)
/*++
Routine Description:
    Processes the windows messags sent by the Instance configuration
        selection buttons

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the control
    IN  WORD    wNotifyMsg
        Notification message sent by the control
    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    BOOL                     bMode;
    HWND                     hWndCounterList;
    PPDHI_BROWSE_DIALOG_DATA pData;
    BOOL                     bReturn = FALSE;

    UNREFERENCED_PARAMETER(hWndControl);

    pData = (PPDHI_BROWSE_DIALOG_DATA)GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData != NULL) {
        switch (wNotifyMsg) {
        case BN_CLICKED:
            bMode           = (BOOL) IsDlgButtonChecked(hDlg, IDC_ALL_COUNTERS);
            hWndCounterList = GetDlgItem(hDlg, IDC_COUNTER_LIST);
            // if "Select ALL" then clear list box selections and disable
            // the list box
            if (bMode) {
                SendMessageW(hWndCounterList, LB_SETSEL, FALSE, (LPARAM) -1);
            }
            else {
                LRESULT dwCountCounter = SendMessage(hWndCounterList, LB_GETCOUNT, 0, 0);
                LRESULT dwThisCounter  = 0;
                BOOL  bSelection       = FALSE;

                for (dwThisCounter = 0; ! bSelection && dwThisCounter < dwCountCounter; dwThisCounter ++) {
                    bSelection = (BOOL) SendMessage(hWndCounterList, LB_GETSEL, (WPARAM) dwThisCounter, 0);
                }
                if (! bSelection) {
                    PDH_STATUS pdhStatus      = ERROR_SUCCESS;
                    DWORD      dwCounterName  = 0;
                    DWORD      dwCounterIndex = 0;
                    LPWSTR     szMachineName  = PdhiGetDlgText(hDlg, IDC_MACHINE_COMBO);
                    LPWSTR     szObjectName   = PdhiGetDlgText(hDlg, IDC_OBJECT_COMBO);
                    LPWSTR     szCounterName  = NULL;

                    if (szMachineName != NULL && szObjectName != NULL) {
                        pdhStatus = PdhGetDefaultPerfCounterHW(pData->pDlgData->hDataSource,
                                                               szMachineName,
                                                               szObjectName,
                                                               szCounterName,
                                                               & dwCounterName);
                        while (pdhStatus == PDH_MORE_DATA) {
                            G_FREE(szCounterName);
                            szCounterName = G_ALLOC(dwCounterName * sizeof(WCHAR));
                            if (szCounterName == NULL) {
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                            else {
                                pdhStatus = PdhGetDefaultPerfCounterHW(pData->pDlgData->hDataSource,
                                                                       szMachineName,
                                                                       szObjectName,
                                                                       szCounterName,
                                                                       & dwCounterName);
                            }
                        }
                        if (pdhStatus == ERROR_SUCCESS) {
                            dwCounterIndex = (DWORD) SendMessageW(hWndCounterList,
                                                                  LB_FINDSTRINGEXACT,
                                                                  (WPARAM) -1,
                                                                  (LPARAM) szCounterName);
                            if (dwCounterIndex == LB_ERR) {
                                dwCounterIndex = 0;
                            }
                            SendMessageW(hWndCounterList, LB_SETSEL, TRUE, (LPARAM) dwCounterIndex);
                        }
                    }
                    G_FREE(szMachineName);
                    G_FREE(szObjectName);
                    G_FREE(szCounterName);
                }
            }
            EnableWindow(hWndCounterList, !bMode);
            pData->bSelectAllCounters = bMode;
            bReturn = TRUE;
            break;

        default:
            break;
        }
    }
    return bReturn;
}

#pragma warning ( disable : 4127 )
STATIC_BOOL
PdhiBrowseCtrDlg_OK(
    HWND hDlg,
    WORD wNotifyMsg,
    HWND hWndControl
)
/*++
Routine Description:
    Processes the currently selected counter and instance strings to
        build a list of selected paths strings in the user's supplied
        buffer. This buffer will either be processed by a call back
        string or the dialog box will be terminated allowing the
        calling function to continue processing the returned strings.

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls
    IN  WORD    wNotifyMsg
        Notification message sent by the button
    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    HCURSOR                   hOldCursor;
    CounterPathCallBack       pCallBack;
    DWORD_PTR                 dwArg;
    PDH_STATUS                pdhStatus;
    PPDHI_BROWSE_DIALOG_DATA  pData;
    PPDHI_BROWSE_DLG_INFO     pDlgData;
    HWND                      hWndFocus;
    HWND                      hWndMachine;
    BOOL                      bReturn = FALSE;

    UNREFERENCED_PARAMETER(hWndControl);

    pData = (PPDHI_BROWSE_DIALOG_DATA) GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData == NULL) {
        goto Cleanup;
    }

    pDlgData    = pData->pDlgData;
    hWndFocus   = GetFocus();
    hWndMachine = GetDlgItem(hDlg, IDC_MACHINE_COMBO);

    if (hWndFocus == hWndMachine) {
        //special case to make sure the dialog has the current machine data
        PdhiBrowseCtrDlg_MACHINE_COMBO(hDlg, CBN_KILLFOCUS, hWndMachine);
        SetFocus(hWndControl);
    }

    switch (wNotifyMsg) {
    case BN_CLICKED:
        // display wait cursor while this is being processed
        hOldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

        while (TRUE) {
            if (pData->bShowObjects) {
                // then return object spec(s) using selected perf objects
                if (pDlgData->pWideStruct != NULL) {
                    // use wide character function
                    pdhStatus = PdhiCompileSelectedObjectsW(hDlg,
                                                            pDlgData->pWideStruct->szReturnPathBuffer,
                                                            pDlgData->pWideStruct->cchReturnPathLength);
                    pCallBack = pDlgData->pWideStruct->pCallBack;
                    dwArg     = pDlgData->pWideStruct->dwCallBackArg;
                    pDlgData->pWideStruct->CallBackStatus = pdhStatus;
                }
                else if (pDlgData->pAnsiStruct != NULL) {
                    // use ansi char functions
                    pdhStatus = PdhiCompileSelectedObjectsA(hDlg,
                                                            pDlgData->pAnsiStruct->szReturnPathBuffer,
                                                            pDlgData->pAnsiStruct->cchReturnPathLength);
                    pCallBack = pDlgData->pAnsiStruct->pCallBack;
                    dwArg     = pDlgData->pAnsiStruct->dwCallBackArg;
                    pDlgData->pAnsiStruct->CallBackStatus = pdhStatus;
                }
                else {
                    // do nothing
                    pCallBack = NULL;
                    dwArg = 0;
                }
            }
            else {
                // return selected counters & instances
                // process these string until it works. (note, this
                // could cause an infinite loop if the callback
                // function is not working correctly (i.e. always
                // returning PDH_RETRY, for example)
                if (pDlgData->pWideStruct != NULL) {
                    // use wide character function
                    pdhStatus = PdhiCompileSelectedCountersW(hDlg,
                                                             pDlgData->pWideStruct->szReturnPathBuffer,
                                                             pDlgData->pWideStruct->cchReturnPathLength);
                    pCallBack = pDlgData->pWideStruct->pCallBack;
                    dwArg     = pDlgData->pWideStruct->dwCallBackArg;
                    pDlgData->pWideStruct->CallBackStatus = pdhStatus;
                }
                else if (pDlgData->pAnsiStruct != NULL) {
                    // use ansi char functions
                    pdhStatus = PdhiCompileSelectedCountersA(hDlg,
                                                             pDlgData->pAnsiStruct->szReturnPathBuffer,
                                                             pDlgData->pAnsiStruct->cchReturnPathLength);
                    pCallBack = pDlgData->pAnsiStruct->pCallBack;
                    dwArg     = pDlgData->pAnsiStruct->dwCallBackArg;
                    pDlgData->pAnsiStruct->CallBackStatus = pdhStatus;
                }
                else {
                    // do nothing
                    pCallBack = NULL;
                    dwArg = 0;
                }

            }
            if (pCallBack != NULL) {
                pdhStatus = (* pCallBack)(dwArg);
            }
            else {
                pdhStatus = ERROR_SUCCESS;
            }

            // see if the callback wants to try again
            if (pdhStatus != PDH_RETRY) {
                break;
            }
        } // end while (retry loop)

        // if the caller only wants to give the user ONE chance to
        // add counters, then end the dialog now.
        if (! pData->bAddMultipleCounters) {
            EndDialog(hDlg, IDOK);
        }
        else {
            SetFocus(hWndFocus);
        }
        SetCursor(hOldCursor);
        bReturn = TRUE;
        break;

    default:
        break;
    }

Cleanup:
    return bReturn;
}
#pragma warning ( default : 4127 )

STATIC_BOOL
PdhiBrowseCtrDlg_CANCEL(
    HWND    hDlg,
    WORD    wNotifyMsg,
    HWND    hWndControl
)
/*++
Routine Description:
    Processes the windows messages that occur when the cancel button
        is pressed.

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls
    IN  WORD    wNotifyMsg
        Notification message sent by the button
    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    BOOL bReturn = FALSE;
    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
    case BN_CLICKED:
        EndDialog (hDlg, IDCANCEL);
        bReturn = TRUE;
        break;

    default:
        break;
    }
    return bReturn;
}

STATIC_BOOL
PdhiBrowseCtrDlg_EXPLAIN_BTN(
    HWND hDlg,
    WORD wNotifyMsg,
    HWND hWndControl
)
/*++
Routine Description:
    Processes the windows message that occurs when the help button
        is pressed. (This feature is not currently implemented)

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls
    IN  WORD    wNotifyMsg
        Notification message sent by the button
    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    HWND                     hFocusWnd;
    PPDHI_BROWSE_DIALOG_DATA pData = (PPDHI_BROWSE_DIALOG_DATA) GetWindowLongPtrW(hDlg, DWLP_USER);

    UNREFERENCED_PARAMETER(wNotifyMsg);
    if (hExplainDlg == NULL) {
        if (pData->bShowObjects) {
            hFocusWnd = GetDlgItem(hDlg, IDC_OBJECT_LIST);
        }
        else {
            hFocusWnd = GetDlgItem(hDlg, IDC_COUNTER_LIST);
        }
        if (hFocusWnd == NULL || hFocusWnd == INVALID_HANDLE_VALUE) {
            hFocusWnd = GetFocus();
        }

        // create a modeless dialog to display the explain text
        hExplainDlg = CreateDialogW(ThisDLLHandle,
                                    MAKEINTRESOURCEW(IDD_EXPLAIN_DLG),
                                    hDlg,
                                    ExplainTextDlgProc);

        SetFocus(hFocusWnd);
        EnableWindow(hWndControl, FALSE);
    }
    if (pData->bShowObjects) {
        SendMessageW(hDlg,
                     WM_COMMAND,
                     MAKEWPARAM(IDC_OBJECT_LIST, LBN_SELCHANGE),
                     (LPARAM) GetDlgItem(hDlg, IDC_OBJECT_LIST));
    }
    else {
        SendMessageW(hDlg,
                     WM_COMMAND,
                     MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                     (LPARAM) GetDlgItem(hDlg, IDC_COUNTER_LIST));
    }
    return TRUE;
}

STATIC_BOOL
PdhiBrowseCtrDlg_HELP_BTN(
    HWND    hDlg,
    WORD    wNotifyMsg,
    HWND    hWndControl
)
/*++
Routine Description:
    Processes the windows message that occurs when the network button
        is pressed. (This feature is not currently implemented)

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls
    IN  WORD    wNotifyMsg
        Notification message sent by the button
    IN  HWND    hWndControl
        Window handle of the control sending the message

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    LPWSTR szMsg;

    UNREFERENCED_PARAMETER(wNotifyMsg);
    UNREFERENCED_PARAMETER(hWndControl);

    szMsg = GetStringResource(IDS_ERR_NO_HELP);
    if (szMsg != NULL) {
        MessageBoxW(hDlg, szMsg, szMsg, MB_OK);
        G_FREE(szMsg);
    }
    else {
        MessageBeep(MB_ICONEXCLAMATION);
    }
    return TRUE;
}

STATIC_BOOL
PdhiBrowseCtrDlg_WM_INITDIALOG(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
/*++
Routine Description:
    Processes the windows message that occurs just before the dialog
        box is displayed for the first time.

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls
    IN  WORD    wParam
    IN  HWND    lParam
        Pointer to dialog box data block

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    PPDHI_BROWSE_DIALOG_DATA  pData;
    PPDHI_BROWSE_DLG_INFO     pDlgData;
    HCURSOR                   hOldCursor;
    LPWSTR                    szMsg;

    UNREFERENCED_PARAMETER (wParam);

    // reset the last error value
    SetLastError(ERROR_SUCCESS);

    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    pData = (PPDHI_BROWSE_DIALOG_DATA) G_ALLOC(sizeof(PDHI_BROWSE_DIALOG_DATA));
    if (pData == NULL) {
        SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
        EndDialog(hDlg, IDCANCEL);
        goto Cleanup;
    }

    // save user data

    pDlgData        = (PPDHI_BROWSE_DLG_INFO) lParam;
    pData->pDlgData = (PPDHI_BROWSE_DLG_INFO) lParam;

    SetWindowLongPtrW(hDlg, DWLP_USER, (LONG_PTR) pData);

    // load configuration flags from user data

    if (pData->pDlgData->pWideStruct != NULL) {
        // use wide structure
        pData->bShowIndex               = (BOOL) pDlgData->pWideStruct->bIncludeInstanceIndex;
        pData->bSelectMultipleCounters  = ! (BOOL) pDlgData->pWideStruct->bSingleCounterPerAdd;
        pData->bAddMultipleCounters     = ! (BOOL) pDlgData->pWideStruct->bSingleCounterPerDialog;
        pData->bLocalCountersOnly       = (BOOL) pDlgData->pWideStruct->bLocalCountersOnly;
        pData->bIncludeMachineInPath    = ! pData->bLocalCountersOnly;
        pData->bWildCardInstances       = (BOOL) pDlgData->pWideStruct->bWildCardInstances;
        pData->bHideDetailLevel         = (BOOL) pDlgData->pWideStruct->bHideDetailBox;
        if (pDlgData->pWideStruct->szDialogBoxCaption != NULL) {
            SetWindowTextW(hDlg, pDlgData->pWideStruct->szDialogBoxCaption);
        }
        pData->dwCurrentDetailLevel     = pDlgData->pWideStruct->dwDefaultDetailLevel;
        pData->bDisableMachineSelection = (BOOL) pDlgData->pWideStruct->bDisableMachineSelection;
        pData->bInitializePath          = (BOOL) pDlgData->pWideStruct->bInitializePath;
        pData->bIncludeCostlyObjects    = (BOOL) pDlgData->pWideStruct->bIncludeCostlyObjects;
        pData->bShowObjects             = (BOOL) pDlgData->pWideStruct->bShowObjectBrowser;
    }
    else if (pData->pDlgData->pAnsiStruct != NULL) {
        // use Ansi struct
        pData->bShowIndex               = (BOOL) pDlgData->pAnsiStruct->bIncludeInstanceIndex;
        pData->bSelectMultipleCounters  = ! (BOOL) pDlgData->pAnsiStruct->bSingleCounterPerAdd;
        pData->bAddMultipleCounters     = ! (BOOL) pDlgData->pAnsiStruct->bSingleCounterPerDialog;
        pData->bLocalCountersOnly       = (BOOL) pDlgData->pAnsiStruct->bLocalCountersOnly;
        pData->bIncludeMachineInPath    = ! pData->bLocalCountersOnly;
        pData->bWildCardInstances       = (BOOL) pDlgData->pAnsiStruct->bWildCardInstances;
        pData->bHideDetailLevel         = (BOOL) pDlgData->pAnsiStruct->bHideDetailBox;
        if (pDlgData->pAnsiStruct->szDialogBoxCaption != NULL) {
            SetWindowTextA(hDlg, pDlgData->pAnsiStruct->szDialogBoxCaption);
        }
        pData->dwCurrentDetailLevel     = pDlgData->pAnsiStruct->dwDefaultDetailLevel;
        pData->bDisableMachineSelection = (BOOL) pDlgData->pAnsiStruct->bDisableMachineSelection;
        pData->bInitializePath          = (BOOL) pDlgData->pAnsiStruct->bInitializePath;
        pData->bIncludeCostlyObjects    = (BOOL) pDlgData->pAnsiStruct->bIncludeCostlyObjects;
        pData->bShowObjects             = (BOOL) pDlgData->pAnsiStruct->bShowObjectBrowser;
    }
    else {
        // bad data so bail out
        EndDialog(hDlg, IDCANCEL);
        G_FREE(pData);
        goto Cleanup;
    }

    // selecting objects implies multiple selections
    if (pData->bShowObjects) {
        pData->bSelectMultipleCounters = TRUE;
    }
    // limit text to machine name
    SendDlgItemMessageW(hDlg, IDC_MACHINE_COMBO, EM_LIMITTEXT, MAX_PATH, 0);

    // set check boxes to the caller defined setting

    if (pData->bLocalCountersOnly) {
        // then only the local counters button is selected and enabled
        EnableWindow(GetDlgItem(hDlg, IDC_SELECT_MACHINE), FALSE);
    }

    CheckRadioButton(hDlg, IDC_USE_LOCAL_MACHINE, IDC_SELECT_MACHINE,
                    (pData->bIncludeMachineInPath ? IDC_SELECT_MACHINE : IDC_USE_LOCAL_MACHINE));
    EnableWindow(GetDlgItem(hDlg, IDC_MACHINE_COMBO), (pData->bIncludeMachineInPath ? TRUE : FALSE));

    if (! pData->bShowObjects) {
        // these controls aren't found in the Object browser
        CheckRadioButton(hDlg, IDC_ALL_INSTANCES, IDC_USE_INSTANCE_LIST, IDC_USE_INSTANCE_LIST);
        pData->bSelectAllInstances = FALSE;
        CheckRadioButton(hDlg, IDC_ALL_COUNTERS, IDC_USE_COUNTER_LIST, IDC_USE_COUNTER_LIST);
        pData->bSelectAllCounters = FALSE;
    }

    // set button text strings to reflect mode of dialog
    if (pData->bAddMultipleCounters) {
        szMsg = GetStringResource(IDS_BRWS_ADD);
        if (szMsg != NULL) {
            SetWindowTextW(GetDlgItem(hDlg, IDOK), (LPCWSTR) szMsg);
            G_FREE(szMsg);
        }
        szMsg = GetStringResource(IDS_BRWS_CLOSE);
        if (szMsg != NULL) {
            SetWindowTextW(GetDlgItem(hDlg, IDCANCEL), (LPCWSTR) szMsg);
            G_FREE(szMsg);
        }
    }
    else {
        szMsg = GetStringResource(IDS_BRWS_OK);
        if (szMsg != NULL) {
            SetWindowTextW(GetDlgItem(hDlg, IDOK), (LPCWSTR) szMsg);
            G_FREE(szMsg);
        }
        szMsg = GetStringResource(IDS_BRWS_CANCEL);
        if (szMsg != NULL) {
            SetWindowTextW(GetDlgItem(hDlg, IDCANCEL), (LPCWSTR) szMsg);
            G_FREE(szMsg);
        }
    }

    // see if the data source supports detail levels
    if (! PdhiDataSourceHasDetailLevelsH(pData->pDlgData->hDataSource)) {
        //then set detail to wizard and hide the combo box
        pData->bHideDetailLevel     = TRUE;
        pData->dwCurrentDetailLevel = PERF_DETAIL_WIZARD;
    }

    // hide detail combo box if desired
    if (pData->bHideDetailLevel) {
        ShowWindow(GetDlgItem(hDlg, IDC_COUNTER_DETAIL_CAPTION), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_COUNTER_DETAIL_COMBO), SW_HIDE);
        // make sure this is a "legal" value
        switch (pData->dwCurrentDetailLevel) {
        case PERF_DETAIL_NOVICE:
        case PERF_DETAIL_EXPERT:
        case PERF_DETAIL_ADVANCED:
        case PERF_DETAIL_WIZARD:
            // these are OK
            break;

        default:
            // default is to show all
            pData->dwCurrentDetailLevel = PERF_DETAIL_WIZARD;
            break;
        }
    }
    else {
        // load the combo box entries
        pData->dwCurrentDetailLevel = PdhiLoadDetailLevelCombo(hDlg, pData->dwCurrentDetailLevel);
    }

    // connect to this machine
    if (pData->pDlgData->hDataSource == H_REALTIME_DATASOURCE) {
        PPERF_MACHINE pMachine = GetMachine(NULL, 0, PDH_GM_UPDATE_NAME | PDH_GM_UPDATE_PERFNAME_ONLY);
        if (pMachine != NULL) {
            pMachine->dwRefCount --;
            RELEASE_MUTEX(pMachine->hMutex);
        }
        else {
            goto Cleanup;
        }
    }

    PdhiLoadKnownMachines(hDlg);    // load machine list
    PdhiLoadMachineObjects(hDlg, TRUE); // load object list
    if (!pData->bShowObjects) {
        // these controls don't exist in the object browser
        PdhiLoadCountersAndInstances(hDlg);
    }

    if (pData->bShowObjects) {
        // display explain text if necessary
        SendMessageW(hDlg,
                     WM_COMMAND,
                     MAKEWPARAM(IDC_OBJECT_LIST, LBN_SELCHANGE),
                     (LPARAM) GetDlgItem(hDlg, IDC_OBJECT_LIST));
    }
    else {
        // display explain text if necessary
        SendMessageW(hDlg,
                     WM_COMMAND,
                     MAKEWPARAM(IDC_COUNTER_LIST, LBN_SELCHANGE),
                     (LPARAM) GetDlgItem(hDlg, IDC_COUNTER_LIST));
    }

    if (pData->bInitializePath) {
        PdhiSelectItemsInPath(hDlg);
    }

    if (pData->pDlgData->hDataSource == H_REALTIME_DATASOURCE
            || pData->pDlgData->hDataSource == H_WBEM_DATASOURCE) {
        EnableWindow(GetDlgItem(hDlg, IDC_EXPLAIN_BTN), TRUE);
    }
    else {
        EnableWindow(GetDlgItem(hDlg, IDC_EXPLAIN_BTN), FALSE);
    }

    // hide the machine selection buttons and disable the
    // machine combo box if selected (after the connection has been
    // made, of course)

    if (pData->bDisableMachineSelection) {
        ShowWindow(GetDlgItem(hDlg, IDC_USE_LOCAL_MACHINE), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_SELECT_MACHINE), SW_HIDE);
        EnableWindow(GetDlgItem(hDlg, IDC_MACHINE_COMBO), FALSE);
        ShowWindow(GetDlgItem(hDlg, IDC_MACHINE_CAPTION), SW_SHOW);
    }
    else {
        EnableWindow(GetDlgItem(hDlg, IDC_MACHINE_COMBO), TRUE);
        ShowWindow(GetDlgItem(hDlg, IDC_MACHINE_CAPTION), SW_HIDE);
    }
    pData->wpLastMachineSel = 0;

Cleanup:
    hExplainDlg = NULL;
    SetCursor(hOldCursor);
    return TRUE;  // return TRUE unless you set the focus to a control
}

STATIC_BOOL
PdhiBrowseCtrDlg_WM_COMPAREITEM(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
/*++
Routine Description:
    Processes the windows message that are generated when a combo 
        box is searched

Arguments:
    IN  HWND    hDlg
        Window handle to the dialog box window
    IN  WPARAM  wParam
        HIWORD  is the notification message ID
        LOWORD  is the control ID of the control issuing the command
    IN  LPARAM  lParam
        the pointer to a compare item structure

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    LPCOMPAREITEMSTRUCT pCIS      = (LPCOMPAREITEMSTRUCT) lParam;
    LPWSTR              szString1;
    LPWSTR              szString2;
    int                 nResult;
    BOOL                bReturn   = (BOOL) 0;

    UNREFERENCED_PARAMETER(hDlg);

    if (wParam == IDC_MACHINE_COMBO) {
        // then process this 
        szString1 = (LPWSTR) pCIS->itemData1;
        szString2 = (LPWSTR) pCIS->itemData2;
        if ((szString1 != NULL) && (szString2 != NULL)) {
            nResult = lstrcmpiW(szString1, szString2);
        }
        else {
            nResult = 0;
        }
        if (nResult < 0) {
            // string 1 < string 2
            bReturn = (BOOL) -1;
        }
        else if (nResult > 0) {
            // string 1 > string 2
            bReturn = (BOOL) 1;
        }
    }
    return bReturn;
}

STATIC_BOOL
PdhiBrowseCtrDlg_WM_COMMAND(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
/*++
Routine Description:
    Processes the windows message that occurs when the user interacts
        with the dialog box

Arguments:
    IN  HWND    hDlg
        Window handle to the dialog box window
    IN  WPARAM  wParam
        HIWORD  is the notification message ID
        LOWORD  is the control ID of the control issuing the command
    IN  LPARAM  lParam
        The window handle of the controle issuing the message

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    BOOL  bReturn    = FALSE;
    WORD  wNotifyMsg = HIWORD(wParam);

    switch (LOWORD(wParam)) {   // select on the control ID
    case IDC_USE_LOCAL_MACHINE:
    case IDC_SELECT_MACHINE:
        bReturn = PdhiBrowseCtrDlg_MACHINE_BUTTON(hDlg, wNotifyMsg, (HWND) lParam);
        break;

    case IDC_MACHINE_COMBO:
        bReturn = PdhiBrowseCtrDlg_MACHINE_COMBO(hDlg, wNotifyMsg, (HWND) lParam);
        break;

    case IDC_OBJECT_COMBO:
        bReturn = PdhiBrowseCtrDlg_OBJECT_COMBO(hDlg, wNotifyMsg, (HWND) lParam);
        break;

    case IDC_ALL_INSTANCES:
    case IDC_USE_INSTANCE_LIST:
        bReturn = PdhiBrowseCtrDlg_INSTANCE_BUTTON(hDlg, wNotifyMsg, (HWND) lParam);
        break;

    case IDC_ALL_COUNTERS:
    case IDC_USE_COUNTER_LIST:
        bReturn = PdhiBrowseCtrDlg_COUNTER_BUTTON(hDlg, wNotifyMsg, (HWND) lParam);
        break;

    case IDC_COUNTER_LIST:
        bReturn = PdhiBrowseCtrDlg_COUNTER_LIST(hDlg, wNotifyMsg, (HWND) lParam);
        break;

    case IDC_OBJECT_LIST:
        bReturn = PdhiBrowseCtrDlg_OBJECT_LIST(hDlg, wNotifyMsg, (HWND) lParam);
        break;

    case IDC_COUNTER_DETAIL_COMBO:
        bReturn = PdhiBrowseCtrDlg_DETAIL_COMBO(hDlg, wNotifyMsg, (HWND) lParam);
        break;

    case IDOK:
        bReturn = PdhiBrowseCtrDlg_OK(hDlg, wNotifyMsg, (HWND) lParam);
        break;

    case IDCANCEL:
        bReturn = PdhiBrowseCtrDlg_CANCEL(hDlg, wNotifyMsg, (HWND) lParam);
        break;

    case IDC_EXPLAIN_BTN:
        bReturn = PdhiBrowseCtrDlg_EXPLAIN_BTN(hDlg, wNotifyMsg, (HWND) lParam);
        break;

    case IDC_HELP_BTN:
        bReturn = PdhiBrowseCtrDlg_HELP_BTN(hDlg, wNotifyMsg, (HWND) lParam);
        break;

    default:
        break;
    }
    return bReturn;
}

STATIC_BOOL
PdhiBrowseCtrDlg_WM_SYSCOMMAND(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
/*++
Routine Description:
    Processes the windows message that occurs when the user selects an
        item from the system menu

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls
    IN  WPARAM  wParam
        menu ID of item selected
    IN  LPARAM  lParam
        Not Used

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    BOOL bReturn = FALSE;
    UNREFERENCED_PARAMETER(lParam);

    switch (wParam) {
    case SC_CLOSE:
        EndDialog(hDlg, IDOK);
        bReturn = TRUE;
        break;

    default:
        break;
    }
    return bReturn;
}

STATIC_BOOL
PdhiBrowseCtrDlg_WM_CLOSE(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
/*++
Routine Description:
    Processes the windows message that occurs when the dialog box
        is closed. No processing is needed so this function merely returns.

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls
    IN  WPARAM  wParam
        Not Used
    IN  LPARAM  lParam
        Not Used

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(hDlg);
    return TRUE;
}

STATIC_BOOL
PdhiBrowseCtrDlg_WM_DESTROY(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
/*++
Routine Description:
    Processes the windows message that occurs just before the window
        is destroyed. Any memory allocations made are now freed.

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls
    IN  WPARAM  wParam
        Not Used
    IN  LPARAM  lParam
        Not Used

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    PPDHI_BROWSE_DIALOG_DATA  pData;
    BOOL                      bReturn = FALSE;

    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);

    pData = (PPDHI_BROWSE_DIALOG_DATA) GetWindowLongPtrW(hDlg, DWLP_USER);
    if (pData != NULL) {
        G_FREE(pData); // free memory block
        bReturn = TRUE;
    }

    return bReturn;
}

INT_PTR
CALLBACK
BrowseCounterDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
)
/*++
Routine Description:
    Processes all windows messages that are sent to the dialog box window.
        This function is the main dispatching function for the processing
        of these messages.

Arguments:
    IN  HWND    hDlg
        Window Handle to the dialog box containing the button controls
    IN  WPARAM  wParam
        Not Used
    IN  LPARAM  lParam
        Not Used

Return Value:
    TRUE if this function handles the message
    FALSE if this function did not process the message and the Default
        message handler for this function should handle the message
--*/
{
    
    BOOL bReturn = FALSE;
    
    switch (message) { 
    case WM_INITDIALOG:
        bReturn = PdhiBrowseCtrDlg_WM_INITDIALOG(hDlg, wParam, lParam);
        break;

    case WM_COMMAND:
        bReturn = PdhiBrowseCtrDlg_WM_COMMAND(hDlg, wParam, lParam);
        break;

    case WM_SYSCOMMAND:
        bReturn = PdhiBrowseCtrDlg_WM_SYSCOMMAND(hDlg, wParam, lParam);
        break;

    case WM_CLOSE:
        bReturn = PdhiBrowseCtrDlg_WM_CLOSE(hDlg, wParam, lParam);
        break;

    case WM_DESTROY:
        bReturn = PdhiBrowseCtrDlg_WM_DESTROY(hDlg, wParam, lParam);
        break;

    case WM_COMPAREITEM:
        bReturn = PdhiBrowseCtrDlg_WM_COMPAREITEM(hDlg, wParam, lParam);
        break;

    case EDM_EXPLAIN_DLG_CLOSING:
        hExplainDlg = NULL;
        EnableWindow(GetDlgItem(hDlg, IDC_EXPLAIN_BTN), TRUE);
        bReturn = TRUE;
        break;

    case WM_CONTEXTMENU:
        {
            INT  iCtrlID = GetDlgCtrlID((HWND) wParam);
            if (0 != iCtrlID) {
                LPWSTR pszHelpFilePath = NULL;
                DWORD  dwLen           = 2 * (MAX_PATH + 1);

                pszHelpFilePath = G_ALLOC(dwLen * sizeof(WCHAR));
                if (pszHelpFilePath != NULL) {
                    if (GetWindowsDirectoryW(pszHelpFilePath, dwLen) > 0) {
                        StringCchCatW(pszHelpFilePath, dwLen, L"\\help\\sysmon.hlp");
                        bReturn = WinHelpW((HWND) wParam,
                                           pszHelpFilePath,
                                           HELP_CONTEXTMENU,
                                           (DWORD_PTR) PdhiBrowseraulControlIdToHelpIdMap);
                    }
                    G_FREE(pszHelpFilePath);
                }
            }
        }
        break;

    case WM_HELP:
        {
            // Only display help for known context IDs.
            LPWSTR     pszHelpFilePath = NULL;
            DWORD      dwLen;
            LPHELPINFO pInfo           = (LPHELPINFO) lParam;

            if (pInfo->iContextType == HELPINFO_WINDOW) {
                for (dwLen = 0; PdhiBrowseraulControlIdToHelpIdMap[dwLen] != 0; dwLen += 2) {
                    if ((INT) PdhiBrowseraulControlIdToHelpIdMap[dwLen] == pInfo->iCtrlId) {
                        break;
                    }
                }
                if (PdhiBrowseraulControlIdToHelpIdMap[dwLen] != 0) {
                    dwLen           = 2 * (MAX_PATH + 1);
                    pszHelpFilePath = G_ALLOC(dwLen * sizeof(WCHAR));
                    if (pszHelpFilePath != NULL) {
                        if (GetWindowsDirectoryW(pszHelpFilePath, dwLen) > 0) {
                            StringCchCatW(pszHelpFilePath, dwLen, L"\\help\\sysmon.hlp");
                            bReturn = WinHelpW(pInfo->hItemHandle,
                                               pszHelpFilePath,
                                               HELP_WM_HELP,
                                               (DWORD_PTR) PdhiBrowseraulControlIdToHelpIdMap);
                        }
                        G_FREE(pszHelpFilePath);
                    }
                }
            }
        } 
        break;

    default:
        break;
    }
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhui\browser.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    browser.c

Abstract:

    counter name browsing functions exposed by the PDH.DLL

--*/
#include <windows.h>
#include <math.h>
#include <mbctype.h>
#include "strsafe.h"
#include "pdh.h"
#include "pdhmsg.h"
#include "strings.h"
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhdlgs.h"
#include "perfdata.h"
#include "browsdlg.h"

#pragma warning ( disable : 4213)

PDH_FUNCTION
PdhSetDefaultRealTimeDataSource(
    IN  DWORD   dwDataSourceId
)
{
    DWORD dwReturn = ERROR_SUCCESS;

    if (dwCurrentRealTimeDataSource <= 0) {
        switch (dwDataSourceId) {
        case DATA_SOURCE_WBEM:
        case DATA_SOURCE_REGISTRY:
            // this is OK so set local variable
            dwPdhiLocalDefaultDataSource = dwDataSourceId;
            break;

        case DATA_SOURCE_LOGFILE:
        default:
            // these are not OK so insert default
            dwReturn = PDH_INVALID_ARGUMENT;
            break;
        }
    }
    else {
        // a default realtime data source has already been defined
        dwReturn = PDH_CANNOT_SET_DEFAULT_REALTIME_DATASOURCE;
    }
    return dwReturn;
}

DWORD
DataSourceTypeH(
    HLOG hDataSource
)
{
    return (hDataSource == H_REALTIME_DATASOURCE) ? (dwPdhiLocalDefaultDataSource)
            : (hDataSource == H_WBEM_DATASOURCE ? DATA_SOURCE_WBEM : DATA_SOURCE_LOGFILE);
}

DWORD
DataSourceTypeA(
    LPCSTR   szDataSource
)
{
    DWORD dwDataSource = dwPdhiLocalDefaultDataSource;

    if (szDataSource != NULL) {
        // see if the prefix to the file name is "WBEM:"
        // indicating this is a WBEM name space instead of a
        // log file name
        // if the file name has a "WBEM:" in the front, then
        // set the flag appropriately

        dwDataSource = (_strnicmp(szDataSource, caszWBEM, lstrlenA(caszWBEM)) != 0
                               && _strnicmp(szDataSource, caszWMI, lstrlenA(caszWMI)) != 0)
                     ? DATA_SOURCE_LOGFILE : DATA_SOURCE_WBEM;
    }
    return dwDataSource;
}

DWORD
DataSourceTypeW(
    LPCWSTR  szDataSource
)
{
    DWORD dwDataSource = dwPdhiLocalDefaultDataSource;

    if (szDataSource != NULL) {
        // see if the prefix to the file name is "WBEM:"
        // indicating this is a WBEM name space instead of a
        // log file name
        // if the file name has a "WBEM:" in the front, then
        // set the flag appropriately
        // Else check if it is "SQL:" prefixed

        dwDataSource = (_wcsnicmp(szDataSource, cszWBEM, lstrlenW(cszWBEM)) != 0
                               && _wcsnicmp(szDataSource, cszWMI, lstrlenW(cszWMI)) != 0)
                     ? DATA_SOURCE_LOGFILE : DATA_SOURCE_WBEM;
    }
    return dwDataSource;
}

PDH_FUNCTION
PdhConnectMachineW(
    IN  LPCWSTR  szMachineName
)
/*++
Routine Description:
  Establishes a connection to the specified machine for reading perforamance
  data from the machine.

Arguments:
    LPCWSTR szMachineName
        The name of the machine to connect to. If this argument is NULL,
        then the local machine is opened.

Return Value:
  PDH Error status value
    ERROR_SUCCESS   indicates the machine was successfully connected and the
        performance data from that machine was loaded.
    PDH_ error code indicates that the machine could not be located or opened.
        The status code indicates the problem.
--*/
{
    PPERF_MACHINE pMachine  = NULL;
    PDH_STATUS    pdhStatus = ERROR_SUCCESS;

    if (szMachineName != NULL) {
        __try {
            // test buffer access
            if (* szMachineName == L'\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenW(szMachineName) > PDH_MAX_COUNTER_NAME) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pMachine = GetMachine((LPWSTR) szMachineName, 0, PDH_GM_UPDATE_NAME | PDH_GM_UPDATE_PERFNAME_ONLY);
        if (pMachine != NULL) {
            // then return the machine status
            pdhStatus = pMachine->dwStatus;
            pMachine->dwRefCount --;
            RELEASE_MUTEX(pMachine->hMutex);
        }
        else {
            // return the status from the GetMachine call
            pdhStatus = GetLastError();
        }
    } // else pass the status to the caller
    return pdhStatus;
}

PDH_FUNCTION
PdhConnectMachineA(
    IN  LPCSTR  szMachineName
)
/*++
Routine Description:
  Establishes a connection to the specified machine for reading perforamance
  data from the machine.

Arguments:
    LPCSTR  szMachineName
        The name of the machine to connect to. If this argument is NULL,
        then the local machine is opened.

Return Value:
  PDH Error status value
    ERROR_SUCCESS   indicates the machine was successfully connected and the
        performance data from that machine was loaded.
    PDH_ error code indicates that the machine could not be located or opened.
        The status code indicates the problem.
--*/
{
    LPWSTR        szWideName   = NULL;
    DWORD         dwNameLength = 0;
    PDH_STATUS    pdhStatus    = ERROR_SUCCESS;
    PPERF_MACHINE pMachine     = NULL;

    if (szMachineName != NULL) {
        __try {
            // test buffer access
            if (* szMachineName == '\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenA(szMachineName) > PDH_MAX_COUNTER_NAME) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        if (pdhStatus == ERROR_SUCCESS) {
            szWideName = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szMachineName);
            if (szWideName == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pMachine = GetMachine(szWideName, 0, PDH_GM_UPDATE_NAME | PDH_GM_UPDATE_PERFNAME_ONLY);
        if (pMachine != NULL) {
            // then return the machine status
            pdhStatus = pMachine->dwStatus;
            pMachine->dwRefCount --;
            RELEASE_MUTEX(pMachine->hMutex);
        }
        else {
            // return the status from the GetMachine call
            pdhStatus = GetLastError();
        }
    }

    G_FREE(szWideName);
    return pdhStatus;
}

STATIC_PDH_FUNCTION
PdhiEnumConnectedMachines(
    LPVOID  pMachineList,
    LPDWORD pcchBufferSize,
    BOOL    bUnicode
)
/*++
Routine Description:
    Builds a MSZ list of the machines currently known by the PDH. This
        list includes machines with open sessions as well as those that
        are off-line.

Arguments:
    IN      LPVOID  pMachineList
            A pointer to the buffer to receive the enumerated machine list.
            The strings written to this buffer will contain the characters
            specified by the bUnicode argument
    IN      LPVOID  pMachineList
            A pointer to the buffer to receive the enumerated machine list.
            The strings written to this buffer will contain the characters
            specified by the bUnicode argument
    IN      LPDWORD pcchBufferSize
            The size of the buffer referenced by pMachineList in characters
    IN      BOOL    bUnicode
            TRUE = UNICODE characters will be written to the pMachineList
                    buffer
            FALSE = ANSI characters will be writtn to the pMachinList buffer

Return Value:
    ERROR_SUCCESS if this the function completes successfully. a PDH error
        value if not.
    PDH_MORE_DATA some entries were returned, but there was not enough
        room in the buffer to store all entries.
    PDH_INVALID_ARGUMENT unable to write to the size buffers or the
        data buffer
--*/
{
    PPERF_MACHINE   pThisMachine;
    DWORD           dwRequiredLength = 0;
    DWORD           dwMaximumLength;
    DWORD           dwNameLength;
    PDH_STATUS      pdhStatus        = ERROR_SUCCESS;
    LPVOID          szNextName;

    // reset the last error value
    SetLastError(ERROR_SUCCESS);

    // first walk down list to compute required length

    pThisMachine = pFirstMachine;

    __try {
        // get a local copy of the size and try writing to the variable
        // to test read & write access of args before continuing

        dwMaximumLength  = * pcchBufferSize;
        * pcchBufferSize = 0;
        * pcchBufferSize = dwMaximumLength;

        // point to first machine entry in list
        szNextName = pMachineList;

        // walk around entire list
        if (pThisMachine != NULL) {
            do {
                if (bUnicode) {
                    dwNameLength = lstrlenW(pThisMachine->szName) + 1;
                    if (szNextName != NULL && dwRequiredLength + dwNameLength <= dwMaximumLength) {
                        StringCchCopyW((LPWSTR) szNextName, dwMaximumLength - dwRequiredLength, pThisMachine->szName);
                        (LPBYTE) szNextName += sizeof(WCHAR) * (dwNameLength - 1);
                        * ((LPWSTR) szNextName) ++ = L'\0';
                    }
                    else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                }
                else {
                    dwNameLength = (dwRequiredLength <= dwMaximumLength)
                                 ? (dwMaximumLength - dwRequiredLength) : (0);
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                         pThisMachine->szName,
                                                         (LPSTR) szNextName,
                                                         & dwNameLength);
                    if (pdhStatus == ERROR_SUCCESS) {
                        (LPBYTE) szNextName += sizeof(CHAR) * dwNameLength;
                    }
                }
                dwRequiredLength += dwNameLength;
                // go to next machine in list
                pThisMachine      = pThisMachine->pNext;
            }
            while (pThisMachine != pFirstMachine);
        }
        else {
            // no machines in list, so insert an empty string
            if (++ dwRequiredLength <= dwMaximumLength) {
                if (bUnicode) {
                    * ((LPWSTR) szNextName) ++ = L'\0';
                }
                else {
                    * ((LPSTR) szNextName) ++ = '\0';
                }
                pdhStatus = ERROR_SUCCESS;
            }
            else if (dwMaximumLength != 0) {
                // then the buffer is too small
                pdhStatus = PDH_MORE_DATA;
            }
        }
        // all entries have been checked and /or copied
        //  so terminate the MSZ or at least account for the required size
        dwRequiredLength ++;
        if (szNextName != NULL && dwRequiredLength <= dwMaximumLength) {
            if (bUnicode) {
                * ((LPWSTR) szNextName) ++ = L'\0';
            }
            else {
                * ((LPSTR) szNextName) ++ = '\0';
            }
            pdhStatus = ERROR_SUCCESS;
        }
        else if (pdhStatus == ERROR_SUCCESS) {
            // then the buffer is too small
            pdhStatus = PDH_MORE_DATA;
        }
        //return the required size or size used
        * pcchBufferSize = dwRequiredLength;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhEnumMachinesHW(
    IN  HLOG    hDataSource,
    IN  LPWSTR  mszMachineList,
    IN  LPDWORD pcchBufferSize
)
{
    PDH_STATUS pdhStatus    = ERROR_SUCCESS;
    DWORD      dwBufferSize = 0;
    DWORD      dwDataSource = 0;

    if (pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwDataSource = DataSourceTypeH(hDataSource);
            dwBufferSize = * pcchBufferSize;
            if (dwBufferSize > 0) {
                if (mszMachineList != NULL) {
                    mszMachineList[0]                = L'\0';
                    mszMachineList[dwBufferSize - 1] = L'\0';
                }
                else {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        }
         __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                pdhStatus = PdhiEnumConnectedMachines((LPVOID) mszMachineList, & dwBufferSize, TRUE);
                break;

            case DATA_SOURCE_WBEM:
                pdhStatus = PdhiEnumWbemMachines((LPVOID) mszMachineList, & dwBufferSize, TRUE);
                break;

            case DATA_SOURCE_LOGFILE:
                pdhStatus = PdhiEnumLoggedMachines(hDataSource, (LPVOID) mszMachineList, & dwBufferSize, TRUE);
                break;

            default:
                pdhStatus = PDH_INVALID_ARGUMENT;
                break;
            }
        }
         __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        RELEASE_MUTEX(hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        __try {
            * pcchBufferSize = dwBufferSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumMachinesW(
    IN  LPCWSTR  szDataSource,
    IN  LPWSTR   mszMachineList,
    IN  LPDWORD  pcchBufferSize
)
/*++
Routine Description:
    Builds a MSZ list of the machines currently known by the PDH. This
        list includes machines with open sessions as well as those that
        are off-line.

Arguments:
    IN      LPCWSTR  szDataSource
            NULL for current real-time data or the name of a log file
    IN      LPWSTR  szMachineList
            A pointer to the buffer to receive the enumerated machine list.
            The strings written to this buffer will contain UNICODE chars
    IN      LPDWORD pcchBufferSize
            The size of the buffer referenced by pMachineList in characters
            The value of the buffer referenced by this pointer may be 0
            if the required size is requested.

Return Value:
    ERROR_SUCCESS if this the function completes successfully. a PDH error
        value if not.
    PDH_MORE_DATA some entries were returned, but there was not enough
        room in the buffer to store all entries.
    PDH_INVALID_ARGUMENT unable to write to the size buffers or the
        data buffer
--*/
{
    PDH_STATUS  pdhStatus    = ERROR_SUCCESS;
    DWORD       dwDataSource = 0;
    HLOG        hDataSource  = H_REALTIME_DATASOURCE;

    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (* szDataSource == L'\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenW(szDataSource) >= PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg
        if (pdhStatus == ERROR_SUCCESS) {
            dwDataSource = DataSourceTypeW(szDataSource);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;
            pdhStatus = PdhOpenLogW(szDataSource,
                                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                    & dwLogType,
                                    NULL,
                                    0,
                                    NULL,
                                    & hDataSource);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhEnumMachinesHW(hDataSource, mszMachineList, pcchBufferSize);
        if (dwDataSource == DATA_SOURCE_LOGFILE) {
            PdhCloseLog(hDataSource, 0);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumMachinesHA(
    IN  HLOG    hDataSource,
    IN  LPSTR   mszMachineList,
    IN  LPDWORD pcchBufferSize
)
{
    PDH_STATUS  pdhStatus    = ERROR_SUCCESS;
    DWORD       dwBufferSize = 0;
    DWORD       dwDataSource = 0;

    if (pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {        
        __try {
            dwDataSource = DataSourceTypeH(hDataSource);
            dwBufferSize = * pcchBufferSize;
            if (dwBufferSize > 0) {
                if (mszMachineList != NULL) {
                    mszMachineList[0]                = '\0';
                    mszMachineList[dwBufferSize - 1] = '\0';
                }
                else {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        }
         __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                pdhStatus = PdhiEnumConnectedMachines((LPVOID) mszMachineList, & dwBufferSize, FALSE);
                break;

            case DATA_SOURCE_WBEM:
                pdhStatus = PdhiEnumWbemMachines((LPVOID) mszMachineList, & dwBufferSize, FALSE);
                break;

            case DATA_SOURCE_LOGFILE:
                pdhStatus = PdhiEnumLoggedMachines(hDataSource, (LPVOID) mszMachineList, & dwBufferSize, FALSE);
                break;

            default:
                pdhStatus = PDH_INVALID_ARGUMENT;
                break;
            }
        }
         __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        RELEASE_MUTEX (hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        __try {
            * pcchBufferSize = dwBufferSize;
        }
         __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumMachinesA(
    IN  LPCSTR   szDataSource,
    IN  LPSTR    mszMachineList,
    IN  LPDWORD  pcchBufferSize
)
/*++
Routine Description:
    Builds a MSZ list of the machines currently known by the PDH. This
        list includes machines with open sessions as well as those that
        are off-line.

Arguments:
    IN      LPCSTR  szDataSource
            NULL for current real-time data or the name of a log file
    IN      LPWSTR  szMachineList
            A pointer to the buffer to receive the enumerated machine list.
            The strings written to this buffer will contain UNICODE chars
    IN      LPDWORD pcchBufferSize
            The size of the buffer referenced by pMachineList in characters
            The value of the buffer referenced by this pointer may be 0
            if the required size is requested.

Return Value:
    ERROR_SUCCESS if this the function completes successfully. a PDH error
        value if not.
    PDH_MORE_DATA some entries were returned, but there was not enough
        room in the buffer to store all entries.
    PDH_INVALID_ARGUMENT unable to write to the size buffers or the
        data buffer
--*/
{
    PDH_STATUS  pdhStatus    = ERROR_SUCCESS;
    DWORD       dwDataSource = 0;
    HLOG        hDataSource  = H_REALTIME_DATASOURCE;

    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (* szDataSource == '\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenA(szDataSource) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg
        if (pdhStatus == ERROR_SUCCESS) {
            dwDataSource = DataSourceTypeA(szDataSource);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogA(szDataSource,
                                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                    & dwLogType,
                                    NULL,
                                    0,
                                    NULL,
                                    & hDataSource);
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhEnumMachinesHA(hDataSource, mszMachineList, pcchBufferSize);
        if (dwDataSource == DATA_SOURCE_LOGFILE) {
            PdhCloseLog(hDataSource, 0);
        }
    }
    return pdhStatus;
}

#pragma warning ( disable : 4127 )
PDH_FUNCTION
PdhiEnumObjects(
    LPWSTR  szMachineName,
    LPVOID  mszObjectList,
    LPDWORD pcchBufferSize,
    DWORD   dwDetailLevel,
    BOOL    bRefresh,
    BOOL    bUnicode
)
/*++
Routine Description:
    Lists the performance objects found on the specified machine as
        a MSZ list.

Arguments:
    IN      LPWSTR  szMachineName
            The machine to list objects from
    IN      LPVOID  mszObjectList
            a pointer to the  buffer to receive the list of performance
            objects
    IN      LPDWORD pcchBufferSize
            a pointer to the DWORD containing the size of the mszObjectList
            buffer in characters. The characters assumed are determined by
            the bUnicode argument.
    IN      DWORD   dwDetailLevel
            The detail level to use as a filter of objects. All objects
            with a detail level less than or equal to that specified
            by this argument will be returned.
    IN      BOOL    bRefresh
            TRUE = retrive a new perf. data buffer for this machine before
                listing the objects
            FALSE = use the currently cached perf data buffer for this
                machine to enumerate objects
    IN      BOOL    bUnicode
            TRUE = return the listed objects as UNICODE strings
            FALSE = return the listed objects as ANSI strings

Return Value:
    ERROR_SUCCESS if the function completes successfully. Otherwise a
        PDH_ error status if not.
    PDH_MORE_DATA is returned when there are more entries available to
        return than there is room in the buffer. Some entries may be
        returned in the buffer though.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
--*/
{
    PPERF_MACHINE       pMachine;
    PDH_STATUS          pdhStatus        = ERROR_SUCCESS;
    DWORD               NumTypeDef;
    PPERF_OBJECT_TYPE   pObjectDef;
    DWORD               dwRequiredLength = 0;
    LPVOID              szNextName;
    DWORD               dwNameLength;
    DWORD               dwMaximumLength;
    LPWSTR              szObjNameString;
    WCHAR               wszNumberString[32];
    DWORD               dwGmFlags;
    DWORD               dwLocalDetailLevel;

    LPDWORD             pdwIndex = NULL;
    DWORD               dwAlloc  = MAX_PATH;
    DWORD               dwUsed   = 0;
    DWORD               i;

    // connect to machine and update data if desired
    if (bRefresh) {
        dwGmFlags  = PDH_GM_UPDATE_PERFDATA;
        dwGmFlags |= ((dwDetailLevel & PERF_DETAIL_COSTLY) == PERF_DETAIL_COSTLY) ? PDH_GM_READ_COSTLY_DATA : 0;
    }
    else {
        dwGmFlags = 0;
    }

    // connect to machine and update data if desired
    pMachine        = GetMachine(szMachineName, 0, (bRefresh ? PDH_GM_UPDATE_PERFDATA : 0));
    dwMaximumLength = * pcchBufferSize;

    if (pMachine != NULL) {
        if (pMachine->dwStatus == ERROR_SUCCESS) {
            if ((dwDetailLevel & PERF_DETAIL_COSTLY) && ! (pMachine->dwMachineFlags & PDHIPM_FLAGS_HAVE_COSTLY)) {
                // then get them
                pMachine->dwRefCount --;
                RELEASE_MUTEX(pMachine->hMutex);
                dwGmFlags = PDH_GM_UPDATE_PERFDATA | PDH_GM_READ_COSTLY_DATA;
                pMachine  = GetMachine(szMachineName, 0, dwGmFlags);
            }
        }
    }
    if (pMachine != NULL) {
        // make sure the machine connection is valid
        if (pMachine->dwStatus == ERROR_SUCCESS) {
            dwRequiredLength = 0;
            szNextName       = mszObjectList;

            // start walking object list
            pObjectDef = FirstObject(pMachine->pSystemPerfData);
            if ((pMachine->pSystemPerfData->NumObjectTypes > 0) && (pObjectDef != NULL)) {
                // convert detail level to the PerfLib detail level
                dwLocalDetailLevel = dwDetailLevel & PERF_DETAIL_STANDARD;
                // build list
                NumTypeDef = 0;
                pdwIndex = (LPDWORD) G_ALLOC(dwAlloc * sizeof(DWORD));
                if (pdwIndex == NULL) {
                    pMachine->dwRefCount --;
                    RELEASE_MUTEX(pMachine->hMutex);
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    goto Cleanup;
                }
                while (1) {
                    // only look at entries matching the desired Detail Level
                    if (pObjectDef->DetailLevel <= dwLocalDetailLevel) {
                        for (i = 0; i < dwUsed; i ++) {
                            if (pdwIndex[i] == pObjectDef->ObjectNameTitleIndex) break;
                        }
                        if (i == dwUsed) {
                            if (dwUsed >= dwAlloc) {
                                LPDWORD pdwTmp = pdwIndex;
                                dwAlloc += dwAlloc;
                                pdwIndex = (LPDWORD) G_REALLOC(pdwTmp, dwAlloc * sizeof(DWORD));
                                if (pdwIndex == NULL) {
                                    G_FREE(pdwTmp);
                                    pMachine->dwRefCount --;
                                    RELEASE_MUTEX(pMachine->hMutex);
                                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                    goto Cleanup;
                                }
                            }
                            pdwIndex[dwUsed] = pObjectDef->ObjectNameTitleIndex;
                            dwUsed ++;

                            if (pObjectDef->ObjectNameTitleIndex < pMachine->dwLastPerfString) {
                                szObjNameString = (LPWSTR) PdhiLookupPerfNameByIndex(pMachine,
                                                                                     pObjectDef->ObjectNameTitleIndex);
                            }
                            else {
                                // no match since the index is larger that that found
                                // in the data buffer
                                szObjNameString = NULL;
                            }

                            if (szObjNameString == NULL) {
                                // then this object has no string name so use
                                // the object number
                                _ltow(pObjectDef->ObjectNameTitleIndex, wszNumberString, 10);
                                szObjNameString = wszNumberString;
                            }

                            // compute length
                            if (bUnicode) {
                                dwNameLength = lstrlenW(szObjNameString) + 1;
                                if (szNextName != NULL && dwRequiredLength + dwNameLength <= dwMaximumLength) {
                                    StringCchCopyW((LPWSTR) szNextName,
                                                   dwMaximumLength - dwRequiredLength,
                                                   szObjNameString);
                                    (LPBYTE) szNextName += (dwNameLength - 1) * sizeof(WCHAR);
                                    * ((LPWSTR) szNextName) ++ = L'\0';
                                }
                                else {
                                    pdhStatus = PDH_MORE_DATA;
                                }
                            }
                            else {
                                dwNameLength = (dwRequiredLength <= dwMaximumLength)
                                             ? (dwMaximumLength - dwRequiredLength) : (0);
                                pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                                     szObjNameString,
                                                                     (LPSTR) szNextName,
                                                                     & dwNameLength);
                                if (pdhStatus == ERROR_SUCCESS) {
                                    (LPBYTE) szNextName += sizeof(CHAR) * dwNameLength;
                                }
                            }
                            dwRequiredLength += dwNameLength;
                        }
                    }

                    // go to next object in the data block
                    NumTypeDef ++;
                    if (NumTypeDef >= pMachine->pSystemPerfData->NumObjectTypes) {
                        // that's enough so break out of the loop
                        break;
                    }
                    else {
                        // goto the next one and make sure it's valid
                        pObjectDef = NextObject(pMachine->pSystemPerfData, pObjectDef); // get next
                        //make sure next object is legit
                        if (pObjectDef != NULL) {
                            if (pObjectDef->TotalByteLength == 0) {
                                // 0-length object buffer returned
                                break;
                            }
                        }
                        else {
                            // and continue
                            break;
                        }
                    }
                }
                // add MSZ terminator to string
                ++ dwRequiredLength; // add the size of the MSZ char
                if (pdhStatus == ERROR_SUCCESS) {
                    if (szNextName != NULL && dwRequiredLength <= dwMaximumLength) {
                        if (bUnicode) {
                            * ((LPWSTR) szNextName)++ = L'\0';
                        }
                        else {
                            * ((LPSTR)szNextName) ++ = '\0';
                        }
                        // make sure pointers and lengths stay in sync
                    }
                    else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                }
            }
            else {
                // no objects found for this machine
                dwRequiredLength = 2;
                if (szNextName != NULL && dwRequiredLength <= dwMaximumLength) {
                    if (bUnicode) {
                        * ((LPWSTR) szNextName) ++ = L'\0';
                        * ((LPWSTR) szNextName) ++ = L'\0';
                    } else {
                        * ((LPSTR) szNextName) ++ = '\0';
                        * ((LPSTR) szNextName) ++ = '\0';
                    }
                }
                else {
                    pdhStatus = ERROR_MORE_DATA;
                } // else this is just a size request
            }
            // return length info
        }
        else {
            pdhStatus = pMachine->dwStatus;  // computer off line
        }
        pMachine->dwRefCount --;
        RELEASE_MUTEX(pMachine->hMutex);
    }
    else {
        pdhStatus = GetLastError(); // computer not found
    }

Cleanup:
    G_FREE(pdwIndex);
    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        __try {
            * pcchBufferSize = dwRequiredLength;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = GetExceptionCode();
        }
    }
    return pdhStatus;
}
#pragma warning ( default : 4127 )

PDH_FUNCTION
PdhEnumObjectsHW(
    IN  HLOG    hDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPWSTR  mszObjectList,
    IN  LPDWORD pcchBufferSize,
    IN  DWORD   dwDetailLevel,
    IN  BOOL    bRefresh
)
{
    PDH_STATUS  pdhStatus    = ERROR_SUCCESS;
    DWORD       dwBufferSize = 0;
    DWORD       dwDataSource = 0;

    if (pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwDataSource = DataSourceTypeH(hDataSource);
            dwBufferSize = * pcchBufferSize;
            if (szMachineName != NULL) {
                if (* szMachineName == L'\0') {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else if (lstrlenW(szMachineName) > PDH_MAX_COUNTER_NAME) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (dwBufferSize > 0) {
                    if (mszObjectList != NULL) {
                        mszObjectList[0]                = L'\0';
                        mszObjectList[dwBufferSize - 1] = L'\0';
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }

        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                pdhStatus = PdhiEnumObjects((LPWSTR) szMachineName,
                                            (LPVOID) mszObjectList,
                                            & dwBufferSize,
                                            dwDetailLevel,
                                            bRefresh,
                                            TRUE);
                break;

            case DATA_SOURCE_WBEM:
                pdhStatus = PdhiEnumWbemObjects((LPWSTR) szMachineName,
                                                (LPVOID) mszObjectList,
                                                & dwBufferSize,
                                                dwDetailLevel,  // not used
                                                bRefresh,
                                                TRUE);
                break;

            case DATA_SOURCE_LOGFILE:
                pdhStatus = PdhiEnumLoggedObjects(hDataSource,
                                                  (LPWSTR) szMachineName,
                                                  (LPVOID) mszObjectList,
                                                  & dwBufferSize,
                                                  dwDetailLevel,
                                                  bRefresh,
                                                  TRUE);
                break;

            default:
                pdhStatus = PDH_INVALID_ARGUMENT;
                break;
            }

        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        RELEASE_MUTEX (hPdhDataMutex);

        if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
            __try {
                * pcchBufferSize = dwBufferSize;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectsW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPWSTR  mszObjectList,
    IN  LPDWORD pcchBufferSize,
    IN  DWORD   dwDetailLevel,
    IN  BOOL    bRefresh
)
/*++
Routine Description:
    Lists the performance objects found on the specified machine as
        a MSZ UNICODE string list.

Arguments:
    IN      LPCWSTR  szDataSource
            NULL for current real-time data or the name of a log file
    IN      LPCWSTR  szMachineName
            The machine to list objects from
    IN      LPWSTR mszObjectList
            a pointer to the  buffer to receive the list of performance
            objects
    IN      LPDWORD pcchBufferSize
            a pointer to the DWORD containing the size of the mszObjectList
            buffer in characters.
    IN      DWORD   dwDetailLevel
            The detail level to use as a filter of objects. All objects
            with a detail level less than or equal to that specified
            by this argument will be returned.
    IN      BOOL    bRefresh
            TRUE = retrive a new perf. data buffer for this machine before
                listing the objects
            FALSE = use the currently cached perf data buffer for this
                machine to enumerate objects

Return Value:
    ERROR_SUCCESS if the function completes successfully. Otherwise a
        PDH_ error status if not.
    PDH_MORE_DATA is returned when there are more entries available to
        return than there is room in the buffer. Some entries may be
        returned in the buffer though.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_INVALID_ARGUMENT is returned if a required argument is not provided
        or a reserved argument is not NULL
--*/
{
    PDH_STATUS  pdhStatus    = ERROR_SUCCESS;
    DWORD       dwDataSource = 0;
    HLOG        hDataSource  = H_REALTIME_DATASOURCE;

    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (* szDataSource == L'\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenW(szDataSource) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg
        if (pdhStatus == ERROR_SUCCESS) {
            dwDataSource = DataSourceTypeW(szDataSource);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogW(szDataSource,
                                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                    & dwLogType,
                                    NULL,
                                    0,
                                    NULL,
                                    & hDataSource);
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhEnumObjectsHW(hDataSource,
                                     szMachineName,
                                     mszObjectList,
                                     pcchBufferSize,
                                     dwDetailLevel,
                                     bRefresh);
        if (dwDataSource == DATA_SOURCE_LOGFILE) {
            PdhCloseLog(hDataSource, 0);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectsHA(
    IN  HLOG    hDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPSTR   mszObjectList,
    IN  LPDWORD pcchBufferSize,
    IN  DWORD   dwDetailLevel,
    IN  BOOL    bRefresh
)
{
    PDH_STATUS pdhStatus    = ERROR_SUCCESS;
    LPWSTR     szWideName;
    DWORD      dwDataSource = 0;
    DWORD      dwBufferSize = 0;

    if (pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwDataSource = DataSourceTypeH(hDataSource);
            if (szMachineName != NULL) {
                // test buffer access
                if (* szMachineName == '\0') {
                    // null machine names are not permitted
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else if (lstrlenA(szMachineName) > PDH_MAX_COUNTER_NAME) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                dwBufferSize = * pcchBufferSize;
                if (dwBufferSize > 0) {
                    if (mszObjectList != NULL) {
                        mszObjectList[0]                = '\0';
                        mszObjectList[dwBufferSize - 1] = '\0';
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (szMachineName != NULL) {
            szWideName = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szMachineName);
        }
        else {
            szWideName = NULL;
        }
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                pdhStatus = PdhiEnumObjects(szWideName,
                                            (LPVOID) mszObjectList,
                                            & dwBufferSize,
                                            dwDetailLevel,
                                            bRefresh,
                                            FALSE);
                break;

            case DATA_SOURCE_WBEM:
                pdhStatus = PdhiEnumWbemObjects((LPWSTR) szWideName,
                                                (LPVOID) mszObjectList,
                                                & dwBufferSize,
                                                dwDetailLevel,  // not used
                                                bRefresh,
                                                FALSE);
                break;

            case DATA_SOURCE_LOGFILE:
                pdhStatus = PdhiEnumLoggedObjects(hDataSource,
                                                  (LPWSTR) szWideName,
                                                  (LPVOID) mszObjectList,
                                                  & dwBufferSize,
                                                  dwDetailLevel,
                                                  bRefresh,
                                                  FALSE);
                break;

            default:
                pdhStatus = PDH_INVALID_ARGUMENT;
                break;
            }

            if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
                * pcchBufferSize = dwBufferSize;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        RELEASE_MUTEX (hPdhDataMutex);
        G_FREE(szWideName);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectsA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPSTR   mszObjectList,
    IN  LPDWORD pcchBufferSize,
    IN  DWORD   dwDetailLevel,
    IN  BOOL    bRefresh
)
/*++
Routine Description:
    Lists the performance objects found on the specified machine as
        a MSZ ANSI string list.

Arguments:
    IN      LPCSTR  szDataSource
            NULL for current real-time data or the name of a log file
    IN      LPCSTR  szMachineName
            The machine to list objects from
    IN      LPSTR mszObjectList
            a pointer to the  buffer to receive the list of performance
            objects
    IN      LPDWORD pcchBufferSize
            a pointer to the DWORD containing the size of the mszObjectList
            buffer in characters.
    IN      DWORD   dwDetailLevel
            The detail level to use as a filter of objects. All objects
            with a detail level less than or equal to that specified
            by this argument will be returned.
    IN      BOOL    bRefresh
            TRUE = retrive a new perf. data buffer for this machine before
                listing the objects
            FALSE = use the currently cached perf data buffer for this
                machine to enumerate objects

Return Value:
    ERROR_SUCCESS if the function completes successfully. Otherwise a
        PDH_ error status if not.
    PDH_MORE_DATA is returned when there are more entries available to
        return than there is room in the buffer. Some entries may be
        returned in the buffer though.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_INVALID_ARGUMENT is returned if a required argument is not provided
        or a reserved argument is not NULL
--*/
{
    PDH_STATUS  pdhStatus   = ERROR_SUCCESS;
    HLOG        hDataSource = H_REALTIME_DATASOURCE;
    DWORD       dwDataSource = 0;

    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (* szDataSource == '\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenA(szDataSource) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg
        if (pdhStatus == ERROR_SUCCESS) {
            dwDataSource = DataSourceTypeA(szDataSource);
        }
    }
     __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogA(szDataSource,
                                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                    & dwLogType,
                                    NULL,
                                    0,
                                    NULL,
                                    & hDataSource);
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhEnumObjectsHA(hDataSource,
                                     szMachineName,
                                     mszObjectList,
                                     pcchBufferSize,
                                     dwDetailLevel,
                                     bRefresh);
        if (dwDataSource == DATA_SOURCE_LOGFILE) {
            PdhCloseLog(hDataSource, 0);
        }
    }
    return pdhStatus;
}

STATIC_PDH_FUNCTION
PdhiEnumObjectItems(
    LPCWSTR szMachineName,
    LPCWSTR szObjectName,
    LPVOID  mszCounterList,
    LPDWORD pcchCounterListLength,
    LPVOID  mszInstanceList,
    LPDWORD pcchInstanceListLength,
    DWORD   dwDetailLevel,
    DWORD   dwFlags,
    BOOL    bUnicode
)
/*++
Routine Description:
    Lists the items found in the specified performance object on the
        specified machine. Thie includes the performance counters and,
        if supported by the object, the object instances.

Arguments:
    IN      LPCWSTR szMachineName
            The name of the machine to list the objects
    IN      LPCWSTR szObjectName
            the name of the object to list items from
    IN      LPVOID  mszCounterList
            pointer to the buffer that will receive the list of counters
            provided by this object. This argument may be NULL if
            the value of pcchCounterLIstLength is 0.
    IN      LPDWORD pcchCounterListLength
            pointer to a DWORD that contains the size in characters
            of the buffer referenced by mszCounterList. The characters
            assumed are defined by bUnicode.
    IN      LPVOID  mszInstanceList
            pointer to the buffer that will receive the list of instances
            of the specified performance object. This argument may be
            NULL if the value of pcchInstanceListLength is 0.
    IN      LPDWORD pcchInstanceListLength
            pointer to the DWORD containing the size, in characters, of
            the buffer referenced by the mszInstanceList argument. If the
            value in this DWORD is 0, then no data will be written to the
            buffer, only the required size will be returned.

            If the value returned is 0, then this object does not
            return instances, if the value returned is 2, then the
            object supports instances, but does not currently have
            any instances to return  (2 = the size of an MSZ list in
            characters)
    IN      DWORD   dwDetailLevel
            The detail level of the performance items to return. All items
            that are of the specified detail level or less will be
            returned.
    IN      DWORD   dwFlags
            Not Used, must be 0.
    IN      BOOL    bUnicode
            TRUE = UNICODE characters will be written to the pMachineList
                    buffer
            FALSE = ANSI characters will be writtn to the pMachinList buffer

Return Value:
    ERROR_SUCCESS if the function completes successfully. Otherwise a
        PDH_ error status if not.
    PDH_MORE_DATA is returned when there are more entries available to
        return than there is room in the buffer. Some entries may be
        returned in the buffer though.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_CSTATUS_NO_OBJECT is returned if the specified object could
        not be found on the specified machine.
--*/
{
    PPERF_MACHINE              pMachine            = NULL;
    DWORD                      dwObjectId          = 0;
    PDH_STATUS                 pdhStatus           = ERROR_SUCCESS;
    PDH_STATUS                 pdhCtrStatus        = ERROR_SUCCESS;
    PDH_STATUS                 pdhInstStatus       = ERROR_SUCCESS;
    DWORD                      DefNdx;
    PPERF_OBJECT_TYPE          pObjectDef;
    PPERF_COUNTER_DEFINITION   pCounterDef;
    PPERF_INSTANCE_DEFINITION  pInstanceDef;
    DWORD                      dwReqCounterLength  = 0;
    DWORD                      dwReqInstanceLength = 0;
    LPVOID                     szNextName;
    DWORD                      dwNameLength;
    LPWSTR                     szInstanceName      = NULL;
    DWORD                      dwInstanceName;
    WCHAR                      szNumberString[32];
    DWORD                      dwMaxInstanceLength;
    DWORD                      dwMaxCounterLength;
    LPWSTR                     szCounterName;
    DWORD                      dwGmFlags;

    DBG_UNREFERENCED_PARAMETER(dwFlags);

    pMachine = GetMachine((LPWSTR) szMachineName, 0, PDH_GM_UPDATE_PERFNAME_ONLY);
    if (pMachine != NULL) {
        if (pMachine->dwStatus == ERROR_SUCCESS) {
            dwObjectId = GetObjectId(pMachine, (LPWSTR) szObjectName, NULL);
        }
        if (dwObjectId == (DWORD) -1) {
            pMachine->dwRefCount --;
            RELEASE_MUTEX(pMachine->hMutex);
            pMachine  = NULL;
            pdhStatus = PDH_CSTATUS_NO_OBJECT;
        }
    }

    if (pMachine != NULL) {
        if ((dwDetailLevel & PERF_DETAIL_COSTLY) && ! (pMachine->dwMachineFlags & PDHIPM_FLAGS_HAVE_COSTLY)) {
            // then get them
            pMachine->dwRefCount --;
            RELEASE_MUTEX(pMachine->hMutex);
            dwGmFlags = PDH_GM_UPDATE_PERFDATA | PDH_GM_READ_COSTLY_DATA;
            pMachine  = GetMachine((LPWSTR) szMachineName, dwObjectId, dwGmFlags);
        }
    }
    if (pMachine != NULL) {
        dwMaxCounterLength  = * pcchCounterListLength;
        dwMaxInstanceLength = * pcchInstanceListLength;

        // make sure the machine connection is valid
        if (pMachine->dwStatus == ERROR_SUCCESS) {
            pObjectDef = GetObjectDefByName(pMachine->pSystemPerfData,
                                            pMachine->dwLastPerfString,
                                            pMachine->szPerfStrings,
                                            szObjectName);
            if (pObjectDef == NULL) {
                DWORD dwObjectTitle = wcstoul(szObjectName, NULL, 10);
                if (dwObjectTitle != 0) {
                    pObjectDef = GetObjectDefByTitleIndex(pMachine->pSystemPerfData, dwObjectTitle);
                }
            }
            if (pObjectDef != NULL) {
                // add up counter name sizes
                pCounterDef = FirstCounter(pObjectDef);
                szNextName  = mszCounterList;

                for (DefNdx = 0; pCounterDef != NULL && DefNdx < pObjectDef->NumCounters; DefNdx++) {
                    if (! ((pCounterDef->CounterType & PERF_DISPLAY_NOSHOW) &&
                                // this is a hack because this type is not defined correctly
                                    (pCounterDef->CounterType != PERF_AVERAGE_BULK)) &&
                                    (pCounterDef->DetailLevel <= dwDetailLevel)) {
                                // then this is a visible counter so get its name.
                        if ((pCounterDef->CounterNameTitleIndex > 0) &&
                                        (pCounterDef->CounterNameTitleIndex < pMachine->dwLastPerfString)) {
                            // look up name of each object & store size
                            szCounterName = (LPWSTR) PdhiLookupPerfNameByIndex(pMachine,
                                                                               pCounterDef->CounterNameTitleIndex);
                        }
                        else {
                            // no matching string found for this index
                            szCounterName = NULL;
                        }
                        if (szCounterName == NULL) {
                            // then use the index numbe for lack of a better
                            // string to use
                            _ltow(pCounterDef->CounterNameTitleIndex, szNumberString, 10);
                            szCounterName = szNumberString;
                        }

                        if (bUnicode) {
                            dwNameLength = lstrlenW(szCounterName) + 1;
                            if (szNextName != NULL
                                            && (dwReqCounterLength + dwNameLength) <= dwMaxCounterLength) {
                                StringCchCopyW((LPWSTR) szNextName, dwNameLength, szCounterName);
                                (LPBYTE) szNextName += sizeof(WCHAR) * (dwNameLength - 1);
                                * ((LPWSTR) szNextName) ++ = L'\0';
                            }
                            else {
                                pdhCtrStatus = PDH_MORE_DATA;
                            }
                        }
                        else {
                            dwNameLength = (dwReqCounterLength <= dwMaxCounterLength)
                                         ? (dwMaxCounterLength - dwReqCounterLength)
                                         : (0);
                            pdhCtrStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                                    szCounterName,
                                                                    (LPSTR) szNextName,
                                                                    & dwNameLength);
                            if (pdhCtrStatus == ERROR_SUCCESS) {
                                (LPBYTE) szNextName += sizeof(CHAR) * dwNameLength;
                            }
                        }
                        dwReqCounterLength += dwNameLength;
                    }
                    else {
                        // this counter is not displayed either because
                        // it's hidden (e.g. the 2nd part of a 2 part counter
                        // or it's the wrong detail level
                    }
                    pCounterDef = NextCounter(pObjectDef, pCounterDef); // get next
                }

                if (DefNdx == 0) {
                    // no counters found so at least one NULL is required
                    dwReqCounterLength += 1;

                    // see if this string will fit
                    if (dwReqCounterLength <= dwMaxCounterLength) {
                        if (bUnicode) {
                            * ((LPWSTR) szNextName) ++ = L'\0';
                        }
                        else {
                            * ((LPSTR) szNextName) ++ = '\0';
                        }
                    }
                    else {
                        // more space needed than was reported
                        pdhCtrStatus = PDH_MORE_DATA;
                    }
                }
                // add terminating NULL
                dwReqCounterLength += 1;

                // see if this string will fit
                if (dwReqCounterLength <= dwMaxCounterLength) {
                    if (bUnicode) {
                        * ((LPWSTR) szNextName) ++ = L'\0';
                    }
                    else {
                        * ((LPSTR) szNextName) ++ = '\0';
                    }
                }
                else {
                    // more space needed than was reported
                    pdhCtrStatus = PDH_MORE_DATA;
                }

                // do instances now.
                szNextName = mszInstanceList;

                // add up instance name sizes
                if (pObjectDef->NumInstances != PERF_NO_INSTANCES) {
                    if (pObjectDef->DetailLevel <= dwDetailLevel && pObjectDef->NumInstances > 0) {
                        dwInstanceName = SMALL_BUFFER_SIZE;
                        szInstanceName = G_ALLOC(dwInstanceName * sizeof(WCHAR));
                        if (szInstanceName == NULL) {
                            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        }
                        else {
                            // the object HAS instances and is of the
                            // approrpriate detail level, so list them
                            pInstanceDef = FirstInstance(pObjectDef);
                            for (DefNdx = 0; pInstanceDef != NULL && DefNdx < (DWORD)pObjectDef->NumInstances; DefNdx++) {
                                dwNameLength = GetFullInstanceNameStr(pMachine->pSystemPerfData,
                                                                      pObjectDef,
                                                                      pInstanceDef,
                                                                      szInstanceName,
                                                                      dwInstanceName);
                                while (pdhStatus == ERROR_SUCCESS && dwNameLength > dwInstanceName) {
                                    G_FREE(szInstanceName);
                                    dwInstanceName = QWORD_MULTIPLE(dwNameLength);
                                    szInstanceName = G_ALLOC(dwInstanceName * sizeof(WCHAR));
                                    if (szInstanceName != NULL) {
                                        dwNameLength = GetFullInstanceNameStr(pMachine->pSystemPerfData,
                                                                              pObjectDef,
                                                                              pInstanceDef,
                                                                              szInstanceName,
                                                                              dwInstanceName);
                                    }
                                    else {
                                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                    }
                                }
                                if (pdhStatus != ERROR_SUCCESS) break;
                                if (dwNameLength > 0) {
                                    if (bUnicode) {
                                        // add length of this string + it's null
                                        dwNameLength += 1;
                                        if (szNextName != NULL
                                                        && dwReqInstanceLength + dwNameLength <= dwMaxInstanceLength) {
                                            StringCchCopyW((LPWSTR) szNextName, dwNameLength, szInstanceName);
                                            (LPBYTE) szNextName += sizeof(WCHAR) * (dwNameLength - 1);
                                            * ((LPWSTR) szNextName) ++ = L'\0';
                                        }
                                        else {
                                            pdhInstStatus = PDH_MORE_DATA;
                                        }
                                    }
                                    else {
                                        dwNameLength = (dwReqInstanceLength <= dwMaxInstanceLength)
                                                     ? (dwMaxInstanceLength - dwReqInstanceLength) : (0);
                                        pdhInstStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                                                 szInstanceName,
                                                                                 (LPSTR) szNextName,
                                                                                 & dwNameLength);
                                        if (pdhInstStatus == ERROR_SUCCESS) {
                                            (LPBYTE) szNextName += sizeof(CHAR) * dwNameLength;
                                        }
                                    }
                                    dwReqInstanceLength += dwNameLength;
                                }

                                // go to next instance of this object
                                pInstanceDef = NextInstance(pObjectDef, pInstanceDef); // get next
                            }
                            G_FREE(szInstanceName);
                        }
                        // add the terminating NULL char
                        dwReqInstanceLength += 1;
                        if (dwMaxInstanceLength > 0) {
                            // see if this string will fit
                            if (dwReqInstanceLength <= dwMaxInstanceLength) {
                                if (bUnicode) {
                                    * ((LPWSTR) szNextName) ++ = L'\0';
                                }
                                else {
                                    * ((LPSTR) szNextName) ++ = '\0';
                                }
                            }
                            else {
                                // more space needed than was reported
                                pdhInstStatus = PDH_MORE_DATA;
                            }
                        }
                    }
                    else {
                        // there are no instances present, but the object does
                        // support instances so return a zero length MSZ (which
                        // actually contains 2 NULL chars
                        dwReqInstanceLength = 2;

                        // see if this string will fit
                        if (dwReqInstanceLength <= dwMaxInstanceLength) {
                            if (bUnicode) {
                                * ((LPWSTR) szNextName) ++ = L'\0';
                                * ((LPWSTR) szNextName) ++ = L'\0';
                            }
                            else {
                                * ((LPSTR) szNextName) ++ = '\0';
                                * ((LPSTR) szNextName) ++ = '\0';
                            }
                        }
                        else {
                            // more space needed than was reported
                            pdhInstStatus = PDH_MORE_DATA;
                        }
                    }
                }
                else {
                    // the object has no instances and never will
                    // so return a 0 length and NO string
                    dwReqInstanceLength = 0;
                }

                if (pdhStatus == ERROR_SUCCESS) {
                    pdhStatus = (pdhCtrStatus == ERROR_SUCCESS) ? (pdhInstStatus) : (pdhCtrStatus);
                }
                if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
                    * pcchCounterListLength  = dwReqCounterLength;
                    * pcchInstanceListLength = dwReqInstanceLength;
                }
            }
            else {
                // object not found on this machine
                pdhStatus = PDH_CSTATUS_NO_OBJECT;
            }
        }
        else {
            // machine is off line
            pdhStatus = pMachine->dwStatus;
        }
        pMachine->dwRefCount --;
        RELEASE_MUTEX(pMachine->hMutex);
    }
    else if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = GetLastError();
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectItemsHW(
    IN  HLOG    hDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szObjectName,
    IN  LPWSTR  mszCounterList,
    IN  LPDWORD pcchCounterListLength,
    IN  LPWSTR  mszInstanceList,
    IN  LPDWORD pcchInstanceListLength,
    IN  DWORD   dwDetailLevel,
    IN  DWORD   dwFlags
)
{
    PDH_STATUS  pdhStatus     = ERROR_SUCCESS;
    DWORD       dwCBufferSize = 0;
    DWORD       dwIBufferSize = 0;
    DWORD       dwDataSource  = 0;

    if (pcchCounterListLength == NULL || pcchInstanceListLength == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwDataSource  = DataSourceTypeH(hDataSource);
            dwCBufferSize = * pcchCounterListLength;
            dwIBufferSize = * pcchInstanceListLength;

            if (szMachineName != NULL) {
                if (* szMachineName == L'\0') {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else if (lstrlenW(szMachineName) > PDH_MAX_COUNTER_NAME) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (szObjectName != NULL) {
                    if (* szObjectName == L'\0') {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                    else if (lstrlenW(szObjectName) > PDH_MAX_COUNTER_NAME) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
                else {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (dwCBufferSize > 0) {
                    if (mszCounterList != NULL) {
                        mszCounterList[0]                 = L'\0';
                        mszCounterList[dwCBufferSize - 1] = L'\0';
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (dwIBufferSize > 0) {
                    if (mszInstanceList != NULL) {
                        mszInstanceList[0]                = L'\0';
                        mszInstanceList[dwIBufferSize -1] = L'\0';
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (dwFlags != 0L) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                pdhStatus = PdhiEnumObjectItems((LPWSTR) szMachineName,
                                                szObjectName,
                                                (LPVOID) mszCounterList,
                                                & dwCBufferSize,
                                                (LPVOID) mszInstanceList,
                                                & dwIBufferSize,
                                                dwDetailLevel,
                                                dwFlags,
                                                TRUE);
                break;

            case DATA_SOURCE_WBEM:
                pdhStatus = PdhiEnumWbemObjectItems((LPWSTR) szMachineName,
                                                    szObjectName,
                                                    (LPVOID) mszCounterList,
                                                    & dwCBufferSize,
                                                    (LPVOID) mszInstanceList,
                                                    & dwIBufferSize,
                                                    dwDetailLevel,
                                                    dwFlags,
                                                    TRUE);
                break;

            case DATA_SOURCE_LOGFILE:
                pdhStatus = PdhiEnumLoggedObjectItems(hDataSource,
                                                      (LPWSTR) szMachineName,
                                                      szObjectName,
                                                      (LPVOID) mszCounterList,
                                                      & dwCBufferSize,
                                                      (LPVOID) mszInstanceList,
                                                      & dwIBufferSize,
                                                      dwDetailLevel,
                                                      dwFlags,
                                                      TRUE);
                break;

            default:
                pdhStatus = PDH_INVALID_ARGUMENT;
                break;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        RELEASE_MUTEX(hPdhDataMutex);

        if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
            __try {
                * pcchCounterListLength  = dwCBufferSize;
                * pcchInstanceListLength = dwIBufferSize;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectItemsW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szObjectName,
    IN  LPWSTR  mszCounterList,
    IN  LPDWORD pcchCounterListLength,
    IN  LPWSTR  mszInstanceList,
    IN  LPDWORD pcchInstanceListLength,
    IN  DWORD   dwDetailLevel,
    IN  DWORD   dwFlags
)
/*++
Routine Description:
    Lists the items found in the specified performance object on the
        specified machine. Thie includes the performance counters and,
        if supported by the object, the object instances.

Arguments:
    IN      LPCWSTR  szDataSource
            NULL for current real-time data or the name of a log file
    IN      LPCWSTR szMachineName
            The name of the machine to list the objects
    IN      LPCWSTR szObjectName
            the name of the object to list items from
    IN      LPWSTR  mszCounterList
            pointer to the buffer that will receive the list of counters
            provided by this object. This argument may be NULL if
            the value of pcchCounterLIstLength is 0.
    IN      LPDWORD pcchCounterListLength
            pointer to a DWORD that contains the size in characters
            of the buffer referenced by mszCounterList. The characters
            assumed are defined by bUnicode.
    IN      LPWSTR  mszInstanceList
            pointer to the buffer that will receive the list of instances
            of the specified performance object. This argument may be
            NULL if the value of pcchInstanceListLength is 0.
    IN      LPDWORD pcchInstanceListLength
            pointer to the DWORD containing the size, in characters, of
            the buffer referenced by the mszInstanceList argument. If the
            value in this DWORD is 0, then no data will be written to the
            buffer, only the required size will be returned.

            If the value returned is 0, then this object does not
            return instances, if the value returned is 2, then the
            object supports instances, but does not currently have
            any instances to return  (2 = the size of an MSZ list in
            characters)
    IN      DWORD   dwDetailLevel
            The detail level of the performance items to return. All items
            that are of the specified detail level or less will be
            returned.
    IN      DWORD   dwFlags
            Not Used, must be 0.

Return Value:
    ERROR_SUCCESS if the function completes successfully. Otherwise a
        PDH_ error status if not.
    PDH_MORE_DATA is returned when there are more entries available to
        return than there is room in the buffer. Some entries may be
        returned in the buffer though.
    PDH_INVALID_ARGUMENT a required argument is not correct or reserved
        argument is not 0 or NULL.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_CSTATUS_NO_OBJECT is returned if the specified object could
        not be found on the specified machine.
--*/
{
    PDH_STATUS  pdhStatus    = ERROR_SUCCESS;
    HLOG        hDataSource  = H_REALTIME_DATASOURCE;
    DWORD       dwDataSource = 0;

    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (* szDataSource == L'\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenW(szDataSource) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg
        if (pdhStatus == ERROR_SUCCESS) {
            dwDataSource = DataSourceTypeW(szDataSource);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogW(szDataSource,
                                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                    & dwLogType,
                                    NULL,
                                    0,
                                    NULL,
                                    & hDataSource);
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhEnumObjectItemsHW(hDataSource,
                                         szMachineName,
                                         szObjectName,
                                         mszCounterList,
                                         pcchCounterListLength,
                                         mszInstanceList,
                                         pcchInstanceListLength,
                                         dwDetailLevel,
                                         dwFlags);
        if (dwDataSource == DATA_SOURCE_LOGFILE) {
            PdhCloseLog(hDataSource, 0);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectItemsHA(
    IN  HLOG    hDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPCSTR  szObjectName,
    IN  LPSTR   mszCounterList,
    IN  LPDWORD pcchCounterListLength,
    IN  LPSTR   mszInstanceList,
    IN  LPDWORD pcchInstanceListLength,
    IN  DWORD   dwDetailLevel,
    IN  DWORD   dwFlags
)
{
    PDH_STATUS  pdhStatus           = ERROR_SUCCESS;
    LPWSTR      szWideMachineName   = NULL;
    LPWSTR      szWideObjectName    = NULL;
    DWORD       dwDataSource        = 0;
    DWORD       dwCBufferSize       = 0;
    DWORD       dwIBufferSize       = 0;

    if ((pcchCounterListLength == NULL) || (pcchInstanceListLength == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwDataSource  = DataSourceTypeH(hDataSource);
            dwCBufferSize = * pcchCounterListLength;
            dwIBufferSize = * pcchInstanceListLength;

            if (szMachineName != NULL) {
                if (* szMachineName == '\0') {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else if (lstrlenA(szMachineName) > PDH_MAX_COUNTER_NAME) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (szObjectName != NULL) {
                    if (* szObjectName == '\0') {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                    else if (lstrlenA(szObjectName) > PDH_MAX_COUNTER_NAME) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
                else {
                    // object cannot be NULL
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (dwCBufferSize > 0) {
                    if (mszCounterList != NULL) {
                        mszCounterList[0]                 = '\0';
                        mszCounterList[dwCBufferSize - 1] = '\0';
                    } 
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (dwIBufferSize > 0) {
                    if (mszInstanceList != NULL) {
                        mszInstanceList[0]                 = '\0';
                        mszInstanceList[dwIBufferSize - 1] = '\0';
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (dwFlags != 0L) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            if (szMachineName != NULL) {
                szWideMachineName = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szMachineName);
            }
            else {
                szWideMachineName = NULL;
            }
            if (szObjectName != NULL) {
                szWideObjectName  = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szObjectName);
            }
            else {
                szWideObjectName  = NULL;
            }
            if (pdhStatus == ERROR_SUCCESS) {
                switch (dwDataSource) {
                case DATA_SOURCE_REGISTRY:
                    pdhStatus = PdhiEnumObjectItems(szWideMachineName,
                                                    szWideObjectName,
                                                    (LPVOID) mszCounterList,
                                                    & dwCBufferSize,
                                                    (LPVOID) mszInstanceList,
                                                    & dwIBufferSize,
                                                    dwDetailLevel,
                                                    dwFlags,
                                                    FALSE);
                    break;

                case DATA_SOURCE_WBEM:
                   pdhStatus = PdhiEnumWbemObjectItems((LPWSTR) szWideMachineName,
                                                       szWideObjectName,
                                                       (LPVOID) mszCounterList,
                                                       & dwCBufferSize,
                                                       (LPVOID) mszInstanceList,
                                                       & dwIBufferSize,
                                                       dwDetailLevel,
                                                       dwFlags,
                                                       FALSE);
                   break;

                case DATA_SOURCE_LOGFILE:
                    pdhStatus = PdhiEnumLoggedObjectItems(hDataSource,
                                                          szWideMachineName,
                                                          szWideObjectName,
                                                          (LPVOID) mszCounterList,
                                                          & dwCBufferSize,
                                                          (LPVOID) mszInstanceList,
                                                          & dwIBufferSize,
                                                          dwDetailLevel,
                                                          dwFlags,
                                                          FALSE);
                    break;

                default:
                    pdhStatus = PDH_INVALID_ARGUMENT;
                    break;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        RELEASE_MUTEX(hPdhDataMutex);
        G_FREE(szWideMachineName);
        G_FREE(szWideObjectName);
        if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
            __try {
                * pcchCounterListLength  = dwCBufferSize;
                * pcchInstanceListLength = dwIBufferSize;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumObjectItemsA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPCSTR  szObjectName,
    IN  LPSTR   mszCounterList,
    IN  LPDWORD pcchCounterListLength,
    IN  LPSTR   mszInstanceList,
    IN  LPDWORD pcchInstanceListLength,
    IN  DWORD   dwDetailLevel,
    IN  DWORD   dwFlags
)
/*++
Routine Description:
    Lists the items found in the specified performance object on the
        specified machine. Thie includes the performance counters and,
        if supported by the object, the object instances.

Arguments:
    IN      LPCSTR  szDataSource
            NULL for current real-time data or the name of a log file
    IN      LPCSTR szMachineName
            The name of the machine to list the objects
    IN      LPCSTR szObjectName
            the name of the object to list items from
    IN      LPSTR  mszCounterList
            pointer to the buffer that will receive the list of counters
            provided by this object. This argument may be NULL if
            the value of pcchCounterLIstLength is 0.
    IN      LPDWORD pcchCounterListLength
            pointer to a DWORD that contains the size in characters
            of the buffer referenced by mszCounterList. The characters
            assumed are defined by bUnicode.
    IN      LPSTR  mszInstanceList
            pointer to the buffer that will receive the list of instances
            of the specified performance object. This argument may be
            NULL if the value of pcchInstanceListLength is 0.
    IN      LPDWORD pcchInstanceListLength
            pointer to the DWORD containing the size, in characters, of
            the buffer referenced by the mszInstanceList argument. If the
            value in this DWORD is 0, then no data will be written to the
            buffer, only the required size will be returned.

            If the value returned is 0, then this object does not
            return instances, if the value returned is 2, then the
            object supports instances, but does not currently have
            any instances to return  (2 = the size of an MSZ list in
            characters)
    IN      DWORD   dwDetailLevel
            The detail level of the performance items to return. All items
            that are of the specified detail level or less will be
            returned.
    IN      DWORD   dwFlags
            Not Used, must be 0.

Return Value:
    ERROR_SUCCESS if the function completes successfully. Otherwise a
        PDH_ error status if not.
    PDH_MORE_DATA is returned when there are more entries available to
        return than there is room in the buffer. Some entries may be
        returned in the buffer though.
    PDH_INVALID_ARGUMENT a required argument is not correct or reserved
        argument is not 0 or NULL.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a required temporary
        buffer could not be allocated.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_CSTATUS_NO_OBJECT is returned if the specified object could
        not be found on the specified machine.
--*/
{
    PDH_STATUS pdhStatus    = ERROR_SUCCESS;
    HLOG       hDataSource  = H_REALTIME_DATASOURCE;
    DWORD      dwDataSource = 0;

    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (* szDataSource == '\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenA(szDataSource) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg
        if (pdhStatus == ERROR_SUCCESS) {
            dwDataSource = DataSourceTypeA(szDataSource);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogA(szDataSource,
                                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                    & dwLogType,
                                    NULL,
                                    0,
                                    NULL,
                                    & hDataSource);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhEnumObjectItemsHA(hDataSource,
                                         szMachineName,
                                         szObjectName,
                                         mszCounterList,
                                         pcchCounterListLength,
                                         mszInstanceList,
                                         pcchInstanceListLength,
                                         dwDetailLevel,
                                         dwFlags);
        if (dwDataSource == DATA_SOURCE_LOGFILE) {
            PdhCloseLog(hDataSource, 0);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhMakeCounterPathW(
    IN  PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElements,
    IN  LPWSTR                       szFullPathBuffer,
    IN  LPDWORD                      pcchBufferSize,
    IN  DWORD                        dwFlags
)
/*++
Routine Description:
    Constructs a counter path using the elemeents defined in the
        pCounterPathElements structure and returns the path string
        in the buffer provided by the caller. The resulting path
        is not validated.

Arguments:
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements
                The pointer to the structure containing the
                individual counter path fields that are to be
                assembled in to a path string
    IN      LPWSTR                      szFullPathBuffer
                The buffer to receive the path string. This value
                may be NULL if the value of the DWORD pointed to
                by pcchBufferSize is 0 indicating this is just a
                request for the required buffer size.
    IN      LPDWORD                     pcchBufferSize
                The pointer to the DWORD containing the size
                of the string buffer in characters. On return
                it contains the size of the buffer used in
                characters (including the terminating NULL char).
                If the value is 0 on entry then no data will be
                written to the buffer, but the required size will
                still be returned.
    IN      DWORD                       dwFlags
            if 0, then return the path as a REGISTRY path items
            if PDH_PATH_WBEM_RESULT then return the items in WBEM format
            if PDH_PATH_WBEM_INPUT then assume the input is in WBEM format

Return Value:
    ERROR_SUCCESS if the function completes successfully, otherwise a
        PDH error is returned.
    PDH_INVALID_ARGUMENT is returned when one of the arguments passed
        by the caller is incorrect or not accesible.
--*/
{
    PDH_STATUS  pdhStatus         = ERROR_SUCCESS;
    double      dIndex;
    double      dLen;
    DWORD       dwSizeRequired    = 0;
    LPWSTR      szNextChar;
    DWORD       dwMaxSize;
    DWORD       dwLocalBufferSize = 0;

    if (pCounterPathElements == NULL || pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
        // test access to the input structure
            if (pCounterPathElements->szMachineName != NULL) {
                // then see if it's accessible
                if (* pCounterPathElements->szMachineName == L'\0') {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szObjectName != NULL) {
                    // then see if it's accessible
                    if (* pCounterPathElements->szObjectName == L'\0') {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
                else {
                    //NULL is NOT ok for this field
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szInstanceName != NULL) {
                    // then see if it's accessible
                    if (* pCounterPathElements->szInstanceName == L'\0') {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szParentInstance != NULL) {
                    // then see if it's accessible
                    if (* pCounterPathElements->szParentInstance == L'\0') {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szCounterName != NULL) {
                    // then see if it's accessible
                    if (* pCounterPathElements->szCounterName == L'\0') {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
                else {
                    //NULL is NOT ok for this field
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            // test the output buffers
            if (pdhStatus == ERROR_SUCCESS) {
                if (pcchBufferSize != NULL) {
                    dwLocalBufferSize = * pcchBufferSize;
                }
                else {
                    // NULL is NOT OK
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            if ((pdhStatus == ERROR_SUCCESS) && (szFullPathBuffer == NULL && dwLocalBufferSize > 0)) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (dwLocalBufferSize > 0) {
                    if (szFullPathBuffer != NULL) {
                        szFullPathBuffer[0]                     = L'\0';
                        szFullPathBuffer[dwLocalBufferSize - 1] = L'\0';
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            if (dwFlags == 0) {
                // then process as:
                //      registry path elements in
                //      registry path out

                dwMaxSize = dwLocalBufferSize;

                if (pCounterPathElements->szMachineName != NULL) {
                    dwSizeRequired = lstrlenW(pCounterPathElements->szMachineName);
                    // compare the first two words of the machine name
                    // to see if the double backslash is already present in the string
                    if (* ((LPDWORD) (pCounterPathElements->szMachineName)) != * ((LPDWORD) (cszDoubleBackSlash))) {
                            // double backslash not found
                        dwSizeRequired += 2; // to include the backslashes
                    }
                    if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                        if (* ((LPDWORD) (pCounterPathElements->szMachineName)) != * ((LPDWORD) (cszDoubleBackSlash))) {
                            // double backslash not found
                            StringCchCopyW(szFullPathBuffer, dwMaxSize, cszDoubleBackSlash);
                            StringCchCatW(szFullPathBuffer, dwMaxSize, pCounterPathElements->szMachineName);
                        }
                        else {
                            StringCchCopyW(szFullPathBuffer, dwMaxSize, pCounterPathElements->szMachineName);
                        }
                    }
                    else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                }

                dwSizeRequired += 1; // for delimiting slash
                dwSizeRequired += lstrlenW(pCounterPathElements->szObjectName);
                if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                    StringCchCatW(szFullPathBuffer, dwMaxSize, cszBackSlash);
                    StringCchCatW(szFullPathBuffer, dwMaxSize, pCounterPathElements->szObjectName);
                }
                else {
                    pdhStatus = PDH_MORE_DATA;
                }

                if (pCounterPathElements->szInstanceName != NULL) {
                    dwSizeRequired += 1; // for delimiting left paren
                    if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                        StringCchCatW(szFullPathBuffer, dwMaxSize, cszLeftParen);
                    }
                    else {
                        pdhStatus = PDH_MORE_DATA;
                    }

                    if (lstrcmpiW(pCounterPathElements->szInstanceName, cszSplat) != 0
                                    && pCounterPathElements->szParentInstance != NULL) {
                        dwSizeRequired += (lstrlenW(pCounterPathElements->szParentInstance) + 1);
                                                // extra 1 for delimiting slash
                        if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                            StringCchCatW(szFullPathBuffer, dwMaxSize, pCounterPathElements->szParentInstance);
                            StringCchCatW(szFullPathBuffer, dwMaxSize, cszSlash);
                        }
                        else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                    }

                    dwSizeRequired += lstrlenW(pCounterPathElements->szInstanceName);
                    if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                        StringCchCatW(szFullPathBuffer, dwMaxSize, pCounterPathElements->szInstanceName);
                    }
                    else {
                        pdhStatus = PDH_MORE_DATA;
                    }

                    if (lstrcmpiW(pCounterPathElements->szInstanceName, cszSplat) != 0
                                    && pCounterPathElements->dwInstanceIndex != PERF_NO_UNIQUE_ID
                                    && pCounterPathElements->dwInstanceIndex != 0) {
                        // the length of the index is computed by getting the log of the number
                        // yielding the largest power of 10 less than or equal to the index.
                        // e.g. the power of 10 of an index value of 356 would 2.0 (which is the
                        // result of (floor(log10(index))). The actual number of characters in
                        // the string would always be 1 greate than that value so 1 is added.
                        // 1 more is added to include the delimiting character

                        dIndex = (double) pCounterPathElements->dwInstanceIndex; // cast to float
                        dLen   = floor(log10(dIndex));                           // get integer log
                        dwSizeRequired += (DWORD) dLen;                          // cast to integer
                        dwSizeRequired += 2;                                     // increment
                        if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                            szNextChar      = & szFullPathBuffer[lstrlenW(szFullPathBuffer)];
                            * szNextChar ++ = POUNDSIGN_L;
                            _ltow((long) pCounterPathElements->dwInstanceIndex, szNextChar, 10);
                        }
                        else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                    }
                    dwSizeRequired += 1; // for delimiting parenthesis
                    if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                        StringCchCatW(szFullPathBuffer, dwMaxSize, cszRightParen);
                    }
                    else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                }

                dwSizeRequired ++;   // include delimiting Backslash
                dwSizeRequired += lstrlenW(pCounterPathElements->szCounterName);
                if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                    StringCchCatW(szFullPathBuffer, dwMaxSize, cszBackSlash);
                    StringCchCatW(szFullPathBuffer, dwMaxSize, pCounterPathElements->szCounterName);
                }
                else {
                    pdhStatus = PDH_MORE_DATA;
                }
                dwSizeRequired ++;   // include trailing Null char
                if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                    szFullPathBuffer[dwSizeRequired - 1] = L'\0';
                }
                else {
                    pdhStatus = PDH_MORE_DATA;
                }
            }
            else {
                // there is some WBEM component involved so send to WBEM function
                // to figure it out
                pdhStatus = PdhiEncodeWbemPathW(pCounterPathElements,
                                                szFullPathBuffer,
                                                & dwLocalBufferSize,
                                                (LANGID) ((dwFlags >> 16) & 0x0000FFFF),
                                                (DWORD) (dwFlags & 0x0000FFFF));
                dwSizeRequired = dwLocalBufferSize;
            }

            if (pdhStatus == ERROR_SUCCESS && (szFullPathBuffer == NULL || * pcchBufferSize == 0)) {
                pdhStatus = PDH_MORE_DATA;
            }
            * pcchBufferSize = dwSizeRequired;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhMakeCounterPathA(
    IN  PPDH_COUNTER_PATH_ELEMENTS_A pCounterPathElements,
    IN  LPSTR                        szFullPathBuffer,
    IN  LPDWORD                      pcchBufferSize,
    IN  DWORD                        dwFlags
)
/*++
Routine Description:
    Constructs a counter path using the elemeents defined in the
        pCounterPathElements structure and returns the path string
        in the buffer provided by the caller. The resulting path
        is not validated.

Arguments:
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements
                The pointer to the structure containing the
                individual counter path fields that are to be
                assembled in to a path string
    IN      LPWSTR                      szFullPathBuffer
                The buffer to receive the path string. This value
                may be NULL if the value of the DWORD pointed to
                by pcchBufferSize is 0 indicating this is just a
                request for the required buffer size.
    IN      LPDWORD                     pcchBufferSize
                The pointer to the DWORD containing the size
                of the string buffer in characters. On return
                it contains the size of the buffer used in
                characters (including the terminating NULL char).
                If the value is 0 on entry then no data will be
                written to the buffer, but the required size will
                still be returned.
    IN      DWORD                       dwFlags
            if 0, then return the path as a REGISTRY path items
            if PDH_PATH_WBEM_RESULT then return the items in WBEM format
            if PDH_PATH_WBEM_INPUT then assume the input is in WBEM format

Return Value:
    ERROR_SUCCESS if the function completes successfully, otherwise a
        PDH error is returned.
    PDH_INVALID_ARGUMENT is returned when one of the arguments passed
        by the caller is incorrect or not accesible.
--*/
{
    PDH_STATUS  pdhStatus         = ERROR_SUCCESS;
    double      dIndex;
    double      dLen;
    DWORD       dwSizeRequired    = 0;
    LPSTR       szNextChar;
    DWORD       dwMaxSize;
    DWORD       dwLocalBufferSize = 0;

    if (pCounterPathElements == NULL|| pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            // test access to the input structure
            if (pCounterPathElements->szMachineName != NULL) {
                // then see if it's accessible
                if (* pCounterPathElements->szMachineName == '\0') {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szObjectName != NULL) {
                    // then see if it's accessible
                    if (* pCounterPathElements->szObjectName == '\0') {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
                else {
                    //NULL is NOT ok for this field
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szInstanceName != NULL) {
                    // then see if it's accessible
                    if (* pCounterPathElements->szInstanceName == '\0') {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szParentInstance != NULL) {
                    // then see if it's accessible
                    if (* pCounterPathElements->szParentInstance == '\0') {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (pCounterPathElements->szCounterName != NULL) {
                    // then see if it's accessible
                    if (* pCounterPathElements->szCounterName == '\0') {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
                else {
                    //NULL is NOT ok for this field
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            // test the output buffers
            if (pdhStatus == ERROR_SUCCESS) {
                if (pcchBufferSize != NULL) {
                    dwLocalBufferSize = * pcchBufferSize;
                }
                else {
                    // NULL is NOT OK
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (pdhStatus == ERROR_SUCCESS && szFullPathBuffer == NULL && dwLocalBufferSize > 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            if (pdhStatus == ERROR_SUCCESS) {
                // write to both ends of the buffer if one was sent
                if (dwLocalBufferSize > 0) {
                    if (szFullPathBuffer != NULL) {
                        * szFullPathBuffer = '\0';
                        szFullPathBuffer[dwLocalBufferSize - 1] = '\0';
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            if (dwFlags == 0) {
                // this is a registry path in and out

                dwMaxSize = dwLocalBufferSize;

                if (pCounterPathElements->szMachineName != NULL) {
                    dwSizeRequired = lstrlenA(pCounterPathElements->szMachineName);
                    // compare the first two words of the machine name
                    // to see if the double backslash is already present in the string
                    if (* ((LPWORD) (pCounterPathElements->szMachineName)) != * ((LPWORD) (caszDoubleBackSlash))) {
                            // double backslash not found
                        dwSizeRequired += 2; // to include the backslashes
                    }
                    if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                        if (* ((LPWORD) (pCounterPathElements->szMachineName)) != * ((LPWORD) (caszDoubleBackSlash))) {
                            // double backslash not found
                            StringCchCopyA(szFullPathBuffer, dwMaxSize, caszDoubleBackSlash);
                            StringCchCatA(szFullPathBuffer, dwMaxSize, pCounterPathElements->szMachineName);
                        }
                        else {
                            StringCchCopyA(szFullPathBuffer, dwMaxSize, pCounterPathElements->szMachineName);
                        }
                    }
                    else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                }

                dwSizeRequired += 1; // for delimiting slash
                dwSizeRequired += lstrlenA (pCounterPathElements->szObjectName);
                if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                    StringCchCatA(szFullPathBuffer, dwMaxSize, caszBackSlash);
                    StringCchCatA(szFullPathBuffer, dwMaxSize, pCounterPathElements->szObjectName);
                }
                else {
                    pdhStatus = PDH_MORE_DATA;
                }

                if (pCounterPathElements->szInstanceName != NULL) {
                    dwSizeRequired += 1; // for delimiting left paren
                    if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                        StringCchCatA(szFullPathBuffer, dwMaxSize, caszLeftParen);
                    }
                    else {
                        pdhStatus = PDH_MORE_DATA;
                    }

                    if (pCounterPathElements->szParentInstance != NULL) {
                        dwSizeRequired += lstrlenA(pCounterPathElements->szParentInstance);
                        dwSizeRequired += 1; // for delimiting slash
                        if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                            StringCchCatA(szFullPathBuffer, dwMaxSize, pCounterPathElements->szParentInstance);
                            StringCchCatA(szFullPathBuffer, dwMaxSize, caszSlash);
                        }
                        else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                    }

                    dwSizeRequired += lstrlenA(pCounterPathElements->szInstanceName);
                    if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                        StringCchCatA(szFullPathBuffer, dwMaxSize, pCounterPathElements->szInstanceName);
                    }
                    else {
                        pdhStatus = PDH_MORE_DATA;
                    }

                    if (pCounterPathElements->dwInstanceIndex != PERF_NO_UNIQUE_ID
                            && pCounterPathElements->dwInstanceIndex != 0) {
                        // the length of the index is computed by getting the log of the number
                        // yielding the largest power of 10 less than or equal to the index.
                        // e.g. the power of 10 of an index value of 356 would 2.0 (which is the
                        // result of (floor(log10(index))). The actual number of characters in
                        // the string would always be 1 greate than that value so 1 is added.
                        // 1 more is added to include the delimiting character

                        dIndex          = (double) pCounterPathElements->dwInstanceIndex; // cast to float
                        dLen            = floor(log10(dIndex));                           // get integer log
                        dwSizeRequired  = (DWORD) dLen;                                   // cast to integer
                        dwSizeRequired += 2;                                              // increment

                        if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                            szNextChar      = & szFullPathBuffer[lstrlenA(szFullPathBuffer)];
                            * szNextChar ++ = POUNDSIGN_L;
                            _ltoa((long) pCounterPathElements->dwInstanceIndex, szNextChar, 10);
                        }
                        else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                    }

                    dwSizeRequired += 1; // for delimiting parenthesis
                    if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                        StringCchCatA(szFullPathBuffer, dwMaxSize, caszRightParen);
                    }
                    else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                }

                dwSizeRequired ++;   // include delimiting Backslash
                dwSizeRequired += lstrlenA(pCounterPathElements->szCounterName);
                if (szFullPathBuffer != NULL && dwSizeRequired <= dwMaxSize) {
                    StringCchCatA(szFullPathBuffer, dwMaxSize, caszBackSlash);
                    StringCchCatA(szFullPathBuffer, dwMaxSize, pCounterPathElements->szCounterName);
                }
                else {
                        pdhStatus = PDH_MORE_DATA;
                }
                dwSizeRequired ++;   // include trailing Null char
            }
            else {
                // this is a WBEM path so have the WBEM function figure
                // it out
                // there is some WBEM component involved so send to WBEM function
                // to figure it out
                pdhStatus = PdhiEncodeWbemPathA(pCounterPathElements,
                                                szFullPathBuffer,
                                                & dwLocalBufferSize,
                                                (LANGID) ((dwFlags >> 16) & 0x0000FFFF),
                                                (DWORD) (dwFlags & 0x0000FFFF));
                dwSizeRequired = dwLocalBufferSize;
            }

            if (pdhStatus == ERROR_SUCCESS && (szFullPathBuffer == NULL || * pcchBufferSize == 0)) {
                pdhStatus = PDH_MORE_DATA;
            }
            * pcchBufferSize = dwSizeRequired;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhParseCounterPathW(
    IN  LPCWSTR                      szFullPathBuffer,
    IN  PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElements,
    IN  LPDWORD                      pcchBufferSize,
    IN  DWORD                        dwFlags
)
/*++
Routine Description:
    Reads a perf counter path string and parses out the
        component fields, returning them in a buffer
        supplied by the calling function.

Arguments:
    IN      LPCWSTR                     szFullPathBuffer
                counter path string to parse.
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements
                pointer to buffer supplied by the caller in
                which the component fields will be written
                This buffer is cast as a structure, however, the
                string data is written to the space after
                the buffer.
    IN      LPDWORD                     pcchBufferSize
                the size of the buffer in BYTES. If specified size
                is 0, then the size is estimated and returned
                in this field and the buffer referenced by the
                agrument above is ignored.
    IN      DWORD                       dwFlags
            if 0, then return the path elements as REGISTRY path items
            if PDH_PATH_WBEM_RESULT then return the items in WBEM format
            if PDH_PATH_WBEM_INPUT then assume the input is in WBEM format

Return Value:
    ERROR_SUCCESS if the function completes successfully, otherwise
        a PDH error if not
    PDH_INVALID_ARGUMENT is returned when an argument is inocrrect or
        this function does not have the necessary access to that arg.
    PDH_INVALID_PATH is returned when the path is not formatted correctly
        and cannot be parsed.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a temporary buffer
        cannot be allocated
--*/
{
    PPDHI_COUNTER_PATH  pLocalCounterPath;
    PDH_STATUS          pdhStatus     = ERROR_SUCCESS;
    DWORD               dwSize;
    LPWSTR              szString      = NULL;
    DWORD               dwLocalBufferSize;
    DWORD               dwString;

    //validate incoming arguments
    if (szFullPathBuffer == NULL || pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwLocalBufferSize = * pcchBufferSize;
            // string cannot be null
            if (* szFullPathBuffer == L'\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenW(szFullPathBuffer) > PDH_MAX_COUNTER_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (dwLocalBufferSize > 0) {
                    if (pCounterPathElements != NULL) {
                        // try both "ends" of the buffer to see if an AV occurs
                        ((LPBYTE) pCounterPathElements) [0]                     = 0;
                        ((LPBYTE) pCounterPathElements) [dwLocalBufferSize - 1] = 0;
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
            if (dwFlags != 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (dwFlags == 0) {
            // allocate a temporary work buffer
            dwString          = 2 * (lstrlenW(szFullPathBuffer) + lstrlenW(szStaticLocalMachineName)
                                                                + PDH_MAX_COUNTER_PATH);
            dwSize            = sizeof(PDHI_COUNTER_PATH) + dwString * sizeof(WCHAR);
            pLocalCounterPath = G_ALLOC(dwSize);
            if (pLocalCounterPath != NULL) {
                if (ParseFullPathNameW(szFullPathBuffer, & dwSize, pLocalCounterPath, FALSE)) {
                    // parsed successfully so load into user's buffer
                    dwSize   = sizeof(PDH_COUNTER_PATH_ELEMENTS_W);
                    if (pCounterPathElements != NULL && dwSize <= dwLocalBufferSize) {
                        szString = (LPWSTR) & pCounterPathElements[1];
                    }
                    else {
                        szString  = NULL;
                        pdhStatus = PDH_MORE_DATA;
                    }
                    if (pLocalCounterPath->szMachineName != NULL) {
                        dwString = lstrlenW(pLocalCounterPath->szMachineName) + 1;
                        if (szString != NULL && dwSize + dwString * sizeof(WCHAR) <= dwLocalBufferSize) {
                            pCounterPathElements->szMachineName = szString;
                            StringCchCopyW(szString, dwString, pLocalCounterPath->szMachineName);
                            szString += dwString;
                        }
                        else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                        dwSize += dwString * sizeof(WCHAR);
                    }
                    else if (pCounterPathElements != NULL && dwSize <= dwLocalBufferSize) {
                        pCounterPathElements->szMachineName = NULL;
                    }

                    if (pLocalCounterPath->szObjectName != NULL) {
                        dwString = lstrlenW(pLocalCounterPath->szObjectName) + 1;
                        if (szString != NULL && dwSize + dwString * sizeof(WCHAR) <= dwLocalBufferSize) {
                            pCounterPathElements->szObjectName = szString;
                            StringCchCopyW(szString, dwString, pLocalCounterPath->szObjectName);
                            szString += dwString;
                        }
                        else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                        dwSize += dwString * sizeof(WCHAR);
                    }
                    else if (pCounterPathElements != NULL && dwSize <= dwLocalBufferSize) {
                        pCounterPathElements->szObjectName = NULL;
                    }

                    if (pLocalCounterPath->szInstanceName != NULL) {
                        dwString = lstrlenW(pLocalCounterPath->szInstanceName) + 1;
                        if (szString != NULL && dwSize + dwString * sizeof(WCHAR) <= dwLocalBufferSize) {
                            pCounterPathElements->szInstanceName = szString;
                            StringCchCopyW(szString, dwString, pLocalCounterPath->szInstanceName);
                            szString += dwString;
                        }
                        else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                        dwSize += dwString * sizeof(WCHAR);

                        if (pLocalCounterPath->szParentName != NULL) {
                            dwString = lstrlenW(pLocalCounterPath->szParentName) + 1;
                            if (szString != NULL && dwSize + dwString * sizeof(WCHAR) <= dwLocalBufferSize) {
                                pCounterPathElements->szParentInstance = szString;
                                StringCchCopyW(szString, dwString, pLocalCounterPath->szParentName);
                                szString += dwString;
                            }
                            else {
                                pdhStatus = PDH_MORE_DATA;
                            }
                            dwSize += dwString * sizeof(WCHAR);
                        }
                        else if (pCounterPathElements != NULL && dwSize <= dwLocalBufferSize) {
                            pCounterPathElements->szParentInstance = NULL;
                        }
                        if (pCounterPathElements != NULL && dwSize <= dwLocalBufferSize) {
                            pCounterPathElements->dwInstanceIndex = pLocalCounterPath->dwIndex;
                        }
                    }
                    else if (pCounterPathElements != NULL && dwSize <= dwLocalBufferSize) {
                        pCounterPathElements->szInstanceName   = NULL;
                        pCounterPathElements->szParentInstance = NULL;
                        pCounterPathElements->dwInstanceIndex  = PERF_NO_UNIQUE_ID;
                    }

                    if (pLocalCounterPath->szCounterName != NULL) {
                        dwString = lstrlenW(pLocalCounterPath->szCounterName) + 1;
                        if (szString != NULL && dwSize + dwString * sizeof(WCHAR) <= dwLocalBufferSize) {
                            pCounterPathElements->szCounterName = szString;
                            StringCchCopyW(szString, dwString, pLocalCounterPath->szCounterName);
                            szString += dwString;
                        }
                        dwSize += dwString * sizeof(WCHAR);
                    }
                    else if (pCounterPathElements != NULL && dwSize <= dwLocalBufferSize) {
                        pCounterPathElements->szCounterName = NULL;
                    }
                    dwLocalBufferSize = dwSize;
                }
                else {
                    // unable to read path
                    pdhStatus = PDH_INVALID_PATH;
                }
                G_FREE(pLocalCounterPath);
            }
            else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        else {
            pdhStatus = PdhiDecodeWbemPathW(szFullPathBuffer,
                                            pCounterPathElements,
                                            & dwLocalBufferSize,
                                            (LANGID) ((dwFlags >> 16) & 0x0000FFFF),
                                            (DWORD) (dwFlags & 0x0000FFFF));
        }
    }

    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        * pcchBufferSize = dwLocalBufferSize;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhParseCounterPathA(
    IN  LPCSTR                       szFullPathBuffer,
    IN  PPDH_COUNTER_PATH_ELEMENTS_A pCounterPathElements,
    IN  LPDWORD                      pcchBufferSize,
    IN  DWORD                        dwFlags
)
/*++
Routine Description:
    Reads a perf counter path string and parses out the
        component fields, returning them in a buffer
        supplied by the calling function.

Arguments:
    IN      LPCSTR                     szFullPathBuffer
                counter path string to parse.
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements
                pointer to buffer supplied by the caller in
                which the component fields will be written
                This buffer is cast as a structure, however, the
                string data is written to the space after
                the buffer.
    IN      LPDWORD                     pcchBufferSize
                the size of the buffer in BYTES. If specified size
                is 0, then the size is estimated and returned
                in this field and the buffer referenced by the
                agrument above is ignored.
    IN      DWORD                       dwFlags
            if 0, then return the path as a REGISTRY path items
            if PDH_PATH_WBEM_RESULT then return the items in WBEM format
            if PDH_PATH_WBEM_INPUT then assume the input is in WBEM format

Return Value:
    ERROR_SUCCESS if the function completes successfully, otherwise
        a PDH error if not
    PDH_INVALID_ARGUMENT is returned when an argument is inocrrect or
        this function does not have the necessary access to that arg.
    PDH_INVALID_PATH is returned when the path is not formatted correctly
        and cannot be parsed.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a temporary buffer
        cannot be allocated
--*/
{
    PPDHI_COUNTER_PATH  pLocalCounterPath = NULL;
    LPWSTR              wszFullPath       = NULL;
    PDH_STATUS          pdhStatus         = ERROR_SUCCESS;
    PDH_STATUS          pdhStatus1        = ERROR_SUCCESS;
    DWORD               dwSize;
    DWORD               dwSizeUsed;
    LPSTR               szString;
    DWORD               dwSizeofLocalCounterPath;
    DWORD               dwLocalBufferSize = 0;

    //validate incoming arguments
    if (szFullPathBuffer == NULL || pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            // capture buffer size locally
            dwLocalBufferSize = * pcchBufferSize;

            if (dwFlags != 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            // the name must be non null
            else if (* szFullPathBuffer == '\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenA(szFullPathBuffer) > PDH_MAX_COUNTER_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (dwLocalBufferSize > 0) {
                if (pCounterPathElements != NULL) {
                    // try both "ends" of the buffer to see if an AV occurs
                    * ((LPBYTE) pCounterPathElements)                      = 0;
                    ((LPBYTE) pCounterPathElements)[dwLocalBufferSize - 1] = 0;
                }
                else {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (dwFlags == 0) {
            dwSize = lstrlenA(szFullPathBuffer) + lstrlenW(szStaticLocalMachineName) + 1;
            dwSize = QWORD_MULTIPLE(dwSize);
            dwSizeofLocalCounterPath = sizeof(PDHI_COUNTER_PATH) + (2 * dwSize * sizeof(WCHAR));
            dwSizeofLocalCounterPath = QWORD_MULTIPLE(dwSizeofLocalCounterPath);

            wszFullPath = G_ALLOC(dwSize * sizeof(WCHAR) + dwSizeofLocalCounterPath);
            if (wszFullPath != NULL) {
                pLocalCounterPath = (PPDHI_COUNTER_PATH) ((LPBYTE) wszFullPath + dwSize * sizeof(WCHAR));
                MultiByteToWideChar(_getmbcp(), 0, szFullPathBuffer, -1, (LPWSTR) wszFullPath, dwSize);
                dwSize            = (DWORD) dwSizeofLocalCounterPath;
                if (ParseFullPathNameW(wszFullPath, & dwSize, pLocalCounterPath, FALSE)) {
                    // parsed successfully so load into user's buffer
                    // adjust dwSize to account for single-byte characters
                    // as they'll be packed in user's buffer.

                    dwSizeUsed = sizeof(PDH_COUNTER_PATH_ELEMENTS);
                    if (pCounterPathElements != NULL && dwSizeUsed <= dwLocalBufferSize) {
                        szString = (LPSTR) & pCounterPathElements[1];
                    }
                    else {
                        szString  = NULL;
                        pdhStatus = PDH_MORE_DATA;
                    }

                    if (pLocalCounterPath->szMachineName != NULL) {
                        dwSize = (dwLocalBufferSize >= dwSizeUsed) ? (dwLocalBufferSize - dwSizeUsed) : (0);
                        pdhStatus1 = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                              pLocalCounterPath->szMachineName,
                                                              szString,
                                                              & dwSize);
                        if (dwSize % sizeof(DWORD) != 0) {
                            dwSize = sizeof(DWORD) * ((dwSize / sizeof(DWORD)) + 1);
                        }
                        dwSizeUsed += dwSize;
                        if (pdhStatus1 == ERROR_SUCCESS) {
                            pCounterPathElements->szMachineName = szString;
                            szString += dwSize;
                        }
                        else if (pdhStatus == ERROR_SUCCESS) {
                            pdhStatus = pdhStatus1;
                        }
                    }
                    else if (pCounterPathElements != NULL && dwSizeUsed <= dwLocalBufferSize) {
                        pCounterPathElements->szMachineName = NULL;
                    }

                    if (pLocalCounterPath->szObjectName != NULL) {
                        dwSize = (dwLocalBufferSize >= dwSizeUsed) ? (dwLocalBufferSize - dwSizeUsed) : (0);
                        pdhStatus1 = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                              pLocalCounterPath->szObjectName,
                                                              szString,
                                                              & dwSize);
                        if (dwSize % sizeof(DWORD) != 0) {
                            dwSize = sizeof(DWORD) * ((dwSize / sizeof(DWORD)) + 1);
                        }
                        dwSizeUsed += dwSize;
                        if (pdhStatus1 == ERROR_SUCCESS) {
                            pCounterPathElements->szObjectName = szString;
                            szString += dwSize;
                        }
                        else if (pdhStatus == ERROR_SUCCESS) {
                            pdhStatus = pdhStatus1;
                        }
                    }
                    else if (pCounterPathElements != NULL && dwSizeUsed <= dwLocalBufferSize) {
                        pCounterPathElements->szObjectName = NULL;
                    }

                    if (pLocalCounterPath->szInstanceName != NULL) {
                        dwSize = (dwLocalBufferSize >= dwSizeUsed) ? (dwLocalBufferSize - dwSizeUsed) : (0);
                        pdhStatus1 = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                              pLocalCounterPath->szInstanceName,
                                                              szString,
                                                              & dwSize);
                        if (dwSize % sizeof(DWORD) != 0) {
                            dwSize = sizeof(DWORD) * ((dwSize / sizeof(DWORD)) + 1);
                        }
                        dwSizeUsed += dwSize;
                        if (pdhStatus1 == ERROR_SUCCESS) {
                            pCounterPathElements->szInstanceName = szString;
                            szString += dwSize;
                        }
                        else if (pdhStatus == ERROR_SUCCESS) {
                            pdhStatus = pdhStatus1;
                        }
                        if (pLocalCounterPath->szParentName != NULL) {
                            dwSize = (dwLocalBufferSize >= dwSizeUsed) ? (dwLocalBufferSize - dwSizeUsed) : (0);
                            pdhStatus1 = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                                  pLocalCounterPath->szParentName,
                                                                  szString,
                                                                  & dwSize);
                            if (dwSize % sizeof(DWORD) != 0) {
                                dwSize = sizeof(DWORD) * ((dwSize / sizeof(DWORD)) + 1);
                            }
                            dwSizeUsed += dwSize;
                            if (pdhStatus1 == ERROR_SUCCESS) {
                                pCounterPathElements->szParentInstance = szString;
                                szString += dwSize;
                            }
                            else if (pdhStatus == ERROR_SUCCESS) {
                                pdhStatus = pdhStatus1;
                            }
                        }
                        else if (pCounterPathElements != NULL && dwSizeUsed <= dwLocalBufferSize) {
                            pCounterPathElements->szParentInstance = NULL;
                        }
                        if (pCounterPathElements != NULL && dwSizeUsed <= dwLocalBufferSize) {
                            pCounterPathElements->dwInstanceIndex = pLocalCounterPath->dwIndex;
                        }
                    }
                    else if (pCounterPathElements != NULL && dwSizeUsed <= dwLocalBufferSize) {
                        pCounterPathElements->szInstanceName   = NULL;
                        pCounterPathElements->szParentInstance = NULL;
                        pCounterPathElements->dwInstanceIndex  = PERF_NO_UNIQUE_ID;
                    }

                    if (pLocalCounterPath->szCounterName != NULL) {
                        dwSize = (dwLocalBufferSize >= dwSizeUsed) ? (dwLocalBufferSize - dwSizeUsed) : (0);
                        pdhStatus1 = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                              pLocalCounterPath->szCounterName,
                                                              szString,
                                                              & dwSize);
                        if (dwSize % sizeof(DWORD) != 0) {
                            dwSize = sizeof(DWORD) * ((dwSize / sizeof(DWORD)) + 1);
                        }
                        dwSizeUsed += dwSize;
                        if (pdhStatus1 == ERROR_SUCCESS) {
                            pCounterPathElements->szCounterName = szString;
                            szString += dwSize;
                        }
                        else if (pdhStatus == ERROR_SUCCESS) {
                            pdhStatus = pdhStatus1;
                        }
                    }
                    else if (pCounterPathElements != NULL && dwSizeUsed < dwLocalBufferSize) {
                        pCounterPathElements->szCounterName = NULL;
                    }

                    dwLocalBufferSize = dwSizeUsed;
                }
                else {
                    pdhStatus = PDH_INVALID_PATH;
                }
                G_FREE(wszFullPath);
            }
            else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        else {
            // this is a WBEM path so have the WBEM function figure
            // it out
            // there is some WBEM component involved so send to WBEM function
            // to figure it out
            pdhStatus = PdhiDecodeWbemPathA(szFullPathBuffer,
                                            pCounterPathElements,
                                            & dwLocalBufferSize,
                                            (LANGID) ((dwFlags >> 16) & 0x0000FFFF),
                                            (DWORD) (dwFlags & 0x0000FFFF));
        }
    }

    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        * pcchBufferSize = dwLocalBufferSize;
    }
    return pdhStatus;

}

PDH_FUNCTION
PdhParseInstanceNameW(
    IN  LPCWSTR szInstanceString,
    IN  LPWSTR  szInstanceName,
    IN  LPDWORD pcchInstanceNameLength,
    IN  LPWSTR  szParentName,
    IN  LPDWORD pcchParentNameLength,
    IN  LPDWORD lpIndex
)
/*++
Routine Description:
    parses the fields of an instance string and returns them in the
    buffers supplied by the caller

Arguments:
    szInstanceString
            is the pointer to the string containing the instance substring
            to parse into individual components. This string can contain the
        following formats and less than MAX_PATH chars in length:
        instance
        instance#index
        parent/instance
        parent/instance#index
    szInstanceName
        is the pointer to the buffer that will receive the instance
        name parsed from the instance string. This pointer can be
        NULL if the DWORD referenced by the pcchInstanceNameLength
        argument is 0.
    pcchInstanceNameLength
        is the pointer to the DWORD that contains the length of the
        szInstanceName buffer. If the value of this DWORD is 0, then
        the buffer size required to hold the instance name will be
        returned.
    szParentName
        is the pointer to the buffer that will receive the name
        of the parent index if one is specified. This argument can
        be NULL if the value of the DWORD referenced by the
        pcchParentNameLength argument is 0.
    lpIndex
        is the pointer to the DWORD that will receive the index
        value of the instance. If an index entry is not present in
        the string, then this value will be 0. This argument can
        be NULL if this information is not needed.

Return Value:
    ERROR_SUCCESS if the function completes successfully, otherwise
        a PDH error is returned.
    PDH_INVALID_ARGUMENT is returned when one or more of the
        arguments is invalid or incorrect.
    PDH_INVALID_INSTANCE is returned if the instance string is incorrectly
        formatted and cannot be parsed
--*/
{
    BOOL        bReturn;
    PDH_STATUS  pdhStatus           = ERROR_SUCCESS;
    DWORD       dwSize;
    DWORD       dwLocalIndex;
    LPWSTR      szLocalInstanceName = NULL;
    LPWSTR      szLocalParentName   = NULL;
    DWORD       dwLocalInstanceNameLength;
    DWORD       dwLocalParentNameLength;

    // test access to arguments

    if (szInstanceString == NULL || pcchInstanceNameLength == NULL || pcchParentNameLength == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } 
    else {
        __try {
            dwLocalInstanceNameLength = * pcchInstanceNameLength;
            dwLocalParentNameLength   = * pcchParentNameLength;

            if (* szInstanceString == L'\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenW(szInstanceString) > PDH_MAX_INSTANCE_NAME) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (dwLocalInstanceNameLength > 0) {
                    if (szInstanceName != NULL) {
                        WCHAR wChar      = * szInstanceName;
                        * szInstanceName = L'\0';
                        * szInstanceName = wChar;
                        wChar            = szInstanceName[dwLocalInstanceNameLength - 1];
                        szInstanceName[dwLocalInstanceNameLength - 1] = L'\0';
                        szInstanceName[dwLocalInstanceNameLength - 1] = wChar;
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } // else size only request
                if (dwLocalParentNameLength > 0) {
                    if (szParentName != NULL) {
                        WCHAR wChar    = * szParentName;
                        * szParentName = L'\0';
                        * szParentName = wChar;
                        wChar          = szParentName[dwLocalParentNameLength - 1];
                        szParentName[dwLocalParentNameLength - 1] = L'\0';
                        szParentName[dwLocalParentNameLength - 1] = wChar;
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } // else size only request
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        DWORD dwLength = lstrlenW(szInstanceString) + 1;
        if (dwLength < PDH_MAX_INSTANCE_NAME) dwLength = PDH_MAX_INSTANCE_NAME;

        szLocalInstanceName = G_ALLOC(2 * dwLength * sizeof(WCHAR));
        if (szLocalInstanceName != NULL) {
            szLocalParentName = (szLocalInstanceName + dwLength);
            bReturn = ParseInstanceName(
                            szInstanceString, szLocalInstanceName, szLocalParentName, dwLength, & dwLocalIndex);
        }
        else {
            bReturn = FALSE;
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }

        if (bReturn) {
            dwSize = lstrlenW(szLocalInstanceName) + 1;
            if (szInstanceName != NULL && dwSize <= dwLocalInstanceNameLength) {
                StringCchCopyW(szInstanceName, dwLocalInstanceNameLength, szLocalInstanceName);
            }
            else {
                pdhStatus = PDH_MORE_DATA;
            }
            dwLocalInstanceNameLength = dwSize; // include the trailing NULL

            dwSize = lstrlenW(szLocalParentName) + 1;
            if (szParentName != NULL && dwSize <= dwLocalParentNameLength) {
                StringCchCopyW(szParentName, dwLocalParentNameLength, szLocalParentName);
            }
            else {
                pdhStatus = PDH_MORE_DATA;
            }
            dwLocalParentNameLength = dwSize; // include the trailing NULL

            __try {
                * pcchInstanceNameLength = dwLocalInstanceNameLength;
                * pcchParentNameLength   = dwLocalParentNameLength;

                if (lpIndex != NULL) {
                    * lpIndex = dwLocalIndex;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        else if (pdhStatus == ERROR_SUCCESS) {
            // unable to parse string
            pdhStatus = PDH_INVALID_INSTANCE;
        }
    }

    G_FREE(szLocalInstanceName);
    return pdhStatus;
}

PDH_FUNCTION
PdhParseInstanceNameA(
    IN  LPCSTR  szInstanceString,
    IN  LPSTR   szInstanceName,
    IN  LPDWORD pcchInstanceNameLength,
    IN  LPSTR   szParentName,
    IN  LPDWORD pcchParentNameLength,
    IN  LPDWORD lpIndex
)
/*++
Routine Description:
    parses the fields of an instance string and returns them in the
    buffers supplied by the caller

Arguments:
    szInstanceString
            is the pointer to the string containing the instance substring
            to parse into individual components. This string can contain the
        following formats and less than MAX_PATH chars in length:
        instance
        instance#index
        parent/instance
        parent/instance#index
    szInstanceName
        is the pointer to the buffer that will receive the instance
        name parsed from the instance string. This pointer can be
        NULL if the DWORD referenced by the pcchInstanceNameLength
        argument is 0.
    pcchInstanceNameLength
        is the pointer to the DWORD that contains the length of the
        szInstanceName buffer. If the value of this DWORD is 0, then
        the buffer size required to hold the instance name will be
        returned.
    szParentName
        is the pointer to the buffer that will receive the name
        of the parent index if one is specified. This argument can
        be NULL if the value of the DWORD referenced by the
        pcchParentNameLength argument is 0.
    lpIndex
        is the pointer to the DWORD that will receive the index
        value of the instance. If an index entry is not present in
        the string, then this value will be 0. This argument can
        be NULL if this information is not needed.

Return Value:
    ERROR_SUCCESS if the function completes successfully, otherwise
        a PDH error is returned.
    PDH_INVALID_ARGUMENT is returned when one or more of the
        arguments is invalid or incorrect.
    PDH_INVALID_INSTANCE is returned if the instance string is incorrectly
        formatted and cannot be parsed
--*/
{
    BOOL    bReturn;
    LONG    pdhStatus            = ERROR_SUCCESS;
    DWORD   dwSize;
    LPWSTR  wszInstanceString    = NULL;
    LPWSTR  wszLocalInstanceName = NULL;
    LPWSTR  wszLocalParentName   = NULL;
    DWORD   dwLocalIndex         = 0;
    DWORD   dwLocalInstanceNameLength;
    DWORD   dwLocalParentNameLength;

    // test access to arguments

    if (szInstanceString == NULL || pcchInstanceNameLength == NULL || pcchParentNameLength == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } 
    else {
        __try {
            dwLocalInstanceNameLength = * pcchInstanceNameLength;
            dwLocalParentNameLength   = * pcchParentNameLength;

            if (* szInstanceString == '\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenA(szInstanceString) > PDH_MAX_INSTANCE_NAME) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else {
                if (dwLocalInstanceNameLength > 0) {
                    if (szInstanceName != NULL) {
                        CHAR cChar       = * szInstanceName;
                        * szInstanceName = '\0';
                        * szInstanceName = cChar;
                        cChar            = szInstanceName[dwLocalInstanceNameLength - 1];
                        szInstanceName[dwLocalInstanceNameLength - 1] = '\0';
                        szInstanceName[dwLocalInstanceNameLength - 1] = cChar;
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } // else size only request
                if (dwLocalParentNameLength > 0) {
                    if (szParentName != NULL) {
                        CHAR cChar     = * szParentName;
                        * szParentName = '\0';
                        * szParentName = cChar;
                        cChar          = szParentName[dwLocalParentNameLength - 1];
                        szParentName[dwLocalParentNameLength - 1] = '\0';
                        szParentName[dwLocalParentNameLength - 1] = cChar;
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } // else size only request
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        dwSize = lstrlenA(szInstanceString) + 1;
        if (dwSize < PDH_MAX_INSTANCE_NAME) dwSize = PDH_MAX_INSTANCE_NAME;

        wszInstanceString = G_ALLOC(3 * dwSize * sizeof(WCHAR));
        if (wszInstanceString != NULL) {
            wszLocalInstanceName = (wszInstanceString    + dwSize);
            wszLocalParentName   = (wszLocalInstanceName + dwSize);
            MultiByteToWideChar(_getmbcp(), 0, szInstanceString, -1, wszInstanceString, dwSize);
            bReturn = ParseInstanceName(
                            wszInstanceString, wszLocalInstanceName, wszLocalParentName, dwSize, & dwLocalIndex);
        }
        else {
            // instance string is too long
            bReturn = FALSE;
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }

        if (bReturn) {
            PDH_STATUS pdhInstStatus   = ERROR_SUCCESS;
            PDH_STATUS pdhParentStatus = ERROR_SUCCESS;

            dwSize = dwLocalInstanceNameLength;
            pdhInstStatus = PdhiConvertUnicodeToAnsi(_getmbcp(), wszLocalInstanceName, szInstanceName, & dwSize);
            dwLocalInstanceNameLength = dwSize;

            dwSize = dwLocalParentNameLength;
            pdhParentStatus = PdhiConvertUnicodeToAnsi(_getmbcp(), wszLocalParentName, szParentName, & dwSize);
            if (pdhParentStatus == PDH_INVALID_ARGUMENT) {
                pdhParentStatus = ERROR_SUCCESS;
            }
            dwLocalParentNameLength = dwSize;
            if (pdhInstStatus != ERROR_SUCCESS) {
                pdhStatus = pdhInstStatus;
            }
            else {
                pdhStatus = pdhParentStatus;
            }

            __try {
                * pcchInstanceNameLength = dwLocalInstanceNameLength;
                * pcchParentNameLength   = dwLocalParentNameLength;

                if (lpIndex != NULL) {
                    * lpIndex = dwLocalIndex;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        else if (pdhStatus == ERROR_SUCCESS) {
            // unable to parse string
            pdhStatus = PDH_INVALID_INSTANCE;
        }
    } // else pass status through to caller

    G_FREE(wszInstanceString);
    return pdhStatus;
}

PDH_FUNCTION
PdhValidatePathW(
    IN  LPCWSTR szFullPathBuffer
)
/*++
Routine Description:
    breaks the specified path into its component parts and evaluates
        each of the part to make sure the specified path represents
        a valid and operational performance counter. The return value
        indicates the pdhStatus of the counter defined in the path string.

Arguments:
    IN      LPCWSTR szFullPathBuffer
                the full path string of the counter to validate.

Return Value:
    ERROR_SUCCESS of the counter was successfully located otherwise
        a PDH error.
    PDH_CSTATUS_NO_INSTANCE is returned if the specified instance of
        the performance object wasn't found
    PDH_CSTATUS_NO_COUNTER is returned if the specified counter was not
        found in the object.
    PDH_CSTATUS_NO_OBJECT is returned if the specified object was not
        found on the machine
    PDH_CSTATUS_NO_MACHINE is returned if the specified machine could
        not be found or connected to
    PDH_CSTATUS_BAD_COUNTERNAME is returned when the counter path string
        could not be parsed.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when the function is unable
        to allocate a required temporary buffer
    PDH_INVALID_ARGUMENT is returned when the counter path string argument
        could not be accessed
--*/
{
    PPERF_MACHINE             pMachine;
    PPDHI_COUNTER_PATH        pLocalCounterPath;
    DWORD                     dwSize;
    PPERF_OBJECT_TYPE         pPerfObjectDef = NULL;
    PPERF_INSTANCE_DEFINITION pPerfInstanceDef;
    PPERF_COUNTER_DEFINITION  pPerfCounterDef;
    PDH_STATUS                CStatus        = ERROR_SUCCESS;

    if (szFullPathBuffer != NULL) {
        // validate access to arguments
        __try {
            // make sure the name isn't empty
            if (* szFullPathBuffer == L'\0') {
                CStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenW(szFullPathBuffer) > PDH_MAX_COUNTER_PATH) {
                CStatus = PDH_INVALID_ARGUMENT;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            CStatus = PDH_INVALID_ARGUMENT;
        }
    }
    else {
        // cannot be null
        CStatus = PDH_INVALID_ARGUMENT;
    }
    if (CStatus == ERROR_SUCCESS) {
        CStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    }
    if (CStatus == ERROR_SUCCESS) {
        __try {
            pLocalCounterPath = G_ALLOC(sizeof(PDHI_COUNTER_PATH) + 2 * sizeof(WCHAR)
                            * (lstrlenW(szFullPathBuffer) + 1 + lstrlenW(szStaticLocalMachineName) + 1));
            if (pLocalCounterPath != NULL) {
                dwSize = (DWORD) G_SIZE(pLocalCounterPath);

                if (ParseFullPathNameW(szFullPathBuffer, & dwSize, pLocalCounterPath, FALSE)) {
                    // parsed successfully so try to connect to machine
                    // and get machine pointer
                    pMachine = GetMachine(pLocalCounterPath->szMachineName, 0, PDH_GM_UPDATE_PERFNAME_ONLY);
                    if (pMachine == NULL) {
                        CStatus = GetLastError();
                        if (CStatus == ERROR_SUCCESS) CStatus = PDH_CSTATUS_NO_MACHINE;
                    }
                    else if (pMachine->dwStatus != ERROR_SUCCESS) {
                        CStatus = pMachine->dwStatus;
                        pMachine->dwRefCount --;
                        RELEASE_MUTEX(pMachine->hMutex);
                        pMachine = NULL;
                    }
                    else {
                        DWORD dwObject = GetObjectId(pMachine, pLocalCounterPath->szObjectName, NULL);
                        if (dwObject == (DWORD) -1) {
                            pMachine->dwRefCount --;
                            RELEASE_MUTEX(pMachine->hMutex);
                            if (CStatus == ERROR_SUCCESS) CStatus = PDH_CSTATUS_NO_OBJECT;
                            pMachine = NULL;
                        }
                    }

                    if (pMachine != NULL) {
                        if (pMachine->dwStatus == ERROR_SUCCESS) {
                            // look up object name
                            pPerfObjectDef = GetObjectDefByName(pMachine->pSystemPerfData,
                                                                pMachine->dwLastPerfString,
                                                                pMachine->szPerfStrings,
                                                                pLocalCounterPath->szObjectName);
                        }
                        else {
                            pPerfObjectDef = NULL;
                        }

                        if (pPerfObjectDef != NULL) {
                            // look up instances if necessary
                            if (pPerfObjectDef->NumInstances != PERF_NO_INSTANCES) {
                                if (pLocalCounterPath->szInstanceName != NULL) {
                                    if (* pLocalCounterPath->szInstanceName != SPLAT_L) {
                                        pPerfInstanceDef = GetInstanceByName(pMachine->pSystemPerfData,
                                                        pPerfObjectDef,
                                                        pLocalCounterPath->szInstanceName,
                                                        pLocalCounterPath->szParentName,
                                                        (pLocalCounterPath->dwIndex != PERF_NO_UNIQUE_ID ?
                                                                        pLocalCounterPath->dwIndex : 0));
                                        if (pPerfInstanceDef == NULL) {
                                            // unable to lookup instance
                                            CStatus = PDH_CSTATUS_NO_INSTANCE;
                                        }
                                    }
                                    // wild card instances are OK IF multiple instances
                                    // are supported!!!
                                }
                                else {
                                    // no instance was specified for a counter
                                    // that should have an instance so this is
                                    // an invalid path
                                    CStatus = PDH_CSTATUS_NO_INSTANCE;
                                }
                            }
                            else {
                                // no instances in this counter, see if one
                                // is defined
                                if ((pLocalCounterPath->szInstanceName != NULL) ||
                                                (pLocalCounterPath->szParentName != NULL)) {
                                    // unable to lookup instance
                                    CStatus = PDH_CSTATUS_NO_INSTANCE;
                                }
                            }
                            if (CStatus == ERROR_SUCCESS) {
                                // and look up counter
                                pPerfCounterDef = GetCounterDefByName(pPerfObjectDef,
                                                                      pMachine->dwLastPerfString,
                                                                      pMachine->szPerfStrings,
                                                                      pLocalCounterPath->szCounterName);
                                if (pPerfCounterDef != NULL) {
                                    // counter found so return TRUE & valid
                                    CStatus = ERROR_SUCCESS;
                                }
                                else {
                                    // unable to lookup counter
                                    CStatus = PDH_CSTATUS_NO_COUNTER;
                                }
                            }
                        }
                        else {
                            // unable to lookup object
                            CStatus = PDH_CSTATUS_NO_OBJECT;
                        }
                        pMachine->dwRefCount --;
                        RELEASE_MUTEX (pMachine->hMutex);
                    }
                    else if (CStatus == ERROR_SUCCESS) {
                        // unable to find machine
                        CStatus = PDH_CSTATUS_NO_MACHINE;
                    }
                }
                else {
                    // unable to parse counter name
                    CStatus = PDH_CSTATUS_BAD_COUNTERNAME;
                }
                G_FREE(pLocalCounterPath);
            }
            else {
                // unable to allocate memory
                CStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            CStatus = PDH_INVALID_ARGUMENT;
        }
        RELEASE_MUTEX (hPdhDataMutex);

    } // else pass error to caller
    return CStatus;
}

PDH_FUNCTION
PdhValidatePathA(
    IN  LPCSTR  szFullPathBuffer
)
/*++
Routine Description:
    breaks the specified path into its component parts and evaluates
        each of the part to make sure the specified path represents
        a valid and operational performance counter. The return value
        indicates the pdhStatus of the counter defined in the path string.

Arguments:
    IN      LPCSTR szFullPathBuffer
                the full path string of the counter to validate.

Return Value:
    ERROR_SUCCESS of the counter was successfully located otherwise
        a PDH error.
    PDH_CSTATUS_NO_INSTANCE is returned if the specified instance of
        the performance object wasn't found
    PDH_CSTATUS_NO_COUNTER is returned if the specified counter was not
        found in the object.
    PDH_CSTATUS_NO_OBJECT is returned if the specified object was not
        found on the machine
    PDH_CSTATUS_NO_MACHINE is returned if the specified machine could
        not be found or connected to
    PDH_CSTATUS_BAD_COUNTERNAME is returned when the counter path string
        could not be parsed.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when the function is unable
        to allocate a required temporary buffer
--*/
{
    LPWSTR     wszFullPath = NULL;
    PDH_STATUS Status      = ERROR_SUCCESS;

    if (szFullPathBuffer != NULL) {
        __try {
            // cannot be blank
            if (* szFullPathBuffer == '\0') {
                Status = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenA(szFullPathBuffer) > PDH_MAX_COUNTER_PATH) {
                Status = PDH_INVALID_ARGUMENT;
            }
            else {
                wszFullPath = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szFullPathBuffer);
                if (wszFullPath == NULL) Status = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = PDH_INVALID_ARGUMENT;
        }
    }
    else {
        // cannot be null
        Status = PDH_INVALID_ARGUMENT;
    }

    if (Status == ERROR_SUCCESS) {
        Status = PdhValidatePathW(wszFullPath);
    }
    G_FREE(wszFullPath);
    return Status;
}

PDH_FUNCTION
PdhiGetDefaultPerfObjectW(
    DWORD   dwDataSource,
    LPCWSTR szMachineName,
    LPWSTR  szDefaultObjectName,
    LPDWORD pcchBufferSize
)
/*++
Routine Description:
    Obtains the default performance object from the specified machine.

Arguments:
    IN      DWORD    dwDataSourcetype
    IN      LPCWSTR szMachineName
                NULL indicates the local machine, othewise this is the
                name of the remote machine to query. If this machine is
                not known to the PDH DLL, then it will be connected.
    IN      LPWSTR  szDefaultObjectName
                pointer to the buffer that will receive the default object
                name. This pointer can be NULL if the value of the DWORD
                referenced by bcchBufferSize is 0.
    IN      LPDWORD pcchBufferSize
                pointer to a DWORD containing the size of the buffer, in
                characters, referenced by the szDefaultObjectName argument.
                If the value of this DWORD is 0, then no data will be written
                to the szDefaultObjectNameBuffer, however the required
                buffer size will be returned in the DWORD referenced by
                this pointer.

Return Value:
    ERROR_SUCCESS if this function completes normally otherwise a PDH error.
    PDH_INVALID_ARGUMENT a required argument is not correct or reserved
        argument is not 0 or NULL.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a required temporary
        buffer could not be allocated.
    PDH_CSTATUS_NO_COUNTERNAME is returned when the default object
        name cannot be read or found.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
--*/
{
    PPERF_MACHINE   pMachine;
    PDH_STATUS      pdhStatus         = ERROR_SUCCESS;
    LONG            lDefault;
    DWORD           dwStringLen;
    DWORD           dwLocalBufferSize = 0;
    LPWSTR          szDefault;
    LPWSTR          szThisMachine     = NULL;

    if (pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        // test the access the arguments
        __try {
            if (szMachineName != NULL) {
                // if there's a machine name then it cannot be blank
                if (* szMachineName == L'\0') {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else if (lstrlenW(szMachineName) > PDH_MAX_COUNTER_NAME) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            } // else NULL machine Name is OK

            if (pdhStatus == ERROR_SUCCESS) {
                dwLocalBufferSize = * pcchBufferSize;
                if (dwLocalBufferSize > 0) {
                    if (szDefaultObjectName != NULL) {
                        // test both ends of the caller's buffer for
                        // write access
                        szDefaultObjectName[0]                    = L'\0';
                        szDefaultObjectName[dwLocalBufferSize -1] = L'\0';
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS && szMachineName != NULL) {
        DWORD dwMachineName = (* szMachineName == L'\\') ? (lstrlenW(szMachineName) + 1)
                                                         : (lstrlenW(szMachineName) + 3);
        dwMachineName *= sizeof(WCHAR);
        szThisMachine = G_ALLOC(dwMachineName);
        if (szThisMachine == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else if (* szMachineName == L'\\') {
            StringCchCopyW(szThisMachine, dwMachineName, szMachineName);
        }
        else {
            StringCchCopyW(szThisMachine, dwMachineName, cszDoubleBackSlash);
            StringCchCatW(szThisMachine, dwMachineName, szMachineName);
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                pMachine  = GetMachine((LPWSTR) szThisMachine, 0, 0);
                pdhStatus = (pMachine != NULL ? pMachine->dwStatus : GetLastError());
                if (pMachine != NULL) {
                    if (pdhStatus == ERROR_SUCCESS) {
                        // only look at buffers from machines that are "on line"
                        lDefault = pMachine->pSystemPerfData->DefaultObject;
                        if ((lDefault > 0) && ((DWORD) lDefault < pMachine->dwLastPerfString)) {
                            // then there should be a string in the table
                            szDefault = (LPWSTR) PdhiLookupPerfNameByIndex(pMachine, lDefault);
                            if (szDefault != NULL) {
                                // determine string buffer length including term. NULL char
                                dwStringLen = lstrlenW(szDefault) + 1;
                                if (szDefaultObjectName != NULL && dwStringLen <= dwLocalBufferSize) {
                                    StringCchCopyW(szDefaultObjectName, dwLocalBufferSize, szDefault);
                                    pdhStatus = ERROR_SUCCESS;
                                }
                                else {
                                    pdhStatus = PDH_MORE_DATA;
                                }
                            }
                            else {
                                // unable to find a matching counter name
                                pdhStatus   = PDH_CSTATUS_NO_COUNTERNAME;
                                dwStringLen = 0;
                            }
                        }
                        else {
                            // string not in table
                            pdhStatus   = PDH_CSTATUS_NO_COUNTERNAME;
                            dwStringLen = 0;
                        }
                        dwLocalBufferSize = dwStringLen;
                    }
                    pMachine->dwRefCount --;
                    RELEASE_MUTEX(pMachine->hMutex);
                } // else pass error pdhStatus on to the caller
                break;

            case DATA_SOURCE_WBEM:
                pdhStatus = PdhiGetDefaultWbemObject(szThisMachine,
                                                     (LPVOID) szDefaultObjectName,
                                                     & dwLocalBufferSize,
                                                     TRUE); // unicode function
                break;

            case DATA_SOURCE_LOGFILE:
                // log files don't support this (for now)
                // but this is still successful.
                dwLocalBufferSize = 0;
                break;

            default:
                pdhStatus = PDH_INVALID_ARGUMENT;
                break;
            }
        }
         __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        RELEASE_MUTEX(hPdhDataMutex);
    }

    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        __try {
            * pcchBufferSize = dwLocalBufferSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    G_FREE(szThisMachine);
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfObjectHW(
    IN  HLOG    hDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPWSTR  szDefaultObjectName,
    IN  LPDWORD pcchBufferSize
)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    __try {
        dwDataSourceType = DataSourceTypeH(hDataSource);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfObjectW(dwDataSourceType, szMachineName, szDefaultObjectName, pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfObjectW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPWSTR  szDefaultObjectName,
    IN  LPDWORD pcchBufferSize
)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus        = ERROR_SUCCESS;

    __try {
        if (szDataSource != NULL) {
            if (* szDataSource == L'\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenW(szDataSource) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        if (pdhStatus == ERROR_SUCCESS) {
            dwDataSourceType = DataSourceTypeW(szDataSource);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfObjectW(dwDataSourceType, szMachineName, szDefaultObjectName, pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetDefaultPerfObjectA(
    DWORD   dwDataSource,
    LPCSTR  szMachineName,
    LPSTR   szDefaultObjectName,
    LPDWORD pcchBufferSize
)
/*++
Routine Description:
    Obtains the default performance object from the specified machine.

Arguments:
    IN      DWORD   dwDataSourceType
    IN      LPCSTR szMachineName
                NULL indicates the local machine, othewise this is the
                name of the remote machine to query. If this machine is
                not known to the PDH DLL, then it will be connected.
    IN      LPSTR  szDefaultObjectName
                pointer to the buffer that will receive the default object
                name. This pointer can be NULL if the value of the DWORD
                referenced by bcchBufferSize is 0.
    IN      LPDWORD pcchBufferSize
                pointer to a DWORD containing the size of the buffer, in
                characters, referenced by the szDefaultObjectName argument.
                If the value of this DWORD is 0, then no data will be written
                to the szDefaultObjectNameBuffer, however the required
                buffer size will be returned in the DWORD referenced by
                this pointer.

Return Value:
    ERROR_SUCCESS if this function completes normally otherwise a PDH error.
    PDH_INVALID_ARGUMENT a required argument is not correct or reserved
        argument is not 0 or NULL.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a required temporary
        buffer could not be allocated.
    PDH_CSTATUS_NO_COUNTERNAME is returned when the default object
        name cannot be read or found.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
--*/
{
    LPWSTR         szWideName        = NULL;
    DWORD          dwNameLength;
    PDH_STATUS     pdhStatus         = ERROR_SUCCESS;
    PPERF_MACHINE  pMachine          = NULL;
    LONG           lDefault;
    DWORD          dwStringLen;
    DWORD          dwLocalBufferSize = 0;
    LPWSTR         szDefault         = NULL;

    if (pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }

    // test the access the arguments
    __try {
        if (szMachineName != NULL) {
            if (* szMachineName == '\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenA(szMachineName) > PDH_MAX_COUNTER_NAME) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL machine Name is OK

        if (pdhStatus == ERROR_SUCCESS) {
            dwLocalBufferSize = * pcchBufferSize;
            if (dwLocalBufferSize > 0) {
                if (szDefaultObjectName != NULL) {
                    // test both ends of the caller's buffer for
                    // write access
                    szDefaultObjectName[0]                    = '\0';
                    szDefaultObjectName[dwLocalBufferSize -1] = '\0';
                }
                else {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS && szMachineName != NULL) {
        LPWSTR szTmpMachine = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szMachineName);
        if (szTmpMachine == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else if (* szTmpMachine == '\\') {
            szWideName = szTmpMachine;
        }
        else {
            szWideName = G_ALLOC((lstrlenW(szTmpMachine) + 3) * sizeof(WCHAR));
            if (szWideName == NULL) {
                szWideName = szTmpMachine;
            }
            else {
                StringCchPrintfW(szWideName,
                                 lstrlenW(szTmpMachine) + 3,
                                 L"%ws%ws",
                                 cszDoubleBackSlash,
                                 szTmpMachine);
                G_FREE(szTmpMachine);
            }
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                if (pdhStatus == ERROR_SUCCESS) {
                    pMachine  = GetMachine(szWideName, 0, 0);
                    pdhStatus = (pMachine != NULL ? pMachine->dwStatus : GetLastError());
                }
                if (pMachine != NULL) {
                    if (pdhStatus == ERROR_SUCCESS) {
                        // only look at buffers from machines that are "on line"
                        lDefault = pMachine->pSystemPerfData->DefaultObject;
                        if ((lDefault > 0) && ((DWORD) lDefault < pMachine->dwLastPerfString)) {
                            // then there should be a string in the table
                            szDefault = (LPWSTR) PdhiLookupPerfNameByIndex(pMachine, lDefault);
                            if (szDefault != NULL) {
                                // determine string buffer length including term. NULL char
                                dwStringLen = dwLocalBufferSize;
                                pdhStatus   = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                                       szDefault,
                                                                       szDefaultObjectName,
                                                                       & dwStringLen);
                            }
                            else {
                                // unable to find a matching counter name
                                pdhStatus   = PDH_CSTATUS_NO_COUNTERNAME;
                                dwStringLen = 0;
                            }
                        }
                        else {
                            // string not in table
                            pdhStatus = PDH_CSTATUS_NO_COUNTERNAME;
                            dwStringLen = 0;
                        }
                        dwLocalBufferSize = dwStringLen;
                    }
                    pMachine->dwRefCount --;
                    RELEASE_MUTEX(pMachine->hMutex);
                } // else pass error pdhStatus on to the caller
                break;

            case DATA_SOURCE_WBEM:
            case DATA_SOURCE_LOGFILE:
                if (pdhStatus == ERROR_SUCCESS && dwDataSource == DATA_SOURCE_WBEM) {
                    pdhStatus = PdhiGetDefaultWbemObject(szWideName,
                                                         (LPVOID) szDefaultObjectName,
                                                         & dwLocalBufferSize,
                                                         FALSE); // ANSI function
                }
                else {
                    //log files don't support this (for now)
                    dwLocalBufferSize = 0;
                }
                break;

            default:
                pdhStatus = PDH_INVALID_ARGUMENT;
                break;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        RELEASE_MUTEX (hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        __try {
            * pcchBufferSize = dwLocalBufferSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

Cleanup:
    G_FREE(szWideName);
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfObjectHA(
    IN  HLOG    hDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPSTR   szDefaultObjectName,
    IN  LPDWORD pcchBufferSize
)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus        = ERROR_SUCCESS;

    __try {
        dwDataSourceType = DataSourceTypeH(hDataSource);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfObjectA(dwDataSourceType, szMachineName, szDefaultObjectName, pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfObjectA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPSTR   szDefaultObjectName,
    IN  LPDWORD pcchBufferSize
)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus        = ERROR_SUCCESS;

    __try {
        if (szDataSource != NULL) {
            if (* szDataSource == '\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenA(szDataSource) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        if (pdhStatus == ERROR_SUCCESS) {
            dwDataSourceType = DataSourceTypeA(szDataSource);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfObjectA(dwDataSourceType, szMachineName, szDefaultObjectName, pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetDefaultPerfCounterW(
    IN  DWORD   dwDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szObjectName,
    IN  LPWSTR  szDefaultCounterName,
    IN  LPDWORD pcchBufferSize
)
/*++
Routine Description:
    Obtains the default performance counter from the specified object on
        the specified machine.

Arguments:
    IN      DWORD   dwDataSource
    IN      LPCWSTR szMachineName
                NULL indicates the local machine, othewise this is the
                name of the remote machine to query. If this machine is
                not known to the PDH DLL, then it will be connected.
    IN      LPCWSTR szObjectName
                a pointer to the buffer that contains the name of the object
                on the machine to find the default counter for.
    IN      LPWSTR  szDefaultCounterName
                pointer to the buffer that will receive the default counter
                name. This pointer can be NULL if the value of the DWORD
                referenced by bcchBufferSize is 0.
    IN      LPDWORD pcchBufferSize
                pointer to a DWORD containing the size of the buffer, in
                characters, referenced by the szDefaultObjectName argument.
                If the value of this DWORD is 0, then no data will be written
                to the szDefaultObjectNameBuffer, however the required
                buffer size will be returned in the DWORD referenced by
                this pointer.

Return Value:
    ERROR_SUCCESS if this function completes normally otherwise a PDH error.
    PDH_INVALID_ARGUMENT a required argument is not correct or reserved
        argument is not 0 or NULL.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a required temporary
        buffer could not be allocated.
    PDH_CSTATUS_NO_COUNTERNAME is returned when the name string for the
        default counter could not be found.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_CSTATUS_NO_OBJECT is returned when the specified object could
        not be found on the specified computer.
    PDH_CSTATUS_NO_COUNTER is returned when the default counter is not
        found in the data buffer.
--*/
{
    PPERF_MACHINE            pMachine;
    PPERF_OBJECT_TYPE        pObjectDef;
    PPERF_COUNTER_DEFINITION pCounterDef;
    PDH_STATUS               pdhStatus         = ERROR_SUCCESS;
    LONG                     lDefault;
    DWORD                    dwStringLen;
    DWORD                    dwLocalBufferSize = 0;
    LPWSTR                   szDefault;
    LPWSTR                   szThisMachine     = NULL;

    if (szObjectName == NULL || pcchBufferSize == NULL) {
         pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        // test the access the arguments
        __try {
            if (szMachineName != NULL) {
                if (* szMachineName == L'\0') {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else if (lstrlenW(szMachineName) > PDH_MAX_COUNTER_NAME) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            } // else NULL machine Name is OK

            if (pdhStatus == ERROR_SUCCESS) {
                if (szObjectName == NULL) {
                    // Null Object is not allowed
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else if (* szObjectName == L'\0') {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else if (lstrlenW(szObjectName) > PDH_MAX_COUNTER_NAME) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                dwLocalBufferSize = * pcchBufferSize;
                if (dwLocalBufferSize > 0) {
                    if (szDefaultCounterName) {
                        // test both ends of the caller's buffer for
                        // write access
                        szDefaultCounterName[0]                     = L'\0';
                        szDefaultCounterName[dwLocalBufferSize - 1] = L'\0';
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (szMachineName != NULL) {
            DWORD dwMachineName = (* szMachineName == L'\\') ? (lstrlenW(szMachineName) + 1)
                                                             : (lstrlenW(szMachineName) + 3);
            szThisMachine = G_ALLOC(dwMachineName * sizeof(WCHAR));
            if (szThisMachine == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            else if (* szMachineName == L'\\') {
                StringCchCopyW(szThisMachine, dwMachineName, szMachineName);
            }
            else {
                StringCchPrintfW(szThisMachine, dwMachineName, L"%ws%ws", cszDoubleBackSlash, szMachineName);
            }
        }
        else {
            szThisMachine = NULL;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                pMachine  = GetMachine((LPWSTR) szThisMachine, 0, PDH_GM_UPDATE_PERFNAME_ONLY);
                if (pMachine == NULL) {
                    pdhStatus = GetLastError();
                    if (pdhStatus == ERROR_SUCCESS) pdhStatus = PDH_CSTATUS_NO_MACHINE;
                }
                else if (pMachine->dwStatus != ERROR_SUCCESS) {
                    pdhStatus = pMachine->dwStatus;
                    pMachine->dwRefCount --;
                    RELEASE_MUTEX(pMachine->hMutex);
                    pMachine = NULL;
                }
                else {
                    DWORD dwObject = GetObjectId(pMachine, (LPWSTR) szObjectName, NULL);
                    if (dwObject == (DWORD) -1) {
                        pMachine->dwRefCount --;
                        RELEASE_MUTEX(pMachine->hMutex);
                        if (pdhStatus == ERROR_SUCCESS) pdhStatus = PDH_CSTATUS_NO_OBJECT;
                        pMachine = NULL;
                    }
                }

                if (pMachine != NULL) {
                    if (pdhStatus == ERROR_SUCCESS) {
                        // get object pointer
                        pObjectDef = GetObjectDefByName(pMachine->pSystemPerfData,
                                                        pMachine->dwLastPerfString,
                                                        pMachine->szPerfStrings,
                                                        szObjectName);
                        if (pObjectDef != NULL) {
                            // default counter reference is an index into the list
                            // of counter definition entries so walk down list of
                            // counters defs to find the default one
                            if (pObjectDef->DefaultCounter > (LONG) pObjectDef->NumCounters) {
                                // Something wrong inside PERF_OBJ_DEF block. DefaultCounter
                                // should be in the range between 0 and NumCounters, but apparently
                                // it is not. Reset DefaultCounter to 0.
                                //
                                pObjectDef->DefaultCounter = 0;
                            }
                            if (pObjectDef->DefaultCounter < (LONG) pObjectDef->NumCounters) {
                                // then the default index should be this buffer
                                lDefault    = 0;
                                pCounterDef = FirstCounter(pObjectDef);
                                while (pCounterDef != NULL && (lDefault < pObjectDef->DefaultCounter)
                                                           && (lDefault < (LONG) pObjectDef->NumCounters)) {
                                    pCounterDef = NextCounter(pObjectDef, pCounterDef);
                                    lDefault ++;
                                }
                                lDefault = pCounterDef->CounterNameTitleIndex;
                                if ((lDefault > 0) && ((DWORD)lDefault < pMachine->dwLastPerfString)) {
                                    // then there should be a string in the table
                                    szDefault   = (LPWSTR)PdhiLookupPerfNameByIndex(pMachine, lDefault);
                                    if (szDefault != NULL) {
                                        dwStringLen = lstrlenW(szDefault) + 1;
                                        if (szDefaultCounterName != NULL && dwStringLen <= dwLocalBufferSize) {
                                            StringCchCopyW(szDefaultCounterName, dwLocalBufferSize, szDefault);
                                            pdhStatus = ERROR_SUCCESS;
                                        }
                                        else {
                                            pdhStatus = PDH_MORE_DATA;
                                        }
                                        dwLocalBufferSize = dwStringLen;
                                    }
                                    else {
                                        dwLocalBufferSize = 0;
                                        pdhStatus         = PDH_CSTATUS_NO_COUNTER;
                                    }
                                }
                                else {
                                    // string index is not valid
                                    dwLocalBufferSize = 0;
                                    pdhStatus         = PDH_CSTATUS_NO_COUNTER;
                                }
                            }
                            else {
                                // the counter entry is not in the buffer
                                dwLocalBufferSize = 0;
                                pdhStatus         = PDH_CSTATUS_NO_COUNTER;
                            }
                        }
                        else {
                            // unable to find object
                            dwLocalBufferSize = 0;
                            pdhStatus         = PDH_CSTATUS_NO_OBJECT;
                        }
                    }
                    pMachine->dwRefCount --;
                    RELEASE_MUTEX(pMachine->hMutex);
                } // else pass pdhStatus value to caller
                break;

            case DATA_SOURCE_WBEM:
                pdhStatus = PdhiGetDefaultWbemProperty(szThisMachine,
                                                       szObjectName,
                                                       szDefaultCounterName,
                                                       & dwLocalBufferSize,
                                                       TRUE);
                break;

            case DATA_SOURCE_LOGFILE:
                dwLocalBufferSize = 0;
                break;

            default:
                break;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        RELEASE_MUTEX (hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        __try {
            * pcchBufferSize = dwLocalBufferSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    G_FREE(szThisMachine);
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfCounterHW(
    IN  HLOG    hDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szObjectName,
    IN  LPWSTR  szDefaultCounterName,
    IN  LPDWORD pcchBufferSize
)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus        = ERROR_SUCCESS;

    __try {
        dwDataSourceType = DataSourceTypeH(hDataSource);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfCounterW(
                        dwDataSourceType, szMachineName, szObjectName, szDefaultCounterName, pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfCounterW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szObjectName,
    IN  LPWSTR  szDefaultCounterName,
    IN  LPDWORD pcchBufferSize
)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus        = ERROR_SUCCESS;

    __try {
        if (szDataSource != NULL) {
            if (* szDataSource == L'\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenW(szDataSource) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        if (pdhStatus == ERROR_SUCCESS) {
            dwDataSourceType = DataSourceTypeW(szDataSource);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfCounterW(
                        dwDataSourceType, szMachineName, szObjectName, szDefaultCounterName, pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetDefaultPerfCounterA(
    DWORD   dwDataSource,
    LPCSTR  szMachineName,
    LPCSTR  szObjectName,
    LPSTR   szDefaultCounterName,
    LPDWORD pcchBufferSize
)
/*++
Routine Description:
    Obtains the default performance counter from the specified object on
        the specified machine.

Arguments:
    IN      DWORD  dwDataSource
    IN      LPCSTR szMachineName
                NULL indicates the local machine, othewise this is the
                name of the remote machine to query. If this machine is
                not known to the PDH DLL, then it will be connected.
    IN      LPCSTR szObjectName
                a pointer to the buffer that contains the name of the object
                on the machine to find the default counter for.
    IN      LPSTR  szDefaultCounterName
                pointer to the buffer that will receive the default counter
                name. This pointer can be NULL if the value of the DWORD
                referenced by bcchBufferSize is 0.
    IN      LPDWORD pcchBufferSize
                pointer to a DWORD containing the size of the buffer, in
                characters, referenced by the szDefaultObjectName argument.
                If the value of this DWORD is 0, then no data will be written
                to the szDefaultObjectNameBuffer, however the required
                buffer size will be returned in the DWORD referenced by
                this pointer.

Return Value:
    ERROR_SUCCESS if this function completes normally otherwise a PDH error.
    PDH_INVALID_ARGUMENT a required argument is not correct or reserved
        argument is not 0 or NULL.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a required temporary
        buffer could not be allocated.
    PDH_CSTATUS_NO_COUNTERNAME is returned when the name string for the
        default counter could not be found.
    PDH_CSTATUS_NO_MACHINE  is returned when the specified machine
        is offline or unavailable.
    PDH_CSTATUS_NO_OBJECT is returned when the specified object could
        not be found on the specified computer.
    PDH_CSTATUS_NO_COUNTER is returned when the default counter is not
        found in the data buffer.
--*/
{
    LPWSTR                   szWideObject      = NULL;
    LPWSTR                   szWideName        = NULL;
    PDH_STATUS               pdhStatus         = ERROR_SUCCESS;
    PPERF_MACHINE            pMachine          = NULL;
    PPERF_OBJECT_TYPE        pObjectDef        = NULL;
    PPERF_COUNTER_DEFINITION pCounterDef;
    LONG                     lDefault;
    DWORD                    dwStringLen;
    DWORD                    dwLocalBufferSize = 0;
    LPWSTR                   szDefault;

    if (szObjectName == NULL || pcchBufferSize == NULL) {
         pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        // test the access the arguments
        __try {
            if (szMachineName != NULL) {
                if (* szMachineName == '\0') {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else if (lstrlenA(szMachineName) > PDH_MAX_COUNTER_NAME) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            } // else NULL machine Name is OK

            if (pdhStatus == ERROR_SUCCESS) {
                if (szObjectName != NULL) {
                    if (* szObjectName == '\0') {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                    else if (lstrlenA(szObjectName) > PDH_MAX_COUNTER_NAME) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
                else {
                    // null objects are not allowed
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                dwLocalBufferSize = * pcchBufferSize;
                if (dwLocalBufferSize > 0) {
                    if (szDefaultCounterName != NULL) {
                        // test both ends of the caller's buffer for
                        // write access
                        szDefaultCounterName[0]                    = '\0';
                        szDefaultCounterName[dwLocalBufferSize -1] = '\0';
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (szMachineName != NULL) {
            LPWSTR szTmpMachine = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szMachineName);

            if (szTmpMachine == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            else if (* szMachineName == '\\') {
                szWideName = szTmpMachine;
            }
            else {
                szWideName = G_ALLOC((lstrlenW(szTmpMachine) + 3) * sizeof(WCHAR));
                if (szWideName == NULL) {
                    szWideName = szTmpMachine;
                }
                else {
                    StringCchPrintfW(szWideName,
                                     lstrlenW(szTmpMachine) + 3,
                                     L"%ws%ws",
                                     cszDoubleBackSlash,
                                     szTmpMachine);
                    G_FREE(szTmpMachine);
                }
            }
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            switch (dwDataSource) {
            case DATA_SOURCE_REGISTRY:
                szWideObject = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szObjectName);
                if (szWideObject == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                if (pdhStatus == ERROR_SUCCESS) {
                    pMachine  = GetMachine(szWideName, 0, PDH_GM_UPDATE_PERFNAME_ONLY);
                    if (pMachine == NULL) {
                        pdhStatus = GetLastError();
                        if (pdhStatus == ERROR_SUCCESS) pdhStatus = PDH_CSTATUS_NO_MACHINE;
                    }
                    else if (pMachine->dwStatus != ERROR_SUCCESS) {
                        pdhStatus = pMachine->dwStatus;
                        pMachine->dwRefCount --;
                        RELEASE_MUTEX(pMachine->hMutex);
                        pMachine = NULL;
                    }
                    else {
                        DWORD dwObject = GetObjectId(pMachine, szWideObject, NULL);
                        if (dwObject == (DWORD) -1) {
                            pMachine->dwRefCount --;
                            RELEASE_MUTEX(pMachine->hMutex);
                            if (pdhStatus == ERROR_SUCCESS) pdhStatus = PDH_CSTATUS_NO_OBJECT;
                            pMachine = NULL;
                        }
                    }
                }
                if (pdhStatus == ERROR_SUCCESS && pMachine != NULL) {
                    // get selected object
                    pObjectDef = GetObjectDefByName(pMachine->pSystemPerfData,
                                                    pMachine->dwLastPerfString,
                                                    pMachine->szPerfStrings,
                                                    szWideObject);
                    if (pObjectDef != NULL) {
                        // default counter reference is an index into the list
                        // of counter definition entries so walk down list of
                        // counters defs to find the default one
                        if (pObjectDef->DefaultCounter > (LONG) pObjectDef->NumCounters) {
                            // Something wrong inside PERF_OBJ_DEF block. DefaultCounter
                            // should be in the range between 0 and NumCounters, but apparently
                            // it is not. Reset DefaultCounter to 0.
                            //
                            pObjectDef->DefaultCounter = 0;
                        }
                        if (pObjectDef->DefaultCounter < (LONG) pObjectDef->NumCounters) {
                            // then the default index should be this buffer
                            lDefault    = 0;
                            pCounterDef = FirstCounter(pObjectDef);
                            while (pCounterDef != NULL && (lDefault < pObjectDef->DefaultCounter)
                                                       && (lDefault < (LONG) pObjectDef->NumCounters)) {
                                pCounterDef = NextCounter(pObjectDef, pCounterDef);
                                lDefault ++;
                            }
                            lDefault = pCounterDef->CounterNameTitleIndex;
                            if ((lDefault > 0) && ((DWORD) lDefault < pMachine->dwLastPerfString)) {
                                // then there should be a string in the table
                                szDefault   = (LPWSTR) PdhiLookupPerfNameByIndex(pMachine, lDefault);
                                if (szDefault != NULL) {
                                    dwStringLen = dwLocalBufferSize;
                                    pdhStatus   = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                                           szDefault,
                                                                           szDefaultCounterName,
                                                                           & dwStringLen);
                                    dwLocalBufferSize = dwStringLen;
                                }
                                else {
                                    dwLocalBufferSize = 0;
                                    pdhStatus         = PDH_CSTATUS_NO_COUNTER;
                                }
                            }
                            else {
                                // string index is not valid
                                dwLocalBufferSize = 0;
                                pdhStatus         = PDH_CSTATUS_NO_COUNTER;
                            }
                        }
                        else {
                            // the counter entry is not in the buffer
                            dwLocalBufferSize = 0;
                            pdhStatus         = PDH_CSTATUS_NO_COUNTER;
                        }
                    }
                    else {
                        // unable to find object
                        dwLocalBufferSize = 0;
                        pdhStatus         = PDH_CSTATUS_NO_OBJECT;
                    }
                    pMachine->dwRefCount --;
                    RELEASE_MUTEX(pMachine->hMutex);
                }
                G_FREE(szWideObject);
                break;

            case DATA_SOURCE_WBEM:
            case DATA_SOURCE_LOGFILE:
                if (pdhStatus == ERROR_SUCCESS && dwDataSource == DATA_SOURCE_WBEM) {
                    szWideObject = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szObjectName);
                    if (szWideObject == NULL) {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                    if (pdhStatus == ERROR_SUCCESS) {
                        pdhStatus = PdhiGetDefaultWbemProperty(szWideName,
                                                               szWideObject,
                                                               (LPVOID) szDefaultCounterName,
                                                               & dwLocalBufferSize,
                                                               FALSE); // ANSI function
                        G_FREE(szWideObject);
                    }
                }
                else {
                    //log files don't support this (for now)
                    dwLocalBufferSize = 0;
                }
                break;

            default:
                pdhStatus = PDH_INVALID_ARGUMENT;
                break;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
        RELEASE_MUTEX(hPdhDataMutex);
    }

    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        __try {
            * pcchBufferSize = dwLocalBufferSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    G_FREE(szWideName);
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfCounterHA(
    IN  HLOG    hDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPCSTR  szObjectName,
    IN  LPSTR   szDefaultCounterName,
    IN  LPDWORD pcchBufferSize
)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus        = ERROR_SUCCESS;

    __try {
        dwDataSourceType = DataSourceTypeH(hDataSource);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfCounterA(
                        dwDataSourceType, szMachineName, szObjectName, szDefaultCounterName, pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhGetDefaultPerfCounterA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPCSTR  szObjectName,
    IN  LPSTR   szDefaultCounterName,
    IN  LPDWORD pcchBufferSize
)
{
    DWORD      dwDataSourceType = 0;
    PDH_STATUS pdhStatus        = ERROR_SUCCESS;

    __try {
        if (szDataSource != NULL) {
            if (* szDataSource == '\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenA(szDataSource) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        if (pdhStatus == ERROR_SUCCESS) {
            dwDataSourceType = DataSourceTypeA(szDataSource);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetDefaultPerfCounterA(
                        dwDataSourceType, szMachineName, szObjectName, szDefaultCounterName, pcchBufferSize);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhBrowseCountersHW(
    IN  PPDH_BROWSE_DLG_CONFIG_HW  pBrowseDlgData
)
{
    PDHI_BROWSE_DLG_INFO  pInfo;
    LPWSTR                szResource;
    int                   nDlgReturn;
    DWORD                 dwReturn = ERROR_SUCCESS;

    pInfo.pWideStruct = (PPDH_BROWSE_DLG_CONFIG_W) pBrowseDlgData;
    pInfo.pAnsiStruct = NULL;

    if (pBrowseDlgData != NULL) {
        __try {
            // copy the data source since it wide characters already
            pInfo.hDataSource = pBrowseDlgData->hDataSource;

            szResource = MAKEINTRESOURCEW(pBrowseDlgData->bShowObjectBrowser
                       ? IDD_BROWSE_OBJECTS
                       : pBrowseDlgData->bSingleCounterPerDialog ? IDD_BROWSE_COUNTERS_SIM : IDD_BROWSE_COUNTERS_EXT);
            nDlgReturn = (int) DialogBoxParamW(ThisDLLHandle,
                                               szResource,
                                               pBrowseDlgData->hWndOwner,
                                               BrowseCounterDlgProc,
                                               (LPARAM) & pInfo);
            if (nDlgReturn == -1) {
                dwReturn = GetLastError();
            }
            else {
                dwReturn = (nDlgReturn == IDOK) ? ERROR_SUCCESS : PDH_DIALOG_CANCELLED;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = PDH_INVALID_ARGUMENT;
        }
    }
    else {
        dwReturn = PDH_INVALID_ARGUMENT;
    }
    return dwReturn;
}

PDH_FUNCTION
PdhBrowseCountersHA(
    IN  PPDH_BROWSE_DLG_CONFIG_HA  pBrowseDlgData)
{
    PDHI_BROWSE_DLG_INFO  pInfo;
    LPWSTR                szResource;
    int                   nDlgReturn;
    DWORD                 dwReturn = ERROR_SUCCESS;

    pInfo.pAnsiStruct = (PPDH_BROWSE_DLG_CONFIG_A) pBrowseDlgData;
    pInfo.pWideStruct = NULL;

    if (pBrowseDlgData != NULL) {
        __try {
            // copy the data source since it wide characters already
            pInfo.hDataSource = pBrowseDlgData->hDataSource;

            szResource = MAKEINTRESOURCEW(pBrowseDlgData->bShowObjectBrowser
                       ? IDD_BROWSE_OBJECTS
                       : pBrowseDlgData->bSingleCounterPerDialog ? IDD_BROWSE_COUNTERS_SIM : IDD_BROWSE_COUNTERS_EXT);
            nDlgReturn = (int) DialogBoxParamW(ThisDLLHandle,
                                               szResource,
                                               pBrowseDlgData->hWndOwner,
                                               BrowseCounterDlgProc,
                                               (LPARAM) & pInfo);
            if (nDlgReturn == -1) {
                dwReturn = GetLastError();
            }
            else {
                dwReturn = (nDlgReturn == IDOK) ? ERROR_SUCCESS : PDH_DIALOG_CANCELLED;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = PDH_INVALID_ARGUMENT;
        }
    }
    else {
        dwReturn = PDH_INVALID_ARGUMENT;
    }
    return dwReturn;
}

PDH_FUNCTION
PdhBrowseCountersW(
    IN  PPDH_BROWSE_DLG_CONFIG_W    pBrowseDlgData
)
{
    PDHI_BROWSE_DLG_INFO pInfo;
    LPWSTR               szResource;
    int                  nDlgReturn;
    DWORD                dwReturn = ERROR_SUCCESS;

    pInfo.pWideStruct = pBrowseDlgData;
    pInfo.pAnsiStruct = NULL;

    if (pBrowseDlgData != NULL) {
        __try {
            DWORD dwDataSource = DataSourceTypeW (pBrowseDlgData->szDataSource);
            if (dwDataSource == DATA_SOURCE_WBEM) {
                pInfo.hDataSource = H_WBEM_DATASOURCE;
            }
            else if (dwDataSource == DATA_SOURCE_LOGFILE) {
                DWORD dwLogType = 0;

                dwReturn = PdhOpenLogW(pBrowseDlgData->szDataSource,
                                       PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                       & dwLogType,
                                       NULL,
                                       0,
                                       NULL,
                                       & pInfo.hDataSource);
            }
            else {
                pInfo.hDataSource = H_REALTIME_DATASOURCE;
            }

            if (dwReturn == ERROR_SUCCESS) {
                szResource = MAKEINTRESOURCEW(pBrowseDlgData->bShowObjectBrowser
                           ? IDD_BROWSE_OBJECTS
                           : pBrowseDlgData->bSingleCounterPerDialog ? IDD_BROWSE_COUNTERS_SIM
                                                                     : IDD_BROWSE_COUNTERS_EXT);
                nDlgReturn = (int) DialogBoxParamW(ThisDLLHandle,
                                                   szResource,
                                                   pBrowseDlgData->hWndOwner,
                                                   BrowseCounterDlgProc,
                                                   (LPARAM) & pInfo);

                if (nDlgReturn == -1) {
                    dwReturn = GetLastError();
                }
                else {
                    dwReturn = nDlgReturn == IDOK ? ERROR_SUCCESS : PDH_DIALOG_CANCELLED;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = PDH_INVALID_ARGUMENT;
        }
    }
    else {
        dwReturn = PDH_INVALID_ARGUMENT;
    }
    return dwReturn;
}

PDH_FUNCTION
PdhBrowseCountersA(
    IN  PPDH_BROWSE_DLG_CONFIG_A    pBrowseDlgData
)
{
    PDHI_BROWSE_DLG_INFO pInfo;
    LPWSTR               szResource;
    int                  nDlgReturn;
    DWORD                dwReturn = ERROR_SUCCESS;

    pInfo.pAnsiStruct = pBrowseDlgData;
    pInfo.pWideStruct = NULL;

    if (pBrowseDlgData != NULL) {
        __try {
            DWORD dwDataSource = DataSourceTypeA(pBrowseDlgData->szDataSource);
            if (dwDataSource == DATA_SOURCE_WBEM) {
                pInfo.hDataSource = H_WBEM_DATASOURCE;
            }
            else if (dwDataSource == DATA_SOURCE_LOGFILE) {
                DWORD dwLogType = 0;

                dwReturn = PdhOpenLogA(pBrowseDlgData->szDataSource,
                                       PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                       & dwLogType,
                                       NULL,
                                       0,
                                       NULL,
                                       & pInfo.hDataSource);
            }
            else {
                pInfo.hDataSource = H_REALTIME_DATASOURCE;
            }

            if (dwReturn == ERROR_SUCCESS) {
                szResource = MAKEINTRESOURCEW(pBrowseDlgData->bShowObjectBrowser
                           ? IDD_BROWSE_OBJECTS
                           : pBrowseDlgData->bSingleCounterPerDialog ? IDD_BROWSE_COUNTERS_SIM
                                                                     :  IDD_BROWSE_COUNTERS_EXT);
                nDlgReturn = (int) DialogBoxParamW(ThisDLLHandle,
                                                   szResource,
                                                   pBrowseDlgData->hWndOwner,
                                                   BrowseCounterDlgProc,
                                                   (LPARAM) & pInfo);
                if (nDlgReturn == -1) {
                    dwReturn = GetLastError();
                }
                else {
                    dwReturn = nDlgReturn == IDOK ? ERROR_SUCCESS : PDH_DIALOG_CANCELLED;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = PDH_INVALID_ARGUMENT;
        }
    }
    else {
        dwReturn = PDH_INVALID_ARGUMENT;
    }
    return dwReturn;
}

LPWSTR
PdhiGetExplainText(
    LPCWSTR  szMachineName,
    LPCWSTR  szObjectName,
    LPCWSTR  szCounterName
)
{
    PPERF_MACHINE            pMachine;
    PPERF_OBJECT_TYPE        pObjectDef;
    PPERF_COUNTER_DEFINITION pCounterDef;
    LPWSTR                   szReturnString = NULL;

    pMachine  = GetMachine((LPWSTR) szMachineName, 0, PDH_GM_UPDATE_PERFNAME_ONLY);
    if (pMachine != NULL) {
        DWORD dwObject = (pMachine->dwStatus == ERROR_SUCCESS)
                       ? GetObjectId(pMachine, (LPWSTR) szObjectName, NULL) : (DWORD) -1;
        if (dwObject == (DWORD) -1) {
            pMachine->dwRefCount --;
            RELEASE_MUTEX(pMachine->hMutex);
            pMachine = NULL;
        }
    }
    if (pMachine != NULL) {
        // make sure the machine connection is valid
        if (pMachine->dwStatus == ERROR_SUCCESS) {
            pObjectDef = GetObjectDefByName(pMachine->pSystemPerfData,
                                            pMachine->dwLastPerfString,
                                            pMachine->szPerfStrings,
                                            szObjectName);
            if (pObjectDef != NULL) {
                if (szCounterName != NULL) {
                    pCounterDef = GetCounterDefByName(pObjectDef,
                                                      pMachine->dwLastPerfString,
                                                      pMachine->szPerfStrings,
                                                      (LPWSTR) szCounterName);
                    if ((pCounterDef != NULL) && 
                                    (pCounterDef->CounterHelpTitleIndex <= pMachine->dwLastPerfString)) {
                        // return string from array
                        szReturnString = pMachine->szPerfStrings[pCounterDef->CounterHelpTitleIndex];
                    }
                }
                else if (pObjectDef->ObjectHelpTitleIndex <= pMachine->dwLastPerfString) {
                    szReturnString = pMachine->szPerfStrings[pObjectDef->ObjectHelpTitleIndex];
                }
            }
        }
        pMachine->dwRefCount --;
        RELEASE_MUTEX(pMachine->hMutex);
    }
    return szReturnString;
}

BOOL
IsWbemDataSource(
    LPCWSTR  szDataSource
)
{
    BOOL bReturn = FALSE;
    __try {
        if (DataSourceTypeW(szDataSource) == DATA_SOURCE_WBEM)
            bReturn = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
    }
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhui\expldlg.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    expldlg.c

Abstract:

    explain dialog box functions

Revision History

    Bob Watson (bobw)   mar-97 Created 

--*/
#include <windows.h>
#include "strsafe.h"
#include <pdh.h>
#include "pdhmsg.h"
#include "strings.h"
#include "pdhidef.h"
#include "pdhdlgs.h"
#include "browsdlg.h"

//
//  Constants used in this module
//
WCHAR PdhiszTitleString[MAX_PATH + 1];

STATIC_BOOL
ExplainTextDlg_WM_INITDIALOG(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    RECT ParentRect;
    RECT rectDeskTop;
    RECT rectDlg;
    BOOL bResult = FALSE;

    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);

    bResult =  GetWindowRect(GetDesktopWindow(), & rectDeskTop) && GetWindowRect(hDlg, & rectDlg);
    ZeroMemory(PdhiszTitleString, (MAX_PATH + 1) * sizeof(WCHAR));
    GetWindowTextW(hDlg, PdhiszTitleString, MAX_PATH);
    if (GetWindowRect(GetParent(hDlg), & ParentRect)) {
        int x = ParentRect.left;
        int y = ParentRect.bottom + 1;

        if (bResult) {
            if (y + (rectDlg.bottom - rectDlg.top) > (rectDeskTop.bottom - rectDeskTop.top)) {
                // Explain dialog will be off-screen at the bottom, so
                // reposition it to top of AddCounter dialog
                //
                y = ParentRect.top - (rectDlg.bottom - rectDlg.top) - 1;
                if (y < 0) {
                    // Explain dialog will be off-screen at the top, use
                    // original calculation
                    //
                    y = ParentRect.bottom + 1;
                }
            }
        }
        SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
    }
    else {
        ShowWindow(hDlg, SW_SHOW);
    }

    return FALSE;
}

STATIC_BOOL
ExplainTextDlg_WM_COMMAND(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(hDlg);
    return FALSE;
}

STATIC_BOOL
ExplainTextDlg_WM_SYSCOMMAND(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    BOOL bReturn = FALSE;

    UNREFERENCED_PARAMETER(lParam);

    switch (wParam) {
    case SC_CLOSE:
        PostMessageW(GetParent(hDlg), EDM_EXPLAIN_DLG_CLOSING, 0, 0);
        EndDialog(hDlg, IDOK);
        bReturn = TRUE;
        break;

    default:
        break;
    }
    return bReturn;
}

STATIC_BOOL
ExplainTextDlg_WM_CLOSE(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(hDlg);
    return TRUE;
}

STATIC_BOOL
ExplainTextDlg_WM_DESTROY(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(hDlg);
    return TRUE;
}

INT_PTR CALLBACK
ExplainTextDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    BOOL bReturn = FALSE;

    switch (message) {
    case WM_INITDIALOG:
        bReturn = ExplainTextDlg_WM_INITDIALOG(hDlg, wParam, lParam);
        break;

    case WM_COMMAND:
        bReturn = ExplainTextDlg_WM_COMMAND(hDlg, wParam, lParam);
        break;

    case WM_SYSCOMMAND:
        bReturn = ExplainTextDlg_WM_SYSCOMMAND(hDlg, wParam, lParam);
        break;

    case WM_CLOSE:
        bReturn = ExplainTextDlg_WM_CLOSE(hDlg, wParam, lParam);
        break;

    case WM_DESTROY:
        bReturn = ExplainTextDlg_WM_DESTROY(hDlg, wParam, lParam);
        break;

    case EDM_UPDATE_EXPLAIN_TEXT:
        if (lParam != 0) {
            SetWindowTextW (GetDlgItem(hDlg, IDC_EXPLAIN_TEXT), (LPCWSTR)lParam);
        } else {
            SetWindowTextW (GetDlgItem(hDlg, IDC_EXPLAIN_TEXT), cszEmptyString);
        }
        bReturn = TRUE;
        break;

    case EDM_UPDATE_TITLE_TEXT:
        {
            LPWSTR szCaption = NULL;
            DWORD  dwLength  = lstrlenW(PdhiszTitleString) + 1;

            if (lParam != 0) {
                if (* (LPWSTR) lParam != L'\0') {
                    dwLength += (lstrlenW(cszSpacer) + lstrlenW((LPWSTR) lParam));
                }
            }
            szCaption = G_ALLOC(dwLength * sizeof(WCHAR));
            if (szCaption != NULL) {
                if (lParam == 0) {
                    StringCchCopyW(szCaption, dwLength, PdhiszTitleString);
                }
                else if (* (LPWSTR) lParam == L'\0') {
                    StringCchCopyW(szCaption, dwLength, PdhiszTitleString);
                }
                else {
                    StringCchPrintfW(szCaption, dwLength, L"%ws%ws%ws", PdhiszTitleString, cszSpacer, (LPWSTR) lParam);
                }
                SetWindowTextW(hDlg, (LPCWSTR) szCaption);
                G_FREE(szCaption);
            }
        }
        bReturn = TRUE;
        break;

    default:
        break;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhui\pdhdlgs.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    pdhdlgs.h

Abstract:

    Dialog resource constants

--*/

#define IDC_STATIC                  -1
#define IDD_BROWSE_COUNTERS_EXT     100
#define IDD_BROWSE_COUNTERS_SIM     101
#define IDD_DATA_SOURCE             102
#define IDD_EXPLAIN_DLG             103
#define IDD_BROWSE_OBJECTS          104
#define IDC_USE_LOCAL_MACHINE       1001
#define IDC_SELECT_MACHINE          1002
#define IDC_MACHINE_CAPTION         1003
#define IDC_MACHINE_COMBO           1004
#define IDC_OBJECT_NAME_CAPTION     1010
#define IDC_OBJECT_COMBO            1011
#define IDC_COUNTERS_CAPTION        1020
#define IDC_ALL_COUNTERS            1021
#define IDC_USE_COUNTER_LIST        1022
#define IDC_COUNTER_LIST            1023
#define IDC_ALL_INSTANCES           1031
#define IDC_USE_INSTANCE_LIST       1032
#define IDC_INSTANCE_CAPTION        1033
#define IDC_INSTANCE_LIST           1034
#define IDC_EXPLAIN_BTN             1041
#define IDC_HELP_BTN                1042
#define IDC_NETWORK                 1043
#define IDC_OBJECT_DETAIL_CAPTION   1044
#define IDC_OBJECT_LIST             1045
#define IDC_COUNTER_DETAIL_CAPTION  1051
#define IDC_COUNTER_DETAIL_COMBO    1052
#define IDC_COUNTER_INFO_TEXT       2001
#define IDC_COUNTER_INFO_NAME       2002
#define IDC_CURRENT_ACTIVITY        3001
#define IDC_DATA_FROM_LOG_FILE      3002
#define IDC_PERF_REG                3003    
#define IDC_WBEM_NS                 3004
#define IDC_LOG_FILE_EDIT           3005
#define IDC_BROWSE_LOG_FILES        3006
#define IDC_EXPLAIN_TEXT            4001
#define IDS_STRINGBASE              10000
#define IDS_DETAIL_NOVICE           10001
#define IDS_DETAIL_ADVANCED         10002
#define IDS_DETAIL_EXPERT           10003
#define IDS_DETAIL_WIZARD           10004
#define IDS_DEFAULT_ACCOUNT         12001

#define IDH_USE_LOCAL_MACHINE       11001
#define IDH_SELECT_MACHINE          11002
#define IDH_MACHINE_COMBO           11003
#define IDH_COUNTER_DETAIL_COMBO    11004
#define IDH_OBJECT_COMBO            11005
#define IDH_ALL_COUNTERS            11006
#define IDH_USE_COUNTER_LIST        11007
#define IDH_COUNTER_LIST            11008
#define IDH_ALL_INSTANCES           11009
#define IDH_USE_INSTANCE_LIST       11010
#define IDH_INSTANCE_LIST           11011
#define IDH_EXPLAIN_BTN             11012

#define IDH_CURRENT_ACTIVITY        11013
#define IDH_DATA_FROM_LOG_FILE      11014
#define IDH_LOG_FILE_EDIT           11015
#define IDH_OBJECT_LIST             11016
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhui\wildcard.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    wildcard.c

Abstract:

    counter name wild card expansion functions

--*/
#include <windows.h>
#include <winperf.h>
#include "mbctype.h"
#include "strsafe.h"
#include "pdh.h"
#include "pdhmsg.h"
#include "pdhidef.h"
#include "pdhdlgs.h"
#include "strings.h"
#include "perftype.h"
#include "perfdata.h"

#pragma warning ( disable : 4213)

DWORD DataSourceTypeA(LPCSTR  szDataSource);
DWORD DataSourceTypeW(LPCWSTR szDataSource);

STATIC_BOOL
WildStringMatchW(
    LPWSTR szWildString,
    LPWSTR szMatchString
)
{
    BOOL bReturn;

    if (szWildString == NULL) {
        // every thing matches a null wild card string
        bReturn = TRUE;
    }
    else if (* szWildString == SPLAT_L) {
        // every thing matches this
        bReturn = TRUE;
    }
    else {
        // for now just do a case insensitive comparison.
        // later, this can be made more selective to support
        // partial wildcard string matches
        bReturn = (BOOL) (lstrcmpiW(szWildString, szMatchString) == 0);
    }
    return bReturn;
}

STATIC_PDH_FUNCTION
PdhiExpandWildcardPath(
    HLOG    hDataSource,
    LPCWSTR szWildCardPath,
    LPVOID  pExpandedPathList,
    LPDWORD pcchPathListLength,
    DWORD   dwFlags,
    BOOL    bUnicode
)
/*
    Flags:
        NoExpandCounters
        NoExpandInstances
        CheckCostlyCounters
*/
{
    PDH_COUNTER_PATH_ELEMENTS_W pPathElem;
    PPDHI_COUNTER_PATH          pWildCounterPath     = NULL;
    PDH_STATUS                  pdhStatus            = ERROR_SUCCESS;
    DWORD                       dwBufferRemaining    = 0;
    LPVOID                      szNextUserString     = NULL;
    DWORD                       dwPathSize           = 0;
    DWORD                       dwSize               = 0;
    DWORD                       dwSizeReturned       = 0;
    DWORD                       dwRetry;
    LPWSTR                      mszObjectList        = NULL;
    DWORD                       dwObjectListSize     = 0;
    LPWSTR                      szThisObject;
    LPWSTR                      mszCounterList       = NULL;
    DWORD                       dwCounterListSize    = 0;
    LPWSTR                      szThisCounter;
    LPWSTR                      mszInstanceList      = NULL;
    DWORD                       dwInstanceListSize   = 0;
    LPWSTR                      szThisInstance;
    LPWSTR                      szTempPathBuffer     = NULL;
    DWORD                       szTempPathBufferSize = SMALL_BUFFER_SIZE;
    BOOL                        bMoreData            = FALSE;
    BOOL                        bNoInstances         = FALSE;
    DWORD                       dwSuccess            = 0;
    LIST_ENTRY                  InstList;
    PLIST_ENTRY                 pHead;
    PLIST_ENTRY                 pNext;
    PPDHI_INSTANCE              pInst;
    PPERF_MACHINE               pMachine             = NULL;

    dwPathSize           = lstrlenW(szWildCardPath) + 1;
    if (dwPathSize < MAX_PATH) dwPathSize = MAX_PATH;
    dwSize               = sizeof(PDHI_COUNTER_PATH) + 2 * dwPathSize * sizeof(WCHAR);
    pWildCounterPath     = G_ALLOC(dwSize);
    szTempPathBufferSize = SMALL_BUFFER_SIZE;
    szTempPathBuffer     = G_ALLOC(szTempPathBufferSize * sizeof(WCHAR));

    if (pWildCounterPath == NULL || szTempPathBuffer == NULL) {
        // unable to allocate memory so bail out
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }
    else {
        __try {
            dwBufferRemaining = * pcchPathListLength;
            szNextUserString  = pExpandedPathList;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // Parse wild card Path
        if (ParseFullPathNameW(szWildCardPath, & dwSize, pWildCounterPath, FALSE)) {
            if (pWildCounterPath->szObjectName == NULL) {
                pdhStatus = PDH_INVALID_PATH;
            }
            else if (* pWildCounterPath->szObjectName == SPLAT_L) {
                BOOL bFirstTime = TRUE;

                //then the object is wild so get the list
                // of objects supported by this machine

                dwObjectListSize = SMALL_BUFFER_SIZE;  // starting buffer size
                dwRetry          = 10;
                do {
                    G_FREE(mszObjectList);
                    mszObjectList = G_ALLOC(dwObjectListSize * sizeof(WCHAR));
                    if (mszObjectList != NULL) {
                        pdhStatus = PdhEnumObjectsHW(hDataSource,
                                                     pWildCounterPath->szMachineName,
                                                     mszObjectList,
                                                     & dwObjectListSize,
                                                     PERF_DETAIL_WIZARD,
                                                     bFirstTime);
                        if (bFirstTime) bFirstTime = FALSE;
                        dwRetry --;
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
                while (dwRetry && pdhStatus == PDH_MORE_DATA);
            }
            else {
                if (hDataSource == H_REALTIME_DATASOURCE) {
                    DWORD dwObjectId;

                    pMachine = GetMachine(pWildCounterPath->szMachineName, 0, PDH_GM_UPDATE_PERFNAME_ONLY);
                    if (pMachine == NULL) {
                        pdhStatus = GetLastError();
                    }
                    else if (pMachine->dwStatus != ERROR_SUCCESS) {
                        pdhStatus = pMachine->dwStatus;
                        pMachine->dwRefCount --;
                        RELEASE_MUTEX(pMachine->hMutex);
                    }
                    else {
                        dwObjectId = GetObjectId(pMachine, pWildCounterPath->szObjectName, NULL);
                        pMachine->dwRefCount --;
                        RELEASE_MUTEX(pMachine->hMutex);

                        if (dwObjectId == (DWORD) -1) {
                            pdhStatus = PDH_CSTATUS_NO_OBJECT;
                        }
                        else {
                            DWORD dwGetMachineFlags = (dwFlags & PDH_REFRESHCOUNTERS) ? (PDH_GM_UPDATE_PERFDATA) : (0);

                            pMachine = GetMachine(pWildCounterPath->szMachineName, dwObjectId, dwGetMachineFlags);
                            if (pMachine != NULL) {
                                pMachine->dwRefCount --;
                                RELEASE_MUTEX(pMachine->hMutex);
                            }
                        }
                    }
                }
                if (pdhStatus == ERROR_SUCCESS) {
                    dwObjectListSize = lstrlenW(pWildCounterPath->szObjectName) + 2;
                    mszObjectList    = G_ALLOC(dwObjectListSize * sizeof (WCHAR));
                    if (mszObjectList != NULL) {
                        StringCchCopyW(mszObjectList, dwObjectListSize, pWildCounterPath->szObjectName);
                        // add the MSZ terminator
                        mszObjectList[dwObjectListSize - 2] = L'\0';
                        mszObjectList[dwObjectListSize - 1] = L'\0';
                        pdhStatus = ERROR_SUCCESS;
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
            }
        }
        else {
            pdhStatus = PDH_INVALID_PATH;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pPathElem.szMachineName = pWildCounterPath->szMachineName;

        // for each object
        for (szThisObject = mszObjectList;
                * szThisObject != L'\0';
                  szThisObject += (lstrlenW(szThisObject) + 1)) {
            G_FREE(mszCounterList);
            G_FREE(mszInstanceList);
            mszCounterList     = NULL;
            mszInstanceList    = NULL;
            dwCounterListSize  = MEDIUM_BUFFER_SIZE; // starting buffer size
            dwInstanceListSize = MEDIUM_BUFFER_SIZE; // starting buffer size
            dwRetry            = 10;
            do {
                G_FREE(mszCounterList);
                G_FREE(mszInstanceList);
                mszCounterList  = G_ALLOC(dwCounterListSize  * sizeof(WCHAR));
                mszInstanceList = G_ALLOC(dwInstanceListSize * sizeof(WCHAR));
                if (mszCounterList != NULL && mszInstanceList != NULL) {
                    pdhStatus = PdhEnumObjectItemsHW(hDataSource,
                                                     pWildCounterPath->szMachineName,
                                                     szThisObject,
                                                     mszCounterList,
                                                     & dwCounterListSize,
                                                     mszInstanceList,
                                                     & dwInstanceListSize,
                                                     PERF_DETAIL_WIZARD,
                                                     0);
                        dwRetry--;
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
            while (dwRetry && pdhStatus == PDH_MORE_DATA);

            pPathElem.szObjectName = szThisObject;
            if (pdhStatus == ERROR_SUCCESS) {
                if (pWildCounterPath->szCounterName == NULL) {
                    pdhStatus = PDH_INVALID_PATH;
                }
                else if ((* pWildCounterPath->szCounterName != SPLAT_L) || (dwFlags & PDH_NOEXPANDCOUNTERS)) {
                    G_FREE(mszCounterList);
                    dwCounterListSize = lstrlenW(pWildCounterPath->szCounterName) + 2;
                    mszCounterList    = G_ALLOC(dwCounterListSize * sizeof(WCHAR));
                    if (mszCounterList != NULL) {
                        StringCchCopyW(mszCounterList, dwCounterListSize, pWildCounterPath->szCounterName);
                        mszCounterList[dwCounterListSize - 1] = L'\0';
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }

                if ((pWildCounterPath->szInstanceName == NULL) && (pdhStatus == ERROR_SUCCESS)){
                    G_FREE(mszInstanceList);
                    bNoInstances       = TRUE;
                    dwInstanceListSize = 2;
                    mszInstanceList    = G_ALLOC(dwInstanceListSize * sizeof(WCHAR));
                    if (mszInstanceList != NULL) {
                        mszInstanceList[0] = mszInstanceList[1] = L'\0';
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
                else if ((* pWildCounterPath->szInstanceName != SPLAT_L) || (dwFlags & PDH_NOEXPANDINSTANCES)) {
                    G_FREE(mszInstanceList);
                    dwInstanceListSize = lstrlenW(pWildCounterPath->szInstanceName) + 2;
                    if (pWildCounterPath->szParentName != NULL) {
                        dwInstanceListSize += lstrlenW(pWildCounterPath->szParentName) + 1;
                    }
                    if (pWildCounterPath->dwIndex != 0 && pWildCounterPath->dwIndex != PERF_NO_UNIQUE_ID) {
                        dwInstanceListSize += 16;
                    }
                    mszInstanceList    = G_ALLOC(dwInstanceListSize * sizeof(WCHAR));
                    if (mszInstanceList != NULL) {
                        if (pWildCounterPath->szParentName != NULL) {
                            StringCchPrintfW(mszInstanceList, dwInstanceListSize, L"%ws/%ws",
                                            pWildCounterPath->szParentName, pWildCounterPath->szInstanceName);
                        }
                        else {
                            StringCchCopyW(mszInstanceList, dwInstanceListSize, pWildCounterPath->szInstanceName);
                        }
                        if (pWildCounterPath->dwIndex != 0 && pWildCounterPath->dwIndex != PERF_NO_UNIQUE_ID) {
                            WCHAR szDigits[16];

                            StringCchCatW(mszInstanceList, dwInstanceListSize, cszPoundSign);

                            ZeroMemory(szDigits, 16 * sizeof(WCHAR));
                            _ltow((long) pWildCounterPath->dwIndex, szDigits, 10);
                            StringCchCatW(mszInstanceList, dwInstanceListSize, szDigits);
                        }

                        mszInstanceList [dwInstanceListSize - 1] = L'\0';
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
            }
            if (pdhStatus != ERROR_SUCCESS) continue;

            if (mszInstanceList != NULL) {
                if (! bNoInstances && mszInstanceList[0] == L'\0') {
                    pdhStatus = PDH_CSTATUS_NO_INSTANCE;
                    continue;
                }

                InitializeListHead(& InstList);
                for (szThisInstance = mszInstanceList;
                              * szThisInstance != L'\0';
                                szThisInstance += (lstrlenW(szThisInstance) + 1)) {
                    PdhiFindInstance(& InstList, szThisInstance, TRUE, &pInst);
                }

                szThisInstance = mszInstanceList;
                do {
                    if (bNoInstances) {
                        pPathElem.szInstanceName = NULL;
                    }
                    else {
                        pPathElem.szInstanceName = szThisInstance;
                    }
                    pPathElem.szParentInstance = NULL;  // included in the instance name
                    pInst = NULL;
                    PdhiFindInstance(& InstList, szThisInstance, FALSE, & pInst);
                    if (pInst == NULL || pInst->dwTotal == 1
                                      || pInst->dwCount <= 1) {
                        pPathElem.dwInstanceIndex = (DWORD) -1;     // included in the instance name
                    }
                    else {
                        pInst->dwCount --;
                        pPathElem.dwInstanceIndex = pInst->dwCount;
                    }
                    for (szThisCounter = mszCounterList;
                            * szThisCounter != L'\0';
                              szThisCounter += (lstrlenW(szThisCounter) + 1)) {
                        pPathElem.szCounterName = szThisCounter;

                        //make path string and add to list if it will fit
                        szTempPathBufferSize = SMALL_BUFFER_SIZE;
                        pdhStatus = PdhMakeCounterPathW(& pPathElem, szTempPathBuffer, & szTempPathBufferSize, 0);
                        if (pdhStatus == ERROR_SUCCESS) {
                            // add the string if it will fit
                            if (bUnicode) {
                                dwSize = lstrlenW((LPWSTR) szTempPathBuffer) + 1;
                                if (! bMoreData && (dwSize <= dwBufferRemaining)) {
                                    StringCchCopyW((LPWSTR) szNextUserString, dwBufferRemaining, szTempPathBuffer);
                                    (LPBYTE) szNextUserString += dwSize * sizeof(WCHAR);
                                    dwBufferRemaining         -= dwSize;
                                    dwSuccess ++;
                                }
                                else {
                                    dwBufferRemaining = 0;
                                    bMoreData         = TRUE;
                                }
                            }
                            else {
                                dwSize = dwBufferRemaining;
                                if (PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                             szTempPathBuffer,
                                                             szNextUserString,
                                                             & dwSize) == ERROR_SUCCESS) {
                                    (LPBYTE)szNextUserString += dwSize * sizeof(CHAR);
                                    dwBufferRemaining        -= dwSize;
                                    dwSuccess ++;
                                }
                                else {
                                    dwBufferRemaining = 0;
                                    bMoreData         = TRUE;
                                }
                            }
                            dwSizeReturned += dwSize;
                        } // end if path created OK
                    } // end for each counter

                    if (* szThisInstance != L'\0') {
                        szThisInstance += (lstrlenW(szThisInstance) + 1);
                    }
                }
                while (* szThisInstance != L'\0');

                if (! IsListEmpty(& InstList)) {
                    pHead = & InstList;
                    pNext = pHead->Flink;
                    while (pNext != pHead) {
                        pInst = CONTAINING_RECORD(pNext, PDHI_INSTANCE, Entry);
                        pNext = pNext->Flink;
                        RemoveEntryList(& pInst->Entry);
                        G_FREE(pInst);
                    }
                }
            } // else no instances to do
        } // end for each object found
    } // end if object enumeration successful

    if (dwSuccess > 0) {
        pdhStatus = (bMoreData) ? (PDH_MORE_DATA) : (ERROR_SUCCESS);
    }

    if (dwSizeReturned > 0) {
        dwSize = 1;
        if (dwBufferRemaining >= 1) {
            if (szNextUserString) {
                if (bUnicode) {
                    * (LPWSTR) szNextUserString = L'\0';
                    (LPBYTE) szNextUserString  += dwSize * sizeof(WCHAR);
                }
                else {
                    * (LPSTR) szNextUserString  = '\0';
                    (LPBYTE) szNextUserString  += dwSize * sizeof(CHAR);
                }
            }
        }
        dwSizeReturned    += dwSize;
        dwBufferRemaining -= dwSize;
    }

    * pcchPathListLength = dwSizeReturned;

    G_FREE(mszCounterList);
    G_FREE(mszInstanceList);
    G_FREE(mszObjectList);
    G_FREE(pWildCounterPath);
    G_FREE(szTempPathBuffer);

    if (bMoreData) pdhStatus = PDH_MORE_DATA;
    return (pdhStatus);
}

PDH_FUNCTION
PdhExpandCounterPathW(
    IN  LPCWSTR szWildCardPath,
    IN  LPWSTR  mszExpandedPathList,
    IN  LPDWORD pcchPathListLength
)
/*++
    Expands any wild card characters in the following fields of the
    counter path string in the szWildCardPath argument and returns the
    matching counter paths in the buffer referenced by the
    mszExpandedPathList argument

    The input path is defined as one of the following formats:

        \\machine\object(parent/instance#index)\counter
        \\machine\object(parent/instance)\counter
        \\machine\object(instance#index)\counter
        \\machine\object(instance)\counter
        \\machine\object\counter
        \object(parent/instance#index)\counter
        \object(parent/instance)\counter
        \object(instance#index)\counter
        \object(instance)\counter
        \object\counter

    Input paths that include the machine will be expanded to also
    include the machine and use the specified machine to resolve the
    wild card matches. Input paths that do not contain a machine name
    will use the local machine to resolve wild card matches.

    The following fields may contain either a valid name or a wild card
    character ("*").  Partial string matches (e.g. "pro*") are not
    supported.

        parent      returns all instances of the specified object that
                        match the other specified fields
        instance    returns all instances of the specified object and
                        parent object if specified
        index       returns all duplicate matching instance names
        counter     returns all counters of the specified object
--*/
{
    return PdhExpandWildCardPathW(NULL, szWildCardPath, mszExpandedPathList, pcchPathListLength, 0);
}

PDH_FUNCTION
PdhExpandCounterPathA(
    IN  LPCSTR  szWildCardPath,
    IN  LPSTR   mszExpandedPathList,
    IN  LPDWORD pcchPathListLength
)
{
    return PdhExpandWildCardPathA(NULL, szWildCardPath, mszExpandedPathList, pcchPathListLength, 0);
}

PDH_FUNCTION
PdhExpandWildCardPathHW(
    IN  HLOG    hDataSource,
    IN  LPCWSTR szWildCardPath,
    IN  LPWSTR  mszExpandedPathList,
    IN  LPDWORD pcchPathListLength,
    IN  DWORD   dwFlags
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwLocalBufferSize;

    if ((szWildCardPath == NULL) || (pcchPathListLength == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            if (* szWildCardPath == L'\0' || lstrlenW(szWildCardPath) > PDH_MAX_COUNTER_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else {
                dwLocalBufferSize = * pcchPathListLength;
                if (dwLocalBufferSize > 0) {
                    if (mszExpandedPathList != NULL) {
                        mszExpandedPathList[0]                     = L'\0';
                        mszExpandedPathList[dwLocalBufferSize - 1] = L'\0';
                    }
                    else {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiExpandWildcardPath(hDataSource,
                                           szWildCardPath,
                                           (LPVOID) mszExpandedPathList,
                                           & dwLocalBufferSize,
                                           dwFlags,
                                           TRUE);
        __try {
            * pcchPathListLength = dwLocalBufferSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhExpandWildCardPathW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szWildCardPath,
    IN  LPWSTR  mszExpandedPathList,
    IN  LPDWORD pcchPathListLength,
    IN  DWORD   dwFlags
)
/*++
    Expands any wild card characters in the following fields of the
    counter path string in the szWildCardPath argument and returns the
    matching counter paths in the buffer referenced by the
    mszExpandedPathList argument

    The input path is defined as one of the following formats:

        \\machine\object(parent/instance#index)\counter
        \\machine\object(parent/instance)\counter
        \\machine\object(instance#index)\counter
        \\machine\object(instance)\counter
        \\machine\object\counter
        \object(parent/instance#index)\counter
        \object(parent/instance)\counter
        \object(instance#index)\counter
        \object(instance)\counter
        \object\counter

    Input paths that include the machine will be expanded to also
    include the machine and use the specified machine to resolve the
    wild card matches. Input paths that do not contain a machine name
    will use the local machine to resolve wild card matches.

    The following fields may contain either a valid name or a wild card
    character ("*").  Partial string matches (e.g. "pro*") are not
    supported.

        parent      returns all instances of the specified object that
                        match the other specified fields
        instance    returns all instances of the specified object and
                        parent object if specified
        index       returns all duplicate matching instance names
        counter     returns all counters of the specified object
--*/
{
    PDH_STATUS  pdhStatus    = ERROR_SUCCESS;
    DWORD       dwLocalBufferSize;
    DWORD       dwDataSource = 0;
    HLOG        hDataSource  = H_REALTIME_DATASOURCE;

    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (* szDataSource == L'\0') {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenW(szDataSource) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg

        if (pdhStatus == ERROR_SUCCESS) {
            dwDataSource      = DataSourceTypeW(szDataSource);
            dwLocalBufferSize = * pcchPathListLength;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogW(szDataSource,
                                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                    & dwLogType,
                                    NULL,
                                    0,
                                    NULL,
                                    & hDataSource);
        }

        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhExpandWildCardPathHW(hDataSource,
                                                szWildCardPath,
                                                mszExpandedPathList,
                                                pcchPathListLength,
                                                dwFlags);
            if (dwDataSource == DATA_SOURCE_LOGFILE) {
                PdhCloseLog(hDataSource, 0);
            }
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhExpandWildCardPathHA(
    IN  HLOG    hDataSource,
    IN  LPCSTR  szWildCardPath,
    IN  LPSTR   mszExpandedPathList,
    IN  LPDWORD pcchPathListLength,
    IN  DWORD   dwFlags
)
{
    LPWSTR      szWideWildCardPath = NULL;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwLocalBufferSize;

    if ((szWildCardPath == NULL) || (pcchPathListLength == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (* szWildCardPath == '\0') {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwLocalBufferSize = * pcchPathListLength;
            if (dwLocalBufferSize > 0) {
                if (mszExpandedPathList != NULL) {
                    mszExpandedPathList[0]                     = L'\0';
                    mszExpandedPathList[dwLocalBufferSize - 1] = L'\0';
                }
                else {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (* szWildCardPath == '\0' || lstrlenA(szWildCardPath) > PDH_MAX_COUNTER_PATH) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else {
                    szWideWildCardPath = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szWildCardPath);
                    if (szWideWildCardPath == NULL) {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiExpandWildcardPath(hDataSource,
                                           szWideWildCardPath,
                                           (LPVOID) mszExpandedPathList,
                                           & dwLocalBufferSize,
                                           dwFlags,
                                           FALSE);
        __try {
            * pcchPathListLength = dwLocalBufferSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    G_FREE(szWideWildCardPath);
    return pdhStatus;
}

PDH_FUNCTION
PdhExpandWildCardPathA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szWildCardPath,
    IN  LPSTR   mszExpandedPathList,
    IN  LPDWORD pcchPathListLength,
    IN  DWORD   dwFlags
)
{
    PDH_STATUS  pdhStatus   = ERROR_SUCCESS;
    HLOG        hDataSource = H_REALTIME_DATASOURCE;
    DWORD       dwDataSource  = 0;

    __try {
        if (szDataSource != NULL) {
            // test for read access to the name
            if (* szDataSource == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else if (lstrlenA(szDataSource) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } // else NULL is a valid arg

        if (pdhStatus == ERROR_SUCCESS) {
                dwDataSource = DataSourceTypeA(szDataSource);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwDataSource == DATA_SOURCE_WBEM) {
            hDataSource = H_WBEM_DATASOURCE;
        }
        else if (dwDataSource == DATA_SOURCE_LOGFILE) {
            DWORD dwLogType = 0;

            pdhStatus = PdhOpenLogA(szDataSource,
                                    PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                    & dwLogType,
                                    NULL,
                                    0,
                                    NULL,
                                    & hDataSource);
        }

        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhExpandWildCardPathHA(hDataSource,
                                                szWildCardPath,
                                                mszExpandedPathList,
                                                pcchPathListLength,
                                                dwFlags);
            if (dwDataSource == DATA_SOURCE_LOGFILE) {
                PdhCloseLog(hDataSource, 0);
            }
        }
    }
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\classmap.cpp ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  CLASSMAP.CPP
//  
//  Mapped NT5 Perf Counter Provider
//
//  raymcc      02-Dec-97   Created.        
//  raymcc      20-Feb-98   Updated to use new initializer.
//  bobw         8-Jub-98   optimized for use with NT Perf counters
//
//***************************************************************************

#include <wpheader.h>
#include "oahelp.inl"

//***************************************************************************
//
//  CClassMapInfo::CClassMapInfo()
//
//  The objective of the map is to have one instance for each CIM class.
//  Internally, a map of perf object ids to CIM property handles is maintained
//  for the class.
//
//  Later, when instances are requested, the blob is retrieved from 
//  HKEY_PERFORMANCE_DATA, and the object IDs in the blob are used to
//  look up the property handles, which are then used to populate instances.
//
//  Property names are never really used except in the mapping phase.
//
//***************************************************************************
// ok
CClassMapInfo::CClassMapInfo()
{
    m_pClassDef = 0;            // The CIM class definition
    m_pszClassName = 0;         // The UNICODE class name

    m_dwObjectId = 0;           // Perf object Id
    m_bSingleton = FALSE;
    m_bCostly = FALSE;
    m_dwNumProps = 0;           // Number of props in class, size
                                // of the following arrays

    m_lRefCount = 0;            // nothing mapped yet
    // These are pointers to parallel arrays, all of the same
    // size (m_dwNumProps)
    // ============================================================
    
    m_pdwIDs = 0;               // IDs of properties
    m_pdwHandles = 0;           // Handles to properties
    m_pdwTypes = 0;             // Types of properties

    m_dwNameHandle = 0;             // The 'Name' property
    m_dwPerfTimeStampHandle = 0;    // the Perf time TimeStamp property
    m_dw100NsTimeStampHandle = 0;   // the 100 Ns Perf TimeStamp property
    m_dwObjectTimeStampHandle = 0;  // the Object TimeStamp property
    m_dwPerfFrequencyHandle = 0;    // the Perf time frequency property
    m_dw100NsFrequencyHandle = 0;   // the 100 Ns Perf frequency property
    m_dwObjectFrequencyHandle = 0;  // the Object frequency property
}

//***************************************************************************
//
//  CClassMapInfo::~CClassMapInfo
//
//***************************************************************************
// ok

CClassMapInfo::~CClassMapInfo()
{
    // this can be destructed only if it's the last item referencing it.
    // if there's another reference to this class, it should have been 
    // released before the destructor was called.
    assert (m_lRefCount <= 1);

    if (m_pClassDef)
        m_pClassDef->Release();

	if (m_pszClassName != NULL) { delete [] m_pszClassName; m_pszClassName = NULL;}
    if (m_pdwIDs != NULL)		{ delete [] m_pdwIDs;		m_pdwIDs = NULL; }
    if (m_pdwHandles != NULL)	{ delete [] m_pdwHandles;	m_pdwHandles = NULL; }
    if (m_pdwTypes != NULL)		{ delete [] m_pdwTypes;		m_pdwTypes = NULL; }
}

//***************************************************************************
//
//  CClassMapInfo::Copy(CClassMapInfo *pClassMap)
//
//  allocates an new Class Map entry and copies the data from the
//  class map passed into it and returns a pointer to the duplicate entry
//
//
//***************************************************************************
// ok
CClassMapInfo * CClassMapInfo::CreateDuplicate()
{
    CClassMapInfo *pOrigClassMap = this;
    CClassMapInfo *pNewClassMap = NULL;
    DWORD	i;

    pNewClassMap = new CClassMapInfo;

    if (pNewClassMap != NULL) {
        pNewClassMap->m_pClassDef = pOrigClassMap->m_pClassDef;
        pNewClassMap->m_pClassDef->AddRef();

        if (pOrigClassMap->m_pszClassName != NULL) {
            size_t cchSize = lstrlenW(pOrigClassMap->m_pszClassName)+1;
            pNewClassMap->m_pszClassName = 
                new WCHAR[cchSize];
            if (pNewClassMap->m_pszClassName != NULL) {
                StringCchCopyW(pNewClassMap->m_pszClassName, cchSize, pOrigClassMap->m_pszClassName);

                pNewClassMap->m_bSingleton = pOrigClassMap->m_bSingleton;
                pNewClassMap->m_bCostly = pOrigClassMap->m_bCostly;

                pNewClassMap->m_dwObjectId = pOrigClassMap->m_dwObjectId;
                pNewClassMap->m_lRefCount = 1;

                pNewClassMap->m_dwNameHandle            = pOrigClassMap->m_dwNameHandle;
                pNewClassMap->m_dwPerfTimeStampHandle   = pOrigClassMap->m_dwPerfTimeStampHandle;
                pNewClassMap->m_dw100NsTimeStampHandle  = pOrigClassMap->m_dw100NsTimeStampHandle;
                pNewClassMap->m_dwObjectTimeStampHandle = pOrigClassMap->m_dwObjectTimeStampHandle;
                pNewClassMap->m_dwPerfFrequencyHandle   = pOrigClassMap->m_dwPerfFrequencyHandle;
                pNewClassMap->m_dw100NsFrequencyHandle  = pOrigClassMap->m_dw100NsFrequencyHandle;
                pNewClassMap->m_dwObjectFrequencyHandle = pOrigClassMap->m_dwObjectFrequencyHandle;

                pNewClassMap->m_dwNumProps = pOrigClassMap->m_dwNumProps;

                pNewClassMap->m_pdwIDs = new PerfObjectId[pNewClassMap->m_dwNumProps];
                pNewClassMap->m_pdwHandles = new DWORD[pNewClassMap->m_dwNumProps];
                pNewClassMap->m_pdwTypes = new DWORD[pNewClassMap->m_dwNumProps];

                if ((pNewClassMap->m_pdwIDs  != NULL) &&
                    (pNewClassMap->m_pdwHandles != NULL) &&
                    (pNewClassMap->m_pdwTypes  != NULL)) {
                    // copy each table to the new object
                    for (i = 0; i < pNewClassMap->m_dwNumProps; i++) {
                        pNewClassMap->m_pdwIDs[i]       = pOrigClassMap->m_pdwIDs[i];
                        pNewClassMap->m_pdwHandles[i]   = pOrigClassMap->m_pdwHandles[i];
                        pNewClassMap->m_pdwTypes[i]     = pOrigClassMap->m_pdwTypes[i];
                    }
                }
                else {
                    delete pNewClassMap;
                    pNewClassMap = NULL;
                }
            } else {
                delete pNewClassMap;
                pNewClassMap = NULL;
            }
        }
    }

    return pNewClassMap;
}

//***************************************************************************
//
//  CClassMapInfo::Map()
//
//  Maps the inbound class definition by:
//
//  (1) Retrieving the perf object id from the class definition.
//  (2) Retrieving the property handles, perf ids, and types for each 
//      property.
//
//
//***************************************************************************
// ok
BOOL CClassMapInfo::Map(IWbemClassObject *pObj)
{
    int                 nIndex = 0;
    IWbemObjectAccess   *pAlias = 0;
    IWbemQualifierSet   *pQSet = 0;
    HRESULT             hRes;
    VARIANT             vPropertyCount;
    VARIANT             vClsName;    
    VARIANT             vPerfObjType;
    VARIANT             vSingleton;
    VARIANT             vCostly;
    VARIANT             vCounter;
    VARIANT             vCounterType;
    CBSTR               cbPerfIndex(cszPerfIndex);
    CBSTR               cbCountertype(cszCountertype);
    CBSTR               cbPropertyCount(cszPropertyCount);
    CBSTR               cbClassName(cszClassName);
    CBSTR               cbSingleton(cszSingleton);
    CBSTR               cbCostly(cszCostly);
    BOOL                bReturn = TRUE;

    VariantInit(&vPropertyCount);
    VariantInit(&vClsName);    
    VariantInit(&vPerfObjType);
    VariantInit(&vSingleton);
    VariantInit(&vCostly);
    VariantInit(&vCounter);
    VariantInit(&vCounterType);

    if( NULL == (BSTR)cbPerfIndex ||
        NULL == (BSTR)cbCountertype ||
        NULL == (BSTR)cbPropertyCount ||
        NULL == (BSTR)cbClassName ||
        NULL == (BSTR)cbSingleton ||
        NULL == (BSTR)cbCostly ){

        return FALSE;
    }
        

    // Copy the class definition.
    // ==========================
        
    m_pClassDef = pObj;
    //m_pClassDef->AddRef(); // this is unnecessary

    m_lRefCount++;  // bump our ref count
    
    // Get the alternate interface so that we can look up handles.
    // ===========================================================
    hRes = pObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pAlias);
    if (hRes) {
        bReturn = FALSE;
    }

    // Determine the number of properties and allocate
    // arrays to hold the handles, perf ids, and types.
    // ================================================
    if (bReturn) {
        hRes = pObj->Get( cbPropertyCount, 0, &vPropertyCount, 0, 0);
        if (hRes == NO_ERROR) {
            m_dwNumProps = DWORD(V_UI4(&vPropertyCount));
        } else {
            bReturn = FALSE;
        }
        VariantClear(&vPropertyCount);
    }

    // allocate the table of the handles and id's
    if (bReturn) {
        m_pdwHandles = new DWORD[m_dwNumProps];
        assert (m_pdwHandles != NULL);
        m_pdwIDs = new PerfObjectId[m_dwNumProps];
        assert (m_pdwIDs != NULL);
        m_pdwTypes = new DWORD[m_dwNumProps];
        assert (m_pdwTypes != NULL);

        // check the memory allocations
        if ((m_pdwHandles == NULL) ||
            (m_pdwIDs == NULL) ||
            (m_pdwTypes == NULL)) {
            bReturn = FALSE;
        }
    }    
    // Clone the class name.
    // =====================
    if (bReturn) {
        hRes = pObj->Get( cbClassName, 0, &vClsName, 0, 0);
        if ((hRes == NO_ERROR) && (vClsName.vt == VT_BSTR)) {
            m_pszClassName = Macro_CloneLPWSTR(V_BSTR(&vClsName));
            if (m_pszClassName == NULL) bReturn = FALSE;
        } else {
            bReturn = FALSE;
        }
        VariantClear (&vClsName);
    }

    // Get the perf object id for the class.
    // =====================================

    if (bReturn) {
        hRes = pObj->GetQualifierSet(&pQSet);
        if (hRes == NO_ERROR) {
            hRes = pQSet->Get(cbPerfIndex, 0, &vPerfObjType, 0);
            if (hRes == NO_ERROR) {
                m_dwObjectId = DWORD(V_UI4(&vPerfObjType));
            } else {
                bReturn = FALSE;
            }
            VariantClear(&vPerfObjType);

            hRes = pQSet->Get( cbSingleton, 0, &vSingleton, 0);
            if (hRes == 0) {
                m_bSingleton = TRUE;
            }
            VariantClear (&vSingleton);


            hRes = pQSet->Get( cbCostly, 0, &vCostly, 0);
            if ((hRes == 0) && (vCostly.vt == VT_BSTR)) {
                m_bCostly= TRUE;
            }
            VariantClear (&vCostly);

            pQSet->Release();
        } else {
            bReturn = FALSE;
        }
    }
    
    
    // Enumerate all the properties and get the object ids
    // and handles for each.
    // ===================================================
    
    hRes = pObj->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    if (hRes == NO_ERROR) {
        // enumeration handle obtained so 
        // continue and cache each property
    
        while (bReturn) {
            BSTR                Name = 0;
            DWORD               dwCtrId;
            DWORD               dwCtrType;
            IWbemQualifierSet   *pQSet = 0;
            LONG                lType = 0;
            LONG                lHandle = 0;
        
            hRes = pObj->Next(
                0,
                &Name,
                0,
                0,
                0
                );                

            if (hRes == WBEM_S_NO_MORE_DATA) {
                break;
            }

            // Next, get the qualifier set for this property.
            // ==============================================
        
            hRes = pObj->GetPropertyQualifierSet(Name, &pQSet);
            if (hRes == NO_ERROR) {
                hRes = pQSet->Get(cbPerfIndex, 0, &vCounter, 0);
                if (hRes == S_OK) {
                    dwCtrId = (DWORD)V_UI4(&vCounter);    
                } else {
                    // unable to read qualifier value
                    dwCtrId = 0;
                }
                VariantClear (&vCounter);

                hRes = pQSet->Get(cbCountertype, 0, &vCounterType, 0);
                if (hRes == S_OK) {
                    dwCtrType = (DWORD)V_UI4(&vCounterType);
                } else {
                    // unable to read qualifier value
                    dwCtrType = 0;
                }
                VariantClear (&vCounterType);

                // done with the qualifier set
                pQSet->Release();

                // Get the property handle and type.
                // =================================
                hRes = pAlias->GetPropertyHandle(Name, &lType, &lHandle);

                if (hRes == NO_ERROR && nIndex < (int)m_dwNumProps ) {
                    // We now know the counter id, the property handle and its
                    // type.  That is all we really need at runtime to map
                    // blobs into CIM object.
                    // =======================================================
                    m_pdwIDs[nIndex] = CM_MAKE_PerfObjectId (dwCtrId, dwCtrType);
                    m_pdwHandles[nIndex] = (DWORD) lHandle;
                    m_pdwTypes[nIndex] = (DWORD) lType;

                    // this property was loaded successfully so 
                    // advance to the next index 
                    nIndex++;
                } else {
                    // no property handle returned so skip it.
                }
            } else {
                // skip this object since it doesn't have
                // a qualifier set
            }

            // Free the name.
            // ==============        
            SysFreeString(Name);    

        }    

        pObj->EndEnumeration();
    } else {
        // unable to get enumeration handle
        bReturn = FALSE;
    }

    // Get the handle of the 'name' property.
    // ======================================
    if (bReturn) {
        if (!m_bSingleton) {
            // only non-singleton classes have this property
            pAlias->GetPropertyHandle((LPWSTR)cszName, 0, (LONG *) &m_dwNameHandle);
        } 

        // Get the handle of the "timestamp" properties
        pAlias->GetPropertyHandle((LPWSTR)cszTimestampPerfTime, 0, (LONG *) &m_dwPerfTimeStampHandle);
        pAlias->GetPropertyHandle((LPWSTR)cszFrequencyPerfTime, 0, (LONG *) &m_dwPerfFrequencyHandle);
        pAlias->GetPropertyHandle((LPWSTR)cszTimestampSys100Ns, 0, (LONG *) &m_dw100NsTimeStampHandle);
        pAlias->GetPropertyHandle((LPWSTR)cszFrequencySys100Ns, 0, (LONG *) &m_dw100NsFrequencyHandle);
        pAlias->GetPropertyHandle((LPWSTR)cszTimestampObject,   0, (LONG *) &m_dwObjectTimeStampHandle);
        pAlias->GetPropertyHandle((LPWSTR)cszFrequencyObject,   0, (LONG *) &m_dwObjectFrequencyHandle);

        // Cleanup.
        // ========

        SortHandles();
    }
    
    if (pAlias != NULL) pAlias->Release();
    
    return bReturn;
}

//***************************************************************************
//
//  CClassMapInfo::SortHandles
//
//  Sort the perf object ids for quick searching later in the GetPropHandle
//  method.
//
//***************************************************************************
// ok
void CClassMapInfo::SortHandles()
{
    DWORD           dwOuter;
    DWORD           dwInner;
    DWORD           dwTemp;
    PerfObjectId    poiTemp;


    // Simple selection sort.  The number of elements is so small
    // and this is only done once, so a quicksort / shellsort would be
    // overkill.
    // ===============================================================

    for (dwOuter = 0; dwOuter < m_dwNumProps - 1; dwOuter++)
    {
        for (dwInner = dwOuter + 1; dwInner < m_dwNumProps; dwInner++)
        {
            if (m_pdwIDs[dwInner] < m_pdwIDs[dwOuter])
            {
                poiTemp = m_pdwIDs[dwInner];
                m_pdwIDs[dwInner] = m_pdwIDs[dwOuter];
                m_pdwIDs[dwOuter] = poiTemp;

                dwTemp = m_pdwHandles[dwInner];
                m_pdwHandles[dwInner] = m_pdwHandles[dwOuter];
                m_pdwHandles[dwOuter] = dwTemp;

                dwTemp = m_pdwTypes[dwInner];
                m_pdwTypes[dwInner] = m_pdwTypes[dwOuter];
                m_pdwTypes[dwOuter] = dwTemp;
            }
        }
    }
}

//***************************************************************************
//
//  CClassMapInfo::GetPropHandle
//
//  Gets the property handle for a corresponding perf counter id.
//  Returns 0 if not found.
//
//***************************************************************************
// ok
LONG CClassMapInfo::GetPropHandle(PerfObjectId dwId)
{
    // Binary search.
    // ==============

    LONG    l;
    LONG    u;
    LONG    m;
    LONG    lReturn = 0;

    if (m_dwNumProps > 0) {
        l = 0;
        u = m_dwNumProps - 1;
        while (l <= u)
        {
            m = (l + u) / 2;

            if (dwId < m_pdwIDs[m]) {
                u = m - 1;
            } else if (dwId > m_pdwIDs[m]) {
                l = m + 1;
            } else {   // Hit!
                lReturn = m_pdwHandles[m];
                break;
            }
        }
    } else {
        // no entries so return 0;
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\perfmon5\perfmon5.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    perfmon5.h

Abstract:

    <abstract>

--*/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <windows.h>
#include <winperf.h>
#include <pdh.h>
#include <pdhmsg.h>

#define FileSeekBegin(hFile, lAmtToMove) SetFilePointer(hFile, lAmtToMove, NULL, FILE_BEGIN)

// these defintions are copied from the NT4 perfmon.exe source files

typedef struct OPTIONSSTRUCT
{  
    BOOL  bMenubar;
    BOOL  bToolbar;
    BOOL  bStatusbar;
    BOOL  bAlwaysOnTop;
} OPTIONS ;

//======================================//
// DISKLINE data type                   //
//======================================//

#define dwLineSignature    (MAKELONG ('L', 'i'))

typedef struct DISKSTRINGSTRUCT
{  
    DWORD  dwLength;
    DWORD  dwOffset;
} DISKSTRING, * PDISKSTRING;

typedef struct _TIMELINESTRUCT
{
     INT  ppd;                           // Pixels Per DataPoint
     INT  rppd;                          // Remaining Pixels Per DataPoint
     INT  xLastTime;                     // X coordinate of last time line.
     INT  iValidValues;                  // High water mark for valid data.
}TIMELINESTRUCT;

#define LineTypeChart            1
#define LineTypeAlert            2
#define LineTypeReport           3

typedef struct LINEVISUALSTRUCT
{
    COLORREF  crColor;
    int       iColorIndex;    
    int       iStyle;
    int       iStyleIndex;
    int       iWidth;
    int       iWidthIndex;
} LINEVISUAL, * PLINEVISUAL;

typedef struct DISKLINESTRUCT
{
    int         iLineType;
    DISKSTRING  dsSystemName;
    DISKSTRING  dsObjectName;
    DISKSTRING  dsCounterName;
    DISKSTRING  dsInstanceName;
    DISKSTRING  dsPINName;
    DISKSTRING  dsParentObjName;
    DWORD       dwUniqueID;
    LINEVISUAL  Visual;
    int         iScaleIndex;
    FLOAT       eScale;
    BOOL        bAlertOver;
    FLOAT       eAlertValue;
    DISKSTRING  dsAlertProgram;
    BOOL        bEveryTime;
} DISKLINE, * PDISKLINE;

#define PerfSignatureLen  20

#define szPerfChartSignature     ((LPCWSTR) L"PERF CHART")
#define szPerfAlertSignature     ((LPCWSTR) L"PERF ALERT")
#define szPerfLogSignature       ((LPCWSTR) L"PERF LOG")
#define szPerfReportSignature    ((LPCWSTR) L"PERF REPORT")
#define szPerfWorkspaceSignature ((LPCWSTR) L"PERF WORKSPACE")

#define LINE_GRAPH  1
#define BAR_GRAPH   2
#define PMC_FILE    1
#define PMA_FILE    2
#define PML_FILE    3
#define PMR_FILE    4
#define PMW_FILE    5

#define AlertMajorVersion    1

// minor version 2 to support Alert msg name
// minor version 3 to support alert, report, log intervals in msec
// minor version 4 to support alert event logging
// minor version 6 to support alert misc options

#define AlertMinorVersion    6

typedef struct DISKALERTSTRUCT
{
    LINEVISUAL  Visual;
    DWORD       dwNumLines;
    DWORD       dwIntervalSecs;
    BOOL        bManualRefresh;
    BOOL        bSwitchToAlert;
    BOOL        bNetworkAlert;
    WCHAR       MessageName[16];
    OPTIONS     perfmonOptions;
    DWORD       MiscOptions;
} DISKALERT;

typedef struct PERFFILEHEADERSTRUCT
{  // PERFFILEHEADER
    WCHAR  szSignature[PerfSignatureLen];
    DWORD  dwMajorVersion;
    DWORD  dwMinorVersion;
    BYTE   abyUnused[100];
} PERFFILEHEADER;

// minor version 3 to support alert, report, log intervals in msec
#define ChartMajorVersion    1
#define ChartMinorVersion    3

typedef struct _graph_options {
    BOOL    bLegendChecked;
    BOOL    bMenuChecked;
    BOOL    bLabelsChecked;
    BOOL    bVertGridChecked;
    BOOL    bHorzGridChecked;
    BOOL    bStatusBarChecked;
    INT     iVertMax;
    FLOAT   eTimeInterval;
    INT     iGraphOrHistogram;
    INT     GraphVGrid,
            GraphHGrid,
            HistVGrid,
            HistHGrid;
} GRAPH_OPTIONS;

#define MAX_SYSTEM_NAME_LENGTH  128
#define PerfObjectLen               80

typedef struct DISKCHARTSTRUCT
{
    DWORD          dwNumLines;
    INT            gMaxValues;
    LINEVISUAL     Visual;
    GRAPH_OPTIONS  gOptions;
    BOOL           bManualRefresh;
    OPTIONS        perfmonOptions;
} DISKCHART;

// minor version 3 to support alert, report, log intervals in msec
#define ReportMajorVersion    1
#define ReportMinorVersion    3

typedef struct DISKREPORTSTRUCT
{
    LINEVISUAL  Visual;
    DWORD       dwNumLines;
    DWORD       dwIntervalSecs;
    BOOL        bManualRefresh;
    OPTIONS     perfmonOptions;
} DISKREPORT;

//=====================================//
// Log File Counter Name data type     //
//=====================================//


// minor version 3 to support alert, report, log intervals in msec
// minor version 5 to support storing Log file name in setting
//  and start logging after reading the file.
#define LogMajorVersion    1
#define LogMinorVersion    5


typedef struct DISKLOGSTRUCT
{
    DWORD    dwNumLines;
    DWORD    dwIntervalSecs;
    BOOL     bManualRefresh;
    OPTIONS  perfmonOptions;
    WCHAR    LogFileName[260];
} DISKLOG;

typedef struct _LOGENTRYSTRUCT
{
    DWORD                     ObjectTitleIndex;
    WCHAR                     szComputer[MAX_SYSTEM_NAME_LENGTH + 1];
    WCHAR                     szObject[PerfObjectLen + 1];
    BOOL                      bSaveCurrentName;
    struct  _LOGENTRYSTRUCT * pNextLogEntry;
} LOGENTRY, * PLOGENTRY;

#define WorkspaceMajorVersion    1

// minor version 1 to support window placement data
// minor version 2 to support alert msg name
// minor version 3 to support alert, report, log intervals in msec
// minor version 4 to support alert eventlog
// minor version 5 to support log file name in log setting
// minor version 6 to support alert misc options
#define WorkspaceMinorVersion    6

typedef struct DISKWORKSPACESTRUCT
{
    INT              iPerfmonView;
    DWORD            ChartOffset;
    DWORD            AlertOffset;
    DWORD            LogOffset;
    DWORD            ReportOffset;
    WINDOWPLACEMENT  WindowPlacement;   
} DISKWORKSPACE;

WCHAR LOCAL_SYS_CODE_NAME[] = {L"...."};
#define  sizeofCodeName sizeof(LOCAL_SYS_CODE_NAME) / sizeof(WCHAR) - 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\classmap.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    classmap.h

Abstract:

    the perfobject ID is combination of the perf counter ID and 
    the perf counter type. This is necessary to support counter
    definitions that use the counter ID for the numerator and denominator
    values (e.g. a counter and it's base value.)

--*/

//***************************************************************************
//
//  class CClassMapInfo
//
//***************************************************************************

#ifndef _CLASSMAP_H_
#define _CLASSMAP_H_

#include "utils.h"

typedef __int64 PerfObjectId;

#define CM_MAKE_PerfObjectId(ctr,type)  (PerfObjectId)(((__int64)(ctr)) | (((__int64)type << 32) & 0xFFFFFFFF00000000))

class CClassMapInfo
{
private:
    // friend clss declarations
    friend class CNt5PerfProvider;
    friend class CNt5Refresher;
    friend class PerfHelper;
    friend class CPerfObjectAccess; 

    // cached class definition object from CIMOM
    IWbemClassObject    *m_pClassDef;
    
    LPWSTR m_pszClassName;      // name of this class
    BOOL   m_bSingleton;        // true if this class has 1 and only 1 instance
    BOOL   m_bCostly;           // true when the costly qualifier is present in the obj def
    DWORD  m_dwObjectId;        // perf object ID corresponding to this class

    LONG   m_lRefCount;         // count of objects that are using this instance

    // saved handles to properties that are in every class of a 
    // performance class object
    LONG   m_dwNameHandle;
    LONG   m_dwPerfTimeStampHandle;
    LONG   m_dw100NsTimeStampHandle;
    LONG   m_dwObjectTimeStampHandle;
    LONG   m_dwPerfFrequencyHandle;
    LONG   m_dw100NsFrequencyHandle;
    LONG   m_dwObjectFrequencyHandle;

    // These entries make up the table of saved handles to the properties
    // belonging to this class.
    DWORD  m_dwNumProps;        // number of properties in the class
    PerfObjectId *m_pdwIDs;     // array of PerfCounterTitleIndex values 
    DWORD *m_pdwHandles;        // array of handles to each of the properties
    DWORD *m_pdwTypes;          // array of perf counter type values

    // internal sort function to arrange handles in order of the
    // perf counter ID so as to facilitate a binary table search 
    //
    // NOTE: Consider a better search routine base on table size
    void SortHandles();
            
public:
    CClassMapInfo();
   ~CClassMapInfo();
   
    // loads a new object and caches the necessary information
    BOOL Map( IWbemClassObject *pObj );
    // creates a new copy from an existing Class Map
    CClassMapInfo *CreateDuplicate();

    LONG    AddRef() {return ++m_lRefCount;}   // increment reference counter
    LONG    Release() {return --m_lRefCount;}   // decrement reference counter

    // looks up the ID in the table and returns the corresponding
    // handle to the property
    LONG GetPropHandle(PerfObjectId dwId);
    
    // returns information about the class
    DWORD GetObjectId() { return m_dwObjectId; }
    BOOL IsSingleton() { return m_bSingleton; }
    BOOL IsCostly() { return m_bCostly; }
};

#endif  // _CLASSMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhwmi\wbem.cpp ===
/*++
Copyright (C) 1995-1999 Microsoft Corporation

Module Name:
    wmi.c

Abstract:
    WMI interface functions exported by PDH.DLL
--*/

#include <windows.h>
#include <winperf.h>
#define SECURITY_WIN32
#include "security.h"
#include "ntsecapi.h"
#include <mbctype.h>
#include "strsafe.h"
#include <pdh.h>
#include <pdhmsg.h>
#include "wbemdef.h"
#include "pdhitype.h"
#include "pdhidef.h"
#include "strings.h"

#define PERF_TIMER_FIELD (PERF_TIMER_TICK | PERF_TIMER_100NS | PERF_OBJECT_TIMER)
#define PDH_WMI_STR_SIZE 1024

__inline 
VOID
PdhiSysFreeString( 
    BSTR * x
) 
{
    if (x != NULL) {
        if (* x != NULL) {
            if (SysStringLen(* x) > 0) {
                SysFreeString(* x);
            }
            * x = NULL;
        }
    }
}

void
PdhWbemWhoAmI(LPCWSTR szTitle)
{
    BOOL  bReturn;
    ULONG dwSize;
    WCHAR wszName[1024];

    dwSize = 1024;
    ZeroMemory(wszName, dwSize * sizeof(WCHAR));
    bReturn = GetUserNameExW(NameSamCompatible, wszName, & dwSize);
    DebugPrint((1,"\"%ws\"::GetUserNameEx(%c,NameSamCompatible,%d,\"%ws\")\n",
            szTitle, bReturn ? 'T' : 'F', dwSize, wszName));
}

// at this point, calling the refresher while adding items to the refresher
// doesn't work. so for the time being, we'll use this interlock to prevent
// a collision
static BOOL bDontRefresh = FALSE;

// Prototype
HRESULT WbemSetProxyBlanket(
    IUnknown                 * pInterface,
    DWORD                      dwAuthnSvc,
    DWORD                      dwAuthzSvc,
    OLECHAR                  * pServerPrincName,
    DWORD                      dwAuthLevel,
    DWORD                      dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE   pAuthInfo,
    DWORD                      dwCapabilities
);

HRESULT SetWbemSecurity(
    IUnknown * pInterface
)
{
    return WbemSetProxyBlanket(pInterface,
                               RPC_C_AUTHN_WINNT,
                               RPC_C_AUTHZ_NONE,
                               NULL,
                               RPC_C_AUTHN_LEVEL_DEFAULT,
                               RPC_C_IMP_LEVEL_IMPERSONATE,
                               NULL,
                               EOAC_DYNAMIC_CLOAKING);
}


// This is the same timeout value the refresher uses so we can pretend
// we're doing the same thing.

#define WBEM_REFRESHER_TIMEOUT  10000

//  This class is designed to encapsulate the IWbemRefresher functionality
//  The definition and implementation are all in this source file

class CWbemRefresher : public IUnknown
{
protected:
    LONG                        m_lRefCount;

    // The primitives that will control the multithreading stuff
    HANDLE                      m_hQuitEvent;
    HANDLE                      m_hDoWorkEvent;
    HANDLE                      m_hWorkDoneEvent;
    HANDLE                      m_hRefrMutex;
    HANDLE                      m_hInitializedEvent;
    HANDLE                      m_hThread;
    HANDLE                      m_hThreadToken;
    DWORD                       m_dwThreadId;
    BOOL                        m_fThreadOk;

    // These are the pass-thru variables we will use as placeholders
    // as we perform our operations.  Note that a couple are missing.
    // This is because we are not really using them in our code, so
    // no sense in adding anything we don't really need.

    IStream *            m_pNSStream;
    LPCWSTR              m_wszPath;
    LPCWSTR              m_wszClassName;
    long                 m_lFlags;
    IWbemClassObject **  m_ppRefreshable;
    IWbemHiPerfEnum **   m_ppEnum;
    long *               m_plId;
    long                 m_lId;
    HRESULT              m_hOperResult;

    // This is what will be set to indicate to the thread which operation
    // it is supposed to perform.

    typedef enum
    {
        eRefrOpNone,
        eRefrOpRefresh,
        eRefrOpAddByPath,
        eRefrOpAddEnum,
        eRefrOpRemove,
        eRefrOpLast
    }   tRefrOps;

    tRefrOps            m_eRefrOp;

    // Thread ebtryt
    class XRefresher : public IWbemRefresher
    {
    protected:
        CWbemRefresher* m_pOuter;

    public:
        XRefresher(CWbemRefresher * pOuter) : m_pOuter(pOuter) {};
        ~XRefresher() {};

        STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG, AddRef)(THIS);
        STDMETHOD_(ULONG, Release)(THIS);
        STDMETHOD(Refresh)(long lFlags);

    } m_xRefresher;

    class XConfigRefresher : public IWbemConfigureRefresher
    {
    protected:
        CWbemRefresher * m_pOuter;

    public:
        XConfigRefresher(CWbemRefresher * pOuter) : m_pOuter(pOuter) {};
        ~XConfigRefresher() {};

        STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj);
        STDMETHOD_(ULONG, AddRef)(THIS);
        STDMETHOD_(ULONG, Release)(THIS);
        STDMETHOD(AddObjectByPath)(IWbemServices     * pNamespace,
                                   LPCWSTR             wszPath,
                                   long                lFlags,
                                   IWbemContext      * pContext,
                                   IWbemClassObject ** ppRefreshable,
                                   long              * plId);
        STDMETHOD(AddObjectByTemplate)(IWbemServices     * pNamespace,
                                       IWbemClassObject  * pTemplate,
                                       long                lFlags,
                                       IWbemContext      * pContext,
                                       IWbemClassObject ** ppRefreshable,
                                       long              * plId);
        STDMETHOD(AddRefresher)(IWbemRefresher * pRefresher, long lFlags, long * plId);
        STDMETHOD(Remove)(long lId, long lFlags);

        STDMETHOD(AddEnum)(IWbemServices    * pNamespace,
                           LPCWSTR            wscClassName,
                           long               lFlags,
                           IWbemContext     * pContext,
                           IWbemHiPerfEnum ** ppEnum,
                           long             * plId);
    } m_xConfigRefresher;

protected:
    void Initialize(void);
    void  Cleanup(void);

    // Operation helpers
    HRESULT SignalRefresher(void);
    HRESULT SetRefresherParams(IWbemServices     * pNamespace,
                               tRefrOps            eOp,
                               LPCWSTR             pwszPath,
                               LPCWSTR             pwszClassName,
                               long                lFlags,
                               IWbemClassObject ** ppRefreshable,
                               IWbemHiPerfEnum  ** ppEnum,
                               long              * plId,
                               long                lId);
    void ClearRefresherParams(void);

    DWORD WINAPI RealEntry(void);

    static DWORD WINAPI ThreadProc(void * pThis) {
        return ((CWbemRefresher *) pThis)->RealEntry();
    }

public:
    CWbemRefresher();
    virtual ~CWbemRefresher();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // The real implementations
    STDMETHOD(AddObjectByPath)(IWbemServices     * pNamespace,
                               LPCWSTR             wszPath,
                               long                lFlags,
                               IWbemContext      * pContext,
                               IWbemClassObject ** ppRefreshable,
                               long              * plId);
    STDMETHOD(AddObjectByTemplate)(IWbemServices     * pNamespace,
                                   IWbemClassObject  * pTemplate,
                                   long                lFlags,
                                   IWbemContext      * pContext,
                                   IWbemClassObject ** ppRefreshable,
                                   long              * plId);
    STDMETHOD(AddRefresher)(IWbemRefresher * pRefresher, long lFlags, long * plId);
    STDMETHOD(Remove)(long lId, long lFlags);
    STDMETHOD(AddEnum)(IWbemServices    * pNamespace,
                       LPCWSTR            wscClassName,
                       long               lFlags,
                       IWbemContext     * pContext,
                       IWbemHiPerfEnum ** ppEnum,
                       long             * plId);
    STDMETHOD(Refresh)(long lFlags);
};

/*
**  Begin CWbemRefresher Implementation
*/
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning(disable:4355)

// CTor and DTor
CWbemRefresher::CWbemRefresher(void)
      : m_lRefCount(0),
        m_xRefresher(this),
        m_xConfigRefresher(this),
        m_hQuitEvent(NULL),
        m_hDoWorkEvent(NULL),
        m_hRefrMutex(NULL),
        m_hInitializedEvent(NULL),
        m_hThread(NULL),
        m_hThreadToken(NULL),
        m_hWorkDoneEvent(NULL),
        m_dwThreadId(0),
        m_pNSStream(NULL),
        m_wszPath(NULL),
        m_wszClassName(NULL),
        m_lFlags(0L),
        m_ppRefreshable(NULL),
        m_ppEnum(NULL),
        m_plId(NULL),
        m_eRefrOp(eRefrOpRefresh),
        m_hOperResult(WBEM_S_NO_ERROR),
        m_fThreadOk(FALSE),
        m_lId(0)
{
    Initialize();
}

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4355)
#endif

CWbemRefresher::~CWbemRefresher(void)
{
    Cleanup();
}

void CWbemRefresher::Initialize(void)
{
    // Now create the events, mutexes and our pal, the MTA thread on which all of
    // the operations will run
    BOOL   bReturn;
    BOOL   bRevert;
    HANDLE hCurrentThread  = GetCurrentThread();

    m_hQuitEvent        = CreateEventW(NULL, FALSE, FALSE, NULL);
    m_hDoWorkEvent      = CreateEventW(NULL, FALSE, FALSE, NULL);
    m_hInitializedEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
    m_hWorkDoneEvent    = CreateEventW(NULL, FALSE, FALSE, NULL);
    m_hRefrMutex        = CreateMutexW(NULL, FALSE, NULL);

    // If we don't have all these, something's gone south
    if (NULL ==  m_hQuitEvent || NULL == m_hDoWorkEvent || NULL == m_hInitializedEvent ||
                                 NULL == m_hWorkDoneEvent || NULL == m_hRefrMutex) {
        return;
    }

    // Kick off the thread and wait for the initialized event signal (we'll give it
    // 5 seconds...if it don't get signalled in that timeframe, something is most likely
    // wrong, but we'll bounce out so whoever allocated us isn't left wondering what
    // to do).

    if (m_hThreadToken != NULL) CloseHandle(m_hThreadToken);
    bReturn = OpenThreadToken(hCurrentThread, TOKEN_ALL_ACCESS, TRUE, & m_hThreadToken);
    bRevert = RevertToSelf();
    m_hThread = CreateThread(NULL, 0, CWbemRefresher::ThreadProc, (void *) this, 0, & m_dwThreadId);
    if (bRevert) {
        bRevert = SetThreadToken(& hCurrentThread, m_hThreadToken);
    }
    if (NULL != m_hThread) {
        DWORD dwStatus;
        dwStatus = WaitForSingleObject(m_hInitializedEvent, 5000);
        if (bReturn) {
            bReturn = SetThreadToken(& m_hThread, m_hThreadToken);
        }
        SetEvent(m_hDoWorkEvent);
        dwStatus = WaitForSingleObject(m_hInitializedEvent, 5000);
    }
}

void CWbemRefresher::Cleanup(void)
{
    // If we have a thread, tell it to go away
    if (NULL != m_hThread) {
        // Signal the quit event and give the thread a 5 second grace period
        // to shutdown.  If it don't, don't worry, just close the handle and go away.
        SetEvent(m_hQuitEvent);
        WaitForSingleObject(m_hThread, 5000);
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }
    if (NULL != m_hThreadToken) {
        CloseHandle(m_hThreadToken);
        m_hThreadToken = NULL;
    }

    // Cleanup the primitives
    if (NULL != m_hQuitEvent) {
        CloseHandle(m_hQuitEvent);
        m_hQuitEvent = NULL;
    }
    if (NULL != m_hDoWorkEvent) {
        CloseHandle(m_hDoWorkEvent);
        m_hDoWorkEvent = NULL;
    }
    if (NULL != m_hInitializedEvent) {
        CloseHandle(m_hInitializedEvent);
        m_hInitializedEvent = NULL;
    }
    if (NULL != m_hWorkDoneEvent) {
        CloseHandle(m_hWorkDoneEvent);
        m_hWorkDoneEvent = NULL;
    }
    if (NULL != m_hRefrMutex) {
        CloseHandle(m_hRefrMutex);
        m_hRefrMutex = NULL;
    }
}

DWORD CWbemRefresher::RealEntry(void)
{
    // Grab hold of all the things we may care about in case some evil timing
    // problem occurs, so we don't get left trying to hit on member variables that
    // don't exist anymore.

    HANDLE                    hQuitEvent        = m_hQuitEvent,
                              hDoWorkEvent      = m_hDoWorkEvent,
                              hInitializedEvent = m_hInitializedEvent,
                              hWorkDoneEvent    = m_hWorkDoneEvent;
    DWORD                     dwWait            = 0;
    HANDLE                    ahEvents[2];
    IWbemRefresher          * pWbemRefresher    = NULL;
    IWbemConfigureRefresher * pWbemConfig       = NULL;
    HRESULT                   hr                = S_OK;

    ahEvents[0] = hDoWorkEvent;
    ahEvents[1] = hQuitEvent;

    // Initialize this thread
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (hr == S_FALSE) {
        // COM library is already initialized, we can continue;
        //
        hr = S_OK;
    }

    // Now get the refresher and config refresher pointers.
    if (SUCCEEDED(hr)) {
        hr = CoCreateInstance(CLSID_WbemRefresher, 0, CLSCTX_SERVER, IID_IWbemRefresher, (LPVOID *) & pWbemRefresher);
        if (SUCCEEDED(hr)) {
            pWbemRefresher->QueryInterface(IID_IWbemConfigureRefresher, (LPVOID *) & pWbemConfig);
        }
    }

    //  Obviously we can't go any further if we don't have our pointers correctly
    //  setup.
    m_fThreadOk = SUCCEEDED(hr);
    SetEvent(hInitializedEvent);
    dwWait = WaitForSingleObject(hDoWorkEvent, 5000);
    // Ready to go --- Signal the Initialized Event
    SetEvent(hInitializedEvent);
    if (m_fThreadOk) {
        while ((dwWait = WaitForMultipleObjects(2, ahEvents, FALSE, INFINITE)) == WAIT_OBJECT_0) {
            // Don't continue if quit is signalled
            if (WaitForSingleObject(hQuitEvent, 0) == WAIT_OBJECT_0) {
                break;
            }

            // This is where we'll do the real operation
            switch(m_eRefrOp) {
            case eRefrOpRefresh:
                m_hOperResult = pWbemRefresher->Refresh(m_lFlags);
                break;

            // For both of these ops, we will need to umarshal the
            // namespace
            case eRefrOpAddEnum:
            case eRefrOpAddByPath:
                {
                    IWbemServices * pNamespace = NULL;

                    // Unmarshal the interface, then set security
                    m_hOperResult = CoGetInterfaceAndReleaseStream(
                                            m_pNSStream, IID_IWbemServices, (void **) & pNamespace );
                    m_pNSStream = NULL;
                    if (SUCCEEDED(m_hOperResult)) {
                        m_hOperResult = SetWbemSecurity(pNamespace);
                        if (SUCCEEDED(m_hOperResult)) {
                            if (eRefrOpAddByPath == m_eRefrOp) {
                                m_hOperResult = pWbemConfig->AddObjectByPath(
                                        pNamespace, m_wszPath, m_lFlags, NULL, m_ppRefreshable, m_plId );
                            }
                            else {
                                m_hOperResult = pWbemConfig->AddEnum(
                                        pNamespace, m_wszClassName, m_lFlags, NULL, m_ppEnum, m_plId );
                            }
                        }
                        pNamespace->Release();
                    }
                }
                break;

            case eRefrOpRemove:
                m_hOperResult = pWbemConfig->Remove(m_lId, m_lFlags);
                break;

            default:
                m_hOperResult = WBEM_E_FAILED;
                break;
            }

            // Signal the event to let a waiting thread know we're done doing
            // what it asked us to do.
            SetEvent(hWorkDoneEvent);
        }
    }

    // This means we're not processing anymore (for whatever reason)
    m_fThreadOk = FALSE;

    // Cleanup our pointers
    if (NULL != pWbemRefresher) {
        pWbemRefresher->Release();
    }
    if (NULL != pWbemConfig) {
        pWbemConfig->Release();
    }
    CoUninitialize();
    return 0;
}

// CWbemRefresher class functions
SCODE CWbemRefresher::QueryInterface(REFIID riid, LPVOID FAR * ppvObj)
{
    SCODE sCode = NOERROR;

    * ppvObj = 0;

    if (IID_IUnknown==riid) {
        * ppvObj = (IUnknown *) this;
        AddRef();
    }
    else if (IID_IWbemRefresher == riid) {
        * ppvObj = (IWbemRefresher *) & m_xRefresher;
        AddRef();
    }
    else if (IID_IWbemConfigureRefresher == riid) {
        * ppvObj = (IWbemConfigureRefresher *) & m_xConfigRefresher;
        AddRef();
    }
    else {
        sCode = ResultFromScode(E_NOINTERFACE);
    }
    return sCode;
}

ULONG CWbemRefresher::AddRef()
{
    return InterlockedIncrement(& m_lRefCount);
}

ULONG CWbemRefresher::Release()
{
    long lRef = InterlockedDecrement(& m_lRefCount);

    if (lRef == 0) {
        delete this;
    }
    return lRef;
}

HRESULT CWbemRefresher::SignalRefresher(void)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (SetEvent(m_hDoWorkEvent)) {
        if (WaitForSingleObject(m_hWorkDoneEvent, INFINITE) == WAIT_OBJECT_0) {
            hr = m_hOperResult;
        }
        else {
            hr = WBEM_E_FAILED;
        }
    }
    else {
        hr = WBEM_E_FAILED;
    }
    ClearRefresherParams();
    return hr;
}

HRESULT CWbemRefresher::SetRefresherParams(IWbemServices     * pNamespace,
                                           tRefrOps            eOp,
                                           LPCWSTR             pwszPath,
                                           LPCWSTR             pwszClassName,
                                           long                lFlags,
                                           IWbemClassObject ** ppRefreshable,
                                           IWbemHiPerfEnum  ** ppEnum,
                                           long              * plId,
                                           long                lId
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (m_pNSStream != NULL) {
        LPVOID pInterface = NULL;
        CoGetInterfaceAndReleaseStream(m_pNSStream, IID_IWbemServices, & pInterface);
        m_pNSStream     = NULL;
    }
    if (NULL != pNamespace) {
        // Marshal the namespace pointer into the stream member
        hr = CoMarshalInterThreadInterfaceInStream(IID_IWbemServices, pNamespace, & m_pNSStream);
    }

    if (SUCCEEDED(hr)) {
        m_eRefrOp       = eOp;
        m_wszPath       = pwszPath;
        m_wszClassName  = pwszClassName,
        m_lFlags        = lFlags;
        m_ppRefreshable = ppRefreshable;
        m_ppEnum        = ppEnum;
        m_plId          = plId;
        m_lId           = lId;
    }
    return hr;
}

void CWbemRefresher::ClearRefresherParams(void)
{
    if (m_pNSStream != NULL) {
        LPVOID pInterface = NULL;
        CoGetInterfaceAndReleaseStream(m_pNSStream, IID_IWbemServices, & pInterface);
        m_pNSStream     = NULL;
    }
    m_eRefrOp       = eRefrOpNone;
    m_wszPath       = NULL;
    m_wszClassName  = NULL,
    m_lFlags        = 0L;
    m_ppRefreshable = NULL;
    m_ppEnum        = NULL;
    m_plId          = NULL;
    m_lId           = 0L;
    m_hOperResult   = WBEM_S_NO_ERROR;
}

// These are the real method implementations
STDMETHODIMP CWbemRefresher::AddObjectByPath(IWbemServices     * pNamespace,
                                             LPCWSTR             wszPath,
                                             long                lFlags,
                                             IWbemContext      * pContext,
                                             IWbemClassObject ** ppRefreshable,
                                             long              * plId
)
{
    HRESULT hr = WBEM_E_FAILED;

    UNREFERENCED_PARAMETER(pContext);

    if (WaitForSingleObject(m_hRefrMutex, WBEM_REFRESHER_TIMEOUT) == WAIT_OBJECT_0) {
        // Check that the thread is still running
        if (m_fThreadOk) {
            // Setup the parameters and perform the operation
            hr = SetRefresherParams(pNamespace, eRefrOpAddByPath, wszPath, NULL, lFlags, ppRefreshable, NULL, plId, 0L);
            if (SUCCEEDED(hr)) {
                // This is where we ask the thread to do the work
                hr = SignalRefresher();
            }
        }
        else {
            hr = WBEM_E_FAILED;
        }
        ReleaseMutex(m_hRefrMutex);
    }
    else {
        hr = WBEM_E_REFRESHER_BUSY;
    }
    return hr;
}

STDMETHODIMP CWbemRefresher::AddObjectByTemplate(IWbemServices     * pNamespace,
                                                 IWbemClassObject  * pTemplate,
                                                 long                lFlags,
                                                 IWbemContext      * pContext,
                                                 IWbemClassObject ** ppRefreshable,
                                                 long              * plId
)
{
    UNREFERENCED_PARAMETER(pNamespace);
    UNREFERENCED_PARAMETER(pTemplate);
    UNREFERENCED_PARAMETER(lFlags);
    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(ppRefreshable);
    UNREFERENCED_PARAMETER(plId);

    // We don't call this internally, so don't implement
    return WBEM_E_METHOD_NOT_IMPLEMENTED;
}

STDMETHODIMP CWbemRefresher::Remove(long lId, long lFlags)
{
    HRESULT hr = WBEM_E_FAILED;

    UNREFERENCED_PARAMETER(lId);
    UNREFERENCED_PARAMETER(lFlags);

    if (WaitForSingleObject(m_hRefrMutex, WBEM_REFRESHER_TIMEOUT) == WAIT_OBJECT_0) {
        // Check that the thread is still running
        if (m_fThreadOk) {
            // Setup the parameters and perform the operation
            hr = SetRefresherParams(NULL, eRefrOpRemove, NULL, NULL, lFlags, NULL, NULL, NULL, lId);

            if (SUCCEEDED(hr)) {
                // This is where we ask the thread to do the work
                hr = SignalRefresher();
            }
        }
        else {
            hr = WBEM_E_FAILED;
        }
        ReleaseMutex(m_hRefrMutex);
    }
    else {
        hr = WBEM_E_REFRESHER_BUSY;
    }
    return hr;
}

STDMETHODIMP CWbemRefresher::AddRefresher(IWbemRefresher * pRefresher, long lFlags, long * plId)
{
    UNREFERENCED_PARAMETER(lFlags);
    UNREFERENCED_PARAMETER(pRefresher);
    UNREFERENCED_PARAMETER(plId);
    // We don't call this internally, so don't implement
    return WBEM_E_METHOD_NOT_IMPLEMENTED;
}

HRESULT CWbemRefresher::AddEnum(IWbemServices    * pNamespace,
                                LPCWSTR            wszClassName,
                                long               lFlags,
                                IWbemContext     * pContext,
                                IWbemHiPerfEnum ** ppEnum,
                                long             * plId
)
{
    HRESULT hr = WBEM_E_FAILED;

    UNREFERENCED_PARAMETER (pContext);
    if (WaitForSingleObject(m_hRefrMutex, WBEM_REFRESHER_TIMEOUT) == WAIT_OBJECT_0) {
        // Check that the thread is still running
        if (m_fThreadOk) {
            // Setup the parameters and perform the operation
            hr = SetRefresherParams(pNamespace, eRefrOpAddEnum, NULL, wszClassName, lFlags, NULL, ppEnum, plId, 0L);
            if (SUCCEEDED(hr)) {
                // This is where we ask the thread to do the work
                hr = SignalRefresher();
            }
        }
        else {
            hr = WBEM_E_FAILED;
        }
        ReleaseMutex(m_hRefrMutex);
    }
    else {
        hr = WBEM_E_REFRESHER_BUSY;
    }
    return hr;
}

STDMETHODIMP CWbemRefresher::Refresh(long lFlags)
{
    HRESULT hr = WBEM_E_FAILED;

    if (WaitForSingleObject(m_hRefrMutex, WBEM_REFRESHER_TIMEOUT) == WAIT_OBJECT_0) {
        // Check that the thread is still running
        if (m_fThreadOk) {
            // Setup the parameters and perform the operation
            hr = SetRefresherParams(NULL, eRefrOpRefresh, NULL, NULL, lFlags, NULL, NULL, NULL, 0L);
            if (SUCCEEDED(hr)) {
                // This is where we ask the thread to do the work
                hr = SignalRefresher();
            }
        }
        else {
            hr = WBEM_E_FAILED;
        }
        ReleaseMutex(m_hRefrMutex);
    }
    else {
        hr = WBEM_E_REFRESHER_BUSY;
    }
    return hr;
}

// XRefresher
SCODE CWbemRefresher::XRefresher::QueryInterface(REFIID riid, LPVOID FAR * ppvObj)
{
    return m_pOuter->QueryInterface(riid, ppvObj);
}

ULONG CWbemRefresher::XRefresher::AddRef()
{
    return m_pOuter->AddRef();
}

ULONG CWbemRefresher::XRefresher::Release()
{
    return m_pOuter->Release();
}

STDMETHODIMP CWbemRefresher::XRefresher::Refresh(long lFlags)
{
    // Pass through
    return m_pOuter->Refresh(lFlags);
}

// XConfigRefresher
SCODE CWbemRefresher::XConfigRefresher::QueryInterface(REFIID riid, LPVOID FAR * ppvObj)
{
    return m_pOuter->QueryInterface(riid, ppvObj);
}

ULONG CWbemRefresher::XConfigRefresher::AddRef()
{
    return m_pOuter->AddRef();
}

ULONG CWbemRefresher::XConfigRefresher::Release()
{
    return m_pOuter->Release();
}

STDMETHODIMP CWbemRefresher::XConfigRefresher::AddObjectByPath(IWbemServices     * pNamespace,
                                                               LPCWSTR             wszPath,
                                                               long                lFlags,
                                                               IWbemContext      * pContext,
                                                               IWbemClassObject ** ppRefreshable,
                                                               long              * plId
)
{
    // Pass through
    return m_pOuter->AddObjectByPath(pNamespace, wszPath, lFlags, pContext, ppRefreshable, plId);
}

STDMETHODIMP CWbemRefresher::XConfigRefresher::AddObjectByTemplate(IWbemServices     * pNamespace,
                                                                   IWbemClassObject  * pTemplate,
                                                                   long                lFlags,
                                                                   IWbemContext      * pContext,
                                                                   IWbemClassObject ** ppRefreshable,
                                                                   long              * plId
)
{
    // Pass through
    return m_pOuter->AddObjectByTemplate(pNamespace, pTemplate, lFlags, pContext, ppRefreshable, plId);
}

STDMETHODIMP CWbemRefresher::XConfigRefresher::Remove(long lId, long lFlags)
{
    return m_pOuter->Remove(lId, lFlags);
}

STDMETHODIMP CWbemRefresher::XConfigRefresher::AddRefresher(IWbemRefresher * pRefresher, long lFlags, long * plId)
{
    return m_pOuter->AddRefresher(pRefresher, lFlags, plId);
}

HRESULT CWbemRefresher::XConfigRefresher::AddEnum(IWbemServices    * pNamespace,
                                                  LPCWSTR            wszClassName,
                                                  long               lFlags,
                                                  IWbemContext     * pContext, 
                                                  IWbemHiPerfEnum ** ppEnum,
                                                  long             * plId
)
{
    return m_pOuter->AddEnum(pNamespace, wszClassName, lFlags, pContext, ppEnum, plId);
}

/*
**  End CWbemRefresher Implementation!
*/

// HELPER Function to establish the CWbemRefresher Interface pass-thru
HRESULT CoCreateRefresher(
    IWbemRefresher ** ppRefresher
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Allocate the pass-thru object then, if successful, get
    // the interface pointer out of it
    CWbemRefresher * pWbemRefresher = new CWbemRefresher;

    if (NULL != pWbemRefresher) {
        hr = pWbemRefresher->QueryInterface(IID_IWbemRefresher, (LPVOID *) ppRefresher);
    }
    else {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    return hr;
}

PPDHI_WBEM_SERVER_DEF   pFirstWbemServer = NULL;
BOOL                    bSecurityInitialized = FALSE;
IGlobalInterfaceTable * gp_GIT = NULL;

BOOL PdhiCoInitialize(void)
{
    HRESULT sc = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (! bSecurityInitialized) {
        // In case it hasn't been
        HRESULT hr = CoInitializeSecurity(NULL,        // Points to security descriptor
                                          -1L,         // Count of entries in asAuthSvc -1 means use default
                                          NULL,        // Array of names to register
                                          NULL,        // Reserved for future use
                                          RPC_C_AUTHN_LEVEL_DEFAULT,    // The default authentication level for proxies
                                          RPC_C_IMP_LEVEL_IMPERSONATE,  // The default impersonation level for proxies
                                          NULL,        // Authentication information for each authentication service
                                          EOAC_NONE,   // Additional client and/or server-side capabilities
                                          NULL);       // Reserved for future use
        bSecurityInitialized = (hr == S_OK || hr == RPC_E_TOO_LATE);
    }
    if (gp_GIT == NULL) {
        HRESULT hr1 = CoCreateInstance(CLSID_StdGlobalInterfaceTable, 
                                       NULL,
                                       CLSCTX_INPROC_SERVER, 
                                       IID_IGlobalInterfaceTable,
                                       (void **) & gp_GIT); 
        if (hr1 != ERROR_SUCCESS) {
            gp_GIT = NULL;
        }
    }

    // We will only return that this succeeded if the call to CoInitializeEx
    // returned S_FALSE.  If it didn't, it either errored or returned S_OK.
    // If S_OK, we will assume that the client isn't doing any COM stuff
    // natively.  If S_FALSE, the client already CoInitialized this thread
    // so we just bumped up the ref count and should cleanup on the way
    // out

    return (S_FALSE == sc);
}

void PdhiCoUninitialize(void)
{
    CoUninitialize();
}

PDH_FUNCTION
PdhiDisconnectWbemServer(
    PPDHI_WBEM_SERVER_DEF pWbemServer
)
{
    PDH_STATUS  pdhReturn = ERROR_SUCCESS;
    if (pWbemServer != NULL) {
        TRACE((PDH_DBG_TRACE_INFO),
              (__LINE__,
               PDH_WBEM,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               pdhReturn,
               TRACE_WSTR(pWbemServer->szMachine),
               TRACE_DWORD(pWbemServer->lRefCount),
               NULL));
        pWbemServer->lRefCount --;
        if (pWbemServer->lRefCount < 0) {
            pWbemServer->lRefCount = 0;
        }
    }
    return pdhReturn;
}

PDH_FUNCTION
PdhiFreeWbemQuery(
    PPDHI_QUERY  pThisQuery
)
{
    HRESULT hRes;

    if (! bProcessIsDetaching) {
        if ((pThisQuery->pRefresherCfg) != NULL) {
            hRes = pThisQuery->pRefresherCfg->Release();
            pThisQuery->pRefresherCfg = NULL;
        }
        if ((pThisQuery->pRefresher) != NULL) {
            hRes = pThisQuery->pRefresher->Release();
            pThisQuery->pRefresher = NULL;
        }
    }
    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiCloseWbemCounter(
    PPDHI_COUNTER   pThisCounter
)
{
    HRESULT hRes;
    BOOLEAN bRemoveRefresher = TRUE;

    if (! bProcessIsDetaching) {
        if (pThisCounter->pOwner->pRefresherCfg != NULL) {
            PPDHI_QUERY   pQuery   = pThisCounter->pOwner;
            PPDHI_COUNTER pCounter = pQuery->pCounterListHead;

            do {
                if (pCounter == NULL) {
                    bRemoveRefresher = FALSE;
                }
                else if (pCounter != pThisCounter && pCounter->lWbemRefreshId == pThisCounter->lWbemRefreshId) {
                    bRemoveRefresher = FALSE;
                }
                else {
                    pCounter = pCounter->next.flink;
                }
            }
            while (bRemoveRefresher && pCounter != NULL && pCounter != pQuery->pCounterListHead);

            if (bRemoveRefresher) {
                hRes = pThisCounter->pOwner->pRefresherCfg->Remove(pThisCounter->lWbemRefreshId, 0L);
            }
        }

        if (pThisCounter->pWbemAccess != NULL) {
            pThisCounter->pWbemAccess->Release();
            pThisCounter->pWbemAccess = NULL;
        }
        if (pThisCounter->pWbemObject != NULL) {
            pThisCounter->pWbemObject->Release();
            pThisCounter->pWbemObject = NULL;
        }
    }

    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiBreakWbemMachineName(
    LPCWSTR    szMachineAndNamespace,
    LPWSTR   * szMachine,
    LPWSTR   * szNamespace
)
/*
    assumes szMachine and szPath are large enough to hold the result
*/
{
    PDH_STATUS Status         = ERROR_SUCCESS;
    DWORD      dwSize;
    LPWSTR     szSrc          = NULL;
    LPWSTR     szDest         = NULL;
    LPWSTR     szLocMachine   = NULL;
    LPWSTR     szLocNamespace = NULL;

    if (szMachineAndNamespace == NULL) {
        // then use local machine and default namespace
        szLocMachine   = (LPWSTR) G_ALLOC((lstrlenW(szStaticLocalMachineName) + 1) * sizeof(WCHAR));
        szLocNamespace = (LPWSTR) G_ALLOC((lstrlenW(cszWbemDefaultPerfRoot)   + 1) * sizeof(WCHAR));
        if (szLocMachine != NULL && szLocNamespace != NULL) {
            StringCchCopyW(szLocMachine,   lstrlenW(szStaticLocalMachineName) + 1, szStaticLocalMachineName);
            StringCchCopyW(szLocNamespace, lstrlenW(cszWbemDefaultPerfRoot)   + 1, cszWbemDefaultPerfRoot);
        }
        else {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        TRACE((PDH_DBG_TRACE_INFO),
              (__LINE__,
               PDH_WBEM,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               Status,
               TRACE_WSTR(szStaticLocalMachineName),
               TRACE_WSTR(cszWbemDefaultPerfRoot),
               NULL));
    }
    else {
        dwSize = lstrlenW(szMachineAndNamespace) + lstrlenW(cszWbemDefaultPerfRoot) + 1;
        szLocMachine   = (LPWSTR) G_ALLOC(dwSize * sizeof(WCHAR));
        szLocNamespace = (LPWSTR) G_ALLOC(dwSize * sizeof(WCHAR));
        if (szLocMachine != NULL && szLocNamespace != NULL) {
            szSrc  = (LPWSTR) szMachineAndNamespace;
            // break into components
            if (* szSrc  != L'\0') {
                // there's a string, see if it's a machine or a namespace
                if ((szSrc[0] == L'\\') && (szSrc[1] == L'\\')) {
                    szDest = szLocMachine;
                    // then there's a machine name
                    * szDest ++ = * szSrc ++;
                    * szDest ++ = * szSrc ++;
                    while ((* szSrc != L'\0') && (* szSrc != L'\\')) {
                        * szDest ++ = * szSrc ++;
                    }
                    * szDest = L'\0';
                }
                else {
                    // no machine so use default
                    // it must be just a namespace
                }
            }
            if (szDest == NULL) {
                // nothing found yet, so insert local machine as default
                StringCchCopyW(szLocMachine, dwSize, szStaticLocalMachineName);
            }

            szDest = szLocNamespace;
            if (* szSrc != L'\0') {
                // if there's a namespace then copy it
                szSrc ++;    // move past backslash
                while (* szSrc != L'\0') {
                    * szDest ++ = * szSrc ++;
                }
                * szDest = L'\0';
            }
            else {
                // else return the default;
                StringCchCopyW(szLocNamespace, dwSize, cszWbemDefaultPerfRoot);
            }
        }
        else {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        TRACE((PDH_DBG_TRACE_INFO),
              (__LINE__,
               PDH_WBEM,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               ERROR_SUCCESS,
               TRACE_WSTR(szLocMachine),
               TRACE_WSTR(szLocNamespace),
               NULL));
    }

    if (Status == ERROR_SUCCESS) {
        * szMachine   = szLocMachine;
        * szNamespace = szLocNamespace;
    }
    else {
        G_FREE(szLocMachine);
        G_FREE(szLocNamespace);
    }
    return Status;
}

PDH_FUNCTION
PdhiMakeWbemInstancePath(
    PPDH_COUNTER_PATH_ELEMENTS_W   pCounterPathElements,
    LPWSTR                       * szFullPathBuffer,
    BOOL                           bMakeRelativePath
)
{
    PDH_STATUS Status         = ERROR_SUCCESS;
    LPWSTR     szMachine      = NULL;
    LPWSTR     szNamespace    = NULL;
    LPWSTR     szFullPath     = NULL;
    LPWSTR     szWbemInstance = NULL;
    DWORD      dwSize;
    LPWSTR     szSrc, szDest;

    if (pCounterPathElements->szMachineName != NULL) {
        dwSize = 2 * lstrlenW(pCounterPathElements->szMachineName) + lstrlenW(cszBackSlash) + lstrlenW(cszColon);
    }
    else {
        dwSize = lstrlenW(szStaticLocalMachineName)
               + lstrlenW(cszWbemDefaultPerfRoot) + lstrlenW(cszBackSlash) + lstrlenW(cszColon);
    }
    dwSize += lstrlenW(pCounterPathElements->szObjectName);
    if (pCounterPathElements->szInstanceName != NULL) {
        dwSize += (lstrlenW(cszNameParam) + 2 * lstrlenW(pCounterPathElements->szInstanceName)
                + lstrlenW(cszDoubleQuote) + 20);
        if (pCounterPathElements->szParentInstance != NULL) {
            dwSize += (2 * lstrlenW(pCounterPathElements->szParentInstance) + 1);
        }
    }
    else {
        dwSize += (lstrlenW(cszSingletonInstance) + 1);
    }
    szFullPath     = (LPWSTR) G_ALLOC(dwSize * sizeof(WCHAR));
    szWbemInstance = (LPWSTR) G_ALLOC(dwSize * sizeof(WCHAR));
    if (szFullPath == NULL || szWbemInstance == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    //  the function assumes that the path buffer is sufficiently large
    //  to hold the result
    //
    // the wbem class instance path consists of one of the following formats:
    // for perf objects with one and only one instance (singleton classes in
    // WBEM parlance) the format is
    //
    //      <objectname>=@
    //
    // for object with instances, the format is
    //
    //      <objectname>.Name="<instancename>"
    //
    if (! bMakeRelativePath) {
        Status = PdhiBreakWbemMachineName(pCounterPathElements->szMachineName, & szMachine, & szNamespace);
        if (Status == ERROR_SUCCESS) {
            StringCchPrintfW(szFullPath, dwSize, L"%ws%ws%ws%ws", szMachine, cszBackSlash, szNamespace, cszColon);
        }
        else {
            goto Cleanup;
        }
    }
    else {
        * szFullPath = L'\0';
    }

    if (pCounterPathElements->szInstanceName == NULL) {
        // then apply the singleton logic
        StringCchCatW(szFullPath, dwSize, pCounterPathElements->szObjectName);
        StringCchCatW(szFullPath, dwSize, cszSingletonInstance);
    }
    else {
        // wbem will interpret the backslash character as an
        // escape char (as "C" does) so we'll have to double each
        // backslash in the string to make it come out OK
        szDest = szWbemInstance;
        if (pCounterPathElements->szParentInstance != NULL) {
            szSrc = pCounterPathElements->szParentInstance;
            while (* szSrc != L'\0') {
                * szDest = * szSrc;
                if (* szSrc == BACKSLASH_L) {
                    * ++ szDest = BACKSLASH_L;
                }
                szDest ++;
                szSrc ++;
            }
            * szDest ++ = L'/'; // parent/child delimiter
        }
        szSrc = pCounterPathElements->szInstanceName;
        while (* szSrc != L'\0') {
            * szDest = * szSrc;
            if (* szSrc == BACKSLASH_L) {
                * ++ szDest = BACKSLASH_L;
            }
            szDest ++;
            szSrc ++;
        }
        * szDest = L'\0';
        // apply the instance name format
        StringCchCatW(szFullPath, dwSize, pCounterPathElements->szObjectName);
        StringCchCatW(szFullPath, dwSize, cszNameParam);
        StringCchCatW(szFullPath, dwSize, szWbemInstance);
        if (pCounterPathElements->dwInstanceIndex != PERF_NO_UNIQUE_ID && pCounterPathElements->dwInstanceIndex != 0) {
            WCHAR szIndex[20];
            ZeroMemory(szIndex, 20 * sizeof(WCHAR));
            _ultow(pCounterPathElements->dwInstanceIndex, szIndex, 10);
            StringCchCatW(szFullPath, dwSize, L"#");
            StringCchCatW(szFullPath, dwSize, szIndex);
        }
        StringCchCatW(szFullPath, dwSize, cszDoubleQuote);
    }

Cleanup:
    if (Status == ERROR_SUCCESS) {
        * szFullPathBuffer = szFullPath;
    }
    else {
        G_FREE(szFullPath);
        * szFullPathBuffer = NULL;
    }
    G_FREE(szMachine);
    G_FREE(szNamespace);
    G_FREE(szWbemInstance);
    return Status;
}

PDH_FUNCTION
PdhiWbemGetCounterPropertyName(
    IWbemClassObject * pThisClass,
    LPCWSTR            szCounterDisplayName,
    LPWSTR           * szPropertyName
)
{
    HRESULT             hResult;
    PDH_STATUS          pdhStatus     = PDH_CSTATUS_NO_COUNTER;
    SAFEARRAY         * psaNames      = NULL;
    long                lLower; 
    long                lUpper        = 0;
    long                lCount;
    BSTR              * bsPropName    = NULL;
    BSTR                bsCountertype = NULL;
    BSTR                bsDisplayname = NULL;
    VARIANT             vName;
    VARIANT             vCountertype;
    IWbemQualifierSet * pQualSet      = NULL;
    LPWSTR              szLocCounter  = NULL;

    * szPropertyName = NULL;

    VariantInit(& vName);
    VariantInit(& vCountertype);

    // get the properties of this class as a Safe Array
    hResult = pThisClass->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, & psaNames);
    if (hResult == WBEM_NO_ERROR) {
        hResult = SafeArrayGetLBound(psaNames, 1, & lLower);
        if (hResult == S_OK) {
            hResult = SafeArrayGetUBound(psaNames, 1, & lUpper);
        }
        if (hResult == S_OK) {
            bsCountertype = SysAllocString(cszCountertype);
            bsDisplayname = SysAllocString(cszDisplayname);
            if (bsCountertype && bsDisplayname) {
                hResult = SafeArrayAccessData(psaNames, (LPVOID *) & bsPropName);
                if (SUCCEEDED(hResult)) {
                    for (lCount = lLower; lCount <= lUpper; lCount++) {
                        // this is the desired counter so
                        // get the qualifier set for this property
                        hResult = pThisClass->GetPropertyQualifierSet(bsPropName[lCount], & pQualSet);
                        if (hResult == WBEM_NO_ERROR) {
                            LONG    lCounterType;
                            // make sure this is a perf counter property
                            hResult = pQualSet->Get(bsCountertype, 0, & vCountertype, NULL);
                            if (hResult == WBEM_NO_ERROR) {
                                lCounterType = V_I4(& vCountertype);
                                // then see if this is a displayable counter
                                if (! (lCounterType & PERF_DISPLAY_NOSHOW) || (lCounterType == PERF_AVERAGE_BULK)) {
                                    // by testing for the counter type
                                    // get the display name for this property
                                    hResult = pQualSet->Get(bsDisplayname, 0, & vName, NULL);
                                    if (hResult == WBEM_NO_ERROR) {
                                        // display name found compare it
                                        if (lstrcmpiW(szCounterDisplayName, V_BSTR(& vName)) == 0) {
                                            // then this is the correct property so return
                                            szLocCounter = (LPWSTR) G_ALLOC(
                                                    (lstrlenW((LPWSTR) bsPropName[lCount]) + 1) * sizeof(WCHAR));
                                            if (szLocCounter != NULL) {
                                                StringCchCopyW(szLocCounter,
                                                               lstrlenW((LPWSTR) bsPropName[lCount]) + 1,
                                                               (LPWSTR) bsPropName[lCount]);
                                                * szPropertyName = szLocCounter;
                                                pdhStatus = ERROR_SUCCESS;
                                                pQualSet->Release();
                                                pQualSet  = NULL;
                                                break;
                                            }
                                            else {
                                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                            }
                                        }
                                        else {
                                            //not this property so continue
                                        }
                                    }
                                }
                                else {
                                    // this is a "don't show" counter so skip it
                                }
                            }
                            else {
                                // unable to get the counter type so it's probably
                                // not a perf counter property, skip it and continue
                            }
                            VariantClear(& vName);
                            VariantClear(& vCountertype);
                            pQualSet->Release();
                            pQualSet = NULL;
                        }
                        else {
                            // unable to read qualifiers so skip
                            continue;
                        }
                    } // end for each element in SafeArray
                    SafeArrayUnaccessData(psaNames);
                }
                else {
                    // unable to read element in SafeArray
                    pdhStatus = PDH_WBEM_ERROR;
                    SetLastError(hResult);
                }
            }
            else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            PdhiSysFreeString(& bsCountertype);
            PdhiSysFreeString(& bsDisplayname);
        }
        else {
            // unable to get array boundries
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError(hResult);
        }
    }
    else {
        // unable to get property strings
        pdhStatus = PDH_WBEM_ERROR;
        SetLastError (hResult);
    }

    VariantClear(& vName);
    VariantClear(& vCountertype);

    if (psaNames != NULL) {
        // Clear the SafeArray if it exists
        SafeArrayDestroy(psaNames);
    }
    if (pdhStatus != ERROR_SUCCESS) {
        G_FREE(szLocCounter);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiWbemGetCounterDisplayName(
    IWbemClassObject * pThisClass,
    LPCWSTR            szCounterName,
    LPWSTR           * szDisplayName
)
{
    HRESULT             hResult;
    PDH_STATUS          pdhStatus     = PDH_CSTATUS_NO_COUNTER;
    SAFEARRAY         * psaNames      = NULL;
    long                lLower; 
    long                lUpper        = 0;
    long                lCount;
    BSTR              * bsPropName    = NULL;
    BSTR                bsCountertype = NULL;
    BSTR                bsDisplayname = NULL;
    VARIANT             vName, vCountertype;
    IWbemQualifierSet * pQualSet      = NULL;
    LPWSTR              szLocDisplay  = NULL;

    * szDisplayName = NULL;

    VariantInit(& vName);
    VariantInit(& vCountertype);

    // get the properties of this class as a Safe Array
    hResult = pThisClass->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, & psaNames);
    if (hResult == WBEM_NO_ERROR) {
        hResult = SafeArrayGetLBound(psaNames, 1, & lLower);
        if (hResult == S_OK) {
            hResult = SafeArrayGetUBound(psaNames, 1, & lUpper);
        }
        if (hResult == S_OK) {
            bsCountertype = SysAllocString(cszCountertype);
            bsDisplayname = SysAllocString(cszDisplayname);
            if (bsCountertype && bsDisplayname) {
                hResult = SafeArrayAccessData(psaNames, (LPVOID *) & bsPropName);
                if (SUCCEEDED(hResult)) {
                    for (lCount = lLower; lCount <= lUpper; lCount++) {
                        if (lstrcmpiW ((LPWSTR) (bsPropName[lCount]), szCounterName) == 0) {
                            // this is the desired counter so
                            // get the qualifier set for this property
                            hResult = pThisClass->GetPropertyQualifierSet(bsPropName[lCount], & pQualSet);
                            if (hResult == WBEM_NO_ERROR) {
                                LONG    lCounterType;
                                // make sure this is a perf counter property
                                hResult = pQualSet->Get(bsCountertype, 0, & vCountertype, NULL);
                                if (hResult == WBEM_NO_ERROR) {
                                    lCounterType = V_I4(&vCountertype);
                                    // then see if this is a displayable counter
                                    if (! (lCounterType & PERF_DISPLAY_NOSHOW) || (lCounterType == PERF_AVERAGE_BULK)) {
                                        // by testing for the counter type
                                        // get the display name for this property
                                        hResult = pQualSet->Get(bsDisplayname, 0, & vName, NULL);
                                        if (hResult == WBEM_NO_ERROR) {
                                            // display name found so copy and break
                                            szLocDisplay = (LPWSTR) G_ALLOC(
                                                            (lstrlenW((LPWSTR) (V_BSTR(& vName))) + 1) * sizeof(WCHAR));
                                            if (szLocDisplay != NULL) {
                                                StringCchCopyW(szLocDisplay,
                                                               lstrlenW((LPWSTR) (V_BSTR(& vName))) + 1,
                                                               (LPWSTR) V_BSTR(& vName));
                                                * szDisplayName = szLocDisplay;
                                                pdhStatus = ERROR_SUCCESS;
                                                pQualSet->Release();
                                                pQualSet  = NULL;
                                                break;
                                            }
                                            else {
                                                pdhStatus = PDH_MORE_DATA;
                                            }
                                        }
                                    }
                                    else {
                                        // this is a "don't show" counter so skip it
                                    }
                                }
                                else {
                                    // unable to get the counter type so it's probably
                                    // not a perf counter property, skip it and continue
                                }
                                VariantClear(& vName);
                                VariantClear(& vCountertype);
                                pQualSet->Release();
                                pQualSet = NULL;
                            }
                            else {
                                // unable to read qualifiers so skip
                                continue;
                            }
                        }
                        else {
                            // aren't interested in this property, so
                            continue;
                        }
                    } // end for each element in SafeArray
                    SafeArrayUnaccessData(psaNames);
                }
                else {
                    // unable to read element in SafeArray
                    pdhStatus = PDH_WBEM_ERROR;
                    SetLastError(hResult);
                }
            }
            else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            PdhiSysFreeString(& bsCountertype);
            PdhiSysFreeString(& bsDisplayname);
        }
        else {
            // unable to get array boundries
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError(hResult);
        }
    }
    else {
        // unable to get property strings
        pdhStatus = PDH_WBEM_ERROR;
        SetLastError(hResult);
    }

    VariantClear(& vName);
    VariantClear(& vCountertype);

    // Clear the SafeArray if it exists
    if (NULL != psaNames) {
        SafeArrayDestroy(psaNames);
    }
    if (pdhStatus != ERROR_SUCCESS) {
        G_FREE(szLocDisplay);
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiWbemGetClassObjectByName(
    PPDHI_WBEM_SERVER_DEF    pThisServer,
    LPCWSTR                  szClassName,
    IWbemClassObject      ** pReturnClass
)
{
    PDH_STATUS         pdhStatus  = ERROR_SUCCESS;
    HRESULT            hResult;
    BSTR               bsClassName;
    IWbemClassObject * pThisClass = NULL;

    bsClassName = SysAllocString(szClassName);
    if (bsClassName) {
        hResult = pThisServer->pSvc->GetObject(bsClassName, // class name
                                               WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                               NULL,
                                               & pThisClass,
                                               NULL);
        PdhiSysFreeString(& bsClassName);
        if (hResult != WBEM_NO_ERROR) {
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError(hResult);
        }
        else {
            * pReturnClass = pThisClass;
        }
    }
    else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }
    return (pdhStatus);
}

PDH_FUNCTION
PdhiWbemGetClassDisplayName(
    PPDHI_WBEM_SERVER_DEF   pThisServer,
    LPCWSTR                 szClassName,
    LPWSTR                * szClassDisplayName,
    IWbemClassObject     ** pReturnClass
)
{
    PDH_STATUS          pdhStatus     = ERROR_SUCCESS;
    HRESULT             hResult;
    BSTR                bsClassName;
    BSTR                bsClass;
    BSTR                bsDisplayName;
    VARIANT             vName;
    LPWSTR              szDisplayName = NULL;
    LPWSTR              szRtnDisplay  = NULL;
    IWbemClassObject  * pThisClass    = NULL;
    IWbemQualifierSet * pQualSet      = NULL;

    * szClassDisplayName = NULL;
    VariantInit(& vName);
    bsClassName = SysAllocString(szClassName);
    if (bsClassName) {
        hResult = pThisServer->pSvc->GetObject(bsClassName, // class name
                                               WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                               NULL,
                                               & pThisClass,
                                               NULL);
        if (hResult != WBEM_NO_ERROR) {
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError(hResult);
        }
        PdhiSysFreeString(& bsClassName);
    }
    else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // get the display name property of this class
        pThisClass->GetQualifierSet(& pQualSet);
        if (pQualSet != NULL) {
            bsDisplayName = SysAllocString(cszDisplayname);
            if (bsDisplayName != NULL) {
                hResult = pQualSet->Get(bsDisplayName, 0, & vName, 0);
                if (hResult == WBEM_E_NOT_FOUND) {
                    // then this has not display name so
                    // pull the class name
                    bsClass = SysAllocString(cszClass);
                    if (bsClass) {
                        hResult = pThisClass->Get(bsClass, 0, & vName, 0, 0);
                        PdhiSysFreeString(& bsClass);
                    }
                    else {
                        hResult = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else {
                    hResult = WBEM_E_OUT_OF_MEMORY;
                }
                PdhiSysFreeString(& bsDisplayName);
            }
            else {
                hResult = WBEM_E_OUT_OF_MEMORY;
            }
            pQualSet->Release();
        }
        else {
            hResult = WBEM_E_NOT_FOUND;
        }
        if (hResult == WBEM_E_NOT_FOUND) {
            //unable to look up a display name so nothing to return
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError(hResult);
        }
        else if (hResult == WBEM_E_OUT_OF_MEMORY) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            SetLastError(hResult);
        }
        else if (hResult == S_OK) {
            // copy string to caller's buffers
            szDisplayName = V_BSTR(& vName);
            szRtnDisplay  = (LPWSTR) G_ALLOC((lstrlenW(szDisplayName) + 1) * sizeof(WCHAR));
            if (szRtnDisplay != NULL) {
                StringCchCopyW(szRtnDisplay, lstrlenW(szDisplayName) + 1, szDisplayName);
                * szClassDisplayName = szRtnDisplay;
                pdhStatus            = ERROR_SUCCESS;
            }
            else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        if (hResult == S_OK) {
            if (pReturnClass != NULL) {
                // return the class pointer, the caller will close it
                * pReturnClass = pThisClass;
            }
            else {
                // close it
                pThisClass->Release();
            }
        }
        else {
            pThisClass->Release();
        }
    }
    VariantClear(& vName);
    return pdhStatus;
}
BOOL
PdhiIsSingletonClass(
    IWbemClassObject * pThisClass
)
{
    HRESULT             hResult;
    BOOL                bReturnValue = FALSE;
    BSTR                bsSingleton  = NULL;
    VARIANT             vValue;
    IWbemQualifierSet * pQualSet     = NULL;

    bsSingleton = SysAllocString(cszSingleton);
    if (bsSingleton) {
        VariantInit(& vValue);
        // get the display name of this class
        pThisClass->GetQualifierSet(& pQualSet);
        if (pQualSet != NULL) {
            hResult = pQualSet->Get(bsSingleton, 0, & vValue, 0);
            pQualSet->Release();
        }
        else {
            hResult = WBEM_E_NOT_FOUND;
        }
        if (hResult == ERROR_SUCCESS) {
            bReturnValue = TRUE;
        }
        VariantClear(& vValue);
        PdhiSysFreeString(& bsSingleton);
    }
    else {
        bReturnValue = FALSE;
    }
    return bReturnValue;
}

#pragma warning (disable : 4127)
PDH_FUNCTION
PdhiEnumWbemServerObjects(
    PPDHI_WBEM_SERVER_DEF pThisServer,
    LPVOID                mszObjectList,
    LPDWORD               pcchBufferSize,
    DWORD                 dwDetailLevel,
    BOOL                  bRefresh,
    BOOL                  bUnicode
);

PDH_FUNCTION
PdhiWbemGetObjectClassName(
    PPDHI_WBEM_SERVER_DEF   pThisServer,
    LPCWSTR                 szObjectName,
    LPWSTR                * szObjectClassName,
    IWbemClassObject     ** pReturnClass
)
{
    PDH_STATUS  pdhStatus   = ERROR_SUCCESS;
    HRESULT     hResult;
    LPWSTR      szLocObject = NULL;
    LONG        lResult;

    if (pThisServer->pObjList == NULL) {
        DWORD dwSize = 0;
        pdhStatus = PdhiEnumWbemServerObjects(pThisServer,
                                              NULL,
                                              & dwSize,
                                              PERF_DETAIL_WIZARD | PERF_DETAIL_COSTLY,
                                              TRUE,
                                              TRUE);
        if (pThisServer->pObjList != NULL) {
            pdhStatus = ERROR_SUCCESS;
        }
    }

    if (pThisServer->pObjList != NULL) {
        PPDHI_WBEM_OBJECT_DEF pObject = pThisServer->pObjList;

        pdhStatus = PDH_CSTATUS_NO_OBJECT;
        while (pObject != NULL) {
            lResult = lstrcmpiW(pObject->szDisplay, szObjectName);
            if (lResult == 0) {
                szLocObject = (LPWSTR) G_ALLOC((lstrlenW(pObject->szObject) + 1) * sizeof(WCHAR));
                if (szLocObject == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                else {
                    pdhStatus = ERROR_SUCCESS;
                    StringCchCopyW(szLocObject, lstrlenW(pObject->szObject) + 1, pObject->szObject);
                }
                if (pObject->pClass == NULL) {
                    BSTR bsClassName = SysAllocString(pObject->szObject);
                    if (bsClassName) {
                        hResult = pThisServer->pSvc->GetObject(
                                        bsClassName, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, & pObject->pClass, NULL);
                        if (hResult != WBEM_NO_ERROR) {
                            SetLastError(hResult);
                            pdhStatus = PDH_WBEM_ERROR;
                        }
                        else if (pReturnClass != NULL) {
                            * pReturnClass = pObject->pClass;
                        }
                        PdhiSysFreeString(& bsClassName);
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
                else if (pReturnClass != NULL) {
                    * pReturnClass = pObject->pClass;
                }
                break;
            }
            pObject = pObject->pNext;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        * szObjectClassName = szLocObject;
    }
    else {
        G_FREE(szLocObject);
    }
    return pdhStatus;
}
#pragma warning ( default : 4127 )

PDH_FUNCTION
PdhiAddWbemServer(
    LPCWSTR                 szMachineName,
    PPDHI_WBEM_SERVER_DEF * pWbemServer
)
{
    IWbemLocator          * pWbemLocator           = NULL;
    IWbemServices         * pWbemServices          = NULL;
    PDH_STATUS              pdhStatus              = ERROR_SUCCESS;
    HRESULT                 hResult;
    DWORD                   dwResult;
    DWORD                   dwStrLen               = 0;
    PPDHI_WBEM_SERVER_DEF   pNewServer             = NULL;
    LPWSTR                  szLocalMachineName     = NULL;
    LPWSTR                  szLocalNameSpaceString = NULL;
    LPWSTR                  szLocalServerPath      = NULL;
    LPWSTR                  szLocale               = NULL;

    // szMachineName can be null,
    // that means use the local machine and default namespace

    // connect to locator
    dwResult = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
                                IID_IWbemLocator, (LPVOID *) & pWbemLocator);
    if (dwResult != S_OK) {
        SetLastError(dwResult);
        pdhStatus = PDH_CANNOT_CONNECT_MACHINE;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiBreakWbemMachineName(szMachineName, & szLocalMachineName, & szLocalNameSpaceString);
        if (pdhStatus == ERROR_SUCCESS) {
            dwStrLen = lstrlenW(szLocalMachineName) + lstrlenW(szLocalNameSpaceString) + 1;
            szLocalServerPath = (LPWSTR) G_ALLOC((dwStrLen + 32) * sizeof(WCHAR));
            if (szLocalServerPath == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            else {
                BSTR bstrLocalServerPath;
                BSTR bstrLocale;

                StringCchPrintfW(szLocalServerPath, dwStrLen, L"%ws%ws", szLocalMachineName, szLocalNameSpaceString);
                bstrLocalServerPath = SysAllocString(szLocalServerPath);

                // Create the locale
                szLocale = szLocalServerPath + dwStrLen;
                StringCchPrintfW(szLocale, 32, L"MS_%hX", GetUserDefaultUILanguage());
                bstrLocale = SysAllocString(szLocale);

                if (bstrLocalServerPath && bstrLocale) {
                    // try to connect to the service
                    hResult = pWbemLocator->ConnectServer(bstrLocalServerPath,
                                                          NULL,
                                                          NULL,
                                                          bstrLocale,
                                                          0L,
                                                          NULL,
                                                          NULL,
                                                          & pWbemServices);
                    if (FAILED(hResult)) {
                        SetLastError(hResult);
                        pdhStatus = PDH_CANNOT_CONNECT_WMI_SERVER;
                    }
                    else {
                        dwStrLen = lstrlenW(szLocalMachineName) + 1;
                    }
                    PdhiSysFreeString(& bstrLocalServerPath);
                    PdhiSysFreeString(& bstrLocale);
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
        }
        // free the locator
        pWbemLocator->Release();
    }

    // If we succeeded, we need to set Interface Security on the proxy and its
    // IUnknown in order for Impersonation to correctly work.
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = SetWbemSecurity(pWbemServices);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // everything went ok so save this connection
        if (* pWbemServer == NULL) {
            // then this is a new connection
            pNewServer = (PPDHI_WBEM_SERVER_DEF) G_ALLOC(sizeof(PDHI_WBEM_SERVER_DEF) + (dwStrLen * sizeof(WCHAR)));
            if (pNewServer == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            else {
                // insert this at the head of the list
                pNewServer->pNext     = pFirstWbemServer;
                pFirstWbemServer      = pNewServer;
                pNewServer->szMachine = (LPWSTR) & pNewServer[1];
                StringCchCopyW(pNewServer->szMachine, dwStrLen, szLocalMachineName);
                pNewServer->lRefCount = 0; // it'll be incremented in the connect function
                * pWbemServer         = pNewServer;
            }
        }
        else {
            // we are reconnecting and reusing an old memory block
            // so just update the pointer
            pNewServer = * pWbemServer;
        }
        // if reconnecting or connecting for the first time, this should be NULL

        if (pdhStatus == ERROR_SUCCESS) {
            // update fields
            // load the name fields
            pNewServer->pSvc     = pWbemServices;
            pNewServer->pObjList = NULL;
            pNewServer->dwCache  = 0;
            if (gp_GIT != NULL) {
                HRESULT hrTmp = gp_GIT->RegisterInterfaceInGlobal(pWbemServices,
                                                                  IID_IWbemServices,
                                                                  & (pNewServer->dwCache));
                if (! SUCCEEDED(hrTmp)) {
                    pWbemServices->Release();
                    pNewServer->pSvc    = NULL;
                    pNewServer->dwCache = 0;
                    pdhStatus           = PDH_WBEM_ERROR;
                }
            }
            else {
                pWbemServices->Release();
                pNewServer->pSvc    = NULL;
                pNewServer->dwCache = 0;
                pdhStatus           = PDH_WBEM_ERROR;
            }
        }
        else {
            // something failed so return a NULL for the server pointer
            * pWbemServer = NULL;
        }
    }
    else {
        // unable to connect so return NULL
        * pWbemServer = NULL;
    }

    // if there was an eror, then free the new sever memory
    if ((* pWbemServer) == NULL) G_FREE(pNewServer);
    G_FREE(szLocalMachineName);
    G_FREE(szLocalNameSpaceString);
    G_FREE(szLocalServerPath);

    return pdhStatus;
}

PDH_FUNCTION
PdhiCloseWbemServer(
    PPDHI_WBEM_SERVER_DEF pWbemServer
)
{
    if (! bProcessIsDetaching) {
        if (pWbemServer != NULL) {
            if (pWbemServer->pObjList != NULL) {
                PPDHI_WBEM_OBJECT_DEF pObject = pWbemServer->pObjList;
                PPDHI_WBEM_OBJECT_DEF pNext;

                pWbemServer->pObjList = NULL;
                while (pObject != NULL) {
                    pNext = pObject->pNext;
                    if (pObject->pClass != NULL) pObject->pClass->Release();
                    G_FREE(pObject);
                    pObject = pNext;
                }
            }
            if (pWbemServer->pSvc != NULL) {
                // this is about all that's currently required
                pWbemServer->pSvc->Release();
                pWbemServer->pSvc = NULL;
            }
            else {
                // no server is connected
            }
        }
        else {
            // no structure exists
        }
    }

    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiConnectWbemServer(
    LPCWSTR                 szMachineName,
    PPDHI_WBEM_SERVER_DEF * pWbemServer
)
{
    PDH_STATUS            pdhStatus         = PDH_CANNOT_CONNECT_MACHINE;
    PPDHI_WBEM_SERVER_DEF pThisServer       = NULL;
    LPWSTR                szWideMachineName = NULL;
    LPWSTR                szWideNamespace   = NULL;
    LPWSTR                szMachineNameArg  = NULL;
    DWORD                 dwSize;

    // get the local machine name & default name space if the caller
    // has passed in a NULL machine name

    if (szMachineName == NULL) {
        pdhStatus = PdhiBreakWbemMachineName(NULL, & szWideMachineName, & szWideNamespace);
//            lstrcatW (szWideMachineName, cszBackSlash);
//            lstrcatW (szWideMachineName, szWideNamespace);
        if (pdhStatus == ERROR_SUCCESS) {
            dwSize = lstrlenW(szWideMachineName) + 3;
            szMachineNameArg = (LPWSTR) G_ALLOC(sizeof(WCHAR) * dwSize);
            if (szMachineNameArg == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            else {
                if (szWideMachineName[0] == L'\\' && szWideMachineName[1] == L'\\') {
                    StringCchCopyW(szMachineNameArg, dwSize, szWideMachineName);
                }
                else {
                    StringCchPrintfW(szMachineNameArg, dwSize, L"%ws%ws", cszDoubleBackSlash, szWideMachineName);
                }
                pdhStatus = ERROR_SUCCESS;
            }
        }
    }
    else {
        dwSize = lstrlenW(szMachineName) + 3;
        szMachineNameArg = (LPWSTR) G_ALLOC(sizeof(WCHAR) * dwSize);
        if (szMachineNameArg == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else {
            if (szMachineName[0] == L'\\' && szMachineName[1] == L'\\') {
                StringCchCopyW(szMachineNameArg, dwSize, szMachineName);
            }
            else {
                StringCchPrintfW(szMachineNameArg, dwSize, L"%ws%ws", cszDoubleBackSlash, szMachineName);
            }
            pdhStatus = ERROR_SUCCESS;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // walk down list of connected servers and find the requested one
        for (pThisServer = pFirstWbemServer; pThisServer != NULL; pThisServer = pThisServer->pNext) {
            // machine name includes the namespace
            if (lstrcmpiW(pThisServer->szMachine, szMachineNameArg) == 0) {
                pdhStatus = ERROR_SUCCESS;
                break;
            }
        }
        if (pThisServer == NULL) {
             // then add it to the list and return it
             pdhStatus = PdhiAddWbemServer(szMachineNameArg, & pThisServer);
        }
        else {
            // make sure the server is really there
            // this is just a dummy call to see if the server will respond
            // with an error or RPC will respond with an error that there's
            // no server anymore.
            HRESULT hrTest;

            if (gp_GIT != NULL) {
                IWbemServices * pSvc = NULL;

                hrTest = gp_GIT->GetInterfaceFromGlobal(pThisServer->dwCache, IID_IWbemServices, (void **) & pSvc);
                if (SUCCEEDED(hrTest)) {
                    if (pSvc != pThisServer->pSvc) {
                        pThisServer->pSvc = NULL;
                        if (pThisServer->pObjList != NULL) {
                            PPDHI_WBEM_OBJECT_DEF pObject;
                            PPDHI_WBEM_OBJECT_DEF pNext;
                            pObject = pThisServer->pObjList;
                            pThisServer->pObjList = NULL;
                            while (pObject != NULL) {
                                pNext = pObject->pNext;
                                G_FREE(pObject);
                                pObject = pNext;
                            }
                        }
                    }
                }
                else {
                    pThisServer->pSvc   = NULL;
                    if (pThisServer->pObjList != NULL) {
                        PPDHI_WBEM_OBJECT_DEF pObject;
                        PPDHI_WBEM_OBJECT_DEF pNext;
                        pObject = pThisServer->pObjList;
                        pThisServer->pObjList = NULL;
                        while (pObject != NULL) {
                            pNext = pObject->pNext;
                            G_FREE(pObject);
                            pObject = pNext;
                        }
                    }
                }
            }
            else {
                pThisServer->pSvc  = NULL;
                if (pThisServer->pObjList != NULL) {
                    PPDHI_WBEM_OBJECT_DEF pObject;
                    PPDHI_WBEM_OBJECT_DEF pNext;
                    pObject = pThisServer->pObjList;
                    pThisServer->pObjList = NULL;
                    while (pObject != NULL) {
                        pNext = pObject->pNext;
                        G_FREE(pObject);
                        pObject = pNext;
                    }
                }
            }
            if (pThisServer->pSvc != NULL) {
                hrTest = pThisServer->pSvc->CancelAsyncCall(NULL);
            }
            else {
                // there is no service connected so set the HRESULT to
                // get the next block to try and reconnect
                hrTest = 0x800706BF; // some bad status value thats NOT WBEM_E_INVALID_PARAMETER
            }

            // if the error is WBEM_E_INVALID_PARAMETER then the server is there
            // so we can continue
            // else if the error is something else then try to reconnect by closing and
            // reopening this connection

            if (hrTest != WBEM_E_INVALID_PARAMETER) {
                PdhiCloseWbemServer(pThisServer);
                pdhStatus = PdhiAddWbemServer(szMachineNameArg, & pThisServer);
            }
        }

        * pWbemServer = pThisServer;

        if (pdhStatus == ERROR_SUCCESS) pThisServer->lRefCount++;
    }
    G_FREE(szWideMachineName);
    G_FREE(szWideNamespace);
    G_FREE(szMachineNameArg);
    return pdhStatus;
}

PDH_FUNCTION
PdhiFreeAllWbemServers(
)
{
    PPDHI_WBEM_SERVER_DEF pThisServer;
    PPDHI_WBEM_SERVER_DEF pNextServer;

    pThisServer = pFirstWbemServer;
    while (pThisServer != NULL) {
        pNextServer = pThisServer->pNext;
        PdhiCloseWbemServer(pThisServer);
        G_FREE(pThisServer);
        pThisServer = pNextServer;
    }
    pFirstWbemServer = NULL;

    if (gp_GIT != NULL) {
        gp_GIT->Release();
        gp_GIT = NULL;
    }
    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiGetWbemExplainText(
    LPCWSTR  szMachineName,
    LPCWSTR  szObjectName,
    LPCWSTR  szCounterName,
    LPWSTR   szExplain,
    LPDWORD  pdwExplain
)
{
    PDH_STATUS              Status            = ERROR_SUCCESS;
    HRESULT                 hResult;
    BOOL                    bDisconnect       = FALSE;
    DWORD                   dwExplain         = 0;
    VARIANT                 vsExplain;
    LPWSTR                  szObjectClassName = NULL;
    PPDHI_WBEM_SERVER_DEF   pThisServer       = NULL;
    IEnumWbemClassObject  * pEnum             = NULL;
    IWbemClassObject      * pThisObject       = NULL;
    IWbemQualifierSet     * pQualSet          = NULL;
    BOOL                    fCoInitialized    = PdhiCoInitialize();

    if (szMachineName == NULL || szObjectName == NULL || pdwExplain == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        dwExplain = * pdwExplain;
        if (szExplain != NULL && dwExplain != 0) {
            ZeroMemory(szExplain, dwExplain);
        }
    }
    if (Status == ERROR_SUCCESS) {
        Status = PdhiConnectWbemServer(szMachineName, & pThisServer);
    }
    if (Status == ERROR_SUCCESS) {
        bDisconnect = TRUE;
        Status      = PdhiWbemGetObjectClassName(pThisServer, szObjectName, & szObjectClassName, & pThisObject);
    }
    if (Status == ERROR_SUCCESS) {
        VariantInit(& vsExplain);

        if (szCounterName != NULL) {
            SAFEARRAY * psaNames      = NULL;
            LONG        lLower        = 0; 
            LONG        lUpper        = 0;
            LONG        lCount        = 0;
            BSTR      * bsPropName    = NULL;
            VARIANT     vName;
            VARIANT     vCountertype;
            LONG        lCounterType;

            VariantInit(& vName);
            VariantInit(& vCountertype);

            hResult = pThisObject->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, & psaNames);
            if (hResult == WBEM_NO_ERROR) {
                hResult = SafeArrayGetLBound(psaNames, 1, & lLower);
                if (hResult == S_OK) {
                    hResult = SafeArrayGetUBound(psaNames, 1, & lUpper);
                }
                if (hResult == S_OK) {
                    hResult = SafeArrayAccessData(psaNames, (LPVOID *) & bsPropName);
                    if (SUCCEEDED(hResult)) {
                        for (lCount = lLower; lCount <= lUpper; lCount++) {
                            hResult = pThisObject->GetPropertyQualifierSet(bsPropName[lCount], & pQualSet);
                            if (hResult == S_OK) {
                                hResult = pQualSet->Get(cszCountertype, 0, & vCountertype, NULL);
                                if (hResult == S_OK) {
                                    lCounterType = V_I4(& vCountertype);
                                    if (! (lCounterType & PERF_DISPLAY_NOSHOW) || (lCounterType == PERF_AVERAGE_BULK)) {
                                        hResult = pQualSet->Get(cszDisplayname, 0, & vName, NULL);
                                        if (hResult == S_OK) {
                                            if (vName.vt == VT_BSTR &&
                                                    lstrcmpiW(szCounterName, V_BSTR(& vName)) == 0) {
                                                hResult = pQualSet->Get(cszExplainText, 0, & vsExplain, NULL);
                                                if (hResult == S_OK && vsExplain.vt == VT_BSTR) {
                                                    LPWSTR szResult = V_BSTR(& vsExplain);
                                                    if (((DWORD) lstrlenW(szResult)) + 1 < dwExplain) {
                                                        StringCchCopyW(szExplain, dwExplain, szResult);
                                                        Status = ERROR_SUCCESS;
                                                    }
                                                    else {
                                                        * pdwExplain = (DWORD) lstrlenW(szResult) + 1;
                                                        Status       = PDH_MORE_DATA;
                                                    }
                                                }
                                                pQualSet->Release();
                                                break;
                                            }
                                            VariantClear(& vName);
                                        }
                                    }
                                    VariantClear(& vCountertype);
                                }
                                pQualSet->Release();
                            }
                        }
                        SafeArrayUnaccessData(psaNames);
                    }
                    else {
                        SetLastError(hResult);
                        Status = PDH_WBEM_ERROR;
                    }
                }
                else {
                    SetLastError(hResult);
                    Status = PDH_WBEM_ERROR;
                }
            }
            else {
                SetLastError(hResult);
                Status = PDH_WBEM_ERROR;
            }
            VariantClear(& vName);
            VariantClear(& vCountertype);
        }
        else {
            // get counter object explain text
            //
            pThisObject->GetQualifierSet(& pQualSet);
            if (pQualSet != NULL) {
                hResult = pQualSet->Get(cszExplainText, 0, & vsExplain, 0);
                if (hResult == S_OK) {
                    LPWSTR szResult = V_BSTR(& vsExplain);
                    if ((DWORD) lstrlenW(szResult) + 1 < dwExplain) {
                        StringCchCopyW(szExplain, dwExplain, szResult);
                        Status = ERROR_SUCCESS;
                    }
                    else {
                        * pdwExplain = (DWORD) lstrlenW(szResult) + 1;
                        Status       = PDH_MORE_DATA;
                    }
                }
                else {
                    SetLastError(hResult);
                    Status = PDH_WBEM_ERROR;
                }
                pQualSet->Release();
            }
            else {
                SetLastError(WBEM_E_NOT_FOUND);
                Status = PDH_WBEM_ERROR;
            }
        }
        //pThisObject->Release();
        VariantClear(& vsExplain);
    }

    if (bDisconnect) {
        if (Status == ERROR_SUCCESS) {
            Status = PdhiDisconnectWbemServer(pThisServer);
        }
        else {
            PdhiDisconnectWbemServer(pThisServer);
        }
    }

    if (fCoInitialized) {
        PdhiCoUninitialize();
    }
    G_FREE(szObjectClassName);
    return Status;
}

PDH_FUNCTION
PdhiEnumWbemMachines(
    LPVOID  pMachineList,
    LPDWORD pcchBufferSize,
    BOOL    bUnicode
)
{
    PDH_STATUS  pdhStatus;
    PPDHI_WBEM_SERVER_DEF pThisServer         = NULL;
    DWORD                 dwCharsLeftInBuffer = * pcchBufferSize;
    DWORD                 dwBufferSize        = 0;
    DWORD                 dwStrLen;
    DWORD                 dwResult;
    // CoInitialize() if we need to
    BOOL                  fCoInitialized      = PdhiCoInitialize();

    // test to see if we've connected to the local machine yet, if not then do it
    if (pFirstWbemServer == NULL) {
        // add local machine
        pdhStatus = PdhiAddWbemServer(NULL, & pThisServer);
    }

    // walk down list of known machines and find the machines that are using
    // the specified name space.
    pThisServer = pFirstWbemServer;
    while (pThisServer != NULL) {
        dwStrLen = lstrlenW(pThisServer->szMachine) + 1;
        if ((pMachineList != NULL) && (dwCharsLeftInBuffer >= dwStrLen)) {
            // then it will fit so add it
            pdhStatus = AddUniqueWideStringToMultiSz(
                    pMachineList, pThisServer->szMachine, dwCharsLeftInBuffer, & dwResult, bUnicode);
            if (pdhStatus == ERROR_SUCCESS) {
                if (dwResult > 0) {
                    dwBufferSize        = dwResult;
                    dwCharsLeftInBuffer = * pcchBufferSize - dwBufferSize;
                } // else
                // this string is already in the list so
                // nothing was added
            }
            else if (pdhStatus == PDH_MORE_DATA) {
                dwCharsLeftInBuffer = 0; // to prevent any other strings from being added
                dwBufferSize       += dwStrLen;
            }
            else {
                goto Cleanup;
            }
        }
        else {
            // just add the string length to estimate the buffer size
            // required
            dwCharsLeftInBuffer = 0; // to prevent any other strings from being added
            dwBufferSize       += dwStrLen;
        }
        pThisServer = pThisServer->pNext;
    } // end of while loop

    if (dwBufferSize <= * pcchBufferSize) {
        // the buffer size includes both term nulls
        pdhStatus = ERROR_SUCCESS;
    }
    else {
        // add terminating MSZ Null char size
        dwBufferSize ++;
        // there wasn't enough room. See if a buffer was passed in
        pdhStatus = PDH_MORE_DATA;
    }
    // return the size used or required
    * pcchBufferSize = dwBufferSize;

Cleanup:
    // CoUninitialize if necessary
    if (fCoInitialized) {
        PdhiCoUninitialize();
    }

    return pdhStatus;
}

#pragma warning ( disable : 4127 )
PDH_FUNCTION
PdhiEnumWbemServerObjects(
    PPDHI_WBEM_SERVER_DEF pThisServer,
    LPVOID                mszObjectList,
    LPDWORD               pcchBufferSize,
    DWORD                 dwDetailLevel,
    BOOL                  bRefresh,       // ignored
    BOOL                  bUnicode
)
{
    // this function enumerates the classes that are subclassed
    // from the Win32_PerfRawData Superclass
    PDH_STATUS              pdhStatus           = ERROR_SUCCESS;
    HRESULT                 hResult;
    DWORD                   dwCharsLeftInBuffer = * pcchBufferSize;
    DWORD                   dwBufferSize        = 0;
    DWORD                   dwStrLen;
    DWORD                   dwRtnCount;
    DWORD                   dwResult;
    DWORD                   dwDetailLevelDesired;
    DWORD                   dwItemDetailLevel   = 0;
    LPWSTR                  szClassName;
    VARIANT                 vName;
    VARIANT                 vClass;
    VARIANT                 vDetailLevel;
    BOOL                    bPerfDefault        = FALSE;
    BSTR                    bsTemp              = NULL;
    BSTR                    bsDisplayName       = NULL;
    BSTR                    bsClass             = NULL;
    BSTR                    bsCostly            = NULL;
    BSTR                    bsDetailLevel       = NULL;
    BSTR                    bsPerfDefault       = NULL;
    BOOL                    bGetCostlyItems     = FALSE;
    BOOL                    bIsCostlyItem       = FALSE;
    BOOL                    bDisconnectServer   = FALSE;
    IEnumWbemClassObject  * pEnum               = NULL;
    IWbemClassObject      * pThisClass          = NULL;
    IWbemQualifierSet     * pQualSet            = NULL;
    PPDHI_WBEM_OBJECT_DEF   pHead               = NULL;
    PPDHI_WBEM_OBJECT_DEF   pObject             = NULL;

    DBG_UNREFERENCED_PARAMETER(bRefresh);

    VariantInit(& vName);
    VariantInit(& vClass);
    VariantInit(& vDetailLevel);

    if (pThisServer->pObjList != NULL) {
        PPDHI_WBEM_OBJECT_DEF pThisObj = pThisServer->pObjList;
        PPDHI_WBEM_OBJECT_DEF pNext;

        pThisServer->pObjList = NULL;
        while (pThisObj != NULL) {
            pNext = pThisObj->pNext;
            if (pThisObj->pClass != NULL) pThisObj->pClass->Release();
            G_FREE(pThisObj);
            pThisObj = pNext;
        }
    }

    // create an enumerator of the PerfRawData class
    bsTemp = SysAllocString (cszPerfRawData);
    if (bsTemp) {
        hResult = pThisServer->pSvc->CreateClassEnum(bsTemp,
                                                     WBEM_FLAG_DEEP | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                                     NULL,
                                                     & pEnum);
        PdhiSysFreeString(& bsTemp);
        bDisconnectServer = TRUE;
        // Set security on the proxy
        if (SUCCEEDED(hResult)) {
            hResult = SetWbemSecurity(pEnum);
        }
        if (hResult != WBEM_NO_ERROR) {
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        }
    }
    else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // set costly flag
        bGetCostlyItems      = ((dwDetailLevel & PERF_DETAIL_COSTLY) == PERF_DETAIL_COSTLY);
        dwDetailLevelDesired = (DWORD) (dwDetailLevel & PERF_DETAIL_STANDARD);
        bsCostly             = SysAllocString(cszCostly);
        bsDisplayName        = SysAllocString(cszDisplayname);
        bsClass              = SysAllocString(cszClass);
        bsDetailLevel        = SysAllocString(cszPerfdetail);
        bsPerfDefault        = SysAllocString(cszPerfdefault);

        if (bsCostly && bsDisplayName && bsClass && bsDetailLevel) {
            while (TRUE) {
                hResult = pEnum->Next(WBEM_INFINITE,  // timeout
                                      1,              // return only 1 object
                                      & pThisClass,
                                      & dwRtnCount);
                // no more classes
                if ((pThisClass == NULL) || (dwRtnCount == 0)) break;

                // get the display name of this class
                bIsCostlyItem = FALSE; // assume it's not unless proven otherwise
                bPerfDefault  = FALSE;
                hResult       = pThisClass->Get(bsClass, 0, & vClass, 0, 0);

                pThisClass->GetQualifierSet(& pQualSet);
                if (pQualSet != NULL) {
                    VariantClear(& vName);
                    hResult = pQualSet->Get(bsCostly, 0, & vName, 0);
                    if (hResult == S_OK) {
                        bIsCostlyItem = TRUE;
                    }
                    hResult = pQualSet->Get(bsDetailLevel, 0, & vDetailLevel, 0);
                    if (hResult == S_OK) {
                        dwItemDetailLevel = (DWORD) V_I4(& vDetailLevel);
                    }
                    else {
                        dwItemDetailLevel = 0;
                    }

                    VariantClear(& vName);
                    hResult = pQualSet->Get(bsPerfDefault, 0, & vName, 0);
                    if (hResult != WBEM_E_NOT_FOUND) {
                        bPerfDefault = (BOOL) V_BOOL(& vName);
                    }
                    VariantClear(& vName);
                    hResult = pQualSet->Get(bsDisplayName, 0, & vName, 0);
                    pQualSet->Release();
                }
                else {
                    hResult = WBEM_E_NOT_FOUND;
                }

                if (hResult == WBEM_E_NOT_FOUND) {
                    // then this has not display name so
                    // pull the class name
                    hResult = pThisClass->Get(bsClass, 0, & vName, 0, 0);
                }

                if (hResult == WBEM_E_NOT_FOUND) {
                    szClassName = (LPWSTR) cszNotFound;
                }
                else {
                    szClassName = (LPWSTR) V_BSTR(& vName);
                }

                if (((bIsCostlyItem && bGetCostlyItems) || // if costly and we want them
                                (! bIsCostlyItem)) && (dwItemDetailLevel <= dwDetailLevelDesired)) {
                    dwStrLen = lstrlenW(szClassName) + 1;
                    if ((mszObjectList != NULL) && (dwCharsLeftInBuffer >= dwStrLen)) {
                        // then it will fit so add it
                        pdhStatus = AddUniqueWideStringToMultiSz(
                                        mszObjectList, szClassName, dwCharsLeftInBuffer, & dwResult, bUnicode);
                        if (pdhStatus == ERROR_SUCCESS) {
                            if (dwResult > 0) {
                                dwBufferSize        = dwResult;
                                dwCharsLeftInBuffer = * pcchBufferSize - dwBufferSize;
                            } // else
                            // this string is already in the list so
                            // nothing was added
                        }
                        else if (pdhStatus == PDH_MORE_DATA) {
                            dwCharsLeftInBuffer = 0; // to prevent any other strings from being added
                            dwBufferSize       += dwStrLen;
                        }
                    }
                    else {
                        // just add the string length to estimate the buffer size
                        // required
                        dwCharsLeftInBuffer = 0; // to prevent any other strings from being added
                        dwBufferSize       += dwStrLen;
                    }
                }

                if (lstrcmpiW(szClassName, cszNotFound) != 0) {
                    LPWSTR szClass = (LPWSTR) V_BSTR(& vClass);
                    DWORD dwSize   = sizeof(PDHI_WBEM_OBJECT_DEF)
                                   + sizeof(WCHAR) * (lstrlenW(szClassName) + lstrlenW(szClass) + 2);
                    pObject = (PPDHI_WBEM_OBJECT_DEF) G_ALLOC(dwSize);
                    if (pObject != NULL) {
                        pObject->bDefault  = bPerfDefault;
                        pObject->szObject  = (LPWSTR) (((LPBYTE) pObject) + sizeof(PDHI_WBEM_OBJECT_DEF));
                        StringCchCopyW(pObject->szObject, lstrlenW(szClass) + 1, szClass);
                        pObject->szDisplay = (LPWSTR) (((LPBYTE) pObject)
                                           + sizeof(PDHI_WBEM_OBJECT_DEF)
                                           + sizeof(WCHAR) * (lstrlenW(szClass) + 1));
                        StringCchCopyW(pObject->szDisplay, lstrlenW(szClassName) + 1, szClassName);
                        pObject->pNext = pHead;
                        pHead          = pObject;
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        pThisClass->Release();
                        break;
                    }
                }
                // clear the variant
                VariantClear(& vName);
                VariantClear(& vClass);
                VariantClear(& vDetailLevel);

                // free this class
                pThisClass->Release();
            }

            if (dwBufferSize == 0) {
                pdhStatus = PDH_WBEM_ERROR;
            }
            else {
                dwBufferSize ++; // the final NULL
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (dwBufferSize <= * pcchBufferSize) {
                    pdhStatus = ERROR_SUCCESS;
                }
                else {
                    // there wasn't enough room. See if a buffer was passed in
                    pdhStatus = PDH_MORE_DATA;
                }
                // return the size used or required
                * pcchBufferSize = dwBufferSize;
            }
        }
    }
    else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }

    PdhiSysFreeString(& bsDisplayName);
    PdhiSysFreeString(& bsClass);
    PdhiSysFreeString(& bsCostly);
    PdhiSysFreeString(& bsDetailLevel);
    PdhiSysFreeString(& bsPerfDefault);
    VariantClear(& vName);
    VariantClear(& vClass);
    VariantClear(& vDetailLevel);

    if (pEnum != NULL) pEnum->Release();

    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        pThisServer->pObjList = pHead;
    }
    else {
        pObject = pHead;
        while (pObject != NULL) {
            pHead   = pObject->pNext;
            G_FREE(pObject);
            pObject = pHead;
        }
    }
    if (bDisconnectServer) {
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiDisconnectWbemServer(pThisServer);
        }
        else {
            // keep error code from function body
            PdhiDisconnectWbemServer(pThisServer);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumWbemObjects(
    LPCWSTR     szWideMachineName,
    LPVOID      mszObjectList,
    LPDWORD     pcchBufferSize,
    DWORD       dwDetailLevel,
    BOOL        bRefresh,       // ignored
    BOOL        bUnicode
)
{
    PDH_STATUS             pdhStatus;
    PPDHI_WBEM_SERVER_DEF  pThisServer;
    BOOL                   fCoInitialized = PdhiCoInitialize();

    pdhStatus = PdhiConnectWbemServer(szWideMachineName, & pThisServer);
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiEnumWbemServerObjects(pThisServer,
                                              mszObjectList,
                                              pcchBufferSize,
                                              dwDetailLevel,
                                              bRefresh,
                                              bUnicode);
    }
    if (fCoInitialized) {
        PdhiCoUninitialize();
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetDefaultWbemObject(
    LPCWSTR  szMachineName,
    LPVOID   szDefaultObjectName,
    LPDWORD  pcchBufferSize,
    BOOL     bUnicode
)
{
    // walk down the list of WBEM perf classes and find the one with the
    // default qualifier

    PDH_STATUS              pdhStatus;
    PPDHI_WBEM_SERVER_DEF   pThisServer;
    HRESULT                 hResult;
    DWORD                   dwBufferSize      = 0;
    DWORD                   dwStrLen;
    BOOL                    bDisconnectServer = FALSE;
    // CoInitialize() if we need to
    BOOL                    fCoInitialized    = PdhiCoInitialize();

    pdhStatus = PdhiConnectWbemServer(szMachineName, & pThisServer);

    if (pdhStatus == ERROR_SUCCESS) {
        bDisconnectServer = TRUE;
        if (pThisServer->pObjList == NULL) {
            DWORD dwSize = 0;
            pdhStatus = PdhiEnumWbemServerObjects(pThisServer,
                                                  NULL,
                                                  & dwSize,
                                                  PERF_DETAIL_WIZARD | PERF_DETAIL_COSTLY,
                                                  TRUE,
                                                  TRUE);
            if (pThisServer->pObjList != NULL) {
                pdhStatus = ERROR_SUCCESS;
            }
            else if (pdhStatus == PDH_MORE_DATA) {
                pdhStatus = PDH_WBEM_ERROR;
            }
        }
        if (pThisServer->pObjList != NULL) {
            PPDHI_WBEM_OBJECT_DEF pObject = pThisServer->pObjList;

            pdhStatus = PDH_CSTATUS_NO_OBJECT;
            while (pObject != NULL) {
                if (pObject->bDefault) {
                    pdhStatus = ERROR_SUCCESS;
                    if (bUnicode) {
                        dwStrLen = lstrlenW(pObject->szDisplay);
                        if (szDefaultObjectName != NULL && dwStrLen < * pcchBufferSize) {
                            StringCchCopyW((LPWSTR) szDefaultObjectName,
                                           * pcchBufferSize,
                                           pObject->szDisplay);
                        }
                        else {
                            pdhStatus = PDH_MORE_DATA;
                        }
                        dwBufferSize = dwStrLen + 1;
                    }
                    else {
                        dwStrLen = * pcchBufferSize;
                        pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                             pObject->szDisplay,
                                                             (LPSTR) szDefaultObjectName,
                                                             & dwStrLen);
                        dwBufferSize = dwStrLen;
                    }
                }
                pObject = pObject->pNext;
            }
        }
    }

    // return the size used or required
    * pcchBufferSize = dwBufferSize;

    if (bDisconnectServer) {
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiDisconnectWbemServer(pThisServer);
        }
        else {
            // keep error code from function body
            PdhiDisconnectWbemServer(pThisServer);
        }
    }

    // CoUninitialize if necessary
    if (fCoInitialized) {
        PdhiCoUninitialize();
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumWbemObjectItems(
    LPCWSTR  szWideMachineName,
    LPCWSTR  szWideObjectName,
    LPVOID   mszCounterList,
    LPDWORD  pcchCounterListLength,
    LPVOID   mszInstanceList,
    LPDWORD  pcchInstanceListLength,
    DWORD    dwDetailLevel,
    DWORD    dwFlags,
    BOOL     bUnicode
)
{
    PDH_STATUS              pdhStatus           = ERROR_SUCCESS;
    PDH_STATUS              CounterStatus       = ERROR_SUCCESS;
    PDH_STATUS              InstanceStatus      = ERROR_SUCCESS;
    DWORD                   dwStrLen;
    PPDHI_WBEM_SERVER_DEF   pThisServer;
    HRESULT                 hResult;
    DWORD                   dwReturnCount;
    DWORD                   dwCounterStringLen  = 0;
    DWORD                   dwInstanceStringLen = 0;
    LPWSTR                  szNextWideString    = NULL;
    LPSTR                   szNextAnsiString    = NULL;
    LPWSTR                  szObjectClassName   = NULL;
    BSTR                    bsName              = NULL;
    BSTR                    bsClassName         = NULL;
    BOOL                    bSingletonClass     = FALSE;
    VARIANT                 vName;
    DWORD                   bDisconnectServer   = FALSE;
    IWbemClassObject      * pThisClass          = NULL;
    IWbemQualifierSet     * pQualSet            = NULL;
    // CoInitialize() if we need to
    BOOL                    fCoInitialized      = PdhiCoInitialize();

    DBG_UNREFERENCED_PARAMETER (dwFlags);

    pdhStatus = PdhiConnectWbemServer(szWideMachineName, & pThisServer);
    // enumerate the instances
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiWbemGetObjectClassName(pThisServer, szWideObjectName, & szObjectClassName, & pThisClass);

        bDisconnectServer = TRUE;

        if (pdhStatus == ERROR_SUCCESS) {
            bSingletonClass = PdhiIsSingletonClass(pThisClass);
        }
        else if (pThisClass == NULL) {
            pdhStatus = PDH_CSTATUS_NO_OBJECT;
        }
        else {
            // unable to find matching perf class
            // return status returned by method
        }
    }

    //enumerate the counter properties
    if (pdhStatus == ERROR_SUCCESS) {
        SAFEARRAY * psaNames      = NULL;
        long        lLower; 
        long        lUpper        = 0;
        long        lCount;
        BSTR      * bsPropName    = NULL;
        BSTR        bsCountertype = NULL;
        BSTR        bsDisplayname = NULL;
        BSTR        bsDetailLevel = NULL;
        VARIANT     vCountertype;
        VARIANT     vDetailLevel;
        DWORD       dwItemDetailLevel;

        VariantInit(& vName);
        VariantInit(& vCountertype);
        VariantInit(& vDetailLevel);

        dwDetailLevel &= PERF_DETAIL_STANDARD; // mask off any inappropriate bits

        // get the properties of this class as a Safe Array
        hResult = pThisClass->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, & psaNames);
        if (hResult == WBEM_NO_ERROR) {
            hResult = SafeArrayGetLBound(psaNames, 1, & lLower);
            if (hResult == S_OK) {
                hResult = SafeArrayGetUBound(psaNames, 1, & lUpper);
            }
            if (hResult == S_OK) {
                szNextAnsiString = (LPSTR)  mszCounterList;
                szNextWideString = (LPWSTR) mszCounterList;
                bsCountertype    = SysAllocString(cszCountertype);
                bsDisplayname    = SysAllocString(cszDisplayname);
                bsDetailLevel    = SysAllocString(cszPerfdetail);
                if (bsCountertype && bsDisplayname && bsDetailLevel) {
                    hResult = SafeArrayAccessData(psaNames, (LPVOID *) & bsPropName);
                    if (SUCCEEDED(hResult)) {
                        for (lCount = lLower; lCount <= lUpper; lCount++) {
                            // get the qualifier set for this property
                            hResult = pThisClass->GetPropertyQualifierSet(bsPropName[lCount], & pQualSet);
                            if (hResult == WBEM_NO_ERROR) {
                                LONG    lCounterType;
                                hResult = pQualSet->Get(bsDetailLevel, 0, & vDetailLevel, 0);
                                if (hResult == S_OK) {
                                    dwItemDetailLevel = (DWORD) V_I4(& vDetailLevel);
                                }
                                else {
                                    dwItemDetailLevel = 0;
                                }

                                // make sure this is a perf counter property
                                hResult = pQualSet->Get (bsCountertype, 0, & vCountertype, NULL);
                                if (hResult == WBEM_NO_ERROR) {
                                    lCounterType = V_I4(& vCountertype);
                                    // then see if this is a displayable counter
                                    if ((!(lCounterType & PERF_DISPLAY_NOSHOW) ||
                                                    (lCounterType == PERF_AVERAGE_BULK)) &&
                                                    (dwItemDetailLevel <= dwDetailLevel)) {
                                        // by testing for the counter type
                                        // get the display name for this property
                                        hResult = pQualSet->Get (bsDisplayname, 0, & vName, NULL);
                                        if (hResult == WBEM_NO_ERROR && vName.vt == VT_BSTR) {
                                            // display name found
                                            if (bUnicode) {
                                                dwStrLen = lstrlenW(V_BSTR(& vName)) + 1;
                                                if ((mszCounterList != NULL)
                                                        && ((dwCounterStringLen + dwStrLen)
                                                                <= (* pcchCounterListLength))) {
                                                    StringCchCopyW(szNextWideString,
                                                                   * pcchCounterListLength - dwCounterStringLen,
                                                                   V_BSTR(& vName));
                                                    szNextWideString += dwStrLen;
                                                }
                                                else {
                                                    pdhStatus = PDH_MORE_DATA;
                                                }
                                            }
                                            else {
                                                dwStrLen = (dwCounterStringLen < * pcchCounterListLength)
                                                         ? (* pcchCounterListLength - dwCounterStringLen)
                                                         : (0);
                                                 pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                         V_BSTR(& vName), szNextAnsiString, & dwStrLen);
                                                 if (pdhStatus == ERROR_SUCCESS) {
                                                    szNextAnsiString += dwStrLen;
                                                 }
                                            }
                                            dwCounterStringLen += dwStrLen;
                                        }
                                    }
                                    else {
                                        // this is a "don't show" counter so skip it
                                    }
                                }
                                else {
                                    // unable to get the counter type so it's probably
                                    // not a perf counter property, skip it and continue
                                }
                                VariantClear(& vName);
                                VariantClear(& vCountertype);
                                VariantClear(& vDetailLevel);

                                pQualSet->Release();
                            }
                            else {
                                // no properties so continue with the next one
                            }
                        } // end for each element in SafeArray
                        SafeArrayUnaccessData(psaNames);
                    }
                    else {
                        // unable to read element in SafeArray
                        pdhStatus = PDH_WBEM_ERROR;
                        SetLastError(hResult);
                    }
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                PdhiSysFreeString(& bsCountertype);
                PdhiSysFreeString(& bsDisplayname);
                PdhiSysFreeString(& bsDetailLevel);
            }
            else {
                // unable to get array boundries
                pdhStatus = PDH_WBEM_ERROR;
                SetLastError(hResult);
            }
        }
        else {
            // unable to get property strings
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError(hResult);
        }

        dwCounterStringLen ++; // final NULL for MSZ
        if (dwCounterStringLen > * pcchCounterListLength) {
            pdhStatus = PDH_MORE_DATA;
        }

        if (pdhStatus == ERROR_SUCCESS) {
            if (bUnicode) {
                if (szNextWideString != NULL) {
                    if (szNextWideString != (LPWSTR) mszCounterList) {
                        * szNextWideString ++ = L'\0';
                    }
                    else {
                        // nothing returned
                        dwCounterStringLen = 0;
                    }
                }
                else {
                    // then this is just a length query so return
                    // include the the MSZ term null char
                    CounterStatus = PDH_MORE_DATA;
                }
            }
            else {
                if (szNextAnsiString != NULL) {
                    if (szNextAnsiString != (LPSTR) mszCounterList) {
                        * szNextAnsiString ++ = '\0';
                    }
                    else {
                        dwCounterStringLen = 0;
                    }
                }
                else {
                    // then this is just a length query so return
                    // include the the MSZ term null char
                    CounterStatus = PDH_MORE_DATA;
                }
            }
        }
        else {
            CounterStatus = pdhStatus;
        }

        VariantClear(& vName);
        VariantClear(& vCountertype);
        VariantClear(& vDetailLevel);

                // Clear the SafeArray if it exists
        if (NULL != psaNames) {
            SafeArrayDestroy(psaNames);
            psaNames = NULL;
        }

        * pcchCounterListLength = dwCounterStringLen;

        //pThisClass->Release();
    }

    // Get instance strings if necessary

    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        szNextAnsiString = (LPSTR)  mszInstanceList;
        szNextWideString = (LPWSTR) mszInstanceList;

        if (! bSingletonClass) {
            IWbemRefresher           * pRefresher    = NULL;
            IWbemConfigureRefresher  * pConfig       = NULL;
            IWbemHiPerfEnum          * pEnum         = NULL;
            LONG                       lID;
            DWORD                      dwNumReturned = 1;
            DWORD                      dwNumObjects  = 0;
            DWORD                      i;
            IWbemObjectAccess       ** apEnumAccess  = NULL;
            CIMTYPE                    cimType;
            WCHAR                      szName[SMALL_BUFFER_SIZE];
            LONG                       lNameHandle   = -1;
            LONG                       lSize1        = SMALL_BUFFER_SIZE;
            LONG                       lSize2        = 0;

            hResult = CoCreateInstance(CLSID_WbemRefresher,
                                       NULL,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IWbemRefresher,
                                       (void **) & pRefresher);
            if (SUCCEEDED(hResult)) {
                hResult = pRefresher->QueryInterface(IID_IWbemConfigureRefresher,
                                                     (void **) & pConfig);
                if (SUCCEEDED(hResult)) {
                    hResult = pConfig->AddEnum(pThisServer->pSvc, szObjectClassName, 0, NULL, & pEnum, & lID);
                    if (SUCCEEDED(hResult)) {
                        hResult = pRefresher->Refresh(0L);
                        if (SUCCEEDED(hResult)) {
                            hResult = pEnum->GetObjects(0L, dwNumObjects, apEnumAccess, & dwNumReturned);
                            if (hResult == WBEM_E_BUFFER_TOO_SMALL) {
                                apEnumAccess = (IWbemObjectAccess **)
                                        G_ALLOC(dwNumReturned * sizeof(IWbemObjectAccess *));
                                if (apEnumAccess != NULL) {
                                    ZeroMemory(apEnumAccess, dwNumReturned * sizeof(IWbemObjectAccess *));
                                    dwNumObjects = dwNumReturned;
                                    hResult = pEnum->GetObjects(0L, dwNumObjects, apEnumAccess, & dwNumReturned);
                                }
                                else {
                                    hResult = WBEM_E_OUT_OF_MEMORY;
                                }
                            }
                            if (SUCCEEDED(hResult)) {
                                for (i = 0; i < dwNumReturned; i ++) {
                                    hResult = apEnumAccess[i]->GetPropertyHandle(cszName, & cimType, & lNameHandle);
                                    if (SUCCEEDED(hResult) && lNameHandle != -1) {
                                        ZeroMemory(szName, SMALL_BUFFER_SIZE * sizeof(WCHAR));
                                        hResult = apEnumAccess[i]->ReadPropertyValue(
                                                        lNameHandle, lSize1 * sizeof(WCHAR), & lSize2, (LPBYTE) szName);
                                        if (SUCCEEDED(hResult) && lstrlenW(szName) > 0) {
                                            if (bUnicode) {
                                                dwStrLen = lstrlenW(szName) + 1;
                                                if ((mszInstanceList != NULL)
                                                        && ((dwInstanceStringLen + dwStrLen)
                                                                 < (* pcchInstanceListLength))) {
                                                    StringCchCopyW(szNextWideString,
                                                                   * pcchInstanceListLength - dwInstanceStringLen,
                                                                   szName);
                                                    szNextWideString += dwStrLen;
                                                }
                                                else {
                                                    pdhStatus = PDH_MORE_DATA;
                                                }
                                            }
                                            else {
                                                dwStrLen = (dwInstanceStringLen <= * pcchInstanceListLength)
                                                         ? (* pcchInstanceListLength - dwInstanceStringLen)
                                                         : (0);
                                                pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                                                     szName,
                                                                                     szNextAnsiString,
                                                                                     & dwStrLen);
                                                if (pdhStatus == ERROR_SUCCESS) {
                                                    szNextAnsiString += dwStrLen;
                                                }
                                            }
                                            dwInstanceStringLen += dwStrLen;
                                        }
                                    }
                                    apEnumAccess[i]->Release();
                                }
                            }
                        }
                    }
                }
            }

            if (! SUCCEEDED(hResult)) {
                IEnumWbemClassObject * pEnumObject = NULL;
                bsName = SysAllocString(cszName);
                bsClassName = SysAllocString(szObjectClassName);
                if (bsName && bsClassName) {
                    // get Create enumerator for this class and get the instances
                    hResult = pThisServer->pSvc->CreateInstanceEnum(bsClassName, WBEM_FLAG_DEEP, NULL, & pEnumObject);
                    if (SUCCEEDED(hResult)) {
                        hResult = SetWbemSecurity(pEnumObject);
                    }

                    if (hResult != WBEM_NO_ERROR) {
                        pdhStatus = PDH_WBEM_ERROR;
                        SetLastError(hResult);
                    }
                    else {
                        LPWSTR szInstance;

                        while (TRUE) {
                            hResult = pEnumObject->Next(WBEM_INFINITE, 1, & pThisClass, & dwReturnCount);
                            if ((pThisClass == NULL) || (dwReturnCount == 0)) {
                                // no more instances
                                break;
                            }
                            else {
                                // name of this instance is in the NAME property
                                hResult = pThisClass->Get(bsName, 0, & vName, 0, 0);
                                if (hResult == WBEM_NO_ERROR) {
                                    szInstance = (LPWSTR) V_BSTR(& vName);
                                    if (bUnicode) {
                                        dwStrLen = lstrlenW(szInstance) + 1;
                                        if ((mszInstanceList != NULL)
                                                && ((dwInstanceStringLen + dwStrLen)
                                                         < (* pcchInstanceListLength))) {
                                            StringCchCopyW(szNextWideString,
                                                           * pcchInstanceListLength - dwInstanceStringLen,
                                                           szInstance);
                                            szNextWideString += dwStrLen;
                                        }
                                        else {
                                            pdhStatus = PDH_MORE_DATA;
                                        }
                                    }
                                    else {
                                        dwStrLen = (dwInstanceStringLen <= * pcchInstanceListLength)
                                                 ? (* pcchInstanceListLength - dwInstanceStringLen)
                                                 : (0);
                                        pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                                             szInstance,
                                                                             szNextAnsiString,
                                                                             & dwStrLen);
                                        if (pdhStatus == ERROR_SUCCESS) {
                                            szNextAnsiString += dwStrLen;
                                        }
                                    }
                                    dwInstanceStringLen += dwStrLen;
                                }
                                // clear the variant
                                VariantClear(& vName);
                            }
                            pThisClass->Release();
                        }
                    }
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                PdhiSysFreeString(& bsClassName);
                PdhiSysFreeString(& bsName);
                if (pEnumObject != NULL) pEnumObject->Release();
            }
            if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
                if (! SUCCEEDED(hResult)) {
                    SetLastError(hResult);
                    pdhStatus = PDH_WBEM_ERROR;
                }
                else if (dwInstanceStringLen == 0) {
                    dwInstanceStringLen = 2;
                    if (szNextWideString != NULL && dwInstanceStringLen <= * pcchInstanceListLength) {
                        * szNextWideString = L'\0';
                        szNextWideString ++;
                    }
                    if (szNextAnsiString != NULL && dwInstanceStringLen <= * pcchInstanceListLength) {
                        * szNextAnsiString = '\0';
                        szNextAnsiString ++;
                    }
                }
                else {
                    dwInstanceStringLen ++;
                }
            }

            G_FREE(apEnumAccess);
            if (pEnum        != NULL) pEnum->Release();
            if (pConfig      != NULL) pConfig->Release();
            if (pRefresher   != NULL) pRefresher->Release();
        }

        if (dwInstanceStringLen > * pcchInstanceListLength) {
            pdhStatus = PDH_MORE_DATA;
        }
        if (pdhStatus == ERROR_SUCCESS) {
            if (bUnicode) {
                if (szNextWideString != NULL) {
                    if (szNextWideString != (LPWSTR) mszInstanceList) {
                        * szNextWideString ++ = L'\0';
                    }
                    else {
                        dwInstanceStringLen = 0;
                    }
                }
                else if (dwInstanceStringLen > 0) {
                    // then this is just a length query so return
                    // include the the MSZ term null char
                    InstanceStatus = PDH_MORE_DATA;
                }
            }
            else {
                if (szNextAnsiString != NULL) {
                    if (szNextAnsiString != (LPSTR)mszInstanceList) {
                        * szNextAnsiString ++ = '\0';
                    }
                    else {
                        dwInstanceStringLen = 0;
                    }
                }
                else if (dwInstanceStringLen > 0) {
                    // then this is just a length query so return
                    // include the the MSZ term null char
                    InstanceStatus = PDH_MORE_DATA;
                }
            }
        }
        else {
            InstanceStatus = pdhStatus;
        }
        * pcchInstanceListLength = dwInstanceStringLen;
    }

    VariantClear(& vName);

    if (bDisconnectServer) {
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiDisconnectWbemServer(pThisServer);
        }
        else {
            // keep error code from function body
            PdhiDisconnectWbemServer(pThisServer);
        }
    }

    // CoUninitialize if necessary
    if (fCoInitialized) {
        PdhiCoUninitialize();
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = (CounterStatus == ERROR_SUCCESS) ? (InstanceStatus) : (CounterStatus);
    }
    G_FREE(szObjectClassName);
    return pdhStatus;
}
#pragma warning ( default : 4127 )

PDH_FUNCTION
PdhiGetDefaultWbemProperty(
    LPCWSTR   szMachineName,
    LPCWSTR   szObjectName,
    LPVOID    szDefaultCounterName,
    LPDWORD   pcchBufferSize,
    BOOL      bUnicode
)
{
    PDH_STATUS            pdhStatus          = ERROR_SUCCESS;
    DWORD                 dwStrLen;
    PPDHI_WBEM_SERVER_DEF pThisServer;
    HRESULT               hResult;
    DWORD                 dwCounterStringLen = 0;
    LPWSTR                szObjectClassName  = NULL;
    DWORD                 bDisconnectServer  = FALSE;
    BOOL                  bFound             = FALSE;
    long                  lFound             = -1;
    long                  lFirst             = -1;
    IWbemClassObject    * pThisClass         = NULL;
    IWbemQualifierSet   * pQualSet           = NULL;
    // CoInitialize() if we need to
    BOOL                  fCoInitialized     = PdhiCoInitialize();

    pdhStatus = PdhiConnectWbemServer(szMachineName, & pThisServer);
    // enumerate the instances
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus         = PdhiWbemGetObjectClassName(pThisServer, szObjectName, & szObjectClassName, & pThisClass);
        bDisconnectServer = TRUE;
    }

    //enumerate the counter properties

    if (pdhStatus == ERROR_SUCCESS) {
        SAFEARRAY * psaNames      = NULL;
        long        lLower; 
        long        lUpper        = 0;
        long        lCount;
        BSTR      * bsPropName    = NULL;
        BSTR        bsFirstName   = NULL;
        BSTR        bsDisplayname = NULL;
        BSTR        bsPerfDefault = NULL;
        VARIANT     vName, vCountertype;

        VariantInit(& vName);
        VariantInit(& vCountertype);

        // get the properties of this class as a Safe Array
        hResult = pThisClass->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, & psaNames);
        if (hResult == WBEM_NO_ERROR) {
            hResult = SafeArrayGetLBound(psaNames, 1, & lLower);
            if (hResult == S_OK) {
                hResult = SafeArrayGetUBound(psaNames, 1, & lUpper);
            }
            if (hResult == S_OK) {
                bsDisplayname = SysAllocString(cszDisplayname);
                bsPerfDefault = SysAllocString(cszPerfdefault);
                if (bsDisplayname && bsPerfDefault) {
                    bFound = FALSE;
                    lFound = -1;
                    hResult = SafeArrayAccessData(psaNames, (LPVOID *) & bsPropName);
                    if (SUCCEEDED(hResult)) {
                        for (lCount = lLower; lCount <= lUpper; lCount ++) {
                            hResult = pThisClass->GetPropertyQualifierSet(bsPropName[lCount], & pQualSet);
                            if (hResult == WBEM_NO_ERROR) {
                                if (lFirst < 0) {
                                    hResult = pQualSet->Get(bsDisplayname, 0, & vName, NULL);
                                    if (hResult == WBEM_NO_ERROR) {
                                        lFirst = lCount;
                                        VariantClear(& vName);
                                    }
                                }
                                hResult = pQualSet->Get(bsPerfDefault, 0, & vCountertype, NULL);
                                if (hResult == WBEM_NO_ERROR) {
                                    if ((BOOL) V_BOOL(& vCountertype)) {
                                        bFound = TRUE;
                                        lFound = lCount;
                                    }
                                    VariantClear(& vCountertype);
                                }
                                pQualSet->Release();
                            }

                            if (bFound) break;
                        }
                        SafeArrayUnaccessData(psaNames);
                    }

                    if (lFound < 0) lFound = lFirst;
                    if (lFound < 0) {
                        pdhStatus = PDH_WBEM_ERROR;
                        SetLastError(PDH_WBEM_ERROR);
                    }
                    else {
                        hResult = SafeArrayGetElement(psaNames, & lFound, & bsFirstName);
                        if (hResult == S_OK) {
                            // get the qualifier set for this property
                            hResult = pThisClass->GetPropertyQualifierSet(bsFirstName, & pQualSet);
                            if (hResult == WBEM_NO_ERROR) {
                                // found the default property so load it and return
                                hResult = pQualSet->Get(bsDisplayname, 0, & vName, NULL);
                                if (hResult == WBEM_NO_ERROR) {
                                    // display name found
                                    if (bUnicode) {
                                        dwStrLen = lstrlenW(V_BSTR(&vName)) + 1;
                                        if ((szDefaultCounterName != NULL) && (dwStrLen <= * pcchBufferSize)) {
                                            StringCchCopyW((LPWSTR) szDefaultCounterName,
                                                           * pcchBufferSize,
                                                           (LPWSTR) V_BSTR(& vName));
                                        }
                                        else {
                                            pdhStatus = PDH_MORE_DATA;
                                        }
                                    }
                                    else {
                                        dwStrLen = * pcchBufferSize;
                                        pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                                            (LPWSTR) V_BSTR(& vName),
                                                                            (LPSTR)  szDefaultCounterName,
                                                                            & dwStrLen);
                                    }
                                    // this is either the amount used or the amount needed
                                    dwCounterStringLen = dwStrLen;
                                    // free qualifier set
                                    VariantClear(& vName);
                                }
                                pQualSet->Release();
                            }
                            PdhiSysFreeString(& bsFirstName);
                        }
                        else {
                            // unable to read element in SafeArray
                            pdhStatus = PDH_WBEM_ERROR;
                            SetLastError(hResult);
                        }
                    }
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                PdhiSysFreeString(& bsPerfDefault);
                PdhiSysFreeString(& bsDisplayname);
            }
            else {
                // unable to get array boundries
                pdhStatus = PDH_WBEM_ERROR;
                SetLastError(hResult);
            }
        }
        else {
            // unable to get property strings
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError(hResult);
        }

        if (NULL != psaNames) {
            SafeArrayDestroy(psaNames);
        }

        VariantClear(& vName);
        VariantClear(& vCountertype);

        //pThisClass->Release();
    }
    * pcchBufferSize = dwCounterStringLen;

    if (bDisconnectServer) {
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiDisconnectWbemServer(pThisServer);
        }
        else {
            // keep error code from function body
            PdhiDisconnectWbemServer(pThisServer);
        }
    }

    // CoUninitialize if necessary
    if (fCoInitialized) {
        PdhiCoUninitialize();
    }
    G_FREE(szObjectClassName);
    return pdhStatus;
}

PDH_FUNCTION
PdhiEncodeWbemPathW(
    PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElements,
    LPWSTR                       szFullPathBuffer,
    LPDWORD                      pcchBufferSize,
    LANGID                       LangId,
    DWORD                        dwFlags
)
/*++

  converts a set of path elements in either Registry or WBEM format
  to a path in either Registry or WBEM format as defined by the flags.

--*/
{
    PDH_STATUS              pdhStatus           = ERROR_SUCCESS;
    DWORD                   dwBuffSize;
    LPWSTR                  szTempPath          = NULL;
    LPWSTR                  szTempObjectString  = NULL;
    LPWSTR                  szTempCounterString = NULL;
    DWORD                   dwCurSize           = 0;
    LPWSTR                  szThisChar;
    IWbemClassObject      * pWbemClass          = NULL;
    PPDHI_WBEM_SERVER_DEF   pWbemServer         = NULL;
    DWORD                   bDisconnectServer   = FALSE;
    // CoInitialize() if we need to
    BOOL                    fCoInitialized      = PdhiCoInitialize();
    BOOL                    bObjectColon        = FALSE;

    DBG_UNREFERENCED_PARAMETER(LangId);

    // create a working buffer the same size as the one passed in

    if (pCounterPathElements->szMachineName != NULL) {
        dwBuffSize = lstrlenW(pCounterPathElements->szMachineName) + 1;
    }
    else {
        dwBuffSize = lstrlenW(cszDoubleBackSlashDot) + 1;
    }
    if (pCounterPathElements->szObjectName != NULL) {
        // then the input is different from the output
        // so convert from one to the other
        // and default name space since perf counters won't be
        // found elsewhere
        pdhStatus = PdhiConnectWbemServer( NULL, & pWbemServer);
        if (pdhStatus == ERROR_SUCCESS) {
            bDisconnectServer = TRUE;
            if (dwFlags & PDH_PATH_WBEM_INPUT) {
                // convert the WBEM Class to the display name
                pdhStatus = PdhiWbemGetClassDisplayName(pWbemServer,
                                                        pCounterPathElements->szObjectName,
                                                        & szTempObjectString,
                                                        & pWbemClass);
                // add a backslash path separator for registry output
                if (pdhStatus == ERROR_SUCCESS) {
                    if (dwFlags & PDH_PATH_WBEM_RESULT) {
                        bObjectColon  = TRUE;
                        dwBuffSize   += lstrlenW(cszColon);
                        G_FREE(szTempObjectString);
                        szTempObjectString = (LPWSTR) G_ALLOC(
                                        (lstrlenW(pCounterPathElements->szObjectName) + 1) * sizeof(WCHAR));
                        if (szTempObjectString != NULL) {
                            StringCchCopyW(szTempObjectString,
                                           lstrlenW(pCounterPathElements->szObjectName) + 1,
                                           pCounterPathElements->szObjectName);
                        }
                        else {
                            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        }
                    }
                    else {
                        dwBuffSize += lstrlenW(cszBackSlash);
                    }
                }
            }
            else {
                // convert the display name to a Wbem class name
                pdhStatus = PdhiWbemGetObjectClassName(pWbemServer,
                                                       pCounterPathElements->szObjectName,
                                                       & szTempObjectString,
                                                       & pWbemClass);
                // add a colon path separator
                bObjectColon  = TRUE;
                dwBuffSize   += lstrlenW(cszColon);
            }
            if (pdhStatus == ERROR_SUCCESS) {
                //then add the string
                dwBuffSize += lstrlenW(szTempObjectString);
            }
            if (bDisconnectServer) {
                if (pdhStatus == ERROR_SUCCESS) {
                    pdhStatus = PdhiDisconnectWbemServer(pWbemServer);
                }
                else {
                    // keep error code from function body
                    PdhiDisconnectWbemServer(pWbemServer);
                }
            }
        }
    }
    else {
        pdhStatus = PDH_CSTATUS_NO_OBJECT;
    }
    if (pCounterPathElements->szInstanceName != NULL) {
        dwBuffSize += lstrlenW(cszLeftParen) + lstrlenW(pCounterPathElements->szInstanceName) + lstrlenW(cszRightParen);
        if (pCounterPathElements->szParentInstance != NULL) {
            dwBuffSize += lstrlenW(pCounterPathElements->szParentInstance) + lstrlenW(cszSlash);
        }
    }
    if (pdhStatus == ERROR_SUCCESS) { 
        if (pCounterPathElements->szCounterName != NULL) {
            // then the input is different from the output
            // so convert from one to the other
            // and default name space since perf counters won't be
            // found elsewhere
            // add a backslash path separator
            dwBuffSize += lstrlenW(cszBackSlash);
            if (dwFlags & PDH_PATH_WBEM_INPUT) {
                // convert the WBEM Class to the display name
                pdhStatus = PdhiWbemGetCounterDisplayName(pWbemClass,
                                                          pCounterPathElements->szCounterName,
                                                          & szTempCounterString);
                if (pdhStatus == ERROR_SUCCESS) {
                    if (dwFlags & PDH_PATH_WBEM_RESULT) {
                        // just copy the string, but save
                        // the class pointer
                        G_FREE(szTempCounterString);
                        szTempCounterString = (LPWSTR) G_ALLOC(
                                        (lstrlenW(pCounterPathElements->szCounterName) + 1) * sizeof(WCHAR));
                        if (szTempCounterString != NULL) {
                            StringCchCopyW(szTempCounterString,
                                           lstrlenW(pCounterPathElements->szCounterName) + 1,
                                           pCounterPathElements->szCounterName);
                        }
                        else {
                            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        }
                    }
                }
            }
            else {
                // convert the display name to a Wbem class name
                pdhStatus = PdhiWbemGetCounterPropertyName(pWbemClass,
                                                           pCounterPathElements->szCounterName,
                                                           & szTempCounterString);
            }
            if (pdhStatus == ERROR_SUCCESS) {
                //then add the string
                dwBuffSize += lstrlenW(szTempCounterString);
            }
        }
        else {
            // no object name, so bad structure
            pdhStatus = PDH_CSTATUS_NO_COUNTER;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        szTempPath = (LPWSTR) G_ALLOC(dwBuffSize * sizeof(WCHAR));
        if (szTempPath == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // start by adding the machine name to the path
        if (pCounterPathElements->szMachineName != NULL) {
            StringCchCopyW(szTempPath, dwBuffSize, pCounterPathElements->szMachineName);
            if (dwFlags == (PDH_PATH_WBEM_INPUT)) {
                // if this is a wbem element in to a registry path out,
                // then remove the namespace which occurs starting at the
                // second backslash
                for (szThisChar = & szTempPath[2];
                            (* szThisChar != L'\0') && (* szThisChar != L'\\');
                            szThisChar ++);
                if (* szThisChar != L'\0') * szThisChar = L'\0';
            }
            else if (dwFlags == (PDH_PATH_WBEM_RESULT)) {
                // if this is a registry element in to a WBEM out, then
                // append the default namespace to the machine name
                // NAMEFIX lstrcatW(szTempPath, cszWbemDefaultPerfRoot);
            }
        }
        else {
            // no machine name specified so add the default machine
            // and default namespace for a wbem output path
            if (dwFlags == (PDH_PATH_WBEM_RESULT)) {
                StringCchCopyW(szTempPath, dwBuffSize, cszDoubleBackSlashDot); // default machine
                //NAMEFIX lstrcatW(szTempPath, cszWbemDefaultPerfRoot);
            }
            else {
                // no entry required for the registry path
            }
        }

        // now add the object or class name
        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements->szObjectName != NULL) {
                // then the input is different from the output
                // so convert from one to the other
                // and default name space since perf counters won't be
                // found elsewhere
                if (bObjectColon) {
                    StringCchCatW(szTempPath, dwBuffSize, cszColon);
                }
                else {
                    StringCchCatW(szTempPath, dwBuffSize, cszBackSlash);
                }
                StringCchCatW(szTempPath, dwBuffSize, szTempObjectString);
            }
            else {
                // no object name, so bad structure
                pdhStatus = PDH_CSTATUS_NO_OBJECT;
            }

        }

        // check for instance entries to add before adding the counter.
        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements->szInstanceName != NULL) {
                StringCchCatW(szTempPath, dwBuffSize, cszLeftParen);
                if (pCounterPathElements->szParentInstance != NULL) {
                    StringCchCatW(szTempPath, dwBuffSize, pCounterPathElements->szParentInstance);
                    StringCchCatW(szTempPath, dwBuffSize, cszSlash);
                }
                StringCchCatW(szTempPath, dwBuffSize, pCounterPathElements->szInstanceName);
                StringCchCatW(szTempPath, dwBuffSize, cszRightParen);
            }
        }

        // add counter name
        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements->szCounterName != NULL) {
                StringCchCatW(szTempPath, dwBuffSize, cszBackSlash);
                StringCchCatW(szTempPath, dwBuffSize, szTempCounterString);
            }
            else {
                pdhStatus = PDH_CSTATUS_NO_COUNTER;
            }
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        dwCurSize = lstrlenW(szTempPath) + 1;
        // copy path to the caller's buffer if it will fit
        if (szFullPathBuffer != NULL && (dwCurSize < * pcchBufferSize)) {
            StringCchCopyW(szFullPathBuffer, dwCurSize, szTempPath);
        }
        else {
            pdhStatus = PDH_MORE_DATA;
        }
        * pcchBufferSize = dwCurSize;
    }

    // CoUninitialize if necessary
    if (fCoInitialized) {
        PdhiCoUninitialize();
    }
    G_FREE(szTempPath);
    G_FREE(szTempObjectString);
    G_FREE(szTempCounterString);

    return pdhStatus;
}

PDH_FUNCTION
PdhiEncodeWbemPathA(
    PPDH_COUNTER_PATH_ELEMENTS_A pCounterPathElements,
    LPSTR                        szFullPathBuffer,
    LPDWORD                      pcchBufferSize,
    LANGID                       LangId,
    DWORD                        dwFlags
)
{
    PDH_STATUS                   pdhStatus = ERROR_SUCCESS;
    LPWSTR                       wszReturnBuffer;
    PPDH_COUNTER_PATH_ELEMENTS_W pWideCounterPathElements;
    DWORD                        dwcchBufferSize;
    DWORD                        dwBuffSize;

    // get required buffer size...
    dwBuffSize = sizeof (PDH_COUNTER_PATH_ELEMENTS_W);
    pWideCounterPathElements = (PPDH_COUNTER_PATH_ELEMENTS_W) G_ALLOC(sizeof(PDH_COUNTER_PATH_ELEMENTS_W));
    if (pWideCounterPathElements != NULL) {
        if (pCounterPathElements->szMachineName != NULL) {
            pWideCounterPathElements->szMachineName = PdhiMultiByteToWideChar(
                                           _getmbcp(), pCounterPathElements->szMachineName);
            if (pWideCounterPathElements->szMachineName == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        else {
            pWideCounterPathElements->szMachineName = NULL;
        }
        if (pCounterPathElements->szObjectName != NULL) {
            pWideCounterPathElements->szObjectName = PdhiMultiByteToWideChar(
                                           _getmbcp(), pCounterPathElements->szObjectName);
            if (pWideCounterPathElements->szObjectName == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        else {
            pWideCounterPathElements->szObjectName = NULL;
        }
        if (pCounterPathElements->szCounterName != NULL) {
            pWideCounterPathElements->szCounterName = PdhiMultiByteToWideChar(
                                           _getmbcp(), pCounterPathElements->szCounterName);
            if (pWideCounterPathElements->szCounterName == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        else {
            pWideCounterPathElements->szCounterName = NULL;
        }
        if (pCounterPathElements->szInstanceName != NULL) {
            pWideCounterPathElements->szInstanceName = PdhiMultiByteToWideChar(
                                           _getmbcp(), pCounterPathElements->szInstanceName);
            if (pWideCounterPathElements->szInstanceName == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        else {
            pWideCounterPathElements->szInstanceName = NULL;
        }
        if (pCounterPathElements->szParentInstance != NULL) {
            pWideCounterPathElements->szParentInstance = PdhiMultiByteToWideChar(
                                           _getmbcp(), pCounterPathElements->szParentInstance);
            if (pWideCounterPathElements->szParentInstance == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        else {
            pWideCounterPathElements->szParentInstance = NULL;
        }
        pWideCounterPathElements->dwInstanceIndex = pCounterPathElements->dwInstanceIndex;

        dwcchBufferSize = * pcchBufferSize;
        if (szFullPathBuffer != NULL) {
            wszReturnBuffer = (LPWSTR) G_ALLOC(dwcchBufferSize * sizeof(WCHAR));
            if (wszReturnBuffer == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        else {
            wszReturnBuffer = NULL;
        }

        if (pdhStatus == ERROR_SUCCESS) {
            // call wide function
            pdhStatus = PdhiEncodeWbemPathW(pWideCounterPathElements,
                                            wszReturnBuffer,
                                            & dwcchBufferSize,
                                            LangId,
                                            dwFlags);
            if ((pdhStatus == ERROR_SUCCESS) && (szFullPathBuffer != NULL)) {
                // convert the wide path back to ANSI
                pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(), wszReturnBuffer, szFullPathBuffer, pcchBufferSize);
            }
        }
        G_FREE(wszReturnBuffer);
        G_FREE(pWideCounterPathElements->szMachineName);
        G_FREE(pWideCounterPathElements->szObjectName);
        G_FREE(pWideCounterPathElements->szCounterName);
        G_FREE(pWideCounterPathElements->szInstanceName);
        G_FREE(pWideCounterPathElements->szParentInstance);
        G_FREE(pWideCounterPathElements);
    }
    else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiDecodeWbemPathW(
    LPCWSTR                      szFullPathBuffer,
    PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElements,
    LPDWORD                      pdwBufferSize,
    LANGID                       LangId,
    DWORD                        dwFlags
)
{
    PPDHI_COUNTER_PATH      pLocalCounterPath;
    PDH_STATUS              pdhStatus      = ERROR_SUCCESS;
    BOOL                    bMoreData      = FALSE;
    DWORD                   dwBufferSize   = * pdwBufferSize;
    DWORD                   dwUsed         = sizeof(PDH_COUNTER_PATH_ELEMENTS_W);
    DWORD                   dwString;
    DWORD                   dwSize;
    LPWSTR                  szString       = NULL;
    LPWSTR                  wszTempBuffer  = NULL;
    LPWSTR                  szSrc          = NULL;
    PPDHI_WBEM_SERVER_DEF   pThisServer    = NULL;
    IWbemClassObject      * pThisClass     = NULL;
    // CoInitialize() if we need to
    BOOL                    fCoInitialized = PdhiCoInitialize();

    DBG_UNREFERENCED_PARAMETER(LangId);

     // allocate a temporary work buffer
    dwSize = sizeof(PDHI_COUNTER_PATH) + 2 * sizeof(WCHAR)
                                           * (lstrlenW(szStaticLocalMachineName) + lstrlenW(szFullPathBuffer) + 3);
    pLocalCounterPath = (PPDHI_COUNTER_PATH) G_ALLOC(dwSize);
    if (pLocalCounterPath == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }
    else {
        // get WBEM server since we'll probably need it later
        if (ParseFullPathNameW(szFullPathBuffer,
                               & dwSize,
                               pLocalCounterPath,
                               (dwFlags & PDH_PATH_WBEM_INPUT ? TRUE : FALSE))) {
            // parsed successfully so load into user's buffer
            szString = (pCounterPathElements != NULL) ? ((LPWSTR) & pCounterPathElements[1]) : (NULL);
            if (pLocalCounterPath->szMachineName != NULL) {
                dwString = lstrlenW(pLocalCounterPath->szMachineName) + 1;
                if (szString != NULL && dwString * sizeof(WCHAR) + dwUsed <= dwBufferSize) {
                    pCounterPathElements->szMachineName = szString;
                    StringCbCopyW(szString, dwBufferSize - dwUsed, pLocalCounterPath->szMachineName);
                    szString += dwString;
                }
                else {
                    bMoreData                           = TRUE;
                    pCounterPathElements->szMachineName = NULL;
                    szString                            = NULL;
                }
                dwUsed += (dwString * sizeof(WCHAR));

                // Now that we have the proper machine name,
                // connect to the server if we need to
                if (dwFlags != (PDH_PATH_WBEM_INPUT | PDH_PATH_WBEM_RESULT)) {
                    pdhStatus = PdhiConnectWbemServer(pCounterPathElements->szMachineName, & pThisServer);
                }
                else {
                    // this will just be a copy operation
                    pdhStatus = ERROR_SUCCESS;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (pLocalCounterPath->szObjectName != NULL) {
                    if (dwFlags & PDH_PATH_WBEM_RESULT) {
                        if (dwFlags & PDH_PATH_WBEM_INPUT) {
                            // just copy
                            szSrc = pLocalCounterPath->szObjectName;
                        }
                        else {
                            // interpret the display name to a class name
                            pdhStatus = PdhiWbemGetObjectClassName(pThisServer,
                                                                   pLocalCounterPath->szObjectName,
                                                                   & wszTempBuffer,
                                                                   & pThisClass);
                            if (pdhStatus == ERROR_SUCCESS) {
                                szSrc = wszTempBuffer;
                            } 
                        }
                    }
                    else if (dwFlags & PDH_PATH_WBEM_INPUT) {
                        // translate class name to a display name
                        pdhStatus = PdhiWbemGetClassDisplayName(pThisServer,
                                                                pLocalCounterPath->szObjectName,
                                                                & wszTempBuffer,
                                                                & pThisClass);
                        if (pdhStatus == ERROR_SUCCESS) {
                            szSrc = wszTempBuffer;
                        }
                    }
                    if (pdhStatus == ERROR_SUCCESS) {
                        dwString = lstrlenW(szSrc) + 1;
                        if (szString != NULL && dwString * sizeof(WCHAR) + dwUsed <= dwBufferSize) {
                            pCounterPathElements->szObjectName = szString;
                            StringCbCopyW(szString, dwBufferSize - dwUsed, szSrc);
                            szString += dwString;
                        }
                        else {
                            bMoreData                          = TRUE;
                            pCounterPathElements->szObjectName = NULL;
                            szString                           = NULL;
                        }
                            dwUsed += (dwString * sizeof(WCHAR));
                    }
                    G_FREE(wszTempBuffer);
                    wszTempBuffer = NULL;
                }
                else {
                    pCounterPathElements->szObjectName = NULL;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (pLocalCounterPath->szInstanceName != NULL) {
                    dwString = lstrlenW(pLocalCounterPath->szInstanceName) + 1;
                    if (szString != NULL &&  dwString * sizeof(WCHAR) + dwUsed <= dwBufferSize) {
                        pCounterPathElements->szInstanceName = szString;
                        StringCbCopyW(szString, dwBufferSize - dwUsed, pLocalCounterPath->szInstanceName);
                        szString += dwString;
                    }
                    else {
                        bMoreData                            = TRUE;
                        pCounterPathElements->szInstanceName = NULL;
                        szString                             = NULL;
                    }
                    dwUsed += (dwString * sizeof(WCHAR));

                    if (pLocalCounterPath->szParentName != NULL) {
                        dwString = lstrlenW(pLocalCounterPath->szParentName) + 1;
                        if (szString != NULL &&  dwString * sizeof(WCHAR) + dwUsed <= dwBufferSize) {
                            pCounterPathElements->szParentInstance = szString;
                            StringCbCopyW(szString, dwBufferSize - dwUsed, pLocalCounterPath->szParentName);
                            szString += dwString;
                        }
                        else {
                            bMoreData                              = TRUE;
                            pCounterPathElements->szParentInstance = NULL;
                            szString                               = NULL;
                        }
                        dwUsed += (dwString * sizeof(WCHAR));
                    }
                    else {
                        pCounterPathElements->szParentInstance = NULL;
                    }
                    pCounterPathElements->dwInstanceIndex = pLocalCounterPath->dwIndex;
                }
                else {
                    pCounterPathElements->szInstanceName   = NULL;
                    pCounterPathElements->szParentInstance = NULL;
                    pCounterPathElements->dwInstanceIndex  = (DWORD) PERF_NO_UNIQUE_ID;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (pLocalCounterPath->szCounterName != NULL) {
                    if (dwFlags & PDH_PATH_WBEM_RESULT) {
                        if (dwFlags & PDH_PATH_WBEM_INPUT) {
                            // just copy
                            szSrc = pLocalCounterPath->szCounterName;
                        }
                        else {
                            // interpret the display name to a property name
                            pdhStatus = PdhiWbemGetCounterPropertyName(pThisClass,
                                                                       pLocalCounterPath->szCounterName,
                                                                       & wszTempBuffer);
                            if (pdhStatus == ERROR_SUCCESS) {
                                szSrc = wszTempBuffer;
                            }
                        }
                    }
                    else if (dwFlags & PDH_PATH_WBEM_INPUT) {
                        // translate class name to a display name
                        pdhStatus = PdhiWbemGetCounterDisplayName(pThisClass,
                                                                  pLocalCounterPath->szCounterName,
                                                                  & wszTempBuffer);
                        if (pdhStatus == ERROR_SUCCESS) {
                            szSrc = wszTempBuffer;
                        }
                    }
                    dwString = lstrlenW(szSrc) + 1;
                    if (szString != NULL &&  dwString * sizeof(WCHAR) + dwUsed <= dwBufferSize) {
                        pCounterPathElements->szCounterName = szString;
                        StringCbCopyW(szString, dwBufferSize - dwUsed, szSrc);
                        szString += dwString;
                    }
                    else {
                        bMoreData                           = TRUE;
                        pCounterPathElements->szCounterName = NULL;
                        szString                            = NULL;
                    }
                    dwUsed += (dwString * sizeof(WCHAR));
                }
                else {
                    pCounterPathElements->szCounterName = NULL;
                }
            }
            if (pdhStatus == ERROR_SUCCESS) {
                * pdwBufferSize = dwUsed;
                if (bMoreData) pdhStatus = PDH_MORE_DATA;
            }
        }
        else {
            // unable to read path
            pdhStatus = PDH_INVALID_PATH;
        }

        // Cleanup pThisServer if used
        if (NULL != pThisServer) {
            if (pdhStatus == ERROR_SUCCESS) {
                pdhStatus = PdhiDisconnectWbemServer(pThisServer);
            }
            else {
                // don't trash the return status
                PdhiDisconnectWbemServer(pThisServer);
            }
        }
    }

    // CoUninitialize if necessary
    if (fCoInitialized) {
        PdhiCoUninitialize();
    }
    G_FREE(pLocalCounterPath);
    G_FREE(wszTempBuffer);
    return pdhStatus;
}

PDH_FUNCTION
PdhiDecodeWbemPathA(
    LPCSTR                       szFullPathBuffer,
    PPDH_COUNTER_PATH_ELEMENTS_A pCounterPathElements,
    LPDWORD                      pdwBufferSize,
    LANGID                       LangId,
    DWORD                        dwFlags
)
{
    PDH_STATUS                   pdhStatus     = ERROR_SUCCESS;
    LPWSTR                       wszWidePath   = NULL;
    PPDH_COUNTER_PATH_ELEMENTS_W pWideElements = NULL;
    DWORD                        dwBufferSize;
    DWORD                        dwSize;
    DWORD                        dwDest        = 0;
    LONG                         lSizeRemaining;
    LPSTR                        szNextString;

    dwBufferSize = * pdwBufferSize;
    wszWidePath = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szFullPathBuffer);
    if (wszWidePath == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // compute size of temp element buffer
        if (dwBufferSize > sizeof(PDH_COUNTER_PATH_ELEMENTS_A)) {
            lSizeRemaining = dwBufferSize - sizeof(PDH_COUNTER_PATH_ELEMENTS_A);
        }
        else {
            lSizeRemaining = 0;
        }
        if (pCounterPathElements != NULL) {
            dwSize = sizeof(PDH_COUNTER_PATH_ELEMENTS_W)
                   + 2 * sizeof(WCHAR) * (lstrlenW(szStaticLocalMachineName) + lstrlenA(szFullPathBuffer) + 3);
            pWideElements = (PDH_COUNTER_PATH_ELEMENTS_W *) G_ALLOC(dwSize);
            if (pWideElements == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        else {
            pWideElements = NULL;
            pdhStatus     = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // convert path to Wide
        pdhStatus = PdhiDecodeWbemPathW(wszWidePath, pWideElements, & dwSize, LangId, dwFlags);
        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements != NULL) {
                // populate the fields of the caller's buffer
                szNextString = (LPSTR) & pCounterPathElements[1];
                if (pWideElements->szMachineName != NULL && lSizeRemaining > 0) {
                    dwDest    = lSizeRemaining;
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                         pWideElements->szMachineName,
                                                         szNextString,
                                                         & dwDest);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pCounterPathElements->szMachineName = szNextString;
                        szNextString += dwDest + 1;
                    }
                    else {
                        pCounterPathElements->szMachineName = NULL;
                    }
                    lSizeRemaining -= dwDest + 1;
                }
                else {
                    pCounterPathElements->szMachineName = NULL;
                }
                if (pWideElements->szObjectName != NULL && lSizeRemaining > 0) {
                    dwDest    = lSizeRemaining;
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                         pWideElements->szObjectName,
                                                         szNextString,
                                                         & dwDest);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pCounterPathElements->szObjectName = szNextString;
                        szNextString += dwDest + 1;
                    }
                    else {
                        pCounterPathElements->szObjectName = NULL;
                    }
                    lSizeRemaining -= dwDest + 1;
                }
                else {
                    pCounterPathElements->szObjectName = NULL;
                }
                if (pWideElements->szInstanceName != NULL && lSizeRemaining > 0) {
                    dwDest    = lSizeRemaining;
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                         pWideElements->szInstanceName,
                                                         szNextString,
                                                         & dwDest);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pCounterPathElements->szInstanceName = szNextString;
                        szNextString += dwDest + 1;
                    }
                    else {
                        pCounterPathElements->szInstanceName = NULL;
                    }
                    lSizeRemaining -= dwDest + 1;
                }
                else {
                    pCounterPathElements->szInstanceName = NULL;
                }
                if (pWideElements->szParentInstance != NULL && lSizeRemaining > 0) {
                    dwDest    = lSizeRemaining;
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                         pWideElements->szParentInstance,
                                                         szNextString,
                                                         & dwDest);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pCounterPathElements->szParentInstance = szNextString;
                        szNextString += dwDest + 1;
                    }
                    else {
                        pCounterPathElements->szParentInstance = NULL;
                    }
                    lSizeRemaining -= dwDest + 1;
                }
                else {
                    pCounterPathElements->szParentInstance = NULL;
                }

                if (pWideElements->szCounterName != NULL && lSizeRemaining > 0) {
                    dwDest    = lSizeRemaining;
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                         pWideElements->szObjectName,
                                                         szNextString,
                                                         & dwDest);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pCounterPathElements->szCounterName = szNextString;
                        szNextString   += dwDest + 1;
                    }
                    else {
                        pCounterPathElements->szCounterName = NULL;
                    }
                    lSizeRemaining -= dwDest + 1;
                }
                else {
                    pCounterPathElements->szCounterName = NULL;
                }
                pCounterPathElements->dwInstanceIndex = pWideElements->dwInstanceIndex;
                * pdwBufferSize = (DWORD) ((LPBYTE) szNextString - (LPBYTE) pCounterPathElements);
            }
            else {
                // just return the size required adjusted for wide/ansi characters
                * pdwBufferSize  = sizeof(PDH_COUNTER_PATH_ELEMENTS_A);
                dwSize          -= sizeof(PDH_COUNTER_PATH_ELEMENTS_W);
                dwSize          /= sizeof(WCHAR)/sizeof(CHAR);
                * pdwBufferSize += dwSize;
            }
        }
        else {
            // call to wide function failed so just return error
        }
    }
    else {
        // memory allocation failed so return error
    }
    G_FREE(pWideElements);
    G_FREE(wszWidePath);

    return pdhStatus;
}

BOOL
WbemInitCounter(
    PPDHI_COUNTER pCounter
)
/*++
Routine Description:
    Initialized the counter data structure by:
        Allocating the memory block to contain the counter structure
            and all the associated data fields. If this allocation
            is successful, then the fields are initialized by
            verifying the counter is valid.

Arguments:
    IN      PPDHI_COUNTER pCounter
        pointer of the counter to initialize using the system data

Return Value:
    TRUE if the counter was successfully initialized
    FALSE if a problem was encountered

    In either case, the CStatus field of the structure is updated to
    indicate the status of the operation.
--*/
{
    DWORD                          dwResult;
    PDH_STATUS                     pdhStatus          = ERROR_SUCCESS;
    PPDHI_WBEM_SERVER_DEF          pWbemServer        = NULL;
    DWORD                          dwLastError        = ERROR_SUCCESS;
    HRESULT                        hRes = S_OK;
    VARIANT                        vCountertype;
    LPWSTR                         szBasePropertyName = NULL;
    DWORD                          dwBasePropertyName;
    LPWSTR                         szFreqPropertyName = NULL;
    DWORD                          dwFreqPropertyName;
    LPWSTR                         szWbemItemPath     = NULL;
    ULONGLONG                      llValue;
    LONG                           lOffset;
    PPDH_COUNTER_PATH_ELEMENTS_W   pPathElem          = NULL;
    BOOL                           bReturn            = TRUE;
    DWORD                          dwBufferSize       = 0;
    BSTR                           bsPropName         = NULL;
    BSTR                           bsCountertype      = NULL;
    IWbemQualifierSet            * pQualSet           = NULL;
    PPDHI_COUNTER                  pCounterInList     = NULL;
    PPDHI_COUNTER_PATH             pPdhiCtrPath       = NULL;
    BOOL                           bMatchFound;
    DWORD                          bDisconnectServer  = FALSE;
    // CoInitialize() if we need to
    BOOL                           fCoInitialized     = PdhiCoInitialize();

    VariantInit(& vCountertype);

    pCounter->dwFlags |= PDHIC_WBEM_COUNTER; // make sure WBEM flag is set

    dwBasePropertyName = (DWORD) lstrlenW(pCounter->szFullName) + (DWORD) lstrlenW(cszBaseSuffix);
    if (dwBasePropertyName < (DWORD) lstrlenW(cszTimestampPerfTime)) {
        dwBasePropertyName = (DWORD) lstrlenW(cszTimestampPerfTime);
    }
    if (dwBasePropertyName < (DWORD) lstrlenW(cszTimestampSys100Ns)) {
        dwBasePropertyName = (DWORD) lstrlenW(cszTimestampSys100Ns);
    }
    if (dwBasePropertyName < (DWORD) lstrlenW(cszTimestampObject)) {
        dwBasePropertyName = (DWORD) lstrlenW(cszTimestampObject);
    }
    szBasePropertyName = (LPWSTR) G_ALLOC((dwBasePropertyName + 1) * sizeof(WCHAR));

    dwFreqPropertyName = (DWORD) lstrlenW(cszFrequencyPerfTime);
    if (dwFreqPropertyName < (DWORD) lstrlenW(cszFrequencySys100Ns)) {
        dwFreqPropertyName = (DWORD) lstrlenW(cszFrequencySys100Ns);
    }
    if (dwFreqPropertyName < (DWORD) lstrlenW(cszFrequencyObject)) {
        dwFreqPropertyName = (DWORD) lstrlenW(cszFrequencyObject);
    }
    szFreqPropertyName = (LPWSTR) G_ALLOC((dwFreqPropertyName + 1) * sizeof(WCHAR));

    if (szBasePropertyName == NULL || szFreqPropertyName == NULL) {
        dwLastError = PDH_MEMORY_ALLOCATION_FAILURE;
        bReturn     = FALSE;
    }

    // make sure the query has a refresher started already
    if (bReturn && pCounter->pOwner->pRefresher == NULL) {
        // it hasn't been started so start now
        dwResult = CoCreateRefresher(& pCounter->pOwner->pRefresher);
        if ((dwResult != S_OK) || (pCounter->pOwner->pRefresher == NULL)) {
            pCounter->pOwner->pRefresher = NULL;
            dwLastError                  = PDH_WBEM_ERROR;
            bReturn                      = FALSE;
        }
        else {
            // open config interface
            dwResult = pCounter->pOwner->pRefresher->QueryInterface(IID_IWbemConfigureRefresher,
                                                                    (LPVOID *) & pCounter->pOwner->pRefresherCfg);
            if (dwResult != S_OK) {
                pCounter->pOwner->pRefresherCfg = NULL;
                pCounter->pOwner->pRefresher->Release();
                pCounter->pOwner->pRefresher    = NULL;
                dwLastError                     = PDH_WBEM_ERROR;
                bReturn                         = FALSE;
            }
        }
    }

    if (bReturn) {
        // so far so good, now figure out the WBEM path to add it to the
        // refresher
        dwBufferSize  = lstrlenW(pCounter->szFullName) * sizeof(WCHAR) * 10;
        dwBufferSize += sizeof(PDH_COUNTER_PATH_ELEMENTS_W);

        pPathElem     = (PPDH_COUNTER_PATH_ELEMENTS_W) G_ALLOC(dwBufferSize);
        // the path is display names, so convert to WBEM class names first

        if (pPathElem == NULL) {
            dwLastError = PDH_MEMORY_ALLOCATION_FAILURE;
            bReturn = FALSE;
        }
        else {
            pdhStatus = PdhiDecodeWbemPathW(pCounter->szFullName,
                                            pPathElem,
                                            & dwBufferSize,
                                            pCounter->pOwner->LangID,
                                            PDH_PATH_WBEM_RESULT);
            if (pdhStatus != ERROR_SUCCESS) {
                dwLastError = PDH_INVALID_PATH;
                bReturn     = FALSE;
            }
        }
    }

    if (bReturn) {
        dwBufferSize *= 8; // just to be safe
        pPdhiCtrPath  = (PPDHI_COUNTER_PATH) G_ALLOC(dwBufferSize);
        if (pPdhiCtrPath == NULL) {
            dwLastError = PDH_MEMORY_ALLOCATION_FAILURE;
            bReturn = FALSE;
        }
        else {
            // break path into display elements
            bReturn = ParseFullPathNameW(pCounter->szFullName, & dwBufferSize, pPdhiCtrPath, FALSE);
            if (bReturn) {
                // realloc to use only the memory needed
                pCounter->pCounterPath = (PPDHI_COUNTER_PATH) G_REALLOC(pPdhiCtrPath, dwBufferSize);
                if ((pPdhiCtrPath != pCounter->pCounterPath) && (pCounter->pCounterPath != NULL)) {
                    // the memory block moved so
                    // correct addresses inside structure
                    lOffset = (LONG)((ULONG_PTR) pCounter->pCounterPath - (ULONG_PTR) pPdhiCtrPath);
                    if (pCounter->pCounterPath->szMachineName) {
                        pCounter->pCounterPath->szMachineName = (LPWSTR) (
                                (LPBYTE) pCounter->pCounterPath->szMachineName + lOffset);
                    }
                    if (pCounter->pCounterPath->szObjectName) {
                        pCounter->pCounterPath->szObjectName = (LPWSTR) (
                                (LPBYTE) pCounter->pCounterPath->szObjectName + lOffset);
                    }
                    if (pCounter->pCounterPath->szInstanceName) {
                        pCounter->pCounterPath->szInstanceName = (LPWSTR) (
                                (LPBYTE) pCounter->pCounterPath->szInstanceName + lOffset);
                    }
                    if (pCounter->pCounterPath->szParentName) {
                        pCounter->pCounterPath->szParentName = (LPWSTR) (
                                (LPBYTE) pCounter->pCounterPath->szParentName + lOffset);
                    }
                    if (pCounter->pCounterPath->szCounterName) {
                        pCounter->pCounterPath->szCounterName = (LPWSTR) (
                                (LPBYTE) pCounter->pCounterPath->szCounterName + lOffset);
                    }
                }
            }
            else {
                // free the buffer
                G_FREE(pPdhiCtrPath);
                dwLastError = PDH_WBEM_ERROR;
            }
        }
    }

    // connect to the WBEM Server on that machine
    if (bReturn) {
        pdhStatus = PdhiConnectWbemServer(pCounter->pCounterPath->szMachineName, & pWbemServer);
        if (pdhStatus != ERROR_SUCCESS) {
            dwLastError = pdhStatus;
            bReturn     = FALSE;
        }
        else {
            bDisconnectServer = TRUE;
        }
    }

    if (bReturn) {
        // make WBEM Instance path out of path elements
        pdhStatus = PdhiMakeWbemInstancePath(pPathElem, & szWbemItemPath, TRUE);

        // check for an object/class of this type that has already been added
        // walk down counter list to find a matching:
        //  machine\namespace
        //  object
        //  instance name
        if (pdhStatus != ERROR_SUCCESS) {
            dwLastError = pdhStatus;
            bReturn     = FALSE;
        }
    }

    if (bReturn) {
        pCounterInList = pCounter->pOwner->pCounterListHead;
        if (pCounterInList == NULL) {
            // then there are no entries to search so continue
        }
        else {
            do {
                // check for matching machine name
                if (lstrcmpiW(pCounterInList->pCounterPath->szMachineName,
                              pCounter->pCounterPath->szMachineName) == 0) {
                    // then the machine name matches

                    if (lstrcmpiW(pCounterInList->pCounterPath->szObjectName,
                                  pCounter->pCounterPath->szObjectName) == 0) {
                        // then the object name matches
                        // see if the instance matches

                        if (lstrcmpiW(pCounterInList->pCounterPath->szInstanceName,
                                      pCounter->pCounterPath->szInstanceName) == 0) {

                            bMatchFound = FALSE;
                            if (pCounter->pCounterPath->szParentName == NULL
                                            && pCounterInList->pCounterPath->szParentName == NULL) {
                                bMatchFound = TRUE;
                            }
                            else if (pCounter->pCounterPath->szParentName != NULL
                                            && pCounterInList->pCounterPath->szParentName != NULL
                                            && lstrcmpiW(pCounterInList->pCounterPath->szParentName,
                                                         pCounter->pCounterPath->szParentName) == 0) {
                                bMatchFound = TRUE;
                            }

                            if (bMatchFound) {
                                bMatchFound = FALSE;
                                if (pCounter->pCounterPath->dwIndex == pCounterInList->pCounterPath->dwIndex) {
                                    bMatchFound = TRUE;
                                }
                                else if (pCounter->pCounterPath->dwIndex == 0
                                                || pCounter->pCounterPath->dwIndex == PERF_NO_UNIQUE_ID) {
                                    if (pCounterInList->pCounterPath->dwIndex == 0
                                                    || pCounterInList->pCounterPath->dwIndex == PERF_NO_UNIQUE_ID) {
                                        bMatchFound = TRUE;
                                    }
                                }
                            }

                            if (bMatchFound) {
                                if ((pCounter->pCounterPath->szInstanceName != NULL) &&
                                                (* pCounter->pCounterPath->szInstanceName == SPLAT_L)) {
                                    // then this is a Wild Card or multiple instance path
                                    // see if an enumerator for this object has already been created
                                    // if so, then AddRef it
                                    if (pCounterInList->pWbemEnum != NULL) {
                                        pCounter->pWbemObject = pCounterInList->pWbemObject;
                                        pCounter->pWbemEnum   = pCounterInList->pWbemEnum;
                                        // bump the ref counts on this object so it
                                        //  doesn't disapper from us
                                        pCounter->pWbemObject->AddRef();
                                        pCounter->pWbemEnum->AddRef();
                                        pCounter->lWbemEnumId = pCounterInList->lWbemEnumId;
                                        pCounter->dwFlags    |= PDHIC_MULTI_INSTANCE;
                                    }
                                    // and exit loop
                                    hRes = S_OK;
                                    break;
                                }
                                else {
                                    // then it's a regular instance the instance name matches
                                    // so get the Object pointer
                                    pCounter->pWbemObject = pCounterInList->pWbemObject;
                                    pCounter->pWbemAccess = pCounterInList->pWbemAccess;
                                    // bump the ref counts on this object so it
                                    //  doesn't disapper from us
                                    pCounter->pWbemObject->AddRef();
                                    pCounter->pWbemAccess->AddRef();
                                    pCounter->lWbemRefreshId = pCounterInList->lWbemRefreshId;
                                    // and exit loop
                                    hRes = S_OK;
                                    break;
                                }
                            }
                        }
                    }
                }
                pCounterInList = pCounterInList->next.flink;
            }
            while (pCounterInList != pCounter->pOwner->pCounterListHead);
        }

        bDontRefresh = TRUE;

        // determine if we should and an object or an enumerator
        if ((pCounter->pCounterPath->szInstanceName != NULL) &&
                        (* pCounter->pCounterPath->szInstanceName == SPLAT_L)) {
            // then this is an enum type so see if there's already one assigned
            // if not, then create one
            if (pCounter->pWbemEnum == NULL) {
                if (pCounter->pOwner->pRefresherCfg != NULL) {
                    hRes = pCounter->pOwner->pRefresherCfg->AddEnum(pWbemServer->pSvc,
                                                                    pPathElem->szObjectName,
                                                                    WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                                                    0,
                                                                    & pCounter->pWbemEnum,
                                                                    & pCounter->lWbemEnumId);
                }
                else {
                    hRes = WBEM_E_INITIALIZATION_FAILURE;
                }

                if (hRes != S_OK) {
                    bReturn = FALSE;
                    dwLastError = PDH_WBEM_ERROR;
                }
                else {
                    pdhStatus = PdhiWbemGetClassObjectByName(pWbemServer,
                                                             pPathElem->szObjectName,
                                                             & pCounter->pWbemObject);
                }
                // set multi instance flag
                pCounter->dwFlags |= PDHIC_MULTI_INSTANCE;
            }
        }
        else {
            // this is a single counter
            if (pCounter->pWbemObject == NULL) {
                // and it hasn't been added yet, so just add one object
                if (pCounter->pOwner->pRefresherCfg != NULL) {
                    hRes = pCounter->pOwner->pRefresherCfg->AddObjectByPath(pWbemServer->pSvc,
                                                                            szWbemItemPath,
                                                                            WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                                                            0,
                                                                            & pCounter->pWbemObject,
                                                                            & pCounter->lWbemRefreshId);
                }
                else {
                    hRes = WBEM_E_INITIALIZATION_FAILURE;
                }

                if (hRes != S_OK) {
                    bReturn     = FALSE;
                    dwLastError = PDH_WBEM_ERROR;
                }
            }
            else {
                // it must have been copied from another
            }
        }

        if (hRes == S_OK) {
            // get handles for subsequent data collection from this object
            hRes = pCounter->pWbemObject->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) & pCounter->pWbemAccess);
            if (hRes == S_OK) {
                if (! PdhiIsSingletonClass(pCounter->pWbemObject)) {
                    CIMTYPE cimType = 0;
                    bsPropName = SysAllocString(cszName);
                    if (bsPropName) {
                        // get handle to the name property for this counter
                        hRes = pCounter->pWbemAccess->GetPropertyHandle(bsPropName, & cimType, & pCounter->lNameHandle);
                        if (hRes != S_OK) {
                            dwLastError = PDH_WBEM_ERROR;
                        }
                        PdhiSysFreeString(& bsPropName);
                    }
                    else {
                        dwLastError = PDH_MEMORY_ALLOCATION_FAILURE;
                        hRes = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else {
                    pCounter->lNameHandle = -1;
                }
                if (hRes == S_OK) {
                    // get handle to the data property for this counter
                    hRes = pCounter->pWbemAccess->GetPropertyHandle(pPathElem->szCounterName,
                                                                    & pCounter->lNumItemType,
                                                                    & pCounter->lNumItemHandle);
                    // get counter type field
                    // first get the property qualifiers
                    bsPropName = SysAllocString(pPathElem->szCounterName);
                    if (bsPropName) {
                        hRes = pCounter->pWbemObject->GetPropertyQualifierSet(bsPropName, & pQualSet);
                        PdhiSysFreeString(& bsPropName);
                    }
                    else {
                        hRes = WBEM_E_OUT_OF_MEMORY;
                    }

                    if (hRes == WBEM_NO_ERROR) {
                        // now get the specific value
                        VariantClear(& vCountertype);
                        bsCountertype = SysAllocString(cszCountertype);
                        if (bsCountertype) {
                            hRes = pQualSet->Get(bsCountertype, 0, & vCountertype, NULL);
                            if (hRes == WBEM_NO_ERROR) {
                                pCounter->plCounterInfo.dwCounterType = (DWORD) V_I4(& vCountertype);
                            }
                            else {
                                pCounter->plCounterInfo.dwCounterType = 0;
                            }
                            PdhiSysFreeString(& bsCountertype);
                        }
                        else {
                            hRes = WBEM_E_OUT_OF_MEMORY;
                        }
                        if (hRes == WBEM_NO_ERROR) {
                            // if this is a fraction counter that has a "base" value
                            // then look it up by appending the "base" string to the
                            // property name

                            if ((pCounter->plCounterInfo.dwCounterType == PERF_SAMPLE_FRACTION)        ||
                                    (pCounter->plCounterInfo.dwCounterType == PERF_AVERAGE_TIMER)      ||
                                    (pCounter->plCounterInfo.dwCounterType == PERF_AVERAGE_BULK)       ||
                                    (pCounter->plCounterInfo.dwCounterType == PERF_LARGE_RAW_FRACTION) ||
                                    (pCounter->plCounterInfo.dwCounterType == PERF_RAW_FRACTION)) {
                                // make sure we have room for the "_Base" string
                                StringCchPrintfW(szBasePropertyName, dwBasePropertyName + 1, L"%ws%ws",
                                        pPathElem->szCounterName, cszBaseSuffix);

                                // get the handle to the denominator
                                hRes = pCounter->pWbemAccess->GetPropertyHandle(szBasePropertyName,
                                                                                & pCounter->lDenItemType,
                                                                                & pCounter->lDenItemHandle);
                            }
                            else {
                                // the denominator is a time field
                                if ((pCounter->plCounterInfo.dwCounterType & PERF_TIMER_FIELD) == PERF_TIMER_TICK) {
                                    // use the system perf time timestamp as the denominator
                                    StringCchCopyW(szBasePropertyName, dwBasePropertyName + 1, cszTimestampPerfTime);
                                    StringCchCopyW(szFreqPropertyName, dwFreqPropertyName + 1, cszFrequencyPerfTime);
                                }
                                else if ((pCounter->plCounterInfo.dwCounterType & PERF_TIMER_FIELD) == PERF_TIMER_100NS) {
                                    StringCchCopyW(szBasePropertyName, dwBasePropertyName + 1, cszTimestampSys100Ns);
                                    StringCchCopyW(szFreqPropertyName, dwFreqPropertyName + 1, cszFrequencySys100Ns);
                                }
                                else if ((pCounter->plCounterInfo.dwCounterType & PERF_TIMER_FIELD) == PERF_OBJECT_TIMER) {
                                    StringCchCopyW(szBasePropertyName, dwBasePropertyName + 1, cszTimestampObject);
                                    StringCchCopyW(szFreqPropertyName, dwFreqPropertyName + 1, cszFrequencyObject);
                                }

                                // get the handle to the denominator
                                hRes = pCounter->pWbemAccess->GetPropertyHandle(szBasePropertyName,
                                                                                & pCounter->lDenItemType,
                                                                                & pCounter->lDenItemHandle);
                                // get the handle to the frequency
                                hRes = pCounter->pWbemAccess->GetPropertyHandle(szFreqPropertyName,
                                                                                & pCounter->lFreqItemType,
                                                                                & pCounter->lFreqItemHandle);
                            }

                            // get the default scale value of this counter
                            VariantClear(& vCountertype);
                            PdhiSysFreeString(& bsCountertype);
                            bsCountertype = SysAllocString(cszDefaultscale);
                            if (bsCountertype) {
                                hRes = pQualSet->Get(bsCountertype, 0, & vCountertype, NULL);
                                if (hRes == WBEM_NO_ERROR) {
                                    pCounter->lScale = 0;
                                    pCounter->plCounterInfo.lDefaultScale = (DWORD) V_I4(& vCountertype);
                                }
                                else {
                                    pCounter->plCounterInfo.lDefaultScale = 0;
                                    pCounter->lScale = 0;
                                }

                                // this may not be initialized but we try anyway
                                if ((pCounter->lFreqItemType == VT_I8) || (pCounter->lFreqItemType == VT_UI8)) {
                                    pCounter->pWbemAccess->ReadQWORD(pCounter->lFreqItemHandle, & llValue);
                                }
                                else {
                                    llValue = 0;
                                }
                                // the timebase is a 64 bit integer
                                pCounter->TimeBase = llValue;
                            }
                            else {
                                hRes = WBEM_E_OUT_OF_MEMORY;
                            }
                        }
                        PdhiSysFreeString(& bsCountertype);
                        pQualSet->Release();
                    }
                    else {
                        if (hRes == WBEM_E_OUT_OF_MEMORY) {
                            dwLastError = PDH_MEMORY_ALLOCATION_FAILURE;
                        }
                        else {
                            dwLastError = PDH_WBEM_ERROR;
                        }
                        bReturn = FALSE;
                    }
                } // else an error has ocurred
            }
            else {
                dwLastError = PDH_WBEM_ERROR;
                bReturn = FALSE;
            }
        }
        else {
            dwLastError = PDH_WBEM_ERROR;
            bReturn = FALSE;
        }
        if (bReturn) {
            // clear the not init'd flag to say it's ok to use now
            pCounter->dwFlags &= ~PDHIC_COUNTER_NOT_INIT;
        }

        bDontRefresh = FALSE;
    }

    if (bReturn) {
        if (! AssignCalcFunction(pCounter->plCounterInfo.dwCounterType, & pCounter->CalcFunc, & pCounter->StatFunc)) {
            dwLastError = PDH_FUNCTION_NOT_FOUND;
            bReturn = FALSE;
        }
    }
    G_FREE(pPathElem);
    G_FREE(szWbemItemPath);
    G_FREE(szBasePropertyName);
    G_FREE(szFreqPropertyName);
    VariantClear(& vCountertype);

    if (bDisconnectServer) {
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiDisconnectWbemServer(pWbemServer);
        }
        else {
            // keep error code from function body
            PdhiDisconnectWbemServer(pWbemServer);
        }
    }

    if (!bReturn) SetLastError(dwLastError);

    // CoUninitialize if necessary
    if (fCoInitialized) {
        PdhiCoUninitialize();
    }

    return bReturn;
}

BOOL
UpdateWbemCounterValue(
    PPDHI_COUNTER   pCounter,
    FILETIME      * pTimeStamp
)
{
    DWORD      LocalCStatus = 0;
    DWORD      LocalCType   = 0;
    ULONGLONG  llValue;
    DWORD      dwValue;
    BOOL       bReturn      = TRUE;

    // move current value to last value buffer
    pCounter->LastValue            = pCounter->ThisValue;

    // and clear the old value
    pCounter->ThisValue.MultiCount = 1;
    pCounter->ThisValue.FirstValue = pCounter->ThisValue.SecondValue = 0;
    pCounter->ThisValue.TimeStamp  = * pTimeStamp;

    // get the counter's machine status first. There's no point in
    // contuning if the machine is offline
    // UpdateWbemCounterValue() will be called only if WBEM refresher succeeds
    // in GetQueryWbemData(); that is, all remote machines should be on-line

    LocalCStatus = ERROR_SUCCESS;
    if (IsSuccessSeverity(LocalCStatus)) {
        // get the pointer to the counter data
        LocalCType = pCounter->plCounterInfo.dwCounterType;
        switch (LocalCType) {
        //
        // these counter types are loaded as:
        //      Numerator = Counter data from perf data block
        //      Denominator = Perf Time from perf data block
        //      (the time base is the PerfFreq)
        //
        case PERF_COUNTER_COUNTER:
        case PERF_COUNTER_QUEUELEN_TYPE:
        case PERF_SAMPLE_COUNTER:
            // this should be a DWORD counter
            pCounter->pWbemAccess->ReadDWORD(pCounter->lNumItemHandle, & dwValue);
            pCounter->ThisValue.FirstValue  = (LONGLONG) dwValue;

            pCounter->pWbemAccess->ReadQWORD(pCounter->lDenItemHandle, & llValue);
            // the denominator should be a 64-bit timestamp
            pCounter->ThisValue.SecondValue = llValue;

            // look up the timebase freq if necessary
            if (pCounter->TimeBase == 0) {
                pCounter->pWbemAccess->ReadQWORD(pCounter->lFreqItemHandle, & llValue);
                // the timebase is a 64 bit integer
                pCounter->TimeBase = llValue;
            }
            break;

        case PERF_ELAPSED_TIME:
        case PERF_100NSEC_TIMER:
        case PERF_100NSEC_TIMER_INV:
        case PERF_COUNTER_TIMER:
        case PERF_COUNTER_TIMER_INV:
        case PERF_COUNTER_BULK_COUNT:
        case PERF_COUNTER_MULTI_TIMER:
        case PERF_COUNTER_MULTI_TIMER_INV:
        case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
        case PERF_OBJ_TIME_TIMER:
        case PERF_COUNTER_100NS_QUEUELEN_TYPE:
        case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
        case PERF_PRECISION_SYSTEM_TIMER:
        case PERF_PRECISION_100NS_TIMER:
        case PERF_PRECISION_OBJECT_TIMER:
            // this should be a QWORD counter
            pCounter->pWbemAccess->ReadQWORD(pCounter->lNumItemHandle, & llValue);
            pCounter->ThisValue.FirstValue  = (LONGLONG) llValue;

            pCounter->pWbemAccess->ReadQWORD(pCounter->lDenItemHandle, & llValue);
            // the denominator should be a 64-bit timestamp
            pCounter->ThisValue.SecondValue = llValue;

            // look up the timebase freq if necessary
            if (pCounter->TimeBase == 0) {
                pCounter->pWbemAccess->ReadQWORD(pCounter->lFreqItemHandle, & llValue);
                // the timebase is a 64 bit integer
                pCounter->TimeBase = llValue;
            }
            break;
        //
        //  These counters do not use any time reference
        //
        case PERF_COUNTER_RAWCOUNT:
        case PERF_COUNTER_RAWCOUNT_HEX:
        case PERF_COUNTER_DELTA:
            // this should be a DWORD counter
            pCounter->pWbemAccess->ReadDWORD(pCounter->lNumItemHandle, & dwValue);
            pCounter->ThisValue.FirstValue  = (LONGLONG) dwValue;
            pCounter->ThisValue.SecondValue = 0;
            break;

        case PERF_COUNTER_LARGE_RAWCOUNT:
        case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
        case PERF_COUNTER_LARGE_DELTA:
            // this should be a DWORD counter
            pCounter->pWbemAccess->ReadQWORD(pCounter->lNumItemHandle, & llValue);
            pCounter->ThisValue.FirstValue  = (LONGLONG) llValue;
            pCounter->ThisValue.SecondValue = 0;
            break;
        //
        //  These counters use two data points, the one pointed to by
        //  pData and the one immediately after
        //
        case PERF_SAMPLE_FRACTION:
        case PERF_RAW_FRACTION:
            // this should be a DWORD counter
            pCounter->pWbemAccess->ReadDWORD(pCounter->lNumItemHandle, & dwValue);
            pCounter->ThisValue.FirstValue  = (LONGLONG) dwValue;

            pCounter->pWbemAccess->ReadDWORD(pCounter->lDenItemHandle, & dwValue);
            // the denominator should be a 32-bit value
            pCounter->ThisValue.SecondValue = (LONGLONG) dwValue;
            break;

        case PERF_LARGE_RAW_FRACTION:
            // this should be a DWORD counter
            pCounter->pWbemAccess->ReadQWORD(pCounter->lNumItemHandle, & llValue);
            pCounter->ThisValue.FirstValue  = (LONGLONG) llValue;

            pCounter->pWbemAccess->ReadQWORD(pCounter->lDenItemHandle, & llValue);
            // the denominator should be a 32-bit value
            pCounter->ThisValue.SecondValue = (LONGLONG) llValue;
        break;

        case PERF_AVERAGE_TIMER:
        case PERF_AVERAGE_BULK:
            // counter (numerator) is a LONGLONG, while the
            // denominator is just a DWORD
            // this should be a DWORD counter
            pCounter->pWbemAccess->ReadQWORD(pCounter->lNumItemHandle, & llValue);
            pCounter->ThisValue.FirstValue  = (LONGLONG) llValue;

            pCounter->pWbemAccess->ReadDWORD(pCounter->lDenItemHandle, & dwValue);
            // the denominator should be a 32-bit value
            pCounter->ThisValue.SecondValue = (LONGLONG) dwValue;

            // look up the timebase freq if necessary
            if (pCounter->TimeBase == 0) {
                pCounter->pWbemAccess->ReadQWORD(pCounter->lFreqItemHandle, & llValue);
                // the timebase is a 64 bit integer
                pCounter->TimeBase = llValue;
            }
            break;
        //
        //  These counters are used as the part of another counter
        //  and as such should not be used, but in case they are
        //  they'll be handled here.
        //
        case PERF_SAMPLE_BASE:
        case PERF_AVERAGE_BASE:
        case PERF_COUNTER_MULTI_BASE:
        case PERF_RAW_BASE:
        case PERF_LARGE_RAW_BASE:
            pCounter->ThisValue.FirstValue  = 0;
            pCounter->ThisValue.SecondValue = 0;
            break;
        //
        //  These counters are not supported by this function (yet)
        //
        case PERF_COUNTER_TEXT:
        case PERF_COUNTER_NODATA:
        case PERF_COUNTER_HISTOGRAM_TYPE:
            pCounter->ThisValue.FirstValue  = 0;
            pCounter->ThisValue.SecondValue = 0;
            break;

        case PERF_100NSEC_MULTI_TIMER:
        case PERF_100NSEC_MULTI_TIMER_INV:
        default:
            // an unidentified  or unsupported
            // counter was returned so
            pCounter->ThisValue.FirstValue  = 0;
            pCounter->ThisValue.SecondValue = 0;
            bReturn = FALSE;
            break;
        }
    }
    else {
        // else this counter is not valid so this value == 0
        pCounter->ThisValue.CStatus     = LocalCStatus;
        pCounter->ThisValue.FirstValue  = 0;
        pCounter->ThisValue.SecondValue = 0;
        bReturn = FALSE;
    }
    return bReturn;
}

BOOL
UpdateWbemMultiInstanceCounterValue(
    PPDHI_COUNTER   pCounter,
    FILETIME      * pTimestamp
)
{
    IWbemObjectAccess     * pWbemAccess;
    HRESULT                 hRes;
    DWORD                   LocalCStatus   = 0;
    DWORD                   LocalCType     = 0;
    DWORD                   dwValue;
    ULONGLONG               llValue;
    DWORD                   dwSize;
    DWORD                   dwFinalSize;
    LONG                    lAvailableSize;
    LONG                    lReturnSize;
    LONG                    lThisInstanceIndex;
    LONG                    lNumInstances;
    LPWSTR                  szNextNameString;
    PPDHI_RAW_COUNTER_ITEM  pThisItem;
    BOOL                    bReturn        = FALSE;
    IWbemObjectAccess    ** pWbemInstances = NULL;

    if (pCounter->pThisRawItemList != NULL) {
        // free old counter buffer list
        G_FREE(pCounter->pLastRawItemList);
        pCounter->pLastRawItemList = pCounter->pThisRawItemList;
        pCounter->pThisRawItemList = NULL;
    }

    // get the counter's machine status first. There's no point in
    // contuning if the machine is offline

    // UpdateWbemCounterValue() will be called only if WBEM refresher succeeds
    // in GetQueryWbemData(); that is, all remote machines should be on-line

    LocalCStatus = ERROR_SUCCESS;
    if (IsSuccessSeverity(LocalCStatus)) {
        // get count of instances in enumerator
        hRes = pCounter->pWbemEnum->GetObjects(0, 0, NULL, (LPDWORD) & lNumInstances);
        if (hRes == WBEM_E_BUFFER_TOO_SMALL) {
            // then we should know how many have been returned so allocate an
            // array of pointers
            pWbemInstances = (IWbemObjectAccess **) G_ALLOC(lNumInstances * sizeof(IWbemObjectAccess *));
            if (pWbemInstances == NULL) {
                SetLastError(ERROR_OUTOFMEMORY);
                hRes    = ERROR_OUTOFMEMORY;
                bReturn = FALSE;
            }
            else {
                hRes = pCounter->pWbemEnum->GetObjects(0,lNumInstances, pWbemInstances, (LPDWORD) & lNumInstances);
            }

            if (hRes == S_OK && lNumInstances > 0) {
                // then we have a table of instances
                // estimate the size required for the new data block
                dwSize  = sizeof (PDHI_RAW_COUNTER_ITEM_BLOCK) - sizeof (PDHI_RAW_COUNTER_ITEM);
                dwSize += lNumInstances * (sizeof(PDH_RAW_COUNTER_ITEM_W) + (PDH_WMI_STR_SIZE * 2 * sizeof(WCHAR)));
                pCounter->pThisRawItemList = (PPDHI_RAW_COUNTER_ITEM_BLOCK)G_ALLOC (dwSize);

                if (pCounter->pThisRawItemList != NULL) {
                    dwFinalSize = lNumInstances * sizeof(PDH_RAW_COUNTER_ITEM_W);
                    szNextNameString = (LPWSTR)((PBYTE) pCounter->pThisRawItemList + dwFinalSize);

                    for (lThisInstanceIndex = 0; lThisInstanceIndex < lNumInstances; lThisInstanceIndex++) {
                        // get pointer to this raw data block in the array
                        pThisItem      = & pCounter->pThisRawItemList->pItemArray[lThisInstanceIndex];
                        // get pointer to this IWbemObjectAccess pointer
                        pWbemAccess    = pWbemInstances[lThisInstanceIndex];
                        // compute the remaining size of the buffer
                        lAvailableSize = (long) (dwSize - dwFinalSize);

                        if (pCounter->lNameHandle != -1) {
                            hRes = pWbemAccess->ReadPropertyValue(pCounter->lNameHandle,
                                                                  lAvailableSize,
                                                                  & lReturnSize,
                                                                  (LPBYTE) szNextNameString);
                        }
                        else {
                            szNextNameString[0] = ATSIGN_L;
                            szNextNameString[1] = 0;
                            lReturnSize = 2;
                        }
                        pThisItem->szName = (DWORD) (((LPBYTE) szNextNameString)
                                                     - ((LPBYTE) pCounter->pThisRawItemList));
                        szNextNameString  = (LPWSTR)((LPBYTE)szNextNameString + lReturnSize);
                        dwFinalSize      += lReturnSize;
                        dwFinalSize       = DWORD_MULTIPLE(dwFinalSize);
                        LocalCType        = pCounter->plCounterInfo.dwCounterType;
                        switch (LocalCType) {
                        //
                        // these counter types are loaded as:
                        //      Numerator = Counter data from perf data block
                        //      Denominator = Perf Time from perf data block
                        //      (the time base is the PerfFreq)
                        //
                        case PERF_COUNTER_COUNTER:
                        case PERF_COUNTER_QUEUELEN_TYPE:
                        case PERF_SAMPLE_COUNTER:
                            // this should be a DWORD counter
                            pWbemAccess->ReadDWORD(pCounter->lNumItemHandle, & dwValue);
                            pThisItem->FirstValue = (LONGLONG) dwValue;

                            pWbemAccess->ReadQWORD(pCounter->lDenItemHandle, & llValue);
                            // the denominator should be a 64-bit timestamp
                            pThisItem->SecondValue = llValue;

                            // look up the timebase freq if necessary
                            if (pCounter->TimeBase == 0) {
                                pWbemAccess->ReadQWORD(pCounter->lFreqItemHandle, & llValue);
                                // the timebase is a 64 bit integer
                                pCounter->TimeBase = llValue;
                            }
                            break;

                        case PERF_ELAPSED_TIME:
                        case PERF_100NSEC_TIMER:
                        case PERF_100NSEC_TIMER_INV:
                        case PERF_COUNTER_TIMER:
                        case PERF_COUNTER_TIMER_INV:
                        case PERF_COUNTER_BULK_COUNT:
                        case PERF_COUNTER_MULTI_TIMER:
                        case PERF_COUNTER_MULTI_TIMER_INV:
                        case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
                        case PERF_OBJ_TIME_TIMER:
                        case PERF_COUNTER_100NS_QUEUELEN_TYPE:
                        case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
                        case PERF_PRECISION_SYSTEM_TIMER:
                        case PERF_PRECISION_100NS_TIMER:
                        case PERF_PRECISION_OBJECT_TIMER:
                            // this should be a QWORD counter
                            pWbemAccess->ReadQWORD(pCounter->lNumItemHandle, & llValue);
                            pThisItem->FirstValue  = (LONGLONG) llValue;

                            pWbemAccess->ReadQWORD(pCounter->lDenItemHandle, & llValue);
                            // the denominator should be a 64-bit timestamp
                            pThisItem->SecondValue = llValue;

                            // look up the timebase freq if necessary
                            if (pCounter->TimeBase == 0) {
                                pWbemAccess->ReadQWORD(pCounter->lFreqItemHandle, & llValue);
                                // the timebase is a 64 bit integer
                                pCounter->TimeBase = llValue;
                            }
                            break;
                        //
                        //  These counters do not use any time reference
                        //
                        case PERF_COUNTER_RAWCOUNT:
                        case PERF_COUNTER_RAWCOUNT_HEX:
                        case PERF_COUNTER_DELTA:
                            // this should be a DWORD counter
                            pWbemAccess->ReadDWORD(pCounter->lNumItemHandle, & dwValue);
                            pThisItem->FirstValue  = (LONGLONG) dwValue;
                            pThisItem->SecondValue = 0;
                            break;

                        case PERF_COUNTER_LARGE_RAWCOUNT:
                        case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
                        case PERF_COUNTER_LARGE_DELTA:
                            // this should be a DWORD counter
                            pWbemAccess->ReadQWORD(pCounter->lNumItemHandle, & llValue);
                            pThisItem->FirstValue  = (LONGLONG) llValue;
                            pThisItem->SecondValue = 0;
                            break;
                        //
                        //  These counters use two data points, the one pointed to by
                        //  pData and the one immediately after
                        //
                        case PERF_SAMPLE_FRACTION:
                        case PERF_RAW_FRACTION:
                            // this should be a DWORD counter
                            pWbemAccess->ReadDWORD(pCounter->lNumItemHandle, & dwValue);
                            pThisItem->FirstValue  = (LONGLONG) dwValue;

                            pWbemAccess->ReadDWORD(pCounter->lDenItemHandle, & dwValue);
                            // the denominator should be a 32-bit value
                            pThisItem->SecondValue = (LONGLONG) dwValue;
                            break;

                        case PERF_LARGE_RAW_FRACTION:
                            // this should be a DWORD counter
                            pCounter->pWbemAccess->ReadQWORD(pCounter->lNumItemHandle, & llValue);
                            pCounter->ThisValue.FirstValue  = (LONGLONG) llValue;

                            pCounter->pWbemAccess->ReadQWORD(pCounter->lDenItemHandle, & llValue);
                            // the denominator should be a 32-bit value
                            pCounter->ThisValue.SecondValue = (LONGLONG) llValue;
                            break;

                        case PERF_AVERAGE_TIMER:
                        case PERF_AVERAGE_BULK:
                            // counter (numerator) is a LONGLONG, while the
                            // denominator is just a DWORD
                            // this should be a DWORD counter
                            pWbemAccess->ReadQWORD(pCounter->lNumItemHandle, & llValue);
                            pThisItem->FirstValue  = (LONGLONG) llValue;

                            pWbemAccess->ReadDWORD(pCounter->lDenItemHandle, & dwValue);
                            // the denominator should be a 32-bit value
                            pThisItem->SecondValue = (LONGLONG) dwValue;

                            // look up the timebase freq if necessary
                            if (pCounter->TimeBase == 0) {
                                pWbemAccess->ReadQWORD(pCounter->lFreqItemHandle, & llValue);
                                // the timebase is a 64 bit integer
                                pCounter->TimeBase = llValue;
                            }
                            break;
                        //
                        //  These counters are used as the part of another counter
                        //  and as such should not be used, but in case they are
                        //  they'll be handled here.
                        //
                        case PERF_SAMPLE_BASE:
                        case PERF_AVERAGE_BASE:
                        case PERF_COUNTER_MULTI_BASE:
                        case PERF_RAW_BASE:
                        case PERF_LARGE_RAW_BASE:
                            pThisItem->FirstValue  = 0;
                            pThisItem->SecondValue = 0;
                            break;
                        //
                        //  These counters are not supported by this function (yet)
                        //
                        case PERF_COUNTER_TEXT:
                        case PERF_COUNTER_NODATA:
                        case PERF_COUNTER_HISTOGRAM_TYPE:
                            pThisItem->FirstValue  = 0;
                            pThisItem->SecondValue = 0;
                            break;

                        case PERF_100NSEC_MULTI_TIMER:
                        case PERF_100NSEC_MULTI_TIMER_INV:
                        default:
                            // an unidentified  or unsupported
                            // counter was returned so
                            pThisItem->FirstValue  = 0;
                            pThisItem->SecondValue = 0;
                            bReturn = FALSE;
                            break;
                        }
                        // we're done with this one so release it
                        pWbemAccess->Release();
                    }
                    // measure the memory block used

                    pCounter->pThisRawItemList->dwLength    = dwFinalSize;
                    pCounter->pThisRawItemList->dwItemCount = lNumInstances;
                    pCounter->pThisRawItemList->dwReserved  = 0;
                    pCounter->pThisRawItemList->CStatus     = ERROR_SUCCESS;
                    pCounter->pThisRawItemList->TimeStamp   = * pTimestamp;
                }
                else {
                    // unable to allocate a new buffer so return error
                    SetLastError(ERROR_OUTOFMEMORY);
                    bReturn = FALSE;
                }
            }
        }
    }
    G_FREE(pWbemInstances);
    return bReturn;
}

LONG
GetQueryWbemData(
    PPDHI_QUERY   pQuery,
    LONGLONG    * pllTimeStamp
)
{
    FILETIME      GmtFileTime;
    FILETIME      LocFileTime;
    LONGLONG      llTimeStamp = 0;
    HRESULT       hRes        = S_OK;
    LONG          lRetStatus  = ERROR_SUCCESS;
    PPDHI_COUNTER pCounter;
    PDH_STATUS    pdhStatus;

    // refresh Wbem Refresher

    if (bDontRefresh) {
        lRetStatus = ERROR_BUSY;
    }
    else if (pQuery->pRefresher != NULL) {
        hRes = pQuery->pRefresher->Refresh(0);
    }
    else {
        hRes = WBEM_E_INITIALIZATION_FAILURE;
    }

    // If multiple objects are being refreshed, some objects may succeed and
    // others may fail, in which case WBEM_S_PARTIAL_RESULTS is returned.
    if (FAILED(hRes)) {
        SetLastError(hRes);
        lRetStatus = PDH_NO_DATA;
    }

    // get timestamp for this counter
    GetSystemTimeAsFileTime(& GmtFileTime);
    FileTimeToLocalFileTime(& GmtFileTime, & LocFileTime);
    llTimeStamp = MAKELONGLONG(LocFileTime.dwLowDateTime, LocFileTime.dwHighDateTime);

    pCounter = pQuery->pCounterListHead;
    if (pCounter == NULL) {
        if (lRetStatus == ERROR_SUCCESS) lRetStatus = PDH_NO_DATA;
    }
    else {
        do {
            if (lRetStatus == ERROR_SUCCESS) {
                // now update the counters using this new data
                if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
                    pdhStatus = UpdateWbemMultiInstanceCounterValue(pCounter, (FILETIME *) & llTimeStamp);
                }
                else {
                    // update single instance counter values
                    pdhStatus = UpdateWbemCounterValue(pCounter, (FILETIME *) & llTimeStamp);
                }
            }
            else if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
                if (pCounter->pThisRawItemList != NULL) {
                    if (pCounter->pLastRawItemList != NULL
                            && pCounter->pLastRawItemList != pCounter->pThisRawItemList) {
                        G_FREE(pCounter->pLastRawItemList);
                    }
                    pCounter->pLastRawItemList = pCounter->pThisRawItemList;
                    pCounter->pThisRawItemList = NULL;
                }
                pCounter->pThisRawItemList = (PPDHI_RAW_COUNTER_ITEM_BLOCK)
                                             G_ALLOC(sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK));
                if (pCounter->pThisRawItemList != NULL) {
                    pCounter->pThisRawItemList->dwLength                 = sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK);
                    pCounter->pThisRawItemList->dwItemCount              = 0;
                    pCounter->pThisRawItemList->CStatus                  = PDH_WBEM_ERROR;
                    pCounter->pThisRawItemList->TimeStamp.dwLowDateTime  = LODWORD(llTimeStamp);
                    pCounter->pThisRawItemList->TimeStamp.dwHighDateTime = HIDWORD(llTimeStamp);
                }
            }
            else {
                pCounter->LastValue                          = pCounter->ThisValue;
                pCounter->ThisValue.CStatus                  = PDH_WBEM_ERROR;
                pCounter->ThisValue.MultiCount               = 1;
                pCounter->ThisValue.FirstValue               = 0;
                pCounter->ThisValue.SecondValue              = 0;
                pCounter->ThisValue.TimeStamp.dwLowDateTime  = LODWORD(llTimeStamp);
                pCounter->ThisValue.TimeStamp.dwHighDateTime = HIDWORD(llTimeStamp);
            }
            pCounter = pCounter->next.flink;
        }
        while (pCounter != pQuery->pCounterListHead);
    }
    if (lRetStatus == ERROR_SUCCESS) {
        * pllTimeStamp = llTimeStamp;
    }
    return lRetStatus;
}

HRESULT WbemSetProxyBlanket(
    IUnknown                 * pInterface,
    DWORD                      dwAuthnSvc,
    DWORD                      dwAuthzSvc,
    OLECHAR                  * pServerPrincName,
    DWORD                      dwAuthLevel,
    DWORD                      dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE   pAuthInfo,
    DWORD                      dwCapabilities
)
{
    // Security MUST be set on both the Proxy and it's IUnknown!

    IUnknown        * pUnk    = NULL;
    IClientSecurity * pCliSec = NULL;
    HRESULT           sc      = pInterface->QueryInterface(IID_IUnknown, (void **) & pUnk);

    if (sc == S_OK) {
        sc = pInterface->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
        if (sc == S_OK) {
            sc = pCliSec->SetBlanket(pInterface,
                                     dwAuthnSvc,
                                     dwAuthzSvc,
                                     pServerPrincName,
                                     dwAuthLevel,
                                     dwImpLevel,
                                     pAuthInfo,
                                     dwCapabilities);
            pCliSec->Release();
            pCliSec = NULL;
            sc      = pUnk->QueryInterface(IID_IClientSecurity, (void **) & pCliSec);
            if(sc == S_OK) {
                sc = pCliSec->SetBlanket(pUnk,
                                         dwAuthnSvc,
                                         dwAuthzSvc,
                                         pServerPrincName,
                                         dwAuthLevel,
                                         dwImpLevel,
                                         pAuthInfo,
                                         dwCapabilities);
                pCliSec->Release();
            }
            else if (sc == 0x80004002) {
                sc = S_OK;
            }
        }
        pUnk->Release();
    }
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\perfmon5\perfmon5.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    perfmon5.c

Abstract:

    Program to adapt the command line Perfmon from NT4 and prior
        to the MMC & NT5 compatible format

Author:

    Bob Watson (bobw) 11 may 99

Revision History:

--*/
#define _OUTPUT_HTML    1
//#define _DBG_MSG_PRINT  1 
#define _USE_MMC        1

#define MAXSTR      1024
#define MAX_ARG_STR 2048

#include "perfmon5.h"
#include "strsafe.h"

#define MemAlloc(s)      HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, s)
#define MemReAlloc(h,s)  HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, h, s)
#define MemFree(h)       if (h != NULL) { HeapFree(GetProcessHeap(), 0, h); }
#define MemSize(h)       ((h != NULL) ? HeapSize(GetPRocessHeap(), 0, h) : 0)

// static & global variables
#ifdef _USE_MMC
LPCWSTR szMmcExeCmd        = (LPCWSTR) L"%windir%\\system32\\mmc.exe";
LPCWSTR szMmcExeArg        = (LPCWSTR) L" %windir%\\system32\\perfmon.msc /s";
#else
LPCWSTR szMmcExeCmd        = (LPCWSTR) L"%windir%\\explorer.exe";
LPCWSTR szMmcExeArg        = (LPCWSTR) L" ";
#endif
LPCWSTR szMmcExeSetsArg    = (LPCWSTR) L"/SYSMON%ws_SETTINGS \"%ws\"";
LPCWSTR szMmcExeSetsLogOpt = (LPCWSTR) L"LOG";
LPCWSTR szEmpty            = (LPCWSTR)L"";

//HTML Formatting definitions
// these are not localized
LPCWSTR szHtmlHeader   = (LPCWSTR) L"\
<HTML>\r\n\
<HEAD>\r\n\
<META NAME=\"GENERATOR\"  Content=\"Microsoft System Monitor\">\r\n\
<META HTTP-EQUIV=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\r\n\
</HEAD><BODY  bgcolor=\"#%6.6x\">\r\n";

LPCWSTR szObjectHeader = (LPCWSTR) L"\
<OBJECT ID=\"%s\" WIDTH=\"100%%\" HEIGHT=\"100%%\"\r\n\
    CLASSID=\"CLSID:C4D2D8E0-D1DD-11CE-940F-008029004347\">\r\n\
    <PARAM NAME=\"Version\" VALUE=\"196611\"\r\n";

LPCWSTR szObjectFooter = (LPCWSTR) L"\
</OBJECT>\r\n";

LPCWSTR szHtmlFooter   = (LPCWSTR) L"\
</BODY>\r\n\
</HTML>\r\n";

LPCWSTR szHtmlDecimalParamFmt     = (LPCWSTR) L"    <PARAM NAME=\"%s\" VALUE=\"%d\">\r\n";
LPCWSTR szHtmlStringParamFmt      = (LPCWSTR) L"    <PARAM NAME=\"%s\" VALUE=\"%s\">\r\n";
LPCWSTR szHtmlWideStringParamFmt  = (LPCWSTR) L"    <PARAM NAME=\"%s\" VALUE=\"%ws\">\r\n";
LPCWSTR szHtmlLineDecimalParamFmt = (LPCWSTR) L"    <PARAM NAME=\"Counter%5.5d.%s\" VALUE=\"%d\">\r\n";
LPCWSTR szHtmlLineRealParamFmt    = (LPCWSTR) L"    <PARAM NAME=\"Counter%5.5d.%s\" VALUE=\"%f\">\r\n";
LPCWSTR szHtmlLineStringParamFmt  = (LPCWSTR) L"    <PARAM NAME=\"Counter%5.5d.%s\" VALUE=\"%s\">\r\n";
LPCWSTR szSingleObjectName        = (LPCWSTR) L"SystemMonitor1";
LPCWSTR szSysmonControlIdFmt      = (LPCWSTR) L"SysmonControl%d";

// CODE STARTS HERE

LPWSTR
DiskStringRead(
    PDISKSTRING pDS
)
{
    LPWSTR szReturnString = NULL;

    if (pDS->dwLength == 0) {
        szReturnString = NULL;
    }
    else {
        szReturnString = MemAlloc((pDS->dwLength + 1) * sizeof(WCHAR));
        if (szReturnString) {
            StringCchCopyW(szReturnString,
                           pDS->dwLength + 1,
                           (LPWSTR) (((LPBYTE) pDS) + pDS->dwOffset));
        }
    }
    return (szReturnString);
}

BOOL 
FileRead(
    HANDLE   hFile,
    LPVOID   lpMemory,
    DWORD    nAmtToRead
)
{
   BOOL   bSuccess;
   DWORD  nAmtRead;

   bSuccess = ReadFile(hFile, lpMemory, nAmtToRead, & nAmtRead, NULL);
   return (bSuccess && (nAmtRead == nAmtToRead));
}

BOOL
ReadLogLine(
    HANDLE      hFile,
    FILE      * fOutFile,
    LPDWORD     pdwLineNo,
    DWORD       dwInFileType,
    PDISKLINE * ppDiskLine,
    DWORD     * pSizeofDiskLine
)
/*
   Effect:        Read in a line from the file hFile, at the current file
                  position.

   Internals:     The very first characters are a line signature, then a
                  length integer. If the signature is correct, then allocate
                  the length amount, and work with that.
*/
{
#ifdef _OUTPUT_HTML
    PDH_COUNTER_PATH_ELEMENTS_W pdhPathElem;
    LPWSTR                      wszCounterPath    = NULL;
    PDH_STATUS                  pdhStatus;
    DWORD                       dwCounterPathSize = 0;
#endif
    LOGENTRY                    LogEntry;
    BOOL                        bReturn   = TRUE;

    UNREFERENCED_PARAMETER(dwInFileType);    
    UNREFERENCED_PARAMETER(ppDiskLine);    
    UNREFERENCED_PARAMETER(pSizeofDiskLine);    

    //=============================//
    // read and compare signature  //
    //=============================//

    if (! FileRead(hFile, & LogEntry, sizeof(LOGENTRY) - sizeof(LogEntry.pNextLogEntry))) {
        return (FALSE);
    }

#ifdef _OUTPUT_HTML
    // expand log entry into counters: not this may not always work!
    if (lstrcmpW(LogEntry.szComputer, (LPCWSTR) L"....") != 0) {
        // then add the machine name
        pdhPathElem.szMachineName = LogEntry.szComputer;
    }
    else {
        pdhPathElem.szMachineName = NULL;
    }
    pdhPathElem.szObjectName     = LogEntry.szObject;
    pdhPathElem.szInstanceName   = (LPWSTR) L"*";
    pdhPathElem.szParentInstance = NULL;
    pdhPathElem.dwInstanceIndex  = (DWORD) -1;
    pdhPathElem.szCounterName    = (LPWSTR) L"*";

    pdhStatus = PdhMakeCounterPathW(& pdhPathElem, wszCounterPath, & dwCounterPathSize, 0);
    while (pdhStatus == PDH_MORE_DATA) {
        MemFree(wszCounterPath);
        wszCounterPath = MemAlloc(dwCounterPathSize * sizeof(WCHAR));
        if (wszCounterPath != NULL) {
            pdhStatus = PdhMakeCounterPathW(& pdhPathElem, wszCounterPath, & dwCounterPathSize, 0);
        }
        else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        fwprintf(fOutFile, szHtmlLineStringParamFmt, * pdwLineNo, (LPCWSTR) L"Path", wszCounterPath);
        * pdwLineNo = * pdwLineNo + 1;   // increment the line no
    }
    else {
        bReturn = FALSE;
    }
    MemFree(wszCounterPath);
#else
    fprintf(fOutFile, "\n    Line[%3.3d].ObjectTitleIndex = %d", * pdwLineNo, LogEntry.ObjectTitleIndex);
    fprintf(fOutFile, "\n    Line[%3.3d].szComputer = %ws",      * pdwLineNo, LogEntry.szComputer);
    fprintf(fOutFile, "\n    Line[%3.3d].szObject = %ws",        * pdwLineNo, LogEntry.szObject);
    fprintf(fOutFile, "\n    Line[%3.3d].bSaveCurrentName = %d", * pdwLineNo, LogEntry.bSaveCurrentName);
    * pdwLineNo = * pdwLineNo + 1;   // increment the line no
#endif
    return bReturn;
}

BOOL
ReadLine(
    HANDLE      hFile,
    FILE      * fOutFile,
    LPDWORD     pdwLineNo,
    DWORD       dwInFileType,
    PDISKLINE * ppDiskLine,
    DWORD     * pSizeofDiskLine
)
/*
   Effect:        Read in a line from the file hFile, at the current file
                  position.

   Internals:     The very first characters are a line signature, then a
                  length integer. If the signature is correct, then allocate
                  the length amount, and work with that.
*/
{
    PDISKLINE                   pDiskLine         = NULL;
    DWORD                       dwLineNo          = * pdwLineNo;
#ifdef _OUTPUT_HTML
    double                      dScaleFactor;
    PDH_STATUS                  pdhStatus;
    PDH_COUNTER_PATH_ELEMENTS_W pdhPathElem;
    LPWSTR                      wszCounterPath    = NULL;
    DWORD                       dwCounterPathSize = 0; 
#else
    LPWSTR                      szTempString      = NULL;
#endif
    BOOL                        bReturn           = FALSE;

    struct {
        DWORD  dwSignature;
        DWORD  dwLength;
    } LineHeader;

    //=============================//
    // read and compare signature  //
    //=============================//

    if (! FileRead(hFile, & LineHeader, sizeof(LineHeader))) {
        goto Cleanup;
    }
    if (LineHeader.dwSignature != dwLineSignature || LineHeader.dwLength == 0) {
        SetLastError(ERROR_BAD_FORMAT);
        goto Cleanup;
    }

    //=============================//
    // read and allocate length    //
    //=============================//

    //   if (!FileRead (hFile, &dwLength, sizeof (dwLength)) || dwLength == 0)
    //      return (NULL) ;

    // check if we need a bigger buffer,
    // normally, it should be the same except the first time...
    if (LineHeader.dwLength > * pSizeofDiskLine) {
        MemFree(* ppDiskLine);
        * pSizeofDiskLine = 0;

        // re-allocate a new buffer
        * ppDiskLine = (PDISKLINE) MemAlloc(LineHeader.dwLength);
        if ((* ppDiskLine) == NULL) {
            // no memory, should flag an error...
            goto Cleanup;
        }
        * pSizeofDiskLine = LineHeader.dwLength;
    }
    pDiskLine = * ppDiskLine;

    //=============================//
    // copy diskline, alloc line   //
    //=============================//

    if (! FileRead(hFile, pDiskLine, LineHeader.dwLength)) {
        goto Cleanup;
    }

#ifdef _OUTPUT_HTML

    // HTML output requires 1 based indexes, not 0 based
    dwLineNo += 1;

    // make counter path string out of components
    pdhPathElem.szMachineName = DiskStringRead(& (pDiskLine->dsSystemName));
    if (pdhPathElem.szMachineName != NULL
            && lstrcmpW(pdhPathElem.szMachineName, (LPCWSTR) L"....") == 0) {
        // then use local machine
        MemFree(pdhPathElem.szMachineName);
        pdhPathElem.szMachineName = NULL;
    }
    pdhPathElem.szObjectName = DiskStringRead(& (pDiskLine->dsObjectName));
    if (pDiskLine->dwUniqueID != PERF_NO_UNIQUE_ID) {
        pdhPathElem.szInstanceName = MemAlloc(MAXSTR);
        if (pdhPathElem.szInstanceName != NULL) {
            _ltow(pDiskLine->dwUniqueID, pdhPathElem.szInstanceName, 10);
        }
    }
    else {
        pdhPathElem.szInstanceName = DiskStringRead(& (pDiskLine->dsInstanceName));
    }
    pdhPathElem.szParentInstance = DiskStringRead( &(pDiskLine->dsPINName));
    pdhPathElem.dwInstanceIndex  = (DWORD) -1;
    pdhPathElem.szCounterName    = DiskStringRead( &(pDiskLine->dsCounterName));

    pdhStatus = PdhMakeCounterPathW(& pdhPathElem, wszCounterPath, & dwCounterPathSize, 0);
    while (pdhStatus == PDH_MORE_DATA) {
        MemFree(wszCounterPath);
        wszCounterPath = MemAlloc(dwCounterPathSize * sizeof(WCHAR));
        if (wszCounterPath != NULL) {
            pdhStatus = PdhMakeCounterPathW(& pdhPathElem, wszCounterPath, & dwCounterPathSize, 0);
        }
        else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        fwprintf(fOutFile, szHtmlLineStringParamFmt, dwLineNo, (LPCWSTR) L"Path", wszCounterPath);
        if (dwInFileType == PMC_FILE) {
            dScaleFactor  = log10(pDiskLine->eScale);
            dScaleFactor += 0.5;
            dScaleFactor  = floor(dScaleFactor);
            fwprintf(fOutFile, szHtmlLineDecimalParamFmt, dwLineNo, (LPCWSTR) L"ScaleFactor", (LONG) dScaleFactor);
            fwprintf(fOutFile, szHtmlLineDecimalParamFmt, dwLineNo, (LPCWSTR) L"Color",       * (DWORD *) & pDiskLine->Visual.crColor);
            fwprintf(fOutFile, szHtmlLineDecimalParamFmt, dwLineNo, (LPCWSTR) L"LineStyle", pDiskLine->Visual.iStyle );
            fwprintf(fOutFile, szHtmlLineDecimalParamFmt, dwLineNo, (LPCWSTR) L"Width",     pDiskLine->Visual.iWidth);
        }

        if (dwInFileType == PMA_FILE) {
            fwprintf(fOutFile, szHtmlLineDecimalParamFmt, dwLineNo, (LPCWSTR) L"AlertOverUnder", pDiskLine->bAlertOver);
            fwprintf(fOutFile, szHtmlLineRealParamFmt,    dwLineNo, (LPCWSTR) L"AlertThreshold", pDiskLine->eAlertValue);
            fwprintf(fOutFile, szHtmlLineDecimalParamFmt, dwLineNo, (LPCWSTR) L"Color",          * (DWORD *) & pDiskLine->Visual.crColor);
        }
        bReturn = TRUE;
    }
    MemFree(wszCounterPath);

    MemFree(pdhPathElem.szMachineName);
    MemFree(pdhPathElem.szObjectName); 
    MemFree(pdhPathElem.szInstanceName);
    MemFree(pdhPathElem.szParentInstance);
    MemFree(pdhPathElem.szCounterName);
#else
    UNREFERENCED_PARAMETER(dwInFileType);
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].iLineType = %d",        dwLineNo, pDiskLine->iLineType);
    szTempString = DiskStringRead(& (pDiskLine->dsSystemName));
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].dsSystmeName = %ws",    dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    MemFree(szTempString);
    szTempString = DiskStringRead(& (pDiskLine->dsObjectName));
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].dsObjectName = %ws",    dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    MemFree(szTempString);
    szTempString = DiskStringRead(& (pDiskLine->dsCounterName));
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].dsCounterName = %ws",   dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    MemFree(szTempString);
    szTempString = DiskStringRead(& (pDiskLine->dsInstanceName));
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].dsInstanceName = %ws",  dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    MemFree(szTempString);
    szTempString = DiskStringRead(& (pDiskLine->dsPINName));
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].dsPINName = %ws",       dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    MemFree(szTempString);
    szTempString = DiskStringRead(& (pDiskLine->dsParentObjName));
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].dsParentObjName = %ws", dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    MemFree(szTempString);
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].dwUniqueID = 0x%8.8x",  dwLineNo, pDiskLine->dwUniqueID);
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].iScaleIndex = %d",      dwLineNo, pDiskLine->iScaleIndex);
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].eScale = %e",           dwLineNo, pDiskLine->eScale);
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].bAlertOver = %d",       dwLineNo, pDiskLine->bAlertOver);
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].eAlertValue = %e",      dwLineNo, pDiskLine->eAlertValue);
    szTempString = DiskStringRead(& (pDiskLine->dsAlertProgram));
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].dsAlertProgram = %ws",  dwLineNo, (szTempString ? szTempString : (LPCWSTR)L""));
    MemFree(szTempString);
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].bEveryTime = %d",       dwLineNo, pDiskLine->bEveryTime);
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].LV.crColor = 0x%8.8x",  dwLineNo, *(DWORD *)&pDiskLine->Visual.crColor) ;
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].LV.iColorIndex = %d",   dwLineNo, pDiskLine->Visual.iColorIndex );
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].LV.iStyle = %d",        dwLineNo, pDiskLine->Visual.iStyle );
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].LV.iStyleIndex = %d",   dwLineNo, pDiskLine->Visual.iStyleIndex );
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].LV.iWidth = %d",        dwLineNo, pDiskLine->Visual.iWidth );
    fwprintf(fOutFile, (LPCWSTR) L"\n    Line[%3.3d].LV.iWidthIndex = %d",   dwLineNo, pDiskLine->Visual.iWidthIndex );

    bReturn = TRUE;
#endif

Cleanup:
    return bReturn;
}

void
ReadLines(
    HANDLE   hFile,
    FILE   * fOutFile,
    DWORD    dwFileType,
    DWORD    dwNumLines
)
{
    DWORD       i;
    PDISKLINE   pDiskLine      = NULL;
    DWORD       SizeofDiskLine = 0;    // bytes in pDiskLine
    DWORD       dwLogLineNo;

    SizeofDiskLine = MAX_PATH;
    for (i = 0, dwLogLineNo = 1; i < dwNumLines ; i ++) {
        if (dwFileType == PML_FILE) {
            ReadLogLine(hFile, fOutFile, & dwLogLineNo, dwFileType, & pDiskLine, & SizeofDiskLine);
        }
        else {
            ReadLine(hFile, fOutFile, & i, dwFileType, & pDiskLine, & SizeofDiskLine);
        }
    }
    MemFree(pDiskLine);
}

BOOL 
OpenAlert(
    LPCWSTR   szInFileName,
    HANDLE    hFile,
    FILE    * fOutFile,
    LPCWSTR   szObjectName
)
{  // OpenAlert
    DISKALERT  DiskAlert;
    BOOL       bSuccess           = TRUE ;
    DWORD      dwLocalActionFlags = 0;

#ifdef _OUTPUT_HTML
    WCHAR  szComment[MAX_PATH];
    WCHAR  path[_MAX_PATH];
    WCHAR  drive[_MAX_DRIVE];
    WCHAR  dir[_MAX_DIR];
    WCHAR  fname[_MAX_FNAME];
    WCHAR  ext[_MAX_EXT];
#endif

    // read the next section if valid
    bSuccess = FileRead (hFile, &DiskAlert, sizeof (DISKALERT));

    if (bSuccess) {
#ifdef _OUTPUT_HTML
        if (DiskAlert.dwNumLines > 0) {
            fwprintf(fOutFile, szObjectHeader, szObjectName);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ManualUpdate",           DiskAlert.bManualRefresh);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ShowToolbar",            DiskAlert.perfmonOptions.bMenubar);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"UpdateInterval",         (int) DiskAlert.dwIntervalSecs / 1000);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"SampleIntervalUnitType", 1); // Seconds
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"SampleIntervalValue",    (int) DiskAlert.dwIntervalSecs / 1000);
            fwprintf(fOutFile, szHtmlStringParamFmt,  (LPCWSTR) L"CommandFile",            "");
            fwprintf(fOutFile, szHtmlStringParamFmt,  (LPCWSTR) L"UserText",               "");
            fwprintf(fOutFile, szHtmlStringParamFmt,  (LPCWSTR) L"PerfLogName",            "");
        
            dwLocalActionFlags |= 1;            // perfmon normally logs to the UI, but we don't have one
                                                // so log to the event log by default
            if (DiskAlert.bNetworkAlert) {
                dwLocalActionFlags |= 2;
            }
            // perfmon does 1 net name per alert. we do 1 per file so leave it blank
            fwprintf(fOutFile, szHtmlStringParamFmt,  (LPCWSTR) L"NetworkName", "");

            dwLocalActionFlags |= 0x00003F00;   // command line flags
            fwprintf (fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ActionFlags",dwLocalActionFlags);

            // set the defaults to duplicate a perfmon log
            _wfullpath(path, szInFileName, _MAX_PATH);
            _wsplitpath(path, drive, dir, fname, ext);
            fwprintf(fOutFile, szHtmlWideStringParamFmt, (LPCWSTR) L"AlertName", fname);
            ZeroMemory(szComment, MAX_PATH * sizeof(WCHAR));
            StringCchPrintfW(szComment,
                             MAX_PATH,
                             (LPCWSTR) L"Created from Perfmon Settings File \"%ws%ws\"", fname, ext);
            fwprintf(fOutFile, szHtmlStringParamFmt,     (LPCWSTR) L"Comment", szComment);
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"LogType", 2);            // Sysmon alert
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"LogFileMaxSize", -1);    // no size limit
            fwprintf(fOutFile, szHtmlWideStringParamFmt, (LPCWSTR) L"LogFileBaseName", fname);
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"LogFileSerialNumber", 1);
            ZeroMemory(szComment, MAX_PATH * sizeof(WCHAR));
            StringCchPrintfW(szComment,
                             MAX_PATH,
                             (LPCWSTR) L"%ws%ws", drive, dir);
            fwprintf(fOutFile, szHtmlWideStringParamFmt, (LPCWSTR) L"LogFileFolder", szComment);
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"LogFileAutoFormat",  0); //no auto name
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"LogFileType", 2);        // PDH binary counter log 
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"StartMode", 0);          // manual start
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"StopMode", 0);           // manual stop
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"RestartMode", 0);        // no restart
            fwprintf(fOutFile, szHtmlStringParamFmt,     (LPCWSTR) L"EOFCommandFile", "");

            // Get ready to list the counters
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"CounterCount", DiskAlert.dwNumLines);
        }
#else // output text
        UNREFERENCED_PARAMETER(szInFileName);
        UNREFERENCED_PARAMETER(szOutFileName);

        // dump settings file header
        fOutFile = stdout;
        fprintf(fOutFile, "\nDA.dwNumLines = %d",         DiskAlert.dwNumLines);
        fprintf(fOutFile, "\nDA.dwIntervalSecs = %d",     DiskAlert.dwIntervalSecs);
        fprintf(fOutFile, "\nDA.bManualRefresh  = %d",    DiskAlert.bManualRefresh);
        fprintf(fOutFile, "\nDA.bSwitchToAlert = %d",     DiskAlert.bSwitchToAlert);
        fprintf(fOutFile, "\nDA.bNetworkAlert = %d",      DiskAlert.bNetworkAlert);
        fprintf(fOutFile, "\nDA.MessageName = %16.16ws",  DiskAlert.MessageName);
        fprintf(fOutFile, "\nDA.MiscOptions = 0x%8.8x",   DiskAlert.MiscOptions);
        fprintf(fOutFile, "\nDA.LV.crColor = 0x%8.8x",    * (DWORD *) & DiskAlert.Visual.crColor);
        fprintf(fOutFile, "\nDA.LV.iColorIndex = %d",     DiskAlert.Visual.iColorIndex);
        fprintf(fOutFile, "\nDA.LV.iStyle = %d",          DiskAlert.Visual.iStyle);
        fprintf(fOutFile, "\nDA.LV.iStyleIndex = %d",     DiskAlert.Visual.iStyleIndex);
        fprintf(fOutFile, "\nDA.LV.iWidth = %d",          DiskAlert.Visual.iWidth);
        fprintf(fOutFile, "\nDA.LV.iWidthIndex = %d",     DiskAlert.Visual.iWidthIndex);
        fprintf(fOutFile, "\nDA.PO.bMenubar  = %d",       DiskAlert.perfmonOptions.bMenubar);
        fprintf(fOutFile, "\nDA.PO.bToolbar   = %d",      DiskAlert.perfmonOptions.bToolbar);
        fprintf(fOutFile, "\nDA.PO.bStatusbar   = %d",    DiskAlert.perfmonOptions.bStatusbar);
        fprintf(fOutFile, "\nDA.PO.bAlwaysOnTop   = %d",  DiskAlert.perfmonOptions.bAlwaysOnTop);
#endif
    }
    if ((bSuccess) && (DiskAlert.dwNumLines > 0)) {
        ReadLines(hFile, fOutFile, PMA_FILE, DiskAlert.dwNumLines);
#ifdef _OUTPUT_HTML
        fwprintf(fOutFile, szObjectFooter);
#endif
    }

    return (bSuccess);

}  // OpenAlert

BOOL 
OpenLog(
    LPCWSTR   szInFileName,
    HANDLE    hFile,
    FILE    * fOutFile,
    LPCWSTR   szObjectName
)
{  // OpenLog
    DISKLOG   DiskLog;
    BOOL      bSuccess = TRUE;
#ifdef _OUTPUT_HTML
    WCHAR     szComment[MAX_PATH];
    WCHAR     path[_MAX_PATH];
    WCHAR     drive[_MAX_DRIVE];
    WCHAR     dir[_MAX_DIR];
    WCHAR     fname[_MAX_FNAME];
    WCHAR     ext[_MAX_EXT];
#endif

    // read the next section if valid
    bSuccess = FileRead(hFile, & DiskLog, sizeof(DISKLOG));

    if (bSuccess) {
#ifdef _OUTPUT_HTML
        if (DiskLog.dwNumLines > 0) {
            fwprintf(fOutFile, szObjectHeader, szObjectName);

            // dump settings file header
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ManualUpdate",           DiskLog.bManualRefresh);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"UpdateInterval",         (int) DiskLog.dwIntervalSecs / 1000);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"SampleIntervalUnitType", 1); // Seconds
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"SampleIntervalValue",    (int) DiskLog.dwIntervalSecs / 1000);
            fwprintf(fOutFile, szHtmlWideStringParamFmt, (LPCWSTR) L"LogFileName",          DiskLog.LogFileName);

            // set the defaults to duplicate a perfmon log
            _wfullpath(path, szInFileName, _MAX_PATH);
            _wsplitpath(path, drive, dir, fname, ext);
            fwprintf(fOutFile, szHtmlWideStringParamFmt, (LPCWSTR) L"LogName", fname);
            ZeroMemory(szComment, MAX_PATH * sizeof(WCHAR));
            StringCchPrintfW(szComment,
                             MAX_PATH,
                             (LPCWSTR) L"Created from Perfmon Settings File \"%ws%ws\"",
                             fname, ext);
            fwprintf(fOutFile, szHtmlStringParamFmt,     (LPCWSTR) L"Comment",             szComment);
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"LogType",             0);    // PDH counter log 
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"LogFileMaxSize",      -1);   // no size limit
            fwprintf(fOutFile, szHtmlWideStringParamFmt, (LPCWSTR) L"LogFileBaseName",     fname);
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"LogFileSerialNumber", 1);
            ZeroMemory(szComment, MAX_PATH * sizeof(WCHAR));
            StringCchPrintfW(szComment, MAX_PATH, (LPCWSTR) L"%ws%ws", drive, dir);
            fwprintf(fOutFile, szHtmlWideStringParamFmt, (LPCWSTR) L"LogFileFolder",      szComment);
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"LogFileAutoFormat",  0); //no auto name
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"LogFileType",        2); // PDH binary counter log 
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"StartMode",          0); // manual start
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"StopMode",           0); // manual stop
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"RestartMode",        0); // no restart
            fwprintf(fOutFile, szHtmlStringParamFmt,     (LPCWSTR) L"EOFCommandFile",     "");

            // Get ready to list the counters
            fwprintf(fOutFile, szHtmlDecimalParamFmt,    (LPCWSTR) L"CounterCount",       DiskLog.dwNumLines);
        }
#else // output text
        UNREFERENCED_PARAMETER(szInFileName);

        // dump settings file header
        fOutFile = stdout;
        fprintf(fOutFile, "\nDL.dwNumLines = %d",        DiskLog.dwNumLines);
        fprintf(fOutFile, "\nDL.bManualRefresh  = %d",   DiskLog.bManualRefresh);
        fprintf(fOutFile, "\nDL.dwIntervalSecs  = %d",   DiskLog.dwIntervalSecs);
        fprintf(fOutFile, "\nDL.LogFileName = %ws",      DiskLog.LogFileName);
        fprintf(fOutFile, "\nDC.PO.bMenubar  = %d",      DiskLog.perfmonOptions.bMenubar);
        fprintf(fOutFile, "\nDC.PO.bToolbar   = %d",     DiskLog.perfmonOptions.bToolbar);
        fprintf(fOutFile, "\nDC.PO.bStatusbar   = %d",   DiskLog.perfmonOptions.bStatusbar);
        fprintf(fOutFile, "\nDC.PO.bAlwaysOnTop   = %d", DiskLog.perfmonOptions.bAlwaysOnTop);
#endif
    }
    if ((bSuccess) && (DiskLog.dwNumLines > 0)) {
        //the log settings file requires a special function to read the lines from
        ReadLines(hFile, fOutFile, PML_FILE, DiskLog.dwNumLines);
#ifdef _OUTPUT_HTML
        fwprintf(fOutFile, szObjectFooter);
#endif
    }

    return (bSuccess) ;

}  // OpenLog


BOOL 
OpenReport(
    HANDLE    hFile,
    FILE    * fOutFile,
    LPCWSTR   szObjectName
)
{  // OpenReport 
    DISKREPORT  DiskReport;
    BOOL        bSuccess = TRUE;
    DWORD       dwColor;

    // read the next section if valid
    bSuccess = FileRead(hFile, & DiskReport, sizeof(DISKREPORT));

    if (bSuccess) {
#ifdef _OUTPUT_HTML
        if (DiskReport.dwNumLines > 0) {
            // dump settings file header
            fwprintf(fOutFile, szObjectHeader, szObjectName);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ManualUpdate", DiskReport.bManualRefresh);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ShowToolbar",  DiskReport.perfmonOptions.bToolbar);
            // report intervals are reported in mS
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"UpdateInterval", (int) DiskReport.dwIntervalSecs / 1000);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"DisplayType",     3); // report type
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ReportValueType", 0); // default display value

            // derive the following from the current windows environment
            dwColor = GetSysColor(COLOR_WINDOW);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"BackColor",    dwColor);
            dwColor = GetSysColor(COLOR_3DFACE);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"BackColorCtl", dwColor);

            dwColor = GetSysColor(COLOR_BTNTEXT);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ForeColor", dwColor);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"GridColor", dwColor);

            dwColor = 0x00FF0000; // red
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"TimeBarColor", dwColor);

            // other perfmon settings that are assumed by perfmon but 
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"Appearance",  1);    // 3d appearance
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"BorderStyle", 0);   // no border        

            // Get ready to list the counters
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"CounterCount", DiskReport.dwNumLines);
        } // else no counters to dump
#else // output text
        // dump settings file header
        fprintf(fOutFile, "\nDR.dwNumLines = %d",        DiskReport.dwNumLines);
        fprintf(fOutFile, "\nDR.bManualRefresh  = %d",   DiskReport.bManualRefresh);
        fprintf(fOutFile, "\nDC.dwIntervalSecs  = %d",   DiskReport.dwIntervalSecs);
        fprintf(fOutFile, "\nDR.LV.crColor = 0x%8.8x",   * (DWORD *) & DiskReport.Visual.crColor);
        fprintf(fOutFile, "\nDR.LV.iColorIndex = %d",    DiskReport.Visual.iColorIndex);
        fprintf(fOutFile, "\nDR.LV.iStyle = %d",         DiskReport.Visual.iStyle);
        fprintf(fOutFile, "\nDR.LV.iStyleIndex = %d",    DiskReport.Visual.iStyleIndex);
        fprintf(fOutFile, "\nDR.LV.iWidth = %d",         DiskReport.Visual.iWidth);
        fprintf(fOutFile, "\nDR.LV.iWidthIndex = %d",    DiskReport.Visual.iWidthIndex);
        fprintf(fOutFile, "\nDC.PO.bMenubar  = %d",      DiskReport.perfmonOptions.bMenubar);
        fprintf(fOutFile, "\nDC.PO.bToolbar   = %d",     DiskReport.perfmonOptions.bToolbar);
        fprintf(fOutFile, "\nDC.PO.bStatusbar   = %d",   DiskReport.perfmonOptions.bStatusbar);
        fprintf(fOutFile, "\nDC.PO.bAlwaysOnTop   = %d", DiskReport.perfmonOptions.bAlwaysOnTop);
#endif
    }
    if ((bSuccess) && (DiskReport.dwNumLines > 0)) {
       ReadLines(hFile, fOutFile, PMR_FILE, DiskReport.dwNumLines);
#ifdef _OUTPUT_HTML
       fwprintf(fOutFile, szObjectFooter);
#endif
    }
    return (bSuccess);

}  // OpenReport 


BOOL 
OpenChart(
    HANDLE    hFile,
    FILE    * fOutFile,
    LPCWSTR   szObjectName
)
{  // OpenChart
    DISKCHART  DiskChart;
    BOOL       bSuccess = TRUE;
    DWORD      dwColor;

    // read the next section if valid
    bSuccess = FileRead(hFile, & DiskChart, sizeof(DISKCHART));
    if (bSuccess) {
#ifdef _OUTPUT_HTML
        if (DiskChart.dwNumLines > 0) {
            // dump settings file header
            fwprintf(fOutFile, szObjectHeader, szObjectName);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ManualUpdate",       DiskChart.bManualRefresh);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ShowLegend",         DiskChart.gOptions.bLegendChecked);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ShowScaleLabels",    DiskChart.gOptions.bLabelsChecked);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ShowVerticalGrid",   DiskChart.gOptions.bVertGridChecked);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ShowHorizontalGrid", DiskChart.gOptions.bHorzGridChecked);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ShowToolbar",        DiskChart.gOptions.bMenuChecked);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"MaximumScale",       DiskChart.gOptions.iVertMax);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"UpdateInterval",    (int) DiskChart.gOptions.eTimeInterval);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"DisplayType",       (DiskChart.gOptions.iGraphOrHistogram == BAR_GRAPH ? 2 : 1));

            // derive the following from the current windows environment
            dwColor = GetSysColor(COLOR_3DFACE);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"BackColor",    dwColor);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"BackColorCtl", dwColor);

            dwColor = GetSysColor(COLOR_BTNTEXT);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"ForeColor", dwColor);
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"GridColor", dwColor);

            dwColor = 0x00FF0000; // red
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"TimeBarColor", dwColor);

            // other perfmon settings that are assumed by perfmon but 
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"Appearance",  1);    // 3d appearance
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"BorderStyle", 0);   // no border        

            // Get ready to list the counters
            fwprintf(fOutFile, szHtmlDecimalParamFmt, (LPCWSTR) L"CounterCount", DiskChart.dwNumLines);
        } // else no counters to display
#else // output text
        // dump settings file header
        fprintf(fOutFile, "\nDC.dwNumLines = %d",            DiskChart.dwNumLines);
        fprintf(fOutFile, "\nDC.gMaxValues = %d",            DiskChart.gMaxValues);
        fprintf(fOutFile, "\nDC.bManualRefresh  = %d",       DiskChart.bManualRefresh);
        fprintf(fOutFile, "\nDC.LV.crColor = 0x%8.8x",       * (DWORD *) & DiskChart.Visual.crColor);
        fprintf(fOutFile, "\nDC.LV.iColorIndex = %d",        DiskChart.Visual.iColorIndex);
        fprintf(fOutFile, "\nDC.LV.iStyle = %d",             DiskChart.Visual.iStyle);
        fprintf(fOutFile, "\nDC.LV.iStyleIndex = %d",        DiskChart.Visual.iStyleIndex);
        fprintf(fOutFile, "\nDC.LV.iWidth = %d",             DiskChart.Visual.iWidth);
        fprintf(fOutFile, "\nDC.LV.iWidthIndex = %d",        DiskChart.Visual.iWidthIndex);
        fprintf(fOutFile, "\nDC.GO.bLegendChecked  = %d",    DiskChart.gOptions.bLegendChecked);
        fprintf(fOutFile, "\nDC.GO.bMenuChecked  = %d",      DiskChart.gOptions.bMenuChecked);
        fprintf(fOutFile, "\nDC.GO.bLabelsChecked = %d",     DiskChart.gOptions.bLabelsChecked);
        fprintf(fOutFile, "\nDC.GO.bVertGridChecked  = %d",  DiskChart.gOptions.bVertGridChecked);
        fprintf(fOutFile, "\nDC.GO.bHorzGridChecked  = %d",  DiskChart.gOptions.bHorzGridChecked);
        fprintf(fOutFile, "\nDC.GO.bStatusBarChecked  = %d", DiskChart.gOptions.bStatusBarChecked);
        fprintf(fOutFile, "\nDC.GO.iVertMax  = %d",          DiskChart.gOptions.iVertMax);
        fprintf(fOutFile, "\nDC.GO.eTimeInterval  = %e",     DiskChart.gOptions.eTimeInterval);
        fprintf(fOutFile, "\nDC.GO.iGraphOrHistogram  = %d", DiskChart.gOptions.iGraphOrHistogram);
        fprintf(fOutFile, "\nDC.GO.GraphVGrid = %d",         DiskChart.gOptions.GraphVGrid);
        fprintf(fOutFile, "\nDC.GO.GraphHGrid = %d",         DiskChart.gOptions.GraphHGrid);
        fprintf(fOutFile, "\nDC.GO.HistVGrid = %d",          DiskChart.gOptions.HistVGrid);
        fprintf(fOutFile, "\nDC.GO.HistHGrid  = %d",         DiskChart.gOptions.HistHGrid);
        fprintf(fOutFile, "\nDC.PO.bMenubar  = %d",          DiskChart.perfmonOptions.bMenubar);
        fprintf(fOutFile, "\nDC.PO.bToolbar   = %d",         DiskChart.perfmonOptions.bToolbar);
        fprintf(fOutFile, "\nDC.PO.bStatusbar   = %d",       DiskChart.perfmonOptions.bStatusbar);
        fprintf(fOutFile, "\nDC.PO.bAlwaysOnTop   = %d",     DiskChart.perfmonOptions.bAlwaysOnTop);
#endif
    }
    if ((bSuccess) && (DiskChart.dwNumLines > 0)) {
       ReadLines(hFile, fOutFile, PMC_FILE, DiskChart.dwNumLines);
#ifdef _OUTPUT_HTML
       fwprintf(fOutFile, szObjectFooter);
#endif
    }

    return (bSuccess);

}  // OpenChart

BOOL 
OpenWorkspace(
    LPCWSTR   szPerfmonFileName,
    HANDLE    hInFile,
    FILE    * fOutFile
)
{
    DISKWORKSPACE  DiskWorkspace;
    WCHAR          szObjectName[MAX_PATH];
    DWORD          dwObjectId = 1;
    BOOL           bReturn    = FALSE;

    if (! FileRead(hInFile, & DiskWorkspace, sizeof(DISKWORKSPACE))) {
      goto Exit0 ;
    }

    if (DiskWorkspace.ChartOffset == 0 &&
                     DiskWorkspace.AlertOffset  == 0 &&
                     DiskWorkspace.LogOffset    == 0 &&
                     DiskWorkspace.ReportOffset == 0) {
        // no entries to process
        goto Exit0 ;
    }

    if (DiskWorkspace.ChartOffset) {
        if (FileSeekBegin(hInFile, DiskWorkspace.ChartOffset) == 0xFFFFFFFF) {
           goto Exit0 ;
        }
        ZeroMemory(szObjectName, MAX_PATH * sizeof(WCHAR));
        StringCchPrintfW(szObjectName, MAX_PATH, szSysmonControlIdFmt, dwObjectId ++);
        // process chart entry
        if (! OpenChart(hInFile, fOutFile, szObjectName)) {
           goto Exit0 ;
        }
    }

    if (DiskWorkspace.AlertOffset) {
        if (FileSeekBegin(hInFile, DiskWorkspace.AlertOffset) == 0xffffffff) {
           goto Exit0 ;
        }
        ZeroMemory(szObjectName, MAX_PATH * sizeof(WCHAR));
        StringCchPrintfW(szObjectName, MAX_PATH, szSysmonControlIdFmt, dwObjectId ++);
        if (! OpenAlert(szPerfmonFileName, hInFile, fOutFile, szObjectName)) {
           goto Exit0 ;
        }
    }
    
    if (DiskWorkspace.LogOffset) {
        if (FileSeekBegin(hInFile, DiskWorkspace.LogOffset) == 0xffffffff) {
           goto Exit0 ;
        }
        ZeroMemory(szObjectName, MAX_PATH * sizeof(WCHAR));
        StringCchPrintfW(szObjectName, MAX_PATH, szSysmonControlIdFmt, dwObjectId ++);
        if (! OpenLog(szPerfmonFileName, hInFile, fOutFile, szObjectName)) {
           goto Exit0 ;
        }
    }
    
    if (DiskWorkspace.ReportOffset) {
        if (FileSeekBegin(hInFile, DiskWorkspace.ReportOffset) == 0xffffffff) {
           goto Exit0 ;
        }
        ZeroMemory(szObjectName, MAX_PATH * sizeof(WCHAR));
        StringCchPrintfW(szObjectName, MAX_PATH, szSysmonControlIdFmt, dwObjectId ++);
        if (! OpenReport(hInFile, fOutFile, szObjectName)) {
           goto Exit0 ;
        }
    }
    bReturn = TRUE;
    
Exit0:
   return bReturn;

}  // OpenWorkspace

BOOL
ConvertPerfmonFile(
    IN  LPCWSTR szPerfmonFileName,
    IN  LPCWSTR szSysmonFileName,
    IN  LPDWORD pdwFileType
)
{
    HANDLE           hInFile = INVALID_HANDLE_VALUE;
    PERFFILEHEADER   pfHeader;
    BOOL             bSuccess = FALSE;
    FILE           * fOutFile = NULL;
#ifdef _OUTPUT_HTML
    DWORD            dwColor;
#endif

    // open input file as read only
    hInFile = CreateFileW(
                    szPerfmonFileName,  // filename
                    GENERIC_READ,       // read access
                    0,                  // no sharing
                    NULL,               // default security
                    OPEN_EXISTING,      // only open existing files
                    FILE_ATTRIBUTE_NORMAL, // normal attributes
                    NULL);              // no template file
    if (hInFile != INVALID_HANDLE_VALUE) {
        bSuccess = FileRead(hInFile, & pfHeader, sizeof(PERFFILEHEADER));
        if (bSuccess) {
#ifdef _OUTPUT_HTML
            fOutFile = _wfopen(szSysmonFileName, (LPCWSTR) L"w+t");           
#else
            fOutFile = stdout;
#endif
            if (fOutFile != NULL) {
                dwColor = GetSysColor(COLOR_3DFACE);
                fwprintf(fOutFile, szHtmlHeader, (dwColor & 0x00FFFFFF));
                if (lstrcmpW(pfHeader.szSignature, szPerfChartSignature) == 0) {
#ifdef _DBG_MSG_PRINT
                    fprintf(stderr, "\nConverting Chart Settings file \"%ws\" to \n \"%ws\"",
                                    szPerfmonFileName,
                                    szSysmonFileName);
#endif
                    bSuccess      = OpenChart(hInFile, fOutFile, szSingleObjectName);
                    * pdwFileType = PMC_FILE;
                }
                else if (lstrcmpW(pfHeader.szSignature, szPerfAlertSignature) == 0) {
#ifdef _DBG_MSG_PRINT
                    fprintf(stderr, "\nConverting Alert Settings file \"%ws\" to \n \"%ws\"",
                                    szPerfmonFileName,
                                    szSysmonFileName);
#endif
                    bSuccess = OpenAlert(szPerfmonFileName, hInFile, fOutFile, szSingleObjectName);
                    * pdwFileType = PMA_FILE;
                }
                else if (lstrcmpW(pfHeader.szSignature, szPerfLogSignature) == 0) {
#ifdef _DBG_MSG_PRINT
                    fprintf(stderr, "\nConverting Log Settings file \"%ws\" to \n \"%ws\"",
                                    szPerfmonFileName,
                                    szSysmonFileName);
#endif
                    bSuccess = OpenLog(szPerfmonFileName, hInFile, fOutFile, szSingleObjectName);
                    * pdwFileType = PML_FILE;
                }
                else if (lstrcmpW(pfHeader.szSignature, szPerfReportSignature) == 0) {
#ifdef _DBG_MSG_PRINT
                    fprintf(stderr, "\nConverting Report Settings file \"%ws\" to \n \"%ws\"",
                                    szPerfmonFileName,
                                    szSysmonFileName);
#endif
                    bSuccess = OpenReport(hInFile, fOutFile, szSingleObjectName);
                    * pdwFileType = PMR_FILE;
                }
                else if (lstrcmpW(pfHeader.szSignature, szPerfWorkspaceSignature) == 0) {
#ifdef _DBG_MSG_PRINT
                    fprintf(stderr, "\nConverting Workspace Settings file \"%ws\" to \n \"%ws\"",
                                    szPerfmonFileName,
                                    szSysmonFileName);
#endif
                    bSuccess = OpenWorkspace(szPerfmonFileName, hInFile, fOutFile);
                    * pdwFileType = PMW_FILE;
                }
                else {
                    // not a valid signature
                    bSuccess = FALSE;
                }
                fwprintf(fOutFile, szHtmlFooter);
                fclose(fOutFile);
            }
            else {
                // not a valid file open
                bSuccess = FALSE;
            }
        }
    }

    if (hInFile != INVALID_HANDLE_VALUE) CloseHandle(hInFile);
    return bSuccess;
}

BOOL
MakeTempFileName (
    IN  LPCWSTR wszRoot,
    IN  LPWSTR  wszTempFilename,
    IN  DWORD   dwTempNameLen
)
{
    FILETIME  ft;
    DWORD     dwReturn = 0;
    HRESULT   hr       = S_OK;
    WCHAR     wszLocalFilename[MAX_PATH];

    GetSystemTimeAsFileTime(& ft);
    ZeroMemory(wszLocalFilename, MAX_PATH * sizeof(WCHAR));
    hr = StringCchPrintfW(wszLocalFilename,
                          MAX_PATH,
                          (LPCWSTR) L"%%temp%%\\%s_%8.8x%8.8x.htm",
                          (wszRoot != NULL ? wszRoot : (LPCWSTR) L"LodCtr"),
                          ft.dwHighDateTime,
                          ft.dwLowDateTime);
    if (hr == S_OK) {
        // expand env. vars
        dwReturn = ExpandEnvironmentStringsW(wszLocalFilename, wszTempFilename, dwTempNameLen);
    }
    return (BOOL)(dwReturn > 0);
}

BOOL
IsPerfmonFile(
    IN  LPWSTR szFileName
) 
{
    LPWSTR  szResult = NULL;

    _wcslwr(szFileName);
    if (szResult == NULL) szResult = wcsstr(szFileName, (LPCWSTR) L".pmc");  // test for chart settings file
    if (szResult == NULL) szResult = wcsstr(szFileName, (LPCWSTR) L".pmr");  // test for report settings file
    if (szResult == NULL) szResult = wcsstr(szFileName, (LPCWSTR) L".pma");  // test for alert settings file
    if (szResult == NULL) szResult = wcsstr(szFileName, (LPCWSTR) L".pml");  // test for log settings file
    if (szResult == NULL) szResult = wcsstr(szFileName, (LPCWSTR) L".pmw");  // test for workspace file 

    return (szResult == NULL) ? (FALSE) : (TRUE);
}

int
__cdecl wmain(
    int       argc,
    wchar_t * argv[]
)
{
    WCHAR               szCommandLine[MAXSTR];
    WCHAR               szArgList[MAX_ARG_STR];
    WCHAR               szTempFileName[MAXSTR];
    WCHAR               szTempArg[MAXSTR];
    LPWSTR              szArgFileName;
    int                 iThisArg;
    DWORD               dwArgListLen;
    DWORD               dwArgLen;
    STARTUPINFOW        startInfo;
    PROCESS_INFORMATION processInfo;
    DWORD               dwReturnValue     = ERROR_SUCCESS;
    BOOL                bSuccess          = TRUE;
    DWORD               dwPmFileType      = 0;
    BOOL                bPerfmonFileMade  = FALSE;
    BOOL                bDeleteFileOnExit = TRUE;

    ZeroMemory(& startInfo,    sizeof(STARTUPINFOW));
    ZeroMemory(& processInfo,  sizeof(PROCESS_INFORMATION));
    ZeroMemory(szCommandLine,  MAXSTR      * sizeof(WCHAR));
    ZeroMemory(szArgList,      MAX_ARG_STR * sizeof(WCHAR));
    ZeroMemory(szTempFileName, MAXSTR      * sizeof(WCHAR));
    ZeroMemory(szTempArg,      MAXSTR      * sizeof(WCHAR));

    startInfo.cb          = sizeof(startInfo); 
    startInfo.dwFlags     = STARTF_USESTDHANDLES; 
    startInfo.wShowWindow = SW_SHOWDEFAULT; 

    dwArgListLen = ExpandEnvironmentStringsW(szMmcExeCmd, szCommandLine, MAXSTR);
    dwArgListLen = ExpandEnvironmentStringsW(szMmcExeArg, szArgList,     MAX_ARG_STR);
    szArgList[MAX_ARG_STR - 1] = UNICODE_NULL;

    if (argc >= 2) {
        for (iThisArg = 1; iThisArg < argc; iThisArg ++) {
            if (IsPerfmonFile(argv[iThisArg])) {
                if (! bPerfmonFileMade) {
                    if (szTempFileName[0] == UNICODE_NULL) {
                        // if there's no filename, then make one
                        MakeTempFileName((LPCWSTR) L"PMSettings", szTempFileName, MAXSTR);
                    }
                    bSuccess = ConvertPerfmonFile(argv[iThisArg], szTempFileName, & dwPmFileType);
                    if (bSuccess) {
                        ZeroMemory(szTempArg, MAXSTR * sizeof(WCHAR));
                        StringCchPrintfW(szTempArg,
                                         MAXSTR,
                                         szMmcExeSetsArg, 
                                         (PML_FILE == dwPmFileType || PMA_FILE == dwPmFileType) 
                                                         ? szMmcExeSetsLogOpt : szEmpty,
                                         szTempFileName);
                        bPerfmonFileMade = TRUE;
                    }
                    else {
                        // ignore this parameter
                        szTempArg[0] = UNICODE_NULL;
                        szTempArg[1] = UNICODE_NULL;
                    }
                }
            }
            else if (lstrcmpiW(argv[iThisArg], (LPCWSTR) L"/WMI") == 0) {
                // this is a special switch
                ZeroMemory(szTempArg, MAXSTR * sizeof(WCHAR));
                StringCchCopyW(szTempArg, MAXSTR, (LPCWSTR) L"/SYSMON_WMI");
            }
            else if (   (argv[iThisArg][0] == L'/') 
                     && ((argv[iThisArg][1] == L'H') || (argv[iThisArg][1] == L'h'))
                     && ((argv[iThisArg][2] == L'T') || (argv[iThisArg][2] == L't'))
                     && ((argv[iThisArg][3] == L'M') || (argv[iThisArg][3] == L'm'))
                     && ((argv[iThisArg][4] == L'L') || (argv[iThisArg][4] == L'l'))
                     && ((argv[iThisArg][5] == L'F') || (argv[iThisArg][5] == L'f'))
                     && ((argv[iThisArg][6] == L'I') || (argv[iThisArg][6] == L'i'))
                     && ((argv[iThisArg][7] == L'L') || (argv[iThisArg][7] == L'l'))
                     && ((argv[iThisArg][8] == L'E') || (argv[iThisArg][8] == L'e'))
                     && (argv[iThisArg][9] == L':')) {
                szArgFileName = &argv[iThisArg][10];
                if (bPerfmonFileMade) {
                    // then copy the file from the temp to the save file
                    CopyFileW(szTempFileName, szArgFileName, FALSE);
                }
                else {
                    // else set the perfmon file name to the one specified in the command line
                    ZeroMemory(szTempArg, MAXSTR * sizeof(WCHAR));
                    StringCchCopyW(szTempFileName, MAXSTR, szArgFileName);
                    bDeleteFileOnExit = FALSE;
                }
            }
            else {
                // just copy the arg
                ZeroMemory(szTempArg, MAXSTR * sizeof(WCHAR));
                StringCchCopyW(szTempArg, MAXSTR, argv[iThisArg]);
                szTempArg[MAXSTR - 1] = UNICODE_NULL;
            } 

            dwArgLen = lstrlenW(szTempArg) + 1;
            if ((dwArgLen + dwArgListLen) < MAX_ARG_STR) {
                szArgList[dwArgListLen - 1] = L' ';  // add in delimiter
                StringCchCopyW(& szArgList[dwArgListLen],
                               MAX_ARG_STR - dwArgListLen - 1,
                               szTempArg);
                dwArgListLen += dwArgLen;
            }
            else {
                // no more room in the arg list buffer so bail
                break;
            }
        }
    }

    if (bSuccess) {
#ifdef _DBG_MSG_PRINT
        fwprintf(stderr, (LPCWSTR) L"\nStarting \"%ws\" \"%ws\"", szCommandLine, szArgList);
#endif
        bSuccess = CreateProcessW(
                        szCommandLine,
                        szArgList,
                        NULL,
                        NULL,
                        FALSE,
                        DETACHED_PROCESS,
                        NULL,
                        NULL,
                        & startInfo,
                        & processInfo);
        if (! bSuccess) {
            dwReturnValue = GetLastError();
        }
        else {
            Sleep(5000); // wait for things to get going            
            CloseHandle(processInfo.hProcess);
            CloseHandle(processInfo.hThread);
        }
        
#ifndef _DBG_MSG_PRINT
        if (bPerfmonFileMade && bDeleteFileOnExit) {
            DeleteFileW(szTempFileName);
        }
#endif
    }

    return (int) dwReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\flexarry.cpp ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  FLEXARRY.CPP
//
//  CFlexArray implementation (non-arena).
//
//  15-Jul-97  raymcc   Created.
//   8-Jun-98  bobw     cleaned up for WBEMPERF usage
//
//***************************************************************************

#include "wpheader.h"
#include <stdio.h>

//***************************************************************************
//
//  CFlexArray::CFlexArray
//
//  Constructs the array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************
// ok
CFlexArray::CFlexArray(
    int nSize,
    int nGrowBy
    )
{
    m_nExtent = nSize;
    m_nSize = 0;
    m_nGrowBy = nGrowBy;
    m_hHeap = GetProcessHeap(); // call this once and save heap handle locally

    m_pArray = (void **) ALLOCMEM(m_hHeap, HEAP_ZERO_MEMORY, sizeof(void *) * nSize);

    if( NULL == m_pArray ){
        assert(FALSE);
        m_nExtent = 0;
    }    
}

//***************************************************************************
//
//  CFlexArray::~CFlexArray
//
//***************************************************************************
// ok
CFlexArray::~CFlexArray()
{
    FREEMEM(m_hHeap, 0, m_pArray);
}

//***************************************************************************
//
//  Copy constructor.
//
//  Copies the pointers, not their contents.
//
//***************************************************************************
// ok
CFlexArray::CFlexArray(CFlexArray &Src)
{
    m_pArray = 0;
    m_nSize = 0;
    m_nExtent = 0;
    m_nGrowBy = 0;

    *this = Src;
}

//***************************************************************************
//
//  operator =
//
//  Assignment operator.
//
//  Arenas are not copied.  This allows transfer of arrays between arenas.
//  Arrays are copied by pointer only.
//
//***************************************************************************
// ok
CFlexArray& CFlexArray::operator=(CFlexArray &Src)
{
    m_nSize   = Src.m_nSize;
    m_nExtent = Src.m_nExtent;
    m_nGrowBy = Src.m_nGrowBy;

    FREEMEM (m_hHeap, 0, m_pArray);
    m_pArray = (void **) ALLOCMEM(m_hHeap, HEAP_ZERO_MEMORY, sizeof(void *) * m_nExtent);
    if (m_pArray) {
        memcpy(m_pArray, Src.m_pArray, sizeof(void *) * m_nExtent);
    }

    return *this;
}

//***************************************************************************
//
//  CFlexArray::RemoveAt
//
//  Removes the element at the specified location.  Does not
//  actually delete the pointer. Shrinks the array over the top of
//  the 'doomed' element.
//
//  Parameters:
//  <nIndex>    The location of the element.
//
//  Return value:
//  range_error     The index is not legal.
//  no_error        Success.
//
//***************************************************************************
// ok
int CFlexArray::RemoveAt(int nIndex)
{
    int i;

    if (nIndex >= m_nSize) {
        return range_error;
    }

    for (i = nIndex; i < m_nSize - 1; i++) {
        m_pArray[i] = m_pArray[i + 1];
    }

    m_nSize--;
    m_pArray[m_nSize] = 0;

    return no_error;
}

int CFlexArray::Remove( void* p )
{
    for (int i = 0; i < m_nSize; i++) {
        if( m_pArray[i] == p ){
            return RemoveAt( i );
        }
    }

    return failed;   
}

//***************************************************************************
//
//  CFlexArray::InsertAt
//
//  Inserts a new element at the specified location.  The pointer is copied.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to insert the new element.
//  <pSrc>          The pointer to copy. (contents are not copied).
//
//  Return value:
//  array_full
//  out_of_memory
//  no_error
//
//***************************************************************************
// ok
int CFlexArray::InsertAt(int nIndex, void *pSrc)
{
    void    **pTmp; // pointer to new array
    int     nReturn = no_error;
    LONG    lOldSize;
    LONG    lNewSize;

    // If the array is full, we need to expand it.
    // ===========================================

    if (m_nSize == m_nExtent) {
        if (m_nGrowBy == 0) {
            nReturn  = array_full;
        } else {
            // compute sizes
            lOldSize = sizeof(void *) * m_nExtent;
            m_nExtent += m_nGrowBy;
            lNewSize = sizeof(void *) * m_nExtent;

            // allocate new array
            pTmp = (void **) ALLOCMEM(m_hHeap, HEAP_ZERO_MEMORY, lNewSize);
            if (!pTmp) {
                nReturn = out_of_memory;
            } else {
                // move bits from old array to new array
                memcpy (pTmp, m_pArray, lOldSize);
                // toss old arrya
                FREEMEM (m_hHeap, 0, m_pArray);
                // save pointer to new array
                m_pArray = pTmp;
            }
        }
    }

    if( nIndex > m_nSize ){
       nReturn = range_error;
    }

    // Special case of appending.  This is so frequent
    // compared to true insertion that we want to optimize.
    // ====================================================

    if (nReturn == no_error) {
        if (nIndex == m_nSize)  {
            m_pArray[m_nSize++] = pSrc;
        } else {
            // If here, we are inserting at some random location.
            // We start at the end of the array and copy all the elements
            // one position farther to the end to make a 'hole' for
            // the new element.
            // ==========================================================

            for (int i = m_nSize; i > nIndex; i--) {
                m_pArray[i] = m_pArray[i - 1];
            }

            m_pArray[nIndex] = pSrc;
            m_nSize++;
        }
    }
    return nReturn;
}

//***************************************************************************
//
//  CFlexArray::Compress
//
//  Removes NULL elements by moving all non-NULL pointers to the beginning
//  of the array.  The array "Size" changes, but the extent is untouched.
//
//***************************************************************************
// ok
void CFlexArray::Compress()
{
    int nLeftCursor = 0, nRightCursor = 0;

    while (nLeftCursor < m_nSize - 1) {
        if (m_pArray[nLeftCursor]) {
            nLeftCursor++;
            continue;
        }
        else {
            nRightCursor = nLeftCursor + 1;
            while (m_pArray[nRightCursor] == 0 && nRightCursor < m_nSize)
                nRightCursor++;
            if (nRightCursor == m_nSize)
                break;  // Short circuit, no more nonzero elements.
            m_pArray[nLeftCursor] = m_pArray[nRightCursor];
            m_pArray[nRightCursor] = 0;
        }
    }

    while (m_pArray[m_nSize - 1] == 0 && m_nSize > 0) m_nSize--;
}

//***************************************************************************
//
//  CFlexArray::Empty
//
//  Clears the array of all pointers (does not deallocate them) and sets
//  its apparent size to zero.
//
//***************************************************************************
// ok
void CFlexArray::Empty()
{
    FREEMEM(m_hHeap, 0, m_pArray);
    m_pArray = (void **) ALLOCMEM(m_hHeap, HEAP_ZERO_MEMORY, sizeof(void *) * m_nGrowBy);
    m_nSize = 0;
    m_nExtent = m_nGrowBy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\flexarry.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  FLEXARRY.H
//
//  CFlexArray and CWStringArray implementation.
//
//  This
//
//  15-Jul-97   raymcc    This implementation is not based on arenas.
//   8-Jun-98   bobw      cleaned up for use with WBEMPERF provider
//
//***************************************************************************

#ifndef _FLEXARRY_H_
#define _FLEXARRY_H_

#ifdef __cplusplus
//***************************************************************************
//
//  class CFlexArray
//
//  This class is a generic pointer array.
//
//***************************************************************************

class CFlexArray
{
private:
    int     m_nSize;            // apparent size
    int     m_nExtent;          // de facto size
    int     m_nGrowBy;          
    HANDLE  m_hHeap;            // heap to hold array
    void**  m_pArray;
            
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };

    // Constructs a flex array at an initial size and
    // specifies the initial size and growth-size chunk.
    // =================================================
    CFlexArray(
        IN int nInitialSize = 32, 
        IN int nGrowBy = 32
        );

   ~CFlexArray(); 
    CFlexArray(CFlexArray &);
    CFlexArray& operator=(CFlexArray &);

    // Gets an element at a particular location.
    // =========================================
    void *  GetAt(int nIndex) const { return m_pArray[nIndex]; }

    // Returns a ptr in the array; allows use on left-hand side of assignment.
    // =======================================================================
    void * operator[](int nIndex) const { return m_pArray[nIndex]; }
    void *& operator[](int nIndex) { return m_pArray[nIndex]; }

    // Sets the element at the requested location.
    // ===========================================
    void  SetAt(int nIndex, void *p) { m_pArray[nIndex] = p; }

    // Removes an element.
    // ====================
    int   RemoveAt(int nIndex);
    int   Remove( void* p );
    
    // Inserts an element.
    // ===================
    int   InsertAt(int nIndex, void *);

    // Removes all zero entries (null ptrs) and shrinks the array size.
    // ================================================================
    void  Compress();    

    // Adds a new element to the end of the array.
    // ===========================================
    int   Add(void *pSrc) { return InsertAt(m_nSize, pSrc); }    

    // Gets the apparent size of the array (number of used elements)
    // =============================================================
    int   Size() const { return m_nSize; }

    // Removes all entries and reduces array size to zero. The elements
    // are simply removed; not deallocated (this class doesn't know what
    // they are).
    // =================================================================
    void  Empty();

    // Gets a pointer to the internal array.
    // =====================================
    void** GetArrayPtr() { return m_pArray; }
};

#endif  // __cplusplus
#endif  // not defined
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\ntperf.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntperf.cpp

Abstract:

    Mapped NT5 Perf counter provider

History:

    raymcc      02-Dec-97   Created.        
    raymcc      20-Feb-98   Updated to use new initializer.
    bobw         8-Jun-98   tuned up

--*/

#include "wpheader.h"
#include <stdio.h>
#include "oahelp.inl"


//***************************************************************************
//
//  CNt5PerfProvider constructor
//
//***************************************************************************
// ok

CNt5PerfProvider::CNt5PerfProvider(enumCLSID OriginClsid)
{
    m_lRef = 0;
    m_OriginClsid = OriginClsid;
    m_hClassMapMutex = CreateMutex(NULL, FALSE, NULL);
}

//***************************************************************************
//
//  CNt5PerfProvider destructor
//
//***************************************************************************
// ok

CNt5PerfProvider::~CNt5PerfProvider()
{
    int i;
    CClassMapInfo *pClassElem;

    assert (m_lRef == 0);

    for (i = 0; i < m_aCache.Size(); i++) {
        pClassElem = (CClassMapInfo *) m_aCache[i];
        m_PerfObject.RemoveClass (pClassElem->m_pClassDef);
        delete pClassElem;
    }
    m_aCache.Empty(); // reset the buffer pointers

    if (m_hClassMapMutex != 0)
        CloseHandle(m_hClassMapMutex);

    // RegCloseKey(HKEY_PERFORMANCE_DATA); // causes more problems than it solves

}

//***************************************************************************
//
//  CNt5PerfProvider::AddRef
//
//  Standard COM AddRef().
//
//***************************************************************************
// ok

ULONG CNt5PerfProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CNt5PerfProvider::Release
//
//  Standard COM Release().
//
//***************************************************************************
// ok

ULONG CNt5PerfProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) {
        delete this;
    }
    return lRef;
}

//***************************************************************************
//
//  CNt5PerfProvider::QueryInterface
//
//  Standard COM QueryInterface().  We have to support two interfaces,
//  the IWbemHiPerfProvider interface itself to provide the objects and
//  the IWbemProviderInit interface to initialize the provider.
//
//***************************************************************************
// ok

HRESULT CNt5PerfProvider::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hReturn;

    if (riid == IID_IUnknown || riid == IID_IWbemHiPerfProvider) {
        *ppv = (IWbemHiPerfProvider*) this;
        AddRef();
        hReturn = S_OK;
    } else if (riid == IID_IWbemProviderInit) {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        hReturn = S_OK;
    } else {
        *ppv = NULL;
        hReturn = E_NOINTERFACE;
    }
    return hReturn;
}

//***************************************************************************
//
//  CNt5PerfProvider::Initialize
//
//  Called once during startup.  Indicates to the provider which
//  namespace it is being invoked for and which User.  It also supplies
//  a back pointer to CIMOM so that class definitions can be retrieved.
//
//  We perform any one-time initialization in this routine. The
//  final call to Release() is for any cleanup.
//
//  <wszUser>           The current user.
//  <lFlags>            Reserved.
//  <wszNamespace>      The namespace for which we are being activated.
//  <wszLocale>         The locale under which we are to be running.
//  <pNamespace>        An active pointer back into the current namespace
//                      from which we can retrieve schema objects.
//  <pCtx>              The user's context object.  We simply reuse this
//                      during any reentrant operations into CIMOM.
//  <pInitSink>         The sink to which we indicate our readiness.
//
//***************************************************************************
// ok

HRESULT CNt5PerfProvider::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          LONG lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink
    )
{
    UNREFERENCED_PARAMETER(wszUser);
    UNREFERENCED_PARAMETER(lFlags);
    UNREFERENCED_PARAMETER(wszNamespace);
    UNREFERENCED_PARAMETER(wszLocale);
    UNREFERENCED_PARAMETER(pNamespace);
    UNREFERENCED_PARAMETER(pCtx);

    pInitSink->SetStatus(0, WBEM_S_INITIALIZED);

    return NO_ERROR;
}
    
//***************************************************************************
//
//  CNt5PerfProvider::QueryInstances
//
//  Called whenever a complete, fresh list of instances for a given
//  class is required.   The objects are constructed and sent back to the
//  caller through the sink.  The sink can be used in-line as here, or
//  the call can return and a separate thread could be used to deliver
//  the instances to the sink.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  This
//                      should not be AddRef'ed or retained past the
//                      execution of this method.
//  <wszClass>          The class name for which instances are required.
//  <lFlags>            Reserved.
//  <pCtx>              The user-supplied context (used during callbacks
//                      into CIMOM).
//  <pSink>             The sink to which to deliver the objects.  The objects
//                      can be delivered synchronously through the duration
//                      of this call or asynchronously (assuming we
//                      had a separate thread).  A IWbemObjectSink::SetStatus
//                      call is required at the end of the sequence.
//
//***************************************************************************
//  ok
HRESULT CNt5PerfProvider::QueryInstances( 
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */  WCHAR __RPC_FAR *wszClass,
    /* [in] */          long lFlags,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemObjectSink __RPC_FAR *pSink
    )
{
    HRESULT hReturn;
    BOOL bRes ;
    CClassMapInfo *pClsMap = NULL;

    UNREFERENCED_PARAMETER(lFlags);

    hReturn = CoImpersonateClient(); // make sure we're legit.

    BOOL    fRevert = SUCCEEDED( hReturn );

    // The following error appears to occur when we are in-proc and there is no
    // proxy/stub, so we are effectively impersonating already

    if ( RPC_E_CALL_COMPLETE == hReturn ) {
        hReturn = S_OK;
    } 

    if (S_OK == hReturn) {
        hReturn = CheckImpersonationLevel();
    }
    // Check Registry security here.
    if ((hReturn != S_OK) || (!HasPermission())) {
        // if Impersonation level is incorrect or
        // the caller doesn't have permission to read
        // from the registry, then they cannot continue
        hReturn = WBEM_E_ACCESS_DENIED;
    }

    if (hReturn == S_OK) {

        if (pNamespace == 0 || wszClass == 0 || pSink == 0) {
            hReturn = WBEM_E_INVALID_PARAMETER;
        } else {

            // Ensure the class is in our cache and mapped.
            // ============================================
            bRes = MapClass(pNamespace, wszClass, pCtx);

            if (bRes == FALSE)  {
                // Class is not one of ours.
                hReturn = WBEM_E_INVALID_CLASS;
            } else {
                pClsMap = FindClassMap(wszClass);
                if (pClsMap == NULL) {
                    hReturn = WBEM_E_INVALID_CLASS;
                }
            }

            if (hReturn == NO_ERROR) {
                // Refresh the instances.
                // ======================

                PerfHelper::QueryInstances(&m_PerfObject, pClsMap, pSink);

                // Tell CIMOM we are finished.
                // ===========================

                pSink->SetStatus(0, WBEM_NO_ERROR, 0, 0);
                hReturn = NO_ERROR;
            }
        }
    } else {
        // return error
    }

    // Revert if we successfuly impersonated the user
    if ( fRevert )
    {
        CoRevertToSelf();
    }

    return hReturn;
}    

//***************************************************************************
//
//  CNt5PerfProvider::CreateRefresher
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  Not used.
//  <lFlags>            Not used.
//  <ppRefresher>       Receives the requested refresher.
//
//***************************************************************************        
// ok
HRESULT CNt5PerfProvider::CreateRefresher( 
     /* [in] */ IWbemServices __RPC_FAR *pNamespace,
     /* [in] */ long lFlags,
     /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
     )
{
    HRESULT hReturn;
    CNt5Refresher *pNewRefresher;

    UNREFERENCED_PARAMETER(lFlags);

    hReturn = CoImpersonateClient(); // make sure we're legit.

    BOOL    fRevert = SUCCEEDED( hReturn );

    // The following error appears to occur when we are in-proc and there is no
    // proxy/stub, so we are effectively impersonating already

    if ( RPC_E_CALL_COMPLETE == hReturn ) {
        hReturn = S_OK;
    } 

    if (S_OK == hReturn) {
        hReturn = CheckImpersonationLevel();
    }
    // Check Registry security here.
    if ((hReturn != S_OK) || (!HasPermission())) {
        // if Impersonation level is incorrect or
        // the caller doesn't have permission to read
        // from the registry, then they cannot continue
        hReturn = WBEM_E_ACCESS_DENIED;
    }

    if (hReturn == S_OK) {

        if (pNamespace == 0 || ppRefresher == 0) {
            hReturn = WBEM_E_INVALID_PARAMETER;
        } else {
            // Construct a new empty refresher.
            // ================================        
            pNewRefresher = new CNt5Refresher (this);

            if (pNewRefresher != NULL) {
                // Follow COM rules and AddRef() the thing before sending it back.
                // ===============================================================
                pNewRefresher->AddRef();
                *ppRefresher = pNewRefresher;
    
                hReturn = NO_ERROR;
            } else {
                hReturn = WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    // Revert if we successfuly impersonated the user
    if ( fRevert )
    {
        CoRevertToSelf();
    }

    return hReturn;
}

//***************************************************************************
//
//  CNt5PerfProvider::CreateRefresherObject
//
//  Called whenever a user wants to include an object in a refresher.
//     
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace in CIMOM.
//  <pTemplate>         A pointer to a copy of the object which is to be
//                      added.  This object itself cannot be used, as
//                      it not owned locally.        
//  <pRefresher>        The refresher to which to add the object.
//  <lFlags>            Not used.
//  <pContext>          Not used here.
//  <ppRefreshable>     A pointer to the internal object which was added
//                      to the refresher.
//  <plId>              The Object Id (for identification during removal).        
//
//***************************************************************************        
// ok

HRESULT CNt5PerfProvider::CreateRefresherObject( 
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [string][in] */ LPCWSTR wszClass,
    /* [in] */ IWbemHiPerfEnum __RPC_FAR *pHiPerfEnum,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId
    )
{
    IWbemClassObject    *pOriginal = 0;
    IWbemClassObject    *pNewCopy = 0;    
    IWbemObjectAccess   *pNewAccess = 0;
    CNt5Refresher       *pRef = 0;
    CClassMapInfo       *pClsMap;
    VARIANT             v; 
    BOOL                bRes;
    HRESULT             hReturn = NO_ERROR;
    CBSTR               cbClassName(cszClassName);
    
    UNREFERENCED_PARAMETER(lFlags);

    if( NULL == (BSTR)cbClassName ){
        return WBEM_E_OUT_OF_MEMORY;
    }

    if (ppRefreshable != NULL) {
        // Initialize the argument
        *ppRefreshable = 0;
    }

    // init the variant 
    VariantInit(&v);

    if (pTemplate != NULL) {
        // Make a copy of the template object.
        // ===================================
        hReturn = pTemplate->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pOriginal);
        if (hReturn == NO_ERROR) {
            hReturn = pOriginal->Clone(&pNewCopy);

            // Get the class name of the object.
            // =================================
            if (hReturn == NO_ERROR) {
                hReturn = pOriginal->Get( cbClassName, 0, &v, 0, 0);
                if ((hReturn == NO_ERROR) && (v.vt != VT_BSTR)) {
                    hReturn = WBEM_E_INVALID_CLASS;
                }
            }

            // We are now done with the original object
            // ========================================
            pOriginal->Release();   
        }

        if (hReturn == NO_ERROR) {
            // We now get the IWbemObjectAccess form of the cloned object
            // and release the unused interface.
            // ==========================================================
            hReturn = pNewCopy->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pNewAccess);
        }

        if( NULL != pNewCopy ){
            pNewCopy->Release();
        }
        
    } else {
        // copy the class name passed in
        v.vt = VT_BSTR;
        v.bstrVal = SysAllocString(wszClass);
    }

    if (hReturn == NO_ERROR) {
        // cast refresher pointer to our refresher object
        pRef = (CNt5Refresher *) pRefresher;

        // Map the class info for this instance.
        // =====================================
        bRes = MapClass(pNamespace, V_BSTR(&v), pContext);
        if (bRes == FALSE) {
           // Class is not one of ours.
           if (pNewAccess != NULL) pNewAccess->Release();
           hReturn = WBEM_E_INVALID_CLASS;
        } else {
            pClsMap = FindClassMap(V_BSTR(&v));
            if (pClsMap == 0) {
                if (pNewAccess != NULL) pNewAccess->Release();
                hReturn = WBEM_E_INVALID_CLASS;
            } else {
                // Add the object to the refresher.
                if (pHiPerfEnum != NULL) {
                    // then this is an Enum object so add it
                    bRes = pRef->AddEnum (
                                pHiPerfEnum,
                                pClsMap,
                                plId);
                    if (bRes) {    
                        // Return new ID to caller
                        // ==========================
                        hReturn = NO_ERROR;
                    } else {
                        // unable to add enumerator
                        pNewAccess->Release();
                        hReturn = GetLastError();
                    }
                } else {
                    // This method will AddRef() the object before returning.
                    // ======================================================
                    bRes = pRef->AddObject(
                                &pNewAccess, 
                                pClsMap,        
                                plId);
                    if (bRes) {    
                        // Return object to the user.
                        // ==========================
                        *ppRefreshable = pNewAccess;
                        hReturn = NO_ERROR;
                    } else {
                        // unable to add object
                        pNewAccess->Release();
                        hReturn = GetLastError();
                    }
                }
            }
        }
    }

    VariantClear(&v);    

    return hReturn;
}

//***************************************************************************
//
//  CNt5PerfProvider::CreateRefreshableObject
//
//  Called whenever a user wants to include an object in a refresher.
//     
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace in CIMOM.
//  <pTemplate>         A pointer to a copy of the object which is to be
//                      added.  This object itself cannot be used, as
//                      it not owned locally.        
//  <pRefresher>        The refresher to which to add the object.
//  <lFlags>            Not used.
//  <pContext>          Not used here.
//  <ppRefreshable>     A pointer to the internal object which was added
//                      to the refresher.
//  <plId>              The Object Id (for identification during removal).        
//
//***************************************************************************        
// ok

HRESULT CNt5PerfProvider::CreateRefreshableObject( 
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId
    )
{


    HRESULT             hReturn = NO_ERROR;

    hReturn = CoImpersonateClient(); // make sure we're legit.

    BOOL    fRevert = SUCCEEDED( hReturn );

    // The following error appears to occur when we are in-proc and there is no
    // proxy/stub, so we are effectively impersonating already

    if ( RPC_E_CALL_COMPLETE == hReturn ) {
        hReturn = S_OK;
    } 

    if (S_OK == hReturn) {
        hReturn = CheckImpersonationLevel();
    }
    // Check Registry security here.
    if ((hReturn != S_OK) || (!HasPermission())) {
        // if Impersonation level is incorrect or
        // the caller doesn't have permission to read
        // from the registry, then they cannot continue
        hReturn = WBEM_E_ACCESS_DENIED;
    }

    if (hReturn == S_OK) {
    
        hReturn = CreateRefresherObject( 
            pNamespace,
            pTemplate,
            pRefresher,
            lFlags,
            pContext,
            NULL,
            NULL,
            ppRefreshable,
            plId);
    }

    // Revert if we successfuly impersonated the user
    if ( fRevert )
    {
        CoRevertToSelf();
    }

    return hReturn;
}
    
//***************************************************************************
//
//  CNt5PerfProvider::StopRefreshing
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//  <pRefresher>            The refresher object from which we are to 
//                          remove the perf object.
//  <lId>                   The ID of the object.
//  <lFlags>                Not used.
//  
//***************************************************************************        
// ok
        
HRESULT CNt5PerfProvider::StopRefreshing( 
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags
    )
{
    CNt5Refresher *pRef;
    BOOL bRes ;
    HRESULT hReturn;

    UNREFERENCED_PARAMETER(lFlags);

    hReturn = CoImpersonateClient(); // make sure we're legit.

    BOOL    fRevert = SUCCEEDED( hReturn );

    // The following error appears to occur when we are in-proc and there is no
    // proxy/stub, so we are effectively impersonating already

    if ( RPC_E_CALL_COMPLETE == hReturn ) {
        hReturn = S_OK;
    } 

    if (S_OK == hReturn) {
        hReturn = CheckImpersonationLevel();
    }
    // Check Registry security here.
    if ((hReturn != S_OK) || (!HasPermission())) {
        // if Impersonation level is incorrect or
        // the caller doesn't have permission to read
        // from the registry, then they cannot continue
        hReturn = WBEM_E_ACCESS_DENIED;
    }

    if (hReturn == S_OK) {

        pRef = (CNt5Refresher *) pRefresher;

        bRes = pRef->RemoveObject(lId);
        if (bRes == FALSE) {
            hReturn = WBEM_E_FAILED;
        } else {
            hReturn = WBEM_NO_ERROR;
        }
    }

    // Revert if we successfuly impersonated the user
    if ( fRevert )
    {
        CoRevertToSelf();
    }
    
    return hReturn;
}
 
HRESULT CNt5PerfProvider::CreateRefreshableEnum( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [string][in] */ LPCWSTR wszClass,
        /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pContext,
        /* [in] */ IWbemHiPerfEnum __RPC_FAR *pHiPerfEnum,
        /* [out] */ long __RPC_FAR *plId)
{
    HRESULT     hReturn;

    hReturn = CoImpersonateClient(); // make sure we're legit.

    BOOL    fRevert = SUCCEEDED( hReturn );

    // The following error appears to occur when we are in-proc and there is no
    // proxy/stub, so we are effectively impersonating already

    if ( RPC_E_CALL_COMPLETE == hReturn ) {
        hReturn = S_OK;
    } 

    if (S_OK == hReturn) {
        hReturn = CheckImpersonationLevel();
    }
    // Check Registry security here.
    if ((hReturn != S_OK) || (!HasPermission())) {
        // if Impersonation level is incorrect or
        // the caller doesn't have permission to read
        // from the registry, then they cannot continue
        hReturn = WBEM_E_ACCESS_DENIED;
    }

    if (hReturn == S_OK) {

        hReturn = CreateRefresherObject( 
            pNamespace,
            NULL,
            pRefresher,
            lFlags,
            pContext,
            wszClass,
            pHiPerfEnum,
            NULL,
            plId);
    }

    // Revert if we successfuly impersonated the user
    if ( fRevert )
    {
        CoRevertToSelf();
    }
    
    return hReturn;
}
 
HRESULT CNt5PerfProvider::GetObjects( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [in] */ long lNumObjects,
        /* [size_is][in] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pContext)
{
    DBG_UNREFERENCED_PARAMETER(pNamespace);
    DBG_UNREFERENCED_PARAMETER(lNumObjects);
    DBG_UNREFERENCED_PARAMETER(apObj);
    DBG_UNREFERENCED_PARAMETER(lFlags);
    DBG_UNREFERENCED_PARAMETER(pContext);

    return WBEM_E_METHOD_NOT_IMPLEMENTED;
}  
 
//***************************************************************************
//
//  CNt5PerfProvider::MapClass
//
//  Adds the class map to an internal cache.
//
//  <pClsMap>           The pointer to the map info to add.  This pointer
//                      is acquired by this function and should not be
//                      deleted by the caller.
//
//***************************************************************************
// ok
BOOL CNt5PerfProvider::AddClassMap(
    IN CClassMapInfo *pClsMap
    )
{
    DWORD           dwResult = ERROR_SUCCESS;
    int             i;
    CClassMapInfo   *pTracer;
    int             nNumElements;
    BOOL bInCache = FALSE;
    
    if (m_hClassMapMutex != 0) {
        if (WAIT_OBJECT_0 == WaitForSingleObject(m_hClassMapMutex, cdwClassMapTimeout)) {
            nNumElements = m_aCache.Size();

            // Because of a problem in which perflibs seem to ignore supported methods of updating
            // the perflib names database (lodctr/unlodctr), do a quick initial traversal to ensure
            // that we don't have any duplicate object indices, since this can cause real problems
            // during adding and refreshing, since incorrect indexes can be returned.

            for (i = 0; i < nNumElements; i++) {
                pTracer = (CClassMapInfo *) m_aCache[i];

                // We've got a problem -- we cannot add this class
                if (pClsMap->m_dwObjectId == pTracer->m_dwObjectId )
                {
                    if (m_PerfObject.CheckClassExist(pTracer->m_pszClassName, pTracer->m_pClassDef)) {
                        ReleaseMutex(m_hClassMapMutex);
                        return FALSE;
                    }
                    else {
                        m_PerfObject.RemoveClass(pTracer->m_pClassDef);
                        m_aCache.RemoveAt(i);
                        delete pTracer;

                        nNumElements = m_aCache.Size();
                        break;
                    }
                }
            }

            for (i = 0; i < nNumElements; i++) {
                pTracer = (CClassMapInfo *) m_aCache[i];
                if (_wcsicmp(pClsMap->m_pszClassName, pTracer->m_pszClassName) < 0) {
                    if( CFlexArray::no_error == m_aCache.InsertAt(i, pClsMap) ){
                        bInCache = TRUE;
                    }
                    break;
                }
            }
    
            if (i == nNumElements) {
                // If here, add it to the end.
                // ===========================
                if( CFlexArray::no_error == m_aCache.Add(pClsMap) ){
                    bInCache = TRUE;
                }
            }

            // make sure the library is in the list
            if( bInCache ){
                dwResult = m_PerfObject.AddClass (pClsMap->m_pClassDef, TRUE);
                if( ERROR_SUCCESS != dwResult ){
                    m_aCache.Remove( pClsMap );
                }
            }else{
                dwResult = ERROR_INVALID_BLOCK;
            }
            
            ReleaseMutex(m_hClassMapMutex);
        } else {
            dwResult = ERROR_LOCK_FAILED;
        }
    }
    
    return (dwResult == ERROR_SUCCESS);
}    

//***************************************************************************
//
//  CNt5PerfProvider::FindClassMap
//
//***************************************************************************
// ok
CClassMapInfo *CNt5PerfProvider::FindClassMap(
    LPWSTR pszClassName
    )
{
    int             l = 0;
    int             u;
    int             m;
    CClassMapInfo   *pClsMap;
    CClassMapInfo   *pClsMapReturn = NULL;

    // Binary search the cache.
    // ========================
    if( NULL == pszClassName ){
        return NULL;
    }

    if (m_hClassMapMutex != 0) {
        if (WAIT_OBJECT_0 == WaitForSingleObject(m_hClassMapMutex, cdwClassMapTimeout)) {

            u = m_aCache.Size() - 1;
            __try{
                while (l <= u) {
                    m = (l + u) / 2;

                    pClsMap = (CClassMapInfo *) m_aCache[m];

                    if (pClsMap != NULL) {
                        if (_wcsicmp(pszClassName, pClsMap->m_pszClassName) < 0) {
                            u = m - 1;
                        } else if (_wcsicmp(pszClassName, pClsMap->m_pszClassName) > 0) {
                            l = m + 1;
                        } else {   // Hit!
                            pClsMapReturn = pClsMap;
                            break;
                        }
                    } else {
                        break;
                    }
                }
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                pClsMapReturn = NULL;
            }
            
            ReleaseMutex(m_hClassMapMutex);
        }
    }
    return pClsMapReturn;
}

//***************************************************************************
//
//  CNt5PerfProvider::MapClass
//
//  Retrieves the requested class and places it in the cache.
//  
//  Parameters:
//      pNs         The namespace which contains the class definition.
//      wsClass     The class name.
//      pCtx        The inbound context object.  Only used for reentrant
//                  calls.
//
//***************************************************************************
// ok
BOOL CNt5PerfProvider::MapClass(
    IN IWbemServices *pNs,
    IN WCHAR *wszClass,
    IN IWbemContext *pCtx    
    )
{
    HRESULT             hRes = 0;
    BOOL                bReturn = FALSE; 
    IWbemClassObject    *pClsDef = 0;
    IWbemQualifierSet   *pQSet = 0;
    VARIANT             v;
    CClassMapInfo       *pMapInfo = 0;
    CBSTR               cbClass(wszClass);
    CBSTR               cbProvider(cszProvider);

    if( NULL == (BSTR)cbClass ||
        NULL == (BSTR)cbProvider ){
        return FALSE;
    }

    if (m_hClassMapMutex != 0) {
        if (WAIT_OBJECT_0 == WaitForSingleObject(m_hClassMapMutex, cdwClassMapTimeout)) {
            // See if the class is already in the cache.
            // =========================================
            if (FindClassMap(wszClass) != 0) {
                // already loaded so quit now
                bReturn = TRUE;
            } else {
                // Get the class definition from CIMOM.
                // ====================================
                hRes = pNs->GetObject( cbClass, 0, pCtx, &pClsDef, 0);
                if (hRes == NO_ERROR) {
                    // Verify the class is one of ours by checking
                    // the "provider" qualifier to ensure it matches
                    // the name that we we have for this component.
                    // =============================================
                    hRes = pClsDef->GetQualifierSet(&pQSet);
                    if (hRes == NO_ERROR) {
                        VariantInit(&v);
                        hRes = pQSet->Get( cbProvider, 0, &v, 0);
                        pQSet->Release();
                        
                        if ((hRes == NO_ERROR) && (v.vt == VT_BSTR)) {
                            if (_wcsicmp(V_BSTR(&v), cszProviderName) == 0) {
                                // Get the property handles and mappings to the perf counter ids
                                // by calling the Map() method of CClassMapInfo.
                                // ==============================================================
                                pMapInfo = new CClassMapInfo;
                                if (pMapInfo != NULL) {
                                    if (pMapInfo->Map(pClsDef)) {
                                        // Add it to the cache.
                                        // ====================
                                        bReturn = AddClassMap(pMapInfo);
                                        if( !bReturn ){
                                            delete pMapInfo;
                                        }
                                    } else {
                                        // unable to add this to the cache
                                        delete pMapInfo;
                                        pMapInfo = NULL;
                                    }
                                } else {
                                    // inable to create new class
                                    bReturn = FALSE;
                                }
                            }
                        } else {
                            SetLastError ((DWORD)WBEM_E_INVALID_PROVIDER_REGISTRATION);
                        }
                        VariantClear(&v);
                    }

                }
                if( pMapInfo == NULL && pClsDef != NULL ){
                    pClsDef->Release();                    
                }
            } 
            ReleaseMutex(m_hClassMapMutex);
        }
    }
    return bReturn;
}    

//***************************************************************************
//
//  CNt5PerfProvider::HasPermission
//
//  tests to see if the caller has permission to access the functions
//  
//  Parameters:
//      void        N/A
//
//***************************************************************************
// ok
BOOL CNt5PerfProvider::HasPermission (void)
{
    DWORD   dwStatus;
    HKEY    hKeyTest;
    BOOL    bReturn;

    dwStatus = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,
        (LPCWSTR)L"Software\\Microsoft\\Windows NT\\CurrentVersion\\WbemPerf",
        0, KEY_READ, &hKeyTest);

    if ((dwStatus == ERROR_SUCCESS) || (dwStatus == ERROR_FILE_NOT_FOUND)) {
        bReturn = TRUE;
        if (dwStatus == ERROR_SUCCESS) RegCloseKey (hKeyTest);
    } else  {
        bReturn = FALSE;
    }

    return bReturn;
}

//***************************************************************************
//
//  CNt5PerfProvider::CheckImpersonationLevel
//
//  tests caller's security impersonation level for correct access
//  
//  Only call here if CoImpersonate worked.
//
//  Parameters:
//      void        N/A
//
//***************************************************************************
// ok
HRESULT CNt5PerfProvider::CheckImpersonationLevel (void)
{
    HRESULT hr = WBEM_E_ACCESS_DENIED;
    BOOL    bReturn;

    // Now, let's check the impersonation level.  First, get the thread token
    HANDLE hThreadTok;
    DWORD dwImp, dwBytesReturned;

    bReturn = OpenThreadToken(
        GetCurrentThread(),
        TOKEN_QUERY,
        TRUE,
        &hThreadTok);

    if (!bReturn) {

        // If the CoImpersonate works, but the OpenThreadToken fails, we are running under the
        // process token (either local system, or if we are running with /exe, the rights of
        // the logged in user).  In either case, impersonation rights don't apply.  We have the
        // full rights of that user.

        hr = WBEM_S_NO_ERROR;

    } else {
        // We really do have a thread token, so let's retrieve its level

        bReturn = GetTokenInformation(
            hThreadTok,
            TokenImpersonationLevel,
            &dwImp,
            sizeof(DWORD),
            &dwBytesReturned);

        if (bReturn) {
            // Is the impersonation level Impersonate?
            if ((dwImp == SecurityImpersonation) || (dwImp == SecurityDelegation)) {
                hr = WBEM_S_NO_ERROR;
            } else {
                hr = WBEM_E_ACCESS_DENIED;
            }
        } else {
            hr = WBEM_E_FAILED;
        }

        // Done with this handle
        CloseHandle(hThreadTok);
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\perfacc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PerfAcc.h

Abstract:

    Windows NT Perf Object Access Class Definition

--*/

#ifndef _NT_PERF_OBJECT_ACCESS_H
#define _NT_PERF_OBJECT_ACCESS_H

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <wbemidl.h>
#include <assert.h>
#include "flexarry.h"
#include "utils.h"

#if (DBG && _OUTPUT_DEBUG_STRINGS)
#define DebugPrint(x)   OutputDebugString (x)
#else
#define DebugPrint(x)
#endif

//
//      constants used by guard page testing
//
#define GUARD_PAGE_SIZE 1024
#define GUARD_PAGE_CHAR 0xA5
#define GUARD_PAGE_DWORD 0xA5A5A5A5

#define  LOG_UNDEFINED  ((LONG)-1)
#define  LOG_NONE       0
#define  LOG_USER       1
#define  LOG_DEBUG      2
#define  LOG_VERBOSE    3

#define     EXT_TEST_UNDEFINED  0
#define     EXT_TEST_ALL        1
#define     EXT_TEST_BASIC      2
#define     EXT_TEST_NONE       3
#define     EXT_TEST_NOMEMALLOC 4

__inline
LONGLONG
GetTimeAsLongLong ()
/*++
    Returns time performance timer converted to ms.

-*/
{
    LARGE_INTEGER liCount, liFreq;
    LONGLONG        llReturn;

    if (QueryPerformanceCounter (&liCount) && 
        QueryPerformanceFrequency (&liFreq)) {
        llReturn = liCount.QuadPart * 1000 / liFreq.QuadPart;
    } else {
        llReturn = 0;
    }
    return llReturn;
}

//
//  Definition of handle table for extensible objects
//
typedef PM_OPEN_PROC    *OPENPROC;
typedef PM_COLLECT_PROC *COLLECTPROC;
typedef PM_QUERY_PROC   *QUERYPROC;
typedef PM_CLOSE_PROC   *CLOSEPROC;

#define EXT_OBJ_INFO_NAME_LENGTH    32

typedef struct _ExtObject {
        LPVOID      pNext;   // not used
        HANDLE      hMutex;         // sync mutex for this function
        OPENPROC    OpenProc;       // address of the open routine
        LPSTR       szOpenProcName; // open procedure name
        LPWSTR      szLinkageString; // param for open proc
        DWORD       dwOpenTimeout;  // wait time in MS for open proc
        COLLECTPROC CollectProc;    // address of the collect routine
        QUERYPROC   QueryProc;      // address of query proc
        LPSTR       szCollectProcName;  // collect procedure name
        DWORD       dwCollectTimeout;   // wait time in MS for collect proc
        CLOSEPROC   CloseProc;     // address of the close routine
        LPSTR       szCloseProcName;    // close procedure name
        HMODULE     hLibrary ;     // handle returned by LoadLibraryW
        LPWSTR      szLibraryName;  // full path of library
        HKEY        hPerfKey;       // handle to performance sub key fo this service
        DWORD       dwNumObjects;  // number of supported objects
        DWORD       dwObjList[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];    // address of array of supported objects
        DWORD       dwFlags;        // flags
        LPWSTR      szServiceName;  // service name
        LONGLONG    llLastUsedTime; // FILETIME of last access
// Performance statistics
        LONGLONG    llElapsedTime;  // time spent in call
        DWORD       dwCollectCount; // number of times Collect successfully called
        DWORD       dwOpenCount;    // number of Loads & opens
        DWORD       dwCloseCount;   // number of Unloads & closes
        DWORD       dwLockoutCount; // count of lock timeouts
        DWORD       dwErrorCount;   // count of errors (other than timeouts)
        DWORD       dwOpenFail;
        DWORD       ADThreadId;     // thread recieving Access Denied
        DWORD       dwFirstCounter;
        DWORD       dwLastCounter;
} ExtObject, *pExtObject;

const DWORD dwExtCtrOpenProcWaitMs = 10000;

// ext object flags
#define PERF_EO_QUERY_FUNC  ((DWORD)0x00000001)     // use query proc
#define PERF_EO_BAD_DLL     ((DWORD)0x00000002)     // true when DLL ret. error
#define PERF_EO_KEEP_RESIDENT ((DWORD)0x00000004)    // true if lib should not be trimmed
#define PERF_EO_OBJ_IN_QUERY ((DWORD)0x80000000)    // true when in query list

#ifdef __cplusplus

class CPerfDataLibrary {
public:
    pExtObject  pLibInfo;
    WCHAR       szQueryString[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION * 10]; // string of objects to query
    DWORD       dwRefCount;     // number of classes referencing this object

    CPerfDataLibrary (void);
    ~CPerfDataLibrary (void);
};

class CPerfObjectAccess {
private:
    HANDLE  m_hObjectHeap;
    // list of libraries referenced
    CFlexArray  m_aLibraries;
    LONG    lEventLogLevel;
    HANDLE  hEventLog;

    DWORD   AddLibrary  (IWbemClassObject *pClass, 
                        IWbemQualifierSet *pClassQualifiers,
                        LPCWSTR szRegistryKey,
                        DWORD   dwPerfIndex);
    DWORD   OpenExtObjectLibrary (pExtObject  pObj);

    DWORD CloseLibrary (CPerfDataLibrary *pLib);

public:
    CPerfObjectAccess (void);
    ~CPerfObjectAccess (void);

    DWORD   AddClass (IWbemClassObject *pClass, BOOL bCatalogQuery);
    DWORD   CollectData(LPBYTE pBuffer, LPDWORD pdwBufferSize, LPWSTR pszItemList=NULL);
    DWORD   RemoveClass(IWbemClassObject *pClass);
    BOOL    CheckClassExist(LPWSTR wszClassName, IWbemClassObject * pClass);
};

#endif // _cplusplus

#endif // _NT_PERF_OBJECT_ACCESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\oahelp.inl ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    oahelp.inl

Abstract:

    OLE Automation Helpers for client code

--*/

#ifndef _OAHELP_INL_
#define _OAHELP_INL_

#pragma warning (disable : 4310)	// typecasting in the following causes a warning
class CBSTR
{
    BSTR m_pStr;
public:
    CBSTR() { m_pStr = 0; }
    CBSTR(LPWSTR pSrc) { m_pStr = SysAllocString(pSrc); }
    CBSTR(LPCWSTR pSrc) { m_pStr = SysAllocString((LPWSTR)pSrc); }
   ~CBSTR() { if (m_pStr) SysFreeString(m_pStr); }
    operator BSTR() { return m_pStr; }

    void Unbind() { m_pStr = 0; }
};

class CVARIANT
{
    VARIANT v;
public:
    CVARIANT() { VariantInit(&v); }
   ~CVARIANT() { VariantClear(&v); }
    void Clear()  { VariantClear(&v); }

    operator VARIANT *() { return &v; }
    VARIANT *operator &() { return &v; }

    CVARIANT(LPWSTR pSrc)   { VariantInit(&v); SetStr(pSrc); }
    CVARIANT(LONG lSrc)     { VariantInit(&v); SetLONG(lSrc); }
    CVARIANT(BOOL b)        { VariantInit(&v); SetBool(b); }
    CVARIANT(short i)       { VariantInit(&v); SetShort(i); }
    CVARIANT(double d)      { VariantInit(&v); SetDouble(d); }
    CVARIANT(BYTE b)        { VariantInit(&v); SetByte(b); }
    CVARIANT(IDispatch * pDisp) { VariantInit(&v); pDisp->AddRef(); SetDispatch(pDisp); }

    void   SetStr(LPWSTR pSrc)
    { Clear(); V_VT(&v) = (WORD)(pSrc != NULL ? VT_BSTR : VT_NULL); 
      V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
    }

    LPWSTR GetStr() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }
    operator LPWSTR() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }

    void SetLONG(LONG lSrc) { Clear(); V_VT(&v) = VT_I4; V_I4(&v) = lSrc; }
    LONG GetLONG() { return V_I4(&v); }
    operator LONG() { return V_I4(&v);  }

    void SetDouble(double dSrc) { Clear(); V_VT(&v) = VT_R8; V_R8(&v) = dSrc; }
    double GetDouble() { return V_R8(&v); }
    operator double() { return V_R8(&v);  }

    void SetByte(BYTE bySrc) { Clear(); V_VT(&v) = VT_UI1; V_UI1(&v) = bySrc; }
    BYTE GetByte() { return V_UI1(&v); }
    operator BYTE() { return V_UI1(&v);  }

    void SetBool(BOOL b) { V_VT(&v) = VT_BOOL; V_BOOL(&v) = (VARIANT_BOOL)(b ? VARIANT_TRUE : VARIANT_FALSE); }
    BOOL GetBool() { return (BOOL)(V_BOOL(&v) == VARIANT_TRUE); }
    operator BOOL() { return V_BOOL(&v); }

    void SetDispatch(IDispatch* pDisp) { V_VT(&v) = VT_DISPATCH; V_DISPATCH(&v) = pDisp; }
    IDispatch * GetDispatch() { return V_DISPATCH(&v); }

    void SetUnknown(IUnknown* pUnk) { V_VT(&v) = VT_UNKNOWN; V_UNKNOWN(&v) = pUnk; }
    IUnknown * GetUnknown() { return V_UNKNOWN(&v); }

    void SetShort(short i) { V_VT(&v) = VT_I2; V_I2(&v) = i; }
    short GetShort() { return V_I2(&v); }
    operator short() { return V_I2(&v); }

    VARTYPE GetType() { return V_VT(&v); }

    void SetArray(SAFEARRAY *p, VARTYPE vt) { Clear(); V_VT(&v) = vt; V_ARRAY(&v) = p; }
        // This function acquires the SAFEARRAY pointer and it is no longer owned
        // by the caller.

    operator SAFEARRAY *() { return (V_VT(&v) & VT_ARRAY ? V_ARRAY(&v) : 0); }

    void Unbind() { VariantInit(&v); }
};

class CSAFEARRAY
{
    SAFEARRAY *p;
public:
    CSAFEARRAY(VARTYPE v, int nSize) 
    {
        SAFEARRAYBOUND rgsabound[1];
    	rgsabound[0].lLbound = 0;
    	rgsabound[0].cElements = nSize;
        p = SafeArrayCreate(v, 1, rgsabound);
    }
    
    ~CSAFEARRAY() { if (p) SafeArrayDestroy(p); }
    CSAFEARRAY(SAFEARRAY *pSrc) { p = pSrc; }

    HRESULT Put(long nLocation, LPVOID pData) {
        return SafeArrayPutElement(p, &nLocation, pData);                
    }

    HRESULT Get(long nLocation, LPVOID pData) { 
        return SafeArrayGetElement(p, &nLocation, pData);                
    }

    HRESULT Access(void **pData) { return SafeArrayAccessData(p, pData); }
    HRESULT Unaccess() { return SafeArrayUnaccessData(p); }

    operator SAFEARRAY *() { return p; }
    long GetNumElements() { long upper; SafeArrayGetUBound(p, 1, &upper); return upper + 1; }

    void Unbind() { p = 0; }
};
#pragma warning (default : 4310)	// restore


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\ntperf.h ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    ntperf.h

Abstract:

    NT5 Perf counter provider

    <abstract>

--*/

#ifndef _NTPERF_H_
#define _NTPERF_H_

#include "flexarry.h"
#include "classmap.h"
#include "perfacc.h"

const DWORD cdwClassMapTimeout = 10000;

//***************************************************************************
//
//  class CNt5PerfProvider
//
//***************************************************************************

class CNt5PerfProvider : public IWbemHiPerfProvider, public IWbemProviderInit
{
    friend class CNt5Refresher;

public:
    typedef enum {
        CLSID_SERVER,
        CLSID_CLIENT
    } enumCLSID;

private:
    LONG                m_lRef;
    enumCLSID           m_OriginClsid;
    CFlexArray          m_aCache;       // Array of CClassMapInfo pointers
	CPerfObjectAccess	m_PerfObject;	// class to interface

    HANDLE				m_hClassMapMutex;	// Lock the provider's Class Map Cache

protected:
    BOOL AddClassMap(CClassMapInfo *pCls);
    CClassMapInfo *FindClassMap(LPWSTR pszClassName);

    BOOL MapClass(
        IWbemServices *pNs,
        WCHAR *wszClass,
        IWbemContext *pCtx    
        );

public:
    static BOOL HasPermission (void);
    static HRESULT CheckImpersonationLevel (void);
    
    CNt5PerfProvider(enumCLSID OriginClsid);
   ~CNt5PerfProvider();

    // Interface members.
    // ==================

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);

	// helper functions
	HRESULT CNt5PerfProvider::CreateRefresherObject( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
		/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pContext,
		/* [string][in] */ LPCWSTR wszClass,
		/* [in] */ IWbemHiPerfEnum __RPC_FAR *pHiPerfEnum,
		/* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
		/* [out] */ long __RPC_FAR *plId
		);


    // IWbemHiPerfProvider methods.
    // ============================
        
    virtual HRESULT STDMETHODCALLTYPE QueryInstances( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [string][in] */ WCHAR __RPC_FAR *wszClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink
        );
    
    virtual HRESULT STDMETHODCALLTYPE CreateRefresher( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [in] */ long lFlags,
        /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
        );
    
    virtual HRESULT STDMETHODCALLTYPE CreateRefreshableObject( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
        /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pContext,
        /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
        /* [out] */ long __RPC_FAR *plId
        );
    
    virtual HRESULT STDMETHODCALLTYPE StopRefreshing( 
        /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
        /* [in] */ long lId,
        /* [in] */ long lFlags
        );

    virtual HRESULT STDMETHODCALLTYPE CreateRefreshableEnum( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [string][in] */ LPCWSTR wszClass,
        /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pContext,
        /* [in] */ IWbemHiPerfEnum __RPC_FAR *pHiPerfEnum,
        /* [out] */ long __RPC_FAR *plId);
    
    virtual HRESULT STDMETHODCALLTYPE GetObjects( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [in] */ long lNumObjects,
        /* [size_is][in] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pContext);
    

    // IWbemProviderInit method.
    // =========================
        
    virtual HRESULT STDMETHODCALLTYPE Initialize( 
        /* [unique][in] */ LPWSTR wszUser,
        /* [in] */ LONG lFlags,
        /* [in] */ LPWSTR wszNamespace,
        /* [unique][in] */ LPWSTR wszLocale,
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
        );
        
};

// defined in server.cpp
extern void ObjectCreated();
extern void ObjectDestroyed();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\perfhelp.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    perfhelp.cpp

Abstract:

    Registry-based performance counter reading helper

--*/

#include "wpheader.h"
#include <stdio.h>

BOOL PerfHelper::IsMatchingInstance (
    PERF_INSTANCE_DEFINITION    *pInstanceDef,
    DWORD                       dwCodePage,
    LPWSTR                      szInstanceNameToMatch,
    DWORD                       dwInstanceNameLength
)
// compares pInstanceName to the name in the instance
{
    DWORD   dwThisInstanceNameLength;
    LPWSTR  szThisInstanceName;
    size_t  cchBufferSize = PDH_MAX_INSTANCE_NAME;
    WCHAR   szBufferForANSINames[PDH_MAX_INSTANCE_NAME];
    BOOL    bReturn = FALSE;

    if (dwInstanceNameLength == 0) {
        // get the length to compare
        dwInstanceNameLength = lstrlenW (szInstanceNameToMatch);
    }

    if (dwCodePage == 0) {
        // try to take a shortcut here if it's a unicode string
        // compare to the length of the shortest string
        // get the pointer to this string
        szThisInstanceName = GetInstanceName(pInstanceDef);

        // convert instance Name from bytes to chars
        dwThisInstanceNameLength = pInstanceDef->NameLength / sizeof(WCHAR);

        // see if this length includes the term. null. If so shorten it
        if (szThisInstanceName[dwThisInstanceNameLength-1] == 0) {
            dwThisInstanceNameLength--;
        }
    } else {
        // go the long way and read/translate/convert the string
        dwThisInstanceNameLength =GetInstanceNameStr (pInstanceDef,
                    szBufferForANSINames,
                    cchBufferSize,
                    dwCodePage);
        if (dwThisInstanceNameLength > 0) {
            szThisInstanceName = &szBufferForANSINames[0];
        } else {
            szThisInstanceName = (LPWSTR)cszSpace;
        }
    }

    // if the lengths are not equal then the names can't be either
    if (dwInstanceNameLength == dwThisInstanceNameLength) {
        if (lstrcmpiW(szInstanceNameToMatch, szThisInstanceName) == 0) {
            // this is a match
            bReturn = TRUE;
        } else {
            // this is not a match
        }
    }
    return bReturn;
}

BOOL PerfHelper::ParseInstanceName (
    IN      LPCWSTR szInstanceString,
    IN      LPWSTR  szInstanceName,
    IN      size_t  cchInstanceName,
    IN      LPWSTR  szParentName,
    IN      size_t  cchParentName,
    IN      LPDWORD lpIndex
)
/*
    parses the instance name formatted as follows

        [parent/]instance[#index]

    parent is optional and if present, is delimited by a forward slash
    index is optional and if present, is delimited by a colon

    parent and instance may be any legal file name character except a
    delimeter character "/#\()" Index must be a string composed of
    decimal digit characters (0-9), less than 10 characters in length, and
    equate to a value between 0 and 2**32-1 (inclusive).

    This function assumes that the instance name and parent name buffers
    are of sufficient size.

    NOTE: szInstanceName and szInstanceString can be the same buffer

*/
{
    LPWSTR  szSrcChar, szDestChar;
    BOOL    bReturn = FALSE;
    WCHAR   szIndexBuffer[WBEMPERF_STRING_SIZE];    // just to be safe
    DWORD   dwIndex = 0;
    size_t  cchSize = 0;
    
    szDestChar = (LPWSTR)szInstanceName;
    szSrcChar = (LPWSTR)szInstanceString;

    __try {
        do {
            *szDestChar++ = *szSrcChar++;
            cchSize++;
        } while ((*szSrcChar != 0) &&
                 (*szSrcChar != wcSlash) &&
                 (*szSrcChar != wcPoundSign) && 
                 cchSize < cchInstanceName );
        // see if that was really the parent or not
        if (*szSrcChar == wcSlash) {
            // terminate destination after test in case they are the same buffer
            *szDestChar = 0;
            szSrcChar++;    // and move source pointer past delimter
            // it was the parent name so copy it to the parent
            StringCchCopyW (szParentName, cchParentName, szInstanceName);
            // and copy the rest of the string after the "/" to the
            //  instance name field
            cchSize = 0;
            szDestChar = szInstanceName;
            do {
                *szDestChar++ = *szSrcChar++;
                cchSize++;
            } while ((*szSrcChar != 0) &&
                    (*szSrcChar != wcPoundSign) && 
                    cchSize < cchInstanceName );
        } else {
            // that was the only element so load an empty string for the parent
            *szParentName = 0;
        }
        // *szSrcChar will either be pointing to the end of the input string
        // in which case the "0" index is assumed or it will be pointing
        // to the # delimiting the index argument in the string.
        if (*szSrcChar == wcPoundSign) {
            *szDestChar = 0;    // terminate the destination string
            szSrcChar++;    // move past delimter
            szDestChar = &szIndexBuffer[0];
            StringCchCopyW( szDestChar, WBEMPERF_STRING_SIZE, szSrcChar );
            dwIndex = wcstoul (szIndexBuffer, NULL, 10);
        } else {
            *szDestChar = 0;    // terminate the destination string
            dwIndex = 0;
        }
        *lpIndex = dwIndex;
        bReturn = TRUE;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        // unable to move strings
        bReturn = FALSE;
    }
    return bReturn;
}

#pragma warning ( disable : 4127)   // while (TRUE) error
PERF_OBJECT_TYPE *
PerfHelper::GetObjectDefByTitleIndex(
    IN  PERF_DATA_BLOCK *pDataBlock,
    IN  DWORD ObjectTypeTitleIndex
)
{
    DWORD NumTypeDef;

    PERF_OBJECT_TYPE *pObjectDef = NULL;
    PERF_OBJECT_TYPE *pReturnObject = NULL;
    PERF_OBJECT_TYPE *pEndOfBuffer = NULL;

    __try {
        pObjectDef = FirstObject(pDataBlock);
        pEndOfBuffer = (PPERF_OBJECT_TYPE)
                        ((DWORD_PTR)pDataBlock +
                            pDataBlock->TotalByteLength);

        if (pObjectDef != NULL) {
            NumTypeDef = 0;
            while (1) {
                if ( pObjectDef->ObjectNameTitleIndex == ObjectTypeTitleIndex ) {
                    pReturnObject = pObjectDef;
                    break;
                } else {
                    NumTypeDef++;
                    if (NumTypeDef < pDataBlock->NumObjectTypes) {
                        pObjectDef = NextObject(pObjectDef);
                        //make sure next object is legit
                        if (pObjectDef >= pEndOfBuffer) {
                            // looks like we ran off the end of the data buffer
                            assert (pObjectDef < pEndOfBuffer);
                            break;
                        } else {
                            if (pObjectDef != NULL) {
                                if (pObjectDef->TotalByteLength == 0) {
                                    // 0-length object buffer returned
                                    assert (pObjectDef->TotalByteLength > 0);
                                    break;
                                }
                            } else {
                                // and continue
                                assert (pObjectDef != NULL);
                                break;
                            }
                        }
                    } else {
                        // no more data objects in this data block
                        break;
                    }
                }
            }
        } // else no object found
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pReturnObject = NULL;
    }
    return pReturnObject;
}
#pragma warning ( default : 4127)   // while (TRUE) error

#pragma warning ( disable : 4127)   // while (TRUE) error
PERF_OBJECT_TYPE *
PerfHelper::GetObjectDefByName (
    IN      PERF_DATA_BLOCK *pDataBlock,
    IN      DWORD           dwLastNameIndex,
    IN      LPCWSTR         *NameArray,
    IN      LPCWSTR         szObjectName
)
{
    DWORD NumTypeDef;
    PERF_OBJECT_TYPE *pReturnObject = NULL;
    PERF_OBJECT_TYPE *pObjectDef = NULL;
    PERF_OBJECT_TYPE *pEndOfBuffer = NULL;

    __try {

        pObjectDef = FirstObject(pDataBlock);
        pEndOfBuffer = (PPERF_OBJECT_TYPE)
                        ((DWORD_PTR)pDataBlock +
                            pDataBlock->TotalByteLength);

        if (pObjectDef != NULL) {

            NumTypeDef = 0;
            while (1) {
                if ( pObjectDef->ObjectNameTitleIndex < dwLastNameIndex ) {
                    // look up name of object & compare
                    if (lstrcmpiW(NameArray[pObjectDef->ObjectNameTitleIndex],
                            szObjectName) == 0) {
                        pReturnObject = pObjectDef;
                        break;
                    }
                }
                NumTypeDef++;
                if (NumTypeDef < pDataBlock->NumObjectTypes) {
                    pObjectDef = NextObject(pObjectDef); // get next
                    //make sure next object is legit
                    if (pObjectDef != NULL) {
                        if (pObjectDef->TotalByteLength > 0) {
                            if (pObjectDef >= pEndOfBuffer) {
                                // looks like we ran off the end of the data buffer
                                assert (pObjectDef < pEndOfBuffer);
                                break;
                            }
                        } else {
                            // 0-length object buffer returned
                            assert (pObjectDef->TotalByteLength > 0);
                            break;
                        }
                    } else {
                        // null pointer
                        assert (pObjectDef != NULL);
                        break;
                    }
                } else {
                    // end of data block
                    break;
                }
            }
        } // else no object found
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pReturnObject = NULL;
    }
    return pReturnObject;
}
#pragma warning ( default : 4127)   // while (TRUE) error

PERF_INSTANCE_DEFINITION *
PerfHelper::GetInstance(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceNumber
)
{

    PERF_INSTANCE_DEFINITION *pInstanceDef;
    PERF_INSTANCE_DEFINITION *pReturnDef = NULL;
    PERF_INSTANCE_DEFINITION *pEndOfBuffer = NULL;
    LONG NumInstance;


    if (pObjectDef != NULL) {
        pInstanceDef = FirstInstance(pObjectDef);
        if (pInstanceDef != NULL) {
            pEndOfBuffer = (PERF_INSTANCE_DEFINITION *)EndOfObject(pObjectDef);

            for ( NumInstance = 0;
                NumInstance < pObjectDef->NumInstances;
                NumInstance++ )  {
                if ( InstanceNumber == NumInstance ) {
                    pReturnDef = pInstanceDef;                    
                }
                pInstanceDef = NextInstance(pInstanceDef);
                // go to next instance in object and check for buffer overrun
                if (pInstanceDef >= pEndOfBuffer) {
                    // something doesn't add up so bail out and return NULL
                    break;
                }
            }
        }
    }

    return pReturnDef;
}

PERF_INSTANCE_DEFINITION *
PerfHelper::GetInstanceByUniqueId(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceUniqueId
)
{
    PERF_INSTANCE_DEFINITION *pInstanceDef;
    PERF_INSTANCE_DEFINITION *pReturnDef = NULL;
    PERF_INSTANCE_DEFINITION *pEndOfBuffer = NULL;
    LONG NumInstance;

    if (pObjectDef != NULL) {
        pInstanceDef = FirstInstance(pObjectDef);
        if (pInstanceDef != NULL) {
            pEndOfBuffer = (PERF_INSTANCE_DEFINITION *)EndOfObject(pObjectDef);

            for ( NumInstance = 0;
                NumInstance < pObjectDef->NumInstances;
                NumInstance++ )  {
                if ( InstanceUniqueId == pInstanceDef->UniqueID ) {
                    pReturnDef = pInstanceDef;
                }
                pInstanceDef = NextInstance(pInstanceDef);
                // go to next instance in object and check for buffer overrun
                if (pInstanceDef >= pEndOfBuffer) {
                    // something doesn't add up so bail out and return NULL
                    break;
                }
            }
        }
    }
    return pReturnDef;
}

DWORD
PerfHelper::GetAnsiInstanceName (PPERF_INSTANCE_DEFINITION pInstance,
                    LPWSTR lpszInstance,
                    size_t cchBufferSize,
                    DWORD dwCodePage)
{
    LPSTR   szSource;
    DWORD_PTR   dwLength;

    UNREFERENCED_PARAMETER(dwCodePage);

    szSource = (LPSTR)GetInstanceName(pInstance);

    // the locale should be set here

    // pInstance->NameLength == the number of bytes (chars) in the string
    dwLength = mbstowcs (lpszInstance, szSource, cchBufferSize );
    if( dwLength < cchBufferSize ){
        lpszInstance[dwLength] = 0; // null terminate string buffer
    }

    return (DWORD)dwLength;
}

DWORD
PerfHelper::GetUnicodeInstanceName (PPERF_INSTANCE_DEFINITION pInstance,
                    LPWSTR lpszInstance, size_t cchBufferSize )
{
   LPWSTR   wszSource;
   DWORD    dwLength;

   wszSource = GetInstanceName(pInstance) ;

   // pInstance->NameLength == length of string in BYTES so adjust to
   // number of wide characters here
   dwLength = pInstance->NameLength / sizeof(WCHAR);

   StringCchCopyW (lpszInstance, cchBufferSize, (LPWSTR)wszSource);

   // add null termination if string length does not include  the null
   if ((dwLength > 0) && (lpszInstance[dwLength-1] != 0)) {    // i.e. it's the last character of the string
           lpszInstance[dwLength] = 0;    // then add a terminating null char to the string
   } else {
           // assume that the length value includes the terminating NULL
        // so adjust value to indicate chars only
           dwLength--;
   }

   return (dwLength); // just incase there's null's in the string
}

DWORD
PerfHelper::GetInstanceNameStr (PPERF_INSTANCE_DEFINITION pInstance,
                    LPWSTR lpszInstance,
                    size_t cchBufferSize,
                    DWORD dwCodePage)
{
    DWORD  dwCharSize;
    DWORD  dwLength = 0;

    if (pInstance != NULL) {
        if (lpszInstance != NULL) {
            if (dwCodePage > 0) {
                    dwCharSize = sizeof(CHAR);
                    dwLength = GetAnsiInstanceName (pInstance, lpszInstance, cchBufferSize, dwCodePage);
            } else { // it's a UNICODE name
                    dwCharSize = sizeof(WCHAR);
                    dwLength = GetUnicodeInstanceName (pInstance, lpszInstance, cchBufferSize);
            }
            // sanity check here...
            // the returned string length (in characters) plus the terminating NULL
            // should be the same as the specified length in bytes divided by the
            // character size. If not then the codepage and instance data type
            // don't line up so test that here

            if ((dwLength + 1) != (pInstance->NameLength / dwCharSize)) {
                // something isn't quite right so try the "other" type of string type
                if (dwCharSize == sizeof(CHAR)) {
                    // then we tried to read it as an ASCII string and that didn't work
                    // so try it as a UNICODE (if that doesn't work give up and return
                    // it any way.
                    dwLength = GetUnicodeInstanceName (pInstance, lpszInstance, cchBufferSize );
                } else if (dwCharSize == sizeof(WCHAR)) {
                    // then we tried to read it as a UNICODE string and that didn't work
                    // so try it as an ASCII string (if that doesn't work give up and return
                    // it any way.
                    dwLength = GetAnsiInstanceName (pInstance, lpszInstance, cchBufferSize, dwCodePage);
                }
            }
        } // else return buffer is null
    } else {
        // no instance def object is specified so return an empty string
        *lpszInstance = 0;
    }

    return dwLength;
}

PERF_INSTANCE_DEFINITION *
PerfHelper::GetInstanceByNameUsingParentTitleIndex(
    PERF_DATA_BLOCK *pDataBlock,
    PERF_OBJECT_TYPE *pObjectDef,
    LPWSTR pInstanceName,
    LPWSTR pParentName,
    DWORD  dwIndex
)
{
   PERF_OBJECT_TYPE *pParentObj;

   PERF_INSTANCE_DEFINITION  *pParentInst;
   PERF_INSTANCE_DEFINITION  *pInstanceDef;
   PERF_INSTANCE_DEFINITION  *pReturnDef = NULL;

   LONG     NumInstance;
   DWORD    dwLocalIndex;
   DWORD    dwInstanceNameLength;

   pInstanceDef = FirstInstance(pObjectDef);
   assert (pInstanceDef != NULL);
   dwLocalIndex = dwIndex;

    dwInstanceNameLength = lstrlenW(pInstanceName);

    for ( NumInstance = 0;
      NumInstance < pObjectDef->NumInstances;
      NumInstance++ ) {

        if (IsMatchingInstance (pInstanceDef, pObjectDef->CodePage,
             pInstanceName, dwInstanceNameLength )) {
            // this is the correct instance, so see if we need to find a parent instance
            if ( pParentName == NULL ) {
               // No parent, we're done if this is the right "copy"
                if (dwLocalIndex == 0) {
                    pReturnDef = pInstanceDef;
                    break;
                } else {
                    --dwLocalIndex;
                }
            } else {
                // Must match parent as well

                pParentObj = GetObjectDefByTitleIndex(
                   pDataBlock,
                   pInstanceDef->ParentObjectTitleIndex);

                if (!pParentObj) {
                   // can't locate the parent, forget it
                   break;
                }

                // Object type of parent found; now find parent
                // instance

                pParentInst = GetInstance(pParentObj,
                   pInstanceDef->ParentObjectInstance);

                if (!pParentInst) {
                   // can't locate the parent instance, forget it
                   break ;
                }

                if (IsMatchingInstance (pParentInst, pParentObj->CodePage,
                    pParentName, 0)) {
                   // Parent Instance Name matches that passed in
                    if (dwLocalIndex == 0) {
                        pReturnDef = pInstanceDef;
                        break;
                    } else {
                        --dwLocalIndex;
                    }
                }
            }
        }
        // get the next one
        pInstanceDef = NextInstance(pInstanceDef);
    }
    return pReturnDef;
}

PERF_INSTANCE_DEFINITION *
PerfHelper::GetInstanceByName(
    PERF_DATA_BLOCK *pDataBlock,
    PERF_OBJECT_TYPE *pObjectDef,
    LPWSTR pInstanceName,
    LPWSTR pParentName,
    DWORD   dwIndex
)
{
    PERF_OBJECT_TYPE *pParentObj;

    PERF_INSTANCE_DEFINITION *pParentInst;
    PERF_INSTANCE_DEFINITION *pInstanceDef;
    PERF_INSTANCE_DEFINITION *pReturnDef = NULL;
    PERF_INSTANCE_DEFINITION *pEndOfBuffer = NULL;

    LONG  NumInstance;
    DWORD  dwLocalIndex;
    DWORD   dwInstanceNameLength;

    pInstanceDef = FirstInstance(pObjectDef);
    if (pInstanceDef != NULL) {
        dwLocalIndex = dwIndex;
        dwInstanceNameLength = lstrlenW(pInstanceName);
        pEndOfBuffer = (PERF_INSTANCE_DEFINITION *)EndOfObject(pObjectDef);

        for ( NumInstance = 0;
            NumInstance < pObjectDef->NumInstances;
            NumInstance++ ) {
            if (IsMatchingInstance (pInstanceDef, pObjectDef->CodePage,
                pInstanceName, dwInstanceNameLength)) {

                // Instance name matches
                if ( !pInstanceDef->ParentObjectTitleIndex ) {
                    // No parent, we're done
                    if (dwLocalIndex == 0) {
                        pReturnDef = pInstanceDef;
                        break;
                    } else {
                        --dwLocalIndex;
                    }
                } else {
                    // Must match parent as well
                    pParentObj = GetObjectDefByTitleIndex(
                                    pDataBlock,
                                    pInstanceDef->ParentObjectTitleIndex);

                    if (pParentObj != NULL) {
                        // Object type of parent found; now find parent
                        // instance

                        pParentInst = GetInstance(pParentObj,
                                        pInstanceDef->ParentObjectInstance);

                        if (pParentInst != NULL) {
                            if (IsMatchingInstance (pParentInst,
                                    pParentObj->CodePage, pParentName, 0)) {
                            // Parent Instance Name matches that passed in

                                if (dwLocalIndex == 0) {
                                    pReturnDef = pInstanceDef;
                                    break;
                                } else {
                                    --dwLocalIndex;
                                }
                            }
                        }
                    } else {
                        // keep trying
                    }
                }
            }
            // go to next instance in object and check for buffer overrun
            pInstanceDef = NextInstance(pInstanceDef);
            if (pInstanceDef >= pEndOfBuffer) {
                // something doesn't add up so bail out and return NULL
                break;
            }
        }
    }
    return pReturnDef;
}  // GetInstanceByName

DWORD
PerfHelper::GetFullInstanceNameStr (
    PERF_DATA_BLOCK             *pPerfData,
    PERF_OBJECT_TYPE            *pObjectDef,
    PERF_INSTANCE_DEFINITION    *pInstanceDef,
    LPWSTR                      szInstanceName,
    size_t                      cchBufferSize
)
// compile instance name.
// the instance name can either be just
// the instance name itself or it can be
// the concatenation of the parent instance,
// a delimiting char (backslash) followed by
// the instance name
{

    WCHAR   szInstanceNameString[PDH_MAX_INSTANCE_NAME];
    WCHAR   szParentNameString[PDH_MAX_INSTANCE_NAME];

    DWORD                       dwLength = 0;
    PERF_OBJECT_TYPE            *pParentObjectDef;
    PERF_INSTANCE_DEFINITION    *pParentInstanceDef;

    szInstanceNameString[0] = UNICODE_NULL;
    szParentNameString[0] = UNICODE_NULL;
    if (pInstanceDef->UniqueID == PERF_NO_UNIQUE_ID) {
        dwLength = GetInstanceNameStr (pInstanceDef,
            szInstanceNameString,
            PDH_MAX_INSTANCE_NAME,
            pObjectDef->CodePage);
    } else {
        // make a string out of the unique ID
        _ltow (pInstanceDef->UniqueID, szInstanceNameString, 10);
        dwLength = lstrlenW (szInstanceNameString);
    }

    if (pInstanceDef->ParentObjectTitleIndex > 0) {
        // then add in parent instance name
        pParentObjectDef = GetObjectDefByTitleIndex (
            pPerfData,
            pInstanceDef->ParentObjectTitleIndex);

        if (pParentObjectDef != NULL) {
            pParentInstanceDef = GetInstance (
                pParentObjectDef,
                pInstanceDef->ParentObjectInstance);
            assert ((UINT_PTR)pParentObjectDef != (DWORD)0xFFFFFFFF);
            if (pParentInstanceDef != NULL) {
                if (pParentInstanceDef->UniqueID == PERF_NO_UNIQUE_ID) {
                    dwLength += GetInstanceNameStr (pParentInstanceDef,
                        szParentNameString,
                        PDH_MAX_INSTANCE_NAME,
                        pParentObjectDef->CodePage);
                } else {
                    // make a string out of the unique ID
                    _ltow (pParentInstanceDef->UniqueID, szParentNameString, 10);
                    dwLength += lstrlenW (szParentNameString);
                }

                StringCchCatW( szParentNameString, PDH_MAX_INSTANCE_NAME, cszSlash );
               
                dwLength += 1;
                StringCchCatW(szParentNameString, PDH_MAX_INSTANCE_NAME, szInstanceNameString);
                StringCchCopyW( szInstanceName, cchBufferSize, szParentNameString);
            } else {
                StringCchCopyW( szInstanceName, cchBufferSize, szInstanceNameString);
            }
        } else {
            StringCchCopyW( szInstanceName, cchBufferSize, szInstanceNameString);
        }
    } else {
        StringCchCopyW( szInstanceName, cchBufferSize,  szInstanceNameString);
    }

    return dwLength;

}

//***************************************************************************
//
//  PerfHelper::GetInstances
//
//  This is called to retrieve all instances of a given class.
//
//  Parameters:
//  <pBuf>          The perf blob retrieved from HKEY_PERFORMANCE_DATA.
//  <pClassMap>     A map object of the class required.
//  <pSink>         The sink to which to deliver the objects.
//
//***************************************************************************
//
void PerfHelper::GetInstances(
    LPBYTE pBuf,
    CClassMapInfo *pClassMap,
    IWbemObjectSink *pSink
    )
{
    PPERF_OBJECT_TYPE           PerfObj = 0;
    PPERF_OBJECT_TYPE           pEndOfBuffer = 0;
    PPERF_INSTANCE_DEFINITION   PerfInst = 0;
    PPERF_INSTANCE_DEFINITION   pEndOfObject = 0;
    PPERF_COUNTER_DEFINITION    PerfCntr = 0, CurCntr = 0;
    PPERF_COUNTER_BLOCK         PtrToCntr = 0;
    PPERF_DATA_BLOCK            PerfData = (PPERF_DATA_BLOCK) pBuf;
    DWORD i, j, k;

    IWbemObjectAccess           *pNewInst = 0;
    IWbemClassObject            *pClsObj = 0;

    WCHAR                       pName[PDH_MAX_INSTANCE_NAME];
    LONG                        lStatus = 0;
    LONG                        hPropHandle;
    LPDWORD                     pdwVal;
    ULONGLONG                   *pullVal;
    HRESULT                     hRes;
    LONG64                      llVal;

    // Get the first object type.
    // ==========================

    PerfObj = (PPERF_OBJECT_TYPE) ((PBYTE)PerfData +
        PerfData->HeaderLength);

    if (PerfObj != NULL) {
        // get end of buffer
        pEndOfBuffer = (PPERF_OBJECT_TYPE)
                        ((DWORD_PTR)PerfData +
                            PerfData->TotalByteLength);

        // Process all objects.
        // ====================

        for (i = 0; i < PerfData->NumObjectTypes; i++ ) {
            // Within each PERF_OBJECT_TYPE is a series of
            // PERF_COUNTER_DEFINITION blocks.
            // ==========================================

            PerfCntr = (PPERF_COUNTER_DEFINITION) ((PBYTE)PerfObj +
                PerfObj->HeaderLength);

            // If the current object isn't of the class we requested,
            // simply skip over it.  I am not sure if this can really
            // happen or not in practice.
            // ======================================================

            if (PerfObj->ObjectNameTitleIndex != pClassMap->m_dwObjectId) {
                PerfObj = (PPERF_OBJECT_TYPE)((PBYTE)PerfObj +
                    PerfObj->TotalByteLength);
                if (PerfObj >= pEndOfBuffer) {
                    // looks like we ran off the end of the data buffer
                    break;
                } 
                else {
                    continue;
                }
            }

            if (PerfObj->NumInstances > 0) {
                // Get the first instance.
                // =======================

                PerfInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)PerfObj +
                    PerfObj->DefinitionLength);
                
                if (PerfInst < (PPERF_INSTANCE_DEFINITION)pEndOfBuffer) {
                        // make sure we are still within the caller's buffer
                        // then find the end of this object

                     pEndOfObject = (PERF_INSTANCE_DEFINITION *)EndOfObject(PerfObj);

                    // Retrieve all instances.
                    // =======================

                    for (k = 0; k < DWORD(PerfObj->NumInstances); k++ ) 
                    {
                        CurCntr = PerfCntr;
                        pClsObj  = NULL;
                        pNewInst = NULL;
                        HRESULT hr;
                        // Get the first counter.
                        // ======================

                        PtrToCntr = (PPERF_COUNTER_BLOCK)((PBYTE)PerfInst +
                            PerfInst->ByteLength);

                        // Quickly clone a new instance to send back to the user.
                        // Since SpawnInstance() returns an IWbemClassObject and
                        // we really need an IWbemObjectAccess,we have to QI
                        // after the spawn.  We need to fix this, as this number
                        // of calls is too time consuming.
                        // ======================================================

                        hr = pClassMap->m_pClassDef->SpawnInstance(0, &pClsObj);
                        if (SUCCEEDED(hr))
                        {
                            hr = pClsObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pNewInst);
                            pClsObj->Release(); // We only need the IWbemObjectAccess pointer
                            if( NULL == pNewInst ){
                                break;
                            }
                        }
                        else
                        {
                            break;
                        }

                        // Locate the instance name.
                        // ==========================
                        lStatus = GetFullInstanceNameStr (
                            PerfData, PerfObj, PerfInst, pName, PDH_MAX_INSTANCE_NAME );

                        // Retrieve all counters.
                        // ======================

                        for(j = 0; j < PerfObj->NumCounters; j++ ) {
                            // Find the WBEM property handle based on the counter title index.
                            // This function does a quick binary search of the class map object
                            // to find the handle that goes with this counter.
                            // ================================================================

                            hPropHandle = pClassMap->GetPropHandle(
                                    CM_MAKE_PerfObjectId(CurCntr->CounterNameTitleIndex,
                                                         CurCntr->CounterType));
                            if (hPropHandle != 0) {
                                // update value according to data type
                                if ((CurCntr->CounterType & 0x300) == 0) {
                                    pdwVal  = LPDWORD((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                                    hRes    = pNewInst->WriteDWORD(hPropHandle, *pdwVal);
                                } else if ((CurCntr->CounterType & 0x300) == 0x100){
                                    pullVal = (ULONGLONG *)((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                                    llVal   = Assign64((PLARGE_INTEGER) pullVal);
                                    hRes = pNewInst->WriteQWORD(hPropHandle, llVal);
                                } else {
                                    //this shouldn't happen
                                    assert (FALSE);
                                }
                            }

                            // Get next counter.
                            // =================
                            CurCntr =  (PPERF_COUNTER_DEFINITION)((PBYTE)CurCntr +
                                CurCntr->ByteLength);
                        }

                        // Write the instance 'name'
                        // =========================

                        if (pName && pClassMap->m_dwNameHandle) {
                            pNewInst->WritePropertyValue(
                                pClassMap->m_dwNameHandle,
                                (DWORD)(((DWORD)(wcslen(pName)) + 1) * 2),
                                LPBYTE(pName)
                                );
                        }

                        // update the timestamp
                        if (pClassMap->m_dwPerfTimeStampHandle) {
                            UpdateTimers(pClassMap, pNewInst, PerfData, PerfObj);
                        }

                        // Deliver the instance to the user.
                        // =================================
                        pSink->Indicate(1, (IWbemClassObject **) &pNewInst);
                        pNewInst->Release();

                        // Move to the next perf instance.
                        // ================================
                        PerfInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)PtrToCntr +
                            PtrToCntr->ByteLength);
                        if (PerfInst >= pEndOfObject) {
                            // something doesn't add up so bail out of this object
                            break;
                        }
                    }
                }
            } 
            else if (PerfObj->NumInstances == PERF_NO_INSTANCES) 
            {
                HRESULT hr;
                pClsObj = NULL;
                pNewInst = NULL;
                // Cases where the counters have one and only one instance.
                // ========================================================

                // Get the first counter.
                // ======================

                PtrToCntr = (PPERF_COUNTER_BLOCK) ((PBYTE)PerfObj +
                    PerfObj->DefinitionLength );

                // Quickly clone a new instance to send back to the user.
                // Since SpawnInstance() returns an IWbemClassObject and
                // we really need an IWbemObjectAccess,we have to QI
                // after the spawn.  We need to fix this, as this number
                // of calls is too time consuming.
                // ======================================================

                hr = pClassMap->m_pClassDef->SpawnInstance(0, &pClsObj);
                if (SUCCEEDED(hr))
                {
                    pClsObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pNewInst);
                    pClsObj->Release();

                    // Retrieve all counters.
                    // ======================

                    for( j=0; j < PerfObj->NumCounters; j++ ) {
                        // Find the WBEM property handle based on the counter title index.
                        // This function does a quick binary search of the class map object
                        // to find the handle that goes with this counter.
                        // ================================================================

                        hPropHandle = pClassMap->GetPropHandle(
                                CM_MAKE_PerfObjectId(PerfCntr->CounterNameTitleIndex,
                                                     PerfCntr->CounterType));
                        if (hPropHandle != 0) {
                            if ((PerfCntr->CounterType & 0x300) == 0) {
                                pdwVal  = LPDWORD((LPVOID)((PBYTE)PtrToCntr + PerfCntr->CounterOffset));
                                hRes    = pNewInst->WriteDWORD(hPropHandle, *pdwVal);
                            } else if ((PerfCntr->CounterType & 0x300) == 0x100) {
                                pullVal = (ULONGLONG *)((LPVOID)((PBYTE)PtrToCntr + PerfCntr->CounterOffset));
                                llVal   = Assign64((PLARGE_INTEGER) pullVal);
                                hRes    = pNewInst->WriteQWORD(hPropHandle, llVal);
                            } else {
                                // this shouldn't happen
                                assert (FALSE);
                            }
                        }

                        PerfCntr = (PPERF_COUNTER_DEFINITION)((PBYTE)PerfCntr +
                               PerfCntr->ByteLength);
                    }

                                        // update the timestamp
                                        if (pClassMap->m_dwPerfTimeStampHandle) {
                                            UpdateTimers(pClassMap, pNewInst, PerfData, PerfObj);
                                        }

                    pSink->Indicate(1, (IWbemClassObject **) &pNewInst);
                    pNewInst->Release();
                }

            } else {
                // this object can have instances, but currently doesn't
                // so there's nothing to report
            }
            break;
        }
    }
}

void PerfHelper::RefreshEnumeratorInstances (
    IN  RefresherCacheEl            *pThisCacheEl, 
    IN  PPERF_DATA_BLOCK            PerfData,
    IN  PPERF_OBJECT_TYPE           PerfObj
)
{
    LONG    lNumObjInstances;
    LONG    lStatus;
    HRESULT hRes;

    PPERF_INSTANCE_DEFINITION   PerfInst = 0;
    PPERF_INSTANCE_DEFINITION   pEndOfObject = 0;
    PPERF_COUNTER_DEFINITION    PerfCntr = 0, CurCntr = 0;
    PPERF_COUNTER_BLOCK         PtrToCntr = 0;
    WCHAR                       pName[PDH_MAX_INSTANCE_NAME];

    LONG                        hPropHandle;
    LPDWORD                     pdwVal;
    ULONGLONG                   *pullVal;
    LONG64                      llVal;

    IWbemObjectAccess           *pNewInst = 0;

    assert (PerfObj != NULL);
    assert (pThisCacheEl != NULL);

    if (pThisCacheEl == NULL)
        return;

    // make sure we have enough pointers 
    // handle the singleton object case
    if (PerfObj->NumInstances == PERF_NO_INSTANCES) {
        lNumObjInstances = 1;
    } else {
        lNumObjInstances = PerfObj->NumInstances;
    }

    if (pThisCacheEl->m_aEnumInstances.Size() < lNumObjInstances) {
        LONG    i;
        // alloc and init the ID array
        if (pThisCacheEl->m_plIds != NULL) {
            delete (pThisCacheEl->m_plIds);
        }
    
        pThisCacheEl->m_lEnumArraySize = lNumObjInstances;
        pThisCacheEl->m_plIds = new LONG[lNumObjInstances];
        
        if (pThisCacheEl->m_plIds == NULL)
            return;

        for (i = 0; i < lNumObjInstances; i++) pThisCacheEl->m_plIds[i] = i;
        
        // add the new IWbemObjectAccess pointers
        for (i = pThisCacheEl->m_aEnumInstances.Size(); 
            i < PerfObj->NumInstances;
            i++) 
        {
            IWbemClassObject *  pClsObj  = NULL;
            HRESULT hr;
            
            hr = pThisCacheEl->m_pClassMap->m_pClassDef->SpawnInstance(0, &pClsObj);
            if (SUCCEEDED(hr))
            {
                pClsObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pNewInst);
                pClsObj->Release(); // We only need the IWbemObjectAccess pointer
            
                pThisCacheEl->m_aEnumInstances.Add (pNewInst);
            }
        }
    }
    assert (pThisCacheEl->m_aEnumInstances.Size() >= lNumObjInstances);

    // release enumerator items to prepare a new batch

    hRes = pThisCacheEl->m_pHiPerfEnum->RemoveAll(0);
    assert (hRes == S_OK);

    // update new instance list

    if (PerfObj->NumInstances == PERF_NO_INSTANCES) {
        //handle the singleton case

    } else if (PerfObj->NumInstances > 0) {
        // Get the first instance.
        // =======================

        PerfInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)PerfObj +
            PerfObj->DefinitionLength);

        // get pointer to the end of this object buffer
        pEndOfObject = (PERF_INSTANCE_DEFINITION *)EndOfObject(PerfObj);

        // point to the first counter definition in the object
        PerfCntr = (PPERF_COUNTER_DEFINITION) ((PBYTE)PerfObj +
            PerfObj->HeaderLength);

        // Retrieve all instances.
        // =======================

        for (LONG k = 0; k < PerfObj->NumInstances; k++ ) {
            CurCntr = PerfCntr;
            // Get the first counter.
            // ======================

            PtrToCntr = (PPERF_COUNTER_BLOCK)((PBYTE)PerfInst +
                PerfInst->ByteLength);

            // get the IWbemObjectAccess pointer from our 
            // cached array of pointers

            pNewInst = (IWbemObjectAccess *)(pThisCacheEl->m_aEnumInstances.GetAt(k));

            // Locate the instance name.
            // ==========================
            lStatus = GetFullInstanceNameStr (
                PerfData, PerfObj, PerfInst, pName, PDH_MAX_INSTANCE_NAME );

            // Retrieve all counters.
            // ======================

            if( NULL != pNewInst ){
                for(DWORD j = 0; j < PerfObj->NumCounters; j++ ) {
                    // Find the WBEM property handle based on the counter title index.
                    // This function does a quick binary search of the class map object
                    // to find the handle that goes with this counter.
                    // ================================================================

                    hPropHandle = pThisCacheEl->m_pClassMap->GetPropHandle(
                            CM_MAKE_PerfObjectId(CurCntr->CounterNameTitleIndex,
                            CurCntr->CounterType));
                    if (hPropHandle != 0) {
                        // update value according to data type
                        if ((CurCntr->CounterType & 0x300) == 0) {
                            pdwVal  = LPDWORD((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                            hRes    = pNewInst->WriteDWORD(hPropHandle, *pdwVal);
                        } else if ((CurCntr->CounterType & 0x300) == 0x100){
                            pullVal = (ULONGLONG *)((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                            llVal   = Assign64((PLARGE_INTEGER) pullVal);
                            hRes    = pNewInst->WriteQWORD(hPropHandle, llVal);
                        } else {
                            //this shouldn't happen
                            assert (FALSE);
                        }
                    }

                    // Get next counter.
                    // =================
                    CurCntr =  (PPERF_COUNTER_DEFINITION)((PBYTE)CurCntr +
                        CurCntr->ByteLength);
                }

                // Write the instance 'name'
                // =========================

                if (pName && pThisCacheEl->m_pClassMap->m_dwNameHandle) {
                    pNewInst->WritePropertyValue(
                        pThisCacheEl->m_pClassMap->m_dwNameHandle,
                        (DWORD)(((DWORD)(wcslen(pName)) + 1) * 2),
                        LPBYTE(pName)
                        );
                }

                // update the timestamp
                if (pThisCacheEl->m_pClassMap->m_dwPerfTimeStampHandle) {
                    UpdateTimers(pThisCacheEl->m_pClassMap, pNewInst, PerfData, PerfObj);
                }

                // Move to the next perf instance.
                // ================================
                PerfInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)PtrToCntr +
                    PtrToCntr->ByteLength);

                if (PerfInst >= pEndOfObject) {
                    // something doesn't add up so bail out of this object
                    break;
                }
            }
        }
    } else {
        // no instances so there's nothing to do
    }

    if (lNumObjInstances > 0) {
        // update the hiperf enumerator object
        hRes = pThisCacheEl->m_pHiPerfEnum->AddObjects( 
                0,
                lNumObjInstances,
                pThisCacheEl->m_plIds,
                (IWbemObjectAccess __RPC_FAR *__RPC_FAR *)pThisCacheEl->m_aEnumInstances.GetArrayPtr());
    } else {
        // nothing to do since we've already cleared the enumerator above
    }
}

//***************************************************************************
//
//  PerfHelper::RefreshInstances
//
//  searches the refresher's list first then
//  looks up the corresponding items in the perf data structure
//
//***************************************************************************
//
void PerfHelper::RefreshInstances(
    LPBYTE pBuf,
    CNt5Refresher *pRef
)
{
    PPERF_OBJECT_TYPE           PerfObj = 0;
    PPERF_INSTANCE_DEFINITION   PerfInst = 0;
    PPERF_COUNTER_DEFINITION    PerfCntr = 0, CurCntr = 0;
    PPERF_COUNTER_BLOCK         PtrToCntr = 0;
    PPERF_DATA_BLOCK            PerfData = (PPERF_DATA_BLOCK) pBuf;

    // for each refreshable object
    PRefresherCacheEl           pThisCacheEl;
    DWORD                       dwNumCacheEntries = pRef->m_aCache.Size();
    DWORD                       dwThisCacheEntryIndex = 0;
    DWORD                       dwThisCounter;
    DWORD                       dwThisInstanceIndex = 0;
    DWORD                       dwNumInstancesInCache = 0;
    IWbemObjectAccess           *pInst = 0;
    LONG                        hPropHandle;
    LPDWORD                     pdwVal;
    HRESULT                     hRes;
    ULONGLONG                   *pullVal;
    LONG64                      llVal;


    while (dwThisCacheEntryIndex < dwNumCacheEntries) {
        // get this entry from the cache
        pThisCacheEl = (PRefresherCacheEl) pRef->m_aCache[dwThisCacheEntryIndex];
        // get class map from this entry
        CClassMapInfo *pClassMap = pThisCacheEl->m_pClassMap;
        // get perf object pointer from the perf data block
        PerfObj = GetObjectDefByTitleIndex (
            PerfData, pThisCacheEl->m_dwPerfObjIx);
        if (PerfObj != NULL) {
            // found the object so do each of the instances
            // loaded in this refresher
            PerfCntr = (PPERF_COUNTER_DEFINITION)
                ((PBYTE)PerfObj +
                  PerfObj->HeaderLength);

            // found so update the properties
            if (PerfObj->NumInstances > 0) {
                // see if they have an enumerator interface and refresh it if they do
                if (pThisCacheEl->m_pHiPerfEnum != NULL) {
                    // refresh enum
                    RefreshEnumeratorInstances (pThisCacheEl, PerfData, PerfObj);
                }
                //do each instance in this class
                dwThisInstanceIndex = 0;
                dwNumInstancesInCache = pThisCacheEl->m_aInstances.Size();
                while (dwThisInstanceIndex < dwNumInstancesInCache ) {
                    pInst = 0;
                    // get the pointer to this instance in the refresher
                    CachedInst *pInstInfo = PCachedInst(pThisCacheEl->m_aInstances[dwThisInstanceIndex]);
                    // get the pointer to the instance block in the current object
                    PerfInst = GetInstanceByName(
                        PerfData,
                        PerfObj,
                        pInstInfo->m_szInstanceName,
                        pInstInfo->m_szParentName,
                        pInstInfo->m_dwIndex);

                    pInst = pInstInfo->m_pInst;
                    // Get the first counter.
                    // ======================
                    CurCntr = PerfCntr;

                    if (PerfInst != NULL) {
                        PtrToCntr = (PPERF_COUNTER_BLOCK)((PBYTE)PerfInst +
                            PerfInst->ByteLength);

                        // Retrieve all counters for the instance if it was one of the instances
                        // we are supposed to be refreshing.
                        // =====================================================================

                        for (dwThisCounter = 0; dwThisCounter < PerfObj->NumCounters; dwThisCounter++ ) {
                            hPropHandle = pClassMap->GetPropHandle(
                                    CM_MAKE_PerfObjectId(CurCntr->CounterNameTitleIndex,
                                                         CurCntr->CounterType));
                            if (hPropHandle != 0) {
                                // Data is (LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset);

                                if ((CurCntr->CounterType & 0x300) == 0) {
                                    pdwVal  = LPDWORD((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                                    hRes    = pInst->WriteDWORD(hPropHandle, *pdwVal);
                                } else if ((CurCntr->CounterType & 0x300) == 0x100) {
                                    pullVal = (ULONGLONG *)((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                                    llVal   = Assign64((PLARGE_INTEGER) pullVal);
                                    hRes    = pInst->WriteQWORD(hPropHandle, llVal);
                                } else {
                                    // This shouldn't happen
                                    assert (FALSE);
                                }
                            }

                            // Get next counter.
                            // =================
                            CurCntr =  (PPERF_COUNTER_DEFINITION)((PBYTE)CurCntr +
                                CurCntr->ByteLength);
                        }
                        // update the timestamp
                        if (pClassMap->m_dwPerfTimeStampHandle) {
                            UpdateTimers(pClassMap, pInst, PerfData, PerfObj);
                        } // else no timestamp handle present
                    } else {
                        // then there's no data for this
                        // instance anymore so zero out the values and continue
                        for (dwThisCounter = 0; dwThisCounter < PerfObj->NumCounters; dwThisCounter++ ) {
                            hPropHandle = pClassMap->GetPropHandle(
                                    CM_MAKE_PerfObjectId(CurCntr->CounterNameTitleIndex,
                                                         CurCntr->CounterType));
                            if (hPropHandle != 0) {
                                if ((CurCntr->CounterType & 0x300) == 0) {
                                    hRes = pInst->WriteDWORD(hPropHandle, 0);
                                } else if ((CurCntr->CounterType & 0x300) == 0x100) {
                                    hRes = pInst->WriteQWORD(hPropHandle, 0);
                                } else {
                                    // This shouldn't happen
                                    assert (FALSE);
                                }
                            }

                            // Get next counter.
                            // =================
                            CurCntr =  (PPERF_COUNTER_DEFINITION)((PBYTE)CurCntr +
                                CurCntr->ByteLength);
                        }

                        // update the timestamp
                        if (pClassMap->m_dwPerfTimeStampHandle) {
                            // save system timer tick
                            pInst->WriteQWORD(pClassMap->m_dwPerfTimeStampHandle , 0);
                            // use system 100 NS timer
                            pInst->WriteQWORD(pClassMap->m_dw100NsTimeStampHandle, 0);
                            // use timer from object
                            pInst->WriteQWORD(pClassMap->m_dwObjectTimeStampHandle, 0);
                        }
                    }       
                    // Get the next instance.
                    // =====================
                    dwThisInstanceIndex++;
                }
            } else if (PerfObj->NumInstances == PERF_NO_INSTANCES
                        && NULL != pThisCacheEl->m_pSingleton ) {

                // Check that the singleton instance did not get cleared
                // due to no references.

                // only a single instance so get the properties and
                // update them
                // Get the first counter.

                // Find the singleton WBEM instance which correponds to the singleton perf instance
                // along with its class def so that we have the property handles.
                //
                // Note that since the perf object index translates to a WBEM class and there
                // can only be one instance, all that is required to find the instance in the
                // refresher is the perf object title index.
                // =================================================================================

                pInst = pThisCacheEl->m_pSingleton;

                // ======================

                PtrToCntr = (PPERF_COUNTER_BLOCK) ((PBYTE)PerfObj +
                    PerfObj->DefinitionLength );

                // Retrieve all counters if the instance is one we are supposed to be refreshing.
                // ==============================================================================
                for( dwThisCounter=0;
                     dwThisCounter < PerfObj->NumCounters;
                     dwThisCounter++ ) {
                    // Get the property handle for the counter.
                    // ========================================

                    hPropHandle = pClassMap->GetPropHandle(
                            CM_MAKE_PerfObjectId(PerfCntr->CounterNameTitleIndex,
                                                 PerfCntr->CounterType));
                    if (hPropHandle != 0) {
                        // update the data values based on the datatype
                        if ((PerfCntr->CounterType & 0x300) == 0) {
                            pdwVal  = LPDWORD((LPVOID)((PBYTE)PtrToCntr + PerfCntr->CounterOffset));
                            hRes    = pInst->WriteDWORD(hPropHandle, *pdwVal);
                        } else if ((PerfCntr->CounterType & 0x300) == 0x100){
                            pullVal = (ULONGLONG *)((LPVOID)((PBYTE)PtrToCntr + PerfCntr->CounterOffset));
                            llVal   = Assign64((PLARGE_INTEGER) pullVal);
                            hRes    = pInst->WriteQWORD(hPropHandle, llVal);
                        } else {
                            // this shouldn't happen
                            assert (FALSE);
                        }
                    }

                    // get next counter definition
                    PerfCntr = (PPERF_COUNTER_DEFINITION)((PBYTE)PerfCntr +
                           PerfCntr->ByteLength);
                }
                // update the timestamp
                if (pClassMap->m_dwPerfTimeStampHandle) {
                    UpdateTimers(pClassMap, pInst, PerfData, PerfObj);
                }
            } else {
                // this object could have instances but doesn't so
                // skip
            }
        } else {
            // desired object not found in data
        }

        // Get the next refresher object
        // =========================
        dwThisCacheEntryIndex++;
    }
}

//***************************************************************************
//
//  QueryInstances
//
//  Used to send back all instances of a perf counter.  The counter
//  is specified by the <pClassMap> object, which is tightly bound to
//  a particular counter.
//
//***************************************************************************
//
BOOL PerfHelper::QueryInstances(
    CPerfObjectAccess *pPerfObj,
    CClassMapInfo *pClassMap,
    IWbemObjectSink *pSink
)
{
    DWORD   dwBufSize = 0;
    LPBYTE  pBuf = NULL;
    LONG    lStatus;
    BOOL    bReturn = FALSE;
    WCHAR   szValueNum[WBEMPERF_STRING_SIZE];
    
    for (;;) {
        dwBufSize += 0x10000;   // 64K
        assert (dwBufSize< 0x100000);   // make sure we don't do this forever

        pBuf = new BYTE[dwBufSize];
        assert (pBuf != NULL);

        if (pBuf != NULL) {
            // either do a global or a costly query depending on the
            // object being queried
            if (pClassMap->GetObjectId() > 0) {
                _ultow (pClassMap->GetObjectId(), (LPWSTR)szValueNum, 10);
            } else if (pClassMap->IsCostly()) {
                StringCchCopyW( szValueNum, WBEMPERF_STRING_SIZE, cszCostly);
            } else {
                StringCchCopyW(szValueNum, WBEMPERF_STRING_SIZE, cszGlobal);
            }
            lStatus = pPerfObj->CollectData (pBuf, &dwBufSize, szValueNum);
            if (lStatus == ERROR_MORE_DATA) {
                // toss the old buffer as it's not useful
                delete pBuf;
                continue;
            } else if (lStatus == ERROR_SUCCESS) {
                bReturn = TRUE;
            }
            break;
        } else {
            // memory allocation failure
            break;
        }
    }

    if (bReturn && (pBuf != NULL)) {
        // a good buffer was returned so
        // Decode the instances and send them back.
        // ========================================

        GetInstances(pBuf, pClassMap, pSink);
    }

    // Cleanup.
    // ========
    if (pBuf != NULL) delete pBuf;

    return bReturn;
}

//***************************************************************************
//
//  RefreshInstances
//
//  Used to refresh a set of instances.
//
//***************************************************************************
//
BOOL PerfHelper::RefreshInstances(
    CNt5Refresher *pRef
)
{
    DWORD   dwBufSize = 0;
    LPBYTE  pBuf = NULL;
    LONG    lStatus;
    BOOL    bReturn = FALSE;

    for (;;) {
        dwBufSize += 0x10000;   // 64K
        assert (dwBufSize< 0x100000);   // make sure we don't do this forever

        pBuf = new BYTE[dwBufSize];
        assert (pBuf != NULL);

        if (pBuf != NULL) {
            lStatus = pRef->m_PerfObj.CollectData (pBuf, &dwBufSize);
            if (lStatus == ERROR_MORE_DATA) {
                // toss the old buffer as it's not useful
                delete pBuf;
                continue;
            } else if (lStatus == ERROR_SUCCESS) {
                bReturn = TRUE;
            }
            break;
        } else {
            // memory allocation failure
            break;
        }
    }

    if (bReturn && (pBuf != NULL)) {
        // update the instances and send them back.
        // ========================================
        RefreshInstances(pBuf, pRef);
    }
    // Cleanup.
    // ========

    if (pBuf != NULL) delete pBuf;

    return bReturn;
}

VOID
PerfHelper::UpdateTimers(
    CClassMapInfo     *pClassMap,
    IWbemObjectAccess *pInst,
    PPERF_DATA_BLOCK  PerfData,
    PPERF_OBJECT_TYPE PerfObj
    )
{
    LONG64 llVal;

    // save system timer tick
    llVal = Assign64(&PerfData->PerfTime);
    pInst->WriteQWORD(
       pClassMap->m_dwPerfTimeStampHandle ,
       llVal
       );
   // use timer from object
    llVal = Assign64(&PerfObj->PerfTime);
   pInst->WriteQWORD(
       pClassMap->m_dwObjectTimeStampHandle,
       llVal
       );
   // use system 100 NS timer
   llVal = Assign64(&PerfData->PerfTime100nSec);
   pInst->WriteQWORD(
       pClassMap->m_dw100NsTimeStampHandle,
       llVal
       );
   // save system timer freq
   llVal = Assign64(&PerfData->PerfFreq);
   pInst->WriteQWORD(
       pClassMap->m_dwPerfFrequencyHandle ,
       llVal
       );
   // use timer from object
    llVal = Assign64(&PerfObj->PerfFreq);
   pInst->WriteQWORD(
       pClassMap->m_dwObjectFrequencyHandle,
       llVal
       );
   // use system 100 NS Freq
   pInst->WriteQWORD(
       pClassMap->m_dw100NsFrequencyHandle,
       (LONGLONG)10000000);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\perfacc.cpp ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  PerfAcc.CPP
//  
//  Windows NT Performance Data Access helper functions
//
//  bobw         8-Jub-98   Created for use with NT Perf counters
//
//***************************************************************************
//
#include "wpheader.h"
#include <stdlib.h>
#include "oahelp.inl"
//#include <malloc.h>

// NOTE: Consider reading this from the registry
LONG    lExtCounterTestLevel = EXT_TEST_ALL;

LPCWSTR cszFirstCounter         = L"First Counter";
LPCWSTR cszLastCounter          = L"Last Counter";

//
//
// precompiled security descriptor
// System and NetworkService has full access
//
// since this is RELATIVE, it will work on both IA32 and IA64
//
DWORD g_PrecSD[] = {
  0x80040001 , 0x00000044 , 0x00000050 , 0x00000000  ,
  0x00000014 , 0x00300002 , 0x00000002 , 0x00140000  ,
  0x001f0001 , 0x00000101 , 0x05000000 , 0x00000012  ,
  0x00140000 , 0x001f0001 , 0x00000101 , 0x05000000  ,
  0x00000014 , 0x00000101 , 0x05000000 , 0x00000014  ,
  0x00000101 , 0x05000000 , 0x00000014 
};

DWORD g_SizeSD = 0;

DWORD g_RuntimeSD[(sizeof(ACL)+sizeof(ACCESS_ALLOWED_ACE)+sizeof(SECURITY_DESCRIPTOR_RELATIVE)+4*(sizeof(SID)+SID_MAX_SUB_AUTHORITIES*sizeof(DWORD)))/sizeof(DWORD)];

typedef 
BOOLEAN ( * fnRtlValidRelativeSecurityDescriptor)(
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    );

fnRtlValidRelativeSecurityDescriptor RtlValidRelativeSecurityDescriptor;

//
//  Build a SD with owner == This
//                  group == This
//                  DACL
//                  ACE[0]  MUTEX_ALL_ACCESS Owner
//                  ACE[1]  MUTEX_ALL_ACCESS System
///////////////////////////////////////////////////////////////////

BOOL
CreateSD( )
{
    TOKEN_USER * pToken_User = NULL;
    SECURITY_DESCRIPTOR_RELATIVE * pLocalSD = NULL;
    PACL pDacl = NULL;

    //
    // Using GetProcAddress so that nt.h does not have to be included.
    // Since WBEM and NT don't get along this function would need to 
    // be in a separate file.
    //
    
    if (! RtlValidRelativeSecurityDescriptor)
    {
        HMODULE hModule = GetModuleHandleW(L"ntdll.dll");
        if (hModule)
        {
            RtlValidRelativeSecurityDescriptor = (fnRtlValidRelativeSecurityDescriptor)GetProcAddress(hModule,"RtlValidRelativeSecurityDescriptor");
            if (! RtlValidRelativeSecurityDescriptor)
            {
                return FALSE;
            }
        }
    }

    HANDLE hToken;
    BOOL bRet;
    
    bRet = OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&hToken);
    if (bRet)
    {
        DWORD dwSize = sizeof(TOKEN_USER)+sizeof(SID)+(SID_MAX_SUB_AUTHORITIES*sizeof(DWORD));
        pToken_User = (TOKEN_USER *)ALLOCMEM( GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);
        if( NULL == pToken_User ){
            bRet = FALSE;
            goto cleanup;
        }
        bRet = GetTokenInformation(hToken,TokenUser,pToken_User,dwSize,&dwSize);
        if (bRet)
        {
            SID SystemSid = { SID_REVISION,
                              1,
                              SECURITY_NT_AUTHORITY,
                              SECURITY_LOCAL_SYSTEM_RID 
                            };
        
            PSID pSIDUser = pToken_User->User.Sid;
            dwSize = GetLengthSid(pSIDUser);
            DWORD dwSids = 2; // Owner and System
            DWORD ACLLength = (ULONG) sizeof(ACL) +
                              (dwSids * ((ULONG) sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) + dwSize + sizeof(SystemSid);

            DWORD dwSizeSD = sizeof(SECURITY_DESCRIPTOR_RELATIVE) + dwSize + dwSize + ACLLength;
            pLocalSD = (SECURITY_DESCRIPTOR_RELATIVE *)ALLOCMEM(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSizeSD); 
            if( NULL == pLocalSD ){
                bRet = FALSE;
                goto cleanup;
            }
            memset(pLocalSD,0,sizeof(SECURITY_DESCRIPTOR_RELATIVE));
            pLocalSD->Revision = SECURITY_DESCRIPTOR_REVISION;
            pLocalSD->Control = SE_DACL_PRESENT|SE_SELF_RELATIVE;
            
            //SetSecurityDescriptorOwner(pLocalSD,pSIDUser,FALSE);
            memcpy((BYTE*)pLocalSD+sizeof(SECURITY_DESCRIPTOR_RELATIVE),pSIDUser,dwSize);
            pLocalSD->Owner = (DWORD)sizeof(SECURITY_DESCRIPTOR_RELATIVE);
            
            //SetSecurityDescriptorGroup(pLocalSD,pSIDUser,FALSE);
            memcpy((BYTE*)pLocalSD+sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize,pSIDUser,dwSize);
            pLocalSD->Group = (DWORD)(sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize);


            pDacl = (PACL)ALLOCMEM(GetProcessHeap(), HEAP_ZERO_MEMORY, ACLLength);
            if( NULL == pDacl ){
                bRet = FALSE;
                goto cleanup;
            }

            bRet = InitializeAcl( pDacl,
                                  ACLLength,
                                  ACL_REVISION);
            if (bRet)
            {
                bRet = AddAccessAllowedAceEx (pDacl,ACL_REVISION,0,MUTEX_ALL_ACCESS,&SystemSid);
                if (bRet)
                {
                    bRet = AddAccessAllowedAceEx (pDacl,ACL_REVISION,0,MUTEX_ALL_ACCESS,pSIDUser);
                    
                    if (bRet)
                    {
                        //bRet = SetSecurityDescriptorDacl(pLocalSD,TRUE,pDacl,FALSE);
                        memcpy((BYTE*)pLocalSD+sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize+dwSize,pDacl,ACLLength);                    
                        pLocalSD->Dacl = (DWORD)(sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize+dwSize);

                        if (RtlValidRelativeSecurityDescriptor(pLocalSD,
                                                           dwSizeSD,
                                                           OWNER_SECURITY_INFORMATION|
                                                           GROUP_SECURITY_INFORMATION|
                                                           DACL_SECURITY_INFORMATION))
                        {
                            g_SizeSD = dwSizeSD;
                            memcpy(g_RuntimeSD,pLocalSD,dwSizeSD);
                        }
                        else
                        {
                            bRet = FALSE;
                        }
                    }
                }
            }
        }
        
        CloseHandle(hToken);
    }

cleanup:
    if( NULL != pToken_User ){
        FREEMEM(GetProcessHeap(), 0, pToken_User );
    }
    if( NULL != pLocalSD ){
        FREEMEM(GetProcessHeap(), 0, pLocalSD );
    }
    if( NULL != pDacl ){
        FREEMEM(GetProcessHeap(), 0, pDacl );
    }

    return bRet;
};

//***************************************************************************
//
//  HANDLE CreateMutexAsProcess(LPCWSTR pwszName)
//
//  This function will create a mutex using the process' security context
//
//***************************************************************************
//
HANDLE CreateMutexAsProcess(LPCWSTR pwszName)
{
    BOOL bImpersonating = FALSE;

    HANDLE hThreadToken = NULL;

    // Determine if we are impersonating

    bImpersonating = OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE, TRUE,
        &hThreadToken);
   
    if(bImpersonating)
    {
        // Determine if we are impersonating
        
        bImpersonating = RevertToSelf();
    }

    // Create the mutex as using the process token.



    HANDLE hRet = OpenMutexW(MUTEX_ALL_ACCESS,FALSE,pwszName);
    if (NULL == hRet)
    {
        SECURITY_ATTRIBUTES sa;
    
        if (0 == g_SizeSD)
        {
            if (CreateSD())
            {
                sa.nLength = g_SizeSD; 
                sa.lpSecurityDescriptor = (LPVOID)g_RuntimeSD; 
                sa.bInheritHandle = FALSE;            
            }
            else
            {
                sa.nLength = sizeof(g_PrecSD);
                sa.lpSecurityDescriptor = (LPVOID)g_PrecSD;
                sa.bInheritHandle = FALSE;            
            
            }             
        }
        else
        {
            sa.nLength = g_SizeSD; 
            sa.lpSecurityDescriptor = (LPVOID)g_RuntimeSD; 
            sa.bInheritHandle = FALSE;                    
        }

        hRet = CreateMutexW(&sa, FALSE, pwszName);
    }

    // If code was oringinally impersonating, resume impersonation

    if(bImpersonating){
        BOOL bRes = SetThreadToken(NULL, hThreadToken);
    }

    if(hThreadToken)
        CloseHandle(hThreadToken);

    return hRet;
}


//***************************************************************************
//
//  CPerfDataLibrary ::CPerfDataLibrary 
//
//  This object is used to abstract the perf data library
//
//***************************************************************************
//
CPerfDataLibrary::CPerfDataLibrary (void)
{
    pLibInfo = NULL;
    memset ((LPVOID)szQueryString, 0, sizeof(szQueryString));
    dwRefCount = 0;     // number of classes referencing this object
}

CPerfDataLibrary::~CPerfDataLibrary (void)
{
    // all libraries should be closed before this is
    // destructed
    assert (dwRefCount == 0);
    assert (pLibInfo == NULL);
}

//***************************************************************************
//
//  CPerfObjectAccess::CPerfObjectAccess
//
//  This object is used to abstract a data object within a perf library
//
//***************************************************************************
//
CPerfObjectAccess::CPerfObjectAccess ()
{
    m_hObjectHeap = HeapCreate(HEAP_GENERATE_EXCEPTIONS, 0x10000, 0);
    if (m_hObjectHeap == NULL) {
        // then just use the process heap
        m_hObjectHeap = GetProcessHeap();
    }

    m_aLibraries.Empty();
    lEventLogLevel = LOG_UNDEFINED;
    hEventLog = NULL;
}

CPerfObjectAccess::~CPerfObjectAccess ()
{
    int    nNumLibraries;
    int    nIdx;

    CPerfDataLibrary *pThisLibrary;

    // close any lingering libraries
    nNumLibraries = m_aLibraries.Size();
    for (nIdx = 0; nIdx < nNumLibraries; nIdx++) {
        pThisLibrary = (CPerfDataLibrary *)m_aLibraries[nIdx];
        CloseLibrary (pThisLibrary);
        FREEMEM(m_hObjectHeap, 0, pThisLibrary->pLibInfo);
        pThisLibrary->pLibInfo = NULL;
        delete pThisLibrary;
    }
    m_aLibraries.Empty();

    if ((m_hObjectHeap != NULL) && (m_hObjectHeap != GetProcessHeap())) {
        HeapDestroy (m_hObjectHeap);
    }
}

//***************************************************************************
//
//  CPerfObjectAccess::CloseLibrary (CPerfDataLibrary *pLib)
//
//  removes a reference to the library that contains this object and closes
//  the library when the last reference is removed
//
//***************************************************************************
//
DWORD
CPerfObjectAccess::CloseLibrary (CPerfDataLibrary *pLib)
{
    pExtObject  pInfo;
    LONG        lStatus;

    assert (pLib != NULL);
    assert (pLib->pLibInfo != NULL);
    pInfo = pLib->pLibInfo;

    assert (pLib->dwRefCount > 0); 
    if (pLib->dwRefCount > 0)   {
        pLib->dwRefCount--;

        if (pLib->dwRefCount == 0) {
            // if there's a close proc to call, then 
            // call close procedure to close anything that may have
            // been allocated by the library
            if (pInfo->hMutex != NULL){
                lStatus = WaitForSingleObject (
                    pInfo->hMutex, 
                    pInfo->dwOpenTimeout);

                if ( lStatus != WAIT_TIMEOUT ){
                    if( pInfo->CloseProc != NULL ){
                        __try{
                            lStatus = (*pInfo->CloseProc) ();
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            lStatus = ERROR_INVALID_FUNCTION;
                        }
                    }
                    ReleaseMutex(pInfo->hMutex);
                } else {
                    pInfo->dwLockoutCount++;
                }
            } else {
                lStatus = ERROR_LOCK_FAILED;
            }

            // then close everything
            if (pInfo->hMutex != NULL) {
                CloseHandle (pInfo->hMutex);
                pInfo->hMutex = NULL;
            }
            
            if (pInfo->hLibrary != NULL) {
                FreeLibrary (pInfo->hLibrary);
                pInfo->hLibrary = NULL;
            }
 
            if (pInfo->hPerfKey != NULL) {
                RegCloseKey (pInfo->hPerfKey);
                pInfo->hPerfKey = NULL;
            }
        }
    }
    return pLib->dwRefCount; // returns remaining references
}

//***************************************************************************
//
//  CPerfObjectAccess::OpenExtObjectLibrary (pExtObject  pObj)
//
//  OpenExtObjectLibrary
//
//    Opens the specified library and looks up the functions used by
//    the performance library. If the library is successfully
//    loaded and opened then the open procedure is called to initialize
//    the object.
//
//    This function expects locked and exclusive access to the object while
//    it is opening. This must be provided by the calling function.
//
//  Arguments:
//
//    pObj    -- pointer to the object information structure of the
//                perf object to close
//
//***************************************************************************
//
DWORD
CPerfObjectAccess::OpenExtObjectLibrary (pExtObject  pObj)
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwOpenEvent = 0;
    DWORD   dwType;
    DWORD   dwSize;
    DWORD   dwValue;

    // variables used for event logging
    DWORD   dwDataIndex;
    WORD    wStringIndex;
    DWORD   dwRawDataDwords[8];
    LPWSTR  szMessageArray[8];

    UINT    nErrorMode;

    // check to see if the library has already been opened

    if (pObj->hLibrary == NULL) {
        // library isn't loaded yet, so
        // check to see if this function is enabled

        dwType = 0;
        dwSize = sizeof (dwValue);
        dwValue = 0;
        Status = RegQueryValueExW (
            pObj->hPerfKey,
            cszDisablePerformanceCounters,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize);

        if ((Status == ERROR_SUCCESS) &&
            (dwType == REG_DWORD) &&
            (dwValue == 1)) {
            // then DON'T Load this library
            Status = ERROR_SERVICE_DISABLED;
        } else {
            Status = ERROR_SUCCESS;
            //  go ahead and load it
            nErrorMode = SetErrorMode (SEM_FAILCRITICALERRORS);
            // then load library & look up functions
            pObj->hLibrary = LoadLibraryExW (pObj->szLibraryName,
                NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

            if (pObj->hLibrary != NULL) {
                const size_t cchSize = 512;
                WCHAR buffer[cchSize];
                // lookup function names
                pObj->OpenProc = (OPENPROC)GetProcAddress(
                    pObj->hLibrary, pObj->szOpenProcName);
                if (pObj->OpenProc == NULL) {
                    if (lEventLogLevel >= LOG_USER) {
                        Status = GetLastError();
                        // load data for eventlog message
                        dwDataIndex = wStringIndex = 0;
                        dwRawDataDwords[dwDataIndex++] =
                            (DWORD)Status;
                        szMessageArray[wStringIndex++] =
                            ConvertProcName(pObj->szOpenProcName, buffer, cchSize);
                        szMessageArray[wStringIndex++] =
                            pObj->szLibraryName;
                        szMessageArray[wStringIndex++] =
                            pObj->szServiceName;

                        ReportEventW (hEventLog,
                            EVENTLOG_ERROR_TYPE,        // error type
                            0,                          // category (not used)
                            (DWORD)WBEMPERF_OPEN_PROC_NOT_FOUND,              // event,
                            NULL,                       // SID (not used),
                            wStringIndex,               // number of strings
                            dwDataIndex*sizeof(DWORD),  // sizeof raw data
                            (LPCWSTR *)szMessageArray,             // message text array
                            (LPVOID)&dwRawDataDwords[0]);           // raw data
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    if (pObj->dwFlags & PERF_EO_QUERY_FUNC) {
                        pObj->QueryProc = (QUERYPROC)GetProcAddress (
                            pObj->hLibrary, pObj->szCollectProcName);
                        pObj->CollectProc = (COLLECTPROC)pObj->QueryProc;
                    } else {
                        pObj->CollectProc = (COLLECTPROC)GetProcAddress (
                            pObj->hLibrary, pObj->szCollectProcName);
                        pObj->QueryProc = (QUERYPROC)pObj->CollectProc;
                    }

                    if (pObj->CollectProc == NULL) {
                        if (lEventLogLevel >= LOG_USER) {
                            Status = GetLastError();
                            // load data for eventlog message
                            dwDataIndex = wStringIndex = 0;
                            dwRawDataDwords[dwDataIndex++] =
                                (DWORD)Status;
                            szMessageArray[wStringIndex++] =
                                ConvertProcName(pObj->szCollectProcName, buffer, cchSize );
                            szMessageArray[wStringIndex++] =
                                pObj->szLibraryName;
                            szMessageArray[wStringIndex++] =
                                pObj->szServiceName;

                            ReportEventW (hEventLog,
                                EVENTLOG_ERROR_TYPE,        // error type
                                0,                          // category (not used)
                                (DWORD)WBEMPERF_COLLECT_PROC_NOT_FOUND,              // event,
                                NULL,                       // SID (not used),
                                wStringIndex,               // number of strings
                                dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                (LPCWSTR *)szMessageArray,             // message text array
                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                        }
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    pObj->CloseProc = (CLOSEPROC)GetProcAddress (
                        pObj->hLibrary, pObj->szCloseProcName);

                    if (pObj->CloseProc == NULL) {
                        if (lEventLogLevel >= LOG_USER) {
                            Status = GetLastError();
                            // load data for eventlog message
                            dwDataIndex = wStringIndex = 0;
                            dwRawDataDwords[dwDataIndex++] =
                                (DWORD)Status;
                            szMessageArray[wStringIndex++] =
                                ConvertProcName(pObj->szCloseProcName, buffer, cchSize);
                            szMessageArray[wStringIndex++] =
                                pObj->szLibraryName;
                            szMessageArray[wStringIndex++] =
                                pObj->szServiceName;

                            ReportEventW (hEventLog,
                                EVENTLOG_ERROR_TYPE,        // error type
                                0,                          // category (not used)
                                (DWORD)WBEMPERF_CLOSE_PROC_NOT_FOUND,              // event,
                                NULL,                       // SID (not used),
                                wStringIndex,               // number of strings
                                dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                (LPCWSTR *)szMessageArray,             // message text array
                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                        }
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    __try {

                        // call open procedure to initialize DLL
                        if (pObj->hMutex != NULL) {
                            Status = WaitForSingleObject (
                                pObj->hMutex, 
                                pObj->dwOpenTimeout);

                            if (Status != WAIT_TIMEOUT){
                                if( pObj->OpenProc != NULL ) {
                                    Status = (*pObj->OpenProc)(pObj->szLinkageString);
                                }
                                ReleaseMutex(pObj->hMutex);
                            }
                            else {
                                pObj->dwLockoutCount++;
                            }
                        } else {
                            Status = ERROR_LOCK_FAILED;
                        }

                        // check the result.
                        if (Status != ERROR_SUCCESS) {
                            dwOpenEvent = WBEMPERF_OPEN_PROC_FAILURE;
                        } else {
                            InterlockedIncrement((LONG *)&pObj->dwOpenCount);
                        }
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        Status = GetExceptionCode();
                        dwOpenEvent = WBEMPERF_OPEN_PROC_EXCEPTION;
                    }

                    if (Status != ERROR_SUCCESS) {
                        // load data for eventlog message
                        dwDataIndex = wStringIndex = 0;
                        dwRawDataDwords[dwDataIndex++] =
                            (DWORD)Status;
                        szMessageArray[wStringIndex++] =
                            pObj->szServiceName;
                        szMessageArray[wStringIndex++] =
                            pObj->szLibraryName;

                        ReportEventW (hEventLog,
                            (WORD)EVENTLOG_ERROR_TYPE, // error type
                            0,                          // category (not used)
                            dwOpenEvent,                // event,
                            NULL,                       // SID (not used),
                            wStringIndex,               // number of strings
                            dwDataIndex*sizeof(DWORD),  // sizeof raw data
                            (LPCWSTR *)szMessageArray,                // message text array
                            (LPVOID)&dwRawDataDwords[0]);           // raw data
                    }
                }

                if (Status != ERROR_SUCCESS) {
                    // clear fields
                    pObj->OpenProc = NULL;
                    pObj->CollectProc = NULL;
                    pObj->QueryProc = NULL;
                    pObj->CloseProc = NULL;
                    if (pObj->hLibrary != NULL) {
                        FreeLibrary (pObj->hLibrary);
                        pObj->hLibrary = NULL;
                    }
                } else {
                    pObj->llLastUsedTime = GetTimeAsLongLong();
                }
            } else {
                Status = GetLastError();
            }
            SetErrorMode (nErrorMode);
        }
    } else {
        // else already open so bump the ref count
        pObj->llLastUsedTime = GetTimeAsLongLong();
    }

    if( ERROR_SUCCESS != Status ){
        if( ERROR_ACCESS_DENIED == Status ){
            InterlockedExchange( (LONG*)&(pObj->ADThreadId), 
                GetCurrentThreadId() );
        }else{
            InterlockedIncrement( (LONG*)&(pObj->dwOpenFail) );
        }
    }else{
        InterlockedExchange( (LONG*)&(pObj->dwOpenFail), 0 );
        InterlockedExchange( (LONG*)&(pObj->ADThreadId), 0 );
    }
    
    return Status;
}

//***************************************************************************
//
//  CPerfObjectAccess::AddLibrary   (
//          IWbemClassObject *pClass, 
//          IWbemQualifierSet *pClassQualifiers,
//          LPCWSTR szRegistryKey,
//          DWORD   dwPerfIndex)
//
//  Adds the library referenced by the class object to the list of 
//  libraries to call 
//
//***************************************************************************
//
DWORD
CPerfObjectAccess::AddLibrary   (
            IWbemClassObject *pClass, 
            IWbemQualifierSet *pClassQualifiers,
            LPCWSTR szRegistryKey,
            DWORD   dwPerfIndex)
{
    CPerfDataLibrary *pLibEntry = NULL;
    LONG    Status = ERROR_SUCCESS;
    HKEY    hServicesKey = NULL;
    HKEY    hPerfKey = NULL;
    LPWSTR  szServiceName = NULL;

    HKEY    hKeyLinkage;

    BOOL    bUseQueryFn = FALSE;

    pExtObject  pReturnObject = NULL;

    DWORD   dwType = 0;
    DWORD   dwSize = 0;
    DWORD   dwFlags = 0;
    DWORD   dwKeep;
    DWORD   dwObjectArray[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];
    DWORD   dwObjIndex = 0;
    DWORD   dwMemBlockSize = sizeof(ExtObject);
    DWORD   dwLinkageStringLen = 0;
    DWORD   dwFirstCounter = 2;
    DWORD   dwLastCounter  = 1846;

    const size_t cchSize = WBEMPERF_STRING_SIZE;
    size_t StorageSizeA = cchSize * 3 * sizeof(CHAR);
    size_t StorageSizeW = cchSize * 9 * sizeof(WCHAR);
    LPSTR    szStorageA = NULL;
    LPWSTR   szStorageW = NULL;
    
    LPSTR    szOpenProcName;
    LPSTR    szCollectProcName;
    LPSTR    szCloseProcName;
    LPWSTR   szLibraryString;
    LPWSTR   szLibraryExpPath;
    LPWSTR   mszObjectList;
    LPWSTR   szLinkageKeyPath;
    LPWSTR   szLinkageString;

    DWORD   dwOpenTimeout = 0;
    DWORD   dwCollectTimeout = 0;

    LPWSTR  szThisObject;
    LPWSTR  szThisChar;

    LPSTR   pNextStringA;
    LPWSTR  pNextStringW;

    LPWSTR  szServicePath;
    LPWSTR  szMutexName;
    WCHAR   szPID[32];

    szStorageW = (LPWSTR)ALLOCMEM(m_hObjectHeap, HEAP_ZERO_MEMORY, StorageSizeW );
    szStorageA = (LPSTR)ALLOCMEM(m_hObjectHeap, HEAP_ZERO_MEMORY, StorageSizeA );

    if( NULL == szStorageA || NULL == szStorageW ){
        Status = ERROR_OUTOFMEMORY;
        goto cleanup;
    }else{
        pNextStringA = szStorageA;
        pNextStringW = szStorageW;

        szOpenProcName = pNextStringA;
        pNextStringA += cchSize;
        szCollectProcName = pNextStringA;
        pNextStringA += cchSize;
        szCloseProcName = pNextStringA;

        szLibraryString = pNextStringW;
        pNextStringW += cchSize;
        szLibraryExpPath = pNextStringW;
        pNextStringW += cchSize;
        mszObjectList = pNextStringW;
        pNextStringW += cchSize;
        szLinkageKeyPath = pNextStringW;
        pNextStringW += cchSize;
        szLinkageString = pNextStringW;
        pNextStringW += cchSize;
        szServicePath = pNextStringW;
        pNextStringW += cchSize;
        szMutexName = pNextStringW;
    }

    assert(pClass != NULL);
    assert(pClassQualifiers != NULL);

    UNREFERENCED_PARAMETER(pClassQualifiers);
    UNREFERENCED_PARAMETER(pClass);

    pLibEntry = new CPerfDataLibrary;
    
    if ((pLibEntry != NULL) && (szRegistryKey != NULL)) {

        StringCchCopyW(szServicePath, cchSize, cszHklmServicesKey);

        Status = RegOpenKeyExW (HKEY_LOCAL_MACHINE, szServicePath, 
            0, KEY_READ, &hServicesKey);

        if (Status == ERROR_SUCCESS) {
            StringCchCopyW(szServicePath, cchSize, szRegistryKey);
            StringCchCatW(szServicePath, cchSize, cszPerformance);
            Status = RegOpenKeyExW (hServicesKey, szServicePath, 
                0, KEY_READ, &hPerfKey);

            if (Status == ERROR_SUCCESS) {
                szServiceName = (LPWSTR)szRegistryKey;

                // read the performance DLL name

                dwType = 0;
                dwSize = cchSize * sizeof(WCHAR);

                Status = RegQueryValueExW (hPerfKey,
                                        cszDLLValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szLibraryString,
                                        &dwSize);
            }
        }

        if (Status == ERROR_SUCCESS) {
            if (dwType == REG_EXPAND_SZ) {
                // expand any environment vars
                dwSize = ExpandEnvironmentStringsW(
                    szLibraryString,
                    szLibraryExpPath,
                    cchSize);

                if ((dwSize > WBEMPERF_STRING_SIZE) || (dwSize == 0)) {
                    Status = ERROR_INVALID_DLL;
                } else {
                    dwSize += 1;
                    dwSize *= sizeof(WCHAR);
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }
            } else if (dwType == REG_SZ) {
                // look for dll and save full file Path
                dwSize = SearchPathW (
                    NULL,   // use standard system search path
                    szLibraryString,
                    NULL,
                    WBEMPERF_STRING_SIZE,
                    szLibraryExpPath,
                    NULL);

                if ((dwSize > WBEMPERF_STRING_SIZE) || (dwSize == 0)) {
                    Status = ERROR_INVALID_DLL;
                } else {
                    dwSize += 1;
                    dwSize *= sizeof(WCHAR);
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }
            } else {
                Status = ERROR_INVALID_DLL;
            }

            if (Status == ERROR_SUCCESS) {
                // we have the DLL name so get the procedure names
                dwType = 0;
                dwSize = cchSize * sizeof(CHAR);

                Status = RegQueryValueExA (hPerfKey,
                                        caszOpenValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szOpenProcName,
                                        &dwSize);
            }

            if (Status == ERROR_SUCCESS) {
                // add in size of previous string
                // the size value includes the Term. NULL
                dwMemBlockSize += DWORD_MULTIPLE(dwSize);

                // we have the procedure name so get the timeout value
                dwType = 0;
                dwSize = cchSize * sizeof(WCHAR);
                Status = RegQueryValueExW (hPerfKey,
                                        cszOpenTimeout,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)&dwOpenTimeout,
                                        &dwSize);

                // if error, then apply default
                if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                    dwOpenTimeout = dwExtCtrOpenProcWaitMs;
                    Status = ERROR_SUCCESS;
                }

            }

            if (Status == ERROR_SUCCESS) {
                // add in size of previous string
                // the size value includes the Term. NULL
                dwMemBlockSize += DWORD_MULTIPLE(dwSize);

                // we have the procedure name so get the timeout value
                dwType = 0;
                dwSize = sizeof(dwFirstCounter);
                Status = RegQueryValueExW (hPerfKey,
                                        cszFirstCounter,
                                        NULL,
                                        & dwType,
                                        (LPBYTE) & dwFirstCounter,
                                        & dwSize);

                // if error, then apply default
                if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                    dwFirstCounter = 2; // assume this is for system base counters
                    Status = ERROR_SUCCESS;
                }

            }

            if (Status == ERROR_SUCCESS) {
                // add in size of previous string
                // the size value includes the Term. NULL
                dwMemBlockSize += DWORD_MULTIPLE(dwSize);

                // we have the procedure name so get the timeout value
                dwType = 0;
                dwSize = sizeof(dwLastCounter);
                Status = RegQueryValueExW (hPerfKey,
                                        cszLastCounter,
                                        NULL,
                                        & dwType,
                                        (LPBYTE) & dwLastCounter,
                                        & dwSize);

                // if error, then apply default
                if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                    dwLastCounter = 1846; // assume this is for system base counters
                    Status = ERROR_SUCCESS;
                }

            }

            if (Status == ERROR_SUCCESS) {
                // get next string

                dwType = 0;
                dwSize = cchSize * sizeof(CHAR);
                Status = RegQueryValueExA (hPerfKey,
                                        caszCloseValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szCloseProcName,
                                        &dwSize);
            }

            if (Status == ERROR_SUCCESS) {
                // add in size of previous string
                // the size value includes the Term. NULL
                dwMemBlockSize += DWORD_MULTIPLE(dwSize);

                // try to look up the query function which is the
                // preferred interface if it's not found, then
                // try the collect function name. If that's not found,
                // then bail
                dwType = 0;
                dwSize = cchSize * sizeof(CHAR);
                Status = RegQueryValueExA (hPerfKey,
                                        caszQueryValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szCollectProcName,
                                        &dwSize);

                if (Status == ERROR_SUCCESS) {
                    // add in size of the Query Function Name
                    // the size value includes the Term. NULL
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                    // get next string

                    bUseQueryFn = TRUE;
                    // the query function can support a static object list
                    // so look it up

                } else {
                    // the QueryFunction wasn't found so look up the
                    // Collect Function name instead
                    dwType = 0;
                    dwSize = cchSize * sizeof(CHAR);
                    Status = RegQueryValueExA (hPerfKey,
                                            caszCollectValue,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)szCollectProcName,
                                            &dwSize);

                    if (Status == ERROR_SUCCESS) {
                        // add in size of Collect Function Name
                        // the size value includes the Term. NULL
                        dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    // we have the procedure name so get the timeout value
                    dwType = 0;
                    dwSize = sizeof(dwCollectTimeout);
                    Status = RegQueryValueExW (hPerfKey,
                                            cszCollectTimeout,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)&dwCollectTimeout,
                                            &dwSize);

                    // if error, then apply default
                    if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                        dwCollectTimeout = dwExtCtrOpenProcWaitMs;
                        Status = ERROR_SUCCESS;
                    }

                }
                // get the list of supported objects if provided by the registry

                dwType = 0;
                dwSize = cchSize * sizeof(WCHAR);
                Status = RegQueryValueExW (hPerfKey,
                                        cszObjListValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)mszObjectList,
                                        &dwSize);

                if (Status == ERROR_SUCCESS) {
                    if (dwType != REG_MULTI_SZ) {
                        size_t cch;
                        // convert space delimited list to msz
                        for (szThisChar = mszObjectList, cch = 0; 
                            *szThisChar != 0  && cch < cchSize; 
                            szThisChar++, cch++) {
                                
                            if (*szThisChar == L' ') *szThisChar = L'\0';
                        }
                        ++szThisChar;
                        *szThisChar = 0; // add MSZ term Null
                    }
                    for (szThisObject = mszObjectList, dwObjIndex = 0;
                        (*szThisObject != 0) && (dwObjIndex < MAX_PERF_OBJECTS_IN_QUERY_FUNCTION);
                        szThisObject += lstrlenW(szThisObject) + 1) {
                        dwObjectArray[dwObjIndex] = wcstoul(szThisObject, NULL, 10);
                        dwObjIndex++;
                    }
                    if (*szThisObject != 0) {
                        DWORD  dwDataIndex  = 0;
                        WORD   wStringIndex = 0;
                        DWORD  dwRawDataDwords[8];
                        LPWSTR szMessageArray[8];
                        dwRawDataDwords[dwDataIndex++] = (DWORD) ERROR_SUCCESS;
                        szMessageArray[wStringIndex++] = (LPWSTR) cszObjListValue;
                        szMessageArray[wStringIndex++] = szLibraryString;
                        szMessageArray[wStringIndex++] = szServicePath;

                        ReportEventW(hEventLog,
                                     EVENTLOG_WARNING_TYPE,
                                     0,
                                     (DWORD) WBEMPERF_TOO_MANY_OBJECT_IDS,
                                     NULL,
                                     wStringIndex,
                                     dwDataIndex * sizeof(DWORD),
                                     (LPCWSTR *) szMessageArray,
                                     (LPVOID) & dwRawDataDwords[0]);
                    }
                } else {
                    // reset status since not having this is
                    //  not a showstopper
                    Status = ERROR_SUCCESS;
                }

                if (Status == ERROR_SUCCESS) {
                    dwType = 0;
                    dwKeep = 0;
                    dwSize = sizeof(dwKeep);
                    Status = RegQueryValueExW (hPerfKey,
                                            cszKeepResident,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)&dwKeep,
                                            &dwSize);

                    if ((Status == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
                        if (dwKeep == 1) {
                            dwFlags |= PERF_EO_KEEP_RESIDENT;
                        } else {
                            // no change.
                        }
                    } else {
                        // not fatal, just use the defaults.
                        Status = ERROR_SUCCESS;
                    }

                }
            }
        }

        if (Status == ERROR_SUCCESS) {

            StringCchCopyW( szLinkageKeyPath, cchSize, szServiceName);
            StringCchCatW( szLinkageKeyPath, cchSize, cszLinkageKey);

            Status = RegOpenKeyExW (
                hServicesKey,
                szLinkageKeyPath,
                0L,
                KEY_READ,
                &hKeyLinkage);

            if (Status == ERROR_SUCCESS) {
                // look up export value string
                dwSize = sizeof(szLinkageString);
                dwType = 0;
                Status = RegQueryValueExW (
                    hKeyLinkage,
                    cszExportValue,
                    NULL,
                    &dwType,
                    (LPBYTE)&szLinkageString,
                    &dwSize);

                if ((Status != ERROR_SUCCESS) ||
                    ((dwType != REG_SZ) && (dwType != REG_MULTI_SZ))) {
                    // clear buffer
                    dwLinkageStringLen = 0;

                    // not finding a linkage key is not fatal so correct
                    // status
                    Status = ERROR_SUCCESS;
                } else {
                    // add size of linkage string to buffer
                    // the size value includes the Term. NULL
                    dwLinkageStringLen = dwSize;
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }

                RegCloseKey (hKeyLinkage);
            } else {
                // not finding a linkage key is not fatal so correct
                // status
                Status = ERROR_SUCCESS;
            }
        }

        if (Status == ERROR_SUCCESS) {
            size_t cbDestSize;            
            
            // add in size of service name
            dwSize = lstrlenW (szServiceName);
            dwSize += 1;
            dwSize *= sizeof(WCHAR);
            dwMemBlockSize += DWORD_MULTIPLE(dwSize);
            cbDestSize = dwMemBlockSize - sizeof(pExtObject);
            
            // allocate and initialize a new ext. object block
            pReturnObject = (pExtObject)ALLOCMEM(m_hObjectHeap,
                HEAP_ZERO_MEMORY, dwMemBlockSize);

            if (pReturnObject != NULL) {
                // copy values to new buffer (all others are NULL)
                pNextStringA = (LPSTR)&pReturnObject[1];

                // copy Open Procedure Name
                pReturnObject->szOpenProcName = pNextStringA;
                StringCbCopyA( pNextStringA, cbDestSize, szOpenProcName );

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);
                cbDestSize = dwMemBlockSize - ((PUCHAR)pNextStringA - (PUCHAR)pReturnObject);
                    
                pReturnObject->dwOpenTimeout = dwOpenTimeout;

                // copy collect function or query function, depending
                pReturnObject->szCollectProcName = pNextStringA;
                StringCbCopyA(pNextStringA, cbDestSize, szCollectProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);
                cbDestSize = dwMemBlockSize - ((PUCHAR)pNextStringA - (PUCHAR)pReturnObject);

                pReturnObject->dwCollectTimeout = dwCollectTimeout;

                // copy Close Procedure Name
                pReturnObject->szCloseProcName = pNextStringA;
                StringCbCopyA(pNextStringA, cbDestSize, szCloseProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);
                cbDestSize = dwMemBlockSize - ((PUCHAR)pNextStringA - (PUCHAR)pReturnObject);

                // copy Library path
                pNextStringW = (LPWSTR)pNextStringA;
                pReturnObject->szLibraryName = pNextStringW;
                StringCbCopyW(pNextStringW, cbDestSize, szLibraryExpPath);

                pNextStringW += lstrlenW (pNextStringW) + 1;
                pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);
                cbDestSize = dwMemBlockSize - ((PUCHAR)pNextStringW - (PUCHAR)pReturnObject);

                // copy Linkage String if there is one
                if (*szLinkageString != 0) {
                    pReturnObject->szLinkageString = pNextStringW;
                    if( cbDestSize > dwLinkageStringLen ){
                        memcpy (pNextStringW, szLinkageString, dwLinkageStringLen);

                        // length includes extra NULL char and is in BYTES
                        pNextStringW += (dwLinkageStringLen / sizeof (WCHAR));
                        pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);
                        cbDestSize = dwMemBlockSize - ((PUCHAR)pNextStringW - (PUCHAR)pReturnObject);
                    }
                    
                }

                // copy Service name
                pReturnObject->szServiceName = pNextStringW;
                StringCbCopyW(pNextStringW, cbDestSize, szServiceName);

                pNextStringW += lstrlenW (pNextStringW) + 1;
                pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);
                cbDestSize = dwMemBlockSize - ((PUCHAR)pNextStringW - (PUCHAR)pReturnObject);

                // load flags
                if (bUseQueryFn) {
                    dwFlags |= PERF_EO_QUERY_FUNC;
                }
                pReturnObject->dwFlags =  dwFlags;

                pReturnObject->hPerfKey = hPerfKey;
                hPerfKey = NULL;

                // load Object array
                if (dwObjIndex > 0) {
                    pReturnObject->dwNumObjects = dwObjIndex;
                    memcpy (pReturnObject->dwObjList,
                        dwObjectArray, (dwObjIndex * sizeof(dwObjectArray[0])));
                }
                pReturnObject->dwFirstCounter = dwFirstCounter;
                pReturnObject->dwLastCounter  = dwLastCounter;
                pReturnObject->llLastUsedTime = 0;

                // create Mutex name
                StringCchCopyW(szMutexName, cchSize, szRegistryKey);
                StringCchCatW( szMutexName, cchSize, (LPCWSTR)L"_Perf_Library_Lock_PID_");
                _ultow ((ULONG)GetCurrentProcessId(), szPID, 16);
                StringCchCatW( szMutexName, cchSize, szPID);

                // pReturnObject->hMutex = CreateMutexW (NULL, FALSE, szMutexName);
                pReturnObject->hMutex = CreateMutexAsProcess(szMutexName);
            } else {
                Status = ERROR_OUTOFMEMORY;
            }
        }

        if (Status != ERROR_SUCCESS) {
            SetLastError (Status);
            if (pReturnObject != NULL) {
                // release the new block
                hPerfKey = pReturnObject->hPerfKey;
                FREEMEM (m_hObjectHeap, 0, pReturnObject);
            }
        } else {
            if (pReturnObject != NULL) {
                Status = OpenExtObjectLibrary (pReturnObject);
                if (Status == ERROR_SUCCESS) {
                    if (dwPerfIndex != 0) {
                        // initialize the perf index string
                        _ultow (dwPerfIndex, pLibEntry->szQueryString, 10);
                    } else {
                        StringCchCopyW(pLibEntry->szQueryString, 
                            MAX_PERF_OBJECTS_IN_QUERY_FUNCTION * 10, cszGlobal);
                    }
                    // save the pointer to the initialize structure
                    pLibEntry->pLibInfo = pReturnObject;
                    m_aLibraries.Add(pLibEntry);
                    pLibEntry->dwRefCount++;
                    assert(pLibEntry->dwRefCount == 1);
                } else {
                    // release the new block
                    
                    hPerfKey = pReturnObject->hPerfKey;
                    FREEMEM (m_hObjectHeap, 0, pReturnObject);
                }
            }
        }

        if (hServicesKey != NULL) RegCloseKey (hServicesKey);
    } else {    // gets here if pLibEntry == NULL and/or szRegistryKey == NULL
        if (pLibEntry == NULL) {
            Status = ERROR_OUTOFMEMORY;
        }
        if (szRegistryKey == NULL) {
            Status = ERROR_INVALID_PARAMETER;
        }
    }
    if ((Status != ERROR_SUCCESS) && (pLibEntry != NULL))
        delete pLibEntry;

cleanup:
    if( hPerfKey != NULL ){
        RegCloseKey( hPerfKey );
    }
    FREEMEM (m_hObjectHeap, 0, szStorageA );
    FREEMEM (m_hObjectHeap, 0, szStorageW );

    return Status;
}

//***************************************************************************
//
//  CPerfObjectAccess::AddClass (IWbemClassObject *pClass, BOOL bCatalogQuery)
//
//  Adds the specified WBEM performance object class and any required library 
//  entries to the access object.
//
//***************************************************************************
//
DWORD   
CPerfObjectAccess::AddClass (IWbemClassObject *pClass, BOOL bCatalogQuery)
{
    CPerfDataLibrary *pLibEntry = NULL;
    CPerfDataLibrary *pThisLibEntry = NULL;
    DWORD           dwIndex, dwEnd;
    LPWSTR          szRegistryKey = NULL;
    IWbemQualifierSet   *pClassQualifiers = NULL;
    VARIANT         vRegistryKey;
    HRESULT         hRes;
    DWORD           dwReturn = ERROR_SUCCESS;
    DWORD           dwPerfIndex = 0;

    CBSTR           cbPerfIndex(cszPerfIndex);
    CBSTR           cbRegistryKey(cszRegistryKey);
    
    if( NULL == (BSTR)cbPerfIndex ||
        NULL == (BSTR)cbRegistryKey ){
        
        return ERROR_OUTOFMEMORY;
    }

    VariantInit (&vRegistryKey);
    // get the Qualifier Set for this class
    hRes = pClass->GetQualifierSet(&pClassQualifiers);
    if( NULL == pClassQualifiers ){
        return hRes;
    }
    
    // now get the library and procedure names
    hRes = pClassQualifiers->Get( cbRegistryKey, 0, &vRegistryKey, 0);
    if ((hRes == 0) && (vRegistryKey.vt == VT_BSTR)) {
        szRegistryKey = Macro_CloneLPWSTR(V_BSTR(&vRegistryKey));
        if (szRegistryKey == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            // now also get the perf index
            if (bCatalogQuery) {
                // then insert 0 for the perf index to indicate a "GLOBAL"
                // query
                dwPerfIndex = 0;
            } else {
                VariantClear (&vRegistryKey);
                hRes = pClassQualifiers->Get( cbPerfIndex, 0, &vRegistryKey, 0);
                if (hRes == 0) {
                    dwPerfIndex = (DWORD)V_UI4(&vRegistryKey);
                } else {
                    // unable to find NtPerfLibrary entry
                    dwReturn = ERROR_FILE_NOT_FOUND;
                }
            }
        }
    } else {
        // unable to find NtPerfLibrary entry
        dwReturn = ERROR_FILE_NOT_FOUND;
    }

    if (pClassQualifiers != NULL) pClassQualifiers->Release();

    if (dwReturn == ERROR_SUCCESS) {
        // find matching library in the array
        dwEnd = m_aLibraries.Size();
        if (dwEnd > 0) {
            // walk down the list of libraries
            for (dwIndex = 0; dwIndex < dwEnd; dwIndex++) {
                // see if this library entry is good enough to keep
                // The library is assumed to be a match if the 
                // lib. name and all proc's are the same.
                pThisLibEntry = (CPerfDataLibrary *)m_aLibraries[dwIndex];
                assert (pThisLibEntry != NULL); // it should have been removed!
                // make sure it's complete
                assert (pThisLibEntry->pLibInfo->szServiceName != NULL);

                if (lstrcmpiW (szRegistryKey, pThisLibEntry->pLibInfo->szServiceName) == 0) {
                    pLibEntry = pThisLibEntry;
                    break;
                } else {
                    // wrong library
                    // so continue
                }
            }
        }

        if (pLibEntry == NULL) {
            // add this class & it's library to the list
            dwReturn = AddLibrary   (pClass, pClassQualifiers, szRegistryKey, dwPerfIndex);
        } else {
            WCHAR   wszNewIndex[WBEMPERF_STRING_SIZE];
            pLibEntry->dwRefCount++;
            _ultow (dwPerfIndex, wszNewIndex, 10);
            if (!IsNumberInUnicodeList (dwPerfIndex, pLibEntry->szQueryString)) {
                // then add it to the list
                StringCchCatW(pLibEntry->szQueryString, 
                        MAX_PERF_OBJECTS_IN_QUERY_FUNCTION*10, cszSpace);
                StringCchCatW(pLibEntry->szQueryString, 
                        MAX_PERF_OBJECTS_IN_QUERY_FUNCTION*10, wszNewIndex);
            }
        }
    }

    if (szRegistryKey != NULL) delete szRegistryKey;
    VariantClear(&vRegistryKey);

    return dwReturn;
}

//***************************************************************************
//
//  CPerfObjectAccess::CollectData (LPBYTE pBuffer, 
//              LPDWORD pdwBufferSize, LPWSTR pszItemList)
//
//  Collects data from the perf objects and libraries added to the access 
//  object
//
//      Inputs:
//
//          pBuffer              -   pointer to start of data block
//                                  where data is being collected
//
//          pdwBufferSize        -   pointer to size of data buffer
//
//          pszItemList        -    string to pass to ext DLL
//
//      Outputs:
//
//          *lppDataDefinition  -   set to location for next Type
//                                  Definition if successful
//
//      Returns:
//
//          0 if successful, else Win 32 error code of failure
//
//
//***************************************************************************
//
DWORD   
CPerfObjectAccess::CollectData (LPBYTE pBuffer, LPDWORD pdwBufferSize, LPWSTR pszItemList)
{
    LPWSTR  lpValueName = NULL;
    LPBYTE  lpData = pBuffer;
    LPDWORD lpcbData = pdwBufferSize;
    LPVOID  lpDataDefinition = NULL;

    DWORD Win32Error=ERROR_SUCCESS;          //  Failure code
    DWORD BytesLeft;
    DWORD NumObjectTypes;

    LPVOID  lpExtDataBuffer = NULL;
    LPVOID  lpCallBuffer = NULL;
    LPVOID  lpLowGuardPage = NULL;
    LPVOID  lpHiGuardPage = NULL;
    LPVOID  lpEndPointer = NULL;
    LPVOID  lpBufferBefore = NULL;
    LPVOID  lpBufferAfter = NULL;
    LPDWORD lpCheckPointer;
    LARGE_INTEGER   liStartTime, liEndTime, liWaitTime;

    pExtObject  pThisExtObj = NULL;

    BOOL    bGuardPageOK;
    BOOL    bBufferOK;
    BOOL    bException;
    BOOL    bUseSafeBuffer;
    BOOL    bUnlockObjData = FALSE;

    LPWSTR  szMessageArray[8];
    DWORD   dwRawDataDwords[8];     // raw data buffer
    DWORD   dwDataIndex;
    WORD    wStringIndex;
    LONG    lReturnValue = ERROR_SUCCESS;

    LONG                lInstIndex;
    PERF_OBJECT_TYPE    *pObject, *pNextObject;
    PERF_INSTANCE_DEFINITION    *pInstance;
    PERF_DATA_BLOCK     *pPerfData;
    BOOL                bForeignDataBuffer;
    BOOL                bCheckThisService;

    DWORD           dwItemsInList = 0;

    DWORD           dwIndex, dwEntry;

    CPerfDataLibrary    *pThisLib;

    liStartTime.QuadPart = 0;
    liEndTime.QuadPart = 0;

    if (lExtCounterTestLevel < EXT_TEST_NOMEMALLOC) {
        bUseSafeBuffer = TRUE;
    } else {
        bUseSafeBuffer = FALSE;
    }

    if (lReturnValue == ERROR_SUCCESS) {

        if (*pdwBufferSize > (sizeof(PERF_DATA_BLOCK) *2)) {
            MonBuildPerfDataBlock(
                (PERF_DATA_BLOCK *)pBuffer,
                &lpDataDefinition,
                0,0);
            dwItemsInList = m_aLibraries.Size();
        } else {
            lReturnValue = ERROR_MORE_DATA;
            dwItemsInList = 0;
        }


        if (dwItemsInList > 0) {
            for (dwEntry = 0; dwEntry < dwItemsInList; dwEntry++) {
                pThisLib = (CPerfDataLibrary *)m_aLibraries[dwEntry];
                assert (pThisLib != NULL);

                bCheckThisService = FALSE;
                pThisExtObj = pThisLib->pLibInfo;
                if (pszItemList == NULL) {
                    // use the one for this library
                    lpValueName = pThisLib->szQueryString;
                } else {
                    // use the one passed by the caller
                    lpValueName = pszItemList;
                }
                if (lpValueName == NULL) {
                    lpValueName = (LPWSTR) cszGlobal;
                }

                // convert timeout value
                liWaitTime.QuadPart = MakeTimeOutValue (pThisExtObj->dwCollectTimeout);

                // initialize values to pass to the extensible counter function
                NumObjectTypes = 0;
                BytesLeft = (DWORD) (*lpcbData - ((LPBYTE)lpDataDefinition - lpData));
                bException = FALSE;

                if (lstrcmpiW(lpValueName, cszGlobal) == 0 || lstrcmpiW(lpValueName, cszCostly) == 0) {
                    bCheckThisService = TRUE;
                }
                else {
                    LPWSTR szThisChar;
                    LPWSTR szThisObject = NULL;
                    DWORD  dwThisObject;
                    DWORD  dwIndex;

                    for (szThisChar = lpValueName; * szThisChar != L'\0'; szThisChar ++) {
                        if (* szThisChar == L' ') {
                            if (szThisObject == NULL) {
                                continue;
                            }
                            else {
                                * szThisChar = L'\0';
                                dwThisObject = wcstoul(szThisObject, NULL, 0);
                                szThisObject = NULL;
                                * szThisChar = L' ';

                                for (dwIndex = 0; dwIndex < pThisExtObj->dwNumObjects; dwIndex ++) {
                                    if (pThisExtObj->dwObjList[dwIndex] == dwThisObject) {
                                        bCheckThisService = TRUE;
                                        break;
                                    }
                                }

                                if (! bCheckThisService) {
                                    if (dwThisObject >= pThisExtObj->dwFirstCounter
                                                    && dwThisObject <= pThisExtObj->dwLastCounter) {
                                        bCheckThisService = TRUE;
                                    }
                                }
                                if (bCheckThisService) break;
                            }
                        }
                        else if (szThisObject == NULL) {
                            szThisObject = szThisChar;
                        }
                    }
                    if (! bCheckThisService && szThisObject != NULL) {
                        dwThisObject = wcstoul(szThisObject, NULL, 0);
                        szThisObject = NULL;

                        for (dwIndex = 0; dwIndex < pThisExtObj->dwNumObjects; dwIndex ++) {
                            if (pThisExtObj->dwObjList[dwIndex] == dwThisObject) {
                                bCheckThisService = TRUE;
                                break;
                            }
                        }

                        if (! bCheckThisService) {
                            if (dwThisObject >= pThisExtObj->dwFirstCounter
                                            && dwThisObject <= pThisExtObj->dwLastCounter) {
                                bCheckThisService = TRUE;
                            }
                        }
                    }
                }

                if (! bCheckThisService) continue;

                if (pThisExtObj->hLibrary == NULL) {
                    // lock library object
                    if (pThisExtObj->hMutex != NULL) {
                        Win32Error =  WaitForSingleObject (
                            pThisExtObj->hMutex,
                            pThisExtObj->dwCollectTimeout);
                        if (Win32Error != WAIT_TIMEOUT) {
                            Win32Error = ERROR_INVALID_ACCESS;
                            // if necessary, open the library
                            if (pThisExtObj->hLibrary == NULL) {
                                // make sure the library is open
                                if( pThisExtObj->dwOpenFail == 0 &&
                                    GetCurrentThreadId() != pThisExtObj->ADThreadId ){
                                    Win32Error = OpenExtObjectLibrary(pThisExtObj);
                                }
                            }
                            
                            ReleaseMutex (pThisExtObj->hMutex);

                            if( ERROR_SUCCESS != Win32Error ){
                                // assume error has been posted
                                continue;
                            }
                        } else {
                            pThisExtObj->dwLockoutCount++;
                        }
                    } else {
                        Win32Error = ERROR_LOCK_FAILED;
                    }
                } else {
                    // library should be ready to use
                }

                // allocate a local block of memory to pass to the
                // extensible counter function.

                if (bUseSafeBuffer) {
                    lpExtDataBuffer = ALLOCMEM (m_hObjectHeap,
                        HEAP_ZERO_MEMORY, BytesLeft + (2*GUARD_PAGE_SIZE));
                } else {
                    lpExtDataBuffer =
                        lpCallBuffer = lpDataDefinition;
                }

                if (lpExtDataBuffer != NULL) {

                    if (bUseSafeBuffer) {
                        // set buffer pointers
                        lpLowGuardPage = lpExtDataBuffer;
                        lpCallBuffer = (LPBYTE)lpExtDataBuffer + GUARD_PAGE_SIZE;
                        lpHiGuardPage = (LPBYTE)lpCallBuffer + BytesLeft;
                        lpEndPointer = (LPBYTE)lpHiGuardPage + GUARD_PAGE_SIZE;
                        lpBufferBefore = lpCallBuffer;
                        lpBufferAfter = NULL;

                        // initialize GuardPage Data

                        memset (lpLowGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
                        memset (lpHiGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
                    }

                    __try {
                        //
                        //  Collect data from extesible objects
                        //

                        bUnlockObjData = FALSE;
                        if (pThisExtObj->hMutex != NULL) {
                            Win32Error =  WaitForSingleObject (
                                pThisExtObj->hMutex,
                                pThisExtObj->dwCollectTimeout);
                            if ( Win32Error != WAIT_TIMEOUT ){
                                if( pThisExtObj->CollectProc != NULL) {
                                    bUnlockObjData = TRUE;

                                    QueryPerformanceCounter (&liStartTime);

                                    Win32Error =  (*pThisExtObj->CollectProc) (
                                        lpValueName,
                                        &lpCallBuffer,
                                        &BytesLeft,
                                        &NumObjectTypes);

                                    QueryPerformanceCounter (&liEndTime);

                                    pThisExtObj->llLastUsedTime = GetTimeAsLongLong();
                                }
                                ReleaseMutex (pThisExtObj->hMutex);
                                bUnlockObjData = FALSE;
                            } else {
                                pThisExtObj->dwLockoutCount++;
                            }
                        } else {
                            Win32Error = ERROR_LOCK_FAILED;
                        }

                        if ((Win32Error == ERROR_SUCCESS) && (BytesLeft > 0)) {
                            // increment perf counters
                            InterlockedIncrement ((LONG *)&pThisExtObj->dwCollectCount);
                            pThisExtObj->llElapsedTime +=
                                liEndTime.QuadPart - liStartTime.QuadPart;

                            if (bUseSafeBuffer) {
                                // a data buffer was returned and
                                // the function returned OK so see how things
                                // turned out...
                                //
                                lpBufferAfter = lpCallBuffer;
                                //
                                // check for buffer corruption here
                                //
                                bBufferOK = TRUE; // assume it's ok until a check fails
                                //
                                if (lExtCounterTestLevel <= EXT_TEST_BASIC) {
                                    //
                                    //  check 1: bytes left should be the same as
                                    //      new data buffer ptr - orig data buffer ptr
                                    //
                                    if (BytesLeft != (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore)) {
                                        if (lEventLogLevel >= LOG_DEBUG) {
                                            // issue WARNING, that bytes left param is incorrect
                                            // load data for eventlog message
                                            // since this error is correctable (though with
                                            // some risk) this won't be reported at LOG_USER
                                            // level
                                            dwDataIndex = wStringIndex = 0;
                                            dwRawDataDwords[dwDataIndex++] = BytesLeft;
                                            dwRawDataDwords[dwDataIndex++] =
                                                (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore);
                                            szMessageArray[wStringIndex++] =
                                                pThisExtObj->szServiceName;
                                            szMessageArray[wStringIndex++] =
                                                pThisExtObj->szLibraryName;
                                            ReportEventW (hEventLog,
                                                EVENTLOG_WARNING_TYPE,      // error type
                                                0,                          // category (not used)
                                                (DWORD)WBEMPERF_BUFFER_POINTER_MISMATCH,   // event,
                                                NULL,                       // SID (not used),
                                                wStringIndex,              // number of strings
                                                dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                (LPCWSTR *)szMessageArray,                // message text array
                                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                                        }
                                        // we'll keep the buffer, since the returned bytes left
                                        // value is ignored anyway, in order to make the
                                        // rest of this function work, we'll fix it here
                                        BytesLeft = (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore);
                                    }
                                    //
                                    //  check 2: buffer after ptr should be < hi Guard page ptr
                                    //
                                    if (((LPBYTE)lpBufferAfter >= (LPBYTE)lpHiGuardPage) && bBufferOK) {
                                        // see if they exceeded the allocated memory
                                        if ((LPBYTE)lpBufferAfter >= (LPBYTE)lpEndPointer) {
                                            // this is very serious since they've probably trashed
                                            // the heap by overwriting the heap sig. block
                                            // issue ERROR, buffer overrun
                                            if (lEventLogLevel >= LOG_USER) {
                                                // load data for eventlog message
                                                dwDataIndex = wStringIndex = 0;
                                                dwRawDataDwords[dwDataIndex++] =
                                                    (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpHiGuardPage);
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szLibraryName;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szServiceName;
                                                ReportEventW (hEventLog,
                                                    EVENTLOG_ERROR_TYPE,        // error type
                                                    0,                          // category (not used)
                                                    (DWORD)WBEMPERF_HEAP_ERROR,  // event,
                                                    NULL,                       // SID (not used),
                                                    wStringIndex,               // number of strings
                                                    dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                    (LPCWSTR *)szMessageArray,             // message text array
                                                    (LPVOID)&dwRawDataDwords[0]);           // raw data
                                            }
                                        } else {
                                            // issue ERROR, buffer overrun
                                            if (lEventLogLevel >= LOG_USER) {
                                                // load data for eventlog message
                                                dwDataIndex = wStringIndex = 0;
                                                dwRawDataDwords[dwDataIndex++] =
                                                    (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpHiGuardPage);
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szLibraryName;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szServiceName;
                                                ReportEventW (hEventLog,
                                                    EVENTLOG_ERROR_TYPE,        // error type
                                                    0,                          // category (not used)
                                                    (DWORD)WBEMPERF_BUFFER_OVERFLOW,     // event,
                                                    NULL,                       // SID (not used),
                                                    wStringIndex,              // number of strings
                                                    dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                    (LPCWSTR *)szMessageArray,                // message text array
                                                    (LPVOID)&dwRawDataDwords[0]);           // raw data
                                            }
                                        }
                                        bBufferOK = FALSE;
                                        // since the DLL overran the buffer, the buffer
                                        // must be too small (no comments about the DLL
                                        // will be made here) so the status will be
                                        // changed to ERROR_MORE_DATA and the function
                                        // will return.
                                        Win32Error = ERROR_MORE_DATA;
                                    }
                                    //
                                    //  check 3: check lo guard page for corruption
                                    //
                                    if (bBufferOK) {
                                        bGuardPageOK = TRUE;
                                        for (lpCheckPointer = (LPDWORD)lpLowGuardPage;
                                                lpCheckPointer < (LPDWORD)lpBufferBefore;
                                            lpCheckPointer++) {
                                            if (*lpCheckPointer != GUARD_PAGE_DWORD) {
                                                bGuardPageOK = FALSE;
                                                    break;
                                            }
                                        }
                                        if (!bGuardPageOK) {
                                            // issue ERROR, Lo Guard Page corrupted
                                            if (lEventLogLevel >= LOG_USER) {
                                                // load data for eventlog message
                                                dwDataIndex = wStringIndex = 0;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szLibraryName;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szServiceName;
                                                ReportEventW (hEventLog,
                                                    EVENTLOG_ERROR_TYPE,        // error type
                                                    0,                          // category (not used)
                                                    (DWORD)WBEMPERF_GUARD_PAGE_VIOLATION, // event
                                                    NULL,                       // SID (not used),
                                                    wStringIndex,              // number of strings
                                                    dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                    (LPCWSTR *)szMessageArray,                // message text array
                                                    (LPVOID)&dwRawDataDwords[0]);           // raw data
                                            }
                                            bBufferOK = FALSE;
                                        }
                                    }
                                    //
                                    //  check 4: check hi guard page for corruption
                                    //
                                    if (bBufferOK) {
                                        bGuardPageOK = TRUE;
                                        for (lpCheckPointer = (LPDWORD)lpHiGuardPage;
                                            lpCheckPointer < (LPDWORD)lpEndPointer;
                                            lpCheckPointer++) {
                                                if (*lpCheckPointer != GUARD_PAGE_DWORD) {
                                                    bGuardPageOK = FALSE;
                                                break;
                                            }
                                        }
                                        if (!bGuardPageOK) {
                                            // issue ERROR, Hi Guard Page corrupted
                                            if (lEventLogLevel >= LOG_USER) {
                                                // load data for eventlog message
                                                dwDataIndex = wStringIndex = 0;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szLibraryName;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szServiceName;
                                                ReportEventW (hEventLog,
                                                    EVENTLOG_ERROR_TYPE,        // error type
                                                    0,                          // category (not used)
                                                    (DWORD)WBEMPERF_GUARD_PAGE_VIOLATION, // event,
                                                    NULL,                       // SID (not used),
                                                    wStringIndex,              // number of strings
                                                    dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                    (LPCWSTR *)szMessageArray,                // message text array
                                                    (LPVOID)&dwRawDataDwords[0]);           // raw data
                                            }

                                            bBufferOK = FALSE;
                                        }
                                    }
                                    //
                                    if ((lExtCounterTestLevel <= EXT_TEST_ALL) && bBufferOK) {
                                        //
                                        //  Internal consistency checks
                                        //
                                        //
                                        //  Check 5: Check object length field values
                                        //
                                        // first test to see if this is a foreign
                                        // computer data block or not
                                        //
                                        pPerfData = (PERF_DATA_BLOCK *)lpBufferBefore;
                                        if ((pPerfData->Signature[0] == (WCHAR)'P') &&
                                            (pPerfData->Signature[1] == (WCHAR)'E') &&
                                            (pPerfData->Signature[2] == (WCHAR)'R') &&
                                            (pPerfData->Signature[3] == (WCHAR)'F')) {
                                            // if this is a foreign computer data block, then the
                                            // first object is after the header
                                            pObject = (PERF_OBJECT_TYPE *) (
                                                (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                            bForeignDataBuffer = TRUE;
                                        } else {
                                            // otherwise, if this is just a buffer from
                                            // an extensible counter, the object starts
                                            // at the beginning of the buffer
                                            pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                            bForeignDataBuffer = FALSE;
                                        }
                                        // go to where the pointers say the end of the
                                        // buffer is and then see if it's where it
                                        // should be
                                        for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                            pObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                                pObject->TotalByteLength);
                                        }
                                        if ((LPBYTE)pObject != (LPBYTE)lpCallBuffer) {
                                            // then a length field is incorrect. This is FATAL
                                            // since it can corrupt the rest of the buffer
                                            // and render the buffer unusable.
                                            if (lEventLogLevel >= LOG_USER) {
                                                // load data for eventlog message
                                                dwDataIndex = wStringIndex = 0;
                                                dwRawDataDwords[dwDataIndex++] = NumObjectTypes;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szLibraryName;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szServiceName;
                                                ReportEventW (hEventLog,
                                                    EVENTLOG_ERROR_TYPE,        // error type
                                                    0,                          // category (not used)
                                                    (DWORD)WBEMPERF_INCORRECT_OBJECT_LENGTH, // event,
                                                    NULL,                       // SID (not used),
                                                    wStringIndex,               // number of strings
                                                    dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                    (LPCWSTR *)szMessageArray,             // message text array
                                                    (LPVOID)&dwRawDataDwords[0]); // raw data
                                            }
                                            bBufferOK = FALSE;
                                        }
                                        //
                                        //  Test 6: Test instance field size values
                                        //
                                        if (bBufferOK) {
                                            // set object pointer
                                            if (bForeignDataBuffer) {
                                                pObject = (PERF_OBJECT_TYPE *) (
                                                    (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                            } else {
                                                // otherwise, if this is just a buffer from
                                                // an extensible counter, the object starts
                                                // at the beginning of the buffer
                                                pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                            }

                                            for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                                pNextObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                                    pObject->TotalByteLength);

                                                if (pObject->NumInstances != PERF_NO_INSTANCES) {
                                                    pInstance = (PERF_INSTANCE_DEFINITION *)
                                                        ((LPBYTE)pObject + pObject->DefinitionLength);
                                                    lInstIndex = 0;
                                                    while (lInstIndex < pObject->NumInstances) {
                                                        PERF_COUNTER_BLOCK *pCounterBlock;

                                                        pCounterBlock = (PERF_COUNTER_BLOCK *)
                                                            ((PCHAR) pInstance + pInstance->ByteLength);

                                                        pInstance = (PERF_INSTANCE_DEFINITION *)
                                                            ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);

                                                        lInstIndex++;
                                                    }
                                                    if ((LPBYTE)pInstance > (LPBYTE)pNextObject) {
                                                        bBufferOK = FALSE;
                                                    }
                                                }

                                                if (!bBufferOK) {
                                                    break;
                                                } else {
                                                    pObject = pNextObject;
                                                }
                                            }

                                            if (!bBufferOK) {
                                                if (lEventLogLevel >= LOG_USER) {
                                                    // load data for eventlog message
                                                    dwDataIndex = wStringIndex = 0;
                                                    dwRawDataDwords[dwDataIndex++] = pObject->ObjectNameTitleIndex;
                                                    szMessageArray[wStringIndex++] =
                                                        pThisExtObj->szLibraryName;
                                                    szMessageArray[wStringIndex++] =
                                                        pThisExtObj->szServiceName;
                                                    ReportEventW (hEventLog,
                                                        EVENTLOG_ERROR_TYPE,        // error type
                                                        0,                          // category (not used)
                                                        (DWORD)WBEMPERF_INCORRECT_INSTANCE_LENGTH, // event,
                                                        NULL,                       // SID (not used),
                                                        wStringIndex,              // number of strings
                                                        dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                        (LPCWSTR *)szMessageArray,                // message text array
                                                        (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                }
                                            }
                                        }
                                    }
                                }
                                //
                                // if all the tests pass,then copy the data to the
                                // original buffer and update the pointers
                                if (bBufferOK) {
                                    RtlMoveMemory (lpDataDefinition,
                                        lpBufferBefore,
                                        BytesLeft); // returned buffer size
                                } else {
                                    NumObjectTypes = 0; // since this buffer was tossed
                                    BytesLeft = 0; // reset the size value since the buffer wasn't used
                                }
                            } else {
                                // function already copied data to caller's buffer
                                // so no further action is necessary
                            }
                            lpDataDefinition = (LPVOID)((LPBYTE)(lpDataDefinition) + BytesLeft);    // update data pointer
                        } else {
                            if (Win32Error != ERROR_SUCCESS) {
                                InterlockedIncrement ((LONG *)&pThisExtObj->dwErrorCount);
                            }
                            if (bUnlockObjData) {
                                ReleaseMutex (pThisExtObj->hMutex);
                            }

                            NumObjectTypes = 0; // clear counter
                        }// end if function returned successfully

                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        Win32Error = GetExceptionCode();
                        InterlockedIncrement ((LONG *)&pThisExtObj->dwErrorCount);
                        bException = TRUE;
                        if (bUnlockObjData) {
                            ReleaseMutex (pThisExtObj->hMutex);
                            bUnlockObjData = FALSE;
                        }
                    }
                    if (bUseSafeBuffer) {
                        FREEMEM (m_hObjectHeap, 0, lpExtDataBuffer);
                    }
                } else {
                    // unable to allocate memory so set error value
                    Win32Error = ERROR_OUTOFMEMORY;
                } // end if temp buffer allocated successfully
                //
                //  Update the count of the number of object types
                //
                ((PPERF_DATA_BLOCK) lpData)->NumObjectTypes += NumObjectTypes;

                if ( Win32Error != ERROR_SUCCESS) {
                    if (bException ||
                        !((Win32Error == ERROR_MORE_DATA) ||
                          (Win32Error == WAIT_TIMEOUT))) {
                        // inform on exceptions & illegal error status only
                        if (lEventLogLevel >= LOG_USER) {
                            // load data for eventlog message
                            dwDataIndex = wStringIndex = 0;
                            dwRawDataDwords[dwDataIndex++] = Win32Error;
                            szMessageArray[wStringIndex++] =
                                pThisExtObj->szServiceName;
                            szMessageArray[wStringIndex++] =
                                pThisExtObj->szLibraryName;
                            ReportEventW (hEventLog,
                                EVENTLOG_ERROR_TYPE,        // error type
                                0,                          // category (not used)
                                (DWORD)WBEMPERF_COLLECT_PROC_EXCEPTION,   // event,
                                NULL,                       // SID (not used),
                                wStringIndex,              // number of strings
                                dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                (LPCWSTR *)szMessageArray,                // message text array
                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                        } else {
                            // don't report
                        }
                    }
                    // the ext. dll is only supposed to return:
                    //  ERROR_SUCCESS even if it encountered a problem, OR
                    //  ERROR_MODE_DATA if the buffer was too small.
                    // if it's ERROR_MORE_DATA, then break and return the
                    // error now, since it'll just be returned again and again.
                    if (Win32Error == ERROR_MORE_DATA) {
                        lReturnValue = Win32Error;
                        break;
                    }
                }
            } // end for each object
        } // else an error occurred so unable to call functions
        ((PPERF_DATA_BLOCK) lpData)->TotalByteLength = (DWORD)
            ((LPBYTE)lpDataDefinition - (LPBYTE)lpData);    
    }

    return lReturnValue;
}

//***************************************************************************
//
//  CPerfObjectAccess::RemoveClass(IWbemClassObject *pClass)
//
//  removes the class from the access object
//
//***************************************************************************
//
DWORD   
CPerfObjectAccess::RemoveClass(IWbemClassObject *pClass)
{
    CPerfDataLibrary *pLibEntry = NULL;
    CPerfDataLibrary *pThisLibEntry = NULL;
    DWORD           dwIndex = 0;
    DWORD            dwEnd;
    LPWSTR          szRegistryKey = NULL;
    IWbemQualifierSet   *pClassQualifiers = NULL;
    VARIANT         vRegistryKey;
    HRESULT         hRes;
    DWORD           dwReturn = ERROR_SUCCESS;
    DWORD           dwPerfIndex;
    CBSTR           cbPerfIndex(cszPerfIndex);
    CBSTR           cbRegistryKey(cszRegistryKey);
    
    if( NULL == (BSTR)cbPerfIndex ||
        NULL == (BSTR)cbRegistryKey ){
        
        return ERROR_OUTOFMEMORY;
    }

    VariantInit (&vRegistryKey);
    // get the Qualifier Set for this class
    hRes = pClass->GetQualifierSet(&pClassQualifiers);
    if( hRes == 0){
        // now get the library and procedure names
        hRes = pClassQualifiers->Get( cbRegistryKey, 0, &vRegistryKey, 0);
        if ((hRes == 0) && (vRegistryKey.vt == VT_BSTR)) {
            szRegistryKey = Macro_CloneLPWSTR(V_BSTR(&vRegistryKey));
            if (szRegistryKey == NULL) {
                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                // now also get the perf index
                VariantClear (&vRegistryKey);
                hRes = pClassQualifiers->Get( cbPerfIndex, 0, &vRegistryKey, 0);
                if (hRes == 0) {
                    dwPerfIndex = (DWORD)V_UI4(&vRegistryKey);
                } else {
                    // unable to find NtPerfLibrary entry
                    dwReturn = ERROR_FILE_NOT_FOUND;
                }
            }
        } else {
            // unable to find NtPerfLibrary entry
            dwReturn = ERROR_FILE_NOT_FOUND;
        }

        if (pClassQualifiers != NULL) pClassQualifiers->Release();

        if (dwReturn == ERROR_SUCCESS) {
            // find matching library in the array
            dwEnd = m_aLibraries.Size();
            if (dwEnd > 0) {
                // walk down the list of libraries
                for (dwIndex = 0; dwIndex < dwEnd; dwIndex++) {
                    // see if this library entry is good enough to keep
                    // The library is assumed to be a match if the 
                    // lib. name and all proc's are the same.
                    pThisLibEntry = (CPerfDataLibrary *)m_aLibraries[dwIndex];
                    assert (pThisLibEntry != NULL); // it should have been removed!
                    // make sure it's complete
                    assert (pThisLibEntry->pLibInfo->szServiceName != NULL);

                    if (lstrcmpiW (szRegistryKey, pThisLibEntry->pLibInfo->szServiceName) == 0) {
                        pLibEntry = pThisLibEntry;
                        break;
                    } else {
                        // wrong library
                        // so continue
                    }
                }
            }

            if (pLibEntry != NULL) {
                // close this class & it's library 
                dwReturn = CloseLibrary(pLibEntry);
                if (dwReturn == 0) {
                    // then no one wants it
                    FREEMEM(m_hObjectHeap, 0, pLibEntry->pLibInfo);
                    pLibEntry->pLibInfo = NULL;
                    m_aLibraries.RemoveAt(dwIndex);
                    m_aLibraries.Compress();
                    delete pLibEntry;
                }
                dwReturn = ERROR_SUCCESS;
            } else {
                dwReturn = ERROR_FILE_NOT_FOUND;
            }
        }

        if (szRegistryKey != NULL) delete szRegistryKey;
        VariantClear(&vRegistryKey);
    }
    return dwReturn;
}

BOOL
CPerfObjectAccess::CheckClassExist(LPWSTR wszClassName, IWbemClassObject * pClass)
{
    BOOL                bExist           = TRUE;
    HRESULT             hRes             = S_OK;
    IWbemQualifierSet * pClassQualifiers = NULL;
    SYSTEMTIME          LocalTime;
    VARIANT             vRegistry;
    LPWSTR              szRegistry       = NULL;
    LPWSTR              szKey            = NULL;
    DWORD               dwKey;
    DWORD               dwType;
    DWORD               dwSize;
    DWORD               Status;
    HKEY                hKey             = NULL;

    ZeroMemory(& LocalTime, sizeof(SYSTEMTIME));
    GetLocalTime(& LocalTime);

    hRes = pClass->GetQualifierSet(& pClassQualifiers);
    if (hRes != S_OK || pClassQualifiers == NULL) {
        bExist = FALSE;
        goto Cleanup;
    }

    hRes = pClassQualifiers->Get(CBSTR(cszRegistryKey), 0, & vRegistry, 0);
    if (hRes != S_OK || vRegistry.vt != VT_BSTR) {
        bExist = FALSE;
        goto Cleanup;
    }

    dwKey = lstrlenW(V_BSTR(& vRegistry)) + 1;
    szRegistry = (LPWSTR) ALLOCMEM(m_hObjectHeap, HEAP_ZERO_MEMORY, sizeof(WCHAR) * dwKey);
    if (szRegistry != NULL) {
        StringCchCopyW(szRegistry, dwKey, V_BSTR(& vRegistry));
        VariantClear(& vRegistry);
    }
    else {
        VariantClear(& vRegistry);
        goto Cleanup;
    }

    dwKey = lstrlenW(cszHklmServicesKey) + 1 + lstrlenW(szRegistry) + lstrlenW(cszPerformance) + 1;
    szKey = (LPWSTR) ALLOCMEM(m_hObjectHeap, HEAP_ZERO_MEMORY, dwKey * sizeof(WCHAR));
    if (szKey == NULL) {
        goto Cleanup;
    }
    StringCchPrintfW(szKey, dwKey, L"%ws\\%ws%ws", cszHklmServicesKey, szRegistry, cszPerformance);

    Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, & hKey);
    if (Status != ERROR_SUCCESS || hKey == NULL || hKey == INVALID_HANDLE_VALUE) {
        bExist = FALSE;
        goto Cleanup;
    }

    dwType = 0;
    dwSize = sizeof(dwKey);
    Status = RegQueryValueExW(hKey, cszFirstCounter, NULL, & dwType, (LPBYTE) & dwKey, & dwSize);
    if (Status != ERROR_SUCCESS || dwType != REG_DWORD) {
        bExist = FALSE;
        goto Cleanup;
    }

    dwType = 0;
    dwSize = sizeof(dwKey);
    Status = RegQueryValueExW(hKey, cszLastCounter, NULL, & dwType, (LPBYTE) & dwKey, & dwSize);
    if (Status != ERROR_SUCCESS || dwType != REG_DWORD) {
        bExist = FALSE;
        goto Cleanup;
    }

Cleanup:
    if (pClassQualifiers != NULL) pClassQualifiers->Release();
    if (szRegistry != NULL) FREEMEM(m_hObjectHeap, 0, szRegistry);
    if (szKey != NULL)      FREEMEM(m_hObjectHeap, 0, szKey);
    if (hKey != NULL && hKey != INVALID_HANDLE_VALUE) RegCloseKey(hKey);
    return bExist;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\perfhelp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    perfhelp.h

Abstract:

    <abstract>

--*/

#ifndef _PERFHELP_H_
#define _PERFHELP_H_

#include <winperf.h>

__inline 
PERF_OBJECT_TYPE *
FirstObject(IN PERF_DATA_BLOCK * pPerfData)
{
    PERF_OBJECT_TYPE *  pReturn;
    LPBYTE              pEndOfBuffer;

    pReturn = (PPERF_OBJECT_TYPE)((PBYTE)(pPerfData) + (pPerfData)->HeaderLength);
    pEndOfBuffer = (LPBYTE)((LPBYTE)pPerfData + pPerfData->TotalByteLength);

    if ((LPBYTE)pReturn >= pEndOfBuffer) pReturn = NULL;

    return (pReturn);
}

#define NextObject(pObject) \
    (PPERF_OBJECT_TYPE)((pObject)->TotalByteLength != 0 ? (PPERF_OBJECT_TYPE)((PBYTE)(pObject) + (pObject)->TotalByteLength) : NULL)

#define FirstInstance(pObjectDef) \
    (PERF_INSTANCE_DEFINITION *)((PCHAR) pObjectDef + pObjectDef->DefinitionLength)

// the return of this macro must be cast to the correct type of pointer by the caller
#define EndOfObject(pObjectDef) \
    ((PCHAR) pObjectDef + pObjectDef->TotalByteLength)

__inline
PERF_INSTANCE_DEFINITION *
NextInstance(
    IN  PERF_INSTANCE_DEFINITION *pInstDef
)
{
    PERF_COUNTER_BLOCK *pCounterBlock;
    pCounterBlock = (PERF_COUNTER_BLOCK *)
                        ((PCHAR) pInstDef + pInstDef->ByteLength);
    return (PERF_INSTANCE_DEFINITION *)
               ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
}

#define PERF_TIMER_TYPE_FIELD	\
	(PERF_TIMER_TICK | PERF_TIMER_100NS | PERF_OBJECT_TIMER)

class PerfHelper
{
    static void GetInstances(
        LPBYTE pBuf,
        CClassMapInfo *pClassMap,
        IWbemObjectSink *pSink
        );

    static void RefreshInstances(
        LPBYTE pBuf,
        CNt5Refresher *pRef
        );

	static PERF_INSTANCE_DEFINITION * GetInstanceByName(
		PERF_DATA_BLOCK *pDataBlock,
		PERF_OBJECT_TYPE *pObjectDef,
		LPWSTR pInstanceName,
		LPWSTR pParentName,
		DWORD   dwIndex);

	static PERF_INSTANCE_DEFINITION * GetInstanceByNameUsingParentTitleIndex(
		PERF_DATA_BLOCK *pDataBlock,
		PERF_OBJECT_TYPE *pObjectDef,
		LPWSTR pInstanceName,
		LPWSTR pParentName,
		DWORD  dwIndex);

	static DWORD GetInstanceNameStr (
		PPERF_INSTANCE_DEFINITION pInstance,
        LPWSTR lpszInstance,
        size_t cchBufferSize,
        DWORD dwCodePage);

	static DWORD GetUnicodeInstanceName (
		PPERF_INSTANCE_DEFINITION pInstance,
        LPWSTR lpszInstance, size_t cchBufferSize );

	static 	LPWSTR GetInstanceName(PPERF_INSTANCE_DEFINITION  pInstDef)
		{
			return (LPWSTR) ((PCHAR) pInstDef + pInstDef->NameOffset);
		}

	static DWORD GetAnsiInstanceName (
		PPERF_INSTANCE_DEFINITION pInstance,
        LPWSTR lpszInstance,
        size_t cchBufferSize,
        DWORD dwCodePage);

	static PERF_INSTANCE_DEFINITION * GetInstanceByUniqueId (
		PERF_OBJECT_TYPE *pObjectDef,
		LONG InstanceUniqueId);

	static PERF_INSTANCE_DEFINITION * GetInstance(
		PERF_OBJECT_TYPE *pObjectDef,
		LONG InstanceNumber);

	static PERF_OBJECT_TYPE * GetObjectDefByName (
		PERF_DATA_BLOCK *pDataBlock,
		DWORD           dwLastNameIndex,
		LPCWSTR         *NameArray,
		LPCWSTR         szObjectName);

	static PERF_OBJECT_TYPE * GetObjectDefByTitleIndex (
		PERF_DATA_BLOCK *pDataBlock,
		DWORD ObjectTypeTitleIndex);

	static BOOL PerfHelper::IsMatchingInstance (
			PERF_INSTANCE_DEFINITION	*pInstanceDef, 
			DWORD						dwCodePage,
			LPWSTR						szInstanceNameToMatch,
			DWORD						dwInstanceNameLength);

	static void RefreshEnumeratorInstances (
		IN	RefresherCacheEl            *pThisCacheEl, 
		IN	PERF_DATA_BLOCK				*PerfData,
		IN  PERF_OBJECT_TYPE			*PerfObj);
public:
	static BOOL ParseInstanceName (
		LPCWSTR szInstanceString,
		LPWSTR  szInstanceName,
		size_t  cchInstanceName,
		LPWSTR  szParentName,
		size_t  cchParentName,
		LPDWORD lpIndex);

	static DWORD GetFullInstanceNameStr (
		PERF_DATA_BLOCK             *pPerfData,
		PERF_OBJECT_TYPE            *pObjectDef,
		PERF_INSTANCE_DEFINITION    *pInstanceDef,
		LPWSTR                      szInstanceName,
		size_t						cchInstanceName );

    static BOOL QueryInstances(
		CPerfObjectAccess *pPerfObj,
        CClassMapInfo *pClassMap,
        IWbemObjectSink *pSink
        );

    static BOOL RefreshInstances(
        CNt5Refresher *pRef
        );

    static VOID UpdateTimers(
        CClassMapInfo     *pClassMap,
        IWbemObjectAccess *pInst,
        PPERF_DATA_BLOCK  PerfData,
		PPERF_OBJECT_TYPE  PerfObj
        );
};

__inline
LONG64
Assign64(
    IN PLARGE_INTEGER Unaligned
    )
{
    PLARGE_INTEGER pAligned;
    LONG64 llVal;

    pAligned = (PLARGE_INTEGER) &llVal;
    pAligned->LowPart = Unaligned->LowPart;
    pAligned->HighPart = Unaligned->HighPart;
    return llVal;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\refreshr.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    refreshr.h

Abstract:

    <abstract>

--*/

#ifndef _REFRESHR_H_
#define _REFRESHR_H_

#include "ntperf.h"
#include "perfacc.h"
#include "utils.h"

//***************************************************************************
//
//***************************************************************************

struct CachedInst
{
    LPWSTR              m_pName;         // Full Instance name
    IWbemObjectAccess   *m_pInst;         // Pointer to WBEM object
    LONG                m_lId;           // ID for this object
    LPWSTR              m_szParentName; // parsed parent name from full name
    LPWSTR              m_szInstanceName; // parsed instance name from full name
    DWORD               m_dwIndex;      // index parsed from full instance name
                
    CachedInst() {  m_pName = 0; 
                    m_pInst = 0; 
                    m_lId = 0;  
                    m_szParentName = 0; 
                    m_szInstanceName = 0; 
                    m_dwIndex = 0;
                }
    ~CachedInst() { if (m_pInst) m_pInst->Release(); 
                    if (m_pName) delete (m_pName);
                    if (m_szParentName) delete (m_szParentName);
                    if (m_szInstanceName) delete (m_szInstanceName);
                    }
};
  
typedef CachedInst *PCachedInst;

//***************************************************************************
//
//  RefresherCacheEl
//
//  Each CNt5Refresher has a cache of <RefresherCacheEl> elements.  There
//  is one RefresherCacheEl struct for each class of object in the refresher.
//
//  As each object is added to the refresher, we locate the corresponding
//  <RefresherCacheEl> for the class of the object.  We then add the
//  instance into the instance cache of the <RefresherCacheEl>. If there
//  is no RefresherCacheEl, we create one.
//
//  For singleton instances, we simply special case by having a dedicated
//  pointer.
//
//  For multi-instance counters, we use a binary search lookup.
//  
//***************************************************************************
// ok
struct RefresherCacheEl
{
    DWORD              m_dwPerfObjIx;       // Perf object index for Class Def
    CClassMapInfo     *m_pClassMap;         // WBEM Class def stuff
    IWbemObjectAccess *m_pSingleton;        // Optional Singleton instance
    LONG               m_lSingletonId;
    CFlexArray         m_aInstances;        // Instance list for non-singleton
                                            // of CachedInst pointers.
    CFlexArray         m_aEnumInstances;    // array of IWbemObjectAccess pointers
    LONG               *m_plIds;            // array of ID's
    LONG               m_lEnumArraySize;    // size of enum item array in elements
    IWbemHiPerfEnum    *m_pHiPerfEnum;      // interface for hi perf enumerator
    LONG               m_lEnumId;           // id of the enumerator

    RefresherCacheEl();
   ~RefresherCacheEl(); 
   
    IWbemObjectAccess *FindInst(LPWSTR pszName);  // Already scoped by class
    BOOL RemoveInst(LONG lId);
    BOOL InsertInst(IWbemObjectAccess **pp, LONG lNewId);
    // support for enumerator objects
    BOOL CreateEnum(IWbemHiPerfEnum *p, LONG lNewId);
    BOOL DeleteEnum(LONG lId);   
};

typedef RefresherCacheEl *PRefresherCacheEl;


// used by flags arg of AddObject Method
#define REFRESHER_ADD_OBJECT_ADD_ITEM   ((DWORD)0)
#define REFRESHER_ADD_OBJECT_ADD_ENUM   ((DWORD)0x00000001)

class CNt5Refresher : public IWbemRefresher
{
    HANDLE              m_hAccessMutex;
    LONG                m_lRef;
    LONG                m_lProbableId;
    CFlexArray          m_aCache;   
    CNt5PerfProvider    *m_pPerfProvider; // back pointer to provider if used

    DWORD       m_dwGetGetNextClassIndex;

    CNt5PerfProvider::enumCLSID m_ClsidType;

    friend  PerfHelper;
public:
    CNt5Refresher(CNt5PerfProvider *pPerfProvider = NULL);
   ~CNt5Refresher();

    CPerfObjectAccess   m_PerfObj;

    // Interface members.
    // ==================

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);

    // Primary WBEM method for updating.
    // =================================
    virtual HRESULT STDMETHODCALLTYPE Refresh(/* [in] */ long lFlags);

    // Private members used by NTPERF.CPP
    // ==================================
    
    BOOL AddObject(
        IN  IWbemObjectAccess **ppObj,    // Object to add
        IN  CClassMapInfo *pClsMap,     // Class of object
        OUT LONG *plId                  // The id of the object added
        );

    BOOL RemoveObject(LONG lId);

    BOOL AddEnum (
        IN  IWbemHiPerfEnum *pEnum,     // enum interface pointer
        IN  CClassMapInfo *pClsMap,     // Class of object
        OUT LONG    *plId               // id for new enum
        );

    CClassMapInfo * FindClassMap(
        DWORD dwObjectTitleIx
        );

    BOOL FindSingletonInst(
        IN  DWORD dwPerfObjIx,
        OUT IWbemObjectAccess **pInst,
        OUT CClassMapInfo **pClsMap
        );

    BOOL FindInst(
        IN  DWORD dwObjectClassIx,
        IN  LPWSTR pszInstName,
        OUT IWbemObjectAccess **pInst,
        OUT CClassMapInfo **pClsMap
        );

    BOOL GetObjectIds(DWORD *pdwNumIds, DWORD **pdwIdList); 
        // Use operator delete on returned <pdwIdList>

    LONG FindUnusedId();
        // Returns -1 on error or an unused id.

    PRefresherCacheEl GetCacheEl(CClassMapInfo *pClsMap);


    BOOL AddNewCacheEl(
        IN CClassMapInfo *pClsMap, 
        PRefresherCacheEl *pOutput
        );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\refreshr.cpp ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  REFRESHR.CPP
//  
//  Mapped NT5 Perf Counter Provider
//
//  raymcc      02-Dec-97   Created.        
//  raymcc      20-Feb-98   Updated to use new initializer.
//  bobw         8-Jub-98   optimized for use with NT Perf counters
//
//***************************************************************************

#include "wpheader.h"
#include <stdio.h>
#include "oahelp.inl"

// Timeout for our wait calls
#define REFRESHER_MUTEX_WAIT_TIMEOUT    10000

class CMutexReleaseMe
{
private:
    HANDLE    m_hMutex;

public:
    CMutexReleaseMe( HANDLE hMutex ) : m_hMutex( hMutex ) {};
    ~CMutexReleaseMe()    { if ( NULL != m_hMutex ) ReleaseMutex( m_hMutex ); };
};

//***************************************************************************
//
//  RefresherCacheEl::RefresherCacheEl
//
//  Constructor
//
//***************************************************************************
// ok
RefresherCacheEl::RefresherCacheEl()
{
    m_dwPerfObjIx = 0;
    m_pClassMap = NULL;
    m_pSingleton = NULL;    
    m_lSingletonId = 0;
    m_plIds = NULL;         // array of ID's
    m_lEnumArraySize = 0;   // size of ID array in elements
    m_pHiPerfEnum = NULL;
    m_lEnumId = 0;
}

//***************************************************************************
//
//  RefresherCacheEl::~RefresherCacheEl()
//
//  Destructor
//
//***************************************************************************
//  ok 
RefresherCacheEl::~RefresherCacheEl()
{
    LONG    nNumInstances;
    int i;

    delete m_pClassMap;

    if (m_pSingleton != NULL) {
        m_pSingleton->Release();
        m_pSingleton = NULL;
        m_lSingletonId = 0;
    }
        
    nNumInstances = m_aInstances.Size();
    for (i = 0; i < nNumInstances; i++) {
        delete (CachedInst *) m_aInstances[i];
    }

    nNumInstances = m_aEnumInstances.Size();
    if (nNumInstances> 0) {
        IWbemObjectAccess   *pAccess;
        for (i = 0;  i < nNumInstances ; i++) {
            pAccess = (IWbemObjectAccess *)(m_aEnumInstances.GetAt(i));
            if (pAccess != NULL) {
                pAccess->Release();
            }
        }
        m_aEnumInstances.Empty();
    }

    if (m_plIds != NULL) {
        delete (m_plIds);
        m_plIds = NULL;
        m_lEnumArraySize = 0;
    }

    if (m_pHiPerfEnum != NULL) {
        m_pHiPerfEnum->Release();
        m_pHiPerfEnum = NULL;
    }
}

//***************************************************************************
//
//  CNt5Refresher constructor
//
//***************************************************************************
// ok
CNt5Refresher::CNt5Refresher(CNt5PerfProvider *pPerfProviderArg)
{
    assert (pPerfProviderArg != NULL);

    m_ClsidType = pPerfProviderArg->m_OriginClsid;
    m_pPerfProvider = pPerfProviderArg;

    m_pPerfProvider = NULL; // for testing of local class map

    if (m_pPerfProvider != NULL) {
        m_pPerfProvider->AddRef();
    }
    m_hAccessMutex = CreateMutex (NULL, TRUE, NULL);
    m_dwGetGetNextClassIndex = 0;
    m_lRef = 0;             // COM Ref Count
    m_lProbableId = 1;      // Used for new IDs
    m_aCache.Empty();       // clear and reset the array
    RELEASE_MUTEX (m_hAccessMutex);
}

//***************************************************************************
//
//  CNt5Refresher destructor
//
//***************************************************************************
// ok
CNt5Refresher::~CNt5Refresher()
{
    int         nNumElements;
    int         i;

    PRefresherCacheEl pCacheEl;

    assert (m_lRef == 0);

    // Make sure we get access to the mutex before we try and clean things up.
    // If we don't get it in a reasonable time, something's up.  Since we're
    // destructing, we'll just quietly let stuff go.

    if ( WaitForSingleObject( m_hAccessMutex, REFRESHER_MUTEX_WAIT_TIMEOUT ) == WAIT_OBJECT_0 )
    {
        // This will auto-release the mutex in case something bad happens
        CMutexReleaseMe    mrm( m_hAccessMutex );

        nNumElements = m_aCache.Size();
        for (i = 0; i < nNumElements; i++) {
            pCacheEl = (PRefresherCacheEl)m_aCache[i];

            // We want to call this once for each instance
            for ( int n = 0; n < pCacheEl->m_aInstances.Size(); n++ )
            {
                m_PerfObj.RemoveClass (pCacheEl->m_pClassMap->m_pClassDef);
            }

            // If we have a Singleton value, RemoveClass should be
            // called once more
            if ( NULL != pCacheEl->m_pSingleton )
            {
                m_PerfObj.RemoveClass (pCacheEl->m_pClassMap->m_pClassDef);
            }

            // And finally if we have an enumerator, remove the class
            // once more.
            if ( NULL != pCacheEl->m_pHiPerfEnum )
            {
                m_PerfObj.RemoveClass (pCacheEl->m_pClassMap->m_pClassDef);
            }

            delete pCacheEl;
        }

        if (m_pPerfProvider != NULL) {
            m_pPerfProvider->Release();
            m_pPerfProvider = NULL;
        }
    }

    CloseHandle (m_hAccessMutex);
}

//***************************************************************************
//
//  CNt5Refresher::Refresh
//
//  Executed to refresh a set of instances bound to the particular 
//  refresher.
//
//***************************************************************************
// ok
HRESULT CNt5Refresher::Refresh(/* [in] */ long lFlags)
{
    HRESULT     hrReturn = WBEM_S_NO_ERROR;
    HRESULT     hReturn = S_OK;    
    BOOL        bRes;

    UNREFERENCED_PARAMETER(lFlags);

    BOOL bNeedCoImpersonate = FALSE;
    
    //
    // this is ugly
    // wmicookr is not impersonating, because
    // it relys on other provider to do that
    // but, it calls the IWbemRefresher::Refresh when it's inside winmgmt or wmiprvse
    // and it calls it from an UN-Impersonated thread
    // so, we need that the provider calls CoImpersonateClient
    // on a Refresh invocation, that is expensive in general,
    // only if the provider has been invoked through the Server CLSID
    //
    BOOL    fRevert;
    if (CNt5PerfProvider::CLSID_SERVER == m_ClsidType)
    {
        hReturn = CoImpersonateClient(); // make sure we're legit.

        fRevert = SUCCEEDED( hReturn );

        // The following error appears to occur when we are in-proc and there is no
        // proxy/stub, so we are effectively impersonating already

        if ( RPC_E_CALL_COMPLETE == hReturn ) {
            hReturn = S_OK;
        } 

        if (S_OK == hReturn) {
            hReturn = CNt5PerfProvider::CheckImpersonationLevel();
        }
        // Check Registry security here.
        if ((hReturn != S_OK) || (!CNt5PerfProvider::HasPermission())) {
            // if Impersonation level is incorrect or
            // the caller doesn't have permission to read
            // from the registry, then they cannot continue
            hReturn = WBEM_E_ACCESS_DENIED;
        }

    }

    if (hReturn == S_OK)
    {
        // Make sure we get access to the mutex before we continue.  If we can't
        // get to it, something's wrong, so we'll just assume we are busy.

        if ( WaitForSingleObject( m_hAccessMutex, REFRESHER_MUTEX_WAIT_TIMEOUT ) == WAIT_OBJECT_0 )
        {
            // This will auto-release the mutex in case something bad happens
            CMutexReleaseMe    mrm( m_hAccessMutex );

            bRes = PerfHelper::RefreshInstances(this);
            if (!bRes) {
                hrReturn = WBEM_E_FAILED;
            }
        }
        else
        {
            hrReturn = WBEM_E_REFRESHER_BUSY;
        }
    }

    if (CNt5PerfProvider::CLSID_SERVER == m_ClsidType)
    {
        // Revert if we successfuly impersonated the user
        if ( fRevert )
        {
            CoRevertToSelf();
        }
    }

    
    return hrReturn;
}

//***************************************************************************
//
//  CNt5Refresher::AddRef
//
//  Standard COM AddRef().
//
//***************************************************************************
// ok

ULONG CNt5Refresher::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CNt5Refresher::Release
//
//  Standard COM Release().
//
//***************************************************************************
// ok

ULONG CNt5Refresher::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CNt5Refresher::QueryInterface
//
//  Standard COM QueryInterface().
//
//***************************************************************************
// ok

HRESULT CNt5Refresher::QueryInterface(REFIID riid, void** ppv)
{
    if (riid == IID_IUnknown || riid == IID_IWbemRefresher)
    {
        *ppv = (IWbemRefresher *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

//***************************************************************************
//
//  CNt5Refresher::RemoveObject
//
//  Removes an object from the refresher.   Since we don't know
//  by ID alone which class it is, we loop through all the ones we 
//  have until somebody claims it and returns TRUE for a removal.(
//
//***************************************************************************
// ok
BOOL CNt5Refresher::RemoveObject(LONG lId)
{
    BOOL    bReturn = FALSE;
    BOOL    bRes;
    PRefresherCacheEl pCacheEl;
    int     nNumElements;

    // Make sure we get access to the mutex before we continue.  If we can't
    // get to it, something's wrong, so we'll just assume we are busy.

    if ( WaitForSingleObject( m_hAccessMutex, REFRESHER_MUTEX_WAIT_TIMEOUT ) == WAIT_OBJECT_0 )
    {
        // This will auto-release the mutex in case something bad happens
        CMutexReleaseMe    mrm( m_hAccessMutex );
    
        nNumElements = m_aCache.Size();
        for (int i = 0; i < nNumElements; i++)
        {
            pCacheEl = PRefresherCacheEl(m_aCache[i]);
            assert (pCacheEl != NULL);

            bRes = pCacheEl->RemoveInst(lId);
            if (bRes == TRUE) {
                // found the matching instance so 
                // de register this with the perf library
                m_PerfObj.RemoveClass (pCacheEl->m_pClassMap->m_pClassDef);
                bReturn = TRUE;
                break;
            }
        }
    }
    else
    {
        SetLastError( (ULONG) WBEM_E_REFRESHER_BUSY );
        bReturn = FALSE;
    }
    
    return bReturn;
}

//***************************************************************************
//
//  CNt5Refresher::FindSingletonInst
//
//  Based on a perf object identification, locates a singleton WBEM
//  instance of that class within this refresher and returns the pointer
//  to it and its WBEM class info.
//
//  Note that the <dwPerfObjIx> maps directly to a WBEM Class entry.
//
//  To save execution time, we don't AddRef() the return value and the 
//  caller doesn't Release().
//
//***************************************************************************
// ok
BOOL CNt5Refresher::FindSingletonInst(
    IN  DWORD dwPerfObjIx,
    OUT IWbemObjectAccess **pInst,
    OUT CClassMapInfo **pClsMap
)
{
    BOOL    bReturn = FALSE;
    PRefresherCacheEl pCacheEl;

    int l = 0;
    int u = m_aCache.Size() - 1;
    int m;

    // Binary search the cache.
    // ========================

    while (l <= u) {

        m = (l + u) / 2;

        pCacheEl = PRefresherCacheEl(m_aCache[m]);

        if (dwPerfObjIx < pCacheEl->m_dwPerfObjIx) {
            u = m - 1;
        } else if (dwPerfObjIx > pCacheEl->m_dwPerfObjIx) {
            l = m + 1;
        } else {
            *pClsMap = pCacheEl->m_pClassMap;    
            *pInst = pCacheEl->m_pSingleton; // No AddRef() caller doesn't 
                                             // change ref count
            bReturn = TRUE;
            break;
        }            
    }

    // Not found
    // =========
        
    return bReturn;
}

//***************************************************************************
//
//  CNt5Refresher::FindInst
//
//  Based on a perf object identification, locates a WBEM instance of 
//  that class within this refresher and returns the pointer to it. 
//
//  Note that the <dwPerfObjIx> maps directly to a WBEM Class entry.
//
//  To save execution time, we don't AddRef() the return value and the 
//  caller doesn't Release().
//
//***************************************************************************
// ok

BOOL CNt5Refresher::FindInst(
    IN  DWORD dwPerfObjIx,
    IN  LPWSTR pszInstName,
    OUT IWbemObjectAccess **pInst,
    OUT CClassMapInfo **pClsMap
    )
{
    BOOL    bReturn = FALSE;
    IWbemObjectAccess *pTmp;
    PRefresherCacheEl pCacheEl;

    int l = 0; 
    int u = m_aCache.Size() - 1;
    int m;

    // Binary search the cache.
    // ========================

    while (l <= u) {
        m = (l + u) / 2;

        pCacheEl = PRefresherCacheEl(m_aCache[m]);

        if (dwPerfObjIx < pCacheEl->m_dwPerfObjIx) {
            u = m - 1;
        } else if (dwPerfObjIx > pCacheEl->m_dwPerfObjIx) {
            l = m + 1;
        } else {
            // We found the class.  Now do we have the instance?
            // =================================================
            pTmp = pCacheEl->FindInst(pszInstName);
            if (pTmp == 0) {
                bReturn  = FALSE;   // Didn't have it.
            } else {
                *pInst = pTmp;                
                *pClsMap = pCacheEl->m_pClassMap;    
                bReturn = TRUE;
            }
            break;
        }            
    }

    // Not found
    // =========
        
    return bReturn;
}

//***************************************************************************
//
//  CNt5Refresher::GetObjectIds
//
//  Gets a list of all the perf object Ids corresponding to the instances
//  in the refresher.
//
//  Caller uses operator delete to deallocate the returned array.
//
//***************************************************************************
// ok
BOOL CNt5Refresher::GetObjectIds(
    DWORD *pdwNumIds, 
    DWORD **pdwIdList
)
{
    DWORD *pdwIds;
    int     nNumElements;
    BOOL    bReturn;
 
    nNumElements = m_aCache.Size();

    pdwIds = new DWORD[nNumElements ];

    if (pdwIds != NULL) {
        for (int i = 0; i < nNumElements; i++) {
            pdwIds[i] = PRefresherCacheEl(m_aCache[i])->m_dwPerfObjIx;
        }

        *pdwIdList = pdwIds;
        *pdwNumIds = nNumElements;
        bReturn = TRUE;
    } else {
        // unable to create buffer
        bReturn = FALSE;
    }

    return bReturn;    
}

//***************************************************************************
//
//  CNt5Refresher::FindUnusedId
//
//  Finds an ID not in use for new objects to be added to the refresher.
//
//***************************************************************************
// ok
LONG CNt5Refresher::FindUnusedId()
{
    PRefresherCacheEl pEl;
    PCachedInst pInst;
    int         nRetries = 0x100000;    // A hundred thousand retries
    LONG        lReturn = -1;
    int         i;
    int         i2;
    int         nNumElements;
    int         nNumInstances;
    // assume the object is locked for access
    
    Restart: 
    while (nRetries--) {
        i = 0;
        nNumElements = m_aCache.Size();
        while(i < nNumElements) {
            pEl = PRefresherCacheEl(m_aCache[i]);
            // test enum Id first
            if (pEl->m_lEnumId == m_lProbableId) {
                m_lProbableId++;
                goto Restart;
            }
            i2 = 0;
            nNumInstances = pEl->m_aInstances.Size();
            while (i2 < nNumInstances) {
                pInst = (PCachedInst) pEl->m_aInstances[i2];
                if (pInst->m_lId == m_lProbableId) {
                    m_lProbableId++;
                    goto Restart;
                }
                i2++;
            }           
            i++;
        }            
        
        lReturn = m_lProbableId;
        break;
    }
    
    return lReturn;
}

//***************************************************************************
//
//  RefresherCacheEl::RemoveInst
//
//  Removes the requested instances from the cache element for a particular
//  class.
//
//***************************************************************************
// ok

BOOL RefresherCacheEl::RemoveInst(LONG lId)
{
    BOOL    bReturn = FALSE;
    int i;
    PCachedInst pInst;
    int nNumInstances;

    if (lId == m_lEnumId) {
        // then clean out the enumerator for this object
        nNumInstances = m_aEnumInstances.Size();
        if (nNumInstances> 0) {
            IWbemObjectAccess   *pAccess;
            for (i = 0;  i < nNumInstances ; i++) {
                pAccess = (IWbemObjectAccess *)(m_aEnumInstances.GetAt(i));
                if (pAccess != NULL) {
                    pAccess->Release();
                }
            }
            m_aEnumInstances.Empty();
        }

        if (m_plIds != NULL) {
            delete (m_plIds);
            m_plIds = NULL;
            m_lEnumArraySize = 0;
        }

        if (m_pHiPerfEnum != NULL) {
            m_pHiPerfEnum->Release();
            m_pHiPerfEnum = NULL;
        }

        // Now, if this is a singleton (m_pSingleton != NULL),
        // then check if m_aInstances is empty.  If so, then
        // no instances are referencing the singleton object
        // so we can free up its resources.

        if ( NULL != m_pSingleton && 0 == m_aInstances.Size() )
        {
            m_pSingleton->Release();
            m_pSingleton = NULL;
        }

        return TRUE;
    } else {
        // walk the instances to find a match
        nNumInstances = m_aInstances.Size();
        for (i = 0; i < nNumInstances; i++) {
            pInst = (PCachedInst) m_aInstances[i];        
            if (lId == pInst->m_lId) {
                delete pInst;
                m_aInstances.RemoveAt(i);
                bReturn = TRUE;
                break;
            }
        }

        // Now, if we removed an instance, m_aInstances is empty
        // and this is a singleton (m_pSingleton != NULL), then
        // check if m_pHiPerfEnum is NULL, meaning no Enumerator
        // exists, so none of its instances will be referencing
        // the singleton object, so we can free up its resources.

        if (    NULL != m_pSingleton
            &&  bReturn
            &&  0 == m_aInstances.Size()
            &&  NULL == m_pHiPerfEnum )
        {
            m_pSingleton->Release();
            m_pSingleton = NULL;
        }

        if ( bReturn )
        {
        }
    }
    return bReturn;
}

//***************************************************************************
//
//  CNt5Refresher::AddEnum
//
//  Creates an enumerator for the specified class
//  to it.
//  
//***************************************************************************
// ?
BOOL CNt5Refresher::AddEnum (
        IN  IWbemHiPerfEnum *pEnum,     // enum interface pointer
        IN  CClassMapInfo *pClsMap,     // Class of object
        OUT LONG    *plId               // id for new enum
)
{
    BOOL bRes = FALSE;
    LONG lStatus;
    LONG lNewId;
    PRefresherCacheEl pWorkEl;
    int  iReturn;

    // Make sure we get access to the mutex before we continue.  If we can't
    // get to it, something's wrong, so we'll just assume we are busy.

    if ( WaitForSingleObject( m_hAccessMutex, REFRESHER_MUTEX_WAIT_TIMEOUT ) == WAIT_OBJECT_0 )
    {
        // This will auto-release the mutex in case something bad happens
        CMutexReleaseMe    mrm( m_hAccessMutex );

        lNewId = FindUnusedId();
    
        if (lNewId != -1) {
            // First, find the cache element corresponding to this object.
            // ===========================================================
            pWorkEl = GetCacheEl(pClsMap);
    
            // If <pWorkEl> is NULL, we didn't have anything in the cache
            // and have to add a new one.
            // ==========================================================

            if (pWorkEl == NULL) {
                bRes = AddNewCacheEl(pClsMap, &pWorkEl);
            }    

            if (pWorkEl != NULL) {
                if (pWorkEl->m_pHiPerfEnum == NULL) {
                    // then we can init it as it hasn't been opened
                    pEnum->AddRef();
                    pWorkEl->m_pHiPerfEnum = pEnum;
                    pWorkEl->m_lEnumId = lNewId;

                    assert (pWorkEl->m_aEnumInstances.Size() == 0L);
                    bRes = TRUE;

                    if (pClsMap->IsSingleton()) {
                        LONG    lNumObjInstances;
                        // then create the singleton IWbemObjectAccess entry here

                        lNumObjInstances = 1;

                        // If we do NOT have a singleton pointer, make it so.
                        if ( NULL == pWorkEl->m_pSingleton )
                        {
                            // add the new IWbemObjectAccess pointers
                            IWbemClassObject    *pClsObj = NULL;
        
                            pWorkEl->m_pClassMap->m_pClassDef->SpawnInstance(0, &pClsObj);
                            if( NULL != pClsObj ){
                                pClsObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pWorkEl->m_pSingleton);
                                pClsObj->Release(); // We only need the IWbemObjectAccess pointer
                            }

                            // We don't really care about the singleton id anymore
                            // pWorkEl->m_lSingletonId = pWorkEl->m_plIds[0];

                        }

                        if (pWorkEl->m_aEnumInstances.Size() < lNumObjInstances) {
                            // alloc and init the ID array
                            if (pWorkEl->m_plIds != NULL) {
                                delete (pWorkEl->m_plIds);
                            }
                    
                            pWorkEl->m_lEnumArraySize = lNumObjInstances;
                            pWorkEl->m_plIds = new LONG[lNumObjInstances];

                            if (pWorkEl->m_plIds != NULL) {
                                pWorkEl->m_plIds[0] = 0;
                        
                                // AddRef the singleton class and place it in the enuminstances array
                                pWorkEl->m_pSingleton->AddRef();
                                iReturn = pWorkEl->m_aEnumInstances.Add (pWorkEl->m_pSingleton);
                                if (iReturn == CFlexArray::no_error) {
                                    // Add the singleton object to the enumerator.  Then, all we have to
                                    // do is update this object and we will, by default update the
                                    // enumerator, since the number of objects in it will always
                                    // be one.

                                    pWorkEl->m_pHiPerfEnum->AddObjects( 
                                            0,
                                            1,
                                            pWorkEl->m_plIds,
                                            (IWbemObjectAccess __RPC_FAR *__RPC_FAR *)pWorkEl->m_aEnumInstances.GetArrayPtr());
                                }
                                else {
                                    SetLastError((ULONG) WBEM_E_OUT_OF_MEMORY);
                                    bRes = FALSE;
                                }

                            } else {
                                SetLastError ((ULONG)WBEM_E_OUT_OF_MEMORY);
                                bRes = FALSE;
                            }
                        }
                        assert (pWorkEl->m_aEnumInstances.Size() >= lNumObjInstances);

                    }

                    // load provider library since all went OK so far
                    lStatus = m_PerfObj.AddClass (pClsMap->m_pClassDef, FALSE);
                    if (lStatus == ERROR_SUCCESS) {
                        // return new ID & successful status 
                        *plId = lNewId;
                        bRes = TRUE;
                    } else {
                        // set error: Class or library failed to load
                        SetLastError ((ULONG)WBEM_E_PROVIDER_FAILURE);
                        bRes = FALSE;
                    }
                } else {
                    // this class already has an enumerator
                    // what to do here? 
                    // for now we'll return the id of the existing one
                    SetLastError ((ULONG)WBEM_E_ILLEGAL_OPERATION);
                    bRes = FALSE;
                }
            }
        }

    }    // IF WaitForSingleObject
    else
    {
        bRes = FALSE;
        // We're locked out of the mutex
        SetLastError ((ULONG)WBEM_E_REFRESHER_BUSY);
    }

    return bRes;
}

//***************************************************************************
//
//  CNt5Refresher::AddObject
//
//  Adds the requested object to the refresher and assigns an ID
//  to it.
//  
//***************************************************************************
// ?
BOOL CNt5Refresher::AddObject(
    IN  IWbemObjectAccess **ppObj,    // Object to add
    IN  CClassMapInfo   *pClsMap,   // Class of object
    OUT LONG            *plId       // The id of the object added
)
{
    BOOL bRes = FALSE;
    LONG lStatus;
    LONG lNewId;
    PRefresherCacheEl pWorkEl;

    // Make sure we get access to the mutex before we continue.  If we can't
    // get to it, something's wrong, so we'll just assume we are busy.

    if ( WaitForSingleObject( m_hAccessMutex, REFRESHER_MUTEX_WAIT_TIMEOUT ) == WAIT_OBJECT_0 )
    {
        // This will auto-release the mutex in case something bad happens
        CMutexReleaseMe    mrm( m_hAccessMutex );

        lNewId = FindUnusedId();
    
        if (lNewId != -1) {
            // First, find the cache element corresponding to this object.
            // ===========================================================
            pWorkEl = GetCacheEl(pClsMap);
    
            // If <pWorkEl> is NULL, we didn't have anything in the cache
            // and have to add a new one.
            // ==========================================================

            if (pWorkEl == NULL) {
                bRes = AddNewCacheEl(pClsMap, &pWorkEl);
            }    

            if (pWorkEl != NULL) {
                // If here, we have successfully added a new cache element.
                // ========================================================
                bRes = pWorkEl->InsertInst(ppObj, lNewId);

                if (bRes) {
                    // load provider library since all went OK so far
                    lStatus = m_PerfObj.AddClass (pClsMap->m_pClassDef, FALSE);

                    if (lStatus == ERROR_SUCCESS) {
                        // return new ID & successful status 
                        *plId = lNewId;
                        bRes = TRUE;
                    } else {
                        // set error: Class or library failed to load
                        SetLastError ((ULONG)WBEM_E_PROVIDER_FAILURE);
                        bRes = FALSE;
                    }
                }
            }
        }

    }    // IF acquired mutex
    else
    {
        bRes = FALSE;
        // Return a busy error
        SetLastError ((ULONG)WBEM_E_REFRESHER_BUSY);
    }

    return bRes;
}

//***************************************************************************
//
//  CNt5Refresher::AddNewCacheEl
//
//  Adds a new cache element in the proper position so that a binary
//  search on perf object id can occur later.
//
//***************************************************************************
// ok
BOOL CNt5Refresher::AddNewCacheEl(
    IN CClassMapInfo *pClsMap, 
    PRefresherCacheEl *pOutput
    )
{
    // assumes the object is locked for access

    PRefresherCacheEl pWorkEl;
    PRefresherCacheEl pNew = 0;

    int i;
    int nNumElements;
    BOOL bReturn = FALSE;

    * pOutput = NULL;
    pNew = new RefresherCacheEl;

    if (pNew != NULL) {
        pNew->m_dwPerfObjIx = pClsMap->GetObjectId();
        pNew->m_pClassMap = pClsMap->CreateDuplicate();

        if (pNew->m_pClassMap != NULL) {
            nNumElements = m_aCache.Size();
            for (i = 0; i < nNumElements; i++) {
                // walk through the list of cache elements
                // and find the first entry that has a 
                // larger index then the one we are adding
                pWorkEl = PRefresherCacheEl(m_aCache[i]);
                if (pNew->m_dwPerfObjIx < pWorkEl->m_dwPerfObjIx) {
                    m_aCache.InsertAt(i, pNew);
                    *pOutput = pNew;
                    bReturn = TRUE;
                    break;
                }
            }

            if (i == nNumElements) {
                // this entry is larger than anyone in the list
                // so Add it to the end.
                // =====-===============
                m_aCache.Add(pNew);    
                *pOutput = pNew;
                bReturn = TRUE;
            }
        }
        else {
            // cannot duplicate ClassMap,
            // delte allocated object and return false
            delete pNew;
        }

    } else {
        // return false
    } 

    return bReturn;
}    

//***************************************************************************
//
//  CNt5Refresher::GetCacheEl
//
//***************************************************************************
// ok
PRefresherCacheEl CNt5Refresher::GetCacheEl(
    CClassMapInfo *pClsMap
)
{
    // assumes the structure is locked for access
    PRefresherCacheEl pReturn = NULL;
    PRefresherCacheEl pWorkEl;
    int i;
    int nNumElements;
    DWORD   dwObjectIdToFind;

    if (pClsMap != NULL) {
        dwObjectIdToFind = pClsMap->GetObjectId();
        nNumElements = m_aCache.Size();
        for (i = 0; i < nNumElements; i++) {
            pWorkEl = PRefresherCacheEl(m_aCache[i]);
            if (pWorkEl->m_pClassMap->GetObjectId() == dwObjectIdToFind) {
                pReturn = pWorkEl;
                break;
            }
        }        
    }

    return pReturn;
}    

//***************************************************************************
//
//  RefresherCacheEl::FindInstance
//
//  Finds an instance in the current cache element for a particular instance.
//  For this to work, the instances have to be sorted by name.
//  
//***************************************************************************
// ok
IWbemObjectAccess *RefresherCacheEl::FindInst(
    LPWSTR pszInstName
    )
{
    // Binary search the cache.
    // ========================

    int l = 0;
    int u = m_aInstances.Size() - 1;
    int m;
    CachedInst *pInst;

    while (l <= u) {
        m = (l + u) / 2;

        pInst = PCachedInst(m_aInstances[m]);

        if (_wcsicmp(pszInstName, pInst->m_pName) < 0) {
            u = m - 1;
        } else if (_wcsicmp(pszInstName, pInst->m_pName) > 0) {
            l = m + 1;
        } else  {
            // We found the instance. 
            // ======================
            return pInst->m_pInst;            
        }            
    }

    // Not found
    // =========
        
    return NULL;
}    

//***************************************************************************
//
//  Inserts a new instance.
//
//***************************************************************************
//
BOOL RefresherCacheEl::InsertInst(IWbemObjectAccess **ppNew, LONG lNewId)
{
    // Save the value passed in
    IWbemObjectAccess*  pNew = *ppNew;

    IWbemClassObject *pObj;
    VARIANT         v;
    PCachedInst     pNewInst;
    DWORD           dwInstanceNameLength;
    PCachedInst     pTest;
    BOOL            bReturn = FALSE;
    HRESULT         hRes;
    int             nNumInstances;
    CBSTR           cbName(cszName);

    if( NULL == (BSTR)cbName ){
        return FALSE;
    }

    // Check for singleton.
    // ====================
    if (m_pClassMap->IsSingleton()) {

        // If we don't already have an object, use the one passed in.  Otherwise
        // we will replace it.

        if ( NULL == m_pSingleton )
        {
            m_pSingleton = pNew;
            m_pSingleton->AddRef();
            // We don't really need the id anymore
            // m_lSingletonId = lNewId;
        }
        else
        {
            // Now we're sneaking around by replacing *ppNew with the
            // singleton we already have.  We must release *ppNew in
            // order to get away with this.

            (*ppNew)->Release();

            // We need to AddRef() this because *ppNew is now referencing it
            m_pSingleton->AddRef();
            *ppNew = m_pSingleton;
            pNew = m_pSingleton;
        }

        // Now we will Add this instance just like any other

        pNewInst = new CachedInst;
//        assert (pNewInst != NULL);

        if ( pNewInst != NULL )
        {
            // For singletons, none of the other pointers
            // should matter.

            pNewInst->m_lId = lNewId;
            pNewInst->m_pInst = pNew;
            pNewInst->m_pInst->AddRef();

            // We are saving the name just to be safe (It will
            // really only be an "@", and I don't believe it
            // will be accessed anywhere else.  I hope...)
            pNewInst->m_pName = Macro_CloneLPWSTR(L"@");
//            assert (pNewInst->m_pName != NULL);

            if ( NULL != pNewInst->m_pName )
            {
                // We can just add this in, since any entries will all be the
                // same anyway.

                m_aInstances.Add(pNewInst);    
                bReturn = TRUE;
            }
            else    // Memory Allocation failed
            {
                bReturn = FALSE;
                SetLastError ((DWORD)WBEM_E_OUT_OF_MEMORY);
                delete(pNewInst);
            }

        }
        else    // Memory allocation failed
        {
            bReturn = FALSE;
            SetLastError ((DWORD)WBEM_E_OUT_OF_MEMORY);
        }

    } else {
        VariantInit(&v);
   
        // For multi-instance, get the instance name.
        // ==========================================
        hRes = pNew->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
        assert (hRes == NO_ERROR);

        if (hRes == NO_ERROR) {
            
            hRes = pObj->Get( cbName, 0, &v, 0, 0);
            assert (hRes == NO_ERROR);
            if (hRes == NO_ERROR) {
                if (v.vt == VT_BSTR) {
                    bReturn = TRUE;
                } else {
                    bReturn = FALSE;
                    // the object passed in should have an instance name
                    SetLastError ((DWORD)WBEM_E_INVALID_OBJECT_PATH);
                }
            }

            pObj->Release();
    
            if (bReturn) {
                // Construct the new instance.
                // ===========================
                pNewInst = new CachedInst;
//                assert (pNewInst != NULL);

                if (pNewInst != NULL) {
                    pNewInst->m_lId = lNewId;
                    pNewInst->m_pInst = pNew;
                    pNewInst->m_pInst->AddRef();
                    pNewInst->m_pName = Macro_CloneLPWSTR(V_BSTR(&v));

                    if (pNewInst->m_pName != NULL) {
                        dwInstanceNameLength = lstrlenW (pNewInst->m_pName) + 1;

                        // parse the instance string now to save processing time later
                        pNewInst->m_szParentName = new WCHAR[dwInstanceNameLength]; 

                        pNewInst->m_szInstanceName = new WCHAR[dwInstanceNameLength];

                        if ((pNewInst->m_szParentName != NULL) &&
                            (pNewInst->m_szInstanceName != NULL)) {

                            // break the instance name into components
                            bReturn = PerfHelper::ParseInstanceName (pNewInst->m_pName,
                                pNewInst->m_szInstanceName,
                                dwInstanceNameLength,
                                pNewInst->m_szParentName,
                                dwInstanceNameLength,
                                &pNewInst->m_dwIndex);
    
                            if (bReturn) {
                                bReturn = FALSE;    // to prime it.
                                // Now place the name in the instance cache element.
                                // =================================================
                                nNumInstances = m_aInstances.Size();
                                for (int i = 0; i < nNumInstances; i++) {
                                    // see if it belongs in the list
                                    pTest = PCachedInst(m_aInstances[i]);        
                                    if (_wcsicmp(V_BSTR(&v), pTest->m_pName) < 0) {
                                        m_aInstances.InsertAt(i, pNewInst);
                                        bReturn = TRUE;
                                        // once it's been added, 
                                        // there's no point in continuing
                                        break; 
                                    }
                                }

                                if (!bReturn) {
                                    // this goes at the end of the list
                                    m_aInstances.Add(pNewInst);    
                                    bReturn = TRUE;
                                } else {
                                    // unable to create instance
                                    SetLastError ((DWORD)WBEM_E_INVALID_OBJECT_PATH);
                                }
                            }
                        }
                        // clean up if there's an error
                        if (!bReturn) {
                            if (pNewInst->m_szParentName != NULL) {
                                delete (pNewInst->m_szParentName);
                            }
                            if (pNewInst->m_szInstanceName != NULL) {
                                delete pNewInst->m_szInstanceName;
                            }
                            delete (pNewInst->m_pName);
                            bReturn = FALSE;
                            delete (pNewInst);
                        }
                    } else {
                        // unable to alloc memory
                        bReturn = FALSE;
                        SetLastError ((DWORD)WBEM_E_OUT_OF_MEMORY);
                        delete (pNewInst);
                    }
                } else {
                    // unable to alloc memory
                    bReturn = FALSE;
                    SetLastError ((DWORD)WBEM_E_OUT_OF_MEMORY);
                }
            } else {
                // return FALSE
            }
        } else {
            // return FALSE
        }
        VariantClear(&v);
    }
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\server.cpp ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  SERVER.CPP
//
//  Generic COM server framework, adapted for the NT perf counter sample
//
//  This module contains nothing specific to the NT perf counter provider
//  except what is defined in the section bracketed by the CLSID SPECIFIC
//  comments below.
//
//  History:
//  raymcc        25-Nov-97     Created.
//  raymcc        18-Feb-98     Updated for NT5 Beta 2 version.
//
//***************************************************************************
#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <objbase.h>
#include <strsafe.h>
#include <initguid.h>
/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//
#pragma warning ( disable : 4268)
#include <wbemidl.h>
#pragma warning ( default : 4268)
#include <wbemint.h>
#include "ntperf.h"
#include "strings.h"

//
//  this is going to be the ClientLoadable one
//

// {FF37A93C-C28E-11d1-AEB6-00C04FB68820}
DEFINE_GUID(CLSID_NT5PerfProvider_V1,
0xff37a93c, 0xc28e, 0x11d1, 0xae, 0xb6, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);

//
// this is going to be the Server Loadable
//

// {76A94DE3-7C26-44f5-8E98-C5AEA48186CB}
DEFINE_GUID(CLSID_NT5PerfProvider_V1_Srv, 
0x76a94de3, 0x7c26, 0x44f5, 0x8e, 0x98, 0xc5, 0xae, 0xa4, 0x81, 0x86, 0xcb);


#define IMPLEMENTED_CLSID_1         CLSID_NT5PerfProvider_V1
#define IMPLEMENTED_CLSID_2         CLSID_NT5PerfProvider_V1_Srv 
#define SERVER_REGISTRY_COMMENT     cszOleRegistryComment
#define CPP_CLASS_NAME              CNt5PerfProvider
#define INTERFACE_CAST              (IWbemHiPerfProvider *)

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////




HINSTANCE g_hInstance;
static ULONG g_cLock = 0;

void ObjectCreated()    { g_cLock++; }
void ObjectDestroyed() { g_cLock--; }

//***************************************************************************
//
//  class CFactory
//
//  Generic implementation of IClassFactory for CWbemLocator.
//
//***************************************************************************

class CFactory : public IClassFactory
{
    ULONG           m_cRef;
    CLSID           m_ClsId;

public:
    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};

//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    UNREFERENCED_PARAMETER(lpReserved);

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }

    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************
extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (IMPLEMENTED_CLSID_1 != rclsid &&
        IMPLEMENTED_CLSID_2 != rclsid) 
            return ResultFromScode(E_FAIL);

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    //
    // Get a new class factory.
    //
    pFactory = new CFactory(rclsid);

    if (!pFactory)
        return ResultFromScode(E_OUTOFMEMORY);

    //
    // Verify we can get an instance.
    //
    HRESULT hRes = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hRes))
        delete pFactory;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cLock)
        sc = S_FALSE;

    return sc;
}


#ifdef _X86_
BOOL IsReallyWOW64( void )
{
    // Environment variable should only exist on WOW64
    return ( GetEnvironmentVariableW( L"PROCESSOR_ARCHITEW6432", 0L, NULL ) != 0L );
}
#endif

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    LPCWSTR Path = L"%systemroot%\\system32\\wbem\\wbemperf.dll";
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[WBEMPERF_STRING_SIZE];
    HKEY hKey = NULL;
    LONG lRes;
    wchar_t *pName;
    HKEY hSubkey = NULL;
    
    // Convert CLSID to string.
    // ========================

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    StringFromCLSID(IMPLEMENTED_CLSID_1, &pGuidStr);
    StringCchPrintfW(KeyPath, WBEMPERF_STRING_SIZE, cszClsidFormatString, pGuidStr);

    lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes){
        goto cleanup;
    }

    pName = (LPWSTR)SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, (DWORD)(((DWORD)(wcslen(pName)) + 1) * 2));


    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);
    if( lRes ){
        goto cleanup;
    }
    
    RegSetValueExW(hSubkey, 0, 0, REG_EXPAND_SZ, (const BYTE *) Path, (DWORD)(((DWORD)(wcslen(Path)) + 1) * 2));
    RegSetValueExW(hSubkey, cszThreadingModel, 0, REG_SZ, (const BYTE *) cszBoth, (DWORD)(((DWORD)(wcslen(cszBoth)) + 1) * 2));

    RegCloseKey(hSubkey);
    hSubkey = NULL;
    
    RegCloseKey(hKey);
    hKey = NULL;

    CoTaskMemFree(pGuidStr);
    pGuidStr = NULL;
    

#ifdef _X86
    if (!IsReallyWOW64())
    {
        // on 32-bit builds, we want to register the server loadable
        // perf provider only if we are not really running in syswow64
#endif

        // Place it in registry.
        // CLSID\\CLSID_Nt5PerProvider_v1_Srv : <no_name> : "name"
        //      \\CLSID_Nt5PerProvider_v1_Srv\\InProcServer32 : <no_name> : "path to DLL"
        //                                    : ThreadingModel : "both"
        // ==============================================================    

        StringFromCLSID(IMPLEMENTED_CLSID_2, &pGuidStr);
        StringCchPrintfW( KeyPath, WBEMPERF_STRING_SIZE, cszClsidFormatString, pGuidStr);

        lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
        if (lRes){
            goto cleanup;
        }

        pName = (LPWSTR)SERVER_REGISTRY_COMMENT; 
        RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, (DWORD)(((DWORD)(wcslen(pName)) + 1) * 2));

        lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);
        if( lRes ){
            goto cleanup;
        }

        RegSetValueExW(hSubkey, 0, 0, REG_EXPAND_SZ, (const BYTE *) Path, (DWORD)(((DWORD)(wcslen(Path)) + 1) * 2));
        RegSetValueExW(hSubkey, cszThreadingModel, 0, REG_SZ, (const BYTE *) cszBoth, (DWORD)(((DWORD)(wcslen(cszBoth)) + 1) * 2));

#ifdef _X86
    }
#endif

cleanup:
    if( NULL != hSubkey ){
        RegCloseKey(hSubkey);
    }
    if( NULL != hKey ){
        RegCloseKey(hKey);
    }
    if( NULL != pGuidStr ){
        CoTaskMemFree(pGuidStr);
    }

    return lRes;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[WBEMPERF_STRING_SIZE];
    LONG lRes;

    // Delete InProcServer32 subkey.
    // =============================
    // Delete CLSID GUID key.
    // ======================
    
    StringFromCLSID(IMPLEMENTED_CLSID_1, &pGuidStr);
    StringCchPrintfW( KeyPath, WBEMPERF_STRING_SIZE, cszClsidFormatString, pGuidStr);

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, cszInprocServer);
    RegCloseKey(hKey);

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, cszClsidKey, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

#ifdef _X86
    if (!IsReallyWOW64())
    {
        // on 32-bit builds, we need to unregister the server loadable
        // perf provider only if we are not really running in syswow64
#endif

        StringFromCLSID(IMPLEMENTED_CLSID_2, &pGuidStr);
        StringCchPrintfW( KeyPath, WBEMPERF_STRING_SIZE, cszClsidFormatString, pGuidStr);

        lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
        if (lRes)
            return E_FAIL;

        RegDeleteKeyW(hKey, cszInprocServer);
        RegCloseKey(hKey);

        lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, cszClsidKey, &hKey);
        if (lRes)
            return E_FAIL;

        RegDeleteKeyW(hKey, pGuidStr);
        RegCloseKey(hKey);

        CoTaskMemFree(pGuidStr);

#ifdef _X86
    }
#endif

    return S_OK;
}

//***************************************************************************
//
//  CFactory::CFactory
//
//  Constructs the class factory given the CLSID of the objects it is supposed
//  to create.
//
//  PARAMETERS:
//
//      const CLSID & ClsId     The CLSID. 
//
//***************************************************************************
CFactory::CFactory(const CLSID & ClsId)
{
    m_cRef = 0;
    ObjectCreated();
    m_ClsId = ClsId;
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//  Destructor.
//
//***************************************************************************
CFactory::~CFactory()
{
    ObjectDestroyed();
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//  Standard IUnknown methods.
//
//***************************************************************************
STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


ULONG CFactory::AddRef()
{
    return ++m_cRef;
}


ULONG CFactory::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CFactory::CreateInstance
//
//  PARAMETERS:
//
//      LPUNKNOWN pUnkOuter     IUnknown of the aggregator. Must be NULL.
//      REFIID riid             Interface ID required.
//      LPVOID * ppvObj         Destination for the interface pointer.
//
//  RETURN VALUES:
//
//      S_OK                        Success
//      CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
//      E_NOINTERFACE               No such interface supported.
//      
//***************************************************************************

STDMETHODIMP CFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    IUnknown* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = ResultFromScode(E_OUTOFMEMORY);

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    if (m_ClsId == IMPLEMENTED_CLSID_1) {
        pObj = INTERFACE_CAST new CPP_CLASS_NAME(CPP_CLASS_NAME::CLSID_CLIENT);
    } else if (m_ClsId == IMPLEMENTED_CLSID_2) {
        pObj = INTERFACE_CAST new CPP_CLASS_NAME(CPP_CLASS_NAME::CLSID_SERVER);
    } else {
        pObj = NULL;
    }

    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  CFactory::LockServer
//
//  Increments or decrements the lock count of the server. The DLL will not
//  unload while the lock count is positive.
//
//  PARAMETERS:
//
//      BOOL fLock      If TRUE, locks; otherwise, unlocks.
//
//  RETURN VALUES:
//
//      S_OK
//
//***************************************************************************
STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\strings.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    central definition file of common static strings
    these strings SHOULD NOT be localized as they are internal
    to the program and not intended for any display to the user

--*/

#include "windows.h"

#ifdef __cplusplus
extern "C" {
#endif

// single character constants
#define wcSpace     L' '
#define wcSlash     L'/'
#define wcPoundSign L'#'
#define wc_0        L'0'
#define wc_a        L'a'
#define wc_A        L'A'
#define wc_E        L'E'
#define wc_F        L'F'
#define wc_P        L'P'
#define wc_R        L'R'
#define wc_z        L'z'
   
// OLE and  Registry strings
extern LPCWSTR cszOleRegistryComment;
extern LPCWSTR cszClsidFormatString;
extern LPCWSTR cszThreadingModel;
extern LPCWSTR cszInprocServer;
extern LPCWSTR cszClsidKey;
extern LPCWSTR cszPerflibKey;
extern LPCWSTR cszDLLValue;
extern LPCWSTR cszObjListValue;
extern LPCWSTR cszLinkageKey;
extern LPCWSTR cszExportValue;
extern LPCWSTR cszOpenTimeout;
extern LPCWSTR cszCollectTimeout;
extern LPCWSTR cszExtCounterTestLevel;
extern LPCWSTR cszOpenProcedureWaitTime;
extern LPCWSTR cszLibraryUnloadTime;
extern LPCWSTR cszKeepResident;
extern LPCWSTR cszDisablePerformanceCounters;
extern LPCWSTR cszProviderName;
extern LPCWSTR cszHklmServicesKey;
extern LPCWSTR cszPerformance;
extern LPCWSTR cszGlobal;
extern LPCWSTR cszForeign;
extern LPCWSTR cszCostly;
extern LPCWSTR cszCounter;
extern LPCWSTR cszExplain;
extern LPCWSTR cszHelp;
extern LPCWSTR cszAddCounter;
extern LPCWSTR cszAddHelp;
extern LPCWSTR cszOnly;
extern LPCWSTR cszBoth;

extern LPCSTR  caszOpenValue;
extern LPCSTR  caszCloseValue;
extern LPCSTR  caszCollectValue;
extern LPCSTR  caszQueryValue;

// "well known" property names
extern LPCWSTR cszPropertyCount;
extern LPCWSTR cszClassName;
extern LPCWSTR cszName;
extern LPCWSTR cszTimestampPerfTime;
extern LPCWSTR cszFrequencyPerfTime;
extern LPCWSTR cszTimestampSys100Ns;
extern LPCWSTR cszFrequencySys100Ns;
extern LPCWSTR cszTimestampObject;
extern LPCWSTR cszFrequencyObject;

// "well known" qualifier names
extern LPCWSTR cszPerfIndex;
extern LPCWSTR cszSingleton;
extern LPCWSTR cszCountertype;
extern LPCWSTR cszProvider;
extern LPCWSTR cszRegistryKey;

// other random strings
extern LPCWSTR cszSpace;
extern LPCWSTR cszSlash;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\wpheader.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wpheader.h

Abstract:

    <abstract>

--*/

#include    <windows.h>
#include    <wbemidl.h>
#include    <wbemint.h>
#include    <pdh.h>  // for constants only
#include    <strsafe.h>
#include    "classmap.h"
#include    "flexarry.h"
#include    "ntperf.h"
#include    "PerfAcc.h"
#include    "refreshr.h"
#include    "perfhelp.h"
#include    "strings.h"
#include    "utils.h"
#include    "wbprfmsg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\strings.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    strings.cpp

Abstract:

    central definition file of common static strings
    these strings SHOULD NOT be localized as they are internal
    to the program and not intended for any display to the user

--*/

#include "strings.h"

// OLE and  Registry strings
LPCWSTR cszOleRegistryComment   = L"WBEM NT5 Base Perf Provider";
LPCWSTR cszClsidFormatString    = L"Software\\Classes\\CLSID\\\\%s";
LPCWSTR cszThreadingModel       = L"ThreadingModel";
LPCWSTR cszInprocServer         = L"InprocServer32";
LPCWSTR cszClsidKey             = L"Software\\Classes\\CLSID";
LPCWSTR cszPerflibKey           = L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
LPCWSTR cszDLLValue             = L"Library";
LPCWSTR cszObjListValue         = L"Object List";
LPCWSTR cszLinkageKey           = L"\\Linkage";
LPCWSTR cszExportValue          = L"Export";
LPCWSTR cszOpenTimeout          = L"Open Timeout";
LPCWSTR cszCollectTimeout       = L"Collect Timeout";
LPCWSTR cszExtCounterTestLevel  = L"ExtCounterTestLevel";
LPCWSTR cszOpenProcedureWaitTime = L"OpenProcedureWaitTime";
LPCWSTR cszLibraryUnloadTime    = L"Library Unload Time";
LPCWSTR cszKeepResident         = L"Keep Library Resident";
LPCWSTR cszDisablePerformanceCounters = L"Disable Performance Counters";
LPCWSTR cszProviderName         = L"NT5_GenericPerfProvider_V1";
LPCWSTR cszHklmServicesKey      = L"SYSTEM\\CurrentControlSet\\Services";
LPCWSTR cszPerformance          = L"\\Performance";
LPCWSTR cszGlobal               = L"Global";
LPCWSTR cszForeign              = L"FOREIGN";
LPCWSTR cszCostly               = L"COSTLY";
LPCWSTR cszCounter              = L"COUNTER";
LPCWSTR cszExplain              = L"EXPLAIN";
LPCWSTR cszHelp                 = L"HELP";
LPCWSTR cszAddCounter           = L"ADDCOUNTER";
LPCWSTR cszAddHelp              = L"ADDEXPLAIN";
LPCWSTR cszOnly                 = L"ONLY";
LPCWSTR cszBoth                 = L"Both";

LPCSTR  caszOpenValue           = "Open";
LPCSTR  caszCloseValue          = "Close";
LPCSTR  caszCollectValue        = "Collect";
LPCSTR  caszQueryValue          = "Query";

// "well known" property names
LPCWSTR cszPropertyCount        = L"__PROPERTY_COUNT";
LPCWSTR cszClassName            = L"__CLASS";
LPCWSTR cszName                 = L"Name";
LPCWSTR cszTimestampPerfTime    = L"Timestamp_PerfTime";
LPCWSTR cszFrequencyPerfTime    = L"Frequency_PerfTime";
LPCWSTR cszTimestampSys100Ns    = L"Timestamp_Sys100NS";
LPCWSTR cszFrequencySys100Ns    = L"Frequency_Sys100NS";
LPCWSTR cszTimestampObject      = L"Timestamp_Object";
LPCWSTR cszFrequencyObject      = L"Frequency_Object";

// "well known" qualifier names
LPCWSTR cszPerfIndex            = L"PerfIndex";
LPCWSTR cszSingleton            = L"Singleton";
LPCWSTR cszCountertype          = L"countertype";
LPCWSTR cszProvider             = L"Provider";
LPCWSTR cszRegistryKey          = L"registrykey";

// other random strings
LPCWSTR cszSpace                = L" ";
LPCWSTR cszSlash                = L"/";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\utils.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    utils.h

Abstract:

    <abstract>

--*/

#ifndef _WBEMPERF_UTILS_H_
#define _WBEMPERF_UTILS_H_

#ifdef __cplusplus

__inline wchar_t* Macro_CloneLPWSTR(wchar_t *x)
{
    wchar_t *s;
    size_t cchSize;
    if (!x) return NULL;
    cchSize = wcslen(x) + 1;
    s = new wchar_t[cchSize];
    if (!s) return NULL;
    StringCchCopyW( s, cchSize, x );
    return s;
}

extern "C" {
#endif

#include <windows.h>
#include <winperf.h>

#ifndef _OUTPUT_DEBUG_STRINGS
#define _OUTPUT_DEBUG_STRINGS 0
#endif

#ifndef _DEBUG_MUTEXES
#define _DEBUG_MUTEXES 0	// for debugging locks
#endif // _DEBUG_MUTEXES undefined

extern HANDLE hEventLog;

#define ALLOCMEM(heap, flags, size)     HeapAlloc (heap, flags, size)
#define REALLOCMEM(heap, flags, pointer, newsize) \
                                    HeapReAlloc(heap, flags, pointer, newsize)
#define FREEMEM(heap, flags, pointer)  if( NULL != pointer ){ HeapFree (heap, flags, pointer); }

// convert mS to relative time
#define MakeTimeOutValue(ms) ((LONGLONG)((LONG)(ms) * -10000L))

#define CLOSE_WAIT_TIME     5000L   // wait time for query mutex (in ms)
#define QUERY_WAIT_TIME     2000L    // wait time for query mutex (in ms)
#define OPEN_PROC_WAIT_TIME 10000L  // default wait time for open proc to finish (in ms)

// query types

#define QUERY_GLOBAL       1
#define QUERY_ITEMS        2
#define QUERY_FOREIGN      3
#define QUERY_COSTLY       4
#define QUERY_COUNTER      5
#define QUERY_HELP         6
#define QUERY_ADDCOUNTER   7
#define QUERY_ADDHELP      8

#define WBEMPERF_STRING_SIZE 1024

extern const WCHAR GLOBAL_STRING[];
extern const WCHAR COSTLY_STRING[];
extern const DWORD VALUE_NAME_LENGTH;

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
//  (assumes dword is 4 bytes, quadword is 8 bytes)
#define DWORD_MULTIPLE(x) (((ULONG)(x) + ((4)-1)) & ~((ULONG)(4)-1))
#define QWORD_MULTIPLE(x) (((ULONG)(x) + ((8)-1)) & ~((ULONG)(8)-1))

#define ALIGN_ON_DWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((4)-1)) & ~((ULONG_PTR)(4)-1)))
#define ALIGN_ON_QWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((8)-1)) & ~((ULONG_PTR)(8)-1)))

//
// function prototypes
//
BOOL
MonBuildPerfDataBlock(
    PERF_DATA_BLOCK *pBuffer,
    PVOID *pBufferNext,
    DWORD NumObjectTypes,
    DWORD DefaultObject
);


BOOL
MatchString (
    IN LPCWSTR lpValueArg,
    IN LPCWSTR lpNameArg
);


DWORD
GetNextNumberFromList (
    IN LPWSTR   szStartChar,
    IN LPWSTR   *szNextChar
);

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
);

LPWSTR
ConvertProcName(
	LPSTR strProcName, 
	LPWSTR buffer, 
	DWORD cchBuffer 
);

#if _DEBUG_MUTEXES
#include <stdio.h>
__inline
void
PdhiLocalWaitForMutex (
	LPCSTR	szSourceFileName,
	DWORD	dwLineNo,
	HANDLE	hMutex
)
{
	DWORD	dwReturnValue;
    CHAR    szOutputString[WBEMPERF_STRING_SIZE];
	FILETIME	ft;
	
	if (hMutex != NULL) {
		GetSystemTimeAsFileTime (&ft);
		dwReturnValue = WaitForSingleObject (hMutex, 10000);
		sprintf (szOutputString, "\n[%8.8x] Mutex [%8.8x] %s by (%d) at: %s (%d)",
			ft.dwLowDateTime,
			(DWORD)hMutex,
			(dwReturnValue == 0 ? "Locked" : "Lock Failed"),
			GetCurrentThreadId(),
			szSourceFileName, dwLineNo);
	} else {
		sprintf (szOutputString, "\nLock of NULL Mutex attmpted at: %s (%d)",
			szSourceFileName, dwLineNo);
	}
	OutputDebugStringA (szOutputString);
}

#define WAIT_FOR_AND_LOCK_MUTEX(h) PdhiLocalWaitForMutex (__FILE__, __LINE__, h);

__inline
void
PdhiLocalReleaseMutex (
	LPCSTR	szSourceFileName,
	DWORD	dwLineNo,
	HANDLE	hMutex
)
{
	BOOL	bSuccess;
    CHAR    szOutputString[WBEMPERF_STRING_SIZE];
	LONG	lPrevCount = 0;
	FILETIME	ft;

	if (hMutex != NULL) {
		GetSystemTimeAsFileTime (&ft);
		bSuccess = ReleaseMutex (hMutex);
		sprintf (szOutputString, "\n[%8.8x] Mutex [%8.8x] %s by (%d) at: %s (%d)",
			ft.dwLowDateTime,
			(DWORD)hMutex,
			(bSuccess ? "Released" : "Release Failed"),
			GetCurrentThreadId(),
			szSourceFileName, dwLineNo);
	} else {
		sprintf (szOutputString, "\nRelease of NULL Mutex attempted at: %s (%d)",
			szSourceFileName, dwLineNo);
	}
    OutputDebugStringA (szOutputString);
}

#define RELEASE_MUTEX(h)  PdhiLocalReleaseMutex (__FILE__, __LINE__, h);
#else
// 10 second wait timeout
#define WAIT_FOR_AND_LOCK_MUTEX(h) (h != NULL ? WaitForSingleObject(h, 10000) : WAIT_TIMEOUT)
#define RELEASE_MUTEX(h)  (h != NULL ? ReleaseMutex(h) : FALSE)
#endif

#ifdef __cplusplus
}
#endif

#endif //_PERFLIB_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perfmtr\drivers.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   kernprof.c

Abstract:

    This module contains a dumper of the drivers loaded in the current system.

Usage:

    drivers

Author:

    Mark Lucovsky (markl) 15-Mar-1993

Envirnoment:



Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

typedef struct _MODULE_DATA {
    ULONG CodeSize;
    ULONG DataSize;
    ULONG BssSize;
    ULONG RoDataSize;
    ULONG ImportDataSize;
    ULONG ExportDataSize;
    ULONG ResourceDataSize;
    ULONG PagedSize;
    ULONG InitSize;
    ULONG CheckSum;
    ULONG TimeDateStamp;
} MODULE_DATA, *PMODULE_DATA;

typedef struct _LOADED_IMAGE {
    PUCHAR MappedAddress;
    PIMAGE_NT_HEADERS FileHeader;
    PIMAGE_SECTION_HEADER LastRvaSection;
    int NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
} LOADED_IMAGE, *PLOADED_IMAGE;


VOID
SumModuleData(
    PMODULE_DATA Sum,
    PMODULE_DATA Current
    )
{
    Sum->CodeSize           += Current->CodeSize;
    Sum->DataSize           += Current->DataSize;
    Sum->BssSize            += Current->BssSize;
    Sum->RoDataSize         += Current->RoDataSize;
    Sum->ImportDataSize     += Current->ImportDataSize;
    Sum->ExportDataSize     += Current->ExportDataSize;
    Sum->ResourceDataSize   += Current->ResourceDataSize;
    Sum->PagedSize          += Current->PagedSize;
    Sum->InitSize           += Current->InitSize;
}
VOID
PrintModuleSeperator(
    VOID
    )
{
    printf("------------------------------------------------------------------------------\n");
}

VOID
PrintModuleHeader(
    VOID
    )
{
    printf("  ModuleName    Code    Data     Bss   Paged    Init          LinkDate\n");
    PrintModuleSeperator();
}

VOID
PrintModuleLine(
    LPSTR ModuleName,
    PMODULE_DATA Current
    )
{
    printf("%12s %7d %7d %7d %7d %7d  %s",
        ModuleName,
        Current->CodeSize,
        Current->DataSize,
        Current->BssSize,
        Current->PagedSize,
        Current->InitSize,
        Current->TimeDateStamp ? ctime((time_t *)&Current->TimeDateStamp) : "\n"
        );
}

VOID
GetModuleData(
    HANDLE hFile,
    PMODULE_DATA Mod
    )
{
    HANDLE hMappedFile;
    PIMAGE_DOS_HEADER DosHeader;
    LOADED_IMAGE LoadedImage;
    ULONG SectionAlignment;
    PIMAGE_SECTION_HEADER Section;
    int i;
    ULONG Size;

    hMappedFile = CreateFileMapping(
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        return;
    }

    LoadedImage.MappedAddress = MapViewOfFile(
                                    hMappedFile,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    0
                                    );
    CloseHandle(hMappedFile);

    if ( !LoadedImage.MappedAddress ) {
        return;
    }

    //
    // Everything is mapped. Now check the image and find nt image headers
    //

    DosHeader = (PIMAGE_DOS_HEADER)LoadedImage.MappedAddress;

    if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE ) {
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return;
    }

    LoadedImage.FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

    if ( LoadedImage.FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return;
    }

    LoadedImage.NumberOfSections = LoadedImage.FileHeader->FileHeader.NumberOfSections;
    LoadedImage.Sections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)LoadedImage.FileHeader + sizeof(IMAGE_NT_HEADERS));
    LoadedImage.LastRvaSection = LoadedImage.Sections;

    //
    // Walk through the sections and tally the dater
    //

    SectionAlignment = LoadedImage.FileHeader->OptionalHeader.SectionAlignment;

    for(Section = LoadedImage.Sections,i=0; i<LoadedImage.NumberOfSections; i++,Section++) {
        Size = Section->Misc.VirtualSize;

        if (Size == 0) {
            Size = Section->SizeOfRawData;
        }

        Size = (Size + SectionAlignment - 1) & ~(SectionAlignment - 1);

        if (!_strnicmp(Section->Name,"PAGE", 4 )) {
            Mod->PagedSize += Size;
        }
        else if (!_stricmp(Section->Name,"INIT" )) {
            Mod->InitSize += Size;
        }
        else if (!_stricmp(Section->Name,".bss" )) {
            Mod->BssSize = Size;
        }
        else if (!_stricmp(Section->Name,".edata" )) {
            Mod->ExportDataSize = Size;
        }
        else if (!_stricmp(Section->Name,".idata" )) {
            Mod->ImportDataSize = Size;
        }
        else if (!_stricmp(Section->Name,".rsrc" )) {
            Mod->ResourceDataSize = Size;
        }
        else if (Section->Characteristics & IMAGE_SCN_MEM_EXECUTE) {
            Mod->CodeSize += Size;
        }
        else if (Section->Characteristics & IMAGE_SCN_MEM_WRITE) {
            Mod->DataSize += Size;
        }
        else if (Section->Characteristics & IMAGE_SCN_MEM_READ) {
            Mod->RoDataSize += Size;
        }
        else {
            Mod->DataSize += Size;
        }
    }

    Mod->CheckSum = LoadedImage.FileHeader->OptionalHeader.CheckSum;
    Mod->TimeDateStamp = LoadedImage.FileHeader->FileHeader.TimeDateStamp;

    UnmapViewOfFile(LoadedImage.MappedAddress);
    return;

}

LONGLONG ModuleInfo[16384];

__cdecl main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    UINT BytesRequired;
    ULONG i;
    PCHAR s;
    HANDLE FileHandle;
    CHAR KernelPath[MAX_PATH];
    CHAR DriversPath[MAX_PATH];
    ULONG ReturnedLength;
    PRTL_PROCESS_MODULES Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;
    NTSTATUS Status;
    MODULE_DATA Sum;
    MODULE_DATA Current;

    //
    // Locate system drivers.
    //

    Status = NtQuerySystemInformation (
                    SystemModuleInformation,
                    ModuleInfo,
                    sizeof( ModuleInfo ),
                    &ReturnedLength);

    if (!NT_SUCCESS(Status)) {
        printf("query system info failed status - %lx\n",Status);
        return(Status);
    }

    BytesRequired = GetSystemDirectory(KernelPath,sizeof(KernelPath)/sizeof(KernelPath[0]));
    if ((BytesRequired == 0) || (BytesRequired > MAX_PATH - 1)) {
        return STATUS_NAME_TOO_LONG;
    }

    // strcpy(DriversPath,KernelPath);
    // strcat(DriversPath,"\\Drivers");
    DriversPath[sizeof(DriversPath) - 1] = 0;
    _snprintf(DriversPath, sizeof(DriversPath) - 1,
              "%s\\Drivers", KernelPath);

    ZeroMemory(&Sum,sizeof(Sum));
    PrintModuleHeader();

    Modules = (PRTL_PROCESS_MODULES)ModuleInfo;
    Module = &Modules->Modules[ 0 ];
    for (i=0; i<Modules->NumberOfModules; i++) {

        ZeroMemory(&Current,sizeof(Current));
        s = &Module->FullPathName[ Module->OffsetToFileName ];

        //
        // try to open the file
        //

        SetCurrentDirectory(KernelPath);

        FileHandle = CreateFile(
                        s,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

        if ( FileHandle == INVALID_HANDLE_VALUE ) {
            SetCurrentDirectory(DriversPath);

            FileHandle = CreateFile(
                            s,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL
                            );

            if ( ( FileHandle == INVALID_HANDLE_VALUE ) && ( argc > 1 ) ) {
                SetCurrentDirectory( argv[1] );

                FileHandle = CreateFile(
                                s,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL
                                );

            }
        }

        if ( FileHandle != INVALID_HANDLE_VALUE ) {
            GetModuleData(FileHandle,&Current);
            CloseHandle(FileHandle);
        }

        SumModuleData(&Sum,&Current);
        PrintModuleLine(s,&Current);
        Module++;
    }
    PrintModuleSeperator();
    PrintModuleLine("Total",&Sum);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\wbemperf\utils.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    utils.c

Abstract:

        Utility functions used by the performance library functions

Author:

    Russ Blake  11/15/91

Revision History:
    8-Jun-98    bobw    revised for use with WBEM functions

--*/
#define UNICODE
//
//  Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <strsafe.h>
//#include <prflbmsg.h>
//#include <regrpc.h>
#include "PerfAcc.h"
#include "strings.h"
#include "utils.h"
#include "wbprfmsg.h"
// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < '0') ? INVALID : \
     (c > '9') ? INVALID : \
     DIGIT)

// the length of "ADDEXPLAIN" in chars
#define MAX_KEYWORD_LEN     10

// minimum length to hold a value name understood by Perflib
// "foreign" is the longest "string" value understood

const   DWORD VALUE_NAME_LENGTH = ((7 + 1) * sizeof(WCHAR));

HANDLE hEventLog = NULL;

static WCHAR    LocalComputerName[WBEMPERF_STRING_SIZE];
static LPWSTR   pComputerName = &LocalComputerName[0];
static DWORD    ComputerNameLength = 0;

BOOL
MonBuildPerfDataBlock(
    PERF_DATA_BLOCK *pBuffer,
    PVOID *pBufferNext,
    DWORD NumObjectTypes,
    DWORD DefaultObject
)
/*++

    MonBuildPerfDataBlock -     build the PERF_DATA_BLOCK structure

        Inputs:

            pBuffer         -   where the data block should be placed

            pBufferNext     -   where pointer to next byte of data block
                                is to begin; DWORD aligned

            NumObjectTypes  -   number of types of objects being reported

            DefaultObject   -   object to display by default when
                                this system is selected; this is the
                                object type title index
--*/

{

    LARGE_INTEGER Time, TimeX10000;

    // Initialize Signature and version ID for this data structure

    pBuffer->Signature[0] = wc_P;
    pBuffer->Signature[1] = wc_E;
    pBuffer->Signature[2] = wc_R;
    pBuffer->Signature[3] = wc_F;

    pBuffer->LittleEndian = 1;

    pBuffer->Version = PERF_DATA_VERSION;
    pBuffer->Revision = PERF_DATA_REVISION;

    //
    //  The next field will be filled in at the end when the length
    //  of the return data is known
    //

    pBuffer->TotalByteLength = 0;

    pBuffer->NumObjectTypes = NumObjectTypes;
    pBuffer->DefaultObject = DefaultObject;
    GetSystemTime(&pBuffer->SystemTime);
    NtQueryPerformanceCounter(&pBuffer->PerfTime,&pBuffer->PerfFreq);

    TimeX10000.QuadPart = pBuffer->PerfTime.QuadPart * 10000L;
    Time.QuadPart = TimeX10000.QuadPart / pBuffer->PerfFreq.LowPart;
    pBuffer->PerfTime100nSec.QuadPart = Time.QuadPart * 1000L;

    if ( ComputerNameLength == 0) {
        // load the name
        ComputerNameLength = sizeof (LocalComputerName) / sizeof(LocalComputerName[0]);
        if (!GetComputerNameW(pComputerName, &ComputerNameLength)) {
            // name look up failed so reset length
            ComputerNameLength = 0;
        }
        assert (ComputerNameLength > 0);
    }

    //  There is a Computer name: i.e., the network is installed

    pBuffer->SystemNameLength = ComputerNameLength;
    pBuffer->SystemNameOffset = sizeof(PERF_DATA_BLOCK);
    RtlMoveMemory(&pBuffer[1],
           pComputerName,
           ComputerNameLength);
    *pBufferNext = (PVOID) ((PCHAR) &pBuffer[1] +
                            QWORD_MULTIPLE(ComputerNameLength));
    pBuffer->HeaderLength = (DWORD)((PCHAR) *pBufferNext - (PCHAR) pBuffer);

    return 0;
}

#pragma warning ( disable : 4127)   // while (TRUE) error
BOOL
MatchString (
    IN LPCWSTR lpValueArg,
    IN LPCWSTR lpNameArg
)
/*++

MatchString

    return TRUE if lpName is in lpValue.  Otherwise return FALSE

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

    IN lpName
        string for one of the keyword names

Return TRUE | FALSE

--*/
{
    BOOL    bFound      = TRUE; // assume found until contradicted
    LPWSTR  lpValue     = (LPWSTR)lpValueArg;
    LPWSTR  lpName      = (LPWSTR)lpNameArg;

    // check to the length of the shortest string

    while (1) {
        if (*lpValue != 0) {
            if (*lpName != 0) {
                if (*lpValue++ != *lpName++) {
                    bFound = FALSE; // no match
                    break;          // bail out now
                }
            } else {
                // the value still has characters, but the name is out
                // so this is no match
                bFound = FALSE;
                break;
            }
        } else {
            if (*lpName != 0) {
                // then the value is out of characters, but the name
                // is out so no match
                bFound = FALSE;
                break;
            } else {
                // both strings are at the end so it must be a match
            }
        }
    }

    return (bFound);
}
#pragma warning ( default : 4127)   // while (TRUE) error

#pragma warning ( disable : 4127)   // while (TRUE) error
DWORD
GetNextNumberFromList (
    IN LPWSTR   szStartChar,
    IN LPWSTR   *szNextChar
)
/*++

 Reads a character string from the szStartChar to the next
 delimiting space character or the end of the string and returns
 the value of the decimal number found. If no valid number is found
 then 0 is returned. The pointer to the next character in the
 string is returned in the szNextChar parameter. If the character
 referenced by this pointer is 0, then the end of the string has
 been reached.

--*/
{
    DWORD   dwThisNumber    = 0;
    WCHAR   *pwcThisChar    = szStartChar;
    WCHAR   wcDelimiter     = wcSpace;
    BOOL    bValidNumber    = FALSE;

    if (szStartChar != 0) {
        while (TRUE) {
            switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
                case DIGIT:
                    // if this is the first digit after a delimiter, then
                    // set flags to start computing the new number
                    bValidNumber = TRUE;
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - wc_0);
                    break;

                case DELIMITER:
                    // a delimter is either the delimiter character or the
                    // end of the string ('\0') if when the delimiter has been
                    // reached a valid number was found, then return it
                    //
                    if (bValidNumber || (*pwcThisChar == 0)) {
                        *szNextChar = pwcThisChar;
                        return dwThisNumber;
                    } else {
                        // continue until a non-delimiter char or the
                        // end of the file is found
                    }
                    break;

                case INVALID:
                    // if an invalid character was encountered, ignore all
                    // characters up to the next delimiter and then start fresh.
                    // the invalid number is not compared.
                    bValidNumber = FALSE;
                    break;

                default:
                    break;

            }
            pwcThisChar++;
        }
    } else {
        *szNextChar = szStartChar;
        return 0;
    }
}
#pragma warning ( default : 4127)   // while (TRUE) error

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;

    while (*pwcThisChar != 0) {
        dwThisNumber = GetNextNumberFromList (
            pwcThisChar, &pwcThisChar);
        if (dwNumber == dwThisNumber) return TRUE;
    }
    // if here, then the number wasn't found
    return FALSE;

}   // IsNumberInUnicodeList

LPWSTR
ConvertProcName(LPSTR strProcName, LPWSTR buffer, DWORD cchBuffer )
{
    ULONG  lenProcName = (strProcName == NULL) ? (0) : (lstrlenA(strProcName));
    ULONG  i;
    PUCHAR AnsiChar;

    if ((lenProcName == 0) || (lenProcName >= cchBuffer)) {
        return (LPWSTR) cszSpace;
    }

    for (i = 0; i < lenProcName; i ++) {
        AnsiChar = (PUCHAR) & strProcName[i];
        buffer[i] = (WCHAR) RtlAnsiCharToUnicodeChar(& AnsiChar);
    }
    
    buffer[lenProcName] = L'\0';

    return buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perfmtr\mminfo.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mminfo.c

Abstract:

    This module monitor the system hard page fault.

Author:

    Stephen Hsiao (shsiao) 4-8-96

Environment:

    User Mode

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define NTMMPERF 1
#if NTMMPERF
typedef enum _KTHREAD_STATE {
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition
    } KTHREAD_STATE;

char *ThreadState[] = {
    "Initialized",
    "Ready",
    "Running",
    "Standby",
    "Terminated",
    "Waiting",
    "Transition",
    };

char *WaitReason[] = {
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "WrExecutive",
    "WrFreePage",
    "WrPageIn",
    "WrPoolAllocation",
    "WrDelayExecution",
    "WrSuspended",
    "WrUserRequest",
    "WrEventPair",
    "WrQueue",
    "WrLpcReceive",
    "WrLpcReply",
    "WrVirtualMemory",
    "WrPageOut",
    "WrRendezvous",
    "Spare2",
    "Spare3",
    "Spare4",
    "Spare5",
    "Spare6",
    "WrKernel",
    "MaximumWaitReason"
    };

PSZ PoolTypeNames[7] = {
    "NonPagedPool",
    "PagedPool   ",
    "NonPagedMS  ",
    "NotUsed     ",
    "NonPagedCaAl",
    "PagedCaAl   ",
    "NonPCaAlMS  "
    };

#define CM_KEY_NODE_SIGNATURE     0x6b6e      // "kn"
#define CM_LINK_NODE_SIGNATURE    0x6b6c      // "kl"
#define CM_KEY_VALUE_SIGNATURE    0x6b76      // "kv"
#define CM_KEY_SECURITY_SIGNATURE 0x6b73      // "ks"
#define CM_KEY_FAST_LEAF          0x666c      // "fl"

#define MAX_TASKS           256
#define TableSize 4096
#define PAGE_SIZE 4096


CHAR        Mark[MAX_MMINFO_MARK_SIZE];
DWORD       pid;
CHAR        pname[MAX_PATH];
CHAR        *MmInfoBuffer;
SYSTEM_MMINFO_FILENAME_INFORMATION        ImageHash[TableSize];
SYSTEM_MMINFO_PROCESS_INFORMATION         ProcessHash[TableSize];
LONG ThreadHash[TableSize] = {-1};
LONG       BufferLength;
BOOLEAN     Debug=FALSE;
ULONG       MmInfoOnFlag=0;
ULONG       DefaultOnFlag=(MMINFO_LOG_MEMORY | 
                           MMINFO_LOG_WORKINGSET | 
                           MMINFO_LOG_HARDFAULT |
                           MMINFO_LOG_PROCESS | 
                           MMINFO_LOG_THREAD);
ULONG       DefaultDetailedOnFlag=(MMINFO_LOG_MEMORY | 
                                   MMINFO_LOG_WORKINGSET | 
                                   MMINFO_LOG_HARDFAULT |
                                   MMINFO_LOG_SOFTFAULT |
                                   MMINFO_LOG_PROCESS | 
                                   MMINFO_LOG_THREAD |
                                   MMINFO_LOG_CSWITCH |
                                   MMINFO_LOG_POOL |
                                   MMINFO_LOG_CHANGELIST);

#ifdef WS_INSTRUMENTATION
char * WsInfoHeaderFormat =
"    WsInfo,                 Process,  WorkSet,    Claim,   Access,     Age0,     Age1,     Age2,     Age3,   Shared,      Mod,   Faults,  RecentF,     Repl,    URepl,   Boosts,     Prio\n";

char * WsInfoDataFormat =
"    WsInfo, %24s, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d\n";

char * TrimHeaderFormat =
"      Trim,                 Process,  WorkSet,    Claim,      Try,      Got,   Faults,  RecentF,     Repl,    URepl,   Boosts,     Prio\n";

char * TrimDataFormat =
"      Trim, %24s, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d\n";

char * WsManagerHeaderFormat =
" WsManager,       Time,    Avail,    Claim,   Faults,   LastPF,  Counter, DesReduc,   DesFree, Action\n";

char * WsManagerDataFormat =
" WsManager, %10I64d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %s\n";

#else
char * WsInfoHeaderFormat =
"    WsInfo,                 Process,  WorkSet,   Faults,     Prio\n";

char * WsInfoDataFormat =
"    WsInfo, %24s, %8d, %8d, %8d\n";

char * TrimHeaderFormat =
"      Trim,                 Process,  WorkSet,   Faults,     Prio\n";

char * TrimDataFormat =
"      Trim, %24s, %8d, %8d, %8d\n";

char * WsManagerHeaderFormat =
" WsManager,       Time,    Avail,   Faults,   LastPF,  Counter, DesReduc,   DesFree, Action\n";

char * WsManagerDataFormat =
" WsManager, %10I64d, %8d, %8d, %8d, %8d, %8d, %8d, %s\n";

#endif // WS_INSTRUMENTATION
char * ImageLoadHeaderFormat =
" ImageLoad, BaseAddr,  EndAddr,  SectNum, Process, Name\n";

char * ImageLoadDataFormat =
" ImageLoad, %08x, %08x, %-8x, %s, %S\n";

char * SampleProfileHeaderFormat =
" SampledProfile,      EIP,  Count\n";

char * SampledProfileDataFormat =
" SampledProfile, %08x, %-8d\n";

char * GeneralHeaderFormat = "%12s,%10s,%22s,%12s,%12s,%8s,%30s,%12s,%10s,%10s,%10s\n";

ULONG       ToTurnOn=0;
ULONG       ToTurnOff=0;

CHAR System[] = "System";

#define MODE_NONE   0
#define MODE_SLASH  1
#define MODE_PLUS   2
#define MODE_MINUS  3


typedef struct Api_Address_St {
  ULONG Address;
  CHAR  *ApiName;
} Api_Address_t, *PApi_Address_t;

typedef struct Dll_Address_St {
  ULONG StartingAddress;
  ULONG EndingAddress;
  CHAR *DllName;
} Dll_Address_t, *PDll_Address_t;

PApi_Address_t GlobalApiInfo;
PDll_Address_t GlobalDllInfo;
int NumGlobalApis=0;
int NumGlobalDlls=0;
int NumAllocatedGlobalApis=0;
int NumAllocatedGlobalDlls=0;
#define AllocationIncrement 1000

VOID InsertDll(ULONG StartingAddress, ULONG EndingAddress, CHAR *DllName){

  if (NumGlobalDlls == NumAllocatedGlobalDlls ){
    if (NumGlobalDlls == 0 ){
      NumAllocatedGlobalDlls = AllocationIncrement;
      GlobalDllInfo = (PDll_Address_t)
        malloc( sizeof(Dll_Address_t) * NumAllocatedGlobalDlls);
    } else {
      NumAllocatedGlobalDlls += AllocationIncrement;
      GlobalDllInfo = (PDll_Address_t)
        realloc( GlobalDllInfo, sizeof(Dll_Address_t) * NumAllocatedGlobalDlls);
    }
  }
  if (GlobalDllInfo == NULL ){
    return;
  }
  GlobalDllInfo[ NumGlobalDlls ].StartingAddress = StartingAddress;
  GlobalDllInfo[ NumGlobalDlls ].EndingAddress   = EndingAddress;
  GlobalDllInfo[ NumGlobalDlls ].DllName         = DllName;
  NumGlobalDlls ++;
}

VOID InsertApi(ULONG Address, CHAR *ApiName){
  if (NumGlobalApis == NumAllocatedGlobalApis ){
    if (NumGlobalApis == 0 ){
      NumAllocatedGlobalApis = AllocationIncrement;
      GlobalApiInfo = (PApi_Address_t)
        malloc( sizeof(Api_Address_t) * NumAllocatedGlobalApis);
    } else {
      NumAllocatedGlobalApis += AllocationIncrement;
      GlobalApiInfo = (PApi_Address_t)
        realloc( GlobalApiInfo, sizeof(Api_Address_t) * NumAllocatedGlobalApis);
    }
  }
  if (GlobalApiInfo == NULL ){
    return;
  }
  GlobalApiInfo[ NumGlobalApis ].Address = Address;
  GlobalApiInfo[ NumGlobalApis ].ApiName = ApiName;
  NumGlobalApis ++;
}
CHAR *DllContainingAddress(ULONG Address){
  int i;
  for(i=0; i < NumGlobalDlls; i++){
    if ( GlobalDllInfo[ i ].StartingAddress <= Address &&
         Address <= GlobalDllInfo[ i ].EndingAddress){
      return   GlobalDllInfo[ i ].DllName;
    }
  }
  return "DllNotFound";
}
CHAR *ApiAtAddress(ULONG Address){
  int i;
  for(i=0; i < NumGlobalApis; i++){
    if ( GlobalApiInfo[ i ].Address == Address ){
      return   GlobalApiInfo[ i ].ApiName;
    }
  }
  return "ApiNotFound";
}


VOID
ParseArgs (
    int argc,
    char *argv[]
    )
{
    ULONG   Mode=MODE_NONE;
    char *p;
    char *Usage="\
        Usage: mminfo -Option \n\
    /c      Turn OFF hard fault clustering\n\
    /i      Initialize MmInfo (Allocate buffer)\n\
    /u      Uninitialize MmInfo (Free buffer) \n\
    /d      Turn on debugging\n\
    /f      Turn off monitoring (Keep log for later processing) \n\
    /F      Set a Mark with workingsetflush now \n\
    /M      Set a Mark now \n\
    /o      Turn on default monitoring (h,m,t, and w)\n\
    /O      Turn on detailed monitoring (plus a, l, p, and S)\n\
    +/- a   Turn on/off context switch monitor\n\
    +/- e   Turn on/off EmptyQ on every Mark\n\
    +/- E   Turn on/off EmptyQDetail (Per Process footprint) on every Mark\n\
    +/- h   Turn on/off hard fault monitor\n\
    +/- l   Turn on/off memory list monitor\n\
    +/- m   Turn on/off memory monitor\n\
    +/- p   Turn on/off pool monitor\n\
    +/- P   Turn on/off sampled profiling\n\
    +/- r   Turn on/off registry monitor\n\
    +/- R   Turn on/off registry Relocation\n\
    +/- s   Turn on/off initial snap shot of memory\n\
    +/- S   Turn on/off Soft (Demand zero and Trainsition) fault monitor\n\
    +/- t   Turn on/off thread & process monitor\n\
    +/- T   Turn on/off detailed trimming monitor\n\
    +/- w   Turn on/off working set monitor\n\
    +/- z   Turn on/off detailed working set info\n\
    +/- Z   Turn on/off dumping working set entries\n\
    Default Dump bata (Also turn off monitoring)\n\
        ";
    NTSTATUS status;
    int i;

    argc--;
    *argv++;
    while ( argc-- > 0 ) {
        p  = *argv++;

        switch (*p) {
            case '/':
                Mode = MODE_SLASH;
                break;
            case '+':
                Mode = MODE_PLUS;
                break;
            case '-':
                Mode = MODE_MINUS;
                break;
            default:
                fprintf(stderr,"%s\n", Usage);
                ExitProcess(1);
        }
        p++;

        while(*p != '\0') {
            if (Mode == MODE_SLASH) {
                switch (*p) {
                case 'c':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_NO_CLUSTERING;
                    break;
                case 'd':
                    Debug=TRUE;
                    break;
                case 'f':
                    status = NtSetSystemInformation (
                                  SystemMmInfoLogOffInformation,
                                  NULL,
                                  0);
                    if (!NT_SUCCESS (status)) {
                        fprintf(stderr,"Set system information failed %lx\n",status);
                    }else{
                        fprintf(stderr,"Monitor Off\n");
                    }
                    ExitProcess(0);
                case 'i':
                    status = NtSetSystemInformation (
                                  SystemMmInfoInitializeInformation,
                                  NULL,
                                  0);
                    if (!NT_SUCCESS (status)) {
                        fprintf(stderr, "Set system information failed %lx\n",status);
                    }else{
                        fprintf(stderr,"buffer allocated\n");
                    }
                    ExitProcess(0);
                case 'F':
                case 'M':
                {
                    BOOLEAN Flush = (*p == 'F') ? TRUE : FALSE;
                    p++;
                    while(*p == '\0') {
                        p++;
                    }

                    i=-1;

                    if (*p == '/' || *p == '+' || *p == '-') {
                        // Nothing in the Mark
                        fprintf(stderr, "Mark not set!\n");
                        fprintf(stderr,"%s\n", Usage);
                        ExitProcess(0);
                    } else if (*p == '"') {
                        p++;
                        while(*p != '"') {
                            if (i < MAX_MMINFO_MARK_SIZE) {
                                i++;
                                Mark[i] = *p;
                            }
                            p++;
                        }
                    } else {
                        while (*p != '\0') {
                            if (i < MAX_MMINFO_MARK_SIZE) {
                                i++;
                                Mark[i] = *p;
                            }
                            p++;
                        }
                    }
                    
                    status = NtSetSystemInformation (
                                Flush ? SystemMmInfoMarkWithFlush
                                      : SystemMmInfoMark,
                                Mark,
                                MAX_MMINFO_MARK_SIZE);

                    if (!NT_SUCCESS (status)) {
                        fprintf(stderr, "Set system information failed %lx\n",status);
                    }else{
                        fprintf(stderr, "Mark set: %s\n", Mark);
                    }
                    ExitProcess(0);
                }
                case 'o':
                    MmInfoOnFlag = DefaultOnFlag;
                    break;
                case 'O':
                    MmInfoOnFlag = DefaultDetailedOnFlag;
                    break;
                case 'u':
                    status = NtSetSystemInformation (
                                  SystemMmInfoUnInitializeInformation,
                                  NULL,
                                  0);
                    if (!NT_SUCCESS (status)) {
                        fprintf(stderr,"Set system information failed %lx\n",status);
                    }else{
                        fprintf(stderr,"Unitialized\n");
                    }
                    ExitProcess(0);
                default:
                    fprintf(stderr,"%s\n", Usage);
                    ExitProcess(1);
                }
            } else if (Mode == MODE_PLUS) {
                switch (*p) {
                case 'a':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_PROCESS |
                                    MMINFO_LOG_THREAD | MMINFO_LOG_CSWITCH;
                    break;
                case 'e':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_MEMORY | MMINFO_LOG_EMPTYQ | MMINFO_LOG_PROCESS;
                    break;
                case 'E':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_MEMORY | MMINFO_LOG_EMPTYQ
                                        | MMINFO_LOG_EMPTYQDETAIL | MMINFO_LOG_PROCESS;
                    break;
                case 'm':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_MEMORY | MMINFO_LOG_PROCESS;
                    break;
                case 'p':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_POOL;
                    break;
                case 'w':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_WORKINGSET | MMINFO_LOG_PROCESS; 
                    break;
                case 't':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_PROCESS | MMINFO_LOG_THREAD;
                    break;
                case 'T':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_WSCHANGE | 
                               MMINFO_LOG_MEMORY | MMINFO_LOG_PROCESS; 
                    break;
                case 'h':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_HARDFAULT | MMINFO_LOG_PROCESS;
                    break;
                case 'l':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_CHANGELIST | MMINFO_LOG_MEMORY;
                    break;
                case 'r':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_REGISTRY;
                    break;
                case 'R':
                    status = NtSetSystemInformation (
                                  SystemRelocateCMCellOn,
                                  NULL,
                                  0);
                    if (!NT_SUCCESS (status)) {
                        fprintf(stderr,"Set system information failed %lx\n",status);
                    }else{
                        fprintf(stderr,"Registry Relocation on\n");
                    }
                    ExitProcess(0);
                case 's':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_INIT_MEMSNAP;
                    break;
                case 'S':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_SOFTFAULT | 
                               MMINFO_LOG_PROCESS | MMINFO_LOG_MEMORY;
                    break;
                case 'z':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_WSDETAILS;
                    break;
                case 'Z':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_WSENTRIES;
                    break;
                case 'P':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_PROFILE;
                    break;
                default:
                    fprintf(stderr,"%s\n", Usage);
                    ExitProcess(1);
                }
            } else if (Mode == MODE_MINUS) {
                switch (*p) {
                case 'a':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_CSWITCH ;
                    break;
                case 'e':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_EMPTYQ;
                    break;
                case 'E':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_EMPTYQDETAIL;
                    break;
                case 'm':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_MEMORY ;
                    break;
                case 'p':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_POOL;
                    break;
                case 'w':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_WORKINGSET;
                    break;
                case 't':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_PROCESS |
                                        MMINFO_LOG_THREAD | MMINFO_LOG_CSWITCH;
                    break;
                case 'T':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_WSCHANGE;
                    break;
                case 'h':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_HARDFAULT;
                    break;
                case 'l':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_CHANGELIST;
                    break;
                case 'r':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_REGISTRY;
                    break;
                case 'R':
                    status = NtSetSystemInformation (
                                  SystemRelocateCMCellOff,
                                  NULL,
                                  0);
                    if (!NT_SUCCESS (status)) {
                        fprintf(stderr,"Set system information failed %lx\n",status);
                    }else{
                        fprintf(stderr,"Registry Relocation off\n");
                    }
                    ExitProcess(0);
                case 's':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_INIT_MEMSNAP;
                    break;
                case 'S':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_SOFTFAULT;
                    break;
                case 'z':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_WSDETAILS;
                    break;
                case 'Z':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_WSENTRIES;
                    break;
                case 'P':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_PROFILE;
                    break;
                default:
                    fprintf(stderr,"%s\n", Usage);
                    ExitProcess(1);
                }
            }
            p++;
        }
    }
}
#endif //NTMMPERF

int _cdecl
main(
    int argc,
    char *argv[]
    )
{
#if NTMMPERF
    LPSTR          p;
    NTSTATUS status;
    ULONG ImageStart, ImageEnd;
    ULONG ProcessStart, ProcessEnd;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    ULONG TotalPageTable;
    ULONG TotalModified;
    ULONG TotalTransition;
    SYSTEMTIME Time;
    ULONG PageKb;
    ULONG LogSize;
    
    ULONG  LogType;
    _int64 *TmpPint64;
    _int64 PerfCounter, PerfCounterStart;
    _int64 PerfFrequency;

    PerfHook_t *Hook, *NextHook;
    TimeStamp_t TS;
    PerfSize_t  Size;
    PerfTag_t   Tag;
    PerfData_t  *Info;
    ULONG i;

    //
    // First parse the arguments and see what to do.
    //
    ParseArgs( argc, argv );

    if (ToTurnOn & ToTurnOff) {
        fprintf(stderr,"Cannot turn on and off the same flag, make up your mind !!!\n");
    }else{
        MmInfoOnFlag=((MmInfoOnFlag | ToTurnOn) & ~ToTurnOff);
    }

    //
    // If there is a flag to turn on. Do it.
    //

    if (MmInfoOnFlag) {
        status = NtSetSystemInformation (
                  SystemMmInfoLogOnInformation,
                  &MmInfoOnFlag,
                  sizeof(ULONG));
        if (!NT_SUCCESS (status)) {
            fprintf(stderr,"Set system information failed ON %lx\n",status);
            return 1;
        }else{
            fprintf(stderr,"Monitor On\n");
            return 0;
        }
    }

    //
    // If we reach this point, we are do dump the log.
    // First turn off monitor.
    //

    status = NtSetSystemInformation (SystemMmInfoLogOffInformation,
                                     NULL,
                                     0);
    if (!NT_SUCCESS (status)) {
        fprintf(stderr,"Set system information failed %lx\n",status);
        return 1;
    }

    //
    // HACK FIXFIX when doing MP stuff
    //
    ThreadHash[0] = 0;
    ProcessHash[0].ProcessID = 0;
    RtlCopyMemory(ProcessHash[0].ImageFileName, "Idle", 16);

    status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if (!NT_SUCCESS (status)) {
        fprintf(stderr,"query system basic information failed %lx\n",status);
        return 1;
    }

    PageKb = BasicInfo.PageSize / 1024;

    // 
    // print the Headers
    //

    printf(WsManagerHeaderFormat);
    printf(WsInfoHeaderFormat);
    printf(TrimHeaderFormat );
    printf(ImageLoadHeaderFormat);
    printf(SampleProfileHeaderFormat);


    //
    // Mow dump the buffer.
    //
    NextHook = PerfNextHook();
    Hook     = PerfFirstHook();

    LogSize = (ULONG) NextHook  - (ULONG) Hook;
    // fprintf(stderr, "Size in Pages %8d\n", PerfQueryBufferSize4KPages());
    // fprintf(stderr, "Size in Bytes %8d\n", PerfQueryBufferSizeBytes());
    // fprintf(stderr, "Size in KBs   %8d\n", PerfQueryBufferSizeKB());
  
    // fprintf(stderr, "Size in Bytes %8d (%8x - %8x) \n", NextHook - Hook, Hook, NextHook);

    while( Hook < NextHook ){
        ULONG LogType;
        Hook = (PerfHook_t *)PerfGetHook(Hook, &Tag, &TS, &Size, &Info );
        LogType = Tag.u.Bits.HookId;
        // LogType = Tag.u.Value;

        // PerfCounter = 0xffffffffffffffff;
        PerfCounter = TS;

        if (Debug) {
            // fprintf(stdout, "%8x: LogType %4d, Size:%4d, Time: %I64u\n",Hook, LogType, Size, PerfCounter);
        }

        switch(LogType) {
          printf ("LogType=%08x\n", LogType);
        case PERF_APIMON_DLL_ADDRESS:
          {
            PPerf_Apimon_Dll_Address_t DllInfo;
            DllInfo = (PPerf_Apimon_Dll_Address_t) Info;
            InsertDll(DllInfo->StartingAddress,
                      DllInfo->EndingAddress,
                      DllInfo->DllName);
            printf ("DllAddressName %08x %08x %s\n", 
                    DllInfo->StartingAddress,
                    DllInfo->EndingAddress,
                    DllInfo->DllName);
          }
        break;
        case PERF_APIMON_API_ADDRESS:
          {
            PPerf_Apimon_Api_Address_t ApiInfo;
            ApiInfo = (PPerf_Apimon_Api_Address_t) Info;
            InsertApi(ApiInfo->Address,
                      ApiInfo->ApiName);
            printf ("ApiAddressName %08x %s\n", 
                    ApiInfo->Address,
                    ApiInfo->ApiName);
          }
        break;
        case PERF_APIMON_ENTER:
          {
            PPerf_Apimon_Enter_t PEnter;
            PEnter = (PPerf_Apimon_Api_Address_t) Info;
            printf ("ApiEnter %08x %s %s\n", 
                    PEnter->Address, 
                    DllContainingAddress(PEnter->Address), 
                    ApiAtAddress(PEnter->Address));
          }
        break;
        case PERF_APIMON_EXIT:
          {
            PPerf_Apimon_Enter_t PExit;
            PExit = (PPerf_Apimon_Api_Address_t) Info;
            printf ("ApiExit  %08x %s %s\n", 
                    PExit->Address,
                    DllContainingAddress(PExit->Address), 
                    ApiAtAddress(PExit->Address));
          }
        break;

            case MMINFO_LOG_TYPE_VERSION:
            {
                PSYSTEM_MMINFO_VERSION_INFORMATION TmpPMmInfoVersion;
                
                TmpPMmInfoVersion = (PSYSTEM_MMINFO_VERSION_INFORMATION) Info;

                if (TmpPMmInfoVersion->Version  != MMINFO_VERSION) {
                    fprintf(stderr, "Kernel Version:%4d mismatch with User Version:%d\n",
                            TmpPMmInfoVersion->Version,
                            MMINFO_VERSION
                    );
                    ExitProcess(1);
                } else {
                    fprintf(stderr, "Version: %4d, BufferSize = %6d KB\n", 
                            MMINFO_VERSION, 
                            LogSize/1024);
                    fprintf(stdout, "Version, %4d, BufferSize, %6d KB\n", 
                            MMINFO_VERSION, 
                            LogSize/1024);
                }
            }
            break;

            case MMINFO_LOG_TYPE_PERFFREQUENCY:
            {
                PMMINFO_TIME_FREQUENCY TimeFreq;

                TimeFreq = (PMMINFO_TIME_FREQUENCY) Info;

                PerfFrequency = TimeFreq->Frequency;
                
                PerfCounterStart = TimeFreq->Time;

                printf("Log start at (Performance Counter), %I64d\n",
                            PerfCounterStart*1000000/PerfFrequency);
            }
            break;

            case MMINFO_LOG_TYPE_FILENAMEBUFFER:
            {
                PSYSTEM_MMINFO_FILENAME_INFORMATION TmpPImage;

                TmpPImage = (PSYSTEM_MMINFO_FILENAME_INFORMATION) Info;

                while (TmpPImage->ImageKey) {
                    i=TmpPImage->ImageKey%TableSize;

                    while(ImageHash[i].ImageKey != 0) {
                        if (ImageHash[i].ImageKey == TmpPImage->ImageKey) {
                            break;
                        }else{
                            i = (i+1)%TableSize;
                        }
                    }

                    ImageHash[i].ImageKey =TmpPImage->ImageKey;
                    ImageHash[i].ImageName.Length =TmpPImage->ImageName.Length;
                    ImageHash[i].ImageName.Buffer =TmpPImage->ImageBuffer;
                    if (Debug) {
                        printf("%12s,", "S-Created");
                    }

                    if (Debug) {
                        printf("%10s,%22s,%12s,%12x,%8s,%30S,%12s,%10s,%10s\n",
                            "",
                            "",
                            "",
                            ImageHash[i].ImageKey,
                            "",
                            ImageHash[i].ImageName.Buffer,
                            "",
                            "",
                            "");
                    }
                    TmpPImage++;
                }
            }
            break;
            case MMINFO_LOG_TYPE_PAGEFAULT:
                {
                    PSYSTEM_HARDPAGEFAULT_INFORMATION TmpPMmInfoLog;

                    TmpPMmInfoLog=(PSYSTEM_HARDPAGEFAULT_INFORMATION) Info;

                    printf("%12s,","HardFault");
                    printf("%10I64d,",
                            (PerfCounter - PerfCounterStart)*1000000/PerfFrequency);
                    
                    if (TmpPMmInfoLog->ProcessID == 0) {
                        printf("%22s,","System (  0)");
                    } else{
                        ULONG i;

                        i = TmpPMmInfoLog->ProcessID;

                        if (ProcessHash[i].ProcessID == TmpPMmInfoLog->ProcessID) {
                            printf("%16s ",ProcessHash[i].ImageFileName);
                            printf("(%3d),",ProcessHash[i].ProcessID);
                        }else{
                            printf("Process %13u,",TmpPMmInfoLog->ProcessID);
                        }
                    }
                    printf("%12u,",TmpPMmInfoLog->ThreadID);
                    printf("%12x,",TmpPMmInfoLog->Va);
                    printf("%8u,",TmpPMmInfoLog->Pfn);
                    {
                        ULONG i;

                        i=TmpPMmInfoLog->ImageKey%TableSize;

                        while(ImageHash[i].ImageKey != 0) {
                            if (ImageHash[i].ImageKey == TmpPMmInfoLog->ImageKey) {
                                printf("%30S,",ImageHash[i].ImageName.Buffer);
                                break;
                            }else{
                                i = (i+1)%TableSize;
                            }
                        }
                        if (ImageHash[i].ImageKey == 0) {
                            if (TmpPMmInfoLog->Va >= 0x8000000) {
                                printf("%30s,","pagefile.sys");
                            } else { 
                                printf("%19s (%8x),","Image", TmpPMmInfoLog->ImageKey);
                            }
                        }
                    }
                    printf("%12I64d,",TmpPMmInfoLog->ReadOffset);
                    printf("%10u,",TmpPMmInfoLog->ByteCount);
                    if (TmpPMmInfoLog->FaultType == 3) {
                        printf("%10s,","Read");
                    } else if (TmpPMmInfoLog->FaultType == 2) {
                        printf("%10s,","Code");
                    } else if (TmpPMmInfoLog->FaultType == 1) {
                        printf("%10s,","Data");
                    } else {
                        printf("%10s,","NA");
                    }

                    printf("%10I64d",
                            (TmpPMmInfoLog->IoCompleteTime-PerfCounter)
                            *1000000/PerfFrequency);
        
                    printf("\n");

                    // printf("Got Page Fault Log\n");

                    break;
                }
            case MMINFO_LOG_TYPE_TRANSITIONFAULT:
            case MMINFO_LOG_TYPE_DEMANDZEROFAULT:
            case MMINFO_LOG_TYPE_ADDVALIDPAGETOWS:
            case MMINFO_LOG_TYPE_PROTOPTEFAULT:
            case MMINFO_LOG_TYPE_ADDTOWS:
                {
                    PSYSTEM_MMINFO_SOFTFAULT_INFORMATION TmpPMmInfoLog;

                    TmpPMmInfoLog=(PSYSTEM_MMINFO_SOFTFAULT_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_TRANSITIONFAULT) {
                        printf("%12s,","TransFault");
                    } else if (LogType == MMINFO_LOG_TYPE_DEMANDZEROFAULT) {
                        printf("%12s,","DeZeroFault");
                    } else if (LogType == MMINFO_LOG_TYPE_ADDVALIDPAGETOWS) {
                        printf("%12s,","AddValidToWS");
                    } else if (LogType == MMINFO_LOG_TYPE_PROTOPTEFAULT) {
                        printf("%12s,","ProtoFault");
                    } else if (LogType == MMINFO_LOG_TYPE_ADDTOWS) {
                        printf("%12s,","AddToWS");
                    } else {
                        printf("%12s,","Unknown");
                    }

                    printf("%10s,", "");
                    
                    if (TmpPMmInfoLog->ProcessID == -1) {
                        printf("%22s,","SystemCache");
                    } else{
                        ULONG i;

                        i = TmpPMmInfoLog->ProcessID;

                        if (ProcessHash[i].ProcessID == TmpPMmInfoLog->ProcessID) {
                            printf("%16s ",ProcessHash[i].ImageFileName);
                            printf("(%3d),",ProcessHash[i].ProcessID);
                        }else{
                            printf("Process %13u,",TmpPMmInfoLog->ProcessID);
                        }
                    }
                    printf("%12u,",TmpPMmInfoLog->ThreadID);
                    printf("%12x,",TmpPMmInfoLog->Va);
                    printf("%8u",TmpPMmInfoLog->Pfn);
        
                    printf("\n");

                    break;
                }
            case MMINFO_LOG_TYPE_WORKINGSETSNAP:
                {
                    PSYSTEM_MMINFO_WSENTRY_INFORMATION TmpPWs;
                    PMMINFO_WSENTRY TmpPWsEntry;
                    ULONG   Size;
                    ULONG   ii;
                    UCHAR   Process[22];

                    TmpPWs = (PSYSTEM_MMINFO_WSENTRY_INFORMATION) Info;

                    Size = TmpPWs->WsSize;
                    TmpPWsEntry = TmpPWs->Ws;

                    if (TmpPWs->ProcessID == -1) {
                        sprintf(Process,"%22s","SystemCache");
                    } else {
                        ULONG i;
                        i = TmpPWs->ProcessID;
                        if (ProcessHash[i].ProcessID == TmpPWs->ProcessID) {
                            sprintf(Process, "%16s (%3d)", 
                                    ProcessHash[i].ImageFileName,
                                    ProcessHash[i].ProcessID);
                        }else{
                            sprintf(Process,"Process %13u",TmpPWs->ProcessID);
                        }
                    }

                    for (ii = 1; ii <= Size; ii++) {
                        printf("%12s,%10s,%22s,%12u,%12x,%8u,%s,%s",
                                    "WsSnap",
                                    "",
                                    Process,
                                    ii,
                                    TmpPWsEntry->Va.Page << 12,
                                    TmpPWsEntry->Pa.Page,
                                    TmpPWsEntry->Pa.Accessed ?
                                        "Accessed" : "NotAccessed",
                                    TmpPWsEntry->Pa.Modified ?
                                        "Modified" : "NotModified",
                                    TmpPWsEntry->Pa.Shared ?
                                        "Shared" : "NotShared"
                                    );
#ifdef WS_INSTRUMENTATION_ACCESS_BIT
                        printf(",%s",
                                    TmpPWsEntry->Pa.RecentlyUsed ?
                                        "RecentlyUsed" : "NotRecentlyUsed"
                                    );
#endif // WS_INSTRUMENTATION_ACCESS_BIT
                        printf("\n");
                        TmpPWsEntry++;
                    }

                    // printf("Size = %d\n", Size);

                    break;
                }
            case MMINFO_LOG_TYPE_OUTWS_REPLACEUSED:
            case MMINFO_LOG_TYPE_OUTWS_REPLACEUNUSED:
            case MMINFO_LOG_TYPE_OUTWS_VOLUNTRIM:
            case MMINFO_LOG_TYPE_OUTWS_FORCETRIM:
            case MMINFO_LOG_TYPE_OUTWS_ADJUSTWS:
            case MMINFO_LOG_TYPE_OUTWS_EMPTYQ:
                {
                    PSYSTEM_MMINFO_WSCHANGE_INFORMATION TmpPMmInfoLog;

                    TmpPMmInfoLog=(PSYSTEM_MMINFO_WSCHANGE_INFORMATION) Info;

                    printf("%12s,","Out_Of_WS");

                    if (LogType == MMINFO_LOG_TYPE_OUTWS_REPLACEUSED) {
                        printf("%10s,","RepUsed");
                    } else if (LogType == MMINFO_LOG_TYPE_OUTWS_REPLACEUNUSED) {
                        printf("%10s,","RepUnUsed");
                    } else if (LogType == MMINFO_LOG_TYPE_OUTWS_VOLUNTRIM) {
                        printf("%10s,","VolunTrim");
                    } else if (LogType == MMINFO_LOG_TYPE_OUTWS_FORCETRIM) {
                        printf("%10s,","ForceTrim");
                    } else if (LogType == MMINFO_LOG_TYPE_OUTWS_ADJUSTWS) {
                        printf("%10s,","AdjustWs");
                    } else if (LogType == MMINFO_LOG_TYPE_OUTWS_EMPTYQ) {
                        printf("%10s,","EmptyQ");
                    } else {
                        printf("%10s,","Unknown");
                    }

                    if (TmpPMmInfoLog->ProcessID == 0) {
                        printf("%22s,","SystemCache");
                    } else{
                        ULONG i;

                        i = TmpPMmInfoLog->ProcessID;

                        if (ProcessHash[i].ProcessID == TmpPMmInfoLog->ProcessID) {
                            printf("%16s ",ProcessHash[i].ImageFileName);
                            printf("(%3d),",ProcessHash[i].ProcessID);
                        }else{
                            printf("Process %13u,",TmpPMmInfoLog->ProcessID);
                        }
                    }
                    printf("%12s,","");
                    printf("%12x,",TmpPMmInfoLog->Entry.Va.Page << 12);
                    printf("%8u",TmpPMmInfoLog->Entry.Pa.Page);
        
                    printf("\n");

                    break;
                }
            case MMINFO_LOG_TYPE_WSINFOCACHE:
            case MMINFO_LOG_TYPE_TRIMCACHE:
            case MMINFO_LOG_TYPE_WSINFOPROCESS:
            case MMINFO_LOG_TYPE_TRIMPROCESS:
                {
                    PSYSTEM_MMINFO_TRIMPROCESS_INFORMATION TmpPMmInfoTrimProcess;
                    
                    TmpPMmInfoTrimProcess = (PSYSTEM_MMINFO_TRIMPROCESS_INFORMATION) Info;

                    if ((LogType == MMINFO_LOG_TYPE_WSINFOPROCESS) ||
                        (LogType == MMINFO_LOG_TYPE_WSINFOCACHE)) {
                        printf("%12s,","WsInfo");
                    } else {
                        printf("%12s,","Triming");
                    }
                    printf("WS:%7d,", TmpPMmInfoTrimProcess->ProcessWorkingSet);

                    if ((LogType == MMINFO_LOG_TYPE_TRIMCACHE) ||
                        (LogType == MMINFO_LOG_TYPE_WSINFOCACHE)) {
                            printf("%22s,","SystemCache");
                    } else{
                        if (TmpPMmInfoTrimProcess->ProcessID == 0) {
                            printf("%30s,","System (  0)");
                        } else {
                            ULONG i;
                        
                            i = TmpPMmInfoTrimProcess->ProcessID;
                        
                            if (ProcessHash[i].ProcessID == TmpPMmInfoTrimProcess->ProcessID) {
                                printf("%16s ",ProcessHash[i].ImageFileName);
                                printf("(%3d),",ProcessHash[i].ProcessID);
                            }else{
                                printf("Process %13u,",TmpPMmInfoTrimProcess->ProcessID);
                            }
                        }
                    }
                    printf("Need:%7d,", TmpPMmInfoTrimProcess->ToTrim);
                    printf("Got:%8d,", TmpPMmInfoTrimProcess->ActualTrim);
                    printf("Pri:%4d,", TmpPMmInfoTrimProcess->ProcessMemoryPriority);
                    printf("PageFaults:%8d,", 
                            TmpPMmInfoTrimProcess->ProcessPageFaultCount-
                            TmpPMmInfoTrimProcess->ProcessLastPageFaultCount);
                    if ((LogType == MMINFO_LOG_TYPE_WSINFOPROCESS) ||
                        (LogType == MMINFO_LOG_TYPE_WSINFOCACHE)) {
                        printf("Acc:%4d,",
                                TmpPMmInfoTrimProcess->ProcessAccessedCount);
                        printf("Mod:%4d,",
                                TmpPMmInfoTrimProcess->ProcessModifiedCount);
                        printf("Shd:%4d,",
                                TmpPMmInfoTrimProcess->ProcessSharedCount);
#ifdef WS_INSTRUMENTATION_ACCESS_BIT
                        printf("RUsed:%4d,",
                                TmpPMmInfoTrimProcess->ProcessRecentlyUsedCount);
#endif // WS_INSTRUMENTATION_ACCESS_BIT
                    }
#ifdef WS_INSTRUMENTATION
                    printf("Replacments:%5d,",
                            TmpPMmInfoTrimProcess->ProcessReplacementCount);

                    printf("QuotaBoosts:%5d,",
                            TmpPMmInfoTrimProcess->ProcessQuotaBoostCount);
                    printf("UsedRepls:%5d,",
                            TmpPMmInfoTrimProcess->ProcessSparecount3);
                    printf("FaultsSinceQInc:%5d,",
                            TmpPMmInfoTrimProcess->ProcessPageFaultCount-
                            TmpPMmInfoTrimProcess->ProcessLastGrowthFaultCount);
                    printf("FaultSinceFGTrim:%5d,",
                            TmpPMmInfoTrimProcess->ProcessPageFaultCount -
                            TmpPMmInfoTrimProcess->
                                    ProcessLastForegroundTrimFaultCount);
                    printf("Spare4:%5d,",
                            TmpPMmInfoTrimProcess->ProcessSparecount4);
                    printf("Spare5:%2d,",
                            TmpPMmInfoTrimProcess->ProcessSparecount5);
#endif // WS_INSTRUMENTATION
                    printf("\n");
                    
                    break;
                }
            case MMINFO_LOG_TYPE_POOLSTAT:
            case MMINFO_LOG_TYPE_ADDPOOLPAGE:
            case MMINFO_LOG_TYPE_FREEPOOLPAGE:
                {
                    PSYSTEM_MMINFO_POOL_INFORMATION TmpPMmInfoPool;
                    
                    TmpPMmInfoPool = (PSYSTEM_MMINFO_POOL_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_ADDPOOLPAGE) {
                        printf("%12s,","AddPoolPage");
                    } else if (LogType == MMINFO_LOG_TYPE_FREEPOOLPAGE) {
                        printf("%12s,","FreePoolPage");
                    } else{
                        printf("%12s,","PoolSummary");
                    }

                    printf("%10s,%22d,%12s,%12x,%8d,%8d,%8d,%12d,%12d\n",
                        "",
                        (int) TmpPMmInfoPool->Pool /100,
                        PoolTypeNames[(TmpPMmInfoPool->Pool%100) & 7],
                        TmpPMmInfoPool->Entry,
                        TmpPMmInfoPool->Alloc,
                        TmpPMmInfoPool->DeAlloc,
                        TmpPMmInfoPool->TotalPages,
                        TmpPMmInfoPool->TotalBytes,
                        // TmpPMmInfoPool->TotalBytes*100/4096/TmpPMmInfoPool->TotalPages,
                        // TmpPMmInfoPool->TotalBigBytes,
                        TmpPMmInfoPool->TotalBigPages
                        // TmpPMmInfoPool->TotalBigBytes*100/4096/TmpPMmInfoPool->TotalBigPages
                    );
            
                    break;
                }
            case MMINFO_LOG_TYPE_WORKINGSETMANAGER:
                {
                    PSYSTEM_WORKINGSETMANAGER_INFORMATION  TmpPWorkingSetManager;
                    char *ActionString;

                    TmpPWorkingSetManager = (PSYSTEM_WORKINGSETMANAGER_INFORMATION) Info;

                    switch(TmpPWorkingSetManager->Action) {
                        case WS_ACTION_RESET_COUNTER:
                            ActionString = "Reset Counter";
                        break;
                        case WS_ACTION_NOTHING:
                            ActionString = "Nothing";
                        break;
                        case WS_ACTION_INCREMENT_COUNTER:
                            ActionString = "Increment Counter";
                        break;
                        case WS_ACTION_WILL_TRIM:
                            ActionString = "Start Trimming";
                        break;
                        case WS_ACTION_FORCE_TRIMMING_PROCESS:
                            ActionString = "Force Trim";
                        break;
                        case WS_ACTION_WAIT_FOR_WRITER:
                            ActionString = "Wait writter";
                        break;
                        case WS_ACTION_EXAMINED_ALL_PROCESS:
                            ActionString = "All Process Examed";
                        break;
                        case WS_ACTION_AMPLE_PAGES_EXIST:
                            ActionString = "Ample Pages Exist";
                        break;
                        case WS_ACTION_END_WALK_ENTRIES:
                            ActionString = "Finished Walking WsEntries";
                        break;
                        default:
                            ActionString = "Unknown Action";
                        break;
                    }

                    printf(WsManagerDataFormat,
                            (PerfCounter - PerfCounterStart) *1000000/PerfFrequency,
                            TmpPWorkingSetManager->Available,
                            TmpPWorkingSetManager->PageFaultCount,
                            TmpPWorkingSetManager->LastPageFaultCount,
                            TmpPWorkingSetManager->MiCheckCounter,
                            TmpPWorkingSetManager->DesiredReductionGoal,
                            TmpPWorkingSetManager->DesiredFreeGoal,
                            ActionString
                            );
                    
                    break;
                }
            case MMINFO_LOG_TYPE_REMOVEPAGEFROMLIST:
            case MMINFO_LOG_TYPE_REMOVEPAGEBYCOLOR:
            case MMINFO_LOG_TYPE_PAGEINMEMORY:
            case MMINFO_LOG_TYPE_MEMORYSNAP:
            case MMINFO_LOG_TYPE_SETPFNDELETED:
            case MMINFO_LOG_TYPE_DELETEKERNELSTACK:
                {
                    PSYSTEM_REMOVEDPAGE_INFORMATION TmpPRemovedPage;

                    TmpPRemovedPage=(PSYSTEM_REMOVEDPAGE_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_PAGEINMEMORY) {
                        printf("%12s,","InMemory");
                    }else if (LogType == MMINFO_LOG_TYPE_MEMORYSNAP) {
                        printf("%12s,","MemSnap");
                    }else if (LogType == MMINFO_LOG_TYPE_SETPFNDELETED) {
                        printf("%12s,","PfnDeleted");
                    }else if (LogType == MMINFO_LOG_TYPE_DELETEKERNELSTACK) {
                        printf("%12s,","DeleteStack");
                    }else {
                        printf("%12s,","PageRemoved");
                    }

                    printf("%10I64d,",
                            (PerfCounter - PerfCounterStart)
                            *1000000/PerfFrequency);

                    printf("%22s,","");
                    printf("%12x,",TmpPRemovedPage->Pte);
                    // printf("%30S,",.ImageName.Buffer);
                    switch(TmpPRemovedPage->UsedFor) {
                        case MMINFO_PAGE_USED_FOR_PAGEDPOOL:
                            printf("%12x,",TmpPRemovedPage->Pte<<10);
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Paged Pool");
                            printf("%12s,%10s,%10s,","","","PagedPool");
                        break;
                        case MMINFO_PAGE_USED_FOR_NONPAGEDPOOL:
                            printf("%12x,",TmpPRemovedPage->Pte<<10);
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","NonPaged Pool");
                            printf("%12s,%10s,%10s,","","","NonPagedP");
                        break;
                        case MMINFO_PAGE_USED_FOR_KERNELSTACK:
                            printf("%12x,",TmpPRemovedPage->Pte<<10);
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Kernel Stack");
                            printf("%12s,%10s,%10s,","","","K-Stack");
                        break;
                        case MMINFO_PAGE_USED_FOR_FREEPAGE:
                            printf("%12s,","");
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Free Page");
                            printf("%12s,%10s,%10s,","","","Free");
                        break;
                        case MMINFO_PAGE_USED_FOR_ZEROPAGE:
                            printf("%12s,","");
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Zero Page");
                            printf("%12s,%10s,%10s,","","","Zero");
                        break;
                        case MMINFO_PAGE_USED_FOR_BADPAGE:
                            printf("%12s,","");
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Bad Page");
                            printf("%12s,%10s,%10s,","","","Bad");
                        break;
                        case MMINFO_PAGE_USED_FOR_UNKNOWN:
                            printf("%12s,","");
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Unknown");
                            printf("%12s,%10s,%10s,","","","Unknown");
                        break;
                        case MMINFO_PAGE_USED_FOR_METAFILE:
                            printf("%12s,","");
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Meta File");
                            printf("%12s,%10s,%10s,","","","Meta");
                        break;
                        case MMINFO_PAGE_USED_FOR_NONAME:
                            printf("%12s,","");
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","No Name");
                            printf("%12s,%10s,%10s,","","","Image");
                        break;
                        case MMINFO_PAGE_USED_FOR_PAGEFILEMAPPED:
                            printf("%12x,",TmpPRemovedPage->Pte<<10);
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Page File Mapped");
                            printf("%12s,%10s,%10s,","","","PFMapped");
                        break;
                        case MMINFO_PAGE_USED_FOR_FILE:
                        case MMINFO_PAGE_USED_FOR_KERNMAP:
                        {
                            ULONG i,j;

                            if (TmpPRemovedPage->UsedFor != MMINFO_PAGE_USED_FOR_KERNMAP) {
                                printf("%12s,","");
                            } else {
                                printf("%12x,",TmpPRemovedPage->Pte << 10);
                            }
                            printf("%8u,",TmpPRemovedPage->Pfn);

                            i=TmpPRemovedPage->ImageKey%TableSize;
    
                            while(ImageHash[i].ImageKey != 0) {
                                if (ImageHash[i].ImageKey == TmpPRemovedPage->ImageKey) {
                                    printf("%30S,",ImageHash[i].ImageName.Buffer);
                                    break;
                                }else{
                                    i = (i+1)%TableSize;
                                }
                            }

                            if (Debug) {
                                // printf("(%4d   %22x)",i,TmpPRemovedPage->ImageKey);
                            }
                            
                            if (ImageHash[i].ImageKey == 0) {
                                if (TmpPRemovedPage->UsedFor != MMINFO_PAGE_USED_FOR_KERNMAP) {
                                    printf("%19s (%8x),","Image", TmpPRemovedPage->ImageKey);
                                    printf("%12I64d,",TmpPRemovedPage->Offset);
                                    printf("%10s,","");
                                    printf("%10s,","FILE");
                                }else{
                                    printf("%19s (%8x),","KernMap", TmpPRemovedPage->ImageKey);
                                    printf("%12s,%10s,","","");
                                    printf("%10s,","Driver");
                                }
                            }else{
                                if (TmpPRemovedPage->UsedFor == MMINFO_PAGE_USED_FOR_KERNMAP) {
                                    printf("%12I64d,",TmpPRemovedPage->Offset);
                                    printf("%10s,","");
                                    printf("%10s,","Driver");
                                }else if (TmpPRemovedPage->UsedFor == MMINFO_PAGE_USED_FOR_FILE) {
                                    printf("%12I64d,",TmpPRemovedPage->Offset);
                                    printf("%10s,","");
                                    printf("%10s,","FILE");
                                }else{    
                                    printf("%12s,%10s,","","");
                                    printf("%10s,","Unknown");
                                }
                            }
                        }
                        break;
                        case MMINFO_PAGE_USED_FOR_PROCESS:
                        case MMINFO_PAGE_USED_FOR_PAGETABLE:
                        {
                            ULONG i;
                    
                            // Bug! Bug! The way to get VA can be wrong in the future.

                            if (TmpPRemovedPage->UsedFor == MMINFO_PAGE_USED_FOR_PAGETABLE) {
                                printf("%12x,",TmpPRemovedPage->Pte<<10);
                                printf("%8u,",TmpPRemovedPage->Pfn);
                                printf("(PT)");
                            }else{
                                printf("%12x,",TmpPRemovedPage->Pte<<10);
                                printf("%8u,",TmpPRemovedPage->Pfn);
                                printf("    ");
                            }
                            if (TmpPRemovedPage->ImageKey == 0) {
                                printf("%26s,","System (  0)");
                            }else{

                                i = TmpPRemovedPage->ImageKey;

                                if (ProcessHash[i].ProcessID == TmpPRemovedPage->ImageKey) {
                                    printf("%20s ",ProcessHash[i].ImageFileName);
                                    printf("(%3d),",ProcessHash[i].ProcessID);
                                }else{
                                    printf("Process %18u,",TmpPRemovedPage->ImageKey);
                                }
                            }
                            if (TmpPRemovedPage->UsedFor == MMINFO_PAGE_USED_FOR_PAGETABLE) {
                                // printf("%12I64d,",TmpPRemovedPage->Offset);
                                printf("%12s,%10s,%10s,","","","PageTable");
                            }else{
                                printf("%12s,%10s,%10s,","","","Process");
                                // printf("%30s,","Page Table");
                            }
                        }
                        break;
                        default:
                            printf("Error2 %22u,",TmpPRemovedPage->ImageKey);
                        break;
                    }
                    switch(TmpPRemovedPage->List) {
                        case MMINFO_PAGE_IN_LIST_FREEPAGE:
                             printf("%10s","Free List");
                             break;
                        case MMINFO_PAGE_IN_LIST_ZEROPAGE:
                             printf("%10s","Zero List");
                             break;
                        case MMINFO_PAGE_IN_LIST_BADPAGE:
                             printf("%10s","Bad List");
                             break;
                        case MMINFO_PAGE_IN_LIST_STANDBY:
                             printf("%10s","Standby");
                             break;
                        case MMINFO_PAGE_IN_LIST_TRANSITION:
                             printf("%10s","Transition");
                             break;
                        case MMINFO_PAGE_IN_LIST_MODIFIED:
                             printf("%10s","Modified");
                             break;
                        case MMINFO_PAGE_IN_LIST_MODIFIEDNOWRITE:
                             printf("%10s","ModNoWrite");
                             break;
                        case MMINFO_PAGE_IN_LIST_ACTIVEANDVALID:
                             printf("%10s","Valid");
                             break;
                        case MMINFO_PAGE_IN_LIST_VALIDANDPINNED:
                             printf("%10s","Valid_Pin");
                             break;
                        case MMINFO_PAGE_IN_LIST_UNKNOWN:
                             printf("%10s","Unknown");
                             break;
                        default:
                             // must be page table
                             printf("%10s","");
                             break;
                    }
                    printf("\n");
                    
                    // printf("Got Removed Page Log\n");
                    break;
                }
            case MMINFO_LOG_TYPE_ZEROSHARECOUNT:
            case MMINFO_LOG_TYPE_ZEROREFCOUNT:
            case MMINFO_LOG_TYPE_DECREFCNT:
            case MMINFO_LOG_TYPE_DECSHARCNT:
                {
                    PSYSTEM_MMINFO_PFN_INFORMATION TmpPPfn;

                    TmpPPfn = (PSYSTEM_MMINFO_PFN_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_DECSHARCNT) {
                        printf("%12s,", "DecShareCnt");
                    } else if (LogType == MMINFO_LOG_TYPE_ZEROSHARECOUNT) {
                        printf("%12s,", "ZeroShareCnt");
                    } else if (LogType == MMINFO_LOG_TYPE_DECREFCNT) {
                        printf("%12s,", "DecRefCnt");
                    } else if (LogType == MMINFO_LOG_TYPE_ZEROREFCOUNT) {
                        printf("%12s,", "ZeroRefCnt");
                    } else {
                        printf("%12s,", "UNKNOWN");
                    }

                    printf("%10s,","");

                    printf("%22s,","");
                    printf("%12s,","");
                    printf("%12s,","");
                    printf("%8u\n",TmpPPfn->Pfn);
                    break;
                }
            case MMINFO_LOG_TYPE_INSERTINLIST:
            case MMINFO_LOG_TYPE_INSERTATFRONT:
            case MMINFO_LOG_TYPE_UNLINKFROMSTANDBY:
            case MMINFO_LOG_TYPE_UNLINKFFREEORZERO:
                {
                    PSYSTEM_MMINFO_STATE_INFORMATION TmpPMmInfoState;

                    TmpPMmInfoState=(PSYSTEM_MMINFO_STATE_INFORMATION) Info;
            
                    if (LogType == MMINFO_LOG_TYPE_INSERTINLIST) {
                        printf("%12s,%10s,","Insert-List", "");
                    }else if (LogType == MMINFO_LOG_TYPE_INSERTATFRONT) {
                        printf("%12s,%10s,","Insert-Front", "");
                    }else if (LogType == MMINFO_LOG_TYPE_UNLINKFROMSTANDBY) {
                        printf("%12s,%10s,","Unlink-From", "");
                    }else if (LogType == MMINFO_LOG_TYPE_UNLINKFFREEORZERO) {
                        printf("%12s,%10s,","Unlink-From", "");
                    }

                    printf("%22s,","");
                    printf("%12s,","");
                    printf("%12s,","");
                    printf("%8u,",TmpPMmInfoState->Pfn);
                    printf("%30s,","");
                    printf("%12s,%10s,%10s,","","","");
                    switch(TmpPMmInfoState->List) {
                        case MMINFO_PAGE_IN_LIST_FREEPAGE:
                             printf("%10s","Free List");
                             break;
                        case MMINFO_PAGE_IN_LIST_ZEROPAGE:
                             printf("%10s","Zero List");
                             break;
                        case MMINFO_PAGE_IN_LIST_BADPAGE:
                             printf("%10s","Bad List");
                             break;
                        case MMINFO_PAGE_IN_LIST_STANDBY:
                             printf("%10s","Standby");
                             break;
                        case MMINFO_PAGE_IN_LIST_TRANSITION:
                             printf("%10s","Transition");
                             break;
                        case MMINFO_PAGE_IN_LIST_MODIFIED:
                             printf("%10s","Modified");
                             break;
                        case MMINFO_PAGE_IN_LIST_MODIFIEDNOWRITE:
                             printf("%10s","ModNoWrite");
                             break;
                        case MMINFO_PAGE_IN_LIST_ACTIVEANDVALID:
                             printf("%10s","Valid");
                             break;
                        case MMINFO_PAGE_IN_LIST_VALIDANDPINNED:
                             printf("%10s","Valid_Pin");
                             break;
                        case MMINFO_PAGE_IN_LIST_UNKNOWN:
                             printf("%10s","Unknown");
                             break;
                        default:
                             // must be page table
                             printf("%10s","");
                             break;
                    }
                    printf("\n");
                    
                    // printf("Got Removed Page Log\n");
                    break;
                }
            case MMINFO_LOG_TYPE_IMAGENAME:
            case MMINFO_LOG_TYPE_SECTIONREMOVED:
                {
                    PSYSTEM_MMINFO_FILENAME_INFORMATION TmpPImage;
                    ULONG i;

                    TmpPImage=(PSYSTEM_MMINFO_FILENAME_INFORMATION) Info;
                    // printf("Got Image Log\n");

                    i=TmpPImage->ImageKey%TableSize;
    
                    while(ImageHash[i].ImageKey != 0) {
                        if (ImageHash[i].ImageKey == TmpPImage->ImageKey) {
                            break;
                        }else{
                            i = (i+1)%TableSize;
                        }
                    }

                    if (LogType == MMINFO_LOG_TYPE_IMAGENAME) {
                        ImageHash[i].ImageKey
                            =TmpPImage->ImageKey;
                        ImageHash[i].ImageName.Length
                            =TmpPImage->ImageName.Length;
                        ImageHash[i].ImageName.Buffer
                            =TmpPImage->ImageBuffer;
                        if (Debug) {
                            printf("%12s,", "S-Created");
                        }
                    }else{
                        if (Debug) {
                            printf("%12s,", "S-Deleted");
                        }

                    }
                    if (Debug) {
                        printf("%10s,%22s,%12s,%12x,%8s,%30S,%12s,%10s,%10s\n",
                            "",
                            "",
                            "",
                            ImageHash[i].ImageKey,
                            "",
                            ImageHash[i].ImageName.Buffer,
                            "",
                            "",
                            "");
                    }

                    break;
                }
            case MMINFO_LOG_TYPE_PROCESSNAME:
            case MMINFO_LOG_TYPE_DIEDPROCESS:
                {
                    PSYSTEM_MMINFO_PROCESS_INFORMATION TmpPProcess;
                    ULONG i;

                    TmpPProcess=(PSYSTEM_MMINFO_PROCESS_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_PROCESSNAME) {
                        i = TmpPProcess->ProcessID;

                        ProcessHash[i].ProcessID
                            =TmpPProcess->ProcessID;
                        RtlCopyMemory(ProcessHash[i].ImageFileName, 
                                      TmpPProcess->ImageFileName, 16);

                        printf("%12s,", "P-Created");
                    }else{
                        printf("%12s,", "P-Deleted");
                    }
                    printf("%10s,%16s (%3d)\n",
                                "",
                                ProcessHash[TmpPProcess->ProcessID].ImageFileName,
                                ProcessHash[TmpPProcess->ProcessID].ProcessID);

                    // printf("Got Process Log\n");
                    break;
                }
            case MMINFO_LOG_TYPE_OUTSWAPPROCESS:
            case MMINFO_LOG_TYPE_INSWAPPROCESS:
                {
                    PSYSTEM_MMINFO_SWAPPROCESS_INFORMATION TmpPProc;
                    ULONG i;

                    TmpPProc=(PSYSTEM_MMINFO_SWAPPROCESS_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_OUTSWAPPROCESS) {
                        printf("%12s,", "P-OutSwap");
                    }else{
                        printf("%12s,", "P-InSwap");
                    }

                    if (PerfCounter) {
                        printf("%10I64d,", ((PerfCounter - PerfCounterStart) * 1000000) / PerfFrequency);
                    } else {
                        printf("%10s,", "");
                    }

                    printf("%16s (%3d)",
                                ProcessHash[TmpPProc->ProcessID].ImageFileName,
                                ProcessHash[TmpPProc->ProcessID].ProcessID);

                    printf("\n");
                    break;
                }
            case MMINFO_LOG_TYPE_OUTSWAPSTACK:
            case MMINFO_LOG_TYPE_INSWAPSTACK:
                {
                    PSYSTEM_MMINFO_SWAPTHREAD_INFORMATION TmpPThread;
                    ULONG i;

                    TmpPThread=(PSYSTEM_MMINFO_SWAPTHREAD_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_OUTSWAPSTACK) {
                        printf("%12s,", "KS-OutSwap");
                    }else{
                        printf("%12s,", "KS-InSwap");
                    }

                    printf("%10d,%16s (%3d)",
                                TmpPThread->ThreadID,
                                ProcessHash[TmpPThread->ProcessID].ImageFileName,
                                ProcessHash[TmpPThread->ProcessID].ProcessID);

                    if (PerfCounter) {
                        printf(",%12I64d", ((PerfCounter - PerfCounterStart) * 1000000) / PerfFrequency);
                    }
                    printf("\n");
                    break;
                }
            case MMINFO_LOG_TYPE_CREATETHREAD:
            case MMINFO_LOG_TYPE_GROWKERNELSTACK:
            case MMINFO_LOG_TYPE_TERMINATETHREAD:
            case MMINFO_LOG_TYPE_CONVERTTOGUITHREAD:
                {
                    PSYSTEM_MMINFO_THREAD_INFORMATION TmpPThread;
                    ULONG i;

                    TmpPThread=(PSYSTEM_MMINFO_THREAD_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_CREATETHREAD) {
                        printf("%12s,", "T-Created");
                        ThreadHash[TmpPThread->ThreadID] = TmpPThread->ProcessID;
                    }else if (LogType == MMINFO_LOG_TYPE_GROWKERNELSTACK) {
                        printf("%12s,", "GrowStack");
                    }else if (LogType == MMINFO_LOG_TYPE_CONVERTTOGUITHREAD) {
                        printf("%12s,", "T-GUI");
                    }else{
                        printf("%12s,", "T-Deleted");
                        //
                        // Threads are sometimes set as deleted while still
                        // running.  If we mark them as dead here we have
                        // a problem when they are cswitched out.
                        //
                        //ThreadHash[TmpPThread->ThreadID] = -1;
                    }

                    printf("%10d,%16s (%3d)",
                                TmpPThread->ThreadID,
                                ProcessHash[TmpPThread->ProcessID].ImageFileName,
                                ProcessHash[TmpPThread->ProcessID].ProcessID);

                    // printf("Got Process Log\n");
                    if (LogType != MMINFO_LOG_TYPE_TERMINATETHREAD) {
                        printf(",%12x",TmpPThread->StackBase);
                        printf(",%12x",TmpPThread->StackLimit);

                        if (TmpPThread->UserStackBase) {
                            printf(",%12x",TmpPThread->UserStackBase);
                            printf(",%12x",TmpPThread->UserStackLimit);
                        } else {
                            printf(",%12s","");
                            printf(",%12s","");
                        }

                        if (TmpPThread->WaitMode >= 0) {
                            if (TmpPThread->WaitMode) {
                                printf(",%8s", "Swapable");
                            } else {
                                printf(",%8s", "NonSwap");
                            }
                        }
                    }
                    printf("\n");
                    break;
                }
            case MMINFO_LOG_TYPE_CSWITCH:
            {
                PSYSTEM_MMINFO_CSWITCH_INFORMATION TmpPMmInfo;
                ULONG OldProcessId;
                ULONG NewProcessId;

                TmpPMmInfo = (PSYSTEM_MMINFO_CSWITCH_INFORMATION) Info;

                OldProcessId = ThreadHash[TmpPMmInfo->OldThreadId];
                NewProcessId = ThreadHash[TmpPMmInfo->NewThreadId];
                if ((OldProcessId == -1) || (NewProcessId == -1)) {
                    printf("Error: Bad thread value %d or %d\n",
                            TmpPMmInfo->OldThreadId,
                            TmpPMmInfo->NewThreadId
                            );
                    break;
                }
                printf("%12s,%10I64d,%11s,%16s,%10d,%16s (%3d), %10d,%16s (%3d),%4d,%4d,%8s\n",
                        "CSwitch",
                        ((PerfCounter - PerfCounterStart) *
                                1000000) / PerfFrequency,
                        ThreadState[TmpPMmInfo->OldState],
                        (TmpPMmInfo->OldState == Waiting) ?
                                WaitReason[TmpPMmInfo->WaitReason] :
                                "",
                        TmpPMmInfo->OldThreadId,
                        ProcessHash[OldProcessId].ImageFileName,
                        OldProcessId,
                        TmpPMmInfo->NewThreadId,
                        ProcessHash[NewProcessId].ImageFileName,
                        NewProcessId,
                        TmpPMmInfo->OldThreadPri,
                        TmpPMmInfo->NewThreadPri,
                        (TmpPMmInfo->OldWaitMode) ? "Swapable" : "NonSwap"
                        );
                break;
            }
            case MMINFO_LOG_TYPE_POOLSNAP:
                {
                    ULONG   PoolTag[2]={0,0};
                    PMMINFO_POOL_TRACKER_TABLE TmpPMmInfopoolTrackTable;

                    TmpPMmInfopoolTrackTable=(PMMINFO_POOL_TRACKER_TABLE) Info;

                    PoolTag[0]=TmpPMmInfopoolTrackTable->Tag & ~PROTECTED_POOL;

                    // Data for Paged Pool
                    if (TmpPMmInfopoolTrackTable->PagedAllocs) {
                        printf("%12s,","PoolSnap");
                        printf("%10s,", PoolTag);
                        printf("%22s,","");
                        printf("%12s,%12s,","PagedPool","");
    
                        printf("%8u,%8u,%8u\n",
                            TmpPMmInfopoolTrackTable->PagedBytes,
                            TmpPMmInfopoolTrackTable->PagedAllocs,
                            TmpPMmInfopoolTrackTable->PagedFrees);
                    }

                    // Data for NonPaged Pool
                    if (TmpPMmInfopoolTrackTable->NonPagedAllocs) {
                        printf("%12s,","PoolSnap");
                        printf("%10s,", PoolTag);
                        printf("%22s,","");
                        printf("%12s,%12s,","NonPagedPool","");
    
                        printf("%8u,%8u,%8u\n",
                            TmpPMmInfopoolTrackTable->NonPagedBytes,
                            TmpPMmInfopoolTrackTable->NonPagedAllocs,
                            TmpPMmInfopoolTrackTable->NonPagedFrees);
                    }
                    break;
                }
            case MMINFO_LOG_TYPE_ALLOCATEPOOL:
            case MMINFO_LOG_TYPE_BIGPOOLPAGE:
                {
                    ULONG   PoolTag[2]={0,0};
                    PSYSTEM_MMINFO_ALLOCATEPOOL_INFORMATION TmpPMmInfoAllocatePool;

                    TmpPMmInfoAllocatePool=(PSYSTEM_MMINFO_ALLOCATEPOOL_INFORMATION) Info;
                    PoolTag[0]=TmpPMmInfoAllocatePool->PoolTag & ~PROTECTED_POOL;

                    if (LogType == MMINFO_LOG_TYPE_ALLOCATEPOOL) {
                        printf("%12s,", "Pool_Alloc");
                        printf("%10s,", PoolTag);
                        if (TmpPMmInfoAllocatePool->ProcessID == 0) {
                            printf("%22s,","System (  0)");
                        } else{
                            ULONG i;
    
                            i = TmpPMmInfoAllocatePool->ProcessID;
    
                            if (ProcessHash[i].ProcessID == TmpPMmInfoAllocatePool->ProcessID) {
                                printf("%16s ",ProcessHash[i].ImageFileName);
                                printf("(%3d),",ProcessHash[i].ProcessID);
                            }else{
                                printf("Process %13u,",TmpPMmInfoAllocatePool->ProcessID);
                            }
                        }
                    }else{
                        printf("%12s,","BigPoolPage");
                        printf("%10s,", PoolTag);
                        printf("%22s,","");
                    }

                    printf("%12s,%12x,%8u\n",
                            PoolTypeNames[TmpPMmInfoAllocatePool->PoolType & 7],
                            TmpPMmInfoAllocatePool->Entry,
                            TmpPMmInfoAllocatePool->Size);
                    break;
                }
            case MMINFO_LOG_TYPE_FREEPOOL:
                {

                    PSYSTEM_MMINFO_FREEPOOL_INFORMATION TmpPMmInfoFreePool;

                    TmpPMmInfoFreePool=(PSYSTEM_MMINFO_FREEPOOL_INFORMATION) Info;

                    printf("%12s,%10s,%22s,%12s,%12x\n",
                            "Pool_Free",
                            "",
                            "",
                            "",
                            TmpPMmInfoFreePool->Entry);
                    break;
                }
            case MMINFO_LOG_TYPE_ASYNCMARK:
            case MMINFO_LOG_TYPE_MARK:
                {
                    PSYSTEM_MMINFO_MARK_INFORMATION TmpPMmInfo;
    
                    TmpPMmInfo = (PSYSTEM_MMINFO_MARK_INFORMATION) Info;
    
                    printf("%12s,%10I64d, %-s\n",
                            (LogType == MMINFO_LOG_TYPE_ASYNCMARK) ?
                                "AsyncMark" : "Mark",
                            ((PerfCounter - PerfCounterStart) *
                                    1000000) / PerfFrequency,
                            TmpPMmInfo->Name);
                    break;
                }
            case MMINFO_LOG_TYPE_CMCELLREFERRED:
                {
                    PSYSTEM_MMINFO_CMCELL_INFORMATION TmpPMmInfoCmCell;
                    TmpPMmInfoCmCell=(PSYSTEM_MMINFO_CMCELL_INFORMATION) Info;

                    printf("%12s,%10s,","Cell_Used","");
                    switch(TmpPMmInfoCmCell->Signature) {
                        case CM_KEY_NODE_SIGNATURE:
                            printf("%22s,%12s","Key_Node","");
                            break;
                        case CM_LINK_NODE_SIGNATURE:
                            printf("%22s,%12s","Link_Node","");
                            break;
                        case CM_KEY_VALUE_SIGNATURE:
                            printf("%22s,%12s","Key_Value","");
                            break;
                        case CM_KEY_FAST_LEAF:
                            printf("%22s,%12s","Index_Leaf","");
                            break;
                        case CM_KEY_SECURITY_SIGNATURE:
                            printf("%22s,%12s","Key_Security","");
                            break;
                        default:
                            printf("%22s,%12s","Unknown","");
                            break;
                    }
                        
                    printf(",%12x,%8d\n", TmpPMmInfoCmCell->Va, TmpPMmInfoCmCell->Size*-1);

                    break;
                }
            case MMINFO_LOG_TYPE_IMAGELOAD:
                {
                    PMMINFO_IMAGELOAD_INFORMATION TmpPMmInfo;
                    char WsNameBuf[30];
                    char * WsName = &WsNameBuf[0];

                    TmpPMmInfo = (PMMINFO_IMAGELOAD_INFORMATION) Info;
                    Info = TmpPMmInfo + 1;

                    if (TmpPMmInfo->ProcessId == 0) {
                        WsName = "System (  0)";
                    } else {
                        ULONG i;

                        i = TmpPMmInfo->ProcessId;

                        if (ProcessHash[i].ProcessID == TmpPMmInfo->ProcessId) {
                            sprintf(WsName, "%16s (%3d)",
                                                    ProcessHash[i].ImageFileName,
                                                    ProcessHash[i].ProcessID);
                        }else{
                            sprintf(WsName, "Process %13u", TmpPMmInfo->ProcessId);
                        }
                    }

                    printf(ImageLoadDataFormat,
                        TmpPMmInfo->ImageBase,
                        (ULONG)TmpPMmInfo->ImageBase + TmpPMmInfo->ImageSize,
                        TmpPMmInfo->ImageSectionNumber,
                        WsName,
                        TmpPMmInfo->ImageName
                        );

                    break;
                }
            case MMINFO_LOG_TYPE_SAMPLED_PROFILE:
                {
                    PMMINFO_SAMPLED_PROFILE_INFORMATION TmpPMmInfo;
                    TmpPMmInfo = (PMMINFO_SAMPLED_PROFILE_INFORMATION) Info;
                    Info = TmpPMmInfo + 1;

                    printf(SampledProfileDataFormat,
                        TmpPMmInfo->InstructionPointer,
                        TmpPMmInfo->Count                        
                        );

                    break;
                }

            default:
                // fprintf(stderr, "Tag Value %8d\n", Tag.u.Value);
                // fprintf(stderr, "TimeStamp       %8x %8x\n", TS.upper, TS.lower);
            break;
        }
    }
#else //NTMMPERF
    printf("Sorry but this is an internal tool!!!\n");
#endif //NTMMPERF
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perfmtr\memmon.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    MEMMON.c

Abstract:

    This module contains the NT/Win32 Pool Monitor

Author:

    Lou Perazzoli (loup) 13-Sep-1993

Revision History:

--*/

#include "perfmtrp.h"
#include <search.h>
#include <malloc.h>
#include <limits.h>
#include <stdlib.h>

#define BUFFER_SIZE 64*1024
#define MAX_BUFFER_SIZE 10*1024*1024

PCHAR       buffer;
ULONG CurrentBufferSize = BUFFER_SIZE;

#define CPU_USAGE 0
#define QUOTAS 1

#define TAG 0
#define ALLOC 1
#define FREE 2
#define DIFF 3
#define BYTES 4
#define EACH 5
#define LIGHT 6


#define NONPAGED 0
#define PAGED 1
#define BOTH 2

CHAR *PoolType[] = {
    "Nonp ",
    "Paged" };

CHAR LargeBuffer1[BUFFER_SIZE];
CHAR LargeBuffer2[BUFFER_SIZE];

#define NONAME_STRING_SIZE  14
CHAR NoName[] = {"No Name Found\0"};
ULONG TotalNoNameFound;

#define NOFILE_STRING_SIZE  13
CHAR NoFileName[] = {"No File Name\0"};
ULONG TotalNoFileFound;

#define META_FILE_STRING_SIZE 13
CHAR MetaFile[] = {"Fs Meta File\0"};
ULONG TotalFsMetaFile;

#define OUT_STRING_SIZE 60

typedef struct _MEMMON_OUT {
    ULONG Valid;
    ULONG Standby;
    ULONG Modified;
    ULONG PageTable;
    CHAR String[OUT_STRING_SIZE];
    WCHAR Null;
} MEMMON_OUT, *PMEMMON_OUT;

MEMMON_OUT OutBuffer[2000];

ULONG DisplayType = BOTH;
ULONG SortBy = TAG;
ULONG Paren;

ULONG DelayTimeMsec = 5000;

BOOLEAN Interactive;
ULONG NumberOfInputRecords;
INPUT_RECORD InputRecord;
HANDLE InputHandle;
HANDLE OriginalOutputHandle;
HANDLE OutputHandle;
DWORD OriginalInputMode;
WORD NormalAttribute;
WORD HighlightAttribute;
ULONG NumberOfCols;
ULONG NumberOfRows;
ULONG NumberOfDetailLines;
ULONG FirstDetailLine;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;
ULONG NoHighlight;

BOOLEAN DisplayTotals = FALSE;
MEMMON_OUT Totals[2];

typedef struct _FILTER {
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    BOOLEAN Exclude;
} FILTER, *PFILTER;

#define MAX_FILTER 64
FILTER Filter[MAX_FILTER];
ULONG FilterCount = 0;

VOID
ShowHelpPopup( VOID );

int __cdecl
ulcomp(const void *e1,const void *e2);

int __cdecl
ulcomp(const void *e1,const void *e2)
{
    ULONG u1;

    switch (SortBy) {
        case TAG:

            u1 = (strcmp (((PMEMMON_OUT)e1)->String,
                          ((PMEMMON_OUT)e2)->String));
            return u1;
            break;

        case ALLOC:
            u1 = ((PMEMMON_OUT)e2)->Valid - ((PMEMMON_OUT)e1)->Valid;
            return (u1);
            break;

        case FREE:
            u1 = ((PMEMMON_OUT)e2)->Standby - ((PMEMMON_OUT)e1)->Standby;
            return (u1);
            break;

        case BYTES:
            u1 = ((PMEMMON_OUT)e2)->Modified - ((PMEMMON_OUT)e1)->Modified;
            return (u1);
            break;

        case DIFF:
            u1 = ((PMEMMON_OUT)e2)->PageTable - ((PMEMMON_OUT)e1)->PageTable;
            return (u1);
            break;

        case EACH:
            return (0);
            break;

        default:
            return(0);
            break;
    }
}

BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    PCHAR Filter
    )
{
    ULONG i;
    CHAR tc;
    CHAR fc;

    for ( i = 0; i < 4; i++ ) {
        tc = *Tag++;
        fc = *Filter++;
        if ( fc == '*' ) return TRUE;
        if ( fc == '?' ) continue;
        if ( tc != fc ) return FALSE;
    }
    return TRUE;
}

BOOLEAN
CheckFilters (
    PSYSTEM_POOLTAG TagInfo
    )
{
    BOOLEAN pass;
    ULONG i;
    PCHAR tag;

    //
    // If there are no filters, all tags pass.
    //

    if ( FilterCount == 0 ) {
        return TRUE;
    }

    //
    // There are filters.  If the first filter excludes tags, then any
    // tag not explicitly mentioned passes.  If the first filter includes
    // tags, then any tag not explicitly mentioned fails.
    //

    if ( Filter[0].Exclude ) {
        pass = TRUE;
    } else {
        pass = FALSE;
    }

    tag = TagInfo->Tag;
    for ( i = 0; i < FilterCount; i++ ) {
        if ( CheckSingleFilter( tag, (PCHAR)&Filter[i].Tag ) ) {
            pass = !Filter[i].Exclude;
        }
    }

    return pass;
}

VOID
AddFilter (
    BOOLEAN Exclude,
    PCHAR FilterString
    )
{
    PFILTER f;
    PCHAR p;
    ULONG i;

    if ( FilterCount == MAX_FILTER ) {
        printf( "Too many filters specified.  Limit is %d\n", MAX_FILTER );
        return;
    }

    f = &Filter[FilterCount];
    p = f->Tag;

    for ( i = 0; i < 4; i++ ) {
        if ( *FilterString == 0 ) break;
        *p++ = *FilterString++;
    }
    for ( ; i < 4; i++ ) {
        *p++ = ' ';
    }

    f->Exclude = Exclude;
    FilterCount++;

    return;
}

VOID
ParseArgs (
    int argc,
    char *argv[]
    )
{
    char *p;
    BOOLEAN exclude;

    argc--;
    argv++;

    while ( argc-- > 0 ) {
        p  = *argv++;
        if ( *p == '-' || *p == '/' ) {
            p++;
            exclude = TRUE;
            switch ( tolower(*p) ) {
            case 'i':
                exclude = FALSE;
            case 'x':
                p++;
                if ( strlen(p) == 0 ) {
                    printf( "missing filter string\n" );
                    ExitProcess( 1 );
                } else if ( strlen(p) <= sizeof(ULONG) ) {
                    AddFilter( exclude, p );
                } else {
                    printf( "filter string too long: %s\n", p );
                    ExitProcess( 1 );
                }
                break;
            case 'e':
                DisplayTotals = TRUE;
                break;
            case 't':
                SortBy = TAG;
                break;
            case 'a':
                SortBy = ALLOC;
                break;
            case 'u':
            case 'b':
                SortBy = BYTES;
                break;
            case 'f':
                SortBy = FREE;
                break;
            case 'd':
                SortBy = DIFF;
                break;
            case 'm':
                SortBy = EACH;

            case 'l':
                NoHighlight = 1 - NoHighlight;
                break;

            case 'p':
                DisplayType += 1;
                if (DisplayType > BOTH) {
                    DisplayType = NONPAGED;
                }
                break;
            case '(':
            case ')':
                Paren += 1;
                break;
            default:
                printf( "unknown switch: %s\n", p );
                ExitProcess( 2 );
            }
        } else {
            printf( "unknown switch: %s\n", p );
            ExitProcess( 2 );
        }
    }

    return;
}

BOOL
WriteConsoleLine(
    HANDLE OutputHandle,
    WORD LineNumber,
    LPSTR Text,
    BOOL Highlight
    )
{
    COORD WriteCoord;
    DWORD NumberWritten;
    DWORD TextLength;

    WriteCoord.X = 0;
    WriteCoord.Y = LineNumber;
    if (!FillConsoleOutputCharacter( OutputHandle,
                                     ' ',
                                     NumberOfCols,
                                     WriteCoord,
                                     &NumberWritten
                                   )
       ) {
        return FALSE;
        }

    if (!FillConsoleOutputAttribute( OutputHandle,
                                     (WORD)((Highlight && !NoHighlight) ? HighlightAttribute : NormalAttribute),
                                     NumberOfCols,
                                     WriteCoord,
                                     &NumberWritten
                                   )
       ) {
        return FALSE;
        }


    if (Text == NULL || (TextLength = strlen( Text )) == 0) {
        return TRUE;
        }
    else {
        return WriteConsoleOutputCharacter( OutputHandle,
                                            Text,
                                            TextLength,
                                            WriteCoord,
                                            &NumberWritten
                                          );
        }
}

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{

    NTSTATUS Status;
    ULONG LastCount = 0;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    PSYSTEM_POOLTAG_INFORMATION PoolInfo;
    PSYSTEM_POOLTAG_INFORMATION PoolInfoOld;
    PUCHAR PreviousBuffer;
    PUCHAR CurrentBuffer;
    PUCHAR TempBuffer;
    BOOLEAN DoHelp;
    BOOLEAN DoQuit;
    int NumberOfPoolTags;
    int i;
    UCHAR LastKey;
    PMEMMON_OUT Out;
    LONG ScrollDelta;
    WORD DisplayLine, LastDetailRow;
    CHAR OutputBuffer[ 512 ];

    NTSTATUS status;
    PSYSTEM_MEMORY_INFORMATION MemInfo;
    PSYSTEM_MEMORY_INFO Info;
    PSYSTEM_MEMORY_INFO InfoEnd;
    PUCHAR String;
    ULONG TotalValid;
    ULONG TotalPageTable;
    ULONG TotalModified;
    ULONG TotalStandby;
    SYSTEMTIME Time;
    ULONG PageKb;

    DoHelp = FALSE;
    DoQuit = FALSE;
    Interactive = TRUE;

    buffer = VirtualAlloc (NULL,
                           MAX_BUFFER_SIZE,
                           MEM_RESERVE,
                           PAGE_READWRITE);

    if (buffer == NULL) {
        printf("Memory allocation failed\n");
        return 0;
    }

    buffer = VirtualAlloc (buffer,
                           BUFFER_SIZE,
                           MEM_COMMIT,
                           PAGE_READWRITE);

    if (buffer == NULL) {
        printf("Memory commit failed\n");
        return 0;
    }

    CurrentBufferSize = BUFFER_SIZE;
    ParseArgs( argc, argv );

    InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    OriginalOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
    if (Interactive) {
        if (InputHandle == NULL ||
            OriginalOutputHandle == NULL ||
            !GetConsoleMode( InputHandle, &OriginalInputMode )
           ) {
            Interactive = FALSE;
        } else {
            OutputHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                                      FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                      NULL,
                                                      CONSOLE_TEXTMODE_BUFFER,
                                                      NULL
                                                    );
            if (OutputHandle == NULL ||
                !GetConsoleScreenBufferInfo( OriginalOutputHandle, &OriginalConsoleInfo ) ||
                !SetConsoleScreenBufferSize( OutputHandle, OriginalConsoleInfo.dwSize ) ||
                !SetConsoleActiveScreenBuffer( OutputHandle ) ||
                !SetConsoleMode( InputHandle, 0 )
               ) {
                if (OutputHandle != NULL) {
                    CloseHandle( OutputHandle );
                    OutputHandle = NULL;
                }

                Interactive = FALSE;
            } else {
                NormalAttribute = 0x1F;
                HighlightAttribute = 0x71;
                NumberOfCols = OriginalConsoleInfo.dwSize.X;
                NumberOfRows = OriginalConsoleInfo.dwSize.Y;
                NumberOfDetailLines = NumberOfRows;
            }
        }
    }

    NtQuerySystemInformation( SystemBasicInformation,
                              &BasicInfo,
                              sizeof(BasicInfo),
                              NULL
                            );

    if (GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS) {
        SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS);
    }

    PageKb = BasicInfo.PageSize / 1024;

    PreviousBuffer = NULL;
    CurrentBuffer = LargeBuffer1;

    while(TRUE) {

        Status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &PerfInfo,
                    sizeof(PerfInfo),
                    NULL
                    );

        if ( !NT_SUCCESS(Status) ) {
            printf("Query perf Failed %lx\n",Status);
            break;
        }

retry01:
        status = NtQuerySystemInformation (SystemFullMemoryInformation,
                                           buffer,
                                           CurrentBufferSize,
                                           NULL);

        if ((status == STATUS_INFO_LENGTH_MISMATCH) ||
            (status == STATUS_DATA_OVERRUN)) {

            //
            // Increase buffer size.
            //

            CurrentBufferSize += 8192;

            buffer = VirtualAlloc (buffer,
                                   CurrentBufferSize,
                                   MEM_COMMIT,
                                   PAGE_READWRITE);
            if (buffer == NULL) {
                printf("Memory commit failed\n");
                ExitProcess(0);
            }
            goto retry01;
        }
        if (!NT_SUCCESS (status)) {
            printf("query system information failed %lx\n",status);
            return 1;
        }

        TotalValid = 0;
        TotalPageTable = 0;
        TotalStandby = 0;
        TotalModified = 0;
        MemInfo = (PSYSTEM_MEMORY_INFORMATION)buffer;
        Info = &MemInfo->Memory[0];
        InfoEnd = (PSYSTEM_MEMORY_INFO)MemInfo->StringStart;

        //
        // Calculate pool tags and display information.
        //

        PoolInfo = (PSYSTEM_POOLTAG_INFORMATION)CurrentBuffer;
        i = PoolInfo->Count;
        PoolInfoOld = (PSYSTEM_POOLTAG_INFORMATION)PreviousBuffer;

        DisplayLine = 0;
        sprintf( OutputBuffer,
                 " Memory:%8ldK Avail:%8ldK  PageFlts:%6ld   InRam Krnl:%5ldK P:%5ldK",
                 BasicInfo.NumberOfPhysicalPages*(BasicInfo.PageSize/1024),
                 PerfInfo.AvailablePages*(BasicInfo.PageSize/1024),
                 PerfInfo.PageFaultCount - LastCount,
                 (PerfInfo.ResidentSystemCodePage + PerfInfo.ResidentSystemDriverPage)*(BasicInfo.PageSize/1024),
                 (PerfInfo.ResidentPagedPoolPage)*(BasicInfo.PageSize/1024)
               );
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          OutputBuffer,
                          FALSE
                        );

        LastCount = PerfInfo.PageFaultCount;
        sprintf( OutputBuffer,
                 " Commit:%7ldK Limit:%7ldK Peak:%7ldK            Pool N:%5ldK P:%5ldK",
                 PerfInfo.CommittedPages*(BasicInfo.PageSize/1024),
                 PerfInfo.CommitLimit*(BasicInfo.PageSize/1024),
                 PerfInfo.PeakCommitment*(BasicInfo.PageSize/1024),
                 PerfInfo.NonPagedPoolPages*(BasicInfo.PageSize/1024),
                 PerfInfo.PagedPoolPages*(BasicInfo.PageSize/1024)
               );
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          OutputBuffer,
                          FALSE
                        );

        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          " Valid   Transition  Modified   PageTables   Name                            ",
                          FALSE
                        );
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          NULL,
                          FALSE
                        );

        Out = &OutBuffer[3];
        if (DisplayTotals) {
            RtlZeroMemory( Totals, sizeof(MEMMON_OUT)*2 );
        }

        TotalNoNameFound = 0;
        TotalFsMetaFile = 0;
        Out[0].Valid = 0;
        Out[0].PageTable = 0;
        Out[0].Standby = 0;
        Out[0].Modified = 0;
        RtlCopyMemory (Out[0].String, NoName, NONAME_STRING_SIZE);
        Out[1].Valid = 0;
        Out[1].PageTable = 0;
        Out[1].Standby = 0;
        Out[1].Modified = 0;
        RtlCopyMemory (Out[1].String, MetaFile, META_FILE_STRING_SIZE);
        Out[2].Valid = 0;
        Out[2].PageTable = 0;
        Out[2].Standby = 0;
        Out[2].Modified = 0;
        RtlCopyMemory (Out[2].String, NoFileName, NOFILE_STRING_SIZE);

        while (Info < InfoEnd) {

//            if ( !CheckFilters(&PoolInfo->TagInfo[i]) ) {
//                continue;
//            }

            Out->Valid = Info->ValidCount*PageKb * PageKb;
            Out->Modified = Info->PageTableCount*PageKb;
            Out->Standby = Info->TransitionCount*PageKb;
            Out->PageTable = Info->ModifiedCount*PageKb;

            TotalValid += Info->ValidCount;
            TotalPageTable += Info->PageTableCount;
            TotalStandby += Info->TransitionCount;
            TotalModified += Info->ModifiedCount;

            RtlZeroMemory (Out->String, OUT_STRING_SIZE);
            if (Info->StringOffset != 0) {
                if (*(PUCHAR)(Info->StringOffset + 1) == 0) {
                   WideCharToMultiByte (CP_ACP,
                                        0,
                                        (LPCWSTR)Info->StringOffset,
                                        -1,
                                        (LPSTR)Out->String,
                                        OUT_STRING_SIZE,
                                        NULL,
                                        NULL);
                } else {

                    if (!strncmp (Info->StringOffset, MetaFile, META_FILE_STRING_SIZE)) {
                        TotalNoNameFound += 1;
                        Out[1].Valid += Info->ValidCount*PageKb * PageKb;
                        Out[1].PageTable += Info->PageTableCount*PageKb;
                        Out[1].Standby += Info->TransitionCount*PageKb;
                        Out[1].Modified += Info->ModifiedCount*PageKb;
                        Out -= 1;
                    } else if (!strncmp (Info->StringOffset, NoFileName, NOFILE_STRING_SIZE)) {
                        TotalNoNameFound += 1;
                        Out[2].Valid += Info->ValidCount*PageKb * PageKb;
                        Out[2].PageTable += Info->PageTableCount*PageKb;
                        Out[2].Standby += Info->TransitionCount*PageKb;
                        Out[2].Modified += Info->ModifiedCount*PageKb;
                        Out -= 1;
                    } else {
                        RtlCopyMemory (Out->String, Info->StringOffset, OUT_STRING_SIZE);
                    }
                }
             } else {
                 TotalNoNameFound += 1;
                 Out[0].Valid += Info->ValidCount*PageKb * PageKb;
                 Out[0].PageTable += Info->PageTableCount*PageKb;
                 Out[0].Standby += Info->TransitionCount*PageKb;
                 Out[0].Modified += Info->ModifiedCount*PageKb;
                 Out -= 1;
             }
            Out += 1;
            Info += 1;
            i++;
        } //end for

        //
        // Sort the running working set buffer
        //

        NumberOfPoolTags = Out - &OutBuffer[0];
        qsort((void *)&OutBuffer,
              (size_t)NumberOfPoolTags,
              (size_t)sizeof(MEMMON_OUT),
              ulcomp);

        LastDetailRow = (WORD)(NumberOfRows - (DisplayTotals ? (DisplayType == BOTH ? 3 : 2) : 0));
        for (i = FirstDetailLine; i < NumberOfPoolTags; i++) {
            if (DisplayLine >= LastDetailRow) {
                break;
            }

            sprintf( OutputBuffer,
                     " %8ld %8ld %8ld %8ld %s",
                     OutBuffer[i].Valid,
                     OutBuffer[i].Standby,
                     OutBuffer[i].Modified,
                     OutBuffer[i].PageTable,
                     OutBuffer[i].String
                   );
            WriteConsoleLine( OutputHandle,
                              DisplayLine++,
                              OutputBuffer,
                              FALSE
                            );
        }

        if (DisplayTotals) {
            WriteConsoleLine( OutputHandle,
                              DisplayLine++,
                              NULL,
                              FALSE
                            );
            for (i = 0; i < 2; i++) {
                if ( (int)DisplayType == i || DisplayType == BOTH ) {
                    sprintf( OutputBuffer,
                             "Total %9ld %9ld %8ld %7ld",
                             TotalValid,
                             TotalStandby,
                             TotalModified,
                             TotalPageTable
                           );
                    WriteConsoleLine( OutputHandle,
                                      DisplayLine++,
                                      OutputBuffer,
                                      FALSE
                                    );
                }
            }
        }

        if (PreviousBuffer == NULL) {
            PreviousBuffer = LargeBuffer2;
        }
        TempBuffer = PreviousBuffer;
        PreviousBuffer = CurrentBuffer;
        CurrentBuffer = TempBuffer;

        while (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0) {
            //
            // Check for input record
            //
            if (ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
                InputRecord.EventType == KEY_EVENT &&
                InputRecord.Event.KeyEvent.bKeyDown
               ) {
                LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;
                if (LastKey < ' ') {
                    ScrollDelta = 0;
                    if (LastKey == 'C'-'A'+1) {
                        DoQuit = TRUE;
                    } else switch (InputRecord.Event.KeyEvent.wVirtualKeyCode) {
                        case VK_ESCAPE:
                            DoQuit = TRUE;
                            break;

                        case VK_PRIOR:
                            ScrollDelta = -(LONG)(InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines);
                            break;

                        case VK_NEXT:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines;
                            break;

                        case VK_UP:
                            ScrollDelta = -InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_DOWN:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_HOME:
                            FirstDetailLine = 0;
                            break;

                        case VK_END:
                            FirstDetailLine = NumberOfPoolTags - NumberOfDetailLines;
                            break;
                    }

                    if (ScrollDelta != 0) {
                        if (ScrollDelta < 0) {
                            if (FirstDetailLine <= (ULONG)-ScrollDelta) {
                                FirstDetailLine = 0;
                            } else {
                                FirstDetailLine += ScrollDelta;
                            }
                        } else {
                            FirstDetailLine += ScrollDelta;
                            if (FirstDetailLine >= (NumberOfPoolTags - NumberOfDetailLines)) {
                                FirstDetailLine = NumberOfPoolTags - NumberOfDetailLines;
                            }
                        }
                    }
                } else {
                    switch (toupper( LastKey )) {
                        case 'Q':
                            //
                            //  Go to the bottom of the current screen when
                            //  we quit.
                            //
                            DoQuit = TRUE;
                            break;

                        case 'T':
                            SortBy = TAG;
                            FirstDetailLine = 0;
                            break;

                        case 'A':
                            SortBy = ALLOC;
                            FirstDetailLine = 0;
                            break;

                        case 'U':
                        case 'B':
                            SortBy = BYTES;
                            FirstDetailLine = 0;
                            break;

                        case 'F':
                            SortBy = FREE;
                            FirstDetailLine = 0;
                            break;

                        case 'D':
                            SortBy = DIFF;
                            FirstDetailLine = 0;
                            break;

                        case 'M':
                            SortBy = EACH;
                            FirstDetailLine = 0;
                            break;

                        case 'L':

                            NoHighlight = 1 - NoHighlight;
                            break;

                        case 'P':
                            DisplayType += 1;
                            if (DisplayType > BOTH) {
                                DisplayType = NONPAGED;
                            }
                            FirstDetailLine = 0;
                            break;

                        case 'X':
                        case '(':
                        case ')':

                            Paren += 1;
                            break;

                        case 'E':
                            DisplayTotals = !DisplayTotals;
                            FirstDetailLine = 0;
                            break;

                        case 'H':
                        case '?':
                            DoHelp = TRUE;
                            break;

                    }
                }

                break;
            }
        }

        if (DoQuit) {
            break;
        }

        if (DoHelp) {
            DoHelp = FALSE;
            ShowHelpPopup();
        }
    }

    if (Interactive) {
        SetConsoleActiveScreenBuffer( OriginalOutputHandle );
        SetConsoleMode( InputHandle, OriginalInputMode );
        CloseHandle( OutputHandle );
        }

    ExitProcess( 0 );
    return 0;
}


VOID
ShowHelpPopup( VOID )
{
    HANDLE PopupHandle;
    WORD n;

    PopupHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                             FILE_SHARE_WRITE | FILE_SHARE_READ,
                                             NULL,
                                             CONSOLE_TEXTMODE_BUFFER,
                                             NULL
                                           );
    if (PopupHandle == NULL) {
        return;
        }

    SetConsoleActiveScreenBuffer( PopupHandle );

    n = 0;

    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "                Poolmon Help", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " columns:", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Tag is the 4 byte tag given to the pool allocation", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Type is paged or nonp(aged)", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Allocs is count of all alloctions", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) is difference in Allocs column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Frees is count of all frees", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) difference in Frees column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Diff is (Allocs - Frees)", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Bytes is the total bytes consumed in pool", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) difference in Bytes column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Per Alloc is (Bytes / Diff)", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " switches:                                                                     ", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   ? or h - gives this help", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   q - quits", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   p - toggles default pool display between both, paged, and nonpaged", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   e - toggles totals lines on and off", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   l - toggles highlighting of changed lines on and off", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " sorting switches:", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   t - tag    a - allocations", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   f - frees  d - difference", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   b - bytes  m - per alloc", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (u is the same as b)", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "   ) - toggles sort between primary tag and value in (  )", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " command line switches", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -i<tag> - list only matching tags", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -x<tag> - list everything except matching tags", FALSE );
    WriteConsoleLine( PopupHandle, n++, "           <tag> can include * and ?", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -peltafdbum) - as listed above", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );

    while (TRUE) {
        if (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0 &&
            ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
            InputRecord.EventType == KEY_EVENT &&
            InputRecord.Event.KeyEvent.bKeyDown &&
            InputRecord.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE
           ) {
            break;
        }
    }

    SetConsoleActiveScreenBuffer( OutputHandle );
    CloseHandle( PopupHandle );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perfmtr\perfmtr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    perfmtr.c

Abstract:

    This module contains the NT/Win32 Performance Meter

Author:

    Mark Lucovsky (markl) 28-Mar-1991

Revision History:

--*/

#include "perfmtrp.h"

#define CPU_USAGE 0
#define VM_USAGE 1
#define POOL_USAGE 2
#define IO_USAGE 3
#define SRV_USAGE 4
#define CACHE_READS 5
#define VDM_USAGE 6
#define FILE_CACHE 7
#define RESIDENT_MEM 8

//
// Hi-Tech macro to figure out how much a field has changed by.
//

#define delta(FLD) (PerfInfo.FLD - PreviousPerfInfo.FLD)

#define vdelta(FLD) (VdmInfo.FLD - PreviousVdmInfo.FLD)

//
// Delta combining Wait and NoWait cases.
//

#define deltac(FLD) (delta(FLD##Wait) + delta(FLD##NoWait))

//
// Hit Rate Macro (includes a rare trip to MulDivia...)
//

#define hitrate(FLD) (((Changes = delta(FLD)) == 0) ? 0 :                                         \
                      ((Changes < (Misses = delta(FLD##Miss))) ? 0 :                              \
                      ((Changes - Misses) * 100 / Changes)))

//
// Hit Rate Macro combining Wait and NoWait cases
//

#define hitratec(FLD) (((Changes = deltac(FLD)) == 0) ? 0 :                                        \
                       ((Changes < (Misses = delta(FLD##WaitMiss) + delta(FLD##NoWaitMiss))) ? 0 : \
                       ((Changes - Misses) * 100 / Changes)))

//
// Arbitrary percent calculation.
//

#define percent(PART,TOTAL) (((TOTAL) == 0) ? 0 : ((PART) * 100 / (TOTAL)))

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{

    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_PERFORMANCE_INFORMATION PreviousPerfInfo;

#ifdef i386
    SYSTEM_VDM_INSTEMUL_INFO VdmInfo;
    SYSTEM_VDM_INSTEMUL_INFO PreviousVdmInfo;
#endif

    LARGE_INTEGER EndTime, BeginTime, ElapsedTime;
    ULONG DelayTimeMsec;
    ULONG DelayTimeTicks;
    ULONG PercentIdle;
    ULONG IdleDots;
    ULONG ProcessCount, ThreadCount, FileCount;
    ULONG Changes, Misses;
    POBJECT_TYPE_INFORMATION ObjectInfo;
    WCHAR Buffer[ 256 ];
    SYSTEM_FILECACHE_INFORMATION FileCacheInfo;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    ULONG PreviousFileCacheFaultCount;
    BOOLEAN PrintHelp = TRUE;
    BOOLEAN PrintHeader = TRUE;
    ULONG DisplayType = CPU_USAGE;
    INPUT_RECORD InputRecord;
    HANDLE ScreenHandle;
    UCHAR LastKey;
    ULONG NumberOfInputRecords;

    SRV_STATISTICS ServerInfo;
    SRV_STATISTICS PreviousServerInfo;
    HANDLE ServerDeviceHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    BOOLEAN ZeroServerStats;
    STRING DeviceName;
    UNICODE_STRING DeviceNameU;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE NullDeviceHandle = NULL;

    DelayTimeMsec = 2500;
    DelayTimeTicks = DelayTimeMsec * 10000;


    RtlInitString( &DeviceName, "\\Device\\Null" );
    RtlAnsiStringToUnicodeString(&DeviceNameU, &DeviceName, TRUE);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceNameU,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                 &NullDeviceHandle,
                 SYNCHRONIZE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 0,
                 FILE_SYNCHRONOUS_IO_NONALERT
                 );

    RtlFreeUnicodeString(&DeviceNameU);

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }
    if (!NT_SUCCESS(Status)) {
        printf(  "NtOpenFile (NULL device object) failed: %X\n", Status );
        return 0;
    }

    ScreenHandle = GetStdHandle (STD_INPUT_HANDLE);
    if (ScreenHandle == NULL) {
        printf("Error obtaining screen handle, error was: 0x%lx\n",
                GetLastError());
        return 0;
    }

    Status = NtQuerySystemInformation(
        SystemBasicInformation,
        &BasicInfo,
        sizeof(BasicInfo),
        NULL
        );

    if (NT_ERROR(Status)) {
        printf("Basic info failed x%lx\n",Status);
        return 0;
    }

    NtQuerySystemInformation(
        SystemPerformanceInformation,
        &PerfInfo,
        sizeof(PerfInfo),
        NULL
        );

    PreviousPerfInfo = PerfInfo;
#ifdef i386
    NtQuerySystemInformation(
        SystemVdmInstemulInformation,
        &VdmInfo,
        sizeof(VdmInfo),
        NULL
        );
    PreviousVdmInfo = VdmInfo;
#endif

    if ( argc > 1 ) {
        if ( argv[1][0] == '-' || argv[1][0] == '/') {
            switch ( argv[1][1] ) {
                case 'C':
                case 'c':
                    DisplayType = CPU_USAGE;
                    PrintHelp = FALSE;
                    break;

                case 'F':
                case 'f':
                    DisplayType = FILE_CACHE;
                    PrintHelp = FALSE;
                    PreviousFileCacheFaultCount = 0;
                    break;

                case 'v':
                case 'V':
                    DisplayType = VM_USAGE;
                    PrintHelp = FALSE;
                    break;

                case 'P':
                case 'p':
                    DisplayType = POOL_USAGE;
                    PrintHelp = FALSE;
                    break;

                case 'I':
                case 'i':
                    DisplayType = IO_USAGE;
                    PrintHelp = FALSE;
                    break;

#ifdef i386
                case 'X':
                case 'x':
                    DisplayType = VDM_USAGE;
                    PrintHelp = FALSE;
                    break;
#endif

                case 'S':
                case 's':
                    DisplayType = SRV_USAGE;
                    PrintHelp = FALSE;
                    ZeroServerStats = TRUE;
                    break;

                case 'R':
                case 'r':
                    DisplayType = CACHE_READS;
                    PrintHelp = FALSE;
                    break;

                case '?':
                default:
                    PrintHelp = FALSE;
                    printf("\nType :\n"
                           "\t'C'  for CPU usage\n"
                           "\t'V'  for VM usage\n"
                           "\t'F'  for File Cache usage\n"
                           "\t'R'  for Cache Manager reads and writes\n"
                           "\t'P'  for POOL usage\n"
                           "\t'I'  for I/O usage\n"
#ifdef i386
                           "\t'X'  for x86 Vdm Stats\n"
#endif
                           "\t'S'  for Server Stats\n"
                           "\t'H'  for header\n"
                           "\t'Q'  to quit\n\n");
            }
        }
    }

    while(TRUE) {

        while (WaitForSingleObject( ScreenHandle, DelayTimeMsec ) == STATUS_WAIT_0) {

            //
            // Check for input record
            //

            if (ReadConsoleInput( ScreenHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
                InputRecord.EventType == KEY_EVENT &&
                InputRecord.Event.KeyEvent.bKeyDown
               ) {
                LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;


                //
                // Ignore control characters.
                //

                if (LastKey >= ' ') {

                    switch (toupper( LastKey )) {

                        case 'C':
                            DisplayType = CPU_USAGE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            break;

                        case 'F':
                            DisplayType = FILE_CACHE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            PreviousFileCacheFaultCount = 0;
                            break;

                        case 'H':
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            break;

                        case 'V':
                            DisplayType = VM_USAGE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            PreviousPerfInfo = PerfInfo;
                            break;

                        case 'P':
                            DisplayType = POOL_USAGE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            break;

                        case 'I':
                            DisplayType = IO_USAGE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            break;

#ifdef i386
                        case 'X':
                            DisplayType = VDM_USAGE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            break;
#endif

                        case 'S':
                            DisplayType = SRV_USAGE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            ZeroServerStats = TRUE;
                            break;

                        case 'R':
                            DisplayType = CACHE_READS;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            break;

                        case 'Q':
                            if (ServerDeviceHandle != NULL) {
                                NtClose(ServerDeviceHandle);
                            }
                            ExitProcess(0);

                        default:
                            break;
                    }
                }
            }
        }
        if (PrintHelp) {
            printf("\nType :\n"
                   "\t'C'  for CPU usage\n"
                   "\t'V'  for VM usage\n"
                   "\t'F'  for File Cache usage\n"
                   "\t'R'  for Cache Manager reads and writes\n"
                   "\t'P'  for POOL usage\n"
                   "\t'I'  for I/O usage\n"
#ifdef i386
                   "\t'X'  for x86 Vdm Stats\n"
#endif
                   "\t'S'  for Server Stats\n"
                   "\t'H'  for header\n"
                   "\t'Q'  to quit\n\n");
            PrintHelp = FALSE;
        }

        NtQuerySystemInformation(
            SystemPerformanceInformation,
            &PerfInfo,
            sizeof(PerfInfo),
            NULL
            );
#ifdef i386
        NtQuerySystemInformation(
            SystemVdmInstemulInformation,
            &VdmInfo,
            sizeof(VdmInfo),
            NULL
            );
#endif

        ObjectInfo = (POBJECT_TYPE_INFORMATION)Buffer;
        NtQueryObject( NtCurrentProcess(),
                       ObjectTypeInformation,
                       ObjectInfo,
                       sizeof( Buffer ),
                       NULL
                     );
        ProcessCount = ObjectInfo->TotalNumberOfObjects;

        NtQueryObject( NtCurrentThread(),
                       ObjectTypeInformation,
                       ObjectInfo,
                       sizeof( Buffer ),
                       NULL
                     );
        ThreadCount = ObjectInfo->TotalNumberOfObjects;

        NtQueryObject( NullDeviceHandle,
                       ObjectTypeInformation,
                       ObjectInfo,
                       sizeof( Buffer ),
                       NULL
                     );
        FileCount = ObjectInfo->TotalNumberOfObjects;

        switch (DisplayType) {

        case CPU_USAGE:

            EndTime = *(PLARGE_INTEGER)&PerfInfo.IdleProcessTime;
            BeginTime = *(PLARGE_INTEGER)&PreviousPerfInfo.IdleProcessTime;

            ElapsedTime.QuadPart = EndTime.QuadPart - BeginTime.QuadPart;
            PercentIdle = ((ElapsedTime.LowPart/BasicInfo.NumberOfProcessors)*100) / DelayTimeTicks;

            //
            //  Sometimes it takes significantly longer than 2.5 seconds
            //  to make a round trip.
            //

            if ( PercentIdle > 100 ) {

                PercentIdle = 100;
            }

            IdleDots = DOT_BUFF_LEN - (PercentIdle / 10 );

            memset(DotBuff,' ',DOT_BUFF_LEN);
            DotBuff[DOT_BUFF_LEN] = '|';
            DotBuff[DOT_BUFF_LEN+1] = '\0';
            memset(DotBuff,DOT_CHAR,IdleDots);

            if (PrintHeader) {
                printf("CPU Usage  Page Page Page InCore NonP Pgd  Incore Pgd  Incore Incore Proc Thd\n");
                printf("           Flts Aval Pool PgPool Pool Krnl  Krnl  Drvr  Drvr  Cache  Cnt  Cnt\n");
                PrintHeader = FALSE;
            }

            printf( "%s", DotBuff );
            printf( "%4ld %4ld %4ld (%4ld) %4ld %4ld (%4ld) %4ld (%4ld) (%4ld) %3ld %4ld\n",
                    PerfInfo.PageFaultCount - PreviousPerfInfo.PageFaultCount,
                    PerfInfo.AvailablePages,
                    PerfInfo.PagedPoolPages,
                    PerfInfo.ResidentPagedPoolPage,
                    PerfInfo.NonPagedPoolPages,
                    PerfInfo.TotalSystemCodePages,
                    PerfInfo.ResidentSystemCodePage,
                    PerfInfo.TotalSystemDriverPages,
                    PerfInfo.ResidentSystemDriverPage,
                    PerfInfo.ResidentSystemCachePage,
                    ProcessCount,
                    ThreadCount
                  );
            break;

        case VM_USAGE:

            if (PrintHeader) {
                printf("avail  page   COW  Tran  Cache Demd Read  Read Cache Cache Page Write Map   Map\n");
                printf("pages faults             Tran  zero flts  I/Os  flts  I/Os writ I/Os  write I/O\n");
                PrintHeader = FALSE;
            }

            printf( "%5ld %5ld %4ld %5ld %5ld %5ld %5ld %5ld %5ld%5ld%5ld%5ld%6ld%5ld\n",
                    PerfInfo.AvailablePages,
                    PerfInfo.PageFaultCount - PreviousPerfInfo.PageFaultCount,
                    PerfInfo.CopyOnWriteCount - PreviousPerfInfo.CopyOnWriteCount,
                    PerfInfo.TransitionCount - PreviousPerfInfo.TransitionCount,
                    PerfInfo.CacheTransitionCount - PreviousPerfInfo.CacheTransitionCount,
                    PerfInfo.DemandZeroCount - PreviousPerfInfo.DemandZeroCount,
                    PerfInfo.PageReadCount - PreviousPerfInfo.PageReadCount,
                    PerfInfo.PageReadIoCount - PreviousPerfInfo.PageReadIoCount,
                    PerfInfo.CacheReadCount - PreviousPerfInfo.CacheReadCount,
                    PerfInfo.CacheIoCount - PreviousPerfInfo.CacheIoCount,
                    PerfInfo.DirtyPagesWriteCount - PreviousPerfInfo.DirtyPagesWriteCount,
                    PerfInfo.DirtyWriteIoCount - PreviousPerfInfo.DirtyWriteIoCount,
                    PerfInfo.MappedPagesWriteCount - PreviousPerfInfo.MappedPagesWriteCount,
                    PerfInfo.MappedWriteIoCount - PreviousPerfInfo.MappedWriteIoCount
                 );


            break;

        case CACHE_READS:

            if (PrintHeader) {
                PrintHeader = FALSE;
                printf("    Map    Cnv     Pin       Copy        Mdl     Read Fast  Fast Fast Lazy Lazy\n");
                printf("    Read   To      Read      Read        Read    Ahed Read  Read Read Wrts Wrt\n");
                printf("      Hit  Pin        Hit        Hit        Hit  I/Os Calls Resc Not  I/Os Pgs\n");
                printf("Count Rate Rate Count Rate Count Rate Count Rate            Miss Poss         \n");
            }

            printf("%05ld %4ld %4ld %05ld %4ld %05ld %4ld %05ld %4ld %4ld %5ld %4ld %4ld %4ld %4ld\n",
                   deltac(CcMapData),
                   hitratec(CcMapData),
                   percent(delta(CcPinMappedDataCount),deltac(CcMapData)),
                   deltac(CcPinRead),
                   hitratec(CcPinRead),
                   deltac(CcCopyRead),
                   hitratec(CcCopyRead),
                   deltac(CcMdlRead),
                   hitratec(CcMdlRead),
                   delta(CcReadAheadIos),
                   deltac(CcFastRead),
                   delta(CcFastReadResourceMiss),
                   delta(CcFastReadNotPossible),
                   delta(CcLazyWriteIos),
                   delta(CcLazyWritePages));
            break;
#ifdef i386
        case VDM_USAGE:

            if (PrintHeader) {
                PrintHeader = FALSE;
                printf("PUSHF  POPF  IRET   HLT   CLI   STI   BOP SEGNOTP\n");
            }

            printf("%5d %5d %5d %5d %5d %5d %5d %7d\n",
                   vdelta(OpcodePUSHF),
                   vdelta(OpcodePOPF),
                   vdelta(OpcodeIRET),
                   vdelta(OpcodeHLT),
                   vdelta(OpcodeCLI),
                   vdelta(OpcodeSTI),
                   vdelta(BopCount),
                   vdelta(SegmentNotPresent)
                  );
            break;
#endif
        case POOL_USAGE:

            if (PrintHeader) {
                printf("Paged Paged Paged  Non   Non    Non    Page Paged Non    Commit  Commit SysPte\n");
                printf("Alloc Freed   A-F  Alloc Freed  A-F    Aval Pages Pages  Pages   Limit   Free\n");
                PrintHeader = FALSE;
            }

            printf( "%5ld %5ld %5ld %5ld %5ld %5ld   %5ld %5ld %5ld %6ld %6ld %7ld\n",
                    PerfInfo.PagedPoolAllocs - PreviousPerfInfo.PagedPoolAllocs,
                    PerfInfo.PagedPoolFrees - PreviousPerfInfo.PagedPoolFrees,
                    PerfInfo.PagedPoolAllocs - PerfInfo.PagedPoolFrees,
                    PerfInfo.NonPagedPoolAllocs - PreviousPerfInfo.NonPagedPoolAllocs,
                    PerfInfo.NonPagedPoolFrees - PreviousPerfInfo.NonPagedPoolFrees,
                    PerfInfo.NonPagedPoolAllocs - PerfInfo.NonPagedPoolFrees,
                    PerfInfo.AvailablePages,
                    PerfInfo.PagedPoolPages,
                    PerfInfo.NonPagedPoolPages,
                    PerfInfo.CommittedPages,
                    PerfInfo.CommitLimit,
                    PerfInfo.FreeSystemPtes
                 );


            break;

        case IO_USAGE:

            if (PrintHeader) {
                printf(" Read Write Other     Read    Write    Other     File       File\n");
                printf(" I/Os  I/Os  I/Os     Xfer     Xfer     Xfer    Objects    Handles\n");
                PrintHeader = FALSE;
            }

            printf( "%5ld %5ld %5ld %8ld %8ld %8ld %8ld   %8ld\n",
                    PerfInfo.IoReadOperationCount - PreviousPerfInfo.IoReadOperationCount,
                    PerfInfo.IoWriteOperationCount - PreviousPerfInfo.IoWriteOperationCount,
                    PerfInfo.IoOtherOperationCount - PreviousPerfInfo.IoOtherOperationCount,
                        PerfInfo.IoReadTransferCount.QuadPart -
                        PreviousPerfInfo.IoReadTransferCount.QuadPart,
                        PerfInfo.IoWriteTransferCount.QuadPart -
                        PreviousPerfInfo.IoWriteTransferCount.QuadPart,
                        PerfInfo.IoOtherTransferCount.QuadPart -
                        PreviousPerfInfo.IoOtherTransferCount.QuadPart,
                    FileCount,
                    ObjectInfo->TotalNumberOfHandles
                 );


            break;

        case SRV_USAGE:

            if (ServerDeviceHandle == NULL) {
                RtlInitString( &DeviceName, SERVER_DEVICE_NAME );
                RtlAnsiStringToUnicodeString(&DeviceNameU, &DeviceName, TRUE);
                InitializeObjectAttributes(
                    &ObjectAttributes,
                    &DeviceNameU,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );


                Status = NtOpenFile(
                             &ServerDeviceHandle,
                             SYNCHRONIZE,
                             &ObjectAttributes,
                             &IoStatusBlock,
                             0,
                             FILE_SYNCHRONOUS_IO_NONALERT
                             );

                RtlFreeUnicodeString(&DeviceNameU);

                if (NT_SUCCESS(Status)) {
                    Status = IoStatusBlock.Status;
                }
                if (!NT_SUCCESS(Status)) {
                    printf(  "NtOpenFile (server device object) failed: %X\n", Status );
                    break;
                }

            }

            Status = NtFsControlFile(
                         ServerDeviceHandle,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         FSCTL_SRV_GET_STATISTICS,
                         NULL, 0,
                         &ServerInfo, sizeof(ServerInfo)
                         );
            if (NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
            }
            if (!NT_SUCCESS(Status)) {
                printf(  "NtFsControlFile failed: %X\n", Status );
                ServerDeviceHandle = NULL;
                break;
            }

            if (PrintHeader) {
                printf( "  Bytes   Bytes    Paged NonPaged                Logn WItm\n");
                printf( "   Rcvd    Sent     Pool     Pool Sess File Srch Errs Shtg\n");
                PrintHeader = FALSE;
            }

            if (ZeroServerStats) {
                PreviousServerInfo = ServerInfo;
                ZeroServerStats = FALSE;
            }

            {
                LARGE_INTEGER BytesReceived, BytesSent;

                BytesReceived.QuadPart =
                                    ServerInfo.TotalBytesReceived.QuadPart -
                                PreviousServerInfo.TotalBytesReceived.QuadPart;
                BytesSent.QuadPart =
                                ServerInfo.TotalBytesSent.QuadPart -
                                PreviousServerInfo.TotalBytesSent.QuadPart;

                printf( "%7ld %7ld %8ld %8ld %4ld %4ld %4ld %4ld %4ld\n",
                            BytesReceived.LowPart,
                            BytesSent.LowPart,
                            ServerInfo.CurrentPagedPoolUsage,
                            ServerInfo.CurrentNonPagedPoolUsage,
                            ServerInfo.CurrentNumberOfSessions,
                            ServerInfo.CurrentNumberOfOpenFiles,
                            ServerInfo.CurrentNumberOfOpenSearches,
                            ServerInfo.LogonErrors,
                            ServerInfo.WorkItemShortages
                            );
            }

            PreviousServerInfo = ServerInfo;
            break;

        case FILE_CACHE:

            if (PrintHeader) {
                printf("Avail  Page   Current  Peak    Fault    Fault\n");
                printf("Pages Faults  Size Kb  Size    Total    Count\n");
                PrintHeader = FALSE;
            }

            NtQuerySystemInformation(
                SystemFileCacheInformation,
                &FileCacheInfo,
                sizeof(FileCacheInfo),
                NULL
                );

            printf( "%5ld %5ld %7ld %7ld %8ld %8ld\n",
                    PerfInfo.AvailablePages,
                    PerfInfo.PageFaultCount - PreviousPerfInfo.PageFaultCount,
                    FileCacheInfo.CurrentSize / 1024,
                    FileCacheInfo.PeakSize / 1024,
                    FileCacheInfo.PageFaultCount,
                    FileCacheInfo.PageFaultCount - PreviousFileCacheFaultCount
                 );

            PreviousFileCacheFaultCount = FileCacheInfo.PageFaultCount;
            break;

        }
        PreviousPerfInfo = PerfInfo;
#ifdef i386
        PreviousVdmInfo = VdmInfo;
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perfmtr\lookmon.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    lookmon.c

Abstract:

    This module contains the NT/Win32 Lookaside List Monitor

Author:

    David N. Cutler (davec) 8-Jun-1996

Revision History:

--*/

#include "perfmtrp.h"
#include <search.h>
#include <malloc.h>
#include <limits.h>
#include <stdlib.h>

//
// Define lookaside query information buffer size and buffers.
//

#define BUFFER_SIZE (64 * 1024 / sizeof(ULONG))

ULONG LargeBuffer1[BUFFER_SIZE];
ULONG LargeBuffer2[BUFFER_SIZE];

//
// Define lookaside output structure and lookaside output information buffer.
//

typedef struct _LOOKASIDE_OUTPUT {
    USHORT CurrentDepth;
    USHORT MaximumDepth;
    ULONG Allocates;
    ULONG AllocateRate;
    ULONG AllocateHits;
    ULONG AllocateMisses;
    ULONG Frees;
    ULONG FreeRate;
    ULONG Type;
    ULONG Tag;
    ULONG Size;
    LOGICAL Changed;
} LOOKASIDE_OUTPUT, *PLOOKASIDE_OUTPUT;

LOOKASIDE_OUTPUT OutputBuffer[1000];

//
// Define sort types and default sort type.
//

#define TOTAL_ALLOCATES 0
#define ALLOCATE_HITS 1
#define ALLOCATE_MISSES 2
#define CURRENT_DEPTH 3
#define MAXIMUM_DEPTH 4
#define RATE 5
#define TAG 6
#define CURRENT_BYTES 7

ULONG SortBy = TAG;

//
// Define pool types to include and default pool type.
//

#define NONPAGED 0
#define PAGED 1
#define BOTH 2

UCHAR *PoolType[] = {
    "Nonp",
    "Page"
};

ULONG DisplayType = BOTH;

//
// Define miscellaneous values.
//

ULONG DelayTimeMsec = 5000;
ULONG NumberOfInputRecords;
INPUT_RECORD InputRecord;
HANDLE InputHandle;
HANDLE OutputHandle;
DWORD OriginalInputMode;
WORD NormalAttribute;
WORD HighlightAttribute;
ULONG NumberOfCols;
ULONG NumberOfRows;
SIZE_T FirstDetailLine = 0;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;
ULONG NoHighlight;

//
// Define filter structure and filter data.
//

#define MAX_FILTER 64

typedef struct _FILTER {
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    BOOLEAN Exclude;
} FILTER, *PFILTER;

FILTER Filter[MAX_FILTER];
ULONG FilterCount = 0;

VOID
ShowHelpPopup(
    VOID
    );

int
__cdecl
ulcomp(
    const void *e1,
    const void *e2
    );

int
__cdecl
ulcomp(
    const void *E1,
    const void *E2
    )

/*++

Routine Description:

    This function compares two lookaside entries and returns the comparison
    value based on the comparison type.

Arguments:

    E1 - Supplies a pointer to a lookaside output entry.

    E2 - Supplies a pointer to a lookaside output entry.

Return Value:

    A negative value is returned if the first lookaside entry compares less
    than the second lookaside entry. A zero value is returned if the two
    lookaside entries compare equal. A positive nonzero value is returned if
    the first lookaside entry is greater than the second lookaside entry.

--*/

{

    PUCHAR C1;
    PUCHAR C2;
    PLOOKASIDE_OUTPUT L1 = (PLOOKASIDE_OUTPUT)E1;
    PLOOKASIDE_OUTPUT L2 = (PLOOKASIDE_OUTPUT)E2;
    LONG U1;

    C1 = (PUCHAR)&L1->Tag;
    C2 = (PUCHAR)&L2->Tag;
    switch (SortBy) {

        //
        // Sort by number of allocations in descending order.
        //

    case TOTAL_ALLOCATES:
        return L2->Allocates - L1->Allocates;
        break;

        //
        // Sort by number of allocate hits in descending order.
        //

    case ALLOCATE_HITS:
        return L2->AllocateHits - L1->AllocateHits;
        break;

        //
        // Sort by number of allocate misses in descending order.
        //

    case ALLOCATE_MISSES:
        return L2->AllocateMisses - L1->AllocateMisses;
        break;

        //
        // Sort by current depth in descending order.
        //

    case CURRENT_DEPTH:
        return L2->CurrentDepth - L1->CurrentDepth;
        break;

        //
        // Sort by current total bytes in descending order.
        //

    case CURRENT_BYTES:
        return ((L2->Size * L2->CurrentDepth) - (L1->Size * L1->CurrentDepth));
        break;

        //
        // Sort by maximum depth in descending order.
        //

    case MAXIMUM_DEPTH:
        return L2->MaximumDepth - L1->MaximumDepth;
        break;

        //
        // Sort by allocation rate in descending order.
        //

    case RATE:
        return L2->AllocateRate - L1->AllocateRate;
        break;

        //
        // Sort by tag, type, and size.
        //

    case TAG:
        U1 = *C1++ - *C2++;
        if (U1 == 0) {
            U1 = *C1++ - *C2++;
            if (U1 == 0) {
                U1 = *C1++ - *C2++;
                if (U1 == 0) {
                    U1 = *C1 - *C2;
                    if (U1 == 0) {
                        U1 = L1->Type - L2->Type;
                        if (U1 == 0) {
                            U1 = L1->Size - L2->Size;
                        }
                    }
                }
            }
        }

        return U1;
        break;
    }

    return 0;
}

LOGICAL
CheckSingleFilter (
    PUCHAR Tag,
    PUCHAR Filter
    )

{
    UCHAR Fc;
    ULONG Index;
    UCHAR Tc;

    //
    // Check if tag matches filter.
    //

    for (Index = 0; Index < 4; Index += 1) {
        Fc = *Filter++;
        Tc = *Tag++;
        if (Fc == '*') {
             return TRUE;

        } else if (Fc == '?') {
            continue;

        } else if (Fc != Tc) {
            return FALSE;
        }
    }

    return TRUE;
}

LOGICAL
CheckFilters (
    PUCHAR Tag
    )

{

    ULONG Index;
    LOGICAL Pass;

    //
    // If there are no filters, then all tags pass. Otherwise, tags pass or
    // do not pass based on whether they are included or excluded.
    //

    Pass = TRUE;
    if (FilterCount != 0) {

        //
        // If the first filter excludes tags, then any tag not explicitly
        // specified passes. If the first filter includes tags, then any
        // tag not explicitly specified fails.
        //

        Pass = Filter[0].Exclude;
        for (Index = 0; Index < FilterCount; Index += 1) {
            if (CheckSingleFilter(Tag, (PUCHAR)&Filter[Index].Tag) != FALSE) {
                Pass = !Filter[Index].Exclude;
                break;
            }
        }
    }

    return Pass;
}

VOID
AddFilter (
    BOOLEAN Exclude,
    PCHAR FilterString
    )

{

    PFILTER f;
    ULONG i;
    PCHAR p;

    if (FilterCount == MAX_FILTER) {
        printf("Too many filters specified.  Limit is %d\n", MAX_FILTER);
        return;
    }

    f = &Filter[FilterCount];
    p = f->Tag;

    for (i = 0; i < 4; i++) {
        if (*FilterString == 0) {
            break;
        }

        *p++ = *FilterString++;
    }

    for (; i < 4; i++) {
        *p++ = ' ';
    }

    f->Exclude = Exclude;
    FilterCount += 1;
    return;
}

VOID
ParseArgs (
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    This function parses the input arguments and sets global state variables.

Arguments:

    argc - Supplies the number of argument strings.

    argv - Supplies a pointer to an array of pointers to argument strings.

Return Value:

    None.

--*/

{

    char *p;
    BOOLEAN exclude;

    argc -= 1;
    argv += 1;
    while (argc-- > 0) {
        p  = *argv++;
        if (*p == '-' || *p == '/') {
            p++;
            exclude = TRUE;
            switch (tolower(*p)) {
            case 'i':
                exclude = FALSE;
            case 'x':
                p++;
                if (strlen(p) == 0) {
                    printf("missing filter string\n");
                    ExitProcess(1);

                } else if (strlen(p) > sizeof(ULONG)) {
                    printf("filter string too long: %s\n", p);
                    ExitProcess(1);
                }

                AddFilter(exclude, p);
                break;

            default:
                printf("unknown switch: %s\n", p);
                ExitProcess(2);
            }

        } else {
            printf("unknown switch: %s\n", p);
            ExitProcess(2);
        }
    }

    return;
}

LOGICAL
WriteConsoleLine(
    HANDLE OutputHandle,
    WORD LineNumber,
    LPSTR Text,
    LOGICAL Highlight
    )

{

    COORD WriteCoord;
    DWORD NumberWritten;
    DWORD TextLength;

    WriteCoord.X = 0;
    WriteCoord.Y = LineNumber;
    if (!FillConsoleOutputCharacter(OutputHandle,
                                    ' ',
                                    NumberOfCols,
                                    WriteCoord,
                                    &NumberWritten)) {
        return FALSE;
    }

    if (!FillConsoleOutputAttribute(OutputHandle,
                                    (WORD)((Highlight && !NoHighlight) ? HighlightAttribute : NormalAttribute),
                                    NumberOfCols,
                                    WriteCoord,
                                    &NumberWritten)) {
        return FALSE;
    }


    if (Text == NULL || (TextLength = strlen(Text)) == 0) {
        return TRUE;

    } else {
        return WriteConsoleOutputCharacter(OutputHandle,
                                           Text,
                                           TextLength,
                                           WriteCoord,
                                           &NumberWritten);
    }
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    This function is the main program entry.

Arguments:

    argc - Supplies the number of argument strings.

    argv - Supplies a pointer to an array of pointers to argument strings.

Return Value:

    Final execution status.

--*/

{

    SIZE_T ActiveNumber;
    CHAR Buffer[512];
    SYSTEM_BASIC_INFORMATION BasicInfo;
    PULONG CurrentBuffer;
    ULONG GeneralNonpagedTotal;
    ULONG GeneralPagedTotal;
    SIZE_T Index;
    BOOLEAN Interactive;
    ULONG Length;
    ULONG LinesInHeader;
    PSYSTEM_LOOKASIDE_INFORMATION LookasideNew;
    PSYSTEM_LOOKASIDE_INFORMATION LookasideOld;
    HANDLE OriginalOutputHandle;
    PLOOKASIDE_OUTPUT Output;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    ULONG PoolNonpagedTotal;
    ULONG PoolPagedTotal;
    PULONG PreviousBuffer;
    NTSTATUS Status;
    PULONG TempBuffer;
    BOOLEAN DoHelp;
    BOOLEAN DoQuit;
    UCHAR LastKey;
    LONG ScrollDelta;
    WORD DisplayLine;
    UCHAR T1;
    UCHAR T2;
    UCHAR T3;
    UCHAR T4;

    //
    // Parse command line arguments.
    //

    DoHelp = FALSE;
    DoQuit = FALSE;
    Interactive = TRUE;
    ParseArgs(argc, argv);

    //
    // Get input and output handles.
    //

    InputHandle = GetStdHandle(STD_INPUT_HANDLE);
    OriginalOutputHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    if (InputHandle == NULL ||
        OriginalOutputHandle == NULL ||
        !GetConsoleMode(InputHandle, &OriginalInputMode)) {
        Interactive = FALSE;

    } else {
        OutputHandle = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                                 FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                 NULL,
                                                 CONSOLE_TEXTMODE_BUFFER,
                                                 NULL);

        if (OutputHandle == NULL ||
            !GetConsoleScreenBufferInfo(OriginalOutputHandle, &OriginalConsoleInfo) ||
            !SetConsoleScreenBufferSize(OutputHandle, OriginalConsoleInfo.dwSize) ||
            !SetConsoleActiveScreenBuffer(OutputHandle) ||
            !SetConsoleMode(InputHandle, 0)) {
            if (OutputHandle != NULL) {
                CloseHandle(OutputHandle);
                OutputHandle = NULL;
            }

            Interactive = FALSE;

        } else {
            NormalAttribute = 0x1F;
            HighlightAttribute = 0x71;
            NumberOfCols = OriginalConsoleInfo.dwSize.X;
            NumberOfRows = OriginalConsoleInfo.dwSize.Y;
        }
    }

    NtQuerySystemInformation(SystemBasicInformation,
                             &BasicInfo,
                             sizeof(BasicInfo),
                             NULL);

    //
    // If the priority class on the current process is normal, then raise
    // the priority class to high.
    //

    if (GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS) {
        SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
    }

    //
    // Continuously display the lookaside information until an exit signal
    // is received.
    //

    CurrentBuffer = &LargeBuffer1[0];
    PreviousBuffer = &LargeBuffer2[0];
    while(TRUE) {
        Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                          &PerfInfo,
                                          sizeof(PerfInfo),
                                          NULL);

        if (!NT_SUCCESS(Status)) {
            printf("Query performance information failed %lx\n", Status);
            break;
        }


        //
        // Query system lookaside information.
        //

        Status = NtQuerySystemInformation(SystemLookasideInformation,
                                          CurrentBuffer,
                                          BUFFER_SIZE,
                                          &Length);

        if (!NT_SUCCESS(Status)) {
            printf("Query lookaside information failed %lx\n", Status);
            break;
        }

        //
        // Compute total memory allocated to paged and nonpaged lookaside
        // lists.
        //

        Length /= sizeof(SYSTEM_LOOKASIDE_INFORMATION);

        LookasideNew = (PSYSTEM_LOOKASIDE_INFORMATION)CurrentBuffer;
        GeneralNonpagedTotal = 0;
        GeneralPagedTotal = 0;
        PoolNonpagedTotal = 0;
        PoolPagedTotal = 0;
        for (Index = 0; Index < Length; Index += 1) {
            
            if ((LookasideNew->Tag == 'looP') ||
                (LookasideNew->Tag == 'LooP')) {
                if (LookasideNew->Type == NONPAGED) {
                    PoolNonpagedTotal +=
                        (LookasideNew->CurrentDepth * LookasideNew->Size);

                } else {
                    PoolPagedTotal +=
                        (LookasideNew->CurrentDepth * LookasideNew->Size);
                }

            } else {
                if (LookasideNew->Type == NONPAGED) {
                    GeneralNonpagedTotal +=
                        (LookasideNew->CurrentDepth * LookasideNew->Size);

                } else {
                    GeneralPagedTotal +=
                        (LookasideNew->CurrentDepth * LookasideNew->Size);
                }
            }

            LookasideNew += 1;
        }

        //
        // Output total memory and available memory in kbytes.
        //

        DisplayLine = 0;
        sprintf(Buffer,
                " Total Memory: %ldkb Available Memory: %ldkb",
                BasicInfo.NumberOfPhysicalPages * (BasicInfo.PageSize / 1024),
                PerfInfo.AvailablePages * (BasicInfo.PageSize / 1024));

        WriteConsoleLine(OutputHandle,
                         DisplayLine++,
                         Buffer,
                         FALSE);

        //
        // Output total memory reserved for nonpaged and paged pool.
        //

        sprintf(Buffer,
                " Pool    Memory - Nonpaged: %ldkb Paged: %ldkb",
                PerfInfo.NonPagedPoolPages * (BasicInfo.PageSize / 1024),
                PerfInfo.PagedPoolPages * (BasicInfo.PageSize / 1024));

        WriteConsoleLine(OutputHandle,
                         DisplayLine++,
                         Buffer,
                         FALSE);

        //
        // Output total memory allocated for nonpaged and paged lookaside
        // lists.
        //

        sprintf(Buffer,
                " Pool    Lookaside - Nonpaged: %ldkb Paged: %ldkb",
                PoolNonpagedTotal / 1024,
                PoolPagedTotal / 1024);

        WriteConsoleLine(OutputHandle,
                         DisplayLine++,
                         Buffer,
                         FALSE);

        sprintf(Buffer,
                " General Lookaside - Nonpaged: %ldkb Paged: %ldkb",
                GeneralNonpagedTotal / 1024,
                GeneralPagedTotal / 1024);

        WriteConsoleLine(OutputHandle,
                         DisplayLine++,
                         Buffer,
                         FALSE);

        //
        // Output report headings.
        //

        WriteConsoleLine(OutputHandle,
                         DisplayLine++,
                         " Tag  Type Size CurDp MaxDp CurBytes Allocates Rate   Frees   Rate  A-Hits A-Misses",
                         FALSE);

        WriteConsoleLine(OutputHandle,
                         DisplayLine++,
                         NULL,
                         FALSE);

        //
        // Extract the specified lookaside information.
        //

        LinesInHeader = DisplayLine;
        LookasideNew = (PSYSTEM_LOOKASIDE_INFORMATION)CurrentBuffer;
        LookasideOld = (PSYSTEM_LOOKASIDE_INFORMATION)PreviousBuffer;
        Output = &OutputBuffer[0];
        for (Index = 0; Index < min(Length, sizeof(OutputBuffer)/sizeof(OutputBuffer[0])); Index += 1) {

            //
            // Check if the tag should be extracted.
            //

            if (!CheckFilters((PUCHAR)&LookasideNew[Index].Tag)) {
                continue;
            }

            //
            // Check if the lookaside information should be extracted.
            //

            if ((DisplayType == BOTH) ||
                ((LookasideNew[Index].Type == 0) && (DisplayType == NONPAGED)) ||
                ((LookasideNew[Index].Type != 0) && (DisplayType == PAGED))) {
                Output->CurrentDepth = LookasideNew[Index].CurrentDepth;
                Output->MaximumDepth = LookasideNew[Index].MaximumDepth;
                Output->Allocates = LookasideNew[Index].TotalAllocates;
                Output->AllocateRate = Output->Allocates - LookasideNew[Index].AllocateMisses;
                if (Output->Allocates != 0) {
                    Output->AllocateRate = (Output->AllocateRate * 100) / Output->Allocates;
                }

                Output->Frees = LookasideNew[Index].TotalFrees;
                Output->FreeRate = Output->Frees - LookasideNew[Index].FreeMisses;
                if (Output->Frees != 0) {
                    Output->FreeRate = (Output->FreeRate * 100) / Output->Frees;
                }

                Output->Tag = LookasideNew[Index].Tag & ~PROTECTED_POOL;

                Output->Type = LookasideNew[Index].Type;
                Output->Size = LookasideNew[Index].Size;
                if (LookasideNew[Index].Tag == LookasideOld[Index].Tag) {
                    Output->Changed =
                        LookasideNew[Index].CurrentDepth != LookasideOld[Index].CurrentDepth;

                    Output->AllocateMisses =
                        LookasideNew[Index].AllocateMisses - LookasideOld[Index].AllocateMisses;

                    Output->AllocateHits =
                        LookasideNew[Index].TotalAllocates - LookasideOld[Index].TotalAllocates - Output->AllocateMisses;

                } else {
                    Output->Changed = FALSE;
                    Output->AllocateHits = 0;
                    Output->AllocateMisses = 0;
                }

                Output += 1;
            }
        }

        //
        // Sort the extracted lookaside information.
        //

        ActiveNumber = Output - &OutputBuffer[0];
        qsort((void *)&OutputBuffer,
              (size_t)ActiveNumber,
              (size_t)sizeof(LOOKASIDE_OUTPUT),
              ulcomp);

        //
        // Display the selected information.
        //

        for (Index = FirstDetailLine; Index < ActiveNumber; Index += 1) {
            if (DisplayLine >= NumberOfRows) {
                break;
            }

            //
            // Check to make sure the tag is displayable.
            //

            if ((OutputBuffer[Index].Tag == 0) ||
                (OutputBuffer[Index].Tag == '    ')) {
                OutputBuffer[Index].Tag = 'nknU';
            }

            T1 = (UCHAR)(OutputBuffer[Index].Tag & 0xff);
            T2 = (UCHAR)((OutputBuffer[Index].Tag >> 8) & 0xff);
            T3 = (UCHAR)((OutputBuffer[Index].Tag >> 16) & 0xff);
            T4 = (UCHAR)((OutputBuffer[Index].Tag >> 24) & 0xff);
            if (T1 == 0) {
                T1 = ' ';
            }

            if (T2 == 0) {
                T2 = ' ';
            }

            if (T3 == 0) {
                T3 = ' ';
            }

            if (T4 == 0) {
                T4 = ' ';
            }

            if ((!isalpha(T1) && (T1 != ' ')) ||
                (!isalpha(T2) && (T2 != ' ')) ||
                (!isalpha(T3) && (T3 != ' ')) ||
                (!isalpha(T4) && (T4 != ' '))) {

                OutputBuffer[Index].Tag = 'nknU';

                T1 = (UCHAR)(OutputBuffer[Index].Tag & 0xff);
                T2 = (UCHAR)((OutputBuffer[Index].Tag >> 8) & 0xff);
                T3 = (UCHAR)((OutputBuffer[Index].Tag >> 16) & 0xff);
                T4 = (UCHAR)((OutputBuffer[Index].Tag >> 24) & 0xff);
            }

            sprintf(Buffer,
                    " %c%c%c%c %4s %4ld %5ld %5ld %8ld %9ld %3ld%% %9ld %3ld%%  %6ld  %6ld",
                    T1,
                    T2,
                    T3,
                    T4,
                    PoolType[OutputBuffer[Index].Type],
                    OutputBuffer[Index].Size,
                    OutputBuffer[Index].CurrentDepth,
                    OutputBuffer[Index].MaximumDepth,
                    OutputBuffer[Index].Size * OutputBuffer[Index].CurrentDepth,
                    OutputBuffer[Index].Allocates,
                    OutputBuffer[Index].AllocateRate,
                    OutputBuffer[Index].Frees,
                    OutputBuffer[Index].FreeRate,
                    OutputBuffer[Index].AllocateHits,
                    OutputBuffer[Index].AllocateMisses);

            WriteConsoleLine(OutputHandle,
                             DisplayLine++,
                             Buffer,
                             OutputBuffer[Index].Changed);
        }

        //
        // If the entire screen is not filled by the selected information,
        // then fill the rest of the screen with blank lines.
        //

        while (DisplayLine < NumberOfRows) {
            WriteConsoleLine(OutputHandle,
                             DisplayLine++,
                             "",
                             FALSE);
        }

        //
        // Wait for input or timeout.
        //

        TempBuffer = PreviousBuffer;
        PreviousBuffer = CurrentBuffer;
        CurrentBuffer = TempBuffer;
        while (WaitForSingleObject(InputHandle, DelayTimeMsec) == STATUS_WAIT_0) {

            //
            // Check for input record
            //

            if (ReadConsoleInput(InputHandle, &InputRecord, 1, &NumberOfInputRecords) &&
                InputRecord.EventType == KEY_EVENT &&
                InputRecord.Event.KeyEvent.bKeyDown) {
                LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;
                if (LastKey<' ') {
                    ScrollDelta = 0;
                    if (LastKey == 'C'-'A' + 1) {
                        DoQuit = TRUE;

                    } else switch (InputRecord.Event.KeyEvent.wVirtualKeyCode) {
                        case VK_ESCAPE:
                            DoQuit = TRUE;
                            break;

                        case VK_PRIOR:
                            ScrollDelta = -(LONG)(InputRecord.Event.KeyEvent.wRepeatCount * NumberOfRows);
                            break;

                        case VK_NEXT:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount * NumberOfRows;
                            break;

                        case VK_UP:
                            ScrollDelta = -InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_DOWN:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_HOME:
                            FirstDetailLine = 0;
                            break;

                        case VK_END:
                            if (ActiveNumber <= (NumberOfRows - LinesInHeader)) {
                                FirstDetailLine = 0;

                            } else {
                                FirstDetailLine = ActiveNumber - NumberOfRows + LinesInHeader;
                            }

                            break;
                    }

                    if (ScrollDelta != 0) {
                        if (ScrollDelta < 0) {
                            if (FirstDetailLine <= (ULONG)-ScrollDelta) {
                                FirstDetailLine = 0;

                            } else {
                                FirstDetailLine += ScrollDelta;
                            }

                        } else {
                            if ((ActiveNumber + LinesInHeader) > NumberOfRows) {
                                FirstDetailLine += ScrollDelta;
                                if (FirstDetailLine >= (ActiveNumber - NumberOfRows + LinesInHeader)) {
                                    FirstDetailLine = ActiveNumber - NumberOfRows + LinesInHeader;
                                }
                            }
                        }
                    }

                } else {
                    switch (toupper( LastKey )) {
                    case 'Q':
                        DoQuit = TRUE;
                        break;

                    case 'A':
                        SortBy = TOTAL_ALLOCATES;
                        FirstDetailLine = 0;
                        break;

                    case 'C':
                        SortBy = CURRENT_DEPTH;
                        FirstDetailLine = 0;
                        break;

                    case 'B':
                        SortBy = CURRENT_BYTES;
                        FirstDetailLine = 0;
                        break;

                    case 'H':
                    case '?':
                        DoHelp = TRUE;
                        break;

                    case 'L':
                        NoHighlight = 1 - NoHighlight;
                        break;

                    case 'M':
                        SortBy = MAXIMUM_DEPTH;
                        FirstDetailLine = 0;
                        break;

                    case 'P':
                        DisplayType += 1;
                        if (DisplayType > BOTH) {
                            DisplayType = NONPAGED;
                        }
                        FirstDetailLine = 0;
                        break;

                    case 'R':
                        SortBy = RATE;
                        FirstDetailLine = 0;
                        break;

                    case 'S':
                        SortBy = ALLOCATE_MISSES;
                        FirstDetailLine = 0;
                        break;

                    case 'T':
                        SortBy = TAG;
                        FirstDetailLine = 0;
                        break;

                    case 'X':
                        SortBy = ALLOCATE_HITS;
                        FirstDetailLine = 0;
                        break;
                    }
                }

                break;
            }
        }

        if (DoQuit) {
            break;
        }

        if (DoHelp) {
            DoHelp = FALSE;
            ShowHelpPopup();
        }
    }

    if (Interactive) {
        SetConsoleActiveScreenBuffer(OriginalOutputHandle);
        SetConsoleMode(InputHandle, OriginalInputMode);
        CloseHandle(OutputHandle);
    }

    ExitProcess(0);
    return 0;
}


VOID
ShowHelpPopup(
    VOID
    )

{

    HANDLE PopupHandle;
    WORD n;

    PopupHandle = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                            FILE_SHARE_WRITE | FILE_SHARE_READ,
                                            NULL,
                                            CONSOLE_TEXTMODE_BUFFER,
                                            NULL);
    if (PopupHandle == NULL) {
        return;
    }

    SetConsoleActiveScreenBuffer( PopupHandle );

    n = 0;

    WriteConsoleLine(PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine(PopupHandle, n++, "                        Lookaside Monitor Help", FALSE);
    WriteConsoleLine(PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine(PopupHandle, n++, " columns:", FALSE );
    WriteConsoleLine(PopupHandle, n++, "   Tag is the four character name of the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   Type is page(d) or nonp(aged)", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   Size is size of the pool allocation in bytes", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   CurDp is the current depth of the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   MaxDp is the maximum depth of the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   CurBytes is the total size of the current allocations of the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   Allocates is the total number of allocations from the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   Rate is the percent of allocates that hit in the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   Frees is the total number of frees to the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   Rate is the percent of frees that hit in the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   A-Hits is the number of allocation hits within the display period", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   A-Misses is the number of allocation misses within the display period", FALSE);
    WriteConsoleLine(PopupHandle, n++, NULL, FALSE);
    WriteConsoleLine(PopupHandle, n++, " switches:", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   ? or h - gives this help", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   l - toggles highlighting of changed lines on and off", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   q - quits", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   p - toggles default pool display between both, page(d), and nonp(aged)", FALSE);
    WriteConsoleLine(PopupHandle, n++, NULL, FALSE);
    WriteConsoleLine(PopupHandle, n++, " sorting switches:", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   a - sort by total allocations", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   c - sort by current depth", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   m - sort by maximum depth", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   b - sort by current total bytes", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   r - sort by allocation hit rate", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   s - sort by allocate misses", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   t - sort by tag, type, and size", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   x - sort by allocate hits", FALSE);
    WriteConsoleLine(PopupHandle, n++, NULL, FALSE);
    WriteConsoleLine(PopupHandle, n++, " command line switches", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   -i<tag> - list only matching tags", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   -x<tag> - list everything except matching tags", FALSE);
    WriteConsoleLine(PopupHandle, n++, "           <tag> can include * and ?", FALSE);
    WriteConsoleLine(PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine(PopupHandle, n++, NULL, FALSE );

    while (TRUE) {
        if (WaitForSingleObject(InputHandle, DelayTimeMsec) == STATUS_WAIT_0 &&
            ReadConsoleInput(InputHandle, &InputRecord, 1, &NumberOfInputRecords) &&
            InputRecord.EventType == KEY_EVENT &&
            InputRecord.Event.KeyEvent.bKeyDown &&
            InputRecord.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE
           ) {
            break;
        }
    }

    SetConsoleActiveScreenBuffer(OutputHandle);
    CloseHandle(PopupHandle);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perfmtr\perfmtrp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    perfmtrp.h

Abstract:

    This module contains NT/Win32 Perfmtr private data and types

Author:

    Mark Lucovsky (markl) 28-Mar-1991

Revision History:

--*/

#ifndef _PERFMTRP_
#define _PERFMTRP_

#define DOT_BUFF_LEN 10
#define DOT_CHAR '*'

char DotBuff[DOT_BUFF_LEN+2];

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <srvfsctl.h>

#ifndef PROTECTED_POOL
#define PROTECTED_POOL 0x80000000
#endif //#ifndef PROTECTED_POOL

#endif // _PERFMTRP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perfmtr\pmon.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    pmon.c

Abstract:

    This module contains the NT/Win32 Process Monitor

Author:

    Lou Perazzoli (loup) 1-Jan-1993

Revision History:

--*/

#include "perfmtrp.h"
#include <search.h>
#include <malloc.h>
#include <limits.h>
#include <stdlib.h>

#define BUFFER_SIZE 64*1024
#define MAX_BUFFER_SIZE 10*1024*1024

ULONG CurrentBufferSize;
PUCHAR PreviousBuffer;
PUCHAR CurrentBuffer;
PUCHAR TempBuffer;


#define CPU_USAGE 0
#define QUOTAS 1

USHORT *NoNameFound = L"Unknown";
USHORT *IdleProcess = L"Idle Process";

UCHAR *StateTable[] = {
    "Initialized",
    "Ready",
    "Running",
    "Standby",
    "Terminated",
    "Wait:",
    "Transition",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown"
};

BOOLEAN Interactive;
ULONG NumberOfInputRecords;
//INPUT_RECORD InputRecord;
HANDLE InputHandle;
HANDLE OriginalOutputHandle;
HANDLE OutputHandle;
DWORD OriginalInputMode;
WORD NormalAttribute;
WORD HighlightAttribute;
ULONG NumberOfCols;
ULONG NumberOfRows;
ULONG NumberOfDetailLines;
ULONG FirstDetailLine;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;

UCHAR *WaitTable[] = {
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "EventPairHigh",
    "EventPairLow",
    "LpcReceive",
    "LpcReply",
    "Spare1",
    "Spare2",
    "Spare3",
    "Spare4",
    "Spare5",
    "Spare6",
    "Spare7",
    "Spare8",
    "Spare9",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *Empty = " ";


PSYSTEM_PROCESS_INFORMATION
FindMatchedProcess (
    IN PSYSTEM_PROCESS_INFORMATION ProcessToMatch,
    IN PUCHAR SystemInfoBuffer,
    IN PULONG Hint
    );

PSYSTEM_THREAD_INFORMATION
FindMatchedThread (
    IN PSYSTEM_THREAD_INFORMATION ThreadToMatch,
    IN PSYSTEM_PROCESS_INFORMATION MatchedProcess
    );

typedef struct _TOPCPU {
    LARGE_INTEGER TotalTime;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_PROCESS_INFORMATION MatchedProcess;
    ULONG Value;
    LONG PageFaultDiff;
    SIZE_T WorkingSetDiff;
} TOPCPU, *PTOPCPU;

// TOPCPU TopCpu[1000];
// Required for Terminal Services
PTOPCPU TopCpu;
ULONG TopCpuSize;
#define TOPCPU_BUFFER_SIZE (((300*sizeof(TOPCPU))/4096+1)*4096)
#define TOPCPU_MAX_BUFFER_SIZE (50*TOPCPU_BUFFER_SIZE)


BOOL
WriteConsoleLine(
    HANDLE OutputHandle,
    WORD LineNumber,
    LPSTR Text,
    BOOL Highlight
    )
{
    COORD WriteCoord;
    DWORD NumberWritten;
    DWORD TextLength;

    WriteCoord.X = 0;
    WriteCoord.Y = LineNumber;
    if (!FillConsoleOutputCharacter( OutputHandle,
                                     ' ',
                                     NumberOfCols,
                                     WriteCoord,
                                     &NumberWritten
                                   )
       ) {
        return FALSE;
        }

    if (Text == NULL || (TextLength = strlen( Text )) == 0) {
        return TRUE;
        }
    else {
        return WriteConsoleOutputCharacter( OutputHandle,
                                            Text,
                                            TextLength,
                                            WriteCoord,
                                            &NumberWritten
                                          );
        }
}

NTSTATUS
GetProcessInfo (
    IN PUCHAR p
    )

{
    NTSTATUS Status;

retry01:

    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                p,
                CurrentBufferSize,
                NULL
                );

    if (Status == STATUS_INFO_LENGTH_MISMATCH) {

        //
        // Increase buffer size.
        //

        CurrentBufferSize += 8192;

        TempBuffer = VirtualAlloc (CurrentBuffer,
                                   CurrentBufferSize,
                                   MEM_COMMIT,
                                   PAGE_READWRITE);
        if (TempBuffer == NULL) {
            printf("Memory commit failed\n");
            ExitProcess(0);
        }
        TempBuffer = VirtualAlloc (PreviousBuffer,
                                   CurrentBufferSize,
                                   MEM_COMMIT,
                                   PAGE_READWRITE);
        if (TempBuffer == NULL) {
            printf("Memory commit failed\n");
            ExitProcess(0);
        }
        goto retry01;
    }
    return Status;
}

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{

    NTSTATUS Status;
    int i;
    ULONG DelayTimeMsec;
    ULONG DelayTimeTicks;
    ULONG LastCount;
    COORD cp;
    BOOLEAN Active;
    PSYSTEM_THREAD_INFORMATION Thread;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_FILECACHE_INFORMATION FileCache;
    SYSTEM_FILECACHE_INFORMATION PrevFileCache;

    CHAR OutputBuffer[ 512 ];
    UCHAR LastKey;
    LONG ScrollDelta;
    WORD DisplayLine, LastDetailRow;
    BOOLEAN DoQuit = FALSE;

    ULONG SkipLine;
    ULONG Hint;
    ULONG Offset1;
    SIZE_T SumCommit;
    int num;
    int lastnum;
    PSYSTEM_PROCESS_INFORMATION CurProcessInfo;
    PSYSTEM_PROCESS_INFORMATION MatchedProcess;
    LARGE_INTEGER LARGE_ZERO={0,0};
    LARGE_INTEGER Ktime;
    LARGE_INTEGER Utime;
    LARGE_INTEGER TotalTime;
    TIME_FIELDS TimeOut;
    PTOPCPU PTopCpu;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    ULONG DisplayType = CPU_USAGE;
    INPUT_RECORD InputRecord;
    DWORD NumRead;
    ULONG Cpu;
    ULONG NoScreenChanges = FALSE;

    OutputBuffer[sizeof(OutputBuffer) - 1] = 0;
    if ( GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS) {
        if (SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS) == 0) {
            //
            // Not much we can do
            //
            printf("Cannot elevate process priority\n");
            return 0;

            }
        }

    InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    OriginalOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
    Interactive = TRUE;
    if (Interactive) {
        if (InputHandle == NULL ||
            OriginalOutputHandle == NULL ||
            !GetConsoleMode( InputHandle, &OriginalInputMode )
           ) {
            Interactive = FALSE;
        } else {
            OutputHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                                      FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                      NULL,
                                                      CONSOLE_TEXTMODE_BUFFER,
                                                      NULL
                                                    );
            if (OutputHandle == NULL ||
                !GetConsoleScreenBufferInfo( OriginalOutputHandle, &OriginalConsoleInfo ) ||
                !SetConsoleScreenBufferSize( OutputHandle, OriginalConsoleInfo.dwSize ) ||
                !SetConsoleActiveScreenBuffer( OutputHandle ) ||
                !SetConsoleMode( InputHandle, 0 )
               ) {
                if (OutputHandle != NULL) {
                    CloseHandle( OutputHandle );
                    OutputHandle = NULL;
                }

                Interactive = FALSE;
            } else {
                NormalAttribute = 0x1F;
                HighlightAttribute = 0x71;
                NumberOfCols = OriginalConsoleInfo.dwSize.X;
                NumberOfRows = OriginalConsoleInfo.dwSize.Y;
                NumberOfDetailLines = NumberOfRows - 7;
            }
        }
    }

    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );

    DelayTimeMsec = 10;
    DelayTimeTicks = DelayTimeMsec * 10000;

    PreviousBuffer = VirtualAlloc (NULL,
                                   MAX_BUFFER_SIZE,
                                   MEM_RESERVE,
                                   PAGE_READWRITE);
    if (PreviousBuffer == NULL) {
        printf("Memory allocation failed\n");
        return 0;
    }

    TempBuffer = VirtualAlloc (PreviousBuffer,
                               BUFFER_SIZE,
                               MEM_COMMIT,
                               PAGE_READWRITE);

    if (TempBuffer == NULL) {
        printf("Memory commit failed\n");
        return 0;
    }

    CurrentBuffer = VirtualAlloc (NULL,
                                  MAX_BUFFER_SIZE,
                                  MEM_RESERVE,
                                  PAGE_READWRITE);
    if (CurrentBuffer == NULL) {
        printf("Memory allocation failed\n");
        return 0;
    }

    TempBuffer = VirtualAlloc (CurrentBuffer,
                               BUFFER_SIZE,
                               MEM_COMMIT,
                               PAGE_READWRITE);
    if (TempBuffer == NULL) {
        printf("Memory commit failed\n");
        return 0;
    }

	// TS 

	TopCpu = VirtualAlloc (NULL,
                           TOPCPU_MAX_BUFFER_SIZE,
                           MEM_RESERVE,
                           PAGE_READWRITE);
	if(TopCpu == NULL)
	{
		printf("Memory allocation failed\n");
		
		return 0;
	}
	
	TempBuffer = VirtualAlloc( TopCpu,
                               TOPCPU_BUFFER_SIZE,
                               MEM_COMMIT,
                               PAGE_READWRITE);
	
	if( TempBuffer == NULL )
	{
		printf("Memory commit failed\n");
		return 0;
	}
 
    num = 0;

	TopCpuSize = TOPCPU_BUFFER_SIZE;
    
	CurrentBufferSize = BUFFER_SIZE;

    TempBuffer = NULL;

	Status = GetProcessInfo (PreviousBuffer);

	if( !NT_SUCCESS( Status ) )
	{
        printf("Get process information failed %lx\n", Status);
        
		return (0);
    }

    DelayTimeMsec = 5000;
    DelayTimeTicks = DelayTimeMsec * 10000;

    Status = GetProcessInfo (CurrentBuffer);

	if( !NT_SUCCESS( Status ) )
	{
		printf("Get process information failed %lx\n", Status);
		
		return (0);
		
	}

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );
    LastCount = PerfInfo.PageFaultCount;

    if ( !NT_SUCCESS(Status) ) {
        printf("Query perf Failed %lx\n",Status);
        return 0;
    }

    Status = NtQuerySystemInformation(
                SystemFileCacheInformation,
                &FileCache,
                sizeof(FileCache),
                NULL
                );
    PrevFileCache = FileCache;

    if ( !NT_SUCCESS(Status) ) {
        printf("Query file cache Failed %lx\n",Status);
        return 0;
    }

    Active = TRUE;

    while(TRUE) {
		
		Status = GetProcessInfo (CurrentBuffer);

		if( !NT_SUCCESS( Status ) )
		{
			printf("Get process information failed %lx\n", Status);
		
			return (0);
		}

        Status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &PerfInfo,
                    sizeof(PerfInfo),
                    NULL
                    );

        if ( !NT_SUCCESS(Status) ) {
            printf("Query perf Failed %lx\n",Status);
            return 0;
        }
        Status = NtQuerySystemInformation(
                    SystemFileCacheInformation,
                    &FileCache,
                    sizeof(FileCache),
                    NULL
                    );

        if ( !NT_SUCCESS(Status) ) {
            printf("Query file cache Failed %lx\n",Status);
            return 0;
        }

        //
        // Calculate top CPU users and display information.
        //

        //
        // Cross check previous process/thread info against current
        // process/thread info.
        //

        Offset1 = 0;
        lastnum = num;
        num = 0;
        Hint = 0;
        TotalTime = LARGE_ZERO;
        SumCommit = 0;
        while (TRUE) {
            CurProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&CurrentBuffer[Offset1];

            //
            // Find the corresponding process in the previous array.
            //

            MatchedProcess = FindMatchedProcess (CurProcessInfo,
                                                 PreviousBuffer,
                                                 &Hint);

			if( num >= (int)( TopCpuSize / sizeof( TOPCPU ) ) )
			{
                TopCpuSize += 4096;

                if( VirtualAlloc( TopCpu, TopCpuSize, MEM_COMMIT, PAGE_READWRITE ) == NULL )
				{
                    printf("Memory commit failed\n");
                    return 0;
                }
            }

            if (MatchedProcess == NULL) {
                TopCpu[num].TotalTime = CurProcessInfo->KernelTime;
                TopCpu[num].TotalTime.QuadPart =
                                            TopCpu[num].TotalTime.QuadPart +
                                            CurProcessInfo->UserTime.QuadPart;
                TotalTime.QuadPart = TotalTime.QuadPart +
                                                TopCpu[num].TotalTime.QuadPart;
                TopCpu[num].ProcessInfo = CurProcessInfo;
                TopCpu[num].MatchedProcess = NULL;
                num += 1;
            } else {
                Ktime.QuadPart = CurProcessInfo->KernelTime.QuadPart -
                                                  MatchedProcess->KernelTime.QuadPart;
                Utime.QuadPart = CurProcessInfo->UserTime.QuadPart -
                                                  MatchedProcess->UserTime.QuadPart;

                TopCpu[num].TotalTime.QuadPart =
                                            Ktime.QuadPart +
                                            Utime.QuadPart;
                TotalTime.QuadPart = TotalTime.QuadPart +
                                                TopCpu[num].TotalTime.QuadPart;
                TopCpu[num].ProcessInfo = CurProcessInfo;
                TopCpu[num].MatchedProcess = MatchedProcess;
                TopCpu[num].PageFaultDiff =
                    CurProcessInfo->PageFaultCount - MatchedProcess->PageFaultCount;
                                            ;
                TopCpu[num].WorkingSetDiff =
                    CurProcessInfo->WorkingSetSize - MatchedProcess->WorkingSetSize;
                num += 1;
            }
            SumCommit += CurProcessInfo->PrivatePageCount / 1024;

            if (CurProcessInfo->NextEntryOffset == 0) {

                DisplayLine = 0;

                _snprintf (OutputBuffer, sizeof(OutputBuffer) - 1,
                     " Memory:%8ldK Avail:%7ldK  PageFlts:%6ld InRam Kernel:%5ldK P:%5ldK",
                                          BasicInfo.NumberOfPhysicalPages*(BasicInfo.PageSize/1024),
                                          PerfInfo.AvailablePages*(BasicInfo.PageSize/1024),
                                          PerfInfo.PageFaultCount - LastCount,
                                          (PerfInfo.ResidentSystemCodePage + PerfInfo.ResidentSystemDriverPage)*(BasicInfo.PageSize/1024),
                                          (PerfInfo.ResidentPagedPoolPage)*(BasicInfo.PageSize/1024)
                                          );
                LastCount = PerfInfo.PageFaultCount;
                WriteConsoleLine( OutputHandle,
                                  DisplayLine++,
                                  OutputBuffer,
                                  FALSE
                                );
                _snprintf(OutputBuffer, sizeof(OutputBuffer) - 1,
                     " Commit:%7ldK/%7ldK Limit:%7ldK Peak:%7ldK  Pool N:%5ldK P:%5ldK",
                                          PerfInfo.CommittedPages*(BasicInfo.PageSize/1024),
                                          SumCommit,
                                          PerfInfo.CommitLimit*(BasicInfo.PageSize/1024),
                                          PerfInfo.PeakCommitment*(BasicInfo.PageSize/1024),
                                          PerfInfo.NonPagedPoolPages*(BasicInfo.PageSize/1024),
                                          PerfInfo.PagedPoolPages*(BasicInfo.PageSize/1024)
                                          );
                WriteConsoleLine( OutputHandle,
                                  DisplayLine++,
                                  OutputBuffer,
                                  FALSE
                                );

                DisplayLine += 1;

                if (NoScreenChanges) {
                    DisplayLine += 2;
                } else {
                    WriteConsoleLine( OutputHandle,
                                      DisplayLine++,
                        "                Mem  Mem   Page   Flts Commit  Usage   Pri  Hnd Thd  Image  ",
                                      FALSE
                                    );

                    WriteConsoleLine( OutputHandle,
                                      DisplayLine++,
                        "CPU  CpuTime  Usage Diff   Faults Diff Charge NonP Page     Cnt Cnt  Name      ",
                                      FALSE
                                    );
                }

                DisplayLine += 1;

                _snprintf(OutputBuffer, sizeof(OutputBuffer) - 1,
                    "             %6ld%5ld%9ld %4ld                             File Cache ",
                       FileCache.CurrentSize/1024,
                       ((LONG)FileCache.CurrentSize - (LONG)PrevFileCache.CurrentSize)/1024,
                       FileCache.PageFaultCount,
                       (LONG)FileCache.PageFaultCount - (LONG)PrevFileCache.PageFaultCount
                     );
                WriteConsoleLine( OutputHandle,
                                  DisplayLine++,
                                  OutputBuffer,
                                  FALSE
                                );
                                PrevFileCache = FileCache;

                LastDetailRow = (WORD)NumberOfRows;
                for (i = FirstDetailLine; i < num; i++) {
                    if (DisplayLine >= LastDetailRow) {
                        break;
                    }

                    PTopCpu = &TopCpu[i];
                    Ktime.QuadPart =
                                PTopCpu->ProcessInfo->KernelTime.QuadPart +
                                PTopCpu->ProcessInfo->UserTime.QuadPart;
                    RtlTimeToElapsedTimeFields ( &Ktime, &TimeOut);
                    TimeOut.Hour += TimeOut.Day*24;
                    if (PTopCpu->ProcessInfo->ImageName.Buffer == NULL) {
                        if (PTopCpu->ProcessInfo->UniqueProcessId == (HANDLE)0) {
                            PTopCpu->ProcessInfo->ImageName.Buffer = (PWSTR)IdleProcess;
                        } else {
                            PTopCpu->ProcessInfo->ImageName.Buffer = (PWSTR)NoNameFound;
                        }
                    } else {
                        if (PTopCpu->ProcessInfo->ImageName.Length > 24) {
                            PTopCpu->ProcessInfo->ImageName.Buffer +=
                              ((PTopCpu->ProcessInfo->ImageName.Length) - 24);
                        }
                    }

                    Cpu = PTopCpu->TotalTime.LowPart / ((TotalTime.LowPart / 100) ? (TotalTime.LowPart / 100) : 1);
                    if ( Cpu == 100 ) {
                        Cpu = 99;
                    }

                    //
                    //  See if nothing has changed.
                    //

                    SkipLine = FALSE;
                    if  ((PTopCpu->MatchedProcess != NULL) &&
                        (Cpu == 0) &&
                        (PTopCpu->WorkingSetDiff == 0) &&
                        (PTopCpu->PageFaultDiff == 0) &&
                        (PTopCpu->MatchedProcess->NumberOfThreads ==
                         PTopCpu->ProcessInfo->NumberOfThreads) &&
                        (PTopCpu->MatchedProcess->HandleCount ==
                         PTopCpu->ProcessInfo->HandleCount) &&
                        (PTopCpu->MatchedProcess->PrivatePageCount ==
                         PTopCpu->ProcessInfo->PrivatePageCount)) {

                        PTopCpu->ProcessInfo->PeakPagefileUsage = 0xffffffff;
                        PTopCpu->ProcessInfo->PeakWorkingSetSize = DisplayLine;

                        if ((PTopCpu->MatchedProcess->PeakPagefileUsage == 0xffffffff) &&
                           (PTopCpu->MatchedProcess->PeakWorkingSetSize == DisplayLine) &&

                           (NoScreenChanges)) {
                            SkipLine = TRUE;
                        }
                    }

                    if (SkipLine) {

                        //
                        // The line on the screen has not changed, just skip
                        // writing this one.
                        //

                        DisplayLine += 1;
                    } else {

                        _snprintf(OutputBuffer, sizeof(OutputBuffer) - 1,
                            "%2ld%4ld:%02ld:%02ld%7ld%5ld%9ld%5ld%7ld%5ld%5ld %2ld%5ld%3ld %ws",
                            Cpu,
                            TimeOut.Hour,
                            TimeOut.Minute,
                            TimeOut.Second,
                            PTopCpu->ProcessInfo->WorkingSetSize / 1024,
                            (ULONG)(PTopCpu->WorkingSetDiff / 1024),
                            PTopCpu->ProcessInfo->PageFaultCount,
                            PTopCpu->PageFaultDiff,
                            PTopCpu->ProcessInfo->PrivatePageCount / 1024,
                            PTopCpu->ProcessInfo->QuotaNonPagedPoolUsage / 1024,
                            PTopCpu->ProcessInfo->QuotaPagedPoolUsage / 1024,
                            PTopCpu->ProcessInfo->BasePriority,
                            PTopCpu->ProcessInfo->HandleCount,
                            PTopCpu->ProcessInfo->NumberOfThreads,
                            PTopCpu->ProcessInfo->ImageName.Buffer
                            );

                        WriteConsoleLine( OutputHandle,
                                      DisplayLine++,
                                      OutputBuffer,
                                      FALSE
                                    );

                    }
                    Thread = (PSYSTEM_THREAD_INFORMATION)(TopCpu[i].ProcessInfo + 1);
                }
                while (lastnum > num) {
                    WriteConsoleLine( OutputHandle,
                                      DisplayLine++,
                                      " ",
                                      FALSE);
                    lastnum -= 1;
                }
            }

            if (CurProcessInfo->NextEntryOffset == 0) {
                break;
            }
            Offset1 += CurProcessInfo->NextEntryOffset;

        } //end while

        TempBuffer = PreviousBuffer;
        PreviousBuffer = CurrentBuffer;
        CurrentBuffer = TempBuffer;

        NoScreenChanges = TRUE;
        while (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0) {

            //
            // Check for input record
            //

            if (ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
                InputRecord.EventType == KEY_EVENT &&
                InputRecord.Event.KeyEvent.bKeyDown
               ) {
                LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;
                if (LastKey < ' ') {
                    ScrollDelta = 0;
                    if (LastKey == 'C'-'A'+1) {
                        DoQuit = TRUE;
                    } else switch (InputRecord.Event.KeyEvent.wVirtualKeyCode) {
                        case VK_ESCAPE:
                            DoQuit = TRUE;
                            break;

                        case VK_PRIOR:
                            ScrollDelta = -(LONG)(InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines);
                            break;

                        case VK_NEXT:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines;
                            break;

                        case VK_UP:
                            ScrollDelta = -InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_DOWN:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_HOME:
                            FirstDetailLine = 0;
                            break;

                        case VK_END:

                            if ((ULONG)num > NumberOfDetailLines) {
                                FirstDetailLine = num - NumberOfDetailLines;
                                NoScreenChanges = FALSE;
                            }
                            break;
                    }

                    if (ScrollDelta != 0) {
                        if (ScrollDelta < 0) {
                            if (FirstDetailLine <= (ULONG)-ScrollDelta) {
                                FirstDetailLine = 0;
                                NoScreenChanges = FALSE;
                            } else {
                                FirstDetailLine += ScrollDelta;
                                NoScreenChanges = FALSE;
                            }
                        } else {
                            FirstDetailLine += ScrollDelta;
                            NoScreenChanges = FALSE;
                            if (FirstDetailLine >= (num - NumberOfDetailLines)) {
                                FirstDetailLine = num - NumberOfDetailLines;
                            }
                        }
                    }
                } else {

                    switch (toupper( LastKey )) {
                        case 'C':
                        case 'c':
                            DisplayType = CPU_USAGE;
                            break;

                        case 'P':
                        case 'p':
                            DisplayType = QUOTAS;
                            break;


                        case 'q':
                        case 'Q':
                            DoQuit = TRUE;
                            break;

                        default:
                            break;
                    }
                }
                break;
            }
        }
        if (DoQuit) {
            if (Interactive) {
                SetConsoleActiveScreenBuffer( OriginalOutputHandle );
                SetConsoleMode( InputHandle, OriginalInputMode );
                CloseHandle( OutputHandle );
            }
            return 0;
        }
    }
    return 0;
}
PSYSTEM_PROCESS_INFORMATION
FindMatchedProcess (
    IN PSYSTEM_PROCESS_INFORMATION ProcessToMatch,
    IN PUCHAR SystemInfoBuffer,
    IN OUT PULONG Hint
    )

/*++

Routine Description:

    This procedure finds the process which corresponds to the ProcessToMatch.
    It returns the address of the matching Process, or NULL if no
    matching process was found.

Arguments:

    ProcessToMatch - Supplies a pointer to the target thread to match.

    SystemInfoBuffer - Supples a pointer to the system information
                     buffer in which to locate the process.

    Hint - Supplies and returns a hint for optimizing the searches.

Return Value:

    Address of the corresponding Process or NULL.

--*/

{
    PSYSTEM_PROCESS_INFORMATION Process;
    ULONG Offset2;

    Offset2 = *Hint;

    while (TRUE) {
        Process = (PSYSTEM_PROCESS_INFORMATION)&SystemInfoBuffer[Offset2];
        if ((Process->UniqueProcessId ==
                ProcessToMatch->UniqueProcessId) &&
            (Process->CreateTime.QuadPart ==
                                  ProcessToMatch->CreateTime.QuadPart)) {
            *Hint = Offset2 + Process->NextEntryOffset;
            return(Process);
        }
        Offset2 += Process->NextEntryOffset;
        if (Offset2 == *Hint) {
            *Hint = 0;
            return(NULL);
        }
        if (Process->NextEntryOffset == 0) {
            if (*Hint == 0) {
                return(NULL);
            }
            Offset2 = 0;
        }
    }
}

PSYSTEM_THREAD_INFORMATION
FindMatchedThread (
    IN PSYSTEM_THREAD_INFORMATION ThreadToMatch,
    IN PSYSTEM_PROCESS_INFORMATION MatchedProcess
    )

/*++

Routine Description:

    This procedure finds thread which corresponds to the ThreadToMatch.
    It returns the address of the matching thread, or NULL if no
    matching thread was found.

Arguments:

    ThreadToMatch - Supplies a pointer to the target thread to match.

    MatchedProcess - Supples a pointer to the process which contains
                     the target thread.  The thread information
                     must follow this process, i.e., this block was
                     obtain from a NtQuerySystemInformation specifying
                     PROCESS_INFORMATION.

Return Value:

    Address of the corresponding thread from MatchedProcess or NULL.

--*/

{
    PSYSTEM_THREAD_INFORMATION Thread;
    ULONG i;

    Thread = (PSYSTEM_THREAD_INFORMATION)(MatchedProcess + 1);
    for (i = 0; i < MatchedProcess->NumberOfThreads; i++) {
        if ((Thread->ClientId.UniqueThread ==
                ThreadToMatch->ClientId.UniqueThread) &&
            (Thread->CreateTime.QuadPart ==
                                  ThreadToMatch->CreateTime.QuadPart)) {

            return(Thread);
        }
        Thread += 1;
    }
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perfmtr\msdis.h ===
/***********************************************************************
* Microsoft Disassembler
*
* Microsoft Confidential.  Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*   This file is a copy of the master version owned by richards.
*   Contact richards for any changes.
*
***********************************************************************/

#ifndef MSDIS_H
#define MSDIS_H

#pragma pack(push, 8)

#include <stddef.h>		       // For size_t

#include <strstream>		       // For std::ostream


	// ------------------------------------------------------------
	// Start of internal vs external definitions
	// ------------------------------------------------------------

#if	defined(DISDLL) 	       // Building the MSDIS DLL

#undef	DISDLL
#define DISDLL		__declspec(dllexport)

#else				       // Building an MSDIS client

#define DISDLL		__declspec(dllimport)

#endif

	// ------------------------------------------------------------
	// End of internal vs external definitions
	// ------------------------------------------------------------


class __declspec(novtable) DIS
{
public:
   enum DIST
   {
      distAM33, 			  // Matsushita AM33
      distArm,				  // ARM
      distCee,				  // MSIL
      distIa64, 			  // IA-64
      distM32R, 			  // Mitsubishi M32R
      distMips, 			  // MIPS R-Series
      distMips16,			  // MIPS16
      distPowerPc,			  // Motorola PowerPC
      distSh3,				  // Hitachi SuperH 3
      distSHcompact,			  // Hitachi SuperH (Compact mode)
      distSHmedia,			  // Hitachi SuperH (Media mode)
      distThumb,			  // Thumb
      distTriCore,			  // Infineon TriCore
      distX86,				  // x86 (32 bit mode)
      distX8616,			  // x86 (16 bit mode)
      distX8664,			  // x86 (64 bit mode)
      distArmConcan,			  // ARM Concan coprocessor
      distArmXmac,			  // ARM XMAC coprocessor
   };


   // A branch is defined as a transfer of control that doesn't
   // record the location of following block so that control may
   // return.  A call does record the location of the following
   // block so that a subsequent indirect branch may return there.
   // The first number in the comments below is the number of
   // successors determinable by static analysis.  There is a dependency
   // in SEC::FDoDisassembly() that trmtBra and above represent branch
   // or call types that are not valid in a delay slot of any of the
   // Def variants of termination type.

   enum TRMT			       // Architecture independent termination type
   {
      trmtUnknown,		       //   Block hasn't been analyzed
      trmtFallThrough,		       // 1 Fall into following block
      trmtBra,			       // 1 Branch, Unconditional, Direct
      trmtBraCase,		       // ? Conditional, Direct, Multiple targets
      trmtBraCc,		       // 2 Branch, Conditional, Direct
      trmtBraCcDef,		       // 2 Branch, Conditional, Direct, Deferred
      trmtBraCcInd,		       // 1 Branch, Conditional, Indirect
      trmtBraCcIndDef,		       // 1 Branch, Conditional, Indirect, Deferred
      trmtBraDef,		       // 1 Branch, Unconditional, Direct, Deferred
      trmtBraInd,		       // 0 Branch, Unconditional, Indirect
      trmtBraIndDef,		       // 0 Branch, Unconditional, Indirect, Deferred
      trmtCall, 		       // 2 Call, Unconditional, Direct
      trmtCallCc,		       // 2 Call, Conditional, Direct
      trmtCallCcDef,		       // 2 Call, Conditional, Direct, Deferred
      trmtCallCcInd,		       // 1 Call, Conditional, Indirect
      trmtCallDef,		       // 2 Call, Unconditional, Direct, Deferred
      trmtCallInd,		       // 1 Call, Unconditional, Indirect
      trmtCallIndDef,		       // 1 Call, Unconditional, Indirect, Deferred
      trmtTrap, 		       // 1 Trap, Unconditional
      trmtTrapCc,		       // 1 Trap, Conditional
   };


   enum TRMTA			       // Architecture dependent termination type
   {
      trmtaUnknown = trmtUnknown,
      trmtaFallThrough = trmtFallThrough
   };


   typedef unsigned char      BYTE;
   typedef unsigned short     WORD;
   typedef unsigned long      DWORD;
   typedef unsigned __int64   DWORDLONG;

   typedef DWORDLONG ADDR;

   enum { addrNil = 0 };


   // MEMREFT describes the types of memory references that an instruction
   // can make.  If the memory reference can't be described by the defined
   // values, memreftOther is returned.

   enum MEMREFT
   {
      memreftNone,		       // Does not reference memory
      memreftRead,		       // Reads from single address
      memreftWrite,		       // Writes to single address
      memreftRdWr,		       // Read/Modify/Write of single address
      memreftOther,		       // None of the above
   };


   enum REGA			       // Architecture dependent register number
   {
      regaNil = -1,
   };

   enum OPA			       // Architecture dependent operation type
   {
      opaInvalid = -1,
   };

   enum OPCLS			       // Operand type
   {
      opclsNone = 0,
      opclsRegister,
      opclsImmediate,
      opclsMemory,
   };


   // OPERAND and INSTRUCTION are the structures used in
   // the interface between the disassembler and the routines that convert
   // native platform instructions into Vulcan IR.

   struct OPERAND
   {
      OPCLS       opcls;         // operand type
      REGA        rega1;         // arch dependent enum -- 1st register
      REGA        rega2;         // arch dependent enum -- 2nd register
      REGA        rega3;         // arch dependent enum -- 3rd register
      DWORDLONG   dwl;           // const, addr, etc. based on OPCLS
      size_t      cb;            // only valid for opclsMemory - some architectures add to this e.g. x86
      bool        fImmediate;    // true if dwl is valid
      WORD        wScale;        // any scaling factor to be applied to rega1
   };

   struct INSTRUCTION
   {
      OPA      opa;           // arch dependent enum -- opcode
      DWORD    dwModifiers;   // arch dependent bits modifying opa
      size_t   coperand;      // count of operands
   };


   // PFNCCHADDR is the type of the callback function that can be set
   // via PfncchaddrSet().

   typedef  size_t (__stdcall *PFNCCHADDR)(const DIS *, ADDR, char *, size_t, DWORDLONG *);

   // PFNCCHCONST is the type of the callback function that can be set
   // via PfncchconstSet().

   typedef  size_t (__stdcall *PFNCCHCONST)(const DIS *, DWORD, char *, size_t);

   // PFNCCHFIXUP is the type of the callback function that can be set
   // via PfncchfixupSet().

   typedef  size_t (__stdcall *PFNCCHFIXUP)(const DIS *, ADDR, size_t, char *, size_t, DWORDLONG *);

   // PFNCCHREGREL is the type of the callback function that can be set
   // via PfncchregrelSet().

   typedef  size_t (__stdcall *PFNCCHREGREL)(const DIS *, REGA, DWORD, char *, size_t, DWORD *);

   // PFNCCHREG is the type of the callback function that can be set
   // via PfncchregSet().

   typedef  size_t (__stdcall *PFNCCHREG)(const DIS *, REGA, char *, size_t);

   // PFNDWGETREG is the type of the callback function that can be set
   // via Pfndwgetreg().

   typedef  DWORDLONG (__stdcall *PFNDWGETREG)(const DIS *, REGA);


   // Methods

   ///////////////////////////////////////////////////////////////////////////
   //  In these comments, please note that "current instruction" is defined
   //  by the results of the most recent call to CbDisassemble() and of any
   //  intervening call(s) to FSelectInstruction().
   ///////////////////////////////////////////////////////////////////////////


   virtual  ~DIS();

   // UNDONE: Comment

   static   DISDLL DIS * __stdcall PdisNew(DIST);

   // Addr() returns the address of the current instruction.  This
   // is the same value as the ADDR parameter passed to CbDisassemble.
   // The return value of this method is not valid if the last call to
   // CbDisassemble returned zero.

	    DISDLL ADDR Addr() const;

   // UNDONE: Comment

   virtual  ADDR AddrAddress(size_t) const;

   // UNDONE: Comment

   virtual  ADDR AddrInstruction() const;

   // AddrJumpTable() returns the address of a potential jump table used by
   // the current instruction.	The return value of this method is not valid
   // if the last call to CbDisassemble returned zero or if the termination
   // type is an indirect branch variant.  If the last instruction does not
   // identify a potential jump table, this method returns addrNil.

   virtual  ADDR AddrJumpTable() const;

   // UNDONE: Comment

   virtual  ADDR AddrOperand(size_t) const;

   // AddrTarget() returns the address of the branch target of the specified
   // operand (first operand by default) of the current instruction.
   // The return value of this method is not valid if the last call to
   // CbDisassemble returned zero or if the termination type is not
   // one of the direct branch or call variants.

   virtual  ADDR AddrTarget(size_t = 1) const = 0;

   // Cb() returns the size in bytes of the current instruction,
   // or the size of a 'bundle' on those architectures that group multiple
   // instructions together.
   // The return value of this method is not valid if the last call to
   // CbDisassemble returned zero.

   virtual  size_t Cb() const = 0;

   // CbAssemble() will assemble a single instruction into the provided
   // buffer assuming the provided address.  On bundled architectures,
   // this function is not yet implemented.  If the resulting buffer contains
   // a valid instruction, CbAssemble will return the number of bytes in
   // the instruction, otherwise it returns zero.

   virtual  size_t CbAssemble(ADDR, void *, size_t);

   // CbDisassemble() will disassemble a single instruction from the provided
   // buffer assuming the provided address.  On those architectures which
   // 'bundle' multiple instructions together, CbDisassemble() will process
   // the entire 'bundle' and the caller is responsible for calling both
   // Cinstruction() and FSelectInstruction() as appropriate.	If the buffer
   // contains a valid instruction, CbDisassemble will return the number of
   // bytes in the instruction (on bundled architectures, the number of bytes
   // in the bundle *if* the buffer contained a valid bundle), otherwise it
   // returns zero.

   virtual  size_t CbDisassemble(ADDR, const void *, size_t) = 0;

   // CbGenerateLoadAddress generates one or more instructions to load
   // the address of the memory operand from the current instruction into
   // a register.  UNDONE: This register is currently hard coded for each
   // architecture.  When pibAddress is non-NULL, this method will store
   // the offset of a possible address immediate in this location.  The
   // value stored is only valid if the AddrAddress method returns a
   // value other than addrNil.  It is not valid to call this method after
   // a call to CbDisassemble that returned 0 or when the return value of
   // Memreft is memreftNone.  It is architecture dependent whether this
   // method will succeed when the return value of Memreft is memreftOther.
   //
   // UNDONE: Add reg parameter.

   virtual size_t CbGenerateLoadAddress(size_t, void *, size_t, size_t * = NULL) const;

   // CbJumpEntry() returns the size of the individual entries in the jump
   // table identified by AddrJumpTable().  The return value of this method
   // is not valid if either the return value of AddrJumpTable() is not valid
   // or AddrJumpTable() returned addrNil.

   virtual  size_t CbJumpEntry() const;

   // CbOperand() returns the size of the memory operand of the current
   // instruction.  The return value of this method is not valid if Memreft()
   // returns memreftNone or memreftOther or if the last call to CbDisassemble
   // returned zero.

   virtual  size_t CbOperand(size_t) const;

   // CchFormatAddr() formats the provided address in the style used for the
   // architecture.  The return value is the size of the formatted address
   // not including the terminating null.  If the provided buffer is not
   // large enough, this method returns 0.

	    DISDLL size_t CchFormatAddr(ADDR, char *, size_t) const;

   // CchFormatBytes() formats the data bytes of the current instruction
   // and returns the size of the formatted buffer not including the
   // terminating null.  If the provided buffer is not large enough, this
   // method returns 0.  It is not valid to call this method after a call to
   // CbDisassemble that returned zero.

   virtual  size_t CchFormatBytes(char *, size_t) const = 0;

   // CchFormatBytesMax() returns the maximum size possibly returned by
   // CchFormatBytes().

   virtual  size_t CchFormatBytesMax() const = 0;

   // CchFormatInstr() formats the current instruction and returns the
   // size of the formatted instruction not including the terminating
   // null.  If the provided buffer is not large enough, this method returns
   // 0.  It is not valid to call this method after a call to CbDisassemble
   // that returned zero.

	    DISDLL size_t CchFormatInstr(char *, size_t) const;

   // Cinstruction() tells how many machine instructions resulted from the
   // most recent call to CbDisassemble().  On most architectures this value
   // will always be one (1); when it is not, the caller is responsible for
   // using FSelectInstruction() as appropriate to access each instruction
   // in turn.

   virtual  size_t Cinstruction() const;

   // Coperand() returns the number of operands in the current instruction.

   virtual  size_t Coperand() const = 0;

   // UNDONE: Comment

   virtual  size_t CregaRead(REGA *, size_t) const;

   // UNDONE: Comment

   virtual  size_t CregaWritten(REGA *, size_t) const;

   // Dist() returns the disassembler type of this instance.

	    DISDLL DIST Dist() const;

   // FDecode converts the current machine instruction into a decoded opcode
   // and operand set.	The void * points to an array of decoded operands.
   // The size_t argument is the size of the input array.  The number of
   // actual operands is returned in the INSTRUCTION.

   virtual  bool FDecode(INSTRUCTION *, OPERAND *, size_t) const;

   // FEncode converts the INSTRUCTION and the array of decoded
   // operands into a machine instruction.

   virtual  bool FEncode(const INSTRUCTION *, const OPERAND *, size_t);

   // UNDONE: Comment

   virtual  void FormatAddr(std::ostream&, ADDR) const;

   // UNDONE: Comment

   virtual  void FormatInstr(std::ostream&) const = 0;

   // For those architectures in which calls to CbDisassemble() will generate
   // more than one resulting instruction, FSelectInstruction() determines
   // which instruction (0-based) all following calls will process.

   virtual  bool FSelectInstruction(size_t);

   // Memreft() returns the memory reference type of the specified operand of
   // the current instruction. It is not valid to call this method
   // after a call to CbDisassemble that returned zero.

   virtual  MEMREFT Memreft(size_t) const = 0;

   // PfncchaddrSet() sets the callback function for symbol lookup.  This
   // function returns the previous value of the callback function address.
   // If the address is non-zero, the callback function is called during
   // CchFormatInstr to query the symbol for the supplied address.  If there
   // is no symbol at this address, the callback should return 0.

	    DISDLL PFNCCHADDR PfncchaddrSet(PFNCCHADDR);

   // PfncchconstSet() sets the callback function for constant pool lookup.
   // This function returns the previous value of the callback function address.
   // If the address is non-zero, the callback function is called during
   // CchFormatInstr to query the string for the supplied constant index.
   // If there is no constant with this index, the callback should return 0.

	    DISDLL PFNCCHCONST PfncchconstSet(PFNCCHCONST);

   // PfncchfixupSet() sets the callback function for symbol lookup.  This
   // function returns the previous value of the callback function address.
   // If the address is non-zero, the callback function is called during
   // CchFormatInstr to query the symbol and displacement referenced by
   // operands of the current instruction.  The callback should examine the
   // contents of the memory identified by the supplied address and size and
   // return the name of any symbol targeted by a fixup on this memory and the
   // displacement from that symbol.  If there is no fixup on the specified
   // memory, the callback should return 0.

	    DISDLL PFNCCHFIXUP PfncchfixupSet(PFNCCHFIXUP);

   // UNDONE: Comment

	    DISDLL PFNCCHREGREL PfncchregrelSet(PFNCCHREGREL);

   // UNDONE: Comment

	    DISDLL PFNCCHREG PfncchregSet(PFNCCHREG);

   // UNDONE: Comment

	    DISDLL PFNDWGETREG PfndwgetregSet(PFNDWGETREG);

   // PvClient() returns the current value of the client pointer.

	    DISDLL void *PvClient() const;

   // PvClientSet() sets the value of a void pointer that the client can
   // later query with PvClient().  This funcion returns the previous value
   // of the client pointer.

	    DISDLL void *PvClientSet(void *);

   // SetAddr64() sets whether addresses are 32 bit or 64 bit.	The default
   // is 32 bit.

	    DISDLL void SetAddr64(bool);

   // Trmt() returns the architecture independent termination type of the
   // current instruction.  The return value of this method is not
   // valid if the last call to CbDisassemble returned zero.

   virtual  TRMT Trmt() const = 0;

   // Trmta() returns the architecture dependent termination type of the
   // current instruction.  The return value of this method is not
   // valid if the last call to CbDisassemble returned zero.

   virtual  TRMTA Trmta() const = 0;

   // UNDONE : These functions have been placed at the end of the vtable 
   // to maintain compatibility for the time-being.  These should be 
   // moved back into alphabetical order in the future.

   // DwModifiers() returns the architecture dependent modifier flags
   // of the current decoded instruction.  The return value of this
   // method is not valid if the last call to FDecode returned false.

   virtual  DWORD DwModifiers() const;

   // Opa() returns the architecture dependent operation type of the
   // current decoded instruction.  The return value of this method is
   // not valid if the last call to FDecode returned false.

   virtual  OPA Opa() const;
   
protected:
	    DIS(DIST);

	    void FormatHex(std::ostream&, DWORDLONG) const;
	    void FormatSignedHex(std::ostream&, DWORDLONG) const;

	    DIST m_dist;
	    bool m_fAddr64;

	    PFNCCHADDR m_pfncchaddr;
	    PFNCCHCONST m_pfncchconst;
	    PFNCCHFIXUP m_pfncchfixup;
	    PFNCCHREGREL m_pfncchregrel;
	    PFNCCHREG m_pfncchreg;
	    PFNDWGETREG m_pfndwgetreg;
	    void *m_pvClient;

	    ADDR m_addr;
};


#pragma pack(pop)

#endif	// MSDIS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perfmtr\poolmon.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    poolmon.c

Abstract:

    This module contains the NT/Win32 Pool Monitor

Author:

    Lou Perazzoli (loup) 13-Sep-1993

Revision History:

    Swetha Narayanaswamy (swethan) 25th-Mar-2002  Added functionality to provide driver description from pooltag files
                                                                                and to dynamically build a local tag file from driver binaries in the system
--*/

#include "perfmtrp.h"
#include <search.h>
#include <malloc.h>
#include <limits.h>
#include <stdlib.h>

#include <stdio.h>
#include <errno.h>
#include <io.h>
#include <stddef.h>

#if !defined (_WIN64)
extern  BOOL MakeLocalTagFile();
#endif

//
// the amount of memory to increase the size
// of the buffer for NtQuerySystemInformation at each step
//
#define BUFFER_SIZE_STEP    65536

#define CPU_USAGE 0
#define QUOTAS 1

#define TAG 0
#define ALLOC 1
#define FREE 2
#define DIFF 3
#define BYTES 4
#define EACH 5
#define LIGHT 6


#define NONPAGED 0
#define PAGED 1
#define BOTH 2

#define OUTPUTBUFFERSIZE 512

UCHAR *PoolType[] = {
    "Nonp ",
    "Paged" };

PUCHAR LargeBuffer1 = NULL;
PUCHAR LargeBuffer2 = NULL;

SIZE_T LargeBuffer1Size = 0;
SIZE_T LargeBuffer2Size = 0;

PCHAR  pchLogFile = NULL; //log file name for snapshot
PCHAR  pchLocalTagFile = NULL; //local tag file name
PCHAR  pchPoolTagFile = NULL; //pool tag file name

typedef struct _POOLMON_OUT {
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    UCHAR NullByte;
    BOOLEAN Changed;
    ULONG Type;
    SIZE_T Allocs;
    SIZE_T AllocsDiff;
    SIZE_T Frees;
    SIZE_T FreesDiff;
    SIZE_T Allocs_Frees;
    SIZE_T Used;
    SIZE_T UsedDiff;
    SIZE_T Each;
} POOLMON_OUT, *PPOOLMON_OUT;

POOLMON_OUT *OutBuffer = NULL;
SIZE_T OutBufferSize = 0;

#define TAGMAPLEN 971
// There are about 90 wild card tags in pooltag.txt
// All wild-card tag entries will have at least one starting letter
// Tags do not begin with a wild-card
#define WILDCARDTAGMAPLEN 26
#define POOLTAGFILE "pooltag.txt"
#define LOCALTAGFILE "localtag.txt"
#define DRIVERNAMELEN 64
#define INVALID_INDEX WILDCARDTAGMAPLEN+1

 // Tag file size of 1000000 allows for 10000 tag entries of 100 bytes each
 // 100 bytes for each tag entry would allow for a driver length of 64 bytes, tag size of 4 bytes and the rest for formatting
 // Note: The MAXTAGFILESIZE check really does not prevent a bad tag file from being opened, it just prevents the process
 // from stalling for too long if a file open is done on a very large file.
#define MAXTAGFILESIZE 1000000

typedef struct _TAGNODE{
    UCHAR Tag[5];
    UCHAR Driver[DRIVERNAMELEN];
    struct _TAGNODE *next;
} TAGNODE, *PTAGNODE;

PTAGNODE* TagMap = NULL;
PTAGNODE* WildCardTagMap=NULL;

BOOL BuildTagMap();
VOID FreeTagMap();
PTAGNODE LookupTag(PUCHAR tag);


ULONG DisplayType = BOTH;
ULONG SortBy = TAG;
ULONG Paren = 0;

BOOL DisplaySessionPool = FALSE;
ULONG DisplaySessionId = (ULONG)-1;
ULONG SessionBufferSize = 0;
PSYSTEM_SESSION_POOLTAG_INFORMATION SessionBuffer = NULL;

ULONG DelayTimeMsec = 5000;

BOOLEAN Interactive;
BOOLEAN IsSnap = FALSE;
BOOL fLocalTag = FALSE;
BOOL fPoolTag = FALSE;
BOOL fPrintSummaryInfo = FALSE;
ULONG NumberOfInputRecords;
INPUT_RECORD InputRecord;
HANDLE InputHandle;
HANDLE OriginalOutputHandle;
HANDLE OutputHandle;
DWORD OriginalInputMode;
WORD NormalAttribute;
WORD HighlightAttribute;
ULONG NumberOfCols;
ULONG NumberOfRows;
ULONG NumberOfDetailLines;
SIZE_T FirstDetailLine;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;
ULONG NoHighlight = 0;

BOOLEAN DisplayTotals = FALSE;
POOLMON_OUT Totals[2];

typedef struct _FILTER {
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    BOOLEAN Exclude;
} FILTER, *PFILTER;

#define MAX_FILTER 64
FILTER Filter[MAX_FILTER];
ULONG FilterCount = 0;



PCHAR UsageStrings[] = {
       "poolmon [-? | -h | -s | -n [LogFile] | -l [LocalTagFile] | -g [PoolTagFile] |",
       "    [-i'tag']*[-x'tag']*[-e][-t | -a | -u |",
       "    -b | -f | -d | -m][-l][-p[-p]][-( | -)]*| -r]",
       "",
       "    -? and -h           Display this help",
       "    -s                  Display session pool", 
       "",
       "    -n [Logfile]        Take a pool snapshot",
       "                        Logfile maybe specified, default is poolsnap.log",
       #if !defined (_WIN64)
       "    -c [LocalTagFile]   Display driver information using LocalTagFile",
       "                        If LocalTagFile is not specified", 
	   "                        use 'localtag.txt' from current directory",
       #endif
       "    -g [PoolTagFile]    Display driver information using PoolTagFile",
       "                        If PoolTagFile is not specified", 
	   "                        use 'pooltag.txt' from current directory",
       "",
       "    -itag               Include the tag",
       "    -xtag               Exclude the tag",
       "    -e                  Display totals",
       "    -t                  Sort by tags",
       "    -a                  Sort by allocs",
       "    -u | -b             Sort by Bytes",
       "    -f                  Sort by free",
       "    -d                  Sort by diff",
       "    -m                  Sort by each",
       "    -l                  Highlight",
       "    -p                  First turns on nonpaged, second turns on paged",
       "    -( | -)             Increase parenthesis",
       "    -r                  Print memory summary information" 
};

VOID Usage(VOID)
{
   int i = 0;
   for(i = 0; i < sizeof(UsageStrings)/sizeof(PCHAR); i++)
   {
           puts(UsageStrings[i]);
   }
   exit(-1);
}

int HashString(PUCHAR sz)
{
        
    long page_index = 0;
    UCHAR c;
    
    if(!sz)return -1;
    while(*sz)
    {
        c = *(sz++); 
        page_index = (page_index<<2) ^ c;
    }
    
    //
    //    Calculate hash value.
    //
    return (page_index & 0x7fffffff);
}

VOID
ShowHelpPopup( VOID );

int __cdecl
PoolSnap(FILE *LogFile);

VOID
ShowSessionPopup( VOID );

int __cdecl
ulcomp(const void *e1,const void *e2);

BOOL
GetSnapShotInfo(LPWSTR szBuf, LPDWORD lpdwSize);

int __cdecl
ulcomp(const void *e1,const void *e2)
{
    LONG_PTR u1;

    switch (SortBy) {
        case TAG:

            u1 = ((PUCHAR)e1)[0] - ((PUCHAR)e2)[0];
            if (u1 != 0) {
                return u1 > 0 ? 1 : -1;
            }
            u1 = ((PUCHAR)e1)[1] - ((PUCHAR)e2)[1];
            if (u1 != 0) {
                return u1 > 0 ? 1 : -1;
            }
            u1 = ((PUCHAR)e1)[2] - ((PUCHAR)e2)[2];
            if (u1 != 0) {
                return u1 > 0 ? 1 : -1;
            }
            u1 = ((PUCHAR)e1)[3] - ((PUCHAR)e2)[3];
            if (u1 == 0) {
                return 0;
            } else {
                return u1 > 0 ? 1 : -1;
            }
            break;

        case ALLOC:
            if (Paren & 1) {
                u1 = ((PPOOLMON_OUT)e2)->AllocsDiff -
                        ((PPOOLMON_OUT)e1)->AllocsDiff;
            } else {
                u1 = ((PPOOLMON_OUT)e2)->Allocs -
                        ((PPOOLMON_OUT)e1)->Allocs;
            }
            if (u1 == 0) {
                return 0;
            } else {
                return u1 > 0 ? 1 : -1;
            }
            break;

        case FREE:
            if (Paren & 1) {
                u1 = ((PPOOLMON_OUT)e2)->FreesDiff -
                        ((PPOOLMON_OUT)e1)->FreesDiff;
            } else {
                u1 = ((PPOOLMON_OUT)e2)->Frees -
                        ((PPOOLMON_OUT)e1)->Frees;
            }
            if (u1 == 0) {
                return 0;
            } else {
                return u1 > 0 ? 1 : -1;
            }
            break;

        case BYTES:
            if (Paren & 1) {
                u1 = ((PPOOLMON_OUT)e2)->UsedDiff -
                        ((PPOOLMON_OUT)e1)->UsedDiff;
            } else {
                u1 = ((PPOOLMON_OUT)e2)->Used -
                        ((PPOOLMON_OUT)e1)->Used;
            }
            if (u1 == 0) {
                return 0;
            } else {
                return u1 > 0 ? 1 : -1;
            }
            break;

        case DIFF:
            u1 = ((PPOOLMON_OUT)e2)->Allocs_Frees -
                    ((PPOOLMON_OUT)e1)->Allocs_Frees;
            if (u1 == 0) {
                return 0;
            } else {
                return u1 > 0 ? 1 : -1;
            }
            break;

        case EACH:
            u1 = ((PPOOLMON_OUT)e2)->Each -
                    ((PPOOLMON_OUT)e1)->Each;
            if (u1 == 0) {
                return 0;
            } else {
                return u1 > 0 ? 1 : -1;
            }
            break;

        default:
            return(0);
            break;
    }
}

BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    PCHAR Filter
    )
{
    ULONG i;
    CHAR tc;
    CHAR fc;

    for ( i = 0; i < 4; i++ ) {
        tc = *Tag++;
        fc = *Filter++;
        if ( fc == '*' ) return TRUE;
        if ( fc == '?' ) continue;
        if ( tc != fc ) return FALSE;
    }
    return TRUE;
}

BOOLEAN
CheckFilters (
    PSYSTEM_POOLTAG TagInfo
    )
{
    BOOLEAN pass;
    ULONG i;
    PCHAR tag;

    //
    // If there are no filters, all tags pass.
    //

    if ( FilterCount == 0 ) {
        return TRUE;
    }

    //
    // There are filters.  If the first filter excludes tags, then any
    // tag not explicitly mentioned passes.  If the first filter includes
    // tags, then any tag not explicitly mentioned fails.
    //

    if ( Filter[0].Exclude ) {
        pass = TRUE;
    } else {
        pass = FALSE;
    }

    tag = TagInfo->Tag;
    for ( i = 0; i < FilterCount; i++ ) {
        if ( CheckSingleFilter( tag, (PCHAR)&Filter[i].Tag ) ) {
            pass = !Filter[i].Exclude;
        }
    }

    return pass;
}

VOID
AddFilter (
    BOOLEAN Exclude,
    PCHAR FilterString
    )
{
    PFILTER f;
    PCHAR p;
    ULONG i;

    if ( FilterCount == MAX_FILTER ) {
        printf( "Poolmon: Too many filters specified.  Limit is %d\n", MAX_FILTER );
        return;
    }

    f = &Filter[FilterCount];
    p = f->Tag;

    for ( i = 0; i < 4; i++ ) {
        if ( *FilterString == 0 ) break;
        *p++ = *FilterString++;
    }
    for ( ; i < 4; i++ ) {
        *p++ = ' ';
    }

    f->Exclude = Exclude;
    FilterCount++;

    return;
}

VOID
ParseArgs (
    int argc,
    char *argv[]
    )
{
    char *p, *prev=NULL;
    BOOLEAN exclude;
    PCHAR *filep;

    argc--;
    argv++;

    while ( argc-- > 0 ) {
            p  = *argv++;
        if ( *p == '-' || *p == '/' ) {
            p++;
            exclude = TRUE;
            switch ( tolower(*p) ) {
            case '?':
            case 'h':
                Usage();
                ExitProcess( 1 );
                break;
        
             case 'n':
                 //
                //    Taking a snap.
                //
                IsSnap = TRUE;
                filep = &pchLogFile;
                break;

            #if !defined (_WIN64)
            case 'c':
                     // build or use existing local tag file to display driver information
                     fLocalTag = TRUE;
                     filep = &pchLocalTagFile;
                     break;
            #endif

            case 'g':
                     // use existing pooltag file to display driver information
                     fPoolTag = TRUE;
                     filep = &pchPoolTagFile;
                     break;
                     
            case 'i':
                exclude = FALSE;
            case 'x':
                p++;
                if ( strlen(p) == 0 ) {
                    printf( "Poolmon: missing filter string\n" );
                    ExitProcess( 1 );
                } else if ( strlen(p) <= sizeof(ULONG) ) {
                    AddFilter( exclude, p );
                } else {
                    printf( "Poolmon: filter string too long: %s\n", p );
                    ExitProcess( 1 );
                }
                break;
            case 'e':
                DisplayTotals = TRUE;
                break;
            case 't':
                SortBy = TAG;
                break;
            case 'a':
                SortBy = ALLOC;
                break;
            case 'u':
            case 'b':
                SortBy = BYTES;
                break;
            case 'f':
                SortBy = FREE;
                break;
            case 'd':
                SortBy = DIFF;
                break;
            case 'm':
                SortBy = EACH;

            case 'l':
                NoHighlight = 1 - NoHighlight;
                break;

            case 'p':
                DisplayType += 1;
                if (DisplayType > BOTH) {
                    DisplayType = NONPAGED;
                }
                break;
            
            case '(':
            case ')':
                Paren += 1;
                break;
            
            case 's':
                DisplaySessionPool = TRUE;

                if (*(p+1) != 0) {

                    DisplaySessionId = atoi (p+1);
                } else {

                    DisplaySessionId = (ULONG)-1;
                }
                break;

            case 'r':
            	// print memory summary info
              fPrintSummaryInfo = TRUE;
              break;

            default:
                printf( "Poolmon: unknown switch: %s\n", p );
                ExitProcess( 2 );
            }
        }else {
        if(! IsSnap && !fLocalTag && !fPoolTag )
        {
                printf("Poolmon: unknown switch: %s\n", p );
                ExitProcess( 2 );
        }
        if (prev != NULL)
        {
                // The filename must be immediately after the option
                if (*prev != '-' && *prev != '/')
               {
                     printf("Poolmon: unknown switch: %s\n", p );
                     ExitProcess( 2 );
               }

               //Check if the previous option is one that allows a file name after it
               if (*++prev != 'n'  && *prev != 'g'  && *prev != 'c')
              {
                     printf("Poolmon: unknown switch: %s\n", p );
                     ExitProcess( 2 );
              }
        }
       
        if (*filep != NULL)
        {
               printf("Poolmon: Duplicate file name: %s\n", p );
               ExitProcess( 2 );
        }
       
        *filep = p;
        }
        prev = --p;
    }

    return;
}

BOOL
WriteConsoleLine(
    HANDLE OutputHandle,
    WORD LineNumber,
    LPSTR Text,
    BOOL Highlight
    )
{
    COORD WriteCoord;
    DWORD NumberWritten;
    DWORD TextLength;

    WriteCoord.X = 0;
    WriteCoord.Y = LineNumber;
    if (!FillConsoleOutputCharacter( OutputHandle,
                                     ' ',
                                     NumberOfCols,
                                     WriteCoord,
                                     &NumberWritten
                                   )
       ) {
        return FALSE;
        }

    if (!FillConsoleOutputAttribute( OutputHandle,
                                     (WORD)((Highlight && !NoHighlight) ? HighlightAttribute : NormalAttribute),
                                     NumberOfCols,
                                     WriteCoord,
                                     &NumberWritten
                                   )
       ) {
        return FALSE;
        }


    if (Text == NULL || (TextLength = strlen( Text )) == 0) {
        return TRUE;
        }
    else {
        return WriteConsoleOutputCharacter( OutputHandle,
                                            Text,
                                            TextLength,
                                            WriteCoord,
                                            &NumberWritten
                                          );
        }
}


NTSTATUS
QueryPoolTagInformationIterative(
    PUCHAR *CurrentBuffer,
    SIZE_T *CurrentBufferSize
    )
{
    size_t NewBufferSize;
    NTSTATUS ReturnedStatus = STATUS_SUCCESS;

    if( CurrentBuffer == NULL || CurrentBufferSize == NULL ) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // There is no buffer allocated yet.
    //

    if( *CurrentBufferSize == 0 || *CurrentBuffer == NULL ) {

        NewBufferSize = sizeof( UCHAR ) * BUFFER_SIZE_STEP;

        *CurrentBuffer = (PUCHAR) malloc( NewBufferSize );

        if( *CurrentBuffer != NULL ) {

            *CurrentBufferSize = NewBufferSize;
        
        } else {

            //
            // insufficient memory
            //

            ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    //
    // Iterate by buffer's size.
    //

    while( *CurrentBuffer != NULL ) {

        ReturnedStatus = NtQuerySystemInformation (
            SystemPoolTagInformation,
            *CurrentBuffer,
            (ULONG)*CurrentBufferSize,
            NULL );

        if( ! NT_SUCCESS(ReturnedStatus) ) {

            //
            // Free the current buffer.
            //

            free( *CurrentBuffer );
            
            *CurrentBuffer = NULL;

            if (ReturnedStatus == STATUS_INFO_LENGTH_MISMATCH) {

                //
                // Try with a larger buffer size.
                //

                NewBufferSize = *CurrentBufferSize + BUFFER_SIZE_STEP;

                *CurrentBuffer = (PUCHAR) malloc( NewBufferSize );

                if( *CurrentBuffer != NULL ) {

                    //
                    // Allocated new buffer.
                    //

                    *CurrentBufferSize = NewBufferSize;

                } else {

                    //
                    // Insufficient memory.
                    //

                    ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

                    *CurrentBufferSize = 0;

                }

            } else {

                *CurrentBufferSize = 0;

            }

        } else  {

            //
            // NtQuerySystemInformation returned success.
            //

            break;

        }
    }

    return ReturnedStatus;
}

ULONG
GetExtraPooltagEntriesNeeded (
    PSYSTEM_POOLTAG_INFORMATION SystemPooltagInfoBuffer,
    PSYSTEM_SESSION_POOLTAG_INFORMATION SessionPooltagInfo
    )
{
    ULONG ExtraNeeded;
    ULONG SessionTag;
    ULONG SystemTag;

    ExtraNeeded = 0;

    for (SessionTag = 0; SessionTag < SessionPooltagInfo->Count; SessionTag += 1) {

        for (SystemTag = 0; SystemTag < SystemPooltagInfoBuffer->Count; SystemTag += 1) {

            if (SessionPooltagInfo->TagInfo[ SessionTag ].TagUlong == 
                SystemPooltagInfoBuffer->TagInfo[ SystemTag ].TagUlong) {

                //
                // This session tag is already in our system buffer so we don't
                // need extra space for it.
                //

                break;
            }
        }

        if (SystemTag >= SystemPooltagInfoBuffer->Count) {

            //
            // We didn't find the current session pooltag in the system buffer
            // so we need an extra entry for it.
            //

            ExtraNeeded += 1;
        }
    }

    return ExtraNeeded;
}

VOID
AddSessionInfoToSystemPooltagInfo (
    PSYSTEM_POOLTAG_INFORMATION SystemPooltagInfoBuffer,
    PSYSTEM_SESSION_POOLTAG_INFORMATION SessionPooltagInfo
    )
{
    ULONG SessionTag;
    ULONG SystemTag;

    ASSERT (SystemPooltagInfoBuffer != NULL);
    ASSERT (SessionPooltagInfo != NULL);

    for (SessionTag = 0; SessionTag < SessionPooltagInfo->Count; SessionTag += 1) {

        for (SystemTag = 0; SystemTag < SystemPooltagInfoBuffer->Count; SystemTag += 1) {

            if (SessionPooltagInfo->TagInfo[ SessionTag ].TagUlong == 
                SystemPooltagInfoBuffer->TagInfo[ SystemTag ].TagUlong) {

                //
                // This session tag is already in our system tag buffer.
                // Add the counters for this session.
                //

                SystemPooltagInfoBuffer->TagInfo[ SystemTag ].PagedAllocs +=
                    SessionPooltagInfo->TagInfo[ SessionTag ].PagedAllocs;                    

                SystemPooltagInfoBuffer->TagInfo[ SystemTag ].PagedFrees +=
                    SessionPooltagInfo->TagInfo[ SessionTag ].PagedFrees;                    

                SystemPooltagInfoBuffer->TagInfo[ SystemTag ].PagedUsed +=
                    SessionPooltagInfo->TagInfo[ SessionTag ].PagedUsed;                    

                SystemPooltagInfoBuffer->TagInfo[ SystemTag ].NonPagedAllocs +=
                    SessionPooltagInfo->TagInfo[ SessionTag ].NonPagedAllocs;                    

                SystemPooltagInfoBuffer->TagInfo[ SystemTag ].NonPagedFrees +=
                    SessionPooltagInfo->TagInfo[ SessionTag ].NonPagedFrees;                    

                SystemPooltagInfoBuffer->TagInfo[ SystemTag ].NonPagedUsed +=
                    SessionPooltagInfo->TagInfo[ SessionTag ].NonPagedUsed;                    

                break;
            }
        }

        if (SystemTag == SystemPooltagInfoBuffer->Count) {

            //
            // We didn't find the current session pooltag in the system buffer
            // so we need to add it. 
            //
            // N.B.
            //           
            // Our caller guarantees that there is enough space in 
            // SystemPooltagInfoBuffer to add this extra information.
            //

            SystemPooltagInfoBuffer->TagInfo[ SystemTag ].TagUlong =
                SessionPooltagInfo->TagInfo[ SessionTag ].TagUlong;

            SystemPooltagInfoBuffer->TagInfo[ SystemTag ].PagedAllocs =
                SessionPooltagInfo->TagInfo[ SessionTag ].PagedAllocs;                    

            SystemPooltagInfoBuffer->TagInfo[ SystemTag ].PagedFrees =
                SessionPooltagInfo->TagInfo[ SessionTag ].PagedFrees;                    

            SystemPooltagInfoBuffer->TagInfo[ SystemTag ].PagedUsed =
                SessionPooltagInfo->TagInfo[ SessionTag ].PagedUsed;                    

            SystemPooltagInfoBuffer->TagInfo[ SystemTag ].NonPagedAllocs =
                SessionPooltagInfo->TagInfo[ SessionTag ].NonPagedAllocs;                    

            SystemPooltagInfoBuffer->TagInfo[ SystemTag ].NonPagedFrees =
                SessionPooltagInfo->TagInfo[ SessionTag ].NonPagedFrees;                    

            SystemPooltagInfoBuffer->TagInfo[ SystemTag ].NonPagedUsed =
                SessionPooltagInfo->TagInfo[ SessionTag ].NonPagedUsed; 
            
            SystemPooltagInfoBuffer->Count += 1;
        }
    }
}


NTSTATUS
TranslateSessionBufferToSystemPoolBuffer (
    PSYSTEM_POOLTAG_INFORMATION *SystemPooltagInfoBuffer,
    SIZE_T *SystemPooltagInfoBufferSize
    )
{
    PSYSTEM_SESSION_POOLTAG_INFORMATION CrtSessionPooltagInfo;
    PVOID NewSystemPooltagInfoBuffer;
    SIZE_T NewSystemPooltagInfoBufferSize;
    ULONG AdditionPooltagsNeeded;

    ASSERT (SystemPooltagInfoBuffer != NULL);
    ASSERT (SystemPooltagInfoBufferSize != NULL);

    CrtSessionPooltagInfo = SessionBuffer;

    //
    // Make sure we have at least space to translate the first 
    // session information into SystemPooltagInfoBuffer.
    //

    if (SessionBuffer == NULL) {

        //
        // This can happen if we are querying for a non-existant session.
        //

        NewSystemPooltagInfoBufferSize = sizeof ((*SystemPooltagInfoBuffer)->Count);
    }
    else {

        NewSystemPooltagInfoBufferSize = sizeof ((*SystemPooltagInfoBuffer)->Count) +
                                         CrtSessionPooltagInfo->Count * sizeof (SYSTEM_POOLTAG);
    }

    if (*SystemPooltagInfoBuffer == NULL || *SystemPooltagInfoBufferSize < NewSystemPooltagInfoBufferSize) {

        if (*SystemPooltagInfoBuffer != NULL) {

            free (*SystemPooltagInfoBuffer);
        }

        *SystemPooltagInfoBuffer = malloc (NewSystemPooltagInfoBufferSize);

        if (*SystemPooltagInfoBuffer == NULL) {

            //
            // Bad luck, we cannot allocate so much memory.
            //

            *SystemPooltagInfoBufferSize = 0;
            
            return STATUS_NO_MEMORY;
        }

        *SystemPooltagInfoBufferSize = NewSystemPooltagInfoBufferSize;
    }

    if (SessionBuffer == NULL) {

        //
        // This can happen if we are querying for a non-existant session.
        //

        (*SystemPooltagInfoBuffer)->Count = 0;
    }
    else {

        ASSERT (SessionBuffer->Count == 0 || 
                DisplaySessionId == (ULONG)-1 || 
                DisplaySessionId == SessionBuffer->SessionId);

        //
        // Copy the information for the current session.
        //

        (*SystemPooltagInfoBuffer)->Count = CrtSessionPooltagInfo->Count;
        CopyMemory (&(*SystemPooltagInfoBuffer)->TagInfo[0],
                    &CrtSessionPooltagInfo->TagInfo[0],
                    (*SystemPooltagInfoBuffer)->Count * sizeof (SYSTEM_POOLTAG));

        //
        // Now look if we are looking for data for more than one session.
        // We might need to change the size of SystemPooltagInfoBuffer,
        // realloc it and copy the whole data one more time.
        //

        if (DisplaySessionId == (ULONG)-1) {

            //
            // We have data for all sessions.
            //

            while (CrtSessionPooltagInfo->NextEntryOffset > 0) {

                CrtSessionPooltagInfo = (PSYSTEM_SESSION_POOLTAG_INFORMATION)
                    ((PCHAR)CrtSessionPooltagInfo + CrtSessionPooltagInfo->NextEntryOffset);

                AdditionPooltagsNeeded = GetExtraPooltagEntriesNeeded (*SystemPooltagInfoBuffer,
                                                                       CrtSessionPooltagInfo);

                if (AdditionPooltagsNeeded > 0) {

                    NewSystemPooltagInfoBufferSize = sizeof ((*SystemPooltagInfoBuffer)->Count) +
                                                     ((*SystemPooltagInfoBuffer)->Count + AdditionPooltagsNeeded) *
                                                     sizeof (SYSTEM_POOLTAG);

                    if (NewSystemPooltagInfoBufferSize > *SystemPooltagInfoBufferSize) {

                        //
                        // We need to reallocate our SystemPooltagInfoBuffer,
                        // copy the data we already have, then add these extra pooltags.
                        //


                        NewSystemPooltagInfoBuffer = malloc (NewSystemPooltagInfoBufferSize);
                
                        if (NewSystemPooltagInfoBuffer == NULL) {

                            //
                            // Bad luck, we cannot allocate so much memory.
                            //

                            return STATUS_NO_MEMORY;
                        }

                        //
                        // Make a copy of the current buffer then continue with its larger copy.
                        //

                        CopyMemory (NewSystemPooltagInfoBuffer,
                                    *SystemPooltagInfoBuffer,
                                    *SystemPooltagInfoBufferSize);

                        free (*SystemPooltagInfoBuffer);

                        *SystemPooltagInfoBuffer = NewSystemPooltagInfoBuffer;
                        *SystemPooltagInfoBufferSize = NewSystemPooltagInfoBufferSize;
                    }
                }

                //
                // At this point we should have enough space in SystemPooltagInfoBuffer
                // to fit all the pooltag info from CrtSessionPooltagInfo.
                //

                AddSessionInfoToSystemPooltagInfo (*SystemPooltagInfoBuffer,
                                                   CrtSessionPooltagInfo);
            }
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
QuerySessionPoolTagInformationIterative (
    PSYSTEM_POOLTAG_INFORMATION *CurrentSystemBuffer,
    SIZE_T *CurrentSystemBufferSize
    )
{
    NTSTATUS Status;
    ULONG NewBufferSize;
    SYSTEM_SESSION_PROCESS_INFORMATION SessionProcessInformation;

    SessionProcessInformation.SessionId = DisplaySessionId;

    while (TRUE)
    {
        SessionProcessInformation.SizeOfBuf = SessionBufferSize;
        SessionProcessInformation.Buffer = SessionBuffer;

        Status = NtQuerySystemInformation (SystemSessionPoolTagInformation,
                                           &SessionProcessInformation,
                                           sizeof (SessionProcessInformation),
                                           & NewBufferSize);

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {

            if (SessionBufferSize != 0) {

                //
                // Our buffer is just not large enough. Add BUFFER_SIZE_STEP
                // to its size. We are not trying to use the size returned
                // by NtQuery here because theoretically some other pool
                // tag might always show up between the two consecutive 
                // queries and we would loop forever in that case.
                //

                free (SessionBuffer);

                NewBufferSize = SessionBufferSize + BUFFER_SIZE_STEP;
            }

            SessionBuffer = malloc (NewBufferSize);

            if (SessionBuffer == NULL) {
                
                //
                // Bad luck, we cannot allocate so much memory
                // so bail out.
                //

                SessionBufferSize = 0;

                return STATUS_NO_MEMORY;
            }

            SessionBufferSize = NewBufferSize;
        }
        else if (Status == STATUS_INVALID_INFO_CLASS) {

            //
            // This is probably a Win2k or XP box so we just ignore the error.
            //
            
            ASSERT (SessionBuffer == NULL);

            break;
        }
        else if (!NT_SUCCESS(Status)) {

            //
            // Query failed for some reason.
            //

            return Status;
        }
        else {

            //
            // All set - we have the information.
            //

            if (NewBufferSize == 0 && SessionBuffer != NULL) {

                //
                // We didn't get back any information (e.g. the session doesn't exist).
                //

                SessionBuffer->Count = 0;
            }

            break;
        }
    }
    
    return TranslateSessionBufferToSystemPoolBuffer (CurrentSystemBuffer,
                                                     CurrentSystemBufferSize);
}


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{

    NTSTATUS Status;
    ULONG LastCount = 0;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    PSYSTEM_POOLTAG_INFORMATION PoolInfo;
    PSYSTEM_POOLTAG_INFORMATION PoolInfoOld;
    PUCHAR *PreviousBuffer;
    PUCHAR *CurrentBuffer;
    PUCHAR *TempBuffer;
    SIZE_T *PreviousBufferSize;
    SIZE_T *CurrentBufferSize;
    SIZE_T *TempBufferSize;
    BOOLEAN DoHelp;
    BOOLEAN DoQuit;
    SIZE_T NumberOfPoolTags;
    SIZE_T i;
    UCHAR LastKey;
    PPOOLMON_OUT Out;
    LONG ScrollDelta;
    WORD DisplayLine, LastDetailRow,BottomDisplayedLine;
    CHAR OutputBuffer[ OUTPUTBUFFERSIZE ];
    FILE *LogFile = NULL;
    INT LastKeyUpper;
    ULONG PoolCount=0;

    DoHelp = FALSE;
    DoQuit = FALSE;
    Interactive = TRUE;

    BottomDisplayedLine = 0;
    
    ParseArgs( argc, argv );

    if (fPoolTag || fLocalTag) BuildTagMap();        
    
    if(IsSnap)
    {
        if(pchLogFile)
        {
            LogFile = fopen(pchLogFile, "a");
            if(!LogFile)
            {
                      printf("Poolmon: Error Opening file %s: %d\n", pchLogFile, GetLastError());
                      return(0);
             }
         }
         else if( (LogFile = fopen("poolsnap.log","a")) == NULL ) {
                    printf("Poolmon: Error Opening file poolsnap.log: %d\n", GetLastError());
                    return(0);
         }

         PoolSnap(LogFile);

         // close file
         fclose(LogFile);

         return 0;
     }


    InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    OriginalOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
    if (Interactive) {
        if (InputHandle == NULL ||
            OriginalOutputHandle == NULL ||
            !GetConsoleMode( InputHandle, &OriginalInputMode )
           ) {
            Interactive = FALSE;
        } else {
            OutputHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                                      FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                      NULL,
                                                      CONSOLE_TEXTMODE_BUFFER,
                                                      NULL
                                                    );
            if (OutputHandle == NULL ||
                !GetConsoleScreenBufferInfo( OriginalOutputHandle, &OriginalConsoleInfo ) ||
                !SetConsoleScreenBufferSize( OutputHandle, OriginalConsoleInfo.dwSize ) ||
                !SetConsoleActiveScreenBuffer( OutputHandle ) ||
                !SetConsoleMode( InputHandle, 0 )
               ) {
                if (OutputHandle != NULL) {
                    CloseHandle( OutputHandle );
                    OutputHandle = NULL;
                }

                Interactive = FALSE;
            } else {
                NormalAttribute = 0x1F;
                HighlightAttribute = 0x71;
                NumberOfCols = OriginalConsoleInfo.dwSize.X;
                NumberOfRows = OriginalConsoleInfo.dwSize.Y;
                NumberOfDetailLines = NumberOfRows;
            }
        }
    }

    NtQuerySystemInformation( SystemBasicInformation,
                              &BasicInfo,
                              sizeof(BasicInfo),
                              NULL
                            );

    if (GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS) {
        SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS);
    }

    PreviousBuffer = &LargeBuffer2;             // NULL at this point
    PreviousBufferSize = &LargeBuffer2Size;     // 0 at this point
    
    CurrentBuffer = &LargeBuffer1;              // NULL at this point
    CurrentBufferSize = &LargeBuffer1Size;      // 0 at this point

    while(TRUE) {
        Status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &PerfInfo,
                    sizeof(PerfInfo),
                    NULL
                    );

        if ( !NT_SUCCESS(Status) ) {
            printf("Poolmon: Query perf Failed (returned: %lx)\n",
                         Status);
            break;
        }


        if (DisplaySessionPool == FALSE) {

            Status = QueryPoolTagInformationIterative (CurrentBuffer,
                                                       CurrentBufferSize);
        }
        else {
            Status = QuerySessionPoolTagInformationIterative ((PSYSTEM_POOLTAG_INFORMATION *)CurrentBuffer,
                                                              CurrentBufferSize);
        }

        if ( !NT_SUCCESS(Status) ) {
            printf("Poolmon: Query pooltags failed (returned: %lx)\n"
                         "Did you remember to enable pool tagging with gflags.exe and reboot?\n",
                         Status);
            break;
        }

        //
        // Calculate pool tags and display information.
        //
        //

        PoolInfo = (PSYSTEM_POOLTAG_INFORMATION)( *CurrentBuffer );
        i = PoolInfo->Count;
        PoolInfoOld = (PSYSTEM_POOLTAG_INFORMATION)( *PreviousBuffer );

        DisplayLine = 0;
        _snprintf( OutputBuffer, OUTPUTBUFFERSIZE,
                 " Memory:%8ldK Avail:%8ldK  PageFlts:%6ld   InRam Krnl:%5ldK P:%5ldK",
                 BasicInfo.NumberOfPhysicalPages*(BasicInfo.PageSize/1024),
                 PerfInfo.AvailablePages*(BasicInfo.PageSize/1024),
                 PerfInfo.PageFaultCount - LastCount,
                 (PerfInfo.ResidentSystemCodePage + PerfInfo.ResidentSystemDriverPage)*(BasicInfo.PageSize/1024),
                 (PerfInfo.ResidentPagedPoolPage)*(BasicInfo.PageSize/1024)
               );
        OutputBuffer[OUTPUTBUFFERSIZE-1] = '\0';
        
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          OutputBuffer,
                          FALSE
                        );

        LastCount = PerfInfo.PageFaultCount;
        _snprintf( OutputBuffer, OUTPUTBUFFERSIZE,
                 " Commit:%7ldK Limit:%7ldK Peak:%7ldK            Pool N:%5ldK P:%5ldK",
                 PerfInfo.CommittedPages*(BasicInfo.PageSize/1024),
                 PerfInfo.CommitLimit*(BasicInfo.PageSize/1024),
                 PerfInfo.PeakCommitment*(BasicInfo.PageSize/1024),
                 PerfInfo.NonPagedPoolPages*(BasicInfo.PageSize/1024),
                 PerfInfo.PagedPoolPages*(BasicInfo.PageSize/1024)
               );
        OutputBuffer[OUTPUTBUFFERSIZE-1] = '\0';
        
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          OutputBuffer,
                          FALSE
                        );

        if (DisplaySessionPool == FALSE) {
            WriteConsoleLine( OutputHandle,
                              DisplayLine++,
                              " System pool information",
                              FALSE
                            );
        }
        else {
            if (DisplaySessionId == (ULONG)-1) {
                WriteConsoleLine( OutputHandle,
                                  DisplayLine++,
                                  " All sessions pool information",
                                  FALSE
                                );
            }
            else {
                _snprintf( OutputBuffer, OUTPUTBUFFERSIZE,
                         " Session %u pool information",
                         DisplaySessionId
                       );

                OutputBuffer[OUTPUTBUFFERSIZE-1] = '\0';
                
                WriteConsoleLine( OutputHandle,
                                  DisplayLine++,
                                  OutputBuffer,
                                  FALSE
                                );
            }
        }

// If driver information is not needed to be displayed don't display "Mapped_Driver"
if (fLocalTag  || fPoolTag) 
{
       #if !defined (_WIN64)
               WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          " Tag  Type     Allocs            Frees            Diff   Bytes      Per Alloc  Mapped_Driver",
                          FALSE
                        );
       #else
               WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          " Tag  Type     Allocs            Frees            Diff       Bytes                 Per Alloc Mapped_Driver",
                          FALSE
                        );
       #endif //#if !defined (_WIN64)
}
else
{
       #if !defined (_WIN64)
               WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          " Tag  Type     Allocs            Frees            Diff   Bytes       Per Alloc",
                          FALSE
                        );
       #else
               WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          " Tag  Type     Allocs            Frees            Diff       Bytes                  Per Alloc",
                          FALSE
                        );
       #endif //#if !defined (_WIN64)

}
        
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          NULL,
                          FALSE
                        );


        
        PoolCount = PoolInfo->Count;

       
        if(OutBufferSize < PoolInfo->Count)
        {
            POOLMON_OUT *tempOutBuffer = OutBuffer;
            OutBuffer = (PPOOLMON_OUT)malloc(PoolInfo->Count * sizeof(POOLMON_OUT));

            // Don't let go of the memory you have if you don't get more memory
            if(!OutBuffer)
            {
                // This is the first allocation and it failed
                if (!tempOutBuffer)
                {
                    printf("Poolmon: Memory allocation failed: %d\n", GetLastError());
                    FreeTagMap();
                    ExitProcess( 1 );
                }
                // If there was an outbuffer we should retain what we have and display 
                // the number of pool entries that we can
                else
                {
                    // We can only display as many entries as outbuffer can hold
                    PoolCount = (ULONG)OutBufferSize;
                    OutBuffer = tempOutBuffer;
                }
            }
            else
            {
                  if (tempOutBuffer) free (tempOutBuffer);
                  OutBufferSize = PoolInfo->Count;
            }
        }


        Out = OutBuffer;
        if (DisplayTotals) {
            RtlZeroMemory( Totals, sizeof(POOLMON_OUT)*2 );
        }

        for (i = 0; i < PoolCount; i++) {

            if ( !CheckFilters(&PoolInfo->TagInfo[i]) ) {
                continue;
            }

            if ((PoolInfo->TagInfo[i].NonPagedAllocs != 0) &&
                 (DisplayType != PAGED)) {

                Out->Allocs = PoolInfo->TagInfo[i].NonPagedAllocs;
                Out->Frees = PoolInfo->TagInfo[i].NonPagedFrees;
                Out->Used = PoolInfo->TagInfo[i].NonPagedUsed;
                Out->Allocs_Frees = PoolInfo->TagInfo[i].NonPagedAllocs -
                                PoolInfo->TagInfo[i].NonPagedFrees;
                Out->TagUlong = PoolInfo->TagInfo[i].TagUlong;
                Out->Type = NONPAGED;
                Out->Changed = FALSE;
                Out->NullByte = '\0';

                if (PoolInfoOld != NULL &&
                    PoolInfoOld->Count > i && 
                    PoolInfoOld->TagInfo[i].TagUlong == PoolInfo->TagInfo[i].TagUlong
                   ) {
                    Out->AllocsDiff = PoolInfo->TagInfo[i].NonPagedAllocs - PoolInfoOld->TagInfo[i].NonPagedAllocs;
                    Out->FreesDiff = PoolInfo->TagInfo[i].NonPagedFrees - PoolInfoOld->TagInfo[i].NonPagedFrees;
                    Out->UsedDiff = PoolInfo->TagInfo[i].NonPagedUsed - PoolInfoOld->TagInfo[i].NonPagedUsed;
                    if (Out->AllocsDiff != 0 ||
                        Out->FreesDiff != 0 ||
                        Out->UsedDiff != 0
                       ) {
                        Out->Changed = TRUE;
                    }
                } else {
                    Out->AllocsDiff = 0;
                    Out->UsedDiff = 0;
                    Out->FreesDiff = 0;
                }
                Out->Each =  Out->Used / (Out->Allocs_Frees?Out->Allocs_Frees:1);
                if (DisplayTotals) {
                    Totals[NONPAGED].Allocs += Out->Allocs;
                    Totals[NONPAGED].AllocsDiff += Out->AllocsDiff;
                    Totals[NONPAGED].Frees += Out->Frees;
                    Totals[NONPAGED].FreesDiff += Out->FreesDiff;
                    Totals[NONPAGED].Allocs_Frees += Out->Allocs_Frees;
                    Totals[NONPAGED].Used += Out->Used;
                    Totals[NONPAGED].UsedDiff += Out->UsedDiff;
                }
                Out += 1;
            }

            else if ((PoolInfo->TagInfo[i].PagedAllocs != 0) &&
                 (DisplayType != NONPAGED)) {

                Out->Allocs = PoolInfo->TagInfo[i].PagedAllocs;
                Out->Frees = PoolInfo->TagInfo[i].PagedFrees;
                Out->Used = PoolInfo->TagInfo[i].PagedUsed;
                Out->Allocs_Frees = PoolInfo->TagInfo[i].PagedAllocs -
                                PoolInfo->TagInfo[i].PagedFrees;
                Out->TagUlong = PoolInfo->TagInfo[i].TagUlong;
                Out->Type = PAGED;
                Out->Changed = FALSE;
                Out->NullByte = '\0';

                if (PoolInfoOld != NULL &&
                    PoolInfoOld->Count > i && 
                    PoolInfoOld->TagInfo[i].TagUlong == PoolInfo->TagInfo[i].TagUlong
                   ) {
                    Out->AllocsDiff = PoolInfo->TagInfo[i].PagedAllocs - PoolInfoOld->TagInfo[i].PagedAllocs;
                    Out->FreesDiff = PoolInfo->TagInfo[i].PagedFrees - PoolInfoOld->TagInfo[i].PagedFrees;
                    Out->UsedDiff = PoolInfo->TagInfo[i].PagedUsed - PoolInfoOld->TagInfo[i].PagedUsed;
                    if (Out->AllocsDiff != 0 ||
                        Out->FreesDiff != 0 ||
                        Out->UsedDiff != 0
                       ) {
                        Out->Changed = TRUE;
                    }
                } else {
                    Out->AllocsDiff = 0;
                    Out->UsedDiff = 0;
                    Out->FreesDiff = 0;
                }
                Out->Each =  Out->Used / (Out->Allocs_Frees?Out->Allocs_Frees:1);
                if (DisplayTotals) {
                    Totals[PAGED].Allocs += Out->Allocs;
                    Totals[PAGED].AllocsDiff += Out->AllocsDiff;
                    Totals[PAGED].Frees += Out->Frees;
                    Totals[PAGED].FreesDiff += Out->FreesDiff;
                    Totals[PAGED].Allocs_Frees += Out->Allocs_Frees;
                    Totals[PAGED].Used += Out->Used;
                    Totals[PAGED].UsedDiff += Out->UsedDiff;
                }
                Out += 1;
            }
        } //end for

        //
        // Sort the running working set buffer
        //

        NumberOfPoolTags = Out - OutBuffer;
        qsort((void *)OutBuffer,
              (size_t)NumberOfPoolTags,
              (size_t)sizeof(POOLMON_OUT),
              ulcomp);

        LastDetailRow = (WORD)(NumberOfRows - (DisplayTotals ? (DisplayType == BOTH ? 3 : 2) : 0));
        Out = (PPOOLMON_OUT)OutBuffer;
        for (i = FirstDetailLine; i < NumberOfPoolTags; i++) {
            PTAGNODE pn = NULL;
            int cnt = 0;
            if (DisplayLine >= LastDetailRow) {
                break;
            }

            pn = LookupTag(Out->Tag);

            if(! pn)
            {
            #if !defined (_WIN64)
                _snprintf( OutputBuffer, OUTPUTBUFFERSIZE,
                        " %4s %5s %9ld (%4ld) %9ld (%4ld) %8ld %7ld (%6ld) %6ld %s",
                        Out->Tag,
                        PoolType[Out->Type],
                        Out->Allocs,
                        Out->AllocsDiff,
                        Out->Frees,
                        Out->FreesDiff,
                        Out->Allocs_Frees,
                        Out->Used,
                        Out->UsedDiff,
                        Out->Each,
                        (fLocalTag || fPoolTag) ? "Unknown Driver" : ""
                    );
                OutputBuffer[OUTPUTBUFFERSIZE-1] = '\0';
                
            #else
                _snprintf( OutputBuffer, OUTPUTBUFFERSIZE, 
                        " %4s %5s %9I64u (%4I64d) %9I64u (%4I64d) %8I64u %11I64u (%11I64d) %11I64u %s",
                        Out->Tag,
                        PoolType[Out->Type],
                        Out->Allocs,
                        Out->AllocsDiff,
                        Out->Frees,
                        Out->FreesDiff,
                        Out->Allocs_Frees,
                        Out->Used,
                        Out->UsedDiff,
                        Out->Each,
                        (fLocalTag || fPoolTag) ? "Unknown Driver" : ""
                    );
                OutputBuffer[OUTPUTBUFFERSIZE-1] = '\0';
            #endif
            
                WriteConsoleLine( OutputHandle,
                                DisplayLine++,
                                OutputBuffer,
                                Out->Changed
                                );
            }
            else
            {
                #if !defined (_WIN64)
                    _snprintf( OutputBuffer, OUTPUTBUFFERSIZE,
                            " %4s %5s %9ld (%4ld) %9ld (%4ld) %8ld %7ld (%6ld) %6ld %s",
                            Out->Tag,
                            PoolType[Out->Type],
                            Out->Allocs,
                            Out->AllocsDiff,
                            Out->Frees,
                            Out->FreesDiff,
                            Out->Allocs_Frees,
                            Out->Used,
                            Out->UsedDiff,
                            Out->Each,
                            pn->Driver
                        );
                    OutputBuffer[OUTPUTBUFFERSIZE-1] = '\0';
                    
                #else
                    _snprintf( OutputBuffer, OUTPUTBUFFERSIZE,
                            " %4s %5s %9I64u (%4I64d) %9I64u (%4I64d) %8I64u %11I64u (%11I64d) %11I64u %s",
                            Out->Tag,
                            PoolType[Out->Type],
                            Out->Allocs,
                            Out->AllocsDiff,
                            Out->Frees,
                            Out->FreesDiff,
                            Out->Allocs_Frees,
                            Out->Used,
                            Out->UsedDiff,
                            Out->Each,
                            pn->Driver
                        );
                    OutputBuffer[OUTPUTBUFFERSIZE-1] = '\0';
                    
                #endif
                    WriteConsoleLine( OutputHandle,
                                    DisplayLine++,
                                    OutputBuffer,
                                    Out->Changed
                                    );
            }

            Out->Changed = FALSE;
            Out++;
        }

        if (DisplayTotals) {
            WriteConsoleLine( OutputHandle,
                              DisplayLine++,
                              NULL,
                              FALSE
                            );
            for (i = 0; i < 2; i++) {
                if ( (int)DisplayType == i || DisplayType == BOTH ) {
                    
#if !defined (_WIN64)
                    _snprintf( OutputBuffer, OUTPUTBUFFERSIZE,
                             "Total %5s %9ld (%4ld) %9ld (%4ld) %8ld %7ld (%6ld) %6ld",
                             PoolType[i],
                             Totals[i].Allocs,
                             Totals[i].AllocsDiff,
                             Totals[i].Frees,
                             Totals[i].FreesDiff,
                             Totals[i].Allocs_Frees,
                             Totals[i].Used,
                             Totals[i].UsedDiff,
                             Totals[i].Each
                           );

                    OutputBuffer[OUTPUTBUFFERSIZE-1] = '\0';
#else
                    _snprintf( OutputBuffer, OUTPUTBUFFERSIZE,
                             "Total %5s %9I64u (%4I64d) %9I64u (%4I64d) %8I64u %11I64u (%11I64d) %11I64u",
                             PoolType[i],
                             Totals[i].Allocs,
                             Totals[i].AllocsDiff,
                             Totals[i].Frees,
                             Totals[i].FreesDiff,
                             Totals[i].Allocs_Frees,
                             Totals[i].Used,
                             Totals[i].UsedDiff,
                             Totals[i].Each
                           );
                    OutputBuffer[OUTPUTBUFFERSIZE-1] = '\0';
                    
#endif //#if !defined (_WIN64)

                    WriteConsoleLine( OutputHandle,
                                      DisplayLine++,
                                      OutputBuffer,
                                      FALSE
                                    );
                }
            }
        }

        //
        // If we had less lines to display this time than last time
        // erase the rest of the console output.
        //

        while (DisplayLine < BottomDisplayedLine) {

            WriteConsoleLine( OutputHandle,
                              DisplayLine++,
                              NULL,
                              FALSE
                            );
        }
        
        BottomDisplayedLine = DisplayLine;

        TempBuffer = PreviousBuffer;
        TempBufferSize = PreviousBufferSize;

        PreviousBuffer = CurrentBuffer;
        PreviousBufferSize = CurrentBufferSize;

        CurrentBuffer = TempBuffer;
        CurrentBufferSize = TempBufferSize;

        while (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0) {
            //
            // Check for input record
            //
            if (ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
                InputRecord.EventType == KEY_EVENT &&
                InputRecord.Event.KeyEvent.bKeyDown
               ) {
                LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;
                if (LastKey < ' ') {
                    ScrollDelta = 0;
                    if (LastKey == 'C'-'A'+1) {
                        DoQuit = TRUE;
                    } else switch (InputRecord.Event.KeyEvent.wVirtualKeyCode) {
                        case VK_ESCAPE:
                            DoQuit = TRUE;
                            break;

                        case VK_PRIOR:
                            ScrollDelta = -(LONG)(InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines);
                            break;

                        case VK_NEXT:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines;
                            break;

                        case VK_UP:
                            ScrollDelta = -InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_DOWN:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_HOME:
                            FirstDetailLine = 0;
                            break;

                        case VK_END:
                            FirstDetailLine = NumberOfPoolTags - NumberOfDetailLines;
                            break;
                    }

                    if (ScrollDelta != 0) {
                        if (ScrollDelta < 0) {
                            if (FirstDetailLine <= (ULONG)-ScrollDelta) {
                                FirstDetailLine = 0;
                            } else {
                                FirstDetailLine += ScrollDelta;
                            }
                        } else {
                            FirstDetailLine += ScrollDelta;
                            if (FirstDetailLine >= (NumberOfPoolTags - NumberOfDetailLines)) {
                                FirstDetailLine = NumberOfPoolTags - NumberOfDetailLines;
                            }
                        }
                    }
                } else {
                    LastKeyUpper = toupper(LastKey);
                    switch (LastKeyUpper) {
                        case 'Q':
                            //
                            //  Go to the bottom of the current screen when
                            //  we quit.
                            //
                            DoQuit = TRUE;
                            break;

                        case 'T':
                            SortBy = TAG;
                            FirstDetailLine = 0;
                            break;

                        case 'A':
                            SortBy = ALLOC;
                            FirstDetailLine = 0;
                            break;

                        case 'U':
                        case 'B':
                            SortBy = BYTES;
                            FirstDetailLine = 0;
                            break;

                        case 'F':
                            SortBy = FREE;
                            FirstDetailLine = 0;
                            break;

                        case 'D':
                            SortBy = DIFF;
                            FirstDetailLine = 0;
                            break;

                        case 'M':
                            SortBy = EACH;
                            FirstDetailLine = 0;
                            break;

                        case 'L':

                            NoHighlight = 1 - NoHighlight;
                            break;

                        case 'P':
                            DisplayType += 1;
                            if (DisplayType > BOTH) {
                                DisplayType = NONPAGED;
                            }
                            FirstDetailLine = 0;
                            break;

                        case 'X':
                        case '(':
                        case ')':

                            Paren += 1;
                            break;

                        case 'E':
                            DisplayTotals = !DisplayTotals;
                            FirstDetailLine = 0;
                            break;

                        case 'H':
                        case '?':
                            DoHelp = TRUE;
                            break;

                        case 'S':
                            DisplaySessionPool = !DisplaySessionPool;
                            break;
                            
                        case 'I':
                            ShowSessionPopup ();
                            break;

                        default:
                            if (LastKeyUpper >= '0' && LastKeyUpper <= '9')
                            {
                                DisplaySessionPool = TRUE;
                                DisplaySessionId = LastKeyUpper - '0';
                            }
                            break;

                    }
                }

                break;
            }
        }

        if (DoQuit) {
            break;
        }

        if (DoHelp) {
            DoHelp = FALSE;
            ShowHelpPopup();
        }
    }

    if (Interactive) {
        SetConsoleActiveScreenBuffer( OriginalOutputHandle );
        SetConsoleMode( InputHandle, OriginalInputMode );
        CloseHandle( OutputHandle );
        }

    FreeTagMap();

    if(OutBuffer)
        free(OutBuffer);

    ExitProcess( 0 );
    return 0;
}

int __cdecl
PoolSnap(
    FILE *LogFile  // Snapshot log file
    )
 /*++
 
Routine Description:
 
    This function collects the list of active drivers in the system and stores the relevant
    pool allocation information along with the tag information (if available) in the 
    snapshot LogFile
 
Return Value:

    0: If there is no error
    1: Otherwise
 
--*/
{
    NTSTATUS    Status;                   // status from NT api
    DWORD        x= 0;                     // counter
    SIZE_T        NumberOfPoolTags;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    PSYSTEM_POOLTAG_INFORMATION PoolInfo;
    PPOOLMON_OUT Out;
    PUCHAR        CurrentBuffer = NULL;
    size_t        CurrentBufferSize = 0;
    int            res = 0;
    LONG       FileSize = 0;

    FileSize = _filelength(_fileno(LogFile));
    if( FileSize == -1 ) {
              printf("Poolmon: Bad file length of snapshot Logfile\n");
              goto Error;
        }    

    fprintf(LogFile,"\n");

    if (fPrintSummaryInfo)
    {
    	Status = NtQuerySystemInformation( SystemBasicInformation,
                              &BasicInfo,
                              sizeof(BasicInfo),
                              NULL
                            );

     	if ( !NT_SUCCESS(Status) ) {
            printf("Poolmon: Query Basic Info Failed (returned: %lx)\n",
                         Status);
            goto Error;
    	}

 
    	if (GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS) {
       	 SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS);
    	}

    	Status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &PerfInfo,
                    sizeof(PerfInfo),
                    NULL
                    );

    	if ( !NT_SUCCESS(Status) ) {
            printf("Poolmon: Query perf Failed (returned: %lx)\n",
                         Status);
            goto Error;
        }

    	fprintf( LogFile, 
                 " Memory:%8ldK Avail:%8ldK  PageFlts:%6ld   InRam Krnl:%5ldK P:%5ldK\n",
                 BasicInfo.NumberOfPhysicalPages*(BasicInfo.PageSize/1024),
                 PerfInfo.AvailablePages*(BasicInfo.PageSize/1024),
                 PerfInfo.PageFaultCount,
                 (PerfInfo.ResidentSystemCodePage + PerfInfo.ResidentSystemDriverPage)*(BasicInfo.PageSize/1024),
                 (PerfInfo.ResidentPagedPoolPage)*(BasicInfo.PageSize/1024)
               );

    	fprintf( LogFile,
                 " Commit:%7ldK Limit:%7ldK Peak:%7ldK            Pool N:%5ldK P:%5ldK\n",
                 PerfInfo.CommittedPages*(BasicInfo.PageSize/1024),
                 PerfInfo.CommitLimit*(BasicInfo.PageSize/1024),
                 PerfInfo.PeakCommitment*(BasicInfo.PageSize/1024),
                 PerfInfo.NonPagedPoolPages*(BasicInfo.PageSize/1024),
                 PerfInfo.PagedPoolPages*(BasicInfo.PageSize/1024)
               );

    	fprintf(LogFile,"\n");
    }
    
    //
    // print file header once
    //
    if (fLocalTag || fPoolTag)
    {
    #if !defined (_WIN64)    
        fprintf(LogFile," Tag  Type     Allocs         Frees    Diff   Bytes    Per Alloc    Mapped_Driver\n");
    #else
        fprintf(LogFile," Tag  Type     Allocs            Frees               Diff            Bytes                 Per Alloc       Mapped_Driver\n");
    #endif 
    }
    else
    {
    #if !defined (_WIN64)    
        fprintf(LogFile," Tag  Type     Allocs         Frees    Diff   Bytes    Per Alloc\n");
    #else
        fprintf(LogFile," Tag  Type     Allocs            Frees               Diff            Bytes                 Per Alloc\n");
    #endif 
    }
    
    fprintf(LogFile,"\n");

    // grab all pool information
    // log line format, fixed column format
    Status = QueryPoolTagInformationIterative(
                &CurrentBuffer,
                &CurrentBufferSize
                );

    if (! NT_SUCCESS(Status)) {
        printf("Poolmon: Failed to query pool tags information (status %08X). \n", Status);
        printf("Please check if pool tags are enabled. \n");

        // If there is an operator around, wake him up, but keep moving
        Beep(1000,350); Beep(500,350); Beep(1000,350);
        goto Error;
    }

    PoolInfo = (PSYSTEM_POOLTAG_INFORMATION)CurrentBuffer;
    OutBuffer = (PPOOLMON_OUT)malloc(PoolInfo->Count * sizeof(POOLMON_OUT));
    if(!OutBuffer)
    {
        printf("Poolmon: Failed to allocate memory: %d\n", GetLastError());
        goto Error;
    }
    
    OutBufferSize = PoolInfo->Count;
    Out = OutBuffer;

    for (x = 0; x < (int)PoolInfo->Count; x++) {
        // get pool info from buffer 

        // non-paged 
        if (PoolInfo->TagInfo[x].NonPagedAllocs != 0) {
            Out->Allocs = PoolInfo->TagInfo[x].NonPagedAllocs;
            Out->Frees = PoolInfo->TagInfo[x].NonPagedFrees;
            Out->Used = PoolInfo->TagInfo[x].NonPagedUsed;
            Out->Allocs_Frees = PoolInfo->TagInfo[x].NonPagedAllocs -
                                PoolInfo->TagInfo[x].NonPagedFrees;
            Out->TagUlong = PoolInfo->TagInfo[x].TagUlong;
            Out->Type = NONPAGED;
            Out->Changed = FALSE;
            Out->NullByte = '\0';
            Out->Each =  Out->Used / (Out->Allocs_Frees?Out->Allocs_Frees:1);
            Out++;
            }
        // paged
        else if (PoolInfo->TagInfo[x].PagedAllocs != 0) {
            Out->Allocs = PoolInfo->TagInfo[x].PagedAllocs;
            Out->Frees = PoolInfo->TagInfo[x].PagedFrees;
            Out->Used = PoolInfo->TagInfo[x].PagedUsed;
            Out->Allocs_Frees = PoolInfo->TagInfo[x].PagedAllocs -
                                PoolInfo->TagInfo[x].PagedFrees;
            Out->TagUlong = PoolInfo->TagInfo[x].TagUlong;
            Out->Type = PAGED;
            Out->Changed = FALSE;
            Out->NullByte = '\0';
            Out->Each =  Out->Used / (Out->Allocs_Frees?Out->Allocs_Frees:1);
            Out++;
      }
 
    }

    //
    // sort by tag value which is big endian 
    // 

    NumberOfPoolTags = Out - OutBuffer;
    qsort((void *)OutBuffer,
          (size_t)NumberOfPoolTags,
          (size_t)sizeof(POOLMON_OUT),
          ulcomp);

    //
    // print in file
    //
    for (x = 0; x < NumberOfPoolTags; x++) {
        int cnt = 0;
        PTAGNODE pn = LookupTag(OutBuffer[x].Tag);

        if(pn == NULL)
        {
            fprintf(LogFile,
#ifdef _WIN64
                " %4s %5s %18I64d %18I64d  %16I64d %14I64d     %12I64d        %s\n",
#else
        " %4s %5s %9ld %9ld  %8ld %7ld     %6ld        %s\n",
#endif
                OutBuffer[x].Tag,
                PoolType[OutBuffer[x].Type],
                OutBuffer[x].Allocs,
                OutBuffer[x].Frees,
                OutBuffer[x].Allocs_Frees,
                OutBuffer[x].Used,
                OutBuffer[x].Each,
               (fLocalTag || fPoolTag) ? "Unknown Driver" : ""
               );
        }
        else
        {
                   fprintf(LogFile,
#ifdef _WIN64
                    " %4s %5s %18I64d %18I64d  %16I64d %14I64d     %12I64d        %s\n",
#else
                    " %4s %5s %9ld %9ld  %8ld %7ld     %6ld        %s\n",
#endif
                    OutBuffer[x].Tag,
                    PoolType[OutBuffer[x].Type],
                    OutBuffer[x].Allocs,
                    OutBuffer[x].Frees,
                    OutBuffer[x].Allocs_Frees,
                    OutBuffer[x].Used,
                    OutBuffer[x].Each,
                    pn->Driver
                );
         }
    }
    goto Exit;
Error:
    res = 1;
Exit:
    FreeTagMap();
    if(OutBuffer)
        free(OutBuffer);
    if(CurrentBuffer)
        free(CurrentBuffer);
    return res;
}

VOID
ShowHelpPopup( VOID )
{
    HANDLE PopupHandle;
    WORD n;

    PopupHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                             FILE_SHARE_WRITE | FILE_SHARE_READ,
                                             NULL,
                                             CONSOLE_TEXTMODE_BUFFER,
                                             NULL
                                           );
    if (PopupHandle == NULL) {
        return;
        }

    SetConsoleActiveScreenBuffer( PopupHandle );

    n = 0;

    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "                Poolmon Help", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " columns:", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Tag is the 4 byte tag given to the pool allocation", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Type is paged or nonp(aged)", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Allocs is count of all alloctions", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) is difference in Allocs column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Frees is count of all frees", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) difference in Frees column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Diff is (Allocs - Frees)", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Bytes is the total bytes consumed in pool", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) difference in Bytes column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Per Alloc is (Bytes / Diff)", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " switches:                                                                     ", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   ? or h - gives this help", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   q - quits", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   p - toggles default pool display between both, paged, and nonpaged", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   e - toggles totals lines on and off", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   l - toggles highlighting of changed lines on and off", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   s - toggles default pool display between system pool and session pool", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   i - asks for a session ID to display pool information about", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   0-9 - displays information about session 0-9 pool", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " sorting switches:", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   t - tag    a - allocations", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   f - frees  d - difference", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   b - bytes  m - per alloc", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (u is the same as b)", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "   ) - toggles sort between primary tag and value in (  )", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " command line switches:", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -i<tag> - list only matching tags", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -x<tag> - list everything except matching tags", FALSE );
    WriteConsoleLine( PopupHandle, n++, "           <tag> can include * and ?", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -peltafdbum) - as listed above", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -s      - starts with information about all sessions pool", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -sN     - starts with information about session N pool", FALSE );
    WriteConsoleLine( PopupHandle, n++, "           (e.g. -s1 for session 1 pool)", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );

    while (TRUE) {
        if (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0 &&
            ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
            InputRecord.EventType == KEY_EVENT &&
            InputRecord.Event.KeyEvent.bKeyDown &&
            InputRecord.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE
           ) {
            break;
        }
    }

    SetConsoleActiveScreenBuffer( OutputHandle );
    CloseHandle( PopupHandle );
    return;
}

ULONG ComputeIndex(PUCHAR tag)
{
    ULONG ind=0;

    if (isdigit(tag[0])) 
    {
        ind = tag[0] - '0'; 
    }
    else
    {
        if (isupper(tag[0])) 
        {
            ind = tag[0]-'A'; 
        }
        //lower case chars will be indexed to this
        else if (islower(tag[0])) 
        {
            ind = (tag[0]-'a');
        }
        else
        {
            ind = INVALID_INDEX;
        }
    }
       return ind;
}


BOOL
StoreTags(PCHAR filename, BOOL fCheckForWildCard)
{
       FILE *tagFile = NULL;
       CHAR line[1024];
       HANDLE hFile = 0;
       DWORD dwSizeLow=0, dwSizeHigh=0;

       hFile = CreateFile( filename,  GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

       // Check for error in CreateFile
       if (hFile == INVALID_HANDLE_VALUE)
       {
              printf("Poolmon: Tag file %s absent or invalid: %d\n", filename, GetLastError());
              return FALSE;
       }

       
       dwSizeLow = GetFileSize(hFile, &dwSizeHigh);

       if (hFile != INVALID_HANDLE_VALUE ) 
       {
            CloseHandle(hFile);
       }
     
       // If we failed ... 
       if (dwSizeLow == INVALID_FILE_SIZE  && (GetLastError() != NO_ERROR))
       { 
              printf("Poolmon: Bad tag file size: %s\n", filename);
              return FALSE;
       }

       if (dwSizeHigh !=0 || dwSizeLow > MAXTAGFILESIZE) {
              printf("Poolmon: Tag file %s too big\n", filename);       
              return FALSE;
       }

     
       if(!(tagFile = fopen(filename, "r")))
       {
              printf("Poolmon: Failed to open tag file %s: %d\n", filename, GetLastError());
              return FALSE;
       }

       while(fgets(line, 1024, tagFile))
       {
              PUCHAR tag = line;
              PUCHAR driver = NULL;
              unsigned int ind,i;
              PTAGNODE pn;
              BOOL fWildCardFound = FALSE;

              line[1023] = '\0';

              // skip initial space.
              while(isspace(*tag)) tag++;

              // skip empty line.
              if(! *tag) continue;

              // skip comments.
              if(_strnicmp(tag, "rem", 3) == 0) continue;

              driver = tag;

              // Find tag end.
              while(*driver != '-' && ! isspace(*driver)) driver++;

              // tag should not be more than 4 chars.
              if(driver - tag > 4 || ! *driver) continue;

              *driver++ = '\0';

              if(!*driver) continue;

              // Find driver start.
              while(*driver == '-' || isspace(*driver)) driver++;
            
              if(! *driver) continue;
        
              // remove ending new lines.
              ind = strlen(driver) - 1;
              while(ind > 0)
              {
                     if(driver[ind] == '\n' || driver[ind] == '\r')
                     {
                            driver[ind] = '\0';
                     }
                     else
                     {
                            break;
                     }
                     ind--;
              }

              if (fCheckForWildCard)
              {
                     for(i=0; i<strlen(tag);i++)
                     {
                            if ((tag[i] == '*') || (tag[i] == '?'))
                            {
                                   ind = ComputeIndex(tag);
                                   if (ind == INVALID_INDEX)
                                   {
                                       goto nextwhile;
                                   }
                                   //This is a wild-card tag
                                   fWildCardFound = TRUE;
                                   pn = WildCardTagMap[ind];
                                   break;
                            }
                     }
              }

              if (!fWildCardFound)
              {
                     ind = HashString(tag) % TAGMAPLEN;
                     pn = TagMap[ind];
              }

              for(;pn; pn = pn->next)
              {
                     //This tag already exists in the list
                     if(strncmp(pn->Tag, tag,4) == 0)
                     {
                            //Not possible to append more than max allowable driver length
                            // +3 accounts for '[', ']' and '\0'
                            if ((strlen(pn->Driver) + strlen(driver) + 3) >= DRIVERNAMELEN) 
                            {
                                   goto nextwhile;
                            }
                            
                            strcat(pn->Driver,"[");
                            strcat(pn->Driver,driver);
                            strcat(pn->Driver,"]");
                            pn->Driver[DRIVERNAMELEN-1]='\0';
                            goto nextwhile;
                     }
              }

              pn = (PTAGNODE)malloc(sizeof(TAGNODE));
              if (!pn) 
              {
                     fclose(tagFile);
                     return FALSE;
              }
              strcpy(pn->Tag, tag);
              strcpy(pn->Driver,"[");
              strncat(pn->Driver, driver,DRIVERNAMELEN-2);
              strcat(pn->Driver,"]");
              pn->Driver[DRIVERNAMELEN-1]='\0';
              if (fWildCardFound)
              {
                     pn->next = WildCardTagMap[ind];
                     WildCardTagMap[ind] = pn;
              }
              else
              {
                    pn->next = TagMap[ind];
                    TagMap[ind] = pn;
              }
    
              nextwhile:
                      continue;
       }

       fclose(tagFile);
       return TRUE;
}

BOOL
BuildTagMap()
/*++
 
Routine Description:
 
    This function builds the tag map using the pooltag file i.e it builds
    a hash table of the tag names and the corresponding driver name.
 
Return Value:
 
    TRUE: If tag map is successfully built
    FALSE: Otherwise
 
--*/

{
    int index;
    BOOL ret=FALSE;
    HANDLE hFile=0;

    TagMap = (PTAGNODE*)malloc(sizeof(PTAGNODE) * TAGMAPLEN);
    if(!TagMap)
        return FALSE;

    for(index = 0; index < TAGMAPLEN; index++)
        TagMap[index] = NULL;

     // Initialize WildCardTagMap
    WildCardTagMap = (PTAGNODE*)malloc(sizeof(PTAGNODE) * WILDCARDTAGMAPLEN);
    if(!WildCardTagMap)
        return FALSE;

    for(index = 0; index < WILDCARDTAGMAPLEN; index++)
        WildCardTagMap[index] = NULL;

    #if !defined (_WIN64)
    // If local tag file is not specified, then we need to build one
    if (fLocalTag)
    {
           if (!pchLocalTagFile)
           {
              //Need to see if there is a localtag.txt file in the current directory
              hFile = CreateFile( LOCALTAGFILE,  GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

              // Check for error in CreateFile
              if (hFile == INVALID_HANDLE_VALUE) 
              {
                     if (GetLastError() == ERROR_FILE_NOT_FOUND)
                     {
                            printf("Poolmon: No %s in current directory\n", LOCALTAGFILE);
                            if (!MakeLocalTagFile())
                            {
                                   printf("Poolmon: Unable to create local tag file\n");
                                   //Need not build TagMap in this case
                                   fLocalTag=FALSE;
                            }
                     }
                     else fLocalTag = FALSE;
              }
              else CloseHandle(hFile);
              pchLocalTagFile = LOCALTAGFILE;
           }
    }
    #endif
    

    // If pool tag file is not specified, we need to look for "pooltag.txt" in the current directory
    if (fPoolTag)
    {
           if (!pchPoolTagFile)
           {
                  //Need to see if there is a pooltag.txt file in the current directory
              hFile = CreateFile( POOLTAGFILE,  GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

              // Check for error in CreateFile
              if (hFile == INVALID_HANDLE_VALUE)
              {
                     printf("Poolmon: Unable to open/No %s in current directory\n", POOLTAGFILE);
                     //This is an error and we need not build Tag Map
                     fPoolTag=FALSE;
              }
              else
              {
                     CloseHandle(hFile);
                     pchPoolTagFile=POOLTAGFILE;
              }
           }
    }

     if (fLocalTag) 
            //If StoreTags returned FALSE, we need not display local tags, hence store result in fLocalTag
            //We need not check for wild-cards in the localtag.txt file
            fLocalTag = StoreTags(pchLocalTagFile, FALSE);
     
     if (fPoolTag)  
            fPoolTag = StoreTags(pchPoolTagFile, TRUE);
     
     return TRUE;
}

VOID
FreeTagMap()
{
    PTAGNODE pn1, pn2;
    int i;

    if(!TagMap)
        return;
    for(i = 0; i < TAGMAPLEN; i++)
    {
        pn1 = TagMap[i];
        TagMap[i] = NULL;
        while(pn1)
        {
            pn2 = pn1;
            pn1 = pn1->next;
            free((void*)pn2);
        }
    }
    free((void*)TagMap);

    //Free WildCardTagMap
    if(!WildCardTagMap)
        return;
    for(i = 0; i < WILDCARDTAGMAPLEN; i++)
    {
        pn1 = WildCardTagMap[i];
        WildCardTagMap[i] = NULL;
        while(pn1)
        {
            pn2 = pn1;
            pn1 = pn1->next;
            free((void*)pn2);
        }
    }
    free((void*)WildCardTagMap);

}

ULONG
MatchPoolTag(
    PSTR Tag,
    PSTR TagToMatch
    )
{
    BOOL Partial = FALSE;
    ULONG CharMatched = 0;
    ULONG i;
    
    for (i = 0; i<strlen(TagToMatch); i++)
    {
         // If pooltag.txt tag is smaller, match cannot happen
         if (Tag[i] == '\0') return FALSE;
         
        switch (Tag[i])
        {
        case '*':
            // Match the remainder
            return CharMatched;
        case '?':
            Partial = TRUE;
            break;
        default:
            // Cannot match a non widcard character after '?'
            if (!Partial && (Tag[i] == TagToMatch[i]))
            {
                CharMatched=i+1;
            } else
            {
                return FALSE;
            }
        }
    }
    if ((strlen(TagToMatch) < strlen(Tag)))
    {
        //* can match 0 or more chars
        if (Tag[i] == '*')
        {
        return CharMatched;
        }
    }
    if (strlen(TagToMatch) == strlen(Tag))
    {
        return CharMatched;
    }
    return FALSE;
}

PTAGNODE 
LookupTag(
    PUCHAR tag)
{
    PTAGNODE pn1, pnMatch=NULL;
    int ind;
    UCHAR szTag[5];
    int i;
    ULONG Match, PrevMatch;


    //Remove leading spaces in tag
    for(i=0;i<4;i++)
    {
        if (!isspace(tag[i]))
        {
            strncpy(szTag,tag+i,4-i);
            szTag[4-i]='\0';
            break;
        }
    }
    
    szTag[4] = '\0';
    for(i = 1; i < 4; i++)
    {
        if(isspace(szTag[i]))
        {
            szTag[i] = '\0';
            break;
        }
    }

    ind = HashString(szTag) % TAGMAPLEN;


    // Tags are case-sensitive i.e. "abcd" and "ABCD" are different tags
    if (TagMap)
    {
    pn1 = TagMap[ind];
    while(pn1)
    {
        if(strcmp(szTag, pn1->Tag) == 0)
               return pn1;
        pn1 = pn1->next;
    }
    }

    //We need to look for wild-card tag matches now
    ind = ComputeIndex(szTag);
    if (ind == INVALID_INDEX) return NULL;
    if (WildCardTagMap)
    {
        pn1 = WildCardTagMap[ind];
        PrevMatch = 0;
        while (pn1)
        {
            Match = MatchPoolTag(pn1->Tag, szTag);
            //We have found a better match
            if (Match > PrevMatch)
            {
                PrevMatch = Match;
                pnMatch=pn1;
            }
            pn1 = pn1->next;
        }
    }
    
    return pnMatch;
}

VOID
ShowSessionPopup( VOID )
{
    HANDLE PopupHandle;
    WORD n;
    COORD Coord;
    BOOL Cancel = FALSE;
    ULONG SessionId = 0;
    ULONG NumberOfDigits = 0;
    CHAR CurrentChar;
    CHAR SpaceChar = ' ';
    DWORD NumWrittenChars;
    CHAR PromptText[] = "Session ID (just press ENTER for all sessions):";

    PopupHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                             FILE_SHARE_WRITE | FILE_SHARE_READ,
                                             NULL,
                                             CONSOLE_TEXTMODE_BUFFER,
                                             NULL
                                           );
    if (PopupHandle == NULL) {
        return;
        }

    SetConsoleActiveScreenBuffer( PopupHandle );

    n = 0;

    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, PromptText, FALSE );
    WriteConsoleLine( PopupHandle, n, NULL, FALSE );

    Coord.X = (SHORT)strlen (PromptText) + 1;
    Coord.Y = n - 1;
    SetConsoleCursorPosition( PopupHandle, Coord );

    while (TRUE) {
        if (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0 &&
            ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
            InputRecord.EventType == KEY_EVENT &&
            InputRecord.Event.KeyEvent.bKeyDown
           ) {
            
            if (InputRecord.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE) {
                
                Cancel = TRUE;
                break;
            }
            else if (InputRecord.Event.KeyEvent.wVirtualKeyCode == VK_RETURN) {

                break;
            } 
            else if (InputRecord.Event.KeyEvent.wVirtualKeyCode == VK_BACK) {

                if (NumberOfDigits > 0) {
                    
                    NumberOfDigits -= 1;

                    SessionId = SessionId / 10;
                    
                    Coord.X -= 1;
                    SetConsoleCursorPosition( PopupHandle, Coord );

                    WriteConsoleOutputCharacter (PopupHandle, &SpaceChar, 1, Coord, &NumWrittenChars);
                }
            }
            else {

                if (NumberOfDigits < 6) {

                    CurrentChar = (CHAR)toupper (InputRecord.Event.KeyEvent.uChar.AsciiChar);

                    if (CurrentChar >= '0' && CurrentChar <= '9') {

                        NumberOfDigits += 1;

                        SessionId = SessionId * 10 + (CurrentChar - '0');

                        WriteConsoleOutputCharacter (PopupHandle, &CurrentChar, 1, Coord, &NumWrittenChars);

                        Coord.X += 1;
                        SetConsoleCursorPosition( PopupHandle, Coord );
                    }
                }
            }
        }
    }

    if (Cancel == FALSE) {

        DisplaySessionPool = TRUE;

        if (NumberOfDigits == 0) {

            DisplaySessionId = (ULONG)-1;
        }
        else {

            DisplaySessionId = SessionId;
        }
    }

    SetConsoleActiveScreenBuffer( OutputHandle );
    CloseHandle( PopupHandle );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perftool\inc\teststat.h ===
/***************************************

This is the header file for the statistics package

***************************************/

#if (defined (NTNAT) || defined (OS2SS))
#define FAR
#define PASCAL
#define far
#define double ULONG	     /* this needs to be changed when flt support
                               becomes available under NT */
#define BOOL BOOLEAN
#endif

#if (defined (WIN16) || defined (WIN32) || defined (MIPS) || defined (DOS))
    #define SHORT short
    #define ULONG DWORD
    #define USHORT WORD
    #define PSHORT short *
    #define PSZ	  LPSTR
    #define PUSHORT USHORT far *
    #define PULONG ULONG far *
    #define FAR far
#endif

#if (defined (WIN16))
    #define PLONG LPSTR
#endif

#ifdef OS2386
    #define far
#endif

#define STAT_ERROR_ILLEGAL_MIN_ITER   1
#define STAT_ERROR_ILLEGAL_MAX_ITER   2
#define STAT_ERROR_ALLOC_FAILED       3
#define STAT_ERROR_ILLEGAL_BOUNDS     4

#define DEFAULT_OUTLIER_FACTOR        4

USHORT FAR PASCAL TestStatOpen     (USHORT, USHORT);
VOID   FAR PASCAL TestStatInit     (VOID);
BOOL   FAR PASCAL TestStatConverge (ULONG);
VOID   FAR PASCAL TestStatValues   (PSZ, USHORT, PULONG far *, PUSHORT, 
                                       PUSHORT); 
VOID   FAR PASCAL TestStatClose    (VOID);
ULONG  FAR PASCAL TestStatRand     (ULONG, ULONG);
double FAR PASCAL TestStatUniRand  (VOID);
USHORT  FAR PASCAL TestStatShortRand  (VOID);
LONG   FAR PASCAL TestStatNormDist (ULONG, USHORT);
LONG   FAR PASCAL TestStatOldDist (ULONG, USHORT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perftool\inc\fastctrs.h ===
/* * * * * * * * * *   I N C L U D E   F I L E S * * * * * * * * * * * * */


#ifndef NT_INCLUDED //Include definitions for other developers

#define IN 
#define OUT 

#define TIME LARGE_INTEGER
#define _TIME _LARGE_INTEGER
#define PTIME PLARGE_INTEGER
#define LowTime LowPart
#define HighTime HighPart 


// begin_winnt begin_ntminiport begin_ntndis

//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#if (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;


typedef LONGLONG USN;
typedef char *PSZ ;
typedef unsigned char  UCHAR ;
typedef unsigned short USHORT ;
typedef unsigned long  ULONG  ;
typedef char  CCHAR ;
typedef char *PCHAR ;
typedef ULONG KAFFINITY ;


typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation,
    SystemProcessorInformation,             // obsolete...delete
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation,
    SystemLocksInformation,
    SystemStackTraceInformation,
    SystemPagedPoolInformation,
    SystemNonPagedPoolInformation,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPageFileInformation,
    SystemVdmInstemulInformation,
    SystemVdmBopInformation,
    SystemFileCacheInformation,
    SystemPoolTagInformation,
    SystemInterruptInformation,
    SystemDpcBehaviorInformation,
    SystemSpare3Information,
    SystemLoadGdiDriverInformation,
    SystemUnloadGdiDriverInformation,
    SystemTimeAdjustmentInformation,
    SystemSpare6Information,
    SystemNextEventIdInformation,
    SystemEventIdsInformation,
    SystemCrashDumpInformation,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemExtendServiceTableInformation,
    SystemPrioritySeperation,
    SystemPlugPlayBusInformation,
    SystemDockInformation,
    SystemPowerInformation,
    SystemProcessorSpeedInformation
} SYSTEM_INFORMATION_CLASS;

//
// System Information Structures.
//


typedef struct _SYSTEM_BASIC_INFORMATION {
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG MinimumUserModeAddress;
    ULONG MaximumUserModeAddress;
    KAFFINITY ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_INFORMATION {
    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;
    USHORT Reserved;
    ULONG ProcessorFeatureBits;
} SYSTEM_PROCESSOR_INFORMATION, *PSYSTEM_PROCESSOR_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
    LARGE_INTEGER IdleTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER DpcTime;          // DEVL only
    LARGE_INTEGER InterruptTime;    // DEVL only
    ULONG InterruptCount;
} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION, *PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;


typedef struct _SYSTEM_PERFORMANCE_INFORMATION {
    LARGE_INTEGER IdleProcessTime;
    LARGE_INTEGER IoReadTransferCount;
    LARGE_INTEGER IoWriteTransferCount;
    LARGE_INTEGER IoOtherTransferCount;
    ULONG IoReadOperationCount;
    ULONG IoWriteOperationCount;
    ULONG IoOtherOperationCount;
    ULONG AvailablePages;
    ULONG CommittedPages;
    ULONG CommitLimit;
    ULONG PeakCommitment;
    ULONG PageFaultCount;
    ULONG CopyOnWriteCount;
    ULONG TransitionCount;
    ULONG CacheTransitionCount;
    ULONG DemandZeroCount;
    ULONG PageReadCount;
    ULONG PageReadIoCount;
    ULONG CacheReadCount;
    ULONG CacheIoCount;
    ULONG DirtyPagesWriteCount;
    ULONG DirtyWriteIoCount;
    ULONG MappedPagesWriteCount;
    ULONG MappedWriteIoCount;
    ULONG PagedPoolPages;
    ULONG NonPagedPoolPages;
    ULONG PagedPoolAllocs;
    ULONG PagedPoolFrees;
    ULONG NonPagedPoolAllocs;
    ULONG NonPagedPoolFrees;
    ULONG FreeSystemPtes;
    ULONG ResidentSystemCodePage;
    ULONG TotalSystemDriverPages;
    ULONG TotalSystemCodePages;
    ULONG Spare0Count;
    ULONG Spare1Count;
    ULONG Spare3Count;
    ULONG ResidentSystemCachePage;
    ULONG ResidentPagedPoolPage;
    ULONG ResidentSystemDriverPage;
    ULONG CcFastReadNoWait;
    ULONG CcFastReadWait;
    ULONG CcFastReadResourceMiss;
    ULONG CcFastReadNotPossible;
    ULONG CcFastMdlReadNoWait;
    ULONG CcFastMdlReadWait;
    ULONG CcFastMdlReadResourceMiss;
    ULONG CcFastMdlReadNotPossible;
    ULONG CcMapDataNoWait;
    ULONG CcMapDataWait;
    ULONG CcMapDataNoWaitMiss;
    ULONG CcMapDataWaitMiss;
    ULONG CcPinMappedDataCount;
    ULONG CcPinReadNoWait;
    ULONG CcPinReadWait;
    ULONG CcPinReadNoWaitMiss;
    ULONG CcPinReadWaitMiss;
    ULONG CcCopyReadNoWait;
    ULONG CcCopyReadWait;
    ULONG CcCopyReadNoWaitMiss;
    ULONG CcCopyReadWaitMiss;
    ULONG CcMdlReadNoWait;
    ULONG CcMdlReadWait;
    ULONG CcMdlReadNoWaitMiss;
    ULONG CcMdlReadWaitMiss;
    ULONG CcReadAheadIos;
    ULONG CcLazyWriteIos;
    ULONG CcLazyWritePages;
    ULONG CcDataFlushes;
    ULONG CcDataPages;
    ULONG ContextSwitches;
    ULONG FirstLevelTbFills;
    ULONG SecondLevelTbFills;
    ULONG SystemCalls;
} SYSTEM_PERFORMANCE_INFORMATION, *PSYSTEM_PERFORMANCE_INFORMATION;

#endif // NT_INCLUDED 

typedef struct _PERFINFO {
    SYSTEM_PERFORMANCE_INFORMATION SysPerfInfo;
	 //
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION SysProcPerfInfo;
	 //
    SYSTEM_PROCESSOR_INFORMATION SysProcInfo;
	 //
    SYSTEM_BASIC_INFORMATION SysBasicInfo;
	 //
    // Other info.
	 //
    PCHAR Title;
    ULONG Iterations;
    short hTimer;
} PERFINFO;
typedef PERFINFO *PPERFINFO;

VOID
FinishBenchmark (
	IN PPERFINFO PerfInfo
);

VOID
StartBenchmark (
	IN PCHAR Title,
	IN ULONG Iterations,
	IN PPERFINFO PerfInfo,
	IN PSZ p5Cntr1,			// 1st Pentium counter - See comments below
	IN PSZ p5Cntr2				// 2nd Pentium counter - See comments below
);
//
// P5Counters:
//		Use the name in the first column when calling StartBenchmark
//
//    "rdata",        "Data Read",                        0x00,
//    "wdata",        "Data Write",                       0x01,
//    "dtlbmiss",     "Data TLB miss",                    0x02,
//    "rdmiss",       "Data Read miss",                   0x03,
//    "wdmiss",       "Data Write miss",                  0x04,
//    "meline",       "Write hit to M/E line",            0x05,
//    "dwb",          "Data cache line WB",               0x06,
//    "dsnoop",       "Data cache snoops",                0x07,
//    "dsnoophit",    "Data cache snoop hits",            0x08,
//    "mempipe",      "Memory accesses in pipes",         0x09,
//    "bankconf",     "Bank conflicts",                   0x0a,
//    "misalign",     "Misadligned data ref",             0x0b,
//    "iread",        "Code Read",                        0x0c,
//    "itldmiss",     "Code TLB miss",                    0x0d,
//    "imiss",        "Code cache miss",                  0x0e,
//    "segloads",     "Segment loads",                    0x0f,
//    "segcache",     "Segment cache accesses",           0x10,
//    "segcachehit",  "Segment cache hits",               0x11,
//    "branch",       "Branches",                         0x12,
//    "btbhit",       "BTB hits",                         0x13,
//    "takenbranck",  "Taken branch or BTB hits",         0x14,
//    "pipeflush",    "Pipeline flushes",                 0x15,
//    "iexec",        "Instructions executed",            0x16,
//    "iexecv",       "Inst exec in vpipe",               0x17,
//    "busutil",      "Bus utilization (clks)",           0x18,
//    "wpipestall",   "Pipe stalled write (clks)",        0x19,
//    "rpipestall",   "Pipe stalled read (clks)",         0x1a,
//    "stallEWBE",    "Stalled while EWBE#",              0x1b,
//    "lock",         "Locked bus cycle",                 0x1c,
//    "io",           "IO r/w cycle",                     0x1d,
//    "noncachemem",  "non-cached memory ref",            0x1e,
//    "agi",          "Pipe stalled AGI",                 0x1f,
//    "flops",        "FLOPs",                            0x22,
//    "dr0",          "Debug Register 0",                 0x23,
//    "dr1",          "Debug Register 1",                 0x24,
//    "dr2",          "Debug Register 2",                 0x25,
//    "dr3",          "Debug Register 3",                 0x26,
//    "int",          "Interrupts",                       0x27,
//    "rwdata",       "Data R/W",                         0x28,
//    "rwdatamiss",   "Data R/W miss",                    0x29,
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perfmtr\poolfind.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    poolfind.cpp

Abstract:

    This module contains the code to find the tags in a driver binary

Author:

    Andrew Edwards (andred) Oct-2001
    
Revision History:

    Swetha Narayanaswamy (swethan) 19-Mar-2002

--*/
#if !defined (_WIN64)
#pragma warning(disable: 4514)

#include "windows.h"
#include "msdis.h"

#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <delayimp.h>

#define TAGSIZE 5
#define DRIVERDIR "\\drivers\\"
#define DRIVERFILEEXT "*.sys"
#define MAXPATH 1024

int __cdecl main(int argc, char** argv);
void ParseImageFile(PTCHAR szImage);



CHAR localTagFile[MAXPATH] = "localtag.txt";
int cSystemDirectory = 0;

//Used to form list of tags used by the same driver
typedef struct _TAGLIST{
    TCHAR Tag[TAGSIZE];
    struct _TAGLIST *next;
} TAGLIST, *PTAGLIST;


BOOL 
GetTagFromCall ( 
const BYTE *pbCall, // pointer to call instruction
PTCHAR ptchTag,  //out param: pointer to tag
DIS *pDis,
int tagLocation)   //location of tag in the parameter list

/*++
 
Routine Description:
 
    This function disassembles the memory allocation function call. 
    It finds the third push and determines the tag and 
    places it in the ptchTag return parameter
 
Return Value:
 
    FALSE: If unable to find tag
    TRUE: Otherwise
 
--*/

{
       // try to backup 3 pushes:
       // FF /6 + modrm etc
       // 50-5F
       // 6A <8imm>
       // 68 <32imm>

       int cbMax = 200;

       const BYTE *pb = pbCall;

       const BYTE *pTag = NULL;

       if ((ptchTag == NULL) || (pbCall == NULL) || (pDis == NULL)) return FALSE;
       
       _tcscpy(ptchTag,"");
       
       while (cbMax--)
       {
              pb--;

              if (pb[0] == 0x68)
              {
                     // disassemble forward 
                     const BYTE *pbInst = pb;
                     size_t cb = 1;
                     int cPush = 0;

                     while (cb && pbInst < pbCall)
                     {
                            cb = pDis->CbDisassemble( (DWORD)pbInst, 
                                                            pbInst, pbCall - pbInst);
                        
                            if ( (pbInst[0] == 0xFF) && 
                                   ((pbInst[1] & 0x38) == 0x30))
                            {
                                   // this looks like a push <r/m>
                                   cPush++;
                            }
                            else if ((pbInst[0] & 0xF0) == 0x50)
                            {
                                   // this looks like a push <reg>
                                   cPush++;
                            }
                            else if (pbInst[0] == 0x6A)
                            {
                                   // this looks like a push <byte>
                                   cPush++;
                            }
                            else if (pbInst[0] == 0x68)
                            {
                                   // this looks like a push <dword>
                                   cPush++;
                            }
                            pbInst += cb;
                     }
       
                     if (cPush == tagLocation &&     pbInst == pbCall)
                     {
                            _sntprintf(ptchTag,5,"%c%c%c%c", 
                                                                pb[1],pb[2],pb[3],( 0x7f &pb[4]));
                            return TRUE;
                     }
              }
       }
       return FALSE;
}

BOOL 
FindTags( 
const BYTE *pb,  
DWORD addr,
PTAGLIST tagList,   // out param: List of tags to append the new tags to
DIS *pDis,
int tagLocation)           // tag location

/*++
 
Routine Description:
 
    This function reads the bytes in the instruction and looks for 
    indirect/direct calls. The tag is appended to the tagList parameter
 
Return Value:
 
    FALSE: If there is an exception or lack of memory
    TRUE: Otherwise
 
--*/

{

       TCHAR tag[TAGSIZE];
       BOOL done = FALSE;
       PTAGLIST tempTagNode=NULL, prevTagNode=NULL, newTagNode=NULL;

       if ((pb==NULL) || (tagList == NULL) || (pDis == NULL)) return FALSE;
       
       // Get the raw bytes and size of the image
      try
      {
              for(;;)
              {
                     done = FALSE;
                     
                     if (pb[0] == 0xFF && pb[1] == 0x15)
                     {
                            // Indirect call
                            pb += 2;
                            if (*(DWORD *)pb == (DWORD)addr)
                            {
                                   // Found a call
                                   if ((GetTagFromCall(pb-2,tag,pDis, tagLocation)) == FALSE) 
                                   {
                                          pb++;
                                          continue;
                                   }
                                   tempTagNode = prevTagNode = tagList;

                                   while (tempTagNode != NULL)
                                   {
                                          if ((_tcscmp(tempTagNode->Tag,"")) == 0) 
                                          {
                                                 // Insert here
                                                 _tcsncpy(tempTagNode->Tag, tag, TAGSIZE);
                                                 done = TRUE;
                                                 break;
                                          }
                                          else if (!(memcmp(tempTagNode->Tag,tag,TAGSIZE))) 
                                          {
                                                 //Tag already exists in list
                                                 done = TRUE;
                                                 break;
                                          }
                                          prevTagNode = tempTagNode;
                                          tempTagNode = tempTagNode->next;
                                   }
                                   
                                   if (!done )
                                   {
                                          newTagNode = (PTAGLIST)malloc(sizeof(TAGLIST));
                                          if (!newTagNode)  
                                          {
                                                 printf("Poolmon: Insufficient memory: %d\n", GetLastError());
                                                 return FALSE;
                                          }

                                          //There is at least one node allocated so prevTagNode 
                                          //will never be NULL
                                          prevTagNode->next = newTagNode;
                                          // Insert here
                                          _tcsncpy(newTagNode->Tag, tag, TAGSIZE);
                                                                             
                                          newTagNode->next = NULL;
                                   }                                    
                            }
                     }

                     pb++;
              }

       }
       catch (...)
       {
              return FALSE;
       }
       return TRUE;
}

unsigned RvaToPtr(unsigned rva, IMAGE_NT_HEADERS *pNtHeader)
{
   int iSect = 0;
   for (PIMAGE_SECTION_HEADER pSect = IMAGE_FIRST_SECTION(pNtHeader); iSect < pNtHeader->FileHeader.NumberOfSections; pSect++, iSect++)
   {
      if (rva >= pSect->VirtualAddress &&
          rva <  pSect->VirtualAddress + pSect->SizeOfRawData)
      {
         rva -= pSect->VirtualAddress;
         rva += pSect->PointerToRawData;
         return rva;
      }
   }

   //error case
   return 0;
}

void 
ParseImageFile(
PTCHAR szImage, PTAGLIST tagList)  // Image file name
/*++
 
Routine Description:
 
    This function opens the binary driver image file, reads it and looks for
    a memory allocation call
 
Return Value:
 
    None 
--*/

{
       DIS *pDis = NULL;

       
       if ((tagList == NULL) || (szImage == NULL) ) return;
       
       // read szImage into memory
       FILE *pf = NULL;
       pf = _tfopen(szImage, "rb");
       if (!pf) return;
   
       if ((fseek(pf, 0, SEEK_END )) != 0) goto exitParseImageFile;
   
       size_t cbMax = 0;
       cbMax = ftell(pf);
       if (cbMax == -1) goto exitParseImageFile;

       if ((fseek(pf, 0, SEEK_SET )) != 0) goto exitParseImageFile;
   
       BYTE *pbImage = NULL;
       pbImage = new BYTE[cbMax];
       if (!pbImage) goto exitParseImageFile;
   
       if ((fread( pbImage, cbMax, 1, pf )) <= 0) goto exitParseImageFile;

       // find the import table
       IMAGE_DOS_HEADER *phdr = (IMAGE_DOS_HEADER *)pbImage;

       if (phdr->e_magic != IMAGE_DOS_SIGNATURE)
       {
              _tprintf("Poolmon: Bad image file %s\n", szImage);
              goto exitParseImageFile;
       }

       if (cbMax < offsetof(IMAGE_DOS_HEADER, e_lfanew) + 
                         sizeof(phdr->e_lfanew) ||phdr->e_lfanew == 0)
       {
              _tprintf("Poolmon: Bad image file %s\n", szImage);
              goto exitParseImageFile;
       }

       IMAGE_NT_HEADERS *pNtHeader = 
                                          (IMAGE_NT_HEADERS *) (pbImage + phdr->e_lfanew);
       if (pNtHeader == NULL) goto exitParseImageFile;
   
       if (pNtHeader->Signature != IMAGE_NT_SIGNATURE ||
       pNtHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)
       {
              _tprintf("Poolmon: Bad image file %s\n", szImage);
              goto exitParseImageFile;
       }

       // Find import tables
       IMAGE_DATA_DIRECTORY *pImports = 
         (IMAGE_DATA_DIRECTORY *)&pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
       
       if (pImports == NULL) goto exitParseImageFile;
   
       unsigned rva = pImports->VirtualAddress;
       // need to adjust from rva to pointer accounting for section alignment
       rva = RvaToPtr(rva, pNtHeader);
       if (0 == rva) {
              goto exitParseImageFile;
       }

       IMAGE_IMPORT_DESCRIPTOR  *pImportDescr = 
                                              (IMAGE_IMPORT_DESCRIPTOR *) (pbImage+rva);
       
       if (NULL == pImportDescr) 
       {
              goto exitParseImageFile;
       }

       //msdis130.dll depends on msvcr70.dll and msvcp70.dll
       //Try a loadlibrary on these 2 libraries, and then proceed to delayload msdis130.dll

       #pragma prefast(suppress:321, "user guide:Programmers developing on the .NET server can ignore this warning by filtering it out.")
       if ((!LoadLibrary("MSVCR70.DLL")) || (!LoadLibrary("MSVCP70.DLL")))
       {
              printf("Unable to load msvcr70.dll/msvcp70.dll, cannot create local tag file\n");
              if (pf) fclose(pf);
              if (pbImage) delete[](pbImage);
              exit(-1);
       }
       
       try {
              pDis = DIS::PdisNew( DIS::distX86 );
       }
       catch (...) {
       	printf("Poolmon: Unable to load msdis130.dll, cannot create local tag file\n");
              if (pf) fclose(pf);
              if (pbImage) delete[](pbImage);
              exit(-1);
       }

       if (pDis == NULL) 
       {
              goto exitParseImageFile;
       }

       // Find the import for ExAllocatePoolWithTag

       for (;pImportDescr->Name &&pImportDescr->FirstThunk;pImportDescr++)
       {

              if (0 == (rva = RvaToPtr(pImportDescr->FirstThunk, pNtHeader))) {
                  goto exitParseImageFile;
              }
			  IMAGE_THUNK_DATA32 *pIAT = (IMAGE_THUNK_DATA32 *) (pbImage + rva);
              if (pIAT == NULL) goto exitParseImageFile;
      
              IMAGE_THUNK_DATA32 *addrIAT = 
                     (IMAGE_THUNK_DATA32 *) (pNtHeader->OptionalHeader.ImageBase + pImportDescr->FirstThunk);       
              if (addrIAT == NULL) goto exitParseImageFile;
      
              if (0 == (rva = RvaToPtr(pImportDescr->Characteristics, pNtHeader))) {
                  goto exitParseImageFile;
              }
              IMAGE_THUNK_DATA32 *pINT= (IMAGE_THUNK_DATA32 *) (pbImage + rva);
			  if (pINT == NULL) goto exitParseImageFile;
      
              for (;pIAT->u1.Ordinal;)      
              {
                     if (IMAGE_SNAP_BY_ORDINAL32(pINT->u1.Ordinal))
                     {
                            // by ordinal?
                     }
                     else       
                     {
                            if (0 == (rva = RvaToPtr((int)pINT->u1.AddressOfData, pNtHeader))) {
                                   goto exitParseImageFile;
                            }
                            IMAGE_IMPORT_BY_NAME* pIIN = (IMAGE_IMPORT_BY_NAME*) (pbImage + rva);
                            if (NULL == pIIN) goto exitParseImageFile;
                            
                            char *name = (char*)pIIN->Name;

                            if (0 == strcmp( name, "ExAllocatePoolWithTag" ))
                            {  
                                   FindTags(pbImage, (DWORD)addrIAT,tagList, pDis,3);
                            } 
                            else  if (0 == strcmp( name, "ExAllocatePoolWithQuotaTag" ))
                            {
                                   FindTags(pbImage, (DWORD)addrIAT,tagList,pDis,3);
                            } 
                            else if (0 == strcmp( name, "ExAllocatePoolWithTagPriority" )) 
                            {
                                   FindTags(pbImage, (DWORD)addrIAT,tagList,pDis,3);
                            }
                            //wrapper functions
                            else if(0 == strcmp(name, "NdisAllocateMemoryWithTag"))
                            {
                                   FindTags(pbImage, (DWORD)addrIAT,tagList,pDis,3);
                            }
                            else if(0 == strcmp(name,"VideoPortAllocatePool"))
                            {
                                   FindTags(pbImage, (DWORD)addrIAT,tagList,pDis,4);
                            }
                            
                     }

                     addrIAT++;
                     pIAT++;
                     pINT++;
              }
       }

      
   
exitParseImageFile:
       if (pf) fclose(pf);
       if (pbImage) delete[](pbImage);
}

extern "C" BOOL MakeLocalTagFile()
/*++
 
Routine Description:
 
    This function finds files one by one in the system drivers directory and call ParseImageFile on the image
 
Return Value:
 
    None 
--*/
{
       WIN32_FIND_DATA FileData; 
       HANDLE hSearch=0; 
       BOOL fFinished = FALSE; 
       TCHAR sysdir[1024];
       PTCHAR filename=NULL;
       TCHAR imageName[MAXPATH] = "";
       PTAGLIST tagList = NULL;
       BOOL ret = TRUE;
       FILE *fpLocalTagFile = NULL;

       cSystemDirectory = GetSystemDirectory(sysdir, 0);
       if(!cSystemDirectory)
       {
              printf("Poolmon: Unable to get system directory: %d\n", GetLastError());
              ret = FALSE;
              goto freeall;
       }

       filename = (PTCHAR)malloc(cSystemDirectory + 
            (_tcslen(DRIVERDIR) + _tcslen(DRIVERFILEEXT) + 1) * sizeof(TCHAR));
       
       if(!filename) 
       {
              ret = FALSE;
              goto freeall;
       }

       GetSystemDirectory(filename, cSystemDirectory + 1);
       _tcscat(filename, DRIVERDIR);
       _tcscat(filename, DRIVERFILEEXT);

       // Search for .sys files
       hSearch = FindFirstFile(filename, &FileData); 
       if (hSearch == INVALID_HANDLE_VALUE) 
       { 
              printf("Poolmon: No .sys files found\n"); 
              ret = FALSE;
              goto freeall;
       } 

       _tcsncpy(imageName, filename,MAXPATH);
       imageName[MAXPATH-1] = '\0';

             
       tagList = (PTAGLIST)malloc(sizeof(TAGLIST));
       if (!tagList) 
       {
              ret = FALSE;
              goto freeall;
       }
       _tcscpy(tagList->Tag,"");
       tagList->next = NULL;

       int cImagePath = cSystemDirectory+ _tcslen(DRIVERDIR) -1;
       
       while (!fFinished) 
       {  
              // Do all the initializations for the next round
              // Remove the previous name
              imageName[cImagePath] = '\0';

              // Initialize existing tagList
              PTAGLIST tempTagNode = tagList;
              while (tempTagNode != NULL) 
              {
                     _tcscpy(tempTagNode->Tag,"");
                     tempTagNode = tempTagNode->next;
              }

              try 
              {
                     _tcsncat(imageName, FileData.cFileName,MAXPATH-cImagePath);
                     ParseImageFile(imageName,tagList);

                     //Remove .sys from szImage
                     imageName[_tcslen(imageName) - 4] = '\0';
              }
              catch(...) 
              {
                      _tprintf("Poolmon: Could not read tags from %s\n", imageName);
              }

              if (!fpLocalTagFile)
		      {
                       printf("Poolmon: Creating %s in current directory......\n", localTagFile);
                       fpLocalTagFile = fopen(localTagFile, "w");
                       if (!fpLocalTagFile) 
                       {
                            ret = FALSE;
                            goto freeall;
                       }
              }

              tempTagNode = tagList;
              while (tempTagNode != NULL)
              {
                      if ((_tcscmp(tempTagNode->Tag,""))) 
                      {
                            _ftprintf(fpLocalTagFile, "%s   -     %s\n", 
                            tempTagNode->Tag,imageName + cSystemDirectory + _tcslen(DRIVERDIR) -1);
                    
                            tempTagNode = tempTagNode->next;
                     }
                     else break;
              }               
              
              if (!FindNextFile(hSearch, &FileData)) 
              {
                     if (GetLastError() == ERROR_NO_MORE_FILES) 
                     { 
                            fFinished = TRUE; 
                     } 
                     else 
                     { 
                            printf("Poolmon: Cannot find next .sys file\n"); 
                     } 
              }
       }


       freeall:
       // Close the search handle. 
       if (hSearch) 
       {
              if (!FindClose(hSearch)) { 
                     printf("Poolmon: Unable to close search handle: %d\n", GetLastError()); 
              } 
       }

       if (filename) free(filename);
       if (fpLocalTagFile) fclose(fpLocalTagFile);
       //Free tagList memory
       PTAGLIST tempTagNode = tagList,prevTagNode = tagList;
       while (tempTagNode != NULL) 
       {
              tempTagNode = tempTagNode->next;
              free(prevTagNode);
              prevTagNode = tempTagNode;
       }

       return ret;

}

FARPROC
WINAPI
PoolmonDLoadErrorHandler (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    )
{
    printf("Poolmon: Unable to load required dlls, cannot create local tag file\n");
    exit(-1);
}

PfnDliHook __pfnDliFailureHook2 = PoolmonDLoadErrorHandler;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perftool\inc\timing.h ===
/* Header file for timer.dll.  Use with timer.c for making the
   dll 
*/

typedef enum {
    KILOSECONDS,
    SECONDS,
    MILLISECONDS,
    MICROSECONDS,
    TENTHMICROSECS,
    NANOSECONDS,
    TIMER_FREE
} _TimerUnits;

#if (defined (WIN16) || defined (WIN32) || defined (NTWIN))
    #define SHORT short
    #define ULONG DWORD
    #define USHORT WORD
    #define PSHORT short *
    #define PSZ	  LPSTR
#endif

#if (defined (WIN16))
    #define PLONG LPSTR
    typedef struct _QWORD {	       
	ULONG	ulLo;
	ULONG	ulHi;
    } QWORD;

    typedef QWORD FAR *PQWORD;
#endif

#if (defined (WIN32) || defined (NTWIN))
#ifdef W32S
    typedef struct _QWORD {
	ULONG	ulLo;
	ULONG	ulHi;
    } QWORD;
#define PQWORD QWORD *
#else
#define PQWORD PLARGE_INTEGER
#endif
#endif

#if (!defined (WIN32) && !defined (NTWIN))
#define OPTIONAL
#endif

#if (defined (OS2SS) || defined (NTNAT) || defined (WIN32) || defined (NTWIN))
#define far
#if (!defined (WIN32) && !defined (NTWIN))
#define FAR
#endif
#endif

#ifdef NTNAT
#define BOOL BOOLEAN
#endif

#ifdef OS2386
#define far
#endif

SHORT FAR PASCAL TimerOpen (SHORT far *, _TimerUnits);
SHORT FAR PASCAL TimerInit (SHORT);
ULONG FAR PASCAL TimerRead (SHORT);
SHORT FAR PASCAL TimerClose (SHORT);
BOOL  FAR PASCAL TimerReport (PSZ, SHORT);
VOID  FAR PASCAL TimerQueryPerformanceCounter (PQWORD, PQWORD);
ULONG FAR PASCAL TimerConvertTicsToUSec (ULONG, ULONG);

#define TIMERERR_NOT_AVAILABLE 1
#define TIMERERR_NO_MORE_HANDLES 2
#define TIMERERR_INVALID_UNITS 3
#define TIMERERR_INVALID_HANDLE 4
#define TIMERERR_OVERFLOW 0xffffffff

typedef struct {
    ULONG ulLo;
    ULONG ulHi;
    _TimerUnits TUnits;
} Timer;

#ifdef WIN16
    #define MAX_TIMERS 500
#else                              
    #define MAX_TIMERS 5000
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perfmtr\top.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    top.c

Abstract:

    This module contains the NT/Win32 Top threads Meter

Author:

    Another Mark Lucovsky (markl) / Lou Perazzoli (loup) production 5-Aug-1991

Revision History:

--*/

#include "perfmtrp.h"
#include <stdlib.h>

#define BUFFER_SIZE 64*1024

#define CPU_THREAD 0
#define CPU_PROCESS 1
#define FAULTS 2
#define WORKING_SET 3
#define CONTEXT_SWITCHES 4
#define SYSTEM_CALLS 5

PUCHAR g_pLargeBuffer1 = NULL;
PUCHAR g_pLargeBuffer2 = NULL;
DWORD g_dwBufSize1;
DWORD g_dwBufSize2;

WCHAR *NoNameFound = L"No Name Found";

UCHAR *StateTable[] = {
    "Initialized",
    "Ready",
    "Running",
    "Standby",
    "Terminated",
    "Wait:",
    "Transition",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *WaitTable[] = {
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "EventPairHigh",
    "EventPairLow",
    "LpcReceive",
    "LpcReply",
    "Spare1",
    "Spare2",
    "Spare3",
    "Spare4",
    "Spare5",
    "Spare6",
    "Spare7",
    "Spare8",
    "Spare9",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *Empty = " ";


PSYSTEM_PROCESS_INFORMATION
FindMatchedProcess (
    IN PSYSTEM_PROCESS_INFORMATION ProcessToMatch,
    IN PUCHAR SystemInfoBuffer,
    IN PULONG Hint
    );

PSYSTEM_THREAD_INFORMATION
FindMatchedThread (
    IN PSYSTEM_THREAD_INFORMATION ThreadToMatch,
    IN PSYSTEM_PROCESS_INFORMATION MatchedProcess
    );

typedef struct _TOPCPU {
    LARGE_INTEGER TotalTime;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_PROCESS_INFORMATION MatchedProcess;
    ULONG Value;
} TOPCPU, *PTOPCPU;

TOPCPU TopCpu[1000];

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{

    NTSTATUS Status;
    int i,j;
    ULONG DelayTimeMsec;
    ULONG DelayTimeTicks;
    COORD dest,cp;
    SMALL_RECT Sm;
    CHAR_INFO ci;
    CONSOLE_SCREEN_BUFFER_INFO sbi;
    KPRIORITY SetBasePriority;
    INPUT_RECORD InputRecord;
    HANDLE ScreenHandle;
    BOOLEAN Active;
    DWORD NumRead;
    SMALL_RECT Window;
    PSYSTEM_THREAD_INFORMATION Thread;
    PSYSTEM_THREAD_INFORMATION MatchedThread;

    PUCHAR PreviousBuffer;
    PUCHAR CurrentBuffer;
    PUCHAR TempBuffer;
    ULONG Hint;
    ULONG Offset1;
    int num;
    int Type;
    ULONG ContextSwitches;
    PSYSTEM_PROCESS_INFORMATION CurProcessInfo;
    PSYSTEM_PROCESS_INFORMATION MatchedProcess;
    LARGE_INTEGER LARGE_ZERO={0,0};
    LARGE_INTEGER Ktime;
    LARGE_INTEGER Utime;
    LARGE_INTEGER TotalTime;
    TIME_FIELDS TimeOut;
    PTOPCPU PTopCpu;

    BOOLEAN bToggle = TRUE;
    PDWORD pdwBufSize = NULL;

    NTSTATUS status;

    SetBasePriority = (KPRIORITY) 12;

    status = NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessBasePriority,
        (PVOID) &SetBasePriority,
        sizeof(SetBasePriority)
        );
    if (!NT_SUCCESS(status)) {
       printf("Cannot set process priority\n");
       return 0;
    }

    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE),&sbi);

    DelayTimeMsec = 2500;
    DelayTimeTicks = DelayTimeMsec * 10000;

    Window.Left = 0;
    Window.Top = 0;
    Window.Right = 79;
    Window.Bottom = 23;

    dest.X = 0;
    dest.Y = 23;

    ci.Char.AsciiChar = ' ';
    ci.Attributes = sbi.wAttributes;

    SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                         TRUE,
                         &Window
                        );

    cp.X = 0;
    cp.Y = 0;

    Sm.Left      = 0;
    Sm.Top       = 0;
    Sm.Right     = 79;
    Sm.Bottom    = 22;

    ScrollConsoleScreenBuffer(
        GetStdHandle(STD_OUTPUT_HANDLE),
        &Sm,
        NULL,
        dest,
        &ci
        );

    SetConsoleCursorPosition(
        GetStdHandle(STD_OUTPUT_HANDLE),
        cp
        );


    printf( "  %%   Pid  Tid  Pri      Key    Start Address  ImageName\n");
    printf( "___________________________________________________________________\n");

    cp.X = 0;
    cp.Y = 2;

    Sm.Left      = 0;
    Sm.Top       = 2;
    Sm.Right     = 79;
    Sm.Bottom    = 22;

    ScreenHandle = GetStdHandle (STD_INPUT_HANDLE);

    // allocate space for the buffer
    
    g_dwBufSize1 = BUFFER_SIZE;
    g_dwBufSize2 = BUFFER_SIZE;

    g_pLargeBuffer1 = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize1 );

    if( g_pLargeBuffer1 == NULL )
    {
        return 0;
    }

    g_pLargeBuffer2 = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize2 );

    if( g_pLargeBuffer2 == NULL )
    {
        return 0;
    }




retry0:


    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                g_pLargeBuffer1,
                g_dwBufSize1,
                NULL
                );

    if( Status == STATUS_INFO_LENGTH_MISMATCH )
    {
        g_dwBufSize1 *= 2;

        if( g_pLargeBuffer1 != NULL )
        {
            free( g_pLargeBuffer1 );
        }

        g_pLargeBuffer1 = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize1 );

        if( g_pLargeBuffer1 == NULL )
        {
            return 0;
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        printf("Query Failed %lx\n",Status);
        goto retry0;
    }

    Sleep(DelayTimeMsec);

retry01:

    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessBasePriority,
        (PVOID) &SetBasePriority,
        sizeof(SetBasePriority)
        );

    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                g_pLargeBuffer2,
                g_dwBufSize2,
                NULL
                );
    
    if( Status == STATUS_INFO_LENGTH_MISMATCH )
    {
        g_dwBufSize2 *= 2;

        if( g_pLargeBuffer2 != NULL )
        {
            free( g_pLargeBuffer2 );
        }

        g_pLargeBuffer2 = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize2 );

        if( g_pLargeBuffer2 == NULL )
        {
            if( g_pLargeBuffer1 != NULL )
            {
                free( g_pLargeBuffer1 );
            }

            return 0;
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        printf("Query Failed %lx\n",Status);
        goto retry01;
    }

    PreviousBuffer = &g_pLargeBuffer1[0];
    CurrentBuffer = &g_pLargeBuffer2[0];

    Active = TRUE;
    Type = CPU_PROCESS;

    while(TRUE) {
waitkey:
        while (PeekConsoleInput (ScreenHandle, &InputRecord, 1, &NumRead) && NumRead != 0) {
            if (!ReadConsoleInput (ScreenHandle, &InputRecord, 1, &NumRead)) {
                break;
            }
            if (InputRecord.EventType == KEY_EVENT) {

                switch (InputRecord.Event.KeyEvent.uChar.AsciiChar) {

                    case 'q':
                    case 'Q':
                        {
                            if( CurrentBuffer != NULL )
                            {
                                free( CurrentBuffer );
                            }

                            if( PreviousBuffer != NULL )
                            {
                                free( PreviousBuffer );
                            }
    
                            ExitProcess(0);
                        }
                        break;

                    case 'p':
                    case 'P':
                        Active = FALSE;
                        break;

                    case 'c':
                    case 'C':
                        Type = CPU_PROCESS;
                        break;

                    case 'f':
                    case 'F':
                        Type = FAULTS;
                        break;

                    case 's':
                    case 'S':
                        Type = CONTEXT_SWITCHES;
                        break;

                    case 't':
                    case 'T':
                        Type = CPU_THREAD;
                        break;

                    case 'w':
                    case 'W':
                        Type = WORKING_SET;
                        break;

                    default:
                        Active = TRUE;
                        break;
                    }
                }
            }
        if ( !Active ) {
            goto waitkey;
            }
        ScrollConsoleScreenBuffer(
            GetStdHandle(STD_OUTPUT_HANDLE),
            &Sm,
            NULL,
            dest,
            &ci
            );

        SetConsoleCursorPosition(
            GetStdHandle(STD_OUTPUT_HANDLE),
            cp
            );


        //
        // Calculate top CPU users and display information.
        //

        //
        // Cross check previous process/thread info against current
        // process/thread info.
        //

        Offset1 = 0;
        num = 0;
        Hint = 0;
        TotalTime = LARGE_ZERO;

        while (TRUE) {

            if (num >= sizeof(TopCpu) / sizeof(TopCpu[0])) {
               break;
            }
            CurProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&CurrentBuffer[Offset1];

            //
            // Find the corresponding process in the previous array.
            //

            MatchedProcess = FindMatchedProcess (CurProcessInfo,
                                                 PreviousBuffer,
                                                 &Hint);
            switch (Type) {
                case CPU_PROCESS:
                case CPU_THREAD:

                    if (MatchedProcess == NULL) {
                        TopCpu[num].TotalTime = Ktime;
                        TopCpu[num].TotalTime.QuadPart =
                                            TopCpu[num].TotalTime.QuadPart +
                                                    Utime.QuadPart;
                        TotalTime.QuadPart = TotalTime.QuadPart +
                                                 TopCpu[num].TotalTime.QuadPart;
                        TopCpu[num].ProcessInfo = CurProcessInfo;
                        TopCpu[num].MatchedProcess = NULL;
                        num += 1;
                    } else {
                        Ktime.QuadPart = CurProcessInfo->KernelTime.QuadPart -
                                              MatchedProcess->KernelTime.QuadPart;
                        Utime.QuadPart = CurProcessInfo->UserTime.QuadPart -
                                                          MatchedProcess->UserTime.QuadPart;

                        if ((Ktime.QuadPart != 0) ||
                            (Utime.QuadPart != 0)) {
                            TopCpu[num].TotalTime = Ktime;
                            TopCpu[num].TotalTime.QuadPart =
                                                        TopCpu[num].TotalTime.QuadPart +
                                                        Utime.QuadPart;
                            TotalTime.QuadPart = TotalTime.QuadPart +
                                                            TopCpu[num].TotalTime.QuadPart;
                            TopCpu[num].ProcessInfo = CurProcessInfo;
                            TopCpu[num].MatchedProcess = MatchedProcess;
                            num += 1;
                        }
                    }
                    if (CurProcessInfo->NextEntryOffset == 0) {

                        for (i=0;i<num;i++) {
                            PTopCpu = &TopCpu[i];
                            Ktime.QuadPart =
                                        PTopCpu->ProcessInfo->KernelTime.QuadPart +
                                        PTopCpu->ProcessInfo->UserTime.QuadPart;
                            RtlTimeToTimeFields ( &Ktime, &TimeOut);
                            printf( "%4ld%% %p %7ld %7ld %7ld %3ld:%02ld:%02ld.%03ld %ws\n",
                                (PTopCpu->TotalTime.LowPart*100)/TotalTime.LowPart,
                                PTopCpu->ProcessInfo->UniqueProcessId,
                                PTopCpu->ProcessInfo->PageFaultCount,
                                PTopCpu->ProcessInfo->WorkingSetSize,
                                PTopCpu->ProcessInfo->PrivatePageCount,
                                TimeOut.Hour,
                                TimeOut.Minute,
                                TimeOut.Second,
                                TimeOut.Milliseconds,
                                (PTopCpu->ProcessInfo->ImageName.Buffer != NULL) ?
                                    PTopCpu->ProcessInfo->ImageName.Buffer :
                                    NoNameFound);


                            Thread = (PSYSTEM_THREAD_INFORMATION)(TopCpu[i].ProcessInfo + 1);
                            if (Type == CPU_THREAD) {
                                for (j = 0;
                                     j < (int)TopCpu[i].ProcessInfo->NumberOfThreads;
                                     j++) {

                                    if (TopCpu[i].MatchedProcess == NULL) {
                                        MatchedThread = NULL;
                                    } else {
                                        MatchedThread = FindMatchedThread (
                                                            Thread,
                                                            TopCpu[i].MatchedProcess
                                                            );
                                    }
                                    if (MatchedThread == NULL) {
                                        Ktime.QuadPart =
                                                    Thread->KernelTime.QuadPart +
                                                    Thread->UserTime.QuadPart;
                                    } else {
                                        Ktime.QuadPart =
                                                    Thread->KernelTime.QuadPart -
                                                    MatchedThread->KernelTime.QuadPart;
                                        Utime.QuadPart =
                                                    Thread->UserTime.QuadPart -
                                                    MatchedThread->UserTime.QuadPart;
                                        Ktime.QuadPart =
                                                    Ktime.QuadPart +
                                                    Utime.QuadPart;
                                    }
                                    if (Ktime.LowPart != 0) {
                                        printf("  %4ld%% TID%p Cs %5ld\n",
                                            (Ktime.LowPart*100)/TotalTime.LowPart,
                                            Thread->ClientId.UniqueThread,
                                            Thread->ContextSwitches);
                                    }
                                    Thread += 1;
                                }
                            }
                        }
                    }
                    break;

                case FAULTS:

                    if (MatchedProcess == NULL) {
                        TopCpu[num].Value = CurProcessInfo->PageFaultCount;
                        TopCpu[num].ProcessInfo = CurProcessInfo;
                        num += 1;
                    } else {
                        TopCpu[num].Value = CurProcessInfo->PageFaultCount -
                                    MatchedProcess->PageFaultCount;
                        if (TopCpu[num].Value != 0) {
                            TopCpu[num].ProcessInfo = CurProcessInfo;
                            num += 1;
                        }
                    }
                    if (CurProcessInfo->NextEntryOffset == 0) {
                        for (i=0;i<num;i++) {
                            PTopCpu = &TopCpu[i];
                            Ktime.QuadPart =
                                        PTopCpu->ProcessInfo->KernelTime.QuadPart +
                                        PTopCpu->ProcessInfo->UserTime.QuadPart;
                            RtlTimeToTimeFields ( &Ktime, &TimeOut);
                            printf( "Pf: %4ld %p %7ld %7ld %7ld %3ld:%02ld:%02ld.%03ld %ws\n",
                                PTopCpu->Value,
                                PTopCpu->ProcessInfo->UniqueProcessId,
                                PTopCpu->ProcessInfo->PageFaultCount,
                                PTopCpu->ProcessInfo->WorkingSetSize,
                                PTopCpu->ProcessInfo->PrivatePageCount,
                                TimeOut.Hour,
                                TimeOut.Minute,
                                TimeOut.Second,
                                TimeOut.Milliseconds,
                                (PTopCpu->ProcessInfo->ImageName.Buffer != NULL) ?
                                    PTopCpu->ProcessInfo->ImageName.Buffer :
                                    NoNameFound);
                        }
                    }
                    break;

                case WORKING_SET:

                    if (MatchedProcess == NULL) {
                        TopCpu[num].Value = CurProcessInfo->PageFaultCount;
                        TopCpu[num].ProcessInfo = CurProcessInfo;
                        num += 1;
                    } else {
                        if (CurProcessInfo->WorkingSetSize !=
                            MatchedProcess->WorkingSetSize) {
                            TopCpu[num].Value =
                                (ULONG)(CurProcessInfo->WorkingSetSize - MatchedProcess->WorkingSetSize);
                            TopCpu[num].ProcessInfo = CurProcessInfo;
                            num += 1;
                        }
                    }
                    if (CurProcessInfo->NextEntryOffset == 0) {
                        for (i=0;i<num;i++) {
                            PTopCpu = &TopCpu[i];
                            Ktime.QuadPart =
                                        PTopCpu->ProcessInfo->KernelTime.QuadPart +
                                        PTopCpu->ProcessInfo->UserTime.QuadPart;
                            RtlTimeToTimeFields ( &Ktime, &TimeOut);
                            printf( "Ws: %4ld %p %7ld %7ld %7ld %3ld:%02ld:%02ld.%03ld %ws\n",
                                PTopCpu->Value,
                                PTopCpu->ProcessInfo->UniqueProcessId,
                                PTopCpu->ProcessInfo->PageFaultCount,
                                PTopCpu->ProcessInfo->WorkingSetSize,
                                PTopCpu->ProcessInfo->PrivatePageCount,
                                TimeOut.Hour,
                                TimeOut.Minute,
                                TimeOut.Second,
                                TimeOut.Milliseconds,
                                (PTopCpu->ProcessInfo->ImageName.Buffer != NULL) ?
                                    PTopCpu->ProcessInfo->ImageName.Buffer :
                                    NoNameFound);
                        }
                    }
                    break;

                case CONTEXT_SWITCHES:


                    Thread = (PSYSTEM_THREAD_INFORMATION)(CurProcessInfo + 1);
                    TopCpu[num].Value = 0;
                    if (MatchedProcess == NULL) {

                        for (j = 0; j < (int)CurProcessInfo->NumberOfThreads; j++ ) {
                            TopCpu[num].Value += Thread->ContextSwitches;
                            Thread += 1;
                        }

                        if (TopCpu[num].Value != 0) {
                            TopCpu[num].ProcessInfo = CurProcessInfo;
                            TopCpu[num].MatchedProcess = NULL;
                            num += 1;
                        }
                    } else {

                        for (j = 0; j < (int)CurProcessInfo->NumberOfThreads; j++ ) {
                            MatchedThread = FindMatchedThread (
                                                Thread,
                                                MatchedProcess
                                                );

                            if (MatchedThread == NULL) {
                                TopCpu[num].Value += Thread->ContextSwitches;

                            } else {
                                TopCpu[num].Value +=
                                    Thread->ContextSwitches - MatchedThread->ContextSwitches;
                            }
                            Thread += 1;
                        }

                        if (TopCpu[num].Value != 0) {
                            TopCpu[num].ProcessInfo = CurProcessInfo;
                            TopCpu[num].MatchedProcess = MatchedProcess;
                            num += 1;
                        }
                    }

                    if (CurProcessInfo->NextEntryOffset == 0) {

                        for (i=0;i<num;i++) {

                            PTopCpu = &TopCpu[i];
                            Ktime.QuadPart =
                                        PTopCpu->ProcessInfo->KernelTime.QuadPart +
                                        PTopCpu->ProcessInfo->UserTime.QuadPart;
                            RtlTimeToTimeFields ( &Ktime, &TimeOut);
                            printf( "Cs: %4ld %p %7ld %7ld %7ld %3ld:%02ld:%02ld.%03ld %ws\n",
                                PTopCpu->Value,
                                PTopCpu->ProcessInfo->UniqueProcessId,
                                PTopCpu->ProcessInfo->PageFaultCount,
                                PTopCpu->ProcessInfo->WorkingSetSize,
                                PTopCpu->ProcessInfo->PrivatePageCount,
                                TimeOut.Hour,
                                TimeOut.Minute,
                                TimeOut.Second,
                                TimeOut.Milliseconds,
                                (PTopCpu->ProcessInfo->ImageName.Buffer != NULL) ?
                                    PTopCpu->ProcessInfo->ImageName.Buffer :
                                    NoNameFound);

                            Thread = (PSYSTEM_THREAD_INFORMATION)(TopCpu[i].ProcessInfo + 1);

                            for (j = 0;
                                 j < (int)TopCpu[i].ProcessInfo->NumberOfThreads;
                                 j++) {

                                ContextSwitches = 0;
                                if (TopCpu[i].MatchedProcess == NULL) {
                                    MatchedThread = NULL;
                                } else {
                                    MatchedThread = FindMatchedThread (
                                                        Thread,
                                                        TopCpu[i].MatchedProcess
                                                        );
                                }
                                if (MatchedThread == NULL) {
                                    ContextSwitches = Thread->ContextSwitches;
                                } else {
                                    ContextSwitches =
                                        Thread->ContextSwitches -
                                                MatchedThread->ContextSwitches;

                                }
                                if (ContextSwitches != 0) {
                                    printf("\t     TID%p Cs %5ld%+3ld\n",
                                        Thread->ClientId.UniqueThread,
                                        Thread->ContextSwitches,
                                        ContextSwitches);
                                }
                                Thread += 1;
                            }
                        }
                    }
                    break;

                default:
                    break;

            } //end switch

            if (CurProcessInfo->NextEntryOffset == 0) {
                break;
            }
            Offset1 += CurProcessInfo->NextEntryOffset;

        } //end while

        /*
        
          two snapshot buffers are maintained and swapped around
          since these buffers are now dynamic keep the bufsize in
          sync
          */

        TempBuffer = PreviousBuffer;
        PreviousBuffer = CurrentBuffer;
        CurrentBuffer = TempBuffer;

        pdwBufSize = bToggle ? &g_dwBufSize1 : &g_dwBufSize2;

        bToggle = !bToggle;


retry1:
        Sleep(DelayTimeMsec);

        NtSetInformationProcess(
            NtCurrentProcess(),
            ProcessBasePriority,
            (PVOID) &SetBasePriority,
            sizeof(SetBasePriority)
            );
        

        Status = NtQuerySystemInformation(
                    SystemProcessInformation,
                    ( PVOID)CurrentBuffer,
                    *pdwBufSize,
                    NULL
                    );

        if( Status == STATUS_INFO_LENGTH_MISMATCH )
        {
            *pdwBufSize *= 2;

            if( CurrentBuffer != NULL )
            {
                free( CurrentBuffer );
            }

            CurrentBuffer = ( PUCHAR )malloc( sizeof( UCHAR ) * ( *pdwBufSize ) );

            if( CurrentBuffer == NULL )
            {
                if( PreviousBuffer != NULL )
                {
                    free( PreviousBuffer );
                }

                return 0;
            }
        }

        if ( !NT_SUCCESS(Status) ) {
            printf("Query Failed %lx\n",Status);
            goto retry1;
        }        
    }
   
    return(0);
}


PSYSTEM_PROCESS_INFORMATION
FindMatchedProcess (
    IN PSYSTEM_PROCESS_INFORMATION ProcessToMatch,
    IN PUCHAR SystemInfoBuffer,
    IN OUT PULONG Hint
    )

/*++

Routine Description:

    This procedure finds the process which corresponds to the ProcessToMatch.
    It returns the address of the matching Process, or NULL if no
    matching process was found.

Arguments:

    ProcessToMatch - Supplies a pointer to the target thread to match.

    SystemInfoBuffer - Supples a pointer to the system information
                     buffer in which to locate the process.

    Hint - Supplies and returns a hint for optimizing the searches.

Return Value:

    Address of the corresponding Process or NULL.

--*/

{
    PSYSTEM_PROCESS_INFORMATION Process;
    ULONG Offset2;

    Offset2 = *Hint;

    while (TRUE) {
        Process = (PSYSTEM_PROCESS_INFORMATION)&SystemInfoBuffer[Offset2];
        if ((Process->UniqueProcessId ==
                ProcessToMatch->UniqueProcessId) &&
            ((Process->CreateTime.QuadPart ==
                                  ProcessToMatch->CreateTime.QuadPart))) {
            *Hint = Offset2 + Process->NextEntryOffset;
            return(Process);
        }
        Offset2 += Process->NextEntryOffset;
        if (Offset2 == *Hint) {
            *Hint = 0;
            return(NULL);
        }
        if (Process->NextEntryOffset == 0) {
            if (*Hint == 0) {
                return(NULL);
            }
            Offset2 = 0;
        }
    }
}

PSYSTEM_THREAD_INFORMATION
FindMatchedThread (
    IN PSYSTEM_THREAD_INFORMATION ThreadToMatch,
    IN PSYSTEM_PROCESS_INFORMATION MatchedProcess
    )

/*++

Routine Description:

    This procedure finds thread which corresponds to the ThreadToMatch.
    It returns the address of the matching thread, or NULL if no
    matching thread was found.

Arguments:

    ThreadToMatch - Supplies a pointer to the target thread to match.

    MatchedProcess - Supples a pointer to the process which contains
                     the target thread.  The thread information
                     must follow this process, i.e., this block was
                     obtain from a NtQuerySystemInformation specifying
                     PROCESS_INFORMATION.

Return Value:

    Address of the corresponding thread from MatchedProcess or NULL.

--*/

{
    PSYSTEM_THREAD_INFORMATION Thread;
    ULONG i;

    Thread = (PSYSTEM_THREAD_INFORMATION)(MatchedProcess + 1);
    for (i = 0; i < MatchedProcess->NumberOfThreads; i++) {
        if ((Thread->ClientId.UniqueThread ==
                ThreadToMatch->ClientId.UniqueThread) &&
            ((Thread->CreateTime.QuadPart ==
                                  ThreadToMatch->CreateTime.QuadPart))) {

            return(Thread);
        }
        Thread += 1;
    }
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perftool\stat\i386\87ftol.asm ===
page	,132
	title	87ftol	 - truncate TOS to 32-bit integer
;*** 
;87ftol.asm - truncate TOS to 32-bit integer
;
;	Copyright (c) 1985-88, Microsoft Corporation
;
;Purpose:
;
;Revision History:
;
;   07/16/85	Greg Whitten
;		save BX and CX for sloppy code generator
;   10/15/86	Greg Whitten
;		in-line instructions rather than call _fpmath
;   08/24/87	Barry McCord
;		expand the functionality of _ftol to handle
;		unsigned long by using "fistp qword ptr"
;   11/24/87	Barry McCord
;		added _loadds under ifdef DLL
;
;   08/26/88	Bill Johnston
;		386 version
;
;*******************************************************************************


.xlist
;	 include cruntime.inc
;	 include mrt386.inc
;	 include os2supp.inc
.list

;	 CODESEG
	.386
	.387
	.model small,C
	.code


public _fltused
_fltused equ	9876h

_ftol	proc

	local	oldcw:word
	local	newcw:word
	local	intval:qword

	fstcw	[oldcw] 		; get control word
	fwait				; synchronize

	mov	ax, [oldcw]		; round mode saved
	or	ah, 0ch 		; set chop rounding mode
	mov	[newcw], ax		; back to memory

	fldcw	[newcw] 		; reset rounding
	fistp	qword ptr [intval]	; store chopped integer
	fldcw	[oldcw] 		; restore rounding

;	 mov	 rax, IWORD ptr [intval]
;	 mov	 rdx, IWORD ptr [intval+ISIZE]

	mov	eax, dword ptr [intval]
	mov	edx, dword ptr [intval+4]

	ret
_ftol	endp




sqrt	proc	x:qword

	fld	[x]
	fsqrt

	ret
sqrt	endp

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perftool\wait\wait.c ===
#include <windows.h>
#include <stdlib.h>

//
//  Program sleeps for desired amount of time, but at least
//  two seconds.  Beeps 5 times to warn of start.  Beeps once at end.
//


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
	unsigned i, uSecs;

	if(argc <=1)
		return(1);

	for (i=1; i<=5; i++) {
	    Beep(360, 200);
	    Sleep(200);
	}

	uSecs = atoi(argv[1]);

    //
    // The test for 2 is because we already waited for 2 seconds,
    // above.
    //
    // The subtraction of 700 milliseconds allows for startup
    // time on my 486/33 EISA machine.  Your milage may vary.
    //


    if (uSecs > 2) {
        Sleep(1000*(uSecs-2)-700);
    }

    Beep(360, 200);
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pfmon\debug.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Main debug loop for pfmon

Author:

    Mark Lucovsky (markl) 26-Jan-1995

Revision History:

--*/

#include "pfmonp.h"

DWORD
DebugEventHandler(
    LPDEBUG_EVENT DebugEvent
    );

VOID
DebugEventLoop( VOID )
{
    DEBUG_EVENT DebugEvent;
    DWORD ContinueStatus;
    DWORD OldPriority;

    //
    // We want to process debug events quickly
    //

    OldPriority = GetPriorityClass( GetCurrentProcess() );
    SetPriorityClass( GetCurrentProcess(), HIGH_PRIORITY_CLASS );

    do {
retry_debug_wait:
        ProcessPfMonData();
        if (!WaitForDebugEvent( &DebugEvent, 500 )) {
            if ( GetLastError() == ERROR_SEM_TIMEOUT ) {
                goto retry_debug_wait;
                }
            DeclareError( PFMON_WAITDEBUGEVENT_FAILED, GetLastError() );
            ExitProcess( 1 );
            }
        ProcessPfMonData();
        if ( fVerbose ) {
            if (DebugEvent.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) {
                fprintf(stderr,"Debug exception event - Code: %x  Address: %p  Info: [%u] %x %x %x %x\n",
                        DebugEvent.u.Exception.ExceptionRecord.ExceptionCode,
                        DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress,
                        DebugEvent.u.Exception.ExceptionRecord.NumberParameters,
                        DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 0 ],
                        DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 1 ],
                        DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 2 ],
                        DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 3 ]
                        );
                }
            else {
                fprintf(stderr,"Debug %x event\n", DebugEvent.dwDebugEventCode);
                }
            }

        ContinueStatus = DebugEventHandler( &DebugEvent );

        if ( fVerbose ) {
            fprintf(stderr,"Continue Status %x\n", ContinueStatus);
            }

        if (!ContinueDebugEvent( DebugEvent.dwProcessId,
                                 DebugEvent.dwThreadId,
                                 ContinueStatus
                               )
           ) {
            DeclareError( PFMON_CONTDEBUGEVENT_FAILED, GetLastError() );
            ExitProcess( 1 );
            }
        }
    while (!IsListEmpty( &ProcessListHead ));


    //
    // Drop back to old priority to interact with user.
    //

    SetPriorityClass( GetCurrentProcess(), OldPriority );
}

DWORD
DebugEventHandler(
    LPDEBUG_EVENT DebugEvent
    )
{
    DWORD ContinueStatus;
    PPROCESS_INFO Process;
    PTHREAD_INFO Thread;
    CONTEXT Context;
    PCONTEXT pContext;


    ContinueStatus = (DWORD)DBG_CONTINUE;
    if (FindProcessAndThreadForEvent( DebugEvent, &Process, &Thread )) {
        switch (DebugEvent->dwDebugEventCode) {
            case CREATE_PROCESS_DEBUG_EVENT:
                //
                // Create process event includes first thread of process
                // as well.  Remember process and thread in our process tree
                //

                if (AddProcess( DebugEvent, &Process )) {
                    AddModule( DebugEvent );
                    AddThread( DebugEvent, Process, &Thread );
                    }
                break;

            case EXIT_PROCESS_DEBUG_EVENT:
                //
                // Exit process event includes last thread of process
                // as well.  Remove process and thread from our process tree
                //

                if (DeleteThread( Process, Thread )) {
                    DeleteProcess( Process );
                    }
                break;

            case CREATE_THREAD_DEBUG_EVENT:
                //
                // Create thread.  Remember thread in our process tree.
                //

                AddThread( DebugEvent, Process, &Thread );
                break;

            case EXIT_THREAD_DEBUG_EVENT:
                //
                // Exit thread.  Remove thread from our process tree.
                //

                DeleteThread( Process, Thread );
                break;

            case LOAD_DLL_DEBUG_EVENT:
                AddModule( DebugEvent );
                break;

            case UNLOAD_DLL_DEBUG_EVENT:
                break;

            case OUTPUT_DEBUG_STRING_EVENT:
            case RIP_EVENT:
                //
                // Ignore these
                //
                break;

            case EXCEPTION_DEBUG_EVENT:
                //
                // Assume we wont handle this exception
                //

                ContinueStatus = (DWORD)DBG_CONTINUE;
                switch (DebugEvent->u.Exception.ExceptionRecord.ExceptionCode) {
                    //
                    // Breakpoint exception.
                    //

                    case STATUS_BREAKPOINT:
                            Context.ContextFlags = CONTEXT_FULL;

                            if (!GetThreadContext( Thread->Handle, &Context )) {
                                fprintf(stderr,"Failed to get context for thread %x (%p) - %u\n", Thread->Id, Thread->Handle, GetLastError());
                                ExitProcess(1);
                                }
                            pContext = &Context;

                            PROGRAM_COUNTER_TO_CONTEXT(pContext, (ULONG_PTR)((PCHAR)DebugEvent->u.Exception.ExceptionRecord.ExceptionAddress + BPSKIP));

                            if (!SetThreadContext( Thread->Handle, &Context )) {
                                fprintf(stderr,"Failed to set context for thread %x (%p) - %u\n", Thread->Id, Thread->Handle, GetLastError());
                                ExitProcess(1);
                                }

                        break;

                    default:
                        ContinueStatus = (DWORD) DBG_EXCEPTION_NOT_HANDLED;
                        if ( fVerbose ) {
                            fprintf(stderr,"Unknown exception: %08x at %p\n",
                                    DebugEvent->u.Exception.ExceptionRecord.ExceptionCode,
                                    DebugEvent->u.Exception.ExceptionRecord.ExceptionAddress
                                    );
                            }
                        break;
                    }
                break;

            default:
                break;
            }
        }
    return( ContinueStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perftool\stat\stat.c ===
/*
*      Stat.c        -    Source file for a statistical
*                         dll package that exports eleven
*                         entry points:
*                         a) TestStatOpen
*                         b) TestStatInit
*                         c) TestStatConverge
*                         d) TestStatValues
*                         e) TestStatClose
*                         f) TestStatRand
*                         g) TestStatUniRand
*                         h) TestStatNormDist
*                         i) TestStatShortRand
*                         j) TestStatFindFirstMode
*                         k) TestStatFindNextMode
*
*                         Entry point a) is an allocating routine
*                         that is called by an application program
*                         that desires to automatically compute
*                         convergence.
*
*                         Entry point b) initializes all variables that
*                         are used by entry points c) and d) in computing
*                         convergence and statistical information.
*
*                         Entry point c) automatically computes the
*                         the number of passes that the application has to
*                         go through for a 95% confidence data.
*                         This routine has to be called by the application
*                         after each pass.
*
*                         Entry point d) automatically computes the
*                         various statistical values eg. mean, SD etc.
*                         This function has to be called only after the
*                         application has called c) several times and has
*                         either converged or reached the iteration limit.
*
*                         Entry point e) deallocates all instance data
*                         data structures that were allocated by entry
*                         point a).
*
*                         Entry point f) returns a Random Number in a
*                         given range.
*
*                         Entry point g) returns a uniformly distributed
*                         number in the range 0 - 1.
*
*                         Entry point h) returns a normally distributed
*                         set of numbers, with repeated calls, whose
*                         mean and standard deviation are approximately
*                         equal to those that are passed in.
*
*                         Entry point i) is the same as g) except that
*                         the range is 0 - 65535.
*
*                         The following should be the rules of calling
*                         the entry points:
*
*                         Entry a) should be called before any of the others.
*                         Entry c) should be preceded by at least one call
*                         to entry b) for meaningful results.  Entry d)
*                         should be preceded by several calls to entry c).
*                         A call to b) and c) after a call to e) should
*                         preceded by a call to a) again.
*
*      Created         -  Paramesh Vaidyanathan  (vaidy)
*      Initial Version -  October 29, '90
*/

/*********************************************************************
*
*      Formula Used in Computing 95 % confidence level is derived here:
*
*
*        Any reference to (A) would imply "Experimental Design
*        in Psychological Research", by Allan Edwards.
*
*        Any reference to (B) would imply "Statistical Methods"
*        by Allan Edwards.
*
*        Assumptions - TYPE I Error  -  5% (B)
*                      TYPE II Error - 16% -do-
*
*        Area under the curve for Type I  - 1.96
*        Area under the curve for Type II - 1.00
*
*        For a 5% deviation, number of runs,
*
*                     2              2
*            n = 2 (c)  (1.96 + 1.00)
*                ------                      .....Eqn (1)
*                     2
*                 (d)
*
*            where c is the Std. Dev. and d is the absolute
*            difference bet. means [(B) Page 91].
*
*                    d = 5% X'               .....Eqn (2)
*
*            where X' is the mean of samples
*                         _
*                and  =  >_ X
*                        -----               .....Eqn (3)
*                         n
*                          0
*
*            When the number of iterations -> infinity,
*
*                     2     2
*                    S ->  c                 .....Eqn (4)
*
*
*                   2
*            where S is the estimate of the common population
*            variance (Eqn. 4 is a big assumption)
*
*        From (B) page 59, we have,
*
*             2     _  2       _   2
*            S  =  >_ X   - ( >_ X)
*                            -----
*                              n
*                               0
*                  -----------------         .....Eqn (5)
*                        n - 1
*                         0
*
*    Substituting Eqn (2), (3), (4) and (5) in (1), we get:
*                          _                     _
*                      2  |   _  2         _   2  |
*        n  = 7008  (n  ) |( >_ X  ) -  ( >_ X)   |
*                     0   |             --------  |
*                         |                n      |
*                         |_                0    _|
*                 ---------------------------------------
*                                        _    2
*                           (n  - 1)  ( >_ X )
*                             0
*
*    It should be mentioned that n  is the iteration pass number.
*                                 0
*********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <math.h>

#include "teststat.h"

#define SQR(A) ( (A) * (A) )        /* macro for squaring */
#define SUCCESS_OK          0       /* weird, but OK */
#define MIN_ITER            3       /* MIN. ITERATIONS */
#define MAX_ITER        65535       /* max. iterations */
#define REPEATS            14       /* repeat count for Norm. Dist. Fn. */
/**********************************************************************/
USHORT  usMinIter;              /* global min iter */
USHORT  usMaxIter;              /* global max iter */
ULONG  *pulDataArray;           /* a pointer to the data array for this
                                       package.  Will be as large as the
                                       maximum iterations */
double  dSumOfData;             /* sum of data during each pass */
double  dSumOfDataSqr;          /* sum of sqr. of each data point */
ULONG   ulTotalIterCount;       /* No. of iters returned by the interna;
                                   routine */
USHORT  cusCurrentPass;         /* count of the current iteration pass */
BOOL    bDataConverged = FALSE; /* TRUE will return a precision of 5% */
BOOL    bMemoryAllocated=FALSE; /* TRUE will allow alloced mem to free */
BOOL    bPowerComputed = FALSE; /* compute 10 exp. 9 for random no. gen */

BOOL   *pbIndexOfOutlier;       /* to keep track of values in
                                       pulDataArray, that were thrown out */

HANDLE hMemHandle = NULL;       /* handle to mem. allocated */
HANDLE hMemOutlierFlag;         /* handle to outlier flag memory */
/**********************************************************************/
ULONG TestStatRepeatIterations (double, double);
VOID TestStatStatistics (PSZ, PULONG far *, USHORT,
                                    PUSHORT, PUSHORT);
void DbgDummy (double, double);
ULONG   ulDataArrayAddress;         /* call to mem alloc routine returns
                                       base address of alloced. mem. */
BOOL    bOutlierDataIndex;          /* for allocating memory for outliers'
                                       index in data set */

/*********************************************************************/
/*
*    Function - TestStatOpen          (EXPORTED)
*
*    Arguments -
*                a) USHORT - usMinIterations
*                b) USHORT - usMaxIterations
*
*    Returns -
*                0 if the call was successful
*
*                An error code if the call failed.  The error code
*                may be one of:
*
*                   STAT_ERROR_ILLEGAL_MIN_ITER
*                   STAT_ERROR_ILLEGAL_MAX_ITER
*                   STAT_ERROR_ALLOC_FAILED
*
*
*    Instance data is allocated for the statistical package.  This
*    call should precede any other calls in this dll.  This function
*    should also be called after a call to TestStatClose, if convergence
*    is required on a new set of data.  An error code is returned if
*    argument a) is zero or a) is greater than b).  An error code is
*    also returned of one of the allocations failed.
*
*/

USHORT
TestStatOpen (
             USHORT usMinIterations,
             USHORT usMaxIterations
             )
{

    /* check for invalid args to this function */
    if (!usMinIterations)
        return (STAT_ERROR_ILLEGAL_MIN_ITER);
    if ((usMinIterations > usMaxIterations) || (usMaxIterations > MAX_ITER))
        return (STAT_ERROR_ILLEGAL_MAX_ITER);
    /* any other parameter is allowed */
    usMinIter = usMinIterations;      /* set global vars */
    usMaxIter = usMaxIterations;      /*    -do -        */

    // change made based on request from JeffSt/Somase/JonLe

    if (hMemHandle != NULL)
        return (STAT_ERROR_ALLOC_FAILED);

    hMemHandle = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, usMaxIter *
                              sizeof(ULONG));
    if (hMemHandle == NULL)
        return (STAT_ERROR_ALLOC_FAILED);

    pulDataArray = (ULONG *) GlobalLock (hMemHandle);
    if (pulDataArray == NULL)
        return (STAT_ERROR_ALLOC_FAILED);

    bMemoryAllocated = TRUE;  /* A call to TestStatClose will
                                 now free the mem */
    return (SUCCESS_OK);
}

/*
*    Function - TestStatClose          (EXPORTED)
*
*    Arguments - None
*
*    Returns -   Nothing
*
*    Instance data allocated for the statistical package by TestStatOpen
*    is freed.  Any call to entry points b) and c) following a call to
*    this function, should be preceded by a call to a).
*
*/
VOID
TestStatClose (VOID)
{
    if (bMemoryAllocated) {   /* free only if memory allocated */
        GlobalUnlock (hMemHandle);
        GlobalFree (hMemHandle);
        hMemHandle = NULL; /* Indicate released (t-WayneR/JohnOw) */
    }  /* end of if (bMemoryAllocated) */
    bMemoryAllocated = FALSE;  /* further calls to TestStatClose should be
                                  preceded by a memory allocation */
    return;
}

/*
*    Function - TestStatInit          (EXPORTED)
*
*    Arguments - None
*
*    Returns -   Nothing
*
*    Initializes all the data arrays/variables for use by the convergence
*    and statistics routines.  This call should precede the first call
*    to TestStatConverge for each set of data.
*
*/

VOID
TestStatInit (VOID)
{
    USHORT usTempCtr;

    /* initialize all counters, variables and the data array itself */
    for (usTempCtr = 0; usTempCtr < usMaxIter; usTempCtr++) {
        pulDataArray [usTempCtr] = 0L;
    }
    dSumOfData = 0.0;
    dSumOfDataSqr = 0.0;
    ulTotalIterCount = 0L;
    cusCurrentPass = 0;
    bDataConverged = FALSE;
    return;
}

/*
*    Function - TestStatConverge          (EXPORTED)
*
*    Arguments -
*                a) ULONG - ulNewData
*    Returns -
*                TRUE if data set converged or limit on max. iters reached
*
*                FALSE if more iterations required for converged.
*
*    Computes the number of iterations required for a 95% confidence
*    in the data received (please see teststat.txt under \ntdocs on
*    \\jupiter\perftool for an explanation of the confidence.
*    If the current iteration count is larger than the maximum specified
*    with the call to TestStatOpen, or if the data set has converged
*    this function returns a TRUE.  The calling application should test
*    for the return value.
*/

BOOL
TestStatConverge (
                 ULONG ulNewData
                 )
{
    dSumOfData += (double)ulNewData;   /* sum of all data points in the set */
    dSumOfDataSqr += SQR ((double) ulNewData);
    /* sqr of data needed for the computation */
    if (cusCurrentPass < (USHORT) (usMinIter-(USHORT)1)) { /* do nothing if current iter
                                           < min specified value */
        ulTotalIterCount = (ULONG)usMaxIter + 1;  /* bogus value */
        pulDataArray [cusCurrentPass++] = ulNewData;
        /* register this data into the array and return FALSE */
        return (FALSE);
    }
    if ((cusCurrentPass == usMaxIter) ||
        (cusCurrentPass >= (USHORT) ulTotalIterCount)) {
        /* either the limit on the max. iters. specified has been reached
           or, the data has converged during the last iter; return TRUE */

        if (cusCurrentPass >= (USHORT) ulTotalIterCount)
            bDataConverged = TRUE;  /* set to determine if precision
                                       should be computed */
        return (TRUE);
    }
    if ((usMinIter < MIN_ITER) &&
        (usMinIter == usMaxIter) && ((USHORT)(cusCurrentPass+(USHORT)1) >= usMaxIter))
        /* don't call convergence algorithm, just return a TRUE */
        /* It does not make any sense in calling the convergence
           algorithm if less than 3 iterations are specifed for the
           minimum */
        return (TRUE);
    pulDataArray [cusCurrentPass++] = ulNewData; /* register this data into
                                                    the array */
    if (dSumOfData == 0.0) { /* possible if data points are all zeros */
        bDataConverged = TRUE;
        return (TRUE);
    }
    ulTotalIterCount = TestStatRepeatIterations (dSumOfData,
                                                 dSumOfDataSqr);

    if (ulTotalIterCount <= cusCurrentPass)
        return (TRUE);

    return (FALSE);
}

/*
*    Function - TestStatValues          (EXPORTED)
*
*    Arguments -
*               a) PSZ - pszOutputString
*               b) USHORT - usOutlierFactor
*               c) PULONG - *pulData
*               d) PUSHORT - pcusElementsInArray
*               e) PUSHORT - pcusDiscardedElements
*
*    Returns -
*               Nothing
*
*    Computes useful statistical values and returns them in the string
*    whose address is passed to this function.  The returned string
*    has the following format :
*        ("%4u %10lu  %10lu  %10lu  %6u %5u  %10lu %4u  %2u")
*    and the arg. list will be in the order: mode number, mean,
*    minimum, maximum, number of iterations, precision,
*    standard deviation, number of outliers in the data set and the
*    outlier count.  (Please refer to \ntdocs\teststat.txt for
*    a description of precision. This is on \\jupiter\perftool.
*
*/
VOID
TestStatValues(
              PSZ     pszOutputString,
              USHORT  usOutlierFactor,
              PULONG  *pulFinalData,
              PUSHORT pcusElementsInArray,
              PUSHORT pcusDiscardedElements
              )
{
    ULONG far * pulArray = NULL;
    USHORT Count =0;
    /* Call the low-level routine to do the statistics computation */
    /* doing this ,'cos, there is a possibility that the low-level
       routine may be used for some apps, within the perf. group.  This
       may not be fair, but that is the way life is */
    TestStatStatistics (pszOutputString, &pulArray,
                        usOutlierFactor, pcusElementsInArray,
                        pcusDiscardedElements);
    *pulFinalData = pulArray;
    return;

}

/***********************************************************************
                ROUTINES NOT EXPORTED, BEGIN
***********************************************************************/
/*
*     Function  - TestStatRepeatIterations  (NOT EXPORTED)
*     Arguments -
*               (a) double - Sum of Individual Data Points thus far
*               (b) double - Sum of Squares of Indiv. data points
*
*     Returns  - ULONG  - value of no. of iterations required for 95%
*                         confidence,
*
*     Computes the number of iterations required of the calling program
*     before a 95% confidence level can be reached.  This will return
*     a zero if the application calls this routine before 3 passes
*     are complete.  The function normally returns the total number of
*     iterations that the application has to pass through before
*     offering a 95% confidence on the data.
*/

ULONG
TestStatRepeatIterations(
                        double dSumOfIndiv,
                        double dSumOfSqrIndiv
                        )
{
    double dSqrSumOfIndiv = 0;
    ULONG  ulRepeatsNeeded = 0L;

    /* dSqrSumOfIndiv. stands for the square of the Sum of Indiv. data
       points,
       dSumOfSqrIndiv stands for the sum of the square of each entry point,
       dSumOfIndiv. stands for the sum of each data point in the set, and
       uIter is the iteration pass count
    */
    if (cusCurrentPass < MIN_ITER)
        /* not enough passes to compute convergence count */
        return (MAX_ITER);
    dSqrSumOfIndiv = SQR (dSumOfIndiv);
    /* use the formula derived at the beginning of this file to
       compute the no. of iterations required */

    ulRepeatsNeeded = (ULONG) (7008 *
                               (dSumOfSqrIndiv - dSqrSumOfIndiv/cusCurrentPass)
                               * SQR (cusCurrentPass) /
                               ((cusCurrentPass - 1) * dSqrSumOfIndiv));

    return (ulRepeatsNeeded);
}
/***************************************************************************/
/*
*     Function  - TestStatStatistics
*     Arguments -
*                 a) PSZ - pszOutputString
*                 b) PULONG far * - pulFinalData
*                 c) USHORT - usOutlierFactor
*                 d) PUSHORT - pcusElementsInArray
*                 e) PUSHORT - pcusDiscardedValues
*
*     Returns  -  Nothing
*
*     Computes the max, min, mean, and std. dev. of a given
*     data set.  The calling program should convert the values obtained
*     from this routine from a "ULONG" to the desired data type.  The
*     outlier factor decides how many data points of the data set are
*     within acceptable limits.  Data is returned to the buffer whose
*     address is the first argument to this call.
*
*/

VOID
TestStatStatistics (
                   PSZ     pszOutputString,
                   PULONG  *pulFinalData,
                   USHORT  usOutlierFactor,
                   PUSHORT pcusElementsInArray,
                   PUSHORT pcusDiscardedValues
                   )
{
    static USHORT   uArrayCount = 0;  /* local variable that may be reused */
    USHORT uTempCt = 0;  /* local variable that may be reused */
    double dSqrOfSDev = 0;       /* sqr of the std. deviation */
    double dSumOfSamples = 0;    /* sum of all data points */
    double dSumOfSquares = 0;    /* sum of squares of data points */
    ULONG  ulMean = 0L;
    ULONG  ulStdDev = 0L;
    ULONG  ulDiffMean = 0L;           /* to store the diff. of mean and SD,
                                         outlier factor */
    BOOL   bAcceptableSDev = TRUE ;   /* flag to determine if SDev. is
                                         acceptable */
    ULONG  ulMax = 0L;                /* pilot value */
    ULONG  ulMin = 0xffffffff;        /* largest possible ULONG */
    USHORT usPrecision = 0;           /* to obtain precision */
    USHORT uModeNumber = 0;           /* DUMMY VALUE until this is
                                         supported */

    /* compute mean by adding up all values and dividing by the no.
       of elements in data set - might need to recompute the
       mean if outlier factor is selected.  However, the min. and max. will
       be selected from the entire set */

    USHORT Count = 0;

    *pcusDiscardedValues = 0;       /* init. this variable */

    if (cusCurrentPass == 0)
        return;   /* get out without doing anything - this is a weird
                         case when the user calls this routine without
                         calling a converge routine */

    *pcusElementsInArray = cusCurrentPass;

    /* every iteration produces one data point */
    uArrayCount = 0;
    while (uArrayCount < *pcusElementsInArray) {
        if (pulDataArray[uArrayCount] > ulMax)
            ulMax = pulDataArray[uArrayCount];     /* new Max. value */
        if (pulDataArray[uArrayCount] < ulMin)
            ulMin = pulDataArray[uArrayCount];     /* new min. value */

        ulMean += pulDataArray [uArrayCount++];
    }
    if (*pcusElementsInArray)
        ulMean /= *pcusElementsInArray;   /* this is the mean */
    else
        ulMean = 0;
    /* the standard deviation needs to be computed */

    for (uArrayCount = 0; uArrayCount < *pcusElementsInArray; uArrayCount++) {
        dSumOfSamples += (double) pulDataArray [uArrayCount];
        dSumOfSquares += SQR ((double) pulDataArray [uArrayCount]);
    }

    if (*pcusElementsInArray) {
        dSqrOfSDev = ((*pcusElementsInArray * dSumOfSquares) -
                      SQR (dSumOfSamples)) /
                     (*pcusElementsInArray * (*pcusElementsInArray - 1));
    }
    ulStdDev = (ULONG) sqrt (dSqrOfSDev);

    /* the standard deviation has been computed for the first pass */
    /* Use the outlier factor and the S.D to find out if any of
       individual data points are abnormal.  If so, throw them out and
        increment the discard value counter */
    if (usOutlierFactor) { /* if outlier factor is zero, do not go
                          through with the following */
        /*** here is what we do....
           allocate space for an array of BOOLs.  Each of these is a flag
           corresponding to a data point.  Initially, these flags will be
           all set to FALSE.  We then go thru each data point.  If a data
           point does not satisfy the condition for throwing out outliers,
           we set the flag corresponding to that data point to TRUE.  That
           point is not used to recompute the mean and SDev.  We recompute
           the mean and SDev after each round of outlier elimination.  When
           we reach a stage where no points were discarded during a round,
           we get out of the while loop and compute the statistics for the
           new data set ****/

        hMemOutlierFlag = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT,
                                       *pcusElementsInArray * sizeof(BOOL));
        pbIndexOfOutlier = (BOOL FAR *) GlobalLock (hMemOutlierFlag);
        if (!pbIndexOfOutlier) {
            return;
        }

        for (uArrayCount = 0; uArrayCount < *pcusElementsInArray;
            uArrayCount ++)
            pbIndexOfOutlier [uArrayCount] = FALSE;

        while (1) { /* begin the data inspection round */
            bAcceptableSDev = TRUE; /* set this flag to TRUE.  If we
                                       hit an outlier, this flag will
                                       be reset */
            for (uArrayCount = 0; uArrayCount < cusCurrentPass;
                uArrayCount++) {
                /*** check the individual data points ***/
                if (ulMean < (ulStdDev * usOutlierFactor))
                    /* just make sure that we are not comparing with a
                       negative number */
                    ulDiffMean = 0L;
                else
                    ulDiffMean = (ulMean - (ulStdDev * usOutlierFactor));
                if (!pbIndexOfOutlier [uArrayCount]) {
                    if ((pulDataArray [uArrayCount] < ulDiffMean)
                        || (pulDataArray [uArrayCount] >
                            (ulMean + (ulStdDev * usOutlierFactor)))) {
                        /* set the flag of this data point to TRUE to
                           indicate that this data point should not be
                           considered in the mean and SDev computation */
                        pbIndexOfOutlier [uArrayCount] = TRUE;
                        /*** increment the discarded qty ***/
                        (*pcusDiscardedValues)++;
                        /*** decrement the count of good data points ***/

                        // uncomment next line if outliers should be part of mean - vaidy

                        //                        (*pcusElementsInArray)--;
                        bAcceptableSDev = FALSE;
                    }  /*** end of if statement ***/
                }   /*** end of if !pbIndexOfOutlier ***/
            }  /*** end of for loop ***/
            if (!bAcceptableSDev) {  /*** there were some bad data points ;
                                        recompute S.Dev ***/
                // Starting at next statement, uncomment all lines until you see
                // "STOP UNCOMMENT FOR OUTLIERS IN MEAN", if you want outliers to be
                // part of mean.  vaidy Aug. 1991.

                //                dSumOfSamples = 0.0; /* init these two guys */
                //                dSumOfSquares = 0.0;
                //                for (uArrayCount = 0;
                //                     uArrayCount < cusCurrentPass;
                //                     /* check all elements in the data array */
                //                     uArrayCount++) {
                //                    /* consider only those data points that do not have the
                //                       pbIndexOfOutlier flag set */

                //                    if (!pbIndexOfOutlier [uArrayCount]) {
                //                        dSumOfSamples += (double) pulDataArray [uArrayCount];
                //                        dSumOfSquares += SQR ((double)pulDataArray
                //                                                      [uArrayCount]);
                //                    }
                //                }
                //                if (*pcusElementsInArray > 1)
                //                    /* compute StdDev. only if there are atleast 2 elements */
                //                    dSqrOfSDev = ((*pcusElementsInArray * dSumOfSquares) -
                //                               SQR (dSumOfSamples)) /
                //                              (*pcusElementsInArray *
                //                              (*pcusElementsInArray - 1));
                //                ulStdDev = (ULONG) sqrt (dSqrOfSDev);
                //                /* since some data points were discarded, the mean has to be
                //                   recomputed */
                //                uArrayCount = 0;
                //                ulMean = 0;
                //                while (uArrayCount < cusCurrentPass) {
                //                    /* consider only those data points that do not have the
                //                       bIndexOfOutlier flag set */
                //                    if (!pbIndexOfOutlier [uArrayCount++])
                //                        ulMean += pulDataArray [uArrayCount - 1];
                //                }
                //                if (*pcusElementsInArray > 0)  /* only then compute mean */
                //                    ulMean /= *pcusElementsInArray; /* this is the new mean */
                //                else
                //                    ulMean = 0L;
                // "STOP UNCOMMENT FOR OUTLIERS IN MEAN"
            } /*** end of if (!bAcceptableSDev) ***/
            else       /*** if the for loop completed without
                            a single bad data point ***/
                break;
        } /* end of while */
        /****  free the memory for the bIndexOfOutiler flag */
        GlobalUnlock (hMemOutlierFlag);
        GlobalFree (hMemOutlierFlag);
    }  /* end of if (iOutlierFactor) */
    /* so, now an acceptable Standard deviation and mean have been obtained */

    if ((!bDataConverged) &&
        (usMaxIter < MIN_ITER)) {
        /* set precision to 0% if max iters chosen is less than 3 */
        usPrecision = 0;
    } else { /* need to compute precision */
        /* using eqn. 1. above, it can be shown that the precision, p,
           can be written as:
                                      1
                 _                 _   /
                |        2       2  |   2
                |  2 * SD  * 2.96   |
            p = | ----------------- |
                |             2     |
                |     n * Mean      |
                |_                 _|
        *************************************************************/
        if (ulMean > 0 && *pcusElementsInArray) {
            usPrecision = (USHORT) (sqrt((double) ((2 *
                                                    SQR ((double)ulStdDev) *
                                                    SQR (2.96) /(*pcusElementsInArray *
                                                                 SQR ((double) ulMean))))) * 100.0
                                    + 0.5);

        } else
            usPrecision = (USHORT)~0;
    }  /* end of else need to compute precision */
    sprintf (pszOutputString,
             "%4u %10lu %10lu %10lu %6u %5u %10lu %4u %2u ",
             uModeNumber, ulMean, ulMin, ulMax, cusCurrentPass,
             usPrecision, ulStdDev, *pcusDiscardedValues,
             usOutlierFactor);

    *pcusElementsInArray = cusCurrentPass;
    *pulFinalData = pulDataArray;
    return;
}


/*
*        The following is the source for generating random numbers.
*        Two procs are provided:  TestStatRand and TestStatUniRand.
*
*   a)   TestStatRand is called as follows: TestStatRand (Low, High)
*            The result is a number returned in the range Low - High (both
*            inclusive.
*
*        A given intial value of Seed will yield a set of repeatable
*        results.  The first call to TestStatRand should be with an odd seed
*        in the range of 1 - 67108863, both inclusive.  The following
*        9 seeds have been tested with good results:
*
*        32347753, 52142147, 52142123, 53214215, 23521425, 42321479,
*        20302541, 32524125, 42152159.
*
*        The result should never be equal to the seed since this would
*        eliminate the theoretical basis for the claim for uniform
*        randomeness.
*
*   b)   TestStatUniRand is called as follows:
*                 NormFrac = TestStatUniRand ();
*            NormFrac is uniformaly distributed between 0 and 1 with
*            a scale of 9 (values range bet. 0 and 0.999999999).
*
*        The basis for this algorithm is the multiplicative congruential
*        method found in Knuth (Vol.2 , Chap.3).  Constants were selected
*        by Pike, M.C and Hill, I.D; Sullivans, W.L. provides the
*        the list of tested seeds.
*
*        The code here has been adapted from Russ Blake's work.
*
*        Created  :   vaidy   - Nov. 29, 90
*/

#define MODULUS     67108864      /* modulus for computing random no */
#define SQRTMODULUS 8192          /* sqrt of MODULUS */
#define MULTIPLIER  3125
#define MAX_UPPER   67108863
#define MAX_SEEDS   8           /* 8 good starting seeds */
#define SCALE       65535

ULONG aulSeedTable [] = {     /* lookup table for good seeds */
    32347753, 52142147, 52142123, 53214215, 23521425, 42321479,
    20302541, 32524125, 42152159};

USHORT uSeedIndex;            /* index to lookup table */
ULONG  ulSeed = 32347753;     /* the seed chosen from table (hardcoded here)
                                 and recomputed */

/*********************************************************************/
/*
*    Function - TestStatRand          (EXPORTED)
*
*    Arguments -
*                a) ULONG  - ulLower
*                b) ULONG  - ulUpper
*
*    Returns -
*                a random number in the range ulLower to ulUpper
*
*                An error code if the call failed.  The error code
*                will be:
*
*                   STAT_ERROR_ILLEGAL_BOUNDS
*
*
*   Calls TestStatUniRand and returns a random number in the range passed
*   in (both inclusive).  The limits for the lower and upper bounds
*   are 1 and 67108863.  The start seed index looks up into the array
*   of seeds to select a good, tested starting seed value.  The returned
*   values will be uniformaly distributed within the boundary.  A start
*   seed has been hardcoded into this dll.
*
*/

ULONG
TestStatRand (
             ULONG ulLower,
             ULONG ulUpper
             )
{
    double dTemp;
    double dNormRand;
    LONG   lTestForLowBounds = (LONG) ulLower;

    /* check args */
    if ((lTestForLowBounds < 1L) ||
        (ulUpper > MAX_UPPER) || (ulUpper < ulLower))
        return (STAT_ERROR_ILLEGAL_BOUNDS);
    dNormRand = TestStatUniRand ();  /* call TestStatUniRand */
    dTemp = (double) ((ulUpper - ulLower) * dNormRand); /* scale value */
    return (ulLower + (ULONG) dTemp);
}

/*
*
*   Function - TestStatUniRand ()          EXPORTED
*
*   Accepts -  nothing
*
*   Returns a uniformaly distrib. normalized number in the range 0 - 0.9999999
*   (both inclusive).  Modifies the seed to the next value.
*
*/

double
TestStatUniRand (VOID)
{
    ULONG  ulModul = MODULUS;   /* use the modulus for getting remainder
                                   and dividing the current value */
    double dMult   = MULTIPLIER;
    double dTemp   = 0.0;       /* a temp variable */
    double dTemp2  = 0.0;       /* a temp variable */
    ULONG  ulDivForMod;         /* used for obtaining the remainder of
                                   the present seed / MODULUS */

    /* the following long-winded approach has to be adopted to
       obtain the remainder.  % operator does not work on floats */

    /* use a temp variable.  Makes the code easier to follow */

    dTemp = dMult * (double) ulSeed;  /* store product in temp var. */
    DbgDummy (dTemp, dMult); // NT screws up bigtime for no reason
                             // if this is not used - possible compiler
                             // bug
    dTemp2 = (double) ulModul; // more compiler problems reported
                               // on Build 259 by JosephH.
                               // April 13, 1992.
    ulDivForMod = (ULONG) (dTemp / dTemp2);

    //    ulDivForMod = (ULONG) (dTemp / ulModul); /* store quotient of present
    //                                                seed divided by MODULUS */
    dTemp -= ((double)ulDivForMod * (double)ulModul);
    /* dTemp will contain the remainder of present seed / MODULUS */

    ulSeed = (ULONG) dTemp;   /* seed for next iteration obtained */
    /* return value */
    return ((dTemp)/(double)ulModul);
}

/*
*
*   Function - TestStatNormDist ()          EXPORTED
*
*   Accepts -
*              a) ULONG  - ulMean
*              b) USHORT - usStdDev
*
*   Returns -  LONG - A LONG that allows the mean of the generated
*              points to be approximately ulMean and the SD of the
*              set to be ulStdDev.
*
*   Formula used here is:            REPEATS
*                                    _
*   Return Value = ulMean + (-7 + [ >_ TestStatUniRandRand ()] * ulStdDev
*                                   i = i
*
*   This formula is based on 'Random Number Generation and Testing',
*   IBM Data Processing Techniques, C20-8011.
*/

LONG
TestStatNormDist (
                 ULONG ulMean,
                 USHORT usSDev
                 )
{
    LONG   lSumOfRands = 0L;  /* store the sum of the REPEATS calls here */
    USHORT cuNorm;            /* a counter */
    LONG   lMidSum = 0L;
    LONG   lRemainder = 0L;

    for (cuNorm = 0; cuNorm < REPEATS; cuNorm++)
        lSumOfRands += (LONG) TestStatShortRand ();

    /* we now do a lot of simple but ugly mathematics to obtain the
       correct result.  What we do is as follows:

       Divide the lSumOfRands by the scale factor.
       Since we are dealing with short and long integers, we are
       likely to lose precision.  So, we get the remainder of this
       division and multiply each of the values by the standard division.

       Eg. if lSumOfRands = 65534 and std.dev is 10,
       lQuotient = 0, lRemainder = 65534.

       lMidSum = (-7 * 10) + (0 * 10) + (65534 * 10/65535) = -61,
       which is pretty accurate.  We then add the mean and return.
       Actually, we do not return right away.  To be more precise,
       we need to find out if the third element in the above term
       yields a remainder of < 0.5.  If so, we do not do anything.
       Else, we add 1 to the result to round off and then return.
       In the above example, the remainder = 0.99.  So we add 1 to
       -61.  The result is -60 and this is accurate. */

    lRemainder = (lSumOfRands * usSDev) % SCALE;
    /* the above remainder is the one to determine the rounding off */

    lMidSum =  ((-7 + (lSumOfRands / SCALE)) * usSDev) +
               ((lSumOfRands % SCALE) * usSDev / SCALE);

    if (lRemainder >= (SCALE / 2L))  /* need to roundup ? */
        lMidSum += 1L;

    return (lMidSum + ulMean);
}

/*
*
*   Function - TestStatShortRand ()          EXPORTED
*
*   Accepts -  nothing
*
*   Returns a normalized number in the range 0 - 65535
*   (both inclusive).  Modifies the seed to the next value.
*
*/

USHORT
TestStatShortRand (VOID)
{
    ULONG  ulTemp = SCALE / SQRTMODULUS;

    ulSeed =  (MULTIPLIER * ulSeed) % MODULUS;
    /* seed for next iteration obtained */

    /* note: the return value should be (ulSeed * SCALE / MODULUS).
       However, the product of the elements in the numerator, far exceeds
       4 Billion.  So, the math is done in two stages.  The value of
       MODULUS is a perfect square (of 8192).  So, the SCALE is first
       divided by the SQRT of the MODULUS, the product of ulSeed and the
       result of the division is divided by the SQRT of the MODULUS again */

    /* return scale value - add one to ulTemp for correction */
    return ((USHORT) ((ulSeed * (ulTemp + 1)) / SQRTMODULUS));
}

/*
*
*   Function - TestStatFindFirstMode ()          EXPORTED
*
*   Accepts -  a) PSZ     - pszOutputString
*              b) USHORT  - usOutlierFactor
*              c) PULONG  - *pulData
*              d) PUSHORT - pcusElementsInArray
*              e) PUSHORT - pcusDiscardedElements
*
*    Returns -
*               Nothing
*
*    Computes useful statistical values and returns them in the string
*    whose address is passed to this function.  The returned string
*    has the following format :
*        ("%10lu  %10lu  %10lu  %10lu %5u  %10lu %4u  %2u")
*    and the arg. list will be in the order: mean,
*    minimum, maximum, number of iterations, precision,
*    standard deviation, number of outliers in the data set and the
*    outlier count.  (Please refer to \ntdocs\teststat.txt for
*    a description of precision. This is on \\jupiter\perftool.
*
*   Returns
*                TO BE COMPLETED.....
*
*/

/*++
  Had to call this routine in TestStatUniRand - compiler screws up
--*/
void
DbgDummy (
         double dTemp,
         double dLocal
         )
{
    dTemp = 0.0;
    dLocal = 0.0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\perftool\timer\timer.c ===
/*  OS/2 Version
*      Timer.c       -    Source file for a statistical
*                         dll package that exports four
*                         entry points:
*                         a) TimerOpen
*                         b) TimerInit
*                         c) TimerRead
*                         d) TimerClose
*                         e) TimerReport
*                         f) TimerQueryPerformanceCounter
*                         g) TimerConvertTicsToUSec
*
*                         Entry point a) opens a timer object
*                         and returns a handle to the timer. This
*                         handle is an index into an array of timer
*                         objects (structs) that are allocated at
*                         the time of the initialization of the dll.
*                         This ensures that allocation is done once only.
*                         Each application program will call this
*                         this function so that it has its own set
*                         of timers to use with TimerInit and TimerRead.
*                         The units of the time returned by TimerRead
*                         is also made available as a parameter to
*                         this call.
*
*                         Entry point b) is called by the application
*                         before commencing a timing operation.  This
*                         function is called with a handle to a timer
*                         object that was opened.  This function has to
*                         to be called before a call to TimerRead. The
*                         current time is stored in the timer object.
*
*                         Entry point c) is called each time the time
*                         since the previous call to TimerInit is
*                         desired.  This call also uses the handle to
*                         a timer that has been previosly opened. The
*                         current time is obtained form the lowlevel
*                         timer and this and the time at TimerInit time
*                         are used, along with the clock frequency and
*                         the return time units and the elapsed time
*                         is obtained and returned as a ULONG.
*
*                         Entry point d) is called whenever an opened
*                         timer is not needed any longer.  This call
*                         resets the timer and makes this timer as
*                         available to future calls to TimerOpen.
*
*                         Entry point e) returns the time obtained during
*                         the last call to TimerInit, TimerRead and the
*                         last returned time.
*
*                         Entry point f) accepts pointers to 2 64 bit
*                         vars.  Upon return, the first will contain the
*                         the current timer tic count and the second,
*                         if not NULL, will point to the timer freq.
*
*                         Entry point g) accepts Elapsed Tics as ULONG,
*                         Frequency as a ULONG and returns the time in
*                         microsecs. as  a ULONG.
*
*                         The dll initialization routine does the
*                         following:
*                             a) Obtains the timer overhead for calibration
*                                purposes.
*                             b) Allocates memory for a large number of
*                                timer objects (this will be system dep).
*                             c) Initializes each timer objects "Units'
*                                element to a "TIMER_FREE" indicator.
*                             d) Determines the lowlevel timer's frequency.
*
*                         TimerRead uses an external asm routine to perform
*                         its computation for elapsed time.
*
*     Created         -   Paramesh Vaidyanathan  (vaidy)
*     Initial Version -              October 18, '90
*
*     Modified to include f).  -     Feb. 14, 1992. (vaidy).
*/

char *COPYRIGHT = "Copyright Microsoft Corporation, 1991-1998";

#ifdef SLOOP
    #define INCL_DOSINFOSEG
    #define INCL_DOSDEVICES
    #define INCL_DOSPROCESS
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "timing.h"
/*****************************END OF INCLUDES*************************/
#define ITER_FOR_OVERHEAD   250
#define SUCCESS_OK            0
#define ONE_MILLION     1000000L
#define MICROSEC_FACTOR 1000000
#define TIMER_FREQ   1193167L  /* clock frequency - Hz */
/*********************************************************************/
Timer pTimer [MAX_TIMERS];       /* array of timer struct */

BOOL  bTimerInit = FALSE;        /* TRUE indicates low level timer exists */
ULONG ulTimerOverhead = 50000L;  /* timer overhead stored here */
BOOL  bCalibrated = FALSE;       /* TRUE subtracts overhead also */
ULONG ulFreq;                    /* timer frequency */
LONG aScaleValues[] = {1000000000L, 1000000L, 1000L, 1L, 10L, 1000L};
/* this is the table for scaling the units */
ULONG ulElapsedTime = 0L;
/********************* internal unexported routines ***************/
ULONG  CalibrateTimerForOverhead (VOID);
/*****************DEFINE VARIBLES AND PROTOTYPE FNS. FOR PLATFORMS*****/
NTSYSAPI
NTSTATUS
NTAPI
NtQueryPerformanceCounter (
                          OUT PLARGE_INTEGER PerformanceCount,
                          OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
                          );

LARGE_INTEGER      PerfFreq;
LARGE_INTEGER      CountCurrent;

SHORT  GetTimerFreq (VOID);

/****************** internal unexported routines end***************/

/*
*     Function  - TimerOpen            (EXPORTED)
*     Arguments -
*               (a) SHORT far * -     address to which to return handle of
*                                the timer object.
*               (b) TimerUnits - units in which to return time from
*                                TimerRead.  It is one of the enum
*                                types defined in the header file.
*
*     Returns  -    SHORT  -     0 if handle was returned successfully
*                                Else, an error code which may be one of:
*
*                                    TIMERERR_NOT_AVAILABLE
*                                    TIMERERR_NO_MORE_HANDLES
*                                    TIMERERR_INVALID_UNITS
*
*     Obtains the handle to a timer object after opening it.
*     Should precede any calls to timer manipulation.  Checks
*     for validity of timer units.
*/

SHORT
TimerOpen (
          SHORT *  phTimerHandle,
          _TimerUnits TimerUnits
          )
{
    SHORT csTemp;

    if ((TimerUnits < KILOSECONDS)
        || (TimerUnits > NANOSECONDS)) /* out of the enum range */
        return (TIMERERR_INVALID_UNITS);

    if (!bTimerInit)  /* set during dll initialization */
        return (TIMERERR_NOT_AVAILABLE);

    /* else check if any timers are not in use and return the first
       available timer handle....actually the index into the
       timer object array */
    for (csTemp = 0; csTemp < MAX_TIMERS; csTemp++) {
        if (pTimer [csTemp].TUnits == TIMER_FREE) {
            *phTimerHandle =  csTemp;  /* found a free timer.  Return
                                          the handle */
            pTimer [csTemp].ulHi = pTimer[csTemp].ulLo = 0L;
            pTimer [csTemp].TUnits =
            TimerUnits;  /* set the units for timer */
            return (SUCCESS_OK);
        }
    }
    /* if exec reached here, all timers are being used */
    return (TIMERERR_NO_MORE_HANDLES);
}

/*
*     Function  - TimerInit       (EXPORTED)
*     Arguments -
*               (a) SHORT - hTimerHandle
*
*     Returns  - SHORT - 0 if call successful
*                        Else, an error code if handle invalid:
*
*                            TIMERERR_INVALID_HANDLE
*
*     Calls the low-level timer and sets the ulHi and ulLo of the
*     chosen timer to the time returned by the timer.  Should be
*     called after opening the timer with TimerOpen.
*/

SHORT
TimerInit (
          SHORT hTimerHandle
          )
{

    NTSTATUS NtStatus;

    if ((hTimerHandle > MAX_TIMERS - 1) ||
        (pTimer [hTimerHandle].TUnits == TIMER_FREE))
        /* this timer has not been opened or does not exist. Return error */
        return (TIMERERR_INVALID_HANDLE);

    /* otherwise get the time from the low-level timer into
       the structure */

    NtStatus = NtQueryPerformanceCounter (&CountCurrent, NULL);
    pTimer [hTimerHandle].ulLo = CountCurrent.LowPart;
    pTimer [hTimerHandle].ulHi = CountCurrent.HighPart;
    /* this timer structure has all the information needed to compute
       the elapsed time.  So return success, if there was no problem */

    return (SUCCESS_OK);
}

/*
*     Function  - TimerRead       (EXPORTED)
*     Arguments -
*               (a) SHORT - hTimerHandle
*
*     Returns  - ULONG - elapsed time since last call to TimerInit
*                         if call successful.
*
*                        Else, an error code if handle invalid or output
*                         overflow.  The error code will be the same:
*
*                            TIMERERR_OVERFLOW (max possible ULONG)
*
*     Calls the low-level timer.  Uses the ulLo and ulHi from the
*     timer's structure and subtracts the current time from the
*     saved time.  Uses ReturnElapsedTime (an external ASM proc)
*     to return the elapsed time taking into account the clock
*     frequency and the units for this timer.  Each call to this
*     returns the time from the previous TimerInit.
*
*     The user should interpret the return value sensibly to check
*     if the result is an error or a real value.
*/

ULONG
TimerRead (
          SHORT hTimerHandle
          )
{
    NTSTATUS NtStatus;
    LARGE_INTEGER  ElapsedTime, CountPrev, LargeOverhead;

    if ((hTimerHandle > MAX_TIMERS - 1)
        || (pTimer [hTimerHandle].TUnits == TIMER_FREE))
        /* this timer has not been opened or does not exist.
           Return TIMERERR_OVERFLOW ie. 0xffffffff, the max. possible
           ULONG.  The user should interpret such a result sensibly */
        return (TIMERERR_OVERFLOW);

    NtStatus = NtQueryPerformanceCounter (&CountCurrent, NULL);
    CountPrev.LowPart  = pTimer [hTimerHandle].ulLo;
    CountPrev.HighPart = (LONG) pTimer [hTimerHandle].ulHi;
    ElapsedTime.LowPart = CountCurrent.LowPart;
    ElapsedTime.HighPart = (LONG) CountCurrent.HighPart;
    /* everything is just fine, convert to double, subtract the times,
       divide by the frequency, convert to MICROSECONDS and return
       the elapsed time as a ULONG */
    /* convert to us., divide the count by the clock frequency that
       has already been obtained */

    ElapsedTime = RtlLargeIntegerSubtract (ElapsedTime, CountPrev);

    ElapsedTime = RtlExtendedIntegerMultiply (ElapsedTime, MICROSEC_FACTOR);

    ElapsedTime = RtlExtendedLargeIntegerDivide (ElapsedTime,
                                                 PerfFreq.LowPart,
                                                 NULL);

    // if the timer is not calibrated, set ulElapsedTime to be the
    // low part of ElapsedTime.  This is because, we do not have to
    // do to any arithmetic to this before returning the value.

    if (!bCalibrated)
        ulElapsedTime = ElapsedTime.LowPart;

    /* this code is common for all platforms but OS2386.  For Win3.x
       if VTD.386 has been installed, the code below should not matter,
       since we should have returned the time by now.

       The elapsed time will be scaled, overhead subtracted
       and the time returned */

    /* we have ulElapsedTime.  Scale it and do the needful */
    /* divide or multiply by the scale factor */

    if (bCalibrated) {
        // Applications like the PROBE call TimerRead repeatedly
        // without calling TimerInit, for more than 70 minutes.  This
        // screws up things.  So treat everything as 64 bit numbers
        // until the very end.

        if ((ElapsedTime.LowPart < ulTimerOverhead) &&
            (!ElapsedTime.HighPart)) { // low part is lower than overhead
                                       // and high part is zero..then make
                                       // elapsed time 0.  We don't want
                                       // negative numbers.
            ElapsedTime.HighPart = 0L;
            ElapsedTime.LowPart = 0L;
        }

        else { // subtract the overhead in tics before converting
               // to time units
            LargeOverhead.HighPart = 0L;
            LargeOverhead.LowPart = ulTimerOverhead;

            ElapsedTime = RtlLargeIntegerSubtract (ElapsedTime,
                                                   LargeOverhead);
        }


        if (pTimer [hTimerHandle].TUnits <= MICROSECONDS) {

            ElapsedTime = RtlExtendedLargeIntegerDivide (
                                                        ElapsedTime,
                                                        aScaleValues [pTimer [hTimerHandle].TUnits],
                                                        NULL
                                                        );
        } else {
            ElapsedTime = RtlExtendedIntegerMultiply (
                                                     ElapsedTime,
                                                     aScaleValues [pTimer [hTimerHandle].TUnits]
                                                     );
        }

        // scaling is done.  Now get the time back into 32 bits.  This
        // should fit.

        ulElapsedTime = ElapsedTime.LowPart;
    }

    if ((LONG) ulElapsedTime < 0L) /* if this guy is -ve, return a 0 */
        return (0L);

    return (ulElapsedTime);
}

/*
*     Function  - TimerClose       (EXPORTED)
*     Arguments -
*               (a) SHORT - hTimerHandle
*
*     Returns  - SHORT - 0 if call successful
*                        Else, an error code if handle invalid:
*
*                            TIMERERR_INVALID_HANDLE
*
*     Releases the timer for use by future TimerOpen calls.
*     Resets the elements of the timer structure, setting the
*     Timer's Units element to TIMER_FREE.
*/

SHORT
TimerClose (
           SHORT hTimerHandle
           )
{
    if ((hTimerHandle > MAX_TIMERS - 1) ||
        (pTimer [hTimerHandle].TUnits == TIMER_FREE))
        /* error condition, wrong handle */
        return (TIMERERR_INVALID_HANDLE);

    /* otherwise, set the TimerUnits of this timer to TIMER_FREE,
       reset the other elements to zero and return */

    pTimer [hTimerHandle].TUnits = TIMER_FREE;
    pTimer [hTimerHandle].ulLo = 0L;
    pTimer [hTimerHandle].ulHi = 0L;
    return (SUCCESS_OK);
}

/*******************************************************************

     Added this routine TimerReport to report individual
     times.  Bob Day requested that such a routine be
     created.  It just maintains the time from the last
     TimerInit and TimerRead and also the last time returned.
     This routine copies this to a user specified buffer.

     Accepts - PSZ   - a pointer to a buffer to print the data out
               SHORT - timer handle

     Returns - TRUE if Timer exists and is open
             - FALSE if Timer not opened

*******************************************************************/

BOOL
FAR
PASCAL
TimerReport (
            PSZ pszReportString,
            SHORT hTimerHandle
            )
{
    if (pTimer [hTimerHandle].TUnits == TIMER_FREE)
        return (FALSE);

    /* stored value is in pTimer[hTimerHandle].ulLo and .ulHi */
    /*
    wsprintf (pszReportString,
        "Init Count (tics) %lu:%lu Current Count (tics) %lu:%lu Returned Time %lu ",
            pTimer [hTimerHandle].ulHi,
            pTimer [hTimerHandle].ulLo, CountCurrent.HighPart,
            CountCurrent.LowPart,
            ulElapsedTime);
    */
    return (TRUE);
}

/*******************************************************************

     Added this routine TimerQueryPerformanceCounter to report
     current tic count at behest of NT GDI folks.


     Accepts - PQWORD   - a pointer to a 64 bit struct. that will
                          contain tic count on return.

               PQWORD [OPTIONAL) - a pointer to a 64 bit struct. that will
                          contain frequency on return.

     Returns - None.

*******************************************************************/

VOID
FAR
PASCAL
TimerQueryPerformanceCounter (
                             PQWORD pqTic,
                             PQWORD pqFreq OPTIONAL
                             )
{

    LARGE_INTEGER TempTic, TempFreq;

    // call the NT API to do the needful and return.
    NtQueryPerformanceCounter (&TempTic, &TempFreq);
    pqTic->LowPart = TempTic.LowPart;
    pqTic->HighPart = TempTic.HighPart;
    pqFreq->LowPart = TempFreq.LowPart;
    pqFreq->HighPart = TempFreq.HighPart;

    return;
}

/*******************************************************************

     Added this routine TimerConvertTicsToUSec to return
     time in usecs. for a given elapsed tic count and freq.


     Accepts - ULONG    - Elapsed Tic Count.

               ULONG    - Frequency.

     Returns - Elapsed Time in usecs. as a ULONG.
             - Zero if input freq. is zero.

*******************************************************************/

ULONG
TimerConvertTicsToUSec (
                       ULONG ulElapsedTics,
                       ULONG ulInputFreq
                       )
{

    LARGE_INTEGER ElapsedTime;
    ULONG ulRemainder = 0L;

    // if the person gives me a zero freq, return him a zero.
    // Let him tear his hair.

    if (!ulInputFreq)
        return 0L;

    // multiply tics by a million and divide by the frequency.

    ElapsedTime = RtlEnlargedIntegerMultiply (ulElapsedTics, MICROSEC_FACTOR);

    ElapsedTime = RtlExtendedLargeIntegerDivide (ElapsedTime,
                                                 ulInputFreq,
                                                 &ulRemainder);

    ElapsedTime.LowPart += (ulRemainder > (ulInputFreq / 2L));

    return (ElapsedTime.LowPart) ; /* get the result into a ULONG */
}

/**************** ROUTINES NOT EXPORTED, FOLLOW ************************/

/*
*     Function  - CalibrateTimerForOverhead  (NOT EXPORTED)
*     Arguments - None
*     Returns   - ULONG
*
*     Calls TimerElapsedTime a few times to compute the expected
*     mean.  Calls TimerElapsedTime more number of times and
*     averages the mean out of those calls that did not exceed
*     the expected mean by 15%.
*/

ULONG
CalibrateTimerForOverhead (VOID)
{
    ULONG ulOverhead [ITER_FOR_OVERHEAD];
    ULONG ulTempTotal = 0L;
    ULONG ulExpectedValue = 0L;
    SHORT csIter;
    SHORT csNoOfSamples = ITER_FOR_OVERHEAD;
    SHORT hTimerHandle;

    if (TimerOpen (&hTimerHandle, MICROSECONDS)) /* open failed.  Return 0 */
        return (0L);

    for (csIter = 0; csIter < 5; csIter++) {
        TimerInit (hTimerHandle);
        ulOverhead [csIter] = TimerRead (hTimerHandle);
        /* if negative, make zero */
        if (((LONG) ulOverhead [csIter]) < 0)
            ulOverhead [csIter] = 0L;
    }
    /* The get elapsed time function has been called 6 times.
       The idea is to calculate the expected mean, then call
       TimerElapsedTime a bunch of times and throw away all times
       that are 15% larger than this mean.  This would give a
       really good overhead time */

    for (csIter = 0; csIter < 5; csIter++ )
        ulTempTotal += ulOverhead [csIter];

    ulExpectedValue = ulTempTotal / 5;

    for (csIter = 0; csIter < ITER_FOR_OVERHEAD; csIter++) {
        TimerInit (hTimerHandle);
        ulOverhead [csIter] = TimerRead (hTimerHandle);
        /* if negative, make zero */
        if (((LONG) ulOverhead [csIter]) < 0)
            ulOverhead [csIter] = 0L;
    }

    ulTempTotal = 0L;         /* reset this value */
    for (csIter = 0; csIter < ITER_FOR_OVERHEAD; csIter++ ) {
        if (ulOverhead [csIter] <=  (ULONG) (115L * ulExpectedValue/100L))
            /* include all samples that is < 115% of ulExpectedValue */
            ulTempTotal += ulOverhead [csIter];
        else
            /* ignore this sample and dec. sample count */
            csNoOfSamples--;
    }
    TimerClose (hTimerHandle);

    if (csNoOfSamples == 0)  /* no valid times.  Return a 0 for overhead */
        return (0L);

    return (ulTempTotal/csNoOfSamples);
}

/*
*       Function - GetTimerFreq    (NOT EXPORTED)
*
*      Arguments - None
*
*
*      Return    - 0 if successful or an error code if timer not aailable
*
*      Calls the function to return freq
*
*/
SHORT
GetTimerFreq (VOID)
{
    LARGE_INTEGER PerfCount, Freq;
    NTSTATUS NtStatus;

    NtStatus = NtQueryPerformanceCounter (&PerfCount, &Freq);

    if ((Freq.LowPart == 0L)  && (Freq.HighPart == 0L))
        /* frequency of zero implies timer not available */
        return (TIMERERR_NOT_AVAILABLE);

    PerfFreq.LowPart = Freq.LowPart;
    PerfFreq.HighPart = (LONG) Freq.HighPart;

    return 0;
}

/***************************************************

NT native dll init routine

****************************************************/
SHORT csTempCtr;    /* a counter - had to make this global..compile fails */
ULONG culTemp;      /*    - do -    */

NTSTATUS
TimerDllInitialize (
                   IN PVOID DllHandle,
                   ULONG Reason,
                   IN PCONTEXT Context OPTIONAL
                   )
{
    DllHandle, Context;     // avoid compiler warnings

    if (Reason != DLL_PROCESS_ATTACH) { // if detaching return immediately
        return TRUE;
    }

    for (csTempCtr = 0; csTempCtr < MAX_TIMERS; csTempCtr++) {
        pTimer [csTempCtr].ulLo = 0L;
        pTimer [csTempCtr].ulHi = 0L;
        pTimer [csTempCtr].TUnits = TIMER_FREE;
    }

    bTimerInit = TRUE;
    GetTimerFreq ();
    ulTimerOverhead = CalibrateTimerForOverhead ();
    /* the timer overhead will be placed in a global variable */
    bCalibrated = TRUE;
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pfmon\module.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    module.c

Abstract:

    This module maintains the module (symbol) information for the pfmon application

Author:

    Mark Lucovsky (markl) 27-Jan-1995

Revision History:

--*/

#include "pfmonp.h"

BOOL
AddModule(
    LPDEBUG_EVENT DebugEvent
    )
{
    PMODULE_INFO Module;
    LPVOID BaseAddress;
    HANDLE Handle;
    IMAGEHLP_MODULE ModuleInfo;

    if (DebugEvent->dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {
        Handle = DebugEvent->u.CreateProcessInfo.hFile;
        BaseAddress = DebugEvent->u.CreateProcessInfo.lpBaseOfImage;
    }
    else {
        Handle = DebugEvent->u.LoadDll.hFile;
        BaseAddress = DebugEvent->u.LoadDll.lpBaseOfDll;
    }

    Module = FindModuleContainingAddress(BaseAddress);

    if (Module) {
        DeleteModule(Module);
    }

    Module = LocalAlloc(LMEM_ZEROINIT, sizeof( *Module ) );

    if (Module == NULL) {
        return FALSE;
    }

    Module->Handle = Handle;
    Module->BaseAddress = BaseAddress;

    if (!Module->Handle) {
        LocalFree(Module);
        return FALSE;
    }

    if (!SymLoadModule (hProcess,Handle,NULL,NULL,(DWORD_PTR)BaseAddress,0)) {
        LocalFree(Module);
        return FALSE;
    }

    ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);
    if (!SymGetModuleInfo (hProcess, (DWORD_PTR)BaseAddress, &ModuleInfo)) {
        LocalFree(Module);
        return FALSE;
    }

    Module->VirtualSize = ModuleInfo.ImageSize;
    Module->ModuleName = _strdup(ModuleInfo.ModuleName);

    InsertTailList( &ModuleListHead, &Module->Entry );

    return TRUE;
}

BOOL
DeleteModule(
    PMODULE_INFO Module
    )
{
    CHAR Line[256];

    if ( Module ) {
        RemoveEntryList(&Module->Entry);

        sprintf(Line,"%16s Caused %6d faults had %6d Soft %6d Hard faulted VA's\n",
            Module->ModuleName ? Module->ModuleName : "Unknown",
            Module->NumberCausedFaults,
            Module->NumberFaultedSoftVas,
            Module->NumberFaultedHardVas
            );

        if ( !fLogOnly ) {
            fprintf(stdout,"%s",Line);
        }

        if ( LogFile ) {
            fprintf(LogFile,"%s",Line);
        }

        if (Module->ModuleName) {
            free (Module->ModuleName);
        }

        LocalFree(Module);
    }

    return TRUE;
}


PMODULE_INFO
FindModuleContainingAddress(
    LPVOID Address
    )
{
    PLIST_ENTRY Next;
    PMODULE_INFO Module;
    BOOL LazyLoadStatus;

    Next = ModuleListHead.Flink;
    while ( Next != &ModuleListHead ) {
        Module = CONTAINING_RECORD(Next,MODULE_INFO,Entry);
        if ( Address >= Module->BaseAddress &&
             Address < (LPVOID)((PUCHAR)(Module->BaseAddress)+Module->VirtualSize) ) {
            return Module;
        }
        Next = Next->Flink;
    }

    Module = NULL;

    //
    // if address is a kernel mode address and we have lazy loaded
    // kernel symbols, then try to load a kernel symbol file
    //

    if ( fKernel && (ULONG_PTR)Address >= SystemRangeStart && LazyModuleInformation ) {
        fKernel = FALSE;
        LazyLoadStatus = LazyLoad(Address);

        if ( LazyLoadStatus ) {
            Module = FindModuleContainingAddress(Address);
        }
        fKernel = TRUE;
    }


    return Module;
}

VOID
SetSymbolSearchPath(
    VOID
    )
{
    LPSTR lpSymPathEnv, lpAltSymPathEnv, lpSystemRootEnv;
    ULONG cbSymPath;
    DWORD dw;

    cbSymPath = 18;
    if (lpSymPathEnv = getenv("_NT_SYMBOL_PATH")) {
        cbSymPath += strlen(lpSymPathEnv) + 1;
    }
    if (lpAltSymPathEnv = getenv("_NT_ALT_SYMBOL_PATH")) {
        cbSymPath += strlen(lpAltSymPathEnv) + 1;
    }

    if (lpSystemRootEnv = getenv("SystemRoot")) {
        cbSymPath += strlen(lpSystemRootEnv) + 1;
    }

    SymbolSearchPath = LocalAlloc(LMEM_ZEROINIT,cbSymPath);
    if (!SymbolSearchPath) {
        return;
    }

    if (lpAltSymPathEnv) {
        dw = GetFileAttributes(lpAltSymPathEnv);
        if ( dw != 0xffffffff && dw & FILE_ATTRIBUTE_DIRECTORY ) {
            strcat(SymbolSearchPath,lpAltSymPathEnv);
            strcat(SymbolSearchPath,";");
        }
    }
    if (lpSymPathEnv) {
        dw = GetFileAttributes(lpSymPathEnv);
        if ( dw != 0xffffffff && dw & FILE_ATTRIBUTE_DIRECTORY ) {
            strcat(SymbolSearchPath,lpSymPathEnv);
            strcat(SymbolSearchPath,";");
        }
    }

    if (lpSystemRootEnv) {
        dw = GetFileAttributes(lpSystemRootEnv);
        if ( dw != 0xffffffff && dw & FILE_ATTRIBUTE_DIRECTORY ) {
            strcat(SymbolSearchPath,lpSystemRootEnv);
            strcat(SymbolSearchPath,";");
        }
    }

    strcat(SymbolSearchPath,".;");
}


LONG
AddKernelDrivers(VOID)

/************************************************************\
This function is used to load the symbol information for
the system files that are loaded so that the page faults
in the kernal can be displayed.

Setting of the environmental variables are important for
ensuring that the symbols load up correctly.

returns: The success of the function
\*************************************************************/


{

    NTSTATUS status;
    PVOID pModuleInfo;
    ULONG lDataSize;
    ULONG lRetSize;
    PRTL_PROCESS_MODULES pModuleInformation;


    //First we need to get a list of all the modules currently
    //running

    //Allocate an initial sized buffer

    lDataSize = 1024 * 12;
    pModuleInfo = (PVOID) LocalAlloc (LMEM_FIXED, lDataSize);

    if (!pModuleInfo) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //Keep querying the system and incrementing the
    //size of the buffer until we can get all the information back

    do {
        //Query for modules loaded up

        status = NtQuerySystemInformation(SystemModuleInformation,
                                          pModuleInfo,
                                          lDataSize,
                                          &lRetSize);


        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            LocalFree (pModuleInfo);
            lDataSize += 1024 * 4;
            pModuleInfo = (PVOID) LocalAlloc (LMEM_FIXED, lDataSize);
        }

        if (!pModuleInfo) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    LazyModuleInformation = (PRTL_PROCESS_MODULES) pModuleInfo;

    return 1;
}



BOOL
LazyLoad(
    LPVOID Address
    )
{
    PRTL_PROCESS_MODULES pModuleInformation;
    DWORD i;
    BYTE szImageFilePath[ MAX_PATH ];
    PMODULE_INFO Module;
    ULONG_PTR BaseAddress;
    HANDLE hFile;
    LPSTR szFileName;
    IMAGEHLP_MODULE ModuleInfo;

    pModuleInformation = (PRTL_PROCESS_MODULES) LazyModuleInformation;

    //Loop through all the items in the structure and
    //and add their symbols to the module structures kept by pfmon.

    for (i = 0; i < pModuleInformation->NumberOfModules; i += 1) {

        BaseAddress = (ULONG_PTR)pModuleInformation->Modules[i].ImageBase;

        //Only look at the kernel space modules

        if (BaseAddress >= SystemRangeStart) {

            if ( (ULONG_PTR)Address > BaseAddress &&
                 (ULONG_PTR)Address <= BaseAddress+pModuleInformation->Modules[i].ImageSize ) {

                szFileName = pModuleInformation->Modules[i].FullPathName +
                             pModuleInformation->Modules[i].OffsetToFileName;

                strcpy (szImageFilePath,
                        pModuleInformation->Modules[i].FullPathName);

                hFile = FindExecutableImage (szFileName,
                                             SymbolSearchPath,
                                             (PCHAR) szImageFilePath );

                if (!hFile) {
                    fprintf(stdout,"Failed to get Executable Image - ");
                    return FALSE;
                }

                //Check to make sure this hasn't already been loaded

                Module = FindModuleContainingAddress((LPVOID)BaseAddress);

                if ( Module ) {
                    fprintf(stdout,"Item has been loaded already: %s",szFileName);
                    DeleteModule(Module);
                }

                //Now create the module record and fill in its fields

                Module = LocalAlloc(LMEM_ZEROINIT, sizeof( *Module ) );

                if (Module == NULL) {
                    return FALSE;
                }

                Module->Handle = hFile;
                Module->BaseAddress = (LPVOID)BaseAddress;

                if (!SymLoadModule (hProcess, hFile, NULL, NULL, BaseAddress, 0)) {
                    LocalFree(Module);
                    fprintf(stdout, "Failed to load -- ");
                    return FALSE;
                }

                ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);
                if (!SymGetModuleInfo (hProcess, BaseAddress, &ModuleInfo)) {
                    LocalFree(Module);
                    fprintf(stdout, "Failed to load -- ");
                    return FALSE;
                }

                Module->VirtualSize = ModuleInfo.ImageSize;

                fprintf(stdout, "Loaded %s, size %u\n", szImageFilePath, Module->VirtualSize);

                InsertTailList( &ModuleListHead, &Module->Entry );

                CloseHandle(hFile);

                return TRUE;
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pfmon\error.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    error.c

Abstract:

    Error handle module for the pfmon program

Author:

    Mark Lucovsky (markl) 26-Jan-1995

Revision History:

--*/

#include "pfmonp.h"

VOID
__cdecl
DeclareError(
    UINT ErrorCode,
    UINT SupplementalErrorCode,
    ...
    )
{
    va_list arglist;
    HMODULE ModuleHandle;
    DWORD Flags, Size;
    UCHAR MessageBuffer[ 512 ];

    va_start( arglist, SupplementalErrorCode );

    if ((ErrorCode & 0x0FFF0000) >> 16 == FACILITY_APPLICATION) {
        ModuleHandle = PfmonModuleHandle;
        Flags = FORMAT_MESSAGE_FROM_HMODULE;
        }
    else {
        ModuleHandle = NULL;
        Flags = FORMAT_MESSAGE_FROM_SYSTEM;
        }

    Size = FormatMessage( Flags,
                          (LPCVOID)ModuleHandle,
                          ErrorCode,
                          0,
                          MessageBuffer,
                          sizeof( MessageBuffer ),
                          &arglist
                        );
    va_end( arglist );

    if (Size != 0) {
        fprintf( stderr, "PFMON: %s", MessageBuffer );
        }
    else {
        fprintf( stderr, "PFMON: Unable to get message text for %08x\n", ErrorCode );
        }

    if (ModuleHandle == PfmonModuleHandle &&
        SupplementalErrorCode != 0 &&
        SupplementalErrorCode != ERROR_GEN_FAILURE
       ) {

        ModuleHandle = NULL;
        Flags = FORMAT_MESSAGE_FROM_SYSTEM;
        Size = FormatMessage( Flags,
                              (LPCVOID)ModuleHandle,
                              SupplementalErrorCode,
                              0,
                              MessageBuffer,
                              sizeof( MessageBuffer ),
                              NULL
                            );
        if (Size != 0) {
            while (Size != 0 && MessageBuffer[ Size ] <= ' ') {
                MessageBuffer[ Size ] = '\0';
                Size -= 1;
                }

            printf( "          '%s'\n", MessageBuffer );
            }
        else {
            printf( "PFMON: Unable to get message text for %08x\n", SupplementalErrorCode );
            }
        }



    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pfmon\init.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This is the initialization module for the pfmon program.

Author:

    Mark Lucovsky (markl) 26-Jan-1995

Revision History:

--*/

#include "pfmonp.h"

BOOL
InitializePfmon( VOID )
{
    LPTSTR CommandLine;
    BOOL fShowUsage;
    DWORD Pid = 0;

    fShowUsage = FALSE;
    CommandLine = GetCommandLine();
    while (*CommandLine > ' ') {
        CommandLine += 1;
    }
    while (TRUE) {
        while (*CommandLine <= ' ') {
            if (*CommandLine == '\0') {
                break;
            } else {
                CommandLine += 1;
            }
        }

        if (!_strnicmp( CommandLine, "/v", 2 ) || !_strnicmp( CommandLine, "-v", 2 )) {
            CommandLine += 2;
            fVerbose = TRUE;
        } else if (!_strnicmp( CommandLine, "/?", 2 ) || !_strnicmp( CommandLine, "-?", 2 )) {
            CommandLine += 2;
            fShowUsage = TRUE;
            goto showusage;
        } else if (!_strnicmp( CommandLine, "/c", 2 ) || !_strnicmp( CommandLine, "-c", 2 )) {
            CommandLine += 2;
            fCodeOnly = TRUE;
        } else if (!_strnicmp( CommandLine, "/h", 2 ) || !_strnicmp( CommandLine, "-h", 2 )) {
            CommandLine += 2;
            fHardOnly = TRUE;
        } else if (!_strnicmp( CommandLine, "/n", 2 ) || !_strnicmp( CommandLine, "-n", 2 )) {
            CommandLine += 2;
            LogFile = fopen("pfmon.log","wt");
            fLogOnly = TRUE;
        } else if (!_strnicmp( CommandLine, "/l", 2 ) || !_strnicmp( CommandLine, "-l", 2 )) {
            CommandLine += 2;
            LogFile = fopen("pfmon.log","wt");
        } else if (!_strnicmp( CommandLine, "/p", 2 ) || !_strnicmp( CommandLine, "-p", 2 )) {
            CommandLine += 2;
            while (*CommandLine <= ' ') {
                if (*CommandLine == '\0') {
                    break;
                } else {
                    ++CommandLine;
                }
            }
            Pid = atoi(CommandLine);
            CommandLine = strchr(CommandLine,' ');
            if (CommandLine==NULL) {
                break;
            }
        } else if (!strncmp( CommandLine, "/k", 2 ) || !strncmp( CommandLine, "-k", 2 )) {
            CommandLine += 2;
            fKernel = TRUE;
            fKernelOnly = FALSE;
        } else if (!strncmp( CommandLine, "/K", 2 ) || !strncmp( CommandLine, "-K", 2 )) {
            CommandLine += 2;
            fKernel = TRUE;
            fKernelOnly = TRUE;
        } else if (!_strnicmp( CommandLine, "/d", 2 ) || !_strnicmp( CommandLine, "-d", 2 )) {
            CommandLine += 2;
            fDatabase = TRUE;
        } else {
            break;
        }
    }
showusage:
    if ( fShowUsage ) {
        fputs("Usage: PFMON [switches] application-command-line\n"
              "             [-?] display this message\n"
              "             [-n] don't display running faults, just log to pfmon.log\n"
              "             [-l] log faults to pfmon.log\n"
              "             [-c] only show code faults\n"
              "             [-h] only show hard faults\n"
              "             [-p pid] attach to existing process\n"
              "             [-d] Database format (tab delimited)\n"
              "                  format: pagefault number, Page Fault type (Hard or Soft),\n"
              "                  Program Counter's Module, Symbol for PC, Decimal value of PC,\n"
              "                  Decimal value of PC, Module of the virtual address accessed,\n"
              "                  Symbol for VA, value of VA\n"
              "             [-k] kernel mode page faults and user mode page faults\n"
              "             [-K] kernel mode page faults instead of user mode\n",
              stdout);
        return FALSE;
        };

    InitializeListHead( &ProcessListHead );
    InitializeListHead( &ModuleListHead );
    SetSymbolSearchPath();
    if (!NT_SUCCESS(NtQuerySystemInformation(SystemRangeStartInformation,
                                             &SystemRangeStart,
                                             sizeof(SystemRangeStart),
                                             NULL))) {
        // Assume usermode is the low half of the address space
        SystemRangeStart = (ULONG_PTR)MAXLONG_PTR;
    }

    PfmonModuleHandle = GetModuleHandle( NULL );

    if (Pid != 0) {
        return(AttachApplicationForDebug(Pid));
    } else {
        return (LoadApplicationForDebug( CommandLine ));
    }

    return TRUE;
}

BOOL
LoadApplicationForDebug(
    LPSTR CommandLine
    )
{
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;

    ZeroMemory( &StartupInfo, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof(StartupInfo);

    if (!CreateProcess( NULL,
                        CommandLine,
                        NULL,
                        NULL,
                        FALSE,                          // No handles to inherit
                        DEBUG_PROCESS,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInformation)) {
        DeclareError( PFMON_CANT_DEBUG_PROGRAM,
                      GetLastError(),
                      CommandLine
                    );
        return FALSE;
    } else {
        hProcess = ProcessInformation.hProcess;
        SymInitialize(hProcess,NULL,FALSE);

        if (fKernel) {
            AddKernelDrivers();
            }

        return InitializeProcessForWsWatch(hProcess);
    }
}

BOOL
NtsdDebugActiveProcess (
    DWORD dwPidToDebug
    )
{
#ifdef CHICAGO
    BOOL                b;

    b = DebugActiveProcess(dwPidToDebug);

    return( b );
#else
    HANDLE              Token;
    PTOKEN_PRIVILEGES   NewPrivileges;
    BYTE                OldPriv[1024];
    PBYTE               pbOldPriv;
    ULONG               cbNeeded;
    BOOL                b;
    BOOL                fRc;
    LUID                LuidPrivilege;

    //
    // Make sure we have access to adjust and to get the old token privileges
    //
    if (!OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &Token)) {

        return( FALSE );

    }

    cbNeeded = 0;

    //
    // Initialize the privilege adjustment structure
    //

    LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &LuidPrivilege );

    NewPrivileges = (PTOKEN_PRIVILEGES)calloc(1,sizeof(TOKEN_PRIVILEGES) +
                                              (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if (NewPrivileges == NULL) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

    pbOldPriv = OldPriv;
    fRc = AdjustTokenPrivileges( Token,
                                 FALSE,
                                 NewPrivileges,
                                 1024,
                                 (PTOKEN_PRIVILEGES)pbOldPriv,
                                 &cbNeeded );

    if (!fRc) {

        //
        // If the stack was too small to hold the privileges
        // then allocate off the heap
        //
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            pbOldPriv = calloc(1,cbNeeded);
            if (pbOldPriv == NULL) {
                CloseHandle(Token);
                return(FALSE);
            }

            fRc = AdjustTokenPrivileges( Token,
                                         FALSE,
                                         NewPrivileges,
                                         cbNeeded,
                                         (PTOKEN_PRIVILEGES)pbOldPriv,
                                         &cbNeeded );
        }
    }

    b = DebugActiveProcess(dwPidToDebug);

    CloseHandle( Token );

    return( b );
#endif
}






BOOL
AttachApplicationForDebug(
    DWORD Pid
    )
{
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;

    if (!NtsdDebugActiveProcess(Pid)) {
        DeclareError( PFMON_CANT_DEBUG_ACTIVE_PROGRAM,
                      GetLastError(),
                      Pid );
        return FALSE;
    } else {
        hProcess = OpenProcess(PROCESS_VM_READ
                               | PROCESS_QUERY_INFORMATION
                               | PROCESS_SET_INFORMATION,
                               FALSE,
                               Pid);
        SymInitialize(hProcess,NULL,FALSE);

        if (fKernel) {
            AddKernelDrivers();
            }

        return InitializeProcessForWsWatch(hProcess);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pfmon\pfmon.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pfmon.c

Abstract:

    USAGE: pfmon [pfmon switches] command-line-of-application


Author:

    Mark Lucovsky (markl) 26-Jan-1995

--*/

#include "pfmonp.h"

#define WORKING_SET_BUFFER_ENTRYS 4096
PSAPI_WS_WATCH_INFORMATION WorkingSetBuffer[WORKING_SET_BUFFER_ENTRYS];

#define MAX_SYMNAME_SIZE  1024
CHAR PcSymBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL PcSymbol = (PIMAGEHLP_SYMBOL) PcSymBuffer;
CHAR VaSymBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL VaSymbol = (PIMAGEHLP_SYMBOL) VaSymBuffer;

#if defined (_WIN64)
#define ZERO_PTR "%016I64x"
#define ZEROD_PTR "%I64u"
#else
#define ZERO_PTR "%08x"
#define ZEROD_PTR "%u"
#endif

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nShowCmd
    )
{
    CHAR Line[256];

    if (!InitializePfmon()) {
        ExitProcess( 1 );
        }
    else {
        DebugEventLoop();
        sprintf(Line,"\n PFMON: Total Faults %d  (KM %d UM %d Soft %d, Hard %d, Code %d, Data %d)\n",
            TotalSoftFaults + TotalHardFaults,
            TotalKernelFaults,
            TotalUserFaults,
            TotalSoftFaults,
            TotalHardFaults,
            TotalCodeFaults,
            TotalDataFaults
            );
        fprintf(stdout,"%s",Line);
        if ( LogFile ) {
            fprintf(LogFile,"%s",Line);
            fclose(LogFile);
            }
        ExitProcess( 0 );
        }

    return 0;
}

VOID
ProcessPfMonData(
    VOID
    )
{
    BOOL b;
    BOOL DidOne;
    INT i;
    PMODULE_INFO PcModule;
    PMODULE_INFO VaModule;
    ULONG_PTR PcOffset;
    DWORD_PTR VaOffset;
    CHAR PcLine[256];
    CHAR VaLine[256];
    CHAR PcModuleStr[256];
    CHAR VaModuleStr[256];
    LPVOID Pc;
    LPVOID Va;
    BOOL SoftFault;
    BOOL CodeFault;
    BOOL KillLog;
    static int cPfCnt = 0;



    PcSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    PcSymbol->MaxNameLength = MAX_SYMNAME_SIZE;
    VaSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    VaSymbol->MaxNameLength = MAX_SYMNAME_SIZE;

    //Get the buffer of recent page faults from the process's data structure
    b = GetWsChanges(hProcess,&WorkingSetBuffer[0],sizeof(WorkingSetBuffer));


    if ( b ) {
        DidOne = FALSE;
        i = 0;
        while (WorkingSetBuffer[i].FaultingPc) {
            if ( WorkingSetBuffer[i].FaultingVa ) {
                Pc = WorkingSetBuffer[i].FaultingPc;
                Va = WorkingSetBuffer[i].FaultingVa;


                if ( (ULONG_PTR)Pc >= SystemRangeStart ) {
                    TotalKernelFaults++;
                    if ( !fKernel ) {
                        i++;
                        continue;
                        }
                    }
                else {
                    TotalUserFaults++;
                    if ( fKernelOnly ) {
                        i++;
                        continue;
                        }
                    }

                //Check least sig bit which stores whether it was a hard
                //or soft fault

                if ( (ULONG_PTR)Va & 1 ) {
                    TotalSoftFaults++;
                    SoftFault = TRUE;
                    }
                else {
                    TotalHardFaults++;
                    SoftFault = FALSE;
                    }

                Va = (LPVOID)( (ULONG_PTR)Va & ~1);
                if ( (LPVOID)((ULONG_PTR)Pc & ~1) == Va ) {
                    CodeFault = TRUE;
                    TotalCodeFaults++;
                    }
                else {
                    TotalDataFaults++;
                    CodeFault = FALSE;
                    }


                PcModule = FindModuleContainingAddress(Pc);
                VaModule = FindModuleContainingAddress(Va);

                if ( PcModule ) {
                    PcModule->NumberCausedFaults++;
                    sprintf(PcModuleStr, "%s", PcModule->ModuleName);
                    }
                else {
                    sprintf(PcModuleStr,"not found %p",Pc);
                    PcModuleStr[0] = '\0';
                    }

                //Va was either a code reference or global
                //reference as opposed to a heap reference

                if ( VaModule ) {
                    if ( SoftFault ) {
                        VaModule->NumberFaultedSoftVas++;
                        }
                    else {
                        VaModule->NumberFaultedHardVas++;
                        }
                    sprintf(VaModuleStr, "%s", VaModule->ModuleName);
                    }
                else
                    VaModuleStr[0] = '\0';

                if (SymGetSymFromAddr(hProcess, (ULONG_PTR)Pc, &PcOffset, PcSymbol)) {
                    if ( PcOffset ) {
                        sprintf(PcLine,"%s+0x%x",PcSymbol->Name,PcOffset);
                        }
                    else {
                        sprintf(PcLine,"%s",PcSymbol->Name);
                        }
                    }
                else {
                    sprintf(PcLine,""ZERO_PTR"",Pc);
                    }

                if (SymGetSymFromAddr(hProcess, (ULONG_PTR)Va, &VaOffset, VaSymbol)) {
                    if ( VaOffset ) {
                        sprintf(VaLine,"%s+0x%p",VaSymbol->Name,VaOffset);
                        }
                    else {
                        sprintf(VaLine,"%s",VaSymbol->Name);
                        }
                    }
                else {
                    sprintf(VaLine,""ZERO_PTR"",Va);
                    }

                KillLog = FALSE;

                if ( fCodeOnly && !CodeFault ) {
                    KillLog = TRUE;
                    }
                if ( fHardOnly && SoftFault ) {
                    KillLog = TRUE;
                    }

                if ( !KillLog ) {
                    if ( !fLogOnly ) {
                        if (!fDatabase) {
                            fprintf(stdout,"%s%s : %s\n",SoftFault ? "SOFT: " : "HARD: ",PcLine,VaLine);
                            }
                        else {

                            //Addresses are printed out in decimal
                            //because most databases don't support
                            //hex formats

                            fprintf(stdout,"%8d\t%s\t%s\t%s\t"ZEROD_PTR"\t%s\t%s\t"ZEROD_PTR"\n",
                                    cPfCnt,
                                    SoftFault ? "SOFT" : "HARD",
                                    PcModuleStr,
                                    PcLine,
                                    (DWORD_PTR) Pc,
                                    VaModuleStr,
                                    VaLine,
                                    (DWORD_PTR) Va);
                            }
                        }

                    if ( LogFile ) {
                        if (!fDatabase) {
                            fprintf(LogFile,"%s%s : %s\n",SoftFault ? "SOFT: " : "HARD: ",PcLine,VaLine);
                            }
                        else {
                            fprintf(LogFile,"%8d\t%s\t%s\t%s\t"ZEROD_PTR"\t%s\t%s\t"ZEROD_PTR"\n",
                                    cPfCnt,
                                    SoftFault ? "SOFT" : "HARD",
                                    PcModuleStr,
                                    PcLine,
                                    (DWORD_PTR) Pc,
                                    VaModuleStr,
                                    VaLine,
                                    (DWORD_PTR) Va);
                            }
                        }
                    DidOne = TRUE;
                    cPfCnt++;
                    }
                }
            i++;
            }

        if ( DidOne ) {
            if ( !fLogOnly  && !fDatabase) {
                fprintf(stdout,"\n");
                }
            }

        //If the buffer overflowed then a non-zero value for
        //the Va was stored in the last record.
        if (WorkingSetBuffer[i].FaultingVa)
            fprintf(stdout,"Warning: Page fault buffer has overflowed\n");
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pnpinit\makefile.inc ===
$(O)\pnpinit.res: pnpinit.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pfmon\process.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module maintains state about each process/thread created by the application
    pfmon program.

Author:

    Mark Lucovsky (markl) 26-Jan-1995

Revision History:

--*/

#include "pfmonp.h"

BOOL
AddProcess(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO *ReturnedProcess
    )
{
    PPROCESS_INFO Process;

    Process = LocalAlloc(LMEM_ZEROINIT, sizeof( *Process ) );
    if (Process == NULL) {
        return FALSE;
        }

    Process->Id = DebugEvent->dwProcessId;
    Process->Handle = DebugEvent->u.CreateProcessInfo.hProcess;
    InitializeListHead( &Process->ThreadListHead );
    InsertTailList( &ProcessListHead, &Process->Entry );
    *ReturnedProcess = Process;

    return TRUE;
}

BOOL
DeleteProcess(
    PPROCESS_INFO Process
    )
{
    PLIST_ENTRY Next, Head;
    PTHREAD_INFO Thread;
    PMODULE_INFO Module;
    CHAR Line[256];

    RemoveEntryList( &Process->Entry );

    Head = &Process->ThreadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Thread = CONTAINING_RECORD( Next, THREAD_INFO, Entry );
        Next = Next->Flink;
        DeleteThread( Process, Thread );
        }

    LocalFree( Process );
    fprintf(stdout,"\n");

    Next = ModuleListHead.Flink;
    while ( Next != &ModuleListHead ) {
        Module = CONTAINING_RECORD(Next,MODULE_INFO,Entry);


        sprintf(Line,"%16s Caused %6d faults had %6d Soft %6d Hard faulted VA's\n",
            Module->ModuleName,
            Module->NumberCausedFaults,
            Module->NumberFaultedSoftVas,
            Module->NumberFaultedHardVas
            );
        if ( !fLogOnly ) {
            fprintf(stdout,"%s",Line);
            }
        if ( LogFile ) {
            fprintf(LogFile,"%s",Line);
            }

        Next = Next->Flink;
        }


    return TRUE;
}


BOOL
AddThread(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO Process,
    PTHREAD_INFO *ReturnedThread
    )
{
    PTHREAD_INFO Thread;

    Thread = LocalAlloc(LMEM_ZEROINIT, sizeof( *Thread ) );
    if (Thread == NULL) {
        return FALSE;
        }

    Thread->Id = DebugEvent->dwThreadId;
    if (DebugEvent->dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {
        Thread->Handle = DebugEvent->u.CreateProcessInfo.hThread;
        Thread->StartAddress = DebugEvent->u.CreateProcessInfo.lpStartAddress;
        }
    else {
        Thread->Handle = DebugEvent->u.CreateThread.hThread;
        Thread->StartAddress = DebugEvent->u.CreateThread.lpStartAddress;
        }
    InsertTailList( &Process->ThreadListHead, &Thread->Entry );
    *ReturnedThread = Thread;
    return TRUE;
}

BOOL
DeleteThread(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    )
{

    RemoveEntryList( &Thread->Entry );

    LocalFree( Thread );
    return TRUE;
}


PPROCESS_INFO
FindProcessById(
    ULONG Id
    )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_INFO Process;

    Head = &ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_INFO, Entry );
        if (Process->Id == Id) {
            return Process;
            }

        Next = Next->Flink;
        }

    return NULL;
}

BOOL
FindProcessAndThreadForEvent(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO *ReturnedProcess,
    PTHREAD_INFO *ReturnedThread
    )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_INFO Process;
    PTHREAD_INFO Thread;

    Head = &ProcessListHead;
    Next = Head->Flink;
    Process = NULL;
    Thread = NULL;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_INFO, Entry );
        if (Process->Id == DebugEvent->dwProcessId) {
            Head = &Process->ThreadListHead;
            Next = Head->Flink;
            while (Next != Head) {
                Thread = CONTAINING_RECORD( Next, THREAD_INFO, Entry );
                if (Thread->Id == DebugEvent->dwThreadId) {
                    break;
                    }

                Thread = NULL;
                Next = Next->Flink;
                }

            break;
            }

        Process = NULL;
        Next = Next->Flink;
        }

    *ReturnedProcess = Process;
    *ReturnedThread = Thread;

    if (DebugEvent->dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {
        if (Process != NULL) {
            DeclareError( PFMON_DUPLICATE_PROCESS_ID, 0, DebugEvent->dwProcessId );
            return FALSE;
            }
        }
    else
    if (DebugEvent->dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT) {
        if (Thread != NULL) {
            DeclareError( PFMON_DUPLICATE_THREAD_ID, 0, DebugEvent->dwThreadId, DebugEvent->dwProcessId );
            return FALSE;
            }
        if (Process == NULL) {
            DeclareError( PFMON_MISSING_PROCESS_ID, 0, DebugEvent->dwProcessId );
            return FALSE;
            }
        }
    else
    if (Process == NULL) {
        DeclareError( PFMON_MISSING_PROCESS_ID, 0, DebugEvent->dwProcessId );
        return FALSE;
        }
    else
    if (Thread == NULL) {
        DeclareError( PFMON_MISSING_THREAD_ID, 0, DebugEvent->dwThreadId, DebugEvent->dwProcessId );
        return FALSE;
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pfmon\pfmonp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    instaler.h

Abstract:

    Main include file for the INSTALER application.

Author:

    Steve Wood (stevewo) 09-Aug-1994

Revision History:

--*/

#ifdef RC_INVOKED
#include <windows.h>
#else

#include "nt.h"
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stddef.h>
#include <dbghelp.h>
#include <psapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "errormsg.h"

//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOL
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
// Data structures and entry points in init.c
//

DWORD TotalSoftFaults;
DWORD TotalHardFaults;
DWORD TotalCodeFaults;
DWORD TotalDataFaults;
DWORD TotalKernelFaults;
DWORD TotalUserFaults;

BOOL fCodeOnly;
BOOL fHardOnly;

ULONG_PTR SystemRangeStart;

VOID
ProcessPfMonData(
    VOID
    );

//
// Data structures and entry points in init.c
//

BOOL fVerbose;
BOOL fLogOnly;
BOOL fKernelOnly;                 //flag for displaying kernel pagefaults
BOOL fKernel;                     //flag for displaying kernel pagefaults
BOOL fDatabase;                   //flag for outputing information in a
                                  //tab-delimited database format
FILE *LogFile;

BOOL
InitializePfmon(
    VOID
    );

BOOL
LoadApplicationForDebug(
    LPSTR CommandLine
    );

BOOL
AttachApplicationForDebug(
    DWORD Pid
    );

HANDLE hProcess;

//
// Data structures and entry points in error.c
//

HANDLE PfmonModuleHandle;

VOID
__cdecl
DeclareError(
    UINT ErrorCode,
    UINT SupplementalErrorCode,
    ...
    );

//
// Data structures and entry points in DEBUG.C
//

VOID
DebugEventLoop( VOID );

//
// Data structures and entry points in process.c
//

typedef struct _PROCESS_INFO {
    LIST_ENTRY Entry;
    LIST_ENTRY ThreadListHead;
    DWORD Id;
    HANDLE Handle;
} PROCESS_INFO, *PPROCESS_INFO;

typedef struct _THREAD_INFO {
    LIST_ENTRY Entry;
    DWORD Id;
    HANDLE Handle;
    PVOID StartAddress;
} THREAD_INFO, *PTHREAD_INFO;

LIST_ENTRY ProcessListHead;

BOOL
AddProcess(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO *ReturnedProcess
    );

BOOL
DeleteProcess(
    PPROCESS_INFO Process
    );

BOOL
AddThread(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO Process,
    PTHREAD_INFO *ReturnedThread
    );

BOOL
DeleteThread(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    );

PPROCESS_INFO
FindProcessById(
    ULONG Id
    );

BOOL
FindProcessAndThreadForEvent(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO *ReturnedProcess,
    PTHREAD_INFO *ReturnedThread
    );
//
// Data structures and entry points in module.c
//

typedef struct _MODULE_INFO {
    LIST_ENTRY Entry;
    LPVOID BaseAddress;
    DWORD VirtualSize;
    DWORD NumberFaultedSoftVas;
    DWORD NumberFaultedHardVas;
    DWORD NumberCausedFaults;
    HANDLE Handle;
    LPTSTR ModuleName;
} MODULE_INFO, *PMODULE_INFO;

LPSTR SymbolSearchPath;
LIST_ENTRY ModuleListHead;

BOOL
LazyLoad(
    LPVOID Address
    );

PRTL_PROCESS_MODULES LazyModuleInformation;

BOOL
AddModule(
    LPDEBUG_EVENT DebugEvent
    );

BOOL
DeleteModule(
    PMODULE_INFO Module
    );

PMODULE_INFO
FindModuleContainingAddress(
    LPVOID Address
    );

VOID
SetSymbolSearchPath( );

LONG
AddKernelDrivers( );


#if defined(_ALPHA_) || defined(_AXP64_)
#define BPSKIP 4
#elif defined(_X86_)
#define BPSKIP 1
#elif defined(_AMD64_)
#define BPSKIP 1
#elif defined(_IA64_)
#define BPSKIP 8
#endif // _ALPHA_

#endif // defined( RC_INVOKED )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pnpinit\pnpinit.c ===
#include <windows.h>
#include <stdlib.h>

int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    FARPROC           lpProc;
    HMODULE           hLib = NULL;
    BOOL              Result = FALSE;

    //
    // load the client-side user-mode PnP manager DLL
    //
    hLib = LoadLibrary(TEXT("cfgmgr32.dll"));
    if (hLib != NULL) {
        lpProc = GetProcAddress( hLib, "CMP_Report_LogOn" );
        if (lpProc != NULL) {
            //
            // Ping the user-mode pnp manager -
            // pass the private id as a parameter
            //
            Result = (lpProc)(0x07020420, GetCurrentProcessId()) ? TRUE : FALSE;
            }

        FreeLibrary( hLib );
        }

    if (Result)
        return 0;
    else
        return 1 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ppr\lpfile.c ===
/*
 *	File handling for LPR
 *
 *	Read from an init file.
 *	Read from a file, expanding tabs.
 */

#include <windef.h>
#include <stdio.h>
#include <string.h>
#include "lpr.h"


extern BOOL fVerify; /* From lpr.c - for verifying our progression */

#define cchIniMax 80		/* length of line in tools.ini file	   */
#define cchPathMax 128          /* maximum length of USER env var.	   */




/* from fgetl.c - expand tabs and return lines w/o separators */

int colTab = 8;		/* Tab stops every colTab columns */



char* __cdecl fgetl(sz, cch, fh)
/* returns line from file (no CRLFs); returns NULL if EOF */
/* Maps nulls read in into .'s */
char *sz;
int cch;
FILE *fh;
    {
    register int c;
    register char *p;

    /* remember NUL at end */
    cch--;
    p = sz;
    while (cch)
	{
        c = getc(fh);
        if (c == EOF || c == '\n')
            break;
        if (c != '\r')
            if (c != '\t')
		{
		*p++ = (char)((unsigned)c ? (unsigned)c : (unsigned)'.');
		cch--;
		}
            else
		{
                c = (int)(min(colTab - ((p-sz) % colTab), cch));
                memset(p, ' ', c);
                p += c;
                cch -= c;
                }
        }
    *p = 0;
    return (!( (c == EOF) && (p == sz) )) ? sz : NULL;
    }




char *SzFindPath(szDirlist, szFullname, szFile)
/* SzFindPath -- Creates szFullname from first entry in szDirlist and szFile.
 *		 The remaining directory list is returned.  If the directory
 *		 list is empty, NULL is returned.
 */
char *szDirlist;
char *szFullname;
char *szFile;
	{
#define chDirSep ';'	/* seperator for entries in directory list */
#define chDirDelim '\\'	/* end of directory name character	   */

	register char *pch;
	register char *szRc;		    /* returned directory list	*/

	if ((pch = strchr(szDirlist, chDirSep)) != 0)
		{
                *pch = (char)NULL; /* replace ';' with null */
		szRc = pch + 1;
		}
	else
		{
		pch  = strchr(szDirlist,'\0');
		szRc = NULL;
		}

        strcpy(szFullname,szDirlist);
        if (szRc != NULL) {
            /* We MUST restore the input string */
            *(szRc-1) = chDirSep;
        }

	/* if directory name doesn't already end with chDirDelim, append it */
	if (*(pch-1) != chDirDelim)
		{
		pch    = szFullname + strlen(szFullname);
		*pch++ = chDirDelim;
                *pch   = (char)NULL;
		}

	strcat(szFullname,szFile);

	return(szRc);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ppr\lppage.c ===
/*
 *   lppage.c - page formatting
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <direct.h>
#include <tools.h>
#include <time.h>
#include "lpr.h"

#define ESC '\033'

BOOL        fPageTop = TRUE;            /* TRUE => printer at top of page     */
BOOL        fFirstFile = TRUE;          /* TRUE => first file to be printed   */

/* information for formated page */
BOOL        fInit;                      /* TRUE => valid info in page         */
int         iPage;                      /* current page being processed       */
int         rowLine;                    /* row for next line                  */
int         iLine;                      /* number of current line             */
char        szFFile[MAX_PATH];         /* full path of file being displayed  */
char        szFTime[50];                /* ascii timestamp for file           */
char        szUsr[MAX_PATH];           /* name of user                       */
char        szCompany[] = COMPANY;
char        szConf[] = CONFIDENTIAL;

extern USHORT usCodePage;

/* Specifics about ctime */
#define cchDateMax 16
#define cchTimeMax 10

/* Maximum length in a short file name */
/* Shape of the banner */
#define crowBanner   30
#define ccolBanner  102



void BannerSz(szFName, cBanOut)
char    *szFName;
int cBanOut;            /* number to output; will be > 0 */
    {
#define CenterCol(sz) (col + ((ccolBanner - (strlen(sz) << 3)) >> 1))
#define cchFShort 12
#define cchPShort 28
#define cchUsrShort 12          /* length username block can be on banner */

    int     row;                /* Position of the banner */
    int     col;
    char    szDate[cchDateMax];
    char    szTime[cchTimeMax];
    char    szPath[MAX_PATH];
    char    szConfid[sizeof(szCompany) + sizeof(szConf)];
    char    szFNShort[cchFShort + 1];   /* To shorten the file name */
                                        /* only up to 12 chars. */
    char    szUsrShort[cchUsrShort + 1];/* Need to shorten the username also! */
    char    szBuffer[30];


    if (!fPostScript) {
        row = ((fLaser ? rowLJBanMax : rowMac) - crowBanner - 10)/2;
        col = ((fLaser ? colLJBanMax : colLPMax) - ccolBanner)/2;
    }

    szFNShort[cchFShort] = '\0' ;
    strncpy(szFNShort, szFName, cchFShort);
    szUsrShort[cchUsrShort] = '\0' ;
    strncpy(szUsrShort, szUsr, cchUsrShort);

    _getcwd(szPath, sizeof(szPath));
    _strupr(szPath);
    _strupr(szFNShort);

    SzDateSzTime(szDate, szTime);

    if (fPostScript) {

        int iPathLen = strlen (szFFile);
        while ((szFFile[iPathLen] != '\\') && (iPathLen>0)) {
            iPathLen--;
        }

        OutLPR("\n", 0);
        /* The 'strings' we are sending out, need to use OutLPRPS just in case
         * they contain \, (, or )...
         */

        // Assign a jobname
        OutLPR ("statusdict begin statusdict /jobname (PPR: ", 0);
        OutLPRPS (szUsr, 0);
        OutLPR (" - ", 0);
        OutLPRPS (szFNShort, 0);
        OutLPR (") put end \n", 0);

        if( fHDuplex || fVDuplex )
        {
            OutLPR( "statusdict begin ", 0 );
            OutLPR( fHDuplex ? "true" : "false", 0 );
            OutLPR( " settumble true setduplexmode end\n", 0);
        }

        // Define some of the data we will be wanting access to
        OutLPR ("/UserName (", 0); OutLPRPS (szUsr, 0); OutLPR (") def \n", 0);
        OutLPR ("/FileName (", 0); OutLPRPS (szFNShort ,0); OutLPR (") def \n", 0);
        OutLPR ("/PathName (", 0); OutLPRPS (szFFile, iPathLen); OutLPR (") def \n", 0);
        OutLPR ("/UserPath (", 0); OutLPRPS (szPath ,0);    OutLPR (") def \n", 0);
        OutLPR ("/Date (", 0);     OutLPRPS (szDate, 0);    OutLPR (") def \n", 0);
        OutLPR ("/Time (", 0);     OutLPRPS (szTime ,0);    OutLPR (") def \n", 0);
        OutLPR ("/FTime (", 0);    OutLPRPS (szFTime,0);    OutLPR (") def \n", 0);
        OutLPR ("/Label ",0);
        OutLPR ((fLabel ? "true" : "false"), 0);
        OutLPR (" def \n", 0);

        if (fConfidential) {
            OutLPR ("/MSConfidential true def\n", 0);

            OutLPR ("/Stamp (", 0);
            if (szStamp && strlen(szStamp) > 0) {
                OutLPR (szStamp, 0);
            } else {
                strcpy(szConfid, szCompany);
                strcat(szConfid, " ");
                strcat(szConfid, szConf);
                OutLPR (szConfid, 0);
            }
            OutLPR (") def \n", 0);
        }

        if (szStamp != NULL) {
            OutLPR ("/MSConfidential true def\n", 0);
            OutLPR ("/Stamp (", 0);
            OutLPRPS (szStamp, 0);
            OutLPR (") def \n", 0);
        }

        // Width of 'gutter' in characters
        sprintf (szBuffer, "/Gutter %d def \n", colGutter);
        OutLPR (szBuffer, 0);

        // The total column width in characters
        sprintf (szBuffer, "/ColWidth %d def \n", colWidth);
        OutLPR (szBuffer, 0);

        // Number of character rows per page
        sprintf (szBuffer, "/RowCount %d def \n", rowMac);
        OutLPR (szBuffer, 0);

        // The character column text should start in
        sprintf (szBuffer, "/ColText %d def \n", colText);
        OutLPR (szBuffer, 0);

        // Number of columns per page
        sprintf (szBuffer, "/Columns %d def\n", cCol);
        OutLPR (szBuffer, 0);

/* ... Ok, now lets get started! */

        if (cBanOut > 0) OutLPR ("BannerPage\n", 0);

        cBanOut--;
        /* print more banners if neccessary ?? */
        while (cBanOut-- > 0) {
            OutLPR ("BannerPage % Extra Banners??\n", 0);
        }

    } else {
        FillRectangle(' ', 0, 0, row + crowBanner, col + ccolBanner + 1);
        HorzLine('_', row, col + 1, col + ccolBanner);
        HorzLine('_', row + 5, col, col + ccolBanner);
        HorzLine('_', row + 16, col, col + ccolBanner);
        HorzLine('_', row + 29, col, col + ccolBanner);
        VertLine('|', col, row + 1, row + crowBanner);
        VertLine('|', col + ccolBanner, row + 1, row + crowBanner);

        WriteSzCoord("User:", row + 2, col + 15);
        WriteSzCoord(szUsr, row + 2, col + 30);
        WriteSzCoord("File Name:", row + 3, col + 15);
        WriteSzCoord(szFNShort, row + 3, col + 30);
        WriteSzCoord("Directory:", row + 3, col + 58);
        WriteSzCoord(szPath, row + 3, col + 73);
        WriteSzCoord("Date Printed:", row + 4, col + 15);
        WriteSzCoord("Time Printed:", row + 4, col + 58);
        WriteSzCoord(szDate, row + 4, col + 30);
        WriteSzCoord(szTime, row + 4, col + 73);

        block_flush(szUsrShort, row + 8, CenterCol(szUsrShort));
        block_flush(szFNShort, row + 20, CenterCol(szFNShort));

        if (fConfidential)
                {
                strcpy(szConfid, szCompany);
                strcat(szConfid, " ");
                strcat(szConfid, szConf);
                WriteSzCoord(szConfid, row+18, col + (ccolBanner-strlen(szConfid))/2);
                }
        if (szStamp != NULL)
                WriteSzCoord(szStamp, row+28, col + (ccolBanner-strlen(szStamp))/2);

        /* move to top of page */
        if (!fPageTop)
            OutLPR(fPostScript ? "showpage\n" : "\r\f", 0);
        if (fLaser)
            {
            if (fVDuplex || fHDuplex)
                    OutLPR(SELECTFRONTPAGE,0);
            OutLPR(BEGINBANNER, 0);
            }
        if (fPostScript)
            OutLPR("beginbanner\n", 0);

        OutRectangle(0, 0, row + crowBanner, col + ccolBanner + 1);
        cBanOut--;

        /* print more banners if neccessary */
        while (cBanOut-- > 0) {
            OutLPR(fPostScript ? "showpage\n" : "\r\f", 0);
            if (fPostScript)
                OutLPR("beginbanner\n", 0);
            OutRectangle(0, 0, row + crowBanner, col + ccolBanner + 1);
        }
    } /* End of PostScript check */

    fPageTop = FALSE;
    }


void SzDateSzTime(szDate, szTime)
/* fill sz's with date & time */
char    *szDate, *szTime;
{
    char *szt;
    char sz[26];
    time_t tT;

    time(&tT);
    szt = ctime(&tT);
    /* convert ctime format into Date & Time */
    strcpy(sz, szt);
    sz[10] = sz[19] = sz[24] = '\0';    /* break into DAY:TIME:YEAR */

    strcpy(szDate, &sz[0]);
    strcat(szDate, " ");
    strcat(szDate, &sz[20]);
    strcpy(szTime, &sz[11]);
} /* SzDateSzTime */


void FlushPage()
/*  FlushPage - dump a completed page to the printer  */
    {
    if (!fInit)
        {
        if (!fPostScript) {
            if (!fPageTop)
                OutLPR("\r\f", 0);
            else if (!fLaser && fLabel)
                OutLPR("\n\n", 0);  /* align printout on LP */
        }

        OutRectangle(0,0,rowMac,colMac);
        fPageTop = FALSE;
      }
    }


void InitPage()
/* fill in the page image with a blanks (and frame, if needed)     */
/* mark punch holes in to row for laserprinters in landscape mode, */
/* so that PlaceTop() can avoid these spots when placing strings   */
    {
    int iCol;

    fInit = TRUE;

    FillRectangle(' ', 0, 0, rowMac, colMac);

    if (!fPostScript)
    if (fBorder)
        {
        /* Draw border around page */
        HorzLine('_', 0         , 1, colMac - 1);
        HorzLine('_', rowMac - 1, 1, colMac - 1);
        VertLine('|', 0         , 1, rowMac);
        VertLine('|', colMac - 1, 1, rowMac);

        /* Fill in column separators */
        for (iCol = 0; iCol < cCol - 1; iCol++)
            VertLine('|', ColBeginIcol(iCol, colWidth) + colWidth, 1, rowMac-1);

        /* mark punch holes */
        if (fLabel && !fPortrait && (fPostScript || fLaser) )
                {
                if (fLaser)
                        {
                        HorzLine('\0', 0, 11, 19);
                        HorzLine('\0', 0, 83, 92);
                        HorzLine('\0', 0, 154, 162);
                        }
                else
                        {
                        HorzLine('\0', 0, 11, 19);
                        HorzLine('\0', 0, 77, 86);
                        HorzLine('\0', 0, 144, 152);
                        }
                }

        }
    }



void RestoreTopRow()
/* replace the zero bytes put in by InitPage() with underscores */
        {
        register char *pch;

        for (pch = &page[0][0];  pch<&page[0][colMac-1];  pch++)
                if (*pch=='\0' || (*pch==' ' && (*(pch-1)=='_' || *(pch+1)=='_')))
                        *pch = '_';
        }


void PlaceTop(szLabel, ichAim, ichMin, ichMax)
char *szLabel;
int ichAim, ichMin, ichMax;
        {
        int cchLab, cTry, dich, ichLim1, ichLim2;
        register int ich;
        register char *pch;
        BOOL fBackward;

        cchLab = strlen(szLabel);
        dich = (fBackward = ichAim<=(colMac-cchLab)/2) ? -1 : 1;

        for (cTry=0;  cTry<2;  cTry++)
                {
                if (fBackward)
                        ichLim1 = (ichLim2=ichAim) + cchLab - 1;
                else
                        ichLim2 = (ichLim1=ichAim+1) + cchLab - 1;
                for (pch= &page[0][ich=ichLim1];
                     ich<ichMax && ich>ichMin;
                     pch += dich,  ich += dich)
                        {
                        if (*pch != '_')
                                {
                                ichLim1 = ich + dich;
                                ichLim2 = ich + (fBackward ? -cchLab : cchLab);
                                }
                        else
                                {
                                if (ich==ichLim2) /* found spot, write string */
                                        {
                                        WriteSzCoord(szLabel, 0, min(ichLim1, ichLim2));
                                        return;
                                        }
                                }
                        }
                /* if no spot found, try the other direction */
                dich = -dich;
                fBackward = !fBackward;
                }
        }


void PlaceNumber(iCol)
int iCol;
        {
        int ichAim, ichMin, ichMax, cchN;
        char szN[8];

        sprintf(szN, " %d ", iPage + iCol + 1);
        ichMin = ColBeginIcol(iCol,colWidth);
        ichAim = ichMin + (colWidth - (cchN=strlen(szN)) )/2;
        ichMax = ichMin + colWidth - cchN - 1;
        PlaceTop(szN, ichAim, ichMin, ichMax);
        }


void LabelPage()
/* place page labels on page */
    {
    int col;
    char szT[11];
    char * szHeader;

    szHeader = szBanner ? szBanner : szFFile;

    if (fLabel)
        {
        if (fPortrait)
            {
            /* move top line over if gutter is being used   */
            col = colGutter;

            /* place in szFTime */
            WriteSzCoord(szFTime, 0, col);
            col += strlen(szFTime)+2;

            /* place in file name after szFTime */
            WriteSzCoord(szHeader, 0, col);
            col += (strlen(szHeader)+2);

            /* place page numbers on page */
            sprintf(szT, "Page %d", iPage + 1);
            WriteSzCoord(szT, 0, col);
            col += (strlen(szT)+2);

            /* place user name on page */
            WriteSzCoord(szUsr, 0, col);
            col += (strlen(szUsr)+4);

            if (fConfidential)
                    {
                    WriteSzCoord(szCompany, 0, col);
                    col += (strlen(szCompany)+1);
                    WriteSzCoord(szConf, 0, col);
                    }

            if (szStamp!=NULL)
                    {
                    WriteSzCoord(szStamp, 0, col);
                    col += (strlen(szStamp)+4);
                    }
            }
        else
            {
            int iCol;

            if (fConfidential)
                {
                PlaceTop(szCompany, colMac/2-strlen(szCompany)-1, 0, colMac-1);
                PlaceTop(szConf, colMac/2, 0, colMac-1);
                }

            if (szStamp!=NULL)
                PlaceTop(szStamp, colMac-strlen(szStamp)-1, 0, colMac-1);

            /* place page numbers on columns */
            for (iCol = 0; iCol < cCol; iCol++)
                PlaceNumber(iCol);

            RestoreTopRow();

            /* place in centered file name */
            WriteSzCoord(szHeader, rowMac-1, (colMac - strlen (szHeader))/2);

            /* place in right-justified szFTime */
            WriteSzCoord(szFTime, rowMac-1, colMac - 2 - strlen(szFTime));

            /* place in name in lower left hand corner */
            WriteSzCoord(szUsr,rowMac-1,2);
            }
        }
    }


void AdvancePage()
/* advance the counters to a succeeding page.  Flush if necessary.  */
    {
    if (fBorder || fLabel)
        rowLine = (fPortrait ? 3 : 1);
    else
        rowLine = 0;

    iPage++;

    /* if we have moved to a new printer page, flush and reinit */
    if ( fPostScript || ((iPage % cCol) == 0))

        {
        FlushPage();
        InitPage();
        if (!fPostScript)
            LabelPage();
        }
    }


void XoutNonPrintSz(sz)
/* replace non-printing characters in sz with dots; don't replace LF, CR, FF
   or HT.
*/
register char    *sz;
{
    if (usCodePage != 0) {
        return;
    }

    while (*sz != '\0') {
        if ( !isascii(*sz)
        || ( !isprint(*sz) &&
              *sz != LF  &&  *sz != CR  && *sz != HT  &&  *sz != FF  &&
              *sz != *sz != ' ')) {
            *sz = '.';
        }
        sz++;
    }
}


void LineOut(sz, fNewLine)
/*  LineOut - place a line of text into the page buffer.  The line is broken
 *  into pieces that are at most colWidth long and are placed into separate
 *  lines in the page.  Lines that contain form-feeds are broken into pieces
 *  also.   Form-feeds cause advance to the next page.  Handle paging. Handle
 *  flushing of the internal buffer.
 *
 *  sz          character pointer to string for output.  We modify this string
 *              during the operation, but restore it at the end.
 *
 *  fNewLine    TRUE ==> this the start of a new input line (should number it)
 */
register char *sz;
BOOL fNewLine;
    {
    register char *pch;

    /* if there is a form feed, recurse to do the part before it */
    while (*(pch = sz + strcspn(sz, "\f")) != '\0')
        {
        if (pch != sz)
            {
            *pch = '\0'; /* temporarily fix to NULL */
            LineOut(sz, fNewLine);
            fNewLine = FALSE;   /* Not a new line after a Form Feed */
            *pch = FF;   /* reset to form feed */
            }

            if (fPostScript) {
                OutLPR ("\f\n\0", 0);
            } else {
                AdvancePage();
            }
        sz = pch + 1; /* point to first char after form feed */
        }

    if (fNewLine)
        iLine++;

    /* if the current line is beyond end of page, advance to next page */
    if (rowLine == rowPage)
        AdvancePage();
    fInit = FALSE;

    if (fNewLine && fNumber) {
        char szLN[cchLNMax + 1];

        sprintf(szLN, LINUMFORMAT, iLine);
        if (fPostScript) {
            OutLPR (szLN, 0);
        } else {
            WriteSzCoord(szLN, rowLine, ColBeginIcol(iPage % cCol,colWidth)+colGutter);
        }
    }

    XoutNonPrintSz(sz);

    /* if the line can fit, drop it in */
    if (strlen(sz) <= (unsigned int)(colWidth - colText))
        if (fPostScript) {
            OutLPR (sz, 0);
            OutLPR ("\n\000",0);
        } else
            WriteSzCoord(sz, rowLine++, ColBeginIcol(iPage % cCol,colWidth) + colText);
    else
        {
        /* drop in the first part and call LineOut for the remainder */
        char ch = sz[colWidth - colText];

        sz[colWidth - colText] = '\0';
        if (fPostScript) {
            OutLPR (sz, 0);
            OutLPR ("\n\000",0);
            /*WriteSzCoord(sz, rowLine++, ColBeginIcol(0, colWidth) + colText);*/
        } else
            WriteSzCoord(sz, rowLine++, ColBeginIcol(iPage % cCol,colWidth) + colText);
        sz[colWidth - colText] = ch;

        LineOut(sz + colWidth - colText, FALSE );
        }
    }


void RawOut(szBuf, cb)
/* print line of raw output */
char * szBuf;
int cb;
        {
        fPageTop = (szBuf[cb - 1] == FF);
        OutLPR(szBuf, cb);
        }


BOOL FilenamX(szSrc, szDst)
/*  copy a filename.ext part from source to dest if present.
    return true if one is found
 */
char *szSrc, *szDst;
        {
#define  szSeps  "\\/:"

        register char *p, *p1;

        p = szSrc-1;
        while (*(p += 1+strcspn(p1=p+1, szSeps)) != '\0')
                ;
        /* p1 points after last / or at bos */
        strcpy(szDst, p1);
        return strlen(szDst) != 0;
        }


int
FileOut(szGiven)
/*  FileOut - print out an entire file.
 *
 *  szGiven         name of file to display.
 */
char *szGiven;
    {
    FILE *pfile;
    int  cDots = 0;
    long lcbStartLPR = 0l;
    char rgbLine[cchLineMax];
    char szFBase[MAX_PATH];
    char rgchBuf[2];

    /* open/secure input file */
    if (!*szGiven || !strcmp(szGiven, "-"))
        {
        pfile = stdin;
        strcpy(szFFile, szBanner ? szBanner : "<stdin>");
        strcpy(szFBase, szFFile);
        szFTime[0] = '\0';
        szGiven = NULL;
        }
    else if ((pfile = fopen(szGiven, szROBin)) != NULL)
        {
        struct _stat st;

        /* The file has been opened, now lets construct a string that
         * tells us exactly what we opened...
         */
        rootpath (szGiven, szFFile);
        _strupr(szFFile);
        FilenamX(szGiven, szFBase);
        if (_stat(szGiven, &st) == -1)
                Fatal("file status not obtainable : [%s]", szGiven, NULL);
        strcpy(szFTime, ctime(&st.st_mtime));
        *(szFTime + strlen(szFTime) - 1) = '\0';
        }
    else
        {
        Error("error opening input file %s", szGiven);
        return(FALSE);
        }

    /* need to get user name to be printed in lower left corner of each */
    /* page and on banner.                                              */
    QueryUserName(szUsr);

    if (!fSilent) {     // Print progress indicator
        fprintf(stderr, "PRINTING %s ", szFBase);
    }

    /* check to see if user forgot -r flag and this is a binary file */
    if (!fRaw && pfile != stdin)
        {
        fread((char *)rgchBuf, sizeof(char), 2, pfile);
        if (rgchBuf[0] == ESC && strchr("&(*E", rgchBuf[1]) != 0)
                {
                fprintf(stderr, "ppr: warning: file is binary; setting raw mode flag");
                fRaw = TRUE;
                }
        if (fseek(pfile, 0L, SEEK_SET) == -1) 
            fprintf(stderr, "ppr: seek failed");     /* reposition the file pointer to start of file */
        }

    if (fPostScript) {
        if (!fFirstFile) {
            OutLPR ("\034\n\000", 0); /* File Separator */
            if (cBanner < 0) /* we at least need to set up the file stuff */
                BannerSz (szBanner ? szBanner : szFBase, 0);
        }
    }

    /* print banner(s) if any */
    if (cBanner > 0)
        BannerSz(szBanner ? szBanner : szFBase, cBanner);
    else if (cBanner < 0  &&  fFirstFile)
        BannerSz(szBanner ? szBanner : szFBase, -cBanner);
    else if (cBanner==0 && fPostScript)
        BannerSz(szBanner ? szBanner : szFBase, 0);

    fFirstFile = FALSE;

    /* always start contents of file at top of page */
    if (!fPageTop)
        {
        if (!fPostScript)
          OutLPR(fPostScript ? "showpage\n" : "\r\f", 0);
        fPageTop = TRUE;
        }

    if (fLaser)
        {
        /* start output mode for laserjet */

        if (fVDuplex || fHDuplex)
            /* always start output on front page */
            OutLPR(SELECTFRONTPAGE,0);

        if (fPortrait)
            OutLPR(BEGINPORTRAIT, 0);
        else
            OutLPR(aszSymSet[usSymSet], 0);
        }

    if (fPostScript) {
        OutLPR (fPortrait ? (fPCondensed ? "QuadPage\n" : "Portrait\n") : "Landscape\n", 0);
        OutLPR ("PrintFile\n", 0);
    }

    /* for PostScript we start the mode before each page */

    lcbStartLPR = lcbOutLPR;
    cDots = 0;
    if (fRaw)
        {
        int cb;

        /* read file and write directly to printer */
        while ((cb = fread(rgbLine, 1, cchLineMax, pfile)) > 0)
            {
            RawOut(rgbLine, cb);
            if (!fSilent && cDots < (lcbOutLPR-lcbStartLPR) / 1024L)
                {
                for (; cDots < (lcbOutLPR-lcbStartLPR) / 1024L; cDots++)
                    fputc('.', stderr);
                }
            }
        }
    else
        {
        /* initialize file information */
        iLine = 0;

        /* initialize page information */
        iPage = -1;
        rowLine = rowPage;
        fInit = TRUE;

        /* read and process each line */
        while (fgetl(rgbLine, cchLineMax, pfile)) {
                LineOut(rgbLine, TRUE);
                if (!fSilent && cDots < (lcbOutLPR-lcbStartLPR) / 1024L) {
                    for (; cDots < (lcbOutLPR-lcbStartLPR) / 1024L; cDots++) {
                        fputc('.', stderr);
                    }
                }
        }

        /* flush out remainder if any */
        FlushPage();
        }

    if (!fPageTop && (fForceFF || fPostScript) && (!fPostScript || !fRaw))
       {
        if (!fPostScript)
           OutLPR(fPostScript ? "showpage\n" : "\r\f", 0);
       fPageTop = TRUE;
       }

    fclose(pfile);

    if (!fSilent)               /* finish PRINTING message with CRLF when done*/
        fprintf(stderr, "%dk\n", (lcbOutLPR-lcbStartLPR)/1024);

    if (fDelete && szGiven)
        {
        if (fSilent)
            _unlink(szGiven);
        else
            {
            fprintf(stderr, "DELETING %s...", szGiven);
            if (!_unlink(szGiven))
                fprintf(stderr, "OK\n");
            else
                fprintf(stderr, "FAILED: file not deleted\n");
            }
        }
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ppr\lplow.c ===
/**************************************************************************\
 * LPLow.C                                                                *
 *------------------------------------------------------------------------*
 *                                                                        *
 * PPR Support for low level network and path handling.                   *
 *                                                                        *
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <stdio.h>
#include <string.h>
#define INCL_NETUSE
#define INCL_NETWKSTA
#define INCL_NETERRORS
#include <windows.h>
#include "lpr.h"


extern BOOL fVerify; /* From LPR.C */


BOOL fRedir = FALSE;		/* TRUE => a redirection was used	*/

void SetupRedir()
{
    int     err;
    DWORD   wnError;
    CHAR    szRemoteName[256];
    DWORD   BufferSize = sizeof(szRemoteName)/sizeof(szRemoteName[0]);

    if (*szNet == '\0' || _strcmpi(szNet, "None") == 0)
        return;		/* don't try to make connection */

    if(szPass) {
        strcpy(szNet + strlen(szNet) + 1, szPass);
    }

    if ( WN_SUCCESS != ( wnError = WNetGetConnection ( (PTSTR) szPName,
						 szRemoteName,
						 &BufferSize ) ) ) {


	if ( (wnError != WN_NOT_CONNECTED) &&
	     (wnError != WN_CONNECTION_CLOSED) ) {

	    switch( wnError ) {

		case WN_NO_NETWORK:
		    Fatal("The network is not installed or workstation not started");
                    break;
		case WN_BAD_LOCALNAME:
		    Fatal("Invalid local name specified");
		    break;
		case WN_EXTENDED_ERROR:
		    Fatal("Extended error from WNetGetConnection" );
                    break;
		default:
		    Fatal("error from WNetGetConnection: %d",wnError );
		    break;
		}
            }
        }
    else  {	/* no error */
	if  ( !strcmp( szRemoteName, szNet ) ) {
            return;
	    }
	}

    /* no redirection, so set one up */

    if ((err = SetPrnRedir(szPName, szNet)) == 0)
        fRedir = TRUE;
    else if (err == 1)
        Fatal("redirection of %s to %s failed (%d)\nredirector is not started",
               szPName,szNet,err);
    else if (err != ERROR_ALREADY_ASSIGNED)
        Fatal("redirection of %s to %s failed (%d)",
               szPName,szNet,err);
}


void ResetRedir()
	{
	int err;

	if (fRedir)
		{
		if ((err = EndRedir(szPName)) != 0)
			Error("removal of redirection failed (%d)", err);
		fRedir = FALSE;
		}
	}





int EndRedir(szDev)
/* End redirection for szDev, return 0 if success */
/* otherwise return error number	*/
char * szDev;

{
    DWORD  wnError;

    if (WN_SUCCESS != ( wnError = WNetCancelConnection ( szDev, TRUE) ) )	{
	return ( 0 );
	}
    else  {
	return ( (int) wnError );
	}
}




int SetPrnRedir(szDev, szPath)
    char *szDev;
    char *szPath;
{
    DWORD wnError;


    /* return 0, 1 or other error */

    if ( szPass && *szPass )  {
        wnError = WNetAddConnection ( (LPTSTR) szPath, (LPTSTR) szPass, (LPTSTR) szDev );
    } else  {
        wnError = WNetAddConnection ( (LPTSTR) szPath, NULL, (LPTSTR) szDev );
    }

    if(wnError == WN_SUCCESS) {
        wnError = 0;
    } else if((wnError == WN_NO_NETWORK) || (wnError == WN_NO_NET_OR_BAD_PATH)) {
        wnError = 1;
	}
    return ( (int)wnError );
}




BOOL QueryUserName(char *szName)
{
    UCHAR		 pUserName [128];
    DWORD		 BufferSize = 128;
    BOOL                 rc;
    DWORD		 wnError;

    if (WN_SUCCESS != ( wnError = WNetGetUser ( NULL, (LPTSTR) pUserName, &BufferSize ) ) )  {
        strcpy(szName,"no name");
        rc = FALSE;
        if(fVerify) {
	    fprintf(stdout,"Warning: WNetGetUser returns %d\n", wnError );
        }
    } else {
	strcpy(szName, pUserName);
        rc =  TRUE;
    }
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ppr\lpr.h ===
/*=========================================================================
 *
 * LPR.H : Master Header file for PPR
 *
 *-------------------------------------------------------------------------
 *
 * Possible defines (differences mostly in network connections):
 *
 *       DOS - DOS 3.x
 *       OS2 - OS/2
 *       X86 - 286 Xenix
 *       (default) - SUN Xenix
 *
 *  Normal combinations:
 *
 *       if DOS || OS2 || X86
 *               non-68k
 *       else
 *               68k
 *       endif
 *
 *       if DOS || OS2
 *               non-Xenix
 *       else
 *               Xenix
 *       endif
 *
 * Currenently active code, is only being compiled for DOS and OS/2.
 * Support for other platforms is untested.
 *
 **************************************************************************/

#define VERSION  "2.3a"     // Current Version number of PPR
#define ANALYST  "RobertH"  // Current responsible (sic.) programmer




#define COMPANY  "Microsoft"
#define CONFIDENTIAL "CONFIDENTIAL"


#define cchArgMax  128

#define cchLineMax 256

#  define PRINTER  "lpt1"
#  define strnxcmp _strnicmp
#  define strcmpx  _strcmpi
#  define SILENT   " >NUL"
#  define szROBin "rb"
#  define szWOBin "wb"

#define DEFAULT       "default"
#define OPTS          "opts"
#define RESETPRINTER  "\033E"

/* [01]o - landscape/portrait (0 - portrait)
   #D - lines per inch (8 or 6)
   #C - vertical motion index (# 1/48in)
   0p - fixed pitch
   #h - pitch
   #v point size
   #t - type face (0 - line printer; 3 - courier)

   These sequences assume that the printer has been reset once before hand.
*/

#define BEGINBANNER             "\033&l1o6D\033(8U\033(s0p10h12v3T"
#define BEGINPORTRAIT           "\033&l0o7.7C\033(8U\033(s0p10h12v3T"
#define SELECTFRONTPAGE         "\033&a1G"
#define SELECTNEXTPAGE          "\033&a0G"
#define BEGINDUPLEXVERT         "\033&l1S"
#define BEGINDUPLEXHOR          "\033&l2S"
#define BEGINSIMPLEX            "\033&l0S"

#define MOVETOTOP       "\033&a1R"

#define rowLJMax 62                     /* lines per page on laser jet        */
#define colLJMax 175                    /* columns per page on laser jet      */
#define colLJPortMax 80                 /* columns per page in portrait mode  */
#define rowLJBanMax 50                  /* rows on banner page                */
#define colLJBanMax 105                 /* columns on banner page             */

#define rowLPMax 66                     /* lines per page on line printer     */
#define colLPMax 132                    /* columns per page on line printer   */

#define rowPSMax 62                     /* lines per page on laserwriter      */
#define colPSMax 170                    /* columns per page on laserwriter    */
#define colPSPortMax 85                 /* columns per page in portrait mode  */
#define rowPSBanMax 48                  /* rows on banner page                */
#define colPSBanMax 115                 /* columns on banner page             */

/*      Note: The following must be at least the maximum
 *      of all the possible printer values.  */
#define rowMax  100                     /* number of lines in page image      */
#define colMax  200                     /* number of columns in page image    */

#define cchLNMax  6                     /* number of columns for line number  */
#define LINUMFORMAT "%5d "              /* format to print line number in     */

#define colGutDef  5                    /* default column of gutter           */

#define HT      ((char) 9)
#define LF      ((char) 10)
#define FF      ((char) 12)
#define CR      ((char) 13)
#define BS      ((char) '\b')

// supported Laserjet symbol sets - used by aszSymSet

#define BEGINLANDUSASCII        0x0000
#define BEGINLANDROMAN8         0x0001
#define BEGINLANDIBMPC          0x0002  // Not available on early models ?

#if !defined (ERROR_ALREADY_ASSIGNED)
#define ERROR_ALREADY_ASSIGNED 85
#endif

/* return index of beginning col of column icol for columns col wide */
#define ColBeginIcol(iCol,col)  ((fBorder ? 1 : 0) + (iCol)*(col+1) )

extern int  colTab;                     /* expand tabs every colTab columns   */
extern long lcbOutLPR;
extern char szPName[];
extern char szNet[];
extern char szPass[];
extern char *szPDesc;
extern int cCol;
extern int cCopies;
extern int colGutter;
extern int colText;
extern int colWidth;
extern int colMac;
extern int rowMac;
extern int rowPage;
extern USHORT usSymSet;
extern char *aszSymSet[];
extern char page[rowMax][colMax+1];
extern BOOL fNumber;
extern BOOL fDelete;
extern BOOL fRaw;
extern BOOL fBorder;
extern BOOL fLabel;
extern BOOL fLaser;
extern BOOL fPostScript;

extern BOOL fPSF;
extern char szPSF[];
extern BOOL fPCondensed;

extern BOOL fConfidential;
extern BOOL fVDuplex;
extern BOOL fHDuplex;
extern BOOL fSilent;
extern int  cBanner;
extern char chBanner;
extern char *szBanner;
extern char *szStamp;
extern BOOL fForceFF;
extern BOOL fPortrait;
extern BOOL fFirstFile;


/* VARARGS */
void __cdecl Fatal(char *,...);
void __cdecl Error(char *,...);
void PrinterDoOptSz(char *);
char * SzGetSzSz(char *, char *);


/* from lpfile.c */


BOOL FRootPath(char *, char *);
char* __cdecl fgetl(char *, int, FILE *);
FILE * PfileOpen(char *, char *);
char *SzFindPath(char *, char *, char *);

/* from lplow.c*/

void SetupRedir(void);
void ResetRedir(void);
BOOL QueryUserName(char *);



int EndRedir(char *);
int SetPrnRedir(char *, char *);



/* from lpprint.c */

void OutLPR(char *, int);
void OutLPRPS(char *, int);
void OutLPRPS7(char *, int);
BOOL FKeyword(char *);
void InitPrinter(void);
void MyOpenPrinter(void);
void FlushPrinter(void);
void MyClosePrinter(void);
char *SzGetSzSz(char *, char *);
char *SzGetPrnName(char *, char *);
BOOL FParseSz(char *);
void SetupPrinter(void);


/* from lppage.c  */

void BannerSz(char *, int);
void SzDateSzTime(char *, char *) ;
void FlushPage(void);
void InitPage(void);
void RestoreTopRow(void);
void PlaceTop(char *, int, int, int);
void PlaceNumber(int);
void LabelPage(void);
BOOL FilenamX(char *, char *);
void AdvancePage(void);
void XoutNonPrintSz(char * );
void LineOut(char *, BOOL);
void RawOut(char *, int);
int FileOut(char *);



/* from lpr.c  */


void Abort(void);
char * SzGetArg(char ** , int *, char **[] );
int WGetArg(char **, int *, char **[] , int, char *);
void DoOptSz(char * );
void DoIniOptions();

/* from pspage.c */

void block_flush(char [], int, int);
void VertLine(char, int, int, int);
void HorzLine(char, int, int, int);
void FillRectangle(char, int, int, int, int);
void WriteSzCoord(char *, int, int);
void OutCmpLJ(char * ,int );
void OutEncPS(char *, int);
void OutCmpPS(char *,int );
int CchNoTrail(char [],int);
void OutRectangle(int, int, int, int);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ppr\pspage.c ===
/* PSPage.C
 *
 *      Title:          PSPAGE
 *                      Henry Burgess
 *                      Copyright Microsoft Corp, 1985
 *                      July 4, 1985
 *
 *      Description:
 *                      This module contains the font table and the routine
 *                      that accesses it.  It might also be OEM configurable.
 *
 *==========================================================================
 * Modification History:
 *--------------------------------------------------------------------------
 *      9/11/85                 Modified to adopt to the banner program.
 *
 *      4/20/86 MJH             Adapt to lpr, page handling module.
 *
 *      3/3/89 Robert Hess      Version 2.9
 *                              Completely re-wrote PostScript support.
 *
 */



#include <windef.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include "lpr.h"


char        page[rowMax][colMax+1];    /* image of one printer page          */


/*
 * the following defines the bits in the character font
 */
unsigned char Font_Bits[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,         /* 00  */
0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,         /* 01  */
0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,         /* 02  */
0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,         /* 03  */
0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,         /* 04  */
0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,         /* 05  */
0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,         /* 06  */
0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,         /* 07  */
0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,         /* 08  */
0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,         /* 09  */
0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,         /* 0a  */
0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,         /* 0b  */
0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,         /* 0c  */
0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,         /* 0d  */
0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,         /* 0e  */
0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,         /* 0f  */
0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,         /* 10  */
0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,         /* 11  */
0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,         /* 12  */
0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,         /* 13  */
0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,         /* 14  */
0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,         /* 15  */
0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,         /* 16  */
0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,         /* 17  */
0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,         /* 18  */
0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,         /* 19  */
0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,         /* 1a  */
0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,         /* 1b  */
0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,         /* 1c  */
0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,         /* 1d  */
0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,         /* 1e  */
0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,         /* 1f  */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,         /* 20  */
0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,         /* 21 ! */
0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,         /* 22 " */
0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,         /* 23 # */
0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,         /* 24 $ */
0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,         /* 25 % */
0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,         /* 26 & */
0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,         /* 27 ' */
0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,         /* 28 ( */
0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,         /* 29 ) */
0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,         /* 2a * */
0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,         /* 2b + */
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,         /* 2c , */
0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,         /* 2d - */
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,         /* 2e . */
0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,         /* 2f / */
0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,         /* 30 0 */
0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,         /* 31 1 */
0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,         /* 32 2 */
0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,         /* 33 3 */
0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,         /* 34 4 */
0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,         /* 35 5 */
0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,         /* 36 6 */
0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,         /* 37 7 */
0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,         /* 38 8 */
0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,         /* 39 9 */
0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,         /* 3a : */
0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,         /* 3b ; */
0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,         /* 3c < */
0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,         /* 3d = */
0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,         /* 3e > */
0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,         /* 3f ? */
0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,         /* 40 @ */
0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,         /* 41 A */
0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,         /* 42 B */
0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,         /* 43 C */
0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,         /* 44 D */
0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,         /* 45 E */
0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,         /* 46 F */
0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,         /* 47 G */
0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,         /* 48 H */
0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,         /* 49 I */
0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,         /* 4a J */
0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,         /* 4b K */
0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,         /* 4c L */
0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,         /* 4d M */
0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,         /* 4e N */
0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,         /* 4f O */
0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,         /* 50 P */
0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,         /* 51 Q */
0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,         /* 52 R */
0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,         /* 53 S */
0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,         /* 54 T */
0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x00,         /* 55 U */
0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,         /* 56 V */
0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,         /* 57 W */
0xc6, 0x6c, 0x38, 0x10, 0x38, 0x6c, 0xc6, 0x00,         /* 58 X */
0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,         /* 59 Y */
0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,         /* 5a Z */
0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,         /* 5b [ */
0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,         /* 5c \ */
0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,         /* 5d ] */
0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,         /* 5e ^ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,         /* 5f _ */
0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,         /* 60 ` */
0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,         /* 61 a */
0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,         /* 62 b */
0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,         /* 63 c */
0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,         /* 64 d */
0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,         /* 65 e */
0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,         /* 66 f */
0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,         /* 67 g */
0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,         /* 68 h */
0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,         /* 69 i */
0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,         /* 6a j */
0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,         /* 6b k */
0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,         /* 6c l */
0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,         /* 6d m */
0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,         /* 6e n */
0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,         /* 6f o */
0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,         /* 70 p */
0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,         /* 71 q */
0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,         /* 72 r */
0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,         /* 73 s */
0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,         /* 74 t */
0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,         /* 75 u */
0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,         /* 76 v */
0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,         /* 77 w */
0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,         /* 78 x */
0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,         /* 79 y */
0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,         /* 7a z */
0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,         /* 7b { */
0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,         /* 7c | */
0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,         /* 7d } */
0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,         /* 7e ~ */
0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00          /* 7f   */
};



void block_flush(sz, rowTopLeft, colTopLeft)
/*** do the actual block printing of sz to the page. */
char        sz[];
int         rowTopLeft, colTopLeft;
    {
    int      row, col, ich;
    register unsigned char c;
    char     chFill;

    if ((sz == NULL) || (sz[0] == '\0'))
	    return;

    for (row =0; row < 8; row++)
	{                      /* 8 lines */
	for (ich = 0; sz[ich] != '\0'; ich++)
	    {         /* characters in string */
	    /*
	    * find this character in the font table
	    * and byte for this row  ( + i )
	    */
	    c = Font_Bits[((unsigned)sz[ich] << 3) + row];

	    if (chBanner<=' ')
		if (isprint(sz[ich]))
	  	    chFill = sz[ich];
		else chFill = 'X';
	    else
		chFill = chBanner;

	    for (col = 0; col < 8; col++)
		{      /* bits in a byte */
		page[rowTopLeft + row][colTopLeft + (ich << 3) + col] =
                      (char)(((int)c & 0x80) ? chFill : ' ');
                c = (unsigned char)((int)c << 1);
		}
	    }
	}
    }




void VertLine(char ch, int colAt, int rowMin, int rowMac)
    {
    register int row;

    for (row = rowMin; row < rowMac; page[row++][colAt] = ch)
	;
    }




void HorzLine(char ch, int rowAt, int colMin, int colMac)
    {
    register int  col;

    for (col = colMin; col < colMac; page[rowAt][col++] = ch)
	;
    }




void FillRectangle(char ch, int rowTopLeft, int colTopLeft, int rowBotRight, int colBotRight)
    {
    register int  col, row;

    for (row = rowTopLeft; row < rowBotRight; row++)
	{
        for (col = colTopLeft; col < colBotRight; col++)
            page[row][col] = ch;
        }
    }




void WriteSzCoord(sz, row, col)
register char *sz;
int   row, col;
    {
    register char *pch;

    for (pch = &page[row][col]; *sz != '\0'; *pch++ = *sz++)
	;
    }




void OutCmpLJ(szO,cchO)
/*  Accept a string, szO, of length cchO and remove runs of seven or
    more spaces by replacing them with a control sequence to move the
    printer head on the HP Laser Jet.

    ESC&a+#C   moves the head # places to the right.

    NOTE: this is very similar to OutCmpPS().
*/
char *szO;
int cchO;
    {
    register int cchB;
    char chO;
    register char *pchB;
    char szMove[10];

    chO = szO[cchO];		/* save for later restore */
    szO[cchO] = '\0';		/* Make sure 0 terminated string. */

    while (*szO != '\0')
        {
	pchB = szO;
	while ((pchB=strchr(pchB, ' ')) != 0 && (cchB=strspn(pchB, " ")) < 7)
		pchB += cchB;

	if (pchB != 0)
		{
		/* found a run of blanks of 7 or more */
		if (szO != pchB)
			{
			/* output other stuff until pchB */
			OutLPR(szO, (int)(pchB-szO));
			szO = pchB;
			}
		
		/* output run of blanks as ESC&a+#C */
		sprintf(szMove, "\033&a+%dC", cchB);
		OutLPR(szMove, 0);
		szO += cchB;
		}
	else
		{
		/* no run of blanks; output all and terminate loop */

		cchB = strlen(szO);		/* not really blanks (!) */
		OutLPR(szO, cchB);
		szO += cchB;
		}
	}
    *szO = chO;		/* restore */
    }



void OutEncPS(pchF, cchF)
/* output PostScript substring quoting *nothing* */
register char *pchF;
int cchF;
{
    register char *pchT;
    int cchT;
    char rgbT[1+colMax*2+5];/* enough for every character to be encoded */

    pchT = rgbT;
    cchT = 0;
    while (cchF-- > 0) {
	switch(*pchF++) {
	    default:
		*pchT++ = *(pchF-1);
		cchT++;
		break;
	}
    }
    *pchT = '\n'; cchT++;	   /* end of PostScript string */

    OutLPR(rgbT, cchT);
}


void OutCmpPS(szO,cchO)
/*  Accept a string, szO, of length cchO.

    # sp   moves the head # places to the right (local definition).

    NOTE: this is VERY similar to OutCmpPS().
*/
char *szO;
int cchO;
    {
    register int cchB;
    char chO;
    register char *pchB;

    chO = szO[cchO];		/* save for later restore */
    szO[cchO] = '\0';		/* Make sure 0 terminated string. */
    while (*szO != '\0') {
	pchB = szO;
	cchB = strlen(szO);		/* not really blanks (!) */
	OutEncPS (szO, cchB);
	szO += cchB;
    }
    *szO = chO;		/* restore */
}




int CchNoTrail(rgch,cch)
/* returns the number of characters in a line of text without counting
   trailing blanks*/
char rgch[];
int cch;
    {
    register char *pch;

    for (pch = rgch + cch - 1; pch >= rgch && *pch==' ';pch--)
         ;
    return ((int)((pch + 1) - rgch));
    }




void OutRectangle(rowMin, colMin, rowLim, colLim)
/* output rectangle of page triming blank lines and blanks from the ends of
   lines
*/
int rowMin, colMin, rowLim, colLim;
    {
    int row;
    int ccol = colLim - colMin;

    while (rowLim > rowMin && CchNoTrail(&page[rowLim-1][colMin], ccol) == 0)
	rowLim--;

    for (row = rowMin; row < rowLim; row++)
	{
	register char *pch = &page[row][colMin];
	int cch = CchNoTrail(pch, ccol);

	if (cch != 0)
	    {
	    if (fLaser)
		OutCmpLJ(pch, cch);
	    else if (fPostScript) {
		OutCmpPS(pch, cch);
	    } else
		OutLPR(pch, cch);
	    }
        else if (fPostScript) {
	    OutCmpPS (" ", 1);
	}
        if (!fPostScript)
	    OutLPR(row==rowLim - 1 ? "\r" : "\r\n", 0);
	}
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pretty\pretty.c ===
// Tweak the CABINETSTATE to disable name pretification by Diz

// Syntax: pretty.exe [option]
//                     on       enables name prettification
//                     off      disables name pretification
//                     help, ?  display help text
//                     [none]   displays the current state

#include "windows.h"
#include "windowsx.h"
#include "winuserp.h"
#include "shlobj.h"
#include "shellapi.h"
#include "shlobjp.h"
#include "stdio.h"

int _cdecl main(int iArgC, LPTSTR pArgs[])
{
    CABINETSTATE cs;
    LPTSTR pArg = pArg=pArgs[1];
    BOOL fOldDontPrettyNames;

    ReadCabinetState(&cs, sizeof(cs));

    fOldDontPrettyNames = cs.fDontPrettyNames;
    if (iArgC > 1)
    {
        if (*pArg==TEXT('-') || *pArg==TEXT('/'))
            pArg++;

        if (lstrcmpi(pArg, TEXT("on"))==0)
        {
            cs.fDontPrettyNames = FALSE;
        }
        else if (lstrcmpi(pArg, TEXT("off"))==0)
        {
            cs.fDontPrettyNames = TRUE;
        }
        else if (*pArg==TEXT('?') || lstrcmpi(pArg, TEXT("help"))==0)
        {
            printf(TEXT("Syntax: pretty.exe [on/off]\n"));
            return 0;
        }

        if (cs.fDontPrettyNames != fOldDontPrettyNames)
            WriteCabinetState(&cs);
    }

    printf(TEXT("Explorer name formatting is %s\n(Any change only become effective after next login)\n"),
                        cs.fDontPrettyNames ? TEXT("off"):TEXT("on"));

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ppr\lpprint.c ===
/*
 *      LPPRINT.C   -   Printer handling for PPR
 *
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <io.h>
#include <fcntl.h>
#include <windows.h>
#include <tools.h>
#include "lpr.h"


char szPName[cchArgMax];        /* text of printer to open              */
char szNet[cchArgMax] = "";     /* network name of printer to open      */
char *szPDesc = NULL;           /* printer description string           */

FILE *pfileLPR = NULL;          /* file for output                      */

extern BOOL fVerify; /* From LPR.C */
extern USHORT usCodePage;


void
OutLPR(
    char *sz,
    int cb
    )
{
    if (cb == 0)
        cb = strlen(sz);
    lcbOutLPR += cb;    /* keep track of how much has been written to printer */

    if (fwrite(sz, 1, cb, pfileLPR) != (unsigned int)cb)
        Error("warning: error writing to printer");
}

/*
 *  We need to add a little cheat, since some of our forced strings might have
 *  special postscript characters in them, such as the file name for one...
 *  We will call this function instead of OutLPR anytime that the string we are
 *  outputing will be within '(...)', and might contain \, (, or ).
 *  The code was borrowed from the original version of OutEncPS.
 */
void
OutLPRPS(
/* output substring quoting all \, ( and ) */
    char *pchF,
    int cchF
    )
{
    register char *pchT;
    int cchT;
    char rgbT[1+colMax*2+5];/* enough for every character to be encoded */

    pchT = rgbT;
    cchT = 0;
    if (cchF == 0)
        cchF = strlen(pchF);
    *pchT = (char)0;

    while (cchF-- > 0) {
        switch(*pchF++) {
            default:
                *pchT++ = *(pchF-1);
                cchT++;
                break;
            case '\\':
                *pchT++ = '\\';
                *pchT++ = '\\';
                cchT += 2;
                break;
            case '(':
                *pchT++ = '\\';
                *pchT++ = '(';
                cchT += 2;
                break;
            case ')':
                *pchT++ = '\\';
                *pchT++ = ')';
                cchT += 2;
                break;
        }
    }
    OutLPR(rgbT, cchT);
}

void
DefaultPSHeader()
{
/* Don't install an error handler for now. If they need one, then they
 * should be installing one onto the printer permanently. SETERROR.PSF
 * is one they can use if they need to.
 */
//OutLPR ("errordict begin\n",0); /* join */
//OutLPR ("/handleerror {\n",0); /* join */
//OutLPR   ("$error begin\n",0); /* join */
//OutLPR     ("newerror {\n",0); /* join */
//OutLPR       ("/newerror false def\n",0); /* join */
//OutLPR       ("showpage\n",0); /* join */
//OutLPR       ("72 72 scale\n",0); /* join */
//OutLPR       ("/Helvetica findfont .2 scalefont setfont\n",0); /* join */
//OutLPR       (".25 10 moveto\n",0); /* join */
//OutLPR       ("(Error/ErrorName = ) show\n",0); /* join */
//OutLPR       ("errorname {\n",0); /* join */
//OutLPR         ("dup type\n",0); /* join */
//OutLPR         ("dup ([ ) show\n",0); /* join */
//OutLPR ("(\n",0); /* join */
//OutLPR ("neringtypeflow\n",0); /* join */
//OutLPR (")\n",0); /* join */
//OutLPR         ("cvs show ( : ) show\n",0); /* join */
//OutLPR         ("/stringtype ne {\n",0); /* join */
//OutLPR ("(\n",0); /* join */
//OutLPR ("neringtypeflow\n",0); /* join */
//OutLPR (")\n",0); /* join */
//OutLPR           ("cvs\n",0); /* join */
//OutLPR         ("} if\n",0); /* join */
//OutLPR       ("show\n",0); /* join */
//OutLPR       ("} exec\n",0); /* join */
//OutLPR       ("( ]; Error/Command = ) show\n",0); /* join */
//OutLPR       ("/command load {\n",0); /* join */
//OutLPR         ("dup type /stringtype ne {\n",0); /* join */
//OutLPR ("(\n",0); /* join */
//OutLPR ("neringtypeflow\n",0); /* join */
//OutLPR (")\n",0); /* join */
//OutLPR           ("cvs\n",0); /* join */
//OutLPR         ("} if show\n",0); /* join */
//OutLPR       ("} exec\n",0); /* join */
//OutLPR       ("( %%) {\n",0); /* join */
//OutLPR         ("{\n",0); /* join */
//OutLPR           ("dup type /stringtype ne {\n",0); /* join */
//OutLPR ("(\n",0); /* join */
//OutLPR ("neringtypeflow\n",0); /* join */
//OutLPR (")\n",0); /* join */
//OutLPR             ("cvs\n",0); /* join */
//OutLPR           ("} if\n",0); /* join */
//OutLPR           ("show\n",0); /* join */
//OutLPR         ("} exec (\n",0); /* join */
//OutLPR (") show\n",0); /* join */
//OutLPR       ("} exec\n",0); /* join */
//OutLPR       ("/x .25 def\n",0); /* join */
//OutLPR       ("/y 10 def\n",0); /* join */
//OutLPR ("\n",0); /* join */
//OutLPR       ("/y y .2 sub def\n",0); /* join */
//OutLPR       ("x y moveto\n",0); /* join */
//OutLPR       ("(Stack =) show\n",0); /* join */
//OutLPR       ("ostack {\n",0); /* join */
//OutLPR         ("/y y .2 sub def x 1 add y moveto\n",0); /* join */
//OutLPR         ("dup type /stringtype ne {\n",0); /* join */
//OutLPR ("(\n",0); /* join */
//OutLPR ("neringtypeflow\n",0); /* join */
//OutLPR (")\n",0); /* join */
//OutLPR           ("cvs\n",0); /* join */
//OutLPR         ("} if\n",0); /* join */
//OutLPR         ("show\n",0); /* join */
//OutLPR       ("} forall\n",0); /* join */
//OutLPR ("\n",0); /* join */
//OutLPR       ("showpage\n",0); /* join */
//OutLPR     ("} if % if (newerror)\n",0);
//OutLPR   ("end\n",0); /* join */
//OutLPR ("} def\n",0); /* join */
//OutLPR ("end\n",0); /* join */
//OutLPR ("\n",0); /* join */
/* End of error handler */

OutLPR ("/inch {72 mul} def\n",0); /* join */
OutLPR ("/White 1 def\n",0); /* join */
OutLPR ("/Black 0 def\n",0); /* join */
OutLPR ("/Gray .9 def\n",0); /* join */
OutLPR ("newpath clippath closepath pathbbox\n",0); /* join */
OutLPR ("/ury exch def\n",0); /* join */
OutLPR ("/urx exch def\n",0); /* join */
OutLPR ("/lly exch def\n",0); /* join */
OutLPR ("/llx exch def\n",0); /* join */
OutLPR ("/PrintWidth urx llx sub def\n",0); /* join */
OutLPR ("/PrintHeight ury lly sub def\n",0); /* join */
OutLPR ("/Mode 0 def\n",0); /* join */
OutLPR ("/doBanner false def\n",0); /* join */
OutLPR ("/MSConfidential false def\n",0); /* join */
OutLPR ("/HeaderHeight 12 def\n",0); /* join */
OutLPR ("/FooterHeight 12 def\n",0); /* join */
OutLPR ("/FontHeight 12 def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/szLine 256 string def\n",0); /* join */
OutLPR ("/Font1 (Courier-Bold) def\n",0); /* join */
OutLPR ("/Font2 (Times-Roman) def\n",0); /* join */
OutLPR ("/Font3 (Helvetica-Bold) def\n",0); /* join */
OutLPR ("Font1 cvn findfont setfont\n",0); /* join */
OutLPR ("/LinesPerPage 62 def\n",0); /* join */
OutLPR ("/AveCharWidth (0) stringwidth pop def\n",0); /* join */
OutLPR ("/CharsPerLine AveCharWidth 86 mul def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/sw { % Add Widths of mulitple strings\n",0);
OutLPR     ("stringwidth pop add\n",0); /* join */
OutLPR ("} bind def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/CenterString {\n",0); /* join */
OutLPR     ("/str exch def /width exch def\n",0); /* join */
OutLPR     ("width str stringwidth pop sub 2 div 0 rmoveto\n",0); /* join */
OutLPR     ("str\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/Box { % put a 'box' path into current path using width and height\n",0);
OutLPR     ("/h exch def\n",0); /* join */
OutLPR     ("/w exch def\n",0); /* join */
OutLPR     ("currentpoint\n",0); /* join */
OutLPR     ("/y exch def\n",0); /* join */
OutLPR     ("/x exch def\n",0); /* join */
OutLPR     ("x w add y lineto\n",0); /* join */
OutLPR     ("x w add y h add lineto\n",0); /* join */
OutLPR     ("x y h add lineto\n",0); /* join */
OutLPR     ("x y lineto\n",0); /* join */
OutLPR ("} bind def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/DoBannerPage {\n",0); /* join */
OutLPR     ("/doBanner false def\n",0); /* join */
OutLPR     ("Mode 1 eq {8.5 inch 0 inch translate 90 rotate} if\n",0); /* join */
OutLPR     ("2 setlinewidth 2 setmiterlimit\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("% Banner Piece #1\n",0);
OutLPR     ("newpath\n",0); /* join */
OutLPR       ("0 PrintHeight moveto\n",0); /* join */
OutLPR       ("llx .5 inch add -1 inch rmoveto\n",0); /* join */
OutLPR       ("PrintWidth 1 inch sub .75 inch Box\n",0); /* join */
OutLPR     ("closepath stroke\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("/XUnit PrintWidth 8 div def\n",0); /* join */
OutLPR     ("/XPos XUnit def\n",0); /* join */
OutLPR     ("/YPos PrintHeight .5 inch sub def\n",0); /* join */
OutLPR     ("/YInc .15 inch def\n",0); /* join */
OutLPR     ("Font2 cvn findfont YInc scalefont setfont\n",0); /* join */
OutLPR     ("XPos YPos moveto (User:) show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto (File Name:) show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto (Date Printed:) show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("/XPos XUnit 4 mul def\n",0); /* join */
OutLPR     ("/YPos PrintHeight .5 inch sub YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto (Directory:) show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto (Time Printed:) show /YPos YPos YInc sub def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("Font1 cvn findfont YInc scalefont setfont\n",0); /* join */
OutLPR     ("/XPos XUnit 2 mul def\n",0); /* join */
OutLPR     ("/YPos PrintHeight .5 inch sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto UserName show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto FileName show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto Date show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("/XPos XUnit 5 mul def\n",0); /* join */
OutLPR     ("/YPos PrintHeight .5 inch sub YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto PathName show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto Time show\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("% Banner Piece #2\n",0);
OutLPR     ("Font3 cvn findfont 1 inch scalefont setfont\n",0); /* join */
OutLPR     ("newpath\n",0); /* join */
OutLPR       ("llx PrintHeight 3 inch sub moveto\n",0); /* join */
OutLPR       ("PrintWidth UserName CenterString true charpath\n",0); /* join */
OutLPR       ("llx PrintHeight 5 inch sub moveto\n",0); /* join */
OutLPR       ("PrintWidth FileName CenterString true charpath\n",0); /* join */
OutLPR     ("closepath\n",0); /* join */
OutLPR     ("gsave\n",0); /* join */
OutLPR       ("Gray setgray fill\n",0); /* join */
OutLPR     ("grestore\n",0); /* join */
OutLPR     ("stroke\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("MSConfidential {\n",0); /* join */
OutLPR       ("Font2 cvn findfont .5 inch scalefont setfont\n",0); /* join */
OutLPR       ("newpath\n",0); /* join */
OutLPR         ("llx PrintHeight 7 inch sub moveto\n",0); /* join */
OutLPR         ("PrintWidth Stamp CenterString show\n",0); /* join */
OutLPR       ("closepath\n",0); /* join */
OutLPR     ("} if\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("showpage\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/BannerPage {\n",0); /* join */
OutLPR     ("/doBanner true def\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/Portrait {\n",0); /* join */
OutLPR     ("/LinesPerPage 66 def\n",0); /* join */
OutLPR     ("/CharsPerLine CharsPerLine Columns div def\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/QuadPage {\n",0); /* join */
OutLPR     ("/LinesPerPage 132 def\n",0); /* join */
OutLPR     ("/CharsPerLine CharsPerLine Columns 2 div div def\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/Landscape {\n",0); /* join */
OutLPR     ("/PrintHeight urx llx sub def\n",0); /* join */
OutLPR     ("/PrintWidth ury lly sub def\n",0); /* join */
OutLPR     ("/Mode 1 def\n",0); /* join */
OutLPR     ("/LinesPerPage 62 def\n",0); /* join */
OutLPR     ("/CharsPerLine CharsPerLine Columns 2 div div def\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/Init {\n",0); /* join */
OutLPR     ("100 0 {dup mul exch dup mul add 1 exch sub} setscreen\n",0); /* join */
OutLPR     ("PrintWidth Columns div .02 mul\n",0); /* join */
OutLPR     ("/BorderX exch def\n",0); /* join */
OutLPR     ("PrintWidth BorderX sub Columns div BorderX sub\n",0); /* join */
OutLPR     ("/PageWidth exch def\n",0); /* join */
OutLPR     ("PrintHeight HeaderHeight FooterHeight add sub\n",0); /* join */
OutLPR     ("/PageHeight exch def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("/FontHeight PageHeight LinesPerPage div def\n",0); /* join */
OutLPR     ("/FontWidth PageWidth CharsPerLine div def\n",0); /* join */
OutLPR     ("/PageNumber 1 def\n",0); /* join */
OutLPR     ("PageHeight FooterHeight add FontHeight sub\n",0); /* join */
OutLPR     ("/topY exch def\n",0); /* join */
OutLPR     ("/currentY topY def\n",0); /* join */
OutLPR     ("FooterHeight FontHeight add\n",0); /* join */
OutLPR     ("/bottomY exch def\n",0); /* join */
OutLPR     ("BorderX 1.25 mul\n",0); /* join */
OutLPR     ("/currentX exch def\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/PageBorder {\n",0); /* join */
OutLPR     ("% Gray backgound\n",0);
OutLPR     ("currentgray\n",0); /* join */
OutLPR     ("newpath clippath closepath Gray setgray fill\n",0); /* join */
OutLPR     ("setgray\n",0); /* join */
OutLPR     ("Label {\n", 0); /* join */
OutLPR         ("Font2 cvn findfont FooterHeight scalefont setfont\n",0); /* join */
OutLPR         ("% Left Justify UserName\n",0);
OutLPR         ("BorderX 2 moveto\n",0); /* join */
OutLPR         ("UserName show\n",0); /* join */
OutLPR         ("PrintWidth 2 div 2 moveto\n",0); /* join */
OutLPR         ("% Center File Name\n",0);
OutLPR         ("0 PathName sw (\\\\) sw FileName sw 2 div neg 0 rmoveto\n",0); /* join */
OutLPR         ("PathName show (\\\\) show FileName show\n",0); /* join */
OutLPR         ("% Right Justify Date\n",0);
OutLPR         ("PrintWidth BorderX sub 2 moveto\n",0); /* join */
OutLPR         ("FTime stringwidth pop neg 0 rmoveto FTime show\n",0); /* join */
OutLPR     ("} if\n", 0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/Confidential {\n",0); /* join */
OutLPR   ("MSConfidential {\n",0); /* join */
OutLPR     ("gsave\n",0); /* join */
OutLPR       ("PageWidth 2 div PageHeight 2 div moveto Font2 cvn findfont\n",0); /* join */
OutLPR       ("setfont Stamp stringwidth pop PageWidth exch div dup 30\n",0); /* join */
OutLPR       ("rotate PageWidth 2 div neg 0 rmoveto scale\n",0); /* join */
OutLPR       ("Stamp true charpath closepath gsave Gray setgray fill\n", 0);
OutLPR       ("grestore 0 setlinewidth stroke\n",0);
OutLPR     ("grestore\n",0); /* join */
OutLPR   ("} if\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/NewPage {\n",0); /* join */
OutLPR     ("/currentY topY def\n",0); /* join */
OutLPR     ("Columns 1 gt PageNumber 1 sub Columns mod 0 ne and {\n",0); /* join */
OutLPR         ("% Don't do this on first column of page\n",0);
OutLPR         ("PageWidth BorderX add 0 translate\n",0); /* join */
OutLPR     ("} {\n",0); /* join */
OutLPR         ("% Do this only for first column of page\n",0);
OutLPR         ("llx lly translate\n",0); /* join */
OutLPR         ("Mode 1 eq { PrintHeight 0 translate 90 rotate } if\n",0); /* join */
OutLPR         ("PageBorder\n",0); /* join */
OutLPR     ("} ifelse\n",0); /* join */
OutLPR     ("newpath % Frame the page\n",0);
OutLPR         ("BorderX FooterHeight moveto\n",0); /* join */
OutLPR         ("PageWidth PageHeight Box\n",0); /* join */
OutLPR     ("closepath\n",0); /* join */
OutLPR     ("gsave\n",0); /* join */
OutLPR         ("White setgray fill\n",0); /* join */
OutLPR     ("grestore\n",0); /* join */
OutLPR     ("Black setgray stroke\n",0); /* join */
OutLPR     ("Confidential\n",0);
OutLPR     ("Font2 cvn findfont HeaderHeight scalefont setfont\n",0); /* join */
OutLPR     ("BorderX PageWidth 2 div add FooterHeight PageHeight add 2 add moveto\n",0); /* join */
OutLPR     ("Label {\n", 0); /* join */
OutLPR         ("PageNumber szLine cvs show\n",0); /* join */
OutLPR     ("} if\n", 0);
OutLPR     ("Font1 cvn findfont [FontWidth 0 0 FontHeight 0 0] makefont setfont\n",0); /* join */
OutLPR     ("/PageNumber PageNumber 1 add def\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/EndPage {\n",0); /* join */
OutLPR     ("Columns 1 eq PageNumber 1 sub Columns mod 0 eq or { showpage } if\n",0); /* join */
OutLPR     ("NewPage\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/PrintLine {\n",0); /* join */
OutLPR     ("dup dup length 0 gt {\n",0); /* join */
OutLPR         ("% Something there\n",0);
OutLPR         ("0 get 12 eq {\n",0); /* join */
OutLPR             ("% Form Feed\n",0);
OutLPR             ("EndPage\n",0); /* join */
OutLPR         ("}{\n",0); /* join */
OutLPR             ("currentX currentY moveto show\n",0); /* join */
OutLPR             ("/currentY currentY FontHeight sub def\n",0); /* join */
OutLPR             ("currentY bottomY le { EndPage } if\n",0); /* join */
OutLPR         ("} ifelse\n",0); /* join */
OutLPR     ("}{\n",0); /* join */
OutLPR         ("% Blank Line\n",0);
OutLPR         ("pop pop pop\n",0); /* join */
OutLPR         ("/currentY currentY FontHeight sub def\n",0); /* join */
OutLPR         ("currentY bottomY le { EndPage } if\n",0); /* join */
OutLPR     ("} ifelse\n",0); /* join */
OutLPR ("}bind def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/DebugOut {\n",0); /* join */
OutLPR     ("/num exch def\n",0); /* join */
OutLPR     ("/str exch def\n",0); /* join */
OutLPR     ("currentpoint\n",0); /* join */
OutLPR     ("str show\n",0); /* join */
OutLPR     ("num szLine cvs show\n",0); /* join */
OutLPR     ("moveto\n",0); /* join */
OutLPR     ("0 -11 rmoveto\n",0); /* join */
OutLPR ("}bind def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/PrintFile {\n",0); /* join */
OutLPR     ("Init % Initialize some values\n",0);
OutLPR     ("doBanner { DoBannerPage } if\n",0); /* join */
OutLPR     ("NewPage\n",0); /* join */
OutLPR     ("{\n",0); /* join */
OutLPR         ("currentfile szLine readline not {exit} if\n",0); /* join */
OutLPR         ("dup dup length 0 gt { 0 get 28 eq {exit} if } if\n",0); /* join */
OutLPR         ("PrintLine\n",0); /* join */
OutLPR     ("} loop\n",0); /* join */
OutLPR     ("showpage % Will this *ever* produce an unwanted blank page?\n",0);
OutLPR ("} bind def\n",0); /* join */
} /* DefaultPSHeader */


void
InitPrinter()
{
    char *szHeader;
    char *szDirlist;
    char szFullname[MAX_PATH];
    BOOL fConcat = FALSE;
    FILE *psfFile;

    register char *pch;

    if (fLaser) {
        OutLPR(RESETPRINTER, 0);
        if (fVDuplex) {
                OutLPR(BEGINDUPLEXVERT,0);
        } else if (fHDuplex)
                OutLPR(BEGINDUPLEXHOR,0);
    } else if (fPostScript) {
        /* write the job setup for postscript */
        OutLPR("\n\004\n% ppr job\n", 0); /* ^D to flush previous job */
        if (!fPSF) {
            DefaultPSHeader();
        } else {
            szHeader = szPSF;
            if (*szHeader == '+') {
                szHeader++; // step over the '+'
                fConcat = TRUE;
                DefaultPSHeader();
            }

/* Lets make an attempt to use environment variables... */
            if ((*szHeader == '$') && ((pch = strchr(++szHeader,':')) != NULL)) {
                    *pch      = (char)NULL;
                    _strupr(szHeader);
                    szDirlist = getenvOem(szHeader);
//                    szDirlist = getenv(szHeader);
                    *pch      = ':';
                    szHeader  = ++pch;
            } else {
                    szDirlist = NULL;
            }

            while (szDirlist) {
                    szDirlist = SzFindPath(szDirlist,szFullname,szHeader);
                    szHeader = szFullname;
            }
/* ...end of attempt */

            if ((psfFile = fopen(szHeader, szROBin)) != NULL) {
                int cb;
                char psfLine[cchLineMax];
                char szFFile[MAX_PATH];

                rootpath (szHeader, szFFile);
                _strupr(szFFile);
                fprintf (stdout, "\nUsing PSF File: %s\n", szFFile);
                while ((cb = fread(psfLine, 1, cchLineMax, psfFile)) > 0)
                    RawOut(psfLine, cb);
            } else {
                fprintf (stdout, "Error opening PSF file %s\n", szPSF);
                if (!fConcat) {
                    fprintf (stdout, "Continuing with default header...\n");
                    DefaultPSHeader();
                }
            }
        }
    }
}



void
MyOpenPrinter()
{
    if (strcmp(szPName, "-") == 0) {
        pfileLPR = stdout;
        _setmode((int)_fileno(pfileLPR), (int)O_BINARY);
    } else {
        if ((pfileLPR = fopen(szPName, szWOBin)) == NULL)
            Fatal("Error opening output file %s", szPName);
    }
    InitPrinter();
}


void
FlushPrinter()
{
    /* A FormFeed is sent before each page.  For fForceFF, we also send
       one after the last page.  For !fForceFF we move to the top of
       the page so that when the network software outputs \r\n\f, we do
       not get a blank page.

       NOTE: for !fForceFF we don't reset the printer or change modes back
       to portrait since that causes any unfinished page to be ejected.
    */
    if (fLaser) {
        if (fVDuplex || fHDuplex)
            OutLPR(BEGINSIMPLEX,0);
        else
            if (fForceFF)
                OutLPR(RESETPRINTER, 0);
            else
                OutLPR(MOVETOTOP, 0);
    }
    else if (fPostScript)
        OutLPR("\n\004\n", 0); /* ^D to flush */
    else
        OutLPR("\n\n",0);       /* force last line on LP */
}



void
MyClosePrinter()
{
    if (pfileLPR == 0)
        return;         /* already closed */

    FlushPrinter();
    if (pfileLPR != stdout)
        fclose(pfileLPR);
    pfileLPR = NULL;
}



/* Fill szBuf with first non-blank substring found in sz;  return pointer
   to following non-blank.  Note: ',' is considered a separator as are ' '
   and '\t' however, ',' is also considered a non-blank.
*/
char *
SzGetSzSz(
    char * sz,
    char * szBuf
    )
{
    int cch;

    sz += strspn(sz, " \t");
    cch = strcspn(sz, " \t,");
    szBuf[0] = '\0';
    if (cch)        /* count of 0 causes error on Xenix 286 */
        strncat(szBuf, sz, cch);
    sz += cch;
    sz += strspn(sz, " \t");
    return sz;
}




char *
SzGetPrnName(
    char *sz,
    char *szBuf
    )
{
    register char  *pch;

    sz = SzGetSzSz(sz, szBuf);
    if (*(pch = szBuf+strlen(szBuf)-1) == ':')
        *pch = '\0';    /* Remove colon from end of printer name */
    return (sz);
}




/*   get printer name and net redirection from a string
 *
 *      Entry:  sz - string to parse;
 *              szPName contains printer name that user requested to use
 *
 *      Return Value:   TRUE  if printer name found matches and thus
 *                      the rest of the string was processed;
 *                      FALSE  if no match and thus string is ignored
 *
 *      Global Variables Set:
 *
 *      szPName - Physical printer port to use, or output file name
 *      szNet   - Network redirection name
 *      szPass  - Network password
 *
 *      printer desc:
 *        (DOS)   [<name> [none | \\<machine>\<shortname> [<password>]]] [,<options>]
 *        (Xenix) [ ( [ net[#] | lpr[#] | xenix[#] | alias[#] ] [<name>] )  |
 *                  ( dos[#] [<server> <shortname> [<password>] ) ]  [,<options>]
 *
 *      The optional network password must be separated from the network name
 *      by some space (it may not contain space, TAB or comma).
 */
BOOL
FParseSz(
    char *sz
    )
{
    char szT[cchArgMax];

    sz = SzGetPrnName(sz, szT); // Get first 'word', remove colon
    if (strcmpx(szT, szPName)) {
        // first word is not the printer name the user requested
        return (FALSE);
    }

    if (*sz != ',') {
        sz = SzGetSzSz(sz, szT); // Get next 'word'

        if (szT[strlen(szT)-1] == ':') {
            // Possible physical 'port'
            SzGetPrnName (szT, szPName);
            sz = SzGetSzSz(sz, szT);
        }

        if (*szT)
            strcpy(szNet, szT);     // Network redirection name

        if (*sz != ',') {
            sz= SzGetSzSz(sz, szT);
            if (*szT)
                strcpy(szPass, szT); // Network Password
        }
    }

    /* We are setting printer info, display it if we were asked to */
    if (fVerify) {
        fprintf (stdout, "Local printer name : %s\n", szPName);
        fprintf (stdout, "Options specified  : %s\n", sz);
        fprintf (stdout, "Remote printer name: %s\n", szNet);
    }

    DoOptSz(sz); // Now read any options that followed
    return (TRUE);
}



void
SetupPrinter()
/* determine printer name and options */
{
    char rgbSW[cchArgMax];
    char szEName[cchArgMax];                /* name of printer in $PRINTER*/
    char *szT;
    FILE *pfile;
    BOOL fNoDest = TRUE;

    /* determine name of printer in $PRINTER (if one) */
    szEName[0] = '\0';
    if ((szT=getenvOem("PRINTER")) != NULL) {
        if (fVerify) {
            fprintf (stdout, "Using 'PRINTER' environment string:\n");
        }
        fNoDest = FALSE;
        SzGetPrnName(szT, szEName);
    }

    /* determine actual printer name to use; one of -p, $PRINTER, default */
    if (szPDesc != NULL) {
        fNoDest = FALSE;
        SzGetPrnName(szPDesc, szPName);
    } else {
        if (*szEName) {
            strcpy(szPName, szEName);
        } else {
            strcpy(szPName, PRINTER);
        }
    }

    /* if printer to use is the same as the one in $PRINTER, set up the
       options from $PRINTER (options from szPDesc below).
    */
    if (strcmpx(szPName, szEName) == 0) {
        if (szT)
            FParseSz(szT);
    } else {
        /* search parameter file */
        if ((pfile = swopen("$INIT:Tools.INI", "ppr")) != NULL) {
            /* 'PPR' tag found in '$INIT:TOOLS.INI' */
            while (swread(rgbSW, cchArgMax, pfile) != 0) {
                /* a switch line was read... */
                fNoDest = FALSE;
                szT = rgbSW + strspn(rgbSW, " \t"); // skip spaces, tabs

                /* a line "default=<printer>" sets szPName **
                ** if there is no environment setting      **
                ** and no command line parameter -p        */
                if (_strnicmp(szT, DEFAULT, strlen(DEFAULT))==0 &&
                    szPDesc==NULL && *szEName == 0)
                {
                    if ((szT = strchr(szT,'=')) != NULL) {
                        SzGetSzSz(szT+1, szPName);
                        FParseSz(szT+1);
                    } else {
                        fprintf(stderr, "ppr: warning: "
                            "default setting in setup file incomplete\n");
                    }
                } else {
                    if (FParseSz(szT)) {
                        break;
                    }
                }
            }
            swclose(pfile);
        }
    }

    /* command line printer description overrides other settings */
    if (szPDesc != NULL)
        FParseSz(szPDesc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\procmon\procmon.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    procmon.c

Abstract:

    Little program for recording the various idle states of a machine

Author:

    John Vert (jvert) 1/14/2000

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <conio.h>

#define DISPLAY_TOTAL 0
#define DISPLAY_DELTA 1
#define DISPLAY_RAW   2
#define DISPLAY_INFO  3
#define DISPLAY_TRANS 4

int Display=DISPLAY_TOTAL;
int LastDisplay=DISPLAY_TOTAL;
LONG DelayTime = 5;

#define printtime(_x_) {                                               \
        ULONGLONG ms = (_x_)/10000;                                    \
        ULONG hours, minutes, seconds;                                 \
        hours = (ULONG)ms/(1000*60*60);                                \
        if (hours) printf("%3d:",(ULONG)(ms/(1000*60*60)));            \
        ms=ms%(1000*60*60);                                            \
        minutes = (ULONG)ms/(1000*60);                                 \
        if (minutes || hours) printf("%02d:",(ULONG)(ms/(1000*60)));   \
        ms=ms%(1000*60);                                               \
        seconds = (ULONG)ms/1000;                                      \
        printf("%02d.",seconds);                                       \
        ms=ms%1000;                                                    \
        printf("%03d",(ULONG)ms);                                      \
    }

__cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    CHAR            Buff[sizeof(SYSTEM_PROCESSOR_POWER_INFORMATION)*MAXIMUM_PROCESSORS];
    PSYSTEM_PROCESSOR_POWER_INFORMATION PowerInfo = (PSYSTEM_PROCESSOR_POWER_INFORMATION)Buff;
    ULONG           Length;
    NTSTATUS        Status;
    UCHAR           LastAdjustedBusyFrequency[MAXIMUM_PROCESSORS];
    UCHAR           LastBusyFrequency[MAXIMUM_PROCESSORS];
    UCHAR           LastC3Frequency[MAXIMUM_PROCESSORS];
    ULONGLONG       LastFrequencyTime[MAXIMUM_PROCESSORS];
    ULONG           PromotionCount[MAXIMUM_PROCESSORS];
    ULONG           DemotionCount[MAXIMUM_PROCESSORS];
    ULONGLONG       LastIdleTime[MAXIMUM_PROCESSORS];
    ULONGLONG       LastKernelTime[MAXIMUM_PROCESSORS];
    ULONGLONG       DeltaTime;
    ULONG           i;
    ULONG           NumProc;
    LARGE_INTEGER   Delay;
    ULONG           Delta;

    for (i = 0; i < MAXIMUM_PROCESSORS; i++) {

        LastFrequencyTime[i] = 0;
        PromotionCount[i] = DemotionCount[i] = 0;

    }

    while (1) {
        if (_kbhit()) {
            int Char=_getch();
            switch (toupper(Char)) {
                case 'T':
                    LastDisplay = Display = DISPLAY_TOTAL;
                    break;
                case 'E':
                    LastDisplay = Display = DISPLAY_TRANS;
                    break;
                case 'D':
                    LastDisplay = Display = DISPLAY_DELTA;
                    break;
                case 'R':
                    LastDisplay = Display = DISPLAY_RAW;
                    break;
                case 'I':
                    LastDisplay = Display;
                    Display = DISPLAY_INFO;
                    break;
                case '+':
                    DelayTime++;
                    printf("New delay is %d seconds.\n",DelayTime);
                    break;
                case '-':
                    if (DelayTime > 2) {
                        DelayTime--;
                        printf("New delay is %d seconds.\n",DelayTime);
                    } else {
                        printf("Delay cannot drop below %d seconds.\n",DelayTime);
                    }
                    break;
                case 'Q':
                    return 0;
                case 'P':
                    printf("Hit a key to continue\n");
                    _getch();
                    break;

                default:
                    printf("Type :\n");
                    printf("\t'T'     - display Total\n");
                    printf("\t'E'     - display Transitions\n");
                    printf("\t'D'     - display Delta\n");
                    printf("\t'R'     - display Raw\n");
                    printf("\t'I'     - display quick info\n");
                    printf("\t'+'/'-' - increase/decrease time pause\n");
                    printf("\t'Q'     - Quit\n");
                    printf("\t'P'     - Pause\n");

            }
        }
        Status = NtQuerySystemInformation(
            SystemProcessorPowerInformation,
            PowerInfo,
            sizeof(Buff),
            &Length
            );
        if (!NT_SUCCESS(Status)) {

            fprintf(stderr, "NtQuerySystemInformation failed: %lx\n",Status);
            return(Status);

        }

        NumProc = Length/sizeof(SYSTEM_PROCESSOR_POWER_INFORMATION);
        for (i=0;i<NumProc;i++) {

            if (NumProc > 1) {

                printf("%2d>",i);

            }

            switch (Display) {
                case DISPLAY_TOTAL:
                    printf("Freq %3d%% (%3d%% %3d%% %3d%%) ",
                           PowerInfo[i].CurrentFrequency,
                           PowerInfo[i].LastAdjustedBusyFrequency,
                           PowerInfo[i].LastBusyFrequency,
                           PowerInfo[i].LastC3Frequency
                           );
                    printtime(PowerInfo[i].CurrentFrequencyTime);
                    printf(" Sys ");
                    printtime(PowerInfo[i].CurrentProcessorTime);
                    printf(" Idle ");
                    printtime(PowerInfo[i].CurrentProcessorIdleTime);
                    break;
                case DISPLAY_TRANS:
                    printf("Freq %3d%% (%3d%% %3d%% %3d%%) ",
                           PowerInfo[i].CurrentFrequency,
                           PowerInfo[i].LastAdjustedBusyFrequency,
                           PowerInfo[i].LastBusyFrequency,
                           PowerInfo[i].LastC3Frequency
                           );
                    printf("#P: %d #D %d #E: %d #R: %d",
                           PowerInfo[i].PromotionCount,
                           PowerInfo[i].DemotionCount,
                           PowerInfo[i].ErrorCount,
                           PowerInfo[i].RetryCount
                           );
                    break;
                case DISPLAY_DELTA:
                    printf("Freq %3d%% (%3d%% %3d%% %3d%%) ",
                           PowerInfo[i].CurrentFrequency,
                           (PowerInfo[i].LastAdjustedBusyFrequency - LastAdjustedBusyFrequency[i]),
                           (PowerInfo[i].LastBusyFrequency - LastBusyFrequency[i]),
                           (PowerInfo[i].LastC3Frequency - LastC3Frequency[i])
                           );
                    DeltaTime = PowerInfo[i].CurrentFrequencyTime - LastFrequencyTime[i];
                    printtime(DeltaTime);
                    printf(" Sys ");
                    printtime((PowerInfo[i].CurrentProcessorTime - LastKernelTime[i]));
                    printf(" Idle ");
                    printtime((PowerInfo[i].CurrentProcessorIdleTime - LastIdleTime[i]));
                    break;

                case DISPLAY_RAW:
                    printf("Freq %3d%% (%3d%% %3d%% %3d%%) %I64X #E %8d #R %8d",
                           PowerInfo[i].CurrentFrequency,
                           PowerInfo[i].LastAdjustedBusyFrequency,
                           PowerInfo[i].LastBusyFrequency,
                           PowerInfo[i].LastC3Frequency,
                           PowerInfo[i].CurrentFrequencyTime,
                           PowerInfo[i].ErrorCount,
                           PowerInfo[i].RetryCount
                           );
                    break;
                case DISPLAY_INFO:
                    printf("Frequencies: Current =%3d%% MaxProc =%3d%% MinProc =%3d%%\n"
                           "Percentages: Adjusted=%3d%% Busy    =%3d%% C3      =%3d%%\n"
                           "Limiters:    Thermal =%3d%% Constant=%3d%% Degraded=%3d%%\n"
                           "Counts:      Promote =%4d Demote =%4d\n"
                           "Status:      Retries =%4d Errors =%4d",
                           PowerInfo[i].CurrentFrequency,
                           PowerInfo[i].ProcessorMaxThrottle,
                           PowerInfo[i].ProcessorMinThrottle,
                           PowerInfo[i].LastAdjustedBusyFrequency,
                           PowerInfo[i].LastBusyFrequency,
                           PowerInfo[i].LastC3Frequency,
                           PowerInfo[i].ThermalLimitFrequency,
                           PowerInfo[i].ConstantThrottleFrequency,
                           PowerInfo[i].DegradedThrottleFrequency,
                           PowerInfo[i].PromotionCount,
                           PowerInfo[i].DemotionCount,
                           PowerInfo[i].RetryCount,
                           PowerInfo[i].ErrorCount
                           );
                    break;
            }

            LastAdjustedBusyFrequency[i] = PowerInfo[i].LastAdjustedBusyFrequency;
            LastBusyFrequency[i] = PowerInfo[i].LastBusyFrequency;
            LastC3Frequency[i] = PowerInfo[i].LastC3Frequency;
            LastFrequencyTime[i] = PowerInfo[i].CurrentFrequencyTime;
            PromotionCount[i] = PowerInfo[i].PromotionCount;
            DemotionCount[i] = PowerInfo[i].DemotionCount;
            LastIdleTime[i] = PowerInfo[i].CurrentProcessorIdleTime;
            LastKernelTime[i] = PowerInfo[i].CurrentProcessorTime;
            printf("\n");
        }

        //
        // Revert Back to whatever we were displaying before...
        //
        if (Display != LastDisplay) {

            Display = LastDisplay;

        }

        Delay.QuadPart = - DelayTime * 1000 * 1000 * 10;
        NtDelayExecution(FALSE, &Delay);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profile\profile.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <windows.h>

int
__cdecl main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    LPSTR s;
    LPSTR CommandLine;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL b;
    HANDLE MappingHandle;
    PVOID SharedMemory;

    argv;
    envp;

    if ( argc < 2 ) {
        puts("Usage: profile [/a] [/innn] [/k] name-of-image [parameters]...\n"
             "       /a       All hits\n"
             "       /bnnn    Set profile bucket size to 2 to the nnn bytes\n"
             "       /ffilename Output to filename\n"
             "       /innn    Set profile interval to nnn (in 100ns units)\n"
             "       /k		profile system modules\n"
             "       /s[profilesource] Use profilesource instead of clock interrupt\n"
             "       /S[profilesource] Use profilesource as secondary profile source\n\n"
#if defined (_ALPHA_)
             "Currently supported profile sources are 'align', 'totalissues', 'pipelinedry'\n"
             "  'loadinstructions', 'pipelinefrozen', 'branchinstructions', 'totalnonissues',\n"
             "  'dcachemisses', 'icachemisses', 'branchmispredicts', 'storeinstructions'\n"
#endif
             );
        ExitProcess(1);
        }

    s = CommandLine = GetCommandLine();

    //
    // skip blanks
    //
    while(*s>' ')s++;

    //
    // get to next token
    //
    while(*s<=' ')s++;

    while ((*s == '-') ||
           (*s == '/')) {
        s++;
        while (*s>' '){
            s++;
            }
        //
        // get to next token
        //
        while(*s<=' ')s++;
        }

    //
    // Create named shared memory to pass parameters to psapi
    //
    MappingHandle = CreateFileMapping((HANDLE)-1,
                                      NULL,
                                      PAGE_READWRITE,
                                      0,
                                      4096,
                                      "ProfileStartupParameters");
    if (MappingHandle != NULL) {
        SharedMemory = MapViewOfFile(MappingHandle,
                                     FILE_MAP_WRITE,
                                     0,
                                     0,
                                     0);
        if (SharedMemory) {
            //
            // Copy command line parameters into shared memory
            //
            strncpy(SharedMemory, CommandLine, (size_t)(s-CommandLine));
            UnmapViewOfFile(SharedMemory);
        }
    }

    memset(&StartupInfo,0,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    b = CreateProcess(
            NULL,
            s,
            NULL,
            NULL,
            TRUE,
            PROFILE_USER,
            NULL,
            NULL,
            &StartupInfo,
            &ProcessInformation
            );
    if ( !b ) {
        printf("CreateProcess(%s) failed %lx\n",s,GetLastError());
        ExitProcess(GetLastError());
        }
    WaitForSingleObject(ProcessInformation.hProcess, (DWORD)-1);

    if (MappingHandle) {
        if (SharedMemory) {
            UnmapViewOfFile(SharedMemory);
        }
        CloseHandle(MappingHandle);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\86dis.c ===
/*    @ Author: Gerd Immeyer              @ Version:                       */
/*                                                                         */
/*    @ Creation Date: 10.19.89           @ Modification Date:             */
/*                                                                         */
/***************************************************************************/

//
// Munged for my purposes on 10/20/99 (v-johnwh)
//
#include <string.h>

typedef unsigned long       DWORD;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
typedef unsigned __int64 ULONGLONG;
typedef int                 BOOL;
typedef ULONG *PULONG;
typedef void * PVOID;
#define ADDR_V86        ((USHORT)0x0002)
#define ADDR_16         ((USHORT)0x0004)
#define FALSE               0
#define TRUE                1
#define BIT20(b) (b & 0x07)
#define BIT53(b) (b >> 3 & 0x07)
#define BIT76(b) (b >> 6 & 0x03)
#define MAXL     16
#define MAXOPLEN 10
#define REGDS           3
#define REGSS           15
#define REGEBX          6
#define REGEBP          10
#define REGEDI          4
#define REGESI          5
#define REGEAX          9
#define REGECX          8
#define REGEDX          7
#define REGESP          14
#define Off(x)          ((x).off)
#define Type(x)         ((x).type)

#define OBOFFSET 26
#define OBOPERAND 34
#define OBLINEEND 77
#define MAX_SYMNAME_SIZE  1024

#include "86dis.h"

ULONG      X86BrkptLength = 1L;
ULONG      X86TrapInstr = 0xcc;

/*****                     static tables and variables                 *****/
static char regtab[] = "alcldlblahchdhbhaxcxdxbxspbpsidi";  /* reg table */
static char *mrmtb16[] = { "bx+si",  /* modRM string table (16-bit) */
                           "bx+di",
                           "bp+si",
                           "bp+di",
                           "si",
                           "di",
                           "bp",
                           "bx"
                         };

static char *mrmtb32[] = { "eax",       /* modRM string table (32-bit) */
                           "ecx",
                           "edx",
                           "ebx",
                           "esp",
                           "ebp",
                           "esi",
                           "edi"
                         };

static char seg16[8]   = { REGDS,  REGDS,  REGSS,  REGSS,
                           REGDS,  REGDS,  REGSS,  REGDS };
static char reg16[8]   = { REGEBX, REGEBX, REGEBP, REGEBP,
                           REGESI, REGEDI, REGEBP, REGEBX };
static char reg16_2[4] = { REGESI, REGEDI, REGESI, REGEDI };

static char seg32[8]   = { REGDS,  REGDS,  REGDS,  REGDS,
                           REGSS,  REGSS,  REGDS,  REGDS };
static char reg32[8]   = { REGEAX, REGECX, REGEDX, REGEBX,
                           REGESP, REGEBP, REGESI, REGEDI };

static char sregtab[] = "ecsdfg";  // first letter of ES, CS, SS, DS, FS, GS

char    hexdigit[] = { '0', '1', '2', '3', '4', '5', '6', '7',
                       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

typedef struct _DECODEDATA
{
  int              mod;            /* mod of mod/rm byte */
  int              rm;             /* rm of mod/rm byte */
  int              ttt;            /* return reg value (of mod/rm) */
  unsigned char    *pMem;          /* current position in instruction */
  ADDR             EAaddr[2];      //  offset of effective address
  int              EAsize[2];      //  size of effective address item
  char             *pchEAseg[2];   //  normal segment for operand
  BOOL             fMovX;          // indicates a MOVSX or MOVZX
  BOOL             fMmRegEa;       // Use mm? registers in reg-only EA.
} DECODEDATA;
/*...........................internal function..............................*/
/*                                                                          */
/*                       generate a mod/rm string                           */
/*                                                                          */

void DIdoModrm (char **ppchBuf, int segOvr, DECODEDATA *decodeData)
{
    int     mrm;                        /* modrm byte */
    char    *src;                       /* source string */
    int     sib;
    int     ss;
    int     ind;
    int     oldrm;

    mrm = *(decodeData->pMem)++;                      /* get the mrm byte from instruction */
    decodeData->mod = BIT76(mrm);                   /* get mod */
    decodeData->ttt = BIT53(mrm);                   /* get reg - used outside routine */
    decodeData->rm  = BIT20(mrm);                   /* get rm */

    if (decodeData->mod == 3) {                     /* register only mode */
        if (decodeData->fMmRegEa) {
            *(*ppchBuf)++ = 'm';
            *(*ppchBuf)++ = 'm';
            *(*ppchBuf)++ = decodeData->rm + '0';
        } else {
            src = &regtab[decodeData->rm * 2];          /* point to 16-bit register */
            if (decodeData->EAsize[0] > 1) {
                src += 16;                  /* point to 16-bit register */
                if (!(decodeData->fMovX))
                    *(*ppchBuf)++ = 'e';    /* make it a 32-bit register */
            }
            *(*ppchBuf)++ = *src++;         /* copy register name */
            *(*ppchBuf)++ = *src;
        }
        decodeData->EAsize[0] = 0;                  //  no EA value to output
        return;
        }

    if (1) {                       /* 32-bit addressing mode */
        oldrm = decodeData->rm;
        if (decodeData->rm == 4) {                  /* rm == 4 implies sib byte */
            sib = *(decodeData->pMem)++;              /* get s_i_b byte */
            decodeData->rm = BIT20(sib);            /* return base */
            }

        *(*ppchBuf)++ = '[';
        if (decodeData->mod == 0 && decodeData->rm == 5) {
            decodeData->pMem += 4;
            }

        if (oldrm == 4) {               //  finish processing sib
            ind = BIT53(sib);
            if (ind != 4) {
                *(*ppchBuf)++ = '+';
                ss = 1 << BIT76(sib);
                if (ss != 1) {
                    *(*ppchBuf)++ = '*';
                    *(*ppchBuf)++ = (char)(ss + '0');
                    }
            }
        }
	}

    //  output any displacement

    if (decodeData->mod == 1) {
        decodeData->pMem++;
        }
    else if (decodeData->mod == 2) {
        long tmp = 0;
        if (1) {
            decodeData->pMem += 4;
            }
        else {
            decodeData->pMem += 2;
            }
        }
}

DWORD GetInstructionLengthFromAddress(PVOID paddr)
{
    PULONG  pOffset = 0;
    int     G_mode_32;
    int     mode_32;                    /* local addressing mode indicator */
    int     opsize_32;                  /* operand size flag */
    int     opcode;                     /* current opcode */
    int     olen = 2;                   /* operand length */
    int     alen = 2;                   /* address length */
    int     end = FALSE;                /* end of instruction flag */
    int     mrm = FALSE;                /* indicator that modrm is generated*/
    unsigned char *action;              /* action for operand interpretation*/
    long    tmp;                        /* temporary storage field */
    int     indx;                       /* temporary index */
    int     action2;                    /* secondary action */
    int     instlen;                    /* instruction length */
    int     segOvr = 0;                 /* segment override opcode */
    unsigned char *membuf;              /* current instruction buffer */
    char    *pEAlabel = "";             /* optional label for operand */
    char    RepPrefixBuffer[32];        /* rep prefix buffer */
    char    *pchRepPrefixBuf = RepPrefixBuffer; /* pointer to prefix buffer */
    char    OpcodeBuffer[8];            /* opcode buffer */
    char    *pchOpcodeBuf = OpcodeBuffer; /*  pointer to opcode buffer */
    char    OperandBuffer[MAX_SYMNAME_SIZE + 20]; /*  operand buffer */
    char    *pchOperandBuf = OperandBuffer; /* pointer to operand buffer */
    char    ModrmBuffer[MAX_SYMNAME_SIZE + 20];   /* modRM buffer */
    char    *pchModrmBuf = ModrmBuffer; /* pointer to modRM buffer */
    char    EABuffer[42];               /* effective address buffer */
    char    *pchEABuf = EABuffer;       /* pointer to EA buffer */

    unsigned char BOPaction;
    int     subcode;                    /* bop subcode */
    DECODEDATA decodeData;

    decodeData.fMovX = FALSE;
    decodeData.fMmRegEa = FALSE;
    decodeData.EAsize[0] = decodeData.EAsize[1] = 0;          //  no effective address
    decodeData.pchEAseg[0] = dszDS_;
    decodeData.pchEAseg[1] = dszES_;

    G_mode_32 = 1;

    mode_32 = opsize_32 = (G_mode_32 == 1); /* local addressing mode */
    olen = alen = (1 + mode_32) << 1;   //  set operand/address lengths
                                        //  2 for 16-bit and 4 for 32-bit
#if MULTIMODE
    if (paddr->type & (ADDR_V86 | ADDR_16)) {
        mode_32 = opsize_32 = 0;
        olen = alen = 2;
        }
#endif

    membuf = (unsigned char *)paddr;
                                
    decodeData.pMem = membuf;                      /* point to begin of instruction */
    opcode = *(decodeData.pMem)++;                   /* get opcode */

    if ( opcode == 0xc4 && *(decodeData.pMem) == 0xC4 ) {
        (decodeData.pMem)++;
        action = &BOPaction;
        BOPaction = IB | END;
        subcode =  *(decodeData.pMem);
        if ( subcode == 0x50 || subcode == 0x52 || subcode == 0x53 || subcode == 0x54 || subcode == 0x57 || subcode == 0x58 || subcode == 0x58 ) {
            BOPaction = IW | END;
        }
    } else {
        action = actiontbl + distbl[opcode].opr; /* get operand action */
    }

/*****          loop through all operand actions               *****/

    do {
        action2 = (*action) & 0xc0;
        switch((*action++) & 0x3f) {
            case ALT:                   /* alter the opcode if 32-bit */
                if (opsize_32) {
                    indx = *action++;
                    pchOpcodeBuf = &OpcodeBuffer[indx];
                    if (indx == 0)
                       ;
                    else {
                        *pchOpcodeBuf++ = 'd';
                        if (indx == 1)
                            *pchOpcodeBuf++ = 'q';
                        }
                    }
                break;

            case STROP:
                //  compute size of operands in indx
                //  also if dword operands, change fifth
                //  opcode letter from 'w' to 'd'.

                if (opcode & 1) {
                    if (opsize_32) {
                        indx = 4;
                        OpcodeBuffer[4] = 'd';
                        }
                    else
                        indx = 2;
                    }
                else
                    indx = 1;

                if (*action & 1) {
                    }
                if (*action++ & 2) {
                    }
                break;

            case CHR:                   /* insert a character */
                *pchOperandBuf++ = *action++;
                break;

            case CREG:                  /* set debug, test or control reg */
                if ((opcode - SECTAB_OFFSET_2)&0x04) //remove bias from opcode
                    *pchOperandBuf++ = 't';
                else if ((opcode - SECTAB_OFFSET_2) & 0x01)
                    *pchOperandBuf++ = 'd';
                else
                    *pchOperandBuf++ = 'c';
                *pchOperandBuf++ = 'r';
                *pchOperandBuf++ = (char)('0' + decodeData.ttt);
                break;

            case SREG2:                 /* segment register */
                // Handle special case for fs/gs (OPC0F adds SECTAB_OFFSET_5
                // to these codes)
                if (opcode > 0x7e)
                    decodeData.ttt = BIT53((opcode-SECTAB_OFFSET_5));
                else
                decodeData.ttt = BIT53(opcode);    //  set value to fall through

            case SREG3:                 /* segment register */
                *pchOperandBuf++ = sregtab[decodeData.ttt];  // reg is part of modrm
                *pchOperandBuf++ = 's';
                break;

            case BRSTR:                 /* get index to register string */
                decodeData.ttt = *action++;        /*    from action table */
                goto BREGlabel;

            case BOREG:                 /* byte register (in opcode) */
                decodeData.ttt = BIT20(opcode);    /* register is part of opcode */
                goto BREGlabel;

            case ALSTR:
                decodeData.ttt = 0;                /* point to AL register */
BREGlabel:
            case BREG:                  /* general register */
                *pchOperandBuf++ = regtab[decodeData.ttt * 2];
                *pchOperandBuf++ = regtab[decodeData.ttt * 2 + 1];
                break;

            case WRSTR:                 /* get index to register string */
                decodeData.ttt = *action++;        /*    from action table */
                goto WREGlabel;

            case VOREG:                 /* register is part of opcode */
                decodeData.ttt = BIT20(opcode);
                goto VREGlabel;

            case AXSTR:
                decodeData.ttt = 0;                /* point to eAX register */
VREGlabel:
            case VREG:                  /* general register */
                if (opsize_32)          /* test for 32bit mode */
                    *pchOperandBuf++ = 'e';
WREGlabel:
            case WREG:                  /* register is word size */
                *pchOperandBuf++ = regtab[decodeData.ttt * 2 + 16];
                *pchOperandBuf++ = regtab[decodeData.ttt * 2 + 17];
                break;

            case MMWREG:
                *pchOperandBuf++ = 'm';
                *pchOperandBuf++ = 'm';
                *pchOperandBuf++ = decodeData.ttt + '0';
                break;

            case IST_ST:
                *(pchOperandBuf - 5) += (char)decodeData.rm;
                break;

            case ST_IST:
                ;
            case IST:
                ;
                *(pchOperandBuf - 2) += (char)decodeData.rm;
                break;

            case xBYTE:                 /* set instruction to byte only */
                decodeData.EAsize[0] = 1;
                break;

            case VAR:
                if (opsize_32)
                    goto DWORDlabel;

            case xWORD:
                decodeData.EAsize[0] = 2;
                break;

            case EDWORD:
                opsize_32 = 1;    //  for control reg move, use eRegs
            case xDWORD:
DWORDlabel:
                decodeData.EAsize[0] = 4;
                break;

            case MMQWORD:
                decodeData.fMmRegEa = TRUE;

            case QWORD:
                decodeData.EAsize[0] = 8;
                break;

            case TBYTE:
                decodeData.EAsize[0] = 10;
                break;

            case FARPTR:
                if (opsize_32) {
                    decodeData.EAsize[0] = 6;
                    }
                else {
                    decodeData.EAsize[0] = 4;
                    }
                break;

            case LMODRM:                //  output modRM data type
                if (decodeData.mod != 3)
                    ;
                else
                    decodeData.EAsize[0] = 0;

            case MODRM:                 /* output modrm string */
                if (segOvr)             /* in case of segment override */
                    0;
                break;

            case ADDRP:                 /* address pointer */
                decodeData.pMem += olen + 2;
                break;

            case REL8:                  /* relative address 8-bit */
                if (opcode == 0xe3 && mode_32) {
                    pchOpcodeBuf = OpcodeBuffer;
                    }
                tmp = (long)*(char *)(decodeData.pMem)++; /* get the 8-bit rel offset */
                goto DoRelDispl;

            case REL16:                 /* relative address 16-/32-bit */
                tmp = 0;
                if (mode_32)
                    memmove(&tmp,decodeData.pMem,sizeof(long));
                else
                    memmove(&tmp,decodeData.pMem,sizeof(short));
                decodeData.pMem += alen;           /* skip over offset */
DoRelDispl:
//                tmp += *pOffset + (decodeData.pMem - membuf); /* calculate address */
                                                   // address
                break;

            case UBYTE:                 //  unsigned byte for int/in/out
                decodeData.pMem++;
                break;

            case IB:                    /* operand is immediate byte */
                if ((opcode & ~1) == 0xd4) {  // postop for AAD/AAM is 0x0a
                    if (*(decodeData.pMem)++ != 0x0a) // test post-opcode byte
                        0;
                    break;
                    }
                olen = 1;               /* set operand length */
                goto DoImmed;

            case IW:                    /* operand is immediate word */
                olen = 2;               /* set operand length */

            case IV:                    /* operand is word or dword */
DoImmed:
                decodeData.pMem += olen;
                break;

            case OFFS:                  /* operand is offset */
                decodeData.EAsize[0] = (opcode & 1) ? olen : 1;

                if (segOvr)             /* in case of segment override */
                   0;

                decodeData.pMem += alen;
                break;

            case GROUP:                 /* operand is of group 1,2,4,6 or 8 */
                                        /* output opcode symbol */
				action++;
                break;

            case GROUPT:                /* operand is of group 3,5 or 7 */
                indx = *action;         /* get indx into group from action */
                goto doGroupT;

            case EGROUPT:               /* x87 ESC (D8-DF) group index */
                indx = BIT20(opcode) * 2; /* get group index from opcode */
                if (decodeData.mod == 3) {         /* some operand variations exists */
                                        /* for x87 and mod == 3 */
                    ++indx;             /* take the next group table entry */
                    if (indx == 3) {    /* for x87 ESC==D9 and mod==3 */
                        if (decodeData.ttt > 3) {  /* for those D9 instructions */
                            indx = 12 + decodeData.ttt; /* offset index to table by 12 */
                            decodeData.ttt = decodeData.rm;   /* set secondary index to rm */
                            }
                        }
                    else if (indx == 7) { /* for x87 ESC==DB and mod==3 */
                        if (decodeData.ttt == 4) {   /* if ttt==4 */
                            decodeData.ttt = decodeData.rm;     /* set secondary group table index */
                        } else if ((decodeData.ttt<4)||(decodeData.ttt>4 && decodeData.ttt<7)) {
                            // adjust for pentium pro opcodes
                            indx = 24;   /* offset index to table by 24*/
                        }
                    }
                }
doGroupT:
                /* handle group with different types of operands */
                action = actiontbl + groupt[indx][decodeData.ttt].opr;
                                                        /* get new action */
                break;
            //
            // The secondary opcode table has been compressed in the
            // original design. Hence while disassembling the 0F sequence,
            // opcode needs to be displaced by an appropriate amount depending
            // on the number of "filled" entries in the secondary table.
            // These displacements are used throughout the code.
            //

            case OPC0F:              /* secondary opcode table (opcode 0F) */
                opcode = *(decodeData.pMem)++;    /* get real opcode */
                decodeData.fMovX  = (BOOL)(opcode == 0xBF || opcode == 0xB7);
                if (opcode < 12) /* for the first 12 opcodes */
                    opcode += SECTAB_OFFSET_1; // point to begin of sec op tab
                else if (opcode > 0x1f && opcode < 0x27)
                    opcode += SECTAB_OFFSET_2; // adjust for undefined opcodes
                else if (opcode > 0x2f && opcode < 0x34)
                    opcode += SECTAB_OFFSET_3; // adjust for undefined opcodes
                else if (opcode > 0x3f && opcode < 0x50)
                    opcode += SECTAB_OFFSET_4; // adjust for undefined opcodes
                else if (opcode > 0x5f && opcode < 0xff)
                    opcode += SECTAB_OFFSET_5; // adjust for undefined opcodes
                else
                    opcode = SECTAB_OFFSET_UNDEF; // all non-existing opcodes
                goto getNxtByte1;

            case ADR_OVR:               /* address override */
                mode_32 = !G_mode_32;   /* override addressing mode */
                alen = (mode_32 + 1) << 1; /* toggle address length */
                goto getNxtByte;

            case OPR_OVR:               /* operand size override */
                opsize_32 = !G_mode_32; /* override operand size */
                olen = (opsize_32 + 1) << 1; /* toggle operand length */
                goto getNxtByte;

            case SEG_OVR:               /* handle segment override */
                segOvr = opcode;        /* save segment override opcode */
                pchOpcodeBuf = OpcodeBuffer;  // restart the opcode string
                goto getNxtByte;

            case REP:                   /* handle rep/lock prefixes */
                if (pchRepPrefixBuf != RepPrefixBuffer)
                    *pchRepPrefixBuf++ = ' ';
                pchOpcodeBuf = OpcodeBuffer;
getNxtByte:
                opcode = *(decodeData.pMem)++;        /* next byte is opcode */
getNxtByte1:
                action = actiontbl + distbl[opcode].opr;

            default:                    /* opcode has no operand */
                break;
            }
        switch (action2) {              /* secondary action */
            case MRM:                   /* generate modrm for later use */
                if (!mrm) {             /* ignore if it has been generated */
					DIdoModrm(&pchModrmBuf, segOvr, &decodeData);
                    mrm = TRUE;         /* remember its generation */
                    }
                break;

            case COM:                   /* insert a comma after operand */
                break;

            case END:                   /* end of instruction */
                end = TRUE;
                break;
            }
 } while (!end);                        /* loop til end of instruction */

  instlen = (decodeData.pMem) - membuf;

  return instlen;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\clevel.c ===
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ctype.h>
#include <stdio.h>
#include <windows.h>
#include "view.h"
#include "thread.h"
#include "dump.h"
#include "memory.h"
#include "clevel.h"

FIXUPRETURN g_fnFixupReturn[1];
DWORD g_dwCallArray[2];

BOOL
PushCaller(PVOID ptfInfo,
           PVOID pEsp)
{
    PTHREADFAULT ptFault = (PTHREADFAULT)ptfInfo;
    PCALLRETSTUB pCallStub = 0;
    PCALLERINFO pCallerTemp = 0;

    //
    // Allocate a unique return stub for this call
    //
    pCallStub = AllocateReturnStub(ptfInfo);
    if (0 == pCallStub) {
       return FALSE;
    }

    //
    // Allocate caller data for the restore
    //
    pCallerTemp = AllocMem(sizeof(CALLERINFO));
    if (0 == pCallerTemp) {
       return FALSE;
    }

    pCallerTemp->dwIdentifier = ptFault->dwCallMarker;
    pCallerTemp->dwCallLevel = ptFault->dwCallLevel;
    pCallerTemp->pReturn = (PVOID)(*(DWORD *)pEsp);
    pCallerTemp->pCallRetStub = pCallStub;
    pCallerTemp->pNextChain = 0;

    //
    // Increment the call count
    //
    ptFault->dwCallLevel++;

    //
    // Replace stack return value with the custom return stub
    //
    *(DWORD *)pEsp = (DWORD)pCallStub;

    //
    // Finally, chain up the return info to the rest of them
    //
    if (ptFault->pCallStackList) {
       pCallerTemp->pNextChain = ptFault->pCallStackList;
       ptFault->pCallStackList = pCallerTemp;
    }
    else {
       ptFault->pCallStackList = pCallerTemp;
    }

    return TRUE;
}

PCALLRETSTUB
AllocateReturnStub(PVOID ptfInfo)
{
    PCALLRETSTUB pRetStub = 0;
    PTHREADFAULT ptFault = (PTHREADFAULT)ptfInfo;

    pRetStub = AllocMem(sizeof(CALLRETSTUB));
    if (0 == pRetStub) {
       return 0;
    }

    //
    // Increment the return marker
    //
    ptFault->dwCallMarker++;

    //
    // Initialize the stub asm
    //
    pRetStub->PUSHDWORD[0] = 0x68;             //push xxxxxxxx (68 dword)
    *(DWORD *)(&(pRetStub->PUSHDWORD[1])) = ptFault->dwCallMarker;
    pRetStub->JMPDWORD[0] = 0xff;              //jmp dword ptr [xxxxxxxx] (ff 25 dword address)
    pRetStub->JMPDWORD[1] = 0x25;
    *(DWORD *)(&(pRetStub->JMPDWORD[2])) = (DWORD)&(g_dwCallArray[1]);

    return pRetStub;
}

PVOID
PopCaller(DWORD dwIdentifier)
{
    PTHREADFAULT pThreadFault = 0;
    PCALLERINFO pCallerTemp;
    PCALLERINFO pCallerPrev = 0;
    PVOID pReturn = 0;

    pThreadFault = GetProfilerThreadData();

    //
    // Find the entry in the caller list
    //
    pCallerTemp = (PCALLERINFO)pThreadFault->pCallStackList;
    while(pCallerTemp) {
        if (pCallerTemp->dwIdentifier == dwIdentifier) {
           break;
        }

        pCallerPrev = pCallerTemp;
        pCallerTemp = pCallerTemp->pNextChain;
    }

    //
    // Yank the entry from the list
    //
    if (0 == pCallerPrev) {
       pThreadFault->pCallStackList = pCallerTemp->pNextChain;
    }
    else {
       pCallerPrev->pNextChain = pCallerTemp->pNextChain;
    }

    //
    // Restore call level for the thread
    //
    pReturn = pCallerTemp->pReturn;
    pThreadFault->dwCallLevel = pCallerTemp->dwCallLevel;

    //
    // Cleanup the allocations
    //
    FreeMem(pCallerTemp->pCallRetStub);
    FreeMem(pCallerTemp);

    return pReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\86dis.h ===
/********************************** module *********************************/
/*                                                                         */
/*                                 disasmtb                                */
/*                           disassembler for CodeView                     */
/*                                                                         */
/***************************************************************************/
/*                                                                         */
/*    @ Purpose:                                                           */
/*                                                                         */
/*    @ Functions included:                                                */
/*                                                                         */
/*                                                                         */
/*    @ Author: Gerd Immeyer              @ Version:                       */
/*                                                                         */
/*    @ Creation Date: 10.19.89           @ Modification Date:             */
/*                                                                         */
/***************************************************************************/

#ifndef _86DIS_H_
#define _86DIS_H_

/* Strings: Operand mnemonics, Segment overrides, etc. for disasm          */

char dszAAA[]       = "aaa";
char dszAAD[]       = "aad";
char dszAAM[]       = "aam";
char dszAAS[]       = "aas";
char dszADC[]       = "adc";
char dszADD[]       = "add";
char dszADDRPRFX[]  = "";
char dszAND[]       = "and";
char dszARPL[]      = "arpl";
char dszBOUND[]     = "bound";
char dszBSF[]       = "bsf";
char dszBSR[]       = "bsr";
char dszBST[]       = "bst";
char dszBSWAP[]     = "bswap";
char dszBT[]        = "bt";
char dszBTC[]       = "btc";
char dszBTR[]       = "btr";
char dszBTS[]       = "bts";
char dszCALL[]      = "call";
char dszCBW[]       = "cbw";
char dszCDQ[]       = "cdq";
char dszCLC[]       = "clc";
char dszCLD[]       = "cld";
char dszCLI[]       = "cli";
char dszCLTS[]      = "clts";
char dszCMC[]       = "cmc";
char dszCMOVO[]     = "cmovo";
char dszCMOVNO[]    = "cmovno";
char dszCMOVB[]     = "cmovb";
char dszCMOVNB[]    = "cmovnb";
char dszCMOVE[]     = "cmove";
char dszCMOVNE[]    = "cmovne";
char dszCMOVBE[]    = "cmovbe";
char dszCMOVA[]     = "cmova";
char dszCMOVS[]     = "cmovs";
char dszCMOVNS[]    = "cmovns";
char dszCMOVP[]     = "cmovp";
char dszCMOVNP[]    = "cmovnp";
char dszCMOVL[]     = "cmovl";
char dszCMOVGE[]    = "cmovge";
char dszCMOVLE[]    = "cmovle";
char dszCMOVNLE[]   = "cmovnle";
char dszCMP[]       = "cmp";
char dszCMPS[]      = "cmps";
char dszCMPSB[]     = "cmpsb";
char dszCMPSD[]     = "cmpsd";
char dszCMPSW[]     = "cmpsw";
char dszCMPXCHG[]   = "cmpxchg";
char dszCMPXCHG8B[] = "cmpxchg8b";
char dszCPUID[]     = "cpuid";
char dszCS_[]       = "cs:";
char dszCWD[]       = "cwd";
char dszCWDE[]      = "cwde";
char dszDAA[]       = "daa";
char dszDAS[]       = "das";
char dszDEC[]       = "dec";
char dszDIV[]       = "div";
char dszDS_[]       = "ds:";
char dszEMMS[]      = "emms";
char dszENTER[]     = "enter";
char dszES_[]       = "es:";
char dszF2XM1[]     = "f2xm1";
char dszFABS[]      = "fabs";
char dszFADD[]      = "fadd";
char dszFADDP[]     = "faddp";
char dszFBLD[]      = "fbld";
char dszFBSTP[]     = "fbstp";
char dszFCHS[]      = "fchs";
char dszFCLEX[]     = "fclex";
char dszFCMOVB[]    = "fcmovb";
char dszFCMOVE[]    = "fcmove";
char dszFCMOVBE[]   = "fcmovbe";
char dszFCMOVU[]    = "fcmovu";
char dszFCMOVNB[]   = "fcmovnb";
char dszFCMOVNE[]   = "fcmovne";
char dszFCMOVNBE[]  = "fcmovnbe";
char dszFCMOVNU[]   = "fcmovnu";
char dszFCOM[]      = "fcom";
char dszFCOMI[]     = "fcomi";
char dszFCOMIP[]    = "fcomip";
char dszFCOMP[]     = "fcomp";
char dszFCOMPP[]    = "fcompp";
char dszFCOS[]      = "fcos";
char dszFDECSTP[]   = "fdecstp";
char dszFDISI[]     = "fdisi";
char dszFDIV[]      = "fdiv";
char dszFDIVP[]     = "fdivp";
char dszFDIVR[]     = "fdivr";
char dszFDIVRP[]    = "fdivrp";
char dszFENI[]      = "feni";
char dszFFREE[]     = "ffree";
char dszFIADD[]     = "fiadd";
char dszFICOM[]     = "ficom";
char dszFICOMP[]    = "ficomp";
char dszFIDIV[]     = "fidiv";
char dszFIDIVR[]    = "fidivr";
char dszFILD[]      = "fild";
char dszFIMUL[]     = "fimul";
char dszFINCSTP[]   = "fincstp";
char dszFINIT[]     = "finit";
char dszFIST[]      = "fist";
char dszFISTP[]     = "fistp";
char dszFISUB[]     = "fisub";
char dszFISUBR[]    = "fisubr";
char dszFLD[]       = "fld";
char dszFLD1[]      = "fld1";
char dszFLDCW[]     = "fldcw";
char dszFLDENV[]    = "fldenv";
char dszFLDL2E[]    = "fldl2e";
char dszFLDL2T[]    = "fldl2t";
char dszFLDLG2[]    = "fldlg2";
char dszFLDLN2[]    = "fldln2";
char dszFLDPI[]     = "fldpi";
char dszFLDZ[]      = "fldz";
char dszFMUL[]      = "fmul";
char dszFMULP[]     = "fmulp";
char dszFNCLEX[]    = "fnclex";
char dszFNDISI[]    = "fndisi";
char dszFNENI[]     = "fneni";
char dszFNINIT[]    = "fninit";
char dszFNOP[]      = "fnop";
char dszFNSAVE[]    = "fnsave";
char dszFNSTCW[]    = "fnstcw";
char dszFNSTENV[]   = "fnstenv";
char dszFNSTSW[]    = "fnstsw";
char dszFNSTSWAX[]  = "fnstswax";
char dszFPATAN[]    = "fpatan";
char dszFPREM[]     = "fprem";
char dszFPREM1[]    = "fprem1";
char dszFPTAN[]     = "fptan";
char dszFRNDINT[]   = "frndint";
char dszFRSTOR[]    = "frstor";
char dszFSAVE[]     = "fsave";
char dszFSCALE[]    = "fscale";
char dszFSETPM[]    = "fsetpm";
char dszFSIN[]      = "fsin";
char dszFSINCOS[]   = "fsincos";
char dszFSQRT[]     = "fsqrt";
char dszFST[]       = "fst";
char dszFSTCW[]     = "fstcw";
char dszFSTENV[]    = "fstenv";
char dszFSTP[]      = "fstp";
char dszFSTSW[]     = "fstsw";
char dszFSTSWAX[]   = "fstswax";
char dszFSUB[]      = "fsub";
char dszFSUBP[]     = "fsubp";
char dszFSUBR[]     = "fsubr";
char dszFSUBRP[]    = "fsubrp";
char dszFS_[]       = "fs:";
char dszFTST[]      = "ftst";
char dszFUCOM[]     = "fucom";
char dszFUCOMI[]    = "fucomi";
char dszFUCOMIP[]   = "fucomip";
char dszFUCOMP[]    = "fucomp";
char dszFUCOMPP[]   = "fucompp";
char dszFWAIT[]     = "fwait";
char dszFXAM[]      = "fxam";
char dszFXCH[]      = "fxch";
char dszFXTRACT[]   = "fxtract";
char dszFYL2X[]     = "fyl2x";
char dszFYL2XP1[]   = "fyl2xp1";
char dszGS_[]       = "gs:";
char dszHLT[]       = "hlt";
char dszIBTS[]      = "ibts";
char dszIDIV[]      = "idiv";
char dszIMUL[]      = "imul";
char dszIN[]        = "in";
char dszINC[]       = "inc";
char dszINS[]       = "ins";
char dszINSB[]      = "insb";
char dszINSD[]      = "insd";
char dszINSW[]      = "insw";
char dszINT[]       = "int";
char dszINTO[]      = "into";
char dszINVD[]      = "invd";
char dszINVLPG[]    = "invlpg";
char dszIRET[]      = "iret";
char dszIRETD[]     = "iretd";
char dszJA[]        = "ja";
char dszJAE[]       = "jae";
char dszJB[]        = "jb";
char dszJBE[]       = "jbe";
char dszJC[]        = "jc";
char dszJCXZ[]      = "jcxz";
char dszJE[]        = "je";
char dszJECXZ[]     = "jecxz";
char dszJG[]        = "jg";
char dszJGE[]       = "jge";
char dszJL[]        = "jl";
char dszJLE[]       = "jle";
char dszJMP[]       = "jmp";
char dszJNA[]       = "jna";
char dszJNAE[]      = "jnae";
char dszJNB[]       = "jnb";
char dszJNBE[]      = "jnbe";
char dszJNC[]       = "jnc";
char dszJNE[]       = "jne";
char dszJNG[]       = "jng";
char dszJNGE[]      = "jnge";
char dszJNL[]       = "jnl";
char dszJNLE[]      = "jnle";
char dszJNO[]       = "jno";
char dszJNP[]       = "jnp";
char dszJNS[]       = "jns";
char dszJNZ[]       = "jnz";
char dszJO[]        = "jo";
char dszJP[]        = "jp";
char dszJPE[]       = "jpe";
char dszJPO[]       = "jpo";
char dszJS[]        = "js";
char dszJZ[]        = "jz";
char dszLAHF[]      = "lahf";
char dszLAR[]       = "lar";
char dszLDS[]       = "lds";
char dszLEA[]       = "lea";
char dszLEAVE[]     = "leave";
char dszLES[]       = "les";
char dszLFS[]       = "lfs";
char dszLGDT[]      = "lgdt";
char dszLGS[]       = "lgs";
char dszLIDT[]      = "lidt";
char dszLLDT[]      = "lldt";
char dszLMSW[]      = "lmsw";
char dszLOADALL[]   = "loadall";
char dszLOCK[]      = "lock";
char dszLODS[]      = "lods";
char dszLODSB[]     = "lodsb";
char dszLODSD[]     = "lodsd";
char dszLODSW[]     = "lodsw";
char dszLOOP[]      = "loop";
char dszLOOPE[]     = "loope";
char dszLOOPNE[]    = "loopne";
char dszLOOPNZ[]    = "loopnz";
char dszLOOPZ[]     = "loopz";
char dszLSL[]       = "lsl";
char dszLSS[]       = "lss";
char dszLTR[]       = "ltr";
char dszMOV[]       = "mov";
char dszMOVD[]      = "movd";
char dszMOVQ[]      = "movq";
char dszMOVS[]      = "movs";
char dszMOVSB[]     = "movsb";
char dszMOVSD[]     = "movsd";
char dszMOVSW[]     = "movsw";
char dszMOVSX[]     = "movsx";
char dszMOVZX[]     = "movzx";
char dszMUL[]       = "mul";
char dszNEG[]       = "neg";
char dszNOP[]       = "nop";
char dszNOT[]       = "not";
char dszOPPRFX[]    = "";
char dszOR[]        = "or";
char dszOUT[]       = "out";
char dszOUTS[]      = "outs";
char dszOUTSB[]     = "outsb";
char dszOUTSD[]     = "outsd";
char dszOUTSW[]     = "outsw";
char dszPACKSSDW[]  = "packssdw";
char dszPACKSSWB[]  = "packsswb";
char dszPACKUSWB[]  = "packuswb";
char dszPADDB[]     = "paddb";
char dszPADDD[]     = "paddd";
char dszPADDSB[]    = "paddsb";
char dszPADDSW[]    = "paddsw";
char dszPADDUSB[]   = "paddusb";
char dszPADDUSW[]   = "paddusw";
char dszPADDW[]     = "paddw";
char dszPAND[]      = "pand";
char dszPANDN[]     = "pandn";
char dszPCMPEQB[]   = "pcmpeqb";
char dszPCMPEQD[]   = "pcmpeqd";
char dszPCMPEQW[]   = "pcmpeqw";
char dszPCMPGTB[]   = "pcmpgtb";
char dszPCMPGTD[]   = "pcmpgtd";
char dszPCMPGTW[]   = "pcmpgtw";
char dszPMADDWD[]   = "pmaddwd";
char dszPMULHW[]    = "pmulhw";
char dszPMULLW[]    = "pmullw";
char dszPOP[]       = "pop";
char dszPOPA[]      = "popa";
char dszPOPAD[]     = "popad";
char dszPOPF[]      = "popf";
char dszPOPFD[]     = "popfd";
char dszPOR[]       = "por";
char dszPSLLD[]     = "pslld";
char dszPSLLW[]     = "psllw";
char dszPSLLQ[]     = "psllq";
char dszPSRAD[]     = "psrad";
char dszPSRAW[]     = "psraw";
char dszPSRLD[]     = "psrld";
char dszPSRLQ[]     = "psrlq";
char dszPSRLW[]     = "psrlw";
char dszPSUBB[]     = "psubb";
char dszPSUBD[]     = "psubd";
char dszPSUBSB[]    = "psubsb";
char dszPSUBSW[]    = "psubsw";
char dszPSUBUSB[]   = "psubusb";
char dszPSUBUSW[]   = "psubusw";
char dszPSUBW[]     = "psubw";
char dszPUNPCKLBW[] = "punpcklbw";
char dszPUNPCKLDQ[] = "punpckldq";
char dszPUNPCKLWD[] = "punpcklwd";
char dszPUNPCKHBW[] = "punpckhbw";
char dszPUNPCKHDQ[] = "punpckhdq";
char dszPUNPCKHWD[] = "punpckhwd";
char dszPUSH[]      = "push";
char dszPUSHA[]     = "pusha";
char dszPUSHAD[]    = "pushad";
char dszPUSHF[]     = "pushf";
char dszPUSHFD[]    = "pushfd";
char dszPXOR[]      = "pxor";
char dszRCL[]       = "rcl";
char dszRCR[]       = "rcr";
char dszRDTSC[]     = "rdtsc";
char dszRDMSR[]     = "rdmsr";
char dszRDPMC[]     = "rdpmc";
char dszREP[]       = "rep ";
char dszREPE[]      = "repe";
char dszREPNE[]     = "repne ";
char dszREPNZ[]     = "repnz";
char dszREPZ[]      = "repz";
char dszRET[]       = "ret";
char dszRETF[]      = "retf";
char dszRETN[]      = "retn";
char dszROL[]       = "rol";
char dszROR[]       = "ror";
char dszRSM[]       = "rsm";
char dszSAHF[]      = "sahf";
char dszSAL[]       = "sal";
char dszSAR[]       = "sar";
char dszSBB[]       = "sbb";
char dszSCAS[]      = "scas";
char dszSCASB[]     = "scasb";
char dszSCASD[]     = "scasd";
char dszSCASW[]     = "scasw";
char dszSETA[]      = "seta";
char dszSETAE[]     = "setae";
char dszSETB[]      = "setb";
char dszSETBE[]     = "setbe";
char dszSETC[]      = "setc";
char dszSETE[]      = "sete";
char dszSETG[]      = "setg";
char dszSETGE[]     = "setge";
char dszSETL[]      = "setl";
char dszSETLE[]     = "setle";
char dszSETNA[]     = "setna";
char dszSETNAE[]    = "setnae";
char dszSETNB[]     = "setnb";
char dszSETNBE[]    = "setnbe";
char dszSETNC[]     = "setnc";
char dszSETNE[]     = "setne";
char dszSETNG[]     = "setng";
char dszSETNGE[]    = "setnge";
char dszSETNL[]     = "setnl";
char dszSETNLE[]    = "setnle";
char dszSETNO[]     = "setno";
char dszSETNP[]     = "setnp";
char dszSETNS[]     = "setns";
char dszSETNZ[]     = "setnz";
char dszSETO[]      = "seto";
char dszSETP[]      = "setp";
char dszSETPE[]     = "setpe";
char dszSETPO[]     = "setpo";
char dszSETS[]      = "sets";
char dszSETZ[]      = "setz";
char dszSGDT[]      = "sgdt";
char dszSHL[]       = "shl";
char dszSHLD[]      = "shld";
char dszSHR[]       = "shr";
char dszSHRD[]      = "shrd";
char dszSIDT[]      = "sidt";
char dszSLDT[]      = "sldt";
char dszSMSW[]      = "smsw";
char dszSS_[]       = "ss:";
char dszSTC[]       = "stc";
char dszSTD[]       = "std";
char dszSTI[]       = "sti";
char dszSTOS[]      = "stos";
char dszSTOSB[]     = "stosb";
char dszSTOSD[]     = "stosd";
char dszSTOSW[]     = "stosw";
char dszSTR[]       = "str";
char dszSUB[]       = "sub";
char dszTEST[]      = "test";
char dszUD2[]       = "ud2";
char dszVERR[]      = "verr";
char dszVERW[]      = "verw";
char dszWAIT[]      = "wait";
char dszWBINVD[]    = "wbinvd";
char dszWRMSR[]     = "wrmsr";
char dszXADD[]      = "xadd";
char dszXBTS[]      = "xbts";
char dszXCHG[]      = "xchg";
char dszXLAT[]      = "xlat";
char dszXOR[]       = "xor";
char dszRESERVED[]  = "???";
char dszMULTI[]     = "";
char dszDB[]        = "db";

#define MRM        0x40
#define COM        0x80
#define END        0xc0

/* Enumeration of valid actions that can be included in the action table */

enum oprtyp { ADDRP,  ADR_OVR, ALSTR,   ALT,     AXSTR,  BOREG,
              BREG,   BRSTR,   xBYTE,   CHR,     CREG,   xDWORD,
              EDWORD, EGROUPT, FARPTR,  GROUP,   GROUPT, IB,
              IST,    IST_ST,  IV,      IW,      LMODRM, MODRM,
              NOP,    OFFS,    OPC0F,   OPR_OVR, QWORD,  REL16,
              REL8,   REP,     SEG_OVR, SREG2,   SREG3,  ST_IST,
              STROP,  TBYTE,   UBYTE,   VAR,     VOREG,  VREG,
              xWORD,  WREG,    WRSTR,   MMWREG,  MMQWORD
            };

/* Enumeration of indices into the action table for instruction classes */

#define O_DoDB          0
#define O_NoOperands    0
#define O_NoOpAlt5      O_NoOperands+1
#define O_NoOpAlt4      O_NoOpAlt5+2
#define O_NoOpAlt3      O_NoOpAlt4+2
#define O_NoOpAlt1      O_NoOpAlt3+2
#define O_NoOpAlt0      O_NoOpAlt1+2
#define O_NoOpStrSI     O_NoOpAlt0+2
#define O_NoOpStrDI     O_NoOpStrSI+2
#define O_NoOpStrSIDI   O_NoOpStrDI+2
#define O_bModrm_Reg    O_NoOpStrSIDI+2
#define O_vModrm_Reg    O_bModrm_Reg+3
#define O_Modrm_Reg     O_vModrm_Reg+3
#define O_bReg_Modrm    O_Modrm_Reg+3
#define O_fReg_Modrm    O_bReg_Modrm+3
#define O_Reg_Modrm     O_fReg_Modrm+3
#define O_AL_Ib         O_Reg_Modrm+3
#define O_AX_Iv         O_AL_Ib+2
#define O_sReg2         O_AX_Iv+2
#define O_oReg          O_sReg2+1
#define O_DoBound       O_oReg+1
#define O_Iv            O_DoBound+3
#define O_wModrm_Reg    O_Iv+1
#define O_Ib            O_wModrm_Reg+3
#define O_Imulb         O_Ib+1
#define O_Imul          O_Imulb+4
#define O_Rel8          O_Imul+4
#define O_bModrm_Ib     O_Rel8+1
#define O_Modrm_Ib      O_bModrm_Ib+3
#define O_Modrm_Iv      O_Modrm_Ib+3
#define O_Modrm_sReg3   O_Modrm_Iv+3
#define O_sReg3_Modrm   O_Modrm_sReg3+3
#define O_Modrm         O_sReg3_Modrm+3
#define O_FarPtr        O_Modrm+2
#define O_AL_Offs       O_FarPtr+1
#define O_Offs_AL       O_AL_Offs+2
#define O_AX_Offs       O_Offs_AL+2
#define O_Offs_AX       O_AX_Offs+2
#define O_oReg_Ib       O_Offs_AX+2
#define O_oReg_Iv       O_oReg_Ib+2
#define O_Iw            O_oReg_Iv+2
#define O_Enter         O_Iw+1
#define O_Ubyte_AL      O_Enter+2
#define O_Ubyte_AX      O_Ubyte_AL+2
#define O_AL_Ubyte      O_Ubyte_AX+2
#define O_AX_Ubyte      O_AL_Ubyte+2
#define O_DoInAL        O_AX_Ubyte+2
#define O_DoInAX        O_DoInAL+3
#define O_DoOutAL       O_DoInAX+3
#define O_DoOutAX       O_DoOutAL+3
#define O_Rel16         O_DoOutAX+3
#define O_ADR_OVERRIDE  O_Rel16+1
#define O_OPR_OVERRIDE  O_ADR_OVERRIDE+1
#define O_SEG_OVERRIDE  O_OPR_OVERRIDE+1
#define O_DoInt3        O_SEG_OVERRIDE+1

#if (O_DoInt3 != 115)
#error "operand table has been modified!"
#endif
/* #define O_DoInt      O_DoInt3+2 */

#define O_DoInt         117
#define O_OPC0F         O_DoInt+1
#define O_GROUP11       O_OPC0F+1
#define O_GROUP13       O_GROUP11+5
#define O_GROUP12       O_GROUP13+5
#define O_GROUP21       O_GROUP12+5
#define O_GROUP22       O_GROUP21+5
#define O_GROUP23       O_GROUP22+5
#define O_GROUP24       O_GROUP23+6
#define O_GROUP25       O_GROUP24+6
#define O_GROUP26       O_GROUP25+6
#define O_GROUP4        O_GROUP26+6
#define O_GROUP6        O_GROUP4+4
#define O_GROUP8        O_GROUP6+4
#define O_GROUP31       O_GROUP8+5
#define O_GROUP32       O_GROUP31+3
#define O_GROUP5        O_GROUP32+3
#define O_GROUP7        O_GROUP5+3
#define O_x87_ESC       O_GROUP7+3
#define O_bModrm        O_x87_ESC+2
#define O_wModrm        O_bModrm+2
#define O_dModrm        O_wModrm+2
#define O_fModrm        O_dModrm+2
#define O_vModrm        O_fModrm+2
#define O_vModrm_Iv     O_vModrm+2
#define O_Reg_bModrm    O_vModrm_Iv+3
#define O_Reg_wModrm    O_Reg_bModrm+3
#define O_Modrm_Reg_Ib  O_Reg_wModrm+3
#define O_Modrm_Reg_CL  O_Modrm_Reg_Ib+4
#define O_ST_iST        O_Modrm_Reg_CL+5
#define O_iST           O_ST_iST+2
#define O_iST_ST        O_iST+2
#define O_qModrm        O_iST_ST+2
#define O_tModrm        O_qModrm+2
#define O_DoRep         O_tModrm+2
#define O_Modrm_CReg    O_DoRep+1
#define O_CReg_Modrm    O_Modrm_CReg+3
#define O_AX_oReg       O_CReg_Modrm+3
#define O_MmReg_qModrm  O_AX_oReg+2
#define O_qModrm_MmReg  O_MmReg_qModrm+3
#define O_MmReg_dModrm  O_qModrm_MmReg+3
#define O_dModrm_MmReg  O_MmReg_dModrm+3
#define O_qModrm_Ib     O_dModrm_MmReg+3
#define O_PSHimw        O_qModrm_Ib+3
#define O_PSHimd        O_PSHimw+5
#define O_PSHimq        O_PSHimd+5
#define O_length        O_PSHimq+5

typedef unsigned short ActionIndex;

#if( O_length > 65535 )
#error "operand table too large!"
#endif


/* The action table: range of lists of actions to be taken for each possible */
/*   instruction class.                                                      */

static unsigned char actiontbl[] = {
/* NoOperands  */ NOP+END,
/* NoOpAlt5    */ ALT+END,   5,
/* NoOpAlt4    */ ALT+END,   4,
/* NoOpAlt3    */ ALT+END,   3,
/* NoOpAlt1    */ ALT+END,   1,
/* NoOpAlt0    */ ALT+END,   0,
/* NoOpStrSI   */ STROP+END, 1,
/* NoOpStrDI   */ STROP+END, 2,
/* NoOpStrSIDI */ STROP+END, 3,
/* bModrm_Reg  */ xBYTE+MRM, MODRM+COM,  BREG+END,
/* vModrm_Reg  */ VAR+MRM,   LMODRM+COM, BREG+END,
/* Modrm_Reg   */ VAR+MRM,   MODRM+COM,  VREG+END,
/* bReg_Modrm  */ xBYTE+MRM, BREG+COM,   MODRM+END,
/* fReg_Modrm  */ FARPTR+MRM,VREG+COM,   MODRM+END,
/* Reg_Modrm   */ VAR+MRM,   VREG+COM,   MODRM+END,
/* AL_Ib       */ ALSTR+COM, IB+END,
/* AX_Iv       */ AXSTR+COM, IV+END,
/* sReg2       */ SREG2+END,
/* oReg        */ VOREG+END,
/* DoBound     */ VAR+MRM,   VREG+COM,   MODRM+END,
/* Iv          */ IV+END,
/* wModrm_Reg  */ xWORD+MRM, LMODRM+COM, WREG+END,
/* Ib          */ IB+END,
/* Imulb       */ VAR+MRM,   VREG+COM,   MODRM+COM, IB+END,
/* Imul        */ VAR+MRM,   VREG+COM,   MODRM+COM, IV+END,
/* REL8        */ REL8+END,
/* bModrm_Ib   */ xBYTE+MRM, LMODRM+COM, IB+END,
/* Modrm_Ib    */ VAR+MRM,   LMODRM+COM, IB+END,
/* Modrm_Iv    */ VAR+MRM,   LMODRM+COM, IV+END,
/* Modrm_sReg3 */ xWORD+MRM, MODRM+COM,  SREG3+END,
/* sReg3_Modrm */ xWORD+MRM, SREG3+COM,  MODRM+END,
/* Modrm       */ VAR+MRM,   MODRM+END,
/* FarPtr      */ ADDRP+END,
/* AL_Offs     */ ALSTR+COM, OFFS+END,
/* Offs_AL     */ OFFS+COM,  ALSTR+END,
/* AX_Offs     */ AXSTR+COM, OFFS+END,
/* Offs_AX     */ OFFS+COM,  AXSTR+END,
/* oReg_Ib     */ BOREG+COM, IB+END,
/* oReg_Iv     */ VOREG+COM, IV+END,
/* Iw          */ IW+END,
/* enter       */ IW+COM,    IB+END,
/* Ubyte_AL    */ UBYTE+COM, ALSTR+END,
/* Ubyte_AX    */ UBYTE+COM, AXSTR+END,
/* AL_Ubyte    */ ALSTR+COM, UBYTE+END,
/* AX_Ubyte    */ AXSTR+COM, UBYTE+END,
/* DoInAL      */ ALSTR+COM, WRSTR+END,  2,
/* DoInAX      */ AXSTR+COM, WRSTR+END,  2,
/* DoOutAL     */ WRSTR+COM, 2,          ALSTR+END,
/* DoOutAX     */ WRSTR+COM, 2,          AXSTR+END,
/* REL16       */ REL16+END,
/* ADR_OVERRIDE*/ ADR_OVR,
/* OPR_OVERRIDE*/ OPR_OVR,
/* SEG_OVERRIDE*/ SEG_OVR,
/* DoInt3      */ CHR+END,   '3',
/* DoInt       */ UBYTE+END,
/* Opcode0F    */ OPC0F,
/* group1_1    */ xBYTE+MRM, GROUP,      0,         LMODRM+COM, IB+END,
/* group1_3    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IB+END,
/* group1_2    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IV+END,
/* group2_1    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, IB+END,
/* group2_2    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, IB+END,
/* group2_3    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_4    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_5    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group2_6    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group4      */ xBYTE+MRM, GROUP,      2,         LMODRM+END,
/* group6      */ xWORD+MRM, GROUP,      3,         LMODRM+END,
/* group8      */ xWORD+MRM, GROUP,      4,         LMODRM+COM, IB+END,
/* group3_1    */ xBYTE+MRM, GROUPT,     20,
/* group3_2    */ VAR+MRM,   GROUPT,     21,
/* group5      */ VAR+MRM,   GROUPT,     22,
/* group7      */ NOP+MRM,   GROUPT,     23,
/* x87_ESC     */ NOP+MRM,   EGROUPT,
/* bModrm      */ xBYTE+MRM, LMODRM+END,
/* wModrm      */ xWORD+MRM, LMODRM+END,
/* dModrm      */ xDWORD+MRM,LMODRM+END,
/* fModrm      */ FARPTR+MRM,LMODRM+END,
/* vModrm      */ VAR+MRM,   LMODRM+END,
/* vModrm_Iv   */ VAR+MRM,   LMODRM+COM, IV+END,
/* reg_bModrm  */ xBYTE+MRM, VREG+COM,   LMODRM+END,
/* reg_wModrm  */ xWORD+MRM, VREG+COM,   LMODRM+END,
/* Modrm_Reg_Ib*/ VAR+MRM,   MODRM+COM,  VREG+COM,   IB+END,
/* Modrm_Reg_CL*/ VAR+MRM,   MODRM+COM,  VREG+COM,   BRSTR+END, 1,
/* ST_iST      */ NOP+MRM,   ST_IST+END,
/* iST         */ NOP+MRM,   IST+END,
/* iST_ST      */ NOP+MRM,   IST_ST+END,
/* qModrm      */ QWORD+MRM, LMODRM+END,
/* tModrm      */ TBYTE+MRM, LMODRM+END,
/* REP         */ REP,
/* Modrm_CReg  */ EDWORD+MRM,MODRM+COM,  CREG+END,
/* CReg_Modrm  */ EDWORD+MRM,CREG+COM,   MODRM+END,
/* AX_oReg     */ AXSTR+COM, VOREG+END,
/* MmReg_qModrm*/ MMQWORD+MRM, MMWREG+COM, LMODRM+END,
/* qModrm_MmReg*/ MMQWORD+MRM, MODRM+COM,  MMWREG+END,
/* MmReg_dModrm*/ xDWORD+MRM, MMWREG+COM,LMODRM+END,
/* dModrm_MmReg*/ xDWORD+MRM, MODRM+COM, MMWREG+END,
/* qModrm_Ib   */ MMQWORD+MRM, MODRM+COM,IB+END,
/* PSHimw      */ MMQWORD+MRM, GROUP,    5,          LMODRM+COM, IB+END,
/* PSHimd      */ MMQWORD+MRM, GROUP,    6,          LMODRM+COM, IB+END,
/* PSHimq      */ MMQWORD+MRM, GROUP,    7,          LMODRM+COM, IB+END,
                  };

#if defined(_M_IX86)
#define BUILDING_ON_X86 1
#else
#define BUILDING_ON_X86 0
#endif

#if BUILDING_ON_X86 == 1
#pragma pack(1)
#endif

typedef struct Tdistbl{
    char *instruct;
    ActionIndex opr;
    } Tdistbl;

#if BUILDING_ON_X86 == 1
#pragma pack()
#endif

//
// Secondary opcode table is compressed - only "filled" locations are
// allocated space in distbl. Offsets for indexing into the secondary
// opcode table are calculcated as follows and defined below.
//
//  Pack#  Opcodes in Pack  #Ops before   Offset(add to opcode)
//     1     0h -  Bh            0            256 (# of primary opcodes)
//     2    20h - 26h           12        256-32+12 = 236
//     3    30h - 33h           19        256-48+19 = 227
//     4    40h - 4fh           23        256-64+23 = 215
//     5    60h - feh           39        256-96+39 = 199
//

#define SECTAB_OFFSET_1 256
#define SECTAB_OFFSET_2 236
#define SECTAB_OFFSET_3 227
#define SECTAB_OFFSET_4 215
#define SECTAB_OFFSET_5 199
#define SECTAB_OFFSET_UNDEF 260

/* List of ordered pairs for each instruction:                           */
/*    (pointer to string literal mnemonic,                               */
/*     instruction class index for action table)                         */

static Tdistbl distbl[] = {
    dszADD,   O_bModrm_Reg,             /* 00 ADD mem/reg, reg (byte)    */
    dszADD,   O_Modrm_Reg,              /* 01 ADD mem/reg, reg (word)    */
    dszADD,   O_bReg_Modrm,             /* 02 ADD reg, mem/reg (byte)    */
    dszADD,   O_Reg_Modrm,              /* 03 ADD reg, mem/reg (word)    */
    dszADD,   O_AL_Ib,                  /* 04 ADD AL, I                  */
    dszADD,   O_AX_Iv,                  /* 05 ADD AX, I                  */
    dszPUSH,  O_sReg2,                  /* 06 PUSH ES                    */
    dszPOP,   O_sReg2,                  /* 07 POP ES                     */
    dszOR,    O_bModrm_Reg,             /* 08 OR mem/reg, reg (byte)     */
    dszOR,    O_Modrm_Reg,              /* 09 OR mem/reg, reg (word)     */
    dszOR,    O_bReg_Modrm,             /* 0A OR reg, mem/reg (byte)     */
    dszOR,    O_Reg_Modrm,              /* 0B OR reg, mem/reg (word)     */
    dszOR,    O_AL_Ib,                  /* 0C OR AL, I                   */
    dszOR,    O_AX_Iv,                  /* 0D OR AX, I                   */
    dszPUSH,  O_sReg2,                  /* 0E PUSH CS                    */
    dszMULTI, O_OPC0F,                  /* 0F CLTS & protection ctl(286) */
    dszADC,   O_bModrm_Reg,             /* 10 ADC mem/reg, reg (byte)    */
    dszADC,   O_Modrm_Reg,              /* 11 ADC mem/reg, reg (word)    */
    dszADC,   O_bReg_Modrm,             /* 12 ADC reg, mem/reg (byte)    */
    dszADC,   O_Reg_Modrm,              /* 13 ADC reg, mem/reg (word)    */
    dszADC,   O_AL_Ib,                  /* 14 ADC AL, I                  */
    dszADC,   O_AX_Iv,                  /* 15 ADC AX, I                  */
    dszPUSH,  O_sReg2,                  /* 16 PUSH SS                    */
    dszPOP,   O_sReg2,                  /* 17 POP SS                     */
    dszSBB,   O_bModrm_Reg,             /* 18 SBB mem/reg, reg (byte)    */
    dszSBB,   O_Modrm_Reg,              /* 19 SBB mem/reg, reg (word)    */
    dszSBB,   O_bReg_Modrm,             /* 1A SBB reg, mem/reg (byte)    */
    dszSBB,   O_Reg_Modrm,              /* 1B SBB reg, mem/reg (word)    */
    dszSBB,   O_AL_Ib,                  /* 1C SBB AL, I                  */
    dszSBB,   O_AX_Iv,                  /* 1D SBB AX, I                  */
    dszPUSH,  O_sReg2,                  /* 1E PUSH DS                    */
    dszPOP,   O_sReg2,                  /* 1F POP DS                     */
    dszAND,   O_bModrm_Reg,             /* 20 AND mem/reg, reg (byte)    */
    dszAND,   O_Modrm_Reg,              /* 21 AND mem/reg, reg (word)    */
    dszAND,   O_bReg_Modrm,             /* 22 AND reg, mem/reg (byte)    */
    dszAND,   O_Reg_Modrm,              /* 23 AND reg, mem/reg (word)    */
    dszAND,   O_AL_Ib,                  /* 24 AND AL, I                  */
    dszAND,   O_AX_Iv,                  /* 25 AND AX, I                  */
    dszES_,   O_SEG_OVERRIDE,           /* 26 SEG ES:                    */
    dszDAA,   O_NoOperands,             /* 27 DAA                        */
    dszSUB,   O_bModrm_Reg,             /* 28 SUB mem/reg, reg (byte)    */
    dszSUB,   O_Modrm_Reg,              /* 29 SUB mem/reg, reg (word)    */
    dszSUB,   O_bReg_Modrm,             /* 2A SUB reg, mem/reg (byte)    */
    dszSUB,   O_Reg_Modrm,              /* 2B SUB reg, mem/reg (word)    */
    dszSUB,   O_AL_Ib,                  /* 2C SUB AL, I                  */
    dszSUB,   O_AX_Iv,                  /* 2D SUB AX, I                  */
    dszCS_,   O_SEG_OVERRIDE,           /* 2E SEG CS:                    */
    dszDAS,   O_NoOperands,             /* 2F DAS                        */
    dszXOR,   O_bModrm_Reg,             /* 30 XOR mem/reg, reg (byte)    */
    dszXOR,   O_Modrm_Reg,              /* 31 XOR mem/reg, reg (word)    */
    dszXOR,   O_bReg_Modrm,             /* 32 XOR reg, mem/reg (byte)    */
    dszXOR,   O_Reg_Modrm,              /* 33 XOR reg, mem/reg (word)    */
    dszXOR,   O_AL_Ib,                  /* 34 XOR AL, I                  */
    dszXOR,   O_AX_Iv,                  /* 35 XOR AX, I                  */
    dszSS_,   O_SEG_OVERRIDE,           /* 36 SEG SS:                    */
    dszAAA,   O_NoOperands,             /* 37 AAA                        */
    dszCMP,   O_bModrm_Reg,             /* 38 CMP mem/reg, reg (byte)    */
    dszCMP,   O_Modrm_Reg,              /* 39 CMP mem/reg, reg (word)    */
    dszCMP,   O_bReg_Modrm,             /* 3A CMP reg, mem/reg (byte)    */
    dszCMP,   O_Reg_Modrm,              /* 3B CMP reg, mem/reg (word)    */
    dszCMP,   O_AL_Ib,                  /* 3C CMP AL, I                  */
    dszCMP,   O_AX_Iv,                  /* 3D CMP AX, I                  */
    dszDS_,   O_SEG_OVERRIDE,           /* 3E SEG DS:                    */
    dszAAS,   O_NoOperands,             /* 3F AAS                        */
    dszINC,   O_oReg,                   /* 40 INC AX                     */
    dszINC,   O_oReg,                   /* 41 INC CX                     */
    dszINC,   O_oReg,                   /* 42 INC DX                     */
    dszINC,   O_oReg,                   /* 43 INC BX                     */
    dszINC,   O_oReg,                   /* 44 INC SP                     */
    dszINC,   O_oReg,                   /* 45 INC BP                     */
    dszINC,   O_oReg,                   /* 46 INC SI                     */
    dszINC,   O_oReg,                   /* 47 INC DI                     */
    dszDEC,   O_oReg,                   /* 48 DEC AX                     */
    dszDEC,   O_oReg,                   /* 49 DEC CX                     */
    dszDEC,   O_oReg,                   /* 4A DEC DX                     */
    dszDEC,   O_oReg,                   /* 4B DEC BX                     */
    dszDEC,   O_oReg,                   /* 4C DEC SP                     */
    dszDEC,   O_oReg,                   /* 4D DEC BP                     */
    dszDEC,   O_oReg,                   /* 4E DEC SI                     */
    dszDEC,   O_oReg,                   /* 4F DEC DI                     */
    dszPUSH,  O_oReg,                   /* 50 PUSH AX                    */
    dszPUSH,  O_oReg,                   /* 51 PUSH CX                    */
    dszPUSH,  O_oReg,                   /* 52 PUSH DX                    */
    dszPUSH,  O_oReg,                   /* 53 PUSH BX                    */
    dszPUSH,  O_oReg,                   /* 54 PUSH SP                    */
    dszPUSH,  O_oReg,                   /* 55 PUSH BP                    */
    dszPUSH,  O_oReg,                   /* 56 PUSH SI                    */
    dszPUSH,  O_oReg,                   /* 57 PUSH DI                    */
    dszPOP,   O_oReg,                   /* 58 POP AX                     */
    dszPOP,   O_oReg,                   /* 59 POP CX                     */
    dszPOP,   O_oReg,                   /* 5A POP DX                     */
    dszPOP,   O_oReg,                   /* 5B POP BX                     */
    dszPOP,   O_oReg,                   /* 5C POP SP                     */
    dszPOP,   O_oReg,                   /* 5D POP BP                     */
    dszPOP,   O_oReg,                   /* 5E POP SI                     */
    dszPOP,   O_oReg,                   /* 5F POP DI                     */
    dszPUSHA, O_NoOpAlt5,               /* 60 PUSHA (286) / PUSHAD (386) */
    dszPOPA,  O_NoOpAlt4,               /* 61 POPA (286) / POPAD (286)   */
    dszBOUND, O_DoBound,                /* 62 BOUND reg, Modrm (286)     */
    dszARPL,  O_Modrm_Reg,              /* 63 ARPL Modrm, reg (286)      */
    dszFS_,   O_SEG_OVERRIDE,           /* 64                            */
    dszGS_,   O_SEG_OVERRIDE,           /* 65                            */
    dszOPPRFX,O_OPR_OVERRIDE,           /* 66                            */
    dszADDRPRFX,O_ADR_OVERRIDE,         /* 67                            */
    dszPUSH,  O_Iv,                     /* 68 PUSH word (286)            */
    dszIMUL,  O_Imul,                   /* 69 IMUL (286)                 */
    dszPUSH,  O_Ib,                     /* 6A PUSH byte (286)            */
    dszIMUL,  O_Imulb,                  /* 6B IMUL (286)                 */
    dszINSB,  O_NoOperands,             /* 6C INSB (286)                 */
    dszINSW,  O_NoOpAlt3,               /* 6D INSW (286) / INSD (386)    */
    dszOUTSB, O_NoOperands,             /* 6E OUTSB (286)                */
    dszOUTSW, O_NoOpAlt4,               /* 6F OUTSW (286) / OUTSD (386)  */
    dszJO,    O_Rel8,                   /* 70 JO                         */
    dszJNO,   O_Rel8,                   /* 71 JNO                        */
    dszJB,    O_Rel8,                   /* 72 JB or JNAE or JC           */
    dszJNB,   O_Rel8,                   /* 73 JNB or JAE or JNC          */
    dszJZ,    O_Rel8,                   /* 74 JE or JZ                   */
    dszJNZ,   O_Rel8,                   /* 75 JNE or JNZ                 */
    dszJBE,   O_Rel8,                   /* 76 JBE or JNA                 */
    dszJA,    O_Rel8,                   /* 77 JNBE or JA                 */
    dszJS,    O_Rel8,                   /* 78 JS                         */
    dszJNS,   O_Rel8,                   /* 79 JNS                        */
    dszJPE,   O_Rel8,                   /* 7A JP or JPE                  */
    dszJPO,   O_Rel8,                   /* 7B JNP or JPO                 */
    dszJL,    O_Rel8,                   /* 7C JL or JNGE                 */
    dszJGE,   O_Rel8,                   /* 7D JNL or JGE                 */
    dszJLE,   O_Rel8,                   /* 7E JLE or JNG                 */
    dszJG,    O_Rel8,                   /* 7F JNLE or JG                 */
    dszMULTI, O_GROUP11,                /* 80                            */
    dszMULTI, O_GROUP12,                /* 81                            */
    dszRESERVED, O_DoDB,                /* 82                            */
    dszMULTI, O_GROUP13,                /* 83                            */
    dszTEST,  O_bModrm_Reg,             /* 84 TEST reg, mem/reg (byte)   */
    dszTEST,  O_Modrm_Reg,              /* 85 TEST reg, mem/reg (word)   */
    dszXCHG,  O_bModrm_Reg,             /* 86 XCHG reg, mem/reg (byte)   */
    dszXCHG,  O_Modrm_Reg,              /* 87 XCHG reg, mem/reg (word)   */
    dszMOV,   O_bModrm_Reg,             /* 88 MOV mem/reg, reg (byte)    */
    dszMOV,   O_Modrm_Reg,              /* 89 MOV mem/reg, reg (word)    */
    dszMOV,   O_bReg_Modrm,             /* 8A MOV reg, mem/reg (byte)    */
    dszMOV,   O_Reg_Modrm,              /* 8B MOV reg, mem/reg (word)    */
    dszMOV,   O_Modrm_sReg3,            /* 8C MOV mem/reg, segreg        */
    dszLEA,   O_Reg_Modrm,              /* 8D LEA reg, mem               */
    dszMOV,   O_sReg3_Modrm,            /* 8E MOV segreg, mem/reg        */
    dszPOP,   O_Modrm,                  /* 8F POP mem/reg                */
    dszNOP,   O_NoOperands,             /* 90 NOP                        */
    dszXCHG,  O_AX_oReg,                /* 91 XCHG AX,CX                 */
    dszXCHG,  O_AX_oReg,                /* 92 XCHG AX,DX                 */
    dszXCHG,  O_AX_oReg,                /* 93 XCHG AX,BX                 */
    dszXCHG,  O_AX_oReg,                /* 94 XCHG AX,SP                 */
    dszXCHG,  O_AX_oReg,                /* 95 XCHG AX,BP                 */
    dszXCHG,  O_AX_oReg,                /* 96 XCHG AX,SI                 */
    dszXCHG,  O_AX_oReg,                /* 97 XCHG AX,DI                 */
    dszCBW,   O_NoOpAlt0,               /* 98 CBW / CWDE (386)           */
    dszCWD,   O_NoOpAlt1,               /* 99 CWD / CDQ (386)            */
    dszCALL,  O_FarPtr,                 /* 9A CALL seg:off               */
    dszWAIT,  O_NoOperands,             /* 9B WAIT                       */
    dszPUSHF, O_NoOpAlt5,               /* 9C PUSHF / PUSHFD (386)       */
    dszPOPF,  O_NoOpAlt4,               /* 9D POPF / POPFD (386)         */
    dszSAHF,  O_NoOperands,             /* 9E SAHF                       */
    dszLAHF,  O_NoOperands,             /* 9F LAHF                       */
    dszMOV,   O_AL_Offs,                /* A0 MOV AL, mem                */
    dszMOV,   O_AX_Offs,                /* A1 MOV AX, mem                */
    dszMOV,   O_Offs_AL,                /* A2 MOV mem, AL                */
    dszMOV,   O_Offs_AX,                /* A3 MOV mem, AX                */
    dszMOVSB, O_NoOpStrSIDI,            /* A4 MOVSB                      */
    dszMOVSW, O_NoOpStrSIDI,            /* A5 MOVSW / MOVSD (386)        */
    dszCMPSB, O_NoOpStrSIDI,            /* A6 CMPSB                      */
    dszCMPSW, O_NoOpStrSIDI,            /* A7 CMPSW / CMPSD (386)        */
    dszTEST,  O_AL_Ib,                  /* A8 TEST AL, I                 */
    dszTEST,  O_AX_Iv,                  /* A9 TEST AX, I                 */
    dszSTOSB, O_NoOpStrDI,              /* AA STOSB                      */
    dszSTOSW, O_NoOpStrDI,              /* AB STOSW / STOSD (386)        */
    dszLODSB, O_NoOpStrSI,              /* AC LODSB                      */
    dszLODSW, O_NoOpStrSI,              /* AD LODSW / LODSD (386)        */
    dszSCASB, O_NoOpStrDI,              /* AE SCASB                      */
    dszSCASW, O_NoOpStrDI,              /* AF SCASW / SCASD (386)        */
    dszMOV,   O_oReg_Ib,                /* B0 MOV AL, I                  */
    dszMOV,   O_oReg_Ib,                /* B1 MOV CL, I                  */
    dszMOV,   O_oReg_Ib,                /* B2 MOV DL, I                  */
    dszMOV,   O_oReg_Ib,                /* B3 MOV BL, I                  */
    dszMOV,   O_oReg_Ib,                /* B4 MOV AH, I                  */
    dszMOV,   O_oReg_Ib,                /* B5 MOV CH, I                  */
    dszMOV,   O_oReg_Ib,                /* B6 MOV DH, I                  */
    dszMOV,   O_oReg_Ib,                /* B7 MOV BH, I                  */
    dszMOV,   O_oReg_Iv,                /* B8 MOV AX, I                  */
    dszMOV,   O_oReg_Iv,                /* B9 MOV CX, I                  */
    dszMOV,   O_oReg_Iv,                /* BA MOV DX, I                  */
    dszMOV,   O_oReg_Iv,                /* BB MOV BX, I                  */
    dszMOV,   O_oReg_Iv,                /* BC MOV SP, I                  */
    dszMOV,   O_oReg_Iv,                /* BD MOV BP, I                  */
    dszMOV,   O_oReg_Iv,                /* BE MOV SI, I                  */
    dszMOV,   O_oReg_Iv,                /* BF MOV DI, I                  */
    dszMULTI, O_GROUP21,                /* C0 shifts & rotates (286)     */
    dszMULTI, O_GROUP22,                /* C1 shifts & rotates (286)     */
    dszRET,   O_Iw,                     /* C2 RET Rel16                  */
    dszRET,   O_NoOperands,             /* C3 RET                        */
    dszLES,   O_fReg_Modrm,             /* C4 LES reg, mem               */
    dszLDS,   O_fReg_Modrm,             /* C5 LDS reg, mem               */
    dszMOV,   O_bModrm_Ib,              /* C6 MOV mem/reg, I(byte)       */
    dszMOV,   O_Modrm_Iv,               /* C7 MOV mem/reg, I(word)       */
    dszENTER, O_Enter,                  /* C8 ENTER (286)                */
    dszLEAVE, O_NoOperands,             /* C9 LEAVE (286)                */
    dszRETF,  O_Iw,                     /* CA RETF I(word)               */
    dszRETF,  O_NoOperands,             /* CB RETF                       */
    dszINT,   O_DoInt3,                 /* CC INT 3                      */
    dszINT,   O_DoInt,                  /* CD INT                        */
    dszINTO,  O_NoOperands,             /* CE INTO                       */
    dszIRET,  O_NoOpAlt4,               /* CF IRET / IRETD (386)         */
    dszMULTI, O_GROUP23,                /* D0 shifts & rotates,1 (byte)  */
    dszMULTI, O_GROUP24,                /* D1 shifts & rotates,1 (word)  */
    dszMULTI, O_GROUP25,                /* D2 shifts & rotates,CL (byte) */
    dszMULTI, O_GROUP26,                /* D3 shifts & rotates,CL (word) */
    dszAAM,   O_Ib,                     /* D4 AAM                        */
    dszAAD,   O_Ib,                     /* D5 AAD                        */
    dszRESERVED, O_DoDB,                /* D6                            */
    dszXLAT,  O_NoOperands,             /* D7 XLAT                       */
    dszMULTI, O_x87_ESC,                /* D8 ESC                        */
    dszMULTI, O_x87_ESC,                /* D9 ESC                        */
    dszMULTI, O_x87_ESC,                /* DA ESC                        */
    dszMULTI, O_x87_ESC,                /* DB ESC                        */
    dszMULTI, O_x87_ESC,                /* DC ESC                        */
    dszMULTI, O_x87_ESC,                /* DD ESC                        */
    dszMULTI, O_x87_ESC,                /* DE ESC                        */
    dszMULTI, O_x87_ESC,                /* DF ESC                        */
    dszLOOPNE,O_Rel8,                   /* E0 LOOPNE or LOOPNZ           */
    dszLOOPE, O_Rel8,                   /* E1 LOOPE or LOOPZ             */
    dszLOOP,  O_Rel8,                   /* E2 LOOP                       */
    dszJCXZ,  O_Rel8,                   /* E3 JCXZ / JECXZ (386)         */
    dszIN,    O_AL_Ubyte,               /* E4 IN AL, I                   */
    dszIN,    O_AX_Ubyte,               /* E5 IN AX, I                   */
    dszOUT,   O_Ubyte_AL,               /* E6 OUT I, AL                  */
    dszOUT,   O_Ubyte_AX,               /* E7 OUT I, AX                  */
    dszCALL,  O_Rel16,                  /* E8 CALL Rel16                 */
    dszJMP,   O_Rel16,                  /* E9 JMP Rel16                  */
    dszJMP,   O_FarPtr,                 /* EA JMP seg:off                */
    dszJMP,   O_Rel8,                   /* EB JMP Rel8                   */
    dszIN,    O_DoInAL,                 /* EC IN AL, DX                  */
    dszIN,    O_DoInAX,                 /* ED IN AX, DX                  */
    dszOUT,   O_DoOutAL,                /* EE OUT DX, AL                 */
    dszOUT,   O_DoOutAX,                /* EF OUT DX, AX                 */
    dszLOCK,  O_DoRep,                  /* F0 LOCK                       */
    dszRESERVED, O_DoDB,                /* F1                            */
    dszREPNE, O_DoRep,                  /* F2 REPNE or REPNZ             */
    dszREP,   O_DoRep,                  /* F3 REP or REPE or REPZ        */
    dszHLT,   O_NoOperands,             /* F4 HLT                        */
    dszCMC,   O_NoOperands,             /* F5 CMC                        */
    dszMULTI, O_GROUP31,                /* F6 TEST, NOT, NEG, MUL, IMUL, */
    dszMULTI, O_GROUP32,                /* F7 DIv, IDIv F6=Byte F7=Word  */
    dszCLC,   O_NoOperands,             /* F8 CLC                        */
    dszSTC,   O_NoOperands,             /* F9 STC                        */
    dszCLI,   O_NoOperands,             /* FA CLI                        */
    dszSTI,   O_NoOperands,             /* FB STI                        */
    dszCLD,   O_NoOperands,             /* FC CLD                        */
    dszSTD,   O_NoOperands,             /* FD STD                        */
    dszMULTI, O_GROUP4,                 /* FE INC, DEC mem/reg (byte)    */
    dszMULTI, O_GROUP5,                 /* FF INC, DEC, CALL, JMP, PUSH  */

    // secondary opcode table begins. Only "filled" locations are stored
    // to compress the secondary table. Hence while disassembling
    // opcode needs to be displaced appropriately to account for the.
    // The displacements are defined in 86dis.c and need to be reevaluated
    // if new opcodes are added here.

    dszMULTI, O_GROUP6,                 /* 0 MULTI                       */
    dszMULTI, O_GROUP7,                 /* 1 MULTI                       */
    dszLAR,   O_Reg_Modrm,              /* 2 LAR                         */
    dszLSL,   O_Reg_Modrm,              /* 3 LSL                         */
    dszRESERVED, O_DoDB,                /* 4                             */
    dszLOADALL, O_NoOperands,           /* 5 LOADALL                     */
    dszCLTS,  O_NoOperands,             /* 6 CLTS                        */
    dszMULTI, O_GROUP7,                 /* 7 MULTI                       */
    dszINVD,  O_NoOperands,             /* 8 INVD                        */
    dszWBINVD,O_NoOperands,             /* 9 WBINVD                      */
    dszRESERVED, O_DoDB,                /* A                             */
    dszUD2,   O_NoOperands,             /* B UD2 undefined               */
    dszMOV,   O_Modrm_CReg,             /* 20 MOV Rd,Cd                  */
    dszMOV,   O_Modrm_CReg,             /* 21 MOV Rd,Dd                  */
    dszMOV,   O_CReg_Modrm,             /* 22 MOV Cd,Rd                  */
    dszMOV,   O_CReg_Modrm,             /* 23 MOV Dd,Rd                  */
    dszMOV,   O_Modrm_CReg,             /* 24 MOV Rd,Td                  */
    dszRESERVED, O_DoDB,                /* 25                            */
    dszMOV,   O_CReg_Modrm,             /* 26 MOV Td,Rd                  */

    dszWRMSR, O_NoOperands,             /* 30 WRMSR                      */
    dszRDTSC, O_NoOperands,             /* 31 RDTSC                      */
    dszRDMSR, O_NoOperands,             /* 32 RDMSR                      */
    dszRDPMC, O_NoOperands,             /* 33 RDPMC                      */

    dszCMOVO,  O_Reg_Modrm,             /* 40 CMOVO                      */
    dszCMOVNO, O_Reg_Modrm,             /* 41 CMOVNO                     */
    dszCMOVB,  O_Reg_Modrm,             /* 42 CMOVB                      */
    dszCMOVNB, O_Reg_Modrm,             /* 43 CMOVNB                     */
    dszCMOVE,  O_Reg_Modrm,             /* 44 CMOVE                      */
    dszCMOVNE, O_Reg_Modrm,             /* 45 CMOVNE                     */
    dszCMOVBE, O_Reg_Modrm,             /* 46 CMOVBE                     */
    dszCMOVA,  O_Reg_Modrm,             /* 47 CMOVNBE                    */
    dszCMOVS,  O_Reg_Modrm,             /* 48 CMOVS                      */
    dszCMOVNS, O_Reg_Modrm,             /* 49 CMOVNS                     */
    dszCMOVP,  O_Reg_Modrm,             /* 4A CMOVP                      */
    dszCMOVNP, O_Reg_Modrm,             /* 4B CMOVNP                     */
    dszCMOVL,  O_Reg_Modrm,             /* 4C CMOVL                      */
    dszCMOVGE, O_Reg_Modrm,             /* 4D CMOVGE                     */
    dszCMOVLE, O_Reg_Modrm,             /* 4E CMOVLE                     */
    dszCMOVNLE,O_Reg_Modrm,             /* 4F CMOVNLE                    */

    dszPUNPCKLBW,O_MmReg_qModrm,        /* 60 PUNPCKLBW                  */
    dszPUNPCKLWD,O_MmReg_qModrm,        /* 61 PUNPCKLWD                  */
    dszPUNPCKLDQ,O_MmReg_qModrm,        /* 62 PUNPCKLDQ                  */
    dszPACKSSWB, O_MmReg_qModrm,        /* 63 PACKSSWB                   */
    dszPCMPGTB,  O_MmReg_qModrm,        /* 64 PCMPGTB                    */
    dszPCMPGTW,  O_MmReg_qModrm,        /* 65 PCMPGTW                    */
    dszPCMPGTD,  O_MmReg_qModrm,        /* 66 PCMPGTD                    */
    dszPACKUSWB, O_MmReg_qModrm,        /* 67 PACKUSWB                   */
    dszPUNPCKHBW,O_MmReg_qModrm,        /* 68 PUNPCKHBW                  */
    dszPUNPCKHWD,O_MmReg_qModrm,        /* 69 PUNPCKHWD                  */
    dszPUNPCKHDQ,O_MmReg_qModrm,        /* 6A PUNPCKHDQ                  */
    dszPACKSSDW, O_MmReg_qModrm,        /* 6B PACKSSDW                   */
    dszRESERVED, O_DoDB,                /* 6C                            */
    dszRESERVED, O_DoDB,                /* 6D                            */
    dszMOVD,     O_MmReg_dModrm,        /* 6E MOVD                       */
    dszMOVQ,     O_MmReg_qModrm,        /* 6F MOVQ                       */
    dszRESERVED, O_DoDB,                /* 70                            */
    dszMULTI,    O_PSHimw,              /* 71 PS[LR][AL]W immediate      */
    dszMULTI,    O_PSHimd,              /* 72 PS[LR][AL]D immediate      */
    dszMULTI,    O_PSHimq,              /* 73 PS[LR]LQ immediate         */
    dszPCMPEQB,  O_MmReg_qModrm,        /* 74 PCMPEQB                    */
    dszPCMPEQW,  O_MmReg_qModrm,        /* 75 PCMPEQW                    */
    dszPCMPEQD,  O_MmReg_qModrm,        /* 76 PCMPEQD                    */
    dszEMMS,     O_NoOperands,          /* 77 EMMS                       */
    dszRESERVED, O_DoDB,                /* 78                            */
    dszRESERVED, O_DoDB,                /* 79                            */
    dszRESERVED, O_DoDB,                /* 7A                            */
    dszRESERVED, O_DoDB,                /* 7B                            */
    dszRESERVED, O_DoDB,                /* 7C                            */
    dszSETNL,    O_bModrm,              /* 7D SETNL                      */
    dszMOVD,     O_dModrm_MmReg,        /* 7E MOVD                       */
    dszMOVQ,     O_qModrm_MmReg,        /* 7F MOVQ                       */
    dszJO,    O_Rel16,                  /* 80 JO                         */
    dszJNO,   O_Rel16,                  /* 81 JNO                        */
    dszJB,    O_Rel16,                  /* 82 JB                         */
    dszJNB,   O_Rel16,                  /* 83 JNB                        */
    dszJE,    O_Rel16,                  /* 84 JE                         */
    dszJNE,   O_Rel16,                  /* 85 JNE                        */
    dszJBE,   O_Rel16,                  /* 86 JBE                        */
    dszJNBE,  O_Rel16,                  /* 87 JNBE                       */
    dszJS,    O_Rel16,                  /* 88 JS                         */
    dszJNS,   O_Rel16,                  /* 89 JNS                        */
    dszJP,    O_Rel16,                  /* 8A JP                         */
    dszJNP,   O_Rel16,                  /* 8B JNP                        */
    dszJL,    O_Rel16,                  /* 8C JL                         */
    dszJNL,   O_Rel16,                  /* 8D JNL                        */
    dszJLE,   O_Rel16,                  /* 8E JLE                        */
    dszJNLE,  O_Rel16,                  /* 8F JNLE                       */
    dszSETO,  O_bModrm,                 /* 90 SETO                       */
    dszSETNO, O_bModrm,                 /* 91 SETNO                      */
    dszSETB,  O_bModrm,                 /* 92 SETB                       */
    dszSETNB, O_bModrm,                 /* 93 SETNB                      */
    dszSETE,  O_bModrm,                 /* 94 SETE                       */
    dszSETNE, O_bModrm,                 /* 95 SETNE                      */
    dszSETBE, O_bModrm,                 /* 96 SETBE                      */
    dszSETA,  O_bModrm,                 /* 97 SETNBE                     */
    dszSETS,  O_bModrm,                 /* 98 SETS                       */
    dszSETNS, O_bModrm,                 /* 99 SETNS                      */
    dszSETP,  O_bModrm,                 /* 9A SETP                       */
    dszSETNP, O_bModrm,                 /* 9B SETNP                      */
    dszSETL,  O_bModrm,                 /* 9C SETL                       */
    dszSETGE, O_bModrm,                 /* 9D SETGE                      */
    dszSETLE, O_bModrm,                 /* 9E SETLE                      */
    dszSETNLE,O_bModrm,                 /* 9F SETNLE                     */
    dszPUSH,  O_sReg2,                  /* A0 PUSH FS                    */
    dszPOP,   O_sReg2,                  /* A1 POP FS                     */
    dszCPUID, O_NoOperands,             /* A2 CPUID                      */
    dszBT,    O_Modrm_Reg,              /* A3 BT                         */
    dszSHLD,  O_Modrm_Reg_Ib,           /* A4 SHLD                       */
    dszSHLD,  O_Modrm_Reg_CL,           /* A5 SHLD                       */
    dszRESERVED, O_DoDB,                /* A6                            */
    dszRESERVED, O_DoDB,                /* A7                            */
    dszPUSH,  O_sReg2,                  /* A8 PUSH GS                    */
    dszPOP,   O_sReg2,                  /* A9 POP GS                     */
    dszRSM,   O_NoOperands,             /* AA RSM                        */
    dszBTS,   O_vModrm_Reg,             /* AB BTS                        */
    dszSHRD,  O_Modrm_Reg_Ib,           /* AC SHRD                       */
    dszSHRD,  O_Modrm_Reg_CL,           /* AD SHRD                       */
    dszRESERVED, O_DoDB,                /* AE                            */
    dszIMUL,  O_Reg_Modrm,              /* AF IMUL                       */
    dszCMPXCHG,O_bModrm_Reg,            /* B0 CMPXCH                     */
    dszCMPXCHG,O_Modrm_Reg,             /* B1 CMPXCH                     */
    dszLSS,   O_fReg_Modrm,             /* B2 LSS                        */
    dszBTR,   O_Modrm_Reg,              /* B3 BTR                        */
    dszLFS,   O_fReg_Modrm,             /* B4 LFS                        */
    dszLGS,   O_fReg_Modrm,             /* B5 LGS                        */
    dszMOVZX, O_Reg_bModrm,             /* B6 MOVZX                      */
    dszMOVZX, O_Reg_wModrm,             /* B7 MOVZX                      */
    dszRESERVED, O_DoDB,                /* B8                            */
    dszRESERVED, O_DoDB,                /* B9                            */
    dszMULTI, O_GROUP8,                 /* BA MULTI                      */
    dszBTC,   O_Modrm_Reg,              /* BB BTC                        */
    dszBSF,   O_Reg_Modrm,              /* BC BSF                        */
    dszBSR,   O_Reg_Modrm,              /* BD BSR                        */
    dszMOVSX, O_Reg_bModrm,             /* BE MOVSX                      */
    dszMOVSX, O_Reg_wModrm,             /* BF MOVSX                      */
    dszXADD,  O_bModrm_Reg,             /* C0 XADD                       */
    dszXADD,  O_Modrm_Reg,              /* C1 XADD                       */
    dszRESERVED, O_DoDB,                /* C2                            */
    dszRESERVED, O_DoDB,                /* C3                            */
    dszRESERVED, O_DoDB,                /* C4                            */
    dszRESERVED, O_DoDB,                /* C5                            */
    dszRESERVED, O_DoDB,                /* C6                            */
    dszCMPXCHG8B,O_qModrm,              /* C7 CMPXCHG8B                  */
    dszBSWAP,    O_oReg,                /* C8 BSWAP                      */
    dszBSWAP,    O_oReg,                /* C9 BSWAP                      */
    dszBSWAP,    O_oReg,                /* CA BSWAP                      */
    dszBSWAP,    O_oReg,                /* CB BSWAP                      */
    dszBSWAP,    O_oReg,                /* CC BSWAP                      */
    dszBSWAP,    O_oReg,                /* CD BSWAP                      */
    dszBSWAP,    O_oReg,                /* CE BSWAP                      */
    dszBSWAP,    O_oReg,                /* CF BSWAP                      */
    dszRESERVED, O_DoDB,                /* D0                            */
    dszPSRLW,    O_MmReg_qModrm,        /* D1 PSRLW                      */
    dszPSRLD,    O_MmReg_qModrm,        /* D2 PSRLD                      */
    dszPSRLQ,    O_MmReg_qModrm,        /* D3 PSRLQ                      */
    dszRESERVED, O_DoDB,                /* D4                            */
    dszPMULLW,   O_MmReg_qModrm,        /* D5 PMULLW                     */
    dszRESERVED, O_DoDB,                /* D6                            */
    dszRESERVED, O_DoDB,                /* D7                            */
    dszPSUBUSB,  O_MmReg_qModrm,        /* D8 PSUBUSB                    */
    dszPSUBUSW,  O_MmReg_qModrm,        /* D9 PSUBUSW                    */
    dszRESERVED, O_DoDB,                /* DA                            */
    dszPAND,     O_MmReg_qModrm,        /* DB PAND                       */
    dszPADDUSB,  O_MmReg_qModrm,        /* DC PADDUSB                    */
    dszPADDUSW,  O_MmReg_qModrm,        /* DD PADDUSW                    */
    dszRESERVED, O_DoDB,                /* DE                            */
    dszPANDN,    O_MmReg_qModrm,        /* DF PANDN                      */
    dszRESERVED, O_DoDB,                /* E0                            */
    dszPSRAW,    O_MmReg_qModrm,        /* E1 PSRAW                      */
    dszPSRAD,    O_MmReg_qModrm,        /* E2 PSRAD                      */
    dszRESERVED, O_DoDB,                /* E3                            */
    dszRESERVED, O_DoDB,                /* E4                            */
    dszPMULHW,   O_MmReg_qModrm,        /* E5 PMULHW                     */
    dszRESERVED, O_DoDB,                /* E6                            */
    dszRESERVED, O_DoDB,                /* E7                            */
    dszPSUBSB,   O_MmReg_qModrm,        /* E8 PSUBSB                     */
    dszPSUBSW,   O_MmReg_qModrm,        /* E9 PSUBSW                     */
    dszRESERVED, O_DoDB,                /* EA                            */
    dszPOR,      O_MmReg_qModrm,        /* EB POR                        */
    dszPADDSB,   O_MmReg_qModrm,        /* EC PADDSB                     */
    dszPADDSW,   O_MmReg_qModrm,        /* ED PADDSW                     */
    dszRESERVED, O_DoDB,                /* EE                            */
    dszPXOR,     O_MmReg_qModrm,        /* EF PXOR                       */
    dszRESERVED, O_DoDB,                /* F0                            */
    dszPSLLW,    O_MmReg_qModrm,        /* F1 PSLLW                      */
    dszPSLLD,    O_MmReg_qModrm,        /* F2 PSLLD                      */
    dszPSLLQ,    O_MmReg_qModrm,        /* F3 PSLLQ                      */
    dszRESERVED, O_DoDB,                /* F4                            */
    dszPMADDWD,  O_MmReg_qModrm,        /* F5 PMADDWD                    */
    dszRESERVED, O_DoDB,                /* F6                            */
    dszRESERVED, O_DoDB,                /* F7                            */
    dszPSUBB,    O_MmReg_qModrm,        /* F8 PSUBB                      */
    dszPSUBW,    O_MmReg_qModrm,        /* F9 PSUBW                      */
    dszPSUBD,    O_MmReg_qModrm,        /* FA PSUBD                      */
    dszRESERVED, O_DoDB,                /* FB                            */
    dszPADDB,    O_MmReg_qModrm,        /* FC PADDB                      */
    dszPADDW,    O_MmReg_qModrm,        /* FD PADDW                      */
    dszPADDD,    O_MmReg_qModrm,        /* FE PADDD                      */
};

/* Auxilary lists of mnemonics for groups of two byte instructions:      */
/*   All of the instructions within each of these groups are of the same */
/*   class, so only the mnemonic string is needed, the index into the    */
/*   action table is implicit.                                           */

static char *group[][8] = {

/* 00 */    {dszADD,  dszOR,    dszADC,  dszSBB,    /* group 1 */
             dszAND,  dszSUB,   dszXOR,  dszCMP},

/* 01 */    {dszROL,  dszROR,   dszRCL,      dszRCR,    /* group 2 */
             dszSHL,  dszSHR,   dszRESERVED, dszSAR},

/* 02 */    {dszINC,      dszDEC,      dszRESERVED, dszRESERVED, /* group 4 */
             dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED},

/* 03 */    {dszSLDT, dszSTR,   dszLLDT,     dszLTR,    /* group 6 */
             dszVERR, dszVERW,  dszRESERVED, dszRESERVED},

/* 04 */    {dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED, /* group 8 */
             dszBT,       dszBTS,      dszBTR,      dszBTC},

/* 05 */    {dszRESERVED, dszRESERVED, dszPSRLW,    dszRESERVED, /* PSHimw */
             dszPSRAW,    dszRESERVED, dszPSLLW,    dszRESERVED},
            
/* 06 */    {dszRESERVED, dszRESERVED, dszPSRLD,    dszRESERVED, /* PSHimd */
             dszPSRAD,    dszRESERVED, dszPSLLD,    dszRESERVED},
            
/* 07 */    {dszRESERVED, dszRESERVED, dszPSRLQ,    dszRESERVED, /* PSHimq */
             dszRESERVED, dszRESERVED, dszPSLLQ,    dszRESERVED},
            
            };

/* Auxilary orderd pairs for groups of two byte instructions structured  */
/*   the same was as distbl above.                                       */

static Tdistbl groupt[][8] = {

/* 00  00                     x87-D8-1                   */
            { dszFADD,     O_dModrm,     /* D8-0 FADD    */
              dszFMUL,     O_dModrm,     /* D8-1 FMUL    */
              dszFCOM,     O_dModrm,     /* D8-2 FCOM    */
              dszFCOMP,    O_dModrm,     /* D8-3 FCOMP   */
              dszFSUB,     O_dModrm,     /* D8-4 FSUB    */
              dszFSUBR,    O_dModrm,     /* D8-5 FSUBR   */
              dszFDIV,     O_dModrm,     /* D8-6 FDIV    */
              dszFDIVR,    O_dModrm },   /* D8-7 FDIVR   */

/* 01                         x87-D8-2                   */
            { dszFADD,     O_ST_iST,     /* D8-0 FADD    */
              dszFMUL,     O_ST_iST,     /* D8-1 FMUL    */
              dszFCOM,     O_iST,        /* D8-2 FCOM    */
              dszFCOMP,    O_iST,        /* D8-3 FCOMP   */
              dszFSUB,     O_ST_iST,     /* D8-4 FSUB    */
              dszFSUBR,    O_ST_iST,     /* D8-5 FSUBR   */
              dszFDIV,     O_ST_iST,     /* D8-6 FDIV    */
              dszFDIVR,    O_ST_iST },   /* D8-7 FDIVR   */

/* 02   01                    x87-D9-1                   */
            { dszFLD,      O_dModrm,     /* D9-0 FLD     */
              dszRESERVED, O_DoDB,       /* D9-1         */
              dszFST,      O_dModrm,     /* D9-2 FST     */
              dszFSTP,     O_dModrm,     /* D9-3 FSTP    */
              dszFLDENV,   O_Modrm,      /* D9-4 FLDENV  */
              dszFLDCW,    O_Modrm,      /* D9-5 FLDCW   */
              dszFSTENV,   O_Modrm,      /* D9-6 FSTENV  */
              dszFSTCW,    O_Modrm },    /* D9-7 FSTCW   */

/* 03   01                    x87-D9-2 TTT=0,1,2,3       */
            { dszFLD,      O_iST,        /* D9-0 FLD     */
              dszFXCH,     O_iST,        /* D9-1 FXCH    */
              dszFNOP,     O_NoOperands, /* D9-2 FNOP    */
              dszFSTP,     O_iST,        /* D9-3 FSTP    */
              dszRESERVED, O_DoDB,       /* D9-4         */
              dszRESERVED, O_DoDB,       /* D9-5         */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB   },   /* D9-7         */

/* 04  02                     x89-DA-1                   */
            { dszFIADD,    O_dModrm,     /* DA-0 FIADD   */
              dszFIMUL,    O_dModrm,     /* DA-1 FIMUL   */
              dszFICOM,    O_dModrm,     /* DA-2 FICOM   */
              dszFICOMP,   O_dModrm,     /* DA-3 FICOMP  */
              dszFISUB,    O_dModrm,     /* DA-4 FISUB   */
              dszFISUBR,   O_dModrm,     /* DA-5 FISUBR  */
              dszFIDIV,    O_dModrm,     /* DA-6 FIDIV   */
              dszFIDIVR,   O_dModrm },   /* DA-7 FIDIVR  */

/* 05                         x87-DA-2                   */
            { dszFCMOVB,   O_ST_iST,     /* DA-0 FCMOVB  */
              dszFCMOVE,   O_ST_iST,     /* DA-1 FCMOVE  */
              dszFCMOVBE,  O_ST_iST,     /* DA-2 FCMOVBE */
              dszFCMOVU,   O_ST_iST,     /* DA-3 FCMOVU  */
              dszRESERVED, O_DoDB,       /* DA-4         */
              dszFUCOMPP,  O_NoOperands, /* DA-5         */
              dszRESERVED, O_DoDB,       /* DA-6         */
              dszRESERVED, O_DoDB },     /* DA-7         */

/* 06  03                     x87-DB-1                   */
            { dszFILD,     O_dModrm,     /* DB-0 FILD    */
              dszRESERVED, O_DoDB,       /* DB-1         */
              dszFIST,     O_dModrm,     /* DB-2 FIST    */
              dszFISTP,    O_dModrm,     /* DB-3 FISTP   */
              dszRESERVED, O_DoDB,       /* DB-4         */
              dszFLD,      O_tModrm,     /* DB-5 FLD     */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszFSTP,     O_tModrm },   /* DB-7 FSTP    */

/* 07                      x87-DB-2 ttt=4        */
            { dszFENI,     O_NoOperands, /* DB-0 FENI    */
              dszFDISI,    O_NoOperands, /* DB-1 FDISI   */
              dszFCLEX,    O_NoOperands, /* DB-2 FCLEX   */
              dszFINIT,    O_NoOperands, /* DB-3 FINIT   */
              dszFSETPM,   O_DoDB,       /* DB-4 FSETPM  */
              dszRESERVED, O_DoDB,       /* DB-5         */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszRESERVED, O_DoDB },     /* DB-7         */

/* 08 04                      x87-DC-1                   */
            { dszFADD,     O_qModrm,     /* DC-0 FADD    */
              dszFMUL,     O_qModrm,     /* DC-1 FMUL    */
              dszFCOM,     O_qModrm,     /* DC-2 FCOM    */
              dszFCOMP,    O_qModrm,     /* DC-3 FCOMP   */
              dszFSUB,     O_qModrm,     /* DC-4 FSUB    */
              dszFSUBR,    O_qModrm,     /* DC-5 FSUBR   */
              dszFDIV,     O_qModrm,     /* DC-6 FDIV    */
              dszFDIVR,    O_qModrm },   /* DC-7 FDIVR   */

/* 09                         x87-DC-2                   */
            { dszFADD,     O_iST_ST,     /* DC-0 FADD    */
              dszFMUL,     O_iST_ST,     /* DC-1 FMUL    */
              dszFCOM,     O_iST,        /* DC-2 FCOM    */
              dszFCOMP,    O_iST,        /* DC-3 FCOMP   */
              dszFSUB,     O_iST_ST,     /* DC-4 FSUB    */
              dszFSUBR,    O_iST_ST,     /* DC-5 FSUBR   */
              dszFDIV,     O_iST_ST,     /* DC-6 FDIVR   */
              dszFDIVR,    O_iST_ST },   /* DC-7 FDIV    */

/* 10  05                     x87-DD-1                   */
            { dszFLD,      O_qModrm,     /* DD-0 FLD     */
              dszRESERVED, O_DoDB,       /* DD-1         */
              dszFST,      O_qModrm,     /* DD-2 FST     */
              dszFSTP,     O_qModrm,     /* DD-3 FSTP    */
              dszFRSTOR,   O_Modrm,      /* DD-4 FRSTOR  */
              dszRESERVED, O_DoDB,       /* DD-5         */
              dszFSAVE,    O_Modrm,      /* DD-6 FSAVE   */
              dszFSTSW,    O_Modrm },    /* DD-7 FSTSW   */

/* 11                         x87-DD-2                   */
            { dszFFREE,    O_iST,        /* DD-0 FFREE   */
              dszFXCH,     O_iST,        /* DD-1 FXCH    */
              dszFST,      O_iST,        /* DD-2 FST     */
              dszFSTP,     O_iST,        /* DD-3 FSTP    */
              dszFUCOM,    O_iST,        /* DD-4 FUCOM   */
              dszFUCOMP,   O_iST,        /* DD-5 FUCOMP  */
              dszRESERVED, O_DoDB,       /* DD-6         */
              dszRESERVED, O_DoDB },     /* DD-7         */

/* 12  06                     x87-DE-1                   */
            { dszFIADD,    O_wModrm,     /* DE-0 FIADD   */
              dszFIMUL,    O_wModrm,     /* DE-1 FIMUL   */
              dszFICOM,    O_wModrm,     /* DE-2 FICOM   */
              dszFICOMP,   O_wModrm,     /* DE-3 FICOMP  */
              dszFISUB,    O_wModrm,     /* DE-4 FISUB   */
              dszFISUBR,   O_wModrm,     /* DE-5 FISUBR  */
              dszFIDIV,    O_wModrm,     /* DE-6 FIDIV   */
              dszFIDIVR,   O_wModrm },   /* DE-7 FIDIVR  */

/* 13                         x87-DE-2                   */
            { dszFADDP,    O_iST_ST,     /* DE-0 FADDP   */
              dszFMULP,    O_iST_ST,     /* DE-1 FMULP   */
              dszFCOMP,    O_iST,        /* DE-2 FCOMP   */
              dszFCOMPP,   O_NoOperands, /* DE-3 FCOMPP  */
              dszFSUBP,    O_iST_ST,     /* DE-4 FSUBP   */
              dszFSUBRP,   O_iST_ST,     /* DE-5 FSUBRP  */
              dszFDIVP,    O_iST_ST,     /* DE-6 FDIVP   */
              dszFDIVRP,   O_iST_ST },   /* DE-7 FDIVRP  */

/* 14  07                     x87-DF-1                   */
            { dszFILD,     O_wModrm,     /* DF-0 FILD    */
              dszRESERVED, O_DoDB,       /* DF-1         */
              dszFIST,     O_wModrm,     /* DF-2 FIST    */
              dszFISTP,    O_wModrm,     /* DF-3 FISTP   */
              dszFBLD,     O_tModrm,     /* DF-4 FBLD    */
              dszFILD,     O_qModrm,     /* DF-5 FILD    */
              dszFBSTP,    O_tModrm,     /* DF-6 FBSTP   */
              dszFISTP,    O_qModrm },   /* DF-7 FISTP   */

/* 15                         x87-DF-2                   */
            { dszFFREE,    O_iST,        /* DF-0 FFREE   */
              dszFXCH,     O_iST,        /* DF-1 FXCH    */
              dszFST,      O_iST,        /* DF-2 FST     */
              dszFSTP,     O_iST,        /* DF-3 FSTP    */
              dszFSTSW,    O_NoOperands, /* DF-4 FSTSW   */
              dszFUCOMIP,  O_ST_iST,     /* DF-5 FUCOMIP */
              dszFCOMIP,   O_ST_iST,     /* DF-6 FCOMIP  */
              dszRESERVED, O_DoDB },     /* DF-7         */

/* 16   01            x87-D9 Mod=3 TTT=4                 */
            { dszFCHS,     O_NoOperands, /* D9-0 FCHS    */
              dszFABS,     O_NoOperands,  /* D9-1 FABS   */
              dszRESERVED, O_DoDB,       /* D9-2         */
              dszRESERVED, O_DoDB,       /* D9-3         */
              dszFTST,     O_NoOperands, /* D9-4 FTST    */
              dszFXAM,     O_NoOperands, /* D9-5 FXAM    */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 17   01            x87-D9 Mod=3 TTT=5                 */
            { dszFLD1,     O_NoOperands, /* D9-0 FLD1    */
              dszFLDL2T,   O_NoOperands, /* D9-1 FLDL2T  */
              dszFLDL2E,   O_NoOperands, /* D9-2 FLDL2E  */
              dszFLDPI,    O_NoOperands, /* D9-3 FLDPI   */
              dszFLDLG2,   O_NoOperands, /* D9-4 FLDLG2  */
              dszFLDLN2,   O_NoOperands, /* D9-5 FLDLN2  */
              dszFLDZ,     O_NoOperands, /* D9-6 FLDZ    */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 18   01            x87-D9 Mod=3 TTT=6                   */
            { dszF2XM1,    O_NoOperands,   /* D9-0 F2XM1   */
              dszFYL2X,    O_NoOperands,   /* D9-1 FYL2X   */
              dszFPTAN,    O_NoOperands,   /* D9-2 FPTAN   */
              dszFPATAN,   O_NoOperands,   /* D9-3 FPATAN  */
              dszFXTRACT,  O_NoOperands,   /* D9-4 FXTRACT */
              dszFPREM1,   O_NoOperands,   /* D9-5 FPREM1  */
              dszFDECSTP,  O_NoOperands,   /* D9-6 FDECSTP */
              dszFINCSTP,  O_NoOperands }, /* D9-7 FINCSTP */

/* 19   01            x87-D9 Mod=3 TTT=7                   */
            { dszFPREM,    O_NoOperands,   /* D9-0 FPREM   */
              dszFYL2XP1,  O_NoOperands,   /* D9-1 FYL2XP1 */
              dszFSQRT,    O_NoOperands,   /* D9-2 FSQRT   */
              dszFSINCOS,  O_NoOperands,   /* D9-3 FSINCOS */
              dszFRNDINT,  O_NoOperands,   /* D9-4 FRNDINT */
              dszFSCALE,   O_NoOperands,   /* D9-5 FSCALE  */
              dszFSIN,     O_NoOperands,   /* D9-6 FSIN    */
              dszFCOS,     O_NoOperands }, /* D9-7 FCOS    */

/* 20                  group 3                             */
            { dszTEST,     O_bModrm_Ib,    /* F6-0 TEST    */
              dszRESERVED, O_DoDB,         /* F6-1         */
              dszNOT,      O_bModrm,       /* F6-2 NOT     */
              dszNEG,      O_bModrm,       /* F6-3 NEG     */
              dszMUL,      O_bModrm,       /* F6-4 MUL     */
              dszIMUL,     O_bModrm,       /* F6-5 IMUL    */
              dszDIV,      O_bModrm,       /* F6-6 DIV     */
              dszIDIV,     O_bModrm },     /* F6-7 IDIV    */

/* 21                  group 3                             */
            { dszTEST,     O_vModrm_Iv,    /* F7-0 TEST    */
              dszRESERVED, O_DoDB,         /* F7-1         */
              dszNOT,      O_vModrm,       /* F7-2 NOT     */
              dszNEG,      O_vModrm,       /* F7-3 NEG     */
              dszMUL,      O_vModrm,       /* F7-4 MUL     */
              dszIMUL,     O_vModrm,       /* F7-5 IMUL    */
              dszDIV,      O_vModrm,       /* F7-6 DIV     */
              dszIDIV,     O_vModrm },     /* F7-7 IDIV    */

/* 22                  group 5                             */
            { dszINC,      O_vModrm,     /* FF-0 INC       */
              dszDEC,      O_vModrm,     /* FF-1 DEC       */
              dszCALL,     O_vModrm,     /* FF-2 CALL      */
              dszCALL,     O_fModrm,     /* FF-3 CALL      */
              dszJMP,      O_vModrm,     /* FF-4 JMP       */
              dszJMP,      O_fModrm,     /* FF-5 JMP       */
              dszPUSH,     O_vModrm,     /* FF-6 PUSH      */
              dszRESERVED, O_DoDB },     /* FF-7           */

/* 23                  group 7                             */
            { dszSGDT,     O_Modrm,      /* 0F-0 SGDT      */
              dszSIDT,     O_Modrm,      /* 0F-1 SIDT      */
              dszLGDT,     O_Modrm,      /* 0F-2 LGDT      */
              dszLIDT,     O_Modrm,      /* 0F-3 LIDT      */
              dszSMSW,     O_wModrm,     /* 0F-4 MSW       */
              dszRESERVED, O_DoDB,       /* 0F-5           */
              dszLMSW,     O_wModrm,     /* 0F-6 LMSW      */
              dszINVLPG,   O_Modrm },    /* 0F-7 INVLPG    */

/* 24                 x87-DB Mod=3 TTT != 4                */
            { dszFCMOVNB,  O_ST_iST,     /* DB-0 FCMOVNB   */
              dszFCMOVNE,  O_ST_iST,     /* DB-1 FCMOVNE   */
              dszFCMOVNBE, O_ST_iST,     /* DB-2 FCMOVNBE  */
              dszFCMOVNU,  O_ST_iST,     /* DB-3 FCMOVNU   */
              dszRESERVED, O_DoDB,       /* DB-4           */
              dszFUCOMI,   O_ST_iST,     /* DB-5 FUCOMI    */
              dszFCOMI,    O_ST_iST,     /* DB-6 FCOMI     */
              dszRESERVED, O_DoDB }      /* DB-7           */

            };

typedef struct _ADDR {
    USHORT      type;
    USHORT      seg;
    ULONG       off;
    union {
        ULONG flat;
        ULONGLONG flat64;
    };
} ADDR, *PADDR;

#endif //_86DIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\cap.c ===
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ctype.h>
#include <stdio.h>
#include <windows.h>
#include "view.h"
#include "thread.h"
#include "dump.h"
#include "memory.h"
#include "cap.h"

BOOL
AddToCap(PCAPFILTER pCapFilter,
         DWORD dwAddress)
{
    DWORD dwIndexCounter;
    DWORD dwCounter;
    PDWORD pdwArray;
    DWORD dwEndRun;
    DWORD dwRunLength = 0;
    DWORD dwRun1Start;
    DWORD dwRun2Start;
    DWORD dwRepeatIndex = 0;
    DWORD dwBeginIndex;

    //
    // Take a pointer to the array
    //
    pdwArray = pCapFilter->dwArray;

    //
    // Increment cursor
    //
    if (0 == pCapFilter->dwCursor) {
       pdwArray[pCapFilter->dwCursor] = dwAddress;
       pCapFilter->dwCursor++;

       return TRUE;
    }

    if (pCapFilter->dwCursor >= CAP_BUFFER_SIZE) {
       //
       // Ran out of room in the buffer, slide everyone down
       //
       MoveMemory((PVOID)pdwArray, (PVOID)(pdwArray + 1), (CAP_BUFFER_SIZE - 1) * sizeof(DWORD));

       pCapFilter->dwCursor = CAP_BUFFER_SIZE - 1;
    }

    //
    // Add address to array
    //
    pdwArray[pCapFilter->dwCursor] = dwAddress;

    //
    // If we're at the initial level, scan for a repeat
    //
    if (0 == pCapFilter->dwIterationLevel) {
       //
       // Do a reverse search looking for patterns up to MAX_CAP_LEVEL
       //
       dwEndRun = pCapFilter->dwCursor - 1;

       if (dwEndRun < MAX_CAP_LEVEL) {
	  dwBeginIndex = 0;
       }
       else {
	  dwBeginIndex = (MAX_CAP_LEVEL - 1);
       }

       for (dwIndexCounter = dwEndRun; dwIndexCounter >= dwBeginIndex; dwIndexCounter--) {
           //
           // Check for overflow
           //
           if (dwIndexCounter > CAP_BUFFER_SIZE) {
              break;
           }

           if (pdwArray[dwIndexCounter] == dwAddress) {
              //
              // Verify the run exists
              //
              dwRun1Start = pCapFilter->dwCursor;
              dwRun2Start = dwIndexCounter;

              //
              // Find the distance for the start of this potential run
              //
              dwRunLength = pCapFilter->dwCursor - dwIndexCounter;

              //
              // If run length falls off the beginning of the array we can stop there
              //
              if ((dwRun2Start - dwRunLength + 1) > CAP_BUFFER_SIZE) {
                 //
                 // We overflowed which means we're done
                 //
                 dwRunLength = 0;

		 break;
              }

	      if (dwRunLength >= 1) {
                 //
                 // Compare it
                 //
                 for (dwCounter = dwRunLength; dwCounter > 0; dwCounter--) {
                     if (pdwArray[dwRun1Start-dwCounter+1] != pdwArray[dwRun2Start-dwCounter+1]) {
                        dwRunLength = 0;
                        break;
                     }
		 }

                 //
                 // Set the run length
                 //
		 if (0 != dwRunLength) {
                    pCapFilter->dwRunLength = dwRunLength;
		 }
             }
          }
       }

       dwRunLength = pCapFilter->dwRunLength;

       //
       // Set the run length if we found one, and shift the entire run to the beginning of the buffer
       //
       if (dwRunLength != 0) {
          //
          // Raise the iteration level
          //
          pCapFilter->dwIterationLevel++;

	  //
	  // Set the lock level
	  //
	  pCapFilter->dwIterationLock = 1 + ((pCapFilter->dwIterationLevel - 1) / pCapFilter->dwRunLength);
       }
    }
    else {
       //
       // Look for repeats and increment the iteration level
       //
       dwRunLength = pCapFilter->dwRunLength;
       dwRun1Start = pCapFilter->dwCursor;
       dwRun2Start = dwRun1Start - dwRunLength;

       //
       // Compare it
       //
       for (dwCounter = dwRunLength; dwCounter > 0; dwCounter--) {
           if (pdwArray[dwRun1Start-dwCounter+1] != pdwArray[dwRun2Start-dwCounter+1]) {
              dwRunLength = 0;

              break;
           }
       }

       if (dwRunLength != 0) {
          //
          // Raise the iteration level
          //
          pCapFilter->dwIterationLevel++;
	  pCapFilter->dwIterationLock = 1 + ((pCapFilter->dwIterationLevel - 1) / pCapFilter->dwRunLength);
       }
       else {
	  pCapFilter->dwIterationLock = 0;
          pCapFilter->dwIterationLevel = 0;
          pCapFilter->dwRunLength = 0;
       }
    }

    //
    // Move the cursor to the next position
    //
    pCapFilter->dwCursor++;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\cap.h ===
#ifndef _CAP_H_
#define _CAP_H_

//
// Constant declarations
//
#define MAX_CAP_LEVEL 0x10
#define MAX_CAP_ITERATION 0x03
#define CAP_BUFFER_SIZE MAX_CAP_LEVEL * 2

//
// Structure definitions
//
typedef struct _CAPFILTER
{
    DWORD dwIterationLock;
    DWORD dwIterationLevel;
    DWORD dwRunLength;
    DWORD dwCursor;
    DWORD dwArray[CAP_BUFFER_SIZE];
} CAPFILTER, *PCAPFILTER; 

//
// Function definitions
//
BOOL
AddToCap(PCAPFILTER pCapFilter,
         DWORD dwAddress);

#endif //_CAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ppr\ppr.c ===
/*  lpr.c - fancy paginator for laserprinters
 *
 *  Author: Mark Taylor
 *
 *  Modifications:
 *
 *      12/85   Mark Zbikowski  rewrite to work cleaner
 *      4/3/86  MZ              Single print jobs will advance page
 *      4/3/86  MZ              use tools.ini for default printer setup
 *      4/20/86 Mike Hanson     add banner, etc (add features to make like
 *                              lpr from PS, extensively reorganized, etc)
 *      6/6/86  Jay Sipelstein  added S and L options to printer desc.
 *                              Trim trailing blanks and blank lines.
 *                              Set mode before raw printing.
 *      7/8/86  Byron Bishop    Add -q to cause print queue to be printed.
 *                              Fixed bug so -# and -e flags take priority
 *                              over default settings.  Runs of blanks
 *                              replaced by escape sequences to reduce
 *                              file size.
 *      8/31/86 Craig Wittenberg Added support for PostScript.  Used the VMI
 *                              on the LaserJet instead of line/inch to get 62
 *                              lines on one page (two for header).  Cleaned
 *                              up iLine (now rowLine) and indentation.
 *      10/10/86 John Rae-Grant Added -g flag to allow gutter in portrait mode.
 *                              $USER can now be a list of directories to
 *                              search for tools.ini in. Default printer can
 *                              be specified in tools.ini file.  Modified
 *                              landscape mode page numbering to avoid three
 *                              hole punch obliteration.
 *      1/27/87 Craig Wittenberg Cleaned up whole program; no change in
 *                              functionality.
 *      1/28/87 Thom Landsberger  Added CB and CZ (=default) flags to the LJ
 *                              printer description to support the 'Z' font
 *                              cartridge in landscape mode
 *      3/23/87 Thom Landsberger  Port to Xenix 286 and 68k;  environment
 *                              setting of parameters accepted as default
 *                              and with higher priority than tools.ini/.pprrc;
 *                              implemented -m, -M, -c command switches;
 *                              restructured command interpretation.
 *      4/10/87 Craig Wittenberg  interrupt signal ignored if that is the
 *                              status when ppr is started
 *      4/14/87 Thom Landsberger  only pure digit strings accepted as
 *                              numeric command line arguments
 *      6/05/87 Thom Landsberger  double sided printing on HP LJ 2000;
 *                              '/' no switch character on Xenix;
 *                              'ppr -q -' now does print from stdin.
 *      7/5/87  Craig Wittenberg changed fDuplex? names to f?Duplex so they
 *                              compile in 68k Xenix.  Invoked ftp with command
 *                              line arguments rather than printing the commands
 *                              to stdin.  -t now removes label (used to require
 *                              -m "").
 *
 *                              Ppr reads /etc/default/ppr if there is not
 *                              $HOME/.pprrc.  Duplex printing now does not
 *                              print on the back of the banner page (even if
 *                              not raw).  Added -s flag: disables messages
 *                              which indicate ppr's progress.  Changed the PS
 *                              setup to avoid VMErrors.  Allowed the default
 *                              printer in the tools.ini/.pprrc file to have
 *                              options (e.g. default=lpt1, LJ L).  Changed the
 *                              default printer on Xenix from net9 to net.
 *
 *      ~8/1/87 Ralph Ryan      Ported to OS/2 LanManager
 *
 *     11/24/87 Craig Wittenberg Rearranged sources - mostly to isloate the OS
 *                              specific network routines in lplow.c
 *                              Ppr now uses clem as the transfer machine for
 *                              DOS print jobs when /usr/eu/bin/ppr is not
 *                              present (indicating a machine in another
 *                              division).
 *
 *      12/2/87 Alan Bauer      Version 2.5
 *                              Final porting to OS/2 LAN Manager.  Mainly
 *                              polished up network routines to work properly
 *                              Released to OS/2 people, DOSENV, NEWENV, and
 *                              new 68K version.
 *
 *      3/17/88 Alan Bauer      Version 2.6
 *                              Fixed so that the username is still printed in
 *                              lower left corner of the file listing when the
 *                              "no banner" option is specified (ppr -b0).
 *                              Ppr -? now prints to stdout rather than stderr.
 *                              Now supports ppr -q for OS/2.
 *
 *      4/04/88 Alan Bauer      Version 2.7
 *                              Added -c<n> option to print <n> copies of the
 *                              specified files.
 *                              Seperates large print jobs into roughly 100K
 *                              amounts.
 *                              Better feed back on PRINTING progress.
 *                              Fixed so that an empty password is now passed to
 *                              mkalias correctly (Xenix 386 version).
 *                              Now map ppr -p "xenix name" to
 *                                    "mkalias name name printing [password]".
 *                              Errors opening input files no longer abort; just
 *                              go on to the next file.
 *
 *      4/05/88 Alan Bauer      Version 2.71
 *                              Fixed problem with last file to be printed
 *                              putting the current print job over 100K,
 *                              therefore causing new print job to be performed
 *                              (with no more files to be printed).
 *
 *      4/13/88 Alan Bauer      Version 2.8
 *                              Added ability to specify options in TOOLS.INI
 *                              file.
 *
 *      5/19/88 Alan Bauer      Version 2.81
 *                              Fixed General Protection Fault in OS/2 dealing
 *                              with login usernames which are more than 12
 *                              characters long.
 *
 *      6/20/88 Alan Bauer      Version 2.82
 *                              Fixed LANMAN error message handling problems
 *                              and a bug where ppr failed if redirection to
 *                              the same printer as established in the environ-
 *                              ment variable was already set up.
 *
 *      3/3/89 Robert Hess      Version 2.9
 *                              Completely changed PostScript support.
 *                              Added 'PC' (Portrait Condensed) and 'PSF'
 *                              (PostScriptFile) printer specific switches.
 *
 *      3/22/89 Robert Hess     Version 2.10
 *                              Modifications to how 'FormFeed' was handled
 *                              for PostScript usage.
 *
 *      7/12/89 Robert Hess     Version 2.11
 *                              Fixed a bug that prevented lengthy Postscript
 *                              files to be printed.
 *
 *      9/14/89 Robert Hess     Version 2.12
 *                              Fixed -M option in PostScript code.
 *                              Fixed the 'opts=<option>' parsing from
 *                              TOOLS.INI (wasn't allowing leading spaces)
 *
 *      10/6/89 Robert Hess     Version 2.12b
 *                              Minor fix, repaired linking to include
 *                              SetArgV.OBJ (to automatically expand
 *                              wildcards in filenames - ooops!), and
 *                              added error handling to the '-q' command.
 *
 *      10/20/89 Robert Hess    Version 2.13
 *                              Date and time of *FILE* is now printed at
 *                              the bottom of the page for PostScript.
 *                              (...ooops...)
 *
 *      12/06/89 Robert Hess    Version 2.14
 *                              Added switches -v (verify, for debugging),
 *                              and -w (column width).
 *
 *      4/9/90 Scott Means      Version 2.15
 *                              Support of non-printable IBM characters and
 *                              added progress indicator.
 *
 *      4/18/90 Robert Hess     Version 2.2
 *                              Re-Wrote postscript header code to allow
 *                              full sensing of actual printer area, and
 *                              corrected several bugs in old header.
 *                              Fixed 'pathname' for network drives
 *                              Fixed '-t' switch for Postscript mode
 *                              Added 'psuedo' printer name support.
 *
 *      6/15/90 Robert Hess     Version 2.3
 *                              Added better implementation of 'extended
 *                              ascii' mode. Added more debugging code
 *                              for network usage. Added R and C printer
 *                              switches to better support odd sized paper.
 *                              Improved 'usage' text.
 *                              Switched to using some TOOLSVR api calls.
 *                              General cleanup and bug fixes.
 *                              Enlisted into \\ToolSvr\Build project.
 *
 *      7/26/90 Robert Hess     Version 2.3a
 *                              Fixed a couple bugs. Added '-l' option for
 *                              listing out contents of TOOLS.INI. Final
 *                              cleanup prior to general release.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <process.h>
#include <signal.h>
#include <ctype.h>
#include <windows.h>
#include <tools.h>
#include "lpr.h"


/* 175 columns:
 *                        0   1                    174
 *  single page:        <bar> 173 columns of text <bar>
 *                        0   1               86   87  88              173 174
 *  double page:        <bar> 86 columns of text <bar> 86 columns of text <bar>
 */

long        lcbOutLPR = 0l;             //  total amount printed in this job
int         cCol = 0;                   //  number of columns being displayed
int         cColCom = 0;                /* number of columns as specified in
                                           command line.                      */
int         colTabCom = 0;              /* number of spaces per tab specified
                                           in command line.   Number of spaces
                                           per tab, colTab, is declared in
                                           lpfile.c                           */
int         colGutter = 0;              //  number of spaces in gutter
int         colText   = 0;              //  column where text starts
int         cCopies = 1;                //  number of copies to print
int         colWidth;                   //  printable spaces in each column

int         defWidth = 0; //  <- NEW... to override colWidth calculation

int         colMac = colLJMax;          //  maximum columns on a page
int         rowMac = rowLJMax;          //  maximum rows on a page
int         rowPage;                    /* number of printable lines per page
                                           including header on top            */

char *aszSymSet[] = {   // supported Laserjet symbol sets
    "\033&l1o5.8C\033(0U\033(s0p16.67h8.5v0T",
    "\033&l1o5.8C\033(8U\033(s0p16.67h8.5v0T",
    "\033&l1o5.8C\033(10U\033(s0p16.67h8.5v0T"
};

BOOL        fNumber = FALSE;            //  TRUE => show line numbers
BOOL        fDelete = FALSE;            //  TRUE => delete file after printing
BOOL        fRaw = FALSE;               //  TRUE => print in raw mode
BOOL        fBorder = TRUE;             //  TRUE => print borders
BOOL        fLabel = TRUE;              //  TRUE => print page heading
BOOL        fLaser = TRUE;              //  TRUE => print on an HP LaserJet
BOOL        fPostScript = FALSE;        //  TRUE => print on postscript printer

BOOL        fPSF = FALSE;               //  TRUE => Use alternate PS Header
char        szPSF[MAX_PATH] = "";      //  pathname of alternate PS Header
BOOL        fPCondensed = FALSE;        //  TRUE => Condensed portrait mode PS

BOOL        fConfidential = FALSE;      //  TRUE => stamp pages and banner
BOOL        fVDuplex = FALSE;           //  TRUE => double sided, vertical bind
BOOL        fHDuplex = FALSE;           //  TRUE => ditto, but horizontal bind
BOOL        fSilent = FALSE;            //  TRUE => no messages
int         cBanner = -1;               //  # of banners; <0 only 1 group
char        chBanner = ' ';             //  used to form banner characters
char        *szBanner = NULL;           //  banner string, use fname if NULL
char        *szStamp = NULL;            //  additional label put on each page
BOOL        fForceFF = TRUE;            //  TRUE => end at top of page
BOOL        fPortrait = FALSE;          //  TRUE => print in portrait mode
BOOL        fQueue = FALSE;             //  TRUE => list print queue
USHORT      usSymSet = 0;               //  symbol set to use on Laserjet
                                        //  FALSE => select Roman-8 symbol set
USHORT      usCodePage = 0;             //  0 = convert extended ascii to '.'
BOOL        fVerify = FALSE; //  TRUE => dump out data on what we are doing
BOOL        fList   = FALSE; //  TRUE => use with fVerify to prevent printing

char        szPass[cchArgMax] = "";

static void Usage(void);
static void DoArgs(int *, char **[]);
void Abort(void);
void DoIniOptions(void);


int __cdecl main(argc, argv)
int argc;
char **argv;
    {
    intptr_t err;
    int iCopies;

#ifdef notdefined
    if (signal(SIGINT, SIG_IGN) != SIG_IGN)
        //  if not ignored upon startup, set our abort handler
        signal(SIGINT, (void (_cdecl *)(int))Abort);
#endif

//  hack to get verify and list to work *before* command line is parsed
    ConvertAppToOem( argc, argv );
    if( argc > 1 ) {
        if (argv[1][1] == 'v') {
            fVerify = TRUE;
        }
        if (argv[1][1] == 'l') {
            fList   = TRUE;
        }
        if (fVerify) {
            fprintf (stdout, "\n");
        }
    }

    DoIniOptions();

    if (fVerify) {
        fprintf (stdout, "Seen on Command Line:\n");
    }

    DoArgs(&argc, &argv);
    SetupPrinter();
    SetupRedir();

    //  -------------- modifications to switches and precalculated values

    //  don't allow guttering in landscape mode
    if (!fPortrait)
        colGutter = 0;

    //  set global for start of text
    colText = colGutter + (fNumber ? cchLNMax : 0);

    //  set # columns if set in command line.
    if (cColCom)
        cCol = cColCom;
    else if (cCol == 0)
        cCol = fPortrait ? 1 : 2;

    //  set # of spaces per tab if set in command line.
    if (colTabCom)
        colTab = colTabCom;

    colWidth = colMac;
    if (fPostScript && fPCondensed) {
        colWidth = colMac *= 2;
    }

    if (defWidth > 0) colWidth = defWidth;

    if (fLaser && usCodePage == 850) {
        usSymSet = BEGINLANDIBMPC; // for the LaserJet
    }

    if (cCol != 1) {
        //  more than one column: divide into separate columns with divider
        colWidth = (colMac-1) / cCol - 1;
        if (defWidth > 0) colWidth = defWidth;
        colMac = (colWidth + 1) * cCol + 1;
    }

    //  rowPage includes border line(s) at top of page
    rowPage = rowMac;
    if (fBorder || fLabel) {
        if (!fLaser && !fPostScript && fPortrait) {
            //  same bottom margin as old Xenix ppr
            rowPage -= 5;
        } else {
            //  don't print on bottom line
            rowPage -= 1;
        }
    }

    if (!fLaser && !fPostScript && cBanner == -1) {
        //  line printer for which the default banner setup is required
        cBanner = -2;
    }

    //  ----------------- end modification of switches

    if (fVerify) fprintf (stdout, "\n"); //  just to clean things up a little
    fprintf(stdout, "PPR version: "VERSION"\n");
    fprintf(stdout, "----------------------------------------------------------------------------\n");

    if (argc == 0) {
        /* No file names were listed... assume user wants <stdin> */
        if (!fQueue && !fList) {
            //  print stdin
            fprintf (stdout, "Printing from: <stdin> Press <Ctrl-Z> to end.\n");
            MyOpenPrinter();
            FileOut("");
            MyClosePrinter();
        }
    } else {
        //  print file(s)
        MyOpenPrinter();
        while (argc) {
            //  print more copies if wanted
            for(iCopies = 1; iCopies <= cCopies; iCopies++) {
                FileOut(*argv);

                //  end this print job if more than 100K has been printed
                //  thus far.  Then start next print job.
                if (lcbOutLPR > 100000 && argc != 1) {
                    lcbOutLPR = 0l;
                    MyClosePrinter();
                    fFirstFile = TRUE;
                    MyOpenPrinter();          //  ready to start next job
                }
            }
            argc--;
            argv++;
        }
        MyClosePrinter();
    }

    /* if user wants to print queue, spawn a process to do the printing.
       The process will inherit the current environment including the
       redirection of szPName.
    */
    if (fQueue) {
        fprintf (stdout, "[Net Print %s]:\n", szNet);
        err = _spawnlp(P_WAIT,"net","net","print",szNet,NULL);
        if (err)
            if (err == -1)
                fprintf (stdout, "- Error : Unable to Spawn Queue Status Request -\n");
            else
                fprintf (stdout, "- Error Returned from Queue Status Request: %d - \n", err);
    }
    ResetRedir();
    return 0;
} /* main */




void Abort()
/*  SIGINT handler to abort printing gracefully
 *
 *      Warning: Never returns (exits via Fatal).
 */
{
    Fatal("terminated by user", NULL);
} /* Abort */




static void Usage()
{
    fprintf(stdout, "PPR version: "VERSION"   by: "ANALYST"\n");
    fprintf(stdout, "Usage: ppr [-switches] files(s)\n");
    fprintf(stdout, "-<digit>   :Print in columns (1-9)    -n         : Print line numbers\n");
    fprintf(stdout, "-b <n>     :Print <n> banners         -o <n>     : Offset <n> for gutter\n");
    fprintf(stdout, "-c <n>     :Print <n> copies          -q         : List print queue status\n");
    fprintf(stdout, "-D         :Delete file after print   -s         : Supress progress message\n");
    fprintf(stdout, "-e <n>     :Expand tabs to <n>        -t         : Supress page headers\n");
    fprintf(stdout, "-f         :NO formfeed at end        -r         : Print in raw mode\n");
    fprintf(stdout, "-h <string>:Use <string> for header   -v         : Verbose (for debugging)\n");
    fprintf(stdout, "-m <string>:Stamp <string> on page    -w <n>     : Page width in characters\n");
    fprintf(stdout, "-M         :\"Microsoft Confidential\"  -p <string>: Printer description\n");
    fprintf(stdout, "\n");
    fprintf(stdout, "Printer Description: ppr -p \"<port>,<type> <options>,<columns>,<tabstops>\"\n");
    fprintf(stdout, "Types & Options:\n");
    fprintf(stdout, "LP        : Line Printer              DV        : Duplex printing vert.\n");
    fprintf(stdout, "LJ        : HPLaserJet                DH        : Duplex printing horz.\n");
    fprintf(stdout, "PS        : PostScript                F         : No force form feed\n");
    fprintf(stdout, "PSF <file>: PostScript w/header       L         : Landscape\n");
    fprintf(stdout, "CZ        : 'Z' Cartridge             P         : Portrait\n");
    fprintf(stdout, "CB        : 'B' Cartridge             PC        : Portrait Condensed\n");
    fprintf(stdout, "CP <n>    : Set CodePage              S         : Force form feed\n");
    fprintf(stdout, "EA        : Set CodePage to 850       #         : Number of rows\n");
    fprintf(stdout, "See PPR.HLP for further information and usage descriptions.\n");

    exit(1);
}



//  VARARGS
void __cdecl Fatal(char *sz, ...)
{
    va_list args;

    va_start(args, sz);
    fprintf(stderr, "ppr: ");
    vfprintf(stderr, sz, args);
    fprintf(stderr, "\n");
    va_end(args);
    MyClosePrinter();
    ResetRedir();
    exit(1);
}


void __cdecl Error(char *sz, ...)
{
    va_list args;

    va_start(args, sz);
    fprintf(stderr, "ppr: ");
    vfprintf(stderr, sz, args);
    fprintf(stderr, "\n");
    va_end(args);
}


char * SzGetArg(ppch, pargc, pargv)
char **ppch;
int *pargc;
char **pargv[];
//  return the string following the current switch; no whitespace required
        {
        char *tmp;
        if (*(*ppch+1))
                {
                (*ppch)++;
                tmp = *ppch;
                *ppch += strlen(*ppch) - 1;
                //  return(*ppch);
                return( tmp );
                }
        else
                {
                (*pargv)++;
                if (--*pargc)
                        return((*pargv)[0]);
                else
                        return(NULL);
                }
        }




int WGetArg(ppch, pargc, pargv, nDefault, szXpl)
//  return the number following the current switch; no whitespace required
char **ppch;
int *pargc;
char **pargv[];
int nDefault;
char * szXpl;
        {
        int nRet;
        char chSwitch;

        chSwitch = **ppch;
        if (*(*ppch+1))
                {
                nRet = atoi(++*ppch);
                *ppch += strlen(*ppch) - 1;
                }
        else
                {
                if ((*pargc>1) &&
                    strlen((*pargv)[1]) == strspn((*pargv)[1], "0123456789") )
                        {
                        (*pargc)--;
                        nRet = atoi((++*pargv)[0]);
                        }
                else
                        nRet = nDefault;
                }

        if (nRet<0)
                {
                Fatal("negative %s (switch %c)", szXpl, chSwitch);
                return 0;
                }
        else
                return(nRet);
        }


void DoIniOptions() //  Get any options from the TOOLS.INI file (OPTS=...)
        {
#define cargsMax 25
    FILE *pfile;
    char *szT;
    char rgbSW[cchArgMax];
    int argc;
    char *pchSp;
    char *argvT[cargsMax];          //  structure to build to be like argv
    char **pargvT = argvT;

//    if ((pfile = swopen()) != NULL) {
    if ((pfile = swopen("$INIT:Tools.INI", "ppr")) != NULL) {
        /* 'PPR' tag was found in 'TOOLS.INI' */
        if (fVerify || fList) {
            fprintf (stdout, "TOOLS.INI contains the following entries:\n");
            fprintf (stdout, "[ppr]\n");
        }
        while (swread(rgbSW, cchArgMax, pfile) != 0) {
            /* a 'switch line' was found in the file */
            szT = rgbSW + strspn(rgbSW, " \t"); // skip spaces and tabs
            if (fVerify || fList) {
                fprintf (stdout, "    %s \n", szT);
            }
            //  an entry "opts=<options>" will cause the options
            //  to be set from the parameter file.
            if (_strnicmp(szT, OPTS, strlen(OPTS)) == 0) {

                if ((szT = strchr(szT, '=')) != NULL) {

                    szT++;  //  advance past '='
                    while (szT[0] == ' ') szT++; //  advance past beginning spaces
                    if(*szT) {
                        argvT[0] = 0;
                        for (argc = 1; argc < cargsMax && szT[0] != '\0'; argc++)
                                {
                            argvT[argc] = szT;
                            pchSp = strchr(szT, ' ');
                            if (pchSp == '\0')
                                    break;
                            *pchSp = 0;
                            szT = pchSp + 1;
                            while (szT[0] == ' ') {
                                    szT++;
                            }
                        }
                        argc++;
                        argvT[argc] = '\0';
                        DoArgs(&argc, &pargvT);
                    }
                }
            }
        }
        swclose(pfile);
    }
}


static void DoArgs(pargc, pargv) //  Parse the argument string.
int * pargc;
char **pargv[];
    {
    int argc, vArgc; //  vArgc - for verify mode
    char **argv, **vArgv;
    char *p;

    argc = vArgc = *pargc;
    argv = vArgv = *pargv;

    argc--;
    argv++;
    p = argv[0];

    while (argc && (*p == '/' || (*p=='-' && *(p+1)!='\0')))
        {
        while (*++p)
            {
            switch (tolower(*p))
                {

                case 'a':
                    chBanner = *++p;
                    break;

                case 'b':
                    cBanner = WGetArg(&p, &argc, &argv, 1, "number of banners");
                    break;

                case 'c':
                    cCopies= WGetArg(&p, &argc, &argv, 1, "number of copies");
                    break;

                case 'd':
                case 'D':
                    if (*p=='D')  // <-- since we did a 'tolower'
                        fDelete = TRUE;
                    break;

                case 'e':
                    colTabCom = WGetArg(&p, &argc, &argv, 8, "tabs");
                    break;

                case 'f':
                    fForceFF = FALSE;
                    break;

                case 'g':
                case 'o':
                    colGutter = WGetArg(&p, &argc, &argv, colGutDef, "offset");
                    break;

                case 'h':
                    szBanner = SzGetArg(&p, &argc, &argv);
                    break;

                case 'l':
                    fList = TRUE;
                    break;

                case 'm':
                case 'M':
                    fBorder = TRUE;
                    fLabel = TRUE;
                    if (*p=='M') // <-- since we did a 'tolower'
                        fConfidential = TRUE;
                    else
                        szStamp = SzGetArg(&p, &argc, &argv);
                    break;

                case 'n':
                    fNumber = TRUE;
                    break;

                case 'p':
                    szPDesc = SzGetArg(&p, &argc, &argv);
                    break;

                case 'q':     //  Enable print of queue
                    fQueue = TRUE;
                    break;
                case 'r':

                    fRaw = TRUE;
                    break;

                case 's':
                    fSilent = TRUE;
                    break;

                case 't':
                    if (!fConfidential && szStamp==NULL)
                        {
                        fBorder = FALSE;
                        fLabel  = FALSE;
                        }
                    break;

                case 'v':
                    fVerify = TRUE;
                    break;

                case 'w':
                    defWidth = WGetArg(&p, &argc, &argv, 80, "Width of column");
                    break;

                case 'x':
                    usCodePage = 850;
                    break;

                case '1': case '2':
                case '3': case '4':
                case '5': case '6':
                case '7': case '8':
                case '9':
                    cColCom = *p - '0';
                    break;

                default :
                    Error("invalid switch: %s\n", p);
                case '?':
                case 'z':
                    Usage();
                    break;
                }
            }
        argc--;
        argv++;
        p = argv[0];
        }

    if (fVerify) {
        vArgv++; //  skip over program name, or null entry
        while (--vArgc) fprintf (stdout, "%s ", *(vArgv++));
        fprintf (stdout, "\n\n");
    }

    *pargv = argv;
    *pargc = argc;
    }



void DoOptSz(szOpt)
/*   scan and handle printer options
 *
 *   Entry:     szOpt - string containing printer options
 *
 *   Exit:      global flags set according to printer options
 *
 *   An option string has the format:
 *     [, [(LJ [P] [L] [CB|CZ] [D|DV|DH]) | (LP [# lines]) | (PS [P] [L])] [F] [S] [, [tabstop] [, [# columns]]]]
 *
 *   Note: Although this is called by the lpprint module,
 *         It is here because it deals with command line arguments
 *         and setting the global print control flags.
 */
register char * szOpt;
    {
    char szBuf[cchArgMax];
    BOOL fLJ = FALSE;
    BOOL fLP = FALSE;
    BOOL fPS = FALSE;

    if (*szOpt++ == ',')
        {
        while (*szOpt != ',' && *szOpt)
            {
            szOpt = SzGetSzSz(szOpt, szBuf);

/* First the different printer types*/

            // Laser Jet
            if (_strcmpi(szBuf, "lj") == 0 && !fLP && !fPS)
                {
                fLJ       = TRUE;
                fLaser    = TRUE;
                fPostScript = FALSE;
                //  don't set border here so -t works
                fPortrait = FALSE;
                colMac    = colLJMax;
                rowMac    = rowLJMax;
                }

            // Line Printer
            else if (_strcmpi(szBuf, "lp") == 0 && !fLJ && !fPS)
                {
                fLP       = TRUE;
                fLaser    = FALSE;
                fPostScript = FALSE;
                fBorder   = FALSE;
                fPortrait = TRUE;
                colMac    = colLPMax;
                rowMac    = rowLPMax;
                }

            // PostScript with custom header
            else if (_strcmpi(szBuf, "psf") == 0 && !fLP && !fLJ)
                {
                fPS       = TRUE;
                fLaser    = FALSE;
                fPostScript = TRUE;
                fPortrait = FALSE;
                fPCondensed = FALSE;
                colMac    = colPSMax;
                rowMac    = rowPSMax;
                fPSF  = TRUE;
                szOpt = SzGetSzSz(szOpt, szPSF);
                }

            // PostScript
            else if (_strcmpi(szBuf, "ps") == 0 && !fLP && !fLJ)
                {
                fPS       = TRUE;
                fLaser    = FALSE;
                fPostScript = TRUE;
                //  don't set border here so -t works
                fPortrait = FALSE;
                fPCondensed = FALSE;
                colMac    = colPSMax;
                rowMac    = rowPSMax;
                }

/* Now the modifiers */

            // Column width to print in
            else if (_strcmpi(szBuf, "c") == 0) {
                szOpt = SzGetSzSz(szOpt, szBuf);
                if (atoi(szBuf) != 0) {
                    defWidth = atoi(szBuf);
                } else {
                        Fatal ("Non-Numeric Columns specified.");
                }
            }

            // LaserJet with the 'B' cartridge
            else if (_strcmpi(szBuf, "cb") == 0 && fLJ)
                usSymSet = BEGINLANDROMAN8;

            // LaserJet emulation of 'IBM' text
            else if (_strcmpi(szBuf, "ci") == 0 && fLJ) {
                usSymSet = BEGINLANDIBMPC; // for the LaserJet
                usCodePage = 850;
            }

            // Code Page specification
            else if (_strcmpi(szBuf, "cp") == 0) {
                szOpt = SzGetSzSz(szOpt, szBuf);
                if (atoi(szBuf) != 0) {
                    usCodePage = (USHORT)atoi(szBuf);
                } else {
                        Fatal ("Non-Numeric CodePage specified.");
                }

            }

            // LaserJet with the 'Z' cartridge
            else if (_strcmpi(szBuf, "cz") == 0 && fLJ)
                usSymSet = BEGINLANDUSASCII;

            // Prep for double sided printing, binding on long edge
            else if ((_strcmpi(szBuf, "d") == 0 || _strcmpi(szBuf, "dv") == 0))
                fVDuplex  = TRUE;

            // Prep for double sided printing, binding on short edge
            else if (_strcmpi(szBuf, "dh") == 0)
                fHDuplex  = TRUE;

            // Extended Ascii printing - shortcut to CP 850
            else if (_strcmpi(szBuf, "ea") == 0) {
                usCodePage = 850;
            }

            // Turn off forced form feed
            else if (_strcmpi(szBuf, "f") == 0)
                fForceFF  = FALSE;

            // Landscape
            else if (_strcmpi(szBuf, "l") == 0 && (fLJ || fPS))
                {
                fPortrait = FALSE;
                colMac    = fLJ ? colLJMax : colPSMax;
                }

            // Portrait
            else if (_strcmpi(szBuf, "p") == 0 && (fLJ || fPS))
                {
                fPortrait = TRUE;
                fBorder   = FALSE;
                colMac    = fLJ ? colLJPortMax : colPSPortMax;
                }

            // Portrait Condensed
            else if (_strcmpi(szBuf, "pc") == 0 && (fLJ || fPS))
                {
                fPortrait = TRUE;
                fPCondensed = TRUE;
                fBorder   = TRUE;
                colMac    = fLJ ? colLJPortMax : colPSPortMax;
                if (cColCom == 0) cColCom   = 2;
                }

            // Number of rows (same as just # by itself, but more descriptive)
            else if (_strcmpi(szBuf, "r") == 0) {
                szOpt = SzGetSzSz(szOpt, szBuf);
                if (atoi(szBuf) != 0) {
                    rowMac = atoi(szBuf);
                    if (rowMac > rowMax)
                        Fatal ("Too many rows (%d) specified.", rowMac);
                } else {
                        Fatal ("Non-Numeric Rows specified.");
                }
            }

            // Force Form Feed
            else if (_strcmpi(szBuf, "s") == 0)
                fForceFF  = TRUE;

            // Number of rows
            else if (isdigit(szBuf[0]) && fLP) {
                rowMac    = atoi(szBuf);
                if (rowMac > rowMax)
                        Fatal("page size %d to long", rowMac);
            }

            else if (_strcmpi(szBuf, "") == 0)
                //  empty string
                ;
            else
                Fatal("unrecognized printer type option %s", szBuf);
            }

/* After the first comma - Tab stop specification */

        if (*szOpt++ == ',')
            {                   //  tabstop
            szOpt = SzGetSzSz(szOpt, szBuf);

            if (isdigit(szBuf[0]))
                colTab = atoi(szBuf);
            else if (szBuf[0] != '\0')
                Fatal("tabstop %s is not a number", szBuf);

/* After the second comma - Column specification (1-9) */

            if (*szOpt++ == ',')
                {               //  # columns (1 - 9)
                szOpt = SzGetSzSz(szOpt, szBuf);

                if (isdigit(szBuf[0]))          //  0 means default # col
                    cCol = szBuf[0] - '0';
                else if (szBuf[0] != '\0')
                    Fatal("number columns (%s) must be digit 1-9",szBuf);
                }
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\clevel.h ===
#ifndef _CLEVEL_H_
#define _CLEVEL_H_

//
// Constant declarations
//

//
// Structure definitions
//
typedef struct _CALLRETSTUB
{
    CHAR PUSHDWORD[5];          //push xxxxxxxx (68 dword)
    CHAR JMPDWORD[6];           //jmp dword ptr [xxxxxxxx] (ff 25 dword address)
} CALLRETSTUB, *PCALLRETSTUB;

typedef struct _FIXUPRETURN
{
   BYTE  PUSHAD;                //pushad   (60)
   BYTE  PUSHFD;                //pushfd   (9c)
   BYTE  PUSHDWORDESPPLUS24[4]; //push dword ptr [esp+24] (ff 74 24 24)
   BYTE  CALLROUTINE[6];        //call [address] (ff15 dword address)
   BYTE  MOVESPPLUS24EAX[4];    //mov [esp+0x24],eax (89 44 24 24)
   BYTE  POPFD;                 //popfd   (9d)
   BYTE  POPAD;                 //popad (61)
   BYTE  RET;                   //ret (c3)
} FIXUPRETURN, *PFIXUPRETURN;

typedef struct _CALLERINFO
{
   DWORD dwIdentifier;
   DWORD dwCallLevel;
   PVOID pCallRetStub;
   PVOID pReturn;
   struct _CALLERINFO *pNextChain;
} CALLERINFO, *PCALLERINFO;

//
// Function definitions
//
BOOL
PushCaller(PVOID ptfInfo,
           PVOID pEsp); 

PVOID
PopCaller(DWORD dwIdentifier);

PCALLRETSTUB
AllocateReturnStub(PVOID ptfInfo);

#endif //_CLEVEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\disasm.h ===
#ifndef _DISASM_H_
#define _DISASM_H_

//
// Constant declarations
//

//
// Structure definitions
//

//
// Function definitions
//
extern
DWORD 
GetInstructionLengthFromAddress(PVOID paddr);

#endif //_DISASM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\except.h ===
#ifndef _EXCEPT_H_
#define _EXCEPT_H_

//
// Constant declarations
//
typedef PVOID     (*pfnRtlAddVectoredExceptionHandler)(ULONG FirstHandler, 
                                                       PVOID VectoredHandler);

typedef ULONG     (*pfnRtlRemoveVectoredExceptionHandler)(PVOID VectoredHandlerHandle);

typedef VOID      (*pfnExContinue)(PCONTEXT pContext);

#define SET_CONTEXT() {_asm int 3 \
                       _asm int 3 \
                       _asm ret \
                       _asm ret \
                       _asm ret }

//
// Structure definitions
//

//
// Function definitions
//
LONG 
ExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);

BOOL
HookUnchainableExceptionFilter(VOID);

VOID
Win9XExceptionDispatcher(struct _EXCEPTION_POINTERS *ExceptionInfo);

#endif //_EXCEPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\filter.h ===
#ifndef _FILTER_H_
#define _FILTER_H_

//
// Constant declarations
//

//
// Structure definitions
//
typedef struct _MODULEFILTER
{
   DWORD dwModuleStart;      // Starting address of the module to filter
   DWORD dwModuleEnd;        // Ending address of the module to filter  
   CHAR  szModuleName[64];
   struct _MODULEFILTER *pNextFilter;    // Used to iterate the module filter normally
} MODULEFILTER, *PMODULEFILTER;

//
// Function definitions
//
BOOL
InitializeFilterList(VOID);

BOOL
AddModuleToFilterList(CHAR *pszModuleName, 
                      DWORD dwStartAddress, 
                      DWORD dwEndAddress,
                      BOOL bLateBound);

BOOL
IsAddressFiltered(DWORD dwAddress);

VOID
RefreshFilterList(VOID);

#endif //_FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\dump.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "view.h"
#include "dump.h"
#include "memory.h"

static CRITICAL_SECTION tCritSec;
static PBYTE pDumpBuffer;
static DWORD dwDumpBufferSize;
static HANDLE hDump = INVALID_HANDLE_VALUE;

BOOL
InitializeDumpData(VOID)
{
    DWORD dwCounter;
    DWORD dwResult;

    InitializeCriticalSection(&tCritSec);

    //
    // Allocate memory for the logging
    //
    pDumpBuffer = AllocMem(DUMP_BUFFER_SIZE);
    if (0 == pDumpBuffer) {
       return FALSE;
    }

    dwDumpBufferSize = 0;

    //
    // Get our file ready for dumping
    //
    hDump = CreateFileA(DUMP_LOG_NAME,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        0,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        0);
    if (INVALID_HANDLE_VALUE == hDump) {
       return FALSE;
    }

    return TRUE;
}

BOOL
AddToDump(PBYTE pBuffer,
          DWORD dwLength,
          BOOL bFlushImmediate)
{
    BOOL bResult;

    EnterCriticalSection(&tCritSec);

    //
    // See if our write would cause overflow
    //
    if (TRUE == bFlushImmediate ||
        (dwDumpBufferSize + dwLength) >= DUMP_BUFFER_SIZE) {

       //
       // If we're doing an immediate flush, do the memory copy and buffer update
       //
       if (TRUE == bFlushImmediate) {
          MoveMemory((PVOID)(pDumpBuffer + dwDumpBufferSize), pBuffer, dwLength);    

          dwDumpBufferSize += dwLength;
       }

       //
       // Do the flush
       //
       bResult = FlushBuffer();
       if (FALSE == bResult) {
          return FALSE;
       }

       dwDumpBufferSize = 0;
    }

    if (FALSE == bFlushImmediate) {
       MoveMemory((PVOID)(pDumpBuffer + dwDumpBufferSize), pBuffer, dwLength);    

       dwDumpBufferSize += dwLength;
    }

    LeaveCriticalSection(&tCritSec);

    return TRUE;
}          

VOID
FlushForTermination(VOID)
{
    DWORD dwCounter;

    EnterCriticalSection(&tCritSec);

    //
    // Flush the buffer
    //
    FlushBuffer();

    //
    // Flush the buffer
    //
    FlushFileBuffers(hDump);

    //
    // Close the file dump handle
    //
    if (INVALID_HANDLE_VALUE != hDump) {
       CloseHandle(hDump);
       hDump = INVALID_HANDLE_VALUE;
    }

    LeaveCriticalSection(&tCritSec);
}

BOOL
FlushBuffer(VOID)
{
    BOOL bResult;
    DWORD dwBytesWritten;

    bResult = WriteFile(hDump,
                        pDumpBuffer,
                        dwDumpBufferSize,
                        &dwBytesWritten,
                        0);
    if (FALSE == bResult) {
       return FALSE;
    }

/*
    bResult = FlushFileBuffers(hDump);
    if (FALSE == bResult) {
       return FALSE;
    }
*/

    return TRUE;
}
 
BOOL
WriteThreadStart(DWORD dwThreadId,
                 DWORD dwStartAddress)
{
    THREADSTART threadStart;
    BOOL bResult = FALSE;

    threadStart.dwType = ThreadStartId;
    threadStart.dwThreadId = dwThreadId;
    threadStart.dwStartAddress = dwStartAddress;

    bResult = AddToDump((PVOID)&threadStart,
                        sizeof(THREADSTART),
                        FALSE);

    return bResult;    
}

BOOL
WriteExeFlow(DWORD dwThreadId,
             DWORD dwAddress,
             DWORD dwCallLevel)
{
    EXEFLOW exeFlow;
    BOOL bResult = FALSE;

    exeFlow.dwType = ExeFlowId;
    exeFlow.dwThreadId = dwThreadId;
    exeFlow.dwAddress = dwAddress;
    exeFlow.dwCallLevel = dwCallLevel;

    bResult = AddToDump((PVOID)&exeFlow,
                        sizeof(EXEFLOW),
                        FALSE);

    return bResult;    
}

BOOL
WriteDllInfo(CHAR *szDLL,
             DWORD dwBaseAddress,
             DWORD dwLength)
{
    DLLBASEINFO dllBaseInfo;
    BOOL bResult = FALSE;
    CHAR szFile[_MAX_FNAME];


    //
    // Trim off any directory information
    //
    _splitpath(szDLL, 0, 0, szFile, 0);

    strcpy(dllBaseInfo.szDLLName, szFile);
    dllBaseInfo.dwType = DllBaseInfoId;
    dllBaseInfo.dwBase = dwBaseAddress;
    dllBaseInfo.dwLength = dwLength;

    bResult = AddToDump((PVOID)&dllBaseInfo,
                        sizeof(DLLBASEINFO),
                        FALSE);

    return bResult;    
}

BOOL
WriteMapInfo(DWORD dwAddress,
             DWORD dwMaxMapLength)
{
    MAPINFO mapInfo;
    BOOL bResult = FALSE;

    mapInfo.dwType = MapInfoId;
    mapInfo.dwAddress = dwAddress;
    mapInfo.dwMaxMapLength = dwMaxMapLength;

    bResult = AddToDump((PVOID)&mapInfo,
                        sizeof(MAPINFO),
                        FALSE);

    return bResult;    
}

BOOL
WriteError(CHAR *szMessage)
{
    ERRORINFO errorInfo;
    BOOL bResult = FALSE;

    errorInfo.dwType = ErrorInfoId;
    strcpy(errorInfo.szMessage, szMessage);

    bResult = AddToDump((PVOID)&errorInfo,
                        sizeof(ERRORINFO),
                        TRUE);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\dump.h ===
#ifndef _DUMP_H_
#define _DUMP_H_

//
// Constant declarations
//
#define DUMP_BUFFER_SIZE 200 * 1024
#define DUMP_LOG_NAME "Profiler.dump"

typedef enum _DUMPTYPES
{
    ThreadStartId = 0,
    ExeFlowId,
    DllBaseInfoId,
    MapInfoId,
    ErrorInfoId,
} DUMPTYPES;

//
// Structure definitions
//
typedef struct _THREADSTART
{
    DUMPTYPES dwType;
    DWORD dwThreadId;
    DWORD dwStartAddress;
} THREADSTART, *PTHREADSTART;

typedef struct _EXEFLOW
{
    DUMPTYPES dwType;
    DWORD dwThreadId;
    DWORD dwAddress;
    DWORD dwCallLevel;
} EXEFLOW, *PEXEFLOW;

typedef struct _DLLBASEINFO
{
    DUMPTYPES dwType;
    DWORD dwBase;
    DWORD dwLength;
    CHAR  szDLLName[32];
} DLLBASEINFO, *PDLLBASEINFO;

typedef struct _MAPINFO
{
    DUMPTYPES dwType;
    DWORD dwAddress;
    DWORD dwMaxMapLength;
} MAPINFO, *PMAPINFO;

typedef struct _ERRORINFO
{
    DWORD dwType;
    CHAR szMessage[MAX_PATH];
} ERRORINFO, *PERRORINFO;

//
// Function definitions
//
BOOL
InitializeDumpData(VOID);

BOOL
AddToDump(PBYTE pBuffer,
          DWORD dwLength,
          BOOL bFlushImmediate);

BOOL
FlushBuffer(VOID);

VOID
FlushForTermination(VOID);

BOOL
WriteThreadStart(DWORD dwThreadId,
                 DWORD dwStartAddress);

BOOL
WriteExeFlow(DWORD dwThreadId,
             DWORD dwAddress,
             DWORD dwCallLevel);

BOOL
WriteDllInfo(CHAR *szDLL,
             DWORD dwBaseAddress,
             DWORD dwLength);

BOOL
WriteMapInfo(DWORD dwAddress,
             DWORD dwMaxMapLength);

BOOL
WriteError(CHAR *szMessage);

#endif //_DUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\except.c ===
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ctype.h>
#include <stdio.h>
#include <windows.h>
#include "profiler.h"
#include "view.h"
#include "thread.h"
#include "dump.h"
#include "except.h"
#include "memory.h"
#include "clevel.h"
#include "cap.h"

extern BOOL g_bIsWin9X;
CAPFILTER g_execFilter;
pfnExContinue g_pfnExContinue = 0;

BOOL
HookUnchainableExceptionFilter(VOID)
{
    BOOL bResult;
    pfnRtlAddVectoredExceptionHandler pfnAddExceptionHandler = 0;
    PVOID pvResult;
    HANDLE hTemp;
    DWORD dwExceptionHandler;
    DWORD dwResultSize;
    PVOID pAlternateHeap;

    //
    // If we're NT - try for the unchainable filter in ntdll
    //
    if (FALSE == g_bIsWin9X) {
       pfnAddExceptionHandler = (pfnRtlAddVectoredExceptionHandler)GetProcAddress(GetModuleHandleA("NTDLL.DLL"), 
                                                                                  "RtlAddVectoredExceptionHandler");
       if (0 == pfnAddExceptionHandler) {
          return FALSE;
       }

       pvResult = (*pfnAddExceptionHandler)(1, 
                                            (PVOID)ExceptionFilter);
       if (0 == pvResult) {
          return FALSE;
       }
    }
    else {
       //
       // Set up exception handler
       //
       hTemp = CreateFileA(NAME_OF_EXCEPTION_VXD,
                           0,
                           0,
                           0,
                           0,
                           FILE_FLAG_DELETE_ON_CLOSE,
                           0);
       if (INVALID_HANDLE_VALUE == hTemp) {
          return FALSE;
       }
 
       _asm mov dwExceptionHandler, offset Win9XExceptionDispatcher

       bResult = DeviceIoControl(hTemp,
                                 INSTALL_RING_3_HANDLER,
                                 &dwExceptionHandler,
                                 sizeof(DWORD),
                                 0,
                                 0,
                                 &dwResultSize,
                                 0);
       if (FALSE == bResult) {
          return FALSE;
       }     

       //
       // Get function pointer for ExContinue
       //
       g_pfnExContinue = (pfnExContinue)0xbff76702;
    }

    return TRUE;
}

LONG 
ExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
    DWORD dwThreadId;
    DWORD dwCounter;
    BOOL bResult;
    LONG lRet;
    PCONTEXT pContext = ExceptionInfo->ContextRecord;
    PEXCEPTION_RECORD pRecord = ExceptionInfo->ExceptionRecord;
    PVIEWCHAIN pView = 0;
    PTHREADFAULT pThreadFault = 0;
    CHAR szBuffer[MAX_PATH];

    //
    // Retrieve thread data
    //
    dwThreadId = GetCurrentThreadId();

    pThreadFault = GetProfilerThreadData();
    if (0 == pThreadFault) {
       //
       // NT only code path
       //
       pThreadFault = AllocateProfilerThreadData();
       if (0 == pThreadFault) {
          //
          // This wasn't suppose to happen
          //
          ExitProcess(-1);
       }
    }
    
    //
    // Rehook the view
    //
    if (STATUS_SINGLE_STEP == pRecord->ExceptionCode) {
       //
       // Trace is used to map into call or jumps types we can't forward map
       //
       if (pThreadFault->dwPrevBP) {
          //
          // If we're a call - patch the return address so we can maintain call level
          //
          if (pThreadFault->prevBPType == Call) {
             //
             // Push the return level hook
             //
             bResult = PushCaller((PVOID)pThreadFault,
                                  (PVOID)pContext->Esp);
             if (FALSE == bResult) {
                //
                // Ooops
                //
                ExitProcess(-1);
             }
          }

          RestoreAddressFromView(pThreadFault->dwPrevBP,
                                 FALSE);

          if ((pThreadFault->prevBPType == Call) ||
              (pThreadFault->prevBPType == Jump)) {
             //
             // Profile this routine if it hasn't been mapped
             //
             pView = FindView((DWORD)pRecord->ExceptionAddress);
             if (0 == pView) {
                //
                // Add this address as a mapping breakpoint
                //
                pView = AddViewToMonitor((DWORD)pRecord->ExceptionAddress,
                                         Map);
                if (pView) {
                   bResult = MapCode(pView);
                   if (FALSE == bResult) {
                      //
                      // This is fatal
                      //
                      ExitProcess(-1);
                   }
                }
             }
          }

          pThreadFault->dwPrevBP = 0;
          pThreadFault->prevBPType = None;

          return EXCEPTION_CONTINUE_EXECUTION;
       }

       //
       // Trace exception wasn't generated by us
       //
       sprintf(szBuffer, "Unhandled Trace %08X\r\n", (DWORD)pRecord->ExceptionAddress);
       WriteError(szBuffer);

       return EXCEPTION_CONTINUE_SEARCH;
    }
 
    //
    // Restore the view
    //
    if (STATUS_BREAKPOINT == pRecord->ExceptionCode) {
       //
       // Restore any BP that hasn't been restored
       //
       if (pThreadFault->dwPrevBP) {
          RestoreAddressFromView(pThreadFault->dwPrevBP,
                                 FALSE);

          if ((DWORD)pRecord->ExceptionAddress == pThreadFault->dwPrevBP) {
             pThreadFault->dwPrevBP = 0;
             pThreadFault->prevBPType = None;

             return EXCEPTION_CONTINUE_EXECUTION;
          }
       }

/*
       //
       // Add address to the execution filter
       //
       bResult = AddToCap(&g_execFilter,
                          (DWORD)pRecord->ExceptionAddress);
       if (FALSE == bResult) {
          //
          // This is fatal
          //
          ExitProcess(-1);
       }

       //
       // If we've hit iteration - disable this and the previous breakpoints
       //
       if (0 != g_execFilter.dwIterationLock) {
          for (dwCounter = 0; dwCounter < g_execFilter.dwRunLength; dwCounter++) {
              //
              // Replace the munged code
              //
              pView = RestoreAddressFromView(g_execFilter.dwArray[g_execFilter.dwCursor - dwCounter - 1],
                                             TRUE);

              //
              // Add runtime event to log
              //
              sprintf(szBuffer, "CAP'ed %08X\r\n", g_execFilter.dwArray[g_execFilter.dwCursor - dwCounter - 1]);
              AddToDump(szBuffer, 
                        strlen(szBuffer), 
                        FALSE);
          }

          //
          // Clear breakpoint monitor flags
          //
          pThreadFault->dwPrevBP = 0;
          pThreadFault->prevBPType = None;

          return EXCEPTION_CONTINUE_EXECUTION;
       }
*/

       //
       // Replace the munged code
       //
       pView = RestoreAddressFromView((DWORD)pRecord->ExceptionAddress,
                                      TRUE);
       if (pView) {
          //
          // See if we've mapped this address range in yet
          //
          if (FALSE == pView->bMapped) {
             //
             // See if this address is already mapped
             //
             bResult = MapCode(pView);
             if (FALSE == bResult) {
                //
                // This is fatal
                //
                ExitProcess(-1);
             }
          }

          //
          // Set the trace so the last bp can be rehooked (unless we just executed a map bp)
          //          
          pContext->EFlags |= 0x00000100;
          pThreadFault->dwPrevBP = (DWORD)pRecord->ExceptionAddress;
          pThreadFault->prevBPType = pView->bpType;

          //
          // Add runtime event to log
          //
          if (pView->bpType != ThreadStart) {
              WriteExeFlow(dwThreadId,
                           (DWORD)pRecord->ExceptionAddress,
                           pThreadFault->dwCallLevel);
          }
          else {
              WriteThreadStart(dwThreadId,
                               (DWORD)pRecord->ExceptionAddress);
          }

          return EXCEPTION_CONTINUE_EXECUTION;
       }

       //
       // BP exception wasn't generated by us
       //
       sprintf(szBuffer, "Unhandled BP %08X\r\n", (DWORD)pRecord->ExceptionAddress);
       WriteError(szBuffer);

       return EXCEPTION_CONTINUE_SEARCH;
    }

    //
    // Continue searching the chain
    //

    return EXCEPTION_CONTINUE_SEARCH;
}

VOID
Win9XExceptionDispatcher(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
    LONG lResult;

    //
    // Call exception handler
    //
    lResult = ExceptionFilter(ExceptionInfo);
    if (lResult != EXCEPTION_CONTINUE_EXECUTION) {
       //
       // Fault not handled - page fault will terminate app
       //
       return;
    }

    //
    // Set the context results
    //
    SET_CONTEXT();

    //
    // This code path is never executed (unless the above call fails)
    //
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\filter.c ===
#include <windows.h>
#include "view.h"
#include "except.h"
#include "thread.h"
#include "dump.h"
#include "memory.h"
#include "profiler.h"
#include "filter.h"

static CRITICAL_SECTION filterCritSec;
static PMODULEFILTER pFilterHead = 0;
static PMODULEFILTER pLBFilterHead = 0;
static char *pszModules[] = {"ntdll.dll",
                             "kernel32.dll",
                             "gdi32.dll",
                             "user32.dll",
                             "shell32.dll",
                             "shlwapi.dll",
                             "msvcrt.dll",
                             "msvcirt.dll",
                             "advapi32.dll",
                             "ddraw.dll",
                             "dsound.dll",
                             "ole32.dll",
                             "rpcrt4.dll",
                             "oleaut32.dll",
                             "winmm.dll",
                             "comctl32.dll",
                             "comdlg32.dll",
                             "riched20.dll",
                             "dinput.dll",
                             "wdmaud.drv",
                             NAME_OF_DLL_TO_INJECT};

BOOL
InitializeFilterList(VOID)
{
    HMODULE hTemp;
    PIMAGE_NT_HEADERS pHeaders;
    DWORD dwModStart;
    DWORD dwModEnd;
    DWORD dwCounter;
    DWORD dwCount;
    BOOL bResult;

    InitializeCriticalSection(&filterCritSec);

    dwCount = sizeof(pszModules) / sizeof(char *);

    for (dwCounter = 0; dwCounter < dwCount; dwCounter++) {
        //
        // Build the filter list
        //   
        hTemp = GetModuleHandleA(pszModules[dwCounter]);
    

        if (0 == hTemp) {
           bResult = AddModuleToFilterList(pszModules[dwCounter],
                                           0,
                                           0,
                                           TRUE);
           if (FALSE == bResult) {
              return FALSE;
           }
        }
        else {
           //
           // Dig out the PE information
           //
           pHeaders = ImageNtHeader2((PVOID)hTemp);

           dwModStart = (DWORD)hTemp;
           dwModEnd = dwModStart + pHeaders->OptionalHeader.SizeOfImage;

           bResult = AddModuleToFilterList(pszModules[dwCounter],
                                           dwModStart,
                                           dwModEnd,
                                           FALSE);
           if (FALSE == bResult) {
              return FALSE;
           }
        }
    }

    return TRUE;
}

BOOL
AddModuleToFilterList(CHAR *pszModuleName, 
                      DWORD dwStartAddress, 
                      DWORD dwEndAddress,
                      BOOL bLateBound)
{
    PMODULEFILTER pModuleFilter;

    //
    // Allocate entry
    //
    pModuleFilter = AllocMem(sizeof(MODULEFILTER));
    if (0 == pModuleFilter) {
       return FALSE;
    }

    if (pszModuleName) {
       strcpy(pModuleFilter->szModuleName, pszModuleName);
    }
    pModuleFilter->dwModuleStart = dwStartAddress;
    pModuleFilter->dwModuleEnd = dwEndAddress;
    pModuleFilter->pNextFilter = 0;

    EnterCriticalSection(&filterCritSec);

    if (FALSE == bLateBound) {
       //
       // Add DLL to the normal filter list
       //
       if (0 == pFilterHead) {
          pFilterHead = pModuleFilter;
       }
       else {
          pModuleFilter->pNextFilter = pFilterHead;
          pFilterHead = pModuleFilter;
       }
    }
    else {
       //
       // Add DLL to the late bound list
       //
       if (0 == pLBFilterHead) {
          pLBFilterHead = pModuleFilter;
       }
       else {
          pModuleFilter->pNextFilter = pLBFilterHead;
          pLBFilterHead = pModuleFilter;
       }
    }

    LeaveCriticalSection(&filterCritSec);

    return TRUE;
}

BOOL
IsAddressFiltered(DWORD dwAddress)
{
    PMODULEFILTER pModuleFilter;

    EnterCriticalSection(&filterCritSec);

    //
    // Walk both lists and see if we have an address to filter
    //
    pModuleFilter = pFilterHead;
    while (pModuleFilter) {
       if ((dwAddress >= pModuleFilter->dwModuleStart) && 
           (dwAddress <= pModuleFilter->dwModuleEnd)) {
          LeaveCriticalSection(&filterCritSec);

          return TRUE;
       }

       pModuleFilter = pModuleFilter->pNextFilter;
    }

    pModuleFilter = pLBFilterHead;
    while (pModuleFilter) {
       if ((dwAddress >= pModuleFilter->dwModuleStart) && 
           (dwAddress <= pModuleFilter->dwModuleEnd)) {
          LeaveCriticalSection(&filterCritSec);

          return TRUE;
       }

       pModuleFilter = pModuleFilter->pNextFilter;
    }

    LeaveCriticalSection(&filterCritSec);

    return FALSE;
}

VOID
RefreshFilterList(VOID)
{
    PMODULEFILTER pModuleFilter;
    HMODULE hTemp;
    PIMAGE_NT_HEADERS pHeaders;
    DWORD dwModStart;
    DWORD dwModEnd;

    //
    // Walk the LB list and refresh the start and end module addresses
    //

    EnterCriticalSection(&filterCritSec);

    pModuleFilter = pLBFilterHead;
    while (pModuleFilter) {
       //
       // Grab the module base address
       //
       hTemp = GetModuleHandleA(pModuleFilter->szModuleName);
       if (hTemp) {
          //
          // This module is loaded - do refresh
          //
          pHeaders = ImageNtHeader2((PVOID)hTemp);

          dwModStart = (DWORD)hTemp;
          dwModEnd = dwModStart + pHeaders->OptionalHeader.SizeOfImage;
 
          pModuleFilter->dwModuleStart = dwModStart;
          pModuleFilter->dwModuleEnd = dwModEnd;
       }
       
       pModuleFilter = pModuleFilter->pNextFilter;
    }

    LeaveCriticalSection(&filterCritSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\hooks.c ===
#include <windows.h>
#include <stdlib.h>
#include <psapi.h>
#include <tlhelp32.h>
#include <imagehlp.h>
#include <stdio.h>
#include "shimdb.h"
#include "shim2.h"
#include "hooks.h"
#include "dump.h"
#include "view.h"
#include "filter.h"
#include "except.h"
#include "profiler.h"

//
// API hook externs
//
extern BOOL g_bIsWin9X;
extern HANDLE g_hSnapshot;
extern HANDLE g_hValidationSnapshot;
extern LONG g_nShimDllCount;
extern LONG g_nHookedModuleCount;
extern HMODULE g_hHookedModules[MAX_MODULES];
extern HMODULE g_hShimDlls[MAX_MODULES];
extern PHOOKAPI g_rgpHookAPIs[MAX_MODULES];
extern LONG g_rgnHookAPICount[MAX_MODULES];

//
// Global array of hooked functions
//
HOOKAPI g_rgBaseHookAPIs[SHIM_BASE_APIHOOK_COUNT];

PVOID StubGetProcAddress(
    HMODULE hMod,
    char*   pszProc)
{
    char  szModName[MAX_PATH];
    char* pszShortName;
    UINT  ind;
    DWORD dwSize;
    PVOID pfn;
    LONG  i,j;
    PHOOKAPI pTopHookAPI = NULL;

    PFNGETPROCADDRESS pfnOld;
    pfnOld = g_rgBaseHookAPIs[ hookGetProcAddress ].pfnOld;

    if( pfn = (*pfnOld)(hMod, pszProc) )
    {    
        for (i = 0; i < g_nShimDllCount; i++)
        {            
            for (j = 0; j < g_rgnHookAPICount[i]; j++)
            {        
                if( g_rgpHookAPIs[i][j].pfnOld == pfn)
                {
                    pTopHookAPI = ConstructChain( pfn, &dwSize );
//maybe use the include exclude function here as well
                    return pTopHookAPI->pfnNew;
                }
            }
        }
    }
    
    return pfn;
} // StubGetProcAddress

HMODULE StubLoadLibraryA(
    LPCSTR pszModule)
{
    HMODULE hMod;
    PFNLOADLIBRARYA pfnOld;
    PIMAGE_NT_HEADERS pHeaders;

    pfnOld = g_rgBaseHookAPIs[ hookLoadLibraryA ].pfnOld;
    hMod = (*pfnOld)(pszModule);

    if (hMod != NULL) {
       RefreshFilterList();

       Shim2PatchNewModules();

       //
       // Rescan DLLs and add updated base information
       //
       WriteImportDLLTableInfo();
    }
    
    return hMod;
} // StubLoadLibraryA

HMODULE StubLoadLibraryW(
    WCHAR* pwszModule)
{
    HMODULE hMod;
    CHAR szModuleName[MAX_PATH];
    PIMAGE_NT_HEADERS pHeaders;
    INT nResult;

    PFNLOADLIBRARYW pfnOld;
    pfnOld = g_rgBaseHookAPIs[ hookLoadLibraryW ].pfnOld;

    hMod = (*pfnOld)(pwszModule);

    if (hMod != NULL) {
       RefreshFilterList();

       Shim2PatchNewModules();


       //
       // Rescan DLLs and add updated base information
       //
       WriteImportDLLTableInfo();
    }
    
    return hMod;
} // StubLoadLibraryW

HMODULE StubLoadLibraryExA(
    LPCSTR pszModule,
    HANDLE  hFile,
    DWORD  dwFlags)
{
    HMODULE hMod;
    PFNLOADLIBRARYEXA pfnOld;
    PIMAGE_NT_HEADERS pHeaders;

    pfnOld = g_rgBaseHookAPIs[ hookLoadLibraryExA ].pfnOld;
    hMod = (*pfnOld)(pszModule, hFile, dwFlags);

    if (hMod != NULL) {
       RefreshFilterList();

       Shim2PatchNewModules();

       //
       // Rescan DLLs and add updated base information
       //
       WriteImportDLLTableInfo();
    }
    
    return hMod;
} // StubLoadLibraryExA

HMODULE StubLoadLibraryExW(
    WCHAR* pwszModule,
    HANDLE  hFile,
    DWORD  dwFlags)
{
    HMODULE hMod;
    PIMAGE_NT_HEADERS pHeaders;
    INT nResult;

    PFNLOADLIBRARYEXW pfnOld;
    pfnOld = g_rgBaseHookAPIs[ hookLoadLibraryExW ].pfnOld;

    hMod = (*pfnOld)(pwszModule, hFile, dwFlags);

    if (hMod != NULL) {
       RefreshFilterList();

       Shim2PatchNewModules();

       //
       // Rescan DLLs and add updated base information
       //
       WriteImportDLLTableInfo();
    }
    
    return hMod;
} // StubLoadLibraryExW

BOOL StubFreeLibrary(
  HMODULE hLibModule   // handle to loaded library module
)
{
    BOOL bRet, bFound;
    PFNFREELIBRARY pfnOld;
    MODULEENTRY32 ModuleEntry32;
    long i, j;

    pfnOld = (PFNFREELIBRARY) g_rgBaseHookAPIs[ hookFreeLibrary ].pfnOld;

    bRet = (*pfnOld)(hLibModule);

    g_hSnapshot = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, 0 );

    ModuleEntry32.dwSize = sizeof( ModuleEntry32 );
    for( i = 0; i < g_nHookedModuleCount; i++ )
    {
        bFound = FALSE;
        bRet = Module32First( g_hSnapshot, &ModuleEntry32 );

        while( bRet )
        {
            if( g_hHookedModules[i] == ModuleEntry32.hModule )
            {
                bFound = TRUE;
                break;
            }
            bRet = Module32Next( g_hSnapshot, &ModuleEntry32 );
        }

        if( ! bFound )
        {
            // Take out of list
            for( j = i; j < g_nHookedModuleCount - 1; j++ )
                g_hHookedModules[j] = g_hHookedModules[j+1];

            g_hHookedModules[j] = NULL;
            g_nHookedModuleCount--;
        }
    }

    if( g_hSnapshot )
    {
        CloseHandle( g_hSnapshot );
        g_hSnapshot = NULL;
    }

    return bRet;
}

VOID StubExitProcess(UINT uExitCode)
{
    PFNEXITPROCESS pfnOld;

    //
    // Process is terminating - flush ourselves
    //
    FlushForTermination();

    pfnOld = g_rgBaseHookAPIs[ hookExitProcess ].pfnOld;
    (*pfnOld)(uExitCode);
} // StubExitProcess

HANDLE StubCreateThread(
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  DWORD dwStackSize,
  LPTHREAD_START_ROUTINE lpStartAddress,
  LPVOID lpParameter,
  DWORD dwCreationFlags,
  LPDWORD lpThreadId)
{
    PFNCREATETHREAD pfnOld;
    PVIEWCHAIN pvTemp;

    pfnOld = g_rgBaseHookAPIs[ hookCreateThread ].pfnOld;

    //
    // Add a mapping breakpoint for the thread entrypoint
    //
    pvTemp = AddViewToMonitor((DWORD)lpStartAddress,
                              ThreadStart);

    return (*pfnOld)(lpThreadAttributes,
                     dwStackSize,
                     lpStartAddress,
                     lpParameter,
                     dwCreationFlags,
                     lpThreadId);
} // StubCreateThread

VOID
InitializeBaseHooks(HINSTANCE hInstance)
{
        g_hSnapshot = NULL;
        g_hValidationSnapshot = NULL;

        g_nShimDllCount = 0;
        g_nHookedModuleCount = 0;
        ZeroMemory( g_hHookedModules, sizeof( g_hHookedModules ) );
        ZeroMemory( g_hShimDlls, sizeof( g_hShimDlls ) );
        ZeroMemory( g_rgpHookAPIs, sizeof( g_rgpHookAPIs ) );
        ZeroMemory( g_rgnHookAPICount, sizeof( g_rgnHookAPICount ) );
        ZeroMemory( g_rgBaseHookAPIs, sizeof( g_rgBaseHookAPIs ) );
    
        g_rgBaseHookAPIs[ hookGetProcAddress ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookGetProcAddress ].pszFunctionName = "GetProcAddress";
        g_rgBaseHookAPIs[ hookGetProcAddress ].pfnNew = (PVOID)StubGetProcAddress;
    
        g_rgBaseHookAPIs[ hookLoadLibraryA ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookLoadLibraryA ].pszFunctionName = "LoadLibraryA";
        g_rgBaseHookAPIs[ hookLoadLibraryA ].pfnNew = (PVOID)StubLoadLibraryA;
    
        g_rgBaseHookAPIs[ hookLoadLibraryW ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookLoadLibraryW ].pszFunctionName = "LoadLibraryW";
        g_rgBaseHookAPIs[ hookLoadLibraryW ].pfnNew = (PVOID)StubLoadLibraryW;
    
        g_rgBaseHookAPIs[ hookLoadLibraryExA ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookLoadLibraryExA ].pszFunctionName = "LoadLibraryExA";
        g_rgBaseHookAPIs[ hookLoadLibraryExA ].pfnNew = (PVOID)StubLoadLibraryExA;
    
        g_rgBaseHookAPIs[ hookLoadLibraryExW ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookLoadLibraryExW ].pszFunctionName = "LoadLibraryExW";
        g_rgBaseHookAPIs[ hookLoadLibraryExW ].pfnNew = (PVOID)StubLoadLibraryExW;

        g_rgBaseHookAPIs[ hookFreeLibrary ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookFreeLibrary ].pszFunctionName = "FreeLibrary";
        g_rgBaseHookAPIs[ hookFreeLibrary ].pfnNew = (PVOID)StubFreeLibrary;

        g_rgBaseHookAPIs[ hookExitProcess ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookExitProcess ].pszFunctionName = "ExitProcess";
        g_rgBaseHookAPIs[ hookExitProcess ].pfnNew = (PVOID)StubExitProcess;

        g_rgBaseHookAPIs[ hookCreateThread ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookCreateThread ].pszFunctionName = "CreateThread";
        g_rgBaseHookAPIs[ hookCreateThread ].pfnNew = (PVOID)StubCreateThread;

        AddHookAPIs(hInstance, g_rgBaseHookAPIs, SHIM_BASE_APIHOOK_COUNT, NULL);

        Shim2PatchNewModules();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\memory.c ===
#include <windows.h>
#include <stdio.h>
#include "memory.h"

static HANDLE hHeap = 0;

BOOL
InitializeHeap(VOID)
{
    HANDLE hResult;

    hResult = HeapCreate(HEAP_GENERATE_EXCEPTIONS,
                         HEAP_DEFAULT_SIZE,
                         0);
    if (0 == hResult) {
       return FALSE;
    }

    hHeap = hResult;

    return TRUE;
}

LPVOID
AllocMem(DWORD dwBytes)
{
    LPVOID lpResult = 0;

    lpResult = HeapAlloc(hHeap,
                         HEAP_ZERO_MEMORY,
                         dwBytes);

    return lpResult;
}

BOOL
FreeMem(LPVOID lpMem)
{
    BOOL bResult = FALSE;

    bResult = HeapFree(hHeap,
                       0,
                       lpMem);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\hooks.h ===
#ifndef _HOOKS_H_
#define _HOOKS_H_

//
// Constant declarations
//
#define HAF_RESOLVED        0x0001
#define HAF_BOTTOM_OF_CHAIN 0x0002
#define MAX_MODULES             512
#define SHIM_GETHOOKAPIS        "GetHookAPIs"

typedef PHOOKAPI    (*PFNNEWGETHOOKAPIS)(DWORD dwGetProcAddress, DWORD dwLoadLibraryA, DWORD dwFreeLibrary, DWORD* pdwHookAPICount);
typedef LPSTR       (*PFNGETCOMMANDLINEA)(VOID);
typedef LPWSTR      (*PFNGETCOMMANDLINEW)(VOID);
typedef PVOID       (*PFNGETPROCADDRESS)(HMODULE hMod, char* pszProc);
typedef HINSTANCE   (*PFNLOADLIBRARYA)(LPCSTR lpLibFileName);
typedef HINSTANCE   (*PFNLOADLIBRARYW)(LPCWSTR lpLibFileName);
typedef HINSTANCE   (*PFNLOADLIBRARYEXA)(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef HINSTANCE   (*PFNLOADLIBRARYEXW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef BOOL        (*PFNFREELIBRARY)(HMODULE hLibModule);
typedef VOID        (*PFNEXITPROCESS)(UINT uExitCode);
typedef HANDLE      (*PFNCREATETHREAD)(LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
 

 
//number of the base hook apis used by init.c and shim2.c
#define SHIM_BASE_APIHOOK_COUNT 8

enum
{
   hookGetProcAddress,
   hookLoadLibraryA,
   hookLoadLibraryW,
   hookLoadLibraryExA,
   hookLoadLibraryExW,
   hookFreeLibrary,
   hookExitProcess,
   hookCreateThread,
};

extern PHOOKAPI ConstructChain( PVOID pfnOld ,DWORD* DllListIndex);
extern void __stdcall Shim2PatchNewModules( VOID );
extern void AddHookAPIs( HMODULE hShimDll, PHOOKAPI pHookAPIs, DWORD dwCount,LPTSTR szIncExclDllList);

//
// Structure definitions
//

//
// Function definitions
//
VOID
InitializeBaseHooks(HINSTANCE hInstance);

#endif //_HOOKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\memory.h ===
#ifndef _MEMORY_H_
#define _MEMORY_H_

//
// Constant declarations
//
#define HEAP_DEFAULT_SIZE 100 * 1024 //20k of initial stack

//
// Structure definitions
//

//
// Function definitions
//
BOOL
InitializeHeap(VOID);

LPVOID
AllocMem(DWORD dwBytes);

BOOL
FreeMem(LPVOID lpMem);

#endif //_MEMORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\inject.h ===
#ifndef _INJECT_H_
#define _INJECT_H_

//
// Constant declarations
//
#define DEFAULT_ENTRY_POINT "g_fnFinalizeInjection"

//
// Structure definitions
//
typedef struct _INJECTIONSTUB
{
  CHAR  pCode[MAX_PATH];
  CHAR  szDLLName[MAX_PATH];
  CHAR  szEntryPoint[MAX_PATH];
} INJECTIONSTUB, *PINJECTIONSTUB;

//
// Function definitions
//
HANDLE
InjectDLL(DWORD dwEntryPoint,
          HANDLE hProcess,
          LPSTR  pszDLLName);

VOID
RestoreImageFromInjection(VOID);

#endif //_INJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\inject.c ===
#include <windows.h>
#include "inject.h"
#include "profiler.h"

BOOL g_bIsWin9X = FALSE;
CHAR g_fnFinalizeInjection[MAX_PATH];
HINSTANCE g_hProfileDLL = 0;

HANDLE
InjectDLL(DWORD dwEntryPoint,
          HANDLE hProcess,
          LPSTR  pszDLLName)
{
    CHAR szTempPath[MAX_PATH];
    HMODULE hKernel32;
    BOOL bResult = FALSE;
    INJECTIONSTUB injStub;
    DWORD dwLoadLibrary;
    DWORD dwGetProcAddress;
    DWORD dwBytesWritten;
    DWORD dwBytesRead;
    DWORD dwOldProtect;
    DWORD dwOldProtect2;
    PBYTE pSharedMem = 0;
    HANDLE hFileMap = 0;

    hKernel32 =  GetModuleHandle("KERNEL32.DLL");
    dwLoadLibrary = (DWORD)GetProcAddress(hKernel32,
                                          "LoadLibraryA");
    if (0 == dwLoadLibrary) {
       bResult = FALSE;
       goto handleerror;
    }

    dwGetProcAddress = (DWORD)GetProcAddress(hKernel32,
                                             "GetProcAddress");
    if (0 == dwGetProcAddress) {
       bResult = FALSE;
       goto handleerror;
    }

    //
    // Initialize the asm for the stub
    //
    injStub.pCode[0] = 0x90;  // int 3 or nop
    injStub.pCode[1] = 0x60;  // pushad
    injStub.pCode[2] = 0x8d;  // lea eax, [xxxxxxxx]
    injStub.pCode[3] = 0x05;
    *(DWORD *)(&(injStub.pCode[4])) = dwEntryPoint + (DWORD)&(injStub.szDLLName) - (DWORD)&injStub;
    injStub.pCode[8] = 0x50;  // push eax
    injStub.pCode[9] = 0xff;  // call dword ptr [xxxxxxxx] - LoadLibraryA
    injStub.pCode[10] = 0x15;
    *(DWORD *)(&(injStub.pCode[11])) = dwEntryPoint + 50;
    injStub.pCode[15] = 0x50; // push eax
    injStub.pCode[16] = 0x5b; // pop ebx
    injStub.pCode[17] = 0x8d; // lea eax, [xxxxxxxx]
    injStub.pCode[18] = 0x05;
    *(DWORD *)(&(injStub.pCode[19])) = dwEntryPoint + (DWORD)&(injStub.szEntryPoint) - (DWORD)&injStub;
    injStub.pCode[23] = 0x50; // push eax  // module base
    injStub.pCode[24] = 0x53; // push ebx  // function name
    injStub.pCode[25] = 0xff; // call dword ptr [xxxxxxxx] - GetProcAddress
    injStub.pCode[26] = 0x15;
    *(DWORD *)(&(injStub.pCode[27])) = dwEntryPoint + 54;
    injStub.pCode[31] = 0xff;
    injStub.pCode[32] = 0xd0;
    *(DWORD *)(&(injStub.pCode[50])) = dwLoadLibrary;
    *(DWORD *)(&(injStub.pCode[54])) = dwGetProcAddress;

    //
    // Create the file mapping object from the paging file
    //
    hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE,
                                 NULL,
                                 PAGE_READWRITE,
                                 0,
                                 sizeof(INJECTIONSTUB),
                                 "ProfilerSharedMem");
    if (0 == hFileMap) {
       bResult = FALSE;
       goto handleerror;
    }

    pSharedMem = (PBYTE)MapViewOfFile(hFileMap,
                                      FILE_MAP_ALL_ACCESS,
                                      0,
                                      0,
                                      sizeof(INJECTIONSTUB));
    if (0 == pSharedMem) {
       bResult = FALSE;
       goto handleerror;
    }

    //
    // Initialize injection stub
    //
    strcpy(injStub.szDLLName, pszDLLName);
    strcpy(injStub.szEntryPoint, DEFAULT_ENTRY_POINT);

    bResult = ReadProcessMemory(hProcess,
 	                       (LPVOID)dwEntryPoint,
 			       (PVOID)pSharedMem,
			       sizeof(INJECTIONSTUB),
			       &dwBytesRead);	                  
    if (FALSE == bResult) {
       bResult = FALSE;
       goto handleerror;
    }  

    //
    // Write the stub code into the entry point
    //
    bResult = WriteProcessMemory(hProcess,
 	                        (LPVOID)dwEntryPoint,
 				(PVOID)&injStub,
				sizeof(INJECTIONSTUB),
 				&dwBytesWritten);	                  
    if (FALSE == bResult) {
       bResult = FALSE;
       goto handleerror;
    }

handleerror:

    return hFileMap;
}

VOID
RestoreImageFromInjection(VOID)
{
    PIMAGE_NT_HEADERS pHeaders = 0;
    BOOL bResult;
    BOOL bError = FALSE;
    PVOID pBase = 0;
    DWORD dwEntryPoint;
    DWORD dwBytesRead;
    DWORD dwBytesWritten;
    PINJECTIONSTUB pInjStub;
    HANDLE hFileMap = 0;
    PBYTE pSharedMem = 0;
    OSVERSIONINFO verInfo;

    //
    // Get the entry point from the headers
    //
    pBase = (PVOID)GetModuleHandle(0);
    if (0 == pBase) {
       bError = TRUE;
       goto handleerror;
    }

    //
    // Dig out the PE information
    //
    pHeaders = ImageNtHeader2(pBase);
    if (0 == pHeaders) {
       bError = TRUE;
       goto handleerror;
    }

    dwEntryPoint = pHeaders->OptionalHeader.ImageBase + pHeaders->OptionalHeader.AddressOfEntryPoint;
    pInjStub = (PINJECTIONSTUB)dwEntryPoint;

    //
    // Open the memory mapped file and get the bits
    //
    hFileMap = OpenFileMapping(FILE_MAP_ALL_ACCESS,
                               FALSE,
                               "ProfilerSharedMem");

    if (0 == hFileMap) {
       bError = TRUE;
       goto handleerror;
    }

    pSharedMem = (PBYTE)MapViewOfFile(hFileMap,
                                      FILE_MAP_ALL_ACCESS,
                                      0,
                                      0,
                                      0);
    if (0 == pSharedMem) {
       bError = TRUE;
       goto handleerror;
    }

    //
    // Replace the bits
    //
    bResult = WriteProcessMemory(GetCurrentProcess(),
                                 (PVOID)dwEntryPoint,
                                 (PVOID)pSharedMem,
                                 sizeof(INJECTIONSTUB),
                                 &dwBytesWritten);
    if (FALSE == bResult) {
       bError = TRUE;
       goto handleerror;
    }

    //
    // Set the OS information
    //
    ZeroMemory(&verInfo, sizeof(OSVERSIONINFO));
    
    verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    bResult = GetVersionExA(&verInfo);
    if (FALSE == bResult) {
       bError = TRUE;
       goto handleerror;
    }

    if (VER_PLATFORM_WIN32_NT == verInfo.dwPlatformId) {
       g_bIsWin9X = FALSE;
    }
    else if (VER_PLATFORM_WIN32_WINDOWS == verInfo.dwPlatformId) {
       g_bIsWin9X = TRUE;
    }
    else {
       //
       // Unsupported platform
       //
       ExitProcess(-1);
    }

    //
    // Finish profiler initializations
    //
    bResult = InitializeProfiler();
    if (FALSE == bResult) {
       bError = TRUE;
       goto handleerror;
    }
    
handleerror:

    if (TRUE == bError) {
       ExitProcess(-1);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\profiler.h ===
#ifndef _PROFILER_H_
#define _PROFILER_H_

//
// Constant declarations
//
#define NAME_OF_DLL_TO_INJECT "profiler.dll"
#define NAME_OF_EXCEPTION_VXD "\\\\.\\EXVECTOR.VXD"
#define INSTALL_RING_3_HANDLER 0x42424242

//
// Function definitions
//
DWORD
GetExeEntryPoint(LPSTR pszExePath);

PIMAGE_NT_HEADERS
ImageNtHeader2 (PVOID Base);

BOOL 
InitializeProfiler(VOID);

HANDLE
AttachToEXVectorVXD(VOID);

VOID
DetachFromEXVectorVXD(HANDLE hDevice);

BOOL
WriteImportDLLTableInfo(VOID);

#endif //_PROFILER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\profiler.c ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <tlhelp32.h>
#include "profiler.h"
#include "inject.h"
#include "view.h"
#include "except.h"
#include "thread.h"
#include "dump.h"
#include "shimdb.h"
#include "shim2.h"
#include "hooks.h"
#include "memory.h"
#include "filter.h"
#include "clevel.h"
#include "cap.h"

extern CHAR g_fnFinalizeInjection[MAX_PATH];
extern HINSTANCE g_hProfileDLL;
extern FIXUPRETURN g_fnFixupReturn[1];
extern DWORD g_dwCallArray[2];
extern CAPFILTER g_execFilter;

int 
WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPSTR     lpszCmd,
    int       swShow)
{
    HANDLE hFile = 0;
    BOOL bResult = FALSE;
    STARTUPINFO sInfo;
    PCHAR pszToken;
    PCHAR pszEnd;
    PROCESS_INFORMATION pInfo;
    DWORD dwEntry = 0;
    OSVERSIONINFO verInfo;
    BOOL bIsWin9X = FALSE;
    HANDLE hDevice = INVALID_HANDLE_VALUE;

    //
    // Get the OS information
    //
    ZeroMemory(&verInfo, sizeof(OSVERSIONINFO));
    
    verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    bResult = GetVersionExA(&verInfo);
    if (FALSE == bResult) {
       return -1;
    }

    if (VER_PLATFORM_WIN32_NT == verInfo.dwPlatformId) {
       bIsWin9X = FALSE;
    }
    else if (VER_PLATFORM_WIN32_WINDOWS == verInfo.dwPlatformId) {
       bIsWin9X = TRUE;
    }

    //
    // Initialize my working heap
    //
    bResult = InitializeHeap();
    if (FALSE == bResult) {
       return -1;
    }

    //
    // Parse the command line
    //
    pszToken = strstr(lpszCmd, "\"");
    if (pszToken) {
       pszToken++;

       pszEnd = strstr(pszToken, "\"");
       *pszEnd = '\0';
    }

    if (0 == pszToken) {
       pszToken = strstr(lpszCmd, " ");
       if (0 == pszToken) {
          pszToken = strstr(lpszCmd, "\t");
          if (0 == pszToken) {
             pszToken = lpszCmd;
          }
       }
    }

    //
    // Initialize our process information struct
    //
    ZeroMemory(&sInfo, sizeof(STARTUPINFO));
    ZeroMemory(&pInfo, sizeof(PROCESS_INFORMATION));
    sInfo.cb = sizeof(STARTUPINFO);

    dwEntry = GetExeEntryPoint(pszToken);
    if (0 == dwEntry) {
       return -1;
    }

    //
    // Get our exe ready for DLL injection
    //
    bResult = CreateProcessA(0,
                             pszToken,
                             0,
                             0,
                             FALSE,
                             CREATE_SUSPENDED,
                             0,
                             0, //should make this a setable param sooner rather than later
                             &sInfo,
                             &pInfo);
    if (FALSE == bResult) {
       return -1;
    }

    //
    // If we're 9x - bring in the VxD
    //
    if (TRUE == bIsWin9X) {
       hDevice = AttachToEXVectorVXD();
       if (INVALID_HANDLE_VALUE == hDevice) {
          return -1;
       }
    }

    //
    // Inject our dll into the target
    //
    hFile = InjectDLL(dwEntry,
                      pInfo.hProcess,
                      NAME_OF_DLL_TO_INJECT);
    if (0 == hFile) {
       return -1;
    }

    //
    // Turn the process loose
    //
    bResult = ResumeThread(pInfo.hThread);
    if (FALSE == bResult) {
       return -1;
    }

    //
    // Wait for target termination
    //    
    WaitForSingleObject(pInfo.hThread,
                        INFINITE);

    //
    // If we're 9x - close our handle to the vxd (this will unload the vxd from memory)
    //
    if (TRUE == bIsWin9X) {
       if (INVALID_HANDLE_VALUE != hDevice) {
          DetachFromEXVectorVXD(hDevice);
       }
    }

    return 0;
}

DWORD
GetExeEntryPoint(LPSTR pszExePath)
{
    PIMAGE_NT_HEADERS pHeaders;
    BOOL bResult;
    PCHAR pEXEBits = 0;
    DWORD dwEntry = 0;
    DWORD dwNumberBytesRead;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    pEXEBits = (PCHAR)AllocMem(4096 * 1);  //allocate a page for reading the PE entry point
    if (0 == pEXEBits) {
       return dwEntry;
    }

    hFile = CreateFileA(pszExePath,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        0,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        0);
    if (INVALID_HANDLE_VALUE == hFile) {
       goto handleerror;
    }

    bResult = ReadFile(hFile,
                       pEXEBits,
                       4096, //read one page
                       &dwNumberBytesRead,
                       0);
    if (FALSE == bResult) {
       goto handleerror;
    }

    //
    // Dig out the PE information
    //
    pHeaders = ImageNtHeader2((PVOID)pEXEBits);
    if (0 == pHeaders) {
       goto handleerror;
    }

    dwEntry = pHeaders->OptionalHeader.ImageBase + pHeaders->OptionalHeader.AddressOfEntryPoint;
                    
handleerror:

    if (pEXEBits) {
       FreeMem(pEXEBits);
    }

    if (INVALID_HANDLE_VALUE != hFile) {
       CloseHandle(hFile);
    }
   
    return dwEntry;
}

PIMAGE_NT_HEADERS
ImageNtHeader2 (PVOID Base)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;

    if (Base != NULL && Base != (PVOID)-1) {
        if (((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) {
            NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);

            if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {
                NtHeaders = NULL;
            }
        }
    }

    return NtHeaders;
}

BOOL
WINAPI 
DllMain (
  HINSTANCE hinstDLL,
  DWORD fdwReason,
  LPVOID lpvReserved)
{
    PIMAGE_NT_HEADERS pHeaders;
    PVOID pBase = 0;
    DWORD dwEntryPoint;
    BOOL bResult = FALSE;

    //
    // Return true for everything coming through here
    //
    if (DLL_PROCESS_ATTACH == fdwReason) {
       //
       // Initialize my working heap
       //
       bResult = InitializeHeap();
       if (FALSE == bResult) {
          return FALSE;
       }

       //
       // Initialize the asm for the fixup return
       //

       //
       // Get the entry point from the headers
       //
       pBase = (PVOID)GetModuleHandle(0);
       if (0 == pBase) {
          return FALSE;
       }

       //
       // Dig out the PE information
       //
       pHeaders = ImageNtHeader2(pBase);
       if (0 == pHeaders) {
          return FALSE;
       }

       dwEntryPoint = pHeaders->OptionalHeader.ImageBase + pHeaders->OptionalHeader.AddressOfEntryPoint;

       //
       // Initialize stub asm for cleanup
       //
       g_fnFinalizeInjection[0] = 0x90; // int 3
       g_fnFinalizeInjection[1] = 0xff; // call dword ptr [xxxxxxxx] - RestoreImageFromInjection
       g_fnFinalizeInjection[2] = 0x15;
       *(DWORD *)(&(g_fnFinalizeInjection[3])) = (DWORD)g_fnFinalizeInjection + 50;
       g_fnFinalizeInjection[7] = 0x83;
       g_fnFinalizeInjection[8] = 0xc4;
       g_fnFinalizeInjection[9] = 0x04;
       g_fnFinalizeInjection[10] = 0x61;
       g_fnFinalizeInjection[11] = 0xa1;
       *(DWORD *)(&(g_fnFinalizeInjection[12])) = (DWORD)g_fnFinalizeInjection + 54;
       g_fnFinalizeInjection[16] = 0xff;
       g_fnFinalizeInjection[17] = 0xe0; 

       *(DWORD *)(&(g_fnFinalizeInjection[50])) = (DWORD)RestoreImageFromInjection;
       *(DWORD *)(&(g_fnFinalizeInjection[54])) = dwEntryPoint;

       //
       // Initialize the call return code
       //
       g_dwCallArray[0] = (DWORD)PopCaller;
       g_dwCallArray[1] = (DWORD)g_fnFixupReturn;

       g_fnFixupReturn->PUSHAD = 0x60;                //pushad   (60)
       g_fnFixupReturn->PUSHFD = 0x9c;                //pushfd   (9c)
       g_fnFixupReturn->PUSHDWORDESPPLUS24[0] = 0xff; //push dword ptr [esp+24] (ff 74 24 24)
       g_fnFixupReturn->PUSHDWORDESPPLUS24[1] = 0x74;
       g_fnFixupReturn->PUSHDWORDESPPLUS24[2] = 0x24;
       g_fnFixupReturn->PUSHDWORDESPPLUS24[3] = 0x24;
       g_fnFixupReturn->CALLROUTINE[0] = 0xff;        //call [address] (ff15 dword address)
       g_fnFixupReturn->CALLROUTINE[1] = 0x15;
       *(DWORD *)(&(g_fnFixupReturn->CALLROUTINE[2])) = (DWORD)&(g_dwCallArray[0]);
       g_fnFixupReturn->MOVESPPLUS24EAX[0] = 0x89;    //mov [esp+0x24],eax (89 44 24 24)
       g_fnFixupReturn->MOVESPPLUS24EAX[1] = 0x44;
       g_fnFixupReturn->MOVESPPLUS24EAX[2] = 0x24; 
       g_fnFixupReturn->MOVESPPLUS24EAX[3] = 0x24;
       g_fnFixupReturn->POPFD = 0x9d;                 //popfd   (9d)
       g_fnFixupReturn->POPAD = 0x61;                 //popad   (61)
       g_fnFixupReturn->RET = 0xc3;                   //ret (c3)

       //
       // Store the DLL base address
       //
       g_hProfileDLL = hinstDLL;
    }
 
    return TRUE;
}

BOOL 
InitializeProfiler(VOID)
{
    BOOL bResult = TRUE;
    PIMAGE_NT_HEADERS pHeaders;
    PVOID pBase = 0;
    DWORD dwEntryPoint;
    PVIEWCHAIN pvTemp;

    //
    // Get the entry point from the headers
    //
    pBase = (PVOID)GetModuleHandle(0);
    if (0 == pBase) {
       return FALSE;
    }

    //
    // Dig out the PE information
    //
    pHeaders = ImageNtHeader2(pBase);
    if (0 == pHeaders) {
       return FALSE;
    }

    dwEntryPoint = pHeaders->OptionalHeader.ImageBase + pHeaders->OptionalHeader.AddressOfEntryPoint;

    //
    // Tag the entry point so it'll start profiling with the initial view
    //
    bResult = InitializeViewData();
    if (FALSE == bResult) {
       //
       // Something unexpected happened
       //
       ExitProcess(-1);
    }

    //
    // Initialize execution filter data
    //
    ZeroMemory(&g_execFilter, sizeof(CAPFILTER));

    //
    // Initialize thread context data
    //
    InitializeThreadData();

    //
    // Get the debug logging setup
    //
    bResult = InitializeDumpData();
    if (FALSE == bResult) {
       //
       // Something unexpected happened
       //
       ExitProcess(-1);
    }

    //
    // Initialize the module filtering
    //
    bResult = InitializeFilterList();
    if (FALSE == bResult) {
       //
       // Something unexpected happened
       //
       ExitProcess(-1);
    }

    //
    // Set up exception trap mechanism
    //
    bResult = HookUnchainableExceptionFilter();
    if (FALSE == bResult) {
       //
       // Something unexpected happened while chaining exception filter
       //
       ExitProcess(-1);
    }

    //
    // Fixup the module list now that everything is restored
    //
    //
    InitializeBaseHooks(g_hProfileDLL);

    //
    // Write out import table base info
    //
    bResult = WriteImportDLLTableInfo();
    if (FALSE == bResult) {
       ExitProcess(-1);
    }

    //
    // Add our entrypoint to the view monitor
    //
    pvTemp = AddViewToMonitor(dwEntryPoint,
                              ThreadStart);
    if (0 == pvTemp) {
       ExitProcess(-1);
    }

    //
    // We're done
    // 
    return TRUE;
}

BOOL
WriteImportDLLTableInfo(VOID)
{
    HANDLE hSnapshot = INVALID_HANDLE_VALUE;
    MODULEENTRY32 ModuleEntry32;
    BOOL bResult;

    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,
                                         0);
    if (INVALID_HANDLE_VALUE == hSnapshot) {
       return FALSE;
    }

    //
    // Walk the DLL imports
    //
    ModuleEntry32.dwSize = sizeof(ModuleEntry32);

    bResult = Module32First(hSnapshot, 
                            &ModuleEntry32);
    if (FALSE == bResult) {
       return bResult;
    }

    while(bResult) {
        //
        // Dump the module information to disk
        //

        if ((DWORD)(ModuleEntry32.modBaseAddr) != (DWORD)g_hProfileDLL) {                         
           bResult = WriteDllInfo(ModuleEntry32.szModule,
                                  (DWORD)(ModuleEntry32.modBaseAddr),
                                  (DWORD)(ModuleEntry32.modBaseSize));
           if (FALSE == bResult) {
              CloseHandle(hSnapshot);

              return FALSE;
           }
        }

        bResult = Module32Next(hSnapshot, 
                               &ModuleEntry32);
    }

    if (INVALID_HANDLE_VALUE != hSnapshot) {
      CloseHandle(hSnapshot);
    }

    return TRUE;
}

HANDLE
AttachToEXVectorVXD(VOID)
{
    HANDLE hFile;

    hFile = CreateFileA(NAME_OF_EXCEPTION_VXD,
                        0,
                        0,
                        0,
                        0,
                        FILE_FLAG_DELETE_ON_CLOSE,
                        0);

    return hFile;
}

VOID
DetachFromEXVectorVXD(HANDLE hDevice)
{
    CloseHandle(hDevice);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\shim2.h ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    shim2.h
//
// History:    Mar-00   a-batjar       Created.
// 
// Desc:    Contains common declarations for shim2
//          
//
////////////////////////////////////////////////////////////////////////////////////


//defined in shim2.c used by init.c GetHookApis.
//loads the shim dll and initializes global structures necessary to hook 

extern BOOL _LoadPatchDll(LPWSTR szPatchDll,LPSTR szCmdLine,LPSTR szModToPatch);

//defined in shim2.c used by init.c GetHookApis
//shim2's hook mechanism, redirects import table of the loaded dll to
//shim functions.

extern void __stdcall PatchNewModules( VOID );


//memory patch tags used by mempatch.c and shim2.c

#define SHIM_MP_UNPROCESSED 0x00
#define SHIM_MP_PROCESSED   0x01
#define SHIM_MP_APPLIED     0x02

typedef struct tagSHIM_MEMORY_PATCH
{
    LPWSTR  pszModule;
    DWORD   dwOffset;
    DWORD   dwSize;
    LPVOID  pOld;
    LPVOID  pNew;
    DWORD   dwStatus;

} SHIM_MEMORY_PATCH, *PSHIM_MEMORY_PATCH;

//defined in init.c used by mempatch.c 


#define MEMPATCHTAG   "PATCH"


//defined in mempatch.c used by shim2.c PatchNewModules
extern void AttemptPatches();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\shim2.c ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    shim2.c
//
// History:    May-99   clupu       Created.
//             Aug-99   v-johnwh    Various bug fixes.
//          23-Nov-99   markder     Support for multiple shim DLLs, chaining
//                                  of hooks, DLL loads/unloads. General clean-up.
//             Jan-00   markder     Windows 9x support added.
//             Mar-00   a-batjar    Changed to support whistler format on w2k
//             May-00   v-johnwh    Modified to work in the profiler
// Desc:    Contains all code to facilitate hooking of APIs by replacing entries
//          in the import tables of loaded modules.
//
////////////////////////////////////////////////////////////////////////////////////


#include <windows.h>
#include <stdlib.h>
#include <psapi.h>
#include <tlhelp32.h>
#include <imagehlp.h>
#include <stdio.h>
#include "shimdb.h"
#include "shim2.h"

#define HAF_RESOLVED        0x0001
#define HAF_BOTTOM_OF_CHAIN 0x0002

typedef PHOOKAPI   (*PFNNEWGETHOOKAPIS)(DWORD dwGetProcAddress, DWORD dwLoadLibraryA, DWORD dwFreeLibrary, DWORD* pdwHookAPICount);
typedef LPSTR       (*PFNGETCOMMANDLINEA)(VOID);
typedef LPWSTR      (*PFNGETCOMMANDLINEW)(VOID);
typedef PVOID       (*PFNGETPROCADDRESS)(HMODULE hMod, char* pszProc);
typedef HINSTANCE   (*PFNLOADLIBRARYA)(LPCSTR lpLibFileName);
typedef HINSTANCE   (*PFNLOADLIBRARYW)(LPCWSTR lpLibFileName);
typedef HINSTANCE   (*PFNLOADLIBRARYEXA)(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef HINSTANCE   (*PFNLOADLIBRARYEXW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef BOOL        (*PFNFREELIBRARY)(HMODULE hLibModule);

// Global Variables

// Disable build warnings due to Print macro in free builds
#pragma warning( disable : 4002 )

#define MAX_MODULES             512
#define SHIM_GETHOOKAPIS        "GetHookAPIs"

////////////////////////////////////////////////////////////////////////////////////
//          API hook count & indices
////////////////////////////////////////////////////////////////////////////////////



enum
{
   hookGetProcAddress,
   hookLoadLibraryA,
   hookLoadLibraryW,
   hookLoadLibraryExA,
   hookLoadLibraryExW,
   hookFreeLibrary,
   hookGetCommandLineA,
   hookGetCommandLineW
};

////////////////////////////////////////////////////////////////////////////////////
//          Global variables
////////////////////////////////////////////////////////////////////////////////////

//  This array contains information used by the shim mechanism to describe 
//  what API to hook with a particular stub function.
LONG            g_nShimDllCount;
HMODULE         g_hShimDlls[MAX_MODULES];
PHOOKAPI        g_rgpHookAPIs[MAX_MODULES];
LONG            g_rgnHookAPICount[MAX_MODULES];
LPTSTR          g_rgnHookDllList[MAX_MODULES];

HMODULE         g_hHookedModules[MAX_MODULES];
LONG            g_nHookedModuleCount;

extern BOOL     g_bIsWin9X;
HANDLE          g_hSnapshot                   = NULL;
HANDLE          g_hValidationSnapshot         = NULL;




////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   ValidateAddress
//
//  Params: pfnOld              Original API function pointer to validate.
//
//  Return:                     Potentially massaged pfnOld.
//
//  Desc:   Win9x thunks system API entry points for some reason. The
//          shim mechanism has to work around this to get to the
//          'real' pointer so that it can make valid comparisons.
//
PVOID ValidateAddress( PVOID pfnOld )
{
    MODULEENTRY32   ModuleEntry32;
    BOOL            bRet;
    long            i, j;

    // Make sure the address isn't a shim thunk
    for( i = g_nShimDllCount - 1; i >= 0; i-- )
    {
        for( j = 0; j < g_rgnHookAPICount[i]; j++ )
        {
            if( g_rgpHookAPIs[i][j].pfnOld == pfnOld )
            {
                if( pfnOld == g_rgpHookAPIs[i][j].pfnNew )
                    return pfnOld;
            }
        }
    }

    ModuleEntry32.dwSize = sizeof( ModuleEntry32 );
    bRet = Module32First( g_hValidationSnapshot, &ModuleEntry32 );

    while( bRet )
    {
        if( pfnOld >= (PVOID) ModuleEntry32.modBaseAddr &&
            pfnOld <= (PVOID) ( ModuleEntry32.modBaseAddr + ModuleEntry32.modBaseSize ) )
        {
            return pfnOld;
        }

        bRet = Module32Next( g_hValidationSnapshot, &ModuleEntry32 );
    }

    // Hack for Win9x
    return *(PVOID *)( ((PBYTE)pfnOld)+1);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   ConstructChain
//
//  Params: pfnOld              Original API function pointer to resolve.
//
//  Return:                     Top-of-chain PHOOKAPI structure.
//
//  Desc:   Scans HookAPI arrays for pfnOld and either constructs the
//          chain or returns the top-of-chain PHOOKAPI if the chain
//          already exists.
//
PHOOKAPI ConstructChain( PVOID pfnOld ,DWORD* DllListIndex)
{
    LONG                        i, j;
    PHOOKAPI                    pTopHookAPI;
    PHOOKAPI                    pBottomHookAPI;

    pTopHookAPI = NULL;
    pBottomHookAPI = NULL;

    *DllListIndex=0;
    // Scan all HOOKAPI entries for corresponding function pointer
    for( i = g_nShimDllCount - 1; i >= 0; i-- )
    {
        for( j = 0; j < g_rgnHookAPICount[i]; j++ )
        {
            if( g_rgpHookAPIs[i][j].pfnOld == pfnOld )
            {
                if( pTopHookAPI )
                {
                    // Already hooked! Chain them together.
                    pBottomHookAPI->pfnOld = g_rgpHookAPIs[i][j].pfnNew;

                    pBottomHookAPI = &( g_rgpHookAPIs[i][j] );
                    pBottomHookAPI->pNextHook =   pTopHookAPI;
                    pBottomHookAPI->dwFlags = HAF_RESOLVED;
                }
                else
                {
                    if( g_rgpHookAPIs[i][j].pNextHook )
                    {
                        // Chaining has already been constructed.
                        pTopHookAPI = (PHOOKAPI) g_rgpHookAPIs[i][j].pNextHook;
                        *DllListIndex=i;
                        return pTopHookAPI;
                    }

                    // Not hooked yet. Set to top of chain.
                    pTopHookAPI = &( g_rgpHookAPIs[i][j] );
                    pTopHookAPI->pNextHook = pTopHookAPI;
                    pTopHookAPI->dwFlags = HAF_RESOLVED;

                    pBottomHookAPI = pTopHookAPI;
                }

                break;
            }        
        }
    }

    if( pBottomHookAPI )
    {
        pBottomHookAPI->dwFlags = HAF_BOTTOM_OF_CHAIN;
    }
    *DllListIndex=i;
    return pTopHookAPI;
} // ConstructChain

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   HookImports
//
//  Params: dwBaseAddress       Base address of module image to hook.
//
//          szModName           Name of module (for debug purposes only).
//
//  Desc:   This function is the workhorse of the shim: It scans the import
//          table of a module (specified by dwBaseAddress) looking for
//          function pointers that require hooking (according to HOOKAPI
//          entries in g_rgpHookAPIs). It then overwrites hooked function
//          pointers with the first stub function in the chain.
//
VOID HookImports(
    DWORD dwBaseAddress,
    LPTSTR szModName )
{
    BOOL                        bAnyHooked          = FALSE;
    PIMAGE_DOS_HEADER           pIDH                = (PIMAGE_DOS_HEADER) dwBaseAddress;
    PIMAGE_NT_HEADERS           pINTH;
    PIMAGE_IMPORT_DESCRIPTOR    pIID;
    PIMAGE_NT_HEADERS           NtHeaders;
    DWORD                       dwTemp;
    DWORD                       dwImportTableOffset;
    PHOOKAPI                    pTopHookAPI;
    DWORD                       dwOldProtect;
    LONG                        i, j;
    PVOID                       pfnOld;
            
    // Get the import table    
    pINTH = (PIMAGE_NT_HEADERS)(dwBaseAddress + pIDH->e_lfanew);

    dwImportTableOffset = pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    
    if( dwImportTableOffset == 0 )
        return;
    
    pIID = (PIMAGE_IMPORT_DESCRIPTOR)(dwBaseAddress + dwImportTableOffset);
    // Loop through the import table and search for the APIs that we want to patch
    while( TRUE )
    {
        
        LPTSTR             pszModule;
        PIMAGE_THUNK_DATA pITDA;


        // Return if no first thunk
        if (pIID->FirstThunk == 0) // (terminating condition)
           break;

        pszModule = (LPTSTR) ( dwBaseAddress + pIID->Name );
        
        // If we're not interested in this module jump to the next.
        bAnyHooked = FALSE;
        for( i = 0; i < g_nShimDllCount; i++ )
        {            
            for( j = 0; j < g_rgnHookAPICount[i]; j++ )
            {
                if( lstrcmpi( g_rgpHookAPIs[i][j].pszModule, pszModule ) == 0 )
                {
                    bAnyHooked = TRUE;
                    goto ScanDone;
                }
            }
        }

ScanDone:
        if( !bAnyHooked )
        {
            pIID++;
            continue;
        }
        
        // We have APIs to hook for this module!        
        pITDA = (PIMAGE_THUNK_DATA)( dwBaseAddress + (DWORD)pIID->FirstThunk );

        while( TRUE )
        {
            DWORD DllListIndex = 0;

            pfnOld = (PVOID) pITDA->u1.Function;

            // Done with all the imports from this module? 
            if( pITDA->u1.Ordinal == 0 ) // (terminating condition)
                break;

            if( g_bIsWin9X )
                pfnOld = ValidateAddress( pfnOld );

            pTopHookAPI = ConstructChain( (PVOID) pfnOld,&DllListIndex );
            

            if( ! pTopHookAPI )
            {
                pITDA++;
                continue;
            }                        


            /*
             * Check if we want to patch this API for this particular loaded module
             */
            if (NULL != g_rgnHookDllList[DllListIndex])
            {

                LPTSTR  pszMod = g_rgnHookDllList[DllListIndex];
                BOOL    b = FALSE;  //gets set to true if the list is an exclude list

                while (*pszMod != 0) {
                    if (lstrcmpi(pszMod, szModName) == 0)
                        break;
                    if(lstrcmpi(pszMod,TEXT("%")) == 0)
                        b=TRUE;
                    if(b && lstrcmpi(pszMod,TEXT("*")) == 0)
                    {
                        //this means it is exclude all and we already checked include list
                        //skip this api
                        break;
                    }                       
                    pszMod = pszMod + lstrlen(pszMod) + 1;
                }
                if(b && *pszMod != 0) 
                {
                    pITDA++;
                    continue;
                }
                if (!b && *pszMod == 0) 
                {
                    pITDA++;
                    continue;
                }
            }
            
            // Make the code page writable and overwrite new function pointer in import table
            if ( VirtualProtect(  &pITDA->u1.Function,
                                  sizeof(DWORD),
                                  PAGE_READWRITE,
                                  &dwOldProtect) )
            {
                pITDA->u1.Function = (ULONG) pTopHookAPI->pfnNew;
            
                VirtualProtect(   &pITDA->u1.Function,
                                  sizeof(DWORD),
                                  dwOldProtect,
                                  &dwTemp );
            }

            pITDA++;

        }

        pIID++;
    }

} // HookImports


////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   ResolveAPIs
//
//  Desc:   Each time a module is loaded, the pfnOld members of each HOOKAPI
//          structure in g_rgpHookAPIs are resolved (by calling GetProcAddress).
//
VOID ResolveAPIs()
{
    LONG            i, j;
    PVOID           pfnOld          = NULL;
    PIMAGE_NT_HEADERS NtHeaders;

    for (i = 0; i < g_nShimDllCount; i++) 
    {

        for (j = 0; j < g_rgnHookAPICount[i]; j++ ) 
        {

            HMODULE hMod;

            // We only care about HOOKAPIs at the bottom of a chain.
            if( ( g_rgpHookAPIs[i][j].dwFlags & HAF_RESOLVED ) &&
              ! ( g_rgpHookAPIs[i][j].dwFlags & HAF_BOTTOM_OF_CHAIN ) )
                continue;

            if( ( hMod = GetModuleHandle(g_rgpHookAPIs[i][j].pszModule) ) != NULL)
            {
            
                pfnOld = GetProcAddress( hMod, g_rgpHookAPIs[i][j].pszFunctionName );

                if( pfnOld == NULL ) 
                {
                
                    // This is an ERROR. The hook DLL asked to patch a function
                    // that doesn't exist !!!
                }
                else
                {                    
                    if( g_bIsWin9X )
                        pfnOld = ValidateAddress( pfnOld );

                    g_rgpHookAPIs[i][j].pfnOld = pfnOld;
                }
            }
        }
    }

} // ResolveAPIs

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   PatchNewModules
//
//  Desc:   This function is called at initialization and then each time a module
//          is loaded. It enumerates all loaded processes and calls HookImports
//          to overwrite appropriate function pointers.
//
void __stdcall Shim2PatchNewModules( VOID )
{
    DWORD   i;
    LONG    j;
    BOOL    bRet;
    HMODULE hMod;

    MODULEENTRY32 ModuleEntry32;

    // Enumerate all the loaded modules and hook their import tables
    g_hSnapshot = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, 0 );
    g_hValidationSnapshot = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, 0 );

    if( g_hSnapshot == NULL ) 
    {
        return;
    }

    // Resolve old APIs for loaded modules
    ResolveAPIs();
    
    ModuleEntry32.dwSize = sizeof( ModuleEntry32 );
    bRet = Module32First( g_hSnapshot, &ModuleEntry32 );

    while( bRet )
    {
        hMod = ModuleEntry32.hModule;

        if( hMod >= (HMODULE) 0x80000000 )
        {
            bRet = Module32Next( g_hSnapshot, &ModuleEntry32 );
            continue;
        }

        // we need to make sure we are not trying to shim ourselves
        for (j = 0; j < g_nShimDllCount; j++ )
        {
            if( hMod == g_hShimDlls[j] )
            {
                hMod = NULL;
                break;
            }
        }

        for (j = 0; j < g_nHookedModuleCount; j++ )
        {
            if( hMod == g_hHookedModules[ j ] )
            {
                hMod = NULL;
                break;
            }
        }

        if( hMod )
        {
            HookImports( (DWORD) hMod, ModuleEntry32.szModule );

            g_hHookedModules[ g_nHookedModuleCount++ ] = hMod;
        }

        bRet = Module32Next( g_hSnapshot, &ModuleEntry32 );
    }

    if( g_hSnapshot )
    {
        CloseHandle( g_hSnapshot );
        g_hSnapshot = NULL;
    }

    if( g_hValidationSnapshot )
    {
        CloseHandle( g_hValidationSnapshot );
        g_hValidationSnapshot = NULL;
    }
} //PatchNewModules

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   AddHookAPIs
//
//  Params: hShimDll            Handle of new shim DLL.
//
//          pHookAPIs           Pointer to new HOOKAPI array.
//
//          dwCount             Number of entries in pHookAPIs.
//
//  Desc:   Stores away the pointer returned by a shim DLL's GetHookAPIs
//          function in our global arrays.
//
void AddHookAPIs( HMODULE hShimDll, PHOOKAPI pHookAPIs, DWORD dwCount,LPTSTR szIncExclDllList)
{
    DWORD i;

    for( i = 0; i < dwCount; i++ )
    {
        pHookAPIs[i].dwFlags = 0;
        pHookAPIs[i].pNextHook = NULL;
    }

    g_rgpHookAPIs[ g_nShimDllCount ] = pHookAPIs;
    g_rgnHookAPICount[ g_nShimDllCount ] = dwCount;
    g_hShimDlls[ g_nShimDllCount ] = hShimDll;

    g_rgnHookDllList[g_nShimDllCount ] = szIncExclDllList;

    g_nShimDllCount++;
} // AddHookAPIs

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   _LoadPatchDll
//
//  Params: pwszPatchDll        Name of shim DLL to be loaded.
//
//  Return:                     TRUE if successful, FALSE if not.
//
//  Desc:   Loads a shim DLL and retrieves the hooking information via GetHookAPIs.
//
BOOL _LoadPatchDll(
    LPWSTR szPatchDll,LPSTR szCmdLine,LPSTR szIncExclDllList)
{
    PHOOKAPI pHookAPIs = NULL;
    DWORD dwHookAPICount = 0;
    HMODULE hModHookDll;
    PFNGETHOOKAPIS pfnGetHookAPIs;

    hModHookDll = LoadLibraryW(szPatchDll);

    if (hModHookDll == NULL) 
    {
        return FALSE;
    }
    
    pfnGetHookAPIs = (PFNGETHOOKAPIS) GetProcAddress( hModHookDll, SHIM_GETHOOKAPIS );

    if( pfnGetHookAPIs == NULL )
    {
        FreeLibrary( hModHookDll );
        return FALSE;
    }

    pHookAPIs = (*pfnGetHookAPIs)(szCmdLine, Shim2PatchNewModules, &dwHookAPICount );

    if( dwHookAPICount == 0  || pHookAPIs == NULL )
    {
        FreeLibrary( hModHookDll );
        return FALSE;
    }

    AddHookAPIs( hModHookDll, pHookAPIs, dwHookAPICount,szIncExclDllList);
    
    return TRUE;
} // _LoadPatchDll

// Re-enable build warnings.
#pragma warning( default : 4002 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\thread.c ===
#include <stdio.h>
#include <windows.h>
#include "view.h"
#include "thread.h"
#include "dump.h"
#include "except.h"
#include "memory.h"

extern BOOL g_bIsWin9X;
static CRITICAL_SECTION tCritSec;
static PTHREADFAULT pThreadHead = 0;

VOID
InitializeThreadData(VOID)
{
    InitializeCriticalSection(&tCritSec);
}

PVOID
GetProfilerThreadData(VOID)
{
    PVOID pData;
    PTHREADFAULT pTemp = 0;
    DWORD dwThreadId;

    dwThreadId = GetCurrentThreadId();

    EnterCriticalSection(&tCritSec);

    pTemp = pThreadHead;
    while(pTemp) {
       if (pTemp->dwThreadId == dwThreadId) {
          break;
       }

       pTemp = pTemp->pNext;
    }

    LeaveCriticalSection(&tCritSec);

    return pTemp;
}

VOID
SetProfilerThreadData(PVOID pData)
{
    PTHREADFAULT pTemp;

    EnterCriticalSection(&tCritSec);

    pTemp = (PTHREADFAULT)pData;

    pTemp->dwThreadId = GetCurrentThreadId();
    pTemp->pNext = pThreadHead;
    pThreadHead = pTemp;

    LeaveCriticalSection(&tCritSec);
}

PTHREADFAULT
AllocateProfilerThreadData(VOID)
{
    PTHREADFAULT pTemp = 0;

    pTemp = AllocMem(sizeof(THREADFAULT));
    if (0 == pTemp) {
       return 0;
    }

    pTemp->dwCallLevel = 0;
    pTemp->dwPrevBP = 0;
    pTemp->pCallStackList = 0;
    pTemp->dwCallMarker = 0;
    pTemp->pNext = 0;

    //
    // Set thread data
    //
    SetProfilerThreadData(pTemp);

    return pTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\shimhapi.h ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    shim.h
//
// History:    May-99   clupu       Created.
//             Aug-99   v-johnwh    Various bug fixes.
//          23-Nov-99   markder     Support for multiple shim DLLs, chaining
//                                  of hooks. General clean-up.
//          11-Feb-00   markder     Reverted to W2K shipped shim structures.
// 
// Desc:    Contains all structure and function definitions for the shim mechanism.
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __SHIM_H__
#define __SHIM_H__

typedef struct tagHOOKAPI {
    
    char*   pszModule;            // the name of the module
    char*   pszFunctionName;      // the name of the API in the module
    PVOID   pfnNew;               // pointer to the new stub API
    PVOID   pfnOld;               // pointer to the old API
    DWORD   dwFlags;              // used internally
    struct tagHOOKAPI *pNextHook; // used internally
} HOOKAPI, *PHOOKAPI;

/*
 * If the hook DLL ever patches LoadLibraryA/W it must call PatchNewModules
 * so that the shim knows to patch any new loaded DLLs
 */
typedef VOID (*PFNPATCHNEWMODULES)(VOID);

typedef PHOOKAPI (*PFNGETHOOKAPIS)(LPSTR pszCmdLine,
                                   PFNPATCHNEWMODULES pfnPatchNewModules,
                                   DWORD* pdwHooksCount);

#define SHIM_COMMAND_LINE_MAX_BUFFER 1024

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\thread.h ===
#ifndef _THREAD_H_
#define _THREAD_H_

//
// Constant declarations
//

//
// Structure definitions
//
typedef struct _THREADFAULT
{
  DWORD dwCallLevel;
  DWORD dwPrevBP;
  BPType prevBPType;
  PVOID pCallStackList;
  DWORD dwCallMarker;
  DWORD dwThreadId;
  struct _THREADFAULT *pNext;
} THREADFAULT, *PTHREADFAULT;

//
// Function definitions
//
PVOID
GetProfilerThreadData(VOID);

VOID
SetProfilerThreadData(PVOID pData);

PTHREADFAULT
AllocateProfilerThreadData(VOID);

VOID
InitializeThreadData(VOID);

#endif //_THREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\makediff\dump.h ===
#ifndef _DUMP_H_
#define _DUMP_H_

typedef enum _DUMPTYPES
{
    ThreadStartId = 0,
    ExeFlowId,
    DllBaseInfoId,
    MapInfoId,
    ErrorInfoId,
} DUMPTYPES;

//
// Structure definitions
//
typedef struct _THREADSTART
{
    DUMPTYPES dwType;
    DWORD dwThreadId;
    DWORD dwStartAddress;
} THREADSTART, *PTHREADSTART;

typedef struct _EXEFLOW
{
    DUMPTYPES dwType;
    DWORD dwThreadId;
    DWORD dwAddress;
    DWORD dwCallLevel;
} EXEFLOW, *PEXEFLOW;

typedef struct _DLLBASEINFO
{
    DUMPTYPES dwType;
    DWORD dwBase;
    DWORD dwLength;
    CHAR  szDLLName[32];
} DLLBASEINFO, *PDLLBASEINFO;

typedef struct _MAPINFO
{
    DUMPTYPES dwType;
    DWORD dwAddress;
    DWORD dwMaxMapLength;
} MAPINFO, *PMAPINFO;

typedef struct _ERRORINFO
{
    DWORD dwType;
    CHAR szMessage[MAX_PATH];
} ERRORINFO, *PERRORINFO;

#endif //_DUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\view.c ===
#include <windows.h>
#include <stdio.h>
#include "view.h"
#include "except.h"
#include "disasm.h"
#include "dump.h"
#include "profiler.h"
#include "memory.h"
#include "filter.h"

static PVIEWCHAIN *ppViewHead = 0;
static CRITICAL_SECTION viewCritSec;
static CRITICAL_SECTION mapCritSec;
static PTAGGEDADDRESS pTagHead = 0;
static PBRANCHADDRESS pBranchHead = 0;

BOOL
InitializeViewData(VOID)
{
    InitializeCriticalSection(&viewCritSec);
    InitializeCriticalSection(&mapCritSec); 

    //
    // Allocate hashing data
    //
    ppViewHead = (PVIEWCHAIN *)AllocMem(sizeof(PVIEWCHAIN) * (MAX_MAP_SIZE >> MAP_STRIDE_BITS));
    if (0 == ppViewHead) {
       return FALSE;
    }

    return TRUE;
}

PVIEWCHAIN
AddViewToMonitor(DWORD dwAddress,
                 BPType bpType)
{
    PVIEWCHAIN pView;
    DWORD dwHash;

    //
    // If address is higher than the map size, fail it
    //
    if (dwAddress >= MAX_MAP_SIZE) {
       return 0;
    }

    //
    // This occurs when a call tries to map over an existing trace breakpoint
    //
    if (*(BYTE *)dwAddress == X86_BREAKPOINT) {
       return 0;
    }

    //
    // Check if we're filtering this address
    //
    if (TRUE == IsAddressFiltered(dwAddress)) {
       return 0;
    }

    //
    // Allocate a chain entry
    //
    pView = AllocMem(sizeof(VIEWCHAIN));
    if (0 == pView) {
       return 0;
    }

    pView->bMapped = FALSE;
    pView->bTraced = FALSE;
    pView->dwAddress = dwAddress;
    pView->dwMapExtreme = dwAddress;
    pView->jByteReplaced = *(BYTE *)dwAddress;
    pView->bpType = bpType;

    //
    // Set a breakpoint at the top of the code
    //
    WRITEBYTE(dwAddress, X86_BREAKPOINT);

    EnterCriticalSection(&viewCritSec);

    //
    // Add view point to monitor list
    //
    dwHash = dwAddress >> MAP_STRIDE_BITS;
    if (0 == ppViewHead[dwHash]) {
       ppViewHead[dwHash] = pView;
    }
    else {
       //
       // Chain to head
       //
       pView->pNext = ppViewHead[dwHash];
       ppViewHead[dwHash] = pView;
    }

    LeaveCriticalSection(&viewCritSec);

    return pView;
}

PVIEWCHAIN
RestoreAddressFromView(DWORD dwAddress,
                       BOOL bResetData)
{
    BOOL bResult = FALSE;
    PVIEWCHAIN pTemp;

    EnterCriticalSection(&viewCritSec);

    pTemp = ppViewHead[dwAddress >> MAP_STRIDE_BITS];
    while (pTemp) {
        //
        // Is this our entry
        //
        if (dwAddress == pTemp->dwAddress) {
           //
           // Set a breakpoint at the top of the code
           //
           if (TRUE == bResetData) {
              WRITEBYTE(dwAddress, pTemp->jByteReplaced);
           }
           else {
              WRITEBYTE(dwAddress, X86_BREAKPOINT);
           }

           //
           // Return with modified data
           //
           break;
        }

        pTemp = pTemp->pNext;
    }

    LeaveCriticalSection(&viewCritSec);
    
    return pTemp;
}

PVIEWCHAIN
FindView(DWORD dwAddress) {
    PVIEWCHAIN pTemp;

    if (dwAddress >= MAX_MAP_SIZE) {
       return 0;
    }

    EnterCriticalSection(&viewCritSec);

    pTemp = ppViewHead[dwAddress >> MAP_STRIDE_BITS];
    while (pTemp) {
        //
        // See if address is mapped
        //
        if (dwAddress == pTemp->dwAddress) {
           LeaveCriticalSection(&viewCritSec);

           return pTemp;
        }

        pTemp = pTemp->pNext;
    }

    LeaveCriticalSection(&viewCritSec);

    return 0;
}

BOOL
MapCode(PVIEWCHAIN pvMap) {
    BOOL bResult;
    DWORD dwCurrent;
    DWORD *pdwAddress;
    DWORD *pdwTemp;
    PCHAR pCode;
    PVIEWCHAIN pvTemp;
    DWORD dwLength;
    DWORD dwJumpEIP;
    LONG lOffset;
    DWORD dwInsLength;
    DWORD dwTemp;
    BYTE  tempCode[32];
    BYTE  jOperand;
    DWORD dwProfileEnd = 0;
    CHAR szBuffer[MAX_PATH];

    //
    // Map termination through all conditionals
    //
    dwCurrent = pvMap->dwAddress;

    //
    // Take the mapping lock
    //
    LockMapper();

    //
    // Forward scan through code to find termination
    //
    while(1) {
       strncpy(tempCode, (PCHAR)dwCurrent, 32);

       //
       // Make sure the instruction is unmodified
       //
       if (tempCode[0] == (BYTE)X86_BREAKPOINT) {
          //
          // Rebuild instruction without breakpoints
          //
          pvTemp = FindView(dwCurrent);
          if (pvTemp) {
             //
             // Replace the bytes if we have a match
             //
             tempCode[0] = pvTemp->jByteReplaced;
          }
       }

       //
       // Calculate instruction length
       //
       dwInsLength = GetInstructionLengthFromAddress((PVOID)tempCode);

       //
       // Follow a forward trace through jumps to the ret
       //
       if ((tempCode[0] >= (BYTE)0x70) && (tempCode[0] <= (BYTE)0x7f)) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Relative branch
          //
          dwJumpEIP = (dwCurrent + 2 + (CHAR)(tempCode[1]));

          //
          // Mark this branch as executed
          //
          bResult = AddTaggedAddress(dwCurrent);
          if (FALSE == bResult) {
             return FALSE;
          }

          if (dwJumpEIP > dwCurrent) {
             //
             // Push the opposite branch
             //
             bResult = PushBranch(dwCurrent + dwInsLength);
             if (FALSE == bResult) {
                return FALSE;
             }

             dwCurrent = dwJumpEIP;
          }
          else {
             //
             // Push the opposite branch
             //
             bResult = PushBranch(dwJumpEIP);
             if (FALSE == bResult) {
                return FALSE;
             }

             dwCurrent += dwInsLength;
          }

          continue;
       }

       if (tempCode[0] == (BYTE)0x0f) {
          if ((tempCode[1] >= (BYTE)0x80) && (tempCode[1] <= (BYTE)0x8f)) {
             //
             // Update the end of the region marker
             //
             if (dwCurrent > dwProfileEnd) {
                dwProfileEnd = dwCurrent;
             }

             //
             // Relative branch
             //
             dwJumpEIP = (dwCurrent + 6 + *(LONG *)(&(tempCode[2])));             

             //
             // Mark this branch as executed
             //
             bResult = AddTaggedAddress(dwCurrent);
             if (FALSE == bResult) {
                return FALSE;
             }

             if (dwJumpEIP > dwCurrent) {
                //
                // Push the opposite branch
                //
                bResult = PushBranch(dwCurrent + dwInsLength);
                if (FALSE == bResult) {
                   return FALSE;
                }
 
                dwCurrent = dwJumpEIP;
             }
             else {
                //
                // Push the opposite branch
                //
                bResult = PushBranch(dwJumpEIP);
                if (FALSE == bResult) {
                   return FALSE;
                }

                dwCurrent += dwInsLength;
             }

             continue;
          }
       }

       if (tempCode[0] == (BYTE)0xe3) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Relative branch
          //
          dwJumpEIP = (dwCurrent + 2 + (CHAR)(tempCode[1]));

          //
          // Mark this branch as executed
          //
          bResult = AddTaggedAddress(dwCurrent);
          if (FALSE == bResult) {
             return FALSE;
          }

          if (dwJumpEIP > dwCurrent) {
             //
             // Push the opposite branch
             //
             bResult = PushBranch(dwCurrent + dwInsLength);
             if (FALSE == bResult) {
                return FALSE;
             }

             dwCurrent = dwJumpEIP;
          }
          else {
             //
             // Push the opposite branch
             //
             bResult = PushBranch(dwJumpEIP);
             if (FALSE == bResult) {
                return FALSE;
             }

             dwCurrent += dwInsLength;
          }

          continue;
       }

       if (tempCode[0] == (BYTE)0xeb) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Jump relative
          //
          dwJumpEIP = (dwCurrent + 2 + (CHAR)(tempCode[1]));

          //
          // Mark this branch as executed
          //
          bResult = AddTaggedAddress(dwCurrent);
          if (FALSE == bResult) {
             return FALSE;
          }
          
          //
          // Jmp must always be followed
          //
          dwCurrent = dwJumpEIP;
          continue;
       }

       if (tempCode[0] == (BYTE)0xe9) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Jump relative
          //
          dwJumpEIP = (dwCurrent + 5 + *(LONG *)(&(tempCode[1])));

          //
          // Mark this branch as executed
          //
          bResult = AddTaggedAddress(dwCurrent);
          if (FALSE == bResult) {
             return FALSE;
          }
          
          //
          // Jump must always be followed
          //
          dwCurrent = dwJumpEIP;
          continue;
       }
       
       //
       // Probe for calls and jumps
       //
       if (tempCode[0] == (BYTE)0xff) {
          //
          // Tests for whether this is a call or not
          //
          jOperand = (tempCode[1] >> 3) & 7;
          if ((jOperand == 2) || 
              (jOperand == 3) ||
              (jOperand == 4) ||
              (jOperand == 5)) {
             //
             // Update the end of the region marker
             //
             if (dwCurrent > dwProfileEnd) {
                dwProfileEnd = dwCurrent;
             }

             //
             // Add our mapping breakpoint with the appropriate type
             //
             if ((jOperand == 2) ||
                 (jOperand == 3)) {
                 pvTemp = AddViewToMonitor(dwCurrent,
                                           Call);
                 if (pvTemp) {
                    pvTemp->bMapped = TRUE;
                 }
             }
             else {
                 //
                 // These kinds of jumps are always a break (there's no way to forward trace them)
                 //
                 pvTemp = AddViewToMonitor(dwCurrent,
                                           Jump);
                 if (pvTemp) {
                    pvTemp->bMapped = TRUE;
                 }
                 else {
                    //
                    // Special case for mapping breakpoints which really are just jumps
                    //
                    pvTemp = FindView(dwCurrent);
                    if (pvTemp) {
                       pvTemp->bMapped = TRUE;
                       pvTemp->bpType = Jump;
                    }
                 }
          
                 //
                 // Mark this branch as executed
                 //
                 bResult = AddTaggedAddress(dwCurrent);
                 if (FALSE == bResult) {
                    return FALSE;
                 }

                 //
                 // Dump the tree
                 //
                 dwTemp = PopBranch();
                 if (dwTemp) {
                    dwCurrent = dwTemp;
                    continue;
                 }

                 break;
             }
          }
       }

       if (tempCode[0] == (BYTE)0xe8) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Add this top call to the view
          //
          pvTemp = AddViewToMonitor(dwCurrent,
                                    Call);
          if (pvTemp) {
             pvTemp->bMapped = TRUE;
          }
       }

       if (tempCode[0] == (BYTE)0x9a) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Add this top call to the view
          //
          pvTemp = AddViewToMonitor(dwCurrent,
                                    Call);
          if (pvTemp) {
             pvTemp->bMapped = TRUE;
          }
       }

       if (tempCode[0] == (BYTE)0xea) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Absolute far jumps are a terminating condition - flush all branches
          //
          pvTemp = AddViewToMonitor(dwCurrent,
                                    Jump);
          if (pvTemp) {
             pvTemp->bMapped = TRUE;
          }
          
          //
          // Mark this branch as executed
          //
          bResult = AddTaggedAddress(dwCurrent);
          if (FALSE == bResult) {
             return FALSE;
          }

          //
          // Dump the tree
          //
          dwTemp = PopBranch();
          if (dwTemp) {
             dwCurrent = dwTemp;
             continue;
          }

          break;
       }

       if (*(WORD *)(&(tempCode[0])) == 0xffff) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // This is also a trace path terminator - see if we need to trace more conditions
          //
          dwTemp = PopBranch();
          if (dwTemp) {
             //
             // We have a branch to follow
             //
             dwCurrent = dwTemp;
             continue;
          }

          //
          // Update the end of the address range
          //
          break;
       }

       if (tempCode[0] == (BYTE)0xc3) {
          //
          // This is also a trace path terminator - see if we need to trace more conditions
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }
          
          dwTemp = PopBranch();
          if (dwTemp) {
             //
             // We have a branch to follow
             //
             dwCurrent = dwTemp;
             continue;
          }

          break;
       }

       if (tempCode[0] == (BYTE)0xc2) {
          //
          // This is also a trace path terminator - see if we need to trace more conditions
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }
          
          dwTemp = PopBranch();
          if (dwTemp) {
             //
             // We have a branch to follow
             //
             dwCurrent = dwTemp;
             continue;
          }

          break;
       } 

       dwCurrent += dwInsLength;
    }    

    if (dwProfileEnd) {
       pvMap->dwMapExtreme = dwProfileEnd;
    }
    else {
       pvMap->dwMapExtreme = dwCurrent;
    }

    bResult = WriteMapInfo(pvMap->dwAddress,
                           pvMap->dwMapExtreme);
    if (!bResult) {
       return FALSE;
    }

    //
    // Restore the code we've whacked around
    //
    bResult = RestoreTaggedAddresses();
    if (FALSE == bResult) {
       return FALSE;
    }

    //
    // Assert if this _ever_ happens
    //
    if (pBranchHead != 0) {
       Sleep(20000);
       _asm int 3
    }

    //
    // We're mapped
    //
    pvMap->bMapped = TRUE;

    //
    // Release the mapping lock
    //
    UnlockMapper();

    return TRUE;    
}

//
// Trace helpers
//
BOOL
AddTaggedAddress(DWORD dwAddress)
{
    PTAGGEDADDRESS pTagTemp;
    DWORD dwTempAddress;

    //
    // Make sure we haven't addressed this tag
    //
    if (*(WORD *)dwAddress == 0xFFFF) {
       //
       // No need since it's already tagged
       //
       return TRUE;
    }

    //
    // Store off the bytes we are tagging
    //
    pTagTemp = AllocMem(sizeof(TAGGEDADDRESS));
    if (0 == pTagTemp) {
       return FALSE;
    }

    pTagTemp->dwAddress = dwAddress;
    pTagTemp->wBytesReplaced = *(WORD *)dwAddress;

    //
    // Chain the entry
    //
    if (0 == pTagHead) {
       pTagHead = pTagTemp;
    }
    else {
       pTagTemp->pNext = pTagHead;
       pTagHead = pTagTemp;
    }

    //
    // Mark this branch as executed
    //
    WRITEWORD(dwAddress, 0xFFFF);
    
    return TRUE;
}

BOOL
RestoreTaggedAddresses(VOID)
{
    PTAGGEDADDRESS pTagTemp;
    PTAGGEDADDRESS pTagTemp2;

    //
    // Walk the tag list and replace the marked branches with their original bytes
    //
    pTagTemp = pTagHead;
    while(pTagTemp) {
        //
        // Dirty up the code now so the branches can auto terminate
        //
        WRITEWORD(pTagTemp->dwAddress, pTagTemp->wBytesReplaced);

        pTagTemp2 = pTagTemp;

        pTagTemp = pTagTemp->pNext;

        //
        // Dump the old allocated memory
        //
        FreeMem(pTagTemp2);
    }

    pTagHead = 0;
    
    return TRUE;
}

BOOL
PushBranch(DWORD dwAddress)
{
    PBRANCHADDRESS pBranchTemp;

    pBranchTemp = AllocMem(sizeof(BRANCHADDRESS));
    if (0 == pBranchTemp) {
       return FALSE;
    }

    pBranchTemp->dwAddress = dwAddress;

    if (0 == pBranchHead) {
       pBranchHead = pBranchTemp;
    }
    else {
       pBranchTemp->pNext = pBranchHead;
       pBranchHead = pBranchTemp;
    }

    return TRUE;
}

DWORD
PopBranch(VOID)
{
    PBRANCHADDRESS pBranchTemp;
    DWORD dwAddress = 0;

    pBranchTemp = pBranchHead;

    if (0 == pBranchTemp) {
       return 0;
    }

    dwAddress = pBranchTemp->dwAddress;
    pBranchHead = pBranchHead->pNext;

    FreeMem(pBranchTemp);

    return dwAddress;
}

VOID
LockMapper(VOID)
{
    EnterCriticalSection(&mapCritSec);
}

VOID
UnlockMapper(VOID)
{
    LeaveCriticalSection(&mapCritSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\makediff\main.h ===
#ifndef _MAIN_H_
#define _MAIN_H_

//
// Structure definitions
//
typedef struct _BASEINFO
{
	CHAR szModule[32];
	DWORD dwStartAddress;
	DWORD dwEndAddress;
	struct _BASEINFO *pNext;
} BASEINFO, *PBASEINFO;

typedef struct _THREADINFO
{
	DWORD dwThreadId;
	HANDLE hFile;
	struct _THREADINFO *pNext;
} THREADINFO, *PTHREADINFO;

//
// Function definitions
//
VOID
CloseThreadHandles(VOID);

BOOL
ProcessRuntimeData(PCHAR pszFile, PCHAR pszBaseFileName);

BOOL
FillBufferWithRelocationInfo(PCHAR pszDestination,
							 DWORD dwAddress);

BOOL
AddThreadInformation(PCHAR pszBaseFileName,
					 PTHREADSTART pThreadStart);

BOOL
AddExeFlowInformation(PEXEFLOW pExeFlow);

BOOL
AddToBaseInformation(PDLLBASEINFO pDLLBaseInfo);

BOOL
AddMappedInformation(PCHAR pszBaseFileName,
					 PMAPINFO pMapInfo);

BOOL
AddErrorInformation(PCHAR pszBaseFileName,
					PERRORINFO pErrorInfo);

#endif //_MAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\view.h ===
#ifndef _VIEW_H_
#define _VIEW_H_

//
// Constant declarations
//
#define X86_BREAKPOINT 0xcc

#define MAX_MAP_SIZE    0x80000000
#define MAP_STRIDE_BITS 10

typedef enum
{
  None = 0,
  Call,
  Jump,
  Map,
  ThreadStart,
} BPType;

//
// Structure definitions
//
typedef struct _VIEWCHAIN
{
  BOOL bMapped;
  BOOL bTraced;
  BPType bpType;
  DWORD dwAddress;
  DWORD dwMapExtreme;
  BYTE jByteReplaced;
  struct _VIEWCHAIN *pNext;
} VIEWCHAIN, *PVIEWCHAIN;

//
// Macros
//
#define WRITEBYTE(x, y) \
{                    \
{                                   \
DWORD dwOldProtect;  \
                     \
VirtualProtect((LPVOID)(x),  \
               sizeof(BYTE), \
               PAGE_READWRITE, \
               &dwOldProtect); \
*(PBYTE)(x) = (y);   \
}                    \
                     \
}

#define WRITEWORD(x, y) \
{                    \
{                                   \
DWORD dwOldProtect;  \
                     \
VirtualProtect((LPVOID)(x),  \
               sizeof(WORD), \
               PAGE_READWRITE, \
               &dwOldProtect); \
*(WORD *)(x) = (y);   \
}                    \
                     \
}


/*
#define WRITEBYTE(x, y) \
{                    \
__try                \
{                    \
*(PBYTE)(x) = (y);   \
}                    \
__except(EXCEPTION_EXECUTE_HANDLER) \
{                                   \
DWORD dwOldProtect;  \
                     \
VirtualProtect((LPVOID)(x),  \
               sizeof(BYTE), \
               PAGE_READWRITE, \
               &dwOldProtect); \
*(PBYTE)(x) = (y);   \
}                    \
                     \
}

#define WRITEWORD(x, y) \
{                    \
__try                \
{                    \
*(WORD *)(x) = (y);   \
}                    \
__except(EXCEPTION_EXECUTE_HANDLER) \
{                                   \
DWORD dwOldProtect;  \
                     \
VirtualProtect((LPVOID)(x),  \
               sizeof(WORD), \
               PAGE_READWRITE, \
               &dwOldProtect); \
*(WORD *)(x) = (y);   \
}                    \
                     \
}
*/

//
// Structure definitions
//
typedef struct _TAGGEDADDRESS
{
  DWORD dwAddress;
  WORD wBytesReplaced;
  struct _TAGGEDADDRESS *pNext;
} TAGGEDADDRESS, *PTAGGEDADDRESS;

typedef struct _BRANCHADDRESS
{
  DWORD dwAddress;
  struct _BRANCHADDRESS *pNext;
} BRANCHADDRESS, *PBRANCHADDRESS;

//
// Function definitions
//
PVIEWCHAIN
AddViewToMonitor(DWORD dwAddress,
                 BPType bpType);

BOOL
InitializeViewData(VOID);

PVIEWCHAIN
RestoreAddressFromView(DWORD dwAddress,
                       BOOL bResetData);

PVIEWCHAIN
FindMappedView(DWORD dwAddress);

PVIEWCHAIN
FindView(DWORD dwAddress);

BOOL
MapCode(PVIEWCHAIN pvMap);

BOOL
PushBranch(DWORD dwAddress);

DWORD
PopBranch(VOID);

BOOL
AddTaggedAddress(DWORD dwAddress);

BOOL
RestoreTaggedAddresses(VOID);

VOID
LockMapper(VOID);

VOID
UnlockMapper(VOID);

#endif //_VIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\vxd\debug.c ===
#include <basedef.h>
#include <vmm.h>
#include <vwin32.h>

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

VOID
DbgPrint(PCHAR pszString)
{
    _asm pushfd                              ; save flags on stack
    _asm pushad                              ; save registers on stack
    _asm mov esi,pszString                   ; points to string to write
    VMMCall( Out_Debug_String );
    _asm popad
    _asm popfd
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\vxd\dispatch.c ===
#include <basedef.h>
#include <vmm.h>
#include <vwin32.h>
#include "ntddpack.h"
#include "except.h"
#include "exvector.h"

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

extern PVOID C_Handle_Trap_1;
extern PVOID C_Handle_Trap_3;
extern DWORD pfnHandler;
extern PVOID pProcessHandle;

BOOL
DriverControl(DWORD dwMessage)
{
    switch (dwMessage)
    {
        case 0:
             _asm mov eax, 1
             _asm mov esi, offset C_Handle_Trap_1
             VMMCall( Hook_PM_Fault );

             _asm mov eax, 3
             _asm mov esi, offset C_Handle_Trap_3
             VMMCall( Hook_PM_Fault );

             break;

        case 1:
             _asm mov eax, 1
             _asm mov esi, offset C_Handle_Trap_1
             VMMCall( Unhook_PM_Fault );
   
             _asm mov eax, 3
             _asm mov esi, offset C_Handle_Trap_3
             VMMCall( Unhook_PM_Fault );
             
             break;

        default:
             0;
    }

    return STATUS_SUCCESS;
}

DWORD 
_stdcall 
DriverIOControl(DWORD dwService,
                DWORD dwDDB,
                DWORD hDevice,
                PDIOCPARAMETERS pDiocParms) 
/*++

Routine Description:

    This is the dispatch routine for create/open and close requests.
    These requests complete successfully.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{  
    PVOID pInputParams;

    switch ( dwService )
    {
	case DIOC_OPEN:
             //
             // Nothing to do
             //
	     break;

	case DIOC_CLOSEHANDLE:
             //
             // If our client for the except handler is going away, initialize the exception handler data
             //
             if (pProcessHandle == VWIN32_GetCurrentProcessHandle()) {
                pfnHandler = 0;
                pProcessHandle = 0;                
             }

             break;
 
        case INSTALL_RING_3_HANDLER:
             //
             // See if we already have a client
             //
             if (pProcessHandle) {
                return STATUS_UNSUCCESSFUL;
             }

             pProcessHandle = VWIN32_GetCurrentProcessHandle();

             //
             // Copy the handler into our global
             //
             pInputParams = (PVOID)(pDiocParms->lpvInBuffer);
             _asm mov eax, pInputParams
             _asm mov eax, [eax]
             _asm mov pfnHandler, eax

             break;

        default:   
             //
             // Error, Unrecognized IOCTL
             //
	     *(DWORD *)(pDiocParms->lpcbBytesReturned) = 0;

	     break;
    }

    return STATUS_SUCCESS;
}

//
// Helper function for maintaining context information between ring levels
//
VOID
FillContextRecord(PCRS pcrs,
                  PCONTEXT pContext)
{
    DWORD dwDebugRegister;

    //
    // Clear trace and direction flags for the exception dispatcher
    //
    pcrs->Client_EFlags &= ~(TF_MASK | DF_MASK);

    //
    // Fill context record
    //
    pContext->Eax = pcrs->Client_EAX;
    pContext->Ebx = pcrs->Client_EBX;
    pContext->Ecx = pcrs->Client_ECX;
    pContext->Edx = pcrs->Client_EDX;
    pContext->Esi = pcrs->Client_ESI;
    pContext->Edi = pcrs->Client_EDI;
    pContext->Eip = pcrs->Client_EIP;
    pContext->Ebp = pcrs->Client_EBP;
    pContext->Esp = pcrs->Client_ESP;
    pContext->SegGs = pcrs->Client_GS;
    pContext->SegFs = pcrs->Client_FS;
    pContext->SegEs = pcrs->Client_ES;
    pContext->SegDs = pcrs->Client_DS;
    pContext->SegCs = pcrs->Client_CS;
    pContext->EFlags = pcrs->Client_EFlags;

    //
    // Store the debug registers
    //
    _asm mov eax, dr0
    _asm mov dwDebugRegister, eax
    pContext->Dr0 = dwDebugRegister;
    _asm mov eax, dr1
    _asm mov dwDebugRegister, eax
    pContext->Dr1 = dwDebugRegister;
    _asm mov eax, dr2
    _asm mov dwDebugRegister, eax
    pContext->Dr2 = dwDebugRegister;
    _asm mov eax, dr3
    _asm mov dwDebugRegister, eax
    pContext->Dr3 = dwDebugRegister;
    _asm mov eax, dr6
    _asm mov dwDebugRegister, eax
    pContext->Dr6 = dwDebugRegister;
    _asm mov eax, dr7
    _asm mov dwDebugRegister, eax
    pContext->Dr7 = dwDebugRegister;

    //
    // This is a full context
    //
    pContext->ContextFlags = (DWORD)-1;
}

VOID
RestorePCRS(PCRS pcrs,
            PCONTEXT pContext)
{
    DWORD dwDebugRegister;

    //
    // Restore pcrs
    //
    pcrs->Client_EAX = pContext->Eax;
    pcrs->Client_EBX = pContext->Ebx;
    pcrs->Client_ECX = pContext->Ecx;
    pcrs->Client_EDX = pContext->Edx;
    pcrs->Client_ESI = pContext->Esi;
    pcrs->Client_EDI = pContext->Edi;
    pcrs->Client_EIP = pContext->Eip;
    pcrs->Client_EBP = pContext->Ebp;
    pcrs->Client_ESP = pContext->Esp;
    pcrs->Client_GS = pContext->SegGs;
    pcrs->Client_FS = pContext->SegFs;
    pcrs->Client_ES = pContext->SegEs;
    pcrs->Client_DS = pContext->SegDs;
    pcrs->Client_CS = pContext->SegCs;
    pcrs->Client_EFlags = pContext->EFlags;

    //
    // Restore the debug registers
    //
    dwDebugRegister = pContext->Dr0;
    _asm mov eax, dwDebugRegister
    _asm mov dr0, eax
    dwDebugRegister = pContext->Dr1;
    _asm mov eax, dwDebugRegister
    _asm mov dr1, eax
    dwDebugRegister = pContext->Dr2;
    _asm mov eax, dwDebugRegister
    _asm mov dr2, eax
    dwDebugRegister = pContext->Dr3;
    _asm mov eax, dwDebugRegister
    _asm mov dr3, eax
    dwDebugRegister = pContext->Dr6;
    _asm mov eax, dwDebugRegister
    _asm mov dr6, eax
    dwDebugRegister = pContext->Dr7;
    _asm mov eax, dwDebugRegister
    _asm mov dr7, eax
}

//
// Exception dispatching routine
//
BOOL
__cdecl
C_Trap_Exception_Handler(ULONG ExceptionNumber,
                         PCRS pcrs)
{
    DWORD dwException = ExceptionNumber >> 2;
    PEXCEPTION_RECORD pExceptionRecord;
    PCONTEXT pContextRecord;
    PSTACKFRAME pStackFrame;
    ULONG Result;
    ULONG StackTop;
    ULONG Length;

    //
    // Make sure our current thread is Win32
    //
    if (FALSE == VWIN32_IsClientWin32()) {
       return FALSE;
    }

    //
    // Make sure we only handle exceptions for our controlling "process"
    //
    if (pProcessHandle != VWIN32_GetCurrentProcessHandle()) {
       return FALSE;
    }

    //
    // If selector isn't flat, we can't handle this exception
    //
    if ((pcrs->Client_SS != pcrs->Client_DS) ||
        (pcrs->Client_SS != pcrs->Client_ES)){
       return FALSE;
    }

    //
    // See if this is a context set
    //
    if (SET_CONTEXT == *(DWORD *)(pcrs->Client_EIP)) {
       //
       // Set the context data
       //
       pContextRecord = *(DWORD *)(pcrs->Client_ESP + 0x10);
  
       RestorePCRS(pcrs,
                   pContextRecord);
           
       return TRUE;
    }

    //
    // Move stack pointer down one context record length
    //
    StackTop = (pcrs->Client_ESP & ~3) - ((sizeof(CONTEXT) + 3) & ~3);
    pContextRecord = (PCONTEXT) StackTop;

    FillContextRecord(pcrs,
                      pContextRecord);

    //
    // Adjust eip for breakpoint exceptions
    //
    if (3 == dwException) {
       pContextRecord->Eip -= 1;
    }

    Length = (sizeof(EXCEPTION_RECORD) - (EXCEPTION_MAXIMUM_PARAMETERS - 2) *
             sizeof(*pExceptionRecord->ExceptionInformation) + 3) & ~3;

    //
    // We are now at the Exception Record
    //
    StackTop = StackTop - Length;
    pExceptionRecord = (PEXCEPTION_RECORD)StackTop;

    pExceptionRecord->ExceptionFlags = 0;
    pExceptionRecord->ExceptionRecord = 0;
    pExceptionRecord->ExceptionAddress = (PVOID)pcrs->Client_EIP;
    pExceptionRecord->NumberParameters = 0;

    switch (dwException) {
        case 1:
            pExceptionRecord->ExceptionCode = STATUS_SINGLE_STEP;
            break;

        case 3:
            pExceptionRecord->ExceptionCode = STATUS_BREAKPOINT;
            pExceptionRecord->NumberParameters = 1;
            pExceptionRecord->ExceptionInformation[0] = BREAKPOINT_BREAK;
            pExceptionRecord->ExceptionAddress = (PVOID)pContextRecord->Eip;            
            break;

        default:
            0;
    }

    //
    // Setup the exception call frame
    //
    StackTop = StackTop - sizeof(STACKFRAME);
    pStackFrame = (PSTACKFRAME) StackTop;

    pStackFrame->ExceptPointers.ExceptionRecord = pExceptionRecord;
    pStackFrame->ExceptPointers.ContextRecord = pContextRecord;
    pStackFrame->pExceptPointers = (PVOID)(StackTop + 0x08);
    pStackFrame->RetAddress = (PVOID)0xffecbad7;  // App will page fault out if unexpected exception occurs

    //
    // Transfer control to Ring 3 handler
    //
    pcrs->Client_ESP = (ULONG)pStackFrame;
    pcrs->Client_EIP = (ULONG)pfnHandler;

    return TRUE;

SkipHandler:

    //
    // We didn't process the exception give it to the next handler
    //
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\makediff\main.c ===
#include <windows.h>
#include <stdio.h>
#include "dump.h"
#include "main.h"

PBASEINFO g_BaseHead = 0;
PTHREADINFO g_ThreadHead = 0;
DWORD g_dwThreadCount = 0;
HANDLE g_MapInformation = INVALID_HANDLE_VALUE;
HANDLE g_ErrorInformation = INVALID_HANDLE_VALUE;

int
_cdecl
main(int argc, char *argv[])
{
    PCHAR pszFile;
    PCHAR pszBaseFileName;
    BOOL bResult;

    if (argc < 3) {
	   return -1;
    }

    pszFile = argv[1]; //1st parameter
    pszBaseFileName = argv[2]; //2nd parameter

    bResult = ProcessRuntimeData(pszFile, pszBaseFileName);
    if (FALSE == bResult) {
       return -1;
    }

    //
    // Close any open file handles
    //
    if (INVALID_HANDLE_VALUE != g_MapInformation) {
       CloseHandle(g_MapInformation);
    }

    if (INVALID_HANDLE_VALUE != g_ErrorInformation) {
       CloseHandle(g_ErrorInformation);
    }

    CloseThreadHandles();

    return 0;
}

BOOL
ProcessRuntimeData(PCHAR pszFile, PCHAR pszBaseFileName)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = 0;
    BOOL bResult = FALSE;
    PVOID pFileBits = 0;
    PBYTE pMappedBits;
    LONG lFileSize;
	 
    //
    // Get our file online and start the data processing
    //
    hFile = CreateFileA(pszFile,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        0,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        0);						
    if (INVALID_HANDLE_VALUE == hFile) {
       bResult = FALSE;

       goto HandleError;
    }

    lFileSize = GetFileSize(hFile,
	                    0);

    //
    // Process the data stream
    //
    hMap = CreateFileMapping(hFile,
	                     0,
                             PAGE_READWRITE,
                             0,
                             0,
                             0);
    if (0 == hMap) {
       bResult = FALSE;

       goto HandleError;
    }

    pFileBits = MapViewOfFile(hMap,
	                      FILE_MAP_READ,
                              0,
                              0,
                              0);
    if (0 == pFileBits) {
       bResult = FALSE;

       goto HandleError;
    }

    pMappedBits = (PBYTE)pFileBits;

    //
    // Process stream data
    //
    while (lFileSize > 0) {
        switch(*pMappedBits) {
	        case ThreadStartId:
				bResult = AddThreadInformation(pszBaseFileName,
					                           (PTHREADSTART)pMappedBits);
				if (FALSE == bResult) {
				   goto HandleError;
				}

				lFileSize -= sizeof(THREADSTART);
				pMappedBits += sizeof(THREADSTART);
			    break;

		    case ExeFlowId:
				bResult = AddExeFlowInformation((PEXEFLOW)pMappedBits);
			//	if (FALSE == bResult) {
			//	   goto HandleError;
			//	}

				lFileSize -= sizeof(EXEFLOW);
				pMappedBits += sizeof(EXEFLOW);
			    break;

		    case DllBaseInfoId:
				bResult = AddToBaseInformation((PDLLBASEINFO)pMappedBits);
				if (FALSE == bResult) {
				   goto HandleError;
				}
				
				lFileSize -= sizeof(DLLBASEINFO);
				pMappedBits += sizeof(DLLBASEINFO);
			    break;

		    case MapInfoId:
				bResult = AddMappedInformation(pszBaseFileName,
					                           (PMAPINFO)pMappedBits);
				if (FALSE == bResult) {
				   goto HandleError;
				}

				lFileSize -= sizeof(MAPINFO);
				pMappedBits += sizeof(MAPINFO);
			    break;

		    case ErrorInfoId:
				bResult = AddErrorInformation(pszBaseFileName,
					                          (PERRORINFO)pMappedBits);
				if (FALSE == bResult) {
				   goto HandleError;
				}

				lFileSize -= sizeof(ERRORINFO);
				pMappedBits += sizeof(ERRORINFO);
			    break;

		    default:
			    0;
		}
    }

	//
	// No problems in processing log
	//
	bResult = TRUE;

HandleError:
	
	if (pFileBits) {
	   UnmapViewOfFile(pFileBits);
	}

	if (hMap) {
	   CloseHandle(hMap);
	}

	if (INVALID_HANDLE_VALUE != hFile) {
	   CloseHandle(hFile);
	}
    
	return bResult;
}

BOOL
AddThreadInformation(PCHAR pszBaseFileName,
					 PTHREADSTART pThreadStart)
{
	PTHREADINFO ptTemp = 0;
	BOOL bResult;
	DWORD dwBytesWritten;
	CHAR szBuffer[MAX_PATH];
	CHAR szAddress[MAX_PATH];

	//
	// Allocate some memory for the new thread data
	//
	ptTemp = LocalAlloc(LPTR,
		                sizeof(THREADINFO));
	if (0 == ptTemp) {
	   return FALSE;
	}

	//
	// Initialize file data
	//
	ptTemp->dwThreadId = pThreadStart->dwThreadId;

	sprintf(szBuffer,"%s.thread%ld", pszBaseFileName, g_dwThreadCount);
    ptTemp->hFile = CreateFileA(szBuffer,
                                GENERIC_READ | GENERIC_WRITE,
					            0,
					            0,
					            CREATE_ALWAYS,
					            FILE_ATTRIBUTE_NORMAL,
					            0);
	if (INVALID_HANDLE_VALUE == ptTemp->hFile) {
	   return FALSE;
	}
	
	//
	// Add thread base information to new thread log
	//
	bResult = FillBufferWithRelocationInfo(szAddress, 
		                                   pThreadStart->dwStartAddress);
	if (FALSE == bResult) {
	   return bResult;
	}

	sprintf(szBuffer,"Thread started at %s\r\n", szAddress);
    
	bResult = WriteFile(ptTemp->hFile,
		                szBuffer,
						strlen(szBuffer),
						&dwBytesWritten,
						0);
	if (FALSE == bResult) {
	   return FALSE;
	}

	//
	// Chain up thread data
	//
	if (0 == g_ThreadHead) {
	   ptTemp->pNext = 0;
	   g_ThreadHead = ptTemp;
	}
	else {
	   ptTemp->pNext = g_ThreadHead;
	   g_ThreadHead = ptTemp;
	}

	return TRUE;
}

VOID
CloseThreadHandles(VOID)
{
    PTHREADINFO ptTemp = 0;

	ptTemp = g_ThreadHead;

	while(ptTemp) {
		if (ptTemp->hFile != INVALID_HANDLE_VALUE) {
		   CloseHandle(ptTemp->hFile);
		}

		ptTemp = ptTemp->pNext;
	}
}

BOOL
AddExeFlowInformation(PEXEFLOW pExeFlow)
{
	PTHREADINFO ptTemp = 0;
	BOOL bResult;
	DWORD dwBytesWritten;
	CHAR szAddress[MAX_PATH];
	CHAR szBuffer[MAX_PATH];

	//
	// Locate thread for this point of execution
	//
	ptTemp = g_ThreadHead;
	while(ptTemp) {
		if (ptTemp->dwThreadId == pExeFlow->dwThreadId) {
			break;
		}

		ptTemp = ptTemp->pNext;
	}

	if (0 == ptTemp) {
	   //
	   // Couldn't locate thread info
	   //
	   return FALSE;
	}

  	bResult = FillBufferWithRelocationInfo(szAddress, 
		                                   pExeFlow->dwAddress);
	if (FALSE == bResult) {
	   return bResult;
	}  

	sprintf(szBuffer, "%s : %ld\r\n", szAddress, pExeFlow->dwCallLevel);

    bResult = WriteFile(ptTemp->hFile,
		                szBuffer,
						strlen(szBuffer),
						&dwBytesWritten,
						0);
	if (FALSE == bResult) {
	   return FALSE;
	}

	return TRUE;
}

BOOL
AddErrorInformation(PCHAR pszBaseFileName,
					PERRORINFO pErrorInfo)
{
	BOOL bResult;
	DWORD dwBytesWritten;
	CHAR szBuffer[MAX_PATH];

	if (INVALID_HANDLE_VALUE == g_ErrorInformation) {
	   strcpy(szBuffer, pszBaseFileName);
	   strcat(szBuffer, ".err");

	   g_ErrorInformation = CreateFileA(szBuffer,
                                        GENERIC_READ | GENERIC_WRITE,
						                0,
						                0,
						                CREATE_ALWAYS,
						                FILE_ATTRIBUTE_NORMAL,
						                0);
	   if (INVALID_HANDLE_VALUE == g_ErrorInformation) {
		  return FALSE;
	   }               
	}

	//
	// Write out error message
	//
    bResult = WriteFile(g_ErrorInformation,
		                pErrorInfo->szMessage,
						strlen(pErrorInfo->szMessage),
						&dwBytesWritten,
						0);
	if (FALSE == bResult) {
	   return FALSE;
	}

	return TRUE;
}

BOOL
AddMappedInformation(PCHAR pszBaseFileName,
					 PMAPINFO pMapInfo)
{
	BOOL bResult;
	CHAR szBuffer[MAX_PATH];
	CHAR szAddress[MAX_PATH];
	CHAR szAddress2[MAX_PATH];
	DWORD dwBytesWritten;

	if (INVALID_HANDLE_VALUE == g_MapInformation) {
	   strcpy(szBuffer, pszBaseFileName);
	   strcat(szBuffer, ".map");

	   g_MapInformation = CreateFileA(szBuffer,
                                      GENERIC_READ | GENERIC_WRITE,
						              0,
						              0,
						              CREATE_ALWAYS,
						              FILE_ATTRIBUTE_NORMAL,
						              0);
	   if (INVALID_HANDLE_VALUE == g_MapInformation) {
		  return FALSE;
	   }               
	}

	//
	// Write out the mapping information
	//
	bResult = FillBufferWithRelocationInfo(szAddress, 
		                                   pMapInfo->dwAddress);
	if (FALSE == bResult) {
	   return bResult;
	}

	bResult = FillBufferWithRelocationInfo(szAddress2, 
		                                   pMapInfo->dwMaxMapLength);
	if (FALSE == bResult) {
	   return bResult;
	}

	sprintf(szBuffer, "%s -> %s\r\n", szAddress, szAddress2);

    bResult = WriteFile(g_MapInformation,
		                szBuffer,
						strlen(szBuffer),
						&dwBytesWritten,
						0);
	if (FALSE == bResult) {
	   return FALSE;
	}

	return TRUE;
}

BOOL
FillBufferWithRelocationInfo(PCHAR pszDestination,
							 DWORD dwAddress)
{
	PBASEINFO pTemp;

	//
	// Find the address in the module info
	//
	pTemp = g_BaseHead;
    while (pTemp) {
		//
		// Did we find the address?
		//
        if ((dwAddress >= pTemp->dwStartAddress) &&
            (dwAddress <= pTemp->dwEndAddress)) {
		   break;
		}

		pTemp = pTemp->pNext;
	}

	if (pTemp) {
	   sprintf(pszDestination, "%s+%08X", pTemp->szModule, (dwAddress - pTemp->dwStartAddress));
	}
	else {
	   sprintf(pszDestination, "%08X", dwAddress);
	}

	return TRUE;
}

BOOL
AddToBaseInformation(PDLLBASEINFO pDLLBaseInfo)
{
	PBASEINFO pTemp;

	if (0 == g_BaseHead) {
	   //
	   // Store off the base information
	   //
	   pTemp = LocalAlloc(LPTR,
		                  sizeof(BASEINFO));
	   if (0 == pTemp) {
		  return FALSE;
	   }
 
	   pTemp->dwStartAddress = pDLLBaseInfo->dwBase;
	   pTemp->dwEndAddress = pTemp->dwStartAddress + pDLLBaseInfo->dwLength;
	   strcpy(pTemp->szModule, pDLLBaseInfo->szDLLName);
	   _strupr(pTemp->szModule);

	   pTemp->pNext = 0;

	   g_BaseHead = pTemp;
	}
	else {
	   //
	   // See if our module has already been mapped, and if so update module base info
	   //
       pTemp = g_BaseHead;

	   while(pTemp) {
		   if (0 == _stricmp(pDLLBaseInfo->szDLLName, pTemp->szModule)) {
			  break;
		   }

		   pTemp = pTemp->pNext;
	   }

	   if (pTemp) {
		   //
		   // Found the DLL already in the list, update
		   //
           pTemp->dwStartAddress = pDLLBaseInfo->dwBase;
	       pTemp->dwEndAddress = pTemp->dwStartAddress + pDLLBaseInfo->dwLength;
	   }
	   else {
		    //
     	    // New DLL
	        //
	        pTemp = LocalAlloc(LPTR,
		                       sizeof(BASEINFO));
	        if (0 == pTemp) {
		       return FALSE;
			}

	        pTemp->dwStartAddress = pDLLBaseInfo->dwBase;
	        pTemp->dwEndAddress = pTemp->dwStartAddress + pDLLBaseInfo->dwLength;
	        strcpy(pTemp->szModule, pDLLBaseInfo->szDLLName);
            _strupr(pTemp->szModule);

			//
			// Chain up the new DLL
			//
			pTemp->pNext = g_BaseHead;
			g_BaseHead = pTemp;
	   }
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\vxd\exvector.asm ===
.LALL

    TITLE $EXVECTOR
    .386P

INCLUDE VMM.INC
INCLUDE EXVECTOR.INC

; the following equate makes the VXD dynamically loadable.
%DEVICE_DYNAMIC EQU 1

DECLARE_VIRTUAL_DEVICE %DEVICE, 1, 0, <%DEVICE>_Control, Undefined_Device_Id, Vmm_init_order

;
; LData
;
VxD_LOCKED_DATA_SEG

Public bInitAlready	
	bInitAlready	 DB 0
Public _pPrevHook1
	_pPrevHook1      DD 0
Public _pPrevHook3
	_pPrevHook3      DD 0
Public _pfnHandler
	_pfnHandler      DD 0
Public _pProcessHandle
        _pProcessHandle  DD 0

VxD_LOCKED_DATA_ENDS


;
; LCode
;
VxD_LOCKED_CODE_SEG

Begin_Control_Dispatch %DEVICE

    Control_Dispatch Sys_Dynamic_Device_Init,	_C_Device_Init
    Control_Dispatch Sys_Dynamic_Device_Exit,	_C_Device_Exit
    Control_Dispatch W32_DEVICEIOCONTROL,    	DriverIOControl, sCall, <ecx, ebx, edx, esi>

End_Control_Dispatch %DEVICE

BeginProc _C_Device_Init

IFDEF _STDCALL
	extern _DriverControl@4:NEAR
ELSE
	extern _DriverControl:NEAR
ENDIF

   mov  		al, bInitAlready
   cmp  		al, 0					; Make sure we' haven't been called already.
   jnz  		Succeed_Init_Phase
   inc  		bInitAlready			; Set the "Called Already" Flag

   push 		0

IFDEF _STDCALL
   call 		_DriverControl@4
ELSE
   call 		_DriverControl
   add  		esp,4
ENDIF

   cmp  		eax, 1
   jz  		        Fail_Init_Phase

Succeed_Init_Phase:
   clc
   ret

Fail_Init_Phase:
   stc
   ret

EndProc _C_Device_Init
 
BeginProc _C_Device_Exit

IFDEF _STDCALL
	extern _DriverControl@4:NEAR
ELSE
	extern _DriverControl:NEAR
ENDIF

   push 		1

IFDEF _STDCALL
   call 		_DriverControl@4
ELSE
   call 		_DriverControl
   add  		esp,4
ENDIF

   cmp  		eax, 1
   jz  		        Fail_Exit_Phase

Succeed_Exit_Phase:
   clc
   ret

Fail_Exit_Phase:
   stc
   ret

EndProc _C_Device_Exit

BeginProc _C_Handle_Trap_1, HOOK_PROC, _pPrevHook1, LOCKED

    extern _C_Trap_Exception_Handler:NEAR

    pushfd
    pushad

    cli

    cCall _C_Trap_Exception_Handler, <esi, ebp>

    sti

    cmp eax, 0
    jnz Trap1_Handled

    ;Try the next handler
    cmp [_pPrevHook1], 0
    jz Trap1_Handled

    ;Here we go
    popad
    popfd
    jmp [_pPrevHook1]
    
Trap1_Handled:
    popad
    popfd
    ret
EndProc _C_Handle_Trap_1

BeginProc _C_Handle_Trap_3, HOOK_PROC, _pPrevHook3, LOCKED

    extern _C_Trap_Exception_Handler:NEAR

    pushfd
    pushad

    cli

    cCall _C_Trap_Exception_Handler, <esi, ebp>

    sti

    cmp eax, 0
    jnz Trap3_Handled

    ;Try the next handler
    cmp [_pPrevHook3], 0
    jz Trap3_Handled

    ;Here we go
    popad
    popfd
    jmp [_pPrevHook3]
    
Trap3_Handled:
    popad
    popfd
    ret
EndProc _C_Handle_Trap_3

VxD_LOCKED_CODE_ENDS

;
; Not using IData or ICode
;

;
; Or RCode
;

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\vxd\except.h ===
#ifndef _EXCEPT_
#define _EXCEPT_

typedef LONG (*PFNUNHANDLEDEXCEPTION)(struct _EXCEPTION_POINTERS *ExceptionInfo);
#define EXCEPTION_MAXIMUM_PARAMETERS 15 // maximum number of exception parameters
#define SIZE_OF_80387_REGISTERS      80
#define MAXIMUM_SUPPORTED_EXTENSION     512
#define BREAKPOINT_BREAK 0

typedef struct _FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[SIZE_OF_80387_REGISTERS];
    DWORD   Cr0NpxState;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;

//
// Context Frame
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} CONTEXT;

typedef CONTEXT *PCONTEXT;

//
// Exception record definition.
//

typedef struct _EXCEPTION_RECORD {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    UINT ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;

typedef struct _STACKFRAME {
  PVOID RetAddress;
  PVOID pExceptPointers;
  EXCEPTION_POINTERS ExceptPointers;
} STACKFRAME, *PSTACKFRAME;

#define STATUS_WAIT_0                    ((DWORD   )0x00000000L)    
#define STATUS_ABANDONED_WAIT_0          ((DWORD   )0x00000080L)    
#define STATUS_USER_APC                  ((DWORD   )0x000000C0L)    
#define STATUS_TIMEOUT                   ((DWORD   )0x00000102L)    
#define STATUS_PENDING                   ((DWORD   )0x00000103L)    
#define STATUS_SEGMENT_NOTIFICATION      ((DWORD   )0x40000005L)    
#define STATUS_GUARD_PAGE_VIOLATION      ((DWORD   )0x80000001L)    
#define STATUS_DATATYPE_MISALIGNMENT     ((DWORD   )0x80000002L)    
#define STATUS_BREAKPOINT                ((DWORD   )0x80000003L)    
#define STATUS_SINGLE_STEP               ((DWORD   )0x80000004L)    
#define STATUS_ACCESS_VIOLATION          ((DWORD   )0xC0000005L)    
#define STATUS_IN_PAGE_ERROR             ((DWORD   )0xC0000006L)    
#define STATUS_INVALID_HANDLE            ((DWORD   )0xC0000008L)    
#define STATUS_NO_MEMORY                 ((DWORD   )0xC0000017L)    
#define STATUS_ILLEGAL_INSTRUCTION       ((DWORD   )0xC000001DL)    
#define STATUS_NONCONTINUABLE_EXCEPTION  ((DWORD   )0xC0000025L)    
#define STATUS_INVALID_DISPOSITION       ((DWORD   )0xC0000026L)    
#define STATUS_ARRAY_BOUNDS_EXCEEDED     ((DWORD   )0xC000008CL)    
#define STATUS_FLOAT_DENORMAL_OPERAND    ((DWORD   )0xC000008DL)    
#define STATUS_FLOAT_DIVIDE_BY_ZERO      ((DWORD   )0xC000008EL)    
#define STATUS_FLOAT_INEXACT_RESULT      ((DWORD   )0xC000008FL)    
#define STATUS_FLOAT_INVALID_OPERATION   ((DWORD   )0xC0000090L)    
#define STATUS_FLOAT_OVERFLOW            ((DWORD   )0xC0000091L)    
#define STATUS_FLOAT_STACK_CHECK         ((DWORD   )0xC0000092L)    
#define STATUS_FLOAT_UNDERFLOW           ((DWORD   )0xC0000093L)    
#define STATUS_INTEGER_DIVIDE_BY_ZERO    ((DWORD   )0xC0000094L)    
#define STATUS_INTEGER_OVERFLOW          ((DWORD   )0xC0000095L)    
#define STATUS_PRIVILEGED_INSTRUCTION    ((DWORD   )0xC0000096L)    
#define STATUS_STACK_OVERFLOW            ((DWORD   )0xC00000FDL)    
#define STATUS_CONTROL_C_EXIT            ((DWORD   )0xC000013AL)    
#define STATUS_FLOAT_MULTIPLE_FAULTS     ((DWORD   )0xC00002B4L)    
#define STATUS_FLOAT_MULTIPLE_TRAPS      ((DWORD   )0xC00002B5L)    
#define STATUS_ILLEGAL_VLM_REFERENCE     ((DWORD   )0xC00002C0L)     

/*
 *  EFLAGs bit assignments
 */
#define CF_BIT	    0
#define CF_MASK     (1 << CF_BIT)
#define PF_BIT	    2
#define PF_MASK     (1 << PF_BIT)
#define AF_BIT	    4
#define AF_MASK     (1 << AF_BIT)
#define ZF_BIT	    6
#define ZF_MASK     (1 << ZF_BIT)
#define SF_BIT	    7
#define SF_MASK     (1 << SF_BIT)
#define TF_BIT	    8
#define TF_MASK     (1 << TF_BIT)
#define IF_BIT	    9
#define IF_MASK     (1 << IF_BIT)
#define DF_BIT	    10
#define DF_MASK     (1 << DF_BIT)
#define OF_BIT	    11	/* Overflow flag */
#define OF_MASK     (1 << OF_BIT)
#define IOPL_MASK   0x3000  /* IOPL flags */
#define IOPL_BIT0   12
#define IOPL_BIT1   13
#define NT_BIT	    14	/* Nested task flag */
#define NT_MASK     (1 << NT_BIT)
#define RF_BIT	    16	/* Resume flag */
#define RF_MASK     (1 << RF_BIT)
#define VM_BIT	    17	/* Virtual Mode flag */
#define VM_MASK     (1 << VM_BIT)
#define AC_BIT	    18	/* Alignment check */
#define AC_MASK     (1 << AC_BIT)
#define VIF_BIT     19	/* Virtual Interrupt flag */
#define VIF_MASK    (1 << VIF_BIT)
#define VIP_BIT     20	/* Virtual Interrupt pending */
#define VIP_MASK    (1 << VIP_BIT)

#endif  //_EXCEPT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\vxd\exvector.h ===
#ifndef _EXVECTOR_
#define _EXVECTOR_

#define NDIS_WIN     1
#define EXPORT

/* NOINC */

#ifndef _STDCALL
#define _STDCALL    1
#endif

#ifdef _STDCALL
#define _API __stdcall
#else
#define _API
#endif

//
//    Segment definition macros.  These assume the segment groupings used by
//    Chicago/MS-DOS 7.
//

#define _LCODE code_seg("_LTEXT", "LCODE")
#define _LDATA data_seg("_LDATA", "LCODE")


#ifdef DEBUG
    #define _PCODE NDIS_LCODE
    #define _PDATA NDIS_LDATA
#else
    #define _PCODE code_seg("_PTEXT", "PCODE")
    #define _PDATA data_seg("_PDATA", "PCODE")
#endif

#define _ICODE NDIS_PCODE
#define _IDATA NDIS_PDATA

#ifndef _SEG_MACROS
    #define ICODE   NDIS_ICODE
    #define IDATA   NDIS_IDATA
    #define PCODE   NDIS_PCODE
    #define PDATA   NDIS_PDATA
    #define LCODE   NDIS_LCODE
    #define LDATA   NDIS_LDATA
#endif

#define _INIT_FUNCTION(f)       alloc_text(_ITEXT,f)
#define _PAGEABLE_FUNCTION(f)   alloc_text(_PTEXT,f)
#define _LOCKED_FUNCTION(f)     alloc_text(_LTEXT,f)

/* INC */
#define _MAJOR_VERSION          0x01
#define _MINOR_VERSION          0x00
/* NOINC */

/* INC */
/* ASM
;===========================================================================
;    Segment definition macros.  These assume the segment groupings used by
;    Chicago/MS-DOS 7.
;
;===========================================================================

LCODE_SEG   TEXTEQU <VXD_LOCKED_CODE_SEG>
LCODE_ENDS  TEXTEQU <VXD_LOCKED_CODE_ENDS>
LDATA_SEG   TEXTEQU <VXD_LOCKED_DATA_SEG>
LDATA_ENDS  TEXTEQU <VXD_LOCKED_DATA_ENDS>

IFDEF DEBUG
    PCODE_SEG   TEXTEQU <LCODE_SEG>
    PCODE_ENDS  TEXTEQU <LCODE_ENDS>
    PDATA_SEG   TEXTEQU <LDATA_SEG>
    PDATA_ENDS  TEXTEQU <LDATA_ENDS>
ELSE
	PCODE_SEG   TEXTEQU <VXD_PAGEABLE_CODE_SEG>
	PCODE_ENDS  TEXTEQU <VXD_PAGEABLE_CODE_ENDS>
	PDATA_SEG   TEXTEQU <VXD_PAGEABLE_DATA_SEG>
	PDATA_ENDS  TEXTEQU <VXD_PAGEABLE_DATA_ENDS>
ENDIF

ICODE_SEG   TEXTEQU <PCODE_SEG>
ICODE_ENDS  TEXTEQU <PCODE_ENDS>
IDATA_SEG   TEXTEQU <PDATA_SEG>
IDATA_ENDS  TEXTEQU <PDATA_ENDS>


*/

#ifndef i386
#define i386
#endif

/* NOINC */

#ifdef DEBUG
    #define DEVL             1
#endif

/* INC */

#ifndef TRUE
#define TRUE  1
#define FALSE 0
#endif

/* NOINC */
#include <basedef.h>

#define ASSERT(a)       if (!(a)) DbgBreakPoint()

#ifdef DEBUG
#define DbgBreakPoint() __asm { \
			 __asm int  3 \
			 }
void __cdecl DbgPrint();
#define DBG_PRINTF(A) DbgPrint A
#else
#define DbgBreakPoint()
#define DBG_PRINTF(A)
#endif

//
// Macros required by DOS to compensate for differences with NT.
//

#define IN
#define OUT
#define OPTIONAL
#define INTERNAL
#define UNALIGNED

typedef INT NDIS_SPIN_LOCK, * PNDIS_SPIN_LOCK;

typedef UCHAR BOOLEAN, *PBOOLEAN;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

typedef signed short WCH, *PWCH;

typedef char CCHAR, *PCCHAR;

typedef PVOID NDIS_HANDLE, *PNDIS_HANDLE;

typedef DWORD                   DEVNODE;

typedef ULONG _STATUS;
typedef _STATUS *_PSTATUS;

// BUGBUG for compatibility with NT, ask them to remove it from
// Their drivers
typedef _STATUS NTSTATUS;
typedef CCHAR KIRQL;
typedef KIRQL *PKIRQL;
#define HIGH_LEVEL 31
#define PDRIVER_OBJECT PVOID
#define PUNICODE_STRING PVOID
#define PDEVICE_OBJECT PVOID
#define PKDPC PVOID

#define STATUS_SUCCESS 0
#define STATUS_UNSUCCESSFUL 0xC0000001
#define INSTALL_RING_3_HANDLER 0x42424242
#define SET_CONTEXT 0xc3c3c3cc

BOOL
VXDINLINE
VWIN32_IsClientWin32( VOID )
{
	VxDCall( _VWIN32_IsClientWin32 );
}

PVOID
VXDINLINE
VWIN32_GetCurrentProcessHandle( VOID )
{
	VxDCall( VWIN32_GetCurrentProcessHandle );
}

PVOID
VXDINLINE
VWIN32_Set_Thread_Context(PVOID pR0ThreadHandle,
                          PCONTEXT pContext)
{
	VxDCall( _VWIN32_Set_Thread_Context );
}

#endif  // _EXVECTOR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\vxd\exvector.inc ===
ifndef _EXVECT_

_EXVECT_	EQU	1

EXVECT_WIN	EQU	1
EXPORT	EQU	1
EXVECT_MAJOR_VERSION	EQU	01H
EXVECT_MINOR_VERSION	EQU	00H

LCODE_SEG   TEXTEQU <VXD_LOCKED_CODE_SEG>
LCODE_ENDS  TEXTEQU <VXD_LOCKED_CODE_ENDS>
LDATA_SEG   TEXTEQU <VXD_LOCKED_DATA_SEG>
LDATA_ENDS  TEXTEQU <VXD_LOCKED_DATA_ENDS>

IFDEF DEBUG
    PCODE_SEG   TEXTEQU <LCODE_SEG>
    PCODE_ENDS  TEXTEQU <LCODE_ENDS>
    PDATA_SEG   TEXTEQU <LDATA_SEG>
    PDATA_ENDS  TEXTEQU <LDATA_ENDS>
ELSE
    PCODE_SEG   TEXTEQU <VXD_PAGEABLE_CODE_SEG>
    PCODE_ENDS  TEXTEQU <VXD_PAGEABLE_CODE_ENDS>
    PDATA_SEG   TEXTEQU <VXD_PAGEABLE_DATA_SEG>
    PDATA_ENDS  TEXTEQU <VXD_PAGEABLE_DATA_ENDS>
ENDIF

ICODE_SEG   TEXTEQU <PCODE_SEG>
ICODE_ENDS  TEXTEQU <PCODE_ENDS>
IDATA_SEG   TEXTEQU <PDATA_SEG>
IDATA_ENDS  TEXTEQU <PDATA_ENDS>

HIGH_LEVEL	EQU	31
PDRIVER_OBJECT	EQU	<PVOID>
PUNICODE_STRING	EQU	<PVOID>
PDEVICE_OBJECT	EQU	<PVOID>
PKDPC	EQU	<PVOID>
STATUS_SUCCESS EQU 0

ifndef i386
i386	EQU	1
endif

ifndef TRUE
TRUE	EQU	1
FALSE	EQU	0
endif

endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\vxd\inc\ntddpack.h ===
#ifndef __NTDDPACKET
#define __NTDDPACKET 1

#include <devioctl.h>

#include <packon.h>

typedef struct _PACKET_OID_DATA 
{
    ULONG           Oid;
    ULONG           Length;
    UCHAR           Data[1];
}   
PACKET_OID_DATA, *PPACKET_OID_DATA;

#include <packoff.h>

#define FILE_DEVICE_PROTOCOL        0x8000


#define IOCTL_PROTOCOL_QUERY_OID    CTL_CODE(FILE_DEVICE_PROTOCOL, 0 , METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PROTOCOL_SET_OID      CTL_CODE(FILE_DEVICE_PROTOCOL, 1 , METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PROTOCOL_STATISTICS   CTL_CODE(FILE_DEVICE_PROTOCOL, 2 , METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PROTOCOL_RESET        CTL_CODE(FILE_DEVICE_PROTOCOL, 3 , METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PROTOCOL_READ         CTL_CODE(FILE_DEVICE_PROTOCOL, 4 , METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PROTOCOL_WRITE        CTL_CODE(FILE_DEVICE_PROTOCOL, 5 , METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PROTOCOL_MACNAME      CTL_CODE(FILE_DEVICE_PROTOCOL, 6 , METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\vxd\inc\devioctl.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    devioctl.h

Revision History:


--*/

// begin_winioctl

#ifndef _DEVIOCTL_
#define _DEVIOCTL_

// begin_ntddk begin_nthal begin_ntifs
//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

// end_ntddk end_nthal end_ntifs

#endif // _DEVIOCTL_

// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\vxd\inc\packon.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    packon.h

Abstract:

    This file turns packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    The file packoff.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(_lint))

#ifdef i386
#pragma warning(disable:4103)
#endif
#pragma pack(1)                 // x86, MS compiler; MIPS, MIPS compiler
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\profiler\vxd\inc\packoff.h ===
/*++

Copyright (c) 1990-95  Microsoft Corporation

Module Name:

    packoff.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    packoff.h is the complement to packon.h.  An inclusion of packoff.h
    MUST ALWAYS be preceded by an inclusion of packon.h, in one-to-one
    correspondence.

--*/

#if ! (defined(lint) || defined(_lint))

#ifdef i386
#pragma warning(disable:4103)
#endif
#pragma pack()                  // x86, MS compiler; MIPS, MIPS compiler
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\psapi\psapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    psapi.h

Abstract:

    Include file for APIs provided by PSAPI.DLL

Author:

    Richard Shupak   [richards]  06-Jan-1994

Revision History:

--*/

#ifndef _PSAPI_H_
#define _PSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

BOOL
WINAPI
EnumProcesses(
    DWORD * lpidProcess,
    DWORD   cb,
    DWORD * cbNeeded
    );

BOOL
WINAPI
EnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    );

DWORD
WINAPI
GetModuleBaseNameA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleBaseNameW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleBaseName  GetModuleBaseNameW
#else
#define GetModuleBaseName  GetModuleBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetModuleFileNameExA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleFileNameEx  GetModuleFileNameExW
#else
#define GetModuleFileNameEx  GetModuleFileNameExA
#endif // !UNICODE


typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;


BOOL
WINAPI
GetModuleInformation(
    HANDLE hProcess,
    HMODULE hModule,
    LPMODULEINFO lpmodinfo,
    DWORD cb
    );


BOOL
WINAPI
EmptyWorkingSet(
    HANDLE hProcess
    );


BOOL
WINAPI
QueryWorkingSet(
    HANDLE hProcess,
    PVOID pv,
    DWORD cb
    );

BOOL
WINAPI
InitializeProcessForWsWatch(
    HANDLE hProcess
    );


typedef struct _PSAPI_WS_WATCH_INFORMATION {
    LPVOID FaultingPc;
    LPVOID FaultingVa;
} PSAPI_WS_WATCH_INFORMATION, *PPSAPI_WS_WATCH_INFORMATION;

BOOL
WINAPI
GetWsChanges(
    HANDLE hProcess,
    PPSAPI_WS_WATCH_INFORMATION lpWatchInfo,
    DWORD cb
    );

DWORD
WINAPI
GetMappedFileNameW(
    HANDLE hProcess,
    LPVOID lpv,
    LPWSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetMappedFileNameA(
    HANDLE hProcess,
    LPVOID lpv,
    LPSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetMappedFileName  GetMappedFileNameW
#else
#define GetMappedFileName  GetMappedFileNameA
#endif // !UNICODE

BOOL
WINAPI
EnumDeviceDrivers(
    LPVOID *lpImageBase,
    DWORD cb,
    LPDWORD lpcbNeeded
    );


DWORD
WINAPI
GetDeviceDriverBaseNameA(
    LPVOID ImageBase,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverBaseNameW(
    LPVOID ImageBase,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameW
#else
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetDeviceDriverFileNameA(
    LPVOID ImageBase,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverFileNameW(
    LPVOID ImageBase,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverFileName  GetDeviceDriverFileNameW
#else
#define GetDeviceDriverFileName  GetDeviceDriverFileNameA
#endif // !UNICODE

// Structure for GetProcessMemoryInfo()

typedef struct _PROCESS_MEMORY_COUNTERS {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
} PROCESS_MEMORY_COUNTERS;
typedef PROCESS_MEMORY_COUNTERS *PPROCESS_MEMORY_COUNTERS;

#if (_WIN32_WINNT >= 0x0501)

typedef struct _PROCESS_MEMORY_COUNTERS_EX {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivateUsage;
} PROCESS_MEMORY_COUNTERS_EX;
typedef PROCESS_MEMORY_COUNTERS_EX *PPROCESS_MEMORY_COUNTERS_EX;

#endif

BOOL
WINAPI
GetProcessMemoryInfo(
    HANDLE Process,
    PPROCESS_MEMORY_COUNTERS ppsmemCounters,
    DWORD cb
    );

typedef struct _PERFORMANCE_INFORMATION {
    DWORD cb;
    SIZE_T CommitTotal;
    SIZE_T CommitLimit;
    SIZE_T CommitPeak;
    SIZE_T PhysicalTotal;
    SIZE_T PhysicalAvailable;
    SIZE_T SystemCache;
    SIZE_T KernelTotal;
    SIZE_T KernelPaged;
    SIZE_T KernelNonpaged;
    SIZE_T PageSize;
    DWORD HandleCount;
    DWORD ProcessCount;
    DWORD ThreadCount;
} PERFORMANCE_INFORMATION, *PPERFORMANCE_INFORMATION, PERFORMACE_INFORMATION, *PPERFORMACE_INFORMATION;

BOOL
WINAPI
GetPerformanceInfo (
    PPERFORMACE_INFORMATION pPerformanceInformation,
    DWORD cb
    );

typedef struct _ENUM_PAGE_FILE_INFORMATION {
    DWORD cb;
    DWORD Reserved;
    SIZE_T TotalSize;
    SIZE_T TotalInUse;
    SIZE_T PeakUsage;
} ENUM_PAGE_FILE_INFORMATION, *PENUM_PAGE_FILE_INFORMATION;

typedef BOOL (*PENUM_PAGE_FILE_CALLBACKW) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCWSTR lpFilename);

typedef BOOL (*PENUM_PAGE_FILE_CALLBACKA) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCSTR lpFilename);

BOOL
WINAPI
EnumPageFilesW (
    PENUM_PAGE_FILE_CALLBACKW pCallBackRoutine,
    LPVOID pContext
    );

BOOL
WINAPI
EnumPageFilesA (
    PENUM_PAGE_FILE_CALLBACKA pCallBackRoutine,
    LPVOID pContext
    );

#ifdef UNICODE
#define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKW
#define EnumPageFiles EnumPageFilesW
#else
#define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKA
#define EnumPageFiles EnumPageFilesA
#endif // !UNICODE

DWORD
WINAPI
GetProcessImageFileNameA(
    HANDLE hProcess,
    LPSTR lpImageFileName,
    DWORD nSize
    );

DWORD
WINAPI
GetProcessImageFileNameW(
    HANDLE hProcess,
    LPWSTR lpImageFileName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetProcessImageFileName  GetProcessImageFileNameW
#else
#define GetProcessImageFileName  GetProcessImageFileNameA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\psapi\driver.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "psapi.h"

#include <stddef.h>

BOOL
FindDeviceDriver(
    LPVOID ImageBase,
    PRTL_PROCESS_MODULE_INFORMATION Module
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    ImageBase - Identifies the driver whose executable file name is being
        requested.

Return Value:

    A return value of FALSE indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    NTSTATUS Status;
    DWORD cbModuleInformation, cbModuleInformationNew, NumberOfModules;
    PRTL_PROCESS_MODULES pModuleInformation;
    DWORD i, ReturnedLength;

    //
    // Set the buffer length and pointer to a fixed size for the first pass
    //

    cbModuleInformation = sizeof (RTL_PROCESS_MODULES) + 0x400;
    pModuleInformation = NULL;

    while (1) {

        pModuleInformation = LocalAlloc (LMEM_FIXED, cbModuleInformation);

        if (pModuleInformation == NULL) {
            SetLastError (ERROR_NO_SYSTEM_RESOURCES);
            return FALSE;
        }

        Status = NtQuerySystemInformation (SystemModuleInformation,
                                           pModuleInformation,
                                           cbModuleInformation,
                                           &ReturnedLength);

        NumberOfModules = pModuleInformation->NumberOfModules;

        if (NT_SUCCESS(Status)) {
            break;
        } else {

            LocalFree (pModuleInformation);
            
            if (Status == STATUS_INFO_LENGTH_MISMATCH) {
                ASSERT (cbModuleInformation >= sizeof (RTL_PROCESS_MODULES));

                cbModuleInformationNew = FIELD_OFFSET (RTL_PROCESS_MODULES, Modules) +
                                         NumberOfModules * sizeof (RTL_PROCESS_MODULE_INFORMATION);

                ASSERT (cbModuleInformationNew >= sizeof (RTL_PROCESS_MODULES));
                ASSERT (cbModuleInformationNew > cbModuleInformation);

                if (cbModuleInformationNew <= cbModuleInformation) {
                    SetLastError (RtlNtStatusToDosError (Status));
                    return FALSE;
                }
                cbModuleInformation = cbModuleInformationNew;

            } else {
                SetLastError (RtlNtStatusToDosError (Status));
                return FALSE;
            }
        }
    }

    for (i = 0; i < NumberOfModules; i++) {
        if (pModuleInformation->Modules[i].ImageBase == ImageBase) {
            *Module = pModuleInformation->Modules[i];

            LocalFree (pModuleInformation);

            return TRUE;
        }
    }

    LocalFree (pModuleInformation);

    SetLastError (ERROR_INVALID_HANDLE);
    return FALSE;
}


BOOL
WINAPI
EnumDeviceDrivers(
    LPVOID *lpImageBase,
    DWORD cb,
    LPDWORD lpcbNeeded
    )
{
    NTSTATUS Status;
    DWORD cbModuleInformation, cbModuleInformationNew, NumberOfModules;
    PRTL_PROCESS_MODULES pModuleInformation;
    DWORD cpvMax;
    DWORD i, ReturnedLength;

    //
    // Set the buffer length and pointer to a fixed size for the first pass
    //

    cbModuleInformation = sizeof (RTL_PROCESS_MODULES) + 0x400;
    pModuleInformation = NULL;

    while (1) {

        pModuleInformation = LocalAlloc (LMEM_FIXED, cbModuleInformation);

        if (pModuleInformation == NULL) {
            SetLastError (ERROR_NO_SYSTEM_RESOURCES);
            return FALSE;
        }

        Status = NtQuerySystemInformation (SystemModuleInformation,
                                           pModuleInformation,
                                           cbModuleInformation,
                                           &ReturnedLength);

        NumberOfModules = pModuleInformation->NumberOfModules;

        if (NT_SUCCESS(Status)) {
            break;
        } else {

            LocalFree (pModuleInformation);
            
            if (Status == STATUS_INFO_LENGTH_MISMATCH) {
                ASSERT (cbModuleInformation >= sizeof (RTL_PROCESS_MODULES));

                cbModuleInformationNew = FIELD_OFFSET (RTL_PROCESS_MODULES, Modules) +
                                         NumberOfModules * sizeof (RTL_PROCESS_MODULE_INFORMATION);

                ASSERT (cbModuleInformationNew >= sizeof (RTL_PROCESS_MODULES));
                ASSERT (cbModuleInformationNew > cbModuleInformation);

                if (cbModuleInformationNew <= cbModuleInformation) {
                    SetLastError (RtlNtStatusToDosError (Status));
                    return FALSE;
                }
                cbModuleInformation = cbModuleInformationNew;

            } else {
                SetLastError (RtlNtStatusToDosError (Status));
                return FALSE;
            }
        }
    }

    cpvMax = cb / sizeof(LPVOID);

    for (i = 0; i < NumberOfModules; i++) {
        if (i == cpvMax) {
            break;
        }

        try {
           lpImageBase[i] = pModuleInformation->Modules[i].ImageBase;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            LocalFree (pModuleInformation);

            SetLastError (RtlNtStatusToDosError (GetExceptionCode ()));
            return FALSE;
        }
    }

    try {
        *lpcbNeeded = NumberOfModules * sizeof(LPVOID);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        LocalFree (pModuleInformation);

        SetLastError (RtlNtStatusToDosError (GetExceptionCode ()));
        return FALSE;
    }

    LocalFree (pModuleInformation);

    return TRUE;
}


DWORD
WINAPI
GetDeviceDriverFileNameW(
    LPVOID ImageBase,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    ImageBase - Identifies the driver whose executable file name is being
        requested.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    LPSTR lpstr;
    DWORD cch;
    DWORD cchT;

    lpstr = (LPSTR) LocalAlloc (LMEM_FIXED, nSize);

    if (lpstr == NULL) {
        return(0);
    }

    cchT = cch = GetDeviceDriverFileNameA (ImageBase, lpstr, nSize);

    if (!cch) {
        LocalFree((HLOCAL) lpstr);
        return 0;
    }

    if (cchT < nSize) {
        //
        // Include NULL terminator
        //

        cchT++;
    }

    if (!MultiByteToWideChar(CP_ACP, 0, lpstr, cchT, lpFilename, nSize)) {
        cch = 0;
    }

    LocalFree((HLOCAL) lpstr);

    return(cch);
}



DWORD
WINAPI
GetDeviceDriverFileNameA(
    LPVOID ImageBase,
    LPSTR lpFilename,
    DWORD nSize
    )
{
    RTL_PROCESS_MODULE_INFORMATION Module;
    DWORD cchT;
    DWORD cch;

    if (!FindDeviceDriver(ImageBase, &Module)) {
        return(0);
    }

    cch = cchT = (DWORD) (strlen(Module.FullPathName) + 1);
    if ( nSize < cch ) {
        cch = nSize;
    }

    CopyMemory(lpFilename, Module.FullPathName, cch);

    if (cch == cchT) {
        cch--;
    }

    return(cch);
}


DWORD
WINAPI
GetDeviceDriverBaseNameW(
    LPVOID ImageBase,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    ImageBase - Identifies the driver whose executable file name is being
        requested.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    LPSTR lpstr;
    DWORD cch;
    DWORD cchT;

    lpstr = (LPSTR) LocalAlloc(LMEM_FIXED, nSize);

    if (lpstr == NULL) {
        return(0);
    }

    cchT = cch = GetDeviceDriverBaseNameA(ImageBase, lpstr, nSize);

    if (!cch) {
        LocalFree((HLOCAL) lpstr);
        return 0;
    }

    if (cchT < nSize) {
        //
        // Include NULL terminator
        //

        cchT++;
    }

    if (!MultiByteToWideChar(CP_ACP, 0, lpstr, cchT, lpFilename, nSize)) {
        cch = 0;
    }

    LocalFree((HLOCAL) lpstr);

    return(cch);
}



DWORD
WINAPI
GetDeviceDriverBaseNameA(
    LPVOID ImageBase,
    LPSTR lpFilename,
    DWORD nSize
    )
{
    RTL_PROCESS_MODULE_INFORMATION Module;
    DWORD cchT;
    DWORD cch;

    if (!FindDeviceDriver(ImageBase, &Module)) {
        return(0);
    }

    cch = cchT = (DWORD) (strlen(Module.FullPathName + Module.OffsetToFileName) + 1);
    if ( nSize < cch ) {
        cch = nSize;
    }

    CopyMemory(lpFilename, Module.FullPathName + Module.OffsetToFileName, cch);

    if (cch == cchT) {
        cch--;
    }

    return(cch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\psapi\module.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "psapi.h"
//Need to change source to include $(BASE_INC_PATH)
#include <..\..\public\internal\base\inc\wow64t.h>

//Need to move in file psapi.h while publishing the EnumModulesEx api

#define LIST_MODULES_32BIT 0x01  // list 32bit modules in the target process.
#define LIST_MODULES_64BIT 0x02  // LIST_WOW64_NATIVE_MODULES list all the modules.
#define LIST_MODULES_ALL   0x03  // list all the modules
#define LIST_MODULES_NATIVE 0x0  // This is the default one app should call

#ifdef _WIN64
PLDR_DATA_TABLE_ENTRY
Wow64FindNextModuleEntry (
    IN HANDLE hProcess,
    IN OUT PLDR_DATA_TABLE_ENTRY LdrEntry,  //64bit structure info got from 32bit entry
    PLIST_ENTRY *pLdrHead
)
/*++

Routine Description:

    This function will walk through the 32bit Loader list to retrieve wow64 module info for 32bit 
    process on IA64. The function can be called repeatedly.

Arguments:

    hProcess - Supplies the target process.
    LdrEntryData - Returns the requested table entry. Data must be initialized in 1st call 
                    and use the same in the sub sequent call.
    pLdrHead - pointer to a PLIST_ENTRY. This is used internally to track the list.
               That get initialized in the 1st uses.

Return Value:

    NULL if no entry found,
    pointer to LdrEntry otherwise.

--*/

{

    LDR_DATA_TABLE_ENTRY32 LdrEntryData32;
    PLDR_DATA_TABLE_ENTRY32 LdrEntry32;
    LIST_ENTRY32 LdrNext32;  //8byte in 32bit 16 byte on IA64
    PLIST_ENTRY32 pLdrNext32;

    //
    // if inititial entry is NULL must find the Teb32 and init the struct with 1st entry.
    //

    if ( LdrEntry == NULL)
        return NULL;

    
    if ( LdrEntry->InMemoryOrderLinks.Flink == NULL &&
        LdrEntry->InMemoryOrderLinks.Blink == NULL ) { // check if any other entry;
                //
                // List need to be initialized.
                //
                NTSTATUS st;
                PPEB32 Peb32;
                PEB32 Peb32_Data;
                
                PEB_LDR_DATA32 Peb32LdrData;
    
                st = NtQueryInformationProcess(hProcess,
                                            ProcessWow64Information,
                                            &Peb32,
                                            sizeof(Peb32),
                                            NULL);
                if (!NT_SUCCESS (st)) {
                    return NULL;
                }
                {
                    PPEB_LDR_DATA32 Ldr32;

                    if (!ReadProcessMemory(hProcess, Peb32, &Peb32_Data, sizeof(Peb32_Data), NULL))
                        return NULL;

                    if (!ReadProcessMemory(hProcess, (PVOID)(ULONGLONG)Peb32_Data.Ldr, &Peb32LdrData, sizeof(Peb32LdrData), NULL))
                        return NULL;

                    *pLdrHead = (PVOID)((PBYTE)(ULONGLONG)Peb32_Data.Ldr + ((PBYTE)&Peb32LdrData.InMemoryOrderModuleList- (PBYTE)&Peb32LdrData ));

                    //
                    // LdrNext = Head->Flink;
                    //

                    pLdrNext32 = (PVOID)(ULONGLONG)Peb32LdrData.InMemoryOrderModuleList.Flink;

                    if (!ReadProcessMemory(hProcess, pLdrNext32, &LdrNext32, sizeof(LdrNext32), NULL)) {
                        return NULL;
                    }

                    
                }

        } else
            pLdrNext32 = (PVOID)LdrEntry->InMemoryOrderLinks.Flink;

        if (LdrEntry->InMemoryOrderLinks.Flink == *pLdrHead)
            return NULL;

        //
        // Read process memory to get a entry.
        //
        LdrEntry32 = CONTAINING_RECORD(
            pLdrNext32, 
            LDR_DATA_TABLE_ENTRY32, 
            InMemoryOrderLinks
            );
        //
        // Read 32bit entry
        //
        if (!ReadProcessMemory(hProcess, LdrEntry32, &LdrEntryData32, sizeof(LdrEntryData32), NULL))
            return NULL;

        //LdrEntryData->InMemoryOrderLinks.Flink; must be thunked
        

        LdrEntry->InLoadOrderLinks.Flink = (PVOID)(ULONGLONG)LdrEntryData32.InLoadOrderLinks.Flink;
        LdrEntry->InLoadOrderLinks.Blink = (PVOID)(ULONGLONG)LdrEntryData32.InLoadOrderLinks.Blink;

        LdrEntry->InMemoryOrderLinks.Flink = (PVOID)(ULONGLONG)LdrEntryData32.InMemoryOrderLinks.Flink;
        LdrEntry->InMemoryOrderLinks.Blink = (PVOID)(ULONGLONG)LdrEntryData32.InMemoryOrderLinks.Blink;

        LdrEntry->InInitializationOrderLinks.Flink = (PVOID)(ULONGLONG)LdrEntryData32.InInitializationOrderLinks.Flink;
        LdrEntry->InInitializationOrderLinks.Blink = (PVOID)(ULONGLONG)LdrEntryData32.InInitializationOrderLinks.Blink;

        LdrEntry->DllBase = (PVOID)(ULONGLONG)LdrEntryData32.DllBase;
        LdrEntry->EntryPoint = (PVOID)(ULONGLONG)LdrEntryData32.EntryPoint;

        //SizeOfImage;
        LdrEntry->SizeOfImage = LdrEntryData32.SizeOfImage;

        //Full Name
        LdrEntry->FullDllName.Length = LdrEntryData32.FullDllName.Length;
        LdrEntry->FullDllName.MaximumLength = LdrEntryData32.FullDllName.MaximumLength;
        LdrEntry->FullDllName.Buffer = (PVOID)(ULONGLONG)LdrEntryData32.FullDllName.Buffer;

        //Base Name
        LdrEntry->BaseDllName.Length = LdrEntryData32.BaseDllName.Length;
        LdrEntry->BaseDllName.MaximumLength = LdrEntryData32.BaseDllName.MaximumLength;
        LdrEntry->BaseDllName.Buffer = (PVOID)(ULONGLONG)LdrEntryData32.BaseDllName.Buffer;

        LdrEntry->Flags = LdrEntryData32.Flags;
        LdrEntry->LoadCount = LdrEntryData32.LoadCount;
        LdrEntry->TlsIndex = LdrEntryData32.TlsIndex;

        return LdrEntry;
}

BOOL
Wow64FindModuleEx(
    IN HANDLE hProcess,
    IN HMODULE hModule,
    OUT PLDR_DATA_TABLE_ENTRY LdrEntryData
    )

/*++

Routine Description:

    This function retrieves the loader table entry for the specified
    module.  The function copies the entry into the buffer pointed to
    by the LdrEntryData parameter.

Arguments:

    hProcess - Supplies the target process.

    hModule - Identifies the module whose loader entry is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    LdrEntryData - Returns the requested table entry.

Return Value:

    TRUE if a matching entry was found.

--*/

{
    
    PLIST_ENTRY LdrHead;
    ULONG Count;
    

    Count = 0;
    try {

        LdrEntryData->InMemoryOrderLinks.Flink = LdrEntryData->InMemoryOrderLinks.Flink = NULL;

        while (Wow64FindNextModuleEntry (hProcess, LdrEntryData, &LdrHead)) {
            if (hModule == LdrEntryData->DllBase) {
                return TRUE;
            }
            Count++;
            if (Count > 10000) {
                SetLastError(ERROR_INVALID_HANDLE);
                return(FALSE);
            }
        } //while

    } except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
    }

    SetLastError(ERROR_INVALID_HANDLE);
    return(FALSE);
}

BOOL
WINAPI
Wow64EnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    )
/*++

Routine Description:

    This function all the module handles in a wow64 process.

Arguments:

    hProcess - Supplies the target process.

    lphModule - point to a array of modules handle to be filled by this API.

    cb - bytes in the array.

    lpcNeeded - will how much memory is needed or filled by the call.

Return Value:

    TRUE if a matching entry was found.

--*/
{
    DWORD ch =0;
    DWORD chMax = cb / sizeof(HMODULE);
    PLIST_ENTRY LdrHead;

    LDR_DATA_TABLE_ENTRY LdrEntry;

    LdrEntry.InMemoryOrderLinks.Flink = LdrEntry.InMemoryOrderLinks.Flink = NULL;

    try {
        while (Wow64FindNextModuleEntry ( hProcess, &LdrEntry, &LdrHead)) {

            if (ch < chMax) {
                try {
                   lphModule[ch] = (HMODULE) LdrEntry.DllBase;
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
                    return(FALSE);
                }
            }
            ch++;
            if (ch > 10000) {
                SetLastError(ERROR_INVALID_HANDLE);
                return(FALSE);
            }
        } //while

        *lpcbNeeded = ch * sizeof(HMODULE);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
    }

    return(TRUE);
}
#endif //_WIN64
BOOL
FindModule(
    IN HANDLE hProcess,
    IN HMODULE hModule,
    OUT PLDR_DATA_TABLE_ENTRY LdrEntryData
    )

/*++

Routine Description:

    This function retrieves the loader table entry for the specified
    module.  The function copies the entry into the buffer pointed to
    by the LdrEntryData parameter.

Arguments:

    hProcess - Supplies the target process.

    hModule - Identifies the module whose loader entry is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    LdrEntryData - Returns the requested table entry.

Return Value:

    TRUE if a matching entry was found.

--*/

{
    PROCESS_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    PPEB Peb;
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    ULONG Count;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
    }

    Peb = BasicInfo.PebBaseAddress;


    if ( !ARGUMENT_PRESENT( hModule )) {
        if (!ReadProcessMemory(hProcess, &Peb->ImageBaseAddress, &hModule, sizeof(hModule), NULL)) {
            return(FALSE);
        }
    }

    //
    // Ldr = Peb->Ldr
    //

    if (!ReadProcessMemory(hProcess, &Peb->Ldr, &Ldr, sizeof(Ldr), NULL)) {
        return (FALSE);
    }

    if (!Ldr) {
        // Ldr might be null (for instance, if the process hasn't started yet).
        SetLastError(ERROR_INVALID_HANDLE);
        return (FALSE);
    }


    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    if (!ReadProcessMemory(hProcess, &LdrHead->Flink, &LdrNext, sizeof(LdrNext), NULL)) {
        return(FALSE);
    }

    Count = 0;
    while (LdrNext != LdrHead) {
        PLDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if (!ReadProcessMemory(hProcess, LdrEntry, LdrEntryData, sizeof(*LdrEntryData), NULL)) {
            return(FALSE);
        }

        if ((HMODULE) LdrEntryData->DllBase == hModule) {
            return(TRUE);
        }

        LdrNext = LdrEntryData->InMemoryOrderLinks.Flink;
        Count++;
        if (Count > 10000) {
            SetLastError(ERROR_INVALID_HANDLE);
            return FALSE;
        }
    }

#ifdef _WIN64
    return Wow64FindModuleEx( hProcess, hModule, LdrEntryData);
#else 
    SetLastError(ERROR_INVALID_HANDLE);
    return(FALSE);
#endif
}


BOOL
WINAPI
EnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    )
{
    PROCESS_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    PPEB Peb;
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    DWORD chMax;
    DWORD ch;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
    }

    Peb = BasicInfo.PebBaseAddress;

    //
    // The system process has no PEB.  STATUS_PARTIAL_COPY is a poor choice
    // for a return value, but it's what's always been returned, so continue
    // to do so to maintain application compatibility.
    //

    if (Peb == NULL) {
        SetLastError( RtlNtStatusToDosError( STATUS_PARTIAL_COPY ) );
        return(FALSE);
    }

    //
    // Ldr = Peb->Ldr
    //

    if (!ReadProcessMemory(hProcess, &Peb->Ldr, &Ldr, sizeof(Ldr), NULL)) {

        //
        // LastError is set by ReadProcessMemory
        //

        return(FALSE);
    }

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    if (!ReadProcessMemory(hProcess, &LdrHead->Flink, &LdrNext, sizeof(LdrNext), NULL)) {
        //
        // LastError is set by ReadProcessMemory
        //

        return(FALSE);
    }

    chMax = cb / sizeof(HMODULE);
    ch = 0;

    while (LdrNext != LdrHead) {
        PLDR_DATA_TABLE_ENTRY LdrEntry;
        LDR_DATA_TABLE_ENTRY LdrEntryData;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if (!ReadProcessMemory(hProcess, LdrEntry, &LdrEntryData, sizeof(LdrEntryData), NULL)) {
            //
            // LastError is set by ReadProcessMemory
            //

            return(FALSE);
        }

        if (ch < chMax) {
            try {
                lphModule[ch] = (HMODULE) LdrEntryData.DllBase;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
                return(FALSE);
            }
        }

        ch++;
        if (ch > 10000) {
            SetLastError(ERROR_INVALID_HANDLE);
            return FALSE;
        }

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
    }

    try {
        *lpcbNeeded = ch * sizeof(HMODULE);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
    }

    return TRUE;
}

BOOL
WINAPI
EnumProcessModulesEx(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded,
    DWORD Res,
    DWORD dwFlag
    )
/*++

Routine Description:

    This function all the module handles in a process with listing option like native 
    modules only, wow64 32bit modules only or all.

Arguments:

    hProcess - Supplies the target process.

    lphModule - point to a array of modules handle to be filled by this API.

    cb - bytes in the array.

    lpcNeeded - will how much memory is needed or filled by the call.
    Res - for future extension of this API. Set to 0.

    dwFlag - control the type of operation. 
        LIST_MODULES_32BIT 0x01  // list 32bit modules in the target process.
        LIST_MODULES_64BIT 0x02  // LIST_WOW64_NATIVE_MODULES list all the modules.
        LIST_MODULES_ALL   0x03  // list all the modules
        LIST_MODULES_NATIVE 0x0  // This is the default one app should call

Return Value:

    TRUE if the module array has been filled properly.
    FALSE - For incomplete buffer caller need to check required memory.

    <TBD> should 32bit app be allowed to use LIST_MODULES_64BIT?

--*/
{
    BOOL Ret= FALSE;
    DWORD dwNeeded1=0, dwNeeded=0;

    //
    // Enumerate the native call
    //

    if (dwFlag == LIST_MODULES_NATIVE || dwFlag == LIST_MODULES_ALL ) {

        Ret = EnumProcessModules(
                                hProcess,
                                lphModule,
                                cb,
                                &dwNeeded1
                                );

        if (dwFlag == LIST_MODULES_NATIVE ) //native only enumeration
            return Ret;
    }
#ifdef _WIN64
    if (dwNeeded1 > cb) {
        //
        // Next pass is just inventory.
        //
        cb =0;
        lphModule = NULL;
    } else {
        cb -= dwNeeded1;
        lphModule = &lphModule[dwNeeded1/sizeof (HMODULE)];
    }

    Ret = Ret && Wow64EnumProcessModules(
                            hProcess,
                            lphModule,
                            cb,
                            &dwNeeded
                            );
    try {
        *lpcbNeeded = dwNeeded1 + dwNeeded;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
    }
#endif //_WIN64
    return Ret;

}


DWORD
WINAPI
GetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    hModule - Identifies the module whose executable file name is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    DWORD cb;

    if (!FindModule(hProcess, hModule, &LdrEntryData)) {
        return(0);
    }

    nSize *= sizeof(WCHAR);

    cb = LdrEntryData.FullDllName.Length + sizeof (WCHAR);
    if ( nSize < cb ) {
        cb = nSize;
    }

    if (!ReadProcessMemory(hProcess, LdrEntryData.FullDllName.Buffer, lpFilename, cb, NULL)) {
        return(0);
    }

    if (cb == LdrEntryData.FullDllName.Length + sizeof (WCHAR)) {
        cb -= sizeof(WCHAR);
    }

    return(cb / sizeof(WCHAR));
}



DWORD
WINAPI
GetModuleFileNameExA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    )
{
    LPWSTR lpwstr;
    DWORD cwch;
    DWORD cch;

    lpwstr = (LPWSTR) LocalAlloc(LMEM_FIXED, nSize * 2);

    if (lpwstr == NULL) {
        return(0);
    }

    cwch = cch = GetModuleFileNameExW(hProcess, hModule, lpwstr, nSize);

    if (cwch < nSize) {
        //
        // Include NULL terminator
        //

        cwch++;
    }

    if (!WideCharToMultiByte(CP_ACP, 0, lpwstr, cwch, lpFilename, nSize, NULL, NULL)) {
        cch = 0;
    }

    LocalFree((HLOCAL) lpwstr);

    return(cch);
}


DWORD
WINAPI
GetModuleBaseNameW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    hModule - Identifies the module whose executable file name is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    DWORD cb;

    if (!FindModule(hProcess, hModule, &LdrEntryData)) {
        return(0);
    }

    nSize *= sizeof(WCHAR);

    cb = LdrEntryData.BaseDllName.Length + sizeof (WCHAR);
    if ( nSize < cb ) {
        cb = nSize;
    }

    if (!ReadProcessMemory(hProcess, LdrEntryData.BaseDllName.Buffer, lpFilename, cb, NULL)) {
        return(0);
    }

    if (cb == LdrEntryData.BaseDllName.Length + sizeof (WCHAR)) {
        cb -= sizeof(WCHAR);
    }

    return(cb / sizeof(WCHAR));
}



DWORD
WINAPI
GetModuleBaseNameA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    )
{
    LPWSTR lpwstr;
    DWORD cwch;
    DWORD cch;

    lpwstr = (LPWSTR) LocalAlloc(LMEM_FIXED, nSize * 2);

    if (lpwstr == NULL) {
        return(0);
    }

    cwch = cch = GetModuleBaseNameW(hProcess, hModule, lpwstr, nSize);

    if (cwch < nSize) {
        //
        // Include NULL terminator
        //

        cwch++;
    }

    if (!WideCharToMultiByte(CP_ACP, 0, lpwstr, cwch, lpFilename, nSize, NULL, NULL)) {
        cch = 0;
    }

    LocalFree((HLOCAL) lpwstr);

    return(cch);
}


BOOL
WINAPI
GetModuleInformation(
    HANDLE hProcess,
    HMODULE hModule,
    LPMODULEINFO lpmodinfo,
    DWORD cb
    )
{
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    MODULEINFO modinfo;

    if (cb < sizeof(MODULEINFO)) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return(FALSE);
    }

    if (!FindModule(hProcess, hModule, &LdrEntryData)) {
        return(0);
    }

    modinfo.lpBaseOfDll = (PVOID) hModule;
    modinfo.SizeOfImage = LdrEntryData.SizeOfImage;
    modinfo.EntryPoint  = LdrEntryData.EntryPoint;

    try {
        *lpmodinfo = modinfo;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\psapi\mapfile.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "psapi.h"


DWORD
WINAPI
GetMappedFileNameW(
    HANDLE hProcess,
    LPVOID lpv,
    LPWSTR lpFilename,
    DWORD nSize
    )
/*++

Routine Description:

    The routine gets the file name associated with a mapped section

Arguments:

    hProcess - Handle of the process to do the query for
    lpv - Address of mapped section to query
    lpFilename - Address of the buffer to hold the returned filename
    nSize - Size of the returned filename.
    

Return Value:

    DWORD - Zero on error otherwise the size of the data returned.
            If the data is truncated the return size is the size of the passed in buffer.

--*/
{
    struct {
        OBJECT_NAME_INFORMATION ObjectNameInfo;
        WCHAR FileName[MAX_PATH];
    } s;
    NTSTATUS Status;
    SIZE_T ReturnLength;
    DWORD cb, CopySize;

    if (nSize == 0) {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        return 0;
    }

    //
    // See if we can figure out the name associated with
    // this mapped region
    //

    Status = NtQueryVirtualMemory (hProcess,
                                   lpv,
                                   MemoryMappedFilenameInformation,
                                   &s.ObjectNameInfo,
                                   sizeof(s),
                                   &ReturnLength);

    if (!NT_SUCCESS (Status)) {
        SetLastError (RtlNtStatusToDosError (Status));
        return 0;
    }

    cb = s.ObjectNameInfo.Name.Length / sizeof (WCHAR);

    CopySize = cb;
    if (nSize < cb + 1) {
        CopySize = nSize - 1;
        cb = nSize;
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
    } else {
        SetLastError (NO_ERROR);
    }

    CopyMemory (lpFilename, s.ObjectNameInfo.Name.Buffer, CopySize * sizeof (WCHAR));

    lpFilename[CopySize] = UNICODE_NULL;

    return cb;
}


DWORD
WINAPI
GetMappedFileNameA(
    HANDLE hProcess,
    LPVOID lpv,
    LPSTR lpFilename,
    DWORD nSize
    )
/*++

Routine Description:

    The routine gets the file name associated with a mapped section

Arguments:

    hProcess - Handle of the process to do the query for
    lpv - Address of mapped section to query
    lpFilename - Address of the buffer to hold the returned filename
    nSize - Size of the returned filename.
    

Return Value:

    DWORD - Zero on error otherwise the size of the data returned or required.
            If the return value is greater than the input buffer size then the data was truncated.

--*/
{
    LPWSTR lpwstr;
    DWORD cwch;
    DWORD cch;

    lpwstr = (LPWSTR) LocalAlloc(LMEM_FIXED, nSize * 2);

    if (lpwstr == NULL) {
        return(0);
    }

    cch = cwch = GetMappedFileNameW(hProcess, lpv, lpwstr, nSize);

    if (cwch < nSize) {
        //
        // Include NULL terminator
        //

        cwch++;
    }

    if (!WideCharToMultiByte(CP_ACP, 0, lpwstr, cwch, lpFilename, nSize, NULL, NULL)) {
        cch = 0;
    }

    LocalFree((HLOCAL) lpwstr);

    return(cch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\psapi\perf.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    psenum.c

Abstract:

    This module returns various performance values

Author:

    Neill clift (NeillC) 23-Jul-2000


Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "psapi.h"

BOOL
WINAPI
GetPerformanceInfo (
    PPERFORMANCE_INFORMATION pPerformanceInformation,
    DWORD cb
    )
/*++

Routine Description:

    The routine gets some performance values.

Arguments:

    pPerformanceInformation - A block out performance values that are returned.

Return Value:

    BOOL - Returns TRUE is the function was successfull FALSE otherwise

--*/
{
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_FILECACHE_INFORMATION FileCache;
    PSYSTEM_PROCESS_INFORMATION ProcInfo, tProcInfo;
    ULONG BufferLength, RetLen;
    ULONG Processes;
    ULONG Threads;
    ULONG Handles;


    if (cb < sizeof (PERFORMANCE_INFORMATION)) {
        SetLastError (RtlNtStatusToDosError (STATUS_INFO_LENGTH_MISMATCH));
        return FALSE;
    }
    Status = NtQuerySystemInformation (SystemBasicInformation,
                                       &BasicInfo,
                                       sizeof(BasicInfo),
                                       NULL);
    if (!NT_SUCCESS (Status)) {
        SetLastError (RtlNtStatusToDosError (Status));
        return FALSE;
    }

    Status = NtQuerySystemInformation (SystemPerformanceInformation,
                                       &PerfInfo,
                                       sizeof(PerfInfo),
                                       NULL);
    if (!NT_SUCCESS (Status)) {
        SetLastError (RtlNtStatusToDosError (Status));
        return FALSE;
    }

    Status = NtQuerySystemInformation (SystemFileCacheInformation,
                                       &FileCache,
                                       sizeof(FileCache),
                                       NULL);
    if (!NT_SUCCESS (Status)) {
        SetLastError (RtlNtStatusToDosError (Status));
        return FALSE;
    }

    BufferLength = 4096;
    while (1) {
        ProcInfo = LocalAlloc (LMEM_FIXED, BufferLength);
        if (ProcInfo == NULL) {
            SetLastError (RtlNtStatusToDosError (STATUS_INSUFFICIENT_RESOURCES));
            return FALSE;
        }
        Status = NtQuerySystemInformation (SystemProcessInformation,
                                           ProcInfo,
                                           BufferLength,
                                           &RetLen);
        if (NT_SUCCESS (Status)) {
            break;
        }
        LocalFree (ProcInfo);
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (RetLen > BufferLength) {
                BufferLength = RetLen;
            } else {
                BufferLength += 4096;
            }
        } else {
            SetLastError (RtlNtStatusToDosError (Status));
            return FALSE;
        }
    }

    Processes = 0;
    Threads = 0;
    Handles = 0;

    tProcInfo = ProcInfo;
    while (RetLen > sizeof (SYSTEM_PROCESS_INFORMATION)) {
        Processes += 1;
        Threads += tProcInfo->NumberOfThreads;
        Handles += tProcInfo->HandleCount;
        if (tProcInfo->NextEntryOffset == 0 || tProcInfo->NextEntryOffset > RetLen) {
            break;
        }
        RetLen -= tProcInfo->NextEntryOffset;
        tProcInfo = (PSYSTEM_PROCESS_INFORMATION) ((PUCHAR) tProcInfo + tProcInfo->NextEntryOffset);
    }
    LocalFree (ProcInfo);

    pPerformanceInformation->cb                = sizeof (PERFORMANCE_INFORMATION);
    pPerformanceInformation->CommitTotal       = PerfInfo.CommittedPages;
    pPerformanceInformation->CommitLimit       = PerfInfo.CommitLimit;
    pPerformanceInformation->CommitPeak        = PerfInfo.PeakCommitment;
    pPerformanceInformation->PhysicalTotal     = BasicInfo.NumberOfPhysicalPages;
    pPerformanceInformation->PhysicalAvailable = PerfInfo.AvailablePages;
    pPerformanceInformation->SystemCache       = FileCache.CurrentSizeIncludingTransitionInPages;
    pPerformanceInformation->KernelTotal       = PerfInfo.PagedPoolPages + PerfInfo.NonPagedPoolPages;
    pPerformanceInformation->KernelPaged       = PerfInfo.PagedPoolPages;
    pPerformanceInformation->KernelNonpaged    = PerfInfo.NonPagedPoolPages;
    pPerformanceInformation->PageSize          = BasicInfo.PageSize;
    pPerformanceInformation->HandleCount       = Handles;
    pPerformanceInformation->ProcessCount      = Processes;
    pPerformanceInformation->ThreadCount       = Threads;

    return TRUE;
}

BOOL
WINAPI
EnumPageFilesW (
    PENUM_PAGE_FILE_CALLBACKW pCallBackRoutine,
    LPVOID pContext
    )
/*++

Routine Description:

    The routine calls the callback routine for each installed page file in the system

Arguments:

    pCallBackRoutine - Routine called for each pagefile
    pContext - Context value provided by the user and passed to the call back routine.

Return Value:

    BOOL - Returns TRUE is the function was successfull FALSE otherwise

--*/
{
    NTSTATUS Status;
    ULONG BufferLength, RetLen;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo, tPageFileInfo;

    BufferLength = 4096;
    while (1) {
        PageFileInfo = LocalAlloc (LMEM_FIXED, BufferLength);
        if (PageFileInfo == NULL) {
            SetLastError (RtlNtStatusToDosError (STATUS_INSUFFICIENT_RESOURCES));
            return FALSE;
        }
        Status = NtQuerySystemInformation (SystemPageFileInformation,
                                           PageFileInfo,
                                           BufferLength,
                                           &RetLen);
        if (NT_SUCCESS (Status)) {
            break;
        }
        LocalFree (PageFileInfo);
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (RetLen > BufferLength) {
                BufferLength = RetLen;
            } else {
                BufferLength += 4096;
            }
        } else {
            SetLastError (RtlNtStatusToDosError (Status));
            return FALSE;
        }
    }

    tPageFileInfo = PageFileInfo;
    while (RetLen > sizeof (SYSTEM_PAGEFILE_INFORMATION)) {
        ENUM_PAGE_FILE_INFORMATION pfi;
        PWCHAR pWc;

        pfi.cb         = sizeof (ENUM_PAGE_FILE_INFORMATION);
        pfi.Reserved   = 0;
        pfi.TotalSize  = tPageFileInfo->TotalSize;
        pfi.TotalInUse = tPageFileInfo->TotalInUse;
        pfi.PeakUsage  = tPageFileInfo->PeakUsage;

        pWc = wcschr (tPageFileInfo->PageFileName.Buffer, L':');
        if (pWc != NULL && pWc > tPageFileInfo->PageFileName.Buffer) {
            pWc--;
            pCallBackRoutine (pContext, &pfi, pWc);
        }
        if (tPageFileInfo->NextEntryOffset == 0 || tPageFileInfo->NextEntryOffset > RetLen) {
            break;
        }
        RetLen -= tPageFileInfo->NextEntryOffset;
        tPageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION) ((PUCHAR) tPageFileInfo +
                                                                 tPageFileInfo->NextEntryOffset);
    }
    LocalFree (PageFileInfo);
    return TRUE;
}

typedef struct _ENUM_PAGE_FILE_CONV_CTX {
    LPVOID Ctx;
    PENUM_PAGE_FILE_CALLBACKA CallBack;
    DWORD LastError;
} ENUM_PAGE_FILE_CONV_CTX, *PENUM_PAGE_FILE_CONV_CTX;

BOOL
CallBackConvertToAscii (
    LPVOID pContext,
    PENUM_PAGE_FILE_INFORMATION pPageFileInfo,
    LPCWSTR lpFilename
    )
{
    DWORD Len;
    LPSTR AsciiStr;
    PENUM_PAGE_FILE_CONV_CTX Ctx = pContext;
    BOOL RetVal;

    Len = wcslen (lpFilename) + 1;

    AsciiStr = LocalAlloc (LMEM_FIXED, Len);
    if (AsciiStr == NULL) {
        Ctx->LastError = RtlNtStatusToDosError (STATUS_INSUFFICIENT_RESOURCES);
        return FALSE;
    }

    if (WideCharToMultiByte (CP_ACP, 0, lpFilename, -1, AsciiStr, Len, NULL, NULL)) {
        RetVal = Ctx->CallBack (Ctx->Ctx, pPageFileInfo, AsciiStr);
    } else {
        Ctx->LastError = GetLastError ();
        RetVal = FALSE;
    }

    LocalFree (AsciiStr);

    return RetVal;
}

BOOL
WINAPI
EnumPageFilesA (
    PENUM_PAGE_FILE_CALLBACKA pCallBackRoutine,
    LPVOID pContext
    )
/*++

Routine Description:

    The routine calls the callback routine for each installed page file in the system

Arguments:

    pCallBackRoutine - Routine called for each pagefile
    pContext - Context value provided by the user and passed to the call back routine.

Return Value:

    BOOL - Returns TRUE is the function was successfull FALSE otherwise

--*/
{
    ENUM_PAGE_FILE_CONV_CTX Ctx;
    BOOL RetVal;

    Ctx.Ctx = pContext;
    Ctx.CallBack = pCallBackRoutine;
    Ctx.LastError = 0;

    RetVal = EnumPageFilesW (CallBackConvertToAscii,
                             &Ctx);
    if (RetVal) {
        //
        // See if our conversion routine encountered an error. If it doid then return this to the caller
        //
        if (Ctx.LastError != 0) {
            RetVal = FALSE;
            SetLastError (Ctx.LastError);
        }
    }
    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\psapi\profile.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <imagehlp.h>
#include <psapi.h>
#include <stdlib.h>
#include <stdio.h>


#define MAX_SYMNAME_SIZE  1024
CHAR symBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL ThisSymbol = (PIMAGEHLP_SYMBOL) symBuffer;

CHAR LastSymBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL LastSymbol = (PIMAGEHLP_SYMBOL) LastSymBuffer;

CHAR BadSymBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL BadSymbol = (PIMAGEHLP_SYMBOL)BadSymBuffer;

BOOL UseLastSymbol;


typedef struct _PROFILE_BLOCK {
    HANDLE Handle;
    HANDLE SecondaryHandle;
    PVOID ImageBase;
    BOOL SymbolsLoaded;
    PULONG CodeStart;
    ULONG CodeLength;
    PULONG Buffer;
    PULONG SecondaryBuffer;
    ULONG BufferSize;
    ULONG TextNumber;
    ULONG BucketSize;
    PUNICODE_STRING ImageName;
    char *ImageFileName;
} PROFILE_BLOCK;

ULONG ProfilePageSize;


#define MAX_BYTE_PER_LINE       72
#define MAX_PROFILE_COUNT 100
#define SYM_HANDLE ((HANDLE)UlongToPtr(0xffffffff))

PROFILE_BLOCK ProfileObject[MAX_PROFILE_COUNT+1];

ULONG NumberOfProfileObjects = 0;

ULONG ProfileInterval = 4882;

#define BUCKETSIZE 4
int PowerOfBytesCoveredPerBucket = 2;
CHAR SymbolSearchPathBuf[4096];
LPSTR SymbolSearchPath = SymbolSearchPathBuf;
BOOLEAN ShowAllHits = FALSE;
BOOLEAN fKernel = FALSE;

PCHAR OutputFile = "profile.out";

KPROFILE_SOURCE ProfileSource = ProfileTime;
KPROFILE_SOURCE SecondaryProfileSource = ProfileTime;
BOOLEAN UseSecondaryProfile = FALSE;

//
// define the mappings between arguments and KPROFILE_SOURCE types
//

typedef struct _PROFILE_SOURCE_MAPPING {
    PCHAR   Name;
    KPROFILE_SOURCE Source;
} PROFILE_SOURCE_MAPPING, *PPROFILE_SOURCE_MAPPING;

PROFILE_SOURCE_MAPPING ProfileSourceMapping[] = {
    {NULL,0}
    };

VOID
PsParseCommandLine(
    VOID
    );

VOID
PsWriteProfileLine(
    IN HANDLE ProfileHandle,
    IN PSZ Line
    )
{
    IO_STATUS_BLOCK IoStatusBlock;

    NtWriteFile(
        ProfileHandle,
        NULL,
        NULL,
        NULL,
        &IoStatusBlock,
        Line,
        (ULONG)strlen(Line),
        NULL,
        NULL
        );

}

NTSTATUS
PsInitializeAndStartProfile(
    VOID
    )
{
    HANDLE CurrentProcessHandle;
    SIZE_T BufferSize;
    PVOID ImageBase;
    PULONG CodeStart;
    ULONG CodeLength;
    PULONG Buffer;
    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PUNICODE_STRING ImageName;
    PLIST_ENTRY Next;
    SYSTEM_BASIC_INFORMATION SystemInfo;
    NTSTATUS Status;
    ULONG i;
    CHAR Bogus[256];
    CHAR *ImageFileName;
    SIZE_T WsMin, WsMax;
    ULONG ModuleNumber;
    CHAR ModuleInfoBuffer[64000];
    ULONG ReturnedLength;
    PRTL_PROCESS_MODULES Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;
    BOOLEAN PreviousProfilePrivState;
    BOOLEAN PreviousQuotaPrivState;
    BOOLEAN Done = FALSE;
    BOOLEAN DuplicateObject = FALSE;
    DWORD cbModuleInformation, cbModuleInformationNew, NumberOfModules;
    PRTL_PROCESS_MODULES pModuleInformation = NULL;


    //
    // Get the page size.
    //

    Status = NtQuerySystemInformation (SystemBasicInformation,
                                       &SystemInfo,
                                       sizeof(SystemInfo),
                                       NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Load kernel modules
    //
    if (fKernel) {
        
        cbModuleInformation = sizeof (RTL_PROCESS_MODULES) + 0x400;

        while (1) {

            pModuleInformation = LocalAlloc (LMEM_FIXED, cbModuleInformation);

            if (pModuleInformation == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            Status = NtQuerySystemInformation (SystemModuleInformation,
                                               pModuleInformation,
                                               cbModuleInformation,
                                               &ReturnedLength);

            NumberOfModules = pModuleInformation->NumberOfModules;

            if (NT_SUCCESS(Status)) {
                break;
            } else {

                LocalFree (pModuleInformation);
                pModuleInformation = NULL;
            
                if (Status == STATUS_INFO_LENGTH_MISMATCH) {
                    ASSERT (cbModuleInformation >= sizeof (RTL_PROCESS_MODULES));

                    cbModuleInformationNew = FIELD_OFFSET (RTL_PROCESS_MODULES, Modules) +
                                             NumberOfModules * sizeof (RTL_PROCESS_MODULE_INFORMATION);

                    ASSERT (cbModuleInformationNew >= sizeof (RTL_PROCESS_MODULES));
                    ASSERT (cbModuleInformationNew > cbModuleInformation);

                    if (cbModuleInformationNew <= cbModuleInformation) {
                        break;
                    }
                    cbModuleInformation = cbModuleInformationNew;

                } else {
                    break;
                }
            }
        }

        if (!NT_SUCCESS(Status)) {
            DbgPrint("query system info failed status - %lx\n",Status);
            fKernel = FALSE;
        } else {
            Modules = pModuleInformation;
            Module = &Modules->Modules[ 0 ];
            ModuleNumber = 0;

            Status = RtlAdjustPrivilege(
                         SE_SYSTEM_PROFILE_PRIVILEGE,
                         TRUE,              //Enable
                         FALSE,             //not impersonating
                         &PreviousProfilePrivState
                         );

            if (!NT_SUCCESS(Status) || Status == STATUS_NOT_ALL_ASSIGNED) {
                DbgPrint("Enable system profile privilege failed - status 0x%lx\n",
                                Status);
            }

            Status = RtlAdjustPrivilege(
                         SE_INCREASE_QUOTA_PRIVILEGE,
                         TRUE,              //Enable
                         FALSE,             //not impersonating
                         &PreviousQuotaPrivState
                         );

            if (!NT_SUCCESS(Status) || Status == STATUS_NOT_ALL_ASSIGNED) {
                DbgPrint("Unable to increase quota privilege (status=0x%lx)\n",
                                Status);
            }
        }
    }

    ProfilePageSize = SystemInfo.PageSize;

    //
    // Locate all the executables in the address and create a
    // seperate profile object for each one.
    //

    CurrentProcessHandle = NtCurrentProcess();

    Peb = NtCurrentPeb();

    Next = Peb->Ldr->InMemoryOrderModuleList.Flink;
    while (!Done) {
        if ( Next != &Peb->Ldr->InMemoryOrderModuleList) {
            LdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY) (CONTAINING_RECORD(
                                Next,
                                LDR_DATA_TABLE_ENTRY,
                                InMemoryOrderLinks
                                ));

            Next = Next->Flink;

            ImageBase = LdrDataTableEntry->DllBase;
            ImageName = &LdrDataTableEntry->BaseDllName;
            CodeLength = LdrDataTableEntry->SizeOfImage;
            CodeStart = (PULONG)ImageBase;

            ImageFileName = HeapAlloc(GetProcessHeap(), 0, 257);
            if (!ImageFileName) {
                if (pModuleInformation != NULL) {
                    LocalFree (pModuleInformation);
                }
                Status = STATUS_NO_MEMORY;
                return Status;
            }
            Status = RtlUnicodeToOemN( ImageFileName,
                                       256,
                                       &i,
                                       ImageName->Buffer,
                                       ImageName->Length
                                     );
            ImageFileName[i] = 0;

            if (Status != STATUS_SUCCESS) {
                HeapFree(GetProcessHeap(), 0, ImageFileName);
                continue;
            }
        } else
        if (fKernel && (ModuleNumber < Modules->NumberOfModules)) {
            ULONG cNameMBLength = lstrlen(&Module->FullPathName[Module->OffsetToFileName]) + 1;
            ULONG cNameUCLength = cNameMBLength * sizeof(WCHAR);
            ULONG cNameSize = cNameUCLength + sizeof(UNICODE_STRING);

            ImageFileName = HeapAlloc(GetProcessHeap(), 0, cNameMBLength);
            if (!ImageFileName) {
                if (pModuleInformation != NULL) {
                    LocalFree (pModuleInformation);
                }
                Status = STATUS_NO_MEMORY;
                return Status;
            }
            lstrcpy(ImageFileName, &Module->FullPathName[Module->OffsetToFileName]);

            ImageBase = Module->ImageBase;
            CodeLength = Module->ImageSize;
            CodeStart = (PULONG)ImageBase;
            ImageName = HeapAlloc(GetProcessHeap(), 0, cNameSize);
            if (!ImageName) {
                if (pModuleInformation != NULL) {
                    LocalFree (pModuleInformation);
                }
                Status = STATUS_NO_MEMORY;
                return Status;
            }

            ImageName->Buffer = (WCHAR *)((PBYTE)ImageName + sizeof(UNICODE_STRING));
            RtlMultiByteToUnicodeN(ImageName->Buffer, cNameUCLength, &i,
                                   &Module->FullPathName[Module->OffsetToFileName],
                                   cNameMBLength);
            ImageName->Length = (USHORT)i;
            Module++;
            ModuleNumber++;
        } else {
            Done = TRUE;
            break;
        }

        DuplicateObject = FALSE;

        for (i = 0; i < NumberOfProfileObjects ; i++ ) {
            if (ImageBase == ProfileObject[i].ImageBase) {
                DuplicateObject = TRUE;
            }
        }

        if (DuplicateObject) {
            continue;
        }

        ProfileObject[NumberOfProfileObjects].ImageBase = ImageBase;
        ProfileObject[NumberOfProfileObjects].ImageName = ImageName;
        ProfileObject[NumberOfProfileObjects].ImageFileName = ImageFileName;

        ProfileObject[NumberOfProfileObjects].CodeLength = CodeLength;
        ProfileObject[NumberOfProfileObjects].CodeStart = CodeStart;
        ProfileObject[NumberOfProfileObjects].TextNumber = 1;

        //
        // Analyze the size of the code and create a reasonably sized
        // profile object.
        //

        BufferSize = ((CodeLength * BUCKETSIZE) >> PowerOfBytesCoveredPerBucket) + 4;
        Buffer = NULL;

        Status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&Buffer,
                                          0,
                                          &BufferSize,
                                          MEM_RESERVE | MEM_COMMIT,
                                          PAGE_READWRITE);

        if (!NT_SUCCESS(Status)) {
            DbgPrint ("RtlInitializeProfile : alloc VM failed %lx\n",Status);
            if (pModuleInformation != NULL) {
                LocalFree (pModuleInformation);
            }
            return Status;
        }

        ProfileObject[NumberOfProfileObjects].Buffer = Buffer;
        ProfileObject[NumberOfProfileObjects].BufferSize = (ULONG)BufferSize;
        ProfileObject[NumberOfProfileObjects].BucketSize = PowerOfBytesCoveredPerBucket;

        Status = NtCreateProfile (
                    &ProfileObject[NumberOfProfileObjects].Handle,
                    CurrentProcessHandle,
                    ProfileObject[NumberOfProfileObjects].CodeStart,
                    ProfileObject[NumberOfProfileObjects].CodeLength,
                    ProfileObject[NumberOfProfileObjects].BucketSize,
                    ProfileObject[NumberOfProfileObjects].Buffer ,
                    ProfileObject[NumberOfProfileObjects].BufferSize,
                    ProfileSource,
                    (KAFFINITY)-1);

        if (Status != STATUS_SUCCESS) {
            if (pModuleInformation != NULL) {
                LocalFree (pModuleInformation);
            }
            DbgPrint("create profile %wZ failed - status %lx\n",
                   ProfileObject[NumberOfProfileObjects].ImageName,Status);
            return Status;
        }

        if (UseSecondaryProfile) {
            Buffer = NULL;
            Status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                              (PVOID *)&Buffer,
                                              0,
                  