ERROR_OUTOFMEMORY;
                }
            }

            if( lResult == ERROR_SUCCESS && pParams->pwszValue == NULL )
            {
                pParams->pwszValue = (LPWSTR) AllocateMemory( 1 * sizeof(WCHAR));
                if( pParams->pwszValue == NULL )
                {
                    lResult = ERROR_OUTOFMEMORY;
                }
            }
        }
    }

    if( lResult != ERROR_SUCCESS )
    {
        if( bResult == FALSE )
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1,
                ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_ADD ] );
        }
        else
        {
            SaveErrorMessage( lResult );
        }
    }

    return (lResult == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\delete.c ===
//-----------------------------------------------------------------------//
//
// File:    delete.cpp
// Created: April 1997
// By:      Martin Holladay (a-martih)
// Purpose: Registry Delete Support for REG.CPP
// Modification History:
//      Copied from Update.cpp and modificd - April 1997 (a-martih)
//      April 1999 Zeyong Xu: re-design, revision -> version 2.0
//
//------------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"

//
// function prototypes
//
LONG DeleteValues( PTREG_PARAMS pParams );
LONG RecursiveDeleteKey( HKEY hKey, LPCWSTR pwszName,
                         DWORD dwDepth, PTREG_PARAMS pParams );
BOOL ParseDeleteCmdLine( DWORD argc, LPCWSTR argv[],
                         PTREG_PARAMS pParams, BOOL* pbUsage );

//
// implementation
//

//-----------------------------------------------------------------------//
//
// DeleteRegistry()
//
//-----------------------------------------------------------------------//

LONG
DeleteRegistry( DWORD argc, LPCWSTR argv[] )
{
    // local variables
    LONG lResult = 0;
    BOOL bUsage = FALSE;
    BOOL bResult = TRUE;
    TREG_PARAMS params;
    LPCWSTR pwszList = NULL;
    LPCWSTR pwszFormat = NULL;

    // check the input
    if( argc == 0 || argv == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        return 1;
    }

    // initialize the global data structure
    InitGlobalData( REG_DELETE, &params );

    //
    // Parse the cmd-line
    //
    bResult = ParseDeleteCmdLine( argc, argv, &params, &bUsage );
    if( bResult == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    // check whether we need to display the usage
    if ( bUsage == TRUE )
    {
        Usage( REG_DELETE );
        FreeGlobalData( &params );
        return 0;
    }

    //
    // Connect to the Remote Machine(s) - if applicable
    //
    bResult = RegConnectMachine( &params );
    if( bResult == FALSE )
    {
        SaveErrorMessage( -1 );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // if delete a value or delete all values under this key
    else if( params.pwszValueName != NULL || params.bAllValues == TRUE )
    {
        lResult = DeleteValues( &params );
    }

    //
    // if delete the key
    else
    {
        pwszFormat = GetResString2( IDS_DELETE_PERMANENTLY, 0 );
        pwszList = GetResString2( IDS_CONFIRM_CHOICE_LIST, 1 );
        do
        {
            lResult = Prompt( pwszFormat,
                params.pwszFullKey, pwszList, params.bForce );
        } while ( lResult > 2 );

        if ( lResult == 1 )
        {
            lResult = RecursiveDeleteKey(
                params.hRootKey, params.pwszSubKey, 0, &params );
        }
        else
        {
            SaveErrorMessage( ERROR_CANCELLED );
            ShowLastErrorEx( stdout, SLE_INTERNAL );
            lResult = ERROR_SUCCESS;
        }
    }

    // return
    FreeGlobalData( &params );
    return ((lResult == ERROR_SUCCESS) ? 0 : 1);
}


//------------------------------------------------------------------------//
//
// ParseDeleteCmdLine()
//
//------------------------------------------------------------------------//
BOOL
ParseDeleteCmdLine( DWORD argc, LPCWSTR argv[],
                    PTREG_PARAMS pParams, BOOL* pbUsage )
{
    // local variables
    DWORD dw = 0;
    LONG lResult = 0;
    DWORD dwLength = 0;
    BOOL bResult = FALSE;
    BOOL bHasValue = FALSE;

    // check the input
    if ( argc == 0 || argv == NULL || pParams == NULL || pbUsage == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // check whether this function is being called for
    // valid operation or not
    if ( pParams->lOperation < 0 || pParams->lOperation >= REG_OPTIONS_COUNT )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if( argc < 3 || argc > 6 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_DELETE ] );
        return FALSE;
    }
    else if ( StringCompareEx( argv[ 1 ], L"DELETE", TRUE, 0 ) != 0 )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    else if ( InString( argv[ 2 ], L"-?|/?|-h|/h", TRUE ) == TRUE )
    {
        if ( argc == 3 )
        {
            *pbUsage = TRUE;
            return TRUE;
        }
        else
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_DELETE ] );
            return FALSE;
        }
    }

    // Machine Name and Registry key
    //
    bResult = BreakDownKeyString( argv[ 2 ], pParams );
    if( bResult == FALSE )
    {
        return FALSE;
    }

    // parsing
    bResult = TRUE;
    lResult = ERROR_SUCCESS;
    for( dw = 3; dw < argc; dw++ )
    {
        if( StringCompareEx( argv[ dw ], L"/v", TRUE, 0 ) == 0 )
        {
            if( bHasValue == TRUE )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            dw++;
            if( dw < argc )
            {
                dwLength = StringLength( argv[ dw ], 0 ) + 1;
                pParams->pwszValueName =
                    (LPWSTR) AllocateMemory( (dwLength + 5) * sizeof( WCHAR ) );
                if ( pParams->pwszValueName == NULL )
                {
                    lResult = ERROR_OUTOFMEMORY;
                    break;
                }

                bHasValue = TRUE;
                StringCopy( pParams->pwszValueName, argv[ dw ], dwLength );
            }
            else
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }
        }
        else if( StringCompareEx( argv[ dw ], L"/ve", TRUE, 0 ) == 0 )
        {
            if( bHasValue == TRUE )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            pParams->pwszValueName =
                (LPWSTR) AllocateMemory( 2 * sizeof( WCHAR ) );
            if ( pParams->pwszValueName == NULL )
            {
                lResult = ERROR_OUTOFMEMORY;
                break;
            }

            bHasValue = TRUE;
        }
        else if( StringCompareEx( argv[ dw ], L"/va", TRUE, 0 ) == 0 )
        {
            if( bHasValue == TRUE )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            bHasValue = TRUE;
            pParams->bAllValues = TRUE;
        }
        else if( StringCompareEx( argv[ dw ], L"/f", TRUE, 0 ) == 0 )
        {
            if ( pParams->bForce == TRUE )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            pParams->bForce = TRUE;
        }
        else
        {
            bResult = FALSE;
            lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
            break;
        }
    }

    if( lResult != ERROR_SUCCESS )
    {
        if( bResult == FALSE )
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1,
                ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_DELETE ] );
        }
        else
        {
            SaveErrorMessage( lResult );
        }
    }

    return (lResult == ERROR_SUCCESS);
}


//-----------------------------------------------------------------------//
//
// RecursiveDeleteKey() - Recursive registry key delete
//
//-----------------------------------------------------------------------//
LONG
RecursiveDeleteKey( HKEY hKey,
                    LPCWSTR pwszName,
                    DWORD dwDepth,
                    PTREG_PARAMS pParams )
{
    // local variables
    LONG lResult = 0;
    DWORD dw = 0;
    DWORD dwIndex = 0;
    DWORD dwCount = 0;
    HKEY hSubKey = NULL;
    LONG lLastResult = 0;
    DWORD dwNumOfSubkey = 0;
    DWORD dwLenOfKeyName = 0;
    LPWSTR pwszNameBuf = NULL;
    TARRAY arrValues = NULL;
    LPCWSTR pwszTemp = NULL;

    if( hKey == NULL || pwszName == NULL || pParams == NULL )
    {
        lResult = ERROR_INVALID_PARAMETER;
        goto exitarea;
    }

    //
    // Open the SubKey
    //
    lResult = RegOpenKeyEx( hKey, pwszName, 0, KEY_ALL_ACCESS, &hSubKey );
    if( lResult != ERROR_SUCCESS )
    {
        goto exitarea;
    }

    // query key info
    lResult = RegQueryInfoKey( hSubKey,
                               NULL, NULL, NULL,
                               &dwNumOfSubkey, &dwLenOfKeyName,
                               NULL, NULL, NULL, NULL, NULL, NULL );

    if( lResult != ERROR_SUCCESS )
    {
        SafeCloseKey( &hSubKey );
        goto exitarea;
    }
    else if ( dwNumOfSubkey == 0 )
    {
        SafeCloseKey( &hSubKey );
        lResult = RegDeleteKey( hKey, pwszName );
        goto exitarea;
    }

    //
    // SPECIAL CASE:
    // -------------
    // For HKLM\SYSTEM\CONTROLSET002 it is found to be API returning value 0 for dwMaxLength
    // though there are subkeys underneath this -- to handle this, we are doing a workaround
    // by assuming the max registry key length
    //
    if ( dwLenOfKeyName == 0 )
    {
        dwLenOfKeyName = 256;
    }
    else if ( dwLenOfKeyName < 256 )
    {
        // always assume 100% more length that what is returned by the API
        dwLenOfKeyName *= 2;
    }

    // create the dynamic array
    arrValues = CreateDynamicArray();
    if ( arrValues == NULL )
    {
        SafeCloseKey( &hSubKey );
        lResult = ERROR_OUTOFMEMORY;
        goto exitarea;
    }

    // create buffer
    //
    // bump the length to take into account the terminator.
    dwLenOfKeyName++;
    pwszNameBuf = (LPWSTR) AllocateMemory( (dwLenOfKeyName + 2) * sizeof( WCHAR ) );
    if ( pwszNameBuf == NULL )
    {
        SafeCloseKey( &hSubKey );
        DestroyDynamicArray( &arrValues );
        lResult = ERROR_OUTOFMEMORY;
        goto exitarea;
    }

    // Now Enumerate all of the keys
    dwIndex = 0;
    lResult = ERROR_SUCCESS;
    lLastResult = ERROR_SUCCESS;
    while( dwIndex < dwNumOfSubkey )
    {
        dw = dwLenOfKeyName;
        SecureZeroMemory( pwszNameBuf, dw * sizeof( WCHAR ) );
        lResult = RegEnumKeyEx( hSubKey,
                                dwIndex, pwszNameBuf,
                                &dw, NULL, NULL, NULL, NULL);

        // check the result
        if ( lResult == ERROR_SUCCESS )
        {
            if ( DynArrayAppendString( arrValues, pwszNameBuf, 0 ) == -1 )
            {
                lResult = lLastResult = ERROR_OUTOFMEMORY;
                break;
            }
        }
        else if ( lLastResult == ERROR_SUCCESS )
        {
            lLastResult = lResult;
        }

        dwIndex++;
    }

    // free memory
    FreeMemory( &pwszNameBuf );

    dwCount = DynArrayGetCount( arrValues );
    if ( lResult != ERROR_OUTOFMEMORY && dwCount != 0 )
    {
        //
        // start recurise delete
        //

        dw = 0;
        lResult = ERROR_SUCCESS;
        lLastResult = ERROR_SUCCESS;
        for( dwIndex = 0; dwIndex < dwCount; dwIndex++ )
        {
            // get the item
            pwszTemp = DynArrayItemAsString( arrValues, dwIndex );

            // try to delete the sub key
            lResult = RecursiveDeleteKey( hSubKey, pwszTemp, dwDepth + 1, pParams );
            if ( lResult != ERROR_SUCCESS )
            {
                if ( lLastResult == ERROR_SUCCESS )
                {
                    lLastResult = lResult;
                }
            }
            else
            {
                dw++;
            }
        }

        if ( dw == 0 )
        {
            lResult = lLastResult;
        }
        else if ( dwCount != dwNumOfSubkey || dw != dwCount )
        {
            lResult = STG_E_INCOMPLETE;
        }
        else
        {
            lResult = ERROR_SUCCESS;
        }
    }
    else
    {
        lResult = lLastResult;
    }

    // release the memory allocate for dynamic array
    DestroyDynamicArray( &arrValues );

    // close this subkey and delete it
    SafeCloseKey( &hSubKey );

    // delete the key if the result is success
    if ( lResult == ERROR_SUCCESS )
    {
        lResult = RegDeleteKey( hKey, pwszName );
    }


exitarea:

    // check the result and display the error message
    // NOTE: error message display should be done only at the exit point
    if ( dwDepth == 0 )
    {
        if ( lResult != ERROR_SUCCESS )
        {
            if ( lResult == STG_E_INCOMPLETE )
            {
                SetReason( ERROR_DELETEPARTIAL );
            }
            else
            {
                SaveErrorMessage( lResult );
            }

            // display the error
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        }
        else
        {
            SaveErrorMessage( ERROR_SUCCESS );
            ShowLastErrorEx( stdout, SLE_INTERNAL );
        }
    }

    // return
    return lResult;
}


LONG
DeleteValues( PTREG_PARAMS pParams )
{
    // local variables
    DWORD dw = 0;
    DWORD dwCount = 0;
    DWORD dwIndex = 0;
    LONG lResult = 0;
    HKEY hSubKey = NULL;
    LONG lLastResult = 0;
    LPCWSTR pwszTemp = NULL;
    LPCWSTR pwszList = NULL;
    LPCWSTR pwszFormat = NULL;
    DWORD dwNumOfValues = 0;
    DWORD dwLengthOfValueName = 0;
    LPWSTR pwszNameBuf = NULL;
    TARRAY arrValues = NULL;

    // check the input
    if ( pParams == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        return ERROR_INVALID_PARAMETER;
    }

    pwszList = GetResString2( IDS_CONFIRM_CHOICE_LIST, 1 );
    if( pParams->bAllValues == TRUE )
    {
        pwszTemp = pParams->pwszFullKey;
        pwszFormat = GetResString2( IDS_DELETEALL_CONFIRM, 0 );
    }
    else if ( pParams->pwszValueName != NULL )
    {
        if ( StringLength( pParams->pwszValueName, 0 ) == 0 )
        {
            pwszTemp = GetResString2( IDS_NONAME, 0 );
        }
        else
        {
            pwszTemp = pParams->pwszValueName;
        }

        // ...
        pwszFormat = GetResString2( IDS_DELETE_CONFIRM, 2 );
    }
    else
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        lResult = Prompt( pwszFormat,
            pwszTemp, pwszList, pParams->bForce );
    } while ( lResult > 2 );

    if ( lResult == 2 )
    {
        SaveErrorMessage( ERROR_CANCELLED );
        ShowLastErrorEx( stdout, SLE_INTERNAL );
        return ERROR_CANCELLED;
    }

    // Open the registry key
    lResult = RegOpenKeyEx( pParams->hRootKey,
        pParams->pwszSubKey, 0, KEY_ALL_ACCESS, &hSubKey );
    if( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return lResult;
    }

    // create the dynamic array
    arrValues = CreateDynamicArray();
    if ( arrValues == NULL )
    {
        SafeCloseKey( &hSubKey );
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return ERROR_OUTOFMEMORY;
    }

    if( pParams->pwszValueName != NULL )   // delete a single value
    {
        lResult = RegDeleteValue( hSubKey, pParams->pwszValueName );
    }
    else if( pParams->bAllValues == TRUE )  // delete all values
    {
        // query source key info
        lResult = RegQueryInfoKey( hSubKey,
            NULL, NULL, NULL, NULL, NULL, NULL,
            &dwNumOfValues, &dwLengthOfValueName, NULL, NULL, NULL);

        if( lResult == ERROR_SUCCESS && dwNumOfValues != 0 )
        {
            // create buffer
            // bump the length to take into account the terminator.
            dwLengthOfValueName++;
            pwszNameBuf =
                (LPWSTR) AllocateMemory( (dwLengthOfValueName + 2) * sizeof(WCHAR) );
            if ( pwszNameBuf == NULL )
            {
                lResult = ERROR_OUTOFMEMORY;
            }
            else
            {
                // Now Enumerate all values
                dwIndex = 0;
                lResult = ERROR_SUCCESS;
                lLastResult = ERROR_SUCCESS;
                while( dwIndex < dwNumOfValues )
                {
                    dw = dwLengthOfValueName;
                    SecureZeroMemory( pwszNameBuf, dw * sizeof( WCHAR ) );
                    lResult = RegEnumValue( hSubKey, dwIndex,
                        pwszNameBuf, &dw, NULL, NULL, NULL, NULL);

                    if ( lResult == ERROR_SUCCESS )
                    {
                        if ( DynArrayAppendString( arrValues,
                                                   pwszNameBuf, 0 ) == -1 )
                        {
                            lResult = lLastResult = ERROR_OUTOFMEMORY;
                            break;
                        }
                    }
                    else if ( lLastResult == ERROR_SUCCESS )
                    {
                        lLastResult = lResult;
                    }

                    dwIndex++;
                }

                // free memory
                FreeMemory( &pwszNameBuf );

                dwCount = DynArrayGetCount( arrValues );
                if ( lResult != ERROR_OUTOFMEMORY && dwCount != 0 )
                {
                    dw = 0;
                    dwIndex = 0;
                    lResult = ERROR_SUCCESS;
                    lLastResult = ERROR_SUCCESS;
                    for( dwIndex = 0; dwIndex < dwCount; dwIndex++ )
                    {
                        // delete the value
                        pwszTemp = DynArrayItemAsString( arrValues, dwIndex );
                        lResult = RegDeleteValue( hSubKey, pwszTemp );
                        if ( lResult != ERROR_SUCCESS )
                        {
                            if ( lLastResult == ERROR_SUCCESS )
                            {
                                lLastResult = lResult;
                            }
                        }
                        else
                        {
                            dw++;
                        }
                    }

                    if ( dw == 0 )
                    {
                        lResult = lLastResult;
                    }
                    else if ( dwCount != dwNumOfValues || dw != dwCount )
                    {
                        lResult = STG_E_INCOMPLETE;
                    }
                    else
                    {
                        lResult = ERROR_SUCCESS;
                    }
                }
                else
                {
                    lResult = lLastResult;
                }
            }
        }
    }

    // close the sub key
    SafeCloseKey( &hSubKey );

    // check the result
    if ( lResult != ERROR_SUCCESS )
    {
        if ( lResult == STG_E_INCOMPLETE )
        {
            SetReason( ERROR_DELETEPARTIAL );
        }
        else
        {
            SaveErrorMessage( lResult );
        }

        // display the error
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }
    else
    {
        SaveErrorMessage( ERROR_SUCCESS );
        ShowLastErrorEx( stdout, SLE_INTERNAL );
    }

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\query.c ===
//-----------------------------------------------------------------------//
//
// File:    query.cpp
// Created: Jan 1997
// By:      Martin Holladay (a-martih)
// Purpose: Registry Query Support for REG.CPP
// Modification History:
//    Created - Jan 1997 (a-martih)
//    Aug 1997 (John Whited) Implemented a Binary output function for
//            REG_BINARY
//    Oct 1997 (martinho) fixed output for REG_MULTI_SZ \0 delimited strings
//    April 1998 - MartinHo - Incremented to 1.05 for REG_MULTI_SZ bug fixes.
//            Correct support for displaying query REG_MULTI_SZ of. Fix AV.
//    April 1999 Zeyong Xu: re-design, revision -> version 2.0
//
//------------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"

//
// query specific structure
//
typedef struct __tagRegQueryInfo
{
    // instance level variables
    BOOL bShowKey;
    BOOL bKeyMatched;
    BOOL bValueNameMatched;
    BOOL bUpdateMatchCount;

    // ...
    DWORD dwMatchCount;
} TREG_QUERY_INFO, *PTREG_QUERY_INFO;

//
// function prototypes
//
BOOL ParseQueryCmdLine( DWORD argc, LPCWSTR argv[],
                        PTREG_PARAMS pParams, BOOL* pbUsage );
LONG QueryValue( HKEY hKey,
                 LPCWSTR pwszFullKey, LPCWSTR pwszValueName,
                 PTREG_PARAMS pParams, PTREG_QUERY_INFO pInfo );
LONG QueryEnumValues( HKEY hKey,
                      LPCWSTR pwszFullKey,
                      PTREG_PARAMS pParams, PTREG_QUERY_INFO pInfo );
LONG QueryEnumKeys( HKEY hKey,
                    LPCWSTR pwszFullKey,
                    PTREG_PARAMS pParams, PTREG_QUERY_INFO pInfo );
BOOL SearchData( LPBYTE pByteData, DWORD dwType,
                 DWORD dwSize, PTREG_PARAMS pParams );
BOOL ParseTypeInfo( LPCWSTR pwszTypes, PTREG_PARAMS pParams );


//
// implementation
//

//-----------------------------------------------------------------------//
//
// QueryRegistry()
//
//-----------------------------------------------------------------------//

LONG
QueryRegistry( DWORD argc, LPCWSTR argv[] )
/*++
   Routine Description:
    Main function for QUERY option which calls appropriate functions

   Arguments:
        None
   Return Value:
        ERROR_SUCCESS on success
        EXIT_FAILURE on failure
--*/
{
    // local variables
    LONG lResult = 0;
    HKEY hKey = NULL;
    BOOL bResult = FALSE;
    BOOL bUsage = FALSE;
    TREG_PARAMS params;
    DWORD dwExitCode = 0;
    TREG_QUERY_INFO info;
    BOOL bSearchMessage = FALSE;

    if ( argc == 0 || argv == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ShowLastError( stderr );
        return 1;
    }

    // initialize the global data structure
    InitGlobalData( REG_QUERY, &params );

    //
    // Parse the cmd-line
    //
    bResult = ParseQueryCmdLine( argc, argv, &params, &bUsage );
    if ( bResult == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    // check whether we need to display the usage
    if ( bUsage == TRUE )
    {
        Usage( REG_QUERY );
        FreeGlobalData( &params );
        return 0;
    }

    //
    // Connect to the Remote Machine(s) - if applicable
    //
    bResult = RegConnectMachine( &params );
    if( bResult == FALSE )
    {
        SaveErrorMessage( -1 );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    //
    // Open the registry key
    //
    lResult = RegOpenKeyEx( params.hRootKey,
        params.pwszSubKey, 0, KEY_READ, &hKey );
    if( lResult != ERROR_SUCCESS)
    {
        SaveErrorMessage( lResult );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    // show a blank line below starting the output
    ShowMessage( stdout, L"\n" );

    //
    // do the query
    //
    ZeroMemory( &info, sizeof( TREG_QUERY_INFO ) );
    if( params.pwszSearchData == NULL &&
        params.pwszValueName != NULL &&
        params.arrTypes == NULL &&
        params.bRecurseSubKeys == FALSE )
    {
        info.bShowKey = TRUE;
        if ( params.pwszValueName != NULL &&
             ( StringLength( params.pwszValueName, 0 ) == 0 || 
			   FindOneOf2( params.pwszValueName, L"*?", TRUE, 0 ) == -1 ) )
        {
            lResult = QueryValue( hKey,
                params.pwszFullKey, params.pwszValueName, &params, &info );

            bSearchMessage = FALSE;
            ShowMessage( stdout, L"\n" );
        }
        else
        {
            bSearchMessage = TRUE;
            lResult = QueryEnumValues( hKey, params.pwszFullKey, &params, &info );
        }
    }
    else
    {
        info.bShowKey = TRUE;
        lResult = QueryEnumKeys( hKey, params.pwszFullKey, &params, &info );

        // determine the kind of success message that needs to be displayed
        bSearchMessage = ! ( params.pwszSearchData == NULL &&
             params.pwszValueName == NULL && params.arrTypes == NULL );
    }

	dwExitCode = 0;
    if ( lResult == ERROR_SUCCESS )
    {
        if ( bSearchMessage == FALSE )
        {
			//
			// BUG: 698877	Reg.exe: Need to turn off newly-added success messages to avoid breaking scripts 
			//				that parse output
			//
            // SaveErrorMessage( ERROR_SUCCESS );
            // ShowLastErrorEx( stdout, SLE_INTERNAL );
			//
        }
        else
        {
			if ( info.dwMatchCount == 0 )
			{
				dwExitCode = 1;
			}

			// ...
            ShowMessageEx( stdout, 1, TRUE, STATISTICS_QUERY, info.dwMatchCount );
        }
    }
    else
    {
        dwExitCode = 1;
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // release the handle
    SafeCloseKey( &hKey );

    // return the error code
    return dwExitCode;
}


//------------------------------------------------------------------------//
//
// ParseQueryCmdLine()
//
//------------------------------------------------------------------------//

BOOL
ParseQueryCmdLine( DWORD argc,
                   LPCWSTR argv[],
                   PTREG_PARAMS pParams, BOOL* pbUsage )
/*++
   Routine Description:
    Parse the command line arguments

   Arguments:
        None
   Return Value:
        REG_STATUS
--*/
{
    //
    // local variables
    DWORD dw = 0;
    DWORD dwLength = 0;
    LPCWSTR pwszTemp = NULL;
    LPCWSTR pwszSearchData = NULL;

    // query parser result trackers
    LONG lResult = 0;
    BOOL bResult = FALSE;

    // query operation validators
    BOOL bHasSeparator = FALSE;

    //
    // implementation starts from here
    //

    // check the input
    if ( argc == 0 || argv == NULL || pParams == NULL || pbUsage == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // check whether this function is being called for
    // valid operation or not
    if ( pParams->lOperation < 0 || pParams->lOperation >= REG_OPTIONS_COUNT )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Do we have a *valid* number of cmd-line params
    //
    if( argc < 3 || argc > 12 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_QUERY ] );
        return FALSE;
    }
    else if ( StringCompareEx( argv[ 1 ], L"QUERY", TRUE, 0 ) != 0 )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    else if( InString( argv[ 2 ], L"/?|-?|/h|-h", TRUE ) == TRUE )
    {
        if ( argc == 3 )
        {
            *pbUsage = TRUE;
            return TRUE;
        }
        else
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_QUERY ] );
            return FALSE;
        }
    }

    // Machine Name and Registry key
    //
    bResult = BreakDownKeyString( argv[ 2 ], pParams );
    if( bResult == FALSE )
    {
        return FALSE;
    }

    // parsing the command line arguments
    bResult = TRUE;
    lResult = ERROR_SUCCESS;
    pParams->dwSearchFlags = 0;
    pParams->bExactMatch = FALSE;
    pParams->bCaseSensitive = FALSE;
    pParams->bRecurseSubKeys = FALSE;
    pParams->bShowTypeNumber = FALSE;
    for( dw = 3; dw < argc; dw++ )
    {
        // /f -- search the registry
        if( StringCompareEx( argv[ dw ], L"/f", TRUE, 0 ) == 0 )
        {
            if ( pwszSearchData != NULL )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            // ...
            dw++;
            if( dw < argc )
            {
                pwszSearchData = argv[ dw ];
            }
            else
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }
        }

        // /k -- searches the REGISTRY KEYS
        else if ( StringCompareEx( argv[ dw ], L"/k", TRUE, 0 ) == 0 )
        {
            if ( pParams->dwSearchFlags & REG_FIND_KEYS )
            {
                // /k is already specified
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            // ...
            pParams->dwSearchFlags |= REG_FIND_KEYS;
        }

        // /v -- searches/displays contents of the specific value names
        else if( StringCompareEx( argv[ dw ], L"/v", TRUE, 0 ) == 0 )
        {
            if( pParams->pwszValueName != NULL ||
                (pParams->dwSearchFlags & REG_FIND_VALUENAMES) )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            if( dw + 1 < argc )
            {
                // determine the length of the current argument
                dwLength = StringLength( argv[ dw + 1 ], 0 );

                // since the value for the /v switch is optional,
                // we need to see if the user specified the next switch
                // or data to this switch
                if ( dwLength < 2 ||
                     argv[ dw + 1 ][ 0 ] != L'/' ||
                     InString( argv[ dw + 1 ] + 1, L"z|ve|f|k|d|c|e|s|t|se", TRUE ) == FALSE )
                {
                    // get the value for /v
                    dw++;
                    dwLength++;
                    pParams->pwszValueName = (LPWSTR) AllocateMemory( dwLength * sizeof( WCHAR ) );
                    if ( pParams->pwszValueName == NULL )
                    {
                        lResult =  ERROR_OUTOFMEMORY;
                        break;
                    }

                    // ...
                    StringCopy( pParams->pwszValueName, argv[ dw ], dwLength );
                }
            }
            else
            {
                // since the value for the /v is optional
                // this is a valid condition
            }

            // if the /v is specified and no memory is allocated for the buffer
            if ( pParams->pwszValueName == NULL )
            {
                // set the flag
                pParams->dwSearchFlags |= REG_FIND_VALUENAMES;
            }
        }

        // /ve -- displays the data for empty value name "(Default)"
        else if( StringCompareEx( argv[ dw ], L"/ve", TRUE, 0 ) == 0 )
        {
            if( pParams->pwszValueName != NULL ||
                (pParams->dwSearchFlags & REG_FIND_VALUENAMES) )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            pParams->pwszValueName = (LPWSTR) AllocateMemory( 2 * sizeof( WCHAR ) );
            if ( pParams->pwszValueName == NULL)
            {
                lResult = ERROR_OUTOFMEMORY;
                break;
            }
        }

        // /d -- searches the DATA field of the REGISTRY
        else if ( StringCompareEx( argv[ dw ], L"/d", TRUE, 0 ) == 0 )
        {
            if ( pParams->dwSearchFlags & REG_FIND_DATA )
            {
                // /d is already specified
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            // ...
            pParams->dwSearchFlags |= REG_FIND_DATA;
        }

        // /c -- case sensitive search
        else if( StringCompareEx( argv[ dw ], L"/c", TRUE, 0 ) == 0 )
        {
            if ( pParams->bCaseSensitive == TRUE )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            // ...
            pParams->bCaseSensitive = TRUE;
        }

        // /e -- exact text match
        else if( StringCompareEx( argv[ dw ], L"/e", TRUE, 0 ) == 0 )
        {
            if ( pParams->bExactMatch == TRUE )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            // ...
            pParams->bExactMatch = TRUE;
        }

        // /z -- show the type number along with the text
        else if ( StringCompareEx( argv[ dw ], L"/z", TRUE, 0 ) == 0 )
        {
            if ( pParams->bShowTypeNumber == TRUE )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            // ...
            pParams->bShowTypeNumber = TRUE;
        }

        // /s -- recursive search/display
        else if( StringCompareEx( argv[ dw ], L"/s", TRUE, 0 ) == 0 )
        {
            if( pParams->bRecurseSubKeys == TRUE )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            pParams->bRecurseSubKeys = TRUE;
        }

        // /se -- seperator to display for REG_MULTI_SZ valuename type
        else if( StringCompareEx( argv[ dw ], L"/se", TRUE, 0 ) == 0 )
        {
            if( bHasSeparator == TRUE )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            dw++;
            if( dw < argc )
            {
                if( StringLength( argv[ dw ], 0 ) == 1 )
                {
                    bHasSeparator = TRUE;
                    StringCopy( pParams->wszSeparator,
                        argv[ dw ], SIZE_OF_ARRAY( pParams->wszSeparator ) );
                }
                else
                {
                    bResult = FALSE;
                    lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                    break;
                }
            }
            else
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }
        }

        // /t -- REGISTRY value type that only needs to be shown
        else if( StringCompareEx( argv[ dw ], L"/t", TRUE, 0 ) == 0 )
        {
            if ( pParams->arrTypes != NULL )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }

            dw++;
            if( dw < argc )
            {
                if ( ParseTypeInfo( argv[ dw ], pParams ) == FALSE )
                {
                    if ( GetLastError() == (DWORD) MK_E_SYNTAX )
                    {
                        bResult = FALSE;
                        lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                        break;
                    }
                    else
                    {
                        bResult = TRUE;
                        lResult = GetLastError();
                        break;
                    }
                }
            }
            else
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
                break;
            }
        }

        // default -- invalid
        else
        {
            bResult = FALSE;
            lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
            break;
        }
    }

    //
    // validate the search information specified
    if ( lResult == ERROR_SUCCESS )
    {
        if ( pwszSearchData == NULL )
        {
            if ( pParams->dwSearchFlags != 0 ||
                 pParams->bExactMatch == TRUE ||
                 pParams->bCaseSensitive == TRUE )
            {
                bResult = FALSE;
                lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
            }
        }
        else if ( pParams->dwSearchFlags == 0 )
        {
            if ( pParams->pwszValueName == NULL )
            {
                pParams->dwSearchFlags = REG_FIND_ALL;
            }
            else
            {
                pParams->dwSearchFlags = REG_FIND_KEYS | REG_FIND_DATA;
            }
        }
    }

    // prepare the final search pattern
    if ( pwszSearchData != NULL && lResult == ERROR_SUCCESS )
    {
        // determine the length of the search pattern
        dwLength = StringLength( pwszSearchData, 0 );
        if ( pParams->bExactMatch == FALSE )
        {
            dwLength += 2;
        }

        // accomodate space for null characters
        dwLength++;

        // allocate memory
        pParams->pwszSearchData = AllocateMemory( (dwLength + 2) * sizeof( WCHAR ) );
        if ( pParams->pwszSearchData == NULL )
        {
            lResult = ERROR_OUTOFMEMORY;
        }
        else
        {
            // if the /e is not specified -- we will search for "*<text>*"
            // otherwise if /e is specified we will search exactly for "<text>"
            // where "<text>" is what is specified by user at the command prompt

            StringCopy( pParams->pwszSearchData, L"", dwLength );
            if ( pParams->bExactMatch == FALSE )
            {
                StringCopy( pParams->pwszSearchData, L"*", dwLength );
            }

            // ...
            StringConcat( pParams->pwszSearchData, pwszSearchData, dwLength );

            // ...
            if ( pParams->bExactMatch == FALSE )
            {
                StringConcat( pParams->pwszSearchData, L"*", dwLength );
            }
        }
    }

    //
    // if /t is specified, then /s needs to be specified
    // if /s is not specified, then atleast /v or /ve should not be specified
    //
    // if ( lResult == ERROR_SUCCESS && pParams->arrTypes != NULL &&
    //      pParams->bRecurseSubKeys == FALSE && pParams->pwszValueName != NULL )
    // {
    //     bResult = FALSE;
    //     lResult = IDS_ERROR_INVALID_SYNTAX_WITHOPT;
    // }

    //
    // parse the pattern information if specified by user and store only
    // the optimized version of it
    //
    if ( lResult == ERROR_SUCCESS )
    {
        //
        // value name
        //
        if ( pParams->pwszValueName != NULL &&
             StringLength( pParams->pwszValueName, 0 ) != 0 )
        {
            pwszTemp = ParsePattern( pParams->pwszValueName );
            if ( pwszTemp == NULL )
            {
                lResult = GetLastError();
            }

            // copy the optimized pattern into the original buffer
            dw = GetBufferSize( pParams->pwszValueName );
            StringCopy( pParams->pwszValueName, pwszTemp, dw );
        }

        //
        // search data
        //
        if ( pParams->pwszSearchData != NULL )
        {
            pwszTemp = ParsePattern( pParams->pwszSearchData );
            if ( pwszTemp == NULL )
            {
                lResult = GetLastError();
            }

            // copy the optimized pattern into the original buffer
            dw = GetBufferSize( pParams->pwszSearchData );
            StringCopy( pParams->pwszSearchData, pwszTemp, dw );
        }
    }

    //
    // check the end result
    //
    if( lResult != ERROR_SUCCESS )
    {
        if( bResult == FALSE )
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_QUERY ] );
        }
        else
        {
            SaveErrorMessage( lResult );
        }
    }
    else
    {
    }

    // return the result
    return (lResult == ERROR_SUCCESS);
}


//-----------------------------------------------------------------------//
//
// QueryValue()
//
//-----------------------------------------------------------------------//
LONG
QueryValue( HKEY hKey,
            LPCWSTR pwszFullKey,
            LPCWSTR pwszValueName,
            PTREG_PARAMS pParams, PTREG_QUERY_INFO pInfo )
{
    // local variables
    LONG lResult = 0;
    DWORD dwType = 0;
    DWORD dwLength = 0;
    PBYTE pByteData = NULL;
    TREG_SHOW_INFO showinfo;
    BOOL bDataMatched = FALSE;

    // check the input
    if ( hKey == NULL || pwszFullKey == NULL ||
         pwszValueName == NULL || pParams == NULL || pInfo == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        lResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // get the size of the buffer to hold the value associated with the value name
    lResult = RegQueryValueEx( hKey, pwszValueName, NULL, NULL, NULL, &dwLength );
    if ( lResult != ERROR_SUCCESS )
    {
        // special case -- "(Default)" value
        if ( lResult == ERROR_FILE_NOT_FOUND &&
             StringLength( pwszValueName, 0 ) == 0 )
        {
            dwLength = StringLength( GetResString2( IDS_VALUENOTSET, 0 ), 0 ) + 1;
            dwLength *= sizeof( WCHAR );
        }
        else
        {
            SaveErrorMessage( lResult );
            goto cleanup;
        }
    }

    //
    // to handle the corrupted registry data properly, adjust the memory
    // allocation size which is divisible by 2
    //
    dwLength += (dwLength % 2);

    // allocate the buffer
    pByteData = (LPBYTE) AllocateMemory( (dwLength + 2) * sizeof( BYTE ) );
    if ( pByteData == NULL )
    {
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        lResult = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    // now get the data
    lResult = RegQueryValueEx( hKey, pwszValueName, NULL, &dwType, pByteData, &dwLength );
    if ( lResult != ERROR_SUCCESS )
    {
        // special case -- "(Default)" value
        if ( lResult == ERROR_FILE_NOT_FOUND &&
             StringLength( pwszValueName, 0 ) == 0 )
        {
            dwType = REG_SZ;
            StringCopy( (LPWSTR) pByteData,
                GetResString2( IDS_VALUENOTSET, 0 ), dwLength / sizeof( WCHAR ));
        }
        else
        {
            SaveErrorMessage( lResult );
            goto cleanup;
        }
    }

    // check whether the data matches with the search pattern specified
    bDataMatched = TRUE;                // default
    if ( pInfo->bValueNameMatched == FALSE )
    {
        if ( pParams->dwSearchFlags & REG_FIND_DATA )
        {
            bDataMatched = SearchData( pByteData, dwType, dwLength, pParams );
            if ( bDataMatched == TRUE )
            {
                pInfo->dwMatchCount++;
            }
        }
    }

    // check the result of the search
    if ( bDataMatched == FALSE )
    {
        SetLastError( ERROR_NOT_FOUND );
        lResult = ERROR_SUCCESS;
        goto cleanup;
    }

    // if the bUpdateMatchCount flag is set -- increment the matched
    // count by 1 and reset the flag
    if ( pInfo->bUpdateMatchCount == TRUE )
    {
        if ( pParams->pwszValueName == NULL && pParams->arrTypes == NULL )
        {
            pInfo->dwMatchCount++;
        }

        // ...
        pInfo->bUpdateMatchCount = FALSE;
    }

    // show the full key -- if needed
    if ( pInfo->bShowKey == TRUE )
    {
        // display the key path for which query proceeds
        ShowMessageEx( stdout, 1, TRUE, L"%s\n", pwszFullKey );

        // flag off -- this will block from display the full key for each value
        pInfo->bShowKey = FALSE;
    }

    // update the match count -- if needed
    if ( pParams->pwszValueName != NULL || pParams->arrTypes != NULL )
    {
        pInfo->dwMatchCount++;
    }

    // init to ZERO
    ZeroMemory( &showinfo, sizeof( TREG_SHOW_INFO ) );

    // set the data
    showinfo.pwszValueName = pwszValueName;
    showinfo.dwType = dwType;
    showinfo.pByteData = pByteData;
    showinfo.pwszSeparator = L"    ";
    showinfo.dwMaxValueNameLength = 0;
    showinfo.dwPadLength = 4;
    showinfo.dwSize = dwLength;
    showinfo.pwszMultiSzSeparator = pParams->wszSeparator;
    if ( pParams->bShowTypeNumber == TRUE )
    {
        showinfo.dwFlags |= RSI_SHOWTYPENUMBER;
    }

    // show
    ShowRegistryValue( &showinfo );

    // end result
    lResult = ERROR_SUCCESS;

cleanup:

    // release the memory
    FreeMemory( &pByteData );

    // return
    return lResult;
}


LONG
QueryEnumValues( HKEY hKey,
                 LPCWSTR pwszFullKey,
                 PTREG_PARAMS pParams, PTREG_QUERY_INFO pInfo )
/*++
   Routine Description:
    Queries Values and Data

   Arguments:
        None
   Return Value:
         ERROR_SUCCESS on success
         EXIT_FAILURE on failure
--*/
{
    // local variables
    DWORD dw = 0;
    LONG lResult = 0;
    DWORD dwType = 0;
    DWORD dwLength = 0;
    DWORD dwMaxLength = 0;
    DWORD dwValueNames = 0;
    LPWSTR pwszValueName = NULL;

    // check the input
    if ( hKey == NULL || pwszFullKey == NULL || pParams == NULL || pInfo == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return ERROR_INVALID_PARAMETER;
    }

    //
    // First find out how much memory to allocate.
    //
    lResult = RegQueryInfoKey( hKey,
        NULL, NULL, NULL, NULL, NULL, NULL,
        &dwValueNames, &dwMaxLength, NULL, NULL, NULL );
    if ( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        return lResult;
    }

    //
    // do the memory allocations
    //

    // value name
    dwMaxLength++;
    pwszValueName = (LPWSTR) AllocateMemory( dwMaxLength * sizeof( WCHAR ) );
    if ( pwszValueName == NULL )
    {
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        return lResult;
    }

    //
    // enumerate the value names and display
    //
    lResult = ERROR_SUCCESS;
    for( dw = 0; dw < dwValueNames; dw++ )
    {
        dwLength = dwMaxLength;
        ZeroMemory( pwszValueName, dwLength * sizeof( WCHAR ) );
        lResult = RegEnumValue( hKey, dw,
            pwszValueName, &dwLength, NULL, &dwType, NULL, NULL );
        if ( lResult != ERROR_SUCCESS )
        {
            SaveErrorMessage( lResult );
            break;
        }

        // check if user is looking for any explicit value name
        // this will improve the performance of the tool
        if ( pParams->pwszValueName != NULL &&
             MatchPatternEx( pwszValueName,
                             pParams->pwszValueName,
                             PATTERN_COMPARE_IGNORECASE | PATTERN_NOPARSING ) == FALSE )
        {
            // skip processing this value name
            continue;
        }

        // filter on type information
        if ( pParams->arrTypes != NULL &&
             DynArrayFindLongEx( pParams->arrTypes, 1, dwType ) == -1 )
        {
            // skip processing this value names
            continue;
        }

        // search for the pattern -- if needed
        pInfo->bValueNameMatched = TRUE;        // default
        if ( pParams->dwSearchFlags & REG_FIND_VALUENAMES )
        {
            pInfo->bValueNameMatched = SearchData(
                (BYTE*) pwszValueName, REG_SZ, dwLength * sizeof( WCHAR ), pParams );
            if ( pInfo->bValueNameMatched == FALSE )
            {
                if ( pParams->dwSearchFlags == REG_FIND_VALUENAMES )
                {
                    // user just want to search in the value names
                    // since the current didn't match skip this valuename
                    continue;
                }
            }
            else
            {
                if ( pParams->pwszValueName == NULL && pParams->arrTypes == NULL )
                {
                    pInfo->dwMatchCount++;
                }
            }
        }
        else if ( pParams->dwSearchFlags != 0 &&
                  pParams->pwszValueName == NULL && pParams->arrTypes == NULL )
        {
            pInfo->bValueNameMatched = FALSE;
        }

        // process the value of this regisry valuename
        if ( pInfo->bValueNameMatched == TRUE ||
             pParams->dwSearchFlags == 0 || pParams->dwSearchFlags & REG_FIND_DATA )
        {
            lResult = QueryValue( hKey, pwszFullKey, pwszValueName, pParams, pInfo );
        }
    }

    // show the new line at the end -- only if needed
    if ( pInfo->bShowKey == FALSE )
    {
        ShowMessage( stdout, L"\n" );
    }

    // release the memory
    FreeMemory( &pwszValueName );

    // return
    return lResult;
}


LONG
QueryEnumKeys( HKEY hKey,
               LPCWSTR pwszFullKey,
               PTREG_PARAMS pParams, PTREG_QUERY_INFO pInfo )
/*++
   Routine Description:
    Queries Values and Data

   Arguments:
        None
   Return Value:
         ERROR_SUCCESS on success
         EXIT_FAILURE on failure
--*/
{
    // local variables
    DWORD dw = 0;
    LONG lResult = 0;
    DWORD dwLength = 0;
    DWORD dwSubKeys = 0;
    DWORD dwMaxLength = 0;
    HKEY hSubKey = NULL;
    DWORD dwNewFullKeyLength = 0;
    LPWSTR pwszSubKey = NULL;
    LPWSTR pwszNewFullKey = NULL;

    // check the input
    if ( hKey == NULL ||
         pwszFullKey == NULL ||
         pParams == NULL || pInfo == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        lResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // show the values under the current hive first
    // NOTE: enumerate the values only when /F is not specified
    //       or subkey is matched or search flags specify to search in
    //       value names and/or data also
    if ( pInfo->bKeyMatched == TRUE &&
         pParams->dwSearchFlags == REG_FIND_KEYS &&
         pParams->pwszValueName == NULL && pParams->arrTypes == NULL )
    {
        // do nothing
    }
    else if ( pParams->dwSearchFlags == 0 ||
              pParams->dwSearchFlags != REG_FIND_KEYS ||
             (pInfo->bKeyMatched == TRUE && (pParams->pwszValueName != NULL || pParams->arrTypes != NULL)) )
    {
        lResult = QueryEnumValues( hKey, pwszFullKey, pParams, pInfo );
        if ( lResult != ERROR_SUCCESS )
        {
            goto cleanup;
        }
    }

    //
    // First find out how much memory to allocate.
    //
    lResult = RegQueryInfoKey( hKey, NULL, NULL, NULL,
        &dwSubKeys, &dwMaxLength, NULL, NULL, NULL, NULL, NULL, NULL );
    if ( lResult != ERROR_SUCCESS )
    {
        SaveErrorMessage( lResult );
        goto cleanup;
    }

    //
    // SPECIAL CASE:
    // -------------
    // For HKLM\SYSTEM\CONTROLSET002 it is found to be API returning value 0 for dwMaxLength
    // though there are subkeys underneath this -- to handle this, we are doing a workaround
    // by assuming the max registry key length
    //
    if ( dwSubKeys != 0 && dwMaxLength == 0 )
    {
        dwMaxLength = 256;
    }
    else if ( dwMaxLength < 256 )
    {
        // always assume 100% more length that what is returned by the API
        dwMaxLength *= 2;
    }

    //
    // do the memory allocations
    //

    // sub key
    dwMaxLength++;
    pwszSubKey = (LPWSTR) AllocateMemory( dwMaxLength * sizeof( WCHAR ) );
    if ( pwszSubKey == NULL )
    {
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        lResult = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    // buffer for new full key name
    dwNewFullKeyLength = StringLength( pwszFullKey, 0 ) + dwMaxLength + 1;
    pwszNewFullKey = (LPWSTR) AllocateMemory( dwNewFullKeyLength * sizeof( WCHAR ) );
    if ( pwszNewFullKey == NULL )
    {
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        lResult = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    //
    // enumerate the value names and display
    //
    lResult = ERROR_SUCCESS;
    for( dw = 0; dw < dwSubKeys; dw++ )
    {
        dwLength = dwMaxLength;
        ZeroMemory( pwszSubKey, dwLength * sizeof( WCHAR ) );
        lResult = RegEnumKeyEx( hKey, dw,
            pwszSubKey, &dwLength, NULL, NULL, NULL, NULL );
        if ( lResult != ERROR_SUCCESS )
        {
            // **********************************************************
            // simply ignore the error here -- for a detailed description
            // check the raid bug #572077
            // **********************************************************
            lResult = ERROR_SUCCESS;
            continue;
        }

        // search for the pattern -- if needed
        pInfo->bKeyMatched = TRUE;        // default
        pInfo->bUpdateMatchCount = FALSE;
        if ( pParams->dwSearchFlags & REG_FIND_KEYS )
        {
            pInfo->bKeyMatched = SearchData(
                (BYTE*) pwszSubKey, REG_SZ, dwLength * sizeof( WCHAR ), pParams );
            if ( pInfo->bKeyMatched == FALSE )
            {
                if ( pParams->bRecurseSubKeys == FALSE &&
                     pParams->dwSearchFlags == REG_FIND_KEYS )
                {
                    // user just want to search in the key names
                    // and there is no recursion
                    // since the current didn't match skip this key
                    continue;
                }
            }
            else
            {
                pInfo->bUpdateMatchCount = TRUE;
            }
        }
        else if ( pParams->dwSearchFlags != 0 || pParams->pwszValueName != NULL )
        {
            pInfo->bKeyMatched = FALSE;
        }

        // format the new full key name
        StringCopy( pwszNewFullKey, pwszFullKey, dwNewFullKeyLength );
        StringConcat( pwszNewFullKey, L"\\", dwNewFullKeyLength );
        StringConcat( pwszNewFullKey, pwszSubKey, dwNewFullKeyLength );

        // show the key name
        pInfo->bShowKey = TRUE;
        if ( pInfo->bKeyMatched == TRUE && pParams->pwszValueName == NULL && pParams->arrTypes == NULL )
        {
            // update the match count
            pInfo->dwMatchCount++;
            pInfo->bUpdateMatchCount = FALSE;

            // ...
            pInfo->bShowKey = FALSE;
            ShowMessageEx( stdout, 1, TRUE, L"%s\n", pwszNewFullKey );
        }

        // check whether we need to recurse or not
        if ( pParams->bRecurseSubKeys == TRUE )
        {
            lResult = RegOpenKeyEx( hKey, pwszSubKey, 0, KEY_READ, &hSubKey );
            if ( lResult == ERROR_SUCCESS )
            {
                // enumerate the sub-keys
                lResult = QueryEnumKeys( hSubKey, pwszNewFullKey, pParams, pInfo );

                // close the sub key
                SafeCloseKey( &hSubKey );
            }
            else
            {
                // **********************************************************
                // simply ignore the error here -- for a detailed description
                // check the raid bug #572077
                // **********************************************************
                lResult = ERROR_SUCCESS;
            }
        }
    }

cleanup:

    // release the memory
    FreeMemory( &pwszSubKey );
    FreeMemory( &pwszNewFullKey );

    // return
    return lResult;
}


BOOL
SearchData( LPBYTE pByteData, DWORD dwType,
            DWORD dwSize, PTREG_PARAMS pParams )
{
    // local variables
    DWORD dw = 0;
    DWORD dwLength = 0;
    BOOL bResult = FALSE;
    LPCWSTR pwszEnd = NULL;
    LPCWSTR pwszData = NULL;
    LPWSTR pwszString = NULL;
    LPCWSTR pwszSeparator = NULL;
    BOOL bShowSeparator = FALSE;
    DWORD dwFlags = 0;

    // check input
    if ( pByteData == NULL || pParams == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    switch( dwType )
    {
        case REG_SZ:
        case REG_EXPAND_SZ:
        {
            pwszData = (LPCWSTR) pByteData;
            break;
        }

        default:
        {
            // allocate memory which is double the (dwSize + 1) & +10 -> buffer
            // but do this only for types that need memory allocation
            dwLength = (dwSize + 1) * 2 + 10;
            pwszString = (LPWSTR) AllocateMemory( dwLength * sizeof( WCHAR ) );
            if ( pwszString == NULL )
            {
                return FALSE;
            }

            // ...
            pwszData = pwszString;
        }
    }

    switch( dwType )
    {
        case REG_MULTI_SZ:
        {
            //
            // Replace '\0' with "\0" for MULTI_SZ
            //
            pwszEnd = (LPCWSTR) pByteData;
            pwszSeparator = pParams->wszSeparator;
            StringCopy( pwszString, cwszNullString, dwLength );
            while( ((BYTE*) pwszEnd) < (pByteData + dwSize) )
            {
                if( *pwszEnd == 0 )
                {
                    // enable the display of value separator and skip this
                    pwszEnd++;
                    bShowSeparator = TRUE;
                }
                else
                {
                    // check whether we need to display the separator or not
                    if ( bShowSeparator == TRUE )
                    {
                        StringConcat( pwszString, pwszSeparator, dwLength );
                    }

                    // ...
                    StringConcat( pwszString, pwszEnd, dwLength );
                    pwszEnd += StringLength( pwszEnd, 0 );
                }
            }

            // ...
            break;
        }

        case REG_SZ:
        case REG_EXPAND_SZ:
            // do nothing
            break;

        default:
        {
            StringCopy( pwszString, cwszNullString, dwLength );
            for( dw = 0; dw < dwSize; dw++ )
            {
                if ( SetReason2( 1, L"%02X", pByteData[ dw ] ) == FALSE )
                {
                    FreeMemory( &pwszString );
                    SetLastError( ERROR_OUTOFMEMORY );
                    return FALSE;
                }

                // ...
                StringConcat( pwszString, GetReason(), dwLength );
            }

            // ...
            break;
        }

        case REG_DWORD:
        case REG_DWORD_BIG_ENDIAN:
        {
            if ( StringCompare( pParams->pwszSearchData, L"0x", TRUE, 2 ) == 0 )
            {
                if ( SetReason2( 1, L"0x%x", *((DWORD*) pByteData) ) == FALSE )
                {
                    FreeMemory( &pwszString );
                    SetLastError( ERROR_OUTOFMEMORY );
                    return FALSE;
                }
            }
            else
            {
                if ( SetReason2( 1, L"%d", *((DWORD*) pByteData) ) == FALSE )
                {
                    FreeMemory( &pwszString );
                    SetLastError( ERROR_OUTOFMEMORY );
                    return FALSE;
                }
            }

            // ...
            StringCopy( pwszString, GetReason(), dwLength );
            break;
        }
    }

    // do the search now
    bResult = TRUE;
    if ( pParams->bExactMatch == FALSE )
    {
        // prepare the comparision flags
        dwFlags = PATTERN_NOPARSING;
        dwFlags |= ((pParams->bCaseSensitive == FALSE) ? PATTERN_COMPARE_IGNORECASE : 0);

        // ...
        if ( MatchPatternEx( pwszData, pParams->pwszSearchData, dwFlags ) == FALSE )
        {
            bResult = FALSE;
            SetLastError( ERROR_NOT_FOUND );
        }
    }
    else
    {
        if ( StringCompare( pwszData,
                            pParams->pwszSearchData,
                            (pParams->bCaseSensitive == FALSE), 0 ) != 0 )
        {
            bResult = FALSE;
            SetLastError( ERROR_NOT_FOUND );
        }
    }

    // release the memory allocated
    FreeMemory( &pwszString );

    // return
    return bResult;
}


BOOL
ParseTypeInfo( LPCWSTR pwszTypes,
               PTREG_PARAMS pParams )
{
    // local variables
    LONG lArrayIndex = 0;
    LONG lLength = 0;
    LONG lIndex = 0;
    LONG lStart = 0;
    LONG lType = 0;
    LPCWSTR pwsz = NULL;

    // check input
    if ( pwszTypes == NULL || pParams == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // validate the types array
    if ( pParams->arrTypes == NULL )
    {
        pParams->arrTypes = CreateDynamicArray();
        if ( pParams->arrTypes == NULL )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }
    }

    // parse the types information
    lStart = lIndex = 0;
    while ( lIndex != -1 )
    {
        lIndex = FindString2( pwszTypes, L",", TRUE, lStart );
        if ( lIndex == -1 )
        {
            lLength = 0;
        }
        else
        {
            lLength = lIndex - lStart;
        }

        // append a row
        lArrayIndex = DynArrayAppendRow( pParams->arrTypes, 2 );
        if ( lArrayIndex == -1 )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

        // add the type info
        if ( DynArraySetString2( pParams->arrTypes,
                                 lArrayIndex, 0, pwszTypes + lStart, lLength ) == -1 )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

        // get the type back from array
        pwsz = DynArrayItemAsString2( pParams->arrTypes, lArrayIndex, 0 );
        if ( pwsz == NULL )
        {
            SetLastError( (DWORD) STG_E_UNKNOWN );
            return FALSE;
        }

        // determine the numeric equivalent of it
        lType = IsRegDataType( pwsz );
        if( lType == -1 )
        {
            if (IsNumeric( pwsz, 10, TRUE ) == TRUE )
            {
                lType = AsLong( pwsz, 10 );
            }
            else
            {
                SetLastError( (DWORD) MK_E_SYNTAX );
                return FALSE;
            }
        }

        if ( DynArraySetLong2( pParams->arrTypes, lArrayIndex, 1, lType ) == -1 )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

        // update the start position
        lStart = lIndex + 1;
    }

    // ...
    SetLastError( ERROR_SUCCESS );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\export.c ===
//-----------------------------------------------------------------------//
//
// File:    export.cpp
// Created: April 1997
// By:      Zeyong Xu
// Purpose: Support EXPORT and IMPORT .reg file
//
//------------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"
#include "regporte.h"

//
// global variables
//
extern UINT g_FileErrorStringID;
extern DWORD g_dwTotalKeysSaved;
//
// function prototypes
//
BOOL ParseExportCmdLine( DWORD argc, LPCWSTR argv[],
                         PTREG_PARAMS pParams, BOOL* pbUsage );
BOOL ParseImportCmdLine( DWORD argc, LPCWSTR argv[],
                         PTREG_PARAMS pParams, BOOL* pbUsage );

//
// implementation
//

//-----------------------------------------------------------------------
//
// ExportRegFile()
//
//-----------------------------------------------------------------------

LONG
ExportRegistry( DWORD argc, LPCWSTR argv[] )
{
    // local variables
    HKEY hKey = NULL;
    BOOL bResult = 0;
    LONG lResult = 0;
    TREG_PARAMS params;
    BOOL bUsage = FALSE;
    HANDLE hFile = NULL;
    LPCWSTR pwszFormat = NULL;
    LPCWSTR pwszList = NULL;

    if ( argc == 0 || argv == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ShowLastError( stderr );
        return 1;
    }

    // initialize the global data structure
    InitGlobalData( REG_EXPORT, &params );

    //
    // Parse the cmd-line
    //
    bResult = ParseExportCmdLine( argc, argv, &params, &bUsage );
    if( bResult == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    // check whether we need to display the usage
    if ( bUsage == TRUE )
    {
        Usage( REG_EXPORT );
        FreeGlobalData( &params );
        return 0;
    }

    //
    // check if the key existed
    //
    bResult = TRUE;
    lResult = RegOpenKeyEx( params.hRootKey, params.pwszSubKey, 0, KEY_READ, &hKey );
    if( lResult == ERROR_SUCCESS )
    {
        // close the reg key
        SafeCloseKey( &hKey );

        //
        // now it is time to check the existence of the file
        hFile = CreateFile( params.pwszValueName,
            GENERIC_READ | GENERIC_WRITE | DELETE, 0, NULL, OPEN_EXISTING, 0, 0 );
        if ( hFile != INVALID_HANDLE_VALUE )
        {
            //
            // file is existing
            //

            // close the handle first -- we dont need it
            CloseHandle( hFile );

            // load the format strings
            pwszList = GetResString2( IDS_CONFIRM_CHOICE_LIST, 1 );
            pwszFormat = GetResString2( IDS_SAVE_OVERWRITE_CONFIRM, 0 );

            // ...
            do
            {
                lResult = Prompt( pwszFormat,
                    params.pwszValueName, pwszList, params.bForce );
            } while ( lResult > 2 );

            // check the user's choice
            lResult = (lResult == 1) ? ERROR_SUCCESS : ERROR_CANCELLED;
        }
        else
        {
            //
            // failed to open the file
            // find out why it is failed
            //

            lResult = GetLastError();
            if ( lResult == ERROR_FILE_NOT_FOUND )
            {
                lResult = ERROR_SUCCESS;
            }
            else
            {
                bResult = FALSE;
                lResult = IDS_EXPFILEERRFILEWRITE;
            }
        }

        // ...
        if ( lResult == ERROR_SUCCESS )
        {
            // since there are chances of getting access problems --
            // instead of directly manipulating with the original file name, we will try to
            // save the data using temporary file name and then transfer
            // the contents to the orignal filename
            params.pwszValue = params.pwszValueName;
            params.pwszValueName = GetTemporaryFileName( params.pwszValueName );
            if ( params.pwszValueName == NULL )
            {
                bResult = FALSE;
                lResult = IDS_EXPFILEERRFILEWRITE;
            }
            else
            {
                // ...
                ExportWinNT50RegFile( params.pwszValueName, params.pwszFullKey );

                //
                // in order make REG in sync with REGEDIt, we are absolutely
                // ignoring all the errors that are generated during the export
                // process -- so, result 99% EXPORT will always results in
                // successful return except when the root hive is not accessible
                // and if there are any syntax errors
                // in future if one wants to do minimal error checking, just
                // uncomment the below code  and you are set
                //
                // if ( g_dwTotalKeysSaved > 0 ||
                //      g_FileErrorStringID == IDS_EXPFILEERRSUCCESS )
                {
                    if ( CopyFile( params.pwszValueName, params.pwszValue, FALSE ) == FALSE )
                    {
                        bResult = FALSE;
                        lResult = IDS_EXPFILEERRFILEWRITE;
                    }
                }
                // else if ( g_FileErrorStringID == IDS_EXPFILEERRBADREGPATH ||
                //           g_FileErrorStringID == IDS_EXPFILEERRREGENUM ||
                //           g_FileErrorStringID == IDS_EXPFILEERRREGOPEN ||
                //           g_FileErrorStringID == IDS_EXPFILEERRFILEOPEN )
                // {
                //     lResult = ERROR_ACCESS_DENIED;
                // }
                // else
                // {
                //     bResult = FALSE;
                //     lResult = g_FileErrorStringID;
                // }

                // delete the temporary file
                DeleteFile( params.pwszValueName );
            }
        }
    }
    else
    {
        if ( lResult == ERROR_INVALID_HANDLE )
        {
            bResult = FALSE;
            lResult = IDS_EXPFILEERRINVALID;
        }
    }

    if ( lResult == ERROR_SUCCESS || lResult == ERROR_CANCELLED )
    {
        SaveErrorMessage( lResult );
        ShowLastErrorEx( stdout, SLE_INTERNAL );
        lResult = 0;
    }
    else
    {
        if ( bResult == FALSE )
        {
            SetReason( GetResString2( lResult, 0 ) );
        }
        else
        {
            SaveErrorMessage( lResult );
        }

        // ...
        lResult = 1;
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // ...
    FreeGlobalData( &params );
    return lResult;
}

//------------------------------------------------------------------------
//
// ParseCmdLine()
//
//------------------------------------------------------------------------
BOOL
ParseExportCmdLine( DWORD argc, LPCWSTR argv[],
                    PTREG_PARAMS pParams, BOOL* pbUsage )
{
    // local variables
    DWORD dwLength = 0;
    BOOL bResult = FALSE;

    // check the input
    if ( argc == 0 || argv == NULL || pParams == NULL || pbUsage == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // check whether this function is being called for
    // valid operation or not
    if ( pParams->lOperation < 0 || pParams->lOperation >= REG_OPTIONS_COUNT )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Do we have a *valid* number of cmd-line params
    //
    if ( InString( argv[ 2 ], L"-?|/?|-h|/h", TRUE ) == TRUE )
    {
        if ( argc == 3 )
        {
            *pbUsage = TRUE;
            return TRUE;
        }
        else
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_EXPORT ] );
            return FALSE;
        }
    }
    else if ( argc < 4 || argc > 5 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_EXPORT ] );
        return FALSE;
    }

    // Machine Name and Registry key
    //
    bResult = BreakDownKeyString( argv[ 2 ], pParams );
    if( bResult == FALSE )
    {
        return FALSE;
    }

    // current, not remotable
    if ( pParams->bUseRemoteMachine == TRUE )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason( ERROR_NONREMOTABLEROOT_EXPORT );
        return FALSE;
    }

    //
    // Get the FileName - using the szValueName string field to hold it
    //
    dwLength = StringLength( argv[ 3 ], 0 ) + 5;
    pParams->pwszValueName = (LPWSTR) AllocateMemory( dwLength * sizeof(WCHAR) );
    if ( pParams->pwszValueName == NULL )
    {
        SaveLastError();
        return FALSE;
    }

    // ...
    StringCopy( pParams->pwszValueName, argv[ 3 ], dwLength );

    // validate the file name -- it should not be empty
    TrimString( pParams->pwszValueName, TRIM_ALL );
    if ( StringLength( pParams->pwszValueName, 0 ) == 0 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_EXPORT ] );
        return FALSE;
    }

    // check if user specified overwrite flag or not
    pParams->bForce = FALSE;
    if ( argc == 5 )
    {
        if ( StringCompareEx( argv[ 4 ], L"/y", TRUE, 0 ) == 0 )
        {
            pParams->bForce = TRUE;
        }
        else
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_EXPORT ] );
            return FALSE;
        }
    }

    // return
    return TRUE;
}

//-----------------------------------------------------------------------
//
// ImportRegFile()
//
//-----------------------------------------------------------------------

LONG
ImportRegistry( DWORD argc, LPCWSTR argv[] )
{
    // local variables
    BOOL bResult = 0;
    LONG lResult = 0;
    TREG_PARAMS params;
    BOOL bUsage = FALSE;

    if ( argc == 0 || argv == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ShowLastError( stderr );
        return 1;
    }

    // initialize the global data structure
    InitGlobalData( REG_IMPORT, &params );

    //
    // Parse the cmd-line
    //
    bResult = ParseImportCmdLine( argc, argv, &params, &bUsage );
    if( bResult == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    // check whether we need to display the usage
    if ( bUsage == TRUE )
    {
        Usage( REG_IMPORT );
        FreeGlobalData( &params );
        return 0;
    }

    //
    // do the import
    //
    ImportRegFileWorker( params.pwszValueName );

    if ( g_FileErrorStringID == IDS_IMPFILEERRSUCCESS )
    {
        SaveErrorMessage( ERROR_SUCCESS );
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        lResult = 0;
    }
    else
    {
        switch( g_FileErrorStringID )
        {
        default:
            {
                SetReason( GetResString( g_FileErrorStringID ) );
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                lResult = 1;
            }
        }
    }

    FreeGlobalData( &params );
    return lResult;
}

//------------------------------------------------------------------------
//
// ParseCmdLine()
//
//------------------------------------------------------------------------
BOOL
ParseImportCmdLine( DWORD argc, LPCWSTR argv[],
                    PTREG_PARAMS pParams, BOOL* pbUsage )
{
    // local variables
    DWORD dwLength = 0;

    // check the input
    if ( argc == 0 || argv == NULL || pParams == NULL || pbUsage == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // check whether this function is being called for
    // valid operation or not
    if ( pParams->lOperation < 0 || pParams->lOperation >= REG_OPTIONS_COUNT )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Do we have a *valid* number of cmd-line params
    //
    if ( argc != 3 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_IMPORT ] );
        return FALSE;
    }
    else if ( InString( argv[ 2 ], L"-?|/?|-h|/h", TRUE ) == TRUE )
    {
        *pbUsage = TRUE;
        return TRUE;
    }

    //
    // Get the FileName - using the szValueName string field to hold it
    //
    dwLength = StringLength( argv[ 2 ], 0 ) + 1;
    pParams->pwszValueName = (LPWSTR) AllocateMemory( dwLength * sizeof(WCHAR) );
    if ( pParams->pwszValueName == NULL )
    {
        SaveLastError();
        return FALSE;
    }

    // ...
    StringCopy( pParams->pwszValueName, argv[ 2 ], dwLength );

    // return
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\reg.h ===
//-----------------------------------------------------------------------//
//
// File:    Reg.h
// Created: Jan 1997
// By:      Martin Holladay (a-martih)
// Purpose: Header file for Reg.cpp
// Modification History:
//      Created - Jan 1997 (a-martih)
//      Aug 1997 - MartinHo - Incremented to 1.01 for bug fixes in:
//              load.cpp, unload.cpp, update.cpp, save.cpp & restore.cpp
//      Sept 1997 - MartinHo - Incremented to 1.02 for update:
//              increased value date max to 2048 bytes
//      Oct 1997 - MartinHo - Incremented to 1.03 for REG_MULTI_SZ bug fixes.
//              Correct support for REG_MULTI_SZ with query, add and update.
//      April 1998 - MartinHo - Fixed RegOpenKey() in Query.cpp to not require
//              KEY_ALL_ACCESS but rather KEY_READ.
//      June 1998 - MartinHo - Increased LEN_MACHINENAME to 18 to account for the
//              leading "\\" characters. (version 1.05)
//      Feb  1999 - A-ERICR - added reg dump, reg find, and many bug fixes(1.06)
//      April 1999 Zeyong Xu: re-design, revision -> version 2.0
//
//------------------------------------------------------------------------//


#ifndef _REG_H
#define _REG_H

//
// macros
//
__inline BOOL SafeCloseKey( HKEY* phKey )
{
    if ( phKey == NULL )
    {
        ASSERT( 0 );
        return FALSE;
    }

    if ( *phKey != NULL )
    {
        RegCloseKey( *phKey );
        *phKey = NULL;
    }

    return TRUE;
}

#define ARRAYSIZE   SIZE_OF_ARRAY

//
// ROOT Key String
//
#define STR_HKLM                    L"HKLM"
#define STR_HKCU                    L"HKCU"
#define STR_HKCR                    L"HKCR"
#define STR_HKU                     L"HKU"
#define STR_HKCC                    L"HKCC"
#define STR_HKEY_LOCAL_MACHINE      L"HKEY_LOCAL_MACHINE"
#define STR_HKEY_CURRENT_USER       L"HKEY_CURRENT_USER"
#define STR_HKEY_CLASSES_ROOT       L"HKEY_CLASSES_ROOT"
#define STR_HKEY_USERS              L"HKEY_USERS"
#define STR_HKEY_CURRENT_CONFIG     L"HKEY_CURRENT_CONFIG"


//
// error messages
//

// general
#define ERROR_INVALID_SYNTAX            GetResString2( IDS_ERROR_INVALID_SYNTAX, 0 )
#define ERROR_INVALID_SYNTAX_EX         GetResString2( IDS_ERROR_INVALID_SYNTAX_EX, 0 )
#define ERROR_INVALID_SYNTAX_WITHOPT    GetResString2( IDS_ERROR_INVALID_SYNTAX_WITHOPT, 0 )
#define ERROR_BADKEYNAME                GetResString2( IDS_ERROR_BADKEYNAME, 0 )
#define ERROR_NONREMOTABLEROOT          GetResString2( IDS_ERROR_NONREMOTABLEROOT, 0 )
#define ERROR_NONLOADABLEROOT           GetResString2( IDS_ERROR_NONLOADABLEROOT, 0 )
#define ERROR_PATHNOTFOUND              GetResString2( IDS_ERROR_PATHNOTFOUND, 0 )
#define ERROR_DELETEPARTIAL             GetResString2( IDS_ERROR_PARTIAL_DELETE, 0 )
#define ERROR_COPYTOSELF_COPY           GetResString2( IDS_ERROR_COPYTOSELF_COPY, 0 )
#define ERROR_COMPARESELF_COMPARE       GetResString2( IDS_ERROR_COMPARESELF_COMPARE, 0 )
#define KEYS_IDENTICAL_COMPARE          GetResString2( IDS_KEYS_IDENTICAL_COMPARE, 0 )
#define KEYS_DIFFERENT_COMPARE          GetResString2( IDS_KEYS_DIFFERENT_COMPARE, 0 )
#define ERROR_READFAIL_QUERY            GetResString2( IDS_ERROR_READFAIL_QUERY, 0 )
#define STATISTICS_QUERY                GetResString2( IDS_STATISTICS_QUERY, 0 )
#define ERROR_NONREMOTABLEROOT_EXPORT   GetResString2( IDS_ERROR_NONREMOTABLEROOT_EXPORT, 0 )

//
// NOTE: do not change the order of the below listed enums -- if you change
//       the order, change the order in ParseRegCmdLine also
enum
{
    REG_QUERY = 0,
    REG_ADD = 1,
    REG_DELETE = 2, REG_COPY = 3,
    REG_SAVE = 4, REG_RESTORE = 5,
    REG_LOAD = 6, REG_UNLOAD = 7,
    REG_COMPARE = 8,
    REG_EXPORT = 9, REG_IMPORT = 10,
    REG_OPTIONS_COUNT
};

enum
{
    REG_FIND_ALL = 0x7,                     // 0000 0000 0000 0111
    REG_FIND_KEYS = 0x1,                    // 0000 0000 0000 0001
    REG_FIND_VALUENAMES = 0x2,              // 0000 0000 0000 0010
    REG_FIND_DATA = 0x4                     // 0000 0000 0000 0100
};

//
// global constants
extern const WCHAR g_wszOptions[ REG_OPTIONS_COUNT ][ 10 ];

//
// global data structure
//
typedef struct __tagRegParams
{
    LONG lOperation;                    // main operation being performed

    HKEY hRootKey;

    BOOL bUseRemoteMachine;
    BOOL bCleanRemoteRootKey;

    BOOL bForce;                        // /f -- forceful overwrite / delete
    BOOL bAllValues;                    // /va
    BOOL bRecurseSubKeys;               // /s -- recurse
    BOOL bCaseSensitive;                // /c
    BOOL bExactMatch;                   // /e
    BOOL bShowTypeNumber;               // /z
    DWORD dwOutputType;                 // /oa, /od, /on
    LONG lRegDataType;                  // reg value data type (/t)
    WCHAR wszSeparator[ 3 ];            // separator (used for REG_MULTI_SZ)
    LPWSTR pwszMachineName;             // machine name (in UNC format)
    LPWSTR pwszSubKey;                  // registry sub key -- excluding hive
    LPWSTR pwszFullKey;                 // full key -- including hive
    LPWSTR pwszValueName;               // /v or /ve
    LPWSTR pwszValue;                   // /d
    DWORD dwSearchFlags;                // /k, /v, /d
    LPWSTR pwszSearchData;              // /f
    TARRAY arrTypes;                    // /t (REG QUERY only)

} TREG_PARAMS, *PTREG_PARAMS;

//
// helper struture -- used to output the registry data
//
#define RSI_IGNOREVALUENAME             0x00000001
#define RSI_IGNORETYPE                  0x00000002
#define RSI_IGNOREVALUE                 0x00000004
#define RSI_IGNOREMASK                  0x0000000F

#define RSI_ALIGNVALUENAME              0x00000010
#define RSI_SHOWTYPENUMBER              0x00000020

typedef struct __tagRegShowInfo
{
    DWORD dwType;
    DWORD dwSize;
    LPBYTE pByteData;
    LPCWSTR pwszValueName;

    DWORD dwMaxValueNameLength;

    DWORD dwFlags;
    DWORD dwPadLength;              // default is no padding
    LPCWSTR pwszSeparator;          // default is space
    LPCWSTR pwszMultiSzSeparator;   // default is '\0'
} TREG_SHOW_INFO, *PTREG_SHOW_INFO;

// helper functions
LONG IsRegDataType( LPCWSTR pwszStr );
BOOL SaveErrorMessage( LONG lLastError );
BOOL FreeGlobalData( PTREG_PARAMS pParams );
BOOL InitGlobalData( LONG lOperation, PTREG_PARAMS pParams );
BOOL RegConnectMachine( PTREG_PARAMS pParams );
BOOL BreakDownKeyString( LPCWSTR pwszStr, PTREG_PARAMS pParams );
BOOL ShowRegistryValue( PTREG_SHOW_INFO pShowInfo );
LPCWSTR GetTypeStrFromType( LPWSTR pwszTypeStr, DWORD* pdwLength, DWORD dwType );
LONG Prompt( LPCWSTR pwszFormat, LPCWSTR pwszValue, LPCWSTR pwszList, BOOL bForce );
LPWSTR GetTemporaryFileName( LPCWSTR pwszSavedFilePath );

// option implementations
BOOL Usage( LONG lOperation );
LONG AddRegistry( DWORD argc, LPCWSTR argv[] );
LONG CopyRegistry( DWORD argc, LPCWSTR argv[] );
LONG DeleteRegistry( DWORD argc, LPCWSTR argv[] );
LONG SaveHive( DWORD argc, LPCWSTR argv[] );
LONG RestoreHive( DWORD argc, LPCWSTR argv[] );
LONG LoadHive( DWORD argc, LPCWSTR argv[] );
LONG UnLoadHive( DWORD argc, LPCWSTR argv[] );
LONG CompareRegistry( DWORD argc, LPCWSTR argv[] );
LONG QueryRegistry( DWORD argc, LPCWSTR argv[] );
LONG ImportRegistry( DWORD argc, LPCWSTR argv[] );
LONG ExportRegistry( DWORD argc, LPCWSTR argv[] );


#endif  //_REG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\regdebug.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDEBUG.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Debug routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGDEBUG
#define _INC_REGDEBUG

#if DBG

VOID
CDECL
_DbgPrintf(
    PSTR pFormatString,
    ...
    );

#define DebugPrintf(x)                    _DbgPrintf ##x

#else       // DBG

#define DebugPrintf(x)

#endif      // DBG

#endif // _INC_REGDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\reg.c ===
//-----------------------------------------------------------------------//
//
// File:    Reg.cpp
// Created: Jan 1997
// By:      Martin Holladay (a-martih)
// Purpose: Command-line registry manipulation (query, add, update, etc)
// Modification History:
//      Created - Jan 1997 (a-martih)
//      Oct 1997 (martinho)
//          Fixed up help on Add and Update to display REG_MULTI_SZ examples.
//      Oct 1997 (martinho)
//          Changed /F to /FORCE under usage for delete
//      April 1999 Zeyong Xu: re-design, revision -> version 2.0
//
//-----------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"
#include <regstr.h>

//
// structures
//
typedef struct __tagRegDataTypes
{
    DWORD dwType;
    LPCWSTR pwszType;
} TREG_DATA_TYPE;

//
// defines / constants / enumerations
//
const WCHAR cwszRegSz[] = L"REG_SZ";
const WCHAR cwszRegExpandSz[] = L"REG_EXPAND_SZ";
const WCHAR cwszRegMultiSz[] = L"REG_MULTI_SZ";
const WCHAR cwszRegBinary[] = L"REG_BINARY";
const WCHAR cwszRegDWord[] = L"REG_DWORD";
const WCHAR cwszRegDWordLittleEndian[] = L"REG_DWORD_LITTLE_ENDIAN";
const WCHAR cwszRegDWordBigEndian[] = L"REG_DWORD_BIG_ENDIAN";
const WCHAR cwszRegNone[] = L"REG_NONE";
const WCHAR cwszRegLink[] = L"REG_LINK";
const WCHAR cwszRegResourceList[] = L"REG_RESOURCE_LIST";
const WCHAR cwszRegFullResourceDescriptor[] = L"REG_FULL_RESOURCE_DESCRIPTOR";
const WCHAR g_wszOptions[ REG_OPTIONS_COUNT ][ 10 ] = {
    L"QUERY", L"ADD", L"DELETE",
    L"COPY", L"SAVE", L"RESTORE", L"LOAD",
    L"UNLOAD", L"COMPARE", L"EXPORT", L"IMPORT"
};

const TREG_DATA_TYPE g_regTypes[] = {
    { REG_SZ,                       cwszRegSz                     },
    { REG_EXPAND_SZ,                cwszRegExpandSz               },
    { REG_MULTI_SZ,                 cwszRegMultiSz                },
    { REG_BINARY,                   cwszRegBinary                 },
    { REG_DWORD,                    cwszRegDWord                  },
    { REG_DWORD_LITTLE_ENDIAN,      cwszRegDWordLittleEndian      },
    { REG_DWORD_BIG_ENDIAN,         cwszRegDWordBigEndian         },
    { REG_NONE,                     cwszRegNone                   },
    { REG_LINK,                     cwszRegLink                   },
    { REG_RESOURCE_LIST,            cwszRegResourceList           },
    { REG_FULL_RESOURCE_DESCRIPTOR, cwszRegFullResourceDescriptor }
};

//
// private functions
//
BOOL IsRegistryToolDisabled();
BOOL ParseRegCmdLine( DWORD argc,
                      LPCWSTR argv[],
                      LONG* plOperation, BOOL* pbUsage );
BOOL ParseMachineName( LPCWSTR pwszStr, PTREG_PARAMS pParams );
LPWSTR AdjustKeyName( LPWSTR pwszStr );
BOOL ParseKeyName( LPWSTR pwszStr, PTREG_PARAMS pParams );
BOOL IsValidSubKey( LPCWSTR pwszSubKey );

//------------------------------------------------------------------------//
//
// main()
//
//------------------------------------------------------------------------//

DWORD __cdecl wmain( DWORD argc, LPCWSTR argv[] )
{
    // local variables
    BOOL bUsage = FALSE;
    BOOL bResult = FALSE;
    DWORD dwExitCode = 0;
    LONG lOperation = 0;

    //
    // Determine the opertion - and pass control to the *deserving* function
    //
    bResult = ParseRegCmdLine( argc, argv, &lOperation, &bUsage );
    if ( bResult == FALSE )
    {
        dwExitCode = 1;
        ShowLastErrorEx( stderr, SLE_INTERNAL );
    }

    // check whether we need to display the usage
    else if ( bUsage == TRUE )
    {
        Usage( -1 );
        dwExitCode = 0;
    }

    // need to check the sub-option
    else
    {
        //
        // At this point we have a valid operation
        //
        switch( lOperation )
        {
        case REG_QUERY:
            dwExitCode = QueryRegistry( argc, argv );
            break;

        case REG_DELETE:
            dwExitCode = DeleteRegistry( argc, argv );
            break;

        case REG_ADD:
            dwExitCode = AddRegistry( argc, argv );
            break;

        case REG_COPY:
            dwExitCode = CopyRegistry( argc, argv );
            break;

        case REG_SAVE:
            dwExitCode = SaveHive( argc, argv );
            break;

        case REG_RESTORE:
            dwExitCode = RestoreHive( argc, argv );
            break;

        case REG_LOAD:
            dwExitCode = LoadHive( argc, argv );
            break;

        case REG_UNLOAD:
            dwExitCode = UnLoadHive( argc, argv );
            break;

        case REG_COMPARE:
            dwExitCode = CompareRegistry( argc, argv );
            break;

        case REG_EXPORT:
            dwExitCode = ExportRegistry( argc, argv );
            break;

        case REG_IMPORT:
            dwExitCode = ImportRegistry( argc, argv );
            break;

        default:
            break;
        }
    }

    ReleaseGlobals();
    return dwExitCode;
}


//------------------------------------------------------------------------//
//
// ParseRegCmdLine()
//   Find out the operation - each operation parses it's own cmd-line
//
//------------------------------------------------------------------------//

BOOL ParseRegCmdLine( DWORD argc,
                      LPCWSTR argv[],
                      LONG* plOperation, BOOL* pbUsage )
{
    // local variables
    LONG lIndex = 0;

    // check the input
    if ( argc == 0 || argv == NULL || plOperation == NULL || pbUsage == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // just REG.EXE is error
    if ( argc == 1 )
    {
        SetReason( ERROR_INVALID_SYNTAX );
        return FALSE;
    }

    // prepare the parser data
    *pbUsage = FALSE;
    *plOperation = -1;
    for( lIndex = 0; lIndex < REG_OPTIONS_COUNT; lIndex++ )
    {
        if ( StringCompareEx( argv[ 1 ], g_wszOptions[ lIndex ], TRUE, 0 ) == 0 )
        {
            // ...
            *plOperation = lIndex;

            // check the GPO -- if GPO is enabled, we should block the
            // user from using the REGISTRY tool except to see the help
            if ( argc >= 3 &&
                 IsRegistryToolDisabled() == TRUE &&
                 InString( argv[ 2 ], L"-?|/?|-h|/h", TRUE ) == FALSE )
            {
                SetReason( GetResString2( IDS_REGDISABLED, 0 ) );
                return FALSE;
            }

            // ...
            return TRUE;
        }
    }

    // no option did match -- might be asking for help
    if ( InString( argv[ 1 ], L"-?|/?|-h|/h", TRUE ) == TRUE )
    {
        *pbUsage = TRUE;
        return TRUE;
    }

    // rest is invalid syntax
    SetReason2( 1, ERROR_INVALID_SYNTAX_EX, argv[ 1 ] );
    return FALSE;
}

BOOL
InitGlobalData( LONG lOperation,
                PTREG_PARAMS pParams )
{
    // check the input
    if ( pParams == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ( lOperation < 0 || lOperation >= REG_OPTIONS_COUNT )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // init to zero's
    SecureZeroMemory( pParams, sizeof( TREG_PARAMS ) );

    pParams->lOperation = lOperation;                       // operation
    pParams->hRootKey = HKEY_LOCAL_MACHINE;
    pParams->lRegDataType = (lOperation == REG_QUERY) ? -1 : REG_SZ;
    pParams->bAllValues = FALSE;
    pParams->bUseRemoteMachine = FALSE;
    pParams->bCleanRemoteRootKey = FALSE;
    pParams->bForce = FALSE;
    pParams->bRecurseSubKeys = FALSE;
    pParams->pwszMachineName = NULL;
    pParams->pwszFullKey = NULL;
    pParams->pwszSubKey = NULL;
    pParams->pwszValueName = NULL;
    pParams->pwszValue = NULL;
    StringCopy( pParams->wszSeparator,
        L"\\0", SIZE_OF_ARRAY( pParams->wszSeparator ) );

    return TRUE;
}

//------------------------------------------------------------------------//
//
// FreeAppVars()
//
//------------------------------------------------------------------------//

BOOL FreeGlobalData( PTREG_PARAMS pParams )
{
    if ( pParams->bCleanRemoteRootKey == TRUE )
    {
        SafeCloseKey( &pParams->hRootKey );
    }

    FreeMemory( &pParams->pwszSubKey );
    FreeMemory( &pParams->pwszFullKey );
    FreeMemory( &pParams->pwszMachineName );
    FreeMemory( &pParams->pwszSearchData );
    FreeMemory( &pParams->pwszValueName );
    FreeMemory( &pParams->pwszValue );
    DestroyDynamicArray( &pParams->arrTypes );

    return TRUE;
}

//------------------------------------------------------------------------//
//
// Prompt() - Answer Y/N question if bForce == FALSE
//
//------------------------------------------------------------------------//

LONG
Prompt( LPCWSTR pwszFormat,
        LPCWSTR pwszValue,
        LPCWSTR pwszList, BOOL bForce )
{
    // local variables
    WCHAR wch;
    LONG lIndex = 0;

    // check the input
    if ( pwszFormat == NULL || pwszList == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return -1;
    }

    if ( bForce == TRUE )
    {
        return 1;
    }

    do
    {
        if ( pwszValue != NULL )
        {
            ShowMessageEx( stdout, 1, TRUE, pwszFormat, pwszValue );
        }
        else
        {
            ShowMessage( stdout, pwszFormat );
        }

        fflush( stdin );
        wch = (WCHAR) getwchar();
    } while ((lIndex = FindChar2( pwszList, wch, TRUE, 0 )) == -1);

    // check the character selected by the user
    // NOTE: we assume the resource string will have "Y" as the first character
    return (lIndex + 1);
}


// break down [\\MachineName\]keyName
BOOL
BreakDownKeyString( LPCWSTR pwszStr, PTREG_PARAMS pParams )
{
    // local variables
    LONG lIndex = 0;
    DWORD dwLength = 0;
    LPWSTR pwszTemp = NULL;
    LPWSTR pwszTempStr = NULL;
    BOOL bResult = FALSE;

    // check the input
    if ( pwszStr == NULL || pParams == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // check whether this function is being called for
    // valid operation or not
    if ( pParams->lOperation < 0 || pParams->lOperation >= REG_OPTIONS_COUNT )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    dwLength = StringLength( pwszStr, 0 ) + 1;
    pwszTempStr = (LPWSTR) AllocateMemory( dwLength * sizeof( WCHAR ) );
    if ( pwszTempStr == NULL )
    {
        SaveErrorMessage( -1 );
        return FALSE;
    }

    // copy the string name into temporary buffer
    StringCopy( pwszTempStr, pwszStr, dwLength );
    TrimString( pwszTempStr, TRIM_ALL );

    //
    // figure out machine name
    //
    bResult = TRUE;
    pwszTemp = pwszTempStr;

    // machine name
    if( StringLength( pwszTempStr, 0 ) > 2 && 
        StringCompareEx( pwszTempStr, L"\\\\", TRUE, 2 ) == 0 )
    {
        lIndex = FindChar2( pwszTempStr, L'\\', TRUE, 2 );
        if(lIndex != -1)
        {
            pwszTemp = pwszTempStr + lIndex + 1;
            *(pwszTempStr + lIndex) = cwchNullChar;
        }
		else
		{
			pwszTemp = NULL;
		}

        bResult = ParseMachineName( pwszTempStr, pParams );
    }

    // parse key name
    if( bResult == TRUE )
    {
        if( pwszTemp != NULL && StringLength( pwszTemp, 0 ) > 0)
        {
            bResult = ParseKeyName( pwszTemp, pParams );
        }
        else
        {
            SetLastError( (DWORD) REGDB_E_KEYMISSING );
            SetReason2( 1, ERROR_BADKEYNAME, g_wszOptions[ pParams->lOperation ] );
            bResult = FALSE;
        }
    }

    // release memory allocated
    FreeMemory( &pwszTempStr );

    // return
    return bResult;
}


//------------------------------------------------------------------------//
//
// FindAndAdjustKeyName()
//
// null out the cmdline based on what we think the end of the argument is
//
// we do this because users might not quote out the cmdline properly.
//
//------------------------------------------------------------------------//

LPWSTR
AdjustKeyName( LPWSTR pwszStr )
{
    // local variables
    DWORD dwLength = 0;

    // check the input
    if ( pwszStr == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }

    // determine the length of the text passed
    dwLength = StringLength( pwszStr, 0 );
    if ( dwLength > 1 && pwszStr[ dwLength - 1 ] == L'\\' )
    {
        // nullify the last back slash
        pwszStr[ dwLength - 1 ] = cwchNullChar;
    }

    // return
    return pwszStr;
}


//------------------------------------------------------------------------//
//
// IsMachineName()
//
//------------------------------------------------------------------------//

BOOL
ParseMachineName( LPCWSTR pwszStr, PTREG_PARAMS pParams )
{
    // local variables
    DWORD dwLength = 0;
    BOOL bUseRemoteMachine = FALSE;

    // check the input
    if ( pwszStr == NULL || pParams == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // copy string
    //
    bUseRemoteMachine = TRUE;
    if( StringCompareEx( pwszStr, L"\\\\", TRUE, 0 ) == 0 )
    {
        SetLastError( (DWORD) REGDB_E_KEYMISSING );
        SetReason2( 1, ERROR_BADKEYNAME, g_wszOptions[ pParams->lOperation ] );
        return FALSE;
    }
    else if(StringCompareEx( pwszStr, L"\\\\.", TRUE, 0) == 0)
    {
        // current machine -- local
        bUseRemoteMachine = FALSE;
    }

    dwLength = StringLength( pwszStr, 0 ) + 1;
    pParams->pwszMachineName = (LPWSTR) AllocateMemory( dwLength * sizeof(WCHAR) );
    if ( pParams->pwszMachineName == NULL )
    {
        SaveErrorMessage( -1 );
        return FALSE;
    }

    StringCopy( pParams->pwszMachineName, pwszStr, dwLength );
    pParams->bUseRemoteMachine = TRUE;
    SaveErrorMessage( ERROR_SUCCESS );
    return TRUE;
}


//------------------------------------------------------------------------//
//
// ParseKeyName()
//
// Pass the full registry path in szStr
//
// Based on input - Sets AppMember fields:
//
//      hRootKey
//      szKey
//      szValueName
//      szValue
//
//------------------------------------------------------------------------//

BOOL
ParseKeyName( LPWSTR pwszStr,
              PTREG_PARAMS pParams )
{
    // local variables
    LONG lIndex = 0;
    BOOL bResult = TRUE;
    DWORD dwSubKeySize = 0;
    DWORD dwRootKeySize = 0;
    DWORD dwFullKeySize = 0;
    LPWSTR pwszTemp = NULL;
    LPWSTR pwszRootKey = NULL;

    // check the input
    if ( pwszStr == NULL || pParams == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // check whether this function is being called for
    // valid operation or not
    if ( pParams->lOperation < 0 || pParams->lOperation >= REG_OPTIONS_COUNT )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // figure out what root key was specified
    //
    pwszTemp = NULL;
    lIndex = FindChar2( pwszStr, L'\\', TRUE, 0 );
    if (lIndex != -1)
    {
        pwszTemp = pwszStr + lIndex + 1;
        *(pwszStr + lIndex) = cwchNullChar;
    }

    if (*pwszStr == L'\"')
    {
        pwszStr += 1;
    }

    //
    // Check the ROOT has been entered
    //
    bResult = TRUE;
    dwRootKeySize = StringLength( STR_HKEY_CURRENT_CONFIG, 0 ) + 1;
    pwszRootKey = (LPWSTR) AllocateMemory( dwRootKeySize * sizeof(WCHAR) );
    if ( pwszRootKey == NULL)
    {
        SaveErrorMessage( -1 );
        return FALSE;
    }

    if (StringCompareEx( pwszStr, STR_HKCU, TRUE, 0) == 0 ||
        StringCompareEx( pwszStr, STR_HKEY_CURRENT_USER, TRUE, 0) == 0)
    {
        pParams->hRootKey = HKEY_CURRENT_USER;
        StringCopy( pwszRootKey, STR_HKEY_CURRENT_USER, dwRootKeySize );

        // check remotable and loadable
        if( pParams->bUseRemoteMachine == TRUE )
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_NONREMOTABLEROOT, g_wszOptions[ pParams->lOperation ] );
            bResult = FALSE;
        }
        else if( pParams->lOperation == REG_LOAD || pParams->lOperation == REG_UNLOAD )
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_NONLOADABLEROOT, g_wszOptions[ pParams->lOperation ] );
            bResult = FALSE;
        }
    }
    else if ( StringCompareEx( pwszStr, STR_HKCR, TRUE, 0 ) == 0 ||
              StringCompareEx( pwszStr, STR_HKEY_CLASSES_ROOT, TRUE, 0 ) == 0)
    {
        pParams->hRootKey = HKEY_CLASSES_ROOT;
        StringCopy( pwszRootKey, STR_HKEY_CLASSES_ROOT, dwRootKeySize );

        // check remotable and loadable
        if( pParams->bUseRemoteMachine == TRUE )
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_NONREMOTABLEROOT, g_wszOptions[ pParams->lOperation ] );
            bResult = FALSE;
        }
        else if( pParams->lOperation == REG_LOAD || pParams->lOperation == REG_UNLOAD )
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_NONLOADABLEROOT, g_wszOptions[ pParams->lOperation ] );
            bResult = FALSE;
        }
    }
    else if ( StringCompareEx( pwszStr, STR_HKCC, TRUE, 0 ) == 0 ||
              StringCompareEx( pwszStr, STR_HKEY_CURRENT_CONFIG, TRUE, 0 ) == 0)
    {
        pParams->hRootKey = HKEY_CURRENT_CONFIG;
        StringCopy( pwszRootKey, STR_HKEY_CURRENT_CONFIG, dwRootKeySize );

        // check remotable and loadable
        if( pParams->bUseRemoteMachine == TRUE )
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_NONREMOTABLEROOT, g_wszOptions[ pParams->lOperation ] );
            bResult = FALSE;
        }
        else if( pParams->lOperation == REG_LOAD ||
                 pParams->lOperation == REG_UNLOAD )
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_NONLOADABLEROOT, g_wszOptions[ pParams->lOperation ] );
            bResult = FALSE;
        }
    }
    else if ( StringCompareEx( pwszStr, STR_HKLM, TRUE, 0 ) == 0 ||
              StringCompareEx( pwszStr, STR_HKEY_LOCAL_MACHINE, TRUE, 0 ) == 0)
    {
        pParams->hRootKey = HKEY_LOCAL_MACHINE;
        StringCopy( pwszRootKey, STR_HKEY_LOCAL_MACHINE, dwRootKeySize );
    }
    else if ( StringCompareEx( pwszStr, STR_HKU, TRUE, 0 ) == 0 ||
              StringCompareEx( pwszStr, STR_HKEY_USERS, TRUE, 0 ) == 0 )
    {
        pParams->hRootKey = HKEY_USERS;
        StringCopy( pwszRootKey, STR_HKEY_USERS, dwRootKeySize );
    }
    else
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_BADKEYNAME, g_wszOptions[ pParams->lOperation ] );
        bResult = FALSE;
    }

    if( bResult == TRUE )
    {
        //
        // parse the subkey
        //
        if ( pwszTemp == NULL )
        {
            // only root key, subkey is empty
            pParams->pwszSubKey = (LPWSTR) AllocateMemory( 1 * sizeof( WCHAR ) );
            if ( pParams->pwszSubKey == NULL)
            {
                SaveErrorMessage( -1 );
                bResult = FALSE;
            }
            else
            {
                pParams->pwszFullKey =
                    (LPWSTR) AllocateMemory( dwRootKeySize * sizeof(WCHAR) );
                if ( pParams->pwszFullKey == NULL )
                {
                    SaveErrorMessage( -1 );
                    bResult = FALSE;
                }

                StringCopy( pParams->pwszFullKey, pwszRootKey, dwRootKeySize );
            }
        }
        else
        {
            //
            // figure out what root key was specified
            //
            pwszTemp = AdjustKeyName( pwszTemp );
            if ( IsValidSubKey( pwszTemp ) == FALSE )
            {
                bResult = FALSE;
                if ( GetLastError() == ERROR_INVALID_PARAMETER )
                {
                    SaveErrorMessage( -1 );
                }
                else
                {
                    SetLastError( (DWORD) MK_E_SYNTAX );
                    SetReason2( 1, ERROR_BADKEYNAME, g_wszOptions[ pParams->lOperation ] );
                }
            }
            else
            {
                // get subkey
                dwSubKeySize = StringLength( pwszTemp, 0 ) + 1;
                pParams->pwszSubKey =
                    (LPWSTR) AllocateMemory( dwSubKeySize * sizeof(WCHAR) );
                if( pParams->pwszSubKey == NULL )
                {
                    SaveErrorMessage( -1 );
                    bResult = FALSE;
                }
                else
                {
                    StringCopy( pParams->pwszSubKey, pwszTemp, dwSubKeySize );

                    // get fullkey ( +2 ==> "/" + buffer )
                    dwFullKeySize = dwRootKeySize + dwSubKeySize + 2;
                    pParams->pwszFullKey =
                        (LPWSTR) AllocateMemory( dwFullKeySize * sizeof(WCHAR) );
                    if ( pParams->pwszFullKey == NULL )
                    {
                        SaveErrorMessage( -1 );
                        bResult = FALSE;
                    }
                    else
                    {
                        StringCopy( pParams->pwszFullKey, pwszRootKey, dwFullKeySize );
                        StringConcat( pParams->pwszFullKey, L"\\", dwFullKeySize );
                        StringConcat( pParams->pwszFullKey, pParams->pwszSubKey, dwFullKeySize );
                    }
                }
            }
        }
    }

    FreeMemory( &pwszRootKey );
    return bResult;
}


BOOL
IsValidSubKey( LPCWSTR pwszSubKey )
{
    // local variables
    LONG lLength = 0;
    LONG lIndex = -1;
    LONG lPrevIndex = -1;

    if ( pwszSubKey == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    else if ( StringLength( pwszSubKey, 0 ) == 0 )
    {
        SetLastError( (DWORD) NTE_BAD_KEY );
        return FALSE;
    }

    do
    {
        if ( lIndex != lPrevIndex )
        {
            if ( lIndex - lPrevIndex == 1 || lIndex - lPrevIndex > 255 )
            {
                SetLastError( (DWORD) NTE_BAD_KEY );
                return FALSE;
            }

            lPrevIndex = lIndex;
        }
    } while ((lIndex = FindChar2( pwszSubKey, L'\\', TRUE, lIndex + 1 )) != -1 );

    // get the length of the subkey
    lLength = StringLength( pwszSubKey, 0 );

    if ( lPrevIndex == lLength - 1 ||
         (lPrevIndex == -1 && lLength > 255) || (lLength - lPrevIndex > 255) )
    {
        SetLastError( (DWORD) NTE_BAD_KEY );
        return FALSE;
    }

    SetLastError( NO_ERROR );
    return TRUE;
}


//------------------------------------------------------------------------//
//
// IsRegDataType()
//
//------------------------------------------------------------------------//

LONG
IsRegDataType( LPCWSTR pwszStr )
{
    // local variables
    LONG lResult = -1;
    LPWSTR pwszDup = NULL;

    if ( pwszStr == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return -1;
    }

    // create a duplicate string of the input string
    pwszDup = StrDup( pwszStr );
    if ( pwszDup == NULL )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return -1;
    }

    // remove the unwanted spaces and tab characters
    TrimString2( pwszDup, NULL, TRIM_ALL );

    if( StringCompareEx( pwszDup, cwszRegSz, TRUE, 0 ) == 0)
    {
        lResult = REG_SZ;
    }
    else if( StringCompareEx( pwszDup, cwszRegExpandSz, TRUE, 0 ) == 0)
    {
        lResult = REG_EXPAND_SZ;
    }
    else if( StringCompareEx( pwszDup, cwszRegMultiSz, TRUE, 0 ) == 0)
    {
        lResult = REG_MULTI_SZ;
    }
    else if( StringCompareEx( pwszDup, cwszRegBinary, TRUE, 0 ) == 0)
    {
        lResult = REG_BINARY;
    }
    else if( StringCompareEx( pwszDup, cwszRegDWord, TRUE, 0 ) == 0)
    {
        lResult = REG_DWORD;
    }
    else if( StringCompareEx( pwszDup, cwszRegDWordLittleEndian, TRUE, 0 ) == 0)
    {
        lResult = REG_DWORD_LITTLE_ENDIAN;
    }
    else if( StringCompareEx( pwszDup, cwszRegDWordBigEndian, TRUE, 0 ) == 0)
    {
        lResult = REG_DWORD_BIG_ENDIAN;
    }
    else if( StringCompareEx( pwszDup, cwszRegNone, TRUE, 0) == 0 )
    {
        lResult = REG_NONE;
    }

    // free the memory
    LocalFree( pwszDup );
    pwszDup = NULL;

    // ...
    SetLastError( NO_ERROR );
    return lResult;
}


//------------------------------------------------------------------------//
//
// Usage() - Display Usage Information
//
//------------------------------------------------------------------------//

BOOL
Usage( LONG lOperation )
{
    // display the banner
    ShowMessage( stdout, L"\n" );

    // display the help based on the operation
    switch( lOperation )
    {
    case REG_QUERY:
        ShowResMessage( stdout, IDS_USAGE_QUERY1 );
        ShowResMessage( stdout, IDS_USAGE_QUERY2 );
        ShowResMessage( stdout, IDS_USAGE_QUERY3 );
        break;

    case REG_ADD:
        ShowResMessage( stdout, IDS_USAGE_ADD1 );
        ShowResMessage( stdout, IDS_USAGE_ADD2 );
        break;

    case REG_DELETE:
        ShowResMessage( stdout, IDS_USAGE_DELETE );
        break;

    case REG_COPY:
        ShowResMessage( stdout, IDS_USAGE_COPY );
        break;

    case REG_SAVE:
        ShowResMessage( stdout, IDS_USAGE_SAVE );
        break;

    case REG_RESTORE:
        ShowResMessage( stdout, IDS_USAGE_RESTORE );
        break;

    case REG_LOAD:
        ShowResMessage( stdout, IDS_USAGE_LOAD );
        break;

    case REG_UNLOAD:
        ShowResMessage( stdout, IDS_USAGE_UNLOAD );
       break;

    case REG_COMPARE:
        ShowResMessage( stdout, IDS_USAGE_COMPARE1 );
        ShowResMessage( stdout, IDS_USAGE_COMPARE2 );
        break;

    case REG_EXPORT:
        ShowResMessage( stdout, IDS_USAGE_EXPORT );
        break;

    case REG_IMPORT:
        ShowResMessage( stdout, IDS_USAGE_IMPORT );
        break;

    case -1:
    default:
        ShowResMessage( stdout, IDS_USAGE_REG );
        break;
    }

    return TRUE;
}


BOOL
RegConnectMachine( PTREG_PARAMS pParams )
{
    // local variables
    LONG lResult = 0;
    HKEY hKeyConnect = NULL;

    // check the input
    if ( pParams == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    lResult = ERROR_SUCCESS;
    if ( pParams->bUseRemoteMachine == TRUE )
    {
        // close the remote key
        if( pParams->hRootKey != NULL &&
            pParams->bCleanRemoteRootKey == TRUE )
        {
            SafeCloseKey( &pParams->hRootKey );
        }

        // connect to remote key
        lResult = RegConnectRegistry(
            pParams->pwszMachineName, pParams->hRootKey, &hKeyConnect);
        if( lResult == ERROR_SUCCESS )
        {
            // sanity check
            if ( hKeyConnect != NULL )
            {
                pParams->hRootKey = hKeyConnect;
                pParams->bCleanRemoteRootKey = TRUE;
            }
            else
            {
                lResult = ERROR_PROCESS_ABORTED;
            }
        }
    }

    SetLastError( lResult );
    return (lResult == ERROR_SUCCESS);
}

BOOL
SaveErrorMessage( LONG lLastError )
{
    // local variables
    DWORD dwLastError = 0;

    dwLastError = (lLastError < 0) ? GetLastError() : (DWORD) lLastError;
    switch( dwLastError )
    {
    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
        {
            SetReason( ERROR_PATHNOTFOUND );
            break;
        }

    default:
        {
            SetLastError( dwLastError );
            SaveLastError();
            break;
        }
    }

    return TRUE;
}


LPCWSTR
GetTypeStrFromType( LPWSTR pwszTypeStr,
                    DWORD* pdwLength, DWORD dwType )
{
    // local variables
    DWORD dw = 0;
    LPCWSTR pwsz = NULL;

    for( dw = 0; dw < SIZE_OF_ARRAY( g_regTypes ); dw++ )
    {
        if ( dwType == g_regTypes[ dw ].dwType )
        {
            pwsz = g_regTypes[ dw ].pwszType;
            break;
        }
    }

    if ( pwsz == NULL )
    {
        SetLastError( ERROR_NOT_FOUND );
        pwsz = cwszRegNone;
    }

    // check the input buffers passed by the caller
    if ( pwszTypeStr == NULL )
    {
        if ( pdwLength != NULL )
        {
            *pdwLength = StringLength( pwsz, 0 );
        }
    }
    else if ( pdwLength == NULL || *pdwLength == 0 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        pwsz = cwszNullString;
    }
    else
    {
        StringCopy( pwszTypeStr, pwsz, *pdwLength );
    }

    // return
    return pwsz;
}


BOOL
ShowRegistryValue( PTREG_SHOW_INFO pShowInfo )
{
    // local variables
    DWORD dw = 0;
    DWORD dwSize = 0;
    LPCWSTR pwszEnd = NULL;
    LPBYTE pByteData = NULL;
    BOOL bShowSeparator = FALSE;
    LPCWSTR pwszSeparator = NULL;
    LPCWSTR pwszValueName = NULL;

    // check the input
    if ( pShowInfo == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // validate and the show the contents

    // ignore mask
    if ( (pShowInfo->dwFlags & RSI_IGNOREMASK) == RSI_IGNOREMASK )
    {
        return TRUE;
    }

    // check if the padding is required or not
    if ( pShowInfo->dwPadLength != 0 )
    {
        ShowMessageEx( stdout, 1, TRUE, L"%*s", pShowInfo->dwPadLength, L" " );
    }

    // value name
    if ( (pShowInfo->dwFlags & RSI_IGNOREVALUENAME) == 0 )
    {
        if ( pShowInfo->pwszValueName == NULL )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        // alignment flag and separator cannot go along
        if ( pShowInfo->pwszSeparator != NULL &&
             (pShowInfo->dwFlags & RSI_ALIGNVALUENAME) )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        // valuename = no name
        pwszValueName = pShowInfo->pwszValueName;
        if( StringLength( pwszValueName, 0 ) == 0 )
        {
            pwszValueName = GetResString2( IDS_NONAME, 0 );
        }

        // alignment
        if ( pShowInfo->dwFlags & RSI_ALIGNVALUENAME )
        {
            if ( pShowInfo->dwMaxValueNameLength == 0 )
            {
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }

            // show the value name
            ShowMessageEx( stdout, 2, TRUE, L"%-*s",
                pShowInfo->dwMaxValueNameLength, pwszValueName );
        }
        else
        {
            ShowMessage( stdout, pwszValueName );
        }

        // display the separator
        if ( pShowInfo->pwszSeparator != NULL )
        {
            ShowMessage( stdout, pShowInfo->pwszSeparator );
        }
        else
        {
            ShowMessage( stdout, L" " );
        }
    }

    // type
    if ( (pShowInfo->dwFlags & RSI_IGNORETYPE) == 0 )
    {
        if ( pShowInfo->dwFlags & RSI_SHOWTYPENUMBER )
        {
            ShowMessageEx( stdout, 2, TRUE, L"%s (%d)",
                GetTypeStrFromType( NULL, NULL, pShowInfo->dwType ), pShowInfo->dwType );
        }
        else
        {
            ShowMessage( stdout,
                GetTypeStrFromType( NULL, NULL, pShowInfo->dwType ) );
        }

        // display the separator
        if ( pShowInfo->pwszSeparator != NULL )
        {
            ShowMessage( stdout, pShowInfo->pwszSeparator );
        }
        else
        {
            ShowMessage( stdout, L" " );
        }
    }

    // value
    if ( (pShowInfo->dwFlags & RSI_IGNOREVALUE) == 0 )
    {
        dwSize = pShowInfo->dwSize;
        pByteData = pShowInfo->pByteData;
        if ( pByteData == NULL )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
        else if ( dwSize != 0 )
        {

            switch( pShowInfo->dwType )
            {
            default:
            case REG_LINK:
            case REG_BINARY:
            case REG_RESOURCE_LIST:
            case REG_FULL_RESOURCE_DESCRIPTOR:
            {
                for( dw = 0; dw < dwSize; dw++ )
                {
                    ShowMessageEx( stdout, 1, TRUE, L"%02X", pByteData[ dw ] );
                }
                break;
            }

            case REG_SZ:
            case REG_EXPAND_SZ:
            {
                ShowMessage( stdout, (LPCWSTR) pByteData );
                break;
            }

            case REG_DWORD:
            case REG_DWORD_BIG_ENDIAN:
            {
                ShowMessageEx( stdout, 1, TRUE, L"0x%x", *((DWORD*) pByteData) );
                break;
            }

            case REG_MULTI_SZ:
            {
                //
                // Replace '\0' with "\0" for MULTI_SZ
                //
                pwszSeparator = L"\\0";
                if ( pShowInfo->pwszMultiSzSeparator != NULL )
                {
                    pwszSeparator = pShowInfo->pwszMultiSzSeparator;
                }

                // ...
                pwszEnd = (LPCWSTR) pByteData;
                while( ((BYTE*) pwszEnd) < (pByteData + dwSize) )
                {
                    if( *pwszEnd == 0 )
                    {
                        // enable the display of value separator and skip this
                        pwszEnd++;
                        bShowSeparator = TRUE;
                    }
                    else
                    {
                        // check whether we need to display the separator or not
                        if ( bShowSeparator == TRUE )
                        {
                            ShowMessage( stdout, pwszSeparator );
                        }

                        ShowMessage( stdout, pwszEnd );
                        pwszEnd += StringLength( pwszEnd, 0 );
                    }
                }

                break;
            }
            }
        }
    }

    // ...
    ShowMessage( stdout, L"\n" );

    // return
    return TRUE;
}


LPWSTR
GetTemporaryFileName( LPCWSTR pwszSavedFilePath )
{
    // local variables
    LONG lIndex = 0;
    DWORD dwTemp = 0;
    DWORD dwPathLength = 0;
    DWORD dwFileNameLength = 0;
    LPWSTR pwszPath = NULL;
    LPWSTR pwszFileName = NULL;

    // allocate memory for path info
    dwPathLength = MAX_PATH;
    pwszPath = (LPWSTR) AllocateMemory( (dwPathLength + 1) * sizeof( WCHAR ) );
    if ( pwszPath == NULL )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return NULL;
    }

    //
    // get the temporary path location
    dwTemp = GetTempPath( dwPathLength, pwszPath );
    if ( dwTemp == 0 )
    {
        FreeMemory( &pwszPath );
        return NULL;
    }
    else if ( dwTemp >= dwPathLength )
    {
        dwPathLength = dwTemp + 2;
        if ( ReallocateMemory( &pwszPath, (dwPathLength + 1) * sizeof( WCHAR ) ) == FALSE )
        {
            FreeMemory( &pwszPath );
            SetLastError( ERROR_OUTOFMEMORY );
            return NULL;
        }

        // this is a simple and silly check being done just to overcome the
        // PREfix error -- ReAllocateMemory function will not return TRUE
        // when the memory is not successfully allocated
        if ( pwszPath == NULL )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return NULL;
        }

        // try to get temporary path again
        dwTemp = GetTempPath( dwPathLength, pwszPath );
        if ( dwTemp == 0 )
        {
            FreeMemory( &pwszPath );
            return NULL;
        }
        else if ( dwTemp >= dwPathLength )
        {
            FreeMemory( &pwszPath );
            SetLastError( (DWORD) STG_E_UNKNOWN );
            return FALSE;
        }
    }

    //
    // get the temporary file name
    dwFileNameLength = MAX_PATH;
    pwszFileName = (LPWSTR) AllocateMemory( (dwFileNameLength + 1) * sizeof( WCHAR ) );
    if ( pwszFileName == NULL )
    {
        FreeMemory( &pwszPath );
        SetLastError( ERROR_OUTOFMEMORY );
        return NULL;
    }

    // ...
    dwTemp = GetTempFileName( pwszPath, L"REG", 0, pwszFileName );
    if ( dwTemp == 0 )
    {
        if ( pwszSavedFilePath != NULL &&
             GetLastError() == ERROR_ACCESS_DENIED )
        {
            SetLastError( ERROR_ACCESS_DENIED );
            lIndex = StringLength( pwszSavedFilePath, 0 ) - 1;
            for( ; lIndex >= 0; lIndex-- )
            {
                if ( pwszSavedFilePath[ lIndex ] == L'\\' )
                {
                    if ( lIndex >= (LONG) dwPathLength )
                    {
                        dwPathLength = lIndex + 1;
                        if ( ReallocateMemory( &pwszPath, (dwPathLength + 5) ) == FALSE )
                        {
                            FreeMemory( &pwszPath );
                            FreeMemory( &pwszFileName );
                            return NULL;
                        }
                    }

                    // ...
                    StringCopy( pwszPath, pwszSavedFilePath, lIndex );

                    // break from the loop
                    break;
                }
            }

            // check whether we got the path information or not
            dwTemp = 0;
            if ( lIndex == -1 )
            {
                StringCopy( pwszPath, L".", MAX_PATH );
            }

            // now again try to get the temporary file name
            dwTemp = GetTempFileName( pwszPath, L"REG", 0, pwszFileName );

            // ...
            if ( dwTemp == 0 )
            {
                FreeMemory( &pwszPath );
                FreeMemory( &pwszFileName );
                return NULL;
            }
        }
        else
        {
            FreeMemory( &pwszPath );
            FreeMemory( &pwszFileName );
            return NULL;
        }
    }

    // release the memory allocated for path variable
    FreeMemory( &pwszPath );

    // since the API already created the file -- need to delete and pass just
    // the file name to the caller
    if ( DeleteFile( pwszFileName ) == FALSE )
    {
        FreeMemory( &pwszPath );
        return FALSE;
    }

    // return temporary file name generated
    return pwszFileName;
}


BOOL IsRegistryToolDisabled()
{
    // local variables
    HKEY hKey = NULL;
    DWORD dwType = 0;
    DWORD dwValue = 0;
    DWORD dwLength = 0;
    BOOL bRegistryToolDisabled = FALSE;

    bRegistryToolDisabled = FALSE;
    if ( RegOpenKey( HKEY_CURRENT_USER,
                     REGSTR_PATH_POLICIES TEXT("\\") REGSTR_KEY_SYSTEM,
                     &hKey ) == ERROR_SUCCESS )
    {
        dwLength = sizeof( DWORD );
        if ( RegQueryValueEx( hKey,
                              REGSTR_VAL_DISABLEREGTOOLS,
                              NULL, &dwType, (LPBYTE) &dwValue, &dwLength ) == ERROR_SUCCESS )
        {
            if ( (dwType == REG_DWORD) && (dwLength == sizeof(DWORD)) && (dwValue != FALSE) )
            {
                bRegistryToolDisabled = TRUE;
            }
        }

        SafeCloseKey( &hKey );
    }

    return bRegistryToolDisabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\regdebug.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDEBUG.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  Debug routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  21 Nov 1993 TCS Original implementation.
*
*******************************************************************************/

#include "stdafx.h"
#include "reg.h"

#if DBG

#define SIZE_DEBUG_BUFFER               100

/*******************************************************************************
*
*  _DbgPrintf
*
*  DESCRIPTION:
*     Simple implementation of the "debug printf" routine.  Takes the given
*     format string and argument list and outputs the formatted string to the
*     debugger.  Only available in debug builds-- use the DbgPrintf macro
*     defined in REGEDIT.H to access this service or to ignore the printf.
*
*  PARAMETERS:
*     lpFormatString, printf-style format string.
*     ..., variable argument list.
*
*******************************************************************************/

VOID
CDECL
_DbgPrintf(
    PSTR pFormatString,
    ...
    )
{

    va_list arglist;
    CHAR DebugBuffer[SIZE_DEBUG_BUFFER];

    va_start(arglist, pFormatString);

    StringCchVPrintfA(DebugBuffer, ARRAYSIZE(DebugBuffer), pFormatString, arglist);

    OutputDebugStringA(DebugBuffer);
//    MessageBoxA(NULL, DebugBuffer, "RegEdit", MB_OK);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\reg1632.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REG1632.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  Win32 and MS-DOS compatibility macros for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  06 Apr 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REG1632
#define _INC_REG1632

#ifndef LPCHAR
typedef CHAR FAR*                       LPCHAR;
#endif

#define FILE_HANDLE                     HANDLE

#define OPENREADFILE(pfilename, handle)                                     \
    ((handle = CreateFile(pfilename, GENERIC_READ, FILE_SHARE_READ,         \
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) !=               \
        INVALID_HANDLE_VALUE)

#define OPENWRITEFILE(pfilename, handle)                                    \
    ((handle = CreateFile(pfilename, GENERIC_WRITE, 0,                      \
        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) !=               \
        INVALID_HANDLE_VALUE)

#define READFILE(handle, buffer, count, pnumbytes)                          \
    ReadFile(handle, buffer, count, pnumbytes, NULL)

#define WRITEFILE(handle, buffer, count, pnumbytes)                         \
    WriteFile(handle, buffer, count, pnumbytes, NULL)

#define SEEKCURRENTFILE(handle, count)                                      \
    (SetFilePointer(handle, (LONG) count, NULL, FILE_CURRENT))


#endif // _INC_REG1632
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\reg1632.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REG1632.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  Win32 and MS-DOS compatibility macros for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  06 Apr 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REG1632
#define _INC_REG1632

#ifndef LPCHAR
typedef CHAR FAR*                       LPCHAR;
#endif

#define FILE_HANDLE                     HANDLE

#define OPENREADFILE(pfilename, handle)                                     \
    ((handle = CreateFile(pfilename, GENERIC_READ, FILE_SHARE_READ,         \
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) !=               \
        INVALID_HANDLE_VALUE)

#define OPENWRITEFILE(pfilename, handle)                                    \
    ((handle = CreateFile(pfilename, GENERIC_WRITE, 0,                      \
        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) !=               \
        INVALID_HANDLE_VALUE)

#define READFILE(handle, buffer, count, pnumbytes)                          \
    ReadFile(handle, buffer, count, pnumbytes, NULL)

#define WRITEFILE(handle, buffer, count, pnumbytes)                         \
    WriteFile(handle, buffer, count, pnumbytes, NULL)

#define SEEKCURRENTFILE(handle, count)                                      \
    (SetFilePointer(handle, (LONG) count, NULL, FILE_CURRENT))


#endif // _INC_REG1632
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\pch.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       PCH.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Precompiled header for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*  07 Apr 1994 TCS Moved the definitions associated to REGISTRY_ROOT to
*                  REGPORTE.H to be more easily shared by the real mode registry
*                  tool.
*
*******************************************************************************/

#ifndef _INC_PCH
#define _INC_PCH

#define STRICT
#define _INC_OLE
#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <winuserp.h>
#include <comctrlp.h>
#include <memory.h>
#include <regdef.h>
#include "regporte.h"
#include "regmisc.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)        (sizeof(x) / sizeof(x[0]))
#endif

#define IMAGEINDEX(x)                   ((x) - IDI_FIRSTIMAGE)

typedef struct _EDITVALUEPARAM {
    PTSTR pValueName;
    PBYTE pValueData;
    UINT cbValueData;
}   EDITVALUEPARAM, FAR *LPEDITVALUEPARAM;

typedef struct _PORTVALUEPARAM 
{
    PBYTE pbData;
    UINT cbData;
}   PORTVALUEPARAM, *LPPORTVALUEPARAM;

//  Instance handle of this application.
extern HINSTANCE g_hInstance;

extern TCHAR g_NullString[];

//  TRUE if accelerator table should not be used, such as during a rename
//  operation.
extern BOOL g_fDisableAccelerators;

extern TCHAR g_KeyNameBuffer[MAXKEYNAME];
extern TCHAR g_ValueNameBuffer[MAXVALUENAME_LENGTH];

extern COLORREF g_clrWindow;
extern COLORREF g_clrWindowText;
extern COLORREF g_clrHighlight;
extern COLORREF g_clrHighlightText;

extern PTSTR g_pHelpFileName;

//  Association between the ASCII name and the handle of the registry key.
extern const REGISTRY_ROOT g_RegistryRoots[NUMBER_REGISTRY_ROOTS];

#endif // _INC_PCH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\regporte.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPORTE.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  File import and export engine routines for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGPORTE
#define _INC_REGPORTE

#ifndef LPHKEY
#define LPHKEY                          HKEY FAR*
#endif

typedef struct _REGISTRY_ROOT {
    LPTSTR lpKeyName;
    HKEY hKey;
}   REGISTRY_ROOT;

#define INDEX_HKEY_CLASSES_ROOT         0
#define INDEX_HKEY_CURRENT_USER         1
#define INDEX_HKEY_LOCAL_MACHINE        2
#define INDEX_HKEY_USERS                3
//  #define INDEX_HKEY_PERFORMANCE_DATA     4
#define INDEX_HKEY_CURRENT_CONFIG       4
#define INDEX_HKEY_DYN_DATA             5

//  #define NUMBER_REGISTRY_ROOTS           7
#define NUMBER_REGISTRY_ROOTS           6

//  BUGBUG:  This is supposed to be enough for one keyname plus one predefined
//  handle name.
#define SIZE_SELECTED_PATH              (MAXKEYNAME + 40)

extern const TCHAR g_HexConversion[];

extern UINT g_FileErrorStringID;

#define ERK_OPEN    0
#define ERK_CREATE  1
#define ERK_DELETE  2


DWORD
PASCAL
EditRegistryKey(
    LPHKEY lphKey,
    LPTSTR lpFullKeyName,
    UINT uOperation
    );

VOID
PASCAL
ImportRegFileWorker(
    LPTSTR lpFileName
    );

VOID
PASCAL
ExportWinNT50RegFile(
    LPTSTR lpFileName,
    LPTSTR lpSelectedPath
    );

VOID
PASCAL
ExportWin40RegFile(
    LPTSTR lpFileName,
    LPTSTR lpSelectedPath
    );

VOID
PASCAL
ImportRegFileUICallback(
    UINT Percentage
    );

LONG RegDeleteKeyRecursive(HKEY hKey,
                           LPCTSTR lpszSubKey);


typedef struct _PORTVALUEPARAM 
{
    PBYTE pbData;
    UINT cbData;
}   PORTVALUEPARAM, *LPPORTVALUEPARAM;

#endif // _INC_REGPORTE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\save.c ===
//-----------------------------------------------------------------------//
//
// File:    save.cpp
// Created: March 1997
// By:      Martin Holladay (a-martih)
// Purpose: Registry Save Support for REG.CPP
// Modification History:
//      Copied from Copy.cpp and modificd - May 1997 (a-martih)
//      Aug 1997 - MartinHo
//          Fixed bug which didn't allow you to specify a ROOT key.
//          Example REG SAVE HKLM\Software didn't work - but should have
//      April 1999 Zeyong Xu: re-design, revision -> version 2.0
//
//------------------------------------------------------------------------//

#include "stdafx.h"
#include "reg.h"

//
// function prototypes
//
LONG RegAdjustTokenPrivileges( LPCWSTR pwszMachine,
                               LPCWSTR pwszPrivilege, LONG lAttribute );
BOOL ParseSaveCmdLine( DWORD argc, LPCWSTR argv[],
                       LPCWSTR pwszOption, PTREG_PARAMS pParams, BOOL* pbUsage );
BOOL ParseUnLoadCmdLine( DWORD argc, LPCWSTR argv[],
                         PTREG_PARAMS pParams, BOOL* pbUsage );

//
// implementation
//

//-----------------------------------------------------------------------//
//
// SaveHive()
//
//-----------------------------------------------------------------------//

LONG
SaveHive( DWORD argc, LPCWSTR argv[] )
{
    // local variables
    LONG lResult = 0;
    BOOL bResult = TRUE;
    HKEY hKey = NULL;
    BOOL bUsage = FALSE;
    TREG_PARAMS params;
    LPCWSTR pwszList = NULL;
    LPCWSTR pwszFormat = NULL;

    if ( argc == 0 || argv == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ShowLastError( stderr );
        return 1;
    }

    // initialize the global data structure
    InitGlobalData( REG_SAVE, &params );

    //
    // Parse the cmd-line
    //
    bResult = ParseSaveCmdLine( argc, argv, L"SAVE", &params, &bUsage );
    if( bResult == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    // check whether we need to display the usage
    if ( bUsage == TRUE )
    {
        Usage( REG_SAVE );
        FreeGlobalData( &params );
        return 0;
    }

    //
    // Connect to the Remote Machine - if applicable
    //
    bResult = RegConnectMachine( &params );
    if( bResult == FALSE )
    {
        SaveErrorMessage( -1 );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    //
    // Open the key
    //
    lResult = RegOpenKeyEx( params.hRootKey, params.pwszSubKey, 0, KEY_READ, &hKey );
    if( lResult == ERROR_SUCCESS )
    {
        //
        // Acquire the necessary privilages and call the API
        //
        lResult = RegAdjustTokenPrivileges(
            params.pwszMachineName, SE_BACKUP_NAME, SE_PRIVILEGE_ENABLED);
        if( lResult == ERROR_SUCCESS )
        {
            lResult = RegSaveKeyEx( hKey, params.pwszValueName, NULL, REG_NO_COMPRESSION );
            if ( lResult == ERROR_ALREADY_EXISTS )
            {
                // load the format strings
                pwszFormat = GetResString2( IDS_SAVE_OVERWRITE_CONFIRM, 0 );
                pwszList = GetResString2( IDS_CONFIRM_CHOICE_LIST, 1 );

                // ...
                do
                {
                    lResult = Prompt( pwszFormat,
                        params.pwszValueName, pwszList, params.bForce );
                } while ( lResult > 2 );

                if( lResult != 1 )
                {
                    lResult = ERROR_CANCELLED;
                }
                else
                {
                    // since there are chances of getting access problems --
                    // instead of deleting the existing file, we will try to
                    // save the data using temporary file name and then transfer
                    // the contents to the orignal filename
                    params.pwszValue = params.pwszValueName;
                    params.pwszValueName = GetTemporaryFileName( params.pwszValueName );
                    if ( params.pwszValueName == NULL )
                    {
                        lResult = GetLastError();
                    }
                    else
                    {
                        // try to save
                        lResult = RegSaveKey( hKey, params.pwszValueName, NULL );

                        // check the result of the operation
                        if ( lResult == ERROR_SUCCESS )
                        {
                            bResult = CopyFile(
                                params.pwszValueName,
                                params.pwszValue, FALSE );
                            if ( bResult == FALSE )
                            {
                                lResult = GetLastError();
                            }
                        }

                        // ...
                        DeleteFile( params.pwszValueName );
                    }
                }
            }
            else
            {
                switch( lResult )
                {
                case ERROR_INVALID_PARAMETER:
                    {
                        lResult = ERROR_FILENAME_EXCED_RANGE;
                        break;
                    }

                default:
                    break;
                }
            }
        }

        SafeCloseKey( &hKey );
    }

    // display the result
    SaveErrorMessage( lResult );
    if ( lResult == ERROR_SUCCESS || lResult == ERROR_CANCELLED )
    {
        lResult = 0;
        ShowLastErrorEx( stdout, SLE_INTERNAL );
    }
    else
    {
        lResult = 1;
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // return
    FreeGlobalData( &params );
    return lResult;
}


//-----------------------------------------------------------------------//
//
// RestoreHive()
//
//-----------------------------------------------------------------------//

LONG
RestoreHive( DWORD argc, LPCWSTR argv[] )
{
    // local variables
    LONG lResult = 0;
    BOOL bResult = FALSE;
    HKEY hKey = NULL;
    BOOL bUsage = FALSE;
    TREG_PARAMS params;

    if ( argc == 0 || argv == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ShowLastError( stderr );
        return 1;
    }

    // initialize the global data structure
    InitGlobalData( REG_RESTORE, &params );

    //
    // Parse the cmd-line
    //
    bResult = ParseSaveCmdLine( argc, argv, L"RESTORE", &params, &bUsage );
    if( bResult == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    // check whether we need to display the usage
    if ( bUsage == TRUE )
    {
        Usage( REG_RESTORE );
        FreeGlobalData( &params );
        return 0;
    }

    //
    // Connect to the Remote Machine - if applicable
    //
    bResult = RegConnectMachine( &params );
    if( bResult == FALSE )
    {
        SaveErrorMessage( -1 );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    //
    // Open the key
    //
    lResult = RegOpenKeyEx( params.hRootKey,
        params.pwszSubKey, 0, KEY_ALL_ACCESS, &hKey );
    if( lResult == ERROR_SUCCESS )
    {
        //
        // Acquire the necessary privilages and call the API
        //
        lResult = RegAdjustTokenPrivileges(
            params.pwszMachineName, SE_RESTORE_NAME, SE_PRIVILEGE_ENABLED );
        if( lResult == ERROR_SUCCESS )
        {
            lResult = RegRestoreKey( hKey, params.pwszValueName, REG_FORCE_RESTORE );

            // check the return error code
            switch( lResult )
            {
            case ERROR_INVALID_PARAMETER:
                {
                    lResult = ERROR_FILENAME_EXCED_RANGE;
                    break;
                }

            default:
                break;
            }
        }

        SafeCloseKey( &hKey );
    }

    // display the result
    SaveErrorMessage( lResult );
    if ( lResult == ERROR_SUCCESS )
    {
        ShowLastErrorEx( stdout, SLE_INTERNAL );
    }
    else
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // return
    FreeGlobalData( &params );
    return ((lResult == ERROR_SUCCESS) ? 0 : 1);
}


//-----------------------------------------------------------------------//
//
// LoadHive()
//
//-----------------------------------------------------------------------//

LONG
LoadHive( DWORD argc, LPCWSTR argv[] )
{
    // local variables
    LONG lResult = 0;
    BOOL bResult = FALSE;
    BOOL bUsage = FALSE;
    TREG_PARAMS params;

    if ( argc == 0 || argv == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ShowLastError( stderr );
        return 1;
    }

    // initialize the global data structure
    InitGlobalData( REG_LOAD, &params );

    //
    // Parse the cmd-line
    //
    bResult = ParseSaveCmdLine( argc, argv, L"LOAD", &params, &bUsage );
    if( bResult == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    // check whether we need to display the usage
    if ( bUsage == TRUE )
    {
        Usage( REG_LOAD );
        FreeGlobalData( &params );
        return 0;
    }

    //
    // Connect to the Remote Machine - if applicable
    //
    bResult = RegConnectMachine( &params );
    if( bResult == FALSE )
    {
        SaveErrorMessage( -1 );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    //
    // Acquire the necessary privilages and call the API
    //
    lResult = RegAdjustTokenPrivileges(
        params.pwszMachineName, SE_RESTORE_NAME, SE_PRIVILEGE_ENABLED );
    if( lResult == ERROR_SUCCESS )
    {
        lResult = RegLoadKey( params.hRootKey, params.pwszSubKey, params.pwszValueName );

        // check the return error code
        switch( lResult )
        {
        case ERROR_INVALID_PARAMETER:
            {
                lResult = ERROR_FILENAME_EXCED_RANGE;
                break;
            }

        default:
            break;
        }
    }

    // display the result
    SaveErrorMessage( lResult );
    if ( lResult == ERROR_SUCCESS )
    {
        ShowLastErrorEx( stdout, SLE_INTERNAL );
    }
    else
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // return
    FreeGlobalData( &params );
    return ((lResult == ERROR_SUCCESS) ? 0 : 1);
}


//-----------------------------------------------------------------------//
//
// UnLoadHive()
//
//-----------------------------------------------------------------------//

LONG
UnLoadHive( DWORD argc, LPCWSTR argv[] )
{
    // local variables
    LONG lResult = 0;
    BOOL bResult = FALSE;
    BOOL bUsage = FALSE;
    TREG_PARAMS params;

    if ( argc == 0 || argv == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ShowLastError( stderr );
        return 1;
    }

    // initialize the global data structure
    InitGlobalData( REG_UNLOAD, &params );

    //
    // Parse the cmd-line
    //
    bResult = ParseUnLoadCmdLine( argc, argv, &params, &bUsage );
    if( bResult == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    // check whether we need to display the usage
    if ( bUsage == TRUE )
    {
        Usage( REG_UNLOAD );
        FreeGlobalData( &params );
        return 0;
    }

    //
    // Connect to the Remote Machine(s) - if applicable
    //
    bResult = RegConnectMachine( &params );
    if( bResult == FALSE )
    {
        SaveErrorMessage( -1 );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeGlobalData( &params );
        return 1;
    }

    //
    // Acquire the necessary privilages and call the API
    //
    lResult = RegAdjustTokenPrivileges(
        params.pwszMachineName, SE_RESTORE_NAME, SE_PRIVILEGE_ENABLED );
    if( lResult == ERROR_SUCCESS )
    {
        lResult = RegUnLoadKey( params.hRootKey, params.pwszSubKey );
    }

    // display the result
    SaveErrorMessage( lResult );
    if ( lResult == ERROR_SUCCESS )
    {
        ShowLastErrorEx( stdout, SLE_INTERNAL );
    }
    else
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // return
    FreeGlobalData( &params );
    return ((lResult == ERROR_SUCCESS) ? 0 : 1);
}


//------------------------------------------------------------------------//
//
// ParseSaveCmdLine()
//
//------------------------------------------------------------------------//

BOOL
ParseSaveCmdLine( DWORD argc, LPCWSTR argv[],
                  LPCWSTR pwszOption, PTREG_PARAMS pParams, BOOL* pbUsage )
{
    // local variables
    DWORD dwLength = 0;
    BOOL bResult = FALSE;

    // check the input
    if ( argc == 0 || argv == NULL ||
         pwszOption == NULL || pParams == NULL || pbUsage == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // check whether this function is being called for
    // valid operation or not
    if ( pParams->lOperation < 0 || pParams->lOperation >= REG_OPTIONS_COUNT )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Do we have a *valid* number of cmd-line params
    //
    if ( argc >= 3 && InString( argv[ 2 ], L"-?|/?|-h|/h", TRUE ) == TRUE )
    {
        if ( argc == 3 )
        {
            *pbUsage = TRUE;
            return TRUE;
        }
        else
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ pParams->lOperation ] );
            return FALSE;
        }
    }
    else if( (pParams->lOperation != REG_SAVE && argc != 4) ||
             (pParams->lOperation == REG_SAVE && (argc < 4 || argc > 5)) )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ pParams->lOperation ] );
        return FALSE;
    }
    else if ( StringCompareEx( argv[ 1 ], pwszOption, TRUE, 0 ) != 0 )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // Machine Name and Registry key
    //
    bResult = BreakDownKeyString( argv[ 2 ], pParams );
    if( bResult == FALSE )
    {
        return FALSE;
    }

    // for "LOAD" subkey should be present
    if ( pParams->lOperation == REG_LOAD )
    {
        if ( pParams->pwszSubKey == NULL ||
             StringLength( pParams->pwszSubKey, 0 ) == 0 )
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ pParams->lOperation ] );
            return FALSE;
        }
    }

    //
    // Get the FileName - using the szValueName string field to hold it
    //
    dwLength = StringLength( argv[ 3 ], 0 ) + 1;
    pParams->pwszValueName = (LPWSTR) AllocateMemory( dwLength * sizeof( WCHAR ) );
    if( pParams->pwszValueName == NULL )
    {
        SaveErrorMessage( ERROR_OUTOFMEMORY );
        return FALSE;
    }

    // ...
    StringCopy( pParams->pwszValueName, argv[ 3 ], dwLength );

    // validate the file name -- it should not be empty
    TrimString( pParams->pwszValueName, TRIM_ALL );
    if ( StringLength( pParams->pwszValueName, 0 ) == 0 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ pParams->lOperation ] );
        return FALSE;
    }

    // check if user specified overwrite flag or not -- this is only for REG SAVE
    if ( argc == 5 && pParams->lOperation == REG_SAVE )
    {
        pParams->bForce = FALSE;
        if ( StringCompareEx( argv[ 4 ], L"/y", TRUE, 0 ) == 0 )
        {
            pParams->bForce = TRUE;
        }
        else
        {
            SetLastError( (DWORD) MK_E_SYNTAX );
            SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ pParams->lOperation ] );
            return FALSE;
        }
    }

    // return
    return TRUE;
}

//------------------------------------------------------------------------//
//
// ParseUnLoadCmdLine()
//
//------------------------------------------------------------------------//

BOOL
ParseUnLoadCmdLine( DWORD argc, LPCWSTR argv[],
                    PTREG_PARAMS pParams, BOOL* pbUsage )
{
    // local variables
    BOOL bResult = FALSE;

    // check the input
    if ( argc == 0 || argv == NULL || pParams == NULL || pbUsage == NULL )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // check whether this function is being called for
    // valid operation or not
    if ( pParams->lOperation < 0 || pParams->lOperation >= REG_OPTIONS_COUNT )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Do we have a *valid* number of cmd-line params
    //
    if( argc != 3 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_UNLOAD ] );
        return FALSE;
    }
    else if ( InString( argv[ 2 ], L"-?|/?|-h|/h", TRUE ) == TRUE )
    {
        *pbUsage = TRUE;
        return TRUE;
    }
    else if ( StringCompareEx( argv[ 1 ], L"UNLOAD", TRUE, 0 ) != 0 )
    {
        SaveErrorMessage( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // Machine Name and Registry key
    //
    bResult = BreakDownKeyString( argv[ 2 ], pParams );
    if( bResult == FALSE )
    {
        return FALSE;
    }

    if ( pParams->pwszSubKey == NULL ||
         StringLength( pParams->pwszSubKey, 0 ) == 0 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        SetReason2( 1, ERROR_INVALID_SYNTAX_WITHOPT, g_wszOptions[ REG_UNLOAD ] );
        return FALSE;
    }

    // return
    return TRUE;
}


//------------------------------------------------------------------------//
//
// AdjustTokenPrivileges()
//
//------------------------------------------------------------------------//

LONG
RegAdjustTokenPrivileges( LPCWSTR pwszMachine,
                          LPCWSTR pwszPrivilege, LONG lAttribute )
{
    // local variables
    BOOL bResult = FALSE;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;

    bResult = OpenProcessToken( GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken );
    if( bResult == FALSE )
    {
        return GetLastError();
    }

    bResult = LookupPrivilegeValue( pwszMachine, pwszPrivilege, &tkp.Privileges[0].Luid );
    if( bResult == FALSE )
    {
        return GetLastError();
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = lAttribute;
    bResult = AdjustTokenPrivileges( hToken,
        FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) NULL, NULL );
    if( bResult == FALSE )
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\regdef.h ===
/* Do not include this before Windows.h */

/* ASM
; DO NOT INCLUDE THIS BEFORE WINDOWS.INC
*/

#define Dereference(x)  x=x;

/*XLATOFF*/
#pragma warning (disable:4209)      // turn off redefinition warning (with vmm.h)
/*XLATON*/

#ifndef _WINREG_
//  WINREG.H uses DECLARE_HANDLE(HKEY) giving incompatible types.
typedef DWORD       HKEY;
#endif

/*XLATOFF*/
#pragma warning (default:4209)      // turn on redefinition warning (with vmm.h)
/*XLATON*/

#define MAXKEYNAME      256
        // Max length of a key name string
#define MAXVALUENAME_LENGTH MAXKEYNAME
        // Max length of a value name string

//  When we need to increase the buffer to add one character, increase it by
//  (1/4)K so that we won't have to repeatly allocate for every new key stroke.
#define ALLOCATION_INCR                 256

// These file types are in the same order as the filer list in regedit.rc
// The list must start at 1
#define FILE_TYPE_REGEDIT5  1
#define FILE_TYPE_REGEDT32  2
#define FILE_TYPE_TEXT      3
#define FILE_TYPE_REGEDIT4  4

#ifndef REG_SZ
#define REG_SZ      0x0001
#endif

#ifndef REG_BINARY
#define REG_BINARY  0x0003
#endif

#ifndef REG_DWORD
#define REG_DWORD       0x0004
#endif

#ifndef FALSE
#define FALSE   0
#endif
#ifndef TRUE
#define TRUE    ~FALSE
#endif

/* following equates are also defined in Windows.h. To avoid warnings
 *  we should make these equates  conditional
 */


#ifndef ERROR_SUCCESS           
#define ERROR_SUCCESS           0L
#endif

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND        2L
#endif

#ifndef ERROR_ACCESS_DENIED
#define ERROR_ACCESS_DENIED              5L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY             1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY          14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER        87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS       259L
#endif  

// INTERNAL

#ifndef ERROR_CANTOPEN16_FILENOTFOUND32
#define ERROR_CANTOPEN16_FILENOTFOUND32 0xffff0000
#define ERROR_CANTREAD16_FILENOTFOUND32 0xffff0001
#endif

#ifndef HKEY_CLASSES_ROOT
#define HKEY_CLASSES_ROOT          ((HKEY)0x80000000)
#endif

#ifndef HKEY_CURRENT_USER
#define HKEY_CURRENT_USER              ((HKEY)0x80000001)
#endif

#ifndef HKEY_LOCAL_MACHINE
#define HKEY_LOCAL_MACHINE             ((HKEY)0x80000002)
#endif

#ifndef HKEY_USERS
#define HKEY_USERS                     ((HKEY)0x80000003)
#endif

#ifndef HKEY_PERFORMANCE_DATA
#define HKEY_PERFORMANCE_DATA          ((HKEY)0x80000004)
#endif

#ifndef HKEY_CURRENT_CONFIG
#define HKEY_CURRENT_CONFIG            ((HKEY)0x80000005)
#endif

#ifndef HKEY_DYN_DATA
#define HKEY_DYN_DATA                  ((HKEY)0x80000006)
#endif

// INTERNAL

#ifndef HKEY_PREDEF_KEYS
#define HKEY_PREDEF_KEYS    7
#endif

#define MAXREGFILES     HKEY_PREDEF_KEYS    

// sub function indices for Registry services in VMM for 16 bit callers

#define RegOpenKey_Idx      0x100
#define RegCreateKey_Idx    0x101
#define RegCloseKey_Idx     0x102
#define RegDeleteKey_Idx    0x103
#define RegSetValue_Idx     0x104
#define RegQueryValue_Idx   0x105
#define RegEnumKey_Idx      0x106
#define RegDeleteValue_Idx  0x107
#define RegEnumValue_Idx    0x108
#define RegQueryValueEx_Idx 0x109
#define RegSetValueEx_Idx   0x10A
#define RegFlushKey_Idx     0x10B
#define RegLoadKey_Idx      0x10C
#define RegUnLoadKey_Idx    0x10D
#define RegSaveKey_Idx      0x10E
#define RegRestore_Idx      0x10F
#define RegRemapPreDefKey_Idx   0x110

// Data structure passed to SYSDM.CPL DMRegistryError function
//  After UI, the function is to call
//  RegRestore(DWORD iLevel, LPREGQRSTR lpRgRstr)
//

struct Reg_Query_Restore_s {
DWORD   dwRQR_Err;      // Error code
DWORD   hRQR_RootKey;       // Root key for file
DWORD   dwRQR_Reference;    // Reference data for RegRestore
TCHAR   szRQR_SubKey[MAXKEYNAME]; // Subkey (for hives) or NULL string
TCHAR   szRQR_FileName[MAX_PATH]; // File name of bad file
};
typedef struct Reg_Query_Restore_s REGQRSTR;
typedef REGQRSTR FAR * LPREGQRSTR;


// END INTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\resource.h ===
#define IDS_USAGE_REG                   2
#define IDS_USAGE_ADD1                  4
#define IDS_USAGE_ADD2                  5
#define IDS_USAGE_DELETE                6
#define IDS_USAGE_COPY                  7
#define IDS_USAGE_SAVE                  8
#define IDS_USAGE_RESTORE               9
#define IDS_USAGE_LOAD                  10
#define IDS_USAGE_UNLOAD                11
#define IDS_USAGE_COMPARE1              12
#define IDS_USAGE_COMPARE2              13
#define IDS_USAGE_EXPORT                14
#define IDS_USAGE_IMPORT                15

#define IDS_ERROR_INVALID_SYNTAX            101
#define IDS_ERROR_INVALID_SYNTAX_EX         102
#define IDS_ERROR_INVALID_SYNTAX_WITHOPT    103
#define IDS_ERROR_BADKEYNAME                104
#define IDS_ERROR_NONREMOTABLEROOT          105
#define IDS_ERROR_NONLOADABLEROOT           106
#define IDS_NOMEMORY                        107
#define IDS_REGDISABLED                     108

#define IDS_ERROR_INVALID_NUMERIC_ADD       121
#define IDS_ERROR_INVALID_HEXVALUE_ADD      122
#define IDS_ERROR_INVALID_DATA_ADD          123

#define IDS_ERROR_COPYTOSELF_COPY           131

#define IDS_ERROR_PARTIAL_DELETE            141

#define IDS_ERROR_COMPARESELF_COMPARE       151

#define IDS_ERROR_READFAIL_QUERY            161

#define IDS_ERROR_NONREMOTABLEROOT_EXPORT   171

#define IDS_ERROR_PATHNOTFOUND              191

#define IDS_DELETE_PERMANENTLY              201
#define IDS_OVERWRITE_CONFIRM               202
#define IDS_OVERWRITE                       203
#define IDS_DELETEALL_CONFIRM               204
#define IDS_DELETE_CONFIRM                  205
#define IDS_CONFIRM_CHOICE_LIST             206
#define IDS_SAVE_OVERWRITE_CONFIRM          207

#define IDS_USAGE_QUERY1                    301
#define IDS_USAGE_QUERY2                    302
#define IDS_USAGE_QUERY3                    303

#define IDS_NONAME                          501
#define IDS_VALUENOTSET                     502

#define IDS_KEYS_DIFFERENT_COMPARE          511
#define IDS_KEYS_IDENTICAL_COMPARE          512
#define IDS_VALUE_COMPARE                   513
#define IDS_KEY_COMPARE                     514

#define IDS_STATISTICS_QUERY                521

#define IDS_QUERY_VALUENAME                 IDS_VALUE_COMPARE   // 526
#define IDS_QUERY_TYPE                      527
#define IDS_QUERY_DATA                      528

#define IDS_IMPFILEERRFILEOPEN          702
#define IDS_IMPFILEERRFILEREAD          703
#define IDS_IMPFILEERRREGOPEN           704
#define IDS_IMPFILEERRREGSET            705
#define IDS_IMPFILEERRFORMATBAD         706
#define IDS_IMPFILEERRVERBAD            707

#define IDS_EXPFILEERRINVALID           801
#define IDS_EXPFILEERRFILEWRITE         802

#define IDS_IMPFILEERRSUCCESS           ERROR_SUCCESS
#define IDS_EXPFILEERRSUCCESS           ERROR_SUCCESS
#define IDS_EXPFILEERRBADREGPATH        ERROR_BADKEY
#define IDS_EXPFILEERRREGENUM           ERROR_READ_FAULT
#define IDS_EXPFILEERRREGOPEN           ERROR_OPEN_FAILED
#define IDS_EXPFILEERRFILEOPEN          ERROR_OPEN_FAILED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//            or project specific include files that are used frequently,
//            but are changed infrequently
//


#include "resource.h"

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

// couple of useful macros
// straight copied from wdm.h
#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

// include header file only once
#pragma once

//
// public Windows header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <Security.h>
#include <SecExt.h>

#include <windows.h>
#include <wchar.h>
#include <io.h>
#include <sys/stat.h>
#include <limits.h>
#include <Shlwapi.h>
#include <winbase.h>

//
// public Windows header files
//
#include <windows.h>
#include <winperf.h>
#include <lmcons.h>
#include <lmerr.h>
// #include <dbghelp.h>
#include <psapi.h>
#include <ntexapi.h>


//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <tchar.h>
// #include <Winioctl.h>
#include <Rpcdce.h>
#include <crtdbg.h>
#include <diskguid.h>
#include <rpc.h>

//#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <direct.h>
#include "strsafe.h"

#include "cmdline.h"
#include "cmdlineres.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\reg\regporte.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPORTE.C
*
*  VERSION:     5.00
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  Histry:      Zeyong Xu modified it in March 1999
*
*  .REG format file import and export engine routines for the Registry Editor.
*
*******************************************************************************/

#include "stdafx.h"
#include "reg.h"
#include "reg1632.h"
#include "regdef.h"
#include "regdebug.h"
#include "regporte.h"
#include "malloc.h"

//  Association between the ASCII name and the handle of the registry key.
const REGISTRY_ROOT g_RegistryRoots[] = {
    TEXT("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT,
    TEXT("HKEY_CURRENT_USER"), HKEY_CURRENT_USER,
    TEXT("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE,
    TEXT("HKEY_USERS"), HKEY_USERS,
    TEXT("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG,
    TEXT("HKEY_DYN_DATA"), HKEY_DYN_DATA
};

const TCHAR s_RegistryHeader[] = TEXT("REGEDIT");

const TCHAR s_OldWin31RegFileRoot[] = TEXT(".classes");

const TCHAR s_Win40RegFileHeader[] = TEXT("REGEDIT4\n\n");

TCHAR g_ValueNameBuffer[MAXVALUENAME_LENGTH];

#define IsRegStringType(x)  (((x) == REG_SZ) || ((x) == REG_EXPAND_SZ) || ((x) == REG_MULTI_SZ))
#define ExtraAllocLen(Type) (IsRegStringType((Type)) ? sizeof(TCHAR) : 0)

#ifdef UNICODE
//
// New header is required for version 5.0 because the version detection code
// in Win 4.0 regedit wasn't very good (See comments in ImportRegFile for
// details)
//
const WORD s_UnicodeByteOrderMark = 0xFEFF;
const TCHAR s_WinNT50RegFileHeader[] = TEXT("Windows Registry Editor Version");
const TCHAR s_WinNT50RegFileVersion[] = TEXT("5.00");
#endif

const TCHAR s_HexPrefix[] = TEXT("hex");
const TCHAR s_DwordPrefix[] = TEXT("dword:");
const TCHAR g_HexConversion[16] = {TEXT('0'), TEXT('1'), TEXT('2'), TEXT('3'), TEXT('4'),
                                   TEXT('5'), TEXT('6'), TEXT('7'), TEXT('8'), TEXT('9'),
                                   TEXT('a'), TEXT('b'), TEXT('c'), TEXT('d'), TEXT('e'), TEXT('f')};
const TCHAR s_FileLineBreak[] = TEXT(",\\\n  ");

//REARCHITECT - we upped the size of this buffer from 512 to 64K to reduce the chance of hitting the bug
//where a DBCS character is split across two buffers.  The true fix was too risky at the time.
//Changed for NT5 RC2
#define SIZE_FILE_IO_BUFFER             0x10000 //64K

typedef struct _FILE_IO{
#ifdef UNICODE
    //
    // Space for unicode/ansi conversions, assumes worst case
    // where every unicode char is a double-byte char
    //
    CHAR ConversionBuffer[SIZE_FILE_IO_BUFFER*2];
#endif
    TCHAR Buffer[SIZE_FILE_IO_BUFFER];
    FILE_HANDLE hFile;
    int BufferOffset;
    int CurrentColumn;
    int CharsAvailable;
    DWORD FileSizeDiv100;
    DWORD FileOffset;
    UINT LastPercentage;
#ifdef DEBUG
    BOOL fValidateUngetChar;
#endif
}   FILE_IO;

FILE_IO s_FileIo;

UINT g_FileErrorStringID;

UINT g_ImportFileVersion;

DWORD g_dwTotalKeysSaved = 0;

BOOL s_fTreatFileAsUnicode = TRUE;

VOID NEAR PASCAL ImportWin31RegFile( VOID );

VOID
NEAR PASCAL
ImportNewerRegFile( VOID );

VOID ParseHeader( LPHKEY lphKey );

VOID
NEAR PASCAL
ParseValue(
    HKEY hKey,
    LPCTSTR lpszValueName
    );

VOID
NEAR PASCAL
ParseValuename(
    HKEY hKey
    );

BOOL
NEAR PASCAL
ParseString(LPPORTVALUEPARAM pPortValueParam);

BOOL
NEAR PASCAL
ParseHexSequence(LPPORTVALUEPARAM pPortValueParam);

BOOL
NEAR PASCAL
ParseHexDword(
    LPDWORD lpDword
    );

BOOL
NEAR PASCAL
ParseHexByte(
    LPBYTE lpByte
    );

BOOL
NEAR PASCAL
ParseHexDigit(
    LPBYTE lpDigit
    );

BOOL
NEAR PASCAL
ParseEndOfLine(
    VOID
    );

VOID
NEAR PASCAL
SkipWhitespace(
    VOID
    );

VOID
NEAR PASCAL
SkipPastEndOfLine(
    VOID
    );

BOOL
NEAR PASCAL
GetChar(
    PTCHAR lpChar
    );

VOID
NEAR PASCAL
UngetChar(
    VOID
    );

BOOL
NEAR PASCAL
MatchChar(
    TCHAR CharToMatch
    );

BOOL
NEAR PASCAL
IsWhitespace(
    TCHAR Char
    );

BOOL
NEAR PASCAL
IsNewLine(
    TCHAR Char
    );

VOID
NEAR PASCAL
PutBranch(
    HKEY hKey,
    LPTSTR lpKeyName
    );

VOID
NEAR PASCAL
PutLiteral(
    LPCTSTR lpString
    );

VOID
NEAR PASCAL
PutString(
    LPCTSTR lpString
    );

VOID
NEAR PASCAL
PutBinary(
    CONST BYTE FAR* lpBuffer,
    DWORD Type,
    DWORD cbBytes
    );

VOID
NEAR PASCAL
PutDword(
    DWORD Dword,
    BOOL fLeadingZeroes
    );

VOID
NEAR PASCAL
PutChar(
    TCHAR Char
    );

VOID
NEAR PASCAL
FlushIoBuffer(
    VOID
    );

/*******************************************************************************
*
*  EditRegistryKey
*
*  DESCRIPTION:
*     Parses the pFullKeyName string and creates a handle to the registry key.
*
*  PARAMETERS:
*     lphKey, location to store handle to registry key.
*     lpFullKeyName, string of form "HKEY_LOCAL_MACHINE\Subkey1\Subkey2".
*     fCreate, TRUE if key should be created, else FALSE for open only.
*     (returns), ERROR_SUCCESS, no errors occurred, phKey is valid,
*                ERROR_CANTOPEN, registry access error of some form,
*                ERROR_BADKEY, incorrectly formed pFullKeyName.
*
*******************************************************************************/

DWORD
PASCAL
EditRegistryKey(
    LPHKEY lphKey,
    LPTSTR lpFullKeyName,
    UINT uOperation
    )
{

    LPTSTR lpSubKeyName = NULL;
    TCHAR PrevChar = L'\0';
    HKEY hRootKey;
    UINT Counter;
    DWORD Result;

    if ((lpSubKeyName = (LPTSTR) StrChr(lpFullKeyName, TEXT('\\'))) != NULL) {

        PrevChar = *lpSubKeyName;
        *lpSubKeyName++ = 0;

    }

    CharUpper(lpFullKeyName);

    hRootKey = NULL;

    for (Counter = 0; Counter < NUMBER_REGISTRY_ROOTS; Counter++) {

        if (lstrcmp(g_RegistryRoots[Counter].lpKeyName, lpFullKeyName) == 0) {

            hRootKey = g_RegistryRoots[Counter].hKey;
            break;

        }

    }

    if (hRootKey) {

        Result = ERROR_CANTOPEN;

        switch (uOperation)
        {
        case ERK_CREATE:
            //
            // If trying to open one of these keys just return OK
            // When lpSubKeyName is NULL, you recreate the parent key
            // Since these keys are usually in use this will fail
            // This code path only occurs when restoring a whole root key
            // from a .reg file.
            //
            if (((hRootKey == HKEY_LOCAL_MACHINE) || (hRootKey == HKEY_USERS))
                && lpSubKeyName == NULL) {
                Result = ERROR_SUCCESS;
            }
            else if (RegCreateKey(hRootKey, lpSubKeyName, lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;
            break;

        case ERK_OPEN:
            //
            // Used when exporting.
            //
            if(RegOpenKeyEx(hRootKey,lpSubKeyName,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;
            break;

        case ERK_DELETE:
            RegDeleteKeyRecursive(hRootKey, lpSubKeyName);
            // asssume success... don't care if this fails
            Result = ERROR_SUCCESS;
            *lphKey = NULL;
            break;
        }

    }
    else
    {
        Result = ERROR_BADKEY;
    }

    if (lpSubKeyName != NULL) {

        lpSubKeyName--;
        *lpSubKeyName = PrevChar;

    }

    return Result;

}

/*******************************************************************************
*
*  ImportRegFileWorker
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     lpFileName, address of name of file to be imported.
*
*******************************************************************************/

VOID
PASCAL
ImportRegFileWorker(
    LPTSTR lpFileName
    )
{

    TCHAR Char;
    LPCTSTR lpHeader = NULL;
    BOOL fNewRegistryFile;
#ifdef UNICODE
    UINT Temp, i;
    TCHAR StrToIntBuf[2];
    LPCTSTR lp50Header = NULL;
#endif // UNICODE
    DWORD cch;
    TCHAR tchBuffer[MAX_PATH] = {0};
    LPTSTR lpFilePart = NULL;

    g_FileErrorStringID = IDS_IMPFILEERRSUCCESS;

    // OPENREADFILE used to be OpenFile(), but there isn't any Unicode version
    // of that API, so now it's CreateFile().  But OpenFile searched the path
    // automatically, whereas CreateFile does not.  Corel's 'Perfect Office v6'
    // install app depends on the path being searched, so do it manually.

    cch = SearchPath(NULL,                // pointer to search path
                     lpFileName,          // pointer to filename
                     NULL,                // pointer to extension
                     ARRAYSIZE(tchBuffer), // size, in characters, of buffer
                     (TCHAR*)tchBuffer,   // pointer to buffer for found filename
                     &lpFilePart);        // pointer to pointer to file component);

    if ((cch != 0) && (cch <= MAX_PATH) && OPENREADFILE((TCHAR*)tchBuffer, s_FileIo.hFile)) 
    {
        WORD wBOM;
        DWORD NumberOfBytesRead;

        s_FileIo.FileSizeDiv100 = GetFileSize(s_FileIo.hFile, NULL) / 100;
        s_FileIo.FileOffset = 0;
        s_FileIo.CharsAvailable = 0;
        s_FileIo.LastPercentage = 0;

        //
        // Read the first two bytes. If it's the Unicode byte order mark,
        // set a flag so all the rest of the file will be interpreted
        // as ANSI or Unicode text properly.
        //
        if (!READFILE(s_FileIo.hFile, &wBOM,
            sizeof(wBOM), &NumberOfBytesRead)) {

            g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
            goto exit_gracefully;
        }

        if (wBOM == s_UnicodeByteOrderMark)
            s_fTreatFileAsUnicode = TRUE;
        else {
            s_fTreatFileAsUnicode = FALSE;
            // We probably just read "RE" from "REGEDIT4".  Back up the file
            // position so the ANSI import routines get what they expect
            SetFilePointer(s_FileIo.hFile, -2, NULL, FILE_CURRENT);
        }

        //
        //  The following will force GetChar to read in the first block of data.
        //

        s_FileIo.BufferOffset = 0;

        SkipWhitespace();

        lpHeader = s_RegistryHeader;
        g_ImportFileVersion = 0;

# if 0
    Sit back, and I will tell ye a tale of woe.

    Win95 and NT 4 shipped with regedit compiled ANSI.  There are a couple
    of registry types on NT (namely REG_EXPAND_SZ and REG_MULTI_SZ) that
    weren't on Win95, and which regedit doesn't really understand.  regedit
    treats these registry types as hex binary streams.

    You can probably see where this is going.

    If you exported, say your user TEMP environment variable on NT 4
    using regedit, you'd get something that looked like this:

REGEDIT4

[HKEY_CURRENT_USER\Environment]
"TEMP"=hex(2):25,53,59,53,54,45,4d,44,52,49,56,45,25,5c,53,48,54,65,6d,70,00

    ...a nice, null-terminated ANSI string.  Nice, that is, until we decided
    to compile regedit UNICODE for NT 5.  A unicode regedit exports your
    user TEMP variable like this:

REGEDIT4

[HKEY_CURRENT_USER\Environment]
"TEMP"=hex(2):25,00,53,00,59,00,53,00,54,00,45,00,4d,00,44,00,52,00,49,00,56,\
  00,45,00,25,00,5c,00,53,00,48,00,54,00,65,00,6d,00,70,00,00,00

    ...mmmm.  Unicode.  Of course, a unicode regedit also expects anything
    it imports to have all those interspersed zeroes, too.  Otherwise,
    it dumps garbage into your registry.  All it takes is a -DUNICODE, and
    regedit is suddenly incompatible with the thousdands of existing .reg
    files out there.

    So just bump the version in the header to REGEDIT5 and be done with
    it, right?  Wrong.  The regedit on Win95 and NT 4 looks at the first
    character after the string "REGEDIT" and compares it to the digit "4".
    If that character is anything other than the digit "4", the parser
    assumes it is looking at a Windows 3.1 file.  Yep.  There will only
    ever be two formats, right?  Just Win95 and Win3.1.  That's all the
    world needs.

    So a completely new .reg file header had to be invented, so that the
    older, regedits of the world would simply regect the new,
    unicodized .reg files outright.  An NT 5 .reg file, exporting your user
    TEMP variable, looks like this:

Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Environment]
"TEMP"=hex(2):25,00,53,00,59,00,53,00,54,00,45,00,4d,00,44,00,52,00,49,00,56,\
  00,45,00,25,00,5c,00,53,00,48,00,54,00,65,00,6d,00,70,00,00,00

    The parser is still not very good, but it does bother to convert that 5.00
    into a version number, so that future generations can bump it to 5.50 or
    6.00, and the regedit 5.00 that shipped with NT 5.00 will properly reject
    the files.
#endif // 0

#ifdef UNICODE
        //
        // Compare to the new .reg file header
        //
        lp50Header = s_WinNT50RegFileHeader;
        while (*lp50Header != 0) {

            if (MatchChar(*lp50Header))
                lp50Header = CharNext(lp50Header);

            else
                break;

        }

        //
        // If the above loop pushed lp50Header to its terminating null
        // character, then the header matches.
        //
        if (0 == *lp50Header) {

            SkipWhitespace();
            //
            // Now, decode the version number into a hex, _WIN32_WINNT
            // style version number.
            //
            StrToIntBuf[1] = 0;

            //
            // Any number of digits can come before the decimal point
            //
            while (!MatchChar(TEXT('.'))) {
                if (!GetChar(StrToIntBuf) || !IsCharAlphaNumeric(*StrToIntBuf)) {
                    g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
                    goto exit_gracefully;
                }

                Temp = StrToInt(StrToIntBuf);
                // Hex version number, so move left four bits.
                g_ImportFileVersion <<= 4;
                g_ImportFileVersion += Temp;
            }

            //
            // Fixed at two digits after the decimal point
            //
            for (i = 0; i < 2; i++) {
                if (!GetChar(StrToIntBuf) || !IsCharAlphaNumeric(*StrToIntBuf)) {
                    g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
                    goto exit_gracefully;
                }

                Temp = StrToInt(StrToIntBuf);
                // Hex version number, so move left four bits.
                g_ImportFileVersion <<= 4;
                g_ImportFileVersion += Temp;
            }

            //
            // For NT 5, reject any version number that isn't
            // 5.  This can be expanded into a switch statement
            // when the version number is bumped later.
            //
            if (0x0500 != g_ImportFileVersion) {
                g_FileErrorStringID = IDS_IMPFILEERRVERBAD;
                goto exit_gracefully;
            }
            else {
                SkipWhitespace();
                ImportNewerRegFile();
            }

        } // if (0 == *lp50Header)
        //
        // It doesn't use the new .reg file header, so
        // it's not an NT 5.0+ registry file, so use the
        // older algorithm to see if it's a valid older registry file
        //
        else {
#endif // UNICODE

            while (*lpHeader != 0) {

                if (MatchChar(*lpHeader))
                    lpHeader = CharNext(lpHeader);

                else
                    break;

            }

            if (*lpHeader == 0) {

                //
                // Win95's and NT 4's regedit shipped with this line
                // of code.  It is the cause of all of the suffering above.
                // Notice the incorrect assumption:  "If the very next
                // character isn't a '4', then we must be reading
                // a Windows 3.1 registry file!"  Of course there won't
                // be a version 5 of regedit.  Version 4 was perfect!
                //
                fNewRegistryFile = MatchChar(TEXT('4'));

                SkipWhitespace();

                if (GetChar(&Char) && IsNewLine(Char)) {

                    if (fNewRegistryFile) {
                        g_ImportFileVersion = 0x0400;
                        ImportNewerRegFile();
                    }
                    else {
                        g_ImportFileVersion = 0x0310;
                        ImportWin31RegFile();
                    }
                }
            }
            else
            {
                g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
            }
#ifdef UNICODE
        }
#endif // UNICODE

    } // if (OPENREADFILE...

    else 
    {
        { 
            TCHAR buff[250];
            StringCchPrintf(buff, ARRAYSIZE(buff), L"REGEDIT:  CreateFile failed, GetLastError() = %d\n", 
                    GetLastError());
            OutputDebugString(buff);
        }
        s_FileIo.hFile = NULL;
        g_FileErrorStringID = IDS_IMPFILEERRFILEOPEN;
    }

#ifdef UNICODE // Urefd labels generate warnings
exit_gracefully:
#endif // UNICODE
    if (s_FileIo.hFile) {
        CloseHandle(s_FileIo.hFile);
    }

}

/*******************************************************************************
*
*  ImportWin31RegFile
*
*  DESCRIPTION:
*     Imports the contents of a Windows 3.1 style registry file into the
*     registry.
*
*     We scan over the file looking for lines of the following type:
*        HKEY_CLASSES_ROOT\keyname = value_data
*        HKEY_CLASSES_ROOT\keyname =value_data
*        HKEY_CLASSES_ROOT\keyname value_data
*        HKEY_CLASSES_ROOT\keyname                          (null value data)
*
*     In all cases, any number of spaces may follow 'keyname'.  Although we
*     only document the first syntax, the Windows 3.1 Regedit handled all of
*     these formats as valid, so this version will as well (fortunately, it
*     doesn't make the parsing any more complex!).
*
*     Note, we also support replacing HKEY_CLASSES_ROOT with \.classes above
*     which must come from some early releases of Windows.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
ImportWin31RegFile(
    VOID
    )
{

    HKEY hKey;
    TCHAR Char;
    BOOL fSuccess;
    LPCTSTR lpClassesRoot;
    TCHAR KeyName[MAXKEYNAME];
    UINT Index;

    //
    //  Keep an open handle to the classes root.  We may prevent some
    //  unneccessary flushing.
    //
    if(RegOpenKeyEx(HKEY_CLASSES_ROOT,NULL,0,KEY_SET_VALUE,&hKey) != ERROR_SUCCESS) {

        g_FileErrorStringID = IDS_IMPFILEERRREGOPEN;
        return;
    }

    for (;;) {

        //
        //  Check for the end of file condition.
        //

        if (!GetChar(&Char))
            break;

        UngetChar();                    //  Not efficient, but works for now.

        //
        //  Match the beginning of the line against one of the two aliases for
        //  HKEY_CLASSES_ROOT.
        //

        if (MatchChar(TEXT('\\')))
            lpClassesRoot = s_OldWin31RegFileRoot;

        else
            lpClassesRoot = g_RegistryRoots[INDEX_HKEY_CLASSES_ROOT].lpKeyName;

        fSuccess = TRUE;

        while (*lpClassesRoot != 0) {

            if (!MatchChar(*lpClassesRoot++)) {

                fSuccess = FALSE;
                break;

            }

        }

        //
        //  Make sure that we have a backslash seperating one of the aliases
        //  from the keyname.
        //

        if (fSuccess)
            fSuccess = MatchChar(TEXT('\\'));

        if (fSuccess) {

            //
            //  We've found one of the valid aliases, so read in the keyname.
            //

            //  fSuccess = TRUE;        //  Must be TRUE if we're in this block
            Index = 0;

            while (GetChar(&Char)) {

                if (Char == TEXT(' ') || IsNewLine(Char))
                    break;

                //
                //  Make sure that the keyname buffer doesn't overflow.  We must
                //  leave room for a terminating null.
                //

                if (Index >= (ARRAYSIZE(KeyName)) - 1) 
                {
                    fSuccess = FALSE;
                    break;
                }

                KeyName[Index++] = Char;

            }

            if (fSuccess)
            {
                UINT cMaxDataLength = ALLOCATION_INCR;
                PBYTE pbValueDataBuffer;

                KeyName[Index] = 0;

                //
                //  Now see if we have a value to assign to this keyname.
                //

                SkipWhitespace();

                if (MatchChar(TEXT('=')))
                    MatchChar(TEXT(' '));

                //  fSuccess = TRUE;    //  Must be TRUE if we're in this block
                Index = 0;

                pbValueDataBuffer = LocalAlloc(LPTR, cMaxDataLength);
                fSuccess = (pbValueDataBuffer != NULL);

                while (GetChar(&Char) && fSuccess)
                {

                    if (IsNewLine(Char))
                        break;

                    //
                    //  Make sure that the value data buffer doesn't overflow.
                    //  Because this is always string data, we must leave room
                    //  for a terminating null.
                    //

                    if (Index >= cMaxDataLength - 1)
                    {
                        PBYTE pbValueData =
                            LocalReAlloc(pbValueDataBuffer, cMaxDataLength + ALLOCATION_INCR, LMEM_MOVEABLE);

                        fSuccess = (pbValueData != NULL);
                        if (!fSuccess)
                        {
                            break;
                        }
                        else
                        {
                            pbValueDataBuffer = pbValueData;
                            cMaxDataLength += ALLOCATION_INCR;
                        }
                    }

                    ((PTSTR)pbValueDataBuffer)[Index++] = Char;

                }

                if (fSuccess)
                {

                    ((PTSTR)pbValueDataBuffer)[Index] = 0;

                    if (RegSetValue(hKey, KeyName, REG_SZ, (LPCTSTR)pbValueDataBuffer,
                        Index*sizeof(TCHAR)) != ERROR_SUCCESS)
                        g_FileErrorStringID = IDS_IMPFILEERRREGSET;
                }
                else
                {
                    g_FileErrorStringID = IDS_NOMEMORY;
                }

                if (pbValueDataBuffer)
                {
                    LocalFree(pbValueDataBuffer);
                }
            }

        }

        //
        //  Somewhere along the line, we had a parsing error, so resynchronize
        //  on the next line.
        //

        if (!fSuccess)
            SkipPastEndOfLine();

    }

    RegFlushKey(hKey);
    RegCloseKey(hKey);

}

/*******************************************************************************
*
*  ImportNewerRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ImportNewerRegFile(
    VOID
    )
{

    HKEY hLocalMachineKey = NULL;
    HKEY hUsersKey = NULL;
    HKEY hKey = NULL;
    TCHAR Char;

#ifdef WINNT
    hLocalMachineKey = NULL;
    hUsersKey = NULL;
#else
    //
    //  Keep open handles for the predefined roots to prevent the registry
    //  library from flushing after every single RegOpenKey/RegCloseKey
    //  operation.
    //

    RegOpenKey(HKEY_LOCAL_MACHINE, NULL, &hLocalMachineKey);
    RegOpenKey(HKEY_USERS, NULL, &hUsersKey);

#ifdef DEBUG
    if (hLocalMachineKey == NULL)
        DbgPrintf(("Unable to open HKEY_LOCAL_MACHINE\n\r"));
    if (hUsersKey == NULL)
        DbgPrintf(("Unable to open HKEY_USERS\n\r"));
#endif
#endif

    hKey = NULL;

    for (;;) {

        SkipWhitespace();

        //
        //  Check for the end of file condition.
        //

        if (!GetChar(&Char))
            break;

        switch (Char) {

            case TEXT('['):
                //
                //  If a registry key is currently open, we must close it first.
                //  If ParseHeader happens to fail (for example, no closing
                //  bracket), then hKey will be NULL and any values that we
                //  parse must be ignored.
                //

                if (hKey != NULL) {

                    RegCloseKey(hKey);
                    hKey = NULL;

                }

                ParseHeader(&hKey);

                break;

            case TEXT('"'):
                //
                //  As noted above, if we don't have an open registry key, then
                //  just skip the line.
                //

                if (hKey != NULL)
                    ParseValuename(hKey);

                else
                    SkipPastEndOfLine();

                break;

            case TEXT('@'):
                //
                //
                //

                if (hKey != NULL)
                    ParseValue(hKey, NULL);

                else
                    SkipPastEndOfLine();

                break;

            case TEXT(';'):
                //
                //  This line is a comment so just dump the rest of it.
                //

                SkipPastEndOfLine();

                break;

            default:
                if (IsNewLine(Char))
                    break;

                SkipPastEndOfLine();

                break;

        }

    }

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (hUsersKey != NULL)
        RegCloseKey(hUsersKey);

    if (hLocalMachineKey != NULL)
        RegCloseKey(hLocalMachineKey);

}

/*******************************************************************************
*
*  ParseHeader
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

// REARCHITECT - each subkeyname can be MAXKEYNAME in size
// ideally - we should handle unlimited size names
// let's at least handle bigger names for now
// at least a depth of 10 with maximum length subkey names

#define SIZE_FULL_KEYNAME ((MAXKEYNAME + 40)*10)

VOID NEAR PASCAL ParseHeader( LPHKEY lphKey )
{

    TCHAR FullKeyName[SIZE_FULL_KEYNAME];
    int CurrentIndex;
    int LastRightBracketIndex;
    TCHAR Char;
    UINT uOperation = ERK_CREATE;

    CurrentIndex = 0;
    LastRightBracketIndex = -1;

    if (!GetChar(&Char))
        return;

    if (Char == TEXT('-')) {
        if (!GetChar(&Char))
            return;
        uOperation = ERK_DELETE;
    }

    do {

        if (IsNewLine(Char))
            break;

        if (Char == TEXT(']'))
            LastRightBracketIndex = CurrentIndex;

        FullKeyName[CurrentIndex++] = Char;

        if (CurrentIndex == SIZE_FULL_KEYNAME) {

            do {

                if (Char == TEXT(']'))
                    LastRightBracketIndex = -1;

                if (IsNewLine(Char))
                    break;

            }   while (GetChar(&Char));

            break;

        }

    } while (GetChar(&Char));

    if (LastRightBracketIndex != -1)
    {
        FullKeyName[LastRightBracketIndex] = 0;

        switch (EditRegistryKey(lphKey, FullKeyName, uOperation))
        {
            //
            // Be afraid of adding code to handle more error cases here.
            //
            // We broke Picture Publisher 8.0 by adding an ERROR_BADKEY
            // case.  As part of their setup, they run regedit on a v4
            // reg file that has a bad section, which EditRegistryKey
            // will fail to parse with ERROR_BADKEY.  We need to keep
            // chugging along in that case like Win2K did, or else we
            // break their setup.
            //
            case ERROR_CANTOPEN:
                g_FileErrorStringID = IDS_IMPFILEERRREGOPEN;
                break;
        }

    }

}

/*******************************************************************************
*
*  ParseValuename
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ParseValuename(
    HKEY hKey
    )
{
    PORTVALUEPARAM PortValueParam;
    PortValueParam.cbData = MAXVALUENAME_LENGTH * sizeof(TCHAR);
    PortValueParam.pbData = LocalAlloc(LPTR, PortValueParam.cbData);

    if (PortValueParam.pbData)
    {
        if (ParseString(&PortValueParam))
        {
            ParseValue(hKey, (PTSTR)PortValueParam.pbData);
        }
        else
        {
            SkipPastEndOfLine();
        }
        LocalFree(PortValueParam.pbData);
    }
}

VOID
NEAR PASCAL
ParseValue(
           HKEY hKey,
           LPCTSTR lpszValueName
           )
{
    BOOL fSuccess = TRUE;
    BOOL fSkipPastLine = FALSE;
    DWORD Type = 0;
    DWORD cbData = 0;
    DWORD cbMaxData = ALLOCATION_INCR;
    LPCTSTR lpPrefix;
    PBYTE pbValueDataBuffer;

    SkipWhitespace();

    if (!MatchChar(TEXT('=')))
    {
        fSuccess = FALSE;
        fSkipPastLine = TRUE;
    }
    else
    {

        SkipWhitespace();

        pbValueDataBuffer = LocalAlloc(LPTR, cbMaxData);
        if (!pbValueDataBuffer)
        {
            g_FileErrorStringID = IDS_IMPFILEERRREGSET;
            fSuccess = FALSE;
        }
        else
        {
            //
            //  REG_SZ.
            //
            //  "ValueName" = "string of text"
            //

            if (MatchChar(TEXT('"')))
            {

                //  FEATURE:  Line continuations for strings?

                PORTVALUEPARAM PortValueParam;
                PortValueParam.pbData = pbValueDataBuffer;
                PortValueParam.cbData = cbMaxData;

                if (!ParseString(&PortValueParam) || !ParseEndOfLine())
                {
                    fSuccess = FALSE;
                    fSkipPastLine = TRUE;
                }

                // pointer might have been swapped for one with more memory
                pbValueDataBuffer = PortValueParam.pbData;
                cbData = PortValueParam.cbData;
                Type = REG_SZ;

            }

            //
            //  REG_DWORD.
            //
            //  "ValueName" = dword: 12345678
            //

            else if (MatchChar(s_DwordPrefix[0])) {

                lpPrefix = &s_DwordPrefix[1];

                while (*lpPrefix != 0)
                {
                    if (!MatchChar(*lpPrefix++))
                    {
                        fSuccess = FALSE;
                        fSkipPastLine = TRUE;
                    }
                }

                if (fSuccess)
                {
                    SkipWhitespace();

                    if (!ParseHexDword((LPDWORD) pbValueDataBuffer) || !ParseEndOfLine())
                    {
                        fSuccess = FALSE;
                        fSkipPastLine = TRUE;
                    }

                    Type = REG_DWORD;
                    cbData = sizeof(DWORD);
                }
            }
            else if (MatchChar('-'))
            {
                if (!ParseEndOfLine())
                {
                    fSuccess = FALSE;
                    fSkipPastLine = TRUE;
                }
                else
                {
                    RegDeleteValue(hKey, lpszValueName);
                    fSuccess = FALSE;
                }
            }

            //
            //  REG_BINARY and other.
            //
            //  "ValueName" = hex: 00 , 11 , 22
            //  "ValueName" = hex(12345678): 00, 11, 22
            //

            else {

                lpPrefix = s_HexPrefix;

                while (*lpPrefix != 0)
                {
                    if (!MatchChar(*lpPrefix++))
                    {
                        fSuccess = FALSE;
                        fSkipPastLine = TRUE;
                    }
                }

                if (fSuccess)
                {
                    //
                    //  Check if this is a type of registry data that we don't directly
                    //  support.  If so, then it's just a dump of hex data of the specified
                    //  type.
                    //

                    if (MatchChar(TEXT('(')))
                    {
                        if (!ParseHexDword(&Type) || !MatchChar(TEXT(')')))
                        {
                            fSuccess = FALSE;
                            fSkipPastLine = TRUE;
                        }
                    }

                    else
                        Type = REG_BINARY;

                    if (fSuccess)
                    {
                        PORTVALUEPARAM PortValueParam;
                        PortValueParam.pbData = pbValueDataBuffer;
                        PortValueParam.cbData = cbMaxData;

                        if (!MatchChar(TEXT(':')) || !ParseHexSequence(&PortValueParam) ||
                            !ParseEndOfLine())
                        {
                            fSuccess = FALSE;
                            fSkipPastLine = TRUE;
                        }

                        // pointer might have been swapped for one with more memory
                        pbValueDataBuffer = PortValueParam.pbData;
                        cbData = PortValueParam.cbData;
                    }
                }
            }

            if (fSuccess)
            {

#ifdef UNICODE
                //
                // If we're compiled UNICODE and we're reading an older, ANSI .reg
                // file, we have to write all of the data to the registry using
                // RegSetValueExA, because it was read from the registry using
                // RegQueryValueExA.
                //
                if ((g_ImportFileVersion < 0x0500) && ((REG_EXPAND_SZ == Type) || (REG_MULTI_SZ == Type)))
                {
                    CHAR AnsiValueName[MAXVALUENAME_LENGTH];
                    AnsiValueName[0] = 0;

                    //
                    // It's much easier to convert the value name to ANSI
                    // and call RegSetValueExA than to try to convert
                    // a REG_MULTI_SZ to Unicode before calling RegSetValueExW.
                    // We don't lose anything because this is coming from a
                    // downlevel .reg file that could only contain ANSI characters
                    // to begin with.
                    //
                    WideCharToMultiByte(
                        CP_THREAD_ACP,
                        0,
                        lpszValueName,
                        -1,
                        AnsiValueName,
                        ARRAYSIZE(AnsiValueName),
                        NULL,
                        NULL
                        );

                    if (RegSetValueExA(
                        hKey,
                        AnsiValueName,
                        0,
                        Type,
                        pbValueDataBuffer,
                        cbData)
                        != ERROR_SUCCESS)
                        g_FileErrorStringID = IDS_IMPFILEERRREGSET;
                }
                else 
                {
#endif // UNICODE
                    if (RegSetValueEx(hKey, lpszValueName, 0, Type, pbValueDataBuffer, cbData) != ERROR_SUCCESS)
                        g_FileErrorStringID = IDS_IMPFILEERRREGSET;
#ifdef UNICODE
                }
#endif // UNICODE

            }
            LocalFree(pbValueDataBuffer);
        }
    }

    if (fSkipPastLine)
    {
        SkipPastEndOfLine();
    }
}

/*******************************************************************************
*
*  ParseString
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseString(LPPORTVALUEPARAM pPortValueParam)
{
    TCHAR Char;
    DWORD cbMaxStringData;
    DWORD cbStringData;


    LPTSTR psz = (LPTSTR)pPortValueParam->pbData; // this one is incremented
    cbMaxStringData = pPortValueParam->cbData;
    cbStringData = sizeof(TCHAR);                   //  Account for the null terminator

    while (GetChar(&Char))
    {
        if (cbStringData >= cbMaxStringData)
        {
            // allocate a bigger buffer
            PBYTE pbValueData =
                LocalReAlloc(pPortValueParam->pbData, cbMaxStringData + ALLOCATION_INCR, LMEM_MOVEABLE);
            if (pbValueData)
            {
                pPortValueParam->pbData = pbValueData;
                // incr psz to next char in new buffer
                psz = (LPTSTR)(pPortValueParam->pbData + (cbMaxStringData - sizeof(TCHAR)));

                cbMaxStringData += ALLOCATION_INCR;
            }
            else
            {
                break;
            }
        }

        switch (Char) {

            case TEXT('\\'):
                if (!GetChar(&Char))
                    return FALSE;

                switch (Char) {

                    case TEXT('\\'):
                        *psz++ = TEXT('\\');
                        break;

                    case TEXT('"'):
                        *psz++ = TEXT('"');
                        break;

                    default:
                        DebugPrintf(("ParseString:  Invalid escape sequence"));
                        return FALSE;

                }
                break;

            case TEXT('"'):
                *psz = 0;
                pPortValueParam->cbData = cbStringData;
                return TRUE;

            default:
                if (IsNewLine(Char))
                    return FALSE;

                *psz++ = Char;
                break;

        }

        cbStringData += sizeof(TCHAR);

    }

    return FALSE;

}


/*******************************************************************************
*
*  ParseHexSequence
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexSequence(LPPORTVALUEPARAM pPortValueParam)
{
    BOOL  fSuccess = TRUE;
    DWORD cbHexData = 0;
    DWORD cbMaxStringData = pPortValueParam->cbData;
    LPBYTE lpHexData = pPortValueParam->pbData;

    do
    {
        if (cbHexData >= cbMaxStringData)
        {
            // allocate a bigger buffer
            PBYTE pbValueData = LocalReAlloc(pPortValueParam->pbData,
                cbMaxStringData + ALLOCATION_INCR, LMEM_MOVEABLE);
            if (pbValueData)
            {
                pPortValueParam->pbData = pbValueData;
                // incr psz to next char in new buffer
                lpHexData = pPortValueParam->pbData + cbMaxStringData;

                cbMaxStringData += ALLOCATION_INCR;
            }
            else
            {
                fSuccess = FALSE;
                break;
            }
        }

        SkipWhitespace();

        if (MatchChar(TEXT('\\')) && !ParseEndOfLine())
        {
            fSuccess = FALSE;
            break;
        }

        SkipWhitespace();

        if (!ParseHexByte(lpHexData++))
            break;

        cbHexData++;

        SkipWhitespace();

    }   while (MatchChar(TEXT(',')));

    pPortValueParam->cbData = cbHexData;

    return fSuccess;

}

/*******************************************************************************
*
*  ParseHexDword
*
*  DESCRIPTION:
*     Parses a one dword hexadecimal string from the registry file stream and
*     converts it to a binary number.  A maximum of eight hex digits will be
*     parsed from the stream.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal dword was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexDword(
    LPDWORD lpDword
    )
{

    UINT CountDigits;
    DWORD Dword;
    BYTE Byte;

    Dword = 0;
    CountDigits = 0;

    for (;;) {

        if (!ParseHexDigit(&Byte))
            break;

        Dword = (Dword << 4) + (DWORD) Byte;

        if (++CountDigits == 8)
            break;

    }

    *lpDword = Dword;

    return CountDigits != 0;

}

/*******************************************************************************
*
*  ParseHexByte
*
*  DESCRIPTION:
*     Parses a one byte hexadecimal string from the registry file stream and
*     converts it to a binary number.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal byte was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexByte(
    LPBYTE lpByte
    )
{

    BYTE SecondDigit;

    if (ParseHexDigit(lpByte)) {

        if (ParseHexDigit(&SecondDigit))
            *lpByte = (BYTE) ((*lpByte << 4) | SecondDigit);

        return TRUE;

    }

    else
        return FALSE;

}

/*******************************************************************************
*
*  ParseHexDigit
*
*  DESCRIPTION:
*     Parses a hexadecimal character from the registry file stream and converts
*     it to a binary number.
*
*  PARAMETERS:
*     lpDigit, location to store binary number.
*     (returns), TRUE if a hexadecimal digit was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexDigit(
    LPBYTE lpDigit
    )
{

    TCHAR Char;
    BYTE Digit;

    if (GetChar(&Char)) {

        if (Char >= TEXT('0') && Char <= TEXT('9'))
            Digit = (BYTE) (Char - TEXT('0'));

        else if (Char >= TEXT('a') && Char <= TEXT('f'))
            Digit = (BYTE) (Char - TEXT('a') + 10);

        else if (Char >= TEXT('A') && Char <= TEXT('F'))
            Digit = (BYTE) (Char - TEXT('A') + 10);

        else {

            UngetChar();

            return FALSE;

        }

        *lpDigit = Digit;

        return TRUE;

    }

    return FALSE;

}

/*******************************************************************************
*
*  ParseEndOfLine
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseEndOfLine(
    VOID
    )
{

    TCHAR Char;
    BOOL fComment;
    BOOL fFoundOneEndOfLine;
    BOOL fEOF;

    fComment = FALSE;
    fFoundOneEndOfLine = FALSE;
    fEOF = TRUE;

    while (GetChar(&Char)) {

        if (IsWhitespace(Char))
            continue;

        if (IsNewLine(Char)) {

            fComment = FALSE;
            fFoundOneEndOfLine = TRUE;

        }

        //
        //  Like .INIs and .INFs, comments begin with a semicolon character.
        //

        else if (Char == TEXT(';'))
            fComment = TRUE;

        else if (!fComment) {

            UngetChar();
            fEOF = FALSE;
            break;

        }

    }

    return fFoundOneEndOfLine || fEOF;

}

/*******************************************************************************
*
*  SkipWhitespace
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past any
*     detected whitespace.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
SkipWhitespace(
    VOID
    )
{

    TCHAR Char;

    while (GetChar(&Char)) {

        if (!IsWhitespace(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  SkipPastEndOfLine
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past the first
*     detected new line character.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
SkipPastEndOfLine(
    VOID
    )
{

    TCHAR Char;

    while (GetChar(&Char)) {

        if (IsNewLine(Char))
            break;

    }

    while (GetChar(&Char)) {

        if (!IsNewLine(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  GetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
GetChar(
    PTCHAR lpChar
    )
{

    DWORD NumberOfBytesRead;
    UINT NewPercentage;

    // If we're at the end of the buffer, read some more.
    // Initially BufferOffset and CharsAvailable will be 0
    if (s_FileIo.BufferOffset == s_FileIo.CharsAvailable) {

        if (TRUE == s_fTreatFileAsUnicode) 
        {
            if (!READFILE(s_FileIo.hFile, s_FileIo.Buffer, SIZE_FILE_IO_BUFFER, &NumberOfBytesRead)) 
            {
                g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
                return FALSE;
            }

            s_FileIo.CharsAvailable = ((int) NumberOfBytesRead / 2);
        }
        else 
        {
            if (!READFILE(s_FileIo.hFile, s_FileIo.ConversionBuffer, SIZE_FILE_IO_BUFFER, &NumberOfBytesRead)) 
            {
                g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
                return FALSE;
            }

            {
                int i;

                i = MultiByteToWideChar(
                        CP_THREAD_ACP,
                        MB_PRECOMPOSED,
                        s_FileIo.ConversionBuffer,
                        NumberOfBytesRead,
                        s_FileIo.Buffer,
                        ARRAYSIZE(s_FileIo.Buffer)
                        );

                s_FileIo.CharsAvailable = i;
            }
        }

        s_FileIo.BufferOffset = 0;
        s_FileIo.FileOffset += NumberOfBytesRead;

        if (s_FileIo.FileSizeDiv100 != 0) {

            NewPercentage = ((UINT) (s_FileIo.FileOffset /
                s_FileIo.FileSizeDiv100));

            if (NewPercentage > 100)
                NewPercentage = 100;

        }

        else
            NewPercentage = 100;

        if (s_FileIo.LastPercentage != NewPercentage) {

            s_FileIo.LastPercentage = NewPercentage;
            // ImportRegFileUICallback(NewPercentage);

        }

    }

    if (s_FileIo.BufferOffset >= s_FileIo.CharsAvailable)
        return FALSE;

    *lpChar = s_FileIo.Buffer[s_FileIo.BufferOffset++];

    return TRUE;

}

/*******************************************************************************
*
*  UngetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
UngetChar(
    VOID
    )
{

#ifdef DEBUG
    if (s_FileIo.fValidateUngetChar)
        DebugPrintf(("REGEDIT ERROR: Too many UngetChar's called!\n\r"));
#endif

    s_FileIo.BufferOffset--;

}

/*******************************************************************************
*
*  MatchChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
MatchChar(
    TCHAR CharToMatch
    )
{

    BOOL fMatch;
    TCHAR NextChar;

    fMatch = FALSE;

    if (GetChar(&NextChar)) {

        if (CharToMatch == NextChar)
            fMatch = TRUE;

        else
            UngetChar();

    }

    return fMatch;

}

/*******************************************************************************
*
*  IsWhitespace
*
*  DESCRIPTION:
*     Checks if the given character is whitespace.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is whitespace, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsWhitespace(
    TCHAR Char
    )
{

    return Char == TEXT(' ') || Char == TEXT('\t');

}

/*******************************************************************************
*
*  IsNewLine
*
*  DESCRIPTION:
*     Checks if the given character is a new line character.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is a new line, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsNewLine(
    TCHAR Char
    )
{

    return Char == TEXT('\n') || Char == TEXT('\r');

}

/*******************************************************************************
*
*  ExportWinNT50RegFile
*
*  DESCRIPTION:
*      Exports an NT 5.0, unicode registry file.  Use this export function
*      for all future .reg file writing.
*
*  PARAMETERS:
*
*******************************************************************************/
VOID ExportWinNT50RegFile(LPTSTR lpFileName, LPTSTR lpSelectedPath)
{

    HKEY hKey = INVALID_HANDLE_VALUE;
    TCHAR SelectedPath[SIZE_SELECTED_PATH];

    g_FileErrorStringID = IDS_EXPFILEERRSUCCESS;

    if (lpSelectedPath != NULL && 
        EditRegistryKey(&hKey, lpSelectedPath, ERK_OPEN) != ERROR_SUCCESS)
    {
        g_FileErrorStringID = IDS_EXPFILEERRBADREGPATH;
        return;
    }

    g_dwTotalKeysSaved = 0;
    if (OPENWRITEFILE(lpFileName, s_FileIo.hFile)) 
    {

        DWORD dwNumberOfBytesWritten;

        s_FileIo.BufferOffset = 0;
        s_FileIo.CurrentColumn = 0;

        WRITEFILE(s_FileIo.hFile, &s_UnicodeByteOrderMark, sizeof(s_UnicodeByteOrderMark), &dwNumberOfBytesWritten);

        PutLiteral(s_WinNT50RegFileHeader);
        PutLiteral(TEXT(" "));
        PutLiteral(s_WinNT50RegFileVersion);
        PutLiteral(TEXT("\n\n"));

        if (lpSelectedPath != NULL) 
        {
            StringCchCopy(SelectedPath, ARRAYSIZE(SelectedPath), lpSelectedPath);
            PutBranch(hKey, SelectedPath);

        }
        else
        {

            StringCchCopy(SelectedPath, ARRAYSIZE(SelectedPath), g_RegistryRoots[INDEX_HKEY_LOCAL_MACHINE].lpKeyName);

            PutBranch(HKEY_LOCAL_MACHINE, SelectedPath);

            StringCchCopy(SelectedPath, ARRAYSIZE(SelectedPath), g_RegistryRoots[INDEX_HKEY_USERS].lpKeyName);

            PutBranch(HKEY_USERS, SelectedPath);

        }

        FlushIoBuffer();

        CloseHandle(s_FileIo.hFile);

    }
    else
        g_FileErrorStringID = IDS_EXPFILEERRFILEOPEN;

    if (lpSelectedPath != NULL)
        RegCloseKey(hKey);

}


/*******************************************************************************
*
*  PutBranch
*
*  DESCRIPTION:
*     Writes out all of the value names and their data and recursively calls
*     this routine for all of the key's subkeys to the registry file stream.
*
*  PARAMETERS:
*     hKey, registry key to write to file.
*     lpFullKeyName, string that gives the full path, including the root key
*        name, of the hKey.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutBranch(
    HKEY hKey,
    LPTSTR lpFullKeyName
    )
{
    HKEY hSubKey;
    LONG RegError;
    DWORD EnumIndex;
    DWORD cchValueName;
    DWORD cbValueData;
    DWORD Type;
    LPTSTR lpSubKeyName;
    LPTSTR lpTempFullKeyName;
    BOOL bFlag = FALSE;
    int nLenTempFullKey;
    int nLenFullKey;    

    //
    //  Write out the section header.
    //

    PutChar(TEXT('['));
    PutLiteral(lpFullKeyName);
    PutLiteral(TEXT("]\n"));

    //
    //  Write out all of the value names and their data.
    //

    EnumIndex = 0;

    for (;;)
    {
        PBYTE pbValueData;
        cchValueName = ARRAYSIZE(g_ValueNameBuffer);

        // VALUE DATA
        // Query for data size
        RegError = RegEnumValue(hKey, EnumIndex++, g_ValueNameBuffer,
            &cchValueName, NULL, &Type, NULL, &cbValueData);

        if (RegError != ERROR_SUCCESS)
        {
            break;
        }

        // allocate memory for data
        g_FileErrorStringID = IDS_EXPFILEERRSUCCESS;
        pbValueData =  LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
        if (pbValueData)
        {
            if (RegQueryValueEx(hKey, g_ValueNameBuffer,
                NULL, &Type, pbValueData, &cbValueData) !=
                ERROR_SUCCESS)
            {
                g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
            }
            else
            {
                //
                //  If cbValueName is zero, then this is the default value of
                //  the key, or the Windows 3.1 compatible key value.
                //

                if (cchValueName)
                    PutString(g_ValueNameBuffer);

                else
                    PutChar(TEXT('@'));

                PutChar(TEXT('='));

                switch (Type)
                {

                case REG_SZ:
                    PutString((LPTSTR) pbValueData);
                    break;

                case REG_DWORD:
                    if (cbValueData == sizeof(DWORD))
                    {
                        PutLiteral(s_DwordPrefix);
                        PutDword(*((LPDWORD) pbValueData), TRUE);
                        break;
                    }
                    //  FALL THROUGH

                case REG_BINARY:
                default:
                    PutBinary((LPBYTE) pbValueData, Type, cbValueData);
                    break;

                }

                PutChar(TEXT('\n'));
            }
            LocalFree(pbValueData);
        }
        else
        {
            g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
        }

        if (g_FileErrorStringID == IDS_EXPFILEERRFILEWRITE)
            return;

        if ( g_FileErrorStringID == IDS_EXPFILEERRSUCCESS )
        {
            bFlag = TRUE;
        }
    }

    PutChar(TEXT('\n'));

    if (RegError != ERROR_NO_MORE_ITEMS)
        g_FileErrorStringID = IDS_EXPFILEERRREGENUM;

    if ( bFlag == TRUE )
    {
        g_dwTotalKeysSaved++;
    }

    //
    //  Write out all of the subkeys and recurse into them.
    //

    //copy the existing key into a new buffer with enough room for the next key
    nLenFullKey = lstrlen(lpFullKeyName);
    nLenTempFullKey = nLenFullKey + MAXKEYNAME;
    __try
    {
        lpTempFullKeyName = (LPTSTR) alloca(nLenTempFullKey * sizeof(TCHAR));
    }
    __except(GetExceptionCode() == STATUS_STACK_OVERFLOW)
    {
        _resetstkoflw();
        return;
    }

    StringCchCopy(lpTempFullKeyName, nLenTempFullKey, lpFullKeyName);
    lpSubKeyName = lpTempFullKeyName + nLenFullKey;
    *lpSubKeyName++ = TEXT('\\');
    *lpSubKeyName = 0;

    EnumIndex = 0;

    for(;;) 
    {
        if ((RegError = RegEnumKey(hKey, EnumIndex++, lpSubKeyName, MAXKEYNAME-1)) != ERROR_SUCCESS)
            break;

        if(RegOpenKeyEx(hKey,lpSubKeyName,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,&hSubKey) == ERROR_SUCCESS) 
        {
            // reset the previous error
            g_FileErrorStringID = IDS_EXPFILEERRSUCCESS;

			PutBranch(hSubKey, lpTempFullKeyName);

            RegCloseKey(hSubKey);

            if ( bFlag == FALSE && g_FileErrorStringID == IDS_EXPFILEERRSUCCESS )
            {
                g_dwTotalKeysSaved++;
                bFlag = TRUE;
            }

            if (g_FileErrorStringID == IDS_EXPFILEERRFILEWRITE)
                return;
        }

        else
            g_FileErrorStringID = IDS_EXPFILEERRREGOPEN;
    }

    if (RegError != ERROR_NO_MORE_ITEMS)
        g_FileErrorStringID = IDS_EXPFILEERRREGENUM;

}

/*******************************************************************************
*
*  PutLiteral
*
*  DESCRIPTION:
*     Writes a literal string to the registry file stream.  No special handling
*     is done for the string-- it is written out as is.
*
*  PARAMETERS:
*     lpLiteral, null-terminated literal to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutLiteral(
    LPCTSTR lpLiteral
    )
{

    while (*lpLiteral != 0)
        PutChar(*lpLiteral++);

}

/*******************************************************************************
*
*  PutString
*
*  DESCRIPTION:
*     Writes a string to the registry file stream.  A string is surrounded by
*     double quotes and some characters may be translated to escape sequences
*     to enable a parser to read the string back in.
*
*  PARAMETERS:
*     lpString, null-terminated string to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutString(
    LPCTSTR lpString
    )
{

    TCHAR Char;

    PutChar(TEXT('"'));

    while ((Char = *lpString++) != 0) {

        switch (Char) {

            case TEXT('\\'):
            case TEXT('"'):
                PutChar(TEXT('\\'));
                //  FALL THROUGH

            default:
                PutChar(Char);
                break;

        }

    }

    PutChar(TEXT('"'));

}

/*******************************************************************************
*
*  PutBinary
*
*  DESCRIPTION:
*     Writes a sequence of hexadecimal bytes to the registry file stream.  The
*     output is formatted such that it doesn't exceed a defined line length.
*
*  PARAMETERS:
*     lpBuffer, bytes to write to file.
*     Type, value data type.
*     cbBytes, number of bytes to write.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutBinary(
    CONST BYTE FAR* lpBuffer,
    DWORD Type,
    DWORD cbBytes
    )
{

    BOOL fFirstByteOnLine;
    BYTE Byte;

    // If we're writing one of the string formats that regedit doesn't write
    // natively (but rather converts to a string of hex digits for streaming
    // out), AND we're writing in downlevel/ANSI/REGEDIT4 format, we aren't
    // going to write out the high byte of each (internally Unicode) character.
    // So we will be writing half as many characters as the buffer byte size.

    // if ((g_RegEditData.uExportFormat == FILE_TYPE_REGEDIT4) &&
    //     ((Type == REG_EXPAND_SZ) || (Type == REG_MULTI_SZ))) {
    //     cbBytes = cbBytes / 2;
    // }

    PutLiteral(s_HexPrefix);

    if (Type != REG_BINARY) {

        PutChar(TEXT('('));
        PutDword(Type, FALSE);
        PutChar(TEXT(')'));

    }

    PutChar(TEXT(':'));

    fFirstByteOnLine = TRUE;

    while (cbBytes--) {

        if (s_FileIo.CurrentColumn > 75 && !fFirstByteOnLine) {

            PutLiteral(s_FileLineBreak);

            fFirstByteOnLine = TRUE;

        }

        if (!fFirstByteOnLine)
            PutChar(TEXT(','));

        Byte = *lpBuffer++;

        // If we're writing one of the string formats that regedit doesn't
        // write natively (REG_EXPAND_SZ and REG_MULTI_SZ values get converted
        // to a string of hex digits for streaming out), AND we're writing in
        // downlevel/ANSI/REGEDIT4 format, we don't want to write out the high
        // byte of each (internally Unicode) character.  So in those cases, we
        // advance another byte to get to the next ANSI character.  Yes, this
        // will lose data on non-SBCS characters, but that's what you get for
        // saving in the downlevel format.

        // if ((g_RegEditData.uExportFormat == FILE_TYPE_REGEDIT4) &&
        //     ((Type == REG_EXPAND_SZ) || (Type == REG_MULTI_SZ))) {
        //     lpBuffer++;
        // }

        PutChar(g_HexConversion[Byte >> 4]);
        PutChar(g_HexConversion[Byte & 0x0F]);

        fFirstByteOnLine = FALSE;

    }

}

/*******************************************************************************
*
*  PutChar
*
*  DESCRIPTION:
*     Writes a 32-bit word to the registry file stream.
*
*  PARAMETERS:
*     Dword, dword to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutDword(
    DWORD Dword,
    BOOL fLeadingZeroes
    )
{

    int CurrentNibble;
    TCHAR Char;
    BOOL fWroteNonleadingChar;

    fWroteNonleadingChar = fLeadingZeroes;

    for (CurrentNibble = 7; CurrentNibble >= 0; CurrentNibble--) {

        Char = g_HexConversion[(Dword >> (CurrentNibble * 4)) & 0x0F];

        if (fWroteNonleadingChar || Char != TEXT('0')) {

            PutChar(Char);
            fWroteNonleadingChar = TRUE;

        }

    }

    //
    //  We need to write at least one character, so if we haven't written
    //  anything yet, just spit out one zero.
    //

    if (!fWroteNonleadingChar)
        PutChar(TEXT('0'));

}

/*******************************************************************************
*
*  PutChar
*
*  DESCRIPTION:
*     Writes one character to the registry file stream using an intermediate
*     buffer.
*
*  PARAMETERS:
*     Char, character to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutChar(
    TCHAR Char
    )
{

    //
    //  Keep track of what column we're currently at.  This is useful in cases
    //  such as writing a large binary registry record.  Instead of writing one
    //  very long line, the other Put* routines can break up their output.
    //

    if (Char != TEXT('\n'))
        s_FileIo.CurrentColumn++;

    else {

        //
        //  Force a carriage-return, line-feed sequence to keep things like, oh,
        //  Notepad happy.
        //

        PutChar(TEXT('\r'));

        s_FileIo.CurrentColumn = 0;

    }

    s_FileIo.Buffer[s_FileIo.BufferOffset++] = Char;

    if (s_FileIo.BufferOffset == SIZE_FILE_IO_BUFFER)
        FlushIoBuffer();

}

/*******************************************************************************
*
*  FlushIoBuffer
*
*  DESCRIPTION:
*     Flushes the contents of the registry file stream to the disk and resets
*     the buffer pointer.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
FlushIoBuffer(
    VOID
    )
{

    DWORD NumberOfBytesWritten;

    if (s_FileIo.BufferOffset) 
    {
        // if (g_RegEditData.uExportFormat == FILE_TYPE_REGEDIT4)
        // {
        //     //
        //     // Convert Unicode to ANSI before writing.
        //     //
        // 
        //     int i;
        // 
        //     i = WideCharToMultiByte(
        //             CP_THREAD_ACP,
        //             0,
        //             s_FileIo.Buffer,
        //             s_FileIo.BufferOffset,
        //             s_FileIo.ConversionBuffer,
        //             sizeof(s_FileIo.ConversionBuffer),      // Number of bytes...
        //             NULL,
        //             NULL
        //             );
        // 
        //     if (!WRITEFILE(s_FileIo.hFile, s_FileIo.ConversionBuffer, i, &NumberOfBytesWritten) 
        //             ||  (DWORD) i != NumberOfBytesWritten)
        // 
        //         g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
        // }
        // else
        {
            //
            // Write Unicode text
            //
            if (!WRITEFILE(s_FileIo.hFile, s_FileIo.Buffer, s_FileIo.BufferOffset * sizeof(WCHAR), 
                            &NumberOfBytesWritten) 
                    || (DWORD) (s_FileIo.BufferOffset * sizeof(WCHAR)) != NumberOfBytesWritten)
            {
                g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
            }
        }
    }

    s_FileIo.BufferOffset = 0;

}

//  RegDeleteKeyRecursive
//  DESCRIPTION:
//     Adapted from \\kernel\razzle3,mvdm\wow32\wshell.c,WOWRegDeleteKey().
//     The Windows 95 implementation of RegDeleteKey recursively deletes all
//     the subkeys of the specified registry branch, but the NT implementation
//     only deletes leaf keys.


LONG RegDeleteKeyRecursive(HKEY hKey,
                           LPCTSTR lpszSubKey)
/*++
Routine Description:

    There is a significant difference between the Win3.1 and Win32
    behavior of RegDeleteKey when the key in question has subkeys.
    The Win32 API does not allow you to delete a key with subkeys,
    while the Win3.1 API deletes a key and all its subkeys.

    This routine is a recursive worker that enumerates the subkeys
    of a given key, applies itself to each one, then deletes itself.

    It specifically does not attempt to deal rationally with the
    case where the caller may not have access to some of the subkeys
    of the key to be deleted.  In this case, all the subkeys which
    the caller can delete will be deleted, but the api will still
    return ERROR_ACCESS_DENIED.

Arguments:
    hKey - Supplies a handle to an open registry key.
    lpszSubKey - Supplies the name of a subkey which is to be deleted
                 along with all of its subkeys.
Return Value:
    ERROR_SUCCESS - entire subtree successfully deleted.
    ERROR_ACCESS_DENIED - given subkey could not be deleted.
--*/
{
    DWORD i;
    HKEY Key;
    LONG Status;
    DWORD ClassLength=0;
    DWORD SubKeys;
    DWORD MaxSubKey;
    DWORD MaxClass;
    DWORD Values;
    DWORD MaxValueName;
    DWORD MaxValueData;
    DWORD SecurityLength;
    FILETIME LastWriteTime;
    LPTSTR NameBuffer;

    //
    // First open the given key so we can enumerate its subkeys
    //
    Status = RegOpenKeyEx(hKey,
                          lpszSubKey,
                          0,
                          KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                          &Key);
    if (Status != ERROR_SUCCESS)
    {
        //
        // possibly we have delete access, but not enumerate/query.
        // So go ahead and try the delete call, but don't worry about
        // any subkeys.  If we have any, the delete will fail anyway.
        //
        return(RegDeleteKey(hKey,lpszSubKey));
    }

    //
    // Use RegQueryInfoKey to determine how big to allocate the buffer
    // for the subkey names.
    //
    Status = RegQueryInfoKey(Key,
                             NULL,
                             &ClassLength,
                             0,
                             &SubKeys,
                             &MaxSubKey,
                             &MaxClass,
                             &Values,
                             &MaxValueName,
                             &MaxValueData,
                             &SecurityLength,
                             &LastWriteTime);
    if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_MORE_DATA) &&
        (Status != ERROR_INSUFFICIENT_BUFFER))
    {
        RegCloseKey(Key);
        return(Status);
    }

    NameBuffer = (LPTSTR) LocalAlloc(LPTR, (MaxSubKey + 1)*sizeof(TCHAR));
    if (NameBuffer == NULL)
    {
        RegCloseKey(Key);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate subkeys and apply ourselves to each one.
    //
    i=0;
    do
    {
        Status = RegEnumKey(Key,
                            i,
                            NameBuffer,
                            MaxSubKey+1);

        if (Status == ERROR_SUCCESS)
        {
            Status = RegDeleteKeyRecursive(Key,NameBuffer);
        }

        if (Status != ERROR_SUCCESS)
        {
            //
            // Failed to delete the key at the specified index.  Increment
            // the index and keep going.  We could probably bail out here,
            // since the api is going to fail, but we might as well keep
            // going and delete everything we can.
            //
            ++i;
        }

    } while ( (Status != ERROR_NO_MORE_ITEMS) &&
              (i < SubKeys) );

    LocalFree((HLOCAL) NameBuffer);
    RegCloseKey(Key);
    return(RegDeleteKey(hKey,lpszSubKey));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regdebug.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDEBUG.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Debug routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGDEBUG
#define _INC_REGDEBUG

#if DBG

VOID
CDECL
_DbgPrintf(
    PSTR pFormatString,
    ...
    );

#define DebugPrintf(x)                    _DbgPrintf ##x

#else       // DBG

#define DebugPrintf(x)

#endif      // DBG

#endif // _INC_REGDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regbined.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGBINED.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Binary edit dialog for use by the Registry Editor.
*
*  Hexadecimal editor control for use by the Registry Editor.  Little attempt
*  is made to make this a generic control-- only one instance is assumed to
*  ever exist.
*
*******************************************************************************/

#include "pch.h"
#include "regresid.h"
#include "reghelp.h"

//
//  Following structure and data are used to move the controls of the
//  EditBinaryValue dialog so that the HexEdit control fills up the appropriate
//  amount of space based on the system metrics.
//

typedef struct _MOVEWND {
    int ControlID;
    UINT SetWindowPosFlags;
}   MOVEWND;

const TCHAR s_HexEditClassName[] = HEXEDIT_CLASSNAME;

const TCHAR s_HexEditClipboardFormatName[] = TEXT("RegEdit_HexData");

const TCHAR s_HexWordFormatSpec[] = TEXT("%04X");
const TCHAR s_HexByteFormatSpec[] = TEXT("%02X");

const MOVEWND s_EditBinaryValueMoveWnd[] = {
    IDOK,           SWP_NOSIZE | SWP_NOZORDER,
    IDCANCEL,       SWP_NOSIZE | SWP_NOZORDER,
    IDC_VALUENAME,  SWP_NOMOVE | SWP_NOZORDER,
    IDC_VALUEDATA,  SWP_NOMOVE | SWP_NOZORDER
};

const DWORD s_EditBinaryValueHelpIDs[] = {
    IDC_VALUEDATA, IDH_REGEDIT_VALUEDATA,
    IDC_VALUENAME, IDH_REGEDIT_VALUENAME,
    0, 0
};


#define HEM_SETBUFFER                   (WM_USER + 1)

//  Number of bytes that are displayed per line.  NOTE:  Assumptions have been
//  made that this is power of two.
#define BYTES_PER_HEXEDIT_LINE          8
#define BYTES_PER_HEXEDIT_LINE_MASK     0x0007

//
//  This font is used by the HexEdit window for all output.  The lfHeight
//  member is calculated later based on the system configuration.
//

LOGFONT s_HexEditFont = {
    0,                                  //  lfHeight
    0,                                  //  lfWidth
    0,                                  //  lfEscapement
    0,                                  //  lfOrientation
    FW_NORMAL,                          //  lfWeight
    FALSE,                              //  lfItalic
    FALSE,                              //  lfUnderline
    FALSE,                              //  lfStrikeout
    ANSI_CHARSET,                       //  lfCharSet
    OUT_DEFAULT_PRECIS,                 //  lfOutPrecision
    CLIP_DEFAULT_PRECIS,                //  lfClipPrecision
    DEFAULT_QUALITY,                    //  lfQuality
    FIXED_PITCH | FF_DONTCARE,          //  lfPitchAndFamily
    TEXT("Courier")                     //  lfFaceName
};

//
//  Reference data for the HexEdit window.  Because we only ever expect one
//  instance of this class to exist, we can safely create one instance of this
//  structure now to avoid allocating and managing the structure later.
//

typedef struct _HEXEDITDATA {
    UINT Flags;
    PBYTE pBuffer;
    int cbBuffer;
    int cbBufferMax;
    int cxWindow;                       //  Width of the window
    int cyWindow;                       //  Height of the window
    HFONT hFont;                        //  Font being used for output
    LONG FontHeight;                    //  Height of the above font
    LONG FontMaxWidth;                  //  Maximum width of the above font
    int LinesVisible;                   //  Number of lines can be displayed
    int MaximumLines;                   //  Total number of lines
    int FirstVisibleLine;               //  Line number of top of display
    int xHexDumpStart;
    int xHexDumpByteWidth;
    int xAsciiDumpStart;
    int CaretIndex;
    int MinimumSelectedIndex;
    int MaximumSelectedIndex;
    int xPrevMessagePos;                //  Cursor point on last mouse message
    int yPrevMessagePos;                //  Cursor point on last mouse message
}   HEXEDITDATA;

//  Set if window has input focus, clear if not.
#define HEF_FOCUS                       0x00000001
#define HEF_NOFOCUS                     0x00000000
//  Set if dragging a range with mouse, clear if not.
#define HEF_DRAGGING                    0x00000002
#define HEF_NOTDRAGGING                 0x00000000
//  Set if editing ASCII column, clear if editing hexadecimal column.
#define HEF_CARETINASCIIDUMP            0x00000004
#define HEF_CARETINHEXDUMP              0x00000000
//
#define HEF_INSERTATLOWNIBBLE           0x00000008
#define HEF_INSERTATHIGHNIBBLE          0x00000000
//  Set if caret should be shown at the end of the previous line instead of at
//  the beginning of it's real caret line, clear if not.
#define HEF_CARETATENDOFLINE            0x00000010

HEXEDITDATA s_HexEditData;

typedef struct _HEXEDITCLIPBOARDDATA {
    DWORD cbSize;
    BYTE Data[1];
}   HEXEDITCLIPBOARDDATA, *LPHEXEDITCLIPBOARDDATA;

UINT s_HexEditClipboardFormat;

BOOL
PASCAL
EditBinaryValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    );

LRESULT
PASCAL
HexEditWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
PASCAL
HexEdit_OnNcCreate(
    HWND hWnd,
    LPCREATESTRUCT lpCreateStruct
    );

VOID
PASCAL
HexEdit_OnSize(
    HWND hWnd,
    UINT State,
    int cx,
    int cy
    );

VOID
PASCAL
HexEdit_SetScrollInfo(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnVScroll(
    HWND hWnd,
    HWND hCtlWnd,
    UINT Code,
    int Position
    );

VOID
PASCAL
HexEdit_OnPaint(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_PaintRect(
    HDC hDC,
    LPRECT lpUpdateRect
    );

VOID
PASCAL
HexEdit_OnSetFocus(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnKillFocus(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnLButtonDown(
    HWND hWnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT KeyFlags
    );

VOID
PASCAL
HexEdit_OnMouseMove(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    );

VOID
PASCAL
HexEdit_OnLButtonUp(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    );

int
PASCAL
HexEdit_HitTest(
    int x,
    int y
    );

VOID
PASCAL
HexEdit_OnKey(
    HWND hWnd,
    UINT VirtualKey,
    BOOL fDown,
    int cRepeat,
    UINT Flags
    );

VOID
PASCAL
HexEdit_OnChar(
    HWND hWnd,
    TCHAR Char,
    int cRepeat
    );

VOID
PASCAL
HexEdit_SetCaretPosition(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_EnsureCaretVisible(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_ChangeCaretIndex(
    HWND hWnd,
    int NewCaretIndex,
    BOOL fExtendSelection
    );

VOID
PASCAL
HexEdit_DeleteRange(
    HWND hWnd,
    UINT SourceKey
    );

BOOL
PASCAL
HexEdit_OnCopy(
    HWND hWnd
    );

BOOL
PASCAL
HexEdit_OnPaste(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnContextMenu(
    HWND hWnd,
    int x,
    int y
    );

/*******************************************************************************
*
*  EditBinaryValueDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
CALLBACK
EditBinaryValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    LPEDITVALUEPARAM lpEditValueParam;

    switch (Message) {

        HANDLE_MSG(hWnd, WM_INITDIALOG, EditBinaryValue_OnInitDialog);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            {
                case IDOK:
                case IDCANCEL:
                    lpEditValueParam = (LPEDITVALUEPARAM) GetWindowLongPtr(hWnd, DWLP_USER);
                    // Set these for both "ok" and "cancel", 
                    // lpEditValueParam->pValueData must again point to the
                    // current buffer so it can be returned and deleted
                    lpEditValueParam->cbValueData = s_HexEditData.cbBuffer;
                    lpEditValueParam->pValueData = s_HexEditData.pBuffer;
                    s_HexEditData.pBuffer = NULL;

                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

                default:
                    return FALSE;

            }
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) s_EditBinaryValueHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
                (DWORD) (ULONG_PTR) s_EditBinaryValueHelpIDs);
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  EditBinaryValue_OnInitDialog
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd,
*     hFocusWnd,
*     lParam,
*
*******************************************************************************/

BOOL
PASCAL
EditBinaryValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    )
{
    LPEDITVALUEPARAM lpEditValueParam;
    RECT Rect;
    int HexEditIdealWidth;
    int dxChange;
    HWND hControlWnd;
    UINT Counter;

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);
    lpEditValueParam = (LPEDITVALUEPARAM) lParam;

    SetDlgItemText(hWnd, IDC_VALUENAME, lpEditValueParam->pValueName);

    SendDlgItemMessage(hWnd, IDC_VALUEDATA, HEM_SETBUFFER, (WPARAM)
        lpEditValueParam->cbValueData, (LPARAM) lpEditValueParam->pValueData);

    //
    //  Figure out how big the "ideally" size HexEdit should be-- this means
    //  displaying the address, hex dump, ASCII dump, and potentially a scroll
    //  bar.
    //

    GetWindowRect(GetDlgItem(hWnd, IDC_VALUEDATA), &Rect);

    HexEditIdealWidth = s_HexEditData.xAsciiDumpStart +
        s_HexEditData.FontMaxWidth * (BYTES_PER_HEXEDIT_LINE + 1) +
        GetSystemMetrics(SM_CXVSCROLL) + GetSystemMetrics(SM_CXEDGE) * 2;

    dxChange = HexEditIdealWidth - (Rect.right - Rect.left);

    //
    //  Resize the dialog box.
    //

    GetWindowRect(hWnd, &Rect);

    MoveWindow(hWnd, Rect.left, Rect.top, Rect.right - Rect.left + dxChange,
        Rect.bottom - Rect.top, FALSE);

    //
    //  Resize or move the controls as necessary.
    //

    for (Counter = 0; Counter < (sizeof(s_EditBinaryValueMoveWnd) / sizeof(MOVEWND)); Counter++) 
    {
        hControlWnd = GetDlgItem(hWnd, s_EditBinaryValueMoveWnd[Counter].ControlID);

        GetWindowRect(hControlWnd, &Rect);

        if (s_EditBinaryValueMoveWnd[Counter].SetWindowPosFlags & SWP_NOSIZE) 
        {
            MapWindowPoints(NULL, hWnd, (LPPOINT) &Rect, 2);
            Rect.left += dxChange;
        }
        else
        {
            Rect.right += dxChange;
        }

        SetWindowPos(hControlWnd, NULL, Rect.left, Rect.top, Rect.right -
            Rect.left, Rect.bottom - Rect.top,
            s_EditBinaryValueMoveWnd[Counter].SetWindowPosFlags);
    }

    return TRUE;

    UNREFERENCED_PARAMETER(hFocusWnd);

}

/*******************************************************************************
*
*  RegisterHexEditClass
*
*  DESCRIPTION:
*     Register the HexEdit window class with the system.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

BOOL
PASCAL
RegisterHexEditClass(
    VOID
    )
{

    WNDCLASS WndClass;

    s_HexEditClipboardFormat = RegisterClipboardFormat(s_HexEditClipboardFormatName);

    WndClass.style = CS_DBLCLKS;
    WndClass.lpfnWndProc = HexEditWndProc;
    WndClass.cbClsExtra = 0;
    WndClass.cbWndExtra = 0;
    WndClass.hInstance = g_hInstance;
    WndClass.hIcon = NULL;
    WndClass.hCursor = LoadCursor(NULL, IDC_IBEAM);
    WndClass.hbrBackground = NULL;
    WndClass.lpszMenuName = NULL;
    WndClass.lpszClassName = s_HexEditClassName;

    return (RegisterClass(&WndClass) != 0);

}

/*******************************************************************************
*
*  HexEditWndProc
*
*  DESCRIPTION:
*     Callback procedure for the HexEdit window.
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

LRESULT
PASCAL
HexEditWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    switch (Message) 
    {

        HANDLE_MSG(hWnd, WM_NCCREATE, HexEdit_OnNcCreate);
        HANDLE_MSG(hWnd, WM_SIZE, HexEdit_OnSize);
        HANDLE_MSG(hWnd, WM_VSCROLL, HexEdit_OnVScroll);
        HANDLE_MSG(hWnd, WM_PAINT, HexEdit_OnPaint);
        HANDLE_MSG(hWnd, WM_LBUTTONDOWN, HexEdit_OnLButtonDown);
        HANDLE_MSG(hWnd, WM_LBUTTONDBLCLK, HexEdit_OnLButtonDown);
        HANDLE_MSG(hWnd, WM_MOUSEMOVE, HexEdit_OnMouseMove);
        HANDLE_MSG(hWnd, WM_LBUTTONUP, HexEdit_OnLButtonUp);
        HANDLE_MSG(hWnd, WM_KEYDOWN, HexEdit_OnKey);
        HANDLE_MSG(hWnd, WM_CHAR, HexEdit_OnChar);

        case WM_SETFOCUS:
            HexEdit_OnSetFocus(hWnd);
            break;

        case WM_KILLFOCUS:
            HexEdit_OnKillFocus(hWnd);
            break;

        case WM_TIMER:
            HexEdit_OnMouseMove(hWnd, s_HexEditData.xPrevMessagePos,
                s_HexEditData.yPrevMessagePos, 0);
            break;

        case WM_GETDLGCODE:
            return (LPARAM) (DLGC_WANTCHARS | DLGC_WANTARROWS);

        case WM_ERASEBKGND:
            return TRUE;

        case WM_NCDESTROY:
            DeleteObject(s_HexEditData.hFont);
            break;

        case WM_CONTEXTMENU:
            HexEdit_OnContextMenu(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        //  Message: HEM_SETBUFFER
        //  wParam:  Number of bytes in the buffer.
        //  lParam:  Pointer to the buffer.
        case HEM_SETBUFFER:
            s_HexEditData.pBuffer = (PBYTE) lParam;
            s_HexEditData.cbBuffer = (int) wParam;
            s_HexEditData.cbBufferMax = (int) wParam;

            s_HexEditData.CaretIndex = 0;
            s_HexEditData.MinimumSelectedIndex = 0;
            s_HexEditData.MaximumSelectedIndex = 0;

            s_HexEditData.FirstVisibleLine = 0;

            HexEdit_SetScrollInfo(hWnd);

            break;

        default:
            return DefWindowProc(hWnd, Message, wParam, lParam);

    }

    return 0;

}

/*******************************************************************************
*
*  HexEdit_OnNcCreate
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

BOOL
PASCAL
HexEdit_OnNcCreate(
    HWND hWnd,
    LPCREATESTRUCT lpCreateStruct
    )
{

    HDC hDC;
    HFONT hPrevFont;
    TEXTMETRIC TextMetric;

    s_HexEditData.cbBuffer = 0;

    //  FEATURE:  Do this symbolically...
    s_HexEditData.Flags = 0;

    s_HexEditData.cxWindow = 0;
    s_HexEditData.cyWindow = 0;

    hDC = GetDC(hWnd);

    s_HexEditFont.lfHeight = -(10 * GetDeviceCaps(hDC, LOGPIXELSY) / 72);

    if ((s_HexEditData.hFont = CreateFontIndirect(&s_HexEditFont)) != NULL) 
    {
        hPrevFont = SelectObject(hDC, s_HexEditData.hFont);
        GetTextMetrics(hDC, &TextMetric);
        SelectObject(hDC, hPrevFont);

        s_HexEditData.FontHeight = TextMetric.tmHeight;

        s_HexEditData.LinesVisible = s_HexEditData.cyWindow / s_HexEditData.FontHeight;

        s_HexEditData.FontMaxWidth = TextMetric.tmMaxCharWidth;

        s_HexEditData.xHexDumpByteWidth = s_HexEditData.FontMaxWidth * 3;
        s_HexEditData.xHexDumpStart = s_HexEditData.FontMaxWidth * 11 / 2;
        s_HexEditData.xAsciiDumpStart = s_HexEditData.xHexDumpStart +
            BYTES_PER_HEXEDIT_LINE * s_HexEditData.xHexDumpByteWidth +
            s_HexEditData.FontMaxWidth * 3 / 2;

    }

    ReleaseDC(hWnd, hDC);

    if (s_HexEditData.hFont == NULL)
        return FALSE;

    return (BOOL) DefWindowProc(hWnd, WM_NCCREATE, 0, (LPARAM) lpCreateStruct);

}

/*******************************************************************************
*
*  HexEdit_OnSize
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnSize(
    HWND hWnd,
    UINT State,
    int cx,
    int cy
    )
{
    s_HexEditData.cxWindow = cx;
    s_HexEditData.cyWindow = cy;

    s_HexEditData.LinesVisible = cy / s_HexEditData.FontHeight;

    HexEdit_SetScrollInfo(hWnd);

    UNREFERENCED_PARAMETER(State);
    UNREFERENCED_PARAMETER(cx);
}

/*******************************************************************************
*
*  HexEdit_SetScrollInfo
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_SetScrollInfo(
    HWND hWnd
    )
{
    SCROLLINFO ScrollInfo;

    s_HexEditData.MaximumLines = (s_HexEditData.cbBuffer +
        BYTES_PER_HEXEDIT_LINE) / BYTES_PER_HEXEDIT_LINE - 1;

    ScrollInfo.cbSize = sizeof(ScrollInfo);
    // DebugAssert(ScrollInfo.cbSize == sizeof(SCROLLINFO));
    ScrollInfo.fMask = (SIF_RANGE | SIF_PAGE | SIF_POS);
    ScrollInfo.nMin = 0;
    ScrollInfo.nMax = s_HexEditData.MaximumLines;
    ScrollInfo.nPage = s_HexEditData.LinesVisible;
    ScrollInfo.nPos = s_HexEditData.FirstVisibleLine;

    SetScrollInfo(hWnd, SB_VERT, &ScrollInfo, TRUE);
}

/*******************************************************************************
*
*  HexEdit_OnVScroll
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnVScroll(
    HWND hWnd,
    HWND hCtlWnd,
    UINT Code,
    int Position
    )
{

    int NewFirstVisibleLine;
    SCROLLINFO ScrollInfo;

    NewFirstVisibleLine = s_HexEditData.FirstVisibleLine;

    switch (Code) 
    {
        case SB_LINEUP:
            NewFirstVisibleLine--;
            break;

        case SB_LINEDOWN:
            NewFirstVisibleLine++;
            break;

        case SB_PAGEUP:
            NewFirstVisibleLine -= s_HexEditData.LinesVisible;
            break;

        case SB_PAGEDOWN:
            NewFirstVisibleLine += s_HexEditData.LinesVisible;
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            NewFirstVisibleLine = Position;
            break;
    }

    //
    //  Change the scroll bar position.  Note that SetScrollInfo will take into
    //  account the clipping between zero and the maximum value.  It will also
    //  return the final scroll bar position.
    //

    ScrollInfo.cbSize = sizeof(ScrollInfo);
    // DebugAssert(ScrollInfo.cbSize == sizeof(SCROLLINFO));
    ScrollInfo.fMask = SIF_POS;
    ScrollInfo.nPos = NewFirstVisibleLine;

    NewFirstVisibleLine = SetScrollInfo(hWnd, SB_VERT, &ScrollInfo, TRUE);

    if (s_HexEditData.FirstVisibleLine != NewFirstVisibleLine) 
    {
        ScrollWindowEx(hWnd, 0, (s_HexEditData.FirstVisibleLine -
            NewFirstVisibleLine) * s_HexEditData.FontHeight, NULL, NULL, NULL,
            NULL, SW_INVALIDATE);

        s_HexEditData.FirstVisibleLine = NewFirstVisibleLine;

        HexEdit_SetCaretPosition(hWnd);
    }

    UNREFERENCED_PARAMETER(hCtlWnd);

}

/*******************************************************************************
*
*  HexEdit_OnPaint
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnPaint(
    HWND hWnd
    )
{

    PAINTSTRUCT PaintStruct;

    BeginPaint(hWnd, &PaintStruct);

    HexEdit_PaintRect(PaintStruct.hdc, &PaintStruct.rcPaint);

    EndPaint(hWnd, &PaintStruct);

}

/*******************************************************************************
*
*  HexEdit_PaintRect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_PaintRect(
    HDC hDC,
    LPRECT lpUpdateRect
    )
{

    HFONT hPrevFont;
    int CurrentByteIndex;
    BYTE Byte;
    int CurrentLine;
    int LastLine;
    int BytesOnLastLine;
    int BytesOnLine;
    BOOL fUsingHighlight;
    int Counter;
    TCHAR Buffer[5];                     //  Room for four hex digits plus null
    RECT TextRect;
    RECT AsciiTextRect;
    int x;

    if (s_HexEditData.hFont)
        hPrevFont = SelectFont(hDC, s_HexEditData.hFont);

    SetBkColor(hDC, g_clrWindow);
    SetTextColor(hDC, g_clrWindowText);

    //
    //  Figure out the range of lines of the control that must be painted.
    //  Using this information we can compute the offset into the buffer to
    //  start reading from.
    //

    CurrentLine = lpUpdateRect-> top / s_HexEditData.FontHeight;

    TextRect.bottom = CurrentLine * s_HexEditData.FontHeight;
    AsciiTextRect.bottom = TextRect.bottom;

    CurrentByteIndex = (s_HexEditData.FirstVisibleLine + CurrentLine) *
        BYTES_PER_HEXEDIT_LINE;

    LastLine = lpUpdateRect-> bottom / s_HexEditData.FontHeight;

    //
    //  Figure out if there's enough in the buffer to fill up the entire window
    //  and the last line that we paint.
    //

    if (LastLine >= s_HexEditData.MaximumLines - s_HexEditData.FirstVisibleLine) 
    {

        LastLine = s_HexEditData.MaximumLines - s_HexEditData.FirstVisibleLine;

        BytesOnLastLine = s_HexEditData.cbBuffer % BYTES_PER_HEXEDIT_LINE;

    }
    else
        BytesOnLastLine = BYTES_PER_HEXEDIT_LINE;

    BytesOnLine = BYTES_PER_HEXEDIT_LINE;
    fUsingHighlight = FALSE;

    //
    //  Loop through each of the lines to be displayed.
    //

    while (CurrentLine <= LastLine) 
    {

        //
        //  If we're on the last line of the display and this is at the end
        //  of the buffer, we may not have a complete line to paint.
        //

        if (CurrentLine == LastLine)
            BytesOnLine = BytesOnLastLine;

        TextRect.top = TextRect.bottom;
        TextRect.bottom += s_HexEditData.FontHeight;

        TextRect.left = 0;
        TextRect.right = s_HexEditData.xHexDumpStart;

        x = TextRect.right + s_HexEditData.FontMaxWidth / 2;

        StringCchPrintf(Buffer, ARRAYSIZE(Buffer), s_HexWordFormatSpec, CurrentByteIndex);
        ExtTextOut(hDC, 0, TextRect.top, ETO_OPAQUE, &TextRect, Buffer, 4, NULL);

        AsciiTextRect.top = AsciiTextRect.bottom;
        AsciiTextRect.bottom += s_HexEditData.FontHeight;
        AsciiTextRect.right = s_HexEditData.xAsciiDumpStart;

        for (Counter = 0; Counter < BytesOnLine; Counter++, CurrentByteIndex++) 
        {
            //
            //  Determine what colors to use to paint the current byte.
            //

            if (CurrentByteIndex >= s_HexEditData.MinimumSelectedIndex) {

                if (CurrentByteIndex >= s_HexEditData.MaximumSelectedIndex) {

                    if (fUsingHighlight) {

                        fUsingHighlight = FALSE;

                        SetBkColor(hDC, g_clrWindow);
                        SetTextColor(hDC, g_clrWindowText);

                    }

                }

                else {

                    if (!fUsingHighlight) {

                        fUsingHighlight = TRUE;

                        SetBkColor(hDC, g_clrHighlight);
                        SetTextColor(hDC, g_clrHighlightText);

                    }

                }

            }

            Byte = s_HexEditData.pBuffer[CurrentByteIndex];

            //
            //  Paint the hexadecimal representation.
            //

            TextRect.left = TextRect.right;
            TextRect.right += s_HexEditData.xHexDumpByteWidth;

            StringCchPrintf(Buffer, ARRAYSIZE(Buffer), s_HexByteFormatSpec, Byte);

            ExtTextOut(hDC, x, TextRect.top, ETO_OPAQUE, &TextRect,
                Buffer, 2, NULL);

            x += s_HexEditData.xHexDumpByteWidth;

            //
            //  Paint the ASCII representation.
            //

            AsciiTextRect.left = AsciiTextRect.right;
            AsciiTextRect.right += s_HexEditData.FontMaxWidth;

            Buffer[0] = (TCHAR) (((Byte & 0x7F) >= TEXT(' ')) ? Byte : TEXT('.'));

            ExtTextOut(hDC, AsciiTextRect.left, AsciiTextRect.top, ETO_OPAQUE,
                &AsciiTextRect, Buffer, 1, NULL);

        }

        //
        //  Paint any leftover strips between the hexadecimal and ASCII columns
        //  and the ASCII column and the right edge of the window.
        //

        if (fUsingHighlight) {

            fUsingHighlight = FALSE;

            SetBkColor(hDC, g_clrWindow);
            SetTextColor(hDC, g_clrWindowText);

        }

        TextRect.left = TextRect.right;
        TextRect.right = s_HexEditData.xAsciiDumpStart;

        ExtTextOut(hDC, TextRect.left, TextRect.top, ETO_OPAQUE, &TextRect,
            NULL, 0, NULL);

        AsciiTextRect.left = AsciiTextRect.right;
        AsciiTextRect.right = s_HexEditData.cxWindow;

        ExtTextOut(hDC, AsciiTextRect.left, AsciiTextRect.top, ETO_OPAQUE,
            &AsciiTextRect, NULL, 0, NULL);

        CurrentLine++;

    }

    //
    //  Paint any remaining space in the control by filling it with the
    //  background color.
    //

    if (TextRect.bottom < lpUpdateRect-> bottom) 
    {
        TextRect.left = 0;
        TextRect.right = s_HexEditData.cxWindow;
        TextRect.top = TextRect.bottom;
        TextRect.bottom = lpUpdateRect-> bottom;

        ExtTextOut(hDC, 0, TextRect.top, ETO_OPAQUE, &TextRect, NULL, 0, NULL);
    }

    if (s_HexEditData.hFont)
        SelectFont(hDC, hPrevFont);

}

/*******************************************************************************
*
*  HexEdit_OnSetFocus
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnSetFocus(
    HWND hWnd
    )
{
    s_HexEditData.Flags |= HEF_FOCUS;

    CreateCaret(hWnd, NULL, 0, s_HexEditData.FontHeight);
    HexEdit_SetCaretPosition(hWnd);
    ShowCaret(hWnd);
}

/*******************************************************************************
*
*  HexEdit_OnKillFocus
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnKillFocus(
    HWND hWnd
    )
{

    if (s_HexEditData.Flags & HEF_FOCUS) {

        s_HexEditData.Flags &= ~HEF_FOCUS;

        DestroyCaret();

    }

}

/*******************************************************************************
*
*  HexEdit_OnLButtonDown
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     fDoubleClick, TRUE if this is a double-click message, else FALSE.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnLButtonDown(
    HWND hWnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT KeyFlags
    )
{

    int NewCaretIndex;

    if (fDoubleClick) {

        HexEdit_ChangeCaretIndex(hWnd, s_HexEditData.CaretIndex + 1, TRUE);
        return;

    }

    NewCaretIndex = HexEdit_HitTest(x, y);

    HexEdit_ChangeCaretIndex(hWnd, NewCaretIndex, (KeyFlags & MK_SHIFT));

    //
    //  If we don't already have the focus, try to get it.
    //

    if (!(s_HexEditData.Flags & HEF_FOCUS))
        SetFocus(hWnd);

    SetCapture(hWnd);
    s_HexEditData.Flags |= HEF_DRAGGING;

    s_HexEditData.xPrevMessagePos = x;
    s_HexEditData.yPrevMessagePos = y;

    SetTimer(hWnd, 1, 400, NULL);

    UNREFERENCED_PARAMETER(fDoubleClick);

}

/*******************************************************************************
*
*  HexEdit_OnMouseMove
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnMouseMove(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    )
{

    int NewCaretIndex;

    if (!(s_HexEditData.Flags & HEF_DRAGGING))
        return;

    NewCaretIndex = HexEdit_HitTest(x, y);

    HexEdit_ChangeCaretIndex(hWnd, NewCaretIndex, TRUE);

    s_HexEditData.xPrevMessagePos = x;
    s_HexEditData.yPrevMessagePos = y;

    {

    int i, j;

    i = y < 0 ? -y : y - s_HexEditData.cyWindow;
    j = 400 - ((UINT)i << 4);
    if (j < 100)
        j = 100;
    SetTimer(hWnd, 1, j, NULL);

    }

    UNREFERENCED_PARAMETER(KeyFlags);

}

/*******************************************************************************
*
*  HexEdit_OnLButtonUp
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnLButtonUp(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    )
{

    if (!(s_HexEditData.Flags & HEF_DRAGGING))
        return;

    KillTimer(hWnd, 1);

    ReleaseCapture();
    s_HexEditData.Flags &= ~HEF_DRAGGING;

    UNREFERENCED_PARAMETER(x);
    UNREFERENCED_PARAMETER(y);
    UNREFERENCED_PARAMETER(KeyFlags);

}

/*******************************************************************************
*
*  HexEdit_HitTest
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     (returns), index of "hit" byte.
*
*******************************************************************************/

int
PASCAL
HexEdit_HitTest(
    int x,
    int y
    )
{

    int HitLine;
    int BytesOnHitLine;
    int HitByte;

    //
    //  Figure out which line the user clicked on and how many bytes are on that
    //  line.
    //

    if (y < 0)
        HitLine = -1;

    else if (y >= s_HexEditData.cyWindow)
        HitLine = s_HexEditData.LinesVisible + 1;

    else
        HitLine = y / s_HexEditData.FontHeight;

    HitLine += s_HexEditData.FirstVisibleLine;

    if (HitLine >= s_HexEditData.MaximumLines) {

        HitLine = s_HexEditData.MaximumLines;

        BytesOnHitLine = (s_HexEditData.cbBuffer + 1) %
            BYTES_PER_HEXEDIT_LINE;

        if (BytesOnHitLine == 0)
            BytesOnHitLine = BYTES_PER_HEXEDIT_LINE;

    }

    else {

        if (HitLine < 0)
            HitLine = 0;

        BytesOnHitLine = BYTES_PER_HEXEDIT_LINE;

    }

    //
    //
    //

    if (x < s_HexEditData.xHexDumpStart)
        x = s_HexEditData.xHexDumpStart;

    if (x >= s_HexEditData.xHexDumpStart && x <
        s_HexEditData.xHexDumpStart + s_HexEditData.xHexDumpByteWidth *
        BYTES_PER_HEXEDIT_LINE + s_HexEditData.FontMaxWidth) {

        x -= s_HexEditData.xHexDumpStart;

        HitByte = x / s_HexEditData.xHexDumpByteWidth;

        s_HexEditData.Flags &= ~HEF_CARETINASCIIDUMP;

    }

    else {

        HitByte = (x - (s_HexEditData.xAsciiDumpStart -
            s_HexEditData.FontMaxWidth / 2)) / s_HexEditData.FontMaxWidth;

        s_HexEditData.Flags |= HEF_CARETINASCIIDUMP;

    }

    //
    //  We allow the user to "hit" the first byte of any line via two ways:
    //      *  clicking before the first byte on that line.
    //      *  clicking beyond the last byte/character of either display of the
    //         previous line.
    //
    //  We would like to see the latter case so that dragging in the control
    //  works naturally-- it's possible to drag to the end of the line to select
    //  the entire range.
    //

    s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;

    if (HitByte >= BytesOnHitLine) {

        if (BytesOnHitLine == BYTES_PER_HEXEDIT_LINE) {

            HitByte = BYTES_PER_HEXEDIT_LINE;
            s_HexEditData.Flags |= HEF_CARETATENDOFLINE;

        }

        else
            HitByte = BytesOnHitLine - 1;

    }

    return HitLine * BYTES_PER_HEXEDIT_LINE + HitByte;

}

/*******************************************************************************
*
*  HexEdit_OnKey
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     Char,
*     cRepeat,
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnKey(
    HWND hWnd,
    UINT VirtualKey,
    BOOL fDown,
    int cRepeat,
    UINT Flags
    )
{

    BOOL fControlDown;
    BOOL fShiftDown;
    int NewCaretIndex;
    UINT ScrollCode;

    fControlDown = (GetKeyState(VK_CONTROL) < 0);
    fShiftDown = (GetKeyState(VK_SHIFT) < 0);

    NewCaretIndex = s_HexEditData.CaretIndex;

    switch (VirtualKey) {

        case VK_UP:
            if (fControlDown)
                break;

            NewCaretIndex -= BYTES_PER_HEXEDIT_LINE;
            goto onkey_CheckLowerBound;

        case VK_DOWN:
            if (fControlDown)
                break;

            NewCaretIndex += BYTES_PER_HEXEDIT_LINE;

            if (NewCaretIndex / BYTES_PER_HEXEDIT_LINE >
                s_HexEditData.MaximumLines) {

                if (s_HexEditData.Flags & HEF_CARETATENDOFLINE)
                    goto onkey_MoveToEndOfBuffer;

                break;

            }

            goto onkey_CheckUpperBound;

        case VK_HOME:
            if (fControlDown)
                NewCaretIndex = 0;

            else {

                if (s_HexEditData.Flags & HEF_CARETATENDOFLINE)
                    NewCaretIndex -= BYTES_PER_HEXEDIT_LINE;

                else
                    NewCaretIndex &= (~BYTES_PER_HEXEDIT_LINE_MASK);

            }

            s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;

            goto onkey_ChangeCaretIndex;

        case VK_END:
            if (fControlDown) {

onkey_MoveToEndOfBuffer:
                s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;
                NewCaretIndex = s_HexEditData.cbBuffer;

            }

            else {

                if (s_HexEditData.Flags & HEF_CARETATENDOFLINE)
                    break;

                NewCaretIndex = (NewCaretIndex &
                    (~BYTES_PER_HEXEDIT_LINE_MASK)) + BYTES_PER_HEXEDIT_LINE;

                if (NewCaretIndex > s_HexEditData.cbBuffer)
                    NewCaretIndex = s_HexEditData.cbBuffer;

                else
                    s_HexEditData.Flags |= HEF_CARETATENDOFLINE;

            }

            goto onkey_ChangeCaretIndex;

        case VK_PRIOR:
        case VK_NEXT:
            NewCaretIndex -= s_HexEditData.FirstVisibleLine *
                BYTES_PER_HEXEDIT_LINE;

            ScrollCode = ((VirtualKey == VK_PRIOR) ? SB_PAGEUP : SB_PAGEDOWN);

            HexEdit_OnVScroll(hWnd, NULL, ScrollCode, 0);

            NewCaretIndex += s_HexEditData.FirstVisibleLine *
                BYTES_PER_HEXEDIT_LINE;

            if (VirtualKey == VK_PRIOR)
                goto onkey_CheckLowerBound;

            else
                goto onkey_CheckUpperBound;

        case VK_LEFT:
            s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;
            NewCaretIndex--;

onkey_CheckLowerBound:
            if (NewCaretIndex < 0)
                break;

            goto onkey_ChangeCaretIndex;

        case VK_RIGHT:
            s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;
            NewCaretIndex++;

onkey_CheckUpperBound:
            if (NewCaretIndex > s_HexEditData.cbBuffer)
                NewCaretIndex = s_HexEditData.cbBuffer;

onkey_ChangeCaretIndex:
            HexEdit_ChangeCaretIndex(hWnd, NewCaretIndex, fShiftDown);
            break;

        case VK_DELETE:
            if (!fControlDown) {

                if (fShiftDown)
                    HexEdit_OnChar(hWnd, IDKEY_CUT, 0);
                else
                    HexEdit_DeleteRange(hWnd, VK_DELETE);

            }
            break;

        case VK_INSERT:
            if (fShiftDown) {

                if (!fControlDown)
                    HexEdit_OnChar(hWnd, IDKEY_PASTE, 0);

            }

            else if (fControlDown)
                HexEdit_OnChar(hWnd, IDKEY_COPY, 0);
            break;

    }

}

/*******************************************************************************
*
*  HexEdit_OnChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     Char,
*     cRepeat,
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnChar(
    HWND hWnd,
    TCHAR Char,
    int cRepeat
    )
{

    PBYTE pCaretByte;
    BYTE NewCaretByte;
    int PrevCaretIndex;
    RECT UpdateRect;
    BOOL fSuccess = TRUE;

    //
    //  Check for any special control characters.
    //

    switch (Char) {

        case IDKEY_COPY:
            HexEdit_OnCopy(hWnd);
            return;

        case IDKEY_PASTE:
            PrevCaretIndex = s_HexEditData.CaretIndex;

            if (HexEdit_OnPaste(hWnd))
                goto UpdateDisplay;

            return;

        case IDKEY_CUT:
            if (!HexEdit_OnCopy(hWnd))
                return;
            //  FALL THROUGH

        case VK_BACK:
            HexEdit_DeleteRange(hWnd, VK_BACK);
            return;

    }

    //
    //  Validate and convert the typed character depending on the "column" the
    //  user is typing in.
    //

    if (s_HexEditData.Flags & HEF_CARETINASCIIDUMP) {

        if (Char < TEXT(' ')) {

            MessageBeep(MB_OK);
            return;

        }

        NewCaretByte = (BYTE) Char;

    }

    else {

        Char = (CHAR) CharLower((LPTSTR) Char);

        if (Char >= TEXT('0') && Char <= TEXT('9'))
            NewCaretByte = (BYTE) (Char - TEXT('0'));

        else if (Char >= TEXT('a') && Char <= TEXT('f'))
            NewCaretByte = (BYTE) (Char - TEXT('a') + 10);

        else {

            MessageBeep(MB_OK);
            return;

        }

    }

    if (!(s_HexEditData.Flags & HEF_INSERTATLOWNIBBLE)) {

        //
        //  Check to see if we're inserting while a range is selected.  If so,
        //  delete the range and insert at the start of the range.
        //

        if (s_HexEditData.MinimumSelectedIndex !=
            s_HexEditData.MaximumSelectedIndex)
            HexEdit_DeleteRange(hWnd, 0);

        //  Verify that we aren't overruning the value data buffer.
        if (s_HexEditData.cbBuffer >= s_HexEditData.cbBufferMax)
        {
            // need a bigger buffer
            PBYTE pbValueData = LocalReAlloc(s_HexEditData.pBuffer, 
                s_HexEditData.cbBuffer + ALLOCATION_INCR, LMEM_MOVEABLE);

            if (pbValueData)
            {
                s_HexEditData.pBuffer = pbValueData;
                s_HexEditData.cbBufferMax = s_HexEditData.cbBuffer + ALLOCATION_INCR;
            }
            else
            {
                InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_EDITVALNOMEMORY),
                    MAKEINTRESOURCE(IDS_EDITVALERRORTITLE), MB_ICONERROR | MB_OK, NULL);
                
                fSuccess = FALSE;
            }
        }

        if (fSuccess)
        {
            //
            //  Make room for the new byte by shifting all bytes after the insertion
            //  point down one byte.
            //

            pCaretByte = s_HexEditData.pBuffer + s_HexEditData.CaretIndex;

            MoveMemory(pCaretByte + 1, pCaretByte, s_HexEditData.cbBuffer - s_HexEditData.CaretIndex);

            s_HexEditData.cbBuffer++;

            HexEdit_SetScrollInfo(hWnd);

            if (s_HexEditData.Flags & HEF_CARETINASCIIDUMP)
                *pCaretByte = NewCaretByte;

            else {

                s_HexEditData.Flags |= HEF_INSERTATLOWNIBBLE;

                *pCaretByte = NewCaretByte << 4;

            }
        }

    }

    else {

        s_HexEditData.Flags &= ~HEF_INSERTATLOWNIBBLE;

        *(s_HexEditData.pBuffer + s_HexEditData.CaretIndex) |= NewCaretByte;

    }

    if (fSuccess)
    {

        PrevCaretIndex = s_HexEditData.CaretIndex;

        if (!(s_HexEditData.Flags & HEF_INSERTATLOWNIBBLE)) {

            s_HexEditData.CaretIndex++;

            s_HexEditData.MinimumSelectedIndex = s_HexEditData.CaretIndex;
            s_HexEditData.MaximumSelectedIndex = s_HexEditData.CaretIndex;

        }

UpdateDisplay:
        s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;
        HexEdit_EnsureCaretVisible(hWnd);

        UpdateRect.left = 0;
        UpdateRect.right = s_HexEditData.cxWindow;
        UpdateRect.top = (PrevCaretIndex / BYTES_PER_HEXEDIT_LINE -
            s_HexEditData.FirstVisibleLine) * s_HexEditData.FontHeight;
        UpdateRect.bottom = s_HexEditData.cyWindow;

        InvalidateRect(hWnd, &UpdateRect, FALSE);
    }
}

/*******************************************************************************
*
*  HexEdit_SetCaretPosition
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_SetCaretPosition(
    HWND hWnd
    )
{

    int CaretByte;
    int xCaret;
    int yCaret;

    CaretByte = s_HexEditData.CaretIndex % BYTES_PER_HEXEDIT_LINE;

    yCaret = (s_HexEditData.CaretIndex / BYTES_PER_HEXEDIT_LINE -
        s_HexEditData.FirstVisibleLine) * s_HexEditData.FontHeight;

    //
    //  Check if caret should really be displayed at the end of the previous
    //  line.
    //

    if (s_HexEditData.Flags & HEF_CARETATENDOFLINE) {

        CaretByte = BYTES_PER_HEXEDIT_LINE;
        yCaret -= s_HexEditData.FontHeight;

    }

    //
    //  Figure out which "column" the user is editing in and thus should have
    //  the caret.
    //

    if (s_HexEditData.Flags & HEF_CARETINASCIIDUMP) {

        xCaret = s_HexEditData.xAsciiDumpStart + CaretByte *
            s_HexEditData.FontMaxWidth;

    }

    else {

        xCaret = s_HexEditData.xHexDumpStart + CaretByte *
            s_HexEditData.xHexDumpByteWidth;

        if (s_HexEditData.Flags & HEF_INSERTATLOWNIBBLE)
            xCaret += s_HexEditData.FontMaxWidth * 3 / 2;

    }

    SetCaretPos(xCaret, yCaret);

}

/*******************************************************************************
*
*  HexEdit_EnsureCaretVisible
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_EnsureCaretVisible(
    HWND hWnd
    )
{

    int CaretLine;
    int LastVisibleLine;
    int Delta;

    if (!(s_HexEditData.Flags & HEF_FOCUS))
        return;

    CaretLine = s_HexEditData.CaretIndex / BYTES_PER_HEXEDIT_LINE;

    //
    //  Check if caret should really be displayed at the end of the previous
    //  line.
    //

    if (s_HexEditData.Flags & HEF_CARETATENDOFLINE)
        CaretLine--;

    LastVisibleLine = s_HexEditData.FirstVisibleLine +
        s_HexEditData.LinesVisible - 1;

    if (CaretLine > LastVisibleLine)
        Delta = LastVisibleLine;

    else if (CaretLine < s_HexEditData.FirstVisibleLine)
        Delta = s_HexEditData.FirstVisibleLine;

    else
        Delta = -1;

    if (Delta != -1) {

        ScrollWindowEx(hWnd, 0, (Delta - CaretLine) * s_HexEditData.FontHeight,
            NULL, NULL, NULL, NULL, SW_INVALIDATE);

        s_HexEditData.FirstVisibleLine += CaretLine - Delta;

        HexEdit_SetScrollInfo(hWnd);

    }

    HexEdit_SetCaretPosition(hWnd);

}

/*******************************************************************************
*
*  HexEdit_ChangeCaretIndex
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     NewCaretIndex,
*     fExtendSelection,
*
*******************************************************************************/

VOID
PASCAL
HexEdit_ChangeCaretIndex(
    HWND hWnd,
    int NewCaretIndex,
    BOOL fExtendSelection
    )
{

    int PrevMinimumSelectedIndex;
    int PrevMaximumSelectedIndex;
    int Swap;
    int UpdateRectCount;
    RECT UpdateRect[2];
    BOOL fPrevRangeEmpty;
    HDC hDC;
    int Index;

    s_HexEditData.Flags &= ~HEF_INSERTATLOWNIBBLE;

    PrevMinimumSelectedIndex = s_HexEditData.MinimumSelectedIndex;
    PrevMaximumSelectedIndex = s_HexEditData.MaximumSelectedIndex;

    if (fExtendSelection) {

        if (s_HexEditData.CaretIndex == s_HexEditData.MaximumSelectedIndex)
            s_HexEditData.MaximumSelectedIndex = NewCaretIndex;

        else
            s_HexEditData.MinimumSelectedIndex = NewCaretIndex;

        if (s_HexEditData.MinimumSelectedIndex >
            s_HexEditData.MaximumSelectedIndex) {

            Swap = s_HexEditData.MinimumSelectedIndex;
            s_HexEditData.MinimumSelectedIndex =
                s_HexEditData.MaximumSelectedIndex;
            s_HexEditData.MaximumSelectedIndex = Swap;

        }

    }

    else {

        s_HexEditData.MinimumSelectedIndex = NewCaretIndex;
        s_HexEditData.MaximumSelectedIndex = NewCaretIndex;

    }

    s_HexEditData.CaretIndex = NewCaretIndex;

    UpdateRectCount = 0;

    if (s_HexEditData.MinimumSelectedIndex > PrevMinimumSelectedIndex) {

        UpdateRect[0].top = PrevMinimumSelectedIndex;
        UpdateRect[0].bottom = s_HexEditData.MinimumSelectedIndex;

        UpdateRectCount++;

    }

    else if (s_HexEditData.MinimumSelectedIndex < PrevMinimumSelectedIndex) {

        UpdateRect[0].top = s_HexEditData.MinimumSelectedIndex;
        UpdateRect[0].bottom = PrevMinimumSelectedIndex;

        UpdateRectCount++;

    }

    if (s_HexEditData.MaximumSelectedIndex > PrevMaximumSelectedIndex) {

        UpdateRect[UpdateRectCount].top = PrevMaximumSelectedIndex;
        UpdateRect[UpdateRectCount].bottom = s_HexEditData.MaximumSelectedIndex;

        UpdateRectCount++;

    }

    else if (s_HexEditData.MaximumSelectedIndex < PrevMaximumSelectedIndex) {

        UpdateRect[UpdateRectCount].top = s_HexEditData.MaximumSelectedIndex;
        UpdateRect[UpdateRectCount].bottom = PrevMaximumSelectedIndex;

        UpdateRectCount++;

    }

    if (fPrevRangeEmpty = (PrevMinimumSelectedIndex ==
        PrevMaximumSelectedIndex)) {

        UpdateRect[0].top = s_HexEditData.MinimumSelectedIndex;
        UpdateRect[0].bottom = s_HexEditData.MaximumSelectedIndex;

        UpdateRectCount = 1;

    }

    if (s_HexEditData.MinimumSelectedIndex ==
        s_HexEditData.MaximumSelectedIndex) {

        if (!fPrevRangeEmpty) {

            UpdateRect[0].top = PrevMinimumSelectedIndex;
            UpdateRect[0].bottom = PrevMaximumSelectedIndex;

            UpdateRectCount = 1;

        }

        else
            UpdateRectCount = 0;

    }

    if (UpdateRectCount) {

        HideCaret(hWnd);

        hDC = GetDC(hWnd);

        for (Index = 0; Index < UpdateRectCount; Index++) {

            UpdateRect[Index].top = (UpdateRect[Index].top /
                BYTES_PER_HEXEDIT_LINE - s_HexEditData.FirstVisibleLine) *
                s_HexEditData.FontHeight;
            UpdateRect[Index].bottom = (UpdateRect[Index].bottom /
                BYTES_PER_HEXEDIT_LINE - s_HexEditData.FirstVisibleLine + 1) *
                s_HexEditData.FontHeight;

            if (UpdateRect[Index].top >= s_HexEditData.cyWindow ||
                UpdateRect[Index].bottom < 0)
                continue;

            if (UpdateRect[Index].top < 0)
                UpdateRect[Index].top = 0;

            if (UpdateRect[Index].bottom > s_HexEditData.cyWindow)
                UpdateRect[Index].bottom = s_HexEditData.cyWindow;

            HexEdit_PaintRect(hDC, &UpdateRect[Index]);

        }

        ReleaseDC(hWnd, hDC);

        ShowCaret(hWnd);

    }


    HexEdit_EnsureCaretVisible(hWnd);

}

/*******************************************************************************
*
*  HexEdit_DeleteRange
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_DeleteRange(
    HWND hWnd,
    UINT SourceKey
    )
{

    int MinimumSelectedIndex;
    int MaximumSelectedIndex;
    PBYTE pMinimumSelectedByte;
    int Length;
    RECT UpdateRect;

    s_HexEditData.Flags &= ~HEF_CARETATENDOFLINE;

    MinimumSelectedIndex = s_HexEditData.MinimumSelectedIndex;
    MaximumSelectedIndex = min(s_HexEditData.MaximumSelectedIndex, s_HexEditData.cbBuffer);


    //
    //  Check to see if a range is selected.  If not, then artificially create
    //  one based on the key that caused this routine to be called.
    //

    if (MinimumSelectedIndex == MaximumSelectedIndex) {

        if (SourceKey == VK_DELETE || s_HexEditData.Flags &
            HEF_INSERTATLOWNIBBLE) {

            s_HexEditData.Flags &= ~HEF_INSERTATLOWNIBBLE;

            MaximumSelectedIndex++;

            if (MaximumSelectedIndex > s_HexEditData.cbBuffer)
                return;

        }

        else if (SourceKey == VK_BACK) {

            MinimumSelectedIndex--;

            if (MinimumSelectedIndex < 0)
                return;

        }

        else
            return;

    }

    //
    //  Compute where to start deleting from and the number of bytes to delete.
    //

    pMinimumSelectedByte = s_HexEditData.pBuffer + MinimumSelectedIndex;

    Length = MaximumSelectedIndex - MinimumSelectedIndex;

    //
    //  Delete the bytes and update all appropriate window data.
    //

    MoveMemory(pMinimumSelectedByte, pMinimumSelectedByte + Length,
        s_HexEditData.cbBuffer - MaximumSelectedIndex);

    s_HexEditData.cbBuffer -= Length;

    s_HexEditData.CaretIndex = MinimumSelectedIndex;
    s_HexEditData.MinimumSelectedIndex = MinimumSelectedIndex;
    s_HexEditData.MaximumSelectedIndex = MinimumSelectedIndex;

    HexEdit_SetScrollInfo(hWnd);

    //  REARCHITECT:  OnChar has the following same sequence!!!
    HexEdit_EnsureCaretVisible(hWnd);

    UpdateRect.left = 0;
    UpdateRect.right = s_HexEditData.cxWindow;
    UpdateRect.top = (MinimumSelectedIndex / BYTES_PER_HEXEDIT_LINE -
        s_HexEditData.FirstVisibleLine) * s_HexEditData.FontHeight;
    UpdateRect.bottom = s_HexEditData.cyWindow;

    InvalidateRect(hWnd, &UpdateRect, FALSE);

}

/*******************************************************************************
*
*  HexEdit_OnCopy
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

BOOL
PASCAL
HexEdit_OnCopy(
    HWND hWnd
    )
{

    BOOL fSuccess;
    int cbClipboardData;
    LPBYTE lpStartByte;
    HANDLE hClipboardData;
    LPHEXEDITCLIPBOARDDATA lpClipboardData;

    fSuccess = FALSE;

    cbClipboardData = s_HexEditData.MaximumSelectedIndex - s_HexEditData.MinimumSelectedIndex;

    if (cbClipboardData != 0) {

        lpStartByte = s_HexEditData.pBuffer + s_HexEditData.MinimumSelectedIndex;

        if (OpenClipboard(hWnd)) 
        {
            if ((hClipboardData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                cbClipboardData + sizeof(HEXEDITCLIPBOARDDATA) - 1)) != NULL) 
            {
                lpClipboardData = (LPHEXEDITCLIPBOARDDATA) GlobalLock(hClipboardData);

                CopyMemory(lpClipboardData->Data, lpStartByte, cbClipboardData);
                lpClipboardData-> cbSize = cbClipboardData;

                GlobalUnlock(hClipboardData);

                EmptyClipboard();
                SetClipboardData(s_HexEditClipboardFormat, hClipboardData);

                fSuccess = TRUE;

            }

            CloseClipboard();

        }

    }

    return fSuccess;

}

/*******************************************************************************
*
*  HexEdit_OnPaste
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

BOOL
PASCAL
HexEdit_OnPaste(
    HWND hWnd
    )
{

    BOOL fSuccess = FALSE;
    HANDLE hClipboardData;
    PBYTE pCaretByte;

    if (s_HexEditData.Flags & HEF_INSERTATLOWNIBBLE) 
    {

        s_HexEditData.Flags &= ~HEF_INSERTATLOWNIBBLE;
        s_HexEditData.CaretIndex++;

    }

    if (OpenClipboard(hWnd)) 
    {
        if ((hClipboardData = GetClipboardData(s_HexEditClipboardFormat)) != NULL) 
        {
            LPHEXEDITCLIPBOARDDATA lpClipboardData = (LPHEXEDITCLIPBOARDDATA) GlobalLock(hClipboardData);

            if (lpClipboardData)
            {

                fSuccess = TRUE;
                if (s_HexEditData.cbBuffer + (int)lpClipboardData-> cbSize > s_HexEditData.cbBufferMax)
                {
                    // need a bigger buffer
                    PBYTE pbValueData = LocalReAlloc(s_HexEditData.pBuffer, 
                        s_HexEditData.cbBuffer + lpClipboardData-> cbSize, LMEM_MOVEABLE);

                    if (pbValueData)
                    { 
                        s_HexEditData.pBuffer = pbValueData;
                        s_HexEditData.cbBufferMax = s_HexEditData.cbBuffer + lpClipboardData-> cbSize;
                    }
                    else
                    {
                        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_EDITVALNOMEMORY),
                            MAKEINTRESOURCE(IDS_EDITVALERRORTITLE), MB_ICONERROR | MB_OK, NULL);

                        fSuccess = FALSE;
                    }
                }

                if (fSuccess) 
                {
                    DWORD cbSize;

                    if (s_HexEditData.MinimumSelectedIndex !=
                        s_HexEditData.MaximumSelectedIndex)
                        HexEdit_DeleteRange(hWnd, VK_BACK);

                    //
                    //  Make room for the new bytes by shifting all bytes after the
                    //  the insertion point down the necessary amount.
                    //

                    pCaretByte = s_HexEditData.pBuffer + s_HexEditData.CaretIndex;
                    cbSize = lpClipboardData->cbSize;

                    MoveMemory(pCaretByte + cbSize, pCaretByte,
                        s_HexEditData.cbBuffer - s_HexEditData.CaretIndex);
                    CopyMemory(pCaretByte, lpClipboardData-> Data, cbSize);

                    s_HexEditData.cbBuffer += cbSize;
                    s_HexEditData.CaretIndex += cbSize;

                    HexEdit_SetScrollInfo(hWnd);
                }
            }

            GlobalUnlock(hClipboardData);

        }

        CloseClipboard();
    }

    return fSuccess;

}

/*******************************************************************************
*
*  HexEdit_OnContextMenu
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     x, horizontal position of the cursor.
*     y, vertical position of the cursor.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnContextMenu(
    HWND hWnd,
    int x,
    int y
    )
{

    HMENU hContextMenu;
    HMENU hContextPopupMenu;
    int MenuCommand;

    //
    //  Give us the focus if we don't already have it.
    //

    if (!(s_HexEditData.Flags & HEF_FOCUS))
        SetFocus(hWnd);

    //
    //  Load the HexEdit context menu from our resources.
    //

    if ((hContextMenu = LoadMenu(g_hInstance,
        MAKEINTRESOURCE(IDM_HEXEDIT_CONTEXT))) == NULL)
        return;

    hContextPopupMenu = GetSubMenu(hContextMenu, 0);

    //
    //  Disable editing menu options as appropriate.
    //

    if (s_HexEditData.MinimumSelectedIndex ==
        s_HexEditData.MaximumSelectedIndex) {

        EnableMenuItem(hContextPopupMenu, IDKEY_COPY, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hContextPopupMenu, IDKEY_CUT, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hContextPopupMenu, VK_DELETE, MF_BYCOMMAND | MF_GRAYED);

    }

    if (!IsClipboardFormatAvailable(s_HexEditClipboardFormat))
        EnableMenuItem(hContextPopupMenu, IDKEY_PASTE, MF_BYCOMMAND |
            MF_GRAYED);

    if (s_HexEditData.MinimumSelectedIndex == 0 &&
        s_HexEditData.MaximumSelectedIndex == s_HexEditData.cbBuffer)
        EnableMenuItem(hContextPopupMenu, ID_SELECTALL, MF_BYCOMMAND |
            MF_GRAYED);

    //
    //  Display and handle the selected command.
    //

    MenuCommand = TrackPopupMenuEx(hContextPopupMenu, TPM_RETURNCMD |
        TPM_RIGHTBUTTON | TPM_LEFTALIGN | TPM_TOPALIGN, x, y, hWnd, NULL);

    DestroyMenu(hContextMenu);

    switch (MenuCommand) {

        case IDKEY_COPY:
        case IDKEY_PASTE:
        case IDKEY_CUT:
        case VK_DELETE:
            HexEdit_OnChar(hWnd, (TCHAR) MenuCommand, 0);
            break;

        case ID_SELECTALL:
            s_HexEditData.MinimumSelectedIndex = 0;
            s_HexEditData.MaximumSelectedIndex = s_HexEditData.cbBuffer;
            s_HexEditData.CaretIndex = s_HexEditData.cbBuffer;
            HexEdit_SetCaretPosition(hWnd);
            InvalidateRect(hWnd, NULL, FALSE);
            break;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regdef.h ===
/* Do not include this before Windows.h */

/* ASM
; DO NOT INCLUDE THIS BEFORE WINDOWS.INC
*/

#define Dereference(x)  x=x;

/*XLATOFF*/
#pragma warning (disable:4209)      // turn off redefinition warning (with vmm.h)
/*XLATON*/

#ifndef _WINREG_
//  WINREG.H uses DECLARE_HANDLE(HKEY) giving incompatible types.
typedef DWORD       HKEY;
#endif

/*XLATOFF*/
#pragma warning (default:4209)      // turn on redefinition warning (with vmm.h)
/*XLATON*/

#define MAXKEYNAME      256
        // Max length of a key name string
#define MAXVALUENAME_LENGTH MAXKEYNAME
        // Max length of a value name string

//  When we need to increase the buffer to add one character, increase it by
//  (1/4)K so that we won't have to repeatly allocate for every new key stroke.
#define ALLOCATION_INCR                 256

// These file types are in the same order as the filer list in regedit.rc
// The list must start at 1
#define FILE_TYPE_REGEDIT5  1
#define FILE_TYPE_REGEDT32  2
#define FILE_TYPE_TEXT      3
#define FILE_TYPE_REGEDIT4  4

#ifndef REG_SZ
#define REG_SZ      0x0001
#endif

#ifndef REG_BINARY
#define REG_BINARY  0x0003
#endif

#ifndef REG_DWORD
#define REG_DWORD       0x0004
#endif

#ifndef FALSE
#define FALSE   0
#endif
#ifndef TRUE
#define TRUE    ~FALSE
#endif

/* following equates are also defined in Windows.h. To avoid warnings
 *  we should make these equates  conditional
 */


#ifndef ERROR_SUCCESS           
#define ERROR_SUCCESS           0L
#endif

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND        2L
#endif

#ifndef ERROR_ACCESS_DENIED
#define ERROR_ACCESS_DENIED              5L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY             1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY          14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER        87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS       259L
#endif  

// INTERNAL

#ifndef ERROR_CANTOPEN16_FILENOTFOUND32
#define ERROR_CANTOPEN16_FILENOTFOUND32 0xffff0000
#define ERROR_CANTREAD16_FILENOTFOUND32 0xffff0001
#endif

#ifndef HKEY_CLASSES_ROOT
#define HKEY_CLASSES_ROOT          ((HKEY)0x80000000)
#endif

#ifndef HKEY_CURRENT_USER
#define HKEY_CURRENT_USER              ((HKEY)0x80000001)
#endif

#ifndef HKEY_LOCAL_MACHINE
#define HKEY_LOCAL_MACHINE             ((HKEY)0x80000002)
#endif

#ifndef HKEY_USERS
#define HKEY_USERS                     ((HKEY)0x80000003)
#endif

#ifndef HKEY_PERFORMANCE_DATA
#define HKEY_PERFORMANCE_DATA          ((HKEY)0x80000004)
#endif

#ifndef HKEY_CURRENT_CONFIG
#define HKEY_CURRENT_CONFIG            ((HKEY)0x80000005)
#endif

#ifndef HKEY_DYN_DATA
#define HKEY_DYN_DATA                  ((HKEY)0x80000006)
#endif

// INTERNAL

#ifndef HKEY_PREDEF_KEYS
#define HKEY_PREDEF_KEYS    7
#endif

#define MAXREGFILES     HKEY_PREDEF_KEYS    

// sub function indices for Registry services in VMM for 16 bit callers

#define RegOpenKey_Idx      0x100
#define RegCreateKey_Idx    0x101
#define RegCloseKey_Idx     0x102
#define RegDeleteKey_Idx    0x103
#define RegSetValue_Idx     0x104
#define RegQueryValue_Idx   0x105
#define RegEnumKey_Idx      0x106
#define RegDeleteValue_Idx  0x107
#define RegEnumValue_Idx    0x108
#define RegQueryValueEx_Idx 0x109
#define RegSetValueEx_Idx   0x10A
#define RegFlushKey_Idx     0x10B
#define RegLoadKey_Idx      0x10C
#define RegUnLoadKey_Idx    0x10D
#define RegSaveKey_Idx      0x10E
#define RegRestore_Idx      0x10F
#define RegRemapPreDefKey_Idx   0x110

// Data structure passed to SYSDM.CPL DMRegistryError function
//  After UI, the function is to call
//  RegRestore(DWORD iLevel, LPREGQRSTR lpRgRstr)
//

struct Reg_Query_Restore_s {
DWORD   dwRQR_Err;      // Error code
DWORD   hRQR_RootKey;       // Root key for file
DWORD   dwRQR_Reference;    // Reference data for RegRestore
TCHAR   szRQR_SubKey[MAXKEYNAME]; // Subkey (for hives) or NULL string
TCHAR   szRQR_FileName[MAX_PATH]; // File name of bad file
};
typedef struct Reg_Query_Restore_s REGQRSTR;
typedef REGQRSTR FAR * LPREGQRSTR;


// END INTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regcdhk.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGCDHK.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  Common dialog box hook functions for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"
#include "regkey.h"
#include "regcdhk.h"
#include "regresid.h"
#include "reghelp.h"

//  Buffer to store the starting path for a registry export or print operation.
TCHAR g_SelectedPath[SIZE_SELECTED_PATH];

//  TRUE if registry operation should be applied to the entire registry or to
//  only start at g_SelectedPath.
BOOL g_fRangeAll;

//  Contains the resource identifier for the dialog that is currently being
//  used.  Assumes that there is only one instance of a hook dialog at a time.
UINT g_RegCommDlgDialogTemplate;

const DWORD s_RegCommDlgExportHelpIDs[] = {
    stc32,                 NO_HELP,
    IDC_EXPORTRANGE,       IDH_REGEDIT_EXPORT,
    IDC_RANGEALL,          IDH_REGEDIT_EXPORT,
    IDC_RANGESELECTEDPATH, IDH_REGEDIT_EXPORT,
    IDC_SELECTEDPATH,      IDH_REGEDIT_EXPORT,

    0, 0
};

const DWORD s_RegCommDlgPrintHelpIDs[] = {
    IDC_EXPORTRANGE,       IDH_REGEDIT_PRINTRANGE,
    IDC_RANGEALL,          IDH_REGEDIT_PRINTRANGE,
    IDC_RANGESELECTEDPATH, IDH_REGEDIT_PRINTRANGE,
    IDC_SELECTEDPATH,      IDH_REGEDIT_PRINTRANGE,

    0, 0
};

BOOL
PASCAL
RegCommDlg_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    );

LRESULT
PASCAL
RegCommDlg_OnNotify(
    HWND hWnd,
    int DlgItem,
    LPNMHDR lpNMHdr
    );

UINT_PTR
PASCAL
RegCommDlg_OnCommand(
    HWND hWnd,
    int DlgItem,
    UINT NotificationCode
    );

BOOL
PASCAL
RegCommDlg_ValidateSelectedPath(
    HWND hWnd,
    BOOL fIsFileDialog
    );

/*******************************************************************************
*
*  RegCommDlgHookProc
*
*  DESCRIPTION:
*     Callback procedure for the RegCommDlg common dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegCommDlg window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

UINT_PTR
CALLBACK
RegCommDlgHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    int DlgItem;
    const DWORD FAR* lpHelpIDs;

    switch (Message) {

        HANDLE_MSG(hWnd, WM_INITDIALOG, RegCommDlg_OnInitDialog);

        case WM_NOTIFY:
            SetDlgMsgResult(hWnd, WM_NOTIFY, HANDLE_WM_NOTIFY(hWnd, wParam,
                lParam, RegCommDlg_OnNotify));
            return TRUE;

        case WM_COMMAND:
            return RegCommDlg_OnCommand(hWnd, GET_WM_COMMAND_ID(wParam, lParam),
                GET_WM_COMMAND_CMD(wParam, lParam));

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            DlgItem = GetDlgCtrlID(((LPHELPINFO) lParam)-> hItemHandle);

            if (DlgItem < IDC_FIRSTREGCOMMDLGID || DlgItem >
                IDC_LASTREGCOMMDLGID)
                break;

            lpHelpIDs = (g_RegCommDlgDialogTemplate == IDD_REGEXPORT) ?
                s_RegCommDlgExportHelpIDs : s_RegCommDlgPrintHelpIDs;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) lpHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            DlgItem = GetDlgCtrlID((HWND) wParam);

            if (g_RegCommDlgDialogTemplate == IDD_REGEXPORT)
                lpHelpIDs = s_RegCommDlgExportHelpIDs;

            else {

                if (DlgItem < IDC_FIRSTREGCOMMDLGID || DlgItem >
                    IDC_LASTREGCOMMDLGID)
                    break;

                lpHelpIDs = s_RegCommDlgPrintHelpIDs;

            }

            WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU, (ULONG_PTR) lpHelpIDs);
            return TRUE;

    }

    return FALSE;

}

/*******************************************************************************
*
*  RegCommDlg_OnInitDialog
*
*  DESCRIPTION:
*     Initializes the RegCommDlg dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegCommDlg window.
*     hFocusWnd, handle of control to receive the default keyboard focus.
*     lParam, additional initialization data passed by dialog creation function.
*     (returns), TRUE to set focus to hFocusWnd, else FALSE to prevent a
*        keyboard focus from being set.
*
*******************************************************************************/

BOOL
PASCAL
RegCommDlg_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    )
{

    HWND hKeyTreeWnd;
    HTREEITEM hSelectedTreeItem;
    int DlgItem;

    g_RegEditData.uExportFormat = FILE_TYPE_REGEDIT5;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
    hSelectedTreeItem = TreeView_GetSelection(hKeyTreeWnd);

    KeyTree_BuildKeyPath( hKeyTreeWnd, 
                            hSelectedTreeItem, 
                            g_SelectedPath, 
                            ARRAYSIZE(g_SelectedPath),
                            BKP_TOSYMBOLICROOT);

    SetDlgItemText(hWnd, IDC_SELECTEDPATH, g_SelectedPath);

    DlgItem = (TreeView_GetParent(hKeyTreeWnd, hSelectedTreeItem) == NULL) ?
        IDC_RANGEALL : IDC_RANGESELECTEDPATH;
    CheckRadioButton(hWnd, IDC_RANGEALL, IDC_RANGESELECTEDPATH, DlgItem);

    return TRUE;

    UNREFERENCED_PARAMETER(hFocusWnd);
    UNREFERENCED_PARAMETER(lParam);

}

/*******************************************************************************
*
*  RegCommDlg_OnNotify
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegCommDlg window.
*     DlgItem, identifier of control.
*     lpNMHdr, control notification data.
*
*******************************************************************************/

LRESULT
PASCAL
RegCommDlg_OnNotify(
    HWND hWnd,
    int DlgItem,
    LPNMHDR lpNMHdr
    )
{

    HWND hControlWnd;
    RECT DialogRect;
    RECT ControlRect;
    int dxChange;
    LPOFNOTIFY lpon;

    switch (lpNMHdr-> code) {

        case CDN_INITDONE:
            GetWindowRect(hWnd, &DialogRect);
            // Use window coordinates because it works for mirrored 
            // and non mirrored windows.
            MapWindowPoints(NULL, hWnd, (LPPOINT)&DialogRect, 2);

            hControlWnd = GetDlgItem(hWnd, IDC_EXPORTRANGE);
            GetWindowRect(hControlWnd, &ControlRect);
            MapWindowPoints(NULL, hWnd, (LPPOINT)&ControlRect, 2);

            dxChange = DialogRect.right - ControlRect.right -
                (ControlRect.left - DialogRect.left);

            SetWindowPos(hControlWnd, NULL, 0, 0, ControlRect.right -
                ControlRect.left + dxChange, ControlRect.bottom -
                ControlRect.top, SWP_NOMOVE | SWP_NOZORDER);

            hControlWnd = GetDlgItem(hWnd, IDC_SELECTEDPATH);
            GetWindowRect(hControlWnd, &ControlRect);
            MapWindowPoints(NULL, hWnd, (LPPOINT)&ControlRect, 2);

            SetWindowPos(hControlWnd, NULL, 0, 0, ControlRect.right -
                ControlRect.left + dxChange, ControlRect.bottom -
                ControlRect.top, SWP_NOMOVE | SWP_NOZORDER);

            break;

        case CDN_TYPECHANGE:
            // lpon->lpOFN->nFilterIndex corresponds to the format types in 
            // regdef.h
            lpon = (LPOFNOTIFY) lpNMHdr;
            g_RegEditData.uExportFormat = lpon->lpOFN->nFilterIndex;
            break;

        case CDN_FILEOK:
            return ( RegCommDlg_ValidateSelectedPath(hWnd, TRUE) != FALSE );

    }

    return FALSE;

}

/*******************************************************************************
*
*  RegCommDlg_OnCommand
*
*  DESCRIPTION:
*     Handles the selection of a menu item by the user, notification messages
*     from a child control, or translated accelerated keystrokes for the
*     RegPrint dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegCommDlg window.
*     DlgItem, identifier of control.
*     NotificationCode, notification code from control.
*
*******************************************************************************/

UINT_PTR
PASCAL
RegCommDlg_OnCommand(
    HWND hWnd,
    int DlgItem,
    UINT NotificationCode
    )
{

    switch (DlgItem) {

        case IDC_RANGESELECTEDPATH:
            SetFocus(GetDlgItem(hWnd, IDC_SELECTEDPATH));
            break;

        case IDC_SELECTEDPATH:
            switch (NotificationCode) {

                case EN_SETFOCUS:
                    SendDlgItemMessage(hWnd, IDC_SELECTEDPATH, EM_SETSEL,
                        0, -1);
                    break;

                case EN_CHANGE:
                    CheckRadioButton(hWnd, IDC_RANGEALL, IDC_RANGESELECTEDPATH,
                        IDC_RANGESELECTEDPATH);
                    break;

            }
            break;

        case IDOK:
            return ( RegCommDlg_ValidateSelectedPath(hWnd, FALSE) != FALSE );

    }

    return FALSE;

}

/*******************************************************************************
*
*  RegCommDlg_ValidateSelectedPath
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegCommDlg window.
*     (returns), TRUE if the registry selected path is invalid, else FALSE.
*
*******************************************************************************/

BOOL
PASCAL
RegCommDlg_ValidateSelectedPath(
    HWND hWnd,
    BOOL fIsFileDialog
    )
{

    HKEY hKey;
    HWND hTitleWnd;
    TCHAR Title[256];

    if (!(g_fRangeAll = IsDlgButtonChecked(hWnd, IDC_RANGEALL))) {

        GetDlgItemText(hWnd, IDC_SELECTEDPATH, g_SelectedPath, ARRAYSIZE(g_SelectedPath));

        if (g_SelectedPath[0] == '\0')
            g_fRangeAll = TRUE;

        else 
        {
            HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
            if (EditRegistryKey(RegEdit_GetComputerItem(hSelectedTreeItem), &hKey, g_SelectedPath, ERK_OPEN) !=
                ERROR_SUCCESS) 
            {

                //
                //  Determine the "real" parent of this dialog and get the
                //  message box title from that window.  Our HWND may really
                //  be a subdialog if we're a file dialog.
                //

                hTitleWnd = fIsFileDialog ? GetParent(hWnd) : hWnd;
                GetWindowText(hTitleWnd, Title, ARRAYSIZE(Title));
                InternalMessageBox(g_hInstance, hTitleWnd,
                    MAKEINTRESOURCE(IDS_ERRINVALIDREGPATH), Title,
                    MB_ICONERROR | MB_OK);

                return TRUE;

            }

            RegCloseKey(hKey);

        }

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regbined.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGBINED.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Binary edit dialog for use by the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGBINED
#define _INC_REGBINED

INT_PTR
CALLBACK
EditBinaryValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
PASCAL
RegisterHexEditClass(
    VOID
    );

#endif // _INC_REGBINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regdebug.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDEBUG.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  Debug routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  21 Nov 1993 TCS Original implementation.
*
*******************************************************************************/

#include "pch.h"

#if DBG

#define SIZE_DEBUG_BUFFER               100

/*******************************************************************************
*
*  _DbgPrintf
*
*  DESCRIPTION:
*     Simple implementation of the "debug printf" routine.  Takes the given
*     format string and argument list and outputs the formatted string to the
*     debugger.  Only available in debug builds-- use the DbgPrintf macro
*     defined in REGEDIT.H to access this service or to ignore the printf.
*
*  PARAMETERS:
*     lpFormatString, printf-style format string.
*     ..., variable argument list.
*
*******************************************************************************/

VOID
CDECL
_DbgPrintf(
    PSTR pFormatString,
    ...
    )
{

    va_list arglist;
    CHAR DebugBuffer[SIZE_DEBUG_BUFFER];

    va_start(arglist, pFormatString);

    StringCchVPrintfA(DebugBuffer, ARRAYSIZE(DebugBuffer), pFormatString, arglist);

    OutputDebugStringA(DebugBuffer);
//    MessageBoxA(NULL, DebugBuffer, "RegEdit", MB_OK);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regcdhk.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGCDHK.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Common dialog box hook functions for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGCDHK
#define _INC_REGCDHK

//  Buffer to store the starting path for a registry export or print operation.
extern TCHAR g_SelectedPath[SIZE_SELECTED_PATH];

//  TRUE if registry operation should be applied to the entire registry or to
//  only start at g_SelectedPath.
extern BOOL g_fRangeAll;

//  Contains the resource identifier for the dialog that is currently being
//  used.  Assumes that there is only one instance of a hook dialog at a time.
extern UINT g_RegCommDlgDialogTemplate;

UINT_PTR
CALLBACK
RegCommDlgHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

#endif // _INC_REGCDHK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regdrag.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDRAG.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Drag and drop routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"

typedef struct _REGDRAGDRATA {
    POINT DragRectPoint;
    POINT HotSpotPoint;
    HWND hLockWnd;
    PRECT pDragRectArray;
    int DragRectCount;
}   REGDRAGDATA;

REGDRAGDATA s_RegDragData;

VOID
PASCAL
DrawDragRects(
    VOID
    );

/*******************************************************************************
*
*  RegEdit_DragObjects
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     hSourceWnd, handle of window initiating the drag.
*     hDragImageList, image used during drag operation, assumed to be at image
*        index 0.  May be NULL if pDragRectArray is valid.
*     pDragRectArray, array of rectangles to draw during drag operation.  May
*        be NULL if hDragImageList is valid.
*     DragRectCount, number of rectangles pointed to be pDragRectArray.
*     HotSpotPoint, offset of the cursor hotpoint relative to the image.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_DragObjects(
    HWND hWnd,
    HIMAGELIST hDragImageList,
    PRECT pDragRectArray,
    int DragRectCount,
    POINT HotSpotPoint
    )
{

    RECT CurrentDropRect;
    HCURSOR hDropCursor;
    HCURSOR hNoDropCursor;
    HCURSOR hDragCursor;
    HCURSOR hNewDragCursor;
    POINT Point;
    BOOL fContinueDrag;
    MSG Msg;
    MSG PeekMsg;

    HTREEITEM hCurrentDropTreeItem = NULL;

    GetWindowRect(g_RegEditData.hKeyTreeWnd, &CurrentDropRect);

    GetCursorPos(&Point);
    Point.x -= CurrentDropRect.left;
    Point.y -= CurrentDropRect.top;

    if (hDragImageList != NULL) {
        if ( ImageList_BeginDrag(hDragImageList, 0, HotSpotPoint.x, HotSpotPoint.y) ) {
            ImageList_DragEnter(g_RegEditData.hKeyTreeWnd, Point.x, Point.y );
        }
    }

    s_RegDragData.hLockWnd = g_RegEditData.hKeyTreeWnd;
    LockWindowUpdate(s_RegDragData.hLockWnd);

    if (hDragImageList != NULL) {

        ShowCursor(FALSE);
        ImageList_DragShowNolock(TRUE);

    }

    else {

        s_RegDragData.HotSpotPoint = HotSpotPoint;
        s_RegDragData.pDragRectArray = pDragRectArray;
        s_RegDragData.DragRectCount = DragRectCount;

        s_RegDragData.DragRectPoint = Point;
        DrawDragRects();

    }

    hDropCursor = LoadCursor(NULL, IDC_ARROW);
    hDragCursor = hDropCursor;
    hNoDropCursor = LoadCursor(NULL, IDC_NO);

    SetCapture(hWnd);

    fContinueDrag = TRUE;

    while (fContinueDrag && GetMessage(&Msg, NULL, 0, 0)) {

        switch (Msg.message) {

            case WM_MOUSEMOVE:
                //
                //  If we have another WM_MOUSEMOVE message in the queue
                //  (before any other mouse message), don't process this
                //  mouse message.
                //

                if (PeekMessage(&PeekMsg, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
                    PM_NOREMOVE) && PeekMsg.message == WM_MOUSEMOVE)
                    break;

                if (!PtInRect(&CurrentDropRect, Msg.pt)) {

                    hNewDragCursor = hNoDropCursor;

                }

                else {

                    hNewDragCursor = hDropCursor;

                }

                if (hNewDragCursor != hDragCursor) {

                    if (hDragImageList != NULL) {

                        if (hNewDragCursor == hDropCursor) {

                            ImageList_DragShowNolock(TRUE);
                            ShowCursor(FALSE);

                        }

                        else {

                            ImageList_DragShowNolock(FALSE);
                            ShowCursor(TRUE);
                            SetCursor(hNewDragCursor);

                        }

                    }

                    else
                        SetCursor(hNewDragCursor);

                    hDragCursor = hNewDragCursor;

                }

                Msg.pt.x -= CurrentDropRect.left;
                Msg.pt.y -= CurrentDropRect.top;

                {

                TV_HITTESTINFO TVHitTestInfo;
                HTREEITEM hTreeItem;

                TVHitTestInfo.pt = Msg.pt;
                hTreeItem = TreeView_HitTest(g_RegEditData.hKeyTreeWnd, &TVHitTestInfo);

                if (hTreeItem != hCurrentDropTreeItem) {

                    ImageList_DragShowNolock(FALSE);

//                    DbgPrintf(("Got a drop target!!!\n"));

//                    SetWindowRedraw(g_RegEditData.hKeyTreeWnd, FALSE);

                    TreeView_SelectDropTarget(g_RegEditData.hKeyTreeWnd, hTreeItem);

//                    SetWindowRedraw(g_RegEditData.hKeyTreeWnd, TRUE);

                    hCurrentDropTreeItem = hTreeItem;

                    ImageList_DragShowNolock(TRUE);

                }

                }

                if (hDragImageList != NULL)
                    ImageList_DragMove(Msg.pt.x, Msg.pt.y);

                else {

                    DrawDragRects();
                    s_RegDragData.DragRectPoint = Msg.pt;
                    DrawDragRects();

                }
                break;

            case WM_KEYDOWN:
                if (Msg.wParam != VK_ESCAPE)
                    break;
                //  FALL THROUGH

            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
                fContinueDrag = FALSE;
                break;

            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
                fContinueDrag = FALSE;
                break;

            default:
                TranslateMessage(&Msg);
                DispatchMessage(&Msg);
                break;

        }

    }

    ReleaseCapture();

    if (hDragImageList != NULL) {

        ImageList_DragShowNolock(FALSE);
        ImageList_EndDrag();

        if (hDragCursor == hDropCursor)
            ShowCursor(TRUE);

    }

    else
        DrawDragRects();

    LockWindowUpdate(NULL);

}

/*******************************************************************************
*
*  DragDragRects
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
PASCAL
DrawDragRects(
    VOID
    )
{

    HDC hDC;
    int Index;
    RECT Rect;

    hDC = GetDCEx(s_RegDragData.hLockWnd, NULL, DCX_WINDOW | DCX_CACHE |
        DCX_LOCKWINDOWUPDATE);

    for (Index = s_RegDragData.DragRectCount; Index >= 0; Index--) {

        Rect = s_RegDragData.pDragRectArray[Index];
        OffsetRect(&Rect, s_RegDragData.DragRectPoint.x -
            s_RegDragData.HotSpotPoint.x, s_RegDragData.DragRectPoint.y -
            s_RegDragData.HotSpotPoint.y);
        DrawFocusRect(hDC, &Rect);

    }

    ReleaseDC(s_RegDragData.hLockWnd, hDC);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regdrag.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDRAG.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Drag and drop routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGDRAG
#define _INC_REGDRAG

VOID
PASCAL
RegEdit_DragObjects(
    HWND hWnd,
    HIMAGELIST hDragImageList,
    PRECT pDragRectArray,
    int DragRectCount,
    POINT HotSpotPoint
    );

#endif // _INC_REGDRAG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regdata.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regdata.cxx

Abstract:

    This module contains the definition for the REGISTRY_DATA
    class. This class is used to display registry data of type
    REG_RESOURCE_LIST and REG_FULL_RESOURCE_DESCRIPTOR.

Author:

    Jaime Sasson (jaimes) - 30-Nov-1993

Environment:

    Ulib, Regedit, Windows, User Mode

--*/
#include "regdata.hxx"
#include "regdesc.hxx"
#include "regfdesc.hxx"
#include "regresls.hxx"
#include "regiodsc.hxx"
#include "regiodls.hxx"
#include "regioreq.hxx"
#include "iterator.hxx"
#include "regsys.hxx"
#include "regresid.h"

#include <stdio.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

extern "C" 
{
    #include "clb.h" 
    HINSTANCE g_hInstance;                   
}


//  Definition of the structure used to pass information
//  to the DisplayBinaryDataDialogProc
typedef struct _BUFFER_INFORMATION 
{
    PBYTE   Buffer;
    ULONG   BufferSize;
    BOOL    DisplayValueType;
    ULONG   ValueType;
} BUFFER_INFORMATION, *PBUFFER_INFORMATION;

//  Constants that define buffer sizes for strings that represent a DWORD
//  and a BIG_INT.
//  These constants take into consideration the trailing '0x' and the terminating NUL
//  character.

#define MAX_LENGTH_DWORD_STRING     1+1+8+1     // 0x12345678'\0'
#define MAX_LENGTH_BIG_INT_STRING   1+1+16+1    // 0x1234567812345678'\0'


DEFINE_CONSTRUCTOR( REGISTRY_DATA, OBJECT );

DEFINE_CAST_MEMBER_FUNCTION( REGISTRY_DATA );


//
//  Static data
//
BOOL        REGISTRY_DATA::s_StringsInitialized = FALSE;
PWSTRING    REGISTRY_DATA::s_MsgBusInternal;
PWSTRING    REGISTRY_DATA::s_MsgBusIsa;
PWSTRING    REGISTRY_DATA::s_MsgBusEisa;
PWSTRING    REGISTRY_DATA::s_MsgBusMicroChannel;
PWSTRING    REGISTRY_DATA::s_MsgBusTurboChannel;
PWSTRING    REGISTRY_DATA::s_MsgBusPCIBus;
PWSTRING    REGISTRY_DATA::s_MsgBusVMEBus;
PWSTRING    REGISTRY_DATA::s_MsgBusNuBus;
PWSTRING    REGISTRY_DATA::s_MsgBusPCMCIABus;
PWSTRING    REGISTRY_DATA::s_MsgBusCBus;
PWSTRING    REGISTRY_DATA::s_MsgBusMPIBus;
PWSTRING    REGISTRY_DATA::s_MsgBusMPSABus;
PWSTRING    REGISTRY_DATA::s_MsgInvalid;
PWSTRING    REGISTRY_DATA::s_MsgDevPort;
PWSTRING    REGISTRY_DATA::s_MsgDevInterrupt;
PWSTRING    REGISTRY_DATA::s_MsgDevMemory;
PWSTRING    REGISTRY_DATA::s_MsgDevDma;
PWSTRING    REGISTRY_DATA::s_MsgIntLevelSensitive;
PWSTRING    REGISTRY_DATA::s_MsgIntLatched;
PWSTRING    REGISTRY_DATA::s_MsgMemReadWrite;
PWSTRING    REGISTRY_DATA::s_MsgMemReadOnly;
PWSTRING    REGISTRY_DATA::s_MsgMemWriteOnly;
PWSTRING    REGISTRY_DATA::s_MsgPortMemory;
PWSTRING    REGISTRY_DATA::s_MsgPortPort;
PWSTRING    REGISTRY_DATA::s_MsgShareUndetermined;
PWSTRING    REGISTRY_DATA::s_MsgShareDeviceExclusive;
PWSTRING    REGISTRY_DATA::s_MsgShareDriverExclusive;
PWSTRING    REGISTRY_DATA::s_MsgShareShared;


//------------------------------------------------------------------------------
//  _InitializeStrings
//
//  DESCRIPTION: Initialize all strings used by this class.
//
//  RETURN:  Returns TRUE if the initialization succeeds.
//------------------------------------------------------------------------------
BOOL REGISTRY_DATA::_InitializeStrings()
{
    s_MsgBusInternal       = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_INTERNAL, ""      );
    s_MsgBusIsa            = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_ISA, ""           );
    s_MsgBusEisa           = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_EISA, ""          );
    s_MsgBusMicroChannel   = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_MICRO_CHANNEL, "" );
    s_MsgBusTurboChannel   = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_TURBO_CHANNEL, "" );
    s_MsgBusPCIBus         = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_PCI_BUS, ""       );
    s_MsgBusVMEBus         = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_VME_BUS, ""       );
    s_MsgBusNuBus          = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_NU_BUS, ""        );
    s_MsgBusPCMCIABus      = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_PCMCIA_BUS, ""    );
    s_MsgBusCBus           = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_C_BUS, ""         );
    s_MsgBusMPIBus         = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_MPI_BUS, ""       );
    s_MsgBusMPSABus        = REGEDIT_BASE_SYSTEM::QueryString( IDS_BUS_MPSA_BUS, ""      );
    s_MsgInvalid           = REGEDIT_BASE_SYSTEM::QueryString( IDS_INVALID, "" );
    s_MsgDevPort           = REGEDIT_BASE_SYSTEM::QueryString( IDS_DEV_PORT, "" );
    s_MsgDevInterrupt      = REGEDIT_BASE_SYSTEM::QueryString( IDS_DEV_INTERRUPT, "" );
    s_MsgDevMemory         = REGEDIT_BASE_SYSTEM::QueryString( IDS_DEV_MEMORY, "" );
    s_MsgDevDma            = REGEDIT_BASE_SYSTEM::QueryString( IDS_DEV_DMA, "" );
    s_MsgIntLevelSensitive = REGEDIT_BASE_SYSTEM::QueryString( IDS_INT_LEVEL_SENSITIVE, "" );
    s_MsgIntLatched        = REGEDIT_BASE_SYSTEM::QueryString( IDS_INT_LATCHED, ""         );
    s_MsgMemReadWrite      = REGEDIT_BASE_SYSTEM::QueryString( IDS_MEM_READ_WRITE, ""      );
    s_MsgMemReadOnly       = REGEDIT_BASE_SYSTEM::QueryString( IDS_MEM_READ_ONLY, ""       );
    s_MsgMemWriteOnly      = REGEDIT_BASE_SYSTEM::QueryString( IDS_MEM_WRITE_ONLY, ""      );
    s_MsgPortMemory        = REGEDIT_BASE_SYSTEM::QueryString( IDS_PORT_MEMORY, "" );
    s_MsgPortPort          = REGEDIT_BASE_SYSTEM::QueryString( IDS_PORT_PORT, "" );
    s_MsgShareUndetermined    = REGEDIT_BASE_SYSTEM::QueryString( IDS_SHARE_UNDETERMINED, ""       );
    s_MsgShareDeviceExclusive = REGEDIT_BASE_SYSTEM::QueryString( IDS_SHARE_DEVICE_EXCLUSIVE, ""      );
    s_MsgShareDriverExclusive = REGEDIT_BASE_SYSTEM::QueryString( IDS_SHARE_DRIVER_EXCLUSIVE, "" );
    s_MsgShareShared          = REGEDIT_BASE_SYSTEM::QueryString( IDS_SHARE_SHARED, "" );

    if ( ( s_MsgBusInternal       == NULL )  ||
         ( s_MsgBusIsa            == NULL )  ||
         ( s_MsgBusEisa           == NULL )  ||
         ( s_MsgBusMicroChannel   == NULL )  ||
         ( s_MsgBusTurboChannel   == NULL )  ||
         ( s_MsgBusPCIBus         == NULL )  ||
         ( s_MsgBusVMEBus         == NULL )  ||
         ( s_MsgBusNuBus          == NULL )  ||
         ( s_MsgBusPCMCIABus      == NULL )  ||
         ( s_MsgBusCBus           == NULL )  ||
         ( s_MsgBusMPIBus         == NULL )  ||
         ( s_MsgBusMPSABus        == NULL )  ||
         ( s_MsgInvalid           == NULL )  ||
         ( s_MsgDevPort           == NULL )  ||
         ( s_MsgDevInterrupt      == NULL )  ||
         ( s_MsgDevMemory         == NULL )  ||
         ( s_MsgDevDma            == NULL )  ||
         ( s_MsgIntLevelSensitive == NULL )  ||
         ( s_MsgIntLatched        == NULL )  ||
         ( s_MsgMemReadWrite      == NULL )  ||
         ( s_MsgMemReadOnly       == NULL )  ||
         ( s_MsgMemWriteOnly      == NULL )  ||
         ( s_MsgPortMemory        == NULL )  ||
         ( s_MsgPortPort          == NULL )  ||
         ( s_MsgShareUndetermined    == NULL )  ||
         ( s_MsgShareDeviceExclusive == NULL )  ||
         ( s_MsgShareDriverExclusive == NULL )  ||
         ( s_MsgShareShared          == NULL )
       ) {

            DELETE( s_MsgBusInternal       );
            DELETE( s_MsgBusIsa            );
            DELETE( s_MsgBusEisa           );
            DELETE( s_MsgBusMicroChannel   );
            DELETE( s_MsgBusTurboChannel   );
            DELETE( s_MsgBusPCIBus         );
            DELETE( s_MsgBusVMEBus         );
            DELETE( s_MsgBusNuBus          );
            DELETE( s_MsgBusPCMCIABus      );
            DELETE( s_MsgBusCBus           );
            DELETE( s_MsgBusMPIBus         );
            DELETE( s_MsgBusMPSABus        );
            DELETE( s_MsgInvalid           );
            DELETE( s_MsgDevPort           );
            DELETE( s_MsgDevInterrupt      );
            DELETE( s_MsgDevMemory         );
            DELETE( s_MsgDevDma            );
            DELETE( s_MsgIntLevelSensitive );
            DELETE( s_MsgIntLatched        );
            DELETE( s_MsgMemReadWrite      );
            DELETE( s_MsgMemReadOnly       );
            DELETE( s_MsgMemWriteOnly      );
            DELETE( s_MsgPortMemory        );
            DELETE( s_MsgPortPort          );
            DELETE( s_MsgShareUndetermined    );
            DELETE( s_MsgShareDeviceExclusive );
            DELETE( s_MsgShareDriverExclusive );
            DELETE( s_MsgShareShared          );

        DebugPrintTrace(( "REGEDT32: Unable to initialize strings on REGISTRY_DATA \n" ));
        s_StringsInitialized = FALSE;
    } else {
        s_StringsInitialized = TRUE;
    }
    return( s_StringsInitialized );
}

VOID DisplayResourceData(HWND hWnd, DWORD dwType, LPEDITVALUEPARAM lpEditValueParam)
{
    REGISTRY_DATA::_DisplayData(hWnd, dwType, lpEditValueParam);
}


//------------------------------------------------------------------------------
//  DisplayResourceData
//
//  DESCRIPTION: Invoke the appropriate dialog that displays registry data of type
//               REG_RESOURCE_LIST and REG_FULL_RESOURCE_DESCRIPTOR.
//
//  PARAMETERS:  hWnd - A handle to the owner window.
//               dwType - Indicates the type of the data to be displayed.
//               EditValueParam - the edit value information
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DisplayData(HWND hWnd, DWORD dwType, LPEDITVALUEPARAM lpEditValueParam)
{
    PBYTE pbValueData = lpEditValueParam->pValueData;
    UINT  cbValueData = lpEditValueParam->cbValueData;

    if(!s_StringsInitialized) 
    {
        _InitializeStrings();
    }

    if (s_StringsInitialized)
    {
        switch(dwType) 
        {
        
        case REG_RESOURCE_LIST:
            {
                RESOURCE_LIST ResourceList;
        
                if(ResourceList.Initialize(pbValueData, cbValueData))
                {
                    REGISTRY_DATA::_DisplayResourceList(hWnd, &ResourceList);
                }
            }
            break;
        
        case REG_FULL_RESOURCE_DESCRIPTOR:
            {
                FULL_DESCRIPTOR FullDescriptor;
        
                if(FullDescriptor.Initialize(pbValueData, cbValueData)) 
                {
                    REGISTRY_DATA::_DisplayFullResourceDescriptor( hWnd, &FullDescriptor );
                }
            }
            break;
        
        case REG_RESOURCE_REQUIREMENTS_LIST:
            {
                IO_REQUIREMENTS_LIST RequirementsList;

                if( RequirementsList.Initialize(pbValueData, cbValueData)) 
                {
                    REGISTRY_DATA::_DisplayRequirementsList( hWnd, &RequirementsList );
                }
            }
            break;  
        }
    }
}


//------------------------------------------------------------------------------
//  _DisplayResourceList
//
//  DESCRIPTION: Invoke the  dialog that displays registry data of type
//               REG_RESOURCE_LIST 
//
//  PARAMETERS:  hWnd - A handle to the owner window.
//               pResourceList - Pointer to a RESOURCE_LIST object to be displayed.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DisplayResourceList(HWND hWnd, PCRESOURCE_LIST pResourceList)
{
    DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_RESOURCE_LIST), hWnd,
                   REGISTRY_DATA::_DisplayResourceListDialogProc,
                   (DWORD_PTR) pResourceList);
}


//------------------------------------------------------------------------------
//  _DisplayFullResourceDescriptor
//
//  DESCRIPTION: Invoke the  dialog that displays registry data of type
//               REG_FULL_RESOURCE_DESCRIPTOR.
//
//  PARAMETERS:  hWnd - A handle to the owner window.
//               pFullDescriptor - Pointer to a FULL_DESCRIPTOR object to be displayed.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DisplayFullResourceDescriptor(HWND hWnd, PCFULL_DESCRIPTOR pFullDescriptor)
{
    DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_FULL_RES_DESCRIPTOR), hWnd,
                   REGISTRY_DATA::_DisplayFullResourceDescriptorDialogProc,
                   (DWORD_PTR) pFullDescriptor);
}


//------------------------------------------------------------------------------
//  _DisplayRequirementsList
//
//  DESCRIPTION: Invoke the  dialog that displays registry data of type
//               REG_IO_RESOURCE_REQUIREMENTS_LIST.
//
//  PARAMETERS:  hWnd - A handle to the owner window.
//               pRequirementsList - Pointer to an IO_REQUIREMENTS_LIST object to be displayed.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DisplayRequirementsList(HWND hWnd, PCIO_REQUIREMENTS_LIST  pRequirementsList)
{
    DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_IO_REQUIREMENTS_LIST), hWnd,
                   REGISTRY_DATA::_DisplayRequirementsListDialogProc,
                   (DWORD_PTR) pRequirementsList );
}


//------------------------------------------------------------------------------
//  _DisplayIoDescriptor
//
//  DESCRIPTION: Invoke appropriate that displays a Port, Memory, Interrupt or DMA,
//               depending on the type of the object received as parameter.
//
//  PARAMETERS:  hWnd - A handle to the owner window.
//               pIODescriptor - Pointer to the object to be displayed.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DisplayIoDescriptor(HWND hWnd, PCIO_DESCRIPTOR pIODescriptor)
{
    DLGPROC     Pointer;
    LPCWSTR     Template;

    if(pIODescriptor->IsDescriptorTypePort()) 
    {
        Pointer = REGISTRY_DATA::_DisplayIoPortDialogProc;
        Template = MAKEINTRESOURCE(IDD_IO_PORT_RESOURCE);
    } 
    else if(pIODescriptor->IsDescriptorTypeMemory()) 
    {
        Pointer = REGISTRY_DATA::_DisplayIoMemoryDialogProc;
        Template = MAKEINTRESOURCE(IDD_IO_MEMORY_RESOURCE);
    } 
    else if(pIODescriptor->IsDescriptorTypeInterrupt()) 
    {
        Pointer = REGISTRY_DATA::_DisplayIoInterruptDialogProc;
        Template = MAKEINTRESOURCE(IDD_IO_INTERRUPT_RESOURCE);
    } 
    else if(pIODescriptor->IsDescriptorTypeDma()) 
    {
        Pointer = REGISTRY_DATA::_DisplayIoDmaDialogProc;
        Template = MAKEINTRESOURCE(IDD_IO_DMA_RESOURCE);
    } 
    else 
    {
        Pointer = NULL;
    }

    if(Pointer) 
    {
        DialogBoxParam(g_hInstance, Template, hWnd, Pointer, (DWORD_PTR)pIODescriptor );
    }
}

//------------------------------------------------------------------------------
//  _DisplayResourceListDialogProc
//
//  DESCRIPTION: The dialog proceedure for displaying data of type REG_RESOURCE_LIST.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               Msg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
INT_PTR CALLBACK REGISTRY_DATA::_DisplayResourceListDialogProc(HWND hDlg, UINT dwMsg, WPARAM wParam,
                                                   LPARAM lParam)
{
    switch(dwMsg) 
    {
    case WM_INITDIALOG:
        {
            LPCWSTR             InterfaceString;
            ULONG               StringSize;
            WCHAR               BusNumber[ MAX_LENGTH_DWORD_STRING ];
            PARRAY              Descriptors;
            PITERATOR           Iterator;
            PCFULL_DESCRIPTOR   FullResourceDescriptor;
            PCRESOURCE_LIST     pResourceList;

            CLB_ROW         ClbRow;
            CLB_STRING      ClbString[ ] = {{ BusNumber, 0, CLB_LEFT, NULL },
                                            { NULL,      0, CLB_LEFT, NULL }};

            ULONG Widths[] = {14, ( ULONG ) -1};

            if (((pResourceList = (PCRESOURCE_LIST)lParam) == NULL) ||
                ((Descriptors = pResourceList->GetFullResourceDescriptors()) == NULL) ||
                ((Iterator = Descriptors->QueryIterator()) == NULL )) 
            {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }
            
            ClbSetColumnWidths(hDlg, IDC_LIST_RESOURCE_LISTS, Widths );

            while( ( FullResourceDescriptor = ( PCFULL_DESCRIPTOR )Iterator->GetNext() ) != NULL ) 
            {
                switch( FullResourceDescriptor->GetInterfaceType() ) 
                {
                case Internal:
                    InterfaceString = s_MsgBusInternal->GetWSTR();
                    StringSize = s_MsgBusInternal->QueryChCount();
                    break;

                case Isa:
                    InterfaceString = s_MsgBusIsa->GetWSTR();
                    StringSize = s_MsgBusIsa->QueryChCount();
                    break;

                case Eisa:
                    InterfaceString = s_MsgBusEisa->GetWSTR();
                    StringSize = s_MsgBusEisa->QueryChCount();
                    break;

                case MicroChannel:
                    InterfaceString = s_MsgBusMicroChannel->GetWSTR();
                    StringSize = s_MsgBusMicroChannel->QueryChCount();
                    break;

                case TurboChannel:
                    InterfaceString = s_MsgBusTurboChannel->GetWSTR();
                    StringSize =  s_MsgBusTurboChannel->QueryChCount();
                    break;

                case PCIBus:
                    InterfaceString = s_MsgBusPCIBus->GetWSTR();
                    StringSize =  s_MsgBusPCIBus->QueryChCount();
                    break;

                case VMEBus:
                    InterfaceString = s_MsgBusVMEBus->GetWSTR();
                    StringSize = s_MsgBusVMEBus->QueryChCount();
                    break;

                case NuBus:
                    InterfaceString = s_MsgBusNuBus->GetWSTR();
                    StringSize =  s_MsgBusNuBus->QueryChCount();
                    break;

                case PCMCIABus:
                    InterfaceString = s_MsgBusPCMCIABus->GetWSTR();
                    StringSize = s_MsgBusPCMCIABus->QueryChCount();
                    break;

                case CBus:
                    InterfaceString = s_MsgBusCBus->GetWSTR();
                    StringSize = s_MsgBusCBus->QueryChCount();
                    break;

                case MPIBus:
                    InterfaceString = s_MsgBusMPIBus->GetWSTR();
                    StringSize = s_MsgBusMPIBus->QueryChCount();
                    break;

                case MPSABus:
                    InterfaceString = s_MsgBusMPSABus->GetWSTR();
                    StringSize = s_MsgBusMPSABus->QueryChCount();
                    break;

                default:
                    InterfaceString = s_MsgInvalid->GetWSTR();
                    StringSize = s_MsgInvalid->QueryChCount();
                    break;
                }

                StringCchPrintf(BusNumber, ARRAYSIZE(BusNumber), ( LPWSTR )L"%d", FullResourceDescriptor->GetBusNumber());

                ClbString[ 0 ].Length = wcslen( BusNumber );
                ClbString[ 0 ].Format = CLB_LEFT;
                ClbString[ 1 ].String = ( LPWSTR )InterfaceString;
                ClbString[ 1 ].Format = CLB_LEFT;
                ClbString[ 1 ].Length = StringSize;

                ClbRow.Count = 2;
                ClbRow.Strings = ClbString;
                ClbRow.Data = ( PVOID )FullResourceDescriptor;

                ClbAddData(hDlg, IDC_LIST_RESOURCE_LISTS, &ClbRow );

            }
            DELETE(Iterator);

            // Disble the Display button
            EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_RESOURCES ), FALSE );
            return( TRUE );
        }

    case WM_COMPAREITEM:
        {
            LPCOMPAREITEMSTRUCT     lpcis;
            LPCLB_ROW               ClbRow1;
            LPCLB_ROW               ClbRow2;
            LONG                    Compare;

            PCFULL_DESCRIPTOR       FullDescriptor1;
            PCFULL_DESCRIPTOR       FullDescriptor2;

            PWSTR                   String1;
            PWSTR                   String2;

            lpcis = ( LPCOMPAREITEMSTRUCT ) lParam;

            //
            // Extract the rows to be compared.
            // First compare by bus number, and if they
            // are equal, compare by interface type
            //

            ClbRow1 = ( LPCLB_ROW ) lpcis->itemData1;
            ClbRow2 = ( LPCLB_ROW ) lpcis->itemData2;

            FullDescriptor1 = ( PCFULL_DESCRIPTOR )ClbRow1->Data;
            FullDescriptor2 = ( PCFULL_DESCRIPTOR )ClbRow2->Data;

            Compare =  (FullDescriptor1->GetBusNumber() -
                        FullDescriptor2->GetBusNumber()   )?  TRUE:FALSE;

            if( Compare == 0 ) 
            {
                String1 = ClbRow1->Strings[1].String;
                String2 = ClbRow2->Strings[1].String;
                Compare = wcscmp( String1, String2 );
            }

            return Compare;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {
        case IDOK:
        case IDCANCEL:
            EndDialog( hDlg, TRUE );
            return( TRUE );

        case IDC_LIST_RESOURCE_LISTS:
            {
                switch( HIWORD( wParam )) 
                {
                case LBN_SELCHANGE:
                    {
                        // Enable the display drive details button
                        EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_RESOURCES ), TRUE);
                    }
                    break;

                case LBN_DBLCLK:
                    {
                        // Simulate that the details button was pushed
                        SendMessage(hDlg, WM_COMMAND,
                                     MAKEWPARAM( IDC_PUSH_DISPLAY_RESOURCES, BN_CLICKED),
                                     ( LPARAM ) GetDlgItem( hDlg, IDC_PUSH_DISPLAY_RESOURCES));
                    }
                    break;
                }
                break;
            }

        case IDC_PUSH_DISPLAY_RESOURCES:
            {
                PCFULL_DESCRIPTOR FullDescriptor;

                FullDescriptor = ( PCFULL_DESCRIPTOR )(_GetSelectedItem ( hDlg, IDC_LIST_RESOURCE_LISTS ) );
                if( FullDescriptor != NULL ) 
                {
                    _DisplayFullResourceDescriptor( hDlg, FullDescriptor );
                }
                return(TRUE);
            }
        }
    }
    return(FALSE);
}


//------------------------------------------------------------------------------
//  _DisplayFullResourceDescriptorDialogProc
//
//  DESCRIPTION: The dialog proceedure for displaying data of type 
//               REG_FULL_RESOURCE_DESCRIPTOR.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
INT_PTR CALLBACK REGISTRY_DATA::_DisplayFullResourceDescriptorDialogProc(HWND hDlg, UINT dwMsg,
                     WPARAM  wParam, LPARAM lParam)
{
    PCBYTE                          Pointer;
    ULONG                           Size;
    STATIC PCDEVICE_SPECIFIC_DESCRIPTOR    LastSelectedDevSpecific;

    switch(dwMsg) 
    {

    case WM_INITDIALOG:
        {
            LPCWSTR                         InterfaceString;
            WCHAR                           BusNumber[ MAX_LENGTH_DWORD_STRING ];
            PARRAY                          PartialDescriptors;
            PITERATOR                       Iterator;
            PCFULL_DESCRIPTOR               FullResourceDescriptor;
            PCPARTIAL_DESCRIPTOR            PartialDescriptor;
            PCPORT_DESCRIPTOR               Port;
            PCINTERRUPT_DESCRIPTOR          Interrupt;
            PCMEMORY_DESCRIPTOR             Memory;
            PCDMA_DESCRIPTOR                Dma;
            PCDEVICE_SPECIFIC_DESCRIPTOR    DeviceSpecific;

            CLB_ROW         ClbRow;
            CLB_STRING      ClbString[ ] = {
                                { NULL, 0, CLB_LEFT, NULL },
                                { NULL, 0, CLB_LEFT, NULL },
                                { NULL, 0, CLB_LEFT, NULL },
                                { NULL, 0, CLB_LEFT, NULL }
                             };

            WCHAR           PortAddressString[ MAX_LENGTH_BIG_INT_STRING ];
            WCHAR           PortLengthString[ MAX_LENGTH_DWORD_STRING ];
            PCWSTRING       PortType;

            WCHAR           InterruptVectorString[ MAX_LENGTH_DWORD_STRING ];
            WCHAR           InterruptLevelString[ MAX_LENGTH_DWORD_STRING ];
            WCHAR           InterruptAffinityString[ MAX_LENGTH_DWORD_STRING ];
            PCWSTRING       InterruptType;

            WCHAR           MemoryAddressString[ MAX_LENGTH_BIG_INT_STRING ];
            WCHAR           MemoryLengthString[ MAX_LENGTH_DWORD_STRING ];
            PCWSTRING       MemoryAccess;

            WCHAR           DmaChannelString[ MAX_LENGTH_DWORD_STRING ];
            WCHAR           DmaPortString[ MAX_LENGTH_DWORD_STRING ];

            WCHAR           Reserved1String[ MAX_LENGTH_DWORD_STRING ];
            WCHAR           Reserved2String[ MAX_LENGTH_DWORD_STRING ];
            WCHAR           DataSizeString[ MAX_LENGTH_DWORD_STRING ];
            PCBYTE          AuxPointer;

           LastSelectedDevSpecific = NULL;

           if( ( FullResourceDescriptor = ( PCFULL_DESCRIPTOR )lParam ) == NULL ) 
           {
                EndDialog( hDlg, 0 );
                return( TRUE );
           }

           //
           //   Write the interface type
           //
           switch( FullResourceDescriptor->GetInterfaceType() ) 
           {

           case Internal:

               InterfaceString = s_MsgBusInternal->GetWSTR();
               break;

           case Isa:

               InterfaceString = s_MsgBusIsa->GetWSTR();
               break;

           case Eisa:

               InterfaceString = s_MsgBusEisa->GetWSTR();
               break;

           case MicroChannel:

               InterfaceString = s_MsgBusMicroChannel->GetWSTR();
               break;

           case TurboChannel:

               InterfaceString = s_MsgBusTurboChannel->GetWSTR();
               break;

           case PCIBus:

               InterfaceString = s_MsgBusPCIBus->GetWSTR();
               break;

           case VMEBus:

               InterfaceString = s_MsgBusVMEBus->GetWSTR();
               break;

           case NuBus:

               InterfaceString = s_MsgBusNuBus->GetWSTR();
               break;

           case PCMCIABus:

               InterfaceString = s_MsgBusPCMCIABus->GetWSTR();
               break;

           case CBus:

               InterfaceString = s_MsgBusCBus->GetWSTR();
               break;

           case MPIBus:

               InterfaceString = s_MsgBusMPIBus->GetWSTR();
               break;

           case MPSABus:

               InterfaceString = s_MsgBusMPSABus->GetWSTR();
               break;

           default:

               InterfaceString = s_MsgInvalid->GetWSTR();
               break;
           }

           SendDlgItemMessage( hDlg,
                               IDC_FULL_RES_TEXT_INTERFACE_TYPE,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )InterfaceString );

           //
           //   Write the bus number
           //
           StringCchPrintf(BusNumber, ARRAYSIZE(BusNumber), ( LPWSTR )L"%d", FullResourceDescriptor->GetBusNumber());

           SendDlgItemMessage( hDlg,
                               IDC_FULL_RES_TEXT_BUS_NUMBER,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )BusNumber );

           //
           //   Write the version and revision
           //

           StringCchPrintf(BusNumber, ARRAYSIZE(BusNumber), ( LPWSTR )L"%d", FullResourceDescriptor->GetVersion());

           SendDlgItemMessage( hDlg,
                               IDC_FULL_RES_TEXT_VERSION,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )BusNumber );

           StringCchPrintf( BusNumber, ARRAYSIZE(BusNumber), ( LPWSTR )L"%d", FullResourceDescriptor->GetRevision() );

           SendDlgItemMessage( hDlg,
                               IDC_FULL_RES_TEXT_REVISION,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )BusNumber );



            //
            //   Write partial descriptors
            //
            if( ( ( PartialDescriptors = FullResourceDescriptor->GetResourceDescriptors() ) == NULL ) ||
                ( ( Iterator = PartialDescriptors->QueryIterator() ) == NULL ) ) {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }


            ClbRow.Strings = ClbString;
            while( ( PartialDescriptor = ( PCPARTIAL_DESCRIPTOR )Iterator->GetNext() ) != NULL ) {

                ClbRow.Data = ( PVOID )PartialDescriptor;
                if( PartialDescriptor->IsDescriptorTypePort() ) {
                    Port = ( PCPORT_DESCRIPTOR )PartialDescriptor;
                    if( ( ( ( PPORT_DESCRIPTOR )Port )->GetPhysicalAddress() )->HighPart != 0 ) {
                        StringCchPrintf( PortAddressString,
                                        ARRAYSIZE(PortAddressString),
                                        ( LPWSTR )L"0x%08x%08x",
                                        ( ( ( PPORT_DESCRIPTOR )Port )->GetPhysicalAddress() )->HighPart,
                                        ( ( ( PPORT_DESCRIPTOR )Port )->GetPhysicalAddress() )->LowPart );
                    } else {
                        StringCchPrintf( PortAddressString,
                                        ARRAYSIZE(PortAddressString),
                                        ( LPWSTR )L"0x%08x",
                                        ( ( ( PPORT_DESCRIPTOR )Port )->GetPhysicalAddress() )->LowPart );
                    }
                    StringCchPrintf( PortLengthString, ARRAYSIZE(PortLengthString),  ( LPWSTR )L"%#x", Port->GetLength() );

                    ClbString[ 0 ].String = ( LPWSTR )PortAddressString;
                    ClbString[ 0 ].Format = CLB_LEFT;
                    ClbString[ 0 ].Length = wcslen( PortAddressString );
                    ClbString[ 1 ].String = ( LPWSTR )PortLengthString;
                    ClbString[ 1 ].Format = CLB_LEFT;
                    ClbString[ 1 ].Length = wcslen( PortLengthString );
                    if( Port->IsPortMemory() ) {
                        PortType = s_MsgPortMemory;
                    } else {
                        PortType = s_MsgPortPort;
                    }
                    ClbString[ 2 ].String = ( LPWSTR )PortType->GetWSTR();
                    ClbString[ 2 ].Format = CLB_LEFT;
                    ClbString[ 2 ].Length = PortType->QueryChCount();

                    ClbRow.Count = 3;

                    ClbAddData( hDlg,
                                IDC_FULL_RES_LIST_PORTS,
                                &ClbRow );

                } else if( PartialDescriptor->IsDescriptorTypeInterrupt() ) {
                    Interrupt = ( PCINTERRUPT_DESCRIPTOR )PartialDescriptor;
                    StringCchPrintf( InterruptVectorString, ARRAYSIZE(InterruptVectorString), ( LPWSTR )L"%d", Interrupt->GetVector() );
                    StringCchPrintf( InterruptLevelString, ARRAYSIZE(InterruptLevelString), ( LPWSTR )L"%d", Interrupt->GetLevel() );
                    StringCchPrintf( InterruptAffinityString, ARRAYSIZE(InterruptAffinityString), ( LPWSTR )L"0x%08x", Interrupt->GetAffinity() );

                    ClbString[ 0 ].String = ( LPWSTR )InterruptVectorString;
                    ClbString[ 0 ].Length = wcslen( InterruptVectorString );
                    ClbString[ 0 ].Format = CLB_LEFT;
                    ClbString[ 1 ].String = ( LPWSTR )InterruptLevelString;
                    ClbString[ 1 ].Format = CLB_LEFT;
                    ClbString[ 1 ].Length = wcslen( InterruptLevelString );
                    ClbString[ 2 ].String = ( LPWSTR )InterruptAffinityString;
                    ClbString[ 2 ].Format = CLB_LEFT;
                    ClbString[ 2 ].Length = wcslen( InterruptAffinityString );
                    if( Interrupt->IsInterruptLatched() ) {
                        InterruptType = s_MsgIntLatched;
                    } else {
                        InterruptType = s_MsgIntLevelSensitive;
                    }
                    ClbString[ 3 ].String = ( LPWSTR )InterruptType->GetWSTR();
                    ClbString[ 3 ].Format = CLB_LEFT;
                    ClbString[ 3 ].Length = InterruptType->QueryChCount();

                    ClbRow.Count = 4;

                    ClbAddData( hDlg,
                                IDC_FULL_RES_LIST_INTERRUPTS,
                                &ClbRow );

                } else if( PartialDescriptor->IsDescriptorTypeMemory() ) {
                    Memory = ( PCMEMORY_DESCRIPTOR )PartialDescriptor;
                    if( ( ( ( PMEMORY_DESCRIPTOR )Memory )->GetStartAddress() )->HighPart != 0 ) {
                        StringCchPrintf( MemoryAddressString, 
                                        ARRAYSIZE(MemoryAddressString),
                                        ( LPWSTR )L"%#08x%08x",
                                        ( ( ( PMEMORY_DESCRIPTOR )Memory )->GetStartAddress() )->HighPart,
                                        ( ( ( PMEMORY_DESCRIPTOR )Memory )->GetStartAddress() )->LowPart );
                    } else {
                        StringCchPrintf( MemoryAddressString,
                                        ARRAYSIZE(MemoryAddressString),
                                        ( LPWSTR )L"%#08x",
                                        ( ( ( PMEMORY_DESCRIPTOR )Memory )->GetStartAddress() )->LowPart );
                    }
                    StringCchPrintf( MemoryLengthString,
                                    ARRAYSIZE(MemoryLengthString),   
                                    ( LPWSTR )L"%#x",
                                    Memory->GetLength() );

                    ClbString[ 0 ].String = ( LPWSTR )MemoryAddressString;
                    ClbString[ 0 ].Length = wcslen( MemoryAddressString );
                    ClbString[ 0 ].Format = CLB_LEFT;
                    ClbString[ 1 ].String = ( LPWSTR )MemoryLengthString;
                    ClbString[ 1 ].Format = CLB_LEFT;
                    ClbString[ 1 ].Length = wcslen( MemoryLengthString );
                    if( Memory->IsMemoryReadWrite() ) {
                        MemoryAccess = s_MsgMemReadWrite;
                    } else if( Memory->IsMemoryReadOnly() ){
                        MemoryAccess = s_MsgMemReadOnly;
                    } else {
                        MemoryAccess = s_MsgMemWriteOnly;
                    }
                    ClbString[ 2 ].String = ( LPWSTR )MemoryAccess->GetWSTR();
                    ClbString[ 2 ].Format = CLB_LEFT;
                    ClbString[ 2 ].Length = MemoryAccess->QueryChCount();

                    ClbRow.Count = 3;

                    ClbAddData( hDlg,
                                IDC_FULL_RES_LIST_MEMORY,
                                &ClbRow );

                } else if( PartialDescriptor->IsDescriptorTypeDma() ) {
                    Dma = ( PDMA_DESCRIPTOR )PartialDescriptor;
                    StringCchPrintf( DmaChannelString, ARRAYSIZE(DmaChannelString), ( LPWSTR )L"%d", Dma->GetChannel() );
                    StringCchPrintf( DmaPortString, ARRAYSIZE(DmaPortString), ( LPWSTR )L"%d", Dma->GetPort() );

                    ClbString[ 0 ].String = ( LPWSTR )DmaChannelString;
                    ClbString[ 0 ].Length = wcslen( DmaChannelString );
                    ClbString[ 0 ].Format = CLB_LEFT;
                    ClbString[ 1 ].String = ( LPWSTR )DmaPortString;
                    ClbString[ 1 ].Format = CLB_LEFT;
                    ClbString[ 1 ].Length = wcslen( DmaPortString );

                    ClbRow.Count = 2;

                    ClbAddData( hDlg,
                                IDC_FULL_RES_LIST_DMA,
                                &ClbRow );

                } else if( PartialDescriptor->IsDescriptorTypeDeviceSpecific() ) {
                    DeviceSpecific = ( PDEVICE_SPECIFIC_DESCRIPTOR )PartialDescriptor;
                    StringCchPrintf( Reserved1String, ARRAYSIZE(Reserved1String), ( LPWSTR )L"0x%08x", DeviceSpecific->GetReserved1() );                              
                    StringCchPrintf( Reserved2String, ARRAYSIZE(Reserved2String), ( LPWSTR )L"0x%08x", DeviceSpecific->GetReserved1() );
                    StringCchPrintf( DataSizeString, ARRAYSIZE(DataSizeString), ( LPWSTR )L"%#x", DeviceSpecific->GetData( &AuxPointer ) );

                    ClbString[ 0 ].String = ( LPWSTR )Reserved1String;
                    ClbString[ 0 ].Length = wcslen( Reserved1String );
                    ClbString[ 0 ].Format = CLB_LEFT;
                    ClbString[ 1 ].String = ( LPWSTR )Reserved2String;
                    ClbString[ 1 ].Format = CLB_LEFT;
                    ClbString[ 1 ].Length = wcslen( Reserved2String );
                    ClbString[ 2 ].String = ( LPWSTR )DataSizeString;
                    ClbString[ 2 ].Length = wcslen( DataSizeString );
                    ClbString[ 2 ].Format = CLB_LEFT;

                    ClbRow.Count = 3;

                    ClbAddData( hDlg,
                                IDC_FULL_RES_LIST_DEVICE_SPECIFIC,
                                &ClbRow );

                } else {
                    DebugPrintTrace(( "REGEDT32: Unknown Descriptor \n\n" ));
                    continue;
                }

            }

            DELETE( Iterator );
            //
            // Disble the Display button
            //
            // EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_RESOURCES ), FALSE );
            return( TRUE );
        }

    case WM_COMPAREITEM:
        {
            LPCOMPAREITEMSTRUCT     lpcis;
            LPCLB_ROW               ClbRow1;
            LPCLB_ROW               ClbRow2;
            LONG                    Compare;

            PCPARTIAL_DESCRIPTOR    Descriptor1;
            PCPARTIAL_DESCRIPTOR    Descriptor2;

            lpcis = ( LPCOMPAREITEMSTRUCT ) lParam;
   
            //
            // Extract the two rows to be compared.
            //

            ClbRow1 = ( LPCLB_ROW ) lpcis->itemData1;
            ClbRow2 = ( LPCLB_ROW ) lpcis->itemData2;

            Descriptor1 = ( PCPARTIAL_DESCRIPTOR ) ClbRow1->Data;
            Descriptor2 = ( PCPARTIAL_DESCRIPTOR ) ClbRow2->Data;

            //
            // Sort the Clbs. In the case of DMA and INTERRUPT, sort by channel
            // and vector respectively. For MEMORY and PORT sort by starting
            // physical address.
            //

            switch( lpcis->CtlID ) {

            case IDC_FULL_RES_LIST_DMA:

                //
                //  For DMA, sort by channel and port
                //

                Compare = ( ( PCDMA_DESCRIPTOR )Descriptor1 )->GetChannel() -
                          ( ( PCDMA_DESCRIPTOR )Descriptor2 )->GetChannel();
                if( Compare == 0 ) {
                    Compare = ( ( PCDMA_DESCRIPTOR )Descriptor1 )->GetPort() -
                              ( ( PCDMA_DESCRIPTOR )Descriptor2 )->GetPort();
                }
                break;

            case IDC_FULL_RES_LIST_INTERRUPTS:

                //
                // For INTERRUPT, sort by vector and level
                //

                Compare = ( ( PCINTERRUPT_DESCRIPTOR )Descriptor1 )->GetVector() -
                          ( ( PCINTERRUPT_DESCRIPTOR )Descriptor2 )->GetVector();
                if( Compare == 0 ) {
                    Compare = ( ( PCINTERRUPT_DESCRIPTOR )Descriptor1 )->GetLevel() -
                              ( ( PCINTERRUPT_DESCRIPTOR )Descriptor2 )->GetLevel();
                }
                break;

            case IDC_FULL_RES_LIST_MEMORY:

                //
                // For MEMORY sort by physical address
                //

                Compare = ( ( ( PMEMORY_DESCRIPTOR )Descriptor1 )->GetStartAddress() )->HighPart -
                          ( ( ( PMEMORY_DESCRIPTOR )Descriptor2 )->GetStartAddress() )->HighPart;
                if( Compare == 0 ) {
                    Compare = ( ( ( PMEMORY_DESCRIPTOR )Descriptor1 )->GetStartAddress() )->LowPart -
                              ( ( ( PMEMORY_DESCRIPTOR )Descriptor2 )->GetStartAddress() )->LowPart;
                }
                break;

            case IDC_FULL_RES_LIST_PORTS:

                //
                // For PORT sort by physical address
                //

                Compare = ( ( ( PPORT_DESCRIPTOR )Descriptor1 )->GetPhysicalAddress() )->HighPart -
                          ( ( ( PPORT_DESCRIPTOR )Descriptor2 )->GetPhysicalAddress() )->HighPart;
                if( Compare == 0 ) {
                    Compare = ( ( ( PPORT_DESCRIPTOR )Descriptor1 )->GetPhysicalAddress() )->LowPart -
                              ( ( ( PPORT_DESCRIPTOR )Descriptor2 )->GetPhysicalAddress() )->LowPart;
                }
                break;

            }
            return Compare;
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) {

            case IDOK:
            case IDCANCEL:

                EndDialog( hDlg, TRUE );
                return( TRUE );

            case IDC_FULL_RES_LIST_DMA:

                switch( HIWORD( wParam )) {

                case LBN_SELCHANGE:
                    {

                        PCPARTIAL_DESCRIPTOR   Descriptor;

                        LastSelectedDevSpecific = NULL;
                        //
                        // Remove the selection from the other list boxes
                        //
                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_INTERRUPTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );
                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_MEMORY,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_PORTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DEVICE_SPECIFIC,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        //
                        // Get the PARTIAL_DESCRIPTOR for the currently selected
                        // resource and update the share disposition display.
                        //

                        Descriptor = ( PCPARTIAL_DESCRIPTOR )_GetSelectedItem( hDlg,
                                                                              LOWORD( wParam ) );

                        if( Descriptor != NULL ) 
                        {
                            _UpdateShareDisplay( hDlg, Descriptor );
                        }
                        //
                        //  Disable the Data... button.
                        //
                        EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_DATA ),
                                      FALSE );

                        return( TRUE );
                    }

                }
                break;

            case IDC_FULL_RES_LIST_INTERRUPTS:

                switch( HIWORD( wParam )) {

                case LBN_SELCHANGE:
                    {

                        PCPARTIAL_DESCRIPTOR   Descriptor;

                        LastSelectedDevSpecific = NULL;
                        //
                        // Remove the selection from the other list boxes
                        //
                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DMA,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_MEMORY,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_PORTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DEVICE_SPECIFIC,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        //
                        // Get the PARTIAL_DESCRIPTOR for the currently selected
                        // resource and update the share disposition display.
                        //

                        Descriptor = ( PCPARTIAL_DESCRIPTOR )_GetSelectedItem( hDlg,
                                                                              LOWORD( wParam ) );

                        if( Descriptor != NULL ) 
                        {
                            _UpdateShareDisplay( hDlg, Descriptor );
                        }
                        //
                        //  Disable the Data... button.
                        //
                        EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_DATA ),
                                      FALSE );

                        return( TRUE );
                    }

                }
                break;

            case IDC_FULL_RES_LIST_MEMORY:

                switch( HIWORD( wParam )) {

                case LBN_SELCHANGE:
                    {

                        PCPARTIAL_DESCRIPTOR   Descriptor;

                        LastSelectedDevSpecific = NULL;
                        //
                        // Remove the selection from the other list boxes
                        //
                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DMA,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_INTERRUPTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_PORTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DEVICE_SPECIFIC,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        //
                        // Get the PARTIAL_DESCRIPTOR for the currently selected
                        // resource and update the share disposition display.
                        //

                        Descriptor = ( PCPARTIAL_DESCRIPTOR )_GetSelectedItem( hDlg,
                                                                              LOWORD( wParam ) );

                        if( Descriptor != NULL ) 
                        {
                            _UpdateShareDisplay( hDlg, Descriptor );
                        }
                        //
                        //  Disable the Data... button.
                        //
                        EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_DATA ),
                                      FALSE );

                        return( TRUE );
                    }

                }
                break;

            case IDC_FULL_RES_LIST_PORTS:

                switch( HIWORD( wParam )) {

                case LBN_SELCHANGE:
                    {
                        PCPARTIAL_DESCRIPTOR   Descriptor;

                        LastSelectedDevSpecific = NULL;
                        //
                        // Remove the selection from the other list boxes
                        //
                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DMA,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_INTERRUPTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_MEMORY,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DEVICE_SPECIFIC,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        //
                        // Get the PARTIAL_DESCRIPTOR for the currently selected
                        // resource and update the share disposition display.
                        //

                        Descriptor = ( PCPARTIAL_DESCRIPTOR )_GetSelectedItem( hDlg,
                                                                              LOWORD( wParam ) );

                        if( Descriptor != NULL ) 
                        {
                            _UpdateShareDisplay( hDlg, Descriptor );
                        }
                        //
                        //  Disable the Data... button.
                        //
                        EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_DATA ),
                                      FALSE );

                        return( TRUE );
                    }

                }
                break;

            case IDC_FULL_RES_LIST_DEVICE_SPECIFIC:

                switch( HIWORD( wParam )) {

                case LBN_SELCHANGE:
                    {

                        PCPARTIAL_DESCRIPTOR   Descriptor;
                        PCBYTE                 Pointer;

                        //
                        // Remove the selection from the other list boxes
                        //
                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_DMA,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_INTERRUPTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_MEMORY,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        SendDlgItemMessage( hDlg,
                                            IDC_FULL_RES_LIST_PORTS,
                                            LB_SETCURSEL,
                                            (WPARAM) -1,
                                            0 );

                        //
                        // Get the PARTIAL_DESCRIPTOR for the currently selected
                        // resource and update the share disposition display.
                        //

                        Descriptor = ( PCPARTIAL_DESCRIPTOR )_GetSelectedItem( hDlg,
                                                                              LOWORD( wParam ) );
                        LastSelectedDevSpecific = ( PCDEVICE_SPECIFIC_DESCRIPTOR )Descriptor;

                        if( Descriptor != NULL ) 
                        {
                            _UpdateShareDisplay( hDlg, Descriptor );
                        }
                        //
                        //  Enable the Data... button if necessary.
                        //

                        EnableWindow( GetDlgItem( hDlg, IDC_PUSH_DISPLAY_DATA ),
                                      ( ( Descriptor != NULL ) &&
                                        Descriptor->IsDescriptorTypeDeviceSpecific() &&
                                        ( ( ( PCDEVICE_SPECIFIC_DESCRIPTOR )Descriptor )->GetData( &Pointer ) != 0 )
                                      )
                                    );

                        return( TRUE );
                    }


                case LBN_DBLCLK:
                    {

                        //
                        // Simulate that the details button was pushed
                        //

                        SendMessage( hDlg,
                                     WM_COMMAND,
                                     MAKEWPARAM( IDC_PUSH_DISPLAY_DATA, BN_CLICKED ),
                                     ( LPARAM ) GetDlgItem( hDlg, IDC_PUSH_DISPLAY_DATA ) );
                        return( TRUE ); //  0;
                    }

                }
                break;

            case IDC_PUSH_DISPLAY_DATA:
                {
                    //
                    //  Display the device specific data
                    //
                    if( ( LastSelectedDevSpecific != NULL ) &&
                        ( ( Size = LastSelectedDevSpecific->GetData( &Pointer ) ) != 0 )
                      ) 
                    {
                        _DisplayBinaryData( hDlg, Pointer, Size);
                    }
                    return( TRUE );
                }
                break;
            }
    }
    return( FALSE );
}


//------------------------------------------------------------------------------
//  _DisplayRequirementsListDialogProc
//
//  DESCRIPTION: The dialog procedure for displaying data of type 
//               REG_RESOURCE_REQUIREMENTS_LIST.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
INT_PTR CALLBACK REGISTRY_DATA::_DisplayRequirementsListDialogProc(HWND hDlg, UINT dwMsg,
                     WPARAM  wParam, LPARAM lParam)
{

    switch(dwMsg) 
    {
        case WM_INITDIALOG:
        {
            LPCWSTR                 InterfaceString;
            LPCWSTR                 DescriptorTypeString;
            ULONG                   StringSize;
            PCIO_REQUIREMENTS_LIST  RequirementsList;
            WCHAR                   BusNumberString[ MAX_LENGTH_DWORD_STRING ];
            WCHAR                   SlotNumberString[ MAX_LENGTH_DWORD_STRING ];

            PARRAY                  AlternativeLists;
            PITERATOR               AlternativeListsIterator;
            ULONG                   AlternativeListNumber;
            WCHAR                   AlternativeListNumberString[ MAX_LENGTH_DWORD_STRING ];

            PCIO_DESCRIPTOR_LIST    IoDescriptorList;

            CLB_ROW         ClbRow;
            CLB_STRING      ClbString[ ] = {
                                { NULL, 0, CLB_LEFT, NULL },
                                { NULL, 0, CLB_LEFT, NULL },
                                { NULL, 0, CLB_LEFT, NULL },
                                { NULL, 0, CLB_LEFT, NULL }
                             };


            if( ( RequirementsList = ( PCIO_REQUIREMENTS_LIST )lParam ) == NULL ) {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }

            //
            //  Write the interface type
            //

            switch( RequirementsList->GetInterfaceType() ) {

            case Internal:

                InterfaceString = s_MsgBusInternal->GetWSTR();
                break;

            case Isa:

                InterfaceString = s_MsgBusIsa->GetWSTR();
                break;

            case Eisa:

                InterfaceString = s_MsgBusEisa->GetWSTR();
                break;

            case MicroChannel:

                InterfaceString = s_MsgBusMicroChannel->GetWSTR();
                break;

            case TurboChannel:

                InterfaceString = s_MsgBusTurboChannel->GetWSTR();
                break;

            case PCIBus:

                InterfaceString = s_MsgBusPCIBus->GetWSTR();
                break;

            case VMEBus:

                InterfaceString = s_MsgBusVMEBus->GetWSTR();
                break;

            case NuBus:

                InterfaceString = s_MsgBusNuBus->GetWSTR();
                break;

            case PCMCIABus:

                InterfaceString = s_MsgBusPCMCIABus->GetWSTR();
                break;

            case CBus:

                InterfaceString = s_MsgBusCBus->GetWSTR();
                break;

            case MPIBus:

                InterfaceString = s_MsgBusMPIBus->GetWSTR();
                break;

            case MPSABus:

                InterfaceString = s_MsgBusMPSABus->GetWSTR();
                break;

            default:

                InterfaceString = s_MsgInvalid->GetWSTR();
                break;
            }

            SendDlgItemMessage( hDlg,
                                IDC_IO_REQ_TEXT_INTERFACE_TYPE,
                                WM_SETTEXT,
                                0,
                                ( LPARAM )InterfaceString );

            //
            //  Write the bus number
            //

            StringCchPrintf( BusNumberString, ARRAYSIZE(BusNumberString), ( LPWSTR )L"%d", RequirementsList->GetBusNumber() );

            SendDlgItemMessage( hDlg,
                                IDC_IO_REQ_TEXT_BUS_NUMBER,
                                WM_SETTEXT,
                                0,
                                ( LPARAM )BusNumberString );

            //
            //  Write the slot number
            //

            StringCchPrintf( SlotNumberString, ARRAYSIZE(SlotNumberString), ( LPWSTR )L"%d", RequirementsList->GetSlotNumber() );

            SendDlgItemMessage( hDlg,
                                IDC_IO_REQ_TEXT_SLOT_NUMBER,
                                WM_SETTEXT,
                                0,
                                ( LPARAM )SlotNumberString );

            //
            //  Write the entries in the column list box
            //
            if( ( ( AlternativeLists = RequirementsList->GetAlternativeLists() ) == NULL ) ||
                ( ( AlternativeListsIterator = AlternativeLists->QueryIterator() ) == NULL ) ) {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }

            AlternativeListNumber = 0;
            while( ( IoDescriptorList = ( PCIO_DESCRIPTOR_LIST )AlternativeListsIterator->GetNext() ) != NULL ) {

                PARRAY          IoDescriptors;
                PITERATOR       IoDescriptorListIterator;
                PCIO_DESCRIPTOR Descriptor;
                ULONG           SubListNumber;
                WCHAR           SubListNumberString[ MAX_LENGTH_DWORD_STRING ];
                ULONG           DescriptorNumber;
                WCHAR           DescriptorNumberString[ MAX_LENGTH_DWORD_STRING ];


                if( ( ( IoDescriptors = ( PARRAY )IoDescriptorList->GetDescriptorsList() ) == NULL ) ||
                    ( ( IoDescriptorListIterator = IoDescriptors->QueryIterator() ) == NULL ) ) {
                    DELETE( AlternativeListsIterator );
                    EndDialog( hDlg, 0 );
                    return( TRUE );
                }

                AlternativeListNumber++;
                StringCchPrintf( AlternativeListNumberString, ARRAYSIZE(AlternativeListNumberString), ( LPWSTR )L"%d", AlternativeListNumber );

                SubListNumber = 0;
                while( ( Descriptor = ( PCIO_DESCRIPTOR )IoDescriptorListIterator->GetNext() ) != NULL ) {
                    if( ( !Descriptor->IsResourceOptionAlternative() ) ||
                        ( SubListNumber == 0 ) ) {
                        SubListNumber++;
                        DescriptorNumber = 0;
                    }
                    DescriptorNumber++;

                    StringCchPrintf( SubListNumberString, ARRAYSIZE(SubListNumberString), ( LPWSTR )L"%d", SubListNumber );

                    StringCchPrintf( DescriptorNumberString, ARRAYSIZE(DescriptorNumberString), ( LPWSTR )L"%d", DescriptorNumber );

                    if( Descriptor->IsDescriptorTypePort() ) {
                        DescriptorTypeString = s_MsgDevPort->GetWSTR();
                        StringSize = s_MsgDevPort->QueryChCount();
                    } else if( Descriptor->IsDescriptorTypeInterrupt() ) {
                        DescriptorTypeString = s_MsgDevInterrupt->GetWSTR();
                        StringSize = s_MsgDevInterrupt->QueryChCount();
                    } else if( Descriptor->IsDescriptorTypeMemory() ) {
                        DescriptorTypeString = s_MsgDevMemory->GetWSTR();
                        StringSize = s_MsgDevMemory->QueryChCount();
                    } else if( Descriptor->IsDescriptorTypeDma() ) {
                        DescriptorTypeString = s_MsgDevDma->GetWSTR();
                        StringSize = s_MsgDevDma->QueryChCount();
                    } else {
                        DescriptorTypeString = s_MsgInvalid->GetWSTR();
                        StringSize = s_MsgInvalid->QueryChCount();
                    }

                    ClbString[ 0 ].String = ( LPWSTR )AlternativeListNumberString;
                    ClbString[ 0 ].Length = wcslen( AlternativeListNumberString );
                    ClbString[ 0 ].Format = CLB_LEFT;
                    ClbString[ 1 ].String = ( LPWSTR )SubListNumberString;
                    ClbString[ 1 ].Format = CLB_LEFT;
                    ClbString[ 1 ].Length = wcslen( SubListNumberString );
                    ClbString[ 2 ].String = ( LPWSTR )DescriptorNumberString;
                    ClbString[ 2 ].Format = CLB_LEFT;
                    ClbString[ 2 ].Length = wcslen( DescriptorNumberString );
                    ClbString[ 3 ].String = ( LPWSTR )DescriptorTypeString;
                    ClbString[ 3 ].Format = CLB_LEFT;
                    ClbString[ 3 ].Length = StringSize;

                    ClbRow.Count = 4;
                    ClbRow.Strings = ClbString;
                    ClbRow.Data = ( PVOID )Descriptor;

                    ClbAddData( hDlg,
                                IDC_IO_LIST_ALTERNATIVE_LISTS,
                                &ClbRow );

                }
                DELETE( IoDescriptorListIterator );
            }
            DELETE( AlternativeListsIterator );

            //
            // Disble the Display button
            //
            EnableWindow( GetDlgItem( hDlg, IDC_IO_REQ_PUSH_DISPLAY_DEVICE ), FALSE );
            return( TRUE );
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) {

                case IDOK:
                case IDCANCEL:

                    EndDialog( hDlg, TRUE );
                    return( TRUE );

                case IDC_IO_LIST_ALTERNATIVE_LISTS:
                {

                    switch( HIWORD( wParam )) {

                        case LBN_SELCHANGE:
                        {

                            //
                            // Enable the display device details button
                            //

                            EnableWindow( GetDlgItem( hDlg, IDC_IO_REQ_PUSH_DISPLAY_DEVICE ),
                                          TRUE );
                            return 0;
                        }

                        case LBN_DBLCLK:
                        {

                            //
                            // Simulate that the details button was pushed
                            //

                            SendMessage( hDlg,
                                         WM_COMMAND,
                                         MAKEWPARAM( IDC_IO_REQ_PUSH_DISPLAY_DEVICE, BN_CLICKED ),
                                         ( LPARAM ) GetDlgItem( hDlg, IDC_IO_REQ_PUSH_DISPLAY_DEVICE ) );
                            return 0;
                        }
                    }
                    break;
                }

                case IDC_IO_REQ_PUSH_DISPLAY_DEVICE:
                {
                    PCIO_DESCRIPTOR IoDescriptor;

                    IoDescriptor = ( PCIO_DESCRIPTOR )( _GetSelectedItem ( hDlg, IDC_IO_LIST_ALTERNATIVE_LISTS ) );
                    if( IoDescriptor != NULL ) 
                    {
                        _DisplayIoDescriptor( hDlg, IoDescriptor );
                    }
                    return( TRUE );
                }
            }
    }
    return( FALSE );
}


//------------------------------------------------------------------------------
//  _DisplayIoPortDialogProc
//
//  DESCRIPTION: The dialog proceedure for displaying an object of type IO_PORT.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
INT_PTR
CALLBACK
REGISTRY_DATA::_DisplayIoPortDialogProc(HWND hDlg, UINT dwMsg, WPARAM wParam, LPARAM lParam)
{
    switch(dwMsg) 
    {
        case WM_INITDIALOG:
        {
            PCIO_PORT_DESCRIPTOR   Port;
            PCWSTRING              String;
            WCHAR                  AddressString[ MAX_LENGTH_BIG_INT_STRING ];

            if( ( Port = ( PCIO_PORT_DESCRIPTOR )lParam ) == NULL ) {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }

            //
            // Write the port type
            //

            if( Port->IsPortMemory() ) {
                String = s_MsgPortMemory;
            } else if( Port->IsPortIo() ){
                String = s_MsgPortPort;
            } else {
                String = s_MsgInvalid;
            }
            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_PORT_TYPE,
                               WM_SETTEXT,
                               0,
                               ( LPARAM ) String->GetWSTR() );

            //
            // Write the length
            //
            StringCchPrintf( AddressString, ARRAYSIZE(AddressString), ( LPWSTR )L"%#x", Port->GetLength() );

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_PORT_LENGTH,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            // Write the alignment
            //
            StringCchPrintf( AddressString, ARRAYSIZE(AddressString), ( LPWSTR )L"%#x", Port->GetAlignment() );

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_PORT_ALIGNMENT,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            // Write the minimum address
            //

            if( ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMinimumAddress() )->HighPart != 0 ) 
            {
                StringCchPrintf( AddressString,
                                ARRAYSIZE(AddressString), 
                                ( LPWSTR )L"0x%08x%08x",
                                ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMinimumAddress() )->HighPart,
                                ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMinimumAddress() )->LowPart );
            } 
            else 
            {
                StringCchPrintf( AddressString,
                                ARRAYSIZE(AddressString), 
                                ( LPWSTR )L"0x%08x",
                                ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMinimumAddress() )->LowPart );
            }

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_PORT_MIN_ADDRESS,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            // Write the maximum address
            //

            if( ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMaximumAddress() )->HighPart != 0 ) 
            {
                StringCchPrintf( AddressString,
                                ARRAYSIZE(AddressString), 
                                ( LPWSTR )L"0x%08x%08x",
                                ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMaximumAddress() )->HighPart,
                                ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMaximumAddress() )->LowPart );
            } 
            else 
            {
                StringCchPrintf( AddressString,
                                ARRAYSIZE(AddressString), 
                                ( LPWSTR )L"0x%08x",
                                ( ( ( PIO_PORT_DESCRIPTOR )Port )->GetMaximumAddress() )->LowPart );
            }
            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_PORT_MAX_ADDRESS,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            //  Write share disposition
            //

            if( Port->IsResourceShareUndetermined() ) {
                String = s_MsgShareUndetermined;
            } else if( Port->IsResourceShareDeviceExclusive() ) {
                String = s_MsgShareDeviceExclusive;
            } else if( Port->IsResourceShareDriverExclusive() ) {
                String = s_MsgShareDriverExclusive;
            } else if( Port->IsResourceShareShared() ) {
                String = s_MsgShareShared;
            } else {
                String = s_MsgInvalid;
            }

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_DISPOSITION,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )String->GetWSTR() );
            //
            // Set the Options
            //
            _UpdateOptionDisplay( hDlg, ( PCIO_DESCRIPTOR )Port );
            return( TRUE );
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) {

                case IDOK:
                case IDCANCEL:

                    EndDialog( hDlg, TRUE );
                    return( TRUE );

            }
    }
    return( FALSE );
}


//------------------------------------------------------------------------------
//  _DisplayIoMemoryDialogProc
//
//  DESCRIPTION: The dialog proceedure for displaying an object of type IO_PORT.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
INT_PTR CALLBACK REGISTRY_DATA::_DisplayIoMemoryDialogProc(HWND hDlg, UINT dwMsg, WPARAM wParam, LPARAM lParam)
{
    switch(dwMsg) 
    {
        case WM_INITDIALOG:
        {
            PCIO_MEMORY_DESCRIPTOR Memory;
            PCWSTRING              String;
            WCHAR                  AddressString[ MAX_LENGTH_BIG_INT_STRING ];

            if( ( Memory = ( PCIO_MEMORY_DESCRIPTOR )lParam ) == NULL ) 
            {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }

            //
            // Write the memory access
            //

            if( Memory->IsMemoryReadWrite() ) {
                String = s_MsgMemReadWrite;
            } else if( Memory->IsMemoryReadOnly() ){
                String = s_MsgMemReadOnly;
            } else if( Memory->IsMemoryWriteOnly() ){
                String = s_MsgMemWriteOnly;
            } else {
                String = s_MsgInvalid;
            }
            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_MEM_ACCESS,
                               WM_SETTEXT,
                               0,
                               ( LPARAM ) String->GetWSTR() );

            //
            // Write the length
            //
            StringCchPrintf( AddressString, ARRAYSIZE(AddressString), ( LPWSTR )L"%#x", Memory->GetLength() );

            SendDlgItemMessage( hDlg, IDC_IO_TEXT_MEM_LENGTH, WM_SETTEXT, 0, ( LPARAM )AddressString );

            //
            // Write the alignment
            //
            StringCchPrintf( AddressString, ARRAYSIZE(AddressString), ( LPWSTR )L"%#x", Memory->GetAlignment() );

            SendDlgItemMessage( hDlg, IDC_IO_TEXT_MEM_ALIGNMENT, WM_SETTEXT, 0, ( LPARAM )AddressString );

            //
            // Write the minimum address
            //
            if( ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMinimumAddress() )->HighPart != 0 ) 
            {
                StringCchPrintf( AddressString,
                                ARRAYSIZE(AddressString), 
                                ( LPWSTR )L"0x%08x%08x",
                                ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMinimumAddress() )->HighPart,
                                ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMinimumAddress() )->LowPart );
            } 
            else 
            {
                StringCchPrintf( AddressString,
                                ARRAYSIZE(AddressString), 
                                ( LPWSTR )L"0x%08x",
                                ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMinimumAddress() )->LowPart );
            }

            SendDlgItemMessage( hDlg, IDC_IO_TEXT_MEM_MIN_ADDRESS, WM_SETTEXT, 0, ( LPARAM )AddressString );

            //
            // Write the maximum address
            //
            if( ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMaximumAddress() )->HighPart != 0 ) 
            {
                StringCchPrintf( AddressString,
                                ARRAYSIZE(AddressString), 
                                ( LPWSTR )L"0x%08x%08x",
                                ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMaximumAddress() )->HighPart,
                                ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMaximumAddress() )->LowPart );
            } 
            else 
            {
                StringCchPrintf( AddressString,
                                ARRAYSIZE(AddressString), 
                                ( LPWSTR )L"0x%08x",
                                ( ( ( PIO_MEMORY_DESCRIPTOR )Memory )->GetMaximumAddress() )->LowPart );
            }
            SendDlgItemMessage( hDlg, IDC_IO_TEXT_MEM_MAX_ADDRESS, WM_SETTEXT, 0, ( LPARAM )AddressString );

            //
            //  Write share disposition
            //

            if( Memory->IsResourceShareUndetermined() ) {
                String = s_MsgShareUndetermined;
            } else if( Memory->IsResourceShareDeviceExclusive() ) {
                String = s_MsgShareDeviceExclusive;
            } else if( Memory->IsResourceShareDriverExclusive() ) {
                String = s_MsgShareDriverExclusive;
            } else if( Memory->IsResourceShareShared() ) {
                String = s_MsgShareShared;
            } else {
                String = s_MsgInvalid;
            }

            SendDlgItemMessage( hDlg, IDC_IO_TEXT_DISPOSITION, WM_SETTEXT, 0, ( LPARAM )String->GetWSTR() );
            //
            // Set the Options
            //
            _UpdateOptionDisplay( hDlg, ( PCIO_DESCRIPTOR )Memory );
            return( TRUE );
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) {

                case IDOK:
                case IDCANCEL:

                    EndDialog( hDlg, TRUE );
                    return( TRUE );

            }
    }
    return( FALSE );
}


//------------------------------------------------------------------------------
//  _DisplayIoInterruptDialogProc
//
//  DESCRIPTION: The dialog proceedure for displaying an object of type IO_PORT.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
INT_PTR CALLBACK REGISTRY_DATA::_DisplayIoInterruptDialogProc(HWND hDlg, UINT dwMsg,
                        WPARAM  wParam, LPARAM lParam)
{
    switch( dwMsg ) 
    {
        case WM_INITDIALOG:
        {
            PCIO_INTERRUPT_DESCRIPTOR Interrupt;
            PCWSTRING                 String;
            WCHAR                     AddressString[ MAX_LENGTH_DWORD_STRING ];

            if( ( Interrupt = ( PCIO_INTERRUPT_DESCRIPTOR )lParam ) == NULL ) 
            {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }

            //
            // Write the interrupt type
            //

            if( Interrupt->IsInterruptLevelSensitive() ) 
            {
                String = s_MsgIntLevelSensitive;
            } 
            else if( Interrupt->IsInterruptLatched() )
            {
                String = s_MsgIntLatched;
            } 
            else 
            {
                String = s_MsgInvalid;
            }
            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_INT_TYPE,
                               WM_SETTEXT,
                               0,
                               ( LPARAM ) String->GetWSTR() );

            //
            // Write the minimum vector
            //
            StringCchPrintf( AddressString, ARRAYSIZE(AddressString), ( LPWSTR )L"%#x", Interrupt->GetMinimumVector() );

            SendDlgItemMessage( hDlg, IDC_IO_TEXT_INT_MIN_VECTOR, WM_SETTEXT, 0, ( LPARAM )AddressString );

            //
            // Write the maximum vector
            //
            StringCchPrintf( AddressString, ARRAYSIZE(AddressString), ( LPWSTR )L"%#x", Interrupt->GetMaximumVector() );

            SendDlgItemMessage( hDlg, IDC_IO_TEXT_INT_MAX_VECTOR, WM_SETTEXT, 0, ( LPARAM )AddressString );

            //
            //  Write share disposition
            //

            if( Interrupt->IsResourceShareUndetermined() ) 
            {
                String = s_MsgShareUndetermined;
            }
            else if( Interrupt->IsResourceShareDeviceExclusive() ) 
            {
                String = s_MsgShareDeviceExclusive;
            } 
            else if( Interrupt->IsResourceShareDriverExclusive() ) 
            {
                String = s_MsgShareDriverExclusive;
            } 
            else if( Interrupt->IsResourceShareShared() ) 
            {
                String = s_MsgShareShared;
            } else 
            {
                String = s_MsgInvalid;
            }

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_DISPOSITION,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )String->GetWSTR() );
            //
            // Set the Options
            //
            _UpdateOptionDisplay( hDlg, ( PCIO_DESCRIPTOR )Interrupt );
            return( TRUE );
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) 
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog( hDlg, TRUE );
                    return( TRUE );
            }
    }
    return( FALSE );
}


//------------------------------------------------------------------------------
//  _DisplayIoDmaDialogProc
//
//  DESCRIPTION: The dialog procedure for displaying an object of type IO_PORT.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
INT_PTR CALLBACK REGISTRY_DATA::_DisplayIoDmaDialogProc(HWND hDlg, UINT dwMsg, WPARAM  wParam,
                    LPARAM lParam)
{

    switch(dwMsg) 
    {
        case WM_INITDIALOG:
        {
            PCIO_DMA_DESCRIPTOR Dma;
            PCWSTRING           String;
            WCHAR               AddressString[ MAX_LENGTH_DWORD_STRING ];

            if( ( Dma = ( PCIO_DMA_DESCRIPTOR )lParam ) == NULL ) 
            {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }

            //
            // Write the minimum channel
            //
            StringCchPrintf( AddressString, ARRAYSIZE(AddressString), ( LPWSTR )L"%#x", Dma->GetMinimumChannel() );

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_DMA_MIN_CHANNEL,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )AddressString );

            //
            // Write the maximum channel
            //
            StringCchPrintf( AddressString, ARRAYSIZE(AddressString), ( LPWSTR )L"%#x", Dma->GetMaximumChannel() );

            SendDlgItemMessage( hDlg, IDC_IO_TEXT_DMA_MAX_CHANNEL, WM_SETTEXT, 0, ( LPARAM )AddressString );

            //
            //  Write share disposition
            //

            if( Dma->IsResourceShareUndetermined() ) {
                String = s_MsgShareUndetermined;
            } else if( Dma->IsResourceShareDeviceExclusive() ) {
                String = s_MsgShareDeviceExclusive;
            } else if( Dma->IsResourceShareDriverExclusive() ) {
                String = s_MsgShareDriverExclusive;
            } else if( Dma->IsResourceShareShared() ) {
                String = s_MsgShareShared;
            } else {
                String = s_MsgInvalid;
            }

            SendDlgItemMessage( hDlg,
                               IDC_IO_TEXT_DISPOSITION,
                               WM_SETTEXT,
                               0,
                               ( LPARAM )String->GetWSTR() );
            //
            // Set the Options
            //
            _UpdateOptionDisplay( hDlg, ( PCIO_DESCRIPTOR )Dma );
            return( TRUE );
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) {

                case IDOK:
                case IDCANCEL:

                    EndDialog( hDlg, TRUE );
                    return( TRUE );

            }
    }
    return( FALSE );
}



//------------------------------------------------------------------------------
//  _GetSelectedItem
//
//  DESCRIPTION: Retrieve the object associated to the currently selected row in
//               a Clb.
//
//  PARAMETERS:  hDlg    - Supplies the handle for the dialog that contains the 
//                         selected Clb.
//               ClbId   - Id of the Clb that contains the selected row.
//------------------------------------------------------------------------------
PVOID REGISTRY_DATA::_GetSelectedItem (HWND hDlg, ULONG ClbId)
{
    LONG                Index;
    LPCLB_ROW           ClbRow;
    PVOID               Descriptor;

    // Get the index of the currently selected item.
    Index = (LONG)SendDlgItemMessage(hDlg, ClbId, LB_GETCURSEL, 0, 0);
    if( Index == LB_ERR ) 
    {
        return NULL;
    }

    // Get the CLB_ROW object for this row and extract the associated
    // object.
    ClbRow = ( LPCLB_ROW ) SendDlgItemMessage(hDlg, ClbId, LB_GETITEMDATA, (WPARAM) Index, 0);
    if(( ClbRow == NULL ) || (( LONG_PTR ) ClbRow ) == LB_ERR ) 
    {
        return NULL;
    }

    Descriptor = ClbRow->Data;
    if( Descriptor == NULL ) 
    {
        return NULL;
    }
    return Descriptor;
}


//------------------------------------------------------------------------------
//  _UpdateShareDisplay
//
//  DESCRIPTION: UpdateShareDisplay hilights the appropriate sharing disposition text in
//               the supplied dialog based on the share disposition of the PARTIAL_DESCRIPTOR
//               object supplied.
//
//  PARAMETERS:  hWnd - Supplies window handle for the dialog box where share
//                      display is being updated.
//               pDescriptor - Supplies a pointer to a PARTIAL_DESCRIPTOR object whose
//                      share disposition will be displayed.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_UpdateShareDisplay(HWND hDlg, PCPARTIAL_DESCRIPTOR pDescriptor)
{
    if(pDescriptor) 
    {
        EnableWindow( GetDlgItem( hDlg, IDC_FULL_RES_TEXT_UNDETERMINED ),
                      pDescriptor->IsResourceShareUndetermined() );

        EnableWindow( GetDlgItem( hDlg, IDC_FULL_RES_TEXT_DEVICE_EXCLUSIVE ),
                      pDescriptor->IsResourceShareDeviceExclusive() );

        EnableWindow( GetDlgItem( hDlg, IDC_FULL_RES_TEXT_DRIVER_EXCLUSIVE ),
                      pDescriptor->IsResourceShareDriverExclusive() );

        EnableWindow( GetDlgItem( hDlg,IDC_FULL_RES_TEXT_SHARED ),
                      pDescriptor->IsResourceShareShared() );
    }
}


//------------------------------------------------------------------------------
//  _UpdateOptionDisplay
//
//  DESCRIPTION: UpdateOptionDisplay highlights the appropriate Option text in
//               the supplied IO_DESCRIPTOR dialog based on the Option of the
//               IO_DESCRIPTOR object supplied.
//
//  PARAMETERS:  hWnd - Supplies window handle for the dialog box where share
//                      display is being updated.
//               pDescriptor - Supplies a pointer to a PARTIAL_DESCRIPTOR object whose
//                      share disposition will be displayed.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_UpdateOptionDisplay(HWND hDlg, PCIO_DESCRIPTOR pDescriptor)
{
    if(pDescriptor) 
    {
        EnableWindow( GetDlgItem( hDlg, IDC_IO_TEXT_OPTION_PREFERRED ),
                      pDescriptor->IsResourceOptionPreferred() );

        EnableWindow( GetDlgItem( hDlg, IDC_IO_TEXT_OPTION_ALTERNATIVE ),
                      pDescriptor->IsResourceOptionAlternative() );
    }
}



VOID DisplayBinaryData(HWND hWnd, LPEDITVALUEPARAM lpEditValueParam, DWORD dwValueType)
{
    PBYTE pbValueData = lpEditValueParam->pValueData;
    UINT  cbValueData = lpEditValueParam->cbValueData;

    REGISTRY_DATA::_DisplayBinaryData(hWnd, pbValueData, cbValueData,
        TRUE, dwValueType);
}

//------------------------------------------------------------------------------
//  _DisplayBinaryData
//
//  DESCRIPTION: Display the contents of a buffer as binary data, in an hd-like 
//               format.
//
//  PARAMETERS:   hWnd - A handle to the owner window.
//                Data - Pointer to the buffer that contains the data to be displayed.
//                DataSize - Number of bytes in the buffer.
//                DisplayValueType - A flag that indicates whether or not the value type of the
//                  data should be displayed as a binary number.
//                ValueType - A number representing the data type. This parameter is ignored if
//                  DisplayValueTRype is FALSE.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DisplayBinaryData(HWND hWnd, PCBYTE  Data, ULONG   DataSize,
    BOOL fDisplayValueType, DWORD dwValueType)
{
    BUFFER_INFORMATION  BufferInfo;

    BufferInfo.Buffer = ( PBYTE )Data;
    BufferInfo.BufferSize = DataSize;
    BufferInfo.DisplayValueType = fDisplayValueType;
    BufferInfo.ValueType = dwValueType;
    DialogBoxParam(g_hInstance,
                   ( BufferInfo.DisplayValueType )? MAKEINTRESOURCE( IDD_DISPLAY_BINARY_DATA_VALUE_TYPE ) :
                                                    MAKEINTRESOURCE( IDD_DISPLAY_BINARY_DATA ),
                   hWnd,
                   REGISTRY_DATA::_DisplayBinaryDataDialogProc,
                   ( LPARAM )&BufferInfo );
}


//------------------------------------------------------------------------------
//  _DisplayBinaryDataDialogProc
//
//  DESCRIPTION: This is the dialog procedure used in the dialog that displays
//               the data in a value entry as binary data, using a format similar
//               to the one used by the 'hd' utility.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               dwMsg - the message passed from Windows.
//               wParam - extra message dependent data.
//               lParam - extra message dependent data.
//------------------------------------------------------------------------------
INT_PTR CALLBACK REGISTRY_DATA::_DisplayBinaryDataDialogProc(HWND hDlg, UINT dwMsg, WPARAM wParam, 
            LPARAM lParam)
{
    STATIC  PCBYTE  Data;
    STATIC  ULONG   Size;
    STATIC  ULONG   CurrentFormat;
    STATIC  BOOL    DisplayValueType;
    STATIC  ULONG   ValueType;


    switch( dwMsg ) 
    {
        case WM_INITDIALOG:
        {
            WCHAR   AuxBuffer[16];
            //
            // Validate arguments and initialize static data
            //
            if( lParam == NULL ) {
                EndDialog( hDlg, 0 );
                return( TRUE );
            }
            Data = ( ( PBUFFER_INFORMATION )lParam )->Buffer;
            Size = ( ( PBUFFER_INFORMATION )lParam )->BufferSize;
            DisplayValueType = ( ( PBUFFER_INFORMATION )lParam )->DisplayValueType;
            ValueType = ( ( PBUFFER_INFORMATION )lParam )->ValueType;

            //
            // Display value type as an hex number if necessary
            //
            if( DisplayValueType ) 
            {
                StringCchPrintf( AuxBuffer, ARRAYSIZE(AuxBuffer), ( LPWSTR )L"%#x", ValueType );
                SendDlgItemMessage( hDlg, IDT_VALUE_TYPE, WM_SETTEXT, 0, ( LPARAM )AuxBuffer );
            }
            //
            // Use fixed size font
            //
            SendDlgItemMessage( hDlg,
                                IDD_DISPLAY_DATA_BINARY,
                                WM_SETFONT,
                                ( WPARAM )GetStockObject( ANSI_FIXED_FONT ),
                                FALSE );

            //
            //  Display the data in the listbox.
            //

            SendDlgItemMessage( hDlg,
                                IDC_BINARY_DATA_BYTE,
                                BM_SETCHECK,
                                ( WPARAM )TRUE,
                                0 );

            _DumpBinaryData( hDlg, Data, Size );
            CurrentFormat = IDC_BINARY_DATA_BYTE;
            return( TRUE );
        }

        case WM_COMMAND:

            switch( LOWORD( wParam ) ) {

                case IDCANCEL:
                case IDOK:
                    EndDialog( hDlg, TRUE );
                    return( TRUE );

                case IDC_BINARY_DATA_BYTE:
                case IDC_BINARY_DATA_WORD:
                case IDC_BINARY_DATA_DWORD:

                    switch( HIWORD( wParam ) ) {

                        case BN_CLICKED:
                        {
                            ULONG   TopIndex;
                            ULONG   CurrentIndex;

                            //
                            //  Ignore massage if new format is already the current format
                            //
                            if( CurrentFormat == LOWORD( wParam ) ) {
                                return( FALSE );
                            }

                            //
                            //  Save the position of current selection
                            //
                            TopIndex = (ULONG)SendDlgItemMessage( hDlg,
                                                                  IDD_DISPLAY_DATA_BINARY,
                                                                  LB_GETTOPINDEX,
                                                                  0,
                                                                  0 );

                            CurrentIndex = ( ULONG )SendDlgItemMessage( hDlg,
                                                                        IDD_DISPLAY_DATA_BINARY,
                                                                        LB_GETCURSEL,
                                                                        0,
                                                                        0 );
                            //
                            // Reset the listbox
                            //
                            SendDlgItemMessage( hDlg,
                                                IDD_DISPLAY_DATA_BINARY,
                                                LB_RESETCONTENT,
                                                0,
                                                0 );
                            //
                            // Display the data in the appropriate format
                            //
                            if( LOWORD( wParam ) == IDC_BINARY_DATA_BYTE ) {
                                _DumpBinaryData( hDlg, Data, Size );
                                CurrentFormat = IDC_BINARY_DATA_BYTE;
                            } else if( LOWORD( wParam ) == IDC_BINARY_DATA_WORD ) {
                                _DumpBinaryDataAsWords( hDlg, Data, Size );
                                CurrentFormat = IDC_BINARY_DATA_WORD;
                            } else {
                                _DumpBinaryDataAsDwords( hDlg, Data, Size );
                                CurrentFormat = IDC_BINARY_DATA_DWORD;
                            }

                            //
                            //  Restore current selection
                            //
                            SendDlgItemMessage( hDlg,
                                                IDD_DISPLAY_DATA_BINARY,
                                                LB_SETTOPINDEX,
                                                ( WPARAM )TopIndex,
                                                0 );

                            if( CurrentIndex != LB_ERR ) {
                                SendDlgItemMessage( hDlg,
                                                    IDD_DISPLAY_DATA_BINARY,
                                                    LB_SETCURSEL,
                                                    ( WPARAM )CurrentIndex,
                                                    0 );
                            }
                            return( TRUE );
                        }

                        default:

                            break;
                    }
                    break;

                default:

                    break;
            }
            break;

        default:
            break;
    }
    return( FALSE );
}


//------------------------------------------------------------------------------
//  _DumpBinaryData
//
//  DESCRIPTION:  Display the contents of a buffer in a list box, as binary data, using
//                an hd-like format.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               Data - Buffer that contains the binary data.
//               Size - Number of bytes in the buffer.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DumpBinaryData(HWND hDlg, PCBYTE Data, ULONG Size)
{
    WCHAR       AuxData[80];


    DWORD       DataIndex;
    DWORD       DataIndex2;
    WORD        SeperatorChars;
    ULONG       Index;

    if (( Data == NULL ) || ( Size == 0 )) 
    {
        return;
    }

    //
    // DataIndex2 tracks multiples of 16.
    //

    DataIndex2 = 0;

    //
    // Display rows of 16 bytes of data.
    //

    for(DataIndex = 0;
        DataIndex < ( Size >> 4 );
        DataIndex++,
        DataIndex2 = DataIndex << 4 ) {

        //
        //  The string that contains the format in the sprintf below
        //  cannot be broken because cfront  on mips doesn't like it.
        //

        StringCchPrintf(AuxData,
                 ARRAYSIZE(AuxData),
                 (LPWSTR)L"%08x   %02x %02x %02x %02x %02x %02x %02x %02x - %02x %02x %02x %02x %02x %02x %02x %02x  %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c",
                 DataIndex2,
                 Data[ DataIndex2 + 0  ],
                 Data[ DataIndex2 + 1  ],
                 Data[ DataIndex2 + 2  ],
                 Data[ DataIndex2 + 3  ],
                 Data[ DataIndex2 + 4  ],
                 Data[ DataIndex2 + 5  ],
                 Data[ DataIndex2 + 6  ],
                 Data[ DataIndex2 + 7  ],
                 Data[ DataIndex2 + 8  ],
                 Data[ DataIndex2 + 9  ],
                 Data[ DataIndex2 + 10 ],
                 Data[ DataIndex2 + 11 ],
                 Data[ DataIndex2 + 12 ],
                 Data[ DataIndex2 + 13 ],
                 Data[ DataIndex2 + 14 ],
                 Data[ DataIndex2 + 15 ],
                 iswprint( Data[ DataIndex2 + 0  ] ) ? Data[ DataIndex2 + 0  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 1  ] ) ? Data[ DataIndex2 + 1  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 2  ] ) ? Data[ DataIndex2 + 2  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 3  ] ) ? Data[ DataIndex2 + 3  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 4  ] ) ? Data[ DataIndex2 + 4  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 5  ] ) ? Data[ DataIndex2 + 5  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 6  ] ) ? Data[ DataIndex2 + 6  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 7  ] ) ? Data[ DataIndex2 + 7  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 8  ] ) ? Data[ DataIndex2 + 8  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 9  ] ) ? Data[ DataIndex2 + 9  ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 10 ] ) ? Data[ DataIndex2 + 10 ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 11 ] ) ? Data[ DataIndex2 + 11 ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 12 ] ) ? Data[ DataIndex2 + 12 ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 13 ] ) ? Data[ DataIndex2 + 13 ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 14 ] ) ? Data[ DataIndex2 + 14 ]  : ( WCHAR )'.',
                 iswprint( Data[ DataIndex2 + 15 ] ) ? Data[ DataIndex2 + 15 ]  : ( WCHAR )'.'
                );
        SendDlgItemMessage( hDlg, IDD_DISPLAY_DATA_BINARY, LB_ADDSTRING, 0, (LONG_PTR)AuxData );
    }

    //
    // If the data size is not an even multiple of 16
    // then there is one additonal line of data to display.
    //

    if( Size % 16 != 0 ) 
    {
        //
        // No seperator characters displayed so far.
        //

        SeperatorChars = 0;

        Index = swprintf( AuxData, (LPWSTR)L"%08x   ", DataIndex << 4 );

        //
        // Display the remaining data, one byte at a time in hex.
        //

        for( DataIndex = DataIndex2;
             DataIndex < Size;
             DataIndex++ ) {

             Index += swprintf( &AuxData[ Index ], (LPWSTR)L"%02x ", Data[ DataIndex ] );

            //
            // If eight data values have been displayed, print
            // the seperator.
            //

            if( DataIndex % 8 == 7 ) {

                Index += swprintf( &AuxData[Index], (LPWSTR)L"%s", (LPWSTR)L"- " );

                //
                // Remember that two seperator characters were
                // displayed.
                //

                SeperatorChars = 2;
            }
        }

        //
        // Fill with blanks to the printable characters position.
        // That is position 63 less 8 spaces for the 'address',
        // 3 blanks, 3 spaces for each value displayed, possibly
        // two for the seperator plus two blanks at the end.
        //

        Index += swprintf( &AuxData[ Index ],
                          (LPWSTR)L"%*c",
                          64
                          - ( 8 + 3
                          + (( DataIndex % 16 ) * 3 )
                          + SeperatorChars
                          + 2 ), ' ' );

        //
        // Display the remaining data, one byte at a time as
        // printable characters.
        //

        for(
            DataIndex = DataIndex2;
            DataIndex < Size;
            DataIndex++ ) {

            Index += swprintf( ( AuxData + Index ),
                               (LPWSTR)L"%c",
                               iswprint( Data[ DataIndex ] )
                                        ? Data[ DataIndex ] : ( WCHAR )'.'
                            );

        }

        SendDlgItemMessage( hDlg, IDD_DISPLAY_DATA_BINARY, LB_ADDSTRING, 0, (LONG_PTR)AuxData );

    }
}


//------------------------------------------------------------------------------
//  _DumpBinaryDataAsWords
//
//  DESCRIPTION:  Display the contents of a buffer in a list box, as binary data, using
//                an hd-like format.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               Data - Buffer that contains the binary data.
//               Size - Number of bytes in the buffer.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DumpBinaryDataAsWords(HWND hDlg, PCBYTE Data,ULONG Size)
{
    ULONG       Index;
    WCHAR       Buffer[ 80 ];
    ULONG       DataIndex;
    ULONG       LineNumber;
    ULONG       WholeLines;


    if( ( Data == NULL ) ||
        ( Size == 0 ) ) {
        return;
    }

    //
    // Display all rows that contain 4 DWORDs.
    //

    WholeLines = Size / 16;
    DataIndex = 0;
    for( LineNumber = 0;
         LineNumber < WholeLines;
         LineNumber++,
         DataIndex += 16 ) {

        //
        //  The string that contains the format in the sprintf below
        //  cannot be broken because cfront  on mips doesn't like it.
        //

        StringCchPrintf( Buffer,
                  ARRAYSIZE(Buffer),
                  ( LPWSTR )L"%08x   %04x %04x %04x %04x %04x %04x %04x %04x",
                  DataIndex,
                  *( ( PUSHORT )( &Data[ DataIndex + 0  ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 2  ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 4  ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 6  ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 8  ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 10 ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 12 ] ) ),
                  *( ( PUSHORT )( &Data[ DataIndex + 14 ] ) )
                );
        SendDlgItemMessage( hDlg, IDD_DISPLAY_DATA_BINARY, LB_ADDSTRING, 0, (LONG_PTR)Buffer );
    }

    //
    // If the data size is not an even multiple of 16
    // then there is one additonal line of data to display.
    //

    if( Size % 16 != 0 ) {

        ULONG   NumberOfWords;
        ULONG   Count;

        //
        //  Determine the number of WORDs in the last line
        //

        NumberOfWords = ( Size % 16 ) / 2;

        //
        // Build the offset
        //

        Index = swprintf( Buffer, (LPWSTR)L"%08x   ", DataIndex );

        //
        // Display the remaining words, one at a time in hex.
        //

        for( Count = 0;
             Count < NumberOfWords;
             Count++,
             DataIndex += 2 ) {

             Index += swprintf( &Buffer[ Index ], (LPWSTR)L"%04x ", *( ( PUSHORT )( &Data[ DataIndex ] ) ) );

        }

        //
        //  Display the remaining byte, if any
        //

        if( Size % 2 != 0 ) {
             swprintf( &Buffer[ Index ], (LPWSTR)L"%02x ", Data[ DataIndex ] );
        }

        SendDlgItemMessage( hDlg, IDD_DISPLAY_DATA_BINARY, LB_ADDSTRING, 0, (LONG_PTR)Buffer );

    }
}


//------------------------------------------------------------------------------
//  _DumpBinaryDataAsDwords
//
//  DESCRIPTION:  Display the contents of a buffer in a list box, as DWORDs, using
//                an hd-like format.
//
//  PARAMETERS:  hDlg - a handle to the dialog proceedure.
//               Data - Buffer that contains the binary data.
//               Size - Number of bytes in the buffer.
//------------------------------------------------------------------------------
VOID REGISTRY_DATA::_DumpBinaryDataAsDwords(HWND hDlg, PCBYTE  Data, ULONG Size)
{
    ULONG       Index;
    WCHAR       Buffer[ 80 ];
    ULONG       DataIndex;
    ULONG       LineNumber;
    ULONG       WholeLines;


    if( ( Data == NULL ) ||
        ( Size == 0 ) ) {
        return;
    }

    //
    // Display all rows that contain 4 DWORDs.
    //

    WholeLines = Size / 16;
    DataIndex = 0;
    for( LineNumber = 0;
         LineNumber < WholeLines;
         LineNumber++,
         DataIndex += 16 ) {

        //
        //  The string that contains the format in the sprintf below
        //  cannot be broken because cfront  on mips doesn't like it.
        //

        StringCchPrintf( Buffer,
                  ARRAYSIZE(Buffer),
                  ( LPWSTR )L"%08x   %08x %08x %08x %08x",
                  DataIndex,
                  *( ( PULONG )( &Data[ DataIndex + 0  ] ) ),
                  *( ( PULONG )( &Data[ DataIndex + 4  ] ) ),
                  *( ( PULONG )( &Data[ DataIndex + 8  ] ) ),
                  *( ( PULONG )( &Data[ DataIndex + 12  ] ) )
                );
        SendDlgItemMessage( hDlg, IDD_DISPLAY_DATA_BINARY, LB_ADDSTRING, 0, (LONG_PTR)Buffer );
    }

    //
    // If the data size is not an even multiple of 16
    // then there is one additonal line of data to display.
    //

    if( Size % 16 != 0 ) {

        ULONG   NumberOfDwords;
        ULONG   Count;

        //
        // Build the offset
        //

        Index = swprintf( Buffer, (LPWSTR)L"%08x   ", DataIndex );

        //
        //  Determine the number of DWORDs in the last line
        //

        NumberOfDwords = ( Size % 16 ) / 4;

        //
        // Display the remaining dwords, one at a time, if any.
        //

        for( Count = 0;
             Count < NumberOfDwords;
             Count++,
             DataIndex += 4 ) {

             Index += swprintf( &Buffer[ Index ], (LPWSTR)L"%08x ", *( ( PULONG )( &Data[ DataIndex ] ) ) );

        }

        //
        //  Display the remaining word, if any
        //

        if( ( Size % 16 ) % 4 >= 2 ) {
             Index += swprintf( &Buffer[ Index ], (LPWSTR)L"%04x ", *( ( PUSHORT )( &Data[ DataIndex ] ) ) );
             DataIndex += 2;
        }

        //
        //  Display the remaining byte, if any
        //

        if( Size % 2 != 0 ) {
             swprintf( &Buffer[ Index ], (LPWSTR)L"%02x ", Data[ DataIndex ] );
        }

        SendDlgItemMessage( hDlg, IDD_DISPLAY_DATA_BINARY, LB_ADDSTRING, 0, (LONG_PTR)Buffer );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regdesc.cxx ===
/*++

Copyright (c) 1991      Microsoft Corporation

Module Name:

    regdesc.cxx

Abstract:

    This module contains the definitions of the member functions
    of the following classes: PARTIAL_DESCRIPTOR, PORT_DESCRIPTOR,
    INTERRUPT_DESCRIPTOR, MEMORY_DESCRIPTOR, DMA_DESCRIPTOR, and
    DEVICE_SPECIFIC_DESCRIPTOR.

Author:

    Jaime Sasson (jaimes) 02-Dec-1993

Environment:

    ULIB, User Mode


--*/

#include "regdesc.hxx"


DEFINE_CONSTRUCTOR ( PARTIAL_DESCRIPTOR, OBJECT );


PARTIAL_DESCRIPTOR::~PARTIAL_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a PARTIAL_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
PARTIAL_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct a PARTIAL_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _Type = 0;
        _ShareDisposition = 0;
        _Flags = 0;
}



DEFINE_CONSTRUCTOR ( PORT_DESCRIPTOR, PARTIAL_DESCRIPTOR );


PORT_DESCRIPTOR::~PORT_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a PORT_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
PORT_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct a PORT_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _PhysicalAddress.LowPart = 0;
        _PhysicalAddress.HighPart = 0;
        _Length = 0;
}



DEFINE_CONSTRUCTOR ( INTERRUPT_DESCRIPTOR, PARTIAL_DESCRIPTOR );


INTERRUPT_DESCRIPTOR::~INTERRUPT_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a INTERRUPT_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
INTERRUPT_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an INTERRUPT_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _Affinity = 0;
    _Level = 0;
    _Vector = 0;
}




// #include "ulib.hxx"
// #include "regdesc.hxx"


DEFINE_CONSTRUCTOR ( MEMORY_DESCRIPTOR, PARTIAL_DESCRIPTOR );


MEMORY_DESCRIPTOR::~MEMORY_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a MEMORY_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
MEMORY_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an MEMORY_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _StartAddress.LowPart = 0;
        _StartAddress.HighPart = 0;
        _Length = 0;
}


DEFINE_CONSTRUCTOR ( DMA_DESCRIPTOR, PARTIAL_DESCRIPTOR );


DMA_DESCRIPTOR::~DMA_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a DMA_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
DMA_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an MEMORY_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _Channel = 0;
    _Port = 0;
    _Reserved1 = 0;
}



DEFINE_CONSTRUCTOR ( DEVICE_SPECIFIC_DESCRIPTOR, PARTIAL_DESCRIPTOR );


DEVICE_SPECIFIC_DESCRIPTOR::~DEVICE_SPECIFIC_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a DEVICE_SPECIFIC_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DataSize = 0;
    if( _Data != NULL ) {
        FREE( _Data );
    }
}

VOID
DEVICE_SPECIFIC_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an DEVICE_SPECIFIC_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _Reserved1 = 0;
    _Reserved2 = 0;
    _Data = NULL;
    _DataSize = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regedit.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGEDIT.H
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  Common header file for the Registry Editor.  Precompiled header.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  21 Nov 1993 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGEDIT
#define _INC_REGEDIT

//  Class name of main application window.
extern const TCHAR g_RegEditClassName[];

#define IDC_KEYTREE                     1
#define IDC_VALUELIST                   2
#define IDC_STATUSBAR                   3

typedef struct _REGEDITDATA {
    HWND hKeyTreeWnd;
    HWND hValueListWnd;
    HWND hStatusBarWnd;
    HWND hFocusWnd;
    int xPaneSplit;
    HIMAGELIST hImageList;
    HKEY hCurrentSelectionKey;
    int SelChangeTimerState;
    int StatusBarShowCommand;
    PTSTR pDefaultValue;
    PTSTR pValueNotSet;
    PTSTR pEmptyBinary;
    PTSTR pCollapse;
    PTSTR pModify;
    PTSTR pModifyBinary;
    PTSTR pNewKeyTemplate;
    PTSTR pNewValueTemplate;
    BOOL fAllowLabelEdits;
    HMENU hMainMenu;
    BOOL fMainMenuInited;
    BOOL fHaveNetwork;
    BOOL fProcessingFind;
    HTREEITEM hMyComputer;
    UINT uExportFormat;
}   REGEDITDATA, *PREGEDITDATA;

extern REGEDITDATA g_RegEditData;

#define SCTS_TIMERCLEAR                 0
#define SCTS_TIMERSET                   1
#define SCTS_INITIALIZING               2
#define REG_READONLY                    0
#define REG_READWRITE                   1

#define MAXKEYNAMEPATH			(MAXKEYNAME * 2)

BOOL
PASCAL
RegisterRegEditClass(
    VOID
    );

HWND
PASCAL
CreateRegEditWnd(
    VOID
    );

VOID
PASCAL
RegEdit_OnCommand(
    HWND hWnd,
    int DlgItem,
    HWND hControlWnd,
    UINT NotificationCode
    );

VOID
PASCAL
RegEdit_SetNewObjectEditMenuItems(
    HMENU hPopupMenu
    );

VOID
PASCAL
RegEdit_SetWaitCursor(
    BOOL fSet
    );

HTREEITEM     RegEdit_GetComputerItem(HTREEITEM hTreeItem);
VOID          RegEdit_InvokeSecurityEditor(HWND hWnd);
PREDEFINE_KEY RegEdit_GetPredefinedKey(HTREEITEM hTreeItem);
void          Regedit_EnableHiveMenuItems(HMENU hPopupMenu);

#define REM_UPDATESTATUSBAR             (WM_USER + 1)

#endif // _INC_REGEDIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regdwded.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDWDED.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        24 Sep 1994
*
*  Dword edit dialog for use by the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGDWDED
#define _INC_REGDWDED

INT_PTR
CALLBACK
EditDwordValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

#endif // _INC_REGDWDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regfile.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGFILE.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  File import and export user interface routines for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGFILE
#define _INC_REGFILE

HWND g_hRegProgressWnd;

VOID RegEdit_ImportRegFile(HWND hWnd, BOOL fSilentMode, LPTSTR lpFileName, HTREEITEM hComputerItem);
BOOL RegEdit_SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege);
VOID RegEdit_OnCommandLoadHive(HWND hWnd);
VOID RegEdit_OnCommandUnloadHive(hWnd);

VOID
PASCAL
RegEdit_OnDropFiles(
    HWND hWnd,
    HDROP hDrop
    );

VOID
PASCAL
RegEdit_OnCommandImportRegFile(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_ExportRegFile(
    HWND hWnd,
    BOOL fSilentMode,
    LPTSTR lpFileName,
    LPTSTR lpSelectedPath
    );

VOID
PASCAL
RegEdit_OnCommandExportRegFile(
    HWND hWnd
    );

void RegEdit_ImportToConnectedComputer(HWND hWnd, PTSTR pszFileName);
INT_PTR RegConnectedComputerDlgProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
void RegImport_OnCommandOk(HWND hWnd, PTSTR pszFileName);
INT_PTR RegImport_OnInitDialog(HWND hWnd);
BOOL RegEdit_GetFileName(HWND hWnd, UINT uTitleStringID, UINT uFilterStringID, 
    UINT uDefExtStringID, LPTSTR lpFileName, DWORD cchFileName, BOOL fOpen);

#endif // _INC_REGFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regfile.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGFILE.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  File import and export user interface routines for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"
#include "regkey.h"
#include "regfile.h"
#include "regcdhk.h"
#include "regresid.h"
#include "reghelp.h"
#include "regstred.h"
#include "regprint.h"

INT_PTR
CALLBACK
RegProgressDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

/*******************************************************************************
*
*  RegEdit_ImportRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     fSilentMode, TRUE if no messages should be displayed, else FALSE.
*     lpFileName, address of file name buffer.
*
*******************************************************************************/

VOID RegEdit_ImportRegFile(HWND hWnd, BOOL fSilentMode, LPTSTR lpFileName, HTREEITEM hComputerItem)
{

    if (!fSilentMode && hWnd != NULL) {

        if ((g_hRegProgressWnd = CreateDialogParam(g_hInstance,
            MAKEINTRESOURCE(IDD_REGPROGRESS), hWnd, RegProgressDlgProc,
            (LPARAM) lpFileName)) != NULL)
            EnableWindow(hWnd, FALSE);

    }

    else
        g_hRegProgressWnd = NULL;

    //
    //  Prompt user to confirm importing a .reg file if running in silent mode 
    //  without a window (i.e. invoked .reg from a folder)
    //
    if (!fSilentMode && !hWnd)
    {
        if (InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_CONFIRMIMPFILE),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONQUESTION | MB_YESNO , lpFileName) != IDYES)
        {
            return;
        }
    }

    ImportRegFile(hWnd, lpFileName, hComputerItem);

    if (g_hRegProgressWnd != NULL) {

        EnableWindow(hWnd, TRUE);
        DestroyWindow(g_hRegProgressWnd);

    }

    if (!fSilentMode && g_FileErrorStringID != IDS_IMPFILEERRORCANCEL)
    {
        //
        // set defaults
        //
        UINT uStyle = MB_ICONERROR;

        TCHAR szComputerName[MAXKEYNAME + 1];
        LPTSTR pszComputerName = szComputerName;
        KeyTree_GetKeyName(hComputerItem, pszComputerName, ARRAYSIZE(szComputerName));

        //
        // For the resource messages that take the pszComputerName parameter,
        // map them to a local-computer version if pszComputerName is empty.
        // (Alternatively, we could  fill in "this computer" or somesuch for
        // pszComputerName, but the resulting text is sort of weird, which
        // which isn't acceptable since local-computer is the 99% case.)
        // 
        // Also map the uStyle as needed.
        //
        switch (g_FileErrorStringID)
        {
        case IDS_IMPFILEERRSUCCESS:
            if (!hWnd || *pszComputerName == 0)
            {
                g_FileErrorStringID += LOCAL_OFFSET;
            }
            uStyle = MB_ICONINFORMATION | MB_OK;
            break;

        case IDS_IMPFILEERRREGOPEN:
        case IDS_IMPFILEERRNOFILE:
            if (*pszComputerName == 0)
            {
                g_FileErrorStringID += LOCAL_OFFSET;
            }
            break;
        }

        //
        // Put up the message box
        //
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(g_FileErrorStringID),
            MAKEINTRESOURCE(IDS_REGEDIT), uStyle, lpFileName, pszComputerName);

    }

}

/*******************************************************************************
*
*  RegEdit_OnDropFiles
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnDropFiles(
    HWND hWnd,
    HDROP hDrop
    )
{

    TCHAR FileName[MAX_PATH];
    UINT NumberOfDrops;
    UINT CurrentDrop;

    BOOL me;

    HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
    TreeView_SelectDropTarget(g_RegEditData.hKeyTreeWnd, hSelectedTreeItem);

    RegEdit_SetWaitCursor(TRUE);

    NumberOfDrops = DragQueryFile(hDrop, (UINT) -1, NULL, 0);

    for (CurrentDrop = 0; CurrentDrop < NumberOfDrops; CurrentDrop++) 
    {
        DragQueryFile(hDrop, CurrentDrop, FileName, ARRAYSIZE(FileName));

        if (TreeView_GetNextSibling(g_RegEditData.hKeyTreeWnd, 
            TreeView_GetRoot(g_RegEditData.hKeyTreeWnd)) != NULL)
        {
            // Remote connections exist
            RegEdit_ImportToConnectedComputer(hWnd, FileName);
        }
        else
        {
            RegEdit_ImportRegFile(hWnd, FALSE, FileName, RegEdit_GetComputerItem(hSelectedTreeItem));
        }

    }

    DragFinish(hDrop);
    TreeView_SelectDropTarget(g_RegEditData.hKeyTreeWnd, NULL);

    RegEdit_OnKeyTreeRefresh(hWnd);

    RegEdit_SetWaitCursor(FALSE);

}

//------------------------------------------------------------------------------
// RegEdit_SetPrivilege
//
// DESCRIPTION: Enable a priviledge
//
// PARAMETERS: lpszPrivilege - the security constant or its corresponding string
//             bEnablePrivilege - TRUE = enable, False = disable
//
//------------------------------------------------------------------------------
BOOL RegEdit_SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    HANDLE hToken;
    BOOL fSuccess = FALSE;
    HRESULT hr;

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
    {
        if (LookupPrivilegeValue(NULL, lpszPrivilege, &luid)) 
        {     
            tp.PrivilegeCount = 1;
            tp.Privileges[0].Luid = luid;
            tp.Privileges[0].Attributes = (bEnablePrivilege) ? SE_PRIVILEGE_ENABLED : 0;
            
            // Enable or disable the privilege
            if (AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES) NULL, 
                    (PDWORD) NULL))
            {   
                fSuccess = TRUE;
            }
        }
        CloseHandle(hToken);
    }
    return fSuccess;
}

//------------------------------------------------------------------------------
// RegEdit_OnCommandLoadHive
//
// DESCRIPTION: Open and Load a Hive
//
// PARAMETERS: hWnd - handle of RegEdit window.
//
//------------------------------------------------------------------------------
VOID RegEdit_OnCommandLoadHive(HWND hWnd)
{
    TCHAR achFileName[MAX_PATH];

    if (RegEdit_GetFileName(hWnd, IDS_LOADHVREGFILETITLE, IDS_REGLOADHVFILEFILTER, 
        IDS_REGNODEFEXT, achFileName, ARRAYSIZE(achFileName), TRUE))
    {
        EDITVALUEPARAM EditValueParam; 

        RegEdit_SetWaitCursor(TRUE);

        EditValueParam.cbValueData = 50 * sizeof(TCHAR);
        EditValueParam.pValueData = LocalAlloc(LPTR, EditValueParam.cbValueData);
        if (EditValueParam.pValueData)
        {
            EditValueParam.pValueData[0] = TEXT('\0');

            if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_INPUTHIVENAME), hWnd,
                    EditStringValueDlgProc, (LPARAM) &EditValueParam) == IDOK)
            {
                HRESULT hr;

                RegEdit_SetPrivilege(SE_RESTORE_NAME, TRUE);

                //
                // REVIEW:
                //  What if EditValueParam.pValueData is greater than 50 characters that have been allocated ?
                //  Is it NULL terminated ?
                //
                if ((hr = RegLoadKey(g_RegEditData.hCurrentSelectionKey, (PTSTR)EditValueParam.pValueData, 
                    achFileName)) == ERROR_SUCCESS)
                {
                    RegEdit_OnKeyTreeRefresh(hWnd);
                }
                else
                {
                    UINT uErrorStringID = IDS_ERRORLOADHV;
                    
                    switch (hr)
                    {
                    case ERROR_PRIVILEGE_NOT_HELD:
                        uErrorStringID = IDS_ERRORLOADHVPRIV;
                        break;
                        
                    case ERROR_SHARING_VIOLATION:
                        uErrorStringID = IDS_ERRORLOADHVNOSHARE;
                        break;

                    case ERROR_ACCESS_DENIED:
                        uErrorStringID = IDS_ERRORLOADHVNOACC;
                        break;

                    }
                    
                    InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(uErrorStringID),
                        MAKEINTRESOURCE(IDS_LOADHVREGFILETITLE), MB_ICONERROR | MB_OK, achFileName);
                }

                RegEdit_SetPrivilege(SE_RESTORE_NAME, FALSE);
            }
            LocalFree(EditValueParam.pValueData);
        }

        RegEdit_SetWaitCursor(FALSE);
    }
}


//------------------------------------------------------------------------------
// RegEdit_OnCommandUnloadHive
//
// DESCRIPTION: Open and Load a Hive
//
// PARAMETERS: hWnd - handle of RegEdit window.
//
//------------------------------------------------------------------------------
VOID  RegEdit_OnCommandUnloadHive(HWND hWnd)
{
    if (InternalMessageBox(g_hInstance, hWnd,
        MAKEINTRESOURCE(IDS_CONFIRMDELHIVETEXT), MAKEINTRESOURCE(IDS_CONFIRMDELHIVETITLE), 
        MB_ICONWARNING | MB_YESNO) == IDYES)
    {
        HRESULT hr;
        TCHAR achKeyName[MAXKEYNAME];
        HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
    
        RegEdit_SetPrivilege(SE_RESTORE_NAME, TRUE);

        // must close key to unload it
        RegCloseKey(g_RegEditData.hCurrentSelectionKey);

        if ((hr = RegUnLoadKey(KeyTree_GetRootKey(hSelectedTreeItem), 
            KeyTree_GetKeyName(hSelectedTreeItem, achKeyName, ARRAYSIZE(achKeyName)))) ==
                    ERROR_SUCCESS)
        {
            g_RegEditData.hCurrentSelectionKey = NULL;
            RegEdit_OnKeyTreeRefresh(hWnd);
        }
        else
        {
            UINT uErrorStringID = IDS_ERRORUNLOADHV;

            switch (hr)
            {
            case ERROR_PRIVILEGE_NOT_HELD:
                uErrorStringID = IDS_ERRORUNLOADHVPRIV;
                break;
                
            case ERROR_ACCESS_DENIED:
                uErrorStringID = IDS_ERRORUNLOADHVNOACC;
                break;
            }
            
            InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(uErrorStringID),
                MAKEINTRESOURCE(IDS_UNLOADHIVETITLE), MB_ICONERROR | MB_OK, achKeyName);
            // The key couldn't be unloaded so select it again 
            g_RegEditData.hCurrentSelectionKey = NULL;
            RegEdit_KeyTreeSelChanged(hWnd);
        }
   
        RegEdit_SetPrivilege(SE_RESTORE_NAME, FALSE);
    }
}

/*******************************************************************************
*
*  RegEdit_OnCommandImportRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/
VOID RegEdit_OnCommandImportRegFile(HWND hWnd)
{

    TCHAR achFileName[MAX_PATH];

    if (RegEdit_GetFileName(hWnd, IDS_IMPORTREGFILETITLE, IDS_REGIMPORTFILEFILTER, 
        IDS_REGFILEDEFEXT, achFileName, ARRAYSIZE(achFileName), TRUE))
    {
        // check for networked registries
        if (TreeView_GetNextSibling(g_RegEditData.hKeyTreeWnd, 
            TreeView_GetRoot(g_RegEditData.hKeyTreeWnd)) != NULL)
        {
            // Remote connections exist
            RegEdit_ImportToConnectedComputer(hWnd, achFileName);    
        }
        else
        {
            RegEdit_SetWaitCursor(TRUE);
            RegEdit_ImportRegFile(hWnd, FALSE, achFileName, NULL);
            //  PERF:  Only need to refresh the computer that we imported the
            //  file into, not the whole thing.
            RegEdit_OnKeyTreeRefresh(hWnd);
            RegEdit_SetWaitCursor(FALSE);
        }
    }
}


/*******************************************************************************
*
*  RegEdit_ExportRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     fSilentMode, TRUE if no messages should be displayed, else FALSE.
*     lpFileName, address of file name buffer.
*     lpSelectedPath,
*
*******************************************************************************/

VOID
PASCAL
RegEdit_ExportRegFile(
    HWND hWnd,
    BOOL fSilentMode,
    LPTSTR lpFileName,
    LPTSTR lpSelectedPath
    )
{

    //
    // Fix a bug where /a or /e is specified and no file is passed in
    //
    if (lpFileName == NULL)
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_NOFILESPECIFIED),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONERROR | MB_OK, lpFileName);
        return;
    }

    switch (g_RegEditData.uExportFormat)
    {
    case FILE_TYPE_REGEDT32:
        ExportRegedt32File(lpFileName, lpSelectedPath);
        break;

    case FILE_TYPE_REGEDIT4:
        ExportWin40RegFile(lpFileName, lpSelectedPath);
        break;

    case FILE_TYPE_TEXT:
        RegEdit_SaveAsSubtree(lpFileName, lpSelectedPath);
        break;

    default:
        ExportWinNT50RegFile(lpFileName, lpSelectedPath);
        break;
    }

    if (g_FileErrorStringID != IDS_EXPFILEERRSUCCESS && g_FileErrorStringID != IDS_IMPFILEERRSUCCESSLOCAL)
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(g_FileErrorStringID),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONERROR | MB_OK, lpFileName);
    }


}


//------------------------------------------------------------------------------
//  RegEdit_OnCommandExportRegFile
//
//  DESCRIPTION:
//
//  PARAMETERS: - hWnd, handle of RegEdit window.
//------------------------------------------------------------------------------
VOID RegEdit_OnCommandExportRegFile(HWND hWnd)
{
    TCHAR achFileName[MAX_PATH];
    LPTSTR lpSelectedPath;

    if (RegEdit_GetFileName(hWnd, IDS_EXPORTREGFILETITLE, IDS_REGEXPORTFILEFILTER, 
        IDS_REGFILEDEFEXT, achFileName, ARRAYSIZE(achFileName), FALSE))
    {
        RegEdit_SetWaitCursor(TRUE);

        lpSelectedPath = g_fRangeAll ? NULL : g_SelectedPath;
        RegEdit_ExportRegFile(hWnd, FALSE, achFileName, lpSelectedPath);

        RegEdit_SetWaitCursor(FALSE);
    }
}


//------------------------------------------------------------------------------
//  RegEdit_GetFileName
//
//  DESCRIPTION: Gets a file name
//
//  PARAMETERS: hWnd - handle of RegEdit window.
//              fOpen - TRUE if importing a file, else FALSE if exporting a file.
//              lpFileName - address of file name buffer.
//              cchFileName - size of file name buffer in TCHARacters.
//
//  RETURN:     True, if successfull
//------------------------------------------------------------------------------
BOOL RegEdit_GetFileName(HWND hWnd, UINT uTitleStringID, UINT uFilterStringID, 
    UINT uDefExtStringID, LPTSTR lpFileName, DWORD cchFileName, BOOL fOpen)
{

    PTSTR pTitle = NULL;
    PTSTR pDefaultExtension = NULL;
    PTSTR pFilter = NULL;
    PTSTR pFilterChar;
    OPENFILENAME OpenFileName;
    BOOL fSuccess;

    //
    //  Load various strings that will be displayed and used by the common open
    //  or save dialog box.  Note that if any of these fail, the error is not
    //  fatal-- the common dialog box may look odd, but will still work.
    //

    pTitle = LoadDynamicString(uTitleStringID);

    if (uDefExtStringID != IDS_REGNODEFEXT)
    {
        pDefaultExtension = LoadDynamicString(uDefExtStringID);
    }

    if ((pFilter = LoadDynamicString(uFilterStringID)) != NULL) 
    {
        //  The common dialog library requires that the substrings of the
        //  filter string be separated by nulls, but we cannot load a string
        //  containing nulls.  So we use some dummy character in the resource
        //  that we now convert to nulls.

        for (pFilterChar = pFilter; *pFilterChar != 0; pFilterChar =
            CharNext(pFilterChar)) 
        {
            if (*pFilterChar == TEXT('#'))
                *pFilterChar++ = 0;

        }

    }

    *lpFileName = 0;

    memset(&OpenFileName, 0, sizeof(OpenFileName));

    OpenFileName.lStructSize = sizeof(OpenFileName);
    // DebugAssert(OpenFileName.lStructSize == sizeof(OPENFILENAME));
    OpenFileName.hwndOwner = hWnd;
    OpenFileName.hInstance = g_hInstance;
    OpenFileName.lpstrFilter = pFilter;
    OpenFileName.lpstrFile = lpFileName;
    OpenFileName.nMaxFile = cchFileName;
    OpenFileName.lpstrTitle = pTitle;
    if (fOpen) 
    {
        OpenFileName.Flags = OFN_HIDEREADONLY | OFN_EXPLORER |
            OFN_FILEMUSTEXIST;

        fSuccess = GetOpenFileName(&OpenFileName);

    }

    else 
    {
        OpenFileName.lpstrDefExt = pDefaultExtension;
        OpenFileName.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT |
            OFN_EXPLORER | OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST |
            OFN_ENABLEHOOK | OFN_ENABLETEMPLATE;
        OpenFileName.lpfnHook = RegCommDlgHookProc;
        OpenFileName.lpTemplateName = MAKEINTRESOURCE(IDD_REGEXPORT);
        g_RegCommDlgDialogTemplate = IDD_REGEXPORT;

        fSuccess = GetSaveFileName(&OpenFileName);

    }

    //
    //  Delete all of the dynamic strings that we loaded.
    //

    if (pTitle != NULL)
        DeleteDynamicString(pTitle);

    if (pDefaultExtension != NULL)
        DeleteDynamicString(pDefaultExtension);

    if (pFilter != NULL)
        DeleteDynamicString(pFilter);

    return fSuccess;

}


/*******************************************************************************
*
*  RegProgressDlgProc
*
*  DESCRIPTION:
*     Callback procedure for the RegAbort dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegProgress window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

INT_PTR
CALLBACK
RegProgressDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    switch (Message) {

        case WM_INITDIALOG:
            //PathSetDlgItemPath(hWnd, IDC_FILENAME, (LPTSTR)lParam);
            SetDlgItemText(hWnd, IDC_FILENAME, (LPTSTR) lParam);
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  ImportRegFileUICallback
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID ImportRegFileUICallback(UINT uPercentage)
{

    if (g_hRegProgressWnd != NULL) 
    {
        SendDlgItemMessage(g_hRegProgressWnd, IDC_PROGRESSBAR, PBM_SETPOS,
            (WPARAM) uPercentage, 0);

        while (MessagePump(g_hRegProgressWnd));
    }

}


//------------------------------------------------------------------------------
//  RegEdit_ImportToConnectedComputer
//
//  DESCRIPTION: Imports a reg. file one or more of the connected computers
//
//  PARAMETERS:  HWND hWnd
//               PTSTR pszFileName - import file
//------------------------------------------------------------------------------

void RegEdit_ImportToConnectedComputer(HWND hWnd, PTSTR pszFileName)
{
    DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_REGIMPORTNET), hWnd,
        RegConnectedComputerDlgProc, (LPARAM) pszFileName);
}


//------------------------------------------------------------------------------
//  RegConnectedComputerDlgProc
//
//  DESCRIPTION: Dlg Proc for selecting a connected computer
//
//  PARAMETERS:  
//------------------------------------------------------------------------------
INT_PTR RegConnectedComputerDlgProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage) 
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hWnd, DWLP_USER, lParam);
        return RegImport_OnInitDialog(hWnd);
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        {
        case IDOK:
            {
                PTSTR pszFileName = (PTSTR) GetWindowLongPtr(hWnd, DWLP_USER);
                // (pszFileName == NULL) is checked later
                RegImport_OnCommandOk(hWnd, pszFileName);
            }
            //  FALL THROUGH
            
        case IDCANCEL:
            EndDialog(hWnd, 0);
            break;
            
        }
        return TRUE;
    }
    
    return FALSE;
}


//------------------------------------------------------------------------------
//  RegImport_OnInitDialog
//
//  DESCRIPTION: Create a list of all the connected computers
//
//  PARAMETERS:  HWND hWnd
//------------------------------------------------------------------------------

INT_PTR RegImport_OnInitDialog(HWND hWnd)
{
    HWND hComputerListWnd;
    RECT ClientRect;
    LV_COLUMN LVColumn;
    LV_ITEM LVItem;
    TCHAR achComputerName[MAX_PATH];
    HWND hKeyTreeWnd;
    TV_ITEM TVItem;

    hComputerListWnd = GetDlgItem(hWnd, IDC_COMPUTERLIST);

    //  Initialize the ListView control.
    ListView_SetImageList(hComputerListWnd, g_RegEditData.hImageList,
        LVSIL_SMALL);

    LVColumn.mask = LVCF_FMT | LVCF_WIDTH;
    LVColumn.fmt = LVCFMT_LEFT;

    GetClientRect(hComputerListWnd, &ClientRect);
    LVColumn.cx = ClientRect.right - GetSystemMetrics(SM_CXVSCROLL) -
        2 * GetSystemMetrics(SM_CXEDGE);

    ListView_InsertColumn(hComputerListWnd, 0, &LVColumn);
  
    //  Walk through the local machine and each remote connection listed 
    //  in the KeyTree and add it to our RemoteList.
    LVItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    LVItem.pszText = achComputerName;
    LVItem.iItem = 0;
    LVItem.iSubItem = 0;
    LVItem.iImage = IMAGEINDEX(IDI_COMPUTER);

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    TVItem.mask = TVIF_TEXT;
    TVItem.hItem = TreeView_GetRoot(hKeyTreeWnd);
    TVItem.pszText = achComputerName;
    TVItem.cchTextMax = ARRAYSIZE(achComputerName);

    // Set "local computer" in list
    LVItem.lParam = (LPARAM) TVItem.hItem;
    TreeView_GetItem(hKeyTreeWnd, &TVItem);
    ListView_InsertItem(hComputerListWnd, &LVItem);

    LVItem.iItem++;

    LVItem.iImage = IMAGEINDEX(IDI_REMOTE);

    while ((TVItem.hItem = TreeView_GetNextSibling(hKeyTreeWnd,
        TVItem.hItem)) != NULL)
    {

        LVItem.lParam = (LPARAM) TVItem.hItem;
        TreeView_GetItem(hKeyTreeWnd, &TVItem);
        ListView_InsertItem(hComputerListWnd, &LVItem);

        LVItem.iItem++;
    }   

    ListView_SetItemState(hComputerListWnd, 0, LVIS_FOCUSED, LVIS_FOCUSED);

    return TRUE;

}


//------------------------------------------------------------------------------
//  RegImport_OnCommandOk
//
//  DESCRIPTION: Import key to selected computers
//
//  PARAMETERS:  HWND hWnd, 
//               PTSTR pszFileName - file to import
//------------------------------------------------------------------------------
void RegImport_OnCommandOk(HWND hWnd, PTSTR pszFileName)
{
    LV_ITEM LVItem;
    HWND hComputerListWnd;

    //  Walk through each selected item in the ListView and import the reg file
    LVItem.mask = LVIF_PARAM;
    LVItem.iItem = -1;
    LVItem.iSubItem = 0;

    hComputerListWnd = GetDlgItem(hWnd, IDC_COMPUTERLIST);

    while ((LVItem.iItem = ListView_GetNextItem(hComputerListWnd, LVItem.iItem,
        LVNI_SELECTED)) != -1) 
    {
        ListView_GetItem(hComputerListWnd, &LVItem);

        RegEdit_SetWaitCursor(TRUE);
 
        RegEdit_ImportRegFile(hWnd, FALSE, pszFileName, (HTREEITEM) LVItem.lParam);

        RegEdit_OnKeyTreeRefresh(hWnd);
        RegEdit_SetWaitCursor(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regdwded.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGDWDED.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        24 Sep 1994
*
*  Dword edit dialog for use by the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regresid.h"
#include "reghelp.h"

const DWORD s_EditDwordValueHelpIDs[] = {
    IDC_VALUEDATA,      IDH_REGEDIT_VALUEDATA,
    IDC_VALUENAME,      IDH_REGEDIT_VALUENAME,
    IDC_HEXADECIMAL,    IDH_REGEDIT_DWORDBASE,
    IDC_DECIMAL,        IDH_REGEDIT_DWORDBASE,
    0, 0
};

const TCHAR s_DecimalFormatSpec[] = TEXT("%u");
const TCHAR s_HexadecimalFormatSpec[] = TEXT("%x");

//  Subclassed IDC_VALUEDATA's previous window procedure.  Only one instance of
//  this dialog is assumed to exist.
WNDPROC s_PrevValueDataWndProc;

//  The radio button that is currently selected: IDC_HEXADECIMAL or IDC_DECIMAL.
UINT s_SelectedBase;

UINT
PASCAL
GetDlgItemHex(
    HWND hWnd,
    int nIDDlgItem,
    BOOL *lpTranslated
    );

BOOL
PASCAL
EditDwordValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    );

VOID
PASCAL
EditDwordValue_SetValueDataText(
    HWND hWnd,
    LPEDITVALUEPARAM lpEditValueParam,
    UINT DlgItem
    );

LRESULT
CALLBACK
EditDwordValue_ValueDataWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL EditDwordValue_StoreDlgValueData(HWND hWnd, LPEDITVALUEPARAM lpEditValueParam);

/*******************************************************************************
*
*  GetDlgItemHex
*
*  DESCRIPTION:
*     Like GetDlgItemInt, only for hexadecimal numbers.
*
*  PARAMETERS:
*     See GetDlgItemInt.
*
*******************************************************************************/

UINT
PASCAL
GetDlgItemHex(
    HWND hWnd,
    int nIDDlgItem,
    BOOL *lpTranslated
    )
{

    TCHAR Buffer[10];                   //  Enough to hold 8 digits, null, extra
    UINT Length;
    DWORD Dword;
    UINT Index;
    DWORD Nibble;

    Dword = 0;

    //
    //  We'll assume that the edit control contains only valid characters and
    //  doesn't begin with any spaces (for Regedit this will be true).  So, we
    //  only need to validate that the length of the string isn't too long.
    //

    Length = GetDlgItemText(hWnd, nIDDlgItem, Buffer, ARRAYSIZE(Buffer));

    if (Length > 0 && Length <= 8) {

        for (Index = 0; Index < Length; Index++) {

            if (Buffer[Index] >= TEXT('0') && Buffer[Index] <= TEXT('9'))
                Nibble = Buffer[Index] - TEXT('0');
            else if (Buffer[Index] >= TEXT('a') && Buffer[Index] <= TEXT('f'))
                Nibble = Buffer[Index] - TEXT('a') + 10;
            else
                Nibble = Buffer[Index] - TEXT('A') + 10;

            Dword = (Dword << 4) + Nibble;

        }

        *lpTranslated = TRUE;
    }
    else
        *lpTranslated = FALSE;

    return Dword;

}

/*******************************************************************************
*
*  EditDwordValueDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
CALLBACK
EditDwordValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    LPEDITVALUEPARAM lpEditValueParam;
    BOOL Translated;
    DWORD Dword;

    lpEditValueParam = (LPEDITVALUEPARAM) GetWindowLongPtr(hWnd, DWLP_USER);

    switch (Message) {

        HANDLE_MSG(hWnd, WM_INITDIALOG, EditDwordValue_OnInitDialog);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDC_VALUEDATA:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS) 
                    {
                       // EditDwordValue_StoreDlgValueData(hWnd, lpEditValueParam);   
                    }
                    break;

                case IDC_DECIMAL:
                case IDC_HEXADECIMAL:
                    if (EditDwordValue_StoreDlgValueData(hWnd, lpEditValueParam))
                    {
                        EditDwordValue_SetValueDataText(hWnd, lpEditValueParam,
                            GET_WM_COMMAND_ID(wParam, lParam));
                    }
                    else
                    {
                        // Since the value cannot be stored (only happens with decimal to
                        // hex) undo the user's choice.
                        CheckRadioButton(hWnd, IDC_HEXADECIMAL, IDC_DECIMAL, IDC_DECIMAL);
                    }
                    break;

                case IDOK:
                    if (!EditDwordValue_StoreDlgValueData(hWnd, lpEditValueParam))
                    {
                        break;   
                    }
                    // FALL THROUGH

                case IDCANCEL:
                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

            }
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) s_EditDwordValueHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
                (ULONG_PTR) s_EditDwordValueHelpIDs);
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  EditDwordValue_OnInitDialog
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of EditDwordValue window.
*     hFocusWnd,
*     lParam,
*
*******************************************************************************/

BOOL
PASCAL
EditDwordValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    )
{

    LPEDITVALUEPARAM lpEditValueParam;

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);
    lpEditValueParam = (LPEDITVALUEPARAM) lParam;

    s_PrevValueDataWndProc = SubclassWindow(GetDlgItem(hWnd, IDC_VALUEDATA),
        EditDwordValue_ValueDataWndProc);

    SetDlgItemText(hWnd, IDC_VALUENAME, lpEditValueParam-> pValueName);

    CheckRadioButton(hWnd, IDC_HEXADECIMAL, IDC_DECIMAL, IDC_HEXADECIMAL);
    EditDwordValue_SetValueDataText(hWnd, lpEditValueParam, IDC_HEXADECIMAL);

    return TRUE;

    UNREFERENCED_PARAMETER(hFocusWnd);

}

/*******************************************************************************
*
*  EditDwordValue_SetValueDataText
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of EditDwordValue window.
*
*******************************************************************************/

VOID
PASCAL
EditDwordValue_SetValueDataText(
    HWND hWnd,
    LPEDITVALUEPARAM lpEditValueParam,
    UINT DlgItem
    )
{
    TCHAR Buffer[12];                    //  Enough to hold 2^32 in decimal
    LPCTSTR lpFormatSpec;
    UINT uEditLength;

    s_SelectedBase = DlgItem;

    if (s_SelectedBase == IDC_DECIMAL) 
    {
        uEditLength = 10;
    } 
    else 
    {
        uEditLength = 8;
    }

    SendDlgItemMessage( hWnd, IDC_VALUEDATA, EM_LIMITTEXT, ( WPARAM )uEditLength, 0L );
    

    lpFormatSpec = (DlgItem == IDC_HEXADECIMAL) ? s_HexadecimalFormatSpec : s_DecimalFormatSpec;

    StringCchPrintf(Buffer, ARRAYSIZE(Buffer), lpFormatSpec, ((LPDWORD) lpEditValueParam->pValueData)[0]);

    SetDlgItemText(hWnd, IDC_VALUEDATA, Buffer);
}

/*******************************************************************************
*
*  EditDwordValue_ValueDataEditProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of EditDwordValue window.
*
*******************************************************************************/

LRESULT
CALLBACK
EditDwordValue_ValueDataWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    TCHAR Char;

    switch (Message) {

        case WM_CHAR:
            Char = (TCHAR) wParam;

            if (Char >= TEXT(' ')) {

                if ((Char >= TEXT('0') && Char <= TEXT('9')))
                    break;

                if (s_SelectedBase == IDC_HEXADECIMAL &&
                    ((Char >= TEXT('A') && Char <= TEXT('F')) || ((Char >= TEXT('a')) &&
                    (Char <= TEXT('f')))))
                    break;

                MessageBeep(0);
                return 0;

            }
            break;

    }

    return CallWindowProc(s_PrevValueDataWndProc, hWnd, Message, wParam,
        lParam);

}

BOOL EditDwordValue_StoreDlgValueData(HWND hWnd, LPEDITVALUEPARAM lpEditValueParam)
{
    BOOL fTranslated = TRUE;
    DWORD dwValue = (s_SelectedBase == IDC_HEXADECIMAL) ?
        GetDlgItemHex(hWnd, IDC_VALUEDATA, &fTranslated) :
        GetDlgItemInt(hWnd, IDC_VALUEDATA, &fTranslated,
        FALSE);
    
    //
    // Special case: "" == 0
    //
    if(!fTranslated && GetWindowTextLength(GetDlgItem(hWnd, IDC_VALUEDATA)) == 0) {
        dwValue = 0;
        fTranslated = TRUE;
    }

    if (fTranslated)
    {
        ((LPDWORD) lpEditValueParam-> pValueData)[0] = dwValue;
    }
    else 
    {
        MessageBeep(0);
        
        if (InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_EDITDWTRUNCATEDEC), 
            MAKEINTRESOURCE(IDS_EDITWARNOVERFLOW), MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2,
            NULL) == IDYES)
        {
            // Truncate Value
            dwValue = 0xffffffff;
            ((LPDWORD) lpEditValueParam-> pValueData)[0] = dwValue;
            fTranslated = TRUE;
        }
    }
    return fTranslated;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regfdesc.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regfdesc.cxx

Abstract:

    This module contains the definitions of the member functions
    of FULL_DESCRIPTOR class.

Author:

    Jaime Sasson (jaimes) 02-Dec-1993

Environment:

    ULIB, User Mode


--*/

#include "regfdesc.hxx"
#include "regdesc.hxx"
#include "iterator.hxx"


DEFINE_CONSTRUCTOR ( FULL_DESCRIPTOR, OBJECT );


FULL_DESCRIPTOR::~FULL_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a FULL_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
    Destroy();
}


VOID
FULL_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct a FULL_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _InterfaceType = Internal;
        _BusNumber = 0;
        _Version = 0;
        _Revision = 0;
        _ResourceDescriptors = NULL;
}


VOID
FULL_DESCRIPTOR::Destroy (
    )

/*++

Routine Description:

    Worker method for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _InterfaceType = Internal;
    _BusNumber = 0;
    _Version = 0;
    _Revision = 0;
    if( _ResourceDescriptors != NULL ) {
        _ResourceDescriptors->DeleteAllMembers();
        DELETE( _ResourceDescriptors );
    }
    _ResourceDescriptors = NULL;
}



BOOLEAN
FULL_DESCRIPTOR::Initialize(
    IN  PCBYTE       Data,
    IN  ULONG        Size,
    OUT PULONG       DescriptorSize
    )

/*++

Routine Description:

    Initialize an object of type FULL_DESCRIPTOR.

Arguments:

    Data - Pointer to a buffer that contains a CM_FULL_RESOURCE_DESCRIPTOR.

    Size - Buffer size.

Return Value:

    BOOLEAN - Returns TRUE if the initialization succeeds.

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    FullResource;
    ULONG                           Count;
    ULONG                           i;
    ULONG                           j;

    PARRAY  TmpList;
    PPORT_DESCRIPTOR            PortDescriptor;
    PINTERRUPT_DESCRIPTOR       InterruptDescriptor;
    PMEMORY_DESCRIPTOR          MemoryDescriptor;
    PDMA_DESCRIPTOR             DmaDescriptor;
    PDEVICE_SPECIFIC_DESCRIPTOR DeviceSpecificDescriptor;
    ULONG                       DeviceSpecificDataSize;

    if( Data == NULL ) {
        return( FALSE );
    }

    Count           = 1;
    FullResource    = ( PCM_FULL_RESOURCE_DESCRIPTOR )Data;

    TmpList = ( PARRAY )NEW( ARRAY );
    if( ( TmpList == NULL ) ||
        ( !TmpList->Initialize() ) ) {
        DebugPrintTrace(("REGEDT32: Out of memory" ));
        DELETE( TmpList );
        return( FALSE );
    }

    _InterfaceType = FullResource->InterfaceType;
    _BusNumber = FullResource->BusNumber;
    _Version = FullResource->PartialResourceList.Version;
    _Revision = FullResource->PartialResourceList.Revision;

    //
    // For each CM_FULL_RESOURCE DESCRIPTOR in the current value...
    //

    for( i = 0; i < Count; i++ ) {

        PCM_PARTIAL_RESOURCE_DESCRIPTOR   PartialResourceDescriptor;

        //
        // For each CM_PARTIAL_RESOURCE_DESCRIPTOR in the list...
        //

        DeviceSpecificDataSize = 0;
        for( j = 0; j < FullResource->PartialResourceList.Count; j++ ) {

                //
                // Get a pointer to the current CM_PARTIAL_RESOURCE_DESCRIPTOR
                // in the current CM_FULLRESOURCE_DESCRIPTOR in the list.
                //

                PartialResourceDescriptor = &( FullResource[ i ].PartialResourceList.PartialDescriptors[ j ]);
                //
                //  Ignore invalid data
                //
                if( ( ULONG_PTR )PartialResourceDescriptor >
                        ( ULONG_PTR )( Data + Size - sizeof( CM_PARTIAL_RESOURCE_DESCRIPTOR ) ) ) {
                    DebugPrintTrace(( "REGEDT32: Invalid CM_PARTIAL_RESOURCE_DESCRIPTOR, j = %d \n", j ));
                    if( DescriptorSize != NULL ) {
                        *DescriptorSize = Size;
                    }
                    _ResourceDescriptors = TmpList;
                    return( TRUE );
                }

                switch( PartialResourceDescriptor->Type ) 
                {
                    case CmResourceTypePort:
                    {
                        PortDescriptor = ( PPORT_DESCRIPTOR )NEW( PORT_DESCRIPTOR );
                        PHYSICAL_ADDRESS portStartAddr = (PHYSICAL_ADDRESS) PartialResourceDescriptor->u.Port.Start;
                        if ( (PortDescriptor == NULL) ||
                            ( !PortDescriptor->Initialize( &portStartAddr,
                                                       PartialResourceDescriptor->u.Port.Length,
                                                       PartialResourceDescriptor->ShareDisposition,
                                                       PartialResourceDescriptor->Flags ) )
                        ) 
                        {
                            DebugPrintTrace(( "REGEDT32: Unable to create PORT_DESCRIPTOR" ));
                            DELETE( PortDescriptor );
                            TmpList->DeleteAllMembers();
                            DELETE( TmpList );
                            return( FALSE );
                        }
                        TmpList->Put( PortDescriptor );
                    }
                    break;

                    case CmResourceTypeInterrupt:
                    {
                        InterruptDescriptor = ( PINTERRUPT_DESCRIPTOR )NEW( INTERRUPT_DESCRIPTOR );
                        if ( ( InterruptDescriptor == NULL ) ||
                            ( !InterruptDescriptor->Initialize( PartialResourceDescriptor->u.Interrupt.Affinity,
                                                            PartialResourceDescriptor->u.Interrupt.Level,
                                                            PartialResourceDescriptor->u.Interrupt.Vector,
                                                            PartialResourceDescriptor->ShareDisposition,
                                                            PartialResourceDescriptor->Flags ) )
                            ) 
                        {
                            DebugPrintTrace(( "REGEDT32: Unable to create INTERRUPT_DESCRIPTOR" ));
                            DELETE( InterruptDescriptor );
                            TmpList->DeleteAllMembers();
                            DELETE( TmpList );
                            return( FALSE );
                        }
                        TmpList->Put( InterruptDescriptor );
                    }
                    break;

                    case CmResourceTypeMemory:
                    {
                        MemoryDescriptor = ( PMEMORY_DESCRIPTOR )NEW( MEMORY_DESCRIPTOR );
                        PHYSICAL_ADDRESS memStartAddr = (PHYSICAL_ADDRESS) PartialResourceDescriptor->u.Memory.Start;
                        if ( ( MemoryDescriptor == NULL ) ||
                            ( !MemoryDescriptor->Initialize( &memStartAddr,
                                                         PartialResourceDescriptor->u.Memory.Length,
                                                         PartialResourceDescriptor->ShareDisposition,
                                                         PartialResourceDescriptor->Flags ) )
                            ) 
                        {
                            DebugPrintTrace(( "REGEDT32: Unable to create MEMORY_DESCRIPTOR" ));
                            DELETE( MemoryDescriptor );
                            TmpList->DeleteAllMembers();
                            DELETE( TmpList );
                            return( FALSE );
                        }
                        TmpList->Put( MemoryDescriptor );
                    }
                    break;

                    case CmResourceTypeDma:
                    {
                        DmaDescriptor = ( PDMA_DESCRIPTOR )NEW( DMA_DESCRIPTOR );
                        if ( ( DmaDescriptor == NULL ) ||
                            ( !DmaDescriptor->Initialize( PartialResourceDescriptor->u.Dma.Channel,
                                                      PartialResourceDescriptor->u.Dma.Port,
                                                      PartialResourceDescriptor->u.Dma.Reserved1,
                                                      PartialResourceDescriptor->ShareDisposition,
                                                      PartialResourceDescriptor->Flags ) )
                            ) 
                        {
                            DebugPrintTrace(( "REGEDT32: Unable to create DMA_DESCRIPTOR" ));
                            DELETE( DmaDescriptor );
                            TmpList->DeleteAllMembers();
                            DELETE( TmpList );
                            return( FALSE );
                        }
                        TmpList->Put( DmaDescriptor );
                    }
                    break;

                    case CmResourceTypeDeviceSpecific:
                    {
                        DeviceSpecificDataSize = PartialResourceDescriptor->u.DeviceSpecificData.DataSize;
                        DeviceSpecificDescriptor = ( PDEVICE_SPECIFIC_DESCRIPTOR )NEW( DEVICE_SPECIFIC_DESCRIPTOR );
                        if ( ( DeviceSpecificDescriptor == NULL ) ||
                            ( !DeviceSpecificDescriptor->Initialize(
                                                      PartialResourceDescriptor->u.DeviceSpecificData.Reserved1,
                                                      PartialResourceDescriptor->u.DeviceSpecificData.Reserved2,
                                                      PartialResourceDescriptor->u.DeviceSpecificData.DataSize,
                                                      ( PBYTE )&PartialResourceDescriptor->u.DeviceSpecificData + 3*sizeof( ULONG ),
                                                      PartialResourceDescriptor->ShareDisposition,
                                                      PartialResourceDescriptor->Flags ) )
                            ) 
                        {
                            DebugPrintTrace(( "REGEDT32: Unable to create DEVICE_SPECIFIC_DESCRIPTOR" ));
                            DELETE( DeviceSpecificDescriptor );
                            TmpList->DeleteAllMembers();
                            DELETE( TmpList );
                            return( FALSE );
                        }
                        TmpList->Put( DeviceSpecificDescriptor );
                    }
                    break;

                    default:
                        DebugPrintTrace(( "REGEDT32: Unknown PartialResourceDescriptor->Type == %#x \n", PartialResourceDescriptor->Type ));
                        continue;
                }
        }

        _ResourceDescriptors = TmpList;
        //
        // Get the next CM_FULL_RESOURCE_DESCRIPTOR from the list.
        //

        FullResource = ( PCM_FULL_RESOURCE_DESCRIPTOR ) ( ( ULONG_PTR )FullResource +
                                                          sizeof( ULONG ) +
                                                          sizeof( ULONG ) +
                                                          sizeof( USHORT ) +
                                                          sizeof( USHORT ) +
                                                          sizeof( ULONG ) +
                                                          j*sizeof( CM_PARTIAL_RESOURCE_DESCRIPTOR ) +
                                                          DeviceSpecificDataSize );
//        FullResource = ( PCM_FULL_RESOURCE_DESCRIPTOR )( PartialResourceDescriptor + 1 );
//        FullResource = ( PCM_FULL_RESOURCE_DESCRIPTOR )( ( ULONG )FullResource +
//                                                            DeviceSpecificDataSize );
    }
    if( DescriptorSize != NULL ) {
        *DescriptorSize = ( ULONG )( ( ULONG_PTR )FullResource - ( ULONG_PTR )Data );

    }
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\reghelp.h ===
// Help IDs for RegEdit

#define NO_HELP				((DWORD) -1) // Disables Help for a control

#define IDH_REGEDIT_EXPORT		1000
#define IDH_REGEDIT_CONNECT		1001
#define IDH_REGEDIT_CONNECT_BROWSE	1002
#define IDH_REGEDIT_VALUENAME		1003
#define IDH_REGEDIT_VALUEDATA		1004
#define IDH_REGEDIT_LOOK		1005
#define IDH_FIND_SEARCHTEXT		1006
#define IDH_FIND_WHOLE			1007
#define IDH_FIND_NEXT_BUTTON		1008
#define IDH_REGEDIT_PRINTRANGE          1009
#define IDH_REGEDIT_DWORDBASE           1010
#define IDH_REGEDIT_DISCONNECT          1011
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regfind.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGFIND.H
*
*  VERSION:     4.00
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        14 Jul 1994
*
*******************************************************************************/

#ifndef _INC_REGFIND
#define _INC_REGFIND

extern DWORD g_FindFlags;

VOID
PASCAL
RegEdit_OnCommandFindNext(
    HWND hWnd,
    BOOL fForceDialog
    );

#endif // _INC_REGFIND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regedit.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGEDIT.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*******************************************************************************/

#include "pch.h"
#include <regstr.h>
#include "regedit.h"
#include "regkey.h"
#include "regvalue.h"
#include "regfile.h"
#include "regprint.h"
#include "regnet.h"
#include "regfind.h"
#include "regresid.h"
#include <htmlhelp.h>
#include <tchar.h>

#include "authz.h"
#include "objbase.h"
#include "aclapi.h"
#include "aclui.h"

extern HRESULT CreateSecurityInformation( IN LPCWSTR strKeyName,
                                          IN LPCWSTR strParentName,
                                          IN LPCWSTR strMachineName,
                                          IN LPCWSTR strPageTitle,
                                          IN BOOL    bRemote,
                                          IN PREDEFINE_KEY PredefinedKey,
                                          IN BOOL bReadOnly,
                                          IN HWND hWnd,
                                          OUT LPSECURITYINFO *pSi);

//
//  Popup menu indexes of the IDM_REGEDIT menu.
//

#define IDM_REGEDIT_FILE_POPUP          0
#define IDM_REGEDIT_EDIT_POPUP          1
#define IDM_REGEDIT_VIEW_POPUP          2
#define IDM_REGEDIT_FAVS_POPUP          3
#define IDM_REGEDIT_HELP_POPUP          4

//
//  Indexes of the "New->" popup menu under the IDM_REGEDIT's "Edit" menu when
//  the focus is in the KeyTree or the ValueList.  Changes because "Modify" and
//  a seperator are dynamically added/removed.
//

#define IDM_EDIT_WHENKEY_NEW_POPUP      0
#define IDM_EDIT_WHENVALUE_NEW_POPUP    2

//
//  Data structure stored in the registry to store the position and sizes of
//  various elements of the Registry Editor interface.
//

typedef struct _REGEDITVIEW {
    WINDOWPLACEMENT WindowPlacement;
    int xPaneSplit;
    int cxNameColumn;
    int cxTypeColumn;
    int cxDataColumn;
    DWORD Flags;
}   REGEDITVIEW, FAR* LPREGEDITVIEW;

#define REV_STATUSBARVISIBLE            0x00000001

//  Class name of main application window.
const TCHAR g_RegEditClassName[] = TEXT("RegEdit_RegEdit");

//  Applet specific information is stored under this key of HKEY_CURRENT_USER.
const TCHAR g_RegEditAppletKey[] = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\Regedit");
//
//  Favorites information is stored under this key of HKEY_CURRENT_USER
//
const TCHAR g_RegEditFavoritesKey[] = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\Regedit\\Favorites");

//  Record of type REGEDITVIEW under g_RegEditAppletKey.
const TCHAR g_RegEditViewValue[] = TEXT("View");
//  Record of type DWORD under g_RegEditAppletKey.
const TCHAR g_RegEditFindFlagsValue[] = TEXT("FindFlags");
//
//  Record of LPTSTR under g_RegEditAppletKey that rememebers that key where RegEdit was closed.
//
const TCHAR g_RegEditLastKeyValue[] = TEXT("LastKey");

//
//  Values for import/export of multiline strings
//
const TCHAR g_RegEditMultiStringsValue[] = TEXT("MultiStrings");

BOOL g_fMultiLineStrings = FALSE;


//  Data structure used when calling GetEffectiveClientRect (which takes into
//  account space taken up by the toolbars/status bars).  First half of the
//  pair is zero when at the end of the list, second half is the control id.
const int s_EffectiveClientRectData[] = {
    1, 0,                               //  For the menu bar, but is unused
    1, IDC_STATUSBAR,
    0, 0                                //  First zero marks end of data
};

//  Context sensitive help array used by the WinHelp engine.
const DWORD g_ContextMenuHelpIDs[] = {
    0, 0
};

//  Data structure used when calling MenuHelp.
const int s_RegEditMenuHelpData[] = {
    0, 0,
    0, (UINT) 0
};

REGEDITDATA g_RegEditData = {
    NULL,                               //  hKeyTreeWnd
    NULL,                               //  hValueListWnd
    NULL,                               //  hStatusBarWnd
    NULL,                               //  hFocusWnd
    0,                                  //  xPaneSplit
    NULL,                               //  hImageList
    NULL,                               //  hCurrentSelectionKey
    SCTS_INITIALIZING,                  //  SelChangeTimerState
    SW_SHOW,                            //  StatusBarShowCommand
    NULL,                               //  pDefaultValue
    NULL,                               //  pValueNotPresent
    NULL,                               //  pEmptyBinary
    NULL,                               //  pCollapse
    NULL,                               //  pModify
    NULL,                               //  pModifyBinary
    NULL,                               //  pNewKeyTemplate
    NULL,                               //  pNewValueTemplate
    FALSE,                              //  fAllowLabelEdits
    NULL,                               //  hMainMenu
    FALSE,                              //  fMainMenuInited
    FALSE,                              //  fHaveNetwork
    FALSE,                              //  fProcessingFind
    NULL,                               //  hMyComputer
    FILE_TYPE_REGEDIT5                  //  uExportFormat
};

BOOL
PASCAL
QueryRegEditView(
    LPREGEDITVIEW lpRegEditView
    );

LRESULT
PASCAL
RegEditWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
PASCAL
RegEdit_OnCreate(
    HWND hWnd,
    LPCREATESTRUCT lpCreateStruct
    );

BOOL
PASCAL
RegEdit_OnContextMenu(
    HWND hWnd,
    HWND hWndTarget,
    int xPos,
    int yPos
    );

VOID
PASCAL
RegEdit_OnDestroy(
    HWND hWnd
    );

LRESULT
PASCAL
RegEdit_OnNotify(
    HWND hWnd,
    int DlgItem,
    LPNMHDR lpNMHdr
    );

VOID
PASCAL
RegEdit_OnInitMenuPopup(
    HWND hWnd,
    HMENU hPopupMenu,
    UINT MenuPosition,
    BOOL fSystemMenu
    );

VOID
PASCAL
RegEdit_OnMenuSelect(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
PASCAL
RegEdit_OnLButtonDown(
    HWND hWnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT KeyFlags
    );

VOID
PASCAL
RegEdit_OnCommandSplit(
    HWND hWnd
    );

#define RESIZEFROM_UNKNOWN              0
#define RESIZEFROM_SPLIT                1

VOID
PASCAL
RegEdit_ResizeWindow(
    HWND hWnd,
    UINT ResizeFrom
    );

BOOL
PASCAL
RegEdit_SetImageLists(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_SetSysColors(
    VOID
    );

INT_PTR PASCAL
RegAddFavoriteDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

/*******************************************************************************
*
*  RegisterRegEditClass
*
*  DESCRIPTION:
*     Register the RegEdit window class with the system.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

BOOL
PASCAL
RegisterRegEditClass(
    VOID
    )
{

    WNDCLASSEX WndClassEx;

    WndClassEx.cbSize = sizeof(WNDCLASSEX);
    WndClassEx.style = CS_DBLCLKS | CS_BYTEALIGNWINDOW | CS_GLOBALCLASS;
    WndClassEx.lpfnWndProc = RegEditWndProc;
    WndClassEx.cbClsExtra = 0;
    WndClassEx.cbWndExtra = 0;
    WndClassEx.hInstance = g_hInstance;
    WndClassEx.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_REGEDIT));
    WndClassEx.hCursor = LoadCursor(g_hInstance, MAKEINTRESOURCE(IDC_SPLIT));
    WndClassEx.hbrBackground = (HBRUSH) (COLOR_3DFACE + 1);
    WndClassEx.lpszMenuName = MAKEINTRESOURCE(IDM_REGEDIT);
    WndClassEx.lpszClassName = g_RegEditClassName;
    WndClassEx.hIconSm = LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_REGEDIT),
        IMAGE_ICON, 16, 16, 0);

    return RegisterClassEx(&WndClassEx);

}

/*******************************************************************************
*
*  CreateRegEditWnd
*
*  DESCRIPTION:
*     Creates an instance of the RegEdit window.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

HWND
PASCAL
CreateRegEditWnd(
    VOID
    )
{

    PTSTR pTitle;
    HWND hRegEditWnd;
    REGEDITVIEW RegEditView;
    BOOL fQueryRegEditViewSuccess;

    if ((pTitle = LoadDynamicString(IDS_REGEDIT)) != NULL) {

        fQueryRegEditViewSuccess = QueryRegEditView(&RegEditView);

        hRegEditWnd = CreateWindowEx(WS_EX_WINDOWEDGE | WS_EX_ACCEPTFILES,
            g_RegEditClassName, pTitle, WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            NULL, NULL, g_hInstance, (LPVOID) &RegEditView);

        if (fQueryRegEditViewSuccess) 
        {
            RegEditView.WindowPlacement.length = sizeof(RegEditView.WindowPlacement);

            if (RegEditView.WindowPlacement.showCmd == SW_SHOWMINIMIZED)
                RegEditView.WindowPlacement.showCmd = SW_SHOWDEFAULT;

            SetWindowPlacement(hRegEditWnd, &RegEditView.WindowPlacement);
        }
        else
        {
            ShowWindow(hRegEditWnd, SW_SHOWDEFAULT);
        }

        DeleteDynamicString(pTitle);

    }

    else
        hRegEditWnd = NULL;

    return hRegEditWnd;

}

/*******************************************************************************
*
*  QueryRegEditView
*
*  DESCRIPTION:
*     Check the registry for a data structure that contains the last positions
*     of our various interface components.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

BOOL
PASCAL
QueryRegEditView(
    LPREGEDITVIEW lpRegEditView
    )
{

    BOOL fSuccess;
    HKEY hKey;
    DWORD cbValueData;
    DWORD Type;
    int cxIcon;
    HDC hDC;
    int PixelsPerInch;

    fSuccess = FALSE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, g_RegEditAppletKey, 0, KEY_QUERY_VALUE, &hKey))
    {
        //
        //  Sort of a hack, but while we're here, pull the last find flags from
        //  the registry as well.
        //

        cbValueData = sizeof(DWORD);

        RegEdit_QueryValueEx(hKey, (LPTSTR) g_RegEditFindFlagsValue, NULL, &Type,
            (LPBYTE) &g_FindFlags, &cbValueData);

        cbValueData = sizeof(REGEDITVIEW);

        if (RegEdit_QueryValueEx(hKey, (LPTSTR) g_RegEditViewValue, NULL, &Type,
            (LPBYTE) lpRegEditView, &cbValueData) == ERROR_SUCCESS &&
            Type == REG_BINARY && cbValueData == sizeof(REGEDITVIEW))
            fSuccess = TRUE;

        RegCloseKey(hKey);

    }

    //
    //  Validate the fields from the view data structure.  Several people have
    //  run into cases where the name and data column widths were invalid so
    //  they couldn't see them.  Without this validation, the only way to fix it
    //  is to run our application... ugh.
    //

    if (fSuccess) {

        cxIcon = GetSystemMetrics(SM_CXICON);

        if (lpRegEditView-> cxNameColumn < cxIcon)
            lpRegEditView-> cxNameColumn = cxIcon;

        if (lpRegEditView-> cxDataColumn < cxIcon)
            lpRegEditView-> cxDataColumn = cxIcon;

        if (lpRegEditView-> xPaneSplit < cxIcon)
            lpRegEditView-> xPaneSplit = cxIcon;

    }

    //
    //  This is probably our first time running the Registry Editor (or else
    //  there was some sort of registry error), so pick some good(?) defaults
    //  for the various interface components.
    //

    else {

        lpRegEditView-> Flags = REV_STATUSBARVISIBLE;

        //
        //  Figure out how many pixels there are in two logical inches.  We use this
        //  to set the initial size of the TreeView pane (this is what the Cabinet
        //  does) and of the Name column of the ListView pane.
        //

        hDC = GetDC(NULL);
        PixelsPerInch = GetDeviceCaps(hDC, LOGPIXELSX);
        ReleaseDC(NULL, hDC);

        lpRegEditView-> xPaneSplit = PixelsPerInch * 9 / 4;     //  2.25 inches
        lpRegEditView-> cxNameColumn = PixelsPerInch * 5 / 4;   //  1.25 inches
        lpRegEditView-> cxTypeColumn = PixelsPerInch * 5 / 4;   //  1.25 inches
        lpRegEditView-> cxDataColumn = PixelsPerInch * 3;       //  3.00 inches

    }

    return fSuccess;

}

/*******************************************************************************
*
*  RegEditWndProc
*
*  DESCRIPTION:
*     Callback procedure for the RegEdit window.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

LRESULT
PASCAL
RegEditWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    switch (Message) {

        HANDLE_MSG(hWnd, WM_CREATE, RegEdit_OnCreate);
        HANDLE_MSG(hWnd, WM_DESTROY, RegEdit_OnDestroy);
        HANDLE_MSG(hWnd, WM_COMMAND, RegEdit_OnCommand);
        HANDLE_MSG(hWnd, WM_NOTIFY, RegEdit_OnNotify);
        HANDLE_MSG(hWnd, WM_INITMENUPOPUP, RegEdit_OnInitMenuPopup);
        HANDLE_MSG(hWnd, WM_LBUTTONDOWN, RegEdit_OnLButtonDown);
        HANDLE_MSG(hWnd, WM_DROPFILES, RegEdit_OnDropFiles);

        //can't use HANDLE_MSG for this because we lose the sign on the x and y parms
        case WM_CONTEXTMENU:
            if (!RegEdit_OnContextMenu(hWnd, (HWND)(wParam), GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)))
                goto dodefault;
            break;

        //
        //  We have to update the status bar after a rename, but the tree item's
        //  text hasn't changed until after we return from the end notification,
        //  so we post this dummy message to tell ourselves to do it later.
        //
        case REM_UPDATESTATUSBAR:
            RegEdit_UpdateStatusBar();
            break;

        //
        //  We must watch for this message to know that when we're in
        //  WM_INITMENUPOPUP, we're really looking at the main menu and not a
        //  context menu.
        //
        case WM_INITMENU:
            g_RegEditData.fMainMenuInited = (g_RegEditData.hMainMenu == (HMENU)
                wParam);
            break;

        case WM_ACTIVATE:
            if (wParam == WA_INACTIVE)
                break;
            //  FALL THROUGH

        case WM_SETFOCUS:
            SetFocus(g_RegEditData.hFocusWnd);
            break;

        case WM_WININICHANGE:
            RegEdit_SetImageLists(hWnd);
            //  FALL THROUGH

        case WM_SYSCOLORCHANGE:
            RegEdit_SetSysColors();
            SendChildrenMessage(hWnd, Message, wParam, lParam);
            //  FALL THROUGH

        case WM_SIZE:
            RegEdit_ResizeWindow(hWnd, RESIZEFROM_UNKNOWN);
            break;

        case WM_TIMER:
            RegEdit_OnSelChangedTimer(hWnd);
            break;

        case WM_MENUSELECT:
            RegEdit_OnMenuSelect(hWnd, wParam, lParam);
            break;

        case WM_PAINT:
            //
            //  Force a paint of the TreeView if we're in the middle of a find.
            //  See REGFIND.C for details on this hack.
            //

            if (g_RegEditData.fProcessingFind) {

                SetWindowRedraw(g_RegEditData.hKeyTreeWnd, TRUE);
                UpdateWindow(g_RegEditData.hKeyTreeWnd);
                SetWindowRedraw(g_RegEditData.hKeyTreeWnd, FALSE);

            }
            goto dodefault;

        dodefault:
        default:
            return DefWindowProc(hWnd, Message, wParam, lParam);

    }

    return 0;

}

/*******************************************************************************
*
*  RegEdit_ExpandKeyPath
*
*  DESCRIPTION: Traverses registry tree to display the desired key path.
*
*  PARAMETERS:
*     lpExpandPath - Destination path of registry key to expand
*
*******************************************************************************/

VOID
PASCAL
RegEdit_ExpandKeyPath(
    LPTSTR lpExpandPath
    )
{
    HTREEITEM hItem, hNext;
    TCHAR KeyName[MAXKEYNAMEPATH*2];
    TCHAR ExpandBuffer[MAXKEYNAMEPATH*2];
    LPTSTR lpExpandBuffer = NULL;
    LPTSTR lpCurrent, lpOriginal;
    BOOL bLastNode = FALSE;
    TV_ITEM TVItem;

    // Make sure we aren't already at the destination path.
    hItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
    KeyTree_BuildKeyPath( g_RegEditData.hKeyTreeWnd, 
                            hItem, 
                            KeyName, 
                            ARRAYSIZE(KeyName), 
                            BKP_TOCOMPUTER);

    if (!lstrcmpi(KeyName, lpExpandPath))
        return;

    // Intialize KeyName to the My Computer string
    KeyTree_BuildKeyPath( g_RegEditData.hKeyTreeWnd, 
                            g_RegEditData.hMyComputer, 
                            KeyName, 
                            ARRAYSIZE(KeyName), 
                            BKP_TOCOMPUTER);

    // Walk backwards until we find a common root node and place that in KeyName.
    while ((hItem != g_RegEditData.hMyComputer) && hItem)
    {
        hItem = TreeView_GetParent(g_RegEditData.hKeyTreeWnd, hItem);
        
        KeyTree_BuildKeyPath( g_RegEditData.hKeyTreeWnd, 
                                hItem, 
                                KeyName, 
                                ARRAYSIZE(KeyName),
                                BKP_TOCOMPUTER);

        if (!_tcsncmp(KeyName, lpExpandPath, lstrlen(KeyName)))
            break;
    }
    
    // Make sure the common parent node is selected and visible.
    TreeView_SelectItem(g_RegEditData.hKeyTreeWnd, hItem);
    TreeView_EnsureVisible(g_RegEditData.hKeyTreeWnd, hItem);

    //
    // If the destination path is deeper than the common parent,
    // we want to null-terminate the path components so we can
    // expand the registry tree for each path sub-component.
    //
    StringCchCopy(ExpandBuffer, ARRAYSIZE(ExpandBuffer), lpExpandPath);

    lpOriginal = lpExpandBuffer = ExpandBuffer;

    if (lstrlen(lpExpandBuffer) >= lstrlen(KeyName))
    {
        while (!bLastNode)
        {
            // Try to find the next path separator
            lpCurrent = (LPTSTR) _tcschr(lpOriginal, TEXT('\\'));
            if (lpCurrent) 
            {            
                // Null-terminate the sub-string
                *lpCurrent = 0;

                // Check if there's more
                if (lpCurrent <= (lpExpandBuffer + lstrlen(KeyName)))
                {
                    // Now step over the path separator we just made NULL
                    lpOriginal = lpCurrent + 1;
                } else bLastNode = TRUE;
            } else bLastNode = TRUE;
        }

        // Now reset bLastNode to FALSE
        bLastNode = FALSE;
    }

    //
    // Get the first child from the common parent and start traversing the treeview
    //
    hItem = TreeView_GetChild(g_RegEditData.hKeyTreeWnd, hItem);
    while(hItem)
    {
        // Get a handle to the next node 
        hNext = TreeView_GetNextSibling(g_RegEditData.hKeyTreeWnd, hItem);

        // DebugAssert(sizeof(TVItem) == sizeof(TV_ITEM));
        ZeroMemory(&TVItem, sizeof(TVItem));
        TVItem.hItem = hItem;
        TVItem.mask = TVIF_TEXT;
        TVItem.pszText = KeyName;
        TVItem.cchTextMax = ARRAYSIZE(KeyName);
        TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);

        //
        // If the child node matches our path component, then we want to expand that node.
        //
        if (!lstrcmpi(KeyName, lpOriginal))
        {
            TreeView_Expand(g_RegEditData.hKeyTreeWnd, hItem, TVE_EXPAND);

            // Replace hNext with the first child of our freshly expanded node.
            hNext = TreeView_GetChild(g_RegEditData.hKeyTreeWnd, hItem);

            // If this is the last node, make it visible and return
            if (bLastNode || !lpCurrent)
            {
                TreeView_SelectItem(g_RegEditData.hKeyTreeWnd, hItem);
                TreeView_EnsureVisible(g_RegEditData.hKeyTreeWnd, hItem);
                return;
            }
            else lpOriginal = lpCurrent + 1;

            lpCurrent = (LPTSTR) _tcschr(lpOriginal, TEXT('\\'));
            if (!lpCurrent)
                bLastNode = TRUE;
            else *lpCurrent = 0;
        }

        // Repeat the loop with the appropriate next tree node
        hItem = hNext;
    }
}

/*******************************************************************************
*
*  RegEdit_OnContextMenu
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     hWndTarget, handle of window in which WM_CONTEXTMENU occurred.
*     xPos
*     yPos
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_OnContextMenu(
    HWND hWnd,
    HWND hWndTarget,
    int xPos,
    int yPos
    )
{
    BOOL bAccel = ((xPos == -1) && (yPos == -1)) ? TRUE : FALSE;
    if (hWndTarget == g_RegEditData.hKeyTreeWnd)
        RegEdit_OnKeyTreeContextMenu(hWndTarget, bAccel);
    else if (hWndTarget == g_RegEditData.hValueListWnd)
        RegEdit_OnValueListContextMenu(hWndTarget, bAccel);
    else
        return FALSE;
    return TRUE;
}

/*******************************************************************************
*
*  RegEdit_OnCreate
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_OnCreate(
    HWND hWnd,
    LPCREATESTRUCT lpCreateStruct
    )
{

    LPREGEDITVIEW lpRegEditView;
    UINT Index;
    TV_INSERTSTRUCT TVInsertStruct;
    TCHAR CheckChildrenKeyName[MAXKEYNAME];
    LV_COLUMN LVColumn;
    HMENU hPopupMenu;
    HKEY hKey;
    DWORD cbValueData;
    DWORD Type;
    TCHAR KeyName[MAXKEYNAMEPATH*2];
    LPTSTR lpKeyName = KeyName;
    DWORD dwStyleEx = WS_EX_CLIENTEDGE;
    DWORD dwLayout = 0;
    DWORD dwValue = 0;

    lpRegEditView = (LPREGEDITVIEW) lpCreateStruct-> lpCreateParams;

    //
    //  Load several strings that will be using very often to display the keys
    //  and values.
    //

    if ((g_RegEditData.pDefaultValue = LoadDynamicString(IDS_DEFAULTVALUE)) ==
        NULL)
        return FALSE;

    if ((g_RegEditData.pValueNotSet = LoadDynamicString(IDS_VALUENOTSET)) ==
        NULL)
        return FALSE;

    if ((g_RegEditData.pEmptyBinary = LoadDynamicString(IDS_EMPTYBINARY)) ==
        NULL)
        return FALSE;

    if ((g_RegEditData.pCollapse = LoadDynamicString(IDS_COLLAPSE)) == NULL)
        return FALSE;

    if ((g_RegEditData.pModify = LoadDynamicString(IDS_MODIFY)) == NULL)
        return FALSE;

    if ((g_RegEditData.pModifyBinary = LoadDynamicString(IDS_MODIFYBINARY)) == NULL)
        return FALSE;

    if ((g_RegEditData.pNewKeyTemplate =
        LoadDynamicString(IDS_NEWKEYNAMETEMPLATE)) == NULL)
        return FALSE;

    if ((g_RegEditData.pNewValueTemplate =
        LoadDynamicString(IDS_NEWVALUENAMETEMPLATE)) == NULL)
        return FALSE;

    /*
     * Check if the default layout for this process is RTL.  Most data
     * in the registry is best edited with LTR reading order.  So we
     * reverse the reading order for the two data windows (key tree and
     * value list) again.
     */
    if (GetProcessDefaultLayout(&dwLayout)) {
        if (dwLayout & LAYOUT_RTL) {
            dwStyleEx |= WS_EX_RTLREADING;  // Actually just switches back to LTR.
        }
    }

    //
    //  Create the left pane, a TreeView control that displays the keys of the
    //  registry.
    //

    if ((g_RegEditData.hKeyTreeWnd = CreateWindowEx(dwStyleEx,
        WC_TREEVIEW, NULL, WS_CHILD | WS_VISIBLE | WS_TABSTOP | TVS_HASBUTTONS |
        TVS_DISABLEDRAGDROP | TVS_LINESATROOT | TVS_HASLINES | TVS_EDITLABELS,
        0, 0, 0, 0, hWnd, (HMENU) IDC_KEYTREE, g_hInstance, NULL)) == NULL)
        return FALSE;

    //
    //  Create the right pane, a ListView control that displays the values of
    //  the currently selected key of the sibling TreeView control.
    //

    if ((g_RegEditData.hValueListWnd = CreateWindowEx(dwStyleEx,
        WC_LISTVIEW, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN |
        WS_TABSTOP | LVS_REPORT | LVS_ALIGNLEFT | LVS_EDITLABELS |
        LVS_SHAREIMAGELISTS | LVS_NOSORTHEADER, 0, 0, 0, 0, hWnd,
        (HMENU) IDC_VALUELIST, g_hInstance, NULL)) == NULL)
        return FALSE;

    ListView_SetExtendedListViewStyleEx(g_RegEditData.hValueListWnd,
            LVS_EX_LABELTIP, LVS_EX_LABELTIP);

    //
    //  Create the status bar window.  We'll set it to "simple" mode now
    //  because we need only one pane that's only used when scrolling through
    //  the menus.
    //

    if ((g_RegEditData.hStatusBarWnd = CreateStatusWindow(WS_CHILD |
        SBARS_SIZEGRIP | CCS_NOHILITE, NULL, hWnd, IDC_STATUSBAR)) == NULL)
        return FALSE;

    g_RegEditData.StatusBarShowCommand = lpRegEditView-> Flags &
        REV_STATUSBARVISIBLE ? SW_SHOW : SW_HIDE;
    ShowWindow(g_RegEditData.hStatusBarWnd, g_RegEditData.StatusBarShowCommand);

    if (!RegEdit_SetImageLists(hWnd))
        return FALSE;

    RegEdit_SetSysColors();

    //
    //
    //

    TVInsertStruct.hParent = TVI_ROOT;
    TVInsertStruct.hInsertAfter = TVI_LAST;
    TVInsertStruct.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE |
        TVIF_PARAM | TVIF_CHILDREN;
    //  TVInsertStruct.item.hItem = NULL;
    //  TVInsertStruct.item.state = 0;
    //  TVInsertStruct.item.stateMask = 0;
    //  TVInsertStruct.item.cchTextMax = 0;

    TVInsertStruct.item.iImage = IMAGEINDEX(IDI_COMPUTER);
    TVInsertStruct.item.iSelectedImage = IMAGEINDEX(IDI_COMPUTER);
    TVInsertStruct.item.cChildren = TRUE;
    TVInsertStruct.item.lParam = 0;

    TVInsertStruct.item.pszText = LoadDynamicString(IDS_COMPUTER);
    TVInsertStruct.hParent = TreeView_InsertItem(g_RegEditData.hKeyTreeWnd,
        &TVInsertStruct);
    DeleteDynamicString(TVInsertStruct.item.pszText);

    TVInsertStruct.item.iImage = IMAGEINDEX(IDI_FOLDER);
    TVInsertStruct.item.iSelectedImage = IMAGEINDEX(IDI_FOLDEROPEN);

    for (Index = 0; Index < NUMBER_REGISTRY_ROOTS; Index++) {

#ifdef WINNT
    //
    //  HKEY_DYN_DATA is not available on NT, so don't bother including it
    //  in the tree.  Note we still keep the string around in case we can
    //  connect to the key remotely.
    //

    if (Index == INDEX_HKEY_DYN_DATA)
        continue;
#endif

        TVInsertStruct.item.pszText = g_RegistryRoots[Index].lpKeyName;
        TVInsertStruct.item.lParam = (LPARAM) g_RegistryRoots[Index].hKey;

        TVInsertStruct.item.cChildren = ( RegEnumKey( g_RegistryRoots[Index].hKey,
                                                        0, 
                                                        CheckChildrenKeyName, 
                                                        ARRAYSIZE(CheckChildrenKeyName)) 
                                            == ERROR_SUCCESS);

        TreeView_InsertItem(g_RegEditData.hKeyTreeWnd, &TVInsertStruct);

    }

    TreeView_Expand(g_RegEditData.hKeyTreeWnd, TVInsertStruct.hParent,
        TVE_EXPAND);
    TreeView_SelectItem(g_RegEditData.hKeyTreeWnd, TVInsertStruct.hParent);

    g_RegEditData.SelChangeTimerState = SCTS_TIMERCLEAR;

    //
    //
    //

    g_RegEditData.hFocusWnd = g_RegEditData.hKeyTreeWnd;

    g_RegEditData.xPaneSplit = lpRegEditView-> xPaneSplit;

    //
    //  Set the column headings used by our report-style ListView control.
    //

    LVColumn.mask = LVCF_WIDTH | LVCF_TEXT;

    LVColumn.cx = lpRegEditView-> cxNameColumn;
    LVColumn.pszText = LoadDynamicString(IDS_NAMECOLUMNLABEL);
    ListView_InsertColumn(g_RegEditData.hValueListWnd, 0, &LVColumn);
    DeleteDynamicString(LVColumn.pszText);

    LVColumn.cx = lpRegEditView-> cxTypeColumn;
    LVColumn.pszText = LoadDynamicString(IDS_TYPECOLUMNLABEL);
    ListView_InsertColumn(g_RegEditData.hValueListWnd, 1, &LVColumn);
    DeleteDynamicString(LVColumn.pszText);

    LVColumn.cx = lpRegEditView-> cxDataColumn;
    LVColumn.pszText = LoadDynamicString(IDS_DATACOLUMNLABEL);
    ListView_InsertColumn(g_RegEditData.hValueListWnd, 2, &LVColumn);
    DeleteDynamicString(LVColumn.pszText);

    //
    //  Do a one-time zero fill of the PRINTDLGEX to have it in a known state.
    //

    memset(&g_PrintDlg, 0, sizeof(g_PrintDlg));

    g_RegEditData.hMainMenu = GetMenu(hWnd);
    g_RegEditData.fHaveNetwork = GetSystemMetrics(SM_NETWORK) & RNC_NETWORKS;

    if (!g_RegEditData.fHaveNetwork) 
    {
        hPopupMenu = GetSubMenu(g_RegEditData.hMainMenu,
            IDM_REGEDIT_FILE_POPUP);

        DeleteMenu(hPopupMenu, ID_CONNECT, MF_BYCOMMAND);
        DeleteMenu(hPopupMenu, ID_DISCONNECT, MF_BYCOMMAND);
        DeleteMenu(hPopupMenu, ID_NETSEPARATOR, MF_BYCOMMAND);
    }

    g_RegEditData.hMyComputer = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);

    //
    //  Send the tree-view control to the last location, if one is set.
    //
    if (RegOpenKey(HKEY_CURRENT_USER, g_RegEditAppletKey, &hKey) == ERROR_SUCCESS)     
    {
        cbValueData = MAXKEYNAMEPATH * 2;

        if (RegEdit_QueryValueEx(hKey, (LPTSTR) g_RegEditLastKeyValue, NULL, &Type,
            (LPBYTE) lpKeyName, &cbValueData) == ERROR_SUCCESS &&
            Type == REG_SZ && cbValueData > 0)
        {
            RegEdit_ExpandKeyPath(lpKeyName);
        }

        cbValueData = sizeof(dwValue);
        
        if ((RegEdit_QueryValueEx(hKey, (LPTSTR) g_RegEditMultiStringsValue, NULL, &Type,
            (LPBYTE) &dwValue, &cbValueData) == ERROR_SUCCESS) &&
            (Type == REG_DWORD) && (cbValueData > 0) && (dwValue != 0))
        {
            g_fMultiLineStrings = TRUE;
        }

        RegCloseKey(hKey);  
    }

    return TRUE;

}

/*******************************************************************************
*
*  RegEdit_OnDestroy
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnDestroy(
    HWND hWnd
    )
{

    REGEDITVIEW RegEditView;
    HKEY hKey;
    HWND hValueListWnd;
    DWORD cbValueData;
    HWND hKeyTreeWnd;
    TCHAR KeyName[MAXKEYNAMEPATH * 2];

    //
    //  Write out a new RegEditView record to the registry for our next
    //  (hopeful?) activation.
    //

    if (RegCreateKey(HKEY_CURRENT_USER, g_RegEditAppletKey, &hKey) == ERROR_SUCCESS) 
    {
        RegEditView.WindowPlacement.length = sizeof(WINDOWPLACEMENT);
        GetWindowPlacement(hWnd, &RegEditView.WindowPlacement);

        RegEditView.xPaneSplit = g_RegEditData.xPaneSplit;

        hValueListWnd = g_RegEditData.hValueListWnd;
        RegEditView.cxNameColumn = ListView_GetColumnWidth(hValueListWnd, 0);
        RegEditView.cxTypeColumn = ListView_GetColumnWidth(hValueListWnd, 1);
        RegEditView.cxDataColumn = ListView_GetColumnWidth(hValueListWnd, 2);

        RegEditView.Flags = (g_RegEditData.StatusBarShowCommand == SW_HIDE) ?
            0 : REV_STATUSBARVISIBLE;

        cbValueData = sizeof(REGEDITVIEW);
        RegSetValueEx(hKey, g_RegEditViewValue, 0, REG_BINARY, (LPBYTE) &RegEditView, cbValueData);

        cbValueData = sizeof(DWORD);
        RegSetValueEx(hKey, g_RegEditFindFlagsValue, 0, REG_DWORD, (LPBYTE) &g_FindFlags, cbValueData);

        //
        // Save the key before RegEdit closes so we can start there next time!
        //
        hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
        
        KeyTree_BuildKeyPath( hKeyTreeWnd,
                                TreeView_GetSelection(hKeyTreeWnd), 
                                KeyName, 
                                ARRAYSIZE(KeyName),
                                BKP_TOCOMPUTER);

        cbValueData = (lstrlen(KeyName) + 1) * sizeof(TCHAR);
        RegSetValueEx(hKey, g_RegEditLastKeyValue, 0, REG_SZ, (LPBYTE) KeyName, cbValueData);

        RegCloseKey(hKey);

    }

    TreeView_SelectItem(g_RegEditData.hKeyTreeWnd, NULL);

    if (g_RegEditData.hCurrentSelectionKey != NULL)
        RegCloseKey(g_RegEditData.hCurrentSelectionKey);

    if (g_RegEditData.hImageList != NULL)
        ImageList_Destroy(g_RegEditData.hImageList);

    PostQuitMessage(0);

}

/*******************************************************************************
*
*  RegAddFavoriteDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
PASCAL
RegAddFavoriteDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static LPTSTR lpFavoriteName;

    switch (Message) {

        case WM_INITDIALOG:
            lpFavoriteName = (LPTSTR) lParam;
            SendDlgItemMessage(hWnd, IDC_FAVORITENAME, EM_SETLIMITTEXT,
                MAXKEYNAMEPATH, 0);
            SetWindowText(GetDlgItem(hWnd, IDC_FAVORITENAME), (LPTSTR) lParam);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDC_FAVORITENAME:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                        EnableWindow(GetDlgItem(hWnd, IDOK),
                            SendMessage(GET_WM_COMMAND_HWND(wParam, lParam),
                            WM_GETTEXTLENGTH, 0, 0) != 0);
                    break;

                case IDOK:
                    GetDlgItemText(hWnd, IDC_FAVORITENAME, lpFavoriteName,
                        MAXKEYNAMEPATH);
                    //  FALL THROUGH

                case IDCANCEL:
                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

            }
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  RegEdit_OnAddToFavorites
*
*  DESCRIPTION:
*     Handles the selection of Favorites
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnAddToFavorites(
    HWND hWnd
    )
{
    TCHAR KeyName[MAXKEYNAMEPATH*2];
    TCHAR FavoriteName[MAXKEYNAMEPATH*2];
    LPTSTR lpFavoriteName = NULL;
    LPTSTR lpCurrent, lpOriginal;
    DWORD cbValueData, dwType;
    LONG lRet;
    HKEY hKey;

    if (RegCreateKey(HKEY_CURRENT_USER, g_RegEditFavoritesKey, &hKey) == ERROR_SUCCESS) 
    {
        KeyTree_BuildKeyPath( g_RegEditData.hKeyTreeWnd, 
                                TreeView_GetSelection(g_RegEditData.hKeyTreeWnd), 
                                KeyName, 
                                ARRAYSIZE(KeyName),
                                BKP_TOCOMPUTER);

        lpOriginal = lpCurrent = KeyName;
        while (lpCurrent)
        {
            lpCurrent = (LPTSTR) _tcsrchr(lpOriginal, TEXT('\\'));
            if (lpCurrent)
            {
                lpCurrent++;
                lpOriginal = lpCurrent;
            }
        }

        while (TRUE)
        {
            StringCchCopy(FavoriteName, ARRAYSIZE(FavoriteName), lpOriginal);

            lpFavoriteName = FavoriteName;
            if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_ADDFAVORITE), hWnd,
                RegAddFavoriteDlgProc, (LPARAM) lpFavoriteName) != IDOK)
            {
                RegCloseKey(hKey);
                return;
            }

            if (*lpFavoriteName)
            {
                lRet = RegEdit_QueryValueEx(hKey, lpFavoriteName, NULL, &dwType, NULL, NULL);
                if (lRet)
                    break;
                
                InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_FAVORITEEXISTS), 
                    MAKEINTRESOURCE(IDS_FAVORITEERROR), MB_ICONERROR | MB_OK);
            }
        }
    
        cbValueData = (lstrlen(KeyName) + 1) * sizeof(TCHAR);
        RegSetValueEx(hKey, lpFavoriteName, 0, REG_SZ, (LPBYTE) KeyName, cbValueData);
        
        RegCloseKey(hKey);
    }
}


/*******************************************************************************
*
*  RegRemoveFavoriteDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
PASCAL
RegRemoveFavoriteDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    TCHAR KeyName[MAXKEYNAMEPATH*2];
    LPTSTR lpKeyName = KeyName;
    TCHAR ValueName[MAXKEYNAMEPATH*2];
    LPTSTR lpValueName = ValueName;
    DWORD cbValueName, dwType;
    HWND hListBox;
    HKEY hKey = NULL;
    LONG lRet;
    int i = 0;
    
    switch (Message) {

        case WM_INITDIALOG:

            if (RegCreateKey(HKEY_CURRENT_USER, g_RegEditFavoritesKey, &hKey) == ERROR_SUCCESS) 
            {
                while (TRUE)
                {           
                    cbValueName = MAXKEYNAMEPATH * 2;
                    lRet = RegEnumValue(hKey, i++, lpValueName, &cbValueName, NULL, &dwType, NULL, NULL);
                    if (lRet)
                        break;
                    ListBox_AddString(GetDlgItem(hWnd, IDC_FAVORITES), lpValueName);
                }
                RegCloseKey(hKey);
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDOK:
                    hListBox = GetDlgItem(hWnd, IDC_FAVORITES);
                    if (ListBox_GetSelCount(hListBox) > 0)
                    {
                        if (RegCreateKey(HKEY_CURRENT_USER, g_RegEditFavoritesKey, &hKey) == ERROR_SUCCESS) 
                        {
                            for(i=0;i<ListBox_GetCount(hListBox);i++)
                            {
                                if (ListBox_GetSel(hListBox, i) != 0)
                                {
                                    ListBox_GetText(hListBox, i, lpValueName);
                                    RegDeleteValue(hKey, lpValueName);
                                }
                            }
                        }
                    }
                    // Fall through

                case IDCANCEL:
                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

            }
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  RegEdit_OnRemoveFavorite
*
*  DESCRIPTION:
*     Handles the removal of Favorites
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnRemoveFavorite(
    HWND hWnd
    )
{
    DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_REMFAVORITE), hWnd,
        RegRemoveFavoriteDlgProc, (LPARAM) NULL);
}

/*******************************************************************************
*
*  RegEdit_OnSelectFavorite
*
*  DESCRIPTION:
*     Handles the selection of Favorites
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     DlgItem, the favorite index
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnSelectFavorite(
    HWND hWnd,
    int DlgItem
    )
{
    TCHAR KeyName[MAXKEYNAMEPATH*2];
    LPTSTR lpKeyName = KeyName;
    TCHAR ValueName[MAXKEYNAMEPATH*2];
    LPTSTR lpValueName = ValueName;
    DWORD cbValueData, cbValueName, dwType;
    HKEY hKey;

    if (RegOpenKey(HKEY_CURRENT_USER, g_RegEditFavoritesKey, &hKey) == ERROR_SUCCESS) 
    {
        cbValueData = MAXKEYNAMEPATH * 2;
        cbValueName = MAXKEYNAMEPATH * 2;

        if (RegEnumValue(hKey, DlgItem - ID_ADDTOFAVORITES - 1, lpValueName, &cbValueName, NULL, 
            &dwType, (LPBYTE) lpKeyName, &cbValueData) == ERROR_SUCCESS &&
            dwType == REG_SZ && cbValueData > 0)
        {
            RegEdit_ExpandKeyPath(lpKeyName);
        }

        RegCloseKey(hKey);  
    }
}

/*******************************************************************************
*
*  RegEdit_OnFavorites
*
*  DESCRIPTION:
*     Handles the selection of Favorites
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnFavorites(
    HWND hWnd,
    UINT uItem
    )
{
    TCHAR KeyName[MAXKEYNAMEPATH*2];
    LPTSTR lpKeyName = KeyName;
    TCHAR ValueName[MAXKEYNAMEPATH*2];
    LPTSTR lpValueName = ValueName;
    TCHAR DataBuffer[MAXKEYNAMEPATH*2];
    LPTSTR lpData = DataBuffer;
    HMENU hMenu, hMainMenu;
    MENUITEMINFO mii;
    DWORD cbValueName, cbData, dwType;
    BOOL bRet = TRUE;
    HKEY hKey;
    LONG lRet;
    UINT i = 0;

    // Get the main RegEdit Menu handle
    hMainMenu = GetMenu(hWnd);
    if (!hMainMenu)
    {
        return;
    }

    // Now get the handle to the Favorites submenu
    hMenu = GetSubMenu(hMainMenu, uItem);
    if (!hMenu)
    {
        return;
    }

    ZeroMemory(&mii, sizeof(mii));
    mii.cbSize = sizeof(mii);
    // DebugAssert(mii.cbSize == sizeof(MENUITEMINFO));
    mii.fMask = MIIM_STATE;
    mii.fState = MFS_DISABLED;
    SetMenuItemInfo(hMenu, ID_REMOVEFAVORITE, FALSE, &mii);
    
    // Now remove every menuitem after the separator so we have a clean slate.
    i = 2;
    while (bRet)
    {
        bRet = DeleteMenu(hMenu, i, MF_BYPOSITION);
    }

    if (RegCreateKey(HKEY_CURRENT_USER, g_RegEditFavoritesKey, &hKey) == ERROR_SUCCESS) 
    {
        i = 0;

        while (TRUE)
        {           
            cbValueName = cbData = MAXKEYNAMEPATH * 2;
            lRet = RegEnumValue(hKey, i, lpValueName, &cbValueName, NULL, &dwType, (LPBYTE) lpData, &cbData);
            if (lRet)
                break;

            if (!i)
            {
                // Enable the "Remove Favorites" menu
                ZeroMemory(&mii, sizeof(mii));
                mii.cbSize = sizeof(mii);
                // DebugAssert(mii.cbSize == sizeof(MENUITEMINFO));
                mii.fMask = MIIM_STATE;
                mii.fState = MFS_ENABLED;
                SetMenuItemInfo(hMenu, ID_REMOVEFAVORITE, FALSE, &mii);

                // Add a separator to make things pretty
                ZeroMemory(&mii, sizeof(mii));
                mii.cbSize = sizeof(mii);
                // DebugAssert(mii.cbSize == sizeof(MENUITEMINFO));
                mii.fMask = MIIM_TYPE;
                mii.fType = MFT_SEPARATOR;
                InsertMenuItem(hMenu, (UINT) -1, 2, &mii);
            }

            ZeroMemory(&mii, sizeof(mii)); 
            mii.cbSize = sizeof(mii);
            // DebugAssert(mii.cbSize == sizeof(MENUITEMINFO));
            mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
            mii.fType = MFT_STRING;
            mii.wID   = ID_ADDTOFAVORITES + i + 1;
            mii.dwTypeData = lpValueName;
            mii.fState = MFS_ENABLED;
            mii.cch = lstrlen(lpValueName);
            InsertMenuItem(hMenu, ID_ADDTOFAVORITES + i + 1, FALSE, &mii);

            i++;
        }
        
        RegCloseKey(hKey);
    }

    DrawMenuBar(hWnd);
}

/*******************************************************************************
*
*  RegEdit_OnCommand
*
*  DESCRIPTION:
*     Handles the selection of a menu item by the user, notification messages
*     from a child control, or translated accelerated keystrokes for the
*     RegEdit window.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     DlgItem, identifier of control.
*     hControlWnd, handle of control.
*     NotificationCode, notification code from control.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCommand(
    HWND hWnd,
    int DlgItem,
    HWND hControlWnd,
    UINT NotificationCode
    )
{

    PTSTR pAppName;

    //
    //  Check to see if this menu command should be handled by the main window's
    //  command handler.
    //

    if (DlgItem >= ID_FIRSTCONTEXTMENUITEM && DlgItem <=
        ID_LASTCONTEXTMENUITEM) {

        if (g_RegEditData.hFocusWnd == g_RegEditData.hKeyTreeWnd)
            RegEdit_OnKeyTreeCommand(hWnd, DlgItem, NULL);

        else
            RegEdit_OnValueListCommand(hWnd, DlgItem);

    }

    switch (DlgItem) {

        case ID_IMPORTREGFILE:
            RegEdit_OnCommandImportRegFile(hWnd);
            break;

        case ID_EXPORTREGFILE:
            RegEdit_OnCommandExportRegFile(hWnd);
            break;

        case ID_LOADHIVE:
            RegEdit_OnCommandLoadHive(hWnd);
            break;
        
        case ID_UNLOADHIVE:
            RegEdit_OnCommandUnloadHive(hWnd);
            break;

        case ID_CONNECT:
            RegEdit_OnCommandConnect(hWnd);
            break;

        case ID_DISCONNECT:
            RegEdit_OnCommandDisconnect(hWnd);
            break;

        case ID_PRINT:
            RegEdit_OnCommandPrint(hWnd);
            break;

        case ID_EXIT:
            PostMessage(hWnd, WM_CLOSE, 0, 0);
            break;

        case ID_FIND:
            RegEdit_OnCommandFindNext(hWnd, TRUE);
            break;

        case ID_FINDNEXT:
            RegEdit_OnCommandFindNext(hWnd, FALSE);
            break;

        case ID_NEWKEY:
            RegEdit_OnNewKey(hWnd,
                TreeView_GetSelection(g_RegEditData.hKeyTreeWnd));
            break;

        case ID_NEWSTRINGVALUE:
            RegEdit_OnNewValue(hWnd, REG_SZ);
            break;

        case ID_NEWBINARYVALUE:
            RegEdit_OnNewValue(hWnd, REG_BINARY);
            break;

        case ID_NEWDWORDVALUE:
            RegEdit_OnNewValue(hWnd, REG_DWORD);
            break;

        case ID_NEWMULTSZVALUE:
            RegEdit_OnNewValue(hWnd, REG_MULTI_SZ);
            break;

        case ID_NEWEXPSZVALUE:
            RegEdit_OnNewValue(hWnd, REG_EXPAND_SZ);
            break;

        //
        //  Show or hide the status bar.  In either case, we'll need to resize
        //  the KeyTree and ValueList panes.
        //

        case ID_STATUSBAR:
            g_RegEditData.StatusBarShowCommand =
                (g_RegEditData.StatusBarShowCommand == SW_HIDE) ? SW_SHOW :
                SW_HIDE;
            ShowWindow(g_RegEditData.hStatusBarWnd,
                g_RegEditData.StatusBarShowCommand);
            RegEdit_ResizeWindow(hWnd, RESIZEFROM_UNKNOWN);
            break;

        case ID_SPLIT:
            RegEdit_OnCommandSplit(hWnd);
            break;

        case ID_DISPLAYBINARY:
            RegEdit_DisplayBinaryData(hWnd);
            break;

        case ID_REFRESH:
            RegEdit_OnKeyTreeRefresh(hWnd);
            break;

        case ID_ABOUT:
            pAppName = LoadDynamicString(IDS_REGEDIT);
            ShellAbout(hWnd, pAppName, g_NullString, LoadIcon(g_hInstance,
                MAKEINTRESOURCE(IDI_REGEDIT)));
            DeleteDynamicString(pAppName);
            break;

        //
        //  Cycle the focus to the next pane when the user presses "tab".  The
        //  assumption is made that there are only two panes, so the tab
        //  direction doesn't really matter.
        //

        case ID_CYCLEFOCUS:
            SetFocus(((g_RegEditData.hFocusWnd == g_RegEditData.hKeyTreeWnd) ?
                g_RegEditData.hValueListWnd : g_RegEditData.hKeyTreeWnd));
            break;

        case ID_HELPTOPICS:
            HtmlHelp( GetDesktopWindow(), TEXT("regedit.chm"), HH_HELP_FINDER, 0);
            break;

        case ID_COPYKEYNAME:
            RegEdit_OnCopyKeyName(hWnd,
            TreeView_GetSelection(g_RegEditData.hKeyTreeWnd));
            break;

        case ID_REMOVEFAVORITE:
            RegEdit_OnRemoveFavorite(hWnd);
            break;

        case ID_ADDTOFAVORITES:
            RegEdit_OnAddToFavorites(hWnd);
            break;

        case ID_PERMISSIONS:
            RegEdit_InvokeSecurityEditor(hWnd);
            break;

        default:
            if (DlgItem > ID_ADDTOFAVORITES)
            {
                RegEdit_OnSelectFavorite(hWnd, DlgItem);
                break;
            }
    }

    UNREFERENCED_PARAMETER(hControlWnd);

}

/*******************************************************************************
*
*  RegEdit_OnNotify
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     DlgItem, identifier of control.
*     lpNMTreeView, control notification data.
*
*******************************************************************************/

LRESULT
PASCAL
RegEdit_OnNotify(
    HWND hWnd,
    int DlgItem,
    LPNMHDR lpNMHdr
    )
{

    switch (DlgItem) {

        case IDC_KEYTREE:
            switch (lpNMHdr-> code) {

                case TVN_ITEMEXPANDING:
                    return RegEdit_OnKeyTreeItemExpanding(hWnd,
                        (LPNM_TREEVIEW) lpNMHdr);

                case TVN_SELCHANGED:
                    RegEdit_OnKeyTreeSelChanged(hWnd, (LPNM_TREEVIEW) lpNMHdr);
                    break;

                case TVN_BEGINLABELEDIT:
                    return RegEdit_OnKeyTreeBeginLabelEdit(hWnd,
                        (TV_DISPINFO FAR*) lpNMHdr);

                case TVN_ENDLABELEDIT:
                    return RegEdit_OnKeyTreeEndLabelEdit(hWnd,
                        (TV_DISPINFO FAR*) lpNMHdr);

                case NM_SETFOCUS:
                    g_RegEditData.hFocusWnd = g_RegEditData.hKeyTreeWnd;
                    break;

            }
            break;

        case IDC_VALUELIST:
            switch (lpNMHdr-> code) {

                case LVN_BEGINLABELEDIT:
                    return RegEdit_OnValueListBeginLabelEdit(hWnd,
                        (LV_DISPINFO FAR*) lpNMHdr);

                case LVN_ENDLABELEDIT:
                    return RegEdit_OnValueListEndLabelEdit(hWnd,
                        (LV_DISPINFO FAR*) lpNMHdr);

                case NM_RETURN:
                case NM_DBLCLK:
                    RegEdit_OnValueListModify(hWnd, FALSE);
                    break;

                case NM_SETFOCUS:
                    g_RegEditData.hFocusWnd = g_RegEditData.hValueListWnd;
                    break;

            }
            break;

    }

    return 0;

}

/*******************************************************************************
*
*  RegEdit_OnInitMenuPopup
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnInitMenuPopup(
HWND hWnd,
HMENU hPopupMenu,
UINT MenuPosition,
BOOL fSystemMenu
)
{
    UINT uEnableFlags;
    int NewPopupPosition;
    HTREEITEM hSelectedTreeItem;
    HTREEITEM hComputerItem;
    HWND hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
    
    //
    //  We don't care about the items in the system menu or any of the context
    //  menus.  All of the context menus should have been initialized already.
    //
    
    if (fSystemMenu || !g_RegEditData.fMainMenuInited)
        return;
    
    switch (MenuPosition) 
    {
    case IDM_REGEDIT_FILE_POPUP:
        {
            Regedit_EnableHiveMenuItems(hPopupMenu);

            if (g_RegEditData.fHaveNetwork) 
            {
                //  Enable or disable the "disconnect..." item depending on
                //  whether or not we have any open connections.
                uEnableFlags = (TreeView_GetNextSibling(hKeyTreeWnd,
                    TreeView_GetRoot(hKeyTreeWnd)) != NULL) ? MF_BYCOMMAND |
                    MF_ENABLED : MF_BYCOMMAND | MF_GRAYED;
                EnableMenuItem(hPopupMenu, ID_DISCONNECT, uEnableFlags);
            }
        }
        break;
        
    case IDM_REGEDIT_EDIT_POPUP:
        // Cannot show permissions for "My Computer"
        hSelectedTreeItem = TreeView_GetSelection(hKeyTreeWnd);
        EnableMenuItem(hPopupMenu, ID_PERMISSIONS,
            (TreeView_GetParent(hKeyTreeWnd, hSelectedTreeItem) != NULL) ? 
            (MF_BYCOMMAND | MF_ENABLED) : (MF_BYCOMMAND | MF_GRAYED));

        if (g_RegEditData.hFocusWnd == hKeyTreeWnd) 
        {
            
            //
            //  Don't show items that are specific only to the ValueList
            //  context.
            //
            
            if (GetMenuItemID(hPopupMenu, 0) == ID_MODIFY) 
            {
                DeleteMenu(hPopupMenu, 0, MF_BYPOSITION);
                DeleteMenu(hPopupMenu, 0, MF_BYPOSITION);
                DeleteMenu(hPopupMenu, 0, MF_BYPOSITION);
            }
            
            RegEdit_SetKeyTreeEditMenuItems(hPopupMenu, hSelectedTreeItem);
            
            //
            //  Disable "Copy Key Name" for top-level items such as
            //  "My Computer" or a remote registry connection.
            //
            
            EnableMenuItem(hPopupMenu, ID_COPYKEYNAME,
                (TreeView_GetParent(hKeyTreeWnd,
                hSelectedTreeItem) != NULL) ? (MF_BYCOMMAND | MF_ENABLED) :
                (MF_BYCOMMAND | MF_GRAYED));
            
            NewPopupPosition = IDM_EDIT_WHENKEY_NEW_POPUP;
            
        }
        
        else
        {
            //
            //  Show menu items that are specific only to the ValueList
            //  context.
            //
            
            if (GetMenuItemID(hPopupMenu, 0) != ID_MODIFY)
            {
                InsertMenu(hPopupMenu, 0, MF_BYPOSITION | MF_SEPARATOR, 0,
                    NULL);
                InsertMenu(hPopupMenu, 0, MF_BYPOSITION | MF_STRING,
                    ID_MODIFYBINARY, g_RegEditData.pModifyBinary);
                InsertMenu(hPopupMenu, 0, MF_BYPOSITION | MF_STRING,
                    ID_MODIFY, g_RegEditData.pModify);
                SetMenuDefaultItem(hPopupMenu, 0, MF_BYPOSITION);
                
            }
            
            RegEdit_SetValueListEditMenuItems(hPopupMenu,
                ListView_GetNextItem(g_RegEditData.hValueListWnd, -1,
                LVNI_SELECTED));
            
            NewPopupPosition = IDM_EDIT_WHENVALUE_NEW_POPUP;
            
        }
        
        RegEdit_SetNewObjectEditMenuItems(GetSubMenu(hPopupMenu,
            NewPopupPosition));
        
        break;
        
    case IDM_REGEDIT_VIEW_POPUP:
        CheckMenuItem(hPopupMenu, ID_STATUSBAR, MF_BYCOMMAND |
            ((g_RegEditData.StatusBarShowCommand == SW_HIDE) ?
            MF_UNCHECKED : MF_CHECKED));

        EnableMenuItem(hPopupMenu, ID_DISPLAYBINARY, MF_BYCOMMAND |
            ((g_RegEditData.hFocusWnd == g_RegEditData.hKeyTreeWnd) ?
            MF_GRAYED : MF_ENABLED));
        break;
        
    case IDM_REGEDIT_FAVS_POPUP:
        //Only allow "add to favorites" when the selected key is a child
        //of the root key for my computer.  (don't allow favs on remote)
        hSelectedTreeItem = 
            TreeView_GetSelection(hKeyTreeWnd);
        hComputerItem = RegEdit_GetComputerItem(hSelectedTreeItem);
        
        EnableMenuItem(hPopupMenu, ID_ADDTOFAVORITES,
            ((hComputerItem == TreeView_GetRoot(hKeyTreeWnd)) &&
            (hSelectedTreeItem != TreeView_GetRoot(hKeyTreeWnd))) ?
            (MF_BYCOMMAND | MF_ENABLED) :
        (MF_BYCOMMAND | MF_GRAYED));
        break;
    }
    
}


//------------------------------------------------------------------------------
//  Regedit_EnableHiveMenuItems
//
//  DESSCRIPTION: Enables hive menu items
//
//  PARAMETERS: HMENU hPopupMenu - handle to popup menu
//------------------------------------------------------------------------------
void Regedit_EnableHiveMenuItems(HMENU hPopupMenu)
{
    UINT uLoadFlags = MF_BYCOMMAND | MF_GRAYED;
    UINT uUnloadFlags = MF_BYCOMMAND | MF_GRAYED;
    HWND hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
    
    if (g_RegEditData.hFocusWnd == hKeyTreeWnd) 
    {
        PREDEFINE_KEY hkeyPredefindedKey;
        HTREEITEM hSelectedTreeItem;
        HTREEITEM hComputerItem;
        
        // get the key's predefined root key
        hSelectedTreeItem = TreeView_GetSelection(hKeyTreeWnd);
        hkeyPredefindedKey = RegEdit_GetPredefinedKey(hSelectedTreeItem);
        
        if ((PREDEFINE_KEY_LOCAL_MACHINE == hkeyPredefindedKey) ||
            (PREDEFINE_KEY_USERS == hkeyPredefindedKey))
        {
            HTREEITEM hParentTreeItem = 
                TreeView_GetParent(hKeyTreeWnd, hSelectedTreeItem);
            HTREEITEM hComputerItem 
                = RegEdit_GetComputerItem(hSelectedTreeItem); //the computer
            
            if (hParentTreeItem == hComputerItem)
            {
                // Enable Load Hive for root keys
                uLoadFlags = MF_BYCOMMAND | MF_ENABLED;
            }
            else if (hParentTreeItem && 
                (TreeView_GetParent(hKeyTreeWnd, hParentTreeItem) ==
                hComputerItem))
            {
                // Enable Unload Hive for children of root keys
                uUnloadFlags = MF_BYCOMMAND | MF_ENABLED;
            }
        }
    }
    
    EnableMenuItem(hPopupMenu, ID_LOADHIVE, uLoadFlags);
    EnableMenuItem(hPopupMenu, ID_UNLOADHIVE, uUnloadFlags);
}


/*******************************************************************************
*
*  RegEdit_SetNewObjectEditMenuItems
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hPopupMenu,
*
*******************************************************************************/

VOID
PASCAL
RegEdit_SetNewObjectEditMenuItems(
    HMENU hPopupMenu
    )
{

    HWND hKeyTreeWnd;
    HTREEITEM hSelectedTreeItem;
    UINT EnableFlags;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
    hSelectedTreeItem = TreeView_GetSelection(hKeyTreeWnd);

    if (g_RegEditData.hCurrentSelectionKey != NULL)
        EnableFlags = MF_ENABLED | MF_BYCOMMAND;
    else
        EnableFlags = MF_GRAYED | MF_BYCOMMAND;

    EnableMenuItem(hPopupMenu, ID_NEWKEY, EnableFlags);
    EnableMenuItem(hPopupMenu, ID_NEWSTRINGVALUE, EnableFlags);
    EnableMenuItem(hPopupMenu, ID_NEWBINARYVALUE, EnableFlags);
    EnableMenuItem(hPopupMenu, ID_NEWDWORDVALUE, EnableFlags);
    EnableMenuItem(hPopupMenu, ID_NEWMULTSZVALUE, EnableFlags);
    EnableMenuItem(hPopupMenu, ID_NEWEXPSZVALUE, EnableFlags);

}

/*******************************************************************************
*
*  RegEdit_OnMenuSelect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnMenuSelect(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{

    MENUITEMINFO MenuItemInfo;

    //
    //  If this is one of our popup menus, then we'll fake out the MenuHelp
    //  API by sending it a normal menu item id.  This makes it easier to
    //  display context sensitive help for the popups, too.
    //

    if ((GET_WM_MENUSELECT_FLAGS(wParam, lParam) & (MF_POPUP | MF_SYSMENU)) ==
        MF_POPUP && GET_WM_MENUSELECT_HMENU(wParam, lParam) != NULL) {

        ZeroMemory(&MenuItemInfo, sizeof(MenuItemInfo));
        MenuItemInfo.cbSize = sizeof(MenuItemInfo);
        // DebugAssert(MenuItemInfo.cbSize == sizeof(MENUITEMINFO));
        MenuItemInfo.fMask = MIIM_ID;

        GetMenuItemInfo((HMENU) lParam, LOWORD(wParam), TRUE, &MenuItemInfo);
        if (LOWORD(wParam) == 3)
        {
            RegEdit_OnFavorites(hWnd, LOWORD(wParam));
        }

        if (GetMenuItemInfo((HMENU) lParam, LOWORD(wParam), TRUE, &MenuItemInfo))
        {
            wParam = MenuItemInfo.wID;
        }

    }

    MenuHelp(WM_MENUSELECT, wParam, lParam, g_RegEditData.hMainMenu,
        g_hInstance, g_RegEditData.hStatusBarWnd, (UINT *)s_RegEditMenuHelpData);

}

/*******************************************************************************
*
*  RegEdit_OnLButtonDown
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     fDoubleClick, TRUE if this is a double-click message, else FALSE.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnLButtonDown(
    HWND hWnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT KeyFlags
    )
{

    LONG Style;
    RECT ClientRect;
    int cxIcon;
    int dx;
    int dy;
    HDC hDC;
    MSG Msg;
    int xLow;
    int xHigh;
    HBRUSH hDitherBrush;
    HBRUSH hPrevBrush;

    if (IsIconic(hWnd))
        return;

    Style = GetWindowLong(hWnd, GWL_STYLE);
    SetWindowLong(hWnd, GWL_STYLE, Style & (~WS_CLIPCHILDREN));

    GetEffectiveClientRect(hWnd, &ClientRect, (LPINT)s_EffectiveClientRectData);

    cxIcon = GetSystemMetrics(SM_CXICON);
    ClientRect.left += cxIcon;
    ClientRect.right -= cxIcon;

    dx = GetSystemMetrics(SM_CXSIZEFRAME);
    y = GetSystemMetrics(SM_CYEDGE);
    dy = ClientRect.bottom - ClientRect.top - y * 2;

    hDC = GetDC(hWnd);

    if ((hDitherBrush = CreateDitheredBrush()) != NULL)
        hPrevBrush = SelectBrush(hDC, hDitherBrush);

    PatBlt(hDC, x - dx / 2, y, dx, dy, PATINVERT);

    SetCapture(hWnd);

    while (GetMessage(&Msg, NULL, 0, 0)) {

        if (Msg.message == WM_KEYDOWN || Msg.message == WM_SYSKEYDOWN ||
            (Msg.message >= WM_MOUSEFIRST && Msg.message <= WM_MOUSELAST)) {

            if (Msg.message == WM_LBUTTONUP || Msg.message == WM_LBUTTONDOWN ||
                Msg.message == WM_RBUTTONDOWN)
                break;

            if (Msg.message == WM_KEYDOWN) {

                if (Msg.wParam == VK_LEFT) {

                    Msg.message = WM_MOUSEMOVE;
                    Msg.pt.x -= 2;

                }

                else if (Msg.wParam == VK_RIGHT) {

                    Msg.message = WM_MOUSEMOVE;
                    Msg.pt.x += 2;

                }

                else if (Msg.wParam == VK_RETURN || Msg.wParam == VK_ESCAPE)
                    break;

                if (Msg.pt.x > ClientRect.right)
                    Msg.pt.x = ClientRect.right;

                else if (Msg.pt.x < ClientRect.left)
                    Msg.pt.x = ClientRect.left;

                SetCursorPos(Msg.pt.x, Msg.pt.y);

            }

            if (Msg.message == WM_MOUSEMOVE) {

                ScreenToClient(hWnd, &Msg.pt);

                if (Msg.pt.x > ClientRect.right)
                    Msg.pt.x = ClientRect.right;

                else if (Msg.pt.x < ClientRect.left)
                    Msg.pt.x = ClientRect.left;

                if (x < Msg.pt.x) {

                    xLow = x;
                    xHigh = Msg.pt.x;

                }

                else {

                    xLow = Msg.pt.x;
                    xHigh = x;

                }

                xLow -= dx / 2;
                xHigh -= dx / 2;

                if (xHigh < xLow + dx)
                    ExcludeClipRect(hDC, xHigh, y, xLow + dx, y + dy);

                else
                    ExcludeClipRect(hDC, xLow + dx, y, xHigh, y + dy);

                PatBlt(hDC, xLow, y, xHigh - xLow + dx, dy, PATINVERT);
                SelectClipRgn(hDC, NULL);

                x = Msg.pt.x;

            }

        }

        else
            DispatchMessage(&Msg);

    }

    ReleaseCapture();

    PatBlt(hDC, x - dx / 2, y, dx, dy, PATINVERT);

    if (hDitherBrush != NULL)
        DeleteObject(SelectBrush(hDC, hPrevBrush));

    ReleaseDC(hWnd, hDC);

    SetWindowLong(hWnd, GWL_STYLE, Style);

    g_RegEditData.xPaneSplit = x - dx / 2;

    RegEdit_ResizeWindow(hWnd, RESIZEFROM_SPLIT);

    UNREFERENCED_PARAMETER(fDoubleClick);
    UNREFERENCED_PARAMETER(KeyFlags);

}

/*******************************************************************************
*
*  RegEdit_OnCommandSplit
*
*  DESCRIPTION:
*     Keyboard alternative to changing the position of the "split" between the
*     KeyTree and ValueList panes.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCommandSplit(
    HWND hWnd
    )
{

    RECT ClientRect;
    POINT MessagePos;
    POINT CursorPos;

    GetEffectiveClientRect(hWnd, &ClientRect, (LPINT)s_EffectiveClientRectData);

    MessagePos.x = g_RegEditData.xPaneSplit +
        GetSystemMetrics(SM_CXSIZEFRAME) / 2;
    MessagePos.y = (ClientRect.bottom - ClientRect.top) / 2;

    CursorPos = MessagePos;
    ClientToScreen(hWnd, &CursorPos);
    SetCursorPos(CursorPos.x, CursorPos.y);

    SetCursor(LoadCursor(g_hInstance, MAKEINTRESOURCE(IDC_SPLIT)));
    ShowCursor(TRUE);

    RegEdit_OnLButtonDown(hWnd, FALSE, MessagePos.x, MessagePos.y, 0);

    ShowCursor(FALSE);

}

/*******************************************************************************
*
*  RegEdit_ResizeWindow
*
*  DESCRIPTION:
*     Called whenever the size of the RegEdit window has changed or the size
*     of its child controls should be adjusted.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     ResizeFrom, source of the size change (RESIZEFROM_* constant).
*
*******************************************************************************/

VOID
PASCAL
RegEdit_ResizeWindow(
    HWND hWnd,
    UINT ResizeFrom
    )
{

    HDWP hDWP;
    RECT ClientRect;
    int Height;
    HWND hKeyTreeWnd;
    HWND hValueListWnd;
    int x;
    int dx;

    if (IsIconic(hWnd))
        return;

    //
    //  Resize and/or reposition the status bar window.  Don't do this when the
    //  resize comes from a change in the splitter position to avoid some
    //  flicker.
    //

    if (ResizeFrom == RESIZEFROM_UNKNOWN)
        SendMessage(g_RegEditData.hStatusBarWnd, WM_SIZE, 0, 0);

    if ((hDWP = BeginDeferWindowPos(2)) != NULL) {

        GetEffectiveClientRect(hWnd, &ClientRect, (LPINT)s_EffectiveClientRectData);
        Height = ClientRect.bottom - ClientRect.top;

        hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

        DeferWindowPos(hDWP, hKeyTreeWnd, NULL, 0, 0, g_RegEditData.xPaneSplit,
            Height, SWP_NOZORDER | SWP_NOACTIVATE);

        x = g_RegEditData.xPaneSplit + GetSystemMetrics(SM_CXSIZEFRAME);
        dx = ClientRect.right - ClientRect.left - x;

        hValueListWnd = g_RegEditData.hValueListWnd;

        DeferWindowPos(hDWP, hValueListWnd, NULL, x, 0, dx, Height,
            SWP_NOZORDER | SWP_NOACTIVATE);

        EndDeferWindowPos(hDWP);

    }

}

/*******************************************************************************
*
*  RegEdit_SetImageLists
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_SetImageLists(
    HWND hWnd
    )
{

    int cxSmIcon;
    int cySmIcon;
    HIMAGELIST hImageList;
    UINT Index;
    HICON hIcon;
    UINT uFlags = TRUE;

    cxSmIcon = GetSystemMetrics(SM_CXSMICON);
    cySmIcon = GetSystemMetrics(SM_CYSMICON);


    if ( GetWindowLongPtr(hWnd , GWL_EXSTYLE) & WS_EX_LAYOUTRTL )
    {
         uFlags |= ILC_MIRROR;
    }

    if ((hImageList = ImageList_Create(cxSmIcon, cySmIcon, uFlags, IDI_LASTIMAGE -
        IDI_FIRSTIMAGE + 1, 1)) == NULL)
        return FALSE;

    //
    //  Initialize the image list with all of the icons that we'll be using
    //  throughout the Registry Editor (at least this window!).  Once set, send
    //  its handle to all interested child windows.
    //

    for (Index = IDI_FIRSTIMAGE; Index <= IDI_LASTIMAGE; Index++) {

        if ((hIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(Index), IMAGE_ICON,
            cxSmIcon, cySmIcon, LR_DEFAULTCOLOR)) != NULL) {

            ImageList_AddIcon(hImageList, hIcon);
            DestroyIcon(hIcon);

        }

        else {

            ImageList_Destroy(hImageList);
            return FALSE;

        }

    }

    TreeView_SetImageList(g_RegEditData.hKeyTreeWnd, hImageList, TVSIL_NORMAL);
    ListView_SetImageList(g_RegEditData.hValueListWnd, hImageList, LVSIL_SMALL);

    if (g_RegEditData.hImageList != NULL)
        ImageList_Destroy(g_RegEditData.hImageList);

    g_RegEditData.hImageList = hImageList;

    return TRUE;

}

/*******************************************************************************
*
*  RegEdit_SetSysColors
*
*  DESCRIPTION:
*     Queries the system for any desired system colors and sets window
*     attributes as necessary.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
PASCAL
RegEdit_SetSysColors(
    VOID
    )
{

    g_clrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_clrHighlight = GetSysColor(COLOR_HIGHLIGHT);

    g_clrWindowText = GetSysColor(COLOR_WINDOWTEXT);
    g_clrWindow = GetSysColor(COLOR_WINDOW);

    //
    //  Optimize the drawing of images by informing interested parties of the
    //  background color.  This lets ImageLists avoid extra BitBlts (biggie) and
    //  ListViews do some minor stuff.
    //

    ImageList_SetBkColor(g_RegEditData.hImageList, g_clrWindow);
    ListView_SetBkColor(g_RegEditData.hValueListWnd, g_clrWindow);

}

/*******************************************************************************
*
*  RegEdit_SetWaitCursor
*
*  DESCRIPTION:
*     Simple logic to show or hide the wait cursor.  Assumes that we won't be
*     called by multiple layers, so no wait cursor count is maintained.
*
*  PARAMETERS:
*     fSet, TRUE if wait cursor should be displayed, else FALSE.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_SetWaitCursor(
    BOOL fSet
    )
{

    ShowCursor(fSet);

    SetCursor(LoadCursor(NULL, fSet ? IDC_WAIT : IDC_ARROW));

}


//------------------------------------------------------------------------------
//  RegEdit_GetComputerItem
//
//  DESCRIPTION: Returns the root item (computer) of an item
//
//  PARAMETERS:  hTreeItem - treeview item
//------------------------------------------------------------------------------
HTREEITEM RegEdit_GetComputerItem(HTREEITEM hTreeItem)
{
    HTREEITEM hTreeItemRoot; 
    HTREEITEM hCurrTreeItem = hTreeItem;

    do
    {
        hTreeItemRoot = hCurrTreeItem;
        hCurrTreeItem = TreeView_GetParent(g_RegEditData.hKeyTreeWnd, hCurrTreeItem);
    }
    while (hCurrTreeItem);

    return hTreeItemRoot;
}


//------------------------------------------------------------------------------
//  RegEdit_GetPredefinedKey
//
//  DESCRIPTION: Returns the RegEdit_GetPredefinedKey of an item
//
//  PARAMETERS:  hTreeItem - treeview item
//------------------------------------------------------------------------------
PREDEFINE_KEY RegEdit_GetPredefinedKey(HTREEITEM hTreeItem)
{
    HTREEITEM hKeyTreeItem;
    HTREEITEM hCurrTreeItem = hTreeItem;
    TCHAR szKeyString[MAXKEYNAME];
    PREDEFINE_KEY  hkeyPredefindedKey = -1;
    int i;

    // Find Key
    do
    {
        hKeyTreeItem = hCurrTreeItem;
        hCurrTreeItem = TreeView_GetParent(g_RegEditData.hKeyTreeWnd, hCurrTreeItem);
    }
    while ((hCurrTreeItem) && 
           (TreeView_GetParent(g_RegEditData.hKeyTreeWnd, hCurrTreeItem)));
 
    // PREDEFINDED KEY from its name
    KeyTree_GetKeyName(hKeyTreeItem, szKeyString, ARRAYSIZE(szKeyString));
    for (i = 0; i < NUMBER_REGISTRY_ROOTS; i++) 
    {
        if (_tcscmp((TCHAR*)&szKeyString, g_RegistryRoots[i].lpKeyName) == 0)
        {
            hkeyPredefindedKey = g_RegistryRoots[i].hPreDefKey;
            break;
        }
    }

    return hkeyPredefindedKey;
}


//------------------------------------------------------------------------------
//  RegEdit_InvokeSecurityEditor
//
//  DESCRIPTION: Invokes the security editor for the currently selected item.
//
//  PARAMETERS:  hWnd - handle to the current window
//------------------------------------------------------------------------------
VOID RegEdit_InvokeSecurityEditor(HWND hWnd)
{
    HTREEITEM hSelectedTreeItem;
    HTREEITEM hParentTreeItem;
    HTREEITEM hComputerItem;
    
    BOOL fRemote;
    LPSECURITYINFO pSi;
    PREDEFINE_KEY  hkeyPredefindedKey;
    
    TCHAR szItemName[MAXKEYNAME + 1];
    TCHAR szItemParentName[MAXKEYNAME + 1];
    TCHAR szComputerName[2 + MAX_COMPUTERNAME_LENGTH + 1] = {'\\','\\'};
    DWORD cbComputerName;
    
    LPTSTR pszTitle = szItemName;
    LPTSTR pszItemName = szItemName;
    LPTSTR pszComputerName = szComputerName;

    LPTSTR pszItemParentName = NULL;

    hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
    hParentTreeItem = TreeView_GetParent(g_RegEditData.hKeyTreeWnd, hSelectedTreeItem);
    hComputerItem = RegEdit_GetComputerItem(hSelectedTreeItem);
    
    // ITEM NAME
    KeyTree_GetKeyName(hSelectedTreeItem, pszItemName, ARRAYSIZE(szItemName));
    
    // COMPUTER NAME
    fRemote = (hComputerItem != g_RegEditData.hMyComputer);
    if (fRemote)
    {
        KeyTree_GetKeyName(hComputerItem, pszComputerName + 2, ARRAYSIZE(szComputerName) - 2); 
    }
    else
    {
        cbComputerName = ARRAYSIZE(szComputerName) - 2;
        GetComputerName(szComputerName + 2, &cbComputerName);
    }
    
    // PARENT NAME
    if (hParentTreeItem == hComputerItem)
    { 
        pszItemName = NULL; 
        pszItemParentName = NULL;
    }
    else if (TreeView_GetParent(g_RegEditData.hKeyTreeWnd, hParentTreeItem) == hComputerItem)
    {
        pszItemParentName = NULL;         
    }
    else 
    {
        KeyTree_BuildKeyPath( g_RegEditData.hKeyTreeWnd, 
                                hParentTreeItem,
                                szItemParentName, 
                                ARRAYSIZE(szItemParentName),
                                BKP_TOSUBKEY);
        pszItemParentName = szItemParentName;
    }
    
    // PREDEFINED KEY
    hkeyPredefindedKey = RegEdit_GetPredefinedKey(hSelectedTreeItem);
    
    // SECURITY INFO
    if (CreateSecurityInformation(pszItemName, pszItemParentName, pszComputerName, pszTitle,
        fRemote, hkeyPredefindedKey, FALSE, hWnd, &pSi ) == S_OK)
    {
        EditSecurity( hWnd, pSi);
        RegEdit_KeyTreeSelChanged(g_RegEditData.hKeyTreeWnd);
    }
    else
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_GET_SECURITY_KEY_NOT_ACCESSIBLE_EX),
            MAKEINTRESOURCE(IDS_SECURITY), MB_ICONERROR | MB_OK, NULL);
    }  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regioreq.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regresls.cxx

Abstract:

    This module contains the definitions of the member functions
    of IO_REQUIREMENTS_LIST class.

Author:

    Jaime Sasson (jaimes) 02-Dec-1993

Environment:

    ULIB, User Mode


--*/

#include "regioreq.hxx"
#include "iterator.hxx"
#include "regiodsc.hxx"
#include "regiodls.hxx"


DEFINE_CONSTRUCTOR ( IO_REQUIREMENTS_LIST, OBJECT );


IO_REQUIREMENTS_LIST::~IO_REQUIREMENTS_LIST (
    )

/*++

Routine Description:

    Destroy a IO_REQUIREMENTS_LIST.

Arguments:

    None.

Return Value:

    None.

--*/

{
    Destroy();
}


VOID
IO_REQUIREMENTS_LIST::Construct (
    )

/*++

Routine Description:

    Construct an IO_REQUIREMENTS_LIST object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _InterfaceType = Internal;
    _BusNumber = 0;
    _SlotNumber = 0;
    _Reserved1 = 0;
    _Reserved2 = 0;
    _Reserved3 = 0;
    _AlternativeLists = NULL;
}


VOID
IO_REQUIREMENTS_LIST::Destroy (
    )

/*++

Routine Description:

    Worker method for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if( _AlternativeLists != NULL ) {
        _AlternativeLists->DeleteAllMembers();
        DELETE( _AlternativeLists );
    }
    _AlternativeLists = NULL;
}



BOOLEAN
IO_REQUIREMENTS_LIST::Initialize(
    IN  PCBYTE       Data,
    IN  ULONG        Size
    )

/*++

Routine Description:

    Initialize an object of type IO_REQUIREMENTS_LIST.

Arguments:

    Data - Pointer to a buffer that contains a IO_RESOURCE_REQUIREMETS_LIST.

    Size - Buffer size.

Return Value:

    BOOLEAN - Returns TRUE if the initialization succeeds.

--*/

{
    PIO_RESOURCE_LIST    ResourceList;
    ULONG                Count;
    ULONG                i;
    PARRAY               TmpList;
    ULONG                BufferSize;
    ULONG                ResourceListSize;

    if( Data == NULL ) {
        return( FALSE );
    }

    Count           = ( ( PIO_RESOURCE_REQUIREMENTS_LIST )Data )->AlternativeLists;
    ResourceList    = ( ( PIO_RESOURCE_REQUIREMENTS_LIST )Data )->List;

    TmpList = ( PARRAY )NEW( ARRAY );
    DebugPtrAssert( TmpList );
    if( ( TmpList == NULL ) ||
        ( !TmpList->Initialize() ) ) {
        DebugPrintTrace(("REGEDT32: Out of memory" ));
        DELETE( TmpList );
        return( FALSE );
    }

    //
    // For each IO_RESOURCE_LIST in the current value...
    //

    BufferSize = Size -                         // Data size
                 sizeof( ULONG ) -              // ListSize
                 sizeof( INTERFACE_TYPE ) -     // InterfaceType
                 sizeof( ULONG ) -              // BusNumber
                 sizeof( ULONG ) -              // SlotNumber
                 3*sizeof( ULONG ) -            // Reserved1, 2 and 3
                 sizeof( ULONG );               // AlternativeLists

    for( i = 0; i < Count; i++ ) {

        PIO_DESCRIPTOR_LIST   IoDescriptorList;

        IoDescriptorList = ( PIO_DESCRIPTOR_LIST )NEW( IO_DESCRIPTOR_LIST );
        if( ( IoDescriptorList == NULL ) ||
            !IoDescriptorList->Initialize( ( PCBYTE )ResourceList,
                                            BufferSize,
                                            &ResourceListSize )
          ) {
            DebugPrint( "REGEDT32: Unable to create or initialize IoDescriptorList \n" );
            DELETE( IoDescriptorList );
            TmpList->DeleteAllMembers();
            DELETE( TmpList );
            return( FALSE );
        }
        TmpList->Put( IoDescriptorList );
#if DBG
        if( BufferSize < ResourceListSize ) {
            DebugPrintTrace(( "REGEDT32: incorrect sizes, BufferSize = %d, ResourceListSize = %d \n",
                       BufferSize, ResourceListSize ));
        }
#endif
        ResourceList = ( PIO_RESOURCE_LIST )( ( ULONG_PTR )ResourceList + ResourceListSize );
        BufferSize -= ResourceListSize;
    }
    _AlternativeLists = TmpList;
    _InterfaceType = ( ( PIO_RESOURCE_REQUIREMENTS_LIST )Data )->InterfaceType;
    _BusNumber     = ( ( PIO_RESOURCE_REQUIREMENTS_LIST )Data )->BusNumber;
    _SlotNumber    = ( ( PIO_RESOURCE_REQUIREMENTS_LIST )Data )->SlotNumber;
    return( TRUE );
}

#if DBG
VOID
IO_REQUIREMENTS_LIST::DbgDumpObject(
    )

/*++

Routine Description:

    Print an IO_REQUIREMENTS_LIST object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PITERATOR           Iterator;
    PIO_DESCRIPTOR_LIST DescriptorList;

    DebugPrintTrace(( "*** Dumping IO_REQUIREMENTS_LIST \n\n" ));
    DebugPrintTrace(( "InterfaceType = %d \n", _InterfaceType ));
    DebugPrintTrace(( "BusNumber = %#lx \n", _BusNumber ));
    DebugPrintTrace(( "SlotNumber = %#lx \n", _SlotNumber ));
    DebugPrintTrace(( "Reserved1 = %#x \n", _Reserved1 ));
    DebugPrintTrace(( "Reserved2 = %#x \n", _Reserved2 ));
    DebugPrintTrace(( "Reserved3 = %#x \n", _Reserved3 ));
    if( _AlternativeLists != NULL ) {
        Iterator = _AlternativeLists->QueryIterator();
        while( DescriptorList = ( PIO_DESCRIPTOR_LIST ) Iterator->GetNext() ) {
            DescriptorList->DbgDumpObject();
        }
        DELETE( Iterator );
    } else {
        DebugPrintTrace(( "IO_REQUIREMENTS_LIST is empty \n\n" ));
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regfind.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGFIND.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        14 Jul 1994
*
*  Find routines for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"
#include "regkey.h"
#include "regresid.h"
#include "reghelp.h"
#include "regvalue.h"

#define SIZE_FINDSPEC                   (max(MAXKEYNAME, MAXVALUENAME_LENGTH))

TCHAR s_FindSpecification[SIZE_FINDSPEC] = { 0 };

#define FIND_EXACT                      0x00000001
#define FIND_KEYS                       0x00000002
#define FIND_VALUES                     0x00000004
#define FIND_DATA                       0x00000008

//  Initialized value is the default if we don't find last known state in the
//  registry.
DWORD g_FindFlags = FIND_KEYS | FIND_VALUES | FIND_DATA;

//  Global needed to monitor the find abort dialog status.
BOOL s_fContinueFind;

//
//  Reference data for the RegFind dialog.
//

typedef struct _REGFINDDATA {
    UINT LookForCount;
}   REGFINDDATA;

REGFINDDATA s_RegFindData;

//
//  Association between the items of the RegFind dialog and the find flags.
//

typedef struct _DLGITEMFINDFLAGASSOC {
    int DlgItem;
    DWORD Flag;
}   DLGITEMFINDFLAGASSOC;

const DLGITEMFINDFLAGASSOC s_DlgItemFindFlagAssoc[] = {
    IDC_WHOLEWORDONLY,      FIND_EXACT,
        IDC_FORKEYS,            FIND_KEYS,
        IDC_FORVALUES,          FIND_VALUES,
        IDC_FORDATA,            FIND_DATA
};

const DWORD s_RegFindHelpIDs[] = {
    IDC_FINDWHAT,      IDH_FIND_SEARCHTEXT,
        IDC_GROUPBOX,      IDH_REGEDIT_LOOK,
        IDC_FORKEYS,       IDH_REGEDIT_LOOK,
        IDC_FORVALUES,     IDH_REGEDIT_LOOK,
        IDC_FORDATA,       IDH_REGEDIT_LOOK,
        IDC_WHOLEWORDONLY, IDH_FIND_WHOLE,
        IDOK,              IDH_FIND_NEXT_BUTTON,
        
        0, 0
};

BOOL
PASCAL
FindCompare(
            LPTSTR lpString
            );

INT_PTR
PASCAL
RegFindDlgProc(
               HWND hWnd,
               UINT Message,
               WPARAM wParam,
               LPARAM lParam
               );

BOOL
PASCAL
RegFind_OnInitDialog(
                     HWND hWnd,
                     HWND hFocusWnd,
                     LPARAM lParam
                     );

VOID
PASCAL
RegFind_OnCommand(
                  HWND hWnd,
                  int DlgItem,
                  HWND hControlWnd,
                  UINT NotificationCode
                  );

BOOL
PASCAL
RegFindAbortProc(
                 HWND hRegFindAbortWnd
                 );

INT_PTR
CALLBACK
RegFindAbortDlgProc(
                    HWND hWnd,
                    UINT Message,
                    WPARAM wParam,
                    LPARAM lParam
                    );

/*******************************************************************************
*
*  RegEdit_OnCommandFindNext
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCommandFindNext(
                          HWND hWnd,
                          BOOL fForceDialog
                          )
{
    UINT uErrorStringID;
    BOOL fError = FALSE;
    BOOL fSearchedToEnd;
    HWND hFocusWnd;
    LV_ITEM LVItem;
    TCHAR ValueName[MAXVALUENAME_LENGTH];
    DWORD Type;
    DWORD cbValueData;
    TV_ITEM TVItem;
    TCHAR KeyName[MAXKEYNAME];
    HWND hRegFindAbortWnd;
    HTREEITEM hTempTreeItem;
    UINT ExpandCounter;
    HKEY hRootKey;
    HKEY hKey;
    DWORD EnumIndex;
    DWORD cbValueName;
    BOOL fFoundMatch;
    TCHAR BestValueName[MAXVALUENAME_LENGTH];
    LV_FINDINFO LVFindInfo;
    
    fSearchedToEnd = FALSE;
    hFocusWnd = NULL;
    hRegFindAbortWnd = NULL;
    
    //
    //  Check if we're to show the find dialog.  This is either due to the user
    //  explicitly choosing the "Find" menu item or causing a "Find Next" with
    //  the search specification being uninitialized.
    //
    
    if (fForceDialog || s_FindSpecification[0] == 0) {
        
        if (DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_REGFIND), hWnd,
            RegFindDlgProc) != IDOK)
            return;
        
    }
    
    RegEdit_SetWaitCursor(TRUE);
    
    //
    //  Check if we're trying to finding either value names or data.  If so,
    //  then the next match might be part of the current ValueList.
    //
    
    if (g_FindFlags & (FIND_VALUES | FIND_DATA)) 
    {    
        LVItem.iItem = ListView_GetNextItem(g_RegEditData.hValueListWnd, -1, LVNI_FOCUSED);
        LVItem.iSubItem = 0;
        LVItem.mask = LVIF_TEXT;
        LVItem.pszText = ValueName;
        LVItem.cchTextMax = ARRAYSIZE(ValueName);
        
        //
        //  Walk over all of the rest of the value names attempting to find a
        //  match.
        //
        
        while ((LVItem.iItem = ListView_GetNextItem(g_RegEditData.hValueListWnd,
            LVItem.iItem, LVNI_ALL)) != -1) {
            
            ListView_GetItem(g_RegEditData.hValueListWnd, &LVItem);
            
            //
            //  Check if this value name meets our search specification.  We'll
            //  assume that this value name still exists.
            //
            
            if ((g_FindFlags & FIND_VALUES) && FindCompare(ValueName))
                goto SelectListItem;
            
            //
            //  Check if this value data meets our search specification.  We'll
            //  have to go back to the registry to determine this.
            //
            
            if (g_FindFlags & FIND_DATA) 
            {
                if ((RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName,
                    NULL, &Type, NULL, &cbValueData) == ERROR_SUCCESS) && 
                    IsRegStringType(Type))
                {
                    // Allocate storage space
                    PBYTE pbDataValue = (PBYTE)LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
                    if (pbDataValue)
                    {
                        BOOL fSuccess = FALSE;
                        
                        if (RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName,
                            NULL, &Type, pbDataValue, &cbValueData) == ERROR_SUCCESS)
                        {
                            if (Type == REG_MULTI_SZ)
                            {
                                EDITVALUEPARAM evp;
                                evp.pValueData = pbDataValue; 
                                evp.cbValueData = cbValueData;
                                
                                if (ValueList_MultiStringToString(&evp))
                                {
                                    pbDataValue = evp.pValueData;
                                }  
                            }
                            fSuccess = FindCompare((PTSTR)pbDataValue);
                        }
                        
                        LocalFree(pbDataValue);
                        if (fSuccess)
                        {
                            goto SelectListItem;
                        }
                    }
                    else
                    {
                        fError = TRUE;
                        uErrorStringID = IDS_NOMEMORY;
                        goto DismissRegFindAbortWnd;
                    }
                }
                
            }
            
        }
        
    }
    
    //
    //  Searching the registry (especially with this code!) is a lengthy
    //  operation, so we must provide a way for the user to cancel the
    //  operation.
    //
    
    s_fContinueFind = TRUE;
    
    if ((hRegFindAbortWnd = CreateDialog(g_hInstance,
        MAKEINTRESOURCE(IDD_REGFINDABORT), hWnd, RegFindAbortDlgProc)) !=
        NULL) {
        
        EnableWindow(hWnd, FALSE);
        
        //
        //  Major hack:  The following code sequence relies heavily on the
        //  TreeView to maintain the state of the find process.  Even though I'm
        //  inserting and deleting non-visible tree items, the TreeView
        //  currently flickers despite this.
        //
        //  So, we set this internal flag and turn off the TreeView's redraw
        //  flag.  Whenever we get a WM_PAINT message for our main window, we
        //  temporarily "let" it redraw itself then and only then.  That way,
        //  the user can move the modeless abort dialog or switch away and back
        //  and still have the TreeView look normal.
        //
        //  Yes, it's difficult at this time to fix the TreeView's paint logic.
        //
        
        g_RegEditData.fProcessingFind = TRUE;
        SetWindowRedraw(g_RegEditData.hKeyTreeWnd, FALSE);
        
    }
    
    //
    //  Either the user wasn't trying to find value names or data or else no
    //  matches were found.  This means that we must move on to the next branch
    //  of the registry.
    //
    //  We first walk into the children of the current branch, then the
    //  siblings, and finally pop back through the parent.
    //
    //  We use the information already in the KeyTree pane as much as possible.
    //
    
    ExpandCounter = 0;
    fFoundMatch = FALSE;
    BestValueName[0] = '\0';
    
    TVItem.mask = TVIF_TEXT | TVIF_STATE | TVIF_CHILDREN;
    TVItem.pszText = KeyName;
    TVItem.cchTextMax = ARRAYSIZE(KeyName);
    
    TVItem.hItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
    TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);
    
    while (TRUE) {
        
        //
        //  Check if we should cancel the find operation.  If so, restore our
        //  initial state and exit.
        //
        
        if (!RegFindAbortProc(hRegFindAbortWnd)) {
            
            if (ExpandCounter) {
                
                hTempTreeItem = TVItem.hItem;
                
                do {
                    
                    hTempTreeItem =
                        TreeView_GetParent(g_RegEditData.hKeyTreeWnd,
                        hTempTreeItem);
                    
                }   while (--ExpandCounter);
                
                TreeView_Expand(g_RegEditData.hKeyTreeWnd, hTempTreeItem,
                    TVE_COLLAPSE | TVE_COLLAPSERESET);
                
            }
            
            goto DismissRegFindAbortWnd;
            
        }
        
        //
        //  Does this branch have any children?  This would have been determined
        //  when the tree item was built by the routine KeyTree_ExpandBranch.
        //
        
        if (TVItem.cChildren) {
            
            //
            //  The branch may have children, but it may not have been expanded
            //  yet.
            //
            
            if ((hTempTreeItem = TreeView_GetChild(g_RegEditData.hKeyTreeWnd,
                TVItem.hItem)) == NULL) {
                
                if (!KeyTree_ExpandBranch(g_RegEditData.hKeyTreeWnd,
                    TVItem.hItem))
                    goto SkipToSibling;
                
                if ((hTempTreeItem = TreeView_GetChild(g_RegEditData.hKeyTreeWnd,
                    TVItem.hItem)) == NULL)
                    goto SkipToSibling;
                
                ExpandCounter++;
                
            }
            
            TVItem.hItem = hTempTreeItem;
            
        }
        
        //
        //  The branch doesn't have any children, so we'll move on to the next
        //  sibling of the current branch.  If none exists, then try finding
        //  the next sibling of the parent branch, and so on.
        //
        
        else {
            
SkipToSibling:
        while (TRUE) {
            
            if ((hTempTreeItem =
                TreeView_GetNextSibling(g_RegEditData.hKeyTreeWnd,
                TVItem.hItem)) != NULL) {
                
                TVItem.hItem = hTempTreeItem;
                break;
                
            }
            
            //
            //  If no more parents exist, then we've finished searching the
            //  tree.  We're outta here!
            //
            
            if ((TVItem.hItem =
                TreeView_GetParent(g_RegEditData.hKeyTreeWnd,
                TVItem.hItem)) == NULL) {
                
                fSearchedToEnd = TRUE;
                
                goto DismissRegFindAbortWnd;
                
            }
            
            if (ExpandCounter) {
                
                ExpandCounter--;
                
                TreeView_Expand(g_RegEditData.hKeyTreeWnd, TVItem.hItem,
                    TVE_COLLAPSE | TVE_COLLAPSERESET);
                
            }
            
        }
        
        }
        
        //
        //  If we made it this far, then we're at the next branch of the
        //  registry to evaluate.
        //
        
        TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);
        
        //
        //  Check if we're trying to find keys.
        //
        
        if (g_FindFlags & FIND_KEYS) {
            
            if (FindCompare(KeyName))
                goto SelectTreeItem;
            
        }
        
        //
        //  Check if we're trying to find value names or data.
        //
        
        if (g_FindFlags & (FIND_VALUES | FIND_DATA)) {
            
            //
            //  Try to open the registry at the new current branch.
            //
            
            hRootKey = KeyTree_BuildKeyPath( g_RegEditData.hKeyTreeWnd,
                                                TVItem.hItem, 
                                                KeyName, 
                                                ARRAYSIZE(KeyName),
                                                BKP_TOSUBKEY);
            
            if(hRootKey && RegOpenKeyEx(hRootKey, KeyName, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS) 
            {    
                //
                //  Here's the simple case-- we're trying to find an exact match
                //  for a value name.  We can just use the registry API to do
                //  this for us!
                //
                
                if ((g_FindFlags & (FIND_VALUES | FIND_DATA | FIND_EXACT)) ==
                    (FIND_VALUES | FIND_EXACT)) {
                    
                    if (RegEdit_QueryValueEx(hKey, s_FindSpecification, NULL, NULL,
                        NULL, NULL) == ERROR_SUCCESS) {
                        
                        StringCchCopy(BestValueName, ARRAYSIZE(BestValueName), s_FindSpecification);
                        fFoundMatch = TRUE;
                        
                    }
                    
                }
                
                //
                //  Bummer... we need to walk through all of the registry
                //  value/data pairs for this key to try to find a match.  Even
                //  worse, we have to look at _all_ of the entries, not just the
                //  first hit... we must display the first alphabetically
                //  matching entry!
                //
                
                else {
                    
                    EnumIndex = 0;
                    
                    while (TRUE) 
                    {
                        cbValueName = ARRAYSIZE(ValueName);
                        
                        if (RegEnumValue(hKey, EnumIndex++, ValueName,
                            &cbValueName, NULL, &Type, NULL,
                            &cbValueData) == ERROR_SUCCESS)
                        {
                            PBYTE pbValueData = (g_FindFlags & FIND_DATA) ? 
                                (PBYTE)LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type)) : NULL;
                            
                            if (pbValueData || !(g_FindFlags & FIND_DATA))
                            {
                                if (RegEdit_QueryValueEx(hKey, ValueName, NULL, &Type, 
                                    pbValueData, &cbValueData) == ERROR_SUCCESS)
                                {
                                    if (pbValueData && (Type == REG_MULTI_SZ))
                                    {
                                        EDITVALUEPARAM evp;
                                        evp.pValueData = pbValueData; 
                                        evp.cbValueData = cbValueData;
                                        
                                        if (ValueList_MultiStringToString(&evp))
                                        {
                                            pbValueData = evp.pValueData;
                                        }
                                    }
                                    
                                    if (((g_FindFlags & FIND_VALUES) &&
                                        FindCompare(ValueName)) ||
                                        ((g_FindFlags & FIND_DATA) && IsRegStringType(Type) &&
                                        FindCompare((PTSTR)pbValueData))) 
                                    {
                                        //
                                        //  We've got to check if we've found a "better"
                                        //  value name to display-- one that's at the top of
                                        //  the sorted list.
                                        //
                                        
                                        if (fFoundMatch) 
                                        {    
                                            if (lstrcmpi(BestValueName, ValueName) > 0)
                                            {
                                                StringCchCopy(BestValueName, ARRAYSIZE(BestValueName), ValueName);
                                            }                                            
                                        }                                        
                                        else 
                                        {
                                            StringCchCopy(BestValueName, ARRAYSIZE(BestValueName), ValueName);
                                            fFoundMatch = TRUE;
                                        }
                                    }
                                }
                                if (pbValueData)
                                {
                                    LocalFree(pbValueData);
                                }
                            }
                            else
                            {
                                fError = TRUE;
                                uErrorStringID = IDS_NOMEMORY;
                                goto DismissRegFindAbortWnd;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    
                }
                
                RegCloseKey(hKey);
                
                if (fFoundMatch)
                    goto SelectTreeItem;
                
            }
            
        }
        
    }
    
SelectTreeItem:
    TreeView_EnsureVisible(g_RegEditData.hKeyTreeWnd, TVItem.hItem);
    TreeView_SelectItem(g_RegEditData.hKeyTreeWnd, TVItem.hItem);
    
    if (!fFoundMatch)
        hFocusWnd = g_RegEditData.hKeyTreeWnd;
    
    else {
        
        //
        //  Right now, the TreeView_SelectItem above will cause the ValueListWnd
        //  to update, but only after a short time delay.  We want the list
        //  immediately updated, so force the timer to go off now.
        //
        
        RegEdit_OnSelChangedTimer(hWnd);
        
        if (BestValueName[0] == 0)
            LVItem.iItem = 0;
        
        else {
            
            LVFindInfo.flags = LVFI_STRING;
            LVFindInfo.psz = BestValueName;
            
            LVItem.iItem = ListView_FindItem(g_RegEditData.hValueListWnd,
                -1, &LVFindInfo);
            
        }
        
SelectListItem:
        ListView_SetItemState(g_RegEditData.hValueListWnd, -1, 0,
            LVIS_SELECTED | LVIS_FOCUSED);
        ListView_SetItemState(g_RegEditData.hValueListWnd, LVItem.iItem,
            LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        ListView_EnsureVisible(g_RegEditData.hValueListWnd, LVItem.iItem,
            FALSE);
        
        hFocusWnd = g_RegEditData.hValueListWnd;
        
    }
    
DismissRegFindAbortWnd:
    RegEdit_SetWaitCursor(FALSE);
    
    if (hRegFindAbortWnd != NULL) {
        
        g_RegEditData.fProcessingFind = FALSE;
        SetWindowRedraw(g_RegEditData.hKeyTreeWnd, TRUE);
        
        EnableWindow(hWnd, TRUE);
        DestroyWindow(hRegFindAbortWnd);
        
    }
    
    if (hFocusWnd != NULL)
        SetFocus(hFocusWnd);
    
    if (fError)
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(uErrorStringID),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONERROR | MB_OK);
    }
    
    if (fSearchedToEnd)
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_SEARCHEDTOEND),
        MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONINFORMATION | MB_OK);
}

/*******************************************************************************
*
*  FindCompare
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
PASCAL
FindCompare(
            LPTSTR lpString
            )
{
    
    if (g_FindFlags & FIND_EXACT)
        return lstrcmpi(lpString, s_FindSpecification) == 0;
    
    else
        return StrStrI(lpString, s_FindSpecification) != NULL;
    
}

/*******************************************************************************
*
*  RegFindDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
PASCAL
RegFindDlgProc(
               HWND hWnd,
               UINT Message,
               WPARAM wParam,
               LPARAM lParam
               )
{
    
    switch (Message) {
        
        HANDLE_MSG(hWnd, WM_INITDIALOG, RegFind_OnInitDialog);
        HANDLE_MSG(hWnd, WM_COMMAND, RegFind_OnCommand);
        
    case WM_HELP:
        WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
            HELP_WM_HELP, (ULONG_PTR) s_RegFindHelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
            (ULONG_PTR) s_RegFindHelpIDs);
        break;
        
    default:
        return FALSE;
        
    }
    
    return TRUE;
    
}

/*******************************************************************************
*
*  RegFind_OnInitDialog
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
PASCAL
RegFind_OnInitDialog(
                     HWND hWnd,
                     HWND hFocusWnd,
                     LPARAM lParam
                     )
{
    
    UINT Counter;
    int DlgItem;
    
    //
    //  Initialize the "Find What" edit control.
    //
    
    SendDlgItemMessage(hWnd, IDC_FINDWHAT, EM_SETLIMITTEXT,
        SIZE_FINDSPEC, 0);
    SetDlgItemText(hWnd, IDC_FINDWHAT, s_FindSpecification);
    
    //
    //  Initialize the checkboxes based on the state of the global find flags.
    //
    
    s_RegFindData.LookForCount = 0;
    
    for (Counter = 0; Counter < sizeof(s_DlgItemFindFlagAssoc) / sizeof(DLGITEMFINDFLAGASSOC); Counter++) 
    {    
        if (g_FindFlags & s_DlgItemFindFlagAssoc[Counter].Flag) {
            
            DlgItem = s_DlgItemFindFlagAssoc[Counter].DlgItem;
            
            CheckDlgButton(hWnd, DlgItem, TRUE);
            
            if (DlgItem >= IDC_FORKEYS && DlgItem <= IDC_FORDATA)
                s_RegFindData.LookForCount++;      
        }        
    }
    
    return TRUE;
    
    UNREFERENCED_PARAMETER(hFocusWnd);
    UNREFERENCED_PARAMETER(lParam);
    
}

/*******************************************************************************
*
*  RegFind_OnCommand
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegFind_OnCommand(
                  HWND hWnd,
                  int DlgItem,
                  HWND hControlWnd,
                  UINT NotificationCode
                  )
{
    
    UINT Counter;
    
    if (DlgItem >= IDC_FORKEYS && DlgItem <= IDC_FORDATA) {
        
        if (NotificationCode == BN_CLICKED) {
            
            IsDlgButtonChecked(hWnd, DlgItem) ? s_RegFindData.LookForCount++ :
        s_RegFindData.LookForCount--;
        
        goto EnableFindNextButton;
        
        }
        
    }
    
    else {
        
        switch (DlgItem) {
            
        case IDC_FINDWHAT:
            if (NotificationCode == EN_CHANGE) {
                
EnableFindNextButton:
            EnableWindow(GetDlgItem(hWnd, IDOK),
                s_RegFindData.LookForCount > 0 &&
                SendDlgItemMessage(hWnd, IDC_FINDWHAT,
                WM_GETTEXTLENGTH, 0, 0) != 0);
            
            }
            break;
            
        case IDOK:
            GetDlgItemText(hWnd, IDC_FINDWHAT, s_FindSpecification, ARRAYSIZE(s_FindSpecification));
            
            for (Counter = 0; Counter < sizeof(s_DlgItemFindFlagAssoc) / sizeof(DLGITEMFINDFLAGASSOC); Counter++) 
            {    
                if (IsDlgButtonChecked(hWnd,
                    s_DlgItemFindFlagAssoc[Counter].DlgItem))
                    g_FindFlags |= s_DlgItemFindFlagAssoc[Counter].Flag;
                else
                    g_FindFlags &= ~s_DlgItemFindFlagAssoc[Counter].Flag;   
            }
            
            //  FALL THROUGH
            
        case IDCANCEL:
            EndDialog(hWnd, DlgItem);
            break;
            
        }
        
    }
    
}

/*******************************************************************************
*
*  RegFindAbortProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     (returns), TRUE to continue the find, else FALSE to cancel.
*
*******************************************************************************/

BOOL
PASCAL
RegFindAbortProc(
                 HWND hRegFindAbortWnd
                 )
{
    
    while (s_fContinueFind && MessagePump(hRegFindAbortWnd))
        ;
    
    return s_fContinueFind;
    
}

/*******************************************************************************
*
*  RegAbortDlgProc
*
*  DESCRIPTION:
*     Callback procedure for the RegAbort dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegAbort window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

INT_PTR
CALLBACK
RegFindAbortDlgProc(
                    HWND hWnd,
                    UINT Message,
                    WPARAM wParam,
                    LPARAM lParam
                    )
{
    
    switch (Message) {
        
    case WM_INITDIALOG:
        break;
        
    case WM_CLOSE:
    case WM_COMMAND:
        s_fContinueFind = FALSE;
        break;
        
    default:
        return FALSE;
        
    }
    
    return TRUE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regiodls.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regiodls.cxx

Abstract:

    This module contains the definitions of the member functions
    of IO_DESCRIPTOR_LIST class.

Author:

    Jaime Sasson (jaimes) 02-Dec-1993

Environment:

    ULIB, User Mode


--*/

#include "regiodls.hxx"
#include "regiodsc.hxx"
#include "iterator.hxx"


DEFINE_CONSTRUCTOR ( IO_DESCRIPTOR_LIST, OBJECT );


IO_DESCRIPTOR_LIST::~IO_DESCRIPTOR_LIST (
    )

/*++

Routine Description:

    Destroy an IO_DESCRIPTOR_LIST.

Arguments:

    None.

Return Value:

    None.

--*/

{
    Destroy();
}


VOID
IO_DESCRIPTOR_LIST::Construct (
    )

/*++

Routine Description:

    Construct an IO_DESCRIPTOR_LIST object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _Version = 0;
        _Revision = 0;
        _DescriptorsList = NULL;
}


VOID
IO_DESCRIPTOR_LIST::Destroy (
    )

/*++

Routine Description:

    Worker method for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _Version = 0;
    _Revision = 0;
    if( _DescriptorsList != NULL ) {
        _DescriptorsList->DeleteAllMembers();
        DELETE( _DescriptorsList );
    }
    _DescriptorsList = NULL;
}


BOOLEAN
IO_DESCRIPTOR_LIST::Initialize(
    IN  PCBYTE       Data,
    IN  ULONG        Size,
    OUT PULONG       DescriptorSize
    )

/*++

Routine Description:

    Initialize an object of type IO_DESCRIPTOR_LIST.

Arguments:

    Data - Pointer to a buffer that contains an IO_RESOURCE_LIST.

    Size - Buffer size.

Return Value:

    BOOLEAN - Returns TRUE if the initialization succeeds.

--*/

{
    PIO_RESOURCE_LIST               IoResourceList;
    ULONG                           Count;
    ULONG                           i;
    ULONG                           j;

    PARRAY                         TmpList;
    PIO_PORT_DESCRIPTOR            PortDescriptor;
    PIO_INTERRUPT_DESCRIPTOR       InterruptDescriptor;
    PIO_MEMORY_DESCRIPTOR          MemoryDescriptor;
    PIO_DMA_DESCRIPTOR             DmaDescriptor;

    if( Data == NULL ) {
        return( FALSE );
    }

    Count           = 1;
    IoResourceList  = ( PIO_RESOURCE_LIST )Data;

    TmpList = ( PARRAY )NEW( ARRAY );
    DebugPtrAssert( TmpList );
    if( ( TmpList == NULL ) ||
        ( !TmpList->Initialize() ) ) {
        DebugPrintTrace(("REGEDIT: Out of memory" ));
        DELETE( TmpList );
        return( FALSE );
    }

    _Version = IoResourceList->Version;
    _Revision = IoResourceList->Revision;

    //
    // For each CM_FULL_RESOURCE DESCRIPTOR in the current value...
    //

    for( i = 0; i < Count; i++ ) 
    {
        PIO_RESOURCE_DESCRIPTOR   IoResourceDescriptor = NULL;

        //
        // For each IO_RESOURCE_DESCRIPTOR in the list...
        //

        for( j = 0; j < IoResourceList->Count; j++ ) 
        {
                 //
                // Get a pointer to the current IO_RESOURCE_DESCRIPTOR
                // in the current IO_RESOURCE_LIST.
                //

                IoResourceDescriptor = &( IoResourceList->Descriptors[ j ]);
                //
                //  Ignore invalid data
                //
                if( ( ULONG_PTR )IoResourceDescriptor >
                        ( ULONG_PTR )( Data + Size - sizeof( IO_RESOURCE_DESCRIPTOR ) ) ) {
                    DebugPrintTrace(( "REGEDIT: Invalid IO_RESOURCE_DESCRIPTOR, j = %d \n", j ));
                    if( DescriptorSize != NULL ) {
                        *DescriptorSize = Size;
                    }
                    _DescriptorsList = TmpList;
                    return( TRUE );
                }

                switch( IoResourceDescriptor->Type ) {

                case CmResourceTypePort:

                    PortDescriptor = ( PIO_PORT_DESCRIPTOR )NEW( IO_PORT_DESCRIPTOR );
                    if( ( PortDescriptor == NULL ) ||
                        ( !PortDescriptor->Initialize( IoResourceDescriptor->u.Port.Length,
                                                       IoResourceDescriptor->u.Port.Alignment,
                                                       &IoResourceDescriptor->u.Port.MinimumAddress,
                                                       &IoResourceDescriptor->u.Port.MaximumAddress,
                                                       IoResourceDescriptor->Option,
                                                       IoResourceDescriptor->ShareDisposition,
                                                       IoResourceDescriptor->Flags ) )
                      ) {
                        DebugPrintTrace(( "REGEDIT: Unable to create IO_PORT_DESCRIPTOR" ));
                        DELETE( PortDescriptor );
                        TmpList->DeleteAllMembers();
                        DELETE( TmpList );
                        return( FALSE );
                    }
                    TmpList->Put( PortDescriptor );
                    break;

                case CmResourceTypeInterrupt:

                    InterruptDescriptor = ( PIO_INTERRUPT_DESCRIPTOR )NEW( IO_INTERRUPT_DESCRIPTOR );
                    if( ( InterruptDescriptor == NULL ) ||
                        ( !InterruptDescriptor->Initialize( IoResourceDescriptor->u.Interrupt.MinimumVector,
                                                            IoResourceDescriptor->u.Interrupt.MaximumVector,
                                                            IoResourceDescriptor->Option,
                                                            IoResourceDescriptor->ShareDisposition,
                                                            IoResourceDescriptor->Flags ) )
                      ) {
                        DebugPrintTrace(( "REGEDIT: Unable to create IO_INTERRUPT_DESCRIPTOR" ));
                        DELETE( InterruptDescriptor );
                        TmpList->DeleteAllMembers();
                        DELETE( TmpList );
                        return( FALSE );
                    }
                    TmpList->Put( InterruptDescriptor );
                    break;

                case CmResourceTypeMemory:

                    MemoryDescriptor = ( PIO_MEMORY_DESCRIPTOR )NEW( IO_MEMORY_DESCRIPTOR );
                    if( ( MemoryDescriptor == NULL ) ||
                        ( !MemoryDescriptor->Initialize( IoResourceDescriptor->u.Memory.Length,
                                                         IoResourceDescriptor->u.Memory.Alignment,
                                                         &IoResourceDescriptor->u.Memory.MinimumAddress,
                                                         &IoResourceDescriptor->u.Memory.MaximumAddress,
                                                         IoResourceDescriptor->Option,
                                                         IoResourceDescriptor->ShareDisposition,
                                                         IoResourceDescriptor->Flags ) )
                      ) {
                        DebugPrintTrace(( "REGEDIT: Unable to create IO_MEMORY_DESCRIPTOR" ));
                        DELETE( MemoryDescriptor );
                        TmpList->DeleteAllMembers();
                        DELETE( TmpList );
                        return( FALSE );
                    }
                    TmpList->Put( MemoryDescriptor );
                    break;

                case CmResourceTypeDma:

                    DmaDescriptor = ( PIO_DMA_DESCRIPTOR )NEW( IO_DMA_DESCRIPTOR );
                    if( ( DmaDescriptor == NULL ) ||
                        ( !DmaDescriptor->Initialize( IoResourceDescriptor->u.Dma.MinimumChannel,
                                                      IoResourceDescriptor->u.Dma.MaximumChannel,
                                                      IoResourceDescriptor->Option,
                                                      IoResourceDescriptor->ShareDisposition,
                                                      IoResourceDescriptor->Flags ) )
                      ) {
                        DebugPrintTrace(( "REGEDIT: Unable to create IO_DMA_DESCRIPTOR" ));
                        DELETE( DmaDescriptor );
                        TmpList->DeleteAllMembers();
                        DELETE( TmpList );
                        return( FALSE );
                    }
                    TmpList->Put( DmaDescriptor );
                    break;

                default:

                    DebugPrintTrace(( "REGEDIT: Unknown IoResourceDescriptor->Type == %#x \n",
                                IoResourceDescriptor->Type ));
                    continue;
                }
        }

        _DescriptorsList = TmpList;

        //
        // Get the next IO_RESOURCE_LIST from the list.
        //

        if (IoResourceDescriptor)
        {
            IoResourceList = ( PIO_RESOURCE_LIST )( IoResourceDescriptor + 1 );
        }
    }
    if( DescriptorSize != NULL ) {
        *DescriptorSize = ( ULONG )( ( ULONG_PTR )IoResourceList - ( ULONG_PTR )Data );
#if DBG
        if( *DescriptorSize > Size ) {
            DebugPrintTrace(( "REGEDIT: Invalid sizes, *DescriptorSize = %d, Size = %d \n", *DescriptorSize, Size ));
        }
#endif
    }
    return( TRUE );
}

#if DBG
VOID
IO_DESCRIPTOR_LIST::DbgDumpObject(
    )

/*++

Routine Description:

    Print an IO_DESCRIPTOR_LIST object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PITERATOR   Iterator;
    PIO_DESCRIPTOR Descriptor;

    DebugPrintTrace(( "\tVersion = %#x \n", _Version ));
    DebugPrintTrace(( "\tRevision = %#x \n", _Revision ));
    if( _DescriptorsList != NULL ) {
        Iterator = _DescriptorsList->QueryIterator();
        while( Descriptor = ( PIO_DESCRIPTOR ) Iterator->GetNext() ) {
            if( Descriptor->IsDescriptorTypePort() ) {
                ( ( PIO_PORT_DESCRIPTOR )Descriptor )->DbgDumpObject();
            } else if( Descriptor->IsDescriptorTypeInterrupt() ) {
                ( ( PIO_INTERRUPT_DESCRIPTOR )Descriptor )->DbgDumpObject();
            } else if( Descriptor->IsDescriptorTypeMemory() ) {
                ( ( PIO_MEMORY_DESCRIPTOR )Descriptor )->DbgDumpObject();
            } else if( Descriptor->IsDescriptorTypeDma() ) {
                ( ( PIO_DMA_DESCRIPTOR )Descriptor )->DbgDumpObject();
            } else {
                DebugPrintTrace(( "\tERROR: Unknown Descriptor \n\n" ));
            }
        }
        DELETE( Iterator );
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regiodsc.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regiodsc.cxx

Abstract:

    This module contains the definitions of the member functions
    of IO_DESCRIPTOR class.

Author:

    Jaime Sasson (jaimes) 02-Dec-1993

Environment:

    ULIB, User Mode


--*/


// don't let ntdddisk.h (included in ulib.hxx") 
// redefine values
#define _NTDDDISK_H_

#include "ulib.hxx"
#include "regiodsc.hxx"

#include <ctype.h>

DEFINE_CONSTRUCTOR ( IO_DESCRIPTOR, OBJECT );


IO_DESCRIPTOR::~IO_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a IO_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
IO_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct a IO_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _Option = 0;
        _Type = 0;
        _ShareDisposition = 0;
        _Flags = 0;
}

#if DBG
VOID
IO_DESCRIPTOR::DbgDumpObject(
    )

/*++

Routine Description:

    Print a IO_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DebugPrintTrace(( "\t\tOption = %#x \n", _Option ));
    DebugPrintTrace(( "\t\tType = %#x \n", _Type ));
    DebugPrintTrace(( "\t\tShareDisposition = %#x \n", _ShareDisposition ));
    DebugPrintTrace(( "\t\tFlags = %x \n", _Flags ));
}
#endif

// #include "ulib.hxx"
// #include "regdesc.hxx"

// extern "C" {
//    #include <ctype.h>
// }

DEFINE_CONSTRUCTOR ( IO_PORT_DESCRIPTOR, IO_DESCRIPTOR );


IO_PORT_DESCRIPTOR::~IO_PORT_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy an IO_PORT_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
IO_PORT_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct a IO_PORT_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _Length = 0;
        _Alignment = 0;
        _MinimumAddress.LowPart = 0;
        _MinimumAddress.HighPart = 0;
        _MaximumAddress.LowPart = 0;
        _MaximumAddress.HighPart = 0;
}

#if DBG
VOID
IO_PORT_DESCRIPTOR::DbgDumpObject(
    )

/*++

Routine Description:

    Print a IO_PORT_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    IO_DESCRIPTOR::DbgDumpObject();
    DebugPrintTrace(( "\t\tLength = %#lx \n", _Length ));
    DebugPrintTrace(( "\t\tAlignment = %#lx \n", _Alignment ));
    DebugPrintTrace(( "\t\tMinimumAddress.HighPart = %#lx \n", _MinimumAddress.HighPart ));
    DebugPrintTrace(( "\t\tMinimumAddress.LowPart = %#lx \n", _MinimumAddress.LowPart ));
    DebugPrintTrace(( "\t\tMaximumAddress.HighPart = %#lx \n", _MaximumAddress.HighPart ));
    DebugPrintTrace(( "\t\tMaximumAddress.LowPart = %#lx \n", _MaximumAddress.LowPart ));
    DebugPrintTrace(( "\n" ));
}
#endif

// #include "ulib.hxx"
// #include "regdesc.hxx"

// extern "C" {
//    #include <ctype.h>
// }

DEFINE_CONSTRUCTOR ( IO_INTERRUPT_DESCRIPTOR, IO_DESCRIPTOR );


IO_INTERRUPT_DESCRIPTOR::~IO_INTERRUPT_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy an IO_INTERRUPT_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
IO_INTERRUPT_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an IO_INTERRUPT_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _MinimumVector = 0;
    _MaximumVector = 0;
}

#if DBG
VOID
IO_INTERRUPT_DESCRIPTOR::DbgDumpObject(
    )

/*++

Routine Description:

    Print an IO_INTERRUPT_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    IO_DESCRIPTOR::DbgDumpObject();
    DebugPrintTrace(( "\t\tMinimumVector = %#lx \n", _MinimumVector ));
    DebugPrintTrace(( "\t\tMaximumVector = %#lx \n", _MaximumVector ));
    DebugPrintTrace(( "\n" ));
}
#endif



// #include "ulib.hxx"
// #include "regdesc.hxx"

// extern "C" {
//    #include <ctype.h>
// }

DEFINE_CONSTRUCTOR ( IO_MEMORY_DESCRIPTOR, IO_DESCRIPTOR );


IO_MEMORY_DESCRIPTOR::~IO_MEMORY_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy an IO_MEMORY_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
IO_MEMORY_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an IO_MEMORY_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
        _Length = 0;
        _Alignment = 0;
        _MinimumAddress.LowPart = 0;
        _MinimumAddress.HighPart = 0;
        _MaximumAddress.LowPart = 0;
        _MaximumAddress.HighPart = 0;
}

#if DBG
VOID
IO_MEMORY_DESCRIPTOR::DbgDumpObject(
    )

/*++

Routine Description:

    Print an IO_MEMORY_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    IO_DESCRIPTOR::DbgDumpObject();
    DebugPrintTrace(( "\t\tLength = %#lx \n", _Length ));
    DebugPrintTrace(( "\t\tAlignment = %#lx \n", _Alignment ));
    DebugPrintTrace(( "\t\tMinimumAddress.HighPart = %#lx \n", _MinimumAddress.HighPart ));
    DebugPrintTrace(( "\t\tMinimumAddress.LowPart = %#lx \n", _MinimumAddress.LowPart ));
    DebugPrintTrace(( "\t\tMaximumAddress.HighPart = %#lx \n", _MaximumAddress.HighPart ));
    DebugPrintTrace(( "\t\tMaximumAddress.LowPart = %#lx \n", _MaximumAddress.LowPart ));
    DebugPrintTrace(( "\n" ));
}
#endif

// #include "ulib.hxx"
// #include "regdesc.hxx"

// extern "C" {
//    #include <ctype.h>
// }

DEFINE_CONSTRUCTOR ( IO_DMA_DESCRIPTOR, IO_DESCRIPTOR );


IO_DMA_DESCRIPTOR::~IO_DMA_DESCRIPTOR (
    )

/*++

Routine Description:

    Destroy a IO_DMA_DESCRIPTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
IO_DMA_DESCRIPTOR::Construct (
    )

/*++

Routine Description:

    Construct an IO_DMA_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _MinimumChannel = 0;
    _MaximumChannel = 0;
}

#if DBG
VOID
IO_DMA_DESCRIPTOR::DbgDumpObject(
    )

/*++

Routine Description:

    Print a IO_DMA_DESCRIPTOR object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    IO_DESCRIPTOR::DbgDumpObject();
    DebugPrintTrace(( "\t\tMinimumChannel = %#lx \n", _MinimumChannel ));
    DebugPrintTrace(( "\t\tMaximumChannel = %#lx \n", _MaximumChannel ));
    DebugPrintTrace(( "\n" ));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regkey.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGKEY.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  KeyTreeWnd TreeView routines for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"
#include "regkey.h"
#include "regvalue.h"
#include "regresid.h"

#define MAX_KEYNAME_TEMPLATE_ID         100

#define SELCHANGE_TIMER_ID              1

#define REFRESH_DPA_GROW                16

VOID
PASCAL
RegEdit_OnKeyTreeDelete(
    HWND hWnd,
    HTREEITEM hTreeItem
    );

VOID
PASCAL
RegEdit_OnKeyTreeRename(
    HWND hWnd,
    HTREEITEM hTreeItem
    );

int
WINAPI
DPACompareKeyNames(
    LPVOID lpString1,
    LPVOID lpString2,
    LPARAM lParam
    );

HTREEITEM
PASCAL
KeyTree_InsertItem(
    HWND hKeyTreeWnd,
    HTREEITEM hParent,
    HTREEITEM hInsertAfter,
    LPCTSTR lpText,
    UINT fHasKids,
    LPARAM lParam
    );

BOOL
PASCAL
DoesKeyHaveKids(
    HKEY hKey,
    LPTSTR lpKeyName
    );

VOID
PASCAL
KeyTree_EditLabel(
    HWND hKeyTreeWnd,
    HTREEITEM hTreeItem
    );

BOOL
PASCAL
KeyTree_CanDeleteOrRenameItem(
    HWND hWnd,
    HTREEITEM hTreeItem
    );

/*******************************************************************************
*
*  RegEdit_OnNewKey
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnNewKey(
                 HWND hWnd,
                 HTREEITEM hTreeItem
                 )
{
    TCHAR KeyName[MAXKEYNAME*2];
    UINT cchKeyName = 0;
    HKEY hRootKey;
    HKEY hKey;
    UINT ErrorStringID;
    BOOL fNewKeyIsOnlyChild;
    UINT NewKeyNameID;
    HKEY hNewKey;
    HTREEITEM hNewTreeItem;
    TV_ITEM TVItem;
    
    hRootKey = KeyTree_BuildKeyPath( g_RegEditData.hKeyTreeWnd, 
                                        hTreeItem,
                                        KeyName, 
                                        ARRAYSIZE(KeyName),
                                        BKP_TOSUBKEY);
    cchKeyName = lstrlen(KeyName);

    if(RegOpenKeyEx(hRootKey,KeyName,0,KEY_CREATE_SUB_KEY,&hKey) != ERROR_SUCCESS) {
        
        //
        //  Get the text of the selected tree item so that we can display
        //  a more meaningful error message.
        //
        
        TVItem.mask = TVIF_TEXT;
        TVItem.hItem = hTreeItem;
        TVItem.pszText = (LPTSTR) KeyName;
        TVItem.cchTextMax = ARRAYSIZE(KeyName);
        
        TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);
        
        ErrorStringID = IDS_NEWKEYPARENTOPENFAILED;
        goto error_ShowDialog;
        
    }
    
    TVItem.mask = TVIF_STATE | TVIF_CHILDREN;
    TVItem.hItem = hTreeItem;
    TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);
    
    fNewKeyIsOnlyChild = FALSE;
    
    if (TVItem.cChildren == FALSE) {
        
        //
        //  The selected key doesn't have any subkeys, so we can't do an expand
        //  on it just yet.  We'll just set a flag and later tag it with a
        //  plus/minus icon and expand it.
        //
        
        fNewKeyIsOnlyChild = TRUE;
        
    }
    
    else if (!(TVItem.state & TVIS_EXPANDED)) {
        
        //
        //  The selected key isn't expanded.  Do it now so that we can do an
        //  in-place edit and don't reenumerate the "New Key #xxx" after we do
        //  the RegCreateKey.
        //
        
        TreeView_Expand(g_RegEditData.hKeyTreeWnd, hTreeItem, TVE_EXPAND);
        
    }
    
    if (RegEdit_GetTemporaryKeyName(hWnd, KeyName, ARRAYSIZE(KeyName), hKey))
    {
        if((cchKeyName + lstrlen(KeyName) + 1) < MAXKEYNAME)
        {
            if (RegCreateKey(hKey, KeyName, &hNewKey) != ERROR_SUCCESS)
            {
                ErrorStringID = IDS_NEWKEYCANNOTCREATE;
                goto error_CloseKey;
                
            }
            
            RegCloseKey(hNewKey);
            
            if (fNewKeyIsOnlyChild) 
            {
                TVItem.mask = TVIF_CHILDREN;
                TVItem.cChildren = TRUE;
                TreeView_SetItem(g_RegEditData.hKeyTreeWnd, &TVItem);
                
                TreeView_Expand(g_RegEditData.hKeyTreeWnd, hTreeItem, TVE_EXPAND);
                
                //  WARNING:  It is possible for our new item _not_ to be the only child
                //  if our view is out of date!
                hNewTreeItem = TreeView_GetChild(g_RegEditData.hKeyTreeWnd, hTreeItem);
                
            }
            
            else 
            {
                hNewTreeItem = KeyTree_InsertItem(g_RegEditData.hKeyTreeWnd, hTreeItem,
                    TVI_LAST, KeyName, FALSE, 0);
                
            }
            
            TreeView_SelectItem(g_RegEditData.hKeyTreeWnd, hNewTreeItem);
            KeyTree_EditLabel(g_RegEditData.hKeyTreeWnd, hNewTreeItem);
        }
        else
        {
            ErrorStringID = IDS_RENAMEKEYTOOLONG;
            goto error_CloseKey;
        }
    }
    else
    {
        ErrorStringID = IDS_NEWKEYNOUNIQUE;
        goto error_CloseKey;
    }

    RegCloseKey(hKey);
    return;
    
error_CloseKey:
    RegCloseKey(hKey);
    
    //  FEATURE:  For any errors that may crop up, we may need to turn off the
    //  child flag.
    
error_ShowDialog:
    InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
        MAKEINTRESOURCE(IDS_NEWKEYERRORTITLE), MB_ICONERROR | MB_OK,
        (LPTSTR) KeyName);
    
}


//------------------------------------------------------------------------------
//  RegEdit_GetTemporaryKeyName
//  
//  DESCRIPTION: Loop through the registry trying to find a valid temporary name 
//               until the user renames the key.
//
//  PARAMETERS:  HWND hWnd - handle to window
//               PTSTR pszKeyName
//
//  RETURN:      True, if unique name is found
//------------------------------------------------------------------------------
BOOL RegEdit_GetTemporaryKeyName(HWND hWnd, PTSTR pszKeyName, DWORD cchKeyNameMax, HKEY hKey)
{
    HKEY hNewKey;
    UINT uNewKeyNameID = 1;

    while (uNewKeyNameID < MAX_KEYNAME_TEMPLATE_ID) 
    {
        StringCchPrintf(pszKeyName, cchKeyNameMax, g_RegEditData.pNewKeyTemplate, uNewKeyNameID);

        if(RegOpenKeyEx(hKey, pszKeyName, 0, 0, &hNewKey) == ERROR_FILE_NOT_FOUND) 
        {
            break;
        }
        RegCloseKey(hNewKey);

        uNewKeyNameID++;
    }

    if (uNewKeyNameID == MAX_KEYNAME_TEMPLATE_ID) 
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_NEWKEYNOUNIQUE),
        MAKEINTRESOURCE(IDS_NEWKEYERRORTITLE), MB_ICONERROR | MB_OK, pszKeyName);
    }

    return (uNewKeyNameID != MAX_KEYNAME_TEMPLATE_ID);
}


/*******************************************************************************
*
*  RegEdit_OnKeyTreeItemExpanding
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     lpNMTreeView, TreeView notification data.
*
*******************************************************************************/

LRESULT
PASCAL
RegEdit_OnKeyTreeItemExpanding(
    HWND hWnd,
    LPNM_TREEVIEW lpNMTreeView
    )
{

    HWND hKeyTreeWnd;
    HTREEITEM hExpandingTreeItem;
    TCHAR KeyName[MAXKEYNAME];
    TV_ITEM TVItem;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
    hExpandingTreeItem = lpNMTreeView-> itemNew.hItem;

    //
    //  Check if we're to expand the given tree item for the first time.  If so,
    //  delve into the registry to get all of the key's subkeys.
    //

    if (lpNMTreeView-> action & TVE_EXPAND && !(lpNMTreeView-> itemNew.state &
        TVIS_EXPANDEDONCE)) {

        if (TreeView_GetChild(hKeyTreeWnd, hExpandingTreeItem) != NULL)
            return FALSE;

        RegEdit_SetWaitCursor(TRUE);

        if (!KeyTree_ExpandBranch(hKeyTreeWnd, hExpandingTreeItem)) {

            //
            //  Get the text of the selected tree item so that we can display
            //  a more meaningful error message.
            //

            TVItem.mask = TVIF_TEXT;
            TVItem.hItem = hExpandingTreeItem;
            TVItem.pszText = (LPTSTR) KeyName;
            TVItem.cchTextMax = ARRAYSIZE(KeyName);

            TreeView_GetItem(hKeyTreeWnd, &TVItem);

            InternalMessageBox(g_hInstance, hWnd,
                MAKEINTRESOURCE(IDS_OPENKEYCANNOTOPEN),
                MAKEINTRESOURCE(IDS_OPENKEYERRORTITLE), MB_ICONERROR | MB_OK,
                (LPTSTR) KeyName);

        }

	RegEdit_SetWaitCursor(FALSE);

    }

    return FALSE;

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeSelChanged
*
*  DESCRIPTION:
*     Depending on how the user has selected the new item in the KeyTreeWnd,
*     we call to the real worker routine, RegEdit_KeyTreeSelChanged, or delay
*     the call for several milliseconds.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     lpNMTreeView, TreeView notification data.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeSelChanged(
    HWND hWnd,
    LPNM_TREEVIEW lpNMTreeView
    )
{

    UINT TimerDelay;

    //
    //  We delay the actual update of the selection and thus of the
    //  ValueListWnd for several milliseconds.  This avoids unnecessary flashing
    //  as the user scrolls through the tree.  (This behavior is directly taken
    //	from the Explorer.)
    //

    switch (g_RegEditData.SelChangeTimerState) {

        case SCTS_TIMERSET:
            KillTimer(hWnd, SELCHANGE_TIMER_ID);
            //  FALL THROUGH

        case SCTS_TIMERCLEAR:
#ifdef WINNT
        //
        // This behavior is extremely annoying so I am changing it.
        //
	    TimerDelay = 1;
#else
	    TimerDelay = (lpNMTreeView != NULL && lpNMTreeView-> action ==
		TVC_BYMOUSE) ? (1) : (GetDoubleClickTime() * 3 / 2);
#endif
	    SetTimer(hWnd, SELCHANGE_TIMER_ID, TimerDelay, NULL);
            g_RegEditData.SelChangeTimerState = SCTS_TIMERSET;
            break;

        //
        //  We want to punt the first selection change notification that comes
        //  through.
        //

        case SCTS_INITIALIZING:
            RegEdit_KeyTreeSelChanged(hWnd);
            break;

    }

}

/*******************************************************************************
*
*  RegEdit_OnSelChangedTimer
*
*  DESCRIPTION:
*     Called several milliseconds after a keyboard operation has selected a new
*     item in the KeyTreeWnd.  Act as if a new selection has just been made in
*     the KeyTreeWnd.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnSelChangedTimer(
    HWND hWnd
    )
{

    KillTimer(hWnd, SELCHANGE_TIMER_ID);
    g_RegEditData.SelChangeTimerState = SCTS_TIMERCLEAR;

    RegEdit_KeyTreeSelChanged(hWnd);

}

/*******************************************************************************
*
*  RegEdit_KeyTreeSelChanged
*
*  DESCRIPTION:
*     Called after a new item has been selected in the KeyTreeWnd.  Opens a
*     registry key to the new branch and notifies the ValueListWnd to update
*     itself.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_KeyTreeSelChanged(
    HWND hWnd
    )
{

    HWND hKeyTreeWnd;
    HTREEITEM hSelectedTreeItem;
    RECT ItemRect;
    RECT ClientRect;
    RECT FromRect;
    RECT ToRect;
    HKEY hRootKey;
    TCHAR KeyName[MAXKEYNAME];
    TV_ITEM TVItem;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
    hSelectedTreeItem = TreeView_GetSelection(hKeyTreeWnd);

    if (g_RegEditData.SelChangeTimerState != SCTS_INITIALIZING) {

        //
        //  Draw an animation that shows the "expansion" of the newly selected
        //  tree item to the ListView.
        //

        TreeView_GetItemRect(hKeyTreeWnd, hSelectedTreeItem, &ItemRect, TRUE);
        GetClientRect(hKeyTreeWnd, &ClientRect);
        IntersectRect(&FromRect, &ClientRect, &ItemRect);
        MapWindowPoints(hKeyTreeWnd, hWnd, (LPPOINT) &FromRect, 2);

        GetWindowRect(g_RegEditData.hValueListWnd, &ToRect);
        MapWindowPoints(NULL, hWnd, (LPPOINT) &ToRect, 2);

        DrawAnimatedRects(hWnd, IDANI_OPEN, &FromRect, &ToRect);

    }

    //
    //  Close the previously selected item's key handle, if appropriate.
    //

    if (g_RegEditData.hCurrentSelectionKey != NULL) {

        RegCloseKey(g_RegEditData.hCurrentSelectionKey);
        g_RegEditData.hCurrentSelectionKey = NULL;

    }

    RegEdit_UpdateStatusBar();

    //
    //  Simple case-- we're changing to one of the top-level labels, such as
    //  "My Computer" or a network computer name.  Right now, nothing is
    //  displayed in the ListView, so just empty it and return.
    //

    if (TreeView_GetParent(hKeyTreeWnd, hSelectedTreeItem) != NULL) {

        //
        //  Build a registry path to the selected tree item and open a registry
        //  key.
        //

        hRootKey = KeyTree_BuildKeyPath( hKeyTreeWnd, 
                                            hSelectedTreeItem,
                                            KeyName, 
                                            ARRAYSIZE(KeyName),
                                            BKP_TOSUBKEY);

        if(RegOpenKeyEx(hRootKey,KeyName, 0, MAXIMUM_ALLOWED,
            &g_RegEditData.hCurrentSelectionKey) != ERROR_SUCCESS) {

            //
            //  Get the text of the selected tree item so that we can display
            //  a more meaningful error message.
            //

            TVItem.mask = TVIF_TEXT;
            TVItem.hItem = hSelectedTreeItem;
            TVItem.pszText = (LPTSTR) KeyName;
            TVItem.cchTextMax = ARRAYSIZE(KeyName);

            TreeView_GetItem(hKeyTreeWnd, &TVItem);

            InternalMessageBox(g_hInstance, hWnd,
                MAKEINTRESOURCE(IDS_OPENKEYCANNOTOPEN),
                MAKEINTRESOURCE(IDS_OPENKEYERRORTITLE), MB_ICONERROR | MB_OK,
                (LPTSTR) KeyName);

        }

    }

    RegEdit_OnValueListRefresh(hWnd);

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeBeginLabelEdit
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     lpTVDispInfo,
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_OnKeyTreeBeginLabelEdit(
    HWND hWnd,
    TV_DISPINFO FAR* lpTVDispInfo
    )
{

    //
    //  B#7933:  We don't want the user to hurt themselves by making it too easy
    //  to rename keys and values.  Only allow renames via the menus.
    //

    //
    //  We don't get any information on the source of this editing action, so
    //  we must maintain a flag that tells us whether or not this is "good".
    //

    if (!g_RegEditData.fAllowLabelEdits)
        return TRUE;

    //
    //  All other labels are fair game.  We need to disable our keyboard
    //  accelerators so that the edit control can "see" them.
    //

    g_fDisableAccelerators = TRUE;

    return FALSE;

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeEndLabelEdit
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     lpTVDispInfo,
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_OnKeyTreeEndLabelEdit(
    HWND hWnd,
    TV_DISPINFO FAR* lpTVDispInfo
    )
{

    HWND hKeyTreeWnd;
    HKEY hRootKey;
    TCHAR SourceKeyName[MAXKEYNAME*2];
    TCHAR DestinationKeyName[MAXKEYNAME];
    HKEY hSourceKey;
    HKEY hDestinationKey;
    LPTSTR lpEndOfParentKey;
    UINT ErrorStringID;
    TV_ITEM TVItem;

    //
    //  We can reenable our keyboard accelerators now that the edit control no
    //  longer needs to "see" them.
    //

    g_fDisableAccelerators = FALSE;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    //
    //  Check to see if the user cancelled the edit.  If so, we don't care so
    //  just return.
    //

    if (lpTVDispInfo-> item.pszText == NULL)
        return FALSE;

    //
    //  Attempt to open the key to be renamed.  This may or may not be the same
    //  key that is already open.
    //

    hRootKey = KeyTree_BuildKeyPath( hKeyTreeWnd, 
                                        lpTVDispInfo-> item.hItem,
                                        SourceKeyName, 
                                        ARRAYSIZE(SourceKeyName),
                                        BKP_TOSUBKEY);

    if (lstrlen(SourceKeyName) >= MAXKEYNAME) {
        ErrorStringID = IDS_RENAMEKEYTOOLONG;
        goto error_ShowDialog;

    }

    if(RegOpenKeyEx(hRootKey,SourceKeyName,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,&hSourceKey) != ERROR_SUCCESS) 
    {
        ErrorStringID = IDS_RENAMEKEYOTHERERROR;
        goto error_ShowDialog;
    }

    //
    //  Take the full path name of the key (relative to a predefined root key)
    //  and replace the old key name with the new.  Make sure that this key
    //  doesn't exceed our internal buffers.
    //

    StringCchCopy(DestinationKeyName, ARRAYSIZE(DestinationKeyName), SourceKeyName);

    if ((lpEndOfParentKey = StrRChr(DestinationKeyName, NULL, TEXT('\\'))) != NULL)
        lpEndOfParentKey++;

    else
        lpEndOfParentKey = DestinationKeyName;

    *lpEndOfParentKey = 0;

    if (lstrlen(DestinationKeyName) + lstrlen(lpTVDispInfo->item.pszText) >= MAXKEYNAME) {
        ErrorStringID = IDS_RENAMEKEYTOOLONG;
        goto error_CloseSourceKey;
    }

    lstrcpy(lpEndOfParentKey, lpTVDispInfo->item.pszText);

    //
    //  Make sure there are no backslashes in the name.
    //

    if (StrChr(lpEndOfParentKey, TEXT('\\')) != NULL) 
    {
        ErrorStringID = IDS_RENAMEKEYBADCHARS;
        goto error_CloseSourceKey;
    }

    //
    //  Make sure there the name isn't empty
    //

    if (DestinationKeyName[0] == 0) {
        ErrorStringID = IDS_RENAMEKEYEMPTY;
        goto error_CloseSourceKey;
    }

    //
    //  Make sure that the destination doesn't already exist.
    //
    if(RegOpenKeyEx(hRootKey, DestinationKeyName, 0, KEY_QUERY_VALUE, &hDestinationKey) == ERROR_SUCCESS) 
    {
        RegCloseKey(hDestinationKey);

        ErrorStringID = IDS_RENAMEKEYEXISTS;
        goto error_CloseSourceKey;
    }

    //
    //  Create the destination key and do the copy.
    //

    if (RegCreateKey(hRootKey, DestinationKeyName, &hDestinationKey) != ERROR_SUCCESS) 
    {
        ErrorStringID = IDS_RENAMEKEYOTHERERROR;
        goto error_CloseSourceKey;
    }

    //  FEATURE:  Check this return (when it gets one!)
    if (!CopyRegistry(hSourceKey, hDestinationKey))
    {
        RegCloseKey(hDestinationKey);
        RegCloseKey(hSourceKey);

        ErrorStringID = IDS_RENAMEKEYOTHERERROR;
        goto error_ShowDialog;
    }

    RegCloseKey(hSourceKey);

    //
    //  Check to see if we're renaming the currently selected key.  If so, toss
    //  our cached key handle and change to our source key.
    //

    if (TreeView_GetSelection(hKeyTreeWnd) == lpTVDispInfo-> item.hItem) {

        RegCloseKey(g_RegEditData.hCurrentSelectionKey);

        g_RegEditData.hCurrentSelectionKey = hDestinationKey;

        //
        //  We can't just call RegEdit_UpdateStatusBar here... the tree item
        //  won't be updated until we return TRUE from this message.  So we must
        //  post a message to tell ourselves to do the update later on.
        //

        PostMessage(hWnd, REM_UPDATESTATUSBAR, 0, 0);

    }

    else
        RegCloseKey(hDestinationKey);

    if (RegDeleteKeyRecursive(hRootKey, SourceKeyName) != ERROR_SUCCESS) {

        ErrorStringID = IDS_RENAMEKEYOTHERERROR;
        goto error_ShowDialog;

    }

    return TRUE;

error_CloseSourceKey:
    RegCloseKey(hSourceKey);

error_ShowDialog:
    TVItem.hItem = lpTVDispInfo-> item.hItem;
    TVItem.mask = TVIF_TEXT;
    TVItem.pszText = SourceKeyName;
    TVItem.cchTextMax = ARRAYSIZE(SourceKeyName);

    TreeView_GetItem(hKeyTreeWnd, &TVItem);

    InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
        MAKEINTRESOURCE(IDS_RENAMEKEYERRORTITLE), MB_ICONERROR | MB_OK,
        (LPTSTR) SourceKeyName);

    return FALSE;

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeCommand
*
*  DESCRIPTION:
*     Handles the selection of a menu item by the user intended for the
*     KeyTree child window.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     MenuCommand, identifier of menu command.
*     hTreeItem,
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeCommand(
    HWND hWnd,
    int MenuCommand,
    HTREEITEM hTreeItem
    )
{

    HWND hKeyTreeWnd;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    //
    //  Assume that the we mean the current selection if we're to dispatch a
    //  command that requires a tree item.  This is necessary because the tree
    //  control will let you activate the context menu of one tree item while
    //  another one is really the selected tree item.
    //

    if (hTreeItem == NULL)
        hTreeItem = TreeView_GetSelection(hKeyTreeWnd);

    switch (MenuCommand) {

        case ID_CONTEXTMENU:
            RegEdit_OnKeyTreeContextMenu(hWnd, TRUE);
            break;

        case ID_TOGGLE:
            TreeView_Expand(hKeyTreeWnd, hTreeItem, TVE_TOGGLE);
            break;

        case ID_DELETE:
            RegEdit_OnKeyTreeDelete(hWnd, hTreeItem);
            break;

        case ID_RENAME:
            RegEdit_OnKeyTreeRename(hWnd, hTreeItem);
            break;

        case ID_DISCONNECT:
            RegEdit_OnKeyTreeDisconnect(hWnd, hTreeItem);
            break;

        case ID_COPYKEYNAME:
            RegEdit_OnCopyKeyName(hWnd, hTreeItem);
            break;

        case ID_NEWKEY:
            RegEdit_OnNewKey(hWnd, hTreeItem);
            break;

        case ID_NEWSTRINGVALUE:
        case ID_NEWBINARYVALUE:
            if (hTreeItem != TreeView_GetSelection(hKeyTreeWnd)) {

                //
                //  Force the selection to occur now, so that we're dealing
                //  with the right open key.
                //

                TreeView_SelectItem(hKeyTreeWnd, hTreeItem);
                RegEdit_OnSelChangedTimer(hWnd);

            }
            //  FALL THROUGH

        default:
            //
            //  Check to see if this menu command should be handled by the main
            //  window's command handler.
            //

            if (MenuCommand >= ID_FIRSTMAINMENUITEM && MenuCommand <=
                ID_LASTMAINMENUITEM)
                RegEdit_OnCommand(hWnd, MenuCommand, NULL, 0);
            break;

    }

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeContextMenu
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeContextMenu(
    HWND hWnd,
    BOOL fByAccelerator
    )
{

    HWND hKeyTreeWnd;
    DWORD MessagePos;
    POINT MessagePoint;
    TV_HITTESTINFO TVHitTestInfo;
    UINT MenuID;
    HMENU hContextMenu;
    HMENU hContextPopupMenu;
    TV_ITEM TVItem;
    int MenuCommand;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    //
    //  If fByAcclerator is TRUE, then the user hit Shift-F10 to bring up the
    //  context menu.  Following the Cabinet's convention, this menu is
    //  placed at (0,0) of the KeyTree client area.
    //

    if (fByAccelerator) {

        MessagePoint.x = 0;
        MessagePoint.y = 0;

        ClientToScreen(hKeyTreeWnd, &MessagePoint);

        TVItem.hItem = TreeView_GetSelection(hKeyTreeWnd);

    }

    else {

        MessagePos = GetMessagePos();

        MessagePoint.x = GET_X_LPARAM(MessagePos);
        MessagePoint.y = GET_Y_LPARAM(MessagePos);

        TVHitTestInfo.pt = MessagePoint;
        ScreenToClient(hKeyTreeWnd, &TVHitTestInfo.pt);
        TVItem.hItem = TreeView_HitTest(hKeyTreeWnd, &TVHitTestInfo);

    }

    //
    //  Determine which context menu to use and load it up.
    //

    if (TVItem.hItem == NULL)
    {
        return;     //  No context menu for now
    }
    else 
    {
        // Select the item to be dragged
        TreeView_Select(g_RegEditData.hKeyTreeWnd, TVItem.hItem, TVGN_CARET);

        if (TreeView_GetParent(hKeyTreeWnd, TVItem.hItem) == NULL)
            MenuID = IDM_COMPUTER_CONTEXT;

        else
            MenuID = IDM_KEY_CONTEXT;

    }

    if ((hContextMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(MenuID))) == NULL)
        return;

    hContextPopupMenu = GetSubMenu(hContextMenu, 0);

    TVItem.mask = TVIF_STATE | TVIF_CHILDREN;
    TreeView_GetItem(hKeyTreeWnd, &TVItem);

    if (TVItem.state & TVIS_EXPANDED)
        ModifyMenu(hContextPopupMenu, ID_TOGGLE, MF_BYCOMMAND | MF_STRING,
            ID_TOGGLE, g_RegEditData.pCollapse);

    if (MenuID == IDM_COMPUTER_CONTEXT) {

        if (g_RegEditData.fHaveNetwork) {

            if (TreeView_GetPrevSibling(hKeyTreeWnd, TVItem.hItem) == NULL)
                EnableMenuItem(hContextPopupMenu, ID_DISCONNECT, MF_GRAYED |
                    MF_BYCOMMAND);

        }

        else {

            DeleteMenu(hContextPopupMenu, ID_DISCONNECT, MF_BYCOMMAND);
            DeleteMenu(hContextPopupMenu, ID_NETSEPARATOR, MF_BYCOMMAND);

        }

    }

    else {

        RegEdit_SetKeyTreeEditMenuItems(hContextPopupMenu, TVItem.hItem);

        if (TVItem.cChildren == 0)
            EnableMenuItem(hContextPopupMenu, ID_TOGGLE, MF_GRAYED |
                MF_BYCOMMAND);

    }

    SetMenuDefaultItem(hContextPopupMenu, ID_TOGGLE, MF_BYCOMMAND);

    MenuCommand = TrackPopupMenuEx(hContextPopupMenu, TPM_RETURNCMD |
        TPM_RIGHTBUTTON | TPM_LEFTALIGN | TPM_TOPALIGN, MessagePoint.x,
        MessagePoint.y, hWnd, NULL);

    DestroyMenu(hContextMenu);

    RegEdit_OnKeyTreeCommand(hWnd, MenuCommand, TVItem.hItem);

}

/*******************************************************************************
*
*  RegEdit_SetKeyTreeEditMenuItems
*
*  DESCRIPTION:
*     Shared routine between the main menu and the context menu to setup the
*     edit menu items.
*
*  PARAMETERS:
*     hPopupMenu, handle of popup menu to modify.
*     hTreeItem, handle of selected tree item.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_SetKeyTreeEditMenuItems(
    HMENU hPopupMenu,
    HTREEITEM hSelectedTreeItem
    )
{

    UINT EnableFlags;

    EnableFlags = KeyTree_CanDeleteOrRenameItem(g_RegEditData.hKeyTreeWnd,
        hSelectedTreeItem) ? (MF_ENABLED | MF_BYCOMMAND) :
        (MF_GRAYED | MF_BYCOMMAND);

    EnableMenuItem(hPopupMenu, ID_DELETE, EnableFlags);
    EnableMenuItem(hPopupMenu, ID_RENAME, EnableFlags);

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeDelete
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeDelete(
    HWND hWnd,
    HTREEITEM hTreeItem
    )
{

    HWND hKeyTreeWnd;
    HKEY hRootKey;
    TCHAR KeyName[MAXKEYNAME];
    HTREEITEM hParentTreeItem;
    TV_ITEM TVItem;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    if (!KeyTree_CanDeleteOrRenameItem(hKeyTreeWnd, hTreeItem))
        return;

    if (InternalMessageBox(g_hInstance, hWnd,
        MAKEINTRESOURCE(IDS_CONFIRMDELKEYTEXT),
        MAKEINTRESOURCE(IDS_CONFIRMDELKEYTITLE), MB_ICONWARNING | MB_YESNO) !=
        IDYES)
        return;

    if (hTreeItem == TreeView_GetSelection(hKeyTreeWnd)) {

        if (g_RegEditData.hCurrentSelectionKey != NULL) {

            RegCloseKey(g_RegEditData.hCurrentSelectionKey);
            g_RegEditData.hCurrentSelectionKey = NULL;

        }

    }

    hRootKey = KeyTree_BuildKeyPath( hKeyTreeWnd, 
                                        hTreeItem, 
                                        KeyName,
                                        ARRAYSIZE(KeyName),
                                        BKP_TOSUBKEY);

    if (RegDeleteKeyRecursive(hRootKey, KeyName) == ERROR_SUCCESS) {

        SetWindowRedraw(hKeyTreeWnd, FALSE);

        hParentTreeItem = TreeView_GetParent(hKeyTreeWnd, hTreeItem);

        TreeView_DeleteItem(hKeyTreeWnd, hTreeItem);

        //
        //  See if the key that we just deleted was the last child of its
        //  parent.  If so, remove the expand/collapse button.
        //

        if (TreeView_GetChild(hKeyTreeWnd, hParentTreeItem) == NULL) {

            TVItem.mask = TVIF_CHILDREN | TVIF_STATE;
            TVItem.hItem = hParentTreeItem;
            TVItem.cChildren = 0;
            TVItem.state = 0;
            TVItem.stateMask = TVIS_EXPANDED | TVIS_EXPANDEDONCE;
            TreeView_SetItem(hKeyTreeWnd, &TVItem);

        }

        //
        //  Make sure we can see the selected tree item now since it may be
        //  currently off-screen.
        //

        TreeView_EnsureVisible(hKeyTreeWnd, TreeView_GetSelection(hKeyTreeWnd));

        SetWindowRedraw(hKeyTreeWnd, TRUE);

        UpdateWindow(hKeyTreeWnd);

    }
    else 
    {

        TVItem.hItem = hTreeItem;
        TVItem.mask = TVIF_TEXT;
        TVItem.pszText = KeyName;
        TVItem.cchTextMax = ARRAYSIZE(KeyName);

        TreeView_GetItem(hKeyTreeWnd, &TVItem);

        InternalMessageBox(g_hInstance, hWnd,
            MAKEINTRESOURCE(IDS_DELETEKEYDELETEFAILED),
            MAKEINTRESOURCE(IDS_DELETEKEYERRORTITLE), MB_ICONERROR | MB_OK,
            KeyName);

        //
        //  Need to refresh the tree at this point, as some subkeys may have
        //  been deleted successfully even if we didn't have sufficient
        //  permissions to delete all of them.
        //
        RegEdit_OnKeyTreeRefresh(hWnd);
    }

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeRename
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeRename(
    HWND hWnd,
    HTREEITEM hTreeItem
    )
{

    if (KeyTree_CanDeleteOrRenameItem(g_RegEditData.hKeyTreeWnd, hTreeItem))
        KeyTree_EditLabel(g_RegEditData.hKeyTreeWnd, hTreeItem);

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeRefresh
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeRefresh(
    HWND hWnd
    )
{

    HDPA hDPA;
    HWND hKeyTreeWnd;
    HTREEITEM hPrevSelectedTreeItem;
    TV_ITEM EnumTVItem;
    TV_ITEM CurrentTVItem;
    HKEY hRootKey;
    TCHAR KeyName[MAXKEYNAME];
    int MaximumSubKeyLength;
    int Index;
    HKEY hEnumKey;
    int CompareResult;
    LPTSTR lpDPAKeyName;
    HTREEITEM hTempTreeItem;

    if ((hDPA = DPA_CreateEx(REFRESH_DPA_GROW, GetProcessHeap())) == NULL)
        return;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    RegEdit_SetWaitCursor(TRUE);
    SetWindowRedraw(hKeyTreeWnd, FALSE);

    hPrevSelectedTreeItem = TreeView_GetSelection(hKeyTreeWnd);

    EnumTVItem.mask = TVIF_TEXT;
    EnumTVItem.pszText = KeyName;
    EnumTVItem.cchTextMax = ARRAYSIZE(KeyName);

    CurrentTVItem.mask = TVIF_STATE | TVIF_CHILDREN;
    CurrentTVItem.stateMask = 0;
    CurrentTVItem.hItem = TreeView_GetRoot(hKeyTreeWnd);

    while (TRUE) {

        TreeView_GetItem(hKeyTreeWnd, &CurrentTVItem);

        hRootKey = KeyTree_BuildKeyPath( hKeyTreeWnd, 
                                            CurrentTVItem.hItem,
                                            KeyName, 
                                            ARRAYSIZE(KeyName),
                                            BKP_TOSUBKEY);

        if (CurrentTVItem.state & TVIS_EXPANDED) {

            //
            //  If this isn't a top-level label (and it won't be if hRootKey is
            //  not NULL), then compare the actual contents of the registry
            //  against what we're showing.
            //
            if(hRootKey && RegOpenKeyEx(hRootKey,KeyName,0,KEY_ENUMERATE_SUB_KEYS,&hEnumKey) ==
                ERROR_SUCCESS) {

                //
                //  As a result of adding new keys and renaming existing ones,
                //  the children of this item may be out of order.  For the
                //  following algorithm to work correctly, we must now sort
                //  these keys.
                //

                TreeView_SortChildren(hKeyTreeWnd, CurrentTVItem.hItem, FALSE);

                //
                //  Build a sorted dynamic array of strings that represent the
                //  keys actually in the registry at this time.
                //

                MaximumSubKeyLength = MAXKEYNAME - (lstrlen(KeyName) + 1);
                Index = 0;

                while (RegEnumKey(hEnumKey, Index, KeyName,
                    MaximumSubKeyLength) == ERROR_SUCCESS) {

                    lpDPAKeyName = NULL;
                    Str_SetPtr(&lpDPAKeyName, KeyName);
                    DPA_InsertPtr(hDPA, Index++, lpDPAKeyName);

                }

                RegCloseKey(hEnumKey);
                DPA_Sort(hDPA, DPACompareKeyNames, 0);

                //
                //  Does this key have subkeys anymore?  If not, then we need
                //  to reset it's child flag and remove all of it's children.
                //

                if (Index == 0) {

                    DPA_DeleteAllPtrs(hDPA);

                    TreeView_Expand(hKeyTreeWnd, CurrentTVItem.hItem,
                        TVE_COLLAPSE | TVE_COLLAPSERESET);

                    CurrentTVItem.cChildren = 0;
                    goto SetCurrentTreeItem;

                }

                //
                //  Merge the keys that we found during our above enumeration
                //  with the keys that our key tree lists.  Add and remove
                //  elements from the tree as appropriate.
                //

                lpDPAKeyName = DPA_FastGetPtr(hDPA, --Index);

                EnumTVItem.hItem = TreeView_GetChild(hKeyTreeWnd,
                    CurrentTVItem.hItem);
                if (EnumTVItem.hItem)
                    TreeView_GetItem(hKeyTreeWnd, &EnumTVItem);

                while (Index >= 0 && EnumTVItem.hItem != NULL) {

                    CompareResult = lstrcmpi(KeyName, lpDPAKeyName);

                    if (CompareResult == 0) {

                        EnumTVItem.hItem = TreeView_GetNextSibling(hKeyTreeWnd,
                            EnumTVItem.hItem);
                        if (EnumTVItem.hItem)
                            TreeView_GetItem(hKeyTreeWnd, &EnumTVItem);

                        goto GetNextDPAPointer;

                    }

                    else if (CompareResult > 0) {

                        KeyTree_InsertItem(hKeyTreeWnd, CurrentTVItem.hItem,
                            TVI_SORT, lpDPAKeyName, DoesKeyHaveKids(hEnumKey,
                            lpDPAKeyName), 0);

GetNextDPAPointer:
                        Str_SetPtr(&lpDPAKeyName, NULL);

                        if (--Index >= 0)
                            lpDPAKeyName = DPA_FastGetPtr(hDPA, Index);

                    }

                    else {

                        hTempTreeItem = TreeView_GetNextSibling(hKeyTreeWnd,
                            EnumTVItem.hItem);
                        TreeView_DeleteItem(hKeyTreeWnd, EnumTVItem.hItem);
                        EnumTVItem.hItem = hTempTreeItem;
                        if (EnumTVItem.hItem)
                            TreeView_GetItem(hKeyTreeWnd, &EnumTVItem);

                    }

                }

                //
                //  Once we drop to here, we may have extra items in the key
                //  tree or in the dynamic array.  Process them accordingly.
                //

                if (Index >= 0) {

                    while (TRUE) {

                        KeyTree_InsertItem(hKeyTreeWnd, CurrentTVItem.hItem,
                            TVI_SORT, lpDPAKeyName, DoesKeyHaveKids(hEnumKey,
                            lpDPAKeyName), 0);

                        Str_SetPtr(&lpDPAKeyName, NULL);

                        if (--Index < 0)
                            break;

                        lpDPAKeyName = DPA_FastGetPtr(hDPA, Index);

                    }

                }

                else {

                    while (EnumTVItem.hItem != NULL) {

                        hTempTreeItem = TreeView_GetNextSibling(hKeyTreeWnd,
                            EnumTVItem.hItem);
                        TreeView_DeleteItem(hKeyTreeWnd, EnumTVItem.hItem);
                        EnumTVItem.hItem = hTempTreeItem;

                    }

                }

                DPA_DeleteAllPtrs(hDPA);

            }

            CurrentTVItem.hItem = TreeView_GetChild(hKeyTreeWnd,
                CurrentTVItem.hItem);

        }

        else {

            //
            //  If this isn't a top-level label (and it won't be if hRootKey is
            //  not NULL), then re-check if this key has any children.
            //

            if (hRootKey != NULL) {

                TreeView_Expand(hKeyTreeWnd, CurrentTVItem.hItem, TVE_COLLAPSE |
                    TVE_COLLAPSERESET);

                CurrentTVItem.cChildren = DoesKeyHaveKids(hRootKey, KeyName);

SetCurrentTreeItem:
                TreeView_SetItem(hKeyTreeWnd, &CurrentTVItem);

            }

            //
            //  Because we're at the "bottom" of the TreeView, we now need to
            //  walk to the siblings of this tree item.  And if no siblings
            //  exist, we walk back to the parent and check again for siblings.
            //

            while (TRUE) {

                if ((hTempTreeItem = TreeView_GetNextSibling(hKeyTreeWnd,
                    CurrentTVItem.hItem)) != NULL) {

                    CurrentTVItem.hItem = hTempTreeItem;
                    break;

                }

                if ((CurrentTVItem.hItem = TreeView_GetParent(hKeyTreeWnd,
                    CurrentTVItem.hItem)) == NULL) {

                    //
                    //  We've now walked over all of the tree items, so do any
                    //  cleanup here and exit.
                    //

                    DPA_Destroy(hDPA);

                    SetWindowRedraw(hKeyTreeWnd, TRUE);

                    //
                    //  The selection may have changed as a result of having
                    //  the focus on an nonexistent key.
                    //

                    if (TreeView_GetSelection(hKeyTreeWnd) != hPrevSelectedTreeItem) {
                        RegEdit_OnKeyTreeSelChanged(hWnd, NULL);
                    } else {
                        if (RegEdit_OnValueListRefresh(hWnd) != ERROR_SUCCESS) {
                            //
                            // Its possible that the registry key was deleted and replaced with
                            // an identically-named key.  We should just trigger a selection
                            // change in this case.
                            //
                            RegEdit_OnKeyTreeSelChanged(hWnd, NULL);
                        }
                    }

                    RegEdit_SetWaitCursor(FALSE);

                    return;

                }

            }

        }

    }

}

/*******************************************************************************
*
*  DPACompareKeyNames
*
*  DESCRIPTION:
*     Callback comparision routine for refresh's DPA_Sort call.  Simply returns
*     the result of lstrcmpi.
*
*  PARAMETERS:
*     lpString1,
*     lpString2,
*     lParam, ignored optional data.
*
*******************************************************************************/

int
WINAPI
DPACompareKeyNames(
    LPVOID lpString1,
    LPVOID lpString2,
    LPARAM lParam
    )
{

    return lstrcmpi((LPTSTR) lpString2, (LPTSTR) lpString1);

}

/*******************************************************************************
*
*  RegEdit_OnKeyTreeDisconnect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnKeyTreeDisconnect(
    HWND hWnd,
    HTREEITEM hTreeItem
    )
{

    HWND hKeyTreeWnd;
    TV_ITEM TVItem;

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    //
    //  Disconnect all of the root registry handles that we've opened.
    //

    TVItem.mask = TVIF_PARAM;
    TVItem.hItem = TreeView_GetChild(hKeyTreeWnd, hTreeItem);

    while (TVItem.hItem != NULL) {

        TreeView_GetItem(hKeyTreeWnd, &TVItem);

        RegCloseKey((HKEY) TVItem.lParam);

        TVItem.hItem = TreeView_GetNextSibling(hKeyTreeWnd, TVItem.hItem);

    }

    TreeView_DeleteItem(hKeyTreeWnd, hTreeItem);

}

/*******************************************************************************
*
*  RegEdit_UpdateStatusBar
*
*  DESCRIPTION:
*     Show the full registry path in the status bar, for lack of anything
*     better to do with it.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
PASCAL
RegEdit_UpdateStatusBar(
    VOID
    )
{

    HWND hKeyTreeWnd;
    TCHAR KeyName[MAXKEYNAME*2];

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    KeyTree_BuildKeyPath( hKeyTreeWnd, 
                            TreeView_GetSelection(hKeyTreeWnd),
                            KeyName, 
                            ARRAYSIZE(KeyName),
                            BKP_TOCOMPUTER);

    SetWindowText(g_RegEditData.hStatusBarWnd, KeyName);

}

/*******************************************************************************
*
*  RegEdit_OnCopyKeyName
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCopyKeyName(
    HWND hWnd,
    HTREEITEM hTreeItem
    )
{

    TCHAR KeyName[MAXKEYNAME*2];
    UINT KeyNameLength;
    HANDLE hClipboardData;
    LPTSTR lpClipboardData;

    KeyTree_BuildKeyPath( g_RegEditData.hKeyTreeWnd, 
                            hTreeItem, 
                            KeyName, 
                            ARRAYSIZE(KeyName),
                            BKP_TOSYMBOLICROOT);

    KeyNameLength = (lstrlen(KeyName) + 1) * sizeof(TCHAR);

    if (OpenClipboard(hWnd)) 
    {
        if ((hClipboardData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, KeyNameLength)) != NULL) 
        {
            lpClipboardData = (LPTSTR) GlobalLock(hClipboardData);

            CopyMemory(lpClipboardData, KeyName, KeyNameLength);

            GlobalUnlock(hClipboardData);

            EmptyClipboard();
            SetClipboardData(CF_UNICODETEXT, hClipboardData);
        }

        CloseClipboard();
    }

}

/*******************************************************************************
*
*  KeyTree_BuildKeyPath
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hTreeViewWnd, handle of KeyTree window.
*     hTreeItem, handle of tree item to begin building from.
*     lpKeyPath, buffer to store path in.
*     cchKeyPathMax, maximum # of characters in key path, includes space for NULL
*     fIncludeSymbolicRootName, TRUE if root key's name should be included
*        (e.g., HKEY_LOCAL_MACHINE), else FALSE.
*
*******************************************************************************/

HKEY
PASCAL
KeyTree_BuildKeyPath(
    HWND hTreeViewWnd,
    HTREEITEM hTreeItem,
    LPTSTR lpKeyPath,
    DWORD cchKeyPathMax,
    UINT ToFlags
    )
{

    TV_ITEM TVItem;
    TCHAR SubKeyName[MAXKEYNAME*2];

    *lpKeyPath = '\0';

    TVItem.mask = TVIF_TEXT | TVIF_PARAM;
    TVItem.hItem = hTreeItem;
    TVItem.pszText = (LPTSTR) SubKeyName;
    TVItem.cchTextMax = ARRAYSIZE(SubKeyName);

    while (TRUE) {

        TreeView_GetItem(hTreeViewWnd, &TVItem);

        if (TVItem.lParam != 0 && !(ToFlags & BKP_TOSYMBOLICROOT))
            break;

        if (*lpKeyPath != '\0') {

            StringCchCat(SubKeyName, ARRAYSIZE(SubKeyName), TEXT("\\"));
            StringCchCat(SubKeyName, ARRAYSIZE(SubKeyName), lpKeyPath);

        }

        StringCchCopy(lpKeyPath, cchKeyPathMax, SubKeyName);

        if (TVItem.lParam != 0 && (ToFlags & BKP_TOCOMPUTER) != BKP_TOCOMPUTER)
            break;

        TVItem.hItem = TreeView_GetParent(hTreeViewWnd, TVItem.hItem);

        if (TVItem.hItem == NULL) {

            if ((ToFlags & BKP_TOCOMPUTER) != BKP_TOCOMPUTER)
                *lpKeyPath = '\0';

            break;

        }

    }

    return ((HKEY) TVItem.lParam);

}

/*******************************************************************************
*
*  KeyTree_InsertItem
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

HTREEITEM
PASCAL
KeyTree_InsertItem(
    HWND hKeyTreeWnd,
    HTREEITEM hParent,
    HTREEITEM hInsertAfter,
    LPCTSTR lpText,
    UINT fHasKids,
    LPARAM lParam
    )
{

    TV_INSERTSTRUCT TVInsertStruct;

    TVInsertStruct.hParent = hParent;
    TVInsertStruct.hInsertAfter = hInsertAfter;
    TVInsertStruct.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE |
        TVIF_PARAM | TVIF_CHILDREN;
    //  TVInsertStruct.item.hItem = NULL;
    //  TVInsertStruct.item.state = 0;
    //  TVInsertStruct.item.stateMask = 0;
    TVInsertStruct.item.pszText = (LPTSTR) lpText;
    //  TVInsertStruct.item.cchTextMax = lstrlen(lpText);
    TVInsertStruct.item.iImage = IMAGEINDEX(IDI_FOLDER);
    TVInsertStruct.item.iSelectedImage = IMAGEINDEX(IDI_FOLDEROPEN);
    TVInsertStruct.item.cChildren = fHasKids;
    TVInsertStruct.item.lParam = lParam;

    return TreeView_InsertItem(hKeyTreeWnd, &TVInsertStruct);

}

/*******************************************************************************
*
*  KeyTree_ExpandBranch
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hTreeViewWnd, handle of KeyTree window.
*     hTreeItem, handle of tree item to edit.
*
*******************************************************************************/

BOOL
PASCAL
KeyTree_ExpandBranch(
    HWND hKeyTreeWnd,
    HTREEITEM hExpandingTreeItem
    )
{

    TCHAR KeyName[MAXKEYNAME];
    HKEY hRootKey;
    HKEY hEnumKey;
    int Index;
    int MaximumSubKeyLength;

    //
    //  Nothing special needs to be done with a top-level label such as "My
    //  Computer" or a network computer name.  It's children are already filled
    //  in and are always valid.
    //

    if (TreeView_GetParent(hKeyTreeWnd, hExpandingTreeItem) == NULL)
        return TRUE;

    hRootKey = KeyTree_BuildKeyPath( hKeyTreeWnd, 
                                        hExpandingTreeItem,
                                        KeyName, 
                                        ARRAYSIZE(KeyName),
                                        FALSE);

    if(RegOpenKeyEx(hRootKey,KeyName,0,KEY_ENUMERATE_SUB_KEYS,&hEnumKey) != ERROR_SUCCESS)
        return FALSE;

    MaximumSubKeyLength = MAXKEYNAME - (lstrlen(KeyName) + 1);
    Index = 0;

    while (RegEnumKey(hEnumKey, Index++, KeyName, MaximumSubKeyLength) ==
        ERROR_SUCCESS) {

        KeyTree_InsertItem(hKeyTreeWnd, hExpandingTreeItem, TVI_FIRST,
            KeyName, DoesKeyHaveKids(hEnumKey, KeyName), 0);

    }

    RegCloseKey(hEnumKey);

    //
    //  Sort the subkeys _after_ inserting all the items.  The above insert
    //  used to specify TVI_SORT, but on NT, expanding a key with several
    //  subkeys (e.g., HKEY_CLASSES_ROOT) would take several seconds!
    //

    TreeView_SortChildren(hKeyTreeWnd, hExpandingTreeItem, FALSE);


    return TRUE;

}

/*******************************************************************************
*
*  DoesKeyHaveKids
*
*  DESCRIPTION:
*     Checks if the given key path has any subkeys or not.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
PASCAL
DoesKeyHaveKids(
    HKEY hKey,
    LPTSTR lpKeyName
    )
{

    BOOL fHasKids;
    HKEY hCheckChildrenKey;
    DWORD cSubKeys;

    fHasKids = FALSE;

    if ( RegOpenKeyEx(hKey, lpKeyName, 0, KEY_QUERY_VALUE|KEY_ENUMERATE_SUB_KEYS, &hCheckChildrenKey) 
                        == ERROR_SUCCESS ) 
    {
        if (RegQueryInfoKey(hCheckChildrenKey, NULL, NULL, NULL, &cSubKeys,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL) == ERROR_SUCCESS &&
            cSubKeys > 0)
            fHasKids = TRUE;

        RegCloseKey(hCheckChildrenKey);
    }

    return fHasKids;

}

/*******************************************************************************
*
*  KeyTree_EditLabel
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hTreeViewWnd, handle of KeyTree window.
*     hTreeItem, handle of tree item to edit.
*
*******************************************************************************/

VOID
PASCAL
KeyTree_EditLabel(
    HWND hKeyTreeWnd,
    HTREEITEM hTreeItem
    )
{

    g_RegEditData.fAllowLabelEdits = TRUE;

    TreeView_EditLabel(hKeyTreeWnd, hTreeItem);

    g_RegEditData.fAllowLabelEdits = FALSE;

}

/*******************************************************************************
*
*  KeyTree_CanDeleteOrRenameItem
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hTreeViewWnd, handle of KeyTree window.
*     hTreeItem, handle of tree item to check.
*
*******************************************************************************/

BOOL
PASCAL
KeyTree_CanDeleteOrRenameItem(
    HWND hWnd,
    HTREEITEM hTreeItem
    )
{

    TV_ITEM TVItem;

    //
    //  Check if the selected tree item is null.  This will occur when viewing
    //  the Edit popup from the main menu with no selection made.
    //

    if (hTreeItem != NULL) {

        //
        //  Check if this tree item has any reference data indicating that it
        //  is a predefined root.  Predefined roots cannot be renamed or
        //  deleted.
        //

        TVItem.hItem = hTreeItem;
        TVItem.mask = TVIF_PARAM;
        TreeView_GetItem(hWnd, &TVItem);

        if ((HKEY) TVItem.lParam == NULL) {

            //
            //  Check that this isn't a top-level item such as "My Computer" or
            //  a remote registry connection.
            //

            if (TreeView_GetParent(hWnd, hTreeItem) != NULL)
                return TRUE;

        }

    }

    return FALSE;

}


//------------------------------------------------------------------------------
//  KeyTree_GetRootKey
//
//  DESCRIPTION: Returns the root key of the item (HKEY_ ...)
//
//  PARAMETERS:  hTreeItem - treeview item
//------------------------------------------------------------------------------
HKEY KeyTree_GetRootKey(HTREEITEM hTreeItem)
{
    TV_ITEM TVItem;
    TVItem.mask = TVIF_PARAM;
    TVItem.hItem = hTreeItem;

    TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);

    while (!TVItem.lParam)
    {
        TVItem.hItem = TreeView_GetParent(g_RegEditData.hKeyTreeWnd, TVItem.hItem);
        TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);
    }

    return ((HKEY) TVItem.lParam);
}


//------------------------------------------------------------------------------
//  KeyTree_GetKeyName
//
//  DESCRIPTION: Returns the TEXT of an item
//
//  PARAMETERS:  hTreeItem - treeview item
//               pszText - pointer to an TCHAR array
//               cchMax - number of characters in the array
//------------------------------------------------------------------------------
PTSTR KeyTree_GetKeyName(HTREEITEM hTreeItem, PTSTR pszName, int cchNameMax)
{
    TV_ITEM TVItem;

    pszName[0] = TEXT('\0');

    TVItem.mask = TVIF_TEXT;
    TVItem.hItem = hTreeItem;
    TVItem.pszText = pszName;
    TVItem.cchTextMax = cchNameMax;

    TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);

    return TVItem.pszText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regkey.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGKEY.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  KeyTreeWnd TreeView routines for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGKEY
#define _INC_REGKEY

VOID
PASCAL
RegEdit_OnNewKey(
    HWND hWnd,
    HTREEITEM hTreeItem
    );

BOOL RegEdit_GetTemporaryKeyName(HWND hWnd, PTSTR pszKeyName, DWORD cchKeyNameMax, HKEY hKey);

LRESULT
PASCAL
RegEdit_OnKeyTreeItemExpanding(
    HWND hWnd,
    LPNM_TREEVIEW lpNMTreeView
    );

VOID
PASCAL
RegEdit_OnKeyTreeSelChanged(
    HWND hWnd,
    LPNM_TREEVIEW lpNMTreeView
    );

VOID
PASCAL
RegEdit_OnSelChangedTimer(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_KeyTreeSelChanged(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_OnKeyTreeBeginDrag(
    HWND hWnd,
    NM_TREEVIEW FAR* lpNMTreeView
    );

BOOL
PASCAL
RegEdit_OnKeyTreeBeginLabelEdit(
    HWND hWnd,
    TV_DISPINFO FAR* lpTVDispInfo
    );

BOOL
PASCAL
RegEdit_OnKeyTreeEndLabelEdit(
    HWND hWnd,
    TV_DISPINFO FAR* lpTVDispInfo
    );

VOID
PASCAL
RegEdit_OnKeyTreeCommand(
    HWND hWnd,
    int MenuCommand,
    HTREEITEM hTreeItem
    );

VOID
PASCAL
RegEdit_OnKeyTreeContextMenu(
    HWND hWnd,
    BOOL fByAccelerator
    );

VOID
PASCAL
RegEdit_SetKeyTreeEditMenuItems(
    HMENU hPopupMenu,
    HTREEITEM hSelectedTreeItem
    );

VOID
PASCAL
RegEdit_OnKeyTreeRefresh(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_OnKeyTreeDisconnect(
    HWND hWnd,
    HTREEITEM hTreeItem
    );

VOID
PASCAL
RegEdit_UpdateStatusBar(
    VOID
    );

VOID
PASCAL
RegEdit_OnCopyKeyName(
    HWND hWnd,
    HTREEITEM hTreeItem
    );

#define BKP_TOSUBKEY                    0x0000
#define BKP_TOSYMBOLICROOT              0x0001
#define BKP_TOCOMPUTER                  (0x0002 | BKP_TOSYMBOLICROOT)

HKEY
PASCAL
KeyTree_BuildKeyPath(
    HWND hTreeViewWnd,
    HTREEITEM hTreeItem,
    LPTSTR lpKeyPath,
    DWORD cchKeyPathMax,
    UINT ToFlags
    );

BOOL
PASCAL
KeyTree_ExpandBranch(
    HWND hKeyTreeWnd,
    HTREEITEM hExpandingTreeItem
    );

HKEY  KeyTree_GetRootKey(HTREEITEM hTreeItem);
PTSTR KeyTree_GetKeyName(HTREEITEM hTreeItem, PTSTR pszName, int cchNameMax);

#endif // _INC_REGKEY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regmain.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGMAIN.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*******************************************************************************/

#include "pch.h"
#include <regstr.h>
#include "regedit.h"
#include "regfile.h"
#include "regbined.h"
#include "regresid.h"

//  Instance handle of this application.
HINSTANCE g_hInstance;

//  TRUE if accelerator table should not be used, such as during a rename
//  operation.
BOOL g_fDisableAccelerators = FALSE;

TCHAR g_KeyNameBuffer[MAXKEYNAME];
TCHAR g_ValueNameBuffer[MAXVALUENAME_LENGTH];

COLORREF g_clrWindow;
COLORREF g_clrWindowText;
COLORREF g_clrHighlight;
COLORREF g_clrHighlightText;

HWND g_hRegEditWnd;

PTSTR g_pHelpFileName;

TCHAR g_NullString[] = TEXT("");

#define PARSERET_CONTINUE               0
#define PARSERET_REFRESH                1
#define PARSERET_EXIT                   2

UINT
PASCAL
ParseCommandLine(
    VOID
    );

BOOL
PASCAL
IsRegistryToolDisabled(
    VOID
    );

int
PASCAL
ModuleEntry(
    VOID
    )
{

    HWND hPopupWnd;
    HACCEL hRegEditAccel;
    MSG Msg;
    USHORT wLanguageId = LANGIDFROMLCID(GetThreadLocale());
    INITCOMMONCONTROLSEX icce;

    g_hInstance = GetModuleHandle(NULL);

    icce.dwSize = sizeof(icce);
    // DebugAssert(icce.dwSize == sizeof(INITCOMMONCONTROLSEX));
    icce.dwICC = ICC_ALL_CLASSES;
    InitCommonControlsEx(&icce);

    g_hRegEditWnd = FindWindow(g_RegEditClassName, NULL);

    //
    //  To prevent users from corrupting their registries,
    //  administrators can set a policy switch to prevent editing.  Check that
    //  switch now.
    //

    if (IsRegistryToolDisabled()) 
    {
        InternalMessageBox(g_hInstance, NULL, MAKEINTRESOURCE(IDS_REGEDITDISABLED),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONERROR | MB_OK);

        goto ModuleExit;
    }

    //
    //  Check if we were given a commandline and handle if appropriate.
    //

    switch (ParseCommandLine()) {

        case PARSERET_REFRESH:
            if (g_hRegEditWnd != NULL)
                PostMessage(g_hRegEditWnd, WM_COMMAND, ID_REFRESH, 0);
            //  FALL THROUGH

        case PARSERET_EXIT:
            goto ModuleExit;

    }

    //
    //  Allow only one instance of the Registry Editor.
    //

    if (g_hRegEditWnd != NULL) {

        if (IsIconic(g_hRegEditWnd))
            ShowWindow(g_hRegEditWnd, SW_RESTORE);

        else {

            BringWindowToTop(g_hRegEditWnd);

            if ((hPopupWnd = GetLastActivePopup(g_hRegEditWnd)) != g_hRegEditWnd)
                BringWindowToTop(hPopupWnd);

            SetForegroundWindow(hPopupWnd);

        }

        goto ModuleExit;

    }

    //
    //  Initialize and create an instance of the Registry Editor window.
    //

    if ((g_pHelpFileName = LoadDynamicString(IDS_HELPFILENAME)) == NULL)
        goto ModuleExit;

    if (!RegisterRegEditClass() || !RegisterHexEditClass())
        goto ModuleExit;

    if ((hRegEditAccel = LoadAccelerators(g_hInstance,
        MAKEINTRESOURCE(IDACCEL_REGEDIT))) == NULL)
        goto ModuleExit;

    if ((g_hRegEditWnd = CreateRegEditWnd()) != NULL) {

        while (GetMessage(&Msg, NULL, 0, 0)) {

            if (g_fDisableAccelerators || !TranslateAccelerator(g_hRegEditWnd,
                hRegEditAccel, &Msg)) {

                TranslateMessage(&Msg);
                DispatchMessage(&Msg);

            }

        }

    }

ModuleExit:
    ExitProcess(0);

    return 0;

}

/*******************************************************************************
*
*  ParseCommandline
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     (returns), TRUE to continuing loading, else FALSE to stop immediately.
*
*******************************************************************************/

UINT
PASCAL
ParseCommandLine(
    VOID
    )
{

    BOOL fSilentMode;
    BOOL fExportMode;
    LPTSTR lpCmdLine;
    LPTSTR lpFileName;
    LPTSTR lpSelectedPath;

    fSilentMode = FALSE;
    fExportMode = FALSE;

    lpCmdLine = GetCommandLine();

    //
    //  Skip past the application pathname.  Be sure to handle long filenames
    //  correctly.
    //

    if (*lpCmdLine == TEXT('\"')) {

        do
            lpCmdLine = CharNext(lpCmdLine);
        while (*lpCmdLine != 0 && *lpCmdLine != TEXT('\"'));

        if (*lpCmdLine == TEXT('\"'))
            lpCmdLine = CharNext(lpCmdLine);

    }

    else {

        while (*lpCmdLine > TEXT(' '))
            lpCmdLine = CharNext(lpCmdLine);

    }

    while (*lpCmdLine != 0 && *lpCmdLine <= TEXT(' '))
        lpCmdLine = CharNext(lpCmdLine);

    while (TRUE) {

        while (*lpCmdLine == TEXT(' '))
            lpCmdLine = CharNext(lpCmdLine);

        if (*lpCmdLine != TEXT('/') && *lpCmdLine != TEXT('-'))
            break;

        lpCmdLine = CharNext(lpCmdLine);

        while (*lpCmdLine != 0 && *lpCmdLine != TEXT(' ')) {

            switch (*lpCmdLine) {

                case TEXT('m'):
                case TEXT('M'):
                    //
                    //  Allow multiple instances mode.  Pretend we are the only
                    //  copy of regedit running.
                    //
                    g_hRegEditWnd = NULL;
                    break;

                    //
                    //  Specifies the location of the SYSTEM.DAT and USER.DAT
                    //  files in real-mode.  We don't use these switches, but
                    //  we do need to bump past the filename.
                    //
                case TEXT('l'):
                case TEXT('L'):
                case TEXT('r'):
                case TEXT('R'):
                    return PARSERET_EXIT;

                case TEXT('e'):
                case TEXT('E'):
                    fExportMode = TRUE;
                    break;

                case TEXT('a'):
                case TEXT('A'):
                    fExportMode = TRUE;
                    g_RegEditData.uExportFormat = FILE_TYPE_REGEDIT4;
                    break;

                case TEXT('s'):
                case TEXT('S'):
                    //
                    //  Silent mode where we don't show any dialogs when we
                    //  import a registry file script.
                    //
                    fSilentMode = TRUE;
                    break;

                case TEXT('v'):
                case TEXT('V'):
                    //
                    //  With the Windows 3.1 Registry Editor, this brought up
                    //  the tree-style view.  Now we always show the tree so
                    //  nothing to do here!
                    //
                    //  FALL THROUGH

                case TEXT('u'):
                case TEXT('U'):
                    //
                    //  Update, don't overwrite existing path entries in
                    //  shell\open\command or shell\open\print.  This isn't even
                    //  used by the Windows 3.1 Registry Editor!
                    //
                    //  FALL THROUGH

                default:
                    break;

            }

            lpCmdLine = CharNext(lpCmdLine);

        }

    }

    if (!fExportMode) {

        if (*lpCmdLine == 0)
            return PARSERET_CONTINUE;

        else {

            lpFileName = GetNextSubstring(lpCmdLine);

            while (lpFileName != NULL) {

                RegEdit_ImportRegFile(NULL, fSilentMode, lpFileName, NULL);
                lpFileName = GetNextSubstring(NULL);

            }

            return PARSERET_REFRESH;

        }

    }
    else 
    {
        lpFileName = GetNextSubstring(lpCmdLine);
        lpSelectedPath = GetNextSubstring(NULL);

        if (GetNextSubstring(NULL) == NULL)
            RegEdit_ExportRegFile(NULL, fSilentMode, lpFileName, lpSelectedPath);

        return PARSERET_EXIT;
    }

}

/*******************************************************************************
*
*  IsRegistryToolDisabled
*
*  DESCRIPTION:
*     Checks the policy section of the registry to see if registry editing
*     tools should be disabled.  This switch is set by administrators to
*     protect novice users.
*
*     The Registry Editor is disabled if and only if this value exists and is
*     set.
*
*  PARAMETERS:
*     (returns), TRUE if registry tool should not be run, else FALSE.
*
*******************************************************************************/

BOOL
PASCAL
IsRegistryToolDisabled(
    VOID
    )
{

    BOOL fRegistryToolDisabled;
    HKEY hKey;
    DWORD Type;
    DWORD ValueBuffer;
    DWORD cbValueBuffer;

    fRegistryToolDisabled = FALSE;

    if ( RegOpenKey( HKEY_CURRENT_USER,
                        REGSTR_PATH_POLICIES TEXT("\\") REGSTR_KEY_SYSTEM,
                        &hKey) 
            == ERROR_SUCCESS ) 
    {

        cbValueBuffer = sizeof(DWORD);

        if (RegEdit_QueryValueEx(hKey, REGSTR_VAL_DISABLEREGTOOLS, NULL, &Type,
            (LPSTR) &ValueBuffer, &cbValueBuffer) == ERROR_SUCCESS) 
        {

            if ( (Type == REG_DWORD) && 
                    (cbValueBuffer == sizeof(DWORD)) &&
                    (ValueBuffer != FALSE) )
            {
                fRegistryToolDisabled = TRUE;
            }
        }

        RegCloseKey(hKey);

    }

    return fRegistryToolDisabled;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regnet.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGNET.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        03 May 1994
*
*  Remote registry support for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  03 May 1994 TCS Moved existing connection code from REGEDIT.C.
*
*******************************************************************************/

#ifndef _INC_REGNET
#define _INC_REGNET

VOID
PASCAL
RegEdit_OnCommandConnect(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_OnCommandDisconnect(
    HWND hWnd
    );

#endif // _INC_REGNET
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regmisc.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGMISC.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Miscellaneous routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGMISC
#define _INC_REGMISC

PTSTR
CDECL
LoadDynamicString(
    UINT StringID,
    ...
    );

//  Wrapper for LocalFree to make the code a little easier to read.
#define DeleteDynamicString(x)          LocalFree((HLOCAL) (x))

BOOL
PASCAL
CopyRegistry(
    HKEY hSourceKey,
    HKEY hDestinationKey
    );

HBRUSH
PASCAL
CreateDitheredBrush(
    VOID
    );

VOID
PASCAL
SendChildrenMessage(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
PASCAL
MessagePump(
    HWND hDialogWnd
    );

LPTSTR
PASCAL
GetNextSubstring(
    LPTSTR lpString
    );

int
PASCAL
InternalMessageBox(
    HINSTANCE hInst,
    HWND hWnd,
    LPCTSTR pszFormat,
    LPCTSTR pszTitle,
    UINT fuStyle,
    ...
    );

//  The Windows 95 and Windows NT implementations of RegDeleteKey differ in how
//  they handle subkeys of the specified key to delete.  Windows 95 will delete
//  them, but NT won't, so we hide the differences using this macro.
#ifdef WINNT
LONG
RegDeleteKeyRecursive(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey
    );
#else
#define RegDeleteKeyRecursive(hkey, lpsz)   RegDeleteKey(hkey, lpsz)
#endif

#define IsRegStringType(x)  (((x) == REG_SZ) || ((x) == REG_EXPAND_SZ) || ((x) == REG_MULTI_SZ))

#define ExtraAllocLen(Type) (IsRegStringType((Type)) ? sizeof(TCHAR) : 0)

LONG RegEdit_QueryValueEx(
  HKEY hKey,            // handle to key
  LPCTSTR lpValueName,  // value name
  LPDWORD lpReserved,   // reserved
  LPDWORD lpType,       // type buffer
  LPBYTE lpData,        // data buffer
  LPDWORD lpcbData      // size of data buffer
);

#endif // _INC_REGMISC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regnet.c ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGNET.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        03 May 1994
*
*  Remote registry support for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"
#include "regkey.h"
#include "regresid.h"
#include <shlobj.h>
#include "reghelp.h"

extern HRESULT SelectComputer(HWND hWnd, LPTSTR pszRemoteName, int cchMax);

const DWORD s_RegConnectHelpIDs[] = {
    IDC_REMOTENAME, IDH_REGEDIT_CONNECT,
    IDC_BROWSE,     IDH_REGEDIT_CONNECT_BROWSE,
    0, 0
};

const DWORD s_RegDisconnectHelpIDs[] = {
    IDC_REMOTELIST, IDH_REGEDIT_DISCONNECT,
    0, 0
};

INT_PTR
PASCAL
RegConnectDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
PASCAL
RegConnect_OnCommandBrowse(
    HWND hWnd
    );

INT_PTR
PASCAL
RegDisconnectDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
PASCAL
RegDisconnect_OnInitDialog(
    HWND hWnd
    );

VOID
PASCAL
RegDisconnect_OnCommandOk(
    HWND hWnd
    );

/*******************************************************************************
*
*  RegEdit_OnCommandConnect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCommandConnect(HWND hWnd)
{
    
    UINT ErrorStringID;
    TCHAR RemoteName[MAX_PATH];
    LPTSTR lpUnslashedRemoteName;
    TCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cbComputerName;
    TV_ITEM TVItem;
    HTREEITEM hPrevTreeItem;
    TCHAR ConnectedName[MAX_PATH];
    int CompareResult;
    HKEY hLocalMachineKey;
    HWND hKeyTreeWnd;
    TV_INSERTSTRUCT TVInsertStruct;
    UINT Index;
    TCHAR CheckChildrenKeyName[MAXKEYNAME];
    
    //
    //  Query the user for the name of the remote computer to connect to.
    //

    if (SUCCEEDED(SelectComputer(hWnd, (LPTSTR)RemoteName, ARRAYSIZE(RemoteName))))
    {
        RegEdit_SetWaitCursor(TRUE);
        
        //
        //
        //
        
        lpUnslashedRemoteName = (RemoteName[0] == TEXT('\\') &&
            RemoteName[1] == TEXT('\\')) ? &RemoteName[2] : &RemoteName[0];
        
        CharLower(lpUnslashedRemoteName);
        CharUpperBuff(lpUnslashedRemoteName, 1);
        
        //
        //  Check if the user is trying to connect to the local computer and prevent
        //  this.
        //
        
        cbComputerName = ARRAYSIZE(ComputerName);
        
        if (GetComputerName(ComputerName, &cbComputerName)) {
            
            if (lstrcmpi(lpUnslashedRemoteName, ComputerName) == 0) {
                
                ErrorStringID = IDS_CONNECTNOTLOCAL;
                goto error_ShowDialog;
                
            }
            
        }
        
        //
        //  Check if the user is trying to connect to an already existing registry
        //  connection and prevent this.
        //
        
        hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
        
        TVItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_HANDLE;
        TVItem.hItem = TreeView_GetRoot(hKeyTreeWnd);
        TVItem.pszText = ConnectedName;
        TVItem.cchTextMax = ARRAYSIZE(ConnectedName);
        
        while (TRUE) 
        {    
            hPrevTreeItem = TVItem.hItem;
            TVItem.hItem = TreeView_GetNextSibling(hKeyTreeWnd, TVItem.hItem);
            
            if (TVItem.hItem == NULL)
                break;
            
            TreeView_GetItem(hKeyTreeWnd, &TVItem);
            
            CompareResult = lstrcmpi(lpUnslashedRemoteName, ConnectedName);
            
            if (CompareResult == 0) {
                
                //
                //  We're already connected to this machine.  Set the focus to the
                //  connection so the user can see where it is.
                //
                
                TreeView_SelectItem(hKeyTreeWnd, TVItem.hItem);
                return;
                
            }
            
            else if (CompareResult < 0)
                break;
            
        }
        
        //
        //  Attempt to connect to the HKEY_LOCAL_MACHINE of the remote computer.
        //  If this fails, assume that the computer doesn't exist or doesn't have
        //  the registry server running.
        //
        
        switch (RegConnectRegistry(RemoteName, HKEY_LOCAL_MACHINE,
            &hLocalMachineKey)) {
            
        case ERROR_SUCCESS:
            break;
            
        case ERROR_ACCESS_DENIED:
            ErrorStringID = IDS_CONNECTACCESSDENIED;
            goto error_ShowDialog;
            
        default:
            ErrorStringID = IDS_CONNECTBADNAME;
            goto error_ShowDialog;
            
        }
        
        //
        //  The connection to HKEY_LOCAL_MACHINE was successful, so add a tree item
        //  for the remote computer and all of its predefined roots.
        //
        
        hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;
        ErrorStringID = 0;
        
        TVInsertStruct.hParent = TVI_ROOT;
        TVInsertStruct.hInsertAfter = hPrevTreeItem;
        TVInsertStruct.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE |
            TVIF_PARAM | TVIF_CHILDREN;
        TVInsertStruct.item.iImage = IMAGEINDEX(IDI_REMOTE);
        TVInsertStruct.item.iSelectedImage = IMAGEINDEX(IDI_REMOTE);
        TVInsertStruct.item.cChildren = TRUE;
        TVInsertStruct.item.lParam = 0;
        
        TVInsertStruct.item.pszText = lpUnslashedRemoteName;
        TVInsertStruct.hParent = TreeView_InsertItem(hKeyTreeWnd, &TVInsertStruct);
        
        TVInsertStruct.item.iImage = IMAGEINDEX(IDI_FOLDER);
        TVInsertStruct.item.iSelectedImage = IMAGEINDEX(IDI_FOLDEROPEN);
        
        for (Index = 0; Index < NUMBER_REGISTRY_ROOTS; Index++) {
            
            TVInsertStruct.item.pszText = g_RegistryRoots[Index].lpKeyName;
            
            //There is no way to determine the current user remotely
            //We would end up mapping the default user to current user
            //so let's just not show this key remotely
            if ((Index == INDEX_HKEY_CURRENT_USER) || (Index == INDEX_HKEY_CLASSES_ROOT))
                continue;
            
            if (Index == INDEX_HKEY_LOCAL_MACHINE)
                TVInsertStruct.item.lParam = (LPARAM) hLocalMachineKey;
            
            else {
                
#ifdef WINNT
                if((Index == INDEX_HKEY_DYN_DATA) || (Index == INDEX_HKEY_CURRENT_CONFIG)) {
                    continue;
                }
#endif
                
                if (RegConnectRegistry(RemoteName, g_RegistryRoots[Index].hKey,
                    (PHKEY) &TVInsertStruct.item.lParam) != ERROR_SUCCESS) {
                    
                    ErrorStringID = IDS_CONNECTROOTFAILED;
                    continue;
                    
                }
                
            }
            
            TVInsertStruct.item.cChildren =
                (RegEnumKey((HKEY) TVInsertStruct.item.lParam, 0,
                CheckChildrenKeyName, ARRAYSIZE(CheckChildrenKeyName)) ==
                ERROR_SUCCESS);
            
            TreeView_InsertItem(hKeyTreeWnd, &TVInsertStruct);
            
        }
        
        TreeView_Expand(hKeyTreeWnd, TVInsertStruct.hParent, TVE_EXPAND);
        TreeView_EnsureVisible(hKeyTreeWnd, TVInsertStruct.hParent);
        
        RegEdit_SetWaitCursor(FALSE);
        
        TreeView_SelectItem(hKeyTreeWnd, TVInsertStruct.hParent);
        SetFocus(hKeyTreeWnd);
        
        if (ErrorStringID != 0) {
            
error_ShowDialog:
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
            MAKEINTRESOURCE(IDS_CONNECTERRORTITLE), MB_ICONERROR | MB_OK,
            RemoteName);
        
        }
    }
}

/*******************************************************************************
*
*  RegConnectDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
PASCAL
RegConnectDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    LPTSTR lpRemoteName;

    switch (Message) {

        case WM_INITDIALOG:
            SetWindowLongPtr(hWnd, DWLP_USER, (LONG) lParam);
            SendDlgItemMessage(hWnd, IDC_REMOTENAME, EM_SETLIMITTEXT,
                MAX_PATH, 0);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDC_REMOTENAME:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                        EnableWindow(GetDlgItem(hWnd, IDOK),
                            SendMessage(GET_WM_COMMAND_HWND(wParam, lParam),
                            WM_GETTEXTLENGTH, 0, 0) != 0);
                    break;

                case IDC_BROWSE:
                    RegConnect_OnCommandBrowse(hWnd);
                    break;

                case IDOK:
                    lpRemoteName = (LPTSTR) GetWindowLongPtr(hWnd, DWLP_USER);
                    GetDlgItemText(hWnd, IDC_REMOTENAME, lpRemoteName,
                        MAX_PATH);
                    //  FALL THROUGH

                case IDCANCEL:
                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

            }
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) s_RegConnectHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
                (ULONG_PTR) s_RegConnectHelpIDs);
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  RegConnect_OnCommandBrowse
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegConnect_OnCommandBrowse(
    HWND hWnd
    )
{

    BROWSEINFO BrowseInfo;
    LPITEMIDLIST pidlComputer;
    TCHAR RemoteName[MAX_PATH];

    BrowseInfo.hwndOwner = hWnd;
    BrowseInfo.pidlRoot = (LPITEMIDLIST) MAKEINTRESOURCE(CSIDL_NETWORK);
    BrowseInfo.pszDisplayName = RemoteName;
    BrowseInfo.lpszTitle = LoadDynamicString(IDS_COMPUTERBROWSETITLE);
    BrowseInfo.ulFlags = BIF_BROWSEFORCOMPUTER;
    BrowseInfo.lpfn = NULL;

    if ((pidlComputer = SHBrowseForFolder(&BrowseInfo)) != NULL) 
    {

        SHFree(pidlComputer);

        SetDlgItemText(hWnd, IDC_REMOTENAME, RemoteName);
        EnableWindow(GetDlgItem(hWnd, IDOK), TRUE);

    }

    DeleteDynamicString(BrowseInfo.lpszTitle);

}

/*******************************************************************************
*
*  RegEdit_OnCommandDisconnect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCommandDisconnect(
    HWND hWnd
    )
{

    DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_REGDISCONNECT), hWnd,
        RegDisconnectDlgProc);

}

/*******************************************************************************
*
*  RegDisconnectDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
PASCAL
RegDisconnectDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    switch (Message) {

        case WM_INITDIALOG:
            return RegDisconnect_OnInitDialog(hWnd);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDOK:
                    RegDisconnect_OnCommandOk(hWnd);
                    //  FALL THROUGH

                case IDCANCEL:
                    EndDialog(hWnd, 0);
                    break;

            }
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) s_RegDisconnectHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
                (ULONG_PTR) s_RegDisconnectHelpIDs);
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  RegDisconnect_OnInitDialog
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd,
*     hFocusWnd,
*     lParam,
*
*******************************************************************************/

INT_PTR
PASCAL
RegDisconnect_OnInitDialog(
    HWND hWnd
    )
{

    HWND hRemoteListWnd;
    RECT ClientRect;
    LV_COLUMN LVColumn;
    LV_ITEM LVItem;
    TCHAR RemoteName[MAX_PATH];
    HWND hKeyTreeWnd;
    TV_ITEM TVItem;

    hRemoteListWnd = GetDlgItem(hWnd, IDC_REMOTELIST);

    //
    //  Initialize the ListView control.
    //

    ListView_SetImageList(hRemoteListWnd, g_RegEditData.hImageList,
        LVSIL_SMALL);

    LVColumn.mask = LVCF_FMT | LVCF_WIDTH;
    LVColumn.fmt = LVCFMT_LEFT;

    GetClientRect(hRemoteListWnd, &ClientRect);
    LVColumn.cx = ClientRect.right - GetSystemMetrics(SM_CXVSCROLL) -
        2 * GetSystemMetrics(SM_CXEDGE);

    ListView_InsertColumn(hRemoteListWnd, 0, &LVColumn);

    //
    //  Walk through each remote connection listed in the KeyTree and add it
    //  to our RemoteList.
    //

    LVItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    LVItem.pszText = RemoteName;
    LVItem.iItem = 0;
    LVItem.iSubItem = 0;
    LVItem.iImage = IMAGEINDEX(IDI_REMOTE);

    hKeyTreeWnd = g_RegEditData.hKeyTreeWnd;

    TVItem.mask = TVIF_TEXT;
    TVItem.hItem = TreeView_GetNextSibling(hKeyTreeWnd,
        TreeView_GetRoot(hKeyTreeWnd));
    TVItem.pszText = RemoteName;
    TVItem.cchTextMax = ARRAYSIZE(RemoteName);

    do 
    {
        LVItem.lParam = (LPARAM) TVItem.hItem;
        TreeView_GetItem(hKeyTreeWnd, &TVItem);
        ListView_InsertItem(hRemoteListWnd, &LVItem);

        LVItem.iItem++;
    }
    while ((TVItem.hItem = TreeView_GetNextSibling(hKeyTreeWnd, TVItem.hItem)) != NULL);

    ListView_SetItemState(hRemoteListWnd, 0, LVIS_FOCUSED, LVIS_FOCUSED);

    return TRUE;

}

/*******************************************************************************
*
*  RegDisconnect_OnCommandOk
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd,
*     hFocusWnd,
*     lParam,
*
*******************************************************************************/

VOID
PASCAL
RegDisconnect_OnCommandOk(
    HWND hWnd
    )
{

    LV_ITEM LVItem;
    HWND hRemoteListWnd;

    //
    //  Walk through each selected item in the ListView and disconnect the
    //  computer.
    //

    LVItem.mask = LVIF_PARAM;
    LVItem.iItem = -1;
    LVItem.iSubItem = 0;

    hRemoteListWnd = GetDlgItem(hWnd, IDC_REMOTELIST);

    while ((LVItem.iItem = ListView_GetNextItem(hRemoteListWnd, LVItem.iItem,
        LVNI_SELECTED)) != -1) {

        ListView_GetItem(hRemoteListWnd, &LVItem);
        RegEdit_OnKeyTreeDisconnect(hWnd, (HTREEITEM) LVItem.lParam);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regmisc.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-2000
*
*  TITLE:       REGMISC.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  Miscellaneous routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  21 Nov 1993 TCS Original implementation.
*  06 Apr 1994 TCS Moved EditRegistryKey to REGPORTE.C because it needs to
*                  be available for the real-mode registry tool, too.
*
*******************************************************************************/

#include "pch.h"

/*******************************************************************************
*
*  LoadDynamicString
*
*  DESCRIPTION:
*     Wrapper for the FormatMessage function that loads a string from our
*     resource table into a dynamically allocated buffer, optionally filling
*     it with the variable arguments passed.
*
*  PARAMETERS:
*     StringID, resource identifier of the string to use.
*     (optional), parameters to use to format the string message.
*     (returns), pointer to dynamically allocated string buffer.
*
*******************************************************************************/

PTSTR
CDECL
LoadDynamicString(
    UINT StringID,
    ...
    )
{

    TCHAR Buffer[256];
    PTSTR pStr;
    va_list Marker;

    va_start(Marker, StringID);

    LoadString(g_hInstance, StringID, Buffer, ARRAYSIZE(Buffer));

    if (0 == FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                    (LPVOID) (LPSTR) Buffer, 0, 0, (LPTSTR) (PTSTR FAR *) &pStr, 0, &Marker)) 
    {
        pStr = NULL;
    }

    va_end(Marker);


    return pStr;
}

/*******************************************************************************
*
*  CopyRegistry
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hSourceKey,
*     hDestinationKey,
*
*******************************************************************************/

BOOL
PASCAL
CopyRegistry(
    HKEY hSourceKey,
    HKEY hDestinationKey
    )
{

    BOOL  fSuccess = TRUE;
    DWORD EnumIndex;
    DWORD cchValueName;
    DWORD cbValueData;
    DWORD Type;
    HKEY  hSourceSubKey;
    HKEY  hDestinationSubKey;

    //
    //  Copy all of the value names and their data.
    //

    EnumIndex = 0;

    while (TRUE)
    {
        PBYTE pbValueData;
        cchValueName = ARRAYSIZE(g_ValueNameBuffer);

        // VALUE DATA
        // Query for data size
        if (RegEnumValue(hSourceKey, EnumIndex++, g_ValueNameBuffer,
            &cchValueName, NULL, &Type, NULL, &cbValueData) != ERROR_SUCCESS)
        {
            break;
        }

        // allocate memory for data
        pbValueData =  LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
        if (pbValueData)
        {
            if (RegEdit_QueryValueEx(hSourceKey, g_ValueNameBuffer,
                NULL, &Type, pbValueData, &cbValueData) == ERROR_SUCCESS)
            {
                RegSetValueEx(hDestinationKey, g_ValueNameBuffer, 0, Type,
                    pbValueData, cbValueData);
            }
            else
            {
                fSuccess = FALSE;
            }
            LocalFree(pbValueData);
        }
        else
        {
            fSuccess = FALSE;
        }
    }

    if (fSuccess)
    {
        //
        //  Copy all of the subkeys and recurse into them.
        //

        EnumIndex = 0;

        while (TRUE) {

            if (RegEnumKey(hSourceKey, EnumIndex++, g_KeyNameBuffer, MAXKEYNAME) !=
                ERROR_SUCCESS)
                break;

            if ( RegOpenKeyEx(hSourceKey, g_KeyNameBuffer, 0, KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE, &hSourceSubKey) 
                    == ERROR_SUCCESS ) 
            {

                if (RegCreateKey(hDestinationKey, g_KeyNameBuffer, &hDestinationSubKey) == ERROR_SUCCESS) 
                {
                
                    CopyRegistry(hSourceSubKey, hDestinationSubKey);

                    RegCloseKey(hDestinationSubKey);

                }

                RegCloseKey(hSourceSubKey);

            }

        }
    }

    return fSuccess;
}

/*******************************************************************************
*
*  CreateDitheredBrush
*
*  DESCRIPTION:
*     Creates a dithered brush which is made up of alternating black and white
*     pixels.
*
*  PARAMETERS:
*     (returns), handle of dithered brush.
*
*******************************************************************************/

HBRUSH
PASCAL
CreateDitheredBrush(
    VOID
    )
{

    WORD graybits[] = {0x5555, 0xAAAA, 0x5555, 0xAAAA, 0x5555, 0xAAAA, 0x5555,
        0xAAAA};
    HBRUSH hBrush;
    HBITMAP hBitmap;

    if ((hBitmap = CreateBitmap(8, 8, 1, 1, graybits)) != NULL) {

        hBrush = CreatePatternBrush(hBitmap);
        DeleteObject(hBitmap);

    }

    else
        hBrush = NULL;

    return hBrush;

}

/*******************************************************************************
*
*  SendChildrenMessage
*
*  DESCRIPTION:
*     Sends the given message to all children of the given parent window.
*
*  PARAMETERS:
*     hWnd, handle of parent window.
*     Message, message to send.
*     wParam, message dependent data.
*     lParam, message dependent data.
*
*******************************************************************************/

VOID
PASCAL
SendChildrenMessage(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    HWND hChildWnd;

    hChildWnd = GetWindow(hWnd, GW_CHILD);

    while (hChildWnd != NULL) {

        SendMessage(hChildWnd, Message, wParam, lParam);
        hChildWnd = GetWindow(hChildWnd, GW_HWNDNEXT);

    }

}

/*******************************************************************************
*
*  MessagePump
*
*  DESCRIPTION:
*     Processes the next queued message, if any.
*
*  PARAMETERS:
*     hDialogWnd, handle of modeless dialog.
*
*******************************************************************************/

BOOL
PASCAL
MessagePump(
    HWND hDialogWnd
    )
{

    MSG Msg;
    BOOL fGotMessage;

    if ((fGotMessage = PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE))) {

        if (!IsDialogMessage(hDialogWnd, &Msg)) {

            TranslateMessage(&Msg);
            DispatchMessage(&Msg);

        }

    }

    return fGotMessage;

}

/*******************************************************************************
*
*  GetNextSubstring
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

LPTSTR
PASCAL
GetNextSubstring(
    LPTSTR lpString
    )
{

    static LPTSTR lpLastString;
    TCHAR EndChar;
    LPTSTR lpReturnString;

    if (lpString == NULL)
        lpString = lpLastString;

    while (*lpString == TEXT(' '))
        lpString++;

    if (*lpString == 0)
        lpReturnString = NULL;

    else {

        if (*lpString == TEXT('\"')) {

            EndChar = TEXT('\"');
            lpString++;

        }

        else
            EndChar = TEXT(' ');

        lpReturnString = lpString;

        while (*lpString != EndChar && *lpString != 0)
            lpString = CharNext(lpString);

        if (*lpString == EndChar)
            *lpString++ = 0;

    }

    lpLastString = lpString;

    return lpReturnString;

}

/*******************************************************************************
*
*  InternalMessageBox
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/
int
PASCAL
InternalMessageBox(
    HINSTANCE hInst,
    HWND hWnd,
    LPCTSTR pszFormat,
    LPCTSTR pszTitle,
    UINT fuStyle,
    ...
    )
{
    TCHAR szTitle[80];
    TCHAR szFormat[512];
    LPTSTR pszMessage;
    BOOL fOk;
    int result;
    va_list ArgList;

    if (HIWORD(pszTitle))
    {
        // do nothing
    }
    else
    {
        // Allow this to be a resource ID
        LoadString(hInst, LOWORD(pszTitle), szTitle, ARRAYSIZE(szTitle));
        pszTitle = szTitle;
    }

    if (HIWORD(pszFormat))
    {
        // do nothing
    }
    else
    {
        // Allow this to be a resource ID
        LoadString(hInst, LOWORD(pszFormat), szFormat, ARRAYSIZE(szFormat));
        pszFormat = szFormat;
    }

    va_start(ArgList, fuStyle);
    fOk = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                        pszFormat, 0, 0, (LPTSTR)&pszMessage, 0, &ArgList);

    va_end(ArgList);

    if (fOk && pszMessage)
    {
        result = MessageBox(hWnd, pszMessage, pszTitle, fuStyle | MB_SETFOREGROUND);
        LocalFree(pszMessage);
    }
    else
    {
        return -1;
    }

    return result;
}

#ifdef WINNT
/*******************************************************************************
*
*  RegDeleteKeyRecursive
*
*  DESCRIPTION:
*     Adapted from \\kernel\razzle3,mvdm\wow32\wshell.c,WOWRegDeleteKey().
*     The Windows 95 implementation of RegDeleteKey recursively deletes all
*     the subkeys of the specified registry branch, but the NT implementation
*     only deletes leaf keys.
*
*  PARAMETERS:
*     (see below)
*
*******************************************************************************/

LONG
RegDeleteKeyRecursive(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey
    )

/*++

Routine Description:

    There is a significant difference between the Win3.1 and Win32
    behavior of RegDeleteKey when the key in question has subkeys.
    The Win32 API does not allow you to delete a key with subkeys,
    while the Win3.1 API deletes a key and all its subkeys.

    This routine is a recursive worker that enumerates the subkeys
    of a given key, applies itself to each one, then deletes itself.

    It specifically does not attempt to deal rationally with the
    case where the caller may not have access to some of the subkeys
    of the key to be deleted.  In this case, all the subkeys which
    the caller can delete will be deleted, but the api will still
    return ERROR_ACCESS_DENIED.

Arguments:

    hKey - Supplies a handle to an open registry key.

    lpszSubKey - Supplies the name of a subkey which is to be deleted
                 along with all of its subkeys.

Return Value:

    ERROR_SUCCESS - entire subtree successfully deleted.

    ERROR_ACCESS_DENIED - given subkey could not be deleted.

--*/

{
    DWORD i;
    HKEY Key;
    LONG Status;
    DWORD ClassLength=0;
    DWORD SubKeys;
    DWORD MaxSubKey;
    DWORD MaxClass;
    DWORD Values;
    DWORD MaxValueName;
    DWORD MaxValueData;
    DWORD SecurityLength;
    FILETIME LastWriteTime;
    LPTSTR NameBuffer;

    //
    // First open the given key so we can enumerate its subkeys
    //
    Status = RegOpenKeyEx(hKey,
                          lpszSubKey,
                          0,
                          KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                          &Key);
    if (Status != ERROR_SUCCESS) 
    {
        //
        // possibly we have delete access, but not enumerate/query.
        // So go ahead and try the delete call, but don't worry about
        // any subkeys.  If we have any, the delete will fail anyway.
        //
        return(RegDeleteKey(hKey,lpszSubKey));
    }

    //
    // Use RegQueryInfoKey to determine how big to allocate the buffer
    // for the subkey names.
    //
    Status = RegQueryInfoKey(Key,
                             NULL,
                             &ClassLength,
                             0,
                             &SubKeys,
                             &MaxSubKey,
                             &MaxClass,
                             &Values,
                             &MaxValueName,
                             &MaxValueData,
                             &SecurityLength,
                             &LastWriteTime);
    if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_MORE_DATA) &&
        (Status != ERROR_INSUFFICIENT_BUFFER)) {
        RegCloseKey(Key);
        return(Status);
    }

    NameBuffer = (LPTSTR) LocalAlloc(LPTR, (MaxSubKey + 1)*sizeof(TCHAR));
    if (NameBuffer == NULL) {
        RegCloseKey(Key);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate subkeys and apply ourselves to each one.
    //
    i=0;
    do {
        Status = RegEnumKey(Key,
                            i,
                            NameBuffer,
                            MaxSubKey+1);
        if (Status == ERROR_SUCCESS) {
        Status = RegDeleteKeyRecursive(Key,NameBuffer);
        }

        if (Status != ERROR_SUCCESS) {
            //
            // Failed to delete the key at the specified index.  Increment
            // the index and keep going.  We could probably bail out here,
            // since the api is going to fail, but we might as well keep
            // going and delete everything we can.
            //
            ++i;
        }

    } while ( (Status != ERROR_NO_MORE_ITEMS) &&
              (i < SubKeys) );

    LocalFree((HLOCAL) NameBuffer);
    RegCloseKey(Key);
    return(RegDeleteKey(hKey,lpszSubKey));

}
#endif


//--------------------------------------------------------------------------
//
//  RegEdit_QueryValueEx
//
//  wraps RegQueryValueEx and ensures that the returned string is NULL-
//  terminated
//
//--------------------------------------------------------------------------
LONG RegEdit_QueryValueEx(
  HKEY hKey,            // handle to key
  LPCTSTR lpValueName,  // value name
  LPDWORD lpReserved,   // reserved
  LPDWORD lpType,       // type buffer
  LPBYTE lpData,        // data buffer
  LPDWORD lpcbData      // size of data buffer
)
{
    LONG lRes = RegQueryValueEx(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
    if (lRes == ERROR_SUCCESS
        && lpType
        && IsRegStringType(*lpType)
        && lpcbData
        && lpData
        )
    {
        // All string local allocs have an extra space in them
        // for the NULL character

        LPTSTR psz = (LPTSTR)lpData;
        int cch = (int)(*lpcbData/sizeof(TCHAR));
        if (cch > 0)
        {
            // If the string is not NULL terminated, add the additional NULL
            if (psz[cch-1] != 0)
               psz[cch] = 0;
        }
        else if (cch == 0)
        {
            if (*lpcbData == 1)
            {
                // We have allocated one extra TCHAR (2 bytes) for the NULL character
                *((BYTE *)(lpData+1)) = 0;
                *((BYTE *)(lpData+2)) = 0;
                *((BYTE *)(lpData+3)) = 0;
            }
            else
            {
                // No character was copied, but the string was not NULL terminated
                psz[0] = 0;
            }
        }
    }
    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regporte.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-2000
*
*  TITLE:       REGPORTE.C
*
*  VERSION:     5.00
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  File import and export engine routines for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regresid.h"
#include "reg1632.h"
#include "regedit.h"
#include "regkey.h"
#include "regfile.h"
#include "regedit.h"
#include <malloc.h>

#include "regdebug.h"

//  Association between the ASCII name and the handle of the registry key.
const REGISTRY_ROOT g_RegistryRoots[] = {
    TEXT("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT, PREDEFINE_KEY_CLASSES_ROOT,
    TEXT("HKEY_CURRENT_USER"), HKEY_CURRENT_USER, PREDEFINE_KEY_CURRENT_USER,
    TEXT("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE, PREDEFINE_KEY_LOCAL_MACHINE,
    TEXT("HKEY_USERS"), HKEY_USERS, PREDEFINE_KEY_USERS,
    TEXT("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG, PREDEFINE_KEY_CURRENT_CONFIG,
    TEXT("HKEY_DYN_DATA"), HKEY_DYN_DATA, 0
};

const TCHAR s_RegistryHeader[] = TEXT("REGEDIT");

const TCHAR s_OldWin31RegFileRoot[] = TEXT(".classes");

const TCHAR s_Win40RegFileHeader[] = TEXT("REGEDIT4\n\n");

#ifdef UNICODE
//
// New header is required for version 5.0 because the version detection code
// in Win 4.0 regedit wasn't very good (See comments in ImportRegFile for
// details)
//
const WORD s_UnicodeByteOrderMark = 0xFEFF;
const TCHAR s_WinNT50RegFileHeader[] = TEXT("Windows Registry Editor Version");
const TCHAR s_WinNT50RegFileVersion[] = TEXT("5.00");
#endif

const TCHAR s_HexPrefix[] = TEXT("hex");
const TCHAR s_DwordPrefix[] = TEXT("dword:");
const TCHAR g_HexConversion[16] = {TEXT('0'), TEXT('1'), TEXT('2'), TEXT('3'), TEXT('4'),
                                   TEXT('5'), TEXT('6'), TEXT('7'), TEXT('8'), TEXT('9'),
                                   TEXT('a'), TEXT('b'), TEXT('c'), TEXT('d'), TEXT('e'), TEXT('f')};
const TCHAR s_FileLineBreak[] = TEXT(",\\\n  ");

extern BOOL g_fMultiLineStrings;

//REARCHITECT - we upped the size of this buffer from 512 to 64K to reduce the chance of hitting the bug
//where a DBCS character is split across two buffers.  The true fix was too risky at the time.
//Changed for NT5 RC2
#define SIZE_FILE_IO_BUFFER             0x10000 //64K

typedef struct _FILE_IO{
#ifdef UNICODE
    //
    // Space for unicode/ansi conversions, assumes worst case
    // where every unicode char is a double-byte char
    //
    CHAR ConversionBuffer[SIZE_FILE_IO_BUFFER*2];
#endif
    TCHAR Buffer[SIZE_FILE_IO_BUFFER];
    FILE_HANDLE hFile;
    int BufferOffset;
    int CurrentColumn;
    int CharsAvailable;
    DWORD FileSizeDiv100;
    DWORD FileOffset;
    UINT LastPercentage;
#ifdef DEBUG
    BOOL fValidateUngetChar;
#endif
}   FILE_IO;

FILE_IO s_FileIo;

UINT g_FileErrorStringID;

UINT g_ImportFileVersion;

BOOL s_fTreatFileAsUnicode = TRUE;

VOID ImportWin31RegFile(HTREEITEM hComputerItem);

VOID
NEAR PASCAL
ImportNewerRegFile(HTREEITEM hComputerItem);

VOID ParseHeader(LPHKEY lphKey, HTREEITEM hComputerItem);

VOID
NEAR PASCAL
ParseValue(
    HKEY hKey,
    LPCTSTR lpszValueName
    );

VOID
NEAR PASCAL
ParseValuename(
    HKEY hKey
    );

BOOL
NEAR PASCAL
ParseString(LPPORTVALUEPARAM pPortValueParam);

BOOL
NEAR PASCAL
ParseHexSequence(LPPORTVALUEPARAM pPortValueParam);

BOOL
NEAR PASCAL
ParseHexDword(
    LPDWORD lpDword
    );

BOOL
NEAR PASCAL
ParseHexByte(
    LPBYTE lpByte
    );

BOOL
NEAR PASCAL
ParseHexDigit(
    LPBYTE lpDigit
    );

BOOL
NEAR PASCAL
ParseEndOfLine(
    VOID
    );

VOID
NEAR PASCAL
SkipWhitespace(
    VOID
    );

VOID
NEAR PASCAL
SkipPastEndOfLine(
    VOID
    );

BOOL
NEAR PASCAL
GetChar(
    PTCHAR lpChar
    );

VOID
NEAR PASCAL
UngetChar(
    VOID
    );

BOOL
NEAR PASCAL
MatchChar(
    TCHAR CharToMatch
    );

BOOL
NEAR PASCAL
IsWhitespace(
    TCHAR Char
    );

BOOL
NEAR PASCAL
IsNewLine(
    TCHAR Char
    );

VOID
NEAR PASCAL
PutBranch(
    HKEY hKey,
    LPTSTR lpKeyName
    );

VOID
NEAR PASCAL
PutLiteral(
    LPCTSTR lpString
    );

VOID
NEAR PASCAL
PutString(
    LPCTSTR lpString
    );

VOID
NEAR PASCAL
PutBinary(
    CONST BYTE FAR* lpBuffer,
    DWORD Type,
    DWORD cbBytes
    );

VOID
NEAR PASCAL
PutDword(
    DWORD Dword,
    BOOL fLeadingZeroes
    );

VOID
NEAR PASCAL
PutChar(
    TCHAR Char
    );

VOID
NEAR PASCAL
FlushIoBuffer(
    VOID
    );

//------------------------------------------------------------------------------
//  Regedit_GetRootKeyFromComputer
//
//  DESCRIPTION: Invokes the security editor for the currently selected item.
//
//  PARAMETERS:  hWnd - handle to the current window
//------------------------------------------------------------------------------
HKEY Regedit_GetRootKeyFromComputer(HTREEITEM hComputerItem, PTSTR pszFullKeyName)
{
    HKEY hRootKey = NULL;

    if (hComputerItem == NULL)
    {
        int i;
        for (i = 0; i < NUMBER_REGISTRY_ROOTS; i++)
        {
            if (lstrcmp(g_RegistryRoots[i].lpKeyName, pszFullKeyName) == 0)
            {
                hRootKey = g_RegistryRoots[i].hKey;
                break;
            }

        }
    }
    else
    {
        TCHAR acComputerName[MAXKEYNAME];
        TV_ITEM TVItem;

        // walk through each of the registry roots to see if this key
        // belongs to it
        HTREEITEM hRegistryRoot =
            TreeView_GetChild(g_RegEditData.hKeyTreeWnd, hComputerItem);

        TVItem.mask = TVIF_TEXT | TVIF_PARAM;
        TVItem.hItem = hRegistryRoot;
        TVItem.pszText = acComputerName;
        TVItem.cchTextMax = ARRAYSIZE(acComputerName);

        while (hRegistryRoot != NULL)
        {
            TreeView_GetItem(g_RegEditData.hKeyTreeWnd, &TVItem);

            if (lstrcmp(acComputerName, pszFullKeyName) == 0)
            {
                hRootKey = (HKEY)TVItem.lParam;
                break;
            }

            hRegistryRoot =
                TreeView_GetNextSibling(g_RegEditData.hKeyTreeWnd, hRegistryRoot);
            TVItem.hItem = hRegistryRoot;
        }
    }

    return hRootKey;
}

/*******************************************************************************
*
*  EditRegistryKey
*
*  DESCRIPTION:
*     Parses the pFullKeyName string and creates a handle to the registry key.
*
*  PARAMETERS:
*     lphKey, location to store handle to registry key.
*     lpFullKeyName, string of form "HKEY_LOCAL_MACHINE\Subkey1\Subkey2".
*     fCreate, TRUE if key should be created, else FALSE for open only.
*     (returns), ERROR_SUCCESS, no errors occurred, phKey is valid,
*                ERROR_CANTOPEN, registry access error of some form,
*                ERROR_BADKEY, incorrectly formed pFullKeyName.
*
*******************************************************************************/

DWORD EditRegistryKey(HTREEITEM hComputerItem, LPHKEY lphKey, LPTSTR lpFullKeyName, UINT uOperation)
{
    LPTSTR lpSubKeyName;
    TCHAR PrevChar;
    UINT Counter;
    DWORD Result;
    HKEY hRootKey = NULL;

    if ((lpSubKeyName = (LPTSTR) StrChr(lpFullKeyName, TEXT('\\'))) != NULL) {

        PrevChar = *lpSubKeyName;
        *lpSubKeyName++ = 0;

    }

    CharUpper(lpFullKeyName);

    hRootKey = Regedit_GetRootKeyFromComputer(hComputerItem, lpFullKeyName);

    if (hRootKey)
    {
        Result = ERROR_CANTOPEN;

        switch (uOperation)
        {
        case ERK_CREATE:
            //
            // If trying to open one of these keys just return OK
            // When lpSubKeyName is NULL, you recreate the parent key
            // Since these keys are usually in use this will fail
            // This code path only occurs when restoring a whole root key
            // from a .reg file.
            //
            if (((hRootKey == HKEY_LOCAL_MACHINE) || (hRootKey == HKEY_USERS))
                && lpSubKeyName == NULL) {
                Result = ERROR_SUCCESS;
            }
            else if (RegCreateKey(hRootKey, lpSubKeyName, lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;
            break;

        case ERK_OPEN:
            //
            // Used when exporting.
            //
            if(RegOpenKeyEx(hRootKey,lpSubKeyName,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;
            break;

        case ERK_DELETE:
            RegDeleteKeyRecursive(hRootKey, lpSubKeyName);
            // asssume success... don't care if this fails
            Result = ERROR_SUCCESS;
            *lphKey = NULL;
            break;
        }

    }
    else
    {
        Result = ERROR_BADKEY;
    }

    if (lpSubKeyName != NULL) {

        lpSubKeyName--;
        *lpSubKeyName = PrevChar;

    }

    return Result;

}

/*******************************************************************************
*
*  ImportRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     lpFileName, address of name of file to be imported.
*
*******************************************************************************/

VOID
PASCAL
ImportRegFile(HWND hWnd, LPTSTR lpFileName, HTREEITEM hComputerItem)
{

    TCHAR Char;
    LPCTSTR lpHeader;
    BOOL fNewRegistryFile;
#ifdef UNICODE
    UINT Temp, i;
    TCHAR StrToIntBuf[2];
    LPCTSTR lp50Header;
#endif // UNICODE
    DWORD cch;
    TCHAR tchBuffer[MAX_PATH] = {0};
    LPTSTR lpFilePart;

    g_FileErrorStringID = IDS_IMPFILEERRSUCCESS;

    // OPENREADFILE used to be OpenFile(), but there isn't any Unicode version
    // of that API, so now it's CreateFile().  But OpenFile searched the path
    // automatically, whereas CreateFile does not.  Corel's 'Perfect Office v6'
    // install app depends on the path being searched, so do it manually.

    cch = SearchPath(NULL,                // pointer to search path
                     lpFileName,          // pointer to filename
                     NULL,                // pointer to extension
                     ARRAYSIZE(tchBuffer), // size, in characters, of buffer
                     (TCHAR*)tchBuffer,   // pointer to buffer for found filename
                     &lpFilePart);        // pointer to pointer to file component);

    if ((cch != 0) && (cch <= MAX_PATH) && OPENREADFILE((TCHAR*)tchBuffer, s_FileIo.hFile)) 
    {
        WORD wBOM;
        DWORD NumberOfBytesRead;

        s_FileIo.FileSizeDiv100 = GetFileSize(s_FileIo.hFile, NULL) / 100;
        s_FileIo.FileOffset = 0;
        s_FileIo.CharsAvailable = 0;
        s_FileIo.LastPercentage = 0;

        //
        // Read the first two bytes. If it's the Unicode byte order mark,
        // set a flag so all the rest of the file will be interpreted
        // as ANSI or Unicode text properly.
        //
        if (!READFILE(s_FileIo.hFile, &wBOM,
            sizeof(wBOM), &NumberOfBytesRead)) {

            g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
            goto exit_gracefully;
        }

        if (wBOM == s_UnicodeByteOrderMark)
            s_fTreatFileAsUnicode = TRUE;
        else {
            s_fTreatFileAsUnicode = FALSE;
            // We probably just read "RE" from "REGEDIT4".  Back up the file
            // position so the ANSI import routines get what they expect
            SetFilePointer(s_FileIo.hFile, -2, NULL, FILE_CURRENT);
        }

        //
        //  The following will force GetChar to read in the first block of data.
        //

        s_FileIo.BufferOffset = 0;

        SkipWhitespace();

        lpHeader = s_RegistryHeader;
        g_ImportFileVersion = 0;

# if 0
    Sit back, and I will tell ye a tale of woe.

    Win95 and NT 4 shipped with regedit compiled ANSI.  There are a couple
    of registry types on NT (namely REG_EXPAND_SZ and REG_MULTI_SZ) that
    weren't on Win95, and which regedit doesn't really understand.  regedit
    treats these registry types as hex binary streams.

    You can probably see where this is going.

    If you exported, say your user TEMP environment variable on NT 4
    using regedit, you'd get something that looked like this:

REGEDIT4

[HKEY_CURRENT_USER\Environment]
"TEMP"=hex(2):25,53,59,53,54,45,4d,44,52,49,56,45,25,5c,53,48,54,65,6d,70,00

    ...a nice, null-terminated ANSI string.  Nice, that is, until we decided
    to compile regedit UNICODE for NT 5.  A unicode regedit exports your
    user TEMP variable like this:

REGEDIT4

[HKEY_CURRENT_USER\Environment]
"TEMP"=hex(2):25,00,53,00,59,00,53,00,54,00,45,00,4d,00,44,00,52,00,49,00,56,\
  00,45,00,25,00,5c,00,53,00,48,00,54,00,65,00,6d,00,70,00,00,00

    ...mmmm.  Unicode.  Of course, a unicode regedit also expects anything
    it imports to have all those interspersed zeroes, too.  Otherwise,
    it dumps garbage into your registry.  All it takes is a -DUNICODE, and
    regedit is suddenly incompatible with the thousdands of existing .reg
    files out there.

    So just bump the version in the header to REGEDIT5 and be done with
    it, right?  Wrong.  The regedit on Win95 and NT 4 looks at the first
    character after the string "REGEDIT" and compares it to the digit "4".
    If that character is anything other than the digit "4", the parser
    assumes it is looking at a Windows 3.1 file.  Yep.  There will only
    ever be two formats, right?  Just Win95 and Win3.1.  That's all the
    world needs.

    So a completely new .reg file header had to be invented, so that the
    older, regedits of the world would simply regect the new,
    unicodized .reg files outright.  An NT 5 .reg file, exporting your user
    TEMP variable, looks like this:

Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Environment]
"TEMP"=hex(2):25,00,53,00,59,00,53,00,54,00,45,00,4d,00,44,00,52,00,49,00,56,\
  00,45,00,25,00,5c,00,53,00,48,00,54,00,65,00,6d,00,70,00,00,00

    The parser is still not very good, but it does bother to convert that 5.00
    into a version number, so that future generations can bump it to 5.50 or
    6.00, and the regedit 5.00 that shipped with NT 5.00 will properly reject
    the files.
#endif // 0

#ifdef UNICODE
        //
        // Compare to the new .reg file header
        //
        lp50Header = s_WinNT50RegFileHeader;
        while (*lp50Header != 0) {

            if (MatchChar(*lp50Header))
                lp50Header = CharNext(lp50Header);

            else
                break;

        }

        //
        // If the above loop pushed lp50Header to its terminating null
        // character, then the header matches.
        //
        if (0 == *lp50Header) {

            SkipWhitespace();
            //
            // Now, decode the version number into a hex, _WIN32_WINNT
            // style version number.
            //
            StrToIntBuf[1] = 0;

            //
            // Any number of digits can come before the decimal point
            //
            while (!MatchChar(TEXT('.'))) {
                if (!GetChar(StrToIntBuf) || !IsCharAlphaNumeric(*StrToIntBuf)) {
                    g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
                    goto exit_gracefully;
                }

                Temp = StrToInt(StrToIntBuf);
                // Hex version number, so move left four bits.
                g_ImportFileVersion <<= 4;
                g_ImportFileVersion += Temp;
            }

            //
            // Fixed at two digits after the decimal point
            //
            for (i = 0; i < 2; i++) {
                if (!GetChar(StrToIntBuf) || !IsCharAlphaNumeric(*StrToIntBuf)) {
                    g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
                    goto exit_gracefully;
                }

                Temp = StrToInt(StrToIntBuf);
                // Hex version number, so move left four bits.
                g_ImportFileVersion <<= 4;
                g_ImportFileVersion += Temp;
            }

            //
            // For NT 5, reject any version number that isn't
            // 5.  This can be expanded into a switch statement
            // when the version number is bumped later.
            //
            if (0x0500 != g_ImportFileVersion) {
                g_FileErrorStringID = IDS_IMPFILEERRVERBAD;
                goto exit_gracefully;
            }
            else {
                SkipWhitespace();
                ImportNewerRegFile(hComputerItem);
            }

        } // if (0 == *lp50Header)
        //
        // It doesn't use the new .reg file header, so
        // it's not an NT 5.0+ registry file, so use the
        // older algorithm to see if it's a valid older registry file
        //
        else {
#endif // UNICODE

            while (*lpHeader != 0) {

                if (MatchChar(*lpHeader))
                    lpHeader = CharNext(lpHeader);

                else
                    break;

            }

            if (*lpHeader == 0) {

                //
                // Win95's and NT 4's regedit shipped with this line
                // of code.  It is the cause of all of the suffering above.
                // Notice the incorrect assumption:  "If the very next
                // character isn't a '4', then we must be reading
                // a Windows 3.1 registry file!"  Of course there won't
                // be a version 5 of regedit.  Version 4 was perfect!
                //
                fNewRegistryFile = MatchChar(TEXT('4'));

                SkipWhitespace();

                if (GetChar(&Char) && IsNewLine(Char)) {

                    if (fNewRegistryFile) {
                        g_ImportFileVersion = 0x0400;
                        ImportNewerRegFile(hComputerItem);
                    }
                    else {
                        g_ImportFileVersion = 0x0310;
                        ImportWin31RegFile(hComputerItem);
                    }
                }
            }
            else if (!hWnd)
            {
                // only registry script files can be imported without the
                // regedit window open
                g_FileErrorStringID = IDS_IMPFILEERRNOTASCRPT;
            }
            else if (!hComputerItem || (hComputerItem ==
                RegEdit_GetComputerItem(TreeView_GetSelection(g_RegEditData.hKeyTreeWnd))))
            {
                // It's not a registry file, but since the selected key is on the computer
                // they choose, try to import it as a binary registy key (regedt32 type)

                // remove the progress dialog
                if (g_hRegProgressWnd != NULL)
                {
                    EnableWindow(hWnd, TRUE);
                    DestroyWindow(g_hRegProgressWnd);
                    g_hRegProgressWnd = NULL;
                }

                RestoreBinaryKeyFile(hWnd, lpFileName);
            }
            else
            {
                g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
            }
#ifdef UNICODE
        }
#endif // UNICODE

    } // if (OPENREADFILE...

    else 
    {
        { 
            TCHAR buff[250];
            StringCchPrintf(buff, ARRAYSIZE(buff), L"REGEDIT:  CreateFile failed, GetLastError() = %d\n", 
                    GetLastError());
            OutputDebugString(buff);
        }
        s_FileIo.hFile = NULL;
        g_FileErrorStringID = IDS_IMPFILEERRFILEOPEN;
    }

#ifdef UNICODE // Urefd labels generate warnings
exit_gracefully:
#endif // UNICODE
    if (s_FileIo.hFile) {
        CloseHandle(s_FileIo.hFile);
    }

}

//------------------------------------------------------------------------------
//  ImportBinaryKeyFile
//
//  DESCRIPTION:  Loads a binary key file at the currently selected key
//                This is the format of regedt32.exe saved keys
//
//  PARAMETERS:   LPTSTR lpFileName - file with the binary key
//------------------------------------------------------------------------------
void RestoreBinaryKeyFile(HWND hWnd, LPTSTR lpFileName)
{
    TCHAR achKeyName[MAXKEYNAME];
    HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);
    KeyTree_GetKeyName(hSelectedTreeItem, achKeyName, ARRAYSIZE(achKeyName));

    // confirm that they want to replace the registry key
    if (InternalMessageBox(g_hInstance, hWnd,
        MAKEINTRESOURCE(IDS_CONFIRMRESTOREKEY), MAKEINTRESOURCE(IDS_CONFIRMRESKEYTITLE),
        MB_ICONQUESTION | MB_YESNO , achKeyName) == IDYES)
    {
        HRESULT hr;

        RegEdit_SetPrivilege(SE_RESTORE_NAME, TRUE);

        // attempt to load the file as a registry key
        if ((hr = RegRestoreKey(g_RegEditData.hCurrentSelectionKey, lpFileName,
            REG_FORCE_RESTORE)) != ERROR_SUCCESS)
        {
            switch (hr)
            {
            case ERROR_PRIVILEGE_NOT_HELD:
                g_FileErrorStringID = IDS_IMPFILEERRNOPRIV;
                break;

            case ERROR_FILE_NOT_FOUND:
                g_FileErrorStringID = IDS_IMPFILEERRNOFILE;
                break;

            case ERROR_INVALID_HANDLE:
                g_FileErrorStringID = IDS_IMPFILEERRINVALID;
                break;

            default:
                g_FileErrorStringID = IDS_IMPFILEERRFORMATBAD;
                break;
            }
        }

        RegEdit_SetPrivilege(SE_RESTORE_NAME, FALSE);
    }
    else
    {
        g_FileErrorStringID = IDS_IMPFILEERRORCANCEL;
    }
}


/*******************************************************************************
*
*  ImportWin31RegFile
*
*  DESCRIPTION:
*     Imports the contents of a Windows 3.1 style registry file into the
*     registry.
*
*     We scan over the file looking for lines of the following type:
*        HKEY_CLASSES_ROOT\keyname = value_data
*        HKEY_CLASSES_ROOT\keyname =value_data
*        HKEY_CLASSES_ROOT\keyname value_data
*        HKEY_CLASSES_ROOT\keyname                          (null value data)
*
*     In all cases, any number of spaces may follow 'keyname'.  Although we
*     only document the first syntax, the Windows 3.1 Regedit handled all of
*     these formats as valid, so this version will as well (fortunately, it
*     doesn't make the parsing any more complex!).
*
*     Note, we also support replacing HKEY_CLASSES_ROOT with \.classes above
*     which must come from some early releases of Windows.
*
*  PARAMETERS: HTREEITEM hComputerItem -  computer item to receive imported key
*
*******************************************************************************/

VOID ImportWin31RegFile(HTREEITEM hComputerItem)
{

    HKEY hKey;
    TCHAR Char;
    BOOL fSuccess;
    LPCTSTR lpClassesRoot;
    TCHAR KeyName[MAXKEYNAME];
    UINT Index;

    //
    //  Keep an open handle to the classes root.  We may prevent some
    //  unneccessary flushing.
    //
    hKey = Regedit_GetRootKeyFromComputer(hComputerItem,
        g_RegistryRoots[INDEX_HKEY_CLASSES_ROOT].lpKeyName);

    if (RegOpenKeyEx(hKey, NULL, 0, KEY_SET_VALUE, &hKey) != ERROR_SUCCESS)
    {
        g_FileErrorStringID = IDS_IMPFILEERRREGOPEN;
        return;
    }

    while (TRUE) {

        //
        //  Check for the end of file condition.
        //

        if (!GetChar(&Char))
            break;

        UngetChar();                    //  Not efficient, but works for now.

        //
        //  Match the beginning of the line against one of the two aliases for
        //  HKEY_CLASSES_ROOT.
        //

        if (MatchChar(TEXT('\\')))
            lpClassesRoot = s_OldWin31RegFileRoot;

        else
            lpClassesRoot = g_RegistryRoots[INDEX_HKEY_CLASSES_ROOT].lpKeyName;

        fSuccess = TRUE;

        while (*lpClassesRoot != 0) {

            if (!MatchChar(*lpClassesRoot++)) {

                fSuccess = FALSE;
                break;

            }

        }

        //
        //  Make sure that we have a backslash seperating one of the aliases
        //  from the keyname.
        //

        if (fSuccess)
            fSuccess = MatchChar(TEXT('\\'));

        if (fSuccess) {

            //
            //  We've found one of the valid aliases, so read in the keyname.
            //

            //  fSuccess = TRUE;        //  Must be TRUE if we're in this block
            Index = 0;

            while (GetChar(&Char)) {

                if (Char == TEXT(' ') || IsNewLine(Char))
                    break;

                //
                //  Make sure that the keyname buffer doesn't overflow.  We must
                //  leave room for a terminating null.
                //

                if (Index >= (ARRAYSIZE(KeyName)) - 1) 
                {
                    fSuccess = FALSE;
                    break;
                }

                KeyName[Index++] = Char;

            }

            if (fSuccess)
            {
                UINT cMaxDataLength = ALLOCATION_INCR;
                PBYTE pbValueDataBuffer;

                KeyName[Index] = 0;

                //
                //  Now see if we have a value to assign to this keyname.
                //

                SkipWhitespace();

                if (MatchChar(TEXT('=')))
                    MatchChar(TEXT(' '));

                //  fSuccess = TRUE;    //  Must be TRUE if we're in this block
                Index = 0;

                pbValueDataBuffer = LocalAlloc(LPTR, cMaxDataLength);
                fSuccess = (pbValueDataBuffer != NULL);

                while (GetChar(&Char) && fSuccess)
                {

                    if (IsNewLine(Char))
                        break;

                    //
                    //  Make sure that the value data buffer doesn't overflow.
                    //  Because this is always string data, we must leave room
                    //  for a terminating null.
                    //

                    if (Index >= cMaxDataLength - 1)
                    {
                        PBYTE pbValueData =
                            LocalReAlloc(pbValueDataBuffer, cMaxDataLength + ALLOCATION_INCR, LMEM_MOVEABLE);

                        fSuccess = (pbValueData != NULL);
                        if (!fSuccess)
                        {
                            break;
                        }
                        else
                        {
                            pbValueDataBuffer = pbValueData;
                            cMaxDataLength += ALLOCATION_INCR;
                        }
                    }

                    ((PTSTR)pbValueDataBuffer)[Index++] = Char;

                }

                if (fSuccess)
                {

                    ((PTSTR)pbValueDataBuffer)[Index] = 0;

                    if (RegSetValue(hKey, KeyName, REG_SZ, (LPCTSTR)pbValueDataBuffer,
                        Index*sizeof(TCHAR)) != ERROR_SUCCESS)
                        g_FileErrorStringID = IDS_IMPFILEERRREGSET;
                }
                else
                {
                    g_FileErrorStringID = IDS_NOMEMORY;
                }

                if (pbValueDataBuffer)
                {
                    LocalFree(pbValueDataBuffer);
                }
            }

        }

        //
        //  Somewhere along the line, we had a parsing error, so resynchronize
        //  on the next line.
        //

        if (!fSuccess)
            SkipPastEndOfLine();

    }

    RegFlushKey(hKey);
    RegCloseKey(hKey);

}

/*******************************************************************************
*
*  ImportNewerRegFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ImportNewerRegFile(HTREEITEM hComputerItem)
{
    TCHAR   Char;
    HKEY    hKey;

    hKey = NULL;

    while (TRUE) {

        SkipWhitespace();

        //
        //  Check for the end of file condition.
        //

        if (!GetChar(&Char))
            break;

        switch (Char) {

            case TEXT('['):
                //
                //  If a registry key is currently open, we must close it first.
                //  If ParseHeader happens to fail (for example, no closing
                //  bracket), then hKey will be NULL and any values that we
                //  parse must be ignored.
                //

                if (hKey != NULL) {

                    RegCloseKey(hKey);
                    hKey = NULL;

                }

                ParseHeader(&hKey, hComputerItem);

                break;

            case TEXT('"'):
                //
                //  As noted above, if we don't have an open registry key, then
                //  just skip the line.
                //

                if (hKey != NULL)
                    ParseValuename(hKey);

                else
                    SkipPastEndOfLine();

                break;

            case TEXT('@'):
                //
                //
                //

                if (hKey != NULL)
                    ParseValue(hKey, NULL);

                else
                    SkipPastEndOfLine();

                break;

            case TEXT(';'):
                //
                //  This line is a comment so just dump the rest of it.
                //

                SkipPastEndOfLine();

                break;

            default:
                if (IsNewLine(Char))
                    break;

                SkipPastEndOfLine();

                break;

        }

    }

    if (hKey != NULL)
        RegCloseKey(hKey);
}

/*******************************************************************************
*
*  ParseHeader
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

// REARCHITECT - each subkeyname can be MAXKEYNAME in size
// ideally - we should handle unlimited size names
// let's at least handle bigger names for now
// at least a depth of 10 with maximum length subkey names

#define SIZE_FULL_KEYNAME ((MAXKEYNAME + 40)*10)

VOID ParseHeader(LPHKEY lphKey, HTREEITEM hComputerItem)
{

    TCHAR FullKeyName[SIZE_FULL_KEYNAME];
    int CurrentIndex;
    int LastRightBracketIndex;
    TCHAR Char;
    UINT uOperation = ERK_CREATE;

    CurrentIndex = 0;
    LastRightBracketIndex = -1;

    if (!GetChar(&Char))
        return;

    if (Char == TEXT('-')) {
        if (!GetChar(&Char))
            return;
        uOperation = ERK_DELETE;
    }

    do {

        if (IsNewLine(Char))
            break;

        if (Char == TEXT(']'))
            LastRightBracketIndex = CurrentIndex;

        FullKeyName[CurrentIndex++] = Char;

        if (CurrentIndex == SIZE_FULL_KEYNAME) {

            do {

                if (Char == TEXT(']'))
                    LastRightBracketIndex = -1;

                if (IsNewLine(Char))
                    break;

            }   while (GetChar(&Char));

            break;

        }

    } while (GetChar(&Char));

    if (LastRightBracketIndex != -1)
    {
        FullKeyName[LastRightBracketIndex] = 0;

        switch (EditRegistryKey(hComputerItem, lphKey, FullKeyName, uOperation))
        {
            //
            // Be afraid of adding code to handle more error cases here.
            //
            // We broke Picture Publisher 8.0 by adding an ERROR_BADKEY
            // case.  As part of their setup, they run regedit on a v4
            // reg file that has a bad section, which EditRegistryKey
            // will fail to parse with ERROR_BADKEY.  We need to keep
            // chugging along in that case like Win2K did, or else we
            // break their setup.
            //
            case ERROR_CANTOPEN:
                g_FileErrorStringID = IDS_IMPFILEERRREGOPEN;
                break;
        }

    }

}

/*******************************************************************************
*
*  ParseValuename
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
ParseValuename(
    HKEY hKey
    )
{
    PORTVALUEPARAM PortValueParam;
    PortValueParam.cbData = MAXVALUENAME_LENGTH * sizeof(TCHAR);
    PortValueParam.pbData = LocalAlloc(LPTR, PortValueParam.cbData);

    if (PortValueParam.pbData)
    {
        if (ParseString(&PortValueParam))
        {
            ParseValue(hKey, (PTSTR)PortValueParam.pbData);
        }
        else
        {
            SkipPastEndOfLine();
        }
        LocalFree(PortValueParam.pbData);
    }
}

VOID
NEAR PASCAL
ParseValue(
           HKEY hKey,
           LPCTSTR lpszValueName
           )
{
    BOOL fSuccess = TRUE;
    BOOL fSkipPastLine = FALSE;
    DWORD Type;
    DWORD cbData = 0;
    DWORD cbMaxData = ALLOCATION_INCR;
    LPCTSTR lpPrefix;
    PBYTE pbValueDataBuffer;

    SkipWhitespace();

    if (!MatchChar(TEXT('=')))
    {
        fSuccess = FALSE;
        fSkipPastLine = TRUE;
    }
    else
    {

        SkipWhitespace();

        pbValueDataBuffer = LocalAlloc(LPTR, cbMaxData);
        if (!pbValueDataBuffer)
        {
            g_FileErrorStringID = IDS_IMPFILEERRREGSET;
            fSuccess = FALSE;
        }
        else
        {
            //
            //  REG_SZ.
            //
            //  "ValueName" = "string of text"
            //

            if (MatchChar(TEXT('"')))
            {

                //  FEATURE:  Line continuations for strings?

                PORTVALUEPARAM PortValueParam;
                PortValueParam.pbData = pbValueDataBuffer;
                PortValueParam.cbData = cbMaxData;

                if (!ParseString(&PortValueParam) || !ParseEndOfLine())
                {
                    fSuccess = FALSE;
                    fSkipPastLine = TRUE;
                }

                // pointer might have been swapped for one with more memory
                pbValueDataBuffer = PortValueParam.pbData;
                cbData = PortValueParam.cbData;
                Type = REG_SZ;

            }

            //
            //  REG_DWORD.
            //
            //  "ValueName" = dword: 12345678
            //

            else if (MatchChar(s_DwordPrefix[0])) {

                lpPrefix = &s_DwordPrefix[1];

                while (*lpPrefix != 0)
                {
                    if (!MatchChar(*lpPrefix++))
                    {
                        fSuccess = FALSE;
                        fSkipPastLine = TRUE;
                    }
                }

                if (fSuccess)
                {
                    SkipWhitespace();

                    if (!ParseHexDword((LPDWORD) pbValueDataBuffer) || !ParseEndOfLine())
                    {
                        fSuccess = FALSE;
                        fSkipPastLine = TRUE;
                    }

                    Type = REG_DWORD;
                    cbData = sizeof(DWORD);
                }
            }
            else if (MatchChar('-'))
            {
                if (!ParseEndOfLine())
                {
                    fSuccess = FALSE;
                    fSkipPastLine = TRUE;
                }
                else
                {
                    RegDeleteValue(hKey, lpszValueName);
                    fSuccess = FALSE;
                }
            }

            //
            //  REG_BINARY and other.
            //
            //  "ValueName" = hex: 00 , 11 , 22
            //  "ValueName" = hex(12345678): 00, 11, 22
            //

            else {

                lpPrefix = s_HexPrefix;

                while (*lpPrefix != 0)
                {
                    if (!MatchChar(*lpPrefix++))
                    {
                        fSuccess = FALSE;
                        fSkipPastLine = TRUE;
                    }
                }

                if (fSuccess)
                {
                    //
                    //  Check if this is a type of registry data that we don't directly
                    //  support.  If so, then it's just a dump of hex data of the specified
                    //  type.
                    //

                    if (MatchChar(TEXT('(')))
                    {
                        if (!ParseHexDword(&Type) || !MatchChar(TEXT(')')))
                        {
                            fSuccess = FALSE;
                            fSkipPastLine = TRUE;
                        }
                    }

                    else
                        Type = REG_BINARY;

                    if (fSuccess)
                    {
                        PORTVALUEPARAM PortValueParam;
                        PortValueParam.pbData = pbValueDataBuffer;
                        PortValueParam.cbData = cbMaxData;

                        if (!MatchChar(TEXT(':')) || !ParseHexSequence(&PortValueParam) ||
                            !ParseEndOfLine())
                        {
                            fSuccess = FALSE;
                            fSkipPastLine = TRUE;
                        }

                        // pointer might have been swapped for one with more memory
                        pbValueDataBuffer = PortValueParam.pbData;
                        cbData = PortValueParam.cbData;
                    }
                }
            }

            if (fSuccess)
            {

#ifdef UNICODE
                //
                // If we're compiled UNICODE and we're reading an older, ANSI .reg
                // file, we have to write all of the data to the registry using
                // RegSetValueExA, because it was read from the registry using
                // RegQueryValueExA.
                //
                if ((g_ImportFileVersion < 0x0500) && ((REG_EXPAND_SZ == Type) || (REG_MULTI_SZ == Type)))
                {
                    CHAR AnsiValueName[MAXVALUENAME_LENGTH];
                    AnsiValueName[0] = 0;

                    //
                    // It's much easier to convert the value name to ANSI
                    // and call RegSetValueExA than to try to convert
                    // a REG_MULTI_SZ to Unicode before calling RegSetValueExW.
                    // We don't lose anything because this is coming from a
                    // downlevel .reg file that could only contain ANSI characters
                    // to begin with.
                    //
                    WideCharToMultiByte(
                        CP_THREAD_ACP,
                        0,
                        lpszValueName,
                        -1,
                        AnsiValueName,
                        ARRAYSIZE(AnsiValueName),
                        NULL,
                        NULL
                        );

                    if (RegSetValueExA(
                        hKey,
                        AnsiValueName,
                        0,
                        Type,
                        pbValueDataBuffer,
                        cbData)
                        != ERROR_SUCCESS)
                        g_FileErrorStringID = IDS_IMPFILEERRREGSET;
                }
                else 
                {
#endif // UNICODE
                    if (RegSetValueEx(hKey, lpszValueName, 0, Type, pbValueDataBuffer, cbData) != ERROR_SUCCESS)
                        g_FileErrorStringID = IDS_IMPFILEERRREGSET;
#ifdef UNICODE
                }
#endif // UNICODE

            }
            LocalFree(pbValueDataBuffer);
        }
    }

    if (fSkipPastLine)
    {
        SkipPastEndOfLine();
    }
}

/*******************************************************************************
*
*  ParseString
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseString(LPPORTVALUEPARAM pPortValueParam)
{
    TCHAR Char;
    DWORD cbMaxStringData;
    DWORD cbStringData;


    LPTSTR psz = (LPTSTR)pPortValueParam->pbData; // this one is incremented
    cbMaxStringData = pPortValueParam->cbData;
    cbStringData = sizeof(TCHAR);                   //  Account for the null terminator

    while (GetChar(&Char))
    {
        if (cbStringData >= cbMaxStringData)
        {
            // allocate a bigger buffer
            PBYTE pbValueData =
                LocalReAlloc(pPortValueParam->pbData, cbMaxStringData + ALLOCATION_INCR, LMEM_MOVEABLE);
            if (pbValueData)
            {
                pPortValueParam->pbData = pbValueData;
                // incr psz to next char in new buffer
                psz = (LPTSTR)(pPortValueParam->pbData + (cbMaxStringData - sizeof(TCHAR)));

                cbMaxStringData += ALLOCATION_INCR;
            }
            else
            {
                break;
            }
        }

        switch (Char) 
        {
            case TEXT('\\'):
                if (!GetChar(&Char))
                    return FALSE;

                switch (Char) 
                {
                    case TEXT('\\'):
                        *psz++ = TEXT('\\');
                        break;

                    case TEXT('"'):
                        *psz++ = TEXT('"');
                        break;

                    case TEXT('r'):
                        if(g_fMultiLineStrings) 
                        {
                            *psz++ = TEXT('\r');
                            break;
                        }
                        else 
                        {
                            DebugPrintf(("ParseString:  Invalid escape sequence"));
                            return FALSE;
                        }

                    case TEXT('n'):
                        if(g_fMultiLineStrings) 
                        {
                            *psz++ = TEXT('\n');
                            break;
                        }
                        else 
                        {
                            DebugPrintf(("ParseString:  Invalid escape sequence"));
                            return FALSE;
                        }

                    default:
                        DebugPrintf(("ParseString:  Invalid escape sequence"));
                        return FALSE;
                }
                break;

            case TEXT('"'):
                *psz = 0;
                pPortValueParam->cbData = cbStringData;
                return TRUE;

            default:
                if (IsNewLine(Char))
                    return FALSE;

                *psz++ = Char;
                break;

        }

        cbStringData += sizeof(TCHAR);

    }

    return FALSE;

}


/*******************************************************************************
*
*  ParseHexSequence
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexSequence(LPPORTVALUEPARAM pPortValueParam)
{
    BOOL  fSuccess = TRUE;
    DWORD cbHexData = 0;
    DWORD cbMaxStringData = pPortValueParam->cbData;
    LPBYTE lpHexData = pPortValueParam->pbData;

    do
    {
        if (cbHexData >= cbMaxStringData)
        {
            // allocate a bigger buffer
            PBYTE pbValueData = LocalReAlloc(pPortValueParam->pbData,
                cbMaxStringData + ALLOCATION_INCR, LMEM_MOVEABLE);
            if (pbValueData)
            {
                pPortValueParam->pbData = pbValueData;
                // incr psz to next char in new buffer
                lpHexData = pPortValueParam->pbData + cbMaxStringData;

                cbMaxStringData += ALLOCATION_INCR;
            }
            else
            {
                fSuccess = FALSE;
                break;
            }
        }

        SkipWhitespace();

        if (MatchChar(TEXT('\\')) && !ParseEndOfLine())
        {
            fSuccess = FALSE;
            break;
        }

        SkipWhitespace();

        if (!ParseHexByte(lpHexData++))
            break;

        cbHexData++;

        SkipWhitespace();

    }   while (MatchChar(TEXT(',')));

    pPortValueParam->cbData = cbHexData;

    return fSuccess;

}

/*******************************************************************************
*
*  ParseHexDword
*
*  DESCRIPTION:
*     Parses a one dword hexadecimal string from the registry file stream and
*     converts it to a binary number.  A maximum of eight hex digits will be
*     parsed from the stream.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal dword was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexDword(
    LPDWORD lpDword
    )
{

    UINT CountDigits;
    DWORD Dword;
    BYTE Byte;

    Dword = 0;
    CountDigits = 0;

    while (TRUE) {

        if (!ParseHexDigit(&Byte))
            break;

        Dword = (Dword << 4) + (DWORD) Byte;

        if (++CountDigits == 8)
            break;

    }

    *lpDword = Dword;

    return CountDigits != 0;

}

/*******************************************************************************
*
*  ParseHexByte
*
*  DESCRIPTION:
*     Parses a one byte hexadecimal string from the registry file stream and
*     converts it to a binary number.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal byte was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexByte(
    LPBYTE lpByte
    )
{

    BYTE SecondDigit;

    if (ParseHexDigit(lpByte)) {

        if (ParseHexDigit(&SecondDigit))
            *lpByte = (BYTE) ((*lpByte << 4) | SecondDigit);

        return TRUE;

    }

    else
        return FALSE;

}

/*******************************************************************************
*
*  ParseHexDigit
*
*  DESCRIPTION:
*     Parses a hexadecimal character from the registry file stream and converts
*     it to a binary number.
*
*  PARAMETERS:
*     lpDigit, location to store binary number.
*     (returns), TRUE if a hexadecimal digit was parsed, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseHexDigit(
    LPBYTE lpDigit
    )
{

    TCHAR Char;
    BYTE Digit;

    if (GetChar(&Char)) {

        if (Char >= TEXT('0') && Char <= TEXT('9'))
            Digit = (BYTE) (Char - TEXT('0'));

        else if (Char >= TEXT('a') && Char <= TEXT('f'))
            Digit = (BYTE) (Char - TEXT('a') + 10);

        else if (Char >= TEXT('A') && Char <= TEXT('F'))
            Digit = (BYTE) (Char - TEXT('A') + 10);

        else {

            UngetChar();

            return FALSE;

        }

        *lpDigit = Digit;

        return TRUE;

    }

    return FALSE;

}

/*******************************************************************************
*
*  ParseEndOfLine
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
ParseEndOfLine(
    VOID
    )
{

    TCHAR Char;
    BOOL fComment;
    BOOL fFoundOneEndOfLine;
    BOOL fEOF;

    fComment = FALSE;
    fFoundOneEndOfLine = FALSE;
    fEOF = TRUE;

    while (GetChar(&Char)) {

        if (IsWhitespace(Char))
            continue;

        if (IsNewLine(Char)) {

            fComment = FALSE;
            fFoundOneEndOfLine = TRUE;

        }

        //
        //  Like .INIs and .INFs, comments begin with a semicolon character.
        //

        else if (Char == TEXT(';'))
            fComment = TRUE;

        else if (!fComment) {

            UngetChar();
            fEOF = FALSE;
            break;

        }

    }

    return fFoundOneEndOfLine || fEOF;

}

/*******************************************************************************
*
*  SkipWhitespace
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past any
*     detected whitespace.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
SkipWhitespace(
    VOID
    )
{

    TCHAR Char;

    while (GetChar(&Char)) {

        if (!IsWhitespace(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  SkipPastEndOfLine
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past the first
*     detected new line character.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
SkipPastEndOfLine(
    VOID
    )
{

    TCHAR Char;

    while (GetChar(&Char)) {

        if (IsNewLine(Char))
            break;

    }

    while (GetChar(&Char)) {

        if (!IsNewLine(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  GetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
GetChar(
    PTCHAR lpChar
    )
{

    DWORD NumberOfBytesRead;
    UINT NewPercentage;

    // If we're at the end of the buffer, read some more.
    // Initially BufferOffset and CharsAvailable will be 0
    if (s_FileIo.BufferOffset == s_FileIo.CharsAvailable) {

        if (TRUE == s_fTreatFileAsUnicode) 
        {
            if (!READFILE(s_FileIo.hFile, s_FileIo.Buffer, SIZE_FILE_IO_BUFFER, &NumberOfBytesRead)) 
            {
                g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
                return FALSE;
            }

            s_FileIo.CharsAvailable = ((int) NumberOfBytesRead / 2);
        }
        else 
        {
            if (!READFILE(s_FileIo.hFile, s_FileIo.ConversionBuffer, SIZE_FILE_IO_BUFFER, &NumberOfBytesRead)) 
            {
                g_FileErrorStringID = IDS_IMPFILEERRFILEREAD;
                return FALSE;
            }

            {
                int i;

                i = MultiByteToWideChar(
                        CP_THREAD_ACP,
                        MB_PRECOMPOSED,
                        s_FileIo.ConversionBuffer,
                        NumberOfBytesRead,
                        s_FileIo.Buffer,
                        ARRAYSIZE(s_FileIo.Buffer)
                        );

                s_FileIo.CharsAvailable = i;
            }
        }

        s_FileIo.BufferOffset = 0;
        s_FileIo.FileOffset += NumberOfBytesRead;

        if (s_FileIo.FileSizeDiv100 != 0) {

            NewPercentage = ((UINT) (s_FileIo.FileOffset /
                s_FileIo.FileSizeDiv100));

            if (NewPercentage > 100)
                NewPercentage = 100;

        }

        else
            NewPercentage = 100;

        if (s_FileIo.LastPercentage != NewPercentage) {

            s_FileIo.LastPercentage = NewPercentage;
            ImportRegFileUICallback(NewPercentage);

        }

    }

    if (s_FileIo.BufferOffset >= s_FileIo.CharsAvailable)
        return FALSE;

    *lpChar = s_FileIo.Buffer[s_FileIo.BufferOffset++];

    return TRUE;

}

/*******************************************************************************
*
*  UngetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
NEAR PASCAL
UngetChar(
    VOID
    )
{

#ifdef DEBUG
    if (s_FileIo.fValidateUngetChar)
        DebugPrintf(("REGEDIT ERROR: Too many UngetChar's called!\n\r"));
#endif

    s_FileIo.BufferOffset--;

}

/*******************************************************************************
*
*  MatchChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
NEAR PASCAL
MatchChar(
    TCHAR CharToMatch
    )
{

    BOOL fMatch;
    TCHAR NextChar;

    fMatch = FALSE;

    if (GetChar(&NextChar)) {

        if (CharToMatch == NextChar)
            fMatch = TRUE;

        else
            UngetChar();

    }

    return fMatch;

}

/*******************************************************************************
*
*  IsWhitespace
*
*  DESCRIPTION:
*     Checks if the given character is whitespace.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is whitespace, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsWhitespace(
    TCHAR Char
    )
{

    return Char == TEXT(' ') || Char == TEXT('\t');

}

/*******************************************************************************
*
*  IsNewLine
*
*  DESCRIPTION:
*     Checks if the given character is a new line character.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is a new line, else FALSE.
*
*******************************************************************************/

BOOL
NEAR PASCAL
IsNewLine(
    TCHAR Char
    )
{

    return Char == TEXT('\n') || Char == TEXT('\r');

}

/*******************************************************************************
*
*  ExportWinNT50RegFile
*
*  DESCRIPTION:
*      Exports an NT 5.0, unicode registry file.  Use this export function
*      for all future .reg file writing.
*
*  PARAMETERS:
*
*******************************************************************************/
VOID ExportWinNT50RegFile(LPTSTR lpFileName, LPTSTR lpSelectedPath)
{
    HKEY hKey;
    TCHAR SelectedPath[SIZE_SELECTED_PATH];
    HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);

    g_FileErrorStringID = IDS_EXPFILEERRSUCCESS;

    if (lpSelectedPath != NULL && 
            EditRegistryKey(RegEdit_GetComputerItem(hSelectedTreeItem), &hKey, lpSelectedPath, ERK_OPEN) 
                    != ERROR_SUCCESS)
    {
        g_FileErrorStringID = IDS_EXPFILEERRBADREGPATH;
        return;
    }

    if (OPENWRITEFILE(lpFileName, s_FileIo.hFile)) 
    {

        DWORD dwNumberOfBytesWritten;

        s_FileIo.BufferOffset = 0;
        s_FileIo.CurrentColumn = 0;

        WRITEFILE(s_FileIo.hFile, &s_UnicodeByteOrderMark, sizeof(s_UnicodeByteOrderMark), &dwNumberOfBytesWritten);

        PutLiteral(s_WinNT50RegFileHeader);
        PutLiteral(TEXT(" "));
        PutLiteral(s_WinNT50RegFileVersion);
        PutLiteral(TEXT("\n\n"));

        if (lpSelectedPath != NULL) 
        {
            StringCchCopy(SelectedPath, ARRAYSIZE(SelectedPath), lpSelectedPath);
            PutBranch(hKey, SelectedPath);

        }
        else
        {
            HTREEITEM hComputerItem = RegEdit_GetComputerItem(hSelectedTreeItem);

            StringCchCopy(SelectedPath, ARRAYSIZE(SelectedPath), g_RegistryRoots[INDEX_HKEY_LOCAL_MACHINE].lpKeyName);

            PutBranch(Regedit_GetRootKeyFromComputer(hComputerItem, SelectedPath), SelectedPath);

            StringCchCopy(SelectedPath, ARRAYSIZE(SelectedPath), g_RegistryRoots[INDEX_HKEY_USERS].lpKeyName);

            PutBranch(Regedit_GetRootKeyFromComputer(hComputerItem, SelectedPath), SelectedPath);
        }

        FlushIoBuffer();

        CloseHandle(s_FileIo.hFile);

    }
    else
        g_FileErrorStringID = IDS_EXPFILEERRFILEOPEN;

    if (lpSelectedPath != NULL)
        RegCloseKey(hKey);

}


//------------------------------------------------------------------------------
// ExportRegedt32File
//
// DESCRIPTION: This function exports file in the format of Regedt32.
//              The binary is key is stored to a file without any key path info
//
// PARAMETERS:  LPTSTR lpFileName
//              LPTSTR lpSelectedPath
//------------------------------------------------------------------------------
void ExportRegedt32File(LPTSTR lpFileName, LPTSTR lpSelectedPath)
{
    HKEY hKey = NULL;
    HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);

    g_FileErrorStringID = IDS_EXPFILEERRSUCCESS;

    if (lpSelectedPath == NULL || EditRegistryKey(RegEdit_GetComputerItem(hSelectedTreeItem),
        &hKey, lpSelectedPath, ERK_OPEN) == ERROR_SUCCESS)
    {
        HRESULT hr;

        RegEdit_SetPrivilege(SE_BACKUP_NAME, TRUE);

        //
        // If a file with the same name already exists, we need to delete
        // it ourselves before calling RegSaveKey or that call will fail.
        //
        DeleteFile(lpFileName);

        if ((hr = RegSaveKey(hKey, lpFileName, NULL)) != ERROR_SUCCESS)
        {
            switch (hr)
            {
            case ERROR_PRIVILEGE_NOT_HELD:
                g_FileErrorStringID = IDS_EXPFILEERRNOPRIV;
                break;

            case ERROR_INVALID_HANDLE:
                g_FileErrorStringID = IDS_EXPFILEERRINVALID;
                break;

            default:
                g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
                break;
            }

            // RegSaveKey created an empty file
            DeleteFile(lpFileName);
        }

        RegEdit_SetPrivilege(SE_BACKUP_NAME, FALSE);
    }
    else
    {
        g_FileErrorStringID = IDS_EXPFILEERRBADREGPATH;
    }
}


/*******************************************************************************
*
*  ExportWin40RegFile
*
*  DESCRIPTION:
*      This function is only kept around to export old, ANSI, regedit 4 .reg
*      files.  Don't touch it except to fix bugs.  Meddling with this code
*      path will result in .reg files that can't be read by older verions
*      of regedit, which is the whole reason this code path is here.  Meddle
*      with ExportWinNT50RegFile if you want to break backwards compatibility.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID ExportWin40RegFile(LPTSTR lpFileName, LPTSTR lpSelectedPath)
{
    HKEY hKey;
    TCHAR SelectedPath[SIZE_SELECTED_PATH];
    HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);

    g_FileErrorStringID = IDS_EXPFILEERRSUCCESS;

    if (lpSelectedPath != NULL && EditRegistryKey(RegEdit_GetComputerItem(hSelectedTreeItem),
        &hKey, lpSelectedPath, ERK_OPEN) != ERROR_SUCCESS)
    {

        g_FileErrorStringID = IDS_EXPFILEERRBADREGPATH;
        return;

    }

    if (OPENWRITEFILE(lpFileName, s_FileIo.hFile))
    {

        s_FileIo.BufferOffset = 0;
        s_FileIo.CurrentColumn = 0;

        PutLiteral(s_Win40RegFileHeader);

        if (lpSelectedPath != NULL) 
        {
            StringCchCopy(SelectedPath, ARRAYSIZE(SelectedPath), lpSelectedPath);
            PutBranch(hKey, SelectedPath);
        }
        else 
        {
            StringCchCopy(SelectedPath, ARRAYSIZE(SelectedPath), g_RegistryRoots[INDEX_HKEY_LOCAL_MACHINE].lpKeyName);
            PutBranch(HKEY_LOCAL_MACHINE, SelectedPath);

            StringCchCopy(SelectedPath, ARRAYSIZE(SelectedPath), g_RegistryRoots[INDEX_HKEY_USERS].lpKeyName);
            PutBranch(HKEY_USERS, SelectedPath);
        }

        FlushIoBuffer();

        CloseHandle(s_FileIo.hFile);

    }

    else
        g_FileErrorStringID = IDS_EXPFILEERRFILEOPEN;

    if (lpSelectedPath != NULL)
        RegCloseKey(hKey);

}

/*******************************************************************************
*
*  PutBranch
*
*  DESCRIPTION:
*     Writes out all of the value names and their data and recursively calls
*     this routine for all of the key's subkeys to the registry file stream.
*
*  PARAMETERS:
*     hKey, registry key to write to file.
*     lpFullKeyName, string that gives the full path, including the root key
*        name, of the hKey.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutBranch(
    HKEY hKey,
    LPTSTR lpFullKeyName
    )
{
    HKEY hSubKey;
    LONG RegError;
    DWORD EnumIndex;
    DWORD cchValueName;
    DWORD cbValueData;
    DWORD Type;
    LPTSTR lpSubKeyName;
    LPTSTR lpTempFullKeyName;
    int nLenTempFullKey;
    int nLenFullKey;    

    //
    //  Write out the section header.
    //

    PutChar(TEXT('['));
    PutLiteral(lpFullKeyName);
    PutLiteral(TEXT("]\n"));

    //
    //  Write out all of the value names and their data.
    //

    EnumIndex = 0;

    while (TRUE)
    {
        PBYTE pbValueData;
        cchValueName = ARRAYSIZE(g_ValueNameBuffer);

        // VALUE DATA
        // Query for data size
        RegError = RegEnumValue(hKey, EnumIndex++, g_ValueNameBuffer,
            &cchValueName, NULL, &Type, NULL, &cbValueData);

        if (RegError != ERROR_SUCCESS)
        {
            break;
        }

        // allocate memory for data
        pbValueData =  LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
        if (pbValueData)
        {
            if (RegEdit_QueryValueEx(hKey, g_ValueNameBuffer,
                NULL, &Type, pbValueData, &cbValueData) !=
                ERROR_SUCCESS)
            {
                g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
            }
            else
            {
                //
                //  If cbValueName is zero, then this is the default value of
                //  the key, or the Windows 3.1 compatible key value.
                //

                if (cchValueName)
                    PutString(g_ValueNameBuffer);

                else
                    PutChar(TEXT('@'));

                PutChar(TEXT('='));

                switch (Type)
                {

                case REG_SZ:
                    PutString((LPTSTR) pbValueData);
                    break;

                case REG_DWORD:
                    if (cbValueData == sizeof(DWORD))
                    {
                        PutLiteral(s_DwordPrefix);
                        PutDword(*((LPDWORD) pbValueData), TRUE);
                        break;
                    }
                    //  FALL THROUGH

                case REG_BINARY:
                default:
                    PutBinary((LPBYTE) pbValueData, Type, cbValueData);
                    break;

                }

                PutChar(TEXT('\n'));
            }
            LocalFree(pbValueData);
        }
        else
        {
            g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
        }

        if (g_FileErrorStringID == IDS_EXPFILEERRFILEWRITE)
            return;

    }

    PutChar(TEXT('\n'));

    if (RegError != ERROR_NO_MORE_ITEMS)
        g_FileErrorStringID = IDS_EXPFILEERRREGENUM;

    //
    //  Write out all of the subkeys and recurse into them.
    //

    //copy the existing key into a new buffer with enough room for the next key
    nLenFullKey = lstrlen(lpFullKeyName);
    nLenTempFullKey = nLenFullKey + MAXKEYNAME;
    __try
    {
        lpTempFullKeyName = (LPTSTR) alloca(nLenTempFullKey * sizeof(TCHAR));
    }
    __except(GetExceptionCode() == STATUS_STACK_OVERFLOW)
    {
        _resetstkoflw();
        return;
    }

    StringCchCopy(lpTempFullKeyName, nLenTempFullKey, lpFullKeyName);
    lpSubKeyName = lpTempFullKeyName + nLenFullKey;
    *lpSubKeyName++ = TEXT('\\');
    *lpSubKeyName = 0;

    EnumIndex = 0;

    while (TRUE) 
    {
        if ((RegError = RegEnumKey(hKey, EnumIndex++, lpSubKeyName, MAXKEYNAME-1)) != ERROR_SUCCESS)
            break;

        if(RegOpenKeyEx(hKey,lpSubKeyName,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,&hSubKey) == ERROR_SUCCESS) 
        {
            PutBranch(hSubKey, lpTempFullKeyName);

            RegCloseKey(hSubKey);

            if (g_FileErrorStringID == IDS_EXPFILEERRFILEWRITE)
                return;
        }

        else
            g_FileErrorStringID = IDS_EXPFILEERRREGOPEN;
    }

    if (RegError != ERROR_NO_MORE_ITEMS)
        g_FileErrorStringID = IDS_EXPFILEERRREGENUM;

}

/*******************************************************************************
*
*  PutLiteral
*
*  DESCRIPTION:
*     Writes a literal string to the registry file stream.  No special handling
*     is done for the string-- it is written out as is.
*
*  PARAMETERS:
*     lpLiteral, null-terminated literal to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutLiteral(
    LPCTSTR lpLiteral
    )
{

    while (*lpLiteral != 0)
        PutChar(*lpLiteral++);

}

/*******************************************************************************
*
*  PutString
*
*  DESCRIPTION:
*     Writes a string to the registry file stream.  A string is surrounded by
*     double quotes and some characters may be translated to escape sequences
*     to enable a parser to read the string back in.
*
*  PARAMETERS:
*     lpString, null-terminated string to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutString(
    LPCTSTR lpString
    )
{

    TCHAR Char;

    PutChar(TEXT('"'));

    while ((Char = *lpString++) != 0) {

        switch (Char) 
        {
            case TEXT('\r'):
                if(g_fMultiLineStrings) 
                {
                    PutChar('\\');
                    PutChar('r');
                }
                else 
                {
                    PutChar(Char);
                }
                break;

            case TEXT('\n'):
                if(g_fMultiLineStrings) 
                {
                    PutChar('\\');
                    PutChar('n');
                }
                else 
                {
                    PutChar(Char);
                }
                break;
            

            case TEXT('\\'):
            case TEXT('"'):
                PutChar(TEXT('\\'));
                //  FALL THROUGH

            default:
                PutChar(Char);
                break;

        }

    }

    PutChar(TEXT('"'));

}

/*******************************************************************************
*
*  PutBinary
*
*  DESCRIPTION:
*     Writes a sequence of hexadecimal bytes to the registry file stream.  The
*     output is formatted such that it doesn't exceed a defined line length.
*
*  PARAMETERS:
*     lpBuffer, bytes to write to file.
*     Type, value data type.
*     cbBytes, number of bytes to write.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutBinary(
    CONST BYTE FAR* lpBuffer,
    DWORD Type,
    DWORD cbBytes
    )
{

    BOOL fFirstByteOnLine;
    BYTE Byte;

    // If we're writing one of the string formats that regedit doesn't write
    // natively (but rather converts to a string of hex digits for streaming
    // out), AND we're writing in downlevel/ANSI/REGEDIT4 format, we aren't
    // going to write out the high byte of each (internally Unicode) character.
    // So we will be writing half as many characters as the buffer byte size.

    if ((g_RegEditData.uExportFormat == FILE_TYPE_REGEDIT4) &&
        ((Type == REG_EXPAND_SZ) || (Type == REG_MULTI_SZ))) {
        cbBytes = cbBytes / 2;
    }

    PutLiteral(s_HexPrefix);

    if (Type != REG_BINARY) {

        PutChar(TEXT('('));
        PutDword(Type, FALSE);
        PutChar(TEXT(')'));

    }

    PutChar(TEXT(':'));

    fFirstByteOnLine = TRUE;

    while (cbBytes--) {

        if (s_FileIo.CurrentColumn > 75 && !fFirstByteOnLine) {

            PutLiteral(s_FileLineBreak);

            fFirstByteOnLine = TRUE;

        }

        if (!fFirstByteOnLine)
            PutChar(TEXT(','));

        Byte = *lpBuffer++;

        // If we're writing one of the string formats that regedit doesn't
        // write natively (REG_EXPAND_SZ and REG_MULTI_SZ values get converted
        // to a string of hex digits for streaming out), AND we're writing in
        // downlevel/ANSI/REGEDIT4 format, we don't want to write out the high
        // byte of each (internally Unicode) character.  So in those cases, we
        // advance another byte to get to the next ANSI character.  Yes, this
        // will lose data on non-SBCS characters, but that's what you get for
        // saving in the downlevel format.

        if ((g_RegEditData.uExportFormat == FILE_TYPE_REGEDIT4) &&
            ((Type == REG_EXPAND_SZ) || (Type == REG_MULTI_SZ))) {
            lpBuffer++;
        }

        PutChar(g_HexConversion[Byte >> 4]);
        PutChar(g_HexConversion[Byte & 0x0F]);

        fFirstByteOnLine = FALSE;

    }

}

/*******************************************************************************
*
*  PutChar
*
*  DESCRIPTION:
*     Writes a 32-bit word to the registry file stream.
*
*  PARAMETERS:
*     Dword, dword to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutDword(
    DWORD Dword,
    BOOL fLeadingZeroes
    )
{

    int CurrentNibble;
    TCHAR Char;
    BOOL fWroteNonleadingChar;

    fWroteNonleadingChar = fLeadingZeroes;

    for (CurrentNibble = 7; CurrentNibble >= 0; CurrentNibble--) {

        Char = g_HexConversion[(Dword >> (CurrentNibble * 4)) & 0x0F];

        if (fWroteNonleadingChar || Char != TEXT('0')) {

            PutChar(Char);
            fWroteNonleadingChar = TRUE;

        }

    }

    //
    //  We need to write at least one character, so if we haven't written
    //  anything yet, just spit out one zero.
    //

    if (!fWroteNonleadingChar)
        PutChar(TEXT('0'));

}

/*******************************************************************************
*
*  PutChar
*
*  DESCRIPTION:
*     Writes one character to the registry file stream using an intermediate
*     buffer.
*
*  PARAMETERS:
*     Char, character to write to file.
*
*******************************************************************************/

VOID
NEAR PASCAL
PutChar(
    TCHAR Char
    )
{

    //
    //  Keep track of what column we're currently at.  This is useful in cases
    //  such as writing a large binary registry record.  Instead of writing one
    //  very long line, the other Put* routines can break up their output.
    //

    if (Char != TEXT('\n'))
        s_FileIo.CurrentColumn++;

    else {

        //
        //  Force a carriage-return, line-feed sequence to keep things like, oh,
        //  Notepad happy.
        //

        PutChar(TEXT('\r'));

        s_FileIo.CurrentColumn = 0;

    }

    s_FileIo.Buffer[s_FileIo.BufferOffset++] = Char;

    if (s_FileIo.BufferOffset == SIZE_FILE_IO_BUFFER)
        FlushIoBuffer();

}

/*******************************************************************************
*
*  FlushIoBuffer
*
*  DESCRIPTION:
*     Flushes the contents of the registry file stream to the disk and resets
*     the buffer pointer.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
NEAR PASCAL
FlushIoBuffer(
    VOID
    )
{

    DWORD NumberOfBytesWritten;

    if (s_FileIo.BufferOffset) 
    {
        if (g_RegEditData.uExportFormat == FILE_TYPE_REGEDIT4)
        {
            //
            // Convert Unicode to ANSI before writing.
            //

            int i;

            i = WideCharToMultiByte(
                    CP_THREAD_ACP,
                    0,
                    s_FileIo.Buffer,
                    s_FileIo.BufferOffset,
                    s_FileIo.ConversionBuffer,
                    sizeof(s_FileIo.ConversionBuffer),      // Number of bytes...
                    NULL,
                    NULL
                    );

            if (!WRITEFILE(s_FileIo.hFile, s_FileIo.ConversionBuffer, i, &NumberOfBytesWritten) 
                    ||  (DWORD) i != NumberOfBytesWritten)

                g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
        }
        else
        {
            //
            // Write Unicode text
            //
            if (!WRITEFILE(s_FileIo.hFile, s_FileIo.Buffer, s_FileIo.BufferOffset * sizeof(WCHAR), 
                            &NumberOfBytesWritten) 
                    || (DWORD) (s_FileIo.BufferOffset * sizeof(WCHAR)) != NumberOfBytesWritten)
            {
                g_FileErrorStringID = IDS_EXPFILEERRFILEWRITE;
            }
        }
    }

    s_FileIo.BufferOffset = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regporte.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPORTE.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        06 Apr 1994
*
*  File import and export engine routines for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGPORTE
#define _INC_REGPORTE



#ifndef LPHKEY
#define LPHKEY                          HKEY FAR*
#endif

// PREDEFINED KEYS
typedef enum _PREDEFINE_KEY {
  PREDEFINE_KEY_CLASSES_ROOT,
  PREDEFINE_KEY_CURRENT_USER,
  PREDEFINE_KEY_LOCAL_MACHINE,
  PREDEFINE_KEY_USERS,
  PREDEFINE_KEY_CURRENT_CONFIG
} PREDEFINE_KEY;

typedef struct _REGISTRY_ROOT {
    LPTSTR lpKeyName;
    HKEY hKey;
    PREDEFINE_KEY hPreDefKey;
}   REGISTRY_ROOT;

#define INDEX_HKEY_CLASSES_ROOT         0
#define INDEX_HKEY_CURRENT_USER         1
#define INDEX_HKEY_LOCAL_MACHINE        2
#define INDEX_HKEY_USERS                3
//  #define INDEX_HKEY_PERFORMANCE_DATA     4
#define INDEX_HKEY_CURRENT_CONFIG	    4
#define INDEX_HKEY_DYN_DATA		        5

//  #define NUMBER_REGISTRY_ROOTS		    7
#define NUMBER_REGISTRY_ROOTS		    6

//  WARNING:  This is supposed to be enough for one keyname plus one predefined
//  handle name.
#define SIZE_SELECTED_PATH              (MAXKEYNAME + 40)

extern const TCHAR g_HexConversion[];

extern UINT g_FileErrorStringID;

#define ERK_OPEN    0
#define ERK_CREATE  1
#define ERK_DELETE  2

HKEY  Regedit_GetRootKeyFromComputer(HTREEITEM hComputerItem, PTSTR pszFullKeyName);
DWORD EditRegistryKey(HTREEITEM hComputerItem, LPHKEY lphKey, LPTSTR lpFullKeyName, UINT uOperation);
VOID  ImportRegFile(HWND hWnd, LPTSTR lpFileName, HTREEITEM hComputerItem);
VOID  ExportWinNT50RegFile(LPTSTR lpFileName, LPTSTR lpSelectedPath);
void  ExportRegedt32File(LPTSTR lpFileName, LPTSTR lpSelectedPath);
VOID  ExportWin40RegFile(LPTSTR lpFileName, LPTSTR lpSelectedPath);
VOID  ImportRegFileUICallback(UINT uPercentage);
void  RestoreBinaryKeyFile(HWND hWnd, LPTSTR lpFileName);

#endif // _INC_REGPORTE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regobjpkr.cpp ===
//------------------------------------------------------------------------
//
//  Microsoft Windows Shell
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      regobjpkr.cpp
//
//  Contents:  The implementation of the object picker for regedit 
//
//  Classes:   none
//
//------------------------------------------------------------------------

#include <accctrl.h>
#include <objsel.h>
#include <TCHAR.h> 

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

extern "C" HRESULT SelectComputer(HWND hWnd, LPTSTR pszRemoteName, int cchMax);
HRESULT InitObjectPicker(IDsObjectPicker *pDsObjectPicker);
void    GetNameFromObject(IDataObject *pdo, LPTSTR pszName, int cchMax);


//------------------------------------------------------------------------------
//  SelectComputer
//
//  DESCRIPTION: Invokes the Object Picker and returns computer name
//
//  PARAMETERS:  hWnd - handle to parent window
//               pszRemoteName[OUT] - LPTSTR
//------------------------------------------------------------------------------
HRESULT SelectComputer(HWND hWnd, LPTSTR pszRemoteName, int cchMax)
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hr))
    {
        IDsObjectPicker *pDsObjectPicker = NULL;
        hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER, IID_IDsObjectPicker, (LPVOID*) &pDsObjectPicker);
        if (SUCCEEDED(hr))
        {
            hr = InitObjectPicker(pDsObjectPicker);
            if (SUCCEEDED(hr)) 
            {
                IDataObject *pdo = NULL;
                if (pDsObjectPicker->InvokeDialog(hWnd, &pdo) == S_OK)
                {
                    GetNameFromObject(pdo, pszRemoteName, cchMax);
                    pdo->Release();
                    hr = S_OK;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            pDsObjectPicker->Release();
        }    
        CoUninitialize();
    }
    return hr;   
}


//------------------------------------------------------------------------------
//  InitObjectPicker
//
//  DESCRIPTION: Initializes the InitObjectPicker
//
//  PARAMETERS:  pDsObjectPicker - pointer to object picker obj.
//------------------------------------------------------------------------------
HRESULT InitObjectPicker(IDsObjectPicker *pDsObjectPicker) 
{
    DSOP_SCOPE_INIT_INFO aScopeInit = {0};
    DSOP_INIT_INFO  InitInfo = {0};
    
    // Initialize the DSOP_SCOPE_INIT_INFO structure.
    aScopeInit.cbSize = sizeof(aScopeInit);

    aScopeInit.flType = DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN |
                        DSOP_SCOPE_TYPE_WORKGROUP |
                        DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN |
                        DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN |
                        DSOP_SCOPE_TYPE_GLOBAL_CATALOG |
                        DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN |
                        DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE |
                        DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;

    aScopeInit.FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    aScopeInit.FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    // Initialize the DSOP_INIT_INFO structure.
    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // Target is the local computer.
    InitInfo.cDsScopeInfos = 1;
    InitInfo.aDsScopeInfos = &aScopeInit;
 
    return pDsObjectPicker->Initialize(&InitInfo);
}


//------------------------------------------------------------------------------
//  GetNameFromObject
//
//  DESCRIPTION: Revieves the name of an object
//
//  PARAMETERS:  IDataObject - data object
//               pszName[OUT] - LPTSTR
//------------------------------------------------------------------------------
void GetNameFromObject(IDataObject *pdo, LPTSTR pszName, int cchMax)
{
    PDS_SELECTION_LIST pDsSelList = NULL;
    
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL, NULL};
    CLIPFORMAT cfDsObjectPicker = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
    FORMATETC formatetc = {cfDsObjectPicker, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    
    // Get the global memory block containing the user's selections.
    if (SUCCEEDED(pdo->GetData(&formatetc, &stgmedium)))
    {     
        // Retrieve pointer to DS_SELECTION_LIST structure.
        pDsSelList = (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);
        if (pDsSelList)
        {
            StringCchCopy(pszName, cchMax, pDsSelList->aDsSelection[0].pwzName);
            GlobalUnlock(stgmedium.hGlobal);
        }
        ReleaseStgMedium(&stgmedium);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regprint.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPRINT.C
*
*  VERSION:     4.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        21 Nov 1993
*
*  Print routines for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regprint.h"
#include "regcdhk.h"
#include "regresid.h"
#include "regedit.h"
#include "richedit.h"
#include "regporte.h"
#include "reg1632.h"
#include <malloc.h>

#include "regdebug.h"

extern void PrintResourceData(PBYTE pbData, UINT uSize, DWORD dwType);

const TCHAR s_PrintLineBreak[] = TEXT(",\n  ");

PRINTDLGEX g_PrintDlg;

typedef struct _PRINT_IO {
    BOOL fContinueJob;
    UINT ErrorStringID;
    HWND hRegPrintAbortWnd;
    RECT rcPage;
    RECT rcOutput;
    PTSTR pLineBuffer;
    UINT cch;
    UINT cBufferPos;
    LPTSTR lpNewLineChars;
}   PRINT_IO;

#define CANCEL_NONE                     0x0000
#define CANCEL_MEMORY_ERROR             0x0001
#define CANCEL_PRINTER_ERROR            0x0002
#define CANCEL_ABORT                    0x0004

#define INITIAL_PRINTBUFFER_SIZE        8192

PRINT_IO s_PrintIo;

BOOL
CALLBACK
RegPrintAbortProc(
    HDC hDC,
    int Error
    );

INT_PTR
CALLBACK
RegPrintAbortDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

void RegPrintSubtree();
void PrintBranch(HKEY hKey, LPTSTR lpFullKeyName);
void PrintKeyValues(HKEY hKey);
void PrintValueData(PBYTE pbValueData, DWORD cbValueData, DWORD dwType);
void PrintKeyHeader(HKEY hKey, LPTSTR lpFullKeyName);
void PrintClassName(HKEY hKey);
void PrintLastWriteTime(HKEY hKey);
void PrintDynamicString(UINT uStringID);
void PrintType(DWORD dwType);
void PrintBinaryData(PBYTE ValueData, UINT cbcbValueData);
void PrintDWORDData(PBYTE ValueData, UINT cbcbValueData);
void PrintLiteral(PTSTR lpLiteral);
BOOL PrintChar(TCHAR Char);
void PrintMultiString(LPTSTR pszData, int cbData);
UINT PrintToSubTreeError(UINT uPrintErrorStringID);
void PrintNewLine();

/*******************************************************************************
*
*  Implement IPrintDialogCallback
*
*  DESCRIPTION:
*     This interface is necessary to handle messages through PrintDlgEx
*     This interface doesn't need to have all the correct semantics of a COM
*     Object
*
*******************************************************************************/

typedef struct
{
    IPrintDialogCallback ipcb;
} CPrintCallback;

#define IMPL(type, pos, ptr) (type*)

static
HRESULT
CPrintCallback_QueryInterface(IPrintDialogCallback *ppcb, REFIID riid, void **ppv)
{
    CPrintCallback *this = (CPrintCallback*)ppcb;
    if (IsEqualIID (riid, &IID_IUnknown) || IsEqualIID (riid, &IID_IPrintDialogCallback))
        *ppv = &this->ipcb;
    else
    {
        *ppv = 0;
        return E_NOINTERFACE;
    }

    this->ipcb.lpVtbl->AddRef(&this->ipcb);
    return NOERROR;
}

static
ULONG
CPrintCallback_AddRef(IPrintDialogCallback *ppcb)
{
    CPrintCallback *this = (CPrintCallback*)ppcb;
    return 1;
}

static
ULONG
CPrintCallback_Release(IPrintDialogCallback *ppcb)
{
    CPrintCallback *this = (CPrintCallback*)ppcb;
    return 1;
}

static
HRESULT
CPrintCallback_InitDone(IPrintDialogCallback *ppcb)
{
    return S_OK;
}

static
HRESULT
CPrintCallback_SelectionChange(IPrintDialogCallback *ppcb)
{
    return S_OK;
}

static
HRESULT
CPrintCallback_HandleMessage(
    IPrintDialogCallback *ppcb,
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *pResult)
{
    *pResult = RegCommDlgHookProc(hDlg, uMsg, wParam, lParam);
    return S_OK;
}


static IPrintDialogCallbackVtbl vtblPCB =
{
    CPrintCallback_QueryInterface,
    CPrintCallback_AddRef,
    CPrintCallback_Release,
    CPrintCallback_InitDone,
    CPrintCallback_SelectionChange,
    CPrintCallback_HandleMessage
};

CPrintCallback g_callback;

/*******************************************************************************
*
*  RegEdit_OnCommandPrint
*
*  DESCRIPTION:
*     Handles the selection of the "Print" option by the user for the RegEdit
*     dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegPrint window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnCommandPrint(
    HWND hWnd
    )
{

    LPDEVNAMES lpDevNames;
    TEXTMETRIC TextMetric;
    DOCINFO DocInfo;
    LOGFONT lf;
    HGLOBAL hDevMode;
    HGLOBAL hDevNames;
    RECT rc;
    HWND hRichEdit;
    FORMATRANGE fr;
    HINSTANCE hInstRichEdit;
    int nOffsetX;
    int nOffsetY;
    PTSTR pszFontName;
    TCHAR szFullPathRichEdit[MAX_PATH+1];


    g_callback.ipcb.lpVtbl = &vtblPCB;

    // We have to completely fill out the PRINTDLGEX structure
    // correctly or the PrintDlgEx function will return an error.
    // The easiest way is to memset it to 0

    hDevMode = g_PrintDlg.hDevMode;
    hDevNames = g_PrintDlg.hDevNames;
    memset(&g_PrintDlg, 0, sizeof(g_PrintDlg));

    g_PrintDlg.lStructSize = sizeof(g_PrintDlg);
    // DebugAssert(g_PrintDlg.lStructSize == sizeof(PRINTDLGEX));
    g_PrintDlg.hwndOwner = hWnd;
    g_PrintDlg.hDevMode = hDevMode;
    g_PrintDlg.hDevNames = hDevNames;
    g_PrintDlg.hDC = NULL;
    g_PrintDlg.Flags = PD_NOPAGENUMS | PD_RETURNDC | PD_ENABLEPRINTTEMPLATE;
    g_PrintDlg.Flags2 = 0;
    g_PrintDlg.ExclusionFlags = 0;
    g_PrintDlg.hInstance = g_hInstance;
    g_PrintDlg.nCopies = 1;
    g_PrintDlg.nStartPage = START_PAGE_GENERAL;
    g_PrintDlg.lpCallback = (IUnknown*) &g_callback.ipcb;
    g_PrintDlg.lpPrintTemplateName = MAKEINTRESOURCE(IDD_REGPRINT);
    g_RegCommDlgDialogTemplate = IDD_REGPRINT;

    if (FAILED(PrintDlgEx(&g_PrintDlg)))
        return;
    if (g_PrintDlg.dwResultAction != PD_RESULT_PRINT)
        return;

    s_PrintIo.ErrorStringID = IDS_PRINTERRNOMEMORY;

    if ((lpDevNames = GlobalLock(g_PrintDlg.hDevNames)) == NULL)
        goto error_ShowDialog;

    //
    //  For now, assume a page with top and bottom margins of 1/2 inch and
    //  left and right margins of 3/4 inch (the defaults of Notepad).
    //  rcPage and rcOutput are in TWIPS (1/20th of a point)
    //

    rc.left = rc.top = 0;
    rc.bottom = GetDeviceCaps(g_PrintDlg.hDC, PHYSICALHEIGHT);
    rc.right = GetDeviceCaps(g_PrintDlg.hDC, PHYSICALWIDTH);
    nOffsetX = GetDeviceCaps(g_PrintDlg.hDC, PHYSICALOFFSETX);
    nOffsetY = GetDeviceCaps(g_PrintDlg.hDC, PHYSICALOFFSETY);

    s_PrintIo.rcPage.left = s_PrintIo.rcPage.top = 0;
    s_PrintIo.rcPage.right = MulDiv(rc.right, 1440, GetDeviceCaps(g_PrintDlg.hDC, LOGPIXELSX));
    s_PrintIo.rcPage.bottom = MulDiv(rc.bottom, 1440, GetDeviceCaps(g_PrintDlg.hDC, LOGPIXELSY));

    s_PrintIo.rcOutput.left = 1080;
    s_PrintIo.rcOutput.top = 720;
    s_PrintIo.rcOutput.right = s_PrintIo.rcPage.right - 1080;
    s_PrintIo.rcOutput.bottom = s_PrintIo.rcPage.bottom - 720;

    //
    //
    //

    if ((s_PrintIo.pLineBuffer = (PTSTR) LocalAlloc(LPTR, INITIAL_PRINTBUFFER_SIZE*sizeof(TCHAR))) == NULL)
        goto error_DeleteDC;
    s_PrintIo.cch = INITIAL_PRINTBUFFER_SIZE;
    s_PrintIo.cBufferPos = 0;

    if ((s_PrintIo.hRegPrintAbortWnd = CreateDialog(g_hInstance,
        MAKEINTRESOURCE(IDD_REGPRINTABORT), hWnd, RegPrintAbortDlgProc)) ==
        NULL)
        goto error_FreeLineBuffer;

    EnableWindow(hWnd, FALSE);

    //
    //  Prepare the document for printing.
    //
    s_PrintIo.ErrorStringID = 0;
    s_PrintIo.fContinueJob = TRUE;
    s_PrintIo.lpNewLineChars = TEXT("\n");
    SetAbortProc(g_PrintDlg.hDC, RegPrintAbortProc);

    DocInfo.cbSize = sizeof(DocInfo);
    // DebugAssert(DocInfo.cbSize == sizeof(DOCINFO));
    DocInfo.lpszDocName = LoadDynamicString(IDS_REGEDIT);
    DocInfo.lpszOutput = (LPTSTR) lpDevNames + lpDevNames-> wOutputOffset;
    DocInfo.lpszDatatype = NULL;
    DocInfo.fwType = 0;

    s_PrintIo.ErrorStringID = 0;

    if (StartDoc(g_PrintDlg.hDC, &DocInfo) <= 0) {

        if (GetLastError() != ERROR_PRINT_CANCELLED)
            s_PrintIo.ErrorStringID = IDS_PRINTERRPRINTER;
        goto error_DeleteDocName;

    }

    // Print registry subtree.
    RegPrintSubtree();

    if (s_PrintIo.ErrorStringID != 0)
    {
        InternalMessageBox(g_hInstance, hWnd,
            MAKEINTRESOURCE(s_PrintIo.ErrorStringID),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONERROR | MB_OK);
    }

    *szFullPathRichEdit = 0;
    if (GetSystemDirectory(szFullPathRichEdit, ARRAYSIZE(szFullPathRichEdit)))
    {
        if (!PathAppend(szFullPathRichEdit, TEXT("riched20.dll")))
        {
            *szFullPathRichEdit = 0;
        }
        szFullPathRichEdit[MAX_PATH] = 0;
    }

    if (!*szFullPathRichEdit)
    {
        StringCchCopy(szFullPathRichEdit, ARRAYSIZE(szFullPathRichEdit), TEXT("riched20.dll"));
    }

    hInstRichEdit = LoadLibrary(szFullPathRichEdit);

    hRichEdit = CreateWindowEx(0, RICHEDIT_CLASS, NULL, ES_MULTILINE, 0, 0, 100, 100, NULL, NULL, NULL, NULL);
    SendMessage(hRichEdit, WM_SETTEXT, 0, (LPARAM)s_PrintIo.pLineBuffer);

    pszFontName = LoadDynamicString(IDS_PRINT_FONT);
    if (pszFontName)
    {
        CHARFORMAT cf;

        cf.cbSize = sizeof(cf);
        cf.dwMask = CFM_FACE | CFM_BOLD;
        cf.dwEffects = 0x00;
        cf.bPitchAndFamily = FIXED_PITCH | FF_MODERN;
        StringCchPrintf(cf.szFaceName, ARRAYSIZE(cf.szFaceName), TEXT("%s"), pszFontName);

        SendMessage(hRichEdit, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);

        DeleteDynamicString(pszFontName);
    }

    fr.hdc = g_PrintDlg.hDC;
    fr.hdcTarget = g_PrintDlg.hDC;
    fr.rc = s_PrintIo.rcOutput;
    fr.rcPage = s_PrintIo.rcPage;
    fr.chrg.cpMin = 0;
    fr.chrg.cpMax = -1;

    while (fr.chrg.cpMin < (int) s_PrintIo.cBufferPos) {
        StartPage(g_PrintDlg.hDC);

        // We have to adjust the origin because 0,0 is not at the corner of the paper
        // but is at the corner of the printable region

        SetViewportOrgEx(g_PrintDlg.hDC, -nOffsetX, -nOffsetY, NULL);
        fr.chrg.cpMin = (LONG)SendMessage(hRichEdit, EM_FORMATRANGE, TRUE, (LPARAM)&fr);
        SendMessage(hRichEdit, EM_DISPLAYBAND, 0, (LPARAM)&s_PrintIo.rcOutput);
        EndPage(g_PrintDlg.hDC);
        if (!s_PrintIo.fContinueJob)
            break;
    }
    SendMessage(hRichEdit, EM_FORMATRANGE, FALSE, 0);

    //
    //  End the print job.
    //

    if (s_PrintIo.ErrorStringID == 0 && s_PrintIo.fContinueJob) {

        if (EndDoc(g_PrintDlg.hDC) <= 0) {
            s_PrintIo.ErrorStringID = IDS_PRINTERRPRINTER;
            goto error_AbortDoc;
        }
    }

    //
    //  Either a printer error occurred or the user cancelled the printing, so
    //  abort the print job.
    //

    else {

error_AbortDoc:
        AbortDoc(g_PrintDlg.hDC);

    }

    DestroyWindow(hRichEdit);
    FreeLibrary(hInstRichEdit);

error_DeleteDocName:
    DeleteDynamicString(DocInfo.lpszDocName);

//  error_DestroyRegPrintAbortWnd:
    EnableWindow(hWnd, TRUE);
    DestroyWindow(s_PrintIo.hRegPrintAbortWnd);

error_FreeLineBuffer:
    LocalFree((HLOCAL)s_PrintIo.pLineBuffer);

error_DeleteDC:
    DeleteDC(g_PrintDlg.hDC);
    g_PrintDlg.hDC = NULL;
    GlobalUnlock(g_PrintDlg.hDevNames);

error_ShowDialog:
    if (s_PrintIo.ErrorStringID != 0)
        InternalMessageBox(g_hInstance, hWnd,
            MAKEINTRESOURCE(s_PrintIo.ErrorStringID),
            MAKEINTRESOURCE(IDS_REGEDIT), MB_ICONERROR | MB_OK);

}


//------------------------------------------------------------------------------
// RegEdit_SaveAsSubtree
//
// DESCRIPTION: Saves a subtree to a file
//
// PARAMETERS: LPTSTR lpFileName - file name
//             LPTSTR lpSelectedPath - path to key
//------------------------------------------------------------------------------
UINT RegEdit_SaveAsSubtree(LPTSTR lpFileName, LPTSTR lpSelectedPath)
{
    s_PrintIo.pLineBuffer = (PTSTR) LocalAlloc(LPTR, INITIAL_PRINTBUFFER_SIZE*sizeof(TCHAR));
    if (s_PrintIo.pLineBuffer)
    {
        FILE_HANDLE hFile;

        // Init the printing info
        s_PrintIo.pLineBuffer[0] = 0xFEFF; //unicode byte order mark
        s_PrintIo.cch = INITIAL_PRINTBUFFER_SIZE;
        s_PrintIo.cBufferPos = 1;
        s_PrintIo.fContinueJob = TRUE;
        s_PrintIo.ErrorStringID = 0;
        s_PrintIo.lpNewLineChars = TEXT("\r\n");

        RegPrintSubtree();

        // write the buffer to the file
        if (OPENWRITEFILE(lpFileName, hFile))
        {
            DWORD cbWritten = 0;

            if (!WRITEFILE(hFile, s_PrintIo.pLineBuffer, s_PrintIo.cBufferPos*sizeof(TCHAR), &cbWritten))
            {
                s_PrintIo.ErrorStringID = IDS_EXPFILEERRFILEWRITE;
            }

            CloseHandle(hFile);
        }
        else
        {
            s_PrintIo.ErrorStringID = IDS_EXPFILEERRFILEOPEN;
        }

        LocalFree(s_PrintIo.pLineBuffer);
    }

    return PrintToSubTreeError(s_PrintIo.ErrorStringID);
}


//------------------------------------------------------------------------------
// PrintToSubTreeError
//
// DESCRIPTION: Prints a subtree
//
// PARAMETER: UINT uPrintErrorStringID - print error string id
//------------------------------------------------------------------------------
UINT PrintToSubTreeError(UINT uPrintErrorStringID)
{
    UINT uError = uPrintErrorStringID;

    switch (uPrintErrorStringID)
    {
    case IDS_PRINTERRNOMEMORY:
        uError = IDS_SAVETREEERRNOMEMORY;

    case IDS_PRINTERRCANNOTREAD:
        uError = IDS_SAVETREEERRCANNOTREAD;
    }

    return uError;
}


//------------------------------------------------------------------------------
// RegPrintSubtree
//
// DESCRIPTION: Prints a subtree
//------------------------------------------------------------------------------
void RegPrintSubtree()
{
    HTREEITEM hSelectedTreeItem = TreeView_GetSelection(g_RegEditData.hKeyTreeWnd);

    if (g_fRangeAll)
    {
        HTREEITEM hComputerItem = RegEdit_GetComputerItem(hSelectedTreeItem);

        StringCchCopy( g_SelectedPath, 
                        ARRAYSIZE(g_SelectedPath), 
                        g_RegistryRoots[INDEX_HKEY_LOCAL_MACHINE].lpKeyName);

        PrintBranch(Regedit_GetRootKeyFromComputer(hComputerItem, g_SelectedPath), g_SelectedPath);

        StringCchCopy( g_SelectedPath, 
                        ARRAYSIZE(g_SelectedPath),
                        g_RegistryRoots[INDEX_HKEY_USERS].lpKeyName);

        PrintBranch(Regedit_GetRootKeyFromComputer(hComputerItem, g_SelectedPath), g_SelectedPath);
    }
    else
    {
        HKEY hKey;

        if (EditRegistryKey(RegEdit_GetComputerItem(hSelectedTreeItem),
            &hKey, g_SelectedPath, ERK_OPEN) == ERROR_SUCCESS)
        {
            PrintBranch(hKey, g_SelectedPath);
            RegCloseKey(hKey);
        }
    }
}

/*******************************************************************************
*
*  RegPrintAbortProc
*
*  DESCRIPTION:
*     Callback procedure to check if the print job should be canceled.
*
*  PARAMETERS:
*     hDC, handle of printer device context.
*     Error, specifies whether an error has occurred.
*     (returns), TRUE to continue the job, else FALSE to cancel the job.
*
*******************************************************************************/

BOOL
CALLBACK
RegPrintAbortProc(
    HDC hDC,
    int Error
    )
{

    while (s_PrintIo.fContinueJob && MessagePump(s_PrintIo.hRegPrintAbortWnd))
        ;

    return s_PrintIo.fContinueJob;

    UNREFERENCED_PARAMETER(hDC);
    UNREFERENCED_PARAMETER(Error);

}

/*******************************************************************************
*
*  RegPrintAbortDlgProc
*
*  DESCRIPTION:
*     Callback procedure for the RegPrintAbort dialog box.
*
*  PARAMETERS:
*     hWnd, handle of RegPrintAbort window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

INT_PTR
CALLBACK
RegPrintAbortDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    switch (Message) {

        case WM_INITDIALOG:
            break;

        case WM_CLOSE:
        case WM_COMMAND:
            s_PrintIo.fContinueJob = FALSE;
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  PrintBranch
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void PrintBranch(HKEY hKey, LPTSTR lpFullKeyName)
{
    // Write out the section header.
    PrintKeyHeader(hKey, lpFullKeyName);

    // Print the vales for the key.
    PrintKeyValues(hKey);

    if (s_PrintIo.ErrorStringID == 0)
    {
        HKEY hSubKey;
        int nLenFullKey;
        DWORD EnumIndex = 0;
        LPTSTR lpSubKeyName;
        LPTSTR lpTempFullKeyName;
        int nLenTempFullKey;

        //  Write out all of the subkeys and recurse into them.

        //copy the existing key into a new buffer with enough room for the next key
        nLenFullKey = lstrlen(lpFullKeyName);
        nLenTempFullKey = nLenFullKey + MAXKEYNAME;
        __try
        {
            lpTempFullKeyName = (LPTSTR) alloca(nLenTempFullKey * sizeof(TCHAR));
        }
        // __except(EXCEPTION_EXECUTE_HANDLER)
        __except(GetExceptionCode() == STATUS_STACK_OVERFLOW)
        {
            _resetstkoflw();
            return;
        }

        StringCchCopy(lpTempFullKeyName, nLenTempFullKey, lpFullKeyName);
        lpSubKeyName = lpTempFullKeyName + nLenFullKey;
        *lpSubKeyName++ = TEXT('\\');
        *lpSubKeyName = 0;

        PrintNewLine();

        while (s_PrintIo.fContinueJob)
        {
            if (RegEnumKey(hKey, EnumIndex++, lpSubKeyName, MAXKEYNAME-1) != ERROR_SUCCESS)
                break;

            if(RegOpenKeyEx(hKey,lpSubKeyName,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,&hSubKey) == ERROR_SUCCESS)
            {

                PrintBranch(hSubKey, lpTempFullKeyName);
                RegCloseKey(hSubKey);
            }
            else
            {
                DebugPrintf(("RegOpenKey failed."));
            }

        }
    }
}


//------------------------------------------------------------------------------
// PrintKeyHeader
//
// DESCRIPTION: Prints the header information of a key
//
// PARAMETERS: HKEY hKey - key
//             LPTSTR lpFullKeyName - path to key
//------------------------------------------------------------------------------
void PrintKeyValues(HKEY hKey)
{
    DWORD EnumIndex = 0;

    //  Write out all of the value names and their data.
    while (s_PrintIo.fContinueJob)
    {
        DWORD Type;
        DWORD cbValueData;
        PBYTE pbValueData;
        TCHAR acAuxNumber[MAXVALUENAME_LENGTH];
        DWORD cchValueName = ARRAYSIZE(g_ValueNameBuffer);

        // Query for data size
        if (RegEnumValue(hKey, EnumIndex++, g_ValueNameBuffer,
            &cchValueName, NULL, &Type, NULL, &cbValueData) != ERROR_SUCCESS)
        {
            break;
        }

        // Print value number
        PrintDynamicString(IDS_PRINT_NUMBER);
        StringCchPrintf(acAuxNumber, ARRAYSIZE(acAuxNumber), TEXT("%d"), EnumIndex - 1);
        PrintLiteral(acAuxNumber);
        PrintNewLine();

        // Print key name
        PrintDynamicString(IDS_PRINT_NAME);
        if (cchValueName)
        {
            PrintLiteral(g_ValueNameBuffer);
        }
        else
        {
            PrintDynamicString(IDS_PRINT_NO_NAME);
        }
        PrintNewLine();

        // Print Type
        PrintType(Type);

        // allocate memory for data
        pbValueData =  LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
        if (pbValueData)
        {
            if (RegEdit_QueryValueEx(hKey, g_ValueNameBuffer,
                NULL, &Type, pbValueData, &cbValueData) == ERROR_SUCCESS)
            {
                PrintValueData(pbValueData, cbValueData, Type);
            }
            else
            {
                s_PrintIo.ErrorStringID = IDS_PRINTERRCANNOTREAD;
            }

            if (pbValueData)
            {
                LocalFree(pbValueData);
                pbValueData = NULL;
            }
        }
        else
        {
            s_PrintIo.ErrorStringID = IDS_PRINTERRNOMEMORY;
            break;
        }
    }
}


//------------------------------------------------------------------------------
// PrintValueData
//
// DESCRIPTION: Prints the header information of a key
//
// PARAMETERS: pbValueData - byte data
//             cbValueData - count of bytes
//             dwType - data type
//------------------------------------------------------------------------------
void PrintValueData(PBYTE pbValueData, DWORD cbValueData, DWORD dwType)
{
    PrintDynamicString(IDS_PRINT_DATA);

    switch (dwType)
    {
    case REG_MULTI_SZ:
        PrintMultiString((LPTSTR)pbValueData, cbValueData);
        break;

    case REG_SZ:
    case REG_EXPAND_SZ:
        PrintLiteral((LPTSTR)pbValueData);
        PrintNewLine();
        break;

    case REG_DWORD:
        PrintDWORDData((PBYTE)pbValueData, cbValueData);
        break;

    case REG_RESOURCE_LIST:
    case REG_FULL_RESOURCE_DESCRIPTOR:
    case REG_RESOURCE_REQUIREMENTS_LIST:
        PrintResourceData((PBYTE)pbValueData, cbValueData, dwType);
        break;

    default:
        PrintBinaryData((PBYTE)pbValueData, cbValueData);
        break;
    }

    PrintNewLine();
}


//------------------------------------------------------------------------------
// PrintKeyHeader
//
// DESCRIPTION: Prints the header information of a key
//
// PARAMETERS: HKEY hKey - key
//             LPTSTR lpFullKeyName - path to key
//------------------------------------------------------------------------------
void PrintKeyHeader(HKEY hKey, LPTSTR lpFullKeyName)
{
    PrintDynamicString(IDS_PRINT_KEY_NAME);
    PrintLiteral(lpFullKeyName);
    PrintNewLine();

    PrintClassName(hKey);
    PrintLastWriteTime(hKey);
}


//------------------------------------------------------------------------------
// PrintClassName
//
// DESCRIPTION: Prints the class name
//
// PARAMETERS: HKEY hKey - key
//------------------------------------------------------------------------------
void PrintClassName(HKEY hKey)
{
    PTSTR pszClass;

    PrintDynamicString(IDS_PRINT_CLASS_NAME);

    pszClass = LocalAlloc(LPTR, ALLOCATION_INCR);
    if (pszClass)
    {
        HRESULT hr;
        DWORD cbClass = sizeof(pszClass);

        hr = RegQueryInfoKey(hKey, pszClass, &cbClass, NULL, NULL, NULL, NULL, NULL,
            NULL, NULL, NULL, NULL);

        if (hr == ERROR_MORE_DATA)
        {
            // need a bigger buffer
            PBYTE pbValueData = LocalReAlloc(pszClass, cbClass + 1, LMEM_MOVEABLE);
            if (pbValueData)
            {
                pszClass = (PTSTR)pbValueData;
                hr = RegQueryInfoKey(hKey, pszClass, &cbClass, NULL, NULL, NULL, NULL, NULL,
                    NULL, NULL, NULL, NULL);
            }
        }

        if (cbClass && (hr == ERROR_SUCCESS))
        {
            PrintLiteral(pszClass);
        }
        else
        {
            PrintDynamicString(IDS_PRINT_NO_CLASS);
        }

        LocalFree(pszClass);
    }

    PrintNewLine();
}


//------------------------------------------------------------------------------
// PrintLastWriteTime
//
// DESCRIPTION: Prints the last write time
//
// PARAMETERS: HKEY hKey - key
//------------------------------------------------------------------------------
void PrintLastWriteTime(HKEY hKey)
{
    FILETIME ftLastWriteTime;

    PrintDynamicString(IDS_PRINT_LAST_WRITE_TIME);

    if (RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
            NULL, NULL, NULL, &ftLastWriteTime) == ERROR_SUCCESS)
    {
        FILETIME ftLocalLastWriteTime;
        if (FileTimeToLocalFileTime(&ftLastWriteTime, &ftLocalLastWriteTime))
        {
            SYSTEMTIME stLastWriteTime;
            if (FileTimeToSystemTime(&ftLocalLastWriteTime, &stLastWriteTime))
            {
                TCHAR achData[50];
                TCHAR achTime[50];

                GetDateFormat(GetSystemDefaultLCID(), DATE_SHORTDATE, &stLastWriteTime,
                    NULL, achData, ARRAYSIZE(achData));

                GetTimeFormat(GetSystemDefaultLCID(), TIME_NOSECONDS, &stLastWriteTime,
                    NULL, achTime, ARRAYSIZE(achTime));

                PrintLiteral(achData);
                PrintLiteral(TEXT(" - "));
                PrintLiteral(achTime);
            }
        }
    }

    PrintNewLine();
}


//------------------------------------------------------------------------------
// PrintDynamicString
//
// DESCRIPTION: Prints the dynamic string
//
// PARAMETERS: UINT uStringID - resource string id
//------------------------------------------------------------------------------
void PrintDynamicString(UINT uStringID)
{
    PTSTR psz = LoadDynamicString(uStringID);
    if (psz)
    {
        PrintLiteral(psz);
        DeleteDynamicString(psz);
    }
}


//------------------------------------------------------------------------------
// PrintType
//
// DESCRIPTION: Prints the value type
//
// PARAMETERS: HKEY hKey - key
//------------------------------------------------------------------------------
void PrintType(DWORD dwType)
{
    UINT uTypeStringId;

    switch (dwType)
    {
    case REG_NONE:
        uTypeStringId = IDS_PRINT_TYPE_REG_NONE;
        break;
    case REG_SZ:
        uTypeStringId = IDS_PRINT_TYPE_REG_SZ;
        break;
    case REG_EXPAND_SZ:
        uTypeStringId = IDS_PRINT_TYPE_REG_EXPAND_SZ;
        break;
    case REG_BINARY:
        uTypeStringId = IDS_PRINT_TYPE_REG_BINARY;
        break;
    case REG_DWORD:
        uTypeStringId = IDS_PRINT_TYPE_REG_DWORD;
        break;
    case REG_LINK:
        uTypeStringId = IDS_PRINT_TYPE_REG_LINK;
        break;
    case REG_MULTI_SZ:
        uTypeStringId = IDS_PRINT_TYPE_REG_MULTI_SZ;
        break;
    case REG_RESOURCE_LIST:
        uTypeStringId = IDS_PRINT_TYPE_REG_RESOURCE_LIST;
        break;
    case REG_FULL_RESOURCE_DESCRIPTOR:
        uTypeStringId = IDS_PRINT_TYPE_REG_FULL_RESOURCE_DESCRIPTOR;
        break;
    case REG_RESOURCE_REQUIREMENTS_LIST:
        uTypeStringId = IDS_PRINT_TYPE_REG_RESOURCE_REQUIREMENTS_LIST;
        break;
    case REG_QWORD:
        uTypeStringId = IDS_PRINT_TYPE_REG_REG_QWORD;
        break;
    default:
        uTypeStringId = IDS_PRINT_TYPE_REG_UNKNOWN;
    }

    PrintDynamicString(IDS_PRINT_TYPE);
    PrintDynamicString(uTypeStringId);
    PrintNewLine();
}


/*******************************************************************************
*
*  PrintLiteral
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/
VOID PrintLiteral(PTSTR lpLiteral)
{
    if (s_PrintIo.fContinueJob)
        while (*lpLiteral != 0 && PrintChar(*lpLiteral++));
}


//------------------------------------------------------------------------------
// PrintBinaryData
//
// DESCRIPTION:  Print a string that contains the binary data
//
// PARAMETERS:   ValueData - Buffer that contains the binary data
//               cbValueData - Number of bytes in the buffer
//------------------------------------------------------------------------------
void PrintBinaryData(PBYTE ValueData, UINT cbValueData)
{
    DWORD   dwDataIndex;
    DWORD   dwDataIndex2 = 0; //tracks multiples of 16.

    if (cbValueData && ValueData)
    {
        // Display rows of 16 bytes of data.
        TCHAR achAuxData[80];

        PrintNewLine();

        for(dwDataIndex = 0;
            dwDataIndex < ( cbValueData >> 4 );
            dwDataIndex++,
            dwDataIndex2 = dwDataIndex << 4 )
        {
            //  The string that contains the format in the sprintf below
            //  cannot be broken because cfront  on mips doesn't like it.
            StringCchPrintf(achAuxData,
                     ARRAYSIZE(achAuxData),
                     TEXT("%08x   %02x %02x %02x %02x %02x %02x %02x %02x - %02x %02x %02x %02x %02x %02x %02x %02x  %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c"),
                     dwDataIndex2,
                     ValueData[ dwDataIndex2 + 0  ],
                     ValueData[ dwDataIndex2 + 1  ],
                     ValueData[ dwDataIndex2 + 2  ],
                     ValueData[ dwDataIndex2 + 3  ],
                     ValueData[ dwDataIndex2 + 4  ],
                     ValueData[ dwDataIndex2 + 5  ],
                     ValueData[ dwDataIndex2 + 6  ],
                     ValueData[ dwDataIndex2 + 7  ],
                     ValueData[ dwDataIndex2 + 8  ],
                     ValueData[ dwDataIndex2 + 9  ],
                     ValueData[ dwDataIndex2 + 10 ],
                     ValueData[ dwDataIndex2 + 11 ],
                     ValueData[ dwDataIndex2 + 12 ],
                     ValueData[ dwDataIndex2 + 13 ],
                     ValueData[ dwDataIndex2 + 14 ],
                     ValueData[ dwDataIndex2 + 15 ],
                     iswprint( ValueData[ dwDataIndex2 + 0  ] ) ? ValueData[ dwDataIndex2 + 0  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 1  ] ) ? ValueData[ dwDataIndex2 + 1  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 2  ] ) ? ValueData[ dwDataIndex2 + 2  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 3  ] ) ? ValueData[ dwDataIndex2 + 3  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 4  ] ) ? ValueData[ dwDataIndex2 + 4  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 5  ] ) ? ValueData[ dwDataIndex2 + 5  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 6  ] ) ? ValueData[ dwDataIndex2 + 6  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 7  ] ) ? ValueData[ dwDataIndex2 + 7  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 8  ] ) ? ValueData[ dwDataIndex2 + 8  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 9  ] ) ? ValueData[ dwDataIndex2 + 9  ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 10 ] ) ? ValueData[ dwDataIndex2 + 10 ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 11 ] ) ? ValueData[ dwDataIndex2 + 11 ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 12 ] ) ? ValueData[ dwDataIndex2 + 12 ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 13 ] ) ? ValueData[ dwDataIndex2 + 13 ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 14 ] ) ? ValueData[ dwDataIndex2 + 14 ]  : TEXT('.'),
                     iswprint( ValueData[ dwDataIndex2 + 15 ] ) ? ValueData[ dwDataIndex2 + 15 ]  : TEXT('.'));

            PrintLiteral(achAuxData);
            PrintNewLine();
        }

        // If the cbValueData is not an even multiple of 16
        // then there is one additonal line of data to display.
        if( cbValueData % 16 != 0 )
        {
            UINT cchBlanks = 0;
            UINT uLinePos = 0;
            DWORD dwSeperatorChars = 0;
            UINT  uIndex = StringCchPrintf(achAuxData, ARRAYSIZE(achAuxData), TEXT("%08x   "), dwDataIndex << 4 );

            // Display the remaining data, one byte at a time in hex.
            for( dwDataIndex = dwDataIndex2; dwDataIndex < cbValueData; dwDataIndex++ )
            {
                uIndex += wsprintf((achAuxData + uIndex ), TEXT("%02x "), ValueData[dwDataIndex]);

                // If eight data values have been displayed, print the seperator.
                if( dwDataIndex % 8 == 7 )
                {
                    uIndex += wsprintf( &achAuxData[uIndex], TEXT("%s"), TEXT("- "));
                    // Remember that two seperator characters were displayed.
                    dwSeperatorChars = 2;
                }
            }

            // Fill with blanks to the printable characters position.
            // That is position 64 less 8 spaces for the 'address',
            // 3 blanks, 3 spaces for each value displayed, possibly
            // two for the seperator plus two blanks at the end.
            uLinePos = (8 + 3 + (( dwDataIndex % 16 ) * 3 ) + dwSeperatorChars + 2 );
            uLinePos = min(uLinePos, 64);

            for(cchBlanks = 64 - uLinePos;
                cchBlanks > 0;
                cchBlanks--)
            {
                achAuxData[uIndex++] = TEXT(' ');
            }

            // Display the remaining data, one byte at a time as
            // printable characters.
            for( dwDataIndex = dwDataIndex2; dwDataIndex < cbValueData; dwDataIndex++ )
            {
                uIndex += wsprintf(&achAuxData[ uIndex ],
                                  TEXT("%c"),
                                  iswprint( ValueData[ dwDataIndex ] )
                                   ? ValueData[ dwDataIndex ] : TEXT('.'));

            }
            PrintLiteral(achAuxData);
        }
    }
    PrintNewLine();
}


//------------------------------------------------------------------------------
// PrintDWORDData
//
// DESCRIPTION:  Prints a DWORD
//
// PARAMETERS:   ValueData - Buffer that contains the binary data
//               cbValueData - Number of bytes in the buffer
//------------------------------------------------------------------------------
void PrintDWORDData(PBYTE ValueData, UINT cbValueData)
{
    DWORD dwData = *((PDWORD)ValueData);
    if (cbValueData && ValueData)
    {
        TCHAR achAuxData[20]; // the largest dword string is only 8 hex digits

        StringCchPrintf(achAuxData, ARRAYSIZE(achAuxData), TEXT("%#x"), dwData);

        PrintLiteral(achAuxData);
    }
    PrintNewLine();
}

/*******************************************************************************
*
*  PrintChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL PrintChar(TCHAR Char)
{
    //
    //  Keep track of what column we're currently at.  This is useful in cases
    //  such as writing a large binary registry record.  Instead of writing one
    //  very long line, the other Print* routines can break up their output.
    //

    if (s_PrintIo.cBufferPos == s_PrintIo.cch) 
    {
        PTSTR pNewBuffer = LocalAlloc(LPTR, 2*s_PrintIo.cch*sizeof(TCHAR));

        if (pNewBuffer == NULL)
            return FALSE;

        memcpy(pNewBuffer, s_PrintIo.pLineBuffer, s_PrintIo.cch*sizeof(TCHAR));

        LocalFree(s_PrintIo.pLineBuffer);

        s_PrintIo.pLineBuffer = pNewBuffer;
        s_PrintIo.cch *= 2;
    }

    s_PrintIo.pLineBuffer[s_PrintIo.cBufferPos++] = Char;

    return TRUE;
}


//------------------------------------------------------------------------------
//  PrintMultiString
//
//  DESCRIPTION: Prints a multi-string
//
//  PARAMETERS:  pszData - string
//               cbData  - number of bytes in string, including nulls
//------------------------------------------------------------------------------

VOID PrintMultiString(LPTSTR pszData, int cbData)
{
    if (s_PrintIo.fContinueJob)
    {
        int i = 0;
        int ccData = (cbData / sizeof(TCHAR)) - 2; // don't want last null of last string or multi-string

        for(i = 0; i < ccData; i++)
        {
            if (pszData[i] == TEXT('\0'))
            {
                PrintNewLine();
                PrintDynamicString(IDS_PRINT_KEY_NAME_INDENT);
            }
            else
            {
                PrintChar(pszData[i]);
            }
        }
    }
    PrintNewLine();
}


//------------------------------------------------------------------------------
//  PrintNewLine()
//
//  DESCRIPTION: Prints the newline chars.
//
//  PARAMETERS:  pszData - string
//               cbData  - number of bytes in string, including nulls
//------------------------------------------------------------------------------
void PrintNewLine()
{
    PrintLiteral(s_PrintIo.lpNewLineChars);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regprint.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGPRINT.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Print routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGPRINT
#define _INC_REGPRINT

extern PRINTDLGEX g_PrintDlg;

void RegEdit_OnCommandPrint(HWND hWnd);
UINT RegEdit_SaveAsSubtree(LPTSTR lpFileName, LPTSTR lpSelectedPath);

#endif // _INC_REGPRINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regresed.h ===
//------------------------------------------------------------------------
//
//  Microsoft Windows Shell
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      regresed.h
//
//  Contents:  REG_RESOURCE_LIST for regedit 
//
//  Classes:   none
//
//------------------------------------------------------------------------

#ifndef _INC_REGRESED
#define _INC_REGRESED

INT_PTR CALLBACK EditResourceListDlgProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);
BOOL    EditResourceList_OnInitDialog(HWND hWnd, HWND hFocusWnd, LPARAM lParam);

#endif // _INC_REGSTRED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regprintres.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regprintres.hxx

Abstract:

    This module contains the declarations for the PRINT_MANAGER class.
    The PRINT_RESOURCE class is responsible for displayning the Printer
    Setup Dialog, for printing a registry.


Author:

    Jaime Sasson (jaimes) 18-Sep-1991


Environment:



--*/


#if !defined( _PRINT_RESOURCE_ )

#define _PRINT_RESOURCE_

// don't let ntdddisk.h (included in ulib.hxx") 
// redefine values
#define _NTDDDISK_H_

#include "ulib.hxx"
#include "wstring.hxx"
#include "regresls.hxx"
#include "regfdesc.hxx"
#include "regdesc.hxx"
#include "regioreq.hxx"
#include "regiodls.hxx"
#include "regiodsc.hxx"


DECLARE_CLASS( PRINT_RESOURCE );


class PRINT_RESOURCE : public OBJECT 
{
    public:
        DECLARE_CONSTRUCTOR( PRINT_RESOURCE );
        DECLARE_CAST_MEMBER_FUNCTION( PRINT_RESOURCE );

        STATIC void _PrintResources(PBYTE pbData, UINT uSize, DWORD dwType);

    private:
        STATIC BOOL _InitializeStrings();
        STATIC void _PrintDataRegResourceList(PBYTE Data, UINT Size);
        STATIC BOOL _PrintFullResourceDescriptor(PCFULL_DESCRIPTOR FullDescriptor,
            UINT DescriptorNumber, BOOL PrintDescriptorNumber DEFAULT TRUE);
        STATIC BOOL _PrintPartialDescriptor(PCPARTIAL_DESCRIPTOR PartialDescriptor,
            ULONG DescriptorNumber);
        STATIC BOOL _PrintInterruptDescriptor(PCINTERRUPT_DESCRIPTOR Descriptor);
        STATIC BOOL _PrintPortDescriptor(PCPORT_DESCRIPTOR Descriptor);
        STATIC BOOL _PrintMemoryDescriptor(PCMEMORY_DESCRIPTOR   Descriptor);
        STATIC BOOL _PrintDmaDescriptor(PCDMA_DESCRIPTOR   Descriptor);
        STATIC BOOL _PrintDeviceSpecificDescriptor(PCDEVICE_SPECIFIC_DESCRIPTOR   Descriptor);
        STATIC BOOL _PrintDataRegRequirementsList(PBYTE Data, ULONG Size);
        STATIC BOOL _PrintIoResourceList(PCIO_DESCRIPTOR_LIST DescriptorList, UINT ListNumber);
        STATIC BOOL _PrintIoDescriptor(PCIO_DESCRIPTOR IoDescriptor, ULONG DescriptorNumber);
        STATIC BOOL _PrintIoInterruptDescriptor(PCIO_INTERRUPT_DESCRIPTOR Descriptor);
        STATIC BOOL _PrintIoPortDescriptor(PCIO_PORT_DESCRIPTOR Descriptor);
        STATIC BOOL _PrintIoMemoryDescriptor(PCIO_MEMORY_DESCRIPTOR Descriptor);
        STATIC BOOL _PrintIoDmaDescriptor(PCIO_DMA_DESCRIPTOR Descriptor);

        STATIC BOOL        s_StringsInitialized;
        STATIC PWSTRING    s_IndentString;
        STATIC PWSTRING    s_StringFullDescriptor;
        STATIC PWSTRING    s_StringInterfaceType;
        STATIC PWSTRING    s_StringBusNumber;
        STATIC PWSTRING    s_StringVersion;
        STATIC PWSTRING    s_StringRevision;
        STATIC PWSTRING    s_EmptyLine;
        STATIC PWSTRING    s_StringPartialDescriptor;
        STATIC PWSTRING    s_StringResource;
        STATIC PWSTRING    s_StringDisposition;
        STATIC PWSTRING    s_StringVector;
        STATIC PWSTRING    s_StringLevel;
        STATIC PWSTRING    s_StringAffinity;
        STATIC PWSTRING    s_StringType;
        STATIC PWSTRING    s_StringStart;
        STATIC PWSTRING    s_StringLength;
        STATIC PWSTRING    s_StringChannel;
        STATIC PWSTRING    s_StringPort;
        STATIC PWSTRING    s_StringReserved1;
        STATIC PWSTRING    s_StringReserved2;
        STATIC PWSTRING    s_StringDevSpecificData;
        STATIC PWSTRING    s_StringIoInterfaceType;
        STATIC PWSTRING    s_StringIoBusNumber;
        STATIC PWSTRING    s_StringIoSlotNumber;
        STATIC PWSTRING    s_StringIoListNumber;
        STATIC PWSTRING    s_StringIoDescriptorNumber;
        STATIC PWSTRING    s_StringIoOption;
        STATIC PWSTRING    s_StringIoMinimumVector;
        STATIC PWSTRING    s_StringIoMaximumVector;
        STATIC PWSTRING    s_StringIoMinimumAddress;
        STATIC PWSTRING    s_StringIoMaximumAddress;
        STATIC PWSTRING    s_StringIoAlignment;
        STATIC PWSTRING    s_StringIoMinimumChannel;
        STATIC PWSTRING    s_StringIoMaximumChannel;
};

extern "C" 
{
    VOID PrintResourceData(PBYTE pbData, UINT uSize, DWORD dwType);
}


#endif // _PRINT_RESOURCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regresid.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGRESID.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Resource identifiers for the Registry Editor.
*
*******************************************************************************/

#ifndef _INC_REGRESID
#define _INC_REGRESID

#define HEXEDIT_CLASSNAME               TEXT("HEX")

//
//
//

#define IDD_REGEXPORT                   100
#define IDD_REGPRINT                    108
#define IDD_INPUTHIVENAME               104

#define IDC_FIRSTREGCOMMDLGID           1280
#define IDC_RANGEALL                    1280
#define IDC_RANGESELECTEDPATH           1281
#define IDC_SELECTEDPATH                1282
#define IDC_EXPORTRANGE                 1283
#define IDC_LASTREGCOMMDLGID            1283

//
//
//

#define IDD_EDITSTRINGVALUE             102
#define IDD_EDITBINARYVALUE             103
#define IDD_EDITDWORDVALUE              111
#define IDD_EDITMULTISZVALUE            114
#define IDD_RESOURCE_LIST               116

#define IDC_VALUENAME                   1000
#define IDC_VALUEDATA                   1001
#define IDC_HEXADECIMAL                 1002
#define IDC_DECIMAL                     1003

// RESOURCE_LIST
#define IDC_LIST_DRIVES                     1201
#define IDC_PUSH_DRIVE_DETAILS              1202
#define IDC_PUSH_DISPLAY_RESOURCES          1203
#define IDC_PUSH_DISPLAY_DATA               1204
#define IDC_LIST_RESOURCE_LISTS             1205

#define IDC_FULL_RES_TEXT_BUS_NUMBER        1300
#define IDC_FULL_RES_TEXT_VERSION           1301
#define IDC_FULL_RES_TEXT_REVISION          1302
#define IDC_FULL_RES_TEXT_INTERFACE_TYPE    1303
#define IDC_FULL_RES_LIST_DEVICE_SPECIFIC   1304
#define IDD_FULL_RES_DESCRIPTOR             1305
#define IDC_FULL_RES_LIST_DMA               1306
#define IDC_FULL_RES_LIST_INTERRUPTS        1307
#define IDC_FULL_RES_LIST_MEMORY            1308
#define IDC_FULL_RES_LIST_PORTS             1309
#define IDC_FULL_RES_TEXT_UNDETERMINED      1310
#define IDC_FULL_RES_TEXT_SHARED            1311
#define IDC_FULL_RES_TEXT_DEVICE_EXCLUSIVE  1312
#define IDC_FULL_RES_TEXT_DRIVER_EXCLUSIVE  1313

#define IDD_IO_REQUIREMENT_LISTS            1401
#define IDD_IO_REQ_INTERFACE_TYPE           1402
#define IDD_IO_REQ_BUS_NUMBER               1403
#define IDD_IO_REQ_SLOT_NUMBER              1404

#define IDD_IO_REQUIREMENTS_LIST            1501
#define IDC_IO_LIST_ALTERNATIVE_LISTS       1502
#define IDC_IO_REQ_TEXT_INTERFACE_TYPE      1503
#define IDC_IO_REQ_TEXT_BUS_NUMBER          1504
#define IDC_IO_REQ_TEXT_SLOT_NUMBER         1505
#define IDC_IO_REQ_PUSH_DISPLAY_DEVICE      1506

#define IDD_IO_MEMORY_RESOURCE              1601
#define IDC_IO_TEXT_MEM_ACCESS              1602
#define IDC_IO_TEXT_MEM_LENGTH              1603
#define IDC_IO_TEXT_MEM_MIN_ADDRESS         1604
#define IDC_IO_TEXT_MEM_MAX_ADDRESS         1605
#define IDC_IO_TEXT_MEM_ALIGNMENT           1606

#define IDD_IO_PORT_RESOURCE                1700
#define IDC_IO_TEXT_PORT_TYPE               1701
#define IDC_IO_TEXT_PORT_LENGTH             1703
#define IDC_IO_TEXT_PORT_MIN_ADDRESS        1704
#define IDC_IO_TEXT_PORT_MAX_ADDRESS        1705
#define IDC_IO_TEXT_PORT_ALIGNMENT          1706

#define IDD_IO_INTERRUPT_RESOURCE           1800
#define IDC_IO_TEXT_INT_TYPE                1801
#define IDC_IO_TEXT_INT_MIN_VECTOR          1803
#define IDC_IO_TEXT_INT_MAX_VECTOR          1804

#define IDD_IO_DMA_RESOURCE                 1900
#define IDC_IO_TEXT_DMA_MIN_CHANNEL         1902
#define IDC_IO_TEXT_DMA_MAX_CHANNEL         1903

#define IDC_IO_TEXT_DISPOSITION             2000
#define IDC_IO_TEXT_OPTION_PREFERRED        2001
#define IDC_IO_TEXT_OPTION_ALTERNATIVE      2002

// Display binary data
#define IDD_DISPLAY_BINARY_DATA             2020
#define IDD_DISPLAY_BINARY_DATA_VALUE_TYPE  2021
#define IDD_DISPLAY_DATA_BINARY             2022
#define IDC_BINARY_DATA_BYTE                2023
#define IDC_BINARY_DATA_WORD                2024
#define IDC_BINARY_DATA_DWORD               2025
#define IDT_VALUE_TYPE                      2026

//
//
//

#define IDC_REMOTENAME                  1100
#define IDC_BROWSE                      1101

//
//
//

#define IDD_REGPRINTABORT               105

//
//  Dialog box for the Edit-> Find... menu option.
//

#define IDD_REGFIND                     106

#define IDC_FINDWHAT                    1150
#define IDC_WHOLEWORDONLY               1151
//  NOTE: The flags IDC_FOR* must be consecutive.
#define IDC_FORKEYS                     1152
#define IDC_FORVALUES                   1153
#define IDC_FORDATA                     1154
#define IDC_GROUPBOX                    1160

#define IDD_REGDISCONNECT               107
#define IDC_REMOTELIST                  1175

//
//  Dialog box for the find abort.
//
#define IDD_REGFINDABORT                109

//
// Dialog boxes for adding/removing a favorite
//
#define IDD_ADDFAVORITE			112
#define IDC_FAVORITENAME		1190
#define IDD_REMFAVORITE			113
#define IDC_FAVORITES			1191

//
//  Dialog box for Import Registry File progress display.
//

#define IDD_REGPROGRESS                 110
#define IDD_REGIMPORTNET                115

#define IDC_FILENAME                    100
#define IDC_PROGRESSBAR                 101
#define IDC_COMPUTERLIST                102

//
//  Menu resource identifiers.
//

#define IDM_REGEDIT                     103
#define IDM_KEY_CONTEXT                 104
#define IDM_VALUE_CONTEXT               105
#define IDM_VALUELIST_NOITEM_CONTEXT    106
#define IDM_COMPUTER_CONTEXT            107

//
//  HexEdit context menu identifier and items.  The IDKEY_* identifier
//  correspond to the WM_CHAR message that it corresponds to.  For example,
//  IDKEY_COPY would send a control-c to the HexEdit_OnChar routine.
//

#define IDM_HEXEDIT_CONTEXT             108

#define IDKEY_COPY                      3
#define IDKEY_PASTE                     22
#define IDKEY_CUT                       24
#define ID_SELECTALL                    0x0400

//
//  Popup menu item identifiers.  Used to determine the context menu help
//  string.
//

#define ID_FIRSTMENUPOPUPITEM           0x0200
#define ID_LASTMENUPOPUPITEM            0x027F

#define IDMP_REGISTRY                   0x0200
#define IDMP_EDIT                       0x0201
#define IDMP_VIEW                       0x0202
#define IDMP_HELP                       0x0203
#define IDMP_NEW                        0x0204
#define IDMP_FAVORITES			        0x0205

//
//  Main menu items.  If any of these items are selected from a context menu,
//  they will be automatically routed to the main window's command handler.
//

#define ID_FIRSTMAINMENUITEM            0x0280
#define ID_LASTMAINMENUITEM             0x02FF

//  Following are really keyboard accelerators.
#define ID_CYCLEFOCUS                   (ID_FIRSTMAINMENUITEM + 0x0000)

//  IMPORTANT:  Do not change the position of this identifier.  If Regedit is
//  already running and Regedit is then invoked through its commandline
//  interface, then the second instance will send a WM_COMMAND message with this
//  identifier to force a refresh.
#define ID_REFRESH                      (ID_FIRSTMAINMENUITEM + 0x0008)

#define ID_CONNECT                      (ID_FIRSTMAINMENUITEM + 0x0011)
#define ID_IMPORTREGFILE                (ID_FIRSTMAINMENUITEM + 0x0012)
#define ID_EXPORTREGFILE                (ID_FIRSTMAINMENUITEM + 0x0013)
#define ID_PRINT                        (ID_FIRSTMAINMENUITEM + 0x0014)
#define ID_EXIT                         (ID_FIRSTMAINMENUITEM + 0x0015)
#define ID_FIND                         (ID_FIRSTMAINMENUITEM + 0x0016)
#define ID_NEWKEY                       (ID_FIRSTMAINMENUITEM + 0x0017)
#define ID_NEWSTRINGVALUE               (ID_FIRSTMAINMENUITEM + 0x0018)
#define ID_NEWBINARYVALUE               (ID_FIRSTMAINMENUITEM + 0x0019)
#define ID_EXECCALC                     (ID_FIRSTMAINMENUITEM + 0x001A)
#define ID_ABOUT                        (ID_FIRSTMAINMENUITEM + 0x001B)
#define ID_STATUSBAR                    (ID_FIRSTMAINMENUITEM + 0x001C)
#define ID_SPLIT                        (ID_FIRSTMAINMENUITEM + 0x001E)
#define ID_FINDNEXT                     (ID_FIRSTMAINMENUITEM + 0x001F)
#define ID_HELPTOPICS                   (ID_FIRSTMAINMENUITEM + 0x0020)
#define ID_NETSEPARATOR                 (ID_FIRSTMAINMENUITEM + 0x0021)
#define ID_NEWDWORDVALUE                (ID_FIRSTMAINMENUITEM + 0x0022)
#define ID_COPYKEYNAME	                (ID_FIRSTMAINMENUITEM + 0x0023)
#define ID_NEWMULTSZVALUE               (ID_FIRSTMAINMENUITEM + 0x0024)
#define ID_NEWEXPSZVALUE                (ID_FIRSTMAINMENUITEM + 0x0025)
#define ID_PERMISSIONS                  (ID_FIRSTMAINMENUITEM + 0x0026)
#define ID_DISPLAYBINARY                (ID_FIRSTMAINMENUITEM + 0x0027)
#define ID_LOADHIVE                     (ID_FIRSTMAINMENUITEM + 0x0028)
#define ID_UNLOADHIVE                   (ID_FIRSTMAINMENUITEM + 0x0029)

//
//  Dual menu items.  The routing of these items depends on whether it was
//  selected from the main menu or from a context menu.
//

#define ID_FIRSTDUALMENUITEM            0x0300
#define ID_LASTDUALMENUITEM             0x037F

#define ID_DISCONNECT                   (ID_FIRSTDUALMENUITEM + 0x0000)

//
//  Context menu items.  If any of these items are selected from the main menu,
//  they will be automatically routed to the focus pane's command handler.
//

#define ID_FIRSTCONTEXTMENUITEM         0x0380
#define ID_LASTCONTEXTMENUITEM          0x03FF

//  Following are really keyboard accelerators.
#define ID_CONTEXTMENU                  (ID_FIRSTCONTEXTMENUITEM + 0x0000)

#define ID_MODIFY                       (ID_FIRSTCONTEXTMENUITEM + 0x0010)
#define ID_DELETE                       (ID_FIRSTCONTEXTMENUITEM + 0x0011)
#define ID_RENAME                       (ID_FIRSTCONTEXTMENUITEM + 0x0012)
#define ID_TOGGLE                       (ID_FIRSTCONTEXTMENUITEM + 0x0013)
#define ID_SENDTOPRINTER                (ID_FIRSTCONTEXTMENUITEM + 0x0014)
#define ID_MODIFYBINARY                 (ID_FIRSTCONTEXTMENUITEM + 0x0015)
//
//  The following are new features added by BruceGr
//
#define ID_FIRSTNEWIDENTIFIER           0x0500
#define ID_REMOVEFAVORITE               (ID_FIRSTNEWIDENTIFIER + 0x0000)
#define ID_ADDTOFAVORITES               (ID_FIRSTNEWIDENTIFIER + 0x0001)

//
//  String resource identifiers.
//

#define IDS_REGEDIT                     16
#define IDS_NAMECOLUMNLABEL             17
#define IDS_DATACOLUMNLABEL             18
#define IDS_COMPUTER                    19
#define IDS_DEFAULTVALUE                20
#define IDS_MODIFYBINARY                21
#define IDS_EMPTYBINARY                 22
#define IDS_NEWKEYNAMETEMPLATE          23
#define IDS_NEWVALUENAMETEMPLATE        24
#define IDS_COLLAPSE                    25
#define IDS_MODIFY                      26
#define IDS_VALUENOTSET                 27
#define IDS_HELPFILENAME                28
#define IDS_DWORDDATAFORMATSPEC         29
#define IDS_INVALIDDWORDDATA            30
#define IDS_TYPECOLUMNLABEL             31

#define IDS_REGEDITDISABLED             40
#define IDS_SEARCHEDTOEND               41
#define IDS_COMPUTERBROWSETITLE         42
#define IDS_NOFILESPECIFIED             43

#define IDS_CONFIRMDELKEYTEXT           48
#define IDS_CONFIRMDELKEYTITLE          49
#define IDS_CONFIRMDELVALMULTITEXT      50
#define IDS_CONFIRMDELVALTITLE          51
#define IDS_CONFIRMDELVALTEXT           52
#define IDS_CONFIRMDELHIVETEXT          53
#define IDS_CONFIRMDELHIVETITLE         54
#define IDS_CONFIRMRESTOREKEY           55
#define IDS_CONFIRMRESKEYTITLE          56

#define IDS_RENAMEKEYERRORTITLE         64
#define IDS_RENAMEPREFIX                65              //  Reserved
#define IDS_RENAMEKEYOTHERERROR         66
#define IDS_RENAMEKEYTOOLONG            67
#define IDS_RENAMEKEYEXISTS             68
#define IDS_RENAMEKEYBADCHARS           69
#define IDS_RENAMEKEYEMPTY              70

#define IDS_RENAMEVALERRORTITLE         72
#define IDS_RENAMEVALOTHERERROR         73
#define IDS_RENAMEVALEXISTS             74
#define IDS_RENAMEVALEMPTY              75

#define IDS_DELETEKEYERRORTITLE         80
#define IDS_DELETEPREFIX                81              //  Reserved
#define IDS_DELETEKEYDELETEFAILED       82

#define IDS_DELETEVALERRORTITLE         88
#define IDS_DELETEVALDELETEFAILED       89

#define IDS_OPENKEYERRORTITLE           96
#define IDS_OPENKEYCANNOTOPEN           97

#define IDS_REFRESHERRORTITLE           100
#define IDS_REFRESHCANNOTREAD           101
#define IDS_REFRESHNOMEMORY             102

#define IDS_EDITWARNOVERFLOW            110
#define IDS_EDITWARNINGTITLE            111
#define IDS_EDITVALERRORTITLE           112
#define IDS_EDITPREFIX                  113             //  Reserved
#define IDS_EDITVALCANNOTREAD           114
#define IDS_EDITVALCANNOTWRITE          115
#define IDS_EDITMULTSZEMPTYSTR          116
#define IDS_EDITMULTSZEMPTYSTRS         117
#define IDS_EDITVALNOMEMORY             118
#define IDS_EDITDWTRUNCATEDEC           119

#define IDS_IMPFILEERRNOTASCRPT         123
// #define IDS_IMPFILEERRSUCCESSNOWIN      124      // unused, reclaim!
#define IDS_IMPFILEERRINVALID           125
#define IDS_IMPFILEERRNOPRIV            126
#define IDS_IMPFILEERRORCANCEL          127
#define IDS_IMPFILEERRSUCCESS           128
#define IDS_IMPFILEERRFILEOPEN          129
#define IDS_IMPFILEERRFILEREAD          130
#define IDS_IMPFILEERRREGOPEN           131
#define IDS_IMPFILEERRREGSET            132
#define IDS_IMPFILEERRFORMATBAD         133
#define IDS_IMPFILEERRVERBAD            134
#define IDS_IMPFILEERRNOFILE            135

#define IDS_EXPFILEERRSUCCESS           136
#define IDS_EXPFILEERRBADREGPATH        137
#define IDS_EXPFILEERRFILEOPEN          138
#define IDS_EXPFILEERRREGOPEN           139
#define IDS_EXPFILEERRREGENUM           140
#define IDS_EXPFILEERRFILEWRITE         141
#define IDS_EXPFILEERRNOPRIV            142
#define IDS_EXPFILEERRINVALID           143

#define IDS_PRINTERRNOMEMORY            144
#define IDS_PRINTERRPRINTER             145
#define IDS_PRINTERRCANNOTREAD          146

#define IDS_ERRINVALIDREGPATH           148

#define IDS_CONNECTERRORTITLE           152
#define IDS_CONNECTNOTLOCAL             153
#define IDS_CONNECTBADNAME              154
#define IDS_CONNECTROOTFAILED           155
#define IDS_CONNECTACCESSDENIED         156

#define IDS_NEWKEYERRORTITLE            160
#define IDS_NEWKEYPARENTOPENFAILED      161
#define IDS_NEWKEYCANNOTCREATE          162
#define IDS_NEWKEYNOUNIQUE              163

#define IDS_NEWVALUEERRORTITLE          168
#define IDS_NEWVALUECANNOTCREATE        169
#define IDS_NEWVALUENOUNIQUE            170

#define IDS_FAVORITEEXISTS              171
#define	IDS_FAVORITEERROR               172
#define IDS_FAVORITE                    173

#define IDS_REGLOADHVFILEFILTER         180
#define IDS_LOADHVREGFILETITLE          181
#define IDS_ERRORLOADHVPRIV             182
#define IDS_ERRORLOADHV                 183
#define IDS_ERRORUNLOADHVPRIV           184
#define IDS_ERRORUNLOADHV               185
#define IDS_UNLOADHIVETITLE             186
#define IDS_ERRORUNLOADHVNOACC          187
#define IDS_ERRORLOADHVNOSHARE          188
#define IDS_ERRORLOADHVNOACC            189

#define IDS_SAVETREEERRNOMEMORY         212
#define IDS_SAVETREEERRCANNOTREAD       213
#define IDS_SAVETREEERRFILEWRITE        214
#define IDS_SAVETREEERRFILEOPEN         215

#define LOCAL_OFFSET    100
#define IDS_IMPFILEERRSUCCESSLOCAL      IDS_IMPFILEERRSUCCESS + LOCAL_OFFSET    // 228
#define IDS_IMPFILEERRREGOPENLOCAL      IDS_IMPFILEERRREGOPEN + LOCAL_OFFSET    // 231
#define IDS_IMPFILEERRNOFILELOCAL       IDS_IMPFILEERRNOFILE + LOCAL_OFFSET     // 235

#define IDS_IMPORTREGFILETITLE          300
#define IDS_EXPORTREGFILETITLE          301
#define IDS_REGIMPORTFILEFILTER         302
#define IDS_REGFILEDEFEXT               303
#define IDS_CONFIRMIMPFILE              304
#define IDS_REGEXPORTFILEFILTER         305
#define IDS_NOMEMORY                    306
#define IDS_REGNODEFEXT                 308

//  The range IDS_FIRSTMENUPOPUPITEM through IDS_LASTMENUPOPUPITEM is reserved
//  for context menu help.  This must match up with ID_FIRSTMENUPOPUPITEM
//  through ID_LASTMENUPOPUPITEM.
#define IDS_FIRSTMENUPOPUPITEM          ID_FIRSTMENUPOPUPITEM
#define IDS_LASTMENUPOPUPITEM           ID_LASTMENUPOPUPITEM

//  The range IDS_FIRSTMAINMENUITEM through IDS_LASTMAINMENUITEM is reserved for
//  context menu help.  This must match up with ID_FIRSTMAINMENUITEM through
//  ID_LASTMAINMENUITEM.

#define IDS_FIRSTMAINMENUITEM           ID_FIRSTMAINMENUITEM
#define IDS_LASTMAINMENUITEM            ID_LASTMAINMENUITEM

//  The range IDS_FIRSTCONTEXTMENUITEM through IDS_LASTCONTEXTMENUITEM is
//  reserved for context menu help.  This must match up with
//  ID_FIRSTCONTEXTMENUITEM through ID_LASTCONTEXTMENUITEM.

#define IDS_FIRSTCONTEXTMENUITEM        ID_FIRSTCONTEXTMENUITEM
#define IDS_LASTCONTEXTMENUITEM         ID_LASTCONTEXTMENUITEM

//  The range IDS_FIRSTDUALMENUITEM through IDS_LASTDUALMENUITEM is reserved for
//  context menu help.  This must match up with ID_FIRSTDUALMENUITEM through
//  ID_LASTDUALMENUITEM.
#define IDS_FIRSTDUALMENUITEM           ID_FIRSTDUALMENUITEM
#define IDS_LASTDUALMENUITEM            ID_LASTDUALMENUITEM

// SECURITY
#define IDS_SECURITY                            7000
#define IDS_SEC_EDITOR_CREATE_LINK              7001
#define IDS_SEC_EDITOR_QUERY_VALUE              7002
#define IDS_SEC_EDITOR_SET_VALUE                7003
#define IDS_SEC_EDITOR_ENUM_SUBKEYS             7004
#define IDS_SEC_EDITOR_NOTIFY                   7005
#define IDS_SEC_EDITOR_CREATE_SUBKEY            7006
#define IDS_SEC_EDITOR_DELETE                   7007
#define IDS_SEC_EDITOR_WRITE_DAC                7008
#define IDS_SEC_EDITOR_WRITE_OWNER              7009
#define IDS_SEC_EDITOR_READ_CONTROL             7010
#define IDS_SEC_EDITOR_READ                     7011
#define IDS_SEC_EDITOR_FULL_ACCESS              7012
#define IDS_SEC_EDITOR_SPECIAL_ACCESS           7013
#define IDS_SEC_EDITOR_REGISTRY_KEY             7014
#define IDS_SEC_EDITOR_APPLY_TO_SUBKEYS         7015
#define IDS_SEC_EDITOR_AUDIT_SUBKEYS            7016
#define IDS_SEC_EDITOR_CONFIRM_APPLY_TO_SUBKEYS 7017
#define IDS_SEC_EDITOR_CONFIRM_AUDIT_SUBKEYS    7018
#define IDS_SEC_EDITOR_DEFAULT_PERM_NAME        7019

#define IDS_GET_SECURITY_ACCESS_DENIED_EX       7050
#define IDS_GET_SECURITY_KEY_DELETED_EX         7051
#define IDS_GET_SECURITY_KEY_NOT_ACCESSIBLE_EX  7052

#define IDS_SET_SECURITY_ACCESS_DENIED_EX                   7070
#define IDS_SET_SECURITY_KEY_DELETED_EX                     7071
#define IDS_SET_SECURITY_RECURSIVE_EX_FAIL                  7072
#define IDS_SET_OWNER_RECURSIVE_EX_FAIL                     7073
#define IDS_SET_SECURITY_ACCESS_DENIED_RECURSIVE_EX         7074
#define IDS_SET_SECURITY_KEY_DELETED_RECURSIVE_EX           7075
#define IDS_SET_SECURITY_KEY_NOT_ACCESSIBLE_RECURSIVE_EX    7076

#define IDS_KEY_FOLDER                          7090
#define IDS_KEY_FOLDER_SUBFOLDER                7091
#define IDS_KEY_SUBFOLDER_ONLY                  7092


// RESOURSE_LIST 
#define IDS_BUS_INTERNAL                 7500
#define IDS_BUS_ISA                      7501
#define IDS_BUS_EISA                     7502
#define IDS_BUS_MICRO_CHANNEL            7503
#define IDS_BUS_TURBO_CHANNEL            7504
#define IDS_BUS_PCI_BUS                  7505
#define IDS_BUS_VME_BUS                  7506
#define IDS_BUS_NU_BUS                   7507
#define IDS_BUS_PCMCIA_BUS               7508
#define IDS_BUS_C_BUS                    7509
#define IDS_BUS_MPI_BUS                  7510
#define IDS_BUS_MPSA_BUS                 7511

#define IDS_INT_LEVEL_SENSITIVE          7520
#define IDS_INT_LATCHED                  7521

#define IDS_MEM_READ_WRITE               7530
#define IDS_MEM_READ_ONLY                7531
#define IDS_MEM_WRITE_ONLY               7532

#define IDS_PORT_MEMORY                  7540
#define IDS_PORT_PORT                    7541
#define IDS_INVALID                      7542

#define IDS_DEV_PORT                     7560
#define IDS_DEV_INTERRUPT                7561
#define IDS_DEV_MEMORY                   7562
#define IDS_DEV_DMA                      7563
#define IDS_DEV_DEVICE_SPECIFIC          7564

#define IDS_SHARE_UNDETERMINED           7580
#define IDS_SHARE_DEVICE_EXCLUSIVE       7581
#define IDS_SHARE_DRIVER_EXCLUSIVE       7582
#define IDS_SHARE_SHARED                 7583

// Printing strings
#define IDS_PRINT_TYPE_REG_NONE             8000
#define IDS_PRINT_TYPE_REG_SZ               8001
#define IDS_PRINT_TYPE_REG_EXPAND_SZ        8002
#define IDS_PRINT_TYPE_REG_BINARY           8003
#define IDS_PRINT_TYPE_REG_DWORD            8004
#define IDS_PRINT_TYPE_REG_LINK             8006
#define IDS_PRINT_TYPE_REG_MULTI_SZ         8007
#define IDS_PRINT_TYPE_REG_RESOURCE_LIST    8008
#define IDS_PRINT_TYPE_REG_FULL_RESOURCE_DESCRIPTOR     8009
#define IDS_PRINT_TYPE_REG_RESOURCE_REQUIREMENTS_LIST   8010
#define IDS_PRINT_TYPE_REG_REG_QWORD        8011
#define IDS_PRINT_TYPE_REG_UNKNOWN          8012
    
#define IDS_PRINT_SEPARATOR                 8100
#define IDS_PRINT_KEY_NAME                  8101
#define IDS_PRINT_CLASS_NAME                8102
#define IDS_PRINT_LAST_WRITE_TIME           8103
#define IDS_PRINT_NUMBER                    8104
#define IDS_PRINT_NAME                      8105
#define IDS_PRINT_TYPE                      8106
#define IDS_PRINT_DATA_SIZE                 8107
#define IDS_PRINT_DATA                      8108
#define IDS_PRINT_NO_NAME                   8109
#define IDS_PRINT_NO_CLASS                  8110
#define IDS_PRINT_KEY_NAME_INDENT           8111
#define IDS_PRINT_FONT                      8112

#define IDS_PRINT_FULL_DESCRIPTOR           8150
#define IDS_PRINT_PARTIAL_DESCRIPTOR        8151
#define IDS_PRINT_INTERFACE_TYPE            8152
#define IDS_PRINT_BUS_NUMBER                8153
#define IDS_PRINT_VERSION                   8154
#define IDS_PRINT_REVISION                  8155

#define IDS_PRINT_RESOURCE                  8160
#define IDS_PRINT_DISPOSITION               8161
#define IDS_PRINT_IO_TYPE                   8162
#define IDS_PRINT_START                     8163
#define IDS_PRINT_LENGTH                    8164
#define IDS_PRINT_LEVEL                     8165
#define IDS_PRINT_VECTOR                    8166
#define IDS_PRINT_AFFINITY                  8167
#define IDS_PRINT_CHANNEL                   8168
#define IDS_PRINT_PORT                      8169
#define IDS_PRINT_RESERVED1                 8170
#define IDS_PRINT_RESERVED2                 8171
#define IDS_PRINT_DEV_SPECIFIC_DATA         8172
         
#define IDS_PRINT_IO_INTERFACE_TYPE         8180
#define IDS_PRINT_IO_BUS_NUMBER             8181
#define IDS_PRINT_IO_SLOT_NUMBER            8182
#define IDS_PRINT_IO_LIST_NUMBER            8183
#define IDS_PRINT_IO_DESCRIPTOR_NUMBER      8184
#define IDS_PRINT_IO_OPTION                 8185
#define IDS_PRINT_IO_ALIGNMENT              8186
#define IDS_PRINT_IO_MINIMUM_ADDRESS        8187
#define IDS_PRINT_IO_MAXIMUM_ADDRESS        8188
#define IDS_PRINT_IO_MINIMUM_VECTOR         8189
#define IDS_PRINT_IO_MAXIMUM_VECTOR         8190
#define IDS_PRINT_IO_MINIMUM_CHANNEL        8191
#define IDS_PRINT_IO_MAXIMUM_CHANNEL        8192

//
//  Icon resource identifiers.
//

#define IDI_REGEDIT                     100
#define IDI_REGEDDOC                    101
#define IDI_REGFIND                     102

#define IDI_FIRSTIMAGE                  201
//  #define IDI_DIAMOND                     200
#define IDI_COMPUTER                    201
#define IDI_REMOTE                      202
#define IDI_FOLDER                      203
#define IDI_FOLDEROPEN                  204
#define IDI_STRING                      205
#define IDI_BINARY                      206
#define IDI_LASTIMAGE                   IDI_BINARY

//
//  Cursor resource identifiers.
//

#define IDC_SPLIT                       100

//
//  Accelerator resource identifiers.
//

#define IDACCEL_REGEDIT                 100

#endif // _INC_REGRESID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regresed.c ===
//------------------------------------------------------------------------------
//
//  Microsoft Windows Shell
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      regresed.c
//
//  Contents:  Implementation of REG_RESOURCE_LIST for regedit 
//
//  Classes:   none
//
//------------------------------------------------------------------------------


#include "pch.h"
#include "regresid.h"
#include "regresed.h"
#include "clb.h"

//------------------------------------------------------------------------------
//
//  EditResourceListDlgProc
//
//  DESCRIPTION:
//
//  PARAMETERS:
//------------------------------------------------------------------------------

INT_PTR CALLBACK EditResourceListDlgProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
    
    LPEDITVALUEPARAM lpEditValueParam;
    
    
    switch (Message) 
    {
        HANDLE_MSG(hWnd, WM_INITDIALOG, EditResourceList_OnInitDialog);
        
    case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            {
            case IDOK:
            case IDCANCEL:
                EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                break; 
            }
        }
        break;
        
    case WM_HELP:
        break;
        
    case WM_CONTEXTMENU:
        break;
        
    default:
        return FALSE;
        
    }
    
    return TRUE;
    
}

//------------------------------------------------------------------------------
//
//  EditResourceList_OnInitDialog
//
//  DESCRIPTION:
//
//  PARAMETERS:
//------------------------------------------------------------------------------

BOOL EditResourceList_OnInitDialog(HWND hWnd, HWND hFocusWnd, LPARAM lParam)
{

    ClbSetColumnWidths(hWnd, IDC_LIST_RESOURCE_LISTS, 10);
    /*
    LPEDITVALUEPARAM lpEditValueParam;

    //  Change maximum number of characters of the edit control, to its
    //  maximum limit (from 3000 characters to 4G characters).
    SendDlgItemMessage( hWnd, IDC_VALUEDATA, EM_LIMITTEXT, 0, 0L );

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);
    lpEditValueParam = (LPEDITVALUEPARAM) lParam;

    SetDlgItemText(hWnd, IDC_VALUENAME, lpEditValueParam-> pValueName);
    SetDlgItemText(hWnd, IDC_VALUEDATA, (PTSTR)lpEditValueParam-> pValueData);
    */

    return TRUE;

    UNREFERENCED_PARAMETER(hFocusWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regresls.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regresls.cxx

Abstract:

    This module contains the definitions of the member functions
    of RESOURCE_LIST class.

Author:

    Jaime Sasson (jaimes) 02-Dec-1993

Environment:

    ULIB, User Mode


--*/

#include "regresls.hxx"
#include "iterator.hxx"
#include "regdesc.hxx"
#include "regfdesc.hxx"


DEFINE_CONSTRUCTOR ( RESOURCE_LIST, OBJECT );


RESOURCE_LIST::~RESOURCE_LIST (
    )

/*++

Routine Description:

    Destroy a RESOURCE_LIST.

Arguments:

    None.

Return Value:

    None.

--*/

{
    Destroy();
}


VOID
RESOURCE_LIST::Construct (
    )

/*++

Routine Description:

    Construct a RESOURCE_LIST object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _FullResourceDescriptors = NULL;
}


VOID
RESOURCE_LIST::Destroy (
    )

/*++

Routine Description:

    Worker method for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if( _FullResourceDescriptors != NULL ) {
        _FullResourceDescriptors->DeleteAllMembers();
        DELETE( _FullResourceDescriptors );
    }
    _FullResourceDescriptors = NULL;
}



BOOLEAN
RESOURCE_LIST::Initialize(
    IN  PCBYTE       Data,
    IN  ULONG        Size
    )

/*++

Routine Description:

    Initialize an object of type RESOURCE_LIST.

Arguments:

    Data - Pointer to a buffer that contains a CM_RESOURCE_LIST.

    Size - Buffer size.

Return Value:

    BOOLEAN - Returns TRUE if the initialization succeeds.

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    FullResource;
    ULONG                           Count;
    ULONG                           i;
    PARRAY  TmpList;
    ULONG   BufferSize;
    ULONG   FullDescriptorSize;

    if( Data == NULL ) {
        return( FALSE );
    }

    Count           = ( ( PCM_RESOURCE_LIST )Data )->Count;
    FullResource    = ( ( PCM_RESOURCE_LIST )Data )->List;

    TmpList = ( PARRAY )NEW( ARRAY );
    DebugPtrAssert( TmpList );
    if( ( TmpList == NULL ) ||
        ( !TmpList->Initialize() ) ) {
        DebugPrintTrace(("REGEDT32: Out of memory" ));
        DELETE( TmpList );
        return( FALSE );
    }

    //
    // For each CM_FULL_RESOURCE DESCRIPTOR in the current value...
    //

    BufferSize = Size -             // Data size
                 sizeof( ULONG );   // Count

    for( i = 0; i < Count; i++ ) {

        PFULL_DESCRIPTOR   FullResourceDescriptor;

        FullResourceDescriptor = ( PFULL_DESCRIPTOR )NEW( FULL_DESCRIPTOR );
        if( ( FullResourceDescriptor == NULL ) ||
            !FullResourceDescriptor->Initialize( ( PCBYTE )FullResource,
                                                 BufferSize,
                                                 &FullDescriptorSize )
          ) {
            DebugPrint( "REGEDT32: Unable to create or initialize FullResourcedescriptor \n" );
            DELETE( FullResourceDescriptor );
            TmpList->DeleteAllMembers();
            DELETE( TmpList );
            return( FALSE );
        }
        TmpList->Put( FullResourceDescriptor );

        FullResource = ( PCM_FULL_RESOURCE_DESCRIPTOR )( ( ULONG_PTR )FullResource + FullDescriptorSize );
        BufferSize -= FullDescriptorSize;
    }
    _FullResourceDescriptors = TmpList;
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regprintres.cpp ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regprintres.cpp

Abstract:

    This file contains the implementation of the member functions
    of PRINT_MANAGER class.

Author:

    Jaime Sasson (jaimes) 18-Sep-1991


Environment:

    Ulib, Regedit, Windows, User Mode


--*/

#include "regprintres.h"
#include "array.hxx"
#include "regsys.hxx"
#include "iterator.hxx"
#include "regresid.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)        (sizeof(x) / sizeof(x[0]))
#endif

extern "C" 
{
    // from regprint.c
    void PrintBinaryData(PBYTE ValueData, UINT cbcbValueData);
    void PrintLiteral(PTSTR lpLiteral);
    void PrintNewLine();
}
 
BOOL PrintString(PWSTRING pwsString)
{
    PrintLiteral((PTSTR)pwsString->GetWSTR());

    return TRUE;
}

void PrintResourceData(PBYTE pbData, UINT uSize, DWORD dwType)
{
    PRINT_RESOURCE::_PrintResources(pbData, uSize, dwType);
}

BOOL        PRINT_RESOURCE::s_StringsInitialized = FALSE;
PWSTRING    PRINT_RESOURCE::s_IndentString;
PWSTRING    PRINT_RESOURCE::s_StringFullDescriptor;
PWSTRING    PRINT_RESOURCE::s_StringInterfaceType;
PWSTRING    PRINT_RESOURCE::s_StringBusNumber;
PWSTRING    PRINT_RESOURCE::s_StringVersion;
PWSTRING    PRINT_RESOURCE::s_StringRevision;
PWSTRING    PRINT_RESOURCE::s_StringPartialDescriptor;
PWSTRING    PRINT_RESOURCE::s_StringResource;
PWSTRING    PRINT_RESOURCE::s_StringDisposition;
PWSTRING    PRINT_RESOURCE::s_StringVector;
PWSTRING    PRINT_RESOURCE::s_StringLevel;
PWSTRING    PRINT_RESOURCE::s_StringAffinity;
PWSTRING    PRINT_RESOURCE::s_StringType;
PWSTRING    PRINT_RESOURCE::s_StringStart;
PWSTRING    PRINT_RESOURCE::s_StringLength;
PWSTRING    PRINT_RESOURCE::s_StringChannel;
PWSTRING    PRINT_RESOURCE::s_StringPort;
PWSTRING    PRINT_RESOURCE::s_StringReserved1;
PWSTRING    PRINT_RESOURCE::s_StringReserved2;
PWSTRING    PRINT_RESOURCE::s_StringDevSpecificData;
PWSTRING    PRINT_RESOURCE::s_StringIoInterfaceType;
PWSTRING    PRINT_RESOURCE::s_StringIoBusNumber;
PWSTRING    PRINT_RESOURCE::s_StringIoSlotNumber;
PWSTRING    PRINT_RESOURCE::s_StringIoListNumber;
PWSTRING    PRINT_RESOURCE::s_StringIoDescriptorNumber;
PWSTRING    PRINT_RESOURCE::s_StringIoOption;
PWSTRING    PRINT_RESOURCE::s_StringIoMinimumVector;
PWSTRING    PRINT_RESOURCE::s_StringIoMaximumVector;
PWSTRING    PRINT_RESOURCE::s_StringIoMinimumAddress;
PWSTRING    PRINT_RESOURCE::s_StringIoMaximumAddress;
PWSTRING    PRINT_RESOURCE::s_StringIoAlignment;
PWSTRING    PRINT_RESOURCE::s_StringIoMinimumChannel;
PWSTRING    PRINT_RESOURCE::s_StringIoMaximumChannel;



//------------------------------------------------------------------------------
// PrintResources
//
// DESCRIPTION: Prints a resouce by type
// 
//------------------------------------------------------------------------------
void PRINT_RESOURCE::_PrintResources(PBYTE pbData, UINT uSize, DWORD dwType)
{
    if(!s_StringsInitialized) 
    {
        s_StringsInitialized = _InitializeStrings();
    }

    if (s_StringsInitialized)
    {
        switch (dwType)
        {
        case REG_RESOURCE_LIST:
            _PrintDataRegResourceList(pbData, uSize);
            break;

        case REG_FULL_RESOURCE_DESCRIPTOR:
            {
                FULL_DESCRIPTOR FullDescriptor;
                if (FullDescriptor.Initialize(pbData, uSize))
                {
                    _PrintFullResourceDescriptor(&FullDescriptor, 0, FALSE);
                }
            }
            break;

        case REG_RESOURCE_REQUIREMENTS_LIST:
            _PrintDataRegRequirementsList(pbData, uSize);
            break;

        default:
            PrintBinaryData(pbData, uSize);
            break;
        }
    }
}


//------------------------------------------------------------------------------
// PrintDataRegResourceList
//
// DESCRIPTION: Initializes the static strings.
// 
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_InitializeStrings()
{
    PWSTR    Buffer;
    ULONG   Size;
    ULONG   Count;
    BOOLEAN fSuccess = TRUE;

    s_IndentString = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_KEY_NAME_INDENT, "" );
    s_StringFullDescriptor = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_FULL_DESCRIPTOR, "" );
    s_StringPartialDescriptor = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_PARTIAL_DESCRIPTOR, "" );
    s_StringInterfaceType = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_INTERFACE_TYPE, "" );
    s_StringBusNumber = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_BUS_NUMBER, "" );
    s_StringVersion = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_VERSION, "" );
    s_StringRevision = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_REVISION, "" );
    s_StringResource = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_RESOURCE, "" );
    s_StringDisposition = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_DISPOSITION, "" );
    s_StringType = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_TYPE, "" );
    s_StringStart = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_START, "" );
    s_StringLength = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_LENGTH, "" );
    s_StringLevel = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_LEVEL, "" );
    s_StringVector = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_VECTOR, "" );
    s_StringAffinity = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_AFFINITY, "" );
    s_StringChannel = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_CHANNEL, "" );
    s_StringPort = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_PORT, "" );
    s_StringReserved1 = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_RESERVED1, "" );
    s_StringReserved2 = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_RESERVED2, "" );
    s_StringDevSpecificData = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_DEV_SPECIFIC_DATA, "" );
    s_StringIoInterfaceType = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_INTERFACE_TYPE, "" );
    s_StringIoBusNumber = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_BUS_NUMBER, "" );
    s_StringIoSlotNumber = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_SLOT_NUMBER, "" );
    s_StringIoListNumber = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_LIST_NUMBER, "" );
    s_StringIoOption = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_OPTION, "" );
    s_StringIoDescriptorNumber = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_DESCRIPTOR_NUMBER, "" );
    s_StringIoAlignment = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_ALIGNMENT, "" );
    s_StringIoMinimumAddress = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_MINIMUM_ADDRESS, "" );
    s_StringIoMaximumAddress = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_MAXIMUM_ADDRESS, "" );
    s_StringIoMinimumVector = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_MINIMUM_VECTOR, "" );
    s_StringIoMaximumVector = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_MAXIMUM_VECTOR, "" );
    s_StringIoMinimumChannel = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_MINIMUM_CHANNEL, "" );
    s_StringIoMaximumChannel = REGEDIT_BASE_SYSTEM::QueryString(IDS_PRINT_IO_MAXIMUM_CHANNEL, "" );
    

    if ((s_StringFullDescriptor == NULL) ||
        (s_StringPartialDescriptor == NULL) ||
        (s_StringInterfaceType == NULL) ||
        (s_StringBusNumber == NULL) ||
        (s_StringVersion == NULL) ||
        (s_StringRevision == NULL) ||
        (s_StringResource == NULL) ||
        (s_StringDisposition == NULL) ||
        (s_StringType == NULL) ||
        (s_StringStart == NULL) ||
        (s_StringLength == NULL) ||
        (s_StringLevel == NULL) ||
        (s_StringVector == NULL) ||
        (s_StringAffinity == NULL) ||
        (s_StringChannel == NULL) ||
        (s_StringPort == NULL) ||
        (s_StringReserved1 == NULL) ||
        (s_StringReserved2 == NULL) ||
        (s_StringDevSpecificData == NULL) ||
        (s_StringIoInterfaceType == NULL) ||
        (s_StringIoBusNumber == NULL) ||
        (s_StringIoSlotNumber == NULL) ||
        (s_StringIoListNumber == NULL) ||
        (s_StringIoOption == NULL) ||
        (s_StringIoDescriptorNumber == NULL) ||
        (s_StringIoAlignment == NULL) ||
        (s_StringIoMinimumAddress == NULL) ||
        (s_StringIoMaximumAddress == NULL) ||
        (s_StringIoMinimumVector == NULL) ||
        (s_StringIoMaximumVector == NULL) ||
        (s_StringIoMinimumChannel == NULL) ||
        (s_StringIoMaximumChannel == NULL))
    {
        DELETE(s_StringFullDescriptor);
        DELETE(s_StringPartialDescriptor);
        DELETE(s_StringInterfaceType);
        DELETE(s_StringBusNumber);
        DELETE(s_StringVersion);
        DELETE(s_StringRevision);
        DELETE(s_StringResource);
        DELETE(s_StringDisposition);
        DELETE(s_StringType);
        DELETE(s_StringStart);
        DELETE(s_StringLength);
        DELETE(s_StringLevel);
        DELETE(s_StringVector);
        DELETE(s_StringAffinity);
        DELETE(s_StringChannel);
        DELETE(s_StringPort);
        DELETE(s_StringReserved1);
        DELETE(s_StringReserved2);
        DELETE(s_StringDevSpecificData);
        DELETE(s_StringIoInterfaceType);
        DELETE(s_StringIoBusNumber);
        DELETE(s_StringIoSlotNumber);
        DELETE(s_StringIoListNumber);
        DELETE(s_StringIoOption);
        DELETE(s_StringIoDescriptorNumber);
        DELETE(s_StringIoAlignment);
        DELETE(s_StringIoMinimumAddress);
        DELETE(s_StringIoMaximumAddress);
        DELETE(s_StringIoMinimumVector);
        DELETE(s_StringIoMaximumVector);
        DELETE(s_StringIoMinimumChannel);
        DELETE(s_StringIoMaximumChannel);

        fSuccess = FALSE;
    }


    return fSuccess;
}


//------------------------------------------------------------------------------
// PrintDataRegResourceList
//
// DESCRIPTION: Print a REG_RESOURCE_LIST stored in a value entry of a registry 
//              key. 
// PARAMETERS:  Data - Pointer to the buffer that contais a REG_RESOURCE_LIST 
//                     data.
//              Size - Number of bytes in the buffer.
//------------------------------------------------------------------------------
void PRINT_RESOURCE::_PrintDataRegResourceList(PBYTE Data, UINT Size)
{
    RESOURCE_LIST       ResourceList;
    PARRAY              FullResourceDescriptors;
    PITERATOR           Iterator;
    PCFULL_DESCRIPTOR   FullDescriptor;
    ULONG               DescriptorNumber;

    PrintNewLine();

    if( ( Size == 0 ) ||
        ( Data == NULL ) ||
        !ResourceList.Initialize( Data, Size ) ) 
    {
        return;
    }

    if( ( ( FullResourceDescriptors = ResourceList.GetFullResourceDescriptors() ) == NULL ) ||
        ( ( Iterator = FullResourceDescriptors->QueryIterator() ) == NULL ) ) 
    {
        return;
    }
    DescriptorNumber = 0;
    while( ( FullDescriptor = ( PCFULL_DESCRIPTOR )( Iterator->GetNext() ) ) != NULL ) 
    {
        if( !_PrintFullResourceDescriptor( FullDescriptor, DescriptorNumber ) ) 
        {
            DELETE( Iterator );
            return;
        }
        DescriptorNumber++;
    }
    DELETE( Iterator );
    return;
}


//------------------------------------------------------------------------------
// PrintFullResourceDescriptor
//
// DESCRIPTION: Print the contents of a FULL_DESCRIPTOR object. 
//
// PARAMETERS:  FullDescriptor - Pointer to object to be printed.
//              DescriptorNumber -
//              PrintDescriptorNumber - A flag that indicates whether or not the 
//                                      descriptor number should be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintFullResourceDescriptor(PCFULL_DESCRIPTOR FullDescriptor,
    UINT DescriptorNumber, BOOL PrintDescriptorNumber)

{
    DSTRING     FullDescriptorNumberString;

    DSTRING     AuxString;
    DSTRING     InterfaceType;
    DSTRING     BusNumber;
    DSTRING     Version;
    DSTRING     Revision;
    WCHAR       AuxNumber[11];
    PWSTRING     TypeString;
    ULONG       InterfaceId;
    PARRAY      Descriptors;
    PITERATOR   Iterator;
    PCPARTIAL_DESCRIPTOR    PartialDescriptor;
    ULONG       Count;

    if( !FullDescriptorNumberString.Initialize( s_IndentString ) ||
        !FullDescriptorNumberString.Strcat( s_StringFullDescriptor ) ||
        !InterfaceType.Initialize( s_IndentString ) ||
        !InterfaceType.Strcat( s_StringInterfaceType ) ||
        !BusNumber.Initialize( s_IndentString ) ||
        !BusNumber.Strcat( s_StringBusNumber ) ||
        !Version.Initialize( s_IndentString ) ||
        !Version.Strcat( s_StringVersion ) ||
        !Revision.Initialize( s_IndentString ) ||
        !Revision.Strcat( s_StringRevision )
      ) 
    {
        return FALSE;
    }

    //
    //  Build a string that contains the full descriptor number
    //  and print it
    //
    if( PrintDescriptorNumber ) 
    {
        StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%d", DescriptorNumber );
        if( !AuxString.Initialize( AuxNumber ) ) 
        {
            return FALSE;
        }
        FullDescriptorNumberString.Strcat( &AuxString );
        if( !PrintString( &FullDescriptorNumberString ) ) 
        {
            return FALSE;
        }
    }
    PrintNewLine();

    //
    // Print the interface type

    switch( FullDescriptor->GetInterfaceType() ) 
    {

    case Internal:

        InterfaceId =  IDS_BUS_INTERNAL;
        break;

    case Isa:

        InterfaceId =  IDS_BUS_ISA;
        break;

    case Eisa:

        InterfaceId =  IDS_BUS_EISA;
        break;

    case MicroChannel:

        InterfaceId =  IDS_BUS_MICRO_CHANNEL;
        break;

    case TurboChannel:

        InterfaceId =  IDS_BUS_TURBO_CHANNEL;
        break;

    case PCIBus:

        InterfaceId =  IDS_BUS_PCI_BUS;
        break;

    case VMEBus:

        InterfaceId =  IDS_BUS_VME_BUS;
        break;

    case NuBus:

        InterfaceId =  IDS_BUS_NU_BUS;
        break;

    case PCMCIABus:

		InterfaceId =  IDS_BUS_PCMCIA_BUS;
        break;

    case CBus:

        InterfaceId =  IDS_BUS_C_BUS;
        break;

    case MPIBus:

        InterfaceId =  IDS_BUS_MPI_BUS;
        break;

    case MPSABus:

        InterfaceId =  IDS_BUS_MPSA_BUS;
        break;

    default:

        InterfaceId =  IDS_INVALID;
        break;
    }

    TypeString =  REGEDIT_BASE_SYSTEM::QueryString( InterfaceId, "" );

    if( TypeString == NULL ) 
    {
        return FALSE;
    }
    InterfaceType.Strcat( TypeString );
    DELETE( TypeString );
    if(!PrintString( &InterfaceType )) 
    {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the bus number
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%d", FullDescriptor->GetBusNumber() );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    BusNumber.Strcat( &AuxString );

    if( !PrintString( &BusNumber ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    //
    // Print version
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%d", FullDescriptor->GetVersion() );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    Version.Strcat( &AuxString );
    if( !PrintString( &Version ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    //
    // Print revision
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%d", FullDescriptor->GetRevision() );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    Revision.Strcat( &AuxString );
    if( !PrintString( &Revision ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    Descriptors = FullDescriptor->GetResourceDescriptors();
    if( ( Descriptors == NULL ) ||
        ( ( Iterator = Descriptors->QueryIterator() ) == NULL )
      ) 
    {
        return FALSE;
    }
    Count = 0;
    while( ( PartialDescriptor = ( PCPARTIAL_DESCRIPTOR )( Iterator->GetNext() ) ) != NULL ) 
    {
        if( !_PrintPartialDescriptor( PartialDescriptor, Count ) ) 
        {
            DELETE( Iterator );
            return FALSE;
        }
        Count++;
    }
    DELETE( Iterator );

    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintPartialDescriptor
//
// DESCRIPTION: Print the contents of a PARTIAL_DESCRIPTOR object. 
//
// PARAMETERS:  PartialDescriptor - Pointer to object to be printed.
//              DescriptorNumber -    
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintPartialDescriptor(PCPARTIAL_DESCRIPTOR PartialDescriptor,
    ULONG DescriptorNumber)
{
    DSTRING     PartialDescriptorNumberString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[11];
    DSTRING     ResourceString;
    DSTRING     DispositionString;
    ULONG       StringId;
    PWSTRING    String;

    if( !PartialDescriptorNumberString.Initialize( s_IndentString ) ||
        !PartialDescriptorNumberString.Strcat( s_StringPartialDescriptor ) ||
        !ResourceString.Initialize( s_IndentString ) ||
        !ResourceString.Strcat( s_StringResource ) ||
        !DispositionString.Initialize( s_IndentString ) ||
        !DispositionString.Strcat( s_StringDisposition )
      ) 
    {
        return FALSE;
    }

    //
    //  Build a string that contains the full descriptor number
    //  and print it
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%d", DescriptorNumber );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    PartialDescriptorNumberString.Strcat( &AuxString );
    if( !PrintString( &PartialDescriptorNumberString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the resource type
    //
    if( PartialDescriptor->IsDescriptorTypeDma() ) 
    {
        StringId = IDS_DEV_DMA;
    } 
    else if( PartialDescriptor->IsDescriptorTypeInterrupt() ) 
    {
        StringId = IDS_DEV_INTERRUPT;
    } 
    else if( PartialDescriptor->IsDescriptorTypeMemory() ) 
    {
        StringId = IDS_DEV_MEMORY;
    } 
    else if( PartialDescriptor->IsDescriptorTypePort() ) 
    {
        StringId = IDS_DEV_PORT;
    } 
    else if( PartialDescriptor->IsDescriptorTypeDeviceSpecific() ) 
    {
        StringId = IDS_DEV_DEVICE_SPECIFIC;
    } 
    else 
    {
        StringId = IDS_INVALID;
    }
    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );

    if( String == NULL ) 
    {
        return FALSE;
    }
    ResourceString.Strcat( String );
    DELETE( String );
    if( !PrintString( &ResourceString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();


    //
    //  Print the disposition
    //
    if( PartialDescriptor->IsResourceShareUndetermined() ) {
        StringId = IDS_SHARE_UNDETERMINED;
    } else if( PartialDescriptor->IsResourceShareDeviceExclusive() ) {
        StringId = IDS_SHARE_DEVICE_EXCLUSIVE;
    } else if( PartialDescriptor->IsResourceShareDriverExclusive() ) {
        StringId = IDS_SHARE_DRIVER_EXCLUSIVE;
    } else {
        StringId = IDS_SHARE_SHARED;
    }

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );

    if( String == NULL ) 
    {
        return FALSE;
    }
    DispositionString.Strcat( String );
    DELETE( String );
    if( !PrintString( &DispositionString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    if( PartialDescriptor->IsDescriptorTypeDma() ) 
    {
        if( !_PrintDmaDescriptor( ( PCDMA_DESCRIPTOR )PartialDescriptor ) ) 
        {
            return FALSE;
        }
    } 
    else if( PartialDescriptor->IsDescriptorTypeInterrupt() ) 
    {
        if( !_PrintInterruptDescriptor( ( PCINTERRUPT_DESCRIPTOR )PartialDescriptor ) ) 
        {
            return FALSE;
        }
    } 
    else if( PartialDescriptor->IsDescriptorTypeMemory() ) 
    {
        if( !_PrintMemoryDescriptor( ( PCMEMORY_DESCRIPTOR )PartialDescriptor ) ) 
        {
            return FALSE;
        }
    } 
    else if( PartialDescriptor->IsDescriptorTypePort() ) 
    {
        if( !_PrintPortDescriptor( ( PCPORT_DESCRIPTOR )PartialDescriptor ) ) 
        {
            return FALSE;
        }
    } 
    else if( PartialDescriptor->IsDescriptorTypeDeviceSpecific() ) 
    {
        if( !_PrintDeviceSpecificDescriptor( ( PCDEVICE_SPECIFIC_DESCRIPTOR )PartialDescriptor ) ) 
        {
            return FALSE;
        }
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintInterruptDescriptor
//
// DESCRIPTION: Print the contents of a INTERRUPT_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintInterruptDescriptor(PCINTERRUPT_DESCRIPTOR Descriptor)
{
    DSTRING     VectorString;
    DSTRING     LevelString;
    DSTRING     AffinityString;;
    DSTRING     TypeString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];
    ULONG       StringId;
    PWSTRING    String;

    if( !VectorString.Initialize( s_IndentString ) ||
        !VectorString.Strcat( s_StringVector ) ||
        !LevelString.Initialize( s_IndentString ) ||
        !LevelString.Strcat( s_StringLevel ) ||
        !AffinityString.Initialize( s_IndentString ) ||
        !AffinityString.Strcat( s_StringAffinity ) ||
        !TypeString.Initialize( s_IndentString ) ||
        !TypeString.Strcat( s_StringType )
      ) 
    {
        return FALSE;
    }

    //
    //  Print the vector
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%d", Descriptor->GetVector() );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    VectorString.Strcat( &AuxString );
    if( !PrintString( &VectorString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the level
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%d", Descriptor->GetLevel() );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    LevelString.Strcat( &AuxString );
    if( !PrintString( &LevelString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the affinity
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"0x%08x", Descriptor->GetAffinity() );
    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        return FALSE;
    }
    AffinityString.Strcat( &AuxString );
    if( !PrintString( &AffinityString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    //  Print the type
    StringId = ( Descriptor->IsInterruptLevelSensitive() )? IDS_INT_LEVEL_SENSITIVE :
                                                            IDS_INT_LATCHED;

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );
    if( String == NULL ) 
    {
        return FALSE;
    }
    TypeString.Strcat( String );
    DELETE( String );
    if( !PrintString( &TypeString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}

//------------------------------------------------------------------------------
// PrintPortDescriptor
//
// DESCRIPTION: Print the contents of a PORT_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintPortDescriptor(PCPORT_DESCRIPTOR Descriptor)
{
    DSTRING     StartAddressString;
    DSTRING     LengthString;
    DSTRING     TypeString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];
    ULONG       StringId;
    PWSTRING    String;

    if( !StartAddressString.Initialize( s_IndentString ) ||
        !StartAddressString.Strcat( s_StringStart ) ||
        !LengthString.Initialize( s_IndentString ) ||
        !LengthString.Strcat( s_StringLength ) ||
        !TypeString.Initialize( s_IndentString ) ||
        !TypeString.Strcat( s_StringType )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the start address
    //
    if( ( ( ( PPORT_DESCRIPTOR )Descriptor )->GetPhysicalAddress() )->HighPart != 0 ) 
    {
        StringCchPrintf( AuxNumber,
                        ARRAYSIZE(AuxNumber),
                        (LPWSTR)L"0x%08x%08x",
                        ( ( ( PPORT_DESCRIPTOR )Descriptor )->GetPhysicalAddress() )->HighPart,
                        ( ( ( PPORT_DESCRIPTOR )Descriptor )->GetPhysicalAddress() )->LowPart );
    } 
    else 
    {
        StringCchPrintf( AuxNumber, 
                        ARRAYSIZE(AuxNumber), 
                        (LPWSTR)L"0x%08x", 
                        ( ( ( PPORT_DESCRIPTOR )Descriptor )->GetPhysicalAddress() )->LowPart );
    }

    if( !AuxString.Initialize( AuxNumber ) ) 
    {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }

    StartAddressString.Strcat( &AuxString );
    if( !PrintString( &StartAddressString ) ) 
    {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the length
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%#x", Descriptor->GetLength() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    LengthString.Strcat( &AuxString );
    if( !PrintString( &LengthString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the type
    //

    StringId = ( Descriptor->IsPortMemory() )? IDS_PORT_MEMORY :
                                               IDS_PORT_PORT;

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );
    if( String == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    TypeString.Strcat( String );
    DELETE( String );
    if( !PrintString( &TypeString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintMemoryDescriptor
//
// DESCRIPTION: Print the contents of a MEMORY_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintMemoryDescriptor(PCMEMORY_DESCRIPTOR   Descriptor)
{
    DSTRING     StartAddressString;
    DSTRING     LengthString;
    DSTRING     TypeString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];
    ULONG       StringId;
    PWSTRING    String;

    if( !StartAddressString.Initialize( s_IndentString ) ||
        !StartAddressString.Strcat( s_StringStart ) ||
        !LengthString.Initialize( s_IndentString ) ||
        !LengthString.Strcat( s_StringLength ) ||
        !TypeString.Initialize( s_IndentString ) ||
        !TypeString.Strcat( s_StringType )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the start address
    //
    if( ( ( ( PMEMORY_DESCRIPTOR )Descriptor )->GetStartAddress() )->HighPart != 0 ) 
    {
        StringCchPrintf( AuxNumber,
                        ARRAYSIZE(AuxNumber),
                        (LPWSTR)L"0x%08x%08x",
                        ( ( ( PMEMORY_DESCRIPTOR )Descriptor )->GetStartAddress() )->HighPart,
                        ( ( ( PMEMORY_DESCRIPTOR )Descriptor )->GetStartAddress() )->LowPart );
    } 
    else 
    {
        StringCchPrintf( AuxNumber, 
                        ARRAYSIZE(AuxNumber), 
                        (LPWSTR)L"0x%08x", 
                        ( ( ( PMEMORY_DESCRIPTOR )Descriptor )->GetStartAddress() )->LowPart );
    }

    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    StartAddressString.Strcat( &AuxString );
    if( !PrintString( &StartAddressString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the length
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%#x", Descriptor->GetLength() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    LengthString.Strcat( &AuxString );
    if( !PrintString( &LengthString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the type
    //

    StringId = ( Descriptor->IsMemoryReadWrite() )? IDS_MEM_READ_WRITE :
                                                    ( ( Descriptor->IsMemoryReadWrite() )? IDS_MEM_READ_ONLY :
                                                                                           IDS_MEM_WRITE_ONLY );

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );
    if( String == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    TypeString.Strcat( String );
    DELETE( String );
    if( !PrintString( &TypeString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintDmaDescriptor
//
// DESCRIPTION: Print the contents of a DMA_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintDmaDescriptor(PCDMA_DESCRIPTOR   Descriptor)
{
    DSTRING     ChannelString;
    DSTRING     PortString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];

    if( !ChannelString.Initialize( s_IndentString ) ||
        !ChannelString.Strcat( s_StringChannel ) ||
        !PortString.Initialize( s_IndentString ) ||
        !PortString.Strcat( s_StringPort )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the channel
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%d", Descriptor->GetChannel() );

    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    ChannelString.Strcat( &AuxString );
    if( !PrintString( &ChannelString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the port
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%d", Descriptor->GetPort() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    PortString.Strcat( &AuxString );
    if( !PrintString( &PortString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintDeviceSpecificDescriptor
//
// DESCRIPTION: Print the contents of a DEVICE_SPECIFIC_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintDeviceSpecificDescriptor(PCDEVICE_SPECIFIC_DESCRIPTOR Descriptor)
{
    DSTRING     Reserved1String;
    DSTRING     Reserved2String;
    DSTRING     DataString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];

    ULONG       Size;
    PCBYTE      Data;

    if( !Reserved1String.Initialize( s_IndentString ) ||
        !Reserved1String.Strcat( s_StringReserved1 ) ||
        !Reserved2String.Initialize( s_IndentString ) ||
        !Reserved2String.Strcat( s_StringReserved2 ) ||
        !DataString.Initialize( s_IndentString ) ||
        !DataString.Strcat( s_StringDevSpecificData )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print reserved1
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"0x%08x", Descriptor->GetReserved1() );

    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    Reserved1String.Strcat( &AuxString );
    if( !PrintString( &Reserved1String ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print reserved2
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"0x%08x", Descriptor->GetReserved2() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    Reserved2String.Strcat( &AuxString );
    if( !PrintString( &Reserved2String ) ) {
        return FALSE;
    }
    PrintNewLine();

    Size = Descriptor->GetData( &Data );
    if( ( Size != 0 ) &&
        ( Data != NULL ) ) {
        if( !PrintString( &DataString ) ) 
        {
            return FALSE;
        }
        PrintBinaryData((PBYTE)Data, Size);
        PrintNewLine();
    }
    return TRUE;
}


//------------------------------------------------------------------------------
// PrintDataRegRequirementsList
//
// DESCRIPTION: Print the contents of a DEVICE_SPECIFIC_DESCRIPTOR object.
//
// PARAMETERS:  
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintDataRegRequirementsList(PBYTE Data, ULONG Size)
{
    IO_REQUIREMENTS_LIST    RequirementsList;
    PARRAY                  AlternativeLists;
    PITERATOR               Iterator;
    PCIO_DESCRIPTOR_LIST    ResourceList;
    ULONG                   ListNumber;

    DSTRING     AuxString;
    DSTRING     InterfaceType;
    DSTRING     BusNumber;
    DSTRING     SlotNumber;
    WCHAR       AuxNumber[11];
    PWSTRING     TypeString;
    ULONG       InterfaceId;

    PrintNewLine();

    if( ( Size == 0 ) ||
        ( Data == NULL ) ||
        !RequirementsList.Initialize( Data, Size ) ) {
        DebugPrintTrace(( "REGEDT32: Unable to initialize RequirementsList \n" ));
        return FALSE;
    }

    if( !InterfaceType.Initialize( s_IndentString ) ||
        !InterfaceType.Strcat( s_StringIoInterfaceType ) ||
        !BusNumber.Initialize( s_IndentString ) ||
        !BusNumber.Strcat( s_StringIoBusNumber ) ||
        !SlotNumber.Initialize( s_IndentString ) ||
        !SlotNumber.Strcat( s_StringIoSlotNumber )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the interface type
    //

    switch( RequirementsList.GetInterfaceType() ) {

    case Internal:

        InterfaceId =  IDS_BUS_INTERNAL;
        break;

    case Isa:

        InterfaceId =  IDS_BUS_ISA;
        break;

    case Eisa:

        InterfaceId =  IDS_BUS_EISA;
        break;

    case MicroChannel:

        InterfaceId =  IDS_BUS_MICRO_CHANNEL;
        break;

    case TurboChannel:

        InterfaceId =  IDS_BUS_TURBO_CHANNEL;
        break;

    case PCIBus:

        InterfaceId =  IDS_BUS_PCI_BUS;
        break;

    case VMEBus:

        InterfaceId =  IDS_BUS_VME_BUS;
        break;

    case NuBus:

        InterfaceId =  IDS_BUS_NU_BUS;
        break;

    case PCMCIABus:

        InterfaceId =  IDS_BUS_PCMCIA_BUS;
        break;

    case CBus:

        InterfaceId =  IDS_BUS_C_BUS;
        break;

    case MPIBus:

        InterfaceId =  IDS_BUS_MPI_BUS;
        break;

    case MPSABus:

        InterfaceId =  IDS_BUS_MPSA_BUS;
        break;

    default:

        InterfaceId =  IDS_INVALID;
        break;
    }

    TypeString =  REGEDIT_BASE_SYSTEM::QueryString( InterfaceId, "" );

    if( TypeString == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    InterfaceType.Strcat( TypeString );
    DELETE( TypeString );
    if( !PrintString( &InterfaceType ) ) {
        return FALSE;
    }
    PrintNewLine();


    //
    //  Print the bus number
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%d", RequirementsList.GetBusNumber() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    BusNumber.Strcat( &AuxString );

    if( !PrintString( &BusNumber ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the slot number
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%d", RequirementsList.GetSlotNumber() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    SlotNumber.Strcat( &AuxString );

    if( !PrintString( &SlotNumber ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the resource lists
    //

    if( ( ( AlternativeLists = RequirementsList.GetAlternativeLists() ) == NULL ) ||
        ( ( Iterator = AlternativeLists->QueryIterator() ) == NULL ) ) {
        DebugPrintTrace(( "REGEDT32: Out of memory! \n" ));
        return FALSE;
    }
    ListNumber = 0;
    while( ( ResourceList = ( PCIO_DESCRIPTOR_LIST )( Iterator->GetNext() ) ) != NULL ) {
        if( !_PrintIoResourceList( ResourceList, ListNumber ) ) {
            DELETE( Iterator );
            return FALSE;
        }
        ListNumber++;
    }
    DELETE( Iterator );
    return TRUE;
}


//------------------------------------------------------------------------------
// PrintIoResourceList
//
// DESCRIPTION: Print the contents of an IO_DESCRIPTOR_LIST object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintIoResourceList(PCIO_DESCRIPTOR_LIST DescriptorList, UINT ListNumber)
{
    DSTRING     ListNumberString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[11];
    PARRAY      Descriptors;
    PITERATOR   Iterator;
    PCIO_DESCRIPTOR    IoDescriptor;
    ULONG       Count;

    if( !ListNumberString.Initialize( s_IndentString ) ||
        !ListNumberString.Strcat( s_StringIoListNumber )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Build a string that contains the list number
    //  and print it
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%d", ListNumber );
    if( !AuxString.Initialize( AuxNumber ) ) {
    DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    ListNumberString.Strcat( &AuxString );
    if( !PrintString( &ListNumberString ) ) {
        return FALSE;
    }
    PrintNewLine();

    Descriptors = DescriptorList->GetDescriptorsList();
    if( ( Descriptors == NULL ) ||
        ( ( Iterator = Descriptors->QueryIterator() ) == NULL )
      ) {
        return FALSE;
    }
    Count = 0;
    while( ( IoDescriptor = ( PCIO_DESCRIPTOR )( Iterator->GetNext() ) ) != NULL ) {
        if( !_PrintIoDescriptor( IoDescriptor, Count ) ) {
            DELETE( Iterator );
            return FALSE;
        }
        Count++;
    }
    DELETE( Iterator );

    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintIoDescriptor
//
// DESCRIPTION: Print the contents of an IO_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintIoDescriptor(PCIO_DESCRIPTOR IoDescriptor, ULONG DescriptorNumber)
{
    DSTRING     IoDescriptorNumberString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[11];
    DSTRING     ResourceString;
    DSTRING     DispositionString;
    DSTRING     OptionString;
    ULONG       StringId;
    PWSTRING    String;

    if( !IoDescriptorNumberString.Initialize( s_IndentString ) ||
        !IoDescriptorNumberString.Strcat( s_StringIoDescriptorNumber ) ||
        !ResourceString.Initialize( s_IndentString ) ||
        !ResourceString.Strcat( s_StringResource ) ||
        !OptionString.Initialize( s_IndentString ) ||
        !OptionString.Strcat( s_StringIoOption ) ||
        !DispositionString.Initialize( s_IndentString ) ||
        !DispositionString.Strcat( s_StringDisposition )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Build a string that contains the full descriptor number
    //  and print it
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%d", DescriptorNumber );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    IoDescriptorNumberString.Strcat( &AuxString );
    if( !PrintString( &IoDescriptorNumberString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the resource type
    //
    if( IoDescriptor->IsDescriptorTypeDma() ) {
        StringId = IDS_DEV_DMA;
    } else if( IoDescriptor->IsDescriptorTypeInterrupt() ) {
        StringId = IDS_DEV_INTERRUPT;
    } else if( IoDescriptor->IsDescriptorTypeMemory() ) {
        StringId = IDS_DEV_MEMORY;
    } else if( IoDescriptor->IsDescriptorTypePort() ) {
        StringId = IDS_DEV_PORT;
    } else {
        StringId = IDS_INVALID;
    }
    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );

    if( String == NULL ) 
    {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    ResourceString.Strcat( String );
    DELETE( String );
    if( !PrintString( &ResourceString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the option
    //

    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"0x%08x", IoDescriptor->GetOption() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    OptionString.Strcat( &AuxString );
    if( !PrintString( &OptionString ) ) {
        return FALSE;
    }
    PrintNewLine();



    //
    //  Print the disposition
    //
    if( IoDescriptor->IsResourceShareUndetermined() ) {
        StringId = IDS_SHARE_UNDETERMINED;
    } else if( IoDescriptor->IsResourceShareDeviceExclusive() ) {
        StringId = IDS_SHARE_DEVICE_EXCLUSIVE;
    } else if( IoDescriptor->IsResourceShareDriverExclusive() ) {
        StringId = IDS_SHARE_DRIVER_EXCLUSIVE;
    } else {
        StringId = IDS_SHARE_SHARED;
    }

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );

    if( String == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    DispositionString.Strcat( String );
    DELETE( String );
    if( !PrintString( &DispositionString ) ) {
        return FALSE;
    }
    PrintNewLine();

    if( IoDescriptor->IsDescriptorTypeDma() ) {
        if( !_PrintIoDmaDescriptor( ( PCIO_DMA_DESCRIPTOR )IoDescriptor ) ) {
            return FALSE;
        }
    } else if( IoDescriptor->IsDescriptorTypeInterrupt() ) {
        if( !_PrintIoInterruptDescriptor( ( PCIO_INTERRUPT_DESCRIPTOR )IoDescriptor ) ) {
            return FALSE;
        }
    } else if( IoDescriptor->IsDescriptorTypeMemory() ) {
        if( !_PrintIoMemoryDescriptor( ( PCIO_MEMORY_DESCRIPTOR )IoDescriptor ) ) {
            return FALSE;
        }
    } else if( IoDescriptor->IsDescriptorTypePort() ) {
        if( !_PrintIoPortDescriptor( ( PCIO_PORT_DESCRIPTOR )IoDescriptor ) ) {
            return FALSE;
        }
    }

    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintIoInterruptDescriptor
//
// DESCRIPTION: Print the contents of an IO_INTERRUPT_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintIoInterruptDescriptor(PCIO_INTERRUPT_DESCRIPTOR Descriptor)
{
    DSTRING     MinimumVectorString;
    DSTRING     MaximumVectorString;
    DSTRING     TypeString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];
    ULONG       StringId;
    PWSTRING    String;

    if( !MinimumVectorString.Initialize( s_IndentString ) ||
        !MinimumVectorString.Strcat( s_StringIoMinimumVector ) ||
        !MaximumVectorString.Initialize( s_IndentString ) ||
        !MaximumVectorString.Strcat( s_StringIoMaximumVector ) ||
        !TypeString.Initialize( s_IndentString ) ||
        !TypeString.Strcat( s_StringType )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the type
    //

    StringId = ( Descriptor->IsInterruptLevelSensitive() )? IDS_INT_LEVEL_SENSITIVE :
                                                            IDS_INT_LATCHED;

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );
    if( String == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    TypeString.Strcat( String );
    DELETE( String );
    if( !PrintString( &TypeString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the minimum vector
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%#x", Descriptor->GetMinimumVector() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MinimumVectorString.Strcat( &AuxString );
    if( !PrintString( &MinimumVectorString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the maximum vector
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%#x", Descriptor->GetMaximumVector() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MaximumVectorString.Strcat( &AuxString );
    if( !PrintString( &MaximumVectorString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintIoPortDescriptor
//
// DESCRIPTION: Print the contents of an IO_PORT_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintIoPortDescriptor(PCIO_PORT_DESCRIPTOR Descriptor)
{
    DSTRING     MinimumAddressString;
    DSTRING     MaximumAddressString;
    DSTRING     LengthString;
    DSTRING     AlignmentString;
    DSTRING     TypeString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];
    ULONG       StringId;
    PWSTRING    String;

    if( !MinimumAddressString.Initialize( s_IndentString ) ||
        !MinimumAddressString.Strcat( s_StringIoMinimumAddress ) ||
        !MaximumAddressString.Initialize( s_IndentString ) ||
        !MaximumAddressString.Strcat( s_StringIoMaximumAddress ) ||
        !LengthString.Initialize( s_IndentString ) ||
        !LengthString.Strcat( s_StringLength ) ||
        !AlignmentString.Initialize( s_IndentString ) ||
        !AlignmentString.Strcat( s_StringIoAlignment ) ||
        !TypeString.Initialize( s_IndentString ) ||
        !TypeString.Strcat( s_StringType )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the type
    //

    StringId = ( Descriptor->IsPortMemory() )? IDS_PORT_MEMORY :
                                               IDS_PORT_PORT;

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );
    if( String == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    TypeString.Strcat( String );
    DELETE( String );
    if( !PrintString( &TypeString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the length
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%#x", Descriptor->GetLength() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    LengthString.Strcat( &AuxString );
    if( !PrintString( &LengthString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the alignment
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%#x", Descriptor->GetAlignment() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    AlignmentString.Strcat( &AuxString );
    if( !PrintString( &AlignmentString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the minimum address
    //
    if( ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->HighPart != 0 ) 
    {
        StringCchPrintf( AuxNumber,
                        ARRAYSIZE(AuxNumber),
                        (LPWSTR)L"0x%08x%08x",
                        ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->HighPart,
                        ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->LowPart );
    } 
    else 
    {
        StringCchPrintf( AuxNumber, 
                        ARRAYSIZE(AuxNumber),
                        (LPWSTR)L"0x%08x", 
                        ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->LowPart );
    }
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MinimumAddressString.Strcat( &AuxString );
    if( !PrintString( &MinimumAddressString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the maximum address
    //
    if( ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->HighPart != 0 ) {
        StringCchPrintf( AuxNumber,
                        ARRAYSIZE(AuxNumber),
                        (LPWSTR)L"0x%08x%08x",
                        ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->HighPart,
                        ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->LowPart );
    } 
    else 
    {
        StringCchPrintf( AuxNumber, 
                        ARRAYSIZE(AuxNumber), 
                        (LPWSTR)L"0x%08x", 
                        ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->LowPart );
    }
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MaximumAddressString.Strcat( &AuxString );
    if( !PrintString( &MaximumAddressString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintIoMemoryDescriptor
//
// DESCRIPTION:  Print the contents of an IO_MEMORY_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintIoMemoryDescriptor(PCIO_MEMORY_DESCRIPTOR Descriptor)
{
    DSTRING     MinimumAddressString;
    DSTRING     MaximumAddressString;
    DSTRING     LengthString;
    DSTRING     AlignmentString;
    DSTRING     TypeString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];
    ULONG       StringId;
    PWSTRING    String;

    if( !MinimumAddressString.Initialize( s_IndentString ) ||
        !MinimumAddressString.Strcat( s_StringIoMinimumAddress ) ||
        !MaximumAddressString.Initialize( s_IndentString ) ||
        !MaximumAddressString.Strcat( s_StringIoMaximumAddress ) ||
        !LengthString.Initialize( s_IndentString ) ||
        !LengthString.Strcat( s_StringLength ) ||
        !AlignmentString.Initialize( s_IndentString ) ||
        !AlignmentString.Strcat( s_StringIoAlignment ) ||
        !TypeString.Initialize( s_IndentString ) ||
        !TypeString.Strcat( s_StringType )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the type
    //

    StringId = ( Descriptor->IsMemoryReadWrite() )? IDS_MEM_READ_WRITE :
                                                    ( ( Descriptor->IsMemoryReadWrite() )? IDS_MEM_READ_ONLY :
                                                                                           IDS_MEM_WRITE_ONLY );

    String =  REGEDIT_BASE_SYSTEM::QueryString( StringId, "" );
    if( String == NULL ) {
        DebugPrintTrace(( "REGEDT32: Unable to retrieve string \n" ));
        return FALSE;
    }
    TypeString.Strcat( String );
    DELETE( String );
    if( !PrintString( &TypeString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the length
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%#x", Descriptor->GetLength() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    LengthString.Strcat( &AuxString );
    if( !PrintString( &LengthString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the alignment
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%#x", Descriptor->GetAlignment() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    AlignmentString.Strcat( &AuxString );
    if( !PrintString( &AlignmentString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the minimum address
    //
    if( ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->HighPart != 0 ) 
    {
        StringCchPrintf( AuxNumber,
                        ARRAYSIZE(AuxNumber),
                        (LPWSTR)L"0x%08x%08x",
                        ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->HighPart,
                        ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->LowPart );
    } 
    else 
    {
        StringCchPrintf( AuxNumber, 
                        ARRAYSIZE(AuxNumber), 
                        (LPWSTR)L"0x%08x", 
                        ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMinimumAddress() )->LowPart );
    }
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MinimumAddressString.Strcat( &AuxString );
    if( !PrintString( &MinimumAddressString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the maximum address
    //
    if( ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->HighPart != 0 ) 
    {
        StringCchPrintf( AuxNumber,
                        ARRAYSIZE(AuxNumber), 
                        (LPWSTR)L"0x%08x%08x",
                        ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->HighPart,
                        ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->LowPart );
    } 
    else 
    {
        StringCchPrintf( AuxNumber, 
                        ARRAYSIZE(AuxNumber), 
                        (LPWSTR)L"0x%08x", 
                        ( ( ( PIO_PORT_DESCRIPTOR )Descriptor )->GetMaximumAddress() )->LowPart );
    }
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MaximumAddressString.Strcat( &AuxString );
    if( !PrintString( &MaximumAddressString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}


//------------------------------------------------------------------------------
// PrintIoDmaDescriptor
//
// DESCRIPTION:  Print the contents of an IO_DMA_DESCRIPTOR object.
//
// PARAMETERS:  Descriptor - Pointer to object to be printed.
//------------------------------------------------------------------------------
BOOL PRINT_RESOURCE::_PrintIoDmaDescriptor(PCIO_DMA_DESCRIPTOR Descriptor)
{
    DSTRING     MinimumChannelString;
    DSTRING     MaximumChannelString;

    DSTRING     AuxString;
    WCHAR       AuxNumber[19];

    if( !MinimumChannelString.Initialize( s_IndentString ) ||
        !MinimumChannelString.Strcat( s_StringIoMinimumChannel ) ||
        !MaximumChannelString.Initialize( s_IndentString ) ||
        !MaximumChannelString.Strcat( s_StringIoMaximumChannel )
      ) {
        DebugPrint( "REGEDT32: Initialization failure" );
        return FALSE;
    }

    //
    //  Print the minimum channel
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%#x", Descriptor->GetMinimumChannel() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MinimumChannelString.Strcat( &AuxString );
    if( !PrintString( &MinimumChannelString ) ) {
        return FALSE;
    }
    PrintNewLine();

    //
    //  Print the maximum channel
    //
    StringCchPrintf( AuxNumber, ARRAYSIZE(AuxNumber), (LPWSTR)L"%#x", Descriptor->GetMaximumChannel() );
    if( !AuxString.Initialize( AuxNumber ) ) {
        DebugPrint( "AuxString.Initialize() failed" );
        return FALSE;
    }
    MaximumChannelString.Strcat( &AuxString );
    if( !PrintString( &MaximumChannelString ) ) {
        return FALSE;
    }
    PrintNewLine();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regsec.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    regsec.cpp

Abstract:

    ISecurityInformation implementation for Registry Key

Author:

    Hitesh Raigandhi (raigah) May-1999


Revision History:

--*/

//Include Files:


// #include "wchar.h"
#include "regsec.h"
#include "regresid.h"
#include "assert.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

// ISecurityInformation interface implementation

EXTERN_C const GUID IID_ISecurityInformation ; 

// = { 0x965fc360, 0x16ff, 0x11d0, 0x91, 0xcb, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x23 }; 

//The Following array defines the permission names for Registry Key Objects
SI_ACCESS siKeyAccesses[] =
{
    { NULL, 
        KEY_ALL_ACCESS,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_FULL_ACCESS), 
        SI_ACCESS_GENERAL | CONTAINER_INHERIT_ACE | SI_ACCESS_SPECIFIC },
    { NULL, 
        KEY_QUERY_VALUE, 
        MAKEINTRESOURCE(IDS_SEC_EDITOR_QUERY_VALUE), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        KEY_SET_VALUE,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_SET_VALUE), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        KEY_CREATE_SUB_KEY,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_CREATE_SUBKEY), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        KEY_ENUMERATE_SUB_KEYS,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_ENUM_SUBKEYS), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        KEY_NOTIFY,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_NOTIFY), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        KEY_CREATE_LINK,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_CREATE_LINK), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        0x00010000, /* DELETE, */
        MAKEINTRESOURCE(IDS_SEC_EDITOR_DELETE), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        WRITE_DAC,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_WRITE_DAC), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        WRITE_OWNER,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_WRITE_OWNER), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        READ_CONTROL,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_READ_CONTROL), 
        SI_ACCESS_SPECIFIC | CONTAINER_INHERIT_ACE },
    { NULL, 
        KEY_READ,
        MAKEINTRESOURCE(IDS_SEC_EDITOR_READ), 
        SI_ACCESS_GENERAL | CONTAINER_INHERIT_ACE  },
};

// The following array defines the inheritance types for Registry.
//
//
// For Keys, objects and containers are the same, so no need for OBJECT_INHERIT_ACE
//
SI_INHERIT_TYPE siKeyInheritTypes[] =
{
        NULL, 0,                                        MAKEINTRESOURCE(IDS_KEY_FOLDER),
        NULL, CONTAINER_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_KEY_FOLDER_SUBFOLDER),
        NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE, MAKEINTRESOURCE(IDS_KEY_SUBFOLDER_ONLY)
};


#define iKeyDefAccess                 10     // index of value in array siKeyAccesses
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)                    (sizeof(x)/sizeof(x[0]))
#endif


PWSTR _PredefinedKeyName[] = {    L"CLASSES_ROOT",
                                L"CURRENT_USER",
                                L"MACHINE",
                                L"USERS",
                                L"CONFIG" };




//CKeySecurityInformation Functions
    
HRESULT 
CKeySecurityInformation::Initialize( LPCWSTR strKeyName,
                                             LPCWSTR strParentName,
                                             LPCWSTR strMachineName,
                                             LPCWSTR strPageTitle,
                                             BOOL        bRemote,
                                             PREDEFINE_KEY PredefinedKey,    
                                             BOOL bReadOnly,
                                             HWND hWnd)
{
    if( strParentName )
        if( !strKeyName )
            return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

     if( NULL == strMachineName )
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

     if( NULL == hWnd )
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

     if( NULL == strPageTitle )
         return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    
     AuthzInitializeResourceManager(AUTHZ_RM_FLAG_NO_AUDIT,
                                    NULL,
                                    NULL,
                                    NULL,
                                    0, 
                                    &m_ResourceManager );


    HRESULT hr = S_OK;
    m_strKeyName = strKeyName;
    m_strParentName = strParentName;
    m_strMachineName = strMachineName;
    m_strPageTitle = strPageTitle;
    m_bRemote = bRemote;
    m_PredefinedKey = PredefinedKey;
    m_bReadOnly = bReadOnly;
    m_hWnd = hWnd;
    m_dwFlags = SI_EDIT_ALL | SI_ADVANCED | SI_CONTAINER
                        | SI_RESET_DACL_TREE | SI_RESET_SACL_TREE 
                        | SI_OWNER_RECURSE | SI_PAGE_TITLE | SI_EDIT_EFFECTIVE;

    if( m_bReadOnly )
        m_dwFlags |= SI_READONLY | SI_OWNER_READONLY ;




    //Set Handle to Predfined key
    if( S_OK    != ( hr = SetHandleToPredefinedKey() ) )
        return hr;
 

    //Set CompleteName
    if( S_OK != ( hr = SetCompleteName() ) )
        return hr;

    return S_OK;

}

CKeySecurityInformation::~CKeySecurityInformation()
{
    if( m_strCompleteName )
        LocalFree( m_strCompleteName );
    
    //Close Handle to Remote Registry if it was successfully opened.
    if( m_bRemote && m_hkeyPredefinedKey )
        RegCloseKey(m_hkeyPredefinedKey);

   AuthzFreeResourceManager(m_ResourceManager);


}



//Sets the complete name in Format:
// "\\machine_name\Predefined_keyName\regkey_path
HRESULT  
CKeySecurityInformation::SetCompleteName()
{
    UINT len = 0;
    PWSTR pstrCompleteName;
    
    if( m_bRemote )
    {
        len += wcslen( m_strMachineName );
        len++;
    }

    len += wcslen(_PredefinedKeyName[m_PredefinedKey]);
    len++;

    if( m_strParentName )
    {
        len += wcslen(m_strParentName);
        len++;
    }

    if( m_strKeyName )
    {
        len += wcslen(m_strKeyName);
        len++;
    }

    len++;    //Terminating null

    pstrCompleteName = (PWSTR)LocalAlloc(LPTR, len * sizeof(WCHAR));
    if( pstrCompleteName == NULL )
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

    if( m_bRemote )
    {
        StringCchCopyW(pstrCompleteName, len, m_strMachineName);
        StringCchCatW(pstrCompleteName, len, L"\\");
    }

    StringCchCatW(pstrCompleteName, len, _PredefinedKeyName[m_PredefinedKey]);
    StringCchCatW(pstrCompleteName, len, L"\\");
    if(m_strParentName)
    {
        StringCchCatW(pstrCompleteName, len, m_strParentName);
        StringCchCatW(pstrCompleteName, len, L"\\");
    }

    if(m_strKeyName)
    {
        StringCchCatW(pstrCompleteName, len, m_strKeyName );
        StringCchCatW(pstrCompleteName, len, L"\\");
    }
    
    m_strCompleteName = pstrCompleteName;

    return S_OK;
}

//Doesn't have Predefined key name attached
//Caller must LocalFree
LPCWSTR 
CKeySecurityInformation::GetCompleteName1()
{
    UINT len = 0;
    PWSTR pstrCompleteName;
    
    if( m_strParentName )
    {
        len += wcslen(m_strParentName);
        len++;
    }

    if( m_strKeyName )
    {
        len += wcslen(m_strKeyName);
        len++;
    }

    len++;     //Terminating null

    pstrCompleteName = (PWSTR)LocalAlloc(LPTR, len * sizeof(WCHAR));
    if( pstrCompleteName == NULL )
        return NULL;

    if(m_strParentName)
    {
        StringCchCopyW(pstrCompleteName, len, m_strParentName);
        StringCchCatW(pstrCompleteName, len, L"\\");
    }

    if(m_strKeyName)
    {
        StringCchCatW(pstrCompleteName, len, m_strKeyName );
        StringCchCatW(pstrCompleteName, len, L"\\");
    }
    return pstrCompleteName;
}


HRESULT
CKeySecurityInformation::SetHandleToPredefinedKey()
{
    DWORD dwErr;
    HRESULT hr = S_OK;
    if( !m_bRemote ) {
        switch ( m_PredefinedKey ){
        case PREDEFINE_KEY_CLASSES_ROOT:
                m_hkeyPredefinedKey= HKEY_CLASSES_ROOT;
                break;
        case PREDEFINE_KEY_CURRENT_USER: 
                m_hkeyPredefinedKey = HKEY_CURRENT_USER;
                break;
        case PREDEFINE_KEY_LOCAL_MACHINE :
                m_hkeyPredefinedKey = HKEY_LOCAL_MACHINE;
                break;
        case PREDEFINE_KEY_USERS:
                m_hkeyPredefinedKey = HKEY_USERS;
                break;
        case PREDEFINE_KEY_CURRENT_CONFIG :
                m_hkeyPredefinedKey = HKEY_CURRENT_CONFIG;
                break;
        default:
                    //assert(false);
            break;
        }
    } 
    else {        //IsRemoteRegistry
        switch ( m_PredefinedKey ){
        case PREDEFINE_KEY_CLASSES_ROOT:
        case PREDEFINE_KEY_CURRENT_USER:
        case PREDEFINE_KEY_CURRENT_CONFIG:
                m_hkeyPredefinedKey = 0;
                break;
        case PREDEFINE_KEY_LOCAL_MACHINE :
                m_hkeyPredefinedKey = HKEY_LOCAL_MACHINE;
                break;
        case PREDEFINE_KEY_USERS:
                m_hkeyPredefinedKey = HKEY_USERS;
                break;
        default:
                    //assert(false);
                break;
        }
        if( m_hkeyPredefinedKey ){
             dwErr = RegConnectRegistry( m_strMachineName,
                                                                     m_hkeyPredefinedKey,
                                                                     &m_hkeyPredefinedKey );
            if( dwErr ) {
                m_hkeyPredefinedKey = 0;
                hr = HRESULT_FROM_WIN32( dwErr );
            }
        }
    }     //IsRemoteRegistry

    return hr;
}
/*
JeffreyS 1/24/97:
If you don't set the SI_RESET flag in
ISecurityInformation::GetObjectInformation, then fDefault should never be TRUE
so you can ignore it.  Returning E_NOTIMPL in this case is OK too.

If you want the user to be able to reset the ACL to some default state
(defined by you) then turn on SI_RESET and return your default ACL
when fDefault is TRUE.    This happens if/when the user pushes a button
that is only visible when SI_RESET is on.
*/
STDMETHODIMP 
CKeySecurityInformation::GetObjectInformation (
        PSI_OBJECT_INFO pObjectInfo )
{
        assert( NULL != pObjectInfo );
        pObjectInfo->dwFlags = m_dwFlags;
        pObjectInfo->hInstance = GetModuleHandle(NULL);
//        pObjectInfo->pszServerName = (LPWSTR)m_strMachineName;
        pObjectInfo->pszServerName = (LPWSTR)m_strMachineName;
        pObjectInfo->pszObjectName = (LPWSTR)m_strPageTitle;
        return S_OK;
}


STDMETHODIMP
CKeySecurityInformation::GetAccessRights(
        const GUID    *pguidObjectType,
        DWORD             dwFlags,
        PSI_ACCESS    *ppAccess,
        ULONG             *pcAccesses,
        ULONG             *piDefaultAccess
)
{
    assert( NULL != ppAccess );
    assert( NULL != pcAccesses );
    assert( NULL != piDefaultAccess );

    *ppAccess = siKeyAccesses;
    *pcAccesses = ARRAYSIZE(siKeyAccesses);
    *piDefaultAccess = iKeyDefAccess;

    return S_OK;
}


GENERIC_MAPPING KeyMap =
{
    KEY_READ,
    KEY_WRITE,
    KEY_READ,
    KEY_ALL_ACCESS
};

STDMETHODIMP
CKeySecurityInformation::MapGeneric(
        const GUID    *pguidObjectType,
        UCHAR             *pAceFlags,
        ACCESS_MASK *pMask
)
{
//jeffreys
// After returning from the object picker dialog, aclui passes 
//CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE to MapGeneric for validation when 
//    initializing Permission entry for <objectname> dialog.
//hiteshr: since registry keys don't have OBJECT_INHERIT_ACE, remove this FLAG,
//this will cause "this keys and subkeys" to appear as default in combobox.


    *pAceFlags &= ~OBJECT_INHERIT_ACE;
    
    MapGenericMask(pMask, &KeyMap);

    return S_OK;
}

STDMETHODIMP 
CKeySecurityInformation::GetInheritTypes (
        PSI_INHERIT_TYPE    *ppInheritTypes,
        ULONG                         *pcInheritTypes
)
{
    assert( NULL != ppInheritTypes );
    assert( NULL != pcInheritTypes );
    *ppInheritTypes = siKeyInheritTypes;
    *pcInheritTypes = ARRAYSIZE(siKeyInheritTypes);
    return S_OK;
}

STDMETHODIMP 
CKeySecurityInformation::PropertySheetPageCallback(
        HWND                    hwnd, 
        UINT                    uMsg, 
        SI_PAGE_TYPE    uPage
)
{
  switch (uMsg)
  {
  case PSPCB_SI_INITDIALOG:
    m_hWndProperty = hwnd;
    break;
  case PSPCB_RELEASE:
    m_hWndProperty = NULL;
    break;
  }

  return S_OK;
}


STDMETHODIMP 
CKeySecurityInformation::GetSecurity( IN    SECURITY_INFORMATION    RequestedInformation,
                                      OUT PSECURITY_DESCRIPTOR    *ppSecurityDescriptor,
                                      IN    BOOL    fDefault )
{
    if( fDefault )
        return E_NOTIMPL;
    
    assert( NULL != ppSecurityDescriptor );

    HRESULT hr;

    LPCTSTR pstrKeyName = GetCompleteName();
    DWORD dwErr = 0;


    dwErr = GetNamedSecurityInfo(  (LPTSTR)pstrKeyName,
                                    SE_REGISTRY_KEY,
                                    RequestedInformation,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    ppSecurityDescriptor);


    return ( ( dwErr != ERROR_SUCCESS ) ? HRESULT_FROM_WIN32(dwErr) : S_OK);

}

STDMETHODIMP 
CKeySecurityInformation::SetSecurity(IN SECURITY_INFORMATION si,
                                     IN PSECURITY_DESCRIPTOR pSD )
{
   if( NULL == pSD )
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

   HRESULT hr = S_OK;
   SECURITY_INFORMATION siLocal = 0;
   SECURITY_DESCRIPTOR sdLocal = {0};
   ACL daclEmpty = {0};
   HKEY hkeyOld = NULL;
   HKEY hKeyNew = NULL;
   BOOL bWriteInfo = false;
   DWORD Error = 0;
   
    //
    // Create a security descriptor with no SACL and an
    // empty DACL for recursively resetting security
    //
    InitializeSecurityDescriptor(&sdLocal, SECURITY_DESCRIPTOR_REVISION);
    InitializeAcl(&daclEmpty, sizeof(daclEmpty), ACL_REVISION);
    SetSecurityDescriptorDacl(&sdLocal, TRUE, &daclEmpty, FALSE);
    SetSecurityDescriptorSacl(&sdLocal, TRUE, &daclEmpty, FALSE);

    //
    // If we need to recursively set the Owner, get the Owner &
    // Group from pSD.
    //
    if (si & SI_OWNER_RECURSE)
    {
            PSID psid;
            BOOL bDefaulted;
            assert(si & (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION));
            siLocal |= si & (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION);

            if (GetSecurityDescriptorOwner(pSD, &psid, &bDefaulted))
                SetSecurityDescriptorOwner(&sdLocal, psid, bDefaulted);
           if (GetSecurityDescriptorGroup(pSD, &psid, &bDefaulted))
                SetSecurityDescriptorGroup(&sdLocal, psid, bDefaulted);
    }

    if (si & SI_RESET_DACL_TREE)
    {
        assert(si & DACL_SECURITY_INFORMATION);
        siLocal |= si & DACL_SECURITY_INFORMATION;
    }

    if (si & SI_RESET_SACL_TREE)
    {
        assert(si & SACL_SECURITY_INFORMATION);
        siLocal |= si & SACL_SECURITY_INFORMATION;
    }

   if( siLocal )
   {
      //Open the key with current Maximum Allowed Permisson
      //When applying permissons recursively , we first use current permisson,
      //if current permisson doesn't have enough rights, we reopen handle to key with
      //new permissons. If none (old or new )has enough permissons to enumerate child and
      // Query info we fail.
      REGSAM samDesired = MAXIMUM_ALLOWED;
        if( si & SACL_SECURITY_INFORMATION ) 
                samDesired |= ACCESS_SYSTEM_SECURITY;
        if( si & DACL_SECURITY_INFORMATION ) 
                samDesired |= WRITE_DAC;
        if( si & OWNER_SECURITY_INFORMATION )
                samDesired |= WRITE_OWNER;

        //Open the selected key
        if( S_OK != ( hr = OpenKey( samDesired, &hkeyOld ) ) ){
                return hr;
        }

    
        //Check if key has Enumeration Permisson
        DWORD             NumberOfSubKeys = 0;
        DWORD             MaxSubKeyLength = 0;
        
      //    Find out the total number of subkeys
        Error = RegQueryInfoKey(
                                hkeyOld,
                                NULL,
                                NULL,
                                NULL,
                                &NumberOfSubKeys,
                                &MaxSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );

        if( Error != ERROR_SUCCESS ){
         if( Error == ERROR_ACCESS_DENIED ) {

            hr = WriteObjectSecurity( hkeyOld, si, pSD );

            if( hr != S_OK )
            {
               if( m_hkeyPredefinedKey != hkeyOld )
                  RegCloseKey( hkeyOld );
               return hr;
            }
            bWriteInfo = true;
            //
            //  Handle doesn't allow KEY_QUERY_VALUE or READ_CONTROL access.
            //  Open a new handle with these accesses.
            //
            samDesired = MAXIMUM_ALLOWED;
            if( si & SACL_SECURITY_INFORMATION ) {
               samDesired |= ACCESS_SYSTEM_SECURITY;
            } else if( si & DACL_SECURITY_INFORMATION ) {
               samDesired |= WRITE_DAC;
            } else if( si & OWNER_SECURITY_INFORMATION ) {
               samDesired |= WRITE_OWNER;
            }
            
            Error = RegOpenKeyEx( hkeyOld,
                                 NULL,
                                 REG_OPTION_RESERVED,
                                 samDesired,
                                 &hKeyNew
                                 );

            if( Error != ERROR_SUCCESS )
            {  
               if( m_hkeyPredefinedKey != hkeyOld )
                  RegCloseKey( hkeyOld );
               return HRESULT_FROM_WIN32(Error);                  
            }
            else
            {
               if( m_hkeyPredefinedKey != hkeyOld )
                  RegCloseKey( hkeyOld );
            }
            
              Error = RegQueryInfoKey(
                                            hKeyNew,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &NumberOfSubKeys,
                                            &MaxSubKeyLength,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL );
            
            if( Error != ERROR_SUCCESS ) {
               RegCloseKey( hKeyNew );
               return HRESULT_FROM_WIN32( Error );
            }
         }
         else
         {
            if( m_hkeyPredefinedKey != hkeyOld )
               RegCloseKey( hkeyOld );
            return HRESULT_FROM_WIN32( Error );
         }
        }
      else
         hKeyNew = hkeyOld;
      
      if( NumberOfSubKeys )
      {
           assert( MaxSubKeyLength <= MAX_PATH );
        
           DWORD SubKeyNameLength = 0;
           WCHAR SubKeyName[MAX_PATH + 1];

         //
         //  The key has subkeys.
         //  Find out if we are able to enumerate the key using the handle
         //  passed as argument.
         //
         SubKeyNameLength = MAX_PATH;
         Error = RegEnumKey( hKeyNew,
                             0,
                             SubKeyName,
                             SubKeyNameLength );

         if( Error != ERROR_SUCCESS ){
            if( Error == ERROR_ACCESS_DENIED && bWriteInfo == false ){

               hr = WriteObjectSecurity( hkeyOld, si, pSD );

               if( hr != S_OK )
               {
                  if( m_hkeyPredefinedKey != hkeyOld )
                     RegCloseKey( hkeyOld );
                  return hr;
               }

               bWriteInfo = true;
               //
               //  Handle doesn't allow KEY_QUERY_VALUE or READ_CONTROL access.
               //  Open a new handle with these accesses.
               //
               samDesired = MAXIMUM_ALLOWED;
               if( si & SACL_SECURITY_INFORMATION ) {
                  samDesired |= ACCESS_SYSTEM_SECURITY;
               } else if( si & DACL_SECURITY_INFORMATION ) {
                  samDesired |= WRITE_DAC;
               } else if( si & OWNER_SECURITY_INFORMATION ) {
                  samDesired |= WRITE_OWNER;
               }
            
               Error = RegOpenKeyEx( hkeyOld,
                                    NULL,
                                    REG_OPTION_RESERVED,
                                    samDesired,
                                    &hKeyNew
                                    );

               if( Error != ERROR_SUCCESS )
               {
                  if( m_hkeyPredefinedKey != hkeyOld )
                     RegCloseKey( hkeyOld );
                  return HRESULT_FROM_WIN32(Error);                  
               }
               else
               {
                  if( m_hkeyPredefinedKey != hkeyOld )
                     RegCloseKey( hkeyOld );
               }    
               SubKeyNameLength = MAX_PATH;
               Error = RegEnumKey( hKeyNew,
                                   0,
                                   SubKeyName,
                                   SubKeyNameLength );
               
               if( Error != ERROR_SUCCESS ){
                  RegCloseKey( hKeyNew );                  
                  return HRESULT_FROM_WIN32(Error);
               }         
            }   
            else
            {
               if( m_hkeyPredefinedKey != hKeyNew )
                  RegCloseKey( hKeyNew );
               return HRESULT_FROM_WIN32(Error);
            }
               
         }

      }
   }
    //
    // Recursively apply new Owner and/or reset the ACLs
    //
    if (siLocal)
    {
        BOOL bNotAllApplied = FALSE;
      hr = SetSubKeysSecurity( hKeyNew, siLocal, &sdLocal, &bNotAllApplied, true );
        RegFlushKey( hKeyNew );
        
      if( m_hkeyPredefinedKey != hKeyNew )
                RegCloseKey( hKeyNew );        

       if( bNotAllApplied )
        {
           if( siLocal & OWNER_SECURITY_INFORMATION )
           { 
               DisplayMessage( GetInFocusHWnd(),
                            GetModuleHandle(NULL),
                            IDS_SET_OWNER_RECURSIVE_EX_FAIL,
                            IDS_SECURITY );
           }
           else if( ( siLocal & DACL_SECURITY_INFORMATION ) || ( siLocal & SACL_SECURITY_INFORMATION ) )
           { 
               DisplayMessage( GetInFocusHWnd(),
                            GetModuleHandle(NULL),
                            IDS_SET_SECURITY_RECURSIVE_EX_FAIL,
                            IDS_SECURITY);
           }

        }

      if( hr != S_OK )
         return hr;
    }

   si &= ~(SI_OWNER_RECURSE | SI_RESET_DACL_TREE | SI_RESET_SACL_TREE);

    //This sets the security for the top keys
    if (si != 0)
    {
        hr = WriteObjectSecurity( GetCompleteName(),
                                          si,
                                          pSD );

      if( hr != S_OK )
      {
         if( siLocal )
            RegCloseKey( hkeyOld );
         return hr;
      }
    }


    return hr;
}

STDMETHODIMP 
CKeySecurityInformation::WriteObjectSecurity(LPCTSTR pszObject,
                                             IN SECURITY_INFORMATION si,
                                             IN PSECURITY_DESCRIPTOR pSD )
{
        DWORD dwErr;
        SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
        DWORD dwRevision;
        PSID psidOwner = NULL;
        PSID psidGroup = NULL;
        PACL pDacl = NULL;
        PACL pSacl = NULL;
        BOOL bDefaulted;
        BOOL bPresent;

        //
        // Get pointers to various security descriptor parts for
        // calling SetNamedSecurityInfo
        //

        if( !GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }

        if ((si & DACL_SECURITY_INFORMATION) && (wSDControl & SE_DACL_PROTECTED))
                si |= PROTECTED_DACL_SECURITY_INFORMATION;
      else
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;
        
      if ((si & SACL_SECURITY_INFORMATION) && (wSDControl & SE_SACL_PROTECTED))
                si |= PROTECTED_SACL_SECURITY_INFORMATION;
      else
            si |= UNPROTECTED_SACL_SECURITY_INFORMATION;
      
        //if the selected key is predefined key, it has no parent and hence
        //cannot inherit any permisson from parent.
        //if PROTECTED_DACL_SECURITY_INFORMATION flag is not set in this case
        // SetSecurityInfo succeeds, but permissions are not set.[bug in SetSecurityInfo].
        if ( (si & DACL_SECURITY_INFORMATION) && !m_strKeyName )
                si |= PROTECTED_DACL_SECURITY_INFORMATION;
      else
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;

        if ( (si & SACL_SECURITY_INFORMATION) && !m_strKeyName )
                si |= PROTECTED_SACL_SECURITY_INFORMATION;
      else
            si |= UNPROTECTED_SACL_SECURITY_INFORMATION;


        //We are on the root object
        if( m_strKeyName == NULL )
        {
            dwErr = SetSecurityInfo( m_hkeyPredefinedKey,
                                             SE_REGISTRY_KEY,
                                             si,
                                             psidOwner,
                                             psidGroup,
                                             pDacl,
                                             pSacl);
        }
        else
        {
            dwErr = SetNamedSecurityInfo((LPWSTR)pszObject,
                                                    SE_REGISTRY_KEY,
                                                    si,
                                                    psidOwner,
                                                    psidGroup,
                                                    pDacl,
                                                    pSacl);
        }
        
        return (dwErr ? HRESULT_FROM_WIN32(dwErr) : S_OK);
}

STDMETHODIMP 
CKeySecurityInformation::WriteObjectSecurity(HKEY hkey,
                                             IN SECURITY_INFORMATION si,
                                             IN PSECURITY_DESCRIPTOR pSD )
{
        DWORD dwErr;
        SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
        DWORD dwRevision;
        PSID psidOwner = NULL;
        PSID psidGroup = NULL;
        PACL pDacl = NULL;
        PACL pSacl = NULL;
        BOOL bDefaulted;
        BOOL bPresent;

        //
        // Get pointers to various security descriptor parts for
        // calling SetNamedSecurityInfo
        //
        ;
        if( !GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
        if( !GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted) )
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }

        if ((si & DACL_SECURITY_INFORMATION) && (wSDControl & SE_DACL_PROTECTED))
            si |= PROTECTED_DACL_SECURITY_INFORMATION;
        else
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;

        if ((si & SACL_SECURITY_INFORMATION) && (wSDControl & SE_SACL_PROTECTED))
            si |= PROTECTED_SACL_SECURITY_INFORMATION;
        else
            si |= UNPROTECTED_SACL_SECURITY_INFORMATION;

        dwErr = SetSecurityInfo(    hkey,
                                             SE_REGISTRY_KEY,
                                             si,
                                             psidOwner,
                                             psidGroup,
                                             pDacl,
                                             pSacl);
        
        return (dwErr ? HRESULT_FROM_WIN32(dwErr) : S_OK);
}


HRESULT 
CKeySecurityInformation::SetSubKeysSecurity( HKEY hkey,
                                             SECURITY_INFORMATION si,
                                             PSECURITY_DESCRIPTOR pSD,
                                             LPBOOL pbNotAllApplied,
                                             bool bFirstCall )
{
        ULONG             Error;
        REGSAM            samDesired;
        HRESULT hr;
        HRESULT hrRet;
      HKEY hKeyNew;

        //For First Call we call SetSecurityInfoEx in last
        if( !bFirstCall )
        {
            SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
            DWORD dwRevision;
            PSID psidOwner = NULL;
            PSID psidGroup = NULL;
            PACL pDacl = NULL;
            PACL pSacl = NULL;
            BOOL bDefaulted;
            BOOL bPresent;
            DWORD dwErr;
            //
            // Get pointers to various security descriptor parts for
            // calling SetNamedSecurityInfo
            //
            if( !GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision) )
            {
                *pbNotAllApplied = TRUE;
                goto SET_FOR_CHILD;
            }
            if( !GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted) )
            {
                *pbNotAllApplied = TRUE;
                goto SET_FOR_CHILD;
            }
            if( !GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted) )
            {
                *pbNotAllApplied = TRUE;
                goto SET_FOR_CHILD;
            }
            if( !GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted) )
            {
                *pbNotAllApplied = TRUE;
                goto SET_FOR_CHILD;
            }
            if( !GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted) )
            {
                *pbNotAllApplied = TRUE;
                goto SET_FOR_CHILD;
            }


            if ((si & DACL_SECURITY_INFORMATION) && (wSDControl & SE_DACL_PROTECTED))
                si |= PROTECTED_DACL_SECURITY_INFORMATION;
            else
                si |= UNPROTECTED_DACL_SECURITY_INFORMATION;

            if ((si & SACL_SECURITY_INFORMATION) && (wSDControl & SE_SACL_PROTECTED))
                si |= PROTECTED_SACL_SECURITY_INFORMATION;
            else
                si |= UNPROTECTED_SACL_SECURITY_INFORMATION;

            dwErr = SetSecurityInfo( hkey,
                                  SE_REGISTRY_KEY,
                                  si,
                                  psidOwner,
                                  psidGroup,
                                  pDacl,
                                  pSacl);

            if( dwErr != ERROR_SUCCESS )
            {
                *pbNotAllApplied = TRUE;
                goto SET_FOR_CHILD;
            }
        }

SET_FOR_CHILD:

        DWORD             NumberOfSubKeys = 0;
        DWORD             MaxSubKeyLength = 0;
        //    Find out the total number of subkeys
        Error = RegQueryInfoKey(
                                hkey,
                                NULL,
                                NULL,
                                NULL,
                                &NumberOfSubKeys,
                                &MaxSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );

        if( Error != ERROR_SUCCESS ){
         if( Error == ERROR_ACCESS_DENIED ) {
            //
            //  Handle doesn't allow KEY_QUERY_VALUE or READ_CONTROL access.
            //  Open a new handle with these accesses.
            //
            samDesired = KEY_QUERY_VALUE | READ_CONTROL; // MAXIMUM_ALLOWED | READ_CONTROL;
            if( si & SACL_SECURITY_INFORMATION ) {
               samDesired |= ACCESS_SYSTEM_SECURITY;
            } else if( si & DACL_SECURITY_INFORMATION ) {
               samDesired |= WRITE_DAC;
            } else if( si & OWNER_SECURITY_INFORMATION ) {
               samDesired |= WRITE_OWNER;
            }
            
            Error = RegOpenKeyEx( hkey,
                                 NULL,
                                 REG_OPTION_RESERVED,
                                 samDesired,
                                 &hKeyNew
                                 );

            if( Error != ERROR_SUCCESS ) {
               *pbNotAllApplied = TRUE;
                  return S_OK;
            }
              Error = RegQueryInfoKey(
                                            hKeyNew,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &NumberOfSubKeys,
                                            &MaxSubKeyLength,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL );
            
            if( Error != ERROR_SUCCESS ) {
               RegCloseKey( hKeyNew );
                  *pbNotAllApplied = TRUE;
                  return S_OK;
            }
            else
               RegCloseKey( hKeyNew );
         }
         else{
            *pbNotAllApplied = TRUE;
               return S_OK;
         }

        }
      
      if( NumberOfSubKeys == 0 ) {
         return S_OK;
      }

        assert( MaxSubKeyLength <= MAX_PATH );
        
        DWORD SubKeyNameLength = 0;
        WCHAR SubKeyName[MAX_PATH + 1];

      //
      //  The key has subkeys.
      //  Find out if we are able to enumerate the key using the handle
      //  passed as argument.
      //
      SubKeyNameLength = MAX_PATH;
      Error = RegEnumKey( hkey,
                          0,
                          SubKeyName,
                          SubKeyNameLength );

      if( Error != ERROR_SUCCESS ){
         
         if( Error == ERROR_ACCESS_DENIED ) {
            //
            //  Handle doesn't allow 'enumerate' access.
            //  Open a new handle with KEY_ENUMERATE_SUB_KEYS access.
            //

            Error = RegOpenKeyEx( hkey,
                                  NULL,
                                  REG_OPTION_RESERVED,
                                  KEY_ENUMERATE_SUB_KEYS, // samDesired,
                                  &hKeyNew
                               );
            if( Error != ERROR_SUCCESS ){
               *pbNotAllApplied = TRUE;
               return S_OK;
            }
         }
         else{
            *pbNotAllApplied = TRUE;
            return S_OK;
         }
      }
      else {
         hKeyNew = hkey;
      }


        for( DWORD Index = 0; Index < NumberOfSubKeys; Index++ ) 
      {

                //    If the key has subkeys, then for each subkey, do:
                //    - Determine the subkey name
                SubKeyNameLength = MAX_PATH;

                Error = RegEnumKey( hKeyNew,
                                Index,
                                SubKeyName,
                                SubKeyNameLength );


                if( Error != ERROR_SUCCESS ) {
                    *pbNotAllApplied = TRUE;
                    continue;
                    //return HRESULT_FROM_WIN32( Error );
                }

                //    - Open a handle to the subkey

                samDesired = MAXIMUM_ALLOWED;
                
                if( si & SACL_SECURITY_INFORMATION ) 
                        samDesired |= ACCESS_SYSTEM_SECURITY;
                if( si & DACL_SECURITY_INFORMATION ) 
                        samDesired |= WRITE_DAC;
                if( si & OWNER_SECURITY_INFORMATION )
                        samDesired |= WRITE_OWNER;

                HKEY hkeyChild;
                Error = RegOpenKeyEx( hKeyNew,
                                  SubKeyName,
                                  REG_OPTION_RESERVED,
                                  samDesired,
                                             &hkeyChild
                                                        );
                if( ERROR_SUCCESS != Error ){
                        *pbNotAllApplied = TRUE;
                        continue;
//                    return HRESULT_FROM_WIN32( Error );
                }


                //    - Set the security of the child's subkeys
                if( S_OK != ( hr = SetSubKeysSecurity( hkeyChild,
                                                                             si,
                                                                             pSD,
                                                                             pbNotAllApplied,
                                                                             false ) )    ){
                    //This case will occur only if some fatal error occur which
                    //prevents propogation on rest of the tree.
               if( hKeyNew != hkey )
                  RegCloseKey( hKeyNew );
                    RegCloseKey( hkeyChild );
                    return hr;
                }
                else{
                    RegCloseKey( hkeyChild );
                }
        
        } //For loop
      if( hKeyNew != hkey )
         RegCloseKey( hKeyNew );
        return S_OK;;
}





HRESULT
CKeySecurityInformation::OpenKey(IN  DWORD Permission,
                                                                 OUT PHKEY pKey )
{


        LPCWSTR             CompleteNameString = NULL;;
        ULONG             Error;

        if( m_strKeyName == NULL){
            //This is a predefined key
            *pKey = m_hkeyPredefinedKey;
        }
        else{
            CompleteNameString = GetCompleteName1();
            assert( CompleteNameString != NULL );
            //    Open handle to the key
            Error = RegOpenKeyEx(m_hkeyPredefinedKey,
                                                        CompleteNameString,
                                                        0,
                                                        Permission,
                                                        pKey );

            if( Error != ERROR_SUCCESS ) {
                return HRESULT_FROM_WIN32( Error );
            }
        }
        if( CompleteNameString )
            LocalFree( (HLOCAL) CompleteNameString);
        return S_OK;
}

OBJECT_TYPE_LIST g_DefaultOTL[] = {
                                    {0, 0, (LPGUID)&GUID_NULL},
                                    };
BOOL SkipLocalGroup(LPCWSTR pszServerName, PSID psid)
{

	SID_NAME_USE use;
	WCHAR szAccountName[MAX_PATH];
	WCHAR szDomainName[MAX_PATH];
	DWORD dwAccountLen = MAX_PATH;
	DWORD dwDomainLen = MAX_PATH;

	if(LookupAccountSid(pszServerName,
						 psid,
						 szAccountName,
						 &dwAccountLen,
						 szDomainName,
						 &dwDomainLen,
						 &use))
	{
		if(use == SidTypeWellKnownGroup)
			return TRUE;
	}
	//Built In sids have first subauthority of 32 ( s-1-5-32 )
	//
	if((*(GetSidSubAuthorityCount(psid)) >= 1 ) && (*(GetSidSubAuthority(psid,0)) == 32))
		return TRUE;

	return FALSE;
}


STDMETHODIMP 
CKeySecurityInformation::GetEffectivePermission(const GUID* pguidObjectType,
                                        PSID pUserSid,
                                        LPCWSTR pszServerName,
                                        PSECURITY_DESCRIPTOR pSD,
                                        POBJECT_TYPE_LIST *ppObjectTypeList,
                                        ULONG *pcObjectTypeListLength,
                                        PACCESS_MASK *ppGrantedAccessList,
                                        ULONG *pcGrantedAccessListLength)
{

    AUTHZ_RESOURCE_MANAGER_HANDLE RM = NULL;    //Used for access check
    AUTHZ_CLIENT_CONTEXT_HANDLE CC = NULL;
    LUID luid = {0xdead,0xbeef};
    AUTHZ_ACCESS_REQUEST AReq;
    AUTHZ_ACCESS_REPLY AReply;
    HRESULT hr = S_OK;    
    DWORD dwFlags;


    AReq.ObjectTypeList = g_DefaultOTL;
    AReq.ObjectTypeListLength = ARRAYSIZE(g_DefaultOTL);
    AReply.GrantedAccessMask = NULL;
    AReply.Error = NULL;

    //Get RM
    if( (RM = GetAUTHZ_RM()) == NULL )
        return S_FALSE;

    //Initialize the client context

    	BOOL bSkipLocalGroup = SkipLocalGroup(pszServerName, pUserSid);

    
    if( !AuthzInitializeContextFromSid(bSkipLocalGroup? AUTHZ_SKIP_TOKEN_GROUPS :0,
                                       pUserSid,
                                       RM,
                                       NULL,
                                       luid,
                                       NULL,
                                       &CC) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }



    //Do the Access Check

    AReq.DesiredAccess = MAXIMUM_ALLOWED;
    AReq.PrincipalSelfSid = NULL;
    AReq.OptionalArguments = NULL;

    AReply.ResultListLength = AReq.ObjectTypeListLength;
    AReply.SaclEvaluationResults = NULL;
    if( (AReply.GrantedAccessMask = (PACCESS_MASK)LocalAlloc(LPTR, sizeof(ACCESS_MASK)*AReply.ResultListLength) ) == NULL )
        return E_OUTOFMEMORY;

    if( (AReply.Error = (PDWORD)LocalAlloc(LPTR, sizeof(DWORD)*AReply.ResultListLength)) == NULL )
    {
        LocalFree(AReply.GrantedAccessMask);
        return E_OUTOFMEMORY;
    }
        

    if( !AuthzAccessCheck(0,
                          CC,
                          &AReq,
                          NULL,
                          pSD,
                          NULL,
                          0,
                          &AReply,
                          NULL) )
    {
        LocalFree(AReply.GrantedAccessMask);
        LocalFree(AReply.Error);
        return HRESULT_FROM_WIN32(GetLastError());
    }



    if(CC)
        AuthzFreeContext(CC);
    
        *ppObjectTypeList = AReq.ObjectTypeList;                                  
        *pcObjectTypeListLength = AReq.ObjectTypeListLength;
        *ppGrantedAccessList = AReply.GrantedAccessMask;
        *pcGrantedAccessListLength = AReq.ObjectTypeListLength;

    return S_OK;
}

STDMETHODIMP
CKeySecurityInformation::GetInheritSource(SECURITY_INFORMATION si,
                                          PACL pACL, 
                                          PINHERITED_FROM *ppInheritArray)
{

    HRESULT hr = S_OK;

    if (NULL == m_strKeyName || !pACL || !ppInheritArray)
        return E_UNEXPECTED;

    
    DWORD dwErr = ERROR_SUCCESS;
    PINHERITED_FROM pTempInherit = NULL;
    PINHERITED_FROM pTempInherit2 = NULL;
    LPWSTR pStrTemp = NULL;

    LPCWSTR pszName = GetCompleteName();
    
    pTempInherit = (PINHERITED_FROM)LocalAlloc( LPTR, sizeof(INHERITED_FROM)*pACL->AceCount);
    if(pTempInherit == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }

    dwErr = GetInheritanceSource((LPWSTR)pszName,
                                        SE_REGISTRY_KEY,
                                        si,
                                        TRUE,
                                        NULL,
                                        0,
                                        pACL,
                                        NULL,
                                        &KeyMap,
                                        pTempInherit);
    
    hr = HRESULT_FROM_WIN32(dwErr);
    if( FAILED(hr) )
        goto exit_gracefully;

    DWORD nSize;
    UINT i;

    nSize = sizeof(INHERITED_FROM)*pACL->AceCount;
    for(i = 0; i < pACL->AceCount; ++i)
    {
        if(pTempInherit[i].AncestorName)
            nSize += ((wcslen(pTempInherit[i].AncestorName)+1)*sizeof(WCHAR));
    }

    pTempInherit2 = (PINHERITED_FROM)LocalAlloc( LPTR, nSize );
    if(pTempInherit2 == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    
    pStrTemp = (LPWSTR)(pTempInherit2 + pACL->AceCount); 

    for(i = 0; i < pACL->AceCount; ++i)
    {
        pTempInherit2[i].GenerationGap = pTempInherit[i].GenerationGap;
        if(pTempInherit[i].AncestorName)
        {
            pTempInherit2[i].AncestorName = pStrTemp;
            wcscpy(pStrTemp, pTempInherit[i].AncestorName);
            pStrTemp += (wcslen(pTempInherit[i].AncestorName)+1);
        }
    }
            

exit_gracefully:

    if(SUCCEEDED(hr))
    {
        //FreeInheritedFromArray(pTempInherit, pACL->AceCount,NULL);
        *ppInheritArray = pTempInherit2;
            
    }                        
    if(pTempInherit)
        LocalFree(pTempInherit);

    return hr;
}

///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CSecurityInformation::AddRef()
{
        return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CSecurityInformation::Release()
{
        if (--m_cRef == 0)
        {
                delete this;
                return 0;
        }

        return m_cRef;
}

STDMETHODIMP
CSecurityInformation::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
//        if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
        if ( IsEqualIID(riid, IID_ISecurityInformation) )

        {
                *ppv = (LPSECURITYINFO)this;
                m_cRef++;
                return S_OK;
        }
        else if(IsEqualIID(riid, IID_IEffectivePermission) )
        {
                *ppv = (LPEFFECTIVEPERMISSION)this;
                m_cRef++;
                return S_OK;

        }
        else if(IsEqualIID(riid, IID_ISecurityObjectTypeInfo) )
        {
                *ppv = (LPSecurityObjectTypeInfo)this;
                m_cRef++;
                return S_OK;

        }
        else
        {
                *ppv = NULL;
                return E_NOINTERFACE;
        }
}

HRESULT CreateSecurityInformation( IN LPCWSTR strKeyName,
                                                                     IN LPCWSTR strParentName,
                                                                     IN LPCWSTR strMachineName,
                                                                     IN LPCWSTR strPageTitle,
                                                                     IN BOOL        bRemote,
                                                                     IN PREDEFINE_KEY PredefinedKey,
                                                                     IN BOOL bReadOnly,
                                   IN HWND hWnd,
                                                                     OUT LPSECURITYINFO *ppSi)
{
    HRESULT hr;

    if( !ppSi )
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    
    CKeySecurityInformation *ckey = new CKeySecurityInformation;
    if( NULL == ckey )
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

    if( S_OK != ( hr = ckey->Initialize(    strKeyName,
                                          strParentName,
                                          strMachineName,
                                          strPageTitle,
                                          bRemote,
                                          PredefinedKey,
                                          bReadOnly,
                                          hWnd ) ) )
    {
        delete ckey;
        return hr;
    }
    else
    {
        *ppSi = ckey;
        return S_OK;
    }
}


//Some helper functions
BOOL DisplayMessage( HWND hWnd,
                                         HINSTANCE hInstance,
                                         DWORD dwMessageId,
                                         DWORD dwCaptionId )
{
  WCHAR pszMessage[1025];
  WCHAR pszTitle[1025];
  LPWSTR lpTitle = NULL;
  
  if( !LoadString(hInstance, dwMessageId, pszMessage, 1024 ) )
      return FALSE;

  if( dwCaptionId )
  {
      if( LoadString(hInstance, dwCaptionId, pszTitle, 1024 ) )
         lpTitle = pszTitle;
  }
    

  // Display the string.
    MessageBox( hWnd, (LPCTSTR)pszMessage, (LPCTSTR)lpTitle, MB_OK | MB_ICONINFORMATION |MB_APPLMODAL );
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regstred.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGSTRED.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  String edit dialog for use by the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGSTRED
#define _INC_REGSTRED

INT_PTR
CALLBACK
EditStringValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

#endif // _INC_REGSTRED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regsys.cxx ===
#include "regdata.hxx"
#include "regsys.hxx"

#include <stdio.h>

extern "C" HINSTANCE g_hInstance;

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)        (sizeof(x) / sizeof(x[0]))
#endif

BOOLEAN
REGEDIT_BASE_SYSTEM::QueryResourceString(
    OUT PWSTRING    ResourceString,
    IN  MSGID       MsgId,
    IN  PCSTR       Format ...
    )
/*++

Routine Description:

    This routine computes the resource string identified by the resource
    identifier 'MsgId'.  In addition to the 'printf' format strings
    supported, 'QueryResourceString' supports :

        1. '%W' - Expects a pointer to a WSTRING.

Arguments:

    ResourceString  - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    ...             - Supplies the arguments to the resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    va_start(ap, Format);
    r = QueryResourceStringV(ResourceString, MsgId, Format, ap);
    va_end(ap);

    return r;
}


BOOLEAN
REGEDIT_BASE_SYSTEM::QueryResourceStringV(
    OUT PWSTRING    ResourceString,
    IN  MSGID       MsgId,
    IN  PCSTR       Format,
    IN  va_list     VarPointer
    )
/*++

Routine Description:

    This is a 'varargs' implementation of 'QueryResourceString'.

Arguments:

    ResourceString  - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    VarPointer      - Supplies a varargs pointer to the arguments of the
                        resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    WCHAR           display_buffer[2048];
    WCHAR           UnformattedMessage[1024];
    DWORD           Status;

    if( LoadStringW(g_hInstance,
                    MsgId,
                    UnformattedMessage,
                    1024 ) == 0 ) {
        Status = GetLastError();
        DebugPrint( "LoadStringW() failed" );
        DebugPrintTrace(("LoadStringW() failed. Error = %d \n", Status ));
        return FALSE;
    }

    if( FormatMessageW(FORMAT_MESSAGE_FROM_STRING,
                       (LPVOID)UnformattedMessage,
                       0,
                       0L,
                       display_buffer,
                       ARRAYSIZE(display_buffer),
                       &VarPointer ) == 0 ) 
    {
         Status = GetLastError();
         DebugPrint( "FormatMessageW() failed" );
         DebugPrintTrace(("FormatMessageW() failed. Error = %d \n", Status ));
         return FALSE;
    }

    return ResourceString->Initialize(display_buffer);
}



PWSTRING
REGEDIT_BASE_SYSTEM::QueryString(
    IN  MSGID       MsgId,
    IN  PCSTR       Format ...
    )
/*++

Routine Description:

    This routine computes the resource string identified by the resource
    identifier 'MsgId'.  In addition to the 'printf' format strings
    supported, 'QueryResourceString' supports :

        1. '%W' - Expects a pointer to a WSTRING.

Arguments:

    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    ...             - Supplies the arguments to the resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;
    PWSTRING    String;

    va_start(ap, Format);
    String = NEW( DSTRING );
    if (String)
    {
        r = QueryResourceStringV(String, MsgId, Format, ap);
        va_end(ap);
        if( !r )
        {
            DELETE( String );
            String = NULL;
        }
    }
    return String;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regstred.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGSTRED.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  String edit dialog for use by the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#include "pch.h"
#include "regresid.h"
#include "reghelp.h"
#include "regedit.h"

const DWORD s_EditStringValueHelpIDs[] = {
    IDC_VALUEDATA, IDH_REGEDIT_VALUEDATA,
    IDC_VALUENAME, IDH_REGEDIT_VALUENAME,
    0, 0
};

BOOL
PASCAL
EditStringValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    );

/*******************************************************************************
*
*  EditStringValueDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR
CALLBACK
EditStringValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    
    LPEDITVALUEPARAM lpEditValueParam;
    
    
    switch (Message) 
    {
        HANDLE_MSG(hWnd, WM_INITDIALOG, EditStringValue_OnInitDialog);
        
    case WM_COMMAND:
        {
            DWORD dwCommand = GET_WM_COMMAND_ID(wParam, lParam);
            switch (dwCommand) 
            {
            case IDOK:
                {
                    UINT ccValueData;
                    UINT cbValueData;
                    PBYTE pbValueData = NULL;
                    
                    lpEditValueParam = (LPEDITVALUEPARAM) GetWindowLongPtr(hWnd, DWLP_USER);
                    
                    // this maybe a multi-string, if so the sizeof(TCHAR) is added to 
                    // allow for the multi-string to be terminated also.
                    ccValueData = (UINT) SendDlgItemMessage(hWnd, IDC_VALUEDATA, WM_GETTEXTLENGTH, 0, 0) + 2;
                    
                    cbValueData = ccValueData * sizeof(TCHAR);
                    
                    if (cbValueData > lpEditValueParam->cbValueData)
                    {
                        // need a bigger buffer
                        PBYTE pbValueData = 
                            LocalReAlloc(lpEditValueParam->pValueData, cbValueData, LMEM_MOVEABLE);

                        if (!pbValueData)
                        { 
                            InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(IDS_EDITVALNOMEMORY),
                                MAKEINTRESOURCE(IDS_EDITVALERRORTITLE), MB_ICONERROR | MB_OK, NULL);
                            dwCommand = IDCANCEL;
                        }
                        else
                        {
                            lpEditValueParam->pValueData = pbValueData;
                        }
                    }
                    
                    // sizeof(TCHAR) to remove multi-string null char from count
                    lpEditValueParam->cbValueData = cbValueData - sizeof(TCHAR);
                    
                    GetDlgItemText(hWnd, IDC_VALUEDATA, (PTSTR)lpEditValueParam->pValueData, 
                                      lpEditValueParam->cbValueData/sizeof(TCHAR));
                }
                //  FALL THROUGH
                
            case IDCANCEL:
                EndDialog(hWnd, dwCommand);
                break;
                
            }
        }
        break;
        
    case WM_HELP:
        WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
            HELP_WM_HELP, (ULONG_PTR) s_EditStringValueHelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
            (ULONG_PTR) s_EditStringValueHelpIDs);
        break;
        
    default:
        return FALSE;
        
    }
    
    return TRUE;
    
}

/*******************************************************************************
*
*  EditStringValue_OnInitDialog
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of EditStringValue window.
*     hFocusWnd,
*     lParam,
*
*******************************************************************************/

BOOL
PASCAL
EditStringValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    )
{
    LPEDITVALUEPARAM lpEditValueParam;

    //  Change maximum number of characters of the edit control, to its
    //  maximum limit (from 3000 characters to 4G characters).
    SendDlgItemMessage( hWnd, IDC_VALUEDATA, EM_LIMITTEXT, 0, 0L );

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);
    lpEditValueParam = (LPEDITVALUEPARAM) lParam;

    if (lpEditValueParam->pValueName && lpEditValueParam->pValueName[0])
    {
        SetDlgItemText(hWnd, IDC_VALUENAME, lpEditValueParam->pValueName);
    }
    else
    {
        SetDlgItemText(hWnd, IDC_VALUENAME, g_RegEditData.pDefaultValue);
    }
    SetDlgItemText(hWnd, IDC_VALUEDATA, (PTSTR)lpEditValueParam-> pValueData);

    return TRUE;

    UNREFERENCED_PARAMETER(hFocusWnd);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by REGEDIT.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         108
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regsec.h ===
#ifndef __REGSEC_H_INCLUDED__
#define __REGSEC_H_INCLUDED__
extern "C"
{
#include "authz.h"
}
#include "objbase.h"
#include "aclapi.h"
#include "aclui.h"

//Type def for PREDEFINED KEYS
typedef enum _PREDEFINE_KEY {
  PREDEFINE_KEY_CLASSES_ROOT,
  PREDEFINE_KEY_CURRENT_USER,
  PREDEFINE_KEY_LOCAL_MACHINE,
  PREDEFINE_KEY_USERS,
  PREDEFINE_KEY_CURRENT_CONFIG
} PREDEFINE_KEY;


class CSecurityInformation : public ISecurityInformation,IEffectivePermission,ISecurityObjectTypeInfo
{
private:
  long m_cRef;
    
public:
  CSecurityInformation():m_cRef(0){}
  virtual ~CSecurityInformation(){};
  // IUnknown methods
  STDMETHOD(QueryInterface)(REFIID, LPVOID *);
  STDMETHOD_(ULONG, AddRef)();
  STDMETHOD_(ULONG, Release)();

  // ISecurityInformation methods 
  STDMETHOD(GetObjectInformation)(
      IN PSI_OBJECT_INFO pObjectInfo
  ) = 0;
  STDMETHOD(GetSecurity)(
      IN  SECURITY_INFORMATION  RequestedInformation,
      OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor,
      IN  BOOL                  fDefault
  ) = 0;
  STDMETHOD(SetSecurity)(
      IN SECURITY_INFORMATION SecurityInformation,
      IN PSECURITY_DESCRIPTOR pSecurityDescriptor
  ) = 0;
  STDMETHOD(GetAccessRights)(
      const GUID  *pguidObjectType,
      DWORD       dwFlags,
      PSI_ACCESS  *ppAccess,
      ULONG       *pcAccesses,
      ULONG       *piDefaultAccess
  ) = 0;
  STDMETHOD(MapGeneric)(
      const GUID  *pguidObjectType,
      UCHAR       *pAceFlags,
      ACCESS_MASK *pMask
  ) = 0;
  STDMETHOD(GetInheritTypes)(
      PSI_INHERIT_TYPE  *ppInheritTypes,
      ULONG             *pcInheritTypes
  ) = 0;
  STDMETHOD(PropertySheetPageCallback)(
      HWND          hwnd, 
      UINT          uMsg, 
      SI_PAGE_TYPE  uPage
  ) = 0;
  STDMETHOD(GetEffectivePermission) (  const GUID* pguidObjectType,
                                         PSID pUserSid,
                                         LPCWSTR pszServerName,
                                         PSECURITY_DESCRIPTOR pSD,
                                         POBJECT_TYPE_LIST *ppObjectTypeList,
                                         ULONG *pcObjectTypeListLength,
                                         PACCESS_MASK *ppGrantedAccessList,
                                         ULONG *pcGrantedAccessListLength) =0;
  
  STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                              PACL pACL, 
                              PINHERITED_FROM *ppInheritArray) PURE;



};

class CKeySecurityInformation : public CSecurityInformation
{


private:
  
  //Name of the Key, NULL for ROOT key
  LPCWSTR m_strKeyName;
  //Name of the parent Key, NULL for root and immediate child of root.
  LPCWSTR m_strParentName;
  //Name of the server, can be NULL
  LPCWSTR m_strMachineName;
  //Title of the page
  LPCWSTR m_strPageTitle;
  //if connected to Remote System, Machine name must not be null in this case
  BOOL m_bRemote;
  PREDEFINE_KEY m_PredefinedKey;
  BOOL m_bReadOnly;
  
  //Handle to predefined key. If handle to remote registry, close in Destructor
  HKEY        m_hkeyPredefinedKey;
  LPWSTR m_strCompleteName ;  //Free in Destructor
  DWORD   m_dwFlags;
  //This HWND to application window
  HWND  m_hWnd;
  //This is HWND to currently infocus ACLUI property Sheet. Null if none
  HWND  m_hWndProperty;
  AUTHZ_RESOURCE_MANAGER_HANDLE m_ResourceManager;    //Used for access check
  AUTHZ_RESOURCE_MANAGER_HANDLE GetAUTHZ_RM(){ return m_ResourceManager; }
  HWND GetInFocusHWnd() { return m_hWndProperty? m_hWndProperty : m_hWnd; }

public:
  CKeySecurityInformation(): m_strKeyName(NULL),m_strParentName(NULL),
                             m_strMachineName(NULL), m_strPageTitle(NULL),
                             m_bRemote(false),m_PredefinedKey((PREDEFINE_KEY)0),
                             m_bReadOnly(false),m_strCompleteName(NULL),
                             m_hWnd(NULL), m_hWndProperty(NULL),
                             m_ResourceManager(NULL){}
  ~CKeySecurityInformation();

public:


  // *** ISecurityInformation methods ***
  STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
  STDMETHOD(GetSecurity)(
    IN  SECURITY_INFORMATION  RequestedInformation,
    OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor,
    IN  BOOL                  fDefault
  );
  STDMETHOD(SetSecurity)(
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
  );
  STDMETHOD(GetAccessRights)(
    const GUID  *pguidObjectType,
    DWORD       dwFlags,
    PSI_ACCESS  *ppAccess,
    ULONG       *pcAccesses,
    ULONG       *piDefaultAccess
  );
  STDMETHOD(MapGeneric)(
    const GUID  *pguidObjectType,
    UCHAR       *pAceFlags,
    ACCESS_MASK *pMask
  );
  STDMETHOD(GetInheritTypes)(
    PSI_INHERIT_TYPE  *ppInheritTypes,
    ULONG             *pcInheritTypes
  );
  STDMETHOD(PropertySheetPageCallback)(
    HWND          hwnd, 
    UINT          uMsg, 
    SI_PAGE_TYPE  uPage
  );
  STDMETHOD(GetEffectivePermission) (  const GUID* pguidObjectType,
                                         PSID pUserSid,
                                         LPCWSTR pszServerName,
                                         PSECURITY_DESCRIPTOR pSD,
                                         POBJECT_TYPE_LIST *ppObjectTypeList,
                                         ULONG *pcObjectTypeListLength,
                                         PACCESS_MASK *ppGrantedAccessList,
                                         ULONG *pcGrantedAccessListLength) ;

  STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                              PACL pACL, 
                              PINHERITED_FROM *ppInheritArray);


  HRESULT Initialize ( LPCWSTR strKeyName,
                       LPCWSTR strParentName,
                       LPCWSTR strMachineName,
                       LPCWSTR strPageTitle,
                       BOOL    bRemote,
                       PREDEFINE_KEY PredefinedKey,
                       BOOL bReadOnly,
                       HWND hWnd);

protected:
  HRESULT SetCompleteName();
  LPCWSTR GetCompleteName(){ return m_strCompleteName; }
  LPCWSTR GetCompleteName1();
  HRESULT SetHandleToPredefinedKey();


  STDMETHOD(WriteObjectSecurity)(
    LPCTSTR pszObject,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR pSD
  );

  STDMETHOD(WriteObjectSecurity)(
    HKEY hkey,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR pSD
  );

  HRESULT SetSubKeysSecurity(
    HKEY hkey,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR pSD,
    LPBOOL pbNotAllApplied,
    bool bFirstCall 
  );
  HRESULT OpenKey(
    DWORD Permission,
    PHKEY pKey 
  );

};


//
extern "C"
{

HRESULT CreateSecurityInformation( IN LPCWSTR strKeyName,
                                   IN LPCWSTR strParentName,
                                   IN LPCWSTR strMachineName,
                                   IN LPCWSTR strPageTitle,
                                   IN BOOL    bRemote,
                                   IN PREDEFINE_KEY PredefinedKey,
                                   IN BOOL bReadOnly,
                                   IN HWND hWnd,
                                   OUT LPSECURITYINFO *pSi);
}

BOOL DisplayMessage( HWND hWnd,
										 HINSTANCE hInstance,
										 DWORD dwMessageId,
										 DWORD dwCaptionId );


#endif // ~__PERMPAGE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regvalue.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGVALUE.C
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  ValueListWnd ListView routines for the Registry Editor.
*
*******************************************************************************/

#include "pch.h"
#include "regedit.h"
#include "regvalue.h"
#include "regstred.h"
#include "regbined.h"
#include "regdwded.h"
#include "regresid.h"


extern void DisplayResourceData(HWND hWnd, DWORD dwType, LPEDITVALUEPARAM lpEditValueParam);
extern void DisplayBinaryData(HWND hWnd, LPEDITVALUEPARAM lpEditValueParam, DWORD dwValueType);

#define MAX_VALUENAME_TEMPLATE_ID       100

//  Maximum number of bytes that will be shown in the ListView.  If the user
//  wants to see more, then they can use the edit dialogs.
#define SIZE_DATATEXT                   196

//  Allow room in a SIZE_DATATEXT buffer for one null and possibly
//  the ellipsis.
#define MAXIMUM_STRINGDATATEXT          192
const TCHAR s_StringDataFormatSpec[] = TEXT("%.192s");

//  Allow room for multiple three character pairs, one null, and possibly the
//  ellipsis.
#define MAXIMUM_BINARYDATABYTES         64
const TCHAR s_BinaryDataFormatSpec[] = TEXT("%02x ");

const TCHAR s_Ellipsis[] = TEXT("...");

const LPCTSTR s_TypeNames[] = { TEXT("REG_NONE"),
                                TEXT("REG_SZ"),
                                TEXT("REG_EXPAND_SZ"),
                                TEXT("REG_BINARY"),
                                TEXT("REG_DWORD"),
                                TEXT("REG_DWORD_BIG_ENDIAN"),
                                TEXT("REG_LINK"),
                                TEXT("REG_MULTI_SZ"),
                                TEXT("REG_RESOURCE_LIST"),
                                TEXT("REG_FULL_RESOURCE_DESCRIPTOR"),
                                TEXT("REG_RESOURCE_REQUIREMENTS_LIST"),
                                TEXT("REG_QWORD")
                              };

#define MAX_KNOWN_TYPE REG_QWORD

VOID
PASCAL
RegEdit_OnValueListDelete(
    HWND hWnd
    );

VOID
PASCAL
RegEdit_OnValueListRename(
    HWND hWnd
    );

VOID
PASCAL
ValueList_EditLabel(
    HWND hValueListWnd,
    int ListIndex
    );

/*******************************************************************************
*
*  RegEdit_OnNewValue
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnNewValue(
    HWND hWnd,
    DWORD Type
    )
{

    UINT NewValueNameID;
    TCHAR ValueName[MAXVALUENAME_LENGTH];
    DWORD Ignore;
    DWORD cbValueData;
    LV_ITEM LVItem;
    int ListIndex;
    UINT ErrorStringID;
    BYTE abValueDataBuffer[4]; // DWORD is largest init. value

    if (g_RegEditData.hCurrentSelectionKey == NULL)
        return;

    //
    //  Loop through the registry trying to find a valid temporary name until
    //  the user renames the key.
    //

    NewValueNameID = 1;

    while (NewValueNameID < MAX_VALUENAME_TEMPLATE_ID) 
    {
        StringCchPrintf(ValueName, ARRAYSIZE(ValueName), g_RegEditData.pNewValueTemplate, NewValueNameID);

        if (RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName,
            NULL, &Ignore, NULL, &Ignore) != ERROR_SUCCESS) {

            //
            //  For strings, we need to have at least one byte to represent the
            //  null.  For binary data, it's okay to have zero-length data.
            //

            switch (Type) {

                case REG_SZ:
                case REG_EXPAND_SZ:
                    ((PTSTR) abValueDataBuffer)[0] = 0;
                    cbValueData = sizeof(TCHAR);
                    break;

                case REG_DWORD:
                    ((LPDWORD) abValueDataBuffer)[0] = 0;
                    cbValueData = sizeof(DWORD);
                    break;

                case REG_BINARY:
                    cbValueData = 0;
                    break;

                case REG_MULTI_SZ:
                    ((PTSTR) abValueDataBuffer)[0] = 0;
                    cbValueData = sizeof(TCHAR);
                    break;
            }

            if (RegSetValueEx(g_RegEditData.hCurrentSelectionKey, ValueName, 0,
                Type, abValueDataBuffer, cbValueData) == ERROR_SUCCESS)
                break;

            else {

                ErrorStringID = IDS_NEWVALUECANNOTCREATE;
                goto error_ShowDialog;

            }

        }

        NewValueNameID++;

    }

    if (NewValueNameID == MAX_VALUENAME_TEMPLATE_ID) {

        ErrorStringID = IDS_NEWVALUENOUNIQUE;
        goto error_ShowDialog;

    }

    LVItem.mask = LVIF_TEXT | LVIF_IMAGE;
    LVItem.pszText = ValueName;
    LVItem.iItem = ListView_GetItemCount(g_RegEditData.hValueListWnd);
    LVItem.iSubItem = 0;
    LVItem.iImage = IsRegStringType(Type) ? IMAGEINDEX(IDI_STRING) :
        IMAGEINDEX(IDI_BINARY);

    if ((ListIndex = ListView_InsertItem(g_RegEditData.hValueListWnd,
        &LVItem)) != -1) {

        ValueList_SetItemDataText(g_RegEditData.hValueListWnd, ListIndex,
            abValueDataBuffer, cbValueData, Type);

        ValueList_EditLabel(g_RegEditData.hValueListWnd, ListIndex);

    }

    return;

error_ShowDialog:
    InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
        MAKEINTRESOURCE(IDS_NEWVALUEERRORTITLE), MB_ICONERROR | MB_OK);

}

/*******************************************************************************
*
*  RegEdit_OnValueListBeginLabelEdit
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     lpLVDispInfo,
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_OnValueListBeginLabelEdit(
    HWND hWnd,
    LV_DISPINFO FAR* lpLVDispInfo
    )
{

    //
    //  B#7933:  We don't want the user to hurt themselves by making it too easy
    //  to rename keys and values.  Only allow renames via the menus.
    //

    //
    //  We don't get any information on the source of this editing action, so
    //  we must maintain a flag that tells us whether or not this is "good".
    //

    if (!g_RegEditData.fAllowLabelEdits)
        return TRUE;

    //
    //  All other labels are fair game.  We need to disable our keyboard
    //  accelerators so that the edit control can "see" them.
    //

    g_fDisableAccelerators = TRUE;

    return FALSE;

}

/*******************************************************************************
*
*  RegEdit_OnValueListEndLabelEdit
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
PASCAL
RegEdit_OnValueListEndLabelEdit(
    HWND hWnd,
    LV_DISPINFO FAR* lpLVDispInfo
    )
{
    BOOL fSuccess = TRUE;
    HWND hValueListWnd;
    DWORD cbValueData;
    DWORD Ignore;
    DWORD Type;
    TCHAR ValueName[MAXVALUENAME_LENGTH];
    UINT ErrorStringID;
    PBYTE pbValueData;

    //
    //  We can reenable our keyboard accelerators now that the edit control no
    //  longer needs to "see" them.
    //

    g_fDisableAccelerators = FALSE;

    hValueListWnd = g_RegEditData.hValueListWnd;

    //
    //  Check to see if the user cancelled the edit.  If so, we don't care so
    //  just return.
    //

    if (lpLVDispInfo-> item.pszText != NULL)
    {

        ListView_GetItemText(hValueListWnd, lpLVDispInfo-> item.iItem, 0,
            ValueName, ARRAYSIZE(ValueName));

        //  Check to see if the new value name is empty
        if (lpLVDispInfo->item.pszText[0] == 0) 
        {
            ErrorStringID = IDS_RENAMEVALEMPTY;
            fSuccess = FALSE;
        }
        //  Check to see if the new name already exists
        else if (RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, lpLVDispInfo->
            item.pszText, NULL, &Ignore, NULL, &Ignore) != ERROR_FILE_NOT_FOUND) 
        {
            ErrorStringID = IDS_RENAMEVALEXISTS;
            fSuccess = FALSE;
        }

        // Set new name
        if (fSuccess)
        {
            fSuccess = FALSE;

            // Query for data size
            RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName,
                NULL, &Type, NULL, &cbValueData);
    
            // Allocate storage space
            pbValueData = LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
            if (pbValueData)
            {
                ErrorStringID = IDS_RENAMEVALOTHERERROR;

                if (RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName, NULL,
                    &Type, pbValueData, &cbValueData) == ERROR_SUCCESS) 
                {

                    if (RegSetValueEx(g_RegEditData.hCurrentSelectionKey, 
                        lpLVDispInfo->item.pszText, 0, Type, pbValueData, cbValueData) ==
                        ERROR_SUCCESS) 
                    {
                        if (RegDeleteValue(g_RegEditData.hCurrentSelectionKey, ValueName) ==
                            ERROR_SUCCESS) 
                        {
                            fSuccess = TRUE;
                        }
                    }
                }
                LocalFree(pbValueData);
            }
            else
            {
                ErrorStringID = IDS_EDITVALNOMEMORY;
            }
        }

        if (!fSuccess)
        {
            InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
                MAKEINTRESOURCE(IDS_RENAMEVALERRORTITLE), MB_ICONERROR | MB_OK,
                (LPTSTR) ValueName);
        }
    }

    return fSuccess;
}

/*******************************************************************************
*
*  RegEdit_OnValueListCommand
*
*  DESCRIPTION:
*     Handles the selection of a menu item by the user intended for the
*     ValueList child window.
*
*  PARAMETERS:
*     hWnd, handle of RegEdit window.
*     MenuCommand, identifier of menu command.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnValueListCommand(
    HWND hWnd,
    int MenuCommand
    )
{

    //
    //  Check to see if this menu command should be handled by the main window's
    //  command handler.
    //

    if (MenuCommand >= ID_FIRSTMAINMENUITEM && MenuCommand <=
        ID_LASTMAINMENUITEM)
        RegEdit_OnCommand(hWnd, MenuCommand, NULL, 0);

    else {

        switch (MenuCommand) {

            case ID_CONTEXTMENU:
                RegEdit_OnValueListContextMenu(hWnd, TRUE);
                break;

            case ID_MODIFY:
                RegEdit_OnValueListModify(hWnd, FALSE);
                break;

            case ID_DELETE:
                RegEdit_OnValueListDelete(hWnd);
                break;

            case ID_RENAME:
                RegEdit_OnValueListRename(hWnd);
                break;

            case ID_MODIFYBINARY:
                RegEdit_OnValueListModify(hWnd, TRUE);
                break;

        }

    }

}

/*******************************************************************************
*
*  RegEdit_OnValueListContextMenu
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnValueListContextMenu(
    HWND hWnd,
    BOOL fByAccelerator
    )
{

    HWND hValueListWnd;
    DWORD MessagePos;
    POINT MessagePoint;
    LV_HITTESTINFO LVHitTestInfo;
    int ListIndex;
    UINT MenuID;
    HMENU hContextMenu;
    HMENU hContextPopupMenu;
    int MenuCommand;

    hValueListWnd = g_RegEditData.hValueListWnd;

    //
    //  If fByAcclerator is TRUE, then the user hit Shift-F10 to bring up the
    //  context menu.  Following the Cabinet's convention, this menu is
    //  placed at (0,0) of the ListView client area.
    //

    if (fByAccelerator) {

        MessagePoint.x = 0;
        MessagePoint.y = 0;

        ClientToScreen(hValueListWnd, &MessagePoint);

        ListIndex = ListView_GetNextItem(hValueListWnd, -1, LVNI_SELECTED);

    }

    else {

        MessagePos = GetMessagePos();
        MessagePoint.x = GET_X_LPARAM(MessagePos);
        MessagePoint.y = GET_Y_LPARAM(MessagePos);

        LVHitTestInfo.pt = MessagePoint;
        ScreenToClient(hValueListWnd, &LVHitTestInfo.pt);
        ListIndex = ListView_HitTest(hValueListWnd, &LVHitTestInfo);

    }

    MenuID = (ListIndex != -1) ? IDM_VALUE_CONTEXT :
        IDM_VALUELIST_NOITEM_CONTEXT;

    if ((hContextMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(MenuID))) == NULL)
        return;

    hContextPopupMenu = GetSubMenu(hContextMenu, 0);

    if (ListIndex != -1) {

        RegEdit_SetValueListEditMenuItems(hContextMenu, ListIndex);

        SetMenuDefaultItem(hContextPopupMenu, ID_MODIFY, MF_BYCOMMAND);

    }

        //  FEATURE:  Fix constant
    else
        RegEdit_SetNewObjectEditMenuItems(GetSubMenu(hContextPopupMenu, 0));

    MenuCommand = TrackPopupMenuEx(hContextPopupMenu, TPM_RETURNCMD |
        TPM_RIGHTBUTTON | TPM_LEFTALIGN | TPM_TOPALIGN, MessagePoint.x,
        MessagePoint.y, hWnd, NULL);

    DestroyMenu(hContextMenu);

    RegEdit_OnValueListCommand(hWnd, MenuCommand);

}

/*******************************************************************************
*
*  RegEdit_SetValueListEditMenuItems
*
*  DESCRIPTION:
*     Shared routine between the main menu and the context menu to setup the
*     edit menu items.
*
*  PARAMETERS:
*     hPopupMenu, handle of popup menu to modify.
*
*******************************************************************************/

VOID
PASCAL
RegEdit_SetValueListEditMenuItems(
    HMENU hPopupMenu,
    int SelectedListIndex
    )
{

    UINT SelectedCount;
    UINT EnableFlags;

    SelectedCount = ListView_GetSelectedCount(g_RegEditData.hValueListWnd);

    //
    //  The edit option is only enabled when a single item is selected.  Note
    //  that this item is not in the main menu, but this should work fine.
    //

    if (SelectedCount == 1)
        EnableFlags = MF_ENABLED | MF_BYCOMMAND;
    else
        EnableFlags = MF_GRAYED | MF_BYCOMMAND;

    EnableMenuItem(hPopupMenu, ID_MODIFY, EnableFlags);

    //
    //  The rename option is also only enabled when a single item is selected
    //  and that item cannot be the default item.  EnableFlags is already
    //  disabled if the SelectedCount is not one from above.
    //

    if (SelectedListIndex == 0)
        EnableFlags = MF_GRAYED | MF_BYCOMMAND;

    EnableMenuItem(hPopupMenu, ID_RENAME, EnableFlags);

    //
    //  The delete option is only enabled when multiple items are selected.
    //

    if (SelectedCount > 0)
        EnableFlags = MF_ENABLED | MF_BYCOMMAND;
    else
        EnableFlags = MF_GRAYED | MF_BYCOMMAND;

    EnableMenuItem(hPopupMenu, ID_DELETE, EnableFlags);

}

/*******************************************************************************
*
*  RegEdit_OnValueListModify
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnValueListModify(HWND hWnd, BOOL fEditBinary)
{
    //  Verify that we only have one item selected
    //  Don't beep for a double-clicking on the background.
    UINT SelectedCount = ListView_GetSelectedCount(g_RegEditData.hValueListWnd);

    if (SelectedCount > 0)
    {
        if (SelectedCount != 1)
        {
            MessageBeep(0);
        }
        else
        {
            RegEdit_EditCurrentValueListItem(hWnd, fEditBinary);   
        }
    }
}

VOID PASCAL RegEdit_EditCurrentValueListItem(HWND hWnd, BOOL fEditBinary)
{
    DWORD Type;
    UINT ErrorStringID;
    BOOL fError = FALSE;
    EDITVALUEPARAM EditValueParam;
    TCHAR ValueName[MAXVALUENAME_LENGTH];
    int ListIndex = ListView_GetNextItem(g_RegEditData.hValueListWnd, -1, LVNI_SELECTED);
    LONG err;

    // VALUE NAME
    ListView_GetItemText(g_RegEditData.hValueListWnd, ListIndex, 0, ValueName, ARRAYSIZE(ValueName));
    //  This is the "(Default)" value. It either does not exist in the registry because
    //  it's value is not set, or it exists in the registry as '\0' when its value is set
    if (ListIndex == 0)
    {
        ValueName[0] = TEXT('\0');
    }
    EditValueParam.pValueName = ValueName;
    
    // VALUE DATA
    // Query for size and type
    // Note that for the DefaultValue, the value may not actually exist yet.  In that case we
    // will get back ERROR_FILE_NOT_FOUND as the error code.
    err = RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName, NULL, &Type, NULL, &EditValueParam.cbValueData);

    if (err == ERROR_FILE_NOT_FOUND && ValueName[0] == TEXT('\0'))
    {
        Type = REG_SZ;
        err = ERROR_SUCCESS;
    }
    
    if (err == ERROR_SUCCESS)
    {
        // Allocate storage space
        EditValueParam.pValueData =  LocalAlloc(LPTR, EditValueParam.cbValueData+ExtraAllocLen(Type));
        if (EditValueParam.pValueData)
        {
            UINT TemplateID = IDD_EDITBINARYVALUE;
            DLGPROC lpDlgProc = EditBinaryValueDlgProc;
            BOOL fResourceType = FALSE;

            // Initialize with registry value
            err = RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, ValueName, NULL, &Type, EditValueParam.pValueData, &EditValueParam.cbValueData);
            
            // Allow the special behavior for a key's Default Value.
            if (err == ERROR_FILE_NOT_FOUND && ValueName[0] == TEXT('\0')) 
            {
                Type = REG_SZ;
                *((TCHAR*)EditValueParam.pValueData) = TEXT('\0');
                err = ERROR_SUCCESS;
            }

            if (err == ERROR_SUCCESS)
            {
                if (!fEditBinary)
                {
                    switch (Type) 
                    {
                    case REG_SZ:
                    case REG_EXPAND_SZ:
                        TemplateID = IDD_EDITSTRINGVALUE;
                        lpDlgProc = EditStringValueDlgProc;
                        break;

                    case REG_MULTI_SZ: 
                        if(ValueList_MultiStringToString(&EditValueParam))
                        {
                            TemplateID = IDD_EDITMULTISZVALUE;
                            lpDlgProc = EditStringValueDlgProc;
                        }
                        break;

                    case REG_RESOURCE_LIST:
                    case REG_FULL_RESOURCE_DESCRIPTOR:
                    case REG_RESOURCE_REQUIREMENTS_LIST:
                        fResourceType = TRUE;
                        break;

                    case REG_DWORD_BIG_ENDIAN:
                        if (EditValueParam.cbValueData == sizeof(DWORD)) 
                        {
                            *((DWORD*)EditValueParam.pValueData) = ValueList_SwitchEndian(*((DWORD*)EditValueParam.pValueData));
                            TemplateID = IDD_EDITDWORDVALUE;
                            lpDlgProc = EditDwordValueDlgProc;
                        }
                        break;

                    case REG_DWORD:
                        if (EditValueParam.cbValueData == sizeof(DWORD)) 
                        {
                            TemplateID = IDD_EDITDWORDVALUE;
                            lpDlgProc = EditDwordValueDlgProc;

                        }
                        break;
                    }
                }

                if (fResourceType)
                {
                    // only display, no editing
                    DisplayResourceData(hWnd, Type, &EditValueParam);
                }
                else if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(TemplateID), 
                    hWnd, lpDlgProc, (LPARAM) &EditValueParam) == IDOK)
                {
                    if ((Type == REG_MULTI_SZ) && (!fEditBinary))
                    {
                        ValueList_StringToMultiString(&EditValueParam);
                        ValueList_RemoveEmptyStrings(hWnd, &EditValueParam);
                    }

                    if ((Type == REG_DWORD_BIG_ENDIAN) && (!fEditBinary) && EditValueParam.cbValueData == sizeof(DWORD)) 
                    {
                        *((DWORD*)EditValueParam.pValueData) = ValueList_SwitchEndian(*((DWORD*)EditValueParam.pValueData));
                    }

                    // set the registry value
                    if (RegSetValueEx(g_RegEditData.hCurrentSelectionKey, ValueName, 0,
                        Type, EditValueParam.pValueData, EditValueParam.cbValueData) !=
                        ERROR_SUCCESS) 
                    {
                        ErrorStringID = IDS_EDITVALCANNOTWRITE;
                        fError = TRUE;
                    }

                    if (!fError)
                    {
                        // set the display value
                        ValueList_SetItemDataText(g_RegEditData.hValueListWnd, ListIndex,
                            EditValueParam.pValueData, EditValueParam.cbValueData, Type);
                    }
                }
            }
            else
            {
                ErrorStringID = IDS_EDITVALCANNOTREAD;
                fError = TRUE;
            }

            LocalFree(EditValueParam.pValueData);
        }
        else
        {
            ErrorStringID = IDS_EDITVALNOMEMORY;
            fError = TRUE;
        }
    }
    else
    {
        ErrorStringID = IDS_EDITVALCANNOTREAD;
        fError = TRUE;
    }
 
    if (fError)
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
            MAKEINTRESOURCE(IDS_EDITVALERRORTITLE), MB_ICONERROR | MB_OK,
            (LPTSTR) ValueName);
    }
}

/*******************************************************************************
*
*  RegEdit_OnValueListDelete
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnValueListDelete(
    HWND hWnd
    )
{

    HWND hValueListWnd;
    UINT ConfirmTextStringID;
    BOOL fErrorDeleting;
    int ListStartIndex;
    int ListIndex;
    TCHAR ValueName[MAXVALUENAME_LENGTH];

    hValueListWnd = g_RegEditData.hValueListWnd;

    ConfirmTextStringID =  (ListView_GetSelectedCount(hValueListWnd) == 1) ?
        IDS_CONFIRMDELVALTEXT : IDS_CONFIRMDELVALMULTITEXT;

    if (InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ConfirmTextStringID),
        MAKEINTRESOURCE(IDS_CONFIRMDELVALTITLE),  MB_ICONWARNING | MB_YESNO) !=
        IDYES)
        return;

    SetWindowRedraw(hValueListWnd, FALSE);

    fErrorDeleting = FALSE;
    ListStartIndex = -1;

    while ((ListIndex = ListView_GetNextItem(hValueListWnd, ListStartIndex, LVNI_SELECTED)) != -1) 
    {
        if (ListIndex != 0) 
        {
            ListView_GetItemText(hValueListWnd, ListIndex, 0, ValueName, ARRAYSIZE(ValueName));
        }
        else
        {
            ValueName[0] = 0;
        }

        if (RegDeleteValue(g_RegEditData.hCurrentSelectionKey, ValueName) == ERROR_SUCCESS) 
        {

            if (ListIndex != 0)
                ListView_DeleteItem(hValueListWnd, ListIndex);

            else {

                ValueList_SetItemDataText(hValueListWnd, 0, NULL, 0, REG_SZ);

                ListStartIndex = 0;

            }

        }
        else 
        {

            fErrorDeleting = TRUE;

            ListStartIndex = ListIndex;

        }

    }

    SetWindowRedraw(hValueListWnd, TRUE);

    if (fErrorDeleting)
        InternalMessageBox(g_hInstance, hWnd,
            MAKEINTRESOURCE(IDS_DELETEVALDELETEFAILED),
            MAKEINTRESOURCE(IDS_DELETEVALERRORTITLE), MB_ICONERROR | MB_OK);

}

/*******************************************************************************
*
*  RegEdit_OnValueListRename
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
RegEdit_OnValueListRename(
    HWND hWnd
    )
{

    HWND hValueListWnd;
    int ListIndex;

    hValueListWnd = g_RegEditData.hValueListWnd;

    if (ListView_GetSelectedCount(hValueListWnd) == 1 && (ListIndex =
        ListView_GetNextItem(hValueListWnd, -1, LVNI_SELECTED)) != 0)
        ValueList_EditLabel(g_RegEditData.hValueListWnd, ListIndex);

}

/*******************************************************************************
*
*  RegEdit_OnValueListRefresh
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

LONG
PASCAL
RegEdit_OnValueListRefresh(HWND hWnd)
{
    UINT ErrorStringID;
    BOOL fError = FALSE;
    BOOL fInsertedDefaultValue;
    HWND hValueListWnd = g_RegEditData.hValueListWnd;
    LONG result = ERROR_SUCCESS;

    RegEdit_SetWaitCursor(TRUE);
    SetWindowRedraw(hValueListWnd, FALSE);

    ListView_DeleteAllItems(hValueListWnd);

    if (g_RegEditData.hCurrentSelectionKey != NULL) 
    {
        LV_ITEM LVItem;
        LONG PrevStyle;
        DWORD EnumIndex;
        TCHAR achValueName[MAXVALUENAME_LENGTH];

        LVItem.mask = LVIF_TEXT | LVIF_IMAGE;
        LVItem.pszText = achValueName;
        LVItem.iSubItem = 0;

        PrevStyle = SetWindowLong(hValueListWnd, GWL_STYLE,
            GetWindowLong(hValueListWnd, GWL_STYLE) | LVS_SORTASCENDING);

        EnumIndex = 0;
        fInsertedDefaultValue = FALSE;

        while (TRUE) 
        {
            DWORD Type;
            DWORD cbValueData = 0;
            int ListIndex;
            PBYTE pbValueData;
            DWORD cchValueName = ARRAYSIZE(achValueName);

            // VALUE DATA
            // Query for data size
            result = RegEnumValue(g_RegEditData.hCurrentSelectionKey, EnumIndex++,
                                  achValueName, &cchValueName, NULL, &Type, NULL, 
                                  &cbValueData);
            if (result != ERROR_SUCCESS)
            {
                break;
            }

            // allocate memory for data
            pbValueData =  LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
            if (pbValueData)
            {
                if (RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, achValueName,
                    NULL, &Type, pbValueData, &cbValueData) != ERROR_SUCCESS)
                {   
                    ErrorStringID = IDS_REFRESHCANNOTREAD;
                    fError = TRUE;
                }
                else
                {
                    if (cchValueName == 0)
                    {
                        fInsertedDefaultValue = TRUE;
                    }

                    LVItem.iImage = IsRegStringType(Type) ? IMAGEINDEX(IDI_STRING) :
                        IMAGEINDEX(IDI_BINARY);

                    ListIndex = ListView_InsertItem(hValueListWnd, &LVItem);

                    ValueList_SetItemDataText(hValueListWnd, ListIndex,
                        pbValueData, cbValueData, Type);
                }
                LocalFree(pbValueData);
            }
            else
            {
                fError = TRUE;
                ErrorStringID = IDS_REFRESHNOMEMORY;
            }

            if (fError)
            {
                InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
                MAKEINTRESOURCE(IDS_REFRESHERRORTITLE), MB_ICONERROR | MB_OK,
                (LPTSTR) achValueName);
                fError = FALSE;
            }

        }

        SetWindowLong(hValueListWnd, GWL_STYLE, PrevStyle);

        LVItem.iItem = 0;
        LVItem.pszText = g_RegEditData.pDefaultValue;
        LVItem.iImage = IMAGEINDEX(IDI_STRING);

        if (fInsertedDefaultValue) 
        {
            LVItem.mask = LVIF_TEXT;
            ListView_SetItem(hValueListWnd, &LVItem);
        }
        else 
        {
            ListView_InsertItem(hValueListWnd, &LVItem);
            ValueList_SetItemDataText(hValueListWnd, 0, NULL, 0, REG_SZ);
        }
        ListView_SetItemState(hValueListWnd, 0, LVIS_FOCUSED, LVIS_FOCUSED);
    }

    SetWindowRedraw(hValueListWnd, TRUE);
    RegEdit_SetWaitCursor(FALSE);

    return result;
}


/*******************************************************************************
*
*  ValueList_SetItemDataText
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hValueListWnd, handle of ValueList window.
*     ListIndex, index into ValueList window.
*     pValueData, pointer to buffer containing data.
*     cbValueData, size of the above buffer.
*     Type, type of data this buffer contains (REG_* definition).
*
*******************************************************************************/

VOID
PASCAL
ValueList_SetItemDataText(
    HWND hValueListWnd,
    int ListIndex,
    PBYTE pValueData,
    DWORD cbValueData,
    DWORD Type
    )
{

    BOOL fMustDeleteString;
    TCHAR DataText[SIZE_DATATEXT];
    int BytesToWrite;
    PTSTR pString;

    fMustDeleteString = FALSE;

    //
    //  When pValueData is NULL, then that's a special indicator to us that this
    //  is the default value and it's value is undefined.
    //

    if (pValueData == NULL)
    {
        pString = g_RegEditData.pValueNotSet;
    }
    else if ((Type == REG_SZ) || (Type == REG_EXPAND_SZ)) 
    {
        StringCchPrintf(DataText, ARRAYSIZE(DataText), s_StringDataFormatSpec, (LPTSTR) pValueData);

        if ((cbValueData/sizeof(TCHAR)) > MAXIMUM_STRINGDATATEXT + 1)           //  for null
            StringCchCat(DataText, ARRAYSIZE(DataText), s_Ellipsis);

        pString = DataText;
    }
    else if (Type == REG_DWORD || Type == REG_DWORD_BIG_ENDIAN) 
    {
        //  FEATURE:  Check for invalid cbValueData!
        if (cbValueData == sizeof(DWORD))
        {
            DWORD dw = *((DWORD*)pValueData);

            if (Type == REG_DWORD_BIG_ENDIAN)
            {
                dw = ValueList_SwitchEndian(dw);
            }

            pString = LoadDynamicString(IDS_DWORDDATAFORMATSPEC, dw);
        }
        else
        {
            pString = LoadDynamicString(IDS_INVALIDDWORDDATA);
        }

        fMustDeleteString = TRUE;
    } 
    else if (Type == REG_MULTI_SZ) 
    {
        int CharsAvailableInBuffer;
        int ComponentLength;
        PTCHAR Start;

        ZeroMemory(DataText, sizeof(DataText));
        CharsAvailableInBuffer = MAXIMUM_STRINGDATATEXT+1;
        Start = DataText;
        for (pString=(PTSTR)pValueData; *pString; pString+=ComponentLength+1) 
        {

            ComponentLength = lstrlen(pString);

            //
            // Quirky behavior of lstrcpyn is exactly what we need here.
            //
            if(CharsAvailableInBuffer > 0) 
            {
                lstrcpyn(Start, pString, CharsAvailableInBuffer);
                Start += ComponentLength;
            }

            CharsAvailableInBuffer -= ComponentLength;

            if(CharsAvailableInBuffer > 0) 
            {
                lstrcpyn(Start,TEXT(" "),CharsAvailableInBuffer);
                Start += 1;
            }

            CharsAvailableInBuffer -= 1;
        }

        if(CharsAvailableInBuffer < 0) 
        {
            lstrcpy(DataText+MAXIMUM_STRINGDATATEXT, s_Ellipsis);
        }

        pString = DataText;
    }
    else 
    {
        if (cbValueData == 0)
        {
            pString = g_RegEditData.pEmptyBinary;
        }
        else 
        {
            BytesToWrite = min(cbValueData, MAXIMUM_BINARYDATABYTES);

            pString = DataText;

            while (BytesToWrite--)
            {
                pString += wsprintf(pString, s_BinaryDataFormatSpec, (BYTE) *pValueData++);
            }

            *(--pString) = 0;

            if (cbValueData > MAXIMUM_BINARYDATABYTES)
                lstrcpy(pString, s_Ellipsis);

            pString = DataText;

        }

    }

    if(Type <= MAX_KNOWN_TYPE) 
    {
        ListView_SetItemText(hValueListWnd, ListIndex, 1, (LPTSTR)s_TypeNames[Type]);
    } 
    else 
    {
        TCHAR TypeString[24];

        StringCchPrintf(TypeString, ARRAYSIZE(TypeString), TEXT("0x%x"),Type);
        ListView_SetItemText(hValueListWnd, ListIndex, 1, TypeString);
    }

    ListView_SetItemText(hValueListWnd, ListIndex, 2, pString);

    if (fMustDeleteString)
        DeleteDynamicString(pString);

}

/*******************************************************************************
*
*  ValueList_EditLabel
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hValueListWnd, handle of ValueList window.
*     ListIndex, index of item to edit.
*
*******************************************************************************/

VOID
PASCAL
ValueList_EditLabel(
    HWND hValueListWnd,
    int ListIndex
    )
{

    g_RegEditData.fAllowLabelEdits = TRUE;

    //
    //  We have to set the focus to the ListView or else ListView_EditLabel will
    //  return FALSE.  While we're at it, clear the selected state of all the
    //  items to eliminate some flicker when we move the focus back to this
    //  pane.
    //

    if (hValueListWnd != g_RegEditData.hFocusWnd) 
    {

        ListView_SetItemState(hValueListWnd, -1, 0, LVIS_SELECTED |
            LVIS_FOCUSED);

        SetFocus(hValueListWnd);

    }

    ListView_EditLabel(hValueListWnd, ListIndex);

    g_RegEditData.fAllowLabelEdits = FALSE;

}

//------------------------------------------------------------------------------
//  ValueList_MultiStringToString
//
//  DESCRIPTION: Replaces NULL with '\r\n' to convert a Multi-String to a String
//
//  PARAMETERS:  EditValueParam - the edit value information
//------------------------------------------------------------------------------
BOOL PASCAL ValueList_MultiStringToString(LPEDITVALUEPARAM pEditValueParam)   
{
    BOOL fSuccess = TRUE;
    int iStrLen = pEditValueParam->cbValueData / sizeof(TCHAR);

    if (iStrLen > 1)
    {
        int i;
        int cNullsToReplace = 0; 
        PTSTR pszTemp = NULL;
        PTSTR psz = (TCHAR*)pEditValueParam->pValueData;

        // Determine new size 
        for (i = iStrLen - 2; i >=0; i--)
        {
            if (psz[i] == TEXT('\0'))
            {
                cNullsToReplace++;
            }
        }
        // the new string is always atleast as big as the old str, so we can convert back
        pszTemp = LocalAlloc(LPTR, pEditValueParam->cbValueData + cNullsToReplace * sizeof(TCHAR));
        if (pszTemp)
        {
            int iCurrentChar = 0;
            int iLastNull = iStrLen - 1;

            // change NULL to '\r\n'  
            for(i = 0; i < iLastNull; i++)
            {
                if (psz[i] == TEXT('\0'))
                {  
                    pszTemp[iCurrentChar++] = TEXT('\r');
                    pszTemp[iCurrentChar] = TEXT('\n');
                }
                else
                {
                    pszTemp[iCurrentChar] = psz[i];
                }
                iCurrentChar++;
            }

            pszTemp[iCurrentChar++] = TEXT('\0');

            pEditValueParam->pValueData  = (PBYTE)pszTemp;
            pEditValueParam->cbValueData = iCurrentChar * sizeof(psz[0]);
            
            LocalFree(psz);
        }
        else
        {
            fSuccess = FALSE;
        }
    }
    return fSuccess;
}


//------------------------------------------------------------------------------
//  ValueList_StringToMultiString
//
//  DESCRIPTION: Replaces '\r\n' with NULL
//
//  PARAMETERS:  EditValueParam - the edit value information
//------------------------------------------------------------------------------
VOID PASCAL ValueList_StringToMultiString(LPEDITVALUEPARAM pEditValueParam)   
{
    PTSTR psz = (TCHAR*)pEditValueParam->pValueData;
    int iStrLen = pEditValueParam->cbValueData / sizeof(TCHAR);

    if (iStrLen > 1)
    {
        int i = 0;
        int iCurrentChar = 0;

        // remove a return at the end of the string
        // because another string does not follow it.
        if (iStrLen >= 3)
        {
            if (psz[iStrLen - 3] == TEXT('\r'))
            {
                psz[iStrLen - 3] = TEXT('\0');
                iStrLen -= 2;
            }
        }

        for (i = 0; i < iStrLen; i++)
        {
            if (psz[i] == '\r')
            {  
                psz[iCurrentChar++] = TEXT('\0');
                i++; // jump past the '\n'   
            }
            else
            {
                psz[iCurrentChar++] = psz[i];
            }
        }

        // Null terminate multi-string
        psz[iCurrentChar++] = TEXT('\0');
        pEditValueParam->cbValueData = iCurrentChar * sizeof(psz[0]);
    }
}

//------------------------------------------------------------------------------
//  ValueList_RemoveEmptyStrings
//
//  DESCRIPTION: Removes empty strings from multi-strings
//
//  PARAMETERS:  EditValueParam - the edit value information
//------------------------------------------------------------------------------
VOID PASCAL ValueList_RemoveEmptyStrings(HWND hWnd, LPEDITVALUEPARAM pEditValueParam)   
{
    PTSTR psz = (TCHAR*)pEditValueParam->pValueData;
    int iStrLen = pEditValueParam->cbValueData / sizeof(TCHAR);

    if (iStrLen > 1)
    {
        int i = 0;
        int cNullStrings = 0;
        int iCurrentChar = 0;
        int iLastChar = pEditValueParam->cbValueData / sizeof(psz[0]) - 1;

        for (i = 0; i < iLastChar; i++)
        {
            if (((psz[i] != TEXT('\0')) || (psz[i+1] != TEXT('\0'))) &&
                ((psz[i] != TEXT('\0')) || (i != 0)))
            {  
                psz[iCurrentChar++] = psz[i];
            }
        }

        psz[iCurrentChar++] = TEXT('\0');

        if (iCurrentChar > 1)
        {
            cNullStrings = iLastChar - iCurrentChar;

            // Null terminate multi-string
            psz[iCurrentChar++] = TEXT('\0');

            // warn user of empty strings
            if (cNullStrings)
            {
                UINT ErrorStringID 
                    = (cNullStrings == 1) ? IDS_EDITMULTSZEMPTYSTR : IDS_EDITMULTSZEMPTYSTRS;

                InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
                MAKEINTRESOURCE(IDS_EDITWARNINGTITLE), MB_ICONERROR | MB_OK, NULL);
            }
        }
        pEditValueParam->cbValueData = (iCurrentChar * sizeof(psz[0]));
    }
}

//------------------------------------------------------------------------------
//  ValueList_SwitchEndian
//
//  DESCRIPTION: Switched a DWORD between little and big endian.
//
//  PARAMETERS:  dwSrc - the source DWORD to switch around
//------------------------------------------------------------------------------
DWORD PASCAL ValueList_SwitchEndian(DWORD dwSrc)
{
    DWORD dwDest = 0;
    BYTE * pbSrc = (BYTE *)&dwSrc;
    BYTE * pbDest = (BYTE *)&dwDest;
    int i;

    for(i = 0; i < 4; i++)
    {
        pbDest[i] = pbSrc[3-i];
    }

    return dwDest;
}

VOID RegEdit_DisplayBinaryData(HWND hWnd)
{
    DWORD Type;
    UINT ErrorStringID;
    BOOL fError = FALSE;
    EDITVALUEPARAM EditValueParam;
    TCHAR achValueName[MAXVALUENAME_LENGTH];
    int ListIndex = ListView_GetNextItem(g_RegEditData.hValueListWnd, -1, LVNI_SELECTED);
    LONG err;

    ListView_GetItemText(g_RegEditData.hValueListWnd, ListIndex, 0, achValueName, ARRAYSIZE(achValueName));
    if (ListIndex == 0)
    {
        //  This is the "(Default)" value. It either does not exist in the registry because
        //  it's value is not set, or it exists in the registry as '\0' when its value is set
        achValueName[0] = TEXT('\0');
    }
    EditValueParam.pValueName = achValueName;
    
    // get size and type
    err = RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, achValueName, NULL, &Type, NULL, &EditValueParam.cbValueData);
    if (err == ERROR_SUCCESS || (err == ERROR_FILE_NOT_FOUND && achValueName[0] == TEXT('\0'))) {
        // Allocate storage space
        EditValueParam.pValueData =  LocalAlloc(LPTR, EditValueParam.cbValueData+ExtraAllocLen(Type));
        if (EditValueParam.pValueData)
        { 
            err = RegEdit_QueryValueEx(g_RegEditData.hCurrentSelectionKey, achValueName, NULL, &Type, EditValueParam.pValueData, &EditValueParam.cbValueData);
            
            // Allow the special behavior for a key's Default Value.
            if (err == ERROR_FILE_NOT_FOUND && achValueName[0] == TEXT('\0')) {
                Type = REG_SZ;
                *((TCHAR*)EditValueParam.pValueData) = TEXT('\0');
                err = ERROR_SUCCESS;
            }            
            
            if (err == ERROR_SUCCESS) {
                DisplayBinaryData(hWnd, &EditValueParam, Type);
            } else {
                ErrorStringID = IDS_EDITVALCANNOTREAD;
                fError = TRUE;
            }

            LocalFree(EditValueParam.pValueData);
        }
        else
        {
            ErrorStringID = IDS_EDITVALNOMEMORY;
            fError = TRUE;
        }
    }
    else
    {
        ErrorStringID = IDS_EDITVALCANNOTREAD;
        fError = TRUE;
    }
 
    if (fError)
    {
        InternalMessageBox(g_hInstance, hWnd, MAKEINTRESOURCE(ErrorStringID),
            MAKEINTRESOURCE(IDS_EDITVALERRORTITLE), MB_ICONERROR | MB_OK,
            (LPTSTR) achValueName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedit\regvalue.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGVALUE.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  ValueListWnd ListView routines for the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGVALUE
#define _INC_REGVALUE

VOID
PASCAL
RegEdit_OnNewValue(
    HWND hWnd,
    DWORD Type
    );

VOID
PASCAL
RegEdit_OnValueListCommand(
    HWND hWnd,
    int MenuCommand
    );

VOID
PASCAL
RegEdit_OnValueListBeginDrag(
    HWND hWnd,
    NM_LISTVIEW FAR* lpNMListView
    );

BOOL
PASCAL
RegEdit_OnValueListBeginLabelEdit(
    HWND hWnd,
    LV_DISPINFO FAR* lpLVDispInfo
    );

BOOL
PASCAL
RegEdit_OnValueListEndLabelEdit(
    HWND hWnd,
    LV_DISPINFO FAR* lpLVDispInfo
    );

VOID
PASCAL
RegEdit_OnValueListCommand(
    HWND hWnd,
    int MenuCommand
    );

VOID
PASCAL
RegEdit_OnValueListContextMenu(
    HWND hWnd,
    BOOL fByAccelerator
    );

VOID
PASCAL
RegEdit_SetValueListEditMenuItems(
    HMENU hPopupMenu,
    int SelectedListIndex
    );

VOID
PASCAL
RegEdit_OnValueListModify(
    HWND hWnd,
    BOOL fEditBinary
    );

VOID PASCAL RegEdit_EditCurrentValueListItem(HWND hWnd, BOOL fEditBinary);

LONG
PASCAL
RegEdit_OnValueListRefresh(
    HWND hWnd
    );

VOID
PASCAL
ValueList_SetItemDataText(
    HWND hValueListWnd,
    int ListIndex,
    PBYTE pValueData,
    DWORD cbValueData,
    DWORD Type
    );

DWORD PASCAL ValueList_SwitchEndian(DWORD dwSrc);
BOOL PASCAL ValueList_MultiStringToString(LPEDITVALUEPARAM LPEditValueParam);
VOID PASCAL ValueList_StringToMultiString(LPEDITVALUEPARAM LPEditValueParam);
VOID PASCAL ValueList_RemoveEmptyStrings(HWND hWnd, LPEDITVALUEPARAM LPEditValueParam);
VOID RegEdit_DisplayBinaryData(HWND hWnd);

#endif // _INC_REGVALUE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedt32\regedt32.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

#include <windows.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <strsafe.h>

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)                    (sizeof(x)/sizeof(x[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\regedt32\regedt32.c ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#include "regedt32.h"

// stolen from the CRT, used to shrink our code

int _stdcall ModuleEntry(void)
{
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    return WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

}


const char szFile[] = "regedit.exe";

//---------------------------------------------------------------------------
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    TCHAR szFullPath[MAX_PATH+1];

    *szFullPath = 0;
    if (GetWindowsDirectory(szFullPath, ARRAYSIZE(szFullPath)))
    {
        if (!PathAppend(szFullPath, szFile))
        {
            *szFullPath = 0;
        }
        szFullPath[MAX_PATH] = 0;           // Ensure NULL termination
    }

    if (!*szFullPath)
    {
        StringCchCopy(szFullPath, ARRAYSIZE(szFullPath), szFile);
    }

    ShellExecute(HWND_DESKTOP, NULL, szFullPath, lpCmdLine, NULL, nCmdShow);
    ExitProcess(0);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\replace\support.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	Support

Abstract:

	Miscelaneous support functions for the Replace utility.

	All functions that are not involved directly in the adding\replacing
	of files go here.

Author:

	Ramon Juan San Andres (ramonsa) 02-May-1991

Revision History:

--*/



#include "ulib.hxx"
#include "system.hxx"
#include "replace.hxx"





VOID
REPLACE::DisplayMessageAndExit (
    IN  MSGID       MsgId,
    IN  PCWSTRING   String,
    IN  ULONG       ExitCode
	)

/*++

Routine Description:

	Displays a message and exits the program with the supplied error code.
	We support a maximum of one string parameter for the message.

Arguments:

	MsgId		-	Supplies the Id of the message to display.
	String		-	Supplies a string parameter for the message.
	ExitCode	-	Supplies the exit code with which to exit.

Return Value:

    None.

Notes:

--*/

{

	PATH	Path;

	if ( MsgId != 0 ) {
        if ( String ) {
		    DisplayMessage( MsgId, ERROR_MESSAGE, "%W", String );
	    } else {
		    DisplayMessage( MsgId, ERROR_MESSAGE, "" );
	    }
    }
	//
	//	Display the number of files added/ replaced.
	//
	if ( _AddSwitch ) {

		if ( _FilesAdded == 0 ) {
			DisplayMessage( REPLACE_MESSAGE_NO_FILES_ADDED );
		} else {
			DisplayMessage( REPLACE_MESSAGE_FILES_ADDED, NORMAL_MESSAGE, "%d",	_FilesAdded );
		}

	} else {

		if ( _FilesReplaced == 0 ) {
			DisplayMessage( REPLACE_MESSAGE_NO_FILES_REPLACED );
		} else {
			DisplayMessage( REPLACE_MESSAGE_FILES_REPLACED, NORMAL_MESSAGE, "%d", _FilesReplaced );
		}
	}

	exit( (int)ExitCode );

}

PWSTRING
REPLACE::QueryMessageString (
	IN MSGID	MsgId
	)
/*++

Routine Description:

	Obtains a string object initialized to the contents of some message

Arguments:

	MsgId	-	Supplies ID of the message

Return Value:

	PWSTRING	-	Pointer to initialized string object

Notes:

--*/

{

	PWSTRING	String;

    if ( ((String = NEW DSTRING) == NULL )  ||
		 !(SYSTEM::QueryResourceString( String, MsgId, "" )) ) {

		DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
	}

	return String;

}

VOID
REPLACE::ExitWithError(
	IN	DWORD		ErrorCode
	)

/*++

Routine Description:

	Displays a message based on a WIN32 error code, and exits.

Arguments:

	ErrorCode	-	Supplies Windows error code

Return Value:

	none

--*/

{
	Fatal(	EXIT_PATH_NOT_FOUND, REPLACE_ERROR_EXTENDED, "%d", ErrorCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\replace\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=replace
TARGETPATH=obj
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\argument.cxx    \
        ..\support.cxx     \
        ..\replace.cxx     \
        ..\replace.rc

INCLUDES=..\.;..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE    # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF   # NTDEBUG

TARGETLIBS=..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\replace\argument.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        Argument

Abstract:

        Argument processing for the Replace utility

Author:

        Ramon Juan San Andres (ramonsa) 01-May-1991

Notes:

        The arguments accepted  by the Replace utility are:

        Source path.-           Source path.

        Destination path.-      Destination path.

        Add switch.-            Adds new files to the target directory instead of
                                                replacing existing one. Cannot use with Subdir
                                                switch or CompareTime switch.

        Prompt switch.-         Prompts before adding/replacing a file.

        ReadOnly switch.-       Replaces red-only files as well as regular files.

        Subdir switch.-         Recurses along the destination path.

        CompareTime switch.-Replaces only thos files on the target path that
                                                are older than the corresponding file in the
                                                source path.

        Wait switch.-           Waits for the user to type any key before starting.

        Help switch.-           Displays usage

Revision History:


--*/


#include "ulib.hxx"
#include "arg.hxx"
#include "arrayit.hxx"
#include "file.hxx"
#include "system.hxx"
#include "replace.hxx"


#define MATCH_ALL_PATTERN       "*"
#define CURRENT_DIRECTORY   (LPWSTR)L"."



//
//  Global variables (global to the module)
//

PPATH_ARGUMENT          SourcePathArgument              =       NULL;
PPATH_ARGUMENT          DestinationPathArgument =       NULL;
PFLAG_ARGUMENT          AddArgument                             =       NULL;
PFLAG_ARGUMENT          PromptArgument                  =       NULL;
PFLAG_ARGUMENT          ReadOnlyArgument                =       NULL;
PFLAG_ARGUMENT          SubdirArgument                  =       NULL;
PFLAG_ARGUMENT          CompareTimeArgument             =       NULL;
PFLAG_ARGUMENT          WaitArgument                    =       NULL;
PFLAG_ARGUMENT          HelpArgument                    =       NULL;

BOOLEAN                         HelpSwitch;



VOID
REPLACE::SetArguments(
        )

/*++

Routine Description:

        Obtains the arguments for the Replace utility

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

        //
        //      Allocate things
        //
        if (//
                //      Get the argument patterns
        //
        !_AddPattern.Initialize( (LPWSTR)L"/A" ) ||
        !_PromptPattern.Initialize( (LPWSTR)L"/P" ) ||
        !_ReadOnlyPattern.Initialize( (LPWSTR)L"/R" ) ||
        !_SubdirPattern.Initialize( (LPWSTR)L"/S" ) ||
        !_CompareTimePattern.Initialize( (LPWSTR)L"/U" ) ||
        !_WaitPattern.Initialize( (LPWSTR)L"/W" ) ||
        !_HelpPattern.Initialize( (LPWSTR)L"/?" ) ||

                //
                //      Get our parsing preferences
        //
        !_Switches.Initialize( (LPWSTR)L"/-" ) ||
        !_MultipleSwitch.Initialize( (LPWSTR)L"/APRSUW?" ) ||

                //
                //      Create the arguments
                //
                ((SourcePathArgument            = NEW PATH_ARGUMENT)     == NULL )                                                              ||
                ((DestinationPathArgument       = NEW PATH_ARGUMENT)     == NULL )                                                              ||
                ((AddArgument                           = NEW FLAG_ARGUMENT)     == NULL )                                                              ||
                ((PromptArgument                        = NEW FLAG_ARGUMENT)     == NULL )                                                              ||
                ((ReadOnlyArgument                      = NEW FLAG_ARGUMENT)     == NULL )                                                              ||
                ((SubdirArgument                        = NEW FLAG_ARGUMENT)     == NULL )                                                              ||
                ((CompareTimeArgument           = NEW FLAG_ARGUMENT)     == NULL )                                                              ||
                ((WaitArgument                          = NEW FLAG_ARGUMENT)     == NULL )                                                              ||
                ((HelpArgument                          = NEW FLAG_ARGUMENT)     == NULL )
                ) {

                DisplayMessageAndExit ( REPLACE_ERROR_NO_MEMORY,
                                                                NULL,
                                                                EXIT_NO_MEMORY );
        }


        //
        //      Parse the arguments
        //
        GetArgumentsCmd();

        //
        //      Verify the arguments
        //
        CheckArgumentConsistency();

        //
        //      Clean up
    //
    DELETE( SourcePathArgument );
        DELETE( DestinationPathArgument );
        DELETE( AddArgument );
        DELETE( PromptArgument );
        DELETE( ReadOnlyArgument );
        DELETE( SubdirArgument );
        DELETE( CompareTimeArgument );
        DELETE( WaitArgument );
        DELETE( HelpArgument );
}

VOID
REPLACE::GetArgumentsCmd(
        )

/*++

Routine Description:

        Obtains the arguments from the Command line

Arguments:

    None.

Return Value:

        None

Notes:

--*/

{

        ARRAY                           ArgArray;
        PATH_ARGUMENT           ProgramNameArgument;
    DSTRING             CmdLine;

        //
        //      Prepare for parsing
        //
        if (//
                //      Initialize the arguments
                //
                !(CmdLine.Initialize( GetCommandLine() ))                                       ||
                !(ArgArray.Initialize( 10, 10 ))                                                        ||
                !(ProgramNameArgument.Initialize( MATCH_ALL_PATTERN ))          ||
        !(SourcePathArgument->Initialize( MATCH_ALL_PATTERN, FALSE)) ||
        !(DestinationPathArgument->Initialize( MATCH_ALL_PATTERN, TRUE ))   ||
        !(AddArgument->Initialize( &_AddPattern   ))                  ||
        !(PromptArgument->Initialize( &_PromptPattern ))              ||
        !(ReadOnlyArgument->Initialize( &_ReadOnlyPattern ))          ||
        !(SubdirArgument->Initialize( &_SubdirPattern ))              ||
        !(CompareTimeArgument->Initialize( &_CompareTimePattern   ))  ||
        !(WaitArgument->Initialize( &_WaitPattern ))                  ||
        !(HelpArgument->Initialize( &_HelpPattern ))                  ||

                //
                //      Put the arguments in the argument array
                //
                !(ArgArray.Put( &ProgramNameArgument ))                                         ||
                !(ArgArray.Put( AddArgument ))                                                          ||
                !(ArgArray.Put( PromptArgument ))                                                       ||
                !(ArgArray.Put( ReadOnlyArgument ))                                                     ||
                !(ArgArray.Put( SubdirArgument ))                                                       ||
                !(ArgArray.Put( CompareTimeArgument ))                                          ||
                !(ArgArray.Put( WaitArgument ))                                                         ||
                !(ArgArray.Put( HelpArgument ))                                                         ||
                !(ArgArray.Put( SourcePathArgument ))                                           ||
                !(ArgArray.Put( DestinationPathArgument ))
                )       {

                DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY,
                                                           NULL,
                                                           EXIT_NO_MEMORY );
        }

        //
        //      Parse the arguments
        //
        ParseArguments( &CmdLine, &ArgArray );

        //
        //      Set the switches
        //
        _AddSwitch                      =       AddArgument->QueryFlag();
        _PromptSwitch           =       PromptArgument->QueryFlag();
        _ReadOnlySwitch         =       ReadOnlyArgument->QueryFlag();
        _SubdirSwitch           =       SubdirArgument->QueryFlag();
        _CompareTimeSwitch      =       CompareTimeArgument->QueryFlag();
        _WaitSwitch                     =       WaitArgument->QueryFlag();
        HelpSwitch                      =       HelpArgument->QueryFlag();

        //
        //      Set the source and destination paths.
        //
        if ( SourcePathArgument->IsValueSet() ) {
        if ((_SourcePath = SourcePathArgument->GetPath()->QueryPath()) == NULL ) {
                        DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
                }
        } else {
                _SourcePath = NULL;
        }

        if ( DestinationPathArgument->IsValueSet() ) {
                if ((_DestinationPath = DestinationPathArgument->GetPath()->QueryFullPath()) == NULL ) {
                        DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
                }
        } else {
                _DestinationPath = NULL;
        }

}

VOID
REPLACE::ParseArguments(
        IN      PWSTRING        CmdLine,
        OUT PARRAY              ArgArray
        )

/*++

Routine Description:

        Parses a group of arguments

Arguments:

        CmdLine         -       Supplies pointer to a command line to parse
        ArgArray        -       Supplies pointer to array of arguments

Return Value:

        none

Notes:

--*/

{
        ARGUMENT_LEXEMIZER      ArgLex;
        ARRAY                           LexArray;

        //
        //      Initialize lexeme array and the lexemizer.
        //
        if ( !(LexArray.Initialize( 8, 8 ))                                                                                                       ||
                 !(ArgLex.Initialize( &LexArray )) ) {

                DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY,
                                                           NULL,
                                                           EXIT_NO_MEMORY );

        }

        //
        //      Set our parsing preferences
    //
    ArgLex.PutMultipleSwitch( &_MultipleSwitch );
    ArgLex.PutSwitches( &_Switches );
    ArgLex.SetCaseSensitive( FALSE );
    ArgLex.PutSeparators( " /\t" );
    ArgLex.PutStartQuotes( "\"" );
    ArgLex.PutEndQuotes( "\"" );


        //
        //      Parse the arguments
        //
        if ( !(ArgLex.PrepareToParse( CmdLine ))) {

                DisplayMessageAndExit( REPLACE_ERROR_PARSE,
                                                           NULL,
                                                           EXIT_COMMAND_LINE_ERROR );

        }

        if ( !ArgLex.DoParsing( ArgArray ) ) {

                DisplayMessageAndExit( REPLACE_ERROR_INVALID_SWITCH,
                                                           ArgLex.QueryInvalidArgument(),
                                                           EXIT_COMMAND_LINE_ERROR );
        }


}

VOID
REPLACE::CheckArgumentConsistency (
        )

/*++

Routine Description:

        Checks the consistency of the arguments

Arguments:

        none

Return Value:

        none

Notes:

--*/

{

    PFSN_FILE   File = NULL;

        if ( HelpSwitch ) {
                //
                //      Help requested
                //
                Usage();
        }


        //
        //      Make sure that we have a source path
        //
        if ( _SourcePath == NULL ) {

                DisplayMessageAndExit( REPLACE_ERROR_SOURCE_PATH_REQUIRED,
                                                           NULL,
                                                           EXIT_COMMAND_LINE_ERROR );
        }

        //
        //      The add switch cannot be specified together with the Subdir or the
        //      CompareTime switch.
        //
        if ( _AddSwitch && (_SubdirSwitch || _CompareTimeSwitch))       {

                DisplayMessageAndExit( REPLACE_ERROR_INVALID_PARAMETER_COMBINATION,
                                                           NULL,
                                                           EXIT_COMMAND_LINE_ERROR );

        }

        //
        //      If destination path is null, then the destination path is the
        //      current directory
        //
        if ( _DestinationPath == NULL ) {

                if ( ((_DestinationPath = NEW PATH) == NULL ) ||
                         !_DestinationPath->Initialize( CURRENT_DIRECTORY, TRUE ) ) {

                        DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY,
                                                                   NULL,
                                                                   EXIT_NO_MEMORY );
                }
        } else if ( (_DestinationPath->HasWildCard())   ||
                                ((File = SYSTEM::QueryFile( _DestinationPath )) != NULL) ) {
                DisplayMessageAndExit( REPLACE_ERROR_PATH_NOT_FOUND,
                                                           _DestinationPath->GetPathString(),
                                                           EXIT_PATH_NOT_FOUND );
        }

    DELETE( File );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\runas\rmtcred.h ===
#ifndef _RMTCRED_
#define _RMTCRED_

#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif

#include    "sspi.h"
#include    "rpc.h"

#ifdef __cplusplus
extern "C" {
#endif

BOOL
WINAPI
SetProcessDefaultCredentials(
    HANDLE  hProcess,
    LPWSTR  lpPrincipal,
    LPWSTR  lpPackage,
    ULONG   fCredentials,
    PVOID   LogonID,                // must be NULL for this release.
    PVOID   pvAuthData,
    SEC_GET_KEY_FN  fnGetKey,       // must be NULL for this release.
    PVOID   pvGetKeyArg             // must be NULL for this release.
    );

#ifdef __cplusplus
}
#endif

#endif // _RMTCRED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\replace\replace.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

        Replace

Abstract:

        Replace utility

Author:

        Ramon Juan San Andres (ramonsa) 01-May-1991

Revision History:

--*/

#include "ulib.hxx"
#include "arrayit.hxx"
#include "dir.hxx"
#include "filter.hxx"
#include "file.hxx"
#include "fsnode.hxx"
#include "stream.hxx"
#include "substrng.hxx"
#include "system.hxx"
#include "replace.hxx"

//
//      Pattern that matches all files in a directory
//
#define         MATCH_ALL_FILES         "*.*"


#define CTRL_C          (WCHAR)3



//
//      Size of buffers to hold path strings
//
#define         INITIAL_PATHSTRING_BUFFER_SIZE  MAX_PATH


VOID __cdecl
main (
        )

/*++

Routine Description:

        Main function of the Replace utility

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    //
    //      Initialize stuff
    //
    DEFINE_CLASS_DESCRIPTOR( REPLACE );

    //
    //      Now do the replacement
    //
    {
            REPLACE Replace;

            //
            //      Initialize the Replace object.
            //
            Replace.Initialize();

            //
            //      Do our thing
            //
            Replace.DoReplace();
    }
}




DEFINE_CONSTRUCTOR( REPLACE,    PROGRAM );



BOOLEAN
REPLACE::Initialize (
        )

/*++

Routine Description:

        Initializes the REPLACE object

Arguments:

    None.

Return Value:

        TRUE if initialized, FALSE otherwise

Notes:

--*/

{
        //
        //      Initialize program object
        //
        PROGRAM::Initialize( REPLACE_MESSAGE_USAGE );

        //
        //      Allocate global structures and initialize them
        //
        InitializeThings();

        //
        //      Parse the arguments
        //
        SetArguments();

        return TRUE;
}

REPLACE::~REPLACE (
        )

/*++

Routine Description:

        Destructs a REPLACE object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    //
    //      Deallocate the global structures previously allocated
    //
    DeallocateThings();

    //
    //      Exit without error
    //
    DisplayMessageAndExit( 0, NULL, EXIT_NORMAL );

}

VOID
REPLACE::InitializeThings (
        )

/*++

Routine Description:

        Initializes the global variables that need initialization

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

    //
        //      Initialize the path string buffers
        //
    _PathString1 = (LPWSTR)MALLOC( INITIAL_PATHSTRING_BUFFER_SIZE );
    _PathString2 = (LPWSTR)MALLOC( INITIAL_PATHSTRING_BUFFER_SIZE );

    _PathString1Size = _PathString2Size = INITIAL_PATHSTRING_BUFFER_SIZE;

    _Keyboard = NEW KEYBOARD;

    if ( !_PathString1 || !_PathString2 || !_Keyboard ) {
            DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
    }

    //
    //      initialize the keyboard and set ctrl-c handling
    //
    _Keyboard->Initialize();
    _Keyboard->EnableBreakHandling();

    //
    //      Initialize our data
    //
    _SourcePath             =       NULL;
    _DestinationPath        =       NULL;
    _FilesAdded             =       0;
    _FilesReplaced          =       0;
    _SourceDirectory        =       NULL;
    _Pattern                        =       NULL;
    _FilesInSrc             =       NULL;

    _AddSwitch = FALSE;   // use by DisplayMessageAndExit before any
                          // of those boolean _*Switch is being initialized

}

VOID
REPLACE::DeallocateThings (
        )

/*++

Routine Description:

        Deallocates the stuff that was initialized in InitializeThings()

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

    DELETE( _FilesInSrc );
    DELETE( _SourceDirectory );
    DELETE( _Pattern );
    DELETE( _Keyboard );

    FREE( _PathString1 );
    FREE( _PathString2 );

}

BOOLEAN
REPLACE::DoReplace (
        )

/*++

Routine Description:

        This is the function that performs the Replace.

Arguments:

    None.

Return Value:

        TRUE

Notes:

--*/

{

    PFSN_DIRECTORY  DestinationDirectory;
    FSN_FILTER              Filter;
    WCHAR                   Char;

    //
    //      Get the source directory object and the pattern that we will use
    //      for file matching.
    //
    GetDirectoryAndPattern( _SourcePath, &_SourceDirectory, &_Pattern );

    DebugPtrAssert( _SourceDirectory );
    DebugPtrAssert( _Pattern );

    //
    //      Get the destination directory
    //
    GetDirectory( _DestinationPath, &DestinationDirectory );

    DebugPtrAssert( DestinationDirectory );

    //
    //      Wait if requested
    //
    if ( _WaitSwitch ) {

            DisplayMessage( REPLACE_MESSAGE_PRESS_ANY_KEY );
            AbortIfCtrlC();

            //
            //      All input is in raw mode.
            //
            _Keyboard->DisableLineMode();
            GetStandardInput()->ReadChar( &Char );
            _Keyboard->EnableLineMode();

            GetStandardOutput()->WriteChar( Char );
            GetStandardOutput()->WriteChar( (WCHAR)'\r');
            GetStandardOutput()->WriteChar( (WCHAR)'\n');

            //
            //      Check for ctrl-c
            //
            if ( Char == CTRL_C ) {
                    exit ( EXIT_PATH_NOT_FOUND );
            }
    }

    //
    //      Get an array containing all the files in the source directory
    //      that match the pattern.
    //
    //      This is so that Replacer() does not have to get the same
    //      information over and over when the Subdir switch is set.
    //
    _FilesInSrc = GetFileArray( _SourceDirectory, _Pattern );
    DebugPtrAssert( _FilesInSrc );

    if ( _SubdirSwitch ) {

            //
            //      First, replace the files in the directory specified
            //
            Replacer( this, DestinationDirectory, NULL );

            Filter.Initialize();
            Filter.SetAttributes( (FSN_ATTRIBUTE)FILE_ATTRIBUTE_DIRECTORY );

            //
            //      Now traverse the destination directory, calling the
            //      replacer function for each subdirectory.
            //
            DestinationDirectory->Traverse( this,
                                                                            &Filter,
                                                                            NULL,
                                                                            REPLACE::Replacer );
    } else {

            //
            //      Call the replace function, which takes care of replacements
            //
            Replacer(this,  DestinationDirectory, NULL );
    }
    DELETE( DestinationDirectory );

    return TRUE;

}

VOID
REPLACE::GetDirectoryAndPattern(
   IN    PPATH       Path,
   OUT   PFSN_DIRECTORY *Directory,
    OUT     PWSTRING        *Pattern
   )

/*++

Routine Description:

        Given a path, this function obtains a directory object and a pattern.

        Normally, the pattern is the filename portion of the path, but if the
        entire path refers to a directory, then the pattern is "*.*"

Arguments:

        Path            -       Supplies pointer to path
        Directory       -       Supplies pointer to pointer to directory
        Pattern         -       Supplies pointer to pointer to pattern

Return Value:

        TRUE

Notes:

--*/

{
    PATH           TmpPath;
    PWSTRING            Name;
    PFSN_DIRECTORY    Dir;
    PWSTRING            Ptrn;

    DebugAssert( Path );
    DebugAssert( Directory );
    DebugAssert( Pattern );

    //
    // If the name passed is a directory, it is an error.
    // Otherwise, split the path into Directory and Pattern
    // portions.
    //
    Dir = SYSTEM::QueryDirectory( Path );

    if ( Dir ||
         (Name = Path->QueryName()) == NULL ||
         (Ptrn = Name->QueryString()) == NULL ) {

        DisplayMessageAndExit( REPLACE_ERROR_NO_FILES_FOUND,
                               Path->GetPathString(),
                               EXIT_FILE_NOT_FOUND );

    } else {

        // We're finished with Name.
        //
        DELETE( Name );

        //
        // Get the directory
        //
        TmpPath.Initialize( Path, TRUE );
        TmpPath.TruncateBase();

        Dir = SYSTEM::QueryDirectory( &TmpPath );

        if ( !Dir ) {

            DisplayMessageAndExit( REPLACE_ERROR_PATH_NOT_FOUND,
                                   Path->GetPathString(),
                                   EXIT_PATH_NOT_FOUND );
        }

        *Directory = Dir;
        *Pattern   = Ptrn;
    }
}

VOID
REPLACE::GetDirectory(
        IN              PCPATH                  Path,
        OUT     PFSN_DIRECTORY  *Directory
        )

/*++

Routine Description:

        Makes a directory out of a path.

Arguments:

        Path            -       Supplies pointer to path
        Directory       -       Supplies pointer to pointer to directory

Return Value:

        TRUE

Notes:

--*/

{
    PFSN_DIRECTORY  Dir;


    if ( !(Dir = SYSTEM::QueryDirectory( Path )) ) {

            DisplayMessageAndExit( REPLACE_ERROR_PATH_NOT_FOUND,
                                                       Path->GetPathString(),
                                                       EXIT_PATH_NOT_FOUND );
    }

    *Directory = Dir;

}

PARRAY
REPLACE::GetFileArray(
   IN    PFSN_DIRECTORY Directory,
    IN      PWSTRING        Pattern
   )

/*++

Routine Description:

        Gets an array of those files in a directory matching a pattern.

Arguments:

        Directory       -       Supplies pointer to directory
        Pattern         -       Supplies pointer to pattern

Return Value:

        Pointer to the array of files

Notes:

--*/
{

    PARRAY          Array;
    FSN_FILTER      Filter;

    DebugPtrAssert( Directory );
    DebugPtrAssert( Pattern );

    Filter.Initialize();
    Filter.SetFileName( Pattern );
    Filter.SetAttributes( (FSN_ATTRIBUTE)0, (FSN_ATTRIBUTE)0, (FSN_ATTRIBUTE)FILE_ATTRIBUTE_DIRECTORY );

    Array = Directory->QueryFsnodeArray( &Filter );

    DebugPtrAssert( Array );

    return Array;

}

BOOLEAN
REPLACE::Replacer (
        IN              PVOID           This,
        IN OUT  PFSNODE         DirectoryNode,
        IN              PPATH           DummyPath
        )
/*++

Routine Description:

        This is the heart of Replace. Given a destination directory, it
        performs the replacement/additions according to the global switches
        and the SourceDirectory and Pattern.

Arguments:

        This                    -       Supplies pointer to the REPLACE object
        Node                    -       Supplies pointer to the directory node.
        DummyPath               -       Required by FSN_DIRECTORY::Traverse(), must be
                                                NULL.

Return Value:

        BOOLEAN -       TRUE if operation successful.
                                FALSE otherwise

Notes:

--*/

{

    DebugAssert( DummyPath == NULL );
    DebugAssert( DirectoryNode->IsDirectory() );

    ((PREPLACE)This)->AbortIfCtrlC();

    if ( ((PREPLACE)This)->_AddSwitch ) {
        return ((PREPLACE)This)->AddFiles( (PFSN_DIRECTORY)DirectoryNode );
    } else {
        return ((PREPLACE)This)->ReplaceFiles( (PFSN_DIRECTORY)DirectoryNode );
    }
}

BOOLEAN
REPLACE::AddFiles (
        IN OUT  PFSN_DIRECTORY  DestinationDirectory
        )
/*++

Routine Description:

        Adds those      files from the SourceDirectory that match Pattern to the
        DestinationDirectory. The array of files is already in the
        FilesInSrc array.

Arguments:

        DestinationDirectory    -       Supplies pointer to destination
                                                                directory.

Return Value:

        BOOLEAN -       TRUE if operation successful.
                                FALSE otherwise

Notes:

--*/

{

    PARRAY_ITERATOR   Iterator;
    PFSN_FILE         File;
    PFSN_FILE         FileToCreate;
    PATH              DestinationPath;
    PWSTRING          Name;

    DebugPtrAssert( DestinationDirectory );
    DebugPtrAssert( _FilesInSrc );

    //
    //      Get destination path
    //
    DestinationPath.Initialize( DestinationDirectory->GetPath() );

    //
    //      Obtain an iterator for going thru the files
    //
    Iterator = ( PARRAY_ITERATOR )_FilesInSrc->QueryIterator( );
    if (Iterator == NULL) {
        DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
        return FALSE;       // help lint
    }

    //
    //      For each file in the array, see if it exists in the destination
    //      directory, and if it does not, then copy it.
    //
    while ( File =  (PFSN_FILE)Iterator->GetNext() ) {

        DebugAssert( !(((PFSNODE)File)->IsDirectory()) );

        Name = File->QueryName();
        if (Name == NULL) {
            DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
            return FALSE;       // help lint
        }

        //
        //      Form the path in the target file
        //
        DestinationPath.AppendBase( Name );

        DELETE( Name );

        //
        //      See if the file exists
        //
        FileToCreate = SYSTEM::QueryFile( &DestinationPath );

        //
        //      If the file does not exist, then it has to be added
        //
        if ( !FileToCreate ) {

            if ( !_PromptSwitch || Prompt( REPLACE_MESSAGE_ADD_YES_NO, &DestinationPath ) ) {

                DisplayMessage( REPLACE_MESSAGE_ADDING, NORMAL_MESSAGE, "%W", DestinationPath.GetPathString() );

                CopyTheFile( File->GetPath(), &DestinationPath );

                _FilesAdded++;
            }

        }

        DELETE( FileToCreate );

        //
        //      Set the destination path back to what it originally was
        //      ( i.e. directory specification, no file ).
        //
        DestinationPath.TruncateBase();

    }
    DELETE( Iterator );

    return TRUE;
}

BOOLEAN
REPLACE::ReplaceFiles (
        IN OUT  PFSN_DIRECTORY  DestinationDirectory
        )
/*++

Routine Description:

        Replaces those files in the DestinationDirectory that match Pattern
        by the corresponding files in SourceDirectory.

Arguments:

        DestinationDirectory    -       Supplies pointer to destination
                                                                directory.

Return Value:

        BOOLEAN -       TRUE if operation successful.
                        FALSE otherwise

Notes:

--*/

{

    PARRAY_ITERATOR     Iterator;
    PFSN_FILE           File;
    PFSN_FILE           FileToReplace;
    PATH                DestinationPath;
    PWSTRING            Name;
    PTIMEINFO           TimeSrc;
    PTIMEINFO           TimeDst;
    BOOLEAN             Proceed = TRUE;

    DebugPtrAssert( DestinationDirectory );
    DebugPtrAssert( _FilesInSrc );

    //
    //      Get destination path
    //
    DestinationPath.Initialize( DestinationDirectory->GetPath() );

    //
    //      Obtain an iterator for going thru the files
    //
    Iterator = ( PARRAY_ITERATOR )_FilesInSrc->QueryIterator( );
    if (Iterator == NULL) {
        DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
        return FALSE;       // help lint
    }

    //
    //      For each file in the array, see if it exists in the destination
    //      directory, and if it does, replace it
    //
    while ( File =  (PFSN_FILE)Iterator->GetNext() ) {

        AbortIfCtrlC();

        DebugAssert( !(((PFSNODE)File)->IsDirectory()) );

        Name = File->QueryName();
        if (Name == NULL) {
            DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
            return FALSE;       // help lint
        }

        //
        //      Form the path in the target file
        //
        DestinationPath.AppendBase( Name );

        DELETE( Name );

        //
        //      See if the file exists
        //
        FileToReplace = SYSTEM::QueryFile( &DestinationPath );


        if ( FileToReplace ) {

            //
            //      If the CompareTime switch is set, then we only proceed if
            //      the destination file is older than the source file.
            //
            if ( _CompareTimeSwitch ) {

                TimeSrc = File->QueryTimeInfo();
                TimeDst = FileToReplace->QueryTimeInfo();

                if (TimeSrc == NULL) {
                    DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
                    return FALSE;       // help lint
                }
                if (TimeDst == NULL) {
                    DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );
                    return FALSE;       // help lint
                }

                Proceed = *TimeDst < *TimeSrc;

                DELETE( TimeSrc );
                DELETE( TimeDst );

            }

            if ( Proceed ) {

                //
                //      We replace the file if it is NOT read-only
                //      (unless the ReadOnly switch is set )
                //
                if ( _ReadOnlySwitch || !(FileToReplace->IsReadOnly()) ) {

                    if ( !_PromptSwitch || Prompt( REPLACE_MESSAGE_REPLACE_YES_NO, &DestinationPath ) ) {

                        DisplayMessage( REPLACE_MESSAGE_REPLACING, NORMAL_MESSAGE, "%W", DestinationPath.GetPathString() );

                        //
                        //      If the file is read-only, we reset the read-only attribute
                        //      before copying.
                        //
                        if ( FileToReplace->IsReadOnly() ) {
                            FileToReplace->ResetReadOnlyAttribute();
                        }

                        CopyTheFile( File->GetPath(), &DestinationPath );

                        _FilesReplaced++;
                    }
                } else {

                    //
                    //      The file is read-only but the ReadOnly flag was
                    //      not set, we error out.
                    //
                    DisplayMessageAndExit( REPLACE_ERROR_ACCESS_DENIED,
                                           DestinationPath.GetPathString(),
                                           EXIT_ACCESS_DENIED );
                }
            }
        }

        DELETE( FileToReplace );

        //
        //      Set the destination path back to what it originally was
        //      ( i.e. directory specification, no file name part ).
        //
        DestinationPath.TruncateBase();

    }

    DELETE( Iterator );

    return TRUE;
}

BOOLEAN
REPLACE::Prompt (
        IN      MSGID           MessageId,
        IN      PCPATH          Path
        )

/*++

Routine Description:

        Gets confirmation from the user about a file to be added/replaced

Arguments:

        MessageId       -       Supplies the Id of the message to use for prompting
        Path            -       Supplies path to use as parameter for the message.

Return Value:

        BOOLEAN -       TRUE if the user confirmed the add/replace
                                FALSE otherwise

--*/

{

    DisplayMessage( MessageId, NORMAL_MESSAGE, "%W", Path->GetPathString() );
    return _Message.IsYesResponse();

}

BOOLEAN
REPLACE::CopyTheFile (
        IN      PCPATH          SrcPath,
        IN      PCPATH          DstPath
        )

/*++

Routine Description:

        Copies a file

Arguments:

        SrcPath         -       Supplies path of source file
        DstFile         -       Supplies path of destination file

Return Value:

        BOOLEAN -       TRUE

--*/

{

    ULONG   Size;

    DebugPtrAssert( SrcPath );
    DebugPtrAssert( DstPath );

    //
    //      Make sure that the buffers are big enough to hold the
    //      paths
    //
    Size = (SrcPath->GetPathString()->QueryChCount() + 1) * 2;
    if ( Size > _PathString1Size ) {
    _PathString1 = (LPWSTR)REALLOC( _PathString1, (unsigned int)Size );
            DebugPtrAssert( _PathString1 );
            _PathString1Size = Size;
    }

    Size = (DstPath->GetPathString()->QueryChCount() + 1) * 2;
    if ( Size > _PathString2Size ) {
    _PathString2 = (LPWSTR)REALLOC( _PathString2, (unsigned int)Size );
            DebugPtrAssert( _PathString2 );
            _PathString2Size = Size;
    }

    if ( !_PathString1 || !_PathString2 ) {
            DisplayMessageAndExit( REPLACE_ERROR_NO_MEMORY, NULL, EXIT_NO_MEMORY );

    }

    //
    //  Convert the paths to LPWSTR so that we can call CopyFile()
    //
    SrcPath->GetPathString()->QueryWSTR( 0, TO_END, _PathString1, _PathString1Size/sizeof(WCHAR) );
    DstPath->GetPathString()->QueryWSTR( 0, TO_END, _PathString2, _PathString2Size/sizeof(WCHAR) );

    //
    //      Now do the copy
    //
    if ( !CopyFile( _PathString1, _PathString2, FALSE ) ) {

            ExitWithError( GetLastError() );

    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\runas\cred_pch.h ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// precomp.hpp
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <commctrl.h>
#define _CREDUI_
#include <wincred.h>
#include <lmcons.h>
#include <netlib.h>

#define CreduiDebugLog

//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------

struct CREDUI_STRINGS
{
    WCHAR UserNameTipTitle[32];
    WCHAR UserNameTipText[256];
    WCHAR CapsLockTipTitle[32];
    WCHAR CapsLockTipText[256];
    WCHAR LogonTipTitle[32];
    WCHAR LogonTipText[256];
    WCHAR LogonTipCaps[256];
    WCHAR DnsCaption[64];
    WCHAR NetbiosCaption[64];
    WCHAR GenericCaption[64];
    WCHAR Welcome[64];
    WCHAR WelcomeBack[64];
    WCHAR Connecting[64];
    WCHAR PasswordStatic[32];
    WCHAR PinStatic[32];
    WCHAR UserNameStatic[32];
    WCHAR CertificateStatic[32];
    WCHAR Certificate[32];
    WCHAR LookupName[64];
    WCHAR EmptyReader[64];
    WCHAR UnknownCard[64];
    WCHAR BackwardsCard[64];
    WCHAR EmptyCard[64];
    WCHAR ReadingCard[64];
    WCHAR CardError[64];
    WCHAR BackwardsTipTitle[32];
    WCHAR BackwardsTipText[128];
    WCHAR SmartCardStatic[32];
    WCHAR WrongOldTipTitle[32];
    WCHAR WrongOldTipText[256];
    WCHAR NotSameTipTitle[32];
    WCHAR NotSameTipText[256];
    WCHAR TooShortTipTitle[32];
    WCHAR TooShortTipText[256];
    WCHAR Save[64];
    WCHAR Prompt[64];
};

// Private window message:

enum
{
    CREDUI_WM_APP_LOOKUP_COMPLETE   = WM_APP + 0,
    CREDUI_WM_APP_VIEW_COMPLETE     = WM_APP + 1
};

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

extern HMODULE CreduiInstance;
extern ULONG CreduiComReferenceCount;

extern BOOL CreduiIsPersonal;
extern BOOL CreduiIsSafeMode;

extern CREDUI_STRINGS CreduiStrings;

extern UINT CreduiScarduiWmReaderArrival;
extern UINT CreduiScarduiWmReaderRemoval;
extern UINT CreduiScarduiWmCardInsertion;
extern UINT CreduiScarduiWmCardRemoval;
extern UINT CreduiScarduiWmCardCertAvail;
extern UINT CreduiScarduiWmCardStatus;

extern BOOL CreduiHasSmartCardSupport;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\runas\dbgdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbgdef.h
//
//  Contents:   Defines for debug exports in crypt32 (crypt32d.lib)
//
//  History:    17-Apr-96   kevinr   created
//              05-Sep-1997 pberkman added subsystem id's
//
//--------------------------------------------------------------------------

#ifndef DBGDEF_H
#define DBGDEF_H

#ifndef _XELIBCA_SRC_
#ifdef __cplusplus
    extern "C" 
    {
#endif
#endif


#if (DBG)

    //--------------------------------------------------------------------------
    // OSS and heap-checking
    //--------------------------------------------------------------------------
#   include <crtdbg.h>

    // To turn on heap checking (the whole nine yards) (slow):
    // set DEBUG_MASK=0x26
    // To only check for leaks:
    // set DEBUG_MASK=0x20

#   ifndef NO_OSS_DEBUG

#       include <asn1code.h>

        // To turn on OSS tracing (all encodes and decodes):
        // set OSS_DEBUG_MASK=0x02
        //
        // To turn on OSS tracing of only decoder errors
        // set OSS_DEBUG_MASK=0x10
        //
        // To send the OSS tracing output to a file:
        // set OSS_DEBUG_TRACEFILE=<filename>

        extern BOOL WINAPI DbgInitOSS( OssGlobal *pog);

#   endif  // NO_OSS_DEBUG

#endif  // DBG


//
//  05-Sep-1997 pberkman:
//
//      DEBUG_PRINT_MASK settings to turn on sub-system debugs
//
#define DBG_SS_CRYPT32                      0x00000001

#define DBG_SS_TRUSTCOMMON                  0x00010000
#define DBG_SS_TRUST                        0x00020000
#define DBG_SS_TRUSTPROV                    0x00040000
#define DBG_SS_SIP                          0x00080000
#define DBG_SS_CATALOG                      0x00100000
#define DBG_SS_SIGNING                      0x00200000
#define DBG_SS_OFFSIGN                      0x00400000
#define DBG_SS_CATDBSVC                     0x00800000

#define DBG_SS_APP                          0x10000000

typedef struct _DBG_SS_TAG
{
    DWORD       dwSS;
    const char  *pszTag;    // 7 characters!

} DBG_SS_TAG;

#define __DBG_SS_TAGS       { \
                                DBG_SS_CRYPT32,     "CRYPT32",  \
                                DBG_SS_TRUSTCOMMON, "PKITRST",  \
                                DBG_SS_TRUST,       "WINTRST",  \
                                DBG_SS_TRUSTPROV,   "SOFTPUB",  \
                                DBG_SS_CATALOG,     "MSCAT32",  \
                                DBG_SS_SIP,         "MSSIP32",  \
                                DBG_SS_SIGNING,     "MSSGN32",  \
                                DBG_SS_OFFSIGN,     "OFFSIGN",  \
                                DBG_SS_APP,         "CONAPPL",  \
                                DBG_SS_CATDBSVC,    "CATDBSV",  \
                                NULL, NULL                      \
                            }

//--------------------------------------------------------------------------
// DBG_TRACE 
//--------------------------------------------------------------------------
#if DBG 

	void DbgPrintf( DWORD dwSubSysId, LPCSTR lpFmt, ...);


#   define DBG_TRACE_EX(argFmt) DbgPrintf argFmt
#   define DBG_TRACE(argFmt)   DBG_TRACE_EX((DBG_SS_CRYPT32,argFmt))

#   define DBG_PRINTF(args)     DbgPrintf args

#else

#   define DBG_TRACE_EX(argFmt)
#   define DBG_TRACE(argFmt)

#   define DBG_PRINTF(args)

#endif  // DBG


//--------------------------------------------------------------------------
// Error-handling 
//--------------------------------------------------------------------------
#ifndef ERROR_RETURN_LABEL
#define ERROR_RETURN_LABEL ErrorReturn
#endif

#define TRACE_ERROR_EX(id,name)                                         \
name##:                                                                 \
    DBG_TRACE_EX((id,"(" #name ":%s,%d)\n", __FILE__, __LINE__));       \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_EX(id,name,err)                                       \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_VAR_EX(id,name,err)                                   \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError(0x%x)\n", __FILE__, __LINE__, (err))); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_VAR_EX(id,name,err)                                 \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n" , __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_HRESULT_EX(id,name)                                       \
name##:                                                                 \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n", __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define SET_DWRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    dwResult = (DWORD) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define TRACE_ERROR(name)               TRACE_ERROR_EX(DBG_SS_CRYPT32,name)
#define SET_ERROR(name,err)             SET_ERROR_EX(DBG_SS_CRYPT32,name,err)
#define SET_ERROR_VAR(name,err)         SET_ERROR_VAR_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT(name,err)           SET_HRESULT_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT_VAR(name,err)       SET_HRESULT_VAR_EX(DBG_SS_CRYPT32,name,err)
#define TRACE_HRESULT(name)             TRACE_HRESULT_EX(DBG_SS_CRYPT32,name)
#define SET_DWRESULT(name,err)          SET_DWRESULT_EX(DBG_SS_CRYPT32,name,err)


#define _JumpCondition(condition, label) \
    if (condition) \
    { \
	goto label; \
    } \
    else { } 

#define _JumpConditionWithExpr(condition, label, expr) \
    if (condition) \
    { \
        expr; \
	goto label; \
    } \
    else { } 

#define _JumpConditionWithPrint(condition, label, ids) \
    if (condition) \
    { \
        LocalizedWPrintf(ids); \
	goto label; \
    } \
    else { } 


#ifndef _XELIBCA_SRC_
#ifdef __cplusplus
    }       // balance of extern "C"
#endif
#endif

#endif // DBGDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\runas\runas.cpp ===
/*+
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1997 - 2000.
 *
 * Name : runas.cxx
 * Author:Jeffrey Richter (v-jeffrr)
 *
 * Abstract:
 * This is the RUNAS tool. It uses CreateProcessWithLogon API
 * to start processes under different security context than the
 * currently logged on user.
 *
 * Revision History:
 * PraeritG    10/8/97  To integrate this in to services.exe
 *
-*/

#define STRICT
#define UNICODE   1
#include <Windows.h>
#include <shellapi.h>
#include <stdarg.h>
#include <stdio.h>
#include <winsafer.h>
#include <wincred.h>
#include <lmcons.h>
#include <netlib.h>
#include <strsafe.h>

#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif

#include <security.h>

#include "dbgdef.h"
#include "stringid.h"
#include "rmtcred.h"
#include "utils.h"
#include "RunasMsg.h"

// Helper macros:
#define ARRAYSIZE(a)       ((sizeof(a))/(sizeof(a[0])))
#define FIELDOFFSET(s,m)   (size_t)&(((s *)0)->m)

#define PSAD_NULL_DATA     (-1)
#define PSAD_STRING_DATA   (-2)
#define PSAD_NO_MORE_DATA  (-1)

//
// must move to winbase.h soon!
#define LOGON_WITH_PROFILE              0x00000001
#define LOGON_NETCREDENTIALS_ONLY       0x00000002

// NT Process exit codes:
#define EXIT_CODE_SUCCEEDED 0
#define EXIT_CODE_FAILED    1

// Credential flags:
#define RUNAS_USE_SMARTCARD  0x00000001
#define RUNAS_USE_SAVEDCREDS 0x00000002
#define RUNAS_SAVE_CREDS     0x00000004

// Argument IDs for command line parsing:
enum ArgId {
    AI_ENV = 0,
    AI_NETONLY,
    AI_NOPROFILE,
    AI_PROFILE,
    AI_TRUSTLEVEL,
    AI_USER,
    AI_SMARTCARD,
    AI_SHOWTRUSTLEVELS,
    AI_SAVECRED
} ArgId;

BOOL rgArgCompat[9][9] =
{
    // ENV     NETONLY   NOPROFILE   PROFILE   TRUSTLEVEL   USER    SMARTCARD  SHOWTRUSTLEVELS  SAVECRED
    {  FALSE,  TRUE,     TRUE,       TRUE,     FALSE,       TRUE,   TRUE,      FALSE,           TRUE },   // ENV
    {  TRUE,   FALSE,    TRUE,       FALSE,    FALSE,       TRUE,   FALSE,     FALSE,           FALSE },  // NETONLY
    {  TRUE,   TRUE,     FALSE,      FALSE,    FALSE,       TRUE,   TRUE,      FALSE,           TRUE },   // NOPROFILE
    {  TRUE,   FALSE,    FALSE,      FALSE,    FALSE,       TRUE,   TRUE,      FALSE,           TRUE  },  // PROFILE
    {  FALSE,  FALSE,    FALSE,      FALSE,    FALSE,       FALSE,  FALSE,     FALSE,           FALSE },  // TRUSTLEVEL
    {  TRUE,   TRUE,     TRUE,       TRUE,     FALSE,       FALSE,  TRUE,      FALSE,           TRUE },   // USER
    {  TRUE,   FALSE,    TRUE,       TRUE,     FALSE,       TRUE,   FALSE,     FALSE,           FALSE },   // SMARTCARD
    {  FALSE,  FALSE,    FALSE,      FALSE,    FALSE,       FALSE,  FALSE,     FALSE,           FALSE },  // SHOWTRUSTLEVELS
    {  TRUE,   FALSE,    TRUE,       TRUE,     FALSE,       TRUE,   FALSE,     FALSE,           FALSE }   // SAVECRED
};

#define _CheckArgCompat(args, n, ai) \
    { \
        for (int _i = 0; _i < (n); _i++) { \
            if (FALSE == rgArgCompat[(ai)][(args)[_i]]) { \
                RunasPrintHelp(); \
                return (EXIT_CODE_FAILED); \
            } \
        } \
        (args)[(n)] = (ai); \
    }

HMODULE   hMod       = NULL;
HANDLE    g_hStdout  = NULL;

void DbgPrintf( DWORD /*dwSubSysId*/, LPCSTR /*pszFormat*/ , ...)
{
/* We're not currently using the DbgPrintf functionality, and it's breaking compiles with /W4
   va_list args;
   CHAR    pszBuffer[1024];
   
   va_start(args, pszFormat);
   _vsnprintf(pszBuffer, 1024, pszFormat, args);
   va_end(args);
   
   OutputDebugStringA(pszBuffer); 
*/
}

typedef BOOLEAN (WINAPI * SetThreadUILanguageFunc)(DWORD dwReserved);
SetThreadUILanguageFunc   g_pfnSetThreadUILanguage  = NULL; 

HRESULT MySetThreadUILanguage(DWORD dwParam)
{
    HMODULE  hKernel32Dll  = NULL;
    HRESULT  hr; 

    if (NULL == g_pfnSetThreadUILanguage) { 
	// We've got the correct system directory now. 
	hKernel32Dll = LoadLibraryW(L"kernel32.dll"); 
	if (NULL == hKernel32Dll) { 
	    hr = HRESULT_FROM_WIN32(GetLastError()); 
	    goto error; 
	}

	g_pfnSetThreadUILanguage = (SetThreadUILanguageFunc)GetProcAddress(hKernel32Dll, "SetThreadUILanguage");
	if (NULL == g_pfnSetThreadUILanguage) { 
	    hr = HRESULT_FROM_WIN32(GetLastError()); 
	    goto error; 
	}
    }

    g_pfnSetThreadUILanguage(dwParam);
    
    hr = S_OK; 
 error:
    if (NULL != hKernel32Dll) { 
	FreeLibrary(hKernel32Dll); 
    }
    return hr; 
}

HRESULT InitializeConsoleOutput() {
    g_hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    if (INVALID_HANDLE_VALUE == g_hStdout) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

HRESULT LocalizedWPrintf(UINT nResourceID) {
    DWORD   ccWritten;
    DWORD   dwRetval;
    WCHAR   rgwszString[512];

    dwRetval = LoadStringW(hMod, nResourceID, rgwszString, ARRAYSIZE(rgwszString));
    if (0 == dwRetval) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!WriteConsoleW(g_hStdout, rgwszString, (DWORD)wcslen(rgwszString), &ccWritten, NULL)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

DWORD MyGetLastError() { 
    DWORD dwResult = GetLastError(); 

    if (ERROR_SUCCESS == dwResult) { 
        dwResult = (DWORD)E_FAIL; 
    }

    return dwResult; 
}

VOID
DisplayMsg(DWORD dwSource, DWORD dwMsgId, ... )
{
    DWORD    dwBytesWritten;
    DWORD    dwLen;
    LPWSTR   pwszDisplayBuffer  = NULL;
    va_list  ap;

    va_start(ap, dwMsgId);

    dwLen = FormatMessageW(dwSource | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           NULL, 
                           dwMsgId, 
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPWSTR)&pwszDisplayBuffer, 
                           0, 
                           &ap);

    if (dwLen && pwszDisplayBuffer) {
        WriteConsoleW(g_hStdout, 
                      (LPVOID)pwszDisplayBuffer, 
                      dwLen,
                      &dwBytesWritten, 
                      NULL);
    }

    if (NULL != pwszDisplayBuffer) { LocalFree(pwszDisplayBuffer); }

    va_end(ap);
}

BOOL WriteMsg(DWORD dwSource, DWORD dwMsgId, LPWSTR *ppMsg, ...)
{
    DWORD    dwLen;
    va_list  ap;

    va_start(ap, ppMsg);

    dwLen = FormatMessageW(dwSource | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           NULL, 
                           dwMsgId, 
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPWSTR)ppMsg, 
                           0, 
                           &ap);
    va_end(ap);

    // 0 is the error return value of FormatMessage.  
    return (0 != dwLen);
}

DWORD GetCredentials
(IN      DWORD  dwCredFlags,
 IN OUT  LPWSTR pwszPassword,
 IN      DWORD  ccPasswordChars,
 IN OUT  LPWSTR pwszUserName,
 IN      DWORD  ccUserNameChars,
 IN OUT  LPWSTR pwszUserDisplayName,
 IN      DWORD  ccUserDisplayNameChars,
 IN OUT  LPWSTR pwszTarget,
 IN      DWORD  ccTarget)
{
    BOOL     fResult;
    DWORD    dwCreduiCmdlineFlags   = 0;
    DWORD    dwResult;
    HRESULT  hr; 
    LPWSTR   pwszAccountDomainName  = NULL;
    LPWSTR   pwszMarshalledCred     = NULL;

    if (RUNAS_USE_SAVEDCREDS & dwCredFlags) {
	if (NULL == wcschr(pwszUserName, L'\\') && NULL == wcschr(pwszUserName, L'@')) { 
	    WCHAR wszUserNameTmp[CREDUI_MAX_USERNAME_LENGTH+1]; 
	    memset(&wszUserNameTmp[0], 0, sizeof(wszUserNameTmp)); 

	    // We have a username in relative form.  Try to prepend the machine name (for workstations) or domain name (for DCs). 
	    // We'll need to use a temporary buffer, because the safe string functions don't have an equivalent for memmove(). 
	    pwszAccountDomainName = GetAccountDomainName(); 
	    _JumpCondition(NULL == pwszAccountDomainName, GetAccountDomainNameError); 
	
	    // 1) Copy the relative username to a temporary buffer: 
	    hr = StringCchCopy(wszUserNameTmp, ARRAYSIZE(wszUserNameTmp), pwszUserName); 
	    _JumpCondition(FAILED(hr), StringCchCopyError); 

	    // 2) Copy the domain name into the username buffer
	    hr = StringCchCopy(pwszUserName, ccUserNameChars, pwszAccountDomainName); 
	    _JumpCondition(FAILED(hr), StringCchCopyError); 
	    
	    // 3) Concatenate the \username
	    hr = StringCchCat(pwszUserName, ccUserNameChars, L"\\"); 
	    _JumpCondition(FAILED(hr), StringCchCatError); 

	    hr = StringCchCat(pwszUserName, ccUserNameChars, wszUserNameTmp); 
	    _JumpCondition(FAILED(hr), StringCchCatError); 
	}

        USERNAME_TARGET_CREDENTIAL_INFO utci = { pwszUserName };

        // Get the marshalled credential from credman.
        fResult = CredMarshalCredentialW(UsernameTargetCredential, &utci, &pwszMarshalledCred);
        _JumpCondition(FALSE == fResult, CredMarshalCredentialWError);

        // User the user-supplied name as the display name.
        hr = StringCchCopy(pwszUserDisplayName, ccUserDisplayNameChars, pwszUserName);
	_JumpCondition(FAILED(hr), StringCchCopyError); 

        // Copy the marshalled cred to the user name.  We use an empty
        // passwd with the marshalled cred.
        hr = StringCchCopy(pwszUserName, ccUserNameChars, pwszMarshalledCred);
	_JumpCondition(FAILED(hr), StringCchCopyError); 
    }
    else {
        dwCreduiCmdlineFlags =
            CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS // These are 'runas' credentials
            | CREDUI_FLAGS_VALIDATE_USERNAME;   // Ensure that the username syntax is correct

        if (RUNAS_USE_SMARTCARD & dwCredFlags) {
            dwCreduiCmdlineFlags |= CREDUI_FLAGS_REQUIRE_SMARTCARD;

            fResult = LoadStringW(hMod, RUNASP_STRING_SMARTCARDUSER, pwszTarget, ccTarget);
            _JumpCondition(FALSE == fResult, LoadStringError);
        }
        else {
            dwCreduiCmdlineFlags |= CREDUI_FLAGS_EXCLUDE_CERTIFICATES; // we don't (yet) know how to handle certificates
            hr = StringCchCopy(pwszTarget, ccTarget, pwszUserName);
	    _JumpCondition(FAILED(hr), StringCchCopyError); 
        }

        if (RUNAS_SAVE_CREDS & dwCredFlags) {
            dwCreduiCmdlineFlags |=
                CREDUI_FLAGS_PERSIST                 // persist creds automatically
                | CREDUI_FLAGS_EXPECT_CONFIRMATION;  // Don't store bogus creds into credman.
        } else {
            dwCreduiCmdlineFlags |=
                CREDUI_FLAGS_DO_NOT_PERSIST;    // Do not persist the creds
        }

        dwResult = CredUICmdLinePromptForCredentialsW
            (pwszTarget,
             NULL,
             NO_ERROR,
             pwszUserName,
             ccUserNameChars,
             pwszPassword,
             ccPasswordChars,
             NULL,
             dwCreduiCmdlineFlags);
        _JumpCondition(ERROR_SUCCESS != dwResult, CredUICmdLineGetPasswordError);

        if (RUNAS_USE_SMARTCARD & dwCredFlags) {
            // Smartcard creds are not human-readable.  Get a display name:
            fResult = CreduiGetCertDisplayNameFromMarshaledName
                (pwszUserName,
                 pwszUserDisplayName,
                 ccUserDisplayNameChars,
                 FALSE);
            _JumpCondition(FALSE == fResult, CreduiGetCertDisplayNameFromMarshaledNameError);
        }
        else {
            hr = StringCchCopy(pwszUserDisplayName, ccUserDisplayNameChars, pwszUserName);
	    _JumpCondition(FAILED(hr), StringCchCopyError); 
        }
    }

    dwResult = ERROR_SUCCESS;
 ErrorReturn:
    if (NULL != pwszAccountDomainName) { NetApiBufferFree(pwszAccountDomainName); }
    return dwResult;


SET_DWRESULT(CredMarshalCredentialWError,                     GetLastError());
SET_DWRESULT(CredUICmdLineGetPasswordError,                   dwResult);
SET_DWRESULT(CreduiGetCertDisplayNameFromMarshaledNameError,  GetLastError());
SET_DWRESULT(GetAccountDomainNameError,                       GetLastError());
SET_DWRESULT(LoadStringError,                                 GetLastError());
SET_DWRESULT(StringCchCatError,                               (DWORD)hr); 
SET_DWRESULT(StringCchCopyError,                              (DWORD)hr); 
}

DWORD SaveCredentials
(IN  LPWSTR pwszTarget,
 IN  BOOL   fSave)
{
    return CredUIConfirmCredentialsW(pwszTarget, fSave);
}

BOOL GetTitle
(IN   LPWSTR  pwszAppName,
 IN   LPWSTR  pwszUserName,
 IN   BOOL    fRestricted,
 IN   LPWSTR  pwszAuthzLevel,
 OUT  LPWSTR *ppwszTitle)
{
    DWORD dwMsgId = fRestricted ? RUNASP_STRING_TITLE_WITH_RESTRICTED : RUNASP_STRING_TITLE;

    return WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, 
                    dwMsgId, 
                    ppwszTitle, 
                    pwszAppName, 
                    pwszUserName, 
                    pwszAuthzLevel); 
}

// Creates the process with a given "privilege level".
//
// dwAuthzLevel -- specifies the authorization level ID to create the
//                 process with.  Can be one of the following values:
//
//     SAFER_LEVELID_FULLYTRUSTED
//     SAFER_LEVELID_NORMALUSER
//     SAFER_LEVELID_CONSTRAINED
//     SAFER_LEVELID_UNTRUSTED
//
BOOL CreateProcessRestricted
(IN   DWORD                 dwAuthzLevel,
 IN   LPCWSTR               pwszAppName,
 IN   LPWSTR                pwszCmdLine,
 IN   LPWSTR                pwszCurrentDirectory,
 IN   LPSTARTUPINFO         si,
 OUT  PROCESS_INFORMATION  *pi)
{
    BOOL               fResult          = FALSE;
    DWORD              dwCreationFlags  = 0;
    SAFER_LEVEL_HANDLE hAuthzLevel      = NULL;
    HANDLE             hToken           = NULL;

    // Maintain old runas behavior:  console apps run in a new console.
    dwCreationFlags |= CREATE_NEW_CONSOLE;

    fResult = SaferCreateLevel
        (SAFER_SCOPEID_MACHINE,
         dwAuthzLevel,
         SAFER_LEVEL_OPEN,
         &hAuthzLevel,
         NULL);
    _JumpCondition(FALSE == fResult, error);

    // Generate the restricted token that we will use.
    fResult = SaferComputeTokenFromLevel
        (hAuthzLevel,
         NULL,                  // source token
         &hToken,               // target token
         SAFER_TOKEN_MAKE_INERT, // runas should run with the inert flag
         NULL);                 // reserved
    _JumpCondition(FALSE == fResult, error);

    // Launch the child process under the context of the restricted token.
    fResult = CreateProcessAsUser
        (hToken,                  // token representing the user
         pwszAppName,             // name of executable module
         pwszCmdLine,             // command-line string
         NULL,                    // process security attributes
         NULL,                    // thread security attributes
         FALSE,                   // if process inherits handles
         dwCreationFlags,         // creation flags
         NULL,                    // new environment block
         pwszCurrentDirectory,    // current directory name
         si,                      // startup information
         pi                       // process information
         );


    // success.
 error:
    if (NULL != hAuthzLevel) { SaferCloseLevel(hAuthzLevel); }
    if (NULL != hToken)      { CloseHandle(hToken); }

    return fResult;
}

DWORD FriendlyNameToTrustLevelID(LPWSTR  pwszFriendlyName,
                                 DWORD  *pdwTrustLevelID)
{
    BOOL               fResult;
    DWORD              cbSize;
    DWORD              dwResult;
    DWORD              dwNumLevels;
    DWORD             *pdwLevelIDs                     = NULL;
    SAFER_LEVEL_HANDLE hAuthzLevel                 = NULL;
    WCHAR              wszLevelName[1024];
    DWORD              dwBufferSize = 0;

    fResult = SaferGetPolicyInformation
        (SAFER_SCOPEID_MACHINE,
         SaferPolicyLevelList,
         0,
         NULL,
         &cbSize,
         NULL);
    _JumpCondition(FALSE == fResult && ERROR_INSUFFICIENT_BUFFER != GetLastError(), GetInformationCodeAuthzPolicyWError);

    dwNumLevels = cbSize / sizeof(DWORD);
    pdwLevelIDs = (DWORD *)HeapAlloc(GetProcessHeap(), 0, cbSize);
    _JumpCondition(NULL == pdwLevelIDs, MemoryError);

    fResult = SaferGetPolicyInformation
        (SAFER_SCOPEID_MACHINE,
         SaferPolicyLevelList,
         cbSize,
         pdwLevelIDs,
         &cbSize,
         NULL);
    _JumpCondition(FALSE == fResult, GetInformationCodeAuthzPolicyWError);

    // Try each trust level, and return the one that matches the trust level
    // passed as a parameter:
    for (DWORD dwIndex = 0; dwIndex < dwNumLevels; dwIndex++)
    {
        if (SaferCreateLevel
            (SAFER_SCOPEID_MACHINE,
             pdwLevelIDs[dwIndex],
             SAFER_LEVEL_OPEN,
             &hAuthzLevel,
             NULL))
        {
            if (SaferGetLevelInformation
                (hAuthzLevel,
                 SaferObjectFriendlyName,
                 wszLevelName,
                 sizeof(wszLevelName) / sizeof(wszLevelName[0]),
                 &dwBufferSize))
            {
                if (0 == _wcsicmp(pwszFriendlyName, wszLevelName))
                {
                    // We've found the specified trust level.
                    *pdwTrustLevelID = pdwLevelIDs[dwIndex];
                    SaferCloseLevel(hAuthzLevel);
                    dwResult = ERROR_SUCCESS;
                    goto ErrorReturn;
                }
            }
            SaferCloseLevel(hAuthzLevel);
        }
    }

    // The specified level ID is not in the enumeration.
    dwResult = ERROR_NOT_FOUND;
 ErrorReturn:
    if (NULL != pdwLevelIDs) { HeapFree(GetProcessHeap(), 0, pdwLevelIDs); }
    return dwResult;

SET_DWRESULT(GetInformationCodeAuthzPolicyWError,  GetLastError());
SET_DWRESULT(MemoryError,                          ERROR_NOT_ENOUGH_MEMORY);

}

DWORD IntermediateSaferLevelsAreEnabled(BOOL *pfResult) 
{
    BOOL    fResult; 
    DWORD   cbSize; 
    DWORD   dwNumLevels; 
    DWORD   dwResult; 

    cbSize = 0; 

    fResult = SaferGetPolicyInformation 
        (SAFER_SCOPEID_MACHINE, 
         SaferPolicyLevelList,
         0, 
         NULL, 
         &cbSize, 
         NULL); 
    _JumpCondition(!fResult && ERROR_INSUFFICIENT_BUFFER != GetLastError(), SaferGetPolicyInformationError); 

    dwNumLevels = cbSize / sizeof(DWORD); 
    // If there are more than two levels available, we know that intermediate
    // safer levels have been enabled. 
    fResult = dwNumLevels > 2; 

    *pfResult = fResult; 
    dwResult = ERROR_SUCCESS;
 ErrorReturn:
    return dwResult; 

SET_DWRESULT(SaferGetPolicyInformationError, GetLastError()); 
}

DWORD
ShowTrustLevels(VOID)
{
    BOOL               fResult;
    DWORD              cbSize;
    DWORD              ccWritten;
    DWORD              dwResult;
    DWORD              dwNumLevels;
    DWORD             *pdwLevelIDs                     = NULL;
    SAFER_LEVEL_HANDLE hAuthzLevel                     = NULL;
    WCHAR              wszLevelName[1024];
    DWORD              dwBufferSize = 0;

    // Print header:
    LocalizedWPrintf(RUNASP_STRING_TRUSTLEVELS);

    // Print trust levels:
    fResult = SaferGetPolicyInformation
        (SAFER_SCOPEID_MACHINE,
         SaferPolicyLevelList,
         0,
         NULL,
         &cbSize,
         NULL);
    _JumpCondition(FALSE == fResult && ERROR_INSUFFICIENT_BUFFER != GetLastError(), GetInformationCodeAuthzPolicyWError);

    dwNumLevels = cbSize / sizeof(DWORD);
    pdwLevelIDs = (DWORD *)HeapAlloc(GetProcessHeap(), 0, cbSize);
    _JumpCondition(NULL == pdwLevelIDs, MemoryError);

    fResult = SaferGetPolicyInformation
        (SAFER_SCOPEID_MACHINE,
         SaferPolicyLevelList,
         cbSize,
         pdwLevelIDs,
         &cbSize,
         NULL);
    _JumpCondition(FALSE == fResult, GetInformationCodeAuthzPolicyWError);

    for (DWORD dwIndex = 0; dwIndex < dwNumLevels; dwIndex++)
    {
        // Give our best effort to enumerate each trust level:
        if (SaferCreateLevel
            (SAFER_SCOPEID_MACHINE,
             pdwLevelIDs[dwIndex],
             SAFER_LEVEL_OPEN,
             &hAuthzLevel,
             NULL))
        {
            if (SaferGetLevelInformation
                (hAuthzLevel,
                 SaferObjectFriendlyName,
                 wszLevelName,
                 sizeof(wszLevelName) / sizeof(wszLevelName[0]),
                 &dwBufferSize))
            {
                WriteConsoleW(g_hStdout, wszLevelName, (DWORD)wcslen(wszLevelName), &ccWritten, NULL);
                WriteConsoleW(g_hStdout, L"\n", 1, &ccWritten, NULL);
            }
            SaferCloseLevel(hAuthzLevel);
        }
    }

    dwResult = ERROR_SUCCESS;
 ErrorReturn:
    if (NULL != pdwLevelIDs) { HeapFree(GetProcessHeap(), 0, pdwLevelIDs); }
    return dwResult;

SET_DWRESULT(GetInformationCodeAuthzPolicyWError,  GetLastError());
SET_DWRESULT(MemoryError,                          ERROR_NOT_ENOUGH_MEMORY);
}


VOID
RunasPrintHelp(VOID)
{
    UINT rgText[] = {
        RUNASP_STRING_HELP_LINE1,       RUNASP_STRING_HELP_LINE2,
        RUNASP_STRING_HELP_LINE3,       RUNASP_STRING_HELP_LINE4,
        RUNASP_STRING_HELP_LINE5,       RUNASP_STRING_SAFER_HELP_LINE1,
        RUNASP_STRING_HELP_LINE7,       RUNASP_STRING_HELP_LINE8,
        RUNASP_STRING_HELP_LINE9,       RUNASP_STRING_HELP_LINE10,
        RUNASP_STRING_HELP_LINE11,      RUNASP_STRING_HELP_LINE12,
        RUNASP_STRING_HELP_LINE13,      RUNASP_STRING_HELP_LINE14,
        RUNASP_STRING_HELP_LINE15,      RUNASP_STRING_HELP_LINE16,
        RUNASP_STRING_HELP_LINE17,      RUNASP_STRING_HELP_LINE18,
        RUNASP_STRING_HELP_LINE19,      RUNASP_STRING_HELP_LINE20, 
	RUNASP_STRING_SAFER_HELP_LINE2, RUNASP_STRING_SAFER_HELP_LINE3, 
	RUNASP_STRING_SAFER_HELP_LINE4, RUNASP_STRING_SAFER_HELP_LINE5,
        RUNASP_STRING_HELP_LINE25,      RUNASP_STRING_HELP_LINE26,
        RUNASP_STRING_HELP_LINE27,      RUNASP_STRING_HELP_LINE28,
        RUNASP_STRING_HELP_LINE29,      RUNASP_STRING_HELP_LINE30,
        RUNASP_STRING_HELP_LINE31,      RUNASP_STRING_HELP_LINE32, 
	RUNASP_STRING_HELP_LINE33 
    };


    BOOL fShowSaferHelp; 

    if (ERROR_SUCCESS != IntermediateSaferLevelsAreEnabled(&fShowSaferHelp)) { 
        fShowSaferHelp = FALSE; 
    }

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgText); dwIndex++) {
        BOOL fPrintLine = TRUE;

        switch (rgText[dwIndex]) 
        {
        case RUNASP_STRING_SAFER_HELP_LINE1:
        case RUNASP_STRING_SAFER_HELP_LINE2:
        case RUNASP_STRING_SAFER_HELP_LINE3:
        case RUNASP_STRING_SAFER_HELP_LINE4:
        case RUNASP_STRING_SAFER_HELP_LINE5:
            fPrintLine = fShowSaferHelp; 
            break; 
        default:
	  ;
        }
       
        if (fPrintLine) 
            LocalizedWPrintf(rgText[dwIndex]);
    }
}

int WINAPI
WinMain(
        HINSTANCE hinstExe,
        HINSTANCE /*hinstExePrev*/,
        LPSTR /*pszCmdLine*/,
        int /*nCmdShow*/)
{

   HRESULT hr; 
   DWORD   dwAuthzLevel = 0;
   DWORD   dwResult = 0;
   DWORD   dwRetval = EXIT_CODE_FAILED; 
   DWORD   Logonflags = 0;
   DWORD   flags = 0;
   BOOL    fOk = FALSE;
   BOOL    UseCurrentEnvironment = FALSE;
   BOOL    UseNetOnly = FALSE;
   BOOL    fCreateProcessRestricted = FALSE;
   BOOL    fSuppliedAppName = FALSE; 
   BOOL    fSuppliedUserName = FALSE;
   BOOL    fCredMan = FALSE;
#if DBG
   BOOL    fSuppliedPassword = FALSE;
#endif // DBG

   DWORD   dwCredFlags       = 0;
   LPVOID  Environment       = NULL;
   LPWSTR  pwszCurrentDir    = NULL;
   LPWSTR  pwszArgvUserName  = NULL; 
   LPWSTR  pwszTitle         = NULL;

   WCHAR  pwszAuthzLevel[MAX_PATH];
   WCHAR  pwszDomainName[MAX_PATH];
   WCHAR  pwszUserDisplayName[CREDUI_MAX_USERNAME_LENGTH];
   WCHAR  pwszUserName[CREDUI_MAX_USERNAME_LENGTH];
   WCHAR  pwszPassword[CREDUI_MAX_PASSWORD_LENGTH];  
   WCHAR  pwszTarget[CREDUI_MAX_USERNAME_LENGTH];    
   
   int    i;

   DWORD rgdwArgs[ARRAYSIZE(rgArgCompat)];

   int nNumArgs;

   memset(&pwszAuthzLevel[0],         0, sizeof(pwszAuthzLevel));
   memset(&pwszDomainName[0],         0, sizeof(pwszDomainName));
   memset(&pwszUserDisplayName[0],    0, sizeof(pwszUserDisplayName));
   memset(&pwszUserName[0],           0, sizeof(pwszUserName));
   memset((WCHAR *)&pwszPassword[0],  0, sizeof(pwszPassword));
   memset((WCHAR *)&pwszTarget[0],    0, sizeof(pwszTarget));

   hMod = (HMODULE)hinstExe;

   MySetThreadUILanguage(0); 

   if (S_OK != (dwResult = InitializeConsoleOutput()))
   {
       DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, dwResult);
       goto error; 
   }

   LPWSTR* pszArgv = CommandLineToArgvW(GetCommandLineW(), &nNumArgs);

   if (pszArgv == NULL) {
       DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, MyGetLastError()); 
       goto error;
   }

   // Logging on with profile is now the default:
   Logonflags |= LOGON_WITH_PROFILE;

   for(i=1;i<nNumArgs;i++)
   {
       if(pszArgv[i][0] != L'/')
       {
           if (i == nNumArgs-1)
           {
               fSuppliedAppName = TRUE; 
               break;
           }
           else
           {
               RunasPrintHelp();
               goto error; 
           }
       }

        switch(pszArgv[i][1])
        {
#if DBG
            case L'z':
            case L'Z':
            {
                LPWSTR  str = &(pszArgv[i][2]);
                while(*str != L':')
                {
                    if(*str == L'\0')
                    {
                        RunasPrintHelp();
                        goto error; 
                    }
                    str++;
                }
                str++;

		hr = StringCchCopy((WCHAR *)pwszPassword, ARRAYSIZE(pwszPassword), str); 
		if (FAILED(hr)) { 
		    DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, ERROR_INVALID_PARAMETER); 
		    goto error; 
		}

                fSuppliedPassword = TRUE;
                break;
            }
#endif // DBG
            case L'p':
            case L'P': // "/profile" argument
                _CheckArgCompat(rgdwArgs, i-1, AI_PROFILE);
                break;

            case L'e':
            case L'E': // "/env" argument
            {
                _CheckArgCompat(rgdwArgs, i-1, AI_ENV);
                UseCurrentEnvironment = TRUE;
                break;
            }
            case L'n':
            case L'N':
            {
                switch (pszArgv[i][2])
                {
                    case L'e':
                    case L'E': // "/netonly" argument
                        _CheckArgCompat(rgdwArgs, i-1, AI_NETONLY);
                        UseNetOnly = TRUE;
                        Logonflags  |= LOGON_NETCREDENTIALS_ONLY;
                        Logonflags  &= ~LOGON_WITH_PROFILE;
                        break;

                    case L'o':
                    case L'O': // "/noprofile" argument
                        _CheckArgCompat(rgdwArgs, i-1, AI_NOPROFILE);
                        Logonflags &= ~LOGON_WITH_PROFILE;
                        break;

                    default:
                        RunasPrintHelp();
                        goto error;
                }

                break;
            }

            case L's':
            case L'S': // "/smartcard" argument
            {
                switch (pszArgv[i][2])
                {
                case L'a':
                case L'A':
                    _CheckArgCompat(rgdwArgs, i-1, AI_SAVECRED);
                    dwCredFlags |= RUNAS_USE_SAVEDCREDS;
                    fCredMan = TRUE;
                    break;
                case L'm':
                case L'M':
                    _CheckArgCompat(rgdwArgs, i-1, AI_SMARTCARD);
                    dwCredFlags |= RUNAS_USE_SMARTCARD;
                    break;
                case L'h':
                case L'H':
                    _CheckArgCompat(rgdwArgs, i-1, AI_SHOWTRUSTLEVELS);
                    ShowTrustLevels();
		    dwRetval = EXIT_CODE_SUCCEEDED; 
                    goto error; 
                }
                break ;
            }
            case L't':
            case L'T': // "/trustlevel" argument
            {
                _CheckArgCompat(rgdwArgs, i-1, AI_TRUSTLEVEL);

                LPWSTR  str = &(pszArgv[i][2]);
                while (*str != L':')
                {
                    if (*str == L'\0')
                    {
                        RunasPrintHelp();
                        goto error;
                    }
                    str++;
                }
                str++;

                if (ERROR_SUCCESS != FriendlyNameToTrustLevelID(str, &dwAuthzLevel))
                {
                    ShowTrustLevels();
                    goto error;
                }

		hr = StringCchCopy(pwszAuthzLevel, ARRAYSIZE(pwszAuthzLevel), str); 
		if (FAILED(hr)) { 
		    DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, ERROR_INVALID_PARAMETER); 
		    goto error; 
		}
                fCreateProcessRestricted = TRUE;
                break;
            }

            case L'u':
            case L'U': // "/user" argument
            {
                _CheckArgCompat(rgdwArgs, i-1, AI_USER);
                LPWSTR  str = &(pszArgv[i][2]);
                while(*str != L':')
                {
                    if(*str == L'\0')
                    {
                        RunasPrintHelp();
                        goto error; 
                    }
                    str++;
                }
                str++;

		hr = StringCchCopy(pwszUserName, ARRAYSIZE(pwszUserName), str); 
		if (FAILED(hr)) { 
		    DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, ERROR_INVALID_PARAMETER); 
		    goto error; 
		}
                pwszArgvUserName = str; // Save the supplied username in case we need to restore it. 
                fSuppliedUserName = TRUE;
                break;
            }

            default:
                  RunasPrintHelp();
                  goto error; 
        }
   }



   // The command line must specify:
   // 1) an application to run 
   // 2) either a username, a trustlevel, or a smartcard option
   if(FALSE == fSuppliedAppName || 
      (FALSE == fSuppliedUserName && FALSE == fCreateProcessRestricted && 0 == (RUNAS_USE_SMARTCARD & dwCredFlags))
      )
   {
       RunasPrintHelp();
       goto error;
   }

   STARTUPINFO si;
   PROCESS_INFORMATION pi;
   ZeroMemory(&si, sizeof(si));
   ZeroMemory(&pi, sizeof(pi)); 
   si.cb = sizeof(si);

   if (TRUE == fCreateProcessRestricted)
   {
       // Username is not specified with this set of options --
       // use the current user.
       DWORD dwSize = ARRAYSIZE(pwszUserName);
       if (FALSE == GetUserNameEx(NameSamCompatible, &pwszUserName[0], &dwSize))
       {
           DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, MyGetLastError());
           goto error;
       }

       pwszCurrentDir = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, MAX_PATH * sizeof(WCHAR));
       if (NULL == pwszCurrentDir)
       {
           DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, ERROR_NOT_ENOUGH_MEMORY); 
           goto error;
       }

       if (FALSE == GetCurrentDirectory(MAX_PATH, pwszCurrentDir))
       {
           DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, MyGetLastError());
           goto error;
       }

       if (FALSE == GetTitle(pszArgv[nNumArgs-1],
                             pwszUserName,
                             TRUE,
                             pwszAuthzLevel,
                             &pwszTitle))
       {
           DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, MyGetLastError());
           goto error; 
       }
       
       si.lpTitle = pwszTitle;

       // If we're just doing restricted login, we have enough information to proceed.
       fOk = CreateProcessRestricted
           (dwAuthzLevel,
            NULL,
            pszArgv[nNumArgs - 1],
            pwszCurrentDir,
            &si,
            &pi);
   }
   else
   {
       for (BOOL fDone = FALSE; !fDone; ) {
#if DBG
           // Can only supply password in checked builds.
           if (FALSE == fSuppliedPassword) {
#endif // DBG
               dwResult = GetCredentials
                   (dwCredFlags,
                    (WCHAR *)pwszPassword,
                    ARRAYSIZE(pwszPassword),
                    pwszUserName,
                    ARRAYSIZE(pwszUserName),
                    pwszUserDisplayName,
                    ARRAYSIZE(pwszUserDisplayName),
                    (WCHAR *)pwszTarget,
                    ARRAYSIZE(pwszTarget));
               if (ERROR_SUCCESS != dwResult) {
                   LocalizedWPrintf(RUNASP_STRING_ERROR_PASSWORD);
                   goto error;
               }
#if DBG
           } else {
               // If we've supplied a password, don't call GetCredentials.
               // Just copy our username to the display name and proceed.
               wcsncpy(pwszUserDisplayName, pwszUserName, ARRAYSIZE(pwszUserDisplayName)-1);
           }
#endif // DBG


           if (FALSE == GetTitle(pszArgv[nNumArgs-1],
                                 pwszUserDisplayName,
                                 FALSE,
                                 NULL,
                                 &pwszTitle)) 
           {
               DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, MyGetLastError());
               goto error; 
           }
           si.lpTitle = pwszTitle;

       //
       // Now we should take the pwszUserName and parse it
       // if it is Domain\User, we want to split it.
       //
           WCHAR *wstr = pwszUserName;
           while(*wstr != L'\0')
           {
               if(*wstr == L'\\')
               {
                   *wstr = L'\0';
                   wstr++;
                   //
                   // first part is domain
                   // second is user.
                   //
		   hr = StringCchCopy(pwszDomainName, ARRAYSIZE(pwszDomainName), pwszUserName); 
		   if (FAILED(hr)) { 
		       DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, ERROR_INVALID_PARAMETER); 
		       goto error; 
		   }

		   hr = StringCchCopy(pwszUserName, ARRAYSIZE(pwszUserName), wstr); 
		   if (FAILED(hr)) { 
		       DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, ERROR_INVALID_PARAMETER); 
		       goto error; 
		   }
                   break;
               }
               wstr++;
           }

           DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_WAIT, pszArgv[nNumArgs-1], pwszUserDisplayName);

           if(UseCurrentEnvironment)
           {
               pwszCurrentDir = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, MAX_PATH * sizeof(WCHAR));
               if (NULL == pwszCurrentDir) {
                   DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, ERROR_NOT_ENOUGH_MEMORY); 
                   goto error;
               }
               if (!GetCurrentDirectory(MAX_PATH, pwszCurrentDir)) { 
                   DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, GetLastError()); 
		   goto error; 
	       }
		   
               Environment = GetEnvironmentStrings();
               flags |= CREATE_UNICODE_ENVIRONMENT;
           }

           fOk = CreateProcessWithLogonW
               (pwszUserName,    // Username
                pwszDomainName,  // Domain
                (WCHAR *)pwszPassword,    // Password
                Logonflags, // logon flags
                NULL,          // Application name
                pszArgv[nNumArgs-1],    // Command line
                flags,         // flags
                Environment,   // NULL=LoggedOnUserEnv, GetEnvironmentStrings
                pwszCurrentDir,// Working Directory
                &si,           // Startup Info
                &pi);          // Process Info

           // See if we need to try again...
           fDone = TRUE;
           if (fCredMan) { // The /savecred option was specified.
               if (RUNAS_USE_SAVEDCREDS & dwCredFlags) { // We tried to use saved credentials
                   if (!fOk && CREDUI_IS_AUTHENTICATION_ERROR(GetLastError())) { 
                       // We attempted to use saved creds, and it didn't work. 
                       // Try prompting for a password.
                       dwCredFlags &= ~RUNAS_USE_SAVEDCREDS;
                       dwCredFlags |= RUNAS_SAVE_CREDS; // We'll save the new credentials if we can.
                       fDone = FALSE; // We should try to create the process again.

                       // Reset the username, it may have been modified by GetCredentials():
		       hr = StringCchCopy(pwszUserName, ARRAYSIZE(pwszUserName), pwszArgvUserName); 
		       if (FAILED(hr)) { 
			   DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, ERROR_INVALID_PARAMETER); 
			   goto error; 
		       }
                   } else { 
                       // We succeeded, or some other failure occured.
                       // Don't bother trying again.
                   }
               }
               else {
                   // We attempted to save our credentials to credman.  Only save them on success:
                   dwResult = SaveCredentials((WCHAR *)pwszTarget, fOk);
                   // ignore errors in SaveCredentials (not much we can do on error).
               }
           }
       }
   }

   if(!fOk)
   {
      DWORD dw;
      LPWSTR wszErrorText = NULL; 

      dw = GetLastError();
      if (ERROR_SUCCESS == dw) 
          GetExitCodeProcess(pi.hProcess, &dw);
      if (ERROR_SUCCESS == dw)
          GetExitCodeThread(pi.hThread, &dw);
      if (ERROR_SUCCESS == dw)
          dw = (DWORD)E_FAIL; 

      if (!WriteMsg(FORMAT_MESSAGE_FROM_SYSTEM, dw, &wszErrorText, pszArgv[nNumArgs-1]))
          DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_INTERNAL, dw);
      else
          DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, RUNASP_STRING_ERROR_OCCURED, pszArgv[nNumArgs-1], dw, wszErrorText); 

      goto error; 
   }

   CloseHandle(pi.hProcess);
   CloseHandle(pi.hThread);

   dwRetval = EXIT_CODE_SUCCEEDED;
 error:
   // Zero out memory which might contain credentials:
   SecureZeroMemory(pwszPassword, sizeof(pwszPassword)); 
   SecureZeroMemory(pwszTarget, sizeof(pwszTarget)); 

   return dwRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\runas\stringid.h ===
/*+
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1997 - 1998.
 *
 * Name : stringid.h
 * Author:PraeritG
 *
-*/

#define RUNASP_STRING_HELP_LINE1        7000
#define RUNASP_STRING_HELP_LINE2        7001
#define RUNASP_STRING_HELP_LINE3        7002
#define RUNASP_STRING_HELP_LINE4        7003
#define RUNASP_STRING_HELP_LINE5        7004
#define RUNASP_STRING_SAFER_HELP_LINE1  7005
#define RUNASP_STRING_HELP_LINE7        7006
#define RUNASP_STRING_HELP_LINE8        7007
#define RUNASP_STRING_HELP_LINE9        7008
#define RUNASP_STRING_HELP_LINE10       7009
#define RUNASP_STRING_HELP_LINE11       7010
#define RUNASP_STRING_HELP_LINE12       7011
#define RUNASP_STRING_HELP_LINE13	7012
#define RUNASP_STRING_HELP_LINE14	7013
#define RUNASP_STRING_HELP_LINE15	7014
#define RUNASP_STRING_HELP_LINE16	7015
#define RUNASP_STRING_HELP_LINE17	7016
#define RUNASP_STRING_HELP_LINE18	7017
#define RUNASP_STRING_HELP_LINE19	7018
#define RUNASP_STRING_SAFER_HELP_LINE2  7019
#define RUNASP_STRING_SAFER_HELP_LINE3  7020
#define RUNASP_STRING_SAFER_HELP_LINE4  7021
#define RUNASP_STRING_SAFER_HELP_LINE5  7022
#define RUNASP_STRING_HELP_LINE24	7023
#define RUNASP_STRING_HELP_LINE25	7024
#define RUNASP_STRING_HELP_LINE26	7025
#define RUNASP_STRING_HELP_LINE27	7026
#define RUNASP_STRING_HELP_LINE28	7027
#define RUNASP_STRING_HELP_LINE29	7028
#define RUNASP_STRING_HELP_LINE30	7029
#define RUNASP_STRING_HELP_LINE31	7030
#define RUNASP_STRING_HELP_LINE32	7031
#define RUNASP_STRING_HELP_LINE20       7032 // NOTE: out of order!
#define RUNASP_STRING_HELP_LINE33       7033

// NOTE:  These defines indicate the boundaries of the SAFER help text. 
//        **These must be kept in sync with the string table in runas.rc**
// 


#define RUNASP_STRING_ERROR             7100
#define RUNASP_STRING_ERROR_SYSTEM      7101
#define RUNASP_STRING_ERROR_INPUT       7102
#define RUNASP_STRING_ERROR_ECHO        7103
#define RUNASP_STRING_ERROR_PASSWORD    7104
#define RUNASP_STRING_ERROR_USERNAME    7105

#define RUNASP_STRING_TRUSTLEVELS       7204
#define RUNASP_STRING_SMARTCARDUSER     7205

// Do not declare string IDs greater than this value!
#define RUNASP_MAX_ID 8000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\runas\utils.h ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// dialogs.hpp
//
// Credential manager user interface classes used to get credentials.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#ifndef __UTILS_HPP__
#define __UTILS_HPP__

#include <wincrypt.h>
#include <lm.h>

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

BOOL
CreduiIsRemovableCertificate(
    CONST CERT_CONTEXT *certContext
    );

BOOL
CreduiGetCertificateDisplayName(
    CONST CERT_CONTEXT *certContext,
    WCHAR *displayName,
    ULONG displayNameMaxChars,
    WCHAR *certificateString
    );

BOOL
CreduiGetCertDisplayNameFromMarshaledName(
    WCHAR *marshaledName,
    WCHAR *displayName,
    ULONG displayNameMaxChars,
    BOOL onlyRemovable
    );

LPWSTR
GetAccountDomainName(
    VOID
    );

//-----------------------------------------------------------------------------

#endif // __UTILS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\browse.c ===
//
// Browse.C
//
#include "sigverif.h"

// Global browse buffer that is used until user click OK or Cancel
TCHAR g_szBrowsePath[MAX_PATH];

//
// This callback function handles the initialization of the browse dialog and when
// the user changes the selection in the tree-view.  We want to keep updating the 
// g_szBrowsePath buffer with selection changes until the user clicks OK.
//
int CALLBACK BrowseCallbackProc(
    HWND hwnd, 
    UINT uMsg, 
    LPARAM lParam, 
    LPARAM lpData 
    )
{
    TCHAR PathName[MAX_PATH];
    LPITEMIDLIST lpid;

    UNREFERENCED_PARAMETER(lpData);

    switch (uMsg) {
    
    case BFFM_INITIALIZED:
        //
        // Initialize the dialog with the OK button and g_szBrowsePath
        //
        SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM) 0, (LPARAM) 1);
        SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM) TRUE, (LPARAM) g_szBrowsePath);
        break;

    case BFFM_SELCHANGED:   
        lpid = (LPITEMIDLIST) lParam;
        
        if (SHGetPathFromIDList(lpid, PathName) &&
            (SUCCEEDED(StringCchCopy(g_szBrowsePath, cA(g_szBrowsePath), PathName)))) {
        
            SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM) 0, (LPARAM) 1);
        }
        
        break;
    }

    return 0;
}  

//
// This uses SHBrowseForFolder to get the directory the user wants to search.
// We specify a callback function that updates g_szBrowsePath until the user clicks OK or Cancel.
// If they clicked OK, then we update the string passed in to us as lpszBuf.
// 
//
BOOL BrowseForFolder(HWND hwnd, LPTSTR lpszBuf, DWORD BufCchSize) {

    BROWSEINFO          bi;
    TCHAR               szBuffer[MAX_PATH], szMessage[MAX_PATH];
    LPITEMIDLIST        lpid;

    //
    // Check if the lpszBuf path is valid, if so use that as the browse dialog's initial directory.
    // If it isn't valid, initialize g_szBrowsePath with the Windows directory.
    //
    if (!SetCurrentDirectory(lpszBuf) ||
        FAILED(StringCchCopy(g_szBrowsePath, cA(g_szBrowsePath), lpszBuf))) {
        
        MyGetWindowsDirectory(g_szBrowsePath, cA(g_szBrowsePath));
    }

    //
    // Start the root of the browse dialog in the CSIDL_DRIVES namespace
    //
    if (!SUCCEEDED(SHGetSpecialFolderLocation(hwnd, CSIDL_DRIVES, &lpid))) {
    
        return FALSE;
    }

    //
    // This loads in the "Please select a directory" text into the dialog.
    //
    MyLoadString(szMessage, cA(szMessage), IDS_SELECTDIR);

    //
    // Setup the BrowseInfo struct.
    //
    bi.hwndOwner        = hwnd;
    bi.pidlRoot         = lpid;
    bi.pszDisplayName   = szBuffer;
    bi.lpszTitle        = szMessage;
    bi.ulFlags          = BIF_RETURNONLYFSDIRS;
    bi.lpfn             = (BFFCALLBACK) BrowseCallbackProc;
    bi.lParam           = 0x123;

    if (SHBrowseForFolder(&bi) == NULL) {
    
        return FALSE;
    }

    //
    // The user must have clicked OK, so we can update lpszBuf with g_szBrowsePath!
    //
    return (SUCCEEDED(StringCchCopy(lpszBuf, BufCchSize, g_szBrowsePath)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\runas\utils.cpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// utils.cpp
//
// Credential manager user interface utility functions.
//
// Created 06/06/2000 johnstep (John Stephens)
//=============================================================================

#include "cred_pch.h"
#include "utils.h"


//=============================================================================
// CreduiIsRemovableCertificate
//
// Arguments:
//   certContext (in) - certificate context to query
//
// Returns TRUE if the certificate has a removable component (such as a smart
// card) or FALSE otherwise.
//
// Created 04/09/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIsRemovableCertificate(
    CONST CERT_CONTEXT *certContext
    )
{
    BOOL isRemovable = FALSE;
    
    // First, determine the buffer size:
    
    DWORD bufferSize = 0;

    if (CertGetCertificateContextProperty(
            certContext,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &bufferSize))
    {
        // Allocate the buffer on the stack:

        CRYPT_KEY_PROV_INFO *provInfo;

        __try
        {
            provInfo = static_cast<CRYPT_KEY_PROV_INFO *>(alloca(bufferSize));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            provInfo = NULL;
        }

        if (provInfo != NULL)
        {
            if (CertGetCertificateContextProperty(
                    certContext,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    provInfo,
                    &bufferSize))
            {
                HCRYPTPROV provContext;

                if (CryptAcquireContext(
                        &provContext,
                        NULL,
                        provInfo->pwszProvName,
                        provInfo->dwProvType,
                        CRYPT_VERIFYCONTEXT | CRYPT_SILENT))
                {
                    DWORD impType;
                    DWORD impTypeSize = sizeof impType;

                    if (CryptGetProvParam(
                            provContext,
                            PP_IMPTYPE,
                            reinterpret_cast<BYTE *>(&impType),
                            &impTypeSize,
                            0))
                    {
                        if (impType & CRYPT_IMPL_REMOVABLE)
                        {
                            isRemovable = TRUE;
                        }
                    }

                    if (!CryptReleaseContext(provContext, 0))
                    {
                        CreduiDebugLog(
                            "CreduiIsRemovableCertificate: "
                            "CryptReleaseContext failed: %u\n",
                            GetLastError());
                    }
                }
            }
        }
    }

    return isRemovable;
}

//=============================================================================
// CreduiGetCertificateDisplayName
//
// Arguments:
//   certContext (in)
//   displayName (out)
//   displayNameMaxChars (in)
//   certificateString (in)
//
// Returns TRUE if a display name was stored or FALSE otherwise.
//
// Created 06/12/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiGetCertificateDisplayName(
    CONST CERT_CONTEXT *certContext,
    WCHAR *displayName,
    ULONG displayNameMaxChars,
    WCHAR * /*certificateString*/
    )
{
    BOOL success = FALSE;
    
    WCHAR *tempName;
    ULONG tempNameMaxChars = displayNameMaxChars / 2 - 1;

    __try
    {
        tempName =
            static_cast<WCHAR *>(
                alloca(tempNameMaxChars * sizeof (WCHAR)));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        tempName = NULL;
    }

    if (tempName == NULL)
    {
        return FALSE;
    }
    
    displayName[0] = L'\0';
    tempName[0] = L'\0';
    
    if (CertGetNameString(
            certContext,
            CERT_NAME_FRIENDLY_DISPLAY_TYPE,
            0,
            NULL,
            tempName,
            tempNameMaxChars))
    {
        success = TRUE;
        lstrcpy(displayName, tempName);
    }

    if (CertGetNameString(
            certContext,
            CERT_NAME_FRIENDLY_DISPLAY_TYPE,
            CERT_NAME_ISSUER_FLAG,
            NULL,
            tempName,
            tempNameMaxChars))
    {
        if (lstrcmpi(displayName, tempName) != 0)
        {
            success = TRUE;

            WCHAR *where = &displayName[lstrlen(displayName)];

            if (where > displayName)
            {
                *where++ = L' ';
                *where++ = L'-';
                *where++ = L' ';
            }

            lstrcpy(where, tempName);
        }
    }

    return success;
}

//=============================================================================
// CreduiGetCertDisplayNameFromMarshaledName
//
// Arguments:
//   marshaledName (in)
//   displayName (out)
//   displayNameMaxChars (in)
//   onlyRemovable (in) - only get name if for a "removable" certificate
//
// Returns TRUE if a display name was stored or FALSE otherwise.
//
// Created 07/24/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiGetCertDisplayNameFromMarshaledName(
    WCHAR *marshaledName,
    WCHAR *displayName,
    ULONG displayNameMaxChars,
    BOOL onlyRemovable
    )
{
    BOOL success = FALSE;

    CRED_MARSHAL_TYPE credMarshalType;
    CERT_CREDENTIAL_INFO *certCredInfo;

    if (CredUnmarshalCredential(
            marshaledName,
            &credMarshalType,
            reinterpret_cast<VOID **>(&certCredInfo)))
    {
        if (credMarshalType == CertCredential)
        {
            HCERTSTORE certStore;
            CONST CERT_CONTEXT *certContext;

            certStore = CertOpenSystemStore(NULL, L"MY");

            if (certStore != NULL)
            {
                CRYPT_HASH_BLOB hashBlob;

                hashBlob.cbData = CERT_HASH_LENGTH;
                hashBlob.pbData = reinterpret_cast<BYTE *>(
                                      certCredInfo->rgbHashOfCert);

                certContext = CertFindCertificateInStore(
                                  certStore,
                                  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                  0,
                                  CERT_FIND_SHA1_HASH,
                                  &hashBlob,
                                  NULL);

                if (certContext != NULL)
                {
                    // If onlyRemovable is TRUE, check to see if this is a
                    // certificate with a removable hardware component; this
                    // usually means a smart card:

                    if (!onlyRemovable ||
                        CreduiIsRemovableCertificate(certContext))
                    {
                        success =
                            CreduiGetCertificateDisplayName(
                                certContext,
                                displayName,
                                displayNameMaxChars,
                                NULL);
                    }

                    CertFreeCertificateContext(certContext);
                }

                // CertCloseStore returns FALSE if it fails. We could try
                // again, depending on the error returned by GetLastError:
                
                CertCloseStore(certStore, 0);
            }
        }

        CredFree(static_cast<VOID *>(certCredInfo));
    }

    return success;
}

LPWSTR
GetAccountDomainName(
    VOID
    )
/*++

Routine Description:

    Returns the name of the account domain for this machine.

    For workstatations, the account domain is the netbios computer name.
    For DCs, the account domain is the netbios domain name.

Arguments:

    None.

Return Values:

    Returns a pointer to the name.  The name should be free using NetApiBufferFree.

    NULL - on error.

--*/
{
    BOOL  CreduiIsDomainController  = FALSE; 
    DWORD WinStatus;

    LPWSTR AllocatedName = NULL;

    OSVERSIONINFOEXW versionInfo;
    versionInfo.dwOSVersionInfoSize = sizeof OSVERSIONINFOEXW;
    
    if (GetVersionEx(reinterpret_cast<OSVERSIONINFOW *>(&versionInfo)))
    {
	CreduiIsDomainController = (versionInfo.wProductType == VER_NT_DOMAIN_CONTROLLER);
    }

    //
    // If this machine is a domain controller,
    //  get the domain name.
    //

    if ( CreduiIsDomainController ) {

        WinStatus = NetpGetDomainName( &AllocatedName );

        if ( WinStatus != NO_ERROR ) {
            return NULL;
        }

    //
    // Otherwise, the 'account domain' is the computername
    //

    } else {

        WinStatus = NetpGetComputerName( &AllocatedName );

        if ( WinStatus != NO_ERROR ) {
            return NULL;
        }

    }

    return AllocatedName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\seclist\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=seclist
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    seclist.cxx \
    seclist.rc

USE_MSVCRT=1

INCLUDES= \
    ..; \
    $(PROJECT_ROOT)\fs\utils\ulib\inc; \
    $(PROJECT_ROOT)\fs\utils\ifsutil\inc; \
    $(PROJECT_ROOT)\fs\utils\ufat\inc;\
    $(DDK_INC_PATH)

C_DEFINES=-DUNICODE=1 -DNOMINMAX

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

TARGETLIBS= \
    $(PROJECT_ROOT)\fs\utils\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib          \
    $(PROJECT_ROOT)\fs\utils\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib    \
    $(PROJECT_ROOT)\fs\utils\ufat\src\$(ALT_PROJECT)\$(O)\ufat.lib          \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\advanced.c ===
//
// Advanced.C
//
#include "sigverif.h"

//
//  Initialization of search dialog.
//
BOOL Search_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{   
    TCHAR szBuffer[MAX_PATH];

    UNREFERENCED_PARAMETER(hwndFocus);
    UNREFERENCED_PARAMETER(lParam);

    g_App.hSearch = hwnd;

    //
    // Since the "check system files" option is faster, check that option by 
    // default.
    //
    if (!g_App.bUserScan) {
        CheckRadioButton(hwnd, IDC_SCAN, IDC_NOTMS, IDC_SCAN);
    } else {
        CheckRadioButton(hwnd, IDC_SCAN, IDC_NOTMS, IDC_NOTMS);
    }

    //
    // Pre-load the user's search path with the Windows directory
    //
    if (!*g_App.szScanPath) {
        MyGetWindowsDirectory(g_App.szScanPath, cA(g_App.szScanPath));
    }

    //
    // Display the current search folder
    //
    SetDlgItemText(hwnd, IDC_FOLDER, g_App.szScanPath);

    //
    // Pre-load the user's search pattern with "*.*"
    //
    if (!*g_App.szScanPattern) {
        MyLoadString(g_App.szScanPattern, cA(g_App.szScanPattern), IDS_ALL);
    }

    //
    // Display the current search pattern.
    //
    SetDlgItemText(hwnd, IDC_TYPE, szBuffer);

    //
    // Now disable all the dialog items associated with IDS_NOTMS
    //
    if (!g_App.bUserScan) {
        EnableWindow(GetDlgItem(hwnd, IDC_SUBFOLDERS), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TYPE), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), FALSE);
        EnableWindow(GetDlgItem(hwnd, ID_BROWSE), FALSE);
    }

    //
    // If we are searching subdirectories, check the SubFolders checkbox
    //
    if (g_App.bSubFolders) {
        CheckDlgButton(hwnd, IDC_SUBFOLDERS, BST_CHECKED);
    } else {
        CheckDlgButton(hwnd, IDC_SUBFOLDERS, BST_UNCHECKED);
    }

    //
    // Set the combobox value to g_App.szScanPattern
    //
    SetDlgItemText(hwnd, IDC_TYPE, g_App.szScanPattern);

    //
    // Initialize the combobox with several pre-defined extension types
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_EXE);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, cA(szBuffer), IDS_DLL);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, cA(szBuffer), IDS_SYS);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, cA(szBuffer), IDS_DRV);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, cA(szBuffer), IDS_OCX);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, cA(szBuffer), IDS_ALL);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);

    return TRUE;
}

//
//  Handle any WM_COMMAND messages sent to the search dialog
//
void Search_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    UNREFERENCED_PARAMETER(hwndCtl);
    UNREFERENCED_PARAMETER(codeNotify);

    switch(id) {
    
    case ID_BROWSE:
        // 
        // The user clicked the ID_BROWSE button, so call BrowseForFolder and 
        // update IDC_FOLDER
        //
        if (BrowseForFolder(hwnd, g_App.szScanPath, cA(g_App.szScanPath))) {
            SetDlgItemText(hwnd, IDC_FOLDER, g_App.szScanPath);
        }
        break;

    case IDC_SCAN:
        //
        //  The user clicked IDC_SCAN, so disable all the IDC_NOTMS controls
        //
        if (!g_App.bScanning) {
            EnableWindow(GetDlgItem(hwnd, IDC_SUBFOLDERS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_TYPE), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), FALSE);
            EnableWindow(GetDlgItem(hwnd, ID_BROWSE), FALSE);
        }
        break;

    case IDC_NOTMS:
        //
        //  The user clicked IDC_NOTMS, so make sure all the controls are enabled
        //
        if (!g_App.bScanning) {
            EnableWindow(GetDlgItem(hwnd, IDC_SUBFOLDERS), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_TYPE), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), TRUE);
            EnableWindow(GetDlgItem(hwnd, ID_BROWSE), TRUE);
        }
        break;
    }
}

//
// This function handles any notification messages for the Search page.
//
LRESULT Search_NotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnmhdr = (NMHDR *) lParam;

    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);

    switch(lpnmhdr->code) {
    
    case PSN_APPLY:         
        g_App.bUserScan = (IsDlgButtonChecked(hwnd, IDC_NOTMS) == BST_CHECKED);
        if (g_App.bUserScan) {

            if (GetWindowTextLength(GetDlgItem(hwnd, IDC_FOLDER)) > cA(g_App.szScanPath)) {
                //
                // The folder path that was entered is too long to fit into our
                // buffer, so tell the user the path is invalid and stay on
                // the property page.
                //
                MyErrorBoxId(IDS_INVALID_FOLDER);
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                return TRUE;
            } else {
                //
                // Get the search pattern from the combobox and update g_App.szScanPattern
                //
                GetDlgItemText(hwnd, IDC_TYPE, g_App.szScanPattern, cA(g_App.szScanPattern));
                
                //
                // Get the path from the edit control and update g_App.szScanPath
                //
                GetDlgItemText(hwnd, IDC_FOLDER, g_App.szScanPath, cA(g_App.szScanPath));
                
                //
                // Get the checked/unchecked state of the "SubFolders" checkbox
                //
                g_App.bSubFolders = (IsDlgButtonChecked(hwnd, IDC_SUBFOLDERS) == BST_CHECKED);
            }
        }
    }

    return 0;
}


//
//  The search dialog procedure.  Needs to handle WM_INITDIALOG, WM_COMMAND, and WM_CLOSE/WM_DESTROY.
//
INT_PTR CALLBACK Search_DlgProc(HWND hwnd, UINT uMsg,
                                WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
        
    HANDLE_MSG(hwnd, WM_INITDIALOG, Search_OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, Search_OnCommand);

    case WM_NOTIFY:
        return Search_NotifyHandler(hwnd, uMsg, wParam, lParam);

    case WM_HELP:
        SigVerif_Help(hwnd, uMsg, wParam, lParam, FALSE);
        break;

    case WM_CONTEXTMENU:
        SigVerif_Help(hwnd, uMsg, wParam, lParam, TRUE);
        break;

    default: fProcessed = FALSE;
    }

    return fProcessed;
}

void AdvancedPropertySheet(HWND hwnd)
{
    PROPSHEETPAGE   psp[NUM_PAGES];
    PROPSHEETHEADER psh;
    TCHAR           szCaption[MAX_PATH];
    TCHAR           szPage1[MAX_PATH];
    TCHAR           szPage2[MAX_PATH];
    
    ZeroMemory(&psp[0], sizeof(PROPSHEETPAGE));
    psp[0].dwSize = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags = PSP_USEHICON | PSP_USETITLE;
    psp[0].hInstance = g_App.hInstance;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_SEARCH);
    psp[0].hIcon = g_App.hIcon;
    psp[0].pfnDlgProc = Search_DlgProc;
    MyLoadString(szPage1, cA(szPage1), IDS_SEARCHTAB);
    psp[0].pszTitle = szPage1;
    psp[0].lParam = 0;
    psp[0].pfnCallback = NULL;

    ZeroMemory(&psp[1], sizeof(PROPSHEETPAGE));
    psp[1].dwSize = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags = PSP_USEHICON | PSP_USETITLE;
    psp[1].hInstance = g_App.hInstance;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_SETTINGS);
    psp[1].hIcon = g_App.hIcon;
    psp[1].pfnDlgProc = LogFile_DlgProc;
    MyLoadString(szPage2, cA(szPage2), IDS_LOGGINGTAB);
    psp[1].pszTitle = szPage2;
    psp[1].lParam = 0;
    psp[1].pfnCallback = NULL;

    ZeroMemory(&psh, sizeof(PROPSHEETHEADER));
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_USEHICON | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwnd;
    psh.hInstance = g_App.hInstance;
    psh.hIcon = g_App.hIcon;
    MyLoadString(szCaption, cA(szCaption), IDS_ADVANCED_SETTINGS);
    psh.pszCaption = szCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage = 0;
    psh.ppsp = (LPCPROPSHEETPAGE)psp;
    psh.pfnCallback = NULL;

    PropertySheet(&psh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\seclist\seclist.cxx ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

        SecList.cxx

Abstract:

        Sector list utility

Author:

        Bill McJohn (billmc) 30-July-92

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"

#include "wstring.hxx"
#include "path.hxx"
#include "smsg.hxx"

#include "system.hxx"
#include "ifssys.hxx"
#include "substrng.hxx"

#include "ulibcl.hxx"

#include "keyboard.hxx"

#include "fatvol.hxx"
#include "fatsa.hxx"
#include "rfatsa.hxx"
#include "fat.hxx"

extern "C" {
#include <stdio.h>
}

BOOLEAN HexOutput = FALSE;

BOOLEAN
FatSecList(
    PWSTRING    NtDriveName,
    PPATH       TargetPath,
    PMESSAGE    Message
    )
{
    LOG_IO_DP_DRIVE Drive;
    REAL_FAT_SA FatSa;
    PFAT        Fat;
    ULONG       SectorsPerCluster, Sector, i;
    ULONG       Cluster;

    if( !Drive.Initialize( NtDriveName, Message ) ||
        !FatSa.Initialize( &Drive, Message )      ||
        !FatSa.FAT_SA::Read()                     ||
        !(Fat = FatSa.GetFat()) ) {

        return FALSE;
    }

    SectorsPerCluster = FatSa.QuerySectorsPerCluster();

    Cluster = FatSa.QueryFileStartingCluster( TargetPath->GetPathString() );

    if( Cluster == 1 || Cluster == 0xFFFF ) {

        printf( "File not found.\n" );
        return FALSE;
    }

    if( Cluster == 0 ) {

        // Zero-length file.
        //
        return TRUE;
    }

    while( TRUE ) {

        Sector = (Cluster - FirstDiskCluster) * SectorsPerCluster +
                 FatSa.QueryStartDataLbn();

        for( i = 0; i < SectorsPerCluster; i++ ) {

            if( HexOutput ) {

                printf( "0x%x\n", Sector + i );

            } else {

                printf( "%d\n", Sector + i );
            }
        }

        if( Fat->IsEndOfChain( Cluster ) ) {

            break;
        }

        Cluster = Fat->QueryEntry( Cluster );
    }

    return TRUE;
}


int __cdecl
main(
    int argc,
    char **argv
    )
/*++
--*/
{
    WCHAR PathString[512];
    STR   DisplayBuffer[512];

    PATH Path;
    DSTRING NtDriveName, FsName, HpfsString, NtfsString, FatString;
    STREAM_MESSAGE Message;

    PWSTRING DosDriveName;

    NTSTATUS Status;
    BOOLEAN Result;
    ULONG i, Length;


    if( argc < 2 ) {

        printf( "usage: %s full-path [-x]\n", argv[0] );
        exit(1);
    }

    if( argc >= 3 &&
        argv[2][0] == '-' &&
        argv[2][1] == 'x' ) {

        HexOutput = TRUE;
    }

    if (!Message.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream())) {

        printf( "Can't initialize MESSAGE object.\n" );
        exit(1);
    }

    // Convert argv[1] to a WSTR using brute force.
    //
    Length = strlen( argv[1] );

    for( i = 0; i < Length; i++ ) {

        PathString[i] = argv[1][i];
    }

    PathString[Length] = 0;


    if( !Path.Initialize( PathString, TRUE ) ) {

        printf( "Unable to initialize path object.\n" );
        exit(1);
    }

    // Get the drive from the path and convert it to
    // an NTFS name.
    //
    if( (DosDriveName = Path.QueryDevice()) == NULL ) {

        DELETE( DosDriveName );
        printf( "Cannot get drive from path.\n" );
        exit(1);
    }

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(DosDriveName, &NtDriveName)) {

        DELETE(DosDriveName);
        return 1;
    }

    DELETE( DosDriveName );


    // Determine the file system on the drive.
    //
    if (!IFS_SYSTEM::QueryFileSystemName(&NtDriveName, &FsName, &Status)) {

        printf( "Cannot determine NT Drive name.  (Status = 0x%x\n)", Status );
        exit(1);
    }

    if( !FsName.QuerySTR( 0, TO_END, DisplayBuffer, 512 ) ) {

        printf( "QuerySTR failed.\n" );
        exit(1);
    }

    if( !FatString.Initialize( "FAT" ) ||
        !NtfsString.Initialize( "NTFS" ) ) {

        printf( "Can't initialize file-system name strings.\n" );
        exit(1);
    }

    if( FsName.Stricmp( &FatString ) == 0 ) {

        Result = FatSecList( &NtDriveName, &Path, &Message );

    } else if( FsName.Stricmp( &NtfsString ) == 0 ) {

        printf( "NTFS is not supported.\n" );
        exit(1);
    }

    if( Result ) {

        exit(0);

    } else {

        printf( "Seclist failed.\n" );
        exit(1);
    }
    //NOTREACHED
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\devnode.c ===
//


//  DEVNODE.C
//
#include "sigverif.h"
#include <initguid.h>
#include <devguid.h>

//
// Given the full path to a driver, add it to the file list.
//
LPFILENODE 
AddDriverFileToList(
    LPTSTR lpDirName, 
    LPTSTR lpFullPathName
    )
{
    DWORD                       Err = ERROR_SUCCESS;
    LPFILENODE                  lpFileNode = NULL;
    TCHAR                       szDirName[MAX_PATH];
    TCHAR                       szFileName[MAX_PATH];
    LPTSTR                      lpFilePart = NULL;

    *szDirName  = 0;
    *szFileName = 0;

    //
    // If no directory is passed in, try to get the full path
    //
    if (!lpDirName || !*lpDirName) {

        if (GetFullPathName(lpFullPathName, cA(szDirName), szDirName, &lpFilePart)) {

            if (lpFilePart && *lpFilePart) {
                
                if (SUCCEEDED(StringCchCopy(szFileName, cA(szFileName), lpFilePart))) {
                
                    *lpFilePart = 0;
                    
                    if (lstrlen(szDirName) > 3) {
                    
                        *(lpFilePart - 1) = 0;
                    }
                } else {
                    *szFileName = 0;
                }
            }
        } else {
            *szDirName = 0;
        }

    } else { 
        
        //
        // Use the directory and filename that was passed in to us
        // Expand out lpDirName in case there are any ".." entries
        //
        if (!GetFullPathName(lpDirName, cA(szDirName), szDirName, NULL)) {
            //
            // If we can't get the full path, then just use the one
            // that was passed in. This could happen if the directory
            // is missing for instance.
            //
            if (FAILED(StringCchCopy(szDirName, cA(szDirName), lpDirName))) {
                //
                // If we can't fit the directory name into our buffer then
                // clear szDirName so this node won't be added to the list.
                //
                *szDirName = 0;
            }
        }

        if (FAILED(StringCchCopy(szFileName, cA(szFileName), lpFullPathName))) {
            //
            // If we can't fit the file name into our buffer then
            // clear szFileName so this node won't be added to the list.
            //
            *szFileName = 0;
        }
    }

    if (*szDirName && *szFileName && !IsFileAlreadyInList(szDirName, szFileName)) {
        //
        // Create a filenode, based on the directory and filename
        //
        lpFileNode = CreateFileNode(szDirName, szFileName);

        if (lpFileNode) { 

            InsertFileNodeIntoList(lpFileNode);

            //
            // Increment the total number of files we've found that meet the 
            // search criteria.
            //
            g_App.dwFiles++;
        
        } else {
            
            Err = GetLastError();
        }
    }

    SetLastError(Err);
    return lpFileNode;
}

BOOL
GetFullPathFromImagePath(
    LPCTSTR ImagePath,
    LPTSTR  FullPath,
    UINT    FullPathLength
    )
{
    TCHAR OriginalCurrentDirectory[MAX_PATH];
    LPTSTR pRelativeString;
    LPTSTR lpFilePart;

    if (!ImagePath || (ImagePath[0] == TEXT('\0'))) {
        return FALSE;
    }

    //
    // First check if the ImagePath happens to be a valid full path.
    //
    if (GetFileAttributes(ImagePath) != 0xFFFFFFFF) {
        GetFullPathName(ImagePath, FullPathLength, FullPath, &lpFilePart);
        return TRUE;
    }

    pRelativeString = (LPTSTR)ImagePath;

    //
    // If the ImagePath starts with "\SystemRoot" or "%SystemRoot%" then
    // remove those values.
    //
    if (StrCmpNI(ImagePath, TEXT("\\SystemRoot\\"), lstrlen(TEXT("\\SystemRoot\\"))) == 0) {
        pRelativeString += lstrlen(TEXT("\\SystemRoot\\"));
    } else if (StrCmpNI(ImagePath, TEXT("%SystemRoot%\\"), lstrlen(TEXT("%SystemRoot%\\"))) == 0) {
        pRelativeString += lstrlen(TEXT("%SystemRoot%\\"));
    }

    //
    // At this point pRelativeString should point to the image path relative to
    // the windows directory.
    //
    if (!GetSystemWindowsDirectory(FullPath, FullPathLength)) {
        return FALSE;
    }

    if (!GetCurrentDirectory(cA(OriginalCurrentDirectory), OriginalCurrentDirectory)) {
        OriginalCurrentDirectory[0] = TEXT('\0');
    }

    if (!SetCurrentDirectory(FullPath)) {
        return FALSE;
    }

    GetFullPathName(pRelativeString, FullPathLength, FullPath, &lpFilePart);

    if (OriginalCurrentDirectory[0] != TEXT('\0')) {
        SetCurrentDirectory(OriginalCurrentDirectory);
    }

    return TRUE;
}

DWORD
CreateFromService(
    SC_HANDLE hscManager,
    PCTSTR ServiceName
    )
{
    DWORD Err = ERROR_SUCCESS;
    SC_HANDLE hscService = NULL;
    DWORD BytesRequired, Size;
    TCHAR FullPath[MAX_PATH];
    LPQUERY_SERVICE_CONFIG pqsc;
    PBYTE BufferPtr = NULL;

    if (hscManager == NULL) {
        //
        // This should never happen.
        //
        goto clean0;
    }

    if (!ServiceName ||
        (ServiceName[0] == TEXT('\0'))) {
        //
        // This should also never happen.
        //
        goto clean0;
    }

    hscService =  OpenService(hscManager, ServiceName, GENERIC_READ);
    if (NULL == hscService) {
        //
        // This service does not exist.  We won't return an error in this case
        // since if the service doesn't exist then the driver won't get
        // loaded.
        //
        goto clean0;
    }

    //
    // First, probe for buffer size
    //
    if (!QueryServiceConfig(hscService, NULL, 0, &BytesRequired) &&
        ERROR_INSUFFICIENT_BUFFER == GetLastError()) {

        BufferPtr = MALLOC(BytesRequired);
        
        if (!BufferPtr) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        pqsc = (LPQUERY_SERVICE_CONFIG)(PBYTE)BufferPtr;

        if (QueryServiceConfig(hscService, pqsc, BytesRequired, &Size) &&
            pqsc->lpBinaryPathName &&
            (TEXT('\0') != pqsc->lpBinaryPathName[0])) {
            //
            // Make sure we have a valid full path.
            //
            if (GetFullPathFromImagePath(pqsc->lpBinaryPathName,
                                         FullPath,
                                         cA(FullPath))) {

                AddDriverFileToList(NULL, FullPath);
            }
        }

        FREE(BufferPtr);
    }

clean0:

    if (hscService) {
        CloseServiceHandle(hscService);
        hscService = NULL;
    }

    if (BufferPtr) {
        FREE(BufferPtr);
    }

    return Err;
}

UINT
ScanQueueCallback(
    PVOID Context,
    UINT Notification,
    UINT_PTR Param1,
    UINT_PTR Param2
    )
{
    LPFILENODE  lpFileNode;
    TCHAR       szBuffer[MAX_PATH];
    LPTSTR      lpFilePart;
    ULONG       BufCbSize;
    HRESULT     hr;

    UNREFERENCED_PARAMETER(Param2);

    if ((Notification == SPFILENOTIFY_QUEUESCAN_SIGNERINFO) &&
        Param1) {
        //
        // Special case for printers:
        // After setupapi copies files from the file queue into their destination
        // location, the printer class installer moves some of these files into
        // other 'special' locations.  This can lead to the callback Win32Error
        // returning ERROR_FILE_NOT_FOUND or ERROR_PATH_NOT_FOUND since the file 
        // is not present in the location where setupapi put it.  So, we will 
        // catch this case for printers and not add the file to our list of 
        // files to scan.  These 'special' printer files will get added later 
        // when we call the spooler APIs.
        // Also note that we can't just skip getting the list of files for printers
        // altogether since the printer class installer only moves some of the 
        // files that setupapi copies and not all of them.
        //
        if (Context &&
            (IsEqualGUID((LPGUID)Context, &GUID_DEVCLASS_PRINTER)) &&
            ((((PFILEPATHS_SIGNERINFO)Param1)->Win32Error == ERROR_FILE_NOT_FOUND) ||
             (((PFILEPATHS_SIGNERINFO)Param1)->Win32Error == ERROR_PATH_NOT_FOUND))) {
            //
            // Assume this was a file moved by the printer class installer.  Don't
            // add it to the list of files to be scanned at this time.
            //
            return NO_ERROR;
        }

        lpFileNode = AddDriverFileToList(NULL, 
                                         (LPTSTR)((PFILEPATHS_SIGNERINFO)Param1)->Target);

        //
        // Fill in some information into the FILENODE structure since we already
        // scanned the file.
        //
        if (lpFileNode) {
        
            lpFileNode->bScanned = TRUE;

            if ((((PFILEPATHS_SIGNERINFO)Param1)->Win32Error == NO_ERROR) ||
                ((!g_App.bNoAuthenticode) &&
                 ((((PFILEPATHS_SIGNERINFO)Param1)->Win32Error == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                  (((PFILEPATHS_SIGNERINFO)Param1)->Win32Error == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)))) {
                lpFileNode->bSigned = TRUE;
            } else {
                lpFileNode->bSigned = FALSE;
            }

            if (lpFileNode->bSigned) {
        
                if (((PFILEPATHS_SIGNERINFO)Param1)->CatalogFile) {
                
                    GetFullPathName(((PFILEPATHS_SIGNERINFO)Param1)->CatalogFile, cA(szBuffer), szBuffer, &lpFilePart);
    
                    BufCbSize = (lstrlen(lpFilePart) + 1) * sizeof(TCHAR);
                    lpFileNode->lpCatalog = MALLOC(BufCbSize);
            
                    if (lpFileNode->lpCatalog) {
            
                        hr = StringCbCopy(lpFileNode->lpCatalog, BufCbSize, lpFilePart);
                    
                        if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                            //
                            // If we fail for some reason other than insufficient
                            // buffer, then free the string and set the pointer
                            // to NULL, since the string is undefined.
                            //
                            FREE(lpFileNode->lpCatalog);
                            lpFileNode->lpCatalog = NULL;
                        }
                    }
                }
        
                if (((PFILEPATHS_SIGNERINFO)Param1)->DigitalSigner) {
                
                    BufCbSize = (lstrlen(((PFILEPATHS_SIGNERINFO)Param1)->DigitalSigner) + 1) * sizeof(TCHAR);
                    lpFileNode->lpSignedBy = MALLOC(BufCbSize);
            
                    if (lpFileNode->lpSignedBy) {
            
                        hr = StringCbCopy(lpFileNode->lpSignedBy, BufCbSize, ((PFILEPATHS_SIGNERINFO)Param1)->DigitalSigner);
                    
                        if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                            //
                            // If we fail for some reason other than insufficient
                            // buffer, then free the string and set the pointer
                            // to NULL, since the string is undefined.
                            //
                            FREE(lpFileNode->lpSignedBy);
                            lpFileNode->lpSignedBy = NULL;
                        }
                    }
                }
        
                if (((PFILEPATHS_SIGNERINFO)Param1)->Version) {
                
                    BufCbSize = (lstrlen(((PFILEPATHS_SIGNERINFO)Param1)->Version) + 1) * sizeof(TCHAR);
                    lpFileNode->lpVersion = MALLOC(BufCbSize);
            
                    if (lpFileNode->lpVersion) {
            
                        hr = StringCbCopy(lpFileNode->lpVersion, BufCbSize, ((PFILEPATHS_SIGNERINFO)Param1)->Version);
                    
                        if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                            //
                            // If we fail for some reason other than insufficient
                            // buffer, then free the string and set the pointer
                            // to NULL, since the string is undefined.
                            //
                            FREE(lpFileNode->lpVersion);
                            lpFileNode->lpVersion = NULL;
                        }
                    }
                }
    
            } else {
                // 
                // Get the icon (if the file isn't signed) so we can display it in the listview faster.
                //
                MyGetFileInfo(lpFileNode);
            }
        }
    }

    return NO_ERROR;
}

void
AddClassInstallerToList(
    LPCTSTR ClassInstallerString
    )
{
    DWORD BufferSize;
    TCHAR ModulePath[MAX_PATH];
    TCHAR TempBuffer[MAX_PATH];
    PTSTR StringPtr;

    if ((ClassInstallerString == NULL) ||
        (ClassInstallerString[0] == TEXT('\0'))) {
        return;
    }

    if (FAILED(StringCchCopy(TempBuffer, cA(TempBuffer), ClassInstallerString))) {
        return;
    }

    //
    // Class/Co-installers are always based under the %windir%\system32 
    // directory.
    //
    if (GetSystemDirectory(ModulePath, cA(ModulePath)) == 0) {
        return;
    }

    //
    // Find the beginning of the entry point name, if present.
    //
    BufferSize = (lstrlen(TempBuffer) + 1) * sizeof(TCHAR);
    for(StringPtr = TempBuffer + ((BufferSize / sizeof(TCHAR)) - 2);
        StringPtr >= TempBuffer;
        StringPtr--) {

        if(*StringPtr == TEXT(',')) {
            *(StringPtr++) = TEXT('\0');
            break;
        }
        //
        // If we hit a double-quote mark, then set the character pointer
        // to the beginning of the string so we'll terminate the search.
        //
        if(*StringPtr == TEXT('\"')) {
            StringPtr = TempBuffer;
        }
    }

    if (pSetupConcatenatePaths(ModulePath, TempBuffer, MAX_PATH, NULL)) {
        AddDriverFileToList(NULL, ModulePath);
    }
}

DWORD 
BuildDriverFileList(
    void
    )
{
    DWORD Err = ERROR_SUCCESS;
    HDEVINFO hDeviceInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DeviceInfoData;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    DWORD DeviceMemberIndex;
    HSPFILEQ hFileQueue;
    DWORD ScanResult;
    DWORD Status, Problem;
    SC_HANDLE hscManager = NULL;
    TCHAR Buffer[MAX_PATH];
    ULONG BufferSize;
    DWORD dwType;
    HKEY hKey = INVALID_HANDLE_VALUE, hKeyClassCoInstallers = INVALID_HANDLE_VALUE;
    PTSTR pItemList = NULL, pSingleItem;
    LPGUID ClassGuidList = NULL;
    DWORD i, NumberClassGuids, CurrentClassGuid;
    TCHAR GuidString[MAX_GUID_STRING_LEN];

    //
    // Build up a list of all the devices in the system.
    //
    hDeviceInfo = SetupDiGetClassDevs(NULL,
                                      NULL,
                                      NULL,
                                      DIGCF_ALLCLASSES
                                      );
    
    if (hDeviceInfo == INVALID_HANDLE_VALUE) {
        Err = GetLastError();
        goto clean0;
    }

    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    DeviceMemberIndex = 0;

    //
    // Enumerate through the list of devices and get a list of all 
    // the files they copy, if they are signed or not, and which catalog
    // signed them.
    //
    while (SetupDiEnumDeviceInfo(hDeviceInfo,
                                 DeviceMemberIndex++,
                                 &DeviceInfoData
                                 ) &&
           !g_App.bStopScan) {

        //
        // We will only build up a driver list for swenum phantoms. All other
        // phantoms will be skipped.
        //
        if (CM_Get_DevNode_Status(&Status, 
                                  &Problem, 
                                  DeviceInfoData.DevInst, 
                                  0) == CR_NO_SUCH_DEVINST) {
            //
            // This device is a phantom, if it is not a swenum device, then
            // skip it.
            //
            if (!SetupDiGetDeviceRegistryProperty(hDeviceInfo,
                                                  &DeviceInfoData,
                                                  SPDRP_ENUMERATOR_NAME,
                                                  NULL,
                                                  (PBYTE)Buffer,
                                                  sizeof(Buffer),
                                                  NULL) ||
                (_wcsicmp(Buffer, TEXT("SW")) != 0)) {
                //
                // Either we couldn't get the enumerator name, or it is not 
                // SW.
                //
                continue;
            }
        }
    
        DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);

        //
        // Before we call SetupDiBuildDriverInfoList to build up a list of drivers
        // for this device we first need to set the DI_FLAGSEX_INSTALLEDDRIVER flag
        // (which tells the API to only include the currently installed driver in
        // the list) and the DI_FLAGSEX_ALLOWEXCLUDEDRVS (allow ExcludeFromSelect
        // devices in the list).
        //
        if (SetupDiGetDeviceInstallParams(hDeviceInfo,
                                          &DeviceInfoData,
                                          &DeviceInstallParams
                                          )) {
            
            DeviceInstallParams.FlagsEx = (DI_FLAGSEX_INSTALLEDDRIVER |
                                           DI_FLAGSEX_ALLOWEXCLUDEDDRVS);

            if (SetupDiSetDeviceInstallParams(hDeviceInfo,
                                              &DeviceInfoData,
                                              &DeviceInstallParams
                                              ) &&
                SetupDiBuildDriverInfoList(hDeviceInfo,
                                           &DeviceInfoData,
                                           SPDIT_CLASSDRIVER
                                           )) {

                //
                // Now we will get the one driver node that is in the list that
                // was just built and make it the selected driver node.
                //
                DriverInfoData.cbSize = sizeof(DriverInfoData);

                if (SetupDiEnumDriverInfo(hDeviceInfo,
                                          &DeviceInfoData,
                                          SPDIT_CLASSDRIVER,
                                          0,
                                          &DriverInfoData
                                          ) &&
                    SetupDiSetSelectedDriver(hDeviceInfo,
                                             &DeviceInfoData,
                                             &DriverInfoData
                                             )) {

                    hFileQueue = SetupOpenFileQueue();

                    if (hFileQueue != INVALID_HANDLE_VALUE) {

                        //
                        // Set the FileQueue parameter to the file queue we just 
                        // created and set the DI_NOVCP flag.
                        //
                        // The call SetupDiCallClassInstaller with DIF_INSTALLDEVICEFILES
                        // to build up a queue of all the files that are copied for
                        // this driver node.
                        //
                        DeviceInstallParams.FileQueue = hFileQueue;
                        DeviceInstallParams.Flags |= DI_NOVCP;

                        if (SetupDiSetDeviceInstallParams(hDeviceInfo,
                                                          &DeviceInfoData,
                                                          &DeviceInstallParams
                                                          ) &&
                            SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                                      hDeviceInfo,
                                                      &DeviceInfoData
                                                      )) {

                            //
                            // Scan the file queue and have it call our callback
                            // function for each file in the queue.
                            //
                            SetupScanFileQueue(hFileQueue,
                                               SPQ_SCAN_USE_CALLBACK_SIGNERINFO,
                                               NULL,
                                               ScanQueueCallback,
                                               (PVOID)&(DeviceInfoData.ClassGuid),
                                               &ScanResult
                                               );

                                                            
                            //
                            // Dereference the file queue so we can close it.
                            //
                            DeviceInstallParams.FileQueue = NULL;
                            DeviceInstallParams.Flags &= ~DI_NOVCP;
                            SetupDiSetDeviceInstallParams(hDeviceInfo,
                                                          &DeviceInfoData,
                                                          &DeviceInstallParams
                                                          );
                        }

                        SetupCloseFileQueue(hFileQueue);
                    }
                }

                SetupDiDestroyDriverInfoList(hDeviceInfo,
                                             &DeviceInfoData,
                                             SPDIT_CLASSDRIVER
                                             );
            }
        }
    }

    //
    // Enumerate through the list of devices and add any function, device 
    // upper/lower filters, and class upper/lower filter drivers to the list
    // that aren't already in the list.
    // We are doing this after we get all the files copied by the INF, because
    // these files can only be validated globally, where the INF copied files
    // can be validated using the catalog associated with their package.
    //
    hscManager = OpenSCManager(NULL, NULL, GENERIC_READ);

    if (hscManager) {
        DeviceInfoData.cbSize = sizeof(DeviceInfoData);
        DeviceMemberIndex = 0;
        while (SetupDiEnumDeviceInfo(hDeviceInfo,
                                     DeviceMemberIndex++,
                                     &DeviceInfoData
                                     ) &&
               !g_App.bStopScan) {
            //
            // Only look at SWENUM phantoms
            //
            if (CM_Get_DevNode_Status(&Status, 
                                      &Problem, 
                                      DeviceInfoData.DevInst, 
                                      0) == CR_NO_SUCH_DEVINST) {
                //
                // This device is a phantom, if it is not a swenum device, then
                // skip it.
                //
                if (!SetupDiGetDeviceRegistryProperty(hDeviceInfo,
                                                      &DeviceInfoData,
                                                      SPDRP_ENUMERATOR_NAME,
                                                      NULL,
                                                      (PBYTE)Buffer,
                                                      sizeof(Buffer),
                                                      NULL) ||
                    (_wcsicmp(Buffer, TEXT("SW")) != 0)) {
                    //
                    // Either we couldn't get the enumerator name, or it is not 
                    // SW.
                    //
                    continue;
                }
            }
    
            if (g_App.bStopScan) {
                continue;
            }
    
            //
            // Function driver.
            //
            if (SetupDiGetDeviceRegistryProperty(hDeviceInfo,
                                                 &DeviceInfoData,
                                                 SPDRP_SERVICE,
                                                 NULL,
                                                 (PBYTE)Buffer,
                                                 sizeof(Buffer),
                                                 NULL)) {
                CreateFromService(hscManager, Buffer);
            }
    
            if (g_App.bStopScan) {
                continue;
            }
    
            //
            // Upper and Lower device filters
            //
            for (i=0; i<2; i++) {
                BufferSize = 0;
                SetupDiGetDeviceRegistryProperty(hDeviceInfo,
                                                 &DeviceInfoData,
                                                 i ? SPDRP_LOWERFILTERS : SPDRP_UPPERFILTERS,
                                                 NULL,
                                                 NULL,
                                                 BufferSize,
                                                 &BufferSize);
            
                if (BufferSize > 0) {
                    pItemList = MALLOC(BufferSize + (2 * sizeof(TCHAR)));
        
                    if (!pItemList) {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }
        
                    if (SetupDiGetDeviceRegistryProperty(hDeviceInfo,
                                                         &DeviceInfoData,
                                                         i ? SPDRP_LOWERFILTERS : SPDRP_UPPERFILTERS,
                                                         NULL,
                                                         (PBYTE)pItemList,
                                                         BufferSize,
                                                         &BufferSize)) {
                        for (pSingleItem=pItemList;
                             *pSingleItem;
                             pSingleItem += (lstrlen(pSingleItem) + 1)) {
    
                            CreateFromService(hscManager, pSingleItem);
                        }
                    }
    
                    FREE(pItemList);
                }
            }
    
            if (g_App.bStopScan) {
                continue;
            }
    
            //
            // Device co-installers.
            //
            hKey = SetupDiOpenDevRegKey(hDeviceInfo,
                                        &DeviceInfoData,
                                        DICS_FLAG_GLOBAL,
                                        0,
                                        DIREG_DRV,
                                        KEY_READ);
            
            if (hKey != INVALID_HANDLE_VALUE) {

                BufferSize = 0;
                RegQueryValueEx(hKey,
                                REGSTR_VAL_COINSTALLERS_32,
                                NULL,
                                &dwType,
                                NULL,
                                &BufferSize);

                if (BufferSize > 0) {
                    pItemList = MALLOC(BufferSize + (2 * sizeof(TCHAR)));
    
                    if (!pItemList) {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }
    
                    dwType = REG_MULTI_SZ;
                    if (RegQueryValueEx(hKey,
                                        REGSTR_VAL_COINSTALLERS_32,
                                        NULL,
                                        &dwType,
                                        (PBYTE)pItemList,
                                        &BufferSize) == ERROR_SUCCESS) {

                        for (pSingleItem=pItemList;
                             *pSingleItem;
                             pSingleItem += (lstrlen(pSingleItem) + 1)) {
                            
                            AddClassInstallerToList(pSingleItem);
                        }
                    }

                    FREE(pItemList);
                }

                RegCloseKey(hKey);
                hKey = INVALID_HANDLE_VALUE;
            }
        }

        //
        // Enumerate through the classes so we can get the class upper and
        // lower filters and the class installers.
        //
        NumberClassGuids = 0;
        SetupDiBuildClassInfoList(0, NULL, 0, &NumberClassGuids);

        if (NumberClassGuids > 0) {
        
            ClassGuidList = MALLOC(NumberClassGuids * sizeof(GUID));

            if (!ClassGuidList) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            if (SetupDiBuildClassInfoList(0, ClassGuidList, NumberClassGuids, &NumberClassGuids)) {
                //
                // Open the class co-installer key since we will go through that
                // list while we have the class guids handy.
                //
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 REGSTR_PATH_CODEVICEINSTALLERS,
                                 0,
                                 KEY_READ,
                                 &hKeyClassCoInstallers) != ERROR_SUCCESS) {
                    hKeyClassCoInstallers = INVALID_HANDLE_VALUE;
                }
    
    
                for (CurrentClassGuid=0; CurrentClassGuid<NumberClassGuids; CurrentClassGuid++) {
                    //
                    // Open the class key.
                    //
                    hKey = SetupDiOpenClassRegKey(&(ClassGuidList[CurrentClassGuid]),
                                                  KEY_READ);
    
                    if (hKey != INVALID_HANDLE_VALUE) {
    
                        //
                        // Upper and Lower class filters
                        //
                        for (i=0; i<2; i++) {
                            BufferSize = 0;
                            RegQueryValueEx(hKey,
                                            i ? REGSTR_VAL_LOWERFILTERS : REGSTR_VAL_UPPERFILTERS,
                                            NULL,
                                            &dwType,
                                            NULL,
                                            &BufferSize);
    
                            if (BufferSize > 0) {
                                pItemList = MALLOC(BufferSize + (2 * sizeof(TCHAR)));
        
                                if (!pItemList) {
                                    Err = ERROR_NOT_ENOUGH_MEMORY;
                                    goto clean0;
                                }
        
                                dwType = REG_MULTI_SZ;
                                if (RegQueryValueEx(hKey,
                                                    i ? REGSTR_VAL_LOWERFILTERS : REGSTR_VAL_UPPERFILTERS,
                                                    NULL,
                                                    &dwType,
                                                    (PBYTE)pItemList,
                                                    &BufferSize) == ERROR_SUCCESS) {
    
                                    for (pSingleItem=pItemList;
                                         *pSingleItem;
                                         pSingleItem += (lstrlen(pSingleItem) + 1)) {
    
                                        CreateFromService(hscManager, pSingleItem);
                                    }
                                }
    
                                FREE(pItemList);
                            }
                        }
    
                        //
                        // Class installer
                        //
                        dwType = REG_SZ;
                        BufferSize = sizeof(Buffer);
                        if (RegQueryValueEx(hKey,
                                            REGSTR_VAL_INSTALLER_32,
                                            NULL,
                                            &dwType,
                                            (PBYTE)Buffer,
                                            &BufferSize) == ERROR_SUCCESS) {
                            
                            AddClassInstallerToList(Buffer);
                        }
    
                        RegCloseKey(hKey);
                        hKey = INVALID_HANDLE_VALUE;
                    }
    
                    //
                    // Class co-installers.
                    //
                    if (hKeyClassCoInstallers != INVALID_HANDLE_VALUE) {
                        if (pSetupStringFromGuid(&(ClassGuidList[CurrentClassGuid]),
                                                 GuidString,
                                                 cA(GuidString)) == ERROR_SUCCESS) {
                            BufferSize = 0;
                            RegQueryValueEx(hKeyClassCoInstallers,
                                            GuidString,
                                            NULL,
                                            &dwType,
                                            NULL,
                                            &BufferSize);
            
                            if (BufferSize > 0) {
                                pItemList = MALLOC(BufferSize + (2 * sizeof(TCHAR)));
                
                                if (!pItemList) {
                                    Err = ERROR_NOT_ENOUGH_MEMORY;
                                    goto clean0;
                                }
                
                                dwType = REG_MULTI_SZ;
                                if (RegQueryValueEx(hKeyClassCoInstallers,
                                                    GuidString,
                                                    NULL,
                                                    &dwType,
                                                    (PBYTE)pItemList,
                                                    &BufferSize) == ERROR_SUCCESS) {
            
                                    for (pSingleItem=pItemList;
                                         *pSingleItem;
                                         pSingleItem += (lstrlen(pSingleItem) + 1)) {
                                        
                                        AddClassInstallerToList(pSingleItem);
                                    }
                                }
            
                                FREE(pItemList);
                            }
                        }
                    }
                }
            }

            if (hKeyClassCoInstallers != INVALID_HANDLE_VALUE) {
                RegCloseKey(hKeyClassCoInstallers);
                hKeyClassCoInstallers = INVALID_HANDLE_VALUE;
            }

            FREE(ClassGuidList);
        }

        CloseServiceHandle(hscManager);
    }

clean0:
    if (hscManager) {
        CloseServiceHandle(hscManager);
    }

    if (pItemList) {
        FREE(pItemList);
    }

    if (ClassGuidList) {
        FREE(ClassGuidList);
    }

    if (hDeviceInfo != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(hDeviceInfo);
    }

    if (hKeyClassCoInstallers != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyClassCoInstallers);
        hKeyClassCoInstallers = INVALID_HANDLE_VALUE;
    }
    
    if (hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
        hKey = INVALID_HANDLE_VALUE;
    }

    return Err;
}

DWORD 
BuildPrinterFileList(
    void
    )
{
    DWORD           Err = ERROR_SUCCESS;
    BOOL            bRet;
    DWORD           dwBytesNeeded = 0;
    DWORD           dwDrivers = 0;
    LPBYTE          lpBuffer = NULL, lpTemp = NULL;
    LPTSTR          lpFileName;
    DRIVER_INFO_3   DriverInfo;
    PDRIVER_INFO_3  lpDriverInfo;
    TCHAR           szBuffer[MAX_PATH];
    LPFILENODE      lpFileNode = NULL;

    ZeroMemory(&DriverInfo, sizeof(DRIVER_INFO_3));
    bRet = EnumPrinterDrivers(  NULL,
                                SIGVERIF_PRINTER_ENV,
                                3,
                                (LPBYTE) &DriverInfo,
                                sizeof(DRIVER_INFO_3),
                                &dwBytesNeeded,
                                &dwDrivers);

    if (!bRet && dwBytesNeeded > 0) {
        
        lpBuffer = MALLOC(dwBytesNeeded);

        //
        // If we can't get any memory then just bail out of this function
        //
        if (!lpBuffer) {

            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
        
        bRet = EnumPrinterDrivers(  NULL,
                                    SIGVERIF_PRINTER_ENV,
                                    3,
                                    (LPBYTE) lpBuffer,
                                    dwBytesNeeded,
                                    &dwBytesNeeded,
                                    &dwDrivers);
    }

    if (dwDrivers > 0) {
        
        //
        // By default, go into the System directory, since Win9x doesn't give full paths to drivers.
        //
        GetSystemDirectory(szBuffer, cA(szBuffer));
        SetCurrentDirectory(szBuffer);

        for (lpTemp = lpBuffer; dwDrivers > 0; dwDrivers--) {
            
            lpDriverInfo = (PDRIVER_INFO_3) lpTemp;
            
            if (lpDriverInfo->pName) {
                
                if (lpDriverInfo->pDriverPath && *lpDriverInfo->pDriverPath) {
                    lpFileNode = AddDriverFileToList(NULL, lpDriverInfo->pDriverPath);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }
                }
                
                if (lpDriverInfo->pDataFile && *lpDriverInfo->pDataFile) {
                    lpFileNode = AddDriverFileToList(NULL, lpDriverInfo->pDataFile);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }
                }
                
                if (lpDriverInfo->pConfigFile && *lpDriverInfo->pConfigFile) {
                    lpFileNode = AddDriverFileToList(NULL, lpDriverInfo->pConfigFile);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }
                }
                
                if (lpDriverInfo->pHelpFile && *lpDriverInfo->pHelpFile) {
                    lpFileNode = AddDriverFileToList(NULL, lpDriverInfo->pHelpFile);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }
                }

                lpFileName = lpDriverInfo->pDependentFiles;
                
                while (lpFileName && *lpFileName) {
                    
                    lpFileNode = AddDriverFileToList(NULL, lpFileName);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }

                    for (;*lpFileName;lpFileName++);
                    lpFileName++;
                }
            }
            
            lpTemp += sizeof(DRIVER_INFO_3);
        }
    }

clean0:
    if (lpBuffer) {
    
        FREE(lpBuffer);
    }

    return Err;
}

DWORD 
BuildCoreFileList(
    void
    )
{
    DWORD Err = ERROR_SUCCESS;
    PROTECTED_FILE_DATA pfd;

    pfd.FileNumber = 0;

    while (SfcGetNextProtectedFile(NULL, &pfd)) {

        if (g_App.bStopScan) {
            Err = ERROR_CANCELLED;
            break;
        }

        AddDriverFileToList(NULL, pfd.FileName);
    }

    //
    // See if SfcGetNextProtectedFile failed from some reason other than
    // ERROR_NO_MORE_FILES.
    //
    if ((Err == ERROR_SUCCESS) &&
        (GetLastError() != ERROR_NO_MORE_FILES)) {
        //
        // SfcGetNextProtectedFile failed before we reached then end of the
        // list of protected file list. This means we won't scan all the 
        // protected files, so we should fail up front!
        //
        Err = GetLastError();
    }

    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\filelist.c ===
//
//  FILELIST.C
//
#include "sigverif.h"

LPTSTR 
MyStrStr(
    LPTSTR lpString, 
    LPTSTR lpSubString
    )
{
    if (!lpString || !lpSubString) {
        return NULL;
    }

    return (StrStrI(lpString, lpSubString));
}

void 
InsertFileNodeIntoList(
    LPFILENODE lpFileNode
    )
{
    LPFILENODE  lpTempNode = g_App.lpFileList;
    LPFILENODE  lpPrevNode = NULL;
    INT         iRet;

    if (!lpFileNode) {
        return;
    }

    if (!g_App.lpFileList) {
        //
        // Initialize the global file lists
        //
        g_App.lpFileList = lpFileNode;
        g_App.lpFileLast = lpFileNode;
    
    } else {
        
        for(lpTempNode=g_App.lpFileList;lpTempNode;lpTempNode=lpTempNode->next) {
            //
            // Insert items sorted by directory and then filename
            //
            iRet = lstrcmp(lpTempNode->lpDirName, lpFileNode->lpDirName);
            if (iRet == 0) {
                //
                // If the directory names match, key off the filename
                //
                iRet = lstrcmp(lpTempNode->lpFileName, lpFileNode->lpFileName);
            }

            if (iRet >= 0) {
                
                if (!lpPrevNode) {
                    //
                    // Insert at the head of the list
                    //
                    lpFileNode->next = lpTempNode;
                    g_App.lpFileList = lpFileNode;
                    return;
                
                } else {
                    //
                    // Inserting between lpPrevNode and lpTempNode
                    //
                    lpFileNode->next = lpTempNode;
                    lpPrevNode->next = lpFileNode;
                    return;
                }
            }

            lpPrevNode = lpTempNode;
        }

        //
        // There were no matches, so insert this item at the end of the list
        //
        g_App.lpFileLast->next = lpFileNode;
        g_App.lpFileLast = lpFileNode;
    }
}

BOOL 
IsFileAlreadyInList(
    LPTSTR lpDirName, 
    LPTSTR lpFileName
    )
{
    LPFILENODE lpFileNode;

    CharLowerBuff(lpDirName, lstrlen(lpDirName));
    CharLowerBuff(lpFileName, lstrlen(lpFileName));

    for(lpFileNode=g_App.lpFileList;lpFileNode;lpFileNode=lpFileNode->next) {

        if (!lstrcmp(lpFileNode->lpFileName, lpFileName) && !lstrcmp(lpFileNode->lpDirName, lpDirName)) {
            return TRUE;
        }
    }

    return FALSE;
}

//
// Free all the memory allocated in a single File Node.
//
void 
DestroyFileNode(
    LPFILENODE lpFileNode
    )
{
    if (!lpFileNode) {
        return;
    }

    if (lpFileNode->lpFileName) {
        FREE(lpFileNode->lpFileName);
    }

    if (lpFileNode->lpDirName) {
        FREE(lpFileNode->lpDirName);
    }

    if (lpFileNode->lpVersion) {
        FREE(lpFileNode->lpVersion);
    }

    if (lpFileNode->lpCatalog) {
        FREE(lpFileNode->lpCatalog);
    }

    if (lpFileNode->lpSignedBy) {
        FREE(lpFileNode->lpSignedBy);
    }

    if (lpFileNode->lpTypeName) {
        FREE(lpFileNode->lpTypeName);
    }

    if (lpFileNode) {
        FREE(lpFileNode);
        lpFileNode = NULL;
    }
}

//
// Free all the memory allocated in the g_App.lpFileList.
//
void 
DestroyFileList(
    BOOL bClear
    )
{
    LPFILENODE lpFileNode;

    while(g_App.lpFileList) {

        lpFileNode = g_App.lpFileList->next;
        DestroyFileNode(g_App.lpFileList);
        g_App.lpFileList = lpFileNode;
    }

    g_App.lpFileLast = NULL;

    if (bClear) {
        g_App.dwFiles    = 0;
        g_App.dwSigned   = 0;
        g_App.dwUnsigned = 0;
    }
}

LPFILENODE 
CreateFileNode(
    LPTSTR lpDirectory, 
    LPTSTR lpFileName
    )
{
    DWORD                       Err = ERROR_SUCCESS;
    LPFILENODE                  lpFileNode;
    TCHAR                       szDirName[MAX_PATH];
    TCHAR                       szFullPathName[MAX_PATH];
    FILETIME                    ftLocalTime;
    WIN32_FILE_ATTRIBUTE_DATA   faData;
    BOOL                        bRet;
    ULONG                       BufCbSize;
    
    lpFileNode = (LPFILENODE) MALLOC(sizeof(FILENODE));

    if (!lpFileNode) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    BufCbSize = (lstrlen(lpFileName) + 1) * sizeof(TCHAR);
    lpFileNode->lpFileName = (LPTSTR)MALLOC(BufCbSize);

    if (!lpFileNode->lpFileName) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }
    
    StringCbCopy(lpFileNode->lpFileName, BufCbSize, lpFileName);
    CharLowerBuff(lpFileNode->lpFileName, lstrlen(lpFileNode->lpFileName));

    if (lpDirectory) {

        BufCbSize = (lstrlen(lpDirectory) + 1) * sizeof(TCHAR);
        lpFileNode->lpDirName = (LPTSTR)MALLOC(BufCbSize);
        
        if (!lpFileNode->lpDirName) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
            
        StringCbCopy(lpFileNode->lpDirName, BufCbSize, lpDirectory);
        CharLowerBuff(lpFileNode->lpDirName, lstrlen(lpFileNode->lpDirName));
    
    } else {

        if (GetCurrentDirectory(cA(szDirName), szDirName) == 0) {
            Err = GetLastError();
            goto clean0;
        }

        CharLowerBuff(szDirName, lstrlen(szDirName));

        BufCbSize = (lstrlen(szDirName) + 1) * sizeof(TCHAR);
        lpFileNode->lpDirName = (LPTSTR)MALLOC(BufCbSize);

        if (!lpFileNode->lpDirName) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
        
        StringCbCopy(lpFileNode->lpDirName, BufCbSize, szDirName);
        CharLowerBuff(lpFileNode->lpDirName, lstrlen(lpFileNode->lpDirName));
    }

    //
    // Store away the last access time for logging purposes.
    //
    if (SUCCEEDED(StringCchCopy(szFullPathName, cA(szFullPathName), lpFileNode->lpDirName)) &&
        pSetupConcatenatePaths(szFullPathName, lpFileName, cA(szFullPathName), NULL)) {
    
        ZeroMemory(&faData, sizeof(WIN32_FILE_ATTRIBUTE_DATA));

        bRet = GetFileAttributesEx(szFullPathName, GetFileExInfoStandard, &faData);
        if (bRet) {
            
            FileTimeToLocalFileTime(&faData.ftLastWriteTime, &ftLocalTime);
            FileTimeToSystemTime(&ftLocalTime, &lpFileNode->LastModified);
        }
    }

clean0:

    if (Err != ERROR_SUCCESS) {
        //
        // If we get here then we weren't able to allocate all of the memory needed
        // for this structure, so free up any memory we were able to allocate and
        // reutrn NULL.
        //
        if (lpFileNode) {
    
            if (lpFileNode->lpFileName) {
                FREE(lpFileNode->lpFileName);
            }
    
            if (lpFileNode->lpDirName) {
                FREE(lpFileNode->lpDirName);
            }
    
            FREE(lpFileNode);
        }

        lpFileNode = NULL;
    }

    SetLastError(Err);
    return lpFileNode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\logfile.c ===
//
// LOGFILE.C
//
#include "sigverif.h"

//
// We need to remember the previous logging state when we do toggling.
//
BOOL    g_bPrevLoggingEnabled = FALSE;

BOOL 
LogFile_OnInitDialog(
    HWND hwnd, 
    HWND hwndFocus, 
    LPARAM lParam
    )
{   
    TCHAR   szBuffer[MAX_PATH];

    UNREFERENCED_PARAMETER(hwndFocus);
    UNREFERENCED_PARAMETER(lParam);

    if (g_App.hIcon) {
        
        SetWindowLongPtr(hwnd, GCLP_HICON, (LONG_PTR) g_App.hIcon); 
    }

    g_App.hLogging = hwnd;

    g_bPrevLoggingEnabled = g_App.bLoggingEnabled;

    if (*g_App.szLogDir) {
        SetCurrentDirectory(g_App.szLogDir);
    } else {
        if (GetWindowsDirectory(szBuffer, cA(szBuffer))) {
            SetCurrentDirectory(szBuffer);
        }
    }
    
    SetDlgItemText(hwnd, IDC_LOGNAME, g_App.szLogFile);

    CheckDlgButton(hwnd, IDC_ENABLELOG, g_App.bLoggingEnabled ? BST_CHECKED : BST_UNCHECKED);

    EnableWindow(GetDlgItem(hwnd, IDC_VIEWLOG), g_App.bLoggingEnabled && EXIST(g_App.szLogFile));

    CheckRadioButton(hwnd, IDC_OVERWRITE, IDC_APPEND, g_App.bOverwrite ? IDC_OVERWRITE : IDC_APPEND);
    EnableWindow(GetDlgItem(hwnd, IDC_APPEND), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_OVERWRITE), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_LOGNAME), g_App.bLoggingEnabled);

    SetForegroundWindow(g_App.hDlg);
    SetForegroundWindow(hwnd);

    return TRUE;
}

void 
LogFile_UpdateDialog(
    HWND hwnd
    )
{
    TCHAR szBuffer[MAX_PATH];

    if (GetDlgItemText(hwnd, IDC_LOGNAME, szBuffer, cA(szBuffer))) {

        EnableWindow(GetDlgItem(hwnd, IDC_VIEWLOG), g_App.bLoggingEnabled && EXIST(szBuffer));

    } else {

        EnableWindow(GetDlgItem(hwnd, IDC_VIEWLOG), FALSE);
    }

    EnableWindow(GetDlgItem(hwnd, IDC_APPEND), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_OVERWRITE), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_LOGNAME), g_App.bLoggingEnabled);
}

void 
LogFile_OnViewLog(
    HWND hwnd
    )
{
    TCHAR szDirName[MAX_PATH];
    TCHAR szFileName[MAX_PATH];

    if (!GetWindowsDirectory(szDirName, cA(szDirName))) {

        szDirName[0] = TEXT('\0');
    }

    if (*g_App.szLogDir) {
        if (FAILED(StringCchCopy(szDirName, cA(szDirName), g_App.szLogDir))) {
            szDirName[0] = TEXT('\0');
        }
    } else {
        if (!GetWindowsDirectory(szDirName, cA(szDirName))) {
            szDirName[0] = TEXT('\0');
        }
    }

    if (!GetDlgItemText(hwnd, IDC_LOGNAME, szFileName, cA(szFileName))) {
        
        MyErrorBoxId(IDS_BADLOGNAME);
        return;
    }

    ShellExecute(hwnd, NULL, szFileName, NULL, szDirName, SW_SHOW);
}

BOOL 
LogFile_VerifyLogFile(
    HWND hwnd, 
    LPTSTR lpFileName, 
    ULONG FileNameCchSize, 
    BOOL bNoisy
    )
{
    TCHAR   szFileName[MAX_PATH];
    HANDLE  hFile;
    BOOL    bRet;
    HWND    hTemp;

    ZeroMemory(szFileName, sizeof(szFileName));

    bRet = GetDlgItemText(hwnd, IDC_LOGNAME, szFileName, cA(szFileName));
    
    if (bRet) {
        
        hFile = CreateFile( szFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL, 
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

        if (hFile != INVALID_HANDLE_VALUE) {
            
            CloseHandle(hFile);

        } else {
            
            hFile = CreateFile( szFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL, 
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

            if (hFile != INVALID_HANDLE_VALUE) {
                
                CloseHandle(hFile);
                DeleteFile(szFileName);

            } else {
                
                //
                // If we couldn't open an existing file and we couldn't create a new one, then we fail.
                //
                bRet = FALSE;
            }
        }
    }

    if (!bRet && bNoisy) {
        
        //
        // Since we don't want to lose focus, we are going to temporarily change g_App.hDlg.  JasKey, I apologize.
        //
        hTemp = g_App.hDlg;
        g_App.hDlg = hwnd;
        MyErrorBoxId(IDS_BADLOGNAME);
        g_App.hDlg = hTemp;
    }

    //
    // If everything worked and the user wants the file name, copy it into lpFileName
    //
    if (bRet && lpFileName && *szFileName) {
        
        if (FAILED(StringCchCopy(lpFileName, FileNameCchSize, szFileName))) {
            //
            // If we failed to copy the entire string into the callers buffer,
            // so set the callers buffer to the empty string and set the return
            // value to FALSE.
            //
            if (FileNameCchSize >= 1) {
                lpFileName[0] = TEXT('\0');
            }

            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL 
LogFile_OnOK(
    HWND hwnd
    )
{
    HKEY    hKey;
    LONG    lRes;
    DWORD   dwDisp, dwType, dwFlags, cbData;

    if (!LogFile_VerifyLogFile(hwnd, g_App.szLogFile, cA(g_App.szLogFile), FALSE)) {
        //
        // The log file could not be created.
        //
        return FALSE;
    }

    g_App.bOverwrite = IsDlgButtonChecked(hwnd, IDC_OVERWRITE);

    //
    // Look in the registry for any settings from the last SigVerif session
    //
    lRes = RegCreateKeyEx(  HKEY_CURRENT_USER,
                            SIGVERIF_KEY,
                            0,
                            NULL,
                            0,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDisp);

    if (lRes == ERROR_SUCCESS) {
        
        cbData = sizeof(DWORD);
        dwFlags = 0;
        
        if (g_App.bLoggingEnabled) {
        
            dwFlags = 0x1;
        }

        if (g_App.bOverwrite) {
        
            dwFlags |= 0x2;
        }

        dwType = REG_DWORD;
        
        lRes = RegSetValueEx(   hKey,
                                SIGVERIF_FLAGS,
                                0,
                                dwType,
                                (LPBYTE) &dwFlags,
                                cbData);

        dwType = REG_SZ;
        cbData = MAX_PATH;
        
        lRes = RegSetValueEx(   hKey,
                                SIGVERIF_LOGNAME,
                                0,
                                dwType,
                                (LPBYTE) g_App.szLogFile,
                                cbData);

        RegCloseKey(hKey);
    }

    return TRUE;
}

void 
LogFile_OnCommand(
    HWND hwnd, 
    int id, 
    HWND hwndCtl, 
    UINT codeNotify
    )
{
    UNREFERENCED_PARAMETER(hwndCtl);
    UNREFERENCED_PARAMETER(codeNotify);

    switch (id) {
    
    case IDC_VIEWLOG:
        LogFile_OnViewLog(hwnd);
        break;

    case IDC_ENABLELOG:
        g_App.bLoggingEnabled = !g_App.bLoggingEnabled;
        
        //
        // Fall through to update...
        //

    default: 
        LogFile_UpdateDialog(hwnd);
    }
}

//
// This function handles any notification messages for the Search page.
//
LRESULT 
LogFile_NotifyHandler(
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    NMHDR   *lpnmhdr = (NMHDR *) lParam;
    LRESULT lResult;
    BOOL    bRet;

    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);

    switch (lpnmhdr->code) {
    
    case PSN_APPLY:         
        if (LogFile_OnOK(hwnd)) {
        
            lResult = PSNRET_NOERROR;
        
        } else {
            
            lResult = PSNRET_INVALID_NOCHANGEPAGE;
        }

        SetWindowLongPtr(hwnd,
                         DWLP_MSGRESULT,
                         (LONG_PTR) lResult);
        
        return lResult;

    case PSN_KILLACTIVE:    
        bRet = !LogFile_VerifyLogFile(hwnd, NULL, 0, TRUE);
        
        if (bRet) {
            
            SetForegroundWindow(g_App.hLogging);
            SetFocus(GetDlgItem(g_App.hLogging, IDC_LOGNAME));
        }

        SetWindowLongPtr(hwnd,
                         DWLP_MSGRESULT,
                         (LONG_PTR) bRet);
        return bRet;
    }

    return 0;
}

INT_PTR 
CALLBACK LogFile_DlgProc(
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
    HANDLE_MSG(hwnd, WM_INITDIALOG, LogFile_OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, LogFile_OnCommand);

    case WM_NOTIFY:
        return LogFile_NotifyHandler(hwnd, uMsg, wParam, lParam);

    case WM_HELP:
        SigVerif_Help(hwnd, uMsg, wParam, lParam, FALSE);
        break;

    case WM_CONTEXTMENU:
        SigVerif_Help(hwnd, uMsg, wParam, lParam, TRUE);
        break;

    default: fProcessed = FALSE;
    }

    return fProcessed;
}

BOOL
PrintUnscannedFileListItems(
    HANDLE hFile
    )
{
    DWORD       Err = ERROR_SUCCESS;
    LPFILENODE  lpFileNode;
    TCHAR       szDirectory[MAX_PATH];
    TCHAR       szBuffer[MAX_PATH * 2];
    TCHAR       szBuffer2[MAX_PATH];
    DWORD       dwBytesWritten;
    HRESULT     hr;

    *szDirectory = 0;

    for (lpFileNode = g_App.lpFileList;lpFileNode;lpFileNode = lpFileNode->next) {

        //
        // Make sure we only log files that have NOT been scanned.
        //
        if (!lpFileNode->bScanned) {

            //
            // Write out the directory name
            //
            if (lstrcmp(szDirectory, lpFileNode->lpDirName)) {

                hr = StringCchCopy(szDirectory, cA(szDirectory), lpFileNode->lpDirName);
                if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    
                    MyLoadString(szBuffer2, cA(szBuffer2), IDS_DIR);
                    hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, szDirectory);
                    
                    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                        
                        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                            Err = GetLastError();
                        }
                    }
                }
            }

            MyLoadString(szBuffer2, cA(szBuffer2), IDS_STRING);
            hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, lpFileNode->lpFileName);
            if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            //
            // Print out the reason that the file was not scanned.
            //
            if (lpFileNode->LastError != ERROR_SUCCESS) {

                //
                // We will special case the error ERROR_FILE_NOT_FOUND and display
                // the text "The file is not installed." in the log file instead of
                // the default ERROR_FILE_NOT_FOUND text "The system cannot find the
                // file specified."
                //
                if (lpFileNode->LastError == ERROR_FILE_NOT_FOUND) {

                    MyLoadString(szBuffer, cA(szBuffer), IDS_FILENOTINSTALLED);
                    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                        Err = GetLastError();
                    }

                } else {
                
                    LPVOID lpLastError = NULL;
    
                    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                      FORMAT_MESSAGE_FROM_SYSTEM |
                                      FORMAT_MESSAGE_IGNORE_INSERTS,
                                      NULL,
                                      lpFileNode->LastError,
                                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                      (LPTSTR)&lpLastError,
                                      0,
                                      NULL) != 0) {
    
                        if (lpLastError) {
    
                            if (!WriteFile(hFile, (LPTSTR)lpLastError, lstrlen((LPTSTR)lpLastError) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                                Err = GetLastError();
                            }
    
                            LocalFree(lpLastError);
                        }
                    }
                }
            }
        }
    }

    MyLoadString(szBuffer, cA(szBuffer), IDS_LINEFEED);
    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
        Err = GetLastError();
    }

    SetLastError(Err);
    return (Err == ERROR_SUCCESS);
}

BOOL
PrintFileListItems(
    HANDLE hFile
    )
{
    DWORD       Err = ERROR_SUCCESS;
    LPFILENODE  lpFileNode;
    TCHAR       szDirectory[MAX_PATH];
    TCHAR       szBuffer[MAX_PATH * 2];
    TCHAR       szBuffer2[MAX_PATH];
    TCHAR       szBuffer3[MAX_PATH];
    DWORD       dwBytesWritten;
    LPTSTR      lpString;
    int         iRet;
    BOOL        bMirroredApp;
    HRESULT     hr;

    bMirroredApp = (GetWindowLong(g_App.hDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);

    *szDirectory = 0;

    for (lpFileNode = g_App.lpFileList;lpFileNode;lpFileNode = lpFileNode->next) {
        
        //
        // Make sure we only log files that have actually been scanned.
        //
        if (lpFileNode->bScanned) {
            
            if (lstrcmp(szDirectory, lpFileNode->lpDirName)) {
                
                hr = StringCchCopy(szDirectory, cA(szDirectory), lpFileNode->lpDirName);
                if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    
                    MyLoadString(szBuffer2, cA(szBuffer2), IDS_DIR);
                    
                    hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, szDirectory);
                    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                        
                        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                            Err = GetLastError();
                        }
                    }
                }
            }

            MyLoadString(szBuffer2, cA(szBuffer2), IDS_STRING);
            hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, lpFileNode->lpFileName);
            if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            MyLoadString(szBuffer, cA(szBuffer), IDS_SPACES);
            if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                Err = GetLastError();
            }

            //
            // Get the date format, so we are localizable...
            //
            MyLoadString(szBuffer2, cA(szBuffer2), IDS_UNKNOWN);
            iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT, 
                                 bMirroredApp ?
                                     DATE_RTLREADING | DATE_SHORTDATE :
                                     DATE_SHORTDATE,
                                 &lpFileNode->LastModified,
                                 NULL,
                                 NULL,
                                 0);
            if (iRet) {
                
                lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

                if (lpString) {
                    
                    iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                         bMirroredApp ?
                                             DATE_RTLREADING | DATE_SHORTDATE :
                                             DATE_SHORTDATE,
                                         &lpFileNode->LastModified,
                                         NULL,
                                         lpString,
                                         iRet);

                    if (iRet) {
                        hr = StringCchCopy(szBuffer2, cA(szBuffer2), lpString);

                        if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                            //
                            // If we failed to copy the date into our buffer for
                            // some reason other than insufficient buffer space,
                            // then set the date to the empty string.
                            //
                            szBuffer2[0] = TEXT('\0');
                        }
                    }

                    FREE(lpString);
                }
            }

            MyLoadString(szBuffer3, cA(szBuffer3), IDS_STRING2);
            hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer3, szBuffer2);
            if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            MyLoadString(szBuffer, cA(szBuffer), IDS_SPACES);
            if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                Err = GetLastError();
            }

            szBuffer3[0] = TEXT('\0');
            if (lpFileNode->lpVersion && *lpFileNode->lpVersion) {
                
                hr = StringCchCopy(szBuffer3, cA(szBuffer3), lpFileNode->lpVersion);
                if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    szBuffer3[0] = TEXT('\0');
                }
            }

            if (szBuffer3[0] == TEXT('\0')) {
                //
                // We were unable to get the version of the file, or the
                // string copy routine failed for some reason, so just show
                // No version.
                //
                MyLoadString(szBuffer3, cA(szBuffer3), IDS_NOVERSION);
            }

            MyLoadString(szBuffer2, cA(szBuffer2), IDS_STRING);
            hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, szBuffer3);
            if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            MyLoadString(szBuffer2, cA(szBuffer2), IDS_STRING);
            MyLoadString(szBuffer3, cA(szBuffer3), lpFileNode->bSigned ? IDS_SIGNED : IDS_NOTSIGNED);
            hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, szBuffer3);
            if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            szBuffer3[0] = TEXT('\0');
            if (lpFileNode->lpCatalog) {
                
                hr = StringCchCopy(szBuffer3, cA(szBuffer3), lpFileNode->lpCatalog);
                if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    szBuffer3[0] = TEXT('\0');
                }
            }

            if (szBuffer3[0] == TEXT('\0')) {
                //
                // We were unable to get the version of the file, or the
                // string copy routine failed for some reason, so just show
                // NA.
                //
                MyLoadString(szBuffer3, cA(szBuffer3), IDS_NA);
            }

            MyLoadString(szBuffer2, cA(szBuffer2), IDS_STRING);
            hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, szBuffer3);
            if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            if (lpFileNode->lpSignedBy) {
                
                if (!WriteFile(hFile, lpFileNode->lpSignedBy, lstrlen(lpFileNode->lpSignedBy) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            MyLoadString(szBuffer, cA(szBuffer), IDS_LINEFEED);
            if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                Err = GetLastError();
            }
        }
    }

    SetLastError(Err);
    return (Err == GetLastError());
}

BOOL
PrintFileList(void)
{
    DWORD           Err = ERROR_SUCCESS;
    HANDLE          hFile;
    DWORD           dwBytesWritten;
    TCHAR           szBuffer[MAX_PATH*2];
    TCHAR           szBuffer2[MAX_PATH];
    TCHAR           szBuffer3[MAX_PATH];
    LPTSTR          lpString = NULL;
    OSVERSIONINFO   osinfo;
    SYSTEM_INFO     sysinfo;
    int             iRet;
    BOOL            bMirroredApp;
    HRESULT         hr;

    bMirroredApp = (GetWindowLong(g_App.hDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);

    //
    // Bail if logging is disabled or there's no file list
    //
    if (!g_App.bLoggingEnabled || !g_App.lpFileList) {

        SetLastError(ERROR_SUCCESS);
        return FALSE;
    }

    if (*g_App.szLogDir) {
        SetCurrentDirectory(g_App.szLogDir);
    } else {
        if (GetWindowsDirectory(szBuffer, cA(szBuffer))) {
            SetCurrentDirectory(szBuffer);
        }
    }

    hFile = CreateFile( g_App.szLogFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        
        Err = GetLastError();
        MyErrorBoxId(IDS_CANTOPENLOGFILE);
        return FALSE;
    }

    //
    // If the overwrite flag is set, truncate the file.
    //
    if (g_App.bOverwrite) {
        
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        SetEndOfFile(hFile);
    
    } else SetFilePointer(hFile, 0, NULL, FILE_END);

#ifdef UNICODE
    //
    // If we are using UNICODE, then write the 0xFF and 0xFE bytes at the beginning of the file.
    //
    if (g_App.bOverwrite || (GetFileSize(hFile, NULL) == 0)) {
        
        szBuffer[0] = 0xFEFF;
        if (!WriteFile(hFile, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL)) {
            Err = GetLastError();
        }
    }
#endif

    //
    // Write the header to the logfile.
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_LOGHEADER1);
    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
        Err = GetLastError();
    }

    //
    // Get the date format, so we are localizable...
    //
    MyLoadString(szBuffer2, cA(szBuffer2), IDS_UNKNOWN);
    iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                         bMirroredApp ?
                             DATE_RTLREADING | DATE_SHORTDATE :
                             DATE_SHORTDATE,
                         NULL,
                         NULL,
                         NULL,
                         0
                         );
    
    if (iRet) {
        
        lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

        if (lpString) {
            
            iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                 bMirroredApp ?
                                     DATE_RTLREADING | DATE_SHORTDATE :
                                     DATE_SHORTDATE,
                                 NULL,
                                 NULL,
                                 lpString,
                                 iRet
                                 );

            if (iRet) {
                hr = StringCchCopy(szBuffer2, cA(szBuffer2), lpString);

                if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    //
                    // If we failed to copy the date into our buffer for
                    // some reason other than insufficient buffer space,
                    // then set the date to the empty string.
                    //
                    szBuffer2[0] = TEXT('\0');
                }
            }

            FREE(lpString);
        }
    }

    //
    // Get the time format, so we are localizable...
    //
    iRet = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,TIME_NOSECONDS,NULL,NULL,NULL,0);
    
    if (iRet) {
        
        lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

        if (lpString) {
            
            iRet = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,TIME_NOSECONDS,NULL,NULL,lpString,iRet);
        }
    }

    MyLoadString(szBuffer3, cA(szBuffer3), IDS_LOGHEADER2);

    if (lpString) {

        hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer3, szBuffer2, lpString);
        FREE(lpString);

    } else {
        
        hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer3, szBuffer2, szBuffer2);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
            Err = GetLastError();
        }
    }

    //
    // Get the OS Platform string for the log file.
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_OSPLATFORM);
    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
        Err = GetLastError();
    }

    ZeroMemory(&osinfo, sizeof(OSVERSIONINFO));
    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osinfo);

    switch (osinfo.dwPlatformId) {
    
    case VER_PLATFORM_WIN32_NT:         
        MyLoadString(szBuffer, cA(szBuffer), IDS_WINNT); 
        break;

    default:                            
        MyLoadString(szBuffer, cA(szBuffer), IDS_UNKNOWN);
        break;
    }

    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
        Err = GetLastError();
    }

    //
    // If this is NT, then get the processor architecture and log it
    //
    if (osinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        
        ZeroMemory(&sysinfo, sizeof(SYSTEM_INFO));
        GetSystemInfo(&sysinfo);
        
        //
        // Initialize szBuffer to zeroes in case of an unknown architecture
        //
        ZeroMemory(szBuffer, sizeof(szBuffer));
        
        switch (sysinfo.wProcessorArchitecture) {
        
        case PROCESSOR_ARCHITECTURE_INTEL:  
            MyLoadString(szBuffer, cA(szBuffer), IDS_X86); 
            break;

        case PROCESSOR_ARCHITECTURE_IA64:
            MyLoadString(szBuffer, cA(szBuffer), IDS_IA64);
            break;
        }

        if (*szBuffer) {
            //
            // Now write the processor type to the file
            //
            if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                Err = GetLastError();
            }
        }
    }

    //
    // Get the OS Version, Build, and CSD information and log it.
    //
    MyLoadString(szBuffer2, cA(szBuffer2), IDS_OSVERSION);
    
    hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, osinfo.dwMajorVersion, osinfo.dwMinorVersion, (osinfo.dwBuildNumber & 0xFFFF), osinfo.szCSDVersion);
    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
        
        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
            Err = GetLastError();
        }
    }

    //
    // Print out the total/signed/unsigned results right before the file list
    //
    MyLoadString(szBuffer2, cA(szBuffer2), IDS_TOTALS);
    hr = StringCchPrintf(szBuffer, 
                         cA(szBuffer), 
                         szBuffer2,   
                         g_App.dwFiles, 
                         g_App.dwSigned, 
                         g_App.dwUnsigned, 
                         g_App.dwFiles - g_App.dwSigned - g_App.dwUnsigned);
    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
        
        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
            Err = GetLastError();
        }
    }

    //
    // If we are doing a user-defined search, then log the parameters.
    //
    if (g_App.bUserScan) {
        //
        // Write the user-specified directory
        //
        MyLoadString(szBuffer2, cA(szBuffer2), IDS_LOGHEADER3);
        
        hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, g_App.szScanPattern);
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
            
            if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                Err = GetLastError();
            }
        }

        //
        // Write the user-specified search pattern
        //
        MyLoadString(szBuffer2, cA(szBuffer2), IDS_LOGHEADER4);
        
        hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, g_App.szScanPath);
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
            
            if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                Err = GetLastError();
            }
        }
    }

    //
    // Write the column headers to the log file
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_LOGHEADER5);
    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
        Err = GetLastError();
    }
    
    MyLoadString(szBuffer, cA(szBuffer), IDS_LOGHEADER6);
    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
        Err = GetLastError();
    }
    
    if (!PrintFileListItems(hFile)) {
        Err = GetLastError();
    }

    //
    // Write the unscanned file headers to the log file
    //
    if (g_App.dwFiles > (g_App.dwSigned + g_App.dwUnsigned)) {
        
        MyLoadString(szBuffer, cA(szBuffer), IDS_LOGHEADER7);
        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
            Err = GetLastError();
        }
        
        MyLoadString(szBuffer, cA(szBuffer), IDS_LOGHEADER8);
        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
            Err = GetLastError();
        }

        if (!PrintUnscannedFileListItems(hFile)) {
            Err = GetLastError();
        }
    }

    CloseHandle(hFile);

    SetLastError(Err);
    return (Err == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\progress.c ===
/*****************************************************************************
 *
 *  Progress.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Our private progress control (because commctrl might be damanged)
 *
 *  Contents:
 *
 *      Progress_Init
 *
 *****************************************************************************/
#include "sigverif.h"

/***************************************************************************
 *
 *  GWL_* for Progress goo.
 *
 ***************************************************************************/

#define GWL_CUR             GWLP_USERDATA

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | Progress_GetRectPos |
 *
 *          Compute the position within the drawing rectangle that
 *          corresponds to the current position.
 *
 *          This is basically a MulDiv, except that we don't let the
 *          bar get all the way to 100% unless it really means it.
 *
 *
 ***************************************************************************/

int 
Progress_GetRectPos(
    int cx, 
    int iCur, 
    int iMax
    )
{
    int iRc;

    if (iCur != iMax) {
        iRc = MulDiv(cx, iCur, iMax);
    } else {
        iRc = cx;
    }

    return iRc;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | Progress_OnPaint |
 *
 *          Draw the first part in the highlight colors.
 *
 *          Draw the second part in the 3dface colors.
 *
 ***************************************************************************/

void 
Progress_OnPaint(
    HWND hwnd
    )
{
    HDC hdc;
    PAINTSTRUCT ps;
    HRESULT hr;

    hdc = BeginPaint(hwnd, &ps);
    if (hdc) {
        UINT taPrev;
        RECT rc;
        int cx;
        COLORREF clrTextPrev, clrBackPrev;
        int iCur, iMax, iPct;
        int ctch;
        HFONT hfPrev;
        TCHAR tsz[256];
        SIZE size;

        //
        //  Set up the DC generically.
        //
        taPrev = SetTextAlign(hdc, TA_CENTER | TA_TOP);
        hfPrev = SelectFont(hdc, GetWindowFont(GetParent(hwnd)));

        //
        //  Set up the colors for the left-hand side.
        //
        clrTextPrev = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
        clrBackPrev = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));

        //
        //  Now do some math.
        //
        GetClientRect(hwnd, &rc);

        cx = rc.right;

        iCur = LOWORD(GetWindowLong(hwnd, GWL_CUR));
        iMax = HIWORD(GetWindowLong(hwnd, GWL_CUR));

        if (iMax == 0) {
            iMax = 1;           /* Avoid divide by zero */
        }

        if (iCur > 0) {

            iPct = (iCur * 100) / iMax;
            if (iPct < 1) {
                iPct = 1;
            }
        } else {
            iPct = 0;
        }

        rc.right = Progress_GetRectPos(cx, iCur, iMax);

        //
        // Update the percentage text in the progress bar.
        //
        hr = StringCchPrintf(tsz, cA(tsz), TEXT("%d%%"), iPct);
        if (FAILED(hr) && (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
            tsz[0] = TEXT('\0');
        }
        
        for(ctch=0;tsz[ctch];ctch++);

        //
        //  Draw the left-hand side.
        //
        if (!GetTextExtentPoint32(hdc, tsz, ctch, &size)) {

            ExtTextOut( hdc, cx/2, 1, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        
        } else {
            
            ExtTextOut( hdc, cx/2, (rc.bottom - rc.top - size.cy + 1) / 2, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        }

        //
        //  Now set up for the right-hand side.
        //
        SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(hdc, GetSysColor(COLOR_WINDOW));

        rc.left = rc.right;
        rc.right = cx;

        //
        //  Draw the right-hand side.
        //
        if (!GetTextExtentPoint32(hdc, tsz, ctch, &size)) {

            ExtTextOut( hdc, cx/2, 1, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        
        } else {

            ExtTextOut( hdc, cx/2, (rc.bottom - rc.top - size.cy + 1) / 2, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        }

        SetBkColor(hdc, clrBackPrev);
        SetTextColor(hdc, clrTextPrev);
        SelectFont(hdc, hfPrev);
        SetTextAlign(hdc, taPrev);

        EndPaint(hwnd, &ps);
    }
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | Progress_OnSetPos |
 *
 *          Update the state and invalidate the section that is affected.
 *
 ***************************************************************************/

void 
Progress_OnSetPos(
    HWND hwnd, 
    WPARAM wp
    )
{
    int iCur, iMax;
    RECT rc;
    LONG lState = GetWindowLong(hwnd, GWL_CUR);


    GetClientRect(hwnd, &rc);

    iCur = LOWORD(GetWindowLong(hwnd, GWL_CUR));
    iMax = HIWORD(GetWindowLong(hwnd, GWL_CUR));

    if (iMax == 0) {
        iMax = 1;           /* Avoid divide by zero */
    }

    rc.left = Progress_GetRectPos(rc.right, iCur, iMax);
    rc.right = Progress_GetRectPos(rc.right, (int)wp, iMax);

    InvalidateRect(hwnd, 0, 0);

    SetWindowLong(hwnd, GWL_CUR, MAKELONG(wp,HIWORD(lState)));
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | Progress_WndProc |
 *
 *          There really isn't much to do.
 *
 *          The string is our window text (which Windows manages for us).
 *
 *          The progress bar itself is kept in the high/low words of
 *          our GWL_USERDATA.
 *
 *          HIWORD(GetWindowLong(GWL_USERDATA)) = maximum
 *          LOWORD(GetWindowLong(GWL_USERDATA)) = current value
 *
 ***************************************************************************/

LRESULT CALLBACK
Progress_WndProc(
    HWND hwnd, 
    UINT wm, 
    WPARAM wp, 
    LPARAM lp
    )
{
    switch (wm) {

    case WM_PAINT:
        Progress_OnPaint(hwnd);
        return 0;

    //
    //  When the range resets, invalidate so we repaint.
    //
    //  wp = new current pos
    //  lp = new range
    //
    case PBM_SETRANGE:
        lp = HIWORD(lp);
        SetWindowLong(hwnd, GWL_CUR, MAKELONG(wp, lp));
        /* FALLTHROUGH */

    case PBM_SETPOS:
        Progress_OnSetPos(hwnd, wp);
        break;

    case PBM_DELTAPOS:
        lp = LOWORD(GetWindowLong(hwnd, GWL_CUR));
        Progress_OnSetPos(hwnd, wp + lp);
        break;

    case WM_ERASEBKGND:
        return 0;
    }

    return DefWindowProc(hwnd, wm, wp, lp);
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Progress_InitRegisterClass |
 *
 *          Register our window classes.
 *
 ***************************************************************************/

void 
Progress_InitRegisterClass(void)
{
    WNDCLASS wc;

    //
    //  Progress control.
    //
    wc.style = 0;
    wc.lpfnWndProc = Progress_WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = cbX(DWORD);
    wc.hInstance = g_App.hInstance;
    wc.hIcon = 0;
    wc.hCursor = LoadCursor(0, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BACKGROUND);
    wc.lpszMenuName = 0;
    wc.lpszClassName = TEXT("progress");

    RegisterClass(&wc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\resource.h ===
#define IDS_COL_NAME                    1
#define IDS_COL_FOLDER                  2
#define IDS_COL_TYPE                    4
#define IDS_COL_VERSION                 5
#define IDS_COL_SIGNEDBY                6
#define IDS_COL_DATE                    7
#define IDS_NOPROBLEMS                  9
#define IDS_ALLSIGNED                   10
#define IDS_MSGBOX                      11
#define IDS_ERRORBOX                    12
#define IDS_NUMFILES                    13
#define IDS_SIGNED                      14
#define IDS_NOTSIGNED                   15
#define IDS_NOFILES                     16
#define IDS_STOP                        17
#define IDS_START                       18
#define IDS_ALL                         19
#define IDS_EXE                         20
#define IDS_SYS                         21
#define IDS_OCX                         22
#define IDS_DLL                         23
#define IDS_DRV                         24
#define IDS_FILENOTINSTALLED            26
#define IDS_SELECTDIR                   29
#define IDS_SCANSTOPPED                 30
#define IDS_NOVERSION                   31
#define IDS_LOGNAME                     32
#define IDS_BADLOGNAME                  33
#define IDS_CANTOPENLOGFILE             34
#define IDS_LOGHEADER1                  35
#define IDS_LOGHEADER2                  36
#define IDS_LOGHEADER3                  37
#define IDS_LOGHEADER4                  38
#define IDS_LOGHEADER5                  39
#define IDS_LOGHEADER6                  40
#define IDS_LOGHEADER7                  41
#define IDS_DIR                         42
#define IDS_VERSION                     43
#define IDS_STRING                      44
#define IDS_OSPLATFORM                  45
#define IDS_OSVERSION                   46
#define IDS_WINNT                       47
#define IDS_UNKNOWN                     50
#define IDS_NA                          51
#define IDS_LINEFEED                    52
#define IDS_SPACES                      53
#define IDS_FILETYPE                    54
#define IDS_FILE                        55
#define IDS_NOSYSTEMFILES               59
#define IDS_COPYFILES                   65
#define IDS_MASTERFILELIST              68
#define IDS_LOGHEADER8                  69
#define IDS_STRING_LINEFEED             70
#define IDS_TOTALS                      73
#define IDS_SIGVERIF                    76
#define IDS_STRING2                     80
#define IDS_STATUS_BUILD                83
#define IDS_STATUS_FREE                 84
#define IDS_STATUS_LOG                  85
#define IDS_STATUS_SCAN                 86
#define IDS_ADVANCED_SETTINGS           87
#define IDS_SEARCHTAB                   88
#define IDS_LOGGINGTAB                  89
#define IDS_X86                         90
#define IDS_IA64                        91
#define IDS_DEFSCAN                     99
#define IDS_LOGDIR                      100
#define IDD_DIALOG                      101
#define IDI_ICON1                       102
#define IDB_BITMAP1                     102
#define IDD_DETAILS                     103
#define IDD_RESULTS                     104
#define IDD_SETTINGS                    105
#define IDD_ADVANCED                    106
#define IDD_SEARCH                      107
#define IDS_INVALID_FOLDER              108
#define IDS_LOGERROR                    109
#define IDS_LOGDIRERROR                 110
#define IDS_BUILDLISTERROR              111
#define IDS_NOAUTHENTICODE              112
#define ID_VIEWLOG                      1000
#define IDC_BITMAP                      1000
#define IDC_FOLDER                      1001
#define IDC_TEXT                        1001
#define IDC_SCAN                        1002
#define IDC_NOTMS                       1003
#define IDC_SUBFOLDERS                  1004
#define ID_CLOSE                        1005
#define ID_START                        1006
#define ID_BROWSE                       1007
#define IDC_PROGRESS                    1008
#define IDC_LISTVIEW                    1009
#define IDC_STATUSWINDOW                1010
#define ID_SETTINGS                     1011
#define ID_ADVANCED                     1011
#define IDC_TYPE                        1013
#define IDC_FREELIST                    1014
#define ID_DETAILS_OK                   1015
#define ID_DETAILS                      1016
#define IDC_RESULTSTEXT                 1017
#define IDC_LOGNAME                     1018
#define IDC_OVERWRITE                   1019
#define IDC_APPEND                      1020
#define IDC_ENABLELOG                   1021
#define IDC_VIEWLOG                     1022
#define IDC_TAB1                        1023
#define IDC_STATUS                      1024
#define IDC_INFOTEXT                    1025


//
// Version Information
//
#include <winver.h>
#include <ntverp.h>
#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "File Signature Verification"
#define VER_INTERNALNAME_STR            "sigverif.exe"
#define VER_ORIGINALFILENAME_STR        "sigverif.exe"
#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\listview.c ===
//
// LISTVIEW.C
//
#include "sigverif.h"

HWND    g_hListView         = NULL;
HWND    g_hStatus           = NULL;
BOOL    g_bSortOrder[]      = { FALSE, FALSE, FALSE, FALSE, FALSE};
RECT    g_Rect;

//
// Initialize the image lists for the icons in the listview control.
//
BOOL WINAPI ListView_SetImageLists(HWND hwndList)
{
    SHFILEINFO      sfi;
    HIMAGELIST      himlSmall;
    HIMAGELIST      himlLarge;
    BOOL            bSuccess = TRUE;
    TCHAR           szDriveRoot[MAX_PATH];

    MyGetWindowsDirectory(szDriveRoot, cA(szDriveRoot));
    szDriveRoot[3] = 0;
    himlSmall = (HIMAGELIST)SHGetFileInfo((LPCTSTR)szDriveRoot, 
                                          0,
                                          &sfi, 
                                          sizeof(SHFILEINFO), 
                                          SHGFI_SYSICONINDEX | SHGFI_SMALLICON);

    himlLarge = (HIMAGELIST)SHGetFileInfo((LPCTSTR)szDriveRoot, 
                                          0,
                                          &sfi, 
                                          sizeof(SHFILEINFO), 
                                          SHGFI_SYSICONINDEX | SHGFI_LARGEICON);

    if (himlSmall && himlLarge) {
        ListView_SetImageList(hwndList, himlSmall, LVSIL_SMALL);
        ListView_SetImageList(hwndList, himlLarge, LVSIL_NORMAL);
    } else {
        bSuccess = FALSE;
    }

    return bSuccess;
}

//
// Insert everything from the g_App.lpFileList into the listview control.
//
void ListView_InsertItems(void)
{
    LPFILENODE  lpFileNode;
    LV_ITEM     lvi;
    TCHAR       szBuffer[MAX_PATH];
    LPTSTR      lpString;
    int         iRet;
    BOOL        bMirroredApp;
    HRESULT     hr;

    bMirroredApp = (GetWindowLong(g_App.hDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);

    for (lpFileNode=g_App.lpFileList;lpFileNode;lpFileNode=lpFileNode->next) {

        if (lpFileNode->bScanned &&
            !lpFileNode->bSigned) {

            SetCurrentDirectory(lpFileNode->lpDirName);

            //
            // Initialize lvi and insert the filename and icon into the first column.
            //
            ZeroMemory(&lvi, sizeof(LV_ITEM));
            lvi.mask = LVIF_TEXT;
            lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            lvi.iImage = lpFileNode->iIcon;
            lvi.lParam = (LPARAM) lpFileNode;
            lvi.iSubItem = 0;
            lvi.pszText = lpFileNode->lpFileName;
            lvi.iItem = MAX_INT;
            lvi.iItem = ListView_InsertItem(g_hListView, &lvi);

            //
            // Insert the directory name into the second column.
            //
            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 1;
            lvi.pszText = lpFileNode->lpDirName;
            ListView_SetItem(g_hListView, &lvi);

            //
            // Get the date format, so we are localizable...
            //
            MyLoadString(szBuffer, cA(szBuffer), IDS_UNKNOWN);

            iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT, 
                                 bMirroredApp ? 
                                    DATE_RTLREADING | DATE_SHORTDATE :
                                    DATE_SHORTDATE,
                                 &lpFileNode->LastModified,
                                 NULL,
                                 NULL,
                                 0);

            if (iRet) {

                lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

                if (lpString) {

                    iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                         bMirroredApp ?
                                            DATE_RTLREADING | DATE_SHORTDATE :
                                            DATE_SHORTDATE,
                                         &lpFileNode->LastModified,
                                         NULL,
                                         lpString,
                                         iRet);

                    if (iRet) {
                        hr = StringCchCopy(szBuffer, cA(szBuffer), lpString);

                        if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                            //
                            // If we failed to copy the date into our buffer for
                            // some reason other than insufficient buffer space,
                            // then set the date to the empty string.
                            //
                            szBuffer[0] = TEXT('\0');
                        }
                    }

                    FREE(lpString);
                }
            }

            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 2;
            lvi.pszText = szBuffer;
            ListView_SetItem(g_hListView, &lvi);

            //
            // Insert the filetype string into the fourth column.
            //
            if (lpFileNode->lpTypeName) {
                //
                // Since this string is just being displayed in the UI, it
                // is OK if it gets truncated.
                //
                hr = StringCchCopy(szBuffer, cA(szBuffer), lpFileNode->lpTypeName);

                if (FAILED(hr) &&
                    (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    //
                    // We encountered some error other than insufficient 
                    // buffer, so just set the buffer to the empty string, 
                    // since it value is not determined with this type of
                    // failure.
                    //
                    szBuffer[0] = TEXT('\0');
                }

            } else {
                
                MyLoadString(szBuffer, cA(szBuffer), IDS_UNKNOWN);
            }

            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 3;
            lvi.pszText = szBuffer;
            ListView_SetItem(g_hListView, &lvi);

            //
            // Insert the version string into the fifth column.
            //
            if (lpFileNode->lpVersion) {
                //
                // Since this string is just being displayed in the UI, it
                // is OK if it gets truncated.
                //
                hr = StringCchCopy(szBuffer, cA(szBuffer), lpFileNode->lpVersion);

                if (FAILED(hr) &&
                    (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    //
                    // We encountered some error other than insufficient 
                    // buffer, so just set the buffer to the empty string, 
                    // since it value is not determined with this type of
                    // failure.
                    //
                    szBuffer[0] = TEXT('\0');
                }

            } else {
                
                MyLoadString(szBuffer, cA(szBuffer), IDS_NOVERSION);
            }

            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 4;
            lvi.pszText = szBuffer;
            ListView_SetItem(g_hListView, &lvi);
        }
    }
}

//
// Initialize the listview dialog.  First, we are going to load the global icon resource.
// Then we are going to create a status window and the actual listview control.
// Then we need to add the four columns and work out their default widths.
//
BOOL ListView_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{   
    LV_COLUMN   lvc;
    RECT        rect, rectResultsText, rectStatusBar, rectCancelButton, rectClient;
    TCHAR       szBuffer[MAX_PATH];
    TCHAR       szBuffer2[MAX_PATH];
    INT         iCol = 0, iWidth = 0;
    HRESULT     hr;

    UNREFERENCED_PARAMETER(hwndFocus);
    UNREFERENCED_PARAMETER(lParam);

    //
    // Load the global icon resource
    //
    if (g_App.hIcon) {

        SetClassLongPtr(hwnd, GCLP_HICON, (LONG_PTR) g_App.hIcon); 
    }

    //
    // Create the status window at the bottom of the dialog
    //
    g_hStatus = CreateStatusWindow(WS_CHILD | WS_VISIBLE,
                                   NULL,
                                   hwnd,
                                   (UINT) IDC_STATUSWINDOW);

    //
    // Load the status string and fill it in with the correct values.
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_NUMFILES);
    hr = StringCchPrintf(szBuffer2, 
                         cA(szBuffer2), 
                         szBuffer,   
                         g_App.dwFiles, 
                         g_App.dwSigned, 
                         g_App.dwUnsigned, 
                         g_App.dwFiles - g_App.dwSigned - g_App.dwUnsigned);
    
    if (FAILED(hr) &&
        (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
        //
        // We encountered some error other than insufficient 
        // buffer, so just set the buffer to the empty string, 
        // since it value is not determined with this type of
        // failure.
        //
        szBuffer2[0] = TEXT('\0');
    }

    SendMessage(g_hStatus, WM_SETTEXT, (WPARAM) 0, (LPARAM) szBuffer2);

    GetWindowRect(hwnd, &g_Rect);
    GetClientRect(hwnd, &rectClient);

    //
    // Get the windows RECT values for the dialog, the static text, and the status window.
    // We will use these values to figure out where to put the listview and the columns.
    //
    GetWindowRect(hwnd, &rect);
    GetWindowRect(GetDlgItem(hwnd, IDC_RESULTSTEXT), &rectResultsText);
    GetWindowRect(g_hStatus, &rectStatusBar);
    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectCancelButton);

    MoveWindow(GetDlgItem(hwnd, IDCANCEL), 
               (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
                 ? (rect.right - rect.left) - (rectCancelButton.right - rectCancelButton.left) - (rect.right - rectResultsText.right)
                 : (rect.right - rectResultsText.left) - (rectCancelButton.right - rectCancelButton.left) - (( 2 * (rectResultsText.left - rect.left)) / 3),
               (rectClient.bottom - rectClient.top) - (rectStatusBar.bottom - rectStatusBar.top) - (rectCancelButton.bottom - rectCancelButton.top) - 10,
               rectCancelButton.right - rectCancelButton.left,
               rectCancelButton.bottom - rectCancelButton.top,
               TRUE);

    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectCancelButton);

    //
    // Create the listview window!  I am using some really screwey logic to figure out how
    // big to make the listview and where to put it, but it seems to work.
    //
    g_hListView = CreateWindowEx(WS_EX_CLIENTEDGE, 
                                 WC_LISTVIEW, TEXT(""), 
                                 WS_TABSTOP | WS_VSCROLL | WS_VISIBLE | WS_CHILD | WS_BORDER | 
                                 LVS_SINGLESEL | LVS_REPORT | LVS_AUTOARRANGE | LVS_SHAREIMAGELISTS,
                                 ((rectResultsText.left - rect.left) * 2) / 3,
                                 (rectResultsText.bottom - rectResultsText.top) * 2,
                                 (rect.right - rect.left) - 2 * (rectResultsText.left - rect.left),
                                 rectCancelButton.top - rectResultsText.bottom - 20,
                                 hwnd, 
                                 (HMENU) IDC_LISTVIEW, 
                                 g_App.hInstance, 
                                 NULL);


    //
    // If the CreateWindowEx failed, then bail.
    //
    if (!g_hListView) {
    
        return FALSE;
    }

    //
    // Initialize the icon lists
    //
    ListView_SetImageLists(g_hListView);

    //
    // Create the first listview column for the icon and the file name.
    //
    lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = (rectResultsText.right - rectResultsText.left) / 5;
    lvc.pszText = szBuffer;
    MyLoadString(szBuffer, cA(szBuffer), IDS_COL_NAME);
    lvc.cchTextMax = MAX_PATH;
    ListView_InsertColumn(g_hListView, iCol++, &lvc);   

    //
    // Create the second listview column for the directory name.
    //
    iWidth += lvc.cx;
    lvc.cx = (rectResultsText.right - rectResultsText.left) / 4;
    MyLoadString(szBuffer, cA(szBuffer), IDS_COL_FOLDER);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    //
    // Create the third listview column for the date name.
    //
    iWidth += lvc.cx;
    lvc.cx = (rectResultsText.right - rectResultsText.left) / 6;
    lvc.fmt = LVCFMT_CENTER;
    MyLoadString(szBuffer, cA(szBuffer), IDS_COL_DATE);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    //
    // Create the fourth listview column for the filetype string.
    //
    iWidth += lvc.cx;
    lvc.cx = (rectResultsText.right - rectResultsText.left) / 6;
    lvc.fmt = LVCFMT_CENTER;
    MyLoadString(szBuffer, cA(szBuffer), IDS_COL_TYPE);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    //
    // Create the fifth listview column for the version string.
    //
    iWidth += lvc.cx;
    lvc.cx = (rectResultsText.right - rectResultsText.left) - iWidth - 5;
    lvc.fmt = LVCFMT_CENTER;
    MyLoadString(szBuffer, cA(szBuffer), IDS_COL_VERSION);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    //
    // Now that the columns are set up, insert all the files in g_App.lpFileList!
    //
    ListView_InsertItems();

    //
    // Initialize the sorting order array to all FALSE.
    //
    g_bSortOrder[0] = FALSE;
    g_bSortOrder[1] = FALSE;
    g_bSortOrder[2] = FALSE;
    g_bSortOrder[3] = FALSE;

    SetForegroundWindow(g_App.hDlg);
    SetForegroundWindow(hwnd);
    SetFocus(GetDlgItem(hwnd, IDCANCEL));

    return TRUE;
}

//
// This function checks to see how big the sizing rectangle will be.  If the user is trying
// to size the dialog to less than the values in g_Rect, then we will fix the rectangle values
//
BOOL ListView_OnSizing(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    RECT    rect;
    LPRECT  lpRect = (LPRECT) lParam;
    BOOL    bRet = FALSE;

    UNREFERENCED_PARAMETER(wParam);

    GetWindowRect(hwnd, &rect);

    if ((lpRect->right - lpRect->left) < (g_Rect.right - g_Rect.left)) {
        lpRect->left = rect.left;
        lpRect->right = lpRect->left + (g_Rect.right - g_Rect.left);
        bRet = TRUE;
    }

    if ((lpRect->bottom - lpRect->top) < (g_Rect.bottom - g_Rect.top)) {
        lpRect->top = rect.top;
        lpRect->bottom = lpRect->top + (g_Rect.bottom - g_Rect.top);
        bRet = TRUE;
    }

    return bRet;
}

//
// This function allows us to resize the listview control and status windows when the
// user resizes the results dialog.  Thankfully, we can make everything relative using
// the RECT values for the main dialog, the static text, and the status window.
//
void ListView_ResizeWindow(HWND hwnd)
{
    RECT    rect, rectResultsText, rectStatusBar, rectCancelButton, rectClient;
    BOOL    bMirroredApp;

    bMirroredApp = (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);

    GetWindowRect(hwnd, &rect);

    if ((rect.right - rect.left) < (g_Rect.right - g_Rect.left)) {
        
        MoveWindow(hwnd,
                   rect.left,
                   rect.top,
                   g_Rect.right - g_Rect.left,
                   rect.bottom - rect.top,
                   TRUE);
    }

    if ((rect.bottom - rect.top) < (g_Rect.bottom - g_Rect.top)) {
        
        MoveWindow(hwnd,
                   rect.left,
                   rect.top,
                   rect.right - rect.left,
                   g_Rect.bottom - g_Rect.top,
                   TRUE);
    }

    GetClientRect(hwnd, &rectClient);
    GetWindowRect(GetDlgItem(hwnd, IDC_RESULTSTEXT), &rectResultsText);
    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectCancelButton);
    GetWindowRect(g_hStatus, &rectStatusBar);


    MoveWindow(g_hStatus,
               0,
               (rect.bottom - rect.top) - (rectStatusBar.bottom - rectStatusBar.top),
               rect.right - rect.left,
               rectStatusBar.bottom - rectStatusBar.top,
               TRUE);

    MoveWindow(GetDlgItem(hwnd, IDCANCEL), 
               (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
                 ? (rect.right - rect.left) - (rectCancelButton.right - rectCancelButton.left) - (rect.right - rectResultsText.right)
                 : (rect.right - rectResultsText.left) - (rectCancelButton.right - rectCancelButton.left) - (( 2 * (rectResultsText.left - rect.left)) / 3),
               (rectClient.bottom - rectClient.top) - (rectStatusBar.bottom - rectStatusBar.top) - (rectCancelButton.bottom - rectCancelButton.top) - 10,
               rectCancelButton.right - rectCancelButton.left,
               rectCancelButton.bottom - rectCancelButton.top,
               TRUE);

    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectCancelButton);

    MoveWindow(g_hListView,
               bMirroredApp
                 ? ((rect.right - rectResultsText.right) * 2) / 3
                 : ((rectResultsText.left - rect.left) * 2) / 3,
               (rectResultsText.bottom - rectResultsText.top) * 2,
               bMirroredApp
                 ? (rect.right - rect.left) - 2 * (rect.right - rectResultsText.right)
                 : (rect.right - rect.left) - 2 * (rectResultsText.left - rect.left),
               rectCancelButton.top - rectResultsText.bottom - 20,
               TRUE);

}

//
// This function is a callback that returns a value for ListView_SortItems.
// ListView_SortItems wants a negative, zero, or positive number.
// Since CompareString returns 1,2,3 we just subtract 2 from the return value.
//
// We use the g_bSortOrder array to figure out which way we have sorted in the past.
//
// Warning: we don't check for error values from CompareString
//
int CALLBACK ListView_CompareNames(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    LPFILENODE  lpFileNode1;
    LPFILENODE  lpFileNode2;
    FILETIME    FileTime1, FileTime2;
    int         iResult = 2;

    //
    // Depending on the sort order, we swap the order of comparison
    //
    if (g_bSortOrder[lParamSort]) {
        lpFileNode2 = (LPFILENODE) lParam1;
        lpFileNode1 = (LPFILENODE) lParam2;
    } else {
        lpFileNode1 = (LPFILENODE) lParam1;
        lpFileNode2 = (LPFILENODE) lParam2;
    }

    switch (lParamSort) {
    
    case 0: 
        //
        // We are comparing the file names
        //
        iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                lpFileNode1->lpFileName, 
                                -1, 
                                lpFileNode2->lpFileName,
                                -1);
        break;

    case 1: 
        //
        // We are comparing the directory names
        //
        iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                lpFileNode1->lpDirName, 
                                -1, 
                                lpFileNode2->lpDirName,
                                -1);
        break;

    case 2: 
        //
        // We are comparing the LastWriteTime's between the two files.
        //
        SystemTimeToFileTime(&lpFileNode1->LastModified, &FileTime1);
        SystemTimeToFileTime(&lpFileNode2->LastModified, &FileTime2);
        iResult = CompareFileTime(&FileTime1, &FileTime2);
        return iResult;

        break;

    case 3: 
        //
        // We are comparing the filetype strings
        //
        iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                lpFileNode1->lpTypeName, 
                                -1, 
                                lpFileNode2->lpTypeName,
                                -1);
        break;

    case 4: 
        //
        // We are comparing the version strings
        //
        iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                lpFileNode1->lpVersion, 
                                -1, 
                                lpFileNode2->lpVersion,
                                -1);
        break;
    }

    return(iResult - 2);
}

//
// This function handles the clicks on the column headers and calls ListView_SortItems with the
// ListView_CompareNames callback previously defined.  It then toggles the sortorder for that column.
//
LRESULT ListView_NotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR       *lpnmhdr = (NMHDR *) lParam;
    NM_LISTVIEW *lpnmlv = (NM_LISTVIEW *) lParam;

    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);

    switch (lpnmhdr->code) {
    
    case LVN_COLUMNCLICK:
        switch (lpnmlv->iSubItem) {
        case 0: 
        case 1:
        case 2: 
        case 3: 
        case 4: ListView_SortItems(lpnmlv->hdr.hwndFrom, ListView_CompareNames, (LPARAM) lpnmlv->iSubItem);
            g_bSortOrder[lpnmlv->iSubItem] = !(g_bSortOrder[lpnmlv->iSubItem]);
            break;
        }
        break;
    }

    return 0;
}

//
// The only thing we look for here is the IDCANCEL if the user hit ESCAPE
//
void ListView_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    UNREFERENCED_PARAMETER(hwndCtl);
    UNREFERENCED_PARAMETER(codeNotify);

    switch (id) {
    case IDCANCEL:
        SendMessage(hwnd, WM_CLOSE, 0, 0);
        break;
    }
}

INT_PTR CALLBACK ListView_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
    
    HANDLE_MSG(hwnd, WM_INITDIALOG, ListView_OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, ListView_OnCommand);

    case WM_NOTIFY:
        return ListView_NotifyHandler(hwnd, uMsg, wParam, lParam);

    case WM_CLOSE:
        if (g_hStatus) {

            DestroyWindow(g_hStatus);
            g_hStatus = NULL;
        }

        if (g_hListView) {

            DestroyWindow(g_hListView);
            g_hListView = NULL;
        }

        EndDialog(hwnd, ID_CLOSE);
        break;

    case WM_SIZING:
        fProcessed = ListView_OnSizing(hwnd, wParam, lParam);
        break;

    case WM_SIZE:
        ListView_ResizeWindow(hwnd);
        break;

    default: fProcessed = FALSE;
    }

    return fProcessed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\sigverif.h ===
//
//  SIGVERIF.H
//
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#pragma warning( disable : 4115 ) // named type definition in parentheses

#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <commctrl.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <spapip.h>
#include <sputils.h>
#include <tchar.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <winspool.h>
#include <imagehlp.h>
#include <capi.h>
#include <softpub.h>
#include <sfc.h>
#include <regstr.h>
#include <strsafe.h>
#include "resource.h"

#pragma warning( default : 4115 )
#pragma warning( default : 4201 )

// Macros and pre-defined values
#define     cbX(X)      sizeof(X)
#define     cA(a)       (cbX(a)/cbX(a[0]))
#define     MALLOC(x)   HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (x))
#define     FREE(x)     if (x) { HeapFree(GetProcessHeap(), 0, (x)); x = NULL; }
#define     EXIST(x)    (GetFileAttributes(x) != 0xFFFFFFFF)
#define     MAX_INT     0x7FFFFFFF
#define     HASH_SIZE   100
#define     NUM_PAGES   2

// Registry key/value names for storing previous settings
#define     SIGVERIF_KEY        TEXT("Software\\Microsoft\\Sigverif")
#define     SIGVERIF_FLAGS      TEXT("Flags")
#define     SIGVERIF_LOGNAME    TEXT("Logname")

#define SIGVERIF_PRINTER_ENV	TEXT("All")

// This structure holds all the information for a specific file.
typedef struct tagFileNode
{
    LPTSTR          lpFileName;
    LPTSTR          lpDirName;
    LPTSTR          lpVersion;
    LPTSTR          lpCatalog;
    LPTSTR          lpSignedBy;
    LPTSTR          lpTypeName;
    INT             iIcon;
    BOOL            bSigned;
    BOOL            bScanned;
    BOOL            bValidateAgainstAnyOs;
    DWORD           LastError;
    SYSTEMTIME      LastModified;
    struct  tagFileNode *next;
} FILENODE, *LPFILENODE;

// This structure is used by walkpath to keep track of subdirectories
typedef struct tagDirNode {
    TCHAR   DirName[MAX_PATH];
    struct  tagDirNode *next;
} DIRNODE, *LPDIRNODE;

// This structure is used when we walk the devicemanager list.
typedef struct _DeviceTreeNode 
{
    struct _DeviceTreeNode *Child;
    struct _DeviceTreeNode *Sibling;
    DEVINST    DevInst;
    TCHAR      Driver[MAX_PATH];
} DEVTREENODE, *PDEVTREENODE;

typedef struct _DeviceTreeData 
{
    HDEVINFO hDeviceInfo;
    DEVTREENODE RootNode;
} DEVICETREE, *PDEVICETREE;

// This is our global data structure that hold our global variables.
typedef struct tagAppData
{
    HWND        hDlg;
    HWND        hLogging;
    HWND        hSearch;
    HICON       hIcon;
    HINSTANCE   hInstance;
    TCHAR       szScanPath[MAX_PATH];
    TCHAR       szScanPattern[MAX_PATH];
    TCHAR       szLogFile[MAX_PATH];
    TCHAR       szLogDir[MAX_PATH];
    TCHAR       szWinDir[MAX_PATH];
    LPFILENODE  lpFileList;
    LPFILENODE  lpFileLast;
    HCATADMIN   hCatAdmin;
    DWORD       dwFiles;
    DWORD       dwSigned;
    DWORD       dwUnsigned;
    BOOL        bOverwrite;
    BOOL        bLoggingEnabled;
    BOOL        bAutomatedScan;
    BOOL        bScanning;
    BOOL        bStopScan;
    BOOL        bUserScan;
    BOOL        bSubFolders;
    BOOL        bNoAuthenticode;
    DWORD       LastError;
} GAPPDATA, *LPGAPPDATA;

// Global function prototypes
BOOL BrowseForFolder(HWND hwnd, LPTSTR lpszBuf, DWORD BufCchSize);
DWORD BuildFileList(LPTSTR lpPathName);
BOOL VerifyFileList(void);
BOOL VerifyFileNode(LPFILENODE lpFileNode);
void MyLoadString(LPTSTR lpString, ULONG CchStringSize, UINT uId);
void MyMessageBox(LPTSTR lpString);
void MyErrorBox(LPTSTR lpString);
void MyErrorBoxId(UINT uId);
void MyMessageBoxId(UINT uId);
UINT MyGetWindowsDirectory(LPTSTR lpDirName, UINT DirNameCchSize);
LPTSTR MyStrStr(LPTSTR lpString, LPTSTR lpSubString);
INT_PTR CALLBACK Details_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ListView_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LogFile_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LPFILENODE CreateFileNode(LPTSTR lpDirectory, LPTSTR lpFileName);
BOOL IsFileAlreadyInList(LPTSTR lpDirName, LPTSTR lpFileName);
void SigVerif_Help(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL bContext);
void AdvancedPropertySheet(HWND hwnd);
void InsertFileNodeIntoList(LPFILENODE lpFileNode);
void DestroyFileList(BOOL bClear);
void DestroyFileNode(LPFILENODE lpFileNode);
BOOL PrintFileList(void);
void Progress_InitRegisterClass(void);
DWORD BuildDriverFileList(void);
DWORD BuildPrinterFileList(void);
DWORD BuildCoreFileList(void);
void MyGetFileInfo(LPFILENODE lpFileInfo);


//
// Context-Sensitive Help/Identifiers specific to SigVerif
//
#define SIGVERIF_HELPFILE                       TEXT("SIGVERIF.HLP")
#define WINDOWS_HELPFILE                        TEXT("WINDOWS.HLP")
#define IDH_SIGVERIF_SEARCH_CHECK_SYSTEM        1000
#define IDH_SIGVERIF_SEARCH_LOOK_FOR            1010
#define IDH_SIGVERIF_SEARCH_SCAN_FILES          1020
#define IDH_SIGVERIF_SEARCH_LOOK_IN_FOLDER      1030
#define IDH_SIGVERIF_SEARCH_INCLUDE_SUBFOLDERS  1040
#define IDH_SIGVERIF_LOGGING_ENABLE_LOGGING     1050
#define IDH_SIGVERIF_LOGGING_APPEND             1060
#define IDH_SIGVERIF_LOGGING_OVERWRITE          1070
#define IDH_SIGVERIF_LOGGING_FILENAME           1080
#define IDH_SIGVERIF_LOGGING_VIEW_LOG           1090

//
// Context-Sensitive Help Identifiers for Browse button
//
#define IDH_BROWSE  28496

//
// g_App is allocated in SIGVERIF.C, so everywhere else we want to make it extern
//
#ifndef SIGVERIF_DOT_C
extern GAPPDATA g_App;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\sigtab\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sigtab.rc
//
#define IDD_SIGTAB                      102
#define IDC_IGNORE                      1000
#define IDC_WARN                        1001
#define IDC_BLOCK                       1002
#define IDC_GLOBAL                      1003
#define IDG_ADMIN                       1004
#define IDC_LINK                        1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

//
// Version Information
//
#include <winver.h>
#include <ntverp.h>
#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "File Integrity Settings"
#define VER_INTERNALNAME_STR            "sigtab.dll"
#define VER_ORIGINALFILENAME_STR        "sigtab.dll"
#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\sigverif.c ===
//
//  SIGVERIF.C
//
#define SIGVERIF_DOT_C
#include "sigverif.h"

// Allocate our global data structure
GAPPDATA    g_App;

//
//  Load a resource string into a buffer that is assumed to be MAX_PATH bytes.
//
void 
MyLoadString(
    LPTSTR lpString, 
    ULONG CchStringSize, 
    UINT uId
    )
{
    LoadString(g_App.hInstance, uId, lpString, CchStringSize);
}

//
//  Pop an OK messagebox with a specific string
//
void 
MyMessageBox(
    LPTSTR lpString
    )
{
    TCHAR szBuffer[MAX_PATH];

    MyLoadString(szBuffer, cA(szBuffer), IDS_MSGBOX);
    MessageBox(g_App.hDlg, lpString, szBuffer, MB_OK);
}

//
//  Pop an OK messagebox with a resource string ID
//
void 
MyMessageBoxId(
    UINT uId
    )
{
    TCHAR szBuffer[MAX_PATH];

    MyLoadString(szBuffer, cA(szBuffer), uId);
    MyMessageBox(szBuffer);
}

//
//  Pop an error messagebox with a specific string
//
void 
MyErrorBox(
    LPTSTR lpString
    )
{
    TCHAR szBuffer[MAX_PATH];

    MyLoadString(szBuffer, cA(szBuffer), IDS_ERRORBOX);
    MessageBox(g_App.hDlg, lpString, szBuffer, MB_OK);
}

//
//  Pop an error messagebox with a resource string ID
//
void 
MyErrorBoxId(
    UINT uId
    )
{
    TCHAR szBuffer[MAX_PATH];

    MyLoadString(szBuffer, cA(szBuffer), uId);
    MyErrorBox(szBuffer);
}

void 
MyErrorBoxIdWithErrorCode(
    UINT uId,
    DWORD ErrorCode
    )
{
    TCHAR szBuffer[MAX_PATH];
    ULONG cchSize;
    HRESULT hr;
    PTSTR errorMessage = NULL;
    LPVOID lpLastError = NULL;

    //
    // Get the error text for the error code.
    //
    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_SYSTEM |
                      FORMAT_MESSAGE_IGNORE_INSERTS,
                      NULL,
                      ErrorCode,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (LPTSTR)&lpLastError,
                      0,
                      NULL) != 0) {

        if (lpLastError) {

            MyLoadString(szBuffer, cA(szBuffer), uId);

            cchSize = lstrlen(szBuffer) + lstrlen(lpLastError) + 1;

            errorMessage = MALLOC(cchSize * sizeof(TCHAR));

            if (errorMessage) {

                hr = StringCchCopy(errorMessage, cchSize, szBuffer);

                if (SUCCEEDED(hr)) {
                    hr = StringCchCat(errorMessage, cchSize, lpLastError);
                }

                // 
                // We want to show the error message, even if the
                // buffer was truncated.
                //
                if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    MyMessageBox(errorMessage);
                }

                FREE(errorMessage);
            }

            LocalFree(lpLastError);
        }
    }
}

//
// Since Multi-User Windows will give me back a Profile directory, I need to get the real Windows directory
// Dlg_OnInitDialog initializes g_App.szWinDir with the real Windows directory, so I just use that.
//
UINT 
MyGetWindowsDirectory(
    LPTSTR lpDirName, 
    UINT DirNameCchSize
    )
{
    UINT  uRet = 0;

    if (lpDirName) {

        if (SUCCEEDED(StringCchCopy(lpDirName, DirNameCchSize, g_App.szWinDir))) {
            uRet = lstrlen(lpDirName);
        } else {
            //
            // If the directory name can't fit in the buffer that the caller
            // provided, then set it to 0 (if they provided a buffer of at
            // least size 1) since we don't want to return a truncated 
            // directory to the caller.
            //
            if (DirNameCchSize > 0) {
                *lpDirName = 0;
            }

            uRet = 0;
        }
    }

    return uRet;
}

//
//  Initialization of main dialog.
//
BOOL 
Dlg_OnInitDialog(
    HWND hwnd
    )
{
    DWORD   Err = ERROR_SUCCESS;
    HKEY    hKey;
    LONG    lRes;
    DWORD   dwType, dwFlags, cbData;
    TCHAR   szBuffer[MAX_PATH];
    LPTSTR  lpCommandLine, lpStart, lpEnd;
    ULONG   cchSize;

    //
    // Initialize global hDlg to current hwnd.
    //
    g_App.hDlg = hwnd;

    //
    // Set the window class to have the icon in the resource file
    //
    if (g_App.hIcon) {
        SetClassLongPtr(hwnd, GCLP_HICON, (LONG_PTR) g_App.hIcon);
    }

    //
    // Make sure the IDC_STATUS control is hidden until something happens.
    //
    ShowWindow(GetDlgItem(g_App.hDlg, IDC_STATUS), SW_HIDE);

    //
    // Set the range for the custom progress bar to 0-100.
    //
    SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETRANGE, (WPARAM) 0, (LPARAM) MAKELPARAM(0, 100));

    //
    // Set the global lpLogName to the one that's given in the resource file
    //
    MyLoadString(g_App.szLogFile, cA(g_App.szLogFile), IDS_LOGNAME);

    //
    // Figure out what the real Windows directory is and store it in g_App.szWinDir
    // This is required because Hydra makes GetWindowsDirectory return a PROFILE directory
    //
    // We store the original CurrentDirectory in szBuffer so we can restore it after this hack.
    // Next we switch into the SYSTEM/SYSTEM32 directory and then into its parent directory.
    // This is what we want to store in g_App.szWinDir.
    //
    GetCurrentDirectory(cA(szBuffer), szBuffer);
    GetSystemDirectory(g_App.szWinDir, cA(g_App.szWinDir));
    SetCurrentDirectory(g_App.szWinDir);
    SetCurrentDirectory(TEXT(".."));
    GetCurrentDirectory(cA(g_App.szWinDir), g_App.szWinDir);
    SetCurrentDirectory(szBuffer);

    //
    // Set the global search folder to %WinDir%
    //
    MyGetWindowsDirectory(g_App.szScanPath, cA(g_App.szScanPath));

    //
    // Set the global search pattern to "*.*"
    //
    MyLoadString(g_App.szScanPattern, cA(g_App.szScanPattern), IDS_ALL);

    //
    // Reset the progress bar back to zero percent
    //
    SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) 0, (LPARAM) 0);

    //
    // By default, we want to turn logging and set the logging mode to OVERWRITE
    //
    g_App.bLoggingEnabled   = TRUE;
    g_App.bOverwrite        = TRUE;
    
    //
    // Look in the registry for any settings from the last SigVerif session
    //
    lRes = RegOpenKeyEx(HKEY_CURRENT_USER,
                        SIGVERIF_KEY,
                        0,
                        KEY_READ,
                        &hKey);

    if (lRes == ERROR_SUCCESS) {

        cbData = sizeof(DWORD);
        lRes = RegQueryValueEx( hKey,
                                SIGVERIF_FLAGS,
                                NULL,
                                &dwType,
                                (LPBYTE) &dwFlags,
                                &cbData);
        if (lRes == ERROR_SUCCESS) {

            g_App.bLoggingEnabled   = (dwFlags & 0x1);
            g_App.bOverwrite        = (dwFlags & 0x2);
        }

        cbData = sizeof(szBuffer);
        lRes = RegQueryValueEx( hKey,
                                SIGVERIF_LOGNAME,
                                NULL,
                                &dwType,
                                (LPBYTE) szBuffer,
                                &cbData);
        if (lRes == ERROR_SUCCESS && dwType == REG_SZ) {
            //
            // This should never happen unless the code is changed
            // so that szBuffer is larger then g_App.szLogFile, but
            // for safety if we can't copy szBuffer fully into
            // g_App.szLogFile, then set g_App.szLogFile to 0 so we
            // don't log to a truncated location.
            //
            if (FAILED(StringCchCopy(g_App.szLogFile, cA(g_App.szLogFile), szBuffer))) {
                g_App.szLogFile[0] = 0;
            }
        }

        RegCloseKey(hKey);
    }

    //
    // If the user specified the LOGDIR flag, we want to create the log
    // file in that directory.
    //
    //
    // SECURITY: Verify that LOGDIR exists and the user has the correct access
    // to it, and if they don't then fail up front.
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_LOGDIR);
    if (SUCCEEDED(StringCchCat(szBuffer, cA(szBuffer), TEXT(":"))) &&
        ((lpStart = MyStrStr(GetCommandLine(), szBuffer)) != NULL)) {

        lpStart += lstrlen(szBuffer);

        if (lpStart && *lpStart) {
            //
            // The string in lpStart is the directory that we want to log
            // into.
            //
            cchSize = lstrlen(lpStart) + 1;
            lpCommandLine = MALLOC(cchSize * sizeof(TCHAR));

            if (lpCommandLine) {

                if (SUCCEEDED(StringCchCopy(lpCommandLine, cchSize, lpStart))) {

                    lpStart = lpCommandLine;

                    //
                    // First skip any white space.
                    //

                    while (*lpStart && (isspace(*lpStart))) {
                    
                        lpStart++;
                    }

                    //
                    // We will deal with two cases, one where the path
                    // starts with a quote, and the other where it does 
                    // not.
                    //
                    if (*lpStart) {
                    
                        if (*lpStart == TEXT('\"')) {
                            //
                            // The log path starts with a quote.  This means that
                            // we will use all of the string until we either hit 
                            // the end of the string, or we find another quote.
                            //
                            lpStart++;

                            lpEnd = lpStart;

                            while (*lpEnd && (*lpEnd != TEXT('\"'))) {

                                lpEnd++;
                            }
                        
                        } else {
                            //
                            // The log path does NOT start with a quote, so 
                            // use the characters until we come to the end
                            // of the string or a space.
                            //
                            lpEnd = lpStart;

                            while (*lpEnd && (isspace(*lpEnd))) {

                                lpEnd++;
                            }
                        }

                        *lpEnd = TEXT('\0');

                        if (FAILED(StringCchCopy(g_App.szLogDir, cA(g_App.szLogDir), lpStart))) {
                            //
                            // The user probably typed in too many characters for
                            // the log dir.
                            //
                            Err = ERROR_DIRECTORY;
                        
                        } else {
                            //
                            // Verify that the log dir exists and is a directory.
                            //
                            DWORD attributes;

                            attributes = GetFileAttributes(g_App.szLogDir);

                            if (attributes == INVALID_FILE_ATTRIBUTES) {
                                Err = ERROR_DIRECTORY;
                            } else if (!(attributes & FILE_ATTRIBUTE_DIRECTORY)) {
                                Err = ERROR_DIRECTORY;
                            }
                        }
                    }
                }

                FREE(lpCommandLine);
            }
        }

        if (Err != ERROR_SUCCESS) {
            MyMessageBoxId(IDS_LOGDIRERROR);
        }
    }

    //
    // By default we will consider Authenticode signed drivers as valid, but
    // if the user specifies the /NOAUTHENTICODE switch then Authenticode
    // signed drivers will not be valid.
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_NOAUTHENTICODE);
    if (MyStrStr(GetCommandLine(), szBuffer)) {
        g_App.bNoAuthenticode = TRUE;
    }

    //
    // If the user specified the DEFSCAN flag, we want to automatically do a 
    // default scan and log the results.
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_DEFSCAN);
    if (MyStrStr(GetCommandLine(), szBuffer)) {

        g_App.bAutomatedScan      = TRUE;
        g_App.bLoggingEnabled     = TRUE;
        
        //
        // Now that everything is set up, simulate a click to the START button...
        //
        PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(ID_START, 0), (LPARAM) 0);
    }

    if (Err == ERROR_SUCCESS) {
        return TRUE;
    
    } else {

        g_App.LastError = Err;
        return FALSE;
    }
}

//
//  Build file list according to dialog settings, then verify the files in the list
//
void WINAPI 
ProcessFileList(void)
{
    DWORD Err = ERROR_SUCCESS;
    TCHAR szBuffer[MAX_PATH];
    ULONG cchSize;
    HRESULT hr;

    //
    // Set the scanning flag to TRUE, so we don't double-scan
    //
    g_App.bScanning = TRUE;

    // Assume a successfull scan.
    g_App.LastError = ERROR_SUCCESS;

    //
    // Change the "Start" to "Stop"
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_STOP);
    SetDlgItemText(g_App.hDlg, ID_START, szBuffer);

    EnableWindow(GetDlgItem(g_App.hDlg, ID_ADVANCED), FALSE);
    EnableWindow(GetDlgItem(g_App.hDlg, IDCANCEL), FALSE);

    //
    // Display the text that says "Building file list..."
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_STATUS_BUILD);
    SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);

    //
    // Make sure the IDC_STATUS text item visible
    //
    ShowWindow(GetDlgItem(g_App.hDlg, IDC_STATUS), SW_SHOW);

    //
    // Free any memory that we may have allocated for the g_App.lpFileList
    //
    DestroyFileList(TRUE);

    //
    // Now actually build the g_App.lpFileList list given the dialog settings
    //
    if (g_App.bUserScan) {
        
        Err = BuildFileList(g_App.szScanPath);
    
    } else {
        if (!g_App.bStopScan && (Err == ERROR_SUCCESS)) {
            Err = BuildDriverFileList();
        }

        if (!g_App.bStopScan && (Err == ERROR_SUCCESS)) {
            Err = BuildPrinterFileList();
        }

        if (!g_App.bStopScan && (Err == ERROR_SUCCESS)) {
            Err = BuildCoreFileList();
        }
    }

    if (!g_App.bAutomatedScan &&
        (Err != ERROR_SUCCESS) && 
        (Err != ERROR_CANCELLED)) {

        g_App.LastError = Err;
        MyErrorBoxIdWithErrorCode(IDS_BUILDLISTERROR, Err);
    }

    //
    // If we encountered an error building the file list then don't bother
    // scanning the files.
    //
    if (Err == ERROR_SUCCESS) {
        //
        // Check if there is even a file list to verify.
        //
        if (g_App.lpFileList) {
    
            if (!g_App.bStopScan) {
                //
                // Display the "Scanning File List..." text
                //
                MyLoadString(szBuffer, cA(szBuffer), IDS_STATUS_SCAN);
                SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);
    
                //
                // Reset the progress bar back to zero percent while it's invisible.
                //
                SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) 0, (LPARAM) 0);
    
                //
                // WooHoo! Let's display the progress bar and start cranking on the file list!
                //
                ShowWindow(GetDlgItem(g_App.hDlg, IDC_PROGRESS), SW_SHOW);
                VerifyFileList();
                ShowWindow(GetDlgItem(g_App.hDlg, IDC_PROGRESS), SW_HIDE);
            }
        } else {
            //
            // The IDC_NOTMS code displays it's own error message, so only display
            // an error dialog if we are doing a System Integrity Scan
            //
            if (!g_App.bStopScan && !g_App.bUserScan)  {
                MyMessageBoxId(IDS_NOSYSTEMFILES);
            }
        }
    
        //
        // Disable the start button while we clean up the g_App.lpFileList
        //
        EnableWindow(GetDlgItem(g_App.hDlg, ID_START), FALSE);
    
        //
        // Log the results.  Note that sigverif will do this even if we encountered
        // an error building or scanning the list, since the logfile may help 
        // figure out which file is causing the problem. Only log the results
        // if we found any files to scan.
        //
        if (!g_App.bStopScan) {
            //
            // Display the text that says "Writing Log File..."
            //
            MyLoadString(szBuffer, cA(szBuffer), IDS_STATUS_LOG);
            SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);
    
            //
            // Write the results to the log file
            //
            if (!PrintFileList()) {
                //
                // We failed while logging for some reason, probably permissions
                // or out of disk space. Let the user know that we could not finish
                // logging all of the files.  
                //
                Err = GetLastError();
    
                if (Err != ERROR_SUCCESS) {
                    
                    MyErrorBoxIdWithErrorCode(IDS_LOGERROR, Err);
                }
            }
        } else {
            //
            // If the user clicked STOP, let them know about it.
            //
            MyMessageBoxId(IDS_SCANSTOPPED);
        }
    }

    //
    // Display the text that says "Freeing File List..."
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_STATUS_FREE);
    SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);

    //
    // Hide the IDC_STATUS text item so it doesn't cover IDC_STATUS
    //
    ShowWindow(GetDlgItem(g_App.hDlg, IDC_STATUS), SW_HIDE);

    //
    // Change the "Stop" button back to "Start"
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_START);
    SetDlgItemText(g_App.hDlg, ID_START, szBuffer);

    EnableWindow(GetDlgItem(g_App.hDlg, ID_START), TRUE);
    EnableWindow(GetDlgItem(g_App.hDlg, ID_ADVANCED), TRUE);
    EnableWindow(GetDlgItem(g_App.hDlg, IDCANCEL), TRUE);

    //
    // Free all the memory that we allocated for the g_App.lpFileList
    //
    DestroyFileList(FALSE);

    //
    // Clear the scanning flag
    //
    g_App.bScanning = FALSE;
    g_App.bStopScan = FALSE;

    //
    // If the user started SigVerif with the /DEFSCAN flag, then we exit.
    //
    if (g_App.bAutomatedScan) {
        PostMessage(g_App.hDlg, WM_CLOSE, (WPARAM) 0, (LPARAM) 0);
    }
}

//
//  Spawns a thread to do the scan so the GUI remains responsive.
//
void 
Dlg_OnPushStartButton(
    HWND hwnd
    )
{
    HANDLE hThread;
    DWORD dwThreadId;

    UNREFERENCED_PARAMETER(hwnd);

    //
    // Check if we are already scanning... if so, bail.
    //
    if (g_App.bScanning) {
        return;
    }

    //
    // Create a thread where Search_ProcessFileList can go without tying up the GUI thread.
    //
    hThread = CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE) ProcessFileList,
                           0,
                           0,
                           &dwThreadId);

    CloseHandle(hThread);
}

//
//  Handle any WM_COMMAND messages sent to the search dialog
//
void 
Dlg_OnCommand(
    HWND hwnd, 
    int id, 
    HWND hwndCtl, 
    UINT codeNotify
    )
{
    UNREFERENCED_PARAMETER(hwndCtl);
    UNREFERENCED_PARAMETER(codeNotify);

    switch(id) {
        //
        //  The user clicked ID_START, so if we aren't scanning start scanning.
        //  If we are scanning, then stop the tests because the button actually says "Stop"
        //
        case ID_START:
            if (!g_App.bScanning) {

                Dlg_OnPushStartButton(hwnd);
            
            } else if (!g_App.bStopScan) {

                g_App.bStopScan = TRUE;
                g_App.LastError = ERROR_CANCELLED;
            }
            break;

        //
        //  The user clicked IDCANCEL, so if the tests are running try to stop them before exiting.
        //
        case IDCANCEL:
            if (g_App.bScanning) {

                g_App.bStopScan = TRUE;
                g_App.LastError = ERROR_CANCELLED;
            
            } else {

                SendMessage(hwnd, WM_CLOSE, 0, 0);
            }
            break;

        //  Pop up the IDD_SETTINGS dialog so the user can change their log settings.
        case ID_ADVANCED:
            if (!g_App.bScanning) {

                AdvancedPropertySheet(hwnd);
            }
            break;
    }
}

void 
SigVerif_Help(
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    BOOL bContext
    )
{
    static DWORD SigVerif_HelpIDs[] =
    {
        IDC_SCAN,           IDH_SIGVERIF_SEARCH_CHECK_SYSTEM,
        IDC_NOTMS,          IDH_SIGVERIF_SEARCH_LOOK_FOR,
        IDC_TYPE,           IDH_SIGVERIF_SEARCH_SCAN_FILES,
        IDC_FOLDER,         IDH_SIGVERIF_SEARCH_LOOK_IN_FOLDER,
        IDC_SUBFOLDERS,     IDH_SIGVERIF_SEARCH_INCLUDE_SUBFOLDERS,
        IDC_ENABLELOG,      IDH_SIGVERIF_LOGGING_ENABLE_LOGGING,
        IDC_APPEND,         IDH_SIGVERIF_LOGGING_APPEND,
        IDC_OVERWRITE,      IDH_SIGVERIF_LOGGING_OVERWRITE,
        IDC_LOGNAME,        IDH_SIGVERIF_LOGGING_FILENAME,
        IDC_VIEWLOG,        IDH_SIGVERIF_LOGGING_VIEW_LOG,
        0,0
    };

    static DWORD Windows_HelpIDs[] =
    {
        ID_BROWSE,      IDH_BROWSE,
        0,0
    };

    HWND hItem = NULL;
    LPHELPINFO lphi = NULL;
    POINT point;

    switch (uMsg) {
        
    case WM_HELP:
        lphi = (LPHELPINFO) lParam;
        if (lphi && (lphi->iContextType == HELPINFO_WINDOW)) {
            hItem = (HWND) lphi->hItemHandle;
        }
        break;

    case WM_CONTEXTMENU:
        hItem = (HWND) wParam;
        point.x = GET_X_LPARAM(lParam);
        point.y = GET_Y_LPARAM(lParam);
        if (ScreenToClient(hwnd, &point)) {
            hItem = ChildWindowFromPoint(hwnd, point);
        }
        break;
    }

    if (hItem) {
        if (GetWindowLong(hItem, GWL_ID) == ID_BROWSE) {
            WinHelp(hItem,
                    (LPCTSTR) WINDOWS_HELPFILE,
                    (bContext ? HELP_CONTEXTMENU : HELP_WM_HELP),
                    (ULONG_PTR) Windows_HelpIDs);
        } else {
            WinHelp(hItem,
                    (LPCTSTR) SIGVERIF_HELPFILE,
                    (bContext ? HELP_CONTEXTMENU : HELP_WM_HELP),
                    (ULONG_PTR) SigVerif_HelpIDs);
        }
    }
}

//
//  The main dialog procedure.  Needs to handle WM_INITDIALOG, WM_COMMAND, and WM_CLOSE/WM_DESTROY.
//
INT_PTR CALLBACK 
DlgProc(
    HWND hwnd, 
    UINT uMsg,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
        
    HANDLE_MSG(hwnd, WM_COMMAND, Dlg_OnCommand);

    case WM_INITDIALOG:
        fProcessed = Dlg_OnInitDialog(hwnd);
        break;

    case WM_CLOSE:
        if (g_App.bScanning) {
            g_App.bStopScan = TRUE;
            g_App.LastError = ERROR_CANCELLED;
        
        } else { 
            EndDialog(hwnd, IDCANCEL);
        }
        break;

    default: 
        fProcessed = FALSE;
    }

    return fProcessed;
}

//
//  Program entry point.  Set up for creation of IDD_DIALOG.
//
WINAPI 
WinMain(
    HINSTANCE hInstance, 
    HINSTANCE hPrevInstance,
    LPSTR lpszCmdParam, 
    int nCmdShow
    )
{
    HWND hwnd;
    TCHAR szAppName[MAX_PATH];

    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpszCmdParam);
    UNREFERENCED_PARAMETER(nCmdShow);

    ZeroMemory(&g_App, sizeof(GAPPDATA));

    g_App.hInstance = hInstance;

    //
    // Look for any existing instances of SigVerif...
    //
    MyLoadString(szAppName, cA(szAppName), IDS_SIGVERIF);
    hwnd = FindWindow(NULL, szAppName);
    if (!hwnd) {
        //
        // We definitely need this for the progress bar, and maybe other stuff too.
        //
        InitCommonControls();

        //
        // Register the custom control we use for the progress bar
        //
        Progress_InitRegisterClass();

        //
        // Load the icon from the resource file that we will use everywhere
        //
        g_App.hIcon = LoadIcon(g_App.hInstance, MAKEINTRESOURCE(IDI_ICON1));

        //
        // Create the IDD_DIALOG and use DlgProc as the main procedure
        //
        DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG), NULL, DlgProc);

        if (g_App.hIcon) {
            DestroyIcon(g_App.hIcon);
            g_App.hIcon = NULL;
        }
    } else {
        //
        // If there is already an instance of SigVerif running, make that one 
        // foreground and we exit.
        //
        SetForegroundWindow(hwnd);
    }

    //
    // If we encountered any errors during our scan, then return the error code,
    // otherwise return 0 if all the files are signed or 1 if we found any
    // unsigned files.
    //
    if (g_App.LastError != ERROR_SUCCESS) {
        return g_App.LastError;
    } else {
        return ((g_App.dwUnsigned > 0) ? 1 : 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\walkpath.c ===
//
// WALKPATH.C
//
#include "sigverif.h"

BOOL        g_bRecurse  = TRUE;

//
// This function takes a directory name and a search pattern and looks for all 
// files mathching the pattern.
// If bRecurse is set, then it will add subdirectories to the end of the 
// g_lpDirList for subsequent traversal.
// 
// In this routine we allocate and fill in some of the lpFileNode values that 
// we know about.
//
DWORD 
FindFile(
    TCHAR *lpDirName, 
    TCHAR *lpFileName
    )
{
    DWORD           Err = ERROR_SUCCESS;
    DWORD           dwRet;
    HANDLE          hFind = INVALID_HANDLE_VALUE;
    LPFILENODE      lpFileNode;
    WIN32_FIND_DATA FindFileData;
    TCHAR           szFullPathName[MAX_PATH];

    //
    // If the user clicked STOP, then bail immediately!
    // If the directory is bogus, then skip to the next one.
    //
    if (!g_App.bStopScan) {
        
        if (g_bRecurse) {
            //
            // The user wants to get all the subdirectories as well, so first 
            // process all of the directories under this path.
            //
            if (FAILED(StringCchCopy(szFullPathName, cA(szFullPathName), lpDirName)) ||
                !pSetupConcatenatePaths(szFullPathName, TEXT("*.*"), cA(szFullPathName), NULL)) {
            
                Err = ERROR_BAD_PATHNAME;
                goto clean0;
            }
            
            hFind = FindFirstFile(szFullPathName, &FindFileData);
            
            if (hFind != INVALID_HANDLE_VALUE) {

                do {

                    if (lstrcmp(FindFileData.cFileName, TEXT(".")) &&
                        lstrcmp(FindFileData.cFileName, TEXT("..")) &&
                        (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

    
                        if (SUCCEEDED(StringCchCopy(szFullPathName, cA(szFullPathName), lpDirName)) &&
                            pSetupConcatenatePaths(szFullPathName, FindFileData.cFileName, cA(szFullPathName), NULL)) {

                            Err = FindFile(szFullPathName, lpFileName);
                        
                        } else {
                            
                            Err = ERROR_BAD_PATHNAME;
                        }
                    }
                    
                } while (!g_App.bStopScan && 
                         (Err == ERROR_SUCCESS) &&
                         FindNextFile(hFind, &FindFileData));

                FindClose(hFind);
                hFind = INVALID_HANDLE_VALUE;
            }
        }

        //
        // If we failed to process one of the directories then just bail out
        // now.
        //
        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Process the files in this directory.
        //
        if (FAILED(StringCchCopy(szFullPathName, cA(szFullPathName), lpDirName)) ||
            !pSetupConcatenatePaths(szFullPathName, lpFileName, cA(szFullPathName), NULL)) {

            Err = ERROR_BAD_PATHNAME;
            goto clean0;
        }

        hFind = FindFirstFile(szFullPathName, &FindFileData);
        if (hFind != INVALID_HANDLE_VALUE) {
            
            do {
                //
                // While there are more files to be found, keep looking in the 
                // directory...
                //
                if (lstrcmp(FindFileData.cFileName, TEXT(".")) &&
                    lstrcmp(FindFileData.cFileName, TEXT("..")) &&
                    !(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    
                    //
                    // Allocate an lpFileNode, fill it in, and add it to the end 
                    // of g_App.lpFileList
                    //
                    // We need to call CharLowerBuff on the file and dir names 
                    // because the catalog files all contain lower-case names 
                    // for the files.
                    //
                    lpFileNode = CreateFileNode(lpDirName, FindFileData.cFileName);

                    if (lpFileNode) {
                        
                        if (!g_App.lpFileList) {
                            g_App.lpFileList = lpFileNode;
                        } else { 
                            g_App.lpFileLast->next = lpFileNode;
                        }

                        g_App.lpFileLast = lpFileNode;

                        //
                        // Increment the total number of files we've found that 
                        // meet the search criteria.
                        //
                        g_App.dwFiles++;
                    } else {

                        Err = GetLastError();
                    }
                }

            } while (!g_App.bStopScan && 
                     (Err == ERROR_SUCCESS) &&
                     FindNextFile(hFind, &FindFileData));

            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }

clean0:

    if (hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;
    }

    return Err;
}

//
// Build an g_App.lpFileList given the user settings in the main dialog.
//
DWORD 
BuildFileList(
    LPTSTR lpPathName
    )
{
    DWORD       Err = ERROR_SUCCESS;
    TCHAR       FileName[MAX_PATH];

    //
    // Check if this is a valid starting directory.
    // If not, then pop up an error message.
    //
    if (!SetCurrentDirectory(lpPathName)) {
        Err = ERROR_BAD_PATHNAME;
        goto clean0;
    }

    //
    // If the "Include Subdirectories" is checked, then bRecurse is TRUE.
    //
    if (g_App.bSubFolders) {
        g_bRecurse = TRUE;
    } else {
        g_bRecurse = FALSE;
    }

    //
    // Get the search pattern from the resource or the user-specified string
    //
    if (g_App.bUserScan) {
        if (FAILED(StringCchCopy(FileName, cA(FileName), g_App.szScanPattern))) {
            //
            // This shouldn't happen since we should check the size of
            // szScanPattern at the time we read it in from the UI.
            //
            goto clean0;
        }
    } else {
        MyLoadString(FileName, cA(FileName), IDS_ALL);
    }

    //
    // Process the g_lpDirList as long as the user doesn't click STOP!
    //
    Err = FindFile(lpPathName, FileName);

clean0:

    //
    // If there weren't any files found, then let the user know about it.
    //
    if (!g_App.lpFileList && (Err == ERROR_SUCCESS)) {
        MyMessageBoxId(IDS_NOFILES);
    }

    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\verify.c ===
//
// VERIFY.C
//
#include "sigverif.h"

//
// Find the file extension and place it in the lpFileNode->lpTypeName field
//
void
MyGetFileTypeName(
    LPFILENODE lpFileInfo
    )
{
    TCHAR szBuffer[MAX_PATH];
    TCHAR szBuffer2[MAX_PATH];
    TCHAR szExt[MAX_PATH];
    LPTSTR lpExtension;
    ULONG BufCbSize;
    HRESULT hr;

    //
    // Initialize szBuffer to be an empty string.
    //
    szBuffer[0] = TEXT('\0');

    //
    // Walk to the end of lpFileName
    //
    for (lpExtension = lpFileInfo->lpFileName; *lpExtension; lpExtension++);

    //
    // Walk backwards until we hit a '.' and we'll use that as our extension
    //
    for (lpExtension--; *lpExtension && lpExtension >= lpFileInfo->lpFileName; lpExtension--) {

        if (lpExtension[0] == TEXT('.')) {
            //
            // Since the file extension is just used for display and logging purposes, if
            // it is too large to fit in our local buffer then just truncate it.
            //
            if (SUCCEEDED(StringCchCopy(szExt, cA(szExt), lpExtension + 1))) {
                CharUpperBuff(szExt, lstrlen(szExt));
                MyLoadString(szBuffer2, cA(szBuffer2), IDS_FILETYPE);

                if (FAILED(StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, szExt))) {
                    //
                    // There is no point in displaying a partial extension so
                    // just set szBuffer to the empty string so we show the
                    // generic extension.
                    //
                    szBuffer[0] = TEXT('\0');
                }
            }
        }
    }

    //
    // If there's no extension, then just call this a "File".
    //
    if (szBuffer[0] == 0) {

        MyLoadString(szBuffer, cA(szBuffer), IDS_FILE);
    }

    BufCbSize = (lstrlen(szBuffer) + 1) * sizeof(TCHAR);
    lpFileInfo->lpTypeName = MALLOC(BufCbSize);

    if (lpFileInfo->lpTypeName) {

        hr = StringCbCopy(lpFileInfo->lpTypeName, BufCbSize, szBuffer);

        if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
            //
            // If we fail for some reason other than insufficient
            // buffer, then free the string and set the pointer
            // to NULL, since the string is undefined.
            //
            FREE(lpFileInfo->lpTypeName);
            lpFileInfo->lpTypeName = NULL;
        }
    }
}

//
// Use SHGetFileInfo to get the icon index for the specified file.
//
void
MyGetFileInfo(
    LPFILENODE lpFileInfo
    )
{
    SHFILEINFO  sfi;
    ULONG       BufCbSize;
    HRESULT     hr;

    ZeroMemory(&sfi, sizeof(SHFILEINFO));
    SHGetFileInfo(  lpFileInfo->lpFileName,
                    0,
                    &sfi,
                    sizeof(SHFILEINFO),
                    SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_TYPENAME);

    lpFileInfo->iIcon = sfi.iIcon;

    if (*sfi.szTypeName) {

        BufCbSize = (lstrlen(sfi.szTypeName) + 1) * sizeof(TCHAR);
        lpFileInfo->lpTypeName = MALLOC(BufCbSize);

        if (lpFileInfo->lpTypeName) {

            hr = StringCbCopy(lpFileInfo->lpTypeName, BufCbSize, sfi.szTypeName);

            if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                //
                // If we fail for some reason other than insufficient
                // buffer, then free the string and set the pointer
                // to NULL, since the string is undefined.
                //
                FREE(lpFileInfo->lpTypeName);
                lpFileInfo->lpTypeName = NULL;
            }
        }

    } else {

        MyGetFileTypeName(lpFileInfo);
    }
}

void
GetFileVersion(
    LPFILENODE lpFileInfo
    )
{
    DWORD               dwHandle, dwRet;
    UINT                Length;
    BOOL                bRet;
    LPVOID              lpData = NULL;
    LPVOID              lpBuffer;
    VS_FIXEDFILEINFO    *lpInfo;
    TCHAR               szBuffer[MAX_PATH];
    TCHAR               szBuffer2[MAX_PATH];
    ULONG               BufCbSize;
    HRESULT             hr;

    dwRet = GetFileVersionInfoSize(lpFileInfo->lpFileName, &dwHandle);

    if (dwRet) {

        lpData = MALLOC(dwRet + 1);

        if (lpData) {

            bRet = GetFileVersionInfo(lpFileInfo->lpFileName, dwHandle, dwRet, lpData);

            if (bRet) {

                lpBuffer = NULL;
                Length = 0;
                bRet = VerQueryValue(lpData, TEXT("\\"), &lpBuffer, &Length);

                if (bRet) {

                    lpInfo = (VS_FIXEDFILEINFO *) lpBuffer;

                    MyLoadString(szBuffer2, cA(szBuffer2), IDS_VERSION);

                    hr = StringCchPrintf(szBuffer,
                                         cA(szBuffer),
                                         szBuffer2,
                                         HIWORD(lpInfo->dwFileVersionMS),
                                         LOWORD(lpInfo->dwFileVersionMS),
                                         HIWORD(lpInfo->dwFileVersionLS),
                                         LOWORD(lpInfo->dwFileVersionLS));

                    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {

                        BufCbSize = (lstrlen(szBuffer) + 1) * sizeof(TCHAR);
                        lpFileInfo->lpVersion = MALLOC(BufCbSize);

                        if (lpFileInfo->lpVersion) {

                            hr = StringCbCopy(lpFileInfo->lpVersion, BufCbSize, szBuffer);

                            if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                                //
                                // If we fail for some reason other than insufficient
                                // buffer, then free the string and set the pointer
                                // to NULL, since the string is undefined.
                                //
                                FREE(lpFileInfo->lpVersion);
                                lpFileInfo->lpVersion = NULL;
                            }
                        }
                    }
                }
            }

            FREE(lpData);
        }
    }

    if (!lpFileInfo->lpVersion) {

        MyLoadString(szBuffer, cA(szBuffer), IDS_NOVERSION);
        BufCbSize = (lstrlen(szBuffer) + 1) * sizeof(TCHAR);
        lpFileInfo->lpVersion = MALLOC(BufCbSize);

        if (lpFileInfo->lpVersion) {

            hr = StringCbCopy(lpFileInfo->lpVersion, BufCbSize, szBuffer);

            if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                //
                // If we fail for some reason other than insufficient
                // buffer, then free the string and set the pointer
                // to NULL, since the string is undefined.
                //
                FREE(lpFileInfo->lpVersion);
                lpFileInfo->lpVersion = NULL;
            }
        }
    }
}

/*************************************************************************
*   Function : VerifyIsFileSigned
*   Purpose : Calls WinVerifyTrust with Policy Provider GUID to
*   verify if an individual file is signed.
**************************************************************************/
BOOL
VerifyIsFileSigned(
    LPTSTR pcszMatchFile,
    PDRIVER_VER_INFO lpVerInfo
    )
{
    HRESULT             hRes;
    WINTRUST_DATA       WinTrustData;
    WINTRUST_FILE_INFO  WinTrustFile;
    GUID                gOSVerCheck = DRIVER_ACTION_VERIFY;
    GUID                gPublishedSoftware = WINTRUST_ACTION_GENERIC_VERIFY_V2;

    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pFile = &WinTrustFile;
    WinTrustData.pPolicyCallbackData = (LPVOID)lpVerInfo;
    WinTrustData.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT |
                               WTD_CACHE_ONLY_URL_RETRIEVAL;

    ZeroMemory(lpVerInfo, sizeof(DRIVER_VER_INFO));
    lpVerInfo->cbStruct = sizeof(DRIVER_VER_INFO);

    ZeroMemory(&WinTrustFile, sizeof(WINTRUST_FILE_INFO));
    WinTrustFile.cbStruct = sizeof(WINTRUST_FILE_INFO);

    WinTrustFile.pcwszFilePath = pcszMatchFile;

    hRes = WinVerifyTrust(g_App.hDlg, &gOSVerCheck, &WinTrustData);
    if (hRes != ERROR_SUCCESS) {

        hRes = WinVerifyTrust(g_App.hDlg, &gPublishedSoftware, &WinTrustData);
    }

    //
    // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
    // that was allocated in our call to WinVerifyTrust.
    //
    if (lpVerInfo && lpVerInfo->pcSignerCertContext) {

        CertFreeCertificateContext(lpVerInfo->pcSignerCertContext);
        lpVerInfo->pcSignerCertContext = NULL;
    }

    return(hRes == ERROR_SUCCESS);
}

//
// Given a specific LPFILENODE, verify that the file is signed or unsigned.
// Fill in all the necessary structures so the listview control can display properly.
//
BOOL
VerifyFileNode(
    LPFILENODE lpFileNode
    )
{
    HANDLE                  hFile;
    BOOL                    bRet;
    HCATINFO                hCatInfo = NULL;
    HCATINFO                PrevCat;
    WINTRUST_DATA           WinTrustData;
    WINTRUST_CATALOG_INFO   WinTrustCatalogInfo;
    DRIVER_VER_INFO         VerInfo;
    GUID                    gSubSystemDriver = DRIVER_ACTION_VERIFY;
    HRESULT                 hRes, hr;
    DWORD                   cbHash = HASH_SIZE;
    BYTE                    szHash[HASH_SIZE];
    LPBYTE                  lpHash = szHash;
    CATALOG_INFO            CatInfo;
    LPTSTR                  lpFilePart;
    TCHAR                   szBuffer[MAX_PATH];
    static TCHAR            szCurrentDirectory[MAX_PATH];
    OSVERSIONINFO           OsVersionInfo;
    ULONG                   BufCbSize;

    //
    // If this is the first item we are verifying, then initialize the static buffer.
    //
    if (lpFileNode == g_App.lpFileList) {

        ZeroMemory(szCurrentDirectory, sizeof(szCurrentDirectory));
    }

    //
    // Check the current directory against the one in the lpFileNode.
    // We only want to call SetCurrentDirectory if the path is different.
    //
    if (lstrcmp(szCurrentDirectory, lpFileNode->lpDirName)) {

        if (!SetCurrentDirectory(lpFileNode->lpDirName) ||
            FAILED(StringCchCopy(szCurrentDirectory, cA(szCurrentDirectory), lpFileNode->lpDirName))) {
            //
            // Well, if we fail to set the current directory, then the code below
            // won't work since it just deals with filenames and not full paths.
            //
            lpFileNode->LastError = ERROR_DIRECTORY;
            return FALSE;
        }
    }

    //
    // Get the handle to the file, so we can call CryptCATAdminCalcHashFromFileHandle
    //
    hFile = CreateFile( lpFileNode->lpFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile == INVALID_HANDLE_VALUE) {

        lpFileNode->LastError = GetLastError();

        return FALSE;
    }

    //
    // Initialize the hash buffer
    //
    ZeroMemory(lpHash, HASH_SIZE);

    //
    // Generate the hash from the file handle and store it in lpHash
    //
    if (!CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, lpHash, 0)) {
        //
        // If we couldn't generate a hash, it might be an individually signed catalog.
        // If it's a catalog, zero out lpHash and cbHash so we know there's no hash to check.
        //
        if (IsCatalogFile(hFile, NULL)) {

            lpHash = NULL;
            cbHash = 0;

        } else {  // If it wasn't a catalog, we'll bail and this file will show up as unscanned.

            CloseHandle(hFile);
            return FALSE;
        }
    }

    //
    // Close the file handle
    //
    CloseHandle(hFile);

    //
    // Now we have the file's hash.  Initialize the structures that
    // will be used later on in calls to WinVerifyTrust.
    //
    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pPolicyCallbackData = (LPVOID)&VerInfo;
    WinTrustData.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT |
                               WTD_CACHE_ONLY_URL_RETRIEVAL;

    ZeroMemory(&VerInfo, sizeof(DRIVER_VER_INFO));
    VerInfo.cbStruct = sizeof(DRIVER_VER_INFO);

    //
    // Only validate against the current OS Version, unless the bValidateAgainstAnyOs
    // parameter was TRUE.  In that case we will just leave the sOSVersionXxx fields
    // 0 which tells WinVerifyTrust to validate against any OS.
    //
    if (!lpFileNode->bValidateAgainstAnyOs) {
        OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
        if (GetVersionEx(&OsVersionInfo)) {
            VerInfo.sOSVersionLow.dwMajor = OsVersionInfo.dwMajorVersion;
            VerInfo.sOSVersionLow.dwMinor = OsVersionInfo.dwMinorVersion;
            VerInfo.sOSVersionHigh.dwMajor = OsVersionInfo.dwMajorVersion;
            VerInfo.sOSVersionHigh.dwMinor = OsVersionInfo.dwMinorVersion;
        }
    }


    WinTrustData.pCatalog = &WinTrustCatalogInfo;

    ZeroMemory(&WinTrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
    WinTrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
    WinTrustCatalogInfo.pbCalculatedFileHash = lpHash;
    WinTrustCatalogInfo.cbCalculatedFileHash = cbHash;
    WinTrustCatalogInfo.pcwszMemberTag = lpFileNode->lpFileName;

    //
    // Now we try to find the file hash in the catalog list, via CryptCATAdminEnumCatalogFromHash
    //
    PrevCat = NULL;

    if (g_App.hCatAdmin) {
        hCatInfo = CryptCATAdminEnumCatalogFromHash(g_App.hCatAdmin, lpHash, cbHash, 0, &PrevCat);
    } else {
        hCatInfo = NULL;
    }

    //
    // We want to cycle through the matching catalogs until we find one that matches both hash and member tag
    //
    bRet = FALSE;
    while (hCatInfo && !bRet) {

        ZeroMemory(&CatInfo, sizeof(CATALOG_INFO));
        CatInfo.cbStruct = sizeof(CATALOG_INFO);

        if (CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0)) {

            WinTrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

            //
            // Now verify that the file is an actual member of the catalog.
            //
            hRes = WinVerifyTrust(g_App.hDlg, &gSubSystemDriver, &WinTrustData);

            if (hRes == ERROR_SUCCESS) {
                GetFullPathName(CatInfo.wszCatalogFile, cA(szBuffer), szBuffer, &lpFilePart);
                BufCbSize = (lstrlen(lpFilePart) + 1) * sizeof(TCHAR);
                lpFileNode->lpCatalog = MALLOC(BufCbSize);

                if (lpFileNode->lpCatalog) {

                    hr = StringCbCopy(lpFileNode->lpCatalog, BufCbSize, lpFilePart);

                    if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                        //
                        // If we fail for some reason other than insufficient
                        // buffer, then free the string and set the pointer
                        // to NULL, since the string is undefined.
                        //
                        FREE(lpFileNode->lpCatalog);
                        lpFileNode->lpCatalog = NULL;
                    }
                }

                bRet = TRUE;
            }

            //
            // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
            // that was allocated in our call to WinVerifyTrust.
            //
            if (VerInfo.pcSignerCertContext != NULL) {

                CertFreeCertificateContext(VerInfo.pcSignerCertContext);
                VerInfo.pcSignerCertContext = NULL;
            }
        }

        if (!bRet) {
            //
            // The hash was in this catalog, but the file wasn't a member...
            // so off to the next catalog
            //
            PrevCat = hCatInfo;
            hCatInfo = CryptCATAdminEnumCatalogFromHash(g_App.hCatAdmin, lpHash, cbHash, 0, &PrevCat);
        }
    }

    //
    // Mark this file as having been scanned.
    //
    lpFileNode->bScanned = TRUE;

    if (!hCatInfo) {
        //
        // If it wasn't found in the catalogs, check if the file is individually
        // signed.
        //
        bRet = VerifyIsFileSigned(lpFileNode->lpFileName, (PDRIVER_VER_INFO)&VerInfo);

        if (bRet) {
            //
            // If so, mark the file as being signed.
            //
            lpFileNode->bSigned = TRUE;
        }

    } else {
        //
        // The file was verified in the catalogs, so mark it as signed and free
        // the catalog context.
        //
        lpFileNode->bSigned = TRUE;
        CryptCATAdminReleaseCatalogContext(g_App.hCatAdmin, hCatInfo, 0);
    }

    if (lpFileNode->bSigned) {

        BufCbSize = (lstrlen(VerInfo.wszVersion) + 1) * sizeof(TCHAR);
        lpFileNode->lpVersion = MALLOC(BufCbSize);

        if (lpFileNode->lpVersion) {

            hr = StringCbCopy(lpFileNode->lpVersion, BufCbSize, VerInfo.wszVersion);

            if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                //
                // If we fail for some reason other than insufficient
                // buffer, then free the string and set the pointer
                // to NULL, since the string is undefined.
                //
                FREE(lpFileNode->lpVersion);
                lpFileNode->lpVersion = NULL;
            }
        }

        BufCbSize = (lstrlen(VerInfo.wszSignedBy) + 1) * sizeof(TCHAR);
        lpFileNode->lpSignedBy = MALLOC(BufCbSize);

        if (lpFileNode->lpSignedBy) {

            hr = StringCbCopy(lpFileNode->lpSignedBy, BufCbSize, VerInfo.wszSignedBy);

            if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                //
                // If we fail for some reason other than insufficient
                // buffer, then free the string and set the pointer
                // to NULL, since the string is undefined.
                //
                FREE(lpFileNode->lpSignedBy);
                lpFileNode->lpSignedBy = NULL;
            }
        }
    } else {
        //
        // Get the icon (if the file isn't signed) so we can display it in the
        // listview faster.
        //
        MyGetFileInfo(lpFileNode);
    }

    return lpFileNode->bSigned;
}

//
// This function loops through g_App.lpFileList to verify each file.  We want to make this loop as tight
// as possible and keep the progress bar updating as we go.  When we are done, we want to pop up a
// dialog that allows the user to choose "Details" which will give them the listview control.
//
BOOL
VerifyFileList(void)
{
    LPFILENODE lpFileNode;
    DWORD       dwCount = 0;
    DWORD       dwPercent = 0;
    DWORD       dwCurrent = 0;

    //
    // Initialize the signed and unsigned counts
    //
    g_App.dwSigned    = 0;
    g_App.dwUnsigned  = 0;

    //
    // If we don't already have an g_App.hCatAdmin handle, acquire one.
    //
    if (!g_App.hCatAdmin) {
        CryptCATAdminAcquireContext(&g_App.hCatAdmin, NULL, 0);
    }

    //
    // Start looping through each file and update the progress bar if we cross
    // a percentage boundary.
    //
    for (lpFileNode=g_App.lpFileList;lpFileNode && !g_App.bStopScan;lpFileNode=lpFileNode->next,dwCount++) {
        //
        // Figure out the current percentage and update if it has increased.
        //
        dwPercent = (dwCount * 100) / g_App.dwFiles;

        if (dwPercent > dwCurrent) {

            dwCurrent = dwPercent;
            SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) dwCurrent, (LPARAM) 0);
        }

        //
        // Verify the file node if it hasn't already been scanned.
        //
        if (!lpFileNode->bScanned) {

            VerifyFileNode(lpFileNode);
        }

        //
        // In case something went wrong, make sure the version information gets
        // filled in.
        //
        if (!lpFileNode->lpVersion) {

            GetFileVersion(lpFileNode);
        }

        if (lpFileNode->bScanned) {
            //
            // If the file was signed, increment the g_App.dwSigned or
            // g_App.dwUnsigned counter.
            //
            if (lpFileNode->bSigned) {

                g_App.dwSigned++;

            } else {

                g_App.dwUnsigned++;
            }
        }
    }

    //
    // If we had an g_App.hCatAdmin, free it and set it to zero so we can
    // acquire a new one in the future.
    //
    if (g_App.hCatAdmin) {

        CryptCATAdminReleaseContext(g_App.hCatAdmin,0);
        g_App.hCatAdmin = NULL;
    }

    if (!g_App.bStopScan && !g_App.bAutomatedScan) {
        //
        // If the user never clicked STOP, then make sure the progress bar hits
        // 100%
        //
        if (!g_App.bStopScan) {

            SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) 100, (LPARAM) 0);
        }

        if (!g_App.dwUnsigned) {
            //
            // If there weren't any unsigned files, then we want to tell the
            // user that everything is dandy!
            //
            if (g_App.dwSigned) {

                MyMessageBoxId(IDS_ALLSIGNED);

            } else {

                MyMessageBoxId(IDS_NOPROBLEMS);
            }

        } else {
            // Show the user the results by going directly to IDD_RESULTS
            //
            DialogBox(g_App.hInstance, MAKEINTRESOURCE(IDD_RESULTS), g_App.hDlg, ListView_DlgProc);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\sigtab\sigtab.h ===
//---------------------------------------------------------------------------
//
//  File: sigtab.h
//
//  Copyright (c) Microsoft Corp. All Rights Reserved
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <shellapi.h>
#include <regstr.h>
#include "resource.h"

extern "C" {
#include <setupapi.h>
#include <spapip.h>
}

#define IDC_STATIC      (-1)

/*
    For driver signing, there are actually 3 sources of policy:

        1.  HKLM\Software\Microsoft\Driver Signing : Policy : REG_BINARY (REG_DWORD also supported)
            This is a Windows 98-compatible value that specifies the default
            behavior which applies to all users of the machine.

        2.  HKCU\Software\Microsoft\Driver Signing : Policy : REG_DWORD
            This specifies the user's preference for what behavior to employ
            upon verification failure.

        3.  HKCU\Software\Policies\Microsoft\Windows NT\Driver Signing : BehaviorOnFailedVerify : REG_DWORD
            This specifies the administrator-mandated policy on what behavior
            to employ upon verification failure.  This policy, if specified,
            overrides the user's preference.

    The algorithm for deciding on the behavior to employ is as follows:

        if (3) is specified {
            policy = (3)
        } else {
            policy = (2)
        }
        policy = MAX(policy, (1))

    Value indicating the policy in effect.  May be one of the following three values:

        DRIVERSIGN_NONE    -  silently succeed installation of unsigned/
                              incorrectly-signed files.  A PSS log entry will
                              be generated, however (as it will for all 3 types)
        DRIVERSIGN_WARNING -  warn the user, but let them choose whether or not
                              they still want to install the problematic file
        DRIVERSIGN_BLOCKING - do not allow the file to be installed
*/

#define SIGTAB_REG_KEY      TEXT("Software\\Microsoft\\Driver Signing")
#define SIGTAB_REG_VALUE    TEXT("Policy")

//
// Context-Sensitive Help/Identifiers specific to SigVerif
//
#define SIGTAB_HELPFILE                         TEXT("SYSDM.HLP")
#define IDH_CODESIGN_IGNORE                     11020
#define IDH_CODESIGN_WARN                       11021
#define IDH_CODESIGN_BLOCK                      11022
#define IDH_CODESIGN_APPLY                      11023

INT_PTR CALLBACK SigTab_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

extern "C" {
VOID
pSetupGetRealSystemTime(
    OUT LPSYSTEMTIME RealSystemTime
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sigverif\sigtab\sigtab.cpp ===
//--------------------------------------------------------------------------------
//
//  File:   sigtab.cpp
//
//  Copyright (c) Microsoft Corp. All Rights Reserved
//
//--------------------------------------------------------------------------------
#include "sigtab.h"

HINSTANCE g_hInst = NULL;

//---------------------------------------------------------------------------
// DllMain()
//---------------------------------------------------------------------------
int APIENTRY DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID )
{
    if ( dwReason == DLL_PROCESS_ATTACH ) {        // Initializing
        g_hInst = hInstance;

        DisableThreadLibraryCalls(hInstance);
    }

    return 1;
}

void GetCurrentDriverSigningPolicy( LPDWORD lpdwDefault, LPDWORD lpdwPolicy, LPDWORD lpdwPreference )
{
    SYSTEMTIME RealSystemTime;
    DWORD dwSize, dwType;
    DWORD dwDefault, dwPolicy, dwPreference;
    HKEY hKey;
    CONST TCHAR pszDrvSignPath[]                     = REGSTR_PATH_DRIVERSIGN;
    CONST TCHAR pszDrvSignPolicyPath[]               = REGSTR_PATH_DRIVERSIGN_POLICY;
    CONST TCHAR pszDrvSignPolicyValue[]              = REGSTR_VAL_POLICY;
    CONST TCHAR pszDrvSignBehaviorOnFailedVerifyDS[] = REGSTR_VAL_BEHAVIOR_ON_FAILED_VERIFY;

    dwPolicy = dwPreference = (DWORD) -1;

    RealSystemTime.wDayOfWeek = LOWORD(&hKey) | 4;
    pSetupGetRealSystemTime(&RealSystemTime);
    dwDefault = (((RealSystemTime.wMilliseconds+2)&15)^8)/4;

    //
    // Retrieve the user policy.
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      pszDrvSignPolicyPath,
                                      0,
                                      KEY_READ,
                                      &hKey)) {
        dwSize = sizeof(dwPolicy);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                             pszDrvSignBehaviorOnFailedVerifyDS,
                                             NULL,
                                             &dwType,
                                             (PBYTE)&dwPolicy,
                                             &dwSize)) {
            //
            // Finally, make sure a valid policy value was specified.
            //
            if ((dwType != REG_DWORD) ||
                (dwSize != sizeof(DWORD)) ||
                !((dwPolicy == DRIVERSIGN_NONE) || (dwPolicy == DRIVERSIGN_WARNING) || (dwPolicy == DRIVERSIGN_BLOCKING))) {
                //
                // Bogus entry for user policy--ignore it.
                //
                dwPolicy = DRIVERSIGN_NONE;
            }
        }

        RegCloseKey(hKey);
    }

    //
    // Finally, retrieve the user preference.
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      pszDrvSignPath,
                                      0,
                                      KEY_READ,
                                      &hKey)) {
        dwSize = sizeof(dwPreference);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                             pszDrvSignPolicyValue,
                                             NULL,
                                             &dwType,
                                             (PBYTE)&dwPreference,
                                             &dwSize)) {
            if ((dwType != REG_DWORD) ||
                (dwSize != sizeof(DWORD)) ||
                !((dwPreference == DRIVERSIGN_NONE) || (dwPreference == DRIVERSIGN_WARNING) || (dwPreference == DRIVERSIGN_BLOCKING))) {
                //
                // Bogus entry for user preference--ignore it.
                //
                dwPreference = DRIVERSIGN_NONE;
            }
        }

        RegCloseKey(hKey);
    }

    //
    // Store the values into the user buffer.
    //
    *lpdwDefault    = dwDefault;
    *lpdwPolicy     = dwPolicy;
    *lpdwPreference = dwPreference;
}

DWORD SigTab_UpdateDialog(HWND hwnd)
{
    DWORD   dwPreference = DRIVERSIGN_NONE;
    DWORD   dwDefault = DRIVERSIGN_NONE;
    DWORD   dwPolicy = DRIVERSIGN_NONE;
    DWORD   dwCurSel;

    //
    // Get the current policy settings from the registry.
    //
    GetCurrentDriverSigningPolicy(&dwDefault, &dwPolicy, &dwPreference);

    //
    // If there is no preference, set it to the policy or the default.
    //
    if (dwPreference == (DWORD) -1) {
        if (dwPolicy != (DWORD) -1)
            dwPreference = dwPolicy;
        else dwPreference = dwDefault;
    }

    //
    // Figure out which item is really selected and re-select it.  This will get rid of any checked && disabled items.
    //
    dwCurSel = dwPreference;
    if (IsDlgButtonChecked(hwnd, IDC_IGNORE) && IsWindowEnabled(GetDlgItem(hwnd, IDC_IGNORE)))
        dwCurSel = IDC_IGNORE;
    if (IsDlgButtonChecked(hwnd, IDC_WARN) && IsWindowEnabled(GetDlgItem(hwnd, IDC_WARN)))
        dwCurSel = IDC_WARN;
    if (IsDlgButtonChecked(hwnd, IDC_BLOCK) && IsWindowEnabled(GetDlgItem(hwnd, IDC_BLOCK)))
        dwCurSel = IDC_BLOCK;
    EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_WARN), TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_BLOCK), TRUE);
    CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, dwCurSel);

    //
    // If there is a policy for this user, it overrides any preferences so grey everything but the policy setting.
    //
    if (dwPolicy != (DWORD) -1) {
        //
        // If the system default is stronger, it will be used instead.
        //
        if (dwDefault > dwPolicy)
            dwPolicy = dwDefault;

        EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_WARN), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_BLOCK), FALSE);
        switch (dwPolicy) {
        case DRIVERSIGN_WARNING:    EnableWindow(GetDlgItem(hwnd, IDC_WARN), TRUE);
            CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_WARN);
            break;

        case DRIVERSIGN_BLOCKING:   EnableWindow(GetDlgItem(hwnd, IDC_BLOCK), TRUE);
            CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_BLOCK);
            break;

        default:                    EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), TRUE);
            CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_IGNORE);
            break;
        }

        dwPreference = dwPolicy;        
    } else {
        //
        // Grey out the items being over-ridden by the systen policy.  Bump the selection down to the first available slot.
        //
        switch (dwDefault) {
        case DRIVERSIGN_BLOCKING:   if (IsDlgButtonChecked(hwnd, IDC_WARN) || IsDlgButtonChecked(hwnd, IDC_IGNORE))
                CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_BLOCK);
            EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_WARN), FALSE);
            break;

        case DRIVERSIGN_WARNING:    if (IsDlgButtonChecked(hwnd, IDC_IGNORE))
                CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_WARN);
            EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), FALSE);
            break;
        }

        //
        // If the system default is stronger, it will be used instead.
        //
        if (dwDefault > dwPreference)
            dwPreference = dwDefault;
    }

    if (pSetupIsUserAdmin()) {
        //
        // If the administrator can set the default, make everything available for selection.
        //
        if (IsDlgButtonChecked(hwnd, IDC_GLOBAL)) {
            EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_WARN), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_BLOCK), TRUE);
        }
    }

    return dwPreference;
}

//
//  Initialization of search dialog.
//
BOOL SigTab_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    DWORD   dwPreference = DRIVERSIGN_NONE;
    DWORD   dwDefault = DRIVERSIGN_NONE;
    DWORD   dwPolicy = DRIVERSIGN_NONE;
    BOOL    bAdmin;

    UNREFERENCED_PARAMETER(hwndFocus);
    UNREFERENCED_PARAMETER(lParam);

    ShowWindow(hwnd, SW_SHOW);

    CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_IGNORE);
    CheckDlgButton(hwnd, IDC_GLOBAL, BST_UNCHECKED);

    bAdmin = pSetupIsUserAdmin();
    ShowWindow(GetDlgItem(hwnd, IDC_GLOBAL), bAdmin ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, IDG_ADMIN), bAdmin ? SW_SHOW : SW_HIDE);

    GetCurrentDriverSigningPolicy(&dwDefault, &dwPolicy, &dwPreference);

    //
    // Call SigTab_UpdateDialog to initialize the dialog
    //
    dwPreference = SigTab_UpdateDialog(hwnd);

    //
    // Check the radio button for their calculated "preference".
    //
    switch (dwPreference) {
    case DRIVERSIGN_WARNING:    CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_WARN);
        break;
    case DRIVERSIGN_BLOCKING:   CheckRadioButton(hwnd, IDC_IGNORE, IDC_BLOCK, IDC_BLOCK);
        break;
    }

    //
    // If the user is an administrator, check the "Global" box if the preference matches the default setting.
    //
    if (bAdmin) {
        switch (dwDefault) {
        case DRIVERSIGN_WARNING:    if (IsDlgButtonChecked(hwnd, IDC_WARN))
                CheckDlgButton(hwnd, IDC_GLOBAL, BST_CHECKED);
            break;

        case DRIVERSIGN_BLOCKING:   if (IsDlgButtonChecked(hwnd, IDC_BLOCK))
                CheckDlgButton(hwnd, IDC_GLOBAL, BST_CHECKED);
            break;

        case DRIVERSIGN_NONE:       if (IsDlgButtonChecked(hwnd, IDC_IGNORE))
                CheckDlgButton(hwnd, IDC_GLOBAL, BST_CHECKED);
            break;
        }

        //
        // If the administrator can set the default, make everything available for selection.
        //
        if (IsDlgButtonChecked(hwnd, IDC_GLOBAL)) {
            EnableWindow(GetDlgItem(hwnd, IDC_IGNORE), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_WARN), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_BLOCK), TRUE);
        }
    }

    return TRUE;
}

void SigTab_Help(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL bContext)
{
    static DWORD SigTab_HelpIDs[] = 
    { 
        IDC_IGNORE, IDH_CODESIGN_IGNORE,
        IDC_WARN,   IDH_CODESIGN_WARN,
        IDC_BLOCK,  IDH_CODESIGN_BLOCK,
        IDC_GLOBAL, IDH_CODESIGN_APPLY,
        IDG_ADMIN,  (DWORD)-1,
        0,0
    };

    HWND hItem = NULL;
    LPHELPINFO lphi = NULL;
    POINT point;

    switch (uMsg) {
    case WM_HELP:
        lphi = (LPHELPINFO) lParam;
        if (lphi && (lphi->iContextType == HELPINFO_WINDOW))   // must be for a control
            hItem = (HWND) lphi->hItemHandle;
        break;

    case WM_CONTEXTMENU:
        hItem = (HWND) wParam;
        point.x = GET_X_LPARAM(lParam);
        point.y = GET_Y_LPARAM(lParam);
        if (ScreenToClient(hwnd, &point)) {
            hItem = ChildWindowFromPoint(hwnd, point);
        }
        break;
    }

    if (hItem && (GetWindowLong(hItem, GWL_ID) != IDC_STATIC)) {
        WinHelp(hItem,
                (LPCTSTR) SIGTAB_HELPFILE,
                (bContext ? HELP_CONTEXTMENU : HELP_WM_HELP),
                (ULONG_PTR) SigTab_HelpIDs);
    }
}

//
//
//
void SigTab_ApplySettings(HWND hwnd)
{
    HKEY    hKey;
    LONG    lRes;
    DWORD   dwData, dwSize, dwType, dwDisposition;

    lRes = RegCreateKeyEx(  HKEY_CURRENT_USER, 
                            SIGTAB_REG_KEY, 
                            NULL, 
                            NULL, 
                            REG_OPTION_NON_VOLATILE, 
                            KEY_WRITE, 
                            NULL, 
                            &hKey, 
                            &dwDisposition);

    if (lRes == ERROR_SUCCESS) {
        dwType = REG_DWORD;
        dwSize = sizeof(dwData);
        dwData = DRIVERSIGN_NONE;

        if (IsDlgButtonChecked(hwnd, IDC_WARN))
            dwData = DRIVERSIGN_WARNING;
        else
            if (IsDlgButtonChecked(hwnd, IDC_BLOCK))
            dwData = DRIVERSIGN_BLOCKING;

        lRes = RegSetValueEx(   hKey, 
                                SIGTAB_REG_VALUE, 
                                0, 
                                dwType, 
                                (CONST BYTE *) &dwData, 
                                dwSize);

        RegCloseKey(hKey);

        if (lRes == ERROR_SUCCESS && IsDlgButtonChecked(hwnd, IDC_GLOBAL) && pSetupIsUserAdmin()) {

            SYSTEMTIME RealSystemTime;

            if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                             TEXT("System\\WPA\\PnP"),
                                             0,
                                             KEY_READ,
                                             &hKey)) {

                dwSize = sizeof(dwData);
                if((ERROR_SUCCESS != RegQueryValueEx(hKey,
                                                     TEXT("seed"),
                                                     NULL,
                                                     &dwType,
                                                     (PBYTE)&dwData,
                                                     &dwSize))
                   || (dwType != REG_DWORD) || (dwSize != sizeof(dwData))) {

                    dwData = 0;
                }

                RegCloseKey(hKey);
            }

            RealSystemTime.wDayOfWeek = LOWORD(&hKey) | 4;
            RealSystemTime.wMinute = LOWORD(dwData);
            RealSystemTime.wYear = HIWORD(dwData);
            dwData = DRIVERSIGN_NONE;
            if(IsDlgButtonChecked(hwnd, IDC_WARN)) {
                dwData = DRIVERSIGN_WARNING;
            } else if(IsDlgButtonChecked(hwnd, IDC_BLOCK)) {
                dwData = DRIVERSIGN_BLOCKING;
            }
            RealSystemTime.wMilliseconds = (LOWORD(&lRes)&~3072)|(WORD)((dwData&3)<<10);
            pSetupGetRealSystemTime(&RealSystemTime);
        }
    }
}

//
//  Handle any WM_COMMAND messages sent to the search dialog
//
void SigTab_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    UNREFERENCED_PARAMETER(hwndCtl);
    UNREFERENCED_PARAMETER(codeNotify);

    switch (id) {
    case IDCANCEL: 
        EndDialog(hwnd, 0);
        break;

    case IDOK:
        SigTab_ApplySettings(hwnd);
        EndDialog(hwnd, 1);
        break;

    case IDC_GLOBAL:
        SigTab_UpdateDialog(hwnd);
        break;
    }

    return;
}

LRESULT SigTab_NotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    OSVERSIONINFOEX osVersionInfoEx;
    NMHDR *lpnmhdr = (NMHDR *) lParam;

    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);

    switch (lpnmhdr->code) {
    case NM_RETURN:
    case NM_CLICK:
        if (lpnmhdr->idFrom == IDC_LINK) {
            //
            // We need to know if this is a server machine or a workstation 
            // machine since there are different help topic structures for
            // the different products.
            //
            ZeroMemory(&osVersionInfoEx, sizeof(osVersionInfoEx));
            osVersionInfoEx.dwOSVersionInfoSize = sizeof(osVersionInfoEx);
            if (!GetVersionEx((LPOSVERSIONINFO)&osVersionInfoEx)) {
                //
                // If GetVersionEx fails then assume this is a workstation
                // machine.
                //
                osVersionInfoEx.wProductType = VER_NT_WORKSTATION;
            }

            ShellExecute(hwnd,
                         TEXT("open"),
                         TEXT("HELPCTR.EXE"),
                         (osVersionInfoEx.wProductType == VER_NT_WORKSTATION)
                            ? TEXT("HELPCTR.EXE -url hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm")
                            : TEXT("HELPCTR.EXE -url hcp://services/subsite?node=Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm"),
                         NULL,
                         SW_SHOWNORMAL
                         );
        }
        break;

    default:
        break;
    }

    return 0;
}

INT_PTR CALLBACK SigTab_DlgProc(HWND hwnd, UINT uMsg,
                                WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
    HANDLE_MSG(hwnd, WM_INITDIALOG, SigTab_OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, SigTab_OnCommand);

    case WM_HELP:
        SigTab_Help(hwnd, uMsg, wParam, lParam, FALSE);
        break;

    case WM_CONTEXTMENU:
        SigTab_Help(hwnd, uMsg, wParam, lParam, TRUE);
        break;

    case WM_NOTIFY:
        return SigTab_NotifyHandler(hwnd, uMsg, wParam, lParam);

    default: fProcessed = FALSE;
    }

    return fProcessed;
}

STDAPI DriverSigningDialog(HWND hwnd, DWORD dwFlagsReserved)
{   
    UNREFERENCED_PARAMETER(dwFlagsReserved);

    return((HRESULT)DialogBox(g_hInst, MAKEINTRESOURCE(IDD_SIGTAB), hwnd, SigTab_DlgProc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sort\resource.h ===
#define SORT_USAGE_FIRST	100
#define SORT_USAGE_2		101
#define SORT_USAGE_3		102
#define SORT_USAGE_5		103
#define SORT_USAGE_6		104
#define SORT_USAGE_7		105
#define SORT_USAGE_8		106
#define SORT_USAGE_9		107
#define SORT_USAGE_10		108
#define SORT_USAGE_11		109
#define SORT_USAGE_12		110
#define SORT_USAGE_13		111
#define SORT_USAGE_14		112
#define SORT_USAGE_15		113
#define SORT_USAGE_16		114
#define SORT_USAGE_17		115
#define SORT_USAGE_18		116
#define SORT_USAGE_19		117
#define SORT_USAGE_20		118
#define SORT_USAGE_21		119
#define SORT_USAGE_22		120
#define SORT_USAGE_23		121
#define SORT_USAGE_24		122
#define SORT_USAGE_25		123
#define SORT_USAGE_26		124
#define SORT_USAGE_27		125
#define SORT_USAGE_28		126
#define SORT_USAGE_29		127
#define SORT_USAGE_30		128
#define SORT_USAGE_31		129
#define SORT_USAGE_32		130
#define SORT_USAGE_33		131
#define SORT_USAGE_34		132
#define SORT_USAGE_35		133
#define SORT_USAGE_36		134
#define SORT_USAGE_37		135
#define SORT_USAGE_38		136
#define SORT_USAGE_39		137
#define SORT_USAGE_40		138
#define SORT_USAGE_41		139
#define SORT_USAGE_42		140
#define SORT_USAGE_43		141
#define SORT_USAGE_44		142
#define SORT_USAGE_45		143
#define SORT_USAGE_46		144
#define SORT_USAGE_47		145
#define SORT_USAGE_48		146
#define SORT_USAGE_49		147
#define SORT_USAGE_50		148
#define SORT_USAGE_51		149
#define SORT_USAGE_52		150
#define SORT_USAGE_53		151
#define SORT_USAGE_54		152
#define SORT_USAGE_LAST		153

#define SORT_REC_TOO_BIG	200
#define SORT_INVALID_LOCALE	201
#define SORT_POSITION		202
#define SORT_INVALID_SWITCH	203
#define SORT_MAX_TOO_LARGE	204
#define SORT_ONE_INPUT		205
#define SORT_CHAR_CONVERSION	206
#define SORT_NOT_ENOUGH_MEMORY	207

#define SORT_REDIRECT_INPUT	300
#define SORT_REDIRECT_OUTPUT	301
#define SORT_MEM_TOO_LOW	302
#define SORT_MEM_GT_PAGE	303

#define SORT_INPUT_FILE		400
#define SORT_OUTPUT_FILE	401
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sort\usa\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

sortmsg.h sortmsg.rc msg00001.bin: ..\sortmsg.mc
    mc -v ..\sortmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sort\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=sort
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES=..\sort.c ..\sort.rc ..\sortmsg.mc

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
INCLUDES=$(O)

USE_MSVCRT=1

UMTYPE=console
UMENTRY=main
TARGETLIBS=\
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\ntdll.lib \
        $(SDK_LIB_PATH)\kernl32p.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\tree\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=tree
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM

SOURCES=..\tree.cxx ..\tree.rc

INCLUDES=..\.;..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\sort\sort.c ===
/* SORT.C
 *
 * This is rewrite of the NT sort program achieves two goals:
 * 1) improves the general speed of the sort program.
 * 2) performs two-pass sort so that large data sets can be sorted.
 *
 * It is designed for a single-disk environment.
 *
 * Author: Chris Nyberg
 * Ordinal Technology Corp, under contract to Microsoft Corporation
 * Dec 1997
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <windows.h>
#include <mbctype.h>
#include <locale.h>
#include <tchar.h>
#include <assert.h>
#include <limits.h>
#include <winnlsp.h>

#include "sortmsg.h"


#define ROUND_UP(a, b) ((((a) + (b) - 1) / (b)) * (b))
#define ROUND_DOWN(a, b) (((a) / (b)) * (b))

#define CTRL_Z          '\x1A'

#define MAX_IO          2   /* the maximum number of r/w requests per file */
#define N_RUN_BUFS      2   /* read buffers per run during merge phase */
#define MAX_XFR_SIZE (1 << 18) /* maximum i/o transfer size */
#define MIN_MEMORY_SIZE (160 * 1024) /* minimum memory size to use */

#ifdef UNICODE
#define ANSI_TO_TCHAR(a)        ansi_to_wchar(a)
#else
#define ANSI_TO_TCHAR(a)        (a)
#endif

char    *Locale;        /* Locale argument */
int     Max_rec_length = 4096;  /* maximum characters in a record */
int     Max_rec_bytes_internal; /* max bytes for a internally-stored record */
int     Max_rec_bytes_external; /* max bytes for a record to/from a file */
BOOL    Reverse;        /* the /R argument to reverse the sort order. */
BOOL    Case_sensitive; /* make comparisons case sensitive */
BOOL    UnicodeOut;     /* Write the output file in unicode. */
int     Position;       /* the /+n argument to skip characters at the
                         * beginning of each record. */

enum {          /* the type of characters in the input and output */
    CHAR_SINGLE_BYTE,   /* internally stored as single-byte chars */
    CHAR_MULTI_BYTE,    /* internally stored as unicode */
    CHAR_UNICODE        /* internally stored as unicode */
} Input_chars, Output_chars;

int     (_cdecl *Compare)(const void *, const void *); /* record comparison */
char    *Alloc_begin;   /* the beginning for VirtualAlloc()'ed memory */

TCHAR   *Input_name;    /* input file name, NULL if standard input */
HANDLE  Input_handle;   /* input file handle */
BOOL    Input_un_over;  /* input file handle is unbuffered and overlapped */
int     Input_type;     /* input from disk, pipe, or char (console)? */
int     In_max_io = 1;  /* max number of input read requests */
__int64 Input_size = -1; /* the size of the input file, -1 if unknown. */
__int64 Input_scheduled;/* number of bytes scheduled for reading so far. */
__int64 Input_read;     /* number of bytes read so far. */
int     Input_read_size;/* the number of bytes to read for each ReadFile() */
char    *In_buf[MAX_IO];/* Input buffer(s) */
int     Input_buf_size; /* size of input buffer(s) */
char    *In_buf_next;   /* Next byte to remove from input buffer */
char    *In_buf_limit;  /* Limit of valid bytes in input buffer */
char    *Next_in_byte;  /* Next input byte */
BOOL    EOF_seen;       /* has eof been seen? */
int     Reads_issued;   /* the number of reads issued to either the
                         * input file or temporary file */
int     Reads_completed;/* the number of reads completed to either the
                         * input file or temporary file */

SYSTEM_INFO     Sys;
MEMORYSTATUSEX    MemStat;
CPINFO          CPInfo;
unsigned Memory_limit;  /* limit on the amount of process memory used */
unsigned User_memory_limit; /* user-specified limit */

#define TEMP_LENGTH     1000
TCHAR   Temp_name[TEMP_LENGTH];
TCHAR   *Temp_dir;      /* temporary directory specified by user */
HANDLE  Temp_handle;    /* temporary file handle */
int     Temp_sector_size; /* sector size on temporary disks */
int     Temp_buf_size;  /* size of temp file xfers */

void    *Rec_buf;       /* Record buffer */
int     Rec_buf_bytes;  /* Number of bytes currently in the record buffer */

TCHAR   *Output_name;   /* output file name, NULL if standard output */
HANDLE  Output_handle;  /* output file handle */
BOOL    Output_un_over; /* output file handle is unbuffered and overlapped */
int     Output_type;    /* output to disk, pipe, or char (console)? */
int     Output_sector_size; /* size of a sector on the output device */
int     Out_max_io = 1; /* max number of output write requests */
int     Out_buf_bytes;  /* number of bytes in the current output buffer */
int     Out_buf_size;   /* buffer size of the current output stream: either
                         * the temp file or output file */
char    *Out_buf[MAX_IO];
int     Output_buf_size;/* size of output buffer(s) */
int     Writes_issued; /* the number of writes issued to either the
                        * temporary file or the output file */
int     Writes_completed; /* the number of writes completed to either the
                           * temporary file or the output file */
__int64 Out_offset;     /* current output file offset */

enum {
    INPUT_PHASE,
    OUTPUT_PHASE
} Phase;
int     Two_pass;       /* non-zero if two-pass, zero of one-pass */
char    *Merge_phase_run_begin; /* address of run memory during merge phase */

char    *Rec;           /* internal record buffer */
char    *Next_rec;      /* next insertion point in internal record buffer */
char    **Last_recp;    /* next place to put a (not short) record ptr */
char    **Short_recp;   /* last short record pointer */
char    **End_recp;     /* end of record pointer array */

OVERLAPPED      Over;
typedef struct
{
    int         requested;      /* bytes requested */
    int         completed;      /* bytes completed */
    OVERLAPPED  over;
} async_t;
async_t         Read_async[MAX_IO];
async_t         Write_async[MAX_IO];

typedef struct run
{
    int         index;          /* index of this run */
    __int64     begin_off;      /* beginning offset of run in temp file */
    __int64     mid_off;        /* mid-point offset between normal and
                                 * short records for this run in temp file */
    __int64     end_off;        /* ending offset of run in temp file */
    char        *buf[N_RUN_BUFS]; /* bufs to hold blocks read from temp file */
    char        *buf_begin;     /* beginning of block buffer being read from */
    __int64     buf_off;        /* offset in temp file of block in buf */
    int         buf_bytes;      /* number of bytes in buffer */
    char        *next_byte;     /* next byte to be read from buffer */
    __int64     end_read_off;   /* end read offset */
    char        *rec;           /* record buffer */
    int         blks_read;      /* count of blocks that have been read */
    int         blks_scanned;   /* count of blocks that have been scanned */
    struct run  *next;          /* next run in block read queue */
} run_t;

#define NULL_RUN        ((run_t *)NULL)
#define END_OF_RUN      ((run_t *)-1)

run_t           *Run;           /* array of run structs */
run_t           **Tree;         /* merge phase tournament tree */
unsigned int    N_runs;         /* number of runs written to temporary file */
unsigned int    Run_limit;      /* limit on number of runs set dictated
                                 * by memory size */

/* the run read queue is a queue of runs that have an empty buffer which
 * should be filled with the next block of data for that run.
 */
run_t           *Run_read_head;
run_t           *Run_read_tail;

#define MESSAGE_BUFFER_LENGTH 8192

/* SYS_ERROR - print the string for an NT error code and exit.
 */
void
sys_error(TCHAR *str, int error)
{
    LPSTR       lpMsgBuf;
    DWORD       bytes;
    wchar_t     *w_str;
    NTSTATUS    status;
    char        messageBuffer[MESSAGE_BUFFER_LENGTH];

    if (str != NULL) {
        bytes = strlen( str );
        w_str = HeapAlloc(GetProcessHeap(), 0, (bytes+1) * sizeof(wchar_t));
        if ( w_str ) {
            status = RtlMultiByteToUnicodeN(w_str,
                                            bytes * sizeof(wchar_t),
                                            &bytes,
                                            str,
                                            bytes );

            if ( NT_SUCCESS(status) ) {
                status = RtlUnicodeToOemN(messageBuffer,
                                          MESSAGE_BUFFER_LENGTH-1,
                                          &bytes,
                                          w_str,
                                          bytes );
                if ( NT_SUCCESS(status) ) {
                    messageBuffer[bytes] = 0;
                    fprintf(stderr, messageBuffer);
                }
            }
            HeapFree(GetProcessHeap(), 0, w_str);
        }
    }

    if (error == 0)
        error = GetLastError();

    bytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_FROM_SYSTEM |
                  FORMAT_MESSAGE_IGNORE_INSERTS,
                  GetModuleHandle(NULL),
                  error,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default lang
                  (LPSTR) &lpMsgBuf,
                  0,
                  NULL);
    w_str = HeapAlloc(GetProcessHeap(), 0, (bytes+1) * sizeof(wchar_t));
    if ( w_str ) {
        status = RtlMultiByteToUnicodeN(w_str,
                                        bytes * sizeof(wchar_t),
                                        &bytes,
                                        lpMsgBuf,
                                        bytes );
        if ( NT_SUCCESS(status) ) {
            status = RtlUnicodeToOemN(messageBuffer,
                                      MESSAGE_BUFFER_LENGTH-1,
                                      &bytes,
                                      w_str,
                                      bytes );
            if ( NT_SUCCESS(status) ) {
                messageBuffer[bytes] = 0;
                fprintf(stderr, messageBuffer);
            }
        }
    }

    exit(EXIT_FAILURE);
}


/* GET_STRING - get a string from the sort program's string table.
 */
TCHAR *get_string(int id)
{
    wchar_t     *w_str;
    DWORD       bytes;
    NTSTATUS    status;
    static char messageBuffer[MESSAGE_BUFFER_LENGTH] = "";

    bytes = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                id,
                0,
                messageBuffer,
                MESSAGE_BUFFER_LENGTH,
                NULL );
    w_str = HeapAlloc(GetProcessHeap(), 0, (bytes+1) * sizeof(wchar_t));
    if ( w_str ) {
        status = RtlMultiByteToUnicodeN(w_str,
                                        bytes * sizeof(wchar_t),
                                        &bytes,
                                        messageBuffer,
                                        bytes );
        if ( NT_SUCCESS(status) ) {
            status = RtlUnicodeToOemN(messageBuffer,
                                      MESSAGE_BUFFER_LENGTH-1,
                                      &bytes,
                                      w_str,
                                      bytes );
            if ( NT_SUCCESS(status) ) {
                messageBuffer[bytes] = 0;
            }
        }
    }

    return (messageBuffer);
}


/* USAGE - print the /? usage message to the standard output.
 */
void usage()
{
    DWORD bytes;

    fprintf(stdout, "%s", get_string(MSG_SORT_USAGE1));
    fprintf(stdout, "%s\n", get_string(MSG_SORT_USAGE2));
    exit (0);
}


/* WARNING - print a warning string from the sort program's string table.
 */
void warning(int id)
{
    fprintf(stderr, "%s\n", get_string(id));
    return;
}


/* ERROR - print an error string from the string table and exit.
 */
void error(int id)
{
    fprintf(stderr, "%s\n", get_string(id));
    exit (EXIT_FAILURE);
}


/* ANSI_TO_WCHAR - convert and ansi string to unicode.
 */
wchar_t *ansi_to_wchar(char *str)
{
    int         n_wchars;
    wchar_t     *w_str;

    n_wchars = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
    w_str = HeapAlloc(GetProcessHeap(), 0, n_wchars * sizeof(wchar_t));
    if ( w_str ) {
        MultiByteToWideChar(CP_ACP, 0, str, -1, w_str, n_wchars);
    }
    return (w_str);
}


/* READ_ARGS - process the command line arguments.
 */
void read_args(int argc, char *argv[])
{
    int len;

    while (argc >= 2)
    {
        if (argv[1][0] == '/')
        {
            len = strlen(&argv[1][1]);
            if (argv[1][1] == '?')
                usage();
            else if (argv[1][1] == '+') /* position */
            {
                Position = atoi(&argv[1][2]);
                if (Position <= 0)
                    error(MSG_SORT_POSITION);
                Position--;
            }
            else if (_strnicmp(&argv[1][1], "case_sensitive", len) == 0)
                Case_sensitive = 1;
            else if (_strnicmp(&argv[1][1], "locale", len) == 0) /* locale */
            {
                if (argc < 3)
                    error(MSG_SORT_INVALID_SWITCH);
                Locale = argv[2];
                argv++;
                argc--;
            }
            else if (_strnicmp(&argv[1][1], "memory", len) == 0)
            {
                /* memory limit */
                if (argc < 3)
                    error(MSG_SORT_INVALID_SWITCH);
                User_memory_limit = atoi(argv[2]);
                argv++;
                argc--;
            }
            else if (_strnicmp(&argv[1][1], "output", len) == 0)
            {
                /* output file */
                if (Output_name != NULL || argc < 3)
                    error(MSG_SORT_INVALID_SWITCH);
                Output_name = ANSI_TO_TCHAR(argv[2]);
                argv++;
                argc--;
            }
            else if (_strnicmp(&argv[1][1], "reverse", len) == 0)
                Reverse = 1;
            else if (_strnicmp(&argv[1][1], "record_maximum", len) == 0)
            {
                /* maximum number of characters per record */
                if (argc < 3)
                    error(MSG_SORT_INVALID_SWITCH);
                Max_rec_length = atoi(argv[2]);
                if (Max_rec_length < 128)
                    Max_rec_length = 128;
                if (Max_rec_length >= 65536)
                    error(MSG_SORT_MAX_TOO_LARGE);
                argv++;
                argc--;
            }
            else if (_strnicmp(&argv[1][1], "temporary", len) == 0)
            {
                if (Temp_dir != NULL || argc < 3)
                    error(MSG_SORT_INVALID_SWITCH);
                Temp_dir = ANSI_TO_TCHAR(argv[2]);
                argv++;
                argc--;
            }
            else if (_strnicmp(&argv[1][1], "uni_output", len) == 0)
            {
                UnicodeOut=TRUE;
            }
            else
                error(MSG_SORT_INVALID_SWITCH);
        }
        else
        {
            if (Input_name != NULL)
                error(MSG_SORT_ONE_INPUT);
            Input_name = ANSI_TO_TCHAR(argv[1]);
        }
        argc--;
        argv++;
    }
}


/* INIT_INPUT_OUTPUT - initialize the input and output files.
 */
void init_input_output()
{
    int         mode;
    int         i;

    /* get input handle and type
     */
    if (Input_name != NULL)
    {
        Input_handle = CreateFile(Input_name,
                                  GENERIC_READ,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);
        if (Input_handle == INVALID_HANDLE_VALUE)
            sys_error(Input_name, 0);
    }
    else
        Input_handle = GetStdHandle(STD_INPUT_HANDLE);
    Input_type = GetFileType(Input_handle);
    if (Input_type == FILE_TYPE_DISK)
    {
        unsigned        low, high;

        low = GetFileSize(Input_handle, &high);
        Input_size = ((__int64)high << 32) + low;
        Input_read_size = 0;    /* will be set it init_mem() */
    }
    else
    {
        Input_size = -1;
        Input_read_size = 4096;  /* use appropriate size for keyboard/pipe */
    }

    if (Output_name)
    {
        /* Don't open output file yet.  It will be opened for writing and
         * truncated after we are done reading the input file.  This
         * handles the case where the input file and output file are the
         * same file.
         */
        Output_type = FILE_TYPE_DISK;
    }
    else
    {
        Output_handle = GetStdHandle(STD_OUTPUT_HANDLE);

        /* determine if output file is to disk, pipe, or console
         */
        Output_type = GetFileType(Output_handle);
        if (Output_type == FILE_TYPE_CHAR &&
            !GetConsoleMode(Output_handle, &mode))
        {
            Output_type = FILE_TYPE_DISK;
        }
    }

    for (i = 0; i < MAX_IO; i++)
    {
        HANDLE  hEvent;

        hEvent = Read_async[i].over.hEvent = CreateEvent(NULL, 1, 0, NULL);
        assert(hEvent != NULL);
        hEvent = Write_async[i].over.hEvent = CreateEvent(NULL, 1, 0, NULL);
        assert(hEvent != NULL);
    }
}


/* SBCS_COMPARE - key comparison routine for records that are internally
 *                stored as ANSI strings.
 */
int
_cdecl SBCS_compare(const void *first, const void *second)
{
    int ret_val;

    ret_val = _stricoll(&((char **)first)[0][Position],
                        &((char **)second)[0][Position]);
    if (Reverse)
        ret_val = -ret_val;
    return (ret_val);
}


/* SBCS_CASE_COMPARE - case-sensitive key comparison routine for records
 *                     that are internally stored as ANSI strings.
 */
int
_cdecl SBCS_case_compare(const void *first, const void *second)
{
    int ret_val;

    ret_val = strcoll(&((char **)first)[0][Position],
                       &((char **)second)[0][Position]);
    if (Reverse)
        ret_val = -ret_val;
    return (ret_val);
}


/* UNICODE_COMPARE - key comparison routine for records that are internally
 *                   stored as Unicode strings.
 */
int
_cdecl Unicode_compare(const void *first, const void *second)
{
    int ret_val;

    ret_val = _wcsicoll(&((wchar_t **)first)[0][Position],
                        &((wchar_t **)second)[0][Position]);
    if (Reverse)
        ret_val = -ret_val;
    return (ret_val);
}


/* UNICODE_CASE_COMPARE - case-sensitive key comparison routine for records
 *                        that are internally stored as Unicode strings.
 */
int
_cdecl Unicode_case_compare(const void *first, const void *second)
{
    int ret_val;

    ret_val = wcscoll(&((wchar_t **)first)[0][Position],
                        &((wchar_t **)second)[0][Position]);
    if (Reverse)
        ret_val = -ret_val;
    return (ret_val);
}


/* INIT_MEM - set the initial memory allocation.
 */
void init_mem()
{
    unsigned    size;
    unsigned    vsize;
    int         buf_size;
    int         i;
    int         rec_buf_size;
    int         rec_n_ptr_size;
    char        *new;

    MemStat.dwLength = sizeof(MemStat);

    GlobalMemoryStatusEx(&MemStat);
    GetSystemInfo(&Sys);

    /* set the memory limit
     */
    if (User_memory_limit == 0)         /* if not specified by user */
    {
        UINT_PTR limit = (UINT_PTR) __min(MemStat.ullAvailPhys, MAXUINT_PTR / 4);

        /* if input or output is not a file, leave half of the available
         * memory for other programs.  Otherwise use 90%.
         */
        if (Input_type != FILE_TYPE_DISK || Output_type != FILE_TYPE_DISK)
            limit = (int)(limit * 0.45);  /* use 45% of available memory */
        else
            limit = (int)(limit * 0.9);   /* use 90% of available memory */

        if (limit > ULONG_MAX) {

            //
            // Note this app will need lots of changes in order to
            // use memory > 4G
            //

            limit = ULONG_MAX - (Sys.dwPageSize * 2);
        }

        Memory_limit = (unsigned)ROUND_UP(limit, Sys.dwPageSize);
    }
    else
    {
        if (User_memory_limit < MIN_MEMORY_SIZE / 1024)
        {
            warning(MSG_SORT_MEM_TOO_LOW);
            Memory_limit = MIN_MEMORY_SIZE;
        }
        else if (User_memory_limit > (__min(MemStat.ullAvailPageFile, ULONG_MAX) / 1024))
        {
            warning(MSG_SORT_MEM_GT_PAGE);
            Memory_limit = (unsigned) __min(MemStat.ullAvailPageFile, ULONG_MAX);
        }
        else
            Memory_limit = (unsigned) ROUND_UP((__min(User_memory_limit, ULONG_MAX) * 1024), Sys.dwPageSize);
    }

    /* if memory limit is below minimum, increase it and hope some physical
     * memory is freed up.
     */
    if (Memory_limit < MIN_MEMORY_SIZE)
        Memory_limit = MIN_MEMORY_SIZE;

    /* calculate the size of all input and output buffers to be no more
     * than 10% of all memory, but no larger than 256k.
     */
    buf_size = (int)(Memory_limit * 0.1) / (2 * MAX_IO);
    buf_size = ROUND_DOWN(buf_size, Sys.dwPageSize);
    buf_size = max(buf_size, (int)Sys.dwPageSize);
    buf_size = min(buf_size, MAX_XFR_SIZE);
    Input_buf_size = Output_buf_size = Temp_buf_size = buf_size;
    if (Input_type == FILE_TYPE_DISK)
        Input_read_size = Input_buf_size;

    GetCPInfo(CP_OEMCP, &CPInfo);
    rec_buf_size = Max_rec_length * max(sizeof(wchar_t), CPInfo.MaxCharSize);
    rec_buf_size = ROUND_UP(rec_buf_size, Sys.dwPageSize);

    /* allocate enough initial record and pointer space to hold two maximum
     * length records or 1000 pointers.
     */
    rec_n_ptr_size = 2 * max(Max_rec_length, 4096) * sizeof(wchar_t) +
        1000 * sizeof(wchar_t *);
    rec_n_ptr_size = ROUND_UP(rec_n_ptr_size, Sys.dwPageSize);

    vsize = MAX_IO * (Input_buf_size + max(Temp_buf_size, Output_buf_size));
    vsize += rec_buf_size + rec_n_ptr_size;

    /* if initial memory allocation won't fit in the Memory limit
     */
    if (vsize > Memory_limit)
    {
        if (User_memory_limit != 0)     /* if specified by user */
        {
            /* if we didn't already warn the user that their memory size
             * is too low, do so.
             */
            if (User_memory_limit >= MIN_MEMORY_SIZE / 1024)
                warning(MSG_SORT_MEM_TOO_LOW);
        }

        /* increase the memory limit and hope some physical memory is freed up.
         */
        Memory_limit = vsize;
    }

    Alloc_begin =
        (char *)VirtualAlloc(NULL, Memory_limit, MEM_RESERVE, PAGE_READWRITE);
    if (Alloc_begin == NULL)
        error(MSG_SORT_NOT_ENOUGH_MEMORY);

    /* for i/o buffers, allocate enough virtual memory for the maximum
     * buffer space we could need.
     */
    size = 0;
    for (i = 0; i < MAX_IO; i++)
    {
        Out_buf[i] = Alloc_begin + size;
        size += max(Temp_buf_size, Output_buf_size);
    }

    Rec_buf = Alloc_begin + size;
    size += rec_buf_size;

    for (i = 0; i < MAX_IO; i++)
    {
        In_buf[i] = Alloc_begin + size;
        size += Input_buf_size;
    }
    Merge_phase_run_begin = In_buf[0];
    Out_buf_size = Temp_buf_size;       /* assume two-pass sort for now */

    /* Initialize Rec and End_recp to sample the input data.
     */
    Rec = Next_rec = Alloc_begin + size;
    size += rec_n_ptr_size;

    End_recp = Short_recp = Last_recp = (char **)(Alloc_begin + size);
    assert(size == vsize);

    new = VirtualAlloc(Alloc_begin, size, MEM_COMMIT, PAGE_READWRITE);
    assert(new == Alloc_begin);
#if 0
    fprintf(stderr, "using %d, avail %d, buf_size %d\n",
            Memory_limit, MemStat.dwAvailPhys, buf_size);
#endif
}


/* READ_NEXT_INPUT_BUF
 */
void read_next_input_buf()
{
    int         bytes_read;
    int         ret;
    async_t     *async;

    /* if using unbuffered, overlapped reads
     */
    if (Input_un_over)
    {
        while (Reads_issued < Reads_completed + In_max_io &&
               Input_scheduled < Input_size)
        {
            async = &Read_async[Reads_issued % In_max_io];
            async->over.Offset = (int)Input_scheduled;
            async->over.OffsetHigh = (int)(Input_scheduled >> 32);
            async->requested = Input_read_size;
            ResetEvent(async->over.hEvent);
            ret = ReadFile(Input_handle, In_buf[Reads_issued % In_max_io],
                           async->requested, &async->completed, &async->over);
            if (ret == 0 && GetLastError() != ERROR_IO_PENDING)
                sys_error(Input_name, 0);
            Input_scheduled += async->requested;
            Reads_issued++;
        }

        if (Reads_completed < Reads_issued)
        {
            async = &Read_async[Reads_completed % In_max_io];
            if (async->completed == 0) /* if read didn't complete instantly */
            {
                ret = GetOverlappedResult(Input_handle, &async->over,
                                          &async->completed, 1);
                if (!ret)
                    sys_error(Input_name, 0);
            }
            In_buf_next = In_buf[Reads_completed % In_max_io];
            bytes_read = async->completed;
            Reads_completed++;
        }
        else
        {
            EOF_seen = 1;
            return;
        }
    }
    else
    {
        In_buf_next = In_buf[0];
        ret = ReadFile(Input_handle, In_buf_next, Input_read_size,
                        &bytes_read, NULL);
        if (!ret)
        {
            if (GetLastError() == ERROR_BROKEN_PIPE)
                bytes_read = 0;
            else
                sys_error(Input_name != NULL ?
                          Input_name : get_string(MSG_SORT_INPUT_FILE), 0);
        }
        Input_scheduled += bytes_read;
    }
    In_buf_limit = In_buf_next + bytes_read;
    if (bytes_read == 0)
    {
        EOF_seen = 1;
        return;
    }
    Input_read += bytes_read;
}


/* WRITE_WAIT - wait for the oldest-issued write to complete.
 */
void write_wait()
{
    int         ret;
    async_t     *async;

    if (Phase == INPUT_PHASE) /* if input (sort) phase, we're writing to temp file */
    {
        async = &Write_async[Writes_completed % MAX_IO];
        if (async->completed == 0) /* if write didn't complete instantly */
        {
            ret = GetOverlappedResult(Temp_handle, &async->over,
                                      &async->completed, 1);
            if (!ret || async->completed != async->requested)
                sys_error(Temp_name, 0);
        }
    }
    else
    {
        if (Output_un_over)
        {
            async = &Write_async[Writes_completed % MAX_IO];
            if (async->completed == 0) /* if write didn't complete instantly */
            {
                ret = GetOverlappedResult(Output_handle, &async->over,
                                          &async->completed, 1);
                if (!ret || async->completed != async->requested)
                    sys_error(Output_name != NULL ?
                              Output_name : get_string(MSG_SORT_OUTPUT_FILE), 0);
            }
        }
    }
    Writes_completed++;
}


/* FLUSH_OUTPUT_BUF - flush the remainder data at the end of the temp or
 *                    output file.
 */
void flush_output_buf()
{
    int         bytes_written;
    int         ret;
    async_t     *async;

    async = &Write_async[Writes_issued % MAX_IO];
    async->over.Offset = (int)Out_offset;
    async->over.OffsetHigh = (int)(Out_offset >> 32);
    async->requested = Out_buf_bytes;

    if (Phase == INPUT_PHASE) /* if input (sort) phase, we're writing to temp file */
    {
        ResetEvent(async->over.hEvent);
        ret = WriteFile(Temp_handle, Out_buf[Writes_issued % MAX_IO],
                        async->requested, &async->completed, &async->over);
        if (ret == 0 && GetLastError() != ERROR_IO_PENDING)
            sys_error(Temp_name, 0);
    }
    else
    {
        if (Output_un_over)
        {
            /* if this is the last write and it is not a multiple of
             * the sector size.
             */
            if (Out_buf_bytes % Output_sector_size)
            {
                /* close handle and reopen it for buffered writes so that
                 * a non-sector-sized write can be done.
                 */
                CloseHandle(Output_handle);
                Output_handle = CreateFile(Output_name,
                                           GENERIC_WRITE,
                                           FILE_SHARE_READ,
                                           NULL,
                                           OPEN_ALWAYS,
                                           FILE_FLAG_OVERLAPPED,
                                           NULL);
                if (Output_handle == INVALID_HANDLE_VALUE)
                    sys_error(Output_name, 0);
            }
            ResetEvent(async->over.hEvent);
            ret = WriteFile(Output_handle, Out_buf[Writes_issued % Out_max_io],
                            async->requested, &async->completed, &async->over);
            if (ret == 0 && GetLastError() != ERROR_IO_PENDING)
                sys_error(Output_name != NULL ?
                          Output_name : get_string(MSG_SORT_OUTPUT_FILE), 0);
        }
        else
        {
            ret = WriteFile(Output_handle, Out_buf[Writes_issued % Out_max_io],
                            Out_buf_bytes, &bytes_written, NULL);
            if (!ret || bytes_written != Out_buf_bytes)
                sys_error(Output_name != NULL ?
                          Output_name : get_string(MSG_SORT_OUTPUT_FILE), 0);
            async->completed = bytes_written;
        }
    }
    Out_offset += Out_buf_bytes;
    Out_buf_bytes = 0;
    Writes_issued++;
}


/* TEST_FOR_UNICODE - test if input is Unicode and determine various
 *                    record lenths.
 */
void test_for_unicode()
{
    read_next_input_buf();

    if (Input_read == 0)
        EOF_seen = 1;

    if (Input_read > 1 && IsTextUnicode(In_buf_next, (int)Input_read, NULL))
    {
        Input_chars = CHAR_UNICODE;

        if (*(wchar_t *)In_buf_next == 0xfeff)
            In_buf_next += sizeof(wchar_t);     /* eat byte order mark */
        Max_rec_bytes_internal = Max_rec_length * sizeof(wchar_t);
        Max_rec_bytes_external = Max_rec_length * sizeof(wchar_t);
    }
    else
    {
        /* use single-byte mode only if the "C" locale is used.  This is
         * because _stricoll() is *much* slower than _wcsicoll() if the
         * locale is not "C".
         */
        if (CPInfo.MaxCharSize == 1 && Locale != NULL && !strcmp(Locale, "C"))
        {
            Input_chars = CHAR_SINGLE_BYTE;
            Max_rec_bytes_internal = Max_rec_length;
            Max_rec_bytes_external = Max_rec_length;
        }
        else
        {
            Input_chars = CHAR_MULTI_BYTE;
            Max_rec_bytes_internal = Max_rec_length * sizeof(wchar_t);
            Max_rec_bytes_external = Max_rec_length * CPInfo.MaxCharSize;
        }
    }

    Output_chars = Input_chars;

    /* Incredible as it might seem, even when the input is Unicode we
     * produce multibyte character output.  (This follows the previous
     * NT sort implementation.)  The previous implementation would write
     * Unicode directly to the console, but we always translate to
     * multibyte characters so we can always use WriteFile(), avoiding
     * WriteConsole().
     */
    if (UnicodeOut) {
        Output_chars=CHAR_UNICODE;
    } else {
        if (Input_chars == CHAR_UNICODE)
            Output_chars = CHAR_MULTI_BYTE;
    }
    /* define the record comparison routine
     */
    Compare = Input_chars == CHAR_SINGLE_BYTE ?
	        (Case_sensitive ? SBCS_case_compare : SBCS_compare) :
	        (Case_sensitive ? Unicode_case_compare : Unicode_compare);
}


/* GET_SECTOR_SIZE - get the sector size of a file.
 */
int get_sector_size(TCHAR *path)
{
    TCHAR       *ptr;
    int         sector_size;
    TCHAR       buf[1000];
    int         foo;

    // Initialize to null length string
    buf[0] = 0; 
    // protect against null pointer and buffer overrun
    if ( (path != NULL) && (_tcslen(path) < (sizeof(buf)/sizeof(buf[0])) ) ) {
        _tcscpy(buf, path);
    }

    /* attempt to determine the sector size of the temporary device.
     * This is complicated by the fact that GetDiskFreeSpace requires
     * a root path (why?).
     *
     * Try transforming the temp directory to its root path.  If that doesn't
     * work, get the sector size of the current disk.
     */
    ptr = _tcschr(buf, '\\');
    if (ptr != NULL)
        ptr[1] = 0;     /* transform temp_path to its root directory */
    if (!GetDiskFreeSpace(buf, &foo, &sector_size, &foo, &foo))
        GetDiskFreeSpace(NULL, &foo, &sector_size, &foo, &foo);

    
    return (sector_size);
}


/* INIT_TWO_PASS - initialize for a two-pass sort.
 */
void init_two_pass()
{

    TCHAR       temp_path[TEMP_LENGTH];

    if (Two_pass == 1)
        return;
    Two_pass = 1;

    if (Temp_dir != NULL)
        _tcscpy(temp_path, Temp_dir);
    else
        if ( !GetTempPath(TEMP_LENGTH - 1, temp_path) ) {
            sys_error(_TEXT("TEMP path"), 0);
        }
    GetTempFileName(temp_path, _TEXT("srt"), 0, Temp_name);

    Temp_handle =
        CreateFile(Temp_name,
                   GENERIC_READ | GENERIC_WRITE,
                   0,           /* don't share file access */
                   NULL,
                   CREATE_ALWAYS,
                   FILE_FLAG_NO_BUFFERING |
                     FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,
                   NULL);
    if (Temp_handle == INVALID_HANDLE_VALUE)
        sys_error(Temp_name, 0);
    Temp_sector_size = get_sector_size(temp_path);
}


/* REVIEW_OUTPUT_MODE - now that we are ready to write to the output file,
 *                      determine how we should write it.
 */
void review_output_mode()
{
    MEMORYSTATUSEX      ms;

    CloseHandle(Input_handle);

    Out_offset = 0;
    Out_buf_size = Output_buf_size;

    if (Output_type != FILE_TYPE_DISK)
    {
        Out_buf_size = min(Out_buf_size, 4096);
        return;
    }

    /* if we are performing a two-pass sort, or there is not enough
     * available physical memory to hold the output file.
     */
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatusEx(&ms);
    if (Two_pass || (ms.ullAvailPhys < (ULONGLONG)Input_read))
    {
        if (Output_name == NULL)
        {
            warning(MSG_SORT_REDIRECT_OUTPUT);
            return;
        }
        Output_un_over = 1;
    }

    /* if Output_name has been specified, we haven't opened Output_handle
     * yet.
     */
    if (Output_name)
    {
        if (Output_un_over)
        {
            Out_max_io = MAX_IO;
            Output_sector_size = get_sector_size(Output_name);
            Output_handle =
              CreateFile(Output_name,
                         GENERIC_WRITE,
                         FILE_SHARE_READ,
                         NULL,
                         CREATE_ALWAYS,
                         FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
                         NULL);
        }
        else
        {
            Output_handle =
              CreateFile(Output_name,
                         GENERIC_WRITE,
                         FILE_SHARE_READ,
                         NULL,
                         CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);
        }
        if (Output_handle == INVALID_HANDLE_VALUE)
            sys_error(Output_name, 0);
    }
}


/* READ_REC - read a record from the input file into main memory,
 *            translating to Unicode if necessary.
 */
void read_rec()
{
    char        *begin;
    char        *limit;
    char        *cp;
    wchar_t     *wp;
    int         bsize;
    int         char_count;
    int         rec_buf_bytes;
    int         delimiter_found;

    /* if input buffer is empty
     */
    if (In_buf_next == In_buf_limit)
    {
        read_next_input_buf();
        if (EOF_seen)
            return;
    }
    begin = In_buf_next;
    limit = In_buf_limit;

    /* loop until we have scanned the next record
     *
     * when we exit the following loop:
     * - "begin" will point to the scanned record (either in the original
     *   input buffer or in Rec_buf)
     * - "bsize" will contain the number of bytes in the record.
     */
    cp = begin;
    delimiter_found = 0;
    rec_buf_bytes = 0;
    for (;;)
    {
        /* potentially adjust scan limit because of maximum record length
         */
        if (limit > cp + Max_rec_bytes_external - rec_buf_bytes)
            limit = cp + Max_rec_bytes_external - rec_buf_bytes;

        if (Input_chars == CHAR_UNICODE)
        {
            wp = (wchar_t *)cp;
            while (wp < (wchar_t *)limit &&
                   *wp != '\n' && *wp != '\0' && *wp != CTRL_Z)
            {
                wp++;
            }
            cp = (char *)wp;
            bsize = (int)(cp - begin);
            if (cp == limit)  /* didn't find delimiter, ran out of input */
                In_buf_next = (char *)wp;
            else
            {
                delimiter_found = 1;
                In_buf_next = (char *)(wp + 1);
                if (*wp == CTRL_Z)
                {
                    EOF_seen = 1;
                    if (bsize + rec_buf_bytes == 0)
                        return; /* ignore zero sized record */
                }
            }
        }
        else    /* single or multi byte input */
        {
            while (cp < limit && *cp != '\n' && *cp != '\0' && *cp != CTRL_Z)
                cp++;
            bsize = (int)(cp - begin);
            if (cp == limit)  /* didn't find delimiter, ran out of input */
                In_buf_next = cp;
            else
            {
                delimiter_found = 1;
                In_buf_next = cp + 1;
                if (*cp == CTRL_Z)
                {
                    EOF_seen = 1;
                    if (bsize + rec_buf_bytes == 0)
                        return; /* ignore zero sized record */
                }
            }
        }

        /* if we didn't find the delimiter or we have already stored
         * the beginning portion of the record in Rec_buf.
         */
        if (!delimiter_found || rec_buf_bytes)
        {
            /* copy the portion of the record into Rec_buf
             */
            if (rec_buf_bytes + bsize >= Max_rec_bytes_external)
                error(MSG_SORT_REC_TOO_BIG);
            memcpy((char *)Rec_buf + rec_buf_bytes, begin, bsize);
            rec_buf_bytes += bsize;

            if (!delimiter_found)
            {
                /* read another input buffer
                 */
                read_next_input_buf();
                if (!EOF_seen)
                {
                    cp = begin = In_buf_next;
                    limit = In_buf_limit;
                    continue;   /* scan some more to find record delimiter */
                }

                /* EOF reached without finding delimiter.  Fall through
                 * and use whatever we have in Rec_buf as the record. */
            }

            /* set begin and size of record in Rec_buf
             */
            begin = Rec_buf;
            bsize = rec_buf_bytes;
            break;
        }
        else /* found delimiter && haven't store a record prefix in Rec_buf */
            break;
    }

    /* ignore any carriage return at end of record
     */
    if (Input_chars == CHAR_UNICODE)
    {
        wp = (wchar_t *)(begin + bsize);
        if (bsize && wp[-1] == '\r')
            bsize -= sizeof(wchar_t);
    }
    else
    {
        cp = begin + bsize;
        if (bsize && cp[-1] == '\r')
            bsize -= 1;
    }

    /* copy scanned record into internal storage
     */
    cp = Next_rec;
    if (Input_chars == CHAR_SINGLE_BYTE)
    {
        memcpy(Next_rec, begin, bsize);
        char_count = bsize;
        cp[char_count] = 0;
        Next_rec += char_count + 1;
    }
    else
    {
        if (Input_chars == CHAR_UNICODE)
        {
            memcpy(Next_rec, begin, bsize);
            char_count = bsize / sizeof(wchar_t);
        }
        else    /* CHAR_MULTI_BYTE */
        {
            if (bsize)
            {
                char_count = MultiByteToWideChar(CP_OEMCP, 0,
                                                 begin, bsize,
                                                 (wchar_t *)Next_rec,
                                                 Max_rec_length);
                if (char_count == 0)
                    error(MSG_SORT_REC_TOO_BIG);
            }
            else
                char_count = 0;
        }
        wp = (wchar_t *)Next_rec;
        wp[char_count] = 0;
        Next_rec = (char *)(wp + char_count + 1);
    }

    /* store pointer to record
     *
     * if record is short (the /+n option directs us to skip to the
     * delimiting NULL in the record or beyond), place record in a
     * separate "short" list.
     */
    if (char_count <= Position)
    {
        --Last_recp;
        --Short_recp;
        *Last_recp = *Short_recp;
        *Short_recp = cp;
    }
    else
        *--Last_recp = cp;      /* place record in list of normal records */
}


/* MERGE_PHASE_RUNS_ALLOWED - determine the number of runs allowed for
 *                            the given memory and temp buf size.
 */
unsigned merge_phase_runs_allowed(unsigned mem_size, int temp_buf_size)
{
    unsigned    overhead;
    unsigned    bytes_per_run;

    /* per run memory consists of temp file buffers, record buffer,
     * run struct and tournament tree pointer.
     */
    bytes_per_run = temp_buf_size * N_RUN_BUFS +
        Max_rec_bytes_internal + sizeof(run_t) + sizeof(run_t *);
    overhead = (unsigned)(Merge_phase_run_begin - Alloc_begin);
    return ((mem_size - overhead) / bytes_per_run);
}


/* TWO_PASS_FIT - determine if the sort will fit in two passes.
 */
BOOL two_pass_fit(__int64 internal_size, unsigned mem_size, int temp_buf_sz)
{
    unsigned    temp;
    __int64     est_runs;
    unsigned    mpra;
    unsigned    sort_phase_overhead;

    sort_phase_overhead =
        (unsigned)((Rec - Alloc_begin) + Max_rec_bytes_internal + sizeof(char *));

    mpra = merge_phase_runs_allowed(mem_size, temp_buf_sz);

    /* estimate the number of runs that would be produced during the
     * sort phase by the given memory size.  Assume we will leave
     * space for twice the allowed runs.  If the number of runs is
     * larger than expected, we will reduce the Temp_buf_size to
     * allow them to fit in the merge phase.
     */
    Run_limit = 2 * mpra;
    temp = mem_size - (sort_phase_overhead +
                       Run_limit * (sizeof(run_t) + sizeof(run_t *)));
    est_runs = (internal_size + temp - 1) / temp;

    /* mem_size allows a fit if the number of runs produced by the
     * sort phase is <= the number of runs that fit in memory
     * during the merge phase.
     */
    return (est_runs <= mpra);
}


/* FIND_TWO_PASS_MEMORY_SIZE - find the memory size such that a two-pass
 *                             sort can be performed.
 */
unsigned find_two_pass_mem_size(__int64 internal_size)
{
    unsigned    curr_size;
    unsigned    last_size;
    unsigned    lower_limit;
    unsigned    upper_limit;
    unsigned    temp_rd_sz;

    /* if a two-pass sort can be performed with the current Temp_buf_size.
     */
    if (two_pass_fit(internal_size, Memory_limit, Temp_buf_size))
    {
        /* perform a binary search to find the minimum memory size for
         * a two-pass sort with the current Temp_buf_size.
         * This will even out the memory usage between the sort phase
         * and merge phase.
         */
        lower_limit = (unsigned)((char *)End_recp - Alloc_begin);   /* existing size */
        upper_limit = Memory_limit;
        curr_size = ROUND_UP((lower_limit + upper_limit) / 2, Sys.dwPageSize);
        do
        {
            last_size = curr_size;

            if (two_pass_fit(internal_size, curr_size, Temp_buf_size))
            {
                upper_limit = curr_size;
                curr_size = (curr_size + lower_limit) / 2;
            }
            else
            {
                lower_limit = curr_size;
                curr_size = (curr_size + upper_limit) / 2;
            }
            curr_size = ROUND_UP(curr_size, Sys.dwPageSize);

        } while (curr_size != last_size);

        return (curr_size);
    }
    else
    {
        /* keep reducing theoretical temp file read size until it fits.
         * This iteration is an exercise directed at getting a
         * reasonable (not too large) Run_limit.  The actual temp file
         * read size will not be set until the beginning of the merge phase.
         */
        for (temp_rd_sz = Temp_buf_size - Sys.dwPageSize;
             temp_rd_sz >= Sys.dwPageSize; temp_rd_sz -= Sys.dwPageSize)
        {
            if (two_pass_fit(internal_size, Memory_limit, temp_rd_sz))
                break;
        }

        /* if it didn't even fit with the mimium temp buf read size, give up.
         */
        if (temp_rd_sz < Sys.dwPageSize)
            error(MSG_SORT_NOT_ENOUGH_MEMORY);

        return (Memory_limit);
    }
}


/* STRATEGY - determine if we have sufficent memory for a one-pass sort,
 *            or if we should optimize for a two-pass sort.
 */
void strategy()
{
    int         ptr_bytes;
    int         delta;
    unsigned    new_size;
    int         n_recs;
    int         n_internal_bytes;
    int         bytes_read;
    __int64     est_internal_size;
    __int64     est_one_pass_size;

    /* determine appropriate memory size to use
     */
    if (Input_type != FILE_TYPE_DISK)
    {
        /* Don't know the size of the input.  Allocate as much memory
         * as possible and hope it fits in either one or two passes.
         */
        new_size = Memory_limit;
        Run_limit = merge_phase_runs_allowed(new_size, Sys.dwPageSize);
    }
    else
    {
        n_recs = (int)(End_recp - Last_recp);
        n_internal_bytes = (int)(Next_rec - Rec);
        bytes_read = (int)Input_read - (int)(In_buf_limit - In_buf_next);

        /* estimate the amount of internal memory it would take to
         * hold the entire input file.
         */
        est_internal_size = (__int64)
          (((double)(n_internal_bytes + n_recs * sizeof(char *)) / bytes_read)
            * Input_size);

        /* calculate the total estimated amount of main memory for a one
         * pass sort.  Since smaller record sizes than those already sampled
         * can require additional memory (more ptrs per record byte), we will
         * bump up the estimated record and pointer size by 10%.
         */
        est_one_pass_size = (__int64)
          ((double)est_internal_size * 1.1 +
           (Rec - Alloc_begin) + Max_rec_bytes_internal + sizeof(char *));
        est_one_pass_size = ROUND_UP(est_one_pass_size, Sys.dwPageSize);

        if (User_memory_limit)
        {
            new_size = Memory_limit;    /* da user's da boss */
            Run_limit = merge_phase_runs_allowed(new_size, Sys.dwPageSize);
        }
        else if (est_one_pass_size <= Memory_limit)
        {
            new_size = (int)est_one_pass_size;  /* plan for one pass sort */
            Run_limit = 2;      /* just in case we don't make it */
        }
        else
        {
            /* find memory size for a two-pass sort
             */
            new_size = find_two_pass_mem_size(est_internal_size);
            init_two_pass();
        }

        /* if input file and sort memory will not fit in available memory,
         * access input file as unbuffered and overlapped.
         */
        if (Input_size + est_one_pass_size > Memory_limit)
        {
            if (Input_name == NULL)
                warning(MSG_SORT_REDIRECT_INPUT);
            else
            {
                /* close input file handle,
                 * reopen it handle as unbuffered and overlapped.
                 */
                CloseHandle(Input_handle);
                Input_handle =
                  CreateFile(Input_name,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
                             NULL);
                if (Input_handle == INVALID_HANDLE_VALUE)
                    sys_error(Input_name, 0);
                Input_un_over = 1;
                In_max_io = MAX_IO;
            }
        }
    }
#if 0
    fprintf(stderr, "new_size: %d\n", new_size);
#endif
    assert(new_size > (unsigned)((char *)End_recp - Alloc_begin));
    if (VirtualAlloc(Alloc_begin, new_size, MEM_COMMIT, PAGE_READWRITE)
        == NULL)
    {
        error(MSG_SORT_NOT_ENOUGH_MEMORY);
    }

    /* allocate the run array and tournament tree backwards from the end
     * of the newly allocated memory.
     */
    Tree = (run_t **)(Alloc_begin + new_size - Run_limit * sizeof(run_t *));
    Run = (run_t *)((char *)Tree - Run_limit * sizeof(run_t));

    /* reallocate record pointers to end of the enlarged memory block.
     */
    delta = (int)((char **)Run - End_recp);
    ptr_bytes = (int)((char *)End_recp - (char *)Last_recp);
    memcpy(Last_recp + delta, Last_recp, ptr_bytes);
    Last_recp += delta;
    Short_recp += delta;
    End_recp += delta;
}


/* READ_INPUT - read records from the input file until there is not enough
 *              space for a maximum-length record.
 */
void read_input()
{
    /* While there is space for a maximum-length record and its pointer
     */
    while (!EOF_seen && (char *)(Last_recp - 1) - Next_rec >=
           Max_rec_bytes_internal + (int)sizeof(char *))
    {
        read_rec();
    }
}


/* SAMPLE_INPUT - read some records into the initial memory allocation
 *                so we can later analyze the records.
 */
void sample_input()
{
    /* read some input and test for unicode
     */
    test_for_unicode();

    /* Read records into the initially small memory allocation so that
     * we can calculate average record lengths.
     */
    if (!EOF_seen)
        read_input();
}


/* SORT - sort the "normal" length records in main memory.
 */
void sort()
{
    qsort(Last_recp, (unsigned)(Short_recp - Last_recp), sizeof(void *), Compare);
}


/* OUTPUT_REC - output a record to either the temporary or output file.
 */
void output_rec(char *cp)
{
    int         buf_bytes;
    int         copy_size;
    int         bsize;
    char        *rec;

    /* copy/transform record bytes into Rec_buf
     */
    rec = Rec_buf;
    if (Output_chars == CHAR_UNICODE)
    {
        bsize = wcslen((wchar_t *)cp) * sizeof(wchar_t);
        memcpy(rec, cp, bsize);

        if (Phase == INPUT_PHASE) /* if input phase and writing to temp disks */
        {
            *(wchar_t *)(rec + bsize) = L'\0';
            bsize += sizeof(wchar_t);
        }
        else
        {
            *(wchar_t *)(rec + bsize) = L'\r';
            bsize += sizeof(wchar_t);
            *(wchar_t *)(rec + bsize) = L'\n';
            bsize += sizeof(wchar_t);
        }
    }
    else
    {
        if (Output_chars == CHAR_MULTI_BYTE)
        {
            bsize = WideCharToMultiByte(CP_OEMCP, 0,
                                        (wchar_t *)cp, -1,
                                        rec, Max_rec_bytes_external,
                                        NULL, NULL);
            assert(bsize != 0);
            bsize--;    /* ignore trailing zero */
        }
        else /* Output_chars == CHAR_SINGLE_BYTE */
        {
            bsize = strlen(cp);
            memcpy(rec, cp, bsize);
        }

        if (Phase == INPUT_PHASE)     /* if input phase and writing to temp disks */
            rec[bsize++] = '\0';
        else
        {
            rec[bsize++] = '\r';
            rec[bsize++] = '\n';
        }
    }

    /* copy record bytes to output buffer and initiate a write, if necessary
     */
    buf_bytes = Out_buf_bytes;
    for (;;)
    {
        copy_size = min(bsize, Out_buf_size - buf_bytes);
        memcpy(Out_buf[Writes_issued % (Phase == INPUT_PHASE ? MAX_IO : Out_max_io)]
               + buf_bytes, rec, copy_size);
        buf_bytes += copy_size;

        if (buf_bytes < Out_buf_size)
            break;

        Out_buf_bytes = buf_bytes;
        /* if all write buffers have a write pending */
        if (Writes_completed + Out_max_io == Writes_issued)
            write_wait();
        flush_output_buf();
        buf_bytes = 0;

        bsize -= copy_size;
        if (bsize == 0)
            break;
        rec += copy_size;
    }
    Out_buf_bytes = buf_bytes;
}


/* OUTPUT_NORMAL - output records whose length is greater than the
 *                 starting compare Position.
 */
void output_normal()
{
    int         i, n;

    n = (int)(Short_recp - Last_recp);
    for (i = 0; i < n; i++)
        output_rec(Last_recp[i]);
}


/* OUTPUT_SHORTS - output records whose length is equal to or less than the
 *                 starting compare Position.
 */
void output_shorts()
{
    int         i, n;

    n = (int)(End_recp - Short_recp);
    for (i = 0; i < n; i++)
        output_rec(Short_recp[i]);
}


/* COMPLETE_WRITES - finish the writing of the temp or output file.
 */
void complete_writes()
{
    /* wait for all pending writes to complete
     */
    while (Writes_completed != Writes_issued)
        write_wait();

    /* if necessary, issue one last write (possibly unbuffered).
     */
    if (Out_buf_bytes)
    {
        flush_output_buf();
        write_wait();
    }
}


/* WRITE_RECS - write out the records which have been read from the input
 *              file into main memory, divided into "short" and "normal"
 *              records, and sorted.
 *
 *              This routine is called to either write a run of records to
 *              the temporary file during a two-pass sort (Phase == INPUT_PHASE),
 *              or to write all the records to the output file during a
 *              one-pass sort.
 */
void write_recs()
{
    if (Phase == INPUT_PHASE)   /* if writing a run to the temp file */
    {
        if (N_runs == Run_limit)
            error(MSG_SORT_NOT_ENOUGH_MEMORY);
        Run[N_runs].begin_off = Out_offset + Out_buf_bytes;
    }

    if (Reverse)
        output_normal();        /* non-short records go first */
    else
        output_shorts();        /* short records go first */

    if (Phase == INPUT_PHASE)   /* if writing a run to the temp file */
        Run[N_runs].mid_off = Out_offset + Out_buf_bytes;

    if (Reverse)
        output_shorts();        /* short records go last */
    else
        output_normal();        /* non-short records go last */

    if (Phase == INPUT_PHASE)   /* if writing a run to the temp file */
    {
        int     sector_offset;

        Run[N_runs].end_off = Out_offset + Out_buf_bytes;

        /* if not on sector boundry, get on one
         */
        sector_offset = Out_buf_bytes & (Temp_sector_size - 1);
        if (sector_offset)
            memset(Out_buf[Writes_issued % MAX_IO] + Out_buf_bytes, 0,
                   Temp_sector_size - sector_offset);
        Out_buf_bytes += Temp_sector_size - sector_offset;

        N_runs++;
    }

    complete_writes();
}


/* SCHED_RUN_READ - schedule the next temp file read for the given run.
 */
void sched_run_read(run_t *run)
{
    __int64     buf_off;
    int         rem;
    int         transfer;
    int         ret;
    async_t     *async;

    buf_off = run->begin_off + run->blks_read * Temp_buf_size;
    transfer = Temp_buf_size;
    if (transfer > run->end_off - buf_off)
    {
        transfer = (int)(run->end_off - buf_off);
        rem = transfer & (Temp_sector_size - 1);
        if (rem)
            transfer += Temp_sector_size - rem;
    }

    async = &Read_async[Reads_issued % MAX_IO];
    async->over.Offset = (int)buf_off;
    async->over.OffsetHigh = (int)(buf_off >> 32);
    async->requested = transfer;
    ResetEvent(async->over.hEvent);
    ret = ReadFile(Temp_handle, run->buf[run->blks_read % N_RUN_BUFS],
                   async->requested, &async->completed, &async->over);
    if (ret == 0 && GetLastError() != ERROR_IO_PENDING)
        sys_error(Temp_name, 0);
    Reads_issued++;
}


/* QUEUE_RUN_READ - put given run on queue of runs needing their next
 *                  temp file block read.
 */
void queue_run_read(run_t *run)
{
    /* place run on read queue
     */
    run->next = NULL;
    if (Run_read_head == NULL)
        Run_read_head = Run_read_tail = run;
    else
    {
        Run_read_tail->next = run;
        Run_read_tail = run;
    }

    /* if we can schedule a read immediately, do so.
     */
    if (Reads_issued < Reads_completed + MAX_IO)
        sched_run_read(run);
}


/* WAIT_BLK_READ - wait for the oldest-issued temp file block read to complete.
 */
void wait_blk_read()
{
    assert(Reads_issued != Reads_completed);
    WaitForSingleObject(Read_async[Reads_completed % MAX_IO].over.hEvent,
                        INFINITE);
}


/* CHECK_RUN_READS - check the temp file reads to see if there are any
 *                   have finished or need to be started.
 */
void check_run_reads()
{
    __int64     buf_off;
    async_t     *async;
    run_t       *run;
    int         ret;
    int         i;
    int         bytes_read;

    if (Reads_issued == Reads_completed)    /* if nothing happening */
        return;

    /* see if most recently issued read has completed
     */
    run = Run_read_head;
    async = &Read_async[Reads_completed % MAX_IO];
    if (async->completed == 0) /* if read didn't complete instantly */
    {
        ret = GetOverlappedResult(Temp_handle, &async->over, &bytes_read, 0);
        if (!ret)
        {
            if (GetLastError() != ERROR_IO_INCOMPLETE)
                sys_error(Temp_name, 0);
            return;     /* try again */
        }
        async->completed = bytes_read;
    }

    /* process completed read
     */
    assert(async->completed == async->requested);
    buf_off = (unsigned)async->over.Offset;
    buf_off += (__int64)async->over.OffsetHigh << 32;
    assert(buf_off == run->begin_off + run->blks_read * Temp_buf_size);

    Reads_completed++;
    run->blks_read++;
    Run_read_head = run->next;

    /* Since we just finished a read, we can schedule a new read if there
     * is an unscheduled run on the run read queue.
     */
    run = Run_read_head;
    for (i = Reads_completed; i < Reads_issued; i++)
        run = run->next;   /* skip over runs with an issued/scheduled read */
    if (run != NULL)
        sched_run_read(run);
}


/* GET_NEXT_TEMP_BUF - get the next buffer of temp file data for the given run.
 */
void get_next_temp_buf(run_t *run)
{
    assert(run->next_byte == run->buf_begin + run->buf_bytes);

    /* while the next read for this run has not completed
     */
    while (run->blks_read == run->blks_scanned)
    {
        wait_blk_read();
        check_run_reads();
    }

    run->buf_off = run->begin_off + run->blks_scanned * Temp_buf_size;
    run->buf_begin = run->buf[run->blks_scanned % N_RUN_BUFS];
    run->next_byte = run->buf_begin;
    run->buf_bytes = Temp_buf_size;
    if (run->buf_bytes > run->end_off - run->buf_off)
        run->buf_bytes = (int)(run->end_off - run->buf_off);
    run->blks_scanned++;
    assert(run->blks_scanned <= run->blks_read);

    /* if there is another block to be read for this run, queue it up.
     */
    if (run->begin_off + run->blks_read * Temp_buf_size < run->end_off)
        queue_run_read(run);
}


/* READ_TEMP_REC - read the next record from the temporary file for the
 *                 given run.
 */
int read_temp_rec(run_t *run)
{
    char        *begin;
    char        *limit;
    char        *cp;
    wchar_t     *wp;
    int         bsize;
    int         char_count;
    int         rec_buf_bytes;
    int         delimiter_found;

    /* if the current read offset is up to the end offset, return false.
     */
    if (run->buf_off + (run->next_byte - run->buf_begin) >= run->end_read_off)
        return (0);

    /* if input buffer is empty
     */
    if (run->next_byte == run->buf_begin + run->buf_bytes)
        get_next_temp_buf(run);
    begin = run->next_byte;
    limit = run->buf_begin + run->buf_bytes;

    /* loop until we have scanned the next record
     *
     * when we exit the following loop:
     * - "begin" will point to the scanned record (either in the original
     *   input buffer or in Rec_buf)
     * - "bsize" will contain the number of bytes in the record.
     */
    cp = begin;
    delimiter_found = 0;
    rec_buf_bytes = 0;
    for (;;)
    {
        /* potentially adjust scan limit because of maximum record length
         */
        if (limit > cp + Max_rec_bytes_external - rec_buf_bytes)
            limit = cp + Max_rec_bytes_external - rec_buf_bytes;

        if (Input_chars == CHAR_UNICODE)
        {
            wp = (wchar_t *)cp;
            while (wp < (wchar_t *)limit && *wp != '\0')
            {
                wp++;
            }
            cp = (char *)wp;
            bsize = (int)(cp - begin);
            if (cp == limit)  /* didn't find delimiter, ran out of input */
                run->next_byte = (char *)wp;
            else
            {
                delimiter_found = 1;
                run->next_byte = (char *)(wp + 1);
            }
        }
        else    /* single or multi byte input */
        {
            while (cp < limit && *cp != '\0')
                cp++;
            bsize = (int)(cp - begin);
            if (cp == limit)  /* didn't find delimiter, ran out of input */
                run->next_byte = cp;
            else
            {
                delimiter_found = 1;
                run->next_byte = cp + 1;
            }
        }

        /* if we didn't find the delimiter or we have already stored
         * the beginning portion of the record in Rec_buf.
         */
        if (!delimiter_found || rec_buf_bytes)
        {
            /* copy the portion of the record into Rec_buf
             */
            if (rec_buf_bytes + bsize >= Max_rec_bytes_external)
                error(MSG_SORT_REC_TOO_BIG);
            memcpy((char *)Rec_buf + rec_buf_bytes, begin, bsize);
            rec_buf_bytes += bsize;

            if (!delimiter_found)
            {
                /* read another input buffer
                 */
                get_next_temp_buf(run);

                cp = begin = run->next_byte;
                limit = run->buf_begin + run->buf_bytes;
                continue;       /* scan some more to find record delimiter */
            }

            /* set begin and size of record in Rec_buf
             */
            begin = Rec_buf;
            bsize = rec_buf_bytes;
            break;
        }
        else /* found delimiter && haven't store a record prefix in Rec_buf */
            break;
    }

    /* copy scanned record into internal storage
     */
    cp = run->rec;
    if (Input_chars == CHAR_SINGLE_BYTE)
    {
        memcpy(run->rec, begin, bsize);
        char_count = bsize;
        cp[char_count] = 0;
    }
    else
    {
        if (Input_chars == CHAR_UNICODE)
        {
            memcpy(run->rec, begin, bsize);
            char_count = bsize / sizeof(wchar_t);
        }
        else    /* CHAR_MULTI_BYTE */
        {
            if (bsize)
            {
                char_count = MultiByteToWideChar(CP_OEMCP, 0,
                                                 begin, bsize,
                                                 (wchar_t *)run->rec,
                                                 Max_rec_length);
                if (char_count == 0)
                    error(MSG_SORT_CHAR_CONVERSION);
            }
        }
        wp = (wchar_t *)run->rec;
        wp[char_count] = 0;
    }

    return (1);
}


/* COPY_SHORTS - copy the "short" records for each run to the output file.
 */
void copy_shorts()
{
    unsigned int    i;
    run_t           *run;

    for (i = 0; i < N_runs; i++)
    {
        run = &Run[i];
        while (read_temp_rec(run))
            output_rec(run->rec);
    }
}


/* TREE_INSERT - insert a next record for the given run into the
 *               tournament tree.
 */
run_t *tree_insert(run_t *run, int not_empty)
{
    int         i;
    run_t       **node;
    run_t       *winner;
    run_t       *temp;
    int         (_cdecl *compare)(const void *, const void *);

    compare = Compare;

    winner = (not_empty ? run : END_OF_RUN);

    /* start at the bottom of the tournament tree, work up the the top
     * comparing the current winner run with the runs on the path to the
     * top of the tournament tree.
     */
    for (i = (run->index + N_runs) / 2; i != 0; i >>= 1)
    {
        node = &Tree[i];

        /* empty tree nodes get filled immediately, and we're done with the
         * insertion as all node above this one must be empty also.
         */
        if (*node == NULL_RUN)
        {
            *node = winner;
            return (NULL_RUN);
        }

        /* if run at current tree node has reached its end, it loses (no swap).
         */
        if (*node == END_OF_RUN)
            continue;
        else if (winner == END_OF_RUN)
        {
            /* current winner run has reached the end of its records,
             * swap and contine.
             */
            winner = *node;
            *node = END_OF_RUN;
        }
        else
        {
            /* both the winner run and the run at the current node have
             * a record.  Compare records and swap run pointer if necessary.
             */
            if (compare((void *)&winner->rec, (void *)&(*node)->rec) > 0)
            {
                temp = winner;
                winner = *node;
                *node = temp;
            }
        }
    }

    return (winner);
}


/* MERGE_RUNS - merge the runs in the temporary file to produce a stream of
 *              "normal"-length records to be written to the output file.
 */
void merge_runs()
{
    unsigned int    i;
    run_t           *run;

    /* initialize all tree nodes to be empty
     */
    for (i = 0; i < N_runs; i++)
        Tree[i] = NULL_RUN;

    /* fill tree with all runs except for the first
     */
    for (i = 1; i < N_runs; i++)
    {
        run = &Run[i];
        run = tree_insert(run, read_temp_rec(run));
        assert(run == NULL_RUN);
    }

    /* replacement-selection main loop
     */
    run = &Run[0];
    for (i = 0; ; i++)
    {
        /* replace winner record by inserting next record from the same
         * run into the tournament tree.
         */
        run = tree_insert(run, read_temp_rec(run));
        if ( (run == END_OF_RUN) ||
             (run == NULL_RUN) )
        {
            break;
        }
        output_rec(run->rec);   /* output winner record */
        if ((i & 0xff) == 0)
            check_run_reads();  /* periodically check run reads */
    }
}


/* MERGE_PASS - execute the merge pass of a two-pass sort.
 */
void merge_pass()
{
    unsigned int    i, j;
    int             per_run_mem;
    int             read_buf_size;

    per_run_mem = (int)(((char *)Run - Merge_phase_run_begin) / N_runs);
    read_buf_size = (per_run_mem - Max_rec_bytes_internal) / N_RUN_BUFS;
    read_buf_size = ROUND_DOWN(read_buf_size, Sys.dwPageSize);
    if (read_buf_size == 0)
        error(MSG_SORT_NOT_ENOUGH_MEMORY);
    if (read_buf_size > MAX_XFR_SIZE)
        read_buf_size = MAX_XFR_SIZE;
    if (Temp_buf_size > read_buf_size)
        Temp_buf_size = read_buf_size; /* adjust only if reduction */
#if 0
    fprintf(stderr, "merge phase adjustment: %d to %d\n",
            Output_buf_size, Temp_buf_size);
    fprintf(stderr, "N_runs: %d, Run_limit: %d\n", N_runs, Run_limit);
#endif
    /* initialize each run
     */
    for (i = 0; i < N_runs; i++)
    {
        Run[i].index = i;
        for (j = 0; j < N_RUN_BUFS; j++)
            Run[i].buf[j] = Merge_phase_run_begin +
              (i * N_RUN_BUFS + j) * Temp_buf_size;
        Run[i].next_byte = Run[i].buf_begin = Run[i].buf[0];
        Run[i].buf_off = Run[i].begin_off;
        Run[i].buf_bytes = 0;
        Run[i].end_read_off = Run[i].mid_off;
        Run[i].rec = Merge_phase_run_begin +
          (N_runs * N_RUN_BUFS * Temp_buf_size) + (i * Max_rec_bytes_internal);
        Run[i].blks_read = Run[i].blks_scanned = 0;
        Run[i].next = NULL;
        queue_run_read(&Run[i]);    /* queue a read of run's first block */
    }

    if (Reverse)
        merge_runs();
    else
        copy_shorts();

    /* adjust temp file ending offsets for each run to include the second
     * "half" of each run.
     */
    for (i = 0; i < N_runs; i++)
        Run[i].end_read_off = Run[i].end_off;

    if (Reverse)
        copy_shorts();
    else
        merge_runs();

    CloseHandle(Temp_handle);

    complete_writes();
}


/* CLEAR_RUN - clear the records from memory for the run just written to
 *              the temporary file.
 */
void clear_run()
{
    Last_recp = Short_recp = End_recp;
    Next_rec = Rec;
}


/* SET_LOCALE
 */
void set_locale()
{
    if (Locale == NULL)
        setlocale(LC_ALL, "");  /* use system-default locale */
    else if (strcmp(Locale, "C"))
        error(MSG_SORT_INVALID_LOCALE);
}


/* MAIN
 */
int
_cdecl main(int argc, char *argv[])
{
    
    SetThreadUILanguage(0);
    
    Phase = INPUT_PHASE;

    read_args(argc, argv);

    set_locale();

    init_input_output();

    init_mem();

    sample_input();

    if (!EOF_seen)
        strategy();

    /* generate run(s) */
    do
    {
        if (!EOF_seen)
            read_input();

        if (Last_recp == End_recp)  /* if no records were read, ignore run */
            break;

        sort();

        if (!Two_pass)
        {
            if (EOF_seen)
                break;
            else
                init_two_pass();
        }

        write_recs();

        clear_run();

    } while (!EOF_seen);

    Phase = OUTPUT_PHASE;
    review_output_mode();

    if (Two_pass)
        merge_pass();
    else
        write_recs();
    CloseHandle(Output_handle);

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\subst\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=subst
TARGETPATH=obj
TARGETTYPE=PROGRAM

USE_MSVCRT=1

SOURCES=..\subst.cxx   \
        ..\subst.rc

INCLUDES=..\.;                      \
         ..\..\ulib\inc;            \
         ..\..\ifsutil\inc;         \

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

TARGETLIBS=                                        \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib   \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\subst\subst.cxx ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

        subst.cxx

Abstract:

        Utility to associate a path to a drive letter

Author:

        THERESES 12-August-1992

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "path.hxx"
#include "substrng.hxx"
#include "system.hxx"
#include "ulibcl.hxx"
#include "subst.hxx"
#include "dir.hxx"

#include "ntrtl.h"

BOOLEAN
QuerySubstedDrive(
    IN  DWORD   DriveNumber,
    OUT LPWSTR  PhysicalDrive,
    IN  DWORD   PhysicalDriveLength,
    IN  LPDWORD DosError
    );

VOID
DisplaySubstUsage(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine displays the usage for the dos 5 label program.

Arguments:

    Message - Supplies an outlet for the messages.

Return Value:

    None.

--*/
{
    Message->Set(MSG_SUBST_INFO);
    Message->Display("");
    Message->Set(MSG_SUBST_USAGE);
    Message->Display("");
}

BOOLEAN
DeleteSubst(
    IN LPWSTR Drive,
    IN OUT PMESSAGE Message
    )
{
    BOOL    Success;
    FSTRING AuxString;

    DWORD   Status;
    WCHAR   Buffer[ MAX_PATH + 8 ];

    Success = QuerySubstedDrive( *Drive - ( WCHAR )'@',
                                 Buffer,
                                 sizeof( Buffer ) / sizeof( WCHAR ),
                                 &Status );

    if( Success ) {
        Success = DefineDosDevice( DDD_REMOVE_DEFINITION,
                                   Drive,
                                   NULL );
        if( !Success ) {
            Status = GetLastError();
        }
    }
    if (!Success) {
        if( Status == ERROR_ACCESS_DENIED ) {
            AuxString.Initialize( Drive );
            Message->Set(MSG_SUBST_ACCESS_DENIED);
            Message->Display("%W",&AuxString);
        } else {
            AuxString.Initialize( Drive );
            Message->Set(MSG_SUBST_INVALID_PARAMETER);
            Message->Display("%W",&AuxString);
        }
    }
    return Success != FALSE;
}

BOOLEAN
AddSubst(
    IN LPWSTR Drive,
    IN LPWSTR PhysicalDrive,
    IN DWORD PhysicalDriveLength,
    IN OUT PMESSAGE Message
    )
{
    DWORD           Status;
    FSTRING         AuxString;

    WCHAR   Buffer[ MAX_PATH + 8 ];

    if( !QuerySubstedDrive( Drive[0] - '@',
                            Buffer,
                            sizeof( Buffer ) / sizeof( WCHAR ),
                            &Status ) ) {
        if( Status == ERROR_FILE_NOT_FOUND ) {
            if ( wcslen(PhysicalDrive) == 3 &&
                 PhysicalDrive[1] == ':' &&
                 PhysicalDrive[2] == '\\' &&
                 PhysicalDrive[3] == 0 ) {

                UNICODE_STRING      string;

                if ( !RtlDosPathNameToNtPathName_U(PhysicalDrive, &string, NULL, NULL) ) {
                    Status = GetLastError();
                } else {
                    string.Buffer[string.Length/sizeof(string.Buffer[0]) - 1] = 0;
                    if ( !DefineDosDevice(DDD_RAW_TARGET_PATH, Drive, string.Buffer) ) {
                        Status = GetLastError();
                    } else {
                        Status = ERROR_SUCCESS;
                    }
                    RtlFreeUnicodeString(&string);
                }
            } else if( !DefineDosDevice( 0, Drive, PhysicalDrive ) ) {
                Status = GetLastError();
            } else {
                Status = ERROR_SUCCESS;
            }
        }
    } else {
        Status = ERROR_IS_SUBSTED;
    }

    if( Status != ERROR_SUCCESS ) {
        if( Status == ERROR_IS_SUBSTED ) {
            Message->Set(MSG_SUBST_ALREADY_SUBSTED);
            Message->Display("");
        } else if (Status == ERROR_FILE_NOT_FOUND) {
            AuxString.Initialize( PhysicalDrive );
            Message->Set(MSG_SUBST_PATH_NOT_FOUND);
            Message->Display("%W", &AuxString);
        } else if (Status == ERROR_ACCESS_DENIED) {
            AuxString.Initialize( PhysicalDrive );
            Message->Set(MSG_SUBST_ACCESS_DENIED);
            Message->Display("%W", &AuxString);
        } else {
            AuxString.Initialize( Drive );
            Message->Set(MSG_SUBST_INVALID_PARAMETER);
            Message->Display("%W", &AuxString );
        }
        return( FALSE );
    } else {
        return( TRUE );
    }
}

BOOLEAN
QuerySubstedDrive(
    IN  DWORD    DriveNumber,
    OUT LPWSTR   PhysicalDrive,
    IN  DWORD    PhysicalDriveLength,
    IN  LPDWORD  DosError
    )
{
    WCHAR   DriveName[3];
    FSTRING DosDevicesPattern;
    FSTRING DeviceName;
    CHNUM   Position;

    DriveName[0] = ( WCHAR )( DriveNumber + '@' );
    DriveName[1] = ( WCHAR )':';
    DriveName[2] = ( WCHAR )'\0';

    if( QueryDosDevice( DriveName,
                        PhysicalDrive,
                        PhysicalDriveLength ) != 0 ) {
        DosDevicesPattern.Initialize( (LPWSTR)L"\\??\\" );
        DeviceName.Initialize( PhysicalDrive );
        Position = DeviceName.Strstr( &DosDevicesPattern );
        if( Position == 0 ) {
            DeviceName.DeleteChAt( 0, DosDevicesPattern.QueryChCount() );
            *DosError = ERROR_SUCCESS;
            return( TRUE );
        } else {
            //
            //  This is not a Dos device
            //
            *DosError = ERROR_INVALID_PARAMETER;
            return( FALSE );
        }
    } else {
        *DosError = GetLastError();
        return( FALSE );
    }
}

VOID
DumpSubstedDrives (
    IN OUT PMESSAGE Message
    )
{
    DSTRING Source;
    WCHAR LinkBuffer[MAX_PATH + 8];
    DWORD i;
    FSTRING AuxString;
    DWORD   ErrorCode;

    Source.Initialize(L"D:\\");
    Message->Set(MSG_SUBST_SUBSTED_DRIVE);
    for (i=1;i<=MAXIMUM_DRIVES;i++) {
        if (QuerySubstedDrive(i,LinkBuffer,sizeof(LinkBuffer)/sizeof(LinkBuffer[ 0 ]),&ErrorCode)) {
            Source.SetChAt((WCHAR)(i+'@'),0);
            if (wcslen(LinkBuffer) == 2 &&
                LinkBuffer[1] == ':' &&
                LinkBuffer[2] == 0) {
                LinkBuffer[2] = '\\';
                LinkBuffer[3] = 0;
            }
            AuxString.Initialize( LinkBuffer );
            Message->Display("%W%W", &Source, &AuxString);
        }
    }
}

INT
__cdecl
main(
    )
/*++

Routine Description:

    This routine emulates the dos 5 subst command for NT.

Arguments:

    None.

Return Value:

    1   - An error occured.
    0   - Success.

--*/
{
    STREAM_MESSAGE      msg;
    ARGUMENT_LEXEMIZER  arglex;
    ARRAY               lex_array;
    ARRAY               arg_array;
    STRING_ARGUMENT     progname;
    PATH_ARGUMENT       virtualdrive_arg;
    PATH_ARGUMENT       physicaldrive_arg;
    FLAG_ARGUMENT       help_arg;
    FLAG_ARGUMENT       delete_arg;
    PWSTRING            p;
    BOOL                Success=TRUE;


    if (!msg.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream(),
                        Get_Standard_Error_Stream())) {
        return 1;
    }

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return 1;
    }

    if (!arglex.Initialize(&lex_array)) {
        return 1;
    }

    arglex.PutSwitches( "/" );
    arglex.PutStartQuotes( "\"" );
    arglex.PutEndQuotes( "\"" );
    arglex.PutSeparators( " \t" );
    arglex.SetCaseSensitive(FALSE);

    if (!arglex.PrepareToParse()) {
        return 1;
    }

    if ( !arg_array.Initialize() ) {
        return 1;
    }

    if (!progname.Initialize("*") ||
        !help_arg.Initialize("/?") ||
        !virtualdrive_arg.Initialize("*", FALSE) ||
        !physicaldrive_arg.Initialize("*",FALSE) ||
        !delete_arg.Initialize("/D") ) {
        return 1;
    }

    if (!arg_array.Put(&progname) ||
        !arg_array.Put(&virtualdrive_arg) ||
        !arg_array.Put(&physicaldrive_arg) ||
        !arg_array.Put(&help_arg) ||
        !arg_array.Put(&delete_arg) ) {
        return 1;
    }

    if (!arglex.DoParsing(&arg_array)) {
        if (arglex.QueryLexemeCount() > MAXIMUM_SUBST_ARGS) {
            msg.Set(MSG_SUBST_TOO_MANY_PARAMETERS);
            msg.Display("%W", p = arglex.GetLexemeAt(MAXIMUM_SUBST_ARGS));
        } else {
            msg.Set(MSG_SUBST_INVALID_PARAMETER);
            msg.Display("%W", p = arglex.QueryInvalidArgument());
        }
        DELETE(p);
        return 1;
    }

    if (help_arg.QueryFlag()) {
        DisplaySubstUsage(&msg);
        return 0;
    }

    if (delete_arg.IsValueSet() &&
        virtualdrive_arg.IsValueSet() &&
        physicaldrive_arg.IsValueSet()) {
        msg.Set(MSG_SUBST_TOO_MANY_PARAMETERS);
        msg.Display("%W", delete_arg.GetPattern() );
        return 1;
    }

    if (delete_arg.IsValueSet() &&
        !virtualdrive_arg.IsValueSet() &&
        !physicaldrive_arg.IsValueSet()) {
        msg.Set(MSG_SUBST_INVALID_PARAMETER);
        msg.Display("%W", delete_arg.GetPattern());
        return 1;
    }

    //
    //  Validate virtual drive
    //  A virtual drive MUST have the format  <drive letter>:
    //  Anything that doesn't have this format is considered an invalid parameter
    //
    if( virtualdrive_arg.IsValueSet() &&
        ( ( virtualdrive_arg.GetPath()->GetPathString()->QueryChCount() != 2 ) ||
          ( virtualdrive_arg.GetPath()->GetPathString()->QueryChAt( 1 ) != ( WCHAR )':' ) )
      ) {
        msg.Set(MSG_SUBST_INVALID_PARAMETER);
        msg.Display("%W", virtualdrive_arg.GetPath()->GetPathString() );
        return 1;
    }

    //
    //  Validate physical drive
    //  A physical drive CANNOT have the format  <drive letter>:
    //
    if( physicaldrive_arg.IsValueSet() &&
        ( physicaldrive_arg.GetPath()->GetPathString()->QueryChCount() == 2 ) &&
        ( physicaldrive_arg.GetPath()->GetPathString()->QueryChAt( 1 ) == ( WCHAR )':' )
      ) {
        msg.Set(MSG_SUBST_INVALID_PARAMETER);
        msg.Display("%W", physicaldrive_arg.GetPath()->GetPathString() );
        return 1;
    }

//
    if (virtualdrive_arg.IsValueSet()) {
        DSTRING         virtualdrivepath;
        DSTRING         colon;
        PATH            TmpPath;
        PFSN_DIRECTORY  Directory;

        virtualdrivepath.Initialize(virtualdrive_arg.GetPath()->GetPathString());
        if (virtualdrivepath.Strupr() ) {
            if (delete_arg.IsValueSet()) {
                Success = DeleteSubst(virtualdrivepath.QueryWSTR(),&msg);
            } else if (physicaldrive_arg.IsValueSet()) {
                LPWSTR physicaldrivepath;

                //
                // verify that the physical drive is an accessible path
                //
                Directory = SYSTEM::QueryDirectory( physicaldrive_arg.GetPath() );
                if( !Directory ) {
                    msg.Set(MSG_SUBST_PATH_NOT_FOUND);
                    msg.Display("%W", physicaldrive_arg.GetPath()->GetPathString());
                    return 1;
                }
                DELETE( Directory );
                TmpPath.Initialize( physicaldrive_arg.GetPath(), TRUE );
                physicaldrivepath = ( TmpPath.GetPathString() )->QueryWSTR();
                Success = AddSubst(virtualdrivepath.QueryWSTR(),
                                   physicaldrivepath,
                                   ( TmpPath.GetPathString() )->QueryChCount(),
                                   &msg
                                  );
                DELETE(physicaldrivepath);
            } else {
                msg.Set(MSG_SUBST_INVALID_PARAMETER);
                msg.Display("%W", p = arglex.GetLexemeAt(1));
                DELETE(p);
                return 1;
            }
        }
    } else {
        if (arglex.QueryLexemeCount() > 1) {
            msg.Set(MSG_SUBST_INVALID_PARAMETER);
            msg.Display("%W", p = arglex.GetLexemeAt(1));
            DELETE(p);
            return 1;
        } else {
            DumpSubstedDrives(&msg);
        }
    }

    return !Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\tree\tree.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

        tree.cxx

Abstract:

        This module contains the implementation of the TREE class.
        The TREE class implements a tree utility functionally compatible
        with the DOS 5 tree utility.
        This utility displays the directory structure of a path or drive.

        Usage:

                TREE [drive:][path] [/F] [/A] [/?]

                        /F      Display the names of files in each directory.

                        /A      Uses ASCII instead of extended characters.

                        /?      Displays a help message.


Author:

        Jaime F. Sasson - jaimes - 13-May-1991

Environment:

        ULIB, User Mode

--*/

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "substrng.hxx"
#include "dir.hxx"
#include "filter.hxx"
#include "system.hxx"
#include "arrayit.hxx"
#include "smsg.hxx"
#include "stream.hxx"
#include "rtmsg.h"
#include "tree.hxx"

extern "C" {
#include <stdio.h>
#include <string.h>
}


#define UNICODE_SINGLE_LEFT_T               0x251c
#define UNICODE_SINGLE_BOTTOM_LEFT_CORNER   0x2514
#define UNICODE_SINGLE_BOTTOM_HORIZONTAL    0x2500
#define UNICODE_SINGLE_VERTICAL             0x2502
#define UNICODE_SPACE                       0x0020


PSTREAM Get_Standard_Input_Stream();
PSTREAM Get_Standard_Output_Stream();

DEFINE_CONSTRUCTOR( TREE, PROGRAM );


BOOLEAN
TREE::Initialize(
        )

/*++

Routine Description:

        Initializes a TREE class.

Arguments:

        None.

Return Value:

        BOOLEAN - Indicates if the initialization succeeded.


--*/


{
    ARGUMENT_LEXEMIZER  ArgLex;
    ARRAY               LexArray;

    ARRAY               ArgumentArray;

    STRING_ARGUMENT     ProgramNameArgument;
    PATH_ARGUMENT       DirectoryPathArgument;
    PWSTRING            DirectoryNameString;
    PATH                DirectoryNamePath;
    PWSTRING            InvalidArgument;
    PCWSTRING           InvalidPath;
    STRING_ARGUMENT     InvalidSwitch;
    PATH                AuxPath;
    STRING_ARGUMENT     ParamNotCorrectFile;
    STRING_ARGUMENT     ParamNotCorrectAscii;
    STRING_ARGUMENT     ParamNotCorrectHelp;
    BOOLEAN             FlagInvalidPath;
    PATH                AuxInvPath;
    PWSTRING            InvPathNoDrive;
    PWSTRING            Device;
    PATH                DevPth;
    PFSN_DIRECTORY      DevDir;
#ifdef FE_SB
    PWCHAR              BufferMiddleBranch;
    PWCHAR              BufferBottomBranch;
    PWCHAR              BufferConnectingBranch;

    WCHAR               BufferMiddleBranchDBCS[] = {
                                               UNICODE_SINGLE_LEFT_T,            // 2
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL, // 2
                                               UNICODE_NULL                      // 0
                                               };
    WCHAR               BufferBottomBranchDBCS[] = {
                                               UNICODE_SINGLE_BOTTOM_LEFT_CORNER, // 2
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,  // 2
                                               UNICODE_NULL                       // 0
                                               };

    WCHAR               BufferConnectingBranchDBCS[] = {
                                               UNICODE_SINGLE_VERTICAL, // 2
                                               UNICODE_SPACE,           // 1
                                               UNICODE_SPACE,           // 1
                                               UNICODE_NULL             // 0
                                               };

    WCHAR               BufferMiddleBranchSBCS[] = {
                                               UNICODE_SINGLE_LEFT_T,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_NULL
                                               };
    WCHAR               BufferBottomBranchSBCS[] = {
                                               UNICODE_SINGLE_BOTTOM_LEFT_CORNER,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_NULL
                                               };

    WCHAR               BufferConnectingBranchSBCS[] = {
                                               UNICODE_SINGLE_VERTICAL,
                                               UNICODE_SPACE,
                                               UNICODE_SPACE,
                                               UNICODE_SPACE,
                                               UNICODE_NULL
                                               };

    switch ( ::GetConsoleOutputCP() ) {
        case 932:
        case 936:
        case 949:
        case 950:
            BufferMiddleBranch = BufferMiddleBranchDBCS;
            BufferBottomBranch = BufferBottomBranchDBCS;
            BufferConnectingBranch = BufferConnectingBranchDBCS;
            break;

        default:

            BufferMiddleBranch = BufferMiddleBranchSBCS;
            BufferBottomBranch = BufferBottomBranchSBCS;
            BufferConnectingBranch = BufferConnectingBranchSBCS;
            break;
    }
#else

    WCHAR               BufferMiddleBranch[] = {
                                               UNICODE_SINGLE_LEFT_T,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_NULL
                                               };
    WCHAR               BufferBottomBranch[] = {
                                               UNICODE_SINGLE_BOTTOM_LEFT_CORNER,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_SINGLE_BOTTOM_HORIZONTAL,
                                               UNICODE_NULL
                                               };

    WCHAR               BufferConnectingBranch[] = {
                                               UNICODE_SINGLE_VERTICAL,
                                               UNICODE_SPACE,
                                               UNICODE_SPACE,
                                               UNICODE_SPACE,
                                               UNICODE_NULL
                                               };
#endif

    _InitialDirectory = NULL;
    FlagInvalidPath = FALSE;
    _FlagAtLeastOneSubdir = TRUE;
    _StandardOutput = Get_Standard_Output_Stream();

    //
    // Initialize MESSAGE class
    //
    _Message.Initialize( _StandardOutput, Get_Standard_Input_Stream() );

    //
    //      Parse command line
    //
    if ( !LexArray.Initialize( ) ) {
        DebugAbort( "LexArray.Initialize() failed \n" );
        return( FALSE );
    }
    if ( !ArgLex.Initialize( &LexArray ) ) {
        DebugAbort( "ArgLex.Initialize() failed \n" );
        return( FALSE );
    }
    ArgLex.PutSwitches( "/" );
    ArgLex.PutStartQuotes( "\"" );
    ArgLex.PutEndQuotes( "\"" );
    ArgLex.PutSeparators( " \t" );
    ArgLex.SetCaseSensitive( FALSE );

    if( !ArgLex.PrepareToParse() ) {
        DebugAbort( "ArgLex.PrepareToParse() failed \n" );
        return( FALSE );
    }
    if ( !ArgumentArray.Initialize() ) {
        DebugAbort( "ArgumentArray.Initialize() failed \n" );
        return( FALSE );
    }
    if( !ProgramNameArgument.Initialize("*") ||
        !_FlagDisplayFiles.Initialize( "/F" ) ||
        !_FlagUseAsciiCharacters.Initialize( "/A" ) ||
        !_FlagDisplayHelp.Initialize( "/?" ) ||
        !ParamNotCorrectFile.Initialize( "/F*" ) ||
        !ParamNotCorrectAscii.Initialize( "/A*" )       ||
        !ParamNotCorrectHelp.Initialize( "/?*" ) ||
        !InvalidSwitch.Initialize( "/*" ) ||
        !DirectoryPathArgument.Initialize( "*" ) ) {
        DebugAbort( "Unable to initialize flag or string arguments \n" );
        return( FALSE );
    }
    if( !ArgumentArray.Put( &ProgramNameArgument ) ||
        !ArgumentArray.Put( &_FlagDisplayFiles ) ||
        !ArgumentArray.Put( &_FlagUseAsciiCharacters ) ||
        !ArgumentArray.Put( &_FlagDisplayHelp ) ||
        !ArgumentArray.Put( &ParamNotCorrectFile ) ||
        !ArgumentArray.Put( &ParamNotCorrectAscii )  ||
        !ArgumentArray.Put( &ParamNotCorrectHelp ) ||
        !ArgumentArray.Put( &InvalidSwitch ) ||
        !ArgumentArray.Put( &DirectoryPathArgument ) ) {
        DebugAbort( "ArgumentArray.Put() failed \n" );
        return( FALSE );
    }
    if( !ArgLex.DoParsing( &ArgumentArray ) ) {
        InvalidArgument = ArgLex.QueryInvalidArgument();
        DebugPtrAssert( InvalidArgument );
        _Message.Set( MSG_TREE_TOO_MANY_PARAMETERS );
        _Message.Display( "%W", InvalidArgument );
        return( FALSE );
    }
    if( InvalidSwitch.IsValueSet() ) {
        InvalidArgument = InvalidSwitch.GetString();
        DebugPtrAssert( InvalidArgument );
        _Message.Set( MSG_TREE_INVALID_SWITCH );
        _Message.Display( "%W", InvalidArgument );
        return( FALSE );
    }
    if( ParamNotCorrectFile.IsValueSet() ) {
        InvalidArgument = ParamNotCorrectFile.GetLexeme();
        DebugPtrAssert( InvalidArgument );
        _Message.Set( MSG_TREE_PARAMETER_NOT_CORRECT );
        _Message.Display( "%W", InvalidArgument );
        return( FALSE );
    }
    if( ParamNotCorrectAscii.IsValueSet() ) {
        InvalidArgument = ParamNotCorrectAscii.GetLexeme();
        DebugPtrAssert( InvalidArgument );
        _Message.Set( MSG_TREE_PARAMETER_NOT_CORRECT );
        _Message.Display( "%W", InvalidArgument );
        return( FALSE );
    }
    if( ParamNotCorrectHelp.IsValueSet() ) {
        InvalidArgument = ParamNotCorrectHelp.GetLexeme();
        DebugPtrAssert( InvalidArgument );
        _Message.Set( MSG_TREE_PARAMETER_NOT_CORRECT );
        _Message.Display( "%W", InvalidArgument );
        return( FALSE );
    }


    //
    //      Displays help message if /? was found in the command line
    //
    if( _FlagDisplayHelp.QueryFlag() ) {
        _Message.Set( MSG_TREE_HELP_MESSAGE );
        _Message.Display( " " );
        return( FALSE );
    }

    //
    //      Find initial directory
    //
    if( !DirectoryPathArgument.IsValueSet() ) {
        //
        // User did't specify a path, so assume current directory
        //
        _FlagPathSupplied = FALSE;

        if (!DirectoryNamePath.Initialize((LPWSTR)L".", TRUE )) {

            DebugAbort( "DirectoryNamePath.Initialize() failed \n" );
            return( FALSE );
        }

    } else {
        //
        // User specified a path
        //

        DirectoryNameString = DirectoryPathArgument.GetPath()->QueryFullPathString();
        DebugPtrAssert( DirectoryNameString );
        DirectoryNameString->Strupr();

        if (!DirectoryNamePath.Initialize(DirectoryNameString, TRUE)) {
            DebugAbort( "DirectoryNamePath.Initialize() failed \n" );
            return( FALSE );
        }

        //
        // Save the path specified by the user as he/she typed it
        // (but in upper case)
        //
        if( !AuxPath.Initialize( DirectoryNameString, FALSE ) ) {
            DebugAbort( "AuxPath.Initialize() failed \n" );
            return( FALSE );
        }

        //
        // Validate the device if one was supplied
        // AuxPath represents the path as typed by the user, and
        // it may or may not contain a device. If it doesn't contain
        // a device, no verification is made. In this case and we are
        // sure that the device is valid
        //
        if( ( Device = AuxPath.QueryDevice() ) != NULL ) {
            if( !DevPth.Initialize( Device ) ) {
                DebugAbort( "DevPth.Initialize() failed \n" );
                return( FALSE );
            }
            if( !(DevDir = SYSTEM::QueryDirectory( &DevPth ) ) ) {
                _Message.Set( MSG_TREE_INVALID_DRIVE );
                _Message.Display( " " );
                DELETE( Device );
                return( FALSE );
            }
            DELETE( Device );
            DELETE( DevDir );
        }

        //
        // Find out if what the user specified is just a drive
        //
        if( AuxPath.IsDrive() ) {
            _FlagPathSupplied = FALSE;
        } else {
            _FlagPathSupplied = TRUE;
        }
    }

    if (NULL == (_InitialDirectory = SYSTEM::QueryDirectory( &DirectoryNamePath ))) {

        InvalidPath = DirectoryNamePath.GetPathString();
        FlagInvalidPath = TRUE;
        _FlagAtLeastOneSubdir = FALSE;
    }

    //
    //      Initialize filter for directories
    //

    if( !_FsnFilterDirectory.Initialize() ) {
        DELETE( _InitialDirectory );
        DebugAbort( "_FsnFilterDirectory.Initialize() failed \n" );
        return( FALSE );
    }
    if( !_FsnFilterDirectory.SetFileName( "*.*" ) ) {
        DELETE( _InitialDirectory );
        DebugAbort( "_FsnFilterDirectory.SetFilename() failed \n" );
        return( FALSE );
    }
    if( !_FsnFilterDirectory.SetAttributes( FSN_ATTRIBUTE_DIRECTORY,
                                            ( FSN_ATTRIBUTE )0,
                                            FSN_ATTRIBUTE_HIDDEN |
                                            FSN_ATTRIBUTE_SYSTEM ) ) {
        DELETE( _InitialDirectory );
        DebugAbort( "_FsnFilterDirectory.SetAttributes() failed \n" );
        return( FALSE );
    }

    //
    //      Initilize filter for files
    //

    if( _FlagDisplayFiles.QueryFlag() ) {
        if( !_FsnFilterFile.Initialize() ) {
            DELETE( _InitialDirectory );
            DebugAbort( "FsnFilter.Initialize() failed \n" );
            return( FALSE );
        }
        if( !_FsnFilterFile.SetFileName( "*.*" ) ) {
            DELETE( _InitialDirectory );
            DebugAbort( "FsnFilter.SetFilename() failed \n" );
            return( FALSE );
        }
        if( !_FsnFilterFile.SetAttributes( ( FSN_ATTRIBUTE )0,
                                           ( FSN_ATTRIBUTE )0,
                                           FSN_ATTRIBUTE_DIRECTORY |
                                           FSN_ATTRIBUTE_HIDDEN |
                                           FSN_ATTRIBUTE_SYSTEM ) ) {
            DELETE( _InitialDirectory );
            DebugAbort( "FsnFilter.SetAttributes() failed \n" );
            return( FALSE );
        }
    }

    //
    //      Find out what kind of characters should be used to display the tree
    //      and initialize the basic strings
    //
    if( _FlagUseAsciiCharacters.QueryFlag() ) {

        _StringForDirectory.Initialize( (LPWSTR)L"+---" );
        _StringForLastDirectory.Initialize( (LPWSTR)L"\\---" );
        _StringForFile.Initialize( (LPWSTR)L"|   " );

    } else {

        _StringForDirectory.Initialize( BufferMiddleBranch );        //  ""
        _StringForLastDirectory.Initialize( BufferBottomBranch );    //  ""
        _StringForFile.Initialize( BufferConnectingBranch );         //  "   "

    }
    _StringForFileNoDirectory.Initialize( (LPWSTR)L"    " );

    if( !_EndOfLineString.Initialize( (LPWSTR)L"\r\n" ) ) {
        DebugPrint( "_EndOfLineString.Initialize() failed" );
        DELETE( _InitialDirectory );
        return( FALSE );
    }

    _VolumeName = SYSTEM::QueryVolumeLabel( &DirectoryNamePath, &_SerialNumber );
    if (NULL == _VolumeName) {
        _Message.Set( MSG_TREE_INVALID_DRIVE );
        _Message.Display( " " );
        DELETE( Device );
        return( FALSE );
    }
    DebugPtrAssert( _VolumeName );
    _FlagAtLeastOneSubdir = FALSE;
    if( FlagInvalidPath ) {
        //
        //      If user specified an invalid path, then display the same
        //      messages that Dos 5 does.
        //
        //      First displays the volume info.
        //

        DisplayVolumeInfo();

        //
        //      Then display the path that is invalid. This path must be
        //      displayed in capital letters, must always contain a device,
        //      and must be displayed as a relative or absolute path depending
        //      on what the user specified.
        //
        Device = DirectoryNamePath.QueryDevice();
        AuxInvPath.Initialize( DirectoryNameString, FALSE );
        InvPathNoDrive = AuxInvPath.QueryDirsAndName();
        _StandardOutput->WriteString( Device );
        _StandardOutput->WriteString( InvPathNoDrive );
        _StandardOutput->WriteByte( '\r' );
        _StandardOutput->WriteByte( '\n' );

        //
        //      Display the message "Invalid Path - <path>"
        //      The path in this case cannot contain a drive even if the
        //      user specified a drive.
        //
        _Message.Set( MSG_TREE_INVALID_PATH );
        _Message.Display( "%W", InvPathNoDrive );
        DELETE( Device );
        DELETE( InvPathNoDrive );
        return( FALSE );
    }
    return( TRUE );
}


VOID
TREE::Terminate(
        )

/*++

Routine Description:

        Deletes objects created during initialization.

Arguments:

        None.

Return Value:

        None.


--*/

{
        if( _InitialDirectory != NULL ) {
                DELETE( _InitialDirectory );
        }
        if( !_FlagAtLeastOneSubdir ) {
                _Message.Set( MSG_TREE_NO_SUBDIRECTORIES );
                _Message.Display( "%s", "\r\n" );
        }

}




BOOLEAN
TREE::DisplayName (
        IN PCFSNODE     Fsn,
        IN PCWSTRING    String
        )

/*++

Routine Description:

        This method writes to the standard output the name of a file or
        directory, preceded by a string that represents pieces of the
        tree structure (pieces of the tree branches).

Arguments:

        Fsn - Pointer to a FSNODE that describes the file or directory whose
                  name is to be written.

        String - Pointer to a WSTRING object that contains the string to
                         be written before the file or directory name.

Return Value:

        BOOLEAN - returns TRUE to indicate that the operation succeeded, or
                          FALSE otherwise.

--*/


{
    PWSTRING                Name;
    PCPATH                  Path;
    PCWSTRING               InitialDirectory;
    DSTRING                 InitialDirectoryUpperCase;
    PWSTRING                Device;
    DSTRING                 EndOfLinePrecededByDot;

        DebugPtrAssert( Fsn );

        Path = Fsn->GetPath();
        DebugPtrAssert( Path );
        if( String != NULL ) {
                if( !_StandardOutput->WriteString( String, 0, String->QueryChCount() ) ) {
                        DebugAbort( "_StandardOutput->WriteString() failed \n" );
                        return( FALSE );
                }
                if( ( Name=Path->QueryName() ) == NULL ) {
                        DebugAbort( "Path->QueryName() failed \n" );
                        return( FALSE );
                }
                Name->Strcat( &_EndOfLineString );

                if( !_StandardOutput->WriteString( Name, 0, Name->QueryChCount() ) ) {
                        DebugAbort( "_StandardOutput->WriteString() failed \n" );
                        DELETE( Name );
                        return( FALSE );
                }

                DELETE( Name );
        } else {
                if( _FlagPathSupplied ) {
                        InitialDirectory = Path->GetPathString();
                        DebugPtrAssert( InitialDirectory );
                        InitialDirectoryUpperCase.Initialize( InitialDirectory );
                        InitialDirectoryUpperCase.Strupr();
                        InitialDirectoryUpperCase.Strcat( &_EndOfLineString );
                        if( !_StandardOutput->WriteString( &InitialDirectoryUpperCase ) ) {
                                DebugAbort( "_StandardOutput->WriteString() failed \n" );
                                return( FALSE );
                        }
                } else {
                        Device = PPATH(Path)->QueryDevice();
                        if (Device == NULL) {
                            DebugAbort("TREE: Path->QueryDevice() failed\n");
                            return FALSE;
                        }
                        DebugPtrAssert( Device );
                        EndOfLinePrecededByDot.Initialize( (LPWSTR)L".\r\n" );
                        Device->Strcat( &EndOfLinePrecededByDot );
                        if( !_StandardOutput->WriteString( Device, 0, TO_END ) ) {
                                DebugAbort( "_StandardOutput->WriteString() failed \n" );
                                DELETE( Device );
                                return( FALSE );
                        }
                        DELETE( Device );
                }
        }
        return( TRUE );
}


VOID
TREE::DisplayVolumeInfo (
        )

/*++

Routine Description:

        This method writes to the standard output the the volume name (if one
        is found) and the serial number.

Arguments:

        None.


Return Value:

        None.

--*/

{
        //
        //      Display volume name
        //
        if( _VolumeName->QueryChCount() == 0 ) {
                _Message.Set( MSG_TREE_DIR_LISTING_NO_VOLUME_NAME );
                _Message.Display( " " );
        } else {
                _Message.Set( MSG_TREE_DIR_LISTING_WITH_VOLUME_NAME );
                _Message.Display( "%W", _VolumeName );
        }

        //
        //      Display serial number
        //
        if( _SerialNumber.HighOrder32Bits != 0 ) {
                _Message.Set( MSG_TREE_64_BIT_SERIAL_NUMBER );
                _Message.Display( "%08X%04X%04X",
                                                  _SerialNumber.HighOrder32Bits,
                                                  _SerialNumber.LowOrder32Bits >> 16,
                                                  ( _SerialNumber.LowOrder32Bits << 16 ) >> 16);
        } else {
                _Message.Set( MSG_TREE_32_BIT_SERIAL_NUMBER );
                _Message.Display( "%04X%04X",
                                                  _SerialNumber.LowOrder32Bits >> 16,
                                                  ( _SerialNumber.LowOrder32Bits << 16 ) >> 16 );
        }
}


BOOLEAN
TREE::ExamineDirectory(
        IN      PCFSN_DIRECTORY Directory,
        IN      PCWSTRING       String
        )

/*++

Routine Description:

        Displays all files and subdirectories in the directory whose
        FSN_DIRECTORY was received as parameter.


Arguments:

        Directory - Pointer to an FSN_DIRECTORY that describes the
                                directory to be examined

        String    - Pointer to a WSTRING that contains part of the string
                                to be written in the left side of each subdiretory name
                                and file name found in the directory being examined
                                (the one whose FSN_DIRECTORY was received as parameter)

Return Value:

        BOOLEAN - Returns TRUE to indicate that the operation succeded.
                          Returns FALSE otherwise.

--*/

{
        PARRAY                          DirectoryArray;
        PFSN_DIRECTORY          FsnDirectory;
        PARRAY_ITERATOR         DirectoryArrayIterator;
        PARRAY                          FileArray;
        PARRAY_ITERATOR         FileArrayIterator;
        PFSNODE                         FsnFile;
#if 0
        PWSTRING                        StringFile;
#endif
#if 0
        PWSTRING                        StringDir;
        PWSTRING                        StringLastDir;
        PWSTRING                        StringSon;
        PWSTRING                        StringLastSon;
#endif
        DSTRING                        StringFile;
        DSTRING                        StringDir;
        DSTRING                        StringLastDir;
        DSTRING                        StringSon;
        DSTRING                        StringLastSon;

        DebugPtrAssert( Directory );

        //
        //      Build list of directories (ie., an array of PFSN_DIRECTORY of all
        //      sub-directories in the current directory
        //
        DirectoryArray = Directory->QueryFsnodeArray( &_FsnFilterDirectory );
        DebugPtrAssert( DirectoryArray );
        DirectoryArrayIterator =
                        ( PARRAY_ITERATOR )( DirectoryArray->QueryIterator() );
        DebugPtrAssert( DirectoryArrayIterator );

        //
        // If files are to be displayed (/F in the command line), then build
        // an array of files (ie., an array of PFSNODEs of all files in the
        // current directory)
        //
        if( _FlagDisplayFiles.QueryFlag() ) {
                FileArray = Directory->QueryFsnodeArray( &_FsnFilterFile );
                DebugPtrAssert( FileArray );
                FileArrayIterator =
                                ( PARRAY_ITERATOR )( FileArray->QueryIterator() );
                DebugPtrAssert( FileArrayIterator );

        //
        //  If array of files is not empty, then we need the strings
        //  to be displayed in the left side of file names. These strings
        //  will contain the pieces of the branches of the tree diagram.
        //  These strings for files are created here.
        //
        if( FileArray->QueryMemberCount() > 0 ) {
#if 0
            StringFile = NEW( DSTRING );
            DebugPtrAssert( StringFile );
#endif
            if( DirectoryArray->QueryMemberCount() > 0 ) {
                if( String == NULL ) {
                    StringFile.Initialize( &_StringForFile );
                } else {
                    StringFile.Initialize( String );
                    StringFile.Strcat( &_StringForFile );
                }
            } else {
                if( String == NULL ) {
                    StringFile.Initialize( &_StringForFileNoDirectory );
                } else {
                    StringFile.Initialize( String );
                    StringFile.Strcat( &_StringForFileNoDirectory );
                }
            }

            //
            //      Display all file names
            //
            while( ( FsnFile = ( PFSNODE )( FileArrayIterator->GetNext( ) ) ) != NULL ) {
                DisplayName( FsnFile, &StringFile );
                DELETE( FsnFile );
            }

            //
            // Display an empty line after the last file
            //
            _StandardOutput->WriteString( &StringFile, 0, StringFile.QueryChCount() );
            _StandardOutput->WriteString( &_EndOfLineString, 0, _EndOfLineString.QueryChCount() );

            }
            DELETE( FileArrayIterator );
            DELETE( FileArray );
        }

    //
    //  If list of directories is not empty
    //
    if( DirectoryArray->QueryMemberCount() > 0 ) {
        _FlagAtLeastOneSubdir = TRUE;
        //
        //  Build strings to be printed before directory name
        //
        if( String == NULL ) {
            StringDir.Initialize( &_StringForDirectory );
            StringLastDir.Initialize( &_StringForLastDirectory );
            StringSon.Initialize( &_StringForFile );
            StringLastSon.Initialize( &_StringForFileNoDirectory );
        } else {
            StringDir.Initialize( String );
            StringDir.Strcat( &_StringForDirectory );
            StringLastDir.Initialize( String );
            StringLastDir.Strcat( &_StringForLastDirectory );
            StringSon.Initialize( String );
            StringSon.Strcat( &_StringForFile );
            StringLastSon.Initialize( String );
            StringLastSon.Strcat( &_StringForFileNoDirectory );
        }
        //
        //  Display name of all directories, and examine each one of them
        //
        while( ( FsnDirectory = ( PFSN_DIRECTORY )( DirectoryArrayIterator->GetNext( ) ) ) != NULL ) {
            if( DirectoryArrayIterator->QueryCurrentIndex() != DirectoryArray->QueryMemberCount() - 1 ) {
                DisplayName( ( PCFSNODE )FsnDirectory, &StringDir );
                ExamineDirectory( FsnDirectory, &StringSon );
            } else {
                DisplayName( ( PCFSNODE )FsnDirectory, &StringLastDir );
                ExamineDirectory( FsnDirectory, &StringLastSon );
            }
            DELETE( FsnDirectory );
        }
    }
    DELETE( DirectoryArrayIterator );
    DELETE( DirectoryArray );
    return( TRUE );
}



ULONG __cdecl
main()

{
        DEFINE_CLASS_DESCRIPTOR( TREE );

        {
                TREE    Tree;
                PCFSN_DIRECTORY         Directory;

                if( Tree.Initialize() ) {
                        Tree.DisplayVolumeInfo();
                        //
                        //      Display directory name
                        //
                        Directory = Tree.GetInitialDirectory();
                        Tree.DisplayName( ( PCFSNODE )Directory, ( PCWSTRING )NULL );
                        Tree.ExamineDirectory( Directory, ( PCWSTRING )NULL );
                }
                Tree.Terminate();
        }
        return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\cluster.cxx ===
#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"


#include "cmem.hxx"

extern "C" {
#ifdef DBLSPACE_ENABLED
#include "mrcf.h"
#endif // DBLSPACE_ENABLED
#include "ntrtl.h"
}

extern VOID DoInsufMemory(VOID);

DEFINE_EXPORTED_CONSTRUCTOR( CLUSTER_CHAIN, OBJECT, UFAT_EXPORT );

VOID
CLUSTER_CHAIN::Construct (
    )
/*++

Routine Description:

    Constructor for CLUSTER_CHAIN which initializes private data to
    default values.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _secruns = NULL;
    _num_secruns = 0;
    _length_of_chain = 0;
    _is_compressed = FALSE;
    _buf = NULL;
    _drive = NULL;
    _fat_sa = NULL;
    _secrun = NULL;
}

UFAT_EXPORT
CLUSTER_CHAIN::~CLUSTER_CHAIN(
    )
/*++

Routine Description:

    Destructor for CLUSTER_CHAIN.  Frees memory and returns references.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
CLUSTER_CHAIN::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PFAT_SA             FatSuperArea,
    IN      PCFAT               Fat,
    IN      ULONG               ClusterNumber,
    IN      ULONG               LengthOfChain
    )
/*++

Routine Description:

    Prepares the CLUSTER_CHAIN object for reads and writes to disk.
    The length of the cluster chain may be specified by the
    LengthOfChain argument.  Setting this parameter to 0 will cause
    the length of the chain to be until the end of file.

Arguments:

    Mem             - Supplies memory for the cluster object.
    Drive           - Supplies the drive to which reads and writes will
                        take place.
    FatSuperArea    - Supplies the FAT super area which contains information
                        about the current FAT implementation.
    Fat             - Supplies the file allocation table for this drive.
    ClusterNumber   - Supplies the cluster number to map.
    LengthOfChain   - Supplies the number of clusters in the chain.
                        This value defaults to 0 which indicates that all
                        clusters until end of file will be addressed.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONT_MEM    cmem;
    SECTORCOUNT sec_per_clus;
    ULONG       clus;
    LONG        size;
    PVOID       buf;
    ULONG       i, j;
    LBN         lbn;

    Destroy();

    if (!Mem ||
        !Drive ||
        !FatSuperArea ||
        !Fat ||
        !Fat->IsInRange(ClusterNumber)) {
        Destroy();
        return FALSE;
    }

    if (LengthOfChain) {
        _length_of_chain = LengthOfChain;
    } else {
        _length_of_chain = Fat->QueryLengthOfChain(ClusterNumber);
    }

    if (!_length_of_chain) {
        Destroy();
        return FALSE;
    }

    sec_per_clus = FatSuperArea->QuerySectorsPerCluster();
    size = sec_per_clus*Drive->QuerySectorSize()*_length_of_chain;

    _is_compressed = FatSuperArea->IsCompressed();
    _fat_sa = FatSuperArea;

#ifdef DBLSPACE_ENABLED
    if (_is_compressed) {

        _fat = Fat;
        _drive = Drive;
        _starting_cluster = ClusterNumber;
        if (!(_secrun = NEW SECRUN)) {
            Destroy();
	    DoInsufMemory();
            return FALSE;
        }
        // This buf will hold the cluster chain's uncompressed data.
        if (!(_buf = (PUCHAR)Mem->Acquire(size, Drive->QueryAlignmentMask()))) {
            Destroy();
	    DoInsufMemory();
            return FALSE;
        }
        if (!_hmem.Initialize()) {
            Destroy();
	    DoInsufMemory();
            return FALSE;
        }
        return TRUE;
    
    }
#endif // DBLSPACE_ENABLED

    if (!(_secruns = (PSECRUN*) MALLOC(_length_of_chain*sizeof(PSECRUN)))) {
        Destroy();
	DoInsufMemory();
        return FALSE;
    }

    if (!(buf = Mem->Acquire(size, Drive->QueryAlignmentMask())) ||
        !cmem.Initialize(buf, size)) {
        
        Destroy();
	DoInsufMemory();
        return FALSE;
    }


    clus = ClusterNumber;
    i = 0;
    for (;;) {
        lbn = _fat_sa->QuerySectorFromCluster(clus);

        for (j = 1; !Fat->IsEndOfChain(clus) &&
                    (clus + 1) == Fat->QueryEntry(clus) &&
                    i + j < _length_of_chain; j++) {
            clus++;
        }
        i += j;

        if (!(_secruns[_num_secruns] = NEW SECRUN)) {
            Destroy();
	    DoInsufMemory();
            return FALSE;
        }

        if (!_secruns[_num_secruns]->Initialize(&cmem, Drive, lbn,
                                                j*sec_per_clus)) {
            Destroy();
	    DoInsufMemory();
            return FALSE;
        }

        _num_secruns++;

        if (i == _length_of_chain) {
            break;
        }

        clus = Fat->QueryEntry(clus);
        if (!Fat->IsInRange(clus)) {
            Destroy();
            return FALSE;
        }
    }

    return TRUE;
}


UFAT_EXPORT
BOOLEAN
CLUSTER_CHAIN::Read(
    )
/*++

Routine Description:

    This routine reads the cluster chain into memory.  This is done
    by making repetitive use of SECRUN's Read routine.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       i;
    BOOLEAN     b = TRUE;
    ULONG       clus;
    LBN         lbn;
    UCHAR       nsec;
#ifdef DBLSPACE_ENABLED
    MRCF_DECOMPRESS
                wkspc;
#endif // DBLSPACE_ENABLED
    ULONG       u;
    ULONG       cluster_size;
    ULONG       sector_size;

    if (!_is_compressed) {

        if (!_secruns) {
            return FALSE;
        }

        for (i = 0; i < _num_secruns; i++) {

            b = (BOOLEAN)(_secruns[i]->Read() && b);
        }

        return b;
    }

#ifdef DBLSPACE_ENABLED
    //
    // The volume is compressed.
    //

    sector_size = _drive->QuerySectorSize();
    cluster_size = sector_size * _fat_sa->QuerySectorsPerCluster();

    clus = _starting_cluster;

    i = 0;
    for (;;) {

        lbn = _fat_sa->QuerySectorFromCluster(clus, &nsec);

        if (!_secrun->Initialize(&_hmem, _drive, lbn, nsec)) {
	    DoInsufMemory();
            return FALSE;
        }

        if (!_secrun->Read()) {
            return FALSE;
        }

        if (_fat_sa->IsClusterCompressed(clus)) {

            RtlZeroMemory(&_buf[i * sector_size], cluster_size);

            u = MrcfDecompress(&_buf[i * sector_size],
                _fat_sa->QuerySectorsRequiredForPlainData(clus) * sector_size,
                (PUCHAR)_secrun->GetBuf(),
                nsec * sector_size, &wkspc);

            if (0 == u) {
                // error: can't decompress data
                return TRUE;
            }

        } else {

            // This cluster isn't compressed; just copy.

            memcpy(&_buf[i * cluster_size], _secrun->GetBuf(), cluster_size);
        }

        if (++i == _length_of_chain) {
            return TRUE;
        }

        clus = _fat->QueryEntry(clus);
        if (!_fat->IsInRange(clus)) {
            return FALSE;
        }
    }

    //NOTREACHED
#endif // DBLSPACE_ENABLED
    return FALSE;
}


UFAT_EXPORT
BOOLEAN
CLUSTER_CHAIN::Write(
    )
/*++

Routine Description:

    This routine writes the cluster chain to disk.  This is done
    by making repetitive use of SECRUN's Write routine.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       i;
    BOOLEAN     b = TRUE;
    UCHAR       nsec, new_nsec;
    ULONG       clus;
    LBN         lbn;
#ifdef DBLSPACE_ENABLED
    MRCF_STANDARD_COMPRESS
                wkspc;
#endif // DBLSPACE_ENABLED
    ULONG       cluster_size;
    ULONG       sector_size;
    ULONG       u;
    HMEM        work_buf;

    if (!_is_compressed) {
        
       if (!_secruns) {
          return FALSE;
       }
       for (i = 0; i < _num_secruns; i++) {
          b = (BOOLEAN)(_secruns[i]->Write() && b);
       }   
       return b;
    }

#ifdef DBLSPACE_ENABLED
    //
    // The volume is compressed.
    //

    sector_size = _drive->QuerySectorSize();
    cluster_size = _fat_sa->QuerySectorsPerCluster() * sector_size;

    if (!work_buf.Initialize() ||
        !work_buf.Acquire(cluster_size, _drive->QueryAlignmentMask())) {
	DoInsufMemory();
        return FALSE;
    }

    clus = _starting_cluster;
    i = 0;
    for (;;) {
        lbn = _fat_sa->QuerySectorFromCluster(clus, &nsec);

        u = MrcfStandardCompress((PUCHAR)work_buf.GetBuf(), cluster_size,
            &_buf[i * cluster_size], cluster_size, &wkspc);
        if (0 == u) {
            // the data could not be compressed

            if (nsec < _fat_sa->QuerySectorsPerCluster()) {

                //
                // previously the data had been compressed; need to allocate
                // more disk space.
                //

                nsec = _fat_sa->QuerySectorsPerCluster();
                _fat_sa->FreeClusterData(clus);
                if (!_fat_sa->AllocateClusterData(clus, nsec, FALSE,
                    _fat_sa->QuerySectorsPerCluster())) {
                    // error: no space
                    return FALSE;
                }
                lbn = _fat_sa->QuerySectorFromCluster(clus);
            }
            DbgAssert(nsec == _fat_sa->QuerySectorsPerCluster());

            _fat_sa->SetClusterCompressed(clus, FALSE);

        } else {
            
           new_nsec = (u + sector_size - 1)/sector_size;

           if (new_nsec != nsec) {

              //
              // The data has been changed, and it won't compress into
              // the same size as it used to.
              //
              _fat_sa->FreeClusterData(clus);
              if (!_fat_sa->AllocateClusterData(clus, new_nsec, TRUE,
                                                _fat_sa->QuerySectorsPerCluster())) {

                 // error: not enough free space
                 return FALSE;
              }
              lbn = _fat_sa->QuerySectorFromCluster(clus, &nsec);
            
           } else {

                //
                // The cluster may not have been compressed before,
                // but we still need the same amount of space even though
                // it's now compressed.
                //
                _fat_sa->SetClusterCompressed(clus, TRUE);
            }
        }

	if (!_hmem.Initialize()) {
	    DoInsufMemory();
            return FALSE;
	}
        if (!_secrun->Initialize(&_hmem, _drive, lbn, nsec)) {
	    DoInsufMemory();
            return FALSE;
        }

        memcpy(_secrun->GetBuf(), work_buf.GetBuf(),
            nsec * sector_size);

        b = (BOOLEAN)(_secrun->Write() && b);

        if (++i == _length_of_chain) {
            return b;
        }

        clus = _fat->QueryEntry(clus);
        if (!_fat->IsInRange(clus)) {
            return FALSE;
        }
    }

    //NOTREACHED
#endif // DBLSPACE_ENABLED
    return FALSE;
}


VOID
CLUSTER_CHAIN::Destroy(
    )
/*++

Routine Description:

    This routine cleans up the objects internal components.  It does not
    need to be called before Init as Init does this automatically.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG i;

#ifdef DBLSPACE_ENABLED
    if (_is_compressed) {
        DELETE(_secrun);
        _num_secruns = 0;
        _length_of_chain = 0;
        _buf = NULL;
        _drive = NULL;
        return;
    }
#endif // DBLSPACE_ENABLED

    for (i = 0; i < _num_secruns; i++) {
        DELETE(_secruns[i]);
    }

    DELETE(_secruns);
    _num_secruns = 0;
    _length_of_chain = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\inc\mrcf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Mrcf.h

Abstract:

    This module defines all of the double space compression routines

Author:

    Gary Kimura     [GaryKi]    03-Jun-1993

Revision History:

--*/

#ifndef _MRCF_
#define _MRCF_

//
//  To decompress/compress a block of data the user needs to
//  provide a work space as an extra parameter to all the exported
//  procedures.  That way the routines will not need to use excessive
//  stack space and will still be multithread safe
//

//
//  Variables for reading and writing bits
//

typedef struct _MRCF_BIT_IO {

    USHORT  abitsBB;        //  16-bit buffer being read
    LONG    cbitsBB;        //  Number of bits left in abitsBB

    PUCHAR  pbBB;           //  Pointer to byte stream being read
    ULONG   cbBB;           //  Number of bytes left in pbBB
    ULONG   cbBBInitial;    //  Initial size of pbBB

} MRCF_BIT_IO;
typedef MRCF_BIT_IO *PMRCF_BIT_IO;

//
//  Decompression only needs the bit i/o structure
//

typedef struct _MRCF_DECOMPRESS {

    MRCF_BIT_IO BitIo;

} MRCF_DECOMPRESS;
typedef MRCF_DECOMPRESS *PMRCF_DECOMPRESS;

//
//  Standard compression uses a few more field to contain
//  the lookup table
//

#define cMAXSLOTS   (8)             //  The maximum number of slots used in the algorithm

#define ltUNUSED    (0xE000)        //  Value of unused ltX table entry
#define mruUNUSED   (0xFF)          //  Value of unused MRU table entry
#define bRARE       (0xD5)          //  Rarely occuring character value

typedef struct _MRCF_STANDARD_COMPRESS {

    MRCF_BIT_IO BitIo;

    ULONG   ltX[256][cMAXSLOTS];    //  Source text pointer look-up table
    UCHAR   abChar[256][cMAXSLOTS]; //  Character look-up table
    UCHAR   abMRUX[256];            //  Most Recently Used ltX/abChar entry

} MRCF_STANDARD_COMPRESS;
typedef MRCF_STANDARD_COMPRESS *PMRCF_STANDARD_COMPRESS;

ULONG
MrcfDecompress (
    PUCHAR UncompressedBuffer,
    ULONG UncompressedLength,
    PUCHAR CompressedBuffer,
    ULONG CompressedLength,
    PMRCF_DECOMPRESS WorkSpace
    );

ULONG
MrcfStandardCompress (
    PUCHAR CompressedBuffer,
    ULONG CompressedLength,
    PUCHAR UncompressedBuffer,
    ULONG UncompressedLength,
    PMRCF_STANDARD_COMPRESS WorkSpace
    );

#endif // _MRCF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\eaheader.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    eaheader.cxx

Abstract:

    This class models the header and tables of the EA file.

Author:

    Norbert P. Kusters (norbertk) 28-Nov-90

Notes:

    Luckily all the structures are well aligned.

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( EA_HEADER, CLUSTER_CHAIN, UFAT_EXPORT );

VOID
EA_HEADER::Construct (
        )
/*++

Routine Description:

        Constructor for EA_HEADER.  Initializes private data to default values.

Arguments:

        None.

Return Value:

        None.

--*/
{
   _ht = NULL;
   _off_tab_size = 0;
}


UFAT_EXPORT
EA_HEADER::~EA_HEADER(
    )
/*++

Routine Description:

    Destructor for EA_HEADER.  Frees memory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
EA_HEADER::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PFAT_SA             FatSuperArea,
    IN      PCFAT               Fat,
    IN      ULONG               StartingCluster,
    IN      ULONG               LengthOfChain
    )
/*++

Routine Description:

    This routine prepares this object for reads and writes.  It also
    prepares the object with memory so that it can accept queries.

    If the length of the cluster chain is not specified this routine
    will read in the first cluster in order to compute the actual
    length of the cluster chain.

Arguments:

    Mem             - Supplies the memory for the cluster chain.
    Drive           - Supplies the drive that contains the EA file.
    FatSuperArea    - Supplies information about the FAT file system.
    Fat             - Supplies the file allocation table.
    StartingCluster - Supplies the first cluster of the EA file.
    LengthOfChain   - Supplies the number of clusters necessary to contain
                      the EA file header, base table and offset table.

Return Value:

    FALSE   - Initialization failed.
    TRUE    - Initialization succeeded.

--*/
{
    HMEM    hmem;
    INT     i;

    Destroy();

    // See if the length of the chain needs to be computed.
    if (!LengthOfChain) {
        if (!hmem.Initialize() ||
            !CLUSTER_CHAIN::Initialize(&hmem, Drive, FatSuperArea, Fat,
                                       StartingCluster, 1) ||
            !(_ht = (PEA_HEADER_AND_TABLE) GetBuf()) ||
            !CLUSTER_CHAIN::Read() ||
            !(_ht->Header.Signature == HeaderSignature) ||
            !(_ht->Header.FormatType == 0) ||
            !(_ht->Header.LogType == 0)) {

           DebugPrintTrace(("UFAT: Failure to initialize EA_HEADER %d\n", 1));
           Destroy();
           return FALSE;

        }
        for (i = 0; i < BaseTableSize && !_ht->Table.BaseTab[i]; i++) {
        }
        if (i == BaseTableSize) {

           DebugPrintTrace(("UFAT: Failure to initialize EA_HEADER %d\n", 2));
           Destroy();
           return FALSE;

        }
        LengthOfChain = _ht->Table.BaseTab[i];
    }

    if (!CLUSTER_CHAIN::Initialize(Mem, Drive, FatSuperArea, Fat,
                                   StartingCluster, LengthOfChain) ||
        !(_ht = (PEA_HEADER_AND_TABLE) GetBuf())) {

        DebugPrintTrace(("UFAT: Failure to initialize EA_HEADER %d\n", 3));
        Destroy();
        return FALSE;

    }

    // Compute the number of offset table entries.
    _off_tab_size = Drive->QuerySectorSize() *
                    FatSuperArea->QuerySectorsPerCluster() *
                    LengthOfChain;
    _off_tab_size -= sizeof(EA_FILE_HEADER);
    _off_tab_size -= BaseTableSize*sizeof(USHORT);
    _off_tab_size /= sizeof(USHORT);

    if (_off_tab_size < 0) {

       DebugPrintTrace(("UFAT: Failure to initialize EA_HEADER %d\n", 4));
       Destroy();
       return FALSE;

    }

    return TRUE;
}


UFAT_EXPORT
USHORT
EA_HEADER::QueryEaSetClusterNumber(
    IN  USHORT  Handle
    ) CONST
/*++

Routine Description:

    This function computes the EA cluster number for an EA set in the
    EA file.  This function will return 0 if the handle is invalid or
    outside the range of the table.

Arguments:

    Handle  - Supplies the handle for the desired EA set.

Return Value:

    Returns the EA cluster number for the EA set whose handle is 'Handle'.

--*/
{
    USHORT  off;

    if (!_ht) {
       DebugPrintTrace(("UFAT: Failure to QueryEaSetClusterNumber in EA_HEADER\n"));
       return 0;
    }

    Handle = (( Handle << 1 ) >> 1 );

    if ((LONG)Handle >= _off_tab_size ||
        (off = _ht->Table.OffTab[Handle]) == InvalidHandle) {
       return 0;
    }

    return (( off << 1 ) >> 1 ) + _ht->Table.BaseTab[Handle>>7];
}


VOID
EA_HEADER::Destroy(
    )
/*++

Routine Description:

    This routine puts this object in a blank state.  It is not necessary
    to call this routine between calls to Init because Init calls this
    routine automatically.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _ht = NULL;
    _off_tab_size = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\entry.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

   entry.cxx

Abstract:

   This module contains the entry points for UFAT.DLL.  These
   include:

      Chkdsk
      ChkdskEx
      Format
      Recover

Author:

   Bill McJohn (billmc) 31-05-91

Environment:

   ULIB, User Mode

--*/

#include <pch.cxx>

#include "error.hxx"
#include "path.hxx"
#include "ifssys.hxx"
#include "filter.hxx"
#include "system.hxx"
#include "dir.hxx"
#include "rcache.hxx"
#ifdef DBLSPACE_ENABLED
#include "dblentry.hxx"
#endif // DBLSPACE_ENABLED

extern "C" {
    #include "nturtl.h"
}

#include "message.hxx"
#include "rtmsg.h"
#include "ifsserv.hxx"


VOID
ReportFileNotFoundError(
    IN      PPATH       PathToCheck,
    IN OUT  PMESSAGE    Message
    )
{
    PWSTRING        dirs_and_name;

    if (dirs_and_name = PathToCheck->QueryDirsAndName()) {
        Message->Set(MSG_FILE_NOT_FOUND);
        Message->Display("%W", dirs_and_name);
        DELETE(dirs_and_name);
    }
}


BOOLEAN
FAR APIENTRY
Chkdsk(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Fix,
    IN      BOOLEAN     Verbose,
    IN      BOOLEAN     OnlyIfDirty,
    IN      BOOLEAN     Recover,
    IN      PPATH       PathToCheck,
    IN      BOOLEAN     Extend,
    IN      BOOLEAN     ResizeLogFile,
    IN      ULONG       LogFileSize,
    IN      PULONG      ExitStatus
   )
/*++

Routine Description:

   Check a FAT volume.

Arguments:

   DosDrivName    supplies the name of the drive to check
   Message        supplies an outlet for messages
   Fix            TRUE if Chkdsk should fix errors
   Verbose        TRUE if Chkdsk should list every file it finds
   OnlyIfDirty    TRUE if the drive should be checked only if
                  it is dirty
   Recover        TRUE if Chkdsk should verify all of the sectors
                  on the disk.
   PathToCheck    Supplies a path to files Chkdsk should check
                  for contiguity
   Extend         Unused (should always be FALSE)
   ExitStatus     Returns exit status to chkdsk.exe

Return Value:

   TRUE if successful.

--*/
{
    FAT_VOL         FatVol;
    BOOLEAN         r;
    PWSTRING        dir_name;
    PWSTRING        name;
    PWSTRING        prefix_name;
    FSN_FILTER      filter;
    PFSN_DIRECTORY  directory;
    PARRAY          file_array;
    PDSTRING        files_to_check;
    ULONG           num_files;
    ULONG           i;
    PFSNODE         fsnode;
    PATH            dir_path;
    DSTRING         backslash;
    PPATH           full_path;
    PREAD_CACHE     read_cache;
    ULONG           exit_status;
    ULONG           flags;

    if (NULL == ExitStatus) {
       ExitStatus = &exit_status;
    }

    if (Extend || !FatVol.Initialize(Message, NtDriveName)) {

       *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
       return FALSE;
    }

    if (Fix && !FatVol.IsWriteable()) {
        Message->DisplayMsg(MSG_CHK_WRITE_PROTECTED);
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    if (Fix && !FatVol.Lock()) {

        if (FatVol.IsFloppy()) {

            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display();

        } else {

            //
            // The client wants to fix the drive, but we can't lock it.
            // Offer to fix it on next reboot.
            //
            Message->Set(MSG_CHKDSK_ON_REBOOT_PROMPT);
            Message->Display("");

            if( Message->IsYesResponse( FALSE ) ) {

                if( FatVol.ForceAutochk( Fix,
                                         Recover ? CHKDSK_RECOVER : 0,
                                         0,
                                         0,
                                         NtDriveName ) ) {

                    Message->Set(MSG_CHKDSK_SCHEDULED);
                    Message->Display();

                } else {

                    Message->Set(MSG_CHKDSK_CANNOT_SCHEDULE);
                    Message->Display();
                }
            }
        }

        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;

        return FALSE;
    }

    // Try to enable caching, if there's not enough resources then
    // just run without a cache.

    if ((read_cache = NEW READ_CACHE) &&
        read_cache->Initialize(&FatVol, 75)) {

        FatVol.SetCache(read_cache);

    } else {
        DELETE(read_cache);
    }



    flags = (Verbose ? CHKDSK_VERBOSE : 0);
    flags |= (OnlyIfDirty ? CHKDSK_CHECK_IF_DIRTY : 0);
    flags |= (Recover ? CHKDSK_RECOVER : 0);

    r = FatVol.ChkDsk( Fix ? TotalFix : CheckOnly,
                       Message,
                       flags,
                       0,
                       0,
                       ExitStatus );

    if (!r) {
        return FALSE;
    }

    if (PathToCheck) {

        if (!(name = PathToCheck->QueryName()) ||
            name->QueryChCount() == 0) {

            DELETE(name);
            return TRUE;
        }

        if (!(full_path = PathToCheck->QueryFullPath())) {

            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            DELETE(name);
            return FALSE;
        }

        if (!FatVol.Initialize(Message, NtDriveName)) {
        Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
        DELETE(full_path);
            DELETE(name);
            return FALSE;
        }

        if (!(prefix_name = full_path->QueryPrefix()) ||
            !dir_path.Initialize(prefix_name)) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(prefix_name);
            DELETE(full_path);
            return FALSE;
        }

        if (!(directory = SYSTEM::QueryDirectory(&dir_path)) ||
            !filter.Initialize() ||
            !filter.SetFileName(name)) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(prefix_name);
            DELETE(directory);
            DELETE(full_path);
            return FALSE;
        }

        DELETE(prefix_name);

        if (!(file_array = directory->QueryFsnodeArray(&filter))) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(directory);
            DELETE(full_path);
            return FALSE;
        }

        DELETE(directory);

        if (!(num_files = file_array->QueryMemberCount())) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(directory);
            file_array->DeleteAllMembers();
            DELETE(file_array);
            DELETE(full_path);
            return FALSE;
        }

        DELETE(name);

        if (!(files_to_check = NEW DSTRING[num_files])) {

            ReportFileNotFoundError(full_path, Message);
            file_array->DeleteAllMembers();
            DELETE(file_array);
            DELETE(full_path);
            return FALSE;
        }

        for (i = 0; i < num_files; i++) {

            fsnode = (PFSNODE) file_array->GetAt(i);

            if (!(name = fsnode->QueryName()) ||
                !files_to_check[i].Initialize(name)) {

                ReportFileNotFoundError(full_path, Message);
                DELETE(name);
                file_array->DeleteAllMembers();
                DELETE(file_array);
                // t-raymak: Should use the array version of delete
                // instead.
                // DELETE(files_to_check);
                delete [] files_to_check;
                files_to_check = NULL;
                DELETE(full_path);
                return FALSE;
            }

            DELETE(name);
        }

        file_array->DeleteAllMembers();
        DELETE(file_array);

        if (!(dir_name = full_path->QueryDirs())) {

            if (!backslash.Initialize("\\")) {
                ReportFileNotFoundError(full_path, Message);
                // DELETE(files_to_check);
                delete [] files_to_check;
                files_to_check = NULL;
                DELETE(full_path);
                return FALSE;
            }
        }

        r = FatVol.ContiguityReport(dir_name ? dir_name : &backslash,
                                    files_to_check,
                                    num_files,
                                    Message);

        // DELETE(files_to_check);
        delete [] files_to_check;
        files_to_check = NULL;
        DELETE(dir_name);
        DELETE(full_path);
    }

    return r;
}


BOOLEAN
FAR APIENTRY
ChkdskEx(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Fix,
    IN      PCHKDSKEX_FN_PARAM  Param,
    IN      PULONG              ExitStatus
   )
/*++

Routine Description:

   Check a FAT volume.

Arguments:

   NtDrivName  supplies the name of the drive to check
   Message     supplies an outlet for messages
   Fix         TRUE if Chkdsk should fix errors on the disk.
   Param       supplies the parameter block
               (see ulib\inc\ifsserv.hxx for details)
   ExitStatus  Returns exit status to chkdsk.exe

Return Value:

   TRUE if successful.

--*/
{
    FAT_VOL         FatVol;
    BOOLEAN         r;
    PWSTRING        dir_name;
    PWSTRING        name;
    PWSTRING        prefix_name;
    FSN_FILTER      filter;
    PFSN_DIRECTORY  directory;
    PARRAY          file_array;
    PDSTRING        files_to_check;
    ULONG           num_files;
    ULONG           i;
    PFSNODE         fsnode;
    PATH            dir_path;
    DSTRING         backslash;
    PPATH           full_path;
    PREAD_CACHE     read_cache;
    ULONG           exit_status;

    if (Param->Major != 1 || (Param->Minor != 0 && Param->Minor != 1)) {
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    if (NULL == ExitStatus) {
       ExitStatus = &exit_status;
    }

    if ((Param->Flags & CHKDSK_EXTEND) ||
        !FatVol.Initialize(Message, NtDriveName)) {

       *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
       return FALSE;
    }

    if (Fix && !FatVol.IsWriteable()) {
        Message->DisplayMsg(MSG_CHK_WRITE_PROTECTED);
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    if (Fix && !FatVol.Lock()) {

        BOOLEAN DismntLock = FALSE;
        WCHAR   windows_path[MAX_PATH];
        DSTRING sdrive, nt_drive_name;
        BOOLEAN system_drive = FALSE;

        if (GetWindowsDirectory(windows_path, sizeof(windows_path)/sizeof(WCHAR)) &&
            wcslen(windows_path) >= 2 &&
            windows_path[1] == TEXT(':') &&
            !(windows_path[2] = 0) &&
            sdrive.Initialize(windows_path) &&
            IFS_SYSTEM::DosDriveNameToNtDriveName(&sdrive, &nt_drive_name)) {

            system_drive = nt_drive_name.Stricmp(NtDriveName) == 0;
        } else {

            Message->DisplayMsg(MSG_CHK_UNABLE_TO_TELL_IF_SYSTEM_DRIVE);
            system_drive = FALSE;
        }

        if (!system_drive) {
            if (Param->Flags & CHKDSK_FORCE) {
                if (FatVol.DismountAndLock()) {
                    Message->Set(MSG_VOLUME_DISMOUNTED);
                    Message->Display();
                    DismntLock = TRUE;
                }
            } else {
                Message->Set(MSG_CHKDSK_FORCE_DISMOUNT_PROMPT);
                Message->Display("");

                if (Message->IsYesResponse( FALSE )) {
                    if (FatVol.DismountAndLock()) {
                        Message->Set(MSG_VOLUME_DISMOUNTED);
                        Message->Display();
                        DismntLock = TRUE;
                    }
                }
            }
        }

        if (!DismntLock) {
            if (FatVol.IsFloppy()) {
                Message->Set(MSG_CANT_LOCK_THE_DRIVE);
                Message->Display();
            } else {
                //
                // The client wants to fix the drive, but we can't lock it.
                // Offer to fix it on next reboot.
                //
                Message->Set(MSG_CHKDSK_ON_REBOOT_PROMPT);
                Message->Display("");

                if( Message->IsYesResponse( FALSE ) ) {

                    if( FatVol.ForceAutochk( Fix,
                                             Param->Flags,
                                             0,
                                             0,
                                             NtDriveName ) ) {

                        Message->Set(MSG_CHKDSK_SCHEDULED);
                        Message->Display();

                    } else {

                        Message->Set(MSG_CHKDSK_CANNOT_SCHEDULE);
                        Message->Display();
                    }
                }
            }
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }
    }


    if (!Fix && !FatVol.Lock()) {
        Message->DisplayMsg(MSG_CHKDSK_FALSE_ALARM);
    }


    // Try to enable caching, if there's not enough resources then
    // just run without a cache.

    if ((read_cache = NEW READ_CACHE) &&
        read_cache->Initialize(&FatVol, 75)) {

        FatVol.SetCache(read_cache);

    } else {
        DELETE(read_cache);
    }

    Param->Flags &= (~CHKDSK_RESIZE_LOGFILE);   // ignore resize of logfile

    r = FatVol.ChkDsk( Fix ? TotalFix : CheckOnly,
                       Message,
                       Param->Flags,
                       0,
                       0,
                       ExitStatus );

    if (!r) {
        return FALSE;
    }

    if (Param->PathToCheck) {

        if (Param->RootPath) {
            if (!(name = Param->RootPath->QueryName()) ||
                name->QueryChCount() == 0) {

                DELETE(name);
                return TRUE;
            }
        } else {
            if (!(name = Param->PathToCheck->QueryName()) ||
                name->QueryChCount() == 0) {

                DELETE(name);
                return TRUE;
            }
        }

        if (!(full_path = Param->PathToCheck->QueryFullPath())) {

            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            DELETE(name);
            return FALSE;
        }

        if (!FatVol.Initialize(Message, NtDriveName)) {
        Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
        DELETE(full_path);
            DELETE(name);
            return FALSE;
        }

        if (!(prefix_name = full_path->QueryPrefix()) ||
            !dir_path.Initialize(prefix_name)) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(prefix_name);
            DELETE(full_path);
            return FALSE;
        }

        if (!(directory = SYSTEM::QueryDirectory(&dir_path)) ||
            !filter.Initialize() ||
            !filter.SetFileName(name)) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(prefix_name);
            DELETE(directory);
            DELETE(full_path);
            return FALSE;
        }

        DELETE(prefix_name);

        if (!(file_array = directory->QueryFsnodeArray(&filter))) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(directory);
            DELETE(full_path);
            return FALSE;
        }

        DELETE(directory);

        if (!(num_files = file_array->QueryMemberCount())) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(directory);
            file_array->DeleteAllMembers();
            DELETE(file_array);
            DELETE(full_path);
            return FALSE;
        }

        DELETE(name);

        if (!(files_to_check = NEW DSTRING[num_files])) {

            ReportFileNotFoundError(full_path, Message);
            file_array->DeleteAllMembers();
            DELETE(file_array);
            DELETE(full_path);
            return FALSE;
        }

        for (i = 0; i < num_files; i++) {

            fsnode = (PFSNODE) file_array->GetAt(i);

            if (!(name = fsnode->QueryName()) ||
                !files_to_check[i].Initialize(name)) {

                ReportFileNotFoundError(full_path, Message);
                DELETE(name);
                file_array->DeleteAllMembers();
                DELETE(file_array);
                // t-raymak: Should use the array version of delete
                // instead.
                // DELETE(files_to_check);
                delete [] files_to_check;
                files_to_check = NULL;
                DELETE(full_path);
                return FALSE;
            }

            DELETE(name);
        }

        file_array->DeleteAllMembers();
        DELETE(file_array);

        if (Param->RootPath) {
            dir_name = Param->RootPath->QueryDirs();
        } else
            dir_name = full_path->QueryDirs();

        if (!dir_name) {

            if (!backslash.Initialize("\\")) {
                ReportFileNotFoundError(full_path, Message);
                // DELETE(files_to_check);
                delete [] files_to_check;
                files_to_check = NULL;
                DELETE(full_path);
                return FALSE;
            }
        }

        r = FatVol.ContiguityReport(dir_name ? dir_name : &backslash,
                                    files_to_check,
                                    num_files,
                                    Message);

        // DELETE(files_to_check);
        delete [] files_to_check;
        files_to_check = NULL;
        DELETE(dir_name);
        DELETE(full_path);
    }

    return r;
}

FORMAT_ERROR_CODE
ValidateFATClusterSizeArg(
    IN      PDP_DRIVE   DpDrive,
    IN OUT  PMESSAGE    Message,
    IN      ULONG   ClusterSize
    )
/*++

Routine Description:

    This routine does a quick and dirty validation that the specified
    cluster size is a valid cluster size to specify for the drive

    NOTE: This routine saying OK does NOT mean that the cluster size
      is valid, it just means that the cluster size is in the right
      ballpark. It may be rejected later when the format code does
      a more exhaustive check on it.

Arguments:

    DpDrive - Drive object for the drive being formated
    Message     - Supplies an outlet for messages.
    ClusterSize - Supplies the cluster size in bytes

Return Value:

    NoError - Success.
    Other   - Failure.

--*/
{
    ULONG SectorSize;

    SectorSize = DpDrive->QuerySectorSize();
    if(ClusterSize < SectorSize) {
        Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_SMALL_MIN);
        Message->Display("%u", SectorSize);
        return(GeneralError);
    }
    if(ClusterSize > (SectorSize * 128)) {
        Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_BIG);
        Message->Display("%s", "FAT");
        return(GeneralError);
    }
    return(NoError);
}

BOOLEAN
FAR APIENTRY
Format(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Quick,
    IN      BOOLEAN             BackwardCompatible,
    IN      MEDIA_TYPE          MediaType,
    IN      PCWSTRING           LabelString,
    IN      ULONG               ClusterSize
    )
/*++

Routine Description:

    This routine formats a volume for the FAT file system.

Arguments:

    NtDriveName - Supplies the NT style drive name of the volume to format.
    Message     - Supplies an outlet for messages.
    Quick       - Supplies whether or not to do a quick format.
    BackwardCompatible - Supplies whether or not the newly formatted volume
                         will be compatible with FAT16.
    MediaType   - Supplies the media type of the drive.
    LabelString - Supplies a volume label to be set on the volume after
                    format.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PDP_DRIVE   DpDrive;
    FAT_VOL     FatVol;
    BIG_INT     Sectors;
    DSTRING     FileSystemName;
    BOOLEAN     IsCompressed;
    BOOLEAN     ret_status;
    FORMAT_ERROR_CODE   errcode;
    ULONG       flags;
    USHORT      format_type;
    BOOLEAN     send_fmt_cmd, fmt_cmd_capable;

    if( !(DpDrive = NEW DP_DRIVE) ) {

        Message->Set( MSG_FMT_NO_MEMORY );
        Message->Display( "" );
        return FALSE;
    }

#if defined(FE_SB) && defined(_X86_)
    if (IsPC98_N()) {

        // PC98 Nov.01.1994
        // We need to notify DP_DRIVE:Initialize() that we will format media by FAT
        format_type = DP_DRIVE::FAT;
    } else
#endif
    {
        format_type = DP_DRIVE::NONE;
    }

    if (!DpDrive->Initialize(NtDriveName, Message, TRUE, FALSE, format_type)) {
        DELETE( DpDrive );
        return FALSE;
    }

    if (!BackwardCompatible && DpDrive->IsFloppy()) {
        DELETE( DpDrive );
        Message->Set(MSG_FMT_FAT32_NO_FLOPPIES);
        Message->Display();
        return FALSE;
    }

    //
    // Check to see if the volume is too large and determine
    // whether it's compressed.  Volumes with more than 4Gig sectors are
    // not supported by fastfat.
    //
    Sectors = DpDrive->QuerySectors();

    //
    // A drive has to have > 0x0FFFFFF6 * 128 to be too big for
    // FAT32. Since 0x0FFFFFF6 * 128 > 2^32, there is no need for the
    // second condition; besides, ComputeSecClus will never return
    // a sector per cluster value > 128.
    //
#if 0
    if (Sectors.GetHighPart() != 0 ||
        FAT_SA::ComputeSecClus(Sectors.GetLowPart(),
                               LARGE32, MediaType) > MaxSecPerClus) {
#endif
    if (Sectors.GetHighPart() != 0) {

        DELETE( DpDrive );
        Message->Set(MSG_DISK_TOO_LARGE_TO_FORMAT);
        Message->Display();
        return FALSE;
    }

#ifdef DBLSPACE_ENABLED
    // Note that we don't care about the return value from
    // QueryMountedFileSystemName, just whether the volume
    // is compressed.
    //
    DpDrive->QueryMountedFileSystemName( &FileSystemName, &IsCompressed );
#endif // DBLSPACE_ENABLED


    // Do a quick check on the cluster size before we do anything lengthy

    if(ClusterSize
#ifdef DBLSPACE_ENABLED
       && !IsCompressed
#endif // DBLSPACE_ENABLED
          ) {
        errcode = ValidateFATClusterSizeArg(DpDrive,Message,ClusterSize);
        if(errcode != NoError) {
            DELETE( DpDrive );
            ret_status = FALSE;
            return ret_status;
        }
    }

    send_fmt_cmd = DpDrive->IsSonyMS();
    fmt_cmd_capable = DpDrive->IsSonyMSFmtCmdCapable();

    // Delete the DP_DRIVE object so it's handle will go away.
    //

    DELETE( DpDrive );

    if (send_fmt_cmd && ClusterSize) {
        Message->Set(MSG_FMT_CLUS_SIZE_NOT_ALLOWED);
        Message->Display();
        if (!Message->IsYesResponse(FALSE)) {
            return FALSE;
        }
        send_fmt_cmd = FALSE;
    }

    send_fmt_cmd = send_fmt_cmd && fmt_cmd_capable;

    if (send_fmt_cmd && Quick) {

        // If it is a Sony memory stick device that has self formatting capability
        // and the user didn't specify any cluster size then quick format is not
        // allowed since the self formatting capability is basically a long format.
        // The quick format will then be promoted to long format with a warning to
        // the user.
        Message->Set(MSG_FMT_QUICK_FORMAT_NOT_AVAILABLE);
        Message->Display();
        if (Message->IsYesResponse(FALSE)) {
            Quick = FALSE;
        } else {
            return FALSE;
        }
    }

    // Volume is not too large, proceed with format.

    errcode = FatVol.Initialize(NtDriveName,
                                Message,
                                FALSE,
                                !Quick,
                                MediaType,
                                format_type );

    if (errcode == NoError) {
        if (!send_fmt_cmd) {
            flags = BackwardCompatible ? FORMAT_BACKWARD_COMPATIBLE : 0;
            errcode = FatVol.Format(LabelString, Message, flags, ClusterSize);
        } else {
            if (!FatVol.SetVolumeLabelAndPrintFormatReport(LabelString,
                                                           Message)) {
                errcode = GeneralError;
            }
        }
    }

    if (errcode == LockError) {
        Message->Set(MSG_CANT_LOCK_THE_DRIVE);
        Message->Display("");
        ret_status = FALSE;
    } else
        ret_status = (errcode == NoError);

    return ret_status;
}


BOOLEAN
FAR APIENTRY
FormatEx(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      PFORMATEX_FN_PARAM  Param,
    IN      MEDIA_TYPE          MediaType
    )
/*++

Routine Description:

    This routine formats a volume for the FAT file system.

Arguments:

    NtDriveName - Supplies the NT style drive name of the volume to format.
    Message     - Supplies an outlet for messages.
    Param       - Supplies the format parameter block
    MediaType   - Supplies the media type of the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PDP_DRIVE   DpDrive;
    FAT_VOL     FatVol;
    BIG_INT     Sectors;
    DSTRING     FileSystemName;
    BOOLEAN     IsCompressed;
    BOOLEAN     ret_status;
    FORMAT_ERROR_CODE   errcode;
    BOOLEAN     do_not_dismount = FALSE;
    USHORT      format_type;
    BOOLEAN     send_fmt_cmd;

    if (Param->Major != 1 || Param->Minor != 0) {
        return FALSE;
    }

    if( !(DpDrive = NEW DP_DRIVE) ) {

        Message->Set( MSG_FMT_NO_MEMORY );
        Message->Display( "" );
        return FALSE;
    }

#if defined(FE_SB) && defined(_X86_)
    if (IsPC98_N()) {

        // PC98 Nov.01.1994
        // We need to notify DP_DRIVE:Initialize() that we will format media by FAT
        format_type = DP_DRIVE::FAT;
    } else
#endif
    {
        format_type = DP_DRIVE::NONE;
    }

    if (!DpDrive->Initialize(NtDriveName, Message, TRUE, FALSE, format_type)) {
        DELETE( DpDrive );
        return FALSE;
    }

    if (!(Param->Flags & FORMAT_BACKWARD_COMPATIBLE) &&
        DpDrive->IsFloppy()) {
        DELETE( DpDrive );
        Message->Set(MSG_FMT_FAT32_NO_FLOPPIES);
        Message->Display();
        return FALSE;
    }

    //
    // Check to see if the volume is too large and determine
    // whether it's compressed.  Volumes with more than 4Gig sectors are
    // not supported by fastfat.
    //
    Sectors = DpDrive->QuerySectors();

    //
    // A drive has to have > 0x0FFFFFF6 * 128 to be too big for
    // FAT32. Since 0x0FFFFFF6 * 128 > 2^32, there is no need for the
    // second condition; besides, ComputeSecClus will never return
    // a sector per cluster value > 128.
    //
#if 0
    if (Sectors.GetHighPart() != 0 ||
        FAT_SA::ComputeSecClus(Sectors.GetLowPart(),
                               LARGE32, MediaType) > MaxSecPerClus) {
#endif
    if (Sectors.GetHighPart() != 0) {

        DELETE( DpDrive );
        Message->Set(MSG_DISK_TOO_LARGE_TO_FORMAT);
        Message->Display();
        return FALSE;
    }

#ifdef DBLSPACE_ENABLED
    // Note that we don't care about the return value from
    // QueryMountedFileSystemName, just whether the volume
    // is compressed.
    //
    DpDrive->QueryMountedFileSystemName( &FileSystemName, &IsCompressed );
#endif // DBLSPACE_ENABLED


    // Do a quick check on the cluster size before we do anything lengthy

    if(Param->ClusterSize
#ifdef DBLSPACE_ENABLED
       && !IsCompressed
#endif // DBLSPACE_ENABLED
          ) {
        errcode = ValidateFATClusterSizeArg(DpDrive,Message,Param->ClusterSize);
        if (errcode != NoError) {
            DELETE( DpDrive );
            ret_status = FALSE;
            return ret_status;
        }
    }

    send_fmt_cmd = DpDrive->IsSonyMS();

    if (send_fmt_cmd && Param->ClusterSize) {
        if (Param->Flags & FORMAT_YES) {
            Message->Set(MSG_FMT_CLUS_SIZE_NOT_ALLOWED_WARNING);
            Message->Display();
        } else {
            Message->Set(MSG_FMT_CLUS_SIZE_NOT_ALLOWED);
            Message->Display();
            if (!Message->IsYesResponse(FALSE)) {
                return FALSE;
            }
        }
        send_fmt_cmd = FALSE;
    }

    send_fmt_cmd = send_fmt_cmd && DpDrive->IsSonyMSFmtCmdCapable();

    if (send_fmt_cmd &&
        (Param->Flags & FORMAT_QUICK)) {

        // If it is a Sony memory stick device that has self formatting capability
        // and the user didn't specify any cluster size then quick format is not
        // allowed since the self formatting capability is basically a long format.
        // The quick format will then be promoted to long format with a warning to
        // the user.
        if (Param->Flags & FORMAT_YES) {
            Message->Set(MSG_FMT_QUICK_FORMAT_NOT_AVAILABLE_WARNING);
            Message->Display();
            Param->Flags &= ~FORMAT_QUICK;      // override
        } else {
            Message->Set(MSG_FMT_QUICK_FORMAT_NOT_AVAILABLE);
            Message->Display();
            if (Message->IsYesResponse(FALSE)) {
                Param->Flags &= ~FORMAT_QUICK;      // override
            } else {
                return FALSE;
            }
        }
    }

    // Volume is not too large, proceed with format.
    // Delete the DP_DRIVE object so it's handle will go away.
    //
    DELETE( DpDrive );

    errcode = FatVol.Initialize(NtDriveName,
                                Message,
                                FALSE,
                                (Param->Flags & FORMAT_QUICK) ? FALSE : TRUE,
                                MediaType,
                                format_type);

    if (errcode == NoError) {
        if (!send_fmt_cmd) {
            errcode = FatVol.Format(Param->LabelString,
                                    Message,
                                    Param->Flags,
                                    Param->ClusterSize);
        } else {

            if (!FatVol.SetVolumeLabelAndPrintFormatReport(Param->LabelString,
                                                           Message)) {
                errcode = GeneralError;
            }
        }
    }

    if (errcode == LockError) {

        if (!(Param->Flags & FORMAT_FORCE)) {
            Message->Set(MSG_FMT_FORCE_DISMOUNT_PROMPT);
            Message->Display();

            if (Message->IsYesResponse(FALSE) &&
                IFS_SYSTEM::DismountVolume(NtDriveName)) {
                Message->Set(MSG_VOLUME_DISMOUNTED);
                Message->Display();
            } else {
                do_not_dismount = TRUE;
            }
        } else if (IFS_SYSTEM::DismountVolume(NtDriveName)) {
            Message->Set(MSG_VOLUME_DISMOUNTED);
            Message->Display();
        }

        if (!do_not_dismount) {
            errcode = FatVol.Initialize(NtDriveName,
                                        Message,
                                        FALSE,
                                        (Param->Flags & FORMAT_QUICK) ? FALSE : TRUE,
                                        MediaType,
                                        format_type,
                                        TRUE);

            if (errcode == NoError) {
                if (!send_fmt_cmd) {
                    errcode = FatVol.Format(Param->LabelString,
                                            Message,
                                            Param->Flags,
                                            Param->ClusterSize);
                } else {

                    if (!FatVol.SetVolumeLabelAndPrintFormatReport(Param->LabelString,
                                                                   Message)) {
                        errcode = GeneralError;
                    }
                }
            }
        }

        if (errcode == LockError) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            ret_status = FALSE;
        } else
            ret_status = (errcode == NoError);
    } else
        ret_status = (errcode == NoError);

    return ret_status;
}


BOOLEAN
FAR APIENTRY
Recover(
   IN       PPATH    RecFilePath,
   IN OUT   PMESSAGE Message
   )
/*++

Routine Description:

   Recover a file on a FAT disk.

Arguments:

Return Value:

   TRUE if successful.

--*/
{
    FAT_VOL       FatVol;
    PWSTRING      fullpathfilename;
    PWSTRING      dosdrive;
    DSTRING       ntdrive;

    fullpathfilename = RecFilePath->QueryDirsAndName();
    dosdrive = RecFilePath->QueryDevice();
    if (!dosdrive ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(dosdrive, &ntdrive)) {

       DELETE(dosdrive);
       DELETE(fullpathfilename);
       return FALSE;
    }

    if (!fullpathfilename) {

       DELETE(dosdrive);
       DELETE(fullpathfilename);
       return FALSE;
    }

    Message->Set(MSG_RECOV_BEGIN);
    Message->Display("%W", dosdrive);
    Message->WaitForUserSignal();

    if (!FatVol.Initialize(Message, &ntdrive)) {
        DELETE(dosdrive);
        DELETE(fullpathfilename);
        return FALSE;
    }

    if (!FatVol.Recover(fullpathfilename, Message)) {
        DELETE(dosdrive);
        DELETE(fullpathfilename);
        return FALSE;
    }

    DELETE(dosdrive);
    DELETE(fullpathfilename);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\fat.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UFAT_MEMBER_

#include "ulib.hxx"
#include "ufat.hxx"

#include "bitvect.hxx"
#include "error.hxx"
#include "fat.hxx"


DEFINE_CONSTRUCTOR( FAT, SECRUN );


FAT::~FAT(
    )
/*++

Routine Description:

    Destructor for FAT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

extern VOID DoInsufMemory(VOID);

VOID
FAT::Construct (
    )
/*++

Routine Description:

    Constructor for FAT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _fat = NULL;
    _num_entries = 0;
    _fat_bits = 0;
    _low_end_of_chain = 0;
    _end_of_chain = 0;
    _bad_cluster = 0;
    _low_reserved = 0;
    _high_reserved = 0;
    _AllocatedClusters = 0xFFFFFFFF;
}


VOID
FAT::Destroy(
    )
/*++

Routine Description:

    This routine returns a FAT object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _fat = NULL;
    _num_entries = 0;
    _fat_bits = 0;
    _low_end_of_chain = 0;
    _end_of_chain = 0;
    _bad_cluster = 0;
    _low_reserved = 0;
    _high_reserved = 0;
    _AllocatedClusters = 0xFFFFFFFF;
}


BOOLEAN
FAT::Initialize(
    IN OUT  PSECRUN     Srun,
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      LBN                 StartSector,
    IN      ULONG               NumOfEntries,
    IN      ULONG               NumSectors
    )
/*++

Routine Description:

    This routine initialize a FAT object.

Arguments:

    Mem             - Supplies the memory for the run of sectors.
    Drive           - Supplies the drive to read and write from.
    StartSector     - Supplies the start of the fat.
    NumberOfEntries - Supplies the number of entries in the FAT
                      which should be the total number of clusters
                      plus two reserved entries at the beginning.
    NumSectors      - Supplies the number of sectors allocated for
                      the fat.  If this parameter is not supplied
                      then this routine will compute this value
                      from the given number of entries.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The 'NumSectors' parameter is added to this function
    DOS FORMAT does not always make the FAT large enough for
    the volume.  If this parameter is supported then the
    number of entries supported by this FAT will be the lesser
    or the actual number passed in that the maximum number that
    the given FAT size will support.

--*/
{
    SECTORCOUNT n;
    ULONG       sector_size;
    ULONG       max_num_entries;

    DebugAssert(Mem);
    DebugAssert(Drive);

    Destroy();

    if (!(sector_size = Drive->QuerySectorSize())) {
        Destroy();
        return FALSE;
    }

    _num_entries = NumOfEntries;

    if (_num_entries < FirstDiskCluster + MaxNumClusForSmallFat) {
       _fat_bits = fFat12;
    } else if (_num_entries < FirstDiskCluster + MinNumClusForFat32) {
       _fat_bits = fFat16;
    } else {
       _fat_bits = fFat32;
    }

    if (fFat32 == _fat_bits) {
        _low_end_of_chain = 0x0FFFFFF8;
        _end_of_chain = 0x0FFFFFFF;
        _bad_cluster = 0x0FFFFFF7;
        _low_reserved = 0x0FFFFFF0;
        _high_reserved = 0x0FFFFFF6;
        n = (_num_entries*4 - 1)/sector_size + 1;
    }
    else if (fFat16 == _fat_bits) {
        // COMMON CODE for FAT 12 and FAT 16
        // FAT 16
        _low_end_of_chain = 0xFFF8;
        _end_of_chain = 0xFFFF;
        _bad_cluster = 0xFFF7;
        _low_reserved = 0xFFF0;
        _high_reserved = 0xFFF6;

        n = (_num_entries*2 - 1)/sector_size + 1;

    }
    else {      // FAT 12
        _low_end_of_chain = 0x0FF8;
        _end_of_chain = 0x0FFF;
        _bad_cluster = 0x0FF7;
        _low_reserved = 0x0FF0;
        _high_reserved = 0x0FF6;

        n = (_num_entries*3 - 1)/2/sector_size + 1;
    }

    if (NumSectors) {
        n = NumSectors;
        if (fFat32 == _fat_bits) {
           max_num_entries = (n*sector_size/4);
        } else if (fFat16 == _fat_bits) {
           // COMMON CODE for FAT 12 and FAT 16
           max_num_entries = (n*sector_size/2);
        } else {
            max_num_entries = (n*sector_size*2/3);
        }
        _num_entries = min(_num_entries, max_num_entries);
    }
    _AllocatedClusters = 0xFFFFFFFF;

    if (!Srun->Initialize(Mem, Drive, StartSector, n)) {
    DoInsufMemory();
        Destroy();
        return FALSE;
    }

    _fat = Srun->GetBuf();
    return TRUE;
}



BOOLEAN
FAT::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      LBN                 StartSector,
    IN      ULONG               NumOfEntries,
    IN      ULONG               NumSectors
    )
/*++

Routine Description:

    This routine initialize a FAT object.

Arguments:

    Mem             - Supplies the memory for the run of sectors.
    Drive           - Supplies the drive to read and write from.
    StartSector     - Supplies the start of the fat.
    NumberOfEntries - Supplies the number of entries in the FAT
                      which should be the total number of clusters
                      plus two reserved entries at the beginning.
    NumSectors      - Supplies the number of sectors allocated for
                      the fat.  If this parameter is not supplied
                      then this routine will compute this value
                      from the given number of entries.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The 'NumSectors' parameter is added to this function
    DOS FORMAT does not always make the FAT large enough for
    the volume.  If this parameter is supported then the
    number of entries supported by this FAT will be the lesser
    or the actual number passed in that the maximum number that
    the given FAT size will support.

--*/
{
    SECTORCOUNT n;
    ULONG       sector_size;
    ULONG       max_num_entries;

    DebugAssert(Mem);
    DebugAssert(Drive);

    Destroy();

    if (!(sector_size = Drive->QuerySectorSize())) {
        Destroy();
        return FALSE;
    }

    _num_entries = NumOfEntries;

    if (_num_entries < FirstDiskCluster + MaxNumClusForSmallFat) {
       _fat_bits = fFat12;
    } else if (_num_entries < FirstDiskCluster + MinNumClusForFat32) {
       _fat_bits = fFat16;
    } else {
       _fat_bits = fFat32;
    }

    if (fFat32 == _fat_bits) {
        _low_end_of_chain = 0x0FFFFFF8;
        _end_of_chain = 0x0FFFFFFF;
        _bad_cluster = 0x0FFFFFF7;
        _low_reserved = 0x0FFFFFF0;
        _high_reserved = 0x0FFFFFF6;
    n = ((_num_entries * 4) + (sector_size - 1)) / sector_size;
    }
    else if (fFat16 == _fat_bits) {
        // COMMON CODE for FAT 12 and FAT 16
        // FAT 16
        _low_end_of_chain = 0xFFF8;
        _end_of_chain = 0xFFFF;
        _bad_cluster = 0xFFF7;
        _low_reserved = 0xFFF0;
        _high_reserved = 0xFFF6;

    n = ((_num_entries * 2) + (sector_size - 1)) / sector_size;

    }
    else {      // FAT 12
        _low_end_of_chain = 0x0FF8;
        _end_of_chain = 0x0FFF;
        _bad_cluster = 0x0FF7;
        _low_reserved = 0x0FF0;
        _high_reserved = 0x0FF6;

    // NOTE: the "+ (2 - 1)) / 2)" below is doing a round up divide by 2
    //   it is left this way because it is clearer what it is doing....

    n = ((((_num_entries * 3) + (2 - 1)) / 2) + (sector_size - 1)) / sector_size;
    }

    if (NumSectors) {
        n = NumSectors;
        if (fFat32 == _fat_bits) {
           max_num_entries = (n*sector_size/4);
        } else if (fFat16 == _fat_bits) {
           // COMMON CODE for FAT 12 and FAT 16
           max_num_entries = (n*sector_size/2);
        } else {
            max_num_entries = (n*sector_size*2/3);
        }
        _num_entries = min(_num_entries, max_num_entries);
    }
    _AllocatedClusters = 0xFFFFFFFF;

    if (!SECRUN::Initialize(Mem, Drive, StartSector, n)) {
    DoInsufMemory();
        Destroy();
        return FALSE;
    }

    _fat = GetBuf();
    return TRUE;
}


UFAT_EXPORT
ULONG
FAT::Index12(
    IN  ULONG    ClusterNumber
    ) CONST
/*++

Routine Description:

    This routine indexes the FAT as 12 bit little endian entries.

Arguments:

    ClusterNumber   - Supplies the FAT entry desired.

Return Value:

    The value of the FAT entry at ClusterNumber.

--*/
{
    ULONG   n;
    PUCHAR  p;

    p = (PUCHAR) _fat;

    DebugAssert(p);

    n = ClusterNumber*3;
    if (n%2) {
        return (p[n/2]>>4) | (p[n/2 + 1]<<4);
    } else {
        return p[n/2] | ((p[n/2 + 1]&0x0F)<<8);
    }
}


UFAT_EXPORT
VOID
FAT::Set12(
    IN  ULONG    ClusterNumber,
    IN  ULONG    Value
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 12 bit FAT entry to Value.

Arguments:

    ClusterNumber   - Supplies the FAT entry to set.
    Value           - Supplies the value to set the FAT entry to.

Return Value:

    None.

--*/
{
    ULONG   n;
    PUCHAR  p;

    p = (PUCHAR) _fat;

    DebugAssert(p);

    n = ClusterNumber*3;
    if (n%2) {
        p[n/2] = (p[n/2]&0x0F) | (((UCHAR)Value&0x000F)<<4);
        p[n/2 + 1] = (UCHAR)((Value&0x0FF0)>>4);
    } else {
        p[n/2] = (UCHAR)Value&0x00FF;
        p[n/2 + 1] = (p[n/2 + 1]&0xF0) | (UCHAR)((Value&0x0F00)>>8);
    }
    _AllocatedClusters = 0xFFFFFFFF;
}

ULONG
FAT::QueryFreeClusters(
    ) CONST
/*++

Routine Description:

    This routine computes the number of free clusters on the disk by
    scanning the FAT and counting the number of empty entries.

Arguments:

    None.

Return Value:

    The number of free clusters on the disk.

--*/
{
    ULONG    i;
    ULONG    r;

    r = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterFree(i)) {

            r++;
        }
    }

    return r;
}


ULONG
FAT::QueryBadClusters(
    ) CONST
/*++

Routine Description:

    This routine computes the number of bad clusters on the disk by
    scanning the FAT and counting the number of entries marked bad.

Arguments:

    None.

Return Value:

    The number of bad clusters on the disk.

--*/
{
    ULONG    i;
    ULONG    r;

    r = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterBad(i)) {
            r++;
        }
    }

    return r;
}


ULONG
FAT::QueryReservedClusters(
    ) CONST
/*++

Routine Description:

    This routine computes the number of reserved clusters on the disk by
    scanning the FAT and counting the number of entries marked reserved.

Arguments:

    None.

Return Value:

    The number of reserved clusters on the disk.

--*/
{
    ULONG    i;
    ULONG    r;

    r = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterReserved(i)) {
            r++;
        }
    }

    return r;
}

ULONG
FAT::QueryAllocatedClusters(
    ) CONST
/*++

Routine Description:

    This routine computes the number of allocated clusters on the
    disk by scanning the FAT and counting the entries marked allocated.

Arguments:

    None.

Return Value:

    The number of allocated clusters on the disk.

--*/
{
    ULONG    i;
    ULONG    r;

    r = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (!IsClusterReserved(i) && !IsClusterBad(i) && !IsClusterFree(i)) {
            r++;
        }
    }

    return r;
}


UFAT_EXPORT
ULONG
FAT::QueryNthCluster(
    IN  ULONG    StartingCluster,
    IN  ULONG    Index
    ) CONST
/*++

Routine Description:

    This routine returns the cluster number of the cluster that is in the
    'Index'th position in the cluster chain beginning at 'StartingCluster'.
    The clusters in a chain are numbered beginning at zero.

Arguments:

    StartingCluster - Supplies the first cluster of a cluster chain.
    Index           - Supplies the number of the cluster in the chain
                        requested.

Return Value:

    The cluster number of the 'Index'th cluster in the cluster chain
    beginning with cluster 'StartingCluster' or 0.

--*/
{
    for (; Index; Index--) {

        if (!IsInRange(StartingCluster)) {
            return 0;
        }

        StartingCluster = QueryEntry(StartingCluster);
    }

    return StartingCluster;
}


UFAT_EXPORT
ULONG
FAT::QueryLengthOfChain(
    IN  ULONG    StartingCluster,
    OUT PULONG   LastCluster
    ) CONST
/*++

Routine Description:

    This routine computes the length of a cluster chain given the number
    of its first cluster.

    This routine depends on the chain being valid.  In particular, if the
    chain contains any cycles then this routine will not finish.  The
    routine 'ScrubChain' will turn an invalid chain into a valid one.

Arguments:

    StartingCluster - Supplies the first cluster of a cluster chain.
    LastCluster     - Returns the number of the last cluster in the chain.

Return Value:

    The length of the cluster chain beginning with 'StartingCluster'.

--*/
{
    ULONG    length;

    if (!StartingCluster) {
        if (LastCluster) {
            *LastCluster = 0;
        }
        return 0;
    }

    for (length = 1; IsInRange(StartingCluster) && !IsEndOfChain(StartingCluster); length++) {
        StartingCluster = QueryEntry(StartingCluster);
    }

    if (LastCluster) {
        *LastCluster = StartingCluster;
    }

    return length;
}


ULONG
FAT::QueryLengthOfChain(
    IN  ULONG    StartingCluster,
    IN  ULONG    EndingCluster
    ) CONST
/*++

Routine Description:

    This routine computes the length of a cluster chain given the number
    of its first cluster and the number of its last cluster.  To compute
    the length of a chain which is terminated by "end of chain", see
    the one parameter version of this routine above.  If 'EndingCluster'
    is not a member of the chain beginning with 'StartingCluster' then
    this routine will return 0.

    This routine depends on the chain being valid.

Arguments:

    StartingCluster - Supplies the first cluster of the cluster chain.
    EndingCluster   - Supplies the last cluster of the cluster chain.

Return Value:

    The length of the cluster chain beginning with 'StartingCluster' and
    ending with 'EndingCluster' or 0.

--*/
{
    ULONG    length;

    if (!StartingCluster) {
        return 0;
    }

    for (length = 1; StartingCluster != EndingCluster &&
                     !IsEndOfChain(StartingCluster); length++) {
        StartingCluster = QueryEntry(StartingCluster);
    }

    return StartingCluster == EndingCluster ? length : 0;
}


ULONG
FAT::QueryPrevious(
    IN  ULONG    Cluster
    ) CONST
/*++

Routine Description:

    Obtains the previous cluster in a chain, i.e. the cluster that
    references the given cluster.

Arguments:

    Cluster -   Supplies the cluster whose predecesor we're looking for.

Return Value:

    The predecesor of the given cluster. 0 if there is no predecesor.

--*/

{
    ULONG    i;

    DebugAssert( Cluster );

    if ( !IsClusterFree( Cluster ) ) {
        for (i = FirstDiskCluster; IsInRange(i); i++) {
            if ( QueryEntry(i) == Cluster ) {
                return i;
            }
        }
    }

    return 0;
}


VOID
FAT::Scrub(
    OUT PBOOLEAN    ChangesMade
    )
/*++

Routine Description:

    This routine goes through all of the FAT entries changing invalid values
    to reasonable values for the purposes of CHKDSK.

    Illegal FAT entries are those that are set out of disk range and that
    are not magic values.  This routine will set all illegal FAT entries to
    the "end of chain" magic value.

Arguments:

    ChangesMade - Returns TRUE if any changes were made to the FAT.

Return Value:

    None.

--*/
{
    ULONG    i;

    if (ChangesMade) {
        *ChangesMade = FALSE;
    }

    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (!IsInRange(QueryEntry(i)) &&
            !IsClusterFree(i) &&
            !IsEndOfChain(i) &&
            !IsClusterBad(i) &&
            !IsClusterReserved(i)) {

            SetEndOfChain(i);

            if (ChangesMade) {
                *ChangesMade = TRUE;
            }
        }
    }
}


VOID
FAT::ScrubChain(
    IN      ULONG        StartingCluster,
    OUT     PBOOLEAN     ChangesMade
    )
/*++

Routine Description:

    This routine goes through all of the FAT entries in the chain beginning
    with cluster 'StartingCluster'.  It is expected that all of the entries
    in this chain point to valid clusters on the disk.  This routine will
    mark the first invalid entry, if any, as the final cluster of the chain
    thus transforming the invalid chain into a valid one.

Arguments:

    StartingCluster - Supplies the first cluster of the chain to
                      scrub.
    ChangesMade     - Returns TRUE if changes were made to correct
                      the chain.

Return Value:

    None.

--*/
{
    ULONG    clus, next;

    DebugAssert(IsInRange(StartingCluster));
    DebugAssert(ChangesMade);

    *ChangesMade = FALSE;

    clus = StartingCluster;
    while (!IsEndOfChain(clus)) {

        next = QueryEntry(clus);
        if (!IsInRange(next) || IsClusterFree(next)) {
            SetEndOfChain(clus);
            *ChangesMade = TRUE;
            return;
        }

        clus = next;
    }
}


VOID
FAT::ScrubChain(
    IN      ULONG       StartingCluster,
    OUT     PBITVECTOR  FatBitMap,
    OUT     PBOOLEAN    ChangesMade,
    OUT     PBOOLEAN    CrossLinkDetected,
    OUT     PULONG      CrossLinkPreviousCluster
    )
/*++

Routine Description:

    This routine goes through all of the FAT entries in the chain beginning
    with cluster 'StartingCluster'.  It is expected that all of the entries
    in this chain point to valid clusters on the disk.  This routine will
    mark the first invalid entry, if any, as the final cluster of the chain
    thus transforming the invalid chain into a valid one.

    This routine will also eliminate any cycles in the cluster chain as well
    as detect cross-links.

Arguments:

    StartingCluster             - Supplies the first cluster of the chain to
                                    scrub.
    UsedClusters                - Supplies a bitvector marking all used
                                    clusters.
    ChangesMade                 - Returns TRUE if changes were made to correct
                                    the chain.
    CrossLinkDetected           - Returns TRUE if a cluster in the chain was
                                    already claimed in the 'FatBitMap'.
    CrossLinkPreviousCluster    - Returns the cluster number previous to the
                                    cross linked cluster number or 0 if the
                                    cross linked cluster number was the first
                                    in the chain.

Return Value:

    None.

--*/
{
    ULONG    clus, next;

    DebugAssert(IsInRange(StartingCluster));
    DebugAssert(ChangesMade);
    DebugAssert(CrossLinkDetected);
    DebugAssert(CrossLinkPreviousCluster);

    *ChangesMade = FALSE;
    *CrossLinkDetected = FALSE;

    if (FatBitMap->IsBitSet(StartingCluster)) {
        *CrossLinkDetected = TRUE;
        *CrossLinkPreviousCluster = 0;
        return;
    }

    clus = StartingCluster;
    while (!IsEndOfChain(clus)) {

        FatBitMap->SetBit(clus);

        next = QueryEntry(clus);
        if (!IsInRange(next) || IsClusterFree(next)) {
            SetEndOfChain(clus);
            *ChangesMade = TRUE;
            return;
        }

        if (FatBitMap->IsBitSet(next)) {

            if (clus == next) {       // Cluster points to itself.
                *ChangesMade = TRUE;
                SetEndOfChain(clus);
                return;
            }

            while (StartingCluster != clus) {

                if (StartingCluster == next) { // Cluster points to previous.
                    *ChangesMade = TRUE;
                    SetEndOfChain(clus);
                    return;
                }

                StartingCluster = QueryEntry(StartingCluster);
            }

            // Otherwise it's a cross link, not a cycle.

            *CrossLinkDetected = TRUE;
            *CrossLinkPreviousCluster = clus;
            return;
        }

        clus = next;
    }

    FatBitMap->SetBit(clus);
}

NONVIRTUAL
BOOLEAN
FAT::IsValidChain(
    IN  ULONG    StartingCluster
    ) CONST
/*++

Routine Description:

    This method determines whether the chain is valid, ie. that it
    consists of a chain of valid cluster numbers ending with an end
    of chain entry.

Arguments:

    StartingCluster - Supplies the first cluster of the chain.

Return Value:

    TRUE if the chain is valid.

--*/
{
    ULONG    current;
    ULONG    clusters_in_chain = 0;

    current = StartingCluster;

    for( ;; ) {

        if (!IsInRange(current) ||
            clusters_in_chain++ > _num_entries ) {

            // Either a bad entry or an infinite loop detected.
            //
            return FALSE;
        }

        if (IsEndOfChain(current)) {
            break;
        }

        current = QueryEntry(current);
    }

    return TRUE;
}


UFAT_EXPORT
ULONG
FAT::AllocChain(
    IN  ULONG    Length,
    OUT PULONG   LastCluster
    )
/*++

Routine Description:

    This routine attempts to allocate a chain of length 'Length' from the
    FAT.  If this routine is successful it will return the cluster number
    of the beginning of the chain.  Upon failure this routine will return
    0 and will make no changes to the FAT.

Arguments:

    Length      - Supplies the length of the chain desired.
    LastCluster - Returns the last cluster of the allocated chain.

Return Value:

    The cluster number of the beginning of the allocated chain or 0.

--*/
{
    ULONG    i, j;
    ULONG    start;
    ULONG    prev;

    if (!Length) {
        return 0;
    }

    start = 0;
    prev = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterFree(i)) {
            if (!start) {
                start = i;
            } else {
                SetEntry(prev, i);
            }
            prev = i;
            Length--;
            if (!Length) {
                SetEndOfChain(i);

                if (LastCluster) {
                    *LastCluster = i;
                }

                return start;
            }
        }
    }

    // There is not enough disk space for the chain so free what was taken.
    for (i = start; i != prev; ) {
        j = QueryEntry(i);
        SetClusterFree(i);
        i = j;
    }

    return 0;
}


ULONG
FAT::ReAllocChain(
    IN  ULONG    StartOfChain,
    IN  ULONG    NewLength,
    OUT PULONG   LastCluster
    )
/*++

Routine Description:

    This routine insures that the cluster chain beginning at cluster
    'StartOfChain' is of length greater than or equal to 'NewSize'.
    If it is not then this routine will attempt to grow the chain by
    allocating new clusters.  Failure to allocate sufficient clusters
    to grow the chain to 'NewSize' clusters will cause this routine to
    restore the chain to its original length and state.  This routine will
    return the current length of the chain : either the old length or the
    new length.  If an error occurs then 0 will be returned.

Arguments:

    StartOfChain    - Supplies the first cluster of the chain.
    NewLength       - Supplies the desired new length of the chain.
    LastCluster     - Returns the last cluster of the chain.

Return Value:

    The current length of the chain or 0.

--*/
{
    ULONG    length;
    ULONG    new_clusters_needed;
    ULONG    end_of_chain;
    ULONG    i, j;
    ULONG    start;

    if (!IsInRange(StartOfChain)) {
        return 0;
    }

    for (length = 1; !IsEndOfChain(StartOfChain); length++) {
        StartOfChain = QueryEntry(StartOfChain);
        if (!IsInRange(StartOfChain)) {
            return 0;
        }
    }

    if (length >= NewLength) {
        if (LastCluster) {
            *LastCluster = StartOfChain;
        }
        return length;
    }

    new_clusters_needed = NewLength - length;

    start = end_of_chain = StartOfChain;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterFree(i)) {
            SetEntry(end_of_chain, i);
            end_of_chain = i;
            new_clusters_needed--;
            if (!new_clusters_needed) {
                SetEndOfChain(i);
                if (LastCluster) {
                    *LastCluster = i;
                }
                return NewLength;
            }
        }
    }

    // There is not enough disk space to lengthen the new chain so
    // settle for the old length.

    for (i = start; i != end_of_chain; ) {
        j = QueryEntry(i);
        SetClusterFree(i);
        i = j;
    }

    SetEndOfChain(start);

    if (LastCluster) {
        *LastCluster = start;
    }

    return length;
}


UFAT_EXPORT
VOID
FAT::FreeChain(
    IN  ULONG    StartOfChain
    )
/*++

Routine Description:

    This routine sets free all of the clusters in the cluster chain
    beginning with 'StartOfChain'.

Arguments:

    StartOfChain    - Supplies the first cluster of the chain to free.

Return Value:

    None.

--*/
{
    ULONG    tmp;

    while (!IsEndOfChain(StartOfChain)) {
        tmp = QueryEntry(StartOfChain);
        SetClusterFree(StartOfChain);
        StartOfChain = tmp;
    }
    SetClusterFree(StartOfChain);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\easet.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    easet.cxx

Abstract:

    This class models an EA set.

Author:

    Norbert P. Kusters (norbertk) 28-Nov-90

Notes:

    There are minor alignment problems here.

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( EA_SET, CLUSTER_CHAIN, UFAT_EXPORT );

VOID
EA_SET::Construct (
        )
/*++

Routine Description:

        Constructor for EA_SET.  Sets private data to default values.

Arguments:

        None.

Return Value:

        None.

--*/
{
   memset(&_eahdr, 0, sizeof(_eahdr));
   _size = 0;
   _size_imposed = FALSE;
   _current_ea = NULL;
   _current_index = 0;
}


UFAT_EXPORT
EA_SET::~EA_SET(
    )
/*++

Routine Description:

    Destructor for EA_SET.  Frees memory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
EA_SET::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PFAT_SA             FatSuperArea,
    IN      PCFAT               Fat,
    IN      ULONG               ClusterNumber,
    IN      ULONG               LengthOfChain
    )
/*++

Routine Description:

    This routine initialize the EA_SET to model the EA set which resides
    at FAT cluster 'ClusterNumber'.

Arguments:

    Mem             - Supplies the memory for the cluster chain.
    Drive           - Supplies the drive where the EA set is contained.
    FatSuperArea    - Supplies the important drive parameters.
    Fat             - Supplies the file allocation table.
    StartingCluster - Supplies the starting cluster of the EA set.
    LengthOfChain   - Supplies the length of the cluster chai which contains
                        the EA set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM    hmem;
    ULONG   cluster_size;
    ULONG   sector_size;

    Destroy();

    if (!FatSuperArea || !Drive || !(sector_size = Drive->QuerySectorSize())) {
        DebugPrintTrace(("UFAT: Failure to initialize EA_SET %d\n", 1));
        Destroy();
        return FALSE;
    }

    cluster_size = sector_size*FatSuperArea->QuerySectorsPerCluster();

    if (!LengthOfChain) {
        if (!hmem.Initialize() ||
            !CLUSTER_CHAIN::Initialize(&hmem, Drive, FatSuperArea, Fat,
                                       ClusterNumber, 1) ||
            !Read()) {
            DebugPrintTrace(("UFAT: Failure to initialize EA_SET %d\n", 2));
            Destroy();
            return FALSE;
        }

        _size = _eahdr.TotalSize + SizeOfEaHdr - sizeof(LONG);
        _size_imposed = TRUE;

        if (_size%cluster_size) {
            LengthOfChain = (USHORT) (_size/cluster_size + 1);
        } else {
            LengthOfChain = (USHORT) (_size/cluster_size);
        }
    } else {
        _size = cluster_size*LengthOfChain;
        _size_imposed = FALSE;
    }


    if (!CLUSTER_CHAIN::Initialize(Mem, Drive, FatSuperArea, Fat,
                                   ClusterNumber, LengthOfChain)) {
        DebugPrintTrace(("UFAT: Failure to initialize EA_SET %d\n", 3));
        Destroy();
        return FALSE;
    }

    return TRUE;
}


UFAT_EXPORT
BOOLEAN
EA_SET::Read(
    )
/*++

Routine Description:

    This routine reads the cluster chain and then unpacks the ea header.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LONG    size;


    if (!CLUSTER_CHAIN::Read() || !UnPackEaHeader()) {
        return FALSE;
    }

    size = _eahdr.TotalSize + SizeOfEaHdr - sizeof(LONG);
    if (size < _size) {
        _size = size;
        _size_imposed = TRUE;
    }

    return TRUE;
}


UFAT_EXPORT
PEA
EA_SET::GetEa(
    IN  ULONG       Index,
    OUT PLONG       EaSize,
    OUT PBOOLEAN    PossiblyMore
    )
/*++

Routine Description:

    This routine returns a pointer to the Index'th EA.  An Index of 0
    indicates the first EA and so on.  A NULL pointer will be returned if
    the Index'th EA does not exist.

    This routine will validate the EA before returning it.  If the EA is
    invalid then NULL will be returned.

    The return value 'PossiblyMore' will only be computed in the event
    that the EA at index 'Index' can't be found.  It is used to indicate
    that there may be another EA in the next cluster of the cluster chain.

Arguments:

    Index   - Supplies which EA is requested.
    EaSize  - Returns the size of the EA.
    PossiblyMore    - Returns TRUE if there may possibly be more EAs in
                        a cluster beyond the boundary of the cluster chain.
                        Returns FALSE if this is impossible.

Return Value:

    A pointer to an EA structure or NULL.

--*/
{
    ULONG   i;
    PEA     r;
    PCHAR   p, b;
    ULONG   offset;

    if (PossiblyMore) {
        *PossiblyMore = FALSE;
    }

    if (!(b = (PCHAR) GetBuf())) {
        DebugPrintTrace(("UFAT: Failure to GetEa in EA_SET\n"));
        return NULL;
    }

    if (!_current_ea || Index < _current_index) {
        p = (PCHAR) (r = (PEA) (b + SizeOfEaHdr));

        if (!r->NameSize || !r->ValueSize[0] && !r->ValueSize[1]) {
            return NULL;
        }

        offset = sizeof(EA) + r->NameSize + r->ValueSize[0] +
                 (r->ValueSize[1]<<8);

        if (p - b + offset > (ULONG)_size) {
            if (PossiblyMore && !_size_imposed) {
                *PossiblyMore = TRUE;
            }

            return NULL;
        }

        if (p[sizeof(EA) + r->NameSize - 1]) {
            return NULL;
        }

        _current_index = 0;
    } else {
        p = (PCHAR) (r = _current_ea);

        offset = sizeof(EA) + r->NameSize + r->ValueSize[0] +
                (r->ValueSize[1]<<8);
    }

    for (i = _current_index; i < Index; i++) {
        r = (PEA) (p += offset);

        if (p - b + sizeof(EA) > (ULONG)_size) {
            if (PossiblyMore && !_size_imposed) {
                *PossiblyMore = TRUE;
            }

            return NULL;
        }

        if (!r->NameSize || !r->ValueSize[0] && !r->ValueSize[1]) {
            return NULL;
        }

        offset = sizeof(EA) + r->NameSize + r->ValueSize[0] +
                (r->ValueSize[1]<<8);

        if (p - b + offset > (ULONG)_size) {
            if (PossiblyMore && !_size_imposed) {
                *PossiblyMore = TRUE;
            }

            return NULL;
        }

        if (p[sizeof(EA) + r->NameSize - 1]) {
            return NULL;
        }
    }

    _current_index = i;
    _current_ea = r;

    if (EaSize) {
        *EaSize = offset;
    }

    return r;
}


VOID
EA_SET::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    memset(&_eahdr, 0, sizeof(_eahdr));
    _size = 0;
    _size_imposed = FALSE;
    _current_ea = NULL;
    _current_index = 0;
}


BOOLEAN
EA_SET::PackEaHeader(
    )
/*++

Routine Description:

    This routine packs the EA set header.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PPACKED_EA_HDR  peahdr;

    if (!(peahdr = (PPACKED_EA_HDR) GetBuf())) {
        DebugPrintTrace(("UFAT: Failure to PackEaHeader in EA_SET\n"));
        return FALSE;
    }

    peahdr->Signature = _eahdr.Signature;
    peahdr->OwnHandle = _eahdr.OwnHandle;
    peahdr->NeedCount = _eahdr.NeedCount;
    memcpy(peahdr->OwnerFileName, _eahdr.OwnerFileName, 14);
    memcpy(peahdr->Reserved, &_eahdr.Reserved, sizeof(ULONG));
    memcpy(peahdr->TotalSize, &_eahdr.TotalSize, sizeof(LONG));

    return TRUE;
}


BOOLEAN
EA_SET::UnPackEaHeader(
    )
/*++

Routine Description:

    This routine unpacks the EA set header.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PPACKED_EA_HDR  peahdr;

    if (!(peahdr = (PPACKED_EA_HDR) GetBuf())) {
        DebugPrintTrace(("UFAT: Failure to UnPackEaHeader in EA_SET\n"));
        return FALSE;
    }

    _eahdr.Signature = peahdr->Signature;
    _eahdr.OwnHandle = peahdr->OwnHandle;
    _eahdr.NeedCount = peahdr->NeedCount;
    memcpy(_eahdr.OwnerFileName, peahdr->OwnerFileName, 14);
    memcpy(&_eahdr.Reserved, peahdr->Reserved, sizeof(ULONG));
    memcpy(&_eahdr.TotalSize, peahdr->TotalSize, sizeof(LONG));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\fatdent.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    fatdent.cxx

Abstract:

    This class models a FAT directory entry.

Author:

    Norbert P. Kusters (norbertk) 4-Dec-90

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "ifssys.hxx"
#include "wstring.hxx"

// TimeInfo is full of windows stuff.
#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

#include "timeinfo.hxx"

#endif


DEFINE_EXPORTED_CONSTRUCTOR( FAT_DIRENT, OBJECT, UFAT_EXPORT );

VOID
FAT_DIRENT::Construct (
        )
/*++

Routine Description:

    Constructor for FAT_DIRENT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _dirent = NULL;
}


UFAT_EXPORT
FAT_DIRENT::~FAT_DIRENT(
    )
/*++

Routine Description:

    Destructor for FAT_DIRENT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
FAT_DIRENT::Initialize(
    IN OUT  PVOID   Dirent
    )
/*++

Routine Description:

    This routine initializes the object to use the directory entry
    pointed to by Dirent.

Arguments:

    Dirent  - Supplies the directory entry.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _dirent = (PUCHAR) Dirent;
    _FatType = FAT_TYPE_UNKNOWN;
    return _dirent ? TRUE : FALSE;
}


UFAT_EXPORT
BOOLEAN
FAT_DIRENT::Initialize(
    IN OUT  PVOID   Dirent,
    IN      UCHAR   FatType
    )
/*++

Routine Description:

    This routine initializes the object to use the directory entry
    pointed to by Dirent.

Arguments:

    Dirent  - Supplies the directory entry.
    FatType - Supplies the FAT type.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _dirent = (PUCHAR) Dirent;
    _FatType = FatType;
    return _dirent ? TRUE : FALSE;
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::QueryName(
    OUT PWSTRING    Name
    ) CONST
/*++

Routine Description:

    This routine copies the directory entries name to 'Name' in an
    appropriate format.

    Directories and files will be returned in compressed 8.3 format.
    Labels will be returned in compressed 11 character format.

Arguments:

    Name    - Returns the name of the directory entry in the appropriate
              format.

Return Value:

    None.

--*/
{
    LONG    i;
    STR     buf[80];
    DSTRING tmp_string;
    DSTRING tmp2;
    CHNUM   l;

    if (!_dirent) {
        return Name->Initialize();
    }

    if (IsVolumeLabel()) {
        memcpy(buf, _dirent, 11);
        buf[11] = 0;

        if (buf[0] == 0x05) {
            buf[0] = (UCHAR)0xE5;
        }

        if (!tmp_string.Initialize(buf))
            return FALSE;

        l = tmp_string.QueryChCount();

        for (i = l - 1; i >= 0 && tmp_string.QueryChAt(i) == ' '; i--) {
        }

        return Name->Initialize(&tmp_string, 0, i + 1);
    }

    memcpy(buf, _dirent, 8);
    buf[8] = 0;

    if (buf[0] == 0x05) {
        buf[0] = (UCHAR)0xE5;
    }

    if (!tmp_string.Initialize(buf))
        return FALSE;

    if (Is8LowerCase()) {
        tmp_string.Strlwr(0);
    }

    l = tmp_string.QueryChCount();

    // Remove trailing white spaces
    for (i = l - 1; i >= 0 && tmp_string.QueryChAt(i) == ' '; i--) {
    }

    if (!Name->Initialize(&tmp_string, 0, i + 1))
        return FALSE;

    memcpy(buf, &_dirent[8], 3);
    buf[3] = 0;

    if (!tmp_string.Initialize(buf))
        return FALSE;

    if (Is3LowerCase()) {
        tmp_string.Strlwr(0);
    }

    l = tmp_string.QueryChCount();

    for (i = l - 1; i >= 0 && tmp_string.QueryChAt(i) == ' '; i--) {
    }

    if (i + 1) {
        if (!tmp2.Initialize(".") ||
            !Name->Strcat(&tmp2) ||
            !tmp2.Initialize(&tmp_string, 0, i + 1) ||
            !Name->Strcat(&tmp2))
            return FALSE;
    }
    return TRUE;
}

extern VOID DoInsufMemory(VOID);

BOOLEAN
FAT_DIRENT::SetName(
    IN  PCWSTRING   Name
    )
/*++

Routine Description:

    This routine expects a "compressed" null-terminated name in a format
    compatible with the return value of 'QueryName'.

    The validity of the characters in the name will not be checked
    by this routine.  Only that the name has the appropriate
    structure.  The routine "IsValidName" will check the validity
    of the name characters.

Arguments:

    Name    - Supplies the new name for the directory entry.

Return Value:

    FALSE   - The name was invalid.
    TRUE    - The name was successfully set.

--*/
{
    CHNUM   i, j;
    STR     buf[40];
    CHNUM   l;
    DSTRING tmp_string;

    if (IsVolumeLabel()) {
       if (!Name->QuerySTR( 0, TO_END, buf, 40) ||
           (i = strlen(buf)) > 11) {
          return FALSE;
       }

       if (!FAT_SA::IsValidString(Name)) {
          return FALSE;
       }

       memset(&_dirent[i], ' ', (UINT) (11 - i));
       memcpy(_dirent, buf, (UINT) i);

       if (_dirent[0] == 0xE5) {
          _dirent[0] = 0x05;
       }

       return TRUE;
    }

    l = Name->QueryChCount();

    if (Name->QueryChAt(0) == '.' && l == 1) {
        memcpy(_dirent, ".          ", 11);
        return TRUE;
    } else if (Name->QueryChAt(0) == '.' &&
               Name->QueryChAt(1) == '.' &&
               l == 2) {
        memcpy(_dirent, "..         ", 11);
        return TRUE;
    }


    for (i = 0; i < l && Name->QueryChAt(i) != '.'; i++) {
    }

    if (!tmp_string.Initialize(Name, 0, i)) {
    DoInsufMemory();
        return FALSE;
    }

    if (!tmp_string.QuerySTR( 0, TO_END, buf, 40)) {
        return FALSE;
    }

    if ((j = strlen(buf)) > 8) {
        return FALSE;
    }

    memset(&buf[j], ' ', (UINT) (11 - j));

    if (i < l) {
        for (j = i + 1; j < l && Name->QueryChAt(j) != '.'; j++) {
        }

        if (j < l) {
            return FALSE;
        }

        if (i + 1 < l) {
            if (!tmp_string.Initialize(Name, i + 1)) {
        DoInsufMemory();
                return FALSE;
            }

        if (!tmp_string.QuerySTR( 0, TO_END, &buf[8], 32)) {
                return FALSE;
            }

            if ((j = strlen(buf)) > 11) {
                return FALSE;
            }

            memset(&buf[j], ' ', (UINT) (11 - j));
        }
    }

    memcpy(_dirent, buf, 11);

    if (_dirent[0] == 0xE5) {
        _dirent[0] = 0x05;
    }

    return TRUE;
}


BOOLEAN
FAT_DIRENT::IsValidName(
    ) CONST
/*++

Routine Description:

    This routine verifies that the name is composed of valid
    characters.

Arguments:

    None.

Return Value:

    FALSE   - The name is not valid.
    TRUE    - The name is valid.

--*/
{
    DSTRING tmp;
    STR     buf[40];

    // There isn't much to validate as there is no telling of what
    // code page is used when those names are created especially
    // if DBCS.

#if 1
    return TRUE;
#else
    if (!_dirent) {
        DebugPrintTrace(("UFAT: Failure in IsValidName in FAT_DIRENT\n"));
        return FALSE;
    }

    if (IsDot() || IsDotDot()) {
        return IsDirectory();
    }

    memcpy(buf, _dirent, 11);
    buf[11] = 0;

    if (buf[0] == 0x05) {
        buf[0] = (UCHAR)0xE5;
    }

    if (!tmp.Initialize(buf)) {
        return FALSE;
    }

    return FAT_SA::IsValidString(&tmp);
#endif
}


UFAT_EXPORT
BOOLEAN
FAT_DIRENT::IsValidLastWriteTime(
    ) CONST
/*++

Routine Description:

    This routine verifies the validity of the last write time.

Arguments:

    None.

Return Value:

    FALSE   - Invalid time stamp.
    TRUE    - Valid time stamp.

--*/
{
    USHORT  t;
    USHORT  d;

    DebugAssert(_dirent);

    memcpy(&t, &_dirent[22], sizeof(USHORT)); // time field
    memcpy(&d, &_dirent[24], sizeof(USHORT)); // date field

    return TimeStampsAreValid(t, d);
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::QueryLastWriteTime(
    OUT LARGE_INTEGER   *TimeStamp
    ) CONST
/*++

Routine Description:

    This routine returns the last write time in the form of a time fields
    structure.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

    TIME_FIELDS TimeFields;
    USHORT      t;
    USHORT      d;
    USHORT      year, month, day, hour, minute, second;

    DebugAssert( _dirent );
    DebugPtrAssert( TimeStamp );

    memcpy(&t, &_dirent[22], sizeof(USHORT)); // time field
    memcpy(&d, &_dirent[24], sizeof(USHORT)); // date field

    second  = (t&0x001F)*2;     // seconds
    minute  = (t&0x07E0)>>5;    // Minutes
    hour    = t>>11;            // Hours
    day     = d&0x001F;         // Day of month 1-31
    month   = (d&0x01E0)>>5;    // Month
    year    = (d>>9) + 1980;    // Year

    TimeFields.Year         = year;
    TimeFields.Month        = month;
    TimeFields.Day          = day;
    TimeFields.Hour         = hour;
    TimeFields.Minute       = minute;
    TimeFields.Second       = second;
    TimeFields.Milliseconds = 0;

    return RtlTimeFieldsToTime( &TimeFields, (PTIME)TimeStamp );
}



BOOLEAN
FAT_DIRENT::SetLastWriteTime(
    )
/*++

Routine Description:

    This routine sets the last write time to the current date and time.

Arguments:

    None.

Return Value:

    FALSE   - Time stamp was not set successfully.
    TRUE    - Time stamp was set successfully.

--*/
{
    USHORT  fat_time;
    USHORT  fat_date;

    DebugAssert(_dirent);

    LARGE_INTEGER SystemTime, LocalTime;
    TIME_FIELDS Time;


#if !defined( _SETUP_LOADER_ )
    IFS_SYSTEM::QueryNtfsTime( &SystemTime );
    RtlSystemTimeToLocalTime( &SystemTime, &LocalTime );
#else
    IFS_SYSTEM::QueryNtfsTime( &LocalTime );
#endif

    RtlTimeToTimeFields(&LocalTime, &Time);

    fat_time = Time.Second/2;
    fat_time |= Time.Minute<<5;
    fat_time |= Time.Hour<<11;

    fat_date = Time.Day;
    fat_date |= Time.Month<<5;
    fat_date |= (Time.Year - 1980)<<9;

        memcpy(&_dirent[22], &fat_time, sizeof(USHORT));
    memcpy(&_dirent[24], &fat_date, sizeof(USHORT));

    return TRUE;
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::IsValidCreationTime(
    ) CONST
/*++

Routine Description:

    This routine verifies the validity of the creation time.

Arguments:

    None.

Return Value:

    FALSE   - Invalid time stamp.
    TRUE    - Valid time stamp.

--*/
{
    USHORT  t;
    USHORT  d;

    DebugAssert(_dirent);

    memcpy(&t, &_dirent[14], sizeof(USHORT)); // time field
    memcpy(&d, &_dirent[16], sizeof(USHORT)); // date field

    return TimeStampsAreValid(t, d);

}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::QueryCreationTime(
    OUT LARGE_INTEGER   *TimeStamp
    ) CONST
/*++

Routine Description:

    This routine returns the creation time in the form of a time fields
    structure.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    TIME_FIELDS TimeFields;
    USHORT      t;
    USHORT      d;
    USHORT      msec;
    USHORT      year, month, day, hour, minute, second;

    DebugAssert( _dirent );
    DebugPtrAssert( TimeStamp );

    memcpy(&t, &_dirent[14], sizeof(USHORT)); // time field
    memcpy(&d, &_dirent[16], sizeof(USHORT)); // date field
    msec = _dirent[13] * 10;                  // msec field

    second  = (t&0x001F)*2;     // seconds
    minute  = (t&0x07E0)>>5;    // Minutes
    hour    = t>>11;            // Hours
    day     = d&0x001F;         // Day of month 1-31
    month   = (d&0x01E0)>>5;    // Month
    year    = (d>>9) + 1980;    // Year

    if (msec >= 1000) {
        second += 1;
        msec -= 1000;
    }

    TimeFields.Year         = year;
    TimeFields.Month        = month;
    TimeFields.Day          = day;
    TimeFields.Hour         = hour;
    TimeFields.Minute       = minute;
    TimeFields.Second       = second;
    TimeFields.Milliseconds = msec;

    return RtlTimeFieldsToTime( &TimeFields, (PTIME)TimeStamp );
}

BOOLEAN
FAT_DIRENT::SetCreationTime(
    )
/*++

Routine Description:

    This routine sets the creation time to the current date and time.

Arguments:

    None.

Return Value:

    FALSE   - Time stamp was not set successfully.
    TRUE    - Time stamp was set successfully.

--*/
{
    USHORT  fat_time;
    USHORT  fat_date;

    DebugAssert(_dirent);

    LARGE_INTEGER SystemTime, LocalTime;
    TIME_FIELDS Time;


#if !defined( _SETUP_LOADER_ )
    IFS_SYSTEM::QueryNtfsTime( &SystemTime );
    RtlSystemTimeToLocalTime( &SystemTime, &LocalTime );
#else
    IFS_SYSTEM::QueryNtfsTime( &LocalTime );
#endif

    RtlTimeToTimeFields(&LocalTime, &Time);

    fat_time = Time.Second/2;
    fat_time |= Time.Minute<<5;
    fat_time |= Time.Hour<<11;

    fat_date = Time.Day;
    fat_date |= Time.Month<<5;
    fat_date |= (Time.Year - 1980)<<9;

    memcpy(&_dirent[14], &fat_time, sizeof(USHORT));
    memcpy(&_dirent[16], &fat_date, sizeof(USHORT));

    return TRUE;
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::IsValidLastAccessTime(
    ) CONST
/*++

Routine Description:

    This routine verifies the validity of the last access time.

Arguments:

    None.

Return Value:

    FALSE   - Invalid time stamp.
    TRUE    - Valid time stamp.

--*/
{
    USHORT  t = 0;
    USHORT  d;

    DebugAssert(_dirent);

    memcpy(&d, &_dirent[18], sizeof(USHORT)); // date field

    return TimeStampsAreValid(t, d);
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::QueryLastAccessTime(
    OUT LARGE_INTEGER   *TimeStamp
    ) CONST
/*++

Routine Description:

    This routine returns the last access time in the form of a time fields
    structure.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

    TIME_FIELDS TimeFields;
    USHORT      t;
    USHORT      d;
    USHORT      year, month, day, hour, minute, second;

    DebugAssert( _dirent );
    DebugPtrAssert( TimeStamp );

    t = 0;                                    // no time for last access; just date
    memcpy(&d, &_dirent[18], sizeof(USHORT)); // date field

    second  = (t&0x001F)*2;     // seconds
    minute  = (t&0x07E0)>>5;    // Minutes
    hour    = t>>11;            // Hours
    day     = d&0x001F;         // Day of month 1-31
    month   = (d&0x01E0)>>5;    // Month
    year    = (d>>9) + 1980;    // Year

    TimeFields.Year         = year;
    TimeFields.Month        = month;
    TimeFields.Day          = day;
    TimeFields.Hour         = hour;
    TimeFields.Minute       = minute;
    TimeFields.Second       = second;
    TimeFields.Milliseconds = 0;

    return RtlTimeFieldsToTime( &TimeFields, (PTIME)TimeStamp );
}

BOOLEAN
FAT_DIRENT::SetLastAccessTime(
    )
/*++

Routine Description:

    This routine sets the last access time to the current date and time.

Arguments:

    None.

Return Value:

    FALSE   - Time stamp was not set successfully.
    TRUE    - Time stamp was set successfully.

--*/
{
    USHORT  fat_date;

    DebugAssert(_dirent);

    LARGE_INTEGER SystemTime, LocalTime;
    TIME_FIELDS Time;


#if !defined( _SETUP_LOADER_ )
    IFS_SYSTEM::QueryNtfsTime( &SystemTime );
    RtlSystemTimeToLocalTime( &SystemTime, &LocalTime );
#else
    IFS_SYSTEM::QueryNtfsTime( &LocalTime );
#endif

    RtlTimeToTimeFields(&LocalTime, &Time);

    fat_date = Time.Day;
    fat_date |= Time.Month<<5;
    fat_date |= (Time.Year - 1980)<<9;

    memcpy(&_dirent[18], &fat_date, sizeof(USHORT));

    return TRUE;
}

VOID
FAT_DIRENT::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _dirent = NULL;
}

UCHAR
RotateCharRight(
    IN  UCHAR   Char,
    IN  INT     Shift
    )
/*++

Routine Description:

    This function rotates an eight-bit character right by the
    specified number of bits.

Arguments:

    Char    --  Supplies the character to rotate
    Shift   --  Supplies the number of bits to shift

Return Value:

    The rotated character.

--*/
{
    UCHAR low_bit;

    Shift %= 8;

    while( Shift-- ) {

        low_bit = Char & 1;
        Char >>= 1;
        if( low_bit ) {
            Char |= 0x80;
        }
    }

    return (UCHAR)Char;
}

UCHAR
FAT_DIRENT::QueryChecksum(
    ) CONST

/*++

Routine Description:

    This method gets the checksum from the directory entry.  If
    the entry is a short entry, the checksum is computed; if the
    entry is long, the checksum field is returned.

Arguments:

    None.

Return Value:

    The directory entry's checksum.

--*/
{
    int name_length;
    UCHAR sum;
    PUCHAR name;

    if( IsLongEntry() ) {

        return( _dirent[13] );

    } else {

        sum = 0;
        name = _dirent;
        for( name_length = 11; name_length != 0; name_length-- ) {

            sum = RotateCharRight(sum, 1) + *name++;
        }

        return( sum );
    }
}

BOOLEAN
FAT_DIRENT::IsWellTerminatedLongNameEntry(
    ) CONST
/*++

Routine Description:

    This method determines whether the entry is a well-terminated
    long-name entry.  A long-name entry is well terminated if:


--*/
{
    ULONG   i;
    WCHAR   Name[13];

    if( IsErased() || !IsLongNameEntry() ) {

        return FALSE;
    }

    // Assemble the bits and pieces of the name:
    //
    memcpy( &Name[0], &_dirent[1], 10 );
    memcpy( &Name[5], &_dirent[14], 12 );
    memcpy( &Name[11], &_dirent[28], 4 );

    if( IsLastLongEntry() ) {

        //
        // Valid syntax for the last name entry is:
        //
        //     N* {0 0xFFFF*}
        //
        // where N is the set of non-null characters.
        //
        for( i = 0; i < 13; i++ ) {

            if( Name[i] == 0 ) {

                break;
            }
        }

        if( i < 13 ) {

            //
            // We hit a null character--step over it.
            //
            i++;
        }

        //
        // The rest of the name-component must be 0xFFFF.
        //
        for( ; i < 13; i++ ) {

            if( Name[i] != 0xFFFF ) {

                return FALSE;
            }
        }

        // This name-component was accepted.
        //
        return TRUE;

    } else {

#if 0
        // This is an additional consistency check that
        // could be performed; however, now (as of 3/28/94)
        // the file-system doesn't care, so neither do we.

        // This is not the last component of the name, so
        // it can't have any NULL's in it.
        //
        for( i = 0; i < 13; i++ ) {

            if( Name[i] == 0 ) {

                return FALSE;
            }
        }
#endif

        return TRUE;
    }
}

BOOLEAN
FAT_DIRENT::QueryLongNameComponent(
    OUT PWSTRING    NameComponent
    ) CONST
/*++

Routine Description:

    This method extracts the long-name component from a Long Name
    Directory Entry.

Arguments:

    NameComponent   --  Receives the long-name component

Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG   i;
    WCHAR   Name[13];

    if( IsErased() || !IsLongNameEntry() ) {

        return FALSE;
    }

    // Assemble the bits and pieces of the name:
    //
    memcpy( &Name[0], &_dirent[1], 10 );
    memcpy( &Name[5], &_dirent[14], 12 );
    memcpy( &Name[11], &_dirent[28], 4 );

    // Long names may be zero terminated; however, if the
    // name fits exactly into n long entries will not be
    // zero terminated.
    //
    for( i = 0; i < 13 && Name[i]; i++ );

    return( NameComponent->Initialize( Name, i ) );
}

BOOLEAN
FAT_DIRENT::NameHasTilde(
    ) CONST
/*++

Routine Description:

    This routine checks a short name entry to see if it contains a tilde.

Arguments:

    None.

Return Value:

    TRUE                        - Tilde.
    FALSE                       - No tilde.

--*/
{
    USHORT i;

    if (IsErased() || IsLongNameEntry()) {
        return FALSE;
    }

    for (i = 0; i < 11; ++i) {
        if ('~' == _dirent[i]) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOLEAN
FAT_DIRENT::NameHasExtendedChars(
    ) CONST
/*++

Routine Description:

    This routine determines whether there are any extended chars
    (those with value >= 0x80) in the short file name.

Arguments:

    None.

Return Value:

    TRUE    - There are one or more extended chars.
    FALSE   - There are no extended chars.

--*/
{
    USHORT i;

    if (IsErased() || IsLongNameEntry()) {
        return FALSE;
    }

    for (i = 0; i < 11; ++i) {
        if (_dirent[i] >= 0x80) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOLEAN
FAT_DIRENT::TimeStampsAreValid(
    USHORT t,
    USHORT d
    ) CONST
/*++

Routine Description:

    This routine examines the given time and date fields and
    determines whether they represent valid dates.

Arguments:

    None.

Return Value:

    TRUE    - The time and date are valid.
    FALSE   - One or both are invalid.

--*/
{
    USHORT  tmp;

    if (t != 0) {
        tmp = t&0x001F;         // 2-second increments
        if (tmp > 29) {
            return FALSE;
        }
    
        tmp = (t&0x07E0)>>5;    // Minutes
        if (tmp > 59) {
            return FALSE;
        }
    
        tmp = (t&0xF800)>>11;   // Hours
        if (tmp > 23) {
            return FALSE;
        }
    }

    if (d != 0) {
        tmp = d&0x001F;         // Day of month
        if (tmp < 1 || tmp > 31) {
            return FALSE;
        }
    
        tmp = (d&0x01E0)>>5;    // Month
        if (tmp < 1 || tmp > 12) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
FAT_DIRENT::IsValidLongName(
    PWSTRING    LongName
    )
/*++

Routine Description:

    This method validates the content of a long name.

Arguments:

    LongName    - Supplies the long name to be validated.

Return Value:

    TRUE if name is valid.

--*/
{
    ULONG   i;

    if (LongName->QueryChCount() == 0)
        return FALSE;

    for (i=0; i<LongName->QueryChCount(); i++) {
        switch (LongName->QueryChAt(i)) {
            case L'*':
            case L'?':
            case L'/':
            case L'\\':
            case L'|':
            case L':':
            case L'<':
            case L'>':
            case L'"':
                return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\fatsacnv.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UFAT_MEMBER_

#include "ulib.hxx"
#include "ufat.hxx"

#include "cluster.hxx"
#include "cmem.hxx"
#include "error.hxx"
#include "fatdent.hxx"
#include "fatsa.hxx"
#include "rootdir.hxx"
#include "rtmsg.h"
#include "sortlist.hxx"
#include "sortlit.hxx"
#include "filedir.hxx"
#include "fat.hxx"
#include "reloclus.hxx"
#include "intstack.hxx"

// #include "keyboard.hxx"


UFAT_EXPORT
BOOLEAN
FAT_SA::QueryCensusAndRelocate (
    OUT     PCENSUS_REPORT  CensusReport,
    IN OUT  PINTSTACK       RelocationStack,
    OUT     PBOOLEAN        Relocated
    )

/*++

Routine Description:

    This function serves a double purpose:

    1.- Generates a census report containing the number and size of different
        FAT structures. This report is somewhat similar to the ChkDsk report.

    2.- Relocates clusters to free areas of the disk.

    Depending on the input parameters, this method may generate the census
    report, relocate clusters, both, or none.

Arguments:

    CensusReport    -   Supplies a pointer to the buffer that will contain
                        the census report.

    RelocationStack -   Supplies a stack with the runs to be relocated.
                        The runs have to be pushed onto the stack as
                        (Start, Size) tuples, with the Size value being
                        pushed first. Both values must be given in sectors.


    Relocated       -   Supplies pointer to boolean which is set to TRUE
                        if any cluster was relocated.

Return Value:

    BOOLEAN -   TRUE if (if requested) the census report was generated and
                if (if requested) the clusters were relocated.
--*/

{
    ULONG       RelocatedChain;         //  Chain of relocated clusters
    SORTED_LIST ClustersToRelocate;     //  List of clusters to relocate

    *Relocated = FALSE;

    //
    //  Initialize the list of clusters to relocate and the relocated chain.
    //  The Relocated chain is the chain of clusters that have been relocated,
    //  it exists so that the clusters that have been freed by relocation
    //  are not re-used while relocating other clusters.
    //
    if ( !ClustersToRelocate.Initialize( ) ) {
        return FALSE;
    }

    RelocatedChain = 0;

    //
    //  If a Relocation stack is provided, relocate all clusters that can
    //  be easily relocated and put all other clusters in the
    //  ClustersToRelocate list.
    //
    //  The clusters that are easily relocated are those that are not the
    //  first cluster of a chain. These clusters can be relocated by copying
    //  their contents and then patching the chain.  Clusters that are the
    //  head of a chain require us to traverse the filesystem tree in order
    //  to locate their corresponding directory entry.
    //
    if ( RelocationStack ) {

        //
        //  InitRelocationList takes care of relocating all "easy" clusters.
        //  It puts the rest of the clusters (i.e. those that are head of
        //  chains) in the ClustersToRelocate list.
        //
        if ( !InitRelocationList( RelocationStack,
                                  &RelocatedChain,
                                  &ClustersToRelocate,
                                  Relocated ) ) {

            ClustersToRelocate.DeleteAllMembers( );

            return FALSE;
        }

        //
        //  The RelocationStack should be empty. All the clusters that it
        //  specified have either been relocated or are now in the
        //  ClustersToRelocate list.
        //
        DebugAssert( RelocationStack->QuerySize() == 0 );

    }

    //
    //  If we need to, traverse the directory tree obtaining the census
    //  and/or relocating the clusters in the ClustersToRelocate list.
    //
    if ( CensusReport || (ClustersToRelocate.QueryMemberCount() > 0 ) ) {

        if ( !DoVolumeCensusAndRelocation( CensusReport,
                                           &ClustersToRelocate,
                                           &RelocatedChain,
                                           Relocated ) ) {

            ClustersToRelocate.DeleteAllMembers( );

            return FALSE;
        }

        DebugAssert( ClustersToRelocate.QueryMemberCount() == 0 );
    }

    //
    //  All the clusters in the relocation stack have been relocated,
    //  we can now free the clusters in the RelocatedChain.
    //
    if ( RelocatedChain ) {
        _fat->FreeChain( RelocatedChain );
    }

    //
    //  Write the fat to disk
    //
    return Write();
}




BOOLEAN
FAT_SA::InitRelocationList(
    IN OUT  PINTSTACK       RelocationStack,
    IN OUT  PULONG          RelocatedChain,
    IN OUT  PSORTED_LIST    ClustersToRelocate,
    OUT     PBOOLEAN        Relocated
    )
/*++

Routine Description:

    Takes runs of sectors out of a relocation stack and converts the sectors
    into clusters. If a cluster is easily relocatable, this method relocates
    the cluster and adds the cluster to the RelocatedChain. Otherwise the
    cluster is added to the ClustersToRelocate list.

    If everything goes right, upon return the RelocationStack is empty, and
    every cluster it specified is either in the RelocatedChain or in the
    ClustersToRelocate list.

    Note that the relocation stack specifies runs of SECTORS. This method converts
    the sectors to FAT clusters.

Arguments:

    RelocationStack     -   Supplies the Relocation stack
    RelocatedChain      -   Supplies the chain of relocated clusters
    ClustersToRelocate  -   Supplies the list of cluisters to relocate
    Relocated           -   Supplies pointer to relocated flag

Return Value:

    BOOLEAN -   TRUE if all the clusters in the runs were added to some
                list.

--*/

{

    SORTED_LIST             RelocatedList;          //  List of relocated clusters
    PSORTED_LIST_ITERATOR   ToRelocateIterator;     //  Iterates over ClustersToRelocate
    PSORTED_LIST_ITERATOR   RelocatedIterator;      //  Iterates over RelocatedList
    BIG_INT                 FirstSector;            //  First sector in run
    BIG_INT                 Size;                   //  Size of run
    BIG_INT                 Sector;                 //  Iterates over each run
    ULONG                   Offset;                 //  Offset within run
    ULONG                   Cluster;                //  Cluster to move
    ULONG                   Previous;               //  Previous in chain
    RELOCATION_CLUSTER      TmpCluster;             //  Tmp. Cluster
    PRELOCATION_CLUSTER     RelCluster;             //  To put in cluster list
    UCHAR                   FatType;
    BOOLEAN                 InRange;


    DebugPtrAssert( RelocationStack   );
    DebugPtrAssert( RelocatedChain    );
    DebugPtrAssert( ClustersToRelocate);
    DebugAssert( ( RelocationStack->QuerySize() % 2 ) == 0 );

    if ( GetFileDir() )
       FatType = FAT_TYPE_FAT32;
    else
       FatType = FAT_TYPE_EAS_OKAY;

    if ( RelocatedList.Initialize()                             &&
         (RelocatedIterator  = (PSORTED_LIST_ITERATOR)(RelocatedList.QueryIterator()) )   &&
         (ToRelocateIterator = (PSORTED_LIST_ITERATOR)(ClustersToRelocate->QueryIterator()) ) ) {

        while ( RelocationStack->QuerySize() > 0 ) {

            //
            //  Take a Run (i.e. a <FirstSector, Size> tuple) off the stack.
            //
            FirstSector = RelocationStack->Look( 0 );
            Size        = RelocationStack->Look( 1 );
            RelocationStack->Pop( 2 );

            DebugPrintTrace(( "    Relocating: Sector %X, size %X\n",
                            FirstSector.GetLowPart(), Size.GetLowPart() ));

            //
            //  Convert the run into a sequence of clusters and determine
            //  what to do with those clusters.
            //
            Offset      = 0;
            while ( Offset < Size.GetLowPart() ) {

                //
                //  Get the sector to relocate
                //
                Sector = FirstSector + Offset;

                //
                //  Get the cluster in which that sector lives
                //
                Cluster = (ULONG)(((Sector - QueryStartDataLbn() )/ (ULONG)QuerySectorsPerCluster()).GetLowPart() + FirstDiskCluster);

                //
                //  Initialize the tmp. cluster and reset iterators
                //
                TmpCluster.Initialize( Cluster );
                RelocatedIterator->Reset();
                ToRelocateIterator->Reset();

                InRange = _fat->IsInRange( Cluster );

                if ( InRange ) {
                    DebugPrintTrace(( "    Cluster to relocate: %X ( Sector %X ) Contents %X \n",
                                     Cluster, Sector.GetLowPart(), _fat->QueryEntry( Cluster )));
                }
                //
                //  If the cluster is already in a list, ignore it.
                //
                if ( InRange &&
                     !RelocatedIterator->FindNext( &TmpCluster ) &&
                     !ToRelocateIterator->FindNext( &TmpCluster ) ) {

                    //
                    //  New cluster. Determine what to do with it
                    //
                    if ( !(RelCluster = NEW RELOCATION_CLUSTER) ) {
                        break;
                    }

                    RelCluster->Initialize( Cluster );

                    if ( _fat->IsClusterFree( Cluster ) ) {

                        //
                        //  The cluster is already free. Add it to the
                        //  RelocatedChain.
                        //
                        DebugPrintTrace(( "        Cluster %X already free\n", Cluster ));
                        *RelocatedChain = _fat->InsertChain( *RelocatedChain, Cluster );
                        RelocatedList.Put( RelCluster );

                    } else if ( Previous =
                                //
                                //  Assume that the clusters in the run are part of
                                //  a chain. If the previous cluster number is the
                                //  previous in the chain, then we don't have to
                                //  search the FAT
                                //
                                (_fat->QueryEntry( Cluster - 1 ) == Cluster) ?
                                ( Cluster - 1 ) :
                                _fat->QueryPrevious( Cluster ) ) {

                        //
                        //  The cluster is not the first of a chain. We can
                        //  relocate it right away.
                        //
                        DebugPrintTrace(( "        Cluster %X not head of chain\n", Cluster ));
                        if ( !RelocateOneCluster( Cluster, Previous ) ) {
                            DELETE( RelCluster );
                            break;
                        }
                        *Relocated = TRUE;
                        *RelocatedChain = _fat->InsertChain( *RelocatedChain, Cluster );
                        RelocatedList.Put( RelCluster );

                    } else if ( _fat->IsClusterBad( Cluster ) ) {

                        //
                        //  Bad cluster. We will stop relocating clusters.
                        //
                        DebugPrintTrace(( "        Cluster %X is Bad!\n", Cluster ));
                        DELETE( RelCluster );
                        break;

                    } else {

                        //
                        //  The first cluster of a chain. Some directory
                        //  must make reference to it, but we don't know
                        //  which directory, so we put the cluster in the
                        //  ClusterToRelocate list.
                        //
                        DebugPrintTrace(( "        Cluster %X head of chain\n", Cluster ));
                        ClustersToRelocate->Put( RelCluster );
                    }
                }

                Offset++;
            }

            //
            //  If could not process all the sectors in the run, something
            //  failed. Get out.
            //
            if ( Offset < Size.GetLowPart() ) {
                break;
            }
        }

        DELETE( RelocatedIterator );
        DELETE( ToRelocateIterator );
        RelocatedList.DeleteAllMembers();

        return ((RelocationStack->QuerySize() == 0) && ( Offset >= Size.GetLowPart() ) );
    }

    return FALSE;
}



BOOLEAN
FAT_SA::RelocateFirstCluster(
    IN OUT  PFAT_DIRENT Dirent
    )

/*++

Routine Description:

    Relocates the first cluster of the file described by a directory
    entry.

Arguments:

    Dirent      -   Supplies the directory entry

Return Value:

    BOOLEAN -   TRUE if cluster relocated.

--*/
{

    HMEM            Hmem;           //  Memory
    ULONG           OldCluster;     //  Original cluster
    ULONG           NewCluster;     //  New cluster
    CLUSTER_CHAIN   ClusterChain;   //  Cluster chain

    DebugPtrAssert( Dirent );

    //
    //  Allocate a free cluster
    //
    if ( !Hmem.Initialize() ||
         !( NewCluster = _fat->AllocChain( 1 ) ) ) {
        return FALSE;
    }

    //
    //  Copy the contents of the cluster to the new cluster
    //
    OldCluster = Dirent->QueryStartingCluster();

    // DebugPrintTrace(( "        Relocating cluster %X -> %X\n", OldCluster, NewCluster ));

    if ( ClusterChain.Initialize( &Hmem, _drive, this, _fat, OldCluster, 1 ) &&
         ClusterChain.Read()                                                 &&
         ClusterChain.Initialize( &Hmem, _drive, this, _fat, NewCluster, 1 ) &&
         ClusterChain.Write() ) {

        //
        //  Patch the cluster chain
        //
        _fat->SetEntry( NewCluster, _fat->QueryEntry( OldCluster ) );

        //
        //  Patch the directory entry. Note that if we crash, we're ok because
        //  the new cluster that we point to is valid. The original cluster would
        //  be an orphan and can be recovered by ChkDsk.
        //
        Dirent->SetStartingCluster( NewCluster );
        _fat->SetClusterFree( OldCluster );

        // DebugPrintTrace(( "            Directory entry patched.\n"));
        return TRUE;
    }

    //
    //  Could not relocate the cluster, Free the new cluster
    //
    _fat->FreeChain( NewCluster );
    return FALSE;
}






ULONG
FAT_SA::RelocateOneCluster(
    IN  ULONG   Cluster,
    IN  ULONG   Previous
    )

/*++

Routine Description:

    Relocates one cluster given its cluster number and the previous
    cluster in its chain.

Arguments:

    Cluster     -   Supplies cluster to relocate
    Previous    -   Supplies the previous cluster in the chain

Return Value:

    ULONG   -   Cluster where the cluster was relocated

--*/
{

    HMEM            Hmem;           //  Memory
    ULONG           NewCluster;     //  New cluster
    CLUSTER_CHAIN   ClusterChain;   //  Cluster chain

    DebugAssert( Cluster );
    DebugAssert( Previous );

    //
    //  Allocate a free cluster
    //
    if ( !Hmem.Initialize() ||
         !( NewCluster = _fat->AllocChain(1)) ) {
        return FALSE;
    }

    // DebugPrintTrace(( "        Relocating cluster %X -> %X\n", Cluster, NewCluster ));

    //
    //  Copy the contents of the cluster to the new cluster
    //
    if ( ClusterChain.Initialize( &Hmem, _drive, this, _fat, Cluster, 1 )    &&
         ClusterChain.Read()                                                 &&
         ClusterChain.Initialize( &Hmem, _drive, this, _fat, NewCluster, 1 ) &&
         ClusterChain.Write() ) {

        //
        //  Patch the chain. We set the new cluster first, so that if we crash,
        //  the previous cluster will always point to a valid cluster (either the
        //  original one or the new one), the chain will remain consistent and
        //  ChkDsk will remove orphans.
        //
        _fat->SetEntry( NewCluster, _fat->QueryEntry( Cluster ) );
        _fat->SetEntry( Previous, NewCluster );
        _fat->SetClusterFree( Cluster );

        // DebugPrintTrace(( "            Done, Chain: Prev[%X (%X)] - [%X (%X)]\n",
        //            Previous,
        //            _fat->QueryEntry(Previous),
        //            NewCluster,
        //            _fat->QueryEntry(NewCluster)
        //            ));

        return NewCluster;
    }

    //
    //  Could not relocate the cluster, Free the new cluster
    //
    _fat->FreeChain( NewCluster );
    return 0;
}






BOOLEAN
FAT_SA::DoVolumeCensusAndRelocation(
    IN OUT  PCENSUS_REPORT  CensusReport,
    IN OUT  PSORTED_LIST    ClustersToRelocate,
    IN OUT  PULONG          RelocatedChain,
    OUT     PBOOLEAN        Relocated
    )
/*++

Routine Description:

    Does a volume census and/or relocates clusters in the supplied
    relocation list.

Arguments:

    CensusReport        -   Supplies pointer to the census report structure
    ClustersToRelocate  -   Supplies pointer to list of clusters to relocate
    RelocatedChain      -   Supplies pointer to chain of relocated clusters
    Relocated           -   Supplies pointer to relocated flag

Return Value:

    BOOLEAN -   TRUE if census report obtained (if requested) and all
                the clusters in the relocation list were relocated (if
                requested).

--*/
{
    PFATDIR     RootDir;    //  Root directory
    FAT_DIRENT  DirEnt;     //  Directory entry for iterating thru directory
    DSTRING     EAFile;     //  Name of EA file
    UCHAR       FatType;

    DebugAssert( !ClustersToRelocate || RelocatedChain );

    //
    //  If there is something to do, do it.
    //
    if ( CensusReport ||
         (ClustersToRelocate && ClustersToRelocate->QueryMemberCount() > 0) ) {

        //
        //  Initialize the Census report if requested
        //
        if ( CensusReport ) {
            CensusReport->FileEntriesCount  =   0;
            CensusReport->FileClusters      =   0;
            CensusReport->DirEntriesCount   =   0;
            CensusReport->DirClusters       =   0;
            CensusReport->EaClusters        =   0;
        }

        //
        //  Get root directory
        //
        RootDir = (PFATDIR)GetRootDir();
        if ( !RootDir ) {
            RootDir = (PFATDIR)GetFileDir();
            FatType = FAT_TYPE_FAT32;
        }
        else
            FatType = FAT_TYPE_EAS_OKAY;

        DebugPtrAssert( RootDir );

        //
        //  Do the census of the volume by recursively obtaining the
        //  census of the root directory.
        //
        if ( DoDirectoryCensusAndRelocation( RootDir,
                                             CensusReport,
                                             ClustersToRelocate,
                                             RelocatedChain,
                                             Relocated ) ) {

            //
            //  If a census report is requested, find out the size of
            //  the EA file (if it exists).
            //
            if ( CensusReport ) {
                EAFile.Initialize( "EA DATA. SF" );

                if ( DirEnt.Initialize( (PFAT_DIRENT)RootDir->SearchForDirEntry( &EAFile ), FatType) ) {
                    CensusReport->EaClusters =
                       (ULONG)((ULONG)DirEnt.QueryFileSize()/
                                (_drive->QuerySectorSize()*QuerySectorsPerCluster())+1);
                }
            }
        } else {

            //
            //  Could not do the directory census
            //
            return FALSE;
        }
    }

        return TRUE;

}




BOOLEAN
FAT_SA::DoDirectoryCensusAndRelocation(
    IN OUT  PFATDIR         Directory,
    IN OUT  PCENSUS_REPORT  CensusReport,
    IN OUT  PSORTED_LIST    ClustersToRelocate,
    IN OUT  PULONG          RelocatedChain,
    OUT     PBOOLEAN        Relocated
    )
/*++

Routine Description:

    Does the census and cluster relocation of a directory an all
    its subdirectories.

Arguments:

    Directory           -   Supplies the directory
    CensusReport        -   Supplies pointer to the census report structure
    ClustersToRelocate  -   Supplies pointer to list of clusters to relocate
    RelocatedChain      -   Supplies pointer to chain of relocated clusters
    Relocated           -   Supplies pointer to relocated flag

Return Value:

    BOOLEAN -   TRUE if census report obtained (if requested) and all
                the clusters in the relocation list (if provided) that
                were references by this directory (or a subdirectory)
                were relocated.

--*/

{

    FAT_DIRENT              Dirent;                     //  For iterating thru Dir
    HMEM                    HMem;                       //  Memory
    FILEDIR                 FileDir;                    //  Subdir
    RELOCATION_CLUSTER      TmpCluster;                 //  Tmp. cluster
    PRELOCATION_CLUSTER     ClusterToRelocate;          //  Cluster to relocate
    PRELOCATION_CLUSTER     RelocatedCluster;           //  Cluster relocated
    PITERATOR               Iterator        =   NULL;   //  Iterates thru ClustersToRelocate
    ULONG                   EntryNumber     =   0;      //  Iterates thru Directorty
    BOOLEAN                 Ok              =   TRUE;   //  FALSE if error
    BOOLEAN                 RelocatedHere   =   FALSE;  //  True if relocated something
    UCHAR                   FatType;

    if ( _dir ) {
        FatType = FAT_TYPE_EAS_OKAY;
    } else {
        FatType = FAT_TYPE_FAT32;
    }

    DebugPtrAssert( Directory );

    //
    //  If there are clusters to relocate, get an iterator for searching
    //  thru the list.
    //
    if ( ClustersToRelocate && ClustersToRelocate->QueryMemberCount() > 0 ) {
        Iterator = ClustersToRelocate->QueryIterator();
        if ( !Iterator ) {
            return FALSE;
        }
    }

    while ( Ok &&
            (CensusReport || (ClustersToRelocate && ClustersToRelocate->QueryMemberCount() > 0)) ) {

        //
        //  Get next directory entry and get out if we reach the end.
        //
        if ( !Dirent.Initialize( Directory->GetDirEntry( EntryNumber ),FatType ) ||
             Dirent.IsEndOfDirectory()
            ) {
            break;
        }

        //
        //  Ignore the deleted, the "parent" and the "self" entries
        //  and any long directory entries
        //
        if ( !( Dirent.IsErased() ||
                Dirent.IsDot()    ||
                Dirent.IsDotDot() ||
                Dirent.IsLongEntry() ) ) {


            //
            //  If a Relocation list is provided, and the first cluster
            //  of the entry is in the relocation list, then relocate
            //  the cluster.
            //
            if ( ClustersToRelocate && ClustersToRelocate->QueryMemberCount() > 0 ) {

                Iterator->Reset();
                TmpCluster.Initialize( Dirent.QueryStartingCluster() );

                if ( ClusterToRelocate = (PRELOCATION_CLUSTER)Iterator->FindNext( &TmpCluster ) ) {

                    //
                    //  Cluster is in the relocation list, relocate it.
                    //
                    if ( !RelocateFirstCluster( &Dirent ) ) {
                        DebugAssert( FALSE );
                        Ok = FALSE;
                        break;
                    }


                    //
                    //  Cluster has been relocated. Remove the cluster from
                    //  the relocation list and add it to the Relocated
                    //  chain.
                    //
                    RelocatedCluster = (PRELOCATION_CLUSTER)ClustersToRelocate->Remove( Iterator );
                    DebugAssert( RelocatedCluster == ClusterToRelocate );
                    *RelocatedChain = _fat->InsertChain( *RelocatedChain, RelocatedCluster->QueryClusterNumber() );
                    DELETE( RelocatedCluster );

                    //
                    //  Set the Relocated flag so that we remember to write out
                    //  the directory when we are done traversing it.
                    //
                    *Relocated    = TRUE;
                    RelocatedHere = TRUE;

                }
            }

            if ( Dirent.IsDirectory() ) {

                //
                //  This is a directory entry, update the census
                //  (if provided) and recurse.
                //
                if( !_fat->IsValidChain( Dirent.QueryStartingCluster() ) ) {

                    Ok = FALSE;
                    break;
                }

                if ( CensusReport ) {
                    CensusReport->DirEntriesCount++;
                    CensusReport->DirClusters += _fat->QueryLengthOfChain( Dirent.QueryStartingCluster() );
                }

                if ( !HMem.Initialize()     ||

                     !FileDir.Initialize( &HMem,
                                          _drive,
                                          this,
                                          _fat,
                                          Dirent.QueryStartingCluster() ) ||

                     !FileDir.Read() ||

                     !DoDirectoryCensusAndRelocation( &FileDir,
                                                      CensusReport,
                                                      ClustersToRelocate,
                                                      RelocatedChain,
                                                      Relocated ) ) {

                    //
                    //  Something went wrong, we return failure
                    //
                    Ok = FALSE;
                    break;
                }

            } else if ( !Dirent.IsVolumeLabel() ) {

                //
                //  This is a file entry, update the census
                //  (if provided )
                //
                if( Dirent.QueryStartingCluster() != 0 &&
                    !_fat->IsValidChain( Dirent.QueryStartingCluster() ) ) {

                    Ok = FALSE;
                    break;
                }

                if ( CensusReport ) {
                    CensusReport->FileEntriesCount++;
                    CensusReport->FileClusters += _fat->QueryLengthOfChain( Dirent.QueryStartingCluster() );
                }
            }
        }

                EntryNumber++;
        }

    if ( Iterator ) {
        DELETE( Iterator );
    }

    //
    //  If we relocated something, then we have patched some entry in this
    //  directory. Write it out to disk
    //
    if ( Ok && RelocatedHere ) {
        Ok = Directory->Write();

        DebugAssert( Ok );

    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\fatsachk.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    fatsachk.cxx

Author:

    Bill McJohn (billmc) 30-May-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#include "bitvect.hxx"
#include "intstack.hxx"
#include "rtmsg.h"
#include "ifsentry.hxx"

// Timeinfo is full of windows stuff.
#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

#include "timeinfo.hxx"

#endif

#define UCHAR_SP        ' '

typedef struct _VISIT_DIR *PVISIT_DIR;
typedef struct _VISIT_DIR {
    PVISIT_DIR Next;
    PWSTRING Path;
    ULONG Cluster;
} VISIT_DIR;

extern "C" {
    #include <stdio.h>
}

extern VOID InsertSeparators(
                  LPCWSTR OutWNumber,
                  char * InANumber,
                  ULONG  Width
                );

VOID
dofmsg(
    IN      PMESSAGE    Message,
    IN OUT  PBOOLEAN    NeedErrorsMessage
    )
{
    if (*NeedErrorsMessage) {
        Message->Set(MSG_CORRECTIONS_WILL_NOT_BE_WRITTEN, NORMAL_MESSAGE, TEXT_MESSAGE);
        Message->Display();
        *NeedErrorsMessage = FALSE;
    }
}

BOOLEAN
CheckAndFixFileName(
    PVOID       DirEntry,
    PBOOLEAN    Changes
)
{
    PUCHAR      p = (PUCHAR)DirEntry;
    BOOLEAN     first_char_replaced;
    PUCHAR      backup_copy[11];
    WCHAR       unicode_string[30];
    ULONG       unicode_string_length;
    NTSTATUS    ntstatus;

#if 1
    //
    // Should not correct case error within file name because
    // different language build translates differently.  On a
    // dual boot machine containing build of two different languages,
    // the chkdsk from one build may not like what the second build
    // put onto the disk.
    //
    return TRUE;
#else

    memcpy(backup_copy, p, 11);

    first_char_replaced = (0x5 == p[0]);

    if (first_char_replaced)
        p[0] = 0xe5;

    ntstatus = RtlOemToUnicodeN(unicode_string,
                                sizeof(unicode_string),
                                &unicode_string_length,
                                (PCHAR)p,
                                11);

    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UFAT: Error in RtlOemToUnicodeN, 0x%x\n", ntstatus));
        memcpy(p, backup_copy, 11);
        return FALSE;
    }

    ntstatus = RtlUpcaseUnicodeToOemN((PCHAR)p,
                                      11,
                                      NULL,
                                      unicode_string,
                                      unicode_string_length);

    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UFAT: Error in RtlUpcaseUnicodeToOemN, 0x%x\n", ntstatus));
        memcpy(p, backup_copy, 11);
        return FALSE;
    }

    if (first_char_replaced) {
        if (0xe5 == p[0]) {
            p[0] = 0x5;
        } else {
            DebugPrintTrace(("UFAT: First byte changed to 0x%x unexpectedly\n", p[0]));
            memcpy(p, backup_copy, 11);
            return FALSE;
        }
    }

    *Changes = (memcmp(p, backup_copy, 11) != 0);

    return TRUE;
#endif
}

BOOLEAN
IsFileNameMatch(
    PFATDIR     Dir,
    UCHAR       FatType,
    ULONG       CurrentIndex,
    ULONG       MatchingIndexCount,
    PULONG      MatchingIndexArray
)
{
    ULONG   j;

    for (j = 0; j < MatchingIndexCount; j++) {

        FAT_DIRENT fd;
        ULONG      indx = MatchingIndexArray[j];

        if (!fd.Initialize(Dir->GetDirEntry(indx), FatType) ||
            fd.IsVolumeLabel()) {
            continue;
        }

        if (!memcmp(Dir->GetDirEntry(indx), Dir->GetDirEntry(CurrentIndex), 11)) {
            return TRUE;    // there is a match
        }
    }
    return FALSE;   // no match
}

BOOLEAN
RenameFileName(
    PULONG  Positions,
    PVOID   DirEntry
)
{
    PUCHAR  p = (PUCHAR)DirEntry;
    INT     i;

    if (*Positions == 0) {   // if first rename
        // find out the first char in the extension that is real
        for (i = 10; i > 7; i--)
            if (p[i] != UCHAR_SP)
                break;
        if (i >= 7 && i < 10) {  // fill the unused extension space with dashes
            for (i++; i < 10; i++)
                p[i] = '-';
        }
        *Positions = 1;
        if (p[10] != '0') {
            p[10] = '0';    // the last char of the extension gets a zero
            return TRUE;
        }
    }

    // extension chars are all in use now
    // check to see if renaming is already in progress

    for (i=10; i>=0; i--) {
        if (!(*Positions & (1 << (10-i)))) {
            *Positions |= (1 << (10-i));
            if (p[i] != '0') {
                p[i] = '0';
                return TRUE;
            }
        }
        if (p[i] >= '0' && p[i] < '9') {
            p[i]++;
            return TRUE;
        } else if (p[i] == '9') {
            p[i] = '0';
        }
    }

    // if we get here that means we have exhausted all possible name
    // shouldn't be as there are more combination than the max number
    // of files that can be in a FAT directory (65536)

    return FALSE;
}

BOOLEAN
PushVisitDir(
    IN OUT PVISIT_DIR *VisitDirStack,
    IN     ULONG Cluster,
    IN     PWSTRING DirectoryPath
    )
{
    PVISIT_DIR visit_dir;

    visit_dir = (PVISIT_DIR)MALLOC( sizeof( VISIT_DIR ) );
    if( visit_dir == NULL ){
        return FALSE;
    }

    visit_dir->Path = DirectoryPath;
    visit_dir->Cluster = Cluster;
    visit_dir->Next = *VisitDirStack;
    *VisitDirStack = visit_dir;

    return TRUE;
}

BOOLEAN
PopVisitDir(
    IN OUT PVISIT_DIR *VisitDirStack,
    OUT    PULONG Cluster OPTIONAL,
    OUT    PWSTRING *DirectoryPath OPTIONAL
    )
{
    PVISIT_DIR visit_dir;

    visit_dir = *VisitDirStack;
    if( visit_dir == NULL ){
        return FALSE;
    }
    *VisitDirStack = visit_dir->Next;

    if( ARGUMENT_PRESENT( Cluster ) ){
        *Cluster = visit_dir->Cluster;
    }

    if( ARGUMENT_PRESENT( DirectoryPath ) ){
        *DirectoryPath = visit_dir->Path;
    }

    FREE( visit_dir );
    return TRUE;
}

STATIC VOID
EraseAssociatedLongName(
    PFATDIR Dir,
    INT     FirstLongEntry,
    INT     ShortEntry
    )
{
    FAT_DIRENT dirent;

    for (int j = FirstLongEntry; j < ShortEntry; ++j) {
        dirent.Initialize(Dir->GetDirEntry(j));
        dirent.SetErased();
    }
}

STATIC BOOLEAN
IsString8Dot3(
    PCWSTRING   s
    )
/*++

Routine Description:

    This routine is used to ensure that lfn's legally correspond
    to their short names.  The given string is examined to see if it
    is a legal fat 8.3 name.

Arguments:

    s -- lfn to examine.

Return Value:

    TRUE            - The string is a legal 8.3 name.
    FALSE           - Not legal.

--*/
{
    USHORT i;
    BOOLEAN extension_present = FALSE;
    WCHAR c;

    //
    // The name can't be more than 12 characters (including a single dot).
    //

    if (s->QueryChCount() > 12) {
        return FALSE;
    }

    for (i = 0; i < s->QueryChCount(); ++i) {

        c = s->QueryChAt(i);

#if 0
        if (!FsRtlIsAnsiCharLegalFat(c, FALSE)) {
            return FALSE;
        }
#endif

        if (c == '.') {

            //
            // We stepped onto a period.  We require the following things:
            //
            //      - it can't be the first character
            //      - there can be only one
            //      - there can't be more than 3 characters following it
            //      - the previous character can't be a space
            //

            if (i == 0 ||
                extension_present ||
                s->QueryChCount() - (i + 1) > 3 ||
                s->QueryChAt(i - 1) == ' ') {

                return FALSE;
            }
            extension_present = TRUE;
        }

        //
        // The base part of the name can't be more than 8 characters long.
        //

        if (i >= 8 && !extension_present) {
            return FALSE;
        }

    }

    //
    // The name cannot end in a space or a period.
    //

    if (c == ' ' || c == '.') {
        return FALSE;
    }

    return TRUE;
}

STATIC PMESSAGE      _pvfMessage = NULL;
STATIC BOOLEAN       _Verbose = FALSE;

VOID
FreeSpaceInBitmap(
    IN      ULONG       StartingCluster,
    IN      PCFAT       Fat,
    IN OUT  PBITVECTOR  FatBitMap
    );

BOOLEAN
FAT_SA::VerifyAndFix(
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN      ULONG       Flags,
    IN      ULONG       LogFileSize,
    IN      USHORT      Algorithm,
    OUT     PULONG      ExitStatus,
    IN      PCWSTRING   DriveLetter
    )
/*++

Routine Description:

    This routine verifies the FAT superarea and if neccessary fixes
    it to a correct state.

Arguments:

    FixLevel        - Supplies the level of fixes that may be performed on
                      the disk.
    Message         - Supplies an outlet for messages.
    Flags           - Supplies flags to control the behavior of chkdsk
                      (see ulib\inc\ifsserv.hxx for details)
    LogFileSize     - ignored
    Algorithm       - ignored
    ExitStatus      - Returns an indication of the result of the check
    DriveLetter     - For autocheck, supplies the letter of the volume
                      being checked

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FAT_DIRENT      eadent;
    ULONG           cluster_size;
    ULONG           ea_clus_num;
    USHORT          num_eas, save_num_eas;
    PEA_INFO        ea_infos;
    ULONG           cluster_count;
    HMEM            ea_header_mem;
    EA_HEADER       ea_header;
    BOOLEAN         changes = FALSE;
    BITVECTOR       fat_bitmap;
    FATCHK_REPORT   report;
    PUSHORT         p;
    VOLID           volid;
    ULONG           free_count, bad_count, total_count;
    BOOLEAN         fmsg;
    DSTRING         label;
    DSTRING         eafilename;
    DSTRING         eafilepath;
    BOOLEAN         tmp_bool;
    ULONG           tmp_ulong;
    DSTRING         date;
    DSTRING         time;
    UCHAR           dirty_byte, media_byte;
    ULONG           errFixedStatus = CHKDSK_EXIT_SUCCESS;

    BOOLEAN         Verbose = (BOOLEAN)(Flags & CHKDSK_VERBOSE);
    BOOLEAN         OnlyIfDirty = (BOOLEAN)(Flags & CHKDSK_CHECK_IF_DIRTY);
    BOOLEAN         EnableUpgrade = (BOOLEAN)(Flags & CHKDSK_ENABLE_UPGRADE);
    BOOLEAN         EnableDowngrade = (BOOLEAN)(Flags & CHKDSK_DOWNGRADE);
    BOOLEAN         RecoverFree = (BOOLEAN)(Flags & CHKDSK_RECOVER_FREE_SPACE);
    BOOLEAN         RecoverAlloc = (BOOLEAN)(Flags & CHKDSK_RECOVER_ALLOC_SPACE);

#if !defined(_AUTOCHECK_)
    STATIC LONG     FatChkdskIsRunning = 0;
#endif

    memset(&report, 0, sizeof(FATCHK_REPORT));

    if (NULL == ExitStatus) {
        ExitStatus = &report.ExitStatus;
    }
    report.ExitStatus = CHKDSK_EXIT_SUCCESS;
    *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;

#if !defined(_AUTOCHECK_)
    if (InterlockedCompareExchange(&FatChkdskIsRunning, 1, 0) != 0) {
        Message->DisplayMsg(MSG_CHK_NO_MULTI_THREAD);
        return FALSE;
    }
#endif

    _pvfMessage = Message;
    _Verbose = Verbose;

    fmsg = TRUE;

    if (FixLevel != CheckOnly) {
        fmsg = FALSE;
    }

    if (EnableUpgrade || EnableDowngrade) {
        Message->Set(MSG_CHK_CANNOT_UPGRADE_DOWNGRADE_FAT);
        Message->Display();
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    //
    // Check to see if the dirty bit is set.
    //
    dirty_byte = QueryVolumeFlags();

    if (OnlyIfDirty) {
        if ((dirty_byte &
             (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE)) == 0) {
            Message->Set(MSG_CHK_VOLUME_CLEAN);
            Message->Display();
            Message->SetLoggingEnabled(FALSE);
            *ExitStatus = CHKDSK_EXIT_SUCCESS;
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return TRUE;
        }

        // We need to re-initialize the fatsa object to include the whole
        // super area

        if (!Initialize(_drive, Message, TRUE)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

        if (!Read(Message)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

        // If the second bit of the dirty byte is set then
        // also perform a full recovery of the free and allocated
        // space.

        if (dirty_byte & FAT_BPB_RESERVED_TEST_SURFACE) {
            RecoverFree = TRUE;
            RecoverAlloc = TRUE;
        }
    }

    //
    // NOTE that this check must follow the above "if (OnlyIfDirty)" because in the
    //      OnlyIfDirty case only the first part of the FAT_SA object is in memory
    //      until the above if gets executed.
    //
    if (QueryLength() <= SecPerBoot()) {
        Message->Set(MSG_NOT_FAT);
        Message->Display();
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    //
    // The volume is not clean, so if we're autochecking we want to
    // make sure that we're printing real messages on the console
    // instead of just dots.
    //

#ifdef _AUTOCHECK_

    if (Message->SetDotsOnly(FALSE)) {

        Message->SetLoggingEnabled(FALSE);
        if (NULL != DriveLetter) {
            Message->Set(MSG_CHK_RUNNING);
            Message->Display("%W", DriveLetter);
        }

        Message->Set(MSG_FILE_SYSTEM_TYPE);
        Message->Display("%s", _ft == LARGE32 ? "FAT32" : "FAT");
        Message->SetLoggingEnabled();

    }

    if (Message->IsInAutoChk()) {

        ULONG   timeout;

        if (!VOL_LIODPDRV::QueryAutochkTimeOut(&timeout)) {
            timeout = AUTOCHK_TIMEOUT;
        }

        if (timeout > MAX_AUTOCHK_TIMEOUT_VALUE)
            timeout = AUTOCHK_TIMEOUT;

        if (timeout != 0) {
            if (dirty_byte & (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE))
                Message->Set(MSG_CHK_AUTOCHK_SKIP_WARNING);
            else
                Message->Set(MSG_CHK_USER_AUTOCHK_SKIP_WARNING);
            Message->Display();
            if (Message->IsKeyPressed(MSG_CHK_ABORT_AUTOCHK, timeout)) {
                Message->SetLoggingEnabled(FALSE);
                Message->Set(MSG_CHK_AUTOCHK_ABORTED);
                Message->Display();
                *ExitStatus = CHKDSK_EXIT_SUCCESS;
                return TRUE;
            } else {
                Message->Set(MSG_CHK_AUTOCHK_RESUMED);
                Message->Display();
            }
        } else if ((dirty_byte & (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE))) {
            Message->Set(MSG_CHK_VOLUME_IS_DIRTY);
            Message->Display();
        }
    } else {
        DebugAssert(Message->IsInSetup());

        if (dirty_byte & (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE)) {
            Message->Set(MSG_CHK_VOLUME_IS_DIRTY);
            Message->Display();
        }
    }

#endif  // _AUTOCHECK_

    //
    // The BPB's Media Byte must be in the set accepted
    // by the file system.
    //
    media_byte = QueryMediaByte();

#if defined(FE_SB) && defined(_X86_)
    if ((media_byte != 0x00) &&  /* FMR */
        (media_byte != 0x01) &&  /* FMR */
        (media_byte != 0xf0) &&
#else
    if ((media_byte != 0xf0) &&
#endif
        (media_byte != 0xf8) &&
        (media_byte != 0xf9) &&
#if defined(FE_SB) && defined(_X86_)
        (media_byte != 0xfa) &&  /* FMR */
        (media_byte != 0xfb) &&  /* FMR */
#endif
        (media_byte != 0xfc) &&
        (media_byte != 0xfd) &&
        (media_byte != 0xfe) &&
        (media_byte != 0xff)) {

        SetMediaByte(_drive->QueryMediaByte());
        dofmsg(Message, &fmsg);
        Message->Set(MSG_CHK_INVALID_MEDIA_BYTE);
        Message->Display();
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    // First print out the label and volume serial number.
    // We won't bother printing this message under autocheck.

#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

    TIMEINFO        timeinfo;

    if ((QueryLabel(&label, &timeinfo) || label.Initialize("")) &&
        label.QueryChCount() &&
        timeinfo.QueryDate(&date) &&
        timeinfo.QueryTime(&time)) {

        Message->Set(MSG_VOLUME_LABEL_AND_DATE);
        Message->Display("%W%W%W", &label, &date, &time);
    }

#endif // !_AUTOCHECK_ && !_SETUP_LOADER_


    if (volid = QueryVolId()) {
        p = (PUSHORT) &volid;
        Message->Set(MSG_VOLUME_SERIAL_NUMBER);
        Message->Display("%04X%04X", p[1], p[0]);
    }

    // Validate the FAT.

    if (_dirF32 == NULL)
        _fat->Scrub(&changes);

    if (changes) {
        dofmsg(Message, &fmsg);
        Message->Set(MSG_CHK_ERRORS_IN_FAT);
        Message->Display();
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }


    //
    // Make sure that the media type in the BPB is the same as at
    // the beginning of the FAT.
    //

    if (QueryMediaByte() != _fat->QueryMediaByte()) {
#if defined(FE_SB) // MO & OEM FAT Support
        BOOLEAN bPrintError = TRUE;

#if defined(_X86_)
        if (IsPC98_N()) {

            // PC98 Nov.01.1994
            // to help the early NEC DOS

            if(_drive->QueryMediaType() == FixedMedia &&
                       QueryMediaByte() == 0xf8 && _fat->QueryMediaByte() == 0xfe) {

                bPrintError = FALSE;

            }
        }
#endif

        if (bPrintError &&
            (_drive->QueryMediaType() == F3_128Mb_512 ||
             _drive->QueryMediaType() == F3_230Mb_512   )) {

            // We won't to recognized as illegal in following case.
            //
            // Some OpticalDisk might have 0xf0 as media in BPB, but it also has 0xF8 in FAT.
            //

            if (QueryMediaByte() == 0xf0 && _fat->QueryMediaByte() == 0xf8) {

                bPrintError = FALSE;
            }
        }

        if( bPrintError ) {
#endif

            dofmsg(Message, &fmsg);
            Message->Set(MSG_PROBABLE_NON_DOS_DISK);
            Message->Display();
            if (!Message->IsYesResponse(FALSE)) {
                _Verbose = FALSE;
                _pvfMessage = NULL;
                return TRUE;
            }

#if defined(FE_SB) // REAL_FAT_SA::Create():Optical disk support
            //
            // Here is a table of Optical Disk (MO) format on OEM DOS.
            //
            //   128MB    |  NEC  |  IBM  | Fujitsu |
            // -----------+-------+-------+---------+
            // BPB.Media  | 0xF0  | 0xF0  | 0xF0    |
            // -----------+-------+-------+---------+
            // FAT.DiskID | 0xF0  | 0xF8  | 0xF8    |
            // -----------+-------+-------+---------+
            //
            //   230MB    |  NEC  |  IBM  | Fujitsu |
            // -----------+-------+-------+---------+
            // BPB.Media  | 0xF0  | 0xF0  | 0xF0    |
            // -----------+-------+-------+---------+
            // FAT.DiskID | 0xF8  | 0xF8  | 0xF8    |
            // -----------+-------+-------+---------+
            //
            // We will take NEC's way....

            if (_drive->QueryMediaType() == F3_230Mb_512) {

                DebugAssert(QueryMediaByte() == (UCHAR) 0xF0);

                _fat->SetEarlyEntries((UCHAR) 0xF8);
            } else {
                _fat->SetEarlyEntries(QueryMediaByte());
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }
#else
        _fat->SetEarlyEntries(QueryMediaByte());
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
#endif
    }


    // Compute the cluster size and the number of clusters on disk.

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();
    cluster_count = QueryClusterCount();


    // No EAs have been detected yet.

    ea_infos = NULL;
    num_eas = 0;


    // Create an EA file name string.

    if (!eafilename.Initialize("EA DATA. SF") ||
        !eafilepath.Initialize("\\EA DATA. SF")) {
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }


    //
    // This bitmap will be reinitialized before 'WalkDirectoryTree'.
    // Its contents will be ignored until then.
    //

    if (!fat_bitmap.Initialize(cluster_count)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    // If there is an EA file on disk then...

    // FAT32 volume does not support EA.
    if (_dir != NULL && // <-- If this is not a FAT32 volume.
        eadent.Initialize(_dir->SearchForDirEntry(&eafilename), FAT_TYPE_EAS_OKAY)) {

        // Validate the EA file directory entry.

        if (!ValidateDirent(&eadent, &eafilepath, FixLevel, FALSE, &report, Message,
                            &fmsg, &fat_bitmap, &tmp_bool, &tmp_ulong)) {
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }


        // If the EA file directory entry was valid then...

        // FATDIR::SearchForDirEntry will not return an erased dirent, but whatever...
        if (!eadent.IsErased()) {

            // The EA file should not have an EA handle.
            if (eadent.QueryEaHandle()) {
                dofmsg(Message, &fmsg);
                Message->Set(MSG_CHK_EAFILE_HAS_HANDLE);
                Message->Display();
                eadent.SetEaHandle(0);
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }

            // Compute the EA file's starting cluster.
            ea_clus_num = eadent.QueryStartingCluster();

            //
            // Perform any log operations recorded at the beginning
            // of the EA file.
            //

            if (!PerformEaLogOperations(ea_clus_num, FixLevel, &report,
                                        Message, &fmsg)) {
                _Verbose = FALSE;
                _pvfMessage = NULL;
                return FALSE;
            }

            //
            // Validate the EA file's EA sets and return an array of
            // information about them.
            //
            ea_infos = RecoverEaSets(ea_clus_num, &num_eas, FixLevel, &report,
                                     Message, &fmsg);

            //
            // If there are no valid EAs in the EA file then erase
            // the EA file.
            //
            if (!ea_infos) {

                if (num_eas) {
                    _Verbose = FALSE;
                    _pvfMessage = NULL;
                    return FALSE;
                }

                eadent.SetErased();

                dofmsg(Message, &fmsg);
                Message->Set(MSG_CHK_EMPTY_EA_FILE);
                Message->Display();
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }
    }


    // Initialize FAT bitmap to be used in detection of cross-links.

    if (!fat_bitmap.Initialize(cluster_count)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    if (!CheckSectorHeapAllocation(FixLevel, Message, &fmsg)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    if (!VerifyFatExtensions(FixLevel, Message, &fmsg)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }


    //
    // Should probably add another function to perform the following task.
    //

    if (_dirF32 != NULL)  {

        if (!VerifyAndFixFat32RootDir( &fat_bitmap, Message, &report, &fmsg)) {
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

    }

    // Validate all of the files on the disk.
    save_num_eas = num_eas;

    if (!WalkDirectoryTree(ea_infos, &num_eas, &fat_bitmap, &report,
                           FixLevel, RecoverAlloc, Message, Verbose, &fmsg)) {
       // DELETE(ea_infos);
       delete [] ea_infos; ea_infos = NULL;
       _Verbose = FALSE;
       _pvfMessage = NULL;
       return FALSE;
    }

    if (save_num_eas != num_eas && ea_infos) {

        if (!EraseEaHandle(ea_infos, num_eas, save_num_eas, FixLevel, Message)) {
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

        if (!num_eas) {

            delete [] ea_infos;
            ea_infos = NULL;

            //
            // Note that the following two steps cause the EA file chain to get recovered
            //  as a lost cluster chain since all this does is erase the dirent, not the
            //  cluster chain.
            //
            eadent.SetErased();
            FreeSpaceInBitmap(eadent.QueryStartingCluster(), _fat,
                              &fat_bitmap);

            dofmsg(Message, &fmsg);
            Message->Set(MSG_CHK_EMPTY_EA_FILE);
            Message->Display();
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }
    }

    // If there are EAs on the disk then...

    if (ea_infos) {

        // Remove all unused EAs from EA file.

        if (!PurgeEaFile(ea_infos, num_eas, &fat_bitmap, FixLevel, &report, Message,
                         &fmsg)) {
            // DELETE( ea_infos );
            delete [] ea_infos; ea_infos = NULL;
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }


        // Rebuild header portion of EA file.

        if (!ea_header_mem.Initialize() ||
            !RebuildEaHeader(&ea_clus_num, ea_infos, num_eas,
                             &ea_header_mem, &ea_header, &fat_bitmap,
                             FixLevel, &report, Message, &fmsg)) {
            // DELETE( ea_infos );
            delete [] ea_infos; ea_infos = NULL;
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

        changes = FALSE;
        if (ea_clus_num) {
            if (eadent.QueryStartingCluster() != ea_clus_num) {
                eadent.SetStartingCluster(ea_clus_num);
                changes = TRUE;
            }
            ULONG new_file_size = cluster_size * _fat->QueryLengthOfChain(ea_clus_num);
            if (eadent.QueryFileSize() != new_file_size) {
                eadent.SetFileSize(new_file_size);
                changes = TRUE;
            }
        } else {
            changes = TRUE;
            dofmsg(Message, &fmsg);
            Message->Set(MSG_CHK_EMPTY_EA_FILE);
            Message->Display();

            //
            // Note that the following two steps cause the EA file chain to get recovered
            //  as a lost cluster chain since all this does is erase the dirent, not the
            //  cluster chain.
            //
            eadent.SetErased();
            FreeSpaceInBitmap(eadent.QueryStartingCluster(), _fat,
                              &fat_bitmap);
        }
        if (changes) {
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            dofmsg(Message, &fmsg);
            Message->Set(MSG_CHK_REPAIRED_EA);
            Message->Display();
        }
    }

    //
    // If WalkDirectoryTree deleted any files, we need to sync the
    // FAT_EXTENSIONS up with the FAT again.
    //
    if (!VerifyFatExtensions(FixLevel, Message, &fmsg)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    if (!RecoverOrphans(&fat_bitmap, FixLevel, Message, &fmsg, &report)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    //
    // RecoverOrphans may have cleared faulty entries from the FAT,
    // and now we need to sync the FAT_EXTENSIONS again.
    //
    if (!VerifyFatExtensions(FixLevel, Message, &fmsg)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    // If requested, validate all of the free space on the volume.

    if (RecoverFree && !RecoverFreeSpace(&report, Message)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    total_count = cluster_count - FirstDiskCluster;

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, &report);
    *ExitStatus = report.ExitStatus;

    switch (*ExitStatus) {
      case CHKDSK_EXIT_SUCCESS:
        Message->DisplayMsg(MSG_CHK_NO_PROBLEM_FOUND);
        break;

      case CHKDSK_EXIT_ERRS_FIXED:
        Message->DisplayMsg((FixLevel != CheckOnly) ? MSG_CHK_ERRORS_FIXED : MSG_CHK_NEED_F_PARAMETER);
        break;

      case CHKDSK_EXIT_COULD_NOT_CHK:
//    case CHKDSK_EXIT_ERRS_NOT_FIXED:
//    case CHKDSK_EXIT_COULD_NOT_FIX:
        Message->DisplayMsg(MSG_CHK_ERRORS_NOT_FIXED);
        break;

    }

    BIG_INT temp_big_int;
    ULONG   temp_ulong;
    MSGID   message_id;
    BOOLEAN KSize;
    DSTRING wdNum1;
    char    wdAstr[14];
    DSTRING wdNum2;


    if (!wdNum1.Initialize("             ") ||
        !wdNum2.Initialize("             ")   ) {

        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    temp_big_int = cluster_size;
    temp_big_int = temp_big_int * total_count;

    // NOTE: The magic number 4095MB comes from Win9x's GUI SCANDISK utility

    if (temp_big_int.GetHighPart() || (temp_big_int.GetLowPart() > (4095ul*1024ul*1024ul))) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
        message_id = MSG_TOTAL_KILOBYTES;
        KSize = TRUE;
    } else {
        temp_ulong = temp_big_int.GetLowPart();
        message_id = MSG_TOTAL_DISK_SPACE;
        KSize = FALSE;
    }

    Message->Set(message_id);
    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    if (report.HiddenEntriesCount) {
        temp_big_int = cluster_size;
        temp_big_int = temp_big_int * report.HiddenClusters;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_HIDDEN_FILES;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_HIDDEN_FILES;
        }
        Message->Set(message_id);

        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);

        sprintf(wdAstr, "%d", report.HiddenEntriesCount);
        InsertSeparators(wdNum2.GetWSTR(),wdAstr, 0);

        Message->Display("%ws%ws", wdNum1.GetWSTR(), wdNum2.GetWSTR());
    }

    if (report.DirEntriesCount) {
        temp_big_int = cluster_size;
        temp_big_int = temp_big_int * report.DirClusters;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_DIRECTORIES;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_DIRECTORIES;
        }
        Message->Set(message_id);

        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);

        sprintf(wdAstr, "%d", report.DirEntriesCount);
        InsertSeparators(wdNum2.GetWSTR(),wdAstr, 0);

        Message->Display("%ws%ws", wdNum1.GetWSTR(), wdNum2.GetWSTR());
    }

    if (report.FileEntriesCount) {

        temp_big_int = cluster_size;
        temp_big_int = temp_big_int * report.FileClusters;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_USER_FILES;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_USER_FILES;
        }
        Message->Set(message_id);

        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);

        sprintf(wdAstr, "%d", report.FileEntriesCount);
        InsertSeparators(wdNum2.GetWSTR(),wdAstr, 0);

        Message->Display("%ws%ws", wdNum1.GetWSTR(), wdNum2.GetWSTR());
    }

    if (bad_count = _fat->QueryBadClusters()) {
        temp_big_int = bad_count;
        temp_big_int = temp_big_int * cluster_size;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_CHK_NTFS_BAD_SECTORS_REPORT_IN_KB;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_BAD_SECTORS;
        }
        Message->Set(message_id);
        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
        Message->Display("%ws", wdNum1.GetWSTR());
    }

    if (ea_infos) {
        Message->Set(MSG_CHK_EA_SIZE);

        sprintf(wdAstr, "%u", cluster_size*_fat->QueryLengthOfChain(ea_clus_num));
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
        Message->Display("%ws", wdNum1.GetWSTR());
    }

    free_count = _fat->QueryFreeClusters();

    temp_big_int = free_count;
    temp_big_int = temp_big_int * cluster_size;
    if (KSize) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
        message_id = MSG_AVAILABLE_KILOBYTES;
    } else {
        temp_ulong = temp_big_int.GetLowPart();
        message_id = MSG_AVAILABLE_DISK_SPACE;
    }
    Message->Set(message_id);
    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_ALLOCATION_UNIT_SIZE);
    sprintf(wdAstr, "%u", cluster_size);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_TOTAL_ALLOCATION_UNITS);
    sprintf(wdAstr, "%u", total_count);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_AVAILABLE_ALLOCATION_UNITS);
    sprintf(wdAstr, "%u", free_count);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    if (FixLevel != CheckOnly && ea_infos && !ea_header.Write()) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    // Clear the dirty bit.
    //
    if( RecoverAlloc ) {
        SetVolumeFlags(FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE,
                       TRUE);
    } else {
        SetVolumeFlags(FAT_BPB_RESERVED_DIRTY, TRUE);
    }

    if (FixLevel != CheckOnly && !Write(Message)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    // DELETE(ea_infos);
    delete [] ea_infos; ea_infos = NULL;
    _Verbose = FALSE;
    _pvfMessage = NULL;
    return TRUE;
}

BOOLEAN
FAT_SA::VerifyAndFixFat32RootDir (
    IN OUT  PBITVECTOR      FatBitMap,
    IN      PMESSAGE        Message,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PBOOLEAN        NeedErrorMessage
    )

/*++

Routine Description:

    This routine verifies the FAT32 root directory which is not an integral
    part of the super area buffer. The method employed to verify and fix the
    root directory is very similar to the one used to verify and fix regular
    directory structure.

Arguments:

    BitVector - Supplies a bit map for cross/bad links detection. The whole
                map should be zeroed when it is passed in this method.
    Message   - Supplies an outlet for messages.
    Report    - Supplies the fat chkdsk report structures for storing the
                actions performed by this method.
    NeedErrorsMessage   - Supplies whether or not an error has occurred
                          under check only conditions.

Return Values:

    TRUE  - Success.
    FALSE - Failed.

--*/
{

    BOOLEAN crosslink_detected = FALSE;
    BOOLEAN changes_made = FALSE;
    ULONG   starting_cluster;
    ULONG   dummy;
    ULONG   errFixedStatus = CHKDSK_EXIT_SUCCESS;

    starting_cluster = QueryFat32RootDirStartingCluster();
    _fat->ScrubChain( starting_cluster,
                      FatBitMap,
                      &changes_made,
                      &crosslink_detected,
                      &dummy );
    //
    // Root dir is the only component marked in the
    // bitmap so far.
    //

    DebugAssert(!crosslink_detected);

    if (changes_made) {
        dofmsg(Message, NeedErrorMessage);
        Message->Set(MSG_BAD_LINK);
        Message->Display("%s", "\\");
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        //
        //  We have to reinitialized the root directory.
        //

        if (!_hmem_F32->Initialize() ||
            !_dirF32->Initialize( _hmem_F32, _drive, this,
                                  _fat, starting_cluster)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        //
        //  Force a re-reading of the root directory.
        //  We don't care if it fails, subsequent code can fix that.
        //

        _dirF32->Read();
    }

    //
    // Validate the readability of the root chain
    //

    //
    // t-raymak:
    // We don't want replacement clusters becuase the replacement given
    // by RecoverChain will be zeroed which, according to the spec., means
    // it contains the end of the directory structure and WalkDirectoryTree
    // will just go ahead and erase all the 'good' directory entries that comes
    // after the replaced cluster. Not a really nice thing to do to the root
    // directory IMHO.
    //
    if(!RecoverChain(&starting_cluster, &changes_made, 0, FALSE)){
        dofmsg(Message, NeedErrorMessage);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (changes_made) {

        if ( starting_cluster ) {

            if ( starting_cluster != _dirF32->QueryStartingCluster() ) {
                SetFat32RootDirStartingCluster( starting_cluster );
            }

            //
            // Should reinitialize the root directory
            //
            if (!_hmem_F32->Initialize() ||
                !_dirF32->Initialize( _hmem_F32, _drive, this,
                                      _fat, starting_cluster)) {
                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }


        } else {

            if(!RelocateNewFat32RootDirectory( Report, FatBitMap, Message )) {
                return FALSE;
            }

        }


        //
        //  Reread the root directory
        //
        if (!_dirF32->Read()) {
            //
            //  Shouldn't fail.
            //
            DebugAbort("Failed to read the FAT32 root directory despite all the fixing.\n");

        }
        dofmsg(Message, NeedErrorMessage);
        Message->Set(MSG_CHK_NTFS_CORRECTING_ERROR_IN_DIRECTORY);
        Message->Display("%s", "\\");
        //
        // Erasing the root will totally destroy the disk
        // so we just leave it partially corrupted and
        // hopefully WalkDirectoryTree will be able to fix it.
        //
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return TRUE;
}

BOOLEAN
FAT_SA::RelocateNewFat32RootDirectory (
    IN OUT PFATCHK_REPORT   Report,
    IN OUT PBITVECTOR       FatBitMap,
    IN     PMESSAGE         Message
    )
/*++

Routine Description:

    This routine relocates a FAT32 root directory

Arguments:

    Report - Supplies the fat chkdsk report structure for storing
             the fix status.

    FatBitMap - Supplies a pointer to the bit map for cross-link
                detection.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - Success.
    FALSE - Failed.

--*/
{

    SECRUN  root_secrun; // Allocate one cluster for the
                         // new root directory.
    ULONG   root_clus;   // New cluster number of the
                         // root directory
    ULONG   cluster_size;// Number of sectors in a cluster.

    ULONG   starting_data_lbn;
    ULONG   sector_size;

    starting_data_lbn = QueryStartDataLbn();
    cluster_size = QuerySectorsPerCluster();
    sector_size = _drive->QuerySectorSize();


    for (;;) {

        root_clus = _fat->AllocChain(1, NULL);

        if (!root_clus) {
            //
            // The disk is full, we have no choice but to bail out.
            //
            Message->Set(MSG_CHK_INSUFFICIENT_DISK_SPACE);
            Message->Display();
            return FALSE;
        }

        if ( !_hmem_F32->Initialize() ||
             !root_secrun.Initialize( _hmem_F32,
                                      _drive,
                                      QuerySectorFromCluster(root_clus, NULL),
                                      cluster_size)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        memset(root_secrun.GetBuf(), 0, cluster_size * sector_size);

        if (root_secrun.Write() && root_secrun.Read()) {
            SetFat32RootDirStartingCluster(root_clus);
            //
            //  Set the bit for the new root in the bit map.
            //
            FatBitMap->SetBit(root_clus);

            //
            //  Reinitialize the FAT32 root directory
            //
            if ( !_hmem_F32->Initialize() ||
                 !_dirF32->Initialize( _hmem_F32, _drive, this,
                                       _fat, root_clus)) {
                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }

            UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);

            return TRUE;
        } else {
            _fat->SetClusterBad(root_clus);
        }

    }

    DebugPrintTrace(("FAT_SA::RelocateNewFat32RootDirectory: This line should not be reached.\n"));
    return FALSE;
}


BOOLEAN
FAT_SA::PerformEaLogOperations(
    IN      ULONG           EaFileCn,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine reads the EA file log from the disk and then performs
    any logged operations specified.

Arguments:

    EaFileCn            - Supplies the first cluster of the EA file.
    FixLevel            - Supplies the fix level.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occurred
                          under check only conditions.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM            hmem;
    EA_HEADER       ea_header;
    PEA_FILE_HEADER pea_header;
    ULONG           cluster_size;
    ULONG           num_clus;

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();
    num_clus = sizeof(EA_FILE_HEADER) + BaseTableSize*sizeof(USHORT);
    if (num_clus%cluster_size) {
        num_clus = (num_clus/cluster_size + 1);
    } else {
        num_clus = (num_clus/cluster_size);
    }

    if (!hmem.Initialize() ||
        !ea_header.Initialize(&hmem, _drive, this, _fat, EaFileCn, num_clus) ||
        !(pea_header = ea_header.GetEaFileHeader())) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (!ea_header.Read()) {
        Message->Set(MSG_CHK_CANT_CHECK_EA_LOG);
        Message->Display();
        Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return TRUE;
    }

    if (pea_header->Signature != HeaderSignature ||
        pea_header->FormatType ||
        pea_header->LogType) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_BAD_LOG, NORMAL_MESSAGE, TEXT_MESSAGE);
        Message->Display();
        if (Message->IsYesResponse(TRUE)) {
            pea_header->Signature = HeaderSignature;
            pea_header->Cluster1 = 0;
            pea_header->Cluster2 = 0;
            pea_header->Cluster3 = 0;

            if (FixLevel != CheckOnly && !ea_header.Write()) {
                Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
            }

            UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);

            return TRUE;
        } else {
            return FALSE;
        }
    }

    if (pea_header->Cluster1) {
        if (_fat->IsInRange(pea_header->Cluster1) &&
            _fat->IsInRange(pea_header->NewCValue1)) {
            _fat->SetEntry(pea_header->Cluster1, pea_header->NewCValue1);
        } else {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_ERROR_IN_LOG);
            Message->Display();
        }
    }

    if (pea_header->Cluster2) {
        if (_fat->IsInRange(pea_header->Cluster2) &&
            _fat->IsInRange(pea_header->NewCValue2)) {
            _fat->SetEntry(pea_header->Cluster2, pea_header->NewCValue2);
        } else {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_ERROR_IN_LOG);
            Message->Display();
        }
    }

    if (pea_header->Cluster3) {
        if (_fat->IsInRange(pea_header->Cluster3) &&
            _fat->IsInRange(pea_header->NewCValue3)) {
            _fat->SetEntry(pea_header->Cluster3, pea_header->NewCValue3);
        } else {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_ERROR_IN_LOG);
            Message->Display();
        }
    }

    return TRUE;
}


PEA_INFO
FAT_SA::RecoverEaSets(
    IN      ULONG           EaFileCn,
    OUT     PUSHORT         NumEas,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine validates and if necessary recovers the EA file.

Arguments:

    EaFileCn            - Supplies the cluster number for the EA file.
    NumEas              - Returns the number of EA sets in the EA file.
    FixLevel            - Supplies the CHKDSK fix level.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occurred
                          under check only conditions.

Return Value:

    An allocated array containing 'NumberOfEaSets' entries documenting
    important information about the EA sets.  If there are no EAs then
    'NumberOfEaSets' is returned as 0 and NULL is returned.  If there
    is an error then NULL will be returned with a non-zero
    'NumberOfEaSets'.

--*/
{
    PEA_INFO    ea_infos;
    ULONG       clus, prev;
    USHORT      num_eas;
    ULONG       i;
    ULONG       length;
    ULONG       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    DebugAssert(NumEas);

    *NumEas = 1;

    length = _fat->QueryLengthOfChain(EaFileCn);
    ea_infos = NEW EA_INFO[length];
    if (!ea_infos) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return NULL;
    }

    memset(ea_infos, 0, length*sizeof(EA_INFO));

    //
    // Scan file for EA sets and validate them while updating the
    // array.
    //
    num_eas = 0;
    prev = EaFileCn;
    while (!_fat->IsEndOfChain(prev)) {

        clus = VerifyAndFixEaSet(prev, &ea_infos[num_eas], FixLevel, Report,
                                 Message, NeedErrorsMessage);

        if (clus) {
            num_eas++;
        } else {
            clus = _fat->QueryEntry(prev);
        }

        prev = clus;
    }

    if (!num_eas) {

        // All the ea sets are unused, the ea file is
        // effectively empty.

        // Should use array delete instead.
        // DELETE( ea_infos );
        delete [] ea_infos;

        // Free the cluster chain occupied by the ea file
        // so subsequent checking and fixing will not
        // complain about the lost chain in the ea file.

        _fat->FreeChain(EaFileCn);

        ea_infos = NULL;
        *NumEas = 0;
        return NULL;
    }


    // Go through and remove unused portions of the EA file.

    for (i = 0; i < (USHORT)(num_eas - 1); i++) {
        if (ea_infos[i].LastCn != ea_infos[i + 1].PreceedingCn) {

            _fat->RemoveChain(ea_infos[i].LastCn,
                              ea_infos[i + 1].PreceedingCn);

            dofmsg(Message, NeedErrorsMessage);

            Message->Set(MSG_CHK_UNUSED_EA_PORTION);
            Message->Display();

            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            ea_infos[i + 1].PreceedingCn = ea_infos[i].LastCn;
        }
    }

    if (!_fat->IsEndOfChain(ea_infos[num_eas - 1].LastCn)) {

        _fat->SetEndOfChain(ea_infos[num_eas - 1].LastCn);

        dofmsg(Message, NeedErrorsMessage);

        Message->Set(MSG_CHK_UNUSED_EA_PORTION);
        Message->Display();

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }


    // Sort the EAs in the EA file.

    if (!EaSort(ea_infos, num_eas, Report, Message, NeedErrorsMessage)) {
        return NULL;
    }

    *NumEas = num_eas;

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return ea_infos;
}


ULONG
FAT_SA::VerifyAndFixEaSet(
    IN      ULONG           PreceedingCluster,
    OUT     PEA_INFO        EaInfo,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine attempts to identify the clusters following the
    'PreceedingCluster' as an EA set.  If this routine does not
    recognize these clusters as an EA set then it will return 0.
    Otherwise, it will return the last cluster of the validated EA set.

    Changes may be made to the clusters if they are recognized as an EA
    set with errors.

Arguments:

    PreceedingCluster   - Supplies the cluster preceeding the EA set cluster.
    Info                - Returns information about the EA set.
    FixLevel            - Supplies the CHKDSK fix level.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not errors have occurred
                            under check only conditions.

Return Value:

    The cluster number of the last cluster in the EA set or 0.

--*/
{
    HMEM    hmem;
    EA_SET  easet;
    ULONG   clus;
    PEA_HDR eahdr;
    LONG    i;
    ULONG   j;
    ULONG   need_count;
    LONG    total_size;
    LONG    size;
    ULONG   length;
    BOOLEAN need_write;
    PEA     pea;
    BOOLEAN more;
    ULONG   chain_length;

    clus = _fat->QueryEntry(PreceedingCluster);
    chain_length = _fat->QueryLengthOfChain(clus);

    length = 1;
    need_write = FALSE;

    if (!hmem.Initialize() ||
        !easet.Initialize(&hmem, _drive, this, _fat, clus, length) ||
        !(eahdr = easet.GetEaSetHeader())) {

        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return 0;
    }

    if (!easet.Read()) {
        return 0;
    }

    if (!easet.VerifySignature()) {
        return 0;
    }

    need_count = 0;
    total_size = 4;
    for (i = 0; ; i++) {
        for (j = 0; !(pea = easet.GetEa(i, &size, &more)) && more &&
                     length + j < chain_length; ) {
            j++;
            if (!hmem.Initialize() ||
                !easet.Initialize(&hmem, _drive, this, _fat, clus, length + j)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return 0;
            }

            if (!easet.Read()) {
                return 0;
            }
        }

        if (pea) {
            length += j;
        } else {
            break;
        }

        total_size += size;

        if (pea->Flag & NeedFlag) {
            need_count++;
        }
    }

    if (!i) {
        return 0;
    }

    if (total_size != eahdr->TotalSize) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_EASET_SIZE);
        Message->Display("%d", clus);
        eahdr->TotalSize = total_size;
        need_write = TRUE;
    }

    if (need_count != eahdr->NeedCount) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_EASET_NEED_COUNT);
        Message->Display("%d", clus);
        eahdr->NeedCount = need_count;
        need_write = TRUE;
    }

    EaInfo->OwnHandle = eahdr->OwnHandle;
    EaInfo->PreceedingCn = PreceedingCluster;
    EaInfo->LastCn = _fat->QueryNthCluster(PreceedingCluster, length);
    memcpy(EaInfo->OwnerFileName, eahdr->OwnerFileName, 14);
    EaInfo->UsedCount = 0;

    if (need_write) {
        if (FixLevel != CheckOnly && !easet.Write()) {
            return 0;
        }
        UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);
    }

    return EaInfo->LastCn;
}


BOOLEAN
FAT_SA::EaSort(
    IN OUT  PEA_INFO        EaInfos,
    IN      ULONG           NumEas,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine sorts the EaInfos array by 'OwnHandle' into ascending order.
    It also edits the FAT with the changes in the EAs order.

Arguments:

    EaInfos             - Supplies the array of EA_INFOs to sort.
    NumEas              - Supplies the number of elements in the array.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not errors have occurred
                            under check only conditions.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN done;
    EA_INFO tmp;
    ULONG   clus;
    ULONG   i;
    BOOLEAN change;

    done = FALSE;
    change = FALSE;
    while (!done) {
        done = TRUE;
        for (i = 0; i < NumEas - 1; i++) {
            if (EaInfos[i].OwnHandle > EaInfos[i + 1].OwnHandle) {
                done = FALSE;

                clus = _fat->RemoveChain(EaInfos[i + 1].PreceedingCn,
                                         EaInfos[i + 1].LastCn);

                _fat->InsertChain(clus,
                                  EaInfos[i + 1].LastCn,
                                  EaInfos[i].PreceedingCn);

                EaInfos[i + 1].PreceedingCn = EaInfos[i].PreceedingCn;
                EaInfos[i].PreceedingCn = EaInfos[i + 1].LastCn;
                if (i + 2 < NumEas) {
                    EaInfos[i + 2].PreceedingCn = EaInfos[i].LastCn;
                }

                change = TRUE;

                tmp = EaInfos[i];
                EaInfos[i] = EaInfos[i + 1];
                EaInfos[i + 1] = tmp;
            }
        }
    }

    if (change) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_UNORDERED_EA_SETS);
        Message->Display();
        UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);
    }

    return TRUE;
}


BOOLEAN
FAT_SA::RebuildEaHeader(
    IN OUT  PULONG          StartingCluster,
    IN OUT  PEA_INFO        EaInfos,
    IN      ULONG           NumEas,
    IN OUT  PMEM            EaHeaderMem,
    OUT     PEA_HEADER      EaHeader,
    IN OUT  PBITVECTOR      FatBitMap,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine rebuilds the header and tables of the EA file base on the
    information in the 'EaInfos' array.  The header log is set to zero,
    and the header itself is relocated if any of the clusters are bad.

    The starting cluster may be relocated if there are bad clusters.

Arguments:

    StartingCluster     - Supplies the first cluster of the EA file.
    EaInfos             - Supplies an array containing information for every
                            EA set.
    NumberOfEas         - Supplies the total number of EA sets.
    EaHeaderMem         - Supplies the memory for the EA header.
    EaHeader            - Returns the EA header.
    FatBitMap           - Supplies the cross-links bitmap.
    FixLevel            - Supplies the CHKDSK fix level.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not errors have occurred
                            under check only conditions.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           length;
    ULONG           cluster_size;
    ULONG           actual_length;
    ULONG           new_chain;
    ULONG           last_cluster;
    BOOLEAN         changes;
    LONG            i, j, k;
    PEA_MAP_TBL     table;
    PEA_FILE_HEADER header;
    LONG            tmp;
    BOOLEAN         empty_ea_file;
    ULONG           clus;
    ULONG           errFixedStatus = CHKDSK_EXIT_SUCCESS;

    // Compute the number of clusters necessary for the header portion of
    // the EA file.

    length = sizeof(EA_FILE_HEADER) +
             BaseTableSize*sizeof(USHORT) +
             EaInfos[NumEas - 1].OwnHandle*sizeof(USHORT);

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();

    if (length%cluster_size) {
        length = length/cluster_size + 1;
    } else {
        length = length/cluster_size;
    }

    //
    // Make sure that the header contains enough clusters to accomodate
    // the size of the offset table.
    //

    last_cluster = EaInfos[0].PreceedingCn;

    actual_length = _fat->QueryLengthOfChain(*StartingCluster, last_cluster);

    if (length > actual_length) {

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_NEED_MORE_HEADER_SPACE);
        Message->Display();

        new_chain = _fat->AllocChain((length - actual_length),
                                     &last_cluster);
        if (!new_chain) {
            Message->Set(MSG_CHK_INSUFFICIENT_DISK_SPACE);
            Message->Display();
            return FALSE;
        }

        if (IsCompressed() && !AllocSectorsForChain(new_chain)) {
            _fat->FreeChain(new_chain);
            Message->Set(MSG_CHK_INSUFFICIENT_DISK_SPACE);
            Message->Display();
            return FALSE;
        }

        for (clus = new_chain;
             !_fat->IsEndOfChain(clus);
             clus = _fat->QueryEntry(clus)) {

            FatBitMap->SetBit(clus);
        }
        FatBitMap->SetBit(clus);

        _fat->InsertChain(new_chain, last_cluster, EaInfos[0].PreceedingCn);

        EaInfos[0].PreceedingCn = last_cluster;

    } else if (length < actual_length) {

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_UNUSED_EA_PORTION);
        Message->Display();

        last_cluster = _fat->QueryNthCluster(*StartingCluster,
                                             length - 1);

        clus = _fat->RemoveChain(last_cluster, EaInfos[0].PreceedingCn);

        EaInfos[0].PreceedingCn = last_cluster;

        for (;
             !_fat->IsEndOfChain(clus);
             clus = _fat->QueryEntry(clus)) {

            FatBitMap->ResetBit(clus);
        }
        FatBitMap->ResetBit(clus);

    }


    // Verify the cluster chain containing the header.

    changes = FALSE;
    if (FixLevel != CheckOnly &&
        !RecoverChain(StartingCluster, &changes, last_cluster, TRUE)) {

        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_INSUFFICIENT_DISK_SPACE);
        Message->Display();

        return FALSE;
    }

    if (changes) {
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_RELOCATED_EA_HEADER);
        Message->Display();
    }


    // Compute the tables.

    if (!EaHeader->Initialize(EaHeaderMem, _drive, this, _fat,
                              *StartingCluster, (USHORT) length) ||
        !(table = EaHeader->GetMapTable()) ||
        !(header = EaHeader->GetEaFileHeader())) {

        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (!EaHeader->Read()) {
        if (FixLevel == CheckOnly) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_RELOCATED_EA_HEADER);
            Message->Display();
        } else {
            return FALSE;
        }
    }


    // Set the log in the header to zero.

    header->Signature = HeaderSignature;
    header->FormatType = 0;
    header->LogType = 0;
    header->Cluster1 = 0;
    header->NewCValue1 = 0;
    header->Cluster2 = 0;
    header->NewCValue2 = 0;
    header->Cluster3 = 0;
    header->NewCValue3 = 0;
    header->Handle = 0;
    header->NewHOffset = 0;


    // Reconcile the tables with the EaInfo information.

    changes = FALSE;

    for (i = 0; i < BaseTableSize; i++) {
        table->BaseTab[i] = 0;
    }

    j = 0;
    empty_ea_file = TRUE;
    for (i = 0; i < (LONG) NumEas; i++) {

        if (EaInfos[i].UsedCount != 1) {
            continue;
        }

        empty_ea_file = FALSE;

        for (; j < (LONG) EaInfos[i].OwnHandle; j++) {
            if (table->OffTab[j] != InvalidHandle) {
                table->OffTab[j] = InvalidHandle;
                changes = TRUE;
            }
        }

        length = _fat->QueryLengthOfChain(*StartingCluster,
                                         EaInfos[i].PreceedingCn);

        for (k = j>>7; k >= 0 && !table->BaseTab[k]; k--) {
            table->BaseTab[k] = (USHORT) length;
        }

        tmp = length - table->BaseTab[j>>7];

        if ((LONG)table->OffTab[j] != tmp) {
            table->OffTab[j] = (USHORT) tmp;
            changes = TRUE;
        }

        j++;
    }

    if (empty_ea_file) {

        for (clus = *StartingCluster;
             !_fat->IsEndOfChain(clus);
             clus = _fat->QueryEntry(clus)) {

            FatBitMap->ResetBit(clus);

        }
        FatBitMap->ResetBit(clus);

        *StartingCluster = 0;

        return TRUE;
    }

    tmp = _fat->QueryLengthOfChain(*StartingCluster);
    for (k = ((j - 1)>>7) + 1; k < BaseTableSize; k++) {
        table->BaseTab[k] = (USHORT) tmp;
    }

    for (; j < (LONG) EaHeader->QueryOffTabSize(); j++) {
        if (table->OffTab[j] != InvalidHandle) {
            table->OffTab[j] = InvalidHandle;
            changes = TRUE;
        }
    }

    if (changes) {
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_ERROR_IN_EA_HEADER);
        Message->Display();
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return TRUE;
}


VOID
FreeSpaceInBitmap(
    IN      ULONG       StartingCluster,
    IN      PCFAT       Fat,
    IN OUT  PBITVECTOR  FatBitMap
    )
{
    if (!StartingCluster) {
        return;
    }

    while (!Fat->IsEndOfChain(StartingCluster)) {
        FatBitMap->ResetBit(StartingCluster);
        StartingCluster = Fat->QueryEntry(StartingCluster);
    }
    FatBitMap->ResetBit(StartingCluster);
}


ULONG
ComputeFileNameHashValue(
    IN  PVOID   FileName
    )
{
    ULONG   h, g;
    BYTE    i;
    PUCHAR  p;

    p = (PUCHAR) FileName;
    h = 0;
    for (i=0; i<11; i++) {
        h = (h << 2) ^ p[i];
    }
    for (i=0; i<2; i++) {
        h = (h << 2) ^ p[i];
    }
    return h;
}

STATIC ULONG         _Twinkle = 0;
STATIC LONG64        _LastTwnkTime = 0;
STATIC ULONG         _LastPercent = 0xFFFFFFFF;

BOOLEAN
DisplayTwnkPercent(
    ULONG   percent
    )
{
    BIG_INT currenttime;

    NtQuerySystemTime((_LARGE_INTEGER *)&currenttime);

    // The above clock counts in 1/10,000ths of a second

    if((percent != _LastPercent) ||
       ((currenttime.GetQuadPart() - _LastTwnkTime) >= (6 * 100 * 10000)))
    {
        if(percent > 100) {
            percent = 100;
        }
        if((_Twinkle > 5) || _Verbose) {
            _Twinkle = 0;
        }
        if(_Verbose && (percent == _LastPercent)) {
            return TRUE;
        }
        _LastPercent = percent;
        _LastTwnkTime = currenttime.GetQuadPart();
        if(_pvfMessage) {
            STR  dots[6];

            dots[5] = '\0';
            dots[4] = ' ';
            dots[3] = ' ';
            dots[2] = ' ';
            dots[1] = ' ';
            dots[0] = ' ';
            switch(_Twinkle) {
                case 5:
                default:
                    dots[4] = '.';
                case 4:
                    dots[3] = '.';
                case 3:
                    dots[2] = '.';
                case 2:
                    dots[1] = '.';
                case 1:
                    dots[0] = '.';
                case 0:
                    ;
            }
            if(!_Verbose) {
                _Twinkle++;
            }
            _pvfMessage->Set(MSG_PERCENT_COMPLETE2);
            if (!_pvfMessage->Display("%d%s", percent, &dots[0])) {
                return FALSE;
            }
            if(_Verbose) {
                _pvfMessage->Set(MSG_BLANK_LINE);
                _pvfMessage->Display();
            }

        }
    }
    return TRUE;
}

VOID DoTwinkle(
    VOID
          )
{
    DisplayTwnkPercent(_LastPercent);
    return;
}

VOID DoInsufMemory(
   VOID
          )
{

    if(_pvfMessage) {
        _pvfMessage->Set(MSG_CHK_NO_MEMORY);
        _pvfMessage->Display();
    } else {
        DebugPrintTrace(("UFAT: Insufficient memory\n"));
    }
    return;
}

BOOLEAN
FAT_SA::WalkDirectoryTree(
    IN OUT  PEA_INFO        EaInfos,
    IN OUT  PUSHORT         NumEas,
    IN OUT  PBITVECTOR      FatBitMap,
    OUT     PFATCHK_REPORT  Report,
    IN      FIX_LEVEL       FixLevel,
    IN      BOOLEAN         RecoverAlloc,
    IN OUT  PMESSAGE        Message,
    IN      BOOLEAN         Verbose,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine walks all of the files on the volume by traversing
    the directory tree.  In doing so it validates all of the
    directory entries on the disk.  It also verifies the proper
    chaining of all file cluster chains.  This routine also validates
    the integrity of the EA handles for all of the directory entries
    on the disk.

    The FatBitMap is used to find and eliminate cross-links in the file
    system.

Arguments:

    EaInfos             - Supplies the EA information.
    NumEas              - Supplies the number of EA sets.
    FatBitMap           - Supplies a bit map marking all of the clusters
                            currently in use.
    Report              - Returns a FAT CHKDSK report on the files of the disk.
    FixLevel            - Supplies the CHKDSK fix level.
    Message             - Supplies an outlet for messages.
    Verbose             - Supplies whether or not to be verbose.
    NeedErrorsMessage   - Supplies whether or not errors have occurred
                            under check only conditions.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PVISIT_DIR      visit_list;
    ULONG           current_dir;
    PFATDIR         dir;
    FILEDIR         filedir;
    FAT_DIRENT      dirent;
    ULONG           i, j;
    ULONG           clus, next;
    DSTRING         file_path;
    PWSTRING        new_path;
    PWSTRING        current_path;
    ULONG           new_dir;
    DSTRING         filename;
    DSTRING         long_name;
    HMEM            hmem;
    CLUSTER_CHAIN   cluster;
    ULONG           new_chain;
    ULONG           cluster_size;
    ULONG           length;
    DSTRING         backslash;
    DSTRING         eafilename;
    DSTRING         eafilename_path;
    DSTRING         tmp_string;
    BOOLEAN         cross_link_detected;
    ULONG           cross_link_prevclus;
    HMEM            tmphmem;
    FILEDIR         tmpfiledir;
    FAT_DIRENT      tmpdirent1;
    FAT_DIRENT      tmpdirent2;
    BOOLEAN         non_zero_dirents;
    HASH_INDEX      file_name_hash_table;
    ULONG           hash_value;
    PULONG          matching_index_array;
    ULONG           matching_index_count;
    BOOLEAN         has_long_entry = FALSE;
    UCHAR           chksum;
    BOOLEAN         broke;
    ULONG           first_long_entry;
    FAT_DIRENT      dirent2;
    ULONG           percent;
    ULONG           allocated_clusters;
    BOOLEAN         processing_ea_file;
    ULONG           old_clus;
    ULONG           new_clus;
    UCHAR           FatType;
    USHORT          numEasLeft = *NumEas;
    ULONG           errFixedStatus = CHKDSK_EXIT_SUCCESS;


//    DebugAssert(sizeof(PUCHAR) <= sizeof(INT));
    DebugAssert(sizeof(USHORT) <= sizeof(INT));
    DebugAssert(sizeof(ULONG  ) <= sizeof(INT));

    visit_list = NULL;

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();

    if (!backslash.Initialize("\\") ||
        !eafilename.Initialize("EA DATA. SF") ||
        !eafilename_path.Initialize("\\EA DATA. SF")) {

        return FALSE;
    }

    if (!(current_path = NEW DSTRING) ||
        !current_path->Initialize(&backslash)) {

        return FALSE;
    }

    if (!PushVisitDir( &visit_list, 0, current_path )) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    Message->Set(MSG_CHK_CHECKING_FILES);
    Message->Display();

    percent = 0;
    if(!DisplayTwnkPercent(percent)) {
        return FALSE;
    }

    for (;
         PopVisitDir( &visit_list, &current_dir, &current_path );
         DELETE( current_path )) {

        DoTwinkle();

        has_long_entry = FALSE;

        if (current_dir) {
            if (!hmem.Initialize() ||
                !filedir.Initialize(&hmem, _drive, this, _fat, current_dir)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }

            if (!filedir.Read()) {
                Message->Set(MSG_BAD_DIR_READ);
                Message->Display();
                return FALSE;
            }

            dir = &filedir;
        } else {

           if ( _dir ) {
              dir = _dir;
              FatType = FAT_TYPE_EAS_OKAY;
           } else {
              dir = _dirF32;
              FatType = FAT_TYPE_FAT32;
           }

        }

        if (!file_name_hash_table.Initialize(dir->QueryNumberOfEntries(), 10)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        for (i = (current_dir ? 2 : 0); ; i++) {

            if (!dirent.Initialize(dir->GetDirEntry(i), FatType) ||
                dirent.IsEndOfDirectory()) {

                if (has_long_entry) {
                    //
                    // There was an orphaned lfn at the end of the
                    // directory.  Erase it now.
                    //

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_BAD_LONG_NAME);
                    Message->Display( "%W", current_path );

                    EraseAssociatedLongName(dir, first_long_entry, i);

                    has_long_entry = FALSE;
                }

                //
                // This code must make sure that all other directory
                // entries are end of directory entries.
                //
                non_zero_dirents = FALSE;

                for (; dirent.Initialize(dir->GetDirEntry(i),FatType); i++) {

                    if (!dirent.IsEndOfDirectory()) {
                        non_zero_dirents = TRUE;
                        dirent.SetEndOfDirectory();
                    }
                }

                if (non_zero_dirents) {
                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_TRAILING_DIRENTS);
                    Message->Display("%W", current_path);

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                }

                break;
            }

            if (dirent.IsErased()) {

                if (has_long_entry) {

                    //
                    // The preceding lfn is orphaned.  Remove it.
                    //

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_BAD_LONG_NAME);
                    Message->Display( "%W", current_path );

                    EraseAssociatedLongName(dir, first_long_entry, i);

                    has_long_entry = FALSE;
                }

                continue;
            }

            if (dirent.IsLongEntry()) {

                // skip long name entries; come back to them later

                if (has_long_entry) {
                    // already amid long entry
                    continue;
                }

                // first long entry

                has_long_entry = TRUE;
                first_long_entry = i;
                continue;
            }

            dirent.QueryName(&filename);

            if (has_long_entry) {

                DSTRING lfn;

                //
                // The current entry is short, and we've just finished
                // skipping the associated long entry.  Look back through
                // the long entries, make sure they're okay.
                //

                broke = FALSE;

                chksum = dirent.QueryChecksum();

                for (j = i - 1; j >= first_long_entry; j--) {
                    dirent2.Initialize(dir->GetDirEntry(j),FatType);

                    if (!dirent2.IsLongNameEntry()) {
                        continue;
                    }

                    broke = (dirent2.QueryLongOrdinal() != i - j) ||
                            (dirent2.QueryChecksum() != chksum) ||
                            (LOUSHORT(dirent2.QueryStartingCluster()) != 0);

                    broke = broke || !dirent2.IsWellTerminatedLongNameEntry();

                    if (broke || dirent2.IsLastLongEntry()) {
                        break;
                    }
                }

                broke = broke || (!dirent2.IsLastLongEntry());

                if (!broke && dir->QueryLongName(i, &lfn)) {
                    broke = !FAT_DIRENT::IsValidLongName(&lfn);
                }

#if 0
//MJB: We'll elide this code because Win95 isn't this strict and we
// don't want to delete all their lfn's.

                if (!broke && dir->QueryLongName(i, &lfn)) {

                    broke = !dirent.NameHasTilde() &&
                        (dirent.NameHasExtendedChars() ||
                            0 != filename.Stricmp(&lfn)) &&
                        !IsString8Dot3(&lfn);
                }
#endif

                if (broke) {

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                    //
                    // Erase all the long name entries.
                    //

                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_BAD_LONG_NAME);
                    Message->Display( "%W", current_path );

                    EraseAssociatedLongName(dir, first_long_entry, i);

                    has_long_entry = FALSE;

                }

                //
                // Fall into code to check short name.
                //
            }

            DoTwinkle();

            dirent.QueryName(&filename);

            if (!file_path.Initialize(current_path)) {
                return FALSE;
            }

            if (current_dir) {
                if (!file_path.Strcat(&backslash)) {
                    return FALSE;
                }
            }

            if (dir->QueryLongName(i, &long_name) &&
                long_name.QueryChCount() != 0) {

                if (!file_path.Strcat(&long_name)) {
                    return FALSE;
                }

            } else {

                if (!file_path.Strcat(&filename)) {
                    return FALSE;
                }
            }

            if (Verbose && !dirent.IsVolumeLabel()) {
                Message->Set(MSG_CHK_FILENAME);
                Message->Display("%W", &file_path);
            }

            if (!ValidateDirent(&dirent, &file_path, FixLevel, RecoverAlloc,
                                Report, Message, NeedErrorsMessage, FatBitMap,
                                &cross_link_detected, &cross_link_prevclus)) {
                return FALSE;
            }

            DoTwinkle();

            if (dirent.IsErased()) {

                //
                // ValidateDirent erased this entry, presumably because it's
                // hosed.  Remove corresponding long name, if any.
                //

                if (has_long_entry) {
                    EraseAssociatedLongName(dir, first_long_entry, i);
                    has_long_entry = FALSE;
                }
                continue;
            }

            //
            // Analyze for duplicate names
            //
            if (!dirent.IsVolumeLabel()) {

                BOOLEAN     renamed = FALSE;
                ULONG       renaming_positions = 0;
                FAT_DIRENT  temp_dirent;
                DSTRING     new_filename;
                BOOLEAN     changes = FALSE;

                if (!CheckAndFixFileName(dir->GetDirEntry(i), &changes)) {
                    Message->Set(MSG_CHK_UNHANDLED_INVALID_NAME);
                    Message->Display("%W%W", &filename, current_path);
                }

                for (;;) {
                    hash_value = ComputeFileNameHashValue(dir->GetDirEntry(i));

                    if (!file_name_hash_table.QueryAndAdd(hash_value,
                                                          i,
                                                          &matching_index_array,
                                                          &matching_index_count)) {
                        Message->Set(MSG_CHK_NO_MEMORY);
                        Message->Display();
                        return FALSE;
                    }

                    DebugAssert(matching_index_count >= 1);
                    matching_index_count--;

                    if (matching_index_count &&
                        IsFileNameMatch(dir, FatType, i, matching_index_count, matching_index_array)) {

                        file_name_hash_table.RemoveLastEntry(hash_value, i);

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        renamed = TRUE;
                        if (!RenameFileName(&renaming_positions, dir->GetDirEntry(i))) {

                            if (!temp_dirent.Initialize(dir->GetDirEntry(i), FatType)) {
                                if (!new_filename.Initialize(L"????????.???")) {
                                    Message->Set(MSG_CHK_NO_MEMORY);
                                    Message->Display();
                                    return FALSE;
                                }
                            } else {
                                if (!temp_dirent.QueryName(&new_filename)) {
                                    Message->Set(MSG_CHK_NO_MEMORY);
                                    Message->Display();
                                    return FALSE;
                                }
                            }

                            dofmsg(Message, NeedErrorsMessage);
                            Message->Set(MSG_CHK_RENAMING_FAILURE);
                            Message->Display("%W%W%W", &filename, current_path, &new_filename);

                            if (!filename.Initialize(&new_filename)) {
                                Message->Set(MSG_CHK_NO_MEMORY);
                                Message->Display();
                                return FALSE;
                            }

                            if (!file_path.Initialize(current_path)) {
                                return FALSE;
                            }

                            if (current_dir) {
                                if (!file_path.Strcat(&backslash)) {
                                    return FALSE;
                                }
                            }

                            if (dir->QueryLongName(i, &long_name) &&
                                long_name.QueryChCount() != 0) {

                                if (!file_path.Strcat(&long_name)) {
                                    return FALSE;
                                }

                            } else {

                                if (!file_path.Strcat(&new_filename)) {
                                    return FALSE;
                                }
                            }

                            break;  // done
                        } else {

                            if (!temp_dirent.Initialize(dir->GetDirEntry(i), FatType)) {
                                if (!new_filename.Initialize(L"????????.???")) {
                                    Message->Set(MSG_CHK_NO_MEMORY);
                                    Message->Display();
                                    return FALSE;
                                }
                            } else {
                                if (!temp_dirent.QueryName(&new_filename)) {
                                    Message->Set(MSG_CHK_NO_MEMORY);
                                    Message->Display();
                                    return FALSE;
                                }
                            }

                            dofmsg(Message, NeedErrorsMessage);
                            Message->Set(MSG_CHK_RENAMED_REPEATED_ENTRY);
                            Message->Display("%W%W%W", &filename, current_path, &new_filename);
                        }

                    } else if (renamed) {

                        if (!temp_dirent.Initialize(dir->GetDirEntry(i), FatType)) {
                            if (!new_filename.Initialize(L"????????.???")) {
                                Message->Set(MSG_CHK_NO_MEMORY);
                                Message->Display();
                                return FALSE;
                            }
                        } else {
                            if (!temp_dirent.QueryName(&new_filename)) {
                                Message->Set(MSG_CHK_NO_MEMORY);
                                Message->Display();
                                return FALSE;
                            }
                        }

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        dofmsg(Message, NeedErrorsMessage);
                        Message->Set(MSG_CHK_RENAMED_REPEATED_ENTRY);
                        Message->Display("%W%W%W", &filename, current_path, &new_filename);

                        if (!filename.Initialize(&new_filename)) {
                            Message->Set(MSG_CHK_NO_MEMORY);
                            Message->Display();
                            return FALSE;
                        }

                        if (!file_path.Initialize(current_path)) {
                            return FALSE;
                        }

                        if (current_dir) {
                            if (!file_path.Strcat(&backslash)) {
                                return FALSE;
                            }
                        }

                        if (dir->QueryLongName(i, &long_name) &&
                            long_name.QueryChCount() != 0) {

                            if (!file_path.Strcat(&long_name)) {
                                return FALSE;
                            }

                        } else {

                            if (!file_path.Strcat(&new_filename)) {
                                return FALSE;
                            }
                        }

                        break;  // no more conflict, done

                    } else if (changes) {

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        dofmsg(Message, NeedErrorsMessage);
                        Message->Set(MSG_CHK_INVALID_NAME_CORRECTED);
                        Message->Display("%W%W", &filename, current_path);
                        break;  // done

                    } else
                        break;  // done as there is no name conflict

                    DoTwinkle();
                }
            }

            DoTwinkle();

            //
            // Analyze for cross-links.
            //
            if (cross_link_detected) {  // CROSSLINK !!

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                // Identify cross linked cluster.

                clus = cross_link_prevclus;

                next = cross_link_prevclus ?
                       _fat->QueryEntry(cross_link_prevclus) :
                       dirent.QueryStartingCluster();

                dofmsg(Message, NeedErrorsMessage);
                Message->Set(MSG_CROSS_LINK);
                Message->Display("%W%d", &file_path, next);

                processing_ea_file = (eafilename_path == file_path);

                if (dirent.IsDirectory()) {

                    DebugAssert(!processing_ea_file);

                    Message->Set(MSG_CHK_DIR_TRUNC);
                    Message->Display();

                    if (clus) {
                        _fat->SetEndOfChain(clus);
                    } else {
                        dirent.SetErased();
                        if (has_long_entry) {
                            EraseAssociatedLongName(dir, first_long_entry, i);
                            has_long_entry = FALSE;
                        }
                        continue;
                    }

                } else {

                    if (!CopyClusters(next, &new_chain, FatBitMap,
                                      FixLevel, Message)) {
                        return FALSE;
                    }

                    if (new_chain) {
                        Message->Set(MSG_CHK_CROSS_LINK_COPY);
                        Message->Display();

                        if (processing_ea_file) {

                            USHORT      j;

                            old_clus = next;
                            new_clus = new_chain;
                            for(;;) {
                                for (j=0; j<*NumEas; j++) {
                                    if (EaInfos[j].PreceedingCn == old_clus) {
                                        EaInfos[j].PreceedingCn = new_clus;
                                    } else if (EaInfos[j].LastCn == old_clus) {
                                        EaInfos[j].LastCn = new_clus;
                                    }
                                }
                                if (_fat->IsEndOfChain(new_clus) || _fat->IsEndOfChain(old_clus)) {
                                    DebugAssert(_fat->IsEndOfChain(new_clus) &&
                                                _fat->IsEndOfChain(old_clus));
                                    break;
                                }
                                old_clus = _fat->QueryEntry(old_clus);
                                new_clus = _fat->QueryEntry(new_clus);
                            }
                        }

                        if (clus) {
                            _fat->SetEntry(clus, new_chain);
                        } else {
                            dirent.SetStartingCluster(new_chain);
                        }

                    } else {

                        Message->Set(MSG_CHK_CROSS_LINK_TRUNC);
                        Message->Display();

                        if (clus) {

                            if (processing_ea_file) {

                                USHORT      j;

                                old_clus = next;
                                for(;;) {
                                    for (j=0; j<*NumEas; j++) {
                                        if (EaInfos[j].LastCn == old_clus) {
                                            numEasLeft = j;
                                            break;
                                        }
                                    }
                                    if (_fat->IsEndOfChain(old_clus))
                                        break;
                                    old_clus = _fat->QueryEntry(old_clus);
                                }
                            }

                            _fat->SetEndOfChain(clus);
                            dirent.SetFileSize(
                                    cluster_size*_fat->QueryLengthOfChain(
                                    dirent.QueryStartingCluster()));

                        } else {
                            numEasLeft = 0;
                            dirent.SetErased();

                            if (has_long_entry) {
                                EraseAssociatedLongName(dir, first_long_entry,
                                    i);
                                has_long_entry = FALSE;
                            }
                        }
                    }
                }
            }

            DoTwinkle();

            if (!ValidateEaHandle(&dirent, current_dir, i, EaInfos, *NumEas,
                                  &file_path, FixLevel, Report, Message,
                                  NeedErrorsMessage)) {
                return FALSE;
            }

            DoTwinkle();

            //
            // Do special stuff if the current entry is a directory.
            //

            if (dirent.IsDirectory()) {

                new_dir = dirent.QueryStartingCluster();

                //
                // Validate the integrity of the directory.
                //

                // Very first make sure it actually has a valid starting clus (check for 0)

                if(!(_fat->IsInRange(new_dir))) {

                    if (dirent.IsDot() ||
                    dirent.IsDotDot()) {

                    // If this happens on the . or .. entry just ignore it as it will
                    // get fixed up later.

                    continue;
                    }

                    Message->Set(MSG_CHK_ERROR_IN_DIR);
                            Message->Display("%W", &file_path);
                            Message->Set(MSG_CHK_CONVERT_DIR_TO_FILE, NORMAL_MESSAGE, TEXT_MESSAGE);
                            Message->Display();
                    if (Message->IsYesResponse(TRUE)) {
                        dirent.ResetDirectory();
                        dirent.SetStartingCluster(0);
                        dirent.SetFileSize(0);
                    }
                    continue;
                }

                // Read the directory.

                if (!tmphmem.Initialize() ||
                    !tmpfiledir.Initialize(&tmphmem, _drive, this, _fat,
                                           new_dir) ||
                    !tmpfiledir.Read()) {
                        Message->Set(MSG_CHK_NO_MEMORY);
                        Message->Display();

                        return FALSE;
                }

                // Check the . and .. entries.

                if (!tmpdirent1.Initialize(tmpfiledir.GetDirEntry(0),FatType) ||
                    !tmpdirent2.Initialize(tmpfiledir.GetDirEntry(1),FatType)) {
                    DebugAbort("GetDirEntry of 0 and 1 failed!");
                    return FALSE;
                }

                if (!tmpdirent1.IsDot() ||
                    !tmpdirent2.IsDotDot() ||
                    !tmpdirent1.IsDirectory() ||
                    !tmpdirent2.IsDirectory()) {

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_ERROR_IN_DIR);
                    Message->Display("%W", &file_path);
                    Message->Set(MSG_CHK_CONVERT_DIR_TO_FILE, NORMAL_MESSAGE, TEXT_MESSAGE);
                    Message->Display();

                    if (Message->IsYesResponse(TRUE)) {
                        dirent.ResetDirectory();
                        dirent.SetFileSize(
                               _fat->QueryLengthOfChain(new_dir)*
                               cluster_size);

                    } else {

                        FreeSpaceInBitmap(dirent.QueryStartingCluster(),
                                          _fat, FatBitMap);

                        dirent.SetErased();

                        if (has_long_entry) {
                            EraseAssociatedLongName(dir, first_long_entry, i);
                            has_long_entry = FALSE;
                        }
                        continue;
                    }

                } else {  // Directory looks valid.

                    if (tmpdirent1.QueryStartingCluster() != new_dir ||
                        tmpdirent2.QueryStartingCluster() != current_dir ||
                        tmpdirent1.QueryFileSize() ||
                        tmpdirent2.QueryFileSize()) {

                        dofmsg(Message, NeedErrorsMessage);
                        Message->Set(MSG_CHK_ERRORS_IN_DIR_CORR);
                        Message->Display("%W", &file_path);

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        tmpdirent1.SetStartingCluster(new_dir);
                        tmpdirent2.SetStartingCluster(current_dir);
                        tmpdirent1.SetFileSize(0);
                        tmpdirent2.SetFileSize(0);

                        if (FixLevel != CheckOnly && !tmpfiledir.Write()) {
                            DebugAbort("Could not write tmp file dir.");
                            return FALSE;
                        }
                    }

                    // Add the directory to the list of directories
                    // to validate.

                    if (!(new_path = NEW DSTRING) ||
                        !new_path->Initialize(&file_path)) {

                        Message->Set(MSG_CHK_NO_MEMORY);
                        Message->Display();
                        return FALSE;
                    }

                    if (!PushVisitDir( &visit_list, new_dir, new_path )) {
                        Message->Set(MSG_CHK_NO_MEMORY);
                        Message->Display();
                        return FALSE;
                    }
                }
            }

            //
            // Generate report stats.
            //

            if (current_dir || !(filename == eafilename)) {
                length = _fat->QueryLengthOfChain(dirent.QueryStartingCluster());
                if (dirent.IsHidden()) {
                    Report->HiddenEntriesCount++;
                    Report->HiddenClusters += length;
                } else if (dirent.IsDirectory()) {
                    Report->DirEntriesCount++;
                    Report->DirClusters += length;
                } else if (!dirent.IsVolumeLabel()) {
                    Report->FileEntriesCount++;
                    Report->FileClusters += length;
                }
            }

            allocated_clusters = _fat->QueryAllocatedClusterCount();

            if (0 == allocated_clusters) {
                allocated_clusters++;   // Prevent divide by 0
            }

            percent = (Report->HiddenClusters + Report->DirClusters +
                      Report->FileClusters) * 100 / allocated_clusters;

            if(!DisplayTwnkPercent(percent)) {
                return FALSE;
            }
            has_long_entry = FALSE;
        }

        file_name_hash_table.DumpHashTable();
#if 0
        //
        // The following line should be moved to REAL_FAT_SA::Write.
        //
        //
        //  t-raymak
        //  The placement of the following line actually touches upon
        //  the philosophical dilemma of what makes a superarea a superarea.
        //  In the good old FAT16/12 days when the root directory is a fixed size
        //  structure and sitting right next to the fat and boot sector, it kind
        //  of makes sense to define the superarea as a run of sectors including the
        //  the root directory. But now that the FAT32 root directory is defined
        //  as a cluster chain, is the superarea still an area (or a run of sectors
        //  as a matter of fact) by including the FAT32 root directory?(Rhetorical
        //  question) Hence I can sort of understand why the following line
        //  is placed where it is originally (but this is an incomplete job
        //  considering the fact that the FAT32 root directory is still part of
        //  the superarea object). So in order to honor the fine tradition of
        //  totally embedding the root directory into the superarea, I have decided
        //  to move the following line to the Write method of the FAT superarea
        //  object. The proper way out of this dilemma is to define the superarea
        //  as a persistent object which is not necessarily a contagious run of
        //  sectors. (I think I get a little bit carried away.)
        //
        if((_dirF32) && !(current_dir)) { //root directory fix
            if (FixLevel != CheckOnly && !_dirF32->Write()) {
                _Verbose = FALSE;
                _pvfMessage = NULL;
                return FALSE;
            }
        }
#endif

        if (current_dir) {
            if (FixLevel != CheckOnly && !filedir.Write()) {
                _Verbose = FALSE;
                _pvfMessage = NULL;
                return FALSE;
            }
        }
    }

    percent = 100;
    if(!DisplayTwnkPercent(percent)) {
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }
    Message->Set(MSG_CHK_DONE_CHECKING);
    Message->Display();

    *NumEas = numEasLeft;
    _Verbose = FALSE;
    _pvfMessage = NULL;

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return TRUE;
}


BOOLEAN
FAT_SA::ValidateDirent(
    IN OUT  PFAT_DIRENT     Dirent,
    IN      PCWSTRING       FilePath,
    IN      FIX_LEVEL       FixLevel,
    IN      BOOLEAN         RecoverAlloc,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage,
    IN OUT  PBITVECTOR      FatBitMap,
    OUT     PBOOLEAN        CrossLinkDetected,
    OUT     PULONG          CrossLinkPreviousCluster
    )
/*++

Routine Description:

    This routine verifies that all components of a directory entry are
    correct.  If the time stamps are invalid then they will be corrected
    to the current time.  If the filename is invalid then the directory
    entry will be marked as deleted.  If the cluster number is out of
    disk range then the directory entry will be marked as deleted.
    Otherwise, the cluster chain will be validated and the length of
    the cluster chain will be compared against the file size.  If there
    is a difference then the file size will be corrected.

    If there are any strange errors then FALSE will be returned.

Arguments:

    Dirent                      - Supplies the directory entry to validate.
    FilePath                    - Supplies the full path name for the directory
                                    entry.
    RecoverAlloc                - Supplies whether or not to recover all
                                    allocated space on the volume.
    Report                      - Supplies the fat chkdsk report structures for storing the
                                    actions performed by this method.
    Message                     - Supplies an outlet for messages.
    NeedErrorsMessage           - Supplies whether or not an error has
                                    occurred during check only mode.
    FatBitMap                   - Supplies a bitmap marking in use all known
                                    clusters.
    CrossLinkDetected           - Returns TRUE if the file is cross-linked with
                                   another.
    CrossLinkPreviousCluster    - Returns the cluster previous to the
                                    cross-linked one.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   start_clus;
    BOOLEAN changes;
    ULONG   length;
    ULONG   max_file_size;
    ULONG   min_file_size;
    ULONG   clus;
    BIG_INT tmp_big_int;
    ULONG   file_size;
    ULONG   cluster_size;
    BOOLEAN recover_status;
    ULONG   errFixedStatus = CHKDSK_EXIT_SUCCESS;
    BOOLEAN minor_inconsistency_found = FALSE;

    DebugAssert(CrossLinkDetected);
    DebugAssert(CrossLinkPreviousCluster);

    *CrossLinkDetected = FALSE;

    if (Dirent->IsErased()) {
        return TRUE;
    }

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();

    // Try to validate names that can be created under different languages

    if (!Dirent->IsValidName()) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_INVALID_NAME);
        Message->Display("%W", FilePath);
        Dirent->SetErased();
        return TRUE;
    }

    if (!Dirent->IsValidLastWriteTime()) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_INVALID_TIME_STAMP);
        Message->Display("%W", FilePath);
        if (!Dirent->SetLastWriteTime()) {
            return FALSE;
        }
    }

    if (!Dirent->IsVolumeLabel()) {
        if (!Dirent->IsValidCreationTime()) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_INVALID_TIME_STAMP);
            Message->Display("%W", FilePath);
            if (!Dirent->SetCreationTime()) {
                return FALSE;
            }
        }

        if (!Dirent->IsValidLastAccessTime()) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_INVALID_TIME_STAMP);
            Message->Display("%W", FilePath);
            if (!Dirent->SetLastAccessTime()) {
                return FALSE;
            }
        }
    }

    if (Dirent->IsDirectory() && Dirent->QueryFileSize()) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_DIR_HAS_FILESIZE);
        Message->Display("%W", FilePath);
        Dirent->SetFileSize( 0 );
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    if ((start_clus = Dirent->QueryStartingCluster()) != 0 ) {
        if (!_fat->IsInRange(start_clus) || _fat->IsClusterFree(start_clus)) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_BAD_FIRST_UNIT);
            Message->Display("%W", FilePath);

            Dirent->SetErased();
            UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);
            return TRUE;
        }

        _fat->ScrubChain(start_clus, FatBitMap, &changes,
                         CrossLinkDetected, CrossLinkPreviousCluster);

        if (changes) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_BAD_LINK);
            Message->Display("%W", FilePath);
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

        if (Dirent->IsDirectory() || RecoverAlloc) {

            //
            // Validate the readability of the directory or file
            // in the case that 'RecoverAlloc' is TRUE.
            //
            if (Dirent->IsDirectory()) {
                if (!(recover_status = RecoverChain(&start_clus, &changes, 0, FALSE, FatBitMap))) {
                   Message->Set(MSG_CHK_NO_MEMORY);
                   Message->Display();
                   return FALSE;
                }
            } else if (FixLevel != CheckOnly) {

               // t-raymak: If we check the recover status for directory, why shouldn't we check
               // the recover status for file also? (I added the following check.)
               if (!(recover_status = RecoverChain(&start_clus, &changes, 0, TRUE, FatBitMap))) {
                   Message->Set(MSG_CHK_NO_MEMORY);
                   Message->Display();
                   return FALSE;
               }
            } else {
                recover_status = TRUE;
                changes = FALSE;
            }

            if (changes) {
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                dofmsg(Message, NeedErrorsMessage);
                if (Dirent->IsDirectory()) {
                    if (!start_clus) {
                        Message->Set(MSG_CHK_BAD_DIR);
                        Message->Display("%W", FilePath);
                        Dirent->SetErased();
                        UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);
                        return TRUE;
                    } else {
                        Message->Set(MSG_CHK_BAD_CLUSTERS_IN_DIR);
                        Message->Display("%W", FilePath);
                        Dirent->SetStartingCluster(start_clus);
                    }
                } else {
                    // In the file case, since we're replacing bad clusters
                    // with new ones, start_clus cannot be zero.
                    DebugAssert(start_clus);

                    if (recover_status) {
                        Message->Set(MSG_CHK_BAD_CLUSTERS_IN_FILE_SUCCESS);
                        Message->Display("%W", FilePath);
                    } else {
                        Message->Set(MSG_CHK_BAD_CLUSTERS_IN_FILE_FAILURE);
                        Message->Display();
                    }
                    Dirent->SetStartingCluster(start_clus);
                }
            }
        }

        // Note here that we know here that start_clus != 0 so length will be
        // at least 1.

        tmp_big_int = length = _fat->QueryLengthOfChain(start_clus);

        tmp_big_int = tmp_big_int * cluster_size;

        if (tmp_big_int.GetHighPart()) {
            if ((tmp_big_int.GetHighPart() != 1) || tmp_big_int.GetLowPart()) {
                //
                // Cluster chain is > 4GB in size, error. Max allowed is 4GB worth
                // of clusters. Note that since cluster size is a power of 2 (since
                // sec/clus and sector_size are both powers of 2) we KNOW that cluster_size
                // evenly divides 4GB.
                //
                clus = start_clus;
                tmp_big_int = cluster_size;
                while(tmp_big_int.GetHighPart() == 0) {
                    clus = _fat->QueryEntry(clus);
                    tmp_big_int += cluster_size;
                }
                _fat->SetEndOfChain(clus);

                // This message is not exactly correct, but saying that the file size
                // is messed up is not totally unreasonable..........

                dofmsg(Message, NeedErrorsMessage);
                Message->Set(MSG_BAD_FILE_SIZE);
                Message->Display("%W", FilePath);
                Dirent->SetFileSize(0xFFFFFFFF);
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
            max_file_size = 0xFFFFFFFF;
            min_file_size = (0xFFFFFFFF - cluster_size) + 2;
        } else {
            max_file_size = tmp_big_int.GetLowPart();
            min_file_size = (max_file_size - cluster_size) + 1;
        }

        if (( file_size = Dirent->QueryFileSize()) != 0 ) {
            if (file_size > max_file_size ||
                file_size < min_file_size) {

                if (file_size > max_file_size) {
                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_BAD_FILE_SIZE);
                    Message->Display("%W", FilePath);
                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                }

                if (file_size < min_file_size) {

                    minor_inconsistency_found = TRUE;

                    WCHAR   fpath[MAX_PATH];

                    if (!FilePath->QueryWSTR(0, TO_END, fpath, MAX_PATH, TRUE)) {
                        fpath[0] = '?';
                        fpath[1] = 0;
                    }

                    DebugPrintTrace(("UFAT: %ls of size %x should be within %x and %x bytes.\n",
                                     fpath, file_size, min_file_size, max_file_size));
                }

                Dirent->SetFileSize(max_file_size);
            }
        } else {
            if (!Dirent->IsDirectory()) {
                dofmsg(Message, NeedErrorsMessage);
                Message->Set(MSG_BAD_FILE_SIZE);
                Message->Display("%W", FilePath);
                Dirent->SetFileSize(max_file_size);
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }
    } else {
        if (Dirent->IsDirectory() && !Dirent->IsDotDot()) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_BAD_LINK);
            Message->Display("%W", FilePath);
            Dirent->SetErased();
            UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);
            return TRUE;
        }

        if (Dirent->QueryFileSize()) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_BAD_FILE_SIZE);
            Message->Display("%W", FilePath);
            Dirent->SetFileSize(0);
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    if (minor_inconsistency_found &&
        Report->ExitStatus == CHKDSK_EXIT_SUCCESS) {
        Report->ExitStatus = CHKDSK_EXIT_MINOR_ERRS;
        if (_Verbose) {
            Message->Set((FixLevel == CheckOnly) ?
                            MSG_CHK_MINOR_ERRORS_DETECTED :
                            MSG_CHK_MINOR_ERRORS_FIXED);
            Message->Display();
        }
    }

    return TRUE;
}


BOOLEAN
FAT_SA::EraseEaHandle(
    IN      PEA_INFO    EaInfos,
    IN      USHORT      NumEasLeft,
    IN      USHORT      NumEas,
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine erases the EA handle that references ea set beyond the
    number of ea sets that should be left.

Arguments:

    EaInfos             - Supplies the list of current EA information.
    NumEasLeft          - Supplies the number of EA sets that should be in EaInfos.
    NumEas              - Supplies the total number of EA sets.
    FixLevel            - Supplies the fix up level.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM        hmem;
    FILEDIR     filedir;
    FAT_DIRENT  other_dirent;
    USHORT      i;

    for (i=NumEasLeft; i<NumEas; i++) {
        if (EaInfos[i].UserFileEntryCn) {
            if (!hmem.Initialize() ||
                !filedir.Initialize(&hmem, _drive, this, _fat,
                                    EaInfos[i].UserFileEntryCn) ||
                !filedir.Read() ||
                !other_dirent.Initialize(filedir.GetDirEntry(
                                         EaInfos[i].UserFileEntryNumber), FAT_TYPE_EAS_OKAY)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }
        } else {
            if (!other_dirent.Initialize(_dir->GetDirEntry(
            // Default _dir works because FAT 32 won't have EA's on it to validate
                                         EaInfos[i].UserFileEntryNumber), FAT_TYPE_EAS_OKAY)) {

                return FALSE;
            }
        }

        //
        // Do not follow an EA link to an LFN entry. Zeroing the EA handle in an LFN entry
        // destroys name data. The link is probably just invalid
        //
        if (!other_dirent.IsLongNameEntry()) {

            other_dirent.SetEaHandle(0);

            if (EaInfos[i].UserFileEntryCn && FixLevel != CheckOnly &&
                !filedir.Write()) {
                return FALSE;
            }
        }
    }
    return TRUE;
}

BOOLEAN
FAT_SA::ValidateEaHandle(
    IN OUT  PFAT_DIRENT     Dirent,
    IN      ULONG           DirClusterNumber,
    IN      ULONG           DirEntryNumber,
    IN OUT  PEA_INFO        EaInfos,
    IN      USHORT          NumEas,
    IN      PCWSTRING       FilePath,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine validates the EA handle in the directory entry 'Dirent'.
    It ensures that it references an actual EA set.  It also ensures
    that it is the only directory entry which references the EA set.

    If several entries try to reference the same EA set then ties will
    be broken based on the 'OwnerFileName' entry in the EA set.

Arguments:

    Dirent              - Supplies the directory entry to validate.
    DirClusterNumber    - Supplies the cluster number of the directory
                          containing the dirent.
    DirEntryNumber      - Supplies the position of the directory entry in
                          the directory.
    EaInfos             - Supplies the list of current EA information.
    NumEas              - Supplies the number of EA sets.
    FilePath            - Supplies the full path name for the directory entry.
    FixLevel            - Supplies the fix up level.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occurred
                          during check only mode.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       i;
    USHORT      handle;
    DSTRING     wfilename;
    STR         filename[14];
    BOOLEAN     remove_other_handle;
    HMEM        hmem;
    FILEDIR     filedir;
    FAT_DIRENT  other_dirent;
    ULONG       errFixedStatus = CHKDSK_EXIT_SUCCESS;


    if (!(handle = Dirent->QueryEaHandle())) {
        return TRUE;
    }
    // The above should exclude any FAT 32 drive.

    if (!EaInfos) {
        NumEas = 0;
    }

    for (i = 0; i < NumEas; i++) {
        if (handle == EaInfos[i].OwnHandle) {
            break;
        }
    }

    if (i == NumEas) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_UNRECOG_EA_HANDLE);
        Message->Display("%W", FilePath);
        Dirent->SetEaHandle(0);
        UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);
        return TRUE;
    }

    if (EaInfos[i].UsedCount >= 2) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_SHARED_EA);
        Message->Display("%W", FilePath);
        Dirent->SetEaHandle(0);
        UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);
        return TRUE;
    }

    Dirent->QueryName(&wfilename);
    if (!wfilename.QuerySTR( 0, TO_END, filename, 14)) {
        return FALSE;
    }

    if (EaInfos[i].UsedCount == 0) {
        memcpy(EaInfos[i].UserFileName, filename, 14);
        EaInfos[i].UserFileEntryCn = DirClusterNumber;
        EaInfos[i].UserFileEntryNumber = DirEntryNumber;
        EaInfos[i].UsedCount = 1;
        return TRUE;
    }


    // UsedCount == 1.

    remove_other_handle = FALSE;

    if (!strcmp(filename, EaInfos[i].OwnerFileName)) {

        remove_other_handle = TRUE;

        if (!strcmp(EaInfos[i].UserFileName,
                    EaInfos[i].OwnerFileName)) {

            EaInfos[i].UsedCount = 2;
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_SHARED_EA);
            Message->Display("%W", FilePath);
            Dirent->SetEaHandle(0);
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

    } else {

        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_SHARED_EA);
        Message->Display("%W", FilePath);
        Dirent->SetEaHandle(0);
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (strcmp(EaInfos[i].UserFileName,
                   EaInfos[i].OwnerFileName)) {

            EaInfos[i].UsedCount = 2;
            remove_other_handle = TRUE;
        }
    }


    if (remove_other_handle) {

        if (EaInfos[i].UserFileEntryCn) {
            if (!hmem.Initialize() ||
                !filedir.Initialize(&hmem, _drive, this, _fat,
                                    EaInfos[i].UserFileEntryCn) ||
                !filedir.Read() ||
                !other_dirent.Initialize(filedir.GetDirEntry(
                                         EaInfos[i].UserFileEntryNumber), FAT_TYPE_EAS_OKAY)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }
        } else {
            if (!other_dirent.Initialize(_dir->GetDirEntry(
                // Default _dir works because FAT 32 won't have EA's on it to validate
                                         EaInfos[i].UserFileEntryNumber), FAT_TYPE_EAS_OKAY)) {

                return FALSE;
            }
        }

        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_SHARED_EA);
        Message->Display("%W", FilePath);

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        //
        // Do not follow an EA link to an LFN entry. Zeroing the EA handle in an LFN entry
        // destroys name data. The link is probably just invalid
        //
        if (!other_dirent.IsLongNameEntry()) {
            other_dirent.SetEaHandle(0);

            if (EaInfos[i].UserFileEntryCn && FixLevel != CheckOnly &&
                !filedir.Write()) {

                return FALSE;
            }
        }
        strcpy(EaInfos[i].UserFileName, filename);
        EaInfos[i].UserFileEntryCn = DirClusterNumber;
        EaInfos[i].UserFileEntryNumber = DirEntryNumber;
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return TRUE;
}


BOOLEAN
FAT_SA::CopyClusters(
    IN      ULONG       SourceChain,
    OUT     PULONG      DestChain,
    IN OUT  PBITVECTOR  FatBitMap,
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine copies the cluster chain beginning at 'SourceChain'
    to a free portion of the disk.  The beginning of the copied chain
    will be returned in 'DestChain'.  If there isn't enough free space
    on the disk to copy the chain then 'DestChain' will return 0.

Arguments:

    SourceChain - Supplies the chain to copy.
    DestChain   - Returns the copy of the chain.
    FatBitMap   - Supplies the orphan and cross-link bitmap.
    FixLevel    - Supplies the CHKDSK fix level.
    Message     - Supplies an outlet for messages

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM            hmem;
    CLUSTER_CHAIN   cluster;
    ULONG           src, dst;
    BOOLEAN         changes;
    ULONG           clus;

    if (!hmem.Initialize()) {
        return FALSE;
    }

    if (!(*DestChain = _fat->AllocChain(
                       _fat->QueryLengthOfChain(SourceChain)))) {
        return TRUE;
    }

    changes = FALSE;
    if (FixLevel != CheckOnly && !RecoverChain(DestChain, &changes, 0, TRUE)) {
        if (*DestChain) {
            _fat->FreeChain(*DestChain);
        }
        *DestChain = 0;
        return TRUE;
    }

    if (IsCompressed() && !AllocSectorsForChain(*DestChain)) {
        _fat->FreeChain(*DestChain);
        *DestChain = 0;
        return TRUE;
    }

    // Mark the new chain as "used" in the FAT bitmap.
    for (clus = *DestChain;
         !_fat->IsEndOfChain(clus);
         clus = _fat->QueryEntry(clus)) {

        FatBitMap->SetBit(clus);
    }
    FatBitMap->SetBit(clus);

    src = SourceChain;
    dst = *DestChain;
    for (;;) {
        if (!cluster.Initialize(&hmem, _drive, this, _fat, src, 1)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        cluster.Read();

        if (!cluster.Initialize(&hmem, _drive, this, _fat, dst, 1)) {
            return FALSE;
        }

        if (FixLevel != CheckOnly && !cluster.Write()) {
            return FALSE;
        }

        if (_fat->IsEndOfChain(src)) {
            break;
        }

        src = _fat->QueryEntry(src);
        dst = _fat->QueryEntry(dst);
    }

    return TRUE;
}


BOOLEAN
FAT_SA::PurgeEaFile(
    IN      PEA_INFO        EaInfos,
    IN      USHORT          NumEas,
    IN OUT  PBITVECTOR      FatBitMap,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine is executed after the directory tree is walked.  Stored,
    in the EaInfos array, is information concerning which EAs get used
    and by how many files.

    If an EA set is not used, or is used by more than one file, then this
    routine will eliminate it from the EA file.

Arguments:

    EaInfos             - Supplies an array of EA information.
    NumEas              - Supplies the number of EA sets.
    FatBitMap           - Supplies the FAT cross-link detection bitmap.
    FixLevel            - Supplies the CHKDSK fix level.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occured
                          in check only mode.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LONG        i;
    EA_SET      easet;
    HMEM        hmem;
    PEA_HDR     eahdr;
    ULONG       clus;
    ULONG       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    if (!hmem.Initialize()) {
        return FALSE;
    }

    for (i = NumEas - 1; i >= 0; i--) {

        if (EaInfos[i].UsedCount != 1) {
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_UNUSED_EA_SET);
            Message->Display("%d", EaInfos[i].OwnHandle);

            // Mark the FAT entries of the removed chain as "not claimed",
            // for the purposes of orphan recovery.

            for (clus = _fat->QueryEntry(EaInfos[i].PreceedingCn);
                 clus != EaInfos[i].LastCn;
                 clus = _fat->QueryEntry(clus)) {

                FatBitMap->ResetBit(clus);

            }
            FatBitMap->ResetBit(clus);


            //
            // Remove the unused EA chain from the EA file.  Here we also
            // have to examine subsequent EaInfos; we may have to modify
            // several PreceedingCn entries if several adjacent EA chains
            // have been removed.
            //

            _fat->RemoveChain(EaInfos[i].PreceedingCn,
                              EaInfos[i].LastCn);

            for (LONG j = i + 2; j < NumEas; j++) {
                if (EaInfos[j].PreceedingCn == EaInfos[i + 1].PreceedingCn) {

                    EaInfos[j].PreceedingCn = EaInfos[i].PreceedingCn;

                } else {
                    break;
                }
            }

            EaInfos[i + 1].PreceedingCn = EaInfos[i].PreceedingCn;

        } else if (strcmp(EaInfos[i].OwnerFileName,
                          EaInfos[i].UserFileName)) {

            if (!easet.Initialize(&hmem, _drive, this, _fat,
                                  _fat->QueryEntry(EaInfos[i].PreceedingCn),
                                  1) ||
                !easet.Read() ||
                !(eahdr = easet.GetEaSetHeader())) {
                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }

            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_NEW_OWNER_NAME);
            Message->Display("%d%s%s", EaInfos[i].OwnHandle,
                    eahdr->OwnerFileName, EaInfos[i].UserFileName);

            memcpy(eahdr->OwnerFileName, EaInfos[i].UserFileName, 14);

            if (FixLevel != CheckOnly && !easet.Write()) {
                return FALSE;
            }
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return TRUE;
}

BOOLEAN
FAT_SA::RecoverOrphans(
    IN OUT  PBITVECTOR     FatBitMap,
    IN      FIX_LEVEL      FixLevel,
    IN OUT  PMESSAGE       Message,
    IN OUT  PBOOLEAN       NeedErrorsMessage,
    IN OUT  PFATCHK_REPORT Report
    )
/*++

Routine Description:

    This routine examines the file system for cluster chains which are
    not claimed by any file.  These 'orphans' will then be recovered in
    a subdirectory of the root or removed from the system.

Arguments:

    FatBitMap           - Supplies a bit map marking all currently used
                            clusters.
    FixLevel            - Supplies the CHKDSK fix level.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occured
                            in check only mode.
    Report              - Supplies the fat chkdsk report structures for storing the
                            actions performed by this method.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    //
    // Why the below define placing an artificial limit on the number of orphans?
    // 1.) The format for the file names is "FILE%04d.CHK" starting at 0 so we can
    //     do only 0-9999 before generating a duplicate file name.
    // 2.) Since CHKDSK recovers all of the orphans into a single directory this prevents
    //     it from making a directory with a HUGE file count in it (which is a performance
    //     issue).
    //
    // There used to be a smaller limit on how many orphan files can be recovered in
    // autochk mode.  The limit was 1000 but AaronR found no truth to that anymore
    // and so the limit is changed to be the same as that in chkdsk which is 10000.
    // -DanielCh 3/7/2000
    //

    CONST ULONG maximum_orphans = 10000;

    ULONG       i;
    ULONG       clus;
    BOOLEAN     changes;
    HMEM        hmem;
    FILEDIR     found_dir;
    STR         found_name[14];
    DSTRING     wfound_name;
    STR         filename[14];
    FAT_DIRENT  dirent;
    ULONG       found_cluster;
    ULONG       orphan_count;
    ULONG       orphan_rec_clus_cnt;
    ULONG       cluster_size;
    ULONG       found_length;
    ULONG       next;
    PUCHAR      orphan_track;
    ULONG       cluster_count;
    ULONG       num_orphans;
    ULONG       num_orphan_clusters;
    DSTRING     tmp_string;
    BITVECTOR   tmp_bitvector;
    BOOLEAN     tmp_bool;
    ULONG       tmp_ulong;
    BIG_INT     tmp_big_int;
    MSGID       message_id;
    BOOLEAN     KSize;
    ULONG       errFixedStatus = CHKDSK_EXIT_SUCCESS;
    PFATDIR     _fat_dir;
    UCHAR       FatType;
    PVOID       p;
    ULONG       length;
    ULONG       starting_cluster;
    ULONG       num_of_entries;


    cluster_count = QueryClusterCount();

    if (!(orphan_track = NEW UCHAR[cluster_count])) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    memset(orphan_track, 0, cluster_count);

    if (!tmp_bitvector.Initialize(cluster_count)) {
        DELETE_ARRAY(orphan_track);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();

    num_orphans = 0;
    num_orphan_clusters = 0;
    for (i = FirstDiskCluster; _fat->IsInRange(i); i++) {
        if (!_fat->IsClusterFree(i) &&
            !FatBitMap->IsBitSet(i) &&
            !_fat->IsClusterBad(i) &&
            !_fat->IsClusterReserved(i)) {

            num_orphans++;

            tmp_bitvector.ResetAll();

            _fat->ScrubChain(i, &tmp_bitvector, &changes,
                             &tmp_bool, &tmp_ulong);

            if (changes) {
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                dofmsg(Message, NeedErrorsMessage);
                Message->Set(MSG_CHK_BAD_LINKS_IN_ORPHANS);
                Message->Display("%d", i);
            }

            num_orphan_clusters++;

            clus = i;
            while (!_fat->IsEndOfChain(clus)) {
                next = _fat->QueryEntry(clus);

                if (orphan_track[next] == 1) {
                    num_orphans--;
                    orphan_track[next] = 2;
                    break;
                }

                if (FatBitMap->IsBitSet(next)) {   // CROSSLINK !!

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_CROSS_LINKED_ORPHAN);
                    Message->Display("%d", clus);

                    _fat->SetEndOfChain(clus);

                    break;
                }

                num_orphan_clusters++;

                FatBitMap->SetBit(next);
                orphan_track[next] = 2;

                clus = next;
            }
            FatBitMap->SetBit(i);
            orphan_track[i] = 1;
        }
    }


    // Now scan through the secondary pointers in search of orphans.

    changes = FALSE;
    for (i = FirstDiskCluster; _fat->IsInRange(i); i++) {
        if (orphan_track[i]) {
            changes = TRUE;
            break;
        }
    }

    if (!changes) {
        // No orphans to recover.
        DELETE_ARRAY(orphan_track);
        return TRUE;
    }

    // Compute whether reporting size in bytes or kilobytes
    //
    // NOTE: The magic number 4095MB comes from Win9x's GUI SCANDISK utility
    //
    tmp_ulong = cluster_count - FirstDiskCluster;
    tmp_big_int = cluster_size;
    tmp_big_int = tmp_big_int * tmp_ulong;
    if (tmp_big_int.GetHighPart() || (tmp_big_int.GetLowPart() > (4095ul*1024ul*1024ul))) {
        KSize = TRUE;
    } else {
        KSize = FALSE;
    }

    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    dofmsg(Message, NeedErrorsMessage);
    Message->Set(MSG_CONVERT_LOST_CHAINS, NORMAL_MESSAGE, TEXT_MESSAGE);
    Message->Display();

    if (!Message->IsYesResponse(TRUE)) {

        if (FixLevel != CheckOnly) {

            for (i = FirstDiskCluster; _fat->IsInRange(i); i++) {
                if (orphan_track[i] == 1) {
                    _fat->FreeChain(i);
                }
            }
            if (KSize) {
                message_id = MSG_KILOBYTES_FREED;
            } else {
                message_id = MSG_BYTES_FREED;
            }
        } else {
            if (KSize) {
                message_id = MSG_KILOBYTES_WOULD_BE_FREED;
            } else {
                message_id = MSG_BYTES_WOULD_BE_FREED;
            }
        }

        tmp_big_int = cluster_size;
        tmp_big_int = tmp_big_int * num_orphan_clusters;
        if (KSize) {
            tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
        } else {
            tmp_ulong = tmp_big_int.GetLowPart();
        }
        Message->Set(message_id);
        Message->Display("%d", tmp_ulong);

        UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

        DELETE_ARRAY(orphan_track);
        return TRUE;
    }


    // Set up for orphan recovery.


    // Establish "FOUND.XXX" directory.
    for (i = 0; i < 1000; i++) {
        sprintf(found_name, "FOUND.%03d", i);
        if (!wfound_name.Initialize(found_name)) {

            DELETE_ARRAY(orphan_track);
            return FALSE;

        }

        if (_dir && !_dir->SearchForDirEntry(&wfound_name)) {

            break;

        } else if (_dirF32 && !_dirF32->SearchForDirEntry(&wfound_name)) {

            break;

        }


    }

    if (i == 1000) {

        tmp_big_int = cluster_size;
        tmp_big_int = tmp_big_int * num_orphan_clusters;
        if (KSize) {
            tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
        } else {
            tmp_ulong = tmp_big_int.GetLowPart();
            message_id = MSG_WOULD_BE_RECOVERED_FILES;
        }
        Message->Set(message_id);
        Message->Display("%d%d", tmp_ulong,
                                 num_orphans);
        Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
        DELETE_ARRAY(orphan_track);
        return TRUE;
    }

    found_length = ((min(num_orphans,maximum_orphans)*BytesPerDirent - 1)/cluster_size + 1);

    if (!(found_cluster = _fat->AllocChain(found_length)) &&
        !(found_cluster = _fat->AllocChain(found_length = 1))) {

        Message->Set(MSG_ORPHAN_DISK_SPACE);
        Message->Display();
        tmp_big_int = cluster_size;
        tmp_big_int = tmp_big_int * num_orphan_clusters;
        if (KSize) {
            tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
        } else {
            tmp_ulong = tmp_big_int.GetLowPart();
            message_id = MSG_WOULD_BE_RECOVERED_FILES;
        }
        Message->Set(message_id);
        Message->Display("%d%d", tmp_ulong,
                                 num_orphans);
        Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
        DELETE_ARRAY(orphan_track);
        return TRUE;
    }

    // Check the chain.
    changes = FALSE;
    if (FixLevel != CheckOnly &&
        !RecoverChain(&found_cluster, &changes, 0, TRUE)) {

        Message->Set(MSG_ORPHAN_DISK_SPACE);
        Message->Display();
        Message->Set(MSG_WOULD_BE_RECOVERED_FILES);
        Message->Display("%d%d", cluster_size*num_orphan_clusters,
                                 num_orphans);
        Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
        DELETE_ARRAY(orphan_track);
        return TRUE;
    }

    if (!hmem.Initialize() ||
        !found_dir.Initialize(&hmem, _drive, this, _fat, found_cluster)) {

        DELETE_ARRAY(orphan_track);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        DebugAbort( "Initialization failed" );
        return FALSE;
    }

    // Allocate space for the cluster chain in the sector heap (fat_db)

    if (IsCompressed() && !AllocSectorsForChain(found_cluster)) {
        _fat->FreeChain(found_cluster);
        Message->Set(MSG_ORPHAN_DISK_SPACE);
        Message->Display();
        Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
        DELETE_ARRAY(orphan_track);
        return TRUE;
    }

    memset(hmem.GetBuf(), 0, (UINT) hmem.QuerySize());

    if (_dir) {
       _fat_dir = _dir;
       FatType = FAT_TYPE_EAS_OKAY;
    }
    else {
       _fat_dir = _dirF32;
       FatType = FAT_TYPE_FAT32;
    }

    p = _fat_dir->GetFreeDirEntry();
    if (p == NULL && _dir == NULL)  {
        starting_cluster = _dirF32->QueryStartingCluster();
        length = _fat->QueryLengthOfChain(starting_cluster);
        num_of_entries = _dirF32->QueryNumberOfEntries();
        if (_fat->ReAllocChain(starting_cluster, ++length) != length ||
            (FixLevel != CheckOnly &&
             !RecoverChain(&starting_cluster, &changes, 0, TRUE))) {
            Message->Set(MSG_NO_ROOM_IN_ROOT);
            Message->Display();
            Message->Set(MSG_WOULD_BE_RECOVERED_FILES);
            Message->Display("%d%d", cluster_size*num_orphan_clusters,
                                     num_orphans);
            Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
            DELETE_ARRAY(orphan_track);
            return TRUE;
        }

        if (FixLevel != CheckOnly && !_dirF32->Write()) {
            DELETE_ARRAY(orphan_track);
            return FALSE;
        }

        if (!_hmem_F32->Initialize() ||
            !_dirF32->Initialize( _hmem_F32, _drive, this,
                                  _fat, starting_cluster) ||
            !_dirF32->Read()) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            Message->Set(MSG_WOULD_BE_RECOVERED_FILES);
            Message->Display("%d%d", cluster_size*num_orphan_clusters,
                                     num_orphans);
            Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
            DELETE_ARRAY(orphan_track);
            return TRUE;
        }
        for (i = num_of_entries; dirent.Initialize(_dirF32->GetDirEntry(i),FatType); i++) {
            dirent.SetEndOfDirectory();
        }

        p = _fat_dir->GetFreeDirEntry();
    }

    if (!dirent.Initialize(p, FatType)) {
        Message->Set(MSG_NO_ROOM_IN_ROOT);
        Message->Display();
        Message->Set(MSG_WOULD_BE_RECOVERED_FILES);
        Message->Display("%d%d", cluster_size*num_orphan_clusters,
                                 num_orphans);
        Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
        DELETE_ARRAY(orphan_track);
        return TRUE;
    }

    dirent.Clear();

    if (!dirent.SetName(&wfound_name)) {
        DELETE_ARRAY(orphan_track);
        return FALSE;
    }

    dirent.SetDirectory();
    dirent.SetHidden();
    dirent.SetSystem();

    if (!dirent.SetLastWriteTime() || !dirent.SetCreationTime() ||
        !dirent.SetLastAccessTime()) {
        DELETE_ARRAY(orphan_track);
        return FALSE;
    }

    dirent.SetStartingCluster(found_cluster);

    if(_dirF32) {
        if (FixLevel != CheckOnly && !_dirF32->Write()) {
            DELETE_ARRAY(orphan_track);
            return FALSE;
        }
    }


    if (!dirent.Initialize(found_dir.GetDirEntry(0),FatType)) {
        DELETE_ARRAY(orphan_track);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    dirent.Clear();

    if (!tmp_string.Initialize(".")) {
        DELETE_ARRAY(orphan_track);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (!dirent.SetName(&tmp_string)) {
        DELETE_ARRAY(orphan_track);
        return FALSE;
    }

    dirent.SetDirectory();

    if (!dirent.SetLastWriteTime() || !dirent.SetCreationTime() ||
        !dirent.SetLastAccessTime()) {
        DELETE_ARRAY(orphan_track);
        return FALSE;
    }

    dirent.SetStartingCluster(found_cluster);

    if (!dirent.Initialize(found_dir.GetDirEntry(1),FatType)) {
        DELETE_ARRAY(orphan_track);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    dirent.Clear();

    if (!tmp_string.Initialize("..")) {
        DELETE_ARRAY(orphan_track);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (!dirent.SetName(&tmp_string)) {
        DELETE_ARRAY(orphan_track);
        return FALSE;
    }

    dirent.SetDirectory();

    if (!dirent.SetLastWriteTime() || !dirent.SetCreationTime() ||
        !dirent.SetLastAccessTime()) {
        DELETE_ARRAY(orphan_track);
        return FALSE;
    }

    dirent.SetStartingCluster(0);


    // OK, now let's recover those orphans.

    orphan_rec_clus_cnt = orphan_count = 0;
    for (i = FirstDiskCluster; _fat->IsInRange(i); i++) {
        if (orphan_track[i] != 1) {
            continue;
        }
        if (orphan_count == maximum_orphans) {
            Message->Set(MSG_TOO_MANY_ORPHANS);
            Message->Display();
            Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
            break;
        }

        if (!dirent.Initialize(found_dir.GetFreeDirEntry(), FatType)) {
            if (_fat->ReAllocChain(found_cluster, ++found_length)
                    != found_length)  {
                Message->Set(MSG_ORPHAN_DISK_SPACE);
                Message->Display();
                tmp_big_int = cluster_size;
                tmp_big_int = tmp_big_int * num_orphan_clusters;
                if (KSize) {
                    tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
                    message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
                } else {
                    tmp_ulong = tmp_big_int.GetLowPart();
                    message_id = MSG_WOULD_BE_RECOVERED_FILES;
                }
                Message->Set(message_id);
                Message->Display("%d%d", tmp_ulong,
                                         num_orphans);
                Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                break;
            }

//XXX.mjb: FATDB: need to get sectors for found_cluster + realloc.

            changes = FALSE;
            if (FixLevel != CheckOnly &&
                !RecoverChain(&found_cluster, &changes, 0, TRUE)) {

                Message->Set(MSG_ORPHAN_DISK_SPACE);
                Message->Display();
                tmp_big_int = cluster_size;
                tmp_big_int = tmp_big_int * num_orphan_clusters;
                if (KSize) {
                    tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
                    message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
                } else {
                    tmp_ulong = tmp_big_int.GetLowPart();
                    message_id = MSG_WOULD_BE_RECOVERED_FILES;
                }
                Message->Set(message_id);
                Message->Display("%d%d", tmp_ulong,
                                         num_orphans);
                Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                DELETE_ARRAY(orphan_track);
                return TRUE;
            }

            if (FixLevel != CheckOnly && !found_dir.Write()) {
                DELETE_ARRAY(orphan_track);
                return FALSE;
            }

            if (!hmem.Initialize() ||
                !found_dir.Initialize(&hmem, _drive, this, _fat,
                                      found_cluster) ||
                !found_dir.Read()) {
                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                Message->Set(MSG_WOULD_BE_RECOVERED_FILES);
                Message->Display("%d%d", cluster_size*num_orphan_clusters,
                                         num_orphans);
                Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                DELETE_ARRAY(orphan_track);
                return TRUE;
            }

            if (!dirent.Initialize(found_dir.GetDirEntry(2 + orphan_count), FatType)) {
                DELETE_ARRAY(orphan_track);
                return FALSE;
            }

            dirent.SetEndOfDirectory();

            if (!dirent.Initialize(found_dir.GetFreeDirEntry(),FatType)) {
                DELETE_ARRAY(orphan_track);
                return FALSE;
            }
        }

        sprintf(filename, "FILE%04d.CHK", orphan_count);

        if (!tmp_string.Initialize(filename)) {
            DELETE_ARRAY(orphan_track);
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        dirent.Clear();

        if (!dirent.SetName(&tmp_string)) {
            DELETE_ARRAY(orphan_track);
            return FALSE;
        }

        if (!dirent.SetLastWriteTime() || !dirent.SetCreationTime() ||
            !dirent.SetLastAccessTime()) {
            DELETE_ARRAY(orphan_track);
            return FALSE;
        }

        dirent.SetStartingCluster(i);
        dirent.SetFileSize(cluster_size*_fat->QueryLengthOfChain(i));

        orphan_count++;
        orphan_rec_clus_cnt += _fat->QueryLengthOfChain(i);
    }

    // Set all dirents past the orphan count to end of directory.

    for (i = 2 + orphan_count; dirent.Initialize(found_dir.GetDirEntry(i),FatType); i++)
    {
        dirent.SetEndOfDirectory();
    }

    if (FixLevel != CheckOnly && !found_dir.Write()) {
        DELETE_ARRAY(orphan_track);
        return FALSE;
    }

    if(FixLevel == CheckOnly) {
        if (KSize) {
            message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
        } else {
            message_id = MSG_WOULD_BE_RECOVERED_FILES;
        }
    } else {
        if (KSize) {
            message_id = MSG_KILOBYTES_IN_RECOVERED_FILES;
        } else {
            message_id = MSG_RECOVERED_FILES;
        }

        // Add the recovered data to the report totals

        Report->FileClusters += orphan_rec_clus_cnt;
        Report->FileEntriesCount += orphan_count;
        Report->DirClusters += found_length;
        Report->DirEntriesCount++;
    }
    tmp_big_int = cluster_size;
    tmp_big_int = tmp_big_int * num_orphan_clusters;
    if (KSize) {
        tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
    } else {
        tmp_ulong = tmp_big_int.GetLowPart();
    }
    Message->Set(message_id);

    Message->Display("%d%d", tmp_ulong,
                             num_orphans);

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    DELETE_ARRAY(orphan_track);
    return TRUE;
}


BOOLEAN
FAT_SA::AllocSectorsForChain(
    ULONG ChainHead
    )
/*++

Routine Description:

    When VerifyAndFix needs to allocate a cluster chain in order
    to create a new directory (such as \FOUND.000), it also needs to
    allocate space in the sector heap for data blocks for those
    clusters.  This routine does that.

Arguments:

    ChainHead - a cluster chain; data blocks are allocated for each
                cluster in this chain.

Return Value:

    TRUE  -   Success.
    FALSE -   Failure - not enough disk space

--*/
{
    ULONG   clus;
    ULONG   next;

    clus = ChainHead;
    for (;;) {
        if (!AllocateClusterData(clus,
                                 (UCHAR)QuerySectorsPerCluster(),
                                 FALSE,
                                 (UCHAR)QuerySectorsPerCluster())) {
            break;
        }

        if (_fat->IsEndOfChain(clus)) {
            return TRUE;
        }

        clus = _fat->QueryEntry(clus);
    }

    // Error: not enough disk space. XXX.mjb

    // Free the sectors we already allocated

    while (ChainHead != clus) {
        FreeClusterData(ChainHead);
        next = _fat->QueryEntry(ChainHead);
        _fat->SetClusterFree(ChainHead);
        ChainHead = next;
    }

    return FALSE;
}

#if defined( _SETUP_LOADER_ )

BOOLEAN
FAT_SA::RecoverFreeSpace(
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message
    )
{
    return TRUE;
}

#else // _SETUP_LOADER_ not defined

BOOLEAN
FAT_SA::RecoverFreeSpace(
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message
    )
/*++

Routine Description:

    This routine checks all of the space marked free in the FAT for
    bad clusters.  If any clusters are bad they are marked bad in the
    FAT.

Arguments:

    Report    - Supplies the fat chkdsk report structures for storing the
                actions performed by this method.
    Message   - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       clus, length, max_length;
    ULONG       start_sector, num_sectors, i;
    NUMBER_SET  bad_sectors;
    LBN         lbn;
    ULONG       percent_complete;
    ULONG       num_checked, total_to_check;
    ULONG       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    Message->Set(MSG_CHK_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE);
    Message->Display();

    _pvfMessage = Message;
    percent_complete = 0;
    if(!DisplayTwnkPercent(percent_complete)) {
        _pvfMessage = NULL;
        return FALSE;
    }

    num_checked = 0;
    total_to_check = _fat->QueryFreeClusters();
    max_length = QueryClusterCount()/20 + 1;
    for (clus = FirstDiskCluster; _fat->IsInRange(clus); clus++) {

        for (length = 0; _fat->IsInRange(clus + length) &&
                         _fat->IsClusterFree(clus + length) &&
                         length < max_length; length++) {
        }

        if (length) {

            start_sector = QueryStartDataLbn() +
                           (clus - FirstDiskCluster)*QuerySectorsPerCluster();
            num_sectors = length*QuerySectorsPerCluster();

            if (!bad_sectors.Initialize() ||
                !_drive->Verify(start_sector, num_sectors, &bad_sectors)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                _pvfMessage = NULL;
                return FALSE;
            }

            if (bad_sectors.QueryCardinality() != 0)
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            for (i = 0; i < bad_sectors.QueryCardinality(); i++) {
                lbn = bad_sectors.QueryNumber(i).GetLowPart();
                _fat->SetClusterBad(((lbn - QueryStartDataLbn())/
                                    QuerySectorsPerCluster()) +
                                    FirstDiskCluster );
            }

            clus += length - 1;
            num_checked += length;

            if (100*num_checked/total_to_check > percent_complete) {
                percent_complete = 100*num_checked/total_to_check;
            }
            if (!DisplayTwnkPercent(percent_complete)) {
                _pvfMessage = NULL;
                return FALSE;
            }
        }
    }

    percent_complete = 100;
    if(!DisplayTwnkPercent(percent_complete)) {
        _pvfMessage = NULL;
        return FALSE;
    }

    if (errFixedStatus == CHKDSK_EXIT_ERRS_FIXED) {
        Message->Set(MSG_CHK_BAD_SECTORS_FOUND);
        Message->Display();
    }

    Message->Set(MSG_CHK_DONE_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE);
    Message->Display();

    _pvfMessage = NULL;

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return TRUE;
}

#endif // _SETUP_LOADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\fatdir.cxx ===
#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "error.hxx"
#include "wstring.hxx"


DEFINE_CONSTRUCTOR( FATDIR, OBJECT );

UFAT_EXPORT
PVOID
FATDIR::SearchForDirEntry(
    IN  PCWSTRING   FileName
    )
/*++

Routine Description:

    This routine gets the directory entry with the (null-terminated)
    filename 'FileName'.  If no such directory entry exists then
    this routine return NULL.

Arguments:

    FileName    - The name of the file searched for.

Return Value:

    A pointer to a directory entry or NULL.

--*/
{
    FAT_DIRENT  dirent;
    ULONG       i;
    DSTRING     filename;
    PVOID       p;

    for (i = 0; dirent.Initialize(p = GetDirEntry(i)); i++) {

        if (dirent.IsEndOfDirectory()) {
            break;
        }

        if (dirent.IsErased()) {
            continue;
        }

        dirent.QueryName(&filename);

        if (dirent.IsVolumeLabel()) {
            continue;
        }

        if (*FileName == filename) {
            return p;
        }

        if (QueryLongName(i, &filename) && (*FileName == filename)) {
            return p;
        }
    }

    return NULL;
}


PVOID
FATDIR::GetFreeDirEntry(
    )
/*++

Routine Description:

    This routine gets an unused directory entry, if one exists.
    If one doesn't exist then this routine returns NULL.

Arguments:

    None.

Return Value:

    A pointer to a directory entry or NULL.

--*/
{
    FAT_DIRENT  dirent;
    ULONG       i;
    PVOID       p;

    for (i = 0; dirent.Initialize(p = GetDirEntry(i)); i++) {

        if (dirent.IsEndOfDirectory()) {
            if (dirent.Initialize(GetDirEntry(i + 1))) {
                dirent.SetEndOfDirectory();
            }
            return p;
        }

        if (dirent.IsErased()) {
            return p;
        }
    }

    return NULL;
}

extern VOID DoInsufMemory(VOID);

UFAT_EXPORT
BOOLEAN
FATDIR::QueryLongName(
    IN  LONG        EntryNumber,
    OUT PWSTRING    LongName
    )
/*++

Routine Description:

    This method fetches the long file name associated with the
    short directory entry at index EntryNumber.

Arguments:

    EntryNumber
    LongName        --  Receives the long name associated with this entry.
                        Receives "" if there is no long name.

Return Value:

    TRUE upon successful completion
    FALSE to indicate failure or disk corruption.

--*/
{
    DSTRING     NameComponent;
    FAT_DIRENT  CurrentEntry;
    LONG        CurrentIndex;
    ULONG       Ordinal = 1;
    UCHAR       Checksum;

    CurrentIndex = EntryNumber;

    if( !CurrentEntry.Initialize( GetDirEntry( CurrentIndex ) ) ||
        !LongName->Initialize( "" ) ) {
	DoInsufMemory();
        return FALSE;
    }

    Checksum = CurrentEntry.QueryChecksum();

    CurrentIndex--;

    for( ; CurrentIndex >= 0; CurrentIndex-- ) {

        if( !CurrentEntry.Initialize( GetDirEntry( CurrentIndex ) ) ) {

	    DoInsufMemory();
            return FALSE;
        }

        if( CurrentEntry.IsErased() ||  !CurrentEntry.IsLongEntry() ) {

            // The long name entries are not valid--return an
            // empty string for the long name.
            //
            return( LongName->Initialize( "" ) );
        }

        if( CurrentEntry.IsLongNameEntry() ) {

            if( CurrentEntry.QueryLongOrdinal() != Ordinal ||
                CurrentEntry.QueryChecksum() != Checksum ) {

                // The long-name entries don't belong to the
                // specified short entry.
                //
                return( LongName->Initialize( "" ) );
            }

            if( !CurrentEntry.QueryLongNameComponent( &NameComponent ) ||
                !LongName->Strcat( &NameComponent ) ) {

                return FALSE;
            }

            if( CurrentEntry.IsLastLongEntry() ) {

                // This was the last entry.
                //
                return TRUE;
            }

            Ordinal++;
        }
    }

    // There is no long name, or it is not valid.
    //
    return( LongName->Initialize( "" ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\fatsa.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    fatsa.cxx

Author:

    Mark Shavlik (marks) 27-Mar-90
    Norbert Kusters (norbertk) 15-Jan-91

Environment:

        ULIB, User Mode

--*/

#include "pch.cxx"

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "cmem.hxx"
#include "rtmsg.h"
#include "drive.hxx"
#include "bootfat.h"
#include "bootf32.h"
#include "boot98f.h"
#include "boot98f2.h"
extern "C" {
#include <parttype.h>
}
#if !defined(_AUTOCHECK_) && !defined(_SETUP_LOADER_)
#include "timeinfo.hxx"
#endif


// Control-C handling is not necessary for autocheck.
#if !defined( _AUTOCHECK_ ) && !defined(_SETUP_LOADER_)

#include "keyboard.hxx"

#endif

#define CSEC_FAT32MEG                   65536
#define CSEC_FAT16BIT                   32680
#define CSEC_FAT32BIT                  (1024*1024)


#define MIN_CLUS_BIG    4085    // Minimum clusters for a big FAT.
#define MAX_CLUS_BIG    65525   // Maximum + 1 clusters for big FAT.

#define MIN_CLUS_FAT32  65536




DEFINE_EXPORTED_CONSTRUCTOR( FAT_SA, SUPERAREA, UFAT_EXPORT );

VOID
FAT_SA::Construct (
        )
/*++

Routine Description:

    Constructor for FAT_SA.

Arguments:

    None.

Return Value:

        None.

--*/
{
    _fat = NULL;
    _dir = NULL;
    _dirF32 = NULL;
    _hmem_F32 = NULL;

}


UFAT_EXPORT
FAT_SA::~FAT_SA(
    )
/*++

Routine Description:

    Destructor for FAT_SA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

BOOLEAN
FAT_SA::RecoverFile(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine runs through the clusters for the file described by
    'FileName' and takes out bad sectors.

Arguments:

    FullPathFileName    - Supplies a full path name of the file to recover.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if defined( _SETUP_LOADER_ )

    return FALSE;

#else // _SETUP_LOADER_


    HMEM        hmem;
    ULONG       clus;
    BOOLEAN     changes;
    PFATDIR     fatdir;
    BOOLEAN     need_delete;
    FAT_DIRENT  dirent;
    ULONG       old_file_size;
    ULONG       new_file_size;

    if ((clus = QueryFileStartingCluster(FullPathFileName,
                                         &hmem,
                                         &fatdir,
                                         &need_delete,
                                         &dirent)) == 1) {
        Message->Set(MSG_FILE_NOT_FOUND);
        Message->Display("%W", FullPathFileName);
        return FALSE;
    }

    if (clus == 0xFFFFFFFF) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    if (clus == 0) {
        Message->Set(MSG_FILE_NOT_FOUND);
        Message->Display("%W", FullPathFileName);
        return FALSE;
    }

    if (dirent.IsDirectory()) {
        old_file_size = _drive->QuerySectorSize()*
                        QuerySectorsPerCluster()*
                        _fat->QueryLengthOfChain(clus);
    } else {
        old_file_size = dirent.QueryFileSize();
    }

    if (!RecoverChain(&clus, &changes)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    if (dirent.IsDirectory() || changes) {
        new_file_size = _drive->QuerySectorSize()*
                        QuerySectorsPerCluster()*
                        _fat->QueryLengthOfChain(clus);
    } else {
        new_file_size = old_file_size;
    }

    if (changes) {


// Autochk doesn't need control C handling.
#if !defined( _AUTOCHECK_ )

        // Disable contol-C handling and

        if (!KEYBOARD::EnableBreakHandling()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            return FALSE;
        }

#endif


        // Lock the drive in preparation for writes.

        if (!_drive->Lock()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            return FALSE;
        }

        dirent.SetStartingCluster(clus);

        dirent.SetFileSize(new_file_size);

        if (!fatdir->Write()) {
            return FALSE;
        }

        if (!Write(Message)) {
            return FALSE;
        }


// Autochk doesn't need control C handling.
#if !defined( _AUTOCHECK_ )

        KEYBOARD::DisableBreakHandling();

#endif


    }

    Message->Set(MSG_RECOV_BYTES_RECOVERED);
    Message->Display("%d%d", new_file_size, old_file_size);


    if (need_delete) {
        DELETE(fatdir);
    }

    return TRUE;

#endif // _SETUP_LOADER_
}


SECTORCOUNT
FAT_SA::QueryFreeSectors(
    ) CONST
/*++

Routine Description:

    This routine computes the number of unused sectors on disk.

Arguments:

    None.

Return Value:

    The number of free sectors on disk.

--*/
{
    if (!_fat) {
        DebugPrintTrace(("UFAT: Failure to QueryFreeSectors in FAT_SA\n"));
        return 0;
    }

    return _fat->QueryFreeClusters()*QuerySectorsPerCluster();
}


FATTYPE
FAT_SA::QueryFatType(
    ) CONST
/*++

Routine Description:

    This routine computes the FATTYPE of the FAT for this volume.

Arguments:

    None.

Return Value:

    The FATTYPE for the FAT.

--*/
{
    return _ft;
}



#if !defined( _AUTOCHECK_ ) && !defined(_SETUP_LOADER_)

BOOLEAN
FAT_SA::QueryLabel(
    OUT PWSTRING    Label
    ) CONST
/*++

Routine Description:

    This routine queries the label from the FAT superarea.
    If the label is not present then 'Label' will return the null-string.
    If the label is invalid then FALSE will be returned.

Arguments:

    Label   - Returns a volume label.

Return Value:

    FALSE   - The label is invalid.
    TRUE    - The label is valid.

--*/
{
    return QueryLabel(Label, NULL);
}


BOOLEAN
FAT_SA::QueryLabel(
    OUT PWSTRING    Label,
    OUT PTIMEINFO   TimeInfo
    ) CONST
/*++

Routine Description:

    This routine queries the label from the FAT superarea.
    If the label is not present then 'Label' will return the null-string.
    If the label is invalid then FALSE will be returned.

Arguments:

    Label   - Returns a volume label.

Return Value:

    FALSE   - The label is invalid.
    TRUE    - The label is valid.

--*/
{
    INT         i;
    FAT_DIRENT  dirent;
    FILETIME    TimeStamp;
    PFATDIR     _fat_dir;
    UCHAR       FatType;

    if (!_dirF32) {

        DebugAssert(_dir);
        _fat_dir = _dir;
        FatType = FAT_TYPE_EAS_OKAY;

    } else {

        _fat_dir = _dirF32;
        FatType = FAT_TYPE_FAT32;
    }

    for (i = 0; ; i++) {
        if (!dirent.Initialize(_fat_dir->GetDirEntry(i), FatType) ||
            dirent.IsEndOfDirectory()) {
            return Label->Initialize("");
        }

        if (!dirent.IsErased() && dirent.IsVolumeLabel()) {
            break;
        }
    }

    dirent.QueryName(Label);

    if ( TimeInfo ) {
        return ( dirent.QueryLastWriteTime( (LARGE_INTEGER *)&TimeStamp ) &&
                 TimeInfo->Initialize( &TimeStamp ) );
    }

    return TRUE;
}

#else // _AUTOCHECK_ or _SETUP_LOADER_ is defined

BOOLEAN
FAT_SA::QueryLabel(
    OUT PWSTRING    Label
    ) CONST
{
    INT         i;
    FAT_DIRENT  dirent;

    PFATDIR     _fat_dir;

    if (!_dirF32) {

        DebugAssert(_dir);
        _fat_dir = _dir;

    } else {

        _fat_dir = _dirF32;
    }

    for (i = 0; ; i++) {
        if (!dirent.Initialize(_fat_dir->GetDirEntry(i)) ||
            dirent.IsEndOfDirectory()) {
            return Label->Initialize("");
        }

        if (!dirent.IsErased() && dirent.IsVolumeLabel()) {
            break;
        }
    }

    dirent.QueryName(Label);

    return TRUE;
}


#endif // _AUTOCHECK_


BOOLEAN
FAT_SA::SetLabel(
    IN  PCWSTRING   NewLabel
    )
/*++

Routine Description:

    This routine sets the label for a FAT partition.

Arguments:

    NewLabel    - Supplies the new volume label.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FAT_DIRENT  dirent;
    INT         i;
    DSTRING     label;
    PFATDIR     _fat_dir;
    UCHAR       FatType;

    if (!_dir) {

        if (!_dirF32) {
            return FALSE;
        }

        _fat_dir = _dirF32;
        FatType = FAT_TYPE_FAT32;

    } else {
        _fat_dir = _dir;
        FatType = FAT_TYPE_EAS_OKAY;
    }

    if (!label.Initialize(NewLabel)) {
        return FALSE;
    }

    if (!label.Strupr()) {
        return FALSE;
    }

    if (!IsValidString(&label)) {
        return FALSE;
    }

    for (i = 0; dirent.Initialize(_fat_dir->GetDirEntry(i), FatType); i++) {

        if (dirent.IsEndOfDirectory()) {
            break;
        }

        if (dirent.IsErased()) {
            continue;
        }

        if (dirent.IsVolumeLabel()) {
            if (!label.QueryChCount()) {
                dirent.SetErased();
                return TRUE;
            }

            return (BOOLEAN) (dirent.SetLastWriteTime() &&
                              dirent.SetName(&label));
        }
    }

    if (!label.QueryChCount()) {
        return TRUE;
    }

    if (!dirent.Initialize(_fat_dir->GetFreeDirEntry(), FatType)) {
        return FALSE;
    }

    dirent.Clear();
    dirent.SetVolumeLabel();

    return (BOOLEAN) (dirent.SetLastWriteTime() && dirent.SetName(&label));
}


UFAT_EXPORT
ULONG
FAT_SA::QueryFileStartingCluster(
    IN  PCWSTRING   FullPathFileName,
    OUT PHMEM       Hmem,
    OUT PPFATDIR    Directory,
    OUT PBOOLEAN    DeleteDirectory,
    OUT PFAT_DIRENT DirEntry
    )
/*++

Routine Description:

    This routine computes the starting cluster number of the file described
    by 'FileName' by tracing through the directories leading to the file.

Arguments:

    FullPathFileName    - Supplies a full path file name that starts with
                            a '\' (i.e. no drive spec).

Return Value:

    The starting cluster for the file or 1 if the file is not found or
    0xFFFFFFFF if there was an error.

--*/
{
    CHNUM       i, j, l;
    DSTRING     component;
    ULONG       clus;
    FAT_DIRENT  the_dirent;
    PFILEDIR    filedir;
    PFAT_DIRENT dirent;
    HMEM        hmem;
    PFATDIR        _fat_dir;
    UCHAR        FatType;

    DebugAssert(_dir || _dirF32);

    if (_dir) {

        _fat_dir = _dir;
        FatType = FAT_TYPE_EAS_OKAY;

    } else {

        _fat_dir = _dirF32;
        FatType = FAT_TYPE_FAT32;
    }

    DebugAssert(_fat);

    filedir = NULL;

    if (!Hmem) {
        Hmem = &hmem;
    }

    if (DirEntry) {
        dirent = DirEntry;
    } else {
        dirent = &the_dirent;
    }

    l = FullPathFileName->QueryChCount();

    for (i = 0; i < l && FullPathFileName->QueryChAt(i) != '\\'; i++) {

        /* NOTHING */
    }

    if (i == l) {
        return 0xFFFFFFFF;
    }

    if (i == l - 1) { // root directory
        return 0;
    }

    j = ++i;
    for (; i < l && FullPathFileName->QueryChAt(i) != '\\'; i++) {
        /* NOTHING */
    }

    if (!component.Initialize(FullPathFileName, j, i - j) ||
        !component.Strupr()) {
        return 1;
    }

    if (!dirent->Initialize(_fat_dir->SearchForDirEntry(&component), FatType)) {
        return 1;
    }

    if (!(clus = dirent->QueryStartingCluster())) {
        return 0;
    }

    while (i < l) {

        if (!filedir &&
            !(filedir = NEW FILEDIR)) {
            return 0xFFFFFFFF;
        }

        if (!Hmem->Initialize() ||
            !filedir->Initialize(Hmem, _drive, this, _fat, clus)) {
            return 0xFFFFFFFF;
        }

        if (!filedir->Read()) {
            return 1;
        }

        j = ++i;
        for (; i < l && FullPathFileName->QueryChAt(i) != '\\'; i++) {
        }

        if (!component.Initialize(FullPathFileName, j, i - j) ||
            !component.Strupr()) {
            return 0xFFFFFFFF;
        }

        if (!dirent->Initialize(filedir->SearchForDirEntry(&component), FatType))
        {
            return 1;
        }

        if (!(clus = dirent->QueryStartingCluster())) {
            return 1;
        }
    }

    if (Directory) {
        if (filedir) {
            *Directory = filedir;
            if (DeleteDirectory) {
                *DeleteDirectory = TRUE;
            }
        } else {
            *Directory = _dir;
            if (DeleteDirectory) {
                *DeleteDirectory = FALSE;
            }
        }
    } else {
        DELETE(filedir);
    }

    return clus;
}


VOID
FAT_SA::Destroy(
    )
/*++

Routine Description:

    This routine cleans up the local data in the fat super area.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE(_fat);
    DELETE(_dir);
    DELETE(_dirF32);

}


FATTYPE
FAT_SA::ComputeFatType(
    ) CONST
/*++

Routine Description:

    Given the total number of clusters on the disk, this routine computes
    whether the FAT entries will be 12, 16, or 32 bits each.

Arguments:

    ClusterCount    - Supplies the number of clusters on the disk.

Return Value:

    SMALL   - A 12 bit FAT is required.
    LARGE16 - A 16 bit FAT is required.
    LARGE32 - A 32 bit FAT is required.
    
Note:

    THIS ROUTINE MAY NOT WORK IF PARTITION ID IS OEM TO START WITH.

--*/
{
    PARTITION_SYSTEM_ID id;

    id = ComputeSystemId();

    if (id == SYSID_FAT12BIT) {
        return(SMALL);
    } else if (id == SYSID_FAT32BIT) {
        return(LARGE32);
    } else {
        return(LARGE16);
    }
}


PARTITION_SYSTEM_ID
FAT_SA::ComputeSystemId(
    ) CONST
/*++

Routine Description:

    This routine computes the system id for a FAT file system with
    the given number of sectors.

Arguments:

    None.

Return Value:

    The correct system id for this partition.

--*/
{
    SECTORCOUNT           disk_size;
    PARTITION_SYSTEM_ID   partition_id;  // The partition id to be returned.
    GenPartitionClass     partition_class;
    NTSTATUS              status;        // Return status of RegeneratePartitionType.
    ULONG                 DoXInt13;

    switch (_drive->QueryMediaType()) {

        case F3_720_512:
        case F5_360_512:
        case F5_320_512:
        case F5_320_1024:
        case F5_180_512:
        case F5_160_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_720_512:
        case F5_640_512:
        case F3_640_512:
        case F3_1Pt2_512:
        case F8_256_128:
        case F5_1Pt23_1024:
        case F3_1Pt23_1024:
#endif
        case F5_1Pt2_512:
        case F3_1Pt44_512:
        case F3_2Pt88_512:
        case F3_20Pt8_512:
            return SYSID_FAT12BIT;

        case F3_120M_512:
        case F3_200Mb_512:
        case F3_240M_512:
            return SYSID_FAT16BIT;
    }

    disk_size = QueryVirtualSectors();

    if (_ft == INVALID_FATTYPE ) {

        //
        // If the _ft member is not initialized,
        // use the sector count to determine the
        // partition class. Note that this method of
        // determining the partition class is not absolutely
        // fool-proof but this method works at least as good
        // as what we have in the past. The proper way of doing
        // the system id computation is to make sure that
        // the fat type is always computed before the
        // partition id and always uses the fat type and,
        // in some cases, the sector count to determine the
        // partition id.
        //
        if (disk_size < CSEC_FAT32BIT) {
            partition_class = GenPartitionClassFat12Or16;
        } else {
            partition_class = GenPartitionClassFat32;
        }

    } else {

        if (_ft == LARGE32 ) {
            partition_class = GenPartitionClassFat32;
        } else {
            partition_class = GenPartitionClassFat12Or16;
        }
    }

    if (_drive->IsSuperFloppy()) {
        return PARTITION_FAT_16;    // just return something other than SYSID_NONE
    }

    if (_drive->IsSonyMS()) {
        //
        // Override RegeneratePartitionType for memory stick as it will use
        // PARTITION_FAT_16 for FAT12 cases when sector counts >= 32680
        //
        if (_drive->QuerySectors() < SMS_VOLSIZE_SMALL/_drive->QuerySectorSize()) {
            return PARTITION_FAT_12;
        } else {
            return PARTITION_HUGE;
        }
    }

    switch (_drive->QueryPartitionType()) {
      case 0x12:
      case 0xDE:
      case 0xFE:
        // preserve OEM partition id if formatting for FAT
        return _drive->QueryPartitionType();
    }

    if (_drive->IsPrimaryPartition()) {
        DoXInt13 = 0;
    } else {
        DoXInt13 = GENPARTTYPE_DISALLOW_XINT13;
    }

    status = RegeneratePartitionType( NULL,
                                      _drive->QueryDriveHandle(),
                                      partition_class,
                                      DoXInt13,
                                      0,
                                      &partition_id );

    if (!NT_SUCCESS(status)) {
        // Shouldn't fail
        DebugPrintTrace(("RegeneratePartitionType returned the error code 0x%x.\n", status));
    }

    return partition_id;
}

#if !defined(_SETUP_LOADER_)

ULONG
FAT_SA::ComputeRootEntries(
    ) CONST
/*++

Routine Description:

    This routine uses the size of the disk and a standard table in
    order to compute the required number of root directory entries.

Arguments:

    None.

Return Value:

    The required number of root directory entries.

--*/
{
    switch (_drive->QueryMediaType()) {

        case F3_720_512:
        case F5_360_512:
        case F5_320_512:
        case F5_320_1024:
        case F5_180_512:
        case F5_160_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_720_512:
        case F5_640_512:
        case F3_640_512:
#endif
            return 112;

        case F5_1Pt2_512:
        case F3_1Pt44_512:
#if defined(FE_SB) && defined(_X86_)
        case F3_1Pt2_512:
#endif
            return 224;

        case F3_2Pt88_512:
        case F3_20Pt8_512:
            return 240;

#if defined(FE_SB) && defined(_X86_)
        case F5_1Pt23_1024:
        case F3_1Pt23_1024:
             return 192;

        case F8_256_128:
            return 68;

        case RemovableMedia:
            return 512;
#endif
    }

    return 512;
}


USHORT
FAT_SA::ComputeSecClus(
    IN  SECTORCOUNT Sectors,
    IN  FATTYPE     FatType,
#if defined(FE_SB) && defined(_X86_)
    IN  MEDIA_TYPE  MediaType,
    IN  ULONG       SectorSize
#else
    IN  MEDIA_TYPE  MediaType
#endif
    )
/*++

Routine Description:

    This routine computes the number of sectors per cluster required
    based on the actual number of sectors.

Arguments:

    Sectors     - Supplies the total number of sectors on the disk.
    FatType     - Supplies the type of FAT.
    MediaType   - Supplies the type of the media.

Return Value:

    The required number of sectors per cluster.

--*/
{
    USHORT      sec_per_clus;
    SECTORCOUNT threshold;


    if (FatType == LARGE32) {

        if (Sectors >= 64*1024*1024) {
            sec_per_clus = 64;                  /* over 32GB -> 32K */
        } else if (Sectors >= 32*1024*1024) {
            sec_per_clus = 32;                  /* up to 32GB -> 16K */
        } else if (Sectors >= 16*1024*1024) {
            sec_per_clus = 16;                  /* up to 16GB -> 8K */
        } else {
            sec_per_clus = 8;                   /* up to 8GB -> 4K */
        }

        return sec_per_clus;
    }

    if (FatType == SMALL) {
        threshold = MIN_CLUS_BIG;
        sec_per_clus = 1;
    } else {
        threshold = MAX_CLUS_BIG;
        sec_per_clus = 1;
    }

    while (Sectors >= threshold) {
        sec_per_clus *= 2;
        threshold *= 2;
    }

    switch (MediaType) {

        case F5_320_512:
        case F5_360_512:
        case F3_720_512:
        case F3_2Pt88_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_640_512:
        case F3_640_512:
        case F5_720_512:
#endif
            sec_per_clus = 2;
            break;

        case F3_20Pt8_512:
#if defined(FE_SB)
        case F3_128Mb_512:
#if defined(_X86_)
        case F8_256_128:
#endif
#endif
            sec_per_clus = 4;
            break;

#if defined(FE_SB)
        case F3_230Mb_512:
            sec_per_clus = 8;
            break;
#endif

        default:
            break;

    }

    return sec_per_clus;
}

#endif // _SETUP_LOADER_


BOOLEAN
FAT_SA::IsValidString(
    IN  PCWSTRING    String
    )
/*++

Routine Description:

    This routine determines whether or not the given null-terminated string
    has any invalid characters in it.

Arguments:

    String  - Supplies the string to validate.

Return Value:

    FALSE   - The string contains invalid characters.
    TRUE    - The string is free from invalid characters.

Notes:

    The list of invalid characters is stricter than HPFS requires.

--*/
{
    CHNUM   i, l;

    l = String->QueryChCount();

    for (i = 0; i < l; i++) {
        if (String->QueryChAt(i) < 32) {
            return FALSE;
        }

        switch (String->QueryChAt(i)) {
            case '*':
            case '?':
                case '/':
            case '\\':
                case '|':
                case ',':
                case ';':
                case ':':
                case '+':
                case '=':
            case '<':
            case '>':
                case '[':
                case ']':
            case '"':
            case '.':
                return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\filedir.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    filedir.cxx

Abstract:

    This class is an implementation of FATDIR for all FAT directories
    that are implemented as files.  In other words all FAT directories
    besides the root directory.

Author:

    Norbert P. Kusters (norbertk) 4-Dec-90

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( FILEDIR, FATDIR, UFAT_EXPORT );

VOID
FILEDIR::Construct (
    )
/*++

Routine Description:

    Constructor for FILEDIR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _number_of_entries = 0;
}


UFAT_EXPORT
FILEDIR::~FILEDIR(
    )
/*++

Routine Description:

    Destructor for FILEDIR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

extern VOID DoInsufMemory(VOID);

UFAT_EXPORT
BOOLEAN
FILEDIR::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PFAT_SA             FatSuperArea,
    IN      PCFAT               Fat,
    IN      ULONG               StartingCluster
    )
/*++

Routine Description:

    This routine initializes the FILEDIR object for use.  It will enable
    referencing the directory starting at StartingCluster.

Arguments:

    Mem             - Supplies the memory for the cluster chain.
    Drive           - Supplies the drive on which the directory resides.
    FatSuperArea    - Supplies the super area for the FAT file system on
                        the drive.
    Fat             - Supplies the file allocation table for the drive.
    StartingCluster - Supplies the first cluster of the directory.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _starting_cluster = StartingCluster;

    if (!_cluster.Initialize(Mem, Drive, FatSuperArea, Fat, StartingCluster)) {
        DoInsufMemory();
        Destroy();
        return FALSE;

    }

    _number_of_entries = Drive->QuerySectorSize()*
                         FatSuperArea->QuerySectorsPerCluster()*
                         _cluster.QueryLength()/
                         BytesPerDirent;

    if (!_number_of_entries) {

        DebugPrintTrace(("UFAT: Failure to Initialize in FILEDIR\n"));
        Destroy();
        return FALSE;
    }

    return TRUE;
}


VOID
FILEDIR::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state.  Memory will
    be freed and all other function besided Init will be inoperative.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _number_of_entries = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\hashindx.cxx ===
#include <pch.cxx>

#include "ulib.hxx"

#include "hashindx.hxx"

extern "C" {
#include <stdio.h>
}

//#define HASH_INDEX_PERFORMANCE    1

#if HASH_INDEX_PERFORMANCE
#include <math.h>
#endif

#define MAX_HASH_TABLE_SIZE     32768

DEFINE_CONSTRUCTOR( HASH_INDEX, OBJECT );

VOID
HASH_INDEX::Construct (
        )
/*++

Routine Description:

    Constructor for HASH_INDEX.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _hashTable = NULL;
    _hash_table_size = 0;
    _hash_table_mask = 0;
    _hash_table_bits = 0;
    _hash_element_increment = 0;
}


VOID
HASH_INDEX::Destroy(
    )
/*++

Routine Description:

    This routine returns the HASH_INDEX to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PHASH_INDEX_ELEMENT   hashElementPtr;
    USHORT                i;

    if (_hashTable == NULL)
        return;

    hashElementPtr = _hashTable;
    for (i=0; i<_hash_table_size; i++) {
        FREE(hashElementPtr->elements);
        hashElementPtr++;
    }
    FREE(_hashTable);

    _hash_table_size = 0;
    _hash_table_mask = 0;
    _hash_table_bits = 0;
    _hash_element_increment = 0;
}


HASH_INDEX::~HASH_INDEX(
    )
/*++

Routine Description:

    Destructor for HASH_INDEX.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


BOOLEAN
HASH_INDEX::Initialize(
    ULONG       HashTableSize,
    USHORT      HashElementIncrement
    )
/*++

Routine Description:

    This routine initializes the set for new input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    USHORT                i;
    USHORT                hash_table_size;

    Destroy();

    // compute hash table bit size

    if (HashTableSize <= 1024)
        _hash_table_bits = 10;
    else if (HashTableSize <= 2048)
        _hash_table_bits = 11;
    else if (HashTableSize <= 4096)
        _hash_table_bits = 12;
    else if (HashTableSize <= 8192)
        _hash_table_bits = 13;
    else if (HashTableSize <= 16384)
        _hash_table_bits = 14;
    else
        _hash_table_bits = 15;

    // set hash table size & mask

    _hash_table_size = (1 << _hash_table_bits);
    _hash_table_mask = _hash_table_size - 1;
    _hash_element_increment = HashElementIncrement;

    _hashTable = (PHASH_INDEX_ELEMENT)MALLOC(sizeof(HASH_INDEX_ELEMENT)*_hash_table_size);

    if (_hashTable == NULL)
        return FALSE;

    memset(_hashTable, 0, sizeof(HASH_INDEX_ELEMENT)*_hash_table_size);

    return TRUE;
}

BOOLEAN
HASH_INDEX::QueryAndAdd(
    IN  ULONG       HashValue,
    IN  ULONG       Index,
    OUT PULONG      *MatchIndexArray,
    OUT PULONG      MatchIndexCount
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.

Arguments:

    Number    - Supplies the number to add to the set.
    Duplicate - Returns TRUE if Number already exists in the set

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PHASH_INDEX_ELEMENT hashElementPtr;
    PULONG              tmpPtr;
    PULONG              elementPtr;
    ULONG               i;
    SHORT               bits_left;
    USHORT              hash_key;

    DebugPtrAssert(_hashTable);

    //
    // Compute hash key
    //

    bits_left = sizeof(ULONG)*8;
    hash_key = 0;
    do {
        hash_key ^= (HashValue & _hash_table_mask);
        HashValue = HashValue >> _hash_table_bits;
        bits_left -= _hash_table_bits;
    } while (bits_left > 0);

    hashElementPtr = &(_hashTable[hash_key]);

    //
    // Is this the first entry
    //

    if (hashElementPtr->elements == NULL) {

        hashElementPtr->elements = (PULONG)
                                   MALLOC(sizeof(ULONG)*_hash_element_increment);
        if (hashElementPtr->elements == NULL)
            return FALSE;
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = _hash_element_increment;
    }

    //
    // Is there room to add another entry
    //
    if (hashElementPtr->elementCount == hashElementPtr->maxElementCount) {
        tmpPtr = (PULONG)REALLOC(hashElementPtr->elements,
                                 sizeof(ULONG)*
                                 (_hash_element_increment +
                                  hashElementPtr->maxElementCount));
        if (tmpPtr == NULL)
            return FALSE;
        hashElementPtr->elements = tmpPtr;
        hashElementPtr->maxElementCount += _hash_element_increment;
    }

    //
    // Insert the element
    //
    hashElementPtr->elements[hashElementPtr->elementCount] = Index;
    hashElementPtr->elementCount += 1;
    DebugAssert(hashElementPtr->elementCount <= hashElementPtr->maxElementCount);

    *MatchIndexArray = hashElementPtr->elements;
    *MatchIndexCount = hashElementPtr->elementCount;

    return TRUE;
}

BOOLEAN
HASH_INDEX::RemoveAll(
     )
{
    PHASH_INDEX_ELEMENT     hashElementPtr;
    USHORT                  i;

    DebugPtrAssert(_hashTable);
    hashElementPtr = _hashTable;
    for (i=0; i<_hash_table_size; i++) {
        FREE(hashElementPtr->elements);
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = 0;
        hashElementPtr++;
    }
    return TRUE;
}

VOID
HASH_INDEX::RemoveLastEntry(
    ULONG   HashValue,
    ULONG   Index
    )
{
    PHASH_INDEX_ELEMENT hashElementPtr;
    SHORT               bits_left;
    USHORT              hash_key;
    ULONG               count;

    DebugPtrAssert(_hashTable);

    //
    // Compute hash key
    //

    bits_left = sizeof(ULONG)*8;
    hash_key = 0;
    do {
        hash_key ^= (HashValue & _hash_table_mask);
        HashValue = HashValue >> _hash_table_bits;
        bits_left -= _hash_table_bits;
    } while (bits_left > 0);

    hashElementPtr = &(_hashTable[hash_key]);

    count = hashElementPtr->elementCount;
    if (count-- >= 1) {
        DebugAssert(hashElementPtr->elements[count] == Index);
        hashElementPtr->elementCount = count;
    }
}

VOID
HASH_INDEX::DumpHashTable(
    )
/*++

Routine Description:

    This routine dumps out the hash table

--*/
{
#if HASH_INDEX_PERFORMANCE
    USHORT                  i;
    PHASH_INDEX_ELEMENT     hashElementPtr;
    ULONG                   slotused = 0, min_count = 100000, max_count = 0, elem_count = 0;
    double                  avg_count = 0, sd_count = 0, avg_slot = 0, sd_slot = 0;

    hashElementPtr = _hashTable;
    printf("\n");
    for (i=0; i<_hash_table_size; i++) {
        if (hashElementPtr->elements != NULL) {
            slotused++;
            avg_slot += i;
            sd_slot += i*i;
//            printf("%d, %d\n", i, hashElementPtr->elementCount);
            if (min_count > hashElementPtr->elementCount)
                min_count = hashElementPtr->elementCount;
            if (max_count < hashElementPtr->elementCount)
                max_count = hashElementPtr->elementCount;
            avg_count += hashElementPtr->elementCount;
            sd_count += (hashElementPtr->elementCount)*(hashElementPtr->elementCount);
        }
        hashElementPtr++;
    }
    printf("Slot (%d): %d, %g, %g\n",
           _hash_table_size, slotused, avg_slot/slotused, sqrt(sd_slot/(slotused-1)));
    printf("Element: %d, %d, %g, %g\n",
           min_count, max_count, avg_count/slotused, sqrt(sd_count/(slotused-1)));

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\fatvol.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    fatvol.cxx

Author:

    Bill McJohn (billmc) 30-May-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#include "message.hxx"
#include "rtmsg.h"
#include "wstring.hxx"


DEFINE_CONSTRUCTOR( FAT_VOL, VOL_LIODPDRV );

VOID
FAT_VOL::Construct (
    )

/*++

Routine Description:

    Constructor for FAT_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}


FAT_VOL::~FAT_VOL(
    )
/*++

Routine Description:

    Destructor for FAT_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


FORMAT_ERROR_CODE
FAT_VOL::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType,
    IN      USHORT      FormatType,
    IN      BOOLEAN     ForceDismount
    )
/*++

Routine Description:

    This routine initializes a FAT_VOL object.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                      opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.
    FormatType      - Supplies the file system type in the event of a format
    ForceDismount   - Supplies whether the volume should be dismounted
                        and locked.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE             msg;
    FORMAT_ERROR_CODE   errcode;

    Destroy();

    errcode = VOL_LIODPDRV::Initialize(NtDriveName, &_fatsa, Message,
                                       ExclusiveWrite, FormatMedia,
                                       MediaType, FormatType, ForceDismount);

    if (errcode != NoError) {
        Destroy();
        return errcode;
    }


    if (!Message) {
        Message = &msg;
    }


    if (!_fatsa.Initialize(this, Message, FALSE)) {
        Destroy();
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return GeneralError;
    }

    return NoError;
}

BOOLEAN
FAT_VOL::Initialize(
    IN OUT  PMESSAGE    Message,
    IN      PCWSTRING   NtDriveName,
    IN      BOOLEAN     OnlyIfDirty,
    IN      USHORT      FormatType
    )
/*++


Routine Description:

    This routine initializes a FAT_VOL object. If OnlyIfDirty is TRUE
    the SECRUN structure in the _fatsa object to only be
    big enough to perform the QueryVolumeFlags function,
    to see if the volume is dirty. This prevents AUTOCHK from setting up the whole
    super area (which is quite memory intensive on FAT32 drives) when it isn't going
    to do anything because the volume is clean.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    OnlyIfDirty     - TRUE if the volume is only going to be checked if dirty
    FormatType      - Supplies the file system type in the event of a format

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE             msg;
    FORMAT_ERROR_CODE   errcode;

    Destroy();

    errcode = VOL_LIODPDRV::Initialize(NtDriveName, &_fatsa, Message,
                                       FALSE,
                                       FALSE,   // will not return LockError
                                       Unknown,
                                       FormatType);

    if (errcode != NoError) {
        Destroy();
        return FALSE;
    }


    if (!Message) {
        Message = &msg;
    }

    // If we fix the QueryVolumeFlags to look at the FAT[1] entry
    // This will need to be changed to increase the SECRUN initialization
    // by one sector so that the first FAT sector comes in.

    // The above comment is not an indication of bug.  It just a
    // note for any future change in QueryVolumeFlags.
    // From what I understand, the super area for FAT reads the
    // boot sector and both FATs while that of FAT32 reads the
    // boot sectors and just one FAT.  So, if we want to look at the
    // second FAT entry of the second copy of FAT, we will need to
    // read one more sector.  However, if we have more than 2 FATs,
    // we will have to make more changes to accomodate that.
    // -DanielCh 3/8/2000

    if (!_fatsa.Initialize(this, Message, OnlyIfDirty ? FALSE : TRUE)) {
        Destroy();
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    if (!_fatsa.Read(Message)) {
        Destroy();
        return FALSE;
    }

    if (OnlyIfDirty) {
        //
        // Note that we ignore any error return on this call.
        //
        _fatsa.InitFATChkDirty(this,Message);
    }

    return TRUE;
}

BOOLEAN
FAT_VOL::IsFileContiguous(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message,
    OUT     PULONG      NumBlocks
    )
/*++

Routine Description:

    This routine computes the number of contiguous blocks for the given
    file.  If the file has only one block then the file is contiguous and
    this function returns TRUE.  Otherwise this function returns FALSE and
    the number of blocks is optionally returned into 'NumBlocks'.

Arguments:

    FullPathFileName    - Supplies the file name of the file to check for
                            contiguity.
    Message             - Supplies an outlet for messages.
    NumBlocks           - Returns the number of contiguous blocks.

Return Value:

    FALSE   - The file is not contiguous.
    TRUE    - The file is contiguous.

--*/
{
    ULONG       num_blocks;
    PFAT        fat;
    ULONG       clus;
    DSTRING     slash;

    if (NumBlocks) {
        *NumBlocks = 0;
    }

    if (!slash.Initialize("\\")) {
        Message ? Message->Set(MSG_CHK_NO_MEMORY) : 1;
        Message ? Message->Display("") : 1;
        return FALSE;
    }

    if (*FullPathFileName == slash) {
        *NumBlocks = 1;
        return TRUE;
    }

    if ((clus = _fatsa.QueryFileStartingCluster(FullPathFileName)) == 1) {
        Message ? Message->Set(MSG_FILE_NOT_FOUND) : 1;
        Message ? Message->Display("%W", FullPathFileName) : 1;
        return FALSE;
    }

    if (clus == 0xFFFFFFFF) {
        Message ? Message->Set(MSG_CHK_NO_MEMORY) : 1;
        Message ? Message->Display("") : 1;
        return FALSE;
    }

    // Say that a zero length file is contiguous.

    if (clus == 0) {
        *NumBlocks = 1;
        return TRUE;
    }


    fat = _fatsa.GetFat();

    DebugAssert(fat);

    for (num_blocks = 1; ; num_blocks++) {
        while (!fat->IsEndOfChain(clus) &&
               (ULONG)(clus + 1) == fat->QueryEntry(clus)) {
            clus++;
        }
        if (fat->IsEndOfChain(clus)) {
            break;
        }
        clus = fat->QueryEntry(clus);
    }

    if (NumBlocks) {
        *NumBlocks = num_blocks;
    }

    return num_blocks == 1;
}


BOOLEAN
FAT_VOL::ContiguityReport(
    IN      PCWSTRING   DirectoryPath,
    IN      PCDSTRING   FilesToCheck,
    IN      ULONG       NumberOfFiles,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine generates a contiguity report for all of the 'FilesToCheck'.
    These file are assumed to all be in the directory pointed to by
    'DirectoryPath'.

Arguments:

    DirectoryPath   - Supplies the directory containing the files to check.
    FilesToCheck    - Supplies an array of files to check.
    NumberOfFiles   - Supplies the number of files in the preceeding array.
    Message         - Suppliea an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       num_blocks;
    PFAT        fat;
    ULONG       clus;
    DSTRING     slash;
    FILEDIR     filedir;
    PFATDIR     dir;
    HMEM        hmem;
    BOOLEAN     all_contig;
    FAT_DIRENT  fatdent;
    DSTRING     current_file;
    ULONG       i;
    DSTRING     directory_path;
    UCHAR       FatType;


    if (!slash.Initialize("\\")) {
        Message ? Message->Set(MSG_CHK_NO_MEMORY) : 1;
        Message ? Message->Display() : 1;
        return FALSE;
    }

    if ((clus = _fatsa.QueryFileStartingCluster(DirectoryPath)) == 1) {
        Message->Set(MSG_FILE_NOT_FOUND);
        Message->Display("%W", DirectoryPath);
        return FALSE;
    }

    if (clus == 0xFFFFFFFF) {
        Message ? Message->Set(MSG_CHK_NO_MEMORY) : 1;
        Message ? Message->Display() : 1;
        return FALSE;
    }

    fat = _fatsa.GetFat();

    if (!clus) {
        dir = _fatsa.GetRootDir();

        if ( !dir ) {
            dir = _fatsa.GetFileDir();
            FatType = FAT_TYPE_FAT32;
        } else
            FatType = FAT_TYPE_EAS_OKAY;

    } else {
        dir = &filedir;
        if (!hmem.Initialize() ||
            !filedir.Initialize(&hmem, this, &_fatsa, fat, clus)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        if (!filedir.Read()) {
            Message->Set(MSG_FILE_NOT_FOUND);
            Message->Display("%W", DirectoryPath);
            return FALSE;
        }
    }

    if (*DirectoryPath == slash) {

        if (!directory_path.Initialize("")) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }
    } else {
        if (!directory_path.Initialize(DirectoryPath)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }
    }


    all_contig = TRUE;
    for (i = 0; i < NumberOfFiles; i++) {

        if (!current_file.Initialize(&directory_path) ||
            !current_file.Strcat(&slash) ||
            !current_file.Strcat(&FilesToCheck[i])) {

            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        if (fatdent.Initialize(dir->SearchForDirEntry(&FilesToCheck[i]),FatType))
        {
           if (clus = fatdent.QueryStartingCluster()) {

                for (num_blocks = 1; ; num_blocks++) {
                    while (!fat->IsEndOfChain(clus) &&
                           (ULONG)(clus + 1) == fat->QueryEntry(clus)) {
                        clus++;
                    }
                    if (fat->IsEndOfChain(clus)) {
                        break;
                    }
                    clus = fat->QueryEntry(clus);
                }

                if (num_blocks != 1) {
                    Message->Set(MSG_CONTIGUITY_REPORT);
                    Message->Display("%W%d", &current_file, num_blocks);
                    all_contig = FALSE;
                }

            }

        } else {
            Message->Set(MSG_FILE_NOT_FOUND);
            Message->Display("%W", &current_file);
            all_contig = FALSE;
        }
    }

    if (all_contig) {
        Message->Set(MSG_ALL_FILES_CONTIGUOUS);
        Message->Display("");
    }

    return TRUE;
}


PVOL_LIODPDRV
FAT_VOL::QueryDupVolume(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType
    ) CONST
/*++

Routine Description:

    This routine allocates a FAT_VOL and initializes it to 'NtDriveName'.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.

Return Value:

    A pointer to a newly allocated FAT volume.

--*/
{
    PFAT_VOL    vol;

    // unreferenced parameters
    (void)(this);

    if (!(vol = NEW FAT_VOL)) {
    Message ? Message->Set(MSG_FMT_NO_MEMORY) : 1;
        Message ? Message->Display("") : 1;
        return NULL;
    }

    if (!vol->Initialize(NtDriveName, Message, ExclusiveWrite,
                         FormatMedia, MediaType)) {
        DELETE(vol);
        return NULL;
    }

    return vol;
}


VOID
FAT_VOL::Destroy(
    )
/*++

Routine Description:

    This routine returns a FAT_VOL object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in $(BASEDIR)\bak\bin\sources.tpl

!ENDIF

TARGETNAME=ufat
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(PROJECT_ROOT)\fs\utils\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib    \
           $(PROJECT_ROOT)\fs\utils\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
           $(PROJECT_LIB_PATH)\patchbc.lib

USE_MSVCRT=1

DLLENTRY=InitializeUfat
PRECOMPILED_INCLUDE= ..\pch.cxx
MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\hashindx.cxx    \
        ..\cluster.cxx     \
        ..\eaheader.cxx    \
        ..\easet.cxx       \
        ..\entry.cxx       \
        ..\fat.cxx         \
        ..\fatdent.cxx     \
        ..\fatdir.cxx      \
        ..\fatsa.cxx       \
        ..\fatsachk.cxx    \
        ..\fatsacnv.cxx    \
        ..\fatvol.cxx      \
        ..\filedir.cxx     \
        ..\reloclus.cxx    \
        ..\rfatsa.cxx      \
        ..\rootdir.cxx     \
        ..\ufat.cxx        \
        ..\ufat.rc

INCLUDES=..\.;  \
         ..\..\inc;     \
         $(PROJECT_ROOT)\fs\utils\ulib\inc;     \
         $(PROJECT_ROOT)\fs\utils\ifsutil\inc;  \
         $(DDK_INC_PATH)

C_DEFINES=-DUNICODE=1

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

UMTYPE=console
DLLDEF=..\ufat.def

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\reloclus.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    reloclus.cxx

Abstract:

    This module contains the definition of the RELOCATION_CLUSTER class.

Author:

    Ramon J. San Andres (ramonsa) 05-Nov-1991


--*/

#include <pch.cxx>



DEFINE_CONSTRUCTOR( RELOCATION_CLUSTER, OBJECT );

DEFINE_CAST_MEMBER_FUNCTION( RELOCATION_CLUSTER );




RELOCATION_CLUSTER::~RELOCATION_CLUSTER (
    )

/*++

Routine Description:

    Destructor for the RELOCATION_CLUSTER object

Arguments:

    None.

Return Value:

    None.

--*/

{
}



BOOLEAN
RELOCATION_CLUSTER::Initialize (
    IN  ULONG    Cluster
    )
/*++

Routine Description:

    Initializes a relocation cluster

Arguments:

    Cluster -   Supplies the cluster number

Return Value:

    BOOLEAN -   TRUE

--*/
{
    _Cluster  =   Cluster;

    return TRUE;
}




LONG
RELOCATION_CLUSTER::Compare (
    IN  PCOBJECT    Object
    ) CONST
/*++

Routine Description:

    Compares this relocation cluster against another object

Arguments:

    Object  -   Supplies pointer to other object

Return Value:

    LONG    -   See Compare in OBJECT

--*/
{
    PRELOCATION_CLUSTER     OtherCluster;

    DebugPtrAssert( Object );

    //
    //  If the other object is a relocation cluster, we do the comparison,
    //  otherwise we let someone else do it.
    //
    if ( OtherCluster = RELOCATION_CLUSTER::Cast( Object ) ) {

        if ( _Cluster < OtherCluster->QueryClusterNumber() ) {
            return -1;
        } else if ( _Cluster == OtherCluster->QueryClusterNumber() ) {
            return 0;
        } else {
            return 1;
        }
    } else {

        return OBJECT::Compare( Object );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\pch.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

        pch.cxx

Abstract:

        This module is a precompiled header for ufat.

Author:

        Matthew Bradburn (mattbr)  01-Feb-1994

--*/

#define _NTAPI_ULIB_
#define _UFAT_MEMBER_

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "ufat.hxx"

#include "cluster.hxx"
#include "eaheader.hxx"
#include "easet.hxx"
#include "fat.hxx"
#include "fatdir.hxx"
#include "fatsa.hxx"
#include "fatdent.hxx"
#include "fatvol.hxx"
#include "filedir.hxx"
#include "reloclus.hxx"
#include "rfatsa.hxx"
#include "rootdir.hxx"
#include "hashindx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\rootdir.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    rootdir.cxx

Abstract:

    This class is an implementation of FATDIR for the FAT root directory.

Author:

    Norbert P. Kusters (norbertk) 4-Dec-90

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( ROOTDIR, FATDIR, UFAT_EXPORT );

VOID
ROOTDIR::Construct (
        )
/*++

Routine Description:

    Constructor for ROOTDIR.

Arguments:

    None.

Return Value:

    None.

--*/
{
        _number_of_entries = 0;
}

extern VOID DoInsufMemory(VOID);

UFAT_EXPORT
ROOTDIR::~ROOTDIR(
    )
/*++

Routine Description:

    Destructor for ROOTDIR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
ROOTDIR::Initialize(
    IN      PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      LBN                 StartingSector,
    IN      LONG                NumberOfEntries
    )
/*++

Routine Description:

    This routine initializes the ROOTDIR object by specifying a drive,
    a position and a size.

Arguments:

    Mem             - Supplies the memory for the run of sectors.
    Drive           - Supplies the drive where the root directory is.
    StartingSector  - Supplies the starting sector of the root directory.
    NumberOfEntries - Supplies the number of entries in the root directory.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LONG        sector_size;
    SECTORCOUNT n;

    Destroy();

    if (!Drive || !(sector_size = Drive->QuerySectorSize())) {
        DebugPrintTrace(("UFAT: Failure to initialize ROOTDIR\n"));
        Destroy();
        return FALSE;
    }

    _number_of_entries = NumberOfEntries;

    n = (BytesPerDirent*NumberOfEntries - 1)/sector_size + 1;

    if (!_secrun.Initialize(Mem, Drive, StartingSector, n)) {
        DoInsufMemory();
        Destroy();
        return FALSE;
    }

    return TRUE;
}


VOID
ROOTDIR::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state.  Init must be
    called for this routine to be useful again.  This routine will
    free up memory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _number_of_entries = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\rfatsa.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    rfatsa.cxx

Author:

    Mark Shavlik (marks) 27-Mar-90
    Norbert Kusters (norbertk) 15-Jan-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "cmem.hxx"
#include "rtmsg.h"
#include "drive.hxx"
#include "bpb.hxx"
#include "bitvect.hxx"

extern "C" {
    #include <stdio.h>
}

#if defined(FE_SB) && defined(_X86_)
// PC98 boot strap code no use disk bios, PC98's boot strap code select.
extern UCHAR PC98FatBootCode[512];
extern UCHAR PC98Fat32BootCode[512*3];
#endif
extern UCHAR FatBootCode[512];
extern UCHAR Fat32BootCode[512*3];

#if !defined(_AUTOCHECK_) && !defined(_SETUP_LOADER_)
#include "timeinfo.hxx"
#endif

// Control-C handling is not necessary for autocheck.
#if !defined( _AUTOCHECK_ ) && !defined(_SETUP_LOADER_)

#include "keyboard.hxx"

#endif

#define CSEC_FAT32MEG            65536
#define CSEC_FAT16BIT            32680

#define MAX_CLUS_SMALL     4086     // Maximum number of clusters for FAT12 2^12 - 8 - 2
#define MAX_CLUS_ENT_SMALL 4087     // Largest fat entry for FAT12
#define MIN_CLUS_BIG       4087
#define MAX_CLUS_BIG       65526    // Maximum number of clusters for FAT16 2^16 - 8 - 2
#define MAX_CLUS_ENT_BIG   65527    // Largest fat entry for FAT16
#define MIN_CLUS_BIG32     65527
#define MAX_CLUS_BIG32     0x0FFFFFF6  // Maximum number of clusters for FAT32 2^28 - 8 - 2
#define MAX_CLUS_ENT_BIG32 0x0FFFFFF7  // Largest fat entry for FAT32
#define sigSUPERSEC1 (UCHAR)0x55    // signature first byte
#define sigSUPERSEC2 (UCHAR)0xAA    // signature second byte

//
// Sony Memory Stick thresholds
//
#define SMS_MIN_CLUS_SIZE   (8*1024)       // Minimum cluster size to use - 8K
#define SMS_MAX_CLUS_SIZE   (16*1024)      // Maximum cluster size to use - 16K
#define SMS_VOLSIZE_MIN_CLUS (10*1024*1024) // Maximum volume size to be formatted using
                                           // 8K instead of 16K cluster size

#define FAT_FIRST_DATA_CLUSTER_ALIGNMENT    (4*1024)    // data clusters starting alignment
#define NUMBER_OF_FATS                      (2)

//
//  The following macro computes the rounded up quotient of a number
//  divided by another number.
//

#define RoundUpDiv(num,div)  ((num) / (div) + ((num) % (div) ? 1 : 0))

//
//  The following macros maps a logical sector number to the corresponding
//  cluster on a volume based on the starting data Lbn and the number of
//  sectors per cluster.
//

#define MapSectorToCluster( sector, sec_per_clus, start_data_lbn ) \
    ((((sector) - (start_data_lbn)) / (sec_per_clus)) + FirstDiskCluster)

//
//  Internal function prototypes
//

ULONG
ComputeClusters(ULONG, ULONG, ULONG, ULONG, ULONG, FATTYPE);

VOID
PrintFormatReport (
    IN ULONG    BadClusters,
    IN PMESSAGE Message,
    IN BIG_INT  SectorSize,
    IN BIG_INT  ClusterSize,
    IN ULONG    ClusterCount,
    IN USHORT   FatType,
    IN PUSHORT  SerialNumber
    );

//
//  Functions for supporting the reduced memory consumption FAT (Reduced FAT)
//  format.
//

VOID SetEarlyEntries( PUCHAR, UCHAR, FATTYPE );
VOID SetEndOfChain( PUCHAR, ULONG, ULONG, FATTYPE );
VOID SetClusterBad( PUCHAR, ULONG, ULONG, FATTYPE );
VOID Set( PUCHAR, ULONG, ULONG, ULONG, FATTYPE );
VOID Set12( PUCHAR, ULONG, ULONG, ULONG);
VOID Set16( PUCHAR, ULONG, ULONG, ULONG);
VOID Set32( PUCHAR, ULONG, ULONG, ULONG);

//
//  End of internal function prototypes
//

DEFINE_EXPORTED_CONSTRUCTOR( REAL_FAT_SA, FAT_SA, UFAT_EXPORT );

BOOLEAN
REAL_FAT_SA::DosSaInit(
    IN OUT PMEM               Mem,
    IN OUT PLOG_IO_DP_DRIVE   Drive,
    IN     SECTORCOUNT        NumberOfSectors,
    IN OUT PMESSAGE           Message
    )
/*++

Routine Description:

    This routine simply initializes the underlying SUPERAREA structure
    and sets up a private pointer to the boot sector signature which is
    the last two bytes of the first sector. Note that the line for
    initializing the boot sector signature assumes that the sector size
    is 512 bytes.

Arguments:

    Mem - Supplies a pointer to a MEM which provides the memory for the
        REAL_FAT_SA object.

    Dive - Supplies a pointer the dirve object in which this super
        area object is found.

    NumberOfSectors - Supplies the total number of sectors on the
        volume.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE - Success.

    FALSE - Failure. The failure is probably caused by a lack of
        memory.

--*/
{

    //
    //  Class inheritance chain for REAL_FAT_SA:
    //  OBJECT<-SECRUN<-SUPERAREA<-FAT_SA<-REAL_FAT_SA
    //

    //
    //  Note that SUPERAREA::Initialize will initialize the
    //  _drive member. SUPERAREA::Initialize itself will call
    //  SECRUN::Initialize which aquires memory from the Mem
    //  object and marks the boundary of the superarea on the
    //  disk.
    //

    if (!SUPERAREA::Initialize(Mem, Drive, NumberOfSectors, Message)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    //
    //  Note that the following line of code depends on a sector size
    //  of twelve but changing the code based on the real sector size
    //  may break the boot code.
    //

    _sector_sig = (UCHAR *)SECRUN::GetBuf() + 510;

    return TRUE;
}


BOOLEAN
REAL_FAT_SA::DosSaSetBpb(
    )
/*++

Routine Description:

    This routine sets up the common fields in the FAT Bpb. More elaborate
    initialization of the Bpb is done in REAL_FAT_SA::SetBpb.

Arguments:

    NONE.

Return Values:

    TRUE - This method cannot fail.

--*/
{
#if defined _SETUP_LOADER_
    return FALSE;
#else
    ULONG Sec32Meg;        // num sectors in 32mb

    DebugAssert(_drive);
    DebugAssert(_drive->QuerySectors().GetHighPart() == 0);
    DebugAssert(_drive->QueryHiddenSectors().GetHighPart() == 0);


    //
    //  Sets up the bytes per sector field in the Bpb.
    //

    _sector_zero.Bpb.BytesPerSector = (USHORT)_drive->QuerySectorSize();

    //
    //  Theoretically, having 32megs of 128 bytes sectors will overflow the
    //  16-bit integer in the Sectors field of the Bpb so the following
    //  code is not absolutely fool-proof.
    //

    Sec32Meg = (32<<20) / _drive->QuerySectorSize();



    if (_drive->QuerySectors() >= Sec32Meg) {

        //
        //  >= 32Mb -- set BPB for large partition
        //

        _sector_zero.Bpb.Sectors = 0;
        _sector_zero.Bpb.LargeSectors = _drive->QuerySectors().GetLowPart();

    } else {

        //
        //  Size of DOS0 partition is < 32Mb
        //

        _sector_zero.Bpb.Sectors = (USHORT)_drive->QuerySectors().GetLowPart();
        _sector_zero.Bpb.LargeSectors = 0;
    }


    //
    //  The following block of code sets up the phycical characterics of the
    //  volume in the bpb.
    //

    _sector_zero.Bpb.Media = _drive->QueryMediaByte();
    _sector_zero.Bpb.SectorsPerTrack = (USHORT)_drive->QuerySectorsPerTrack();
    _sector_zero.Bpb.Heads = (USHORT)_drive->QueryHeads();
#if defined(FE_SB) && defined(_X86_)
    //  PC98 Oct.21.1995 ATAcard add
    //  PC98 Floppy disk should be treated same as PC/AT
    if (IsPC98_N() && !_drive->IsATformat() && !_drive->IsFloppy() && !_drive->IsSuperFloppy()){
        _sector_zero.Bpb.HiddenSectors = _drive->QueryPhysicalHiddenSectors().GetLowPart();
    } else
#endif
    _sector_zero.Bpb.HiddenSectors = _drive->QueryHiddenSectors().GetLowPart();

    return TRUE;
#endif // _SETUP_LOADER_
}

VOID
REAL_FAT_SA::Construct (
    )
/*++

Routine Description:

    Constructor for FAT_SA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _fat          = NULL;
    _dir          = NULL;
    _dirF32       = NULL;
    _hmem_F32     = NULL;
    _ft           = INVALID_FATTYPE;
    _StartDataLbn = 0;
    _ClusterCount = 0;
    _sysid        = SYSID_NONE;
    _data_aligned = FALSE;
    _AdditionalReservedSectors = MAXULONG;
}


UFAT_EXPORT
REAL_FAT_SA::~REAL_FAT_SA(
    )
/*++

Routine Description:

    Destructor for REAL_FAT_SA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

UFAT_EXPORT
BOOLEAN
REAL_FAT_SA::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Formatted
    )
/*++

Routine Description:

    This routine initializes the FAT super area to an initial state.  It
    does so by first reading in the boot sector and verifying it with
    the methods of REAL_FAT_SA.  Upon computing the super area's actual size,
    the underlying SECRUN will be set to the correct size.

    If the caller needs to format this volume, then this method should
    be called with the Formatted parameter set to FALSE.

Arguments:

    Drive       - Supplies the drive where the super area resides.
    Message     - Supplies an outlet for messages
    Formatted   - Supplies a boolean which indicates whether or not
                    the volume is formatted.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

    BIG_INT     data_offset;

    //
    //  Reset the state of the REAL_FAT_SA object.
    //

    Destroy();

    //
    //  Make sure that the boot sector(s) is(are) at least 512 bytes
    //  in size. Note that the boot area for a FAT32 volume is of size at least
    //  32 * 512 bytes but that adjustment will be made later. The first
    //  512 bytes of a FAT volume should contain the whole Bpb and that is all we
    //  care for the moment.
    //

    _sec_per_boot = max(1, BYTES_PER_BOOT_SECTOR/Drive->QuerySectorSize());

    if (!Formatted) {
        return _mem.Initialize() &&
               DosSaInit(&_mem, Drive, _sec_per_boot, Message);
    }

    //
    //  Do some quick parameter checking, initialize the underlying
    //  SUPERAREA and SECRUN structure, and read in the Bpb.
    //

    if (!Drive ||
        !(Drive->QuerySectorSize()) ||
        !_mem.Initialize() ||
        !DosSaInit(&_mem, Drive, _sec_per_boot, Message) ||
        !SECRUN::Read()) {

        Message->Set(MSG_CANT_READ_BOOT_SECTOR);
        Message->Display("");
        Destroy();
        return FALSE;

    }

    //
    //  Unpack the bpb in the SECRUN buffer into the _sector_zero
    //  member for easier access to the fields within the bpb.
    //

    UnpackExtendedBios(&_sector_zero,
        (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

    //
    //  Have a really quick check on the unpacked Bpb.
    //

    if (!VerifyBootSector() || !_sector_zero.Bpb.Fats) {
        Destroy();
        return FALSE;
    }

    //
    //  Determine the FAT type and the number of clusters on the volume
    //  depending on the
    //

    _ClusterCount = DetermineClusterCountAndFatType ( &_StartDataLbn,
                                                      &_ft );

    //
    // figured out if the data clusters are aligned
    //
    data_offset = QuerySectorsPerFat()*QueryFats()+QueryReservedSectors();
    data_offset = data_offset * Drive->QuerySectorSize();
    data_offset += QueryRootEntries()*BytesPerDirent;
    DebugAssert(FAT_FIRST_DATA_CLUSTER_ALIGNMENT <= MAXULONG);
    _data_aligned = ((data_offset.GetLowPart() & (FAT_FIRST_DATA_CLUSTER_ALIGNMENT - 1)) == 0);

    //
    //  Determine the partition id.
    //

    if (_ft == SMALL) {
        _sysid = SYSID_FAT12BIT;
    } else if (QueryVirtualSectors() < CSEC_FAT32MEG) {
        _sysid = SYSID_FAT16BIT;
    } else if (_ft == LARGE32) {
        _sysid = SYSID_FAT32BIT;
    } else {
        _sysid = SYSID_FAT32MEG;
    }

    //
    //  Adjust the _sector_per_boot member if the volume
    //  is a FAT32 volume and also in the case of a FAT32 drive
    //  only set up the super area to include memory for one FAT.
    //  On FAT32 drives the FAT can be much larger than on a FAT16 drive
    //  and we do not want to carry around the second FAT in memory as
    //  extra baggage.
    //

    if ( _ft == LARGE32 ) {
        //
        // FAT32 drives have a variable reserved area size so we do not want this
        // number hard wired at 32 unless it is not set yet (BPB value is 0 or 1)
        //
        if(_sector_zero.Bpb.ReservedSectors > 1) {
            _sec_per_boot = _sector_zero.Bpb.ReservedSectors;
        } else {
            _sec_per_boot = max((32 * 512)/_drive->QuerySectorSize(), 32);
        }
        if(!_mem.Initialize() || !DosSaInit(&_mem, Drive,
                            _sector_zero.Bpb.ReservedSectors + _sector_zero.Bpb.BigSectorsPerFat,
                            Message)) {
            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            Destroy();
            return FALSE;
        }
    } else {
        //
        //  The main idea behind the following code segment is to allocate
        //  memory for the whole super area including the boot area, all copies
        //  of the FAT, and the root directory for FAT12/16 volume and to initialize
        //  the underlying SECRUn object to cover the whole superarea on the
        //  disk.
        //
        if(!_mem.Initialize() || !DosSaInit(&_mem, Drive, _StartDataLbn, Message)) {
            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            Destroy();
            return FALSE;
        }
    }
    //
    //  Initialize the root directory of the volume.
    //

    if (!(InitializeRootDirectory(Message))) {
        return FALSE;
    }

    return TRUE;
}

UFAT_EXPORT
BOOLEAN
REAL_FAT_SA::InitFATChkDirty(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PMESSAGE        Message
    )
/*++

Routine Description:

    This routine initializes the _fat pointer in the FAT super area
    to point to the first sector of one of the FATs so that the dirty bits in the FAT[1]
    entry can be looked at.

Arguments:

    Drive   - Supplies the drive.
    Message     - Supplies an outlet for messages

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UINT    StartSec;


    UnpackExtendedBios(&_sector_zero,
               (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

    if (!VerifyBootSector() || !_sector_zero.Bpb.Fats) {
        return FALSE;
    }

    _ClusterCount = DetermineClusterCountAndFatType ( &_StartDataLbn,
                                                      &_ft );

    StartSec =  _sector_zero.Bpb.ReservedSectors;

    if(!_mem2.Initialize()) {
    return FALSE;
    }

    DELETE(_fat);
    if (!(_fat = NEW FAT)) {
    return FALSE;
    }

    if (!_fat->Initialize(&_secrun2, &_mem2, Drive, StartSec, _ClusterCount, 1)) {
    DELETE(_fat);
    return FALSE;
    }

    if(!_secrun2.Read()) {
    if(_sector_zero.Bpb.SectorsPerFat == 0) {
        StartSec += _sector_zero.Bpb.BigSectorsPerFat;
    } else {
        StartSec += (UINT)_sector_zero.Bpb.SectorsPerFat;
    }
    if (!_fat->Initialize(&_secrun2, &_mem2, Drive, StartSec, _ClusterCount, 1)) {
        DELETE(_fat);
        return FALSE;
    }
    if(!_secrun2.Read()) {
        DELETE(_fat);
        return FALSE;
    }
    }

    return TRUE;
}

ULONG
REAL_FAT_SA::DetermineClusterCountAndFatType (
    IN OUT  PULONG      StartingDataLbn,
    IN OUT  FATTYPE     *FatType
    )
/*++

Routine Description:

    This routine computes the number of clusters and fat type of a volume
    based on the total number of sectors on the volume and data in the Bpb.

    Note that this method assumes that the _sector_zero member has beeen
    initialized properly.

Arguments:

    StartingDataLbn - Supplies the address at which the starting data
        Lbn should be returned to the caller.

    FatType  - Supplies the address at which the Fat type should be
        returned to the caller.

Return Values:

    Number of clusters on the volume. Note that this number includes the
    first two entries.

--*/
{
    ULONG   cluster_count;      //  Number of clusters on the volume
    ULONG   sectors;            //  Number of sectors on the volume.
    ULONG   starting_data_lbn;  //  The first data sector on the FAT volume.
    FATTYPE fat_type;           //  FAT type.
    ULONG   sector_size;        //  Sector size.

    sectors = QueryVirtualSectors();
    starting_data_lbn = ComputeStartDataLbn();
    sector_size = _drive->QuerySectorSize();

    //
    //  Use the naive formula to compute a preliminary cluster count
    //  on the volume.
    //

    cluster_count = (sectors - starting_data_lbn) / (ULONG)QuerySectorsPerCluster() +
                    FirstDiskCluster;

    //
    //  We can determine the fat type now, note that we are assuming
    //  that subsequent adjustment to the cluster count will not affect the
    //  fat type which is fairly reasonable.
    //

    fat_type = cluster_count > MAX_CLUS_ENT_SMALL ? LARGE16 : SMALL;

    //
    //  It is possible to have a FAT16 volume that doesn't use up all
    //  the space on the disk so we should check whether _sector_zero.Bpb
    //  .SectorsPerfat == 0 in order to make sure that the volume is really
    //  a FAT32 volume.
    //

    if (cluster_count > MAX_CLUS_ENT_BIG) {
        if ( _sector_zero.Bpb.SectorsPerFat == 0 ) {
            fat_type = LARGE32;
        } else {
            cluster_count = MAX_CLUS_ENT_BIG;
        }
    }

    //
    // Check to make sure the FAT size in the BPB is actually big enough to hold this
    //  many clusters, adjust the cluster_count down if it is not.
    //

    switch(fat_type) {
    case SMALL:
        if (RoundUpDiv(cluster_count * 12, sector_size * 8) > _sector_zero.Bpb.SectorsPerFat ) {
        cluster_count = (_sector_zero.Bpb.SectorsPerFat * sector_size * 8) / 12;
        }
        break;
    case LARGE16:
        if (RoundUpDiv(cluster_count * 2, sector_size) > _sector_zero.Bpb.SectorsPerFat ) {
        cluster_count = (_sector_zero.Bpb.SectorsPerFat * sector_size) / 2;
        }
        break;
    case LARGE32:
        if (RoundUpDiv(cluster_count * 4, sector_size) > _sector_zero.Bpb.BigSectorsPerFat ) {
        cluster_count = (_sector_zero.Bpb.BigSectorsPerFat * sector_size) / 4;
        }
        break;
    default:
        DebugPrintTrace(("Bad FAT type.\n"));
    }

    //
    //  Make sure that the caller gets what it wants.
    //

    *FatType = fat_type;
    *StartingDataLbn = starting_data_lbn;
    return cluster_count;

}

BOOLEAN
REAL_FAT_SA::InitializeRootDirectory (
    IN  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine initializes the root directory structure in the
    FAT super area object after the boot sector has been read from the
    disk.

Arguments:

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - The opreation is completed successfully.
    FALSE - This routine fails to complete the intended operation.

--*/
{

    //
    //  Note that the root directory for a FAT32 volume is a cluster
    //  chain while the FAT16/12 root directory is a fixed size area
    //  that comes right after the FATs.
    //

    if ( _ft == LARGE32 ) {

        if (!(_dirF32 = NEW FILEDIR)) {
            Destroy();
            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            return FALSE;
        }

        //
        //  Complete initialization of _dirF32 is deffered until
        //  REAL_FAT_SA::read is called because the FAT
        //  is needed.
        //

    } else {

        CONT_MEM    cmem;           //  This CONT_MEM object piggybacks onto the
                                    //  the root directory section of the
                                    //  super area SECRUN buffer.
        ULONG       root_size;      //  Size of the root directory in number of sectors.
        ULONG       sector_size;    //  Well, it's kind of obvious isn't it.

        sector_size = _drive->QuerySectorSize();

        if (!(_dir = NEW ROOTDIR)) {

            Destroy();
            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            return FALSE;

        } else {

            ULONG   root_offset;    //  Sector offset of the root directory from the
                                    //  beginning of the disk.

            //
            //  Computes the sector offset of the root directory.
            //

            root_offset = _sector_zero.Bpb.ReservedSectors +
                          _sector_zero.Bpb.SectorsPerFat *
                          _sector_zero.Bpb.Fats;

            //
            //  Size of the root directory in number of bytes. Note that the
            //  result is rounded up to the nearest size size.
            //

            root_size = ((_sector_zero.Bpb.RootEntries * BytesPerDirent - 1)
                         / sector_size + 1) * sector_size;

            //
            //  Now it's time to initialize the root directory. Note that this operation
            //  shouldn't fail because REAL_FAT_SA::Initialize should have allocated
            //  enough memory for the root directory through REAL_FAT_SA::DosSaInit.
            //

            if(!cmem.Initialize((PCHAR) SECRUN::GetBuf() + (root_offset * sector_size), root_size) ||
               !_dir->Initialize(&cmem, _drive, root_offset, _sector_zero.Bpb.RootEntries)) {
                DebugPrintTrace(("The secrun buffer should have enough space, big bug in code.\n"));
                Message->Set(MSG_FMT_NO_MEMORY);
                Message->Display("");
                Destroy();
                return FALSE;
            }
        }
    }

    return TRUE;

}



BOOLEAN
REAL_FAT_SA::CreateBootSector(
    IN  ULONG    ClusterSize,
    IN  ULONG    Flags,
    IN  PMESSAGE Message
    )
/*++

Routine Description:

    This routine updates fields in sector 0.

Arguments:

    ClusterSize - Supplies the desired number of bytes per cluster.
    Flags       - Supplies the flags from format.
    Message - Supplies an outlet for messages.

Return Value:

    TRUE  -   Success.
    FALSE -   Failure.

--*/
{
#if defined _SETUP_LOADER_

    return FALSE;

#else

    SetVolId(ComputeVolId());

    return SetBpb(ClusterSize, Flags, Message) &&
           SetBootCode() &&
           SetPhysicalDriveType(_drive->IsRemovable() ?
                                PHYS_REMOVABLE : PHYS_FIXED) &&
           SetOemData() &&
           SetSignature();

#endif // _SETUP_LOADER_
}

VALIDATION_STATUS
REAL_FAT_SA::ValidateClusterSize(
    IN     ULONG    ClusterSize,
    IN     ULONG    Sectors,
    IN     ULONG    SectorSize,
    IN     ULONG    Fats,
    IN OUT FATTYPE  *FatType,
    OUT    PULONG   FatSize,
    OUT    PULONG   ClusterCount
    )
/*++

Routine Description:

   This routine validates whether a given cluster size is
valid for a particular FAT type. If the fat type provided is
INVALID_FATTYPE, this routine would determine whether FAT12 or
FAT16 should be used.

Arguments:

    ClusterSize - Supplies the cluster size to be validated.

    Sectors - Supplies the total number of sectors on the volume.

    SectorSize - Supplies the number of bytes per sector.

    Fats - Supplies the number of FATs in the volume.

    FatType - Supplies the FAT type that the volume is going to be
        formatted. The caller will supply INVALID_FATTYPE if
        it is unsure whether the volume should be formatted
        as a FAT16 volume or a FAT12 volume and let this function
        to make the descision.

    FatSize - Supplies a location where the size of a fat in number
        of sectors can be passed back to the caller if the
        cluster size is valid.

    ClusterCounter - Supplies a location where the total number
        of clusters can be passed back to the caller if the
        given cluster size is valid.

Return Values:

   VALIDATION_STATUS

   VALID     - The given cluster size is valid.
   TOO_SMALL - The given cluster size is too small (Too many clusters).
   TOO_BIG   - The given cluster size is too big. (Too few clusters).

++*/
{
    ULONG   min_sec_req;    //  Minimum number of sectors required.
    ULONG   min_fat_size;   //  Minimum size of the FATs in number
                            //  of sectors.
    ULONG   fat_entry_size; //  Number of bytes per fat entry.
    ULONG   sec_per_clus;   //  Number of sectors per cluster.
    ULONG   clusters;       //  Number of clusters.
    FATTYPE fat_type;       //  Local fat type.

    ULONG   initial_data_sector_offset;
    ULONG   data_sector_offset;
    ULONG   pad;            // Padding to be added to the reserved sectors
                            // for data alignment

    DebugAssert(ClusterSize);

    //
    // Check for absolute minumum (one sector per cluster)
    //

    if (ClusterSize < SectorSize) {
        return TOO_SMALL;
    }

    //
    //  Compute the number of sectors per cluster.
    //

    sec_per_clus = ClusterSize / SectorSize;

    //
    //  Make sure that sec_per_clus <= 128
    //

    if (sec_per_clus > 128) {
        return TOO_BIG;
    }

    fat_type = *FatType;
    if (fat_type == INVALID_FATTYPE) {

        //  If the caller doesn't specify the fat type,
        //  try FAT16 first unless the volume is > 2Gig bytes
        //  in size (512 byte sectors only).

        if((SectorSize == 512) && (Sectors > (4 * 1024 * 1024))) {
            fat_type = LARGE32;
        } else {
            fat_type = LARGE16;
        }
    }

    //
    //  Compute the minimum number of sectors required by the
    //  FAT(s)
    //  The minimum number of sectors that the fats on a volume will
    //  occupy is given by: RoundUp(Number of fats * (minimum number of
    //  clusters + 2) * bytes per fat entry / sector size).
    //

    if (fat_type == LARGE32) {

        fat_entry_size = 4;
        min_fat_size = RoundUpDiv( Fats * (MIN_CLUS_BIG32 + 2) * fat_entry_size,
                                   SectorSize);
        min_sec_req = min_fat_size + MIN_CLUS_BIG32 * sec_per_clus;

        if (Sectors > min_sec_req) { // Meets the minimum requirement

            //
            //  Compute the number of clusters
            //

            initial_data_sector_offset = max(32, _sec_per_boot);

            for (pad=0; ; pad++) {

                data_sector_offset = initial_data_sector_offset + pad;

                clusters = ComputeClusters( ClusterSize,
                                            Sectors,
                                            SectorSize,
                                            data_sector_offset,
                                            Fats,
                                            fat_type);

                *FatSize = RoundUpDiv((clusters+2) * fat_entry_size , SectorSize);

                data_sector_offset += (*FatSize * Fats);

                if (_drive->IsFloppy() ||
                    ((((BIG_INT)data_sector_offset*SectorSize).GetLowPart() &
                      (FAT_FIRST_DATA_CLUSTER_ALIGNMENT-1)) == 0)) {
                    _AdditionalReservedSectors = pad;
                    break;
                }
            }

            //
            //  Check to see if the cluster size is too small
            //

            if ( clusters > MAX_CLUS_BIG32 ) {
                return TOO_SMALL;
            }

            //
            //  See if this cluster size makes the FAT too big. Win95's FAT32
            //  support does not support FATs > 16Meg - 64k bytes in size because
            //  the GUI version of SCANDISK is a 16-bit windows application that
            //  has this limit on its allocation block size. This value is also
            //  a quite reasonable lid on FAT size.
            //

            if ((clusters * 4) > ((16 * 1024 * 1024) - (64 * 1024))) {
                return TOO_SMALL;
            }

            //
            //  Return the fat type if the caller
            //  doesn't specify it.
            //

            if (*FatType == INVALID_FATTYPE) {
                *FatType = LARGE32;
            }

            //
            //  Compute the fat size and return it to the caller
            //

            *ClusterCount = clusters + FirstDiskCluster;
            return VALID;
        }

        // Volume is too small for FAT32
        return TOO_BIG;

    }

    //
    //  The code in this function may look a bit asymmetrical
    //  but that's because we treat FAT32 separately from
    //  FAT16/12.
    //

    if (fat_type == LARGE16) {

        //
        //  Again, we compute the minimum number of sectors required
        //  if the volume is formatted as a FAT16 volume.
        //

        fat_entry_size = 2;
        min_fat_size = RoundUpDiv( Fats * (MIN_CLUS_BIG + 2) * fat_entry_size, SectorSize);
        min_sec_req = min_fat_size + MIN_CLUS_BIG * sec_per_clus;

        if (Sectors > min_sec_req) { // Meets the minimum requirement

            //
            //  Compute the number of clusters
            //

            initial_data_sector_offset = _sec_per_boot +
                                         (_sector_zero.Bpb.RootEntries * BytesPerDirent - 1) /
                                         SectorSize + 1;

            for (pad=0; ; pad++) {

                data_sector_offset = initial_data_sector_offset + pad;

                clusters = ComputeClusters( ClusterSize,
                                            Sectors,
                                            SectorSize,
                                            data_sector_offset,
                                            Fats,
                                            fat_type );

                *FatSize = RoundUpDiv((clusters + 2) * fat_entry_size, SectorSize);

                data_sector_offset += (*FatSize * Fats);

                if (_drive->IsFloppy() ||
                    ((((BIG_INT)data_sector_offset*SectorSize).GetLowPart() &
                      (FAT_FIRST_DATA_CLUSTER_ALIGNMENT-1)) == 0)) {
                    _AdditionalReservedSectors = pad;
                    break;
                }
            }

            if (clusters > MAX_CLUS_BIG) {

                return TOO_SMALL;

            } else {

                //
                //  Return the fat type if the caller
                //  doesn't specify it.
                //

                if (*FatType == INVALID_FATTYPE) {
                    *FatType = LARGE16;
                }

                //
                //  Compute and return the fat size to the caller.
                //

                *ClusterCount = clusters + FirstDiskCluster;
                return VALID;

            }

        } else {

            //
            //  Don't bother to fall over to the FAT12 section if the
            //  volume has more that 32679 sectors unless it's a sony memory stick.
            //

            if (*FatType == INVALID_FATTYPE &&
                (_drive->IsSonyMS() || Sectors < CSEC_FAT16BIT)) {

                //
                //  Fall over to the FAT12 section
                //

                fat_type = SMALL;

            } else {

                return TOO_BIG;

            }

        }

    }

    //
    //  A volume is never too small for FAT12 so we just
    //  check whether it is too big.
    //

    if (fat_type == SMALL) {

        initial_data_sector_offset = _sec_per_boot +
                                     (_sector_zero.Bpb.RootEntries * BytesPerDirent - 1) /
                                     SectorSize + 1;

        for (pad=0; ; pad++) {

            data_sector_offset = initial_data_sector_offset + pad;

            clusters = ComputeClusters( ClusterSize,
                                        Sectors,
                                        SectorSize,
                                        data_sector_offset,
                                        Fats,
                                        fat_type );

            *FatSize = RoundUpDiv(RoundUpDiv((clusters + 2) * 3, 2), SectorSize);

            data_sector_offset += (*FatSize * Fats);

            if (_drive->IsFloppy() ||
                ((((BIG_INT)data_sector_offset*SectorSize).GetLowPart() &
                  (FAT_FIRST_DATA_CLUSTER_ALIGNMENT-1)) == 0)) {
                _AdditionalReservedSectors = pad;
                break;
            }
        }

        if (clusters > MAX_CLUS_SMALL) {
            return TOO_SMALL;
        }

        //
        //  Return fat type to caller if necessary
        //

        if (*FatType == INVALID_FATTYPE) {
            *FatType = SMALL;
        }

        //
        //  Compute and return the FAT size
        //

        *ClusterCount = clusters + FirstDiskCluster;
        return VALID;

    }

    DebugAbort("This line should never be executed.\n");
    return TOO_BIG;

}

ULONG
ComputeClusters(
    IN  ULONG        ClusterSize,
    IN  ULONG        Sectors,
    IN  ULONG        SectorSize,
    IN  ULONG        ReservedSectors,
    IN  ULONG        Fats,
    IN  FATTYPE      FatType
    )
/*++

Routine Description:

    This routine computes the number of clusters on a volume given
    the cluster size, volume size and the fat type.

Arguments:

    ClusterSize - Supplies the size of a cluster in number of bytes.

    Sectors - Supplies the total number of sectors in the volume.

    SectorSize - Supplies the size of a sector in number of bytes.

    ReservedSectors - Supplies the number of reserved sectors.

    Fats - Supplies the number of copies of fat for this volume.

    FatType - Supplies the fat type.

Return Value:

    ULONG - The total number of clusters for the given configuration.

++*/
{
    ULONG entries_per_sec; //  Number of FAT entries per sector.
    ULONG fat_entry_size;  //  Size of each FAT entry in number of BITS.
    ULONG sectors_left;    //  Number of sectors left for consideration.
    ULONG residue;         //  The residue number of bits per sector.
    ULONG acc_residue = 0; //  The accumulated residue number of FAT entry
                           //  bits.
    ULONG sec_per_clus;    //  Sectors per cluster.
    ULONG increment = 1;   //  Increment step size in number of FAT sectors.
    ULONG additional_clus; //  Number of additional clusters possible due to
                           //  the accumulated residue bits in the fat.
    ULONG clusters = 0;    //  Number of clusters in total.
    ULONG temp;            //  Temporary place-holder for optimizing certain
                           //  computations.

    sectors_left = Sectors - ReservedSectors;

    sec_per_clus = ClusterSize / SectorSize;

    //
    //  Determine the Fat entry size in number of bits based on the
    //  fat type.
    //

    switch (FatType) {
        case SMALL:
            fat_entry_size = 12;
            break;
        case LARGE16:
            fat_entry_size = 16;
            break;
        case LARGE32:
            fat_entry_size = 32;
            break;
    }

    //
    //  Compute the number of FAT entries a sector can hold.
    //    NOTE that fat_entry_size is the size in BITS,
    //    this is the reason for the "* 8" (bits per byte).
    //

    entries_per_sec = (SectorSize * 8) / fat_entry_size;

    //
    //  If the FAT entry size doesn't divide the sector
    //  size evenly, we want to know the residue.
    //

    residue = (SectorSize * 8) % fat_entry_size;

    //
    //  Compute a sensible increment step size to begin with.
    //

    while (Sectors / (increment * entries_per_sec * sec_per_clus) > 1) {
        increment *= 2;
    }

    //
    //  We have to handle the first sector of FAT entries
    //  separately because the first two entries are reserved.
    //  Kind of yucky, isn't it?
    //

    temp = Fats + ((entries_per_sec - 2) * sec_per_clus);
    if (sectors_left < temp) {

        return (sectors_left - Fats) / sec_per_clus;

    } else {

        sectors_left -= temp;
        acc_residue += residue;
        clusters += entries_per_sec - 2;

        while (increment && sectors_left) {

            additional_clus = (acc_residue + (increment * residue)) / fat_entry_size;
            temp = (Fats + entries_per_sec * sec_per_clus) * increment + additional_clus * sec_per_clus;

            if (sectors_left < temp) {

                //
                //  If the increment step is only one, try to utilize the remaining sectors
                //  as much as possible.
                //

                if (increment == 1) {

                    //
                    // Exhaust the residue fat entries first
                    //

                    temp = acc_residue / fat_entry_size;
                    if (temp <= sectors_left / sec_per_clus) {

                        clusters += temp;
                        sectors_left -= temp * sec_per_clus;

                    } else {

                        clusters += sectors_left / sec_per_clus;
                        sectors_left -= sectors_left / sec_per_clus;

                    }

                    //
                    // Additional clusters may be possible after allocating
                    // one more sector of fat.
                    //
                    if ( sectors_left > Fats) {
                        temp = (sectors_left - Fats) / sec_per_clus;
                        if (temp > 0) {
                            clusters += temp;
                        }
                    }

                }

                //
                // Cut the increment step by half if it is too big.
                //

                increment /= 2;

            } else {

                if (additional_clus) {
                    acc_residue = (acc_residue + (increment * residue)) % (additional_clus * fat_entry_size);
                } else {
                    acc_residue += increment * residue;
                }
                sectors_left -= temp;
                clusters += increment * entries_per_sec + additional_clus;

            }

        }
        return clusters;
    }

    DebugAbort("This line should never be executed.");
    return 0;
}

ULONG
REAL_FAT_SA::ComputeDefaultClusterSize(
    IN  ULONG        Sectors,
    IN  ULONG        SectorSize,
    IN  ULONG        ReservedSectors,
    IN  ULONG        Fats,
    IN  MEDIA_TYPE   MediaType,
    IN  FATTYPE      FatType,
    OUT PULONG       FatSize,
    OUT PULONG       ClusterCount
    )
/*++

Routine Description:

    This routine computes a default cluster size given the total number
    of free sectors and fat type.

Arguments:

    Sectors - Supplies the total number of sectors on the volume.

    SectorSize - Supplies the size of a sector in bytes.

    ReservedSectors - Supplies the number of reserved sectors.

    Fats - Supplies the number of fats.

    MediaType - Supplies the media type.

    FatType - Supplies the fat type.

    FatSize - Supplies a location for this routine to pass back the
        size of a FAT in number of sectors back to the caller.

    ClusterCount - Supplies a location for this routine to pass back
        the total number of clusters on the volume.


Return Values:

    ULONG - The number of clusters that should on the volume computed
            by the default algorithm.

++*/
{
    ULONG             fat_size;      //  Number of sectors per fat.
    ULONG             sec_per_clus;  //  Number of sectors per cluster.
    ULONG             cluster_size;  //  Cluster size in number of bytes.
    VALIDATION_STATUS result;        //  Result after validating
                                     //  the cluster size.

    //
    //  Assign a reasonable value to sec_per_clus
    //  base on the number of sectors in total.
    //

    switch (FatType) {
        case LARGE32:
        //
        // The numbers in this may look a bit odd and arbitrary, they are.
        // They match the ones that MS-DOS/Win95 use for FAT32 drives, at least
        // for 512 byte sectors. NOTE than in the case of other sector sizes
        //
        if (Sectors >= 64*1024*1024) {          // >= 32GB
            sec_per_clus = 64;                  //   32k cluster @ 512 byt/sec
        } else if (Sectors >= 32*1024*1024) {   // >= 16GB
            sec_per_clus = 32;                  //   16k cluster @ 512 byt/sec
        } else if (Sectors >= 16*1024*1024) {   // >=  8GB
            sec_per_clus = 16;                  //    8k cluster @ 512 byt/sec
        } else {                                // else
            sec_per_clus = 8;                   //    4k cluster @ 512 byt/sec
        }
            break;

        case LARGE16:
            sec_per_clus = 1;
            break;

        case SMALL:
            sec_per_clus = 1;
            break;

        default:
            sec_per_clus = 0;   // set it to an invalid value
            DebugAbort("This cannot happen.");
    }

    DebugAssert(GetDrive());

    if (GetDrive()->IsSonyMS()) {
        //
        // Select default cluster size based on memory stick size
        //
        sec_per_clus = SMS_MIN_CLUS_SIZE/SectorSize;
        if (Sectors >= (SMS_VOLSIZE_MIN_CLUS/SectorSize)) {
            sec_per_clus = SMS_MAX_CLUS_SIZE/SectorSize;
        }
    }

    //
    //  If this is a floppy disk, we just choose a default value.
    //

    switch (MediaType) {

        case F5_320_512:
        case F5_360_512:
        case F3_720_512:
        case F3_2Pt88_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_640_512:
        case F3_640_512:
        case F5_720_512:
#endif
            sec_per_clus = 2;
            break;

        case F3_20Pt8_512:
#if defined(FE_SB)
        case F3_128Mb_512:
#if defined(_X86_)
        case F8_256_128:
#endif
#endif
            sec_per_clus = 4;
            break;

#if defined(FE_SB)
        case F3_230Mb_512:
            sec_per_clus = 8;
            break;
#endif

        default:
            break;

    }

    //
    // Validate the assigned number of sectors per
    // cluster and readjust them if necessary.
    //

    result = ValidateClusterSize( sec_per_clus * SectorSize,
                                  Sectors,
                                  SectorSize,
                                  Fats,
                                  &_ft,
                                  &fat_size,
                                  ClusterCount);

    switch (result) {

        case TOO_SMALL:

            //
            //  If the cluster size is too small, keep enlarging
            //  it by a factor of 2 until it is valid.
            //

            do {
                sec_per_clus *= 2;
                if ( sec_per_clus > 128 ) {
                    return (sec_per_clus * SectorSize);
                }
            } while (ValidateClusterSize( sec_per_clus * SectorSize,
                                          Sectors,
                                          SectorSize,
                                          Fats,
                                          &_ft,
                                          &fat_size,
                                          ClusterCount) != VALID);

            break;

        case TOO_BIG:

            //
            //  If the cluster size is too big, keep reducing it
            //  by half until it is valid.
            //

            do {
                sec_per_clus /= 2;
                if ( sec_per_clus == 0 ) {
                    return (sec_per_clus * SectorSize);
                }
            } while (ValidateClusterSize( sec_per_clus * SectorSize,
                                          Sectors,
                                          SectorSize,
                                          Fats,
                                          &_ft,
                                          &fat_size,
                                          ClusterCount) != VALID);

            break;

        case VALID:
            break;
        default:
            DebugAbort("This should never happen.");
            break;
    }

    *FatSize = fat_size;
    return (sec_per_clus * SectorSize);

}


BOOLEAN
REAL_FAT_SA::SetBpb(
     )
{
   DebugAbort("This method should never be called.");
   return FALSE;
}

BOOLEAN
REAL_FAT_SA::SetBpb(
    IN  ULONG    ClusterSize,
    IN  ULONG    Flags,
    IN  PMESSAGE Message
    )
/*++

Routine Description:

    This routine sets up the BPB from scratch for the FAT file system.

Arguments:

    ClusterSize - Supplies the desired number of bytes per cluster.
    Flags       - Supplies the flags from format.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if defined( _SETUP_LOADER_ )

    return FALSE;

#else // _SETUP_LOADER_


    BOOLEAN     BackwardCompatible = ((Flags & FORMAT_BACKWARD_COMPATIBLE) ? TRUE : FALSE);
                                  // flag to determine fat 16/12 compatibility

    SECTORCOUNT sectors;          //  Total number of sectors.
    ULONG       sector_size;      //  Size of each sector in bytes.
    USHORT      sec_per_clus = 0; //  Sectors per cluster
    ULONG       cluster_size = 0; //  Size of each cluster in bytes.
    VALIDATION_STATUS result;     //  Return code from ValidateClusterSize.
    ULONG       fat_size;         //  Size of each fat in number of
                                  //  sectors.
#if DBG
    BIG_INT     data_offset;      // the offset to first data cluster
#endif

    //
    //  Call DosSaSeetBpb to perform some very rudimentary bpb setup.
    //

    if (!DosSaSetBpb()) {
        DebugPrintTrace(("Could not do a REAL_FAT_SA::DosSaSetBpb.\n"));
        return FALSE;
    }

    //
    //  A volume cannot have more than 4gig sectors.
    //
    DebugAssert(_drive->QuerySectors().GetHighPart() == 0);

    sectors = _drive->QuerySectors().GetLowPart();
    sector_size = _drive->QuerySectorSize();

    PCHAR fattypestr;
    if (!BackwardCompatible) {

        //
        //  If BackwardCompatible is false, then the user must have
        //  specified the /fs:FAT32 switch or the existing volume
        //  must be a FAT32 volume when a quik format is performed.
        //

        _ft = LARGE32;
        fattypestr = "FAT32";

    } else {

        //
        //  At this moment, we don't know whether FAT16 or FAt12
        //  is appropriate for this volume.
        //

        _ft = INVALID_FATTYPE;
        fattypestr = "FAT16/12";

    }

    if (_drive->QuerySectors().GetHighPart() != 0) {
        Message->Set(MSG_FMT_VOL_TOO_BIG);
        Message->Display("%s", fattypestr);
        return FALSE;
    }

    //
    //  The boot area of a FAt32 volume is at least 32 sectors large
    //  and at least 32 * 512 bytes in size.
    //

    if (_ft == LARGE32) {
        _sec_per_boot = max((32 * 512) / sector_size, 32);
    }

    //
    //  Set up the number of reserved sectors and the number of
    //  FATs in the boot sector. Note that ValidateClusterSize and
    //  ComputeDefaultClusterSize depend on these values so don't move
    //  the following lines to anywhere else.
    //

    _sector_zero.Bpb.ReservedSectors = (USHORT)_sec_per_boot;
    _sector_zero.Bpb.Fats = 2;

    //
    //  Try to honor the cluster size provided by the user.
    //

    if (ClusterSize) {

        //
        //  If the cluster size specified by the user is not
        //  of the form sector_size * 2^n where n is an integer
        //  then choose a cluster size which is of the form 2^n
        //  * sector size and is just bigger than the cluster
        //  size specified by the user.
        //

        USHORT i;
        cluster_size = sector_size;
        sec_per_clus = 1;

        //
        // Check that the user specified cluster size is at least as big as
        // the minimum allowed cluster size as determined by the sector size.
        //

        if (ClusterSize < cluster_size) {
            Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_SMALL_MIN);
            Message->Display("%u", sector_size);
            return FALSE;
        }

        while (cluster_size < ClusterSize && sec_per_clus < 256) {
            cluster_size *= 2;
            sec_per_clus *= 2;
        }

        //
        //  Make sure that the cluster size provided by the user
        //  is not too big.
        //

        if (sec_per_clus > MaxSecPerClus) {

            Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_BIG);
            Message->Display("%s", fattypestr);
            return FALSE;
        }

        //
        //  Issue a warning if the cluster size computed is not
        //  equal to the cluster size provided by the user.
        //

        if (cluster_size != ClusterSize) {
            if (Flags & FORMAT_YES) {
                Message->Set(MSG_FMT_CLUSTER_SIZE_MISMATCH_WARNING);
                Message->Display("%u", cluster_size);
            } else {
                Message->Set(MSG_FMT_CLUSTER_SIZE_MISMATCH);
                Message->Display("%u", cluster_size);
                if (!Message->IsYesResponse(FALSE)) {
                    return FALSE;
                }
            }
        }
    }

    _sector_zero.Bpb.RootEntries = (USHORT)ComputeRootEntries();

    if (cluster_size) {

        //
        //  Make sure that the cluster size is valid for a
        //  FAT volume.
        //

        result = ValidateClusterSize( cluster_size,
                                      sectors,
                                      sector_size,
                                      NUMBER_OF_FATS,
                                      &_ft,
                                      &fat_size,
                                      &_ClusterCount );

        //
        //  Tell the user the cluster size specified is invalid
        //  for the FAT type chosen.
        //

        switch (result) {
            case TOO_SMALL:
                Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_SMALL);
                Message->Display("%s", fattypestr);
                return FALSE;
            case TOO_BIG:
                Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_BIG);
                Message->Display("%s", fattypestr);
                return FALSE;
        }

    }


    if (BackwardCompatible && _ft == INVALID_FATTYPE) {

        //
        //  Use CSEC_16BIT as a cut-off point for determining
        //  whether the FAT should be 16-bit or 12-bit unless
        //  it is a Sony memory stick.
        //  If it is a Sony memory stick, then anything 64MB
        //  or less should be FAT12.

        if (_drive->IsSonyMS()) {
            if (sectors < SMS_VOLSIZE_SMALL/sector_size) {   // use a slightly larger cutoff point
                _ft = SMALL;
            } else {
                _ft = LARGE16;
            }
        } else if (sectors < CSEC_FAT16BIT) {
            _ft = SMALL;
        } else {
            _ft = LARGE16;
        }
    }

    //
    //  If the user doesn't provide a cluster size, we have
    //  to compute a default cluster size.
    //
    if (!cluster_size) {

        cluster_size = ComputeDefaultClusterSize( sectors,
                                                  sector_size,
                                                  _sector_zero.Bpb.ReservedSectors,
                                                  NUMBER_OF_FATS,
                                                  _drive->QueryMediaType(),
                                                  _ft,
                                                  &fat_size,
                                                  &_ClusterCount);
        if (cluster_size == 0) {
            Message->Set(MSG_FMT_VOL_TOO_SMALL);
            Message->Display("%s", fattypestr);
            return FALSE;

        } else if (cluster_size > 128 * sector_size) {
            Message->Set(MSG_FMT_VOL_TOO_BIG);
            Message->Display("%s", fattypestr);
            return FALSE;

        }

    }

    //
    // Check for volume limits.
    //
    //  If volume is > 32Gig, say we won't do FAT
    //  If cluster size is 64k warn about compatibility issues
    //

    if((sectors / ((1024 * 1024) / sector_size)) > (32 * 1024)) {
        Message->Set(MSG_FMT_VOL_TOO_BIG);
        Message->Display("%s", fattypestr);
        return FALSE;
    }

    if(cluster_size >= (64 * 1024)) {
        if (Flags & FORMAT_YES) {
            Message->Set(MSG_FMT_CLUSTER_SIZE_64K_WARNING);
            Message->Display("");
        } else {
            Message->Set(MSG_FMT_CLUSTER_SIZE_64K);
            Message->Display("");
            if (!Message->IsYesResponse(TRUE)) {
                return FALSE;
            }
        }
    }

    //
    //  Compute the number of sectors per clusters.
    //

    _sector_zero.Bpb.SectorsPerCluster = (UCHAR) (cluster_size / sector_size);
    if (_ft == LARGE32) {
        _sector_zero.Bpb.SectorsPerFat = 0;
        _sector_zero.Bpb.BigSectorsPerFat = fat_size;
    } else {
        _sector_zero.Bpb.SectorsPerFat = (USHORT)fat_size;
        _sector_zero.Bpb.BigSectorsPerFat = 0;
    }

    if (_ft == SMALL) {
        memcpy(_sector_zero.SystemIdText, "FAT12   ", cSYSID);
    } else if (_ft == LARGE32) {
        memcpy(_sector_zero.SystemIdText, "FAT32   ", cSYSID);
    } else {
        memcpy(_sector_zero.SystemIdText, "FAT16   ", cSYSID);
    }

    memcpy(_sector_zero.Label, "NO NAME    ", cLABEL);

    _sector_zero.CurrentHead = 0;

    //
    //  Initialize the additional fields in the FAT32 boot
    //  sector.
    //

    if (_ft == LARGE32) {
        //
        // Recompute RootEntries, _sec_per_boot, and ReservedSectors
        // in case _ft changes
        //
        _sector_zero.Bpb.RootEntries = (USHORT)ComputeRootEntries();
        _sec_per_boot = max((32 * 512) / _drive->QuerySectorSize(), 32);
        _sector_zero.Bpb.ReservedSectors = (USHORT)_sec_per_boot;

        _sector_zero.Bpb.ExtFlags = 0;
        _sector_zero.Bpb.FS_Version = 0;
        _sector_zero.Bpb.RootDirStrtClus = 2;
        _sector_zero.Bpb.FSInfoSec = 1;
        _sector_zero.Bpb.BkUpBootSec = max(6, (USHORT)((6 * 512) / sector_size));
    }

    DebugAssert(_AdditionalReservedSectors != MAXULONG);
    //
    // Sony camera assumes memory stick ReservedSectors to be 1 for FAT12/16
    // If not, corruption will occur when camera tries to write to memory stick
    //
    if (!_drive->IsSonyMS()) {
        _sec_per_boot += _AdditionalReservedSectors;
    }
    _sector_zero.Bpb.ReservedSectors = (USHORT)_sec_per_boot;

#if DBG
    if (!_drive->IsSonyMS()) {
        data_offset = ((BIG_INT)(fat_size*NUMBER_OF_FATS + _sec_per_boot))*sector_size +
                      (_sector_zero.Bpb.RootEntries*BytesPerDirent);
        DebugAssert (_drive->IsFloppy() ||
                     ((data_offset.GetLowPart() & (FAT_FIRST_DATA_CLUSTER_ALIGNMENT - 1)) == 0));
    }
#endif

    return TRUE;

#endif // _SETUP_LOADER_
}

#if defined( _AUTOCHECK_ )

#define LOCALE_STHOUSAND              0x0000000F   // thousand separator

typedef unsigned int        UINT;
typedef unsigned int        *PUINT;
typedef unsigned int        *LPUINT;

int
ChkGetLocaleInfoW(
    UINT     Locale,
    UINT     LCType,
    LPWSTR   lpLCData,
    int      cchData)
{
    //
    //  For AUTOCHK we do not do thousand seperators. The NLS APIs are not
    //  around, and the registry isn't really set up either so there is no standard
    //  language place available to determine what the thousand seperator is.
    //
    return 0;
}

UINT
ChkGetUserDefaultLCID(void)
{
    return 0;
}

#else
#define ChkGetLocaleInfoW   GetLocaleInfoW
#define ChkGetUserDefaultLCID   GetUserDefaultLCID
#endif


VOID
InsertSeparators(
    LPCWSTR OutWNumber,
    char * InANumber,
    ULONG  Width
    )
{
    WCHAR szSeparator[10];
    WCHAR Separator;
    LPWSTR lpWNumber;

    lpWNumber = (LPWSTR)OutWNumber;

    if (0 != ChkGetLocaleInfoW(
                   ChkGetUserDefaultLCID(),
                   LOCALE_STHOUSAND,
                   szSeparator,
                   10
                  ))
    {
        Separator = szSeparator[0];
    }
    else
    {
    Separator = L'\0';  // If we can't get the thousand separator, do not use one.
    }

    WCHAR Buffer[100];
    ULONG cchNumber = strlen((LPCSTR)InANumber);
    UINT Triples = 0;

    Buffer[99] = L'\0';
    PWCHAR pch = &Buffer[98];

    while (cchNumber > 0)
    {
    *pch-- = InANumber[--cchNumber];

        ++Triples;
    if ( (Separator != L'\0') && (0 == (Triples % 3)) && (cchNumber > 0) )
        {
            *pch-- = Separator;
        }
    }

    cchNumber = wcslen((pch + 1));
    if(cchNumber < Width) {
    UINT i;

    cchNumber = Width - cchNumber;
    for(i = 0; i < cchNumber; i++) {
        lpWNumber[i] = L' ';
    }
    } else {
    cchNumber = 0;
    }

    wcscpy(lpWNumber + cchNumber, pch + 1); // the Number buffer better be able to handle it!
}

BOOLEAN
REAL_FAT_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label,
    IN      ULONG           Flags,
    IN      ULONG           ClusterSize,
    IN      ULONG           VirtualSize
    )
/*++

Routine Description:

    This routine initializes the FAT file system.

Arguments:

    BadSectors - Supplies a list of the bad sectors on the volume.

    Message - Supplies an outlet for messages.

    Label - Supplies an optional label.

    Flags - Supplies flags from format.

    ClusterSize - Supplies the cluster size specified by the user. If
        the user doesn't specify a cluster size, this parameter will
        be zero.

    VirtualCluster - Not used.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

Notes: FAT32 root directory uses the FILEDIR structure as
       opposed to the ROOTDIR structure used in FAT16/12.
--*/
{
#if defined( _SETUP_LOADER_ )

    return FALSE;

#else

    ULONG bad_clusters;

    //
    //  CreateBootSector initializes the private member
    //  _sector_zero which mirrors the boot sector.
    //  Note that the new boot sector has not been written to
    //  the disk yet at this point.
    //

    if (!CreateBootSector(ClusterSize, Flags, Message)) {
        return FALSE;
    }

#if defined(FE_SB) && defined(_X86_)
    //
    //  Set the appropriate boot code according to environment.
    //  This must be here because _ft is fixed at CreateBootSector().
    //
    if (IsPC98_N() && !_drive->IsATformat()) {
    if ( _ft == LARGE32 ) {
        _bootcode = PC98Fat32BootCode;
        _bootcodesize = sizeof(PC98Fat32BootCode);
    }
    else {
        _bootcode = PC98FatBootCode;
        _bootcodesize = sizeof(PC98FatBootCode);
    }
    }
    else {
#endif
    if ( _ft == LARGE32 ) {
        _bootcode = Fat32BootCode;
        _bootcodesize = sizeof(Fat32BootCode);
    }
    else {
        _bootcode = FatBootCode;
        _bootcodesize = sizeof(FatBootCode);
    }
#if defined(FE_SB) && defined(_X86_)
    }
#endif

    //
    //  Check that the REAL_FAT_SA object is initialized
    //  properly before this method is called. Also compute the
    //  appropriate partition id.
    //

    if (!_drive ||
        (_sysid = ComputeSystemId()) == SYSID_NONE) {
        return FALSE;
    }

    //
    //  These "Hidden Status" messages are a hack to allow WinDisk to
    //  cancel a quick format, which ordinarily doesn't send any status
    //  messages, but which might take a while and for which there is a
    //  cancel button.  When using format.com, no message will be displayed
    //  for this.
    //

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    //
    //  DiskIsUsable will compute the proper value for the _StartDataLbn
    //  member.
    //

    if (!DiskIsUsable(BadSectors, Message)) {
        return FALSE;

    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    //
    //  WriteNewFats will initialize _sector_zero.Bpb.RootDirStrtClus to the
    //  first error-free cluster on a FAT32 volume.
    //

    if (!WriteNewFats( BadSectors, &bad_clusters, Message)){
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    //
    //  Initialize new root directory on the disk.
    //

    if (!WriteNewRootDirAndVolumeLabel( Label, Message )) {
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    //
    //  Initialize new boot sector and setup boot code.
    //

    if (!WriteNewBootArea(Message)) {
        return FALSE;
    }

    //
    //  Set file system id in the corresponding PARTITION
    //  TABLE ENTRY.
    //

    if (!SetSystemId()) {

       Message->Set(MSG_WRITE_PARTITION_TABLE);
       Message->Display("");
       return FALSE;

    }

    Message->Set(MSG_FORMAT_COMPLETE);
    Message->Display("");


    //
    //  Print an informative report.
    //

    PrintFormatReport( bad_clusters, Message );

    return TRUE;


#endif
}

BOOLEAN
REAL_FAT_SA::DiskIsUsable (
    IN  PCNUMBER_SET    BadSectors,
    IN  PMESSAGE        Message
    )
/*++

Routine Description:

    This routine checks whether the volume is write-protected and whether there
    are any bad sectors in the critical area(boot sector, fats, and rootdir for FAT16).
    Note that this routine will initialize the _StartDataLbn member to a proper value
    when it is done.


Arguments:

    BadSectors - Supplies the set of bad sectors on the volume.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - The volume is usable.

    FALSE - The volume is either write-protected or one of the sectors
        in the critical area is bad.

--*/
{
    //
    //  Computes the first data sector which also serves as the
    //  boundary of the FAT critical area.
    //

    _StartDataLbn = ComputeStartDataLbn();

    //
    //  Since the set of bad sectors is sorted in ascending order,
    //  we only have to check whether the first bad sectors is in the
    //  critical area.
    //

    if (BadSectors->QueryCardinality().GetLowPart()) {

        if (BadSectors->QueryNumber(0).GetLowPart() < _StartDataLbn ) {

            Message->Set(MSG_UNUSABLE_DISK);
            Message->Display("");
            return FALSE;

        }

    }

    //
    //  Check to see if the disk is write protected by trying to
    //  write to the first sector. Note that REAL_FAT_SA::Initialize
    //  has already allocated memory for the boot sector.
    //

    // wipe out signature so as not to confuse the system when dealing with superfloppy

    *_sector_sig = 0;
    *(_sector_sig+1) = 0;

    if (!_drive->Write( 0, 1, _mem.GetBuf())) {

        if( _drive->QueryLastNtStatus() == STATUS_MEDIA_WRITE_PROTECTED) {

            Message->Set(MSG_FMT_WRITE_PROTECTED_MEDIA);

        } else {

            Message->Set(MSG_UNUSABLE_DISK);

        }

        Message->Display("");
        return FALSE;
    }

    //
    // We wipe out any ntfs backup boot sector to prevent recovering
    // this as a ntfs partition
    //
    // Mount Rainier format, which is currently applied to CD-RW media 
    // and will be applied to DVD+RW media, allows a CD-RW media or 
    // DVD+RW media to be "Background low-level formatted". By writing 
    // to the end of the media, the benefits of the background format 
    // are lost. Besides Mt. Rainier Format drives cannot be formatted
    // with ntfs, so this operation is not performed.
    //
    if ( !( (_drive->QueryDriveType() == CdRomDrive) 
          && (DP_DRIVE::QueryMrwSupport(_drive->QueryDriveHandle())) ) ) {
        
        PBYTE   ZeroBuf = (PBYTE)MALLOC(_drive->QuerySectorSize());
    
        if (ZeroBuf == NULL) {
            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            return FALSE;
        }
        memset(ZeroBuf, 0, _drive->QuerySectorSize());
    
        if (!_drive->Write( _drive->QuerySectors()-1, 1, ZeroBuf )) {
            DebugPrintTrace(("UFAT: Unable to clean the NTFS mirror boot sector at %x\n", _drive->QuerySectors()-1));
        }

        FREE(ZeroBuf);
    }
    
    return TRUE;
}

BOOLEAN
REAL_FAT_SA::WriteNewFats (
    IN     PCNUMBER_SET BadSectors,
    IN OUT PULONG       BadClusters,
    IN     PMESSAGE     Message

)
/*++

Routine Description:

    This routine writes brand new copies of the fat to the disk in
    a piecemeal manner. As a side effect, this routine will also allocate
    the first available cluster to the FAT32 root directory.

Arguments:

    BadSectors  - Supplies the set of bad sectors on the volume.

    BadClusters - Supplies the location where this routine can return
        the number of bad clusters on the volume to the caller.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - Success.

    FALSE - Failure. Probably runs out of memory.

--*/
{
    ULONG    sectors;               //  Total number of sectors on the volume.
    BIG_INT  bad_sector;            //  The current bad sector under consideration.
    ULONG    i,j;                   //  Generic indices.
    ULONG    segment_size;          //  The size of a fat segment in number of sectors.
    ULONG    entries_per_segment;   //  Number of fat entries in each segment.
    ULONG    granularity_factor;    //  The number of sectors required to avoid
                                    //  having fat entries straddling on a
                                    //  segment boundary.
    ULONG    root_dir_strt_clus;    //  The first cluster of the FAT32 root directory.
    HMEM     segment_hmem;          //  Memory object for the fat segment.
    SECRUN   segment_secrun;        //  The run of sectors representing the current
                                    //  fat segment on the disk.
    ULONG    segment_offset;        //  The starting offset of the current fat segment
                                    //  on the volume in sectors.
    ULONG    segment_start_entry;   //  Number of fat entries in each fat segment.
    ULONG    segment_last_entry;    //  The last fat entry in the current segment
    ULONG    curr_bad_clus;         //  The current bad cluster.
    ULONG    prev_bad_clus;
    ULONG    sector_size;
    ULONG    mult_factor;           //  Number of "grains" per segment;
    ULONG    sectors_per_fat;
    ULONG    sectors_per_cluster;
    ULONG    num_of_fats;
    ULONG    num_of_fat_sec_remain; //  Number of sectors remain uninitialized in the current fat.
    ULONG    curr_segment_size;

    DebugAssert(_ft != INVALID_FATTYPE);


    sector_size = _drive->QuerySectorSize();
    sectors     = _drive->QuerySectors().GetLowPart();
    sectors_per_cluster = QuerySectorsPerCluster();
    sectors_per_fat = QuerySectorsPerFat();
    num_of_fats     = _sector_zero.Bpb.Fats;

    //
    //  The more generic way of figuring out the granularity factor
    //  is to use the formula: granularity factor = LCM(sector size in bits, LCM(fat entry size in bits , 8 (bits per byte))
    //  but since it is reasonable to assume that sector size in bytes is divisible by 4, the
    //  granularity factors are hard-coded.
    //

    switch (_ft) {
        case SMALL:
            granularity_factor = 3;
            break;
        case LARGE16:
            granularity_factor = 1;
            break;
        case LARGE32:
            granularity_factor = 1;
            break;
    }

    //
    //  We don't want to be a pig grabbing too much memory from the system
    //  even with virtual memory enabled so we limit ourselves to 512kb
    //  per fat segment.
    //

    mult_factor = min( (sectors_per_fat - 1) / granularity_factor + 1, ((1ul << 19) / sector_size) / granularity_factor);

    if(!segment_hmem.Initialize()){

        DebugPrintTrace(("Unable to initialize hmem object.\n"));
        return FALSE;

    }

    while (!segment_secrun.Initialize( &segment_hmem,
                                       _drive,
                                       _sector_zero.Bpb.ReservedSectors,
                                       mult_factor * granularity_factor)) {


        //
        //  Reduce the segment size util there is enough memory.
        //

        mult_factor /= 2;

        if (!mult_factor) {

            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            return FALSE;

        }

    }

    segment_size = min(sectors_per_fat, mult_factor * granularity_factor);

    //
    // Computes the number of fat entries per fat segment.
    //

    switch (_ft) {
        case SMALL:
            entries_per_segment = (segment_size * sector_size * 2) / 3;
            break;
        case LARGE16:
            entries_per_segment = (segment_size * sector_size) / 2;
            break;
        case LARGE32:
            entries_per_segment = (segment_size * sector_size) / 4;
            break;
    }

    //
    // Allocate the first available cluster for a FAT32 volume root directory.
    //

    if (_ft == LARGE32) {

        root_dir_strt_clus = _sector_zero.Bpb.RootDirStrtClus;

        //
        //  Scan for the first non-bad cluster for the root
        //  directory.
        //

        for (i = 0; i < BadSectors->QueryCardinality().GetLowPart(); i++) {
            bad_sector = BadSectors->QueryNumber(i);


            curr_bad_clus = MapSectorToCluster(bad_sector.GetLowPart(), sectors_per_cluster, _StartDataLbn);

            if (curr_bad_clus == _ClusterCount) {

                //
                //  All clusters are bad, there is no point to go on.
                //

                Message->Set(MSG_UNUSABLE_DISK);
                Message->Display("");
                return FALSE;
            }

            if (curr_bad_clus  == root_dir_strt_clus) {
                root_dir_strt_clus++;
            } else if (curr_bad_clus > root_dir_strt_clus) {
                break;
            }
        }
    }

    //
    //  Preparations for the FAT initialization progress meter.
    //

    ULONG percent = 0;
    ULONG    total_num_fat_sec;     //  Total number of FAT sectors.
    ULONG    num_sec_completed;     //  Number of fat sectors initialized.
    total_num_fat_sec = sectors_per_fat * _sector_zero.Bpb.Fats;
    Message->Set(MSG_FMT_INITIALIZING_FATS);
    Message->Display("");


#if 0 // Remove the extra progress meter.
    Message->Set(MSG_PERCENT_COMPLETE);
    Message->Display("%d", percent);
#endif

    //
    // For each fat...
    //

    *BadClusters = 0;
    for (i = 0; i < _sector_zero.Bpb.Fats; i++) {

        segment_last_entry  = entries_per_segment - 1;
        segment_start_entry = 0;
        segment_offset      = i * sectors_per_fat + _sector_zero.Bpb.ReservedSectors;
        curr_segment_size   = segment_size;
        num_of_fat_sec_remain = sectors_per_fat;
        prev_bad_clus         = 0;

        //
        // Initialize the first two entries of the first segment.
        //
        if (!segment_hmem.Initialize() ||
            !segment_secrun.Initialize( &segment_hmem,
                                        _drive,
                                        segment_offset,
                                        segment_size) ){

            //
            // Shouldn't fail
            //
            DebugPrintTrace(("Unable to initialize secrun object.\n"));
            return FALSE;
        }

        memset(segment_secrun.GetBuf(), 0, segment_size * sector_size);

        SetEarlyEntries( (PUCHAR)segment_secrun.GetBuf(),
                         _sector_zero.Bpb.Media,
                         _ft );

        j = 0;
        while (num_of_fat_sec_remain) {

            //
            //  Mark all the bad clusters in the current segment
            //  and keep track of the bad clusters counter.
            //

            for (;j < BadSectors->QueryCardinality().GetLowPart(); j++) {
                bad_sector = BadSectors->QueryNumber(j);

                curr_bad_clus = MapSectorToCluster( bad_sector.GetLowPart(), sectors_per_cluster, _StartDataLbn );

                if (curr_bad_clus > segment_last_entry) {
                    break; // j is not incremented
                } else if (curr_bad_clus > prev_bad_clus) {
                    prev_bad_clus = curr_bad_clus;
                    SetClusterBad( (PUCHAR)segment_secrun.GetBuf(),
                                   curr_bad_clus,
                                   segment_start_entry,
                                   _ft );
                    (*BadClusters)++;

                }
            }

            if ( _ft == LARGE32 ) {

                //
                //  Allocate the root cluster if it is in the
                //  current segment.
                //

                if (root_dir_strt_clus >= segment_start_entry &&
                    root_dir_strt_clus <= segment_last_entry ) {
                    SetEndOfChain( (PUCHAR)segment_secrun.GetBuf(),
                                   root_dir_strt_clus,
                                   segment_start_entry,
                                   _ft );

                }

            }

            //
            //  Write the current segment to the disk.
            //
            //  We don't care whether the write operation is successful
            //  or not because we can rely on the inherent redundancy
            //  of multiple fats.
            //

            if (!segment_secrun.Write()) {
                DebugPrintTrace(("Unable to write fat segment to disk.\n"));
            }

            //
            //  Decrement the number of fat sectors remain.
            //

            num_of_fat_sec_remain -= curr_segment_size;

#if 0   // No FAT initialization progress meter for now.
            num_sec_completed += curr_segment_size;
            percent = (num_sec_completed * 100) / total_num_fat_sec;

            Message->Display("%d", percent);
#endif
            //
            //  Increment the segment offset, start entry.
            //

            segment_offset += curr_segment_size;
            segment_start_entry += entries_per_segment;

            //
            //  Compute the new segment size.
            //
            curr_segment_size = min( segment_size, num_of_fat_sec_remain );

            //
            //  Increment the last segment entry.
            //
            segment_last_entry += entries_per_segment * curr_segment_size / segment_size;

            //
            //  Reintialize the secrun object to point to the next
            //  fat segment on the disk.
            //

            if (curr_segment_size) {
                if (!segment_hmem.Initialize() ||
                    !segment_secrun.Initialize( &segment_hmem,
                                                _drive,
                                                segment_offset,
                                                curr_segment_size )) {
                    //
                    //  Shouldn't fail.
                    //
                    DebugAbort("Unable to initialize secrun object.\n");
                }

                //
                //  Zero the secrun buffer for the next iteration.
                //

                memset(segment_secrun.GetBuf(), 0, curr_segment_size * sector_size);

            }
        }

    }

#if 0   // No FAT initialization progress meter for now.
    Message->Display("%d", 100);
#endif
    _sector_zero.Bpb.RootDirStrtClus = root_dir_strt_clus;
    (*BadClusters) /= _sector_zero.Bpb.Fats;
    return TRUE;
}


BOOLEAN
REAL_FAT_SA::WriteNewRootDirAndVolumeLabel (
    IN PCWSTRING    Label,
    IN PMESSAGE     Message
)
/*++

Routine Description:

    This routine initializes the root directory as an empty structure
    and then sets up the volume label if neccessary.

Arguments:

    Label   - Supplies the volume label that the user has specified
        at the command line.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - The operation is completed successfully.
    FALSE - This routine encounters unrecoverable errors while
            carrying out the operation.
--*/
{
    HMEM    root_dir_hmem;  //  Memory object for the root directory
    ULONG   root_size;      //  Size of the root directory.
    SECRUN  root_secrun;    //  A run of sectors that represents the
                            //  the root directory. Note that the
                            //  FAT32 root directory is initially one
                            //  cluster long which is a contagious run
                            //  of sectors. Note that we don't use the
                            //  the higher level FILEDIR and ROOTDIR
                            //  structures because we don't have the whole
                            //  fat in memory to initialize them.
    ULONG   root_dir_offset;//  The location of the root directory on the
                            //  disk.
    FAT_DIRENT label_dirent;//  Directory entry for the label.
    DSTRING    label;       //  Volume label.
    FAT_DIRENT ms_dirent;   //  Directory entry for the memory stick file.
    DSTRING    ms_name;     //  Volume label.
    PUCHAR     starting_entry;

    DebugAssert(_ft != INVALID_FATTYPE);

    if (!root_dir_hmem.Initialize()) {
        //
        //  Shouldn't fail.
        //
        DebugPrintTrace(("Failed to initialize HMEM object.\n"));
    }

    //
    //  Initialize the root directory secrun according to the Fat type.
    //

    if (_ft == LARGE32) {

        //
        //  Note that the following lines depends on the fact that
        //  WriteNewFats has set up _sector_zero.Bpb.RootDirStrtClus.
        //
        root_size = 0;
        root_dir_offset = QuerySectorFromCluster( _sector_zero.Bpb.RootDirStrtClus,
                                                  (PUCHAR)&root_size);


    } else {

        //
        //  Compute the sector offset of the FAT16/12 root directory.
        //

        root_dir_offset = _sector_zero.Bpb.ReservedSectors +
                          _sector_zero.Bpb.Fats * _sector_zero.Bpb.SectorsPerFat;

        //
        //  Compute the size of the FAT16/12 root direcctory.
        //

        root_size = (_sector_zero.Bpb.RootEntries * BytesPerDirent - 1) /
                    _drive->QuerySectorSize() + 1;


    }

    //
    //  Initialize and zero out the secrun buffer.
    //

    if (!root_secrun.Initialize( &root_dir_hmem,
                                 _drive,
                                 root_dir_offset,
                                 root_size)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    memset( root_secrun.GetBuf(), 0, root_size * _drive->QuerySectorSize());

    starting_entry = (PUCHAR)root_secrun.GetBuf();

    //
    //  Maybe someone should consider breaking the volume label
    //  code out as a separate function.
    //
    //
    //  Prompt the user for a volume label.
    //

    if (_drive->QueryMediaType() != F5_160_512 &&
        _drive->QueryMediaType() != F5_320_512) {

        if (Label) {

            if (!label.Initialize(Label)) {
                Message->Set(MSG_FMT_INIT_LABEL_FAILED);
                Message->Display("");
                return FALSE;
            }

        } else {
            switch (_drive->QueryRecommendedMediaType()) {
                case F5_360_512:
                case F5_320_512:
                case F5_180_512:
                case F5_160_512:
                    //
                    //  These disk drives are poor and can't
                    //  take the spin down without a verify
                    //  so don't prompt for the label.
                    //  This will avoid FORMAT failing.
                    //
                    label.Initialize();
                    break;

                default:
                    Message->Set(MSG_VOLUME_LABEL_PROMPT);
                    Message->Display("");
                    Message->QueryStringInput(&label);
                    break;

            }

        }

        for (;;) {

            if ( IsValidString(&label) &&
                 label.Strupr()) {
                if (label.QueryChCount()) {

                    //
                    //  Now set the volume label into the first directory
                    //  entry of the root directory. Note that the first
                    //  directory entry of the root directory must be free.
                    //

                    if (!(label_dirent.Initialize((PUCHAR)(root_secrun.GetBuf()), _ft))) {

                        //
                        //  Shouldn't fail.
                        //

                        DebugPrintTrace(("Failed to initialize directory entry for volume label.\n"));
                        return FALSE;

                    } else {

                        label_dirent.SetVolumeLabel();

                        if (!(label_dirent.SetLastWriteTime() &&  label_dirent.SetName(&label))) {

                            Message->Set(MSG_FMT_INIT_LABEL_FAILED);
                            Message->Display("");

                        } else {

                            starting_entry += BytesPerDirent;
                            break;
                        }
                    }

                } else {

                    break;

                }

            }

            Message->Set(MSG_INVALID_LABEL_CHARACTERS);
            Message->Display("");

            Message->Set(MSG_VOLUME_LABEL_PROMPT);
            Message->Display("");
            Message->QueryStringInput(&label);

        }
    }

    if (_drive->IsSonyMS() && !_drive->IsSonyMSFmtCmdCapable()) {

        if (!ms_name.Initialize(TEXT("MEMSTICK.IND"))) {
            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            return FALSE;
        }

        if (!ms_dirent.Initialize(starting_entry, _ft) ||
            !ms_dirent.SetLastWriteTime() ||
            !ms_dirent.SetName(&ms_name)) {

            Message->Set(MSG_FMT_UNABLE_TO_CREATE_MEMSTICK_FILE);
            Message->Display();
            return FALSE;
        }

        ms_dirent.SetHidden();
        ms_dirent.SetReadOnly();
    }

    //
    //  We can now write the root directory to the disk.
    //

    if (!root_secrun.Write()) {

        Message->Set(MSG_UNUSABLE_DISK);
        Message->Display("");
        return FALSE;

    }

    return TRUE;
}


BOOLEAN
REAL_FAT_SA::WriteNewBootArea (
    IN  PMESSAGE    Message
)
/*++

Routine Description:

    This routine initializes the boot area, which includes the boot code and
    the bpb, of a new volume.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    TRUE  - The operation is completed successfully.

    FALSE - Either the system rans out of memory or the boot area
            cannot be written to the disk.

++*/
{

    ULONG   boot_area_size; // Size of the whole boot area in bytes.
    ULONG   pseudo_sector_size;


    pseudo_sector_size = max(512, _drive->QuerySectorSize());
    boot_area_size = _sector_zero.Bpb.ReservedSectors * _drive->QuerySectorSize();

    //
    //  Call DosSaInit to make sure that the secrun buffer is
    //  large enough to hold the boot sector(s).
    //

    if(!_mem.Initialize() || !DosSaInit(&_mem, _drive, _sector_zero.Bpb.ReservedSectors, Message)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }


    //
    //  Zero out the reserved area
    //

    memset ( (PUCHAR)SECRUN::GetBuf(), 0,  boot_area_size );


    //
    //  We always assume that the sector size is at least 512 bytes when we copy the
    //  the boot code to the disk. If this is not the case, the boot code has
    //  to be smart enough to load itself up.
    //

    if  (_ft == LARGE32) {

        //
        //  We just copy the whole boot code (which includes the boot sector) directly
        //  into the secrun buffer and then pack the Bpb at a later time.
        //

        //
        //  Copy the first 1k of the bootcode into the secrun buffer.
        //

        memcpy ( SECRUN::GetBuf(), _bootcode, 512);
        memcpy ( (PUCHAR)SECRUN::GetBuf() + pseudo_sector_size, _bootcode + 512, 512);

        //
        //  Copy the last four byte signature onto sector 2 as well
        //
        memcpy ( (PUCHAR)SECRUN::GetBuf() + (3 * pseudo_sector_size - 4),
                 _bootcode + (3 * pseudo_sector_size - 4), 4 );
        //
        //  Copy the last 512 bytes of the boot code into the
        //  12th pseudo sector.
        //

        memcpy ( (PUCHAR)SECRUN::GetBuf() + (12 * pseudo_sector_size), _bootcode + 1024, 512 );


    } else {

        memcpy ( SECRUN::GetBuf(), _bootcode, 512 );

    }


    //
    //  Pack the bpb into the secrun buffer.
    //

    PackExtendedBios( &_sector_zero,
                      (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)(SECRUN::GetBuf()));


    //
    //  Backup the first 3 sectors to sectors 6-8 if the
    //  volume is a FAT32 volume.
    //

    if (_ft == LARGE32) {
        memcpy ((PUCHAR)SECRUN::GetBuf() + 6 * pseudo_sector_size, SECRUN::GetBuf(), 3 * pseudo_sector_size);
    }

    //
    //  Write the boot area to the disk.
    //

    if (!SECRUN::Write()) {
        Message->Set(MSG_UNUSABLE_DISK);
        Message->Display("");
        return FALSE;
    }
    return TRUE;
}

VOID
REAL_FAT_SA::PrintFormatReport (
    IN ULONG    BadClusters,
    IN PMESSAGE Message
    )
/*++

Routine Description:

    This routine prints an informative format report to the console.

Arguments:

    BadClustrers - Supplies the number of bad clusters on the disk.

    Message      - Supplies an outlet for messages.

Return Value:

    None.

--*/
{
    ::PrintFormatReport(BadClusters,
                        Message,
                        _drive->QuerySectorSize(),
                        QuerySectorsPerCluster()*_drive->QuerySectorSize(),
                        _ClusterCount,
                        _ft,
                        QueryVolId() ? (PUSHORT)&_sector_zero.SerialNumber : NULL);
}

VOID
REAL_FAT_SA::PrintFormatReport (
    IN PMESSAGE                         Message,
    IN PFILE_FS_SIZE_INFORMATION        FsSizeInfo,
    IN PFILE_FS_VOLUME_INFORMATION      FsVolInfo
    )
/*++

Routine Description:

    This routine prints an informative format report to the console.

Arguments:

    BadClustrers - Supplies the number of bad clusters on the disk.

    Message      - Supplies an outlet for messages.

Return Value:

    None.

--*/
{
    ULONG cluster_size = FsSizeInfo->SectorsPerAllocationUnit*FsSizeInfo->BytesPerSector;

    BIG_INT volume_size = FsSizeInfo->TotalAllocationUnits*cluster_size;

    FATTYPE volume_type = (volume_size < SMS_VOLSIZE_SMALL) ? SMALL : LARGE16;

    ::PrintFormatReport(0,
                        Message,
                        FsSizeInfo->BytesPerSector,
                        cluster_size,
                        FsSizeInfo->AvailableAllocationUnits.LowPart + FirstDiskCluster,
                        volume_type,
                        (PUSHORT)&FsVolInfo->VolumeSerialNumber);
}

VOID
PrintFormatReport (
    IN ULONG    BadClusters,
    IN PMESSAGE Message,
    IN BIG_INT  SectorSize,
    IN BIG_INT  ClusterSize,
    IN ULONG    ClusterCount,
    IN USHORT   FatType,
    IN PUSHORT  SerialNumber
    )
{

    BIG_INT   free_count;
    BIG_INT   cluster_size;
    BIG_INT   sector_size;
    PUSHORT   serial_number;
    BIG_INT   temp_big_int;
    ULONG     temp_ulong;
    MSGID     message_id;
    BOOLEAN   KSize;
    char      wdAstr[14];
    DSTRING   wdNum1;

    if (!wdNum1.Initialize("             ")) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return;
    }

    sector_size = SectorSize;
    cluster_size = ClusterSize;

    // Compute whether reporting size in bytes or kilobytes
    //
    // NOTE: The magic number 4095MB comes from Win9x's GUI SCANDISK utility
    //
    temp_big_int = cluster_size * (ClusterCount - FirstDiskCluster) ;
    if (temp_big_int.GetHighPart() || (temp_big_int.GetLowPart() > (4095ul*1024ul*1024ul))) {
        KSize = TRUE;
    } else {
        KSize = FALSE;
    }

    if (KSize) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
        message_id = MSG_TOTAL_KILOBYTES;
    } else {
        temp_ulong = temp_big_int.GetLowPart();
        message_id = MSG_TOTAL_DISK_SPACE;
    }

    Message->Set(message_id);

    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
    Message->Display("%ws", wdNum1.GetWSTR());

    if (BadClusters) {
        temp_big_int = cluster_size * BadClusters;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_CHK_NTFS_BAD_SECTORS_REPORT_IN_KB;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_BAD_SECTORS;
        }
        Message->Set(message_id);
        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
        Message->Display("%ws", wdNum1.GetWSTR());
    }

    free_count = ClusterCount;
    free_count -= BadClusters + FirstDiskCluster;

    if (FatType == LARGE32) {
        free_count -= 1;
    }

    temp_big_int = free_count * cluster_size.GetLowPart();
    if (KSize) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
        message_id = MSG_AVAILABLE_KILOBYTES;
    } else {
        temp_ulong = temp_big_int.GetLowPart();
        message_id = MSG_AVAILABLE_DISK_SPACE;
    }
    Message->Set(message_id);
    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_ALLOCATION_UNIT_SIZE);
    sprintf(wdAstr, "%u", cluster_size);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_AVAILABLE_ALLOCATION_UNITS);
    sprintf(wdAstr, "%u", free_count);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_BLANK_LINE);
    Message->Display();

    Message->Set(MSG_FMT_FAT_ENTRY_SIZE);
    switch(FatType) {

      case SMALL:
     Message->Display("%13u", 12ul);
         break;

      case LARGE16:
     Message->Display("%13u", 16ul);
         break;

      case LARGE32:
     Message->Display("%13u", 32ul);
         break;

      default:
         ;
    }

    if (SerialNumber) {
        Message->Set(MSG_BLANK_LINE);
        Message->Display();
        serial_number = SerialNumber;
        Message->Set(MSG_VOLUME_SERIAL_NUMBER);
        Message->Display("%04X%04X", serial_number[1], serial_number[0]);
    }

}

//
// The following routines are slightly modified versions of the
// methods found in fat.hxx
//

//
// Fat macros
//
#define FAT12_MASK      0x00000FFF
#define FAT16_MASK      0x0000FFFF
#define FAT32_MASK      0x0FFFFFFF
#define END_OF_CHAIN    0x0FFFFFFF
#define BAD_CLUSTER     0x0FFFFFF7

VOID
SetEarlyEntries(
    IN OUT PUCHAR   FatBuf,
    IN     UCHAR    MediaByte,
    IN     FATTYPE  FatType
    )
/*++

Routine Description:

    This routine sets the first two FAT entries as required by the
    FAT file system.  The first byte gets set to the media descriptor.
    The remaining bytes gets set to FF.

Arguments:

    FatBuf - Supplies a pointer to the first FAt segment.

    MediaByte   - Supplies the media byte for the volume.

    FatType - Supplies the FAT type.

Return Value:

    None.

--*/
{
    DebugAssert(FatType != INVALID_FATTYPE);

    FatBuf[0] = MediaByte;
    FatBuf[1] = FatBuf[2] = 0xFF;

    if (FatType != SMALL) {
        FatBuf[3] = 0xFF;
    }

    if (FatType == LARGE32) {
        FatBuf[3] = 0x0F;
        ((PULONG)FatBuf)[1] = FAT32_MASK;
    }
    return;
}

VOID
SetEndOfChain (
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    StartingEntry,
    IN     FATTYPE  FatType
    )
/*++

Routine Description:

    This routine sets the cluster ClusterNumber to the end of its cluster
    chain.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the cluster to be set to end of chain.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

    FatType - Supplies the Fat type.

Return Value:

    None.

--*/
{
    Set( FatBuf, ClusterNumber, END_OF_CHAIN, StartingEntry, FatType );
    return;
}

VOID
SetClusterBad(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    StartingEntry,
    IN     FATTYPE  FatType
    )
/*++

Routine Description:

    This routine sets the cluster ClusterNumber to bad on the FAT.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the cluster number to mark bad.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

    FatType - Supplies the Fat type.

Return Value:

    None.

--*/
{
    Set( FatBuf, ClusterNumber, BAD_CLUSTER, StartingEntry, FatType );
    return;
}


VOID
Set(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    Value,
    IN     ULONG    StartingEntry,
    IN     FATTYPE  FatType
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 12 bit, 16 bit or 32 bit FAT entry to Value.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the FAT entry to set.

    Value           - Supplies the value to set the FAT entry to.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

    FatType - Supplies the Fat type.

Return Value:

    None.

--*/
{

    DebugAssert(FatType != INVALID_FATTYPE);

    switch (FatType) {
        case SMALL:
            Set12( FatBuf, ClusterNumber, Value, StartingEntry );
            break;
        case LARGE16:
            Set16( FatBuf, ClusterNumber, Value, StartingEntry );
            break;
        case LARGE32:
            Set32( FatBuf, ClusterNumber, Value, StartingEntry );
            break;
    }
    return;
}

VOID
Set12(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    Value,
    IN     ULONG    StartingEntry
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 12 bit FAT entry to Value.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the FAT entry to set.

    Value           - Supplies the value to set the FAT entry to.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

Return Value:

    None.

--*/
{
    ULONG  n;
    UCHAR  value;

    Value = Value & FAT12_MASK;

    n = (ClusterNumber - StartingEntry) * 3;

    if (n%2) {
        FatBuf[n/2] = (FatBuf[n/2]&0x0F) | (((UCHAR)Value&0x000F)<<4);
        FatBuf[n/2 + 1] = (UCHAR)((Value&0x0FF0)>>4);
    } else {
        FatBuf[n/2] = (UCHAR)Value&0x00FF;
        FatBuf[n/2 + 1] = (FatBuf[n/2 + 1]&0xF0) | (UCHAR)((Value&0x0F00)>>8);
    }
    return;
}

VOID
Set16(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    Value,
    IN     ULONG    StartingEntry
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 16 bit FAT entry to Value.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the FAT entry to set.

    Value           - Supplies the value to set the FAT entry to.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

Return Value:

    None.

--*/
{
    Value = Value & FAT16_MASK;
    ((PUSHORT)FatBuf)[ClusterNumber - StartingEntry] = (USHORT)Value;
    return;
}

VOID
Set32(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    Value,
    IN     ULONG    StartingEntry
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 16 bit FAT entry to Value.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the FAT entry to set.

    Value           - Supplies the value to set the FAT entry to.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

Return Value:

    None.

--*/
{
    Value = Value & FAT32_MASK;
    ((PULONG)FatBuf)[ClusterNumber - StartingEntry] = Value;
    return;

}

BOOLEAN
REAL_FAT_SA::RecoverFile(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine runs through the clusters for the file described by
    'FileName' and takes out bad sectors.

Arguments:

    FullPathFileName    - Supplies a full path name of the file to recover.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if defined( _SETUP_LOADER_ )

    return FALSE;

#else // _SETUP_LOADER_


    HMEM        hmem;
    ULONG       clus;
    BOOLEAN     changes;
    PFATDIR     fatdir;
    BOOLEAN     need_delete;
    FAT_DIRENT  dirent;
    ULONG       old_file_size;
    ULONG       new_file_size;

    if ((clus = QueryFileStartingCluster(FullPathFileName,
                                         &hmem,
                                         &fatdir,
                                         &need_delete,
                                         &dirent)) == 1) {

       Message->Set(MSG_FILE_NOT_FOUND);
       Message->Display("%W", FullPathFileName);
       return FALSE;

    }

    if (clus == 0xFFFFFFFF) {

       Message->Set(MSG_CHK_NO_MEMORY);
       Message->Display("");
       return FALSE;

    }

    if (clus == 0) {

       Message->Set(MSG_FILE_NOT_FOUND);
       Message->Display("%W", FullPathFileName);
       return FALSE;

    }

    if (dirent.IsDirectory()) {
        old_file_size = _drive->QuerySectorSize()*
                        QuerySectorsPerCluster()*
                        _fat->QueryLengthOfChain(clus);
    } else {
        old_file_size = dirent.QueryFileSize();
    }

    if (!RecoverChain(&clus, &changes)) {

       Message->Set(MSG_CHK_NO_MEMORY);
       Message->Display("");
       return FALSE;

    }

    if (dirent.IsDirectory() || changes) {
       new_file_size = _drive->QuerySectorSize()*
                       QuerySectorsPerCluster()*
                       _fat->QueryLengthOfChain(clus);
    } else {
        new_file_size = old_file_size;
    }

    if (changes) {


// Autochk doesn't need control C handling.
#if !defined( _AUTOCHECK_ )

        // Disable contol-C handling and

        if (!KEYBOARD::EnableBreakHandling()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            return FALSE;
        }

#endif


        // Lock the drive in preparation for writes.
        if (!_drive->Lock()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            return FALSE;
        }

        dirent.SetStartingCluster(clus);

        dirent.SetFileSize(new_file_size);

        if (!fatdir->Write()) {
            return FALSE;
        }

        if (!Write(Message)) {
            return FALSE;
        }


// Autochk doesn't need control C handling.
#if !defined( _AUTOCHECK_ )

        KEYBOARD::DisableBreakHandling();

#endif


    }

    Message->Set(MSG_RECOV_BYTES_RECOVERED);
    Message->Display("%d%d", new_file_size, old_file_size);

    if (need_delete) {
        DELETE(fatdir);
    }

    return TRUE;

#endif // _SETUP_LOADER_
}


UFAT_EXPORT
BOOLEAN
REAL_FAT_SA::Read(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine reads the super area.  It will succeed if it can
    read the boot sector, the root directory, and at least one of
    the FATs.

    If the position of the internal FAT has not yet been determined,
    this routine will attempt to map it to a readable FAT on the disk.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    SECRUN      secrun;
    CONT_MEM    cmem;
    LBN         fat_lbn;
    ULONG       sector_size;
    PCHAR       fat_pos;
    SECTORCOUNT sec_per_fat;
    SECTORCOUNT num_res;
    ULONG       i;
    PFAT        fat;

    if (!SECRUN::Read()) {

        // Possibly cannot read one of the fats

        // Check to see if super area was allocated as formatted.
        if (QueryLength() <= _sec_per_boot) {

            Message->Set(MSG_CANT_READ_BOOT_SECTOR);
            Message->Display("");
            return FALSE;
        }

        // Check the boot sector.
        if (!secrun.Initialize(&_mem, _drive, 0, _sec_per_boot) ||
            !secrun.Read()) {

            // msliger We just failed to read this.  Why unpack it?

            // I don't see any reason to unpack the buffer either.
            // The buffer probably contains unknown data and unpacking
            // it won't do any good unless the intent is to corrupt
            // the _sector_zero.  If that's the case, why not set
            // it to zeros or 0xff or some other known pattern.
            // -DanielCh 3/8/2000

            // UnpackExtendedBios(&_sector_zero,
            //                    (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

            Message->Set(MSG_CANT_READ_BOOT_SECTOR);
            Message->Display("");
            return FALSE;
        }

        // t-raymak Personally, I think it is safer to re-unpack the bios here

        // I have asked RMak about the above comment but he does not remember
        // any of it and I see no reason to change anything right now.
        // -DanielCh 3/8/2000

        UnpackExtendedBios(&_sector_zero,
                           ((PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)secrun.GetBuf()));

        //
        // Note: Make sure that the fat is initialized
        // before the root directory.
        //

        // Check for one good FAT.
        if (_fat) {

            if (!_fat->Read()) {

                Message->Set(MSG_DISK_ERROR_READING_FAT);
                Message->Display("%d", 1 +
                                 (_fat->QueryStartLbn() - _sector_zero.Bpb.ReservedSectors)/
                                 _sector_zero.Bpb.SectorsPerFat);
                return FALSE;

            } else {

                Message->Set(MSG_SOME_FATS_UNREADABLE);
                Message->Display("");

            }

        } else {

            sector_size = _drive->QuerySectorSize();

            num_res = _sector_zero.Bpb.ReservedSectors;

            fat_pos = (PCHAR) SECRUN::GetBuf() + (num_res * sector_size);

            if ( 0 == _sector_zero.Bpb.SectorsPerFat ) {
                sec_per_fat = _sector_zero.Bpb.BigSectorsPerFat;
            } else {
                sec_per_fat = _sector_zero.Bpb.SectorsPerFat;
            }

            for (i = 0; i < QueryFats(); i++) {
                fat_lbn = num_res + (i * sec_per_fat);

                //
                // The FAT32 super area only has one in memory FAT which is always
                // at fat_pos, computed above, regardless of which FAT it happens to be.
                //
                // FAT12/16 drives have all of the FAT(s) in memory.
                //
                if (LARGE32 == _ft) {
                    if (!cmem.Initialize(fat_pos, sec_per_fat * sector_size)) {
                        Message->Set(MSG_FMT_NO_MEMORY);
                        Message->Display("");
                        return FALSE;
                    }
                } else if (!cmem.Initialize(fat_pos + i * sec_per_fat * sector_size,
                                            sec_per_fat * sector_size)) {
                    Message->Set(MSG_FMT_NO_MEMORY);
                    Message->Display("");
                    return FALSE;
                }

                if (!(fat = NEW FAT)) {
                    Message->Set(MSG_FMT_NO_MEMORY);
                    Message->Display("");
                    return FALSE;
                }

                if (!fat->Initialize(&cmem, _drive, fat_lbn, _ClusterCount)) {

                    return FALSE;
                }

                if (!fat->Read()) {

                    Message->Set(MSG_DISK_ERROR_READING_FAT);
                    Message->Display("%d", 1 +
                                     (fat->QueryStartLbn() - _sector_zero.Bpb.ReservedSectors)/
                                     _sector_zero.Bpb.SectorsPerFat);
                    DELETE(fat);
                }

                // Break out as soon as there is a good fat
                if (fat) {

                    _fat = fat;
                    break;

                }
            }

            if (!_fat) {
                Message->Set(MSG_CANT_READ_ANY_FAT);
                Message->Display("");

                return FALSE;
            }
        }

        // Check the root directory.
        if ( _dirF32 ) {

            //
            // If _hmem_F32 has not been allocated, _dirF32 has not been properly
            // initialized.
            //
            if (!_hmem_F32) {

                if (!(_hmem_F32 = NEW HMEM)) {

                    Message->Set(MSG_FMT_NO_MEMORY);
                    Message->Display("");
                    return FALSE;

                }

                if (!_hmem_F32->Initialize()) {
                    Destroy();
                    return FALSE;
                }

                if (!_dirF32->Initialize( _hmem_F32, _drive,
                                          this, _fat,
                                          _sector_zero.Bpb.RootDirStrtClus)) {
                    Destroy();
                    return FALSE;
                }

            }

            if (!_dirF32->Read()) {

                //
                //  Don't bail out immediately after a bad FAT32 root directory
                //  read. Chkdsk may be able to recover part of a damaged
                //  root directory
                //
                DebugPrintTrace(("The FAT32 root directory is damaged.\n"));
            }

        } else {
            if (!_dir || !_dir->Read()) {

                Message->Set(MSG_BAD_DIR_READ);
                Message->Display("%s","\\");
                return FALSE;
            }
        }

    } else {

        UnpackExtendedBios(&_sector_zero,
                           (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

        // Changed to allow FAT 32 passage, KLUDGE?
        if (!_fat && ( ( _dirF32 ) || (QueryLength() > _sec_per_boot))) {
            fat_lbn = _sector_zero.Bpb.ReservedSectors;
            sector_size = _drive->QuerySectorSize();

            //
            // In the case where the SECRUN::Read works for the whole superarea we
            //  simply initialize _fat to point at the first FAT.
            //
            if (!cmem.Initialize((PCHAR) SECRUN::GetBuf() + fat_lbn*sector_size,
                                 QuerySectorsPerFat()*sector_size)) {

                Message->Set(MSG_FMT_NO_MEMORY);
                Message->Display("");
                return FALSE;
            }

            if (!(_fat = NEW FAT)) {

                Message->Set(MSG_FMT_NO_MEMORY);
                Message->Display("");
                return FALSE;
            }

            if (!_fat->Initialize(&cmem, _drive, fat_lbn, _ClusterCount,
                                  QuerySectorsPerFat())) {

                Message->Set(MSG_FMT_NO_MEMORY);
                Message->Display("");
                return FALSE;
            }

            // Complete "FAT_32_Root" FILEDIR initialization after NEW FAT above
            if (LARGE32 == _ft) {

                if (!(_hmem_F32 = NEW HMEM)) {
                    Message->Set(MSG_FMT_NO_MEMORY);
                    Message->Display("");
                    return FALSE;
                }
                // This is part two of init above, we needed _fat defined first !!!!
                if (!_hmem_F32->Initialize()) {

                    Destroy();
                    return FALSE;

                }
                // This is part two of init above, we needed _fat defined first !!!!
                if (!_dirF32->Initialize( _hmem_F32, _drive,
                                          this, _fat,
                                          _sector_zero.Bpb.RootDirStrtClus)) {
                    //
                    //  Don't bail out immediately after a bad FAT32 root directory
                    //  initialization. Chkdsk may be able to recover part of a damaged
                    //  root directory
                    //
                    DebugPrintTrace(("The FAT32 root directory is damaged.\n"));
                    return TRUE;
                }

                if (!_dirF32->Read()) {
                    //
                    //  Don't bail out immediately after a bad FAT32 root directory
                    //  read. Chkdsk may be able to recover part of a damaged
                    //  root directory
                    //
                    DebugPrintTrace(("The FAT32 root directory is damaged.\n"));
                }
            }
        }
    }
    return TRUE;
}


BOOLEAN
REAL_FAT_SA::Write(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine writes the super area.  It will succeed if it can
    write the boot sector, the root directory, and at least one of
    the FATs.

    This routine will duplicate the working FAT to all other FATs
    in the super area.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    SECRUN  secrun;
    CONT_MEM    cmem;
    ULONG   i;
    ULONG   fat_size;
    ULONG   sector_size;
    SECTORCOUNT num_res;
    SECTORCOUNT sec_per_fat;
    BOOLEAN FATok;


    // Dup the first FAT in the in memory superarea into all of the other
    // FATs in the in memory super area.
    if (_ft != LARGE32) {
    DupFats();
    }

    PackExtendedBios(&_sector_zero,
        (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

    // Writing the boot sector.
    if (!SECRUN::Write()) {

       if (!_fat || (!_dir && !_dirF32)) {

          Message->Set(MSG_CANT_WRITE_BOOT_SECTOR);
          Message->Display("");
          return FALSE;

       }

       PackExtendedBios(&_sector_zero,
                        (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

       // Writing the bootstrap code
       if (!secrun.Initialize(&_mem, _drive, 0, _sec_per_boot) ||
           !secrun.Write()) {

          Message->Set(MSG_CANT_WRITE_BOOT_SECTOR);
          Message->Display("");
          return FALSE;
       }


       // Writing the root directory
       if ( !_dir ) {

          if (!_dirF32->Write()) {

             Message->Set(MSG_CANT_WRITE_ROOT_DIR);
             Message->Display("");
             return FALSE;
          }

       } else {

          if (!_dir->Write()) {

             Message->Set(MSG_CANT_WRITE_ROOT_DIR);
             Message->Display("");
             return FALSE;
          }
       }

       // Write the fat(s).

       FATok = FALSE;

       if (_fat->Write()) {
       FATok = TRUE;
       }
       sector_size = _drive->QuerySectorSize();
       num_res = _sector_zero.Bpb.ReservedSectors;
       sec_per_fat = QuerySectorsPerFat();
       fat_size = sec_per_fat*sector_size;
       for (i = 0; i < QueryFats(); i++) {
       if (num_res + (i*sec_per_fat) != _fat->QueryStartLbn()) {


        if(cmem.Initialize((PCHAR)_fat->GetBuf(),fat_size) &&
           secrun.Initialize(&cmem, _drive, num_res + (i*sec_per_fat), sec_per_fat) &&
           secrun.Write()) {

            FATok = TRUE;
        }
       }
       }
       if (!FATok) {
          Message->Set(MSG_BAD_FAT_WRITE);
          Message->Display("");
          return FALSE;
       } else {
          Message->Set(MSG_SOME_FATS_UNWRITABLE);
          Message->Display("");
       }
    } else if (_ft == LARGE32) {
    // SECRUN::Write doesn't write all of the FATs or the FAT32 root directory.

    // Write out the other FATs. Note that any failures on these writes
    // are basically ignored (except for MSG_SOME_FATS_UNWRITABLE) since
    // we already have the first FAT fully written out via SECRUN::Write

    FATok = TRUE;
    sector_size = _drive->QuerySectorSize();
    num_res = _sector_zero.Bpb.ReservedSectors;
    sec_per_fat = QuerySectorsPerFat();
    fat_size = sec_per_fat*sector_size;
    // NOTE that following loop starts at 1 not 0 as FAT 0 is already written out
    for (i = 1; i < QueryFats(); i++) {
        if(!cmem.Initialize((PCHAR) SECRUN::GetBuf() + (num_res * sector_size),fat_size) ||
           !secrun.Initialize(&cmem, _drive, num_res + (i*sec_per_fat), sec_per_fat) ||
           !secrun.Write()) {

            FATok = FALSE;
        }
    }
    if (!FATok) {
        Message->Set(MSG_SOME_FATS_UNWRITABLE);
        Message->Display("");
    }

    // Write out the FAT32 root directory

    if(_dirF32) {
        if (!_dirF32->Write()) {
        Message->Set(MSG_CANT_WRITE_ROOT_DIR);
        Message->Display("");
        return FALSE;
        }
    }
    }

    return TRUE;
}


UFAT_EXPORT
SECTORCOUNT
REAL_FAT_SA::QueryFreeSectors(
    ) CONST
/*++

Routine Description:

    This routine computes the number of unused sectors on disk.

Arguments:

    None.

Return Value:

    The number of free sectors on disk.

--*/
{
    if (!_fat) {
        DebugPrintTrace(("UFAT: Failure to QueryFreeSectors in REAL_FAT_SA\n"));
        return 0;
    }

    return _fat->QueryFreeClusters()*QuerySectorsPerCluster();
}


FATTYPE
REAL_FAT_SA::QueryFatType(
    ) CONST
/*++

Routine Description:

    This routine computes the FATTYPE of the FAT for this volume.

Arguments:

    None.

Return Value:

    The FATTYPE for the FAT.

--*/
{
    return _ft;
}


VOID
REAL_FAT_SA::Destroy(
    )
/*++

Routine Description:

    This routine cleans up the local data in the fat super area.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE(_fat);
    DELETE(_dir);
    DELETE(_dirF32);
    _StartDataLbn = 0;
    _ClusterCount = 0;
    _sysid = SYSID_NONE;
    _data_aligned = FALSE;
    _AdditionalReservedSectors = MAXULONG;
}

BOOLEAN
REAL_FAT_SA::DupFats(
    )
/*++

Routine Description:

    This routine will duplicate the current FAT to all other FATs
    in the IN MEMORY super area.

    DO NOT call this on FAT32 drives since there is only one in memory FAT
    on FAT32 drives!!!!!!!

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       i;
    PCHAR       fat_pos;
    ULONG       fat_size;
    ULONG       sector_size;
    SECTORCOUNT num_res;
    SECTORCOUNT sec_per_fat;

    num_res = _sector_zero.Bpb.ReservedSectors;
    if (!_fat || !_drive || !(sector_size = _drive->QuerySectorSize())) {
        return FALSE;
    }

    if ( 0 == _sector_zero.Bpb.SectorsPerFat ) {
           sec_per_fat = _sector_zero.Bpb.BigSectorsPerFat;
    } else {
        sec_per_fat = _sector_zero.Bpb.SectorsPerFat;
    }
    fat_size = sec_per_fat*sector_size;
    fat_pos = (PCHAR) SECRUN::GetBuf() + num_res*sector_size;

    for (i = 0; i < QueryFats(); i++) {
        if (num_res + i*sec_per_fat != _fat->QueryStartLbn()) {
            memcpy(fat_pos + i*fat_size, _fat->GetBuf(), (UINT) fat_size);
        }
    }

    return TRUE;
}


LBN
REAL_FAT_SA::ComputeStartDataLbn(
    ) CONST
/*++

Routine Description:

    This routine computes the first LBN of the data part of a FAT disk.
    In other words, the LBN of cluster 2.

Arguments:

    None.

Return Value:

    The LBN of the start of data.

--*/
{

    if ( 0 == _sector_zero.Bpb.SectorsPerFat ) {

       return  _sector_zero.Bpb.ReservedSectors +
               _sector_zero.Bpb.Fats*_sector_zero.Bpb.BigSectorsPerFat;
    } else {

       return  _sector_zero.Bpb.ReservedSectors +
               _sector_zero.Bpb.Fats*_sector_zero.Bpb.SectorsPerFat +
               (_sector_zero.Bpb.RootEntries*BytesPerDirent - 1)/
               _drive->QuerySectorSize() + 1;
    }

}


#if !defined(_SETUP_LOADER_)

ULONG
REAL_FAT_SA::ComputeRootEntries(
    ) CONST
/*++

Routine Description:

    This routine uses the size of the disk and a standard table in
    order to compute the required number of root directory entries.

Arguments:

    None.

Return Value:

    The required number of root directory entries.

--*/
{

    if (_ft == LARGE32) {
        return 0;
    }

    switch (_drive->QueryMediaType()) {

        case F3_720_512:
        case F5_360_512:
        case F5_320_512:
        case F5_320_1024:
        case F5_180_512:
        case F5_160_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_720_512:
        case F5_640_512:
        case F3_640_512:
#endif
            return 112;

        case F5_1Pt2_512:
        case F3_1Pt44_512:
#if defined(FE_SB) && defined(_X86_)
        case F3_1Pt2_512:
#endif
            return 224;

        case F3_2Pt88_512:
        case F3_20Pt8_512:
            return 240;

#if defined(FE_SB) && defined(_X86_)
        case F5_1Pt23_1024:
        case F3_1Pt23_1024:
             return 192;

        case F8_256_128:
            return 68;
#endif
    }

    return 512;
}


USHORT
REAL_FAT_SA::ComputeSecClus(
    IN  SECTORCOUNT Sectors,
    IN  FATTYPE     FatType,
#if defined(FE_SB) && defined(_X86_)
    IN  MEDIA_TYPE  MediaType,
    IN  ULONG       SectorSize
#else
    IN  MEDIA_TYPE  MediaType
#endif
    )
/*++

Routine Description:

    This routine computes the number of sectors per cluster required
    based on the actual number of sectors.

Arguments:

    Sectors     - Supplies the total number of sectors on the disk.
    FatType     - Supplies the type of FAT.
    MediaType   - Supplies the type of the media.

Return Value:

    The required number of sectors per cluster.

--*/
{
    USHORT      sec_per_clus;
    SECTORCOUNT threshold;

    if (FatType == LARGE32) {

        if (Sectors >= 64*1024*1024) {
            sec_per_clus = 64;                  /* over 32GB -> 32K */
        } else if (Sectors >= 32*1024*1024) {
            sec_per_clus = 32;                  /* up to 32GB -> 16K */
        } else if (Sectors >= 16*1024*1024) {
            sec_per_clus = 16;                  /* up to 16GB -> 8K */
        } else {
            sec_per_clus = 8;                   /* up to 8GB -> 4K */
        }

        return sec_per_clus;
    }

    if (FatType == SMALL) {
        threshold = MIN_CLUS_BIG;
        sec_per_clus = 1;
    } else {
        threshold = MAX_CLUS_BIG;
        sec_per_clus = 1;
    }

    while (Sectors >= threshold) {
        sec_per_clus *= 2;
        threshold *= 2;
    }

    switch (MediaType) {

        case F5_320_512:
        case F5_360_512:
        case F3_720_512:
        case F3_2Pt88_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_640_512:
        case F3_640_512:
        case F5_720_512:
#endif
            sec_per_clus = 2;
            break;

        case F3_20Pt8_512:
#if defined(FE_SB)
        case F3_128Mb_512:
#if defined(_X86_)
        case F8_256_128:
#endif
#endif
            sec_per_clus = 4;
            break;

#if defined(FE_SB)
        case F3_230Mb_512:
            sec_per_clus = 8;
            break;
#endif

        default:
            break;

    }

    return sec_per_clus;
}

#endif // _SETUP_LOADER_

extern VOID DoInsufMemory(VOID);

BOOLEAN
REAL_FAT_SA::RecoverChain(
    IN OUT  PULONG      StartingCluster,
    OUT     PBOOLEAN    ChangesMade,
    IN      ULONG       EndingCluster,
    IN      BOOLEAN     Replace,
    IN OUT  PBITVECTOR  FatBitMap
    )
/*++

Routine Description:

    This routine will recover the chain beginning with 'StartingCluster'
    in the following way.  It will verify the readability of every cluster
    until it reaches 'EndingCluster' or the end of the chain.  If a cluster
    is not readable then 'ChangesMade' will be set to TRUE, the FAT will
    be marked to indicate that the cluster is bad, and the cluster will be
    taken out of the chain.  Additionally, if 'Replace' is set to TRUE,
    the FAT will be scanned for a readable free cluster to replace the lost
    ones with.  Failure to accomplish this will result in a return value
    of FALSE being returned.

    If the very first cluster of the chain was bad then then
    'StartingCluster' will be set with the new starting cluster of the
    chain even if this starting cluster is past 'EndingCluster'.  If the
    chain is left empty then 'StartingCluster' will be set to zero.

Arguments:

    StartingCluster - Supplies the first cluster of the chain to recover.
    ChangesMade     - Returns TRUE if changes to the chain were made.
    EndingCluster   - Supplies the final cluster to recover.
    Replace         - Supplies whether or not to replace bad clusters with
                      new ones.
    FatBitmap       - Supplies the volume bitmap if it needs to be updated.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST           max_transfer_bytes  = 65536;
    HMEM            hmem;
    CLUSTER_CHAIN   cluster;
    ULONG           clus, prev;
    ULONG           replacement;
    BOOLEAN         finished;
    ULONG           max_clusters;
    ULONG           chain_length;
    ULONG           i;

    DebugAssert(_fat);
    DebugAssert(ChangesMade);
    DebugAssert(StartingCluster);

    if (!hmem.Initialize()) {
    DoInsufMemory();
        return FALSE;
    }

    *ChangesMade = FALSE;
    finished = TRUE;

    max_clusters = (USHORT)(max_transfer_bytes /
                   QuerySectorsPerCluster() /
                   _drive->QuerySectorSize());

    if (!max_clusters) {
        max_clusters = 1;
    }

    chain_length = _fat->QueryLengthOfChain(*StartingCluster);

    for (i = 0; i < chain_length; i += max_clusters) {

        if (!cluster.Initialize(&hmem, _drive, this, _fat,
                                _fat->QueryNthCluster(*StartingCluster, i),
                                min(max_clusters, chain_length - i))) {

            DebugPrintTrace(("Unable to initialize cluster object. i = %d\n, chain_length = %d\n, max_clusters = %d\n", i, chain_length, max_clusters));
            return FALSE;
        }

        if (!cluster.Read()) {

            // Since the quick analysis detected some errors do the slow
            // analysis to pinpoint them.

            finished = FALSE;
            break;
        }
    }

    prev = 0;
    clus = *StartingCluster;

    if (!clus) {
        return TRUE;
    }

    while (!finished) {
        if (!cluster.Initialize(&hmem, _drive, this, _fat, clus, 1)) {
            DebugPrintTrace(("Unable to initialize cluster object.1\n"));
            return FALSE;
        }

        finished = (BOOLEAN) (_fat->IsEndOfChain(clus) || clus == EndingCluster);

        if (!cluster.Read()) {

            // There is a bad cluster so indicate that changes will be made.

            *ChangesMade = TRUE;

            // Take it out of the bitmap if desired

            if (FatBitMap) {
                FatBitMap->ResetBit(clus);
            }

            // Take the bad cluster out of the cluster chain.

            if (prev) {

               _fat->SetEntry(prev, _fat->QueryEntry(clus));
               _fat->SetClusterBad(clus);
               clus = prev;

            } else {

               *StartingCluster = _fat->IsEndOfChain(clus) ? 0 :
                                  _fat->QueryEntry(clus);
               _fat->SetClusterBad(clus);
               clus = 0;

            }


            // If a replacement cluster is wanted then get one.

            if (Replace) {

                if (!(replacement = _fat->AllocChain(1))) {
                    DebugPrintTrace(("Unable to allocate replacement cluster.\n"));
                    return FALSE;
                }


                // Zero fill and write the replacement.

                cluster.Initialize(&hmem, _drive, this, _fat, replacement, 1);
                memset(hmem.GetBuf(), 0, (UINT) hmem.QuerySize());
                cluster.Write();


                if (finished) {
                    EndingCluster = replacement;
                    finished = FALSE;
                }


                // Link in the replacement.

                if (prev) {
                    _fat->InsertChain(replacement, replacement, prev);
                } else {
                    if (*StartingCluster) {
                        _fat->SetEntry(replacement, *StartingCluster);
                    }
                    *StartingCluster = replacement;
                }

                // Mark it in the bitmap if desired

                if (FatBitMap) {
                    DebugAssert(FatBitMap->IsBitSet(replacement) == 0);
                    FatBitMap->SetBit(replacement);
                }
            }
        }

        prev = clus;
        clus = clus ? _fat->QueryEntry(clus) : *StartingCluster;
    }

    return TRUE;
}

ULONG
REAL_FAT_SA::QueryFat32RootDirStartingCluster (
    )
/*++

Routine Description:

    This routine queries the root directory starting cluster from the FAT32 bpb.

Arguments:

    None.

Return Value:

    ULONG - The FAT32 root directory starting cluster.

--*/

{

    // Only FAT32 related code should call this function.
    DebugAssert(_ft == LARGE32);

    return _sector_zero.Bpb.RootDirStrtClus;

}


VOID
REAL_FAT_SA::SetFat32RootDirStartingCluster (
    IN  ULONG   RootCluster
    )
/*++

Routine Description:

    This routine sets the root directory starting cluster in the FAT32 bpb.

Arguments:

    RootCluster - Supplies the new root directory starting cluster.

Return Value:

    None.

--*/

{

    // Only FAT32 related code should call this function.
    DebugAssert(_ft == LARGE32);

    _sector_zero.Bpb.RootDirStrtClus = RootCluster;

}

ULONG
REAL_FAT_SA::SecPerBoot()
{
    return _sec_per_boot;
}

BOOLEAN
REAL_FAT_SA::SetBootCode(
    )
/*++

Routine Description:

    This routine sets the boot code in the super area.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _sector_zero.IntelNearJumpCommand = 0xEB;
    if (_ft == LARGE32)
    _sector_zero.BootStrapJumpOffset  = 0x9058;
    else
    _sector_zero.BootStrapJumpOffset  = 0x903C;
    SetBootSignature();
    return TRUE;
}

BOOLEAN
REAL_FAT_SA::SetPhysicalDriveType(
    IN  PHYSTYPE    PhysType
    )
/*++

Routine Description:

    This routine sets the physical drive type in the super area.

Arguments:

    PhysType    - Supplies the physical drive type.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _sector_zero.PhysicalDrive = (UCHAR)PhysType;
    return TRUE;
}

INLINE
BOOLEAN
REAL_FAT_SA::SetOemData(
    )
/*++

Routine Description:

    This routine sets the OEM data in the super area.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    memcpy( (void*)_sector_zero.OemData, (void*)OEMTEXT, OEMTEXTLENGTH);
    return TRUE;
}

BOOLEAN
REAL_FAT_SA::SetSignature(
    )
/*++

Routine Description:

    This routine sets the sector zero signature in the super area.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (!_sector_sig) {
        DebugPrintTrace(("UFAT: Failure to SetSignature in REAL_FAT_SA\n"));
        return FALSE;
    }

    *_sector_sig = sigSUPERSEC1;
    *(_sector_sig + 1) = sigSUPERSEC2;

    return TRUE;
}

BOOLEAN
REAL_FAT_SA::VerifyBootSector(
    )
/*++

Routine Description:

    This routine checks key parts of sector 0 to insure that the data
    being examined is indeed a zero sector.

Arguments:

    None.

Return Value:

    FALSE   - Invalid sector zero.
    TRUE    - Valid sector zero.

--*/
{
    PUCHAR  p;

// We don't check for 55 AA anymore because we have reason to
// believe that there are versions of FORMAT out there that
// don't put it down.

#if 0
    if (!IsFormatted()) {
        return FALSE;
    }
#endif

    p = (PUCHAR) GetBuf();

#if defined(FE_SB) &&  defined(_X86_)
    return p[0] == 0x49 ||  /* FMR */
           p[0] == 0xE9 ||
          (p[0] == 0xEB && p[2] == 0x90);
#else
    return p[0] == 0xE9 || (p[0] == 0xEB && p[2] == 0x90);
#endif
}

ULONG
REAL_FAT_SA::QuerySectorFromCluster(
    IN  ULONG   Cluster,
    OUT PUCHAR  NumSectors
    )
{
    if (NULL != NumSectors) {
        *NumSectors = (UCHAR)QuerySectorsPerCluster();
    }

    return (Cluster - FirstDiskCluster)*QuerySectorsPerCluster() +
           QueryStartDataLbn();
}

BOOLEAN
REAL_FAT_SA::IsClusterCompressed(
    IN  ULONG
    ) CONST
{
    return FALSE;
}

VOID
REAL_FAT_SA::SetClusterCompressed(
    IN  ULONG,
    IN  BOOLEAN fCompressed
    )
{
    if (fCompressed) {
        DebugAssert("REAL_FAT_SA shouldn't have compressed clusters.");
    }
}

UCHAR
REAL_FAT_SA::QuerySectorsRequiredForPlainData(
        IN      ULONG
        )
{
    DebugAssert("REAL_FAT_SA didn't expect call to QuerySectorsRequiredForPlainData\n");
    return 0;

}

BOOLEAN
REAL_FAT_SA::VerifyFatExtensions(
    FIX_LEVEL, PMESSAGE, PBOOLEAN
    )
{
    //
    // We have no fat extensions, we're real.
    //

    return TRUE;
}

BOOLEAN
REAL_FAT_SA::CheckSectorHeapAllocation(
    FIX_LEVEL, PMESSAGE, PBOOLEAN
    )
{
    //
    // We have no sector heap, we're real.
    //

    return TRUE;
}

BOOLEAN
REAL_FAT_SA::AllocateClusterData(
    ULONG, UCHAR, BOOLEAN, UCHAR
    )
{
    DebugAbort("Didn't expect REAL_FAT_SA::AllocateClusterData to be "
        "called.");
    return FALSE;
}

BOOLEAN
REAL_FAT_SA::FreeClusterData(
    ULONG
    )
{
    DebugAbort("Didn't expect REAL_FAT_SA::FreeClusterData to be "
        "called.");
    return FALSE;
}

BYTE
REAL_FAT_SA::QueryVolumeFlags(
    ) CONST
/*++

Routine Description:

    This routine returns the volume flags byte from the bpb.

Arguments:

    None.

Return Value:

    The flags.

--*/
{
    ULONG clus1;
    BYTE  CurrHd;

    if(_fat) {
    clus1 = _fat->QueryEntry(1);
    } else {
    clus1 = 0x0FFFFFFF;
    }
    CurrHd = _sector_zero.CurrentHead;

    if (_ft == LARGE32) {
        if((!(CurrHd & FAT_BPB_RESERVED_DIRTY)) && (!(clus1 & CLUS1CLNSHUTDWNFAT32))) {
            CurrHd |= FAT_BPB_RESERVED_DIRTY;
        }
        if((!(CurrHd & FAT_BPB_RESERVED_TEST_SURFACE)) && (!(clus1 & CLUS1NOHRDERRFAT32))) {
            CurrHd |= FAT_BPB_RESERVED_TEST_SURFACE;
        }
    } else if (_ft == LARGE16) {
        if((!(CurrHd & FAT_BPB_RESERVED_DIRTY)) && (!(clus1 & CLUS1CLNSHUTDWNFAT16))) {
            CurrHd |= FAT_BPB_RESERVED_DIRTY;
        }
        if((!(CurrHd & FAT_BPB_RESERVED_TEST_SURFACE)) && (!(clus1 & CLUS1NOHRDERRFAT16))) {
            CurrHd |= FAT_BPB_RESERVED_TEST_SURFACE;
        }
    }
    return(CurrHd);
}

VOID
REAL_FAT_SA::SetVolumeFlags(
    BYTE Flags,
    BOOLEAN ResetFlags
    )
/*++

Routine Description:

    This routine sets the volume flags in the bpb.

Arguments:

    Flags       -- flags to set or clear
    ResetFlags  -- if true, Flags are cleared instead of set

Return Value:

    None.

--*/
{
    ULONG clus1;

    if (ResetFlags) {
        _sector_zero.CurrentHead &= ~Flags;
        if(_fat) {
            clus1 = _fat->QueryEntry(1);
            if (_ft == LARGE32) {
            if(Flags & FAT_BPB_RESERVED_DIRTY) {
                clus1 |= CLUS1CLNSHUTDWNFAT32;
            }
            if(Flags & FAT_BPB_RESERVED_TEST_SURFACE) {
                clus1 |= CLUS1NOHRDERRFAT32;
            }
            } else if (_ft == LARGE16) {
            if(Flags & FAT_BPB_RESERVED_DIRTY) {
                clus1 |= CLUS1CLNSHUTDWNFAT16;
            }
            if(Flags & FAT_BPB_RESERVED_TEST_SURFACE) {
                clus1 |= CLUS1NOHRDERRFAT16;
            }
            }
            _fat->SetEntry(1, clus1);
        }
    } else {
        _sector_zero.CurrentHead |= Flags;
        if(_fat) {
            clus1 = _fat->QueryEntry(1);
            if (_ft == LARGE32) {
            if(Flags & FAT_BPB_RESERVED_DIRTY) {
                clus1 &= ~CLUS1CLNSHUTDWNFAT32;
            }
            if(Flags & FAT_BPB_RESERVED_TEST_SURFACE) {
                clus1 &= ~CLUS1NOHRDERRFAT32;
            }
            } else if (_ft == LARGE16) {
            if(Flags & FAT_BPB_RESERVED_DIRTY) {
                clus1 &= ~CLUS1CLNSHUTDWNFAT16;
            }
            if(Flags & FAT_BPB_RESERVED_TEST_SURFACE) {
                clus1 &= ~CLUS1NOHRDERRFAT16;
            }
            }
            _fat->SetEntry(1, clus1);
        }
    }
}

BOOLEAN
REAL_FAT_SA::IsFileContiguous(
    IN      ULONG       StartingCluster
    ) CONST
/*++

Routine Description:

    This routine computes the number of contiguous blocks for the given
    starting cluster.  If the file has only one block then the file is contiguous and
    this function returns TRUE.  Otherwise this function returns FALSE.

Arguments:

    StartingClustere    - Supplies the starting cluster of the file.

Return Value:

    FALSE   - The file is not contiguous.
    TRUE    - The file is contiguous.

--*/
{
    ULONG   num_blocks;

    DebugAssert(_fat);
    DebugAssert(_fat->IsInRange(StartingCluster));

    if (_fat == NULL || !_fat->IsInRange(StartingCluster)) {
        return FALSE;
    }

    for (num_blocks = 1; ; num_blocks++) {
        while (!_fat->IsEndOfChain(StartingCluster) &&
               (ULONG)(StartingCluster + 1) == _fat->QueryEntry(StartingCluster)) {
            StartingCluster++;
        }
        if (_fat->IsEndOfChain(StartingCluster)) {
            return TRUE;
        }
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\inc\cstring.h ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

	wstring.h

Abstract:

	This module contains the prototypes for the wide character
	C-runtime support. Since there is no C-runtime support for
	wide characters, the functions here are wrappers to the
	single-byte counterparts

Author:

	Ramon San Andres (Ramonsa)	07-Jun-1991

Revision History:

--*/

typedef char	wchar;
typedef WCHAR	wchar_t;
typedef size_t	wsize_t;

long	watol( const wchar *);
wchar * wcschr(const wchar *, int);
wchar * wcslwr(wchar *);
wchar * wcsrchr(const wchar *, int);
wchar * wcsupr(wchar *);
wsize_t wcscspn(const wchar *, const wchar *);
wsize_t wcsspn(const wchar *, const wchar *);
wchar * wcsstr(const wchar *, const wchar *);
int 	wctomb( char *s, wchar_t wchar );
int 	mbtowc(wchar_t *pwc, const char *s, size_t n);
wchar_t towupper( wchar_t wc);

INLINE
long
watol(
	const wchar * p
	)
{
	return atol( (char *)p );
}


INLINE
wchar *
wcschr (
	const wchar * p,
	int 		  c
	)
{
	return (wchar *)strchr( (char *)p, c);
}


INLINE
wchar *
wcslwr (
	wchar * p
	)
{
	return (wchar *)strlwr( (char *)p );
}

INLINE
wchar *
wcsrchr (
	const wchar * p,
	int 		  c
	)
{
	return (char *)strrchr( (char *)p, c);
}

INLINE
wchar *
wcsupr (
	wchar * p
	)
{
	return (char *)strupr( (char *)p );
}


INLINE
wsize_t
wcscspn (
	const wchar *p1,
	const wchar *p2
	)
{

	return (wsize_t)strcspn( (char *)p1, (char *)p2);

}

INLINE
wsize_t
wcsspn (
	const wchar *p1,
	const wchar *p2
	)
{

	return (wsize_t)strspn( (char *)p1, (char *)p2);

}


INLINE
wchar *
wcsstr (
	const wchar *p1,
	const wchar *p2
	)
{

	return (wchar *)strstr( (char *)p1, (char *)p2);

}


INLINE
int
wctomb (
	char *s,
	wchar_t wchar
	)
{

	if (s) {
		*s = (char)wchar;
		return 1;
	} else {
		return 0;
	}
}


INLINE
int
mbtowc (
	wchar_t *pwc,
	const char *s,
	size_t n
	)
{
	UNREFERENCED_PARAMETER( n );

	if ( s && *s && (n > 0) ) {
		*pwc = (wchar_t)(*s);
		return 1;
	} else {
		return 0;
	}

}


INLINE
wchar_t
towupper(
	wchar_t wc
	)
{

	return (wchar_t)toupper( (char)wc );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\memtrace\memtrace.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	memtrace.c

Abstract:

	This function contains an extension to NTSD that allows tracing of
	memory usage when ULIB objects are compiled with the MEMLEAK flag
	defined.

Author:

	Barry Gilhuly (W-Barry) 25-July-91

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>

#include <string.h>

#include "memtrace.h"


VOID
DumpToFile( char *OutString, ... )
{
	DWORD bytes;

	bytes = strlen( OutString );
	WriteFile( hFile, OutString, bytes, &bytes, NULL );
	return;
}

VOID
MemTrace(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
	the current contents of the Mem list.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        critical section to be dumped (e.g.  ntdll!FastPebLock,
        csrsrv!CsrProcessStructureLock...).


Return Value:

    None.

--*/

{
	DWORD		AddrMem;

	BOOL		b;
	DWORD		i;

	PMEM_BLOCK	MemListNext;
	MEM_BLOCK	MemObject;
	CHAR		Symbol[64];
	CHAR		Buffer[ 128 ];
	DWORD		Displacement;

	PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
	PNTSD_OUTPUT_ROUTINE lpAlternateOutputRoutine;

    PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
    PNTSD_GET_SYMBOL lpGetSymbolRoutine;

    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);
	UNREFERENCED_PARAMETER(lpArgumentString);

    lpOutputRoutine = lpExtensionApis->lpOutputRoutine;
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine;
	lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine;

	//
	// Attempt to use the input string as a file name...
	//
	if( ( hFile = CreateFile( lpArgumentString,
							  GENERIC_WRITE,
							  0,
							  NULL,
							  CREATE_ALWAYS,
							  FILE_ATTRIBUTE_NORMAL,
							  0
							) ) == (HANDLE)-1 ) {
		//
		// Unable to open the file - send all output to the screen.
		//
		lpAlternateOutputRoutine = lpExtensionApis->lpOutputRoutine;

	} else {

		lpAlternateOutputRoutine = DumpToFile;

	}



	//
	// Get the address of the head of the memleak list...
	//
	AddrMem = (lpGetExpressionRoutine)("Ulib!pmemHead");
	if ( !AddrMem ) {
		(lpOutputRoutine)( "Unable to find the head of the Mem List!\n" );
		if( hFile != (HANDLE)-1 ) {
			CloseHandle( hFile );
		}
		return;
	}
	if( !ReadProcessMemory(
            hCurrentProcess,
			(LPVOID)AddrMem,
			&MemListNext,
			sizeof( PMEM_BLOCK ),
            NULL
			) ) {
		if( hFile != (HANDLE)-1 ) {
			CloseHandle( hFile );
		}
		return;
	}

	//
	// Traverse the list of Mem blocks stopping when the head hits the
	// tail...At this point, the head of the list should be indicated
	// by MemListHead and the tail by MemListTail.	Since the first element
	// in the list is a dummy entry, it can be skipped...
	//
	do {

		if( !ReadProcessMemory(
				hCurrentProcess,
				(LPVOID)MemListNext,
				&MemObject,
				sizeof( MEM_BLOCK ),
				NULL
				) ) {
			return;
		}

		if( MemObject.memsig != Signature ) {

			//
			// This is an unrecognized memory block - die...
			//
			(lpOutputRoutine)( "Invalid block found!\n" );
			return;
		}

		//
		// Display the stored info - First the File, Line and Size of the
		// memory block allocated.	Then the stack trace...
		//
		sprintf( Buffer, "File: %s, Line: %ld, Size: %ld\n", MemObject.file,
				 MemObject.line, MemObject.size
			   );
		( lpAlternateOutputRoutine )( Buffer );

		//
		// This should dump the stack trace which was stored...
		//
		for( i = 0; ( i < MaxCallStack ) && ( MemObject.call[ i ] != 0 ); i++ ) {

			(lpGetSymbolRoutine)( ( LPVOID )( MemObject.call[ i ] ),
								  Symbol,
								  &Displacement
								);
			sprintf( Buffer, "\t%s\n", Symbol );
			( lpAlternateOutputRoutine )( Buffer );

		}
		( lpAlternateOutputRoutine )( "\n" );


	} while( ( MemListNext = MemObject.pmemNext ) != NULL );



	(lpOutputRoutine)( "\n...End of List...\n" );

	if( hFile != (HANDLE)-1 ) {

		( lpAlternateOutputRoutine )( "\n...End of List...\n" );
		CloseHandle( hFile );

	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ufat\src\ufat.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

        ufat.cxx

Abstract:

        This module contains run-time, global support for the
        FAT IFS Utilities library (UFAT).       This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

        Bill McJohn (billmc) 30-May-1991

Environment:

        User Mode

Notes:

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ulib.hxx"
#include "ufat.hxx"

extern "C" {
    #include <patchbc.h>
    #include "rtmsg.h"
}


#ifdef _AUTOCHECK_

BOOLEAN
SimpleFetchMessageTextInOemCharSet(
    IN  ULONG  MessageId,
    OUT CHAR  *Text,
    IN  ULONG  BufferLen
    );

#endif

//      Local prototypes

STATIC
BOOLEAN
DefineClassDescriptors(
        );

STATIC
BOOLEAN
UndefineClassDescriptors(
        );

BOOLEAN
PatchFatAndFat32BootCodeMessages(
    VOID
    );

extern "C"
UFAT_EXPORT
BOOLEAN
InitializeUfat (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        );

UFAT_EXPORT
BOOLEAN
InitializeUfat (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Ufat by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

#if defined(FE_SB) && defined(_X86_)
    if (Reason == DLL_PROCESS_ATTACH) {
        //
        // Initialize Machine Id
        //
        InitializeMachineData();
    }
#endif

#if _AUTOCHECK_

    UNREFERENCED_PARAMETER( Reason );

    if(!PatchFatAndFat32BootCodeMessages()) {
        DebugAbort("Internal error: translated messages for boot code are missing or too long!!!\n");
        return(FALSE);
    }

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "Ufat initialization failed!!!\n" );
        return( FALSE );
    }

#if defined(TRACE_UFAT_MEM_LEAK)
    DebugPrint("UFAT.DLL got attached.\n");
#endif

#else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
            //
            // Get translated boot messages into FAT boot code.
            //
            if(!PatchFatAndFat32BootCodeMessages()) {
                //
                // Internal error only, don't worry about translating it.
                //
                MessageBoxA(
                    NULL,
                    "Internal error: Translated boot messages are too long or missing.",
                    "ULIB.DLL (UFAT.DLL)",
                    MB_ICONERROR | MB_SYSTEMMODAL | MB_OK
                    );

                DebugAbort("Internal error: translated messages for boot code are missing or too long!!!\n");
                return(FALSE);
            }

            // Success, FALL THROUGH to thread attach case

        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_UFAT_MEM_LEAK)
                DebugPrintTrace(("UFAT.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "Ufat initialization failed!!!\n" );
                return( FALSE );
            }

#if defined(TRACE_UFAT_MEM_LEAK)
            DebugPrint("UFAT.DLL got attached.\n");
#endif

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_UFAT_MEM_LEAK)
                DebugPrintTrace(("UFAT.DLL got detached.  %d time(s) left.\n", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_UFAT_MEM_LEAK)
                DebugPrint("UFAT.DLL got detached.\n");
#endif

                UndefineClassDescriptors();
                count--;
            } else {
#if defined(TRACE_UFAT_MEM_LEAK)
                DebugPrint("UFAT.DLL detached more than attached\n");
#endif
            }
            break;
    }
#endif _AUTOCHECK_ || _SETUP_LOADER_

    return TRUE;
}



DECLARE_CLASS(  CLUSTER_CHAIN           );
DECLARE_CLASS(  EA_HEADER               );
DECLARE_CLASS(  EA_SET                  );
DECLARE_CLASS(  FAT                     );
DECLARE_CLASS(  FATDIR                  );
DECLARE_CLASS(  FAT_DIRENT              );
DECLARE_CLASS(  FAT_SA                  );
DECLARE_CLASS(  FAT_VOL                 );
#ifdef DBLSPACE_ENABLED
DECLARE_CLASS(  FATDB_VOL               );
#endif // DBLSPACE_ENABLED
DECLARE_CLASS(  FILEDIR                 );
DECLARE_CLASS(  HASH_INDEX              );
DECLARE_CLASS(  ROOTDIR                 );
DECLARE_CLASS(  RELOCATION_CLUSTER      );
#ifdef DBLSPACE_ENABLED
DECLARE_CLASS(  CVF_FAT_EXTENS          );
#endif // DBLSPACE_ENABLED
DECLARE_CLASS(  REAL_FAT_SA             );
#ifdef DBLSPACE_ENABLED
DECLARE_CLASS(  FATDB_SA                );
#endif // DBLSPACE_ENABLED


STATIC
BOOLEAN
DefineClassDescriptors(
        )
{
        if( DEFINE_CLASS_DESCRIPTOR( CLUSTER_CHAIN          ) &&
#ifdef DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( CVF_FAT_EXTENS         ) &&
#endif // DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( EA_HEADER              ) &&
            DEFINE_CLASS_DESCRIPTOR( EA_SET                 ) &&
            DEFINE_CLASS_DESCRIPTOR( FAT                    ) &&
#ifdef DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( FATDB_SA               ) &&
#endif // DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( FATDIR                 ) &&
            DEFINE_CLASS_DESCRIPTOR( FAT_DIRENT             ) &&
            DEFINE_CLASS_DESCRIPTOR( FAT_SA                 ) &&
            DEFINE_CLASS_DESCRIPTOR( FAT_VOL                ) &&
#ifdef DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( FATDB_VOL              ) &&
#endif // DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( FILEDIR                ) &&
            DEFINE_CLASS_DESCRIPTOR( HASH_INDEX             ) &&
            DEFINE_CLASS_DESCRIPTOR( RELOCATION_CLUSTER     ) &&
            DEFINE_CLASS_DESCRIPTOR( REAL_FAT_SA            ) &&
            DEFINE_CLASS_DESCRIPTOR( ROOTDIR                )
        ) {

                return TRUE;

        } else {

                DebugPrint( "Could not initialize class descriptors!");
                return FALSE;
        }
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
    UNDEFINE_CLASS_DESCRIPTOR( CLUSTER_CHAIN          );
#ifdef DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( CVF_FAT_EXTENS         );
#endif // DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( EA_HEADER              );
    UNDEFINE_CLASS_DESCRIPTOR( EA_SET                 );
    UNDEFINE_CLASS_DESCRIPTOR( FAT                    );
#ifdef DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( FATDB_SA               );
#endif // DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( FATDIR                 );
    UNDEFINE_CLASS_DESCRIPTOR( FAT_DIRENT             );
    UNDEFINE_CLASS_DESCRIPTOR( FAT_SA                 );
    UNDEFINE_CLASS_DESCRIPTOR( FAT_VOL                );
#ifdef DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( FATDB_VOL              );
#endif // DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( FILEDIR                );
    UNDEFINE_CLASS_DESCRIPTOR( HASH_INDEX             );
    UNDEFINE_CLASS_DESCRIPTOR( RELOCATION_CLUSTER     );
    UNDEFINE_CLASS_DESCRIPTOR( REAL_FAT_SA            );
    UNDEFINE_CLASS_DESCRIPTOR( ROOTDIR                );
    return TRUE;
}


BOOLEAN
PatchFatAndFat32BootCodeMessages(
    VOID
    )
{
    CHAR NtldrMissing[100];
    CHAR DiskError[100];
    CHAR PressKey[100];

    extern UCHAR FatBootCode[512];
    extern UCHAR Fat32BootCode[512*3];

    //
    // Get message text.
    //
#ifdef _AUTOCHECK_
    //
    // ntlib.lib, messages are in the binary being run.
    //
    {
        BOOLEAN b;

        b = SimpleFetchMessageTextInOemCharSet(
                MSG_BOOT_FAT_NTLDR_MISSING,
                NtldrMissing,
                sizeof(NtldrMissing)
                );

        if(b) {
            b = SimpleFetchMessageTextInOemCharSet(
                    MSG_BOOT_FAT_IO_ERROR,
                    DiskError,
                    sizeof(DiskError)
                    );

            if(b) {
                b = SimpleFetchMessageTextInOemCharSet(
                        MSG_BOOT_FAT_PRESS_KEY,
                        PressKey,
                        sizeof(PressKey)
                        );
            }
        }

        if(!b) {
            return(FALSE);
        }

    }
#else
    //
    // Win32 case, messages are in ulib.dll.
    //
    {
        HINSTANCE h;
        DWORD d;

        h = LoadLibraryEx(TEXT("ULIB"),NULL,LOAD_LIBRARY_AS_DATAFILE);
        if(!h) {
            return(FALSE);
        }

        d = FormatMessageA(
                FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                h,
                MSG_BOOT_FAT_NTLDR_MISSING,
                0,
                NtldrMissing,
                sizeof(NtldrMissing),
                NULL
                );

        if(d) {

            d = FormatMessageA(
                    FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                    h,
                    MSG_BOOT_FAT_IO_ERROR,
                    0,
                    DiskError,
                    sizeof(DiskError),
                    NULL
                    );

            if(d) {
                d = FormatMessageA(
                        FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                        h,
                        MSG_BOOT_FAT_PRESS_KEY,
                        0,
                        PressKey,
                        sizeof(PressKey),
                        NULL
                        );
            }
        }

        FreeLibrary(h);
        if(!d) {
            return(FALSE);
        }

        CharToOemA(NtldrMissing,NtldrMissing);
        CharToOemA(DiskError,DiskError);
        CharToOemA(PressKey,PressKey);
    }
#endif

    //
    // Call code in patchbc.lib to do the patching now that we've got
    // the translated message text.
    //
    if(!PatchMessagesIntoFatBootCode(FatBootCode,FALSE,NtldrMissing,DiskError,PressKey)
    || !PatchMessagesIntoFatBootCode(Fat32BootCode,TRUE,NtldrMissing,DiskError,PressKey)) {

        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ulib\src\arg.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    argument classes

Abstract:

    These classes implement the command line parsing for all utilities.

Author:

    steve rowe              stever                  2/45/91

Revision History:


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

extern "C" {
    #include <ctype.h>
};

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "wstring.hxx"

#if !defined( _AUTOCHECK_ )

#include "path.hxx"
#include "dir.hxx"
#include "filter.hxx"
#include "system.hxx"

#endif

//
//      Prototypes for the matching functions
//
STATIC
BOOLEAN
Match(
    OUT PARGUMENT           Argument,
    OUT PARGUMENT_LEXEMIZER ArgumentLexemizer,
    IN  BOOLEAN             CaseSensitive
    );

STATIC
BOOLEAN
TailMatch(
    IN  PWSTRING Pattern,
    IN  PWSTRING String,
    IN  CHNUM    chn,
    OUT PCHNUM   chnEnd,
    IN  BOOLEAN  CaseSensitive
    );


//
//  Increment size of the _CharPos array
//
#define CHARPOS_INCREMENT   64



DEFINE_EXPORTED_CONSTRUCTOR( ARGUMENT_LEXEMIZER, OBJECT, ULIB_EXPORT );

VOID
ARGUMENT_LEXEMIZER::Construct (
    )
{
    _CharPos = NULL;
}


ULIB_EXPORT
ARGUMENT_LEXEMIZER::~ARGUMENT_LEXEMIZER (
    )
{
    if ( _CharPos ) {
        FREE( _CharPos );
    }
}



ULIB_EXPORT
BOOLEAN
ARGUMENT_LEXEMIZER::Initialize (
    IN PARRAY LexemeArray
    )
/*++

Routine Description:

      Initialization for ARGUMENT_LEXEMIZER. ARGUMENT_LEXEMIZER holds the
    container for lexed parameters from the command line.

Arguments:

    LexemeArray - Supplies pointer to a general array container.

Return Value:

    TRUE  - If initialization succeeds
    FALSE - If failed to construct the different character sets used
            to lex out the argument strings.

--*/
{

    DebugPtrAssert( LexemeArray );

    //
    //  Initialize our counts and pointer to the array of lexemes
    //
    _ConsumedCount = 0;
    _LexemeCount   = 0;
    _parray        = LexemeArray;
    _CharPosSize   = CHARPOS_INCREMENT;

    if ( !(_CharPos = (PCHNUM)MALLOC( (unsigned int)(_CharPosSize * sizeof(CHNUM)) ))) {
        return FALSE;
    }

    //
    // Setup the character sets used in lexing.
    //
    // Switch defines the general character used to a switch. This
    // is needed to seperate /a/b into /a /b
    //
    // White space is all characters that are not of interest
    //
    // MultipleSwitches are specific switch values that can be grouped
    // together under 1 switch. Appear as /a/b or /ab
    //
    // EscapeChars are chars that negate any special meaning of a char.
    //
    // StartQuote and EndQuote define the opening and closing of quoted strings
    //
    if ((_SwitchChars.Initialize( (PWSTR) L"/" ))      &&
        (_WhiteSpace.Initialize( (PWSTR) L" \t"))      &&
        (_MultipleSwitches.Initialize())  &&
        (_StartQuote.Initialize())        &&
        (_EndQuote.Initialize())          &&
        (_MetaChars.Initialize())) {

        //
        // Separator is a combo of other characters that can terminate
        // a token.
        //
        _Separators.Initialize();
        _SeparatorString.Initialize( &_Separators );
        _SeparatorString.Strcat(&_WhiteSpace);
        _SeparatorString.Strcat(&_SwitchChars);
        _SeparatorString.Strcat(&_StartQuote);

        _CaseSensitive = TRUE;
        _AllowGlomming = FALSE;
        _NoSpcBetweenDstAndSwitch = FALSE;

        return TRUE;
    }

    //
    //  Something went wrong
    //
    return FALSE;
}

VOID
ARGUMENT_LEXEMIZER::PutMetaChars (
    IN PCSTR   MetaChars
    )
/*++

Routine Description:

    Initializes Meta-characters

Arguments:

    MetaChars - Supplies pointer to string of metacharacters

Return Value:

    none
--*/
{
    DebugPtrAssert( MetaChars );
    _MetaChars.Initialize(MetaChars);
}

VOID
ARGUMENT_LEXEMIZER::PutMetaChars (
    IN PCWSTRING MetaChars
    )
/*++

Routine Description:

    Initializes Meta-characters

Arguments:

    MetaChars - Supplies pointer to string of metacharacters

Return Value:

    none
--*/
{
    DebugPtrAssert( MetaChars );
    _MetaChars.Initialize(MetaChars);
}

ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::PutMultipleSwitch (
    IN PCSTR   MultipleSwitches
    )
/*++

Routine Description:

    initializes Multiple-switches

Arguments:

    MultipleSwitches - Supplies pointer to string of multiple switches

Return Value:

    none
--*/
{
    DebugPtrAssert( MultipleSwitches );
    _MultipleSwitches.Initialize(MultipleSwitches);
}

ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::PutMultipleSwitch (
    IN PCWSTRING MultipleSwitches
    )
/*++

Routine Description:

    initializes Multiple-switches

Arguments:

    MultipleSwitches - Supplies pointer to string of multiple switches

Return Value:

    none
--*/
{
    DebugPtrAssert( MultipleSwitches );
    _MultipleSwitches.Initialize(MultipleSwitches);
}

ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::PutSeparators (
    IN PCSTR   Separators
    )
/*++

Routine Description:

    Initializes Separators

Arguments:

    pSeparators - Supplies pointer to string of separators

Return Value:

    none
--*/
{
    DebugPtrAssert( Separators );
    _Separators.Initialize(Separators);
    _SeparatorString.Initialize( &_Separators );
    //_SeparatorString += _WhiteSpace;
    //_SeparatorString += _SwitchChars;
}

VOID
ARGUMENT_LEXEMIZER::PutSeparators (
    IN PCWSTRING Separators
    )
/*++

Routine Description:

    Initializes Separators

Arguments:

    Separators - Supplies pointer to string of separators

Return Value:

    none
--*/
{
    DebugPtrAssert( Separators );
    _Separators.Initialize(Separators);
    _SeparatorString.Initialize( &_Separators );
    _SeparatorString.Strcat(&_WhiteSpace);
    _SeparatorString.Strcat(&_SwitchChars);
}

ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::PutSwitches (
    IN PCSTR   Switches
    )
/*++

Routine Description:

    Initializes Switches

Arguments:

    Switches - Supplies pointer to string of switches

Return Value:

    none
--*/
{
    DebugPtrAssert( Switches );
    _SwitchChars.Initialize(Switches);
    _SeparatorString.Initialize( &_Separators );
    _SeparatorString.Strcat(&_WhiteSpace);
    _SeparatorString.Strcat(&_SwitchChars);
}

ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::PutSwitches (
    IN PCWSTRING Switches
    )
/*++

Routine Description:

    Initializes Switches

Arguments:

    Switches - Supplies pointer to string of switches

Return Value:

    none
--*/
{
    DebugPtrAssert( Switches );
    _SwitchChars.Initialize(Switches);
    _SeparatorString.Initialize( &_Separators );
    _SeparatorString.Strcat(&_WhiteSpace);
    _SeparatorString.Strcat(&_SwitchChars);
}

ULIB_EXPORT
PWSTRING
ARGUMENT_LEXEMIZER::QueryInvalidArgument (
    )
/*++

Routine Description:

    Returns the lexeme tha could not be matched against any argument

Arguments:

    none

Return Value:

    pointer to string initialized with the offending lexeme

--*/
{
    PWSTRING String;

    if ( _ConsumedCount == _LexemeCount) {
        //
        //      There was no error
        //
        return NULL;
    }

    if ( ((String = NEW DSTRING) == NULL)   ||
        !String->Initialize( GetLexemeAt( _ConsumedCount )) ) {
        DebugAssert( FALSE );

        DELETE( String );
        return NULL;
    }

    return String;

}

BOOLEAN
ARGUMENT_LEXEMIZER::PutCharPos (
     IN  ULONG   Index,
     IN  CHNUM   CharPos
     )
/*++

Routine Description:

    Puts a character position into the character position array

Arguments:

    Index       -   Supplies the Index within the CharPos array

    CharPos     -   Supplies the character

Return Value:

    TRUE  - If done, FALSE otherwise

--*/

{
    PCHNUM  pTmp;
    ULONG   NewSize = _CharPosSize;

    if ( Index >= _CharPosSize ) {

        NewSize += CHARPOS_INCREMENT;

        if ( !(pTmp = (PCHNUM)REALLOC( _CharPos, (unsigned int)(NewSize * sizeof(CHNUM))  ))) {
            return FALSE;
        }

        _CharPos     = pTmp;
        _CharPosSize = NewSize;
    }

    _CharPos[ Index ] = CharPos;

    return TRUE;
}



ULIB_EXPORT
BOOLEAN
ARGUMENT_LEXEMIZER::PrepareToParse (
    IN PWSTRING CommandLine
    )
/*++

Routine Description:

    Lexes command line into strings and puts in array container held
    with object.

Arguments:

    CommandLine - Supplies command line

Return Value:

    TRUE  - If Command line lex'd correctly
    FALSE - If error in lexing.  FALSE will be returned if there are
            quote characters defined and the user types a command line with
            an open quote without a corresponding close quote.

--*/

{
    PWSTRING    pEndSet;                //      End Set for token
    PWSTRING    pCur;                   //      Current token
    PWSTRING    pTmp;                   //      Temporary string
    CHNUM       chnStart;               //      Start of token
    CHNUM       chnEnd;                 //      End of token
    CHNUM       SwitchAt;               //      Switch character position
    CHNUM       SwitchSpan;             //      Switches expand up to this position
    CHNUM       QuoteOffset;            //      Offset of beg. quote char in _StartQuote
    WCHAR       EndQuoteChar;           //      end of quote char
    CHNUM       NextMeta;
    CHNUM       NextSeparator;


    if ( CommandLine == NULL ) {

#if defined( _AUTOCHECK_ )

        return FALSE;
#else
        if (!_CmdLine.Initialize( GetCommandLine() )) {
                        DebugAssert( FALSE );
                        return FALSE;
        }
#endif

    } else {

        if (!_CmdLine.Initialize( CommandLine )) {
            DebugAssert( FALSE );
            return FALSE;
        }
    }

    chnStart = 0;

    //
    //      Set _Switch to any permissible switch character
    //
    DebugAssert( _SwitchChars.QueryChCount() > 0 );
    _Switch = _SwitchChars.QueryChAt( 0 );

    //
    //      If we are case-insensitive, then we expand our multiple switches
    //      to include lower and upper case.
    //
    if (!_CaseSensitive && _MultipleSwitches.QueryChCount() > 0) {

        pTmp = NEW DSTRING;

        if (pTmp == NULL) {
            DebugPrint("ULIB: Out of memory\n");
            return FALSE;
        }

        _MultipleSwitches.Strupr();

        if (!pTmp->Initialize(&_MultipleSwitches)) {
            DebugPrint("ULIB: Out of memory\n");
            return FALSE;
        }
        pTmp->DeleteChAt(0);
        pTmp->Strlwr();

        if (!_MultipleSwitches.Strcat(pTmp)) {
            DebugPrint("ULIB: Out of memory\n");
            return FALSE;
        }

        DELETE( pTmp );
    }

    //
    // Loop till Command line is exhausted of tokens.
    //
    while ( TRUE ) {

        //
        // move to first character not part of white space. This will
        // always be the case for the start char. position since lexing
        // will always be interested in anything that is not white space.
        //
        chnStart = _CmdLine.Strspn( &_WhiteSpace, chnStart );

        //
        // Check of any tokens left to lex. Note that we have to
        // recheck the actual char. count each time through since
        // we may have deleted meta characters
        //
        if (chnStart == INVALID_CHNUM) {

            //
            // Have exhausted the command line of tokens. Get out of here
            //
            break;
        }

        //
        // if escape character, skip it and try again
        //
        if (_MetaChars.Strchr( _CmdLine.QueryChAt( chnStart)) != INVALID_CHNUM) {

            chnStart++;
            continue;
        }

        //
        // we've skipped over the leading whitespace so we're at the
        // beginning of the token.
        //
        chnEnd  = chnStart;

        if ( chnEnd < _CmdLine.QueryChCount() ) {

            pEndSet = &_SeparatorString;

            while ( chnEnd < _CmdLine.QueryChCount() ) {

                // if the current character is a separator and not
                // the first character in the token, we're done.
                // It can also be that there is no space between switches
                if( chnEnd != chnStart &&
                    ((_SeparatorString.Strchr(_CmdLine.QueryChAt(chnEnd)) != INVALID_CHNUM) ||
                     (_NoSpcBetweenDstAndSwitch &&
                      (_SwitchChars.Strchr(_CmdLine.QueryChAt(chnEnd)) != INVALID_CHNUM) &&
                      ((chnEnd+1) < _CmdLine.QueryChCount()) &&
                      !isdigit(_CmdLine.QueryChAt(chnEnd+1))))) {

                    // If this token so far is two consecutive separators,
                    // keep going.  Otherwise, it's the end of the token.
                    //
                    if( chnStart + 1 == chnEnd &&
                        (_SwitchChars.Strchr( _CmdLine.QueryChAt( chnStart ) ) != INVALID_CHNUM ) &&
                        (_SwitchChars.Strchr( _CmdLine.QueryChAt( chnEnd ) )   != INVALID_CHNUM ) ) {

                        chnEnd++;
                        continue;
                    }

                    break;
                }

                // if the current character is a meta character, delete
                // the meta character and accept the following character
                // without reservation.
                //
                if( _MetaChars.Strchr( _CmdLine.QueryChAt(chnEnd) ) != INVALID_CHNUM ) {

                    _CmdLine.DeleteChAt(chnEnd);

                    if( chnEnd < _CmdLine.QueryChCount() ) {
                        chnEnd++;
                    }
                    continue;
                }

                // if the current character is a start-quote, accept everything
                // until an end-quote is found (or we run out of string).
                //
                if( (QuoteOffset = _StartQuote.Strchr( _CmdLine.QueryChAt(chnEnd) )) != INVALID_CHNUM ) {

                    //
                    //  Set the end of quote char to the corresponding char in
                    //  the _EndQuote string.  (ie. if the opening quote char
                    //  is the first char in _StartQuote then use the first
                    //  char in _EndQuote)
                    //
                    EndQuoteChar = _EndQuote.QueryChAt(QuoteOffset);
                    chnEnd++;

                    while( TRUE ) {
                        //
                        // locate potential end of token by looking for the
                        // EndQuoteChar.
                        //
                        //  check if next char is the EndQuoteChar--if it is,
                        //  then the user is 'quoting' the endquotechar, so
                        //  remove the 'quoting' char.  Otherwise, this is
                        //  the end of the quoted string.
                        //
                        if( (chnEnd = _CmdLine.Strchr(EndQuoteChar, chnEnd ))
                            != INVALID_CHNUM ) {

                            //
                            // bump up chnEnd to check the character
                            // after the quote char.  If it's another
                            // quote char then, delete the first quote.
                            // Otherwise, we're at the end of the quoted
                            // string.
                            //
                            if( _CmdLine.QueryChAt(++chnEnd) == EndQuoteChar ) {

                                _CmdLine.DeleteChAt(chnEnd - 1);
                                continue;

                            } else {

                                break;
                            }

                        } else {

                            //
                            // we reached the end of the string w/o finding the
                            // endQuoteChar (chnEnd == INVALID_CHNUM)
                            //
                            // return FALSE because an open quote is being
                            // considered a lex error because this is easier and
                            // does what is required.  If someone wants to
                            // handle quote characters they could change this
                            // by setting chnEnd to the last char of the first
                            // token, ignoring the quote. eg: if cmd line was
                            //      cmd "arg1 arg2 arg3
                            //
                            // chnEnd could be set to the position of '1'.
                            //
                            return FALSE;

                        }
                    }

                    // Keep accepting characters.
                    //
                    continue;
                }

                // It's not a separator, a meta-character, or a start quote;
                // accept it.
                //
                chnEnd++;
            }
        }


                //
                // we have a valid token to put in string array.
                //
        if ((pCur = _CmdLine.QueryString(chnStart, chnEnd - chnStart)) == NULL) {

                        //
            // Could not create a new substring. Error out.
                        //
                        return FALSE;
                }

                SwitchSpan = pCur->Strspn( &_MultipleSwitches, 1 );

                //
                //      Ramonsa - We must not replace the original switch character used,
                //                        because if we do then we won't be able to retrieve it.
                //
                //if ((SwitchAt = _SwitchChars.Strchr( pCur->QueryChAt(0))) != INVALID_CHNUM ) {
                //
                //      //
                //      //      The first character is a switch
                //      //
                //      pCur->SetChAt( _Switch, 0);
                //
                //
                //}
                SwitchAt = _SwitchChars.Strchr( pCur->QueryChAt(0) );

                //
                // Check for multiple switch arguments by seeing if any of the
        // characters in the token are not in the multiple switch set.
        // Also, if the token is only one character then it can't be
        // multiple switches.
        if (( SwitchAt == INVALID_CHNUM ) ||
            ( SwitchSpan != INVALID_CHNUM ) ||
            pCur->QueryChCount() == 1) {

                        //
                        // Non-multiple characters were found, throw the entire
                        // thing into the string array container
                        //

            if (!_parray->Put( pCur ) ||
                !PutCharPos( _LexemeCount, chnStart )
               ) {

                                //
                                // Error out we could not insert the value
                                //
                                return FALSE;

                        } else {

                                //
                                // Setup to fetch next token and go to outer loop
                //
                _LexemeCount++;
                                chnStart = chnEnd;
                                continue;
                        }

                } else {

                        //
                        //  All characters in the string are multiple switches.
                        //
                        for ( CHNUM chn = 1; chn < pCur->QueryChCount(); chn++ ) {

                            //
                            // If glomming is allowed then we want to handle pCur when
                            // it looks like "/s/f/i/d" by splitting up each argument.
                            // We skip over the slashes and treat this string the same
                            // as "/sfid".  (See arg.hxx at "GLOMMING".)
                            //

                            if (_AllowGlomming && chn >= 2 &&
                                pCur->QueryChAt(chn) == pCur->QueryChAt(0)) {
                                continue;
                }

                                //
                                //      Pull out a switch and put in new switch string.
                                //
                pTmp = NEW DSTRING();

                if (pTmp == NULL ||
                    !pTmp->Initialize((PWSTR) L"  ")) {
                    DebugPrint("ULIB: Out of memory\n");
                    return FALSE;
                }

                pTmp->SetChAt( pCur->QueryChAt(0), 0 );
                pTmp->SetChAt( pCur->QueryChAt(chn), 1 );

                if (!_parray->Put( pTmp )                   ||
                    !PutCharPos( _LexemeCount, chnStart )
                   ) {

                                        //
                                        // ERROR out we could not put the token
                                        //
                                        DELETE( pTmp );
                                        return FALSE;

                                } else {

                                        _LexemeCount++;
                                }
                        }

                        //
                        //      pCur not needed anymore
                        //
                        DELETE( pCur );

                        //
                        // Setup to fetch next token and go to outer loop
                        //
                        chnStart = chnEnd;
                        continue;
                }
        }

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
ARGUMENT_LEXEMIZER::DoParsing (
    IN PARRAY           ArgumentArray
    )
/*++

Routine Description:

    Parses the arguments passed.

Arguments:

        ArgumentArray  -   Supplies pointer to array of arguments to set


Return Value:

        TRUE if all argument strings matched
        FALSE otherwise.


--*/
{

        PARRAY_ITERATOR Iterator;
        PARGUMENT               arg;
        BOOLEAN         DoAgain = TRUE;

        DebugPtrAssert( ArgumentArray );

        while (DoAgain) {

                DoAgain   = FALSE;

                Iterator = (PARRAY_ITERATOR)ArgumentArray->QueryIterator();

                DebugAssert( Iterator );

                if ( Iterator ) {

                        arg = (PARGUMENT)Iterator->GetNext();

                        while( arg ) {

                                //
                                //      Check that the argument hasn't already found its
                                //      match.
                                //
                                if (!arg->IsValueSet()) {

                                        //
                                        //      If the first character of the pattern is a switch,
                                        //      we change the switch character.
                                        //
                                        if (( _SwitchChars.Strchr(arg->GetPattern()->QueryChAt(0))) != INVALID_CHNUM) {

                                                arg->GetPattern()->SetChAt( _Switch, 0);

                                        }

                                        //
                                        //      Try to match it
                                        //
                                        if (arg->SetIfMatch( this, _CaseSensitive )) {

                                                //
                                                //      Found a match, start over with first argument
                                                //      if there are more lexemes to match.
                                                //
                                                DoAgain = (BOOLEAN)( _ConsumedCount != _LexemeCount );

                                                break;
                                        }
                                }

                                arg = (PARGUMENT)Iterator->GetNext();
                        }

                        DELETE( Iterator );
                }
        }

        return  ( _ConsumedCount == _LexemeCount );
}

ULIB_EXPORT
PWSTRING
ARGUMENT_LEXEMIZER::GetLexemeAt (
    IN  ULONG   Index
        )
/*++

Routine Description:

        Gets the Lexeme at the specified index

Arguments:

    Index   -   Supplies the index of the lexeme desired

Return Value:

    Pointer to the lexeme

--*/
{
        return (PWSTRING)_parray->GetAt(Index);
}


CHNUM
ARGUMENT_LEXEMIZER::QueryCharPos (
    IN  ULONG   LexemeNumber
    )
/*++

Routine Description:

    Queries the character position of a particular lexeme

Arguments:

    LexemeNumber    -   Supplies the lexeme number

Return Value:

    Returns the character position of the lexeme

--*/
{
    DebugAssert( LexemeNumber < _LexemeCount );
    DebugAssert( LexemeNumber < _CharPosSize );

    return _CharPos[ LexemeNumber ];
}


ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::SetCaseSensitive (
        IN BOOLEAN CaseSensitive
    )
/*++

Routine Description:

        Sets case sensitivity ON/OFF

Arguments:

        CaseSensitive   -       Supplies case sensitivity flag

Return Value:

        none

--*/
{
        _CaseSensitive = CaseSensitive;
}


ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::SetAllowSwitchGlomming (
    IN BOOLEAN AllowGlomming
    )
/*++

Routine Description:

    Sets whether swith glomming (as in "/s/f/i/d") is allowed
    or not.  See note in <arg.hxx> at "GLOMMING".

Arguments:

    AllowGlomming   -   Supplies glomming allowed flag.

Return Value:

    none

--*/
{
    _AllowGlomming = AllowGlomming;
}


ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::SetNoSpcBetweenDstAndSwitch (
    IN BOOLEAN NoSpcBetweenDstAndSwitch
    )
/*++

Routine Description:

    Sets whether a separator is required between
    tokens.  This is specifically for xcopy that
         a space should not be required to separate the
         destination and the specified options.

Arguments:

    NoSpcBetweenDstAndSwitch - Supplies the flag

Return Value:

    none

--*/
{
    _NoSpcBetweenDstAndSwitch = NoSpcBetweenDstAndSwitch;
}


DEFINE_CONSTRUCTOR( ARGUMENT, OBJECT );

VOID
ARGUMENT::Construct (
    )
{
        UNREFERENCED_PARAMETER( (void)this);
        _Lexeme = NULL;
}

BOOLEAN
ARGUMENT::Initialize (
        IN      PSTR Pattern
    )
/*++

Routine Description:

    Create an ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                 parameter

Return Value:

        TRUE - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
        //  Make sure that we have an associated pattern
        //
        DebugAssert(Pattern);

        //
        //  Initially we don't have a value
        //
        _fValueSet = FALSE;

        //
        //  Initialize the pattern
        //
        return _Pattern.Initialize(Pattern);
}

BOOLEAN
ARGUMENT::Initialize (
    IN  PWSTRING Pattern
    )
/*++

Routine Description:

    Create an ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                 parameter

Return Value:

        TRUE - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
        //  Make sure that we have an associated pattern
        //
        DebugAssert(Pattern);

        //
        //  Initially we don't have a value
        //
        _fValueSet = FALSE;

        //
        //  Initialize the pattern
        //
        return _Pattern.Initialize(Pattern);
}

ULIB_EXPORT
PWSTRING
ARGUMENT::GetLexeme (
        )
/*++

Routine Description:

        Gets the lexeme matched by this Argument.

Arguments:

    none

Return Value:

        Pointer to Lexeme

--*/
{
    //DebugAssert( _fValueSet );

        return _Lexeme;
}

ULIB_EXPORT
PWSTRING
ARGUMENT::GetPattern (
        )
/*++

Routine Description:

    Gets the pattern associated with this Argument.

Arguments:

    none

Return Value:

    Pointer to pattern

--*/
{
        return &_Pattern;
}

BOOLEAN
ARGUMENT ::SetIfMatch(
        OUT PARGUMENT_LEXEMIZER ArgumentLexemizer,
        IN      BOOLEAN                         CaseSensitive
    )
/*++

Routine Description:

        Determines if the current argument string is recognized by
    this ARGUMENT object, and setst the value if there is a match.

Arguments:

        ArgumentLexemizer - Supplies container holding command line
                                                 lex'd into strings
        CaseSensitive     - Supplies case sensitivity flag

Return Value:

    TRUE  - argument recognized and value set.
        FALSE - argument not recognized and/or value not set.

--*/
{
        //
        // Match will try to match the current argument pattern (Pattern)
        // with one of the string from the lexemizer. If a match occurs
        // then it will callback through the this pointer passed to
        // the SetValue routine for this argument object.
        //
        return Match( this, ArgumentLexemizer,  CaseSensitive );
};

ULIB_EXPORT
BOOLEAN
ARGUMENT::IsValueSet (
        )
/*++

Routine Description:

    Checks if the argument has been found and set.

    This method is used to determine if the ARGUMENT object has had
    its value set without having to know what type of ARGUMENT object
        it is. This is used mainly in ARGUMENT_LIST to avoid repeated calling
    IsArgument once the argument has been recognized and the value
        set.

Arguments:

Return Value:

        TRUE - if value has already been set.
    FALSE - if the value has not been set and it is ok to call IsArgument

--*/
{
    return _fValueSet;
};

BOOLEAN
ARGUMENT::SetValue(
        IN PWSTRING                     Arg,
        IN CHNUM                                chnIdx,
        IN CHNUM                                chnEnd,
        IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
    )
/*++

Routine Description:

        Default method for setting the value of an argument. Sets
    fValueSet to false.

Arguments:

        Arg                              -       Supplies current argument string
        chnIdx                           -       Supplies index within Arg
        ArgumentLexemizer        -       Supplies list of lexed strings

Return Value:

        FALSE

--*/
{

    UNREFERENCED_PARAMETER( this );
    UNREFERENCED_PARAMETER( (void)Arg );
    UNREFERENCED_PARAMETER( (void)chnIdx );
    UNREFERENCED_PARAMETER( (void)ArgumentLexemizer );
    UNREFERENCED_PARAMETER( (void)chnEnd );


    return _fValueSet = FALSE ;
}








DEFINE_EXPORTED_CONSTRUCTOR( FLAG_ARGUMENT, ARGUMENT, ULIB_EXPORT);

VOID
FLAG_ARGUMENT::Construct (
        )
{
        UNREFERENCED_PARAMETER( this );
}

ULIB_EXPORT
BOOLEAN
FLAG_ARGUMENT::Initialize (
        IN      PSTR Pattern
        )
/*++

Routine Description:

        Create a FLAG_ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                                 parameter

Return Value:

        TRUE - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

    //
    //      Set our initial value
    //
    _flag = FALSE;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

ULIB_EXPORT
BOOLEAN
FLAG_ARGUMENT::Initialize (
    IN  PWSTRING Pattern
        )
/*++

Routine Description:

        Create a FLAG_ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                                 parameter

Return Value:

        TRUE - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
    //      Set our initial value
    //
    _flag = FALSE;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
FLAG_ARGUMENT::SetValue(
        IN PWSTRING                     Arg,
    IN CHNUM                chnIdx,
        IN CHNUM                                chnEnd,
        IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
    )
/*++

Routine Description:

    Sets the flag to TRUE

Arguments:

        Arg                              -       Supplies current argument string
        chnIdx                                  -       Supplies index within Arg
        ArgumentLexemizer          -   Supplies list of lexed strings

Return Value:

    FALSE

--*/
{

    UNREFERENCED_PARAMETER( this );
    UNREFERENCED_PARAMETER( (void)Arg );
    UNREFERENCED_PARAMETER( (void)chnIdx );
    UNREFERENCED_PARAMETER( (void)ArgumentLexemizer );

    _Lexeme = Arg;
    _LastConsumedCount = ArgumentLexemizer->QueryConsumedCount();
    return _flag = _fValueSet = TRUE;

}



DEFINE_EXPORTED_CONSTRUCTOR( STRING_ARGUMENT, ARGUMENT, ULIB_EXPORT);

VOID
STRING_ARGUMENT::Construct (
        )
{
        _String = NULL;
}

ULIB_EXPORT
STRING_ARGUMENT::~STRING_ARGUMENT (
        )
/*++

Routine Description:

    Destructor for String Arguments

Arguments:


Return Value:

    none

--*/
{
        DELETE( _String );
}

ULIB_EXPORT
BOOLEAN
STRING_ARGUMENT::Initialize (
        IN      PSTR Pattern
    )
/*++

Routine Description:

    Create a FLAG_ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                                 parameter

Return Value:

    TRUE  - If arg. initialized.
    FALSE - If failed to initialize.

--*/
{
        //
    //      Set our initial value
        //
        _String = NULL;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
STRING_ARGUMENT::Initialize (
    IN  PWSTRING Pattern
    )
/*++

Routine Description:

    Create a FLAG_ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                                 parameter

Return Value:

    TRUE  - If arg. initialized.
    FALSE - If failed to initialize.

--*/
{
        //
    //      Set our initial value
        //
        _String = NULL;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
STRING_ARGUMENT::SetValue(
        IN PWSTRING                     Arg,
    IN CHNUM                chnIdx,
        IN CHNUM                                chnEnd,
        IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
    )

/*++

Routine Description:

    Sets the value of a STRING_ARGUMENT argument

Arguments:

        Arg                      -       Supplies current argument string
        chnIdx                          -       Supplies index within Arg
        ArgumentLexemizer  -   Supplies list of lexed strings

Return Value:

    TRUE if value set
    FALSE otherwise

--*/
{

        DebugPtrAssert( Arg );

    _fValueSet = FALSE;

        DebugAssert( Arg->QueryChCount() >= chnEnd );

    if ((_String=Arg->QueryString(chnIdx, chnEnd - chnIdx )) != NULL) {
                  ArgumentLexemizer->IncrementConsumedCount( );

                _Lexeme    = Arg;
        _fValueSet = TRUE;
    }

    return _fValueSet;
}






DEFINE_EXPORTED_CONSTRUCTOR( LONG_ARGUMENT, ARGUMENT, ULIB_EXPORT);

VOID
LONG_ARGUMENT::Construct (
        )
{
        UNREFERENCED_PARAMETER( this );
}

ULIB_EXPORT
BOOLEAN
LONG_ARGUMENT::Initialize (
        IN      PSTR Pattern
        )
/*++

Routine Description:

    Create a FLAG_ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                 parameter

Return Value:

    TRUE  - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
    //      Set our initial value
    //
    _value = 0;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
LONG_ARGUMENT::Initialize (
    IN  PWSTRING Pattern
        )
/*++

Routine Description:

    Create a FLAG_ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                 parameter

Return Value:

    TRUE  - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
    //      Set our initial value
    //
    _value = 0;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
LONG_ARGUMENT::SetValue (
        IN PWSTRING                     Arg,
        IN CHNUM                chnIdx,
        IN CHNUM                                chnEnd,
        IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
    )

/*++

Routine Description:

    Sets the value of a LONG_ARGUMENT argument

Arguments:

        Arg      -       Supplies current argument string
        chnIdx          -       Supplies index within Arg
        ArgStrings -   Supplies list of lexed strings

Return Value:

    TRUE if value set
    FALSE otherwise

--*/
{
        DebugPtrAssert( Arg );

        DebugAssert( Arg->QueryChCount() >= chnEnd );

    if ( Arg->QueryNumber( &_value, chnIdx,  chnEnd - chnIdx )) {
                ArgumentLexemizer->IncrementConsumedCount();

                _Lexeme = Arg;
                return _fValueSet = TRUE;
        }

        return FALSE;
}



#if !defined( _AUTOCHECK_ )



DEFINE_EXPORTED_CONSTRUCTOR( TIMEINFO_ARGUMENT, ARGUMENT, ULIB_EXPORT);

VOID
TIMEINFO_ARGUMENT::Construct (
        )
{
        UNREFERENCED_PARAMETER( this );
}

ULIB_EXPORT
TIMEINFO_ARGUMENT::~TIMEINFO_ARGUMENT (
        )
/*++

Routine Description:

        Destructor for Timeinfo Arguments

Arguments:


Return Value:

    none

--*/
{
        DELETE( _TimeInfo );
}

ULIB_EXPORT
BOOLEAN
TIMEINFO_ARGUMENT::Initialize (
    IN      PSTR Pattern
    )
/*++

Routine Description:

    Create a TIMEINFO_ARGUMENT object and setup for parsing

Arguments:

    Pattern - Supplies string used in matching argument with command line
             parameter

Return Value:

    TRUE  - If arg. initialized.
    FALSE - If failed to initialize.

--*/
{

    _TimeInfo = NULL;

    return ARGUMENT::Initialize(Pattern);
}

BOOLEAN
TIMEINFO_ARGUMENT::Initialize (
    IN  PWSTRING Pattern
    )
/*++

Routine Description:

    Create a TIMEINFO_ARGUMENT object and setup for parsing

Arguments:

    Pattern - Supplies string used in matching argument with command line
              parameter

Return Value:

    TRUE  - If arg. initialized.
    FALSE - If failed to initialize.

--*/
{
    _TimeInfo = NULL;

    return ARGUMENT::Initialize(Pattern);
}

BOOLEAN
TIMEINFO_ARGUMENT::SetValue (
    IN PWSTRING             Arg,
    IN CHNUM                chnIdx,
    IN CHNUM                chnEnd,
    IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
    )

/*++

Routine Description:

    Sets the value of a TIMEINFO_ARGUMENT argument

Arguments:

    Arg             -       Supplies current argument string
    chnIdx          -       Supplies index within Arg
    ArgStrings      -       Supplies list of lexed strings

Return Value:

    TRUE if value set
    FALSE otherwise

--*/
{

    DSTRING String;

    DebugPtrAssert( Arg );

    if ( ( Arg) &&
        String.Initialize( Arg, chnIdx, chnEnd - chnIdx )     &&
        ((_TimeInfo = NEW TIMEINFO) != NULL)                  &&
        _TimeInfo->Initialize()                               &&
        _TimeInfo->SetDateAndTime( &String ) ) {

        ArgumentLexemizer->IncrementConsumedCount();

        _Lexeme = Arg;
        return _fValueSet = TRUE;
    }

    return FALSE;
}

#endif  // _AUTOCHECK_


#if !defined( _AUTOCHECK_ )

DEFINE_EXPORTED_CONSTRUCTOR( PATH_ARGUMENT, ARGUMENT, ULIB_EXPORT);

VOID
PATH_ARGUMENT::Construct (
        )
{
        _Path = NULL;
}

ULIB_EXPORT
PATH_ARGUMENT::~PATH_ARGUMENT(
        )
/*++

Routine Description:

    Destructor for Path Arguments

Arguments:

    none

Return Value:

        none

--*/
{
        Destroy();
}

VOID
PATH_ARGUMENT::Destroy(
        )
/*++

Routine Description:

        Destroys a path argument

Arguments:

    none

Return Value:

        none

--*/
{
        DELETE( _Path );
}

ULIB_EXPORT
BOOLEAN
PATH_ARGUMENT::Initialize (
        IN      PSTR    Pattern,
        IN      BOOLEAN Canonicalize
        )
/*++

Routine Description:

        Create a PATH_ARGUMENT object and setup for parsing

Arguments:

        Pattern                 -       Supplies string used in matching argument with
                                                command line parameter
        Canonicalize    -       Supplies the canonicalization flag

Return Value:

    TRUE  - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
        //      Destroy the path, in case we are re-initializing
        //
        Destroy();

        _Canonicalize = Canonicalize;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
PATH_ARGUMENT::Initialize (
    IN  PWSTRING Pattern,
        IN      BOOLEAN                 Canonicalize
        )
/*++

Routine Description:

        Create a PATH_ARGUMENT object and setup for parsing

Arguments:

        Pattern                 -       Supplies string used in matching argument with
                                                command line parameter
        Canonicalize    -       Supplies the canonicalization flag

Return Value:

    TRUE  - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
        //      Destroy the path, in case we are re-initializing
        //
        Destroy();

        _Canonicalize = Canonicalize;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
PATH_ARGUMENT::SetValue(
        IN PWSTRING                             Arg,
        IN CHNUM                chnIdx,
        IN CHNUM                                chnEnd,
        IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
        )
/*++

Routine Description:

        Sets the value of a PATH_ARGUMENT argument

Arguments:

        Arg                             -       Supplies current argument string
        chnIdx          -   Supplies index within Arg
    ArgumentLexemizer - Supplies list of lexed strings

Return Value:

        TRUE if value set
        FALSE otherwise

--*/
{

        PWSTRING pT;

        DebugPtrAssert( Arg );


        _fValueSet = FALSE;

        DebugAssert( Arg->QueryChCount() >= chnEnd );

        pT = Arg->QueryString(chnIdx, chnEnd - chnIdx);

        if (NULL != pT) {

        //
        // Remove double quotes from the path string.  We assume
        // that there will never be a valid double-quote in an
        // actual path.
        //

        for (ULONG i = 0; i < pT->QueryChCount(); ++i) {
            if ('\"' == pT->QueryChAt(i)) {
                pT->DeleteChAt(i);
                i--;
                continue;
            }
        }

                if( (_Path = NEW PATH) != NULL) {
                        if ( _Path->Initialize( pT, _Canonicalize )) {

                                //
                                // check the first char to see if it's a switch char
                                // (it can't be if it's a path)
                                //
                if( (ArgumentLexemizer->GetSwitches()->Strchr(pT->QueryChAt(0))
                                         == INVALID_CHNUM)  ) {
                                        ArgumentLexemizer->IncrementConsumedCount();

                                        _Lexeme         =       Arg;
                                        _fValueSet      =       TRUE;
                                }

                        } else {

                                DebugAssert( FALSE );
                                DELETE( _Path );
                        }
                }

                DELETE( pT );

        }

        return _fValueSet;
}


#endif  // _AUTOCHECK_



#if !defined( _AUTOCHECK_ )


DEFINE_EXPORTED_CONSTRUCTOR( MULTIPLE_PATH_ARGUMENT, PATH_ARGUMENT, ULIB_EXPORT);

VOID
MULTIPLE_PATH_ARGUMENT::Construct (
        )
{
        _PathArray = NULL;
}

ULIB_EXPORT
MULTIPLE_PATH_ARGUMENT::~MULTIPLE_PATH_ARGUMENT(
        )

/*++

Routine Description:

        Destructor for Path Arguments

Arguments:

        none


Return Value:

        none

--*/

{
        Destroy();
}

VOID
MULTIPLE_PATH_ARGUMENT::Destroy(
        )

/*++

Routine Description:

        Destroys a multiple-path argument

Arguments:

        none


Return Value:

        none

--*/

{
        DELETE( _PathArray );
}

ULIB_EXPORT
BOOLEAN
MULTIPLE_PATH_ARGUMENT::Initialize (
        IN PSTR         Pattern,
    IN BOOLEAN  Canonicalize,
    IN BOOLEAN  ExpandWildCards
    )
/*++

Routine Description:

        Initializes a MULTIPLE_PATH_ARGUMENT

Arguments:

        Pattern                 -       Supplies the argument pattern
    Canonicalize    -   Supplies canonicalization flag
    ExpandWildCards -   Supplies wildcard expansion flag

Return Value:

        TRUE if correctly initialized
        FALSE otherwise

--*/

{

        //
        //      Destroy, in case we are re-initializing
        //
        Destroy();

        //
        //      Initialize the argument
        //
        if (PATH_ARGUMENT::Initialize( Pattern, Canonicalize ) ) {

                //
                //      Argument correctly initialized, create our array object
                //
                if ((_PathArray = NEW ARRAY) != NULL) {

                        //
                        //      Ok, so initialize it
                        //
                        if (_PathArray->Initialize() ) {

                                //
                                //      Everything's cool
                                //
                _PathCount          = 0;
                _ExpandWildCards    = ExpandWildCards;
                _WildCardExpansionFailed  = FALSE;
                return TRUE ;
                        }

                        DELETE( _PathArray );
        }
    }

    return FALSE;
}

BOOLEAN
MULTIPLE_PATH_ARGUMENT::Initialize (
    IN PWSTRING  Pattern,
    IN BOOLEAN          Canonicalize,
    IN BOOLEAN          ExpandWildCards
    )
/*++

Routine Description:

        Initializes a MULTIPLE_PATH_ARGUMENT

Arguments:

        Pattern                 -       Supplies the argument pattern
    Canonicalize    -   Supplies canonicalization flag
    ExpandWildCards -   Supplies wildcard expansion flag

Return Value:

        TRUE if correctly initialized
        FALSE otherwise

--*/

{
        //
        //      Destroy, in case we are re-initializing
        //
        Destroy();

        //
        //      Initialize the argument
        //
        if (PATH_ARGUMENT::Initialize( Pattern, Canonicalize ) ) {

                //
                //      Argument correctly initialized, create our array object
                //
                if ((_PathArray = NEW ARRAY) != NULL) {

                        //
                        //      Ok, so initialize it
                        //
                        if (_PathArray->Initialize() ) {

                                //
                                //      Everything's cool
                                //
                _PathCount          = 0;
                _ExpandWildCards    = ExpandWildCards;
                _WildCardExpansionFailed  = FALSE;
                return TRUE ;
                        }

                        DELETE( _PathArray );
        }
    }

    return FALSE;
}

BOOLEAN
MULTIPLE_PATH_ARGUMENT::SetValue (
        IN PWSTRING                         pwcArg,
        IN CHNUM                                chnIdx,
        IN CHNUM                                chnEnd,
        IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
        )
/*++

Routine Description:

        Sets the value of a MULTIPLE_PATH_ARGUMENT argument

Arguments:

        pwcArg                          -       Supplies current argument string
        chnIdx                          -       Supplies index within pwcArg
        ArgumentLexemizer       -       Supplies list of lexed strings

Return Value:

        TRUE if value set
        FALSE otherwise

--*/
{

    PPATH               FullPath    = NULL;
    PWSTRING TmpName     = NULL;
    PFSN_DIRECTORY      Directory   = NULL;
    PARRAY              NodeArray   = NULL;
    PARRAY_ITERATOR     Iterator    = NULL;
    PFSNODE             Node;
    PPATH               Path;
    CHNUM               BaseLength;
    DSTRING             Name;
    FSN_FILTER          Filter;
    CHNUM               PrefixLength;
    BOOLEAN             Ok          = FALSE;

    DebugPtrAssert( _PathArray );

        //
        //      Try to set the path value
        //
        if (PATH_ARGUMENT::SetValue(pwcArg, chnIdx, chnEnd, ArgumentLexemizer)) {

        //
        //  If we have to expand wildcards, we get an array of paths and put
        //  the elements in our array, otherwise we just put the path that we
        //  have.
        //
        if ( _ExpandWildCards && PATH_ARGUMENT::_Path->HasWildCard() ) {

            //
            //  Expand the path that we have, remember its name portion
            //  and truncate it so that we are left with a directory
            //  path. Then get a directory object from the path and a filter
            //  for the wildcard.
            //
            //  Then do the wildcard expansion.
            //
            if ( ( FullPath = PATH_ARGUMENT::_Path->QueryFullPath() )        &&
                 ( TmpName  = FullPath->QueryName() )                        &&
                 Name.Initialize( TmpName )                                  &&
                 FullPath->TruncateBase()                                    &&
                 (Directory = SYSTEM::QueryDirectory( FullPath ))            &&
                 Filter.Initialize()                                         &&
                 Filter.SetFileName( &Name )                                 &&
                 ( NodeArray = Directory->QueryFsnodeArray( &Filter ))       &&
                 ( Iterator  = (PARRAY_ITERATOR)NodeArray->QueryIterator() )
               ) {

                Ok = TRUE;


                //
                //  If no files matched the wildcard, we remember the pattern
                //  and set the failure flag.
                //
                if ( !_WildCardExpansionFailed &&
                     (NodeArray->QueryMemberCount() == 0 ) ) {
