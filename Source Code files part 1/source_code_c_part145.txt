e Band Mask, one byte where:				
;										
;				  bit 0 = Color Band 1 is needed		
;				  bit 1 = Color Band 2 is needed		
;				  bit 2 = Color Band 3 is needed		
;				  bit 3 = Color Band 4 is needed		
;										
;										
;	CALLED BY: SET_CGA_XLT_TAB						
;		   SET_EGA_XLT_TAB						
;		   SET_ROUNDUP_XLT_TAB						
;		   SET_MODE_13H_XLT_TAB 					
;		   SET_MODE_F_XLT_TAB						
;										
;------------------------------------------------------------------------------ 
;										
; NOTES: The RGB values in input describe a color from the screen.		
; Up to 256K different colors can be described with these RGB values.		
;										
; On the color printer, the print ribbon is composed of 4 color bands,		
; each of a different color.  By overlapping these 4 bands when 		
; printing, more colors can be obtained.  However, the number of colors 	
; that can be achieved by overlapping print bands is very limited (4 or 	
; 8 colors).									
;										
; THIS MODULE SELECT THE PRINTER COLOR THAT IS THE CLOSEST TO THE		
; DESIRED SCREEN COLOR. 							
;										
; The Band Mask specifies which color bands have to be overlapped to		
; obtain a color on the printer.						
;										
;										
; DESCRIPTION: Go through the list of printer colors in the SHARED DATA 	
; AREA, for each of these colors, compare its RGB values with those in		
; input.									
; Get the BAND_MASK of the closest printer color.				
;										
; LOGIC:									
;										
; Locate the printer colors info structure in the shared data area:		
; COLORPRINT_PTR := BP + COLORPRINT_PTR 					
;										
; Get the number of printer colors from the COLORPRINT info in the Shared	
; data area:									
; Number of colors  := COLORPRINT_PTR.NUM_PRT_COLOR				
;										
; CURRENT_COLOR_PTR : First record in the COLORPRINT info structure		
; BEST_CHOICE := CURRENT_RECORD_PTR.BAND_MASK					
; MIN_DIFF    := Maximum positive value 					
;										
; FOR each printer color:							
;   CUR_DIFF	:= 0								
; (* Calculate the geometric distance between the RGB values from the *)	
; (* input and those of the printer color.			      *)	
;   Red difference   := (R - CURRENT_COLOR_PTR.RED)				
;   Red difference   := Red difference * Red difference 			
;   CUR_DIFF	     := CUR_DIFF + Red difference				
;										
;   Green difference := (G - CURRENT_COLOR_PTR.GREEN)				
;   Green difference := Green difference * Green difference			
;   CUR_DIFF	     := CUR_DIFF + Green difference				
;										
;   Blue difference  := (B - CURRENT_COLOR_PTR.BLUE)				
;   Blue difference  := Blue difference  * Blue difference			
;   CUR_DIFF	     := CUR_DIFF + Blue difference				
;										
;   IF CUR_DIFF < MIN_DIFF							
;   THEN BEGIN									
;	 MIN_DIFF	:=  CUR_DIFF						
;	 BEST_CHOICE	:=  printer color.BAND_MASK				
;	 END									
;										
;   CURRENT_COLOR_PTR := Offset of next color					
; END (For each printer color)							
;										
; Return BEST_CHOICE								
;										
;										
RGB2BAND PROC NEAR								
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
										
;-------Process /R   (Reverse black and white)					
.IF <BIT DS:[BP].SWITCHES Z REVERSE_SW>  ; IF reverse is OFF			
.THEN					 ; THEN REVERSE BLACK AND WHITE:	
;------------------------------------------------------------------------------ 
;										
; REVERSE BLACK AND WHITE:							
;										
;------------------------------------------------------------------------------ 
;-------Test if the color is BLACK						
       .IF     <RGB.R EQ BLACK_INT> AND ; If black				
       .IF     <RGB.G EQ BLACK_INT> AND ;					
       .IF     <RGB.B EQ BLACK_INT>	;					
       .THEN				; then, replace it with the		
	  MOV	  BEST_CHOICE,0 	;	band mask for white		
	  JMP	  RGB2BAND_END		;	return this band mask		
       .ELSEIF <RGB.R EQ WHITE_INT> AND ; else if, high-intensity white 	
       .IF     <RGB.G EQ WHITE_INT> AND ;					
       .IF     <RGB.B EQ WHITE_INT>	;					
       .THEN				; then, replace it with the		
	  MOV	  RGB.R,BLACK_INT	;	RGB values of black		
	  MOV	  RGB.G,BLACK_INT						
	  MOV	  RGB.B,BLACK_INT						
       .ELSEIF <RGB.R EQ TWO_THIRD> AND ; else if, white			
       .IF     <RGB.G EQ TWO_THIRD> AND ;					
       .IF     <RGB.B EQ TWO_THIRD>	;					
       .THEN				; then, replace it with the		
	  MOV	  RGB.R,BLACK_INT	;	RGB values of black		
	  MOV	  RGB.G,BLACK_INT						
	  MOV	  RGB.B,BLACK_INT						
       .ENDIF									
.ENDIF										
;------------------------------------------------------------------------------ 
;										
; CALCULATE THE GEOMETRIC DISTANCE BETWEEN THE COLORS OF THE PIXEL AND THOSE OF 
; THE PRINTER:									
;										
;------------------------------------------------------------------------------ 
	MOV	BX,DS:[BP].COLORPRINT_PTR	; BX := OFFSET of COLORPRINT	
	ADD	BX,BP								
	MOV	MIN_DIFF,7FFFh			; No match yet, minimum diff.	
						;  is maximum POSITIVE value.	
	XOR	CX,CX								
	MOV	CL,DS:[BP].NUM_PRT_COLOR	; CX := Number of print colors	
										
										
INSPECT_1_PRINT_COLOR:								
	MOV	CUR_DIFF,0			; Current difference := 0	
;------------------------------------------------------------------------------ 
;	Calculate the Red difference:						
;------------------------------------------------------------------------------ 
	MOV	AL,RGB.R							
	SUB	AL,[BX].RED							
;-------Elevate at the power of two						
	MOV	DL,AL				; DX := Red difference		
	IMUL	DL				; AX := Red diff. square	
	ADD	CUR_DIFF,AX			; CURR_DIF + Red diff.		
										
;------------------------------------------------------------------------------ 
;	Calculate the Green difference: 					
;------------------------------------------------------------------------------ 
	MOV	AL,RGB.G							
	SUB	AL,[BX].GREEN							
;-------Elevate at the power of two						
	MOV	DL,AL				; DX := Red difference		
	IMUL	DL				; AX := Red diff. square	
	ADD	CUR_DIFF,AX			; CURR_DIF + Green diff.	
										
;------------------------------------------------------------------------------ 
;	Calculate the Blue difference:						
;------------------------------------------------------------------------------ 
	MOV	AL,RGB.B							
	SUB	AL,[BX].BLUE							
;-------Elevate at the power of two						
	MOV	DL,AL				; DX := Red difference		
	IMUL	DL				; AX := Red diff. square	
	ADD	CUR_DIFF,AX			; CURR_DIF + Blue diff. 	
										
;------------------------------------------------------------------------------ 
;	Check how close is this print color to the screen color:		
;------------------------------------------------------------------------------ 
	MOV	AX,CUR_DIFF		; If this color is better than what we	
       .IF <AX L MIN_DIFF>		;  had before.				
       .THEN				;					
	  MOV	  MIN_DIFF,AX		; then, new minimum distance;		
	  MOV	  AL,[BX].SELECT_MASK	;	get its band mask.		
	  MOV	  BEST_CHOICE,AL	;					
       .ENDIF				;					
										
;------------------------------------------------------------------------------ 
;	Get offset of next COLORPRINT info record:				
;------------------------------------------------------------------------------ 
	ADD	BX,SIZE COLORPRINT_STR						
	LOOP	INSPECT_1_PRINT_COLOR						
										
;------------------------------------------------------------------------------ 
;	BEST_CHOICE contains the print color with the closest RGB values	
;------------------------------------------------------------------------------ 
RGB2BAND_END:									
	POP	DX								
	POP	CX								
	POP	BX								
	POP	AX								
	MOV	AL,BEST_CHOICE							
	RET									
BEST_CHOICE	DB	?							
MIN_DIFF	DW	?							
CUR_DIFF	DW	?							
RGB2BAND ENDP									
CODE	ENDS									
	END									

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\grcommon.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:  I modified the procedures STORE_BOX, PRINT_BUFFER,
;**                GET_SCREEN_INFO, DET_CUR_SCAN_LNE_LENGTH, and NEW_PRT_LINE
;**                as follows.
;**  
;**                For STORE_BOX:
;**                  if data_type = data_row, then store printbox in print buffer
;**                     in row format - not column format.
;**  
;**                For PRINT_BUFFER:
;**                  if data_type = data_row, then print one byte at a time.
;**  
;**                For GET_SCREEN_INFO:
;**                  if data_type = data_row
;**                          nb_boxes_per_prt_buf = 8/box_height
;**                          if print_options = rotate
;**                                  nb_scan_lines = screen_width
;**                          else
;**                                  nb_scan_lines = screen_height
;**                          endif
;**                  endif
;**  
;**                For DET_CUR_SCAN_LNE_LENGTH:
;**                  if data_type = data_row
;**                          don't go down the columns to determine the scan_line_length
;**                  endif
;**  
;**                For NEW_PRT_LINE:
;**                  Altered it so send escape number sequence, COUNT or LOWCOUNT and
;**                  HIGHCOUNT, if they are specified before the new keyword DATA.
;**  
;**  
;**                I added the the procedures END_PRT_LINE and GET_COUNT, which
;**                are described below.
;**            
;**                END_PRT_LINE sends escape number sequence, COUNT or LOWCOUNT and
;**                HIGHCOUNT, if they are specified after the new keyword DATA
;**                in the GRAPHICS statement of the profile.  It also sends a
;**                CR & LF for IBM type printers if needed.
;**  
;**                GET_COUNT gets the number of bytes that are going to be sent to the
;**                printer and converts the number to ASCII if DATA_TYPE = DATA_ROW.
;**  
;**  BUG NOTES:     The   following   bug   was  fixed   for   the   pre-release  
;**                 version Q.01.02.
;**  
;**  BUG (mda003)
;**  ------------
;**  
;**  NAME:     GRAPHICS   prints  a CR & LF after  each  scan line unless it  is 
;**            loaded twice.  
;**  
;**  FILES & PROCEDURES AFFECTED:  GRLOAD3.ASM - PARSE_GRAPHICS
;**                                GRCOMMON.ASM - END_PRT_LINE
;**                                GRSHAR.STR - N/A
;**  
;**  CAUSES:   The local variables LOWCOUNT_FOUND, HIGHCOUNT_FOUND CR_FOUND  and 
;**            LF_FOUND used for loading, were incorrectly being used as  global 
;**            variables during printing.
;**  
;**  FIX:      Created  a new variable Printer_Needs_CR_LF in GRSHAR.STR,  which 
;**            is  used  to  determine  in GRCOMMON.ASM  if  it's  necessary  to 
;**            manually  send  a  CR  & LF to the printer  at  print  time.  The 
;**            variable  is  set at load time in GRLOAD3.ASM, if  the  variables 
;**            Data_Found and Build_State are set. 
;**  
;**  DOCUMENTATION NOTES:  This version of GRCOMMON.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;************************************************************
	PAGE	,132								;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                              
;;										;AN000;
;; File Name:  GRCOMMON.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;										;AN000;
;;	 This file contains the modules common to the Print Screen		;AN000;
;;	 process of GRAPHICS.COM.						;AN000;
;;	 This file is included by both set of Print modules.			;AN000;
;;										;AN000;
;;	 This file MUST BE COMPILED WITH EACH SET OF MODULES since,		;AN000;
;;	 one set is relocated in memory at installation time; all		;AN000;
;;	 references to the common procedures must be resolved from		;AN000;
;;	 within each set of print modules.					;AN000;
;;										;AN000;
;;	 The set of common modules is relocated in memory along with		;AN000;
;;	 the selected set of print modules.					;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	READ_DOT								;AN000;
;;	LOC_MODE_PRT_INFO							;AN000;
;;	STORE_BOX								;AN000;
;;	PRINT_BUFFER								;AN000;
;;	GET_SCREEN_INFO 							;AN000;
;;	SETUP_PRT								;AN000;
;;	RESTORE_PRT								;AN000;
;;	NEW_PRT_LINE								;AN000;
;;	PRINT_BYTE								;AN000;
;;	DET_CUR_SCAN_LNE_LENGTH 						;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;;              Added the following procedures to support printers with horizontal
;;              printer heads, such as an HP PCL printers.
;;      GET_COUNT
;;      END_PRT_LINE
; /\ ~~mda(001) -----------------------------------------------------------------------
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRCTRL.ASM: 						;AN000;
;;	      PRT_SCR	       - Main module for printing the screen.		;AN000;
;;	 FROM FILE  GRBWPRT.ASM:						;AN000;
;;	      PRT_BW_APA       - Main module for printing on BW printer.	;AN000;
;;	 FROM FILE  GRCOLPRT.ASM:						;AN000;
;;	      PRINT_COLOR      - Main module for printing on COLOR printer.	;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;										;AN000;
;;	 This file is included by both GRBWPRT.ASM and GRCOLPRT.ASM and is	;AN000;
;;	 compiled with each of them. However, only one copy is made resident.	;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; LOC_MODE_PRT_INFO: LOCATE DISPLAYMODE PRINTER INFO. FOR THE CURRENT		;AN000;
;		     MODE							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP		= Offset of the shared data area		;AN000;
;		CUR_MODE	= Current video mode				;AN000;
;										;AN000;
;	OUTPUT: CUR_MODE_PTR	= Absolute Offset of the			;AN000;
;				  current DISPLAYMODE INFO record.		;AN000;
;										;AN000;
;		ERROR_CODE	= DISPLAYMODE_INFO_NOT_FOUND if not found.	;AN000;
;										;AN000;
;	CALLED BY: PRINT_COLOR							;AN000;
;		   PRINT_BW_APA 						;AN000;
;										;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION:	DISPLAYMODE_PTR is pointing to the first DISPLAYMODE		;AN000;
; INFO record within the Shared Data Area.					;AN000;
;										;AN000;
; This (chained) list of DISPLAYMODE records is scanned until the record	;AN000;
; for the current mode is found.						;AN000;
;										;AN000;
; Note: All pointers in the DISPLAYMODE records are relative to the beginning	;AN000;
;	of the shared data area. Therefore, we must add the offset of the	;AN000;
;	shared data area (in BP) in order to access the data these pointers	;AN000;
;	are referencing.							;AN000;
;										;AN000;
;	The CUR_MODE_PTR is relative to the segment and references the		;AN000;
;	DISPLAYMODE record for the video mode currently set at print screen	;AN000;
;	time.									;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; FOUND := FALSE								;AN000;
; DO UNTIL FOUND OR END_OF_LIST 						;AN000;
;   Get a display mode information record					;AN000;
;   IF record.DISP_MODE = CUR_MODE						;AN000;
;     THEN FOUND := TRUE							;AN000;
;   ELSE									;AN000;
;     CUR_MODE_PTR := record.NEXT_DISP_MODE					;AN000;
;										;AN000;
;										;AN000;
										;AN000;
LOC_MODE_PRT_INFO PROC NEAR							;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
	PUSH	SI								;AN000;
										;AN000;
	MOV	BX,DS:[BP].DISPLAYMODE_PTR	; [BX] := Current DISPLAYMODE	;AN000;
	ADD	BX,BP				;	   record		;AN000;
	MOV	DL,CUR_MODE			; DL := Current mode		;AN000;
										;AN000;
SCAN_1_DISPLAYMODE_RECORD:							;AN000;
	MOV	SI,[BX].DISP_MODE_LIST_PTR	; [SI] : First mode covered	;AN000;
	ADD	SI,BP				;    by this DISPLAYMODE record ;AN000;
	MOV	CL,[BX].NUM_DISP_MODE		; Scan each mode in the list	;AN000;
	XOR	CH,CH								;AN000;
SCAN_LIST_OF_MODES:								;AN000;
	CMP	CS:[SI],DL			; FOUND ?			;AN000;
	JE	FOUND								;AN000;
	INC	SI				; NO, get next mode in		;AN000;
	LOOP	SCAN_LIST_OF_MODES		;      DISPLAYMODE record	;AN000;
										;AN000;
	CMP	[BX].NEXT_DISP_MODE,-1		; END OF DISPLAYMODE LIST ?	;AN000;
	JE	NOT_FOUND			; Yes, this mode not supported	;AN000;
NEXT_RECORD:					; No,				;AN000;
	MOV	BX,[BX].NEXT_DISP_MODE		;     [BX] := Next record	;AN000;
	ADD	BX,BP				;				;AN000;
	JMP	SHORT SCAN_1_DISPLAYMODE_RECORD 				;AN000;
										;AN000;
FOUND:						; Found:			;AN000;
	MOV	CUR_MODE_PTR,BX 		; Update pointer to current	;AN000;
	JMP	SHORT LOC_MODE_PRT_INFO_END	; DISPLAYMODE record.		;AN000;
										;AN000;
NOT_FOUND:					; Not found:			;AN000;
	MOV	ERROR_CODE,DISPLAYMODE_INFO_NOT_FOUND ; Return error condition	;AN000;
										;AN000;
LOC_MODE_PRT_INFO_END:								;AN000;
	POP	SI								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
LOC_MODE_PRT_INFO ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; STORE_BOX : STORE ONE BOX IN THE PRINT BUFFER.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	SI	   = OFFSET OF THE BOX TO BE PRINTED			;AN000;
;		BOX_W	   = BOX WIDTH IN BITS					;AN000;
;		BOX_H	   = BOX HEIGHT IN BITS 				;AN000;
;										;AN000;
;	OUTPUT: PRT_BUF  = THE PRINT BUFFER					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: The print buffer is first shifted left in order to make		;AN000;
; room for the new box (Note: the MSB's are lost; they are assumed to           ;AN000;
; have been printed), then the box is inserted in the low-order bits of 	;AN000;
; the printer buffer.								;AN000;
;										;AN000;
PAGE										;AN000;
;			      EXAMPLE						;AN000;
;			      -------						;AN000;
; BEFORE:				     AFTER:				;AN000;
;										;AN000;
; BOX: 0    0	0								;AN000;
;      0    0	0								;AN000;
;      0    0	0								;AN000;
;      0    0	0								;AN000;
;      0    0	0								;AN000;
;      0    0	0								;AN000;
;      b1  b2  b3								;AN000;
;      b4  b5  b6								;AN000;
;										;AN000;
; PRT_BUF: byte1 byte2 byte3		     PRT_BUF:  byte1 byte2 byte3	;AN000;
;	     0	   1	 0				 1     1     1		;AN000;
;	     1	   0	 1				 1     1     1		;AN000;
;	     1	   1	 1				 1     1     1		;AN000;
;	     1	   1	 1				 1     1     1		;AN000;
;	     1	   1	 1				 1     1     1		;AN000;
;	     1	   1	 1				 1     1     1		;AN000;
;	     1	   1	 1				 b1    b2    b3 	;AN000;
;    LSB --> 1	   1	 1				 b4    b5    b6 	;AN000;
;										;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; FOR each byte of the buffer (BOX_W)						;AN000;
;   BEGIN									;AN000;
;   Make room for the box to be inserted					;AN000;
;   Insert the box								;AN000;
;   END 									;AN000;
;										;AN000;
STORE_BOX PROC NEAR								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DI								;AN000;
										;AN000;
	MOV	DI,OFFSET PRT_BUF ; DI := Offset of the Print buffer		;AN000;
       	XOR	BX,BX		        ; BX := Byte index number			;AN000;

; \/ ~~mda(001) -----------------------------------------------------------------------
;               Added the following modification to support printers with
;               vertical print heads, such as HP PCL printers.  The code
;               as is does not work for these printers because the data
;               is being stored in the print buffer with the assumption
;               that the print head is vertical.
;
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>
                PUSH    AX              ; 
                PUSH    DX              ;
                PUSH    BP              ;
                MOV     CL,BOX_W        ; Make room for the bits to be inserted.
                SHL     BYTE PTR [BX][DI],CL    ;
                MOV     CL,DS:[BP].ROW_TO_EXTRACT       ; CL determines which row we're extracting
                XOR     BP,BP           ; Point to first column.
                XOR     DX,DX           ; Clear counter
                XOR     AX,AX           ; Clear register
                                        ;
EXTRACT_NEXT_BIT:                       ;
                                        ;
                SHL     AH,1            ; Make room for next bit
                MOV     AL,DS:[SI][BP]  ; Read column
                SHR     AL,CL           ; Get bit from row we're extracting
                AND     AL,1            ; Isolate bit we got from row we're extracting
                OR      AH,AL           ; Place it in AH
                INC     BP              ; Advance to next column
                INC     DL              ; Inc. counter
                CMP     DL,BOX_W        ; Check if have more bits to extract from the row
                JL      EXTRACT_NEXT_BIT; We do
                OR      DS:[DI][BX],AH  ; We don't so place the row we extracted in the 
                                        ; print buffer.
                POP     BP              ;
                POP     DX              ; 
                POP     AX              ;
       .ELSE                            ;
; /\ ~~mda(001) -----------------------------------------------------------------------
										        ;AN000;
	        MOV	CL,BOX_H	        ; CL := Number of BITS to be shifted		;AN000;
; FOR each column (byte) of the box to be stored in the buffer: 		;AN000;
STORE_1_BYTE:				        					;AN000;
	        SHL	BYTE PTR [BX][DI],CL	; Make room for the bits to be inserted ;AN000;
	        MOV	CH,[BX][SI]		; CH := column of the box to be inserted;AN000;
	        OR	[BX][DI],CH		; Insert the box column in the buffer	;AN000;
	        INC	BL			; Get next column (byte) of the box	;AN000;
	        CMP	BL,BOX_W		; All columns (bytes) of box stored ?	;AN000;
	        JL	STORE_1_BYTE		; No, store next one.			;AN000;
       .ENDIF                                   ; ~~mda(001) Close the IF stmt										        ;AN000;
STORE_BOX_END:									;AN000;
	POP	DI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
STORE_BOX ENDP									;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PRINT_BUFFER : PRINT THE BUFFER						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	PRT_BUF  = BYTES TO BE PRINTED					;AN000;
;		BOW_W	 = BOX WIDTH						;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Prints BOX_W bytes.						;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; DO for each column in one pattern						;AN000;
;   BEGIN									;AN000;
;   Print one byte from the buffer						;AN000;
;   END 									;AN000;
;										;AN000;
PRINT_BUFFER PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	BX,OFFSET PRT_BUF						;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               If DATA_TYPE = DATA_ROW then the most we store in the print
;               buffer at one time is one byte.
.IF <DS:[BP].DATA_TYPE EQ DATA_ROW>     ;
	MOV	AL,[BX] 	        ; Print one byte				
	CALL	PRINT_BYTE		;					
	JC	PRINT_BUFFER_END        ; If printer error, quit the loop	
.ELSE
; /\ ~~mda(001) -----------------------------------------------------------------------
	XOR	CX,CX								;AN000;
	MOV	CL,BOX_W							;AN000;
PRINT_1_BUF_COLUMN:								;AN000;
	MOV	AL,[BX] 	; Print one byte				;AN000;
	CALL	PRINT_BYTE							;AN000;
	JC	PRINT_BUFFER_END; If printer error, quit the loop		;AN000;
	INC	BX		; Get next byte 				;AN000;
	LOOP	PRINT_1_BUF_COLUMN						;AN000;
.ENDIF                          ;~~mda(001) close IF stmt
PRINT_BUFFER_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PRINT_BUFFER ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; GET_SCREEN_INFO : GET INFORMATION ABOUT HOW TO READ THE SCREEN.		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	SCREEN_HEIGHT	  = Number of pixel rows on the screen		;AN000;
;		SCREEN_WIDTH	  = Number of pixel columns on screen		;AN000;
;		CUR_MODE_PTR	  = Offset of the current DISPLAYMODE info rec. ;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;		SCAN_LINE_MAX_LENGTH = Maximum length of Screen scan line.	;AN000;
;		NB_SCAN_LINES	  = Number of SCAN LINES on the screen		;AN000;
;		CUR_ROW,CUR_COLUMN = Coordinates of the first pixel to be	;AN000;
;					 read on the screen			;AN000;
;		NB_BOXES_PER_PRT_BUF = Number of boxes fitting in the Print	;AN000;
;				       buffer					;AN000;
;										;AN000;
;	CALLED BY: PRINT_COLOR							;AN000;
;		   PRT_BW_APA							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION:									;AN000;
;										;AN000;
;    1) Determine where to start reading the screen.				;AN000;
;	For non-rotated printing, it should start with the top-left		;AN000;
;	corner pixel.								;AN000;
;	For rotated printing, it should start with the low-left corner		;AN000;
;	pixel.									;AN000;
;										;AN000;
;    2) Determine the length of a scan line.					;AN000;
;	For non-rotated printing, it is the WIDTH of the screen.		;AN000;
;	For rotated printing, it is the HEIGHT of the screen.			;AN000;
;										;AN000;
;    3) Determine the number of scan lines on the screen.			;AN000;
;	For non-rotated printing, it is the HEIGHT of the screen divided	;AN000;
;	by the number of boxes fitting in the print buffer.			;AN000;
;	For rotated printing, it is the WIDTH of the screen divided by		;AN000;
;	the number of boxes fitting in the print buffer.			;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; CUR_COLUMN   := 0								;AN000;
; IF printing is sideways							;AN000;
;   THEN									;AN000;
;     CUR_ROW := SCREEN_HEIGHT - 1	  ; Low-left pixel			;AN000;
;     SCAN_LINE_MAX_LENGTH := SCREEN_HEIGHT					;AN000;
;     NB_SCAN_LINES :=	SCREEN_WIDTH / NB_BOXES_PER_PRT_BUF			;AN000;
;   ELSE									;AN000;
;     CUR_ROW := 0			  ; Top-left pixel			;AN000;
;     SCAN_LINE_MAX_LENGTH := SCREEN_WIDTH					;AN000;
;     NB_SCAN_LINES :=	SCREEN_HEIGHT / NB_BOXES_PER_PRT_BUF			;AN000;
;										;AN000;
;										;AN000;
GET_SCREEN_INFO PROC NEAR							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX			; Used for DIV				;AN000;
	PUSH	DX			; Used for DIV				;AN000;
										;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Offset DISPLAYMODE info record	;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Calculate how many printer boxes fit in the print buffer:			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               The NB_BOXES_PER_PRT_BUF depends on if the printer head is
;               vertical, as in IBM's case, or if it's horizontal, as in
;               HP's case.  If DATA_TYPE is DATA_COL, then we have a vertical
;               print head.  If DATA_TYPE is DATA_ROW, then we have a 
;               horizontal print head.
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>      ; Print head is horizontal
            MOV	AX,8			; Num := 8 bits / Box width		
            MOV	DL,[BX].BOX_WIDTH	;					
            DIV	DL			;					
            MOV	NB_BOXES_PER_PRT_BUF,AL ;					
       .ELSE                            ;
; /\ ~~mda(001) -----------------------------------------------------------------------
	    MOV	AX,8			; Num := 8 bits / Box heigth		;AN000;
	    MOV	DL,[BX].BOX_HEIGHT						;AN000;
	    DIV	DL								;AN000;
	    MOV	NB_BOXES_PER_PRT_BUF,AL 					;AN000;
       .ENDIF                           ; ~~mda(001) Close IF stmt.
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Determine where to start reading the screen:					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	CUR_COLUMN,0		; Reading always start from left of scr ;AN000;
.IF <[BX].PRINT_OPTIONS EQ ROTATE>						;AN000;
.THEN										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Printing is sideways; screen must be read starting in low-left corner.	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	AX,SCREEN_HEIGHT						;AN000;
	MOV	SCAN_LINE_MAX_LENGTH,AX ; Scan line length := screen height	;AN000;
	DEC	AX								;AN000;
	MOV	CUR_ROW,AX		; First row := screen height - 1	;AN000;
										;AN000;
;-------Calculate the number of scan lines:					;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               The NB_SCAN_LINES depends on if the printer head is
;               vertical, as in IBM's case, or if it's horizontal, as in
;               HP's case.  If the printer head is horizontal, then we can't
;               make use of the concept of scan lines.  However, we can still
;               use the symbol NB_SCAN_LINES by just stuffing into it the
;               screen width.
;
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>      ; Print head is horizontal
            MOV	        AX,SCREEN_WIDTH ; DX AX = Screen width			
            CWD                         ;
            MOV         NB_SCAN_LINES,AX;
       .ELSE
; /\ ~~mda(001) -----------------------------------------------------------------------        
            MOV	        AX,SCREEN_WIDTH         ; DX AX = Screen width			;AN000;
	    CWD				        ;					;AN000;
	    XOR	        BX,BX		        ; BX	= Number of boxes per print buf ;AN000;
	    MOV	        BL,NB_BOXES_PER_PRT_BUF ;					;AN000;
	    DIV	        BX			; Screen width / number boxes per buff	;AN000;
	    MOV	        NB_SCAN_LINES,AX	; Number of scan lines := result	;AN000;
           .ENDIF                               ; ~~mda(001) Close IF stmt.

.ELSE										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Printing is not sideways; screen must be read starting in top-left corner	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	AX,SCREEN_WIDTH 						;AN000;
	MOV	SCAN_LINE_MAX_LENGTH,AX ; Scan line length := screen width	;AN000;
	MOV	CUR_ROW,0		; First row := 0			;AN000;
										;AN000;
;-------Calculate the number of scan lines:					;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               The NB_SCAN_LINES depends on if the printer head is
;               vertical, as in IBM's case, or if it's horizontal, as in
;               HP's case.  If the printer head is horizontal, then we can't
;               make use of the concept of scan lines.  However, we can still
;               use the symbol NB_SCAN_LINES by just stuffing into it the
;               screen height.
;
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>      ; Print head is vertical
            MOV	        AX,SCREEN_HEIGHT; DX AX = Screen height			
            CWD                         ;
            MOV         NB_SCAN_LINES,AX;
       .ELSE
; /\ ~~mda(001) -----------------------------------------------------------------------        
 
	MOV	AX,SCREEN_HEIGHT	; DX AX = Screen height 		;AN000;
	CWD				;					;AN000;
	XOR	BX,BX			; BX  = Number of boxes per print buff	;AN000;
	MOV	BL,NB_BOXES_PER_PRT_BUF ;					;AN000;
	DIV	BX			; Screen height/number boxes per buff.	;AN000;
	MOV	NB_SCAN_LINES,AX	; Number of scan lines := result	;AN000;
       .ENDIF                           ; ~~mda(001) Close IF stmt.

.ENDIF										;AN000;
	POP	DX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
GET_SCREEN_INFO ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; DET_CUR_SCAN_LNE_LENGTH : Determine where is the last non-blank "scan line    ;AN000;
;				column" on the current scan line.               ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;     INPUT:  CUR_ROW,								;AN000;
;	      CUR_COLUMN	  = Coordinates of the top pixel of the current ;AN000;
;				    scan line.					;AN000;
;	      XLT_TAB		  = Color translation table			;AN000;
;										;AN000;
;     OUTPUT: CUR_SCAN_LNE_LENGTH = Number of "columns" of pixels from the      ;AN000;
;				    beginning of the scan line up to		;AN000;
;				    the last non-blank pixel.			;AN000;
;										;AN000;
; DATA	      SCREEN_WIDTH,							;AN000;
; REFERENCED: SCREEN_HEIGHT	  = Dimensions of the screen in pels		;AN000;
;	      SCAN_LINE_MAX_LENGTH= Maximum length of the scan line		;AN000;
;	      ROTATE_SW 	  = ON if printing is sideways			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Determine where is the last non-blank "column" by reading        ;AN000;
; the scan line backwards, one column at a time.				;AN000;
;										;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; ; Obtain coordinates for the top pixel of the last column on the current	;AN000;
; ; scan line:									;AN000;
; IF printing is sideways							;AN000;
;   THEN									;AN000;
;   CUR_ROW := 0								;AN000;
; ELSE										;AN000;
;   CUR_COLUMN := SCREEN_WIDTH - 1						;AN000;
;										;AN000;
; CUR_SCAN_LNE_LENGTH := SCAN_LINE_MAX_LENGTH					;AN000;
; ; Read a column of pixels on the scan line until a non-blank is found:	;AN000;
; For each column on the screen 						;AN000;
;   CALL FILL_BUFF								;AN000;
; ; Check if PRT_BUF is empty							;AN000;
;   IF buffer is empty								;AN000;
;     THEN DEC	CUR_SCAN_LNE_LENGTH						;AN000;
;	   ; Get next column							;AN000;
;	   IF printing sideways THEN DEC CUR_ROW				;AN000;
;				ELSE DEC CUR_COLUMN				;AN000;
;   ELSE quit the loop								;AN000;
;										;AN000;
DET_CUR_SCAN_LNE_LENGTH PROC NEAR						;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
	PUSH	CUR_COLUMN							;AN000;
	PUSH	CUR_ROW 							;AN000;
										;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of XLT_TAB		;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Obtain coordinates of the top pixel for the last column of the current	;AN000;
; scan line:									;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				; then, 				;AN000;
	  MOV	  CUR_ROW,0		;   CUR_ROW := 0			;AN000;
       .ELSE				; else, 				;AN000;
	  MOV	  CX,SCREEN_WIDTH	;   CUR_COLUMN := SCREEN_WIDTH - 1	;AN000;
	  DEC	  CX			;					;AN000;
	  MOV	  CUR_COLUMN,CX 	;					;AN000;
       .ENDIF									;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Read the scan line backwards "column" by "column" until a non-blank is found: ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	CX,SCAN_LINE_MAX_LENGTH ; CX := current length			;AN000;
;										;AN000;
;-------For each "column"                                                       ;AN000;
CHECK_1_COLUMN: 								;AN000;
	MOV	SI,CUR_ROW		; Save coordinates of the column	;AN000;
	MOV	DI,CUR_COLUMN		; in SI, DI				;AN000;
	XOR	DL,DL			; DL := Number of pixels verified in	;AN000;
					;	  one "column"                  ;AN000;
;										;AN000;
;-------For each pixel within that "column"                                     ;AN000;
CHECK_1_PIXEL:									;AN000;
	CALL	READ_DOT		; AL := Index into translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Band mask or Intensity		;AN000;
										;AN000;
;-------Check if pixel will map to an empty box:				;AN000;
       .IF <DS:[BP].PRINTER_TYPE EQ BLACK_WHITE> ; If BLACK AND WHITE printer	;AN000;
       .THEN				; then, check for intensity of white	;AN000;
	  CMP	  AL,WHITE_INT		;      If curent pixel not blank	;AN000;
	  JNE	  DET_LENGTH_END	;      THEN, LEAVE THE LOOP		;AN000;
       .ELSE				; else, COLOR printer			;AN000;
	  OR	  AL,AL 		;      IF Band mask not blank		;AN000;
	  JNZ	  DET_LENGTH_END	;      THEN, LEAVE THE LOOP		;AN000;
       .ENDIF									;AN000;
										;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Only if DATA_TYPE is DATA_COL do we have "columns",
;               so skip this section otherwise.
       .IF <DS:[BP].DATA_TYPE EQ DATA_COL> ; Print head is vertical
; /\ ~~mda(001) ----------------------------------------------------------------------- 
;-------All pixels so far on this "column" are blank, get next pixel:           ;AN000;
               .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
               .THEN				;					;AN000;
	                INC CUR_COLUMN		; then, increment column number 	;AN000;
               .ELSE				;					;AN000;
	                INC CUR_ROW			; else, increment row number		;AN000;
               .ENDIF				;					;AN000;
	        INC	DL			; One more pixel checked		;AN000;
	        CMP	DL,NB_BOXES_PER_PRT_BUF ; All pixels for that column done ?	;AN000;
	        JL	CHECK_1_PIXEL		;   No, check next one. 		;AN000;
       .ENDIF                                   ;~~mda(001) Close IF stmt.
										;AN000;
;-------Nothing to print for this column, get next column			;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				; then, 				;AN000;
	  MOV CUR_COLUMN,DI		;   Restore column number		;AN000;
	  INC CUR_ROW			;   Get next row			;AN000;
       .ELSE				; else, 				;AN000;
	  MOV CUR_ROW,SI		;   Restore row number			;AN000;
	  DEC CUR_COLUMN		;   Get next column			;AN000;
       .ENDIF				;					;AN000;
	LOOP CHECK_1_COLUMN		; CX (length) := CX - 1 		;AN000;
										;AN000;
DET_LENGTH_END: 								;AN000;
	MOV	CUR_SCAN_LNE_LENGTH,CX	; Get current length			;AN000;
										;AN000;
	POP	CUR_ROW 							;AN000;
	POP	CUR_COLUMN							;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
DET_CUR_SCAN_LNE_LENGTH ENDP							;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; SETUP_PRT : SET UP THE PRINTER FOR PRINTING IN GRAPHIC MODE			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: CUR_MODE_PTR = Offset of the DISPLAYMODE information		;AN000;
;			      record for the current mode			;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;	CALLED BY: PRINT_COLOR							;AN000;
;		   PRT_BW_APA							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Extract the SETUP escape sequence from the DISPLAYMODE		;AN000;
; information record; Send this escape sequence to the printer. 		;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Number of bytes to print := CUR_MODE_PTR.NUM_SETUP_ESC			;AN000;
;										;AN000;
; Get the escape sequence:							;AN000;
; SI := CUR_MODE_PTR.SETUP_ESC_PTR						;AN000;
;										;AN000;
; FOR each byte to be printed							;AN000;
;   PRINT_BYTE [SI]			; Send the byte to the printer		;AN000;
;   INC SI				; Get the next byte			;AN000;
;										;AN000;
SETUP_PRT PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Displaymode info record.	;AN000;
										;AN000;
	XOR	CX,CX			; CX := Number of bytes to print	;AN000;
	MOV	CL,[BX].NUM_SETUP_ESC	;					;AN000;
.IF <CL G 0>				; If there is at least one		;AN000;
.THEN					; byte to be printed:			;AN000;
	MOV	BX,[BX].SETUP_ESC_PTR	; BX := Offset sequence to send 	;AN000;
	ADD	BX,BP								;AN000;
										;AN000;
SEND_1_SETUP_BYTE:								;AN000;
	MOV	AL,[BX] 		; AL := byte to print			;AN000;
	CALL	PRINT_BYTE		; Send it to the printer		;AN000;
	JC	SETUP_PRT_END		; If printer error, quit the loop	;AN000;
	INC	BX			; Get next byte 			;AN000;
	LOOP	SEND_1_SETUP_BYTE						;AN000;
.ENDIF										;AN000;
SETUP_PRT_END:									;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
SETUP_PRT ENDP									;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; RESTORE_PRT : RESTORE THE PRINTER TO ITS INITIAL STATUS			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: CUR_MODE_PTR = Offset of the DISPLAYMODE information		;AN000;
;				 record for the current mode			;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;	CALLED BY: PRINT_COLOR							;AN000;
;		   PRT_BW_APA							;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Extract the RESTORE escape sequence from the DISPLAYMODE 	;AN000;
; information record; Send this escape sequence to the printer. 		;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Number of bytes to print := CUR_MODE_PTR.NUM_RESTORE_ESC			;AN000;
;										;AN000;
; Get the escape sequence:							;AN000;
; SI := CUR_MODE_PTR.RESTORE_ESC_PTR						;AN000;
; FOR each byte to be printed							;AN000;
;   PRINT_BYTE [SI]			; Send the byte to the printer		;AN000;
;   INC SI				; Get the next byte			;AN000;
;										;AN000;
RESTORE_PRT PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Displaymode info record.	;AN000;
										;AN000;
	XOR	CX,CX			; CX := Number of bytes to print	;AN000;
	MOV	CL,[BX].NUM_RESTORE_ESC 					;AN000;
.IF <CL G 0>				; If there is at least one		;AN000;
.THEN					; byte to be printed:			;AN000;
	MOV	BX,[BX].RESTORE_ESC_PTR ; BX := Offset sequence to send 	;AN000;
	ADD	BX,BP								;AN000;
										;AN000;
SEND_1_RESTORE_BYTE:								;AN000;
	MOV	AL,[BX] 		; AL := byte to print			;AN000;
	CALL	PRINT_BYTE		; Send it to the printer		;AN000;
	JC	RESTORE_PRT_END 	; If printer error, quit the loop	;AN000;
	INC	BX			; Get next byte 			;AN000;
	LOOP	SEND_1_RESTORE_BYTE						;AN000;
.ENDIF										;AN000;
RESTORE_PRT_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
RESTORE_PRT ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; NEW_PRT_LINE : INITIALIZE THE PRINTER FOR A GRAPHIC LINE			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: CUR_MODE_PTR = Offset of the DISPLAYMODE information		;AN000;
;				 record for the current mode			;AN000;
;	       CUR_SCAN_LNE_LENGTH = Number of bytes to send to the printer.	;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;	CALLED BY: PRINT_BAND							;AN000;
;		   PRT_BW_APA							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Extract the GRAPHICS escape sequence from the DISPLAYMODE	;AN000;
; information record; Send this escape sequence to the printer. 		;AN000;
; Then, send the number of bytes that will follow.				;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Number of bytes to print := CUR_MODE_PTR.NUM_GRAPHICS_ESC			;AN000;
;										;AN000;
; Get the escape sequence:							;AN000;
; Set up the 2 bytes containing the number of bytes to send in this sequence.	;AN000;
; SI := CUR_MODE_PTR.GRAPHICS_ESC_PTR						;AN000;
;										;AN000;
; FOR each byte to be printed							;AN000;
;   PRINT_BYTE [SI]			; Send the byte to the printer		;AN000;
;   INC SI				; Get the next byte			;AN000;
;										;AN000;
; Send the byte count								;AN000;
;										;AN000;
										;AN000;
NEW_PRT_LINE PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
	PUSH	DI								;AN000;
										;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Displaymode info record.	;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set up the 2 bytes containing the number of bytes to send in the GRAPHICS seq.;AN000;
; NOTE: number of bytes to send is "CUR_SCAN_LNE_LENGTH * BOX_W"                ;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	AL,BOX_W		;   cur_scan_lne_length *		;AN000;
	CBW				;   printer box width = nb bytes to send;AN000;
	MUL	CUR_SCAN_LNE_LENGTH	;     (result in DX AX) 		;AN000;
;-------AX := Number of bytes to print						;AN000;

; \/ ~~mda(001) -----------------------------------------------------------------------
;               Since we have added the key words DATA and COUNT to the		
;               list of allowable words for the GRAPHICS statement
;               we have to take into consideration if the esc. sequence
;               numbers come before of after the word DATA.  Also we have
;               to take into consideration if the printer is expecting
;               to receive the COUNT in binary form or in ASCII form.
;               Note this section of code replaces the section of code
;               which follows it.
        MOV     DI,[BX].GRAPHICS_ESC_PTR        ; DI := offset seq. to send
	XOR	CX,CX				; CX := Length of the escape seq
        MOV	CL,[BX].NUM_GRAPHICS_ESC	;	before the word DATA			
        
       .WHILE <CX NE 0>         ; Doing while loop just in case DATA is the 
                                ; first word after  GRAPHICS.  In that case 
                                ; skip this and send the actual data.
                 MOV    BL,BYTE PTR DS:[BP+DI]            ; Get code.
                                                          ;
                .SELECT                                   ; Case statement
                .WHEN <BL EQ ESC_NUM_CODE>                ; We have an esc. number
       	                PUSH      AX                      ; Save count
                        INC       DI                      ; Point to esc. number
                        MOV       AL,DS:[BP+DI]           ;
                        CALL      PRINT_BYTE              ; Send esc. number
                        JC        NEW_PRT_LINE_ENDP_1     ; If printer error then quit 
                                                          ; the loop and restore registers
                        INC       DI                      ; Point to next tag
                        POP       AX                      ; Restore the count
                        DEC       CX                      ;
                .WHEN <BL EQ COUNT_CODE>                  ; Need to send count in ascii form
       	                PUSH      AX                      ; Save count
                        PUSH      SI                      ;
                        CALL      GET_COUNT               ; Get # bytes to send to printer
                        PUSH      CX                      ; Save counter for outside loop
                        XOR       CH,CH                   ;
                        MOV       CL,DS:[BP].NUM_BYTES_FOR_COUNT        ;
                        LEA       SI,DS:[BP].COUNT        ; Get ptr. to count
                        SUB       SI,CX                   ; Need to send MSB first
                        INC       SI                      ;
                        CLD                               ;
SEND_ASCII_COUNT:                                         ;
                        LODSB                             ;
                        CALL      PRINT_BYTE              ; Print it
                        JC        NEW_PRT_LINE_ENDP_2     ; If printer error then quit 
                                                          ; the loop and restore registers
                        LOOP      SEND_ASCII_COUNT        ;
                        POP       CX                      ; Restore outside loop counter
                        ADD       DI,2                    ; Point to next tag
                        POP       SI                      ;
                        POP       AX                      ; Restore COUNT
                        DEC       CX                      ;
                .WHEN <BL EQ LOWCOUNT_CODE>               ; Sending lowbyte of COUNT 
                        CALL      PRINT_BYTE              ; Print it
                        JC        NEW_PRT_LINE_ENDP       ; If printer error then quit 
                        ADD       DI,2                    ; Point to next tag
                        DEC       CX                      ;
                .WHEN <BL EQ HIGHCOUNT_CODE>              ; Sending highbyte of COUNT
       	                PUSH      AX                      ; Save count 
                        CWD                               ;
                        MOV       BX,100h                 ;
                        DIV       BX                      ; Put highbyte in AL
                        CALL      PRINT_BYTE              ; Print it
                        JC        NEW_PRT_LINE_ENDP_1     ; If printer error then quit 
                                                          ; the loop and restore registers
                        ADD       DI,2                    ; Point to next tag
                                                          ; the loop.
                        POP       AX                      ; Restore count
                        DEC       CX                      ;
                .ENDSELECT                                ;
       .ENDWHILE                                          ;
        ADD	DI,2                                      ; Skip over DATA tag and byte 
                                                          ; so pointing to correct place when 
                                                          ; get to END_PRT_LINE proc.
; /\ ~~mda(001) -----------------------------------------------------------------------

; \/ ~~mda(001) -----------------------------------------------------------------------
;               The following piece of code is replaced by the above piece
;               of code.
;
;;;;    MOV	DI,[BX].LOW_BYT_COUNT_PTR; DI := Offset of LOW byte of		;AN000;
;;;;	ADD	DI,BP			;	 byte count			;AN000;
;;;;	MOV	[DI],AL 		; Store low byte			;AN000;
;;;;	MOV	DI,[BX].HGH_BYT_COUNT_PTR; DI := Offset of HIGH byte of 	;AN000;
;;;;	ADD	DI,BP			;	 byte count			;AN000;
;;;;	MOV	[DI],AH 		; Store high byte			;AN000;
;;;;										;AN000;
;;;;;-------------------------------------------------------------------------------;AN000;
;;;;; Send the GRAPHICS escape sequence to the printer:				;AN000;
;;;;;-------------------------------------------------------------------------------;AN000;
;;;;	XOR	CX,CX				; CX := Length of the escape seq;AN000;
;;;;	MOV	CL,[BX].NUM_GRAPHICS_ESC					;AN000;
;;;;	MOV	BX,[BX].GRAPHICS_ESC_PTR	; BX := Offset sequence to send ;AN000;
;;;;	ADD	BX,BP								;AN000;
;;;;										;AN000;
;;;;SEND_1_GRAPHICS_BYTE:							;AN000;
;;;;	MOV	AL,[BX] 		; AL := byte to print			;AN000;
;;;;	CALL	PRINT_BYTE		; Send it to the printer		;AN000;
;;;;	JC	NEW_PRT_LINE_ENDP	; If printer error, quit the loop	;AN000;
;;;;	INC	BX			; Get next byte 			;AN000;
;;;;	LOOP	SEND_1_GRAPHICS_BYTE						;AN000;
; /\ ~~mda(001) -----------------------------------------------------------------------
JMP     SHORT  NEW_PRT_LINE_ENDP               ; ~~mda(001) Restore registers
        JMP     SHORT  NEW_PRT_LINE_ENDP       ;
NEW_PRT_LINE_ENDP_2:                    ; ~~mda(001) 
        POP     SI
NEW_PRT_LINE_ENDP_1:			; ~~mda(001) 
        POP     AX
NEW_PRT_LINE_ENDP:								;AN000;
	POP	DI								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
NEW_PRT_LINE ENDP								;AN000;
PAGE										;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Since we have the keyword DATA, and we allow it to be anywhere
;               on the GRAPHICS line, then it is possible to have an
;               esc. sequence to send to the printer after the data has been
;               sent.  Therefore we need this new procedure.
;===============================================================================
;										
; END_PRT_LINE : SEND THE REST OF THE GRAPHICS LINE			        
;										
;-------------------------------------------------------------------------------
;										
;	INPUT: CUR_MODE_PTR = Offset of the DISPLAYMODE information		
;    			      record for the current mode			
;              DI           = Points to the section of the esc. seq that
;                             comes after the keyword DATA.
;										
;	OUTPUT: PRINTER 							
;										
;	CALLED BY: PRT_BW_APA							
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION: Extract the GRAPHICS escape sequence that comes after the keyword
; DATA from the DISPLAYMODE information record; Send this escape sequence to the
; printer. 		                                                        
;										
;										

CR_FOUND        DB      ?       ; So we know if a carriage return has been sent
LF_FOUND        DB      ?       ; So we know if a line feed has been sent

END_PRT_LINE PROC NEAR								
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	PUSH	DI								
										
        MOV     CR_FOUND,NO             ; Initialize
        MOV     LF_FOUND,NO             ; 
	MOV	BX,CUR_MODE_PTR 	; BX := Displaymode info record.	
										
;-------------------------------------------------------------------------------
; Set up the 2 bytes containing the number of bytes to send in the GRAPHICS seq.
; NOTE: number of bytes to send is "CUR_SCAN_LNE_LENGTH * BOX_W"                
;-------------------------------------------------------------------------------
	MOV	AL,BOX_W		;   cur_scan_lne_length *		
	CBW				;   printer box width = nb bytes to send
	MUL	CUR_SCAN_LNE_LENGTH	;     (result in DX AX) 		
;-------AX := Number of bytes to print						

	XOR	CX,CX				        ; CX := Length of the escape seq
        MOV	CL,[BX].NUM_GRAPHICS_ESC_AFTER_DATA	;after the word DATA		
        

       .WHILE <CX NE 0>         ; Doing a while loop just in case DATA is the 
                                ; last word on the GRAPHICS line.  In that case 
                                ; skip this and send a CR or LF if needed.
                 MOV    BL,BYTE PTR DS:[BP+DI]            ; Get code.

                .SELECT                                   ; Case statement
                .WHEN <BL EQ ESC_NUM_CODE>                ; We have an esc. number
       	                PUSH      AX                      ; Save count
                        INC       DI                      ; Point to esc. number
                        MOV       AL,DS:[BP+DI]           ;
                       .IF <AL EQ CR>                     ; Check if a CR is 
                            MOV     CR_FOUND,YES          ; explicitly stated
                       .ENDIF
                       .IF <AL EQ LF>                     ; Check if a LF is 
                            MOV     LF_FOUND,YES          ; explicitly stated
                       .ENDIF
                        CALL      PRINT_BYTE              ; Send esc. number
                        JC        GOTO_END_PRT_LINE_ENDP_1; If printer error then quit 
                                                          ; the loop and restore registers
                        INC       DI                      ; Point to next tag
                        POP       AX                      ; Restore the count
                        DEC       CX                      ;
                .WHEN <BL EQ COUNT_CODE>                  ; Need to send count in ascii form
       	                PUSH      AX                      ; Save count
                        PUSH      SI                      ;
                        CALL      GET_COUNT               ; Get # of bytes to send to printer
                        PUSH      CX                      ; Save counter for outside loop
                        XOR       CH,CH                   ;
                        MOV       CL,DS:[BP].NUM_BYTES_FOR_COUNT     ;
                        LEA       SI,DS:[BP].COUNT        ; Get ptr. to count
                        SUB       SI,CX                   ; Need to send MSB first
                        INC       SI                      ;
                        CLD                               ;
SEND_THE_ASCII_COUNT:                                     ;
                        LODSB                             ;
                        CALL      PRINT_BYTE              ; Print it
                        JC        GOTO_END_PRT_LINE_ENDP_2     ; If printer error then quit 
                                                          ; the loop and restore registers.
                        LOOP      SEND_THE_ASCII_COUNT    ;
                        POP       CX                      ; Restore outside loop counter
                        ADD       DI,2                    ; Point to next tag
                        POP       SI                      ;
                        POP       AX                      ; Restore COUNT
                        DEC       CX                      ;
                .WHEN <BL EQ LOWCOUNT_CODE>               ; Sending lowbyte of COUNT 
                        CALL      PRINT_BYTE              ; Print it
                        JC        END_PRT_LINE_ENDP       ; If printer error then quit 
                        ADD       DI,2                    ; Point to next tag
                        DEC       CX                      ;
                .WHEN <BL EQ HIGHCOUNT_CODE>              ; Sending highbyte of COUNT
       	                PUSH      AX                      ; Save count
                        CWD                               ;
                        MOV       BX,100h                 ;
                        DIV       BX                      ; Put highbyte in AL
                        CALL      PRINT_BYTE              ; Print it
                        JC        END_PRT_LINE_ENDP_1     ; If printer error then quit
                                                          ; the loop and restore registers
                        ADD       DI,2                    ; Point to next tag
                                                          ; the loop.
                        POP       AX                      ; Restore count
                        DEC       CX                      ;
                .ENDSELECT                                ;
       .ENDWHILE                                          ;
        JMP     SHORT  CR_LF                              ;
GOTO_END_PRT_LINE_ENDP_2:                                 ; Conditional jump was out of range
        JMP     SHORT  END_PRT_LINE_ENDP_2                ;
GOTO_END_PRT_LINE_ENDP_1:                                 ; Conditional jump was out of range
        JMP     SHORT END_PRT_LINE_ENDP_1                 ;
CR_LF:                                                    ;
       .IF <DS:[BP].PRINTER_NEEDS_CR_LF EQ YES>           ; ~~mda(003) We have an IBM type printer  
                                                          ; so we need to do a CR and LF if it 
                                                          ; already hasn't been done.
               .IF <CR_FOUND EQ NO>                       ; It hasn't been done.
                        MOV       AL,CR                   ;
                        CALL      PRINT_BYTE              ;
                        JC        END_PRT_LINE_ENDP       ; If printer error then quit 
               .ENDIF                                     ;
               .IF <LF_FOUND EQ NO>                       ; It hasn't been done.
                        MOV       AL,LF                   ;
                        CALL      PRINT_BYTE              ;
                        JC        END_PRT_LINE_ENDP       ; If printer error then quit 
               .ENDIF                                     ;       
                                                          ;
       .ENDIF                                             ;
JMP     NEW_PRT_LINE_ENDP                                 ; Restore registers
        JMP     SHORT   END_PRT_LINE_ENDP                 ;
END_PRT_LINE_ENDP_2:                                      ; Restore registers										
        POP     SI                                        ;
END_PRT_LINE_ENDP_1:			                  ; Restore registers							
        POP     AX                                        ;
END_PRT_LINE_ENDP:					  ;			
	POP	DI					  ;			
	POP	DX					  ;			
	POP	CX					  ;			
	POP	BX					  ;			
	POP	AX					  ;			
	RET						  ;			
END_PRT_LINE ENDP					  ;			
; /\ ~~mda(001) -----------------------------------------------------------------------
PAGE										;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Since we now can do HP PCL, we have to get the number of
;               bytes that are going to be sent to the printer and convert 
;               the number to ASCII if DATA_TYPE = DATA_ROW.
;===============================================================================;AN000;
;										;AN000;
; GET_COUNT : GET THE NUMBER OF BYTES TO SEND TO THE PRINTER 
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: CUR_SCAN_LNE_LENGTH
;              NB_BOXES_PER_PRT_BUF                                            ;AN000;
;										;AN000;
;       output : si	pointer to ascii string
;
;	         si  --> len=4    (hex = 4d2h)
;		         1
;		         2
;		         3
;		         4
;
;	         count (from shared_data_area)
;
;										;AN000;
;	CALLED BY: NEW_PRT_LINE
;                  END_PRT_LINE
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_COUNT 	proc	near
		push	ax	       ;
		push	bx	       ;
		push	cx	       ;
		push	dx	       ;
                push    si             ;

                mov     ax,cur_scan_lne_length  ; Get # bytes to send to
                cwd                             ; the printer
                xor     bh,bh                   ;
                mov     bl,nb_boxes_per_prt_buf ; 
                div     bx                      ;
               .IF <DX NE 0>                    ; So don't lose data when
                     INC        AX              ; have a remainder.
               .ENDIF                           ;

                                                ;
;--------- AX is the # bytes to send to the printer. Now convert it to ascii.
                                                ;
		xor	dx,dx	                ;clear upper 16 bits
		lea	si,ds:[bp].count        ;get pointer
                PUSH    SI                      ; Save ptr.
                MOV     CX,5                    ; Init. COUNT
INIT_COUNT:                                     ;
                MOV     BYTE PTR [SI],0         ;
                DEC     SI                      ;
                LOOP    INIT_COUNT              ;
                POP     SI                      ;
                                                ;
		mov	bx,10	                ; mod 10, div 10
		xor	cx,cx	                ;length counter = 0
hx_asc:                                         ;
		div	bx	                ;div, mod
		add	dl,'0'                  ;add 48 for ASCII
		mov	[si],dl                 ;store it
		dec	si	                ;point to next string element
		inc	cx	                ;inc length counter
		xor	dx,dx	                ;consider only div part for next loop
		cmp	ax,0	                ;end of loops ? (div=0)
		jnz	hx_asc	                ;no
                mov     ds:[bp].num_bytes_for_count,cl     ;save the length
                                                ;
                pop     si                      ;
		pop	dx	                ;
		pop	cx	                ;
		pop	bx	                ;
		pop	ax	                ;
		ret                             ;
GET_COUNT 	endp                            ;
; /\ ~~mda(001) -----------------------------------------------------------------------
PAGE                                            
;
;===============================================================================;AN000;
;										;AN000;
; PRINT_BYTE : SEND A BYTE TO THE PRINTER AT LPT1				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	AL		= Byte to be printed				;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;		ERROR_CODE	= PRINTER_ERROR if an error is detected.	;AN000;
;		Carry flag is set in case of error.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINT_BYTE PROC    NEAR 							;AN000;
	PUSH	AX								;AN000;
	PUSH	DX								;AN000;
										;AN000;
	MOV	DX,0000 	; PRINTER NUMBER				;AN000;
	MOV	AH,00		; REQUEST PRINT 				;AN000;
	INT	17H		; CALL BIOS : SEND THE CHARACTER		;AN000;
										;AN000;
	AND	AH,00101001B	; Test error code returned in AH for		;AN000;
				;   "Out of paper", "I/O error" and "Time-out". ;AN000;
	JNZ	PRINT_BYTE_ERROR; Set the error code if error			;AN000;
	JMP	SHORT PRINT_BYTE_END ; else, return normally			;AN000;
PRINT_BYTE_ERROR:								;AN000;
	MOV	ERROR_CODE,PRINTER_ERROR					;AN000;
	STC			; Set the carry flag to indicate ERROR		;AN000;
PRINT_BYTE_END: 								;AN000;
	POP	DX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PRINT_BYTE ENDP 								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; READ_DOT: READ A PIXEL - RETURN A COLOR TRANSLATION TABLE INDEX		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	CUR_MODE   = Current video mode.				;AN000;
;		CUR_ROW,							;AN000;
;		CUR_COLUMN = Coordinates of the pixel to be read.		;AN000;
;		CUR_PAGE   = Active page number 				;AN000;
;										;AN000;
;	OUTPUT: AL	   = Index into COLOR TRANSLATION TABLE.		;AN000;
;										;AN000;
;	DEPENDENCIES : COLOR TRANSLATION TABLE entries must be bytes		;AN000;
;										;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Use VIDEO BIOS INTERRUPT 10H "READ DOT CALL".                    ;AN000;
;										;AN000;
; Depending on the video hardware, the dot returned by BIOS has 		;AN000;
; different meanings.								;AN000;
; With an EGA it is an index into the Palette registers,			;AN000;
; With a CGA it is a number from 0 to 3,  mapping to a specific color		;AN000;
; depending on the background color and the color palette currently		;AN000;
; selected.									;AN000;
;										;AN000;
; The Color Translation table has been set up to hold the correct color 	;AN000;
; mapping for any "dot" in any mode.  Therefore, the dot number returned        ;AN000;
; by INT 10H can be used with any mode as a direct index within that		;AN000;
; table.									;AN000;
;										;AN000;
; With APA Monochrome mode 0FH there are 4 different dots: white,		;AN000;
; blinking white, high-intensity white, and black.				;AN000;
;										;AN000;
; For mode 0FH, the dot returned by interrupt 10 "read dot" call is a byte      ;AN000;
; where only bits 0 and 2 are significant.  These 2 bits must be appended	;AN000;
; together in order to obtain a binary number (from 0 to 3) that will be used	;AN000;
; as an index in the Color Translation table.					;AN000;
;										;AN000;
; For mode 11H, the dot is either 0 (for background color) or 7 (for the	;AN000;
; foreground color) only the LSB is returned.  That is, we return either	;AN000;
; 0 or 1.									;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Call VIDEO BIOS "READ DOT"                                                    ;AN000;
; IF CUR_MODE = 0FH								;AN000;
; THEN										;AN000;
;   Append bits 1 and 3.							;AN000;
; IF CUR_MODE = 11H								;AN000;
; THEN										;AN000;
;   Wipe out bits 1 and 2.							;AN000;
;										;AN000;
READ_DOT PROC NEAR								;AN000;
	PUSH	BX			; Save registers			;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
										;AN000;
	MOV	BH,CUR_PAGE							;AN000;
	MOV	DX,CUR_ROW							;AN000;
	MOV	CX,CUR_COLUMN							;AN000;
	MOV	AH,READ_DOT_CALL						;AN000;
	INT	10H			; Call BIOS: AL <-- Dot read		;AN000;
										;AN000;
	CMP	CUR_MODE,0FH		; Is it Mode 0fH ?			;AN000;
	JNE	MODE_11H?		; No, look for mode 11h.		;AN000;
;-------Mode 0Fh is the current mode:						;AN000;
;-------Convert bits 2 and 0 into a 2 bit number:				;AN000;
	MOV	BL,AL			; BL := AL = "Pixel read"               ;AN000;
	AND	BL,00000100B		; Wipe off all bits but bit 2 in BL	;AN000;
	AND	AL,00000001B		; Wipe off all bits but bit 0 in AL	;AN000;
	SHR	BL,1			;  Move bit 2 to bit 1 in BL		;AN000;
	OR	AL,BL			;  Append bit 1 and bit 0		;AN000;
	JMP	SHORT READ_DOT_END	;  Quit.				;AN000;
										;AN000;
MODE_11H?:									;AN000;
	CMP	CUR_MODE,11H		; Is it Mode 0fH ?			;AN000;
	JNE	READ_DOT_END		; No, quit				;AN000;
										;AN000;
;-------Mode 11H is the current mode:						;AN000;
	AND	AL,00000001B		; Keep only the Least significant bit	;AN000;
										;AN000;
READ_DOT_END:									;AN000;
	POP	DX			; Restore registers			;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
READ_DOT ENDP									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\grcpsd.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Copy Shared Data
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                              
;;										;AN000;
;; File Name:  GRCPSD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the COPY_SHARED_DATA module.			;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 COPY_SHARED_DATA - Copy the Shared Data Area from temporary		;AN000;
;;			    build area to resident memory & exit to DOS 	;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 None									;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       ;AN000;
	ASSUME CS:CODE,DS:CODE	       ;;					;AN000;
	INCLUDE GRCTRL.EXT	       ;; Bring in external declarations	;AN000;
	INCLUDE GRCTRL.STR	       ;;  for transient command processing	;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   PUBLIC COPY_SHARED_DATA	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   COPY_SHARED_DATA								;AN000;
;;										;AN000;
;; Input Parameters:								;AN000;
;;   DS : SI - points to the Temporary Shared Data Area 			;AN000;
;;   ES : DI - destination for resident Shared Data Area			;AN000;
;;   BP      - offset for new Shared Data Area (same as DI)			;AN000;
;;   AH    - Function code for exiting to DOS:					;AN000;
;;	     31H : Terminate & Stay Resident - if first time			;AN000;
;;	     4CH : Terminate - if already installed				;AN000;
;;   DX    - resident data segment size in paragraphs				;AN000;
;;										;AN000;
;; Output Parameters:								;AN000;
;;   NONE									;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;   Control Variables								;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Copy the Temporary Shared Data area over the installation modules		;AN000;
;;   and terminate (stay resident).  The data is copied immediately		;AN000;
;;   following this module.							;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   GRAPHICS_INSTALL								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   NONE									;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   Copy Temporary Shared Data Area						;AN000;
;;   Set PRINT_SCREEN_ALLOWED to YES						;AN000;
;;   Exit to DOS (Function Code 31 or 4C setup by caller)			;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
COPY_SHARED_DATA  PROC NEAR	       ;;					;AN000;
				       ;;					;AN000;
	REP	MOVSB		       ;; Copy Shared Data from temporary	;AN000;
				       ;;  build area to resident memory	;AN000;
				       ;; Allow print screens now		;AN000;
	MOV	ES:PRINT_SCREEN_ALLOWED,YES					;AN000;
				       ;;					;AN000;
	INT	21H		       ;; Exit					;AN000;
				       ;;					;AN000;
COPY_SHARED_DATA  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
CODE	ENDS									;AN000;
	END COPY_SHARED_DATA							;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\grinst.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:  I changed the default printer type from GRAPHICS to HPDEFAULT 
;**                because we have a section in the profile under 'HPDEFAULT' that
;**                will satisfactorily handle all of our printers.  I also changed
;**                the number of bytes for the printer type from 9 to 16 because
;**                of the RUGGEDWRITERWIDE.
;**  
;**  DOCUMENTATION NOTES:  This version of GRINST.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								
	TITLE	DOS - GRAPHICS Command  -	Installation Modules		
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;; DOS - GRAPHICS Command
;;                                   
;;										
;; File Name:  GRINST.ASM							
;; ----------									
;;										
;; Description: 								
;; ------------ 								
;;	 This file contains the installation modules for the			
;;	 GRAPHICS command.							
;;										
;;	 GRAPHICS_INSTALL is the main module.					
;;										
;;	 GRAPHICS_INSTALL calls modules in GRLOAD.ASM to load			
;;	 the GRAPHICS profile and GRPARMS.ASM to parse the command line.	
;;										
;;										
;; Documentation Reference:							
;; ------------------------							
;;	 OASIS High Level Design						
;;	 OASIS GRAPHICS I1 Overview						
;;	 DOS 3.3 Message Retriever Interface Supplement. 			
;;	 TUPPER I0 Document - PARSER HIGH LEVEL DESIGN REVIEW			
;;										
;; Procedures Contained in This File:						
;; ----------------------------------						
;;	 GRAPHICS_INSTALL - Main installation module				
;;	 CHAIN_INTERRUPTS - Chain interrupts 5, 2F, EGA Save Pointers		
;;	 COPY_PRINT_MODULES - Throw away one set of print modules		
;;										
;;										
;; Include Files Required:							
;; -----------------------							
;;	 GRLOAD.EXT   - Externals for profile load				
;;	 GRLOAD2.EXT  - Externals for profile load				
;;	 GRCTRL.EXT   - Externals for print screen control			
;;	 GRPRINT.EXT  - Externals for print modules				
;;	 GRCPSD.EXT   - Externals for COPY_SHARED_DATA module			
;;	 GRPARMS.EXT  - External for GRAPHICS command line parsing		
;;	 GRPARSE.EXT  - External for DOS parser 				
;;	 GRBWPRT.EXT  - Externals for Black and white printing modules		
;;	 GRCOLPRT.EXT - Externals for color printing modules			
;;	 GRINT2FH.EXT - Externals for Interrupt 2Fh driver.			
;;										
;;	 GRMSG.EQU    - Equates for the GRAPHICS error messages 		
;;	 SYSMSG.INC   - DOS message retriever					
;;										
;;	 GRSHAR.STR   - Shared Data Area Structure				
;;										
;;	 STRUC.INC    - Macros for using structured assembly language		
;;										
;; External Procedure References:						
;; ------------------------------						
;;	 FROM FILE  GRLOAD.ASM: 						
;;	      LOAD_PROFILE - Main module for profile loading			
;;	 SYSPARSE   - DOS system parser 					
;;	 SYSDISPMSG - DOS message retriever					
;;										
;; Linkage Instructions:							
;; -------------------- 							
;;	 Refer to GRAPHICS.ASM							
;;										
;; Change History:								
;; ---------------								
;; M001	NSM	1/30/91		Install our int 10 handler also along with
;;				int 2f and int 5 handlers to take care of alt
;;				prt-sc select calls made by ANSI.SYS
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       
	ASSUME	CS:CODE,DS:CODE        ;;					
				       ;;					
.XLIST				       ;;					
	INCLUDE GRSHAR.STR	       ;; Include the Shared data area structure
	INCLUDE SYSMSG.INC	       ;; Include DOS message retriever 	
	INCLUDE STRUC.INC	       ;; Include macros - Structured Assembler 
	INCLUDE GRLOAD.EXT	       ;; Bring in external declarations	
	INCLUDE GRLOAD2.EXT	       ;;					
	INCLUDE GRLOAD3.EXT	       ;;					
	INCLUDE GRCTRL.EXT	       ;;					
	INCLUDE GRBWPRT.EXT	       ;;					
	INCLUDE GRCOLPRT.EXT	       ;;					
	INCLUDE GRCPSD.EXT	       ;;					
	INCLUDE GRINT2FH.EXT	       ;;					
	INCLUDE GRCTRL.EXT	       ;;					
	INCLUDE GRPARSE.EXT	       ;;					
	INCLUDE GRPARMS.EXT	       ;;					
	INCLUDE GRMSG.EQU	       ;;					
				       ;;					
MSG_UTILNAME <GRAPHICS> 	       ;; Identify ourself to Message retriever.
				       ;; Include messages			
MSG_SERVICES <MSGDATA>		       ;;					
MSG_SERVICES <LOADmsg,DISPLAYmsg,CHARmsg,NUMmsg>  ;;				
MSG_SERVICES <GRAPHICS.CL1,GRAPHICS.CL2,GRAPHICS.CLA,GRAPHICS.CLB,GRAPHICS.CLC> 
.LIST				       ;;					
				       ;;					
PUBLIC GRAPHICS_INSTALL 	       ;;					
PUBLIC CHAIN_INTERRUPTS
PUBLIC TEMP_SHARED_DATA_PTR	       ;;					
PUBLIC PRINTER_TYPE_PARM	       ;;					
PUBLIC PRINTER_TYPE_LENGTH	       ;;					
PUBLIC PROFILE_PATH		       ;;					
PUBLIC PRINTBOX_ID_PTR		       ;;					
PUBLIC PRINTBOX_ID_LENGTH	       ;;					
PUBLIC DEFAULT_BOX		       ;;					
PUBLIC LCD_BOX			       ;;					
PUBLIC NB_FREE_BYTES		       ;;					
PUBLIC SYSDISPMSG		       ;;					
PUBLIC DISP_ERROR		       ;;					
PUBLIC INSTALLED		       ;;					
PUBLIC ERROR_DEVICE		       ;;					
PUBLIC STDERR			       ;;					
PUBLIC STDOUT			       ;;					
PUBLIC RESIDENT_SHARED_DATA_SIZE       ;;					
				       ;;					
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;;										
;; Install Variables								
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
NO		      EQU   0	       ;;					
YES		      EQU   1	       ;;					
INSTALLED	      DB    NO	       ;; YES if GRAPHICS already installed	
				       ;;					
				       ;;					
BYTES_AVAIL_PSP_OFF   EQU   6	       ;; Word number 6 of the PSP is the	
				       ;;  number of bytes available in the	
				       ;;   current segment			
				       ;;					
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;;										
;; GRLOAD (PROFILE LOADING) INPUT PARMS:					
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;\/ ~~mda ----------------------------------------------------------------------------
;               Changed the default printer type from GRAPHICS to HPDEFAULT,
;               which really isn't a printer type.  In the GRAPHICS.PRO
;               file there is a section that starts 'PRINTER HPDEFAULT'
;               that has all the necessary parms to support all HP printers
;               satisfactorily.  Also changed the number of bytes for the
;               printer type from 9 to 16 because of the RUGGEDWRITERWIDE.
;
;	MD 6/4/90 - this is a backwards compatibility problem.	Changed default
;		    back to Graphics

PRINTER_TYPE_PARM    DB    "GRAPHICS",9 DUP(0) ; Printer type			
				       ;;  (default=Graphics)			
;/\ ~~mda -----------------------------------------------------------------------------
PRINTER_TYPE_LENGTH  DB    17	       ;; Printer type maximum length of ASCIIZ 
PROFILE_PATH	     DB    128 DUP(0)  ;;  Profile name with full path		
				       ;;   (Max size for ASCIIZ is 128)	
PRINTBOX_ID_PTR      DW    DEFAULT_BOX ;;  Offset of ASCIIZ string containing	
DEFAULT_BOX	     DB    "STD",14 DUP(0);  the printbox id. (DEFAULT = STD)   
LCD_BOX 	     DB    "LCD",14 DUP(0); ASCIIZ string for the LCD printboxID
PRINTBOX_ID_LENGTH   DB    17	       ;;  Max. length for the printbox id.	
				       ;;   ASCIIZ string			
NB_FREE_BYTES	     DW    ?	       ;;  Number of bytes available in our	
				       ;;   resident segment			
RESIDENT_SHARED_DATA_SIZE  DW ?        ;;  Size in bytes of the RESIDENT Shared 
				       ;;   data area (if GRAPHICS already	
				       ;;    installed).			
END_OF_RESIDENT_CODE DW    ?	       ;; Offset of the end of the code that	
				       ;;  has to be made resident.		
TEMP_SHARED_DATA_PTR DW    ?	       ;; Offset of the temporary Shared area	
				       ;;					
ERROR_DEVICE   DW   STDERR	       ;; Device DISP_ERROR will output 	
				       ;;  messages to (STDERR or STDOUT)	
PAGE										
;===============================================================================
;										
; GRAPHICS_INSTALL : INSTALL GRAPHICS.COM					
;										
;-------------------------------------------------------------------------------
;										
;  INPUT:   Command line parameters						
;	    GRAPHICS profile - A file describing printer characteristics and	
;			       attributes.					
;										
;  OUTPUT:  If first time invoked:						
;	      INT 5 VECTOR and INT 2FH VECTOR are replaced; only the required	
;	      code for printing the screen is made resident.			
;	    else,								
;	      The resident code is updated to reflect changes in printing	
;	      options.								
;										
;-------------------------------------------------------------------------------
;;										
;; DESCRIPTION: 								
;;										
;;   This module intalls GRAPHICS code and data.				
;;										
;;   An INT 2FH driver is also installed.					
;;										
;;   If this driver is already present then, we assume GRAPHICS was installed	
;;   and do not install it again but, simply update the resident code.		
;;										
;;   The resident code contains ONLY the code and data needed for Printing	
;;   the screen. The code needed is determined according to the command line	
;;   parameters and the information extracted from the printer profile. 	
;;										
;;   The printer profile is parsed according to the current hardware setting	
;;   and also to the command line options. The information extracted from	
;;   the profile is stored in a Data area shared between the installation	
;;   process and the Print Screen process.					
;;										
;;   A temporary Shared Data Area is FIRST built at the end of the .COM file	
;;   Before building it, we verify that there is				
;;   enough memory left in the current segment.  If not, the installation	
;;   process is aborted.							
;;										
;;   This temporary Data area when completed will be copied over the		
;;   installation code. Therefore, the file comprising GRAPHICS must be 	
;;   linked in a specific order with the installation modules being last.	
;;										
;;   These modules will be overwritten by the Shared Data area and the EGA	
;;   dynamic save area before we exit and stay resident.			
;;										
;;   The end of the resident code is the end of the Shared Data area, anything	
;;   else beyond that is not made resident.					
;;										
;;   The pointer to the resident Shared Data area is declared within the	
;;   Interrupt 2Fh driver. This pointer is initialized by the installation	
;;   process and points to the shared data area at Print Screen time.		
;;										
;;   Depending on the type of printer attached (i.e., Black and white or Color) 
;;   only one set of modules is made resident during the installation.		
;;										
;;   The set of print modules required is copied over the previous one at	
;;   location "PRINT_MODULE_START". This location is declared within            
;;   GRCOLPRT which must be linked before GRBWPRT				
;;										
;;   When copying one of the 2 sets of print modules we reserve enough space	
;;   for the larger of them. Therefore, if GRAPHICS is already installed but	
;;   is reinvoked with a different printer type which needs a bigger set of	
;;   modules: this new set of modules is simply recopied over the existing	
;;   one in the resident code.							
;;										
;;   The Shared Data area is copied rigth after the set of modules that we keep 
;;   that is, over the unused set of modules.					
;;										
;;										
;-------------------------------------------------------------------------------
;;										
;; Register Conventions:							
;;   BP - points to start of Temp Shared Data (Transiant code)			
;;										
;; Called By:									
;;   Entry point for GRAPHICS command processing.				
;;										
;; External Calls:								
;;   INT 2FH, LOAD_MESSAGES, LOAD_PROFILE, PARSE_PARMS				
;;   CHAIN_INTERRUPTS, COPY_SHARED_DATA, DISPLAY_MESSAGE			
;;   COPY_PRINT_MODULES 							
;;										
;-------------------------------------------------------------------------------
;;										
;; LOGIC:									
;;   Load the message retriever 						
;;   IF carry flag is set (incorrect DOS version) THEN				
;;	Issue message (COMMON1) 						
;;	Exit									
;;   ENDIF									
;;										
;;   Get number of bytes available in the segment from PSP (word 6)		
;;   /* This is needed since we construct a temporary Shared data area at the	
;;   of the .COM file */							
;;										
;;   /* Build Shared Data in temporary area */					
;;   END_OF_RESIDENT_CODE := (end of .COM file) 				
;;   NB_FREE_BYTES    := Number of bytes availables				
;;										
;;   CALL PARSE_PARMS								
;;   IF error THEN	/* PARSE_PARMS will issue messages */			
;;	Exit									
;;   ENDIF									
;;										
;;   CALL LOAD_PROFILE								
;;   IF profile errors THEN							
;;	Exit		/* LOAD_PROFILE will issue messages */			
;;   ENDIF									
;;										
;;   Issue INT 2FH Install Check call (AX=AC00H)				
;;   /* INT 2FH returns ES:[DI] pointing to the shared data area */		
;;   IF already installed THEN							
;;   THEN									
;;	Move NO to PRINT_SCREEN_ALLOWED in resident Shared Data 		
;;	SHARED_DATA_AREA_PTR := DI						
;;   ELSE									
;;	MOV PRINT_SCREEN_ALLOWED,NO						
;;	CALL CHAIN_INTERRUPTS	/* Install INT 5 and INT 2FH vectors */ 	
;;	ES := Our segment							
;;   ENDIF									
;;   /* Keep only Print Black and White or Print Color: */			
;;   CALL COPY_PRINT_MODULES							
;;	/* COPY_SHARED_DATA will terminate & stay resident */			
;;	Set up registers for copy & terminate call				
;;	/* reserve enough memory to handle any printer in the profile*/ 	
;;	jump to COPY_SHARED_DATA module 					
;;   ELSE									
;;	/* Shared Data has been built in place */				
;;	move YES to PRINT_SCREEN_ALLOWED					
;;	Return to DOS								
;;   ENDIF									
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
GRAPHICS_INSTALL     PROC NEAR		;					
										
;-------------------------------------------------------------------------------
; Load the error messages							
;-------------------------------------------------------------------------------
   CALL    SYSLOADMSG		    ; Load messages				
  .IF C 			    ; If error when loading messages		
  .THEN 			    ; then,					
     MOV     CX,0		    ;	CX := No substitution in message	
     MOV     AX,1		    ;	AX := msg nb. for "Invalid DOS version" 
     CALL DISP_ERROR		    ;	Display error message			
     JMP     ERROR_EXIT 	    ;	 and quit				
  .ENDIF									
										
;-------------------------------------------------------------------------------
; Get offset of where to build the TEMPORARY Shared Data area (always built)	
;-------------------------------------------------------------------------------
   MOV	   BP,OFFSET LIMIT	     ; Build it at the end of this .COM file	
				     ;	(LIMIT = the offset of the last byte	
				     ;	  of the last .OBJ file linked with	
				     ;	   GRAPHICS)				
   MOV	   TEMP_SHARED_DATA_PTR,BP   ;						
										
;-------------------------------------------------------------------------------
; Determine if GRAPHICS is already installed; get the resident segment value	
;-------------------------------------------------------------------------------
    MOV     AH,PRT_SCR_2FH_NUMBER    ; Call INT 2FH (the Multiplex interrupt)	
    XOR     AL,AL		     ;	for Print Screen handler		
    INT     2FH 		     ;						
										
   .IF <AH EQ 0FFH>		     ; IF already installed			
   .THEN			     ; then,					
   ;----------------------------------------------------------------------------
   ; GRAPHICS is already installed: Get pointer to the EXISTING Shared Data area
   ;----------------------------------------------------------------------------
      MOV     INSTALLED,YES	    ;	Say it's installed                      
      MOV     AX,ES		    ;	Get the segment and offset of the	
      MOV     SHARED_DATA_AREA_PTR,DI;	 resident Shared Data area.		
      MOV     RESIDENT_CODE_SEG,AX  ;	  (returned in ES:DI)			

      MOV  AX,ES:[DI].SD_TOTAL_SIZE ; CX := Size of the existing Shared area	
      MOV  MAX_BLOCK_END, AX

				    ;	Disable print screen because we will	
      MOV     ES:PRINT_SCREEN_ALLOWED,NO ; be updating the resident code.	
   .ELSE			    ; ELSE, not installed:			
   ;------------------------------------------------------------------------	
   ; GRAPHICS is NOT installed: RESIDENT shared data area is in OUR segment	
   ;------------------------------------------------------------------------	
      PUSH    CS		    ; The Shared Data area will be in our	
      POP     RESIDENT_CODE_SEG     ;  segment. 				
   .ENDIF									
;-------------------------------------------------------------------------------
; Determine in AX how many bytes are available for building the TEMPORARY SHARED
; DATA AREA:									
;-------------------------------------------------------------------------------

;   MOV     AX,ES:BYTES_AVAIL_PSP_OFF;AX := Number of bytes availables in	
				    ;  the current segment (as indicated in PSP)
;M000;    mov     ax,0FFFFh		    ; Assume available to top of seg
;M000;
;Check for amount of memory that is free without assuming 64K. This causes
;crashes if it is loaded into UMBs.
;
	push	cx
	mov	ax,offset Limit
	add	ax,15
	mov	cl,4
	shr	ax,cl			;round up to nearest para
	mov	cx,es			;get our PSP seg
	add	ax,cx			;end of load image
	sub	ax,es:[2]		;es:[2] = top of our memory block
	neg	ax			;ax = # of paras free
	test	ax,0f000h		;greater than 64K bytes?
	jz	lt64K			;no
	mov	ax,0ffffh		;stop at 64K
	jmp	short gotfree
lt64K:
	mov	cl,4
	shl	ax,cl			;ax = # of bytes free above us
gotfree:
	pop	cx
;
;M000; End changes;
;

;;;   .IF	<AX B <OFFSET LIMIT>>	    ; If there is no bytes available past	
;;;   .THEN			    ;	the end of our .COM file		
;;;      XOR     AX,AX		    ; then, AX := 0 bytes available		
;;;   .ELSE			    ;						
;;;      SUB     AX,OFFSET LIMIT	    ; else,  AX := Number of FREE bytes 	
;;;   .ENDIF			    ;	     in this segment			
										
;---AX = Number of bytes in our segment available for building the Temp Shared	
;---data area.									
;---IF ALREADY INSTALLED: Get the size of the existing Shared data area.	
;---Since the temporary shared data area will be copied over the resident	
;---shared data area, we do not want to build it any bigger than the one	
;---it will overwrite. Therefore we do not give to LOAD_PROFILE more space	
;---than the size of the existing Shared data area.				
   .IF <INSTALLED EQ YES>	    ; If already installed then,		
   .THEN									
      PUSH CS:RESIDENT_CODE_SEG     ; ES:[DI] := Resident Shared data area	
      POP  ES			    ;						
      MOV  DI,SHARED_DATA_AREA_PTR  ;						
      MOV  CX,ES:[DI].SD_TOTAL_SIZE ; CX := Size of the existing Shared area	
      MOV  RESIDENT_SHARED_DATA_SIZE,CX ; Save size for LOAD_PROFILE		
     .IF <AX A CX>		    ; If AX > size of existing SDA		
	MOV AX,CX		    ; then, AX := Size of existing Shared area	
     .ENDIF			    ;						
   .ENDIF									
				    ;  NB_FREE_BYTES := Number of bytes 	
    MOV     NB_FREE_BYTES,AX	    ;	available for				
				    ;	 building the TEMPORARY shared area	
;-------------------------------------------------------------------------------
; Parse the command line parameters						
;-------------------------------------------------------------------------------
   MOV	   BYTE PTR CS:[BP].SWITCHES,0 ; Init. the command line switches	
   PUSH    CS			   ; Set ES to segment containing the PSP	
   POP	   ES									
   CALL    PARSE_PARMS		   ; Set switches in the Temp. Shared Area	
  .IF C 			   ; If error when parsing the command		
    .THEN			   ; line then, EXIT				
     JMP     ERROR_EXIT 							
  .ENDIF									
;-------------------------------------------------------------------------------
; Parse the printer profile - Build the temporary Shared data area		
;-------------------------------------------------------------------------------
 CALL  LOAD_PROFILE	            ;  Builds profile info in Temporary Shared	
				    ;	Data					
   .IF C			    ; If error when loading the profile 	
   .THEN			    ; then, EXIT				
      JMP     ERROR_EXIT							
   .ENDIF									
										
;-------------------------------------------------------------------------------
; Check if /B was specified with a BLACK and WHITE printer:(invalid combination)
;-------------------------------------------------------------------------------
   .IF <CS:[BP].PRINTER_TYPE EQ BLACK_WHITE> AND				
   .IF <BIT CS:[BP].SWITCHES NZ BACKGROUND_SW>					
   .THEN									
      MOV     AX,INVALID_B_SWITCH     ; Error := /B invalid with B&W prt.	
      MOV     CX,0		      ; No substitution 			
      CALL    DISP_ERROR	      ; Display error message			
      JMP     SHORT ERROR_EXIT	      ;  and quit				
   .ENDIF									
										
;-------------------------------------------------------------------------------
;										
; RELOCATE THE TEMPORARY SHARED DATA AREA AND THE SET OF REQUIRED PRINT MODULES 
;										
; (Discard the set of print modules not needed with the printer attached and	
;  discard all the code not used at print screen time). 			
;										
; If GRAPHICS is already installed then, we copy the				
; Shared Data area and the print modules over the previous ones installed in	
; resident memory.								
;										
; If we are installed for the first time then, we copy those over the		
; installation modules before we exit and stay resident.			
;										
; A temporaty Shared Data area is always created even if a resident one 	
; already exist (it is then, copied over), a set of print modules is recopied	
; only if needed.								
;										
; NOTE: END_OF_RESIDENT_CODE points to the first location over which code	
;	may be relocated.  After data or code is relocated, END_OF_RESIDENT_CODE
;	is updated and points to the next available location for copying code	
;	that will stay resident.						
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
; Initialize the pointer to the next available location for resident code:	
;-------------------------------------------------------------------------------
   .IF <INSTALLED EQ NO>	    ; If not installed				
   .THEN			    ; then,					
      MOV     END_OF_RESIDENT_CODE,OFFSET PRINT_MODULE_START			
   .ENDIF			    ;	we make everything up to the print	
				    ;	 modules resident code. 		
;-------------------------------------------------------------------------------
; Keep only the set of print modules that is needed:				
;-------------------------------------------------------------------------------
    CALL    COPY_PRINT_MODULES	    ; Updates END_OF_RESIDENT_CODE		
;-------------------------------------------------------------------------------
; Replace the interrupt vectors and install the EGA dynamic area (if needed)	
;-------------------------------------------------------------------------------
   .IF <INSTALLED EQ NO>	    ; If not already installed			
   .THEN			    ; then,					
;------Release evironment vector						;AN002;
      CALL RELEASE_ENVIRONMENT	    ;	release unneeded environment vector	;AN002;
;------Replace the interrupt vectors						
      MOV   PRINT_SCREEN_ALLOWED,NO ;	Disable Print Screen			
      CALL  CHAIN_INTERRUPTS	    ;	Replace the interrupt vectors		
				    ;	 (END_OF_RESIDENT_CODE is updated)	
      CALL  DET_HW_CONFIG	    ;	Find what display adapter we got	
     .IF <CS:[BP].HARDWARE_CONFIG EQ EGA>;If EGA is present			
     .THEN			    ;	then,					
	 CALL INST_EGA_SAVE_AREA    ;	  Install the EGA dynamic save area	
     .ENDIF			    ;	  (END_OF_RESIDENT_CODE is updated)	
;------Calculate the size of the resident code					
      MOV   DX,END_OF_RESIDENT_CODE ; DX := End of resident code		
      ADD   DX,CS:[BP].SD_TOTAL_SIZE; Add size of Shared Data area		
      MOV   CL,4		    ;						
      SHR   DX,CL		    ; convert to paragraphs			
      INC   DX			    ;  and add 1				
;------Set AX to DOS exit function call - (COPY_SHARED_DATA will exit to DOS)	
      MOV   AH,31H		    ; Function call to terminate but stay	
      XOR   AL,AL		    ;	resident				
   .ELSE									
      MOV   AH,4CH		    ; Function call to terminate		
      XOR   AL,AL		    ; (EXIT to calling process) 		
   .ENDIF									
										
;-------------------------------------------------------------------------------
; Copy the temporary shared data area in the resident code			
;-------------------------------------------------------------------------------
    MOV     CX,CS:[BP].SD_TOTAL_SIZE; CX := MOVSB count for COPY_SHARED_DATA	
    MOV     SI,BP		    ; DS:SI := Temporary Shared data area	
    PUSH    RESIDENT_CODE_SEG	    ; ES:DI := Resident Shared data area:	
    POP     ES			    ;						
   .IF <INSTALLED EQ NO>	    ; If not installed				
   .THEN			    ; then,					
      MOV     DI,END_OF_RESIDENT_CODE;	 DI := End of resident code		
      MOV     BP,DI		    ;	BP := New resident Shared data area	
      MOV     SHARED_DATA_AREA_PTR,DI;	 Update pointer to resident Shar. area	
   .ELSE			    ; else,					
      MOV     DI,SHARED_DATA_AREA_PTR ;   DI := Existing Shared data area	
      MOV     BP,DI		    ;	BP = DI:= Existing Shared data area	
   .ENDIF									
      JMP   COPY_SHARED_DATA	    ; Jump to proc that copies area in new	
				    ;  part of memory and exits to DOS		
ERROR_EXIT:									
   .IF <INSTALLED EQ YES>	    ; If we are already installed, re-enable	
      MOV   ES,RESIDENT_CODE_SEG    ;  print screens				
      MOV   ES:PRINT_SCREEN_ALLOWED,YES 					
   .ENDIF			    ;						
				    ;						
    MOV     AH,4CH		    ; Function call to terminate		
    MOV     AL,1		    ; (EXIT to calling process) 		
    INT     21H 								
GRAPHICS_INSTALL     ENDP							
										
PAGE										
;===============================================================================
;										
; INST_EGA_SAVE_AREA : INSTALL A DYNAMIC SAVE AREA FOR THE EGA PALETTE REGISTERS
;										
;-------------------------------------------------------------------------------
;										
; INPUT:   DS			= Data segment for our code			
;	   END_OF_RESIDENT_CODE = Offset of the end of the resident code	
;										
; OUTPUT:  END_OF_RESIDENT_CODE is updated to point to the end of the code	
;				   that will stay resident.			
;	   SAVE_AREA_PTR in BIOS segment is updated.				
;										
;-------------------------------------------------------------------------------
;;										
;; Data Structures Referenced:							
;;   Shared Data Area								
;;										
;; Description: 								
;;   ************* The EGA Dynamic Save Area will be built over top		
;;   **  NOTE	** of the profile loading modules (file GRLOAD.ASM)		
;;   ************* to avoid having to relocate this area just before		
;;   terminating.  This is safe since the maximum memory used is		
;;   288 bytes and the profile loading modules are MUCH larger than		
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		
;;   GRPRINT.ASM.								
;;										
;; BIOS will update the dynamic save area whenener it's aware the palette       
;; registers have been updated. 						
;;										
;; BIOS 4A8H		BIOS SAVE	       EGA DYNAMIC			
;; POINTER:		POINTER TABLE	       SAVE AREA			
;; 			       (16 first bytes are the 16	
;;    *>	     		EGA palette registers)		
;; 			       			
;;			     *>			
;;				       			
;;				     	       			
;;					     .				
;;				     		     .				
;;					     .	    256 bytes		
;;				     		     .				
;;					     .				
;;				     	       			
;;				       			
;;				     	       			
;;				       			
;;				     	       			
;;				       			
;;										
;; Called By:									
;;   GRAPHICS_INSTALL								
;;										
;; External Calls:								
;;										
;; Logic:									
;;   IF EGA Dynamic Save Area NOT established THEN				
;;	  /* Required since default table is in ROM */				
;;	  IF Save Table is in ROM						
;;	     Replicate all the Save Area Table in resident RAM just before	
;;	      the Shared Data Area						
;;	  ENDIF 								
;;	  Allocate 256 bytes for EGA Dynamic Save Area just before the		
;;	  Shared Data Area							
;;	  Update END_OF_RESIDENT_CODE						
;;     ENDIF									
;;   RETURN									
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
BIOS_SAVE_PTR	     EQU    4A8H       ;; Offset of the BIOS Save Ptr area	
SAVE_AREA_LEN	     EQU    8*4        ;; There are 8 pointers in the Save area 
EGA_DYNAMIC_LEN      EQU    256        ;; Length of the EGA dynamic save area	
; Standard default colours for the Enhanced Graphics Adapter: (rgbRGB values)	
; The following table is necessary in order to initialize the EGA DYNAMIC	
; SAVE AREA when creating it.							
EGA_DEFAULT_COLORS   DB     00h        ;; Black 				
		     DB     01h        ;; Blue					
		     DB     02h        ;; Green 				
		     DB     03h        ;; Cyan					
		     DB     04h        ;; Red					
		     DB     05h        ;; Magenta				
		     DB     14h        ;; Brown 				
		     DB     07h        ;; White 				
		     DB     38h        ;; Dark Grey				
		     DB     39h        ;; Light Blue				
		     DB     3Ah        ;; Light Green				
		     DB     3Bh        ;; Light Cyan				
		     DB     3Ch        ;; Light Red				
		     DB     3Dh        ;; Light Magenta 			
		     DB     3Eh        ;; Yellow				
		     DB     3Fh        ;; Bright white				
		     DB     00h        ;; OVERSCAN register			
										
INST_EGA_SAVE_AREA PROC NEAR							
PUSH	AX									
PUSH	CX									
PUSH	DX									
PUSH	SI									
PUSH	DI									
PUSH	ES									
;-------------------------------------------------------------------------------
; Get the BIOS save pointer table						
;-------------------------------------------------------------------------------
XOR	AX,AX			      ; ES := segment 0 			
MOV	ES,AX									
LES	SI,ES:DWORD PTR BIOS_SAVE_PTR ; ES:[SI] =Current BIOS save table	
.IF <<WORD PTR ES:[SI]+4> EQ 0> AND   ; IF the dynamic save are pointer is	
.IF <<WORD PTR ES:[SI]+6> EQ 0>       ;  null then, it's not defined            
.THEN				      ;   and we have to define it:		
    ;---------------------------------------------------------------------------
    ; The Dynamic EGA save area is NOT DEFINED: 				
    ;---------------------------------------------------------------------------
     MOV   BYTE PTR ES:[SI]+4,0FFH    ; Try to write a byte in the table	
     PUSH  AX			      ; (PUSH AX, POP AX used to create a	
     POP   AX			      ;  small delay)				
    .IF <<WORD PTR ES:[SI]+4> NE 0FFH>;If we can't read our byte back then,     
    .THEN			      ;  the Save Ptrs table is in ROM		
       ;------------------------------------------------------------------------
       ; The Save pointer table is in ROM;					
       ; Copy the BIOS save pointer table from ROM to within our .COM file	
       ;------------------------------------------------------------------------
	PUSH  ES		      ; DS:SI := Offset of BIOS save ptrs table 
	POP   DS		      ; 					
	PUSH  CS		      ; ES:DI := The next available location	
	POP   ES		      ; 	  for installing resident code	
	MOV   DI,CS:END_OF_RESIDENT_CODE ;	   within our .COM file 	
	MOV   CS:OUR_SAVE_TAB_OFF,DI  ; 					
	MOV   CX,SAVE_AREA_LEN	      ;     CX := Length of the table to copy	
	REP   MOVSB		      ;  Replicate the Save Table		
	PUSH  CS								
	POP   DS		      ; Reestablish our data segment		
       ;------------------------------------------------------------------------
       ; Adjust END_OF_RESIDENT_CODE to the next offset available for copying	
       ; resident code and data.						
       ;------------------------------------------------------------------------
	ADD   END_OF_RESIDENT_CODE,SAVE_AREA_LEN				
       ;------------------------------------------------------------------------
       ; Set the pointer in OUR Save ptr table to our EGA dynamic save area	
       ; which we create right after the Save pointer table.			
       ;------------------------------------------------------------------------
	MOV	DI,OUR_SAVE_TAB_OFF    ; DS:[DI] := Our BIOS save ptr tab	
	MOV	AX,END_OF_RESIDENT_CODE; Store its offset			
	MOV	DS:[DI]+4,AX	       ;					
	MOV	WORD PTR DS:[DI]+6,DS  ; Store its segment			
       ;------------------------------------------------------------------------
       ; Initialize our DYNAMIC SAVE AREA with the 16 standard EGA colors	
       ;------------------------------------------------------------------------
										
	LEA  SI,EGA_DEFAULT_COLORS	; DS:[SI] := EGA 16 Default colors	
	MOV  DI,END_OF_RESIDENT_CODE	; ES:[DI] := DYNAMIC SAVE AREA		
	MOV  CX,17			; CX := Number of colors		
	REP  MOVSB			; Initialize the Dynamic save area	
       ;------------------------------------------------------------------------
       ; Set the BIOS Save Pointer to our table of Save pointers:		
       ;------------------------------------------------------------------------
	CLI									
	XOR	AX,AX		       ; ES:BIOS_SAVE_PTR := Our save table:	
	MOV	ES,AX								
	MOV	AX,OUR_SAVE_TAB_OFF						
	MOV	ES:BIOS_SAVE_PTR,AX						
	MOV	ES:BIOS_SAVE_PTR+2,DS						
	STI									
    .ELSE			       ; ELSE save pointer table is in RAM	
       ;------------------------------------------------------------------------
       ; ELSE, the BIOS save pointer table is in RAM:				
       ;------------------------------------------------------------------------
       ;------------------------------------------------------------------------
       ; Set the pointer in THEIR Save ptr table to OUR EGA dynamic save area	
       ;------------------------------------------------------------------------
	MOV   WORD PTR ES:[SI]+6,DS    ; ES:[SI] = The existing table in RAM	
	MOV   AX,END_OF_RESIDENT_CODE						
	MOV   ES:[SI]+4,AX							
    .ENDIF			       ; ENDIF save pointer table is in ROM	
  ;-----------------------------------------------------------------------------
  ; Adjust END_OF_RESIDENT_CODE to the next offset available for copying	
  ; resident code and data.							
  ;-----------------------------------------------------------------------------
   ADD	END_OF_RESIDENT_CODE,EGA_DYNAMIC_LEN					
.ENDIF										
POP	 ES									
POP	 DI									
POP	 SI									
POP	 DX									
POP	 CX									
POP	 AX									
										
RET										
OUR_SAVE_TAB_OFF DW	?							
INST_EGA_SAVE_AREA ENDP 							
PAGE										
;===============================================================================
;										
; CHAIN_INTERRUPTS : INSTALL INT 5 ,INT 10 AND INT 2FH VECTORS				
;										
;-------------------------------------------------------------------------------
;										
; INPUT:   DS			= Data segment for our code			
;	   END_OF_RESIDENT_CODE = Offset of the end of the resident code	
;										
; OUTPUT:  OLD_INT_2FH		  (within INT_2FH_DRIVER)			
;	   BIOS_INT_5H		  (within PRT_SCR module)			
; 	   OLD_INT_10H
;	   END_OF_RESIDENT_CODE is updated to point to the end of the code	
;				   that will stay resident.			
;	   SAVE_AREA_PTR in BIOS segment is updated if an EGA adapter is found	
;										
;-------------------------------------------------------------------------------
;;										
;; Data Structures Referenced:							
;;   Shared Data Area								
;;										
;; Description: 								
;;   Install Interrupts 5 ,10 and 2FH. The old vectors are saved.
;;										
;; Called By:									
;;   GRAPHICS_INSTALL								
;;										
;; External Calls:								
;;   DOS INT 21H Replace vector AH=25h						
;;   DOS INT 21H Get vector AH=35h						
;;										
;; Logic:									
;;   Save interrupt 5 vector in BIOS_INT_5H					
;;   Point interrupt 5 to PRT_SCR module					
;;   Save interrupt 2FH vector in BIOS_INT_2FH					
;;   Point interrupt 2FH to INT_2FH_DRIVER module				
;;   Save interrupt 10h vector in OLD_INT_10h
;;   point interrupt 10h to INT_10H_DRIVER
;;   RETURN									
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
CHAIN_INTERRUPTS  PROC NEAR	       ;;					
	PUSH	ES								
	PUSH	BX								
										
;-------------------------------------------------------------------------------
; Replace INTERRUPT 5 vector							
;-------------------------------------------------------------------------------
	MOV	AX,3505H		; Get vector for int 5 request
	INT	21H			; Call DOS				

	MOV	CS:BIOS_INT_5H,BX	; Save the old vector
	MOV	CS:BIOS_INT_5H+2,ES			
						
	MOV	DX,OFFSET PRT_SCR	; DS:DX := Offset of our Print Screen

	MOV	AX,2505H		; Replace vector for int 5 request
	INT	21H			; Call DOS	
										
;-------------------------------------------------------------------------------
; Replace INTERRUPT 2FH vector							
;-------------------------------------------------------------------------------
	MOV	AX,352FH		; Get vector for int 2FH request
	INT	21H			; Call DOS				
										
	MOV	WORD PTR OLD_INT_2FH,BX ; Save the old vector			
	MOV	WORD PTR OLD_INT_2FH+2,ES					
										
	MOV	DX,OFFSET INT_2FH_DRIVER; DS:DX := Offset of our 2FH handler	
										
	MOV	AX,252FH		; Replace vector for int 2FH request
	INT	21H			; Call DOS				
; /* M001 BEGIN */
;------------------------------------------------------------------------------
; Replace INTERRUPT 10 vector						
;------------------------------------------------------------------------------
	MOV	AX,3510H		; Get vector for int10h request
	INT	21H			; Call DOS	
						
	MOV	WORD PTR OLD_INT_10H,BX ; Save the old vector
	MOV	WORD PTR OLD_INT_10H+2,ES		
						
	MOV	DX,OFFSET INT_10H_DRIVER; DS:DX := Offset of our 2FH handler
				
	MOV	AX,2510H		; Replace vector for int10H request
	INT	21H			; Call DOS	
; /* M001 END */
						
	POP	BX			
	POP	ES		
	RET		

CHAIN_INTERRUPTS  ENDP	
;===============================================================================
;										
; COPY_PRINT_MODULES: COPY THE SET OF PRINT MODULES NEEDED OVER THE PREVIOUS ONE
;										
;-------------------------------------------------------------------------------
;										
; INPUT:  BP		       = Offset of the temporary Shared Data area	
;	  END_OF_RESIDENT_CODE = Location of the set of COLOR modules		
;				 (if first time installed)			
;	  CS:[BP].PRINTER_TYPE = Printer type NEEDED				
;	  RESIDENT_CODE_SEG    = Segment containing the resident code		
;										
; OUTPUT: END_OF_RESIDENT_CODE = End of the print modules IS UPDATED		
;				 (If first time installed)			
;										
;-------------------------------------------------------------------------------
;;										
;; Data Structures Referenced:							
;;   Control Variables								
;;   Shared Data Area								
;;										
;; Description: 								
;;   This module trashes one set of print modules (Color or Black & White)	
;;   depending on the type of printer attached.  Since the Shared Data		
;;   (resident version) will reside immediately after the print modules,	
;;   END_OF_RESIDENT_CODE will be set by this modules.				
;;										
;;   The set of COLOR modules is already at the rigth located when installing	
;;   GRAPHICS for the first time. This is true since, the color modules are	
;;   linked before the black and white modules. 				
;;										
;;   Therefore, if we are installing GRAPHICS for the first time and we need	
;;   the color modules then, we do not need to relocate any print modules.	
;;										
;;   When installing GRAPHICS again we first check what is the resident set,	
;;   we recopy a new set only if needed.					
;;										
;; Called By:									
;;   GRAPHICS_INSTALL								
;;										
;; Logic:									
;;   IF color printer THEN							
;;	SI := Offset of BW_PRINT_MODULES					
;;   ELSE									
;;	SI := Offset of COLOR_PRINT_MODULES					
;;   ENDIF									
;;   REP MOVSB		; Copy the set of modules				
;;   END_OF_RESIDENT_CODE := end of the set of modules				
;;   RETURN									
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
COPY_PRINT_MODULES  PROC NEAR							
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	SI								
	PUSH	DI								
	PUSH	ES								
										
;-------------------------------------------------------------------------------
; Determine if we need to relocate the set of print modules, if so, set the	
; source address (DS:SI), the destination address (ES:DI) and the number of	
; bytes to copy (CX).								
;-------------------------------------------------------------------------------
   PUSH    CS:RESIDENT_CODE_SEG 	; ES := Segment containing the resident 
   POP	   ES				;	 code  (Where to copy modules)	
   MOV	   DI,OFFSET PRINT_MODULE_START ; ES:[DI] := Resident print modules	
										
  .IF <INSTALLED EQ NO> 		; IF not installed			
  .THEN 				; THEN, 				
					;   We relocate the print modules	
					;    at the end of the resident code:	
					;     (this is where the color set is)	
     .IF <CS:[BP].PRINTER_TYPE EQ BLACK_WHITE> ; IF we don't want the color set 
     .THEN				;   THEN,				
	MOV NEED_NEW_PRINT_MODULES,YES	;     Say we need new modules		
	MOV SI,OFFSET PRINT_BW_APA	;     DS:[SI] := Black and white modules
	MOV CX,LEN_OF_BW_MODULES	;     CX      := Length of B&W modules	
     .ENDIF				;					
										
  .ELSE 				; ELSE, (We are already installed)	
      MOV     BX,SHARED_DATA_AREA_PTR	;   BX := Offset of Shared Data area	
      MOV     AL,ES:[BX].PRINTER_TYPE	;   AL := Type of the resident set	
     .IF <AL NE CS:[BP].PRINTER_TYPE>	;   IF resident set is not the one	
     .THEN				;   we need THEN,			
	MOV NEED_NEW_PRINT_MODULES,YES	;     Say we need a new set.		
       .IF <CS:[BP].PRINTER_TYPE EQ COLOR>;   IF its color we need then,	
	  MOV SI,OFFSET PRINT_COLOR	;	DS:[SI] := Color set		
	  MOV CX,LEN_OF_COLOR_MODULES	;	CX	:= Length of color mod. 
       .ELSE				;     ELSE				
	  MOV SI,OFFSET PRINT_BW_APA	;	DS:[SI] := B&W set		
	  MOV CX,LEN_OF_BW_MODULES	;	CX	:= Length of B&W mod.	
       .ENDIF				;     ENDIF we need the color set	
     .ENDIF				;   ENDIF we need a new set		
  .ENDIF				; ENDIF we are not installed		
										
										
;-------------------------------------------------------------------------------
; If needed: Copy the required set of print modules				
;-------------------------------------------------------------------------------
  .IF <NEED_NEW_PRINT_MODULES EQ YES>						
  .THEN 									
     CLD			       ; Clear the direction flag		
     REP     MOVSB		       ; Copy the set of print modules		
  .ENDIF			       ; ENDIF needs to copy the print modules	
										
;-------------------------------------------------------------------------------
; Set END_OF_RESIDENT_CODE pointer to the end of the print modules:		
; (Reserve enough space to store the larger set of modules on a 		
;  subsequent install)								
;-------------------------------------------------------------------------------
  .IF <INSTALLED EQ NO> 		; IF first time installed		
  .THEN 				; THEN, 				
     MOV     CX,LEN_OF_COLOR_MODULES	;   Adjust END_OF_RESIDENT_CODE to	
    .IF <CX G LEN_OF_BW_MODULES>	;   contains the larger set of modules. 
    .THEN				;					
       ADD     END_OF_RESIDENT_CODE,LEN_OF_COLOR_MODULES			
    .ELSE									
       ADD     END_OF_RESIDENT_CODE,LEN_OF_BW_MODULES				
    .ENDIF				;					
  .ENDIF									
										
	POP ES									
	POP DI									
	POP SI									
	POP CX									
	POP BX									
	POP AX									
	RET									
NEED_NEW_PRINT_MODULES DB   NO		; True if print modules needed must be	
					;  copied over the other set of print	
					;   modules				
COPY_PRINT_MODULES  ENDP							
										;AN002;
PAGE										;AN002;
;===============================================================================;AN002;
;										;AN002;
; PROCEDURE_NAME: RELEASE_ENVIRONMENT						;AN002;
;										;AN002;
; INPUT:  None. 								;AN002;
;										;AN002;
; OUTPUT: Environment vector released.						;AN002;
;										;AN002;
;-------------------------------------------------------------------------------;AN002;
RELEASE_ENVIRONMENT PROC NEAR							;AN002;
	PUSH	AX			; save regs				;AN002;
	PUSH	BX								;AN002;
	PUSH	ES								;AN002;
	MOV	AH,62H			; function for get the PSP segment	;AN002;
	INT	21H			; invoke INT 21h			;AN002;
	MOV	ES,BX			; BX contains PSP segment - put in ES	;AN002;
	MOV	BX,WORD PTR ES:[2CH]	; get segment of environmental vector	;AN002;
	MOV	ES,BX			; place segment in ES for Free Memory	;AN002;
	MOV	AH,49H			; Free Allocated Memory function call	;AN002;
	INT	21H			; invoke INT 21h			;AN002;
	POP	ES			; restore regs				;AN002;
	POP	BX								;AN002;
	POP	AX								;AN002;
	RET									;AN002;
RELEASE_ENVIRONMENT ENDP							;AN002;
										
PAGE										
;===============================================================================
;										
; PROCEDURE_NAME: DISP_ERROR							
;										
; INPUT:  AX := GRAPHICS message number (documented in GRMSG.EQU)		
;	  CX := Number of substitutions (Needed by SYSDISPMSG)			
;	  DS:[SI] := Substitution list (needed only if CX <> 0) 		
;										
; OUTPUT: Error message is displayed on STANDARD ERROR OUTPUT (STDERR)		
;										
;-------------------------------------------------------------------------------
DISP_ERROR    PROC   NEAR							
	PUSH	BX								
	PUSH	DI								
	PUSH	SI								
	PUSH	BP								
										
	MOV	BX,ERROR_DEVICE    ; Issue message to standard error		
	XOR	DL,DL		   ; No input					
	MOV	DH,UTILITY_MSG_CLASS;It's one of our messages                   
	CALL	SYSDISPMSG	   ; display error message			
										
	POP	BP								
	POP	SI								
	POP	DI								
	POP	BX								
	RET									
DISP_ERROR    ENDP								

include msgdcl.inc										
										
CODE   ENDS									
       END									


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\grbwprt.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:  I added code to the procedures PRINT_BW_PRT and FILL_BUFFER 
;**                to handle the support of HP PCL printers.   I used the algorithm
;**                below for PRINT_BW_PRT.
;**  
;**                  if data_type = data_row
;**                          if cur_scan_lne_length = 0 goto next_coordinates
;**                                  for i:=1 to box_h
;**                                          call new_prt_line
;**                                          save regs.
;**                                          save cur_row & cur_column
;**                                          for j:=1 to cur_scan_lne_lenght/nb_boxes_per_prt_buf 
;**                                          (+1 if remainder)
;**                                                  call fill_buffer
;**                                                  call print_buffer
;**                                          end_for
;**                                          call end_prt_line
;**                                          restore cur_column & cur_row
;**                                          restore regs.
;**                                  end_for
;**                          restore regs.
;**  next_coordinates:       if rotate_sw = on
;**                                  inc cur_column
;**                          else
;**                                  inc cur_row
;**                          endif
;**                  else
;**                        .
;**                        .
;**                        .
;**                          call end_prt_line       ; Print CR & LF
;**                        .
;**                        .
;**                        .
;**                  endif
;**  
;**  DOCUMENTATION NOTES:  This version of GRBWPRT.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE ,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Black and White printing modules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                              
;;										;AN000;
;; File Name:  GRBWPRT.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the code for printing a GRAPHICS screen on a	;AN000;
;;	 BLACK and WHITE printer.						;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;										;AN000;
;;	PRINT_BW_APA								;AN000;
;;	  FILL_BUFFER								;AN000;
;;	    INT2PAT								;AN000;
;;	    PAT2BOX								;AN000;
;;										;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 GRCTRL.EXT   - Externals for print screen control			;AN000;
;;	 GRCTRL.STR   - Structures and equates for print screen control 	;AN000;
;;	 GRPATTRN.STR - Structures for the printer patterns.			;AN000;
;;										;AN000;
;;	 GRSHAR.STR   - Shared Data Area Structure				;AN000;
;;										;AN000;
;;	 STRUC.INC    - Macros for using structured assembly language		;AN000;
;;										;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRCTRL.ASM: 						;AN000;
;;	      PRT_SCR - Main module for printing the screen.			;AN000;
;;	 TO FILE GRCOMMON.ASM							;AN000;
;;	      Common modules - tools for printing a screen.			;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 This file is included by GRCTRL.ASM					;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
PAGE										;AN000;
CODE	SEGMENT PUBLIC 'CODE'                                                   ;AN000;
	ASSUME		CS:CODE,DS:CODE 					;AN000;
										;AN000;
	PUBLIC	PRINT_BW_APA							;AN000;
	PUBLIC	LEN_OF_BW_MODULES						;AN000;
										;AN000;
.XLIST										;AN000;
INCLUDE GRCTRL.STR			; Stuctures needed			;AN000;
INCLUDE GRSHAR.STR			;  for both set of print modules	;AN000;
INCLUDE GRPATTRN.STR			;					;AN000;
INCLUDE GRCTRL.EXT			; Externals from PRT_SCR control module ;AN000;
INCLUDE STRUC.INC			;					;AN000;
										;AN000;
	PUBLIC PRINT_BW_APA		; Black and white modules,		;AN000;
.LIST										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PRINT_BW_APA : PRINT A GRAPHIC MODE SCREEN ON A BLACK AND WHITE PRINTER	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP	 = Offset of the shared data area			;AN000;
;		XLT_TAB  = Color translation table				;AN000;
;		BIOS_INT_5H = Pointer to BIOS int 5h				;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION:	This procedure	maps  each  pixel of the screen to a box	;AN000;
; of dots on the printer.  The box size depends on the screen resolution	;AN000;
; and  the number  of  bytes per printer line.	It is chosen in order to	;AN000;
; respect the  screen ratio and  is  documented in each printer profile.	;AN000;
;										;AN000;
;     For efficiency and space considerations, the print buffer does not	;AN000;
; hold a full print line.  Bytes representing pixels are printed as soon	;AN000;
; as they are  ready to be printed.  However, the print buffer	is  wide	;AN000;
; enough to hold complete boxes.						;AN000;
;										;AN000;
;     The order  for reading  pixels  off the screen  is  driven  by the	;AN000;
; order bytes  are  expected by the printer.  To print the screen in its	;AN000;
; original orientation we must begin reading it from the top left corner	;AN000;
; and  send  the pixels line by line; to print it sideways, reading will	;AN000;
; start from the bottom left  corner and a "LINE" will now be a vertical        ;AN000;
; screen column read from bottom to top.					;AN000;
;										;AN000;
;     There is	more  to it  however, the  printer  head  is  printing a	;AN000;
; vertical  column of 8 dots  at a time and each pixel read is mapped to	;AN000;
; a box of dots  that is less than  8 dots high  (e.g., 2 cols	x 1 row)	;AN000;
; therefore, many boxes must be stored in the bytes sent to the printer.	;AN000;
;										;AN000;
;     These boxes represent pixels that are one above each other on  the	;AN000;
; screen. We must read enough pixels on one column of the screen to  use	;AN000;
; all 8 bits of the vertical printer head (e.g., if the box size  is 2x1	;AN000;
; then 8  pixels  must be read	and  2 bytes of the print buffer will be	;AN000;
; filled).									;AN000;
;										;AN000;
;     The  PRINT BUFFER  for  any  box size  will be 8 bits high by "BOX        ;AN000;
; WIDTH" bits wide.                                                             ;AN000;
;										;AN000;
;     After the buffer is filled, it is  printed  and  the next "column"        ;AN000;
; of  8 pixels	is read.  Therefore,  the screen  is read "line by line"        ;AN000;
; where a line is  8 pixels high  for a 2x1 box (4 pixels high for a 3x2	;AN000;
; box).  ONE SUCH LINE IS CALLED A SCAN LINE.					;AN000;
;										;AN000;
PAGE										;AN000;
;										;AN000;
; A 350X200 screen mapping to a 3x2 box is read in the following order: 	;AN000;
;										;AN000;
; SCREEN:									;AN000;
;										;AN000;
;	  column column    . . .	column					;AN000;
;	  no. 0  no. 1			no. 349 				;AN000;
;	 				;AN000;
;  scan  1(0,0) 5(0,1) 	       1397(0,349)				;AN000;
;  line  2(1,0) 6(1,1)  . . . . . . . 1398(1,349)				;AN000;
;  no. 1 3(2,0) 7(2,1) 	       1399(2,349)				;AN000;
;	 4(3,0) 8(3,1) 	       1400(3,349)				;AN000;
;	 					  				;AN000;
;  scan  1401(4,0) 1405(4,1)			      LEGEND:	n(X,Y)		;AN000;
;  line  1402(5,0)   etc,			  				;AN000;
;  no. 2 1403(6,0)	     . . . . .		      n = READ RANK		;AN000;
;	 1404(7,0)				      X = ROW NUMBER		;AN000;
;	     . 				      Y = COLUMN NUMBER	;AN000;
;   etc,     . 				  				;AN000;
;	     . 		    70000(199,349)				;AN000;
;	 				;AN000;
;										;AN000;
;										;AN000;
; LOGIC :									;AN000;
;										;AN000;
; Initialize printer and local variables.					;AN000;
; CALL	  LOC_MODE_PRT_INFO ; Get printer info related to current mode. 	;AN000;
; CALL	  GET_SCREEN_INFO   ; Get info. about how to read the screen		;AN000;
; CALL	  SETUP_PRT	    ; Set up the printer (Line spacing, etc)		;AN000;
;										;AN000;
; FOR each scan line on the screen (NB_SCAN_LINES)				;AN000;
;   (Note: One scan line maps to one print line)				;AN000;
;   BEGIN									;AN000;
;   CALL DET_CUR_SCAN_LNE_LENGTH ; Determine length in pels of the current	;AN000;
;			  ;  scan line. 					;AN000;
;   IF CUR_SCAN_LNE_LENGTH NE 0 THEN						;AN000;
;     CALL NEW_PRT_LINE     ; Initialize a new printer line			;AN000;
;     DO CUR_SCAN_LNE_LENGTH times ; For each column				;AN000;
;	BEGIN									;AN000;
;	CALL FILL_BUFFER    ; Read top-down enough pels to fill the buffer	;AN000;
;	CALL PRINT_BUFFER   ; Print the buffer					;AN000;
;	IF printing sideways THEN INC CUR_ROW	 ; Get coordinates of next	;AN000;
;			     ELSE INC CUR_COLUMN ;  "column" (vertical chunk of ;AN000;
;	END (for each column)			 ;   a scan line).		;AN000;
;   PRINT_BYTE CR	  ; Print a CR and a LF 				;AN000;
;   PRINT_BYTE LF								;AN000;
;   ; Get coordinates of next scan line:					;AN000;
;   IF printing sideways THEN							;AN000;
;			      ADD CUR_COLUMN,NB_BOXES_PER_PRT_BUF		;AN000;
;			      MOV CUR_ROW,SCREEN_HEIGHT - 1			;AN000;
;			 ELSE							;AN000;
;			      ADD CUR_ROW,NB_BOXES_PER_PRT_BUF			;AN000;
;			      MOV CUR_COLUMN,0					;AN000;
;   END (for each scan line)							;AN000;
;										;AN000;
PRINT_BW_APA PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; INITIALIZATION:								;AN000;
;										;AN000;
;	1) Locate and extract printer DISPLAYMODE information from		;AN000;
;	   the shared data area, calculate the number of boxes fitting		;AN000;
;	   in the printer buffer.						;AN000;
;	2) Determine where to start reading the screen: 			;AN000;
;	     If printing sideways, start in LOW LEFT corner.			;AN000;
;	     If normal printing, start in TOP LEFT corner.			;AN000;
;	   Determine the maximum length for a scan line:			;AN000;
;	     If printing sideways, it is the height of the screen.		;AN000;
;	     For normal printing, it is the width of the screen.		;AN000;
;	   Determine the number of scan lines on the screen.			;AN000;
;	3) Set up the Printer for printing Graphics.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	LOC_MODE_PRT_INFO	; Get printer info related to curr. mode;AN000;
;										;AN000;
;-------Test if DISPLAYMODE info record was found:				;AN000;
       .IF <ERROR_CODE EQ DISPLAYMODE_INFO_NOT_FOUND>				;AN000;
       .THEN									;AN000;
	  MOV	  ERROR_CODE,UNABLE_TO_PRINT ; IF no record found,		;AN000;
	  JMP	  PRINT_BW_APA_END	     ; then, return error code		;AN000;
       .ENDIF				     ;	      and quit procedure	;AN000;
;										;AN000;
;-------Get the box size from the DISPLAYMODE info record:			;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Offset current DISPLAYMODE info.;AN000;
	MOV	AH,[BX].BOX_WIDTH	; Take local copy of the box size.	;AN000;
	MOV	BOX_W,AH		;  in BOX_W and BOX_H			;AN000;
	MOV	AL,[BX].BOX_HEIGHT						;AN000;
	MOV	BOX_H,AL							;AN000;
;										;AN000;
;-------Verify if the box size obtained from DISPLAYMODE info. is valid 	;AN000;
       .IF <ZERO AL> OR 		; IF height of the box is 0		;AN000;
       .IF <ZERO AH>			;  OR width of the box is 0		;AN000;
       .THEN				; THEN we can't print:                  ;AN000;
	  MOV	  ERROR_CODE,UNABLE_TO_PRINT ; return error code		;AN000;
	  JMP	  PRINT_BW_APA_END	;	and quit			;AN000;
       .ENDIF									;AN000;
;										;AN000;
;-------Get the Print Orientation from the DISPLAYMODE info record		;AN000;
       .IF <[BX].PRINT_OPTIONS EQ ROTATE>; If printing sideways 		;AN000;
       .THEN				;  then:				;AN000;
	  MOV	  ROTATE_SW,ON		;    Rotate switch := "ON"              ;AN000;
       .ENDIF									;AN000;
										;AN000;
;										;AN000;
;-------Initialize print variables and the printer:				;AN000;
	CALL	GET_SCREEN_INFO 	; Get info. about how to read the screen;AN000;
	CALL	SETUP_PRT		; Set up the printer (Line spacing, etc);AN000;
       .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>					;AN000;
       .THEN				; A printer error occurred: quit	;AN000;
	  JMP	  PRINT_BW_APA_END	;					;AN000;
       .ENDIF									;AN000;

	MOV	CX,NB_SCAN_LINES						;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Added the following modification to support printers with
;               vertical print heads, such as HP PCL printers.  
;
;                                       ; .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>
CMP     DS:[BP].DATA_TYPE,DATA_ROW      ;        
JNE     GOTO_ITS_DATA_COLUMN            ;
;-------------------------------------------------------------------------------
;										
; FOR EACH SCAN LINE ON THE SCREEN, WHICH REALLY IS JUST ONE LINE:					
;										
;-------------------------------------------------------------------------------
PRINT_1_LINE_OF_BOXES:                          ;
	CALL	DET_CUR_SCAN_LNE_LENGTH ; Determine how many non-blanks on line 
        CMP     CUR_SCAN_LNE_LENGTH,0           ; .IF <CUR_SCAN_LNE_LENGTH NE 0>
        JE      GOTO_NEXT_COORDINATES           ; If line is not empty then, 			
						;				
	        PUSH	CX			; Save scan line counter	
                XOR     CH,CH                   ; Clear register
                MOV     CL,BOX_H                ; CX is the # of times we need to read
                                                ; a line to print complete boxes.
                MOV     DS:[BP].ROW_TO_EXTRACT,CL ; Determines what row to extract
                DEC     DS:[BP].ROW_TO_EXTRACT  ; zero based
READ_LINE:                                      ;
	        CALL	NEW_PRT_LINE		;  Send escape sequence to the printer 
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR> ; for starting a new line.       
               .THEN				; If a printer error occurred:	       
                        POP     CX              ; Restore counter for how many times we
                        JMP     PRINT_BW_APA_END; need to read line and quit!
               .ENDIF		                ;							
                PUSH    DX                      ;
                PUSH    CX                      ; Save counter for how many times we 
                                                ; need to read line.
	        PUSH    CUR_ROW                 ; Save coordinates where start reading
                PUSH    CUR_COLUMN              ; line.
                MOV     AX,CUR_SCAN_LNE_LENGTH  ; DX:AX = counter for how many pixels need to
                CWD                             ; be read per line
                XOR     BH,BH                   ;
                MOV     BL,NB_BOXES_PER_PRT_BUF ;
                
                DIV     BX                      ;
               .IF <DX NE 0>                    ; So don't lose data when
                     INC        AX              ; have a remainder.
               .ENDIF                           ;
                MOV     CX,AX                   ; loop CX times to read all
                                                ; pixels on scan line.
                JMP     SHORT  PRINT_1_LINE     ; Jumps were out of range
GOTO_NEXT_COORDINATES:                          ;
        JMP     SHORT   NEXT_COORDINATES        ;
GOTO_PRINT_1_LINE_OF_BOXES:                     ;
        JMP     PRINT_1_LINE_OF_BOXES           ;
GOTO_ITS_DATA_COLUMN:                           ; 
        JMP     SHORT   ITS_DATA_COLUMN         ;
PRINT_1_LINE:                                   ;
                CALL    FILL_BUFFER             ; Read enough pixels to fill the buffer
                                                ; convert each to a printer box,
                                                ; extract a row from each box,
                                                ; store it in the print buffer
                CALL    PRINT_BUFFER            ; Print it
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>   ;				       
               .THEN				        ; A printer error occurred:	       
                        POP       CUR_COLUMN            ;
                        POP       CUR_ROW               ;
	                POP	  CX			; Restore counter for how many pixels
                                                        ; needed to read per line      
                        POP       DX                    ;
                        POP       CX                    ; Save scan line counter
	                JMP	  PRINT_BW_APA_END	; and quit				
               .ENDIF					;			       
                LOOP    PRINT_1_LINE                    ; Continue reading, converting, extracting
                                                        ; storing and printing.
	        CALL	END_PRT_LINE		        ;  Send escape sequence to the printer 
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>   ; for ending a line.	       
               .THEN				        ; If a printer error occurred: 
                        POP       CUR_COLUMN            ;
                        POP       CUR_ROW               ;
                        POP       CX                    ; Restore counter for how many times we
                                                        ; needed to read per line      
                        POP       DX                    ;
                        POP       CX                    ; Save scan line counter
                        JMP     PRINT_BW_APA_END; need to read line and quit!
               .ENDIF					;			       
                DEC     DS:[BP].ROW_TO_EXTRACT          ; Extract next row. Note:zero based
                POP     CUR_COLUMN                      ; Restore coordinates of beginning
                POP     CUR_ROW                         ; of "scan" line.
                POP     CX                              ; Restore counter for how many times we
                                                        ; needed to read per line      
                POP     DX                              ;
                LOOP    READ_LINE                       ; Read the line again so we can extract
                                                        ; the other rows out of the printer boxes
                POP      CX                             ; Save scan line counter

NEXT_COORDINATES:                                       ; End of, if line is not empty 
       .IF <CUR_SCAN_LNE_LENGTH EQ 0>                   ; 
                CALL    NEW_PRT_LINE                    ; Send esc. seq. to printer
       .ENDIF                                           ;
       .IF <ROTATE_SW EQ ON>                            ; Get coordinates of next "scan" line
       .THEN                                            ;
                INC CUR_COLUMN                          ;
       .ELSE                                            ;
                INC CUR_ROW                             ;
       .ENDIF                                           ;
        DEC     CX                                      ; Loop was out of range.  Read another
        CMP     CX,0                                    ; "scan" line and print the corresponding
        JNE     GOTO_PRINT_1_LINE_OF_BOXES; printer boxes.
        JMP     SHORT   DONE_WITH_PRINTING              ;

ITS_DATA_COLUMN:                                        ; .ELSE

; /\ ~~mda(001) -----------------------------------------------------------------------
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; FOR EACH SCAN LINE ON THE SCREEN:						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINT_1_SCAN_LINE:								;AN000;
	CALL	DET_CUR_SCAN_LNE_LENGTH ; Determine how many non-blanks on line ;AN000;
       .IF <CUR_SCAN_LNE_LENGTH NE 0>		; If line is not empty		;AN000;	
       .THEN					; then, 			;AN000;	
                CALL	NEW_PRT_LINE		;  Send escape sequence to the printer	;AN000;
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR> ; for starting a new line.;AN000;	
               .THEN				; If a printer error occurred:	;AN000;	
	                JMP  SHORT PRINT_BW_APA_END	;   Quit !		;AN000;	
               .ENDIF								;AN000;
										;AN000;
	        PUSH	CX			; Save scan line counter	;AN000;
	        MOV	CX,CUR_SCAN_LNE_LENGTH					;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; FOR each column on the current scan line (up to the last non-blank):		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINT_1_SCAN_COLUMN:								;AN000;
	        CALL	FILL_BUFFER		; Read all pixels on this column,    ;AN000;
					        ;   convert each to a printer box,   ;AN000;
					        ;    store boxes in the print buffer ;AN000;
					        ;     (a buffer contains one "column";AN000;
					        ;      of pixels).		     ;AN000;
	        CALL	PRINT_BUFFER		; Print the buffer.		     ;AN000;
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>				     ;AN000;
               .THEN				; A printer error occurred:	     ;AN000;
	                POP	  CX			; Restore scan line counter and quit	;AN000;
	                JMP	  SHORT  PRINT_BW_APA_END	;			;AN000;
               .ENDIF								;AN000;
										;AN000;
										;AN000;
;-------Get coordinates of next "column":                                       ;AN000;
               .IF <ROTATE_SW EQ ON>		; If printing sideways		;AN000;
               .THEN				;				;AN000;
	                DEC CUR_ROW			; then, get row above on screen	;AN000;
               .ELSE				;				;AN000;
	                INC CUR_COLUMN		; else, get column next right	;AN000;
               .ENDIF				;				;AN000;
										;AN000;
        	LOOP	PRINT_1_SCAN_COLUMN	; Print next column		;AN000;
										;AN000;
	        POP	CX			; Restore scan line counter	;AN000;
       .ENDIF					; Endif line is not empty	;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Print a carriage return and a line feed:					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Commented out the following and replaced it with the procedure
;               END_PRT_LINE because this procedure takes care of this as well
;               as sending the esc. seq. that comes after the keyword DATA.
;
;       MOV	AL,CR							;AN000;
;	CALL	PRINT_BYTE		        ; Send CR		;AN000;
;	JC	PRINT_BW_APA_END	        ; If printer error, leave;AN000;
;	MOV	AL,LF				;			;AN000;
;	CALL	PRINT_BYTE		        ; Send LF		;AN000;
;	JC	PRINT_BW_APA_END	        ; If printer error, leave;AN000;
;                                               ;
	CALL	END_PRT_LINE		        ;  Send escape sequence to the printer	;AN000;
       .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>   ; for ending a line, and for      ;AN000;
                                                ; doing a CR and LF.
       .THEN				        ; If a printer error occurred:	  ;AN000;
	JMP	SHORT   PRINT_BW_APA_END        ;   Quit !			  ;AN000;
       .ENDIF					;			;AN000;
; /\ ~~mda(001) -----------------------------------------------------------------------

        JMP     SHORT   GET_NEXT_SCAN_LINE      ;~~mda(001) Used this to replace a
GOTO_PRINT_1_SCAN_LINE:                         ; loop that was out or range.
        JMP     PRINT_1_SCAN_LINE               ;
GET_NEXT_SCAN_LINE:                             ;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Get coordinates of next scan line:						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
               .IF <ROTATE_SW EQ ON>		; If printing sideways		;AN000;
               .THEN				; then: 			;AN000;
	                MOV	  AL,NB_BOXES_PER_PRT_BUF ;   AX := Numbers of pels read on row ;AN000;
	                CBW				;				;AN000;
	                ADD	  CUR_COLUMN,AX 	;   CUR_COLUMN + Number of pels read	;AN000;
	                MOV	  AX,SCREEN_HEIGHT	;   CUR_ROW := SCREEN_HEIGHT - 1;AN000;
	                DEC	  AX			;				;AN000;
	                MOV	  CUR_ROW,AX		;				;AN000;
               .ELSE				; else, printing NOT rotated:	;AN000;
	                MOV	  AL,NB_BOXES_PER_PRT_BUF ;   AX := Number of pels read on colum;AN000;
	                CBW				;				;AN000;
	                ADD	  CUR_ROW,AX		;   CUR_ROW + Number of pels read;AN000;
	                MOV	  CUR_COLUMN,0		;   CUR_COLUMN := 0		;AN000;
               .ENDIF				;				;AN000;
;;        LOOP	PRINT_1_SCAN_LINE	;~~mda(001) Commented it out cause loop is  ;AN000;
                                        ;           out of range.
        DEC     CX                      ;~~mda(001) Used this instead of the LOOP
        OR      CX,CX
        JNZ      GOTO_PRINT_1_SCAN_LINE  ;
DONE_WITH_PRINTING:                     ;~~mda(001) Label for endif.										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Restore the printer.								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	RESTORE_PRT							;AN000;
PRINT_BW_APA_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PRINT_BW_APA ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; FILL_BUFFER : READS ENOUGH PIXELS TO FILL UP THE PRINT BUFFER.		;AN000;
;		THESE PIXELS ARE MAPPED TO A PRINTER DOT BOX.			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	CUR_COLUMN,							;AN000;
;		CUR_ROW = Coordinates of the first pixel to be read		;AN000;
;		BOXES_PER_PRT_BUF = Number of boxes fitting in the print	;AN000;
;				    buffer					;AN000;
;		XLT_TAB = Color translation table				;AN000;
;										;AN000;
;	OUTPUT: PRT_BUF = PRINT BUFFER						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION:									;AN000;
;										;AN000;
;	1) Pixels are read one by one vertically from top to bottom in		;AN000;
;	   the current column of the screen scan line.				;AN000;
;	   NOTE: What is called here a 'column' can actually be a line          ;AN000;
;		 on the physical display.					;AN000;
;	2) Each pixel is mapped to a printer dot box.				;AN000;
;	3) Each Dot box is stored in the printer buffer.			;AN000;
;	4) The coordinates in input are those of the "top" pixel                ;AN000;
;	   and restored when leaving this procedure.				;AN000;
;										;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Save coordinates of the current "column" (slice of a screen scan line)        ;AN000;
; DO for BOXES_PER_PRT_BUF  (8 / BOX_H) 					;AN000;
;   BEGIN									;AN000;
;   CALL READ_DOT		  ; Read a pixel, get index in XLT_TAB		;AN000;
;   Get pixel intensity from XLT_TAB						;AN000;
;   CALL INT2PAT		  ; Locate pattern corresponding to int.	;AN000;
;   CALL PAT2BOX		  ; Extract box from pattern			;AN000;
;   CALL STORE_BOX		  ; Store the box in the printer buffer 	;AN000;
;   ; Get coordinates of next pixel below:					;AN000;
;   IF printing is sideways THEN INC CUR_COLUMN 				;AN000;
;			    ELSE INC CUR_ROW					;AN000;
;   END 									;AN000;
; Restore initial coordinates.							;AN000;
;										;AN000;
FILL_BUFFER PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Save initial coordinates:							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;	        If DATA_TYPE is equal to DATA_ROW then we have a horizontal 
;               print head so we SHOULDN'T save CUR_ROW and CUR_COLUMN because 
;               we are moving down the "scan" line from left to right a little 
;               at a time, that is we don't finish reading the scan line until 
;               we have made repeated calls to this procedure.  Remember since
;               we're dealing with horizontal print heads one scan line is 
;               really just one line.
;                                                  ;
       .IF <DS:[BP].DATA_TYPE NE DATA_ROW>         ;
                                                   ;
	        PUSH	CUR_ROW 		   ;					
	        PUSH	CUR_COLUMN		   ;					
       .ENDIF					   ;					
;/\  ~~mda(001) -----------------------------------------------------------------------
;-------Clear the print buffer: 						;AN000;
	XOR	BX,BX		; For each byte in the PRT_BUF: 		;AN000;
CLEAR_PRT_BUF:									;AN000;
	MOV	PRT_BUF[BX],0	;  Initialize byte to blanks			;AN000;
	INC	BX		;  Get next byte				;AN000;
	CMP	BL,BOX_W	;  All bytes cleared ?				;AN000;
	JL	CLEAR_PRT_BUF	;  No, clear next one.				;AN000;
										;AN000;
	MOV	BX,OFFSET XLT_TAB ; BX := Offset of XLT_TAB			;AN000;
										;AN000;
;-------Fill the print buffer with one box for each pixel read: 		;AN000;
	XOR	CX,CX		; CL := Number of pixels to read		;AN000;
	MOV	CL,NB_BOXES_PER_PRT_BUF 					;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; For each pixel within the current column of the scan line:			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
READ_AND_STORE_1_PIXEL: 							;AN000;
	CALL	READ_DOT		; AL := Index into translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Intensity			;AN000;
	CALL	INT2PAT 		; SI := Offset of matching Pattern	;AN000;
	CALL	PAT2BOX 		; Extract CUR_BOX from the pattern.	;AN000;
	MOV	SI,OFFSET CUR_BOX	; Store it in the PRT_BUF		;AN000;
	CALL	STORE_BOX							;AN000;
										;AN000;
;-------Get coordinates of next pixel:						;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               If DATA_TYPE is DATA_ROW then we have a horizontal print head
;               so we need to read the next pixel on the scan line.  Remember
;               since we're dealing with horizontal print heads one scan line
;               is really just one line. For every pixel read we need to store 
;               one row of the corresponding box in the print buffer.
;
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>      ;
                .IF <ROTATE_SW EQ ON>		; If printing sideways			
                .THEN				;					
	                DEC CUR_ROW		; then, decrement row number   
                .ELSE				;			       
	                INC CUR_COLUMN		; else, increment column number
                .ENDIF				;			       
       .ELSE                                    ;
;/\  ~~mda(001) -----------------------------------------------------------------------
                .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
                .THEN				;					;AN000;
	                INC CUR_COLUMN		; then, increment column number 	;AN000;
                .ELSE				;					;AN000;
	                INC CUR_ROW		; else, increment row number		;AN000;
                .ENDIF				;					;AN000;
       .ENDIF                                   ; ~~mda(001) Close IF stmt.
	LOOP READ_AND_STORE_1_PIXEL						;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Restore initial coordinates:							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               If DATA_TYPE = DATA_ROW then we don't restore initial coordinates.
;
       .IF <DS:[BP].DATA_TYPE NE DATA_ROW>         ;
	        POP	CUR_COLUMN		   ;					
	        POP	CUR_ROW 		   ;					
       .ENDIF					   ;					
;/\  ~~mda(001) -----------------------------------------------------------------------
										;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
FILL_BUFFER ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; INT2PAT : MAP AN INTENSITY TO A PATTERN.					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	AL = GREY INTENSITY (0 - 63 = BLACK to WHITE)			;AN000;
;		BOX_W = Number of columns in a box				;AN000;
;		CUR_MODE_PTR = Offset of current DISPLAYMODE info record	;AN000;
;										;AN000;
;	OUTPUT: SI = OFFSET OF THE PATTERN MATCHING THE INTENSITY		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Performs a sequential search in the table of patterns		;AN000;
; until the proper pattern is found.						;AN000;
;										;AN000;
;										;AN000;
; SI = 0 ; FOUND = FALSE							;AN000;
; DO UNTIL FOUND = TRUE 							;AN000;
;   BEGIN									;AN000;
;   IF AL <= Maximum intensity of the current pattern in the table		;AN000;
;     THEN									;AN000;
;	FOUND = TRUE								;AN000;
;     ELSE									;AN000;
;	SI = SI + (BOX_W * 2)							;AN000;
;   END 									;AN000;
;										;AN000;
INT2PAT PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	DX								;AN000;
										;AN000;
;-------Calculate the size in bytes of one pattern STRUCTURE: (see GRPATTRN.STR);AN000;
	MOV	DL,BOX_W	; DX := Number of columns in the box		;AN000;
	XOR	DH,DH								;AN000;
	SHL	DL,1		; (DX * 2) = Number of columns in the pattern	;AN000;
	INC	DL		; DL := Size in bytes of one pattern		;AN000;
				;	(includes intensity field)		;AN000;
	MOV	BX,CUR_MODE_PTR ; BX := Offset of current mode			;AN000;
				; SI := Offset of the first pattern		;AN000;
	MOV	SI,[BX].PATTERN_TAB_PTR 					;AN000;
	ADD	SI,BP								;AN000;
										;AN000;
COMPARE_INTENSITY:								;AN000;
	CMP	AL,[SI] 	; Within the range of this pattern ?		;AN000;
	JLE	FOUND_PATTERN	;   Yes, use this pattern.			;AN000;
				;   No, look at next pattern:			;AN000;
	ADD	SI,DX		;     SI := SI + Number columns in pattern)	;AN000;
	JMP	SHORT COMPARE_INTENSITY 					;AN000;
										;AN000;
FOUND_PATTERN:									;AN000;
										;AN000;
	POP	DX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
										;AN000;
INT2PAT ENDP									;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PAT2BOX : SELECT AND EXTRACT THE PROPER BOX FROM THE PATTERN ACCORDING	;AN000;
;	    TO THE COORDINATES OF THE PIXEL.					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	SI = OFFSET OF CURRENT PATTERN					;AN000;
;		CUR_COLUMN,							;AN000;
;		CUR_ROW  = COORDINATES OF THE CURRENT PIXEL			;AN000;
;										;AN000;
;	OUTPUT: CUR_BOX  = PORTION OF THE PATTERN TO BE PRINTED 		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: If the pixel is on even-even coordinates, then the		;AN000;
; top-left box of the pattern is extracted.					;AN000;
; If its Even-odd --> extract the top-right box.				;AN000;
; Odd-even --> low-left box, and Odd-odd  --> low-right box.			;AN000;
;										;AN000;
PAGE										;AN000;
;  For example., (with a 3x2 box):						;AN000;
;										;AN000;
;  PATTERN (over 6 bytes):							;AN000;
;										;AN000;
;										;AN000;
;	       byte1  byte2  byte3	byte4  byte5  byte6			;AN000;
;										;AN000;
;		 0	0      0	  0	 0	0			;AN000;
;		 0	0      0	  0	 0	0			;AN000;
;		 0	0      0	  0	 0	0			;AN000;
;		 0	0      0	  0	 0	0			;AN000;
; even-even --> dot1   dot2   dot3   |	 dot1	dot2   dot3 <-- even-odd	;AN000;
; (row-column)	dot4   dot5   dot6   |	 dot4	dot5   dot6	box		;AN000;
; box.	       ------------------------------------------------ 		;AN000;
; odd-even  --> dot1   dot2   dot3   |	 dot1	dot2   dot3 <-- odd-odd 	;AN000;
; box		dot4   dot5   dot6   |	 dot4	dot5   dot6	box		;AN000;
;										;AN000;
;										;AN000;
;  The selected box is then stored as follow:					;AN000;
;										;AN000;
;  CUR_BOX:									;AN000;
;		byte1 byte2 byte3						;AN000;
;     MSB ------> 0	0     0 						;AN000;
;     (bit7)	  0	0     0 						;AN000;
;		  0	0     0 						;AN000;
;		  0	0     0 						;AN000;
;		  0	0     0 						;AN000;
;		  0	0     0 						;AN000;
;		 dot1  dot2  dot3 <-- box					;AN000;
;     LSB ------>dot4  dot5  dot6						;AN000;
;										;AN000;
; LOGIC:									;AN000;
; IF CUR_ROW is odd								;AN000;
; THEN SI := SI + BOX_W 	; Access right portion of pattern		;AN000;
; Build a bit mask in BL of BOX_H bits, right justified.			;AN000;
; FOR each column in the box (BOX_W)						;AN000;
;   Get the pattern column in AL						;AN000;
;   IF CUR_COLUMN is even							;AN000;
;   THEN									;AN000;
;     Move down the column of the top box.					;AN000;
;   AND BL,AL			; BL <-- Column of the desired box		;AN000;
;										;AN000;
;										;AN000;
PAT2BOX PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
										;AN000;
					; SI := Offset of current pattern	;AN000;
	INC	SI			; Skip the MAX INTENSITY field		;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Set SI to either the left or right set of 2 boxes in the pattern:		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	TEST	CUR_ROW,1		; Odd row ?				;AN000;
	JZ	EXTRACT_BOX		;   No,  access left portion of pattern ;AN000;
	MOV	AL,BOX_W		;					;AN000;
	CBW				;					;AN000;
	ADD	SI,AX			;   Yes, access right portion of pattern;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Extract the box:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
EXTRACT_BOX:									;AN000;
;-------Build a bit mask that will be used to keep only BOX_H bits		;AN000;
;-------of the bytes where CUR_BOX is stored.					;AN000;
	XOR	AH,AH			; AH := Box column bit mask		;AN000;
	MOV	AL,BOX_H		; For each row of the box:		;AN000;
INIT_MASK:				;					;AN000;
	SHL	AH,1			;					;AN000;
	OR	AH,1			;    Insert one bit in the mask.	;AN000;
	DEC	AL			;					;AN000;
	CMP	AL,0			;					;AN000;
	JG	INIT_MASK							;AN000;
										;AN000;
	XOR	BX,BX			; BL := Column number within the box	;AN000;
;										;AN000;
;-------For each column of the box:						;AN000;
EXTRACT_1_BOX_COLUMN:								;AN000;
	MOV	AL,[SI] 		; AL := Current column of pattern	;AN000;
	TEST	CUR_COLUMN,1		; If the pixel is on ODD column 	;AN000;
	JNZ	BOTTOM_BOX		;   Then, need bottom box portion	;AN000;
	MOV	CL,BOX_H		;   Else, need top box portion		;AN000;
TOP_BOX:				; Need top box: 			;AN000;
	SHR	AL,CL			;   Shift top box over bottom box	;AN000;
BOTTOM_BOX:				; The box we want is now at bottom	;AN000;
	AND	AL,AH			; Keep only bits from the box		;AN000;
	MOV	CUR_BOX[BX],AL		; Store this box column 		;AN000;
	INC	SI			; Access next column of the pattern	;AN000;
	INC	BX			; One more column stored.		;AN000;
	CMP	BL,BOX_W		; All stored ?				;AN000;
	JL	EXTRACT_1_BOX_COLUMN	;   No, continue			;AN000;
										;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PAT2BOX ENDP									;AN000;
INCLUDE GRCOMMON.ASM								;AN000;
LEN_OF_BW_MODULES EQU $-PRINT_BW_APA						;AN000;
CODE	ENDS									;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\grcolprt.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Color printing modules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                              
;;										;AN000;
;; File Name:  GRCOLPRT.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the code for printing a screen (text and graphics)	;AN000;
;;	 on a COLOR printer.							;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;										;AN000;
;;	PRINT_COLOR								;AN000;
;;	  SCAN_FOR_BANDS_APA							;AN000;
;;	  SCAN_FOR_BANDS_TXT							;AN000;
;;	  PRINT_BAND_APA							;AN000;
;;	  PRINT_BAND_TXT							;AN000;
;;	  SET_CURSOR								;AN000;
;;	  SET_COLOR_BAND							;AN000;
;;	  INIT_BLACK_BOX							;AN000;
;;										;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;										;AN000;
;;	 GRCTRL.EXT   - Externals for print screen control			;AN000;
;;	 GRCTRL.STR   - Structures and equates for print screen control 	;AN000;
;;	 GRPATTRN.STR - Structures for the printer patterns.			;AN000;
;;										;AN000;
;;	 GRSHAR.STR   - Shared Data Area Structure				;AN000;
;;										;AN000;
;;	 STRUC.INC    - Macros for using structured assembly language		;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRCTRL.ASM: 						;AN000;
;;	      PRT_SCR - Main module for printing the screen.			;AN000;
;;	 TO FILE GRCOMMON.ASM							;AN000;
;;	      Common modules - tools for printing a screen.			;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;	 Date last updated 5/26/87.						;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
PAGE										;AN000;
CODE	SEGMENT PUBLIC 'CODE'                                                   ;AN000;
	ASSUME		CS:CODE,DS:CODE 					;AN000;
										;AN000;
	PUBLIC	PRINT_MODULE_START     ;; Color modules public			;AN000;
	PUBLIC	PRINT_COLOR	       ;;  procedures				;AN000;
	PUBLIC	LEN_OF_COLOR_MODULES   ;;					;AN000;
				       ;;					;AN000;
.XLIST					;					;AN000;
INCLUDE GRCTRL.STR			; Stuctures needed			;AN000;
INCLUDE GRSHAR.STR			;  for both set of print modules	;AN000;
INCLUDE GRPATTRN.STR			;					;AN000;
					;					;AN000;
INCLUDE GRCTRL.EXT			; Externals from PRT_SCR control module ;AN000;
INCLUDE STRUC.INC			;					;AN000;
.LIST					;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
;;										;AN000;
;;										;AN000;
;; PRINT_COLOR : PRINT TEXT AND APA MODE SCREEN ON A COLOR PRINTER		;AN000;
;;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP	 = Offset of the shared data area			;AN000;
;		XLT_TAB  = Color translation table				;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Main control module for printing of text and graphics			;AN000;
;;   on color printers. 							;AN000;
;;										;AN000;
;;   Calls either the text or graphics mode routine.				;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   PRINT_SCREEN								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   LOC_MODE_PRT_INFO, PRINT_COLOR_APA, PRINT_COLOR_TXT			;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   IF MODE_TYPE = TXT 							;AN000;
;;     THEN CALL PRINT_COLOR_TXT						;AN000;
;;   ELSE (MODE_TYPE = APA)							;AN000;
;;     CALL LOC_MODE_PRT_INFO	 ; Get DISPLAYMODE record from the SHARED AREA	;AN000;
;;     CALL PRINT_COLOR_APA							;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	;AN000;
PRINT_MODULE_START  LABEL BYTE							;AN000;
PRINT_COLOR	PROC NEAR							;AN000;
	JMP	SHORT PRINT_COLOR_BEGIN 					;AN000;
WHITE_BOX	DB	0,0,0,0 ; Print boxes for APA mode			;AN000;
BLACK_BOX	DB	?,?,?,? ;  NOTE: 1 print box = 1 screen pixel		;AN000;
				;   only BOX_W bytes are used out of these 2	;AN000;
				;    boxes.					;AN000;
										;AN000;
REQ_BAND_MASK	DB	?	; Mask = "All color bands needed for the current;AN000;
				;	   print line".                         ;AN000;
										;AN000;
PRINT_COLOR_BEGIN:								;AN000;
.IF <MODE_TYPE EQ TXT>								;AN000;
.THEN										;AN000;
;-------------------------------------------------------------------------------;AN000;
; The screen is in a text mode: 						;AN000;
;-------------------------------------------------------------------------------;AN000;
  CALL PRINT_COLOR_TXT			; Print a text screen on a color printer;AN000;
.ELSE										;AN000;
;-------------------------------------------------------------------------------;AN000;
; The screen is in All Points Addressable mode: 				;AN000;
; Locate and extract printer DISPLAYMODE information from			;AN000;
; the shared data area. 							;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	LOC_MODE_PRT_INFO	; Get printer info related to curr. mode;AN000;
;										;AN000;
;-------Test if DISPLAYMODE info record was found:				;AN000;
       .IF <ERROR_CODE EQ DISPLAYMODE_INFO_NOT_FOUND>				;AN000;
       .THEN									;AN000;
	  MOV	  ERROR_CODE,UNABLE_TO_PRINT ; IF no record found,		;AN000;
	  JMP	  SHORT PRINT_COLOR_END      ; then, return error code		;AN000;
       .ENDIF				     ;	      and quit procedure	;AN000;
;										;AN000;
;-------Get the box size from the DISPLAYMODE info record:			;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Offset current DISPLAYMODE info.;AN000;
	MOV	AH,[BX].BOX_WIDTH	; Take local copy of the box size.	;AN000;
	MOV	BOX_W,AH		;  in BOX_W and BOX_H			;AN000;
	MOV	AL,[BX].BOX_HEIGHT						;AN000;
	MOV	BOX_H,AL							;AN000;
;										;AN000;
;-------Verify if the box size obtained from DISPLAYMODE info. is valid 	;AN000;
       .IF <ZERO AL> OR 		; IF height of the box is 0		;AN000;
       .IF <ZERO AH>			;  OR width of the box is 0		;AN000;
       .THEN				; THEN we can't print:                  ;AN000;
	  MOV	  ERROR_CODE,UNABLE_TO_PRINT ; return error code		;AN000;
	  JMP	  SHORT PRINT_COLOR_END      ;	     and quit			;AN000;
       .ENDIF									;AN000;
;										;AN000;
;-------Get the Print Orientation from the DISPLAYMODE info record		;AN000;
       .IF <[BX].PRINT_OPTIONS EQ ROTATE>; If printing sideways 		;AN000;
       .THEN				;  then:				;AN000;
	  MOV	  ROTATE_SW,ON		;    Rotate switch := "ON"              ;AN000;
       .ENDIF									;AN000;
  CALL PRINT_COLOR_APA			; Print APA screen on a color printer	;AN000;
.ENDIF										;AN000;
PRINT_COLOR_END:								;AN000;
	RET									;AN000;
PRINT_COLOR ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PRINT_COLOR_TXT: PRINT A TEXT MODE SCREEN ON A COLOR PRINTER			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP		     = Offset of the shared data area		;AN000;
;		XLT_TAB 	     = Color translation table			;AN000;
;		SCREEN_WIDTH	     = Maximum length of Screen scan line.	;AN000;
;		SCREEN_HEIGHT	     = Number of SCAN LINES on the screen	;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: The screen is read and printed line by line; character by	;AN000;
; character.									;AN000;
; Each line is first scanned in order to determine what colors are present on	;AN000;
; it and what printer bands will be needed to approximate these colors. 	;AN000;
;										;AN000;
; For each printer color band needed for the current line, this screen line	;AN000;
; is READ AGAIN character by character; If the color of the			;AN000;
; current character must use the current color band to be			;AN000;
; approximated; then, the character is printed. 				;AN000;
;										;AN000;
;										;AN000;
; LOGIC :									;AN000;
;										;AN000;
; Save current coordinates of the cursor.					;AN000;
; Initialize the cursor to the first character to be read  (Top-left of screen) ;AN000;
; FOR each row on the screen (SCREEN_HEIGHT)					;AN000;
;   BEGIN									;AN000;
;   CALL SCAN_FOR_BANDS_TXT(CUR_ROW,CUR_COLUMN,REQ_BAND_MASK)			;AN000;
;   CUR_BAND_MASK := 01H							;AN000;
;   IF REQ_BAND_MASK <> 0 THEN							;AN000;
;	DO 8 TIMES								;AN000;
;	 IF (REQ_BAND_MASK AND CUR_BAND_MASK)=1 THEN				;AN000;
;	    CALL PRINT_BAND_TXT(CUR_ROW,CUR_COLUMN,CUR_BAND_MASK)		;AN000;
;	    CALL PRINT_BYTE(CARRIAGE_RETURN)					;AN000;
;	  ENDIF 								;AN000;
;	  Shift CUR_BAND_MASK one bit left					;AN000;
;	ENDDO									;AN000;
;	CALL PRINT_BYTE(LINE_FEED)						;AN000;
;   ENDIF									;AN000;
;   CUR_COLUMN := 0		    ; Get next row coordinates			;AN000;
;   CUR_ROW    := CUR_ROW + 1							;AN000;
;   END ; FOR each row on the screen						;AN000;
; Restore initial coordinates of the cursor					;AN000;
;										;AN000;
PRINT_COLOR_TXT PROC								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
;										;AN000;
;-------Save coordinates of the cursor on the stack:				;AN000;
	MOV	AH,READ_CURSOR_CALL  ; Read position of the cursor on the screen;AN000;
	MOV	BH,CUR_PAGE	     ;	for the current page			;AN000;
	INT	10H		     ; Call BIOS				;AN000;
	PUSH	DX		     ; DH := Row number, DL := Column number	;AN000;
				     ; CX := Top line and bottom line for cursor;AN000;
				     ;	      (not needed)			;AN000;
;										;AN000;
;-------Initialize the cursor to the first character to be read 		;AN000;
	MOV	CUR_ROW,0	     ; cursor = position (0,0) on the screen	;AN000;
	MOV	CUR_COLUMN,0	     ;	(top-left corner)			;AN000;
	CALL	SET_CURSOR							;AN000;
										;AN000;
	MOV	CX,SCREEN_HEIGHT     ; CX := Number of rows on the screen	;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; FOR EACH ROW ON THE SCREEN:							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINT_1_TEXT_LINE:								;AN000;
	CALL	SCAN_FOR_BANDS_TXT	; REQ_BAND_MASK := Print bands needed	;AN000;
					;  for this line			;AN000;
	MOV	DL,01H			; DL :="Current Band printed" mask      ;AN000;
										;AN000;
	; NOTE: The COLORSELECT records are stored sequentially in the		;AN000;
	; Shared Data area. The band mask 00000001 corresponds to the first	;AN000;
	; record, 00000010 to the second, etc.					;AN000;
	; The COLORSELECT record indicates: "How to select the color band"      ;AN000;
	; on the printer (It contains the bytes that must be sent to the printer;AN000;
										;AN000;
	MOV	BX,DS:[BP].COLORSELECT_PTR; BX := relative offset of COLORSELECT;AN000;
	ADD	BX,BP			; BX := absolute offset of COLORSELECT	;AN000;
	PUSH	CX			; Save row counter			;AN000;
	MOV	CX,8			; For up to the maximum number of print ;AN000;
					;  bands with this printer		;AN000;
	;-----------------------------------------------------------------------;AN000;
	;									;AN000;
	; FOR each Color Band available with the ribbon installed on the printer;AN000;
	;									;AN000;
	;-----------------------------------------------------------------------;AN000;
	PRINT_1_COLOR_BAND_TXT: 	  ; Do one pass of the printer head:	;AN000;
	 .IF <BIT REQ_BAND_MASK AND DL>   ; IF this color band is needed	;AN000;
	 .THEN				  ;  by any character on the line	;AN000;
	    CALL SET_COLOR_BAND 	  ; then, select the color band 	;AN000;
	    CALL PRINT_BAND_TXT 	  ;    and do one Print Pass for it.	;AN000;
	   .IF	<BIT ERROR_CODE NZ PRINTER_ERROR>				;AN000;
	   .THEN			  ; A printer error occurred:		;AN000;
	      POP     CX		  ;   Restore the line counter		;AN000;
	      JMP     SHORT  PRINT_COLOR_TXT_END ;    and quit.			;AN000;
	   .ENDIF								;AN000;
	    MOV     AL,CR		  ;    Print a carriage return		;AN000;
	    CALL    PRINT_BYTE							;AN000;
	   .IF	C								;AN000;
	   .THEN			  ; A printer error occurred:		;AN000;
	      POP     CX		  ;   Restore the line counter		;AN000;
	      JMP     SHORT    PRINT_COLOR_TXT_END ;    and quit.			;AN000;
	   .ENDIF			  ; ENDIF printer error 		;AN000;
	 .ENDIF 			  ; ENDIF this color band is needed	;AN000;
	  SHL	  DL,1			  ; Get next Color Band mask		;AN000;
					  ; [BX] := Next COLORSELECT record:	;AN000;
	  MOV	  AL,[BX].NUM_SELECT_ESC  ;	skip the escape bytes		;AN000;
	  XOR	  AH,AH 		  ;					;AN000;
	  ADD	  BX,AX 		  ;					;AN000;
	  INC	  BX			  ;	skip the NUM_SELECT_ESC field	;AN000;
	LOOP	PRINT_1_COLOR_BAND_TXT						;AN000;
	POP	CX			  ; Restore row counter 		;AN000;
;										;AN000;
;-----Print a line feed:							;AN000;
	MOV	AL,LF								;AN000;
	CALL	PRINT_BYTE		; Send the LF				;AN000;
	JC	PRINT_COLOR_TXT_END	; If printer error, quit		;AN000;
;										;AN000;
;-------Get coordinates of the first character in the next scan line:		;AN000;
	INC	CUR_ROW 		;   CUR_ROW + 1 			;AN000;
	MOV	CUR_COLUMN,0		;   CUR_COLUMN := 0			;AN000;
;										;AN000;
;-------Point CURSOR to first character in the next scan line:			;AN000;
	CALL	SET_CURSOR							;AN000;
										;AN000;
	LOOP	PRINT_1_TEXT_LINE	; Print next scan line			;AN000;
										;AN000;
;										;AN000;
;-------Restore CURSOR to its original location (saved on the stack)		;AN000;
PRINT_COLOR_TXT_END:								;AN000;
	POP	DX			; DH := Row number, DL := Column number ;AN000;
	MOV	CL,DH								;AN000;
	MOV	CUR_ROW,CX		; CUR_ROW := Original row number	;AN000;
	MOV	CL,DL								;AN000;
	MOV	CUR_COLUMN,CX		; CUR_COLUMN := Original column number	;AN000;
	CALL	SET_CURSOR		; Set the cursor back there		;AN000;
										;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
PRINT_COLOR_TXT ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; SCAN_FOR_BANDS_TEXT: DETERMINE WHAT PRINTER COLOR BANDS ARE NEEDED FOR	;AN000;
;			PRINTING THE COLORS ON THE CURRENT SCREEN LINE. 	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; INPUT:  CUR_ROW	      = row to start scanning				;AN000;
;	  CUR_COLUMN	      = column to start scanning			;AN000;
;	  ROTATE_SW	      = ON if printing is sideways			;AN000;
;										;AN000;
; OUTPUT: REQ_BAND_MASK 							;AN000;
;										;AN000;
;										;AN000;
; DATA STRUCTURE REFERENCED:							;AN000;
;	  XLT_TAB	     = Color translation table				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Read all characters on the current line from left to right.	;AN000;
; For each character, extract its band mask from the color translation table.	;AN000;
; Add the band mask required for this character to the "Required Bands" mask.   ;AN000;
;										;AN000;
; LOGIC :									;AN000;
; Save current coordinates							;AN000;
; DO (SCREEN_WIDTH) TIMES							;AN000;
;   Read a character								;AN000;
;   Get its Band Mask from the color translation table in AL			;AN000;
;   OR REQ_BAND_MASK,AL 	; Add its band mask to the "Required bands" mask;AN000;
;   ; Get coordinates of the next character:					;AN000;
;   INC CUR_COLUMN								;AN000;
; Restore initial coordinates							;AN000;
;										;AN000;
SCAN_FOR_BANDS_TXT PROC NEAR							;AN000;
	PUSH	CUR_ROW 		; Save coordinates			;AN000;
	PUSH	CUR_COLUMN							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	REQ_BAND_MASK,0 	; No Color bands needed so far...	;AN000;
	MOV	CX,SCREEN_WIDTH 	; For each character on the screen row	;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; FOR each character on the current scan line:					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
SCAN_1_CHAR:									;AN000;
;										;AN000;
;-------Read the character at the current cursor position			;AN000;
	CALL	SET_CURSOR		; Set cursor at character to be read	;AN000;
	MOV	AH,READ_CHAR_CALL	; Read one character			;AN000;
	MOV	BH,CUR_PAGE		;  at CUR_PAGE, CUR_COLUMN and CUR_ROW	;AN000;
	INT	10H			; Call BIOS				;AN000;
					; AL:=Character read, AH:=Byte attribute;AN000;
	AND	AH,00001111B		; AH := Foreground color attribute	;AN000;
	XCHG	AL,AH			; AL := AH, used as index in the XLT_TAB;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of translation table	;AN000;
	XLAT	XLT_TAB 		; AL  = Band mask			;AN000;
;										;AN000;
;-------Obtain what Print bands are required to print the color of this char:	;AN000;
	OR	REQ_BAND_MASK,AL						;AN000;
										;AN000;
	INC	CUR_COLUMN		; Get coordinates of next character	;AN000;
	LOOP	SCAN_1_CHAR		; Scan next character			;AN000;
										;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	POP	CUR_COLUMN		; Restore initial coordinates		;AN000;
	POP	CUR_ROW 							;AN000;
	RET									;AN000;
SCAN_FOR_BANDS_TXT ENDP 							;AN000;
PAGE										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
;;										;AN000;
;;   PRINT_BAND_TXT: PRINT ALL CHARACTERS ON THE CURRENT LINE THAT ARE THE SAME ;AN000;
;;		     COLOR AS THE CURRENT PRINT BAND.				;AN000;
;;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;  INPUT:  CUR_ROW,								;AN000;
;	   CUR_COLUMN	  : Coordinates of the first character to be read in	;AN000;
;			    the current scan line.				;AN000;
;	   DL		  : Band mask indicating what print band to use 	;AN000;
;			    for this print pass.				;AN000;
;	   SCAN_LINE_LENGTH: Length of the current scan line.			;AN000;
;										;AN000;
;  OUTPUT: PRINTER								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; LOGIC:									;AN000;
;    DO (SCAN_LINE_LENGTH) TIMES						;AN000;
;      CALL BIOS INT 10H Read Character - returns CHAR, COLOR_NUM		;AN000;
;      IF (CUR_BAND_MASK AND XLAT_TAB[COLOR_NUM])=1				;AN000;
;      THEN IF Background color is same as Foreground color			;AN000;
;	    THEN								;AN000;
;	      CALL PRINT_BYTE(SOLID_BOX)					;AN000;
;	    ELSE								;AN000;
;	      CALL PRINT_BYTE(CHAR)						;AN000;
;      ELSE									;AN000;
;	 CALL PRINT_BYTE(blank) 						;AN000;
;      Get coordinates of the next character					;AN000;
;										;AN000;
PRINT_BAND_TXT PROC								;AN000;
SOLID_BOX	EQU	219	; ASCII Code for printing a solid box		;AN000;
BLANK		EQU	32	; ASCII code for printing a space		;AN000;
	PUSH	CUR_COLUMN	; Save column number				;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	MOV	CX,SCREEN_WIDTH ; CX := Number of character on one screen row	;AN000;
;===============================================================================;AN000;
;										;AN000;
; FOR each character on the current row:					;AN000;
;										;AN000;
;===============================================================================;AN000;
PRINT_1_CHAR:									;AN000;
;										;AN000;
;-------Read the character at the current cursor position			;AN000;
	CALL	SET_CURSOR		; Set cursor at character to be read	;AN000;
	MOV	AH,READ_CHAR_CALL	; Read one character			;AN000;
	MOV	BH,CUR_PAGE		;  at CUR_PAGE, CUR_COLUMN and CUR_ROW	;AN000;
	INT	10H			; Call BIOS				;AN000;
					; AL:=Character read, AH:=Byte attribute;AN000;
	MOV	CUR_CHAR,AL							;AN000;
	MOV	DH,AH			; DH := Byte attribute			;AN000;
	AND	DH,11110000B		; DH := Background color		;AN000;
	SHR	DH,1			; DH := Background color right justified;AN000;
	SHR	DH,1								;AN000;
	SHR	DH,1								;AN000;
	SHR	DH,1								;AN000;
	AND	AH,00001111B		; AH := Foreground color right justified;AN000;
;										;AN000;
;-------Test if this character should be printed (need color of the current band;AN000;
	MOV	AL,AH			; AL:=color used as index in the XLT_TAB;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Band mask (DL=current band mask);AN000;
       .IF     <BIT AL AND DL>		;If needs this band to print the color	;AN000;
       .THEN				; of this character			;AN000;
	 .IF	 <AH EQ DH>		; then: when foreground = background	;AN000;
	 .THEN				;	send a solid box		;AN000;
	    MOV     AL,SOLID_BOX	;					;AN000;
	 .ELSE				;	when foreground <> background	;AN000;
	    MOV     AL,CUR_CHAR 	;	send the character		;AN000;
	 .ENDIF 			; Endif foreground = background 	;AN000;
       .ELSE				; else: send a blank			;AN000;
	  MOV	  AL,BLANK		;					;AN000;
       .ENDIF				; Endif color band needed		;AN000;
	CALL	PRINT_BYTE		; Print the byte			;AN000;
	JC	PRINT_BAND_TXT_END	; If printer error occurred: QUIT	;AN000;
	INC CUR_COLUMN			; Else, Get next column; keep going	;AN000;
	LOOP	PRINT_1_CHAR							;AN000;
										;AN000;
PRINT_BAND_TXT_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	POP	CUR_COLUMN		; Restore column number 		;AN000;
	RET									;AN000;
CUR_CHAR	DB ?								;AN000;
PRINT_BAND_TXT ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PRINT_COLOR_APA: PRINT AN APA MODE SCREEN ON A COLOR PRINTER			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP	 = Offset of the shared data area			;AN000;
;		XLT_TAB  = Color translation table				;AN000;
;		CUR_MODE_PTR = Coordinates of current DISPLAYMODE info. 	;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Each pixel on the screen is printed as a "box" of dots on the    ;AN000;
; printer. For a screen pixel of a given color, the best color approximation	;AN000;
; is chosen among the color available on the printer.				;AN000;
;										;AN000;
; The printer colors are obtained by selecting a print band. A few more printer ;AN000;
; color are obtained by printing twice (or more times) with different color	;AN000;
; bands.									;AN000;
;										;AN000;
; For example, let's say we have a ribbon on the printer with a YELLOW CYAN     ;AN000;
; MAGENTA ribbon and we read a GREEN pixel on the screen.			;AN000;
;										;AN000;
;   We first determine what "box" size will be used to represent this pixel.    ;AN000;
;   Let's say it's a 3x2 box (this is obtained from the DISPLAYMODE record)     ;AN000;
;   In all cases, we will print this pixel as a 3x2 box of printer dots.	;AN000;
;   That is, we will print 6 dots on the printer for one on the screen. 	;AN000;
;   We do not use any kind of patterns (e,g,. printing only 2 dots out of 6)	;AN000;
;   for printing on the color printer. A screen pixel is either printed 	;AN000;
;   as a "full" box of printer dots or not printed at all (e,g,. if it's white).;AN000;
;										;AN000;
;   Now, from the COLORPRINT records, we know all the colors availables on the	;AN000;
;   printer, and what print bands must be used (or overlaid) in order to	;AN000;
;   obtain them.								;AN000;
;										;AN000;
;   So, we consult these COLORPRINT records one by one comparing how close	;AN000;
;   the color of each of them is to our GREEN pixel. (the colors for our pixel	;AN000;
;   AND for the printer color are both indicated in terms of RGB values)	;AN000;
;   WE PICK THE CLOSEST PRINTER COLOR.						;AN000;
;										;AN000;
;   To conclude, our GREEN pixel will be printed by first selecting the YELLOW	;AN000;
;   band, then sending to the printer a "box".  Then, the BLUE band is selected ;AN000;
;   and the "box" is sent again.                                                ;AN000;
;										;AN000;
; This process is carried line by line. 					;AN000;
;										;AN000;
; For each line, we first read each pixel to see what color bands are going	;AN000;
; to be needed for this line.							;AN000;
;										;AN000;
; Then, we loop for each band available on the printer. 			;AN000;
;										;AN000;
; IF the current line needs the current printer band (i.e.,if any pixel on	;AN000;
;  the line needs this color band in order to achieve its color.		;AN000;
; THEN, we select this color band (we know how to do it from the COLORSELECT	;AN000;
;	record in the Shared Data area) 					;AN000;
;	AND we must read the line again; for each pixel that needs the current	;AN000;
;	band  a "box" is sent to the printer.                                   ;AN000;
;										;AN000;
; LOGIC :									;AN000;
;     CALL INIT_BLACK_BOX		; Initialize a print box		;AN000;
;     CALL GET_SCREEN_INFO							;AN000;
;     CALL SETUP_PRT								;AN000;
;     DO (NB_SCAN_LINES) TIMES							;AN000;
;	  CALL DET_CUR_SCAN_LNE_LENGTH						;AN000;
;	  IF CUR_SCAN_LNE_LENGTH NE 0 THEN					;AN000;
;	    CALL SCAN_FOR_BANDS_APA(CUR_ROW,CUR_COLUMN,REQ_BAND_MASK)		;AN000;
;	    CUR_BAND_MASK := 01H						;AN000;
;	    IF REQ_BAND_MASK <> 0 THEN						;AN000;
;	       DO 8 TIMES							;AN000;
;		  IF (REQ_BAND_MASK AND CUR_BAND_MASK)=1 THEN			;AN000;
;		     CALL NEW_PRT_LINE						;AN000;
;		     CALL PRINT_BAND_APA(CUR_ROW,CUR_COLUMN,CUR_BAND_MASK)	;AN000;
;		     CALL PRINT_BYTE(CARRIAGE_RETURN)				;AN000;
;		  ENDIF 							;AN000;
;		  Shift CUR_BAND_MASK one bit left				;AN000;
;	       ENDDO								;AN000;
;	    ENDIF ; Should make a print pass for this color band		;AN000;
;	    CALL PRINT_BYTE(LINE_FEED)						;AN000;
;	  ENDIF ; Current scan line is not empty				;AN000;
;	  IF rotated print THEN 						;AN000;
;	     CUR_COLUMN := CUR_COLUMN - BOXES_PER_PRT_BUF			;AN000;
;	     CUR_ROW := SAVE_START_ROW						;AN000;
;	  ELSE									;AN000;
;	     CUR_ROW := CUR_ROW + BOXES_PER_PRT_BUF				;AN000;
;	     CUR_COLUMN := SAVE_START_COLUMN					;AN000;
;	  ENDIF 								;AN000;
;     ENDDO ; Number of Scan lines						;AN000;
;     CALL RESTORE_PRT								;AN000;
;										;AN000;
PRINT_COLOR_APA PROC								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
										;AN000;
										;AN000;
;-------Initialize print box (A "box" represents one screen pel on the printer) ;AN000;
	CALL INIT_BLACK_BOX							;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;  Determine where to start reading the screen: 				;AN000;
;    If printing sideways, start in LOW LEFT corner.				;AN000;
;    If normal printing, start in TOP LEFT corner.				;AN000;
;  Determine the maximum length for a scan line:				;AN000;
;    If printing sideways, it is the height of the screen.			;AN000;
;    For normal printing, it is the width of the screen.			;AN000;
;  Determine the number of scan lines on the screen.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	GET_SCREEN_INFO 	; Get info. about how to read the screen;AN000;
	CALL	SETUP_PRT		; Set up the printer (Line spacing, etc);AN000;
       .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>					;AN000;
       .THEN				; A printer error occurred: quit	;AN000;
	  JMP	  SHORT  PRINT_COLOR_APA_END	;					;AN000;
       .ENDIF									;AN000;
										;AN000;
	MOV	CX,NB_SCAN_LINES						;AN000;
;----------------------------------------------------------------------------	;AN000;
;										;AN000;
; FOR EACH SCAN LINE ON THE SCREEN (and each print line):			;AN000;
;										;AN000;
;----------------------------------------------------------------------------	;AN000;
PRINT_SCAN_LINE:								;AN000;
	CALL	DET_CUR_SCAN_LNE_LENGTH ; Determine length of the scan line	;AN000;
       .IF <CUR_SCAN_LNE_LENGTH NE 0>	; If line is not empty			;AN000;
       .THEN									;AN000;
	  CALL	  SCAN_FOR_BANDS_APA	  ; REQ_BAND_MASK := Mask for what print;AN000;
					  ;  bands are needed.			;AN000;
	  MOV	  DL,01H		  ; DL := "Current Band to be printed"  ;AN000;
	  MOV	  BX,DS:[BP].COLORSELECT_PTR; BX := Offset of COLORSELECT record;AN000;
	  ADD	  BX,BP 		  ;	("How to select the color band");AN000;
	  PUSH	  CX			  ; Save scan line counter		;AN000;
	  MOV	  CX,8			  ; For up to the maximum number of prin;AN000;
					  ;  bands with this printer		;AN000;
	  ;---------------------------------------------------------------------;AN000;
	  ;									;AN000;
	  ; FOR each Color Band needed: 					;AN000;
	  ;									;AN000;
	  ;---------------------------------------------------------------------;AN000;
       PRINT_1_COLOR_BAND_APA:		  ; Only if this color band is needed:	;AN000;
	   .IF <BIT REQ_BAND_MASK AND DL> ;   Do one pass of the printer head	;AN000;
	   .THEN			  ;					;AN000;
	      CALL    SET_COLOR_BAND	  ; Select the color band on the printer;AN000;
	      CALL    NEW_PRT_LINE	  ; Send escape sequence to the printer ;AN000;
					  ;  for starting a new graphics line	;AN000;
	     .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>				;AN000;
	     .THEN			  ; A printer error occurred:		;AN000;
		POP   CX		  ; Restore the line counter and	;AN000;
		JMP   SHORT  PRINT_COLOR_APA_END ;  return				;AN000;
	     .ENDIF			  ; Endif printer error occurred	;AN000;
										;AN000;
	      CALL PRINT_BAND_APA	  ; Do one Print Pass for current band	;AN000;
	      MOV     AL,CR		  ;   Print a carriage return		;AN000;
	      CALL    PRINT_BYTE						;AN000;
	     .IF      C 		  ; If a printer error occurred 	;AN000;
	     .THEN								;AN000;
		POP   CX		  ; Restore the line counter and	;AN000;
		JMP   SHORT  PRINT_COLOR_APA_END ;  return				;AN000;
	     .ENDIF			  ; End if printer error occurred	;AN000;
	   .ENDIF			  ; End if this color band is needed	;AN000;
	    SHL     DL,1		  ; Get next Color Band mask		;AN000;
					  ; Locate next COLORSELECT record:	;AN000;
	    MOV     AL,[BX].NUM_SELECT_ESC;  skip the escape bytes		;AN000;
	    XOR     AH,AH							;AN000;
	    ADD     BX,AX							;AN000;
	    INC     BX			  ;  skip the NUM_SELECT_ESC field	;AN000;
	  LOOP	  PRINT_1_COLOR_BAND_APA					;AN000;
	  POP	  CX			  ; Restore scan line counter		;AN000;
       .ENDIF ; Scan line length <> 0						;AN000;
;										;AN000;
;-----Print a line feed:							;AN000;
	MOV	AL,LF								;AN000;
	CALL	PRINT_BYTE							;AN000;
	JC	PRINT_COLOR_APA_END	  ; If a printer error occurred: quit	;AN000;
;										;AN000;
;-------Get coordinates of next scan line:					;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				; then: 				;AN000;
	  MOV	  AL,NB_BOXES_PER_PRT_BUF;  AX := Numbers of pels read on row	;AN000;
	  CBW				;					;AN000;
	  ADD	  CUR_COLUMN,AX 	;   CUR_COLUMN + Number of pels read	;AN000;
	  MOV	  AX,SCREEN_HEIGHT	;   CUR_ROW := SCREEN_HEIGHT - 1	;AN000;
	  DEC	  AX			;					;AN000;
	  MOV	  CUR_ROW,AX		;					;AN000;
       .ELSE				; else, printing NOT rotated:		;AN000;
	  MOV	  AL,NB_BOXES_PER_PRT_BUF ; AX := Number of pels read on column ;AN000;
	  CBW				;					;AN000;
	  ADD	  CUR_ROW,AX		;   CUR_ROW + Number of pels read	;AN000;
	  MOV	  CUR_COLUMN,0		;   CUR_COLUMN := 0			;AN000;
       .ENDIF				; End if printing sideways		;AN000;
	LOOP	PRINT_SCAN_LINE 	;					;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Restore the printer (send a Page Eject, etc.) 				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	RESTORE_PRT							;AN000;
PRINT_COLOR_APA_END:								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PRINT_COLOR_APA ENDP								;AN000;
PAGE										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
;;										;AN000;
;;										;AN000;
;;   SCAN_FOR_BANDS_APA : DETERMINE WHAT PRINT BANDS ARE NEEDED FOR THE CURRENT ;AN000;
;;			  PRINT PASS.						;AN000;
;;										;AN000;
;;------------------------------------------------------------------------------;AN000;
;										;AN000;
; INPUT:  CUR_ROW	      : row to start scanning	(word)			;AN000;
;	  CUR_COLUMN	      : column to start scanning (word) 		;AN000;
;	  CUR_SCAN_LNE_LENGTH : length of the current scan line (word)		;AN000;
;	  ROTATE_SW	      = ON if printing is sideways			;AN000;
;										;AN000;
; OUTPUT: REQ_BAND_MASK       : band mask for required bands (byte)		;AN000;
;										;AN000;
;;------------------------------------------------------------------------------;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;   Shared Data Area								;AN000;
;;   Print Info 								;AN000;
;;   Color Translate Table							;AN000;
;;										;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Read all the dots required for one print line to determine 		;AN000;
;;   the print bands required.	The print line corresponds to several		;AN000;
;;   screen rows (or columns if rotated printing).  The number of		;AN000;
;;   rows / columns per print line is stored in NB_BOXES_PER_PRT_BUF.		;AN000;
;;   The band information is obtained from the Color Translate Table.		;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   PRINT_COLOR_APA								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   READ_DOT, BIOS INT 10H							;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   Save initial coordinates							;AN000;
;;   SAVE_START_COLUMN := CUR_COLUMN						;AN000;
;;   REQ_BAND_MASK := 00H							;AN000;
;;   DO (SCAN_LINE_LENGTH) TIMES						;AN000;
;;	Save coordinates of the "column"                                        ;AN000;
;;	DO (BOXES_PER_PRT_BUF) TIMES						;AN000;
;;	  CALL READ_DOT(IN CUR_ROW,CUR_COLUMN; OUT COLOR_NUM)			;AN000;
;;	   REQ_BAND_MASK := REQ_BAND_MASK OR COLOR_XLAT_TAB[BX] 		;AN000;
;;	   IF rotated print THEN						;AN000;
;;	      Increment CUR_COLUMN						;AN000;
;;	   ELSE 								;AN000;
;;	      Increment CUR_ROW 						;AN000;
;;	   ENDIF								;AN000;
;;	Restore coordinates of the "column"                                     ;AN000;
;;	ENDDO									;AN000;
;;	IF rotated print THEN							;AN000;
;;	   Decrement CUR_ROW							;AN000;
;;	ELSE									;AN000;
;;	   Increment CUR_COLUMN 						;AN000;
;;	ENDIF									;AN000;
;;   ENDDO									;AN000;
;;   Restore initial coordinates						;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	;AN000;
SCAN_FOR_BANDS_APA PROC NEAR							;AN000;
	PUSH	CUR_ROW 							;AN000;
	PUSH	CUR_COLUMN							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	REQ_BAND_MASK,0 	; No Color bands needed so far...	;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of translation table	;AN000;
	MOV	CX,CUR_SCAN_LNE_LENGTH						;AN000;
;===============================================================================;AN000;
;										;AN000;
; FOR each column on the current scan line (up to the last non=blank):		;AN000;
;										;AN000;
;===============================================================================;AN000;
SCAN_1_COLUMN:									;AN000;
	PUSH	CX			; Save column counter			;AN000;
	PUSH	CUR_ROW 		; Save coordinates of the "column"      ;AN000;
	PUSH	CUR_COLUMN							;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; For each pixel within the current column of the scan line:			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	XOR	CX,CX			; CX := Number of pixels to read	;AN000;
	MOV	CL,NB_BOXES_PER_PRT_BUF ;   within the current "column"         ;AN000;
SCAN_1_PIXEL:									;AN000;
	CALL	READ_DOT		; AL := Index into translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Band mask			;AN000;
	OR	REQ_BAND_MASK,AL	; Add bands required for this pixel	;AN000;
										;AN000;
;-------Get coordinates of next pixel:						;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				;					;AN000;
	  INC CUR_COLUMN		; then, increment column number 	;AN000;
       .ELSE				;					;AN000;
	  INC CUR_ROW			; else, increment row number		;AN000;
       .ENDIF				;					;AN000;
	LOOP SCAN_1_PIXEL							;AN000;
	POP	CUR_COLUMN		; Restore coordinates of the "column"   ;AN000;
	POP	CUR_ROW 		;					;AN000;
	POP	CX			; Restore column counter		;AN000;
										;AN000;
										;AN000;
;-------Get coordinates of next "column":                                       ;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				;					;AN000;
	  DEC CUR_ROW			; then, get row above on screen 	;AN000;
       .ELSE				;					;AN000;
	  INC CUR_COLUMN		; else, get column next right		;AN000;
       .ENDIF				;					;AN000;
	LOOP	SCAN_1_COLUMN							;AN000;
										;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	POP	CUR_COLUMN							;AN000;
	POP	CUR_ROW 							;AN000;
	RET									;AN000;
SCAN_FOR_BANDS_APA ENDP 							;AN000;
PAGE										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
;;										;AN000;
;;   PRINT_BAND_APA : PRINT ALL DOTS ON CURRENT LINE THAT NEED THE CURRENT BAND ;AN000;
;;		      TO APPROXIMATE THEIR COLOR.				;AN000;
;;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;  INPUT:  CUR_ROW,								;AN000;
;	   CUR_COLUMN	  : Coordinates of the first pixel to be read in the	;AN000;
;			    current scan line.					;AN000;
;	   DL		  : Band mask indicating what print band to use 	;AN000;
;			    for this print pass.				;AN000;
;	   CUR_SCAN_LNE_LENGTH: Length of the current scan line.		;AN000;
;	   ROTATE_SW	   = ON if printing is sideways 			;AN000;
;										;AN000;
;  OUTPUT: PRINTER								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;   Shared Data Area								;AN000;
;;   Print Info 								;AN000;
;;   Color Translate Table							;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Print all dots on this print line which need the current			;AN000;
;;   band. The print line corresponds to several				;AN000;
;;   screen rows (or columns if rotated printing).  The number of		;AN000;
;;   rows / columns per print line is stored in NB_BOXES_PER_PRT_BUF.		;AN000;
;;   The band information is obtained from the Color Translate Table.		;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   PRINT_COLOR_APA								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   READ_DOT, BIOS INT 10H, STORE_BOX, PRT_BUFFER, PRINT_BYTE			;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   SAVE_START_ROW := CUR_ROW							;AN000;
;;   SAVE_START_COLUMN := CUR_COLUMN						;AN000;
;;										;AN000;
;;   CALL SET_COLOR_BAND	; Select the color for this print pass		;AN000;
;;   DO (SCAN_LINE_LENGTH) TIMES						;AN000;
;;	Save coordinates of the "column"                                        ;AN000;
;;	Clear the print buffer							;AN000;
;;	DO (BOXES_PER_PRT_BUF) TIMES						;AN000;
;;	   CALL READ_DOT(CUR_ROW,CUR_COLUMN,COLOR_NUM)				;AN000;
;;	   IF (CUR_BAND_MASK AND XLAT_TAB[COLOR_NUM])=1 THEN			;AN000;
;;	      CALL STORE_BOX(black box) 					;AN000;
;;	   ELSE 								;AN000;
;;	      CALL STORE_BOX(white box) 					;AN000;
;;	   ENDIF								;AN000;
;;	   IF rotated print THEN						;AN000;
;;	      Decrement CUR_COLUMN						;AN000;
;;	   ELSE 								;AN000;
;;	      Increment CUR_ROW 						;AN000;
;;	   ENDIF								;AN000;
;;	ENDDO									;AN000;
;;	CALL PRINT_BUFFER							;AN000;
;;	Restore coordinates of the "column"                                     ;AN000;
;;	; Get coordinates of the next "column";                                 ;AN000;
;;	IF rotated print THEN							;AN000;
;;	   Decrement CUR_ROW							;AN000;
;;	   CUR_COLUMN := SAVE_START_COLUMN					;AN000;
;;	ELSE									;AN000;
;;	   Increment CUR_COLUMN 						;AN000;
;;	   CUR_ROW := SAVE_START_ROW						;AN000;
;;	ENDIF									;AN000;
;;   ENDDO									;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
PRINT_BAND_APA	    PROC NEAR							;AN000;
	PUSH	CUR_ROW 		; Save coordinates			;AN000;
	PUSH	CUR_COLUMN							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of translation table	;AN000;
	MOV	CX,CUR_SCAN_LNE_LENGTH						;AN000;
;===============================================================================;AN000;
;										;AN000;
; FOR each column on the current scan line (up to the last non=blank):		;AN000;
; (One "column" contains the number of pixels required to fill the Print buffer);AN000;
;										;AN000;
;===============================================================================;AN000;
PRINT_1_COLUMN: 								;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Clear the print buffer "PRT_BUF"                                              ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	XOR	DI,DI		; DI := Number of bytes cleared in the buffer	;AN000;
	XOR	AX,AX								;AN000;
	MOV	AL,BOX_W	; AX := Number of bytes in the print buffer	;AN000;
CLEAR_BUF:			; For each byte in the PRT_BUF: 		;AN000;
	MOV	PRT_BUF[DI],0	;    Initialize byte to blanks			;AN000;
	INC	DI		;    One more has been cleared			;AN000;
	CMP	DI,AX		;    All bytes cleared ?			;AN000;
	JL	CLEAR_BUF	;	 No, clear next one.			;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Fill up the print buffer "PRT_BUF"                                            ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	PUSH	CX			; Save column counter			;AN000;
	XOR	CX,CX			; CX := Number of pixels to read	;AN000;
	MOV	CL,NB_BOXES_PER_PRT_BUF ;   within the current "column"         ;AN000;
					;    of the scan line			;AN000;
	PUSH	CUR_ROW 		; Save coordinates of the "column"      ;AN000;
	PUSH	CUR_COLUMN							;AN000;
;										;AN000;
; For each pixel within the current column of the scan line:			;AN000;
STORE_1_PIXEL:									;AN000;
	CALL	READ_DOT		; AL := Index into translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Band mask			;AN000;
       .IF <BIT AL AND DL>		; If color of the current pixel needs	;AN000;
       .THEN				;  the current printer band		;AN000;
	  MOV	SI,OFFSET BLACK_BOX	; then, store a box in the		;AN000;
	  CALL STORE_BOX		;	 PRT_BUF			;AN000;
       .ELSE				;					;AN000;
	  MOV	SI,OFFSET WHITE_BOX	;  else, store an empty box		;AN000;
	  CALL STORE_BOX		;	  in the PRT_BUF		;AN000;
       .ENDIF									;AN000;
;										;AN000;
;-------Get coordinates of next pixel:						;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				;					;AN000;
	  INC CUR_COLUMN		; then, increment column number 	;AN000;
       .ELSE				;					;AN000;
	  INC CUR_ROW			; else, increment row number		;AN000;
       .ENDIF				;					;AN000;
	LOOP STORE_1_PIXEL							;AN000;
										;AN000;
	POP	CUR_COLUMN		; Restore coordinates of the "column"   ;AN000;
	POP	CUR_ROW 		;					;AN000;
	POP	CX			; Restore column counter		;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Print the PRT_BUF:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	PRINT_BUFFER							;AN000;
       .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>					;AN000;
       .THEN				; A printer error occurred: QUIT	;AN000;
	  JMP SHORT PRINT_BAND_APA_END	;					;AN000;
       .ENDIF									;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Get coordinates of next "column":                                             ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				;					;AN000;
	  DEC CUR_ROW			; then, get row above on screen 	;AN000;
       .ELSE				;					;AN000;
	  INC CUR_COLUMN		; else, get column next right		;AN000;
       .ENDIF				;					;AN000;
	LOOP	PRINT_1_COLUMN							;AN000;
										;AN000;
PRINT_BAND_APA_END:								;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	POP	CUR_COLUMN		; Restore initial coordinates		;AN000;
	POP	CUR_ROW 							;AN000;
	RET									;AN000;
PRINT_BAND_APA	ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; SET_CURSOR : SET THE CURSOR TO CUR_ROW, CUR_COLUMN AND CUR_PAGE		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	CUR_ROW,							;AN000;
;		CUR_COLUMN  = Coordinates for the cursor (word) 		;AN000;
;		CUR_PAGE    = Page for which to set the cursor (byte)		;AN000;
;										;AN000;
;	OUTPUT: SCREEN								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
SET_CURSOR PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	DX								;AN000;
	MOV	DH,BYTE PTR CUR_ROW						;AN000;
	MOV	DL,BYTE PTR CUR_COLUMN						;AN000;
	MOV	BH,CUR_PAGE							;AN000;
	MOV	AH,SET_CURSOR_CALL	; Set cursor request			;AN000;
	INT	10H			; Call BIOS				;AN000;
	POP	DX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
SET_CURSOR ENDP 								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; SET_COLOR_BAND : SET THE PRINTER TO THE CURRENT COLOR BAND			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: BX	= Offset of current COLORSELECT record in the		;AN000;
;			  Shared data area.					;AN000;
;	       DS:[BP]	= Offset of shared data area				;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
SET_COLOR_BAND PROC NEAR							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
;-------Send the escape sequence for selecting this color band to the printer:	;AN000;
	XOR	CX,CX								;AN000;
	MOV	CL,[BX].NUM_SELECT_ESC	; CX := Number of bytes to send 	;AN000;
	ADD	BX,OFFSET SELECT_ESC	; BX := Offset of bytes to send 	;AN000;
SEND_1_COLORSELECT_BYTE:							;AN000;
	MOV	AL,[BX] 		; AL := Byte to send to printer 	;AN000;
	CALL	PRINT_BYTE		; Send it				;AN000;
	JC	SET_COLOR_BAND_END	; If printer error: return		;AN000;
	INC	BX			; Get next byte 			;AN000;
	LOOP	SEND_1_COLORSELECT_BYTE 					;AN000;
										;AN000;
SET_COLOR_BAND_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
SET_COLOR_BAND ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; INIT_BLACK_BOX: INIT. THE BOX FOR PRINTING APA MODE DOTS ON A COLOR PRINTER.	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BOX_W,								;AN000;
;		BOX_H		= Size of the print box for one pixel.		;AN000;
;										;AN000;
;	OUTPUT: BLACK_BOX	= A box for which all dots are on.		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Initialize the print box used to print a screen pixel.		;AN000;
;										;AN000;
; For example,									;AN000;
; with a size of 3x2 the BLACK_BOX will use 3 bytes:				;AN000;
;										;AN000;
;										;AN000;
;	  byte1     byte2     byte3						;AN000;
;	(column1) (column2) (column3)						;AN000;
;  bit 7 -->0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    1	       1	 1						;AN000;
;  bit 0 -->1	       1	 1						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
INIT_BLACK_BOX PROC NEAR							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
;-------Build one box column:							;AN000;
	XOR	CX,CX								;AN000;
	MOV	CL,BOX_H	; CX := Height in bits of the print box 	;AN000;
	XOR	AL,AL		; AX := Bit mask for creating box column	;AN000;
       .REPEAT			; For height of the box:			;AN000;
	  SHL	  AL,1		;						;AN000;
	  OR	  AL,1		;   Insert one bit in the box column		;AN000;
       .LOOP									;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	AL now contains one box column. 					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
										;AN000;
;-------Replicate this column over all columns of the box.			;AN000;
	XOR	BX,BX		; BX := Index into the BOX			;AN000;
INIT_1_BLACK_COLUMN:								;AN000;
	MOV	BLACK_BOX[BX],AL; Init current column to black box column	;AN000;
	INC	BX		; Get next column				;AN000;
	CMP	BL,BOX_W							;AN000;
	JL	INIT_1_BLACK_COLUMN						;AN000;
										;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
INIT_BLACK_BOX ENDP								;AN000;
INCLUDE GRCOMMON.ASM								;AN000;
LEN_OF_COLOR_MODULES EQU $-PRINT_COLOR						;AN000;
CODE	ENDS									;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\graphics.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Command Entry Point
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; MS DOS GRAPHICS Command
;;                                      
;;										;AN000;
;; File Name:  GRAPHICS.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the GRAPHICS command entry point.			;AN000;
;;	 A jump is made to the GRAPHICS_INSTALL procedure			;AN000;
;;	 in file GRINST.ASM to begin installation processing.			;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 GRINST.EXT - Externals for GRINST.ASM					;AN000;
;;										;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRINST.ASM: 						;AN000;
;;	      GRAPHICS_INSTALL - Main module for installation.			;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 LINK GRAPHICS GRINT2FH GRPATTRN GRCTRL GRCPSD GRCOLPRT GRBWPRT 	;AN000;
;;	      GRINST GRPARSE grparms GRLOAD GRLOAD2 GRLOAD3;			;AN000;
;;	 EXE2BIN GRAPHICS.EXE GRAPHICS.COM					;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;	A000 - Denotes 4.00 level source.					;AN000;
;;	A001 - PTM1779 - invalid parm msg followed by garbage			;AN001;
;;	       Module affected: GRPARMS.ASM					;AN001;
;;	A002 - PTM2666 - Release environment string before terminating. 	;AN002;
;;	       Module affected: GRINST.ASM					;AN002;
;;	A003 - PTM3915 - Change to include common copyright file.
;;	       Module affected: GRAPHICS.ASM
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       ;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
	ORG   100H		       ;; required for .COM			;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;; Bring in external declarations	;AN000;
				       ;;  for transient command processing	;AN000;
START:				       ;;					;AN000;
				       ;;					;AN000;
	JMP   GRAPHICS_INSTALL	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;
;	INCLUDE COPYRIGH.INC	       ;; included in message services		;AN003;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
CODE   ENDS									;AN000;
       END    START								;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\grpattrn.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Common modules			;AN000;
.xlist										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                               
;;										;AN000;
;; File Name:  GRPATTRN.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the grey patterns used by PRT_BW_APA for printing	;AN000;
;;	 on a Black and White printer.						;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	none									;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	GRPATTRN.STR	- Structures for patterns.				;AN000;
;;										;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;										;AN000;
;;	Called by PRT_BW_APA from file GRBWPRT.ASM				;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
.list										;AN000;
CODE	SEGMENT PUBLIC 'CODE'                                                   ;AN000;
	ASSUME		CS:CODE,DS:CODE 					;AN000;
INCLUDE GRPATTRN.STR								;AN000;
										;AN000;
PUBLIC	TAB_DIRECTORY								;AN000;
PUBLIC	TAB_DIR_NB_ENTRIES							;AN000;
PUBLIC	PAT_4X2 								;AN000;
PUBLIC	PAT_4X4 								;AN000;
PUBLIC	PAT_6X2 								;AN000;
PUBLIC	PAT_8X2 								;AN000;
PUBLIC	PAT_6X4 								;AN000;
PUBLIC	PAT_8X4 								;AN000;
PUBLIC	PAT_8X6 								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; PATTERN DIRECTORY:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
TAB_DIR_NB_ENTRIES DB 7 							;AN000;
TAB_DIRECTORY LABEL BYTE							;AN000;
; ENTRY = <OFFSET PATTERN TABLE, TABLE SIZE, BOX_W, BOX_H,			;AN000;
;	   NUNBER OF PATTERNS(INTENSITIES) >					;AN000;
	TAB_ENTRY <OFFSET PAT_4X2,-1,40,2,1,8 > 				;AN000;
	TAB_ENTRY <OFFSET PAT_4X4,-1,40,2,2,8 > 				;AN000;
	TAB_ENTRY <OFFSET PAT_6X2,-1,70,3,1,10> 				;AN000;
	TAB_ENTRY <OFFSET PAT_8X2,-1,108,4,1,12>				;AN000;
	TAB_ENTRY <OFFSET PAT_6X4,-1,119,3,2,17>				;AN000;
	TAB_ENTRY <OFFSET PAT_8X4,-1,162,4,2,18>				;AN000;
	TAB_ENTRY <OFFSET PAT_8X6,-1,171,4,3,19>				;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 4X2 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_4X2 LABEL BYTE								;AN000;
; PATTERN=<MAXIMUM INTENSITY, 1ST COLUMN (top is left bit), 2ND, 3RD, 4TH >	;AN000;
	    PAT_4X2_STR < 5,11B,11B,11B,11B>					;AN000;
	    PAT_4X2_STR <13,11B,10B,01B,11B>					;AN000;
	    PAT_4X2_STR <20,10B,11B,01B,10B>					;AN000;
	    PAT_4X2_STR <28,10B,01B,01B,10B>					;AN000;
	    PAT_4X2_STR <36,10B,00B,01B,10B>					;AN000;
	    PAT_4X2_STR <47,10B,00B,01B,00B>					;AN000;
	    PAT_4X2_STR <58,10B,00B,00B,00B>					;AN000;
	    PAT_4X2_STR <63,00B,00B,00B,00B>					;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 4X4 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_4X4 LABEL BYTE								;AN000;
; PATTERN=<MAXIMUM INTENSITY, 1ST COLUMN (top is left bit), 2ND, 3RD, 4TH >	;AN000;
	    PAT_4X4_STR < 5,1111B,1111B,1111B,1111B>				;AN000;
	    PAT_4X4_STR <13,1111B,1010B,0101B,1111B>				;AN000;
	    PAT_4X4_STR <20,1010B,1111B,0101B,1010B>				;AN000;
	    PAT_4X4_STR <28,1010B,0101B,0101B,1010B>				;AN000;
	    PAT_4X4_STR <36,1010B,0000B,0101B,1010B>				;AN000;
	    PAT_4X4_STR <47,1010B,0000B,0101B,0000B>				;AN000;
	    PAT_4X4_STR <58,1010B,0000B,0000B,0000B>				;AN000;
	    PAT_4X4_STR <63,0000B,0000B,0000B,0000B>				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 6X2 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_6X2 LABEL BYTE								;AN000;
	    PAT_6X2_STR < 3,11B,11B,11B,11B,11B,11B>				;AN000;
	    PAT_6X2_STR < 8,11B,11B,10B,11B,11B,01B>				;AN000;
	    PAT_6X2_STR <15,10B,01B,10B,11B,10B,01B>				;AN000;
	    PAT_6X2_STR <21,01B,10B,10B,01B,10B,10B>				;AN000;
	    PAT_6X2_STR <28,01B,10B,10B,01B,10B,00B>				;AN000;
	    PAT_6X2_STR <36,10B,01B,00B,10B,01B,00B>				;AN000;
	    PAT_6X2_STR <45,00B,10B,00B,01B,00B,10B>				;AN000;
	    PAT_6X2_STR <53,10B,00B,00B,01B,00B,00B>				;AN000;
	    PAT_6X2_STR <60,10B,00B,00B,00B,00B,00B>				;AN000;
	    PAT_6X2_STR <63,00B,00B,00B,00B,00B,00B>				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 8X2 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_8X2 LABEL BYTE								;AN000;
	    PAT_8X2_STR < 3,11B,11B,11B,11B,11B,11B,11B,11B>			;AN000;
	    PAT_8X2_STR < 9,11B,11B,10B,11B,11B,10B,11B,01B>			;AN000;
	    PAT_8X2_STR <15,10B,11B,01B,11B,10B,11B,00B,11B>			;AN000;
	    PAT_8X2_STR <21,10B,01B,11B,10B,01B,10B,01B,10B>			;AN000;
	    PAT_8X2_STR <27,10B,01B,01B,10B,10B,01B,01B,10B>			;AN000;
	    PAT_8X2_STR <33,00B,10B,01B,10B,00B,01B,10B,01B>			;AN000;
	    PAT_8X2_STR <39,10B,00B,10B,01B,00B,10B,00B,01B>			;AN000;
	    PAT_8X2_STR <45,10B,00B,01B,00B,10B,00B,01B,00B>			;AN000;
	    PAT_8X2_STR <51,10B,00B,00B,01B,00B,00B,10B,00B>			;AN000;
	    PAT_8X2_STR <56,10B,00B,00B,00B,01B,00B,00B,00B>			;AN000;
	    PAT_8X2_STR <61,10B,00B,00B,00B,00B,00B,00B,00B>			;AN000;
	    PAT_8X2_STR <63,00B,00B,00B,00B,00B,00B,00B,00B>			;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 6X4 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_6X4 LABEL BYTE								;AN000;
	    PAT_6X4_STR < 3,1111B,1111B,1111B,1111B,1111B,1111B>		;AN000;
	    PAT_6X4_STR < 8,1111B,1111B,1101B,1111B,1111B,1011B>		;AN000;
	    PAT_6X4_STR <13,1111B,1111B,0101B,1011B,1111B,1010B>		;AN000;
	    PAT_6X4_STR <16,0101B,1111B,0101B,1010B,0101B,1010B>		;AN000;
	    PAT_6X4_STR <20,0101B,1110B,0101B,1010B,0101B,1010B>		;AN000;
	    PAT_6X4_STR <24,1010B,0101B,1010B,0101B,0010B,0101B>		;AN000;
	    PAT_6X4_STR <28,1010B,0101B,1000B,0101B,0010B,0101B>		;AN000;
	    PAT_6X4_STR <32,1010B,0101B,1000B,1001B,0010B,0100B>		;AN000;
	    PAT_6X4_STR <37,1010B,0000B,1010B,0101B,0000B,0101B>		;AN000;
	    PAT_6X4_STR <40,0100B,0001B,1000B,0010B,1000B,0101B>		;AN000;
	    PAT_6X4_STR <45,0100B,0010B,1000B,0010B,0100B,0001B>		;AN000;
	    PAT_6X4_STR <49,1010B,0000B,1000B,0101B,0000B,0000B>		;AN000;
	    PAT_6X4_STR <52,1010B,0000B,0000B,0101B,0000B,0000B>		;AN000;
	    PAT_6X4_STR <55,0000B,1000B,0000B,0010B,0000B,0100B>		;AN000;
	    PAT_6X4_STR <58,1000B,0000B,0000B,0010B,0000B,0000B>		;AN000;
	    PAT_6X4_STR <61,1000B,0000B,0000B,0000B,0000B,0000B>		;AN000;
	    PAT_6X4_STR <63,0000B,0000B,0000B,0000B,0000B,0000B>		;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 8X4 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_8X4 LABEL BYTE								;AN000;
	    PAT_8X4_STR < 1,1111B,1111B,1111B,1111B,1111B,1111B,1111B,1111B>	;AN000;
	    PAT_8X4_STR < 4,1010B,1111B,1111B,1111B,1010B,1111B,1111B,1111B>	;AN000;
	    PAT_8X4_STR < 7,1010B,1111B,1101B,1111B,1010B,1111B,0111B,1111B>	;AN000;
	    PAT_8X4_STR <10,1010B,0111B,1110B,0101B,1010B,1101B,1011B,0101B>	;AN000;
	    PAT_8X4_STR <13,1001B,1110B,0110B,1001B,0110B,1011B,1001B,0110B>	;AN000;
	    PAT_8X4_STR <18,1010B,0101B,1110B,0101B,1010B,0101B,1010B,0101B>	;AN000;
	    PAT_8X4_STR <24,1010B,0101B,0101B,1010B,1010B,0101B,0101B,1010B>	;AN000;
	    PAT_8X4_STR <30,1010B,0101B,1010B,0000B,0101B,1010B,0101B,0000B>	;AN000;
	    PAT_8X4_STR <36,1010B,0000B,1010B,0101B,0000B,1010B,0000B,0101B>	;AN000;
	    PAT_8X4_STR <42,1010B,0000B,0101B,0000B,1010B,0000B,0101B,0000B>	;AN000;
	    PAT_8X4_STR <46,0010B,1000B,0000B,0010B,1000B,0001B,0100B,0001B>	;AN000;
	    PAT_8X4_STR <48,1010B,0000B,0101B,0000B,0000B,1010B,0000B,0000B>	;AN000;
	    PAT_8X4_STR <50,0010B,0000B,1000B,0010B,0000B,0100B,0001B,0000B>	;AN000;
	    PAT_8X4_STR <53,1010B,0000B,0000B,0000B,0101B,0000B,0000B,0000B>	;AN000;
	    PAT_8X4_STR <56,0000B,1000B,0000B,0000B,0100B,0000B,0000B,0010B>	;AN000;
	    PAT_8X4_STR <59,1000B,0000B,0000B,0000B,0010B,0000B,0000B,0000B>	;AN000;
	    PAT_8X4_STR <62,1000B,0000B,0000B,0000B,0000B,0000B,0000B,0000B>	;AN000;
	    PAT_8X4_STR <63,0000B,0000B,0000B,0000B,0000B,0000B,0000B,0000B>	;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 8X6 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_8X6 LABEL BYTE								;AN000;
	  PAT_8X6_STR < 1,111111B,111111B,111111B,111111B,111111B,111111B,111111B,111111B>;AN000;
	  PAT_8X6_STR < 4,011011B,111111B,111111B,111111B,110110B,111111B,111111B,111111B>;AN000;
	  PAT_8X6_STR < 7,101010B,011111B,111111B,110101B,101010B,011111B,111111B,110101B>;AN000;
	  PAT_8X6_STR <10,101010B,010101B,111111B,101010B,010101B,101010B,111111B,010101B>;AN000;
	  PAT_8X6_STR <13,011011B,100100B,111011B,100100B,011011B,100100B,011111B,100100B>;AN000;
	  PAT_8X6_STR <17,101010B,010101B,101010B,010101B,101010B,010101B,101010B,010101B>;AN000;
	  PAT_8X6_STR <21,101010B,010101B,101010B,010101B,001010B,010101B,101010B,010101B>;AN000;
	  PAT_8X6_STR <25,010100B,101010B,010101B,001010B,100100B,010001B,101110B,000001B>;AN000;
	  PAT_8X6_STR <29,000000B,010101B,101010B,010101B,000000B,101010B,010101B,101010B>;AN000;
	  PAT_8X6_STR <33,010010B,100101B,011000B,100010B,001101B,100000B,001010B,100100B>;AN000;
	  PAT_8X6_STR <37,100100B,001010B,010000B,001001B,100010B,001101B,010000B,001010B>;AN000;
	  PAT_8X6_STR <41,100000B,010010B,100100B,000010B,101000B,000101B,010000B,001010B>;AN000;
	  PAT_8X6_STR <45,100010B,001000B,000010B,100000B,010100B,000001B,100100B,000000B>;AN000;
	  PAT_8X6_STR <49,101000B,000001B,000100B,010000B,000010B,100000B,001000B,000101B>;AN000;
	  PAT_8X6_STR <53,101010B,000000B,000000B,000000B,010101B,000000B,000000B,000000B>;AN000;
	  PAT_8X6_STR <57,000000B,010000B,000000B,000100B,000000B,100000B,000000B,000010B>;AN000;
	  PAT_8X6_STR <60,100000B,000000B,000000B,000000B,000100B,000000B,000000B,000000B>;AN000;
	  PAT_8X6_STR <62,100000B,000000B,000000B,000000B,000000B,000000B,000000B,000000B>;AN000;
	  PAT_8X6_STR <63,000000B,000000B,000000B,000000B,000000B,000000B,000000B,000000B>;AN000;
CODE	ENDS										  ;AN000;
	END										  ;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\grload3.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:   I restructured the procedure PARSE_GRAPHICS so it can handle 
;**                 the keywords LOWCOUNT, HIGHCOUNT, the new keywords COUNT and 
;**                 DATA, and the escape sequence bytes in any order.
;**  
;**  BUG NOTES:     The   following   bug   was  fixed   for   the   pre-release  
;**                 version Q.01.02.
;**  
;**  BUG (mda003)
;**  ------------
;**  
;**  NAME:     GRAPHICS   prints  a CR & LF after  each  scan line unless it  is 
;**            loaded twice.  
;**  
;**  FILES & PROCEDURES AFFECTED:  GRLOAD3.ASM - PARSE_GRAPHICS
;**                                GRCOMMON.ASM - END_PRT_LINE
;**                                GRSHAR.STR - N/A
;**  
;**  CAUSES:   The local variables LOWCOUNT_FOUND, HIGHCOUNT_FOUND CR_FOUND  and 
;**            LF_FOUND used for loading, were incorrectly being used as  global 
;**            variables during printing.
;**  
;**  FIX:      Created  a new variable Printer_Needs_CR_LF in GRSHAR.STR,  which 
;**            is  used  to  determine  in GRCOMMON.ASM  if  it's  necessary  to 
;**            manually  send  a  CR  & LF to the printer  at  print  time.  The 
;**            variable  is  set at load time in GRLOAD3.ASM, if  the  variables 
;**            Data_Found and Build_State are set. 
;**  
;**  DOCUMENTATION NOTES:  This version of GRLOAD3.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Profile Load Modules #2 	;AN000;
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                    
;;										;AN000;
;; File Name:  GRLOAD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;   This file contains the modules used to load the				;AN000;
;;   GRAPHICS profile into resident memory.					;AN000;
;;										;AN000;
;;   ************* The EGA Dynamic Save Area will be built (by			;AN000;
;;   **  NOTE	** CHAIN_INTERRUPTS in file GRINST.ASM) over top of these	;AN000;
;;   ************* modules to avoid having to relocate this save just before	;AN000;
;;   terminating.  This is safe since the maximum memory used is		;AN000;
;;   288 bytes and the profile loading modules are MUCH larger than		;AN000;
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		;AN000;
;;   GRPRINT.ASM.								;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 LOAD_PROFILE - Main module for profile loading 			;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 ?????????? - Externals for profile loading modules			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE' BYTE     ;;                                       ;AN000;
				       ;;					;AN000;
	INCLUDE STRUC.INC	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;; Bring in external declarations	;AN000;
				       ;;  for transient command processing	;AN000;
	INCLUDE GRSHAR.STR	       ;;					;AN000;
	INCLUDE GRMSG.EQU	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;;					;AN000;
	INCLUDE GRLOAD.EXT	       ;;					;AN000;
	INCLUDE GRLOAD2.EXT	       ;;					;AN000;
	INCLUDE GRPARSE.EXT	       ;;					;AN000;
	INCLUDE GRPATTRN.STR	       ;;					;AN000;
	INCLUDE GRPATTRN.EXT	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   PUBLIC PARSE_GRAPHICS	       ;;					;AN000;
   PUBLIC PARSE_COLORSELECT	       ;;					;AN000;
   PUBLIC PARSE_COLORPRINT	       ;;					;AN000;
   PUBLIC PARSE_DARKADJUST	       ;;					;AN000;
   PUBLIC LIMIT 		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Profile Load Variables							;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
NO	      EQU   0		       ;;					;AN000;
YES	      EQU   1		       ;;					;AN000;
				       ;;					;AN000;
RESULT_BUFFER	LABEL BYTE	       ;; general purpose result buffer 	;AN000;
		    DB	 ?	       ;; operand type				;AN000;
RESULT_TAG	    DB	 0	       ;; operand tag				;AN000;
		    DW	 ?	       ;; pointer to synonym/keyword		;AN000;
RESULT_VAL	    DB	 ?,?,?,?       ;; returned numeric value		;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_GRAPHICS								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
GRAPHICS_PARSE_PARMS  LABEL WORD       ;; Parser control blocks 		;AN000;
	    DW	 GRAPHICS_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
GRAPHICS_P   DB   0,1		       ;; Required, max parms			;AN000;
	    DW	 GRAPHICS_P1	       ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
GRAPHICS_P1 DW	 0A000H 	       ;; Numeric OR string			;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 GRAPHICS_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
GRAPHICS_P1V	DB   3		       ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,255		       ;; range 0..255				;AN000;
	    DB	 0		       ;; 0 - no actual numerics		;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               Changed the # of string values from 2 to 4 because of the new
;               keywords COUNT and DATA.
	    DB	 4		       ;; 4 STRING VALUES			;AN000;
;/\  ~~mda(001) -----------------------------------------------------------------------
	    DB	 2		       ;; tag					;AN000;
	    DW	 LOWCOUNT_STR	       ;; ptr					;AN000;
	    DB	 3		       ;; tag					;AN000;
	    DW	 HIGHCOUNT_STR	       ;; ptr					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               Added the following valid string values because of the new
;               keywords COUNT and DATA.
            DB  4                       ; tag
            DW  COUNT_STR               ; ptr
            DB  5                       ; tag
            DW  DATA_STR                ; ptr

COUNT_STR     DB  'COUNT',0             ;
DATA_STR      DB  'DATA',0              ;
;
;/\  ~~mda(001) -----------------------------------------------------------------------
				       ;;					;AN000;
lowcount_str  db  'LOWCOUNT',0         ;;                                       ;AN000;
HIGHcount_str  db  'HIGHCOUNT',0       ;;                                       ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
LOWCOUNT_FOUND	 DB  NO 	       ;;					;AN000;
HIGHCOUNT_FOUND  DB  NO 	       ;;				  	;AN000;

;\/  ~~mda(001) -----------------------------------------------------------------------
;                Added the following so know when get COUNT and DATA.
COUNT_FOUND      DB  NO                 ;
DATA_FOUND       DB  NO                 ;
;
;/\  ~~mda(001) -----------------------------------------------------------------------
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_GRAPHICS	PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,GR		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;;					;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
	
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     MOV  DI,BLOCK_START	       ;;					;AN000;
     MOV  AX,BLOCK_END		       ;;				;AN000;
     MOV  [BP+DI].GRAPHICS_ESC_PTR,AX  ;; Set pointer to GRAPHICS seq		;AN000;
     MOV  [BP+DI].NUM_GRAPHICS_ESC,0   ;; Init sequence size			;AN000;
     MOV  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA,0   ;;~~mda(001) Init sequence size			;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  LOWCOUNT_FOUND,NO	       ;; Flags to indicate whether the LOW	;AN000;
  MOV  HIGHCOUNT_FOUND,NO	       ;;  and HIGHCOUNT parms were found	;AN000;
  MOV  COUNT_FOUND,NO                  ;;~~mda(001) Flags to indicate the COUNT 
  MOV  DATA_FOUND,NO 		       ;;~~mda(001) and DATA parms were found					;AN000;
                                       ;;
  OR   STMTS_DONE,GR		       ;; Indicate GRAPHICS found		;AN000;
				       ;;					;AN000;
  MOV  AX,PREV_STMT		       ;; Terminate any preceeding groups	;AN000;
  OR   GROUPS_DONE,AX		       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET GRAPHICS_PARSE_PARMS  ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
				       ;;					;AN000;
   .IF <AX EQ 0> NEAR		       ;; If PARM is valid			;AN000;
	MOV  BL,RESULT_TAG	       ;;					;AN000;
       .SELECT			       ;;					;AN000;
       .WHEN <BL EQ 1>		       ;; Escape byte				;AN000;
	  PUSH AX		       ;;					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               Changed the 1 to a 2 in the following instruction cause
;               need an extra byte in the sequence to hold the tag that
;               corresponds to esc seq., so during printing we know what to
;               send and in what order.

	  MOV	AX,2		       ;; Add a byte to the sequence		;AN000;
;/\  ~~mda(001) -----------------------------------------------------------------------
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,BLOCK_START       ;;					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               During printing we need to know how many things (things being
;               esc #s, count, lowcount, or highcount) come before
;               the data and how many things go after the data, - not just
;               how many bytes are in the sequence.  So check if dealing with 
;               things that come before the data.

            .IF <DATA_FOUND EQ NO>      ; Bump # of things in seq. that 
	        INC  [BP+DI].NUM_GRAPHICS_ESC ;; come before data.       	
            .ELSE                       ; Bump # of things in seq. that
                INC  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA  ; go after data
	    .ENDIF
;/\  ~~mda(001) -----------------------------------------------------------------------
	     MOV  DI,BLOCK_END	       ;;					;AN000;
             MOV  BYTE PTR [BP+DI-2],ESC_NUM_CODE;
	     MOV  AL,RESULT_VAL        ;; Get esc byte from result buffer	;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store at end of sequence		;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
       .WHEN <BL EQ 2>		       ;; LOWCOUNT				;AN000;
	   CMP LOWCOUNT_FOUND,NO       ;; ~~mda(001) If no LOWCOUNT or COUNT   ;AN000;
           JNE LOWCNT_ERROR             ; ~~mda(001) then proceed.  Not using
           CMP COUNT_FOUND,NO           ; ~~mda(001) .IF macro cause jump is 
           JNE LOWCNT_ERROR             ; ~~mda(001) out of range
	       MOV   LOWCOUNT_FOUND,YES ;;					;AN000;
	       PUSH AX		       ;;					;AN000;
	       MOV   AX,2	       ;; ~~mda(001) Changed a 1 to a 2 cause	;AN000;
                                        ; ~~mda(001) need extra byte for tag
	       CALL  GROW_SHARED_DATA  ;; Update block end			;AN000;
	      .IF <BUILD_STATE EQ YES> ;;					;AN000;
		  PUSH DI	       ;;					;AN000;
		  MOV  DI,BLOCK_START  ;;					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
                 .IF <DATA_FOUND EQ NO>      ; Bump # of things in seq. that 
        	     INC  [BP+DI].NUM_GRAPHICS_ESC ;; come before data.      
                 .ELSE                       ; Bump # of things in seq. that
                     INC  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA  ; go after data
	         .ENDIF
;/\  ~~mda(001) -----------------------------------------------------------------------
	
		  MOV  DI,BLOCK_END    ;; ~~mda(001) Put BLOCK_END in DI not AX.;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               No longer need following 3 instruction cause will have COUNT
;               at a known fixed location in the SHARED_DATA_AREA.
;
;;		  DEC  AX	       ;; Save pointer to low byte		;AN000;
;;		  MOV  [BP+DI].LOW_BYT_COUNT_PTR,AX				;AN000;
;;		  MOV  DI,AX	       ;;			 		;AN000;
;/\  ~~mda(001) -----------------------------------------------------------------------
                  MOV  BYTE PTR [BP+DI-2],LOWCOUNT_CODE;
		  MOV  BYTE PTR[BP+DI-1],0 ;; ~~mda(001) Added the -1. Store 0 in ;AN000;
		  POP  DI	       ;;		 in place of count      ;AN000;
	      .ENDIF		       ;;					;AN000;
	       POP  AX		       ;;					;AN000;
               JMP  CK_NEXT_PARM        ;~~mda(001) Added jump since can't use .IF macro
 LOWCNT_ERROR:  		       ;;~~mda(001) Added label since can't use .IF macro 
	       OR  STMT_ERROR,INVALID  ;; Duplicate LOWCOUNT parms              ;AN000;
	       MOV  PARSE_ERROR,YES    ;;~~mda(001) or combo of LOWCOUNT & COUNT;AN000;
	       MOV  BUILD_STATE,NO     ;;					;AN000;
       .WHEN <BL EQ 3>		       ;; HIGHCOUNT				;AN000;
	   CMP HIGHCOUNT_FOUND,NO       ;; ~~mda(001) If no HIGHCOUNT or COUNT   ;AN000;
           JNE HIGHCNT_ERROR             ; ~~mda(001) then proceed.  Not using
           CMP COUNT_FOUND,NO           ;  ~~mda(001) .IF macro cause jump is 
           JNE HIGHCNT_ERROR             ; ~~mda(001) out of range
	      MOV   HIGHCOUNT_FOUND,YES ;;					;AN000;
	      PUSH AX		       ;;					;AN000;
	      MOV   AX,2	       ;; ~~mda(001) Changed a 1 to a 2 cause	;AN000;
                                        ; ~~mda(001) need extra byte for tag
	      CALL  GROW_SHARED_DATA   ;; Update block end			;AN000;
	     .IF <BUILD_STATE EQ YES>  ;;					;AN000;
		 PUSH DI	       ;;					;AN000;
		 MOV  DI,BLOCK_START   ;;					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
                .IF <DATA_FOUND EQ NO>      ; Bump # of things in seq. that 
	            INC  [BP+DI].NUM_GRAPHICS_ESC ;; come before data.    
                .ELSE                       ; Bump # of things in seq. that
                    INC  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA  ; go after data
	        .ENDIF
;/\  ~~mda(001) -----------------------------------------------------------------------

        	 MOV  DI,BLOCK_END    ;; ~~mda(001) Put BLOCK_END in DI not AX. ;AN000;	
;\/  ~~mda(001) -----------------------------------------------------------------------
;               No longer need following 3 instructions cause will have COUNT
;               at a known fixed location in the SHARED_DATA_AREA.
;
;;		 DEC  AX	       ;; Save pointer to low byte		;AN000;
;;		 MOV  [BP+DI].LOW_BYT_COUNT_PTR,AX				;AN000;
;;	         MOV  DI,AX	       ;;			 		;AN000;
;/\  ~~mda(001) -----------------------------------------------------------------------
                 MOV  BYTE PTR [BP+DI-2],HIGHCOUNT_CODE;
		 MOV  BYTE PTR[BP+DI-1],0 ;; ~~mda(001) Added the -1. Store 0 in  ;AN000;
		 POP  DI	       ;; place of count					;AN000;
	     .ENDIF		       ;;					;AN000;
	      POP  AX		       ;;					;AN000;
              JMP  CK_NEXT_PARM        ;~~mda(001) Added jump since can't use .IF macro
	
 HIGHCNT_ERROR: 		       ;;~~mda(001) Added label cause can't use .IF macro.					;AN000;
	       OR  STMT_ERROR,INVALID  ;; Duplicate HIGHCOUNT parms	       
	       MOV  PARSE_ERROR,YES    ;; ~~mda(001) or combo of HIGHCOUNT and  ;AN000;
	       MOV  BUILD_STATE,NO     ;; ~~mda(001) COUNT parms                ;AN000;

;\/  ~~mda(001) -----------------------------------------------------------------------
;               Added the following two cases for when have COUNT or DATA on
;               GRAPHICS line.
 
       .WHEN <BL EQ 4>		       ;; COUNT				        
          .IF <COUNT_FOUND EQ NO> AND   ; If haven't found a type of count
	  .IF <LOWCOUNT_FOUND EQ NO> AND;;then proceed.                         
          .IF <HIGHCOUNT_FOUND EQ NO>   ; 
                                        ; 
	      MOV   COUNT_FOUND,YES    ;;					
	      PUSH AX		       ;;					
	      MOV   AX,2	       ;; Add 2 bytes to the seq. cause         
                                        ; need extra byte for tag
	      CALL  GROW_SHARED_DATA   ;; Update block end			
	     .IF <BUILD_STATE EQ YES>  ;;					
		 PUSH DI	       ;;					
		 MOV  DI,BLOCK_START   ;;					
                .IF <DATA_FOUND EQ NO>      ; Bump # of things in seq. that 
	            INC  [BP+DI].NUM_GRAPHICS_ESC ;; come before data.       	
                .ELSE                       ; Bump # of things in seq. that
                    INC  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA  ; go after data
	        .ENDIF
        	 MOV  DI,BLOCK_END    ;;                                        	
                 MOV  BYTE PTR [BP+DI-2],COUNT_CODE;
		 MOV  BYTE PTR[BP+DI-1],0 ;; Store 0 in place of count          
		 POP  DI	       ;; 					
	     .ENDIF		       ;;					
	      POP  AX		       ;;					
	  .ELSE 		       ;;					
	       OR  STMT_ERROR,INVALID  ;; Duplicate COUNT parms or combo of     
	       MOV  PARSE_ERROR,YES    ;; COUNT, LOWCOUNT or HIGHCOUNT parms    
	       MOV  BUILD_STATE,NO     ;;                                       
	  .ENDIF		       ;;					

       .WHEN <BL EQ 5>		       ;; DATA				        
          .IF <DATA_FOUND EQ NO>        ; If haven't found data then proceed
	      MOV   DATA_FOUND,YES     ;;					
	      PUSH AX		       ;;					
	      MOV   AX,2	       ;; Add 2 bytes to the seq. cause         
                                        ; need extra byte for tag
	      CALL  GROW_SHARED_DATA   ;; Update block end			
	     .IF <BUILD_STATE EQ YES>  ;;					
                 PUSH DI               ;;
        	 MOV  DI,BLOCK_END    ;;                                        
                 MOV  BYTE PTR [BP+DI-2],DATA_CODE;
		 MOV  BYTE PTR[BP+DI-1],0 ;; Store 0 in place of data           
		 POP  DI	       ;; 					
	     .ENDIF		       ;;					
	      POP  AX		       ;;					
	  .ELSE 		       ;;					
	       OR  STMT_ERROR,INVALID  ;; Duplicate DATA parms                  
	       MOV  PARSE_ERROR,YES    ;;                                       
	       MOV  BUILD_STATE,NO     ;;                                       
	  .ENDIF		       ;;					
;/\  ~~mda(001) -----------------------------------------------------------------------

       .ENDSELECT		       ;;					;AN000;
   .ELSE NEAR			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;

CK_NEXT_PARM:                           ;~~mda(001) Added label since can't use
                                        ;~~mda(001) .IF macro.
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;

;\/  ~~mda(003) -----------------------------------------------------------------------
 .IF  <DATA_FOUND EQ NO>               ;; We have a printer that requires a					;AN000;
      .IF <BUILD_STATE EQ YES>         ;;
           MOV  [BP].PRINTER_NEEDS_CR_LF,YES; CR, LF to be sent to it
      .ENDIF                           ;;
 .ENDIF                                ;;
;/\  ~~mda(003) -----------------------------------------------------------------------

				       ;;					;AN000;
 .IF  <LOWCOUNT_FOUND EQ NO> OR        ;;					;AN000;
 .IF  <HIGHCOUNT_FOUND EQ NO>	       ;; Missing LOWCOUNT/HIGHCOUNT parms	;AN000;
      .IF  <COUNT_FOUND EQ NO>         ;; ~~mda(001) or missing COUNT parm
           OR   STMT_ERROR,INVALID	       ;;					;AN000;
           MOV  PARSE_ERROR,YES	       ;;					;AN000;
           MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF
 .ENDIF 			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_GRAPHICS	ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_COLORSELECT								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
COLORSELECT_PARSE_PARMS  LABEL WORD    ;; Parser control blocks 		;AN000;
	    DW	 COLORSELECT_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
COLORSELECT_P	   LABEL BYTE	       ;;					;AN000;
CS_NUM_REQ    DB   1,1		       ;; Required, max parms			;AN000;
COLORSELECT_PARM   LABEL  WORD	       ;;					;AN000;
CS_POSITIONAL DW   ?		       ;; Pointer to our positional		;AN000;
	      DB   0		       ;; # Switches				;AN000;
	      DB   0		       ;; # keywords				;AN000;
				       ;;					;AN000;
COLORSELECT_P0	DW   2000H	       ;; sTRING - display type 		;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 COLORSELECT_P0V       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
COLORSELECT_P0V    DB	0		   ;; # of value lists			;AN000;
;	    DB	 0		       ;; # of range numerics			;AN000;
;	    DB	 0		       ;; # of discrete numerics		;AN000;
;	    DB	 1		       ;; # of strings				;AN000;
;	    DB	 1		       ;; tag					;AN000;
;COLORSELECT_P0V1 DW   ?		   ;; string				;AN000;
				       ;;					;AN000;
COLORSELECT_P1	DW   8001H		  ;; Numeric - escape sequence byte	;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 COLORSELECT_P1V	  ;; Value list 			;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
COLORSELECT_P1V    DB	1		  ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 1,255		       ;; range 1..255				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
SEQ_LENGTH_PTR	DW   0		       ;; Number of colorselect statements	;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_COLORSELECT  PROC 	       ;;					;AN000;
				      ;;					;AN000;
  MOV  CUR_STMT,COLS		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND PRT>	       ;; PRINTER  statemnet must have been	;AN000;
     OR  STMT_ERROR,MISSING	       ;;  processed				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE AND DISP+COLP>    ;; DISDPLAYMODE and COLORPRINT  stmts	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  should NOT have been processed	;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT GROUPS_DONE AND COLS>        ;; Check for a previous group of 	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  COLORSELECTS within this PTD 	;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND COLS>        ;; If first COLORSELECT...		;AN000;
      MOV  NUM_BANDS,0		       ;; Init number of COLORSELECT bands	;AN000;
     .IF <BUILD_STATE EQ YES>	       ;; Update count and pointer in the	;AN000;
	 MOV  AX,BLOCK_END	       ;;  Shared Data Area header		;AN000;
	 MOV  [BP].COLORSELECT_PTR,AX  ;; Set pointer to COLORSELECT info	;AN000;
	 MOV  [BP].NUM_PRT_BANDS,0     ;; Init NUMBER OF COLORSELECTS		;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,COLS		       ;; Indicate found			;AN000;
 .IF <PREV_STMT NE COLS> THEN	       ;; Terminate any preceeding groups	;AN000;
     MOV  AX,PREV_STMT		       ;;  except for COLORSELECT		;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV	AX,1			       ;; Make room for sequence length field	;AN000;
  CALL	GROW_SHARED_DATA	       ;;					;AN000;
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     INC  [BP].NUM_PRT_BANDS	       ;; Inc number of selects 		;AN000;
     MOV  DI,BLOCK_END		       ;;					;AN000;
     MOV  BYTE PTR [BP+DI-1],0	       ;; Init sequence length field		;AN000;
     LEA  AX,[DI-1]		       ;;					;AN000;
     MOV  SEQ_LENGTH_PTR,AX	       ;; Save pointer to length of sequence	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET COLORSELECT_PARSE_PARMS  ;; parse parms			;AN000;
  MOV  CS_NUM_REQ,1		       ;; Change to 1 required parameters	;AN000;
  MOV  AX,OFFSET COLORSELECT_P0        ;; Point to control block for the band	;AN000;
  MOV  CS_POSITIONAL,AX 	       ;;  ID.	(Dealing with only 1 positional ;AN000;
				       ;;  parameter at a time was the only way ;AN000;
				       ;;   I could get SYSPARSE to handle	;AN000;
				       ;;    the COLORSELECT syntax!)		;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the band ID			;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
     RET			       ;;  statement.				;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  PUSH	ES			       ;; We got a band id........		;AN000;
  PUSH	DI			       ;;					;AN000;
				       ;;					;AN000;
  LES	DI,DWORD PTR RESULT_VAL        ;; Get pointer to the parsed band id	;AN000;
 .IF <<BYTE PTR ES:[DI+1]> NE 0>       ;; Make sure the band id is only 	;AN000;
     OR  STMT_ERROR,INVALID	       ;;  one byte long			;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  BL,NUM_BANDS		       ;;					;AN000;
  XOR  BH,BH			       ;;					;AN000;
 .IF <BX EQ MAX_BANDS> THEN	       ;; Watch out for too many COLORSELECTs	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     SHL  BX,1			       ;; calc index to store band in value list;AN000;
     MOV  AL,ES:[DI]		       ;; get BAND ID FROM PARSEr		;AN000;
     MOV  BAND_VAL_LIST[BX],AL	       ;;					;AN000;
     INC  NUM_BANDS		       ;; bump number of bands			;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  POP  DI			       ;;					;AN000;
  POP  ES			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,OFFSET COLORSELECT_P1        ;; Switch to numeric positional parm!!!	;AN000;
  MOV  CS_POSITIONAL,AX 	       ;;					;AN000;
  MOV  CS_NUM_REQ,0		       ;; Change to 0 required parameters	;AN000;
  XOR  DX,DX			       ;; PARSE the sequence of escape bytes	;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
   .IF <AX EQ 0>		       ;; If esc byte is valid			;AN000;
	  PUSH AX		       ;;					;AN000;
	  MOV	AX,1		       ;; Add a byte to the sequence		;AN000;
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,SEQ_LENGTH_PTR    ;;					;AN000;
	     INC  byte ptr [BP+DI]     ;; Bump number of bytes in sequence	;AN000;
	     MOV  DI,BLOCK_END	       ;;					;AN000;
	     MOV  AL,RESULT_VAL        ;; Get esc byte from result buffer	;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store at end of sequence		;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_COLORSELECT  ENDP 	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_COLORPRINT								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
COLORPRINT_PARSE_PARMS	LABEL WORD    ;; Parser control blocks			;AN000;
	    DW	 COLORPRINT_P	      ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
COLORPRINT_P	  LABEL BYTE	       ;;					;AN000;
	      DB   3,4		       ;; Required,MAX				;AN000;
	      DW   COLORPRINT_P0       ;; Numeric: Red value			;AN000;
	      DW   COLORPRINT_P0       ;; Green value				;AN000;
	      DW   COLORPRINT_P0       ;; Blue value				;AN000;
	      DW   COLORPRINT_P1       ;; Band ID ... REPEATING 		;AN000;
	      DB   0		       ;; # Switches				;AN000;
	      DB   0		       ;; # keywords				;AN000;
				       ;;					;AN000;
COLORPRINT_P0  DW   8000H	       ;; Numeric - RGB value			;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 COLORPRINT_P0V        ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
COLORPRINT_P0V	 DB   1 	       ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,63		       ;; range 0..63				;AN000;
				       ;;					;AN000;
COLORPRINT_P1  DW   2001H	       ;; sTRING - Band ID			;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 COLORPRINT_P1V        ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
COLORPRINT_P1V	  DB   3	       ;; # of value lists			;AN000;
	    DB	 0		       ;; 0 - no range numerics 		;AN000;
	    DB	 0		       ;; 0 - no actual numerics		;AN000;
NUM_BANDS   DB	 0		       ;; number of band values 		;AN000;
	    DB	 01H		       ;; tag: TAGS ARE BAND MASKS		;AN000;
	    DW	 BAND_PTR_1	       ;; ptr					;AN000;
	    DB	 02H		       ;; tag					;AN000;
	    DW	 BAND_PTR_2	       ;; ptr					;AN000;
	    DB	 04H		       ;; tag					;AN000;
	    DW	 BAND_PTR_3	       ;; ptr					;AN000;
	    DB	 08H		       ;; tag					;AN000;
	    DW	 BAND_PTR_4	       ;; ptr					;AN000;
	    DB	 10H		       ;; tag					;AN000;
	    DW	 BAND_PTR_5	       ;; ptr					;AN000;
	    DB	 20H		       ;; tag					;AN000;
	    DW	 BAND_PTR_6	       ;; ptr					;AN000;
	    DB	 40H		       ;; tag					;AN000;
	    DW	 BAND_PTR_7	       ;; ptr					;AN000;
	    DB	 80H		       ;; tag					;AN000;
	    DW	 BAND_PTR_8	       ;; ptr					;AN000;
				       ;;					;AN000;
MAX_BANDS   EQU  8		       ;;					;AN000;
				       ;;					;AN000;
BAND_VAL_LIST  LABEL BYTE	       ;;					;AN000;
BAND_PTR_1  DB	 ?,0		       ;;					;AN000;
BAND_PTR_2  DB	 ?,0		       ;;					;AN000;
BAND_PTR_3  DB	 ?,0		       ;;					;AN000;
BAND_PTR_4  DB	 ?,0		       ;;					;AN000;
BAND_PTR_5  DB	 ?,0		       ;;					;AN000;
BAND_PTR_6  DB	 ?,0		       ;;					;AN000;
BAND_PTR_7  DB	 ?,0		       ;;					;AN000;
BAND_PTR_8  DB	 ?,0		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_COLORPRINT  PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,COLP		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND PRT>	       ;; PRINTER  statemnet must have been	;AN000;
     OR  STMT_ERROR,MISSING	       ;;  processed				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE AND DISP>	       ;; DISPLAYMODE stmts			;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  should NOT have been processed	;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT GROUPS_DONE AND COLP>        ;; Check for a previous group of 	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  COLORPRINTS within this PTD		;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_PRINTER_TYPE,COLOR	       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND COLP>        ;; If first COLORPRINT...		;AN000;
     .IF <BUILD_STATE EQ YES>	       ;; Update count and pointer in the	;AN000;
	 MOV  AX,BLOCK_END	       ;;  Shared Data Area header		;AN000;
	 MOV  [BP].COLORPRINT_PTR,AX   ;; Set pointer to COLORPRINT info	;AN000;
	 MOV  [BP].PRINTER_TYPE,COLOR  ;;					;AN000;
	 MOV  [BP].NUM_PRT_COLOR,0     ;; Init NUMBER OF COLORPRINTS		;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     INC  [BP].NUM_PRT_COLOR	       ;; Inc number of selects 		;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,COLP		       ;; Indicate found			;AN000;
 .IF <PREV_STMT NE COLP> THEN	       ;; Terminate any preceeding groups	;AN000;
     MOV  AX,PREV_STMT		       ;;  except for COLORPRINT		;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV	AX,BLOCK_END		       ;; Start a new block			;AN000;
  MOV	BLOCK_START,AX		       ;;					;AN000;
  MOV	AX,SIZE COLORPRINT_STR	       ;; Make room for COLORPRINT info 	;AN000;
  CALL	GROW_SHARED_DATA	       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET COLORPRINT_PARSE_PARMS  ;; parse parms 			;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the RED value			;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 PUSH  DI		       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AL,RESULT_VAL	       ;; Store RED value in COLORPRINT info	;AN000;
	 MOV  [BP+DI].RED,AL	       ;;					;AN000;
	 POP  DI		       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the GREEN value 		;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 PUSH  DI		       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AL,RESULT_VAL	       ;; Store GREEN value in COLORPRINT info	;AN000;
	 MOV  [BP+DI].GREEN,AL	       ;;					;AN000;
	 POP  DI		       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the BLUE value			;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 PUSH  DI		       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AL,RESULT_VAL	       ;; Store BLUE value in COLORPRINT info	;AN000;
	 MOV  [BP+DI].BLUE,AL	       ;;					;AN000;
	 POP  DI		       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     PUSH  DI			       ;;					;AN000;
     MOV   DI,BLOCK_START	       ;;					;AN000;
     MOV   [BP+DI].SELECT_MASK,0       ;; Initialize band select mask		;AN000;
     POP   DI			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  XOR  DX,DX			       ;; For each band found "OR" the item     ;AN000;
 .REPEAT			       ;;  tag into the select mask		;AN000;
    MOV  CX,3			       ;; Avoid getting too many parms error	;AN000;
    CALL SYSPARSE		       ;;  from parser				;AN000;
   .IF <AX EQ 0>		       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	  PUSH	DI		       ;;					;AN000;
	  MOV	DI,BLOCK_START	       ;;					;AN000;
	  MOV	AL,RESULT_TAG	       ;;					;AN000;
	  OR	[BP+DI].SELECT_MASK,AL ;; OR the mask for this band into the	;AN000;
				       ;;  select mask for this color		;AN000;
	  POP	DI		       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_COLORPRINT  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_DARKADJUST								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
DARKADJUST_PARSE_PARMS	LABEL WORD    ;; Parser control blocks			;AN000;
	    DW	 DARKADJUST_P	      ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
DARKADJUST_P	  LABEL BYTE	       ;;					;AN000;
	      DB   1,1		       ;; Required,MAX				;AN000;
	      DW   DARKADJUST_P0       ;; Numeric: adjust value 		;AN000;
	      DB   0		       ;; # Switches				;AN000;
	      DB   0		       ;; # keywords				;AN000;
				       ;;					;AN000;
DARKADJUST_P0  DW   4000H	       ;; Signed Numeric - adjust value 	;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 DARKADJUST_P0V        ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
DARKADJUST_P0V	 DB   1 	       ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 -63,63 	       ;; range -63,63				;AN000;
;;;;***********************************;;					;AN000;
				       ;;					;AN000;
										;AN000;
PARSE_DARKADJUST  PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,DARK		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND PRT>	       ;; PRINTER  statemnet must have been	;AN000;
     OR  STMT_ERROR,MISSING	       ;;  processed				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,DARK		       ;; Indicate found			;AN000;
				       ;; Terminate any preceeding groups	;AN000;
  MOV  AX,PREV_STMT		       ;;					;AN000;
  OR   GROUPS_DONE,AX		       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET DARKADJUST_PARSE_PARMS  ;; parse parms 			;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the ADJUST VALUE		;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 MOV  AL,RESULT_VAL	       ;;					;AN000;
	 MOV  [BP].DARKADJUST_VALUE,AL ;;					;AN000;
     .ENDIF			       ;;					;AN000;
      CALL SYSPARSE		       ;; CHECK FOR EXTRA PARMS 		;AN000;
     .IF <AX NE -1>		       ;;					;AN000;
	OR  STMT_ERROR,INVALID	       ;;					;AN000;
	MOV PARSE_ERROR,YES	       ;;					;AN000;
	MOV BUILD_STATE,NO	       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_DARKADJUST  ENDP		       ;;					;AN000;
										;AN000;
LIMIT	LABEL NEAR		       ;;					;AN000;
CODE	ENDS			       ;;					;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\grload2.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:   I  altered  the  procedure  PARSE_VERB  and  added  the  new 
;**                 procedure PARSE_DEFINE and made it public in order to handle 
;**                 the  new  statement DEFINE.  I also made  the  new  variable 
;**                 DATA_TYPE  have  the  default of DATA_COL,  so  the  default 
;**                 assumes  IBM type printers.  
;**  
;**  BUG NOTES:     Bug  mda002  was  completely fixed   for   the   pre-release  
;**                 version  Q.01.02,  whereas  bug mda005  was  only  partially 
;**                 fixed.   In  other  words,  part of bug  mda005  is  in  the 
;**                 released versions D.01.01 & D.01.02.
;**  
;**  BUG (mda002)
;**  ------------
;**  
;**  NAME:     GRAPHICS   prints garbage on PCL  printers  if IBM  printers  are 
;**            listed after HP printers  in the GRAPHICS profile.  
;**  
;**  FILES & PROCEDURES AFFECTED:  GRLOAD2.ASM - PARSE_PRINTER
;**                                GRLOAD2.ASM - PARSE_DEFINE
;**  
;**  CAUSES:   1)   In  the  procedure Parse_Define I was moving values  in  the 
;**                 variable  DATA_TYPE for every DEFINE statement,  instead  of 
;**                 just  for  the  DEFINE statement that  corresponded  to  the 
;**                 printer we were using.
;**  
;**            2)   In the procedure Parse_Printer I was resetting DATA_TYPE  to 
;**                 DATA_COL  if  BUILD_STATE  = YES, but I was doing  it  in  a 
;**                 section  of  code  where BUILD_STATE  would  never  be  YES.  
;**  
;**  FIXES:     1)  Made  a couple of changes in the procedure  Parse_Define  so 
;**                 that  values are moved into the variable DATA_TYPE just  for 
;**                 the  DEFINE  statement  that  corresponds  to  the   printer 
;**                 currently being used.
;**  
;**            2)   I  moved a section of code from the procedure  Parse_Printer 
;**                 to  the  end of the procedure, because this is where  it  is 
;**                 possible for BUILD_STATE to equal YES.  
;**  
;**  BUG (mda005)
;**  ------------
;**  
;**  NAME:     If  a  picture is printed using a 3,1 printbox, the  picture  has 
;**            blank lines throughout  the picture,  which has  the wrong aspect
;**            ratio. 
;**  
;**  FILES & PROCEDURES AFFECTED:  GRLOAD2.ASM - PARSE_PRINTBOX
;**  
;**  CAUSE:    The print buffer was being filled as follows,
;**  
;**                      --------------------------
;**                      | o  o  o  o  o  o  o  o |
;**                      --------------------------
;**                        |_____|  |  |_____|  |
;**                           |     |     |     |              
;**                           |     |     |     |
;**            FROM:       pixel 1  |  pixel 2  |
;**                                 |           |
;**                                 |___________|
;**                                       |
;**                                       |
;**                                       |
;**                               Always left blank
;**  
;**            instead of as follows,
;**  
;**                      --------------------------
;**                      | o  o  o  o  o  o  o  o |
;**                      --------------------------
;**                        |_____|  |_____|  |__|
;**                           |        |       |     
;**                           |        |       |
;**            FROM:       pixel 1  pixel 2  pixel 3
;**  
;**            Note  that  this not only resulted in a strange  picture,  but  a 
;**            picture with the incorrect aspect ratio.  Because in essence  the 
;**            picture  was printed indirectly with a 4,1 printbox  because  for 
;**            every pixel read four bits were sent to the printer.
;**  
;**  FIX:      Because  of time constraints it was decided to print the  picture 
;**            directly  with a 4,1 printbox.  So even though the picture  still 
;**            has the wrong aspect ratio, it at least does not have funny blank 
;**            lines throughout the entire picture.  This fix was implemented by 
;**            changing a 3,1 printbox to a 4,1 printbox.
;**  
;**  DOCUMENTATION NOTES:  This version of GRLOAD2.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Profile Load Modules #2 	;AN000;
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                   
;;										;AN000;
;; File Name:  GRLOAD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;   This file contains the modules used to load the				;AN000;
;;   GRAPHICS profile into resident memory.					;AN000;
;;										;AN000;
;;   ************* The EGA Dynamic Save Area will be built (by			;AN000;
;;   **  NOTE	** CHAIN_INTERRUPTS in file GRINST.ASM) over top of these	;AN000;
;;   ************* modules to avoid having to relocate this save just before	;AN000;
;;   terminating.  This is safe since the maximum memory used is		;AN000;
;;   288 bytes and the profile loading modules are MUCH larger than		;AN000;
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		;AN000;
;;   GRPRINT.ASM.								;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 LOAD_PROFILE - Main module for profile loading 			;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 ?????????? - Externals for profile loading modules			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE' BYTE     ;;                                       ;AN000;
				       ;;					;AN000;
	INCLUDE STRUC.INC	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;; Bring in external declarations	;AN000;
				       ;;  for transient command processing	;AN000;
	INCLUDE GRSHAR.STR	       ;;					;AN000;
	INCLUDE GRMSG.EQU	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;;					;AN000;
	INCLUDE GRLOAD.EXT	       ;;					;AN000;
	INCLUDE GRPARSE.EXT	       ;;					;AN000;
	INCLUDE GRPATTRN.STR	       ;;					;AN000;
	INCLUDE GRPATTRN.EXT	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   PUBLIC PARSE_VERB		       ;;					;AN000;
   PUBLIC PARSE_PRINTER 	       ;;					;AN000;
; \/ ~~mda(001) ---------------------------------
;		Added procedure PARSE_DEFINE
;
   PUBLIC PARSE_DEFINE			;
; /\ ~~mda(001) ---------------------------------
   PUBLIC PARSE_DISPLAYMODE	       ;;					;AN000;
   PUBLIC PARSE_PRINTBOX	       ;;					;AN000;
   PUBLIC PARSE_SETUP		       ;;					;AN000;
   PUBLIC PARSE_RESTORE 	       ;;					;AN000;
   PUBLIC TERMINATE_DISPLAYMODE        ;;					;AN000;
   PUBLIC TERMINATE_PRINTER	       ;;					;AN000;
   PUBLIC CUR_PRINTER_TYPE	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Profile Load Variables							;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
NO	      EQU   0		       ;;					;AN000;
YES	      EQU   1		       ;;					;AN000;
				       ;;					;AN000;
RESULT_BUFFER	LABEL BYTE	       ;; general purpose result buffer 	;AN000;
		    DB	 ?	       ;; operand type				;AN000;
RESULT_TAG	    DB	 0	       ;; operand tag				;AN000;
		    DW	 ?	       ;; pointer to synonym/keyword		;AN000;
RESULT_VAL	    DB	 ?,?,?,?       ;; returned numeric value		;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   TERMINATE_DISPLAYMODE							;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
TERMINATE_DISPLAYMODE	PROC	       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,STMTS_DONE		       ;;					;AN000;
 .IF <PTD_FOUND EQ YES> AND	       ;; For the matched PTD			;AN000;
 .IF <BIT AX NAND BOX> AND	       ;;  issue "Invalid parm value"           ;AN000;
 .IF <PRT_BOX_ERROR EQ NO>	       ;;  message if PRINTBOX ID not		;AN000;
				       ;;  matched in each DISPLAYMODE section	;AN000;
	 PUSH AX		       ;; Save STMT_DONE flags			;AN000;
	 MOV  AX,INVALID_PB	       ;;					;AN000;
	 MOV  CX,0		       ;;					;AN000;
	 CALL DISP_ERROR	       ;;					;AN000;
	 MOV  BUILD_STATE,NO	       ;;					;AN000;
	 MOV  PRT_BOX_ERROR,YES        ;; Issue this message only once		;AN000;
	 POP  AX		       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  AND  AX,GR			       ;; Check for missing statements is last	;AN000;
 .IF <AX NE GR> 		       ;;  DISPLAYMODE section: 		;AN000;
     OR  STMT_ERROR,MISSING	       ;;    GRAPHICS stmt is required		;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
TERMINATE_DISPLAYMODE	ENDP	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   TERMINATE_PRINTER								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
TERMINATE_PRINTER	PROC	       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,BLOCK_END		       ;;					;AN000;
 .IF <AX A MAX_BLOCK_END>	       ;; Keep track of the largest PRINTER	;AN000;
    MOV  MAX_BLOCK_END,AX	       ;;  section so we can allow space for	;AN000;
 .ENDIF 			       ;;  reload with a different printer	;AN000;
				       ;;  type.				;AN000;
				       ;;					;AN000;
				       ;; Check for missing statements		;AN000;
  MOV  AX,STMTS_DONE		       ;;					;AN000;
  AND  AX,DISP			       ;; At least one DISPLAYMODE		;AN000;
 .IF <AX NE DISP>		       ;;  must have been found in last 	;AN000;
     OR  STMT_ERROR,MISSING	       ;;   PRINTER section			;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
TERMINATE_PRINTER	ENDP	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_PRINTER								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
PRINTER_PARSE_PARMS  LABEL WORD        ;; Parser control blocks 		;AN000;
	    DW	 PRINTER_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
PRINTER_P   DB	 0,1		       ;; Required, max parms			;AN000;
	    DW	 PRINTER_P1	       ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
PRINTER_P1  DW	 2000H		       ;; simple string 			;AN000;
	    DW	 0002H		       ;; Capitalize using character table	;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 PRINTER_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
PRINTER_P1V    DB   3		       ;; # of value lists			;AN000;
	    DB	 0		       ;; # of range numerics			;AN000;
	    DB	 0		       ;; # of discrete numerics		;AN000;
	    DB	 1		       ;; # of strings				;AN000;
	    DB	 1		       ;; tag: index into verb jump table	;AN000;
PRINTER_P1V1  DW   ?		       ;; string offset 			;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CUR_PRINTER_TYPE   DB  0	       ;; Type of printer currently being	;AN000;
				       ;;  parsed:  1-color 2-b&w		;AN000;
				       ;;					;AN000;
PARSE_PRINTER  PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,PRT		       ;;					;AN000;
  MOV  CUR_PRINTER_TYPE,BLACK_WHITE    ;; Assume black & white until we hit	;AN000;
				       ;;  a COLORPRINT 			;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE AND PRT>	       ;; If not the first PRINTER section	;AN000;
     CALL  TERMINATE_DISPLAYMODE       ;;  then clean up the last one and	;AN000;
     CALL  TERMINATE_PRINTER	       ;;    the last DISPLAYMODE section.	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 MOV  AX,FIRST_BLOCK		       ;;					;AN000;
 MOV  BLOCK_START,AX		       ;; Reset block pointers to start 	;AN000;
 MOV  BLOCK_END,AX		       ;;  of variable area			;AN000;
				       ;;					;AN000;
  MOV  STMTS_DONE,PRT		       ;; Clear all bits except for PRT 	;AN000;
  MOV  GROUPS_DONE,0		       ;; Clear 				;AN000;
				       ;;					;AN000;
 .IF <PTD_FOUND EQ YES> 	       ;; PRINTER statement marks the end of	;AN000;
     MOV  PTD_FOUND,PROCESSED	       ;;  the previous PTD			;AN000;
     MOV  BUILD_STATE,NO	       ;; Stop building shared data		;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  CL,TAB_DIR_NB_ENTRIES	       ;; Reset the pattern table copy		;AN000;
  XOR  CH,CH			       ;;  pointers.  These pointers		;AN000;
  MOV  BX,OFFSET TAB_DIRECTORY	       ;;   are established when a pattern	;AN000;
 .REPEAT			       ;;    table is copied to the shared	;AN000;
    MOV [BX].TAB_COPY,-1	       ;;     data area.  Initially they	;AN000;
    ADD BX,SIZE TAB_ENTRY	       ;;      are -1.				;AN000;
 .LOOP				       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,OFFSET PRINTER_TYPE_PARM     ;; Store printer type from command	;AN000;
  MOV  PRINTER_P1V1,AX		       ;;  line in value list			;AN000;
  MOV  DI,OFFSET PRINTER_PARSE_PARMS   ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
				       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
     XOR  CX,CX 		       ;; Don't worry about number of operands  ;AN000;
     CALL SYSPARSE		       ;;					;AN000;
    .IF <AX EQ 9>		       ;; Syntax error is the only thing	;AN000;
	OR  STMT_ERROR,INVALID	       ;;  which can go wrong			;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ 0> OR		       ;;					;AN000;
 .UNTIL <AX EQ -1>		       ;;					;AN000;
				       ;; Printer type parm matched one coded	;AN000;
				       ;;  on the PRINTER statement		;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
    .IF <PTD_FOUND EQ NO>	       ;;					;AN000;
	MOV  PTD_FOUND,YES	       ;; If the printer type matches and	;AN000;
       .IF <PARSE_ERROR EQ NO> AND     ;;  no errors have been found yet	;AN000;
       .IF <PRT_BOX_ERROR EQ NO> AND   ;;					;AN000;
       .IF <MEM_OVERFLOW EQ NO>        ;;					;AN000;
	   MOV BUILD_STATE,YES	       ;;   then start building the shared	;AN000;
       .ENDIF			       ;;    data				;AN000;
    .ENDIF			       ;;					;AN000;
 .ELSE				       ;; No match				;AN000;
    MOV  BUILD_STATE,NO 	       ;;					;AN000;
   .IF <AX NE -1>		       ;; Error during parse			;AN000;
      OR  STMT_ERROR,INVALID	       ;; set error flag for caller		;AN000;
      MOV PARSE_ERROR,YES	       ;; set error flag for caller		;AN000;
   .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
; \/ ~~mda(002) -----------------------------------------------------------------------
 .IF <BUILD_STATE EQ YES>              ;;
      MOV	[BP].DATA_TYPE,DATA_COL;; Set DATA_TYPE back to default of DATA_COL
 .ENDIF                                ;; for new PTD.
; /\ ~~mda(002) -----------------------------------------------------------------------
				       ;;					;AN000;
  RET										;AN000;
				       ;;					;AN000;
PARSE_PRINTER  ENDP								;AN000;
										;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;


;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_DISPLAYMODE								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
DISPMODE_PARSE_PARMS  LABEL WORD       ;; Parser control blocks 		;AN000;
	    DW	 DISPMODE_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
DISPMODE_P   DB   0,1		       ;; Required, max parms			;AN000;
	    DW	 DISPMODE_P1	       ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
DISPMODE_P1  DW   8000H 	       ;; Numeric				;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 DISPMODE_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
DISPMODE_P1V	DB   1			;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,19		       ;; range 0..19				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_DISPLAYMODE  PROC 	       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,DISP		       ;;					;AN000;
				       ;; Check for a preceeding PRINTER	;AN000;
 .IF <BIT STMTS_DONE NAND PRT>	       ;;					;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;; If first DISPLAYMODE...		;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 MOV  AX,BLOCK_END	       ;;					;AN000;
	 MOV  [BP].DISPLAYMODE_PTR,AX  ;; Set pointer to first DISPLAYMODE	;AN000;
	 MOV  BLOCK_START,AX	       ;; New block starts after last one	;AN000;
     .ENDIF			       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     CALL TERMINATE_DISPLAYMODE        ;; If not the first DISPLAYMODE then	;AN000;
				       ;;  clean up the last one.		;AN000;
     MOV  DI,BLOCK_START	       ;; DI=pointer to DISPLAYMODE block just	;AN000;
     MOV  AX,BLOCK_END		       ;;  built				;AN000;
    .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	MOV  [BP+DI].NEXT_DISP_MODE,AX ;; Add new block to DISPLAYMODE chain	;AN000;
    .ENDIF			       ;;					;AN000;
     MOV  BLOCK_START,AX	       ;; New block starts after last one	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,SIZE DISPLAYMODE_STR	       ;; Allocate space for new DISPLAYMODE	;AN000;
  CALL	GROW_SHARED_DATA	       ;;  block				;AN000;
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     MOV  DI,BLOCK_START	       ;; Start of new block			;AN000;
     MOV  [BP+DI].NUM_SETUP_ESC,0	  ;; SETUP, RESTORE are optional so set ;AN000;
     MOV  [BP+DI].NUM_RESTORE_ESC,0	  ;;  to defaults			;AN000;
     MOV  [BP+DI].SETUP_ESC_PTR,-1	  ;;					;AN000;
     MOV  [BP+DI].RESTORE_ESC_PTR,-1	  ;;					;AN000;
     MOV  [BP+DI].BOX_WIDTH,0		  ;;					;AN000;
     MOV  [BP+DI].BOX_HEIGHT,0		  ;;					;AN000;
     MOV  [BP+DI].PRINT_OPTIONS,0	  ;; Default to NO print options	;AN000;
     MOV  [BP+DI].NUM_DISP_MODE,0      ;; Get ready to INC this 		;AN000;
     MOV  [BP+DI].NEXT_DISP_MODE,-1    ;; This is the last DISPLAYMODE for now! ;AN000;
     MOV  AX,BLOCK_END		       ;;					;AN000;
     MOV  [BP+DI].DISP_MODE_LIST_PTR,AX;; Start mode list at end of new block	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,DISP		       ;; Indicate DISPLAYMODE found		;AN000;
  AND  STMTS_DONE,NOT (BOX+GR+SET+REST) ;; Reset flags for PRINTBOX, GRAPHICS	;AN000;
				       ;;  stmts found				;AN000;
  AND  GROUPS_DONE,NOT (GR+SET+REST)   ;; Reset flags for GRAPHICS, SETUP,	;AN000;
				       ;;  RESTORE groups processed		;AN000;
  MOV  DI,OFFSET DISPMODE_PARSE_PARMS  ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
   .IF <AX EQ 0>		       ;; If mode is valid			;AN000;
	  PUSH AX		       ;;					;AN000;
	  MOV	AX,1		       ;; Add a mode to the list		;AN000;
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,BLOCK_START       ;;					;AN000;
	     INC  [BP+DI].NUM_DISP_MODE   ;; Bump number of modes in list	;AN000;
	     MOV  DI,BLOCK_END	       ;;					;AN000;
	     MOV  AL,RESULT_VAL   ;; Get mode from result buffer		;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store the mode at end of list 	;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID	  ;; Mode is invalid			;AN000;
	  MOV  PARSE_ERROR,YES		  ;;					;AN000;
	  MOV  BUILD_STATE,NO		  ;;					;AN000;
      .ENDIF				  ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1>		       ;;					;AN000;
				       ;;					;AN000;
  RET										;AN000;
				       ;;					;AN000;
PARSE_DISPLAYMODE  ENDP 							;AN000;
										;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_SETUP								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
SETUP_PARSE_PARMS  LABEL WORD	     ;; Parser control blocks			;AN000;
	    DW	 SETUP_P	     ;; 					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
SETUP_P   DB   0,1		    ;; Required, max parms			;AN000;
	    DW	 SETUP_P1	    ;;						;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
SETUP_P1 DW   08000H		    ;; Numeric					;AN000;
	    DW	 0		       ;; nO Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	    ;; Result buffer				;AN000;
	    DW	 SETUP_P1V	    ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
SETUP_P1V    DB   1		    ;; # of value lists 			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,255		       ;; range 0..255				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_SETUP  PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,SET		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;; DISPLAYMODE must preceed this 	;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT GROUPS_DONE AND SET>	       ;; Check for previous group of SETUP	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  stmts				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND SET>	       ;; If first SETUP...			;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AX,BLOCK_END	       ;;					;AN000;
	 MOV  [BP+DI].SETUP_ESC_PTR,AX ;; Set pointer to SETUP seq		;AN000;
	 MOV  [BP+DI].NUM_SETUP_ESC,0  ;; Init sequence size			;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,SET		       ;; Indicate SETUP found			;AN000;
 .IF <PREV_STMT NE SET> THEN	       ;; Terminate any preceeding groups	;AN000;
     MOV  AX,PREV_STMT		       ;;  except for SETUP group		;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET SETUP_PARSE_PARMS     ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
   .IF <AX EQ 0>		       ;; If esc byte is valid			;AN000;
	  PUSH AX		       ;;					;AN000;
	  MOV	AX,1		       ;; Add a byte to the sequence		;AN000;
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,BLOCK_START       ;;					;AN000;
	     INC  [BP+DI].NUM_SETUP_ESC   ;; Bump number of bytes in sequence	;AN000;
	     MOV  DI,BLOCK_END	       ;;					;AN000;
	     MOV  AL,RESULT_VAL  ;; Get esc byte from result buffer		;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store at end of sequence		;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_SETUP  ENDP		    ;;						;AN000;
										;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_RESTORE								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
RESTORE_PARSE_PARMS  LABEL WORD        ;; Parser control blocks 		;AN000;
	    DW	 RESTORE_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
RESTORE_P   DB	 0,1		      ;; Required, max parms			;AN000;
	    DW	 RESTORE_P1	      ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
RESTORE_P1 DW	08000H		      ;; Numeric				;AN000;
	    DW	 0		       ;; nO Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	    ;; Result buffer				;AN000;
	    DW	 RESTORE_P1V	      ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
RESTORE_P1V    DB   1		      ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,255		       ;; range 0..255				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_RESTORE  PROC			 ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,SET		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;; DISPLAYMODE must preceed this 	;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT GROUPS_DONE AND REST>        ;; Check for previous group of RESTORE	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  stmts				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND REST>        ;; If first RESTORE...			;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AX,BLOCK_END	       ;;					;AN000;
	 MOV  [BP+DI].RESTORE_ESC_PTR,AX ;; Set pointer to RESTORE seq		;AN000;
	 MOV  [BP+DI].NUM_RESTORE_ESC,0  ;; Init sequence size			;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,REST		       ;; Indicate RESTORE found		;AN000;
 .IF <PREV_STMT NE REST> THEN		;; Terminate any preceeding groups	;AN000;
     MOV  AX,PREV_STMT		       ;;  except for RESTORE group		;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET RESTORE_PARSE_PARMS	 ;; parse parms 			;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
   .IF <AX EQ 0>		       ;; If esc byte is valid			;AN000;
	  PUSH AX		       ;;					;AN000;
	  MOV	AX,1		       ;; Add a byte to the sequence		;AN000;
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,BLOCK_START       ;;					;AN000;
	     INC  [BP+DI].NUM_RESTORE_ESC   ;; Bump number of bytes in sequence ;AN000;
	     MOV  DI,BLOCK_END	       ;;					;AN000;
	     MOV  AL,RESULT_VAL  ;; Get esc byte from result buffer		;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store at end of sequence		;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_RESTORE  ENDP		      ;;					;AN000;
										;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_PRINTBOX								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
PRINTBOX_PARSE_PARMS  LABEL WORD	;; Parser control blocks		;AN000;
	    DW	 PRINTBOX_P		;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
PRINTBOX_P  DB	 1,4		       ;; Required, max parms			;AN000;
	    DW	 PRINTBOX_P0	       ;; LCD/STD				;AN000;
	    DW	 PRINTBOX_P1	       ;; width 				;AN000;
	    DW	 PRINTBOX_P1	       ;; height				;AN000;
	    DW	 PRINTBOX_P2	       ;; rotate				;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
PRINTBOX_P0  DW   2000H 	       ;; sTRING - display type 		;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 PRINTBOX_P0V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
PRINTBOX_P0V	DB   3			;; # of value lists			;AN000;
	    DB	 0		       ;; # of range numerics			;AN000;
	    DB	 0		       ;; # of discrete numerics		;AN000;
	    DB	 1		       ;; # of strings				;AN000;
	    DB	 1		       ;; tag					;AN000;
PRINTBOX_P0V1 DW   ?		       ;; string				;AN000;
				       ;;					;AN000;
PRINTBOX_P1  DW   8001H 	       ;; Numeric - BOX DIMENSIONS		;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 PRINTBOX_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
PRINTBOX_P1V	DB   1		       ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 1,9		       ;; range 1..9				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PRINTBOX_P2  DW   2001H 	       ;; sTRING - ROTATE PARM			;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 PRINTBOX_P2V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
PRINTBOX_P2V	DB   3			;; # of value lists			;AN000;
	    DB	 0		       ;; # of range numerics			;AN000;
	    DB	 0		       ;; # of discrete numerics		;AN000;
	    DB	 1		       ;; # of strings				;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DW	 ROTATE_STR	       ;; string				;AN000;
ROTATE_STR  DB	 'ROTATE',0            ;;                                       ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PROF_BOX_W  DB	0		       ;; Box width and height extracted from	;AN000;
PROF_BOX_H  DB	0		       ;;  the profile				;AN000;
PRINTBOX_MATCH	     DB  0	       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_PRINTBOX	PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  PRINTBOX_MATCH,NO	       ;; Start out assuming the PRINTBOX ID	;AN000;
  MOV  PROF_BOX_W,0		       ;;  does not match the one requested	;AN000;
  MOV  PROF_BOX_H,0		       ;;					;AN000;
  MOV  CUR_STMT,BOX		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;; DISPLAYMODE must preceed PRINTBOX	;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;; Multiple PRINTBOX stmts may be coded	;AN000;
				       ;;  We must decide if this one		;AN000;
				       ;;   matches the requested display type	;AN000;
				       ;;    If not, ignore the statement	;AN000;
  MOV  DI,OFFSET PRINTBOX_PARSE_PARMS  ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,PRINTBOX_ID_PTR	       ;; Insert requested display type in	;AN000;
  MOV  PRINTBOX_P0V1,AX 	       ;;  parser value list			;AN000;
  CALL SYSPARSE 		       ;; PARSE display type			;AN000;
 .IF <AX EQ 0>			       ;; If ID matches then set this flag.	;AN000;
     MOV  PRINTBOX_MATCH,YES	       ;;					;AN000;
     OR   STMTS_DONE,BOX	       ;; Indicate PRINTBOX found		;AN000;
     MOV  AX,PREV_STMT		       ;; Terminate any preceeding groups	;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE horizontal dimension		;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
     MOV  BL,RESULT_VAL 	       ;;					;AN000;

; \/ ~~mda(005) -----------------------------------------------------------------------
;           Presently a 3,1 printbox is not supported for HP PCL printers, but
;           a 4,1 printbox is supported.  The reason for this is that one byte
;           is printed at a time and only two 3,1 print boxes are placed in
;           the one byte print buffer, leaving two blank bits.  This causes
;           the picture to have blank lines running through it and results in
;           a 4,1 printbox.  Instead of placing only two 3,1 print boxes in 
;           the print buffer, two 3,1 print boxes plus a partial 3,1 printbox
;           should be placed in the print buffer.  Another solution is to
;           make the print buffer be three bytes long, and place eight 3,1 
;           print boxes in the three byte long print buffer.  Since the present
;           implementation results in a faulty 4,1 printbox, we change the 3,1
;           printbox to a 4,1 printbox up front.  So even though we still
;           have a 4,1 printbox, at least we will have an accurate picture.
    .IF <[BP].DATA_TYPE EQ DATA_ROW> AND
    .IF <BL EQ 3>
         MOV BL,4
    .ENDIF
; /\ ~~mda(005) -----------------------------------------------------------------------
              
     MOV  PROF_BOX_W,BL 	       ;; Save in local var			;AN000;
 .ELSE				       ;;					;AN000;
    .IF <AX EQ -1>		       ;;					;AN000;
	JMP  PRINTBOX_DONE	       ;;					;AN000;
    .ELSE			       ;;					;AN000;
	OR  STMT_ERROR,INVALID	       ;;					;AN000;
	MOV PARSE_ERROR,YES	       ;;					;AN000;
	MOV BUILD_STATE,NO	       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE vertical dimension		;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
     MOV  BL,RESULT_VAL 	       ;;					;AN000;
     MOV  PROF_BOX_H,BL 	       ;; Save in local var			;AN000;
 .ELSE				       ;;					;AN000;
    .IF <AX EQ -1>		       ;;					;AN000;
	JMP  SHORT   PRINTBOX_DONE     ;;					;AN000;
    .ELSE			       ;;					;AN000;
	OR  STMT_ERROR,INVALID	       ;;					;AN000;
	MOV PARSE_ERROR,YES	       ;;					;AN000;
	MOV BUILD_STATE,NO	       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; Parse ROTATE parm			;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
    .IF <BUILD_STATE EQ YES> AND       ;;					;AN000;
    .IF <PRINTBOX_MATCH EQ YES>        ;;					;AN000;
	PUSH DI 		       ;;					;AN000;
	MOV  DI,BLOCK_START	       ;;					;AN000;
	OR   [BP+DI].PRINT_OPTIONS,ROTATE ;;					;AN000;
	POP  DI 		       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ELSE				       ;;					;AN000;
    .IF <AX EQ -1>		       ;;					;AN000;
	JMP  SHORT   PRINTBOX_DONE     ;;					;AN000;
    .ELSE			       ;;					;AN000;
	OR  STMT_ERROR,INVALID	       ;;					;AN000;
	MOV PARSE_ERROR,YES	       ;;					;AN000;
	MOV BUILD_STATE,NO	       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; CHECK FOR EXTRA PARMS 		;AN000;
 .IF <AX NE -1> 		    ;;						;AN000;
    OR	STMT_ERROR,INVALID	   ;;						;AN000;
    MOV PARSE_ERROR,YES 	   ;;						;AN000;
    MOV BUILD_STATE,NO		   ;;						;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PRINTBOX_DONE:			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BUILD_STATE EQ YES> AND	    ;; Store the PRINTBOX dimensions		;AN000;
 .IF <PRINTBOX_MATCH EQ YES>	    ;;						;AN000;
     PUSH DI			    ;;	in the DISPLAYMODE block		;AN000;
     MOV  DI,BLOCK_START	    ;;						;AN000;
     MOV  AL,PROF_BOX_W 	    ;;						;AN000;
     MOV  [BP+DI].BOX_WIDTH,AL	    ;;						;AN000;
     MOV  AL,PROF_BOX_H 	    ;;						;AN000;
     MOV  [BP+DI].BOX_HEIGHT,AL     ;;						;AN000;
     POP  DI			    ;;						;AN000;
 .ENDIF 			    ;;						;AN000;
				       ;; If we have a B&W printer then 	;AN000;
				       ;;   load the grey patterns for the	;AN000;
				       ;;    requested print box size.		;AN000;
 .IF <CUR_PRINTER_TYPE EQ BLACK_WHITE> NEAR					;AN000;
				       ;;					;AN000;
    .IF <PROF_BOX_W NE 0> AND NEAR	  ;; Dimensions could also be 0 if the	;AN000;
    .IF <PROF_BOX_H NE 0> NEAR		  ;;  printbox ID does not apply to this;AN000;
					  ;;   displaymode, so don't try for    ;AN000;
					  ;;	a pattern!			;AN000;
	MOV  BX,OFFSET TAB_DIRECTORY	  ;;					;AN000;
	MOV  CL,TAB_DIR_NB_ENTRIES	  ;;					;AN000;
	XOR  CH,CH			  ;;					;AN000;
	MOV  DI,BLOCK_START		  ;;					;AN000;
	MOV  AL,PROF_BOX_W		  ;; Requested box width		;AN000;
	MOV  AH,PROF_BOX_H		  ;; Requested box height		;AN000;
       .REPEAT				  ;;					;AN000;
	  .IF <[BX].BOX_W_PAT EQ AL> AND  ;;					;AN000;
	  .IF <[BX].BOX_H_PAT EQ AH>	  ;;					;AN000;
	     .LEAVE			  ;;					;AN000;
	  .ELSE 			  ;;					;AN000;
	      ADD  BX,SIZE TAB_ENTRY	  ;;					;AN000;
	  .ENDIF			  ;;					;AN000;
       .LOOP				  ;;					;AN000;
       .IF <ZERO CX>			  ;;					;AN000;
	   OR  STMT_ERROR,INVALID	  ;; Unsupported box size		;AN000;
	   MOV PARSE_ERROR,YES		  ;;					;AN000;
	   MOV BUILD_STATE,NO		  ;;					;AN000;
       .ELSE NEAR			  ;; Box size OK - pattern tab found	;AN000;
	  .IF <[BX].TAB_COPY NE -1>	  ;; Pointer is NOT null if the table	;AN000;
	      MOV  AX,[BX].TAB_COPY	  ;;  has already been copied to	;AN000;
					  ;;   the shared data area.		;AN000;
	     .IF <BUILD_STATE EQ YES> AND ;;	Point to the copy.		;AN000;
	     .IF <PRINTBOX_MATCH EQ YES>  ;; Establish pointer to table ONLY	;AN000;
		 MOV  [BP+DI].PATTERN_TAB_PTR,AX ;; if the PB ID matched.	;AN000;
		 MOV  AL,[BX].NB_INT	  ;; Number of table entries (intensitie;AN000;
		 MOV  [BP+DI].NUM_PATTERNS,AL ;;				;AN000;
	     .ENDIF			  ;;					;AN000;
	  .ELSE 			  ;; Otherwise we have to copy it.	;AN000;
	   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
	   ;; Copy the table even if the printbox ID didn't match!              ;AN000;
	   ;; This is a simple way to reserve enough space to allow reloading	;AN000;
	   ;; with a different PRINTBOX ID specified on the command line.	;AN000;
	   ;; This scheme avoids storing					;AN000;
	   ;; duplicate tables but may reserve slightly more space		;AN000;
	   ;; (probably only a hundred bytes or so) than			;AN000;
	   ;; could ever be required.  The optimal solution (too		;AN000;
	   ;; complicated!) would involve keeping running totals for each	;AN000;
	   ;; PRINTBOX ID coded.						;AN000;
	   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
					  ;;					;AN000;
	      MOV  DI,BLOCK_END 	  ;; Copy it onto the end of the	;AN000;
					  ;;  current block			;AN000;
	      MOV  DX,DI		  ;; Save start addr of the copy	;AN000;
	      MOV  [BX].TAB_COPY,DX	  ;; Store ptr to copy in the directory ;AN000;
	      MOV  AX,[BX].TAB_SIZE	  ;;					;AN000;
	      CALL GROW_SHARED_DATA	  ;; Allocate room for the table	;AN000;
	     .IF <BUILD_STATE EQ YES>	  ;;					;AN000;
		 MOV  CX,AX		  ;; Number of bytes to copy		;AN000;
		 PUSH SI		  ;; Save parse pointer 		;AN000;
		 MOV  SI,[BX].TAB_OFFSET  ;; Source pointer			;AN000;
		 ADD  DI,BP		  ;; make DI an absolute pointer (dest) ;AN000;
		 REP  MOVSB		  ;; Move it!				;AN000;
		 POP  SI		  ;;					;AN000;
		.IF <PRINTBOX_MATCH EQ YES>  ;; Establish pointer to table ONLY ;AN000;
		    MOV  DI,BLOCK_START      ;; Establish pointer in DISPLAYMODE;AN000;
		    MOV  [BP+DI].PATTERN_TAB_PTR,DX  ;;  info			;AN000;
		    MOV  AL,[BX].NB_INT      ;; Number of table entries (intens);AN000;
		    MOV  [BP+DI].NUM_PATTERNS,AL ;;				;AN000;
		.ENDIF			     ;; 				;AN000;
	     .ENDIF			  ;;					;AN000;
	  .ENDIF			   ;;					;AN000;
       .ENDIF			       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_PRINTBOX	ENDP								;AN000;
										;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_VERB 								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
VERB_PARSE_PARMS  LABEL WORD	       ;; Parser control blocks to parse verb	;AN000;
	    DW	 VERB_P 	       ;; Parser control blocks to parse verb	;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
VERB_P	    DB	 0,1		       ;; Required, max parms			;AN000;
	    DW	 VERB_P1	       ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
VERB_P1     DW	 2000H		       ;; simple string 			;AN000;
	    DW	 0002H		       ;; Capitalize using character table	;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 VERB_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
VERB_P1V    DB	 3			  ;; # of value lists			;AN000;
	    DB	 0			  ;; # of range numerics		;AN000;
	    DB	 0			  ;; # of discrete numerics		;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Changed the number of strings from 9 to 10 because of the
;               new DEFINE statement.
	    DB	 10			  ;; # of strings			;AN000;
;/\  ~~mda(001) ----------------------------------------------------------
	    DB	 0			  ;; tag: index into verb jump table	;AN000;
	    DW	 PRINTER_STRING 	  ;; string offset			;AN000;
	    DB	 2			  ;; tag				;AN000;
	    DW	 DISPLAYMODE_STRING	  ;; string offset			;AN000;
	    DB	 4			  ;; tag				;AN000;
	    DW	 PRINTBOX_STRING	  ;; string offset			;AN000;
	    DB	 6			  ;; tag				;AN000;
	    DW	 SETUP_STRING		  ;; string offset			;AN000;
	    DB	 8			  ;; tag				;AN000;
	    DW	 RESTORE_STRING 	  ;; string offset			;AN000;
	    DB	 10			  ;; tag				;AN000;
	    DW	 GRAPHICS_STRING	  ;; string offset			;AN000;
	    DB	 12			  ;; tag				;AN000;
	    DW	 COLORPRINT_STRING	  ;; string offset			;AN000;
	    DB	 14			  ;; tag				;AN000;
	    DW	 COLORSELECT_STRING	  ;; string offset			;AN000;
	    DB	 16			  ;; tag				;AN000;
	    DW	 DARKADJUST_STRING	  ;; string offset			;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Added DEFINE_STRING to the value list.
;
            DB   18                       ;; tag
            DW   DEFINE_STRING            ;; string offset
;/\  ~~mda(001) ----------------------------------------------------------
PRINTER_STRING	    DB 'PRINTER',0        ;;                                    ;AN000;
DISPLAYMODE_STRING  DB 'DISPLAYMODE',0    ;;                                    ;AN000;
PRINTBOX_STRING     DB 'PRINTBOX',0       ;;                                    ;AN000;
SETUP_STRING	    DB 'SETUP',0          ;;                                    ;AN000;
RESTORE_STRING	    DB 'RESTORE',0        ;;                                    ;AN000;
GRAPHICS_STRING     DB 'GRAPHICS',0       ;;                                    ;AN000;
COLORPRINT_STRING   DB 'COLORPRINT',0     ;;                                    ;AN000;
COLORSELECT_STRING  DB 'COLORSELECT',0    ;;                                    ;AN000;
DARKADJUST_STRING   DB 'DARKADJUST',0     ;;                                    ;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Added the DEFINE_STRING.
;
DEFINE_STRING       DB 'DEFINE',0         ;;
;/\  ~~mda(001) ----------------------------------------------------------
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_VERB     PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET VERB_PARSE_PARMS      ;; parse parms				;AN000;
  MOV  SI,OFFSET STMT_BUFFER	       ;; the line to parse			;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
  CALL SYSPARSE 		       ;;					;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
    MOV  BL,RESULT_TAG		       ;;					;AN000;
    XOR  BH,BH			       ;; return tag in BX			;AN000;
 .ELSE				       ;;					;AN000;
   .IF <AX NE -1>		       ;; syntax error				;AN000;
      OR  STMT_ERROR,INVALID	       ;; set error flag for caller		;AN000;
   .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  RET										;AN000;
PARSE_VERB     ENDP								;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;

;\/ ~~mda(001)  -----------------------------------------------------------------------
;               This procedure parses the new statement DEFINE in the
;               graphics profile.  The reason for this new statement
;               is to be able to define the new keyword, DATA, as DATA_ROW
;               or DATA_COL.  This is necessary in order to support HP PCL
;               printers since they print in row format and IBM printers
;               print in column format.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;;										
;; Module Name: 								
;;   PARSE_DEFINE								
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
DEFINE_PARSE_PARMS  LABEL WORD         ;; Parser control blocks 		
	    DW	 DEFINE_P	       ;;					
	    DB	 2		       ;; # of lists				
	    DB	 0		       ;; # items in delimeter list		
	    DB	 1		       ;; # items in end-of-line list		
	    DB	 ';'                   ;; ';' used for comments                 
				       ;;					
DEFINE_P    DB   0,1		       ;; Required, max parms.  If have DEFINE	
				       ;; then must have DEFINE DATA,ROW or
				       ;; DEFINE DATA,COLUMN
	    DW	 DEFINE_P1	       ;;					
	    DB	 0		       ;; # Switches				
	    DB	 0		       ;; # keywords				
				       ;;					
DEFINE_P1   DW	 2000H 	       	       ;; simple string				
	    DW	 2		       ;; Capitalize				
	    DW	 RESULT_BUFFER	       ;; Result buffer 			
	    DW	 DEFINE_P1V	       ;; Value list				
	    DB	 0		       ;; Synomyms				
				       ;;					
				       ;;					
DEFINE_P1V  DB   3		       ;; # of value lists			
	    DB	 0		       ;; # of range numerics			
	    DB	 0		       ;; # of discrete numerics		
	    DB	 3		       ;; 3 STRING VALUES			
	    DB	 1		       ;; tag					
	    DW	 DATA_STR	       ;; ptr					
	    DB	 2		       ;; tag					
	    DW	 ROW_STR	       ;; ptr					
	    DB	 3		       ;; tag					
	    DW	 COL_STR	       ;; ptr					
				       ;;					
DATA_STR    DB  'DATA',0               ;;                                       
ROW_STR     DB  'ROW',0                ;;                                       
COL_STR     DB  'COLUMN',0             ;;                                       
				       ;;					
				       ;;					
ROW_FOUND	 DB  NO 	       ;;					
COL_FOUND        DB  NO 	       ;; Assume column until told otherwise	
DATA_FOUND	 DB  NO		       ;;
				       ;;					
				       ;;					
PARSE_DEFINE	PROC		       ;;					
				       ;;					
  MOV  CUR_STMT,DEF		       ;; 					
 .IF <BIT STMTS_DONE NAND PRT>         ;; If no preceeding PRT stmt		
     OR   STMT_ERROR,MISSING	       ;; then issue error			
     MOV  PARSE_ERROR,YES	       ;;					
     MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
                                       ;;
 .IF <BIT STMTS_DONE AND DISP>	       ;; DISPLAYMODE stmts			
     OR   STMT_ERROR,SEQUENCE	       ;; should NOT have been processed	
     MOV  PARSE_ERROR,YES	       ;;					
     MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
                                       ;;
 .IF <BIT STMTS_DONE AND DEF>	       ;; If another DEF stmt within in this
     OR   STMT_ERROR,INVALID           ;; PTD then issue error			
     MOV  PARSE_ERROR,YES	       ;;					
     MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
				       ;;					
				       ;;					
  MOV  ROW_FOUND,NO	               ;; Flags to indicate whether the ROW,	
  MOV  COL_FOUND,NO		       ;; COLUMN, or DATA parms were found.  	
  MOV  DATA_FOUND,NO                   ;;
				       ;;					
  OR   STMTS_DONE,DEF		       ;; Indicate DEFINE found			
				       ;;					
  MOV  DI,OFFSET DEFINE_PARSE_PARMS    ;; parse parms				
				       ;; SI => the line to parse		
  XOR  DX,DX			       ;;					
 .REPEAT			       ;;					
    XOR  CX,CX			       ;;					
    CALL SYSPARSE		       ;;					
				       ;;					
   .IF <AX EQ 0> NEAR		       ;; If PARM is valid			
	MOV  BL,RESULT_TAG	       ;;					
       .SELECT			       ;;					
       .WHEN <BL EQ 1>		       ;; DATA string				
	   CMP DATA_FOUND,NO           ;; .IF <DATA_FOUND EQ NO> ... .ELSE ...  
	   JNE DATA_ERROR	       ;; Not using .IF macro because jump is 
	   MOV DATA_FOUND,YES	       ;; out of range.
	   JMP CONT_PARSE              ;;
DATA_ERROR:                            ;;
	   OR  STMT_ERROR,INVALID      ;; Duplicate DATA parms			
	   MOV  PARSE_ERROR,YES        ;;					
	   MOV  BUILD_STATE,NO         ;;					
	                               ;;
       .WHEN <BL EQ 2>		       ;; ROW					
	  .IF <ROW_FOUND EQ NO> AND    ;;					
	  .IF <COL_FOUND EQ NO>        ;;					
	       MOV   ROW_FOUND,YES     ;;					
              .IF <BUILD_STATE EQ YES> ;; ~~mda(002) If this is the DEFINE stmt we're using
	           MOV  [BP].DATA_TYPE,DATA_ROW ;; Set DATA_TYPE to DATA_ROW. 	
              .ENDIF
	  .ELSE 		       ;;					
	       OR  STMT_ERROR,INVALID  ;; Duplicate ROW parms or combo of	
				       ;; parms ROW and COLUMN
	       MOV  PARSE_ERROR,YES    ;;					
	       MOV  BUILD_STATE,NO     ;;					
	  .ENDIF		       ;;					
                                       ;;
       .WHEN <BL EQ 3>		       ;; COLUMN				
	  .IF <COL_FOUND EQ NO> AND    ;;					
	  .IF <ROW_FOUND EQ NO>        ;;					
	       MOV   COL_FOUND,YES     ;;					
              .IF <BUILD_STATE EQ YES> ;; ~~mda(002) If this is the DEFINE stmt we're using
     	           MOV  [BP].DATA_TYPE,DATA_COL	;; Set DATA_TYPE to DATA_COL. 	
              .ENDIF                   ;;
	  .ELSE 		       ;;					
	       OR  STMT_ERROR,INVALID  ;; Duplicate COLUMN parms or combo of	
				       ;; parms COLUMN and ROW
	       MOV  PARSE_ERROR,YES    ;;					
	       MOV  BUILD_STATE,NO     ;;					
	  .ENDIF		       ;;					
       .ENDSELECT		       ;;					
   .ELSE NEAR			       ;;					
      .IF <AX NE -1>		       ;;					
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			
	  MOV  PARSE_ERROR,YES	       ;;					
	  MOV  BUILD_STATE,NO	       ;;					
      .ENDIF			       ;;					
   .ENDIF			       ;;					
CONT_PARSE:                            ;;
 .UNTIL <AX EQ -1> NEAR 	       ;;					
				       ;;					
 .IF  <DATA_FOUND EQ NO>               ;; Missing DATA parm			
      OR   STMT_ERROR,INVALID	       ;;					
      MOV  PARSE_ERROR,YES	       ;;					
      MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
                                       ;;
                                       ;;
 .IF  <ROW_FOUND EQ NO> AND	       ;; Missing ROW or COLUMN parm		
 .IF  <COL_FOUND EQ NO>                ;;
      OR   STMT_ERROR,INVALID	       ;;					
      MOV  PARSE_ERROR,YES	       ;;					
      MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
				       ;;					
  RET				       ;;					
				       ;;					
PARSE_DEFINE	ENDP		       ;;					
				       ;;					
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;/\ ~~mda(001)  -----------------------------------------------------------------------
										;AN000;
LIMIT	LABEL NEAR		       ;;					;AN000;
CODE	ENDS			       ;;					;AN000;
	END									;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\grparse.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Profile Load Modules #2 
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                
;;										;AN000;
;; File Name:  GRLOAD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;   This file contains the modules used to load the				;AN000;
;;   GRAPHICS profile into resident memory.					;AN000;
;;										;AN000;
;;   ************* The EGA Dynamic Save Area will be built (by			;AN000;
;;   **  NOTE	** CHAIN_INTERRUPTS in file GRINST.ASM) over top of these	;AN000;
;;   ************* modules to avoid having to relocate this save just before	;AN000;
;;   terminating.  This is safe since the maximum memory used is		;AN000;
;;   288 bytes and the profile loading modules are MUCH larger than		;AN000;
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		;AN000;
;;   GRPRINT.ASM.								;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 LOAD_PROFILE - Main module for profile loading 			;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 ?????????? - Externals for profile loading modules			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       ;AN000;
				       ;;					;AN000;
	INCLUDE STRUC.INC	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set assemble switches for parse code that is not required!!			;AN000;
;-------------------------------------------------------------------------------;AN000;
DateSW	      EQU     0 							;AN000;
TimeSW	      EQU     0 							;AN000;
CmpxSW	      EQU     0 							;AN000;
DrvSW	      EQU     0 							;AN000;
QusSW	      EQU     0 							;AN000;
KeySW	      EQU     0 							;AN000;
;Val1SW        EQU     0							;AN000;
;Val2SW        EQU     0							;AN000;

	include version.inc										;AN000;
       PUBLIC  SYSPARSE 	       ;;					;AN000;
       INCLUDE PARSE.ASM	       ;; parser code				;AN000;
				       ;;					;AN000;
CODE	ENDS			       ;;					;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\grint2fh.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Interrupt 2FH Driver		;AN000;
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                             
;;										;AN000;
;; File Name:  GRINT2FH.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the Interrupt 2FH driver.				;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 INT_2FH_DRIVER - Interrupt 2FH driver					;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 GRLOAD.EXT - Externals for profile load				;AN000;
;;	 GRCTRL.EXT - Externals for print screen control			;AN000;
;;	 GRPRINT.EXT - Externals for print modules				;AN000;
;;	 GRCPSD.EXT - Externals for COPY_SHARED_DATA module			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 Calls next Int 2FH handler in the chain.				;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:	
;; ---------------
;;	M001	NSM 	1/30/91	  New int 10 handler to trap alt-prt-sc select
;;				   calls made by ANSI.SYS. For these calls, we
;;				   we need to reinstall our int 5 handler again
;;	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       ;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
	PUBLIC	OLD_INT_2FH	       ;;					;AN000;
	PUBLIC	INT_2FH_DRIVER	       ;;					;AN000;
	PUBLIC	INT_10H_DRIVER	       ;;					;AN000;
	PUBLIC	PRT_SCR_2FH_NUMBER     ;;					;AN000;
	PUBLIC	RESIDENT_CODE_SEG      ;;					;AN000;
	PUBLIC	SHARED_DATA_AREA_PTR   ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
.XLIST										;AN000;
INCLUDE STRUC.INC								;AN000;
INCLUDE GRINST.EXT								;AN000;
INCLUDE GRCTRL.EXT								;AN000;
INCLUDE GRCPSD.EXT								;AN000;
.LIST										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module: INT_2FH_DRIVER							;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;     Respond to GRAPHICS Int 2FH calls.					;AN000;
;;     The following calls are handled: 					;AN000;
;;										;AN000;
;;	AL = 0  Install Check							;AN000;
;;										;AN000;
;; Invoked By:									;AN000;
;;     INT 2FH instruction.							;AN000;
;;										;AN000;
;; Modules Called:								;AN000;
;;     Lower level INT 2FH handlers.						;AN000;
;;										;AN000;
;; Input Registers:								;AN000;
;;     Install Check - AH=ACH  AL=0						;AN000;
;;										;AN000;
;;										;AN000;
;; Output Registers:								;AN000;
;;     Install Check:  IF GRAPHICS installed					;AN000;
;;			  AH=FFH  AL=FFH					;AN000;
;;			  ES : DI points to Shared Data Area			;AN000;
;;		       ELSE							;AN000;
;;			  AH=ACH  AL=0						;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;     IF AH=ACH THEN								;AN000;
;;	  IF AL=0 THEN								;AN000;
;;	     AH,AL := -1							;AN000;
;;	     ES : DI := SHARED_DATA_AREA_PTR					;AN000;
;;	  ENDIF 								;AN000;
;;	  IRET									;AN000;
;;     ELSE									;AN000;
;;	  IF OLD_INT_2FH is a valid pointer THEN				;AN000;
;;	      Jump to Old Int 2FH						;AN000;
;;	  ELSE									;AN000;
;;	      IRET								;AN000;
;;	  ENDIF 								;AN000;
;;     ENDIF									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
INT_2FH_DRIVER	PROC  NEAR							;AN000;
	JMP	SHORT	INT_2FH 							;AN000;
PRT_SCR_2FH_NUMBER EQU	       0ACH	; 2FH Multiplex interrupt number	;AN000;
					;  assigned to Print Screen.		;AN000;
OLD_INT_2FH	DD    ? 		; Pointer to next 2FH interrupt handler ;AN000;
RESIDENT_CODE_SEG	DW   ?	; Segment for installed stuff			;AN000;
SHARED_DATA_AREA_PTR	DW   ?	; Offset of the start of the			;AN000;
				;  Shared Data Area				;AN000;
										;AN000;
INT_2FH:									;AN000;
;-------------------------------------------------------------------------------;AN000;
; Verify if the 2FH Interrupt call is for our interrupt handler:		;AN000;
;-------------------------------------------------------------------------------;AN000;
       .IF <AH EQ PRT_SCR_2FH_NUMBER> AND;If 2FH call is for us 		;AN000;
       .IF <ZERO AL>			;  and request is "Get install state"   ;AN000;
       .THEN				; then, 				;AN000;
;-------------------------------------------------------------------------------;AN000;
; Yes: return results								;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	DI,CS:SHARED_DATA_AREA_PTR ;  ES:DI :=	Pointer to shared	;AN000;
	PUSH	CS:RESIDENT_CODE_SEG	   ;		 data area		;AN000;
	POP	ES			;					;AN000;
	MOV	AH,0FFH 		; AL and AH := "We are installed"       ;AN000;
	MOV	AL,AH			;					;AN000;
	IRET				; Return to interrupted process 	;AN000;
;-------------------------------------------------------------------------------;AN000;
; No, pass control to next 2FH interrupt handler:				;AN000;
;-------------------------------------------------------------------------------;AN000;
       .ELSE				; else, this call is not for us:	;AN000;
	 .IF <<WORD PTR CS:OLD_INT_2FH> NE 0> AND ;if there is another		;AN000;
	 .IF <<WORD PTR CS:OLD_INT_2FH+2> NE 0> ;  2FH driver			;AN000;
	 .THEN				;	below us then,			;AN000;
	    JMP CS:OLD_INT_2FH		;	  pass control to it		;AN000;
	 .ELSE				;	else, there is nobody to pass	;AN000;
	    IRET			;	  control to, just return.	;AN000;
	 .ENDIF 			;     END If there is a driver below us.;AN000;
      .ENDIF				;  END If this call is for us.		;AN000;
INT_2FH_DRIVER	ENDP								;AN000;
										;AN000;

;/*M001 BEGIN */
;========================================================================
; INT_10h_Driver :
;    int 10 handler to check for alt-prt-sc-select calls (ah=12,bl=20h)
;    Other int 10 calls are passed on. For alt-prt-sc-select calls,
;    old int 10 is called and after return, we reinstall our int 5 (prt_sc)
;    vector back again ( if it was changed by ANSI.SYS).
;=======================================================================
INT_10H_DRIVER	PROC	NEAR

	sti 					; restore interrupts
	cmp	ah,ALTERNATE_SELECT		; see if the call is for
	jnz	go_old_int10			; alt_prt_sc; if so
	cmp	bl,ALT_PRT_SC_SELECT		; call int 10 and then
	jz	Set_Our_Int5_handler		; restore out PRT_SC vector
go_old_int10:						; other int 10 calls
	jmp	DWORD PTR cs:OLD_INT_10H		; ...pass it on.

; the call is for alternate prt Screen int 10
; call the old int 10 handler and then restore our int 5 vector back again

Set_Our_Int5_handler:
	pushf
	call	DWORD PTR cs:OLD_INT_10H	; call the prev.int 10 handler
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	ds
	xor	ax,ax		
	mov	ds,ax			; ds-> 0 to get at int.vector table
	mov	si,5 * 4		; ds:si  -> ptr to int 5 vector
	mov	cx,cs		
	mov	dx,offset PRT_SCR

	cli
	mov	ax,ds:[si+2]		; segment for current int 5 vector
	cmp	ax,cx			; is it changed by ROM BIOS
	je	no_int5_chg		
	mov	bx,ds:[si]		
	cmp	bx, dx	;further sanity check  for offset
	je	no_int5_chg		

; cx:dx = our int 5 handler
; ax:bx = current int 5 handler
; store the current int 5 handler as the old handler and install ourselves
; again	

	mov	ds:[si],dx		; store offset
	mov	ds:[si+2],cx		; store segment
	mov	CS:[BIOS_INT_5H],bx	; store old int5 vector
	mov	CS:[BIOS_INT_5H +2],ax

no_int5_chg:
	sti
	pop	ds
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax

	iret

INT_10H_DRIVER	ENDP

; /* M001 END */

CODE   ENDS									;AN000;
       END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\grparms.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Command line parsing module	;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                   
;;										;AN000;
;; File Name:  GRPARMS.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;										;AN000;
;;	 This file contains modules for parsing the GRAPHICS.COM		;AN000;
;;	 command line; using the DOS PARSER.					;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;	 DOS 3.3 Message Retriever Interface Supplement. 			;AN000;
;;	 TUPPER I0 Document - PARSER HIGH LEVEL DESIGN REVIEW			;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 PARSE_PARMS	  - Parse the command line				;AN000;
;;	 GET_R		  - Get /R						;AN000;
;;	 GET_B		  - Get /B						;AN000;
;;	 GET_LCD	  - Get /LCD						;AN000;
;;	 GET_PRINTBOX	  - Get /PRINTBOX					;AN000;
;;	 GET_PROFILE	  - Get the profile path and file name			;AN000;
;;	 GET_TYPE	  - Get the printer type				;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 GRINST.EXT  - Externals for installation modules			;AN000;
;;	 GRPARSE.EXT - Externals for the DOS parser code			;AN000;
;;	 GRSHAR.STR  - Shared Data Area Structure				;AN000;
;;	 GRMSG.EQU   - Equates for GRAPHICS.COM error messages			;AN000;
;;	 STRUC.INC   - Macros for using structured assembly language		;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRINST.ASM: 						;AN000;
;;	      GRAPHICS_INSTALL - Main module for the installation of GRAPHICS	;AN000;
;;	 SYSPARSE - DOS system parser						;AN000;
;;	 SYSDISPMSG - DOS message retriever					;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'                                                   ;AN000;
	ASSUME	CS:CODE,DS:CODE 						;AN000;

PARSE_PARMS PROC NEAR								;AN000;
	jmp	PARSE_PARMS_START						;AN000;
PUBLIC PARSE_PARMS								;AN000;

	EXTRN	ERROR_DEVICE: WORD	; grinst.asm

.XLIST										;AN000;
INCLUDE GRMSG.EQU		; Include GRAPHICS error messages equates	;AN000;
INCLUDE GRSHAR.STR		; Include the Shared data area structure	;AN000;
INCLUDE GRINST.EXT		; Include externals for the installation module ;AN000;
INCLUDE GRPARSE.EXT		; Include externals for the DOS parse code	;AN000;
INCLUDE STRUC.INC		; Include macros for using STRUCTURES		;AN000;
.LIST										;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PARSE_PARMS : PARSE THE COMMAND LINE PARAMETERS.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	DS,ES		= SEGMENT CONTAINING THE PROGRAM PREFIX SEGMENT ;AN000;(PSP)
;										;AN000;
;	OUTPUT: SWITCHES	= A bit mask in the shared data area indicating ;AN000;
;				  which command line switches are set.		;AN000;
;		PROFILE_PATH	= The profile file name and path (ASCIIZ string);AN000;
;		PRINTBOX_ID_PTR = Offset of the printbox id (ASCIIZ string)	;AN000;
;		PRINTER_TYPE_PARM = printer type (ASCIIZ string)		;AN000;
;		CARRY FLAG IS SET if an error occurred				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Call the DOS parser to parse the command line parameters 	;AN000;
; of the GRAPHICS  command line which is obtained from the PSP (Program Segment ;AN000;
; Prefix).									;AN000;
;										;AN000;
; The format of the command line is:						;AN000;
;										;AN000;
;										;AN000;
;	GRAPHICS  {prt_type {profile}}	 {/R}  {/B}  {[/LCD | /PRINTBOX:id]}	;AN000;
;										;AN000;
;	(All arguments are optional, /PRINTBOX can be spelled /PB.)		;AN000;
;										;AN000;
; If no printer type is specified then, a null pointer is returned.		;AN000;
; If no profile name is supplied then, a null string is returned.		;AN000;
; If "/LCD" is specified then, a pointer to the printbox id: "LCD" is returned. ;AN000;
;										;AN000;
;										;AN000;
; LOGIC:									;AN000;
; Set addressibility to the command line parameters in the PSP			;AN000;
; CALL SYSPARSE       ; Call the system parser					;AN000;
; While not (End Of Line) AND no error						;AN000;
;   IF argument is the profile name						;AN000;
;   THEN Get the profile name							;AN000;
;   IF argument is the printbox switch						;AN000;
;   THEN Get the printbox id							;AN000;
;   IF argument is a /r 							;AN000;
;   THEN Get /r 								;AN000;
;   IF argument is /b								;AN000;
;   THEN Get /b 								;AN000;
;   IF argument /lcd								;AN000;
;   THEN Get /lcd								;AN000;
;   CALL SYSPARSE								;AN000;
; If error									;AN000;
; Then display the appropriate error message					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; BIT MASK INDICATING THE COMMAND LINE SWITCHES PARSED SO FAR:			;AN000;
;-------------------------------------------------------------------------------;AN000;
SWITCH_PARSED DB   0								;AN000;
GOT_R	      EQU  1			; Found /R				;AN000;
GOT_B	      EQU  2			; Found /B				;AN000;
GOT_LCD       EQU  4			; Found /LCD				;AN000;
GOT_PRINTBOX  EQU  8			; Found /PB:id or /PRINTBOX:id		;AN000;
										;AN000;
;===============================================================================;AN000;
;										;AN000;
; CONTROL BLOCK DEFINITIONS FOR THE PARSER:					;AN000;
;										;AN000;
;===============================================================================;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; PARMS INPUT BLOCK								;AN000;
;-------------------------------------------------------------------------------;AN000;
PARMS LABEL WORD								;AN000;
	DW	PARMSX			; Offset of parms extension block	;AN000;
	DB	0			; No delimiters to define		;AN000;
					;  or end of line markers.		;AN000;
										;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; PARMS EXTENSION BLOCK : Describe what's on the command line                   ;AN000;
;-------------------------------------------------------------------------------;AN000;
PARMSX	LABEL BYTE								;AN000;
	DB	0,2			; Max. 2 positional parameters		;AN000;
	DW	TYPE_CTL		; Offset of type control block		;AN000;
	DW	PROF_CTL		; Offset of profile control block	;AN000;
										;AN000;
	DB	5			; Max. 4 switch types			;AN000;
	DW	PRINTBOX_CTL		; Offset of control for Printbox	;AN000;
	DW	R_CTL			; Offset of control for /R		;AN000;
	DW	B_CTL			; Offset of control for /B		;AN000;
	DW	LCD_CTL 		; Offset of control for /LCD		;AN000;
	DW	?_CTL                   ; offset of control for /?
										;AN000;
	DB	0			; No keywords				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the printer type parameter:						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
TYPE_CTL LABEL	WORD								;AN000;
	DW	2001H		 ; Optional simple string			;AN000;
	DW	0002H		 ; Capitalize it				;AN000;
	DW	TYPE_RESULT	 ; Offset of result buffer for printer type	;AN000;
	DW	NO_VALUES	 ; No values (NOTE: The type returned is checked;AN000;
	DB	0		 ;		   for validity by LOAD_PROFILE);AN000;
										;AN000;
NO_VALUES	DB	0							;AN000;
										;AN000;
TYPE_RESULT	LABEL BYTE							;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Pointer to string found			;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of the PROFILE parameter: 				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
										;AN000;
PROF_CTL LABEL WORD								;AN000;
	DW	0201H		; File spec. - Optional 			;AN000;
	DW	0001h		; Capitalize					;AN000;
	DW	PROFILE_RESULT	; Offset of result buffer for Profile		;AN000;
	DW	NO_VALUES	; No values needed				;AN000;
	DB	0								;AN000;
										;AN000;
										;AN000;
PROFILE_RESULT	LABEL BYTE							;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of string				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of /R							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
R_CTL	LABEL WORD								;AN000;
	DW	0		;						;AN000;
	DW	0		;						;AN000;
	DW	R_RESULT	; Offset of result buffer for a simple switch	;AN000;
	DW	NO_VALUES	; No values can be given with these switches.	;AN000;
	DB	1		; 1 name for this switch			;AN000;
	DB	"/R",0          ;   Reverse                                     ;AN000;
										;AN000;
R_RESULT LABEL BYTE								;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;

;----------------------------------------------------------------------------
;			
; Describe the format of /?
;			
;----------------------------------------------------------------------------
?_CTL	LABEL WORD								;AN000;
	DW	0		;						;AN000;
	DW	0		;						;AN000;
	DW	?_RESULT	; Offset of result buffer for a simple switch
	DW	NO_VALUES	; No values can be given with these switches.
	DB	1		; 1 name for this switch	
	DB	"/?",0   
										;AN000;
?_RESULT LABEL BYTE								;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;

;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of /B							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
B_CTL	LABEL WORD								;AN000;
	DW	0		;						;AN000;
	DW	0		;						;AN000;
	DW	B_RESULT	; Offset of result buffer for a simple switch	;AN000;
	DW	NO_VALUES	; No values can be given with these switches.	;AN000;
	DB	1		; 1 name allowed for this switch		;AN000;
	DB	"/B",0          ;   Background                                  ;AN000;
										;AN000;
B_RESULT LABEL BYTE								;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of /LCD							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
LCD_CTL LABEL WORD								;AN000;
	DW	0		;						;AN000;
	DW	0		;						;AN000;
	DW	LCD_RESULT	; Offset of result buffer for a /LCD		;AN000;
	DW	NO_VALUES	; No values can be given with these switches.	;AN000;
	DB	1		; 1 name:					;AN000;
	DB	"/LCD",0        ;  /LCD                                         ;AN000;
										;AN000;
LCD_RESULT  LABEL BYTE								;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of the PRINTBOX switch:					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINTBOX_CTL LABEL WORD 							;AN000;
	DW	2001H		; Optional simple string			;AN000;
	DW	0001H		; Capitalize					;AN000;
	DW	PRINTBOX_RESULT ; Offset of result buffer for Printbox		;AN000;
	DW	NO_VALUES	; Values will be validated when loading profile ;AN000;
	DB	2		; 2 synomym for this switch:			;AN000;
	DB	"/PRINTBOX",0   ;                                               ;AN000;
	DB	"/PB",0                                                         ;AN000;
										;AN000;
PRINTBOX_RESULT LABEL BYTE							;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;
										;AN000;
;===============================================================================;AN000;
;										;AN000;
; DOS "MESSAGE RETRIEVER" Substitution list control block:                      ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
SUBLIST        LABEL DWORD		   ; List for substitution:		;AN000;
	       DB	11		   ; Size of this list			;AN000;
	       DB	0		   ; Reserved				;AN000;
SAVE_SI        DD	?		   ; Ptr to data item			;AN001;
	       DB	1		   ; Variable to be substitued: %1	;AN000;
	       DB	00010000B	   ; %1 is an ASCIIZ string left justifi;AN000;ed
	       DB	0		   ; Unlimited size for %1		;AN000;
	       DB	1		   ; Minimum size is 1 character	;AN000;
	       DB	" "                ; Delimiter is "space"               ;AN000;
										;AN000;
;===============================================================================;AN000;
;										;AN000;
; START OF EXECUTABLE CODE:							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
										;AN000;
PARSE_PARMS_START:								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
	PUSH	ES								;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set up addressibility for the parser						;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	SI,81H			; DS:SI := Command line parameters	;AN000;
					;  to be parsed 			;AN000;
	PUSH	CS								;AN000;
	POP	ES								;AN000;
	LEA	DI,PARMS		; ES:DI := Parms control block		;AN000;
;(deleted ;AN001;) XOR DX,DX		; CX,DX must be zero for the		;AN000;
	XOR	CX,CX			; Initially, CX should be zero		;AN001;
	MOV	AX,0			; No error yet				;AN000;
;-------------------------------------------------------------------------------;AN000;
; Parse FIRST argument								;AN000;
;-------------------------------------------------------------------------------;AN000;
;(deleted ;AN001;) CALL SYSPARSE	; Get one argument from the command line;AN000;
	CALL	CALL_SYSPARSE		; Get one argument from the command line;AN001;
;(deleted ;AN001;) MOV BX,DX		; BX := Offset of result block		;AN000;
.WHILE <AX EQ RC_NO_ERROR>		; While there is no error		;AN000;
;-------------------------------------------------------------------------------;AN000;
; Get the argument:								;AN000;
;-------------------------------------------------------------------------------;AN000;
       .SELECT									;AN000;
       .WHEN <BX EQ <OFFSET ?_RESULT>>
          MOV	[ERROR_DEVICE], STDOUT       ; output to stdout
	  MOV	AX, MSG_OPTIONS_FIRST        ; number of first 'option' msg
	  XOR	CX, CX                       ; specify no subst
PRMORE:	  CALL  DISP_ERROR                   ; DISP_ERROR is a mistaken name
; in this case.  I use it because it is the existing routine for printing out
; messages, and it is named so because the only messages graphics would 
; display are error messages.  Hence disp_error writes out to STDERR.  I 
; could write another message-display interface to sysdispmsg, but this one 
; works fine, I just wanted to note that the name disp_error gives the wrong
; impression here.
	  INC	AX
	  CMP	AX, MSG_OPTIONS_LAST + 1     ; another msg to do
	  JB	PRMORE
          MOV	[ERROR_DEVICE], STDERR       ; set output back to stderr
	  STC                                ; pretend to have an error so
; that graphics now cleans up and goes home without further action
	  JMP   PPST
       .WHEN <BX EQ <OFFSET TYPE_RESULT>>					;AN000;
	  CALL	GET_TYPE							;AN000;
       .WHEN <BX EQ <OFFSET PROFILE_RESULT>>					;AN000;
	  CALL	GET_PROFILE_NAME						;AN000;
       .WHEN <BX EQ <OFFSET LCD_RESULT >>					;AN000;
	  CALL	GET_LCD 							;AN000;
       .WHEN <BX EQ <OFFSET R_RESULT>>						;AN000;
	  CALL	GET_REVERSE							;AN000;
       .WHEN <BX EQ <OFFSET B_RESULT>>						;AN000;
	  CALL	GET_BACKGROUND							;AN000;
       .WHEN <BX EQ <OFFSET PRINTBOX_RESULT>>					;AN000;
	  CALL	GET_PRINTBOX_ID 						;AN000;
       .OTHERWISE								;AN000;
;-------No result block was returned by the parser				;AN000;
	STC				; Set error				;AN000;
       .ENDSELECT								;AN000;
       .LEAVE C 			; IF error occurred while parsing the	;AN000;
					;  previous argument, exit the loop:	;AN000;
					;   stop parsing the command line.	;AN000;
;-------------------------------------------------------------------------------;AN000;
; Parse next argument:								;AN000;
;-------------------------------------------------------------------------------;AN000;
;(deleted ;AN001;) XOR DX,DX		;					;AN000;
;(deleted ;AN001;) CALL SYSPARSE	; Get one argument from the command line;AN000;
	CALL	CALL_SYSPARSE		; Get one argument from the command line;AN001;
;(deleted ;AN001;) MOV BX,DX		; ES:BX := Offset of result block	;AN000;
.ENDWHILE									;AN000;

;-------------------------------------------------------------------------------;AN000;
; Check for error, select and display an error message				;AN000;
;-------------------------------------------------------------------------------;AN000;
.IF <AL NE RC_EOL>			; IF an error occurred			;AN000;
.THEN					; then, display error message		;AN000;
    MOV 	CX,0			; Assume no substitutions		;AN000;
   .SELECT				; (CX := Number of substitutions	;AN000;
   .WHEN <AL EQ RC_TOO_MANY>		; When RC = Too many parameters 	;AN000;
	MOV	AX,TOO_MANY_PARMS	;   (AL = Message number to display)	;AN000;
   .WHEN <AL EQ RC_Not_In_Val>		; When RC = Not in value list provided	;AN000;
	MOV	AX,VALUE_NOT_ALLOWED	;   (AL = Message number to display)	;AN000;
   .WHEN <AL EQ RC_Not_In_Sw>		; When RC = Not in switch list provided ;AN000;
	MOV	CX,1			;   1 substitution in this message	;AN000;
	MOV	BYTE PTR [SI],0 	; PUT NUL AT END OF THIS PARM		;AN001;
	LEA	SI,SUBLIST		;   DS:[SI]:="Invalid parm" Substitution;AN000; list
;(deleted ;AN001;) LES DX,ES:[BX+4]	;   ES:DX := Offset of offending parm.	;AN000;
;(deleted ;AN001;) MOV [SI]+2,DX	;   Store offset to this offender in the;AN000;
	MOV	[SI]+4,ES		;    substitution list control block	;AN000;
	MOV	AX,INVALID_PARM 	;   AL := 'Invalid parameter' msg number;AN000;
   .WHEN <AL EQ RC_INVLD_COMBINATION>	; When RC = Invalid combination of parms;AN000;
	MOV	AX,INVALID_COMBINATION	;   (AL = Message number to display)	;AN000;
   .WHEN <AL EQ RC_DUPLICATE_PARMS>	; When RC = Invalid combination of parms;AN000;
	MOV	AX,DUPLICATE_PARM	;   (AL = Message number to display)	;AN000;
   .OTHERWISE				;					;AN000;
	MOV	AX,FORMAT_NOT_CORRECT	; RC = Anything else, tell the user	;AN000;
					;	something is wrong with his	;AN000;
   .ENDSELECT				;	 command line.			;AN000;
    CALL DISP_ERROR			; Display the selected error message	;AN000;
    STC 				; Indicate parse error occurred 	;AN000;
.ENDIF										;AN000;
										;AN000;
PPST:	POP	ES								;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET				; Return to GRAPHICS_INSTALL		;AN000;
										;AN000;
PARSE_PARMS ENDP								;AN000;
CALL_SYSPARSE PROC NEAR 		;COMMON INVOCATION OF SYSPARSE		;AN001;
;INPUT: - CX=ORDINAL VALUE							;AN001;
;	  DS:SI=WHERE COMMAND LINE IS, SAVED IN "SAVE_SI"                       ;AN001;
;	  ES:DI=WHERE PARMS DESCRIPTOR BLOCK IS 				;AN001;
;OUTPUT:  CX=NEW ORDINAL VALUE							;AN001;
;	  BX=OFFSET OF RESULT BLOCK, IF ONE IS RETURNED 			;AN001;
;	  SI=OFFSET OF CHAR BEYOND PARSED PARM IN COMMAND LINE			;AN001;
										;AN001;
	XOR	DX,DX			;CLEAR DX FOR PARSER			;AN001;
	MOV	WORD PTR SAVE_SI,SI	;REMEMBER WHERE TO START LOOKING	;AN001;
	CALL	SYSPARSE		;GO PARSE THE NEXT PARM 		;AN001;
										;AN001;
	MOV	BX,DX			; BX := Offset of result block		;AN001;
	RET				;RETURN TO CALLER			;AN001;
CALL_SYSPARSE ENDP								;AN001;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_PROFILE							;AN000;
;										;AN000;
; INPUT:  ES:[BX] := Result block						;AN000;
;										;AN000;
; OUTPUT: PROFILE_PATH = The profile file name and path (ASCIIZ string) 	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_PROFILE_NAME PROC								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	DX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Get the name of the profile path found on the command line:			;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	DI,ES:[BX+4]	; DI := Offset of filename found		;AN000;
	XOR	BX,BX		; BX := Byte index				;AN000;
	MOV	SI,OFFSET PROFILE_PATH	; [BX][SI] := Where to store it 	;AN000;
										;AN000;
.IF <<BYTE PTR [DI]> NE 0>	; Don't copy a NULL parm                        ;AN000;
  .REPEAT			; While not end of path name (NULL terminated)	;AN000;
	MOV	AL,[BX][DI]	; Copy the byte (including the NULL)		;AN000;
	MOV	[BX][SI],AL							;AN000;
	INC	BX		; Get next one					;AN000;
  .UNTIL <<BYTE PTR [BX-1][DI]> EQ 0> ; 					;AN000;
.ENDIF										;AN000;
										;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	DX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	CLC									;AN000;
	RET									;AN000;
GET_PROFILE_NAME ENDP								;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_TYPE							;AN000;
;										;AN000;
; INPUT:  ES:[BX] := Result block						;AN000;
;	  PRINTER_TYPE_LENGTH := Maximum length for the printer type string	;AN000;
;										;AN000;
; OUTPUT: PRINTER_TYPE_PARM = ASCIIZ string containing				;AN000;
;			       the Printer type.				;AN000;
;	  AX		    = Error code					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_TYPE PROC									;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
;---------------------------------------------------------------------- 	;AN000;
; Overwrite the DEFAULT TYPE with the type found on the command line		;AN000;
;---------------------------------------------------------------------- 	;AN000;
  MOV	  SI,ES:[BX+4]		       ; DS:SI := Offset of printer type found	;AN000;
 .IF <<BYTE PTR [SI]> NE 0>	       ; Do not copy an empty string		;AN000;
 .THEN				       ;					;AN000;
    MOV     CL,PRINTER_TYPE_LENGTH     ; CX := Maximum number of bytes		;AN000;
    XOR     CH,CH		       ;	to copy 			;AN000;
    MOV     DI,OFFSET PRINTER_TYPE_PARM; ES:DI := Where to store it		;AN000;
    REP     MOVSB		       ; Copy the string			;AN000;
  ;----------------------------------------------------------------------	;AN000;
  ; Verify that the string supplied is not too long:				;AN000;
  ;----------------------------------------------------------------------	;AN000;
   .IF	<<BYTE PTR [DI-1]> EQ 0>       ; If the last byte is a null		;AN000;
   .THEN			       ; then, the string was not longer	;AN000;
				       ;       than the maximum 		;AN000;
      CLC			       ;   Clear the carry flag = No error	;AN000;
   .ELSE			       ; else, string provided is too long	;AN000;
      MOV  AX,RC_Not_In_Sw	       ;   Error := RC for Invalid parm 	;AN000;
      STC			       ; Set error				;AN000;
   .ENDIF			       ; ENDIF string too long			;AN000;
 .ENDIF 			       ; ENDIF string provided			;AN000;
										;AN000;
GET_TYPE_END:									;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
GET_TYPE  ENDP									;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_REVERSE							;AN000;
;										;AN000;
; INPUT:  ES:[BX]	:= Result block 					;AN000;
;	  SWITCH_PARSED := The command line switches parsed so far (bit mask)	;AN000;
;										;AN000;
; OUTPUT: CS:[BP].SWITCHES (Bit mask in the Shared data area) is updated	;AN000;
;			    with the value of the switch found. 		;AN000;
;	  GOT_R is set in SWITCH_PARSED 					;AN000;
;	  AX		:= Error message number.				;AN000;
;	  CARRY FLAG IS SET IF ERROR FOUND					;AN000;
;										;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_REVERSE	PROC								;AN000;
										;AN000;
	TEST	SWITCH_PARSED,GOT_R		; If already parsed this switch ;AN000;
	JNZ	DUPLICATE_R			; then, error			;AN000;
	OR	SWITCH_PARSED,GOT_R		; else, say we parsed it.	;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set the Reverse switch in the Shared data area				;AN000;
;-------------------------------------------------------------------------------;AN000;
	OR	CS:[BP].SWITCHES,REVERSE_SW	; Set the command line switch	;AN000;
	CLC					; Clear the error flag		;AN000;
	JMP	SHORT GET_REVERSE_END		; Return			;AN000;
										;AN000;
DUPLICATE_R:					; Already got this switch	;AN000;
	MOV	AX,RC_DUPLICATE_PARMS		; AX := error message number	;AN000;
	STC					; SET ERROR			;AN000;
GET_REVERSE_END:								;AN000;
										;AN000;
	RET									;AN000;
GET_REVERSE	ENDP								;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_BACKGROUND						;AN000;
;										;AN000;
; INPUT:  ES:[BX] := Result block						;AN000;
;	  SWITCH_PARSED := The command line switches parsed so far (bit mask)	;AN000;
;										;AN000;
; OUTPUT: CS:[BP].SWITCHES (Bit mask in the Shared data area) is updated	;AN000;
;			    with the value of the switch found. 		;AN000;
;										;AN000;
;	  GOT_B is set in SWITCH_PARSED 					;AN000;
;	  AX		:= Error message number.				;AN000;
;	  CARRY FLAG IS SET IF ERROR FOUND					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_BACKGROUND	PROC								;AN000;
										;AN000;
	TEST	SWITCH_PARSED,GOT_B		; If already parsed this switch ;AN000;
	JNZ	DUPLICATE_B			; then, error			;AN000;
	OR	SWITCH_PARSED,GOT_B		; else, say we parsed it.	;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set the switch in the Shared data area					;AN000;
;-------------------------------------------------------------------------------;AN000;
	OR	CS:[BP].SWITCHES,BACKGROUND_SW	; Set the command line switch	;AN000;
	CLC					; Clear the error flag		;AN000;
	JMP	SHORT GET_BACKGROUND_END	; Return			;AN000;
										;AN000;
DUPLICATE_B:					; Already got this switch	;AN000;
	MOV	AX,RC_DUPLICATE_PARMS		; AX := error message number	;AN000;
	STC					; SET ERROR			;AN000;
										;AN000;
GET_BACKGROUND_END:								;AN000;
	RET									;AN000;
GET_BACKGROUND	ENDP								;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_LCD							;AN000;
;										;AN000;
; INPUT:  SWITCH_PARSED   := The command line switches parsed so far (bit mask) ;AN000;
;										;AN000;
; OUTPUT: PRINTBOX_ID_PTR := Point to /LCD ASCIIZ string.			;AN000;
;	  GOT_B is set in SWITCH_PARSED 					;AN000;
;	  AX		  := Error message number.				;AN000;
;	  CARRY FLAG IS SET IF ERROR FOUND					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Data Referenced:								;AN000;
;										;AN000;
;	  LCD_BOX = An ASCIIZ string representing the LCD printbox id.		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_LCD PROC									;AN000;
										;AN000;
	TEST	SWITCH_PARSED,GOT_LCD	   ; If already parsed this switch	;AN000;
	JNZ	DUPLICATE_LCD		   ; then, error: Duplicate switch	;AN000;
	TEST	SWITCH_PARSED,GOT_PRINTBOX ; If printbox already mentioned	;AN000;
	JNZ	BAD_COMBINATION 	   ; then, error: Invalid combination	;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set the pointer to the print box id to "LCD"                                  ;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	AX,OFFSET LCD_BOX	   ; PRINTBOX id := LCD 		;AN000;
	MOV	PRINTBOX_ID_PTR,AX	   ; Save pointer to this printbox id.	;AN000;
	OR	SWITCH_PARSED,GOT_LCD	   ; Say we found this switch		;AN000;
	CLC				   ; Clear the error flag		;AN000;
	JMP	SHORT GET_LCD_END	   ; Return				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; /LCD was already parsed:							;AN000;
;-------------------------------------------------------------------------------;AN000;
DUPLICATE_LCD:				   ; Already got this switch		;AN000;
	MOV	AX,RC_DUPLICATE_PARMS	   ; AX := error message number 	;AN000;
	STC				   ; SET ERROR				;AN000;
	JMP	SHORT GET_LCD_END	   ; Return				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; /PRINTBOX was already parsed: 						;AN000;
;-------------------------------------------------------------------------------;AN000;
BAD_COMBINATION:			   ; /LCD and /PRINTBOX invalid at same ;AN000;
	MOV	AX,RC_INVLD_COMBINATION    ;  time, Set the error flag		;AN000;
	STC				   ;   AX := Error code 		;AN000;
										;AN000;
GET_LCD_END:									;AN000;
	RET									;AN000;
GET_LCD 	ENDP								;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_PRINTBOX							;AN000;
;										;AN000;
; INPUT:  ES:[BX]	:= Result block 					;AN000;
;	  SWITCH_PARSED := The command line switches parsed so far (bit mask)	;AN000;
;										;AN000;
; OUTPUT: DEFAULT_BOX	:= Is overwritten to contain the printbox id. found on	;AN000;
;			    the command line.					;AN000;
;	  GOT_PRINTBOX is set in SWITCH_PARSED					;AN000;
;	  AX		:= Error message number.				;AN000;
;	  CARRY FLAG IS SET IF ERROR FOUND					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_PRINTBOX_ID PROC								;AN000;
										;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Test for error in the printbox statement:					;AN000;
;-------------------------------------------------------------------------------;AN000;
	TEST	SWITCH_PARSED,GOT_LCD	    ; If /LCD	  already mentioned	;AN000;
	JNZ	BAD_COMBINATION2	    ; then, error: Invalid combination	;AN000;
	TEST	SWITCH_PARSED,GOT_PRINTBOX  ; If already parsed this switch	;AN000;
	JNZ	DUPLICATE_PRINTBOX	    ; then, error: Duplicate switch	;AN000;
										;AN000;
	MOV	DI,ES:[BX+4]		    ; DI := Offset of switch VALUE found;AN000;
										;AN000;
       .IF <<BYTE PTR [DI]> EQ 0>	    ; IF no printbox id 		;AN000;
       .THEN				    ; then,				;AN000;
	 ;----------------------------------------------------------------------;AN000;
	 ; No printbox id. was found:						;AN000;
	 ;----------------------------------------------------------------------;AN000;
	  MOV	  AX,FORMAT_NOT_CORRECT     ;	AX := Error code		;AN000;
	  STC				    ;	Set the error flag		;AN000;
       .ELSE				    ; else,				;AN000;
	  OR	  SWITCH_PARSED,GOT_PRINTBOX;	Say we found this switch	;AN000;
	 ;----------------------------------------------------------------------;AN000;
	 ; Overwrite DEFAULT_BOX with the Printbox id. found			;AN000;
	 ;----------------------------------------------------------------------;AN000;
	  MOV	  CL,PRINTBOX_ID_LENGTH     ;	  CX := Maximum number of bytes ;AN000;
	  XOR	  CH,CH 		    ;		 to copy		;AN000;
	  MOV	  SI,DI 		    ;	  [DS][SI] :=  Value found	;AN000;
	  MOV	  DI,OFFSET DEFAULT_BOX     ;	  [ES][DI] :=  Default value	;AN000;
	  REP	  MOVSB 		    ;	  Copy the string		;AN000;
	 ;----------------------------------------------------------------------;AN000;
	 ; Verify that the Printbox id. string is not too long: 		;AN000;
	 ;----------------------------------------------------------------------;AN000;
	 .IF  <<BYTE PTR [DI-1]> EQ 0>	    ; If the last byte is a null	;AN000;
	 .THEN				    ; then, the string was not longer	;AN000;
					    ;	    than the maximum		;AN000;
	    CLC 			    ;	Clear the carry flag = No error ;AN000;
	 .ELSE				    ; else, string provided is too long ;AN000;
	    MOV  AX,RC_Not_In_Sw	    ;	Error := RC for Invalid parm	;AN000;
	    STC 			    ; Set error 			;AN000;
	 .ENDIF 			    ; ENDIF printbox id. too long	;AN000;
       .ENDIF				    ; ENDIF printbox id. provided	;AN000;
										;AN000;
	JMP	SHORT GET_PRINTBOX_END	    ; Return				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; /PRINTBOX was already parsed: 						;AN000;
;-------------------------------------------------------------------------------;AN000;
DUPLICATE_PRINTBOX:			    ; Already got this switch		;AN000;
	MOV	AX,RC_DUPLICATE_PARMS	    ; AX := error message number	;AN000;
	STC				    ; SET ERROR 			;AN000;
	JMP	SHORT GET_PRINTBOX_END	    ; Return				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; /LCD was already parsed:							;AN000;
;-------------------------------------------------------------------------------;AN000;
BAD_COMBINATION2:			    ; /LCD and /PRINTBOX invalid at same;AN000;
	MOV	AX,RC_INVLD_COMBINATION     ;  time, Set the error flag 	;AN000;
	STC				    ;	AX := Error code		;AN000;
										;AN000;
GET_PRINTBOX_END:								;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	RET									;AN000;
GET_PRINTBOX_ID ENDP								;AN000;
										;AN000;
CODE  ENDS									;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\grload.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:  I added an entry in the VERB_JMP_TAB and the equate DEF to 
;**                handle the new statement DEFINE.  I also made the new variable
;**                DATA_TYPE have the default of DATA_COL in the procedure
;**                LOAD_PROFILE, so the default assumes IBM type printers.
;**  
;**  DOCUMENTATION NOTES:  This version of GRLOAD.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Profile Load Modules		;AN000;
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                     
;;										;AN000;
;; File Name:  GRLOAD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;   This file contains the modules used to load the				;AN000;
;;   GRAPHICS profile into resident memory.					;AN000;
;;										;AN000;
;;   ************* The EGA Dynamic Save Area will be built (by			;AN000;
;;   **  NOTE	** CHAIN_INTERRUPTS in file GRINST.ASM) over top of these	;AN000;
;;   ************* modules to avoid having to relocate this save just before	;AN000;
;;   terminating.  This is safe since the maximum memory used is		;AN000;
;;   288 bytes and the profile loading modules are MUCH larger than		;AN000;
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		;AN000;
;;   GRPRINT.ASM.								;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 LOAD_PROFILE - Main module for profile loading 			;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 ?????????? - Externals for profile loading modules			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE' BYTE     ;;                                       ;AN000;
				       ;;					;AN000;
	INCLUDE STRUC.INC	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;; Bring in external declarations	;AN000;
				       ;;  for transient command processing	;AN000;
	INCLUDE GRSHAR.STR	       ;;					;AN000;
	INCLUDE GRPARSE.EXT	       ;;					;AN000;
	INCLUDE GRLOAD2.EXT	       ;;					;AN000;
	INCLUDE GRLOAD3.EXT	       ;;					;AN000;
	INCLUDE GRMSG.EQU	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   PUBLIC  LOAD_PROFILE 							;AN000;
   PUBLIC  GROW_SHARED_DATA							;AN000;
   PUBLIC  BLOCK_START								;AN000;
   PUBLIC  BLOCK_END								;AN000;
   PUBLIC  FIRST_BLOCK								;AN000;
   PUBLIC  MAX_BLOCK_END							;AN000;
   PUBLIC  GROUPS_DONE								;AN000;
   PUBLIC  STMTS_DONE								;AN000;
   PUBLIC  STMTS_DONE								;AN000;
   PUBLIC  PTD_FOUND								;AN000;
   PUBLIC  BUILD_STATE								;AN000;
   PUBLIC  STMT_ERROR								;AN000;
   PUBLIC  FILE_ERROR								;AN000;
   PUBLIC  PARSE_ERROR								;AN000;
   PUBLIC  END_OF_FILE								;AN000;
   PUBLIC  MEM_OVERFLOW 							;AN000;
   PUBLIC  STMT_BUFFER								;AN000;
   PUBLIC  CUR_STMT								;AN000;
   PUBLIC  PREV_STMT								;AN000;
   PUBLIC  PRT_BOX_ERROR							;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Profile Load Variables							;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
NO	      EQU   0		       ;;					;AN000;
YES	      EQU   1		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   LOAD_PROFILE								;AN000;
;;										;AN000;
;; Input Parameters:								;AN000;
;;   DS,ES,SS - points to our transient segment 				;AN000;
;;										;AN000;
;; Output Parameters:								;AN000;
;;   Temporary Shared Data Area 						;AN000;
;;   Carry flag set if errors in profile.					;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;   Shared Data Area								;AN000;
;;   Profile Load Variables							;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Build the profile information in the Temporary Shared Data Area.		;AN000;
;;   The information will be built for the printer type parsed off		;AN000;
;;   the command line.	ALL Printer Type Descriptions will be			;AN000;
;;   parsed to issue error messages and determine the maximum			;AN000;
;;   amount of resident memory required for initial load.			;AN000;
;;   The Shared Data Area begins with a fixed length section			;AN000;
;;   and then has several variable length sections.  PROFILE_BUILD_PTR		;AN000;
;;   is used to build the variable length sections by serving			;AN000;
;;   as a running pointer to the sections as they are built.			;AN000;
;;										;AN000;
;; Register Usage:								;AN000;
;;   BP - points to beginning of Temp Shared Data				;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   GRAPHICS_INSTALL								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   PARSE_PRINTER, PARSE_DISPLAYMODE, PARSE_SETUP, PARSE_RESTORE		;AN000;
;;   PARSE_PRINTBOX, PARSE_GRAPHICS, PARSE_COLORSELECT, 			;AN000;
;;   PARSE_COLORPRINT, GET_STATEMENT						;AN000;
;;   SYSPARSE									;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   IF profile path not specified  THEN					;AN000;
;;	PROFILE_PATH := "GRAPHICS.PRO"  /* Current directory */                 ;AN000;
;;	Open profile using PROFILE_PATH 					;AN000;
;;	IF error during open THEN						;AN000;
;;	   PROFILE_PATH := ARG(V0) with "GRAPHICS.COM" replaced                 ;AN000;
;;	     by "GRAPHICS.PRO"                                                  ;AN000;
;;	   Open profile using PROFILE_PATH					;AN000;
;;	   IF error during open THEN						;AN000;
;;	      Issue "Cannot find profile" msg                                   ;AN000;
;;	      Set carry flag							;AN000;
;;	      RETURN								;AN000;
;;	   ENDIF								;AN000;
;;	ENDIF									;AN000;
;;   ELSE									;AN000;
;;	Open profile using specified path					;AN000;
;;	IF error during open THEN						;AN000;
;;	   Issue "Cannot find profile" msg                                      ;AN000;
;;	   Set carry flag							;AN000;
;;	   RETURN								;AN000;
;;	ENDIF									;AN000;
;;   ENDIF									;AN000;
;;   /* don't start building until we find our printer type*/                   ;AN000;
;;   PARSE_MODE := NOBUILD							;AN000;
;;   MAX_BUILD_PTR := 0 							;AN000;
;;   CALL GROW_SHARED_DATA(PROFILE-BUILD_PTR,size of FIXED PART 		;AN000;
;;     of Shared Data Area)							;AN000;
;;   WHILE (not end of file) AND (no I/O error) DO				;AN000;
;;	CALL GET_STATEMENT							;AN000;
;;	IF I/O error THEN							;AN000;
;;	   Issue error message							;AN000;
;;	ELSE									;AN000;
;;	   CALL SYSPARSE to parse the statement verb				;AN000;
;;	   IF verb found THEN							;AN000;
;;	      IF invalid verb THEN						;AN000;
;;		 Issue error message						;AN000;
;;		 PARSE_MODE := ERROR						;AN000;
;;	      ELSE								;AN000;
;;		 CASE statement verb						;AN000;
;;		    PRINTER:							;AN000;
;;		       CALL PARSE_PRINTER					;AN000;
;;		    DISPLAYMODE:						;AN000;
;;		       CALL PARSE_DISPLAYMODE					;AN000;
;;		    PRINTBOX:							;AN000;
;;		       CALL PARSE_PRINTBOX					;AN000;
;;		    SETUP:							;AN000;
;;		       CALL PARSE_SETUP 					;AN000;
;;		    RESTORE:							;AN000;
;;		       CALL PARSE_RESTORE					;AN000;
;;		    GRAPHICS:							;AN000;
;;		       CALL PARSE_GRAPHICS					;AN000;
;;		    COLORPRINT: 						;AN000;
;;		       CALL PARSE_COLORPRINT					;AN000;
;;		    COLORSELECT:						;AN000;
;;		       CALL PARSE_COLORSELECT					;AN000;
;;		 ENDCASE							;AN000;
;;		 IF error on statement THEN					;AN000;
;;		    IF OVERFLOW bit set in RETURN_CODE THEN			;AN000;
;;		       Issue "Insufficient memory" message                      ;AN000;
;;		       RETURN to caller 					;AN000;
;;		    ELSE							;AN000;
;;		       IF MISSING bit set in RETURN_CODE THEN			;AN000;
;;			  Issue "required statement missing" message            ;AN000;
;;		       ENDIF							;AN000;
;;		       IF INVALID bit set in RETURN_CODE THEN			;AN000;
;;			  Issue "statement invalid" message                     ;AN000;
;;		       ENDIF							;AN000;
;;		       IF SEQUENCE bit set in RETURN_CODE THEN			;AN000;
;;			  Issue "out of sequence" message                       ;AN000;
;;		       ENDIF							;AN000;
;;		       display the statement in error				;AN000;
;;		    ENDIF							;AN000;
;;		    PARSE_MODE := ERROR 					;AN000;
;;		 ENDIF								;AN000;
;;	      ENDIF								;AN000;
;;	   ENDIF								;AN000;
;;	ENDIF									;AN000;
;;   ENDWHILE									;AN000;
;;										;AN000;
;;   /* Check length of last PTD */						;AN000;
;;   IF PROFILE_BUILD_PTR > MAX_BUILD_PTR THEN					;AN000;
;;	MAX_BUILD_PTR := PROFILE_BUILD_PTR					;AN000;
;;   ENDIF									;AN000;
;;										;AN000;
;;   /* Make sure all required statements were in previous */			;AN000;
;;   /* Printer Type Description */						;AN000;
;;   /* Must have completed PRINTER, DISPLAYMODE, PRINTBOX and */		;AN000;
;;   /* GRAPHICS statements */							;AN000;
;;   IF PRT+DISP+BOX+GR bits not all set in STMTS_DONE THEN			;AN000;
;;	Issue "required statement missing" message                              ;AN000;
;;	Display "END OF FILE."                                                  ;AN000;
;;   ENDIF									;AN000;
;;										;AN000;
;;   IF errors during build THEN						;AN000;
;;	set carry flag								;AN000;
;;   ELSE									;AN000;
;;	SD_TOTAL_SIZE := MAX_BUILD_PTR - TEMP_SHARED_DATA_PTR			;AN000;
;;   ENDIF									;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
FILE_NOT_FOUND	EQU  2		       ;; DOS Int21H error codes		;AN000;
PATH_NOT_FOUND	EQU  3		       ;;					;AN000;
				       ;;					;AN000;
SUBLIST     LABEL  BYTE 	       ;; Message substituion list for stmt #	;AN000;
	    DB	11		       ;; sublist size				;AN000;
	    DB	0		       ;;					;AN000;
	    DW	STMT_NUM	       ;; \ Dword pointer to item		;AN000;
SUBLIST_SEG DW	?		       ;; /					;AN000;
	    DB	1		       ;; Substitution #			;AN000;
;; Flag format	a0sstttt	       ;;					;AN000;
	    DB	00100001B	       ;; Unsigned binary word - left align	;AN000;
;;;;	    DB	00000000B	       ;; charcater				;AN000;
	    DB	0		       ;; max field width			;AN000;
	    DB	1		       ;; min width width			;AN000;
	    DB	' '                    ;; pad characeter                        ;AN000;
				       ;;					;AN000;
STMT_NUM    DW	0		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
FILE_ERROR  DB	0		       ;; Error opening or reading PROFILE	;AN000;
PARSE_ERROR DB	0		       ;; Syntax errors in PROFILE		;AN000;
END_OF_FILE	DB  0		       ;; 1 if end of file			;AN000;
MEM_OVERFLOW  DB  0		       ;; 1 if insufficient memory		;AN000;
				       ;;					;AN000;
STMT_ERROR  DB	0		       ;; Error flag for individual stmt errors ;AN000;
MISSING     EQU 1		       ;; Required statement missing		;AN000;
INVALID     EQU 2		       ;; Invalid statement format		;AN000;
SEQUENCE    EQU 4		       ;; Statement out of sequence		;AN000;
				       ;;					;AN000;
DEFAULT_PATH	  DB "GRAPHICS.PRO",0  ;;                                       ;AN000;
BUFFER	    DB	64 DUP("$")            ;;                                       ;AN000;
				       ;;					;AN000;
HANDLE	    DW	0		       ;; Profile handle			;AN000;
				       ;;					;AN000;
BUILD_STATE DB	0		       ;; 1 if we are currently building	;AN000;
				       ;;  data.  0 means syntax checking	;AN000;
				       ;;   only				;AN000;
				       ;;					;AN000;
				       ;; Keep track of whether this PTD	;AN000;
				       ;;  matches the type requested		;AN000;
PTD_FOUND   DB	0		       ;; Values are NO (0), YES (1) and	;AN000;
PROCESSED   EQU 2		       ;;  PROCESSED (2)			;AN000;
				       ;;					;AN000;
VERB	    DB	0		       ;; PTR into VERB_JMP_TAB 		;AN000;
				       ;;					;AN000;
VERB_JMP_TAB  LABEL WORD	       ;;					;AN000;
	DW  OFFSET PARSE_PRINTER       ;;					;AN000;
	DW  OFFSET PARSE_DISPLAYMODE   ;;					;AN000;
	DW  OFFSET PARSE_PRINTBOX      ;;					;AN000;
	DW  OFFSET PARSE_SETUP	       ;;					;AN000;
	DW  OFFSET PARSE_RESTORE       ;;					;AN000;
	DW  OFFSET PARSE_GRAPHICS      ;;					;AN000;
	DW  OFFSET PARSE_COLORPRINT    ;;					;AN000;
	DW  OFFSET PARSE_COLORSELECT   ;;					;AN000;
	DW  OFFSET PARSE_DARKADJUST    ;;					;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Added the following so that LOAD_PROFILE will parse the
;               DEFINE statement.
;
        DW  OFFSET PARSE_DEFINE         ;
;/\  ~~mda(001) ----------------------------------------------------------
				       ;;					;AN000;
STMTS_DONE   DW  0		       ;;					;AN000;
GROUPS_DONE  DW  0		       ;;					;AN000;
PREV_STMT    DW  0		       ;;					;AN000;
CUR_STMT     DW  0		       ;;					;AN000;
				       ;;					;AN000;
PRT	EQU  1			       ;; Bit masks for STMTS_DONE and		;AN000;
DISP	EQU  2			       ;;  GROUPS_DONE.  There is one		;AN000;
BOX	EQU  4			       ;;   bit for each statement except	;AN000;
GR	EQU  8			       ;;    DARKADJUST 			;AN000;
SET	EQU  10H		       ;;					;AN000;
REST	EQU  20H		       ;;					;AN000;
COLS	EQU  40H		       ;;					;AN000;
COLP	EQU  80H		       ;;					;AN000;
DARK	EQU  100H		       ;;					;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Added the following for the DEFINE statement.
;
DEF     EQU  200H
;/\  ~~mda(001) ----------------------------------------------------------
				       ;;					;AN000;
BLOCK_START  DW  ?		       ;; Extents of the variable size block	;AN000;
BLOCK_END    DW  ?		       ;;  currently being built		;AN000;
				       ;; These are relative to the		;AN000;
				       ;;  start of the Shared Data Area	;AN000;
				       ;;   so the area can be relocated	;AN000;
MAX_BLOCK_END	DW  0		       ;; End of largest PTD contained		;AN000;
				       ;;  in profile				;AN000;
FIRST_BLOCK  DW  ?		       ;; Pointer to first variable block	;AN000;
				       ;;  (end of fixed part)			;AN000;
PRT_BOX_ERROR  DB  0		       ;;					;AN000;
				       ;;					;AN000;
LOAD_PROFILE  PROC NEAR 	       ;;					;AN000;
				       ;;					;AN000;
  PUSH	CS			       ;;					;AN000;
  POP	SUBLIST_SEG		       ;; setup segment for message sublist	;AN000;
				       ;;					;AN000;
  CALL OPEN_FILE		       ;;					;AN000;
 .IF <FILE_ERROR EQ YES>	       ;; Check for error during open		;AN000;
     STC			       ;;					;AN000;
     RET			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  BP,TEMP_SHARED_DATA_PTR	       ;; BP points to START of Shared Data	;AN000;
  MOV  AX,SIZE SHARED_DATA_AREA_STR    ;; size of fixed part of Shared Data	;AN000;
  MOV  BLOCK_END,0		       ;; Initialize BLOCK_START,BLOCK_END	;AN000;
  MOV  [BP].DARKADJUST_VALUE,0	       ;; Init some values in the fixed 	;AN000;
  MOV  [BP].NUM_PRT_COLOR,0	       ;;  area 				;AN000;
  MOV  [BP].COLORPRINT_PTR,-1	       ;;					;AN000;
  MOV  [BP].NUM_PRT_BANDS,0	       ;;					;AN000;
  MOV  [BP].COLORSELECT_PTR,-1	       ;;					;AN000;
  MOV  [BP].PRINTER_TYPE,BLACK_WHITE   ;;					;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Make the default DATA_TYPE be DATA_COL for the IBM printers.
;
  MOV [BP].DATA_TYPE,DATA_COL           ;
;/\  ~~mda(001) ----------------------------------------------------------
  CALL GROW_SHARED_DATA 	       ;;  to the first byte after the		;AN000;
				       ;;   fixed part of Shared Data		;AN000;
     MOV  AX,BLOCK_END		       ;; Variable size data will be built	;AN000;
     MOV  BLOCK_START,AX	       ;;  starting at BLOCK_START		;AN000;
     MOV  FIRST_BLOCK,AX	       ;; Save start of variable data		;AN000;
				       ;;					;AN000;
     MOV  SI,BUFFER_PTR 	       ;; Set up SI for GET_BYTE		;AN000;
     CALL GET_BYTE		       ;; Get first byte from file		;AN000;
     MOV  NEXT_BYTE,AL		       ;;  and store it 			;AN000;
     MOV  BUFFER_PTR,SI 	       ;; Save SI for next GET_BYTE		;AN000;
    .WHILE <END_OF_FILE EQ NO> AND     ;; Keep parsing until end of file or	;AN000;
    .WHILE <FILE_ERROR EQ NO>	       ;;  file error occurs			;AN000;
       MOV STMT_ERROR,0 	       ;; Clear parse error flags		;AN000;
       CALL GET_STATEMENT	       ;; Get next profile statement		;AN000;
       INC  STMT_NUM		       ;;					;AN000;
      .IF NC			       ;; Carry flag set if get unsuccessful	;AN000;
	  CALL PARSE_VERB	       ;; Index into verb jump table returned	;AN000;
				       ;;  in BX				;AN000;
	 .IF <AX EQ 0> THEN	       ;; AX=0 if there is a recognized 	;AN000;
	    MOV  AX,CUR_STMT	       ;;					;AN000;
	    MOV  PREV_STMT,AX	       ;; Save last statement verb		;AN000;
	    CALL VERB_JMP_TAB[BX]      ;;  statement to parse			;AN000;
	 .ELSEIF <AX NE -1> THEN       ;;					;AN000;
	    OR	 STMT_ERROR,INVALID    ;;					;AN000;
	    MOV  PARSE_ERROR,YES       ;;					;AN000;
	    MOV  BUILD_STATE,NO        ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	 .IF <STMT_ERROR NE 0>	       ;; An error was detected 		;AN000;
	    CALL SHOW_PARSE_ERROR      ;;					;AN000;
	    MOV PARSE_ERROR,YES        ;;					;AN000;
	    MOV STMT_ERROR,0	       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
    .ENDWHILE			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE  AND PRT>	       ;; Must have at least one PRINTER	;AN000;
     CALL TERMINATE_DISPLAYMODE        ;; Terminate the last PRINTER and	;AN000;
     CALL TERMINATE_PRINTER	       ;;  DISPLAYMODE sections 		;AN000;
 .ELSE				       ;;					;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
 .IF <STMT_ERROR NE 0>		       ;;					;AN000;
     CALL  SHOW_PARSE_ERROR	       ;; Issue Profile syntax messages 	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,3E00H 		       ;; Close the file			;AN000;
  MOV  BX,HANDLE		       ;;					;AN000;
  INT  21H			       ;;					;AN000;
				       ;;					;AN000;
 .IF <PARSE_ERROR EQ YES>	       ;;					;AN000;
      MOV  AX,SYNTAX_ERRORS	       ;; Issue "Syntax errors found in         ;AN000;
      MOV  CX,0 		       ;;  profile" message.                    ;AN000;
      CALL DISP_ERROR		       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <PTD_FOUND EQ NO>		       ;; Did we find the requested printer	;AN000;
      MOV  AX,INVALID_PRT	       ;;  type?  If not issue error		;AN000;
      MOV  CX,0 		       ;;  message.				;AN000;
      CALL DISP_ERROR		       ;;					;AN000;
      MOV  PARSE_ERROR,YES	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <PARSE_ERROR EQ YES> OR	       ;;					;AN000;
 .IF <PRT_BOX_ERROR EQ YES> OR	       ;;					;AN000;
 .IF <FILE_ERROR EQ YES>	       ;; Set carry flag if profile load	;AN000;
     STC			       ;;  was unsuccessful			;AN000;
 .ELSE				       ;;					;AN000;
    .IF <MEM_OVERFLOW EQ YES>	       ;; Everthing else was OK BUT we ran	;AN000;
	.IF <INSTALLED EQ YES>	       ;;  out of memory!!!			;AN000;
	    MOV   AX,NB_FREE_BYTES     ;;					;AN000;
	   .IF <AX LT RESIDENT_SHARED_DATA_SIZE>				;AN000;
	       MOV   AX,NO_MEMORY      ;; We ran out of physical memory!	;AN000;
	   .ELSE		       ;;					;AN000;
	       MOV   AX,UNABLE_RELOAD  ;; Allocated shared data is too small	;AN000;
	   .ENDIF		       ;;					;AN000;
	.ELSE			       ;;					;AN000;
	    MOV   AX,NO_MEMORY	       ;; We ran out of physical memory 	;AN000;
	.ENDIF			       ;;					;AN000;
	 MOV   CX,0		       ;;					;AN000;
	 CALL  DISP_ERROR	       ;;					;AN000;
	 STC			       ;; Indicate unsuccessful 		;AN000;
    .ELSE			       ;;					;AN000;
	 MOV  AX,MAX_BLOCK_END	       ;; Extent of largest PRINTER section	;AN000;
	 MOV  [BP].SD_TOTAL_SIZE,AX    ;;  we parsed.				;AN000;
	 CLC			       ;; SUCCESSFUL LOAD!!!!			;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
LOAD_PROFILE  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   SHOW_PARSE_ERROR								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
CARRAIGE_RET   EQU  13		       ;;					;AN000;
LINE_FEED      EQU  10		       ;;					;AN000;
				       ;;					;AN000;
SHOW_PARSE_ERROR   PROC 	       ;;					;AN000;
				       ;;					;AN000;
  MOV  ERROR_DEVICE,STDOUT	       ;; profile syntax messages to STDOUT	;AN000;
				       ;;					;AN000;
 .IF <BIT STMT_ERROR AND MISSING>						;AN000;
    PUSH SI		    ;;							;AN000;
    MOV  AX,MISSING_STMT    ;;							;AN000;
    MOV  CX,1		    ;;							;AN000;
    MOV  SI,OFFSET SUBLIST  ;;							;AN000;
    CALL DISP_ERROR	    ;;							;AN000;
    POP  SI		    ;;							;AN000;
 .ENDIF 		    ;;							;AN000;
 .IF <BIT STMT_ERROR AND INVALID>						;AN000;
    PUSH SI		    ;;							;AN000;
    MOV  AX,INVALID_STMT    ;;							;AN000;
    MOV  CX,1									;AN000;
    MOV  SI,OFFSET SUBLIST  ;;							;AN000;
    CALL DISP_ERROR	    ;;							;AN000;
    POP  SI		    ;;							;AN000;
 .ENDIF 		    ;;							;AN000;
 .IF <BIT STMT_ERROR AND SEQUENCE>						;AN000;
    PUSH SI		    ;;							;AN000;
    MOV  AX,OUT_SEQ_STMT    ;;							;AN000;
    MOV  CX,1									;AN000;
    MOV  SI,OFFSET SUBLIST  ;;							;AN000;
    CALL DISP_ERROR	    ;;							;AN000;
    POP  SI		    ;;							;AN000;
 .ENDIF 		    ;;	                                                ;AN000;
				       ;;					;AN000;
  MOV  DI,STMT_END_INDEX  ;;							;AN000;
  MOV  STMT_BUFFER[DI],'$'           ;; For display                             ;AN000;
  MOV  AH,9			     ;; 					;AN000;
  MOV  DX,OFFSET STMT_BUFFER							;AN000;
  INT  21H			     ;; 					;AN000;
  MOV  DL,CARRIAGE_RET		     ;; 					;AN000;
  MOV  AH,2			     ;; 					;AN000;
  INT  21H			     ;; 					;AN000;
  MOV  DL,LINE_FEED		     ;; 					;AN000;
  MOV  AH,2			     ;; 					;AN000;
  INT  21H			     ;; 					;AN000;
				       ;;					;AN000;
  MOV  ERROR_DEVICE,STDERR	       ;; reset to STDERR			;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
SHOW_PARSE_ERROR   ENDP 	       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   OPEN_FILE									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
OPEN_FILE     PROC NEAR 	       ;;					;AN000;
				       ;;					;AN000;
 .IF <PROFILE_PATH NE 0>	       ;; If a path was specified then		;AN000;
     MOV  DX,OFFSET PROFILE_PATH       ;;  try and open it			;AN000;
     MOV  AX,3D00H		       ;;					;AN000;
     INT  21H			       ;; Open it				;AN000;
    .IF C			       ;; Open error if carry flag set		;AN000;
       .IF <AX EQ FILE_NOT_FOUND> OR   ;; Check for error other than		;AN000;
       .IF <AX EQ PATH_NOT_FOUND>      ;;  file not found			;AN000;
	   MOV	 AX,PROFILE_NOT_FOUND  ;;					;AN000;
	   MOV	 CX,0		       ;;					;AN000;
	   CALL  DISP_ERROR	       ;; Issue "File not found" common msg     ;AN000;
	   MOV	 FILE_ERROR,YES        ;;					;AN000;
       .ELSE			       ;;					;AN000;
	   CALL  FILE_ERROR_PROC       ;; Issue "Open error"                    ;AN000;
       .ENDIF			       ;;					;AN000;
    .ELSE			       ;;					;AN000;
	MOV  HANDLE,AX		       ;;					;AN000;
    .ENDIF			       ;; File opened OK			;AN000;
 .ELSE				       ;; No path parameter			;AN000;
     MOV  DX,OFFSET DEFAULT_PATH       ;; Try and open "GRAPHICS.PRO"           ;AN000;
     MOV  AX,3D00H		       ;;					;AN000;
     INT  21H			       ;; Open it				;AN000;
    .IF C			       ;; Open error if carry flag set		;AN000;
       .IF <AX EQ FILE_NOT_FOUND> OR   ;; Check for file not found error	;AN000;
       .IF <AX EQ PATH_NOT_FOUND>      ;;					;AN000;
	   CALL COPY_ARGV0	       ;;					;AN000;
	   MOV	DX,OFFSET PROFILE_PATH ;; Try and open "GRAPHICS.PRO" in        ;AN000;
	   MOV	AX,3D00H	       ;;  ARGV0 directory			;AN000;
	   INT	21H		       ;;					;AN000;
	  .IF C 		       ;; Issue "File not found" common msg     ;AN000;
	     .IF <AX EQ FILE_NOT_FOUND> OR					;AN000;
	     .IF <AX EQ PATH_NOT_FOUND> 					;AN000;
		 MOV   AX,PROFILE_NOT_FOUND  ;; 				;AN000;
		 MOV   CX,0		     ;; 				;AN000;
		 CALL  DISP_ERROR	     ;; Issue "File not found"common MSG;AN000;
		 MOV   FILE_ERROR,YES	     ;; 				;AN000;
	     .ELSE		       ;;					;AN000;
		 CALL  FILE_ERROR_PROC ;; Issue "Open error"                    ;AN000;
	     .ENDIF		       ;;					;AN000;
	  .ELSE 		       ;;					;AN000;
	      MOV  HANDLE,AX	       ;;					;AN000;
	  .ENDIF		       ;; File opened OK			;AN000;
       .ELSE			       ;;					;AN000;
	   CALL  FILE_ERROR_PROC       ;; Issue "Open error"                    ;AN000;
       .ENDIF			       ;;					;AN000;
    .ELSE			       ;;					;AN000;
	MOV  HANDLE,AX		       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
OPEN_FILE     ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   COPY_ARGV0 								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
COPY_ARGV0  PROC		       ;;					;AN000;
				       ;;					;AN000;
  PUSH	 ES			       ;;					;AN000;
  PUSH	 DI			       ;;					;AN000;
  PUSH	 SI			       ;;					;AN000;
				       ;;					;AN000;
  MOV	 DI,2CH 		       ;; Locate environment string		;AN000;
  MOV	 ES,[DI]		       ;;					;AN000;
  XOR	 SI,SI			       ;;					;AN000;
  .WHILE <<WORD PTR ES:[SI]> NE 0>     ;;					;AN000;
     INC   SI			       ;;					;AN000;
  .ENDWHILE			       ;;					;AN000;
  ADD	 SI,4			       ;;					;AN000;
  LEA	 DI,PROFILE_PATH	       ;; Move string to work area		;AN000;
  .REPEAT			       ;;					;AN000;
     MOV    AL,ES:[SI]		       ;;					;AN000;
     MOV    [DI],AL		       ;;					;AN000;
     INC    SI			       ;;					;AN000;
     INC    DI			       ;;					;AN000;
  .UNTIL <<BYTE PTR ES:[SI]> EQ 0>     ;;					;AN000;
  MOV	 BYTE PTR [DI],0	       ;;					;AN000;
  MOV	 BYTE PTR [DI]-3,"P"           ;; Change COM to PRO                     ;AN000;
  MOV	 BYTE PTR [DI]-2,"R"           ;;                                       ;AN000;
  MOV	 BYTE PTR [DI]-1,"O"           ;;                                       ;AN000;
				       ;;					;AN000;
  POP	    SI			       ;;					;AN000;
  POP	    DI			       ;;					;AN000;
  POP	    ES			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
COPY_ARGV0  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   FILE_ERROR_PROC								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
FILE_ERROR_PROC  PROC		       ;;					;AN000;
  MOV	AX,FILE_ERRORS		       ;;					;AN000;
  MOV	CX,0			       ;;					;AN000;
  CALL	DISP_ERROR		       ;;					;AN000;
  MOV	FILE_ERROR,YES		       ;;					;AN000;
  RET				       ;;					;AN000;
FILE_ERROR_PROC  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   GET_STATEMENT								;AN000;
;;										;AN000;
;; Input Parameters:								;AN000;
;;   NONE									;AN000;
;;										;AN000;
;; Output Parameters:								;AN000;
;;   PROFILE_LINE								;AN000;
;;   RETURN CODE : 0 - successfull read 					;AN000;
;;		 : 1 - end of file						;AN000;
;;		 : 2 - error during read					;AN000;
;;										;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Get a statement from the profile.						;AN000;
;;   The file read in 512 byte buffers and parsed into				;AN000;
;;   lines by the presence of a carriage return at the end of each line.	;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   LOAD_PROFILE								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   NONE									;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   FOUND := FALSE								;AN000;
;;   RETURN_CODE := 0								;AN000;
;;   WHILE NOT FOUND DO 							;AN000;
;;	IF end of buffer THEN							;AN000;
;;	   Read next profile record into buffer 				;AN000;
;;	   IF successful read THEN						;AN000;
;;	      point to first byte in buffer					;AN000;
;;	   ELSE 								;AN000;
;;	      IF end of file THEN						;AN000;
;;		 Close profile							;AN000;
;;		 RETURN_CODE := 1						;AN000;
;;		 FOUND := TRUE							;AN000;
;;	      ELSE								;AN000;
;;		 RETURN_CODE := 2						;AN000;
;;		 FOUND := TRUE							;AN000;
;;	      ENDIF								;AN000;
;;	   ENDIF								;AN000;
;;	ENDIF									;AN000;
;;	copy byte to PROFILE_LINE						;AN000;
;;	IF byte in buffer is a CR THEN						;AN000;
;;	   FOUND := TRUE							;AN000;
;;	ENDIF									;AN000;
;;   ENDWHILE									;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
FOUND  DB   0			       ;;					;AN000;
				       ;;					;AN000;
CARRIAGE_RET	EQU 13		       ;;					;AN000;
LINE_FEED	EQU 10		       ;;					;AN000;
NEXT_BYTE	DB  0		       ;; Save area for byte just read		;AN000;
BUFFER_SIZE	EQU 512 	       ;;					;AN000;
FILE_BUFFER	DB  512 DUP(0)	       ;;					;AN000;
BUFFER_PTR	DW  512 	       ;;					;AN000;
BUFFER_END	DW  512 	       ;;					;AN000;
STMT_BUFFER	DB  255 DUP(0)	       ;;					;AN000;
		DB  ?		       ;; In case we have to insert a CR	;AN000;
		DB  ?		       ;;  and a LF				;AN000;
		DB  ?		       ;; Too put the "$" for displaying the    ;AN000;
				       ;;  line.				;AN000;
				       ;;					;AN000;
STMT_END_INDEX	DW  ?		       ;;					;AN000;
MAX_STMT_LEN	EQU 255 	       ;;					;AN000;
CR_FOUND	DB  0		       ;; 1 if we found a line terminator	;AN000;
				       ;;					;AN000;
GET_STATEMENT PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  FOUND,NO 		       ;;					;AN000;
  MOV  STMT_ERROR,0		       ;; Clear error flags			;AN000;
  XOR  DI,DI			       ;; Index for extracted statement 	;AN000;
  MOV  SI,BUFFER_PTR		       ;; Init file buffer ptr			;AN000;
				       ;;					;AN000;
  MOV  AL,NEXT_BYTE		       ;; Restore current byte			;AN000;
  MOV  CR_FOUND,NO		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
 .WHILE <FOUND EQ NO> AND	       ;; Keep parsing until we find a stmt	;AN000;
 .WHILE <FILE_ERROR EQ NO> AND	       ;;  or a file error occurs		;AN000;
 .WHILE <END_OF_FILE EQ NO>	       ;;   or we reach end of file		;AN000;
   .IF <CR_FOUND EQ YES>	       ;;					;AN000;
      .IF <AL EQ LINE_FEED>	       ;; Return the line feed as well		;AN000;
	 .IF <DI NA MAX_STMT_LEN>      ;; Truncate lines longer than MAX	;AN000;
	     MOV  STMT_BUFFER[DI],AL   ;;  MOVE TO statement buffer		;AN000;
	     INC  DI		       ;; Point to next byte in file buffr	;AN000;
	  .ELSE 		       ;;					;AN000;
	      OR   STMT_ERROR,INVALID  ;; Line has been truncated > ERROR	;AN000;
	      MOV  PARSE_ERROR,YES     ;;					;AN000;
	      MOV  BUILD_STATE,NO      ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  CALL GET_BYTE 	       ;; Get the first byte of next statement	;AN000;
      .ENDIF			       ;;					;AN000;
       MOV  FOUND,YES		       ;; Time to leave this WHILE		;AN000;
       MOV  NEXT_BYTE,AL	       ;; Save the byte we just read		;AN000;
   .ELSE			       ;;					;AN000;
      .IF <DI NA MAX_STMT_LEN>	       ;; Truncate lines longer than MAX	;AN000;
	  MOV  STMT_BUFFER[DI],AL      ;; move byte to statement buffer 	;AN000;
	  INC  DI		       ;; Point to next byte in file buffer	;AN000;
      .ELSE			       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; Line has been truncated > ERROR	;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
      .IF <AL EQ CARRIAGE_RET>	       ;; Found a line terminator		;AN000;
	  MOV  CR_FOUND,YES	       ;; Indicate carriage return found	;AN000;
      .ENDIF			       ;;  and go through once more to		;AN000;
       CALL GET_BYTE		       ;;   check for a line feed		;AN000;
   .ENDIF			       ;;					;AN000;
 .ENDWHILE			       ;;					;AN000;
				       ;;					;AN000;
 .IF <STMT_BUFFER[DI-1] NE CARRIAGE_RET> AND		 ;;			;AN000;
 .IF <STMT_BUFFER[DI-1] NE LINE_FEED>		      ;;			;AN000;
     MOV  STMT_BUFFER[DI],CARRIAGE_RET ;;					;AN000;
     MOV  STMT_BUFFER[DI+1],LINE_FEED  ;;					;AN000;
     INC  DI			       ;;					;AN000;
     INC  DI			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  MOV STMT_END_INDEX,DI 	       ;;					;AN000;
  MOV BUFFER_PTR,SI		       ;; Save buffer ptr for next time 	;AN000;
				       ;;					;AN000;
 .IF <END_OF_FILE EQ YES>	       ;;					;AN000;
     .IF <DI EQ 0>		       ;; Clear carry if we read something	;AN000;
	STC			       ;;  and no file error occured otherwise	;AN000;
     .ELSE			       ;;   set carry indicating unsuccessful	;AN000;
	CLC			       ;;    get.				;AN000;
     .ENDIF			       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <FILE_ERROR EQ YES>	       ;;					;AN000;
	 STC			       ;;					;AN000;
     .ELSE			       ;;					;AN000;
	 CLC			       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
GET_STATEMENT ENDP		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   GET_BYTE									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
GET_BYTE      PROC		       ;;					;AN000;
				       ;;					;AN000;
 .IF <SI EQ BUFFER_END> 	       ;; If buffer empty do another read	;AN000;
     MOV  AH,3FH		       ;;					;AN000;
     MOV  DX,OFFSET FILE_BUFFER        ;;					;AN000;
     MOV  CX,BUFFER_SIZE	       ;;					;AN000;
     MOV  BX,HANDLE		       ;;					;AN000;
     INT  21H			       ;;					;AN000;
    .IF C			       ;; Carry set by DOS if file error	;AN000;
	CALL FILE_ERROR_PROC	       ;;					;AN000;
    .ELSE			       ;;					;AN000;
       .IF <AX EQ 0>		       ;; End of file if AX=0			;AN000;
	   MOV	END_OF_FILE,YES        ;;					;AN000;
	   MOV	AH,3EH		       ;; Close the file			;AN000;
	   MOV	BX,HANDLE	       ;;					;AN000;
	   INT	21H		       ;;					;AN000;
       .ELSE			       ;;					;AN000;
	   MOV BUFFER_END,AX	       ;; Number of bytes read			;AN000;
	   XOR SI,SI		       ;; Buffer pointer := 0			;AN000;
       .ENDIF			       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <FILE_ERROR EQ YES> OR	       ;;					;AN000;
 .IF <END_OF_FILE EQ YES>	       ;;					;AN000;
     STC			       ;; Unsuccessful get			;AN000;
 .ELSE				       ;;					;AN000;
    .IF <<FILE_BUFFER[SI]> EQ 1AH>	;; cHECK for EOF marker 		;AN000;
	MOV END_OF_FILE,YES	       ;;					;AN000;
	STC			       ;;					;AN000;
    .ELSE			       ;;					;AN000;
	MOV  AL,FILE_BUFFER[SI] 	  ;; Return byte in AL			;AN000;
	INC  SI 			  ;;					;AN000;
	CLC				  ;; Successful get			;AN000;
    .ENDIF				  ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
GET_BYTE      ENDP		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   GROW_SHARED_DATA								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
GROW_SHARED_DATA  PROC		       ;;					;AN000;
  PUSH BX			       ;;					;AN000;
  ADD  BLOCK_END,AX		       ;; Grow the current block by AX		;AN000;
  MOV  BX,BLOCK_END		       ;;					;AN000;
 .IF <BX A NB_FREE_BYTES>	       ;; Check for overflow			;AN000;
     MOV  BUILD_STATE,NO	       ;; Stop building shared data		;AN000;
     MOV  MEM_OVERFLOW,YES	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  POP  BX			       ;;					;AN000;
  RET				       ;;					;AN000;
GROW_SHARED_DATA  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
CODE	ENDS			       ;;					;AN000;
	END									;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\commsubs.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;;
;; File Name:  CONVERT.INC
;; ----------
;;
;; Root File Name:  KEYBCMD.ASM
;; ---------------
;;
;;
;; Description:
;; ------------
;;       External declarations for procedures in file KEYBCMD.ASM.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    FIND_SYS_TYPE   :NEAR ;;
        EXTRN    FIND_KEYB_TYPE  :NEAR ;;
                                       ;;
        EXTRN    HW_TYPE         :WORD ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\graphics\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

graphics.skl : ..\usa\graphics.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybcmd.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBCMD.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;;
;; Description:
;; ------------
;;       External declarations for procedures in file KEYCMD.ASM.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                              ;;
        EXTRN    KEYB_COMMAND        :NEAR    ;;
                                              ;;
        EXTRN    KEYBSYS_FILE_HANDLE:WORD     ;;
        EXTRN    CP_TAB_OFFSET:DWORD          ;;
        EXTRN    STATE_LOGIC_OFFSET:DWORD     ;;
        EXTRN    SYS_CODE_PAGE:WORD           ;;
        EXTRN    KEYBCMD_LANG_ENTRY_PTR:DWORD ;;
        EXTRN    DESIG_CP_BUFFER:WORD         ;;
        EXTRN    DESIG_CP_OFFSET:WORD         ;;
        EXTRN    NUM_DESIG_CP:WORD            ;;
        EXTRN    TB_RETURN_CODE:WORD          ;;
        EXTRN    FILE_BUFFER:BYTE             ;;
;****************CNS****************************
        EXTRN    ID_PTR_SIZE:WORD             ;;
;****************CNS****************************
        EXTRN    LANG_PTR_SIZE:WORD           ;;
        EXTRN    CP_PTR_SIZE:WORD             ;;
;****************CNS****************************
        EXTRN    NUM_ID:WORD                  ;;
;****************CNS****************************
        EXTRN    NUM_LANG:WORD                ;;
        EXTRN    NUM_CP:WORD                  ;;
        EXTRN    SHARED_AREA_PTR:DWORD        ;;
        EXTRN    SD_SOURCE_PTR:BYTE           ;;
        EXTRN    TEMP_SHARED_DATA:BYTE        ;;
                                              ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\kbmsg.inc ===
;;

;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;

ACT_KEYB    DB	  'Current keyboard code: ','$'                               ;;
ACT_KEYB_CP DB	  '  code page: ','$'                                         ;;
ACT_CON_CP  DB	  'Current CON code page: ','$'                               ;;
INV_L	    DB	  'Invalid keyboard code specified',10,13,'$'                 ;;
INV_I	    DB	  'Invalid keyboard ID specified',10,13,'$'                 ;;
INV_CP	    DB	  'Invalid code page specified',10,13,'$'                     ;;
INV_S	    DB	  'Invalid syntax',10,13,'$'                                  ;;
INV_FN	    DB	  'Bad or missing Keyboard Definition File',10,13,'$'         ;;
INV_KEYB_Q  DB	  'KEYB has not been installed',10,13,'$'                     ;;
INV_CON_Q   DB	  'Active code page not available from CON device',10,13,'$'  ;;
NOT_DESIG   DB	  'Code page specified has not been prepared',10,13,'$'       ;;
NOT_SUPP    DB	  'One or more CON code pages invalid for given keyboard code',10,13,'$' ;;
NOT_VALID1  DB	  'Code page requested (','$'                                 ;;
NOT_VALID2  DB	  ') is not valid for given keyboard code',10,13,'$'               ;;
WARNING_1   DB	  'Code page specified is inconsistent with the selected code page',10,13,'$'  ;;
INV_COMBO   DB	  'ID code specified is inconsistent with the selected keyboard code',13,'$'  ;;
MEMORY_OVERF DB   'Unable to create KEYB table in resident memory',10,13,'$'  ;;
CR_LF	    DB	  10,13,'$'                                                   ;;
									      ;;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybcpsd.asm ===
PAGE	,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; (C) Copyright Microsoft Corp. 1987-1990
; MS-DOS 5.00 - NLS Support - KEYB Command
;
;
;  File Name:  KEYBCPSD.ASM
;  ----------
;
;
;  Description:
;  ------------
;	 Copies the SHARED_DATA_AREA into a part of memory that
;	 can be left resident. All relative pointers must already
;	 be recalculated to this new position.
;	 THIS FILE MUST BE THE LAST OF THE RESIDENT FILES WHEN KEYB IS LINKED.
;
;
;  Procedures Contained in This File:
;  ----------------------------------
;
;  Include Files Required:
;  -----------------------
;	INCLUDE KEYBSHAR.INC
;	INCLUDE KEYBCMD.INC
;	INCLUDE KEYBTBBL.INC
;
;  External Procedure References:
;  ------------------------------
;	 FROM FILE  ????????.ASM:
;	      procedure - description???
;
;  Linkage Information:  Refer to file KEYB.ASM
;  --------------------
;
;  Change History:
;  ---------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	PUBLIC	SD_DEST_PTR
	PUBLIC	COPY_SD_AREA
	PUBLIC	SHARED_DATA

	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBCMD.INC
	INCLUDE KEYBTBBL.INC

CODE	SEGMENT PUBLIC 'CODE'

	ASSUME	CS:CODE,DS:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: COPY_SD_AREA
;
;  Description:
;
;  Input Registers:
;
;  Output Registers:
;      N/A
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SD		EQU   SHARED_DATA
TSD		EQU  TEMP_SHARED_DATA

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COPY_SD_AREA	PROC   NEAR

   REP	MOVS	ES:BYTE PTR [DI],DS:[SI]	; Copy SHARED_DATA_AREA to
						;	new part of memory

	MOV	BYTE PTR ES:SD.TABLE_OK,1	; Activate processing flag
	INT	21H				; Exit


COPY_SD_AREA	ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		db	'SHARED DATA'
SD_DEST_PTR	LABEL	BYTE

SHARED_DATA   SHARED_DATA_STR <>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE   ENDS
       END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybcmd.asm ===
PAGE    ,132
;
; (C) Copyright Microsoft Corp. 1987-1990
; MS-DOS 5.00 - NLS Support - KEYB Command
;
;
; File Name:  KEYBCMD.ASM
; ----------
;
;
; Description:
; ------------
;        Contains transient command processing modules for KEYB command.
;
; Procedures contained in this file:
; ----------------------------------
;       KEYB_COMMAND:    Main routine for command processing.
;       PARSE_PARAMETERS:  Validate syntax of parameters included
;           on command line.
;       BUILD_PATH: Find KEYBOARD.SYS file and validate language and/or
;           code page.
;       INSTALL_INT_VECTORS:  Install our INT 9, INT 2F Drivers
;       NUMLK_ON:  Turn on the NUM LOCK LED
;       FIND_FIRST_CP: Determine first code page for given language in the
;           Keyboard Definition file.
;
; Include Files Required:
; -----------------------
;       KEYBMSG.INC
;       KEYBEQU.INC
;       KEYBSYS.INC
;       KEYBI9C.INC
;       KEYBI9.INC
;       KEYBI2F.INC
;       KEYBSHAR.INC
;       KEYBDCL.INC
;       KEYBTBBL.INC
;       COMMSUBS.INC
;       KEYBCPSD.INC
;       POSTEQU.SRC
;       DSEG.SRC
;
; External Procedure References:
; ------------------------------
;       FROM FILE  KEYBTBBL.ASM:
;             TABLE_BUILD - Create the shared area containing all keyboard tables.
;             STATE_BUILD - Build all states within the table area
;        FROM FILE  KEYBMSG.ASM:
;             KEYB_MESSAGES - All messages
;
; Change History:
;
;  Modified for DOS 3.40 -      Nick Savage , IBM Corporation
;                               Wilf Russell, IBM Canada Laboratory
;                               DCR ???? -KEYBAORD SECURITY LOCK - CNS
;
;
;                               PTM 3906 - KEYB messages do not conform
;                                          to spec. Error message does
;                               3/24/88            not pass back the bogus command
;                                          line argument.             - CNS
;
; PTMP3955 ;KEYB component to free environment and close handles 0 - 4
;
; 3/24/88
;
; 9/26/89 jwg Moved code from resident module and reduce code size.
;
;;;;;;;;;;;;;

        PUBLIC  KEYB_COMMAND

;*****************CNS********************
        PUBLIC  ID_TAB_OFFSET
;*****************CNS********************

        PUBLIC  CP_TAB_OFFSET
        PUBLIC  STATE_LOGIC_OFFSET
        PUBLIC  SYS_CODE_PAGE
        PUBLIC  KEYBCMD_LANG_ENTRY_PTR
        PUBLIC  DESIG_CP_BUFFER
        PUBLIC  DESIG_CP_OFFSET
        PUBLIC  KEYBSYS_FILE_HANDLE
        PUBLIC  NUM_DESIG_CP
        PUBLIC  TB_RETURN_CODE
        PUBLIC  FILE_BUFFER
        PUBLIC  FB

;*****************CNS********************
        PUBLIC  ID_PTR_SIZE
        PUBLIC  LANG_PTR_SIZE
        PUBLIC  CP_PTR_SIZE
        PUBLIC  NUM_ID
        PUBLIC  NUM_LANG
        PUBLIC  NUM_CP
        PUBLIC  SHARED_AREA_PTR
;*****************CNS********************

        PUBLIC  SD_SOURCE_PTR
        PUBLIC  TEMP_SHARED_DATA

        PUBLIC  FOURTH_PARM
        PUBLIC  ONE_PARMID
        PUBLIC  FTH_PARMID
        PUBLIC  ID_FOUND
        PUBLIC  BAD_ID
        PUBLIC  ALPHA
        EXTRN   PARSE_PARAMETERS:NEAR
        extrn   pswitches:byte

;***CNS
        EXTRN   SECURE_FL:BYTE
        EXTRN   CUR_PTR:WORD
        EXTRN   OLD_PTR:WORD
        EXTRN   ERR_PART:WORD
;***CNS

        .xlist
        INCLUDE SYSMSG.INC             ;  message retriever
        .list

MSG_UTILNAME <KEYB>                    ;  identify to message retriever

CODE    SEGMENT PUBLIC 'CODE'

        .xlist
        INCLUDE KEYBEQU.INC
        INCLUDE KEYBSYS.INC
        INCLUDE KEYBI9.INC
        INCLUDE KEYBI9C.INC
        INCLUDE KEYBI2F.INC
        INCLUDE KEYBSHAR.INC
        INCLUDE KEYBDCL.INC
        INCLUDE KEYBTBBL.INC
        INCLUDE COMMSUBS.INC
        INCLUDE KEYBCPSD.INC
        .xlist
        INCLUDE POSTEQU.INC
        INCLUDE DSEG.INC

        .list
        ASSUME  CS:CODE,DS:CODE

;;;;;;;;;;;;;
;
; Module: KEYB_COMMAND
;
; Description:
;     Main routine for transient command processing.
;
; Input Registers:
;     DS - points to our data segment
;
; Output Registers:
;     Upon termination, if an error has occurred in which a keyboard table
;     was not loaded, the AL register will contain the a error flag. This
;     flag is defined as follows:
;             AL:= 1 - Invalid language, code page, or syntax
;                  2 - Bad or missing Keyboard Definition File
;                  3 - KEYB could not create a table in resident memory
;                  4 - An error condition was received when communicating
;                      with the CON device
;                  5 - Code page requested has not been designated
;                  6 - The keyboard table for the requested code page cannot
;                      be found in resident keyboard table.
;
; Logic:
;     IF KEYB has NOT been previously loaded THEN
;         Set SHARED_AREA_PTR to TEMP_SHARED_AREA
;         INSTALLED_KEYB := 0
;         Get HW_TYPE (set local variable)
;     ELSE
;         Set SHARED_AREA_PTR to ES:SHARED_AREA
;         Get HW_TYPE (set local variable)
;         Set TABLE_OK := 0
;         INSTALLED_KEYB := 1
;
;     IF CPS-CON has been loaded THEN
;         INSTALLED_CON := 1
;
;*********************************** CNS *************************************
;     Call PARSE_PARAMETERS := Edit ID or language, code page,
;                                           and path parameters,ID on command line
;*********************************** CNS *************************************
;     Check all return codes:
;     IF any parameters are invalid THEN
;         Display ERROR message
;     ELSE
;         IF no language parm specified
;                                AND code page is not invalid
;                                                    AND syntax is valid THEN
;            Process QUERY:
;            IF KEYB is installed THEN
;                Get and display active language from SHARED_DATA_AREA
;                Get invoked code page from SHARED_DATA_AREA
;                Convert to ASCII
;                Display ASCII representation of code page, CR/LF
;*********************************** CNS *************************************
;            IF ALTERNATE FLAG SET
;                Get and display active ID from SHARED_DATA_AREA
;                Convert to ASCII
;                Display ASCII representation of ID, CR/LF
;*********************************** CNS *************************************
;            IF CPS-CON is installed THEN
;                Get selected code page info from CON
;                Convert to ASCII
;                Display ASCII representation of code page, CR/LF
;            EXIT without staying resident
;
;         ELSE
;            Call BUILD_PATH := Determine location of Keyboard definition file
;            Open the file
;            IF error in opening file THEN
;               Display ERROR message and EXIT
;            ELSE
;               Save handle
;               Set address of buffer
;               READ header of Keyboard definition file
;               IF error in reading file THEN
;                  Display ERROR message and EXIT
;               ELSE
;                  Check signature for correct file
;                  IF file signature is correct THEN
;                     READ language table
;                     IF error in reading file THEN
;                         Display ERROR message and EXIT
;                     ELSE
;                         Use table to verify language parm
;                         Set pointer values
;                         IF code page was specified
;                             READ language entry
;                             IF error in reading file THEN
;                                  Display ERROR message and EXIT
;                             ELSE
;                                  READ Code page table
;                                  IF error in reading file THEN
;                                      Display ERROR message and EXIT
;                                  ELSE
;                                      Use table to verify code page parm
;                                      Set pointer values
;     IF CPS-CON is not installed THEN
;           Set number of code pages = 1
;           IF CODE_PAGE_PARM was specified THEN
;              Copy CODE_PAGE_PARM into table of code pages to build
;           ELSE
;              Call FIND_FIRST_CP := Define the system code page (1st in Keyb Def file)
;              Copy SYSTEM_CP into table of code pages to build
;     ELSE
;           Issue INT 2F ; 0AD03H  to get table of Designated code pages
;           Set number of designated code pages (HWCP + Desig CP)
;           Issue INT 2F ; 0AD02H  to get invoked code page
;           IF CODE_PAGE_PARM was specified THEN
;              Check that CODE_PAGE_PARM is in the list of designated code pages
;              IF CODE_PAGE_PARM is in the list of designated code pages THEN
;                   Copy specified CP into table of code pages to build
;                   IF a CP has been selected AND is inconsistent with specified CP
;                       Issue WARNING message
;              ELSE
;                   Display ERROR message
;           ELSE
;              IF a code page has been invoked THEN
;                   Copy invoked code page into table of code pages to build
;              ELSE
;                   Call FIND_FIRST_CP := Define the system code page (1st in Keyb Def file)
;                   Copy SYSTEM_CP into table of code pages to build
;
;     IF KEYB has not been previously installed THEN
;         Call FIND_SYS_TYPE := Determine system type
;         Call INSTALL_INT_9 := Install INT 9 handler
;         Call FIND_KEYB_TYPE := Determine the keyboard type
;
;     Call TABLE_BUILD := Build the TEMP_SHARED_DATA_AREA
;
;     IF return codes from TABLE_BUILD are INVALID THEN
;         IF KEYB_INSTALLED := 0 THEN
;             Call REMOVE_INT_9
;         Display corresponding ERROR message
;         EXIT without staying resident
;     ELSE
;         IF any of the designated CPs were invalid in the build THEN
;             Issue WARNING message
;         Close the Keyboard definition file
;         IF KEYB had NOT already been installed THEN
;             IF keyboard is a Ferrari_G AND system is not an XT THEN
;             Call NUMLK_ON := Turn the NUM LOCK LED on
;             IF extended INT 16 support required THEN
;                Install extended INT 16 support
;             Call INSTALL_INT_9_NET := Let network know about INT 9
;             Call INSTALL_INT_2F := Install the INT 2F driver
;             Activate language
;             Get resident end and copy TEMP_SHARED_DATA_AREA into SHARED_DATA_AREA
;             EXIT but stay resident
;         ELSE
;             IF this was not a query call AND exit code was valid THEN
;                Activate language
;                Get resident end and copy TEMP_SHARED_DATA_AREA into SHARED_DATA_AREA
;             EXIT without staying resident
;     END
;
;;;;;;;;;;;;;

INVALID_PARMS        EQU  1           ;  EXIT return codes
BAD_KEYB_DEF_FILE    EQU  2
MEMORY_OVERFLOW      EQU  3
CONSOLE_ERROR        EQU  4
CP_NOT_DESIGNATED    EQU  5
KEYB_TABLE_NOT_LOAD  EQU  6
BAD_DOS_VER          EQU  7
EXIT_RET_CODE        DB   0

;******************** CNS ***********
ID_VALID             EQU  0
ID_INVALID           EQU  1
NO_ID                EQU  2
LANGUAGE_VALID       EQU  0
LANGUAGE_INVALID     EQU  1             ;  Return Codes
NO_LANGUAGE          EQU  2             ;    from
NO_IDLANG            EQU  3
;******************** CNS ***********

CODE_PAGE_VALID      EQU  0             ;     EDIT_LANGUAGE_CODE
CODE_PAGE_INVALID    EQU  1
NO_CODE_PAGE         EQU  2
VALID_SYNTAX         EQU  0
INVALID_SYNTAX       EQU  1

ACT_KEYB             EQU  2
ACT_ID               EQU  3
ACT_KEYB_CP          EQU  4
ACT_CON_CP           EQU  5
INV_L                EQU  6             ;  message numbers...
INV_I                EQU  7
INV_CP               EQU  8
INV_S                EQU  18
INV_FN               EQU  9
INV_KEYB_Q           EQU  10
INV_CON_Q            EQU  11
NOT_DESIG            EQU  12
NOT_SUPP             EQU  13
NOT_VALID            EQU  14
WARNING_1            EQU  15
INV_COMBO            EQU  16
MEMORY_OVERF         EQU  17
help_1st             equ  300
help_last            equ  306
CR_LF                DB   10,13,'$'

FOURTH_PARM     DB      0               ;  switch was specified
ONE_PARMID      DB      0               ;  id given as positional
FTH_PARMID      DB      0               ;  id given as switch
ID_FOUND        DB      0               ;  id was good (in k.d. file)
BAD_ID          DB      0               ;  id was bad (from parse)
ALPHA           DB      0               ;  first parm a language id

ID_DISPLAYED    DB      0               ;  Indicating ID already displayed

SUBLIST_NUMBER LABEL BYTE               ;  sublist for numbers
               DB       11              ;  size
               DB       0
PTR_TO_NUMBER  DW       ?               ;  offset ptr
SEG_OF_NUMBER  DW       ?               ;  segment
               DB       1
               DB       10100001B       ;  flag
               DB       4               ;  max width (YST)
               DB       1               ;  min width
               DB       " "             ;  filler


SUBLIST_ASCIIZ LABEL BYTE               ;  sublist for asciiz
               DB       11              ;  size
               DB       0
PTR_TO_ASCIIZ  DW       ?               ;  offset ptr
SEG_OF_ASCIIZ  DW       ?               ;  segment
               DB       1
               DB       00010000B       ;  flag
               DB       2               ;  max width
               DB       2               ;  min width
               DB       " "             ;  filler

NUMBER_HOLDER  DW       ?               ;  used for message retriever

;***CNS
SUBLIST_COMLIN LABEL BYTE               ;  sublist for asciiz
               DB       11              ;  size
               DB       0
PTR_TO_COMLIN  DW       ?               ;  offset ptr
SEG_OF_COMLIN  DW       ?
               DB       0
               DB       LEFT_ALIGN+CHAR_FIELD_ASCIIZ  ;  flag

               DB       0               ;  max width
               DB       1               ;  min width
               DB       " "             ;  filler


STRING_HOLDER  DB       64 DUP(0)
;***CNS

FILE_BUFFER          DB   FILE_BUFFER_SIZE dup (0); Buffer for Keyboard Def file
FB                   EQU  FILE_BUFFER   ;m for 32 language entries)
DESIG_CP_BUFFER      DW   28 DUP(?)     ; (Room for 25 code pages)
DESIG_CP_BUF_LEN     DW   $-DESIG_CP_BUFFER ; Length of code page buffer
NUM_DESIG_CP         DW   0
CP_TAB_OFFSET        DD   ?

;******************  CNS  ******************
TOTAL_SIZE           DW   0
PASS_LANG            DW   0
ID_TAB_OFFSET        DD   ?
;******************  CNS  ******************

STATE_LOGIC_OFFSET   DD   -1
KEYBSYS_FILE_HANDLE  DW   ?
TB_RETURN_CODE       DW   1
DESIG_CP_OFFSET      DW   OFFSET DESIG_CP_BUFFER
SYS_CODE_PAGE        DW   0
DESIG_LIST           DW   0
QUERY_CALL           DB   0

KB_MASK              EQU  02h

SIGNATURE            DB   0FFh,'KEYB   '
SIGNATURE_LENGTH     DW   8

;******************  CNS  ***************************
NUM_ID               DW   0
ERR4ID               DB   0
NUM_LANG             DW   0
NUM_CP               DW   0
ID_PTR_SIZE          DW   SIZE KEYBSYS_ID_PTRS
;******************  CNS  ***************************

LANG_PTR_SIZE        DW   SIZE KEYBSYS_LANG_PTRS
CP_PTR_SIZE          DW   SIZE KEYBSYS_CP_PTRS
KEYBCMD_LANG_ENTRY_PTR DD ?

KEYB_INSTALLED       DW   0
CON_INSTALLED        DW   0
SHARED_AREA_PTR      DD   0
GOOD_MATCH           DW   0

;******************  CNS  ***************************;
LANGUAGE_ASCII       DB   '??',0

CMD_PARM_LIST        PARM_LIST <>

;----------  TABLES FOR EXTENDED KEYBOARD SUPPORT CTRL CASE  ---------


RPL_K8  LABEL   BYTE                    ;-------- CHARACTERS ---------
        DB      27,-1,00,-1,-1,-1       ; Esc, 1, 2, 3, 4, 5
        DB      30,-1,-1,-1,-1,31       ; 6, 7, 8, 9, 0, -
        DB      -1,127,148,17,23,5      ; =, Bksp, Tab, Q, W, E
        DB      18,20,25,21,09,15       ; R, T, Y, U, I, O
        DB      16,27,29,10,-1,01       ; P, [, ], Enter, Ctrl, A
        DB      19,04,06,07,08,10       ; S, D, F, G, H, J
        DB      11,12,-1,-1,-1,-1       ; K, L, ;, ', `, LShift
        DB      28,26,24,03,22,02       ; \, Z, X, C, V, B
        DB      14,13,-1,-1,-1,-1       ; N, M, ,, ., /, RShift
        DB      150,-1,' ',-1           ; *, Alt, Space, CL
                                        ;--------- FUNCTIONS ---------
        DB      94,95,96,97,98,99       ; F1 - F6
        DB      100,101,102,103,-1,-1   ; F7 - F10, NL, SL
        DB      119,141,132,142,115,143 ; Home, Up, PgUp, -, Left, Pad5
        DB      116,144,117,145,118,146 ; Right, +, End, Down, PgDn, Ins
        DB      147,-1,-1,-1,137,138    ; Del, SysReq, Undef, WT, F11, F12
L_CTRL_TAB      EQU     $-RPL_K8

;;;;;;;;;;;;;;;;
;    Program Code
;;;;;;;;;;;;;;;;

KEYB_COMMAND  PROC NEAR
        CALL    SYSLOADMSG              ;load messages
        JNC     VERSION_OK              ;if no carry then version ok

        CALL    SYSDISPMSG              ;error..display version error
        MOV     AL,BAD_DOS_VER          ;bad DOS version
        MOV     EXIT_RET_CODE,AL
        JMP     KEYB_EXIT_NOT_RESIDENT  ;exit..non resident

VERSION_OK:
        MOV     SEG_OF_NUMBER,CS        ;initialize..
        MOV     SEG_OF_ASCIIZ,CS        ;  ..sublists
        MOV     BP,OFFSET CMD_PARM_LIST         ;pointer for parm list
        MOV     WORD PTR SHARED_AREA_PTR,ES ; ES segment

KEYB_INSTALL_CHECK:
        MOV     AX,0AD80H               ; KEYB install check
        INT     2FH
        CMP     AL,-1                   ; If flag is not 0FFh THEN
        JE      INSTALLED_KEYB

        MOV     WORD PTR SHARED_AREA_PTR+2,OFFSET TSD
        JMP     short CON_INSTALL_CHECK

INSTALLED_KEYB:
        MOV     KEYB_INSTALLED,1        ; Set KEYB_INSTALLED flag = YES
        MOV     WORD PTR SHARED_AREA_PTR,ES ; Save segment of SHARED_DATA_AREA
        MOV     WORD PTR SHARED_AREA_PTR+2,DI ;Save offset of SHARED_DATA_AREA

        MOV     AX,ES:[DI].KEYB_TYPE
        MOV     HW_TYPE,AX
        MOV     ES:[DI].TABLE_OK,0      ; Do not allow processing
        PUSH    CS                      ;         while building table
        POP     ES                      ; Reset ES until required

CON_INSTALL_CHECK:
        MOV     AX,0AD00H               ; CONSOLE install check
        INT     2FH
        CMP     AL,-1                   ; If flag is not 0FFh THEN
        jnz     call_first_stage

        MOV     CON_INSTALLED,1                 ; Set CON_INSTALLED flag = YES

CALL_FIRST_STAGE:
        PUSH    CS
        POP     ES
        CALL    PARSE_PARAMETERS        ; Validate parameter list

        test    pswitches,1             ; /? option?
        jz      no_help                         ; brif not

        mov     ax,help_1st             ; first help msg
help_loop:
        push    ax
        MOV     BX,STDOUT               ; to standard out
        xor     cx,cx                   ; no replacements
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        LEA     SI,SUBLIST_ASCIIZ       ; ptr to sublist
        CALL    SYSDISPMSG
        pop     ax
        inc     ax
        cmp     ax,help_last
        jbe     help_loop

        mov     exit_ret_code,invalid_parms ; return "invalid parms"
        jmp     KEYB_EXIT_NOT_RESIDENT



no_help:

BEGIN_PARM_CHECK:                       ; CHECK ALL RETURN CODES
        MOV     DL,[BP].RET_CODE_3
        CMP     DL,1                    ; Check for invalid syntax
        JNE     VALID1
        JMP     ERROR3

VALID1:
        MOV     DL,[BP].RET_CODE_1      ; Check for invalid language parm
        CMP     DL,1
        JNE     VALID2
        JMP     ERROR1

VALID2:
        MOV     DL,[BP].RET_CODE_2      ; Check for invalid code page parm
        CMP     DL,1
        JNE     VALID3
        JMP     ERROR2

VALID3:
        MOV     DL,[BP].RET_CODE_1      ; Check for query command
        CMP     DL,2
        JE      QUERY


;******************************* CNS **
        CMP     DL,3                    ; Get a status of the codepage
        JE      QUERY                   ; language, and possible ID code
;******************************* CNS **

        JMP     NOT_QUERY
                                        ; IF QUERY is requested THEN
QUERY:
        MOV     QUERY_CALL,DL
        MOV     AX,KEYB_INSTALLED       ;     If KEYB is installed THEN
        or      ax,ax
        JE      QUERY_CONTINUE1

        MOV     DI,WORD PTR SHARED_AREA_PTR+2   ; Get offset of
        MOV     ES,WORD PTR SHARED_AREA_PTR     ;        shared area
        MOV     BX,WORD PTR ES:[DI].ACTIVE_LANGUAGE ; Get active language
        or      bx,bx                           ; if no language...
        JE      I_MESSAGE                       ;  then id was specified


L_MESSAGE:
        MOV     WORD PTR LANGUAGE_ASCII,BX ; Display Language
        LEA     SI,LANGUAGE_ASCII       ; sublist points to...
        MOV     PTR_TO_ASCIIZ,SI        ; language code asciiz string
        MOV     AX,ACT_KEYB             ; display 'Current keyboard code'
        MOV     BX,STDOUT               ; to standard out
        MOV     CX,1                    ; one replacement
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        LEA     SI,SUBLIST_ASCIIZ       ; ptr to sublist
        CALL    SYSDISPMSG
        JMP     short KEYB_L_FINISHED

I_MESSAGE:
        MOV     BX,WORD PTR ES:[DI].INVOKED_KBD_ID ;  get id code.
        MOV     NUMBER_HOLDER,BX        ;  transfer number to temp loc.
        LEA     SI,NUMBER_HOLDER        ;  sublist points to...
        MOV     PTR_TO_NUMBER,SI        ;  code page word
        MOV     AX,ACT_ID               ;  display 'Current ID:  '
        MOV     BX,STDOUT               ;  to standard out
        MOV     CX,1                    ;  one replacement
        MOV     DH,UTILITY_MSG_CLASS    ;  utility message
        XOR     DL,DL                   ;  no input
        LEA     SI,SUBLIST_NUMBER       ;  ptr to sublist
        CALL    SYSDISPMSG
        MOV     ID_DISPLAYED,1          ;  ID was displayed.
        JMP     short KEYB_L_FINISHED

QUERY_CONTINUE1:
        MOV     AX,INV_KEYB_Q
        MOV     BX,STDOUT               ;  Else
        XOR     CX,CX                   ;   Display message that KEYB
        MOV     DH,UTILITY_MSG_CLASS    ;   has not been installed
        XOR     DL,DL
        CALL    SYSDISPMSG
        JMP     short KEYB_CP_FINISHED

KEYB_L_FINISHED:
        MOV     BX,ES:[DI].INVOKED_CP_TABLE ; Get invoked code page

        MOV     NUMBER_HOLDER,BX        ;  transfer number to temp loc.
        LEA     SI,NUMBER_HOLDER        ;  sublist points to...
        MOV     PTR_TO_NUMBER,SI        ;  code page word
        MOV     AX,ACT_KEYB_CP          ;  display '  code page: '
        MOV     BX,STDOUT               ;  to standard out
        MOV     CX,1                    ;  one replacement
        MOV     DH,UTILITY_MSG_CLASS    ;  utility message
        XOR     DL,DL                   ;  no input
        LEA     SI,SUBLIST_NUMBER       ;  ptr to sublist
        CALL    SYSDISPMSG
        CMP     ID_DISPLAYED,1          ;  was id displayed?
        JE      KEYB_CP_FINISHED        ;  yes..continue.

        MOV     BX,WORD PTR ES:[DI].INVOKED_KBD_ID ;  get id code.
        or      bx,bx                   ;  no id given
        JE      KEYB_CP_FINISHED

        MOV     NUMBER_HOLDER,BX        ;  transfer number to temp loc.
        LEA     SI,NUMBER_HOLDER        ;  sublist points to...
        MOV     PTR_TO_NUMBER,SI        ;  code page word
        MOV     AX,ACT_ID               ;  display 'Current ID:  '
        MOV     BX,STDOUT               ;  to standard out
        MOV     CX,1                    ;  one replacement
        MOV     DH,UTILITY_MSG_CLASS    ;  utility message
        XOR     DL,DL                   ;  no input
        LEA     SI,SUBLIST_NUMBER       ;  ptr to sublist
        CALL    SYSDISPMSG

        MOV     AH,09H                  ;  need a CR_LF here.
        MOV     DX,OFFSET CR_LF
        INT     21H

KEYB_CP_FINISHED:
        MOV     AX,CON_INSTALLED        ;  If CON has been installed THEN
        or      ax,ax
        JNE     GET_ACTIVE_CP
        JMP     short CON_NOT_INSTALLED

GET_ACTIVE_CP:
        MOV     AX,0AD02H               ;  Get active code page
        INT     2FH                     ;   information from the console
        JNC     DISPLAY_ACTIVE_CP
        JMP     ERROR5

DISPLAY_ACTIVE_CP:
        MOV     NUMBER_HOLDER,BX        ; transfer number to temp loc.
        LEA     SI,NUMBER_HOLDER        ; sublist points to...
        MOV     PTR_TO_NUMBER,SI        ; code page word
        MOV     AX,ACT_CON_CP           ; display 'Current CON code page: '
        MOV     BX,STDOUT               ; to standard out
        MOV     CX,1                    ; one replacement
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        LEA     SI,SUBLIST_NUMBER       ; ptr to sublist
        CALL    SYSDISPMSG

        JMP     KEYB_EXIT_NOT_RESIDENT  ;  Exit from Proc

CON_NOT_INSTALLED:                      ; ELSE
        MOV     AX,INV_CON_Q
        MOV     BX,STDOUT               ; Else
        XOR     CX,CX                   ;       Display message that CON does
        MOV     DH,UTILITY_MSG_CLASS    ;         not have active code page
        XOR     DL,DL
        CALL    SYSDISPMSG
        JMP     KEYB_EXIT_NOT_RESIDENT  ; Exit from Proc

NOT_QUERY:                              ; IF not a query function requested
        CALL    BUILD_PATH              ; Determine location of KEYBOARD.SYS
                                        ;  ...and open file.

        JNC     VALID4                  ; If no error in opening file then
        JMP     ERROR4

VALID4:
        MOV     KEYBSYS_FILE_HANDLE,AX  ; Save handle
        MOV     BP,OFFSET CMD_PARM_LIST ; Set base pointer for structures
        MOV     BX,KEYBSYS_FILE_HANDLE  ; Retrieve the file handle
        MOV     DX,OFFSET FILE_BUFFER   ; Set address of buffer

;************************* CNS ********;
        cmp     [BP].RET_CODE_4,ID_VALID ; CNS is there an ID available
        je      ID_TYPED                ; if so go find out if it is
        jmp     short GET_LANG          ; a 1st or 4th parm, if not must
                                        ; must be a language
ID_TYPED:

        call    SCAN_ID                         ; scan the table for the ID
        cmp     ID_FOUND,1              ; if a legal ID check and see if
        jne     LOST_ID                         ; it is a first or fourth parm

        cmp     FTH_PARMID,1            ; if it is a fourth parm go
        je      GET_ID                  ; check for language compatibility
        jmp     short Language_found    ; otherwise it must be a first
                                        ; parm id value

LOST_ID:                                ; otherwise must be a bogus match
                                        ; between language and ID codes
                                        ;  or the ID code does not exist
        jmp     ERR1ID                  ; in the table
;************************* CNS ***********;

GET_LANG:                                ; Must be a language/or a 1st parm ID


        XOR     DI,DI                   ; Set number
        LEA     CX,[DI].KH_NUM_LANG+2   ;        bytes to read header

        MOV     AH,3FH                  ; Read header of the Keyb Def file
        INT     21H
        JNC     VALID5                  ; If no error in opening file then
        JMP     ERROR4

VALID5:
        CLD                             ;  all moves/scans forward
        MOV     CX,SIGNATURE_LENGTH
        MOV     DI,OFFSET SIGNATURE     ; Verify matching
        MOV     SI,OFFSET FB.KH_SIGNATURE ;          signatures
        REPE    CMPSB
        JE      LANGUAGE_SPECIFIED
        JMP     ERROR4
                                        ; READ the language table
LANGUAGE_SPECIFIED:
        MOV     AX,FB.KH_NUM_LANG
        MOV     NUM_LANG,AX             ; Save the number of languages
        MUL     LANG_PTR_SIZE           ; Determine # of bytes to read
        MOV     DX,OFFSET FILE_BUFFER   ; Establish beginning of buffer
        MOV     CX,AX
        CMP     CX,SIZE FILE_BUFFER     ; Make sure buffer is not to small
        JBE     READ_LANG_TAB
        JMP     ERROR4

READ_LANG_TAB:
        MOV     AH,3FH                  ; Read language table from
        INT     21H                     ;              Keyb Def file
        JNC     READ_VALID              ; If no error in opening file then
        JMP     ERROR4                  ; Else display ERROR message

READ_VALID:
        MOV     CX,NUM_LANG             ;    Number of valid codes
        MOV     DI,OFFSET FILE_BUFFER   ;    Point to correct word in table

SCAN_LANG_TABLE:                        ; FOR language parm
        MOV     AX,[BP].LANGUAGE_PARM   ;    Get parameter
        CMP     [DI].KP_LANG_CODE,AX    ;    Valid Code ??
        JE      LANGUAGE_FOUND          ; If not found AND more entries THEN

        ADD     DI,LANG_PTR_SIZE        ;         Check next entry
        DEC     CX                      ;    Decrement count of entries
        JNE     SCAN_LANG_TABLE                 ; Else
        JMP     ERROR1                  ;    Display error message

;**************************** CNS ****
GET_ID:                                 ; CNS - Must be an ID value
        mov     cx,1                    ; initialize ctr value for # of ids

SEARCH_ID:                              ; minimum per country
;                                       ; There is atleast 1 ID for each country
        or      cx,cx                   ; check for any more IDs left to check
        jne     FINDID                  ; Country has more than one ID check
        jmp     END_IDCHK               ; Country & ID has been found or value
                                        ; is zero
FINDID:

        push    di                      ; save the current language entry ptr
        push    cx                      ; save the minimum # of ids before
                                        ; reading the table data from the disk
;**************************** CNS ***********

LANGUAGE_FOUND:
        MOV     CX,WORD PTR [DI].KP_ENTRY_PTR+2         ; Get offset of lang entry
        MOV     DX,WORD PTR [DI].KP_ENTRY_PTR   ;       in the Keyb Def file
        MOV     WORD PTR KEYBCMD_LANG_ENTRY_PTR,DX ; Save
        MOV     WORD PTR KEYBCMD_LANG_ENTRY_PTR+2,CX ;  offset
        MOV     AH,42H                          ; Move file pointer to
        MOV     AL,0                            ;  location of language
        INT     21H                             ;  entry
        JNC     LSEEK_VALID
        JMP     ERROR4

LSEEK_VALID:
        MOV     DI,AX
        MOV     CX,SIZE KEYBSYS_LANG_ENTRY-1    ; Set number
                                                ;  bytes to read header
        MOV     DX,OFFSET FILE_BUFFER
        MOV     AH,3FH                  ; Read language entry in
        INT     21H                     ;  Keyb Def file
        JNC     VALID6a                         ; If no error in file then
        JMP     ERROR4

;**************************** CNS **********************************************


valid6a:
        cmp     FOURTH_PARM,1           ; Is the ID a 4th Parm
        jne     VALID6                  ; if not get out of routine, otherwise
        pop     cx                      ; restore # of ids for the country
                                        ; Check to see if this is the first
                                        ; time checking the primary ID
        cmp     cx,1                    ; if there is just one ID check to make
        jne     CHK4PARM                ; sure both flags are not set
                                        ; this should not be necessary w/ new parser

        cmp     FTH_PARMID,1            ; is the ID flag for switch set
        jne     CHK1N4                  ; is the flag set only for the 4th
        cmp     FOURTH_PARM,1           ; if set only for the switch proceed
        jne     CHK1N4                  ; if not must be a positional
        mov     cl,fb.kl_num_id                 ; get the number of IDs available from the table
        mov     FTH_PARMID,0            ; turn switch flag off so the table
                                        ; counter will not be reset

                                        ;ids available for the
CHK1N4:                                 ;country
        cmp     ONE_PARMID,1            ; this was to be done if
        jne     CHK4PARM                ; two the positional
        cmp     FOURTH_PARM,0           ; and switch was specified
        jne     CHK4PARM                ; this should never happen

        pop     di                      ; if the parser is intact
        jmp     error3                  ; report error & exit

CHK4PARM:                               ; check on the first ID
        cmp     FOURTH_PARM,1           ; ID was a switch
        jne     ABORT_LOOP              ; otherwise get out of routine
        call    IDLANG_CHK              ; check the ID
        jmp     short ADVANCE_PTR       ; advance to the next position

ABORT_LOOP:
        xor     cx,cx                   ; end loop

ADVANCE_PTR:
        pop     di                      ;restore entry value

        dec     cx                      ; # of ids left to check
        je      NO_ADVANCE              ; if 0, don't advance table position
        cmp     GOOD_MATCH,1            ; check to see if ID matched language
        je      NO_ADVANCE              ; if equal do not advance

        add     di,LANG_PTR_SIZE        ; step to the next entry
                                        ; in the table

NO_ADVANCE:

        jmp     SEARCH_ID               ; for the country

;                                       ; end of ID check for country

END_IDCHK:

        cmp     FOURTH_PARM,1           ; see if id was found
        jne     VALID6
        cmp     GOOD_MATCH,0            ; none found
        jne     VALID6                  ; report error

        mov     [bp].ret_code_4,1       ; incompatible lang code
        mov     al,[bp].ret_code_4      ; id combo
        jmp     err2id

                                        ; otherwise found it
                                        ; continue to build tbl
;**************************** CNS **********************************************

VALID6:
        MOV     AX,WORD PTR FB.KL_LOGIC_PTR     ; Save the offset of the state
        MOV     WORD PTR STATE_LOGIC_OFFSET,AX  ;    logic section
        MOV     AX,WORD PTR FB.KL_LOGIC_PTR+2   ; Save the offset of the state
        MOV     WORD PTR STATE_LOGIC_OFFSET+2,AX ;   logic section

        MOV     DL,[BP].RET_CODE_2      ; IF code page was specified
        CMP     DL,2
        JNE     CODE_PAGE_SPECIFIED
        JMP     short DONE

CODE_PAGE_SPECIFIED:                  ;  Then

;************************** CNS ***************************************
        xor     ah,ah
        MOV     Al,FB.KL_NUM_CP
;************************** CNS ***************************************

        MOV     NUM_CP,AX               ; Save the number of code pages
        MUL     CP_PTR_SIZE             ; Determine # of bytes to read
        MOV     DX,OFFSET FILE_BUFFER   ; Establish beginning of buffer
        MOV     CX,AX
        CMP     CX,SIZE FILE_BUFFER     ; Make sure buffer is not to small
        JBE     VALID7
        JMP     ERROR4

VALID7:
        MOV     AH,3FH                  ; Read code page table from
        INT     21H                     ;       Keyb Def file
        JNC     VALID8                  ; If no error in opening file then
        JMP     ERROR4

VALID8:
        MOV     CX,NUM_CP               ;    Number of valid codes
        MOV     DI,OFFSET FILE_BUFFER   ;    Point to correct word in table

SCAN_CP_TABLE:                          ; FOR code page parm
        MOV     AX,[BP].CODE_PAGE_PARM  ;    Get parameter
        CMP     [DI].KC_CODE_PAGE,AX    ;    Valid Code ??
        JE      CODE_PAGE_FOUND                 ; If not found AND more entries THEN

        ADD     DI,CP_PTR_SIZE          ;    Check next entry
        DEC     CX                      ;    Decrement count of entries
        JNE     SCAN_CP_TABLE           ; Else
;;; if we can not find the CP, simply use the first one available for
;;; the language. This was done for NT because users can not really specified
;;; the code page id via KEYB.COM. By using the first CP, we maintain the
;;; compatibility with dos(keyb gr will succeed even the currnt code page is
;;; invalid for German layout
;;;
ifdef NOT_NTVDM
       JMP	 ERROR2 		 ;    Display error message
else
	mov	cx, 1
	mov	NUM_DESIG_CP, cx
	mov	[si].NUM_DESIGNATES, cx
	jmp	short SET_TO_SYSTEM_CP

endif

CODE_PAGE_FOUND:
        MOV     AX,WORD PTR [DI].KC_ENTRY_PTR
        MOV     WORD PTR CP_TAB_OFFSET,AX
        MOV     AX,WORD PTR [DI].KC_ENTRY_PTR+2
        MOV     WORD PTR CP_TAB_OFFSET+2,AX

DONE:
        MOV     SI,OFFSET DESIG_CP_BUFFER

        MOV     AX,CON_INSTALLED        ;  If CON is NOT installed THEN
        or      ax,ax
        JE      SYSTEM_CP
        JMP     short GET_DESIG_CPS

SYSTEM_CP:
        MOV     CX,1
        MOV     NUM_DESIG_CP,CX                 ; Set number of CPs = 1
        MOV     [SI].NUM_DESIGNATES,CX

        MOV     DL,[BP].RET_CODE_2      ; Check if code page parm
        or      dl,dl                   ;    was specified
        JNE     SET_TO_SYSTEM_CP

        MOV     DX,[BP].CODE_PAGE_PARM
        MOV     [SI].DESIG_CP_ENTRY,DX  ; Load specified code page into
        JMP     READY_TO_BUILD_TABLE    ;      designated code page list

SET_TO_SYSTEM_CP:
        CALL    FIND_FIRST_CP           ; Call routine that sets the first
        or      ax,ax                   ;   table found in the Keyb Def file
        JE      SET_TO_SYSTEM_CP2       ;       to the system code page
        JMP     ERROR4

SET_TO_SYSTEM_CP2:
        MOV     SYS_CODE_PAGE,BX
        MOV     [BP].CODE_PAGE_PARM,BX
        MOV     [SI].DESIG_CP_ENTRY,BX  ;    Move sys CP into desig list
        JMP     READY_TO_BUILD_TABLE

GET_DESIG_CPS:                          ;  ELSE
        MOV     AX,0AD03H
        PUSH    CS                      ; Make sure ES is set
        POP     ES
        LEA     DI,DESIG_CP_BUFFER
        MOV     CX,DESIG_CP_BUF_LEN
        INT     2FH                     ; Get all designated code pages
        JNC     SET_DESIG_VARIABLES     ;  from console
        JMP     ERROR5

SET_DESIG_VARIABLES:
        MOV     CX,[SI].NUM_DESIGNATES
        ADD     CX,[SI].NUM_HW_CPS
        MOV     NUM_DESIG_CP,CX                 ; Set number of Designated CPs

BUFFER_CREATED:
        MOV     AX,0AD02H
        INT     2FH                     ; Get invoked code page

SET_TO_CP_INVOKED:
        MOV     DL,[BP].RET_CODE_2      ; IF code page parm was specified
        or      dl,dl
        JNE     SET_TO_INVOKED_CP

        MOV     CX,NUM_DESIG_CP
        MOV     DESIG_LIST,SI
        JMP     short TEST_IF_DESIGNATED

SET_TO_INVOKED_CP:
        CMP     AX,1                    ; IF a code page has been invoked
        JNE     SET_TO_INVOKED_CP3

        CALL    FIND_FIRST_CP           ; Call the routine that sets the
        or      ax,ax                   ; first code page in the Keyb Def
        JE      SET_TO_INVOKED_CP2      ;  file to the system code page
        JMP     ERROR4

SET_TO_INVOKED_CP2:
        MOV     [BP].CODE_PAGE_PARM,BX
        MOV     SYS_CODE_PAGE,BX

        JMP     short TEST_IF_DESIGNATED

SET_TO_INVOKED_CP3:
        MOV     [BP].CODE_PAGE_PARM,BX

TEST_IF_DESIGNATED:
        MOV     DX,[BP].CODE_PAGE_PARM
        CMP     [SI].DESIG_CP_ENTRY,DX  ; Is Code page specified in the list
        JE      CODE_PAGE_DESIGNATED    ;   of designated code pages ?

NEXT_DESIG_CP:
        ADD     SI,2                    ; Check next code page
        DEC     CX                      ; If all designated code pages have
        JNZ     TEST_IF_DESIGNATED      ;   been checked Then ERROR
        JMP     ERROR6

CODE_PAGE_DESIGNATED:
        CMP     SYS_CODE_PAGE,0
        JNE     READY_TO_BUILD_TABLE
        CMP     AX,1                    ; IF a code page has been invoked
        JE      READY_TO_BUILD_TABLE
        CMP     [BP].CODE_PAGE_PARM,BX  ; IF Invoked CP <> Specified CP
        JE      READY_TO_BUILD_TABLE    ;        Issue warning

;***************************************************************************
        PUSH    BX
        PUSH    CX
        MOV     AX,WARNING_1
        MOV     BX,STDOUT
        XOR     CX,CX
        MOV     DH,UTILITY_MSG_CLASS
        XOR     DL,DL
        CALL    SYSDISPMSG
        POP     CX
        POP     BX
;***************************************************************************


READY_TO_BUILD_TABLE:

        MOV     AX,KEYB_INSTALLED
        or      ax,ax                   ; Else if KEYB has not been installed
        JNE     BUILD_THE_TABLE

        CALL    FIND_SYS_TYPE           ; Determine system type for INT 9 use

;------ LOAD IN SPECIAL INT 9 HANDLER AND SPECIAL TABLES

        CALL    INSTALL_INT_9           ; Install INT 9

        CALL    FIND_KEYB_TYPE          ; Determine keyboard type table use

BUILD_THE_TABLE:
        CALL    TABLE_BUILD             ; Build the TEMP_SHARED_DATA_AREA

CHECK_ERRORS:
                                        ; Take appropriate action considering
        MOV     CX,TB_RETURN_CODE       ;  return codes from TABLE_BUILD
        jcxz    CHECK_FOR_INV_CP        ; If return code is not 0

        MOV     AX,KEYB_INSTALLED       ; If KEYB has not been installed,
        or      ax,ax
        JNE     CHECK_ERROR_CONTINUE

        CALL    REMOVE_INT_9            ;     remove installed vector

CHECK_ERROR_CONTINUE:
        CMP     CX,1                    ; If return code = 1
        JNE     CHECK_ERROR2
        JMP     ERROR1                  ;     display error message

CHECK_ERROR2:
        CMP     CX,2                    ; If return code = 2
        JNE     CHECK_ERROR3
        JMP     ERROR2

CHECK_ERROR3:
        CMP     CX,3                    ; If return code = 3
        JNE     CHECK_ERROR4
        JMP     ERROR3                  ;     display error message

CHECK_ERROR4:
        CMP     CX,4                    ; If return code = 4
        JNE     CHECK_ERROR5A
        JMP     ERROR4                  ;     display error message

CHECK_ERROR5A:
        CMP     CX,5                    ; If return code = 5
        JNE     CHECK_ERROR6A
        JMP     ERROR5A                         ;     display error message

CHECK_ERROR6A:
        JMP     ERROR6A                         ; If return code not 0,1,2,3,4 then
                                        ;      display error message
CHECK_FOR_INV_CP:
        MOV     CX,CPN_INVALID          ; Check if any CPs were not loaded
        jcxz    TERMINATE               ;   If some were invalid, issue
                                        ;       warning message

;***************************************************************************
        PUSH    BX
        PUSH    CX
        MOV     AX,NOT_SUPP
        MOV     BX,STDOUT               ;  WARNING
        XOR     CX,CX                   ;   MESSAGE
        MOV     DH,UTILITY_MSG_CLASS
        XOR     DL,DL
        CALL    SYSDISPMSG
        POP     CX
        POP     BX
;***************************************************************************

TERMINATE:
        MOV     AH,3EH                  ;  Close the KEYBOARD.SYS file
        MOV     BX,KEYBSYS_FILE_HANDLE  ;  if open
        or      bx,bx
        JE      KEYB_EXIT
        INT     21H

        MOV     AX,KEYB_INSTALLED
        or      ax,ax
        JE      KEYB_EXIT
        JMP     KEYB_EXIT_NOT_RESIDENT

KEYB_EXIT:
        TEST    SD.KEYB_TYPE,G_KB       ; Q..FERRARI G??
        JZ      NO_FERRARI_G            ; N..LEAVE NUMLK ALONE
        TEST    SD.SYSTEM_FLAG,PC_XT    ;   Q..PC/XT?
        JNZ     NO_FERRARI_G            ;   Y..LEAVE NUMLK ALONE
        TEST    SD.KEYB_TYPE,P_KB       ;      Q..FERRARI P??
        JNZ     NO_FERRARI_G            ;      Y..LEAVE NUMLK ALONE

;***CNS
        CMP     SECURE_FL,1             ; IF SECURITY FLAG SET
        JNE     NO_FERRARI_G            ; DON'T TURN ON NUM_LK

;***CNS
        CALL    NUMLK_ON                ;    N..TURN NUMLK ON

NO_FERRARI_G:
        TEST    SD.SYSTEM_FLAG,EXT_16   ; extended INT 16 support?
        JZ      SKIP_CTRL_COPY
                                       ; Yes, load extened CTRL case table

        MOV     CX,L_CTRL_TAB          ; CX = LENGTH OF EXTENDED TABLE
        MOV     SI,OFFSET CS:RPL_K8    ; POINT TO EXT. CTRL TABLES
        MOV     DI,OFFSET CS:K8        ; POINT TO REGULAR CTRL TABLE
        CLD
        REP     MOVSB                  ; OVERLAY WITH EXT. CTRL TABLE

SKIP_CTRL_COPY:
        CALL    INSTALL_INT_9_NET       ; Let the network know about INT 9
                                        ;     (if the network is installed)
        CALL    INSTALL_INT_2F          ; Install INT 2F

        MOV     AX,0AD82H               ; Activate language
        MOV     BL,-1
        INT     2FH

        MOV     AH,31H                  ; Function call to terminate but stay
        XOR     AL,AL                   ;   resident
        MOV     DI,OFFSET SD_DEST_PTR   ; Initialize destination ptr

        MOV     DX,ES:TSD.RESIDENT_END  ; Get resident end

        CALL    COPY_SDA_SETUP          ; Set up move common code

        JMP     COPY_SD_AREA            ; Jump to proc that copies area in new
                                        ;       part of memory

;***************************** CNS **************************************
ERR1ID:
;************************************************************************

        MOV     AX,INV_I                ; invalid ID message
        MOV     BX,STDOUT               ;  to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,INVALID_PARMS
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     KEYB_EXIT_NOT_RESIDENT
ERR2ID:
;***************************************************************************

        MOV     AX,INV_COMBO            ; invalid combination message
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,INVALID_PARMS
        MOV     EXIT_RET_CODE,AL

;**************************************************************************
        JMP     KEYB_EXIT_NOT_RESIDENT
;***************************** CNS ****************************************

ERROR1:
;***************************************************************************
        MOV     AX,INV_L                ; invalid language code
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message

        MOV     AL,INVALID_PARMS
        MOV     EXIT_RET_CODE,AL
;***************************************************************************

        JMP     KEYB_EXIT_NOT_RESIDENT
ERROR2:
;***************************************************************************
        MOV     AX,INV_CP               ; invalid code page message
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message

        MOV     AL,INVALID_PARMS
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     KEYB_EXIT_NOT_RESIDENT
ERROR3:
;***************************************************************************

        MOV     AX,INV_S                ; invalid syntax message
        MOV     BX,STDOUT               ; to standard out
;***CNS

        LEA     DI,STRING_HOLDER        ;Set PTR to look at the STRING
        PUSH    SI                      ;Save current SI index
        PUSH    AX
        MOV     AX,OLD_PTR              ;Last locale of the end of a PARAM
        SUB     CUR_PTR,AX              ;Get the length via the PSP
        MOV     SI,CUR_PTR
        MOV     CX,SI                   ;Save it in CX to move in the chars
        POP     AX                      ;Restore the PTR to the command line position

        MOV     SI,OLD_PTR              ;Last locale of the end of a PARAM
        REP     MOVSB                   ;Move in the chars until no more

        LEA     DI,STRING_HOLDER        ;Set PTR to look at the STRING


        POP     SI                      ;Restore the PTR to the command line position

        MOV     CX,1                    ;One replacement
        MOV     PTR_TO_COMLIN,DI        ; language code asciiz string


        PUSH    AX
        MOV     AX,DS                   ; language code asciiz string
        MOV     SEG_OF_COMLIN,AX
        POP     AX

        MOV     AX,ERR_PART
ifdef	BILINGUAL
	or	ax,ax
	jnz	ERR03_GO
	mov	ax,8			; Value Disallow
ERR03_GO:
endif
        LEA     SI,SUBLIST_COMLIN
        MOV     DH,PARSE_ERR_CLASS      ; parse error message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,INVALID_PARMS
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     short KEYB_EXIT_NOT_RESIDENT
ERROR4:
;***************************************************************************

        MOV     AX,INV_FN               ; bad or missing file message
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,BAD_KEYB_DEF_FILE
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     short KEYB_EXIT_NOT_RESIDENT
ERROR5:
;***************************************************************************

        MOV     AX,INV_CON_Q            ; CON code page not available.
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,CONSOLE_ERROR
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     short KEYB_EXIT_NOT_RESIDENT
ERROR5A:
;***************************************************************************

        MOV     AX,MEMORY_OVERF                 ; not enough resident memory.
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,MEMORY_OVERFLOW
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     short KEYB_EXIT_NOT_RESIDENT
ERROR6:
;***************************************************************************

        MOV     AX,NOT_DESIG            ; code page not prepared.
        MOV     BX,STDOUT               ; to standard out
        XOR     CX,CX                   ; no substitutions
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        CALL    SYSDISPMSG              ; display message
        MOV     AL,CP_NOT_DESIGNATED
        MOV     EXIT_RET_CODE,AL

;***************************************************************************
        JMP     short KEYB_EXIT_NOT_RESIDENT
ERROR6A:
;***************************************************************************

        MOV     NUMBER_HOLDER,BX        ; transfer number to temp loc.
        LEA     SI,NUMBER_HOLDER        ; sublist points to...
        MOV     PTR_TO_NUMBER,SI        ; code page word
        MOV     AX,NOT_VALID            ; display 'Code page requested....'
        MOV     BX,STDOUT               ; to standard out
        MOV     CX,1                    ; one replacement
        MOV     DH,UTILITY_MSG_CLASS    ; utility message
        XOR     DL,DL                   ; no input
        LEA     SI,SUBLIST_NUMBER       ; ptr to sublist
        CALL    SYSDISPMSG

        MOV     AL,KEYB_TABLE_NOT_LOAD
        MOV     EXIT_RET_CODE,AL

;***************************************************************************

KEYB_EXIT_NOT_RESIDENT:
        MOV     AH,04CH
        MOV     AL,QUERY_CALL           ; Check if this was a query call
        or      al,al
        JNE     KEYB_EXIT3              ;  IF yes then EXIT

        MOV     AL,EXIT_RET_CODE        ; Check if return code was valid
        or      al,al
        JNE     KEYB_EXIT3              ;  IF not then EXIT

COPY_INTO_SDA:
        MOV     AX,0AD82H               ; Activate language
        MOV     BL,-1
        INT     2FH

        MOV     AH,04CH
        MOV     AL,EXIT_RET_CODE
        MOV     DI,WORD PTR SHARED_AREA_PTR+2   ; Initialize destination ptr
        MOV     ES,WORD PTR SHARED_AREA_PTR
        MOV     DX,[BP].RESIDENT_END

        CALL    COPY_SDA_SETUP         ; Set up move common code

        JMP     COPY_SD_AREA           ; Jump to proc that copies area in new

KEYB_EXIT3:
        MOV     AL,EXIT_RET_CODE
        MOV     DI,WORD PTR SHARED_AREA_PTR+2   ; Initialize destination ptr
        MOV     ES,WORD PTR SHARED_AREA_PTR
        MOV     ES:[DI].TABLE_OK,1
        INT     21H

KEYB_COMMAND  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Procedure: COPY_SDA_SETUP
;
; Description:
;     Common setup logic for exit
;
; Input Registers:
;     N/A
;
; Output Registers:
;     N/A
;
; Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COPY_SDA_SETUP  PROC    NEAR

        push    ax                      ;save existing values
        push    es
        mov     ax,cs:[2ch]             ;check offset for address containin environ.
        or      ax,ax
        je      NO_FREEDOM

        mov     es,ax
        mov     ax,4900H                ;make the free allocate mem func
        int     21h

NO_FREEDOM:
        pop     es                      ;restore existing values
        push    bx
                                        ;Terminate and stay resident
        mov     bx,4                    ;1st close file handles
                                        ;STDIN,STDOUT,STDERR
closeall:
        mov     ah,3eh
        int     21h
        dec     bx
        jnz     closeall

        pop     bx
        pop     ax

        MOV     CL,4                    ; Convert into paragrahs
        SHR     DX,CL
        INC     DX

        MOV     SI,OFFSET SD_SOURCE_PTR         ; Initialize source ptr
        XOR     BP,BP
        LEA     BX,[BP].ACTIVE_LANGUAGE
        ADD     DI,BX                   ; Adjust for portion not copied
        ADD     SI,BX                   ; Adjust for portion not copied

        MOV     CX,SD_LENGTH            ; Set length of SHARED_DATA_AREA
        SUB     CX,BX                   ; Adjust for portion not copied

        RET

COPY_SDA_SETUP  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Procedure: NUMLK_ON
;
; Description:
;     Turn  Num Lock On.
;
; Input Registers:
;     N/A
;
; Output Registers:
;     N/A
;
; Logic:
;     Set Num Lock bit in BIOS KB_FLAG
;     Issue Int 16 to update lights
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NUMLK_ON     PROC

        PUSH    ES
        PUSH    AX

        MOV     AX,DATA
        MOV     ES,AX

        OR      ES:KB_FLAG,NUM_STATE    ; Num Lock state active
        MOV     AH,1                    ; Issue keyboard query call to
        INT     16H                     ;  have BIOS update the lights

        POP     AX
        POP     ES
        RET

NUMLK_ON   ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: INSTALL_INT_9
;
; Description:
;     Install our INT 9 driver.
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;       Get existing vector
;       Install our vector
;       Return
;

INSTALL_INT_9        PROC

        PUSH    ES

        MOV     AH,35H                  ; Get int 9 vector
        MOV     AL,9
        INT     21H                     ; Vector in ES:BX

        PUSH    ES                      ; Save segment ES:
        PUSH    CS
        POP     ES
        MOV     WORD PTR ES:SD.OLD_INT_9,BX ; Offset
        POP     AX                      ; Recover ES: segment
        MOV     WORD PTR ES:SD.OLD_INT_9+2,AX ; Segment

        MOV     AH,25H
        MOV     AL,9
        MOV     DX,OFFSET KEYB_INT_9    ; Let DOS know about our handler
        INT     21H

        POP     ES
        RET

INSTALL_INT_9        ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: INSTALL_INT_9_NET
;
; Description:
;
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;       IF network is installed THEN
;         Let it know about our INT 9
;       Return
;

INSTALL_INT_9_NET    PROC

        PUSH    ES

        TEST    SD.SYSTEM_FLAG,PC_NET   ; TEST FOR PC_NETWORK
                                        ; IF NOT THE NETWORK INSTALLED
        JZ      INSTALL_9_DONE_NET      ; SKIP THE PC NETWORK HANDSHAKE

                                        ; ES:BX TO CONTAIN INT 9 ADDR
        MOV     BX,OFFSET KEYB_INT_9
        MOV     AX,0B808H               ; FUNCTION FOR PC NETWORK TO INSTALL
                                        ; THIS ADDRESS FOR THEIR JUMP TABLE
        INT     2FH                     ; TELL PC_NET TO USE MY ADDR TO CHAIN TO

INSTALL_9_DONE_NET:
        POP     ES
        RET

INSTALL_INT_9_NET    ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: INSTALL_INT_2F
;
; Description:
;     Install our INT 2F drivers.
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;       Get existing vectors
;       Install our vectors
;       Return
;
;
INSTALL_INT_2F    PROC

        MOV     AH,35H                  ; Get int 2f vector
        MOV     AL,2FH
        INT     21H                     ; Vector in ES:BX

        PUSH    ES                      ; Save segment ES:
        PUSH    CS
        POP     ES
        MOV     WORD PTR ES:SD.OLD_INT_2F,BX ; Offset
        POP     AX                      ; Recover ES: segment
        MOV     WORD PTR ES:SD.OLD_INT_2F+2,AX ; Segment

        MOV     AH,25H                  ; Set int 9 vector
        MOV     AL,2FH
        MOV     DX,OFFSET KEYB_INT_2F   ; Vector in DS:DX
        INT     21H


        RET

INSTALL_INT_2F    ENDP

;
;
; Module: REMOVE_INT_9
;
; Description:
;     Remove our INT 9 driver.
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;       Get old vector
;       Install old vector
;       Return
;

REMOVE_INT_9        PROC

        PUSH    DS
        PUSH    ES
        MOV     ES,WORD PTR SHARED_AREA_PTR
        MOV     AX,WORD PTR ES:SD.OLD_INT_9+2   ; int 9 vector - segment
        MOV     DS,AX
        MOV     DX,WORD PTR ES:SD.OLD_INT_9     ; int 9 vector - offset

        MOV     AH,25H                  ; Set int 9 vector
        MOV     AL,9
        INT     21H

REMOVE_9_DONE:
        POP     ES
        POP     DS
        RET

REMOVE_INT_9             ENDP



IDLANG_CHK      PROC    NEAR

        mov     ax,fb.kl_id_code        ;get the id code from the table
        cmp     ax,[bp].id_parm         ;compare it to value taken
        jne     end_match               ;from the switch-- if found
        cmp     ALPHA,0                 ;a keyboard code was specified
        je      a_match                 ;no lang & a match

        mov     ax,fb.kl_lang_code      ;compare lang codes
        cmp     ax,[BP].LANGUAGE_PARM   ;they are equal
        je      a_match

        jmp     short end_match                 ;if not found go check next
                                        ;id for the same country

a_match:
        mov     good_match,1            ;report the ids match

end_match:
        ret

    IDLANG_CHK  ENDP
;*********************** CNS *******************;

;**********************************SCAN_ID***********************;
; New variables defined - NUM_ID,ADRSS_LANG,ID_PTR_SIZE,ID_FOUND
;****************************************************************;


SCAN_ID PROC    NEAR

        xor     di,di                   ;clear di to set at the
                                        ;beginning of KEYBSYS STRUCTURE


        lea     cx,[di].kh_num_ID+4     ; set number of bytes to read header

        mov     ah,3fh
        int     21h
        jnc     VAL5ID
        jmp     short BAD_TAB            ;bad table message

 VAL5ID:

        mov     cx,SIGNATURE_LENGTH
        mov     di,offset SIGNATURE
        mov     si,offset FB.KH_SIGNATURE
        repe    CMPSB
        je      ID_SPECIFIED
        jmp     short BAD_TAB



 ID_SPECIFIED:

        mov     ax,FB.KH_NUM_ID
        mov     NUM_ID,ax               ; save # of IDs
        mul     ID_PTR_SIZE             ; determine # of bytes to read
        push    ax                      ; save current # of bytes to read for
                                        ; ID values only
        mov     ax,FB.KH_NUM_LANG       ; add on lang data in table
        mul     LANG_PTR_SIZE           ; data that comes before the ID data
        mov     cx,ax                   ; save that value for the size compare
        mov     PASS_LANG,cx
        pop     ax                      ; restore the info for # of ID bytes to read

        add     cx,ax                   ; add that value to get total in CX
        mov     TOTAL_SIZE,cx           ; save the total size
        cmp     cx,size FILE_BUFFER
        jbe     READ_ID_TAB
        jmp     short BAD_TAB


READ_ID_TAB:
        mov     dx,offset FILE_BUFFER
        mov     ah,3fh                  ;read language table from
        int     21h                     ;keyb defn file
        jnc     READ_IDVAL
        jmp     short BAD_TAB

READ_IDVAL:

        mov     cx,NUM_ID
        mov     di,offset FILE_BUFFER
        add     di,PASS_LANG

SCAN_ID_TAB:

        mov     ax,[bp].ID_PARM
        cmp     [di].KP_ID_CODE,ax
        je      ID_HERE

        add     di,ID_PTR_SIZE
        dec     cx
        jne     SCAN_ID_TAB

        jmp     short FINALE

BAD_TAB:
        mov     ERR4ID,1
        jmp     short FINALE

ID_HERE:
        mov     ID_FOUND,1              ;reset ptr for
                                        ;current country
FINALE:
        ret

SCAN_ID         ENDP

;*******************************SCAN_ID END******;
;
; Module: BUILD_PATH
;
; Description:
;     Build the complete filename of the Keyboard Definition File
;*************************************WGR*********************
;     and open the file.
;+++++++++++++++++++++++++++++++++++++WGR+++++++++++++++++++++
;
; Input Registers:
;     DS - points to our data segment
;     ES - points to our data segment
;     BP - offset of parmeter list
;
; Output Registers:
;************************************WGR**********************
;     CARRY CLEAR
;           AX = HANDLE
;     CARRY SET (ERROR)
;           NONE
;++++++++++++++++++++++++++++++++++++WGR++++++++++++++++++++++
;    The complete filename will be available in FILE_NAME
;
; Logic:
;
;    Determine whether path parameter was specified
;    IF length is zero THEN
;****************************************WGR******************
;       Try to open file in ACTIVE directory
;       IF failed THEN
;         Try to open file in ARGV(0) directory
;         IF failed THEN
;           Try to open file in ROOT directory (for DOS 3.3 compatibility)
;           ENDIF
;         ENDIF
;       ENDIF
;    ELSE
;       Copy path from PSP to FILE_NAME memory area
;       Try to open USER SPECIFIED file
;++++++++++++++++++++++++++++++++++++++++WGR++++++++++++++++++
;
;

KEYBOARD_SYS    DB   '\KEYBOARD.SYS',00
KEYB_SYS_ACTIVE DB   'KEYBOARD.SYS',00
KEYB_SYS_LENG   EQU  14
KEYB_SYS_A_LENG EQU  13

ifdef JAPAN
PUBLIC          FILE_NAME
endif ; JAPAN
FILE_NAME       DB   128 DUP(0)
ifdef JAPAN
PUBLIC     keyb_table
keyb_table label byte             ; keyboard definition file search table
;               len  driver name sub type
           db    9, 'KEYAX.SYS', 1
           db    9, 'KEY01.SYS', 2
           db    9, 'KEY02.SYS', 3
           db    10,'KEYJ31.SYS',4
           db    0
endif ; JAPAN
FILE_NOT_FOUND  EQU  2
PATH_NOT_FOUND  EQU  3
;
;  Program Code
;

BUILD_PATH    PROC  NEAR

        CLD
        MOV     DI,OFFSET FILE_NAME     ; Get the offset of the filename
        MOV     CX,[BP].PATH_LENGTH     ; If path is specified then
        jcxz    APPEND_KEYB_SYS

        MOV     SI,[BP].PATH_OFFSET     ;   Get the offset of the path

        REPE    MOVSB                   ;   Copy each char of the specified

        MOV     AX,3D00H                ; Open the KEYBOARD.SYS file
        MOV     DX,OFFSET FILE_NAME
        INT     21H
        RET                             ;   path into the filename location

APPEND_KEYB_SYS:
        MOV     SI,OFFSET KEYB_SYS_ACTIVE ;  copy name for active directory
        MOV     CX,KEYB_SYS_A_LENG      ;  to file name variable.
        REPE    MOVSB

        MOV     AX,3D00H                ; try to open it.
        MOV     DX,OFFSET FILE_NAME
        INT     21H

        jnc     opened_ok               ; brif no error opening

        cmp     ax,PATH_NOT_FOUND       ; was it path?
        jz      open_err_1
        cmp     ax,FILE_NOT_FOUND       ; or file not found?
        jnz     open_err_2

open_err_1:
        CALL    COPY_ARGV0              ; yes....try ARGV(0) directory.
        MOV     AX,3D00H
        MOV     DX,OFFSET FILE_NAME
        INT     21H

        jnc     opened_ok               ; done if open ok

        cmp     ax,PATH_NOT_FOUND       ; if path or file not found, try root
        jz      open_err_3
        cmp     ax,FILE_NOT_FOUND
        jnz     open_err_2

open_err_3:
        MOV     SI,OFFSET KEYBOARD_SYS  ; try ROOT directory.
        MOV     DI,OFFSET FILE_NAME
        MOV     CX,KEYB_SYS_LENG
        REPE    MOVSB

        MOV     AX,3D00H
        MOV     DX,OFFSET FILE_NAME
        INT     21H

        jmp     short opened_ok

open_err_2:
        stc                             ; some other error, set error flag

opened_ok:

        RET

BUILD_PATH      ENDP


COPY_ARGV0  PROC

        PUSH    ES
        PUSH    DI
        PUSH    SI
        PUSH    CX

        MOV     DI,2CH                 ; Locate environment string
        MOV     ES,[DI]
        XOR     SI,SI

carv0_loop:
        cmp     word ptr es:[si],0      ; find ARGV(0) string
        jz      carv0_loop_exit
        inc     si
        jmp     carv0_loop

carv0_loop_exit:
        ADD     SI,4
        LEA     DI,FILE_NAME            ; move string to work area

carv0_loop1:
        MOV     AL,ES:[SI]
        MOV     [DI],AL
        INC     SI
        INC     DI
        cmp     byte ptr es:[si],0
        jnz     carv0_loop1

carv0_loop2:
        dec     di
        cmp     byte ptr [di],'\'       ; scan back to first character after "\"
        jz      carv0_loop2_exit
        cmp     byte ptr [di],0
        jnz     carv0_loop2

carv0_loop2_exit:
        INC     DI
        PUSH    CS
        POP     ES
        LEA     SI,KEYB_SYS_ACTIVE      ; copy in "KEYBOARD.SYS"
        MOV     CX,KEYB_SYS_A_LENG
        REPE    MOVSB

        POP     CX
        POP     SI
        POP     DI
        POP     ES
        RET

COPY_ARGV0  ENDP

;
;
; Module: FIND_FIRST_CP
;
; Description:
;     Check the keyboard definition file for the first code page
;
; Input Registers:
;     DS - points to our data segment
;     ES - points to our data segment
;     BP - offset of parmeter list
;
; Output Registers:
;           NONE
;
; Logic:
;   Open the file
;   IF error in opening file THEN
;       Display ERROR message and EXIT
;   ELSE
;       Save handle
;       Set address of buffer
;       READ header of Keyboard definition file
;       IF error in reading file THEN
;          Display ERROR message and EXIT
;       ELSE
;          Check signature for correct file
;          IF file signature is correct THEN
;             READ language table
;             IF error in reading file THEN
;                 Display ERROR message and EXIT
;             ELSE
;                 Use table to verify language parm
;                 Set pointer values
;                 IF code page was specified
;                     READ language entry
;                     IF error in reading file THEN
;                          Display ERROR message and EXIT
;                     ELSE
;                          READ first code page
;                          IF error in reading file THEN
;                              Display ERROR message and EXIT
;   RET
;
;

FIND_FIRST_CP PROC  NEAR

        PUSH    CX                      ; Save everything that
        PUSH    DX                      ;  that will be changed
        PUSH    SI
        PUSH    DI

        MOV     BX,KEYBSYS_FILE_HANDLE  ; Get handle
        MOV     DX,WORD PTR KEYBCMD_LANG_ENTRY_PTR   ; LSEEK file pointer
        MOV     CX,WORD PTR KEYBCMD_LANG_ENTRY_PTR+2 ;  to top of language entry
        MOV     AH,42H
        MOV     AL,0                    ; If no problem with
        INT     21H                     ;     Keyb Def file Then
        JNC     FIND_FIRST_BEGIN
        JMP     short FIND_FIRST_CP_ERROR4

FIND_FIRST_BEGIN:
        MOV     DI,AX
        MOV     CX,SIZE KEYBSYS_LANG_ENTRY-1 ; Set number
                                        ;       bytes to read header
        MOV     DX,OFFSET FILE_BUFFER
        MOV     AH,3FH                  ; Read language entry in
        INT     21H                     ;        keyboard definition file
        JNC     FIND_FIRST_VALID4       ; If no error in opening file then
        JMP     short FIND_FIRST_CP_ERROR4

FIND_FIRST_VALID4:

;************************** CNS *******;
        xor     ah,ah
        MOV     Al,FB.KL_NUM_CP
;************************** CNS *******;

        MUL     CP_PTR_SIZE             ; Determine # of bytes to read
        MOV     DX,OFFSET FILE_BUFFER   ; Establish beginning of buffer
        MOV     CX,AX
        CMP     CX,SIZE FILE_BUFFER     ; Make sure buffer is not to small
        JBE     FIND_FIRST_VALID5

        JMP   short FIND_FIRST_CP_ERROR4

FIND_FIRST_VALID5:
        MOV     AH,3FH                  ; Read code page table from
        INT     21H                     ;            keyboard definition file
        JNC     FIND_FIRST_VALID6       ; If no error in opening file then
        JMP     short FIND_FIRST_CP_ERROR4

FIND_FIRST_VALID6:
        MOV     CX,NUM_CP               ; Number of valid codes
        MOV     DI,OFFSET FILE_BUFFER   ; Point to correct word in table

        MOV     BX,[DI].KC_CODE_PAGE    ; Get parameter
        XOR     AX,AX
        JMP     short FIND_FIRST_RETURN

FIND_FIRST_CP_ERROR4:
        MOV     AX,4

FIND_FIRST_RETURN:
        POP     DI
        POP     SI
        POP     DX
        POP     CX

        RET

FIND_FIRST_CP  ENDP

        .xlist
MSG_SERVICES <MSGDATA>
MSG_SERVICES <LOADmsg,DISPLAYmsg,CHARmsg,NUMmsg>
MSG_SERVICES <KEYB.CL1>
MSG_SERVICES <KEYB.CL2>
MSG_SERVICES <KEYB.CLA>
        .list
;
; Temp Shared Data Area
; Contains data which is required by
; both the resident and transient KEYB code.
; All keyboard tables are stored in this area
; Structures for this area are in file KEYBSHAR.INC
;
        db      'TEMP SHARED DATA'
SD_SOURCE_PTR   LABEL      BYTE
TEMP_SHARED_DATA SHARED_DATA_STR <>

CODE    ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybcpsd.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBCPSD.INC
;; ----------
;;
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBCPSD.ASM
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    COPY_SD_AREA:NEAR     ;;
                                       ;;
        EXTRN    SD_DEST_PTR :BYTE     ;;
        EXTRN    SHARED_DATA :BYTE     ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\commsubs.asm ===
PAGE	,132
	TITLE	 MS DOS 5.0 - NLS Support - KEYB Command

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  MS DOS 5.0 - NLS Support - KEYB Command
;  (C) Copyright Microsoft Corp 1987-1991
;
;  File Name:  COMMSUBS.ASM
;  ----------
;
;  Description:
;  ------------
;	 Common subroutines used by NLS support
;
;  Documentation Reference:
;  ------------------------
;	 None
;
;  Procedures Contained in This File:
;  ----------------------------------
;
;	 FIND_HW_TYPE - Determine the keyboard and system unit types and
;	       set the corresponding flags.
;
;  Include Files Required:
;  -----------------------
;	 None
;
;  External Procedure References:
;  ------------------------------
;	 FROM FILE  ????????.ASM:
;	      ????????? - ???????
;
;  Change History:
;  ---------------
;  Sept 1989 For 4.02.
;		Add required JMP $+2 between OUT/IN in KEYB_SECURE,
;		remove unnecessary code and re-document routine.
;		Remove unnecessary PUSH/POP's around call to KEYB_SECURE.
;		Fix bug in FIND_KEYB_TYPE of READ ID flags not being
;		cleared on PS/2's when keyboard is security locked.
;		Clean up BIOS DATA & Extended DATA area access, use ES:.
;		Arrange KB type checks into special case group and 8042.
;		Fix delay loop timeout bug at WT_ID with REFRESH BIT type
;		fixed timeout delay of 15ms.  When the KBX flag is set
;		by BIOS, the READ_ID is done and PORT 60h is ID_2 byte.
;		AT (FCh) type machines all have the Refresh Bit at 61h.
;		Change SND_DATA_AT proc to a general send command routine
;		with REFRESH BIT timout logic and move the P-Layout test
;		into FIND_KEYB_TYPE.  Allows P-kb on all 8042 systems.
;		Add untranslated ID_2 byte to P-layout support for newer
;		PS/2's with hardware logic instead of 8042 if AT type.
;
;  Feb 1990 For 4.03.
;  PTM 6660	Add default to PC_386 type for new/unsupported system.
;		Move determination code from KEYBI9C.ASM for original PC.
;		Add Patriot/Sebring determination code for HOT Replug
;		so that INT 9 handler can alter keyboard Scan Code set.
;		Unknown system default= PC_386 with Patriot/Sebring test.
;		Add EXT_122 check for 122 key keyboard to SYSTEM_FLAG.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	PUBLIC	FIND_SYS_TYPE
	PUBLIC	FIND_KEYB_TYPE
	PUBLIC	HW_TYPE 
	PUBLIC	SECURE_FL
ifdef JAPAN
                                        ;       EXTRN's to KEYBI9C.ASM
        EXTRN   BEEP_DELAY:WORD         ; Value for error beep delay
        EXTRN   S_122_MARKER:BYTE       ; 122 key marker F8 or E0
        EXTRN   READ_ID2:BYTE           ; Second byte of last READ ID
        EXTRN   SCAN_CODE_SET:BYTE      ; 01 for non SBCS keyboard (default)
                                        ; 81h or 82h for DBCS keyboard
                                        ; This value is used at hot replug.
        EXTRN   keyb_table:byte         ; keyboard search table
        EXTRN   FILE_NAME:byte          ; keyboard definition file name
endif ; JAPAN

	INCLUDE KEYBEQU.INC
	INCLUDE KEYBCPSD.INC
	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBI9C.INC
	INCLUDE KEYBCMD.INC
	INCLUDE DSEG.INC
	INCLUDE POSTEQU.INC
ifdef JAPAN
        INCLUDE KEYBDCL.INC
endif ; JAPAN


CODE	SEGMENT PUBLIC 'CODE'

	ASSUME	CS:CODE,DS:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: FIND_SYS_TYPE
;
;  Description:
;      Determine the type of system we are running on.
;      SYSTEM_FLAG (in active SHARED_DATA) are set to
;      indicate the system type.
;      This routine is only called the first time KEYB is being installed.
;
;
;  Input Registers:
;      DS - points to our data segment
;
;  Output Registers:
;      NONE
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ROM	SEGMENT AT	0F000H
		ORG	0FFFBH
SYSROM_DATE	DW	?		; OFFSET OF ROM YEAR DIGIT

PC1DATE_ID	EQU	03138H		; YEAR ROM WAS RELEASED IN ASCII

		ORG	0FFFEH
ROMID		DB	?
					; SEGMENT F000. (F000:FFFE)

ROMPC1		EQU	0FFH		; ID OF PC1 hardware
ROMXT		EQU	0FEH		; ID OF PC-XT/PORTABLE hardware
ROMAT		EQU	0FCH		; ID OF PCAT
ROMXT_ENHAN	EQU	0FBH		; ID OF ENHANCED PCXT
ROMPAL		EQU	0FAH		; ID FOR PALACE
ROMLAP		EQU	0F9H		; ID FOR PC LAP (P-14)
ROM_RU_386	EQU	0F8H		; ID FOR ROUNDUP-386

ROM	ENDS

ifdef JAPAN
RTN_EXT_BIOS_DATA_SEG   EQU     0C1H    ; INT15H SUB FUNCTION  M005 -- JP9009
endif ; JAPAN
ROMEXT	SEGMENT AT 00000H		; ADDRESS SHOULD NOT BE FIXED AT 09FC0H
					; This just a dummy segment value, as
		ORG	0003BH		;  INT 15h - function C1 call will load
KEYBID1 	DB	?		;  ES: dynamically depending on where
					;  the ROMEXT segment is located.
					;  (9FC0 was only for old 640K systems)
ifdef JAPAN
                ORG     00117H          ;                    ;JP9009
EXT_BIOS_DATA_KBD_ID    DW      ?       ; KEYBOARD ID(xxABH) ;JP9009
endif ; JAPAN
ROMEXT	ENDS				;  ( ES:003B )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_SYS_TYPE	       PROC  NEAR

	MOV	AX,ROM			; Set segmant to look at ROM
	MOV	DS,AX			;    using the data segment
	ASSUME	DS:ROM

	MOV	AX,SYSROM_DATE		; Get BIOS year date
	PUSH	AX			; save it on stack
	MOV	AL,ROMID		; Get hardware ID
	PUSH	AX			; save it

	PUSH	CS			; Set data seg back to code
	POP	DS
	ASSUME	DS:CODE 

	MOV	AH,092H 		; SET INVALID CALL FOR INT16  83 KEYS
	INT	16H			; CALL BIOS
	CMP	AH,80H			; IS EXTENDED INTERFACE THERE? 101/102
	JA	CHECK_PC_NET		;  NO, SKIP FLAG

	OR	SD.SYSTEM_FLAG,EXT_16	; Default is extended INT 16 support

	MOV	AH,0A2H 		; SET INVALID CALL FOR INT16  101 KEYS
	INT	16H			; CALL BIOS
	CMP	AH,80H			; IS EXTENDED INTERFACE THERE? 122/
	JA	CHECK_PC_NET		;  NO, SKIP FLAG

	OR	SD.SYSTEM_FLAG,EXT_122	; Also extended 122 keyboard support

CHECK_PC_NET:
	MOV	AH,30H			; GET DOS VERSION NUMBER
	INT	21H			; MAJOR # IN AL, MINOR # IN AH
	CMP	AX,0A03H		; SENSITIVE TO 3.10 OR >
	JB	CHECK_SYSTEM		; EARLIER VERSION OF DOS NOTHING
					; WAS ESTABLISHED FOR THIS SITUATION
	PUSH	ES			; Save ES just in case
	MOV	AX,3509H		; GET INT VECTOR 9 CONTENTS
	INT	21H			; ES:BX WILL = CURRENT INT9 VECTOR
					; SEE IF WE ARE THE 1ST ONES LOADED
	MOV	CX,ES			; INTO THE INT 9.  WITH DOS 3.1 WE CAN
	POP	ES			; HANDSHAKE WITH THE PC NETWORK BUT
	CMP	CX,0F000H		; BUT NO ONE ELSE CAN BE HOOK IN FIRST
	JE	CHECK_SYSTEM		; INT VECTOR 9 POINTS TO ROM, OK

	MOV	AX,0B800H		; ASK IF PC NETWORK IS INSTALLED
	INT	2FH
	or	al,al			; not installed if al=0
	JE	CHECK_SYSTEM		; SOMEBODY HAS LINKED THE INT VECTOR 9
					; & I'M GOING TO DROP RIGHT IN AS USUAL
	OR	SD.SYSTEM_FLAG,PC_NET	; INDICATE PC NET IS RUNNING

CHECK_SYSTEM:
ifdef JAPAN
                                        ; Determine if REFRESH BIT works OK    ;AN012
        MOV     BEEP_DELAY,36           ; Set error beep delay for XT machines ;AN012
        XOR     CX,CX                   ; Clear timeout loop counter           ;AN012
CHECK_SYST5:                                                                   ;AN012
        IN      AL,PORT_B               ; Read current system status port      ;AN012
        AND     AL,REFRESH_BIT          ; Mask all but refresh bit             ;AN012
        LOOPNZ  CHECK_SYST5             ; Loop till we see the bit OFF         ;AN012
        JCXZ    CHECK_SYST7             ; Exit if it fails to go OFF           ;AN012
CHECK_SYST6:                                                                   ;AN012
        IN      AL,PORT_B               ; Read current system status port      ;AN012
        AND     AL,REFRESH_BIT          ; Mask all but refresh bit             ;AN012
        LOOPZ   CHECK_SYST6             ; Loop till we see the bit ON          ;AN012
        JCXZ    CHECK_SYST7             ; Exit if it fails to go ON            ;AN012
        MOV     BEEP_DELAY,19           ; Set Refresh delay loop constant      ;AN012
CHECK_SYST7:                                                                   ;AN012
        PUSH    ES                      ; Check for broken INT 16h BIOS        ;AN013
        MOV     AH,0C0h                 ; Configuration function               ;AN013
        INT     15h                     ; System services call                 ;AN013
        JC      CHECK_SYST8             ; Skip if not supported by system      ;AN013
                                        ;       Check Model/submodel/revision  ;AN013
        CMP     word ptr ES:[BX+2],019F8h ; Initial ship level of 122 broken   ;AN013
        JNE     CHECK_SYST8             ; Skip if not broken INT 16h model/sub ;AN013
        CMP     byte ptr ES:[BX+4],005h ; Is it the bad revision level         ;AN013
        JA      CHECK_SYST8             ; Skip if not the broken code          ;AN013
                                        ;  ELSE                                ;AN013
        MOV     S_122_MARKER,0          ; Change 122 key F8h marker to an 00h  ;AN013
                                        ; F8,19,05 and below do not support F8 ;AN013
CHECK_SYST8:                                                                   ;AN013
        POP     ES                      ; Restore                              ;AN013
endif ; JAPAN
	POP	AX			; get code back
	POP	BX			; get date back off of stack
					; Is the hardware a PCjr
					; Is the hardware a PC1 or XT ?
	CMP	AL,ROMXT
	JAE	ITS_AN_XT		; IF (FE) OR (FF) THEN ITS AN XT
	CMP	AL,ROMXT_ENHAN		; IF (FB) IT IS ALSO AN XT
	JNE	TEST_PC_AT		; IF not then check for next type

ITS_AN_XT:
	OR	SD.SYSTEM_FLAG,PC_XT	; system type
					; Check the ROM level in the system
	CMP	BX,PC1DATE_ID		; Is it the ORIGINAL PC1 version?
	JNE	SHORT FIND_SYS_END	; Done if not

	OR	SD.SYSTEM_FLAG,PC_81	; Else set the Original PC1 flag
	JMP	SHORT FIND_SYS_END

TEST_PC_AT:
					; Is the hardware an AT ?
	CMP	AL,ROMAT		; (FC)
	JNE	TEST_P12		; IF not then check for next type

	OR	SD.SYSTEM_FLAG,PC_AT	; system type with 8042 V2 interface

	JMP	SHORT FIND_SYS_END

TEST_P12:
	CMP	AL,ROMLAP		; IS this a Convertible (F9) (P12)?
	JNE	TEST_PAL		; IF not then check for next type
	OR	SD.SYSTEM_FLAG,PC_LAP	; system type
	JMP	SHORT FIND_SYS_END

TEST_PAL:
	CMP	AL,ROMPAL		; IS this a Model 30 (FA) (PALACE)?
	JNE	TEST_RU_386		; IF not then check for next type
	OR	SD.SYSTEM_FLAG,PC_PAL	; system type
ifdef JAPAN
        MOV     BEEP_DELAY,88           ; Set error beep delay for 8086 machine;AN012
endif ; JAPAN
	JMP	SHORT FIND_SYS_END

TEST_RU_386:
	CMP	AL,ROM_RU_386		; IS this a PS/2 with a 386 (F8)?
	JNE	TEST_SYS_NEW		; IF not then check for next type
	OR	SD.SYSTEM_FLAG,PC_386	; System type with 8042 V3
	CALL	SP_8042 		; Determine if 8042 is Patriot/Sebring
	JMP	SHORT FIND_SYS_END

TEST_SYS_NEW:
					; ASSUME 8042 TYPE IF UNKNOWN
	OR	SD.SYSTEM_FLAG,PC_386	; Default system type with 8042 V3
	CALL	SP_8042 		; Determine if 8042 is Patriot/Sebring


FIND_SYS_END:

	RET

FIND_SYS_TYPE	    ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: FIND_KEYB_TYPE
;
;  Description:
;      Determine the type of keyboard we are running on.
;      KEYB_TYPE (in SHARED_DATA) is set to indicate the keyboard type.
;      This routine is only called the first time KEYB is being installed.
;      It is called after the new Interrupt 9 handler is installed.
;
;  Input Registers:
;      DS - points to our data segment
;
;  Output Registers:
;      NONE
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

HW_TYPE 	DW	0
SECURE_FL	DB	0

ifndef JAPAN
;RESERVED ADDRESS 013h BITS 1 & 2

PASS_MODE	equ	00000001B
SERVER_MODE	equ	00000010B
SECRET_ADD	equ	13h
PORT_70 	equ	70h		; CMOS ADDRESS PORT
PORT_71 	equ	71h		; CMOS DATA PORT
endif ; !JAPAN

ID_1		EQU	0ABh			; Keyboard ID_1 for FERRARI
TID_2		EQU	041h	   ;;AB41	; Keyboard ID_2 for FERRARI_G
ID_2U		EQU	083h	   ;;AB83	; Keyboard ID_2 for FERRARI_G
TID_2A		EQU	054h	   ;;AB54	; Keyboard ID_2 for FERRARI_P
ID_2AU		EQU	084h	   ;;AB84	; Keyboard ID_2 for FERRARI_P
ID_2JG		EQU	090h	   ;;AB90	; Keyboard ID_2 for JPN G
ID_2JP		EQU	091h	   ;;AB91	; Keyboard ID_2 for JPN P
ID_2JA		EQU	092h	   ;;AB92	; Keyboard ID_2 for JPN A

P_KB_ID 	DB	08

	extrn	pswitches:byte

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_KEYB_TYPE	      PROC  NEAR

; we need these code until be prepared code for NTVDM (MSKK)
; KKFIX Make it KK specific 10/17/96
ifdef JAPAN
;if 1 
;ifdef NOT_NTVDM

	PUSH	ES
	PUSH	DS

	MOV	AX,DATA 
	MOV	ES,AX			; ES points to BIOS data
	ASSUME	ES:DATA 

	MOV	AX,ROM			; Set segmant to look at ROM
	MOV	DS,AX			;    using the data segment
	ASSUME	DS:ROM

	MOV	AL,ROMID		; Get hardware ID

	PUSH	CS			; Set data segment to CODE
	POP	DS
	ASSUME	DS:CODE 

	test	pswitches,2		; /e switch true?
	jz	no_force_enh
	or	es:KB_FLAG_3,KBX	; force enhanced kbd support on
no_force_enh:

	MOV	HW_TYPE,G_KB		; Default keyboard is G_KB

	CMP	AL,ROMLAP		; IS this a P12? (CONVERTABLE)
	JNE	TEST_PC_XT_2		; IF not then check for next type

	MOV	HW_TYPE,P12_KB		; IF yes then set flag
	JMP	FIND_KEYB_END		; Done

TEST_PC_XT_2:
					; Is the hardware a PC1 or XT ?
	CMP	AL,ROMXT
	JAE	ITS_AN_XT_2		; IF FE OR FF THEN ITS AN XT
	CMP	AL,ROMXT_ENHAN		; IF FB IT IS ALSO AN XT
	JNE	TEST_PS_30_2		; IF not then check for next type

ITS_AN_XT_2:
	TEST	ES:KB_FLAG_3,KBX	; IS THE ENHANCED KEYBOARD INSTALLED?
	JZ	ITS_AN_XT_3
ifndef JAPAN
	JMP	SHORT FIND_KEYB_END	; Yes, exit
else ; JAPAN
	JMP	FIND_KEYB_END		; Yes, exit
endif ; JAPAN

ITS_AN_XT_3:
	MOV	HW_TYPE,XT_KB		; NO, normal XT keyboard
ifndef JAPAN
	JMP	SHORT FIND_KEYB_END
else ; JAPAN
	JMP	FIND_KEYB_END
endif ; JAPAN

TEST_PS_30_2:
	CMP	AL,ROMPAL		; IS this a PS/2 MODEL 30 or 25
	JNE	TEST_PC_AT_2		; IF not then check for next type

	MOV	AH,0C1H 		; Make extended bios data area call to
	INT	15H			; get the segment address for accessing
	JNC	ITS_AN_PS2_30		; the PALACE (only) keyboard byte area.
ifndef JAPAN
	JMP	SHORT FIND_KEYB_END	; JC   Assume Keyboard type G if error,
else ; JAPAN
	JMP	FIND_KEYB_END		; JC   Assume Keyboard type G if error,
endif ; JAPAN
					; Otherwise EXTENDED BIOS DATA RETURNED
					; in the ES: and ES:003Bh is keyboard

ITS_AN_PS2_30:				; ID byte reserved for PALACE.
					; Set segment to look at extended ROM
	ASSUME	ES:ROMEXT		;    using the ES: segment
					; SEG ES: value returned by INT15h - C1
	MOV	AL,KEYBID1		; Get keyboard ID

	ASSUME	ES:NOTHING		; Don't use ES: for anything else

	AND	AL,0FH			; Remove high nibble
	CMP	AL,P_KB_ID		; IF keyboard is a FERRARI P THEN
	JNE	ITS_AN_PS2_30G
	OR	HW_TYPE,P_KB		;    Set the HW_TYPE flag to P keyboard

ITS_AN_PS2_30G: 
	JMP	SHORT FIND_KEYB_END	; Done

					; (Insert any more special cases here.)

;	At this point, all special case or older keyboard/system
;	types have been determined and HW_TYPE correctly set.
;	(PC, XT, XT Enhansed, CONVERTABLE, Model 30/25)
;
;	Assume now that the system has an 8042 type keyboard
;	interface and can be sent a READ ID command to determine
ifndef JAPAN
;	the type of keyboard installed.  The old AT keyboard is
;	handled as a special case of no security bits set and no
;	response to a READ ID command.	If security bits are set
;	and no KBX flag is set as a result of the READ ID, then
;	the interface is assumed to be locked and the default of
;	G-keyboard is taken as the keyboard ID can not be read.
else ; JAPAN
;       the type of keyboard installed.  First we check to see if the          ;AN011
;       interface is inhibited by either the password lock (PS/2) or a         ;AN011
;       keylock.  If not, we set Read ID in process, clear last ID byte 2      ;AN011
;       read by the KEYBI9C INT 9h handler, send a READ ID command to the      ;AN011
;       keyboard and wait for the second ID byte save location to change.      ;AN011
;       A timeout of this operation indicates either an old AT style keyboard  ;M000
;       or no keyboard attached and we set the type of keyboard to AT_KB,      ;AN011
;       unless the KBX flag has been turned on by the /E switch, default G_KB. ;AN011
;       Any E0 will force KBX on, but APPS will not see it unless /E was used. ;AN011
;       Mouse/AUX conflicts are handled by an extra long delay here and a      ;AN011
;       retry loop, checking that the returned value for ID 2 is not invalid.  ;AN011
;                                                                              ;AN011
;       However if the interface is inhibited we will check to see if this     ;AN011
;       is a DBCS enabled machine, that does a READ ID during POST and saves   ;AN011
;       the keyboard ID in the extended data area, and use this data.  We      ;AN011
;       also set a flag indicating the security mode is set, so that the       ;AN011
;       correct Scan Code Set can be sent to the keyboard when it is unlocked. ;AN011
;       If not a DBCS machine we will again default to the G-keyboard.         ;M000
endif ; JAPAN

TEST_PC_AT_2:

	ASSUME	ES:DATA 		; READ ID COMMAND TO TEST FOR A KBX

ifndef JAPAN
	MOV	ES:KB_FLAG_3,RD_ID	; INDICATE THAT A READ ID IS BEING DONE
					;  and clear KBX flag if set
	MOV	AL,0F2H 		; SEND THE READ ID COMMAND
	CALL	SND_DATA_AT
					; Wait 40ms for READ ID to complete
	MOV	CX,DLY_15ms		; Load count for 15ms (15,000/15.086)

WT_ID:					;      Fixed time wait loop on AT's
	TEST	ES:KB_FLAG_3,KBX	; TEST FOR KBX SET by BIOS interrupt 9h
	JNZ	DONE_AT_2		; Exit wait loop if/when flag gets set
else ; JAPAN
        AND     ES:KB_FLAG_3,NOT LC_E0+LC_AB ; Clear hidden code and first ID  ;AN011
                                             ; Do not clear the KBX flag (/E)  ;AN011
        MOV     BL,5                    ; Set READ ID retry count to 5 tries   ;AN011
                                                                               ;AN011
        IN      AL,STATUS_PORT          ; Check for the KEYBOARD INHIBIT bit   ;AN011
        TEST    AL,KYBD_INH             ;  to see if server mode or keylocked. ;AN011
        JNZ     ASK_KEYBOARD            ; If not inhibited, ask the keyboard ID;AN011
        JMP     ASK_ROM_BIOS            ; If inhibited, see if POST read the ID;AN011

ASK_KEYBOARD:                           ;       ASK keyboard it's ID           ;AN011
        MOV     READ_ID2,0              ; Clear READ ID byte 2 save location   ;AN011
                                        ; INT 9h will now set it to ID byte 2  ;AN011
        OR      ES:KB_FLAG_3,RD_ID      ; INDICATE THAT A READ ID IS BEING DONE;AN011
                                        ;  and do not clear KBX flag set by /E ;AN011
if 0 ; can not send read id command. (MSKK)
	MOV	AL,0F2H 		; SEND THE READ ID COMMAND
	CALL	SND_DATA_AT
endif
                                        ; Wait 30ms for READ ID to complete    ;AN011
        MOV     CX,DLY_15ms*2           ; Load count for 30ms (15,000/15.086)*2;AN011

WT_ID:					;      Fixed time wait loop on AT's
        CMP     READ_ID2,0              ; TEST FOR BIOS interrupt 9h to set ID ;AN011
	JNZ	DONE_AT_2		; Exit wait loop if/when flag gets set

        TEST    ES:KB_FLAG_3,RD_ID+LC_AB; Test for unexpected scan code ending ;AN012
        JZ      ID_ERROR                ;  READ ID or clearing hang condition  ;AN012
endif ; JAPAN

	IN	AL,PORT_B		; Read current system status port
	AND	AL,REFRESH_BIT		; Mask all but refresh bit
	CMP	AL,AH			; Did it change? (or first pass thru)
	JZ	WT_ID			; No, wait for change, else continue

ifdef JAPAN
ID_ERROR:                               ; Read ID error exit, must clear CX    ;AN011
endif ; JAPAN
	MOV	AH,AL			; Save new refresh bit state
	LOOP	WT_ID			; WAIT OTHERWISE

					; BE SURE READ ID FLAGS GOT RESET
	AND	ES:KB_FLAG_3,NOT RD_ID+LC_AB ; Clear READ ID state flags
ifdef JAPAN
                                        ; As no ID byte 2 was read/set         ;AN011
        DEC     BL                      ; Decrement retry counter              ;AN011
        JNZ     ASK_KEYBOARD            ; Try five times to get a valid ID     ;AN011

        TEST    ES:KB_FLAG_3,KBX        ; Is the KBX flag ON from /E switch    ;AN011
        JNZ     KBX_OK                  ; If ON, use default G_KB as keyboard  ;AN011

        MOV     HW_TYPE,AT_KB           ; NO, AT KBD if no KBX and no security ;AN011
KBX_OK:                                                                        ;AN011
        JMP     SHORT FIND_KEYB_END     ; EXIT                                 :AN011
else ; !JAPAN
					; As no KBX flag set
	CALL	KEYB_SECURE		; SEE IF THE KEYBOARD SECURITY IS
					; ACTIVATED AT THIS POINT
	JNC	ASSUME_AT		; SECURITY UNAVAILABLE OR AN AT KB

	MOV	SECURE_FL,1		; SECURITY IS ACTIVE
	JMP	SHORT FIND_KEYB_END	; ASSUME IT IS A G_KB  WITH
					; NUM LOCK OFF
ASSUME_AT:
	MOV	HW_TYPE,AT_KB		; NO, AT KBD if no KBX and no security
	JMP	SHORT FIND_KEYB_END	; EXIT
endif ; !JAPAN

DONE_AT_2:				;      LAST PORT 60h VALUE IS ID_2 BYTE
ifndef JAPAN
	IN	AL,PORT_A		; Re-read last byte from keyboard input
else ; JAPAN
;AN011                                   ;  IN al,60h here causes missed ID2's

        MOV     AL,READ_ID2             ; Get the ID2 byte just read by KEYBI9C;AN011
        DEC     BL                      ; Decrement READ ID retry counter      ;AN011
        JZ      ID_USE                  ; Skip range check if retries exhausted;AN011

        CMP     AL,ID_1                 ; Did we get the ID1 byte twice        ;AN011
        JE      ASK_KEYBOARD            ; Retry read ID if this happens        ;AN011

        CMP     AL,TID_2                ; Check that the ID read is valid range;AN011
        JB      ASK_KEYBOARD            ; Try again if not 41h or greater      ;AN011
ID_USE:                                                                        ;AN011

;       M005 -- begin changed section

        CALL    SET_KBD_ID_TO_ROM_EXT   ; This is DBCS requirement. There are  ;JP9009
                                        ; five kinds of DBCS keyboards. We     ;JP9009
                                        ; need to distinguish them.            ;JP9009
        CMP     AL, ID_2JG              ; Was it old DBCS keyboards?           ;JP9009
        JAE     CHECK_WHAT_DBCS_KBD     ; Check what it is.                    ;JP9009
DONE_AT_FOR_G_P_TYPE:                                                          ;JP9011

;       M005 -- end changed section
endif ; JAPAN
	CMP	AL,TID_2A		; Was it the P-layout keyboard
	JE	DONE_AT_3		; Go set P type keyboard

	CMP	AL,ID_2AU		; Was it the P-layout untranslated
	JNE	DONE_AT_4		; Continue if not

DONE_AT_3:
	OR	HW_TYPE,P_KB		; Set HW_TYPE for P-layout keyboard
DONE_AT_4:
					; EXIT


FIND_KEYB_END:				; EXIT POINT
	MOV   AX,HW_TYPE		;      Get default or determined type
ifndef JAPAN
	MOV   SD.KEYB_TYPE,AX		;      Place into shared data area

	POP   DS
	POP   ES
else ; JAPAN
;       M005 -- begin changed section

;                                                                      ;JP9009
; New DBCS keyboards' ID is the same as that of SBCS 101/102 key       ;JP9009
; keyboard. So, we can distinguish them only by the language parameter ;JP9009
; string.                                                              ;JP9009
;                                                                      ;JP9009
;+ AN015-- Delete this out for now per request of Japanese.
;+         They can not assume ID's for other countries.  Actually we
;+         need a better way to determine if DBCS mode should be made active.
;+         This really need to be handled in the KEYBOARD.SYS files and set here.
;+
;AN015         MOV     CX, WORD PTR [BP].LANGUAGE_PARM; Get language specified.       ;JP9009
;AN015         CMP     CX, 'PJ'                ; Japanese keyboard?                   ;JP9009
;AN015         JE      DBCS_KEYBOARD                                                  ;JP9009
;AN015         CMP     CX, 'OK'                ; Korea keyboard?                      ;JP9009
;AN015         JE      DBCS_KEYBOARD                                                  ;JP9009
;AN015         CMP     CX, 'RP'                ; PRC keyboard?                        ;JP9009
;AN015         JE      DBCS_KEYBOARD                                                  ;JP9009
;AN015         CMP     CX, 'AT'                ; Taiwan keyboard?                     ;JP9009
;AN015         JNE     SBCS_KEYBOARD                                                  ;JP9009
;AN015 DBCS_KEYBOARD:                                                                 ;JP9009

;JP9110        CMP     WORD PTR [BP].LANGUAGE_PARM,'PJ' ; Japanese keyboard language  ;AN015
        CALL    IS_DBCS_KEYBOARD_LAYOUT ; DBCS layout?                  ;JP9110
        JNE     SBCS_KEYBOARD                    ; Skip DBCS if not            ;AN015

        OR      AX, DBCS_KB             ; Set it as DBCS keyboard              ;JP9009
        OR      SD.SYSTEM_FLAG,DBCS_OK  ; Set DBCS flag for INT 9 handler      ;AN013

; Determine keyboard sub type for Japanese keyboard
        push    si

        push    ds
        pop     es
	ASSUME	ES:CODE 

        MOV     si,offset FILE_NAME
        xor     dx,dx

        push    ax
find_filename:
        lodsb
        and     al,al                   ; extract only file name
        jz      check_def_file
        cmp     al,'\'
        jnz     find_filename

        mov     dx,si
        jmp     short find_filename

check_def_file:
        and     dx,dx
        jz      check_end

        lea     si,keyb_table
check_file2:
        xor     cx,cx
        lodsb
        and     al,al
        jz      check_end

        mov     cl,al
        mov     di,dx
        repe    cmpsb                   ; find match driver name
        jz      match_driver

        add     si,cx
        inc     si
        jmp     check_file2

match_driver:
        mov     cl,[si]

check_end:
        pop     ax                      ; key type
        or      al,cl                   ; add keyboard sub type

        pop     si

SBCS_KEYBOARD:                                                                 ;JP9009

;       M005 -- end changed section

	MOV   SD.KEYB_TYPE,AX		;      Place into shared data area

	POP   DS
	POP   ES
	RET

;       M005 -- begin changed section

ASK_ROM_BIOS:                                                                  ;JP9010
        OR      SD.SYSTEM_FLAG, SECURITY_ACTIVE ; Set keyboard LOCK active,    ;AN011
                                        ; it will clear when password entered  ;AN011
        MOV     SECURE_FL,1             ; SECURITY IS ACTIVE                   ;AN011
        PUSH    ES                      ;                                      ;JP9011
        MOV     AH, RTN_EXT_BIOS_DATA_SEG; GET EXTENDED BIOS DATA AREA SEGMENT ;JP9010
        INT     15H                     ;                                      ;JP9010
        ASSUME  ES:ROMEXT               ;                                      ;JP9009
;AN011        MOV     AL, BYTE PTR ES:EXT_BIOS_DATA_KBD_ID + 1;                      ;JP9010
        MOV     AX,ES:EXT_BIOS_DATA_KBD_ID ; Get both bytes of ID              ;AN011
        ASSUME  ES:DATA                 ;                                      ;JP9009
        POP     ES                      ; AH = HIGH BYTE OF KEYBOARD ID        ;JP9011
        JC      FIND_KEYB_END           ;      0 IF NOT SUPPORTED              ;JP9011
         CMP    AL,ID_1                 ; Is this valid READ ID data           ;AN011
         JNE    FIND_KEYB_END           ; Exit if not supported on this system ;AN011
         MOV    AL,AH                   ; Move READ ID byte 2 into register    ;AN011
         CMP     AL, ID_2JG             ;                                      ;JP9010
         JB      DONE_AT_FOR_G_P_TYPE   ; WE GOT KEYB_TYPE FROM ROM BIOS, SO   ;JP9011
                                        ; RETURN TO NORMAL PROCEDURE           ;JP9011
CHECK_WHAT_DBCS_KBD:                                                           ;JP9009
;JP9110        MOV     HW_TYPE, (DBCS_OLD_G_KB or DBCS_OLD_P_KB)                      ;JP9009
        OR      HW_TYPE, (DBCS_OLD_G_KB or DBCS_OLD_P_KB)               ;JP9110
        CMP     AL, ID_2JA              ; Was it old DBCS A keyboard?          ;JP9009
        JNE     SET_SCAN_TABLE          ; Go if old DBCS G/P keyboard.         ;JP9009
;JP9110        MOV     HW_TYPE, DBCS_OLD_A_KB                                         ;JP9009
        AND     HW_TYPE, NOT (DBCS_OLD_G_KB or DBCS_OLD_P_KB)           ;JP9110
        OR      HW_TYPE, DBCS_OLD_A_KB                                  ;JP9110
SET_SCAN_TABLE:                                                                ;JP9009
        MOV     AL,82h                  ; SELECT SCAN CODE SET 82              ;JP9009
        TEST    SD.SYSTEM_FLAG,PS_8042   ; If in passthru mode without 8042    ;JP9009
        JZ      CHANGE_SCAN_TABLE       ; then set scan code set 81            ;JP9009
        MOV     AL,81h                  ; SELECT SCAN CODE SET 81              ;JP9009
CHANGE_SCAN_TABLE:                                                             ;JP9009
        MOV     SCAN_CODE_SET, AL       ; 81h or 82h for old DBCS keyboard     ;JP9009
                                        ; This is also used at hot replug.     ;JP9009
        CMP     SECURE_FL, 1            ; IF SECURITY ACTIVE, RETURN           ;JP9010
;        JE      FIND_KEYB_END           ;                                      ;JP9010
        JNE      FIND_KEYB_SCAN                                        ; QFESP4
        JMP      FIND_KEYB_END                                         ; QFESP4
FIND_KEYB_SCAN:                                                        ; QFESP4
        MOV     AL,SCAN_CODE_CMD        ; SELECT SCAN CODE SET COMMAND         ;JP9009
        CALL    SND_DATA_AT             ; SEND IT DIRECTLY TO THE KEYBOARD     ;JP9009
        MOV     AL, SCAN_CODE_SET       ; SCAN CODE SET                        ;JP9009
        CALL    SND_DATA_AT             ; SEND IT TO THE KEYBOARD              ;JP9009
;        JMP     SHORT DONE_AT_4                                                ;JP9009
        JMP     DONE_AT_4                                              ; QFESP4


;  Module: SET_KBD_ID_TO_ROM_EXT
;  Description:
;       This routine sets keyboard ID to the corresponding extended BIOS
;       data area, even if ROM BIOS does not support 'Return Keyboard ID
;       (INT16H, AH=0AH)'. DBCS DOS supports it by some software if ROM
;       BIOS does not support it.
;       Input:
;               AL = High byte of keyboard ID
;                    Assumes low byte is 'ABH'.
;       Output:
;               none
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                      ;JP9009
SET_KBD_ID_TO_ROM_EXT   PROC    NEAR    ;                                      ;JP9009
        PUSH    ES                      ;                                      ;JP9009
        PUSH    AX                      ;                                      ;JP9009
        MOV     AH, RTN_EXT_BIOS_DATA_SEG;                                     ;JP9009
        INT     15H                     ; Get extended BIOS data area          ;JP9009
        JC      NOT_SET_KBD_ID          ;                                      ;JP9009
            ASSUME  ES:ROMEXT           ; EXTENDED BIOS DATA AREA              ;JP9009
            MOV     AH, AL              ; AH = KBD ID 2ND BYTE                 ;JP9009
            MOV     AL, 0ABH            ; ASSUME KBD ID = xxABH                ;JP9009
            MOV     ES:EXT_BIOS_DATA_KBD_ID, AX; Set KBD ID to ext. BIOS data  ;JP9009
            ASSUME  ES:DATA             ; NORMAL BIOS DATA AREA                ;JP9009
NOT_SET_KBD_ID:                                                                ;JP9009
        POP     AX                      ;                                      ;JP9009
        POP     ES                      ;                                      ;JP9009
        RET                             ;                                      ;JP9009
SET_KBD_ID_TO_ROM_EXT   ENDP            ;                                      ;JP9009
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                      ;JP9009
;       M005 -- end changed section

;                                                                       ;JP9110
;       Check if the specified keyboard layout is DBCS one or not.      ;JP9110
;                                                                       ;JP9110
;       Input:  BP = CMD_PARM_LIST                                      ;JP9110
;       Output: ZF = Zero if DBCS layout                                ;JP9110
;                    Non-Zero if not                                    ;JP9110
;                                                                       ;JP9110
IS_DBCS_KEYBOARD_LAYOUT         PROC    NEAR                            ;JP9110
        CMP     WORD PTR [BP].LANGUAGE_PARM,'PJ' ; Japanese layout?     ;JP9110
        RET                                                             ;JP9110
IS_DBCS_KEYBOARD_LAYOUT         ENDP                                    ;JP9110

endif ; JAPAN
else
;; BUGBUG
;; don't do the read id under nt because the keyboard h/w interrupt is
;; disabled at this moment. We should be able to get the keyboard type
;; from GetKeyboardType API after beta.
;; We simply pretend the keyboard is a 101/102 keyboard whithout checking
;; -- softpc only support 101/102 keys keyboard.

	PUSH	ES
	push	ds
	mov	ax, cs
	mov	ds, ax
	assume	ds:CODE

	MOV	AX,DATA 
	MOV	ES,AX			; ES points to BIOS data
	assume	es:DATA
	or	es:KB_FLAG_3,KBX	; force enhanced kbd support on
;;Set this to one will turn on the NUM lock when we are going to exit and keep
;; resident. This is not necessary because ntvdm host code controls num lock
;; states and the rest of system.
;;	mov	SECURE_FL, 1
;;
	mov	ax, G_KB		; enhanced keyboard
	mov	HW_TYPE, ax
	mov	SD.KEYB_TYPE, ax
	pop	ds
	POP	ES
	assume	ES:nothing
endif
	RET

FIND_KEYB_TYPE		ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: SND_DATA_AT
;
;  Description:
;	THIS ROUTINE HANDLES TRANSMISSION OF PC/AT COMMAND AND DATA BYTES
;	TO THE KEYBOARD AND RECEIPT OF ACKNOWLEDGEMENTS.  IT ALSO
;	HANDLES ANY RETRIES IF REQUIRED
;
;
;  Input Registers:
;      DS - points to our data segment
;      ES - points to the BIOS data segment
;
;  Output Registers:
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SND_DATA_AT PROC   NEAR 
	PUSH	AX			; SAVE REGISTERS
	PUSH	BX			; *
	PUSH	CX
	MOV	BH,AL			; SAVE TRANSMITTED BYTE FOR RETRIES
	MOV	BL,3			; LOAD RETRY COUNT

;----  WAIT FOR 8042 INTERFACE NOT BUSY

SD0:					; RETRY entry
	CALL	CHK_IBF 		; Wait for command to be accepted

	CLI				; DISABLE INTERRUPTS
	AND	ES:KB_FLAG_2,NOT (KB_FE+KB_FA+KB_ERR)	; CLEAR ACK, RESEND AND
							; ERROR FLAGS
	MOV	AL,BH			; REESTABLISH BYTE TO TRANSMIT
	OUT	PORT_A,AL		; SEND BYTE

	JMP	$+2			; Delay for 8042 to accept command
	STI				; ENABLE INTERRUPTS

;-----	WAIT FOR COMMAND TO BE ACCEPTED BY KEYBOARD

	MOV	CX,DLY_15ms		; Timout for 15 ms (15,000/15.086)

SD1:					;	Fixed timout wait loop on AT's
	TEST	ES:KB_FLAG_2,KB_FE+KB_FA; SEE IF EITHER BIT SET
	JNZ	SD3			; IF SET, SOMETHING RECEIVED GO PROCESS

	IN	AL,PORT_B		; Read current system status port
	AND	AL,REFRESH_BIT		; Mask all but refresh bit
	CMP	AL,AH			; Did it change? (or first pass thru)
	JE	SD1			; No, wait for change, else continue

	MOV	AH,AL			; Save new refresh bit state
	LOOP	SD1			; OTHERWISE WAIT

SD2:
	DEC	BL			; DECREMENT RETRY COUNT
	JNZ	SD0			; RETRY TRANSMISSION

	OR	ES:KB_FLAG_2,KB_ERR	; TURN ON TRANSMIT ERROR FLAG
	JMP	SHORT SD4		; RETRIES EXHAUSTED FORGET TRANSMISSION

SD3:
	TEST	ES:KB_FLAG_2,KB_FA	; SEE IF THIS IS AN ACKNOWLEDGE
	JZ	SD2			; IF NOT, GO RESEND

SD4:
	POP	CX			; RESTORE REGISTERS
	POP	BX
	POP	AX			; *
	RET				; RETURN, GOOD TRANSMISSION

SND_DATA_AT ENDP

ifndef JAPAN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; KEYBOARD SECURITY LOGIC
;
; CHECK THE CMOS RAM BYTE AT CMOS LOCATION HEX 013H
; CHECK TO SEE IF EITHER BITS 1 (PASSWORD) OR 2 (SERVER MODE) ARE SET ON
; IF EITHER BIT IS SET ON THE SYSTEM IS A MOD 50 on up
;    RETurn CARRY FLAG ON indicating keyboard interface may be disabled.
; OTHERWISE NO SECURITY ENABLED OR THE SYSTEM IS AN OLD AT.
;    RETurn CARRY FLAG OFF indicating keyboard interface not disabled.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

KEYB_SECURE	PROC	NEAR

	CLI				; DISABLE INTERRUPTS WHILE DOING
					; ADDRESS WRITE AND CMOS READ
	MOV	AL,SECRET_ADD		; WRITE ADDRESS OF CMOS BYTE WITH
	OUT	PORT_70,AL		; BITS FOR THE PASSWORD AND SERVER
					; MODE STATE TO PORT 70H
	JMP	$+2			; I/O Delay required
	IN	AL,PORT_71		; READ CMOS DATA BYTE WITH THE
					; PASSWORD AND SERVER SECURITY
	STI				; ENABLE THE INTERRUPTS
	TEST	AL,PASS_MODE+SERVER_MODE; CHECK & SEE IF THE BITS ARE ON
					; TEST clears CARRY flag
	JZ	SECURE_RET		; EXIT NO CARRY if neither set

	STC				; SET THE SECURITY FLAG ON
					; System is NOT an AT but the
SECURE_RET:				; keyboard interface maybe locked

	RET

KEYB_SECURE	ENDP
endif ; !JAPAN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; 8042 TYPE DETERMINATION
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SP_8042 PROC	NEAR			; Determine if 8042 is Patriot/Sebring
	PUSH	AX			; Save work register
	PUSH	CX			; Save count register
ifdef JAPAN
;       M005 -- begin changed section

        IN      AL, STATUS_PORT         ; In server password mode, no answer   ;JP9010
        TEST    AL, KYBD_INH            ; is returned from the following logic.;JP9010
        JZ      GET_FROM_ROM_BIOS       ; So, ask ROM BIOS.                    ;JP9010

;       M005 -- end changed section
endif ; JAPAN
	MOV	CX,24			; Limit AUX inputs if they are playing
					;  with the mouse while loading KEYB

SP__2:
	MOV	AL,DIS_KBD		; Disable command to clear 8042 output
	OUT	STATUS_PORT,AL		; Sending allows receive to complete
	STI				; Allow any pending AUX interrupt
	CALL	CHK_IBF 		; Wait for command to be accepted

	CLI				; Block interrupts until password set
	IN	AL,STATUS_PORT		; Read 8042 status byte
	TEST	AL,MOUSE_OBF		; Check for AUX data pending at output
	LOOPNZ	SP__2			; Loop till AUX inputs are cleared

	IN	AL,PORT_A		; Read to clear int's on SX  ;PTR660243
	MOV	AL,20h			; Read 8042 controller's command byte
	OUT	STATUS_PORT,AL		; Send command to 8042 interface
	CALL	CHK_IBF 		; Wait for command to be accepted
	MOV	CX,DLY_15ms		; Timeout 15 milliseconds (15000/15.086

SP__5:
ifdef JAPAN
        IN      AL,STATUS_PORT          ; Read status (command) port           ;AN012
        TEST    AL,OUT_BUF_FULL         ; Check for output buffer empty        ;AN012
        JNZ     SP__6                   ; Loop until OBF is ON                 ;AN012
endif ; JAPAN
	IN	AL,PORT_B		; Read current refresh output bit
	AND	AL,REFRESH_BIT		; Mask all but refresh bit
	CMP	AL,AH			; Did it change? (or first pass thru)
	JZ	SHORT SP__5		; No?, wait for change, else continue

	MOV	AH,AL			; Save new refresh bit state
ifndef JAPAN
	IN	AL,STATUS_PORT		; Read status (command) port
	TEST	AL,OUT_BUF_FULL 	; Check for output buffer empty
	LOOPZ	SP__5			; Loop until OBF is on or timeout
else ; JAPAN
        LOOP    SP__5                   ; Loop until OBF is ON or timeout      ;AN012
SP__6:                                                                         ;AN012
endif ; JAPAN

	IN	AL,PORT_A		; Get the command byte
	TEST	AL,01000000b		; Check for translate bit on
	JNZ	SP_EXIT 		; Done if it is on to begin with

ifdef JAPAN
SP_EXIT_0:                              ; M005 ;JP9010
endif ; JAPAN
	OR	SD.SYSTEM_FLAG,PS_8042	; Set PATRIOT/SEBRING type 8042
					;  with Translate scan codes set OFF
SP_EXIT:
	MOV	AL,ENA_KBD		; Enable command for keyboard
	OUT	STATUS_PORT,AL		; Send to 8042
	CALL	CHK_IBF 		; Wait for command to be accepted
	IN	AL,PORT_A		; Read to clear int's on SX  ;PTR660243
	POP	CX			; Recover user register
	POP	AX			; Recover user register
	STI				; Enable inteerutps again
	RET				; Return to caller

ifdef JAPAN
;       M005 -- begin added section

RTN_SYSTEM_CONFIG       EQU     0C0H    ; INT15H SUB FUNCTION                  ;JP9010
FEATURE_INFO_2          EQU     006H    ; FEATURE INFO2 OFFSET IN CONFIG DATA  ;JP9010
NON_8042_CONTROLLER     EQU     004H    ; THIS BIT ON IF NON-8042 CONTROLLER   ;JP9010
GET_FROM_ROM_BIOS:                      ; WE CAN ONLY ASK ROM BIOS WHICH TYPE  ;JP9010
        PUSH    ES                      ; OF KEYBOARD CONTROLLER IS ATTACHED.  ;JP9010
        PUSH    BX                      ;                                      ;JP9010
        MOV     AH, RTN_SYSTEM_CONFIG   ;                                      ;JP9010
        INT     15H                     ;                                      ;JP9010
        JC      RTN_SYS_CONFIG_NOT_SUPPORTED; IN CASE NOT SUPPORTED, IT MUST   ;JP9010
                                        ; BE 8042. BELIEVE IT.                 ;JP9010
        TEST    BYTE PTR  ES:[BX+FEATURE_INFO_2], NON_8042_CONTROLLER          ;JP9010
        POP     BX                      ;                                      ;JP9010
        POP     ES                      ;                                      ;JP9010
        JNZ     SP_EXIT_0               ; IF NON-8042, SET THE FLAG            ;JP9010
        JMP     SHORT SP_EXIT           ;                                      ;JP9010
RTN_SYS_CONFIG_NOT_SUPPORTED:           ;                                      ;JP9010
        POP     BX                      ;                                      ;JP9010
        POP     ES                      ;                                      ;JP9010
        JMP     SHORT SP_EXIT           ;                                      ;JP9010

;       M005 -- end added section
endif ; JAPAN

SP_8042 ENDP

CODE	ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybdcl.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBDCL.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 Common declarations for structures in procedures for KEYB.COM
;;
;; Change History:
;; ---------------
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
PARM_LIST	 STRUC		       ;;
;*******************CNS******************
;*******************CNS******************
    RET_CODE_1	    DB	 0	       ;;  \
    RET_CODE_2	    DB	 0	       ;;  |
    RET_CODE_3	    DB	 0	       ;;  |
;*******************CNS******************
    RET_CODE_4	    DB	 0	       ;;  |;AN000;
;*******************CNS******************
    LANGUAGE_PARM   DW	 ?	       ;;   }  PARAMETER
    CODE_PAGE_PARM  DW	 ?	       ;;  |	    LIST
    PATH_OFFSET     DW	 ?	       ;;  |
    PATH_LENGTH     DW	 0	       ;;  /
;*******************CNS******************
    ID_PARM	    DW	 ?	       ;AN000;
;*******************CNS******************
PARM_LIST	 ENDS		       ;;
				       ;;
DESIG_CP_STRUC	 STRUC		       ;;
    NUM_DESIGNATES  DW	 ?	       ;;
    NUM_FONTS	    DW	 ?	       ;;
    NUM_HW_CPS	    DW	 ?	       ;;
    DESIG_CP_ENTRY  DW	 ?	       ;;
DESIG_CP_STRUC	  ENDS		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybequ.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBEQU.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 Include file containing equates used by all KEYB modules.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
YES		EQU	1		;;
NO		EQU	0		;;
					;;
INT_2F_SUB_FUNC EQU	0ADH		;; our subfunction code for int 2f
SD		EQU	SHARED_DATA	;;
TSD		EQU	TEMP_SHARED_DATA;;
					;;
DLY_15ms	EQU	995		;; 15mS DELAY = (15000/15.086)
MOUSE_OBF	EQU	00100000b	;; AUX DATA PRESENT BIT AT STATUS_PORT
SCAN_CODE_CMD	EQU	0F0h		;; SELECT SCAN CODE SET COMMAND TO KB
					;;
ifdef NOT_NTVDM
FILE_BUFFER_SIZE equ	300		;; buffer used for reading keyboard.sys
else
FILE_BUFFER_SIZE equ	40 * 2 * 6	;;
endif
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keyb.asm ===
PAGE    ,132
        TITLE   MS-DOS 5.0 KEYB Command  -  Root Module

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MS-DOS 5.0 - NLS Support - KEYB Command
; (c) Copyright Microsoft Corp 1987-1991
;
; File Name:  KEYB.ASM
; ----------
;
;
; Description:
; ------------
;       Contains root module for KEYB command.  This module is the
;       KEYB command entry point.  KEYB is an external command included
;       with MS DOS 5.0 to provide keyboard support for 14 languages.
;       KEYB will jump immediately into the command processing in
;       file KEYBCMD.  All resident code is included before KEYBCMD
;       in the linkage list.
;
;
; Procedures Contained in This File:
; ----------------------------------
;
;
; Include Files Required:
; -----------------------
;       KEYBCMD.INC - External declarations for transient command
;           processing routines
;
; External Procedure References:
; ------------------------------
;       FROM FILE  KEYCMD.ASM:
;            KEYB_COMMAND - Main routine for transient command processing.
;
; Linkage Instructions:
; --------------------
;       Link in .COM format.  Resident code/data is in files KEYB thru
;       KEYBCPSD.
;
;       LINK KEYB+KEYBI9+KEYBI9C+KEYBI2F+KEYBCPSD+KEYBMSG+
;            COMMSUBS+KEYBTBBL+KEYBCMD;
;       EXE2BIN KEYB.EXE KEYB.COM
;
; Change History:
; ---------------
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


CODE    SEGMENT PUBLIC 'CODE' BYTE

        INCLUDE KEYBCMD.INC            ; Bring in external declarations
                                       ;  for transient command processing
        ASSUME  CS:CODE,DS:CODE
        ORG   100H                     ; required for .COM


START:

        JMP   KEYB_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CODE   ENDS
       END    START

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybi2f.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBI2F.INC
;; ----------
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBI2F.ASM
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    KEYB_INT_2F:NEAR      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybi2f.asm ===
PAGE    ,132
;
; (C) Copyright Microsoft Corp. 1987-1990
; MS-DOS 5.00 - NLS Support - KEYB Command
;
; File Name:  KEYBI2F.ASM
; ----------
;
; Description:
; ------------
;       Contains Interrupt 2F handler.
;
; Procedures Contained in This File:
; ----------------------------------
;       KEYB_INT_2F - Interupt 2F handler
;
; Include Files Required:
; -----------------------
;       INCLUDE KEYBEQU.INC
;       INCLUDE KEYBSHAR.INC
;       INCLUDE KEYBMAC.INC
;       INCLUDE KEYBCMD.INC
;       INCLUDE KEYBCPSD.INC
;       INCLUDE KEYBI9C.INC
;
; External Procedure References:
; ------------------------------
;       FROM FILE  ????????.ASM:
;               procedure - description????????????????????????????????
;
; Linkage Information:  Refer to file KEYB.ASM
; --------------------
;
; Change History:
; ---------------

        INCLUDE KEYBEQU.INC
        INCLUDE KEYBSHAR.INC
ifndef JAPAN
        INCLUDE KEYBMAC.INC
endif ; !JAPAN
        INCLUDE KEYBCMD.INC
        INCLUDE KEYBCPSD.INC
        INCLUDE KEYBI9C.INC

        PUBLIC KEYB_INT_2F

        EXTRN  ERROR_BEEP:NEAR


        EXTRN  NLS_FLAG_1:BYTE         ;; (YST)


CODE    SEGMENT PUBLIC 'CODE'

        ASSUME  CS:CODE,DS:nothing

; Module: KEYB_INT_2F
;
; Description:
;
; Input Registers:
;       AH = 0ADH
; ifdef JAPAN
;	AL = 80,81,82,83
; else
;       AL = 80,81,82
; endif
;
; Output Registers:
;       N/A
;
; Logic:
;       IF AH = 0ADh THEN        (this call is for us)
;       Set carry flag to 0
;       IF AL = 80 THEN
;         Get major and minor
;         Get SEG:OFFSET of SHARED_DATA_AREA
;
;       IF AL = 81 THEN
;         Get FIRST_XLAT_PTR
;         FOR each table
;               IF code page requested = code page value at pointer THEN
;               Set INVOKED_CODE_PAGE
;               Set ACTIVE_XLAT_PTR
;               EXIT
;               ELSE
;               Get NEXT_SECT_PTR
;         NEXT table
;         IF no corresponding code page found THEN
;               Set carry flag
;
;       IF AL = 82 THEN
;         IF BL = 00 THEN
;               Set COUNTRY_FLAG = 00
;         ELSE IF BL = 0FFH THEN
;               Set COUNTRY_FLAG = 0FFH
;         ELSE
;               Set carry flag
; ifdef JAPAN
;	IF AL = 83 THEN
;	  Return BL=COUNTRY_FLAG
; endif
;       JMP to previous INT 2FH handler

CP_QUERY        EQU     80H
CP_INVOKE       EQU     81H
CP_LANGUAGE     EQU     82H
ifdef JAPAN
CP_QLANGUAGE	EQU	83H
endif ; JAPAN


GET_KB_MODE     EQU   83H              ;; ONLY FOR RUSSIAN (YST)
SET_KB_MODE     EQU   84H              ;; ONLY FOR RUSSIAN


VERSION_MAJOR   EQU     01H
VERSION_MINOR   EQU     00H

CARRY_FLAG      EQU     01H

KEYB_INT_2F     PROC

        cmp     ah,INT_2F_SUB_FUNC      ; is it for us?
        jz      our_i2f_interrupt

i2f_chain:

;       Under DOS 5, it is always safe for us to assume that there was
;         an existing Int2f vector for us to continue to.

        jmp     cs:sd.old_int_2f

our_i2f_interrupt:

        push    bp
        mov     bp,sp
        and     word ptr [bp]+6,not carry_flag ; pre-clear carry
        call    do_our_i2f              ; pass bp.6 -> flags to functions

        pop     bp
        jmp     i2f_chain

do_our_i2f:
        CMP     AL,CP_QUERY             ; Q..query CP?
        JNE     INT_2F_CP_INVOKE        ; N..next

        MOV     AX,-1                   ; Y..process query
        mov     bx,(version_major shl 8) + version_minor
        MOV     DI,OFFSET SD
        PUSH    CS
        POP     ES
        ret

INT_2F_CP_INVOKE:
        CMP     AL,CP_INVOKE            ; Q..invoke CP?
        JNE     INT_2F_CP_LANGUAGE      ; N..next

        MOV     SI,cs:SD.FIRST_XLAT_PTR         ; Get FIRST_XLAT_PTR

INT_2F_NEXT_SECTION:
        CMP     SI,-1
        JE      INT_2F_ERROR_FLAG

        cmp     bx,cs:[SI].XS_CP_ID     ; is this the code page we want?
        JNE     INT_2F_CP_INVOKE_CONT1

        MOV     cs:SD.ACTIVE_XLAT_PTR,SI ; IF Yes, Set the ACTIVE_XLAT_PTR
        MOV     cs:SD.INVOKED_CP_TABLE,BX ;     record new code page
        ret

INT_2F_CP_INVOKE_CONT1:
        MOV     SI,cs:[SI].XS_NEXT_SECT_PTR ; Chain to NEXT_SECT_PTR
        JMP     INT_2F_NEXT_SECTION     ;       NEXT_SECTION

INT_2F_ERROR_FLAG:
        mov     ax,1                    ; ***???  why do we return error code
;                                       ;   only in this case?????
i2f_reterror:
        or      word ptr [bp]+6,carry_flag ; set carry to int2f caller
        ret

INT_2F_CP_LANGUAGE:
        CMP     AL,CP_LANGUAGE          ; Q..Set default language??


ifdef JAPAN
	jnz	INT_2F_CP_QLANG		; go check for query language
else ; !JAPAN
        jnz     int2f_ret               ; don't handle undefined functions
endif ; !JAPAN

;       Now, if BL=0 or 0ffh, we'll set COUNTRY_FLAG to that value.

        inc     bl
        cmp     bl,2                    ; set carry if bl is legal
        dec     bl                      ; restore old value, preserve carry
        jnc     i2f_reterror            ; done if error

        MOV     cs:COUNTRY_FLAG,BL      ;       Set COUNTRY_FLAG to 0 or 0ffh
;; ============================================================
;;       ONLY FOR RUSSIAN KEYBOARD !!!!!
;; ============================================================
        jmp     short int2f_ret

INT_2F_KB_MODE_ERROR_FLAG:             ;;   ==== (YST) ===                                       ;;
INT_2F_GET_KB_MODE:                    ;; (YST)-----------------------------
        CMP   AL,GET_KB_MODE           ;; Q..Get keyboard mode?            |
        JNE   INT_2F_SET_KB_MODE       ;; N..next                          |
;        PUSH  DS                       ;;
;        PUSH  BX                       ;;
;        PUSH  CX                       ;;
;        PUSH  SI                       ;;
;        push  cs
;        pop   ds
        XOR   AX,AX                    ;;                                  |
        OR    AL,cs:COUNTRY_FLAG          ;; Q..CTRL+ALT+F1 was pressed?      |
        JZ    INT_2F_GET_KB_MODE_DONE  ;; Y..return AX = 0                 |
                                       ;; Q..is current driver switchable? |
        TEST  WORD PTR CS:SD.SPECIAL_FEATURES,SWITCHABLE  ;;               |
        JZ    INT_2F_GET_KB_MODE_DONE  ;; N..return AX = 0FFH              |
        MOV   AL,cs:NLS_FLAG_1            ;; Y..return <keyb NL mode+1>       |------------------\
        AND   AL,1                     ;;                                  | if RUS_MODE = 1 | >   S
        INC   AX                       ;;                                  |------------------/    A
                                       ;;                                  |
INT_2F_GET_KB_MODE_DONE:               ;; For DOS 5 normal exit            |
        RET                            ;;                                  |
                                       ;;                                  |
INT_2F_SET_KB_MODE:                    ;;                                  |
        CMP   AL,SET_KB_MODE           ;; Q..Set keyboard mode?            |
        JNE   int2f_ret                ;; N..next                          |
                                       ;;                                  |
        MOV   BH,cs:NLS_FLAG_1            ;;                                  |
                                       ;;                                  |
        TEST  BL,0FEH                  ;; Q..BL equ 0 or 1?                |---------------------
        JNZ   INT_2F_KB_MODE_ERROR_FLAG;; N..Set CARRY flag                |                    |
        AND   BH,0FEH                  ;; Y..Set NL mode                   |  if RUS_MODE = 1   |
        OR    BH,BL                    ;;                                  |                    |
                                       ;;                                  |---------------------
                                       ;;                                  |
        MOV   cs:NLS_FLAG_1,BH            ;; Store this value                 |
                                       ;;                                  |
                                       ;;                                  |
                                       ;;                                  |
                                       ;; (YST)-----------------------------

int2f_ret:
        ret

ifdef JAPAN
INT_2F_CP_QLANG:
	CMP	AL,CP_QLANGUAGE
	jnz	int2f_ret

	mov	bl,cs:COUNTRY_FLAG
	ret
endif ; JAPAN

KEYB_INT_2F     ENDP

CODE    ENDS
        END

;; ========================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybi9.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBI9.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBI9.ASM
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    KEYB_STATE_PROCESSOR:NEAR

	EXTRN	 FLAGS_TO_TEST:BYTE    ;;  (YST)
                                       ;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybi9c.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBI9C.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBI9C.ASM
;;
;; Change History:
;; ---------------
;; Delete unused externs
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
        EXTRN   KEYB_INT_9:NEAR         ;;
        EXTRN   K8:BYTE                 ;;
        EXTRN   BUFFER_FILL:NEAR        ;;
        EXTRN   COUNTRY_FLAG:BYTE       ;;
        EXTRN   COPY_NLS1_FLAG:BYTE     ;; (YST)
        EXTRN   BEEP_PENDING:BYTE       ;;
        EXTRN   SCAN_CODE:BYTE          ;;
        EXTRN   CHK_IBF:NEAR            ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybi9c.asm ===
PAGE    ,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;  File Name:  KEYBI9C.ASM
;  ----------
;
;
;  Description:
;  ------------
;        Interrupt 9 mainline.
;        This routine handles all US keyboard support for the following
;        system units:  PC, PC-XT, PC-AT, PC Convertible, PC-XT/286
;                       Models 25 and 30 (PALACE),
;                       PS/2's - all 8042 based 80286, 80386 and 80486.
;                              - all PATRIOT and SEBRING based systems.
;        KEYB_STATE_PROCESSOR is called for non-US keyboard support.
;
;
;
;  Procedures Contained in This File:
;  ----------------------------------
;        KEYB_INT_9 - Interrupt 9
;
;  External Procedure References:
;  ------------------------------
;        FROM FILE  KEYBI9.ASM:
;             KEYB_STATE_PROCESSOR - Non US keyboard support.
;
;  Linkage Information:  Refer to file KEYB.ASM
;  --------------------
;
;  Change History:
;  ---------------
;  ; - DCR 478 -        KEYBOARD INT SPLICING Nick Savage  ;deleted by AN005
;  ; - PTM 3090         ENABLING RIGHT CTL FOR RE-BOOTING
;  ; - PTM 60XX         PICK UP ALL KEYBOARD BIOS PTR's AND DCR's TO BRING
;                       INT 9h  UP TO THE TOPHAT (80486) SUPPORT LEVEL. '89  jwg
;          PTR 6600736  Keep INT's disabled till after PORT 60h read.
;          PTR 6600756  EXTRA EOI ISSUED IF INTERRUPTS SATURATED **********
;                          NOTE: This is a fix for a BIOS bug that goes all
;                           the way back to the first AT.  The rationale for
;                           the fix is as follows:
;           (deleted AN005)     A stack frame is created upon entry (BP) and
;                               CHK_EOI is called to check the frame. If no
;                               EOI has been issued, CHK_EOI does it and
;                               resets the frame, preventing any additinal
;                               EOI's from being issued on subsequent calls
;                               to CHK_EOI.  All direct EOI's in the code
;                               have been replaced with calls to CHK_EOI.
;
;  ;Ax004; - PTM 2555   KEYB command locks keyboard. 10/5/89;cja
;                       ; jwg 11/09/98 Updates - Wild Mouse, etc workaround.....
;  ; - PTM 5802         Restructure Interrupt Splicing to correct lost Mouse
;                       interrupt when LED's are updated.  Make it apply to
;                       all systems. Essentially remove all code added by AN001.
;                       Remove stack frame logic of AN003 and PTR 6600756 and do
;                       an early EOI.  Requires a CLI at K38B and other places.
;                       Remove Chk_ibf before 60h.
;                       Re-write ERROR_BEEP to make processor speed independent
;                       for AT and PS/2 systems and right tone if interrupts.
;                       Make SHIP_IT handle call on PC machines.
;                       Use BP to hold system flags during interrupt processing.
;          PTR 6602049  Fix problem with Pause Key hanging system if Mouse
;                       driver is using polled mode.  (Port 60h hangs.)
;          PTR 6602247  Change JMP at K40 to stop extra Enable Keyboard cmd.
;          PTR 6602319  Fix interrupt window on System Request key allowing
;                       following scan code(s) to be processed out of sequence.
;          PTR 6602355  Fix Print Screen clearing E0 state flags too late.
;  ; - ;deleted         Add code the clear "Wild Mouse" condition at PAUSE wait.
;  ; -  PTM 6660        Move determination code for original PC1 to COMMSUBS.ASM
;          - ;jwg 2/90  Add Patriot/Sebring HOT REPLUG code so keyboard can be
;                       switched back to Scan Code Set 1 if repluged.  LIB LITE
;  ; -  PTM 6680        Remove code attempting to re-sync BIOS flags with reset
;                       Keyboard.  Test case simulators can/are sending invalid
;                       sequence of AA,AA.  Must leave BIOS flags alone on POR.
;  ; -  PTM 6716        MicroSoft WORKS (German version) reentrancy problem with
;          - ;jwg 3/90  NLS state processor and save scan code.  LED update ACK
;                       overlays memory before NLS processing of scan code.
;                       Remove AN006 "Wild Mouse" reset code, field tests done.
;  ; -  PTM ????        Fix read ID logic to recognize 122 keyboards and set the
;	     ;jwg 8/90	KBX flag on any enhansed keyboard.
;  ; -  PTM ????        Add 122 Keyboard key support tables.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        INCLUDE KEYBEQU.INC
        INCLUDE DSEG.INC                ; System data segments
        INCLUDE POSTEQU.INC             ; System equates
        INCLUDE KEYBSHAR.INC
        INCLUDE KEYBI2F.INC
        INCLUDE KEYBI9.INC
        INCLUDE KEYBCPSD.INC
        INCLUDE KEYBCMD.INC

include bop.inc
include vint.inc

        PUBLIC  KEYB_INT_9
        PUBLIC  K8                      ; CTRL case tables
        PUBLIC  SCAN_CODE
        PUBLIC  BUFFER_FILL
        PUBLIC  COUNTRY_FLAG


        PUBLIC COPY_NLS1_FLAG          ;; (YST)


        PUBLIC  BEEP_PENDING
        PUBLIC  ERROR_BEEP
        PUBLIC  CHK_IBF
ifdef JAPAN
	PUBLIC	S_122_MARKER		; 122 KEYBOARD F8/00 marker
	PUBLIC	BEEP_DELAY		; Error beep delay, default=19
	PUBLIC	SCAN_CODE_SET		; Keyboard Scan Code Set in use
	PUBLIC	READ_ID2		; Second byte read on last READ ID
endif ; JAPAN



ID_1            EQU     0ABH            ; 1ST ID CHARACTER FOR KBX
TID_2           EQU     041H            ; US G-LAYOUT
TID_2A          EQU     054H            ; US P-LAYOUT

;UNTRANSLATED 2ND ID CHAR FOR KBDX
ID_2U           EQU     083H            ; US G-LAYOUT (PATRIOT)
ID_2AU          EQU     084H            ; US P-LAYOUT (PATRIOT)
ID_122          EQU     086H            ; 2ND ID CHARACTER FOR 122-KEYBOARD
ID_2JG          EQU     090H            ; JPN G-LAYOUT
ID_2JP          EQU     091H            ; JPN P-LAYOUT
ID_2JA          EQU     092H            ; JPN A-LAYOUT

ifdef JAPAN
S_XKBD_SCAN	EQU	0A6h		; Highest Character Code For Enhanced
S_122_MARK	EQU	0F8h		; Marker for EXTENDED 122 keys DCR 1815
endif ; JAPAN

DIAGS   SEGMENT AT 0FFFFH
        ORG     0
RESET   LABEL   FAR
DIAGS   ENDS


CODE    SEGMENT PUBLIC 'CODE'
        ASSUME  CS:CODE,DS:DATA


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   TABLE OF SHIFT KEYS AND MASK VALUES
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;------ KEY_TABLE
K6      LABEL   BYTE
        DB      INS_KEY                 ; INSERT KEY
        DB      CAPS_KEY,NUM_KEY,SCROLL_KEY,ALT_KEY,CTL_KEY
        DB      LEFT_KEY,RIGHT_KEY
K6L     EQU     $-K6

;------ MASK_TABLE
K7      LABEL   BYTE
        DB      INS_SHIFT               ; INSERT MODE SHIFT
        DB      CAPS_SHIFT,NUM_SHIFT,SCROLL_SHIFT,ALT_SHIFT,CTL_SHIFT
        DB      LEFT_SHIFT,RIGHT_SHIFT

;----------  TABLES FOR ALT CASE  -----
;------ ALT-INPUT-TABLE
K30     LABEL   BYTE
        DB      82,79,80,81,75
        DB      76,77,71,72,73          ; 10 NUMBERS ON KEYPAD
;------ SUPER-SHIFT-TABLE
        DB      16,17,18,19,20,21       ; A-Z TYPEWRITER CHARS
        DB      22,23,24,25,30,31
        DB      32,33,34,35,36,37
        DB      38,44,45,46,47,48
        DB      49,50
K30_LEN         EQU     $-K30-10

;------ ALT-INPUT-FUNCTION-TABLE   53H - 7EH
K30A    LABEL   BYTE
        DB      -1,-1,-1,-1,139,140     ; Del, SysReq, Undef, WT, F11, F12
        DB      -1,235,218,219,220      ; Undef, PA1, F13, F14, F15
        DB      -1,-1,-1,-1,-1          ; Pause, Undef 5F-62
        DB      221,222,223,226,227     ; F16, F17, F18, F19, F20,
        DB      228,229,230,231         ; F21, F22, F23, F24,
        DB      -1,243,-1,-1            ; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,253 	                ; K#74, Clear,
ifdef NOT_NTVDM
;;*     DB             -1,-1,-1         ;              Undef, K#109, Undef
;;*     DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, Undef
else
        DB             -1,-1,-1         ;              Undef, K#109, Undef
        DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, K#107
endif
ifdef JAPAN
	DB	-1			; 07Eh, 07Fh.  DBCS Pseudo codes.
					;  H_LAST_SCAN must be 07Fh for DBCS
endif ; JAPAN

H_LAST_SCAN     EQU     $-K30A+52h      ; Largest valid scan code in table
                                        ;  K30A K8 K15 K14 must have same ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  K8 is overlaid by K8_RPL (from module KEYB_COMMAND)
;  if extended INT 16 support is available
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

K8      LABEL   BYTE                    ;-------- CHARACTERS ---------
        DB      27,-1,00,-1,-1,-1       ; Esc, 1, 2, 3, 4, 5
        DB      30,-1,-1,-1,-1,31       ; 6, 7, 8, 9, 0, -
        DB      -1,127,-1,17,23,5       ; =, Bksp, Tab, Q, W, E
        DB      18,20,25,21,09,15       ; R, T, Y, U, I, O
        DB      16,27,29,10,-1,01       ; P, [, ], Enter, Ctrl, A
        DB      19,04,06,07,08,10       ; S, D, F, G, H, J
        DB      11,12,-1,-1,-1,-1       ; K, L, ;, ', `, LShift
        DB      28,26,24,03,22,02       ; \, Z, X, C, V, B
        DB      14,13,-1,-1,-1,-1       ; N, M, ,, ., /, RShift
        DB      '*',-1,' ',-1           ; *, Alt, Space, CL
                                        ;--------- FUNCTIONS ---------
        DB      94,95,96,97,98,99       ; F1 - F6
        DB      100,101,102,103,-1,-1   ; F7 - F10, NL, SL
        DB      119,-1,132,-1,115,-1    ; Home, Up, PgUp, -, Left, Pad5
        DB      116,-1,117,-1,118,-1    ; Right, +, End, Down, PgDn, Ins
        DB      -1,-1,-1,-1,137,138     ; Del, SysReq, Undef, WT, F11, F12
                                        ;---------- 122 KEYBOARD not overlaid
        DB      -1,234,206,207,208      ; Undef, PA1, F13, F14, F15
        DB      -1,-1,-1,-1,-1          ; Pause, Undef 5F-62
        DB      209,210,211,212,213     ; F16, F17, F18, F19, F20,
        DB      214,215,216,217         ; F21, F22, F23, F24,
        DB      -1,242,-1,-1            ; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,252                  ; K#74, Clear,
ifdef NOT_NTVDM
;;*     DB             -1,-1,-1         ;              Undef, K#109, Undef
;;*     DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, Undef
else
        DB             -1,-1,-1         ;              Undef, K#109, Undef
        DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, K#107
endif
ifdef JAPAN
	DB	-1                      ; 07Eh, 07Fh.  DBCS Pseudo codes.
endif ; JAPAN

;-----  TABLES FOR LOWER CASE (USA)  --

K10     LABEL   BYTE
        DB      27,'12345'
        DB      '67890-'
        DB      '=',08,09,'qwe'
        DB      'rtyuio'
        DB      'p[]',0DH,-1,'a'        ; LETTERS, Return, Ctrl
        DB      'sdfghj'
        DB      "kl;'`",-1              ; LETTERS, L Shift
        DB      '\zxcvb'
        DB      'nm,./'
        DB      -1,'*',-1,' \'          ; R Shift, *, Alt, Sp, CL (REALLY WT KEY)

;------ LC TABLE SCAN
        DB      59,60,61,62,63          ; BASE STATE OF F1 - F10
        DB      64,65,66,67,68
        DB      -1,-1                   ; NL, SL

;------ KEYPAD TABLE
K15     LABEL   BYTE
        DB      71,72,73,-1,75,-1       ; Home, Up, PgUp, -1, Left, -1
        DB      77,-1,79,80,81,82       ; Right, -1, End, Down, PgDn, Ins
        DB      83                      ; Del
        DB      -1,-1,'\',133,134       ; SysRq, Undef, WT, F11, F12
ifndef JAPAN
        DB      -1,232,182,183,184      ; Undef, PA1, F13, F14, F15
else ; JAPAN
	DB	-1,232,236,237,238	; Undef, PA1, F13, F14, F15
endif ; JAPAN
        DB      -1,-1,-1,-1,-1          ; Pause, Undef 5F-62
ifndef JAPAN
        DB      185,186,187,188,189     ; F16, F17, F18, F19, F20,
        DB      190,191,192,193         ; F21, F22, F23, F24,
else ; JAPAN
	DB	239,244,245,246,247	; F16, F17, F18, F19, F20,
	DB	248,249,250,192 	; F21, F22, F23, F24,
endif ; JAPAN
        DB      -1,240,-1,-1            ; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,251                  ; K#74, Clear,
ifdef NOT_NTVDM
;;*     DB             -1,-1,-1         ;              Undef, K#109, Undef
;;*     DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, Undef
else
        DB             -1,-1,-1         ;              Undef, K#109, Undef
        DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, K#107
endif
ifdef JAPAN
	DB      -1                      ; 07Eh, 07Fh.  DBCS Pseudo codes.
endif ; JAPAN

;-------  TABLES FOR UPPER CASE (USA)

K11     LABEL   BYTE
        DB      27,'!@#$%'
        DB      '^&*()_'
        DB      '+',08,00,'QWE'
        DB      'RTYUIO'
        DB      'P{}',0DH,-1,'A'        ; LETTERS, Return, Ctrl
        DB      'SDFGHJ'
        DB      'KL:"~',-1              ; LETTERS, L Shift
        DB      '|ZXCVB'
        DB      'NM<>?'
        DB      -1,'*',-1,' |'          ; R Shift, *, Alt, Sp, CL (REALLY WT KEY)

;------ UC TABLE SCAN
K12     LABEL   BYTE
        DB      84,85,86,87,88          ; SHIFTED STATE OF F1 - F10
        DB      89,90,91,92,93
        DB      -1,-1                   ; NL, SL

;------ NUM STATE TABLE
K14     LABEL   BYTE
        DB      '789-456+1230.'         ; NUMLOCK STATE OF KEYPAD KEYS
        DB      -1,-1,'|',135,136       ; SysRq, Undef, WT, F11, F12
ifndef JAPAN
        DB      -1,233,194,195,196      ; Undef, PA1, F13, F14, F15
else ; JAPAN
	DB	-1,233,193,195,196	; Undef, PA1, F13, F14, F15
endif ; JAPAN
        DB      -1,-1,-1,-1,-1          ; Pause, Undef 5F-62
        DB      197,198,199,200,201     ; F16, F17, F18, F19, F20,
        DB      202,203,204,205         ; F21, F22, F23, F24,
        DB      -1,241,-1,-1            ; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,251                  ; K#74, Clear,
ifdef NOT_NTVDM
;;*     DB             -1,-1,-1         ;              Undef, K#109, Undef
;;*     DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, Undef
else
        DB             -1,-1,-1         ;              Undef, K#109, Undef
        DB      -1,-1,-1,-1,-1          ; Undef, Undef, K#94, K#14, K#107
endif
ifdef JAPAN
        DB      -1                      ; 07Eh, 07Fh.  DBCS Pseudo codes.
endif ; JAPAN
PAGE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Procedure: KEYB_INT_9
;
;  Description:
;      Entry point for interrupt 9 processing.
;
;  Input Registers:
;      None
;
;  Output Registers:
;      None
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		EVEN			; Keep KEYB_INT_9 entry on even boundry
BEEP_PENDING	DB	NO		; YES if a beep is needed
SCAN_CODE	DB	0		; Last SCAN code read

KEYB_INT_9      PROC   NEAR

         JMP  SHORT KB_INT_1            ;; (YST)
COPY_NLS1_FLAG  DB       0              ;; (YST)
COUNTRY_FLAG    DB      -1              ; WHERE THE INT9 VECTOR POINTS
ifdef JAPAN
READ_ID2	DB	0		; Second byte from last READ ID
BEEP_DELAY	DW	19		; Error beep delay, 19=Refresh loop,
					;  the half cycle time for 1745 hz
SCAN_CODE_SET	DB	01h		; In case of old DBCS keyboards, this
					;  may be 81h or 82h.  Default is 01
S_122_MARKER	DB	0F8h		; Marker for 122-KEYBOARD KEYS DCR 1815
					;  Changed to E0 depending on INT 16h
	EVEN				; Force to even location
endif ; JAPAN
KB_INT_1:

                                        ; Do NOT enable interrupts untill after
                                        ;  PORT 60h has been read.  INT 15h has
                                        ;  interrupt window, do EOI, fast pass.
        PUSH    BP                      ; Reserved in KEYBi9c for SD.SYSTEM_FLAG
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    DX
        PUSH    SI
        PUSH    DI
        PUSH    DS
        PUSH    ES
        CLD                             ; FORWARD DIRECTION
        MOV     BX,DATA                 ; SET UP ADDRESSING
        MOV     DS,BX                   ; DS POINTS AT THE ROM BIOS DATA AREA
        MOV     BP,CS:SD.SYSTEM_FLAG    ; GET CS:SD.SYSTEM_FLAG, AND USE BP


ifdef NOT_NTVDM
;/* --  WAIT TILL KEYBOARD DISABLE COMMAND CAN BE ACCEPTED
        MOV     AL,DIS_KBD              ; DISABLE THE KEYBOARD COMMAND
        CALL    SHIP_IT                 ; EXECUTE DISABLE
else
        mov     ah, 1                   ; notify I9 entry to softpc
        BOP     09h
        nop                             ; Carbon copy traces for
        nop                             ; "in al,PORT_A"
endif                                   ; keep it traceable

        IN      AL,PORT_A               ; READ IN THE CHARACTER


;/* --  SYSTEM HOOK  INT 15H - FUNCTION 4FH  (ON HARDWARE INTERRUPT LEVEL 9H)

        MOV     AH,04FH                 ; SYSTEM INTERCEPT - KEY CODE FUNCTION
        STC                             ; SET CY= 1 (IN CASE OF IRET)
        INT     15H                     ; CASSETTE CALL   (AL)= KEY SCAN CODE
                                        ;  RETURNS CY= 1 FOR INVALID FUNCTION

ifdef NOT_NTVDM
                                        ; EARLY  EOI for all interrupts done
                                        ;  after INT 15h to prevent re-entrancy
        XCHG    BX,AX                   ; SAVE SCAN CODE
        MOV     AL,EOI                  ; END OF INTERRUPT COMMAND (EARLY EOI)
        OUT     INTA00,AL               ; SEND EOI TO INTERRUPT CONTROL PORT
        XCHG    BX,AX                   ; RECOVER SCAN CODE
endif

        JC      KB_INT_02               ; CONTINUE IF CARRY FLAG SET ((AL)=CODE)
        JMP     K26                     ; EXIT IF SYSTEM HANDLED SCAN CODE
                                        ;  EXIT HANDLES ENABLE

;/* --- CHECK FOR A POSSIBLE HOT REPLUG AND A POR COMPLETE CODE
KB_INT_02:                              ;       (AL)= SCAN CODE

ifdef NOT_NTVDM
; ntvdm we don't do keyboard resets\power on stuff
;
                                        ;       CHECK FOR POR
        CMP     AL,KB_OK                ; CHECK FOR POSSIBLE KEYBOARD POR CHAR
        JNE     KB_INT_03               ; CONTINUE NOT A POR OF AA
                                        ;       CHECK FOR ENHANSED KEYB
        TEST    KB_FLAG_3,LC_E0                 ; WAS E0h LAST SCAN CODE?    DCR467
        JNZ     KB_INT_03               ; SKIP KB POR IF IT WAS
                                        ;       CHECK FOR LEFT SHIFT BREAK
        TEST    KB_FLAG,LEFT_SHIFT      ; IS LEFT SHIFT ACTIVE?
        JNZ     KB_INT_03               ; SKIP KB POR IF IT WAS
                                        ;       KEYBOARD POWER ON DETECTED
        MOV     CS:BEEP_PENDING,YES     ; INDICATE WE NEED A BEEP
        MOV     KB_FLAG_2,0             ; CLEAR ALL LED FLAGS TO FORCE UPDATE
                                        ; LEAVE OTHERS SO KB SIMULATORS WORK

        TEST    BP,PS_8042              ; SYSTEM USING 8042 & SCAN CODE SET 01?
        JZ      KB_INT_03               ; SKIP IF SYSTEM USES DEFAULT SCS 02
                                        ;       PATRIOT/SEBRING 8042 GATE ARRAY
        MOV     AL,SCAN_CODE_CMD        ; SELECT SCAN CODE SET COMMAND
        CALL    SND_DATA                ; SEND IT DIRECTLY TO THE KEYBOARD
        MOV     AL,01h                  ; SELECT SCAN CODE SET 01
        CALL    SND_DATA                ; SEND IT TO THE KEYBOARD
        MOV     AL,KB_OK                ; RESTORE POR SCAN CODE IN (AL)
endif

KB_INT_03:

;/* --- CHECK FOR A RESEND COMMAND TO KEYBOARD

        ;; NTVDM STI                             ; ENABLE INTERRUPTS AGAIN
        CMP     AL,KB_RESEND            ; IS THE INPUT A RESEND
        JE      KB_INT_4                ; GO IF RESEND

;/* --- CHECK FOR RESPONSE TO A COMMAND TO KEYBOARD

        CMP     AL,KB_ACK               ; IS THE INPUT AN ACKNOWLEDGE
        JNZ     KB_INT_2                ; GO IF NOT

;/* --- A COMMAND TO THE KEYBOARD WAS ISSUED

        ;; NTVDM CLI                             ; DISABLE INTERRUPTS
        OR      KB_FLAG_2,KB_FA         ; INDICATE ACK RECEIVED
        JMP     K26                     ; RETURN IF NOT (ACK RETURNED FOR DATA)

;/* --- RESEND THE LAST BYTE

KB_INT_4:
        ;; NTVDM CLI                             ; DISABLE INTERRUPTS
        OR      KB_FLAG_2,KB_FE         ; INDICATE RESEND RECEIVED
        JMP     K26                     ; RETURN IF NOT (ACK RETURNED FOR DATA)


;/* --- UPDATE MODE INDICATORS IF CHANGE IN STATE

KB_INT_2:
        PUSH    AX                      ; SAVE DATA IN
        CALL    MAKE_LED                ; GO GET MODE INDICATOR DATA BYTE
        MOV     BL, KB_FLAG_2           ; GET PREVIOUS BITS
        XOR     BL,AL                   ; SEE IF ANY DIFFERENT
        AND     BL,KB_LEDS              ; ISOLATE INDICATOR BITS
        JZ      UP0                     ; IF NO CHANGE BYPASS UPDATE
        CALL    SND_LED                 ; GO TURN ON MODE INDICATORS
UP0:    POP     AX                      ; RESTORE DATA IN

;---------------------------------------------------------------------
;             START OF KEY PROCESSING                                -
;---------------------------------------------------------------------

        MOV     AH,AL                   ; SAVE SCAN CODE IN AH ALSO
                                        ; END OF RE-ENTRANT CODE PATHS
        MOV     CS:SCAN_CODE,AL         ; SAVE SCAN CODE TO BE PROCESSED BY KEYB

;------ TEST FOR OVERRUN SCAN CODE FROM KEYBOARD

        CMP     AL,KB_OVER_RUN          ; IS THIS AN OVERRUN CHAR?
        JNZ     K16                     ; NO, TEST FOR SHIFT KEY

        MOV     CS:BEEP_PENDING,YES
        JMP     K26                     ; BUFFER_FULL_BEEP, EXIT

K16:

        PUSH    CS
        POP     ES                      ; ESTABLISH ADDRESS OF TABLES
        MOV     BH, KB_FLAG_3           ; LOAD FLAGS FOR TESTING

;------ TEST TO SEE IF A READ_ID IS IN PROGRESS

        TEST    BH,RD_ID+LC_AB          ; ARE WE DOING A READ ID?
        JZ      NOT_ID                  ; CONTINUE IF NOT
        JNS     TST_ID_2                ; IS THE RD_ID FLAG ON?
        CMP     AL,ID_1                 ; IS THIS THE 1ST ID CHARACTER?
        JNE     RST_RD_ID
        OR      KB_FLAG_3,LC_AB         ; INDICATE 1ST ID WAS OK
RST_RD_ID:
        AND     KB_FLAG_3,NOT RD_ID     ; RESET THE READ ID FLAG
        JMP     SHORT ID_EX             ; AND EXIT


;------ CHECK 2ND US KBD ID - FOR SETTING NUM LOCK ON
TST_ID_2:
        AND     KB_FLAG_3,NOT LC_AB     ; RESET FLAG
        OR      KB_FLAG_3,KBX           ; INDICATE ENHANCED KEYBOARD WAS FOUND
ifdef JAPAN
					; If it responds to a read ID command
	MOV	CS:READ_ID2,AL		; Save ID just read for ID checks
endif ; JAPAN
        CMP     AL,TID_2                ; IS THIS US G-LAYOUT KBD  w 8042
        JE      NUM_LOCK_000            ;  JUMP IF SO
        CMP     AL,ID_2U                ; IS THIS US G-LAYOUT KBD  w/o 8042
        JE      NUM_LOCK_000            ;  JUMP IF SO
        CMP     AL,ID_122               ; IS THIS THE 122 KEY ENHANCED KEYBOARD
        JE      NUM_LOCK_000            ;  JUMP IF SO

;------ CHECK 2ND JAPANESE KBD ID       ;DCR355

        CMP     AL,ID_2JG               ; IS THIS JPN KBD - G ?
        JE      NUM_LOCK_000            ; JUMP IF SO
        CMP     AL,ID_2JA               ; IS THIS JPN KBD - A ?
	JNE	ID_EX			; EXIT IF NUM LOCK NOT REQUIRED
                                        ;  These ID's do not set NUM LOCK ON
                                        ;  ID_2AU = US P-LAYOUT KBD  w/o 8042
                                        ;  TID_2A = US P-LAYOUT KBD  w 8042
                                        ;  ID_2JP = JPN KBD - P

;------ A READ ID SAID THAT IT WAS ENHANCED KEYBOARD

NUM_LOCK_000:
        TEST    BH,SET_NUM_LK           ; SHOULD WE SET NUM LOCK?
        JZ      ID_EX                   ; EXIT IF NOT
        OR      KB_FLAG,NUM_STATE       ; FORCE NUM LOCK ON
        CALL    SND_LED                 ; GO SET THE NUM LOCK INDICATOR
ID_EX:
        JMP     K26                     ; EXIT
PAGE
NOT_ID:
ifdef JAPAN
;	M005 -- Kermit merge changes + AN013				       ;AN013

	TEST	BP,DBCS_OK		; Is a DBCS keyboard active?	;JP9009;AN013
	JZ	NOT_DBCS		; Skip DBCS shift case checks	       ;AN013

	MOV	BL,KB_FLAG		; Get shift key state flags now ;JP9009;AN013
	; ntraid:mskkbug#3516: Alt+Capslock does not work	11/9/93 yasuho
	CALL	DBCS_keyboard_support	; Go check for special shift key;JP9009;AN013
					; We can't call because this is edited
					; scan code directly. I comment it.
					; 8/31/93 NT-J
NOT_DBCS:								       ;AN013
;	M005 -- End changes + AN013
endif ; JAPAN
        CMP     AL,MC_E0                ; IS THIS THE GENERAL MARKER CODE?
        JNE     TEST_E1
        OR      KB_FLAG_3,LC_E0+KBX     ; SET FLAG BIT, SET KBX, AND
        JMP     SHORT EXIT              ; THROW AWAY THIS CODE

TEST_E1:
        CMP     AL,MC_E1                ; IS THIS THE PAUSE KEY?
        JNE     NOT_HC
        OR      KB_FLAG_3,LC_E1+KBX     ; SET FLAG, PAUSE KEY MARKER CODE
EXIT:   JMP     K26A                    ; THROW AWAY THIS CODE

NOT_HC:
        AND     AL,07FH                 ; TURN OFF THE BREAK BIT
        TEST    BH,LC_E0                ; LAST CODE THE E0 MARKER CODE?
        JZ      NOT_LC_E0               ; JUMP IF NOT

        MOV     CX,2                    ; LENGTH OF SEARCH
        MOV     DI,OFFSET K6+6          ; IS THIS A SHIFT KEY?
        REPNE   SCASB                   ; CHECK IT
        JNE     K16A                    ; NO, CONTINUE KEY PROCESSING
        JMP     SHORT K16B              ; YES, THROW AWAY & RESET FLAG

NOT_LC_E0:
        TEST    BH,LC_E1                ; LAST CODE THE E1 MARKER CODE?
        JZ      T_SYS_KEY               ; JUMP IF NOT

        MOV     CX,4                    ; LENGTH OF SEARCH
        MOV     DI,OFFSET K6+4          ; IS THIS AN ALT, CTL, OR SHIFT?
        REPNE   SCASB                   ; CHECK IT
        JE      EXIT                    ; THROW AWAY IF SO

        CMP     AL,NUM_KEY              ; IS IT THE PAUSE KEY?
        JNE     K16B                    ; NO, THROW AWAY & RESET FLAG
        TEST    AH,80H                  ; YES, IS IT THE BREAK OF THE KEY?
        JNZ     K16B                    ;  YES, THROW THIS AWAY, TOO
        TEST    KB_FLAG_1,HOLD_STATE    ;  NO, ARE WE PAUSED ALREADY?
        JNZ     K16B                    ;      YES, THROW AWAY
        JMP     K39P                    ;  NO, THIS IS THE REAL PAUSE STATE
PAGE
;------ TEST FOR SYSTEM KEY

T_SYS_KEY:
        CMP     AL,SYS_KEY              ; IS IT THE SYSTEM KEY?
        JNE     K16A                    ; CONTINUE IF NOT

        TEST    AH,080H                 ; CHECK IF THIS A BREAK CODE
        ;; NTVDM CLI                           ; DISABLE INTERRUPTS     PTR 6602319
        JNZ     K16C                    ; DON'T TOUCH SYSTEM INDICATOR IF TRUE

        TEST    KB_FLAG_1,SYS_SHIFT     ; SEE IF IN SYSTEM KEY HELD DOWN
        JNZ     K16B                    ; IF YES, DON'T PROCESS SYSTEM INDICATOR

        OR      KB_FLAG_1,SYS_SHIFT     ; INDICATE SYSTEM KEY DEPRESSED

ifdef NOT_NTVDM
        MOV     AL,ENA_KBD              ; INSURE KEYBOARD IS ENABLED
        CALL    SHIP_IT                 ; EXECUTE ENABLE
else
        mov     ah, 3                   ; K27A exit notify
        BOP     09h
endif
        MOV     AX,08500H               ; FUNCTION VALUE FOR MAKE OF SYSTEM KEY
        INT     15H                     ; USER INTERRUPT
        JMP     K27A                    ; END PROCESSING

K16B:   JMP     K26                     ; IGNORE SYSTEM KEY

K16C:   AND     KB_FLAG_1,NOT SYS_SHIFT; TURN OFF SHIFT KEY HELD DOWN

ifdef NOT_NTVDM
        MOV     AL,ENA_KBD              ; INSURE KEYBOARD IS ENABLED
        CALL    SHIP_IT                 ; EXECUTE ENABLE
else
        mov     ah, 3                   ; K27A exit notify
        BOP     09h
endif

        MOV     AX,08501H               ; FUNCTION VALUE FOR BREAK OF SYSTEM KEY
        INT     15H                     ; USER INTERRUPT
        JMP     K27A                    ; IGNORE SYSTEM KEY
PAGE
;------ TEST FOR SHIFT KEYS
;
; HERE IS WHERE KB_FLAGS ARE SET.  WHAT HAPPENS IS, THE SYSTEM SEARCHES TABLE
; 'K6' FOR THE KEY.  IF FOUND, IT GETS THE APPROPRIATE BIT FROM TABLE 'K7'
; AND SETS IT ON. (TABLES ARE ALL AT THE TOP OF THIS ROUTINE)  FLAGS FOR THE
; SECOND ALT AND CTRL ARE SET IN KB_FLAG_3 AND HAVE THE SAME BIT POSITIONS AS
; THEIR ORIGINAL COUNTERPARTS IN KB_FLAG

K16A:   MOV     BL, KB_FLAG             ; PUT STATE FLAGS IN BL
        MOV     DI,OFFSET K6            ; SHIFT KEY TABLE
        MOV     CX,K6L                  ; LENGTH
        REPNE   SCASB                   ; LOOK THROUGH THE TABLE FOR A MATCH
        MOV     AL,AH                   ; RECOVER SCAN CODE
        JE      K17                     ; JUMP IF MATCH FOUND
        JMP     K25                     ; IF NO MATCH, THEN SHIFT NOT FOUND

;------ SHIFT KEY FOUND

K17:    SUB     DI,OFFSET K6+1          ; ADJUST PTR TO SCAN CODE MTCH
        MOV     AH,CS:K7[DI]            ; GET MASK INTO AH
        MOV     CL,2                    ; SET UP COUNT FOR FLAG SHIFTS
        TEST    AL,80H                  ; TEST FOR BREAK KEY
        JZ      K17C
        JMP     K23                     ; JUMP IF BREAK

;------ SHIFT MAKE FOUND, DETERMINE SET OR TOGGLE

K17C:   CMP     AH,SCROLL_SHIFT
        JAE     K18                     ; IF SCROLL SHIFT OR ABOVE, TOGGLE KEY

;------ PLAIN SHIFT KEY, SET SHIFT ON

        CMP     COUNTRY_FLAG,0FFh       ; ARE WE IN FOREIGN LANG MODE?
        JNE     K17C1                   ;  NO, US MODE, JUMP
        CMP     AL,ALT_KEY              ; IS THIS THE ALT KEY?
        JNE     K17C1                   ;  NO, NORMAL KEY
                                        ;**CNS

K17C1:  OR      KB_FLAG,AH              ; TURN ON SHIFT BIT
K17C2:  TEST    AH,CTL_SHIFT+ALT_SHIFT  ; IS IT ALT OR CTRL?
        JZ      K17F                    ;  NO, JUMP
K17D:   TEST    BH,LC_E0                ; IS THIS ONE OF THE NEW KEYS?
        JZ      K17E                    ;  NO, JUMP
        OR      KB_FLAG_3,AH            ; SET BITS FOR RIGHT CTRL, ALT
;        JMP     K26                    ; INTERRUPT_RETURN
        jmp     short K17G              ; (YST)

K17E:   SHR     AH,CL                   ; MOVE FLAG BITS TWO POSITIONS
        OR      KB_FLAG_1,AH            ; SET BITS FOR LEFT CTRL, ALT
;        JMP     K26                    ; INTERRUPT RETURN
        jmp     short K17G              ; (YST)

K17F:
        TEST    CS:SD.SPECIAL_FEATURES,TYPEWRITER_CAPS_LK
        JZ      K17G                    ; N..all done
        CMP     COUNTRY_FLAG,0FFh       ; ARE WE IN LANG MODE?
        JNE     K17G                    ;  NO, ALL DONE WITH SHIFT KEY

;------ If keyboard is P12 then we still need to release caps_lk

        TEST    BP,PC_LAP               ;  IS THIS A P12 KEYBOARD?
        JNZ     REMOVE_CAPS_SHIFT

        TEST    BH,KBX                  ; THIS THE ENHANCED KEYBOARD?
        JZ      K17G                    ;  NO, ALL DONE WITH SHIFT KEY
REMOVE_CAPS_SHIFT:
        AND     KB_FLAG,NOT CAPS_SHIFT ;  YES, TAKE KB OUT OF C_L STATE
        CALL    SND_LED                 ;   AND UPDATE THE LED INDICATORS
K17G:


; ===========================================
;   Russian Keyboard (YST)
; ===========================================
        CMP     COUNTRY_FLAG,0FFh       ; ARE WE IN FOREIGN LANG MODE?   (YST)
        JNE     K17H                    ; NO, US MODE, RETURN            (YST)
        TEST    CS:SD.SPECIAL_FEATURES,SHIFTS_TO_LOGIC; CAN OUR STATE    (YST)
                                        ; LOGIC SUPPORT THIS CALL?       (YST)
        JZ      K17H                    ; NO, RETURN                     (YST)
        OR      CS:FLAGS_TO_TEST[EXT_KB_FLAG_ID],SHIFTS_PRESSED;         (YST)
                                        ; SET FLAG FOR STATE LOGIC       (YST)
        CALL    KEYB_STATE_PROCESSOR    ; ********                       (YST)
        AND     CS:FLAGS_TO_TEST[EXT_KB_FLAG_ID],NOT SHIFTS_PRESSED;     (YST)
                                        ; CLEAR FLAG AFTER USE           (YST)
; ===========================================
;   End of Russian Keyboard (YST)
; ===========================================


K17H:   JMP     K26                     ;  RETURN

;------ TOGGLED SHIFT KEY, TEST FOR 1ST MAKE OR NOT

K18:                                    ; SHIFT-TOGGLE
        TEST    BL,CTL_SHIFT            ; CHECK CTL SHIFT STATE
        JZ      K18A                    ; JUMP IF NOT CTL STATE
        JMP     K25                     ; JUMP IF CTL STATE
K18A:   CMP     AL,INS_KEY              ; CHECK FOR INSERT KEY
        JNE     K22                     ; JUMP IF NOT INSERT KEY
        TEST    BL,ALT_SHIFT            ; CHECK FOR ALTERNATE SHIFT
        JZ      K18B                    ; JUMP IF NOT ALTERNATE SHIFT
        JMP     K25                     ; JUMP IF ALTERNATE SHIFT
K18B:   TEST    BH,LC_E0                ; IS THIS THE NEW INSERT KEY?
        JNZ     K22                     ; YES, THIS ONE'S NEVER A "0"
K19:    TEST    BL,NUM_STATE            ; CHECK FOR BASE STATE
        JNZ     K21                     ; JUMP IF NUM LOCK IS ON
        TEST    BL,LEFT_SHIFT+RIGHT_SHIFT  ; TEST FOR SHIFT STATE
        JZ      K22                        ; JUMP IF BASE STATE
K20:    MOV     AH,AL                   ; PUT SCAN CODE BACK IN AH
        JMP     K25                     ; NUMERAL "0", STNDRD. PROCESSING

K21:    TEST    BL,LEFT_SHIFT+RIGHT_SHIFT  ; MIGHT BE NUMERIC
        JZ      K20                        ; IS NUMERIC, STD. PROC.

K22:                                    ; SHIFT TOGGLE KEY HIT; PROCESS IT
        TEST    AH, KB_FLAG_1           ; IS KEY ALREADY DEPRESSED?
        JZ      K22A
        JMP     K26                     ; JUMP IF KEY ALREADY DEPRESSED
K22A:   OR      KB_FLAG_1,AH            ; INDICATE THAT THE KEY IS DEPRESSED
        XOR     KB_FLAG,AH              ; TOGGLE THE SHIFT STATE

        TEST    CS:SD.SPECIAL_FEATURES,TYPEWRITER_CAPS_LK
        JZ      K22C                    ; N..all done

;------ If keyboard is P12 then we do not toggle

        TEST    BP,PC_LAP               ;  IS THIS A P12 KEYBOARD?
        JNZ     LAP_SO_DONT_TOGGLE

        TEST    BH,KBX                  ; THIS THE ENHANCED KEYBOARD?
        JZ      K22C                    ;  NO, ALL DONE WITH TOGGLE KEYS

LAP_SO_DONT_TOGGLE:
        CMP     CS:COUNTRY_FLAG,0FFh    ; ARE WE IN FOREIGN LANG MODE?
        JNE     K22C                    ;  NO, NO SPECIAL STUFF FOR U.S.
        TEST    AH,CAPS_SHIFT           ; IS IT THE CAPS_LOCK KEY?
        JZ      K22C                    ;  NO, NOTHING ELSE TO DO
        OR      KB_FLAG,AH              ;  YES, SET CAPS_LOCK (NOT TOGGLE)

K22C:

;------ TOGGLE LED IF CAPS, NUM, OR SCROLL KEY DEPRESSED

        TEST    AH,CAPS_SHIFT+NUM_SHIFT+SCROLL_SHIFT ; SHIFT TOGGLE?
        JZ      K22B                    ; GO IF NOT
        PUSH    AX                      ; SAVE SCAN CODE AND SHIFT MASK
        CALL    SND_LED                 ; GO TURN MODE INDICATORS ON
        POP     AX                      ; RESTORE SCAN CODE

K22B:   CMP     AL,INS_KEY              ; TEST FOR 1ST MAKE OF INSERT KEY
        JNE     K26                     ; JUMP IF NOT INSERT KEY
        MOV     AH,AL                   ; SCAN CODE IN BOTH HALVES OF AX
        JMP     K28                     ; FLAGS UPDATED, PROC. FOR BUFFER

;------ BREAK SHIFT FOUND

K23:                                    ; BREAK-SHIFT-FOUND
        CMP     AH,SCROLL_SHIFT         ; IS THIS A TOGGLE KEY?
        NOT     AH                      ; INVERT MASK
        JAE     K24                     ; YES, HANDLE BREAK TOGGLE
        AND     KB_FLAG,AH              ; TURN OFF SHIFT BIT
        CMP     AH,NOT CTL_SHIFT        ; IS THIS ALT OR CTL?
        JA      K23D                    ;  NO, ALL DONE

        TEST    BH,LC_E0                ; 2ND ALT OR CTL?
        JZ      K23A                    ; NO, HANDLE NORMALLY
        AND     KB_FLAG_3,AH            ; RESET BIT FOR RIGHT ALT OR CTL
        JMP     SHORT K23B              ; CONTINUE
K23A:   SAR     AH,CL                   ; MOVE THE MASK BIT TWO POSITIONS
        AND     KB_FLAG_1,AH            ; RESET BIT FOR LEFT ALT OR CTL
K23B:   MOV     AH,AL                   ; SAVE SCAN CODE
        MOV     AL, KB_FLAG_3           ; GET RIGHT ALT & CTRL FLAGS
        CMP     COUNTRY_FLAG,0FFH       ; ARE WE IN LANGUAGE MODE?
        JNE     K23C                    ;  NO, LEAVE RIGHT FLAGS AS IS
;**CNS
        AND     AL,NOT GRAPH_ON         ;  YES, FILTER OUT THE ALT_GR KEY
;**CNS
K23C:   SHR     AL,CL                   ; MOVE TO BITS 1 & 0
        OR      AL, KB_FLAG_1           ; PUT IN LEFT ALT & CTL FLAGS
        SHL     AL,CL                   ; MOVE BACK TO BITS 3 & 2
        AND     AL,ALT_SHIFT+CTL_SHIFT  ; FILTER OUT OTHER GARBAGE
        OR      KB_FLAG,AL              ; PUT RESULT IN THE REAL FLAGS
        MOV     AL,AH                   ; RECOVER SAVED SCAN CODE

K23D:   CMP     AL,ALT_KEY+80H          ; IS THIS ALTERNATE SHIFT RELEASE
        JNE     K26                     ; INTERRUPT_RETURN

;------ ALTERNATE SHIFT KEY RELEASED, GET THE VALUE INTO BUFFER

        MOV     AL, ALT_INPUT
        xor     ah,ah                   ; scan code of 0
        MOV     ALT_INPUT,AH            ; ZERO OUT THE FIELD
        or      al,al                   ; was the input = 0?
        JE      K26                     ; INTERRUPT_RETURN
        CALL    BUFFER_FILL_ANY_CHAR    ; Put in buffer, but use this
                                        ;  entry point to avoid trashing
                                        ;   an ASCII code of 255
        JMP     SHORT K26               ; INTERRUPT_RETURN

K24:                                    ; BREAK-TOGGLE
        AND     KB_FLAG_1,AH            ; INDICATE NO LONGER DEPRESSED
        JMP     SHORT K26               ; INTERRUPT_RETURN

;------ TEST FOR HOLD STATE
                                        ; AL, AH = SCAN CODE
K25:                                    ; NO-SHIFT-FOUND
        CMP     AL,80H                  ; TEST FOR BREAK KEY
        JAE     K26                     ; NOTHING FOR BREAK CHARS FROM HERE ON
        TEST    KB_FLAG_1,HOLD_STATE    ; ARE WE IN HOLD STATE
        JZ      K28                     ; BRANCH AROUND TEST IF NOT
        CMP     AL,NUM_KEY
        JE      K26                     ; CAN'T END HOLD ON NUM_LOCK
        AND     KB_FLAG_1,NOT HOLD_STATE  ; TURN OFF THE HOLD STATE BIT

K26:
        AND     KB_FLAG_3,NOT LC_E0+LC_E1 ; RESET LAST CHAR H.C. FLAG

K26A:                                   ; INTERRUPT-RETURN
ifdef  NOT_NTVDM
        ;; NTVDM CLI                             ; TURN OFF INTERRUPTS
        CALL    ERROR_BEEP              ; CHECK FOR ERROR BEEP PENDING

        CMP     CS:BUFFER_ENTRY_OK,YES  ; HAS A CHARACTER BEEN PLACED IN BUFFER
        JNE     K27                     ;  NO, SKIP POST

        MOV     byte ptr CS:BUFFER_ENTRY_OK,NO  ; CLEAR POST CHARACTER IN BUFFER FLAG
        MOV     AX,09102H               ; MOVE IN POST CODE & TYPE
        INT     15H                     ; PERFORM OTHER FUNCTION
K27:
        MOV     AL,ENA_KBD              ; ENSURE KEYBOARD IS ENABLED (AT PS/2)
        CALL    SHIP_IT                 ; EXECUTE ENABLE
else

        mov     ah, 2
        mov     bh, CS:BEEP_PENDING
        mov     bl, CS:BUFFER_ENTRY_OK
        MOV     byte ptr CS:BUFFER_ENTRY_OK,NO
        MOV     byte ptr CS:BEEP_PENDING,NO
        BOP     09h
endif


K27A:   ;; NTVDM CLI                             ; DISABLE INTERRUPTS
        POP     ES                      ; RESTORE REGISTERS
        POP     DS                      ; *
        POP     DI                      ; *
        POP     SI                      ; *
        POP     DX                      ; *
        POP     CX                      ; *
        POP     BX                      ; *
        POP     AX                      ; *
        POP     BP                      ; *

        jmp DOIRET                            ; RETURN
PAGE
;------ NOT IN HOLD STATE
                                        ; AL, AH = SCAN CODE (ALL MAKES)
K28:                                    ; NO-HOLD-STATE
        CMP     AL,H_LAST_SCAN          ; TEST FOR OUT-OF-RANGE SCAN CODES
        JA      SHORT K26               ; IGNORE IF OUT-OF-RANGE
ifndef JAPAN
        TEST    BP,EXT_122              ; IS EXTENDED 122 KEYBOARD SUPPORT OK
else ; JAPAN
					; Must pass 07Eh and 07Fh DBCS pseudo's;AN013
					; IS DBCS KEYBOARD support code active ;AN013
	TEST	BP,EXT_122+DBCS_OK	;  or EXTENDED 122 KEYBOARD support OK ;AN013
endif ; JAPAN
        JNZ     K28_122                 ; SKIP NON-122 OUT-OF-RANGE CHECK

ifdef NOT_NTVDM
        CMP     AL,88                   ; TEST FOR OUT-OF-RANGE SCAN CODES
else
        CMP     AL,7Eh                  ; MAX SCANCODE ON BRAZILIAN ABNT KBD
endif
        JA      K26                     ; IGNORE IF OUT-OF-RANGE

K28_122:
        TEST    BL,ALT_SHIFT            ; ARE WE IN ALTERNATE SHIFT?
        JZ      K28A                    ; JUMP IF NOT ALTERNATE

        TEST    BH,KBX                  ; IS THIS THE ENHANCED KEYBOARD?
        JZ      K29                     ; NO, ALT STATE IS REAL

        TEST    KB_FLAG_1,SYS_SHIFT     ; YES, IS SYSREQ KEY DOWN?
        JZ      K29                     ;  NO, ALT STATE IS REAL
;**CNS
         TEST    AH,LC_E0               ; IS IT THE ALT_GR KEY?
         JZ      K28A                   ; YES,   DON'T SET KB_FLAG

         TEST    AL,R_ALT_SHIFT         ; TURN ON SHIFT BIT
         JNZ     K29                    ; TURN ON SHIFT BIT
;**CNS

K28A:   JMP     K38                     ;  YES, THIS IS PHONY ALT STATE
                                        ;       DUE TO PRESSING SYSREQ

;------ TEST FOR RESET KEY SEQUENCE (CTL ALT DEL) OR HOT KEY DEPRESSED

K29:                                    ; TEST-RESET
        TEST    BL,CTL_SHIFT            ; ARE WE IN CONTROL SHIFT ALSO?
ifndef JAPAN
        JZ      K31                     ; NO_RESET
else ; JAPAN
	JZ	K31C			; NO_RESET, Not in Ctrl state
endif ; JAPAN
        CMP     AL,DEL_KEY              ; SHIFT STATE IS THERE, TEST KEY
        JNE     K31A                    ; NO_RESET,  TRANSLATE TABLE SWAP

;------ CTL-ALT-DEL HAS BEEN FOUND, DO I/O CLEANUP

        MOV     RESET_FLAG,1234H        ; SET FLAG FOR RESET FUNCTION
        AND     WORD PTR  KB_FLAG_3,KBX ; CLEAR ALL FLAG BITS EXCEPT KBX   PED 6-25-86
        JMP     RESET                   ; JUMP TO POWER ON DIAGNOSTICS

ifdef JAPAN
;------ SET COUNTRY FLAG TO INDICATE WHICH TABLE WE'RE USING, FOREIGN OR DOMESTIC

K31A:	CMP	AL,CS:SD.HOT_KEY_ON_SCAN ; TEST FOR HOT KEY TO US
	JNE	K31B
	MOV	CS:COUNTRY_FLAG,00	; SET FLAG FOR DOMESTIC KEY'S
	JMP	K26			; INTERRUPT RETURN

K31B:	CMP	AL,CS:SD.HOT_KEY_OFF_SCAN ; TEST FOR HOT KEY TO FOREIGN
	JNE	K31C			; IF NOT TEST FOR FRONT ENGRAV
	MOV	CS:COUNTRY_FLAG,0FFH	; SET FLAGS FOR FOREIGN KEY'S
	JMP	K26			; INTERRUPT RETURN


;------ ALT STATE, OR CTRL AND ALT DOWN BUT NO HOT KEY F1/F2 OR DEL KEY        ;AN014

K31C:	CMP	CS:COUNTRY_FLAG,0FFH	; Check for country translate flag set ;AN014
	JNE	K31			; Else try ALT_KEY_PAD special cases   ;AN014

	CALL	KEYB_STATE_PROCESSOR	; Let NLS handle it's differences      ;AN014
	JC	K32A	;K26		;    TRANSLATIONS FOUND - EXIT
endif ; JAPAN

;------ IN ALTERNATE SHIFT, RESET NOT FOUND

K31:                                    ; NO-RESET
        CALL    KEYB_STATE_PROCESSOR
ifndef JAPAN
        JC      K26                     ;    TRANSLATIONS FOUND - EXIT
else ; JAPAN
	JNC	K310
        JMP     K26                     ;    TRANSLATIONS FOUND - EXIT
K310:
endif ; JAPAN

        CMP     AL,57                   ; TEST FOR SPACE KEY
        JNE     K311                    ; NOT THERE
        MOV     AL,' '                  ; SET SPACE CHAR
        JMP     K57                     ; BUFFER_FILL
K311:
        TEST    BP,EXT_16               ; IS EXTENDED INT 16 LOADED?
        JZ      K32                     ;  NO, SKIP THIS EXTENDED STUFF
        CMP     AL,15                   ; TEST FOR TAB KEY
        JNE     K312                    ; NOT THERE
        MOV     AX,0A500h               ; SET SPECIAL CODE FOR ALT-TAB
        JMP     K57                     ; BUFFER_FILL
K312:
        CMP     AL,74                   ; TEST FOR KEYPAD -
        JE      K312A                   ; GO PROCESS
        CMP     AL,78                   ; TEST FOR KEYPAD +
        JNE     K32                     ; SKIP TEST FOR LANG SWAP & CONT.
K312A:  JMP     K37B                    ; GO PROCESS

ifndef JAPAN
;------ SET COUNTRY FLAG TO INDICATE WHICH TABLE WE'RE USING, FOREIGN OR DOMESTIC

K31A:   CMP     AL,CS:SD.HOT_KEY_ON_SCAN ; TEST FOR HOT KEY TO US
        JNE     K31B
        MOV     CS:COUNTRY_FLAG,00      ; SET FLAG FOR DOMESTIC KEY'S
        JMP     K26                     ; INTERRUPT RETURN

K31B:   CMP     AL,CS:SD.HOT_KEY_OFF_SCAN ; TEST FOR HOT KEY TO FOREIGN
        JNE     K31C                    ; IF NOT TEST FOR FRONT ENGRAV
        MOV     CS:COUNTRY_FLAG,0FFH    ; SET FLAGS FOR FOREIGN KEY'S
        JMP     K26                     ; INTERRUPT RETURN


;------ ALT, CTRL DOWN ; NO HOT KEY

K31C:   CMP     CS:COUNTRY_FLAG,0FFH
        JNE     K32                     ; TRY ALT_KEY_PAD
        CALL    KEYB_STATE_PROCESSOR
        JC      K32A    ;K26            ;    TRANSLATIONS FOUND - EXIT
endif ; !JAPAN

;------ LOOK FOR KEY PAD ENTRY

K32:                                    ; ALT-KEY-PAD
        MOV     DI,OFFSET K30           ; ALT-INPUT-TABLE
        MOV     CX,10                   ; LOOK FOR ENTRY USING KEYPAD
        REPNE   SCASB                   ; LOOK FOR MATCH
        JNE     K33                     ; NO_ALT_KEYPAD
        TEST    BH,LC_E0                ; IS THIS ONE OF THE NEW KEYS?
        JNZ     K37C                    ;  YES, JUMP, NOT NUMPAD KEY
        SUB     DI,OFFSET K30+1         ; DI NOW HAS ENTRY VALUE
        MOV     AL, ALT_INPUT           ; GET THE CURRENT BYTE
        MOV     AH,10                   ; MULTIPLY BY 10
        MUL     AH
        ADD     AX,DI                   ; ADD IN THE LATEST ENTRY
        MOV      ALT_INPUT,AL           ; STORE IT AWAY
K32A:   JMP     K26                     ; THROW AWAY THAT KEYSTROKE

;------ LOOK FOR SUPERSHIFT ENTRY

K33:                                    ; NO-ALT-KEYPAD
        MOV      ALT_INPUT,0            ; ZERO ANY PREVIOUS ENTRY INTO INPUT
                                        ; DI,ES ALREADY POINTING
        MOV     CX,K30_LEN              ; NORMALLY 26, BUT 27 FOR FR, DUE
                                        ;  TO THE ";" KEY BEING "M"
        REPNE   SCASB                   ; LOOK FOR MATCH IN ALPHABET
        JE      K37A                    ; MATCH FOUND, GO FILL THE BUFFER

;------ LOOK FOR TOP ROW OF ALTERNATE SHIFT

K34:                                    ; ALT-TOP-ROW
        CMP     AL,2                    ; KEY WITH '1' ON IT
        JB      K37B                    ; MUST BE ESCAPE
        CMP     AL,13                   ; IS IT IN THE REGION
        JA      K35                     ;  NO, ALT-SOMETHING ELSE
        ADD     AH,118                  ; CONVERT PSEUDO SCAN CODE TO RANGE
        JMP     SHORT K37A              ; GO FILL THE BUFFER

;------ TRANSLATE ALTERNATE SHIFT PSEUDO SCAN CODES

K35:                                    ; ALT-FUNCTION
        CMP     AL,F11_M                ; IS IT F11 or GREATER ?
        JB      K35A                    ;  NO, BRANCH
        SUB     AL,52h                  ; SET UP TO SEARCH ALT-FUNCTION-TABLE
        MOV     BX,OFFSET K30A          ; BASE CASE TABLE
        JMP     K64                     ; CONVERT TO PSEUDO SCAN

K35A:   TEST    BH,LC_E0                ; DO WE HAVE ONE OF THE NEW KEYS?
        JZ      K37                     ;  NO, JUMP
        TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 LOADED?
        JZ      K37                     ;  NO, DO COMPATIBLE OUTPUT
        CMP     AL,28                   ; TEST FOR KEYPAD ENTER
        JNE     K35B                    ; NOT THERE
        MOV     AX,0A600h               ; SPECIAL CODE
        JMP     K57                     ; BUFFER FILL
K35B:   CMP     AL,83                   ; TEST FOR DELETE KEY
        JE      K37C                    ; HANDLE WITH OTHER EDIT KEYS
        CMP     AL,53                   ; TEST FOR KEYPAD /
        JNE     K32A                    ; NOT THERE, NO OTHER E0 SPECIALS
        MOV     AX,0A400h               ; SPECIAL CODE
        JMP     K57                     ; BUFFER FILL

K37:    CMP     AL,59                   ; TEST FOR FUNCTION KEYS (F1)
        JB      K37B                    ;  NO FN, HANDLE W/OTHER EXTENDED
        CMP     AL,68                   ; IN KEYPAD REGION?
                                        ; OR NUMLOCK, SCROLLOCK?
        JA      K32A                    ; IF SO, IGNORE
        ADD     AH,45                   ; CONVERT TO PSEUDO SCAN CODE

K37A:   xor     al,al                   ; ASCII CODE OF ZERO
        JMP     K57                     ; PUT IT IN THE BUFFER

K37B:
        TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 LOADED?
        JZ      K32A    ;K26               ;  NO, IGNORE THIS ONE
        MOV     AL,0F0h                 ; USE SPECIAL ASCII CODE
        JMP     K57                     ; PUT IT IN THE BUFFER

K37C:
        TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 LOADED?
        JZ      K37A                    ;  NO, DO COMPATIBLE OUTPUT
        ADD     AL,80                   ; CONVERT SCAN CODE (EDIT KEYS)
        MOV     AH,AL                   ; (SCAN CODE NOT IN AH FOR INSERT)
        JMP     K37A                    ; PUT IT IN THE BUFFER
PAGE
;------ NOT IN ALTERNATE SHIFT

K38:                                    ; NOT-ALT-SHIFT
                                        ; BL STILL HAS SHIFT FLAGS
        TEST    BL,CTL_SHIFT            ; ARE WE IN CONTROL SHIFT?
        JNZ     K38A                    ;  YES, START PROCESSING
        JMP     K44                     ; NOT-CTL-SHIFT

;------ CONTROL SHIFT, TEST SPECIAL CHARACTERS

;------ TEST FOR BREAK

K38A:   CMP     AL,SCROLL_KEY           ; TEST FOR BREAK
        JNE     K39                     ; JUMP, NO-BREAK
        TEST    BP,PC_LAP               ; IS THIS THE LAP COMPUTER?
        JNZ     K38B                    ;  YES, THIS IS CTRL-BREAK
        TEST    BH,KBX                  ; IS THIS THE ENHANCED KEYBOARD?
        JZ      K38B                    ;  NO, BREAK IS VALID
        TEST    BH,LC_E0                ;  YES, WAS LAST CODE AN E0?
        JZ      K39                     ;   NO-BREAK, TEST FOR PAUSE

K38B:
        ;; NTVDM CLI                             ; Disable interrupts because EOI issued
        MOV     BX, BUFFER_HEAD         ; RESET BUFFER TAIL TO BUFFER HEAD
        MOV      BUFFER_TAIL,BX
        MOV      BIOS_BREAK,80H         ; TURN ON BIOS_BREAK BIT

;-------- ENABLE KEYBOARD

ifdef NOT_NTVDM
        MOV     AL,ENA_KBD              ; ENABLE KEYBOARD
        CALL    SHIP_IT                 ; EXECUTE ENABLE
else
        mov     ah, 4
        BOP     09h
endif
        INT     1BH                     ; BREAK INTERRUPT VECTOR
        SUB     AX,AX                   ; PUT OUT DUMMY CHARACTER
        JMP     K57                     ; BUFFER_FILL

;-------- TEST FOR PAUSE

K39:                                    ; NO-BREAK
        CMP     AL,NUM_KEY              ; LOOK FOR PAUSE KEY
        JNE     K41                     ; NO-PAUSE
        TEST    BH,KBX                  ; IS THIS THE ENHANCED KEYBOARD?
        JZ      K39P                    ;  NO, THIS IS A VALID PAUSE
        TEST    BP,PC_LAP               ; IS THIS THE LAP COMPUTER?
        JZ      K41                     ;  NO, IT'S NOT PAUSE THIS TIME
K39P:   OR      KB_FLAG_1,HOLD_STATE    ; TURN ON THE HOLD FLAG

;-------- ENABLE KEYBOARD

        MOV     AL,ENA_KBD              ; ENABLE KEYBOARD
        CALL    SHIP_IT                 ; EXECUTE ENABLE

ifdef NOT_NTVDM

;------ DURING PAUSE INTERVAL, TURN CRT BACK ON

        CMP     CRT_MODE,7              ; IS THIS BLACK AND WHITE CARD
        JAE     K40                     ; YES, NOT CGA MODES NOTHING TO DO
        MOV     DX,03D8H                ; PORT FOR COLOR CARD
        MOV     AL,CRT_MODE_SET         ; GET THE VALUE OF THE CURRENT MODE
        OUT     DX,AL                   ; SET THE CRT MODE, SO THAT CRT IS ON
K40:                                    ; PAUSE-LOOP
        TEST    BP,PC_LAP               ; IS THIS THE LAP COMPUTER?
        JZ      K40A                    ;  NO, SKIP THE BATTERY LIFE STUFF
        MOV     AX,4104H                ; FUNCTION 41, AL=04=RETURN IF 0
        MOV     BX,HOLD_STATE*100H      ; BH=HOLD_STATE, BL=0=NO TIME OUT
        PUSH    DS                      ; MAKE ES:DI POINT TO KB_FLAG_1
        POP     ES
        MOV     DI,OFFSET  KB_FLAG_1
        INT     15H                     ; SLEEP UNTIL OUT OF HOLD

;------ CHECK FOR AUX ADAPTER INPUT PENDING
K40A:
        MOV CX,100                      ; COUNT FOR WAIT LOOP
else
        mov     ah, 3                   ; K27A exit notify
        BOP     09h
        call DOSTI
K40A:
        mov   cx, 16
        xor   ax, ax
        BOP   BOP_WAITIFIDLE            ; idle bop
endif
K40B:
        TEST    KB_FLAG_1,HOLD_STATE    ; ARE WE IN HOLD STATE
        JZ K40E                         ; EXIT IF NOT

ifdef NOT_NTVDM
        TEST    BP,PC_XT+PC_LAP                 ; Check for systems without AUX BIOS
        JNZ     K40B                    ; For them, just loop on hold flag

        IN      AL,STATUS_PORT          ; READ CURRENT STATUS
        AND     AL,MOUSE_OBF+OUT_BUF_FULL ; MASK OFF ALL BUT MOUSE DATA BITS
        CMP     AL,MOUSE_OBF+OUT_BUF_FULL ; IS THERE STILL MOUSE DATA PENDING?
endif
        LOOPE   K40B                    ; WAIT FOR MOUSE DATA TO GO
        JNE     K40A                    ; CONTINUE IF PAUSE STATE              ;an005
K40E:
ifndef NOT_NTVDM
        call    DOCLI
endif
        AND     KB_FLAG_1,NOT HOLD_STATE ; CLEAR HOLD STATE FLAG
        JMP     K27A                    ; INTERRUPT_RETURN_NO_EOI      PTR 2247

;------ TEST SPECIAL CASE KEY 55

K41:                                    ; NO-PAUSE
        CMP     AL,55                   ; TEST FOR */PRTSC KEY
        JNE     K42                     ; NOT-KEY-55
        TEST    BP,PC_LAP               ; IS THIS THE LAP COMPUTER?
        JZ      K41B                    ;  NO, JUMP
        TEST    BH,LC_E0                ;  YES, WAS LAST CODE AN E0?
        JZ      K41A                    ;    NO, THIS IS THE PRTSC KEY
        JMP     SHORT K42B              ;    YES, E0 MEANS THE "*" KEY

K41B:   TEST    BH,KBX                  ; IS THIS THE ENHANCED KEYBOARD?
        JZ      K41A                    ;  NO, CTL-PRTSC IS VALID
        TEST    BH,LC_E0                ;  YES, WAS LAST CODE AN E0?
        JZ      K42B                    ;   NO, TRANSLATE TO A FUNCTION
K41A:   MOV     AX,114*256              ; START/STOP PRINTING SWITCH
        JMP     K57                     ; BUFFER_FILL

;------ SET UP TO TRANSLATE CONTROL SHIFT

K42:                                    ; NOT-KEY-55
ifdef JAPAN
	CMP	CS:COUNTRY_FLAG,0FFH	; Check for country translate flag set
	JNE	K42US			; Skip overhead if not in country mode
endif ; JAPAN
	CALL	KEYB_STATE_PROCESSOR
        JC      K449    ;K26            ; TRANSLATIONS FOUND - EXIT
ifdef JAPAN
K42US:
endif ; JAPAN
        CMP     AL,15                   ; IS IT THE TAB KEY?
        JE      K42B                    ;  YES, XLATE TO FUNCTION CODE
        CMP     AL,53                   ; IS IT THE / KEY?
        JNE     K42A                    ;  NO, NO MORE SPECIAL CASES
        TEST    BH,LC_E0                ;  YES, IS IT FROM THE KEYPAD?
        JZ      K42A                    ;   NO, JUST TRANSLATE
        MOV     AX,9500h                ;   YES, SPECIAL CODE FOR THIS ONE
        JMP     K57                     ;   BUFFER FILL

K42A:   MOV     BX,OFFSET K8            ; SET UP TO TRANSLATE CTL
        CMP     AL,59                   ; IS IT IN CHARACTER TABLE?
        JB      K45F                    ;  YES, GO TRANSLATE CHAR
K42B:   MOV     BX,OFFSET K8            ; SET UP TO TRANSLATE CTL
        JMP     K64                     ;  NO, GO TRANSLATE_SCAN
PAGE
;------ NOT IN CONTROL SHIFT

K44:
ifdef JAPAN
	CMP	CS:COUNTRY_FLAG,0FFH	; Check for country translate flag set
	JNE	K44US			; Skip overhead if not in country mode
endif ;JAPAN
	CALL	KEYB_STATE_PROCESSOR
        JC      K449    ;K26            ; TRANSLATIONS FOUND - EXIT
ifdef JAPAN
K44US:
endif ; JAPAN
        CMP     AL,55                   ; PRINT SCREEN KEY?
        JNE     K45                     ; NOT-PRINT-SCREEN
        TEST    BP,PC_LAP               ; IS THIS THE LAP COMPUTER?
        JZ      K441                    ;  NO, JUMP
        TEST    BH,LC_E0                ;  YES, WAS LAST CODE THE MARKER?
        JZ      K44A                    ;       NO, TEST THE SHIFT STATE
        JMP     SHORT K45C              ;       YES, XLATE TO "*" CHAR
K441:   TEST    BH,KBX                  ; IS THIS ENHANCED KEYBOARD?
        JZ      K44A                    ; NO, TEST FOR SHIFT STATE
        TEST    BH,LC_E0                ; YES, LAST CODE A MARKER?
        JNZ     K44B                    ;  YES, IS PRINT SCREEN
        JMP     SHORT K45C              ;  NO, XLATE TO "*" CHARACTER
K44A:   TEST    BL,LEFT_SHIFT+RIGHT_SHIFT  ;NOT 101 KBD, SHIFT KEY DOWN?
        JZ      K45C                       ; NO, XLATE TO "*" CHARACTER

;------ ISSUE INTERRUPT TO PERFORM PRINT SCREEN FUNCTION
K44B:
        ;; NTVDM CLI                         ; DISABLE INTERRUPTS           PTR 2355
        AND     KB_FLAG_3,NOT LC_E0+LC_E1 ;ZERO OUT THESE FLAGS

ifdef NOT_NTVDM
        MOV     AL,ENA_KBD              ; INSURE KEYBOARD IS ENABLED
        CALL    SHIP_IT                 ; EXECUTE ENABLE
else
        mov     ah, 3                   ; K27A exit notify
        BOP     09h
endif
        PUSH    BP                      ; SAVE POINTER (compatibility)
        INT     5H                      ; ISSUE PRINT SCREEN INTERRUPT
        POP     BP                      ; RESTORE POINTER
        JMP     K27A                    ; EXIT WITHOUT EXTRA EOI OR ENABLE

K449:
        JMP     K26                     ; EXIT

;------ HANDLE THE IN-CORE KEYS
K45:                                    ; NOT-PRINT-SCREEN
        CMP     AL,58                   ; TEST FOR IN-CORE AREA
        JA      K46                     ; JUMP IF NOT

        TEST    BH,GRAPH_ON             ; IS ALT GRAPHICS ON?              AEV
        JNZ     K449    ;K26            ; YES, TRASH KEYSTROKE

        CMP     AL,53                   ; IS THIS THE "/" KEY?
        JNE     K45A                    ;  NO, JUMP
        TEST    BH,LC_E0                ; WAS LAST CODE THE MARKER?
        JNZ     K45C                    ;  YES, TRANSLATE TO CHARACTER

K45A:   MOV     CX,K30_LEN              ; LENGTH OF SEARCH
        MOV     DI,OFFSET K30+10        ; POINT TO TABLE OF A-Z CHARS
        REPNE   SCASB                   ; IS THIS A LETTER KEY?
        JNE     K45B                    ;  NO, SYMBOL KEY

        TEST    BL,CAPS_STATE           ; ARE WE IN CAPS_LOCK?
        JNZ     K45D                    ; TEST FOR SURE
K45B:   TEST    BL,LEFT_SHIFT+RIGHT_SHIFT ; ARE WE IN SHIFT STATE?
        JNZ     K45E                      ; YES, UPPERCASE
                                          ; NO, LOWERCASE
K45C:   MOV     BX,OFFSET K10           ; TRANSLATE TO LOWERCASE LETTERS
        JMP     SHORT K56
K45D:                                   ; ALMOST-CAPS-STATE
        TEST    BL,LEFT_SHIFT+RIGHT_SHIFT ; CL ON. IS SHIFT ON, TOO?
        JNZ     K45C                    ; SHIFTED TEMP OUT OF CAPS STATE
K45E:   MOV     BX,OFFSET K11           ; TRANSLATE TO UPPERCASE LETTERS
K45F:   JMP     SHORT K56


;------ TEST FOR KEYS F1 - F10
K46:                                    ; NOT IN-CORE AREA
        CMP     AL,68                   ; TEST FOR F1 - F10
        JA      K47                     ; JUMP IF NOT
        JMP     SHORT K53A              ; YES, GO DO FN KEY PROCESS


;------ HANDLE THE NUMERIC PAD KEYS

K47:                                    ; NOT F1 - F10
        CMP     AL,83                   ; TEST FOR NUMPAD KEYS
        JA      K52                     ; JUMP IF NOT

;------ KEYPAD KEYS, MUST TEST NUM LOCK FOR DETERMINATION
K48:    CMP     AL,74                   ; SPECIAL CASE FOR MINUS
        JE      K45E                    ; GO TRANSLATE (US & WT ARE SAME)
        CMP     AL,78                   ; SPECIAL CASE FOR PLUS
        JE      K45E                    ; GO TRANSLATE (US & WT ARE SAME)
        TEST    BH,LC_E0                ; IS THIS ONE OF THE NEW KEYS?
        JNZ     K49                     ;  YES, TRANSLATE TO BASE STATE

        TEST    BL,NUM_STATE            ; ARE WE IN NUM_LOCK?
        JNZ     K50                     ; TEST FOR SURE
        TEST    BL,LEFT_SHIFT+RIGHT_SHIFT  ; ARE WE IN SHIFT STATE?
        JNZ     K51                        ; IF SHIFTED, REALLY NUM STATE

;------ BASE CASE FOR KEYPAD
K49:    CMP     AL,76                   ; SPECIAL CASE FOR BASE STATE 5
        JNE     K49A                    ; CONTINUE IF NOT KEYPAD 5
        TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 LOADED?
        JZ      K59     ;K26            ;  NO, INGORE

        MOV     AL,0F0h                 ; SPECIAL ASCII CODE
        JMP     SHORT K57               ; BUFFER FILL
K49A:   MOV     BX,OFFSET K10           ; BASE CASE TABLE
        JMP     SHORT K64               ; CONVERT TO PSEUDO SCAN

;------ MIGHT BE NUM LOCK, TEST SHIFT STATUS
K50:    TEST    BL,LEFT_SHIFT+RIGHT_SHIFT       ;ALMOST-NUM-STATE
        JNZ     K49                     ; SHIFTED TEMP OUT OF NUM STATE
K51:    JMP     SHORT K45E              ; REALLY_NUM_STATE
                                        ; (US & WT ARE SAME)

;------ TEST FOR THE NEW KEY ON WT KEYBOARDS

K52:                                    ; NOT A NUMPAD KEY
        CMP     AL,86                   ; IS IT THE NEW WT KEY?
        JNE     K53                     ; JUMP IF NOT
        MOV     AL,58                   ; WE'RE GOING TO PULL A SNEAKY
        JMP     K45                     ; TRICK HERE. WT TABLES ARE TOO SHORT TO
                                        ; XLATE 86, SO WE'LL CHANGE IT TO CAPS_LOCK
                                        ; AND PUT THE CHAR IN THE TABLES IN THE C_L
                                        ; POSITION, SINCE C_L SCAN CODES NEVER GET
                                        ; HERE ANYWAY.

;------ MUST BE F11 OR F12

K53:    TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 THERE?
        JZ      K59                     ;  NO, INGORE F11 & F12 (NEAR RET)
                                        ; F1 - F10 COME HERE, TOO
K53A:   TEST    BL,LEFT_SHIFT+RIGHT_SHIFT ;TEST SHIFT STATE
        JZ      K49                     ;   JUMP, LOWERCASE PSEUDO SC'S

        MOV     BX,OFFSET K11           ; UPPER CASE PSEUDO SCAN CODES
        JMP     SHORT K64               ; TRANSLATE_SCAN
PAGE
;------ TRANSLATE THE CHARACTER

K56:                                    ; TRANSLATE-CHAR
        DEC     AL                      ; CONVERT ORIGIN
        XLAT    CS:K11                  ; CONVERT THE SCAN CODE TO ASCII
        TEST    KB_FLAG_3,LC_E0         ; IS THIS A NEW KEY?
        JZ      K57                     ;  NO, GO FILL BUFFER
        TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 THERE?
        JZ      K57                     ;  NO, DO COMPATIBLE OUTPUT
        MOV     AH,MC_E0                ;  YES, PUT SPECIAL MARKER IN AH
        JMP     SHORT K57               ; PUT IT INTO THE BUFFER

;------ TRANSLATE SCAN FOR PSEUDO SCAN CODES

K64:                                    ; TRANSLATE-SCAN-ORGD
        DEC     AL                      ; CONVERT ORIGIN
        XLAT    CS:K8                   ; CTL TABLE SCAN
        MOV     AH,AL                   ; PUT VALUE INTO AH
        xor     al,al                   ; ZERO ASCII CODE
        TEST    KB_FLAG_3,LC_E0                 ; IS THIS A NEW KEY?
        JZ      K57                     ;  NO, GO FILL BUFFER
        TEST    BP,EXT_16               ; IS THE EXTENDED INT 16 THERE?
        JZ      K57                     ;  NO, DO COMPATIBLE OUTPUT
        MOV     AL,MC_E0                ;  YES, PUT SPECIAL MARKER IN AL

;------ PUT CHARACTER INTO BUFFER

K57:                                    ; BUFFER-FILL
ifdef JAPAN
	CMP	AH,0E0h 		; Was this the Ctrl-Enter key? DCR 1815;AN013
	JE	Short K57N122		; Do not add 122 key marker    DCR 1815;AN013
	CMP	AH,S_XKBD_SCAN		; Is it non 122-keyboard key?  DCR 1815;AN013
	JBE	Short K57N122		; Yes, skip add of 122 marker  DCR 1815;AN013
	CMP	CS:S_122_MARKER,0	;  Check special INT 16h case flag     ;AN013
	JE	K57N122 		;  Skip F8 marker, if INT 16h broken   ;AN013
	MOV	AL,S_122_MARK		; Add special marker F8 if 122 DCR 1815;AN013
K57N122:								       ;AN013
endif ; JAPAN
	CALL	BUFFER_FILL
K59:
        JMP     K26                     ;-- THAT'S ALL FOLKS --

KEYB_INT_9   ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Procedure: BUFFER_FILL
;
;  Description:
;      Generate keyboard buffer entry
;
;  Input Registers:
;      AX - the buffer entry
;      DS - BIOS data segment
;
;  Output Registers:
;      None
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

BUFFER_ENTRY_OK DB      NO              ; YES if character put into buffer

BUFFER_FILL     PROC   NEAR

;        CMP     AL,-1                   ; IS THIS AN IGNORE CHAR
;        JE      K61B                    ; YES, EXIT (commented YST)
        CMP     AH,-1                   ; LOOK FOR -1 PSEUDO SCAN
        JE      K61B                    ; EXIT
;
;  BUFFER_FILL_ANY_CHAR is an alternate entry point to this PROC.
;  Entry at this point will avoid trashing ASCII values of 255.
;
BUFFER_FILL_ANY_CHAR  LABEL  NEAR

        PUSH    SI
        PUSH    BX
        PUSH    DS                      ; This routine may be called
                                        ;  externally so make sure DS points
        MOV     BX,DATA                 ;   to BIOS data
        MOV     DS,BX

        ;; NTVDM cli                             ; disable interrupts  P724
        MOV     BX, BUFFER_TAIL         ; GET THE END POINTER TO THE BUFFER
        MOV     SI,BX                   ; SAVE THE VALUE
        INC     BX                      ; MOVE TO NEXT WORD IN LIST
        INC     BX

;; VERIFY IF THE CURRENT ROM LEVEL IN THE SYSTEM IS FOR THE ORIGINAL PC1

        TEST    BP,PC_81                ; CHECK FOR '81 DATE FLAG SET
ifndef JAPAN
        JNE     NOT_PC1                 ; IF IT'S A LATER ROM RELEASE, BRANCH
else ; JAPAN
	JZ	NOT_PC1 		; IF IT'S A LATER ROM RELEASE, BRANCH
endif ; JAPAN

        CMP     BX,OFFSET KB_BUFFER_END ; AT END OF BUFFER?
        JNE     K5                      ; NO, CONTINUE
        MOV     BX,OFFSET  KB_BUFFER    ; YES, RESET TO BUFFER BEGINNING
        JMP     SHORT K5
NOT_PC1:
        CMP     BX, BUFFER_END          ; AT END OF BUFFER?
        JNE     K5                      ; NO, CONTINUE
        MOV     BX, BUFFER_START        ; YES, RESET TO BUFFER BEGINNING
K5:
        CMP      BX,BUFFER_HEAD         ; HAS THE BUFFER WRAPPED AROUND
        JE      K62                     ; BUFFER_FULL_BEEP
        MOV     [SI],AX                 ; STORE THE VALUE
        MOV      BUFFER_TAIL,BX         ; MOVE THE POINTER UP
        MOV     CS:BUFFER_ENTRY_OK,YES  ; INDICATE WE PUT SOMETHING IN BUFFER
        JMP     SHORT K61A
K62:
        MOV     CS:BEEP_PENDING,YES     ; INDICATE WE NEED A BEEP
K61A:
        POP     DS
        POP     BX
        POP     SI
        ;; NTVDM sti                             ; enable interrupts  P724
K61B:
        RET
BUFFER_FILL     ENDP

PAGE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Procedure: ERROR_BEEP
;
;  Description:
;      General routine to generate beep tones
;
;  Input Registers:
;      None
;
;  Output Registers:
;      None
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


ERROR_BEEP      PROC    NEAR

	CMP	 CS:BEEP_PENDING,YES	 ; Q..SHOULD WE BEEP?
        JNE     NO_BEEP

        MOV     CS:BEEP_PENDING,NO      ; Reset BEEP required
ifndef NOT_NTVDM
        mov     ah, 0eh
        mov     al, 07h
        int     10h

else
        MOV     CX,216-32               ; NUMBER OF CYCLES FOR 1/8 SECOND TONE
        IN      AL,PORT_B               ; Get control info
        PUSH    AX
LOOP01:
        AND     AL,0FCH                 ; Turn off timer gate and speaker
        OUT     PORT_B,AL               ; output to control - speaker off
        CALL    WAITFB                  ; half cycle time for tone
        OR      AL,2                    ; turn on speaker
        CLI                             ; Disable interrupts for 1/2 cycle, 300u
        OUT     PORT_B,AL               ; output to control
        CALL    WAITFB                  ; another half cycle
        STI                             ; Enable interrupts between 1/2 cycle
        LOOP    LOOP01

        POP     AX
        OUT     PORT_B,AL               ; Restore control
        MOV     CX,32*2                 ; Short delay count of 32 cycles
LOOP02:
        CALL    WAITFB                  ; Add a short delay to complete 1/8 sec
        LOOP    LOOP02                  ; Repeat
        CLI                             ; Disable interrupts
endif

NO_BEEP:
        RET                             ; RETURN
ERROR_BEEP      ENDP


ifdef NOT_NTVDM
WAITFB  PROC    NEAR                    ;       DELAY FOR  (CX)*15.085737 US
        PUSH    AX                      ; SAVE WORK REGISTER (AH)
        PUSH    CX                      ; SAVE COUNT
        MOV     CX,19                   ; The half cycle time for 1745 hz
        TEST    BP,PC_AT+PC_386         ; IF THE SYSTEM IS AN 80x86
        JNZ     WAITF1                  ; SKIP TO REFRESH BIT DELAY

WAITF0:
        NOP                             ; Force two fetch cycles on Model 30
        LOOP    WAITF0                  ; SOFTWARE DELAY LOOP ON 808x MACHINES

        JMP     SHORT WAITFE            ; EXIT

WAITF1:                                 ;       USE TIMER 1 OUTPUT BITS
        IN      AL,PORT_B               ; READ CURRENT COUNTER OUTPUT STATUS
        AND     AL,REFRESH_BIT          ; MASK FOR REFRESH DETERMINE BIT
        CMP     AL,AH                   ; DID IT JUST CHANGE
        JE      WAITF1                  ; WAIT FOR A CHANGE IN OUTPUT LINE

        MOV     AH,AL                   ; SAVE NEW FLAG STATE
        LOOP    WAITF1                  ; DECREMENT HALF CYCLES TILL COUNT END
WAITFE:

        POP     CX                      ; RESTORE COUNT
        POP     AX                      ; RESTORE (AH)
        RET                             ; RETURN  (CX)= 0

WAITFB  ENDP
endif

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       SHIP_IT
;
;       THIS ROUTINE HANDLES TRANSMISSION OF COMMAND AND DATA BYTES
;       TO THE KEYBOARD CONTROLLER.
;
;       On entry the AL contains the command byte.
;       On Enable keyboard commands, the reset keyboard input latch is done
;       if the system is the old PC type.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SHIP_IT PROC    NEAR

ifdef NOT_NTVDM
;------- TEST SYSTEM TYPE
        PUSHF                           ; SAVE FLAGS    P725
        CLI                             ; DISABLE INTERRUPTS TILL DATA SENT

        TEST    BP,PC_XT+PC_LAP
        JZ      SI5                     ; USE AT 8042 COMMAND IF NOT PC TYPE

        CMP     AL,ENA_KBD              ; CHECK FOR ENABLE KEYBOARD COMMAND
        JNE     SI9                     ; SKIP ENABLE RESET
                                        ;   FOR PC, XT, P12: RESET THE KEYBOARD
        PUSH    AX                      ; SAVE AX
        IN      AL,KB_CTL               ; GET THE CONTROL PORT
        MOV     AH,AL                   ; SAVE VALUE
        OR      AL,80H                  ; RESET BIT FOR KEYBOARD ON PC/PC-XT
        OUT     KB_CTL,AL
        XCHG    AH,AL                   ; GET BACK ORIGINAL CONTROL
        OUT     KB_CTL,AL               ; KB HAS BEEN RESET
        POP     AX                      ; RESTORE AX
                                        ; EXIT as NOT next system
SI5:
        TEST    BP,PC_AT+PC_386         ; IF THE SYSTEM IS NOT AN 80x86
        JZ      SI9                     ; MACHINE, EXIT THIS PROC.

;------- WAIT FOR COMMAND TO BE ACCEPTED;

        CALL    chk_ibf                 ; GO READ KEYBOARD CONTROLLER STATUS
endif

        OUT     STATUS_PORT,AL          ; SEND TO KEYBOARD CONTROLLER

ifdef NOT_NTVDM
SI9:                                    ; ENABLE INTERRUPTS AGAIN
        POPF                            ; RESTORE FLAGS P725
endif
        RET                             ; RETURN TO CALLER
SHIP_IT ENDP

ifdef NOT_NTVDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       SND_DATA
;
;       THIS ROUTINE HANDLES TRANSMISSION OF COMMAND AND DATA BYTES
;       TO THE KEYBOARD AND RECEIPT OF ACKNOWLEDGEMENTS.  IT ALSO
;       HANDLES ANY RETRIES IF REQUIRED
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SND_DATA PROC   NEAR
        PUSH    AX                      ; SAVE REGISTERS
        PUSH    BX                      ; *
        PUSH    CX
        MOV     BH,AL                   ; SAVE TRANSMITTED BYTE FOR RETRIES

        MOV     BL,3                    ; LOAD RETRY COUNT
SD0:
        CLI                             ; DISABLE INTERRUPTS
        AND     KB_FLAG_2,NOT (KB_FE+KB_FA+kb_err) ; CLEAR ACK, RESEND and
                                                    ; error flags

        CALL    CHK_IBF                 ; Wait for command accepted

        MOV     AL,BH                   ; REESTABLISH BYTE TO TRANSMIT
        OUT     PORT_A,AL               ; SEND BYTE
        STI                             ; ENABLE INTERRUPTS
        MOV     CX,DLY_15MS             ; DELAY FOR 15 ms TIMEOUT
SD1:    TEST    KB_FLAG_2,KB_FE+KB_FA   ; SEE IF EITHER BIT SET
        JNZ     SD3                     ; IF SET, SOMETHING RECEIVED GO PROCESS
        IN      AL,PORT_B               ; WAIT LOOP USING REFRESH BIT
        AND     AL,REFRESH_BIT
        CMP     AL,AH
        JE      SD1                     ; KEEP TESTING
        MOV     AH,AL                   ; DEC CX ON REFRESH TIC
        LOOP    SD1                     ; KEEP TESTING
                                        ; !! TIMEOUT !!

SD2:    DEC     BL                      ; DECREMENT RETRY COUNT
        JNZ     SD0                     ; RETRY TRANSMISSION
        OR      KB_FLAG_2,KB_ERR        ; TURN ON TRANSMIT ERROR FLAG
        JMP     SHORT SD4               ; RETRIES EXHAUSTED FORGET TRANSMISSION

SD3:    TEST    KB_FLAG_2,KB_FA         ; SEE IF THIS IS AN ACKNOWLEDGE
        JZ      SD2                     ; IF NOT, GO RESEND

SD4:    POP     CX                      ; RESTORE REGISTERS
        POP     BX
        POP     AX                      ; *
        RET                             ; RETURN, GOOD TRANSMISSION
SND_DATA ENDP
endif

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       SND_LED
;
;       THIS ROUTINE TURNS ON THE MODE INDICATORS.
;
; NTVDM - we do not need to update led's as this is controlled
;         by the host\system. We also assume that interrupts are
;         off upon entry
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SND_LED PROC    NEAR
ifdef NOT_NTVDM
        CLI                             ; TURN OFF INTERRUPTS

        TEST    BP,PC_AT+PC_386         ; IF THE SYSTEM IS NOT A 80x86
        JZ      SL1                     ; MACHINE, EXIT THIS PROC
endif

        TEST    KB_FLAG_2,KB_PR_LED     ; CHECK FOR MODE INDICATOR UPDATE
        JNZ     SL1                     ; DONT UPDATE AGAIN IF UPDATE UNDERWAY
        OR      KB_FLAG_2,KB_PR_LED     ; TURN ON UPDATE IN PROCESS
ifdef NOT_NTVDM
        MOV     AL,LED_CMD              ; LED CMD BYTE
        CALL    SND_DATA                ; SEND DATA TO KEYBOARD
        CLI
endif
        CALL    MAKE_LED                ; GO FORM INDICATOR DATA BYTE
        AND     KB_FLAG_2,0F8H                  ; CLEAR MODE INDICATOR BITS
        OR      KB_FLAG_2,AL            ; SAVE PRESENT INDICATORS FOR NEXT TIME

        mov   ah, 3                     ; inform softpc to set lights
        BOP   16h


ifdef NOT_NTVDM
        TEST    KB_FLAG_2,KB_ERR        ; TRANSMIT ERROR DETECTED
        JNZ     SL2                     ;  YES, BYPASS SECOND BYTE TRANSMISSION
        CALL    SND_DATA                ; SEND DATA TO KEYBOARD
        CLI                             ; TURN OFF INTERRUPTS
        TEST    KB_FLAG_2,KB_ERR        ; TRANSMIT ERROR DETECTED
        JZ      SL3                     ; IF NOT, DONT SEND AN ENABLE COMMAND
SL2:    MOV     AL,KB_ENABLE            ; GET KEYBOARD CSA ENABLE COMMAND
        CALL    SND_DATA                ; SEND DATA TO KEYBOARD
        CLI                             ; TURN OFF INTERRUPTS
endif

SL3:    AND     KB_FLAG_2,NOT(KB_PR_LED+KB_ERR) ; TURN OFF MODE INDICATOR
                                        ; UPDATE AND TRANSMIT ERROR FLAG
SL1:
ifdef NOT_NTVDM
        STI                             ; ENABLE INTERRUPTS
endif
        RET                             ; RETURN TO CALLER
SND_LED ENDP
PAGE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       MAKE_LED
;
;       THIS ROUTINE FORMS THE DATA BYTE NECESSARY TO TURN ON/OFF
;       THE MODE INDICATORS
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MAKE_LED PROC   NEAR
        PUSH    CX                      ; SAVE CX
        MOV     AL, KB_FLAG             ; GET CAPS & NUM LOCK INDICATORS
        AND     AL,CAPS_STATE+NUM_STATE+SCROLL_STATE ; ISOLATE INDICATORS
        MOV     CL,4                    ; SHIFT COUNT
        ROL     AL,CL                   ; SHIFT BITS OVER TO TURN ON INDICATORS
        AND     AL,07H                  ; MAKE SURE ONLY MODE BITS ON
        POP     CX
        RET                             ; RETURN TO CALLER
MAKE_LED ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       CHK_IBF
;
;  Description:
;      Waits for a keyboard command to be accepted
;       wait until ibf = 0   (empty)
;
;  Input Registers:
;      None
;
;  Output Registers:
;       ZF=0    time out & IBF still full
;       ZF=1    IBF is empty
;
;       ---------------------------------------------------------------
;       This procedure replaces the previous one which used a software
;       timing loop.   (For 80286, 80386 and 80486 based machines.)
;       ---------------------------------------------------------------
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

chk_ibf proc    near

        push    ax                      ; Save register used
        push    cx
	mov	cx,DLY_15MS		; Timeout 15 milleseconds (15000/15.086;
chk_ibfl:
ifdef JAPAN
	in	al,status_port		; Read status port
	test	al,inpt_buf_full	; Check for input buffer empty
	jz	chk_ibfe		; Exit if IBF off, no command pending
endif ; JAPAN
        in      al,PORT_B               ; Read current refresh output bit
        and     al,refresh_bit          ; Mask all but refresh bit
        cmp     al,ah                   ; Did it change? (or first pass thru)
        jz      short chk_ibfl          ; No, wait for change, else continue

        mov     ah,al                   ; Save new refresh bit state
ifndef JAPAN
        in      al,status_port          ; Read status port
        test    al,inpt_buf_full        ; Check for input buffer empty
        loopnz  chk_ibfl                ; Loop until input buf empty or timeout;
else ; JAPAN
	loop	chk_ibfl		; Loop until timeout		       
chk_ibfe:				;  or exit when Input Buffer Full off
endif ; JAPAN
        pop     cx
        pop     ax                      ; Restore register used
        ret                             ; Return to caller

chk_ibf endp

ifdef JAPAN
;***********************************************************************;JP9009
;*								       *;JP9009
;*		      DBCS Common Keyboard Support		       *;JP9009
;*								       *;JP9009
;*	The DBCS common keyboard unique scan code is mapped to the     *;JP9009
;*	temporary scan code. It is again mapped to the corresponding   *;JP9009
;*	scan code/character code according the current shift staes.    *;JP9009
;*								       *;JP9009
;***********************************************************************;JP9009
									;JP9009
DBCS_keyboard_support	proc	near					;JP9009
	cmp	al, 80h 			; Ignore break keys	;JP9009
	jae	leave_it_to_common_method				;JP9009
;AN013	  test	  cs:SD.KEYB_TYPE, DBCS_KB	  ; DBCS keyboard?	  ;JP9009
;AN013	    jz	    leave_it_to_common_method				  ;JP9009
	cmp	cs:SD.INVOKED_CP_TABLE, 932	; DBCS code page?	;JP9009
	jb	leave_it_to_common_method				;JP9009
		call	DBCS_keyboard_common_support			;JP9009
		test	cs:SD.KEYB_TYPE, DBCS_OLD_KB			;JP9009
		jz	leave_it_to_common_method_1			;JP9009
			call	DBCS_old_keyboard_support		;JP9009
	leave_it_to_common_method_1:					;JP9009
		mov	ah, al		; ah = al = 'make' scan code    ;JP9009
		mov	cs:scan_code, al; Set this because we don't know;JP9009
					; who will use it later.	;JP9009
    leave_it_to_common_method:						;JP9009
	ret								;JP9009
DBCS_keyboard_support	endp						;JP9009
									;JP9009
PSEUDO_SC_ALPHANUMERIC	equ	7eh					;JP9009
PSEUDO_SC_HIRAGANA	equ	7fh					;JP9009
									;JP9009
DBCS_keyboard_common_support	proc	near				;JP9009
	; Check if it is the Alphanumeric key or Kanji NO key		;JP9009
	; of the DBCS new keyboard.					;JP9009
	cmp	al, 3ah 			; CAPS key ?		;JP9009
	jne	leave_it_to_common_method_2	; if not		;JP9009

	mov	cx,cs:SD.KEYB_TYPE                                      ;QFESP4
	and     cx,07h
	cmp	cx,2				; 106 kbd?
	jz	check_key_status
	cmp	cx,3				; IBM-5576 002/003 kbd?
	jz	check_key_status
	cmp	cx,0				; 101 kbd?
	jnz	leave_it_to_common_method_2

	test	bl,(ALT_SHIFT or CTL_SHIFT or LEFT_SHIFT or RIGHT_SHIFT)
	jz	leave_it_to_common_method_2
        push    bx
        and     bl,(ALT_SHIFT or CTL_SHIFT)
	cmp	bl,(ALT_SHIFT or CTL_SHIFT)	;press alt and ctl ?
        pop     bx
	jz	leave_it_to_common_method_2
	jmp	short convert_to_alphanumeric_2

    check_key_status:							;QFESP4
	test	bl, ALT_SHIFT						;JP9009
	jnz	convert_to_alphanumeric 				;JP9009
	test	bl, (LEFT_SHIFT or RIGHT_SHIFT) 			;JP9009
	jnz	leave_it_to_common_method_2				;JP9009
	jmp	short convert_to_alphanumeric_2 			;JP9009
    convert_to_alphanumeric:						;JP9009
	    test    cs:SD.KEYB_TYPE, DBCS_OLD_A_KB			;JP9009
	    jnz     leave_it_to_common_method_2 			;JP9009
    convert_to_alphanumeric_2:						;JP9009
		mov	al, PSEUDO_SC_ALPHANUMERIC			;JP9009
    leave_it_to_common_method_2:					;JP9009
	ret								;JP9009
DBCS_keyboard_common_support	endp					;JP9009
									;JP9009

;***********************************************************************;JP9009
;*								       *;JP9009
;*		      DBCS Old Keyboard Support 		       *;JP9009
;*								       *;JP9009
;*	The old DBCS keyboard unique scan codes is mapped to the       *;JP9009
;*	temporary scan code. It is again mapped to the corresponding   *;JP9009
;*	scan code/character code according the current shift staes.    *;JP9009
;*								       *;JP9009
;***********************************************************************;JP9009
									;JP9009
DBCS_old_keyboard_support	proc	near				;JP9009
	mov	cx,cs:SD.KEYB_TYPE
	and     cx,07h
	cmp	cx,2				; 106 kbd?
	jz	check_old_key_status
	cmp	cx,3				; IBM-5576 002/003 kb?
	jne	not_right_ALT_nor_hiragana
check_old_key_status:

	cmp	al, 38h 						;JP9009
	jne	not_right_ALT_nor_hiragana				;JP9009
	test	ds:KB_FLAG_3, LC_E0					;JP9009
	jz	not_right_ALT_nor_hiragana				;JP9009
		mov	al, PSEUDO_SC_HIRAGANA				;JP9009
		and	ds:KB_FLAG_3, not LC_E0 			;JP9009
    not_right_ALT_nor_hiragana: 					;JP9009
	ret								;JP9009
DBCS_old_keyboard_support	endp					;JP9009
endif ; JAPAN

DOSTI proc    near
      FSTI
      ret
DOSTI endp

DOCLI proc    near
      FCLI
      ret
DOCLI endp

DOIRET:
      FIRET

CODE    ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybshar.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1991
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBSHAR.INC
;; ----------
;;
;; Description:
;; ------------
;;       Include file containing structure definitions Shared Data Area
;;       for the Shared Data Area.
;;       The Shared Data Area contains data which is required by
;;       both the resident and transient KEYB code.  The Shared
;;       Data Area is allocated in the KEYBI2F file and will be
;;       resident following initial installation.
;;
;; Change History:
;; ---------------
;;
;; ;jwg  ; - Feb 1990 For 4.03.
;; ;AN007; -           Add Patriot/Sebring determination code for HOT Replug
;;                      so that INT 9 handler can alter keyboard Scan Code set.
;; ;M030                Merged IBM (Kermit - JP), KEYBOARD.SYS and KEYB.COM
;;                        versions of this file into one.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SHARED_DATA_STR defines the initial fixed length portion of the
;; Shared Data Area.
;; Tables are loaded beginning at TABLE_AREA in the following order:
;;  State Logic
;;  Common Translate Section
;;  Specific Translate Sections for
;;   each code page
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;; SPECIAL_FEATURES equates:
TYPEWRITER_CAPS_LK  EQU    8000H        ;; typewriter style caps lock
                                        ;;
JR_HOT_KEY_1_2  equ     4000h           ;; M030 Merged back for kdfcf.asm
;;========================================
;; Added YST for Cyrillic keyboards
;; 1/21/90
;;========================================
SHIFTS_TO_LOGIC     EQU    2000H       ;; - transfer CTRL, SHIFT, ALT keys
                                       ;;   to LOGIC section
                                       ;;
SWITCHABLE          EQU    1000H       ;; - Driver can use NLS/Def mode
                                       ;;   switching (like Rus/Lat mode)
                                       ;;   Used for Int 2Fh, function 0AD83h answer
;;========================================
;; End of YST
;;========================================
JR_KB           equ     8000h           ;; M030 Merged back for kdfcf.asm
                                        ;; Some useful scan codes:
F1_SCAN     EQU   59                    ;; F1
F2_SCAN     EQU   60                    ;; F2
                                        ;;
                                        ;;      SYSTEM_FLAG / Hardware equates:
                                        ;;   INT 16h and remote support
EXT_16          EQU     8000H           ;; extended INT 16h support is there
EXT_122         EQU     4000H           ;; extended INT 16h for 122 is there
;               EQU     2000H           ;;  unused
PC_NET          EQU     1000H           ;; flag PC Net is installed
                                        ;;   System type/hardware support flags
PC_81           EQU     0800H           ;; flag for Original PC
PC_XT           EQU     0400H           ;; code for PC, PC/XT, PORTABLE
PC_LAP          EQU     0200H           ;; code for Convertiable (p-12)
PC_PAL          EQU     0080H           ;; code for Model 30 (PALACE)
PC_AT           EQU     0040H           ;; code for PC-AT  with 8042
PC_386          EQU     0020H           ;; code for PS/2's with 8042 (WRANGLER)
PS_8042         EQU     0010H           ;; 8042 is a Patriot/Sebring type array;AN007;jwg
                                        ;;  or system set translate OFF (SCS=01)
SECURITY_ACTIVE         EQU     0008h   ; M030  ;; Server password mode is active
;                               ; M030  ;;  This bit becomes off from on when
;                               ; M030  ;;  correct password is entered JP9010
ifdef JAPAN
DBCS_OK 	EQU	0002h		;; DBCS scan codes are OK allowed
endif ; JAPAN
                                        ;;
                                        ;; HOT_KEY_FLAG EQUATES:
US_MODE     EQU   0                     ;;  hot key is active => US
LANG_MODE   EQU   0FFH                  ;;  hot key is inactive
                                        ;;
                                        ;; -----------------------------------
SHARED_DATA_STR     STRUC               ;; SHARED DATA AREA
                                        ;;
OLD_INT_9           DD    0             ;; saved int 9 vector
OLD_INT_2F          DD    0             ;; saved int 2F vector
                    dd    0             ;; reserved
KEYB_TYPE           DW    0             ;; type of keyboard
SYSTEM_FLAG         DW    0             ;; system configuration flags
TABLE_OK            DB    0             ;; flag to INT 9 that table is built
                    db    5 dup (0)     ;; reserved
                                        ;;
                                        ;; Table copy begins here:
ACTIVE_LANGUAGE     DB    'US'          ;; language code
INVOKED_CP_TABLE    DW    437           ;; ptr to table for invoked code page
INVOKED_KBD_ID      DW    0             ;; WGR invoked keyboard id.            ;AN000
ACTIVE_XLAT_PTR     DW    -1            ;; ptr to active Specific Translate Sect
FIRST_XLAT_PTR      DW    -1            ;; ptr to first Specific Translate Sect
RESIDENT_END        DW    0ffffh        ;; offset of last byte in resident mem
LOGIC_PTR           DW    -1            ;; ptr to State Logic
COMMON_XLAT_PTR     DW    -1            ;; ptr to Common Translate Section
SPECIAL_FEATURES    DW    ?             ;; special Features
TABLE_OVERFLOW      DB    0             ;; overflow flag for table rebuild
HOT_KEY_ON_SCAN     DB    ?             ;; scan codes to use with ALT+CTRL
HOT_KEY_OFF_SCAN    DB    ?             ;;  to turn hot key on and off
                    DB    4 DUP(0)      ;; reserved
TABLE_AREA          DB    ?             ;; tables loaded here:
                                        ;;  State Logic
                                        ;;  Common Translate Section
                                        ;;  Specific Translate Sections for
                                        ;;   each code page
SHARED_DATA_STR     ENDS                ;;
                                        ;;
                                        ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Logic equates.
;; Contains equates for our NLS Flags and for the State Logic
;; commands.
;; State Logic command macros are defined in KEYBMAC.INC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
STATE_LOGIC_STR STRUC                   ;;
                                        ;;
SL_LOGIC_LEN    DW   ?                  ;; length of state logic
SL_SPECIAL_FEATURES   DW   ?            ;;
SL_LOGIC_CMDS   DB   0                  ;; state logic commands begin here
                                        ;;
STATE_LOGIC_STR ENDS                    ;;
                                        ;;
                                        ;;
NUM_BIOS_FLAGS      EQU   4             ;;
NUM_NLS_FLAGS       EQU   2             ;; '+1' below is the EXT_KB_FLAG
NUM_FLAGS           EQU   NUM_BIOS_FLAGS+NUM_NLS_FLAGS+1
                                        ;;
                                        ;;
EITHER_SHIFT        EQU   80H           ;; EXT_KB_FLAG : our own shift state
EITHER_CTL          EQU   40H           ;;  flags
EITHER_ALT          EQU   20H           ;;
SCAN_MATCH          EQU   08H           ;; set if scan code found in XLATT
                                        ;; or SET_FLAG searches
                                        ;;
SHIFTS_PRESSED      EQU   04H          ;; set if any SHIFT, ALT, CTRL key
                                       ;; pressed (added YST for Cyrillic keyb.)
                                        ;;
KB_FLAG_ID          EQU   0             ;; Flag ID's as coded in IFF and ANDF
KB_FLAG_1_ID        EQU   1             ;;  commands
KB_FLAG_2_ID        EQU   2             ;;
KB_FLAG_3_ID        EQU   3             ;;
EXT_KB_FLAG_ID      EQU   4             ;;
NLS_FLAG_1_ID       EQU   5             ;;
NLS_FLAG_2_ID       EQU   6             ;;
                                        ;;
COMMAND_BITS        EQU   0F0H          ;; Mask to isolate command code
SUB_CMD_BITS        EQU   0FH           ;; mask to isolate sub command code
NOT_TEST            EQU   08H           ;; NOT bit in IFF, ANDF
COMMAND_SHIFT       EQU   4             ;; shift amount for command code
FLAG_ID_BITS        EQU   07H           ;; mask to isolate flag id in IFF, ANDF
NUM_COMMANDS        EQU   0CH           ;; number of commands
                                        ;;
IFF_COMMAND         EQU   00H           ;;
ANDF_COMMAND        EQU   10H           ;;
ELSEF_COMMAND       EQU   20H           ;;
ENDIFF_COMMAND      EQU   30H           ;;
XLATT_COMMAND       EQU   40H           ;;
OPTION_COMMAND      EQU   50H           ;;
SET_FLAG_COMMAND    EQU   60H           ;;
PUT_ERROR_COMMAND   EQU   70H           ;;
IFKBD_COMMAND       EQU   80H           ;;
GOTO_COMMAND        EQU   90H           ;;
BEEP_COMMAND        EQU   0A0H          ;;
RESET_NLS_COMMAND   EQU   0B0H          ;;
CHECK_CORE_COMMAND  EQU   0C0H          ;;
                                        ;;
                                        ;;
EXIT_INT_9_FLAG         EQU  01H        ;; Special forms of GOTO.  These
EXIT_STATE_LOGIC_FLAG   EQU  02H        ;;  values are in the right nibble
                                        ;;   of the GOTO command.
                                        ;;
                                        ;; PROCESSING OPTIONS:
EXIT_IF_FOUND       EQU   80H           ;; exit INT 9 if a translation
                                        ;;  match is found
                                        ;;
ANY_KB               EQU   0FFFFH       ;;
XT_KB                EQU   4000H        ;;
AT_KB                EQU   2000H        ;;
G_KB                 EQU   1000H        ;;
P_KB                 EQU   0800H        ;;
P12_KB               EQU   0400H        ;;
DBCS_OLD_A_KB        EQU   0080H ; M030         ;; JP9009
DBCS_OLD_P_KB        EQU   0040H ; M030         ;; JP9009
DBCS_OLD_G_KB        EQU   0020H ; M030         ;; JP9009
DBCS_OLD_KB          EQU   00C0H ; M030         ;; JP9009
DBCS_KB                      EQU   0020H ; M030         ;; JP9009
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table Sections.  Both the Specific and Common
;; Translate Sections are formatted as follows.
;;
;; The Specific Translate Sections are chained together using the
;; XS_NEXT_SECT_PTR field (-1 if last section).
;; Translate Sections contains multiple States.
;; A State contains the translate tables for a single
;; shift state (IE lower case, upper case ....)
;; Each State may contain multiple translate tables.
;;
;; The Translate Section layout is defined using several STRUCs.
;; These STRUCs are allocated in the Shared Data Area as follows:
;;
;;       XLAT_SECT_STR            ; header info for the section
;;          STATE_STR             ; header for state #1
;;            XLAT_STR            ;   first translate tab for state #1
;;            XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;            XLAT_STR            ;   second translate tab
;;            XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;            ...
;;          STATE_STR             ; header for state #2
;;            XLAT_STR
;;            XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;            ...
;;         ...
;;
;; A State may contain a "Set_Flag" table instead of translate tables.
;; These tables are used to set the NLS flags instead of generating
;; ASCII codes (for example: to remember dead key states).
;; There can be only on Set_Flag table per state.
;; The Set_Flag table layout is defined in the SET_FLAG_STR STRUC.
;;
;; So some states will contain translate tables (to generate ASCII codes)
;; and some states will contain a Set_Flag table (to record dead key
;; status).
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
XLAT_SECT_STR       STRUC               ;;
                                        ;;
XS_NEXT_SECT_PTR       DW    ?          ;; Pointer to next Specific Translate
                                        ;;  Section
XS_CP_ID               DW    ?          ;; code page id
XS_FIRST_STATE         DB    ?          ;;
                                        ;;
XLAT_SECT_STR       ENDS                ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State structure.
;; The last State is a null State containing only the
;; XS_STATE_LEN field with a value of 0.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
STATE_STR           STRUC               ;;
                                        ;;
XS_STATE_LEN     DW    ?                ;; length of state section
XS_STATE_ID      DB    ?                ;; State ID
XS_KBD_TYPE      DW    ?                ;; Keyboard Type
XS_ERROR_CHAR    DW    ?                ;; Buffer entry for error character
XS_FIRST_TAB     DB    ?                ;;
                                        ;;
STATE_STR           ENDS                ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table structures.
;; There may be many translate tables in a State.  The last
;; table is a null table containing only the XLAT_TAB_SIZE field with
;; a value of 0.
;; The xlate table can be in one of two forms:
;;    Type 1 = Table contains buffer entries only.
;;             Scan code is used as an index into xlat table
;;    Type 2 = Table contains pairs of SCAN/BUFFER_ENTRY.
;;             Table must be searched for matching scan.
;; Type 1 is the default.  Type 2 tables should be identified by setting
;; the TYPE_2_TAB bit in XLAT_OPTIONS.
;; Buffer entries default to 2-bytes per entry.
;; Optionally the table may contain ASCII codes only
;; (1-byte entries).  This is specified by setting the ASCII_ONLY bit
;; in XLAT_OPTIONS.  2-byte buffer entries are coded ASCII,SCAN.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
                                        ;; Translate options:
ASCII_ONLY          EQU   80H           ;; Only ASCII codes listed - use
                                        ;;  incoming scan for buffer entry
TYPE_2_TAB          EQU   40H           ;; search xlat table for matching scan
ZERO_SCAN           EQU   20H           ;; set the scan half of the buffer
                                        ;;  entry to 0
                                        ;;
NULL_ASCII_CODE     EQU   -1            ;;
                                        ;;
DEFAULT_TAB_2_ENT_SZ   EQU   3          ;;
ASC_ONLY_TAB_2_ENT_SZ  EQU   2          ;;
                                        ;;
                                        ;;
XLAT_STR            STRUC               ;;
                                        ;;
XLAT_TAB_SIZE       DW    ?             ;; Size in bytes of this table -
                                        ;;  includes this field, options etc.
XLAT_OPTIONS        DB    ?             ;; xlat options
                                        ;; XLAT TABLE IS HERE
XLAT_STR            ENDS                ;;
                                        ;;
XLAT_TYPE_1_STR     STRUC               ;; use scan code as index into table
                    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_SCAN_LO        DB    ?             ;; Scan code
XLAT_SCAN_HI        DB    ?             ;;  range
XLAT_1_BUF_ENTRY    DB    ?             ;; The table itself
XLAT_TYPE_1_STR     ENDS                ;;
                                        ;;
XLAT_TYPE_2_STR     STRUC               ;; search table for scan
                    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_NUM            DB    ?             ;; number of scans
XLAT_SCAN           DB    ?             ;; Scan code
XLAT_2_BUF_ENTRY    DB    ?             ;; The table itself
XLAT_TYPE_2_STR     ENDS                ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set_Flag Tables.
;; State Sections immediately following the LAST_ENTRYs.
;; Dead key definitions.  If the scan matches then
;; set the bit in NLS_FLAGs indicated in DK_MASK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
SF_ENT_SZ     EQU   3                   ;; size of entry
                                        ;;
SET_FLAG_STR        STRUC               ;;
                                        ;;
SF_NUM              DB    0             ;; Number of entries
SF_SCAN_CODE        DB    0             ;; scan code
SF_FLAG_ID          DB    0             ;; flag id
SF_FLAG_MASK        DB    0             ;; flag mask
                                        ;;
SET_FLAG_STR        ENDS                ;;
                                        ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybi9.asm ===
PAGE    ,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; (C) Copyright Microsoft Corp. 1987-1990
; MS-DOS 5.00 - NLS Support - KEYB Command
;
; File Name:  KEYBI9.ASM
; ----------
;
; Description:
; ------------
;       Converts scan codes to ASCII for non-US keyboards.
;       This orutine uses the tables loaded into the SHARED_DATA_AREA
;       from KEYBOARD.SYS by the KEYB_COMMAND module.
;
;
; Procedures Contained in This File:
; ----------------------------------
;       KEYB_STATE_PROCESSOR - Scan to ASCII translator.
;
; External Procedure References:
; ------------------------------
;       None.
;
; Linkage Information:  Refer to file KEYB.ASM
; --------------------
;
; Change History:
; ---------------
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        INCLUDE KEYBEQU.INC
        INCLUDE DSEG.INC               ; System data segments
        INCLUDE POSTEQU.INC            ; System equates
        INCLUDE KEYBSHAR.INC
        INCLUDE KEYBI2F.INC
        INCLUDE KEYBI9C.INC
        INCLUDE KEYBCPSD.INC
        INCLUDE KEYBCMD.INC

        PUBLIC KEYB_STATE_PROCESSOR


        PUBLIC FLAGS_TO_TEST           ;; (YST)
        PUBLIC NLS_FLAG_1              ;; (YST)


CODE    SEGMENT PUBLIC 'CODE'

        ASSUME  CS:CODE,DS:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Procedure: KEYB_STATE_PROCESSOR
;
; Description:
;     Convert scan to ASCII using the tables loaded into the
;     SHARED_DATA_AREA.  Conversion is directed by the STATE LOGIC
;     commands contained in the SHARED_DATA_AREA.  This routine
;     interprets those commands.
;
; Input Registers:
;     N/A
;
; Output Registers:
;     N/A
;
; Logic:
;     Enable interrupts
;     Save registers
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

BREAK_CODE    EQU  80H

HOT_KEY_ACTIVE  DB   0                 ; 1 if hot key is active


                                       ; These are copies of the BIOS FLAGS
FLAGS_TO_TEST    LABEL BYTE            ;  KB_FLAG, KB_FLAG_1,2,3
KB_SHADOW_FLAGS  DB   NUM_BIOS_FLAGS DUP(0)
EXT_KB_FLAG      DB   0                ; Extended KB Flag for shift states
NLS_FLAG_1       DB   0                ; NLS Flags for dead key etc
NLS_FLAG_2       DB   0                ;  .

SAVED_NLS_FLAGS  DB   0,0              ; Saved copy of the NLS flags

OPTION_BYTE     DB    0                ; Set by OPTION command

KB_FLAG_PTRS    DW   OFFSET KB_FLAG    ; These are pointers to the BIOS flags
                DW   OFFSET KB_FLAG_1  ;  we must test
                DW   OFFSET KB_FLAG_2
                DW   OFFSET KB_FLAG_3

XLAT_TAB_PTR    DW   0                 ; pointer to xlat tables for cur state

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


NEST_LEVEL      DB   0
PROCESS_LEVEL   DB   0
TAKE_ELSE       DB   0
BUSY_FLAG       DB   0                 ; Flag to prevent re-entry

CMD_JUMP_TABLE  LABEL  WORD
        DW   OFFSET  IFF_PROC          ; CODE  0
        DW   OFFSET  ANDF_PROC         ;       1
        DW   OFFSET  ELSEF_PROC        ;       2
        DW   OFFSET  ENDIFF_PROC       ;       3
        DW   OFFSET  XLATT_PROC        ;       4
        DW   OFFSET  OPTION_PROC       ;       5
        DW   OFFSET  SET_FLAG_PROC     ;       6
        DW   OFFSET  PUT_ERROR_PROC    ;       7
        DW   OFFSET  IFKBD_PROC        ;       8
        DW   OFFSET  GOTO_PROC         ;       9
        DW   OFFSET  BEEP_PROC         ;       A
        DW   OFFSET  RESET_NLS_PROC    ;       B
        DW   OFFSET  RESET_NLS1_PROC   ;       C
        DW   OFFSET  UNKNOWN_COMMAND   ;       D
        DW   OFFSET  UNKNOWN_COMMAND   ;       E
        DW   OFFSET  UNKNOWN_COMMAND   ;       F


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

KEYB_STATE_PROCESSOR   PROC   NEAR

        TEST   byte ptr CS:SD.TABLE_OK,1
        JNZ    WE_HAVE_A_TABLE
        CLC                            ; BACK TO US INT 9
        RET
WE_HAVE_A_TABLE:

        PUSH   DS                      ; save DS
        PUSH   ES                      ; save ES
        PUSH   AX                      ; save scan code for caller
        PUSH   BX                      ; save shift states for caller

        PUSH   CS
        POP    DS                      ; DS = our seg
        MOV    BX,DATA
        MOV    ES,BX                   ; addressability to BIOS data


        CMP     COUNTRY_FLAG,0FFH      ; Q..country mode?
        JE      INIT_STATE_PROCESSING  ; Y..continue
        JMP     GOTO_BIOS              ; N..exit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; -------STATE SECTION PROCESSING-------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

INIT_STATE_PROCESSING:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set NLS shift flags EITHER_SHIFT, EITHER_ALT, EITHER_CTRL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                                       ; Q..in shift state?
        TEST   ES:KB_FLAG,RIGHT_SHIFT+LEFT_SHIFT
        JNZ    IN_SHIFT_STATE          ; Y..go set bit
        AND    EXT_KB_FLAG,NOT EITHER_SHIFT ; N..clear bit
        JMP    SHORT TEST_CTL
IN_SHIFT_STATE:
        OR     EXT_KB_FLAG,EITHER_SHIFT
TEST_CTL:
        TEST   ES:KB_FLAG,CTL_SHIFT    ; Q..in control state?
        JNZ    IN_CTL_STATE            ; Y..go set bit
        TEST   ES:KB_FLAG_3,R_CTL_SHIFT ; Q..how bout the right ctl?
        JNZ    IN_CTL_STATE            ; Y..go set the bit
        AND    EXT_KB_FLAG,NOT EITHER_CTL ; N..clear the bit
        JMP    SHORT TEST_ALT
IN_CTL_STATE:
        OR     EXT_KB_FLAG,EITHER_CTL
TEST_ALT:
        TEST   ES:KB_FLAG,ALT_SHIFT    ; Q..in alt state?
        JNZ    IN_ALT_STATE            ; Y..go set bit
        TEST   ES:KB_FLAG_3,R_ALT_SHIFT ; Q..how bout the right alt?
        JNZ    IN_ALT_STATE            ; Y..go set the bit
        AND    EXT_KB_FLAG,NOT EITHER_ALT ; N..clear the bit
        JMP    SHORT COPY_FLAGS
IN_ALT_STATE:
        OR     EXT_KB_FLAG,EITHER_ALT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copy BIOS KB flags from BIOS data seg into the
; FLAGS_TO_TEST structure.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COPY_FLAGS:
        MOV    CX,NUM_BIOS_FLAGS
        xor    si,si                    ; pointers to the BIOS flags
        xor    di,di                    ; create shadow copies
MOVE_NEXT_FLAG:
        MOV    BX,KB_FLAG_PTRS[SI]     ; pointer to next flag
        MOV    AL,ES:[BX]              ; flag in AL
        MOV    KB_SHADOW_FLAGS[DI],AL  ; save it in the shadow table
        INC    DI
        INC    SI
        INC    SI
        LOOP   MOVE_NEXT_FLAG

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Interpret State Logic Commands
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_STATES:
        MOV    OPTION_BYTE,0           ; clear options
        MOV    SI,SD.LOGIC_PTR
        LEA    SI,[SI].SL_LOGIC_CMDS
NEXT_COMMAND:
        XOR    BH,BH                   ; ????
        MOV    BL,[SI]                 ; command byte in BL
        SHR    BL,1
        SHR    BL,1
        SHR    BL,1
        SHR    BL,1                    ; ISOLATE COMMAND CODE
        SHL    BL,1                    ; command code * 2
        JMP    CMD_JUMP_TABLE[BX]      ; go process command
UNKNOWN_COMMAND:
        JMP    FATAL_ERROR             ; bad news


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKBD_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    IFKBD_DONE              ; N..don't process

        MOV    AX,[SI+1]               ; Keyboard Type Flag

        TEST   SD.KEYB_TYPE,AX         ; Q..are we the right system?
        JNZ    IFKBD_TEST_OK           ; Y..
IFKBD_TEST_FAILED:
        MOV    TAKE_ELSE,YES           ; test failed - take ELSE
        JMP    SHORT IFKBD_DONE
IFKBD_TEST_OK:
        INC    PROCESS_LEVEL           ; process commands within IF
        MOV    TAKE_ELSE,NO
IFKBD_DONE:
        INC    NEST_LEVEL              ; IFKBD increments nest level
        INC    SI                      ; bump past IFKBD
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PUT_ERROR_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    PUT_ERROR_DONE          ; N..don't process
        MOV    DI,SD.ACTIVE_XLAT_PTR   ; pointer to active Xlat Section
        MOV    AL,[SI+1]               ; state id in AL
        CALL   PUT_ERROR               ; check active section
        JC     PUT_ERROR_DONE          ; carry set if translation found
        MOV    DI,SD.COMMON_XLAT_PTR   ; check common Xlat Section
        MOV    AL,[SI+1]               ; state id for XLATT in AL
        CALL   PUT_ERROR

PUT_ERROR_DONE:
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND

PUT_ERROR      PROC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search for a state whose ID matches the ID
; on the PUT_ERROR command
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        CLC
        LEA    DI,[DI].XS_FIRST_STATE  ; point to first state in section
PE_NEXT_STATE:
        CMP    [DI].XS_STATE_LEN,0     ; Q..out of states?
        JE     PE_EXIT                 ; Y..exit
        CMP    AL,[DI].XS_STATE_ID     ; Q..is this the requested state?
        JE     PE_STATE_MATCH
        ADD    DI,[DI].XS_STATE_LEN    ; N..check next state
        JMP    SHORT PE_NEXT_STATE

PE_STATE_MATCH:
        MOV    AX,[DI].XS_ERROR_CHAR   ; get error char in AX
        CALL   BUFFER_FILL
        STC                            ; indicate that we found the state
PE_EXIT:
        RET

PUT_ERROR   ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GOTO_BIOS:
        CLC                            ; clear carry flag indicating
        POP   BX                       ;  we should continue INT 9
        POP   AX                       ;   processing
        POP   ES
        POP   DS
        RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IFF_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    IFF_DONE                ; N..don't process IFF
        MOV    BL,[SI]                 ; command byte
        AND    BL,FLAG_ID_BITS         ; isolate flag id
        XOR    BH,BH
        MOV    AL,FLAGS_TO_TEST[BX]    ; flag in AL
        TEST   BYTE PTR[SI],NOT_TEST   ; Q..is this a NOT test?
        JNZ    ITS_A_NOT
        TEST   AL,[SI]+1               ; Y..check for bit set
        JNZ    IFF_MATCH
        JZ     IFF_NO_MATCH
ITS_A_NOT:
        TEST   AL,[SI]+1               ; Y..check for bit clear
        JZ     IFF_MATCH
IFF_NO_MATCH:
        MOV    TAKE_ELSE,YES           ; flag test failed - take ELSE
        JMP    SHORT IFF_DONE
IFF_MATCH:
        INC    PROCESS_LEVEL           ; process commands within IF
        MOV    TAKE_ELSE,NO

IFF_DONE:
        INC    NEST_LEVEL              ; IFF increments nest level
        INC    SI                      ; bump past IFF
        INC    SI
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELSEF_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    CHECK_TAKE_ELSEF        ; N..check for take_else
        DEC    PROCESS_LEVEL           ; Y..we just finished the "IF" block
        JMP    short ELSEF_DONE        ;    so we are finished with IFF/ELSEF
CHECK_TAKE_ELSEF:
        CMP    TAKE_ELSE,YES           ; Q..are we scanning for ELSE?
        JNE    ELSEF_DONE              ; N..done
        DEC    NEST_LEVEL              ; ELSEF itself is back a level
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    NOT_THIS_ELSEF          ; N..this else is not the one
        INC    PROCESS_LEVEL           ; Y..process ELSEF block
        MOV    TAKE_ELSE,NO            ; reset
NOT_THIS_ELSEF:
        INC    NEST_LEVEL              ; stuff within the ELSEF is up a level

ELSEF_DONE:
        INC    SI                      ; bump past ELSEF
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENDIFF_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    ENDIFF_DONE             ; N..don't adjust process level
        DEC    PROCESS_LEVEL           ; Y..we just finished the IF/ELSE
ENDIFF_DONE:
        DEC    NEST_LEVEL              ; ENDIF decrements nest level
        INC    SI                      ; bump past ENDIF
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Translations may be in the Common or Specific
; Sections.  Search the Specific section first
; then the common section.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
XLATT_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    XLATT_DONE              ; N..next command
        MOV    DI,SD.ACTIVE_XLAT_PTR   ; pointer to active Xlat Section
        MOV    AL,[SI+1]               ; state id for XLATT in AL
        CALL   TRANSLATE               ; check active section
        JC     XLATT_FOUND             ; carry set if translation found
        MOV    DI,SD.COMMON_XLAT_PTR   ; check common Xlat Section
        MOV    AL,[SI+1]               ; state id for XLATT in AL
        CALL   TRANSLATE
        JNC    XLATT_DONE
XLATT_FOUND:
        OR     EXT_KB_FLAG,SCAN_MATCH  ; set flag indicating scan matched
        TEST   OPTION_BYTE,EXIT_IF_FOUND ; Q..exit
        JZ     XLATT_DONE
        JMP    EXIT                    ; Y..BYE

XLATT_DONE:
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND

TRANSLATE PROC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search for a state whose ID matches the ID
; on the XLATT command
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        CLC
        LEA    DI,[DI].XS_FIRST_STATE  ; point to first state in section
TP_NEXT_STATE:
        CMP    [DI].XS_STATE_LEN,0     ; Q..out of states?
        JE     TP_EXIT                 ; Y..exit
        CMP    AL,[DI].XS_STATE_ID     ; Q..is this the requested state?
        JE     TP_STATE_MATCH
        ADD    DI,[DI].XS_STATE_LEN    ; N..check next state
        JMP    SHORT TP_NEXT_STATE

TP_STATE_MATCH:
        AND    EXT_KB_FLAG,NOT SCAN_MATCH  ; reset flag before search
        PUSH   SI                      ; save pointer to next command
        LEA    SI,[DI].XS_FIRST_TAB    ; point to first xlat table
        MOV    XLAT_TAB_PTR,SI         ; start of XLAT tables
        MOV    AL,SCAN_CODE            ; restore incoming scan code
        JMP    SHORT NEXT_XLAT_TAB
TP_DONE:                               ; return here from XLAT
        POP    SI
TP_EXIT:
        RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Check xlate tables for matching scan code
; The xlate table can be in one of two forms:
;    Type 1 = Table contains buffer entries only.
;             Scan code is used as an index into xlat table
;    Type 2 = Table contains pairs of SCAN/BUFFER_ENTRY.
;             Table must be searched for matching scan.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NEXT_XLAT_TAB:
        MOV    SI,XLAT_TAB_PTR         ; pointer to xlat tables
        CMP    [SI].XLAT_TAB_SIZE,0    ; Q..any more xlat tables?
        JNE    PROCESS_XLAT_TAB        ; Y..check um
        JMP    TP_DONE                 ; N..done
PROCESS_XLAT_TAB:
        MOV    DL,[SI].XLAT_OPTIONS    ; save translate options IN DL
        MOV    BX,[SI].XLAT_TAB_SIZE   ; Y..calc pointer to next xlat tab
        ADD    BX,SI
        MOV    XLAT_TAB_PTR,BX         ; pointer to next xlat tab
        TEST   DL,TYPE_2_TAB           ; Q..is this a type 2 table?
        JZ     TYPE_1_LOOKUP           ; N..go do table lookup
TYPE_2_SEARCH:                         ; Y..search table
        XOR    CH,CH
        MOV    CL,[SI].XLAT_NUM        ; number of xlat entries
        MOV    BX,DEFAULT_TAB_2_ENT_SZ ; default entry size
        TEST   DL,ASCII_ONLY+ZERO_SCAN ; Q..are buffer entries ASCII only?
        JZ     NEXT_TAB_2_ENTRY        ; N..continue
        MOV    BX,ASC_ONLY_TAB_2_ENT_SZ ; Y..set size in BX
NEXT_TAB_2_ENTRY:                      ; entry size is in BX
        jcxz    next_xlat_tab           ;   brif last entry
        CMP    AL,[SI].XLAT_SCAN       ; Q..scan match?
        JE     FOUND_TAB_2_ENTRY       ; Y..go create buffer entry
        ADD    SI,BX                   ; point to next entry
        LOOP   NEXT_TAB_2_ENTRY
        JMP    SHORT NEXT_XLAT_TAB
FOUND_TAB_2_ENTRY:                     ; Q..set scan code to 0?
        MOV    AH,AL                   ; default scan code in AH
        MOV    AL,[SI].XLAT_2_BUF_ENTRY ; ASCII code from table in AL
        TEST   DL,ASCII_ONLY+ZERO_SCAN ; Q..are buffer entries ASCII only?
        JNZ    BUFFER_ENTRY_READY      ; Y..buffer entry is ready
        MOV    AH,[SI].XLAT_2_BUF_ENTRY+1 ; N..scan code from table as well
        JMP    SHORT BUFFER_ENTRY_READY ; go put entry in buffer

TYPE_1_LOOKUP:
        CMP    AL,[SI].XLAT_SCAN_LO    ; Q..is scan in range of this table?
        JB     NEXT_XLAT_TAB           ; N..next table
        CMP    AL,[SI].XLAT_SCAN_HI    ; Q..is scan in range of this table?
        JA     NEXT_XLAT_TAB           ; N..next table
        SUB    AL,[SI].XLAT_SCAN_LO    ; convert scan code to xlat index
        TEST   DL,ASCII_ONLY+ZERO_SCAN ; Q..ASCII only in xlat ?
        JZ     TWO_BYTE_LOOKUP         ; N..go do 2-byte lookup
        LEA    BX,[SI].XLAT_1_BUF_ENTRY ; Y..do 1-byte lookup
        XLAT   [SI].XLAT_1_BUF_ENTRY   ; ASCII code in AL
        MOV    AH,SCAN_CODE            ; SCAN in AH
        JMP    SHORT BUFFER_ENTRY_READY ; go put entry in buffer
TWO_BYTE_LOOKUP:
        MOV    BL,2                    ; multiply scan index
        MUL    BL                      ;  by two
        MOV    BX,AX                   ; real index in BX
        MOV    AX,WORD PTR [SI].XLAT_1_BUF_ENTRY[BX] ; get 2-byte buffer entry
                                       ;  AL=ASCII  AH=SCAN
BUFFER_ENTRY_READY:
        TEST   DL,ZERO_SCAN            ; Q..set scan part to zero?
        JZ     NO_ZERO_SCAN            ; N..
        XOR    AH,AH                   ; scan = 0
NO_ZERO_SCAN:
        CALL   BUFFER_FILL             ; go put entry in buffer
        STC                            ; indicate translation found
        JMP    TP_DONE

TRANSLATE ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPTION_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    DONE_OPTION             ; N..done
        MOV    AL,[SI]+1               ; mask in AL
        TEST   BYTE PTR[SI],NOT_TEST   ; Q..is this a NOT?
        JNZ    AND_MASK
        OR     OPTION_BYTE,AL          ; N..OR in the mask bits
        JMP    short DONE_OPTION
AND_MASK:
        NOT    AL
        AND    OPTION_BYTE,AL          ; Y..AND out the mask bits
DONE_OPTION:
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESET_NLS_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    RN_DONE                 ; N..don't process
        MOV    NLS_FLAG_1,0
        MOV    NLS_FLAG_2,0


        MOV    COPY_NLS1_FLAG,0        ;; (YST)


RN_DONE:
        INC    SI
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This PROC only for Yugoslavian (Cyrillic)
;; keyboard from CRAZY IBM (YST)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

RESET_NLS1_PROC:                       ;;
        MOV    AL,NEST_LEVEL           ;;
        CMP    AL,PROCESS_LEVEL        ;; Q..nest level = process level?
        JNE    RN1_DONE                 ;; N..don't process
        MOV    NLS_FLAG_1, 1            ;;
        MOV    NLS_FLAG_2,0            ;;
        MOV    COPY_NLS1_FLAG, 1        ;; (YST)
RN1_DONE:                               ;;
        INC    SI                      ;;
        JMP    NEXT_COMMAND            ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BEEP_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    BP_DONE                 ; N..don't process
        MOV    BEEP_PENDING,YES        ; set beep pending flag. the beep
                                       ;  will be done just before iret
BP_DONE:
        INC    SI
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GOTO_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    GOTO_DONE               ; N..don't process
        MOV    BL,[SI]                 ; command byte in BL
        AND    BL,NOT COMMAND_BITS     ; remove command code
        OR     BL,BL                   ; Q..goto label?
        JZ     GOTO_LABEL              ; Y..go jump
        CMP    BL,EXIT_INT_9_FLAG      ; Q..SPECIAL - Exit Int 9?
        JNE    NOT_EXIT_INT_9          ; N..
        JMP    EXIT                    ; Y..bye bye
NOT_EXIT_INT_9:
        CMP    BL,EXIT_STATE_LOGIC_FLAG ; Q..SPECIAL - Exit State Logic?
        JNE    NOT_EXIT_S_L            ; N..
        JMP    GOTO_BIOS               ; Y..goto bios
NOT_EXIT_S_L:
        JMP    FATAL_ERROR             ; garbage in that command
GOTO_LABEL:
        ADD    SI,[SI]+1               ; bump by relative offset
        MOV    PROCESS_LEVEL,0         ; reset process and nest level
        MOV    NEST_LEVEL,0
GOTO_DONE:
        ADD    SI,3                    ; bump to next command
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ANDF_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    ANDF_DONE               ; N..don't process ANDF
        MOV    BL,[SI]                 ; command byte
        AND    BL,FLAG_ID_BITS         ; isolate flag id
        XOR    BH,BH
        MOV    AL,FLAGS_TO_TEST[BX]    ; flag in AL
        TEST   BYTE PTR[SI],NOT_TEST   ; Q..is this a NOT test?
        JNZ    ANDF_NOT
        TEST   AL,[SI]+1               ; Y..check for bit set
        JNZ    ANDF_DONE               ; if set then remain in IFF
        JZ     ANDF_NO_MATCH
ANDF_NOT:
        TEST   AL,[SI]+1               ; Y..check for bit clear
        JZ     ANDF_DONE               ; if clear then remain in IFF
ANDF_NO_MATCH:
        MOV    TAKE_ELSE,YES           ; flag test failed - take ELSE
        DEC    PROCESS_LEVEL           ; IFF would have inc'd - so dec
ANDF_DONE:
        INC    SI                      ; bump past ANDF
        INC    SI
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SET_FLAG Command.
; Flag Table must be in the Common Section
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SET_FLAG_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    SF_DONE                 ; N..don't process

        MOV    DI,SD.COMMON_XLAT_PTR   ; check common Xlat Section
        MOV    AL,[SI+1]               ; state id in AL
        LEA    DI,[DI].XS_FIRST_STATE  ; point to first state in section
SF_NEXT_STATE:
        CMP    [DI].XS_STATE_LEN,0     ; Q..out of states?
        JE     SF_DONE                 ; Y..exit
        CMP    AL,[DI].XS_STATE_ID     ; Q..is this the requested state?
        JE     SF_STATE_MATCH
        ADD    DI,[DI].XS_STATE_LEN    ; N..check next state
        JMP    SHORT SF_NEXT_STATE

SF_STATE_MATCH:
        AND    EXT_KB_FLAG,NOT SCAN_MATCH  ; reset flag before search
        PUSH   SI                      ; save pointer to next command
        LEA    SI,[DI].XS_FIRST_TAB    ; point to table
        MOV    AL,SCAN_CODE            ; restore incoming scan code
        MOV    CX,[SI]                 ; number of entries
        jcxz    sf_restore              ; done if no entries
        INC    SI                      ; Y..Bump to first entry
        INC    SI
NEXT_SF_ENTRY:
        CMP    AL,[SI]                 ; Q..scan match?
        JE     FOUND_SF_ENTRY          ; Y..go set flag
        ADD    SI,3                    ; point to next entry
        LOOP   NEXT_SF_ENTRY
        JMP    SHORT SF_RESTORE        ; no match found
FOUND_SF_ENTRY:
        MOV    NLS_FLAG_1,0            ; clear all NLS bits
        MOV    NLS_FLAG_2,0
        MOV    BL,[SI]+1               ; flag id in BX
        XOR    BH,BH
        MOV    AL,[SI]+2               ; mask in AL
        OR     FLAGS_TO_TEST[BX],AL    ; set the bit
        OR     EXT_KB_FLAG,SCAN_MATCH  ; set flag indicating scan matched


        MOV    AL,NLS_FLAG_1           ;; copy NLS_FLAG_1 to the (YST)
        MOV    COPY_NLS1_FLAG,AL       ;; public place (YST)


        TEST   OPTION_BYTE,EXIT_IF_FOUND ; Q..exit
        JZ     SF_RESTORE
        POP    SI
        JMP    short EXIT
SF_RESTORE:
        POP    SI
SF_DONE:
        INC    SI                      ; bump past command
        INC    SI
        JMP    NEXT_COMMAND


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Fatal Error routine.  Come here when
; we have a critical error such as an
; invalid State Logic Command.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FATAL_ERROR:
        JMP   SHORT EXIT               ; end the int 9 processing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Exit point.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EXIT:
        MOV   BUSY_FLAG,NO
        STC                            ; indicate we should end INT 9
        POP   BX                       ;  processing
        POP   AX
        POP   ES
        POP   DS
        RET

KEYB_STATE_PROCESSOR   ENDP



CODE   ENDS
       END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybmsg.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBMSG.INC
;; ----------
;;
;; Root File Name:  KEYBCMD.ASM (KEYB.ASM)
;; ---------------
;;
;; Description:
;; ------------
;;	 External declarations for procedures in file KEYBCMD.ASM.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	EXTRN	 ACT_KEYB_CP :BYTE     ;;
	EXTRN	 ACT_CON_CP  :BYTE     ;;
	EXTRN	 ACT_KEYB    :BYTE     ;;
	EXTRN	 INV_L	     :BYTE     ;;
	EXTRN	 INV_I	     :BYTE     ;;
	EXTRN	 INV_CP      :BYTE     ;;
	EXTRN	 INV_S	     :BYTE     ;;
	EXTRN	 INV_FN      :BYTE     ;;
	EXTRN	 INV_KEYB_Q  :BYTE     ;;
	EXTRN	 INV_CON_Q   :BYTE     ;;
	EXTRN	 NOT_DESIG   :BYTE     ;;
	EXTRN	 NOT_SUPP    :BYTE     ;;
	EXTRN	 NOT_VALID1  :BYTE     ;;
	EXTRN	 NOT_VALID2  :BYTE     ;;
	EXTRN	 WARNING_1   :BYTE     ;;
	EXTRN	 INV_COMBO   :BYTE     ;;
	EXTRN	 CR_LF	     :BYTE     ;;
	EXTRN	 MEMORY_OVERF :BYTE    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybmac.inc ===
.XLIST

;     *   IBM CONFIDENTIAL   *   Jan 9 1990   *

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PC DOS 3.3 - NLS Support - Keyboard Definition File
;; (C) Copyright IBM Corp 198?,...
;;
;; File Name:  KEYBMAC.INC
;; ----------
;;
;; Author:     Bill Devlin  - IBM Canada Laboratory - May 1986
;; -------     ???????????
;;
;; Description:
;; ------------
;;       Include file containing macros for the Keyboard Definition File.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Dead key flags
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
ACUTE               EQU   80H          ;; NLS_FLAG_1
GRAVE               EQU   40H          ;;
DIARESIS            EQU   20H          ;;
CIRCUMFLEX          EQU   10H          ;;
CEDILLA             EQU   08H          ;;
TILDE               EQU   04H          ;;
RUS_MODE            EQU   01H          ;; Added YST for Cyrillic keyboard
LAT_MODE            EQU   00H          ;; 1/21/91
                                       ;; NLS_FLAG_2 : nothing defined yet
CARON               EQU   80H
BREVE               EQU   40H
OVERCIRCLE          EQU   20H
OGONEK              EQU   10H
OVERDOT             EQU   08H
DOUBLEACUTE         EQU   04H

                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State IDs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
DEAD_LOWER          EQU    1           ;; dead keys on lower shift
DEAD_UPPER          EQU    2           ;;
ALPHA_LOWER         EQU    3           ;;
ALPHA_UPPER         EQU    4           ;;
NON_ALPHA_LOWER     EQU    5           ;;
NON_ALPHA_UPPER     EQU    6           ;;
THIRD_SHIFT         EQU    7           ;;
ACUTE_LOWER         EQU    8           ;;
ACUTE_UPPER         EQU    9           ;;
ACUTE_SPACE         EQU   10           ;;
GRAVE_LOWER         EQU   11           ;;
GRAVE_UPPER         EQU   12           ;;
GRAVE_SPACE         EQU   13           ;;
DIARESIS_LOWER      EQU   14           ;;
DIARESIS_UPPER      EQU   15           ;;
DIARESIS_SPACE      EQU   16           ;;
CIRCUMFLEX_LOWER    EQU   17           ;;
CIRCUMFLEX_UPPER    EQU   18           ;;
CIRCUMFLEX_SPACE    EQU   19           ;;
CEDILLA_LOWER       EQU   20           ;;
CEDILLA_UPPER       EQU   21           ;;
CEDILLA_SPACE       EQU   22           ;;
CEDILLA_CEDILLA     EQU   23           ;;
DEAD_THIRD          EQU   24           ;;
ACUTE_ACUTE         EQU   25           ;;
GRAVE_GRAVE         EQU   26           ;;
DIARESIS_DIARESIS   EQU   27           ;;
CIRCUMFLEX_CIRCUMFLEX EQU 28           ;;
FOURTH_SHIFT        EQU   29           ;;
DEAD_FOURTH         EQU   30           ;;
TILDE_LOWER         EQU   31           ;;
TILDE_UPPER         EQU   32           ;;
TILDE_SPACE         EQU   33           ;;
TILDE_TILDE         EQU   34           ;;
ALT_CASE            EQU   35           ;;
CTRL_CASE           EQU   36           ;;
NUMERIC_PAD         EQU   37           ;;
DIVIDE_SIGN         EQU   38           ;;
BOTLH_CAPS          EQU   39           ;;
BOTRH_CAPS          EQU   40           ;;
BOTLH_F_CAPS        EQU   41           ;;
BOTRH_F_CAPS        EQU   42           ;;
RUS_MODE_SET        EQU   43           ;;   Added YST for Cyrillic keyboard
                                       ;;
;************************************************
; Mihindu 11/30/90 - Added Eastern Europe support
;************************************************
CARON_SPACE         EQU   43
CARON_LOWER         EQU   44
CARON_UPPER         EQU   45
BREVE_SPACE         EQU   46
BREVE_LOWER         EQU   47
BREVE_UPPER         EQU   48
OVERCIRCLE_SPACE    EQU   49
OVERCIRCLE_LOWER    EQU   50
OVERCIRCLE_UPPER    EQU   51
OGONEK_SPACE        EQU   52
OGONEK_LOWER        EQU   53
OGONEK_UPPER        EQU   54
OVERDOT_SPACE       EQU   55
OVERDOT_LOWER       EQU   56
OVERDOT_UPPER       EQU   57
DOUBLEACUTE_SPACE   EQU   58
DOUBLEACUTE_LOWER   EQU   59
DOUBLEACUTE_UPPER   EQU   60

;******************************************************
;  M000 --- new state for KDFJP.ASM (Kermit)    *******
;******************************************************

DBCS_OLD_A         EQU   61             ; M000 (JP9009)

NON_ALPHA_LOWER_LAT    EQU   62
NON_ALPHA_UPPER_LAT    EQU   63
ALPHA_LOWER_LAT        EQU   64
ALPHA_UPPER_LAT        EQU   65
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Logic Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;

UNKNOWN = 255

FIND_FLAG MACRO  FLAG_MASK
       IFIDN <FLAG_MASK>,<SCAN_MATCH>
          FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<EITHER_SHIFT>
          FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<CAPS_STATE>
          FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<NUM_STATE>
          FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<EITHER_CTL>
          FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<EITHER_ALT>
          FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<LEFT_SHIFT>
          FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<RIGHT_SHIFT>
          FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<ALT_SHIFT>
          FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<CTL_SHIFT>
          FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<R_ALT_SHIFT>
          FLAG_ID = KB_FLAG_3_ID
       ELSE
       IFIDN <FLAG_MASK>,<R_CTL_SHIFT>
          FLAG_ID = KB_FLAG_3_ID
       ELSE
       IFIDN <FLAG_MASK>,<TILDE>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<ACUTE>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<GRAVE>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<DIARESIS>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<CEDILLA>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<CIRCUMFLEX>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<CARON>
          FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<BREVE>
          FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<OVERCIRCLE>
          FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<OGONEK>
          FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<OVERDOT>
          FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<DOUBLEACUTE>
          FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<LC_E0>
          FLAG_ID = KB_FLAG_3_ID
       ELSE
;; ============================================================
;; For Cyrillic keyboards (YST)
;; ============================================================
       IFIDN <FLAG_MASK>,<SHIFTS_PRESSED>
          FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<RUS_MODE>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<LAT_MODE>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
;; ============================================================
;; End of Cyrillic keyboards (YST)
;; ============================================================
          FLAG_ID = UNKNOWN
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FLAG MACRO  FLAG_MASK
       FIND_FLAG FLAG_MASK
       IF (FLAG_ID EQ UNKNOWN)
          IF2
              %OUT Unknown parameter FLAG_MASK on FLAG MACRO
          ENDIF
       ELSE
          DB FLAG_ID
          DB FLAG_MASK
       ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFF MACRO  FLAG_MASK,MASK_TYPE
    MAC_OK = 1
    IFB  <MASK_TYPE>
         NOT_BIT = 00000000B
    ELSE
         IFIDN <MASK_TYPE>,<NOT>
             NOT_BIT = 00001000B
         ELSE
             MAC_OK = 0
             IF2
                 %OUT Unknown parameter MASK_TYPE on IFF MACRO
             ENDIF
         ENDIF
    ENDIF
    IF MAC_OK
       FIND_FLAG FLAG_MASK
       IF (FLAG_ID EQ UNKNOWN)
          IF2
              %OUT Unknown parameter FLAG_MASK on IFF MACRO
          ENDIF
       ELSE
          DB IFF_COMMAND+NOT_BIT+FLAG_ID
          DB FLAG_MASK
       ENDIF
    ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKBD MACRO  SYS
       DB IFKBD_COMMAND
       DW SYS
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ANDF MACRO  FLAG_MASK,MASK_TYPE
    MAC_OK = 1
    IFB  <MASK_TYPE>
         NOT_BIT = 00000000B
    ELSE
         IFIDN <MASK_TYPE>,<NOT>
             NOT_BIT = 00001000B
         ELSE
             MAC_OK = 0
             IF2
                 %OUT Unknown parameter MASK_TYPE on ANDF MACRO
             ENDIF
         ENDIF
    ENDIF
    IF MAC_OK
       FIND_FLAG FLAG_MASK
       IF (FLAG_ID EQ UNKNOWN)
          IF2
              %OUT Unknown parameter FLAG_MASK on ANDF MACRO
          ENDIF
       ELSE
          DB ANDF_COMMAND+NOT_BIT+FLAG_ID
          DB FLAG_MASK
       ENDIF
    ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ELSEF  MACRO
       DB  ELSEF_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENDIFF MACRO
       DB  ENDIFF_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
XLATT  MACRO STATE
       DB  XLATT_COMMAND
       DB  STATE
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PUT_ERROR_CHAR  MACRO STATE
       DB  PUT_ERROR_COMMAND
       DB  STATE
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPTION MACRO MASK,MASK_TYPE
    MAC_OK = 1
    IFB  <MASK_TYPE>
         NOT_BIT = 00000000B
    ELSE
         IFIDN <MASK_TYPE>,<NOT>
             NOT_BIT = 00001000B
         ELSE
             MAC_OK = 0
             IF2
                 %OUT Unknown parameter MASK_TYPE on OPTION MACRO
             ENDIF
         ENDIF
    ENDIF
    IF MAC_OK
       DB  OPTION_COMMAND+NOT_BIT
       DB  MASK
    ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SET_FLAG  MACRO STATE
       DB  SET_FLAG_COMMAND
       DB  STATE
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESET_NLS  MACRO
       DB  RESET_NLS_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESET_NLS1  MACRO
       DB  RESET_NLS1_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BEEP   MACRO
       DB  BEEP_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GOTO    MACRO GOTO_OFFSET
       DB  GOTO_COMMAND
       DW  GOTO_OFFSET-$-2
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
EXIT_INT_9  MACRO
       DB  GOTO_COMMAND+EXIT_INT_9_FLAG
       DW  0
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
EXIT_STATE_LOGIC  MACRO
       DB  GOTO_COMMAND+EXIT_STATE_LOGIC_FLAG
       DW  0
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHECK_FOR_CORE_KEY MACRO
       DB  CHECK_CORE_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybsys.inc ===
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBSYS.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 Include file containing structure definitions and equates
;;	 for the KEYBOARD.SYS file.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; File header - contains pointers to keyboard tables for each language
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_HEADER	STRUC		       ;;
				       ;;
KH_SIGNATURE	DB   0FFh,'KEYB   '    ;; signature
KH_RESV_1	DB   8 DUP(0)	       ;; reserved
KH_MAX_COM_SZ	DW   0	      ;AN000;**chg  ;; maximum size of Common Xlat Sect
KH_MAX_SPEC_SZ	DW   0	      ;AN000;;**chg   ;; max size of Specific Xlat Sect
KH_MAX_LOGIC_SZ DW   0	      ;AN000;;**chg   ;; max size of State Logic
KH_RESV_2	Dw   0	      ;AN000;;**chg   ;; reserved CNS
KH_NUM_ID	Dw   0		       ;AN000;;; ************* CNS
KH_NUM_LANG	DW   0		       ;; number of languages
KH_LANG_PTRS	DB   0		       ;; language pointers start here
;********************* CNS **********************
;KH_NUM_ID	  DW   0		 ;; number of languages
;KH_ID_PTRS	  DB   0		 ;; id pointers start here
;********************* CNS **********************
KEYBSYS_HEADER	ENDS		       ;;
;******************CNS*******************
KEYBSYS_ID_PTRS STRUC

KP_ID_CODE	DW   0		       ;AN000;
KP_LANG_PTR	DD   0		       ;AN000;

KEYBSYS_ID_PTRS ENDS
				       ;;
;*****************CNS********************
KEYBSYS_LANG_PTRS STRUC 	       ;;
				       ;; Next two entries repeat:
KP_LANG_CODE	DW   0		       ;;   language code
KP_ENTRY_PTR	DD   0		       ;;   language entry pointer
				       ;;
KEYBSYS_LANG_PTRS ENDS		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Language Entry - pointed to by KH_ENTRY_PTR in KEYBSYS_HEADER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_LANG_ENTRY  STRUC	       ;;
				       ;;
KL_LANG_CODE	DW   'XX'              ;; language code
KL_ID_CODE	DW   0		       ;; reserved (ID CODE)
KL_LOGIC_PTR	DD   0	       ;AC000;;**chg  ;; State Logic pointer
KL_NUM_ID	DB   0	       ;AN000;;CNS    ;; number of valid IDs for this lang
KL_NUM_CP	DB   0		       ;; number of valid CPs for this lang
KL_CP_PTRS	DB   0		       ;; CP table pointers start here
				       ;;
KEYBSYS_LANG_ENTRY  ENDS	       ;;
				       ;;
KEYBSYS_CP_PTRS     STRUC	       ;;
				       ;; Next two entries repeat:
KC_CODE_PAGE	DW   0		       ;;  code page
KC_ENTRY_PTR	DD   0		       ;; ptr to Specific Translate Section
				       ;;
KEYBSYS_CP_PTRS     ENDS	       ;;
				       ;;
				       ;;
;; Everything from here down is new
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Logic - pointed to by KL_LOGIC_PTR in KEYBSYS_LANG_ENTRY
;; Common Translate Section follows immediately after the State Logic.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_STATE_LOGIC STRUC	       ;;
				       ;;
KT_LOGIC_LEN	DW   ?		       ;; length of state logic
KT_SPECIAL_FEATURES  DW  ?	       ;; Special Features (see KEYBSHAR.INC)
KT_LOGIC_CMDS	DB   0		       ;; state logic commands begin here
				       ;;
KEYBSYS_STATE_LOGIC ENDS	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Section - Common and Specific Translate Sections
;; are both in this form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_XLAT_SECT   STRUC	       ;;
				       ;;
KX_SECTION_LEN	 DW    ?	       ;; Length of this section
KX_CP_ID	 DW    ?	       ;; code page id
KX_FIRST_STATE	 DB    ?	       ;;
				       ;;
KEYBSYS_XLAT_SECT   ENDS	       ;;
				       ;;
				       ;;
KEYBSYS_STATE	    STRUC	       ;;
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	     ;; Translate Sections contains multiple States.
	     ;; A State contains the translate tables for a single
	     ;; shift state (IE lower case, upper case ....)
	     ;; The last State is a null State containing only the
	     ;; KX_STATE_LEN field with a value of 0.
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
KX_STATE_LEN	 DW    ?	       ;; length of state section
KX_STATE_ID	 DB    ?	       ;; State ID
KX_KBD_TYPE	 DW    ?	       ;; Keyboard Type
KX_ERROR_CHAR	 DW    ?	       ;; Buffer entry for error character
KX_FIRST_XLAT	 DB    ?	       ;; XLAT tables begin here
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	     ;; Each State consists of multiple translate tables.
	     ;; The last translate table within a state is a null
	     ;; table containing only the
	     ;; KX_XLAT_LEN field with a value of 0.
	     ;; Refer to KEYBSHAR.INC for translate table format.
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_STATE	    ENDS	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\parser.asm ===
PAGE	,132
TITLE	PARSE CODE AND CONTROL BLOCKS FOR KEYB.COM

;****************** START OF SPECIFICATIONS **************************
;
;  MODULE NAME: PARSER.ASM
;
;  DESCRIPTIVE NAME: PARSES THE COMMAND LINE PARAMETERS FOR KEYB.COM
;
;  FUNCTION: THE COMMAND LINE IN THE PSP IS PARSED FOR PARAMETERS.
;
;  ENTRY POINT: PARSE_PARAMETERS
;
;  INPUT: BP POINTS TO PARAMETER LIST
;	  DS & ES POINT TO PSP
;
;  AT EXIT:
;     PARAMETER LIST FILLED IN AS REQUIRED.
;
;  INTERNAL REFERENCES:
;
;     ROUTINES: SYSPARSE - PARSING CODE
;
;     DATA AREAS: PARMS - PARSE CONTROL BLOCK FOR SYSPARSE
;
;  EXTERNAL REFERENCES:
;
;     ROUTINES: N/A
;
;     DATA AREAS: PARAMETER LIST BLOCK TO BE FILLED.
;
;  NOTES:
;
;  REVISION HISTORY:
;	 A000 - DOS Version 3.40
;  3/24/88 AN003 - P3906 PARSER changes to return "bogus" parameter on the
;	       "Parameter value not allowed " message - CNS
;  5/12/88 AN004 - P4867 /ID:NON-Numeric hangs the sytem as a 1st positional
;
;
; (C) Copyright Microsoft Corp. 1987-1990
; MS-DOS 5.00 - NLS Support - KEYB Command
;
;
;****************** END OF SPECIFICATIONS ****************************

INCLUDE KEYBDCL.INC

ID_VALID	EQU	0
ID_INVALID	EQU	1
NO_ID		EQU	2

LANGUAGE_VALID	EQU	0
LANGUAGE_INVALID EQU	1
NO_LANGUAGE	EQU	2

NO_IDLANG	EQU	3

CODE_PAGE_VALID EQU	0
CODE_PAGE_INVALID EQU	1
NO_CODE_PAGE	EQU	2
VALID_SYNTAX	EQU	0
INVALID_SYNTAX	EQU	1

COMMAND_LINE_START EQU	81H
RC_EOL		EQU	-1
RC_NO_ERROR	EQU	0
RC_OP_MISSING	EQU	2
RC_NOT_IN_SW	EQU	3

;***CNS P4867 1st CHECK for /ID:ALPHA

RC_SW_FIRST	EQU	9

;***CNS P4867 1st CHECK for /ID:ALPHA

ERROR_COND	EQU	-1
NUMBER		EQU	1
STRING		EQU	3
FILE_SPEC	EQU	5
MAX_ID		EQU	999
LANG_LENGTH	EQU	2

INVALID_SWITCH	EQU	3
TOO_MANY	EQU	1
INVALID_PARAM	EQU	10
VALUE_DISALLOW	EQU	8


	PUBLIC	PARSE_PARAMETERS ; near procedure for parsing command line
	PUBLIC	CUR_PTR 	; near procedure for parsing command line
	PUBLIC	OLD_PTR 	; near procedure for parsing command line
	PUBLIC	ERR_PART	; near procedure for parsing command line

	EXTRN	BAD_ID:BYTE	; WGR to match old code
	EXTRN	FOURTH_PARM:BYTE ; WGR to match old code
	EXTRN	ONE_PARMID:BYTE	; WGR to match old code
	EXTRN	FTH_PARMID:BYTE	; WGR to match old code
	EXTRN	ALPHA:BYTE	; WGR to match old code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Set assemble switches for parse code that is not required!!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DateSW		EQU	0
TimeSW		EQU	0
CmpxSW		EQU	0
DrvSW		EQU	0
QusSW		EQU	0
KeySW		EQU	0
Val1SW		EQU	0
Val2SW		EQU	0
Val3SW		EQU	0


CODE	SEGMENT PUBLIC 'CODE' BYTE
	ASSUME	CS:CODE,DS:CODE

	.XLIST
	INCLUDE	PARSE.ASM	; Parsing code
	.LIST


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PARM control blocks for KEYB
; Parsing command line as follows:
;
; KEYB [lang],[cp],[[d:][path]KEYBOARD.SYS][/ID:id][/e][/?]
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARMS	LABEL	WORD
	DW	PARMSX
	DB	0		; no extra delimeters or EOLs.

PARMSX	LABEL	BYTE
	DB	0,3		; min,max positional operands
	DW	LANG		; pointer to control block
	DW	CP		; pointer to control block
	DW	FILE_NAME	; pointer to control block
	DB	3		; 3 switches
	DW	ID_VALUE	; pointer to control block
	dw	help_value	; pointer to control block
	dw	ext_value	; pointer to control block
	DB	0		; no keywords

LANG	LABEL	WORD
	DW	0A001H		; sstring or numeric value (optional)
	DW	0002H		; cap result by char table (sstring)
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	0		; no keyword/switch synonyms

CP	LABEL	WORD
	DW	8001H		; numeric
	DW	0		; no functions
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	0		; no keyword/switch synonyms

FILE_NAME LABEL WORD
	DW	0201H		; file spec
	DW	0001H		; cap by file table
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	0		; no keyword/switch synonyms

ID_VALUE LABEL	WORD
	DW	8010H		; numeric
	DW	0		; no functions
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	1		; 1 switch synonym
id_name:
	DB	"/ID",0 	; ID switch

help_value label	word
	dw	0		; no values
	dw	0		; no functions
	dw	RESULT_BUF	; result
	dw	novals		; no value checking done
	db	1		; 1 switch synonym
help_name:
	db	"/?",0		; /? switch

ext_value label	word
	dw	0		; no values
	dw	0		; no functions
	dw	result_buf	; result
	dw	novals		; no value checking done
	db	1		; 1 switch synonym
ext_name:
	db	"/E",0		; /e switch


NOVALS	LABEL	BYTE
	DB	0		; no value checking done

RESULT_BUF	LABEL BYTE
RESULT_TYPE	DB	0	; type returned (number, string, etc.)
		DB	?	; matched item tag (if applicable)
RESULT_SYN_PTR	DW	?	; synonym ptr (if applicable)
RESULT_VAL	DD	?	; value

LOOP_COUNT	DB	0	; keeps track of parameter position

;***CNS
CUR_PTR        DW	0	; keeps track of parameter position
OLD_PTR        DW	0	; keeps track of parameter position
ERR_PART       DW	0	; keeps track of parameter position
;***CNS
				;..and reports an error condition

	public	pswitches
pswitches	db	0	; bit 0, /?, bit 1 /e

TEMP_FILE_NAME DB	128 DUP(0) ; place for file name

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PARSE_PARAMETERS
;
; FUNCTION:
; THIS PROCEDURE PARSES THE COMMAND LINE PARAMETERS IN THE PSP FOR
; KEYB.COM. THE PARAMETER LIST BLOCK IS FILLED IN ACCORDINGLY.
;
; AT ENTRY: AS ABOVE.
;
; AT EXIT:
;    AS ABOVE.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARSE_PARAMETERS       PROC	NEAR

	XOR	AX,AX				; setup default parameters.
	MOV	[BP].RET_CODE_1,NO_IDLANG
	MOV	[BP].RET_CODE_2,NO_CODE_PAGE
	MOV	[BP].RET_CODE_3,VALID_SYNTAX
	MOV	[BP].RET_CODE_4,NO_ID
	MOV	[BP].PATH_LENGTH,AX
	LEA	DI,PARMS			; setup parse blocks
	MOV	SI,COMMAND_LINE_START

	call	save_curptr

	XOR	CX,CX
	XOR	DX,DX
	CALL	SYSPARSE

kbs_10:
	cmp	ax,RC_EOL		; while not end of line and...
	jnz	kbs_11
	jmp	kbs_12
kbs_11:
	cmp	LOOP_COUNT,ERROR_COND	; parameters valid, do...
	jnz	kbs_13
	jmp	kbs_12

kbs_13:
	cmp	ax,RC_NOT_IN_SW		; invalid switch?
	jz	kbs_08
	cmp	ax,RC_SW_FIRST
	jnz	kbs_09

kbs_08:
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; set invalid syntax flag.
	MOV	LOOP_COUNT,ERROR_COND		; set error flag to exit parse.

;***CNS
	MOV	ERR_PART,INVALID_SWITCH
	call	save_curptr
;***CNS

	jmp	kbs_10

kbs_09:

	cmp	RESULT_SYN_PTR,offset id_name	; was /id:xxx switch found?
	jnz	not_id_switch


	MOV	AX,WORD PTR RESULT_VAL+2 ; is it valid?
	OR	AX,AX
	jnz	kbs_01

	mov	ax,word ptr RESULT_VAL
	cmp	ax,MAX_ID
	jna	kbs_02

kbs_01:

	MOV	[BP].RET_CODE_1,ID_INVALID	; no...invalid id.
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error.
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse
	mov	bad_id,1

	MOV	[ERR_PART],VALUE_DISALLOW	; SET ERROR TYPE FOR DISPLAY
	call	save_curptr

	jmp	short kbs_03

kbs_02:
	MOV	[BP].RET_CODE_4,ID_VALID ; yes...set return code 4.
	MOV	[BP].ID_PARM,AX
	mov	fourth_parm,1
	mov	fth_parmid,1

	jmp	short kbs_03


not_id_switch:
	cmp	RESULT_SYN_PTR,offset help_name	; was /? switch found?
	jnz	not_help_switch

	or	pswitches,1			; set flag for /?
	jmp	short kbs_03

not_help_switch:
	cmp	RESULT_SYN_PTR,offset ext_name
	jnz	kbs_07

	or	pswitches,2			; set flag for /e
	jmp	short kbs_03


kbs_07:
	INC	LOOP_COUNT		; positional encountered...
	cmp	LOOP_COUNT,1		; check for language
	jnz	kbs_04

	CALL	PROCESS_1ST_PARM

	call	save_curptr

	jmp	short kbs_03

kbs_04:
	cmp	LOOP_COUNT,2		; check for code page
	jnz	kbs_05

	CALL	 PROCESS_2ND_PARM

	call	save_curptr

	jmp	short kbs_03

kbs_05:
	cmp	LOOP_COUNT,3		; check for file name
	jnz	kbs_06

	CALL	PROCESS_3RD_PARM

	call	save_curptr

	jmp	short kbs_03

;	all other cases

kbs_06:
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; too many parms

	call	save_curptr

	MOV	ERR_PART,TOO_MANY
	MOV	LOOP_COUNT,ERROR_COND	; set error flag to exit parse.
kbs_03:
	MOV	RESULT_TYPE,0		; reset result block.
	CALL	SYSPARSE		; parse next parameter.

	jmp	kbs_10

kbs_12:
	cmp	[bp].RET_CODE_4,ID_VALID
	jnz	kbs_14				; ensure that if switch was
	cmp	[bp].RET_CODE_1,LANGUAGE_VALID	; used, it was valid keyword
	jz	kbs_14

	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	 ; code was used..

;***CNS
	call	save_curptr
	MOV	ERR_PART,VALUE_DISALLOW
;***CNS

kbs_14:
	RET

PARSE_PARAMETERS       ENDP

save_curptr	proc	near

	PUSH	AX			;Save environment
	MOV	AX,CUR_PTR		;Set advancing ptr to end of argument
	MOV	OLD_PTR,AX		;after saving the beginning the string
	MOV	CUR_PTR,SI
	POP	AX			;Restore the environment
	ret

save_curptr	endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PROCESS_1ST_PARM
;
; FUNCTION:
; THIS PROCEDURE PROCESSES THE FIRST POSITIONAL PARAMETER. THIS SHOULD
; BE THE LANGUAGE ID OR THE KEYBOARD ID.
;
; AT ENTRY: PARSE RESULT BLOCK CONTAINS VALUES IF AX HAS NO ERROR.
;
; AT EXIT:
;    PARAMETER CONTROL BLOCK UPDATED FOR LANGUAGE ID.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_1ST_PARM       PROC    NEAR

	cmp	ax,RC_NO_ERROR		; error on parse?
	jng	kbs_23

	MOV	[BP].RET_CODE_1,LANGUAGE_INVALID ; yes...set invalid language
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	 ; and syntax error..
	MOV	LOOP_COUNT,ERROR_COND		 ; set flag to exit parse.
	MOV	ERR_PART,AX

	jmp	kbs_18

kbs_23:
	cmp	RESULT_TYPE,NUMBER	; was this a number (id?)
	jnz	kbs_24

	MOV	AX,WORD PTR RESULT_VAL+2 ; yes...check to see if
	OR	AX,AX			; within range.
	jnz	kbs_19

	MOV	AX,WORD PTR RESULT_VAL
	cmp	ax,max_id
	jna	kbs_17

kbs_19:
	MOV	[BP].RET_CODE_1,ID_INVALID	; no...invalid id.
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error.
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse
	mov	bad_id,1

	jmp	short kbs_18

kbs_17:
	MOV	[BP].RET_CODE_1,ID_VALID	; valid id...set
	MOV	[BP].RET_CODE_4,ID_VALID	; valid id...set
	MOV	[BP].ID_PARM,AX			; and value moved into block
	MOV	LOOP_COUNT,4			; there should be no more parms
	mov	one_parmid,1

	jmp	short kbs_18

kbs_24:
	cmp	RESULT_TYPE,STRING	; must be a string then???
	jnz	kbs_26

	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	DS
	LDS	SI,RESULT_VAL		; get ptr to string
	MOV	DI,BP
	ADD	DI,LANGUAGE_PARM	; point to block for copy.
	MOV	CX,LANG_LENGTH		; maximum length = 2
	LODSB				; load AL with 1st char..

kbs_16:
	jcxz	kbs_15			; do twice, unless only 1 char
	or	al,al
	jz	kbs_15

	STOSB				; store
	DEC	CX			; dec count
	LODSB				; load

	jmp	kbs_16

kbs_15:

	or	cx,cx			; if there was less than 2 or..
	jnz	kbs_20
	or	al,al			;  greater than 2 chars, then..
	jz	kbs_21

kbs_20:
	MOV	[BP].RET_CODE_1,LANGUAGE_INVALID ; invalid.
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error
	MOV	ERR_PART,INVALID_PARAM
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse.

	jmp	short kbs_22

kbs_21:
	MOV	[BP].RET_CODE_1,LANGUAGE_VALID	; valid language has been copied
	MOV	ALPHA,1				; language found

kbs_22:
	POP	DS
	POP	CX
	POP	DI
	POP	SI
	jmp	short kbs_18

;	omitted parameter...

kbs_26:
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; invalid since further parameters.
kbs_18:
	RET

PROCESS_1ST_PARM       ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PROCESS_2ND_PARM
;
; FUNCTION:
; THIS PROCEDURE PROCESSES THE 2ND POSITIONAL PARAMETER. THIS SHOULD
; BE THE CODE PAGE, IF REQUESTED.
;
; AT ENTRY: PARSE RESULT BLOCK CONTAINS VALUES IF AX HAS NO ERROR.
;
; AT EXIT:
;    PARAMETER CONTROL BLOCK UPDATED FOR CODE PAGE.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_2ND_PARM       PROC    NEAR

	cmp	ax,RC_NO_ERROR			; if parse error
	jle	kbs_32

	MOV	[BP].RET_CODE_2,CODE_PAGE_INVALID ; mark invalid..
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse
	MOV	ERR_PART,AX

	jmp	short kbs_31

kbs_32:

	cmp	RESULT_TYPE,NUMBER		; was parameter specified?
	jnz	kbs_30

	MOV	AX,WORD PTR RESULT_VAL+2	; yes..if code page not..
	OR	AX,AX

	jnz	kbs_27

	MOV	AX,WORD PTR RESULT_VAL		; valid..then

	cmp	ax,MAX_ID
	jna	kbs_28

kbs_27:
	MOV	[BP].RET_CODE_2,CODE_PAGE_INVALID ; mark invalid..
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse

	jmp	short kbs_31

kbs_28:
	MOV	[BP].RET_CODE_2,CODE_PAGE_VALID	; else...valid code page
	MOV	[BP].CODE_PAGE_PARM,AX		; move into parm

	jmp	short kbs_31

kbs_30:
	MOV	[BP].RET_CODE_2,NO_CODE_PAGE	; mark as not specified.
kbs_31:
	RET

PROCESS_2ND_PARM      ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PROCESS_3RD_PARM
;
; FUNCTION:
; THIS PROCEDURE PROCESSES THE 3RD POSITIONAL PARAMETER. THIS SHOULD
; BE THE KEYBOARD DEFINITION FILE PATH, IF SPECIFIED.
;
; AT ENTRY: PARSE RESULT BLOCK CONTAINS VALUES IF AX HAS NO ERROR.
;
; AT EXIT:
;    PARAMETER CONTROL BLOCK UPDATED FOR FILE NAME.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_3RD_PARM       PROC    NEAR

	cmp	ax,RC_NO_ERROR		; if parse error, then...
	jle	kbs_33

	MOV	[BP].RET_CODE_3,INVALID_SYNTAX ; syntax error.
	MOV	LOOP_COUNT,ERROR_COND	; set flag to exit parse
	MOV	ERR_PART,AX

	jmp	short kbs_34

kbs_33:

	cmp	RESULT_TYPE,FILE_SPEC
	jnz	kbs_34

	PUSH	DS
	PUSH	SI
	PUSH	DI
	PUSH	CX
	LDS	SI,RESULT_VAL		; load offset of file name
	LEA	DI,TEMP_FILE_NAME
	MOV	[BP].PATH_OFFSET,DI	; copy to parameter block
	XOR	CX,CX
	LODSB				; count the length of the path.

kbs_35:
	or	al,al
	jz	kbs_36

	STOSB
	LODSB
	INC	CX
	jmp	short kbs_35

kbs_36:
	MOV	[BP].PATH_LENGTH,CX	; copy to parameter block
	POP	CX
	POP	DI
	POP	SI
	POP	DS
kbs_34:
	RET

PROCESS_3RD_PARM ENDP

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybtbbl.asm ===
PAGE	,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; (C) Copyright Microsoft Corp. 1987-1990
; MS-DOS 5.00 - NLS Support - KEYB Command
;
; File Name:  KEYBTBBL.ASM
; ----------
;
; Description:
; ------------
;	Build SHARED_DATA_AREA with parameters specified
;	in KEYBCMD.ASM
;
; Documentation Reference:
; ------------------------
;	None
;
; Procedures Contained in This File:
; ----------------------------------
;	TABLE_BUILD: Build the header sections of the SHARED_DATA_AREA
;	STATE_BUILD: Build the state sections in the table area
;	FIND_CP_TABLE: Given the language and code page parm, determine the
;		offset of the code page table in KEYBOARD.SYS
;
; Include Files Required:
; -----------------------
;	KEYBSHAR.INC
;	KEYBSYS.INC
;	KEYBDCL.INC
;	KEYBI2F.INC
;
; External Procedure References:
; ------------------------------
;	None
;
; Change History:
; ---------------
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	PUBLIC TABLE_BUILD
	PUBLIC FIND_CP_TABLE
	PUBLIC CPN_INVALID
	PUBLIC SD_LENGTH

CODE	SEGMENT PUBLIC 'CODE'

	INCLUDE KEYBEQU.INC
	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBSYS.INC
	INCLUDE KEYBCMD.INC
	INCLUDE KEYBDCL.INC
	INCLUDE COMMSUBS.INC
	INCLUDE KEYBCPSD.INC

	ASSUME  cs:CODE,ds:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: TABLE_BUILD
;
; Description:
;	Create the table area within the shared data structure. Each
;	table is made up of a descriptor plus the state sections.
;	Translate tables are found in the Keyboard definition file and are
;	copied into the shared data area by means of the STATE_BUILD
;	routine.
;
; Input Registers:
;	ds - points to our data segment
;	es - points to our data segment
;	bp - points at beginning of CMD_PARM_LIST
;
;	SHARED_DATA_STR must be allocated in memory
;
;	The following variables must also be passed from KEYB_COMMAND
;	 KEYBSYS_FILE_HANDLE is set to file handle after opening file
;	 CP_TAB_OFFSET is the offset of the CP table in the SHARED_DATA_AREA
;	 STATE_LOGIC_OFFSET is the offset of the state section in the SHARED_DATA_AREA
;	 SYS_CODE_PAGE is the binary representation of the system CP
;	 KEYBCMD_LANG_ENTRY_PTR is a pointer to the lang entry in KEY DEF file
;	 DESIG_CP_BUFFER is the buffer which holds a list of designated CPs
;	 DESIG_CP_OFFSET:WORD is the offset of that list
;	 NUM_DESIG_CP is the number of CPs designated
;	 FILE_BUFFER is the buffer to read in the KEY DEF file
;**********CNS ***************************************
;	 ID_PTR_SIZE is the size of the ID ptr structure
;**********CNS ***************************************
;	 LANG_PTR_SIZE is the size of the lang ptr structure
;	 CP_PTR_SIZE is the size of the CP ptr structure
;	 NUM_CP is the number of CPs in the KEYB DEF file for that lang
;	 SHARED_AREA_PTR segment and offset of the SHARED_DATA_AREA
;
;
; Output Registers:
;	cx - RETURN_CODE :=  0  - Table build successful
;			  1  - Table build unsuccessful - ERROR 1
;					(Invalid language parm)
;			  2  - Table build unsuccessful - ERROR 2
;					(Invalid Code Page parm)
;			  3  - Table build unsuccessful - ERROR 3
;					(Machine type unavaliable)
;			  4  - Table build unsuccessful - ERROR 4
;					(Bad or missing keyboard def file)
;			  5  - Table build unsuccessful - ERROR 5
;					(Memory overflow occurred)
; Logic:
;	Calculate Offset difference between TEMP and SHARED_DATA_AREAs
;	Get LANGUAGE_PARM and CODE_PAGE_PARM from parm list
;	Call FIND_CP_TABLE := Determine whether CP is valid for given language
;	IF CP is valid THEN
;	Store them in the SHARED_DATA_AREA
;	Prepare to read Keyboard definition file by LSEEKing to the top
;	READ the header
;	Store maximum table values for calculation of RES_END
;	Set di to point at TABLE_AREA within SHARED_DATA_AREA
;	FOR the state logic section of the specified language:
;		IF STATE_LOGIC_PTR is not -1 THEN
;		LSEEK to state logic section in keyboard definition file
;		READ the state logic section into the TABLE_AREA
;		Set the hot keyb scan codes
;		Set the LOGIC_PTR in the header
;	FOR the common translate section:
;		IF Length parameter is not 0 THEN
;		Build state
;		Set the COMMON_XLAT_PTR in the header
;	FOR the specific translate sections:
;	Establish addressibility to list of designated code pages
;	FOR each code page
;		IF CP_ENTRY_PTR is not -1 THEN
;		Determine offset of CP table in Keyb Def file
;		IF CP table not avaliable THEN
;			Set CPN_INVALID flag
;		ELSE
;			LSEEK to CPn state section in keyboard definition file
;			IF this is the invoked code page THEN
;			Set ACTIVE_XLAT_PTR in SHARED_DATA_AREA
;			Update RESIDENT_END ptr
;			Build state
;	Update RESIDENT_END ptr
;	End
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FB		EQU	FILE_BUFFER
KB_MASK		EQU	02H

FIRST_XLAT_TAB	DW	0
NEXT_SECT_PTR	DW	-1

MAX_COM_SIZE	DW	?
MAX_SPEC_SIZE	DW	?
MAX_LOGIC_SIZE	DW	?

RESIDENT_END_ACC DW	0
SA_HEADER_SIZE	DW	SIZE SHARED_DATA_STR;
PARM_LIST_OFFSET DW	?
;********************CNS*************************
TB_ID_PARM	DW	0
;********************CNS*************************
TB_LANGUAGE_PARM DW	0
TB_CODE_PAGE_PARM DW	0

CPN_INVALID	DW	0

KEYB_INSTALLED	DW	0
SD_AREA_DIFFERENCE DW	0
SD_LENGTH	DW	2000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TABLE_BUILD	  PROC NEAR

	mov	ax,OFFSET SD_SOURCE_PTR	; Setup the difference
	sub	ax,OFFSET SD_DesT_PTR	; value used to calculate
	mov	SD_AREA_DIFFERENCE,ax	; new ptr values for
					;  SHARED_DATA_AREA
	mov	ax,[bp].ID_PARM		; Get id parameter
	mov	TB_ID_PARM,ax
	mov	ax,[bp].LANGUAGE_PARM	; Get language parameter
	mov	TB_LANGUAGE_PARM,ax
	mov	bx,[bp].CODE_PAGE_PARM	; Get code page parameter
	mov	TB_CODE_PAGE_PARM,bx
					; Make sure code page is
	call	FIND_CP_TABLE		;   valid for the language
	jcxz	TB_CHECK_CONTINUE1	; IF code page is found
	jmp	TB_ERROR6		;  for language THEN

TB_CHECK_CONTINUE1:
	mov	bp,OFFSET SD_SOURCE_PTR	; Put language parm and
	mov	ax,TB_ID_PARM		;  id parm and..
	mov	es:[bp].INVOKED_KBD_ID,ax
	mov	bx,TB_CODE_PAGE_PARM
	mov	es:[bp].INVOKED_CP_TABLE,bx	; code page parm into the
	mov	ax,TB_LANGUAGE_PARM		;  SHARED_DATA_AREA
	mov	word ptr es:[bp].ACTIVE_LANGUAGE,ax

	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	xor	dx,dx			; LSEEK file pointer
	xor	cx,cx			;  back to top of file
	mov	ax,4200h		; If no problem with
	int	21H			;  Keyboard Def file THEN
	jnc	TB_START
	jmp	TB_ERROR4

TB_START:				; Else
	xor	di,di			; Set number
	lea	cx,[di].KH_NUM_ID+2	; M006 -- read a few extra entries
	mov	dx,OFFSET FILE_BUFFER	; Move contents into file buffer
	mov	ah,3FH			;  READ
	push	cs
	pop	ds
	int	21H			;  File
	jnc	TB_CONTINUE1
	jmp	TB_ERROR4

TB_CONTINUE1:
	cmp	cx,ax
	je	TB_ERROR_CHECK1
ifndef JAPAN
	mov	cx,4
	jmp	TB_CPN_INVALID
else ; JAPAN
tb_err4_j:				; M006
	jmp	TB_ERROR4		; M002
endif ; JAPAN

TB_ERROR_CHECK1:
ifdef JAPAN
	cmp	FB.KH_NUM_ID,0		; M006 -- is it an old KEYBOARD.SYS?
	jz	tb_err4_j		; M006 --  bomb out if so
endif ; JAPAN
	mov	cx,FB.KH_MAX_COM_SZ	; Save values for RESIDENT_END
	mov	MAX_COM_SIZE,cx		;  calculation
	mov	cx,FB.KH_MAX_SPEC_SZ
	mov	MAX_SPEC_SIZE,cx
	mov	cx,FB.KH_MAX_LOGIC_SZ
	mov	MAX_LOGIC_SIZE,cx

	LEA	di,[bp].TABLE_AREA	; Point at beginning of table area
					;		di ---> TABLE_AREA
ifdef JAPAN
;	M002 -- begin added section
;
;	Before we go ANY further, let's see if we actually have room
;	   for our worst case memory allocation needs.  Notice that
;	   we're actually trusting the MAX fields from the KEYBOARD
;	   definition file.  If it lies to us and has fields bigger
;	   than these MAX values, we may crash over memory we don't
;	   own during initialization.

	mov	ax,NUM_DESIG_CP
	mul	MAX_SPEC_SIZE
	or	dx,dx			; error if overflowed 16 bits
	jnz	mem_alloc_err

	add	ax,SA_HEADER_SIZE
	jc	mem_alloc_err
	add	ax,MAX_LOGIC_SIZE
	jc	mem_alloc_err
	add	ax,MAX_COM_SIZE
	jc	mem_alloc_err

;	Note that ax could be used for the RESIDENT_END_ACC value,
;	  but since this check is being added late in the testing
;	  cycle, we'll leave that calculation alone.

	add	ax,di			; get the ending offset of temp buffer
	jc	mem_alloc_err

	add	ax,15
	jc	mem_alloc_err
	mov	cl,4			; convert to paragraph
	shr	ax,cl
	mov	cx,ax
	mov	ax,cs			; get our code segment
	add	ax,cx			; this is our ending segment
	cmp	ax,cs:[2]		; compare against psp:2
	jb	mem_alloc_ok
mem_alloc_err:
	jmp	TB_ERROR5
mem_alloc_ok:

;	M002 -- end added section
endif ; JAPAN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	** FOR STATE LOGIC SECTION FOR LANG **
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TB_STATE_BEGIN:
	mov	bx,KEYBSYS_FILE_HANDLE		; Get handle
	mov	cx,word ptr STATE_LOGIC_OFFSET+2
	mov	dx,word ptr STATE_LOGIC_OFFSET	; Get LSEEK file pointer

	cmp	dx,-1			; If no language table then
	jnz	TB_STATE_CONTINUE1	;  jump to code page begin
	jmp	TB_CP_BEGIN

TB_STATE_CONTINUE1:			; Else
	mov	ax,4200h		; LSEEK to begin of state logic sect
	int	21H			;	Keyboard Def file THEN
	jnc	TB_STATE_CONTINUE2
	jmp	TB_ERROR4

TB_STATE_CONTINUE2:
	mov	dx,ax
	mov	word ptr SB_STATE_OFFSET+2,cx	;  Save the offset of the
	mov	word ptr SB_STATE_OFFSET,dx	;	states in Keyb Def file

	sub	di,SD_AREA_DIFFERENCE	; Adjust for relocation
	mov	es:[bp].LOGIC_PTR,di	; Set because this is state
	add	di,SD_AREA_DIFFERENCE	; Adjust for relocation

	mov	cx,4			; Set number bytes to read length and
					;	special features
	mov	dx,OFFSET FILE_BUFFER	; Set the buffer address
	mov	ah,3FH			; Read from the Keyb Def file
	int	21H
	jnc	TB_STATE_CONTINUE3
	jmp	TB_ERROR4

TB_STATE_CONTINUE3:
	cmp	cx,ax
	je	TB_ERROR_CHECK2
ifndef JAPAN
	mov	cx,4
	jmp	TB_CPN_INVALID
else ; JAPAN
	jmp	TB_ERROR4
endif ; JAPAN

TB_ERROR_CHECK2:
	mov	ax,FB.KT_SPECIAL_FEATURES	; Save the special features in the
	mov	es:[bp].SPECIAL_FEATURES,ax	;	SHARED_DATA_AREA


	mov	es:[bp].HOT_KEY_ON_SCAN,F1_SCAN
	mov	es:[bp].HOT_KEY_OFF_SCAN,F2_SCAN

HOT_KEY_SET:
	mov	cx,FB.KT_LOGIC_LEN	; Set length of section to read
	or	cx,cx
	jnz	TB_STATE_CONTINUE4

	dec	cx			; cx = -1
	mov	es:[bp].LOGIC_PTR,cx
	jmp	short SB_COMM_BEGIN

TB_STATE_CONTINUE4:
	mov	es:[di],cx		; Store length parameter in
	add	di,2			;	  SHARED_DATA_AREA
	mov	cx,FB.KT_SPECIAL_FEATURES ; Save the special features
	mov	es:[di],cx
	add	di,2
	mov	cx,FB.KT_LOGIC_LEN	; Set length of section to read
	sub	cx,4			; Adjust for what we have already read
	mov	dx,di			; Set the address of SHARED_DATA_AREA
	push	es
	pop	ds
	mov	ah,3FH			; Read logic section from the
	int	21H			;	Keyb Def file
	push	cs
	pop	ds
	jnc	TB_STATE_CONTINUE5
	jmp	TB_ERROR4

TB_STATE_CONTINUE5:
	cmp	cx,ax
	je	TB_ERROR_CHECK3
ifndef JAPAN
	mov	cx,4
	jmp	TB_CPN_INVALID
else ; JAPAN
	jmp	TB_ERROR4
endif ; JAPAN

TB_ERROR_CHECK3:
	add	di,cx			; Set di at new beginning of area
					;		TABLE_AREA
					;		STATE_LOGIC
	mov	cx,RESIDENT_END_ACC	;	di --->
	add	cx,SA_HEADER_SIZE
	add	cx,MAX_LOGIC_SIZE
	mov	RESIDENT_END_ACC,cx	;  Refresh Resident end size

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	** FOR COMMON TRANSLATE SECTION FOR LANG **
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SB_COMM_BEGIN:
	mov	cx,SIZE KEYBSYS_XLAT_SECT-1 ; Set number bytes to read header
	mov	dx,di			; Set the SHARED_DATA_AREA address
	push	es
	pop	ds
	mov	ah,3FH			; Read from the Keyb Def file
	int	21H
	push	cs
	pop	ds
	jnc	TB_STATE_CONTINUE6
	jmp	TB_ERROR4

TB_STATE_CONTINUE6:
	mov	cx,es:[di].KX_SECTION_LEN; Set length of section to read
	jcxz	TB_CP_BEGIN

	mov	cx,word ptr SB_STATE_OFFSET	;  Save the offset of the
	add	cx,FB.KT_LOGIC_LEN
	mov	word ptr SB_STATE_OFFSET,cx	;  Save the offset of the
	sub	di,SD_AREA_DIFFERENCE		;   Adjust for relocation
	mov	es:[bp].COMMON_XLAT_PTR,di
	add	di,SD_AREA_DIFFERENCE		;   Adjust for relocation

	call	STATE_BUILD
					; di set at new beginning of area
					;		TABLE_AREA
					;		STATE_LOGIC
					;		COMMON_XLAT_SECTION
	mov	cx,RESIDENT_END_ACC
	add	cx,MAX_COM_SIZE
	mov	RESIDENT_END_ACC,cx	;  Refresh resident end size

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	FOR alL DESIGNATED OR INVOKED CODE PAGES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TB_CP_BEGIN:						; Get the offset to
	mov	cx,OFFSET DESIG_CP_BUFFER.DESIG_CP_ENTRY ; the beginning of the
	mov	DESIG_CP_OFFSET,cx			; table of designated
							; code pages
TB_CPN_BEGIN:
	mov	ax,word ptr es:[bp].ACTIVE_LANGUAGE  ; Get the active language
	mov	cx,NUM_DESIG_CP		; Get the number of CPs
	or	cx,cx			; IF we have done all requested CPs
	jnz	TB_CPN_VALID1
	jmp	TB_DONE			;	Then done

TB_CPN_VALID1:
	mov	si,[DESIG_CP_OFFSET]
	mov	bx,[si]			; Get the CP
	cmp	bx,-1
	jnz	TB_CPN_CONTINUE1
	jmp	short TB_CPN_REPEAT

TB_CPN_CONTINUE1:			; ELSE
	push	di
	call	FIND_CP_TABLE		;	Find offset of code page table
	pop	di

	jcxz	TB_CPN_VALID		;  brif valid code page for language
	mov	CPN_INVALID,cx		;	Set flag and go to next CP
	jmp	short TB_CPN_REPEAT	; Else

TB_CPN_VALID:
	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	mov	cx,word ptr CP_TAB_OFFSET+2  ; Get offset of the code page
	mov	dx,word ptr CP_TAB_OFFSET ;	in the Keyb Def file

	cmp	dx,-1			; Test if code page is blank
	jnz	TB_CPN_CONTINUE2
	jmp	short TB_CPN_REPEAT	; If it is then go get next CP

TB_CPN_CONTINUE2:
	mov	ax,4200h		; LSEEK to table in Keyb Def file
	int	21H			;	Keyb Def file Then
	jnc	TB_CPN_CONTINUE3
	jmp	TB_ERROR4

TB_CPN_CONTINUE3:
	mov	dx,ax
	mov	word ptr SB_STATE_OFFSET+2,cx	;  Save the offset of the
	mov	word ptr SB_STATE_OFFSET,dx	;	states in Keyb Def file

	mov	cx,TB_CODE_PAGE_PARM	;  If this code page is the
	mov	si,[DESIG_CP_OFFSET]	;	invoked code page
	cmp	cx,[si]
	jnz	TB_CPN_CONTINUE4	;  Then

	sub	di,SD_AREA_DIFFERENCE	;  Adjust for relocation
	mov	es:[bp].ACTIVE_XLAT_PTR,di ;  Set active xlat section
	add	di,SD_AREA_DIFFERENCE	;  Adjust for relocation

TB_CPN_CONTINUE4:
	sub	di,SD_AREA_DIFFERENCE	;  Adjust for relocation
	mov	es:[bp].FIRST_XLAT_PTR,di ;	  Set flag
	add	di,SD_AREA_DIFFERENCE	;  Adjust for relocation

TB_CPN_CONTINUE5:
	CALL	STATE_BUILD		;  Build state
					;		TABLE_AREA
	jcxz	TB_CPN_REPEAT		;    COMMON_XLAT_SECTION,SPECIFIC...
	jmp	TB_ERROR4		;	di --->

TB_CPN_REPEAT:
	mov	cx,RESIDENT_END_ACC
	add	cx,MAX_SPEC_SIZE	;  Refresh resident end size
	mov	RESIDENT_END_ACC,cx

	mov	cx,DESIG_CP_OFFSET
	add	cx,2			; Adjust offset to find next code page
	mov	DESIG_CP_OFFSET,cx

	mov	cx,NUM_DESIG_CP		; Adjust the number of code pages left
	dec	cx
	mov	NUM_DESIG_CP,cx

	jmp	TB_CPN_BEGIN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TB_DONE:
	mov	cx,RESIDENT_END_ACC	;  Set final calculated value
	add	cx,bp
	sub	cx,SD_AREA_DIFFERENCE		;  Adjust for relocation
	mov	es,word ptr SHARED_AREA_PTR	;	Set segment
	mov	bp,word ptr SHARED_AREA_PTR+2
	cmp	cx,es:[bp].RESIDENT_END
	JNA	TB_DONE_CONTINUE1
	jmp	short TB_ERROR5

TB_DONE_CONTINUE1:
	cmp	es:[bp].RESIDENT_END,-1
	jnz	DONT_REPLACE
	push	cs
	pop	es
	mov	bp,OFFSET SD_SOURCE_PTR
	mov	es:[bp].RESIDENT_END,cx ;  Save resident end
	jmp	short CONTINUE_2_END

DONT_REPLACE:
	push	cs
	pop	es
	mov	bp,OFFSET SD_SOURCE_PTR

CONTINUE_2_END:
	sub	cx,OFFSET SD_DesT_PTR	;  Calculate # of bytes to copy
	mov	SD_LENGTH,cx

	xor	cx,cx			;  Set valid completion return code
	mov	TB_RETURN_CODE,cx
	ret

ifndef JAPAN
;	M002 -- dead code deleted.  The following label was only
;		branched to with cx==4.  Those calls were all
;		replaced with direct JMPs to TB_ERROR4, which was
;		assumed to set cx=4 in other places anyway.
TB_CPN_INVALID:
	cmp	cx,1			;  Set error 1 return code
	jnz	TB_ERROR2
	mov	TB_RETURN_CODE,cx
	ret

TB_ERROR2:
	cmp	cx,2			;  Set error 2 return code
	jnz	TB_ERROR3
	mov	TB_RETURN_CODE,cx
	ret

TB_ERROR3:
	cmp	cx,3			;  Set error 3 return code
	jnz	TB_ERROR4
	mov	TB_RETURN_CODE,cx
	ret
endif ; !JAPAN

TB_ERROR4:
ifndef JAPAN
	cmp	cx,4			;  Set error 4 return code
	jnz	TB_ERROR5
else ; JAPAN
	mov	cx,4		; M002	; set error 4 return code
endif ; JAPAN
	mov	TB_RETURN_CODE,cx
	ret

TB_ERROR5:
	mov	cx,5			;  Set error 5 return code
	mov	TB_RETURN_CODE,cx
	ret

TB_ERROR6:
	mov	bx,TB_CODE_PAGE_PARM
	mov	cx,6
	mov	TB_RETURN_CODE,cx	;  Set error 6 return code
	ret

TABLE_BUILD	  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: STATE_BUILD
;
; Description:
;	Create the state/xlat section within the specific translate section.
;
; Input Registers:
;	ds - points to our data segment
;	es - points to our data segment
;	SB_STATE_OFFSET - offset to the beginning of the info in Keyb Def SYS
;	di - offset of the beginning of the area used to build states
;
;	KEYBSYS_FILE_HANDLE - handle of the KEYBOARD.SYS file
;
; Output Registers:
;	di  - offset of the end of the area used by STATE_BUILD
;
;	cx - Return Code := 0  -  State build successful
;			    4  -  State build unsuccessful
;				    (Bad or missing Keyboard Def file)
;
; Logic:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

END_OF_AREA_PTR	DW	0
SB_FIRST_STATE	DW	0
SB_STATE_LENGTH	DW	0
SB_STATE_OFFSET	DD	0
STATE_LENGTH	DW	0
RESTORE_BP	DW	?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

STATE_BUILD	  PROC NEAR

	mov	si,di			;  Get the tally pointer
	mov	END_OF_AREA_PTR,di	;  Save pointer

	mov	RESTORE_bp,bp		;  Save the base pointer

	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	mov	dx,word ptr SB_STATE_OFFSET	; LSEEK file pointer
	mov	cx,word ptr SB_STATE_OFFSET+2	;	back to top of XLAT table
	mov	ax,4200h		; If no problem with
	int	21H			;   Keyboard Def file THEN
	jnc	SB_FIRST_HEADER
	jmp	SB_ERROR4

SB_FIRST_HEADER:
	xor	bp,bp
	LEA	cx,[bp].KX_FIRST_STATE	; Set number of bytes to read header
	mov	dx,di
	push	es
	pop	ds
	mov	ah,3FH			; read in the header
	int	21H
	push	cs
	pop	ds
	jnc	SB_HEAD_CONTINUE1
	jmp	SB_ERROR4

SB_HEAD_CONTINUE1:
	mov	dx,NEXT_SECT_PTR
	cmp	dx,-1
	je	SB_HEAD_CONTINUE2
	sub	dx,SD_AREA_DIFFERENCE	;  Adjust for relocation

SB_HEAD_CONTINUE2:
	mov	es:[di].XS_NEXT_SECT_PTR,dx
	cmp	dx,-1
	je	SB_HEAD_CONTINUE3
	add	dx,SD_AREA_DIFFERENCE	;  Adjust for relocation

SB_HEAD_CONTINUE3:
	add	di,cx			; Update the di pointer

SB_NEXT_STATE:
	xor	bp,bp			;  Set number
	LEA	cx,[bp].KX_STATE_ID	;	bytes to read state length
	mov	dx,di			;  Read the header into the
	mov	bx,KEYBSYS_FILE_HANDLE	;	SHARED_DATA_AREA
	push	es
	pop	ds
	mov	ah,3FH
	int	21H

SB_CONTINUE1:
	push	cs			; Reset the data segment
	pop	ds
	mov	cx,es:[di].KX_STATE_LEN ; If the length of the state section
	mov	STATE_LENGTH,cx
	add	di,2			;  is zero then done
	jcxz	SB_DONE

	xor	bp,bp			;  Set number
	LEA	cx,[bp].KX_FIRST_XLAT-2 ;	bytes to read state length
	mov	dx,di			;  Read the header into the
	mov	bx,KEYBSYS_FILE_HANDLE	;	SHARED_DATA_AREA
	push	es
	pop	ds
	mov	ah,3FH
	int	21H

SB_CONTINUE1A:
	push	cs			; Reset the data segment
	pop	ds
	sub	di,2
	mov	ax,es:[di].XS_KBD_TYPE	; Get the keyboard type def
	test	ax,HW_TYPE		; Does it match our hardware?
	JNZ	SB_CONTINUE2
	mov	dx,es:[di].XS_STATE_LEN ; No, then
	LEA	cx,[bp].KX_FIRST_XLAT
	sub	dx,cx
	xor	cx,cx
	mov	ah,42H			;  LSEEK past this state
	mov	al,01H
	int	21H
	jmp	SB_NEXT_STATE

SB_CONTINUE2:				; Yes, then
	mov	ax,SIZE STATE_STR-1
	add	di,ax			; Set PTR and end of header

SB_XLAT_TAB_BEGIN:			; Begin getting xlat tables
	mov	bx,KEYBSYS_FILE_HANDLE
	LEA	dx,[bp].KX_FIRST_XLAT	; Adjust for what we have already read
	mov	cx,STATE_LENGTH
	sub	cx,dx
	mov	dx,di
	push	es
	pop	ds
	mov	ah,3FH			; Read in the xlat tables
	int	21H
	push	cs
	pop	ds
	jnc	SB_CONTINUE4
	jmp	short SB_ERROR4

SB_CONTINUE4:
	cmp	cx,ax
	je	SB_ERROR_CHECK1
	jmp	short SB_ERROR4

SB_ERROR_CHECK1:
	add	di,cx			; Update the end of area ptr

	mov	si,di
	jmp	SB_NEXT_STATE

SB_DONE:
	mov	ax,-1
	mov	si,END_OF_AREA_PTR
	mov	NEXT_SECT_PTR,si

	mov	bp,RESTORE_bp
	ret

SB_ERROR1:
	mov	cx,1
	ret

SB_ERROR2:
	mov	cx,2
	ret

SB_ERROR3:
	mov	cx,3
	ret

SB_ERROR4:
	mov	cx,4
	ret


STATE_BUILD	  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: FIND_CP_TABLE
;
; Description:
;	Determine the offset of the specified code page table in KEYBOARD.SYS
;
; Input Registers:
;	ds - points to our data segment
;	es - points to our data segment
;	ax - ASCII representation of the language parm
;	bx - binary representation of the code page
;
;	KEYBSYS_FILE_HANDLE - handle of the KEYBOARD.SYS file
;
; Output Registers:
;	CP_TAB_OFFSET - offset of the CP table in KEYBOARD.SYS
;
;	cx - Return Code := 0  -  State build successful
;			    2  -  Invalid Code page for language
;			    4  -  Bad or missing Keyboard Def file
; Logic:
;
;	READ language table
;	IF error in reading file THEN
;	 Display ERROR message and EXIT
;	ELSE
;	 Use table to verify language parm
;	 Set pointer values
;	 IF code page was specified
;		READ language entry
;		IF error in reading file THEN
;		  Display ERROR message and EXIT
;		ELSE
;		  READ Code page table
;		  IF error in reading file THEN
;			Display ERROR message and EXIT
;		  ELSE
;			Use table to get the offset of the code page parm
;	ret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_CP_PARM	  DW	?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_CP_TABLE	  PROC  NEAR


	mov	FIND_CP_PARM,bx	  ; Save Code page

	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	mov	dx,word ptr KEYBCMD_LANG_ENTRY_PTR ; LSEEK file pointer
	mov	cx,word ptr KEYBCMD_LANG_ENTRY_PTR+2 ;  to top of language entry
	mov	ax,4200h		; If no problem with
	int	21H			;   Keyb Def file Then
	jnc	FIND_BEGIN
	jmp	short FIND_CP_ERROR4

FIND_BEGIN:
	mov	di,ax
	mov	cx,SIZE KEYBSYS_LANG_ENTRY-1	; Set number
						;	bytes to read header
	mov	dx,OFFSET FILE_BUFFER
	mov	ah,3FH			; Read language entry in
	int	21H			;	KEYBOARD.SYS file
	jnc	FIND_VALID4		; If no error in opening file then
	jmp	short FIND_CP_ERROR4

FIND_VALID4:

;****************************** CNS ****************************************
	xor	ah,ah
	mov	al,FB.KL_NUM_CP
;****************************** CNS ****************************************

	mov	NUM_CP,ax		; Save the number of code pages
	MUL	CP_PTR_SIZE		; Determine # of bytes to read
	mov	dx,OFFSET FILE_BUFFER	; Establish beginning of buffer
	mov	cx,ax
	cmp	cx,FILE_BUFFER_SIZE	; Make sure buffer is not to small
	jbe	FIND_VALID5
	jmp	short FIND_CP_ERROR4

FIND_VALID5:
	mov	ah,3FH			; Read code page table from
	int	21H			;	KEYBOARD.SYS file
	jnc	FIND_VALID6		; If no error in opening file then
	jmp	short FIND_CP_ERROR4

FIND_VALID6:
	mov	cx,NUM_CP		;  Number of valid codes
	mov	di,OFFSET FILE_BUFFER	;  Point to correct word in table

F_SCAN_CP_TABLE:			; FOR code page parm
	mov	ax,FIND_CP_PARM		;	Get parameter
	cmp	[di].KC_CODE_PAGE,ax	;	Valid Code ??
	je	F_CODE_PAGE_FOUND	; If not found AND more entries THEN
	add	di,LANG_PTR_SIZE	;	Check next entry
	loop	F_SCAN_CP_TABLE		;    Decrement count & loop


	jmp	short FIND_CP_ERROR2	;  Display error message

F_CODE_PAGE_FOUND:
	mov	ax,word ptr [di].KC_ENTRY_PTR
	mov	word ptr CP_TAB_OFFSET,ax
	mov	ax,word ptr [di].KC_ENTRY_PTR+2
	mov	word ptr CP_TAB_OFFSET+2,ax

	xor	cx,cx
	ret

FIND_CP_ERROR1:
	mov	cx,1
	ret

FIND_CP_ERROR2:
	mov	cx,2
	ret

FIND_CP_ERROR3:
	mov	cx,3
	ret

FIND_CP_ERROR4:
	mov	cx,4
	ret

FIND_CP_TABLE	 ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE	ENDS
	END	TABLE_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\keybtbbl.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1990
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;;
;; File Name:  KEYBTBBL.INC
;; ----------
;;
;; Description:
;; ------------
;;	 Include file containing structure definitions Shared Data Area
;;	 for the Shared Data Area.
;;	 The Shared Data Area contains data which is required by
;;	 both the resident and transient KEYB code.  The Shared
;;	 Data Area is allocated in the KEYBI2F file and will be
;;	 resident following initial installation.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					       ;;
	EXTRN	 TABLE_BUILD   :NEAR	       ;;
	EXTRN	 FIND_CP_TABLE :NEAR	       ;;
					       ;;
	EXTRN	 CPN_INVALID   :WORD	       ;;
	EXTRN	 SD_LENGTH     :WORD	       ;;
					       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\keyb\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

keyb.skl : ..\usa\keyb.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\loadfix.asm ===
FindStruc	struc

	db	21 dup (?)		;reserved area
Attr	db	?			;attribute of file
Time	dw	?			;time of last write
Date	dw	?			;date of last write
Fsize	dd	?			;filesize
Fname	db	13 dup (?)		;filename

FindStruc	ends

CMDSIZE		equ	94h		;current resident size of
					;command.com is 94h paras

code	segment byte public 'CODE'
	assume	cs:code, ds:code, es:code

	org	100h
public	start
start:
	mov	sp,offset MyStack		;set ss:sp to our stack

	mov	ax,offset EndProg
	add	ax,15
	mov	cl,4
	shr	ax,cl			;para size of this program
	mov	bx,ax			;bx = this program's size
	mov	cx,es
	add	ax,cx			;ax = top of this program
	sub	ax,1000h - CMDSIZE		;are we below the first 64K?
	jae	no_mem			;no, dont reserve memory
	neg	ax			;additional memory to be reserved
	add	bx,ax
no_mem:					;bx = #paras needed
	mov	ah,4ah
	int	21h			;resize to desired size
;
;Prepare to execute the desired program
;
	call	Exec_prepare
	jnc	do_exec

	mov	al,1	   		;return error
	jmp	short exit
do_exec:
	cmp	helpflg,1
	je 	do_help
	mov	ah,4bh
	mov	dx,offset ExecPath
	mov	bx,offset ExecBlk
	int	21h			;do the Exec
	jc	exec_err		;error while executing
;
;No error on execution. Get the return code of the program we executed and
;return that as our return code.
;
	mov	ah,4dh
	int	21h			;al = return code now
exit:
	mov	ah,4ch
	int	21h			;terminate ourselves
exec_err:
	mov	dx,offset ErrMsg		;Error executing command.com
ifdef BILINGUAL
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset ErrMsg2
@@:
endif
	mov	al,1
	call	dispmsg
	jmp	short	exit
do_help:
	mov	dx,offset HelpMsg		;Display help for loadfix
ifdef BILINGUAL
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset HelpMsg2
@@:
endif
	call	dispmsg
	xor	al,al
	jmp	short exit

;***
;Dispmsg -- Displays messages that are terminated by '$'
;
;Input:	ds:dx = pointer to message
;
;Output: None
;
;Registers: ax
;***

dispmsg	proc	near

	mov	ah,9
	int	21h
	ret

dispmsg	endp

;***
;Exec_prepare -- Searches the environment for the COMSPEC and sets up the
;command line and FCBs for the Exec call
;
;Input:	None
;
;Output: Carry set => error. Error message is displayed here
;	Carry clear => all parameters set successfully
;
;Registers: ax, cx, dx, si, di
;***

Exec_prepare	proc	near

	push	ds
	push	es

	mov	si,81h			;ds:si points at our command line
	call	skip_white		;skip all leading whitespace

	cmp	byte ptr [si],0dh		;Did we hit a CR?
	je	no_parms		;yes, no parameters given
;
;Check if we have a /? here
;
	cmp	byte ptr [si],'/'
	jne	no_help
	cmp	byte ptr [si+1],'?'
	jne	no_help

	inc	helpflg   		;/? given -- print help
	jmp	short exefnd

no_help:
	mov	dx,si			;ds:dx now points at the program

	mov	si,offset CmdOpt
	mov	di,offset CmdParms
	inc	di
	mov	cl,CmdOptLen
	xor	ch,ch
	rep	movsb

	mov	si,dx
	xor	cx,cx
st_lp:
	lodsb
	stosb
	inc	cx
	cmp	al,0dh
	jne	st_lp

	dec	cx
	add	cl,CmdOptLen		;command line cannot be >128
	mov	CmdParms,cl

	mov	si,offset CmdParms

	mov	word ptr CmdPtr,si
	mov	word ptr CmdPtr+2,cs		;store command line pointer

	mov	word ptr Fcb1+2,cs
	mov	word ptr Fcb2+2,cs

	call	find_comspec
	jc	no_comspec

	mov	si,offset ExecPath
	xchg 	si,di
	push	ds
	push	es
	pop	ds
	pop	es
comspec_lp:
	lodsb
	stosb
	or	al,al
	jnz	comspec_lp

exefnd:
	clc
execp_ret:
	pop	es
	pop	ds
	ret
no_parms:
	mov	dx,offset NoParms
ifdef BILINGUAL
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset NoParms2
@@:
endif
	call	dispmsg
	stc
	jmp	short execp_ret
no_comspec:
	mov	dx,offset NoComspec
ifdef BILINGUAL
	call	IsDBCSCodePage
	jz	@f
	mov	dx,offset NoComspec2
@@:
endif
	call	dispmsg
	stc
	jmp	short execp_ret

Exec_prepare	endp

;***
;skip_white -- Skips all whitespace characters until it hits a non-whitespace
;
;Input: ds:si = string to be looked at
;
;Output: ds:si points at the first non-whitespace char in the string
;
;Registers: ax, si
;***

skip_white	proc	near
	
	lodsb
	cmp	al,20h			;Blank?
	je	skip_white		;yes, skip
	cmp	al,9			;Tab?
	je	skip_white		;yes, skip

	dec	si			;point at the first non-white

	ret

skip_white	endp

;***
;find_comspec -- searches in the environment for the COMSPEC variable
;
;Input: None
;
;Output: es:di points at the arguments of the COMSPEC= variable
;
;Registers: si
;***

find_comspec	proc	near

	mov	si,offset Comspec_Text

;
; input: ds:si points to a "=" terminated string
; output: es:di points to the arguments in the environment
;	  zero is set if name not found
;	  carry flag is set if name not valid format
;
	call	find				; find the name
	jc	done_findp			; carry means not found
	call	scasb1				; scan for = sign
done_findp:
	ret

find_comspec	endp

;***
;find -- scans the environment for the variable whose name is passed in
;
;Input: ds:si points at the environment variable to be scanned for
;
;Output: es:di points at the environment variable
;
;Registers: ax, di
;***

find	proc	near

	cld
	call	count0				; cx = length of name
	mov	es,es:[2ch]			; get environment segment
;
;Bugbug: What if the environment segment here is 0?
;
	xor	di,di

find1:
	push	cx
	push	si
	push	di

find11:
	lodsb
	inc	di
	cmp	al,es:[di-1]
	jnz	find12
	loop	find11

find12:
	pop	di
	pop	si
	pop	cx
	jz	end_find
	push	cx
	call	scasb2				; scan for a nul
	pop	cx
	cmp	byte ptr es:[di],0
	jnz	find1
	stc					; indicate not found
end_find:
	ret

find	endp

;***
;count0 -- returns length of string until the first '=' char
;
;Input: ds:si points at the string
;
;Output: cx = length until '='
;
;Registers: di
;***

count0	proc	near

	mov	di,si				;ds = es = cs

	push	di				; count number of chars until "="
	call	scasb1
	pop	cx
	sub	di,cx
	xchg	di,cx
	ret

count0	endp

;***
;scasb1 -- scans string for the first '='
;scasb2 -- scans string for the first null
;
;Input: es:di = string
;
;Output: es:di points after the desired char
;
;Registers: ax, cx
;***

scasb1	proc	near

	mov	al,'='                          ; scan for an =
	jmp	short scasbx
scasb2:
	xor	al,al				; scan for a nul
scasbx:
	mov	cx,100h
	repnz	scasb
	ret

scasb1	endp


ifdef BILINGUAL
IsDBCSCodePage	proc	near
	push	ax
	push	bx

	mov	ax,4f01h		; get code page
	xor	bx,bx
	int	2fh

ifdef JAPAN
	cmp	bx,932
endif
ifdef KOREA
	cmp	bx,949
endif
ifdef TAIWAN
	cmp	bx,950
endif
ifdef PRC
	cmp	bx,936
endif

	pop	bx
	pop	ax
	ret
IsDBCSCodePage	endp
endif


;**************************
;Data
;**************************

ExecBlk	label	word
	dw	0
CmdPtr	dd	?
Fcb1	dw	offset MyFcb1
	dw	?
Fcb2	dw	offset MyFcb2
	dw	?

	dw	128 dup (1)
MyStack	label	word

CmdOpt	db	'/C '
CmdOptLen 	db	$ - CmdOpt

CmdParms	db	128 dup (?)		;buffer to hold prog to be Exec'ed

ExecPath	db	67 dup (?)		;holds path to COMMAND.COM

ComSpec_Text	db	'COMSPEC=',0

MyFcb1	db	0
	db	11 dup (' ')

MyFcb2	db	0
	db	11 dup (' ')

Helpflg	db	0			;default is no help

include	loadmsg.msg

EndProg	label	byte

code	ends
	end	start



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\loadfix\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\chkvdisk.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
; Check for existence of a VDisk header.  Check the beginning of the segment
; addressed by the INT 19 vector, and, if XMS is available to give us
; A20 toggling, check at the 1Mb boundary.  We don't do the latter check
; if we can't do the A20 switch.
;
; Return the size of the VDisk if found.
;

; Checking for a VDISK header at 1Mb is currently disabled.  This is because
; the XMS calls used to access the HMA will cause INT 15 memory to
; be claimed if there are currently no Himem or XMS users, and the MEM
; command shouldn't disturb the memory environment in that way.
; We rely on VDisk allocators to use the INT 19 approach to signal
; their memory usage.  According to Ray Duncan, this may not be
; entirely reliable, but this is probably better than adding the
; code necessary to do lots of INT 15 block moves to interrogate
; the extended memory arena.

CHECKXMS	equ	0		; set to non-zero to enable checking
					; of the HMA for VDisk headers.

.MODEL	SMALL
.CODE

	extrn	_XMM_Installed	:Near
	extrn	_XMM_QueryA20	:Near
	extrn	_XMM_EnableA20	:Near
	extrn	_XMM_DisableA20 :Near

;----------------------------------------------------------------------------
;
; following piece of code will be moved into a para boundary. And the para
; address posted in seg of int 19h vector. Offset of int 19h will point to
; VDint19. This is to protect HMA from apps which use VDISK header method
; to determine free extended memory.
;
; For more details read "power programming" column by Ray Duncan in the
; May 30 1989 issue of PC Magazine (pp 377-388) [USING EXTENDED MEMORY,PART 1]
;
;----------------------------------------------------------------------------
;
StartVDHead	label	byte
;
;-------------- what follows is a dummy device driver header (not used by DOS)
;
		dd	0		; link to next device driver
		dw	8000h		; device attribute
		dw	0		; strategy routine offset
		dw	0		; interrupt routine offset
		db	1		; number of units
		db	7 dup(0)	; reserved area
VDiskSig1	db	'VDISK'

VLEN1		equ	($-offset VDiskSig1)

		db	'  V3.3'	; vdisk label
		db	15 dup (0)	; pad
VDiskEnd1	dw	0		; bits 0-15 of free HMA
		db	11h		; bits 16-23 of free HMA (1M + 64K)

VDInt19:
		db	0eah		; jmp to old vector
OldVDInt19	dd	?		; Saved int 19 vector

EndVDHead	label	byte
;
;
VDiskHMAHead	db	0,0,0		; non-bootable disk
VDiskSig2	db	'VDISK'

VLEN2		equ	($-offset VDiskSig2)

		db	'3.3'		; OEM - signature
		dw	128		; number of bytes/sector
		db	1		; sectors/cluster
		dw	1		; reserved sectors
		db	1		; number of FAT copies
		dw	64		; number of root dir entries
		dw	512		; number of sectors
		db	0feh		; media descriptor
		dw	6		; number of sectors/FAT
		dw	8		; sectors per track
		dw	1		; number of heads
		dw	0		; number of hodden sectors
VDiskEnd2	dw	440h		; Start of free HMA in K (1M+64K)
EndVDiskHMAHead	label	byte
;
;
;----------------------------------------------------------------------------
;
; procedure : IsVDiskInstalled
;
;		Checks for the presence of VDISK header at 1MB boundary
;		& INT 19 vector.  Returns number of Kb used as Vdisk
;
; Inputs  : none
; Outputs : AX = size of VDisk in Kb, 0 if none found
; Uses	  : AX, CX
;
;----------------------------------------------------------------------------
;
		public _CheckVDisk

_CheckVDisk	proc   near
		push	bp
		push	si		; Save regs
		push	di
		push	es
		push	ds

		mov	ax,3519h	; Get Int Vector 19h
		int	21h
					; set registers for CMPS
		mov	di, offset VDiskSig1 - offset StartVDHead
		mov	cx, VLEN1
		push	cs
		pop	ds
		mov	si, offset VDiskSig1
		rep	cmpsb
IF NOT CHECKXMS
		jnz	cvd_NoDisk
ELSE
		jnz	cvd_checkXMS	; jump if we didn't find it
ENDIF

;
; Get the first free address in Kb, and determine the number of Kb used
; above 1Mb.  First free address in a 24-bit address, so divide by 1024
; to get number of Kb
;
		mov	di,offset VDiskEnd1 - offset StartVDHead
		mov	ax,es:[di]+1	; load top 16 bits of end address
		shr	ax,1
		shr	ax,1		; fast divide of 24 bits by 1024
		test	es:[di],03FFh	; check for rounding
		jz	@F
		inc	ax		; round up if needed
@@:
IF NOT CHECKXMS
		jmp	short cvd_End

ELSE
		pop	ds		; clear top of stack
		jmp	short cvd_End	; AX now has size in Kb


;
; Ensure that A20 is on before we check above 1Mb.  If XMS is not
; installed, we punt, and assume no VDisk
;

cvd_checkXMS:
		pop	ds		; get DS again
		call	_XMM_Installed
		or	ax,ax
		jz	cvd_NoDisk	; No XMS, assume no VDisk

;
; Get and save current A20 state, get A20 on
;
		call	_XMM_QueryA20
		push	ax		; save current state
		or	ax,ax		; already on?
		jnz	cvd_A20On	; yes, don't turn it on
		call	_XMM_EnableA20	; turn it on

cvd_A20On:
		push	ds		; save DS again
		mov	ax, 0ffffh
		mov	ds, ax
		mov	si, 10h+(offset VDiskSig2 - offset VDiskHMAHead)
		mov	ax,cs
		mov	es,ax
		mov	di, offset VDiskSig2
		mov	cx, VLEN2
		rep	cmpsb
		jne	@F		; if no header, turn off A20 now
					; get first free address in Kb
		mov	si,offset VDiskEnd2 - offset VDiskHMAHead
		mov	ax,[si]
@@:
		pop	ds		; get original DS again
		pop	ax		; get original A20 state
		pushf			; save result of header check
		or	ax,ax		; was A20 already on?
		jnz	@F		; jump if yes
		call	_XMM_DisableA20 ; else turn it off again

@@:
		popf			; get result of header check
		je	cvd_End 	; jump if present

ENDIF		; CHECKXMS

cvd_NoDisk:
		mov	ax,1024 	; set up to return 0

cvd_End:
		sub	ax,1024 	; discount first 1Mb from first
					; free address to get size in Kb
IF NOT CHECKXMS
		pop	ds
ENDIF
		pop	es
		pop	di
		pop	si
		pop	bp
		ret
_CheckVDisk endp

		end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\membase.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/* MEMBASE.C - MEM routines for determining and displaying memory usage
*  for conventional memory.
*/

#include "stdio.h"
#include "dos.h"
#include "string.h"
#include "stdlib.h"
#include "msgdef.h"
#include "version.h"
#include "mem.h"

/**/

/* go through the arena and print out the program name,size etc for /P switch */
/* but just keep storing them in a datastruct for later disp. for /C switch   */

unsigned int	DisplayBaseDetail()
{

	struct	 ARENA far *ThisArenaPtr;
	struct	 ARENA far *NextArenaPtr;
	struct	 ARENA far *ThisConfigArenaPtr;
	struct	 ARENA far *NextConfigArenaPtr;

	struct	 DEVICEHEADER far *ThisDeviceDriver;

	int	 SystemDataType;
	char	 SystemDataOwner[64];
	unsigned int far *UMB_Head_ptr;

	unsigned int long	Out_Var1;
	unsigned int long	Out_Var2;
	char			Out_Str1[64];
	char			Out_Str2[64];
	unsigned int msgno;

	InRegs.h.ah = (unsigned char) 0x52;
	intdosx(&InRegs,&OutRegs,&SegRegs);

	FP_SEG(SysVarsPtr) = FP_SEG(UMB_Head_ptr) = SegRegs.es;
	FP_OFF(SysVarsPtr) = OutRegs.x.bx;

	FP_OFF(UMB_Head_ptr) = 0x8c; /* ptr to UMB_HEAD in DOS Data */
	UMB_Head = *UMB_Head_ptr;

	if (!Classify)
	    Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
	if (DataLevel > 0)
	{
		if (!Classify) {
			Sub0_Message(Title1Msg,STDOUT,Utility_Msg_Class);
			Sub0_Message(Title2Msg,STDOUT,Utility_Msg_Class);
		}
	}

	InRegs.h.ah = (unsigned char) 0x30;
	intdos(&InRegs, &OutRegs);

	if ( (OutRegs.h.al != (unsigned char) 3) || (OutRegs.h.ah < (unsigned char) 40) )
		UseArgvZero = TRUE;
	   else UseArgvZero = FALSE;

	/* Display stuff below DOS  */
	Out_Var1 = 0l;
	Out_Var2 = 0x400l;
	if (Classify)				/* M003 */
		/* classify this memory also as part of DOS */
	    { if (AddMem_to_PSP(8,Out_Var1,Out_Var2)) return(1); }
	else
	    Sub4_Message(MainLineMsg,
		     STDOUT,
		     Utility_Msg_Class,
		     &Out_Var1,
		     BlankMsg,
		     &Out_Var2,
		     InterruptVectorMsg);

	Out_Var1 = 0x400l;
	Out_Var2 = 0x100l;
	if (Classify)
		/* classify this memory also as part of DOS */
	    { if (AddMem_to_PSP(8,Out_Var1,Out_Var2)) return(1); }
	else
	    Sub4_Message(MainLineMsg,
		     STDOUT,
		     Utility_Msg_Class,
		     &Out_Var1,
		     BlankMsg,
		     &Out_Var2,
		     ROMCommunicationAreaMsg);

	Out_Var1 = 0x500l;
	Out_Var2 = 0x200l;
	if (Classify)
		/* classify this memory also as part of DOS */
	    {	if (AddMem_to_PSP(8,Out_Var1,Out_Var2)) return(1); }
	else
	    Sub4_Message(MainLineMsg,
		     STDOUT,
		     Utility_Msg_Class,
		     &Out_Var1,
		     BlankMsg,
		     &Out_Var2,
		     DOSCommunicationAreaMsg);

	/* Display the DOS data */

	/* Display the BIO data location and size */

	if (!Classify)
		Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);


	Out_Var1 = 0x700l;
	Out_Var2 = (long) (FP_SEG(SysVarsPtr) - 0x70)*16l;
	if (Classify)
		/* classify this memory also as part of DOS */
	    {	if (AddMem_to_PSP(8,Out_Var1,Out_Var2)) return(1); }
	else
	    Sub4_Message(MainLineMsg,
		     STDOUT,
		     Utility_Msg_Class,
		     &Out_Var1,
		     IbmbioMsg,
		     &Out_Var2,
		     SystemDataMsg);

	/* Display the Base Device Driver Locations and Sizes */

	/*********************************************************************/
        /* to do this get the starting address of the internal driver header */
        /* chain. Start from the first header and get the address of the     */
        /* first header.  Display the driver name and address by calling     */
        /* "DISPLAYDEVICEDRIVER".  Repeat this for next driver on the chain  */
        /* until the last driver.  Note that driver name is in the header.   */
        /* The driver header addrs is in the system variable table from      */
        /* INT 21H fun 52H call.                                             */
	/*********************************************************************/

	BlockDeviceNumber = 0;

	for (ThisDeviceDriver = SysVarsPtr -> DeviceDriverChain;
	      (FP_OFF(ThisDeviceDriver) != 0xFFFF);
	       ThisDeviceDriver = ThisDeviceDriver -> NextDeviceHeader)
	      { if ( FP_SEG(ThisDeviceDriver) < FP_SEG(SysVarsPtr) )
			DisplayDeviceDriver(ThisDeviceDriver,SystemDeviceDriverMsg);
		}

	/* Display the DOS data location and size */

        FP_SEG(ArenaHeadPtr) = FP_SEG(SysVarsPtr);                                                                               /* ;an004; */
        FP_OFF(ArenaHeadPtr) = FP_OFF(SysVarsPtr) - 2;                                                                           /* ;an004; */
                                                                                                                                 /* ;an004; */
        FP_SEG(ThisArenaPtr) = *ArenaHeadPtr;                                                                                    /* ;an004; */
        FP_OFF(ThisArenaPtr) = 0;                                                                                                /* ;an004; */
	if (!Classify)
	    Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);

	Out_Var1 = (long) FP_SEG(SysVarsPtr) * 16l;
        Out_Var2 = (long) ((AddressOf((char far *)ThisArenaPtr)) - Out_Var1);                                                    /* ;ac004; */
	if (Classify)
		/* classify this memory also as part of DOS */
	    {	if (AddMem_to_PSP(8,Out_Var1,Out_Var2)) return(1); }
	else
	    Sub4_Message(MainLineMsg,
		     STDOUT,
		     Utility_Msg_Class,
		     &Out_Var1,
		     IbmdosMsg,
		     &Out_Var2,
		     SystemDataMsg);

	if (!Classify)
	   Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);

	/* Display the memory data */

/* IO.SYS data area contains BUFFERS, FCBs, LAST DRIVE etc.  They are contained 	       */
/* in a one huge memory block.  This block has a seg iD 0008.  This seg ID can                 */
/* be found from the block header owner area.  This seg id 0008:0000                           */
/* points to the buffer table as shown below.  If seg id is 0008:000, then                     */
/* using the seg id find the table.  Each entry is contained in a sub block                    */
/* within the main block.  Each sub block has header and this header contains                  */
/* id such as B for BUFFER,  X for FCBs,  I for IFS,  D for external device                    */
/* drivers.  Go through the sub blocks and display the name ans size. that's all.              */
/*                                                                                             */
/* If the block contains D, then it contains external drivers.  The driver name                */
/* is not in the sub block.  So we have to find the driver name from the driver                */
/* header chain.  To do this get the address of the driver chain from syster                   */
/* variable table from INT 21H FN 52H call.  Go through the chain and findout                  */
/* the name.  Display name from the header and the size we got from the sub block.             */
/*                                                                                             */
/*                                                                                             */
/* After this main block, comes other buffer blocks which contains programs                    */
/* such as command.com, doscolor, even MEM.  From these blocks, get the program                */
/* name and the size and display them too.                                                     */
/*                                                                                             */
/* 0008:000->------------------          -------------------                                   */
/*           | BUFFERS        | -------->|B (signature)    | Block header                      */
/*           ------------------          -------------------                                   */
/*           | FCBs           | --       |                 |                                   */
/*           ------------------   |      | Buffers data    |                                   */
/*           | IFSs           |   |      |                 |                                   */
/*           ------------------   |      |                 |                                   */
/*           | LAST DRIVE     |   |      |                 |                                   */
/*           ------------------   |      --------------------                                  */
/*           | EXTERN DRIVER 1|   |                                                            */
/*           ------------------   |          -------------------                               */
/*           | EXTERN DRIVER 2|   | -------->|X (signature)    | Block header                  */
/*           ------------------              -------------------                               */
/*           | EXTERN DRIVER 3|              |                 |                               */
/*           ------------------              | Buffers data    |                               */
/*                                           |                 |                               */
/*                                           |                 |                               */
/*                                           |                 |                               */
/*                                           --------------------                              */
/*                                                                                             */
/* For DOS 5.0, there are some additions to the above.	Basically, we have
/* three possible memory maps, to wit:
/*
/*    DOS Loads Low			     DOS loads high
/*    70:0 - BIOS data			     70:0 - BIOS data
/*	     DOS data				    DOS data
/*	     BIOS + DOS code			    Sysinit data (arena name SD)
/*	       (arena owner 8, name "SC")	    VDisk header (arena name SC)
/*	     Sysinit data (arean owner 8, name SD)
/*
/*    DOS tries to load high but fails
/*    70:0 - BIOS data
/*	     DOS data
/*	     Sysinit data (arena name SD)
/*	     DOS + BIOS code (arena name SC)
/*
/*    We have to detect the special arena ownership marks and display them
/*    correctly.  Everything after DOS and BIOS data should have an arena header
/******************************************************************************/

	while (ThisArenaPtr -> Signature != (char) 'Z')
	      {
																 /* MSKK02  */
#ifdef JAPAN
		if (ThisArenaPtr -> Owner == 8 || ThisArenaPtr -> Owner == 9 )
#else
		if (ThisArenaPtr -> Owner == 8)
#endif
		      {
			FP_SEG(NextArenaPtr) = FP_SEG(ThisArenaPtr) + ThisArenaPtr -> Paragraphs + 1;
			FP_OFF(NextArenaPtr) = 0;

			Out_Var1 = AddressOf((char far *)ThisArenaPtr);
			Out_Var2 = (long) (ThisArenaPtr -> Paragraphs) * 16l;
			if (ThisArenaPtr->OwnerName[0] == 'S' &&
			    ThisArenaPtr->OwnerName[1] == 'C')
			{      /* display message for BIOS and DOS code */
			   if (Classify)
		 	   /* classify this memory also as part of DOS */
				{ if (AddMem_to_PSP(8,Out_Var1,Out_Var2)) return(1); }
			   else {
				msgno = (FP_SEG(ThisArenaPtr) < UMB_Head) ? IbmdosMsg:SystemMsg;
				Sub4_Message(MainLineMsg,
					     STDOUT,
					     Utility_Msg_Class,
					     &Out_Var1,
					     msgno,
					     &Out_Var2,
					     SystemProgramMsg);
				Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
			    }
			}
			else /* display message for data */
			{
			if (!Classify)
			    Sub4_Message(MainLineMsg,
				     STDOUT,
				     Utility_Msg_Class,
				     &Out_Var1,
#ifdef JAPAN
				     (ThisArenaPtr -> Owner == 8) ? IbmbioMsg : AdddrvMsg,
				     &Out_Var2,
				     (ThisArenaPtr -> Owner == 8) ? SystemDataMsg : ProgramMsg );
#else
				     IbmbioMsg,
				     &Out_Var2,
				     SystemDataMsg);
#endif

			FP_SEG(ThisConfigArenaPtr) = FP_SEG(ThisArenaPtr) + 1;
			FP_OFF(ThisConfigArenaPtr) = 0;


			while ( (FP_SEG(ThisConfigArenaPtr) > FP_SEG(ThisArenaPtr)) &&
				(FP_SEG(ThisConfigArenaPtr) < FP_SEG(NextArenaPtr))    )
			      {
				strcpy(SystemDataOwner," ");
				switch(ThisConfigArenaPtr -> Signature)
				      {
					case 'B':
						SystemDataType = ConfigBuffersMsg;
						if (AddMem_to_PSP(8,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;
					case 'D':
						SystemDataType = ConfigDeviceMsg;
						if (AddMem_to_PSP(ThisConfigArenaPtr->Owner,((long)FP_SEG(ThisConfigArenaPtr)*16l) ,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						strcpy(SystemDataOwner,OwnerOf(ThisConfigArenaPtr));
						break;
					case 'F':
						SystemDataType = ConfigFilesMsg;
						if (AddMem_to_PSP(8,((long)FP_SEG(ThisConfigArenaPtr) *16l),((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;
					case 'I':
						SystemDataType = ConfigIFSMsg;
						strcpy(SystemDataOwner,OwnerOf(ThisConfigArenaPtr));
						if (AddMem_to_PSP(ThisConfigArenaPtr->Owner,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;
					case 'L':
						SystemDataType = ConfigLastDriveMsg;
						if (AddMem_to_PSP(8,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;
					case 'S':
						SystemDataType = ConfigStacksMsg;
						if (AddMem_to_PSP(8,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;
					case 'T':					 /* gga */
						SystemDataType = ConfigInstallMsg;	 /* gga */
						if (AddMem_to_PSP(8,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;					 /* gga */
					case 'X':
						SystemDataType = ConfigFcbsMsg;
						if (AddMem_to_PSP(8,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
                                                break;

                                        // NTVDM for special kbd\mouse drivers
                                        case 'Q':
                                                SystemDataType = SystemProgramMsg;
                                                strcpy(SystemDataOwner,OwnerOf(ThisConfigArenaPtr));
                                                if (AddMem_to_PSP(ThisConfigArenaPtr->Owner,((long)FP_SEG(ThisConfigArenaPtr)*16l) ,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
                                                break;
#ifdef JAPAN
					case '?':
						SystemDataType = DataMsg;
						break;
#endif
                                        default:
						SystemDataType = BlankMsg;
						if (AddMem_to_PSP(8,((long)ThisConfigArenaPtr) <<4,((long)ThisConfigArenaPtr->Paragraphs <<4) +1)) return(1);
						break;
					}

          /****************************************************/
          /*  Found one, now display the owner name and size  */
          /****************************************************/

				Out_Var1 = ((long) ThisConfigArenaPtr -> Paragraphs) * 16l;
				if (!Classify)
				   Sub3_Message(DriverLineMsg,
					     STDOUT,
					     Utility_Msg_Class,
					     SystemDataOwner,
					     &Out_Var1,
					     SystemDataType );

				NextConfigArenaPtr = ThisConfigArenaPtr;
				FP_SEG(NextConfigArenaPtr) += NextConfigArenaPtr -> Paragraphs + 1;
				if (ThisConfigArenaPtr -> Signature == (char) 'D')
				      {

					FP_SEG(ThisDeviceDriver) = FP_SEG(ThisConfigArenaPtr) + 1;
					FP_OFF(ThisDeviceDriver) = 0;
/* start MSKK bug fix - MSKK01 */
					while ( (FP_SEG(ThisDeviceDriver) > FP_SEG(ThisConfigArenaPtr)) &&
						(FP_SEG(ThisDeviceDriver) < FP_SEG(NextConfigArenaPtr))    ) {
						DisplayDeviceDriver(ThisDeviceDriver,InstalledDeviceDriverMsg);
						ThisDeviceDriver = ThisDeviceDriver -> NextDeviceHeader;
					     }
/* end MSKK bug fix - MSKK01 */			
					}

				FP_SEG(ThisConfigArenaPtr) += ThisConfigArenaPtr -> Paragraphs + 1;

				}
			   }
			}
		 else {

/*******************************************************************************/
/* If not BIOS table, it is a program like MEM, etc.			       */
/* calculate the size of the block occupied by the program and display program */
/* name and size                                                               */
/*******************************************************************************/

		      Out_Var1 = AddressOf((char far *)ThisArenaPtr);
		      Out_Var2 = ((long) (ThisArenaPtr -> Paragraphs)) * 16l;
		      strcpy(Out_Str1,OwnerOf(ThisArenaPtr));
		      strcpy(Out_Str2,TypeOf(ThisArenaPtr));
		      if (Classify)
			{ if (AddMem_to_PSP(ThisArenaPtr->Owner,Out_Var1,Out_Var2)) return(1); }
		      else
		      	Sub4a_Message(MainLineMsg,
				   STDOUT,
				   Utility_Msg_Class,
				   &Out_Var1,
				   Out_Str1,
				   &Out_Var2,
				   Out_Str2);
			}

		FP_SEG(ThisArenaPtr) += ThisArenaPtr -> Paragraphs + 1;

		}
	Out_Var1 = AddressOf((char far *)ThisArenaPtr);
	Out_Var2 = ((long) (ThisArenaPtr -> Paragraphs)) * 16l;
	strcpy(Out_Str1,OwnerOf(ThisArenaPtr));
	strcpy(Out_Str2,TypeOf(ThisArenaPtr));
	if (Classify)
	    { if (AddMem_to_PSP(ThisArenaPtr->Owner,Out_Var1,Out_Var2)) return(1); }
	else
	   Sub4a_Message(MainLineMsg,
		     STDOUT,
		     Utility_Msg_Class,
		     &Out_Var1,
		     Out_Str1,
		     &Out_Var2,
		     Out_Str2);


	return(0); 			/* end of MEM main routine */

	}



/**/

void	 DisplayDeviceDriver(ThisDeviceDriver,DeviceDriverType)
struct	 DEVICEHEADER far *ThisDeviceDriver;
int	 DeviceDriverType;
{
	char	 LocalDeviceName[16];
	int	 i;

	if (DataLevel < 2) return;

	if ( ((ThisDeviceDriver -> Attributes) & 0x8000 ) != 0 )
	      { for (i = 0; i < 8; i++) LocalDeviceName[i] = ThisDeviceDriver -> Name[i];
		LocalDeviceName[8] = NUL;

		Sub2_Message(DeviceLineMsg,
			     STDOUT,
			     Utility_Msg_Class,
			     LocalDeviceName,
			     DeviceDriverType);

		}

	 else {
		if ((int) ThisDeviceDriver -> Name[0] == 1)
			sprintf(&LocalDeviceName[0],SingleDrive,'A'+BlockDeviceNumber);
		   else sprintf(&LocalDeviceName[0],MultipleDrives,
				'A'+BlockDeviceNumber,
				'A'+BlockDeviceNumber + ((int) ThisDeviceDriver -> Name[0]) - 1);

		Sub2_Message(DeviceLineMsg,
			     STDOUT,
			     Utility_Msg_Class,
			     LocalDeviceName,
			     DeviceDriverType);

		BlockDeviceNumber += (int) (ThisDeviceDriver -> Name[0]);

		}

	return;

	}


/**/

void DisplayBaseSummary()
	{

	struct	PSP_STRUC
		{
		unsigned int	int_20;
		unsigned int	top_of_memory;
		};

	char	 far *CarvedPtr;

	unsigned long int total_mem;		  /* total memory in system */
	unsigned long int avail_mem;		  /* avail memory in system */
	unsigned long int free_mem;		  /* free memory */
	unsigned long biggest_free;			/* largest free block now :M001 */
	struct	 PSP_STRUC far *PSPptr;

/* skip a line */
	Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);

/*  get PSP info */
	InRegs.h.ah = GET_PSP;			/* get PSP function call */
	intdos(&InRegs,&OutRegs);

	FP_SEG(PSPptr) = OutRegs.x.bx;		/* PSP segment */
	FP_OFF(PSPptr) = 0;			/* offset 0 */

/* Get total memory in system */
	int86(MEMORY_DET,&InRegs,&OutRegs);

/* Convert to bytes */
	total_mem = (unsigned long int) OutRegs.x.ax * 1024l;
        avail_mem = total_mem;

/* M004 BEGIN */
/* Adjust for XBDA size */
/* XBDA size should be added to total mem size reported by INT 12 */
/* IFF XBDA is placed just at the end of conv.mem */
/* IF EMM386 or QEMM is loaded, XBDA gets relocated to EMM driver mem */
/* and int 12 reports correct size of memory in this case */

	InRegs.x.bx = 0;
	InRegs.x.ax = 0xc100;
	int86x(0x15, &InRegs, &OutRegs, &SegRegs);
	if (OutRegs.x.cflag == 0)
	{
		if (total_mem == ((unsigned long)SegRegs.es) * 16ul) {
			FP_SEG(CarvedPtr) = SegRegs.es;
			FP_OFF(CarvedPtr) = 0;
			total_mem = total_mem + ( (unsigned long int) (*CarvedPtr) * 1024l) ;   /* ;an002; dms;adjust total for */
		}
        }	/* RAM carve value  */
/* M004 END */

	Sub1_Message(TotalMemoryMsg,STDOUT,Utility_Msg_Class,&total_mem);

	Sub1_Message(AvailableMemoryMsg,STDOUT,Utility_Msg_Class,&avail_mem);

/* Calculate the total memory used.   PSP segment * 16. Subtract from total to
   get free_mem */
	free_mem = (DOS_TopOfMemory * 16l) - (FP_SEG(PSPptr)*16l);								 /* ;an000;ac005; */

	/* Get largest free block in system :M001 */

	InRegs.x.ax = 0x4800;	/* M001 */
	InRegs.x.bx = 0xffff;	/* M001 */
	intdos(&InRegs, &OutRegs);	/* M001 */
	biggest_free = OutRegs.x.bx * 16L; /* Size of largest block now :M001 */

	/* The largest free block in the system is either the block we are
		currently in or the block we have allocated. We can either be the
		topmost program or be loaded in a hole or UMB. In either case, the
		larger of the 2 values gives us the largest free block :M001
	*/

	if ( biggest_free > free_mem )	/* M001 */
		free_mem = biggest_free;		/* M001 */

	Sub1_Message(FreeMemoryMsg,STDOUT,Utility_Msg_Class,&free_mem);

	return;

	}			/* end of display_low_total */


/**/


char *OwnerOf(ArenaPtr)
struct ARENA far *ArenaPtr;
{

	char	 far *StringPtr;
	char	     *o;
	unsigned far *EnvironmentSegmentPtr;
	unsigned     PspSegment;
	int	     i,fPrintable;

	o = &OwnerName[0];
	*o = NUL;
	sprintf(o,UnOwned);

	PspSegment = ArenaPtr -> Owner;


	if (PspSegment == 0) sprintf(o,Ibmdos);
	 else if (PspSegment == 8) sprintf(o,Ibmbio);
	  else {
		FP_SEG(ArenaPtr) = PspSegment-1;	/* -1 'cause Arena is 16 bytes before PSP */
		StringPtr = (char far *) &(ArenaPtr -> OwnerName[0]);
/* M002 BEGIN */
		fPrintable = TRUE;


/* Chars below 0x20 (Space) and char 0x7f are not printable in US and
 * European Code pages.  The following code checks for it and does not print
 * such names.  - Nagara 11/20/90
 */

		for (i = 0; i < 8;i++,StringPtr++) {
#ifdef DBCS
			if ( ((unsigned char)*StringPtr < 0x20) | ((unsigned char)*StringPtr == 0x7f) ) {
#else
			if ( (*StringPtr < 0x20) | (*StringPtr == 0x7f) ) {
#endif
					/* unprintable char ? */	
			   if (*StringPtr) fPrintable = FALSE;	
			   break;
			}
		    }

		if (fPrintable) {	/*  the name is printable */
			StringPtr = (char far *) &(ArenaPtr -> OwnerName[0]);
			for (i = 0; i < 8;i++)
				*o++ = *StringPtr++;
			*o = (char) '\0';
		    }
/* M002 END */
		}

	if (UseArgvZero) GetFromArgvZero(PspSegment,EnvironmentSegmentPtr);

	return(&OwnerName[0]);

	}


/**/

void	     GetFromArgvZero(PspSegment,EnvironmentSegmentPtr)
unsigned     PspSegment;
unsigned far *EnvironmentSegmentPtr;
{

	char	far *StringPtr;
	char	*OutputPtr;
	unsigned far *WordPtr;

	OutputPtr = &OwnerName[0];

	if (UseArgvZero)
	      {
		if (PspSegment < FP_SEG(ArenaHeadPtr))
		      {
			if (*OutputPtr == NUL) sprintf(OutputPtr,Ibmdos);
			}
		 else {
			FP_SEG(EnvironmentSegmentPtr) = PspSegment;
			FP_OFF(EnvironmentSegmentPtr) = 44;

/*			   FP_SEG(StringPtr) = *EnvironmentSegmentPtr;	*/
			FP_SEG(StringPtr) = FP_SEG(EnvironmentSegmentPtr);
			FP_OFF(StringPtr) = 0;

			while ( (*StringPtr != NUL) || (*(StringPtr+1) != NUL) ) StringPtr++;

			StringPtr += 2;
			WordPtr = (unsigned far *) StringPtr;

			if (*WordPtr == 1)
			      {
				StringPtr += 2;
				while (*StringPtr != NUL)
					*OutputPtr++ = *StringPtr++;
				*OutputPtr++ = NUL;

				while ( OutputPtr > &OwnerName[0] )
				      { if (*OutputPtr == (char) '.') *OutputPtr = NUL;
					if ( (*OutputPtr == (char) '\\') || (*OutputPtr == (char) ':') )
					      { OutputPtr++;
						break;
						}
					OutputPtr--;
					}

				}

			}
		}

	strcpy(&OwnerName[0],OutputPtr);

	return;

	}


/**/


char *TypeOf(Header)
struct ARENA far *Header;
{

	char	     *t;
	unsigned     PspSegment;
	unsigned far *EnvironmentSegmentPtr;
        unsigned int Message_Number;
        char far     *Message_Buf;
        unsigned int i;

	t = &TypeText[0];
	*t = NUL;

        Message_Number = 0xff;                                                  /* ;an000; initialize number value      */
	if (Header -> Owner == 8) Message_Number = StackMsg;
	if (Header -> Owner == 0) Message_Number = FreeMsg;

	PspSegment = Header -> Owner;
	if (PspSegment < FP_SEG(ArenaHeadPtr))
		{
                if (Message_Number == 0xff) Message_Number = BlankMsg;
		}
	else {
		FP_SEG(EnvironmentSegmentPtr) = PspSegment;
		FP_OFF(EnvironmentSegmentPtr) = 44;


                if (PspSegment == FP_SEG(Header)+1)
                        Message_Number = ProgramMsg;
                else if ( *EnvironmentSegmentPtr == FP_SEG(Header)+1 )
                        Message_Number = EnvironMsg;
                else
                        Message_Number = DataMsg;

                }

	InRegs.x.ax = Message_Number;
	InRegs.h.dh = Utility_Msg_Class;
	sysgetmsg(&InRegs,&SegRegs,&OutRegs);

	FP_OFF(Message_Buf)    = OutRegs.x.si;
	FP_SEG(Message_Buf)    = SegRegs.ds;

        i = 0;
        while ( *Message_Buf != (char) '\x0' )
                TypeText[i++] = *Message_Buf++;
        TypeText[i++] = '\x0';


	return(t);

	}
/* M003 BEGIN */
/*----------------------------------------------------------------------*/
/*  AddMem_to_PSP						        */
/*	Entry:	PSP_ADDR	(to which this mem. should be added)	*/
/*		ARENA_START_ADDR					*/
/*		Length_of_Arena						*/
/*	Exit:	mem_table updated.			      		*/
/*		returns 1 if more than MAX_CL_ENTRIES in mem_table	*/
/*		   else 0						*/
/*									*/
/* CAVEATS:						  		*/
/* --------								*/
/* 1. any system area (BIOS,SYSINIT,DOS ) code/data is listed as belonging */
/*    to PSP 8.							        */
/*									*/
/* 2. We look at the UMB_HEAD in DOS DATA to determine whether an arena */
/*    is in UMB or not; For the Arena at the UMB boundary, we add one   */
/*    para to conv. and remaining to UMB portion of that PSP	        */
/*									*/
/* 3. Any free memory is always added as a new entry in the mem_table   */
/*    instead of just adding the sizes to an existing FREE entry        */
/*    Free memory gets added to the previous free memory if they are    */
/*    contiguous							*/
/*									*/
/* 4. The no of programs/free arenas cannot exceed a max of (100)	*/
/*    (defined by MAX_CLDATA_INDEX )       				*/
/*    If the memory is fragmented and a lot of small TSRs loaded such   */
/*    that we exceed this limit, we TERMINATE				*/
/*									*/
/* 5. Mem occupied by this MEM are also reported as FREE mem		*/
/*									*/
/*----------------------------------------------------------------------*/

unsigned int AddMem_to_PSP(psp,start_addr,length)
unsigned int psp;
unsigned long start_addr,length;
{
	unsigned int para_no,len_in_paras,CurPSP;
	int i;
	extern unsigned int _psp;
	
	para_no = (unsigned int)(start_addr >> 4);	/* convert to paras*/
	len_in_paras = (unsigned int)(length >> 4);	/* convert to paras */

	CurPSP = psp;

	if (psp == _psp) psp = 0;	/* treat MEM's arenas as FREE */

	if (!psp) {
	   if (LastPSP == _psp) {	/* if the prev.arena was MEM */
		i = noof_progs -1;	/* look at the last entry */
		if (mem_table[i].psp_add != psp) /* was the last entry free ?*/
			i++;
		else len_in_paras++;	/* account for one free arena header */
	   }
	   else i = noof_progs; /* new entry for FREE mem */
	}
	else
	    for (i = 0;i < noof_progs;i++)
		if (mem_table[i].psp_add == psp) break;

	/* if psp is not already listed in the table, add it */
	if (i == noof_progs) {
		if (noof_progs == MAX_CLDATA_INDEX) {
			/* use parse error message proc to display err msg */
			Parse_Message(CMemFragMsg,STDERR,Utility_Msg_Class,(char far *) NULL);
			return(1);
		}
		mem_table[i].psp_add = psp;
		noof_progs++;
	}

	/* add the memory to the table entry */

	if (para_no < UMB_Head)
		mem_table[i].mem_conv += len_in_paras;
	else if (para_no == UMB_Head) {
		mem_table[i].mem_conv++;
		mem_table[i].mem_umb = len_in_paras-1;
	}
	else mem_table[i].mem_umb += len_in_paras;
	LastPSP = CurPSP;
	return(0);
}
		
/**/
/************************************************************************/
/* DisplayClassification						*/
/*	Main display proc for /C switch 				*/
/*									*/	
/* ENTRY:	none							*/
/*									*/	
/* EXIT:	none 							*/
/*									*/
/*	find out if UMB is available by going through mem_table entries */
/*	(also find out MEM's size from these entries)			*/
/*	display memory break up for conventional memory			*/
/*	if (UMB in system) display memmory break up for UMB memory	*/
/*	display the total free size (= total free in conv.+total_free   */
/*		in UMB + MEM's size )					*/
/*	call DispBigFree to display the largest prog. sizes in Conv.&UMB*/
/*									*/	
/************************************************************************/

#define CONVONLY 0
#define UMBONLY	1

void DisplayClassification()
{
	unsigned long tot_freemem=0L;
	char ShDSizeName[12];
	int i;
	unsigned int cur_psp;
	char fUMBAvail=0;


	/*  get PSP info */

	InRegs.h.ah = GET_PSP;			/* get PSP function call */
	intdos(&InRegs,&OutRegs);

	cur_psp = OutRegs.x.bx;			/* psp of MEM */

	for (i=0;i <noof_progs;i++) {
		if (mem_table[i].mem_umb)
			fUMBAvail = TRUE;
		if (mem_table[i].psp_add == cur_psp) {
		   tot_freemem += (long)(mem_table[i].mem_conv + mem_table[i].mem_umb);
		   if (fUMBAvail) break;
		}
	}
	tot_freemem *=16l;	/* convert to bytes */

	Sub0_Message(CTtlConvMsg,STDOUT,Utility_Msg_Class);
	Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
	tot_freemem += DispMemClass(CONVONLY);

	Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);

	if (fUMBAvail) {
		Sub0_Message(CTtlUMBMsg,STDOUT,Utility_Msg_Class);
		Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
		tot_freemem += DispMemClass(UMBONLY);

		Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
	}

	sprintf(ShDSizeName," (%5.1fK)",((float)tot_freemem)/1024l );
	i = (fUMBAvail) ? CSumm1Msg:CSumm1AMsg;
	SubC2_Message(i,STDOUT,&tot_freemem, ShDSizeName);

	DispBigFree(fUMBAvail,cur_psp);

}
/************************************************************************/
/* DispMemClass								*/
/*		(displays the progs and FREE sizes in either the   	*/
/*		conventional or UMB)					*/
/*									*/	
/* ENTRY:	memtype => Conventional(0) /UMB (1)			*/
/*									*/	
/* EXIT:	total_freemem_size (in bytes)				*/
/*									*/
/*	go through mem_table entries and display NON-ZERO size, NON-FREE */
/*		entries in the given mem_type				*/
/*	go through mem_table entries and display NON_ZERO size, FREE	*/
/*		entries in the given mem_type				*/
/*	calculate the total free mem size in the given mem type &return */
/*									*/
/* CAVEATS:								*/
/*	Arenas marked as belonging to MSDOS (code) in UMB are displayed */
/*	as SYSTEM							*/
/*									*/	
/************************************************************************/

unsigned long DispMemClass(memtype)
int memtype;
{
	int i,msgtype;
	unsigned int cur_memsize;
	unsigned long memsize;
	char *nameptr;
	char ShDSizeName[12];
	unsigned long tot_free = 0;
	struct ARENA far *ArenaPtr;

	Sub0_Message(CTtlNameMsg,STDOUT,Utility_Msg_Class);
	Sub0_Message(CTtlUScoreMsg,STDOUT,Utility_Msg_Class);

	for (i=0; i <noof_progs; i++) {

		cur_memsize = (memtype == CONVONLY) ? mem_table[i].mem_conv:mem_table[i].mem_umb;
		if (!cur_memsize) continue;
		if (!mem_table[i].psp_add) continue;
		msgtype = 0;
		if (mem_table[i].psp_add == 8) 	/* if DOS area */
			msgtype = (memtype == CONVONLY)?IbmdosMsg:SystemMsg;
		if (!msgtype) {
			FP_SEG(ArenaPtr) = mem_table[i].psp_add-1;	
				/* -1 'cause Arena is 16 bytes before PSP */
			FP_OFF(ArenaPtr) = 0;
			nameptr = OwnerOf(ArenaPtr);
		}
		else nameptr = NULL;

		memsize = ((long) cur_memsize) *16l;
		sprintf(ShDSizeName," (%5.1fK)",((float)memsize)/1024l );
		SubC4_Message(MainLineMsg,STDOUT,nameptr,msgtype,&memsize, ShDSizeName);
		
	}
	for (i=0; i <noof_progs; i++) {

		if (mem_table[i].psp_add) continue;
		cur_memsize = (memtype == CONVONLY) ? mem_table[i].mem_conv:mem_table[i].mem_umb;
		if (!cur_memsize) continue;
		tot_free += (long) cur_memsize;

		memsize = ((long) cur_memsize) *16l;
		sprintf(ShDSizeName," (%5.1fK)",((float)memsize)/1024l );
		SubC4_Message(MainLineMsg,STDOUT,NULL,CFreeMsg,&memsize, ShDSizeName);
		
	}

	tot_free *= 16l;
	sprintf(ShDSizeName," (%5.1fK)",((float)tot_free )/1024l );
	Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
	SubC2_Message(CTotalFreeMsg,STDOUT,&tot_free, ShDSizeName);

	return(tot_free);
		

}
/************************************************************************/
/* DispBigFree								*/
/* ENTRY:	UMBAvailable? (flag) 1-> there is UMB			*/
/*		MEM's PSP						*/
/* EXIT:	none (largest prog.sizes displayed)			*/
/*	This finds out and displays the largest contig.mem available in */
/*	in Conventional and UMB memory 					*/
/*	This calculation is done assuming that MEM is not loaded 	*/
/*									*/	
/************************************************************************/

void DispBigFree(fUMBAvail,cur_psp)
char fUMBAvail;
unsigned int cur_psp;
{

	int i;
	unsigned int ConvBigFree = 0;
	unsigned int UMBBigFree = 0;
	unsigned long TmpBigFree;
	char ShDSizeName[12];
	unsigned far *Env_ptr;
	unsigned int env_mem,BigFree;
	char fMEMHigh;
	

	/* assume that the biggest free size is the top of mem we got when */
	/* MEM was loaded */

	FP_SEG(Env_ptr) = cur_psp;
	FP_OFF(Env_ptr) = 44;	/* get the env for MEM */
	FP_SEG(Env_ptr) = (*Env_ptr)-1;	/* get to arena for env. */
	FP_OFF(Env_ptr) = 3;	/* get the size of environment */
	env_mem = *Env_ptr + 1; /* 1 extra para for arena header */

	fMEMHigh = (char)((cur_psp > UMB_Head) ? 1:0);

	BigFree = DOS_TopOfMemory  - cur_psp;

	if (fMEMHigh ) 	/* mem was loaded higher */
		UMBBigFree = BigFree;
	else
		ConvBigFree = BigFree;

	for (i =0; i<noof_progs;i++) {
		if (mem_table[i].psp_add) continue; /* skip non-FREE entries */
		if (mem_table[i].mem_conv > ConvBigFree)
			ConvBigFree = mem_table[i].mem_conv;
		if (mem_table[i].mem_umb > UMBBigFree)
			UMBBigFree = mem_table[i].mem_umb;
	}

	if (fMEMHigh) {	/* MEM was loaded high */
		if (FP_SEG(Env_ptr) > UMB_Head) /* env also in UMB */
			if (UMBBigFree == (BigFree + env_mem))
				UMBBigFree = BigFree;
	}
	else {		/* MEM was loaded low */
		if (FP_SEG(Env_ptr) < UMB_Head) /* env also in Conv */
			if (ConvBigFree == (BigFree + env_mem))
				ConvBigFree = BigFree;
	}


	TmpBigFree = ((unsigned long)ConvBigFree) * 16l;
	sprintf(ShDSizeName," (%5.1fK)",((float)TmpBigFree)/1024l );
	SubC2_Message(CSumm2Msg,STDOUT,&TmpBigFree, ShDSizeName);

	if (fUMBAvail) {
		TmpBigFree = ((unsigned long)UMBBigFree) * 16l;
		sprintf(ShDSizeName," (%5.1fK)",((float)TmpBigFree)/1024l );
		SubC2_Message(CSumm3Msg,STDOUT,&TmpBigFree, ShDSizeName);
	}

}
/* M003 END */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\parse.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/*  */
/*----------------------------------------------------------------------+
|									|
| This file contains the structures and defines that are needed to use	|
| the parser from a C program.						|
|									|
|									|
| Date: 	5-21-87 						|
|									|
+----------------------------------------------------------------------*/


#define p_len_parms		4		/* length of p_parms  */
#define p_i_use_default 	0		/* no extra stuff specified */
#define p_i_have_delim		1		/* extra delimiter specified  */
#define p_i_have_eol		2		/* extra EOL specified */

struct p_parms
	{
	struct p_parmsx *p_parmsx_address;	/* address of p_parmsx */
	unsigned char	p_num_extra;		/* number of extra stuff */
	unsigned char	p_len_extra_delim;	/* length of extra delimiter */
	char		p_extra_delim[30];	/* extra delimiters */
	};

struct p_parmsx
	{
	unsigned char	p_minp; 		/* Minimum positional number */
	unsigned char	p_maxp; 		/* Maximum positional number  */
	unsigned char	p_maxswitch;		/* Maximum switches	*/
	struct p_control_blk *p_control[4];	/* Address of the 1st CONTROL block */
	unsigned char	p_keyword;		/* Keyword count */
	};


struct p_control_blk
	{
	unsigned int	p_match_flag;		/* Controls type matched */
	unsigned int	p_function_flag;	/* Function should be taken */
	unsigned int	p_result_buf;		/* Result buffer address */
	unsigned int	p_value_list;		/* Value list address */
	unsigned char	p_nid;			/* # of keyword/SW synonyms */
	char		p_keyorsw[32];		/* keyword or sw */
	};

/* Match_Flags */

#define p_num_val		0x8000		/* Numeric Value */
#define p_snum_val		0x4000		/* Signed numeric value */
#define p_simple_s		0x2000		/* Simple string */
#define p_date_s		0x1000		/* Date string */
#define p_time_s		0x0800		/* Time string */
#define p_cmpx_s		0x0400		/* Complex string */
#define p_file_spc		0x0200		/* File Spec */
#define p_drv_only		0x0100		/* Drive Only */
#define p_qu_string		0x0080		/* Quoted string */
#define p_ig_colon		0x0010		/* Ignore colon at end in match */
#define p_repeat		0x0002		/* Repeat allowed */
#define p_optional		0x0001		/* Optional */
#define p_none			0x0000

/*----------------------------------------------------------------------+
|									|
|  Function flags							|
|									|
+----------------------------------------------------------------------*/

#define p_cap_file		0x0001		/* CAP result by file table */
#define p_cap_char		0x0002		/* CAP result by character table */
#define p_rm_colon		0x0010		/* Remove ":" at the end */



#define p_nval_none		0		/* no value list ID */
#define p_nval_range		1		/* range list ID */
#define p_nval_value		2		/* value list ID */
#define p_nval_string		3		/* string list ID */
#define p_len_range		9		/* Length of a range choice(two DD plus one DB) */
#define p_len_value		5		/* Length of a value choice(one DD plus one DB) */
#define p_len_string		3		/* Length of a string choice(one DW plus one DB) */

/*----------------------------------------------------------------------+
|									|
|  Value block structure						|
|									|
+----------------------------------------------------------------------*/

struct p_value_blk
	{
	unsigned char p_val_num;
	};


/*----------------------------------------------------------------------+
|									|
|  Result block structure						|
|									|
+----------------------------------------------------------------------*/

struct p_result_blk
	{
	unsigned char	P_Type; 		/* Type returned */
	unsigned char	P_Item_Tag;		/* Matched item tag */
	unsigned int	P_SYNONYM_Ptr;		/* pointer to Synonym list returned */
	unsigned long int p_result_buff;	/* result value */
	};

/*----------------------------------------------------------------------+
|									|
|  type 								|
|									|
+----------------------------------------------------------------------*/

#define p_eol			0		/* End of line */
#define p_number		1		/* Number */
#define p_list_idx		2		/* List Index */
#define p_string		3		/* String */
#define p_complex		4		/* Complex */
#define p_file_spec		5		/* File Spec */
#define p_drive 		6		/* Drive */
#define p_date_f		7		/* Date */
#define p_time_f		8		/* Time */
#define p_quoted_string 	9		/* Quoted String */

#define p_no_tag		0x0FF		/* No ITEM_TAG found */

/*----------------------------------------------------------------------+
|									|
|  following return code will be returned in the AX register.		|
|									|
+----------------------------------------------------------------------*/

#define p_no_error		0		/* No error */
#define p_too_many		1		/* Too many operands */
#define p_op_missing		2		/* Required operand missing */
#define p_not_in_sw		3		/* Not in switch list provided */
#define p_not_in_key		4		/* Not in keyword list provided */
#define p_out_of_range		6		/* Out of range specified */
#define p_not_in_val		7		/* Not in value list provided */
#define p_not_in_str		8		/* Not in string list provided */
#define p_syntax		9		/* Syntax error */
#define p_rc_eol		0x0ffff 	/* End of command line */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\mem.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
  /* MEM.H - general equates and externals for the MEM command.
  *  Extracted from the original MEM.C file.
  */

/* Structure definitions */

struct	DEVICEHEADER {
	struct DEVICEHEADER far *NextDeviceHeader;
	unsigned		Attributes;
	unsigned		Strategy;
	unsigned		Interrupt;
	char			Name[8];
	};


struct	SYSIVAR {
	char far *DpbChain;
	char far *SftChain;
	char far *Clock;
	char far *Con;
	unsigned  MaxSectorSize;
	char far *BufferChain;
	char far *CdsList;
	char far *FcbChain;
	unsigned  FcbKeepCount;
	unsigned char BlockDeviceCount;
	char	  CdsCount;
	struct DEVICEHEADER far *DeviceDriverChain;
	unsigned  NullDeviceAttributes;
	unsigned  NullDeviceStrategyEntryPoint;
	unsigned  NullDeviceInterruptEntryPoint;
	char	  NullDeviceName[8];
	char	  SpliceIndicator;
	unsigned  DosParagraphs;
	char far *DosServiceRntryPoint;
	char far *IfsChain;
	unsigned  BufferValues;
	unsigned  LastDriveValue;
	char	  BootDrive;
	char	  MoveType;
	unsigned  ExtendedMemory;
	};


struct	ARENA	 {
	char	 Signature;
	unsigned Owner;
	unsigned Paragraphs;
	char	 Dummy[3];
	char	 OwnerName[8];
	};

struct sublistx {
	 unsigned char size;	       /* sublist size			       */
	 unsigned char reserved;       /* reserved for future growth	       */
	 unsigned far *value;	       /* pointer to replaceable parm	       */
	 unsigned char id;	       /* type of replaceable parm	       */
	 unsigned char flags;	       /* how parm is to be displayed	       */
	 unsigned char max_width;      /* max width of replaceable field       */
	 unsigned char min_width;      /* min width of replaceable field       */
	 unsigned char pad_char;       /* pad character for replaceable field  */
	};

struct mem_classif {			/* M003 - struct for storing sizes */
	unsigned int psp_add;		/* 	acc. to PSPs 		  */
	unsigned int mem_conv;		/* conv.mem for PSP */
	unsigned int mem_umb;		/* umb mem for PSP */
};

/* miscellaneous defines */

#define DA_TYPE 	0x8000;
#define DA_IOCTL	0x4000;

#define a(fp)	((char) fp)

/* relevant DOS functions */

#define GET_VECT	0x35
#define GET_UMB_LINK_STATE 0x5802
#define SET_UMB_LINK_STATE 0x5803
#define LINK_UMBS	1
#define UNLINK_UMBS	0

#define EMS		0x67

#define CASSETTE	0x15		/* interrupt to get extended memory */

#define DOSEMSVER	0x40		/* EMS version */

#define EMSGetStat	0x4000		/* get stat */
#define EMSGetVer	0x4600		/* get version */
#define EMSGetFreePgs	0x4200		/* get free pages */

#define GetExtended	0x8800		/* get extended memory size */


/* defines used by total memory determination */
#define GET_PSP 	(unsigned char ) 0x62		 /* get PSP function call */

#define MEMORY_DET	0x12		/* BIOS interrupt used to get total memory size */

#define FALSE	 (char)(1==0)
#define TRUE	 !(FALSE)
#define CR	 '\x0d'
#define LF	 '\x0a'
#define NUL	 (char) '\0'
#define TAB	 '\x09'
#define BLANK	' '

#define	MAX_CLDATA_INDEX	100
	/* max index no for mem_table array */
	/* this is the max no of progs or free arenas that mem/c  can used */
	/* to process ; if the memory is fragmented and too many progs are */
	/* loaded such that this no exceeds 100, we terminate with errmsg */

/* external variables */

extern	      unsigned DOS_TopOfMemory; 	/* PSP Top of memory from 'C' init code  */					       /* ;an005; */
extern	      unsigned far	   *ArenaHeadPtr;
extern	      struct   SYSIVAR far *SysVarsPtr;

extern	      unsigned UMB_Head;
extern	      unsigned LastPSP;

extern	      char    OwnerName[128];
extern	      char    TypeText[128];
extern	      char    cmd_line[128];
extern	      char    far *cmdline;

extern	      char    UseArgvZero;
extern	      char    EMSInstalledFlag;

extern	      union    REGS    InRegs;
extern	      union    REGS    OutRegs;
extern	      struct   SREGS   SegRegs;

extern	      int      DataLevel;
extern	      int      Classify;
extern	      int      i;

extern	      int      BlockDeviceNumber;
extern	      char     *Parse_Ptr;						      /* ;an003; dms; pointer to command      */
extern	      struct mem_classif mem_table[MAX_CLDATA_INDEX];
extern		  int	   noof_progs;

extern	      struct sublistx sublist[5];

extern	      char    *SingleDrive;
extern	      char    *MultipleDrives;
extern	      char    *UnOwned;
extern	      char    *Ibmbio;
extern	      char    *Ibmdos;


/* function prototypes */

int	 main(void);
int      printf();
int      sprintf();
int      strcmp(const char *, const char *);
int	 sscanf();
void	 exit(int);
int	 kbhit();
char	 *OwnerOf(struct ARENA far *);
char	 *TypeOf(struct ARENA far *);
unsigned long AddressOf(char far *);
void	CSwitch_init(void);

char	 EMSInstalled(void);
void	 DisplayEMSSummary(void);
void	 DisplayEMSDetail(void);

void	 DisplayBaseSummary(void);
void	 DisplayExtendedSummary(void);
unsigned CheckDOSHigh(void);
unsigned CheckVDisk(void);

unsigned int DisplayBaseDetail(void);

void	DisplayClassification(void);		/* M003 */
unsigned long 	DispMemClass(int);		/* M003 */
void	DispBigFree(char,unsigned int);		/* M003 */

unsigned int AddMem_to_PSP(unsigned int,unsigned long,unsigned long);  /* M003 */

void	 GetFromArgvZero(unsigned,unsigned far *);

void	 DisplayDeviceDriver(struct   DEVICEHEADER far *,int);

void	 parse_init(void);

void	 Parse_Message(int,int,unsigned char,char far *);
void	 Sub0_Message(int,int,unsigned char);
void	 Sub1_Message(int,int,unsigned char,unsigned long int *);
void	 Sub2_Message(int,int,unsigned char,char *,int);
void	 Sub3_Message(int,int,unsigned char,
		      char *,
		      unsigned long int *,
		      int);

void	 Sub4_Message(int,int,unsigned char,
		      unsigned long int *,
		      int,
		      unsigned long int *,
		      int);

void	 Sub4a_Message(int,int,unsigned char,
		      unsigned long int *,
		      char *,
		      unsigned long int *,
		      char *);

void	EMSPrint(int,int,unsigned char,
		 int *,
		 char *,
		 unsigned long int *);

void SubC2_Message(int,int,unsigned long int*,char*);	/* M003 */

void	 SubC4_Message(int,int,char *,int,	/* M003 */
		      unsigned long int *,
		      char *);

extern void sysloadmsg(union REGS *, union REGS *);
extern void sysdispmsg(union REGS *, union REGS *);
extern void sysgetmsg(union REGS *, struct SREGS *, union REGS *);
extern void parse(union REGS *, union REGS *);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\msgdef.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/************************************************************************/
/* MSGDEF.H		- This include file defines each message type	*/
/*			  that can occur in MEM.  These defines will	*/
/*			  be used by MEM to build the proper message.	*/
/*									*/
/*	Date	: 10/29/87						*/
/************************************************************************/
#include "version.h"                                                    /*EGH*/

#define NewLineMsg			10
#define Title1Msg			11
#define Title2Msg			12
#define Title3Msg			13
#define Title4Msg			14
#define MainLineMsg			15
#define DriverLineMsg			16
#define DeviceLineMsg			17
#define TotalMemoryMsg			18
#define AvailableMemoryMsg		19
#define FreeMemoryMsg			20
#define EMSTotalMemoryMsg		21
#define EMSFreeMemoryMsg		22
#define EXTMemoryMsg			23
#define InterruptVectorMsg		24
#define ROMCommunicationAreaMsg 	25
#define DOSCommunicationAreaMsg 	26
#if IBMCOPYRIGHT                                                        /*EGH*/
#define IbmbioMsg                       56                              /*EGH*/
#define IbmdosMsg                       57                              /*EGH*/
#else                                                                   /*EGH*/
#define IbmbioMsg                       27
#define IbmdosMsg			28
#endif                                                                  /*EGH*/
#define SystemDataMsg			29
#define SystemProgramMsg		30
#define SystemDeviceDriverMsg		31
#define InstalledDeviceDriverMsg	32
#define SingleDriveMsg			33
#define MultipleDrivesMsg		34
#define ConfigBuffersMsg		35
#define ConfigFilesMsg			36
#define ConfigFcbsMsg			37
#define ConfigStacksMsg 		38
#define ConfigDeviceMsg 		39
#define ConfigIFSMsg			40
#define ConfigLastDriveMsg		41
#define ConfigInstallMsg		45	/* gga */
#define UnownedMsg			42
#define BlankMsg			43
#define HandleMsg			44
#define EXTMemAvlMsg			46	/* ;an001; dms;*/
#define StackMsg			47
#define FreeMsg 			48
#define ProgramMsg			49
#define EnvironMsg			50
#define DataMsg 			51
#define XMSMemAvlMsg			52
#define HMAAvlMsg			53
#define HMANotAvlMsg			54
#define HMADOSMsg			55
#define ROMDOSMsg			58
#define CTtlConvMsg			59
#define CTtlUMBMsg			60
#define CTotalFreeMsg			61
#define	CFreeMsg			62
#define CTtlNameMsg			63
#define CTtlUScoreMsg			64
#define CSumm1Msg			65
#define CSumm2Msg			66
#define CSumm3Msg			67
#define CMemFragMsg			68
#define SystemMsg			69
#define CSumm1AMsg			70

#define	MSG_OPTIONS_FIRST	300
#define	MSG_OPTIONS_LAST	304

#ifdef JAPAN
#define	AdddrvMsg			400
#endif

#define ParseError1Msg			01
#define ParseError10Msg 		10

/************************************************************************/
/*		Message Retriever Standard Equates			*/
/************************************************************************/

#define Ext_Err_Class			0x0001
#define Parse_Err_Class 		0x0002
#define Utility_Msg_Class		0x00ff
#define No_Handle			0xffff
#define No_Replace			0x0000
#define Sublist_Length			0x000b
#define Reserved			0x0000
#define Left_Align			0x0000
#define Right_Align			0x0080
#define Char_Field_Char 		0x0000
#define Char_Field_ASCIIZ		0x0010
#define Unsgn_Bin_Byte			0x0011
#define Unsgn_Bin_Word			0x0021
#define Unsgn_Bin_DWord 		0x0031
#define Sgn_Bin_Byte			0x0012
#define Sgn_Bin_Word			0x0022
#define Sgn_Bin_DWord			0x0032
#define Bin_Hex_Byte			0x0013
#define Bin_Hex_Word			0x0023
#define Bin_Hex_DWord			0x0033
#define No_Input			0x0000
#define STDIN				0x0000
#define STDOUT				0x0001
#define STDERR				0x0002
#define Blank				0x0020

#define SubCnt1 			0x0001
#define SubCnt2 			0x0002
#define SubCnt3 			0x0003
#define SubCnt4 			0x0004
#define SubCnt5 			0x0005

#define CarryFlag			0x0001

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\memex.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/* MEMEX.C - expanded and extended memory handling functions for MEM.C.
*/

#include "ctype.h"
#include "conio.h"			/* need for kbhit prototype */
#include "stdio.h"
#include "dos.h"
#include "string.h"
#include "stdlib.h"
#include "msgdef.h"
#include "version.h"			/* MSKK02 07/18/89 */
#include "mem.h"
#include "xmm.h"
#include "versionc.h"


/**/

void DisplayEMSDetail()
  {

#define EMSGetHandleName 0x5300 	/* get handle name function */
#define EMSGetHandlePages 0x4c00	/* get handle name function */
#define EMSCODE_83	0x83		/* handle not found error */
#define EMSMaxHandles	256		/* max number handles */

  int	HandleIndex;			/* used to step through handles */
  char	HandleName[9];			/* save area for handle name */
  unsigned long int HandleMem;		/* memory associated w/handle */
  char	TitlesPrinted = FALSE;		/* flag for printing titles */

  HandleName[0] = NUL;			/* initialize the array 	*/

  Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);

  segread(&SegRegs);

  SegRegs.es = SegRegs.ds;

  for (HandleIndex = 0; HandleIndex < EMSMaxHandles; HandleIndex++)
    {

    InRegs.x.ax = EMSGetHandleName;	/* get handle name */
    InRegs.x.dx = HandleIndex;		/* handle in question */
    InRegs.x.di = (unsigned int) HandleName;	/* point to handle name */
    int86x(EMS, &InRegs, &OutRegs, &SegRegs);

    HandleName[8] = NUL;		/* make sure terminated w/nul */

    if (OutRegs.h.ah != EMSCODE_83)
      {
      InRegs.x.ax = EMSGetHandlePages;	/* get pages assoc w/this handle */
      InRegs.x.dx = HandleIndex;
      int86x(EMS, &InRegs, &OutRegs, &SegRegs);
      HandleMem = OutRegs.x.bx;
      HandleMem *= (long) (16l*1024l);

      if (!TitlesPrinted)
	{
	Sub0_Message(Title3Msg,STDOUT,Utility_Msg_Class);
	Sub0_Message(Title4Msg,STDOUT,Utility_Msg_Class);
	TitlesPrinted = TRUE;
	}

      if (HandleName[0] == NUL) strcpy(HandleName,"        ");
      EMSPrint(HandleMsg,
	       STDOUT,
	       Utility_Msg_Class,
	       &HandleIndex,
	       HandleName,
	       &HandleMem);
      }

    }					/* end	 for (HandleIndex = 0; HandleIndex < EMSMaxHandles;HandleIndex++) */

  return;

  }					/* end of DisplayEMSDetail */



/**/

void DisplayExtendedSummary()
  {

  unsigned long int	  EXTMemoryTot;
  unsigned long int	  XMSMemoryTot;
  unsigned long int	  HMA_In_Use;
  unsigned		  DOS_Is_High,DOS_in_ROM;

  InRegs.h.ah = (unsigned char) 0x52;                                           /* Get SysVar Pointer   ;an001; dms;*/
  intdosx(&InRegs,&OutRegs,&SegRegs);                                           /* Invoke interrupt     ;an001; dms;*/

  FP_SEG(SysVarsPtr) = SegRegs.es;                                              /* put pointer in var   ;an001; dms;*/
  FP_OFF(SysVarsPtr) = OutRegs.x.bx;                                            /*                      ;an001; dms;*/
  if ((SysVarsPtr) -> ExtendedMemory != 0)                                      /* extended memory?     ;an001; dms;*/
  {                                                                             /* yes                  ;an001; dms;*/
      EXTMemoryTot = (long) (SysVarsPtr) -> ExtendedMemory;                     /* get total EM size    ;an001; dms;*/
      EXTMemoryTot *= (long) 1024l;                                             /*  at boot time        ;an001; dms;*/
      Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);                        /* print blank line     ;an001; dms;*/
      Sub1_Message(EXTMemoryMsg,STDOUT,Utility_Msg_Class,&EXTMemoryTot);        /* print total EM mem   ;an001; dms;*/

      OutRegs.x.cflag = 0;                                                      /* clear carry flag     ;an001; dms;*/
      InRegs.x.ax = GetExtended;                                                /* get extended mem     ;an001; dms;*/
                                                                                /*   available                      */
      int86(CASSETTE, &InRegs, &OutRegs);                                       /* INT 15h call         ;an001; dms;*/

      EXTMemoryTot = (unsigned long) OutRegs.x.ax * 1024l;				 /* returns 1K mem blocks;an001; dms;*/

      /* subtract out VDisk usage.  Note assumption that VDisk usage doesn't
      *  exceed 64Mb.  Don't bother if there is no extended memory
      */
      if (EXTMemoryTot != 0)
	      EXTMemoryTot -= (unsigned long) (CheckVDisk() * 1024l);

      Sub1_Message(EXTMemAvlMsg,STDOUT,Utility_Msg_Class,&EXTMemoryTot);	/* display available	;an001; dms;*/

      /* if an XMS driver is present, INT 15 may return 0 as the amount
      *  of extended memory available.	In that case, call the XMS
      *  driver to find out the amount of XMS free.  Don't call XMS
      *  unconditionally, because that will cause it to claim memory
      *  if it has not already done so.
      *
      *  However, it is possible, with the newer versions of Himem,
      *  for XMS memory and INT 15 memory to coexist.  There is no
      *  completely reliable way to detect this situation, but we
      *  do know that if Himem is installed, DOS is high, and INT 15
      *  memory exists, then we are configured that way.  In that case,
      *  we can make calls to Himem without disrupting the memory environment.
      *  Otherwise we can't.
      */
      if (XMM_Installed())
      {

	  InRegs.x.ax = 0x3306;		/* get DOS version info */
	  intdos(&InRegs, &OutRegs);	/* call DOS */
	  DOS_Is_High = (OutRegs.h.dh & DOSHMA);	
	  DOS_in_ROM = (OutRegs.h.dh & DOSROM);

	  if (DOS_Is_High || EXTMemoryTot == 0)
	  {	  /* make this check only if we won't disrupt environment */
		  /* get and display XMS memory available */
		  XMSMemoryTot = XMM_QueryTotalFree() * 1024l;
		  Sub1_Message(XMSMemAvlMsg,STDOUT,Utility_Msg_Class,
			       &XMSMemoryTot);
	  }

	  /* get and display HMA status */
	  /* DOS High implies HMA is in use */
	  if (DOS_Is_High) 
		if (DOS_in_ROM)
			Sub0_Message(ROMDOSMsg,STDOUT,Utility_Msg_Class);
		else
			Sub0_Message(HMADOSMsg,STDOUT,Utility_Msg_Class);

	  /* DOS isn't, check if HMA in use, but only if we can quietly */
	  else if (EXTMemoryTot == 0)
	  {
		  HMA_In_Use = XMM_RequestHMA(0xffff);
		  if (HMA_In_Use)
			Sub0_Message(HMANotAvlMsg,STDOUT,Utility_Msg_Class);
		  else
		  {
			XMM_ReleaseHMA();
			Sub0_Message(HMAAvlMsg,STDOUT,Utility_Msg_Class);
		  }
	   }
      }
  }
}				      /* end of DisplayExtendedSummary */





/**/

void DisplayEMSSummary()
  {

  unsigned long int	  EMSFreeMemoryTot;
  unsigned long int	  EMSAvailMemoryTot;

  Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);

  InRegs.x.ax = EMSGetFreePgs;		    /* get total number unallocated pages */
  int86x(EMS, &InRegs, &OutRegs, &SegRegs);

  EMSFreeMemoryTot = OutRegs.x.bx;	    /* total unallocated pages in  BX */
  EMSFreeMemoryTot *= (long) (16l*1024l);

  EMSAvailMemoryTot = OutRegs.x.dx;	    /* total pages */
  EMSAvailMemoryTot *= (long) (16l*1024l);

  Sub1_Message(EMSTotalMemoryMsg,STDOUT,Utility_Msg_Class,&EMSAvailMemoryTot);
  Sub1_Message(EMSFreeMemoryMsg,STDOUT,Utility_Msg_Class,&EMSFreeMemoryTot);

  return;

  }					/* end of DisplayEMSSummary */





/**/


char EMSInstalled()
  {

  unsigned int	EMSStatus;
  unsigned int	EMSVersion;

  char		EmsName[8];
  void far	*EmsNameP;


  if (EMSInstalledFlag == 2)
    {
    EMSInstalledFlag = FALSE;
    InRegs.h.ah = GET_VECT;		  /* get int 67 vector */
    InRegs.h.al = EMS;
    intdosx(&InRegs,&OutRegs,&SegRegs);


    /* only want to try this if vector is non-zero */


    if ((SegRegs.es != 0) && (OutRegs.x.bx != 0))
      {

      EmsNameP = EmsName;
      movedata(SegRegs.es, 0x000a, FP_SEG(EmsNameP), FP_OFF(EmsNameP), 8);
      if (strncmp(EmsName, "EMMXXXX0", 8))
	return (EMSInstalledFlag);

      InRegs.x.ax = EMSGetStat; 	  /* get EMS status */
      int86x(EMS, &InRegs, &OutRegs, &SegRegs);
      EMSStatus = OutRegs.h.ah; 	  /* EMS status returned in AH */

      InRegs.x.ax = EMSGetVer;		  /* get EMS version */
      int86x(EMS, &InRegs, &OutRegs, &SegRegs);
      EMSVersion = OutRegs.h.al;	  /* EMS version returned in AL */

      if ((EMSStatus == 0) && (EMSVersion >= DOSEMSVER))
	EMSInstalledFlag = TRUE;
      } 				  /* end ((SegRegs.es != 0) && (OutRegs.x.bx != 0)) */

    }					/* end if (EMSInstalledFlag == 2) */


  return(EMSInstalledFlag);


  }

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\memctrlc.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/*******************************************************************/
/*	MEMCTRLC.C																		*/
/*																						*/
/*		This module contains the Ctrl-C handler put in by Mem when 	*/
/*	it links in UMBs. On a Ctrl-C, UMBs are delinked if they were	*/
/* 	explicitly enabled by Mem. The old Ctrl-C handler is restored 	*/
/* 	and Mem then exits. If we dont do this, UMBs remain linked in	*/
/*	after a Ctrl-C and as a result lot of old programs dont run.	*/
/*																						*/
/*******************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <dos.h>

extern char LinkedIn;
extern void (interrupt far *OldCtrlc)();
#pragma warning(4:4762)

void interrupt cdecl far MemCtrlc (unsigned es, unsigned ds,
			unsigned di, unsigned si, unsigned bp, unsigned sp,
			unsigned bx, unsigned dx, unsigned cx, unsigned ax )
{
	union REGS inregs;

	((void)es), ((void)ds),	((void)si),	((void)bp), ((void)sp);
	((void)bx), ((void)dx), ((void)bx), ((void)dx), ((void)cx);
	((void)di), ((void)ax);

	if ( LinkedIn )	/* Did we link in UMBs */
	{
		inregs.x.ax = 0x5803;
		inregs.x.bx = 0;
		intdos( &inregs, &inregs );	/* Delink UMBs */
	}

	_dos_setvect( 0x23, OldCtrlc ); /* Restore previous ctrlc handler */

	exit(0);	/* Exit Mem */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\mem.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */

/*----------------------------------------------------------------------+
|                                                                       |
|                                                                       |
|       Title:          MEM                                             |
|                                                                       |
|       Syntax:                                                         |
|                                                                       |
|               From the DOS command line:                              |
|                                                                       |
|               MEM                                                     |
|                       - Used to display DOS memory map summary.       |
|                                                                       |
|               MEM /PROGRAM                                            |
|                       - Used to display DOS memory map.               |
|                                                                       |
|               MEM /DEBUG                                              |
|                       - Used to display a detailed DOS memory map.    |
|                                                                       |
|       AN001 - PTM P2914 -> This PTM relates to MEM's ability to report|
|                            the accurate total byte count for EM       |
|                            memory.                                    |
|                                                                       |
|       AN002 - PTM P3477 -> MEM was displaying erroneous base memory   |
|                            information for "Total" and "Available"    |
|                            memory.  This was due to incorrect logic   |
|                            for RAM carving.                           |
|                                                                       |
|       AN003 - PTM P3912 -> MEM messages do not conform to spec.       |
|               PTM P3989                                               |
|                                                                       |
|               Date: 1/28/88                                           |
|                                                                       |
|       AN004 - PTM P4510 -> MEM does not give correct DOS size.        |
|                                                                       |
|               Date: 4/27/88                                           |
|                                                                       |
|       AN005 - PTM P4957 -> MEM does not give correct DOS size for     |
|                            programs loaded into high memory.          |
|                                                                       |
|               Date: 6/07/88                                           |
|									|
|	Revision History						|	
|	================						|
|									|
|	M000	SR	8/27/90	Added new Ctrl-C handler to delink UMBs |
|									|
|	M003	NSM	12/28/90 Added a New switch /Classify which     |
|			groups programs in conv and UMB and gives sizes |
|			in decimal and hex.				|
|                                                                       |
+----------------------------------------------------------------------*/

/**/

#include "ctype.h"
#include "conio.h"			/* need for kbhit prototype */
#include "stdio.h"
#include "dos.h"
#include "string.h"
#include "stdlib.h"
#include "msgdef.h"
#include "parse.h"
#include "version.h"			/* MSKK02 07/18/89 */
#include "mem.h"

/**/

/* All global declarations go here */

	char	*SingleDrive = "%c:" ;
	char	*MultipleDrives = "%c: - %c:" ;
	char	*UnOwned = "----------" ;
#if IBMCOPYRIGHT                                                        /*EGH*/
        char    *Ibmbio = "IBMBIO" ;                                    /*EGH*/
        char    *Ibmdos = "IBMDOS" ;                                    /*EGH*/
#else                                                                   /*EGH*/
        char    *Ibmbio = "IO    " ;
        char    *Ibmdos = "MSDOS " ;
#endif                                                                  /*EGH*/
	char  LinkedIn = 0;	/* Flag set when mem links in UMBs :M000 */
	void (interrupt far *OldCtrlc)(); /* Old Ctrlc handler save vector :M000*/

/*----------------------------------------------------------------------+
|       define structure used by parser                                 |
+----------------------------------------------------------------------*/

struct p_parms	p_p;

struct p_parmsx p_px;

struct p_control_blk p_con1;
struct p_control_blk p_con2;
struct p_control_blk p_con3;
struct p_control_blk p_con4;

struct p_result_blk  p_result1;
struct p_result_blk  p_result2;
struct p_result_blk  p_result3;
struct p_result_blk  p_result4;

struct p_value_blk p_noval;


/**/

	struct sublistx sublist[5];

	unsigned far	     *ArenaHeadPtr;
	struct	 SYSIVAR far *SysVarsPtr;

	char	OwnerName[128];
	char	TypeText[128];
	char	cmd_line[128];
	char	far *cmdline;

	unsigned UMB_Head;
	unsigned LastPSP=0;

	char	UseArgvZero = TRUE;
	char	EMSInstalledFlag = (char) 2;

	union	 REGS	 InRegs;
	union	 REGS	 OutRegs;
	struct	 SREGS	 SegRegs;

	int	 DataLevel;
	int	 Classify;		/* M003 */
	int	 i;

	int	 BlockDeviceNumber;
        char	*Parse_Ptr;                                                     /* ;an003; dms; pointer to command      */

	struct mem_classif mem_table[100];	/* M003 */
	int	noof_progs = 0;		/* no of entries in mem_table above */

/**/

void interrupt cdecl far MemCtrlc (unsigned es, unsigned ds,
			unsigned di, unsigned si, unsigned bp, unsigned sp,
			unsigned bx, unsigned dx, unsigned cx, unsigned ax );


int	 main()
{
	unsigned char	UMB_Linkage;
	unsigned int rc=0;		/* init to NO ERROR */


	sysloadmsg(&InRegs,&OutRegs);
	if ((OutRegs.x.cflag & CarryFlag) == CarryFlag)
		{
		sysdispmsg(&OutRegs,&OutRegs);
		exit(1);
		}


	InRegs.h.ah = (unsigned char) 0x62;					/* an000; dms; get the PSP		*/
	intdosx(&InRegs, &InRegs, &SegRegs);					/* an000; dms; invoke the INT 21	*/

	FP_OFF(cmdline) = 0x81; 						/* an000; dms; offset of command line	*/
	FP_SEG(cmdline) = InRegs.x.bx;						/* an000; dms; segment of command line	*/

	i = 0;									/* an000; dms; init index		*/
	while ( *cmdline != (char) '\x0d' ) cmd_line[i++] = *cmdline++; 	/* an000; dms; while no CR		*/
	cmd_line[i++] = (char) '\x0d';						/* an000; dms; CR terminate string	*/
	cmd_line[i++] = (char) '\0';						/* an000; dms; null terminate string	*/

	DataLevel = Classify = 0;	/* M003 */
	CSwitch_init();			/* M003: init data structures for */
					/*       Classify */
	parse_init();								/* an000; dms; init for parser		*/
	InRegs.x.si = (unsigned)cmd_line;					/* an000; dms; initialize to command ln.*/
	InRegs.x.cx = (unsigned)0;						/* an000; dms; ordinal of 0		*/
	InRegs.x.dx = (unsigned)0;						/* an000; dms; init pointer		*/
	InRegs.x.di = (unsigned)&p_p;						/* an000; dms; point to ctrl blocks	*/
        Parse_Ptr   = cmd_line;                                       /*;an003; dms; point to command         */

	parse(&InRegs,&OutRegs);						/* an000; dms; parse command line	*/
	while (OutRegs.x.ax == p_no_error)					/* an000; dms; good parse loop		*/
		{
		if (p_result4.P_SYNONYM_Ptr == (unsigned int)p_con4.p_keyorsw)
		{
			for (i = MSG_OPTIONS_FIRST; i <= MSG_OPTIONS_LAST; i++)
				Sub0_Message(i, STDOUT, Utility_Msg_Class);
			return(0);
 		}
		if (p_result1.P_SYNONYM_Ptr == (unsigned int)p_con1.p_keyorsw ||   /* DEBUG switch	       */
		    p_result1.P_SYNONYM_Ptr == (unsigned int)p_con1.p_keyorsw +
						(strlen(p_con1.p_keyorsw)+1))
			DataLevel = 2;						   /* flag DEBUG switch        */

		if (p_result2.P_SYNONYM_Ptr == (unsigned int)p_con2.p_keyorsw ||   /* PROGRAM switch	       */
		    p_result2.P_SYNONYM_Ptr == (unsigned int)p_con2.p_keyorsw +
						(strlen(p_con2.p_keyorsw)+1))
			DataLevel = 1;	    /* flag PROGRAM switch	*/

/* M003 BEGIN - parsing for switch /C */
		if (p_result3.P_SYNONYM_Ptr == (unsigned int)p_con3.p_keyorsw ||   /* Classify switch	       */
		    p_result3.P_SYNONYM_Ptr == (unsigned int)p_con3.p_keyorsw +
						(strlen(p_con3.p_keyorsw)+1))
	 	{
			DataLevel = 1;	/* treat this similar to /P switch */
			Classify = 1;
		}
/* M003 END */

		Parse_Ptr = (char *) (OutRegs.x.si);					    /* point to next parm	*/
		parse(&OutRegs,&OutRegs);					    /* parse the line		*/
		if (OutRegs.x.ax == p_no_error) 				    /* check for > 1 switch	*/
			OutRegs.x.ax = p_too_many;				    /* flag too many		*/
		}

	if (OutRegs.x.ax != p_rc_eol)						    /* parse error?		*/
		{
		Parse_Message(OutRegs.x.ax,STDERR,Parse_Err_Class,(char far *)Parse_Ptr);		    /* display parse error	*/
		exit(1);							    /* exit the program 	*/
		}

	/* Store the current Ctrl-C handler and replace with our
		Ctrl-C handler :M000
	*/
	OldCtrlc = _dos_getvect( 0x23 ); /* M000 */
	_dos_setvect( 0x23, MemCtrlc );	/* M000 */

	if (DataLevel > 0)
	{
		/* save current state of UMB linkage */
		InRegs.x.ax = GET_UMB_LINK_STATE;
		intdos(&InRegs, &OutRegs);
		if (!(UMB_Linkage = OutRegs.h.al))
		{  /* UMBs not presently linked, so do it now */
			InRegs.x.ax = SET_UMB_LINK_STATE;
			InRegs.x.bx = LINK_UMBS;
			intdos(&InRegs, &OutRegs);
			LinkedIn++;	/* Indicate that we have linked in UMBs :M000 */
		}

		rc = DisplayBaseDetail();		/* go show the memory state */

		/* restore original UMB link state */
		if (!UMB_Linkage)		/* weren't linked originally */
		{
			InRegs.x.ax = SET_UMB_LINK_STATE;
			InRegs.x.bx = UNLINK_UMBS;
			intdos(&InRegs, &OutRegs);  /* take 'em out again */
			LinkedIn--;
		}
	}
	if (!rc) {	/* if no error in DisplayBaseDetail */
			/* go display other things and summary */
		Sub0_Message(NewLineMsg,STDOUT,Utility_Msg_Class);
		/* M003 BEGIN - Display summary acc. to option chosen */
		if (Classify)
			DisplayClassification();
		else
			DisplayBaseSummary();	/* display low memory totals */
		/* M003 END */

		if (EMSInstalled() && (DataLevel > 1))
		  DisplayEMSDetail();	/* display EMS memory totals */


		if (EMSInstalled())
		  DisplayEMSSummary();	/* display EMS memory totals */

		DisplayExtendedSummary(); /* display extended memory summary */
					/* NOTE: we don't display status of
					 * HMA because to enquire about its
					 * status can cause XMS to kick in
					 *
					 * If we didn't care about that, then
					 * display HMA status here.
					 */
	}	/* end of if (!rc) */

	/* If user did not issue Ctrl-C till here, we just remove the handler */
	_dos_setvect( 0x23, OldCtrlc );	/* M000 */

	return(rc);			/* end of MEM main routine */

	}

/**/

unsigned long AddressOf(Pointer)
char far *Pointer;
{

	unsigned long SegmentAddress,OffsetAddress;

	SegmentAddress = (unsigned long) (FP_SEG(Pointer)) * 16l;
	OffsetAddress = (unsigned long) (FP_OFF(Pointer));

	return( SegmentAddress + OffsetAddress);

	}

/*----------------------------------------------------------------------+
|                                                                       |
|  SUBROUTINE NAME:     PARSE_INIT                                      |
|                                                                       |
|  SUBROUTINE FUNCTION:                                                 |
|                                                                       |
|       This routine is called by the FILESYS MAIN routine to initialize|
|       the parser data structures.                                     |
|                                                                       |
|  INPUT:                                                               |
|       none                                                            |
|                                                                       |
|  OUTPUT:                                                              |
|       properly initialized parser control blocks                      |
|                                                                       |
+----------------------------------------------------------------------*/
void parse_init()
  {
  p_p.p_parmsx_address	  = &p_px;	/* address of extended parm list */
  p_p.p_num_extra	  = 0;

  p_px.p_minp		  = 0;
  p_px.p_maxp		  = 0;
  p_px.p_maxswitch	  = 4;
  p_px.p_control[0]	  = &p_con1;
  p_px.p_control[1]	  = &p_con2;
  p_px.p_control[2]       = &p_con3;
  p_px.p_control[3]       = &p_con4;
  p_px.p_keyword	  = 0;

  p_con1.p_match_flag	  = p_none;
  p_con1.p_function_flag  = p_cap_file;
  p_con1.p_result_buf	  = (unsigned int)&p_result1;
  p_con1.p_value_list	  = (unsigned int)&p_noval;
  p_con1.p_nid		  = 2;
  strcpy(p_con1.p_keyorsw,"/DEBUG"+NUL);
  strcpy(p_con1.p_keyorsw + (strlen(p_con1.p_keyorsw)+1),"/D"+NUL);

  p_con2.p_match_flag	  = p_none;
  p_con2.p_function_flag  = p_cap_file;
  p_con2.p_result_buf	  = (unsigned int)&p_result2;
  p_con2.p_value_list	  = (unsigned int)&p_noval;
  p_con2.p_nid		  = 2;
  strcpy(p_con2.p_keyorsw,"/PROGRAM"+NUL);
  strcpy(p_con2.p_keyorsw + (strlen(p_con2.p_keyorsw)+1),"/P"+NUL);

  p_con3.p_match_flag	  = p_none;
  p_con3.p_function_flag  = p_cap_file;
  p_con3.p_result_buf	  = (unsigned int)&p_result3;
  p_con3.p_value_list	  = (unsigned int)&p_noval;
  p_con3.p_nid		  = 2;
  strcpy(p_con3.p_keyorsw,"/CLASSIFY"+NUL);
  strcpy(p_con3.p_keyorsw + (strlen(p_con3.p_keyorsw)+1),"/C"+NUL);

  p_con4.p_match_flag	  = p_none;
  p_con4.p_function_flag  = p_none;
  p_con4.p_result_buf	  = (unsigned int)&p_result4;
  p_con4.p_value_list	  = (unsigned int)&p_noval;
  p_con4.p_nid		  = 1;
  strcpy(p_con4.p_keyorsw,"/?"+NUL);

  p_noval.p_val_num	  = 0;

  p_result1.P_Type	  = 0;
  p_result1.P_Item_Tag	  = 0;
  p_result1.P_SYNONYM_Ptr = 0;
  p_result1.p_result_buff = 0;

  p_result2.P_Type	  = 0;
  p_result2.P_Item_Tag	  = 0;
  p_result2.P_SYNONYM_Ptr = 0;
  p_result2.p_result_buff = 0;

  p_result3.P_Type	  = 0;
  p_result3.P_Item_Tag	  = 0;
  p_result3.P_SYNONYM_Ptr = 0;
  p_result3.p_result_buff = 0;

  return;

  }					/* end parse_init */


/************************************************************************/
/* Parse_Message                - This routine will print only those    */
/*                                messages that require 1 replaceable   */
/*                                parm.                                 */
/*                                                                      */
/*      Inputs  : Msg_Num       - number of applicable message          */
/*                Handle        - display type                          */
/*                Message_Type  - type of message to display            */
/*                Replace_Parm  - pointer to parm to replace            */
/*                                                                      */
/*      Outputs : message                                               */
/*                                                                      */
/************************************************************************/

void Parse_Message(Msg_Num,Handle,Message_Type,parse_ptr)
                        
int             Msg_Num; 
int             Handle;  
unsigned char   Message_Type;
char far *parse_ptr;
                            
{                          
                         
                                     
	if (parse_ptr) {
		sublist[1].value     = (unsigned far *)parse_ptr;
		sublist[1].size      = Sublist_Length; 
		sublist[1].reserved  = Reserved;      
		sublist[1].id        = 0;            
		sublist[1].flags     = Char_Field_ASCIIZ+Left_Align;
		sublist[1].max_width = 40;
		sublist[1].min_width = 01;
		sublist[1].pad_char  = Blank; 
	
        	InRegs.x.cx = SubCnt1;    
	}
	else
        	InRegs.x.cx = 0;    
                                     
        InRegs.x.ax = Msg_Num;      
        InRegs.x.bx = Handle;      
        InRegs.h.dl = No_Input;  
        InRegs.h.dh = Message_Type; 
        InRegs.x.si = (unsigned int)&sublist[1]; 
        sysdispmsg(&InRegs,&OutRegs); 
        return;                     
}                                  


/* M003 BEGIN */
/*----------------------------------------------------------------------+
|                                                                       |
|  SUBROUTINE NAME:     CSwitch_init                                    |
|                                                                       |
|  SUBROUTINE FUNCTION:                                                 |
|                                                                       |
|       This routine is called by the FILESYS MAIN routine to initialize|
|       the C(lassify) switch related data structures.                  |
|                                                                       |
|  INPUT:                                                               |
|       none                                                            |
|                                                                       |
|  OUTPUT:                                                              |
|       properly initialized C switch related Data structures 		|
|                                                                       |
+----------------------------------------------------------------------*/
void CSwitch_init()
{
	int i;
	int *ptr;

	ptr = (int *) (mem_table);

	for (i=sizeof(mem_table)/2;i>0;i--)
		*ptr++ = 0;

	noof_progs=0;
}

/* M003 END */
	

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\_msgret.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
page	       60,132
name	       _msgret
title	       C to Message Retriever
;-------------------------------------------------------------------
;
;	MODULE: 	_msgret
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 message retriever
;
;	CALLING FORMAT:
;			msgret(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

	INCLUDE SYSMSG.INC		;PERMIT SYSTEM MESSAGE HANDLER DEFINITION ;AN000;

	MSG_UTILNAME <MEM>		;IDENTIFY THE COMPONENT 		;AN000;

;-------------------------------------------------------------------
;-------------------------------------------------------------------


_TEXT	SEGMENT BYTE PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT WORD PUBLIC 'BSS'
_BSS	ENDS

DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME	CS: DGROUP, DS: DGROUP, SS: DGROUP, ES: NOTHING

	public	data_sysloadmsg
	public	data_sysdispmsg
	public	data_sysgetmsg

_DATA	SEGMENT

	MSG_SERVICES <MSGDATA>
	MSG_SERVICES <LOADmsg,FARmsg>
	MSG_SERVICES <DISPLAYmsg,GETmsg,CHARmsg,NUMmsg>
	MSG_SERVICES <MEM.CLA,MEM.CLB,MEM.CL1,MEM.CL2,MEM.CTL>			     ;AN000;


data_sysloadmsg proc far

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4+4]		  ; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer

;-------------------------------------------------------------------

	call	sysloadmsg		; call the message retriever

;-------------------------------------------------------------------

	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6+4]		  ; fix di (arg 1)

	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

data_sysloadmsg endp


data_sysdispmsg proc far

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4+4]		  ; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer

;-------------------------------------------------------------------

	call	sysdispmsg

;-------------------------------------------------------------------

	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6+4]		  ; fix di (arg 1)

	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

data_sysdispmsg endp


data_sysgetmsg	proc far

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4+4]		  ; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer

;-------------------------------------------------------------------

	call	sysgetmsg		; call the message retriever

;-------------------------------------------------------------------

	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6+4]		  ; fix di (arg 1)

	push	ax			; save ax
	mov	[di+00],es		; load segregs.es
	mov	[di+06],ds		; load outregs.ds
	pop	ax			; restore ax

	pop	di			; restore di
	push	di			; save it
	mov	di,[bp+8+4]		  ; fix di (arg 2)
	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

data_sysgetmsg	endp

include msgdcl.inc

_DATA	ends			; end code segment

_TEXT	SEGMENT

	assume cs:_TEXT

	public	_sysdispmsg
	public	_sysloadmsg
	public	_sysgetmsg

_sysdispmsg	proc	near
		call	data_sysdispmsg
		ret
_sysdispmsg	endp

_sysloadmsg	proc	near
		call	data_sysloadmsg
		ret
_sysloadmsg	endp

_sysgetmsg	proc	near
		call	data_sysgetmsg
		ret
_sysgetmsg	endp

_TEXT	ENDS
	end


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\_parse.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
page	       60,132
name	       _parse
title	       C to PARSER interface
;-------------------------------------------------------------------
;
;	MODULE: 	_parse
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 parser
;
;	CALLING FORMAT:
;			parse(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

;	extrn	sysparse:far

	public	_parse

;-------------------------------------------------------------------
;FarSW	 equ	 0	 ; make sysparse be a NEAR proc
;TimeSW  equ	 0	 ; Check time format
;FileSW  equ	 0	 ; Check file specification
;CAPSW	 equ	 0	 ; Perform CAPS if specified
;CmpxSW  equ	 0	 ; Check complex list
;NumSW	 equ	 1	 ; Check numeric value
;KeySW	 equ	 0	 ; Support keywords
;SwSW	 equ	 1	 ; Support switches
;Val1SW  equ	 1	 ; Support value definition 1
;Val2SW  equ	 1	 ; Support value definition 2
;Val3SW  equ	 0	 ; Support value definition 3
;DrvSW	 equ	 0	 ; Support drive only format
;QusSW	 equ	 0	 ; Support quoted string format
;-------------------------------------------------------------------




_TEXT	SEGMENT BYTE PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT WORD PUBLIC 'BSS'
_BSS	ENDS


DGROUP	GROUP	CONST, _BSS, _DATA


_DATA	segment word public 'DATA'

	assume	cs:DGROUP
	assume	ss:dgroup

	public	SysParse

;-------------------------------------------------------------------
.xlist
include version.inc
include parse.asm		; include the parser
.list
;-------------------------------------------------------------------

		public	CallParser
CallParser	proc	far

	push	ds
	PUSH	ES

	push	cs
	pop	ds
	assume	ds:DGROUP

	push	cs
	pop	es
	assume	es:DGROUP

	nop

	call	SysParse

	POP	ES
	pop	ds

	ret

CallParser	endp



_DATA	ends

_TEXT	segment byte public 'CODE'

	ASSUME	CS:_TEXT
	ASSUME	DS:DGROUP
	ASSUME	ES:NOTHING
	ASSUME	SS:DGROUP

_parse	proc	near

	push	bp		; save user's base pointer
	mov	bp,sp		; set bp to current sp
	push	di		; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4]	; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]	; load di
	push	ax		; the di value from inregs is now on stack

	mov	ax,[di+00]	; get inregs.x.ax
	mov	bx,[di+02]	; get inregs.x.bx
	mov	cx,[di+04]	; get inregs.x.cx
	mov	dx,[di+06]	; get inregs.x.dx
	mov	si,[di+08]	; get inregs.x.si
	pop	di		; get inregs.x.di from stack

	push	bp		; save base pointer

;-------------------------------------------------------------------
;-------------------------------------------------------------------

	call	CallParser	; call the parser

;-------------------------------------------------------------------
;-------------------------------------------------------------------

	pop	bp		; restore base pointer
	push	di		; the di value from call is now on stack
	mov	di,[bp+6]	; fix di (arg 1)

	mov	[di+00],ax	; load outregs.x.ax
	mov	[di+02],bx	; load outregs.x.bx
	mov	[di+04],cx	; load outregs.x.cx
	mov	[di+06],dx	; load outregs.x.dx
	mov	[di+08],si	; load outregs.x.si

	xor	ax,ax		; clear ax
	lahf			; get flags into ax
	mov	[di+0ch],ax	; load outregs.x.cflag

	pop	ax		; get di from stack
	mov	[di+0ah],ax	; load outregs.x.di

;-------------------------------------------------------------------

	pop	si		; restore registers
	pop	di
	mov	sp,bp		; restore sp
	pop	bp		; restore user's bp
	ret

_parse	endp

_TEXT	ends			; end code segment
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\submsg.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/* SUBMSG.C - Message retriever interface functions for MEM command.
*/

#include "ctype.h"
#include "conio.h"			/* need for kbhit prototype */
#include "stdio.h"
#include "dos.h"
#include "string.h"
#include "stdlib.h"
#include "msgdef.h"
#include "version.h"			/* MSKK02 07/18/89 */
#include "mem.h"

/**/


/************************************************************************/
/* SUB0_MESSAGE 		- This routine will print only those	*/
/*				  messages that do not require a	*/
/*				  a sublist.				*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void Sub0_Message(Msg_Num,Handle,Message_Type)					     /* print messages with no subs	     */

int		Msg_Num;
int		Handle;
unsigned char	Message_Type;
										/*     extended, parse, or utility	*/
	{
	InRegs.x.ax = Msg_Num;							/* put message number in AX		*/
	InRegs.x.bx = Handle;							/* put handle in BX			*/
	InRegs.x.cx = No_Replace;						/* no replaceable subparms		*/
	InRegs.h.dl = No_Input; 						/* no keyboard input			*/
	InRegs.h.dh = Message_Type;						/* type of message to display		*/
	sysdispmsg(&InRegs,&OutRegs);					       /* display the message		       */

	return;
	}


/************************************************************************/
/* SUB1_MESSAGE 		- This routine will print only those	*/
/*				  messages that require 1 replaceable	*/
/*				  parm. 				*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*		  Replace_Parm	- pointer to parm to replace		*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void Sub1_Message(Msg_Num,Handle,Message_Type,Replace_Parm)

int		Msg_Num;
int		Handle;
unsigned char	Message_Type;
										/*     extended, parse, or utility	*/
unsigned long int    *Replace_Parm;						/* pointer to message to print		*/

{


	{

	sublist[1].value     = (unsigned far *)Replace_Parm;
	sublist[1].size      = Sublist_Length;
	sublist[1].reserved  = Reserved;
	sublist[1].id	     = 1;
	sublist[1].flags     = Unsgn_Bin_DWord+Right_Align;
	sublist[1].max_width = 10;
	sublist[1].min_width = 10;
	sublist[1].pad_char  = Blank;

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt1;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Message_Type;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	}
	return;
}


/************************************************************************/
/* SUB2_MESSAGE 		- This routine will print only those	*/
/*				  messages that require 2 replaceable	*/
/*				  parms.				*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*		  Replace_Parm1 - pointer to parm to replace		*/
/*		  Replace_Parm2 - pointer to parm to replace		*/
/*		  Replace_Parm3 - pointer to parm to replace		*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void Sub2_Message(Msg_Num,Handle,Message_Type,
	     Replace_Parm1,
	     Replace_Message1)

int		Msg_Num;
int		Handle;
unsigned char	Message_Type;
int		Replace_Message1;
										/*     extended, parse, or utility	*/
char	*Replace_Parm1; 							/* pointer to message to print		*/
{


	{
		switch(Msg_Num)
			{
			case	DeviceLineMsg:

				sublist[1].value     = (unsigned far *)Replace_Parm1;
				sublist[1].size      = Sublist_Length;
				sublist[1].reserved  = Reserved;
				sublist[1].id	     = 1;
				sublist[1].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[1].max_width = 0x0008;
				sublist[1].min_width = 0x0008;
				sublist[1].pad_char  = Blank;

				InRegs.x.ax = Replace_Message1;
				InRegs.h.dh = Message_Type;
				sysgetmsg(&InRegs,&SegRegs,&OutRegs);

				FP_OFF(sublist[2].value)    = OutRegs.x.si;
				FP_SEG(sublist[2].value)    = SegRegs.ds;
				sublist[2].size      = Sublist_Length;
				sublist[2].reserved  = Reserved;
				sublist[2].id	     = 2;
				sublist[2].flags     = Char_Field_ASCIIZ+Right_Align;
				sublist[2].max_width = 00;
				sublist[2].min_width = 10;
				sublist[2].pad_char  = Blank;
				break;
			}

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt2;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Message_Type;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	}
	return;
}

/************************************************************************/
/* SUB3_MESSAGE 		- This routine will print only those	*/
/*				  messages that require 3 replaceable	*/
/*				  parms.				*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*		  Replace_Parm1 - pointer to parm to replace		*/
/*		  Replace_Parm2 - pointer to parm to replace		*/
/*		  Replace_Parm3 - pointer to parm to replace		*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void Sub3_Message(Msg_Num,Handle,Message_Type,
	     Replace_Parm1,
	     Replace_Parm2,
	     Replace_Message1)

int		  Msg_Num;
int		  Handle;
unsigned char	  Message_Type;
char		  *Replace_Parm1;
unsigned long int *Replace_Parm2;
int		  Replace_Message1;
										/*     extended, parse, or utility	*/
{


	{
		switch(Msg_Num)
			{
			case	DriverLineMsg:

				sublist[1].value     = (unsigned far *)Replace_Parm1;
				sublist[1].size      = Sublist_Length;
				sublist[1].reserved  = Reserved;
				sublist[1].id	     = 1;
				sublist[1].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[1].max_width = 0x0008;
				sublist[1].min_width = 0x0008;
				sublist[1].pad_char  = Blank;

				sublist[2].value     = (unsigned far *)Replace_Parm2;
				sublist[2].size      = Sublist_Length;
				sublist[2].reserved  = Reserved;
				sublist[2].id	     = 2;
				sublist[2].flags     = Bin_Hex_DWord+Right_Align;
				sublist[2].max_width = 0x0006;
				sublist[2].min_width = 0x0006;
				sublist[2].pad_char  = 0x0030;

				InRegs.x.ax = Replace_Message1;
				InRegs.h.dh = Message_Type;
				sysgetmsg(&InRegs,&SegRegs,&OutRegs);

				FP_OFF(sublist[3].value)    = OutRegs.x.si;
				FP_SEG(sublist[3].value)    = SegRegs.ds;
				sublist[3].size      = Sublist_Length;
				sublist[3].reserved  = Reserved;
				sublist[3].id	     = 3;
				sublist[3].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[3].max_width = 00;
				sublist[3].min_width = 10;
				sublist[3].pad_char  = Blank;
				break;

			case	HandleMsg:
				sublist[1].value     = (unsigned far *)Replace_Parm1;
				sublist[1].size      = Sublist_Length;
				sublist[1].reserved  = Reserved;
				sublist[1].id	     = 1;
				sublist[1].flags     = Unsgn_Bin_Byte+Right_Align;
				sublist[1].max_width = 0x0009;
				sublist[1].min_width = 0x0009;
				sublist[1].pad_char  = Blank;

				sublist[2].value     = (unsigned far *)Replace_Parm2;
				sublist[2].size      = Sublist_Length;
				sublist[2].reserved  = Reserved;
				sublist[2].id	     = 2;
				sublist[2].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[2].max_width = 0x0008;
				sublist[2].min_width = 0x0008;
				sublist[2].pad_char  = Blank;

				InRegs.x.ax = Replace_Message1;
				InRegs.h.dh = Message_Type;
				sysgetmsg(&InRegs,&SegRegs,&OutRegs);

				FP_OFF(sublist[3].value)    = OutRegs.x.si;
				FP_SEG(sublist[3].value)    = SegRegs.ds;
				sublist[3].size      = Sublist_Length;
				sublist[3].reserved  = Reserved;
				sublist[3].id	     = 3;
				sublist[3].flags     = Bin_Hex_DWord+Right_Align;
				sublist[3].max_width = 00;
				sublist[3].min_width = 10;
				sublist[3].pad_char  = Blank;
				break;

			}

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt3;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Message_Type;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	}
	return;
}


/************************************************************************/
/* SUB4_MESSAGE 		- This routine will print only those	*/
/*				  messages that require 4 replaceable	*/
/*				  parms.				*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*		  Replace_Parm1 - pointer to parm to replace		*/
/*		  Replace_Parm2 - pointer to parm to replace		*/
/*		  Replace_Parm3 - pointer to parm to replace		*/
/*		  Dynamic_Parm	- parm number to use as replaceable	*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void Sub4_Message(Msg_Num,Handle,Message_Type,
	     Replace_Value1,
	     Replace_Message1,
	     Replace_Value2,
	     Replace_Message2)

int			Msg_Num;
int			Handle;
unsigned char		Message_Type;
unsigned long int	*Replace_Value1;
int			Replace_Message1;
unsigned long int	*Replace_Value2;
int			Replace_Message2;
										/*     extended, parse, or utility	*/
{


	{
		switch(Msg_Num)
			{
			case	MainLineMsg:

				sublist[1].value     = (unsigned far *)Replace_Value1;
				sublist[1].size      = Sublist_Length;
				sublist[1].reserved  = Reserved;
				sublist[1].id	     = 1;
				sublist[1].flags     = Bin_Hex_DWord+Right_Align;
				sublist[1].max_width = 06;
				sublist[1].min_width = 06;
				sublist[1].pad_char  = 0x0030;

				InRegs.x.ax	   = Replace_Message1;
				InRegs.h.dh	   = Message_Type;
				sysgetmsg(&InRegs,&SegRegs,&OutRegs);

				FP_OFF(sublist[2].value)    = OutRegs.x.si;
				FP_SEG(sublist[2].value)    = SegRegs.ds;
				sublist[2].size      = Sublist_Length;
				sublist[2].reserved  = Reserved;
				sublist[2].id	     = 2;
				sublist[2].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[2].max_width = 0x0008;
				sublist[2].min_width = 0x0008;
				sublist[2].pad_char  = Blank;

				sublist[3].value     = (unsigned far *)Replace_Value2;
				sublist[3].size      = Sublist_Length;
				sublist[3].reserved  = Reserved;
				sublist[3].id	     = 3;
				sublist[3].flags     = Bin_Hex_DWord+Right_Align;
				sublist[3].max_width = 06;
				sublist[3].min_width = 06;
				sublist[3].pad_char  = 0x0030;

				InRegs.x.ax = Replace_Message2;
				InRegs.h.dh = Message_Type;
				sysgetmsg(&InRegs,&SegRegs,&OutRegs);

				FP_OFF(sublist[4].value)    = OutRegs.x.si;
				FP_SEG(sublist[4].value)    = SegRegs.ds;
				sublist[4].size      = Sublist_Length;
				sublist[4].reserved  = Reserved;
				sublist[4].id	     = 4;
				sublist[4].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[4].max_width = 0;
				sublist[4].min_width = 10;
				sublist[4].pad_char  = Blank;
				break;
			}

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt4;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Message_Type;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	}
	return;
}



/************************************************************************/
/* SUB4a_MESSAGE		- This routine will print only those	*/
/*				  messages that require 4 replaceable	*/
/*				  parms.				*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*		  Replace_Parm1 - pointer to parm to replace		*/
/*		  Replace_Parm2 - pointer to parm to replace		*/
/*		  Replace_Parm3 - pointer to parm to replace		*/
/*		  Dynamic_Parm	- parm number to use as replaceable	*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void Sub4a_Message(Msg_Num,Handle,Message_Type,
	     Replace_Value1,
	     Replace_Message1,
	     Replace_Value2,
	     Replace_Message2)

int			Msg_Num;
int			Handle;
unsigned char		Message_Type;
unsigned long int	*Replace_Value1;
char			*Replace_Message1;
unsigned long int	*Replace_Value2;
char			*Replace_Message2;

{


	{
		switch(Msg_Num)
			{
			case	MainLineMsg:

				sublist[1].value     = (unsigned far *)Replace_Value1;
				sublist[1].size      = Sublist_Length;
				sublist[1].reserved  = Reserved;
				sublist[1].id	     = 1;
				sublist[1].flags     = Bin_Hex_DWord+Right_Align;
				sublist[1].max_width = 06;
				sublist[1].min_width = 06;
				sublist[1].pad_char  = 0x0030;

				sublist[2].value     = (unsigned far *)Replace_Message1;
				sublist[2].size      = Sublist_Length;
				sublist[2].reserved  = Reserved;
				sublist[2].id	     = 2;
				sublist[2].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[2].max_width = 0x0008;
				sublist[2].min_width = 0x0008;
				sublist[2].pad_char  = Blank;

				sublist[3].value     = (unsigned far *)Replace_Value2;
				sublist[3].size      = Sublist_Length;
				sublist[3].reserved  = Reserved;
				sublist[3].id	     = 3;
				sublist[3].flags     = Bin_Hex_DWord+Right_Align;
				sublist[3].max_width = 06;
				sublist[3].min_width = 06;
				sublist[3].pad_char  = 0x0030;

				sublist[4].value     = (unsigned far *)Replace_Message2;
				sublist[4].size      = Sublist_Length;
				sublist[4].reserved  = Reserved;
				sublist[4].id	     = 4;
				sublist[4].flags     = Char_Field_ASCIIZ+Left_Align;
				sublist[4].max_width = 0;
				sublist[4].min_width = 10;
				sublist[4].pad_char  = Blank;
				break;
			}

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt4;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Message_Type;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	}
	return;
}


/************************************************************************/
/* EMSPrint			- This routine will print the message	*/
/*				  necessary for EMS reporting.		*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void EMSPrint(Msg_Num,Handle,Message_Type,
	     Replace_Value1,
	     Replace_Message1,
	     Replace_Value2)

int			Msg_Num;
int			Handle;
unsigned char		Message_Type;
int			*Replace_Value1;
char			*Replace_Message1;
unsigned long int	*Replace_Value2;
										/*     extended, parse, or utility	*/
{

	{
	sublist[1].value     = (unsigned far *)Replace_Value1;
	sublist[1].size      = Sublist_Length;
	sublist[1].reserved  = Reserved;
	sublist[1].id	     = 1;
	sublist[1].flags     = Unsgn_Bin_Word+Right_Align;
	sublist[1].max_width = 03;
	sublist[1].min_width = 03;
	sublist[1].pad_char  = Blank;

	sublist[2].value     = (unsigned far *)Replace_Message1;
	sublist[2].size      = Sublist_Length;
	sublist[2].reserved  = Reserved;
	sublist[2].id	     = 2;
	sublist[2].flags     = Char_Field_ASCIIZ+Left_Align;
	sublist[2].max_width = 0x0008;
	sublist[2].min_width = 0x0008;
	sublist[2].pad_char  = Blank;

	sublist[3].value     = (unsigned far *)Replace_Value2;
	sublist[3].size      = Sublist_Length;
	sublist[3].reserved  = Reserved;
	sublist[3].id	     = 3;
	sublist[3].flags     = Bin_Hex_DWord+Right_Align;
	sublist[3].max_width = 06;
	sublist[3].min_width = 06;
	sublist[3].pad_char  = 0x0030;

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt3;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Message_Type;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	}
	return;
}

/* M003 BEGIN - output procs for C switch */
/************************************************************************/
/* SUBC4_MESSAGE		- This routine will print only those	*/
/*				  messages that require 4 replaceable	*/
/*				  parms.(for Classify Switch)		*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Message_Type	- type of message to display		*/
/*		  Replace_Message1 - pointer to a Replacement message	*/
/*		  Replace_Value1 - pointer to parm to replace		*/
/*		  Replace_Message2 - pointer to a Replacement message	*/
/*		  Replace_Value2 - pointer to parm to replace		*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void SubC4_Message(Msg_Num,Handle,
	     Replace_Message1,Msg_Type,
	     Replace_Value1,
	     Replace_Message2)

int			Msg_Num;
int			Handle,Msg_Type;
unsigned long int	*Replace_Value1;
char			*Replace_Message1,*Replace_Message2;

{

	switch(Msg_Type)
		{
		case	IbmdosMsg:
		case	CFreeMsg:
		case	SystemMsg:
			InRegs.x.ax = Msg_Type;
			InRegs.h.dh = Utility_Msg_Class;
			sysgetmsg(&InRegs,&SegRegs,&OutRegs);
			FP_OFF(sublist[1].value)    = OutRegs.x.si;
			FP_SEG(sublist[1].value)    = SegRegs.ds;
			break;
		default:
			sublist[1].value = (unsigned far *) Replace_Message1;
			break;
	}
	sublist[1].size      = Sublist_Length;
	sublist[1].reserved  = Reserved;
	sublist[1].id	     = 1;
	sublist[1].flags     = Char_Field_ASCIIZ+Left_Align;
	sublist[1].max_width = 0x0008;
	sublist[1].min_width = 0x0008;
	sublist[1].pad_char  = Blank;

	sublist[2].value     = (unsigned far *)Replace_Value1;
	sublist[2].size      = Sublist_Length;
	sublist[2].reserved  = Reserved;
	sublist[2].id	     = 2;
	sublist[2].flags     = Unsgn_Bin_DWord+Right_Align;
	sublist[2].max_width = 10;
	sublist[2].min_width = 10;
	sublist[2].pad_char  = Blank;

	sublist[3].value     = (unsigned far *) Replace_Message2;
	sublist[3].size      = Sublist_Length;
	sublist[3].reserved  = Reserved;
	sublist[3].id	     = 3;
	sublist[3].flags     = Char_Field_ASCIIZ+Left_Align;
	sublist[3].max_width = 0x0009;
	sublist[3].min_width = 0x0009;
	sublist[3].pad_char  = Blank;

	sublist[4].value     = (unsigned far *)Replace_Value1;
	sublist[4].size      = Sublist_Length;
	sublist[4].reserved  = Reserved;
	sublist[4].id	     = 4;
	sublist[4].flags     = Bin_Hex_DWord+Right_Align;
	sublist[4].max_width = 06;
	sublist[4].min_width = 06;
	sublist[4].pad_char  = Blank;


	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt4;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Utility_Msg_Class;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	return;
}
/************************************************************************/
/* SUBC2_MESSAGE 		- This routine will print only those	*/
/*				  messages that require 2 replaceable	*/
/*				  parms (for Classify Switch).		*/
/*									*/
/*	Inputs	: Msg_Num	- number of applicable message		*/
/*		  Handle	- display type				*/
/*		  Replace_Parm1 - pointer to parm to replace		*/
/*		  Replace_Message1 - pointer to replace message 	*/
/*									*/
/*	Outputs : message						*/
/*									*/
/************************************************************************/

void SubC2_Message(Msg_Num,Handle, Replace_Parm1,
	     Replace_Message1)

int		Msg_Num;
int		Handle;
unsigned long int *Replace_Parm1;
char *Replace_Message1;
{

	sublist[1].value     = (unsigned far *)Replace_Parm1;
	sublist[1].size      = Sublist_Length;
	sublist[1].reserved  = Reserved;
	sublist[1].id	     = 1;
	sublist[1].flags     = Unsgn_Bin_DWord+Right_Align;
	sublist[1].max_width = 10;
	sublist[1].min_width = 10;
	sublist[1].pad_char  = Blank;

	sublist[2].value     = (unsigned far *)Replace_Message1;
	sublist[2].size      = Sublist_Length;
	sublist[2].reserved  = Reserved;
	sublist[2].id	     = 2;
	sublist[2].flags     = Char_Field_ASCIIZ+Left_Align;
	sublist[2].max_width = 0x0009;
	sublist[2].min_width = 0x0009;
	sublist[2].pad_char  = Blank;

	InRegs.x.ax = Msg_Num;
	InRegs.x.bx = Handle;
	InRegs.x.cx = SubCnt2;
	InRegs.h.dl = No_Input;
	InRegs.h.dh = Utility_Msg_Class;
	InRegs.x.si = (unsigned int)&sublist[1];
	sysdispmsg(&InRegs,&OutRegs);
	return;
}
/* M003 END */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\xmm.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/*
 *	XMS Driver C Interface Routine Definitions
 *
 */

unsigned	XMM_Installed(void);

long	XMM_Version(void);
long	XMM_RequestHMA(unsigned);
long	XMM_ReleaseHMA(void);
long	XMM_GlobalEnableA20(void);
long	XMM_GlobalDisableA20(void);
long	XMM_EnableA20(void);
long	XMM_DisableA20(void);
long	XMM_QueryA20(void);
long	XMM_QueryLargestFree(void);
long	XMM_QueryTotalFree(void);
long	XMM_AllocateExtended(unsigned);
long	XMM_FreeExtended(unsigned);
long	XMM_MoveExtended(struct XMM_Move *);
long	XMM_LockExtended(unsigned);
long	XMM_UnLockExtended(unsigned);
long	XMM_GetHandleLength(unsigned);
long	XMM_GetHandleInfo(unsigned);
long	XMM_ReallocateExtended(unsigned, unsigned);
long	XMM_RequestUMB(unsigned);
long	XMM_ReleaseUMB(unsigned);

struct	XMM_Move {
	unsigned long	Length;
	unsigned short	SourceHandle;
	unsigned long	SourceOffset;
	unsigned short	DestHandle;
	unsigned long	DestOffset;
};

#define	XMSERROR(x)	(char)((x)>>24)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\mem\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

mem.skl : ..\usa\mem.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\nlsparm.asm ===
PAGE	,132			;
	TITLE	NLSPARM.SAL - NLSFUNC  SYSTEM COMMAND LINE PARSER

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: NLSPARM.SAL
;
; DESCRIPTIVE NAME: Include the DOS system PARSER in the SEGMENT
;		    configuration expected by the modules of NLSFUNC.
;
;FUNCTION: The common code of the DOS command line PARSER is optimized by
;	   the setting of certain switches that cause the conditional
;	   assembly of only the required portions of the common PARSER.
;	   The segment registers are ASSUMED according to the type .EXE.
;
; ENTRY POINT: SYSPARSE, near
;
; INPUT:
;	ES - has seg id of the SEGMENT
;	     that contains the input control blocks,
;	     defined below.
;
;	DI - offset into ES of the PARMS INPUT BLOCK
;
;	DS - has seg id of the SEGMENT
;	     that contains the DOS input COMMAND
;	     string, which is originally presented at 81h
;	     in the PSP.
;
;	SI - offset into DS of the text of the DOS input COMMAND string
;	     as originally presented at 81H in the PSP.
;
;	DX - zero
;
;	CX - ordinal value, intially zero, updated on each subsequent call
;	     to the value returned in CX on the previous call.
;
;	CS - points to the segment containing the
;	     INCLUDE PARSE.SAL statement
;
;	DS - also points to the segment containing the INCLUDE
;	     PARSE.SAL statement.
;
; EXIT-NORMAL:	Output registers:
;	 AX - return code:
;	    RC_No_Error     equ     0	 ; No error
;	    RC_EOL	    equ     -1	 ; End of command line
;
;	 DX - Offset into ES of the selected RESULT BLOCK.
;	 BL - terminated delimiter code
;	 CX - new operand ordinal
;	 SI - set past scanned operand
;
; EXIT-ERROR: Output registers:
;	 AX - return code:
;	    RC_Too_Many     equ     1	 ; Too many operands
;	    RC_Op_Missing   equ     2	 ; Required operand missing
;	    RC_Not_In_SW    equ     3	 ; Not in switch list provided
;	    RC_Not_In_Key   equ     4	 ; Not in keyword list provided
;	    RC_Out_Of_Range equ     6	 ; Out of range specified
;	    RC_Not_In_Val   equ     7	 ; Not in value list provided
;	    RC_Not_In_Str   equ     8	 ; Not in string list provided
;	    RC_Syntax	    equ     9	 ; Syntax error
;
; INTERNAL REFERENCES:
;    ROUTINES: SYSPARSE:near (INCLUDEd in PARSE.SAL)
;
;    DATA AREAS: none
;
; EXTERNAL REFERENCES:
;    ROUTINES: none
;
;    DATA AREAS: control blocks pointed to by input registers.
;
; NOTES:
;	 This module should be processed with the ASMUT preprocessor
;	 with the re-alignment not requested, as:
;
;		SALUT  NLSPARM,NUL;
;
;	 To assemble these modules, the sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;	 NLSFUNC.SAL
;
; REVISION HISTORY: A000 Version 4.00: add PARSER, System Message Handler,
;
; COPYRIGHT: "The DOS NLSFUNC Utility"
;	     "Version 4.00 (C)Copyright 1988 Microsoft
;	     "Licensed Material - Program Property of Microsoft "
;
;****************** END OF SPECIFICATIONS *****************************
	IF1
	    %OUT    COMPONENT=NLSFUNC, MODULE=NLSPARM.SAL...
	ENDIF
; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<MACRO DEFINITION>
; =  =	=  =  =  =  =  =  =  =	=  =

HEADER	MACRO	TEXT
.XLIST
	SUBTTL	TEXT
.LIST
	PAGE
	ENDM

; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<SYSPARSE - SYSTEM COMMAND LINE PARSER>
NLS_DATA SEGMENT BYTE PUBLIC  'DATA'

CAPSW   EQU	1			;SUPPORT FILENAME TBL CAPS
FARSW	EQU	0			;PARSER CALL FAR
FILESW  EQU	1			;CHECK FOR FILESPEC
SWSW	EQU	1			;SUPPORT CHECKING FOR SWITCHES
DATESW	EQU	0			;SUPPRESS DATE CHECKING
TIMESW	EQU	0			;SUPPRESS TIME CHECKING
CMPXSW	EQU	0			;SUPPRESS CHECKING COMPLEX LIST
NUMSW	EQU	0			;SUPPRESS CHECKING NUMERIC VALUE
KEYSW	EQU	0			;SUPPRESS KEYWORD SUPPORT
VAL1SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 1
VAL2SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 2
VAL3SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 3
DRVSW	EQU	0			;SUPPORT OF DRIVE ONLY FORMAT
QUSSW	EQU	0			;SUPPRESS SUPPORT OF QUOTED STRING FORMAT

;	 INCLUDE PSDATA.INC		 ;PARSE WORK AREA & EQUATES

NLS_DATA ENDS

NLS_INIT_CODE SEGMENT BYTE PUBLIC 'CODE'

;	 ASSUME  CS:NLS_INIT_CODE,DS:NLS_DATA
	 ASSUME  CS:NLS_INIT_CODE,DS:nothing ; tsuneo

;	 mov	 ax,NLS_DATA
;	 mov	 ds,ax

;INCSW	 equ	 0



	include version.inc
	INCLUDE PARSE.ASM
       PUBLIC  SYSPARSE

NLS_INIT_CODE ENDS
;NLS_DATA ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\nlsfunc.asm ===
PAGE	,132  ;
	TITLE	NLSFUNC - GET/SET CP & COUNTRY INFO   CHCP SUPPORT

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;**************************************************************************
;This is the NLSFUNC int2f command that supports the INT21h functions
;Get_Extended Country Information and the Set_codepage...
;NLSFUNC will read the COUNTRY.SYS information from disk , store the
;data in a buffer , then move the information into a buffer
;area specified by DOS.
;d:NLSFUNC {path}
;									 *
;CHECKINSTALL:								 *
;CheckRequest proc							 *
;	  If installed previously					 *
;	     report back error already installed and exit		 *
;	  otherwise  goto install					 *
;Checkrequest endp							 *
;*************************************************************************
;				NEW CODE				 *
;*************************************************************************
subttl get extended country data
page
;
;***************************************
;*  Process_Path Procedure	       *
;***************************************
;*  CALL SYSLOADMSG		       *
;*  Do DOS Version check	       *
;*  If ne X.X then (carry set)		*
;*   CALL SYSDISPLAY_MSG	       *
;*   DISPLAY_MSG(Message number 001)   *
;*    (001 - Incorrect DOS Version)    *
;*    (Class 3 - Utility Msg)	       *
;*   exit			       *
;*  else			       *
;*   Establish addressability	       *
;*   to command line parms (DS:SI)     *
;*   Establish addressability to PARM  *
;*   control block	   (ES:DI)     *
;*				       *
;*     Call SYSPARSE for filename      *
;*     GET Parse Block results	       *
;*     IF PARSE_ERROR		       *
;*	  CALL SYSDISPLAY_MSG (Class 2)*
;*	  DISPLAY_MSG = PARSE_NUM      *
;*     ELSE			       *
;*	  SUCCESSFUL_PARSE (0 or -1)   *
;*     ENDIFELSE		       *
;*     GET_PARSE_RESULTS Path_Spec     *
;*     IF No path exist then	       *
;*	  assume current directory     *
;*	  assume default filename      *
;*     ENDIF			       *
;*     IF No Drive exist then	       *
;*	  Use Current Drive	       *
;*     ENDIF			       *
;*     IF No filename exist then       *
;*	  assume default filename      *
;*	  and concatenate with drive   *
;*     ENDIF			       *
;*     CHECK_PATH		       *
;*     IF PATH EXIST THAN	       *
;*	  INSTALL_NLS	(NLS_RESCODE)  *
;*     ENDIF			       *
;*     ELSE NOT PATH_EXIST THAN        *
;*	  GET_PARSE_RESULTS (Class 3)  *
;*	  PASS_TO_MSGTXT (Message 003) *
;*	  (File not found %1)	       *
;*	  ERR_CODE SET TO 2	       *
;*	  EXIT			       *
;*     ENDIFELSE		       *
;*				       *
;*  INSTALL_NLS 		       *
;*	  CHECK INSTALL FLAG	       *
;*	  IF INSTALLED		       *
;*	     (Class 3)		       *
;*	     PASS_TO_MGSTXT (Msg 002)  *
;*	     %1 already installed      *
;*	  ELSE			       *
;*	     HOOK IN CODE	       *
;*	     TERMINATE & STAY RESIDENT *
;*	  ENDIFELSE		       *
;*				       *
;*				       *
;*   EXIT			       *
;*	 CHECK FOR ERRORCODE	       *
;*	 exit to DOS		       *
;***************************************
;
;INSTALL:
;	  Get the current 2f handler in the chain
;	  make it the next install my handler in the
;	  beginning of the the chain using get interrupt (25)
;	  and set interrupt (35); Once in the chain
;	  terminate and stay resident.
;
;DOS NEEDS ME.......
;
;Install Dos Interface Logic
;     Dos issues Call Install
;	     Establish residency
;	  If Mult Id is mine	(* NLSFUNC*)
;	     CheckInstall Status to see if installed or not
;	  otherwise
;	     jump to the next 2f handler
;CheckInstall
;	  If not installed returns
;	  If installed program is executed  (*NLSFUNC resident portion *)
;*******************************************************************************
;
;Program Logic
;
;     Check to make sure not reserved DOS number in the al
;
;     Go establish which function is to be performed
;
;Sel_Func proc
;	  mov FUNC_CODE,al
;	  case
;	     function code = 0
;	     function code = 1
;	     function code = 2
;	     function code = 3
;	     function code = 4
;	  otherwise error_routine
;	  return
;Sel_Func endp


;funcode0 proc
;INSTALL     NLSFUNC must be installed in mem
;	     return 0FFh that I am installed
;funcode0 endp

;funcode1 proc
;	    (* Means Set codepage and "select" device drivers*)
;	    same at funcode 3 plus device drivers are invoked with the
;	    specified code page.
;funcode1 endp

;funcode2 proc
;	   (* Get_extended_country info issued by DOS not in buffer*)
;	    BP = info_type
;	    call trans_Cty_Data Proc
;	    return
;funcode2 endp

;funcode3 proc
;	    (* Means Set codepage *)
;	    On entry DOS gives me the CODEP in BX & the CC in DX,SIZE in CX
;	     Search for Country.sys file on disk
;	    if file is found	  }BUFFER will exist in code 320 (can be altered)
;		the control buffer = 64 bytes of the buffer
;		the data buffer = 256 bytes of the buffer
;	     call Trans_Cty_Data Proc
;	    otherwise return an error flag
;	     return
;funcode3 endp


;funcode4 proc
;	   (* Get_extended_country info - old 38 call*)
;	    set flag and same as funcode 2
;	    data returned slightly Revised
;funcode4 endp

;	   ****************************
;	    if selected is FUNCTION 1, 3
;	       PassDOS_Data(*ES:DI*)
;	    otherwise FUNCTION 2, 4
;	       Get the INFO ID
;	       Flag that it is function 2
;	       PassUserData(*ES:DI*)
;	    mov NO_ERRORS to ERROR_FLAG
;	    ****************************
;Trans_Cty_Data Proc
;	     Open file(Dos call back 38)
;	     Do an LSEEK to move CTY_INFO into NLSFUNC control buffer 39
;	     Do an LSEEK to move tables into NLSFUNC data buffer 39
;	    if R/W pointer ok on Disk
;	     Read the file(Dos call back 38)
;	     Check to see if it is FUNCTION 1 or FUNCTION 2
;	       Flag if FUNCTION 2
;	       if FUNCTION 2
;		Search for user specified INFO ID
;		until found or report back error to DOS & exit
;		if INFO ID is found
;		   godo move the data and set the counter to zero (entry value)
;
;
;
;
;MOVE_DATA:    Manage transfer from disk to buffer
;	       Check to see if entire entry can fit in to the data
;	       buffer if not read the maximum allowed into buffer
;	       Check to see what is left to read; read until no more
;	       Search for appropriate field in the DOS INFO
;		if found move in info until complete
;		   get the next entry until number of entries is 0
;		otherwise
;		   report to DOS error and exit
;	     loop back to read file until (all entries are Obtained) or (EOF)
;	     Close file handle (Dos call back 40)
;	    otherwise mov 05h to error_flag & jump to error_routine
;
;	    return
;Trans ENDP
;
;
;Error_routine	proc
;	     mov al,error_flag
;	     return
;error_routine	endp
;*******************************************************************************
;**********************************INTRO****************************************
subttl	Revision History
page
;****************************** Revision History *************************** ;
;
; =A  7/29/86  RG   PTM P64
;     Prevent overwrite of DOS monocase routine entry point during
;     transfer of SetCountryInfo.
;     For Get Ext Cty Info, put DOS monocase routine entry point into
;     user buffer.
;
; =B  7/29/86  RG	 PTM P67
;     Correct jump condition in ERROR_ROUTINE of NLSRES_CODE.
;     This prevents exit without COUNTRY.SYS file close.
;
; =C  7/30/86  RG	 PTM P85
;     Preserve ES register in NLSFUNC for IBMDOS.
;
; =D  7/31/86  RG	 PTM P86
;     Corrects information put into user buffer for Get Extended
;     Country Information.
;
; =E  7/31/85  RG	 DCR 18
;     CHCP support.
;
; =F  8/4/86   RG
;     Get Country Info - Revised info from Get Extended Country Info
;
; =G  8/5/86   RG
;     Correct carry set for good exit.
;
; =H  8/5/86   RG
;     Start extended info at length instead of signature.
;
; =FC 8/14/86  FChen
;     Insert code for control buff management and actual length retunred
;
; =I  8/20/86  RG
;     Improve path parameter parsing.
;
; =J  8/22/86  RG
;     Change error codes
;
; =K  8/28/86  RG
;     65 call-get ext cty info	put final csize (# bytes returned)
;     in cx on iret ;
;
; =L  11/7/86  RG
;     Set error to INVALID DATA (13) on no cp/cty match.
;
; =M  05/20/87 CNS
;     Additional re-design for structured code using STRUC
;     PARSER implementation
;     Message Retriever implementation
;     DBCS Support for Environmental Vector recognition (Walk Devices& IOCTL call)
;     Enable the Interrupt when NLSFUNC is loaded PTM ???
;
;AN001; P2685 NLSFUNC should not visit the same device repeatedly. 01/15/88 J.K.
;AN002; P3934 Bad write on sacred DOS area - segmentation incorrect  03/22/88 CNS
;*******************************************************************************
subttl macros
page
PUSHALL       macro  reg1,reg2,reg3			;used to save all
		push reg1				;registers needed
		push reg2				;for DOS interactions
		push reg3
	      endm

POPALL	     macro   reg1,reg2,reg3			;used to restore all
		pop reg3				;for DOS interactions
		pop reg2
		pop reg1
	      endm

;SHOWERR       macro   msg,len_msg
;		 mov	 ah,40h
;		 mov	 bx,2
;		 lea	 dx,msg 			 ;displays error msgs
;		 mov	 cx,len_msg
;		 int	 21h
;		endm


EXTRN		SYSPARSE:NEAR

subttl NLSFUNC data
page
NLS_DATA	SEGMENT byte PUBLIC 'DATA'

;Copyright 1988 Microsoft
;***************************** MSG DATA ************************************
UTILITY 	db	"NLSFUNC",0           ;AC000;
;***************************** MSG DATA ************************************

.xlist
include copyrigh.inc			;AN000;
include struc.inc
include DOESMAC.INC
include MULT.INC
include sf.inc				;AN001;
include DOSCNTRY.INC
include DEVSYM.INC
include SYSMSG.INC			;AN000;
include FUNCDBCS.INC			;AN000;
include MSG2NLS.INC
include FUNCPARM.INC			;AN000;
include version.inc			; MSKK02 07/18/89
MSG_UTILNAME <NLSFUNC>			;AN000;

.list

MSG_OPTIONS_FIRST	equ	300	; first options message line
MSG_OPTIONS_LAST        equ     302     ; last options message line

MULT_NLSFUNC	equ	14h
INSTALLED	equ	0ffh
; nlsfunc function codes
CHG_CODEPAGE	 equ	1
GET_EXT_CTY_INFO equ	2
SET_CODEPAGE	 equ	3
GET_CTY_INFO	 equ	4

INVALID_FUNCTION equ	1		     ;=J
INVALID_DATA	 equ	13		     ;=L
;FILE_NOT_FOUND  equ	2		     ;=J(=L no longer explicitly used)
;TAB		  equ	 9
;CR		  equ	 13
PAD_CHAR	 equ	' '                  ;AN000;
BAD_INVOKE	 equ	65		     ;=E
UPCASE_A	 equ	'A'
BUFFSIZE	 equ	512 ;	      ;AC000;REDUCTION OF ORIGINAL (128 BYTES) TO STORE
LOCATE_INFOTYPE  equ	18	      ;THE DEVICE LIST & THE OLD COUNTRY INFO
CTL_BUFF	 equ	256 ;	      ;AC000;
ID_TAG		 equ	8
DATA_BUFF_LENG	 equ	(BUFFSIZE - CTL_BUFF)
MAXBUFF_FIT	 equ	(BUFFSIZE - (CTL_BUFF + ID_TAG))
DATA_N_ID	 equ	(CTL_BUFF + ID_TAG)
SETCTY_LENG	 equ	38
;SPACE		  equ	 ' '
BACKSLASH	 equ	'\'
PERIOD		 equ	'.'
;COLON		  equ	 ':'
;
;**************** NEW VARIABLE	****************
subttl NLSFUNC data
page
IN_DEX		  equ	 bp			       ;AN000;
FILESPEC_PTR	  equ	 byte ptr ds:[in_dex]	       ;AN000;
FILEVAL 	 equ	0100h	;convert data block after checking for the
				;AN000;
				;drive only to look for the filespec
CL_NUM		 equ	81h	;command line at the PSP
				;AN000;
;**************** NEW VARIABLE	****************
;interrupts
SET_INT 	 equ	25h
GET_INT 	 equ	35h
;
;dos call backs
;dosopen	 equ	38
;dosclose	 equ	39
;lseek		 equ	40
;dosread	 equ	41
;
;NO_ERRORS	 equ	0FFh

;variable definition area
;initialization area

MSG_SERVICES <MSGDATA>
; Replace a bunch of bytes that are storing one byte (0 or 1) for one
; byte where I control each bit.

ID_CHECK_F      equ     00000001b
GET_EXT_F       equ     00000010b
GOOD_PAR_F      equ     00000100b
PARSE_ERR_F     equ     00001000b
EXIT_STAY_F     equ     00010000b
NO_PARMS_F      equ     00100000b
GOOD_PATH_F     equ     01000000b
OPTIONS_SENT_F  equ     10000000b

INFO_FLAG       db      ID_CHECK_F      ;Only ID_CHECK_F set, the rest 0




;ID_CHECK        db      1               ;resident variable re-initialize
ALL_DONE	db	0		;resident variable re-initialize
;GET_EXT         db      0               ;resident variable re-initialize
INFO_ID 	db	0		;resident variable re-initialize
DONT_CLOSE	db	0		;if open or close error,this is set

RES_PARASIZE	dw	0		;adjusted size for terminate & stay func.
ERROR_CODE	db	0		;contains extended error code val
FUNC_CODE	db	0		;save function number
;GOOD_PAR        db      0
;PARSE_ERR       db      0

SI_DOSLOCATE	dw	0
DS_DOSLOCATE	dw	0
SAVEDX		dw	0		;=FC  file offset
SAVECX		dw	0		;=FC
NOFFSET 	dw	2		;=FC
CSIZE		dw	0
CCODE		dw	0
CPAGE		dw	0
;VALID_FUNC      db      0               ;Flag to check for valid function #
;EXIT_STAY       db      0
FILENAME	db     "COUNTRY.SYS",0
PATH_SPEC	db	64 dup(0)	;used to build path parameter
USER_PATH	db	0		;=I
PAR_RETC	dw     0
;NO_PARMS        db     0
;GOOD_PATH       db     0
;OPTIONS_SENT    db      0               ; non-zero if options msg displayed
PATHSEG 	DW     0
SW_SPEC 	dW     0
;LENGTH_HOLD     db     0                  ;dead code
;***CNS
CUR_PTR        DW	0		   ;AN003;; keeps track of parameter position	   ;AN000
OLD_PTR        DW	0		   ;AN003;; keeps track of parameter position	   ;AN000
;***CNS
;********************************************************************************
NLS_BUFFER	db	BUFFSIZE dup (?)  ;NLS BUFFER to transfer data


DATASIZE	equ	$-NLS_DATA

NLS_DATA ENDS

NLS_INIT_CODE	SEGMENT BYTE PUBLIC 'CODE'

		ASSUME CS:NLS_INIT_CODE,DS:NOTHING,ES:NOTHING,SS:NOTHING



INT_2f_NEXT	DD	?	;Chain location.
subttl resident code
page
;**************************** resident portion ********************************

NLSRES_CODE	PROC	NEAR
		cmp	ah,MULT_NLSFUNC 	;Check the mutliplex value
		je	IS_NLSFUNC		;the # is mine
		jmp	dword ptr INT_2F_NEXT	;Chain to* the next handler

IS_NLSFUNC:


		cmp	al,0f8h 	;Make sure AL does not have reserved
					;DOS value 0F8 - 0FFH
		jb	SEL_FUNC	;Select the function code between 0,
					;1,2,3,4

		iret			;return on reserved functions

SEL_FUNC:


		push	es		;=C
		push	ds		;save the user's data segment
		push	si
		push	ds
		push	ax		;save the function value


		mov	ax,NLS_DATA	;so it won't be hosed
		mov	ds,ax		;set the data segment to mine

		ASSUME DS:NLS_DATA

		pop	ax
		pop	DS_DOSLOCATE
		pop	SI_DOSLOCATE

                mov     INFO_FLAG,ID_CHECK_F    ;re-initalize flags
                mov     ALL_DONE,0              ;from resident portion
                mov     DONT_CLOSE,0            ;no open or close error yet

		pushall bx,cx,dx	;save all DOS registers
		pushall bp,si,di	;save all DOS registers
; *************************** CNS **********************************************
		sti			;;AN000;the interrupt for external devices
					;AN000;
; *************************** CNS **********************************************
		mov	FUNC_CODE,al	;save function #
;               or      al,al
;               jnz     FUNCODE_DOSTATE ;state is not 0
                dec     al              ;Tell DOS I am installed (dec 0 = ff)
                js      RES_EXIT        ;state is 0
;               jmp     short RES_EXIT  ;exit


FUNCODE_DOSTATE:
;               dec     al                              ;cmp     al,CHG_CODEPAGE
                jz      FUNCODE3_1                      ;je      FUNCODE3_1
                dec     al                              ;cmp     al,GET_EXT_CTY_INFO
                jz      FUNCODE2                        ;je      FUNCODE2
                dec     al                              ;cmp     al,SET_CODEPAGE
                jz      FUNCODE3_1                      ;je      FUNCODE3_1
                                                        ; If al >= 4 then do 4


FUNCODE4:     ;Get Country Data - old 38 call =F
		mov	bp,1		;set info_id to 1 =F
;               jmp     short FUNCODE2  ;                 =F


FUNCODE2:      ;Get Extended Country Information
		mov	ax,bp		;information requested by the user
		mov	INFO_ID,al
                or      INFO_FLAG,GET_EXT_F ;get extended cty into user buffer
		call	RES_MAIN
		jc	ERROR_ROUTINE

		jmp	short CLOSE_FILE	  ;=E



FUNCODE3_1:    ;Set Codepage/Get Country Information =E
		les	di,dword ptr SI_DOSLOCATE
;		cmp	es:[di].ccDosCodePage,bx	;=E
;		jne	fc3_1_10			;=E
;		cmp	es:[di].ccDosCountry,dx 	;=E
;		jne	fc3_1_10			;=E
;		mov	CPAGE,bx	     ;get the codepage value =E
;		jmp	short fc3_1_20			;=E
;
;fc3_1_10:
		call	RES_MAIN
		jc	ERROR_ROUTINE
		CallInstall Dosclose,multdos,39,<ax,bx,cx,dx,ds,es>,<es,ds,dx,cx,bx,ax> ;close the file
		jc	NO_CLOSE

fc3_1_20:
		cmp	FUNC_CODE,1	       ;=E
		je	FUNCODE1	       ;=E
		mov	al,ALL_DONE	       ;=E
		jmp	short RES_EXIT	       ;=E


FUNCODE1:      ;CHCP - Change Code Page    =E
		call	WALK_DEVICES	    ;=E
		mov	al,ALL_DONE	    ;=E
		jmp	short RES_EXIT	    ;=E

NO_CLOSE:
		mov	ALL_DONE,al	;=J
		inc	DONT_CLOSE

;if an error was detected

ERROR_ROUTINE:
		mov	al,ALL_DONE
		cmp	DONT_CLOSE,1
		je	RES_EXIT
;               jmp     CLOSE_FILE



CLOSE_FILE:				     ;DOS  3eh function close COUNTRY.SYS
		mov	al,ALL_DONE

		CallInstall Dosclose,multdos,39,<ax,bx,cx,dx,ds,es>,<es,ds,dx,cx,bx,ax> ;close the file
		jc	NO_CLOSE
						;clear to let DOS know ok


RES_EXIT:
		popall	bp,si,di	;restore all DOS registers
		popall	bx,cx,dx	;restore all DOS registers

		cmp	FUNC_CODE,GET_EXT_CTY_INFO ;			  =K
		jne	NC_IRET 	;				  =K
                or      al,al           ;if successful 65 call, put size  =K
                jnz     NC_IRET         ;of info returned in CX           =K
		mov	cx,CSIZE	;				  =K

NC_IRET:				;				  =K
		pop	ds		;restore user's data segment  =K moved
		pop	es		;=C			      =K moved
		iret			;Return to DOS


NLSRES_CODE	ENDP
;*******************************END OF NLSRES_CODE******************************
subttl resident main routine
page
;*******************************RES_MAIN****************************************
RES_MAIN	PROC	NEAR

;               mov    VALID_FUNC,1     ;function exist   ; dead code?
		mov    CPAGE,bx 	;get the codepage value
		mov    CCODE,dx 	;get the country code
		mov    CSIZE,cx 	;size of the buffer
;               call   CHK_OPEN         ;go open file if possible

; instead of calling the procedure, I include the procedure here
; Begining of procedure CHK_OPEN

                xor     cx,cx                           ;zero cx for open
                cmp     USER_PATH,1                     ;either user supplied=I
                je      co_user                         ;or default DOS

co_dos:         push    ds                              ;save current ds value
                push    si                              ;save current si value
                lds     si,dword ptr SI_DOSLOCATE       ;old dos ds si value
                lea     dx,ds:[si].ccPATH_COUNTRYSYS
                CallInstall Dosopen,Multdos,38,<BX,DS,ES,SI,DI>,<DI,SI,ES,DS,BX>
                pop     si                              ;restore current si
                pop     ds                              ;restore current ds
                jmp     short co_10

co_user:        lea     dx,PATH_SPEC
                CallInstall Dosopen,Multdos,38,<BX,DS,ES,SI,DI>,<DI,SI,ES,DS,BX>

co_10:          jc      BADREP_FILE                     ;bx contains the
                mov     bx,ax                           ;file handle
                jmp     short END_OPEN

BADREP_FILE:
                mov     ALL_DONE,al                     ;=J
                inc     DONT_CLOSE

END_OPEN:
; End of procedure CHK_OPEN

		jc     END_RES		;scan and read country info

		mov	ax,CCODE
		mov	dx,CPAGE
		mov	si,offset NLS_BUFFER
		call	Trans_Cty_Data
					;into my buffer & the dos buffer
  END_RES:
		ret

RES_MAIN	ENDP
;*******************************END RES_MAIN************************************
subttl	check open procedure
page
;******************************CHECK OPEN PROCEDURE****************************
;CHK_OPEN        PROC    NEAR
;
;
;                xor     cx,cx                           ;zero cx for open
;                cmp     USER_PATH,1                     ;either user supplied=I
;                je      co_user                         ;or default DOS
;
;co_dos:         push    ds                              ;save current ds value
;                push    si                              ;save current si value
;                lds     si,dword ptr SI_DOSLOCATE       ;old dos ds si value
;                lea     dx,ds:[si].ccPATH_COUNTRYSYS
;                CallInstall Dosopen,Multdos,38,<BX,DS,ES,SI,DI>,<DI,SI,ES,DS,BX>
;                pop     si                              ;restore current si
;                pop     ds                              ;restore current ds
;                jmp     short co_10
;
;co_user:        lea     dx,PATH_SPEC
;                CallInstall Dosopen,Multdos,38,<BX,DS,ES,SI,DI>,<DI,SI,ES,DS,BX>
;
;co_10:          jc      BADREP_FILE                     ;bx contains the
;                mov     bx,ax                           ;file handle
;                jmp     short END_OPEN
;
;BADREP_FILE:
;                mov     ALL_DONE,al                     ;=J
;                inc     DONT_CLOSE
;
;END_OPEN:
;                ret
;
;   CHK_OPEN     ENDP
;******************************END OF CHKOPEN**********************************
subttl transfer country data
page
;******************************TRANS_CTY__DATA ********************************
TRANS_CTY_DATA	PROC	NEAR

TRANSTART:
		push	di			;save start of CTY/CP INFO
						;get the size of the file
		xor	cx,cx			;clear cx to start at
		xor	dx,dx			;at the beginning of the
						;file
		call	READ_CTLBUFF		;Read in the file header
                jnc     CHK_INFOTYPE
                jmp     END_TRANS               ;=G

CHK_INFOTYPE:
		add	si,LOCATE_INFOTYPE	;si > Country info type
		cmp	byte ptr ds:[si],1	;only 1 type exist currently
		je	GET_INFOIDS
		jmp	BAD_FILE
GET_INFOIDS:
		inc	si			;si > set to file offset
		mov	dx,word ptr ds:[si]	;Get the Info file offset
		mov	cx,word ptr ds:[si+2]	;Doubleword

		mov	SAVEDX,dx		;=FC save offset
		mov	SAVECX,cx		;=FC for more than 1 buffer
		mov	NOFFSET,2		;=FC start from beginning

		call	READ_CTLBUFF		;Read Info
                jc      Bridge_END_TRANS
;               jmp     END_TRANS               ;=G

COUNT_ENTRIES:

		mov	cx,word ptr ds:[si]	;Get count of entries
						;in info
		inc	si			;next word
		inc	si			;si >  Entry info packet

FIND_CTY:					;Search for CTY/CP combo

		mov	ax,word ptr ds:[si]	;=FC get size of entry
                inc     ax                      ;=FC include length filed
                inc     ax
		add	NOFFSET,ax		;=FC look ahead
		cmp	NOFFSET,CTL_BUFF-4	;=FC < (256 - 4)
		jb	IN_BUFF 		;=FC
		sub	NOFFSET,ax		;=FC restore to old offset
		push	cx			;=FC save number of cntries
		mov	cx,SAVECX		;=FC get file offset
		mov	dx,SAVEDX		;=FC
		add	dx,NOFFSET		;=FC update to the entry
		adc	cx,0			;=FC beginning
		mov	SAVECX,cx		;=FC save them for next use
		mov	SAVEDX,dx		;=FC
		call	READ_CTLBUFF		;=FC read next buffer in
		jc	READERROR		;=FC read error occurs
		pop	cx			;=FC restore number of cntries
		mov	NOFFSET,0		;=FC a new beginning
IN_BUFF:

		mov	dx,CPAGE
		mov	ax,CCODE
		cmp	ax,word ptr ds:[si+2]	 ;compare country id
		jne	NEXT_CTY
		cmp	dx, word ptr ds:[si+4]	;compare code page id
		je	FOUND_CTY
                or      dx,dx             ;=FC    if default pick the
		jz	FOUND_CTY2	  ;=FC	  1st country

NEXT_CTY:
		add	si, word ptr ds:[si]	;next entry
		inc	si
		inc	si			;take a word for size of entry itself
		loop	FIND_CTY

		mov	ALL_DONE,INVALID_DATA	;if it exits the loop	=J =L
		jmp	FINDCTY_FAIL		;then no cp/cty match

READERROR:	pop	cx			;=FC
Bridge_END_TRANS:
                jmp     END_TRANS               ;=FC

FOUND_CTY2:	mov	dx,word ptr ds:[si+4]	;=FC from now on,this is
		mov	CPAGE,dx		;=FC the code page

FOUND_CTY:		       ;found the matching entry
		mov	dx, word ptr ds:[si+10] ;get the file offset of country data
		mov	cx, word ptr ds:[si+12]
		call	READ_CTLBUFF
                jc      Bridge_END_TRANS
;               jmp     END_TRANS               ;=G
NUM_ENTRY:
		mov	cx, word ptr ds:[si]	;get the number of entries to handle.
		inc	si
		inc	si			;SI -> first entry

SETDOSCTY_DATA:
.REPEAT
		 push	 di			 ;ES:DI -> DOS_COUNTRY_CDPG_INFO
		 push	 si			 ;si -> current entry in Control buffer
		 push	 cx			 ;save # of entry left

		mov	al, byte ptr ds:[si+2]	;get data entry id
		xor	ah,ah			;clear out for comparison with
						;info-id in case id is > 256



                test    INFO_FLAG,GET_EXT_F     ;check to see if function 2
						;get_extended info was needed
                jz      TRANSALL                ;if not assume function code 1
						;set codepage

		cmp	INFO_ID,-1		;Minus 1 means return all of the
		jne	CHK_ID			;country info to the user
						;otherwise get the specific
						;info id and return only that info


		pop	cx			;error can not return all
		pop	si			;info accept for currently
		pop	di			;loaded control info in DOS
		jmp	BAD_SETID		;area

CHK_ID: 	cmp	al,INFO_ID		;check to see if the selected
						;id is the same as the id in the
						;ctrl buffer area

		jne	SETDOSCTY_NEXT		;if not equal go search for the
						;next information id

		pop	cx			;Bingo!! Found it set counter
		mov	cx,1			;to zero to exit loop
		push	cx

                and     INFO_FLAG,NOT ID_CHECK_F    ;Turn bit off.  found a valid id
                test    INFO_FLAG,GET_EXT_F         ;after transferring data to USER
                jnz     GET_ADDR                    ;area

						;set cx image in stack to force
						;exit loop
TRANSALL:



		call	GetDOSCTY_Dest		   ;get the address of destination in ES:DI
		jc	SetDOSCTY_NEXT		   ;No matching data entry id in DOS

GET_ADDR:

		mov	dx, word ptr ds:[si+4]	   ;get offset of data
		mov	cx, word ptr ds:[si+6]



SEEK_READ:

		push	ax			   ;=A	save data id.
		xor	bp,bp						;DOS 4200h function
		CallInstall Lseek,multdos,40,<bx,cx,ds,es,di,si>,<si,di,es,ds,cx,bx>		 ;move ptr
		pop	ax			   ;=A
		jc	DATASEEKNREAD
										     ;when ptr moved
		mov	dx,offset NLS_BUFFER +CTL_BUFF							;set the buffer to the beginning of the
										     ;data buffer area

		mov	cx,DATA_BUFF_LENG					     ;set to number of bytes in the
										     ;data buffer area
		push	ax			   ;=A
								       ;DOS 3fh
		CallInstall Dosread,Multdos,41,<bx,cx,ds,es,di,si>,<si,di,es,ds,cx,bx>		 ;Read cx many bytes into the buffer
		pop	ax			   ;=A
		jc    DATASEEKNREAD

IS_EXTENDED:
                test    INFO_FLAG,GET_EXT_F
                jz      CHK_OVERWRITE
		call	GETEXT_CTY
		jmp	short SETDOSCTY_NEXT


CHK_OVERWRITE:					   ;=A
						   ; If SetCountryInfo, then
						   ; put DOS monocase routine
						   ; entry point into
						   ; NLS_BUFFER so don't
						   ; write over.  =A

						   ; MSKK02 07/18/89
		call	SetDBCS_before_clear	   ; check DBCS vector set


		cmp	al,SetCountryInfo	   ;=A
		jne	DOS_MOVE		   ;=A
		mov	ax,word ptr es:[di+24]	   ;=A
		mov	word ptr ds:[NLS_BUFFER+CTL_BUFF + 32],ax  ;=A
		mov	ax,word ptr es:[di+26]	   ;=A
		mov	word ptr ds:[NLS_BUFFER+CTL_BUFF + 34],ax  ;=A

		mov	ax,CPAGE		   ;=FC, CPAGE is right
		mov	word ptr ds:[NLS_BUFFER+CTL_BUFF + 12],ax  ;=FC

DOS_MOVE:
		call	CHK_ADJUST						     ;now check to see if the entire
										     ;table fits

SETDOSCTY_NEXT:

		pop	cx
		pop	si
		pop	di
		add	si, word ptr ds:[si]
		inc	si
		inc	si
		dec	cx
		.UNTIL <cx eq 0>    NEAR		     ;loop    SETDOSCTY_DATA

		;Check for an invalid id
                test    INFO_FLAG,GET_EXT_F     ;Check to see if a get_ext func 2 was issued
                jz      CTLSEEKnREAD            ;if not move on
                test    INFO_FLAG,ID_CHECK_F    ;if so check to see if an id was found
                jnz     BAD_SETID               ;if none was found report an error
                                                ;otherwise continue



CTLSEEKnREAD:
		clc				;=G
		jmp	short END_TRANS 	;exit



DATASEEKnREAD:
		mov    ALL_DONE,al		;=J
		pop	cx
		pop	si
		pop	di
		jmp    short END_TRANS

BAD_SETID:
;               mov     ALL_DONE,INVALID_FUNCTION  ;=J
;               jmp    short FINDCTY_FAIL          ;=J

BAD_FILE:
		mov	ALL_DONE,INVALID_FUNCTION  ;=J

FINDCTY_FAIL:
		stc

END_TRANS:
		pop	di			;Restore header start
		ret



TRANS_CTY_DATA	ENDP

						; MSKK02 07/18/89
SetDBCS_before_clear:
		cmp	al,SetDBCS		; DBCS vector set?
		jnz	@F			; jump if not
		cmp	word ptr es:[di], 0	; zero byte data block?
		jz	@F			; jump if so
		push	di			;
		push	ax			;
		push	cx			;
		mov	cx,es:[di]		; load block length
		add	di,2			; points actual data
		xor	al,al			; fill bytes
		rep	stosb			; clear data block
		pop	cx			;
		pop	ax			;
		pop	di			;
@@:
		ret				;

;******************************END TRANS_CTY_DATA ******************************
subttl get DOS country destination
page
;****************************GETCTY_DEST***********************************************
GetDOSCty_Dest	 proc	 near
;Get the destination address in the DOS country info table.
;Input: AL - Data ID
;	ES:DI -> DOS_COUNTRY_CDPG_INFO
;On return:
;	ES:DI -> Destination address of the matching data id
;	carry set if no matching data id found in DOS.

	push	cx
	add	di, ccNumber_of_entries ;skip the reserved area, syscodepage etc.
	mov	cx, word ptr es:[di]	;get the number of entries
	inc	di
	inc	di			;SI -> the first start entry id
GetCntryDest:
	cmp	byte ptr es:[di], al
	je	GetCntryDest_OK
	cmp	byte ptr es:[di], SetCountryInfo ;was it SetCountryInfo entry?
	je	GetCntryDest_1
	add	di, 5			;next data id
	jmp	short GetCntryDest_loop

GetCntryDest_1:
	add	di, NEW_COUNTRY_SIZE + 1 ;next data id

GetCntryDest_loop:
	loop	GetCntryDest
	stc
	jmp	short	GetCntryDest_exit

GetCntryDest_OK:

	cmp	al, SetCountryInfo	;select country info?
	jne	GetCntryDest_OK1
	inc	di			;now DI -> ccCountryInfoLen
	clc				;clear the carry
	jmp	short	GetCntryDest_exit

GetCntryDest_OK1:

	les	di, dword ptr es:[di+1] ;get the destination in ES:DI
	clc

GetCntryDest_Exit:
	pop	cx
	ret

GetDOSCty_Dest	 endp
;****************************GETDOSCTY_DEST*************************************
subttl get extended country data
page
;****************************GETEXT_CTY*****************************************
GETEXT_CTY	proc

JUSTONE_ID:
		mov	ah,func_code	;=F
		cmp	ah,GET_CTY_INFO ;=F
		je	id_ctyinfo1	;=F

		mov	al,INFO_ID
		mov	byte ptr es:[di],al

		cmp	INFO_ID,SetCountryInfo ;SETCTY_INFO  =D moved.
		je	ID_CTYINFO	       ;=D don't want ptr if 1.

		mov	word ptr es:[di+1],offset nls_buffer + ctl_buff+8  ;=H
		mov	word ptr es:[di+3],ds	     ;my current ds value
		mov	CSIZE,5 		     ;=K

		jmp	short GET_EXT_END

ID_CTYINFO:
		inc	di		;=D  (old code - add di,5) =F(moved).
id_ctyinfo1:				;=F
		mov	cx,CSIZE
					;next line used to be "add si,5"
					;si needs to point to cty info. =D
		mov	si,offset nls_buffer + ctl_buff + 8  ;=D

		push	es		;=A  put DOS Monocase Routine
		push	di		;=A  entry point in user buffer.
		push	ax		;=A
		les	di,dword ptr si_doslocate ;=A
		mov	ax,word ptr es:[di].ccMono_Ptr	  ;=A
		mov	word ptr ds:[si+24],ax		  ;=A
		mov	ax,word ptr es:[di].ccMono_Ptr+2  ;=A
		mov	word ptr ds:[si+26],ax		  ;=A

		mov	ax,CPAGE			  ;=FC trust CPAGE
		mov	word ptr ds:[si+4],ax		  ;=FC

		pop	ax		;=A
		pop	di		;=A
		pop	es		;=A

		push	bx		;=F
		cmp	ah,GET_CTY_INFO ;=F if get cty info(38) slide info
		jne	id_ctyinfo2	;=F ptr up to date.
		add	si,6		;=F
		mov	cx,old_country_size ;=FC
		jmp	short MOVE_CTY	 ;=FC

id_ctyinfo2:	mov	bx,word ptr ds:[si]	;=FC get table size


		sub	CSIZE,3 	;=FC  size begins after length field
		mov	cx,CSIZE	;=FC

		cmp	cx,bx			;=D was cmped to SETCTR_LENG
		ja	TRUNC_SIZE	;=FC  used to be jg
		jmp	short  MOV_SIZE
TRUNC_SIZE:
		mov	cx,bx		;=F
MOV_SIZE:
		mov	es:[di],cx	;=FC  move actual length to user's buff
                inc     di              ;=FC  update index
                inc     di
                inc     si              ;=FC  skip length field
                inc     si

MOVE_CTY:	pop	bx		;=F
		mov	CSIZE,cx	;=K
		add	CSIZE,3 	;=K
		rep	movsb

GET_EXT_END:
		ret

GETEXT_CTY	endp
;*****************************END GETEXT_CTY*************************************
subttl read into control buffer
page
;**************************READ_CTLBUFF*****************************************
;
READ_CTLBUFF		proc	near
;Move file pointer to CX:DX
;Read 64 bytes into the control buffer.  Assume that the necessary data
;is within that limit.
;SI will be set to beginning of the offset my NLS_BUFFER hence DS:SI points to the control buffer.
;Entry:  CX,DX offset from the start of the file where the read/write pointer
;	 be moved.
;	 BX - file handle
;	 DS - buffer seg.
;Return: The control data information is read into DS:0 - DS:0200.
;	 CX,DX value destroyed.
;	 Carry set if error in Reading file.
;
								    ;Function 4200h
		xor	bp,bp
		CallInstall Lseek,multdos,40,<bx,cx,ds,es,di,si>,<si,di,es,ds,cx,bx>	;move pointer
		jc	NO_SEEK1

		mov	dx,offset NLS_BUFFER	  ;ds:dx -> control buffer
		mov	si,dx			  ;index for the entire buffer
						  ;read into the buffer function 3fh
		mov	cx, CTL_BUFF		  ;XXX bytes. Size of the information
		CallInstall Dosread,multdos,41,<bx,cx,dx,ds,es,di,si>,<si,di,es,ds,dx,cx,bx>	;should be less than XXX bytes.
		jc	NO_READ1
		jmp	short RICB_exit


NO_SEEK1:
;                mov    ALL_DONE,al               ;=J
;                jmp    short RICB_exit

NO_READ1:
		 mov	ALL_DONE,al		  ;=J

RICB_exit:				  ;In this case 64 bytes
		  ret

READ_CTLBUFF	  endp
;****************************END READ_CTLBUFF***********************************
subttl check / adjust / move data into DOS buffer
page
;****************************CHK_ADJUST*****************************************
CHK_ADJUST	PROC  NEAR

		push	ax			;save info id
		mov	si,offset NLS_BUFFER+DATA_N_ID		  ;start of buffer + tag id
		mov	cx, word ptr ds:[si]	;get the length of the structure

		inc	cx
		inc	cx

		cmp	cx,MAXBUFF_FIT
		jbe	MOVE_DATA
		push	cx
		mov	cx,MAXBUFF_FIT
		rep	movsb
		pop	cx
		sub	cx,MAXBUFF_FIT

NEED_ADJUST:
		mov	dx,offset NLS_BUFFER+CTL_BUFF		  ;reset to the beginning of the data buffer
		mov	si,dx			;reset to the beginning of the data buffer
		cmp	cx,DATA_BUFF_LENG	;check to see if it fits for the nth read
		jbe	LAST_READ		;last portion fits
		push	cx			;save how much is left to read
		mov	cx,DATA_BUFF_LENG	;set to how much you read at one time

		;read again					      ;function 3fh
						      ;read into the data buffer
		CallInstall Dosread,multdos,41,<bx,cx,dx,ds,es,di,si>,<si,di,es,ds,dx,cx,bx>  ;save the file handle
		jc	ADJUST_END

		rep	movsb			      ;move data into DOS area
		pop	cx			      ;restore size remaining to
		sub	cx,DATA_BUFF_LENG	      ;be read get new size
		jmp	NEED_ADJUST			  ;must read agian

LAST_READ:
						      ;one more read 3f
		 CallInstall Dosread,multdos,41,<bx,cx,dx,ds,es,di,si>,<si,di,es,ds,dx,cx,bx>
		 jc	ADJUST_END

MOVE_DATA:
		rep	movsb			      ;move data into DOS area

ADJUST_END:
		pop	ax
		ret
CHK_ADJUST	ENDP
;*******************************END CHK_ADJUST *********************************
subttl walk through device drivers and invoke
page
;************************ WALK DEVICE DRIVERS **********************************
;=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=E=

WALK_DEVICES	PROC  NEAR

		mov	si,offset NLS_BUFFER ;Prepare to hold device name
		push	es			;AN001; Clear out NLS_BUFFER to 0
		push	ds			;AN001;
		pop	es			;AN001;
		mov	di, si			;AN001; ES:DI-> NLS_BUFFER
		xor	ax, ax			;AN001; AX=0
		mov	cx, BUFFSIZE		;AN001;
		shr	cx, 1			;AN001; /2 to make a # of words
		rep	stosw			;AN001;
		pop	es			;AN001; Restore es
						;Get ptr to hdr of 1st device.
		push	si			;AN001;
		CallInstall GetDevLst,Multdos,44,<DS>,<DS>
		pop	si			;AN001;
		mov	es,bx		    ;bx:ax -> hdr.
		mov	di,ax
char_test:
		test	es:[di].sdevatt,devtyp ;check attribute word for
                je      BR_GET_NEXT_DEVICE
;               jmp     GET_NEXT_DEVICE        ;character device.

OPEN_DEVICE:
		push	si
		push	di		    ;set up asciiz filename
		add	di,10		    ;for DOS file open
		mov	cx,8

set_asciiz:	mov	al,es:[di]
		cmp	al,20h
		je	done_set_asciiz
		mov	ds:[si],al
		inc	di
		inc	si
		loop	set_asciiz

done_set_asciiz:xor	al,al
		mov	ds:[si],al

		pop	di
		pop	si

		mov	cx,1		    ;open for write
		mov	dx,si
		CallInstall Dosopen,Multdos,38,<DS,SI,ES,DI>,<DI,ES,SI,DS>
		jnc	end_open_device

BR_GET_NEXT_DEVICE:
		jmp	GET_NEXT_DEVICE     ; ignore this =FC

end_open_device:
		mov	bx,ax		    ;put handle in bx
		call	Chk_Revisit	    ;AN001; Have been here already?
                jc      BR_CLOSE_DEVICE     ;AN001; No, a new one.
;               jmp     short CLOSE_DEVICE    ;AN001; Yes. Close and ignore this.

INVOKE_DEVICE:
		push	ds		    ;Check print queue first.
		push	si		    ;Set up for 2f print call.
		clc
		mov	ax,0106h	    ;2f call to command.com.
		int	2fh		    ;If print active: carry set,
		jnc	invoke_it	    ;DS:SI -> hdr of printing device.
		cmp	si,di		    ;Check if printing device is this
		jne	invoke_it	    ;device.  Match on ptr to device.
		mov	ax,ds
		mov	cx,es
		cmp	ax,cx
		jne	invoke_it

		pop	si
		pop	ds
		mov	ALL_DONE,BAD_INVOKE ;Match.  Set invoke error.

BR_CLOSE_DEVICE:
		jmp	short CLOSE_DEVICE

invoke_it:	pop	si			     ;save the current
		pop	ds				;environment

;*************** CNS *********** Start of DBCS Support
;  PUSH    DS			   ;ICE
;  push    bx			   ;ICE
;  push    ax			   ;ICE
;  mov	   bx,0140H		   ;ICE
;  xor	   ax,ax		   ;ICE
;  mov	   ds,ax		   ;ICE
;  mov	   ax,word ptr ds:[bx]	   ;ICE
;  mov	   word ptr ds:[bx],ax	   ;ICE
;  POP	   ax			   ;ICE
;  pop	   bx			   ;ICE
;  pop	   ds			   ;ICE
	       push    di
	       push    bx
	       push    cx
	       push    es
	       les     di,dword ptr SI_DOSLOCATE     ;get the environmental
;*************** CNS ******************
;	       mov     bx,es:[di].ccDBCS_ptr	     ;values to allow
;	       mov     es,es:[di].ccDBCS_ptr+2	     ;recognition and
;*************** CNS ******************
	       les     bx,es:[di].ccDBCS_ptr
	       mov     cx,es:[bx]		     ;invocation of data
               inc     cx
               inc     cx
               inc     bx                            ;and ID for start
               inc     bx
	       mov     di,offset pk.DBCS_EV	     ;and stop values for
						     ;otherwise it is a DBCS
;****CHANGE					     ;or custom designed codepage

	       mov     PK.PACKLEN,cx		     ;if packet length is zero

NODBCS_CP:
	       add     cx,-2			     ;AN002; reset counter before CP addition

;****CHANGE

DB_EVECS:
               or      cx,cx                         ;AN002;no need to alter packet
               jz      NO_LOAD                       ;An002;initialized to zero


	 .REPEAT				      ;;AN000;DBCS transmission
						     ;AN000;
	       mov     al,es:[bx]		     ;;AN000;get the the contents
;***CNS 						;AN000;
	       mov     ds:[di],al			;;AN002;of where the DBCS Points
;***CNS 						;AN000;
	       inc     di			     ;;AN000;data packet for ioctl
						     ;AN000;
	       inc     bx			     ;AN000;;call--- get the start
						     ;stop values to load
						     ;AN000;
		dec	cx			     ;AN000;

	  .UNTIL <CX EQ 0 >			     ;AN000;
						      ;invocation of 1 codepage
						     ;standard codepage selection


NO_LOAD:

		 pop	 es			       ;AN000;;accordingly & restore
						       ;AN000;
		 pop	 cx			       ;AN000;;values
						       ;AN000;
		 pop	 bx			       ;AN000;
						       ;AN000;
		 pop	 di			       ;AN000;
						       ;AN000;;invoke codepage
;************************ CNS*** End of DBCS

					    ;Set up data packet for generic
		mov	ax,cpage	    ;ioctl call.
		mov	pk.packcpid,ax
		lea	dx,pk

		mov	cx,004ah
		mov	bp,0ch		    ;generic ioctl
		CallInstall IOCTL,multdos,43,<DS,SI,ES,DI,BX>,<BX,DI,ES,SI,DS>
		jc	device_error


CLOSE_DEVICE:
		CallInstall Dosclose,multdos,39,<DS,SI,ES,DI>,<DI,ES,SI,DS>
		jc	dev_open_close_error  ; ignore this =FC

GET_NEXT_DEVICE:
		cmp	word ptr es:[di],0FFFFH
		je	END_WALK_DEVICES
		les	di,dword ptr es:[di]
		jmp	char_test

DEVICE_ERROR:
		cmp	ax,1
		je	CLOSE_DEVICE
		CallInstall GetExtErr,multdos,45,<DS,SI,ES,DI,BX>,<BX,DI,ES,SI,DS>
		cmp	ax,22
		je	CLOSE_DEVICE
		mov	ALL_DONE,BAD_INVOKE
		jmp	CLOSE_DEVICE

dev_open_close_error:
		mov	ALL_DONE,BAD_INVOKE
		jmp	GET_NEXT_DEVICE

END_WALK_DEVICES:


		ret

WALK_DEVICES	endp
;*********************** END WALK DEVICE DRIVERS *******************************
;************************ Chk_Revisit******************************************
;This routine will check if we are opening the same device driver again.
;If it is, then carry bit will set.
;This routine will use the NLS_BUFFER to keep the history of already
;visited device driver address (OFFSET,SEGMENT).  NLS_BUFFER will be
;used from the end of the buffer towards to the front of the buffer.
;For 512 byte length and considering the front part used for OPEN device
;driver name string, this will handle appr. 126 devices maximum. which is
;sufficient enough. - J.K. 1/15/88
;IN: BX = file handle
;    DS = NLS_BUFFER segment
;OUT: carry set = visited
;     carry not set = new one.
;     Other registers saved.

Chk_Revisit	proc	near
	push	ax				;AN001;
	push	bx				;AN001;
	push	es				;AN001;
	push	di				;AN001;
	mov	ax, 1220h			;AN001; Get the spot of SFT
	int	2fh				;AN001;
	jc	Chk_Rvst_Ret			;AN001; This won't happen
	xor	bx, bx				;AN001;
	mov	bl, byte ptr es:[di]		;AN001;
	mov	ax, 1216h			;AN001; Get the SFT pointer
	int	2fh				;AN001; es:di-> SFT table
	jc	Chk_Rvst_Ret			;AN001; This won't happen
	mov	ax, word ptr es:[di].SF_DEVPTR	;AN001; offset of device
	mov	bx, word ptr es:[di].SF_DEVPTR+2;AN001; Segment of device
	mov	di, offset NLS_BUFFER		;AN001;
	add	di, BUFFSIZE-2			;AN001; ds:di-> last word of the buffer
Chk_Rvst_While: 				;AN001;
	cmp	word ptr ds:[di], 0		;AN001; di-> segment value
	jne	Chk_Rvst_Cont			;AN001;
	cmp	word ptr ds:[di-2], 0		;AN001; offset
	jne	Chk_Rvst_Cont			;AN001;
	jmp	short Chk_Rvst_New		;AN001; Encountered a blank entry in the buffer
Chk_Rvst_Cont:					;AN001;
	cmp	word ptr ds:[di], bx		;AN001;
	jne	Chk_Rvst_Next			;AN001;
	cmp	word ptr ds:[di-2], ax		;AN001;
	jne	Chk_Rvst_Next			;AN001;
	stc					;AN001; found a match
	jmp	short Chk_Rvst_Ret		;AN001;
Chk_Rvst_Next:					;AN001;
	sub	di, 4				;AN001; move the pointer to the next entry
	jmp	Chk_Rvst_While			;AN001;
Chk_Rvst_New:					;AN001;
	mov	word ptr ds:[di],bx		;AN001; Keep the current open device segment
	mov	word ptr ds:[di-2], ax		;AN001; and offset
	clc					;AN001; New device
Chk_Rvst_Ret:					;AN001;
	pop	di				;AN001;
	pop	es				;AN001;
	pop	bx				;AN001;
	pop	ax				;AN001;
	ret					;AN001;
Chk_Revisit	endp

subttl end nlsfunc resident code
page
 NLSRES_LENG	equ	$-NLSRES_CODE+DATASIZE
subttl initialization
page
;***************************** NLSFUNC Initialization **************************


	ASSUME	CS:NLS_INIT_CODE,SS:STACK
	PUBLIC	MAIN
MAIN	PROC	FAR

	mov	ax,NLS_DATA		;set up data segment
	mov	ds,ax
	assume	ds:NLS_DATA

	mov	PATHSEG,ax

	call	 SYSLOADMSG		 ;does DOS version check

	.IF <NC>

	   mov	dx,NLSRES_LENG		;calculate paragraph
	   add	dx,15			;add 15
	   shr	dx,1			;divide by 16 to get conversion from
	   shr	dx,1			;bytes to paragraphs
	   shr	dx,1
	   shr	dx,1
	   add	dx,11h			;size based on the byte size of
	   mov	RES_PARASIZE,dx 	;the resident procedure
	   call	PROCESS_PATH

	.ELSE

	   call	SYSDISPMSG

	.ENDIF

	; See if we should install and set
	; the TSR flag.

;       .IF <OPTIONS_SENT eq 0>

            test    INFO_FLAG,OPTIONS_SENT_F
            jnz     JJOPSOUT


;          .IF <NO_PARMS eq 1> or
;             .IF <GOOD_PATH eq 1>

            test    INFO_FLAG,NO_PARMS_F OR GOOD_PATH_F
            jz      JJOPSOUT

OPSEOK:
	      call INSTALL_NLS		;let's install NLSFUNC

;             .IF <NC>

            jc      JJOPSOUT
            or      INFO_FLAG,EXIT_STAY_F     ;if nothing wrong occured


;             .ENDIF    ; <NC>
;          .ENDIF       ; <NO_PARMS eq 1> or <GOOD_PATH eq 1>
;       .ENDIF          ; <OPTIONS_SENT eq 0>
JJOPSOUT:
								;determine path of exit
								;error or residency

;****************************** EXIT PROG *********************************************

	push	ax			  ;AN004;save existing values
	push	es			  ;
	xor	ax,ax
	mov	ax,es:[2ch]
        or      ax,ax
        jz      NO_FREEDOM
	mov	es,ax
	mov	ax,4900H		    ;AN004;make the free allocate mem func
	int	21h

NO_FREEDOM:
	pop	es			  ;AN004;restore existing values
	pop	ax			  ;

;       .IF <EXIT_STAY eq 1>            ;Terminate and stay resident

            test    INFO_FLAG,EXIT_STAY_F
            jz      JJEXSY

	   mov     bx,4			;1st close file handles

	   .REPEAT
	      mov  ah,3eh
	      int  21h
	      dec  bx
	   .UNTIL <BX eq 0>

            mov     ah,031h
            mov     dx,RES_PARASIZE      ;paragraphs allocated
            jmp     short JJEXOUT

;       .ELSE
JJEXSY:
	   clc
	   mov     ah,04ch		;value passed to ERRORLEVEL

;       .ENDIF
JJEXOUT:

	mov	al, ERROR_CODE		;check for an error
	int	21H

MAIN	ENDP

;****************************** EXIT PROG *********************************************
subttl parse
page
; On entry: ES points at the PSP
;	    DS points at NLS_DATA
;	    DX was used to calculate paragraph size
;
;	    PARSER EFFECTS  ES & DS wil be swapped
;
; Changes : ES:DI seg:off containing PARM Input Block
; to	    DS:SI seg:off containing command line
; segments
;
;
;
;
;
;
;****************************** PROCESS PATH ***********************************
;=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=I=

PROCESS_PATH	PROC	NEAR

					;to command line parms


		push	es		;;AC000;e original es (nothing)
					;AC000;
		push	ds		;AC000;he original ds (Nls_data)
					;AC002;
		push	ds		;save for both es & ds to point at data

		push	es		;AC000;hat's in my es the PSP value
					;AN000;
		push	ds		;AN000;he segment id that points to my
					;es now points to data
		pop	es		;AC000;
					;input parameter control block (NLS_DATA)
					;AN000;

		pop	ds		;AN000; points to the segment for
					;the command line string
					;AN000;

		ASSUME	DS:NOTHING,ES:NLS_DATA

		xor	dx,dx
		xor	cx,cx

;***CNS
RE_START:
		mov	si,80h		;get the command line length

		mov	cl,byte ptr ds:[si]	;get the length for the counter
;
;               mov     LENGTH_HOLD,cl          ;save the length of the command line
;



;		.IF <dx eq 0>

		     mov     di,OFFSET NLS_BUFFER    ;
 ;		     mov     dx,1
 ;		.ELSE
 ;		     mov     di,OFFSET PATH_SPEC    ;
 ;		     mov     dx,-1
 ;		.ENDIF

		mov	si,CL_NUM	;AN000; points to the offset command
					;line input string at value 81h
					;AN000;

		rep	movsb			;transfer command line to NLS_BUFFER

;		.IF <dx eq 1>
;		    jmp RE_START
;		.ENDIF

;***CNS




		mov	di,OFFSET NLS_PARMS    ;AN000; into ES of the PARMS INPUT
					;BLOCK
					;AN000;
		pop	ds		       ; ds also point at NLS_DATA


		ASSUME	DS:NLS_DATA


		mov	si,OFFSET NLS_BUFFER	;si now points to the offset command
;***CNS

                xchg    ax,CUR_PTR              ;AN003;Save environment
                                                ;AN003;Set advancing ptr to end of argument
                xchg    ax,OLD_PTR              ;AN003;after saving the beginning the string
                                                ;AN003;
                xchg    ax,CUR_PTR              ;AN003;Restore the environment
                mov     CUR_PTR,si

;***CNS



		xor	cx,cx			;AN000;l value should be atleast 1
		xor	dx,dx			;AN000;ut dx for input into the PARSER
						;AN000;

	.WHILE <PAR_RETC eq 0> 			;AN000;

	   call	SYSPARSE			;AN000;empt to parse
;***CNS

                xchg    ax,CUR_PTR              ;AN003;Save environment
                                                ;AN003;Set advancing ptr to end of argument
                xchg    ax,OLD_PTR              ;AN003;after saving the beginning the string
                                                ;AN003;
                xchg    ax,CUR_PTR              ;AN003;Restore the environment
                mov     CUR_PTR,si

;***CNS

	   .IF <RES_SYN EQ <OFFSET OPT_SYN>>

	      ; Display the user options help message

	      call	DISPLAY_OPTIONS

	      ; Flag that the options message has been displayed,
	      ; and now we want out of this program so the user
	      ; can try again.

              or        INFO_FLAG,OPTIONS_SENT_F  ; to get out of program
              and       INFO_FLAG,NOT EXIT_STAY_F ;  and not TSR
              mov       ERROR_CODE, 0             ;  and no error for help
              mov       ax, 1                     ; to get out of WHILE loop

	   .ELSEIF <Res_type eq 5>		;AN000;ound
						;AN000;
	      mov	USER_PATH,1		;AN000;;path specified
						;AC000;
	   .ENDIF				;AN000;

	   mov	PAR_RETC, AX			;AN000;;keep parsing until eoln
						;AN000;
	.ENDWHILE				;AN000;

	; If we didn't display the option help message,
	; then continue on with normal processing.

;       .IF <OPTIONS_SENT EQ 0> NEAR

            test    INFO_FLAG,OPTIONS_SENT_F
            jz      JJBR1
            jmp     JJOUT1

;          .IF <PAR_RETC gt 0>                  ;AN000;;parse error
JJBR1:
            cmp     PAR_RETC,0
            jnge    JJRETC


	      LEA   DI,PATH_SPEC		;AN003;Set PTR to look at the STRING
	      PUSH  SI				;AN003;Save current SI index
	      PUSH  AX
	      MOV   AX,OLD_PTR			;AN003;Last locale of the end of a PARAM
	      SUB   CUR_PTR,AX			;AN003;Get the length via the PSP
	      MOV   SI,CUR_PTR
	      MOV   CX,SI			;AN003;Save it in CX to move in the chars
	      POP   AX				;AN003;Restore the PTR to the command line position

	      MOV   SI,OLD_PTR			;AN003;Last locale of the end of a PARAM
	      REP   MOVSB			;AN003;Move in the chars until no more

	      LEA   DI,PATH_SPEC		;AN003;Set PTR to look at the STRING

	      POP   SI				;AN003;Restore the PTR to the command line position

	      mov   cx,1			;AN003;;
	      mov   bx,STDERR			;AN003;
	      mov   dl,no_input			;AN003;
	      mov   dh,PARSE_ERR_CLASS		;AN003;
	      mov   ds,PATHSEG			;AN003;
	      mov   si,OFFSET PARMLIST3		;AN003;
	      call  SYSDISPMSG			;AN003;
              or    INFO_FLAG,PARSE_ERR_F       ;AN003;;PARSE ERROR OCCURED

            jmp     short JJOUTRETC

;          .ELSEIF <CX eq 1>                    ;AN000;ordinal check
JJRETC:

                cmp cx,1
                jne JJCX
						;AN000;
              or    INFO_FLAG,GOOD_PAR_F        ;AN000;you are at the end of the line

            jmp     short JJOUTRETC             ;AN000;

JJCX:
;          .ELSE

            or      INFO_FLAG,NO_PARMS_F        ;AN000;there is no argument go install

;          .ENDIF               ; <PAR_RETC gt 0>
JJOUTRETC:


;         .IF <PARSE_ERR eq 0> NEAR             ;AN000;if not true you encountered a parse error

                test INFO_FLAG,PARSE_ERR_F
                jnz JJOUT1

;            .IF <GOOD_PAR eq 1> NEAR           ;AN000;there is a parameter line available
						;to parse
                test    INFO_FLAG,GOOD_PAR_F    ;AN000;
                jz      JJOUT1                  ;Check the flags to see what
						;was returned in the return block

	        lea     di,path_spec		;AC000;es:di > final path_spec
						;that will be used after fixup

;               .IF <USER_PATH gt 0>            ;AC000;drive has been solved need
                                                ;to check the filespec now
                cmp USER_PATH,0
                jnge USPA1

	           xor   in_dex,in_dex		;AN000;clear ctr
		   mov   bx,Res_POFF 		;AN000;get file spec ptr to text
		   push  ds			;AN000;prepare for entry
		   mov   ds,Res_PSEG 		;AN000;
		   mov   in_dex,bx		;AN000;string seg value if filename

;               .ENDIF        ;user path        ;AN000;
USPA1:

	        .WHILE <Filespec_PTR ne NULL>	;load chars until no more
						;AN000;
						;AN000;
		   mov	al,FILESPEC_PTR 	;AN000;
		   mov	byte ptr es:[di],al	;move value into pathspec and
		   inc	in_dex			;increment to next char position
		   inc	di			;AN000;

	        .ENDWHILE

;************************** CNS **********************************************
;The new method of checking for a "bogus" file will be to attempt an
;open on the path_spec if pathspec exist close path and continue if
;carry set stuff error code with 02 and exit.....
;*****************************************************************************
;	        push	es			;AN000;

	        pop	ds			;into find first
	        mov	si,di			;AN000;
	        xor	cx,cx			;AN000;

	        ASSUME	DS:NLS_DATA

	        mov	byte ptr ds:[si],NULL	;add asciiz value
						;AN000;
	        lea	dx,PATH_SPEC		;check full pathname
	        mov	ah,4eh
	        int	21h
						;set up addressability
;               .IF <NC>

                jc      JJC1

		   clc				;ok-clear carry/exit
                   or   INFO_FLAG,GOOD_PATH_F

                jmp     short JJOUT1

;               .ELSE
JJC1:
	           mov	ax,FNF			;AN000;
	           mov	cx,1			; ;AN000;
	           mov	bx,STDERR		;AN000;
	           mov	dl,no_input		;AN000;
	           mov	dh,UTILITY_MSG_CLASS 	;AN000;
	           mov	ds,PATHSEG		;AN000;
	           mov	si,OFFSET PARMLIST1	;AN000;
		   call	SYSDISPMSG		;AN000;
		   mov	ERROR_CODE,02		;
		   stc

;               .ENDIF  ; <NC>

;            .ENDIF     ; <GOOD_PAR eq 1>

;          .ENDIF       ; <PARSE_ERR eq 0>

;       .ENDIF          ; <OPTIONS_SENT EQ 0>

JJOUT1:


	pop	ds				;AN000;;restore original ds (NLS_DATA)
						;AN000;
	pop	es				;AN000;;restore original es (nothing)
						;AN000;
						;AN000;;after munging around with the PARSER

	ASSUME	DS:NLS_DATA,ES:NOTHING

	ret

PROCESS_PATH	ENDP


subttl display_options
page
;**************************** DISPLAY OPTIONS *******************************
;
; 04/26/90 c-PaulB
;
; on entry:
;   No value passed
;
; on exit:
;   No value returned
;   AX, BX, CX, DX, SI modified
;
; function:
;   Displays all lines of the options help message to standard
;   output.
;
;**************************** DISPLAY OPTIONS *******************************

	PUBLIC	DISPLAY_OPTIONS
DISPLAY_OPTIONS	PROC NEAR

	push	ds
	mov	ax, MSG_OPTIONS_FIRST		; message to display
	mov	bx, STDOUT			; output handle
	mov	cx, 0				; no substitutions
	mov	dh, UTILITY_MSG_CLASS		; message class
	mov	dl, no_input			; no input wanted
	mov	si, 0				; no substitution list
	mov	ds, PATHSEG
DO_LOOP:
	call	SYSDISPMSG			; send this message line
	cmp	ax, MSG_OPTIONS_LAST		; last message?
	je	DO_DONE				;  we're done if so
	inc	ax				; else get next msg
	jmp	short DO_LOOP			;  and go do it
DO_DONE:
	pop	ds
	ret

DISPLAY_OPTIONS ENDP


;****************************** CNS *******************************************
subttl install NLSFUNC
page
;******************************** INSTALL NLSFUNC *****************************

INSTALL_NLS	PROC	NEAR

		push	es

		xor	ax,ax			  ;clear the ax
		mov	ah,MULT_NLSFUNC 	  ;load in my multiplex
		INT	2fh			  ;id value 14
		or	al,al			  ;check to see if
;		jz	DO_INSTALL		  ;hooked in the chain
; *********************** CNS *************************************************

	   .IF <Z>				  ;AN000

						  ;Install NLSFUNC
		mov	al,2fh			  ;Get interrupt
		mov	ah,GET_INT		  ;2f in the chain
		int	21h
		mov	word ptr INT_2f_NEXT+2,ES ;store the address
		mov	word ptr INT_2f_NEXT,BX   ;to make the current
		push	ds			  ;2f handler next in
		push	cs			  ;the chain
		pop	ds			  ;set Dataseg to the Code
		mov	dx,offset NLSRES_CODE	  ;give start address
		mov	al,2fh			  ;of resident logic
		mov	ah,SET_INT		  ;set the 2f in the
		int	21h			  ;chain
		pop	ds			  ;restore original ds
						  ;terminate &
		CLC				  ; Let main know everything OK 	 ;BN001;
						  ;stay
;FREE THE ENVIRONMENT				  ;no then install

;		  push	  ax			  ;AN004;save existing values
;		  push	  es			  ;
;		  mov	  ah,49H		  ;AN004;make the free allocate mem func
;		  mov	  es,es:[2ch]		    ;AN004;get the segment address
;		  int	  21h			  ;
;		  pop	  es			  ;AN004;restore existing values
;		  pop	  ax			  ;

	   .ELSE				   ;AN000;
;TBR Message retriever				  ;otherwise
		   mov	   ax,ALLINS		     ;
		   mov	   cx,1 		     ;
		   mov	   bx,STDERR		       ;AN000;
		   mov	   dl,no_input		       ;AN000;
		   mov	   dh,UTILITY_MSG_CLASS 	 ;AN000;
		   mov	   ds,PATHSEG
		   mov	   si,OFFSET PARMLIST2
		   call    SYSDISPMSG		      ;AN000;
		   mov	   ERROR_CODE,80	      ;UTILITY ERROR CODE
		   stc

.ENDIF

		pop	es

		ret

INSTALL_NLS	ENDP

msg_services <LOADmsg>				      ;AN000;
msg_services <DISPLAYmsg,CHARmsg>		      ;AN000;
msg_services <nlsfunc.cl1,nlsfunc.cl2,nlsfunc.cla>    ;AN000;

;******************************** END OF NLS_INIT_CODE **************************
NLS_INIT_CODE	 ENDS
subttl stack
page

STACK	SEGMENT   PARA	STACK 'STACK'
	DB	  512 DUP (?)
STACK	ENDS

	END	MAIN

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\funcdbcs.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;; generic ioctl call data "packet" pointed to by DS:DX    =E
PACKET		STRUC	   ;USED BY MINOR CODES: 6AH,4AH,4DH (SELECT, QUERY SELECTED, PREPARE END)  =E
PACKLEN 	DW   0	     ;LENGTH OF PACKET IN BYTES =E	  2/16/KK
PACKCPID	DW   0	   ;CODE PAGE ID	      =E
DBCS_EV 	DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
		DB   0,0   ; 2/16/KK
PACKET		ENDS


STD_CPLENGTH  equ	2
PK	      PACKET <>  ;CNS

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\doesmac.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

CallInstall MACRO   name,mpx,fn,save,restore
BREAK	MACRO	subtitle
	SUBTTL	subtitle
	PAGE
ENDM
.xcref	break
IF Installed
    IFNB    <save>
	SaveReg <save>
    ENDIF
	MOV	AX,(mpx SHL 8) + fn
	INT	2Fh
    IFNB    <restore>
	RestoreReg  <restore>
    ENDIF
ELSE
	Invoke	name
ENDIF
ENDM

BREAK <SaveReg - save a set of registers>

SaveReg MACRO	reglist 		;; push those registers
IRP reg,<reglist>
	?stackdepth = ?stackdepth + 1
	PUSH	reg
ENDM
ENDM
.xcref	SaveReg

BREAK <RestoreReg - unsave some registers>

RestoreReg  MACRO   reglist		;; pop those registers
IRP reg,<reglist>
	?stackdepth = ?stackdepth - 1
	POP	reg
ENDM
ENDM
.xcref	RestoreReg

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\funcparm.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;Parser INPUT PARM LIST Structure

	PUBLIC	NLS_PARMS
 NLS_PARMS	label  word
      dw	NLS_PARMSX
      db	0	  ;no extra delimiters

	PUBLIC	NLS_PARMSX
 NLS_PARMSX	label  word
      db	0,1	  ;Min 0 - no path
			  ;Max 1 - path
      dw	NLS_POS1
      db	1         ; 1 switch supported
      dw	NLS_OPTS  ; its addr

	PUBLIC	NLS_POS1
 NLS_POS1	label  word
      dw	0201h	 ;File spec (optional)
      dw	0001h	 ;Cap result by file
      dw	Res_Valptr   ;tbl
      dw	NoVal	     ;no value list
      db	0	     ;no switch or
			     ;keyword synonyms

	PUBLIC	NLS_OPTS, OPT_SYN
NLS_OPTS	label word
	dw	0000		; Match Mask
	dw	0000		; Function Mask
	dw	RES_VALPTR	; ptr to results
	dw	NOVAL		; ptr to values
	db	1		; count of synonyms
OPT_SYN	db	"/?", 0

NOVAL label word
	db	0

	PUBLIC	RES_VALPTR, RES_SYN
    RES_VALPTR	label word

      RES_TYPE	 db	?	;Result_type
      RES_ITAG	 db	0	;Matched item tag
      RES_SYN	 dw	0	;synonym returned
      RES_POFF	 dw	0	;drive type or beginning of string
      RES_PSEG	 dw	0	;may be string
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\msg2nls.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

BADDOS equ 1
ALLINS equ 2
FNF    equ 3
FLAG1  equ LEFT_ALIGN+CHAR_FIELD_ASCIIZ

;*****************************************************************************
;******************************************************************************
;		VALUES FOR THE MSG_DESC CONTROL BLOCK
ONE_SUBS       EQU   1		   ;ONE VARIABLE FIELD IN MESSAGE
TWO_SUBS       EQU   2		   ;TWO VARIABLE FIELDS IN MESSAGE
THREE_SUBS     EQU   3		   ;THREE VARIABLE FIELDS IN MESSAGE
CLASS_1        EQU   EXT_ERR_CLASS ;CLASS 1 (DOS EXTENDED ERRORS)
CLASS_2        EQU   PARSE_ERR_CLASS ;CLASS 2 (PARSE ERRORS)
CLASS_A        EQU   UTILITY_MSG_CLASS ;CLASS A TYPE MESSAGE

;THIS MESSAGE DESCRIPTOR CONTROL BLOCK IS GENERATED, ONE PER MESSAGE,
;TO DEFINE THE SEVERAL PARAMETERS THAT ARE EXPECTED TO BE PASSED IN
;CERTAIN REGISTERS WHEN THE SYSDISPMSG FUNCTION IS TO BE INVOKED.

;MSG_DESC	   STRUC
;MSG_NUM	   DW	 0	    ;MESSAGE NUMBER (TO AX)
;MSG_HAND	   DW	 0	     ;HANDLE OF OUTPUT DEVICE (TO BX)
;MSG_SUBLIST	   Dd	 0	    ;POINTER TO SUBLIST (TO SI)
;MSG_COUNT	   DW	 0	    ;SUBSTITUTION COUNT (TO CX)
;MSG_CLASS	   DB	 0	    ;MESSAGE CLASS (IN HIGH BYTE, TO DH)
;				    ; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL)
;MSG_DESC	   ENDS
;		VALUES FOR THE SUBLIST CONTROL BLOCK
PC_ID_0        EQU   0		   ;ID OF " - " TRAILER TO MESSAGE
PC_ID_1        EQU   1		   ;ID OF PERCENT VARIABLE FIELD
PC_ID_2        EQU   2		   ;ID OF PERCENT VARIABLE FIELD
PC_ID_3        EQU   3		   ;ID OF PERCENT VARIABLE FIELD
MAX_0	       EQU   0		   ;MAXIMUM WIDTH OF STRING FIELD (0=NO LIMIT)
MIN_1	       EQU   1		   ;MINIMUM WIDTH OF STRING FIELD
ID_0	       EQU   0

;Message PARM LIST Structure
  PARMLIST1 LABEL   BYTE  ;PARM LIST
       ;(File not found - 'PATH_SPEC')
       DB  11	      ;PARMLIST size
       DB  0	      ;reserved
       DD  PATH_SPEC
       DB  id_0       ;; n of %n
       DB  FLAG1      ;; data type
       DB  max_0      ;;max width
       DB  min_1      ;;min width
       DB  PAD_CHAR   ;;char defined to be space


  PARMLIST2 LABEL   BYTE  ;PARM LIST
       ;(NLSFUNC already installed)
       DB  11	      ;PARMLIST size
       DB  0	      ;reserved
       DD  UTILITY    ;; ptr to data
       DB  1	      ;; n of %n
       DB  FLAG1      ;; data type
       DB  0	      ;;max width
       DB  1	      ;;min width
       DB  PAD_CHAR   ;;char defined

  PARMLIST3 LABEL   BYTE  ;PARM LIST
       ;(Invalid parameter 'PATH_SPEC')
       DB  11	      ;PARMLIST size
       DB  0	      ;reserved
       DD  PATH_SPEC   ;; ptr to data
       DB  id_0       ;; n of %n
       DB  FLAG1      ;; data type
       DB  0	      ;;max width
       DB  1	      ;;min width
       DB  PAD_CHAR   ;;char defined

;		THE NEXT GROUP ARE ALL CLASS "1" MESSAGES

;		PUBLIC MSGNUM_EXTERR
;MSGNUeM_EXTERR  MSG_DESC <FNF,STDERR,,,CLASS_1> ;ALL EXTENDED DOS ERRORS
				   ;File not found - %0

;		THE NEXT GROUP ARE ALL CLASS "2" MESSAGES

;		PUBLIC MSGNUM_PARSE ;SO PARSE DRIVER CAN FIND IT
;MSGNUM_PARSE	MSG_DESC <,STDERR,,,CLASS_2> ;ALL PARSING ERRORS BUT INVALID
						;SYNTAX
				   ;ERROR NUMBER WILL NEED TO BE FILLED IN

;		THE NEXT GROUP ARE ALL CLASS "A" MESSAGES
;		THESE ARE THE "CANNED" MESSAGES ALWAYS PRESENT

;		PUBLIC MSGNUM_VER
;MSGNUM_VER	MSG_DESC <1,STDERR> ;"Incorrect DOS Version"

;		PUBLIC MSGNUM_INST
;MSGNUM_INST	MSG_DESC <ALLINS,STDERR> ;"%1 - already installed"
;end of MSGHAN.INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\qbasic\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\qbasic\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\qbasic\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\qbasic\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\qbasic\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\qbasic\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\qbasic\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\nlsfunc\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

nlsfunc.skl : ..\usa\nlsfunc.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\device.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;========================================================
COMMENT #

	DEVICE.ASM


	=================================================
	Device driver to activate the version table in
	MS-DOS 5.0. Upon initialization the driver will
	set the DWORD PTR in the DOS data area at offset
	05dh to point to the version table in the device
	driver and also calculates the minimum install
	size needed to include only the valid entries
	in the default version table.


	================================================

	johnhe - 12/30/90

END COMMENT #

; =======================================================

INCLUDE		VERSIONA.INC

CMD		EQU	2		; Command field offset in packet
STATUS		EQU	3		; Return status field offset
DEV_LEN		EQU	14		; Device length field offset

DOS_TABLE	EQU	5dh		; Lie table ptr offset in dos data
TABLE_LEN	EQU	2048		; Max size of lie table

; ====================================================================

A_DEVICE SEGMENT BYTE PUBLIC 'CODE'
	ASSUME	CS:A_DEVICE, DS:NOTHING, ES:NOTHING

PUBLIC	ENTRY
PUBLIC	DeviceInit

; ====================================================================


DeviceHeader:
		dw	-1,-1
		dw	1000000000000000b; Device attributes (character device)
		dw	Strategy	; Device strategy entry offset
		dw	Entry		; Device entry offset
		db	'SETVERXX'
ExtendedHeader:				; Extended header is used by the
					; SETVER.EXE program to determine
					; where the version table is located
					; within the .EXE file
VerMinor	db	0		; Version 1.0 of Setver
VerMajor	db	1		;
TableOffset	dd	OFFSET VerList	; Offset of table from device start
TableLength	dw	TABLE_LEN	; Max table size
PtrSave	dd	(?)			; Address of device packet

; ====================================================================

; ====================================================================

StratProc PROC	FAR

Strategy:
	mov	WORD PTR CS:[PtrSave],BX	; Save device packet for
	mov	WORD PTR CS:[PtrSave][2],ES	; use on call to dev entry
	ret

StratProc	ENDP	
	
; ====================================================================

; ====================================================================

Entry PROC FAR				; Device driver entry location
	push	BX
	push	DS
	
	lds	BX,[PtrSave]		; DS:BX --> Cmd structure
	mov	AL,DS:[BX].CMD		; AL == command from sysinit
	cbw
	or	AX,AX			; Check for init function zero
	jnz	CmdError		; If not init then error
	jmp	DeviceInit		; Jmp to initialize device

CmdError:
	mov	AL,3			; Return invalid function code
	mov	AH,10000001b		; Signal error in AH

SetStatus:
	mov	[BX].Status,AX		 ; Copy status to packet

	pop	DS
	pop	BX
	ret

Entry ENDP

; ====================================================================
; ====================================================================

SIG	db	'PCMN'
TblLen	dw	TABLE_LEN

; ====================================================================
; ====================================================================


; NTVDM commented out unsupported drivers\apps 19-Aug-1992 Jonle
if 0
        db      10,"WIN200.BIN"         ,3,40   ; windows 2.x
        db      10,"WIN100.BIN"         ,3,40   ; win 1.x
        db      11,"WINWORD.EXE"        ,4,10   ; winword 1.0
	db	9, "EXCEL.EXE"		,4,10	; excel 2.x
        db      11,"HITACHI.SYS"        ,4,00   ; CDROMS
        db      10,"MSCDEX.EXE"         ,4,00   ; CDROMS
        db      10,"REDIR4.EXE"         ,4,00   ; Banyan networks
        db      7, "NET.EXE"            ,4,00   ; 3+ Open
        db      7, "NET.COM"            ,3,30   ; IBM PCLP
        db      12,"NETWKSTA.EXE"       ,4,00   ; 3+ Open
        db      12,"DXMA0MOD.SYS"       ,3,30   ; Token ring
        db      7, "BAN.EXE"            ,4,00   ; Banyan
        db      7, "BAN.COM"            ,4,00   ; Banyan
        db      11,"MSREDIR.EXE"        ,4,00   ; LanMan
	db      9, "METRO.EXE"          ,3,31   ; Lotus Metro
        db      12,"IBMCACHE.SYS"       ,3,40   ; IBM CHACHE Program
        db      11,"REDIR40.EXE"        ,4,00   ; IBM PCLP 1.3/4 redirector
	db	6, "DD.EXE"		,4,01	; Laplink III software
	db	6, "DD.BIN"		,4,01	; Laplink III software
	db	7, "LL3.EXE"		,4,01   ; Laplink III software
        db      9, "REDIR.EXE"          ,4,00   ; DOS 4 redir
        db      9, "SYQ55.SYS"          ,4,00   ; Removable SCSII drive from Syquest
        db      12,"SSTDRIVE.SYS"       ,4,00   ; Columbia SCSI driver
        db      8, "ZDRV.SYS"           ,4,01   ; Unisys CD-ROM B#4734
        db      8, "ZFMT.SYS"           ,4,01   ; Unisys CD-ROM B#4734
        db      11,"TOPSRDR.EXE"        ,4,00   ; TOPS redir Bug 5968
endif

        public  VerList

VerList db      11,"WINWORD.EXE"        ,4,10   ; winword 1.0
	db	9, "EXCEL.EXE"		,4,10	; excel 2.x
        db      9, "METRO.EXE"          ,3,31   ; Lotus Metro
        db      6, "DD.EXE"             ,4,01   ; Laplink III software
	db	6, "DD.BIN"		,4,01	; Laplink III software
        db      7, "LL3.EXE"            ,4,01   ; Laplink III software

        db      (TABLE_LEN - ($ - VerList)) dup (0)
	db	0


; ====================================================================
; Device initialization function first determines minimum size the
; driver needs to be and then sets the DWORD PTR in the DOS data area
; to the location of the version table.
; ====================================================================

DeviceInit:

	push	BX
	push	CX
	mov	AH,30h			; Get version
	int	21h
	pop	CX
	pop	BX

	cmp	AX,expected_version
	je	SetupScan
	xor	AX,AX			; Set end of device to 0
	jmp	SHORT SetDevEnd
	
SetupScan:
	push	SI
	push	DS
	mov	AX,CS
	mov	DS,AX
	mov	SI, OFFSET VerList	; DS:SI --> Version table

	xor	AX,AX			; Clear high byte of AX
ScanLoop:
	lodsb				; Grab the name length
 	or	AX,AX			; Test for end of the table
	jz	FoundEnd
	inc	AX			; Add 2 bytes for the version number
	inc	AX
	add	SI,AX			; Make SI so it points to next entry
	jmp	SHORT ScanLoop

FoundEnd:
	mov	AX,SI			; AX == Offset of end of table
	inc	AX			; Need 1 zero byte at end of table
	pop	DS
	pop	SI

SetTablePtr:
	push	BX
	push	ES

	push	AX			; Save end of device offset
	mov	AH,52h			; Get the DOS data segment
	int	21h
	pop	AX			; Restore end of device offset to AX

	cli				; Safety measure when altering DOSdata
	mov	WORD PTR ES:[DOS_TABLE], OFFSET VerList ; Offset of lie table
	mov	WORD PTR ES:[DOS_TABLE][2],CS	; Segment of lie table
	sti
	pop	ES
	pop	BX

SetDevEnd:
	mov	WORD PTR DS:[BX].DEV_LEN,AX ; Set end of driver @ end of list
	mov	DS:[BX].DEV_LEN[2],CS	; Set device segment
	mov	AH,00000001b		; Normal status return

	jmp	SetStatus		; End of init code

; ====================================================================

A_DEVICE ENDS

; ====================================================================

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\setver.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                         */
/* SETVER.H                                                                */
/*                                                                         */
/*	Include file for MS-DOS set version program.                       		*/
/*                                                                         */
/*	johnhe	05-01-90                                                   		*/
/***************************************************************************/


#pragma pack(1)

/***************************************************************************/
/* Normal variable typedefs. These type defs are compatible with OS2	   	*/
/* typedefs.								   												*/
/***************************************************************************/

typedef  char           CHAR;
typedef  unsigned char  UCHAR;
typedef  int            INT;
typedef  unsigned int   UINT;
typedef  long           LONG;
typedef  unsigned long  UL;
typedef  float          FLOAT;
typedef  double         DOUBLE;

/***************************************************************************/
/* Standard global constants.						   									*/
/* Don't change the TRUE define because some functions depend on it being  */
/* 1 instead of !FALSE.							   										*/
/***************************************************************************/

#ifndef	FALSE
  #define FALSE    	0
#endif

#ifndef	TRUE
  #define TRUE 	   1
#endif

#define	EOL	  		'\0'

#define	HEX	  		16
#define	DECIMAL	  	10
#define	OCTAL      	8

/***************************************************************************/
/* Module specific constants						   									*/
/***************************************************************************/

#define	MAX_NAME_LEN			13
#define	MAX_ENTRY_SIZE			(MAX_NAME_LEN + 1 + 2 + 1)
#define	MAX_PATH_LEN			68

#define	MAX_VERSION 			0x0a00		/* Max version 9.99	*/
#define	MIN_VERSION 			0x020b		/* Min version 2.11	*/

#define	S_ERROR					-1
#define	S_OK						0
#define	S_INVALID_SWITCH		-1
#define	S_INVALID_FNAME		-2
#define	S_MEMORY_ERROR 		-3
#define	S_BAD_VERSION_FMT 	-4
#define	S_ENTRY_NOT_FOUND 	-5
#define	S_FILE_NOT_FOUND		-6
#define	S_BAD_DRV_SPEC 		-7
#define	S_TOO_MANY_PARMS		-8
#define	S_MISSING_PARM			-9	    		/* Missing version number or /d	*/
#define	S_FILE_READ_ERROR		-10
#define	S_CORRUPT_TABLE		-11
#define	S_INVALID_SIG			-12
#define	S_NO_ROOM				-13
#define	S_FILE_WRITE_ERROR	-14
#define	S_INVALID_PATH			-15

#define	DO_LIST 					1
#define	DO_ADD_FILE 			2
#define	DO_DELETE 				3
#define	DO_HELP   				4
#define	DO_QUIET					5

#define	VERSION_COLUMN			16				/* Screen column for version #	*/
#define	SIGNATURE_STR			"PCMN"		/* Signature string in MSDOS.SYS	*/
#define	SIGNATURE_LEN			4
#define	BUF_LEN					4096

/***************************************************************************/
/* Defines for possible command line switches.										*/
/***************************************************************************/

#define	HELP_SWITCH		"?"
#define	DEL_SWITCH		"DELETE"
#define	SWITCH_CHAR 	'/'
#define	QUIET_SWITCH   "QUIET"

/***************************************************************************/

struct TableEntry
{
	char		Drive;
#ifdef JAPAN
	char		Path[ MAX_PATH_LEN+10 ];
#else
	char		Path[ MAX_PATH_LEN ];
#endif
	char		szFileName[ MAX_NAME_LEN + 1 ];
	UCHAR		MajorVer;
	UCHAR		MinorVer;
};

struct ExeHeader
{
	UINT		Signature;
	UINT		LastPageLen;
	UINT		TotalFilePages;
	UINT		NumRelocEntries;
	UINT		HeaderParas;
	UINT		MinEndParas;
	UINT		MaxEndParas;
	UINT		StackSeg;
	UINT		StackPtr;
	UINT		NegChkSum;
	UINT		IndexPtr;
	UINT		CodeSeg;
	UINT		RelocTblOffset;
	UINT		OverlayNum;
};

struct DevHeader
{
	char far		*NextDevice;
	unsigned		DeviceAttrib;
	char near	*Strategy;
	char near	*Entry;
	char			Name[ 8 ];
	char			VersMinor;
	char			VersMajor;
	long			TblOffset;
	unsigned		TblLen;
};

/***************************************************************************/
/* Function prototypes for SETVER.C                                        */
/***************************************************************************/

extern  int   main( int argc, char *argv[] );
static  int   Error( int iErrCode );
static  int   DoFunction( int iFunction );

static  void  DisplayMsg( char *tbl[] );
static  int   DeleteEntry( void );
static  int   AddEntry( void );

static  int   DisplayTable( void );
static  int   MatchFile( char *pchStart, char *szFile );
static  int   IsValidEntry( char *pchPtr );
static  char  *GetNextFree( void );

static  int   ReadVersionTable( void );
static  int   WriteVersionTable( void );

static  int   SeekRead( int iFile, void *Buf, long lOffset, unsigned uBytes );

#ifdef BILINGUAL
static	int	IsDBCSCodePage(void);
#endif

/***************************************************************************/
/* Function prototypes for PARSE.C                                         */
/***************************************************************************/

extern  int   ParseCmd( int argc, char *argv[], struct TableEntry *Entry );
static  int   IsValidFile( char *szFileName );
static  UINT  ParseVersion( char *szVersion );
static  int   IsDigitStr( char *szStr );
static  char  *SkipLeadingChr( char *szStr, char chChar );
static  void  RemoveTrailing( char *szStr, char chChar );
static  int   MatchSwitch( char *szCmdParm, char *szTestSwitch );
static  int   IsValidFileName( char *szFile );
static  int   IsReservedName( char *szFile );
static  int   IsWildCards( char *szFile );
static  int   ValidFileChar( char *szFile );
static  int   IsValidFileChr( char Char );

#ifdef DBCS 
static  int   IsDBCSLeadByte(unsigned char);
static	int   CheckDBCSTailByte(unsigned char *,unsigned char *);
#endif

/***************************************************************************/
/* Function prototypes for DOS.ASM                                         */
/***************************************************************************/

extern  int   IsValidDrive( unsigned DrvLetter );
extern  void  PutStr( char *String );
extern  long  _dos_seek( int Handle, long lOffset, int Mode );
extern  int	  SetVerCheck ( void );					/* M001 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\setver.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*	SETVER.C 																					*/
/*																									*/
/*	This module contains the functions which read in the version table		*/
/*	from MSDOS.SYS and then updates the table with new entries and				*/
/*	writes it back to the file.															*/
/*																									*/
/*	The fake version table is located in the DOS system file and it's			*/
/*	location and length are specified with 2 words at offset 7 in the			*/
/* file. The first word is the table offset and second word is length.		*/
/*																									*/
/*	Table layout:																				*/
/*																									*/
/* ENTRY FILENAME LEN:	Length of filename in bytes	1 byte					*/
/* ENTRY FILENAME:	Variable length to 12 bytes	? bytes						*/
/* ENTRY VERSION MAJOR: Dos major version to return	1 byte					*/
/* ENTRY VERSION MINOR: Dos minor version to return	1 byte					*/
/*																									*/
/*																									*/
/*	USEAGE:																						*/
/*		List table:		SETVER [D:]															*/
/*		Add entry:		SETVER [D:] name.ext X.XX										*/
/*		Delete entry:	SETVER [D:] name.ext /DELETE									*/
/*		Delete entry quietly: SETVER [D:] name.ext /DELETE /QUIET				*/
/*		Display help	SETVER /?															*/
/*																									*/
/*	WHERE:																						*/
/*		D: is the drive containing MSDOS.SYS											*/
/*		name.ext is the executable file name											*/
/*		X.XX is the major and minor version numbers									*/
/*																									*/
/*	RETURN CODES:																				*/
/*		0	Successful completion															*/
/*		1	Invalid switch																		*/
/*		2	Invalid file name																	*/
/*		3	Insuffient memory																	*/
/*		4	Invalid version number format													*/
/*		5	Entry not found in the table													*/
/*		6	MSDOS.SYS file not found														*/
/*		7	Invalid MSDOS.SYS or IBMDOS.SYS file										*/
/*		8	Invalid drive specifier															*/
/*		9	Too many command line parameters												*/
/*		10	DOS version was not specified													*/
/*		11	Missing parameter																	*/
/*		12 Error reading MS-DOS system file												*/
/*		13 Version table is corrupt														*/
/*		14 Specifed file does not support a version table							*/
/*		15 Insuffient space in version table for new entry							*/
/*		16 Error writing MS-DOS system file												*/
/*																									*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <dos.h>
#include <io.h>
#include <fcntl.h>

#include <setver.h>
#include <message.h>


/***************************************************************************/

static char				*ReadBuffer;
static char 			*LieBuffer;		 		/* Buffer to read lietable into	*/
static char 			*EndBuf;			 		/* Ptr to end of the buffer 		*/
struct ExeHeader		ExeHdr;
struct DevHeader		DevHdr;
struct TableEntry		Entry;
static char				*szSetVer = "SETVERXX";

long						FileOffset;
/* static UINT				TableLen; */

/***************************************************************************/
/* Program entry point. Parses the command line and if it's valid executes */
/* the requested function and then returns the proper error code. Any		*/
/* error codes returned by ParseCommand are negative so they must be			*/
/* converted with a negate before being returned as valid error codes.		*/
/*																									*/
/*	int main( int argc, char *argv[] )													*/
/*																									*/
/*	ARGUMENTS:	argc - Count of command line arguments				 				*/
/*					argv - Array of ptrs to argument strings							*/
/*	RETURNS:		int	- Valid return code for batch processing					*/
/*																								 	*/
/***************************************************************************/

int main( int argc, char *argv[] )
{
	register		iFunc;
	char			szError[ 80 ];

	iFunc = ParseCmd( argc, argv, &Entry );
	if ( iFunc >= 0 )
		iFunc = DoFunction( iFunc );

	if ( iFunc != S_OK )
	{
		iFunc = -(iFunc);
#ifdef BILINGUAL
		if (IsDBCSCodePage())
		{
			strcpy( szError, ErrorMsg[ 0 ] );
			strcat( szError, ErrorMsg[ iFunc ] );
		}
		else
		{
			strcpy( szError, ErrorMsg2[ 0 ] );
			strcat( szError, ErrorMsg2[ iFunc ] );
		}
#else
		strcpy( szError, ErrorMsg[ 0 ] );
		strcat( szError, ErrorMsg[ iFunc ] );
#endif
		PutStr( szError );
#ifdef BILINGUAL
		if (IsDBCSCodePage())
			PutStr( szMiniHelp );
		else
			PutStr( szMiniHelp2 );
#else
		PutStr( szMiniHelp );
#endif
	}
	return( iFunc	);
}

/***************************************************************************/
/* Calls the appropriate function to do whatever was specified by the		*/
/* user. The lie table if first read in except in the case only the help	*/
/* function was requested. To be sure duplicate table entries are not		*/
/* created a call to DeleteEntry with the new program name will be done		*/
/* before the new entry is created.														*/
/*																									*/
/*	int DoFunction( int iFunc )															*/
/*																									*/
/*	ARGUMENTS:	iFunct - The function to be performed								*/
/*	RETURNS:		int	 - S_OK if no errors else an error code					*/
/*																									*/
/***************************************************************************/

int DoFunction( int iFunc )
{
	register		iStatus;

	if ( iFunc == DO_HELP )
	{
#ifdef BILINGUAL
		if (IsDBCSCodePage())
			DisplayMsg( Help );
		else
			DisplayMsg( Help2 );
#else
		DisplayMsg( Help );
#endif
		return( S_OK );
	}

	if ( iFunc == DO_ADD_FILE )
#ifdef BILINGUAL
		if (IsDBCSCodePage())
			DisplayMsg( Warn );
		else
			DisplayMsg( Warn2 );
#else
		DisplayMsg( Warn );							/* Read in the lie table and	*/
#endif
															/* then decide what to do		*/
	if ( (iStatus = ReadVersionTable()) == S_OK )
	{
		if ( iFunc == DO_LIST )
			iStatus = DisplayTable();
		else
		{
			if ( (iFunc == DO_DELETE || iFunc == DO_QUIET) &&
				  (iStatus = MatchFile( LieBuffer, Entry.szFileName )) < S_OK )
				return( iStatus );
															/* Always a delete before add	*/

			if ( (iStatus = DeleteEntry()) == S_OK &&	iFunc == DO_ADD_FILE )
				iStatus = AddEntry();

			if ( iStatus == S_OK &&
				  (iStatus = WriteVersionTable()) == S_OK &&
				   !(iFunc == DO_QUIET) )
			{
#ifdef BILINGUAL
				if (IsDBCSCodePage())
					PutStr( SuccessMsg );
				else
					PutStr( SuccessMsg_2 );
				if ( SetVerCheck() == TRUE )		/* M001 */
				{
					if (IsDBCSCodePage())
						PutStr( SuccessMsg2 );
					else
						PutStr( SuccessMsg2_2 );
				}
#else
				PutStr( SuccessMsg );
				if ( SetVerCheck() == TRUE )		/* M001 */
					PutStr( SuccessMsg2 );
#endif
			}
		}
	}
					/* M001 Install check to see if currently in device chain */
	if ( iStatus == S_OK && iFunc != DO_QUIET && SetVerCheck() == FALSE )
#ifdef BILINGUAL
	{
		if (IsDBCSCodePage())
			DisplayMsg( szNoLoadMsg );
		else
			DisplayMsg( szNoLoadMsg2 );
	}
#else
		DisplayMsg( szNoLoadMsg );
#endif

	return( iStatus );
}

/***************************************************************************/
/* Displays the help text for "/?" option, or the warning text.				*/
/*																									*/
/*	void DisplayHelp( tbl )																	*/
/*																									*/
/*	ARGUMENTS:	char *tbl[]													 				*/
/*	RETURNS:		void																			*/
/*																									*/
/***************************************************************************/

void DisplayMsg( char *tbl[] )
{
	register i;

	for ( i = 0; tbl[i] != NULL; i++ )
		PutStr( tbl[ i ] );
}

/***************************************************************************/
/* Displays all entries in the version table which must have already been	*/
/* read into the work buffer. The name and version number are created as	*/
/* as ascii string in a tempory buffer and then printed as a single string */
/* in the format:																			 	*/
/*																								 	*/
/*	1234567890123456789																		*/
/*	FILENAME.EXT	X.XX																		*/
/*																								 	*/
/*	int DisplayTable( void )														 		*/
/*																								 	*/
/*	ARGUMENTS:	void																			*/
/*	RETURNS:		int	- S_CORRUPT_TABLE if table corrupt else S_OK				*/
/*																								 	*/
/***************************************************************************/

int DisplayTable( void )
{
	char		*BufPtr;
	char		*szTmp;
	char		*szVersion;
	char		szEntry[ 50 ];

	BufPtr = LieBuffer;
	szVersion = szEntry + VERSION_COLUMN;

	PutStr( "" );
	while ( *BufPtr != 0 && BufPtr < EndBuf )
	{
														 	/* Chk for table corruption	*/
		if ( !IsValidEntry( BufPtr ) )
			return( S_CORRUPT_TABLE );
												/* Copy file name and pad with spaces	*/
		strncpy( szEntry, BufPtr+1, (unsigned)((int)*BufPtr) );
		for ( szTmp = szEntry + *BufPtr; szTmp < szVersion; szTmp++ )
			*szTmp = ' ';

															/* Point to version number		*/
		BufPtr += *BufPtr;
		BufPtr++;

															/* Now create ascii version	*/
		itoa( (int)*(BufPtr++), szVersion, DECIMAL );
		strcat( szVersion, (int)*BufPtr < 10 ? ".0" : "." );
		itoa( (int)*(BufPtr++), strchr( szVersion, EOL ), DECIMAL );

		PutStr( szEntry );
	}
	if ( BufPtr == LieBuffer )
#ifdef BILINGUAL
	{
		if (IsDBCSCodePage())
			PutStr( szTableEmpty );
		else
			PutStr( szTableEmpty2 );
	}
#else
		PutStr( szTableEmpty );
#endif

	return( S_OK );
}


/***************************************************************************/
/* Deletes all matching entries in the version table by moving all of the	*/
/* entries following the matched entry down in the buffer to replace the	*/
/* entry being deleted. After the entries are moved down the residuals		*/
/* at the end of the table must be zeroed out. Before returning the entire */
/* end of the table buffer after the valid entries is zeroed out to remove */
/* any possible corruption.																*/
/*																									*/
/*	int DeleteEntry( void )																	*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- S_CORRUPT_TABLE if errors found else S_OK				*/
/*																									*/
/***************************************************************************/

int DeleteEntry( void )
{
	char		*pchPtr;
	char		*pchTmp;
	int		iOffset;
	UINT		uEntryLen;
	UINT		uBlockLen;

	pchPtr = LieBuffer;

	while ( (iOffset = MatchFile( pchPtr, Entry.szFileName )) >= 0 )
	{
		pchPtr = LieBuffer + iOffset;						/* Move block down		*/
		uEntryLen = (UINT)((int)*pchPtr) + 3;
		uBlockLen = (UINT)(EndBuf - pchPtr) + uEntryLen;
		memmove( pchPtr, pchPtr + uEntryLen, uBlockLen );

		pchTmp = pchPtr + uBlockLen;			 			/* Clean end of blk		*/
		memset( pchTmp, 0, uEntryLen );
	}

	if ( iOffset == S_ENTRY_NOT_FOUND )		 			/* Clean end of table	*/
	{
		if ( (pchTmp = GetNextFree()) != NULL )
			memset( pchTmp, 0, DevHdr.TblLen - (unsigned)(pchTmp - LieBuffer) );
		return( S_OK );
	}
	else
		return( S_CORRUPT_TABLE );
}


/***************************************************************************/
/* Adds a new entry to the end of any existing entries in the version		*/
/* table. There must be suffient room in the table for the entry or the	 	*/
/* call will fail with a S_NO_ROOM error returned.									*/
/*																									*/
/*	int AddEntry( void )																		*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- S_OK if room for entry else S_NO_ROOM		 			*/
/*																									*/
/***************************************************************************/

int AddEntry( void )
{
	register		iLen;
	char			*pchNext;

	iLen = (int)strlen( Entry.szFileName ) + 3;

	if ( (pchNext = GetNextFree()) != NULL && iLen <= EndBuf - pchNext )
	{
		*pchNext = (char)(iLen - 3);
		strcpy( pchNext + 1, Entry.szFileName );
		pchNext += (int)(*pchNext) + 1;
		*(pchNext++) = (char)Entry.MajorVer;
		*pchNext = (char)Entry.MinorVer;
		return( S_OK );
	}
	else
		return( S_NO_ROOM );
}


/***************************************************************************/
/* Returns the offset of a specified name in the version table. The start	*/
/* of the search is specified by the caller so that searches for duplicate */
/* entries can be made without redundency. NOTE: file name entries in the	*/
/* version table are not zero terminated strings so the comparision must	*/
/* be conditioned by length and the search strings length must be checked	*/
/* to avoid an error caused by a match of a shorter table entry name.		*/
/*																								 	*/
/*	int MatchFile( char *pchStart, char *szFile )							 		*/
/*																								 	*/
/*	ARGUMENTS:	pchStart - Ptr specifying search starting point	 				*/
/*					szFile	- Ptr to file name to match								*/		
/*	RETURNS:		int		- Offset of entry from start of version				*/
/*								  buffer or -1 if not match or							*/
/*								  S_CORRUPT_TABLE if error					 				*/
/*																								 	*/
/***************************************************************************/

int MatchFile( char *pchPtr, char *szFile )
{
	for ( ; pchPtr < EndBuf && *pchPtr != 0; pchPtr += *pchPtr + 3 )
	{
		if ( !IsValidEntry( pchPtr ) )						/* Corruption check	*/
			return( S_CORRUPT_TABLE );
		else if ( strncmp( szFile, pchPtr + 1, (UINT)((int)*pchPtr) ) == S_OK &&
					 *(szFile + *pchPtr) == EOL )
			return( pchPtr - LieBuffer );						/* Return ptr offset */
	}
	return( S_ENTRY_NOT_FOUND );								/* Return no match	*/
}

/***************************************************************************/
/* Checks a version table entry to see if it a valid entry. The definition */
/* of a valid entry is one which has a file length less than MAX_NAME_LEN	*/
/* and the entire entry lies within the version table.							*/
/*																								 	*/
/*	int IsValidEntry( char *pchPtr )														*/
/*																								 	*/
/*	ARGUMENTS:	pchPtr - Ptr to version tbl entry in table buffer				*/
/*	RETURNS:		int	 - TRUE if entry is valid else FALSE						*/
/*																								 	*/
/***************************************************************************/

int IsValidEntry( char *pchPtr )
{
	if ( (int)*pchPtr < MAX_NAME_LEN && (pchPtr + (int)*pchPtr + 3) < EndBuf )
		return( TRUE );
	else
		return( FALSE );
}


/***************************************************************************/
/* Returns a pointer to the next free entry in the version table. If there */
/* are no free entries left in the buffer a NULL ptr will be returned.		*/
/* Since DeleteEntry is always called before AddEntry there is no check	 	*/
/* for table corruption since it will have already been done by the			*/
/* DeleteEntry call.																		 	*/
/*																								 	*/
/*	char *GetNextFree( void )																*/
/*																								 	*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		char*	- Ptr to next free entry or NULL if tbl full 			*/
/*																								 	*/
/* NOTE: This caller of this function must check to be sure any entry any	*/
/*			entry to be added at the ptr returned will fit in the remaining	*/
/*			buffer area because the remaining buffer size may be less than	 	*/
/*			MAX_ENTRY_SIZE.																	*/
/*																								 	*/
/***************************************************************************/

char *GetNextFree( void )
{
	char		*pchPtr;

	for ( pchPtr = LieBuffer; *pchPtr != 0 && pchPtr < EndBuf;
			pchPtr += *pchPtr + 3 )
		;

	return( pchPtr < EndBuf ? pchPtr : NULL );
}

/***************************************************************************/
/* Opens the DOS system file and reads in the table offset and length		*/
/* structure. Then allocates a buffer and reads in the table.					*/
/*																									*/
/*	int ReadVersionTable( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- OK if successful else error code							*/
/*																									*/
/***************************************************************************/

int ReadVersionTable( void )
{
	register		iStatus;						/* Function's return value				*/
	int			iFile;						/* DOS file handle 						*/
	unsigned		uRead;						/* Number of bytes read from file	*/


			/* Open the file and read in the max buffer len from stack seg		*/

	if ( _dos_open( Entry.Path, O_RDONLY, &iFile ) != S_OK )
		return( S_FILE_NOT_FOUND );

	if ( _dos_read( iFile, &ExeHdr, sizeof( ExeHdr ), &uRead ) == S_OK &&
		  uRead == sizeof( ExeHdr ) )
	{
		FileOffset += (long)(ExeHdr.HeaderParas * 16);
		if ( SeekRead( iFile, &DevHdr, FileOffset, sizeof( DevHdr ) ) == S_OK )
		{
			if ( strncmp( DevHdr.Name, szSetVer, 8 ) == S_OK &&
				  DevHdr.VersMajor == 1 )
			{
				FileOffset += DevHdr.TblOffset;
				if ( (LieBuffer = malloc( DevHdr.TblLen )) == NULL )
					iStatus = S_MEMORY_ERROR;

				else if ( SeekRead( iFile, LieBuffer, FileOffset,
							 DevHdr.TblLen ) == S_OK )
				{
					iStatus = S_OK;
					EndBuf = LieBuffer + DevHdr.TblLen;
				}
			}
			else
				iStatus = S_INVALID_SIG;
		}
		else
			iStatus = S_FILE_READ_ERROR;
	 }
	 else
		iStatus = S_FILE_READ_ERROR;
	_dos_close( iFile );

	return( iStatus );
}

/***************************************************************************/
/* Opens the DOS system file and writes the versin table back to the file. */
/*																									*/
/*	int WriteVersionTable( void )															*/
/*																									*/
/*	ARGUMENTS:	NONE																			*/
/*	RETURNS:		int	- OK if successful else error code							*/
/*																									*/
/***************************************************************************/

int WriteVersionTable( void )
{
	register			iStatus;					/* Function's return value				*/
	int				iFile;					/* DOS file handle						*/
	unsigned			uWritten;				/* Number of bytes written to file	*/
	struct find_t	Info;

	if ( _dos_findfirst( Entry.Path, _A_HIDDEN|_A_SYSTEM, &Info ) == S_OK &&
		  _dos_setfileattr( Entry.Path, _A_NORMAL ) == S_OK &&
		  _dos_open( Entry.Path, O_RDWR, &iFile ) == S_OK )
	{
		if ( _dos_seek( iFile, FileOffset, SEEK_SET ) == FileOffset &&
			  _dos_write(iFile, LieBuffer, DevHdr.TblLen, &uWritten ) == S_OK &&
			  uWritten == DevHdr.TblLen )
			iStatus = S_OK;
		else
			iStatus = S_FILE_WRITE_ERROR;

		_dos_setftime( iFile, Info.wr_date, Info.wr_time );
		_dos_close( iFile );
		_dos_setfileattr( Entry.Path, (UINT)((int)(Info.attrib)) );
	}
	else
		iStatus = S_FILE_NOT_FOUND;

	return( iStatus );
}

/***************************************************************************/
/* Seeks to the specified offset in a file and reads in the specified		*/
/* number of bytes into the caller's buffer.											*/
/*																									*/
/*	unsigned SeekRead( int iFile, char *Buf, long lOffset, unsigned uBytes )*/
/*																									*/
/*	ARGUMENTS:	iFile		- Open DOS file handle										*/
/*					Buf		- Ptr to read buffer											*/
/*					lOffset	- Offset in file to start reading at					*/
/*					uBytes	- Number of bytes to read									*/
/*	RETURNS:		unsigned	- S_OK if successfull else S_FILE_READ_ERROR			*/
/*																									*/
/***************************************************************************/

int SeekRead( int iFile, void *Buf, long lOffset, unsigned uBytes )
{
	unsigned		uRead;

	if ( _dos_seek( iFile, lOffset, SEEK_SET ) == lOffset &&
		  _dos_read( iFile, Buf, uBytes, &uRead ) == S_OK &&
		  uRead == uBytes )
		return( S_OK );
	else
		return( S_FILE_READ_ERROR );
}


#ifdef BILINGUAL
int	IsDBCSCodePage()
{
	union REGS inregs,outregs;

	inregs.x.ax = 0x4f01;
	int86(0x2f,&inregs,&outregs);

#ifdef JAPAN
	if (outregs.x.bx == 932)
#endif
#ifdef KOREA
	if (outregs.x.bx == 949)
#endif
#ifdef PRC
	if (outregs.x.bx == 936)
#endif
#ifdef TAIWAN
	if (outregs.x.bx == 950)
#endif
		return(1);
	else
		return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\br\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
        "\r\nERROR: ",
        "Opo invlida.",
        "Nome de arquivo invlido.",
        "No h memria suficiente.",
        "Verso invlida. O formato deve ser 2.11 - 9.99.",
        "No foi localizada a entrada especificada na tabela de verso.",
        "No foi possvel encontrar o arquivo SETVER.EXE.",
        "A unidade especificada no  vlida.",
        "H muitos parmetros na linha de comando.",
        "Falta um parmetro.",
        "Lendo o arquivo SETVER.EXE.",
        "A tabela de verso est danificada.",
        "A verso do arquivo SETVER no caminho especificado no  compatvel.",
        "No h mais espao para novas entradas na tabela de verso.",
        "Gravando o arquivo SETVER.EXE."
        "Foi especificado um caminho invlido para SETVER.EXE."
};

char *SuccessMsg                = "\r\nA tabela de verso foi atualizada com xito";
char *SuccessMsg2               = "A mudana de verso ter efeito na prxima vez que reiniciar o sistema";
char *szMiniHelp                = "       Se desejar obter ajuda, execute \"SETVER /?\"";
char *szTableEmpty      	= "\r\nNo foram localizadas entradas na tabela de verso";

char *Help[] =
{
        "Define o nmero de verso que o MS-DOS relata a um programa.\r\n",
        "Exibe a tabela de verso atual: SETVER [unidade:caminho]",
        "Adiciona uma entrada:           SETVER [unidade:caminho] arquivo n.nn",
        "Exclui uma entrada:             SETVER [unidade:caminho] arquivo /DELETE [/QUIET]\r\n",
        "  [unidade:caminho] Especifica a localizao do arquivo SETVER.EXE.",
        "  arquivo           Especifica o nome do programa.",
        "  n.nn              Especifica a verso do MS-DOS a ser relatada ao programa.",
        "  /DELETE ou /D     Exclui a entrada da tabela de verso relativa ao programa",
        "                    especificado.",
        "  /QUIET            Oculta a mensagem que normalmente  exibida ao se excluir",
        "                    uma entrada da tabela de verso.",
        NULL

};
char *Warn[] =
{
   "\nAVISO - O aplicativo que est sendo adicionado  tabela de verso do",
   "MS-DOS pode no ter sido verificado pela Microsoft nesta verso do MS-DOS.",
   "Entre em contato com o distribuidor de software para determinar se este",
   "aplicativo ser executado corretamente com esta verso do MS-DOS.",
   "Se este aplicativo for executado especificando um nmero de verso do MS-DOS",
   "diferente, os dados podem ser perdidos, danificados ou poder haver",
   "instabilidades no sistema. Em tais circunstncias, a Microsoft no se",
   "responsabiliza por nenhuma perda ou dano.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
        "",
        "OBSERVAO: O dispositivo SETVER no foi carregado. Para ativ-lo ",
        "            voc deve carregar o dispositivo SETVER.EXE no CONFIG.SYS.",
        NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\dos.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;================= DOS.ASM =========================
COMMENT #


  johnhe - 05/09/90

END COMMENT #

;========================================================

INVALID_DRIVE	EQU	15
DOS_PUTCHAR	EQU	02

DOSSEG
.Model	  SMALL,C


.Data

CrLf	db	0dh, 0ah, 0


.Code

; =========================================================================
; Verifies that a drive exists using the IsChangeable IOCtl function.
;
; int IsValidDrive( char DrvLetter )
;
; ARGUMENTS:	DrvLetter	- The drive letter to verify
; RETURNS:	int		- FALSE if not a valid drive letter
;				  else !FALSE
;
; =========================================================================

IsValidDrive	PROC Drive:WORD

	mov	BX,Drive		; BX = Drive number
	cmp	BX,26			; Make not greater than drive Z
	jg	NotValid

	mov	AX,4408h		; AX = IOCtl Is changeable function
	int	21h
	jnc	IsValid			; Drv valid
					; Else check error code to see if
	cmp	AX,INVALID_DRIVE	; invalid drive error
	jne	IsValid 		; Drive is valid

NotValid:
	xor	AX,AX			; Return FALSE
	jmp	SHORT DrvChkRet		; Done

IsValid:
	mov	AX,1			; Return TRUE

DrvChkRet:
	ret				; Return AX = TRUE or FALSE
	
IsValidDrive	ENDP

; =========================================================================
; Displays a zero terminated ascii string on the console followed by
; a carriage return line feed conbination.
;
; void PutStr( char *String )
;
; ARGUMENTS:	String - Ptr to string to be displayed
; RETURNS:	void
;
; =========================================================================

PutStr PROC USES SI, String:PTR

	mov	SI,String			; DS:SI -> to caller's string
	mov	CX,2				; 2 loops 

PrintLoop:
	cld					; Always clear direction flag
	lodsb					; Load char in AL & inc SI
	or	AL,AL				; Test for EOL character
	jz	EndOfStr

	mov	AH,DOS_PUTCHAR			; AH = DOS put char function
	mov	DL,AL				; Put character to print in DL
	int	21h				; Output the character
	jmp	SHORT PrintLoop			; Go back and do the next one

EndOfStr:
	mov	SI,OFFSET CrLf			; DS:SI -> CR/LF return string
	loop	PrintLoop			; Go back and print CR/LF

	ret

PutStr ENDP

; =========================================================================
;
; Seeks to the specified offset in an open disk
; disk file.
; 
; long	_dos_seek( int Handle, long lOffset, int Mode )
; 
; ARGUMENTS:	Handle	- Open DOS file handle
; 		lOffset - Offset to seek to in bytes
; 		Mode	- Seek mode as described below
; 			  0 = Beginning of file + offset
; 			  1 = Current file position + offset
; 			  2 = End of file + offset
; RETURNS:	long	- New offset in file is success
; 			  or -1L if error
; =========================================================================
  
_dos_seek PROC USES ES, Handle:WORD, lOffset:DWORD, Mode:BYTE

	mov	AH,42h		; AH = DOS file SEEK function
	mov	AL,Mode		; AL = SEEK mode specified by caller
	mov	BX,Handle	; BX = Open file handle from caller

LoadOffset:
	les	DX,lOffset	; Load file offset into ES:DX
	mov	CX,ES		; CX:DX = Offset to seek to in the file

Int21Call:
	int	21h		; DOS call
	jc	SeekError	; Error check
	jmp	SHORT SeekReturn ;Everything is OK

SeekError:
	mov	AX,-1		; Error code
	cwd			; Extend sign to make a LONG (dword)

SeekReturn:
	ret

_dos_seek ENDP

; =======================================================
; M001 ; Start of changes to check for SETVER.EXE in the
;        device chain.
; =======================================================

.DATA

SetVerStr	db	'SETVERXX'

LEN_SETVERSTR	EQU	$-SetVerStr

.Code

; =======================================================
;
; Checks to see if SETVER.EXE was installed as as a device
; driver by walking the device chain looking for the name
; "SETVERXX".
;
; int SetVerCheck ( void )
; 
; ARGUMENTS:	NONE
; RETURNS:	int - TRUE if SetVer device driver is installed else FALSE
;
; =======================================================

SetVerCheck PROC USES SI DI DS ES
	ASSUME	ES:NOTHING

	mov	AH,52h
	int	21h			; ES:BX --> first DBP

	push	BX			; Save offset
	mov	AH,30h
	int	21h			; AL == Major version
	pop	DI			; Restore DPB offset to BX

	add	DI,17h			; DOS 2.x offset of NULL device is 17h
	cmp	AL,2			; See if version is really 2.x
	jle	@f
	add	DI,0bh			; Offset for DOS > 2.x is 22h
@@:
	mov	AX,@DATA
	mov	DS,AX

	mov	SI,OFFSET SetVerStr
	mov	CX,LEN_SETVERSTR
	cld

NameCmpLoop:
	cmp	DI,0ffffh		; See if ES:DX is xxxx:ffff
	je	NoSetVer

SaveSetup:
	push	CX			; Save name length
	push	DI			; Save ptr to current device
	push	SI			; Save ptr to SetVer string
	add	DI,0ah			; ES:DI --> Device name + 1
	
	repe	cmpsb
	pop	SI
	pop	DI
	pop	CX

	je	FoundSetVer
	les	DI,ES:[DI]		; Load ptr to next device.
	jmp	SHORT NameCmpLoop

NoSetVer:
	xor	AX,AX
	jmp	SHORT SetVerReturn

FoundSetVer:
	mov	AX,1

SetVerReturn:
	ret

SetVerCheck ENDP

; =======================================================
; M001 ; End of changes
; =======================================================

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\parse.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/* PARSE.C 													 									*/				 
/*																									*/						
		 
/*	Command line parsing functions for SETVER.C.										*/
/*																									*/
/*	Valid command lines are:																*/
/*		List table: 					SETVER [D:\path] 									*/
/*		Add entry:						SETVER [D:\path] name.ext X.XX			 	*/
/*		Delete entry:					SETVER [D:\path] name.ext /DELETE		 	*/
/*		Display help					SETVER /? 											*/
/*		Delete entry quietly:		SETVER [D:\path] name.ext /DELETE /QUIET	*/
/*																									*/
/*	The following error codes are returned: 											*/
/*																									*/
/*		S_INVALID_SWITCH	Invalid switch										 			*/
/*		S_INVALID_FNAME	Invalid file name 								 			*/
/*		S_BAD_VERSION_FMT	Invalid version number format 		 					*/
/*		S_BAD_DRV_SPEC		Invalid drive/path specifier				 				*/
/*		S_TOO_MANY_PARMS	Too many command line parameters	 						*/
/*		S_MISSING_PARM		Missing parameter 								 			*/
/*		S_INVALID_PATH		Path specifier is invalid									*/
/*																									*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

#include	<stdio.h>
#include	<stdlib.h>
#include	<ctype.h>
#include	<string.h>
#include	<dos.h>
#include	<direct.h>

#include	<setver.h>

/***************************************************************************/
/* Parses the command line to get the optional drive letter, optional 		*/
/* executable file name and optional switch /DELETE. Also handles a single */
/* "/?" switch for displaying command help. The /DELETE switch will accept */
/* any number of chars in the the word DELETE for the switch. 	Also			*/
/* supports a /QUIET switch, similarly handled, but only valid in 			*/
/* combination with the /DELETE switch													*/
/*																									*/
/*	int ParseCmd( int argc, char *argv[], struct TableEntry *Entry )	 		*/
/*																									*/
/*	ARGUMENTS:	argc	- Count of command line arguments 					 		*/
/*					argv	- Array of ptrs to command line argments		 			*/
/*					Entry - Ptr to struct to be filled in 						 		*/
/*	RETURNS:		int 	- Valid function number or parse error code  			*/
/*																									*/
/***************************************************************************/

int ParseCmd( int argc, char *argv[], struct TableEntry *Entry )
{
	register		Funct;
	unsigned		uVersion;
	int			iTmp;
	int			iStrLen;

	strcpy( Entry->Path, argv[0] );			/* Set default setver.exe path	*/

	if ( argc == 1 )								/* Chk for default of 0 parms		*/
		return( DO_LIST );						/* No args so just do a listing	*/

	for ( iTmp = 1; iTmp < argc; iTmp++ )
                strupr( argv[ iTmp ] );                                        /* Convert params to upper case */

														/* Chk for help switch				*/
	if ( MatchSwitch( argv[ 1 ], HELP_SWITCH ) )
		return( argc > 2 ? S_TOO_MANY_PARMS : DO_HELP);

	iTmp = 1;

												/* Chk for optional drive:\path spec	*/
	if ( strchr( argv[1], ':' ) )
	{
                if ( IsValidDrive( (unsigned)argv[1][0] - 0x40 ) && argv[1][1] == ':' )
		{
			if ( (iStrLen = strlen( argv[1] )) > (MAX_PATH_LEN - 1) )
				return( S_INVALID_PATH );
			else
			{
				strcpy( Entry->Path, argv[1] );
#ifdef DBCS
				if ( (*(Entry->Path + iStrLen - 1) != '\\' && argv[1][2] != EOL )
					|| CheckDBCSTailByte(Entry->Path,Entry->Path + iStrLen - 1) )
#else
				if ( *(Entry->Path + iStrLen - 1) != '\\' && argv[1][2] != EOL )
#endif
					strcat( Entry->Path, "\\" );
				strcat( Entry->Path, "SETVER.EXE" );
				iTmp++;
			}
		}
		else
			return( S_BAD_DRV_SPEC );
	}

	if ( iTmp >= argc )
		Funct = DO_LIST;

	else if ( IsValidFileName( argv[ iTmp ] ) )
	{
		strcpy( Entry->szFileName, argv[ iTmp++ ] );

		if ( iTmp >= argc )				/* Version # or /D or /Q must follow	*/
			Funct = S_MISSING_PARM;

				/* note that Quiet switch requires Del switch also be supplied */
		else if ( MatchSwitch( argv[ iTmp ], DEL_SWITCH ) )
		{
			if ( ++iTmp < argc )	 /* more args left */
			{
				if (MatchSwitch(argv[iTmp], QUIET_SWITCH))
					Funct = (++iTmp < argc ? S_TOO_MANY_PARMS : DO_QUIET);
				else
					Funct = S_TOO_MANY_PARMS;
			}
			else
				Funct = DO_DELETE;
		}
		else if ( MatchSwitch( argv[iTmp], QUIET_SWITCH ) )
		{
			if ( ++iTmp < argc )						 /* must find delete switch	*/
				if (MatchSwitch(argv[iTmp], DEL_SWITCH))
					Funct = (++iTmp < argc ? S_TOO_MANY_PARMS : DO_QUIET);
				else
					Funct = S_INVALID_SWITCH;
			else
				Funct = S_INVALID_SWITCH;
		}
		else if ( *argv[iTmp] == '/' )		/* Make sure not a bogus switch	*/
			Funct = S_INVALID_SWITCH;
		else if ( (uVersion = ParseVersion( argv[ iTmp++ ] )) != 0 )
		{
			Entry->MajorVer = (char)(uVersion >> 8);
			Entry->MinorVer = (char)(uVersion & 0xff);
			Funct = (iTmp < argc ? S_TOO_MANY_PARMS : DO_ADD_FILE);
		}
		else
			Funct = S_BAD_VERSION_FMT;
	}
	else
		Funct = S_INVALID_FNAME;

	return( Funct );
}


/***************************************************************************/
/* Parses a DOS major and minor version number from an ascii string in the */
/* form of "00.00" where the major number is on the left of the decminal	*/
/* point and the minor version follows the version number. Valid version	*/
/* numbers are decimal numbers between 2.00 and 9.99.				 				*/
/*										 															*/
/*	unsigned ParseVersion( char *szDosVer )					 						*/
/*										 															*/
/*	ARGUMENTS:	szDosVer - Ptr to an ascii verion number string 	 			*/
/*	RETURNS:		unsigned - Version # in the form (Major << 8) + 	 			*/
/*								  Minor or 0 if not valid version string  			*/
/*																									*/
/***************************************************************************/

unsigned ParseVersion( char *szDosVer )
{
	unsigned		Version = 0;
	size_t		Len;
	char			*szMinor;

		/* First parse the minor version number */
	if ( (szMinor = strchr( szDosVer, '.' )) != NULL )
	{
		*szMinor = EOL;
		szMinor++;
		if ( (Len = strlen( szMinor )) > 2	|| !IsDigitStr( szMinor ) )
			Version = (unsigned) S_ERROR;
		else
		{
			Version = (unsigned)atoi( szMinor );
			while( Len++ < 2 )								/* Convert .x to .x0	*/
				Version *= 10;
		}
	}
		/* Now get the major part of the number */
	szDosVer = SkipLeadingChr( szDosVer, '0' );
	if ( Version == (unsigned)S_ERROR || strlen( szDosVer ) > 2 ||
			 !IsDigitStr( szDosVer ) )
		Version = 0;
	else
		Version |= ((unsigned)atoi( szDosVer ) << 8);

		/* Check for min and max versions */
	if ( Version < MIN_VERSION || Version >= MAX_VERSION )
		Version = 0;

	return( Version );
}

/***************************************************************************/
/* Checks a string to verify that all characters in the string are decmial */
/* numbers 0-9.									 											*/
/*										 															*/
/*	int IsDigitStr( char *szStr )						 									*/
/*										 															*/
/*	ARGUMENTS:	szStr - Ptr to ascii string to be scanned 				 		*/
/*	RETURNS:		int 	- TRUE if all chars are numbers else FALSE	 			*/
/*										 															*/
/***************************************************************************/

int IsDigitStr( char *szStr )
{
	while( *szStr != EOL	)
	{
		if ( !isdigit( *(szStr++) ) )
			return( FALSE );
	}
	return( TRUE );
}

/***************************************************************************/
/* Accepts a pointer to a string and a single character to match. Returns  */
/* a ptr to the first character in the string not matching the specified	*/
/* character.									 												*/
/*										 															*/
/*	char *SkipLeadingChr( char *szStr, char chChar )			 					*/
/*										 															*/
/*	ARGUMENTS:	szStr  - Ptr to an ascii string										*/
/*					chChar - Ascii character to match 								 	*/
/*	RETURNS:		char * - Ptr to first char in the string not			 			*/
/*								matching the specified character 				 		*/
/***************************************************************************/

char *SkipLeadingChr( char *szStr, char chChar )
{
	while( *szStr == chChar )
		szStr++;
	return( szStr );
}


/***************************************************************************/
/* Compares a cmd line switch against a test string. The test switch is an */
/* ascii string which will be used as a pattern to be matched against the  */
/* command string. The command string may be any subset of the test string */
/* which has been prefixed with a switch character.				 				*/
/*										 															*/
/*	int MatchSwitch( char *szCmdParm, char *szTestSwitch )			 			*/
/*										 															*/
/*	ARGUMENTS:	szCmdParm		- Command line parameter to be tested 			*/
/*					szTestSwitch	- Switch to test command line against 			*/
/*	RETURN:		int				- TRUE if there is a match else FALSE 			*/
/*																									*/
/***************************************************************************/

int MatchSwitch( char *szCmdParm, char *szTestSwitch )
{
		/* Must have a leading '/' and at least 1 char */
	if ( *(szCmdParm++) != SWITCH_CHAR || *szCmdParm == EOL )
		return( FALSE );

	while ( *szTestSwitch != EOL && *szTestSwitch == *szCmdParm )
		szTestSwitch++, szCmdParm++;

	return( *szCmdParm == EOL ? TRUE : FALSE );
}


/***************************************************************************/
/* Scans a string to see if the string can be used a valid file name.		*/
/* The scan checks to be sure each character in the name is a valid		 	*/
/* character for a path name. There is also a check to be sure that only	*/
/* there is not more than 1 decimal in the name and that if there is a		*/
/* decimal that the primary name and extension do not exceed the maximum	*/
/* length of 8 chars for primary and 3 for extension. If the name does		*/
/* not include a decimal the max length is 8 characters.			 				*/
/*										 															*/
/*	int IsValidFileName( char *szPath )					 								*/
/*										 															*/
/*	ARGUMENTS:	szFile - String containing a file name. 					 		*/
/*	RETURNS	:	int 	 - TRUE if valid name else FALSE. 					 		*/
/*										 															*/
/***************************************************************************/

int IsValidFileName( char *szFile )
{
	char *szDecimal;

	RemoveTrailing( szFile, '.' );

		/*
		 *	Check to be sure length of filename is greater than 0,
		 *	there are no invalid file characters,
		 *	there is no path associated with the filename,
		 *	the filename is not a reserved DOS filename, and
		 *	there are no wildcard characters used in the filename.
	 	*/
#ifdef DBCS
	if ( strlen( szFile ) > 0 && ValidFileChar( szFile ) &&
			 ((strchr(szFile, '\\') == NULL) || CheckDBCSTailByte(szFile,strchr(szFile, '\\'))) &&
			 !IsReservedName( szFile ) && !IsWildCards( szFile ) )
#else
	if ( strlen( szFile ) > 0 && ValidFileChar( szFile ) &&
			 (strchr(szFile, '\\') == NULL) &&
			 !IsReservedName( szFile ) && !IsWildCards( szFile ) )
#endif
	{
			/* Check for appropriate 8.3 filename */
		if ( (szDecimal = strchr( szFile, '.' )) != NULL )
		{
			if ( strchr( szDecimal + 1, '.' ) == NULL &&	/* Chk for more '.'s */
					 (szDecimal - szFile) <= 8 && 			/* Chk lengths			*/
					 (strchr( szDecimal, EOL ) - szDecimal - 1) <= 3 )
				return ( TRUE );
		}
		else if ( strlen( szFile ) <= 8 )
			return ( TRUE );
	}
	return( FALSE );
}

/***************************************************************************/
/* Checks all of the characters in a string to see if they are vaild path  */
/* name characaters.								 											*/
/*										 															*/
/*	int ValidFileChar( char *szFile )					 								*/
/*										 															*/
/*	ARGUMENTS:	szFile - File name string 												*/
/*	RETURN:		int 	 - TRUE if chars in string are valid else 	 			*/
/*								FALSE																*/
/*										 															*/
/***************************************************************************/

int ValidFileChar( char *szFile )
{
	int IsOk = TRUE;

	while ( IsOk && *szFile != EOL )
	#ifdef DBCS
		if (IsDBCSLeadByte(*szFile))
			szFile += 2;
		else
	#endif
		IsOk = IsValidFileChr( *(szFile++) );
	return( IsOk );
}


/***************************************************************************/
/* Checks a file or path name against a list of reserved DOS filenames and */
/* returns TRUE if the name is a reserved name. The function must first		*/
/* off any extension from the name.						 								*/
/*										 															*/
/*	int IsReservedName( char *szFile )					 								*/
/*										 															*/
/*	ARGUMENTS:	szFile - File name string				 								*/
/*	RETURN:		int 	 - TRUE if name is reserved DOS name				 		*/
/*																									*/
/***************************************************************************/

int IsReservedName( char *szFile )
{
	register Status;
	register i;
	char *szTmp;
	static char *apszRes[] = { "AUX", "CLOCK$", "COM1", "COM2",
										"COM3", "COM4", "CON", "LPT", "LPT1",
										"LPT2", "LPT3", "LST", "NUL", "PRN", NULL };

	if ( (szTmp = strchr( szFile, '.' )) != NULL )
		*szTmp = EOL;
	for ( i = 0, Status = FALSE; Status == FALSE && apszRes[i] != NULL; i++ )
                Status = !strcmpi( szFile, apszRes[i] );
	if ( szTmp != NULL )
		*szTmp = '.';

	return( Status );
}

/***************************************************************************/
/* Checks a file or path name for any wildcards (* and ?).	If wildcard 	*/
/* characters exist, it returns TRUE.  Otherwise, it returns FALSE. 			*/
/*										 															*/
/*	int IsWildCards( char *szFile )									 					*/
/*										 															*/
/*	ARGUMENTS:	szFile - File name string				 								*/
/*	RETURN:		int 	 - TRUE if wildcards exist in name					 		*/
/*																									*/
/***************************************************************************/

int IsWildCards( char *szFile )
{
	if ( ((strchr( szFile, '*' )) != NULL) ||
		  ((strchr( szFile, '?' )) != NULL) )
		return( TRUE );
	return( FALSE );
}


/***************************************************************************/
/* Validates a character as a valid path and file name character. 			*/
/*													 												*/
/*	IsValidFileChr( char Char )						 									*/
/*													 												*/
/*	ARGUMENTS:	Char - Character to be tested 										*/
/*	RETURNS:    int  - TRUE if a valid character else FALSE 		 				*/
/*													 												*/
/***************************************************************************/

int IsValidFileChr( char Char )
{
	int IsOk;

	switch( Char )
	{
		case ' '	:
		case '\t' :
		case 0x0d :
		case '/'	:
		case ':'	:
		case ';'	:
		case '='	:
		case '<'	:
		case '>'	:
		case '|'	:
			IsOk = FALSE;
			break;
		default		:
			IsOk = TRUE;
			break;
	}
	return( IsOk );
}

/***************************************************************************/
/* Removes all trailing characters of the type specified from a string. 	*/
/*																									*/
/*	void RemoveTrailing( char *String, char Char )							 		*/
/*																									*/
/*	ARGUMENTS:	String - pointer to a string				 							*/
/*					Char	 - ascii char to remove from end of string				*/
/*	RETURNS:	void							 													*/
/*										 															*/
/***************************************************************************/

void RemoveTrailing( char *String, char Char )
{
	char *EndOfString;

	EndOfString = strchr(String, EOL );
	while( EndOfString != String && *(EndOfString-1) == Char )
		EndOfString--;
	*EndOfString = EOL;
}

/***************************************************************************/
/* Copyright (c) 1989 - Microsoft Corp.                                    */
/* All rights reserved.                                                    */
/*                                                                         */
/* Returns a pointer to the first character in the filename which may or	*/
/* may not be appended to a path.														*/
/* 																								*/
/* char *ParseFileName( char *szPath ) 												*/
/* 																								*/
/* ARGUMENTS:	szPath	- Ptr to a file path in the form d:\xxxx\xxx.xxx	*/
/* RETURNS: 	char *	- Ptr to file name or character after last			*/
/* 							  backslash or ':' in the string if the path did	*/
/* 							  not contain a file name									*/
/*										 															*/
/***************************************************************************/

char *ParseFileName( char *szPath )
{
	char	*szPtr;

	for ( szPtr = szPath;
			*szPtr != EOL && (IsValidFileChr( *szPtr ) ||	*szPtr == ':');
			szPtr++ )
		#ifdef DBCS
			if (IsDBCSLeadByte(*szPtr))
				szPtr++;
		#else
			;
		#endif

	#ifdef DBCS
		while(( --szPtr >= szPath && *szPtr != '\\' && *szPtr != ':') ||
				(szPtr >= szPath && CheckDBCSTailByte(szPath,szPtr)) )
	#else
		while( --szPtr >= szPath && *szPtr != '\\' && *szPtr != ':' )
	#endif
			;

	return( ++szPtr );
}

#ifdef DBCS
/***************************************************************************/
/* Test if the character is DBCS lead byte. 											*/
/*																									*/
/*	int IsDBCSLeadByte(char c)																*/
/*																									*/
/*	ARGUMENTS:	c - character to test 													*/
/*	RETURNS:	TRUE if leadbyte																*/
/*										 															*/
/***************************************************************************/

int IsDBCSLeadByte(c)
unsigned char c;
{
	static unsigned char far *DBCSLeadByteTable = NULL;
	union REGS inregs,outregs;
	struct SREGS segregs;
	unsigned char far *p;


	if (DBCSLeadByteTable == NULL)
	{
		inregs.x.ax = 0x6300;							/* get DBCS lead byte table */
		intdosx(&inregs, &outregs, &segregs);
		FP_OFF(DBCSLeadByteTable) = outregs.x.si;
		FP_SEG(DBCSLeadByteTable) = segregs.ds;
	}

	p = DBCSLeadByteTable;
	while (p[0] || p[1])
	{
		if (c >= p[0] && c <= p[1])
			return TRUE;
		p += 2;
	}
	return ( FALSE );
}


/***************************************************************************/
/*
/*	Check if the character point is at tail byte
/*
/*	input:	*str = strart pointer of the string
/*		*point = character pointer to check
/*	output:	TRUE if at the tail byte
/*
/***************************************************************************/

int	CheckDBCSTailByte(str,point)
unsigned char *str,*point;
{
	unsigned char *p;

	p = point;
	while (p != str)
	{
		p--;
		if (!IsDBCSLeadByte(*p))
		{
			p++;
			break;
		}
	}
	return ((point - p) & 1 ? TRUE : FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\chp\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};

#ifdef BILINGUAL
char *ErrorMsg2[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg_2 		= "\r\nVersion table successfully updated";
char *SuccessMsg2_2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp2 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty2	= "\r\nNo entries found in version table";

char *Help2[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn2[] =
{
										/* m100	*/
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg2[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\cs\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
        "\r\nCHYBA: ",
        "Neplatn pepna.",
        "Neplatn nzev souboru.",
        "Nedostatek pamti.",
        "Neplatn slo verze, formt mus bt: 2.11 - 9.99.",
        "Zadan poloka nebyla nalezena v tabulce verz.",
        "Nelze nalzt soubor SETVER.EXE.",
        "Neplatn specifiktor jednotky.",
        "Pli mnoho parametr pkazov dky.",
        "Schz parametr.",
        "Nat se soubor SETVER.EXE.",
        "Tabulka verz je pokozena.",
        "Soubor SETVER na zadan cest nen kompatibiln s danou verz.",
        "V tabulce verz ji nen prostor pro dal poloky.",
        "Zapisuje se soubor SETVER.EXE."
        "Byla zadna neplatn cesta k souboru SETVER.EXE."
};

char *SuccessMsg                = "\r\nTabulka verz spn aktualizovna";
char *SuccessMsg2               = "Zmna verze nabude platnosti po ptm sputn tohoto systmu";
char *szMiniHelp                = "       Pkaz \"SETVER /?\" zobraz npovdu";
char *szTableEmpty      = "\r\nV tabulce verz nejsou dn poloky";

char *Help[] =
{
        "Nastavit slo verze systmu, kter systm MS-DOS hls programu.\r\n",
        "Zobrazit aktuln tabulku verz: SETVER [jednotka:cesta]",
        "Pidat poloky:                  SETVER [jednotka:cesta] soubor n.nn",
        "Odstranit poloku:               SETVER [jednotka:cesta] soubor /DELETE [/QUIET]\r\n",
        "  [jednotka:cesta]   Uruje umstn souboru SETVER.EXE.",
        "  soubor             Uruje nzev souboru danho programu.",
        "  n.nn               Uruje verzi MS-DOS, kter se m programu nahlsit.",
        "  /DELETE i /D      Odstran poloku z tabulky verz pro dan program.",
        "  /QUIET             Potla zprvu, kter se jinak zobraz pi odstrann",
        "                     poloky z tabulky verz.",
        NULL

};
char *Warn[] =
{
   "\nUPOZORNN - Aplikace, kterou pidvte do tabulky verz MS-DOS, ",
   "zejm nebyla verifikovna firmou Microsoft pro tuto verzi systmu.  ",
   "MS-DOS. Obrate se na dodavatele softwaru a zjistte, zda dan ",
   "aplikace bude sprvn fungovat s touto verz systmu MS-DOS.  ",
   "Pokud tuto aplikaci spustte tak, e nastavte sstm MS-DOS na ",
   "hlen jin verze systmu, pak mete ztratit i pokodit data, nebo ",
   "zpsobit nestabilitu systmu.  V takovm ppad nen spolenost ",
   "Microsoft odpovdn za jakoukoliv ztrtu i kodu.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
        "",
        "POZNMKA: Zazen SETVER nenateno. Hlen verz SETVER se aktivuje",
        "          natenm zazen SETVER.EXE pomoc souboru CONFIG.SYS.",
        NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\es\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Modificador no vlido.",
	"Nombre de archivo no vlido.",
	"Memoria insuficiente.",
	"Versin no vlida. El formato debe ser 2.11 - 9.99.",
	"No se ha encontrado la entrada especificada en la tabla de versin.",
	"No se ha encontrado el archivo SETVER.EXE.",
	"La unidad especificada no es vlida.",
	"Hay demasiados parmetros de lnea de comandos.",
	"Falta un parmetro.",
	"Leyendo el archivo SETVER.EXE.",
	"La tabla de versin est daada.",
	"La versin del archivo SETVER de la ruta especificada no es compatible.",
	"No queda espacio para ms entradas en la tabla de versin.",
	"Escribiendo el archivo SETVER.EXE."
	"Se ha especificado una ruta para SETVER.EXE no vlida."
};

char *SuccessMsg                = "\r\nSe ha actualizado la tabla de versin";
char *SuccessMsg2               = "El cambio de versin harefecto la prxima vez que reinicie su sistema";
char *szMiniHelp                = "       Si desea obtener ayuda utilice \"SETVER /?\"";
char *szTableEmpty      = "\r\nNo se han encontrado entradas en la tabla de versin";

char *Help[] =
{
	"Establece el nmero de versin que MS-DOS indica a los programas.\r\n",
	"Muestra tabla de vers. act.:  SETVER [unidad:ruta]",
	"Agregar entrada:              SETVER [unidad:ruta] archivo n.nn",
	"Eliminar entrada:             SETVER [unidad:ruta] archivo /DELETE [/QUIET]\r\n",
	"  [unidad:ruta]   Especifica la ubicacin del archivo SETVER.EXE.",
	"  archivo         Especifica el nombre de archivo del programa.",
	"  n.nn            Especifica la versin de MS-DOS a usar con el programa.",
	"  /DELETE o /D    Elimina el programa especificado de la tabla de versin.",
	"  /QUIET          Oculta el mensaje que normalmente se muestra al eliminar una",
	"                  entrada de la tabla de versin.",
	NULL

};
char *Warn[] =
{
   "\nADVERTENCIA - La aplicacin que est agregando a la tabla de versin de MS-DOS ",
   "puede no haber sido comprobada por Microsoft en esta versin de MS-DOS.  ",
   "Pongase en contacto con su distribuidor de software para determinar si esta ",
   "aplicacin se ejecutar correctamente con esta versin de MS-DOS.  ",
   "Si ejecuta esta aplicacin especificando que MS-DOS indique un nmero de versin ",
   "de MS-DOS diferente, se puede producir prdida de datos, estos pueden ser daados ",
   "o se puede causar inestabilidad en el sistema. En tales circunstancias, Microsoft ",
   "no es reponsable de ninguna prdida o dao.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
	"",
	"NOTA: no se ha cargado el dispositivo SETVER. Para activar SETVER",
   "      debe cargar el dispositivo SETVER.EXE en su CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\chs\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};

#ifdef BILINGUAL
char *ErrorMsg2[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg_2 		= "\r\nVersion table successfully updated";
char *SuccessMsg2_2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp2 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty2	= "\r\nNo entries found in version table";

char *Help2[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn2[] =
{
										/* m100	*/
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg2[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\cht\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};

#ifdef BILINGUAL
char *ErrorMsg2[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg_2 		= "\r\nVersion table successfully updated";
char *SuccessMsg2_2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp2 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty2	= "\r\nNo entries found in version table";

char *Help2[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn2[] =
{
										/* m100	*/
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg2[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\da\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\el\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\fi\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\fr\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERREUR: ",
	"Commutateur non valide.",
	"Nom de fichier non valide.",
	"Mmoire insuffisante.",
	"Numro de version non valide, le format doit tre 2.11 - 9.99.",
	"L'entre spcifie n'a pas t trouve dans la table de version.",
	"Impossible de trouver le fichier SETVER.EXE.",
	"Spcification de lecteur non valide.",
	"Trop de paramtres sur la ligne de commande.",
	"Paramtre manquant.",
	"Lecture du fichier SETVER.EXE.",
	"La table de version est endommage.",
	"Le fichier SETVER dans le chemin spcifi n'est pas une version compatible.",
	"Il y a plus d'espace dans les nouvelles entres de la table de version.",
	"Ecriture du fichier SETVER.EXE."
	"Un chemin non valide a t spcifi pour SETVER.EXE."
};

char *SuccessMsg 		= "\r\nMise  jour russie pour la table de version";
char *SuccessMsg2		= "La modification de version prendra effet la prochaine fois que vous redmarrez";
char *szMiniHelp 		= "       Utilisez \"SETVER /?\" pour avoir de l'aide";
char *szTableEmpty	= "\r\nAucune entre trouve dans la table de version";

char *Help[] =
{
        "Dfinit le numro de version que MS-DOS fournit  un programme.\r\n",
        "Affiche la table de version courante :  SETVER [lecteur:chemin]",
        "Ajoute une entre :                     SETVER [lecteur:chemin] nom_de_fichier n.nn",
        "Supprime une entre :                   SETVER [lecteur:chemin] nom_de_fichier /DELETE [/QUIET]\r\n",
        "  [lecteur:chemin] Spcifie l'emplacement du fichier SETVER.EXE.",
        "  nom_de_fichier   Spcifie le nom de fichier du programme.",
        "  n.nn             Spcifie la version MS-DOS  fournir au programme.",
        "  /DELETE ou /D    Supprime l'entre de table de version pour le prog. spcifi.",
        "  /QUIET           Cache le message habituellement affich pendant la",
        "                   suppression d'entres de table de version.",
	NULL

};
char *Warn[] =
{
   "\nAVERTISSEMENT - L'application que vous ajoutez  la table de version MS-DOS",
   "peut ne pas avoir t vrifie par Microsoft pour cette version de MS-DOS.  ",
   "Veuillez contacter votre revendeur de logiciel pour savoir si cette ",
   "application fonctionnera correctement avec cette version de MS-DOS.  ",
   "Si vous excutez cette application en instruisant MS-DOS de fournir un ",
   "numro de version MS-DOS diffrent, vous pouvez perdre ou endommager ",
   "des donnes, ou causer une dstabilisation du systme.  Dans ces ",
   "circonstances, Microsoft n'est pas responsable pour toute perte ou dgt.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"Remarque : priphrique SETVER non charg. Pour activer le service de version",
   "           SETVER, chargez le priphrique SETVER.EXE dans CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\no\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\ger\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                        */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nFEHLER: ",
	"Unzulssige Option.",
	"Ungltiger Dateiname.",
	"Zuwenig Arbeitsspeicher.",
	"Unzulssige Versionsnummer, muss zwischen 2.11 und 9.99 liegen.",
	"Angegebener Eintrag in der Versionstabelle nicht gefunden.",
	"Datei SETVER.EXE nicht gefunden.",
	"Ungltige Laufwerksangabe.",
	"Zu viele Parameter in der Befehlszeile.",
	"Fehlender Parameter.",
	"Datei SETVER.EXE wird gelesen.",
	"Versionstabelle ist fehlerhaft.",
	"Datei SETVER im angegebenen Pfad ist eine nicht-kompatible Version.",
	"Kein Speicherplatz mehr in der Versionstabelle fr neue Eintrge.",
	"Datei SETVER.EXE wird geschrieben."
	"Der angegebene Pfad zu SETVER.EXE ist ungltig."
};

char *SuccessMsg                = "\r\nVersionstabelle erfolgreich aktualisiert";
char *SuccessMsg2               = "Der Versionswechsel wird beim nchsten Neustart des Systems wirksam";
char *szMiniHelp                = "        Geben Sie \"SETVER /?\" fr die Anzeige von Hilfe ein.";
char *szTableEmpty      = "\r\nKeine Eintrge in der Versionstabelle gefunden";
char *Help[] =
{
	"Setzt die Versionsnummer, die MS-DOS an ein Programm meldet.\r\n",
	"Versionstabelle anzeigen:  SETVER [Laufwerk:Pfad]",
	"Eintrag hinzufgen:        SETVER [Laufwerk:Pfad] Dateiname n.nn",
	"Eintrag lschen:           SETVER [Laufwerk:Pfad] Dateiname /DELETE [/QUIET]\r\n",
	" [Laufwerk:Pfad]   Position der Datei SETVER.EXE.",
	" Dateiname         Dateiname des Programms.",
	" n.nn              An das Programm zu meldende MS-DOS-Version.",
	" /D(ELETE)    Lscht den Versionstabelleneintrag fr das angegebene Programm.",
	" /QUIET       Zeigt beim Lschen eines Eintrags aus der Versionstabelle keine",
	"              Meldung an.",
	NULL

};
char *Warn[] =
{
	"\nVORSICHT - Die Anwendung, die Sie zur MS-DOS-Versionstabelle hinzufgen,",
	"ist mglicherweise nicht von Microsoft fr diese MS-DOS-Version berprft",
	"worden. Fragen Sie Ihren Software-Hndler, ob dieses Programm mit dieser",
	"Version von MS-DOS korrekt ausgefhrt wird. Wenn Sie MS-DOS anweisen, bei",
	"der Ausfhrung dieser Anwendung eine andere MS-DOS-Versionsnummer zu melden,",
	"knnen Sie Daten verlieren oder beschdigen oder Systeminstabilitten verur-",
	"sachen. Microsoft ist in diesem Fall nicht fr Datenverluste oder -beschdi-",
	"gungen verantwortlich.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
	"",
	"HINWEIS: SETVER-Treiber nicht geladen. Um die SETVER-Versionsmeldung",
     "         zu aktivieren, mssen Sie den SETVER.EXE-Treiber in der ",
     "         Datei CONFIG.SYS laden.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\psu\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\kor\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\n: ",
	" .",
	"  .",
	" .",
	"  . 2.11 9.99   .",
	"    .",
	"SETVER.EXE    .",
	"  .",
	"    .",
	"  .",
	"SETVER.EXE   ",
	"  .",
	"   SETVER    .",
	"      .",
	"SETVER.EXE   "
	"SETVER.EXE   ."
};

char *SuccessMsg 		= "\r\n    .";
char *SuccessMsg2		= "       .";
char *szMiniHelp 		= "         \"SETVER /?\" .";
char *szTableEmpty	= "\r\n    .";

char *Help[] =
{
        "MS-DOS     .\r\n",
        "   :        SETVER [:]",
        " :                    SETVER [:]   n.nn",
        " :                    SETVER [:]   /DELETE [/QUIET]\r\n",
        "  [:]     SETVER.EXE   .",
        "                 .",
        "  n.nn                  MS-DOS  .",
        "  /DELETE  /D          .",
        "  /QUIET                    ",
        "                    .",
	NULL

};
char *Warn[] =
{
   "\n -  MS-DOS     , ",
   "Microsoft   MS-DOS     .  ",
   "    MS-DOS    ",
   "    . ",
   "MS-DOS   MS-DOS     ",
   "   ,      ",
   "    .  , ",
   "   Microsoft  .",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	": SETVER   . SETVER   ",
   "       CONFIG.SYS SETVER.EXE   .",
	NULL
};

#ifdef BILINGUAL
char *ErrorMsg2[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg_2 		= "\r\nVersion table successfully updated";
char *SuccessMsg2_2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp2 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty2	= "\r\nNo entries found in version table";

char *Help2[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn2[] =
{
										/* m100	*/
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg2[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\jpn\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nG[: ",
	"XCb`.",
	"t@C.",
	".",
	"o[W.  2.11 - 9.99 .",
	"o[We[uwGg.",
        "SETVER.EXEt@C.",
	"hCuw.",
	"R}hCp[^.",
	"p[^s.",
	"SETVER.EXEt@C.",
	"o[We[u.",
	"wpX SETVER t@C, o[W.",
	"o[We[uVKGg.",
#ifdef JAPAN
	"SETVER.EXEt@C.",
#else
	"SETVER.EXEt@C."
#endif
	"SETVER.EXE pXw."
};

char *SuccessMsg 		= "\r\no[We[uXV.";
char *SuccessMsg2		= "o[WX, VXeNL.";
char *szMiniHelp 		= "       wv\\, \"SETVER /?\" .";
char *szTableEmpty	= "\r\no[We[u, Gg.";

char *Help[] =
{
        "MS-DOS vOo[W.\r\n",
        "o[We[u\\:   SETVER [:]",
        "Gg:               SETVER [:]  n.nn",
        "Gg:               SETVER [:]  /DELETE [/QUIET]\r\n",
        "  [:]   SETVER.EXE t@Cuw.",
        "           vOt@Cw.",
        "  n.nn           vO MS-DOS o[Ww.",
        "  /DELETE (/D)   wvOo[We[uGg.",
        "  /QUIET         o[We[uGg, \\",
        "                 bZ[W\\.",
	NULL
};
char *Warn[] =
{
										/* m100	*/
   " - MS-DOS o[We[uvOvO",
   "s, Microsoft mF.",
   "wvO o[W MS-DOS s, ",
   "\\tgEFA[J[.",
   "o[W MS-DOS o[We[uXvOs",
   ", f[^, , s.",
   "C, Microsoft .",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
        "",
        ": SETVERfoCXg. SETVER o[WL",
   "       CONFIG.SYS SETVER.EXEfoCXKv.",
        NULL
};

#ifdef BILINGUAL
char *ErrorMsg2[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg_2 		= "\r\nVersion table successfully updated";
char *SuccessMsg2_2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp2 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty2	= "\r\nNo entries found in version table";

char *Help2[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn2[] =
{
										/* m100	*/
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg2[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\hu\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
        "\r\nHIBA: ",
        "rvnytelen kapcsol.",
        "Hibs fjlnv.",
        "Nincs elg memria.",
        "rvnytelen verziszm. A verzinak  2.11 - 9.99 kz kell esnie.",
        "A megadott bejegyzs nem tallhat a verziszm-tblzatban.",
        "A SETVER.EXE fjl nem tallhat.",
        "rvnytelen meghajt.",
        "Tl sok parancssori kapcsol.",
        "Hinyz paramter.",
        "SETVER.EXE fjl olvassa.",
        "A verziszm-tblzat srlt.",
        "A megadott elrsi ton tallt SETVER fjl nem kompatbilis ezzel a programmal.",
        "Nincs tbb hely a verziszm-tblzatban.",
        "SETVER.EXE fjl rsa."
        "A SETVER.EXE programra mutat elrsi t rvnytelen."
};

char *SuccessMsg                = "\r\nA verziszm-tblzat frisstse megtrtnt.";
char *SuccessMsg2               = "A verziszm vltozs a szmtgp jraindtsa utn jut rvnyre.";
char *szMiniHelp                = "       A \"SETVER /?\" parancs megjelenti a program sgjt.";
char *szTableEmpty      = "\r\nA verziszm-tblzat res.";

char *Help[] =
{
        "Belltja, hogy az MS-DOS milyen verziszmot jelezzen a programoknak.\r\n",
        "A jelenlegi verziszm-tblzat listzsa:  SETVER [meghajt:elrsi t]",
        "j bejegyzs:              SETVER [meghajt:elrsi t] fjlnv n.nn",
        "Bejegyzs trlse:         SETVER [meghajt:elrsi t] fjlnv /DELETE [/QUIET]\r\n",
        "  [meghajt:elrsi t] A SETVER.EXE fjl elrsi tja.",
        "  fjlnv               A tblzatba felvenni kvnt program neve.",
        "  n.nn                  A programnak jelzend MS-DOS verziszm.",
        "  /DELETE vagy /D       Trli a megadott program bejegyzst a tblzatbl.",
        "  /QUIET                Nem jelenti meg a bejegyzs trlsekor egybknt ",
        "                        megjelen zenetet.",
        NULL

};
char *Warn[] =
{
   "\nFIGYELMEZTETS - A programot, amelyhez bejegyzst kvn kszteni, a ",
   "Microsoft nem tesztelte az MS-DOS ezen verzijval. Vegye fel a kapcsolatot ",
   "a szoftver ksztjvel s krdezze meg, hogy a program helyesen ",
   "mkdik-e ezzel az MS-DOS verzival. Ha gy hasznlja az alkalmazst, ",
   "hogy nem a valdi MS-DOS verziszmot jelzi neki, akkor ez adatvesztst ",
   "okozhat, illetve a rendszer instabilitshoz vezethet. Ebben az esetben ",
   "a Microsoft nem vllal felelssget a keletkezett krrt.",
   "  ",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
        "",
        "MEGJEGYZS: a SETVER illesztprogram nincs betltve. A verziszm-jelent ",
        "            mkdtetshez a CONFIG.SYS segtsgvel be kell tltenie a",
        "            SETVER.EXE programot.",
        NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\it\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERRORE: ",
	"Opzione non valida.",
	"Nome file non valido.",
	"Memoria insufficiente.",
	"Numero di versione non valido. Il formato deve essere 2.11 - 9.99.",
	"Voce specificata non trovata nella tabella delle versioni.",
	"Impossibile trovare il file SETVER.EXE.",
	"Specificatore di unit non valido.",
	"Troppi parametri nella riga di comando.",
	"Parametro mancante.",
	"Lettura del file SETVER.EXE.",
	"La tabella delle versioni  danneggiata.",
	"Il file SETVER nel percorso specificato non  una versione compatibile.",
	"Spazio per le nuove voci esaurito nella tabella delle versioni.",
	"Scrittura del file SETVER.EXE."
	"Percorso specificato per SETVER.EXE non valido."
};

char *SuccessMsg                = "\r\nTabella delle versioni aggiornata correttamente";
char *SuccessMsg2               = "La modifica delle versioni sar effettiva al riavvio del sistema";
char *szMiniHelp                = "     Usare \"SETVER /?\" per la Guida";
char *szTableEmpty      = "\r\nNessuna voce trovata nella tabella delle versioni";

char *Help[] =
{
	"Imposta la versione che MS-DOS riporta ad un programma.\r\n",
	"Visualizza la tabella corrente: SETVER [unit:perc]",
	"Aggiunge voce:                  SETVER [unit:perc] nomefile n.nn",
	"Elimina voce:                   SETVER [unit:perc] nomefile /DELETE [/QUIET]\r\n",
	"  [unit:perc]    Indica la posizione del file SETVER.EXE.",
	"  nomefile        Indica il nome file del programma.",
	"  n.nn            Indica la versione di MS-DOS da riportare al programma.",
	"  /DELETE or /D   Elimina la voce dalla tabella per il programma specificato.",
	"  /QUIET          Nasconde il messaggio normalmente visualizzato durante",
	"                  l'eliminazione della voce dalla tabella delle versioni.",
	NULL

};
char *Warn[] =
{
   "\nAVVISO - L'applicazione aggiunta alla tabella delle versioni di MS-DOS ",
   "potrebbe non essere verificata da Microsoft con questa versione di MS-DOS. ",
   "Rivolgersi al fornitore del software per assicurarsi che questa applicazione ",
   "funzioni correttamente con questa versione di MS-DOS. Se l'applicazione ",
   "viene eseguita richiedendo a MS-DOS di riportare un numero di versione di ",
   "MS-DOS differente,  possibile perdere o danneggiare dati o causare l' ",
   "instabilit del sistema. In questa circostanza, Microsoft non  responsabile ",
   "per alcun danno o perdita di dati.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
	"",
	"NOTA: periferica SETVER non caricata. Per attivare la modifica delle versioni",
   "      riportate, includere l'istruzione device=SETVER.EXE nel file CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\pl\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
        "\r\nBD: ",
        "Nieprawidowy przecznik.",
        "Nieprawidowa nazwa pliku.",
        "Za mao pamici.",
        "Zy numer wersji, prawidowy format to 2.11 - 9.99.",
        "Podanego wpisu nie mona znale w tabeli wersji.",
        "Nie mona znale pliku SETVER.EXE.",
        "Nieprawidowe okrelenie dysku.",
        "Za wiele parametrw wiersza polecenia.",
        "Brak parametru.",
        "Czytanie pliku SETVER.EXE.",
        "Tabela wersji jest uszkodzona.",
        "Plik SETVER w podanej ciece nie jest plikiem zgodnej wersji.",
        "W tabeli wersji nie ma ju miejsca na nowe wpisy.",
        "Zapisywanie pliku SETVER.EXE."
        "Podano nieprawidow ciek do pliku SETVER.EXE."
};

char *SuccessMsg                = "\r\nTabela wersji zostaa pomylnie zaktualizowana";
char *SuccessMsg2               = "Zmiana wersji zacznie obowizywa od nastpnego uruchomienia systemu";
char *szMiniHelp                = "       Uyj polecenia \"SETVER /?\", aby uzyska pomoc";
char *szTableEmpty      = "\r\nBrak wpisw w tabeli wersji";

char *Help[] =
{
        "Ustawia wersj MS-DOS raportowan przez system.\r\n",
        "Wywietla biec tabel wersji: SETVER [dysk:cieka]",
        "Dodaje wpis:                     SETVER [dysk:cieka] plik n.nn",
        "Usuwa wpis:                      SETVER [dysk:scieka] plik /DELETE [/QUIET]\r\n",
        "  [dysk:cieka]    Okrela lokalizacj pliku SETVER.EXE.",
        "  nazwapliku        Okrela nazw pliku programu.",
        "  n.nn              Okrela wersj MS-DOS, ktra bdzie podawana programowi.",
        "  /DELETE lub /D    Usuwa wpis tabeli wersji dla okrelonego programu.",
        "  /QUIET            Ukrywa komunikat wywietlany zwykle podczas usuwania",
        "                    wpisu tabeli wersji.",
	NULL

};
char *Warn[] =
{
   "\nOSTRZEENIE - Aplikacja dodawana do tabeli wersji systemu Windows moga ",
   "nie zosta sprawdzona przez Microsoft dla tej wersji systemu Windows.  ",
   "Skontaktuj si z producentem w celu uzyskania informacji, czy aplikacja ",
   "bdzie dziaaa poprawnie w tej wersji systemu Windows. Jeli ",
   "uruchomisz t aplikacj, wydajc dla systemu Windows polecenie zgaszania ",
   "innego numeru wersji systemu MS-DOS, moe nastpi utrata lub uszkodzenie ",
   "danych lub wystpi niestabilno systemu. W takich okolicznociach firma",
   "Microsoft nie jest odpowiedzialna za adne straty lub zniszczenia.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
        "UWAGA: Urzdzenie SETVER nie jest zaadowane. Aby uaktywni podawanie wersji",
   "      przez SETVER, naley zaadowa SETVER.EXE w pliku CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\tst\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\usa\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERROR: ",
	"Invalid switch.",
	"Invalid filename.",
	"Insuffient memory.",
	"Invalid version number, format must be 2.11 - 9.99.",
	"Specified entry was not found in the version table.",
	"Could not find the file SETVER.EXE.",
	"Invalid drive specifier.",
	"Too many command line parameters.",
	"Missing parameter.",
	"Reading SETVER.EXE file.",
	"Version table is corrupt.",
	"The SETVER file in the specified path is not a compatible version.",
	"There is no more space in version table new entries.",
	"Writing SETVER.EXE file."
	"An invalid path to SETVER.EXE was specified."
};

char *SuccessMsg 		= "\r\nVersion table successfully updated";
char *SuccessMsg2		= "The version change will take effect the next time you restart your system";
char *szMiniHelp 		= "       Use \"SETVER /?\" for help";
char *szTableEmpty	= "\r\nNo entries found in version table";

char *Help[] =
{
        "Sets the version number that MS-DOS reports to a program.\r\n",
        "Display current version table:  SETVER [drive:path]",
        "Add entry:                      SETVER [drive:path] filename n.nn",
        "Delete entry:                   SETVER [drive:path] filename /DELETE [/QUIET]\r\n",
        "  [drive:path]    Specifies location of the SETVER.EXE file.",
        "  filename        Specifies the filename of the program.",
        "  n.nn            Specifies the MS-DOS version to be reported to the program.",
        "  /DELETE or /D   Deletes the version-table entry for the specified program.",
        "  /QUIET          Hides the message typically displayed during deletion of",
        "                  version-table entry.",
	NULL

};
char *Warn[] =
{
   "\nWARNING - The application you are adding to the MS-DOS version table ",
   "may not have been verified by Microsoft on this version of MS-DOS.  ",
   "Please contact your software vendor for information on whether this ",
   "application will operate properly under this version of MS-DOS.  ",
   "If you execute this application by instructing MS-DOS to report a ",
   "different MS-DOS version number, you may lose or corrupt data, or ",
   "cause system instabilities.  In that circumstance, Microsoft is not ",
   "reponsible for any loss or damage.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTE: SETVER device not loaded. To activate SETVER version reporting",
   "      you must load the SETVER.EXE device in your CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\nl\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nFOUT: ",
	"Ongeldige schakeloptie.",
	"Ongeldige bestandsnaam.",
	"Onvoldoende geheugen.",
	"Ongeldig versienummer, opmaak moet 2.11 - 9.99 zijn.",
	"Opgegeven ingang niet gevonden in de versietabel.",
	"Kan het bestand SETVER.EXE niet vinden.",
	"Ongeldige stationsaanduiding.",
	"Teveel opdrachtparameters.",
	"Parameter ontbreekt.",
	"Bezig met het lezen van bestand SETVER.EXE.",
	"Versietabel is beschadigd.",
	"Het bestand SETVER in het opgegeven pad is geen compatibele versie.",
	"Er is geen ruimte in de versietabel voor nieuwe ingangen.",
	"Bezig met het schrijven van bestand SETVER.EXE."
	"Er is een ongeldig pad voor SETVER.EXE opgegeven."
};

char *SuccessMsg                = "\r\nVersietabel met succes bijgewerkt";
char *SuccessMsg2               = "De versiewijziging treedt in werking als de computer opnieuw wordt gestart.";
char *szMiniHelp                = "       Gebruik \"SETVER /?\" voor help";
char *szTableEmpty      = "\r\nGeen ingangen gevonden in de versietabel";

char *Help[] =
{
	"Stelt het versienummmer in dat MS-DOS opgeeft aan het programma.\r\n",
	"Weergeven huidige versietabel:  SETVER [station:pad]",                          
	"Toevoegen van ingang:           SETVER [station:pad] bestandsnaam n.nn",
	"Verwijderen van ingang:         SETVER [station:pad] bestandsnaam", 
	"                                /DELETE [/QUIET]\r\n",
	"  [station:pad]   De locatie van het bestand SETVER.EXE.",
	"  bestandsnaam    De bestandsnaam van het programma.",
	"  n.nn            De MS-DOS-versie die wordt opgegeven aan het programma.",
	"  /DELETE of /D   De versietabelingang voor het opgegeven", 
	"                  programma wordt verwijderd.",
	"  /QUIET          Het bericht dat verschijnt als een versietabel wordt",
	"                  verwijderd, wordt niet weergegeven.",
	NULL

};
char *Warn[] =
{
   "\nWAARSCHUWING - De toepassing die u toevoegt aan de versietabel van",
   "MS-DOS is misschien niet door Microsoft gecontroleerd voor deze versie",
   "van MS-DOS. Neem contact op met uw leverancier voor informatie over",
   "de mogelijkheid deze toepassing op de juiste wijze uit te voeren onder",
   "deze versie van MS-DOS. Als u deze toepassing uitvoert door MS-DOS",
   "opdracht te geven een ander MS-DOS-versienummer op te geven, kunt u",
   "gegevens verliezen of beschadigen, of het systeem kan instabiel wor-",
   "den. In dat geval is Microsoft niet verantwoordelijk voor eventueel",
   "gegevensverlies.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
	"",
	"NB: SETVER is niet geladen. Om het weergeven van de versie door",
	"    SETVER te activeren, dient u SETVER.EXE op te nemen in CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\share\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\share\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\tr\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nHATA: ",
	"Geersiz anahtar.",
	"Geersiz dosya ad.",
	"Yetersiz bellek.",
	"Geersiz srm numaras, biim 2.11 - 9.99 olmal.",
	"Belirtilen girdi srm tablosunda bulunamad.",
	"SETVER.EXE dosyas bulunamad.",
	"Geersiz src tantcs.",
	"ok fazla komut satr parametresi.",
	"Eksik parametre.",
	"SETVER.EXE dosyas okunuyor.",
	"Srm tablosu bozuk.",
	"Belirtilen yoldaki SETVER dosyas uyumlu bir srm deil.",
	"Yeni girdiler iin srm tablosunda baka yer yok.",
	"SETVER.EXE dosyas yazlyor."
	"SETVER.EXE dosyas iin geersiz bir yol belirtildi."
};

char *SuccessMsg 		= "\r\Srm tablosu baaryla gncelletirildi";
char *SuccessMsg2		= "Srm deiiklii, bilgisayarnz yeniden balattnzda etkili olacaktr";
char *szMiniHelp 		= "       Yardm iin \"SETVER /?\" kullann";
char *szTableEmpty	= "\r\nSrm tablosunda girdi bulunamad ";

char *Help[] =
{
        "MS-DOS''un bir programa bildirdii srm numarasn ayarlar.\r\n",
        "Geerli srm tablosunu gsterir:  SETVER [src:yol]",
        "Girdi ekle:                        SETVER [src:yol] dosyaad n.nn",
        "Girdi sil:                         SETVER [src:yol] dosyaad /DELETE [/QUIET]\r\n",
        "  [src:yol]    SETVER.EXE dosyasnn yerini belirtir.",
        "  dosyaad        Program dosya adn belirtir.",
        "  n.nn            Programa bildirilecek MS-DOS srmn belirtir.",
        "  /DELETE or /D   Belirtilen program iin srm tablosu girdisini siler.",
        "  /QUIET          Normalde srm tablosu girdisini silerken gsterilen",
        "                  iletileri gizler.",
	NULL

};
char *Warn[] =
{
   "\nUYARI - MS-DOS srm tablosuna eklediiniz uygulama ",
   "bu MS-DOS srmnde Microsoft tarafndan onaylanmam olabilir.  ",
   "Bu MS-DOS srmnde bu uygulamann doru alp almayacan renmek ",
   "iin ltfen yazlmnzn satcsyla balant kurun.  ",
   "Bu uygulamay, MS-DOS''un farkl bir MS-DOS srm numaras ",
   "bildirmesini isteyerek altrrsanz, veri kaybedebilir veya bozabilirsiniz ",
   "veya sistem kararszlklarna yol aabilirsiniz. Bu koullarda Microsoft, ",
   "veri kaybndan veya bozulmasndan sorumlu deildir.",
   NULL
};

char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOT: SETVER aygt ykl deil. SETVER srm bildirimini etkinletirmek iin",
   "      SETVER.EXE aygtn CONFIG.SYS dosyanzda yklemelisiniz.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\pt\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*																									*/
/* MESSAGE.H                                						 */
/* 																								*/
/*	Include file for MS-DOS set version program.										*/
/* 																								*/
/*	johnhe	05-01-90																			*/
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\nERRO: ",
	"Parmetro invlido.",
	"Nome de ficheiro invlido.",
	"Memria insuficiente.",
	"N. de verso invlido, formato tem de ser 2.11 - 9.99.",
	"Entrada especificada no encontrada na tabela de verses.",
	"Ficheiro SETVER.EXE no encontrado.",
	"Especificador de unidade invlido.",
	"Demasiados parmetros de linha de comando.",
	"Parmetro em falta.",
	"a ler o ficheiro SETVER.EXE.",
	"Tabela de verses danificada.",
	"O ficheiro SETVER no caminho especificado  de uma verso incompatvel.",
	"No h mais espao para novas entradas na tabela de verses.",
	"a escrever o ficheiro SETVER.EXE."
	"Foi especificado um caminho invlido para SETVER.EXE."
};

char *SuccessMsg 		= "\r\nTabela de verses actualizada com xito";
char *SuccessMsg2		= "A mudana de verso surtir efeito da prxima vez que reiniciar o sistema";
char *szMiniHelp 		= "       Use \"SETVER /?\" para ajuda";
char *szTableEmpty	= "\r\nNenhumas entradas encontradas na tabela de verses";

char *Help[] =
{
        "Define o n. de verso que o MS-DOS devolve a um programa.\r\n",
        "Mostrar a tabela de verses actual:   SETVER [unidade:caminho]",
        "Adicionar entrada:   SETVER [unidade:caminho] NomeFicheiro n.nn",
        "Eliminar entrada:    SETVER [unidade:caminho] NomeFicheiro /DELETE [/QUIET]\r\n",
        "  [unidade:caminho]  Especifica a localizao do ficheiro SETVER.EXE.",
        "  nomedeficheiro     Especifica o nome do ficheiro de programa.",
        "  n.nn               Especifica a verso MS-DOS a ser devolvida ao programa.",
        "  /DELETE ou /D Elimina a entrada na tabela de verses do programa especificado",
        "  /QUIET        Oculta a mensagem geralmente mostrada durante a eliminao da",
        "                entrada na tabela de verses.",
	NULL

};
char *Warn[] =
{
   "\nAVISO - A aplicao que est a adicionar  tabela de verses MS-DOS ",
   "pode no ter sido verificada pela Microsoft nesta verso do MS-DOS.  ",
   "Contacte o seu fornecedor de software para obter informaes ",
   "sobre se esta aplicao executar correctamente nesta verso do MS-DOS.  ",
   "Se executar esta aplicao instrundo o MS-DOS para devolver um n. de ",
   "verso diferente, pode perder ou danificar dados ou causar ",
   "instabilidades de sistema. Nessa circunstncia, a Microsoft no  ",
   "responsvel por quaisquer perdas ou danos.",
   NULL
};


char *szNoLoadMsg[] =						/* M001 */
{
	"",
	"NOTA: O dispositivo SETVER no est carregado. Para activar o relatrio de ",
   "      verses, tem de carregar o dispositivo SETVER.EXE no CONFIG.SYS.",
	NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\sv\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
     "\r\nFEL:   ",
     "Felaktig vxel.",
     "Felaktigt filnamn.",
     "Det finns inte tillrckligt mycket ledigt minne.",
     "Felaktigt versionsnummer. Formatet mste vara mellan 2.11 och 9.99.",
     "Det gick inte att hitta den angivna posten i versionstabellen.",
     "Det gick inte att hitta filen SETVER.EXE.",
     "Felaktig enhetsbokstav.",
     "Fr mnga kommandoradsparametrar.",
     "Parameter saknas.",
     "Lser filen SETVER.EXE.",
     "Versionstabellen r skadad.",
     "Filen SETVER i den angivna skvgen r inte en kompatibel version.",
     "Det finns inte tillrckligt med ledigt utrymme fr nya poster i versionstabellen.",
     "Skriver filen SETVER.EXE."
     "Den angivna skvgen till filen SETVER.EXE r felaktig."
};

char *SuccessMsg                = "\r\nVersionstabellen har uppdaterats";
char *SuccessMsg2               = "Versionsndringen brjar glla nr du startar om datorn";
char *szMiniHelp                = "       Syntax \"SETVER /?\" fr hjlp";
char *szTableEmpty      = "\r\nDet gick inte att hitta ngra poster i versionstabellen";

char *Help[] = 
{
     "Anger vilket versionsnummer MS-DOS ska rapportera till olika program.\r\n",
     "Visa aktuell versionstabell:   SETVER [enhet:skvg]",
     "Lgg till post:                SETVER [enhet:skvg] filnamn n.nn",
     "Ta bort post:                  SETVER [enhet:skvg] filnamn /DELETE [/QUIET]\r\n",
     "  [enhet:skvg]  Anger var filen SETVER.EXE finns.",
     "  filnamn         Anger namnet p programfilen.",
     "  n.nn            Anger vilket versionsnummer MS-DOS ska rapportera till",
     "                  programfilen.",
     "  /DELETE         Tar bort den post i versionstabellen som motsvaras av den",
     "                  angivna programfilen. Du kan ocks skriva /D.",
     "  /QUIET          Meddelandet som vanligen visas nr en post tas bort frn", 
     "                  versionstabellen visas inte.",
     NULL

};
char *Warn[] =
{
   "\nVARNING - Det kan hnda att Microsoft inte har verifierat att ",
   "programmet gr att kra nr du ndrar programmets versionsnummer.  ",
   "Kontakta din terfrsljare fr att ta reda p om detta program ",
   "r kompatibelt med den aktuella versionen av MS-DOS.  ",
   "Om du kr programmet efter att ha ndrat i versionstabellen kan ",
   "du frlora data, frstra data eller gra systemet instabilt. ",
   "Microsoft ansvarar inte fr eventuella frluster eller skador ",
   "av data.",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
     "",
     "OBS! Drivrutinen SETVER har inte lsts in. Om du vill aktivera ",
     "     versionsrapportering mste du lgga till SETVER.EXE i din CONFIG.SYS.",
     NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\share\share.asm ===
; share.asm
;
; Copyright (c) 1991, Microsoft Corporation
;
; History:
;   13-Apr-1992 Sudeep Bharati (sudeepb)
;   Created.
;
;   On NT this utility is just a stub which does nothing.
;

code	segment byte public 'CODE'
	assume	cs:code, ds:code, es:code

	org	100h
public	start
start:
	mov	ah,4ch
	xor	al,al
	int	21h
	ret

code	ends
	end	start
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\ru\message.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***************************************************************************/
/*                                                                                                                                                                                                      */
/* MESSAGE.H                                                                             */
/*                                                                                                                                                                                              */
/*      Include file for MS-DOS set version program.                                                                            */
/*                                                                                                                                                                                              */
/*      johnhe  05-01-90                                                                                                                                                        */
/***************************************************************************/

char *ErrorMsg[]=
{
	"\r\n: ",
	" .",
	"  .",
	" .",
	"  .  : 2.11 - 9.99.",
	"      .",
	"    SETVER.EXE.",
	"  .",
	"    .",
	" .",
	"  SETVER.EXE.",
	"  .",
	"    SETVER,   .",
	"       .",
	"  SETVER.EXE."
	"   SETVER.EXE  ."
};

char *SuccessMsg                = "\r\n   ";
char *SuccessMsg2               = "       .";
char *szMiniHelp                = "          \"SETVER /?\"   ";
char *szTableEmpty      = "\r\n  ";

char *Help[] =
{
	"  ,  MS-DOS  .\r\n",
	"   : SETVER [:]",
	" :               SETVER [:]  n.nn",
	" :                SETVER [:]  /DELETE [/QUIET]\r\n",
	"  [:]        SETVER.EXE.",
	"  filename            .",
	"  n.nn              MS-DOS   .",
	"  /DELETE  /D        .",
	"  /QUIET           ,    ",
	"                    .",
	NULL

};
char *Warn[] =
{
   "\n -     MS-DOS  ",
   "    Microsoft    MS-DOS. ",
   "        ,   ",
   "        MS-DOS. ",
   "     ,  MS-DOS  ",
   "   MS-DOS,       . ",
   "       .    ",
   "Microsoft        .",
   NULL
};

char *szNoLoadMsg[] =                                           /* M001 */
{
   "",
   ":  SETVER  .   SETVER ",
   "                   ", 
   "             SETVER.EXE   CONFIG.SYS.",
   NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\ansi.asm ===
PAGE	,132
TITLE	CONDEV	FANCY CONSOLE DRIVER
;******************************************************************************

;  Change Log:

;    Date    Who   #                      Description
;  --------  ---  ---  ------------------------------------------------------
;  06/01/90  MKS  C02  Bug#173.  ANSI was permitting you to go  one line below
;                      the bottom of the screen.  PROMPT $e[25;3H $e[1B will
;                      show you. (PYS: badly done. M005)
;******************************************************************************

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

;       ADDRESSES FOR I/O

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;------------------------------------------------------------------------------
; New functionality in DOS 4.00
; GHG fix scrolling flashes on Mod 25/30's
; P1767 VIDEO_MODE_TABLE not initialized correctly		10/16/87 J.K.
; D375 /X needs to be supported by ANSI sequence also		12/14/87 J.K.
; D397 /L option for Enforcing number of lines			12/17/87 J.K.
; D479  An option to disable the extended keyboard functions	02/12/88 J.K.
; P4241 AN001 fix be Revised to fix this problem		04/20/88 J.K.
; P4532 Scrolling has a snow for CGA adapter			04/27/88 J.K.
; P4533 In mode Dh, Eh, Fh, 10h and 13h, Scrolling not working	04/27/88 J.K.
; P4766 In mode 11h, and 12h erase display leaves bottom 5	05/24/88 F.G.
;------------------------------------------------------------------------------

INCLUDE	DEVSYM.INC
INCLUDE	ANSI.INC		;equates and structures
INCLUDE	VECTOR.INC

BREAK	<ANSI driver code>

PUBLIC	SWITCH_X		; /X option for extended keyboard redefinition support
PUBLIC	SCAN_LINES
PUBLIC	VIDEO_MODE_TABLE
PUBLIC	VIDEO_TABLE_MAX
PUBLIC	MAX_VIDEO_TAB_NUM	;P1767
PUBLIC	PTRSAV
PUBLIC	ERR1
PUBLIC	ERR2
PUBLIC	EXT_16
PUBLIC	BRKKY
PUBLIC	COUT
PUBLIC	BASE
PUBLIC	MODE
PUBLIC	MAXCOL
PUBLIC	EXIT
PUBLIC	NO_OPERATION
PUBLIC	HDWR_FLAG
PUBLIC	SWITCH_L
PUBLIC	SWITCH_K
PUBLIC	SWITCH_S		; M008 /S for screensize option setting.
PUBLIC	fhavek09		; M006

PUBLIC	CON$READ
PUBLIC	CON$RDND
PUBLIC	CON$FLSH
PUBLIC	CON$WRIT
PUBLIC	VIDEO
PUBLIC	CUU
PUBLIC	CUD
PUBLIC	CUF
PUBLIC	CUB
PUBLIC	CUP
PUBLIC	ED
PUBLIC	CPR
PUBLIC	SM
PUBLIC	RM
PUBLIC	SGR
PUBLIC	DSR
PUBLIC	KEYASN
PUBLIC	EXTKEY
PUBLIC	PSCP
PUBLIC	PRCP

IFDEF	JAPAN
PUBLIC	ROW_ADJ
ENDIF

CODE	SEGMENT PUBLIC BYTE

	ASSUME CS:CODE,DS:NOTHING,ES:NOTHING
;-----------------------------------------------

;	C O N - CONSOLE DEVICE DRIVER


EXTRN	CON$INIT	: NEAR		; ANSI initialization code
EXTRN	GENERIC_IOCTL	: NEAR		; Generic IOCTL code
EXTRN	REQ_TXT_LENGTH	: WORD		; current text length
EXTRN	GRAPHICS_FLAG	: BYTE		; graphics flag

ATTRIB	EQU	CHARDEV+DEVIOCTL+DEV320+ISSPEC+ISCOUT+ISCIN
CONDEV:	SYSDEV	<-1,ATTRIB,STRATEGY,ENTRY,'CON     '>	; Matches CON

;--------------------------------------------------------------

;	COMMAND JUMP TABLES
CONTBL:
	DW	CON$INIT
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	CON$READ
	DW	CON$RDND
	DW	NO_OPERATION
	DW	CON$FLSH
	DW	CON$WRIT
	DW	CON$WRIT
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	NO_OPERATION
	DW	GENERIC_IOCTL		; generic IOCTL routine offset
MAX_CMD	EQU	($ - CONTBL)/2		; size of CONTBL

CMDTABL DB	'A'
	DW	CUU			; cursor up
	DB	'B'
	DW	CUD			; cursor down
	DB	'C'
	DW	CUF			; cursor forward
	DB	'D'
	DW	CUB			; cursor back
	DB	'H'
	DW	CUP			; cursor position
	DB	'J'
	DW	ED			; erase display
	DB	'K'
	DW	EL			; erase line
	DB	'R'
	DW	CPR			; cursor postion report
	DB	'f'
	DW	CUP			; cursor position
	DB	'h'
	DW	SM			; set mode
	DB	'l'
	DW	RM			; reset mode
	DB	'm'
	DW	SGR			; select graphics rendition
	DB	'n'
	DW	DSR			; device status report
	DB	'p'
	DW	KEYASN			; key assignment
	DB	'q'			; dynamic support of /X option through ansi sequence
	DW	EXTKEY			; esc[0q = reset it. esc[1q = set it
	DB	's'
	DW	PSCP			; save cursor postion
	DB	'u'
	DW	PRCP			; restore cursor position
IFDEF	JAPAN
	DB	'M'
	DW	DELETE			; delete line
	DB	'L'
	DW	INSERT			; insert line
ENDIF
	DB	00

GRMODE	DB	00,00000000B,00000111B
	DB	01,11111111B,00001000B
	DB	04,11111000B,00000001B
	DB	05,11111111B,10000000B
	DB	07,11111000B,01110000B
	DB	08,10001000B,00000000B
	DB	30,11111000B,00000000B
	DB	31,11111000B,00000100B
	DB	32,11111000B,00000010B
	DB	33,11111000B,00000110B
	DB	34,11111000B,00000001B
	DB	35,11111000B,00000101B
	DB	36,11111000B,00000011B
	DB	37,11111000B,00000111B
	DB	40,10001111B,00000000B
	DB	41,10001111B,01000000B
	DB	42,10001111B,00100000B
	DB	43,10001111B,01100000B
	DB	44,10001111B,00010000B
	DB	45,10001111B,01010000B
	DB	46,10001111B,00110000B
	DB	47,10001111B,01110000B
	DB	0FFH

;---------------------------------------------------
;	Device entry point


PTRSAV	DD	0

BUF1:	BUF_DATA <>			; Next CON Buffer area

STRATP	PROC	FAR

STRATEGY:
	mov	word ptr cs:[PTRSAV],bx
	mov	word ptr cs:[PTRSAV+2],es
	ret

STRATP	ENDP

ENTRY:
	push	si
	push	ax
	push	cx
	push	dx
	push	di
	push	bp
	push	ds
	push	es
	push	bx

; Check if header link has to be set	(Code ported from
;						DISPLAY.SYS)

	lea	bx,BUF1
	mov	di,OFFSET CONDEV	; CON Device header

	mov	CONPTR.DEV_HDRO,di
	mov	CONPTR.DEV_HDRS,cs
	cld				; all moves forward

	cmp	CONPTR.CON_STRAO, -1
	jne	L4			; has been linked to DOS CON
	cmp	CONPTR.CON_STRAS, -1
	jne	L4			; has been linked to DOS CON
					; next device header :	ES:[DI]
	lds	si,dword ptr CONPTR.DEV_HDRO
	les	di,HP.SDEVNEXT

L1:					; while pointer to next device header
	push	es			; is not -1
	pop	ax
	cmp	ax,-1
	jne	NOT0FFFF		; leave if both offset and segment are
	cmp	di,-1			; 0FFFFH
	je	L4

NOT0FFFF:
	push	di
	push	si
	mov	cx,8
	lea	di,NHD.SDEVNAME
	lea	si,HP.SDEVNAME
	repe	cmpsb
	pop	si
	pop	di
	and	cx,cx
					; Exit if name is found in linked hd.
	jnz	L3			; Name is not found
					; Name is found in the linked header
	mov	ax,NHD.SDEVSTRAT	; Get the STRATEGY address
	mov	CONPTR.CON_STRAO,ax
	mov	ax,es
X1:	mov	CONPTR.CON_STRAS,ax

	mov	ax,NHD.SDEVINT	 	; Get the INTERRUPT address
	mov	CONPTR.CON_INTRO,ax
	mov	ax,es
X2:	mov	CONPTR.CON_INTRS,ax

	jmp	SHORT L4		; Device Name
L3:
	les	di,NHD.SDEVNEXT
	jmp	L1
L4:
	lds	bx,cs:[PTRSAV]		; GET PONTER TO I/O PACKET

	mov	cx,word ptr ds:[bx].COUNT

	mov	al,byte ptr ds:[bx].CMD
	cbw
	mov	si,OFFSET CONTBL
	add	si,ax
	add	si,ax
	cmp	al,MAX_CMD		; not a call for ANSI...chain to lower device
	ja	NO_OPERATION

ifdef   KOREA                                   ; <MSCH>
        mov     ah, byte ptr ds:[bx].media
endif   ; KOREA

	les	di,dword ptr ds:[bx].TRANS

	; Following code, supplied by Compaq, is the "hit-it-on-the-head"
	; approach to solving the problem of resetting the screen length
	; after a character set reload.	We should try to find a better
	; approach.	For now this will stay in. - MGD

	push	ax			; SAVE AX
	mov	ax,40H			; GET ROM VAR
	mov	ds,ax			;

	mov	al,ds:[84h]		; GET MAX NUM OF ROWS
	cmp	al,0			; Q:ZERO
	jne	ENTRY10			; jmp IF NO
	mov	al,24			; SET TO 24 ROWS
ENTRY10:				;
	push	cs
	pop	ds

	ASSUME	ds:CODE

	inc	al			; BUMP FOR ONE BASED
	mov	byte ptr [REQ_TXT_LENGTH],al ; SET LENGTH TO 40:84H VALUE.	*F
	pop	ax			; RESTORE AX

	jmp	word ptr [si]		; GO DO COMMAND

;=====================================================
;=
;=	SUBROUTINES SHARED BY MULTIPLE DEVICES
;=
;=====================================================
;----------------------------------------------------------

;	EXIT - ALL ROUTINES RETURN THROUGH THIS PATH

BUS$EXIT:				; DEVICE BUSY EXIT
	mov	ah,00000011B
	jmp	SHORT ERR1

NO_OPERATION:
	call	PASS_CONTROL		; Pass control to lower CON
	jmp	SHORT ERR2

ERR$EXIT:
	mov	ah,10000001B		; MARK ERROR RETURN
	jmp	SHORT ERR1

EXITP	PROC	FAR

EXIT:	mov	ah,00000001B

ifdef   KOREA
INTERIM$EXIT:                           ; <MSCH>
endif   ; KOREA

ERR1:	lds	bx,cs:[PTRSAV]
	mov	word ptr [bx].STATUS,ax	; MARK OPERATION COMPLETE
ERR2:
	pop	bx
	pop	es
	pop	ds
	pop	bp
	pop	di
	pop	dx
	pop	cx
	pop	ax
	pop	si
	ret				; RESTORE REGS and RETURN
EXITP	ENDP


;	PASS CONTROL

;	This calls the attached device to perform any further
;	action on the call!


PASS_CONTROL	PROC
	lea	si,BUF1
	les	bx,cs:[PTRSAV]			; pass the request header to the
	call	dword ptr cs:[si].CON_STRAO	; CON strategy routine.
	call	dword ptr cs:[si].CON_INTRO	; interrupt the CON
	ret
PASS_CONTROL	ENDP
;-----------------------------------------------

;	BREAK KEY HANDLING

BRKKY:
	mov	byte ptr cs:ALTAH,3	; INDICATE BREAK KEY SET
INTRET: iret


;	WARNING - Variables are very order dependent, be careful
;		 when adding new ones!	- c.p.

WRAP		DB	0		; 0 = WRAP, 1 = NO WRAP
ASNPTR		DW	4
STATE		DW	S1
MODE		DB	3		;*
MAXCOL		DB	79		;*
COL		DB	0
ROW		DB	0
SAVCR		DW	0
INQ		DB	0
PRMCNT		LABEL	BYTE
PRMCNTW 	DW	0
KEYCNT		DB	0
KEYPTR		DW	BUF
REPORT		DB	ESC_CHAR,'[00;00R',CR	;CURSOR POSTION REPORT BUFFER
ALTAH		DB	0			;Special key handling

SAVE_CHAR	DW	0			; Temp storage for char/attr for new scroll code

EXT_16		DB	0		; Extended INT 16h flag
SWITCH_X	DB	OFF		; /X flag
SWITCH_L	DB	OFF		; DCR397; 1= /L flag entered.
SWITCH_K	DB	OFF		; To control EXT_16
fhavek09	DB	OFF		; M006
SCAN_LINES	DB	?		; flag for available scan lines (VGA)
HDWR_FLAG	DW	0		; byte of flags indicating video support
SWITCH_S	DB	OFF		; M008; /S flag

ifdef   KOREA                           ;
REQ_TYPE        DB      0               ;
EXT_REQ_TYPE    DB      0               ;
LEADBYTE        DB      0               ;
TRAILBYTE       DB      0               ;
ECSPRE          DB      0               ;
endif   ; KOREA                         ;

VIDEO_MODE_TABLE	LABEL	BYTE	; table containing applicable
MODE_TABLE	<>			; video modes and corresponding
MODE_TABLE	<>			; data.
MODE_TABLE	<>			; this table is initialized at
MODE_TABLE	<>			; INIT time
MODE_TABLE	<>			
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>
MODE_TABLE	<>

ifdef	KOREA				;  The KOREAN video mode
MODE_TABLE   <>                         ;  have 4 more than standard
MODE_TABLE   <>                         ;  VGA  card
MODE_TABLE   <>                         ;
MODE_TABLE   <>                         ;
endif   ; KOREA                         ;

VIDEO_TABLE_MAX	EQU	$		; maximum address for video table
MAX_VIDEO_TAB_NUM	EQU	($-VIDEO_MODE_TABLE)/TYPE MODE_TABLE ;P1767 Max number of table


IFDEF		DBCS
dbcs_flag	DB	0		; 0=single, 1=lead byte, 2=tail byte
ENDIF
IFDEF		JAPAN
new_mode	DB	0		; mode for '>'
row_adj		DB	0		; for ESC[>1l
ENDIF

;-------------------------------------------------------------

;	CHROUT - WRITE OUT CHAR IN AL USING CURRENT ATTRIBUTE

ATTRW		LABEL	WORD
ATTR		DB	00000111B		; CHARACTER ATTRIBUTE
BPAGE		DB	0			; BASE PAGE
BASE		DW	0b800h
SCREEN_SEG 	DW	00000h

chrout:

ifdef   KOREA                   ; <MSCH>
;
        cmp     [leadbyte],1    ; Is the previous byte a lead byte?  ; KeyW
        jnz     TestDBCSRange   ; No,
        mov     byte ptr [leadbyte],0
        mov     byte ptr [trailbyte],1   ; Mark that this is trail byte of ECS
        jmp     short OUTCHR
;
;
; Note : TestECS routine is hard coded. If you have the different code range,
;        you should change some codes below.
; 1990/11/9 This routine is changed to use IsDBCS routines.
;
TestDBCSRange:
        mov     byte ptr [trailbyte], 0 ; Mark it as a non trail byte
        call    IsDBCSleadbyte
        jnz     realout                 ; Jump if one byte code
;
;       CMP     AL, 0A1H                ;
;       JB      REALOUT                 ;
;       CMP     AL, 0FEH                ;
;       JA      REALOUT                 ;

        mov     byte ptr [leadbyte], 1  ;  it as a lead byte
        mov     ah, [col]               ;
        cmp     ah, [maxcol]            ;
        jnz     outchr                  ;
;                                       ;
; Decide the position to print the Lead byte which is on the column boundary.
;
        cmp     [wrap],0                ;
        jz      skip1                   ;
        dec     [col]                   ;
        cmp     [ecspre],1              ;
        jnz     oneback1                ;
        dec     [col]                   ;
oneback1:                               ;
        call    setit1                  ;
        jmp     short outchr            ;
skip1:                                  ;
        push    ax                      ;
        call    outchr1                 ;
        pop     ax                      ;
        jmp     short outchr            ;
realout:
endif   ; KOREA                         ;

	cmp	al,13
	jnz	trylf
	mov	[COL],0

ifdef	KOREA
	jmp	setit
else
IFDEF	JAPAN
	jmp	setit
ELSE
	jmp	short setit
ENDIF
endif   ; KOREA

trylf:	cmp	al,10
	jz	lf
	cmp	al,7
	jnz	tryback
torom:
	mov	bx,[ATTRW]
	and	bl,7
	mov	ah,14
	int	10h
ret5:	ret

tryback:
	cmp	al,8
	jnz	outchr
	cmp	[COL],0
	jz	ret5
	dec	[COL]
	jmp	short setit

outchr:
	mov	bx,[ATTRW]
	mov	cx,1
	mov	ah,9
	int	10h
	inc	[COL]
	mov	al,[COL]
	cmp	al,[MAXCOL]
	jbe	setit
	cmp	[wrap],0
	jz	outchr1
	dec	[COL]

ifdef   KOREA
;
;       Set boundary position for DBCS code.
;               No lead byte can arrive here.
;
        cmp     [trailbyte],1
        jnz     onebk
        dec     [col]
onebk:
        call    setit1
;
; We don't need ECSPRE change, because we have enough time to deal with it.
; Wait for another character to change ECSPRE.
;
endif	; KOREA

	ret
outchr1:
	mov	[COL],0
lf:	inc	[ROW]
	mov	ah,30			; GHG	Fix for ROUNDUP/PALACE
	mov	al,MODE		 	; GHG	Fix for ROUNDUP/PALACE
	cmp	al,11H			; GHG	Fix for ROUNDUP/PALACE
	je	LF2			; GHG	Fix for ROUNDUP/PALACE
	cmp	al,12H			; GHG	Fix for ROUNDUP/PALACE
	je	LF2			; GHG	Fix for ROUNDUP/PALACE

	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jne	tmplab1
	mov	ah,DEFAULT_LENGTH
	jmp	short tmplab2
tmplab1:
	mov	ah,byte ptr [REQ_TXT_LENGTH]
tmplab2:
LF2:					; GHG	Fix for ROUNDUP/PALACE
IFDEF JAPAN
	sub	ah,row_adj
ENDIF
	cmp	[ROW],AH		; GHG	Fix for ROUNDUP/PALACE
	jb	setit
	dec	ah			; GHG	Fix for ROUNDUP/PALACE
	mov	[ROW],AH		; GHG	Fix for ROUNDUP/PALACE
	call	scroll

setit:

ifdef	   KOREA
preset:
        xor     al, al
        cmp     [trailbyte],al
        jz      noDBCStrail
        inc     al
noDBCStrail:
        mov     [ecspre], al
setit1:
endif   ; KOREA

	mov	dh,row
	mov	dl,col
	mov	bh,[bpage]
	mov	ah,2
	int	10h
	ret

;Writing a LF char through Teletype function to scroll the screen
;has a side effect of changing the color of the cursor when the PROMPT
;setting in PTM P4241 is used. AN001 uses this method to fix the strobing
;problem of the palace machine.	The old method of scrolling used to directly
;write into video buffer.	The old method has been used by AN001 for
;CGA adater of mode 2 or 3 only.
;To solve P4241, but to maintain the fix of the strobing problem of palace
;machine, we return back to the old logic but the old logic has to be
;Revised for the displays above CGA level.	For the adapters above
;CGA display, we don't need to turn off/on the video - this will causes
;a strobing, if you use do this,	for Palace machine.
;This logic will be only applied to mode 2 and 3 only.

; Following code is bug fix supplied by Compaq - MGD
scroll:

ifdef	KOREA				; Responsible for ROM
        mov     al, 10
        jmp     torom
else
IFDEF	JAPAN				; ### if JAPAN ###

	xor	cx,cx
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	scroll10		; if nor graphic
	mov	dh,DEFAULT_LENGTH
	xor	bh,bh
	jmp	short scroll20
scroll10:
	mov	dh,byte ptr [REQ_TXT_LENGTH]
	mov	bh,[ATTR]
scroll20:
	sub	dh,row_adj
	dec	dh
	mov	dl,[MAXCOL]
	mov	ax,0601h		; scroll up
	int	10h
	jmp	short setit

else					; ### if Not JAPAN ###

	mov	al,mode		 	; get display mode
	cmp	al,4			;Q: mode less than 4?
	jc	is_text		 	;Y: perform kludge
	cmp	al,7			;N: Q: monochrome mode?
	je	is_text		 	;   Y: perform kludge
	mov	al,10			; send the line feed to the ROM
	jmp	torom			; exit
is_text:
	mov	ah,8			; read char/attr at cursor pos
	mov	bh,[bpage]
	int	10h
	mov	[save_char],ax		; save char/attribute

	mov	ah,9			; write char at cursor pos
	mov	bx,[ATTRW]		; use current attribute
	mov	cx,1
	int	10h

	mov	al,10			; send the line feed to the ROM
	call	torom
	mov	ah,3			; read cursor pos
	int	10h
	push	dx			; save it
	mov	ah,2			; set cursor position
	dec	dh			; (to row-1)
	int	10h

	mov	ax,[save_char]		; retrieve saved char/attr
	mov	bl,ah
	mov	ah,9			; write it back to the screen
	mov	cx,1
	int	10h

	pop	dx			; retrieve new cursor position
	mov	ah,2			; set cursor position
	int	10h
	ret
ENDIF					; ### end if Not JAPAN ###
endif   ; KOREA


;------------------------------------------------------

;	CONSOLE READ ROUTINE

CON$READ:
	jcxz	CON$EXIT

ifdef   KOREA                           ;
        mov     [req_type], 0           ;
        mov     [ext_req_type], 10h     ;
        test    ah, 00000001b           ;
        jz      con$loop                ;
        mov     [req_type], 0f0h        ; ; Get Interim mode
        mov     [ext_req_type], 0f8h    ;
        cmp     cx, 1                   ;
        jnz     con$ndisp               ;
                                        ;
        call    chrin                   ;
        stosb                           ;
        cmp     ah, 0f0h                ; ; Is this an interim code ?
        jnz     con$exit                ;
        mov     ah, 00000101b           ;
        jmp     interim$exit            ; ; return to DOS with interim flag set
con$ndisp:                              ;
        call    chrin                   ;
        cmp     ah, 0f0h                ; ; Is this an interim code ?
        jz      con$ndisp               ; ; Skip the interims
        stosb                           ;
        LOOP    CON$NDISP               ;
        JMP     EXIT                    ;
endif   ; KOREA


CON$LOOP:
	push	cx			; SAVE COUNT
	call	CHRIN			; GET CHAR IN AL
	pop	cx
	stosb				; STORE CHAR AT ES:DI
	loop	CON$LOOP
CON$EXIT:
	jmp	EXIT
;---------------------------------------------------------

;	INPUT SINGLE CHAR INTO AL

CHRIN:	xor	ax,ax
	xchg	al,ALTAH		; GET CHARACTER & ZERO ALTAH
	or	al,al
	jnz	KEYRET

INAGN:	cmp	KEYCNT,0
	jnz	KEY5A

ifdef   KOREA
        mov     ah, [req_type]
else
	xor	ah,AH
endif   ; KOREA

	cmp	EXT_16,ON		; extended interrupt available?
	jne	tmplab3

ifdef   KOREA
        mov     ah, [ext_req_type]
else
	mov	ah,10h			; yes..perform extended call
endif	; KOREA

	INT	16h

ifdef   KOREA
        cmp     ah, 0f0h
        jz      keyret1                 ; Breief return for the interim code
endif   ; KOREA

	cmp	SWITCH_X,OFF		; /X switch used?
	jne	tmplab5
	call	CHECK_FOR_REMAP 	; no....map to normal call

tmplab5:
	call	SCAN			; check for redefinition
	jz	tmplab4			; no redefinition?....and
	cmp	SWITCH_X,ON		; /X switch used?
	jne	tmplab4
	call	CHECK_FOR_REMAP 	; then remap..
	or	bx,bx			; reset zero flag for jump test in old code

	jmp	short tmplab4

;	extended interrupt not available

tmplab3:
	int	16h

ifdef   KOREA
        cmp     ah, 0f0h
        jz      keyret1
endif   ; KOREA

	call	SCAN			; check for redefinition

tmplab4:
	jnz	ALT10			; IF NO MATCH JUST RETURN IT

	dec	cx
	dec	cx
	inc	bx
	inc	bx
	cmp	al,0			; check whether keypacket is an extended one
	jz	tmplab7
	cmp	al,0e0h
	jnz	tmplab6

ifdef   KOREA
        cmp     ah, 0f0h
        jb      mschtmp2
        cmp     ah, 0f2h
        jbe     tmplab7
mschtmp2:
endif   ; KOREA

	cmp	SWITCH_X,1
	jnz	tmplab6
tmplab7:
	dec	cx			; adjust pointers
	inc	bx			; appropiately
tmplab6:
	mov	KEYCNT,cl
	mov	KEYPTR,bx
KEY5A:					; Jmp here to get rest of translation
	call	KEY5			; GET FIRST KEY FROM TRANSLATION
ALT10:
	or	ax,ax			; Check for non-key after BREAK
	jz	INAGN
	or	al,al			; SPECIAL CASE?
	jnz	KEYRET
	mov	ALTAH,ah		; STORE SPECIAL KEY
KEYRET:

ifdef   KOREA
        mov     ah, 0f1h
keyret1:
endif   ; KOREA

	ret

KEY5:	mov	bx,KEYPTR		; GET A KEY FROM TRANSLATION TABLE
	mov	ax,word ptr [bx]
	dec	KEYCNT
	inc	bx
	or	al,al
	jnz	KEY6
	inc	bx
	dec	KEYCNT
KEY6:	mov	KEYPTR,bx
	ret

SCAN:	mov	bx,OFFSET BUF
KEYLP:	mov	cl,byte ptr [bx]
	xor	ch,ch
	or	cx,cx
	jz	NOTFND
	cmp	al,0			; check whether extended keypacket
	jz	tmplab8
	cmp	al,0e0h			; extended must be enabled with /x
	jnz	tmplab9

ifdef   KOREA                           ; Jump when Hangeul char
        cmp     ah, 0f0h
        jb      mschtmp1
        cmp     ah, 0f2h
        jbe     tmplab9
mschtmp1:
endif   ; KOREA

	cmp	SWITCH_X,ON
	jnz	tmplab9
tmplab8:
	cmp	ax,word ptr [bx+1]	; yes...compare the word
	jmp	short tmplab10
tmplab9:
	cmp	al,byte ptr [bx+1]	; no...compare the byte
tmplab10:
	jz	MATCH
	add	bx,cx
	jmp	KEYLP
NOTFND:	or	bx,bx
MATCH:	ret
;--------------------------------------------------------------

;	KEYBOARD NON DESTRUCTIVE READ, NO WAIT

CON$RDND:
	mov	al,[ALTAH]
	or	al,al

ifdef   KOREA
        jnz     To_RDEXIT
else
	jnz	RDEXIT
endif   ; KOREA

	cmp	[KEYCNT],0
	jz	RD1
	mov	bx,[KEYPTR]
	mov	al,byte ptr [bx]

ifdef   KOREA
to_rdexit:
        jmp     rdexit
else
	jmp	SHORT RDEXIT
endif   ; KOREA

RD1:

ifdef   KOREA
        mov     [req_type], 1
        mov     [ext_req_type], 11H
        test    ah, 00000001b
        jz      rd11
        mov     [req_type], 0f1h
        mov     [ext_req_type], 0f9H
RD11:
        mov     ah, [req_type]
        cmp     ext_16, on
        jnz     tmplab11
        mov     ah, [ext_req_type]
else
        mov     ah,1
	cmp	EXT_16,ON
	jnz	tmplab11
	add	ah,10h			; yes....adjust to extended call
endif	; KOREA

tmplab11:
	int	16h
	jz	CheckForEvent
	or	ax,ax
	jnz	RD2

ifdef   KOREA
        mov     ah, [req_type]
        and     ah, 11111110b
else
        mov     ah,0
endif   ; KOREA

	cmp	EXT_16,ON		; extended interrupt available?
	jne	tmplab12

ifdef   KOREA
        mov     ah, [ext_req_type]
        and     ah, 11111110b
else
	mov	ah,10h			; yes..perform extended call
endif   ; KOREA

	int	16h
	cmp	SWITCH_X,OFF		; /X switch used?
	jnz	tmplab13
	call	CHECK_FOR_REMAP		; no....map to normal call
	jmp	short tmplab13
tmplab12:
	int	16h
tmplab13:
	jmp	CON$RDND

RD2:

ifdef   KOREA
        cmp     ah, 0f0h
        jz      rdexit
endif   ; KOREA

	call	SCAN
	jz	tmplab14		; if no redefinition
	cmp	EXT_16,ON
	jnz	tmplab14		; and extended INT16 used
	cmp	SWITCH_X,ON		; and /x used
	jnz	tmplab14

	call	CHECK_FOR_REMAP		; remap to standard call
	or	bx,bx			; reset zero flag for jump test in old code

tmplab14:
	jnz	RDEXIT

	mov	al,byte ptr [bx+2]
	cmp	byte ptr [bx+1],0
	jnz	RDEXIT
	mov	al,byte ptr [bx+3]
RDEXIT: lds	bx,[PTRSAV]
	mov	[bx].MEDIA,al
EXVEC:	jmp	EXIT

; M006 - begin

CheckForEvent:
	cmp	fhavek09,0
	jz	CONBUS			; return with busy status if not k09

	les	bx,[ptrsav]
	assume	es:nothing
	test	es:[bx].status,0400h	; system wait enabled?
	jz	CONBUS			;  return with busy status if not

;	need to wait for ibm response to request for code
;	on how to use the system wait call.

	mov	ax,4100h		; wait on an external event
	xor	bl,bl			; wait for any event
	int	15h			; call rom for system wait

; M006 - end

CONBUS: jmp	BUS$EXIT
;--------------------------------------------------------------

;	KEYBOARD FLUSH ROUTINE

CON$FLSH:
	mov	[ALTAH],0		; Clear out holding buffer
	mov	[KEYCNT],0

ifdef   KOREA
        mov     ah, 0f3h
        int     16h
 ReadNullByte:                          ; We may have final char
        mov     ah, 0f1h
        int     16h
        jz      FlushDone
        mov     ah, 0f0h
        int     16h
        jmp     short   ReadNullByte
FlushDone:
else
Flush:	mov	ah,1
	cmp	EXT_16,ON		; if extended call available
	jnz	tmplab15
	add	ah,10h			; then use it
tmplab15:

	int	16h
	jz	FlushDone
	mov	ah,0

	cmp	EXT_16,ON		; if extended call available
	jnz	tmplab16
	add	ah,10h			; use it
tmplab16:
	int	16h
	jmp	Flush
FlushDone:
endif   ; KOREA

	jmp	EXVEC
;----------------------------------------------------------

;	CONSOLE WRITE ROUTINE

CON$WRIT:
	jcxz	EXVEC

ifdef   KOREA
        test    ah, 00000001b
        jnz     con$lp_nac      ;OUT CHAR WITHOUT CURSOR ADVANCING
endif   ; KOREA

CON$LP: mov	al,es:[di]		; GET CHAR
	inc	di
	call	OUTC			; OUTPUT CHAR
	loop	CON$LP			; REPEAT UNTIL ALL THROUGH
	jmp	EXVEC

ifdef   KOREA
con$lp_nac:
        mov     al, es:[di]
        inc     di
        call    outchr_nac      ;OUTPUT CHAR WITHOUT CURSOR MOVE
        loop    con$lp_nac      ;REPEAT UNTIL ALL THROUGH
        jmp     exit

outchr_nac:
        push    ax
        push    si
        push    di
        push    bp
        mov     ah, 0feh        ;OUTPUT CHAR WITHOUT CURSOR ADVANCING
        mov     bl, 7           ;SET FOREGROUND COLOR
        int     10h             ;CALL ROM BIOS
        pop     bp
        pop     di
        pop     si
        pop     ax
        ret
endif

COUT:	sti
	push	ds
	push	cs
	pop	ds
	call	OUTC
	pop	ds
	Iret

OUTC:	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	es
	push	bp

	mov	[BASE],0b800h
	xchg	ax,si			; SAVE CHARACTER TO STUFF
	mov	ax,40h			; POINT TO ROS BIOS
	mov	ds,ax
	mov	ax,ds:[49h]		; AL=MODE, AH=MAX COL
	dec	ah			; ANSI NEEDS 0-79 OR 0-39
	mov	word ptr cs:[MODE],ax	; SAVE MODE and MAX COL
	cmp	al,7
	jnz	NOT_BW
	mov	word ptr cs:[BASE],0B000H
NOT_BW: mov	al,ds:[62H]		; GET ACTIVE PAGE
	mov	cs:[BPAGE],al
	cbw
	add	ax,ax
	mov	bx,ax
	mov	ax,ds:[bx+50H]		; AL=COL, AH=ROW
	mov	word ptr cs:[COL],ax	; SAVE ROW and COLUMN
	mov	ax,ds:[4EH]		; GET START OF SCREEN SEG
	mov	cl,4
	shr	ax,cl			; CONVERT TO A SEGMENT
	push	cs
	pop	ds
	mov	[SCREEN_SEG],ax
	xchg	ax,si			; GET BACK CHARACTER IN AL

	call	VIDEO
	pop	bp
	pop	es
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret


;----------------------------------------------------------

;	OUTPUT SINGLE CHAR IN AL TO VIDEO DEVICE

VIDEO:	mov	si,OFFSET STATE
	jmp	[si]

S2:	cmp	al,'['
	jz	S22

ifdef   KOREA
        cmp     al, '$'
        jnz     chk_off
        mov     word ptr [si], offset S8
        ret
chk_off:
        cmp     al, '('
        jnz     jmp_S1
        mov     word ptr [si], offset S10
        ret
jmp_S1:
endif   ; KOREA

	jmp	S1
S22:	mov	word ptr [si],OFFSET S3
	xor	bx,bx
	mov	word ptr INQ,bx
	jmp	SHORT S3B

S3:	cmp	al,';'
	jnz	S3C
S3A:	inc	PRMCNT
S3B:	call	GETPTR
	xor	ax,ax
	mov	word ptr [bx],ax	; DEFAULT VALUE IS ZERO
	ret

S3C:	cmp	al,'0'
	jb	S3D
	cmp	al,'9'
	ja	S3D
	call	GETPTR
	sub	al,'0'
	xchg	al,byte ptr [bx]
	mov	ah,10
	mul	ah			; *10
	add	byte ptr [bx],al	; movE IN DIGIT
	ret

S3D:	cmp	al,'='
	jz	S3ret
	cmp	al,'?'
	jz	S3ret
IFDEF JAPAN
	cmp	al,'>'
	jz	s3f
ENDIF
	cmp	al,'"'			; BEGIN QUOTED STRING
	jz	S3E
	cmp	al,"'"
	jnz	S7
S3E:	mov	word ptr [si],OFFSET S4
	mov	[INQ],al
S3ret:	ret

IFDEF JAPAN
s3f:
	mov	new_mode,1
	jmp	short s3ret
ENDIF


;	ENTER QUOTED STRINGS


S4:	cmp	al,[INQ]		; CHECK FOR STRING TERMINATOR
	jnz	S4A
	dec	PRMCNT			; TERMINATE STRING
	mov	word ptr [si],OFFSET S3
	ret

S4A:	call	GETPTR
	mov	byte ptr [bx],al
	mov	word ptr [si],OFFSET S4
	jmp	S3A

;	LOOK FOR ANSI COMMAND SPECIFIED IN AL


	PUBLIC	S7
S7:	mov	bx,OFFSET CMDTABL-3

S7A:	add	bx,3
	cmp	byte ptr [bx],0
	jz	S1B
	cmp	byte ptr [bx],al
	jnz	S7A

S7B:	mov	ax,word ptr [bx+1]	; AX = JUMP addRESS
	mov	bx,OFFSET BUF
	inc	bx
	add	bx,ASNPTR		; BX = PTR TO PARM LIST
	mov	DL,byte ptr [bx]
	xor	DH,DH			; DX = FIRST PARAMETER
	mov	cx,dx
	or	cx,cx
	jnz	S7C
	inc	cx			; CX = DX, CX=1 IF DX=0
S7C:	jmp	ax			; AL = COMMAND

S1:	cmp	al,ESC_CHAR		; ESCAPE SEQUENCE?
	jnz	S1B
IFDEF	DBCS
	mov	dbcs_flag,0
ENDIF
IFDEF	JAPAN
	mov	new_mode,0
ENDIF
	mov	word ptr [si],OFFSET S2
	ret

S1B:

ifndef  KOREA                           ; IN KOREA, WE ALREADY handled
IFDEF DBCS
	cmp	dbcs_flag,1
	jz	set_dbcs		; if it was lead byte
	cmp	dbcs_flag,2
	jnz	@f			; if it was not tail byte
	mov	dbcs_flag,0		; reset
@@:
	call	IsDBCSLeadByte
	jnz	@f			; if this is not lead byte
set_dbcs:
	inc	dbcs_flag
@@:
	cmp	dbcs_flag,1
	jnz	@f
	mov	dl,col
	cmp	dl,maxcol
	jnz	@f
	push	ax
	mov	al,' '
	call	chrout
	pop	ax
@@:
ENDIF
endif   ; NOT KOREA

	call	CHROUT
S1A:	mov	word ptr [STATE],OFFSET S1
	ret

ifdef   KOREA
S8:     cmp     al, ')'
        jnz     s1
        mov     word ptr [si], offset S9
        ret
S9:     cmp     al, '1'
        jnz     S1
han_on:
        mov     ah, 0f2h
        mov     al, 08h                 ; Hangeul input mode on
        int     16h
        ret

S10:    cmp     al, '2'
        jnz     S1
han_off:
        mov     ah, 0f2h
        mov     al, 00h
        int     16h
        ret
endif   ; KOREA

MOVCUR:					;C02
	cmp	byte ptr [bx],AH
	jz	SETCUR
	add	byte ptr [bx],al
	loop	MOVCUR
SETCUR: mov	dx,word ptr COL
;*C05	xor	bx,bx
	mov	ah,0fh			;*C05
	int	10h			;*C05
	mov	ah,2
	int	16
	jmp	S1A

CUP:
					
IFDEF	JAPAN				; ### if JAPAN ###
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	tmplab17		; if not graphic mode
	mov	ah,DEFAULT_LENGTH
	jmp	short tmplab18
tmplab17:
	mov	ah,byte ptr [REQ_TXT_LENGTH]
tmplab18:
	sub	ah,row_adj
	cmp	cl,ah
ELSE
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	tmplab17
	cmp	cl,DEFAULT_LENGTH
	jmp	short tmplab18
tmplab17:
	cmp	cl,byte ptr [REQ_TXT_LENGTH]
tmplab18:
ENDIF					; ### end if JAPAN ###

	ja	SETCUR
	mov	al,MAXCOL
	mov	ch,byte ptr [bx+1]
	or	ch,CH
	jz	CUP1
	dec	CH
CUP1:	cmp	al,CH
	ja	CUP2
	mov	ch,al
CUP2:	xchg	cl,CH
	dec	CH
	mov	word ptr COL,cx
	jmp	SETCUR

CUF:	mov	ah,MAXCOL
	mov	al,1
CUF1:	mov	bx,OFFSET COL
	jmp	MOVCUR

CUB:	mov	ax,00FFH
	jmp	CUF1

CUU:	mov	ax,00FFH
CUU1:	mov	bx,OFFSET ROW
	jmp	MOVCUR

CUD:
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	tmplab19
	mov	ah,DEFAULT_LENGTH
	jmp	short tmplab20
tmplab19:
	mov	ah,byte ptr [REQ_TXT_LENGTH]
	dec	ah			; M005; REQ_TXT_LENGTH is not 0 based
tmplab20:
IFDEF JAPAN
	sub	ah,row_adj
ENDIF
	mov	al,1
	jmp	CUU1

ExtKey:
	cmp	dl, 0			; DL = previous parameter
	jne	ExtKey_1
	mov	Switch_X, OFF		; reset it if 0.
	jmp	S1A
ExtKey_1:
	cmp	dl, 1			; 1 ?
	je	SetExtKey
	jmp	S1A			; ignore it
SetExtKey:
	mov	Switch_X, ON		; set it if 1.
	jmp	S1A

PSCP:	mov	ax,word ptr COL
	mov	SAVCR,ax
	jmp	SETCUR

PRCP:	mov	ax,SAVCR
	mov	word ptr COL,ax
	jmp	SETCUR

SGR:	xor	cx,cx
	xchg	cl,PRMCNT
	call	GETPTR
	inc	cx
SGR1:	mov	al,byte ptr [bx]
	push	bx
	mov	bx,OFFSET GRMODE
SGR2:	mov	ah,byte ptr [bx]
	add	bx,3
	cmp	ah,0FFH
	jz	SGR3
	cmp	ah,al
	jnz	SGR2
	mov	ax,word ptr [bx-2]
	and	ATTR,al
	or	ATTR,AH
SGR3:	pop	bx
	inc	bx
	loop	SGR1
	jmp	SETCUR

IFDEF JAPAN				; ### if JAPAN ###
ED:
	mov	bl,dl			; save function no.
	mov	dh,30
	mov	al,MODE
	cmp	al,11h
	je	ed20			; if graphic 640X480
	cmp	al,12h
	je	ed20			; if graphic 640X480
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	ed10			; if not graphic mode
	mov	dh,DEFAULT_LENGTH
	jmp	short ed20
ed10:
	mov	dh,byte ptr [REQ_TXT_LENGTH]
ed20:
	sub	dh,row_adj
	dec	dh			; last row
	mov	dl,MAXCOL
	xor	cx,cx
	cmp	bl,0
	jz	ed_func0
	cmp	bl,1
	jz	ed_func1
	mov	word ptr COL,cx		; ESC[2J
	jmp	short ed_30
ed_func0:				; ESC[0J
	push	dx
	mov	cx,word ptr COL
	mov	dh,ch
	mov	dl,MAXCOL
	call	erase			; erase to eol
	pop	dx
	mov	ch,ROW
	cmp	ch,dh
	jz	ed_end			; if at bottom
	inc	ch
	mov	cl,0
	jmp	short ed_30
ed_func1:				; ESC[1J
	mov	dx,word ptr COL
	mov	ch,dh
	mov	cl,0
	call	erase			; erase from top
	mov	dh,ROW
	cmp	dh,0
	jz	ed_end
	dec	dh
	mov	dl,MAXCOL
	xor	cx,cx
ed_30:
	call	erase
ed_end:
	jmp	setcur

EL:
	cmp	dl,1
	jz	el_func1
	cmp	dl,2
	jz	el_func2
	mov	cx,word ptr COL		; ESC[0K
	mov	dh,ch
	mov	dl,MAXCOL
	jmp	short el_10
el_func1:
	mov	dx,word ptr COL		; ESC[1K
	mov	ch,dh
	mov	cl,0
	jmp	short el_10
el_func2:
	mov	ch,ROW			; ESC[2K
	mov	dh,ch
	mov	cl,0
	mov	dl,MAXCOL
el_10:
	call	erase
	jmp	setcur

erase:
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE	; if we are in graphics mode,
	jnz	erase10
	xor	bh,bh			; then use 0 as attribute
	jmp	short erase20
erase10:
	mov	bh,ATTR			; else use ATTR
erase20:
	mov	ax,0600H		; clear
	int	10h
	ret

else					; ### if Not JAPAN ###

ED:	xor	cx,cx
	mov	word ptr COL,cx
	mov	DH,30
	mov	al,MODE
	cmp	al,11H
	je	ERASE
	cmp	al,12H
	je	ERASE

	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	tmplab21
	mov	dh,DEFAULT_LENGTH
	jmp	short tmplab22
tmplab21:
	mov	dh,byte ptr [REQ_TXT_LENGTH]
tmplab22:
ERASE:	mov	DL,MAXCOL

	cmp	GRAPHICS_FLAG,GRAPHICS_MODE	; if we are in graphics mode,
	jnz	tmplab23
	xor	bh,bh			;	then use 0 as attribute
	jmp	short tmplab24
tmplab23:
	mov	bh,ATTR			;	else use ATTR
tmplab24:
	mov	ax,0600H
	int	16
ED3:	jmp	SETCUR

EL:	mov	cx,word ptr COL
	mov	DH,CH
	jmp	ERASE

ENDIF					; ### end if Not JAPAN ###

IFDEF JAPAN				; ### if JAPAN ###
delete:
	mov	ah,6			; scroll up
	jmp	short insdel
insert:
	mov	ah,7			; scroll down
insdel:
	mov	al,cl			; set scroll number
	mov	COL,0			; set to top of row
	mov	cx,word ptr COL
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	line10			; if not graphic mode
	mov	dh,DEFAULT_LENGTH
	xor	bh,bh			; attribute
	jmp	short line20
line10:
	mov	bh,ATTR
	mov	dh,byte ptr [REQ_TXT_LENGTH]
line20:
	sub	dh,row_adj
	dec	dh
	mov	dl,MAXCOL
	int	10h			; scroll
	jmp	setcur
ENDIF					; ### end if JAPAN ###

BIN2ASC:mov	DL,10
	inc	AL
	xor	ah,AH
	div	dl
	add	ax,'00'
	ret
DSR:	mov	ah,REQ_CRSR_POS
	push	bx
	xor	bh,bh
	int	10h
	pop	bx
	push	dx
	mov	al,dh			;REPORT CURRENT CURSOR POSITION
	call	BIN2ASC
	mov	word ptr REPORT+2,ax
	pop	dx
	mov	al,DL
	call	BIN2ASC
	mov	word ptr REPORT+5,ax
	mov	[KEYCNT],9
	mov	[KEYPTR],OFFSET REPORT
CPR:	jmp	S1A

RM:	mov	cl,1
	jmp	SHORT SM1

SM:	xor	cx,cx
SM1:	mov	al,DL

IFDEF JAPAN
	cmp	new_mode,1
	jz	nmode
ENDIF

	cmp	al,MODE7		;	if mode isn't (0-6, 13-19)
	jl	tmplab25		;	then skip	(cas -- signed?)
	cmp	al,MODE13
	jl	tmplab26
	cmp	al,MODE19
	jg	tmplab26

tmplab25:
	test	HDWR_FLAG,LCD_ACTIVE	; is this the LCD?
	jz	tmplab25a		; skip if not

	push	ds			; WGR yes...
	push	ax			; WGR save mode
	mov	ax,ROM_BIOS
	mov	ds,ax			; WGR get equipment status flag..
	mov	ax,DS:[EQUIP_FLAG]
	and	ax,INIT_VID_MASK	; WGR clear initial video bits..
	or	ax,LCD_COLOR_MODE	; WGR .....set bits as color
	mov	ds:[EQUIP_FLAG],ax 	; WGR replace updated flag.
	pop	ax			; WGR restore mode.
	pop	ds

tmplab25a:

	mov	ah,SET_MODE		; WGR yes....set mode..
	int	10H
	jmp	short tmplab27

tmplab26:
	cmp	al,7			; then if 7, wrap at EOL
	jnz	tmplab27
	mov	[WRAP],CL		; WGR yes....wrap...
tmplab27:
	jmp	CPR

IFDEF JAPAN				; ### if JAPAN ###
nmode:
	mov	new_mode,0
	cmp	al,1
	jz	row_mode		; set row mode
	cmp	al,5
	jz	cur_mode		; set cursor mode
	jmp	cpr
row_mode:
	mov	row_adj,0
	jcxz	row_mode_ret		; if set mode
	cmp	GRAPHICS_FLAG,GRAPHICS_MODE
	jnz	row_mode10		; if not graphic mode
	mov	ah,DEFAULT_LENGTH
	jmp	short row_mode20
row_mode10:
	mov	ah,byte ptr [REQ_TXT_LENGTH]
row_mode20:
	dec	ah
	cmp	row,ah
	jb	row_mode_30		; if cursor not at bottom row
	dec	row
	call	scroll
row_mode_30:
	inc	row_adj
row_mode_ret:
	jmp	cpr
cur_mode:
	push	cx
	mov	ah,3			; get cursor
	mov	bh,bpage
	int	10h
	pop	ax
	or	ax,ax
	jz	cur_mode10		; if for cursor off
	and	ch,11011111b		; cursor on
	jmp	short cur_mode20
cur_mode10:
	or	ch,00100000b		; corsor off
cur_mode20:
	mov	ah,1			; set cursor
	int	10h
	jmp	cpr
ENDIF					; ### end if JAPAN ###

KEYASN: xor	dx,dx
	xchg	DL,PRMCNT		;GET CHARACTER COUNT
	inc	dx
	inc	dx

	call	GETPTR
	mov	ax,word ptr [bx]	;GET CHARACTER TO BE ASSIGNED
	call	SCAN			;LOOK IT UP
	jnz	KEYAS1

	mov	di,bx			;DELETE OLD DEFINITION
	sub	ASNPTR,cx
	mov	KEYCNT,0		; This delete code shuffles the
					; key definition table all around.
					; This will cause all sorts of trouble
					; if we are in the middle of expanding
					; one of the definitions being shuffled.
					; So shut off the expansion.
	mov	si,di
	add	si,cx
	mov	cx,OFFSET BUF+ASNMAX
	sub	cx,si
	cld
	push	es			; SAVE USER'S ES
	push	CS
	pop	es			; SET UP ES addRESSABILITY
	rep	movsb
	pop	es			; RESTORE ES

KEYAS1: call	GETPTR
	cmp	DL,3
	jb	KEYAS3
	mov	byte ptr [bx-1],DL	; SET LENGTH
	add	ASNPTR,dx		; REMEMBER END OF LIST
	add	bx,dx
	cmp	ASNPTR,ASNMAX		; Too much???
	jb	KEYAS3			; No
	sub	bx,dx			; Next three instructions undo the above
	sub	ASNPTR,dx
KEYAS3: mov	byte ptr [bx-1],00
	mov	STATE,OFFSET S1		; RETURN
	ret

GETPTR: mov	bx,ASNPTR
	inc	bx
	add	bx,PRMCNTW
	cmp	bx,ASNMAX + 8
	jb	GET1
	dec	PRMCNT
	jmp	GETPTR
GET1:	add	bx,OFFSET BUF
	ret




; CHECK_FOR_REMAP:

; This function esnures that the keypacket
; passed to it in AX is mapped to a standard INT16h call



CHECK_FOR_REMAP PROC NEAR
	cmp	al,0e0h			; extended key?
	jnz	tmplab28

ifdef   KOREA
        cmp     ah, 0f0h
        jb      mschtmp
        cmp     ah, 0f2h
        jbe     tmplab28
mschtmp:
endif   ; KOREA

	or	ah,ah			; probably, but check for alpha character
	jz	tmplab28
	xor	al,al			; if not an alpha, map extended to standard
tmplab28:
	ret
CHECK_FOR_REMAP ENDP

IFDEF DBCS

;	Test if the character is DBCS Lead Byte

;	input:	AL = character to check
;	outpit:	ZF = 1 if DBCS Lead Byte

	public	DBCSLeadByteTable
DBCSLeadByteTable	dd	0

IsDBCSLeadByte		proc	near
	push	ax
	push	si
	push	ds
	lds	si,cs:DBCSLeadByteTable
idlb_check:
	cmp	word ptr [si],0
	jz	idlb_not		; if end of table
	cmp	al,[si]
	jb	idlb_next		; if below low value
	cmp	al,[si+1]
	jbe	idlb_yes		; if below high value
idlb_next:
	add	si,2			; do next
	jmp	short idlb_check
idlb_not:
	or	al,1			; reset ZF
	jmp	short idlb_end
idlb_yes:
	and	al,0			; set ZF
idlb_end:
	pop	ds
	pop	si
	pop	ax
	ret
IsDBCSLeadByte		endp
ENDIF


BUF	DB	4,00,72H,16,0
	DB	ASNMAX+8-5 DUP (?)

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\ansiinit.asm ===
PAGE	,132
TITLE	ANSI Console device CON$INIT routine

;******************************************************************************

;  Change Log:

;    Date    Who   #			  Description
;  --------  ---  ---  ------------------------------------------------------
;  06/05/90  MKS  C03  Bug#234.  ANSI was not recognizing the presence of a
;		       VGA if there was another video board in the system.
;******************************************************************************



;  MODULE_NAME: CON$INIT

;  FUNCTION:
;    THIS PROCEDURE PERFORMS ALL NECESSARY INITIALIZATION ROUTINES
;  FOR ANSI.SYS.

;  THIS ROUTINE WAS SPLIT FROM THE ORIGINAL ANSI.ASM SOURCE FILE
;  FOR RELEASE 4.00 OF DOS.  ALL CHANGED LINES HAVE BEEN MARKED WITH
; . NEW PROCS HAVE BEEN MARKED AS SUCH.


; P1767 VIDEO_MODE_TABLE not initialized correctly	   10/16/87 J.K.
; P2617 Order dependecy problem with Display.sys		   11/23/87 J.K.
; D479  An option to disable the extended keyboard functions 02/12/88 J.K.
; D493 New INIT request structure for error message	   02/25/88 J.K.
; P5699 Moving selecting alternate print screen routine to only when it
; 10/26/88    is needed.  OEM EGA cards don't support the call it, so they
; K. Sayers   couldn't (shift) print screen at all.
;-------------------------------------------------------------------------------

INCLUDE	ANSI.INC			; equates and strucs

PUBLIC	CON$INIT		


CODE	SEGMENT	PUBLIC	BYTE
	ASSUME	CS:CODE,DS:CODE

EXTRN	VIDEO_MODE_TABLE:BYTE
EXTRN	FUNC_INFO:BYTE
EXTRN	HDWR_FLAG:WORD
EXTRN	VIDEO_TABLE_MAX:ABS
EXTRN	SCAN_LINES:BYTE
EXTRN	PTRSAV:DWORD
EXTRN	PARSE_PARM:NEAR
EXTRN	ERR2:NEAR
EXTRN	EXT_16:BYTE
EXTRN	BRKKY:NEAR
EXTRN	COUT:NEAR
EXTRN	BASE:WORD
EXTRN	MODE:BYTE
EXTRN	MAXCOL:BYTE
EXTRN	EXIT:NEAR
EXTRN	MAX_SCANS:BYTE
EXTRN	ROM_INT10:WORD
EXTRN	INT10_COM:NEAR
EXTRN	ROM_INT2F:WORD
EXTRN	INT2F_COM:NEAR
EXTRN	ABORT:BYTE
EXTRN	Display_Loaded_Before_me:byte	;Defined in IOCTL.ASM
EXTRN	Switch_K:Byte
EXTRN	fhavek09:BYTE			; M006
EXTRN	Switch_S:BYTE			; M008

ifdef	DBCS
EXTRN	DBCSLeadByteTable:dword
endif


INCLUDE	ANSIVID.INC			; video tables data

CON$INIT:
	lds	bx,cs:[PTRSAV]		; establish addressability to request header	
	lds	si,[BX].ARG_PTR		; ds:SI now points to rest of DEVICE=statement
	call	PARSE_PARM		; parse DEVICE= command line
	jnc	CONT_INIT		; no error in parse...continue install
	lds	bx,cs:[PTRSAV]		; prepare to abort install			 
	xor	ax,ax			;						 
	mov	[BX].NUM_UNITS,al	; set number of units to zero		 
	mov	[BX].END_ADDRESS_O,ax	; set ending address offset to 0		 
	mov	[BX].END_ADDRESS_S,cs	; set ending address segment to CS		 
	mov	word ptr [bx].CONFIG_ERRMSG, -1 ; Let IBMBIO display "Error in CONFIG.SYS..".
	mov	ax,UNKNOWN_CMD		; set error in status			 
	mov	WORD PTR [BX].STATUS,ax ; set error status				 
	jmp	ERR2			; prepare to exit

CONT_INIT:			
	push	cs		
	pop	ds			; restore DS to ANSI segment
	mov	ax,ROM_BIOS	
	mov	es,ax			; ES now points to BIOS data area

	cmp	Switch_S,OFF		; M008
	jz	noscreensizesw		; M008

	mov	BYTE PTR es:[84h],24	; M008 ; Use default value

noscreensizesw:				; M008

	mov	ah,es:[KBD_FLAG_3]	; load AH with KBD_FLAG_3

	test	ah,EXT16_FLAG		; if extended Int16 available
	jz	tlab01
	cmp	Switch_K,OFF		; and user didn't disable it
	jnz	tlab01

	mov	EXT_16,ON		; then enable extended int16
tlab01:
	call	DET_HDWR		; procedure to determine video hardware status
	call	LOAD_INT10		; load interrupt 10h handler
	call	LOAD_INT2F		; load interrupt 2Fh handler

; M006 - begin
	push	ds
	pop	es
	xor	di,di			; es:di points to begining of driver

	mov	ax,4101h		; wait for bh=es:[di]
	mov	bl,1			; wait for 1 clock tick
	mov	bh,byte ptr es:[di]
	stc				; Assume we will fail
	int	15h
	jc	CheckColor
	mov	fhavek09,ON		; remember we have a k09 type
CheckColor:
; M006 - end

	int	11h
	and	al,00110000b
	cmp	al,00110000b
	jnz	iscolor
	mov	[base],0b000h		;look for bw card
iscolor:
	cmp	al,00010000b		;look for 40 col mode
	ja	setbrk
	mov	[mode],0
	mov	[maxcol],39

setbrk:
	xor	bx,bx
	mov	ds,bx
	mov	bx,BRKADR
	mov	WORD PTR [BX],OFFSET BRKKY
	mov	WORD PTR [BX+2],cs

	mov	bx,29H*4
	mov	WORD PTR [BX],OFFSET COUT
	mov	WORD PTR [BX+2],cs

ifdef DBCS
	mov	ax,6300h
	int	21h			; get DBCS lead byte table
	mov	word ptr cs:DBCSLeadByteTable,si
	mov	word ptr cs:DBCSLeadByteTable+2,ds
endif

	lds	bx,cs:[PTRSAV]
	mov	WORD PTR [BX].TRANS,OFFSET CON$INIT	;SET BREAK ADDRESS
	mov	[BX].TRANS+2,cs
	jmp	EXIT




;	PROCEDURE_NAME: DET_HDWR

;	FUNCTION:
;	THIS CODE DETERMINES WHAT VIDEO HARDWARE IS AVAILABLE.	THIS INFORMATION
;	IS USED TO LOAD APPROPRIATE VIDEO TABLES INTO MEMORY FOR USE IN THE
;	GENERIC IOCTL.

;	AT ENTRY:

;	AT EXIT:
;	NORMAL: FLAG WORD WILL CONTAIN BITS SET FOR THE APPROPRIATE
;		TABLES. IN ADDITION, FOR VGA SUPPORT, A FLAG BYTE
;		WILL CONTAIN THE AVAILABLE SCAN LINE SETTINGS FOR THE
;		INSTALLED ADAPTER.
;		VIDEO TABLES WILL BE LOADED INTO MEMORY REFLECTING
;		APPLICABLE MODE SETTINGS AND SCREEN LINE LENGTHS.

;	ERROR:	N/A



DET_HDWR	PROC	NEAR
	mov	ah,GET_SYS_ID		; see if this is a Convertible
	int	15h

	cmp	es:[BX].MODEL_BYTE,LCD_MODEL	; and it has an LCD attached
	jnz	tlab04

	mov	ah,GET_STATUS		; system status will tell us
	int	15h

	test	al,1			; if bit 0 = 0 then LCD..
	jnz	tlab04

	or	HDWR_FLAG,LCD_ACTIVE	; so ...set hdwr flag and...
	lea	si,COLOR_TABLE
	mov	cx,COLOR_NUM		; load color table (for LCD)
	call	LOAD_TABLE
	lea	si,MONO_TABLE		; and mono table
	mov	cx,MONO_NUM
	call	LOAD_TABLE
	jmp	short tlab05

;	not LCD... check for CGA and mono

tlab04:
	mov	ax,MONO_ADDRESS		; write to mono buffer to see if present
	call	CHECK_BUF

	cmp	ah,al
	jnz	tlab03			; if present then,

	or	HDWR_FLAG,MONO_ACTIVE	; set hdwr flag and..
	lea	si,MONO_TABLE
	mov	cx,MONO_NUM		; load mono table
	call	LOAD_TABLE

tlab03:

	mov	ax,COLOR_ADDRESS	; write to CGA buffer to see if present
	call	CHECK_BUF
	cmp	ah,al
	jnz	tlab02			; if present then,

	or	HDWR_FLAG,CGA_ACTIVE	; set hdwr flag and...
	lea	si,COLOR_TABLE
	mov	cx,COLOR_NUM		; load color table
	call	LOAD_TABLE

tlab02:

tlab05:
	push	cs			; setup addressiblity for
	pop	es			;	functionality call

	xor	ax,ax
	mov	ah,FUNC_call		; functionality call
	xor	bx,bx 			; implementation type 0
	lea	DI,FUNC_INFO		; block to hold data
	int	10H

	cmp	al,FUNC_call		; if call supported, then...
	jne	tlab11

	mov	ax,1A00h		; alternate check for VGA	;C03
	int	10h			; C03

	cmp	bl,8			; test for color VGA or mono VGA
	jz	tlab08
	cmp	bl,7
	jnz	tlab09
tlab08:

	or	HDWR_FLAG,VGA_ACTIVE	; yes ....so
	lea	si,COLOR_TABLE		; set hdwr flag and...
	mov	cx,COLOR_NUM		; load color table +..
	call	LOAD_TABLE
	lea	si,VGA_TABLE		; load VGA table
	mov	cx,VGA_NUM
	call	LOAD_TABLE

	jmp	short tlab07

;	not VGA, must be MCGA

tlab09:
	cmp	[DI].ACTIVE_DISPLAY,MOD30_MONO
	jz	tlab06
	cmp	[DI].ACTIVE_DISPLAY,MOD30_COLOR
	jz	tlab06
	cmp	[DI].ALT_DISPLAY,MOD30_MONO
	jz	tlab06
	cmp	[DI].ALT_DISPLAY,MOD30_COLOR
	jnz	tlab07

tlab06:
	or	HDWR_FLAG,MCGA_ACTIVE	; so...set hdwr flag and...
	lea	si,COLOR_TABLE
	mov	cx,COLOR_NUM		; load color table +..
	call	LOAD_TABLE
	lea	si,MCGA_TABLE		; load MCGA table
	mov	cx,MCGA_NUM
	call	LOAD_TABLE

tlab07:
	mov	al,[DI].CURRENT_SCANS	; copy current scan line setting..
	mov	MAX_SCANS,al 		; as maximum text mode scan setting.
	les	DI,[DI].STATIC_ADDRESS	; point to static functionality table
	mov	al,es:[DI].SCAN_TEXT	; load available scan line flag byte..
	mov	SCAN_LINES,al		; and store it in resident data.

	jmp	short DET_HDWR_DONE

;	call not supported, try EGA

tlab11:
	mov	ah,alT_SELECT		; alternate select call
	mov	BL,EGA_INFO		; get EGA information subcall
	int	10H

	cmp	bl,EGA_INFO		; see if call was valid
	jz	DET_HDWR_DONE

	cmp	bh,MONOCHROME		; yes, check for monochrome
	jnz	tlab17

	or	HDWR_FLAG,E5151_ACTIVE	; ..5151 found so set hdwr flag and..
	lea	si,EGA_5151_TABLE
	mov	cx,EGA_5151_NUM		; load 5151 table.
	call	LOAD_TABLE

	jmp	short DET_HDWR_DONE

tlab17:
	and	CL,0FH			; clear upper nibble of switch setting byte

	cmp	cl,9			; test for switch settings of 5154
	jz	tlab13
	cmp	cl,3
	jnz	tlab14
tlab13:

	or	HDWR_FLAG,E5154_ACTIVE	; so..set hdwr flag and...
	lea	si,COLOR_TABLE
	mov	cx,COLOR_NUM		; load color table +..
	call	LOAD_TABLE
	lea	si,EGA_5154_TABLE	; load 5154 table
	mov	cx,EGA_5154_NUM
	call	LOAD_TABLE

	jmp	short DET_HDWR_DONE

;	5154 not found, must be 5153

tlab14:
	or	HDWR_FLAG,E5153_ACTIVE	; so..set hdwr flag and...
	lea	si,COLOR_TABLE
	mov	cx,COLOR_NUM		; load color table +..
	call	LOAD_TABLE
	lea	si,EGA_5153_TABLE	; load 5153 table
	mov	cx,EGA_5153_NUM
	call	LOAD_TABLE

DET_HDWR_DONE:
	ret
DET_HDWR	ENDP




; PROCEDURE_NAME: CHECK_BUF

; FUNCTION:
; THIS PROCEDURE WRITES TO THE VIDEO BUFFER AND READS THE DATA BACK
; AGAIN TO DETERMINE THE EXISTANCE OF THE VIDEO CARD.

; AT ENTRY:

; AT EXIT:
;	NORMAL: AH EQ AL IF BUFFER PRESENT
;		AH NE AL IF NO BUFFER

;	ERROR: N/A



CHECK_BUF PROC	NEAR			; write to video buffer to see if it is present

	push	ds
	mov	ds,ax			; load DS with address of buffer
	mov	CH,ds:0			; save buffer information (if present)
	mov	al,55H 			; prepare to write sample data
	mov	ds:0,al			; write to buffer
	push	BX			; terminate the bus so that lines..
	pop	BX			; are reset
	mov	ah,ds:0			; bring sample data back...
	mov	ds:0,CH			; repair damage to buffer
	pop	ds
	ret

CHECK_BUF ENDP



; PROCEDURE_NAME: LOAD_TABLE

; FUNCTION:
; THIS PROCEDURE COPIES ONE OF THE VIDEO TABLES INTO RESIDENT DATA.
; IT MAY BE REPEATED TO LOAD SEVERAL TABLES INTO THE SAME DATA SPACE.
; MATCHING MODES WILL BE OVERWRITTEN...THEREFORE..CARE MUST BE TAKEN
; IN LOAD ORDERING.

; AT ENTRY:
;	SI: POINTS TO TOP OF TABLE TO COPY
;	CX: NUMBER OF RECORDS TO COPY

; AT EXIT:
;	NORMAL: TABLE POINTED TO BY SI IS COPIED INTO RESIDENT DATA AREA

;	ERROR: N/A



LOAD_TABLE PROC	NEAR
	push	DI			; save DI
	push	es			; and ES
	push	cs			; setup ES to code segment
	pop	es			
	lea	DI,VIDEO_MODE_TABLE	; point DI to resident video table

while01:
	cmp	cx,0			; do for as many records as there are
	jz	while01_exit
	cmp	di,VIDEO_TABLE_MAX	; check to ensure other data not overwritten
	jge	while01_exit		; cas --- signed compare!!!

	mov	al,[DI].V_MODE		; prepare to check resident table

	cmp	al,UNOCCUPIED		; if this spot is occupied
	jz	tlab20
	cmp	al,[si].V_MODE		; and is not the same mode then
	jz	tlab20

	add	DI,TYPE MODE_TABLE	; do not touch...go to next mode

	jmp	short while01

;	can write at this location

tlab20:
	push	cx			; save record count
	mov	cx,TYPE MODE_TABLE	; load record length
	rep	movsb			; copy record to resident data
	lea	DI,VIDEO_MODE_TABLE	; Set DI to the top of the target again.
	pop	cx			; restore record count and..
	dec	cx			; decrement

	jmp	short while01

while01_exit:
	pop	es			; restore..
	pop	DI			; registers
	ret
LOAD_TABLE ENDP




; PROCEDURE_NAME: LOAD_INT10

; FUNCTION:
; THIS PROCEDURE LOADS THE INTERRUPT HANDLER FOR INT10H

; AT ENTRY:

; AT EXIT:
;	NORMAL: INTERRUPT 10H VECTOR POINTS TO INT10_COM. OLD INT 10H
;		VECTOR STORED.

;	ERROR:	N/A



LOAD_INT10 PROC	NEAR
	push	es
	xor	ax,ax 			; point ES to low..
	mov	es,ax	 		; memory.
	mov	cx,es:WORD PTR INT10_LOW; store original..
	mov	cs:ROM_INT10,cx		; interrupt 10h..
	mov	cx,es:WORD PTR INT10_HI	; location..
	mov	cs:ROM_INT10+2,cx
	cli
	mov	es:WORD PTR INT10_LOW,OFFSET INT10_COM ; replace vector..
	mov	es:WORD PTR INT10_HI,cs	; with our own..
	sti
	mov	ax, DISPLAY_CHECK	;DISPLAY.SYS already loaded?
	int	2fh
	cmp	al, INSTALLED
	jne	L_INT10_Ret
	mov	cs:Display_Loaded_Before_Me,1
L_INT10_Ret:
	pop	es
	ret
LOAD_INT10 ENDP




; PROCEDURE_NAME: LOAD_INT2F

; FUNCTION:
; THIS PROCEDURE LOADS THE INTERRUPT HANDLER FOR INT2FH

; AT ENTRY:

; AT EXIT:
;	NORMAL: INTERRUPT 2FH VECTOR POINTS TO INT2F_COM. OLD INT 2FH
;		VECTOR STORED.

;	ERROR:	N/A



LOAD_INT2F PROC	NEAR
	push	es
	xor	ax,ax 			; point ES to low..
	mov	es,ax 			; memory.
	mov	ax,es:WORD PTR INT2F_LOW; store original..
	mov	cs:ROM_INT2F,ax		; interrupt 2Fh..
	mov	cx,es:WORD PTR INT2F_HI	; location..
	mov	cs:ROM_INT2F+2,cx
	or	ax,cx 			; check if old int2F is 0
	jnz	tlab21
	mov	ax,OFFSET ABORT		; yes....point to..
	mov	cs:ROM_INT2F,ax		; IRET.
	mov	ax,cs
	mov	cs:ROM_INT2F+2,ax

tlab21:
	cli
	mov	es:WORD PTR INT2F_LOW,OFFSET INT2F_COM	; replace vector..
	mov	es:WORD PTR INT2F_HI,cs	; with our own..
	sti
	pop	es
	ret
LOAD_INT2F ENDP


CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\ansi.inc ===
;   Equates and Strucs.


;------------------------------------------------------------------------------
; D425 For OS2 compatibiltiy box, /L option status query     01/14/88 J.K.
; D493 New INIT request structure for error message          02/25/88 J.K.
; P4934 Change ANSI 2F function number to 1Ah                05/20/88 F.G.
;------------------------------------------------------------------------------


;	DEVICE Header		DS:[SI]	-- to locate the next CON header
;	NEXT device header	ES:[DI]


HP		EQU	DS:[SI]
NHD		EQU	ES:[DI]

; CON data structure	CS:[BX]

CONPTR		EQU	CS:[BX]
					; STATES
BUF_DATA	STRUC
DEV_HDRO	DW	-1		; device driver header offset
DEV_HDRS	DW	-1
CON_STRAO	DW	-1		; dos CON strategy offset
CON_STRAS	DW	-1
CON_INTRO	DW	-1		; dos CON strategy offset
CON_INTRS	DW	-1
BUF_DATA	ENDS

;	INIT Structures and equates
IFNDEF		TRUE
TRUE		EQU	-1
ENDIF
IFNDEF		FALSE
FALSE		EQU	0
ENDIF
BRKADR		EQU	6Ch		; Break vector address
CR		EQU	13		; carriage return
BACKSP		EQU	8		; backspace
ESC_CHAR	EQU	1BH
ASNMAX		EQU	400		; (increased) SIZE OF KEY ASSIGNMENT BUFFER
ROM_BIOS	EQU	40h		; Segment of ROM_BIOS data area
EQUIP_FLAG	EQU	10h		; equipment flag. (for LCD)
KBD_FLAG_3	EQU	96h		; offset of KBD_FLAG_3 in data area
NUM_ROWS	EQU	84h		; offset of number of rows in data area
EXT16_FLAG	EQU	00010000b	; mask for Extended INT16 bit
INIT_VID_MASK	EQU	0FFCFh		; mask for equipment list
LCD_COLOR_MODE	EQU	20h		; LCD as color
LCD_MONO_MODE	EQU	30h		; LCD as MONOchrome
UNKNOWN_CMD	EQU	8103H		; unknown command status byte
RC_EOL		EQU	-1		; parser return code for EOL
RC_NO_ERROR	EQU	0		; parser return code for not in switch list
INVALID_PARM	EQU	10		; PARSE Invalid parameter message number
SSTRING		EQU	3		; PARSE Too many parameters message
FUNC_CALL	EQU	1BH		; VGA functionality call
ALT_SELECT	EQU	12H		; EGA alternate select call
EGA_INFO	EQU	10H		; EGA return information subcall
ALT_PRT_SC	EQU	20H		; select alternate print screen subcall
MONOCHROME	EQU	1		; monochrome attached to EGA
COLOR		EQU	0		; some color attached to EGA
PS2_MONO	EQU	7		; display adapter types...
PS2_COLOR	EQU	8
MOD30_MONO	EQU	0BH
MOD30_COLOR	EQU	0CH
LCD_MODEL	EQU	0F9H		; Convertible model byte value
GET_SYS_ID	EQU	0C0H		; INT15H call for system identification
GET_STATUS	EQU	43H		; read system status (Convertible)
MONO_ADDRESS	EQU	0B000H		; base address for monochrome
COLOR_ADDRESS	EQU	0B800H		; base address for CGA
UNOCCUPIED	EQU	-1		; value in VIDEO_MODE_TABLE if space unused
LCD_ACTIVE	EQU	00000001B	; LCD adapter is present
MONO_ACTIVE	EQU	00000010B	; monochrome adapter is present
CGA_ACTIVE	EQU	00000100B	; CGA adapter is present
MCGA_ACTIVE	EQU	00001000B	; MCGA is present
E5151_ACTIVE	EQU	00010000B	; EGA with monochrome is present
E5153_ACTIVE	EQU	00100000B	; EGA with color display is present
E5154_ACTIVE	EQU	01000000B	; EGA with enhanced color display is present
VGA_ACTIVE	EQU	10000000B	; VGA is present
INT10_LOW	EQU	(4*10H)		; interrupt 10 vector location
INT10_HI	EQU	(4*10H)+2
INT2F_LOW	EQU	(4*2FH)		; interrupt 2F vector location
INT2F_HI	EQU	(4*2FH)+2
ONE		EQU	1
THREE		EQU	3
EIGHT		EQU	8
NINE		EQU	9
FOURTEEN	EQU	14
REQ_CRSR_POS	EQU	3		; function call to return cursor position
MODE7		EQU	7
MODE13		EQU	13
MODE15		EQU	15
MODE19		EQU	19

;	Request Header Structure (INIT)

INIT_REQ_HDR	STRUC			; INIT Request header structure
		DB	13 DUP(?)	; standard request header
NUM_UNITS	DB	?		; number of units (N/A)
END_ADDRESS_O	DW	?		; ending address of resident code
END_ADDRESS_S	DW	?
ARG_PTR		DD	?		; ptr. to remaining arguments
DRIVE_NUM	DB	?		; drive number (N/A)
CONFIG_ERRMSG	DW	0		; Flag to control "Error in CONFIG.SYS.." msg.
INIT_REQ_HDR	ENDS


; Information Block Structure
;	(for functionality call)


INFO_BLOCK	STRUC			; information block for functionality call
STATIC_ADDRESS	DD	?		; address of static functionality table
		DB	33 DUP(?)	; don't care
ACTIVE_DISPLAY	DB	?		; active display code
ALT_DISPLAY	DB	?		; alternate display code
		DB	3 DUP(?)	; don't care
CURRENT_SCANS	DB	?		; current number of scan lines
		DB	2 DUP(?)	; don't care
MISC_INFO	DB	?		; miscellaneous state information
		DB	18 DUP(?)	; don't care
INFO_BLOCK	ENDS

; Video table entry structure


MODE_TABLE	STRUC
V_MODE		DB	-1		; video mode
D_MODE		DB	-1		; display mode
RESERVED_BYTE	DB	0		; reserved
COLORS		DW	-1		; colors
SCR_WIDTH	DW	-1		; screen width (pels)
SCR_LENGTH	DW	-1		; screen length (pels)
SCR_COLS	DW	-1		; number columns
SCR_ROWS	DW	-1		; number rows
MODE_TABLE	ENDS


; Structure of Static Block
;	(for functionality call


STATIC_BLOCK	STRUC			; format of static functionality table
		DB	7 DUP(?)	; don't care
SCAN_TEXT	DB	?		; available scan lines in text modes
STATIC_BLOCK	ENDS


; Structure of System ID call return block


SYS_ID		STRUC			; format of return system config data
		DW	?		; don't care
MODEL_BYTE	DB	?		; model byte
SYS_ID		ENDS



; INT2f Strucs and Equates


MULT_ANSI	EQU	1Ah		; ANSI multiplex number
INSTALL_CHECK	EQU	0		; install check for ANSI
IOCTL_2F	EQU	1		; 2F interface to IOCTL
DA_INFO_2F	EQU	2h		; J.K. Information passing to ANSI.
					; Subfunction code for IOCTL_2F
GET_SUBFUNC	EQU	7FH		; WGR Same structure as GET_IOCTL(ANSI)

;Info Struture for DA_INFO_2F. (DS:DX point to this packet)
;J.K. Note: For DOS 4.00, DA_INFO_PACKET is used by DISPLAY.SYS to signal ANSI.SYS that
;DISPLAY.SYS is calling/finishing INT 10h SET MODE call.	ANSI.SYS needs this
;infomration since it also hooks INT 10h vector.
;For this DA_SETMODE_FLAG purpose, DA_INFO_LEVEL and DA_INFO_DIRECTION should always be
;set to 0.	This can be extended for another information passing scheme between
;DISPLAY.SYS and ANSI.SYS in the future version.
;For DA_SETMODE_FLAG, DISPLAY.SYS should be extremely careful that when it calls
;with DA_SETMODE_FLAG =1, then it should calls with DA_SETMODE_FLAG=0
;when it finished INT 10h function call. Otherwise, the system goes .....

;D425. At the request of OS2 compatibility box, when the user ask to ANSI
; with DA_INFO_LEVEL=1, then ANSI sets DA_OPTION_L_STATE based on /L option
; status.

DA_INFO_PACKET	STRUC
DA_INFO_LEVEL	DB	0		; 0=used for SET_MODE_FLAG 1=for L_STATE
DA_SETMODE_FLAG	DB	0		; 1: DISPLAY.SYS is calling INT 10h call, SET MODE. 0=finished.
DA_L_STATE	DB	0		; 1 = /L active, 0 = /L inactive
DA_INFO_PACKET	ENDS



; GENERIC IOCTL Strucs and Equates



DISPLAY_TYPE	EQU	3		; MAJ_FUNC type for display
GET_FUNC	EQU	7FH		; MIN_FUNC for get subfunction
SET_FUNC	EQU	5FH		; MIN_FUNC for set subfunction
REQ_VID_MODE	EQU	0FH		; request video mode INT10h function call
DONE		EQU	0100H		; set done bit for IOCTL status
CMD_ERROR	EQU	8000H		; set error bit for IOCTL status
INVALID_FUNC	EQU	1		; invalid function
NOT_SUPPORTED	EQU	10		; return code non-supported ioctl function
NOT_AVAILABLE	EQU	12		; return code for font not available
TEXT_MODE	EQU	1		; text mode = 1 in request packet
GRAPHICS_MODE	EQU	2		; graphics mode = 2
DEFAULT_LENGTH	EQU	25		; normal screen length
OFF		EQU	0000H
ON		EQU	0001H
INT_BIT		EQU	00100000b	; mask for int. bit from functionality call
FOUND		EQU	1		; flag value for FOUND
NOT_FOUND	EQU	0		; flag value for not FOUND
SET_MODE	EQU	0		; set mode INT10H function number
DISPLAY_CHECK	EQU	0AD00H		; install check for DISPLAY.SYS
CHECK_ACTIVE	EQU	0AD02H		; active code page check for DISPLAY.SY
INSTALLED	EQU	0FFH		; present in AL if installed
LOAD_8X8	EQU	1112H		; register value for 8x8 ROM load
SET_BLOCK_0	EQU	1103H		; activate block = 0.
CHECK_FOR_FONT	EQU	0AD10H		; check for 8x8 RAM font - DISPLAY.SYS
SELECT_SCAN	EQU	30H		; subfunction to set scan lines (VGA)
SET_INTENSIFY	EQU	0		; value to enable intensify.
SET_BLINK	EQU	1		; value to enable blink.
BLINK_TOGGLE	EQU	1003H		; INT10 call to toggle int/blink bit.
CURSOR_FLAG	EQU	87H		; cursor flag byte in ROM_BIOS
SET_CURSOR_CALL EQU	1		; INT10 function call to set cursor typ
VIDEO_MASK	EQU	7FH		; turn of clear buffer bit of mode value
MULT_ANSI	EQU	1Ah		; ANSI multiplex number		;AC003
INSTALL_CHECK	EQU	0		; install check for ANSI
IOCTL_2F	EQU	1		; 2F interface to IOCTL
NOT_CY		EQU	0FFFEH		; turn carry bit off
CY		EQU	1		; turn carry bit off
INVALID_FLAGS	EQU	0FFFEH		; test for invalid flags in control word
TURN_OFF	EQU	0FEH		; values to turn off and on cursor..
TURN_ON		EQU	NOT TURN_OFF	; emulation
SUB_SIZE	EQU	11		; sublist size
LEFT_ASCIIZ	EQU	00010000B	; left-aligned asciiz string
UNLIMITED	EQU	0		; unlimited message size.


CMDLEN	=	0	;LENGTH OF THIS COMMAND
UNIT	=	1	;SUB UNIT SPECIFIER
CMD	=	2	;COMMAND CODE
STATUS	=	3	;STATUS
MEDIA	=	13	;MEDIA DESCRIPTOR
TRANS	=	14	;TRANSFER ADDRESS
COUNT	=	18	;COUNT OF BLOCKS OR CHARACTERS
START	=	20	;FIRST BLOCK TO TRANSFER


; REQUEST PACKET STRUCTURE (Generic IOCTL)


REQ_PCKT	STRUC
INFO_LEVEL	DB	?		; information level (should be 0)
		DB	?		; reserved
DATA_LENGTH	DW	?		; length of remaining data
RP_FLAGS	DW	?		; control flags
RP_MODE		DB	?		; display mode
RESERVED2	DB	?		; reserved
RP_COLORS	DW	?		; # of colors
RP_WIDTH	DW	?		; screen width
RP_LENGTH	DW	?		; screen length
RP_COLS		DW	?		; columns
RP_ROWS		DW	?		; rows
REQ_PCKT	ENDS


; Scan Lines available structure


SCAN_LINE_STR	STRUC
NUM_LINES	DW	?		; number of scan lines
REP_1BH		DB	?		; representation in 1Bh call
REP_12H		DB	?		; representation in 12h call
SCAN_LINE_STR	ENDS


; SUBLIST struc


SUB_STRUC	STRUC
		DB	2 DUP(?)
SUB_PTR_O	DW	?
SUB_PTR_S	DW	?
SUB_STRUC	ENDS


; RESULT BUFFER struc


RESULT_STRUC	STRUC
RESULT_TYPE	DB	?
		DB	?
RES_SYN_PTR	DW	?
RES_PTR		DD	?
RESULT_STRUC	ENDS

BREAK		MACRO	subtitle
		SUBTTL	subtitle
		PAGE	,132
ENDM

AsmVars		Macro	varlist
IRP		var,<varlist>
AsmVar		var
ENDM
ENDM

AsmVar		Macro	var
IFNDEF		var
var		=	FALSE
ENDIF
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\ansivid.inc ===
VGA_TABLE	   LABEL BYTE
    MODE_TABLE	 < 1, 1,, 16,  -1,  -1, 40, -1> ; mode	1  To give preference
    MODE_TABLE	 < 0, 1,, 16,  -1,  -1, 40, -1> ; mode	0   of COxx over
    MODE_TABLE	 < 3, 1,, 16,  -1,  -1, 80, -1> ; mode	3   BWxx.
    MODE_TABLE	 < 2, 1,, 16,  -1,  -1, 80, -1> ; mode	2 	(see text)
    MODE_TABLE	 < 7, 1,,  0,  -1,  -1, 80, -1> ; mode	7
    MODE_TABLE	 <13, 2,, 16, 320, 200, 40, 25> ; mode 13
    MODE_TABLE	 <14, 2,, 16, 640, 200, 80, 25> ; mode 14
    MODE_TABLE	 <15, 2,,  0, 640, 350, 80, 25> ; mode 15
    MODE_TABLE	 <16, 2,, 16, 640, 350, 80, 25> ; mode 16
    MODE_TABLE	 <17, 2,,  2, 640, 480, 80, 30> ; mode 17
    MODE_TABLE	 <18, 2,, 16, 640, 480, 80, 30> ; mode 18
    MODE_TABLE	 <19, 2,,256, 320, 200, 40, 25> ; mode 19
VGA_NUM 	 EQU  ($ - VGA_TABLE)/(TYPE MODE_TABLE)

MCGA_TABLE	   LABEL BYTE
    MODE_TABLE	 <17, 2,,  2, 640, 480, 80, 30> ; mode 17
    MODE_TABLE	 <19, 2,,256, 320, 200, 40, 25> ; mode 19
MCGA_NUM	 EQU  ($ - MCGA_TABLE)/(TYPE MODE_TABLE)

EGA_5154_TABLE	   LABEL BYTE
    MODE_TABLE	 < 1, 1,, 16,  -1,  -1, 40, 43> ; mode	1  To give preference
    MODE_TABLE	 < 0, 1,, 16,  -1,  -1, 40, 43> ; mode	0   of COxx over
    MODE_TABLE	 < 3, 1,, 16,  -1,  -1, 80, 43> ; mode	3   BWxx.
    MODE_TABLE	 < 2, 1,, 16,  -1,  -1, 80, 43> ; mode	2 	(see text)
    MODE_TABLE	 <13, 2,, 16, 320, 200, 40, 25> ; mode 13
    MODE_TABLE	 <14, 2,, 16, 640, 200, 80, 25> ; mode 14
    MODE_TABLE	 <16, 2,, 16, 640, 350, 80, 25> ; mode 16
EGA_5154_NUM	 EQU  ($ - EGA_5154_TABLE)/(TYPE MODE_TABLE)

EGA_5153_TABLE	   LABEL BYTE
    MODE_TABLE	 <13, 2,, 16, 320, 200, 40, 25> ; mode 13
    MODE_TABLE	 <14, 2,, 16, 640, 200, 80, 25> ; mode 14
EGA_5153_NUM	 EQU  ($ - EGA_5153_TABLE)/(TYPE MODE_TABLE)

EGA_5151_TABLE	   LABEL BYTE
    MODE_TABLE	 < 7, 1,,  0,  -1,  -1, 80, 43> ; mode	7
    MODE_TABLE	 <15, 2,,  0, 640, 350, 80, 25> ; mode 15
EGA_5151_NUM	 EQU  ($ - EGA_5151_TABLE)/(TYPE MODE_TABLE)

MONO_TABLE	   LABEL BYTE
    MODE_TABLE	 < 7, 1,,  0,  -1,  -1, 80, 25> ; mode	7
MONO_NUM	 EQU  ($ - MONO_TABLE)/(TYPE MODE_TABLE)

COLOR_TABLE	   LABEL BYTE
    MODE_TABLE	 < 1, 1,, 16,  -1,  -1, 40, 25> ; mode	1  To give preference
    MODE_TABLE	 < 0, 1,, 16,  -1,  -1, 40, 25> ; mode	0   of COxx over
    MODE_TABLE	 < 3, 1,, 16,  -1,  -1, 80, 25> ; mode	3   BWxx.
    MODE_TABLE	 < 2, 1,, 16,  -1,  -1, 80, 25> ; mode	2 	(see text)
    MODE_TABLE	 < 4, 2,,  4, 320, 200, 40, 25> ; mode	4
    MODE_TABLE	 < 5, 2,,  2, 320, 200, 40, 25> ; mode	5
    MODE_TABLE	 < 6, 2,,  2, 640, 200, 80, 25> ; mode	6
COLOR_NUM	 EQU  ($ - COLOR_TABLE)/(TYPE MODE_TABLE)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\parser.asm ===
PAGE	    ,132
TITLE	    PARSE CODE AND CONTROL BLOCKS FOR ANSI.SYS

;****************** START OF SPECIFICATIONS **************************

;  MODULE NAME: PARSER.ASM

;  DESCRIPTIVE NAME: PARSES THE DEVICE= STATEMENT IN CONFIG.SYS FOR
;		     ANSI.SYS

;  FUNCTION: THE COMMAND LINE PASSED TO ANSI.SYS IN THE CONFIG.SYS
;	     STATEMENT IS PARSED TO CHECK FOR THE /X SWITCH. A FLAG
;	     IS CLEARED IF NOT FOUND.

;  ENTRY POINT: PARSE_PARM

;  INPUT: DS:SI POINTS TO EVERYTHING AFTER DEVICE=

;  AT EXIT:
;     NORMAL: SWITCH FLAGS WILL BE SET IF /X or /L IS FOUND

;     ERROR: CARRY SET

;  INTERNAL REFERENCES:

;     ROUTINES: SYSLOADMSG - MESSAGE RETRIEVER LOADING CODE
;		SYSDISPMSG - MESSAGE RETRIEVER DISPLAYING CODE
;		PARM_ERROR - DISPLAYS ERROR MESSAGE
;		SYSPARSE - PARSING CODE

;     DATA AREAS: PARMS - PARSE CONTROL BLOCK FOR SYSPARSE

;  EXTERNAL REFERENCES:

;     ROUTINES: N/A

;     DATA AREAS: SWITCH - BYTE FLAG FOR EXISTENCE OF SWITCH PARAMETER

;  NOTES:

;  REVISION HISTORY:
;	    A000 - DOS Version 4.00

;      Label: "DOS ANSI.SYS Device Driver"
;	      "Version 4.00 (C) Copyright 1988 Microsoft"
;	      "Licensed Material - Program Property of Microsoft"

;****************** END OF SPECIFICATIONS ****************************
;Modification history**********************************************************
; P1529 ANSI /x /y gives wrong error message		   10/8/87 J.K.
; D397  /L option for "Enforcing" the line number            12/17/87 J.K.
; D479  An option to disable the extended keyboard functions 02/12/88 J.K.
;******************************************************************************


INCLUDE     ANSI.INC	    ; ANSI equates and structures
.XLIST
INCLUDE     SYSMSG.INC	    ; Message retriever code
MSG_UTILNAME <ANSI>	    ; Let message retriever know its ANSI.SYS
.LIST

PUBLIC	    PARSE_PARM	     ; near procedure for parsing DEVICE= statement



; Set assemble switches for parse code that is not required!!



DateSW	      EQU     0
TimeSW	      EQU     0
CmpxSW	      EQU     0
DrvSW	      EQU     0
QusSW	      EQU     0
NumSW	      EQU     0
KeySW	      EQU     0
Val1SW	      EQU     0
Val2SW	      EQU     0
Val3SW	      EQU     0


CODE	      SEGMENT  PUBLIC BYTE
	      ASSUME CS:CODE

.XLIST
MSG_SERVICES <MSGDATA>
MSG_SERVICES <DISPLAYmsg,LOADmsg,CHARmsg>
MSG_SERVICES <ANSI.CL1>
MSG_SERVICES <ANSI.CL2>
MSG_SERVICES <ANSI.CLA>

INCLUDE     VERSION.INC
INCLUDE     PARSE.ASM       ; Parsing code
.LIST


EXTRN	    SWITCH_X:BYTE	 ; /X switch flag
extrn	    Switch_L:Byte	 ; /L switch flag
extrn	    Switch_K:Byte	 ; /K switch flag
extrn	    Switch_S:Byte	 ; M008 ; /S or /SCREENSIZE switch flag	



; PARM control blocks for ANSI
; Parsing DEVICE= statment from CONFIG.SYS

; DEVICE=[d:][path]ANSI.SYS [/X] [/K] [/L] [/S | /SCREENSIZE] ; M008



PARMS	       LABEL WORD
	       DW	PARMSX
	       DB	0		   ; no extra delimeters or EOLs.

PARMSX	       LABEL BYTE
	       DB	1,1		   ; 1 valid positional operand
	       DW	FILENAME	   ; filename
	       DB	1		   ; 1 switche definition in the following
	       DW	Switches
	       DB	0		   ; no keywords

FILENAME       LABEL WORD
	       DW	0200H		   ; file spec
	       DW	0001H		   ; cap by file table
	       DW	RESULT_BUF	   ; result
	       DW	NOVALS		   ; no value checking done
	       DB	0		   ; no switch/keyword synonyms

Switches       LABEL WORD
	       DW	0		   ; switch with no value
	       DW	0		   ; no functions
	       DW	RESULT_BUF	   ; result
	       DW	NOVALS		   ; no value checking done
	       DB	5		   ;AN003; M008; 5 switch synonym
X_SWITCH       DB	"/X",0             ; /X name
L_SWITCH       DB	"/L",0             ; /L
K_SWITCH       DB	"/K",0             ; /K
SSIZE_SWITCH   DB	"/SCREENSIZE",0    ; M008; /SCREENSIZE
S_SWITCH       DB	"/S",0             ; M008; /S

NOVALS	       LABEL BYTE
	       DB	0		   ; no value checking done

RESULT_BUF     LABEL BYTE
	       DB	?		   ; type returned (number, string, etc.)
	       DB	?		   ; matched item tag (if applicable)
SYNONYM_PTR    DW	0		   ; synonym ptr (if applicable)
	       DD	?		   ; value

SUBLIST        LABEL DWORD		   ; list for substitution
	       DB	SUB_SIZE
	       DB	0
	       DD	?
	       DB	1
	       DB	LEFT_ASCIIZ
	       DB	UNLIMITED
	       DB	1
	       DB	" "

Old_SI		dw	?
Saved_Chr	db	0
Continue_Flag	db	ON
Parse_Err_Flag	db	OFF



; PROCEDURE_NAME: PARSE_PARM

; FUNCTION:
; THIS PROCEDURE PARSES THE DEVICE= PARAMETERS FROM THE INIT REQUEST
; BLOCK. ERROR MESSAGES ARE DISPLAYED ACCORDINGLY.

; AT ENTRY: DS:SI POINTS TO EVERYTHING AFTER THE DEVICE= STATEMENT

; AT EXIT:
;    NORMAL: CARRY CLEAR - SWITCH FLAG BYTE SET TO 1 IF /X FOUND

;    ERROR: CARRY SET



PARSE_PARM    PROC     NEAR
	      CALL     SYSLOADMSG		; load message

	jnc	plab01

		CALL	 SYSDISPMSG		; display error message
		STC				; ensure carry still set

	jmp	plab02

plab01:
		PUSH	 CS			; establish ES ..
		POP	 ES			; addressability to data
		LEA	 DI,PARMS		; point to PARMS control block
		XOR	 CX,CX			; clear both CX and DX for
		XOR	 DX,DX			;  SYSPARSE
		CALL	 SYSPARSE		; move pointer past file spec
		mov	 Switch_L, OFF
		mov	 Switch_X, OFF

while01:
	cmp	Continue_Flag,ON
	jz	plab_bogus		; M008; bogus label to avoid jmp
	jmp	while01_end		; M008; out of short range.

plab_bogus:				; M008

	mov Old_SI, SI		;to be use by PARM_ERROR
	call SysParse

	cmp	ax,RC_EOL
	jnz	plab09

	mov Continue_Flag, OFF
	jmp	short while01

plab09:

	cmp	ax,RC_NO_ERROR
	jz	plab07

	   mov Continue_Flag, OFF
	   mov Switch_X, OFF
	   mov Switch_L, OFF
	   mov Switch_K, OFF
	   call Parm_Error
	   mov Parse_Err_Flag,ON

	jmp	short while01

plab07:

	cmp	Synonym_ptr,offset X_SWITCH
	jnz	plab05

	mov	Switch_X,ON
	jmp	short plab04


plab05:
	cmp	Synonym_ptr,offset L_SWITCH
	jnz	plab03

	mov	Switch_L,ON
	jmp	short plab04

plab03:						; M008
	cmp	Synonym_ptr, offset S_SWITCH	; M008
	jnz	plab11				; M008

plab12:						; M008
	mov	Switch_S,ON			; M008
	jmp	short plab04			; M008
						
plab11:						; M008
	cmp	Synonym_ptr, offset SSIZE_SWITCH; M008
	jz	plab12				; M008

	mov	Switch_K,ON		; must be /K

plab04:
	clc

	jmp	while01

while01_end:

	cmp	Parse_Err_Flag,ON
	jnz	plab10

	stc
	jmp	short plab02

plab10:
	clc

plab02:

	      RET
PARSE_PARM    ENDP




; PROCEDURE_NAME: PARM_ERROR

; FUNCTION:
; LOADS AND DISPLAYS "Invalid parameter" MESSAGE

; AT ENTRY:
;   DS:Old_SI -> parms that is invalid

; AT EXIT:
;    NORMAL: ERROR MESSAGE DISPLAYED

;    ERROR: N/A



PARM_ERROR    PROC   NEAR
	      PUSH   CX
	      PUSH   SI
	      PUSH   ES
	      PUSH   DS

;	       PUSH   CS
;	       POP    DS		 ; establish addressability
;	       MOV    BX,DX
;	       LES    DX,[BX].RES_PTR	 ; find offending parameter
	       push   ds
	       pop    es
	       mov    si, cs:Old_SI	;Now es:dx -> offending parms
	       push   si		;Save it
Get_CR:
	       cmp    byte ptr es:[si], 13 ;CR?
	       je     Got_CR
	       inc    si
	       jmp    Get_CR
Got_CR:
	       inc    si		   ; The next char.
	       mov    al, byte ptr es:[si]
	       mov    cs:Saved_Chr, al	   ; Save the next char

	       mov    byte ptr es:[si], 0     ; and make it an ASCIIZ
	       mov    cs:Old_SI, si	; Set it again
	       pop    dx		; saved SI -> DX

	       push   cs
	       pop    ds		;for addressability

	      LEA    SI,SUBLIST 	; ..and place the offset..
	      MOV    [SI].SUB_PTR_O,DX	; ..in the SUBLIST..
	      MOV    [SI].SUB_PTR_S,ES
	      MOV    AX,INVALID_PARM	; load 'Invalid parameter' message number
	      MOV    BX,STDERR		; to standard error
	      MOV    CX,ONE		; 1 substitution
	      XOR    DL,DL		; no input
	      MOV    DH,UTILITY_MSG_CLASS ; parse error
	      CALL   SYSDISPMSG 	; display error message
	      mov    si, cs:Old_SI	;restore the original char.
	      mov    cl, cs:Saved_Chr
	      mov    byte ptr es:[si], cl

	      POP    DS
	      POP    ES
	      POP    SI
	      POP    CX
	      RET
PARM_ERROR    ENDP

include msgdcl.inc

CODE	      ENDS
	      END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\ioctl.asm ===
PAGE	,132
TITLE	ANSI Generic IOCTL Code

;******************************************************************************

;  Change Log:

;    Date    Who   #			  Description
;  --------  ---  ---  ------------------------------------------------------

;  06/29/90  MKS  C04  Bug#1150.  Video 7 Fastwrite VGA has problems if a
;		       Hercules mono board is the active display.

;******************************************************************************

;****************** START OF SPECIFICATIONS **************************

;  MODULE NAME: IOCTL.ASM

;  DESCRIPTIVE NAME: PERFORM THE GENERIC IOCTL CALL IN ANSI.SYS

;  FUNCTION: THE GENERIC DEVICE IOCTL IS USED TO SET AND GET THE
;	     MODE OF THE DISPLAY DEVICE ACCORDING TO PARAMETERS PASSED
;	     IN A BUFFER. ADDITIONALLY, THE CALL CAN TOGGLE THE
;	     USE OF THE INTENSITY BIT, AND CAN LOAD THE 8X8 CHARACTER
;	     SET, EFFECTIVELY GIVING MORE LINES PER SCREEN. THE
;	     AVAILABILITY OF THIS FUNCTION VARIES STRONGLY WITH HARDWARE
;	     ATTACHED.

;  ENTRY POINT: GENERIC_IOCTL

;  INPUT: LOCATION OF REQUEST PACKET STORED DURING STRATEGY CALL.

;  AT EXIT:
;     NORMAL: CARRY CLEAR - DEVICE CHARACTERISTICS SET

;     ERROR: CARRY SET - ERROR CODE IN AX.
;	     AX = 1  - INVALID FUNCTION. EXTENDED ERROR = 20
;	     AX = 10 - UNSUPPORTED FUNCTION ON CURRENT HARDWARE.
;			EXTENDED ERROR = 29
;	     AX = 12 - DISPLAY.SYS DOES NOT HAVE 8X8 RAM CHARACTER SET.
;			EXTENDED ERROR = 31

;  INTERNAL REFERENCES:

;     ROUTINES: GET_IOCTL - PERFORMS THE GET DEVICE CHARACTERISTICS
;		SET_IOCTL - PERFORMS THE SET DEVICE CHARACTERISTICS
;		GET_SEARCH - SEARCHES THE INTERNAL VIDEO TABLE FOR THE
;			     CURRENT MODE MATCH
;		SET_SEARCH - SEARCHES THE INTERNAL VIDEO TABEL FOR THE
;			     CURRENT MODE MATCH
;		SET_CURSOR_EMUL - SETS THE BIT THAT CONTROLS CURSOR EMULATION
;		INT10_COM - INTERRUPT 10H HANDLER TO KEEP CURRENT SCREEN SIZE
;		INT2F_COM - INTERRUPT 2FH INTERFACE TO GENERIC IOCTL
;		MAP_DOWN - PERFORMS CURSOR TYPE MAPPING FOR EGA WITH MONOCHROME
;		SET_VIDEO_MODE - SETS THE VIDEO MODE

;     DATA AREAS: SCAN_LINE_TABLE - HOLDS SCAN LINE INFORMATION FOR PS/2
;		  FUNC_INFO - BUFFER FOR PS/2 FUNCTIONALITY CALL.


;  EXTERNAL REFERENCES:

;     ROUTINES: INT 10H SERVICES

;     DATA AREAS: VIDEO_MODE_TABLE - INTERNAL TABLE FOR CHARACTERISTICS TO MODE
;				     MATCH-UPS

;  NOTES:

;  REVISION HISTORY:

;      Label: "DOS ANSI.SYS Device Driver"
;	      "Version 4.00 (C) Copyright 1988 Microsoft"
;	      "Licensed Material - Program Property of Microsoft"

;****************** END OF SPECIFICATIONS ****************************
;Modification history *********************************************************
; P1350 Codepage switching not working on EGA		   10/10/87 J.K.
; P1626 ANSI does not allow lines=43 with PS2,Monochrome	   10/15/87 J.K.
; p1774 Lines=43 after selecting cp 850 does not work	   10/20/87 J.K.
; p1740 MODE CON LINES command causes problem with PE2 w PS/210/24/87 J.K.
; p2167 Does'nt say EGA in medium resol. cannot do 43 lines  10/30/87 J.K.
; p2236 After esc [=0h, issuing INT10h,AH=fh returns mode=1. 11/3/87  J.K.
; p2305 With ANSI loaded, loading RDTE hangs the system	   11/06/87 J.K.
; P2617 Order dependecy problem with Display.sys		   11/23/87 J.K.
; p2716 HOT key of VITTORIA does not work properly	   12/03/87 J.K.
; d398  /L option for Enforcing the number of lines	   12/17/87 J.K.
; D425 For OS2 compatibiltiy box, /L option status query	   01/14/88 J.K.
; P5699 Moving selecting alternate print screen routine to only when it
; 10/26/88    is needed.  OEM EGA cards don't support the call it, so they
; K. Sayers   couldn't (shift) print screen at all when the alt. routine was
;	      invoked during initialization.
;******************************************************************************

INCLUDE		DEVSYM.INC
INCLUDE		ANSI.INC
INCLUDE		MULT.INC

PUBLIC		GENERIC_IOCTL
PUBLIC		SET_IOCTL
PUBLIC		GET_IOCTL
PUBLIC		SET_SEARCH
PUBLIC		GET_SEARCH
PUBLIC		SET_CURSOR_EMUL
PUBLIC		FUNC_INFO
PUBLIC		MAX_SCANS
PUBLIC		INT10_COM
PUBLIC		SET_MODE_HANDLER
PUBLIC		SET_CURSOR_HANDLER
PUBLIC		ROM_INT10
PUBLIC		INT2F_COM
PUBLIC		INT2F_HANDLER
PUBLIC		ROM_INT2F
PUBLIC		ABORT
PUBLIC		MAP_DOWN
PUBLIC		SET_VIDEO_MODE
PUBLIC		REQ_TXT_LENGTH
PUBLIC		GRAPHICS_FLAG
PUBLIC		DO_ROWS
PUBLIC		Display_Loaded_Before_Me

CODE		SEGMENT  PUBLIC  BYTE
		ASSUME CS:CODE,DS:CODE

EXTRN		PTRSAV:DWORD
EXTRN		NO_OPERATION:NEAR
EXTRN		ERR1:NEAR
EXTRN		VIDEO_MODE_TABLE:BYTE
EXTRN		MAX_VIDEO_TAB_NUM:ABS
EXTRN		HDWR_FLAG:WORD
EXTRN		SCAN_LINES:BYTE
EXTRN		SWITCH_L:Byte			;Defined in ANSI.ASM

IFDEF		JAPAN
EXTRN		row_adj:byte
ENDIF

SCAN_LINE_TABLE	LABEL	BYTE
		SCAN_LINE_STR <200,000000001B,0>	; 200 scan lines
		SCAN_LINE_STR <344,000000010B,1>	; 350 scan lines
		SCAN_LINE_STR <400,000000100B,2>	; 400 scan lines
SCANS_AVAILABLE	EQU	($ - SCAN_LINE_TABLE)/TYPE SCAN_LINE_STR

;This is used when ANSI calls Get_IOCTL, Set_IOCTL by itself.
In_Generic_IOCTL_flag	db	0
I_AM_IN_NOW		EQU	00000001b
SET_MODE_BY_DISPLAY	EQU	00000010b	;Display.sys calls Set mode INT 10h.
CALLED_BY_INT10COM	EQU	00000100b	;To prevent from calling set mode int 10h again.

INT10_V_Mode		db	0ffh		;Used by INT10_COM

My_IOCTL_Req_Packet	REQ_PCKT <0,0,0Eh,0,?,0,?,?,?,?,?>

FUNC_INFO		INFO_BLOCK <>		;data block for functionality call
ROM_INT10		DW	?		;segment and offset of original..
			DW	?		;interrupt 10h vector.
ROM_INT2F		DW	?		;segment and offset of original..
			DW	?		;interrupt 2Fh vector.
INTENSITY_FLAG		DW	OFF		;intensity flag initially off
REQ_TXT_LENGTH		DW	DEFAULT_LENGTH	;requested text screen length
SCAN_DESIRED		DB	0		;scan lines desired
MAX_SCANS		DB	0		;maximum scan line setting
GRAPHICS_FLAG		DB	TEXT_MODE	;flag for graphics mode
Display_Loaded_Before_Me db	0		;flag
ANSI_SetMode_Call_Flag	db	0		;Ansi is issuing INT10,AH=0.
ALT_PRT_SC_INVOKED	DB	FALSE		;indicates that have already set up alternat print screen routine



; PROCEDURE_NAME: GENERIC_IOCTL

; FUNCTION:
; TO GET OR SET DEVICE CHARACTERISTICS ACCORDING TO THE BUFFER PASSED
; IN THE REQUEST PACKET.

; AT ENTRY:

; AT EXIT:
;	NORMAL: CARRY CLEAR - DEVICE CHARACTERISTICS SET

;	ERROR: CARRY SET - ERROR CODE IN AL. (SEE MODULE DESCRIPTION ABOVE).

; NOTE: THIS PROC IS PERFORMED AS A JMP AS WITH THE OLD ANSI CALLS.



GENERIC_IOCTL:
	les	bx,[PTRSAV]			; establish addressability to request header
	mov	al,es:[bx].MINORFUNCTION
	les	di,es:[bx].GENERICIOCTL_PACKET	; point to request packet

	cmp	al,GET_FUNC			; is this get subfunction?
	jnz	gi_not_get

	call	GET_IOCTL			; yes...execute routine

	jmp	short gi_check_error

gi_not_get:
	cmp	al,SET_FUNC			; is this the set subfunction?
	jnz	gi_none

	call	SET_IOCTL			; yes....execute routine

gi_check_error:
	jnc	gi_done				; branch if no error
	or	ax,CMD_ERROR			; yes...set error bit in status

gi_done:
	or	ax,DONE				; add done bit to status
	jmp	ERR1				; return with status in ax

gi_none:
	jmp	NO_OPERATION			; call lower CON device


; PROCEDURE_NAME: GET_IOCTL

; FUNCTION:
; THIS PROCEDURE RETURNS DEVICE CHARACTERISTICS.

; AT ENTRY: ES:DI POINTS TO REQUEST BUFFER

; AT EXIT:
;	NORMAL: CARRY CLEAR - REQUEST BUFFER CONTAINS DEVICE CHARACTERISTICS

;	ERROR: CARRY SET - ERROR CONDITION IN AX



GET_IOCTL	PROC	NEAR

	cmp	es:[di].INFO_LEVEL,0		; check for valid info level
	jnz	gi_invalid
	cmp	es:[di].DATA_LENGTH,TYPE MODE_TABLE+1 ; and buffer size
	jge	gi_valid

gi_invalid:
	mov	ax,INVALID_FUNC			; not valid...unsupported
	stc					; function..set error flag and
	ret

gi_valid:
	mov	es:[di].INFO_LEVEL+1,0		; set reserved byte to 0.
	mov	ah,REQ_VID_MODE			; request current video mode
	int	10H
	and	al,VIDEO_MASK
	lea	si,VIDEO_MODE_TABLE		; point to resident video table
	call	GET_SEARCH			; perform search
	jnc	gi_supported			; found?

	mov	ax,NOT_SUPPORTED		; no....load unsupported function
	ret					; carry already set

gi_supported:
	push	di				;Save Request Buffer pointer
	mov	WORD PTR es:[di].DATA_LENGTH,(TYPE MODE_TABLE)+1 ;length of data is struc size
	inc	si				; skip mode value
	add	di,RP_FLAGS			; point to flag word

;	VGA,MCGA: VALUE RETURNED FROM FUNCTIONALITY CALL
;	EGA: VALUE LAST SET THROUGH IOCTL. DEFAULT IS BLINKING.
;	CGA,MONO: BLINKING

	cmp	al,7				; M004; Monochrome screen?
	mov	ax,OFF				; assume CGA,MONO 
						; (we always have blink).
	jz	gi_flags_done			; M004;

	cmp	HDWR_FLAG,MCGA_ACTIVE		; if we have an EGA or better
	jl	gi_flags_done

	test	HDWR_FLAG,VGA_ACTIVE		; VGA supported?
	jz	gi_as_intensity_flag

	push	es				; yes...prepare for
	push	di				; functionality call

	push	ds
	pop	es
	lea	di,FUNC_INFO			; point to data block
	mov	ah,FUNC_CALL			; load function number
	xor	bx,bx				; implementation type 0
	int	10H

	mov	INTENSITY_FLAG,OFF		; assume no intensity
	test	es:[di].MISC_INFO,INT_BIT	; is blink bit set?
	jnz	gi_intensity_is_fine		; if not no intensity

	inc	INTENSITY_FLAG			; we want intensity

gi_intensity_is_fine:
	pop	di				; restore registers
	pop	es

gi_as_intensity_flag:
	mov	ax,INTENSITY_FLAG		; write the control flag..

gi_flags_done:
	stosw					; write the control flag..
						; point to next field (display)
	mov	cx,(TYPE MODE_TABLE)-1		; load count
	rep	movsb				; transfer data from video table
						; to request packet
	sub	si,TYPE MODE_TABLE		; point back to start of mode data

ifdef JAPAN
	dec	di				; point to number of rows
	dec	di
ENDIF

	cmp	[si].D_MODE,TEXT_MODE		; if we are in text mode and
	jnz	gi_row_counted
	cmp	[si].SCR_ROWS,DEFAULT_LENGTH	; length <> 25 then we have an EGA or VGA
	jz	gi_row_counted

ifndef JAPAN
	dec	di				; point back to length entry in req packet
	dec	di
ENDIF
	push	ds
	mov	ax,ROM_BIOS			; load ROM BIOS data area segment
	mov	ds,ax
	mov	al,BYTE PTR ds:[NUM_ROWS]	; load current number of rows
	cbw
	inc	ax				; add 1 to row count
	mov	WORD PTR es:[di],ax		; and copy to request packet
	pop	ds

gi_row_counted:

ifdef JAPAN
	mov	al,row_adj
	xor	ah,ah
	sub	es:[di],ax			; support ESC[>1l
ENDIF

	xor	ax,ax				; no errors
	clc					; clear error flag
	pop	di				; Restore Request Buffer pointer
	ret					; return to calling module

GET_IOCTL	ENDP




; PROCEDURE_NAME: SET_IOCTL

; FUNCTION:
; THIS PROCEDURE SETS THE VIDEO MODE AND CHARACTER SET ACCORDING
; TO THE CHARACTERSTICS PROVIDED.

; AT ENTRY:
;	ES:[DI] POINTS TO REQUEST BUFFER

; AT EXIT:
;	NORMAL: CLEAR CARRY - VIDEO MODE SET

;	ERROR: CARRY SET - ERROR CONDITION IN AX



SET_IOCTL	PROC	NEAR

	or	In_Generic_IOCTL_Flag, I_AM_IN_NOW	; Signal GENERIC_IOCTL request being processed
	push	REQ_TXT_LENGTH			; save old value in case of error
ifdef JAPAN
	push	word ptr row_adj
endif

	cmp	es:[di].INFO_LEVEL,0		; check for valid info level
	jnz	si_invalid
	cmp	es:[di].DATA_LENGTH,TYPE MODE_TABLE+1 ; ane buffer size
	jnz	si_invalid
	mov	ax,es:[di].RP_FLAGS		; test for invalid flags
	test	ax,INVALID_FLAGS
	jnz	si_invalid
	test	es:[di].RP_FLAGS,ON		; if intensity is requested and..
	jz	si_valid
	cmp	HDWR_FLAG,MCGA_ACTIVE		; hardware does not support it
	jge	si_valid

si_invalid:
	mov	ax,INVALID_FUNC			; not valid...unsupported..
	jmp	si_failed

si_valid:
	call	SET_SEARCH			; search table for match
	jnc	si_mode_valid

si_not_supp:
	jmp	si_not_supported

si_mode_valid:
	cmp	[si].D_MODE,TEXT_MODE		; is a text mode being requested?
	jz	si_do_text_mode

	call	SET_VIDEO_MODE
	jmp	si_end_ok	

si_do_text_mode:
	mov	ax,es:[di].RP_ROWS		; save new requested value.

ifdef JAPAN
	mov	row_adj,0
	cmp	ax,DEFAULT_LENGTH-1
	jnz	@f
	mov	row_adj,1
	inc	ax
@@:
endif

	mov	REQ_TXT_LENGTH,ax

	cmp	ax,DEFAULT_LENGTH		; is it just 25 lines needed?
	jz	si_display_ok

	mov	ax,DISPLAY_CHECK
	int	2FH

	cmp	al,INSTALLED			; or is DISPLAY.SYS not there?
	jnz	si_display_ok

	mov	ax,CHECK_FOR_FONT
	int	2FH				; or if it is does it have the..
	jnc	si_display_ok

	mov	ax,NOT_AVAILABLE		; DISPLAY.SYS does not have the font
	jmp	si_failed
	
si_display_ok:
	cmp	[si].SCR_ROWS,UNOCCUPIED
	jz	si_is_vga
	test	HDWR_FLAG,VGA_ACTIVE
	jz	si_non_vga

si_is_vga:
	mov	ax,1A00h			;Get currently active adap.;C04
	int	10h				;VGA interrupt             ;C04
	mov	ax,REQ_TXT_LENGTH		; restore AX
	cmp	bl,7				;Q: non_vga adapter?	   ;C04
	jb	si_non_vga			;Yes so do other stuff	   ;C04

process_vga:
	mov	cl,3				; ax loaded with length requested
	shl	ax,cl				; mulitply by 8 to get scan lines
	lea	bx,SCAN_LINE_TABLE		; load bx with scan line table start
	mov	cx,SCANS_AVAILABLE		; total number of scan lines settings

pv_while:
	cmp	ax,[bx].NUM_LINES		; pointing at the right setting?
	jz	pv_found

	add	bx,TYPE SCAN_LINE_STR		; not this setting..point to next
	loop	pv_while
	
	jmp	short si_not_supp

pv_found:
	mov	dl,[bx].REP_1BH

	test	SCAN_LINES,dl			; does the hardware have it?
	jz	si_not_supp

	mov	cl,[bx].REP_12H			; yes, store value to set it
	mov	SCAN_DESIRED,cl

	cmp	REQ_TXT_LENGTH,DEFAULT_LENGTH	; 25 lines requested?
	jnz	pv_scan_ok

	mov	al,MAX_SCANS			; desired scan setting should be..
	mov	SCAN_DESIRED,AL			; the maximum.

pv_scan_ok:

; following added to overcome problems with rolling
; screens in QBX and WZMAIL.	Problem still exists when switching between
; mono and VGA screens when ANSI is loaded with /L.

	test	In_Generic_IOCTL_Flag,CALLED_BY_INT10COM
	jnz	si_set_mode_done

	mov	ah,ALT_SELECT			; set the appropriate number..
	mov	bl,SELECT_SCAN			; of scan lines..
	mov	al,SCAN_DESIRED
	int	10H

	jmp	short si_processed

si_non_vga:
	mov	ax,REQ_TXT_LENGTH
	cmp	ax,DEFAULT_LENGTH		; see if length requested..
	jz	si_cursor_emul			; is valid
	cmp	ax,[si].SCR_ROWS
	jnz	si_not_supported

si_cursor_emul:
	call	SET_CURSOR_EMUL

si_processed:
	call	SET_VIDEO_MODE

si_set_mode_done:
	call	DO_ROWS
	cmp	ALT_PRT_SC_INVOKED,FALSE	; If not set up already
	jnz	si_printscreen_ok
	cmp	es:[di].RP_ROWS,DEFAULT_LENGTH	; and needed because lines	(or 30?)
	jle	si_printscreen_ok
	cmp	HDWR_FLAG,MCGA_ACTIVE		; and if we have EGA or better then.. (supported)
	jl	si_printscreen_ok

	mov	ah,ALT_SELECT			; issue select alternate print..
	mov	BL,ALT_PRT_SC			; screen routine call..
	int	10H
	mov	ALT_PRT_SC_INVOKED,TRUE		; mark that it was done

si_printscreen_ok:
	call	SET_CURSOR_EMUL			; yes..ensure cursor emulation
						; is set accordingly.
	cmp	HDWR_FLAG,MCGA_ACTIVE		; for the EGA and better...
	jl	si_end_ok

	cmp	[si].V_MODE,7			; M004; and not monochrome
	jz	si_end_ok

	xor	bx,bx				; bx: 1=intensity on, 0: off
						; assume off
	test	es:[di].RP_FLAGS,ON		
	jz	si_intensity_ok

	inc	bx				; user wants intensity

si_intensity_ok:
	mov	INTENSITY_FLAG,bx
	mov	ax,BLINK_TOGGLE
	xor	bl,ON				; bl is opposite
						; of INTENSITY_FLAG
	int	10H

si_end_ok:
	and	In_Generic_IOCTL_Flag, NOT I_AM_IN_NOW	; Turn the flag off
ifdef JAPAN
	pop	ax				; throw old row_adj
endif
	pop	ax				; forget old REQ_TXT_LENGTH
	xor	ax,ax				; clear error register
	clc					; clear error flag
	ret

si_not_supported:
	mov	ax,NOT_SUPPORTED

si_failed:
	and	In_Generic_IOCTL_Flag, NOT I_AM_IN_NOW	; Turn the flag off
ifdef JAPAN
	pop	word ptr row_adj
endif
	pop	REQ_TXT_LENGTH			; error...so restore old value.
	stc					; set error flag
	ret

SET_IOCTL	ENDP



; Procedure name: DO_ROWS
; Function:
;	Only called for TEXT_MODE.
;	If (REQ_TXT_LENGTH <> DEFAULT_LENGTH) &
;	(DISPLAY.SYS not loaded or CODEPAGE not active)
;	then
;	LOAD ROM 8X8 charater.


DO_ROWS		PROC	NEAR

	cmp	req_txt_length, DEFAULT_LENGTH
	je	dr_exit
	mov	ax,LOAD_8X8 			; load 8x8 ROM font
	xor	bl,bl
	int	10H				; M003;
	mov	ax,SET_BLOCK_0			; activate block = 0
	xor	bl,bl
	int	10H				; M003;
dr_exit:
	ret

DO_ROWS 	ENDP






; PROCEDURE_NAME: SET_SEARCH

; FUNCTION:
; THIS PROCEDURE SEARCHES THE RESIDENT VIDEO TABLE IN ATTEMPT TO
; FIND A MODE THAT MATCHES THE CHARACTERISTICS REQUESTED.

; AT ENTRY:

; AT EXIT:
;	NORMAL: CARRY CLEAR - SI POINTS TO APPLICABLE RECORD

;	ERROR: CARRY SET

; When INT10_V_Mode <> 0FFH, then assumes that the user
;	issuing INT10h, Set mode function call.	Unlike Generic IOCTL
;	set mode call, the user already has taken care of the video mode.
;	So, we also find the matching V_MODE.

; WARNING: TRASH CX

SET_SEARCH	PROC	NEAR

	lea	si,VIDEO_MODE_TABLE		; point to video table
	mov	cx,MAX_VIDEO_TAB_NUM 		; load counter, # of tables

ss_while:
	cmp	[si].V_MODE,UNOCCUPIED		; while we have valid entries
	jz	ss_not_found

	mov	al,INT10_V_Mode

	cmp	al,0ffh				; if not issued by Int10 set mode,
	jnz	ss_from_set_mode

	
	mov	al,es:[di].RP_MODE		; load register for compare.
	cmp	[si].D_MODE,al			; match?
	jnz	ss_end_while

	mov	ax,es:[di].RP_COLORS		; yes...prepare next field
	cmp	[si].COLORS,ax			; match?
	jnz	ss_end_while

	cmp	es:[di].RESERVED2,0		; yes, ensure reserved byte is zero
	jnz	ss_end_while

	cmp	es:[di].RP_MODE,GRAPHICS_MODE	; for graphics mode
	jnz	ss_not_graphic			; check the following:

	mov	ax,es:[di].RP_WIDTH		; screen width.
	cmp	[si].SCR_WIDTH,ax
	jnz	ss_end_while

	mov	ax,es:[di].RP_LENGTH		; screen length
	cmp	[si].SCR_LENGTH,ax
	jnz	ss_end_while			; ignore #rows and #coloumns

	jmp	short ss_found

ss_not_graphic:
	mov	ax,es:[di].RP_COLS		; the rows are matched
	cmp	[si].SCR_COLS,ax		; in the main routine
	jnz	ss_end_while

ss_found:
	clc
	jmp	short ss_done

ss_from_set_mode:
	cmp	[si].V_MODE,al			; if V_MODE = AL, we are ok
	jz	ss_found

ss_end_while:
	add	si,type MODE_TABLE		; then, this is not the correct entry.
	loop	ss_while			; Let's find the next entry.

ss_not_found:
	stc

ss_done:
	mov	INT10_V_Mode, 0FFh		; Done. Reset the value
	ret

SET_SEARCH	ENDP




; PROCEDURE_NAME: GET_SEARCH

; FUNCTION:
; THIS PROCEDURE SEARCHES THE VIDEO TABLE LOOKING FOR A MATCHING
; VIDEO MODE.

; AT ENTRY: DS:SI POINTS TO VIDEO TABLE
;		AL CONTAINS THE MODE REQUESTED

; AT EXIT:
;	NORMAL: CARRY CLEAR, DS:SI POINTS TO MATCHING RECORD

;	ERROR: CARRY SET

; WARNING: TRASH CX

GET_SEARCH	PROC	NEAR

	mov	cx,MAX_VIDEO_TAB_NUM		; # of total tables

gs_while:
	cmp	[si].V_MODE,UNOCCUPIED		; while we're not pointing to
	jz	gs_error
	cmp	[si].V_MODE,al			; the right mode and we are still
	jz	gs_got_it

	add	si,TYPE MODE_TABLE		; point to the next mode
	loop	gs_while

gs_error:
	stc					; no, set error flag
	ret

gs_got_it:
	clc
	ret

GET_SEARCH	ENDP



; PROCEDURE_NAME: SET_CURSOR_EMUL

; FUNCTION:
; THIS PROCEDURE SETS THE CURSOR EMULATION BIT OFF IN ROM BIOS. THIS
; IS TO PROVIDE A CURSOR ON THE EGA WITH THE 5154 LOADED WITH AN 8X8
; CHARACTER SET.

; AT ENTRY:

; AT EXIT:
;	NORMAL: CURSOR EMULATION BIT SET FOR APPLICABLE HARDWARE

;	ERROR: N/A



SET_CURSOR_EMUL PROC	NEAR

	test	HDWR_FLAG,E5154_ACTIVE		; EGA with 5154?
	jz	sce_done

	push	si
	push	ds				; yes..so..
	mov	ax,ROM_BIOS			; check cursor emulation..
	mov	ds,ax
	mov	si,CURSOR_FLAG
	mov	al,BYTE PTR [si]

	cmp	cs:REQ_TXT_LENGTH,DEFAULT_LENGTH; >25 lines req?
	jnz	sce_cursor_on

	and	al,TURN_OFF			; no....set it OFF

	jmp	short sce_cursor_ok

sce_cursor_on:
	or	al,TURN_ON			; yes...set it ON

sce_cursor_ok:
	mov	BYTE PTR [si],AL
	pop	ds
	pop	si

sce_done:
	ret					; return to calling module

SET_CURSOR_EMUL	ENDP




; PROCEDURE_NAME: INT10_COM

; FUNCTION:
; THIS IS THE INTERRUPT 10H HANDLER TO CAPTURE THE FOLLOWING FUNCTIONS:

;	AH=1H (SET CURSOR TYPE). CURSOR EMULATION IS PERFORMED IF WE HAVE
;		AND EGA WITH A 5151 MONITOR, AND 43 LINES IS REQUESTED.

;M002; What is bellow was modified. The /L option was removed. But ansi
;M002; will still do a GET_IOCTL/SET_IOCTL for the application.
;	AH=0H (SET MODE) SCREEN LENGTH IS MAINTAINED WHEN POSSIBLE. (IE. IN
;		TEXT MODES ONLY.)
;	AN004; Capturing Set Mode call and enforcing the # of Rows based on the
;		previous Set_IOCTL request lines was a design mistake.	ANSI cannot
;		covers the all the application program out there which use INT 10h
;		directly to make a full screen interface by their own way.
;		This part of logic has been taken out by the management decision.
;		Instead, for each set mdoe INT 10h function call, if it were not
;		issued by SET_IOCTL procedures itself, or by DISPLAY.SYS program,
;		then we assume that it was issued by an APPS, that usually does not
;		know the new ANSI GET_IOCTL/SET_IOCTL interfaces.
;		In this case, ANSI is going to call GET_IOCTL and SET_IOCTL function
;		call - This is not to lose the local data consistency in ANSI.

; AT ENTRY:

; AT EXIT:
;	NORMAL:

;	ERROR:



INT10_COM	PROC	NEAR

	sti 					; restore interrupts
	cmp	ah,SET_CURSOR_CALL
	jz	SET_CURSOR_HANDLER
	cmp	ah,SET_MODE
	jz	SET_MODE_HANDLER

	jmp	DWORD PTR cs:ROM_INT10		; no...pass it on.

SET_CURSOR_HANDLER:
	push	ax

	test	cs:HDWR_FLAG,E5151_ACTIVE	; do we have an EGA?
	jz	sch_goto_rom
	cmp	cs:REQ_TXT_LENGTH,DEFAULT_LENGTH
	jz	sch_goto_rom
	cmp	cs:GRAPHICS_FLAG,TEXT_MODE	; with 5151..so perform cursor mapping
	jnz	sch_goto_rom
	cmp	cl,8
	jl	sch_goto_rom

	mov	al,ch				; check for cursor..
	and	al,60h				; off emulation. J.K.

	cmp	al,20h
	jz	sch_goto_rom

	mov	al,ch				; start position for cursor
	call	MAP_DOWN
	mov	ch,al
	mov	al,cl				; end position for cursor
	call	MAP_DOWN
	mov	cl,al

sch_goto_rom:
	pop	ax
	jmp	DWORD PTR CS:ROM_INT10		; continue interrupt processing

SET_MODE_HANDLER:
	pushf					; prepare for IRET
	mov	cs:ANSI_SetMode_Call_Flag, 1	; Used by INT2F_COM
	call	DWORD PTR CS:ROM_INT10		; call INT10 routine
	mov	cs:ANSI_SetMode_Call_Flag, 0	; Reset it
	push	bp
	push	es
	push	ds
	push	si
	push	di
	push	dx
	push	cx
	push	bx
	push	ax
	push	cs
	pop	ds
	mov	ah,REQ_VID_MODE			; get current mode..
	pushf
	call	DWORD PTR ROM_INT10
	and	al,VIDEO_MASK			; mask bit 7 (refresh)
	test	In_Generic_IOCTL_Flag, (I_AM_IN_NOW + SET_MODE_BY_DISPLAY)	; Flag is on?
;If not (I_AM_IN_NOW or SET_MODE_BY_DISPLAY),

	jnz	smh_ioctl_done

;	cmp	SWITCH_L,0			;M002; No more /L
;	jnz	smh_ioctl_done			;M002; No more /L

	push	ax				;Save mode
	push	es
	push	cs
	pop	es
	mov	di,offset My_IOCTL_Req_Packet
	mov	INT10_V_Mode,al			;Save current mode for SET_SEARCH
	call	Get_IOCTL

	jc	smh_set_ioctl_done

	or	In_Generic_IOCTL_Flag, CALLED_BY_INT10COM ;Do not set mode INT 10h again. Already done.
	call	Set_IOCTL
	and	In_Generic_IOCTL_Flag, not CALLED_BY_INT10COM

smh_set_ioctl_done:

	pop	es
	pop	ax				;Restore mode
	mov	INT10_V_Mode,0FFh


smh_ioctl_done:

	lea	si,VIDEO_MODE_TABLE
	call	GET_SEARCH 			; look through table for mode selected.
	jc	smh_graphic_mode		; M001; if not found then
						; M001; assume graphic mode

	cmp	[si].D_MODE,TEXT_MODE		; text mode?
	jz	smh_text_mode

smh_graphic_mode:
	mov	GRAPHICS_FLAG,GRAPHICS_MODE	; no, set graphics flag
	jmp	short smh_flag_done

smh_text_mode:
	mov	GRAPHICS_FLAG,TEXT_MODE		; set TEXT MODE


smh_flag_done:

;	test	In_Generic_IOCTL_Flag, I_AM_IN_NOW
;	jnz	smh_l_done			; M002; No more /L
;	cmp	Graphics_Flag,TEXT_MODE		; M002; No more /L
;	jnz	smh_l_done			; M002; No more /L
;	cmp	SWITCH_L,1			; M002; No more /L
;	jnz	smh_l_done			; M002; No more /L

;	call	DO_ROWS				; M002; No more /L

smh_l_done:

;For each SET mode function int 10h function call, if it is not
;issued by ANSI GET_IOCTL and SET_IOCTL procedure themselves, we assume
;that the APPS, which usually does not know the ANSI GET_IOCTL/SET_IOCTL
;interfaces, intend to change the screen mode.	In this case, ANSI is
;kind enough to call GET_IOCTL and SET_IOCTL function call for themselves.

	pop	ax
	pop	bx
	pop	cx
	pop	dx
	pop	di
	pop	si
	pop	ds
	pop	es
	pop	bp
	iret

INT10_COM	ENDP




; PROCEDURE_NAME: INT2F_COM

; FUNCTION:
; THIS IS THE INTERRUPT 2FH HANDLER TO CAPTURE THE FOLLOWING FUNCTIONS:

;	ax=1A00H INSTALL REQUEST. ANSI WILL RETURN AL=FFH IF LOADED.

;	AH=1A01H THIS IS THE INT2FH INTERFACE TO THE GENERIC IOCTL.
;	NOTE: THE GET CHARACTERISTICS FUNCTION CALL WILL RETURN
;		THE REQ_TXT_LENGTH IN THE BUFFER AS OPPOSED TO
;		THE ACTUAL HARDWARE SCREEN_LENGTH
;	Ax=1A02h This is an information passing from DISPLAY.SYS about
;		the INT 10h, SET MODE call.

; AT ENTRY:

; AT EXIT:
;	NORMAL:

;	ERROR:



INT2F_COM	PROC	NEAR

	sti
	cmp	ah,multANSI			; is this for ANSI?
	jnz	ic_goto_rom
	cmp	al,DA_INFO_2F
	jle	INT2F_HANDLER

ic_goto_rom:
	jmp	DWORD PTR CS:ROM_INT2F		; no....jump to old INT2F

INT2F_HANDLER:

	cmp	al,INSTALL_CHECK
	jnz	ih_not_check

;	do install check

	mov	al,INSTALLED			; load value to indicate installed
	clc					; clear error flag.
	jmp	ih_iret

ih_not_check:
	cmp	al,DA_INFO_2F			; IOCTL or INFO passing?
	jbe	ih_valid
	jmp	ih_iret

ih_valid:
	push	bp
	push	ax				; s
	push	cx				; a
	push	dx				; v
	push	ds				; e	r
	push	es				;	e
	push	di				;	g
	push	si				;	s.
	push	bx
	push	ds				; load ES with DS (for call)
	pop	es
	mov	di,dx				; load DI with dx (for call)
	push	cs				; setup local addressability
	pop	ds

	cmp	al,IOCTL_2F			; IOCTL request
	jnz	ih_not_ioctl

	cmp	cl,GET_FUNC			; get function requested.
	jnz	ih_not_get

	call	GET_IOCTL

	jc	ih_set_flags			; if no error and
	cmp	HDWR_FLAG,E5151_ACTIVE		; >25 lines supported
	jl	ih_set_flags
	cmp	[si].D_MODE,TEXT_MODE		; this is a text mode then..
	jnz	ih_set_flags


;	cmp	SWITCH_L,1			; M002; No more /L
;	jz	ih_use_rtl			; M002; No more /L

	cmp	ANSI_SetMode_Call_Flag,1
	jnz	ih_use_rtl			; if not originated by ANSI thru AH=0, Int10
	cmp	Display_Loaded_Before_me,1	; or Display.sys not loaded before ANSI,
	jz	ih_get_ok

ih_use_rtl:
	mov	bx,REQ_TXT_LENGTH		; then use REQ_TXT_LENGTH instead..
ifdef JAPAN
	sub	bl,row_adj
endif
	mov	es:[di].RP_ROWS,bx

ih_get_ok:
	clc
	jmp	short ih_set_flags

ih_not_get:
	cmp	cl,SET_FUNC
	jnz	ih_invalid

	call	SET_IOCTL			; set function requested.

	jmp	short ih_set_flags

;	invalid function

ih_invalid:
	mov	ax,INVALID_FUNC			; load error and...
	stc 					; set error flag.
	jmp	short ih_set_flags		; Info. passing

ih_not_ioctl:
	cmp	es:[di].DA_INFO_LEVEL,0		; 0 - DA_SETMODE_FLAG request
	jnz	ih_not_info


	cmp	es:[di].DA_SETMODE_FLAG,1
	jnz	ih_not_set

	or	In_Generic_IOCTL_Flag, SET_MODE_BY_DISPLAY	;Turn the flag on
	jmp	short ih_info_ok

ih_not_set:
	and	In_Generic_IOCTL_Flag, not SET_MODE_BY_DISPLAY	;Turn the flag off

	jmp	short ih_info_ok

ih_not_info:

	cmp	es:[di].DA_INFO_LEVEL,1		; 1 = DA_L_STATA query
	jnz	ih_info_ok

;	mov	al,cs:[SWITCH_L]		; M002; No more /L
	mov	al,OFF				; M002; No more /L

	mov	es:[di].DA_L_STATE, al

ih_info_ok:
	clc					; clear carry. There is no Error in DOS 4.00 for this call.

ih_set_flags:
	pop	bx				; restore all..
	pop	si
	pop	di				;	registers except..
	pop	es
	pop	ds				;	BP.
	pop	dx
	pop	cx
	push	ax				; save error condition
	mov	bp,sp				; setup frame pointer
	mov	ax,[bp+10]			; load stack flags
	jc	ih_error			; carry set???

	and	ax,NOT_CY			; no.. set carry off.
	mov	[bp+10],ax			; put back on stack.
	pop	ax				; remove error flag from stack
	pop	ax				; no error so bring back function call
	XCHG	ah,al				; exchange to show that ANSI present
	jmp	short ih_pop_bp

ih_error:
	or	ax,CY				; yes...set carry on.
	mov	[bp+10],ax			; put back on stack.
	pop	ax				; restore error flag
	pop	bp				; pop off saved value of ax (destroyed)

ih_pop_bp:
	pop	bp				; restore final register.
ih_iret:
ABORT:	iret

INT2F_COM	ENDP




; PROCEDURE_NAME: MAP_DOWN

; FUNCTION:
; THIS PROCEDURE MAPS THE CURSOR START (END) POSITION FROM A 14 PEL
; BOX SIZE TO AN 8 PEL BOX SIZE.

; AT ENTRY: AL HAS THE CURSOR START (END) TO BE MAPPED.

; AT EXIT:
;	NORMAL: AL CONTAINS THE MAPPED POSITION FOR CURSOR START (END)

;	ERROR: N/A



MAP_DOWN	PROC	NEAR

	push	bx
	xor	ah,ah 			; clear upper byte of cursor position
	mov	bl,EIGHT		; multiply by current box size.
	push	dx			;	al	x
	mul	bl			;	---- = ---
	pop	dx			;	14	8
	mov	bl,FOURTEEN
	div	bl			; divide by box size expected.
	pop	bx
	ret

MAP_DOWN	ENDP




; PROCEDURE_NAME: SET_VIDEO_MODE

; FUNCTION:
; THIS PROCEDURE SETS THE VIDEO MODE SPECIFIED IN DS:[SI].V_MODE.

; AT ENTRY: DS:SI.V_MODE CONTAINS MODE NUMBER

; AT EXIT:
;	NORMAL: MODE SET

;	ERROR: N/A



SET_VIDEO_MODE PROC	NEAR

	test	In_Generic_IOCTL_Flag,CALLED_BY_INT10COM
	jnz	svm_done

	mov	al,[si].V_MODE			; ..issue set mode

	test	HDWR_FLAG,LCD_ACTIVE
	jnz	svm_update_bios			; is this the LCD?
	test	HDWR_FLAG,VGA_ACTIVE		; or VGA? (done for BRECON card)
	jz	svm_update_done

svm_update_bios:
	push	ds				; yes...
	mov	bl,al				; save mode
	mov	ax,ROM_BIOS
	mov	ds,ax				; get equipment status flag..
	mov	ax,ds:[EQUIP_FLAG]
	and	ax,INIT_VID_MASK		; clear initial video bits..

	cmp	bl,MODE7			; are we setting mono?
	jz	svm_mono
	cmp	bl,MODE15
	jnz	svm_color

svm_mono:
	or	ax,LCD_MONO_MODE		; yes...set bits as mono
	jmp	short svm_update_it

svm_color:
	or	ax,LCD_COLOR_MODE		; no...set bits as color

svm_update_it:
	mov	ds:[EQUIP_FLAG],ax	 	; replace updated flag.
	mov	al,bl			 	; restore mode.
	pop	ds

svm_update_done:
	mov	ah,SET_MODE			; set mode
	int	10H

svm_done:
	ret

SET_VIDEO_MODE	ENDP

CODE		ENDS
		END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\ansi\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

ansi.skl : ..\usa\ansi.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls437.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 437
;
; -----------------------------------------
;
Latin1_437_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db " ","!",'"',"#","$","%","&","'","(",")","*","+",",","-",".","/"
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db "0","1","2","3","4","5","6","7","8","9",":",";","<","=",">","?"
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db "@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db "P","Q","R","S","T","U","V","W","X","Y","Z","[","\","]","^","_"
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db "`","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db "P","Q","R","S","T","U","V","W","X","Y","Z","{","|","}","~",127
   ;                                               
  db "C","U","E","A","A","A","A","C","E","E","E","I","I","I","A","A"
   ;                                               
  db "E","A","A","O","O","O","U","U","Y","O","U","$","$","$","$","$"
   ;                                               
  db "A","I","O","U","N","N",166,167,"?",169,170,171,172,"!",'"','"'
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,"S",226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Dutch_437_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 128,154,144,065,142,065,143,128,069,069,069,073,073,073,142,143
   ;                                               
  db 144,146,146,079,079,079,085,085,152,079,085,155,156,157,158,159
   ;                                               
  db 065,073,079,085,165,165,166,167,168,169,170,171,172,173,174,175
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Spanish_437_collate label word
 ctable  <,'COLLATE',256>
  db 000,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164
  db 165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 000,060,061,062,063,064,065,000,066,067,068,069,070,000,071,072
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 034,035,036,037,038,039,040,041,042,043,073,074,075,076,077,078
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 079,001,002,003,006,008,009,010,011,012,013,014,015,017,018,020
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 021,022,023,024,026,028,029,030,031,032,033,080,081,082,083,084
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 085,001,002,003,006,008,009,010,011,012,013,014,015,017,018,020
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 021,022,023,024,026,028,029,030,031,032,033,086,087,088,089,090
   ;                                               
  db 004,028,008,001,001,001,001,004,008,008,008,012,012,012,001,001
   ;                                               
  db 008,001,001,020,020,020,028,028,032,020,028,091,092,093,094,095
   ;                                               
  db 001,012,020,028,019,019,001,020,096,097,098,099,100,101,102,103
   ;                                               
  db 104,105,106,107,108,181,182,183,184,109,110,111,112,185,186,113
   ;                                               
  db 114,115,116,117,118,119,187,188,120,121,122,123,124,125,126,189
   ;                                               
  db 190,191,192,193,194,195,196,197,198,127,128,129,130,199,200,131
   ;                                               
  db 201,025,202,203,204,205,132,206,207,208,209,210,211,212,213,214
   ;                                               
  db 215,133,216,217,218,219,134,220,221,222,000,223,224,135,136,225

;
;Spanish_437_collate label word
; ctable  <,'COLLATE',256>
;  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255 
;  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255 
;   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
;  db 001,009,023,045,039,046,044,022,026,027,042,047,006,005,014,013 
;   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
;  db 060,064,066,068,070,071,072,073,074,075,008,007,051,052,053,011 
;   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
;  db 036,077,094,096,104,108,118,120,122,124,134,136,138,144,146,150 
;   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
;  db 165,167,169,171,174,178,188,190,192,194,199,028,043,029,017,002 
;   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
;  db 016,076,093,095,103,107,117,119,121,123,133,135,137,143,145,149 
;   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
;  db 164,166,168,170,173,177,187,189,191,193,198,030,055,031,019,200 
;   ;                                               
;  db 098,185,109,083,087,081,085,097,113,115,111,131,129,127,088,086
;   ;                                               
;  db 110,091,092,156,158,154,183,181,197,158,186,038,040,041,039,200
;   ;                                               
;  db 079,125,152,179,147,148,078,151,012,200,054,062,061,010,024,025
;   ;                                               
;  db 240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240
;   ;                                               
;  db 240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240
;   ;                                               
;  db 240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240
;   ;                                               
;  db 201,172,202,203,204,205,058,206,207,208,209,210,211,212,213,214
;   ;                                               
;  db 215,048,216,217,218,219,049,220,057,020,020,223,224,067,240,255
;

Swed_Fin_437_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,089,069,065,092,065,091,067,069,069,069,073,073,073,092,091
   ;                                               
  db 069,092,092,079,093,079,085,085,089,093,089,036,036,036,036,036
   ;                                               
  db 065,073,079,085,078,078,166,167,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Swiss_437_collate label word
 ctable  <,'COLLATE',256>
  db 001,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214
  db 215,216,217,218,140,141,219,220,221,222,223,224,225,226,227,228
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 001,060,061,062,063,064,065,066,067,068,069,070,071,072,073,074
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 032,033,034,035,036,037,038,039,040,041,075,076,077,078,079,080
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 081,002,003,004,005,007,008,009,010,011,012,013,014,015,016,018
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 019,020,021,022,024,026,027,028,029,030,031,082,083,084,052,085
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 051,002,003,004,005,007,008,009,010,011,012,013,014,015,016,018
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 019,020,021,022,024,026,027,028,029,030,031,086,087,088,054,089
   ;                                               
  db 004,026,007,002,002,002,002,004,007,007,007,011,011,011,002,002
   ;                                               
  db 007,002,002,018,018,018,026,026,030,018,026,111,090,112,150,092
   ;                                               
  db 002,011,018,026,017,017,002,018,093,151,095,096,097,098,099,100
   ;                                               
  db 101,102,103,104,105,152,153,154,155,107,108,109,110,156,157,113
   ;                                               
  db 114,115,116,117,118,119,158,159,120,121,122,123,124,125,126,160
   ;                                               
  db 161,162,163,164,165,166,167,168,169,128,129,130,131,170,171,133
   ;                                               
  db 172,023,173,174,175,176,134,177,178,179,180,181,182,183,184,185
   ;                                               
  db 186,137,187,188,189,190,142,191,143,192,144,193,194,147,148,001


Belgian_437_collate label word
 ctable  <,'COLLATE',256>
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 255,033,034,035,036,037,038,255,040,041,042,043,044,255,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,065,065,065,067,069,069,069,073,073,073,065,065
   ;                                               
  db 069,065,065,079,079,079,085,085,089,079,085,155,156,157,158,159
   ;                                               
  db 065,073,079,085,078,078,166,167,168,169,170,171,172,173,174,175
   ;                                               
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
   ;                                               
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
   ;                                               
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,255,255


;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 437
;
; ---------------------------------------------------------------
;
Latin1_437_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","E","A","","A","","","E","E","E","I","I","I","",""
   ;                                               
  db "","","","O","","O","U","U","Y","","","","","","",""
   ;                                               
  db "A","I","O","U","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255


Swed_Fin_437_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","A","","A","","","E","E","E","I","I","I","",""
   ;                                               
  db "","","","O","","O","U","U","Y","","","","","","",""
   ;                                               
  db "A","I","O","U","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255


Swiss_437_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","A","","A","","","E","E","E","I","I","I","",""
   ;                                               
  db "","","","O","","O","U","U","Y","","","","","","",""
   ;                                               
  db "A","I","O","U","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255


Dutch_437_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","U","E","A","A","A","","","E","E","E","I","I","I","A",""
   ;                                               
  db "E","","","O","O","O","U","U","","O","U","","","","",""
   ;                                               
  db "A","I","O","U","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255


;
;       World Trade Mono Case Filename Character Tables
;
;
; ----------------------------------------------------------------------------
CP437_ucfile label word
 ctable  <,'FUCASE ',128>
		      ;  View this table in CP437
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\dbcs93x.inc ===
; ----------------------------------------------------------------------------
;
;       World Trade DBCS Tables for Code Pages 932, 949, 936, and 938
;
; ----------------------------------------------------------------------------
;

;
;    Japan DBCS lead byte table
;
jp932_dbcs      label   word                          
		ctable  <,'DBCS   ',db932end-db932bgn>
db932bgn        label   word                          
		db      081h,09Fh                     
		db      0E0h,0FCh                     
db932term       db      000h,000h                     
db932end        equ     $
                                                      
;
;    Korea DBCS lead byte table
;
ko949_dbcs      label   word                          
		ctable  <,'DBCS   ',db949end-db949bgn>
db949bgn        label   word                          
		db      081h,0FEh                     
db949term       db      000h,000h                     
db949end        equ     $


ko1361_dbcs      label   word                          
		ctable  <,'DBCS   ',db1361end-db1361bgn>
db1361bgn        label   word                          
		db      084h,0d3h                     
		db      0d8h,0deh                     
		db      0e0h,0f9h                     
db1361ter       db      000h,000h                     
db1361end        equ     $

;
;    PRC DBCS lead byte table
;
pr936_dbcs      label   word                          
		ctable  <,'DBCS   ',db936end-db936bgn>
db936bgn        label   word                          
		db      0A1h,0FEh                     
db936term       db      000h,000h                     
db936end        equ     $

;
;    Taiwan DBCS lead byte table
;
ta938_dbcs      label   word                          
		ctable  <,'DBCS   ',ta938end-ta938bgn>
ta938bgn        label   word                          
		db      081h,0FEh                     
ta938term       db      000h,000h                     
ta938end        equ     $
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls852.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 852
;
; -----------------------------------------
;
Latin2_852_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 100,101,102,103,104,105,106,107,108,109,126,127,128,129,130,131
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 132,033,039,040,044,047,052,053,054,055,058,059,060,064,065,068
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 073,074,075,078,083,086,091,092,093,094,096,133,134,135,136,137
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 138,033,039,040,044,047,052,053,054,055,058,059,060,064,065,068
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 073,074,075,078,083,086,091,092,093,094,096,139,140,141,142,032
   ;                                               
  db 043,089,048,038,035,088,041,043,063,051,072,072,057,098,035,041
   ;                                               
  db 048,061,061,070,071,062,062,082,082,071,089,084,084,063,143,042
   ;                                               
  db 034,056,069,087,036,036,097,097,050,050,144,098,042,081,145,146
   ;                                               
  db 151,152,153,154,155,034,038,049,081,156,157,158,159,099,099,160
   ;                                               
  db 161,162,163,164,165,166,037,037,167,168,169,170,171,172,173,147
   ;                                               
  db 045,045,046,051,046,066,056,057,049,174,175,176,177,085,088,178
   ;                                               
  db 069,079,070,067,067,066,080,080,076,087,076,090,095,095,085,180
   ;                                               
  db 148,181,182,183,184,149,150,185,186,187,188,090,077,077,179,255


;
;Latin2_852_collate label word
; ctable  <,'COLLATE',256>
;  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
;  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
;   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
;  db 001,008,025,039,035,040,038,024,026,027,036,041,005,004,011,010
;   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
;  db 049,050,051,052,053,054,055,056,057,058,007,006,044,045,046,009
;   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
;  db 033,060,072,074,082,088,098,100,102,104,110,112,114,122,124,130
;   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
;  db 140,142,144,150,159,165,175,177,179,181,185,028,037,029,015,002
;   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
;  db 013,059,071,073,081,087,097,099,101,103,109,111,113,121,123,129
;   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
;  db 139,141,143,149,158,164,174,176,178,180,184,030,047,031,020,200
;   ;                                               
;  db 080,170,089,065,067,168,075,079,119,093,138,137,107,187,068,076
;   ;                                               
;  db 090,116,115,133,135,118,117,152,151,136,171,161,160,120,043,077
;   ;                                               
;  db 061,105,131,166,070,069,189,188,096,095,000,186,078,155,030,031
;   ;                                               
;  db 240,240,240,240,240,062,066,092,156,240,240,240,240,191,190,240
;   ;                                               
;  db 240,240,240,240,240,240,064,063,240,240,240,240,240,240,240,034
;   ;                                               
;  db 085,086,084,094,083,128,106,108,091,240,240,240,240,163,169,240
;   ;                                               
;  db 132,157,134,126,125,127,154,153,146,167,145,173,182,183,162,012
;   ;                                               
;  db 004,019,023,016,014,032,042,022,017,018,021,172,148,147,240,255
;

;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 852
;
; ---------------------------------------------------------------
;
Latin2_852_ucase label word
 ctable  <,'UCASE  ',128>
  ;                            x
  db 080h,09Ah,090h,0B6h,08Eh,0DEh,08Fh,080h,09Dh,0D3h,08Ah,08Ah,0D7h,08Dh,08Eh,08Fh
  ;              x                  x                              x
  db 090h,091h,092h,0E2h,099h,095h,05Fh,097h,097h,099h,09Ah,09Bh,09Bh,09Dh,09Eh,0ACh
  db 0B5h,092h,0E0h,0E9h,0A4h,0A4h,0A6h,0A6h,0A8h,0A8h,0AAh,08Dh,0ACh,0B8h,0AEh,0AFh
  db 0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BDh,0BFh
  db 0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C6h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
  db 0D1h,0D1h,0D2h,0D3h,0D2h,0D5h,0D6h,0D7h,0B7h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
  db 0E0h,0E1h,0E2h,0E3h,0E3h,0D5h,0E6h,0E6h,0E8h,0E9h,0E8h,0EBh,0EDh,0EDh,0DDh,0EFh
  db 0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0EBh,0FCh,0FCh,0FEh,0FFh

;
;       World Trade Mono Case Filename Character Tables
;
;
; ----------------------------------------------------------------------------
CP852_ucfile label word
 ctable  <,'FUCASE ',128>
		      ;  View this table in CP852
    ;                                               
  db  "","","","","","","","","","","","","","","",""
    ;                                                   
  db  "","","","","","","","","","","","","","","",""
    ;                                               
  db  "","","","","","","","","","","","","","","",""
    ;                                               
  db  176,177,178,179,180,"","","","",185,186,187,188,"","",191
    ;                                               
  db  192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
    ;                                               
  db  "","","","","","","","","",217,218,219,220,"","",223
    ;                                               
  db  "","","","","","","","","","","","","","","",""
    ;                                               
  db  "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls737.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 737
;
; -----------------------------------------
;
Greek_737_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 001,015,044,084,072,085,082,043,050,052,079,089,010,009,022,021
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 112,114,115,117,119,120,121,123,124,125,014,012,097,100,103,018
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 069,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 226,228,230,232,234,236,238,240,242,244,246,054,081,055,027,003
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 042,197,199,201,203,205,207,209,211,213,215,217,219,221,223,225
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 227,229,231,233,235,237,239,241,243,245,247,056,105,057,033,063
   ;                                               
  db 126,131,133,135,137,141,143,147,149,156,158,160,162,164,168,170
   ;                                               
  db 172,174,177,179,186,188,190,192,127,132,134,136,138,142,144,148
   ;                                               
  db 150,157,159,161,163,165,167,171,173,175,176,178,180,187,189,191
   ;                                               
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;                                               
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;                                               
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;                                               
  db 193,130,140,146,154,152,169,182,184,195,128,139,145,151,181,168
   ;                                            
  db 194,091,096,102,153,183,080,099,045,036,037,088,248,116,254,255


;
; ---------------------------------------------------------------
;
;      World Trade Case Mappings for Code Page 737
;
; ---------------------------------------------------------------
;
Greek_737_ucase label word
 ctable  <,'UCASE  ',128>

;                                                                 
  db 080h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
;                                                                 
  db 090h,091h,092h,093h,094h,095h,096h,097h,080h,081h,082h,083h,084h,085h,086h,087h
;                                                                 
  db 088h,089h,08ah,08bh,08ch,08dh,08eh,08fh,090h,091h,05fh,092h,093h,094h,095h,096h
;                                                                 
  db 0b0h,0b1h,0b2h,0b3h,0b4h,0b5h,0b6h,0b7h,0b8h,0b9h,0bah,0bbh,0bch,0bdh,0beh,0bfh
;                                                                 
  db 0c0h,0c1h,0c2h,0c3h,0c4h,0c5h,0c6h,0c7h,0c8h,0c9h,0cah,0cbh,0cch,0cdh,0ceh,0cfh
;                                                                 
  db 0d0h,0d1h,0d2h,0d3h,0d4h,0d5h,0d6h,0d7h,0d8h,0d9h,0dah,0dbh,0dch,0ddh,0deh,0dfh
;                                                                 
  db 097h,0eah,05fh,0ech,0f4h,0edh,0eeh,0efh,0f5h,0f0h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
;                                                             
  db 0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls850.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 850
;
; -----------------------------------------
;
Latin1_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,065,065,065,067,069,069,069,073,073,073,065,065
   ;                                               
  db 069,065,065,079,079,079,085,085,089,079,085,079,036,079,158,036
   ;                                               
  db 065,073,079,085,078,078,166,167,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,065,065,065,184,185,186,187,188,036,036,191
   ;                                               
  db 192,193,194,195,196,197,065,065,200,201,202,203,204,205,206,036
   ;                                               
  db 068,068,069,069,069,073,073,073,073,217,218,219,220,221,073,223
   ;                                               
  db 079,083,079,079,079,079,230,232,232,085,085,085,089,089,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Latin2_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,067,068,069,071,073,074,075,076,078,079,080,081,082,083
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 085,086,087,088,089,090,092,093,094,095,097,040,047,041,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,067,068,069,071,073,074,075,076,078,079,080,081,082,083
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 085,086,087,088,089,090,092,093,094,095,097,040,047,041,126,127
   ;                                               
  db 068,091,072,066,066,066,066,068,072,072,072,077,077,077,066,066
   ;                                               
  db 072,099,099,084,100,084,091,091,096,100,091,084,036,084,158,036
   ;                                               
  db 066,077,084,091,082,082,065,084,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,066,066,066,184,185,186,187,188,036,036,191
   ;                                               
  db 192,193,194,195,196,197,066,066,200,201,202,203,204,205,206,036
   ;                                               
  db 070,070,072,072,072,076,077,077,077,217,218,219,220,221,077,223
   ;                                               
  db 084,067,084,084,084,084,230,098,098,091,091,091,096,096,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


;
;Latin2_850_collate label word
; ctable  <,'COLLATE',256>
;  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
;  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
;   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
;  db 001,008,025,039,035,040,038,024,026,027,036,041,005,004,011,010
;   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
;  db 049,050,051,052,053,054,055,056,057,058,007,006,044,045,046,009
;   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
;  db 033,060,072,074,082,088,098,100,102,104,110,112,114,122,124,130
;   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
;  db 140,142,144,150,159,165,175,177,179,181,185,028,037,029,015,002
;   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
;  db 013,059,071,073,081,087,097,099,101,103,109,111,113,121,123,129
;   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
;  db 139,141,143,149,158,164,174,176,178,180,184,030,047,031,020,198
;   ;                                               
;  db 080,170,089,065,067,201,201,079,202,093,202,203,107,203,068,201
;   ;                                               
;  db 090,201,201,133,135,205,207,207,208,136,171,205,035,205,199,199
;   ;                                               
;  db 061,105,131,166,204,204,201,205,199,199,199,200,200,199,030,031
;   ;                                               
;  db 240,240,240,240,240,062,066,201,199,240,240,240,240,035,035,240
;   ;                                               
;  db 240,240,240,240,240,240,201,201,240,240,240,240,240,240,240,034
;   ;                                               
;  db 085,086,202,094,202,203,106,108,203,240,240,240,240,047,203,240
;   ;                                               
;  db 132,157,134,205,205,205,199,206,206,166,207,207,182,183,199,012
;   ;                                            
;  db 004,199,199,200,199,032,042,022,017,018,199,200,200,200,240,255
;

Dutch_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,065,065,143,067,069,069,069,073,073,073,065,143
   ;                                               
  db 069,146,146,079,079,079,085,085,152,079,085,079,156,079,158,159
   ;                                               
  db 065,073,079,085,165,165,166,167,168,169,170,171,172,173,174,175
   ;                                               
  db 176,177,178,179,180,065,065,065,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,065,065,200,201,202,203,204,205,206,207
   ;                                               
  db 209,209,069,069,069,073,073,073,073,217,218,219,220,221,073,223
   ;                                               
  db 079,225,079,079,079,079,230,232,232,085,085,085,089,089,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Danish_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,040,047,041,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,040,047,041,126,127
   ;                                               
  db 067,089,069,065,091,065,093,067,069,069,069,073,073,073,091,093
   ;                                               
  db 069,091,091,079,092,079,085,085,089,092,089,092,036,092,158,036
   ;                                               
  db 065,073,079,085,078,078,065,079,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,065,065,065,184,185,186,187,188,036,036,191
   ;                                               
  db 192,193,194,195,196,197,065,065,200,201,202,203,204,205,206,036
   ;                                               
  db 068,068,069,069,069,073,073,073,073,217,218,219,220,221,073,223
   ;                                               
  db 079,083,079,079,079,079,230,080,080,085,085,085,089,089,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Norwegian_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,091,065,093,067,069,069,069,073,073,073,091,093
   ;                                               
  db 069,091,091,079,092,079,085,085,089,092,089,092,036,092,158,036
   ;                                               
  db 065,073,079,085,078,078,065,079,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,065,065,065,184,185,186,187,188,036,036,191
   ;                                               
  db 192,193,194,195,196,197,065,065,200,201,202,203,204,205,206,036
   ;                                               
  db 068,068,069,069,069,073,073,073,073,217,218,219,220,221,073,223
   ;                                               
  db 079,083,079,079,079,079,230,080,080,085,085,085,089,089,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Finnish_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,089,069,065,092,065,091,067,069,069,069,073,073,073,092,091
   ;                                               
  db 069,092,092,079,093,079,085,085,089,093,089,093,036,093,158,036
   ;                                               
  db 065,073,079,085,078,078,166,167,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,065,065,065,184,185,186,187,188,036,036,191
   ;                                               
  db 192,193,194,195,196,197,065,065,200,201,202,203,204,205,206,036
   ;                                               
  db 068,068,069,069,069,073,073,073,073,217,218,219,220,221,073,223
   ;                                               
  db 079,083,079,079,079,079,230,232,232,085,085,085,089,089,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Swedish_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,089,069,065,092,065,091,067,069,069,069,073,073,073,092,091
   ;                                               
  db 069,092,092,079,093,079,085,085,089,093,089,093,036,093,158,036
   ;                                               
  db 065,073,079,085,078,078,166,167,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,065,065,065,184,185,186,187,188,036,036,191
   ;                                               
  db 192,193,194,195,196,197,065,065,200,201,202,203,204,205,206,036
   ;                                               
  db 068,068,069,069,069,073,073,073,073,217,218,219,220,221,073,223
   ;                                               
  db 079,083,079,079,093,093,230,232,232,085,085,085,089,089,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Swiss_850_collate label word
 ctable  <,'COLLATE',256>
  db 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 000,165,168,133,185,134,135,169,170,171,136,158,172,174,175,176
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 117,118,120,122,124,125,126,127,128,129,177,178,160,161,162,179
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 137,002,018,020,024,028,038,040,042,044,055,057,059,061,063,067
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 081,083,085,087,090,094,104,106,108,110,115,138,139,140,191,173
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 190,003,019,021,025,029,039,041,043,056,045,058,060,062,064,068
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 082,084,086,088,091,095,105,107,109,111,116,142,143,144,193,157
   ;                                               
  db 022,103,031,009,011,007,015,023,035,037,033,053,051,049,010,014
   ;                                               
  db 030,017,016,074,076,072,101,099,114,075,102,080,184,079,164,188
   ;                                               
  db 005,047,070,097,066,065,149,148,180,154,156,131,130,166,181,182
   ;                                               
  db 207,208,209,206,204,004,008,006,153,210,211,212,213,186,187,198
   ;                                               
  db 197,202,201,203,205,200,013,012,214,215,216,217,218,219,220,183
   ;                                               
  db 027,026,034,036,032,054,046,050,052,199,196,223,221,155,048,222
   ;                                               
  db 069,089,073,071,078,077,146,092,093,096,100,098,113,112,145,189
   ;                                            
  db 167,159,141,132,151,150,163,194,147,192,195,119,123,121,152,001


Belgian_850_collate label word
 ctable  <,'COLLATE',256>
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 255,033,034,035,036,037,038,255,040,041,042,043,044,255,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,065,065,065,067,069,069,069,073,073,073,065,065
   ;                                               
  db 069,065,065,079,079,079,085,085,089,079,085,079,156,079,158,159
   ;                                               
  db 065,073,079,085,078,164,166,167,168,169,170,171,172,173,174,175
   ;                                               
  db 255,255,255,255,255,065,065,065,184,255,255,255,255,189,190,255
   ;                                               
  db 255,255,255,255,255,255,065,065,255,255,255,255,255,255,255,207
   ;                                               
  db 068,068,069,069,069,073,073,073,073,255,255,255,255,221,073,255
   ;                                               
  db 079,083,079,079,079,079,230,084,084,085,085,085,089,089,238,239
   ;                                            
  db 255,241,242,243,244,245,246,247,248,249,250,251,252,253,255,255


Spanish_850_collate label word
 ctable  <,'COLLATE',256>
  db 000,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164
  db 165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 000,060,061,062,063,064,065,000,066,067,068,069,070,000,071,072
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 034,035,036,037,038,039,040,041,042,043,073,074,075,076,077,078
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 079,001,002,003,006,008,009,010,011,012,013,014,015,017,018,020
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 021,022,023,024,026,028,029,030,031,032,033,080,081,082,083,084
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 085,001,002,003,006,008,009,010,011,012,013,014,015,017,018,020
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 021,022,023,024,026,028,029,030,031,032,033,086,087,088,089,090
   ;                                               
  db 004,028,008,001,001,001,001,004,008,008,008,012,012,012,001,001
   ;                                               
  db 008,001,001,020,020,020,028,028,032,020,028,020,092,020,094,095
   ;                                               
  db 001,012,020,028,019,019,001,020,096,097,098,099,100,101,102,103
   ;                                               
  db 104,105,106,107,108,001,001,001,184,109,110,001,001,091,093,113
   ;                                               
  db 114,115,116,117,118,119,187,188,120,121,122,123,124,125,126,189
   ;                                               
  db 007,007,008,008,008,012,012,012,012,127,128,129,130,199,012,131
   ;                                               
  db 020,025,020,020,020,020,132,027,027,028,028,028,032,032,213,214
   ;                                            
  db 000,133,216,217,218,219,134,220,221,222,000,223,224,135,136,225


;
;Spanish_850_collate label word
; ctable  <,'COLLATE',256>
;  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
;  db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
;   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
;  db 001,009,023,045,039,046,044,022,026,027,042,047,006,005,014,013
;   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
;  db 060,064,066,068,070,071,072,073,074,075,008,007,051,052,053,011
;   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
;  db 036,077,094,096,104,108,118,120,122,124,134,136,138,144,146,150
;   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
;  db 165,167,169,171,174,178,188,190,192,194,199,028,043,029,017,002
;   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
;  db 016,076,093,095,103,107,117,119,121,123,133,135,137,143,145,149
;   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
;  db 164,166,168,170,173,177,187,189,191,193,198,030,055,031,019,200
;   ;                                               
;  db 098,185,109,083,087,081,085,097,113,115,111,131,129,127,088,086
;   ;                                               
;  db 110,091,092,156,158,154,183,181,197,159,186,162,040,163,050,200
;   ;                                               
;  db 079,125,152,179,147,148,078,151,012,035,054,062,061,010,024,025
;   ;                                               
;  db 254,254,254,254,254,080,084,082,034,254,254,254,254,038,041,254
;   ;                                               
;  db 254,254,254,254,254,254,089,090,254,254,254,254,254,254,254,037
;   ;                                               
;  db 105,106,114,116,112,200,126,130,132,254,254,254,254,056,128,254
;   ;                                               
;  db 153,172,157,155,160,161,058,175,176,180,184,182,195,196,003,015
;   ;                                            
;  db 005,048,201,063,033,032,049,021,057,018,020,065,069,067,254,255
;

Turkish_850_collate label word
 ctable  <,'COLLATE',256>
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 000,009,023,045,039,046,044,022,026,027,042,047,006,005,014,013
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 060,064,066,068,070,071,072,073,074,075,008,007,051,052,053,011
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 036,077,094,096,100,102,112,114,118,120,132,134,136,138,140,144
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 159,161,163,165,170,172,182,184,186,188,191,028,043,029,017,002
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 016,076,093,095,099,101,111,113,117,121,131,133,135,137,139,143
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 158,160,162,164,169,171,181,183,185,187,190,030,055,031,019,192
   ;                                               
  db 098,179,103,083,087,081,085,097,107,109,105,129,127,125,088,086
   ;                                               
  db 104,091,092,151,156,148,177,175,189,157,180,154,040,155,050,192
   ;                                               
  db 079,123,146,173,141,142,078,145,012,035,054,062,061,010,024,025
   ;                                               
  db 240,240,240,240,240,080,084,082,034,240,240,240,240,038,040,240
   ;                                               
  db 240,240,240,240,240,240,089,090,240,240,240,240,240,240,240,037
   ;                                               
  db 193,193,108,110,106,119,124,128,130,240,240,240,240,056,125,240
   ;                                               
  db 147,166,151,149,152,153,058,193,193,174,178,176,193,193,003,015
   ;                                            
  db 005,048,193,063,033,032,049,021,057,018,020,065,069,067,240,255


;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for 850
;
; ---------------------------------------------------------------
;
Latin1_850_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


German_850_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Spanish_850_ucase label word
Swed_Fin_850_ucase label word
Nordic_850_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Swiss_850_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Dutch_850_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Latin2_850_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Brazilian_850_ucase label word
 ctable      <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255

Turkish_850_ucase label word
 ctable      <,'UCASE  ',128>
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255

;
;       World Trade Mono Case Filename Character Tables
;
;
; ----------------------------------------------------------------------------
CP850_ucfile label word
 ctable  <,'FUCASE ',128>
		      ;  View this table in CP850
   ;                                                      
  db 080h,9ah,90h,0b6h,8eh,0b7h,8fh,80h,0d2h,0d3h,0d4h,0d8h,0d7h,0deh,08eh,8fh
   ;                                                   
  db 090h,092h,092h,0e2h,099h,0e3h,0eah,0ebh,05fh,099h,09ah,09dh,09ch,09dh,09eh,09fh
   ;                                                     
  db 0b5h,0d6h,0e0h,0e9h,0a5h,0a5h,"","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,199,199,200,201,202,203,204,205,206,207
   ;                                               
  db 0d1h,0d1h,210,211,212,"I",214,215,216,217,218,219,220,"",222,223
   ;                                               
  db 224,225,226,227,229,229,230,232,232,233,234,235,237,237,238,239
   ;                                            
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\country.asm ===
;
;       create country.sys file
;
;
        include mkcntry.inc
;
; -----------------------------------------------------------
;
;       Data for COUNTRY.SYS file
;
; -----------------------------------------------------------
dseg    segment para
cdinfo  label   word
        db      0ffh,'COUNTRY'          ; signature
        db      8 dup (0)               ; reserved
        dw      PTRCNT                  ; number of pointers in header
        db      CIPTYPE                 ; type = country info pointer
        dd      offset cntryinfo        ; pointer to country information
;
cntryinfo label word
cntrycnt=0
        dw      finalCNT                ; number of countries

 ctryent <CENTRYSIZE,CID_AL,852,,,al852_data>   ; Albania
 ctryent <CENTRYSIZE,CID_AL,850,,,al850_data>   ;

 ctryent <CENTRYSIZE,CID_AR,850,,,ar850_data>   ; Argentina
 ctryent <CENTRYSIZE,CID_AR,437,,,ar437_data>   ;

 ctryent <CENTRYSIZE,CID_AU,437,,,au437_data>   ; Australia
 ctryent <CENTRYSIZE,CID_AU,850,,,au850_data>   ;

 ctryent <CENTRYSIZE,CID_AT,850,,,at850_data>   ; Austria
 ctryent <CENTRYSIZE,CID_AT,437,,,at437_data>   ;

 ctryent <CENTRYSIZE,CID_BE,850,,,be850_data>   ; Belgium
 ctryent <CENTRYSIZE,CID_BE,437,,,be437_data>   ;

 ctryent <CENTRYSIZE,CID_BH,852,,,bh852_data>   ; Bosnia/Herzegovina
 ctryent <CENTRYSIZE,CID_BH,850,,,bh850_data>   ;

 ctryent <CENTRYSIZE,CID_BR,850,,,br850_data>   ; Brazil
 ctryent <CENTRYSIZE,CID_BR,437,,,br437_data>   ;

 ctryent <CENTRYSIZE,CID_BG,855,,,bg855_data>   ; Bulgaria IBM Country Code
 ctryent <CENTRYSIZE,CID_BG,850,,,bg850_data>   ;

 ctryent <CENTRYSIZE,CID_BGI,855,,,bgi855_data> ; Bulgaria Real Country Code
 ctryent <CENTRYSIZE,CID_BGI,850,,,bgi850_data> ;

 ctryent <CENTRYSIZE,CID_CA,850,,,ca850_data>   ; Canada French
 ctryent <CENTRYSIZE,CID_CA,863,,,ca863_data>   ; 

 ctryent <CENTRYSIZE,CID_CAE,850,,,cae850_data> ; Canada English
 ctryent <CENTRYSIZE,CID_CAE,863,,,cae863_data> ; 

 ctryent <CENTRYSIZE,CID_CL,850,,,cl850_data>   ; Chile
 ctryent <CENTRYSIZE,CID_CL,437,,,cl437_data>   ;

 ctryent <CENTRYSIZE,CID_CO,850,,,co850_data>   ; Colombia
 ctryent <CENTRYSIZE,CID_CO,437,,,co437_data>   ;

 ctryent <CENTRYSIZE,CID_CRO,852,,,cro852_data> ; Croatia
 ctryent <CENTRYSIZE,CID_CRO,850,,,cro850_data> ;

 ctryent <CENTRYSIZE,CID_CS,852,,,cs852_data>   ; Czech Republic
 ctryent <CENTRYSIZE,CID_CS,850,,,cs850_data>   ;

 ctryent <CENTRYSIZE,CID_EC,850,,,ec850_data>   ; Ecuador
 ctryent <CENTRYSIZE,CID_EC,437,,,ec437_data>   ;

 ctryent <CENTRYSIZE,CID_DK,850,,,dk850_data>   ; Denmark
 ctryent <CENTRYSIZE,CID_DK,865,,,dk865_data>   ;

 ctryent <CENTRYSIZE,CID_FI,850,,,fi850_data>   ; Finland 
 ctryent <CENTRYSIZE,CID_FI,437,,,fi437_data>   ;

 ctryent <CENTRYSIZE,CID_FR,850,,,fr850_data>   ; France
 ctryent <CENTRYSIZE,CID_FR,437,,,fr437_data>   ; 

 ctryent <CENTRYSIZE,CID_GR,850,,,gr850_data>   ; Germany
 ctryent <CENTRYSIZE,CID_GR,437,,,gr437_data>   ; 

 ctryent <CENTRYSIZE,CID_GK,869,,,gk869_data>   ; Greece
 ctryent <CENTRYSIZE,CID_GK,737,,,gk737_data>   ; 
 ctryent <CENTRYSIZE,CID_GK,850,,,gk850_data>   ;

 ctryent <CENTRYSIZE,CID_HK,437,,,hk437_data>   ; Hong Kong SAR

 ctryent <CENTRYSIZE,CID_HU,852,,,hu852_data>   ; Hungary
 ctryent <CENTRYSIZE,CID_HU,850,,,hu850_data>   ;

 ctryent <CENTRYSIZE,CID_IC,850,,,ic850_data>   ; Iceland
 ctryent <CENTRYSIZE,CID_IC,861,,,ic861_data>   ; 

 ctryent <CENTRYSIZE,CID_IN,437,,,in437_data>   ; Indea

 ctryent <CENTRYSIZE,CID_AFE,437,,,afe437_data> ; International English
 ctryent <CENTRYSIZE,CID_AFE,850,,,afe850_data> ;

 ctryent <CENTRYSIZE,CID_IT,850,,,it850_data>   ; Italy
 ctryent <CENTRYSIZE,CID_IT,437,,,it437_data>   ; 

 ctryent <CENTRYSIZE,CID_IE,850,,,ie850_data>   ; Ireland
 ctryent <CENTRYSIZE,CID_IE,437,,,ie437_data>   ;

 ctryent <CENTRYSIZE,CID_LA,850,,,la850_data>   ; Latin America
 ctryent <CENTRYSIZE,CID_LA,437,,,la437_data>   ;

 ctryent <CENTRYSIZE,CID_MAC,855,,,mac855_data> ; FYRO former yugoslav republic of Macedonio
 ctryent <CENTRYSIZE,CID_MAC,850,,,mac850_data> ;

 ctryent <CENTRYSIZE,CID_MY,437,,,my437_data>   ; Malaysia

 ctryent <CENTRYSIZE,CID_MX,850,,,mx850_data>   ; Mexico
 ctryent <CENTRYSIZE,CID_MX,437,,,mx437_data>   ;

 ctryent <CENTRYSIZE,CID_NL,850,,,nl850_data>   ; Netherlands
 ctryent <CENTRYSIZE,CID_NL,437,,,nl437_data>   ; 

 ctryent <CENTRYSIZE,CID_NZ,437,,,nz437_data>   ; New Zealand
 ctryent <CENTRYSIZE,CID_NZ,850,,,nz850_data>   ;

 ctryent <CENTRYSIZE,CID_NO,850,,,no850_data>   ; Norway
 ctryent <CENTRYSIZE,CID_NO,865,,,no865_data>   ;

 ctryent <CENTRYSIZE,CID_PL,852,,,pl852_data>   ; Poland
 ctryent <CENTRYSIZE,CID_PL,850,,,pl850_data>   ;

 ctryent <CENTRYSIZE,CID_PO,850,,,po850_data>   ; Portugal
 ctryent <CENTRYSIZE,CID_PO,860,,,po860_data>   ;

 ctryent <CENTRYSIZE,CID_RO,852,,,ro852_data>   ; Romania
 ctryent <CENTRYSIZE,CID_RO,850,,,ro850_data>   ;

 ctryent <CENTRYSIZE,CID_RU,866,,,ru866_data>   ; Russia
 ctryent <CENTRYSIZE,CID_RU,437,,,ru437_data>   ; 
 ctryent <CENTRYSIZE,CID_RU,850,,,ru850_data>   ; 
 ctryent <CENTRYSIZE,CID_RU,855,,,ru855_data>   ; 
 ctryent <CENTRYSIZE,CID_RU,852,,,ru852_data>   ;

 ctryent <CENTRYSIZE,CID_SM,855,,,sm855_data>   ; Serbia/Montenegro
 ctryent <CENTRYSIZE,CID_SM,850,,,sm850_data>   ;

 ctryent <CENTRYSIZE,CID_SG,437,,,sg437_data>   ; Singapore

 ctryent <CENTRYSIZE,CID_SL,852,,,sl852_data>   ; Slovakia
 ctryent <CENTRYSIZE,CID_SL,850,,,sl850_data>   ;

 ctryent <CENTRYSIZE,CID_SLN,852,,,sln852_data> ; Slovenia
 ctryent <CENTRYSIZE,CID_SLN,850,,,sln850_data> ;

 ctryent <CENTRYSIZE,CID_ZA,437,,,za437_data>   ; South Africa
 ctryent <CENTRYSIZE,CID_ZA,850,,,za850_data>   ;

 ctryent <CENTRYSIZE,CID_SP,850,,,sp850_data>   ; Spain
 ctryent <CENTRYSIZE,CID_SP,437,,,sp437_data>   ;

 ctryent <CENTRYSIZE,CID_SV,850,,,sv850_data>   ; Sweden
 ctryent <CENTRYSIZE,CID_SV,437,,,sv437_data>   ; 

 ctryent <CENTRYSIZE,CID_SW,850,,,sw850_data>   ; Switzerland
 ctryent <CENTRYSIZE,CID_SW,437,,,sw437_data>   ;

 ctryent <CENTRYSIZE,CID_TR,857,,,tr857_data>   ; Turkey
 ctryent <CENTRYSIZE,CID_TR,850,,,tr850_data>   ; 

 ctryent <CENTRYSIZE,CID_UK,850,,,uk850_data>   ; United Kingdom
 ctryent <CENTRYSIZE,CID_UK,437,,,uk437_data>   ; 

 ctryent <CENTRYSIZE,CID_US,437,,,us437_data>   ; United States
 ctryent <CENTRYSIZE,CID_US,850,,,us850_data>   ;

 ctryent <CENTRYSIZE,CID_VE,850,,,ve850_data>   ; Venezuela
 ctryent <CENTRYSIZE,CID_VE,437,,,ve437_data>   ;

 ctryent <CENTRYSIZE,CID_YU,852,,,yu852_data>   ; Yugoslavia
 ctryent <CENTRYSIZE,CID_YU,850,,,yu850_data>   ;
 ctryent <CENTRYSIZE,CID_YC,855,,,yc855_data>   ; Yugoslavia Cyrillic

 ctryent <CENTRYSIZE,CID_IS,850,,,is850_data>   ; Israel
 ctryent <CENTRYSIZE,CID_IS,862,,,is862_data>   ; 

 ctryent <CENTRYSIZE,CID_AS,850,,,as850_data>   ; Area South (Arab States)
 ctryent <CENTRYSIZE,CID_AS,864,,,as864_data>   ; 

 ctryent <CENTRYSIZE,CID_JP,437,,,jp437_data>   ; Japan
 ctryent <CENTRYSIZE,CID_JP,932,,,jp932_data>   ; 

 ctryent <CENTRYSIZE,CID_KO,949,,,ko949_data>   ; Korea Windows
 ctryent <CENTRYSIZE,CID_KO,437,,,ko437_data>   ; Korea
 ctryent <CENTRYSIZE,CID_KO,1361,,,ko1361_data>   ; 

 ctryent <CENTRYSIZE,CID_PR,936,,,pr936_data>   ; PRC
 ctryent <CENTRYSIZE,CID_PR,437,,,pr437_data>   ; 

 ctryent <CENTRYSIZE,CID_TA,950,,,ta938_data>   ; Taiwan Windows
 ctryent <CENTRYSIZE,CID_TA,437,,,ta437_data>   ; Taiwan Old MS-DOS Code
 ctryent <CENTRYSIZE,CID_TA,938,,,ta938_data>   ; 
 ctryent <CENTRYSIZE,CID_TAI,950,,,tai938_data> ; Taiwan Real Country Code
 ctryent <CENTRYSIZE,CID_TAI,437,,,tai437_data> ; 
 ctryent <CENTRYSIZE,CID_TAI,938,,,tai938_data> ; 

 ctryent <CENTRYSIZE,CID_ISO,437,,,iso437_data> ; Work around an NLSFUNC.EXE
 ctryent <CENTRYSIZE,CID_ISO,737,,,iso437_data> ;  bug entry.  USA with
 ctryent <CENTRYSIZE,CID_ISO,850,,,iso850_data> ;  ISO 8601 Date format.
 ctryent <CENTRYSIZE,CID_ISO,852,,,iso850_data> ; 
 ctryent <CENTRYSIZE,CID_ISO,855,,,iso850_data> ;
 ctryent <CENTRYSIZE,CID_ISO,857,,,iso850_data> ;


dummy   macro   p
finalCNT        equ     p
        endm
        dummy   %cntrycnt


al852_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,al852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

al850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,al850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


as864_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,as864_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Arabic_864_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

as850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,as850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ar850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ar850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ar437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ar437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


au437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,au437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

au850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,au850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


at850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,at850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,German_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,German_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

at437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,at437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


be850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,be850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Belgian_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swed_Fin_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swed_Fin_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

be437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,be437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Belgian_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swed_Fin_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swed_Fin_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


bh852_data label   word
  dw     CDATAITEMS                      ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,bh852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

bh850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,bh850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


br850_data label   word
  dw    CDATAITEMS                    ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,br850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Brazilian_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

br437_data label   word
  dw    CDATAITEMS                    ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,br437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


bg855_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,bg855_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Cyrillic_855_collate>
  ctrydat <CDATASIZE,SETUCASE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

bg850_data label   word
  dw     CDATAITEMS                      ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,bg850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

bgi855_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,bgi855_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Cyrillic_855_collate>
  ctrydat <CDATASIZE,SETUCASE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

bgi850_data label   word
  dw     CDATAITEMS                      ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,bgi850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ca850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ca850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ca863_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ca863_info>
  ctrydat <CDATASIZE,SETCOLLATE,,FrnCdn_863_collate>
  ctrydat <CDATASIZE,SETUCASE,,FrnCdn_863_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,FrnCdn_863_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


cae850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cae850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

cae863_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cae863_info>
  ctrydat <CDATASIZE,SETCOLLATE,,FrnCdn_863_collate>
  ctrydat <CDATASIZE,SETUCASE,,FrnCdn_863_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,FrnCdn_863_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


cl850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cl850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

cl437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cl437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


co850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,co850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

co437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,co437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


cro852_data label   word
  dw     CDATAITEMS                      ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cro852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

cro850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cro850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


cs852_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cs852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

cs850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,cs850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


dk850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,dk850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Danish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Nordic_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Nordic_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

dk865_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,dk865_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Danish_865_collate>
  ctrydat <CDATASIZE,SETUCASE,,Nordic_865_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Nordic_865_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ec850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ec850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ec437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ec437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


fi850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,fi850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Finnish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swed_Fin_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swed_Fin_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

fi437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,fi437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Swed_Fin_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swed_Fin_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swed_Fin_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


fr850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,fr850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

fr437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,fr437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


gr850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,gr850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,German_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,German_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

gr437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,gr437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


gk869_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,gk869_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Greek_869_collate>
  ctrydat <CDATASIZE,SETUCASE,,Greek_869_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Greek_869_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

gk737_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,gk737_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Greek_737_collate>  
  ctrydat <CDATASIZE,SETUCASE,,Greek_737_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Greek_737_ucase>   
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

gk850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,gk850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


hk437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,hk437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


hu852_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,hu852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

hu850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,hu850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ic850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ic850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ic861_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ic861_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Icelandic_861_collate>
  ctrydat <CDATASIZE,SETUCASE,,Icelandic_861_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Icelandic_861_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


afe437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,afe437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

afe850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,afe850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ie850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ie850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ie437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ie437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


in437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,in437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


is862_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,is862_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Hebrew_862_collate>
  ctrydat <CDATASIZE,SETUCASE,,Hebrew_862_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Hebrew_862_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

is850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,is850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


it850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,it850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

it437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,it437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


jp932_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,jp932_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Japan_932_collate>
  ctrydat <CDATASIZE,SETUCASE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,jp932_dbcs>

jp437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,jp437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ko949_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ko949_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Korea_949_collate>
  ctrydat <CDATASIZE,SETUCASE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,ko949_dbcs>


ko1361_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ko1361_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Korea_949_collate>
  ctrydat <CDATASIZE,SETUCASE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,ko1361_dbcs>


ko437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ko437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


la850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,la850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

la437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,la437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


mac855_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,mac855_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Cyrillic_855_collate>
  ctrydat <CDATASIZE,SETUCASE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

mac850_data label   word
  dw     CDATAITEMS                               ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,mac850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


my437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,my437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


mx850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,mx850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

mx437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,mx437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


nl850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,nl850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Dutch_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Dutch_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Dutch_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

nl437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,nl437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Dutch_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Dutch_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Dutch_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


nz437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,nz437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

nz850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,nz850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


no850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,no850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Norwegian_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Nordic_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Nordic_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

no865_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,no865_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Norwegian_865_collate>
  ctrydat <CDATASIZE,SETUCASE,,Nordic_865_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Nordic_865_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


pr936_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,pr936_info>
  ctrydat <CDATASIZE,SETCOLLATE,,PRC_936_collate>
  ctrydat <CDATASIZE,SETUCASE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,pr936_dbcs>


pr437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,pr437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


pl852_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,pl852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

pl850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,pl850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


po850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,po850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

po860_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,po860_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Portuguese_860_collate>
  ctrydat <CDATASIZE,SETUCASE,,Portuguese_860_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Portuguese_860_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ro852_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ro852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ro850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ro850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ru866_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ru866_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Russian_866_collate>
  ctrydat <CDATASIZE,SETUCASE,,Russian_866_ucase>
  ctrydat <CDATASIZE,SETLCASE,,ru866_lcase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Russian_866_ucase>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ru437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ru437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ru850_data label   word
  dw      CDATAITEMS                             ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ru850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ru855_data label   word
  dw      CDATAITEMS                             ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ru855_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Cyrillic_855_collate>
  ctrydat <CDATASIZE,SETUCASE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ru852_data label   word
  dw      CDATAITEMS                             ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ru852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sm855_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sm855_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Cyrillic_855_collate>
  ctrydat <CDATASIZE,SETUCASE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

sm850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sm850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sg437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sg437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sl852_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sl852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

sl850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sl850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sln852_data label   word
  dw     CDATAITEMS                      ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sln852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

sln850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sln850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


za437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,za437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

za850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,za850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sp850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sp850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

sp437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sp437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sv850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sv850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Swedish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swed_Fin_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swed_Fin_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

sv437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sv437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Swed_Fin_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swed_Fin_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swed_Fin_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


sw850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sw850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Swiss_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swiss_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swiss_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

sw437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,sw437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Swiss_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Swiss_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Swiss_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ta938_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ta938_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Taiwan_938_collate>
  ctrydat <CDATASIZE,SETUCASE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,ta938_dbcs>

ta437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ta437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


tai938_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,tai938_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Taiwan_938_collate>
  ctrydat <CDATASIZE,SETUCASE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,DBCS_93x_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,ta938_dbcs>

tai437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,tai437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


tr857_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,tr857_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Turkish_857_collate>
  ctrydat <CDATASIZE,SETUCASE,,Turkish_857_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Turkish_857_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

tr850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,tr850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Turkish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Turkish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Turkish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


uk850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,uk850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

uk437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,uk437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


us437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,us437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

us850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,us850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


ve850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ve850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Spanish_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

ve437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,ve437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Spanish_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


yu852_data label   word
  dw     CDATAITEMS                      ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,yu852_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_852_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_852_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP852_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

yu850_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,yu850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin2_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin2_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,CP850_ucfile>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

yc855_data label   word
  dw     CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,yc855_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Cyrillic_855_collate>
  ctrydat <CDATASIZE,SETUCASE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Cyrillic_855_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>


iso437_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,iso437_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_437_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_437_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>

iso850_data label   word
  dw      CDATAITEMS                              ; number of entries
  ctrydat <CDATASIZE,SETCOUNTRYINFO,,iso850_info>
  ctrydat <CDATASIZE,SETCOLLATE,,Latin1_850_collate>
  ctrydat <CDATASIZE,SETUCASE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETUCASEFILE,,Latin1_850_ucase>
  ctrydat <CDATASIZE,SETFILELIST,,Valid_flist>
  ctrydat <CDATASIZE,SETDBCS,,Not_dbcs>



; ----------------------------------------
;                                                       
;       World Trade Country Info Tables
;
; ----------------------------------------

;================================================

al852_info   label   word   ;CP852 Albania
   ctable  <>
   cinfo   <CID_AL,852,YMD,'L','e','k',000,0,'.',0,',',0,'-',0,':',0,CurrAmount,2,HR24,0,','>

al850_info   label   word   ;CP850 Albania
   ctable  <>
   cinfo   <CID_AL,850,YMD,'L','e','k',000,0,'.',0,',',0,'-',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

as864_info   label   word   ;CP864 Area South (Arabic)
   ctable  <>
   cinfo   <CID_AS,864,DMY,164,000,000,000,0,'.',0,',',0,'/',0,':',0,Amount_Cur,3,HR12,0,';'>

as850_info   label   word   ;CP850 Area South (Arabic)
   ctable  <>
   cinfo   <CID_AS,864,DMY,'',000,000,000,0,'.',0,',',0,'/',0,':',0,Amount_Cur,3,HR12,0,';'>

;================================================

ar850_info   label   word   ;CP850 Argentina
   ctable  <>
   cinfo   <CID_AR,850,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,'.',0,CurrAmount,2,HR24,0,','> 

ar437_info   label   word   ;CP437 Argentina
   ctable  <>
   cinfo   <CID_AR,437,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,'.',0,CurrAmount,2,HR24,0,','> 

;================================================

au437_info   label   word   ;CP437 Australia
   ctable  <>
   cinfo   <CID_AU,437,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

au850_info   label   word   ;CP850 Australia
   ctable  <>
   cinfo   <CID_AU,850,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

at850_info   label   word   ;CP850 Austria
   ctable  <>
   cinfo   <CID_AT,850,DMY,'S',000,000,000,0,'.',0,',',0,'.',0,':',0,Cur_Amount,2,HR24,0,';'> 

at437_info   label   word   ;CP437 Austria
   ctable  <>
   cinfo   <CID_AT,437,DMY,'S',000,000,000,0,'.',0,',',0,'.',0,':',0,Cur_Amount,2,HR24,0,';'> 

;================================================

be850_info   label   word   ;CP850 Belgium
   ctable  <>
   cinfo   <CID_BE,850,DMY,'B','F',000,000,0,'.',0,',',0,'/',0,':',0,Amount_Cur,2,HR24,0,';'>      

be437_info   label   word   ;CP437 Belgium
   ctable  <>
   cinfo   <CID_BE,437,DMY,'B','F',000,000,0,'.',0,',',0,'/',0,':',0,Amount_Cur,2,HR24,0,';'>      

;================================================

bh852_info   label   word   ;CP852 Bosnia/Herzegovina
   ctable  <>
   cinfo   <CID_BH,852,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

bh850_info   label   word   ;CP850 Bosnia/Herzegovina
   ctable  <>
   cinfo   <CID_BH,850,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

br850_info   label   word   ;CP850 Brazil
   ctable  <>
   cinfo   <CID_BR,850,DMY,'C','r','$',000,0,'.',0,',',0,'/',0,':',0,Cur_Amount,2,HR24,0,';'>

br437_info   label   word   ;CP437 Brazil
   ctable  <>
   cinfo   <CID_BR,437,DMY,'C','r','$',000,0,'.',0,',',0,'/',0,':',0,Cur_Amount,2,HR24,0,';'>

;================================================

bg855_info   label   word   ;CP855 Bulgaria  IBM Country Code
   ctable  <>
   cinfo   <CID_BG,855,DMY,'','','.',000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,';'>

bg850_info   label   word   ;CP850 Bulgaria  IBM Country Code
   ctable  <>
   cinfo   <CID_BG,850,DMY,'L','v',000,000,0,' ',0,',',0,'.',0,'.',0,CurrAmount,2,HR24,0,';'>

bgi855_info  label   word   ;CP855 Bulgaria  Real Country Code
   ctable  <>
   cinfo  <CID_BGI,855,DMY,'','','.',000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,';'>

bgi850_info  label   word   ;CP850 Bulgaria  Real Country Code
   ctable  <>
   cinfo  <CID_BGI,850,DMY,'L','v',000,000,0,' ',0,',',0,'.',0,'.',0,CurrAmount,2,HR24,0,';'>

;================================================

ca850_info   label   word   ;CP850 French Canadian
   ctable  <>
   cinfo   <CID_CA,850,YMD,'$',000,000,000,0,' ',0,',',0,'-',0,':',0,Amount_Cur,2,HR24,0,';'>

ca863_info   label   word   ;CP863 French Canadian
   ctable  <>
   cinfo   <CID_CA,863,YMD,'$',000,000,000,0,' ',0,',',0,'-',0,':',0,Amount_Cur,2,HR24,0,';'>

;================================================

cae850_info  label   word   ;CP850 English Canadian
   ctable  <>
   cinfo  <CID_CAE,850,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

cae863_info  label   word   ;CP863 English Canadian
   ctable  <>
   cinfo  <CID_CAE,863,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

cl850_info   label   word   ;CP850 Chile
   ctable  <>
   cinfo   <CID_CL,850,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,','> 

cl437_info   label   word   ;CP437 Chile
   ctable  <>
   cinfo   <CID_CL,437,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,','> 

;================================================

; Columbia
co850_info   label   word   ;CP850 Columbia
   ctable  <>
   cinfo   <CID_CO,850,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

co437_info   label   word   ;CP437 Columbia
   ctable  <>
   cinfo   <CID_CO,437,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

;================================================

cro852_info  label   word   ;CP852 Croatia
   ctable  <>
   cinfo  <CID_CRO,852,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

cro850_info  label   word   ;CP850 Croatia
   ctable  <>
   cinfo  <CID_CRO,850,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

cs852_info   label   word   ;CP852 Czech Republic
   ctable  <>
   cinfo   <CID_CS,852,DMY,'K','',000,000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,','>

cs850_info   label   word   ;CP850 Czech Republic
   ctable  <>
   cinfo   <CID_CS,850,DMY,'K','c',000,000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,','>

;================================================

dk850_info   label   word   ;CP850 Denmark
   ctable  <>
   cinfo   <CID_DK,850,DMY,'k','r',000,000,0,'.',0,',',0,'-',0,'.',0,Cur_Amount,2,HR24,0,';'>

dk865_info   label   word   ;CP865 Denmark
   ctable  <>
   cinfo   <CID_DK,865,DMY,'k','r',000,000,0,'.',0,',',0,'-',0,'.',0,Cur_Amount,2,HR24,0,';'>

;================================================

ec850_info   label   word   ;CP850 Ecuador
   ctable  <>
   cinfo   <CID_EC,850,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,','> 

ec437_info   label   word   ;CP437 Ecuador
   ctable  <>
   cinfo   <CID_EC,437,DMY,'$',000,000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,','> 


;================================================

fi850_info   label   word   ;CP850 Finland
   ctable  <>
   cinfo   <CID_FI,437,DMY,'m','k',000,000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,';'>

fi437_info   label   word   ;CP437
   ctable  <>
   cinfo   <CID_FI,437,DMY,'m','k',000,000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,';'>

;================================================

fr850_info   label   word   ;CP850 France
   ctable  <>
   cinfo   <CID_FR,850,DMY,'F',000,000,000,0,' ',0,',',0,'/',0,':',0,Amount_Cur,2,HR24,0,';'> 

fr437_info   label   word   ;CP437 France
   ctable  <>
   cinfo   <CID_FR,437,DMY,'F',000,000,000,0,' ',0,',',0,'/',0,':',0,Amount_Cur,2,HR24,0,';'> 

;================================================

gr850_info   label   word   ;CP850 Germany
   ctable  <>
   cinfo   <CID_GR,850,DMY,'D','M',000,000,0,'.',0,',',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'> 

gr437_info   label   word   ;CP437 Germany
   ctable  <>
   cinfo   <CID_GR,437,DMY,'D','M',000,000,0,'.',0,',',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'> 

;================================================

gk869_info   label   word   ;CP869 Greece
   ctable  <>
   cinfo   <CID_GK,869,DMY,'','','',000,0,'.',0,',',0,'/',0,':',0,AmountCurr,2,HR12,0,','>

gk737_info   label   word   ;CP737 Greece
   ctable  <>
   cinfo   <CID_GK,737,DMY,'','','',000,0,'.',0,',',0,'/',0,':',0,AmountCurr,2,HR12,0,','>

gk852_info   label   word   ;CP852 Greece
   ctable  <>
   cinfo   <CID_GK,852,DMY,'D','r','s',000,0,'.',0,',',0,'/',0,':',0,AmountCurr,2,HR12,0,','>

gk850_info   label   word   ;CP850 Greece
   ctable  <>
   cinfo   <CID_GK,850,DMY,'D','r','s',000,0,'.',0,',',0,'/',0,':',0,AmountCurr,2,HR12,0,','>

;================================================

hk437_info   label   word   ;CP437 Hong Kong SAR
   ctable  <>
   cinfo   <CID_HK,437,DMY,'H','K','$',000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>  

;================================================

hu852_info   label   word   ;CP852 Hungary
   ctable  <>
   cinfo   <CID_HU,852,YMD,'F','t',000,000,0,' ',0,',',0,'.',0,'.',0,CurrAmount,2,HR24,0,';'>

hu850_info   label   word   ;CP850 Hungary
   ctable  <>
   cinfo   <CID_HU,850,YMD,'F','t',000,000,0,' ',0,',',0,'.',0,'.',0,CurrAmount,2,HR24,0,';'>

;================================================

ic861_info   label   word   ;CP861 Iceland
   ctable  <>
   cinfo   <CID_IC,861,YMD,'','K','r',000,0,' ',0,',',0,'-',0,':',0,Amount_Cur,2,HR24,0,';'>

ic850_info   label   word   ;CP850 Iceland
   ctable  <>
   cinfo   <CID_IC,850,YMD,'k','r',000,000,0,' ',0,',',0,'-',0,':',0,Amount_Cur,2,HR24,0,';'>

;================================================

in437_info   label   word   ;CP437 Indea
   ctable  <>
   cinfo   <CID_IN,437,DMY,'R','s',000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,','>  

;================================================

afe437_info  label   word   ;CP437 International English
   ctable  <>
   cinfo  <CID_AFE,437,DMY,'$',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,2,HR12,0,','>

afe850_info  label   word   ;CP850 International English
   ctable  <>
   cinfo  <CID_AFE,850,DMY,'$',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,2,HR12,0,','>

;================================================

ie850_info   label   word   ;CP850 Ireland
   ctable  <>
   cinfo   <CID_IE,850,DMY,'I','R','',000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>  

ie437_info   label   word   ;CP437 Ireland
   ctable  <>
   cinfo   <CID_IE,437,DMY,'I','R','',000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>  

;================================================

is862_info   label   word   ;CP862 Israel
   ctable  <>
   cinfo   <CID_IS,862,DMY,153,000,000,000,0,',',0,'.',0,'/',0,':',0,Cur_Amount,2,HR24,0,','>

is850_info   label   word   ;CP850 Israel
   ctable  <>
   cinfo   <CID_IS,850,DMY,'N','I','S',000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

it850_info   label   word   ;CP850 Italy
   ctable  <>
   cinfo   <CID_IT,850,DMY,'L','.',000,000,0,'.',0,',',0,'/',0,'.',0,Cur_Amount,0,HR24,0,';'>       

it437_info   label   word   ;CP437 Italy
   ctable  <>
   cinfo   <CID_IT,437,DMY,'L','.',000,000,0,'.',0,',',0,'/',0,'.',0,Cur_Amount,0,HR24,0,';'>       

;================================================

jp932_info   label   word   ;CP932 Japan
   ctable  <>
   cinfo   <CID_JP,932,YMD,'\',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,0,HR24,0,','>

jp437_info   label   word   ;CP437 Japan
   ctable  <>
   cinfo   <CID_JP,437,MDY,'$',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,2,HR12,0,','>

;================================================

ko949_info   label   word   ;CP949 Korea
   ctable  <>
   cinfo   <CID_KO,949,YMD,'\',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,0,HR24,0,','>  

ko1361_info   label   word   ;CP1361 Korea
   ctable  <>
   cinfo   <CID_KO,1361,YMD,'\',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,0,HR24,0,','>  

ko437_info   label   word   ;CP437 Korea
   ctable  <>
   cinfo   <CID_KO,437,MDY,'$',000,000,000,0,',',0,'.',0,'-',0,':',0,CurrAmount,2,HR12,0,','>

;================================================

la850_info   label   word   ;CP850 Latin America
   ctable  <>
   cinfo   <CID_LA,850,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

la437_info   label   word   ;CP437 Latin America
   ctable  <>
   cinfo   <CID_LA,437,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

;================================================

mac855_info  label   word   ;CP855 FYRO Former Yugoslav Republic of Macedonia
   ctable  <>
   cinfo  <CID_MAC,855,YMD,'','','',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

mac850_info  label   word   ;CP850 FYRO Former Yugoslav Republic of Macedonia
   ctable  <>
   cinfo  <CID_MAC,850,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

my437_info   label   word   ;CP437 Malaysia
   ctable  <>
   cinfo   <CID_MY,437,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>  

;================================================

mx850_info   label   word   ;CP850 Mexico
   ctable  <>
   cinfo   <CID_MX,850,DMY,'N','$',000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

mx437_info   label   word   ;CP437 Mexico
   ctable  <>
   cinfo   <CID_MX,437,DMY,'N','$',000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

;================================================

nl850_info   label   word   ;CP850 Netherlands
   ctable  <>
   cinfo   <CID_NL,850,DMY,'',000,000,000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,';'>

nl437_info   label   word   ;CP437 Netherlands
   ctable  <>
   cinfo   <CID_NL,437,DMY,'',000,000,000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,';'>

;================================================

nz437_info   label   word   ;CP437 New Zealand
   ctable  <>
   cinfo   <CID_NZ,437,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

nz850_info   label   word   ;CP850 New Zealand
   ctable  <>
   cinfo   <CID_NZ,850,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

no850_info   label   word   ;CP850 Norway
   ctable  <>
   cinfo   <CID_NO,850,DMY,'k','r',000,000,0,' ',0,',',0,'.',0,':',0,Cur_Amount,2,HR24,0,';'>

no865_info   label   word   ;CP865 Norway
   ctable  <>
   cinfo   <CID_NO,865,DMY,'k','r',000,000,0,' ',0,',',0,'.',0,':',0,Cur_Amount,2,HR24,0,';'> 

;================================================

pr936_info   label   word   ;CP936 People's Republic of China
   ctable  <>
   cinfo   <CID_PR,936,YMD,'\',000,000,000,0,',',0,'.',0,'.',0,':',0,CurrAmount,2,HR12,0,','>

pr437_info   label   word   ;CP437 People's Republic of China
   ctable  <>
   cinfo   <CID_PR,437,YMD,'$',000,000,000,0,',',0,'.',0,'.',0,':',0,CurrAmount,2,HR12,0,','>

;================================================

pl852_info   label   word   ;CP852 Poland 
   ctable  <>
   cinfo   <CID_PL,852,YMD,'Z','',000,000,0,' ',0,',',0,'.',0,':',0,CurrAmount,2,HR24,0,';'>

pl850_info   label   word   ;CP850 Poland 
   ctable  <>
   cinfo   <CID_PL,850,YMD,'Z','l',000,000,0,' ',0,',',0,'.',0,':',0,CurrAmount,2,HR24,0,';'>

;================================================

po850_info   label   word   ;CP850 Portugal
   ctable  <>
   cinfo   <CID_PO,850,DMY,'E','s','c','.',0,'.',0,',',0,'-',0,':',0,Amount_Cur,2,HR24,0,';'>        

po860_info   label   word   ;CP860 Portugal
   ctable  <>
   cinfo   <CID_PO,860,DMY,'E','s','c','.',0,'.',0,',',0,'-',0,':',0,Amount_Cur,2,HR24,0,';'>        

;================================================

ro852_info   label   word   ;CP852 Romania
   ctable  <>
   cinfo   <CID_RO,852,YMD,'L','e','i',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

ro850_info   label   word   ;CP850 Romania
   ctable  <>
   cinfo   <CID_RO,850,YMD,'L','e','i',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

ru866_info   label   word   ;CP866 Russia
   ctable  <>
   cinfo   <CID_RU,866,DMY,'','.',000,000,0,' ',0,'.',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'>

ru437_info   label   word   ;CP437 Russia
   ctable  <>
   cinfo   <CID_RU,437,DMY,'r','.',000,000,0,' ',0,'.',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'>

ru850_info   label   word   ;CP850 Russia
   ctable  <>
   cinfo   <CID_RU,850,DMY,'r','.',000,000,0,' ',0,'.',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'>

ru855_info   label   word   ;CP855 Russia
   ctable  <>
   cinfo   <CID_RU,855,DMY,'','.',000,000,0,' ',0,'.',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'>

ru852_info   label   word   ;CP852 Russia
   ctable  <>
   cinfo   <CID_RU,852,DMY,'r','.',000,000,0,' ',0,'.',0,'.',0,':',0,Amount_Cur,2,HR24,0,';'>

;================================================

sm855_info   label   word   ;CP855 Serbia/Montenegro
   ctable  <>
   cinfo   <CID_SM,855,YMD,'','','',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

sm850_info   label   word   ;CP850 Serbia/Montenegro
   ctable  <>
   cinfo   <CID_SM,850,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

sg437_info   label   word   ;CP437 Singapore
   ctable  <>
   cinfo   <CID_SG,437,DMY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>  

;================================================

sl852_info   label   word   ;CP852 Slovakia
   ctable  <>
   cinfo   <CID_SL,852,DMY,'S','k',000,000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,';'>

sl850_info   label   word   ;CP850 Slovakia
   ctable  <>
   cinfo   <CID_SL,850,DMY,'S','k',000,000,0,' ',0,',',0,'.',0,'.',0,Amount_Cur,2,HR24,0,';'>

;================================================

sln852_info  label   word   ;CP852 Slovenia
   ctable  <>
   cinfo  <CID_SLN,852,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

sln850_info  label   word   ;CP850 Slovenia
   ctable  <>
   cinfo  <CID_SLN,850,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

za437_info   label   word   ;CP437 South Africa
   ctable  <>
   cinfo   <CID_ZA,437,YMD,'R',000,000,000,0,' ',0,',',0,'-',0,':',0,CurrAmount,2,HR24,0,','>

za850_info   label   word   ;CP850 South Africa
   ctable  <>
   cinfo   <CID_ZA,850,YMD,'R',000,000,000,0,' ',0,',',0,'-',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

sp850_info   label   word   ;CP850 Spain
   ctable  <>
   cinfo   <CID_SP,437,DMY,'P','t','s',000,0,'.',0,',',0,'/',0,':',0,Amount_Cur,0,HR24,0,';'>   

sp437_info   label   word   ;CP437 Spain
   ctable  <>
   cinfo   <CID_SP,437,DMY,'',000,000,000,0,'.',0,',',0,'/',0,':',0,Amount_Cur,0,HR24,0,';'> 

;================================================

sv850_info   label   word   ;CP850 Sweden
   ctable  <>
   cinfo   <CID_SV,850,YMD,'k','r',000,000,0,' ',0,',',0,'-',0,'.',0,Amount_Cur,2,HR24,0,';'>      

sv437_info   label   word   ;CP437 Sweden
   ctable  <>
   cinfo   <CID_SV,437,YMD,'k','r',000,000,0,' ',0,',',0,'-',0,'.',0,Amount_Cur,2,HR24,0,';'>      

;================================================

sw850_info   label   word   ;CP850 Switzerland
   ctable  <>
   cinfo   <CID_SW,850,DMY,'S','F','r','.',0,"'",0,'.',0,'.',0,':',0,Cur_Amount,2,HR24,0,';'> 

sw437_info   label   word   ;CP437 Switzerland
   ctable  <>
   cinfo   <CID_SW,437,DMY,'S','F','r','.',0,"'",0,'.',0,'.',0,':',0,Cur_Amount,2,HR24,0,';'> 

;================================================

ta938_info   label   word   ;CP938 Taiwan
   ctable  <>
   cinfo  <CID_TA,938,YMD,'N','T','$',000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>

ta437_info   label   word   ;CP437 Taiwan
   ctable  <>
   cinfo  <CID_TA,437,YMD,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>    

tai938_info  label   word   ;CP938 Taiwan with Real Country/Region Code
   ctable  <>
   cinfo   <CID_TAI,938,YMD,'N','T','$',000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>

tai437_info  label   word   ;CP437 Taiwan with Country/Region Code
   ctable  <>
   cinfo   <CID_TAI,437,YMD,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>    

;================================================

tr850_info   label   word   ;CP852 Turkey
   ctable  <>
   cinfo   <CID_TR,850,DMY,'T','L',000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,';'>

tr857_info   label   word   ;CP852 Turkey
   ctable  <>
   cinfo   <CID_TR,857,DMY,'T','L',000,000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR24,0,';'>

;================================================

uk850_info   label   word   ;CP850 United Kingdom
   ctable  <>
   cinfo   <CID_UK,850,DMY,'',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>  

uk437_info   label   word   ;CP437 United Kingdom
   ctable  <>
   cinfo   <CID_UK,437,DMY,'',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR24,0,','>  

;================================================

us437_info   label   word   ;CP437 United States
   ctable  <>
   cinfo   <CID_US,437,MDY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>

us850_info   label   word   ;CP850 United States
   ctable  <>
   cinfo   <CID_US,850,MDY,'$',000,000,000,0,',',0,'.',0,'/',0,':',0,CurrAmount,2,HR12,0,','>

;================================================

ve850_info   label   word   ;CP850 Venezuela
   ctable  <>
   cinfo   <CID_VE,850,DMY,'B','s','.',000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

ve437_info   label   word   ;CP437 Venezuela
   ctable  <>
   cinfo   <CID_VE,437,DMY,'B','s','.',000,0,'.',0,',',0,'/',0,':',0,CurrAmount,2,HR12,0,','> 

;================================================

yu852_info   label   word   ;CP852 Yugoslavia
   ctable  <>
   cinfo   <CID_YU,852,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

yu850_info   label   word   ;CP850 Yugoslavia
   ctable  <>
   cinfo   <CID_YU,850,YMD,'D','i','n',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

yc855_info   label   word   ;CP855 Yugoslavia Cyrillic
   ctable  <>
   cinfo   <CID_YC,855,YMD,'','','',000,0,'.',0,',',0,'-',0,':',0,Cur_Amount,2,HR24,0,','>

;================================================

iso437_info  label   word   ;CP437 Work around an NLSFUNC.EXE Bug Entry
   ctable  <>
   cinfo  <CID_ISO,437,YMD,'E','A','$',000,0,'.',0,',',0,'-',0,':',0,CurrAmount,2,HR24,0,','>

iso850_info  label   word   ;CP850 Work around an NLSFUNC.EXE Bug Entry
   ctable  <>
   cinfo  <CID_ISO,850,YMD,'J','K','$',000,0,',',0,'.',0,'-',0,':',0,CurrAmount,2,HR24,0,','>

;================================================

        page

include nls437.inc
include nls737.inc
include nls850.inc
include nls852.inc
include nls855.inc
include nls857.inc
include nls860.inc
include nls861.inc
include nls862.inc
include nls863.inc
include nls864.inc
include nls865.inc
include nls866.inc
include nls869.inc
include nls93x.inc


; ----------------------------------------------------------------------------
;
;       World Trade Valid Filename Character Tables
;
;               Currently all countries have same (4/14/86)
;
;
; ----------------------------------------------------------------------------
Valid_flist label word
                ctable  <,'FCHAR  ',fclend-fclbegin>
fclbegin        label   word
                db      1,0,255                         ; include all
                db      0,0,20h                         ; exclude 0 - 20h
                db      2,14,'."/\[]:|<>+=;,'           ; exclude 14 special chars
fclend          label   word



; ----------------------------------------------------------------------------
;
;       World Trade DBCS Tables
;
;           Currently all countries have same (4/14/86)
;
;
; ----------------------------------------------------------------------------
;                                  
Not_dbcs label word
                ctable  <,'DBCS   ',dbcsterm-dbcsbegin>         ;AN000;
dbcsbegin       label   word                                    ;AN000;
dbcsterm        db      0,0                                     ;AN000;
dbcsend         label   word                                    ;AN000;



include DBCS93x.inc



include copyrigh.inc

; ---------------------------------------------------------------
;
;               END OF CDI SEGMENT
;
; ---------------------------------------------------------------


dseg    ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\mkcntry.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
;        include file for create cdi file
;
PTRCNT          EQU     1               ; NUMBER OF POINTERS
CIPTYPE         EQU     1               ; TYPE FOR COUNTRY INFO POINTER
; CNTRYCNT        EQU     18              ; NUMBER OF COUNTRIES SUPPORTED

;
; entry type symbols
;
SETCOUNTRYINFO  EQU     1
SETUCASE        EQU     2
SETLCASE        EQU     3
SETUCASEFILE    EQU     4
SETFILELIST     EQU     5
SETCOLLATE      EQU     6
SETDBCS         EQU     7


CDATAITEMS      EQU     SETDBCS - 1     ; NUMBER OF ENTRIES IN COUNTRY DATA


;
; country id's
;
CID_UK          EQU     044             ; United Kingdom
CID_FR          EQU     033             ; France
CID_GR          EQU     049             ; Germany
CID_SP          EQU     034             ; Spain
CID_IT          EQU     039             ; Italy
CID_SV          EQU     046             ; Sweden
CID_AFE         EQU     061             ; International English
CID_DK          EQU     045             ; Denmark
CID_SW          EQU     041             ; Switzerland
CID_NO          EQU     047             ; Norway
CID_NL          EQU     031             ; Netherlands
CID_BE          EQU     032             ; Belgium
CID_FI          EQU     358             ; Finland
CID_US          EQU     001             ; United States
CID_IS          EQU     972             ; Israel
CID_CA          EQU     002             ; Canadian French
CID_CAE         EQU     004             ; Canadian English
CID_AS          EQU     785             ; Area South (Saudi Arabia)
CID_PO          EQU     351             ; Portugal
CID_LA          EQU     003             ; Latin America
CID_BR          EQU     055             ; Brazil
CID_IC          EQU     354             ; Iceland
CID_TR          EQU     090             ; Turkey
CID_YU          EQU     038             ; YUGOSLAVIA
CID_CS          EQU     420             ; CZECH
CID_GK          EQU     030             ; GREEK  added 9/15/93
CID_HU          EQU     036             ; HUNGARY
CID_PL          EQU     048             ; POLAND
CID_RO          EQU     040             ; ROMANIA
CID_JP          EQU     081             ; Japan         2/17/KK
CID_KO          EQU     082             ; Korea         2/17/KK
CID_PR          EQU     086             ; PRC           2/17/KK
CID_TA          EQU     088             ; Taiwan        2/17/KK
CID_TAI         EQU     886             ; Real Country/Region Code for Taiwan   (EA)
CID_RU          EQU     007             ; Russia  (YST)
CID_AL          EQU     355             ; Albania                        (EA)
CID_AR          EQU     054             ; Argentina                      (EA)
CID_AU          EQU     061             ; Australia                      (EA)
CID_AT          EQU     043             ; Austria                        (EA)
CID_BH          EQU     387             ; Bosnia/Herzegovina             (EA)
CID_BG          EQU     035             ; IBM Country Code for Bulgaria  (EA)
CID_BGI         EQU     359             ; Real Country Code for Bulgaria (EA)
CID_CL          EQU     056             ; Chile                          (EA)
CID_CO          EQU     057             ; Columbia                       (EA)
CID_CRO         EQU     384             ; Croatia                        (EA)
CID_EC          EQU     593             ; Ecuador                        (EA)
CID_MAC         EQU     389             ; FYRO Macedonia                 (EA)
CID_IE          EQU     353             ; Ireland                        (EA)
CID_MX          EQU     052             ; Mexico                         (EA)
CID_NZ          EQU     064             ; New Zealand                    (EA)
CID_SM          EQU     381             ; Serbia/Montenegro              (EA)
CID_SLN         EQU     386             ; Slovenia                       (EA)
CID_ZA          EQU     027             ; South Africa                   (EA)
CID_VE          EQU     058             ; Venezuela                      (EA)
CID_YC          EQU     038             ; Yugoslavia Cyrillic            (EA)
CID_HK          EQU     852             ; Hong Kong SAR                  (EA)
CID_IN          EQU     091             ; Indea                          (EA)
CID_MY          EQU     060             ; Malaysia                       (EA)
CID_SG          EQU     065             ; Singapore                      (EA)
CID_SL          EQU     421             ; SLOVAK (Not Real Country Code,
                                        ;  but need to get a new number
                                        ;  since it now has different
                                        ;  settings than Czech Rep. and
                                        ;  AT&T have not assigned a new
                                        ;  number yet.)                  (EA)
CID_ISO         EQU     711             ; Work around an NLSFUNC.EXE bug
                                        ;  Entry.  USA with ISO 8601 Date
                                        ;  format.                       (EA)
CID_XX          EQU     000             ; Dummy entry


;
; country code pages
;
CP_UK           EQU     850
CP_FR           EQU     850
CP_GR           EQU     850
CP_SP           EQU     850
CP_IT           EQU     850
CP_SV           EQU     850
CP_AFE          EQU     437
CP_DA           EQU     865
CP_SW           EQU     850
CP_NO           EQU     865
CP_NL           EQU     850
CP_BE           EQU     850
CP_FI           EQU     850
CP_US           EQU     437
CP_IS           EQU     862
CP_CA           EQU     863
CP_CAE          EQU     863
CP_AS           EQU     864
CP_PO           EQU     860
CP_BR           EQU     850
CP_IC           EQU     850
CP_TR           EQU     857
CP_GK           EQU     869             ; GREEK
CP_YU           EQU     852             ; YUGOSLAVIA
CP_CS           EQU     852             ; CZECH
CP_SL           EQU     852             ; SLOVAK (CZECH)
CP_HU           EQU     852             ; HUNGARY
CP_PL           EQU     852             ; POLAND
CP_RO           EQU     852             ; ROMANIA
CP_JP           EQU     932             ; Japan  2/17/KK
CP_KO           EQU     949             ; Korea         2/17/KK
CP_PR           EQU     936             ; PRC           2/17/KK
CP_TA           EQU     938             ; Taiwan        2/17/KK
CP_TAI          EQU     938
CP_RU           EQU     866             ; Russia  1/22/91 (YST)
CP_AL           EQU     852             ; Albania                        (EA)
CP_AR           EQU     850             ; Argentina                      (EA)
CP_AU           EQU     437             ; Australia                      (EA)
CP_AT           EQU     850             ; Austria                        (EA)
CP_BH           EQU     852             ; Bosnia/Herzegovina             (EA)
CP_BG           EQU     855             ; IBM Country Code for Bulgaria  (EA)
CP_BGI          EQU     855             ; Real Country Code for Bulgaria (EA)
CP_CL           EQU     850             ; Chile                          (EA)
CP_CO           EQU     850             ; Columbia                       (EA)
CP_CRO          EQU     852             ; Croatia                        (EA)
CP_EC           EQU     850             ; Ecuador                        (EA)
CP_MAC          EQU     855             ; FYRO Macedonia                 (EA)
CP_IE           EQU     850             ; Ireland                        (EA)
CP_MX           EQU     850             ; Mexico                         (EA)
CP_NZ           EQU     437             ; New Zealand                    (EA)
CP_SM           EQU     855             ; Serbia/Montenegro              (EA)
CP_SLN          EQU     852             ; Slovenia                       (EA)
CP_ZA           EQU     437             ; South Africa                   (EA)
CP_VE           EQU     850             ; Venezuela                      (EA)
CP_HK           EQU     437             ; Hong Kong SAR                  (EA)
CP_IN           EQU     437             ; Indea                          (EA)
CP_MY           EQU     437             ; Malaysia                       (EA)
CP_SG           EQU     437             ; Singapore                      (EA)
CP_ISO          EQU     437             ; Work around an NLSFUNC.EXE bug
                                        ;  Entry.  USA with ISO 8601 Date
                                        ;  format.                       (EA)


;
; date formats
;
MDY             EQU     0
DMY             EQU     1
YMD             EQU     2

;
; time formats
;
HR12            EQU     0               ; 12 HOUR TIME FORMAT
HR24            EQU     1               ; 24 HOUR TIME FORMAT

;
; CURRENCY FORMAT FLAGS
;
CurrAmount      EQU     0               ;  $100
AmountCurr      EQU     1               ;   100$ 
Cur_Amount      EQU     2               ; $ 100
Amount_Cur      EQU     3               ;   100 $

;
; STRUC definitions
;
CTRYSTR STRUC
ESIZE   DW      0                       ; SIZE OF ENTRY
CNTRYID DW      0                       ; COUNTRY ID
CODPAGE DW      0                       ; CODE PAGE ID
RESV1   DW      0                       ; RESERVED
RESV2   DW      0                       ; RESERVED
CDPOINT DW      0                       ; POINTER TO COUNTRY DATA
        DW      0
CTRYSTR ENDS


CENTRYSIZE      EQU  (TYPE CTRYSTR) - 2 ; SIZE OF COUNTRY ENTRY


CTRYENT MACRO PARMS
         CTRYSTR <PARMS>
         CNTRYCNT = CNTRYCNT + 1
ENDM


CTRYDAT STRUC
        DW      0
        DB      0
        DB      0
        DW      0
        DW      0
CTRYDAT ENDS


CDATASIZE       EQU  (TYPE CTRYDAT) - 2 ; SIZE OF COUNTRY DATA


CINFO   STRUC                           ; OFFSET   FIELD
        DW      0                       ;    0     COUNTRY ID
        DW      0                       ;    2     CODE PAGE
        DW      0                       ;    4     DATE FORMAT
        DB      0                       ;    5     CURRENCY SYMBOL (5 BYTES)
        DB      0
        DB      0
        DB      0
        DB      0
        DB      0                       ;   10     1000 SEPARATOR
        DB      0
        DB      0                       ;   12     DECIMAL SEPARATOR
        DB      0
        DB      0                       ;   14     DATE SEPARATOR
        DB      0
        DB      0                       ;   16     TIME SEPARATOR
        DB      0
        DB      0                       ;   18     CURRENCY FORMAT FLAGS
        DB      0                       ;   19     DIGITS IN CURRENCY
        DB      0                       ;   20     TIME FORMAT
        DD      0                       ;   21     RESERVED
        DB      0                       ;   25     DATA LIST SEPARATOR
        DB      0
        DW      5 DUP (0)               ;   27     RESERVED
CINFO   ENDS


CINFOSIZE       EQU     TYPE CINFO      ; SIZE OF COUNTRY INFO TABLE


CTABLE  STRUC
        DB      0FFh
        DB      'CTYINFO'
        DW      CINFOSIZE
CTABLE  ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls855.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 855
;
; -----------------------------------------
;
Russian_855_collate label word
 ctable  <,'COLLATE',256>
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 001,008,016,030,025,031,028,015,017,018,026,032,005,004,011,010
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 038,039,040,041,042,043,044,045,046,047,007,006,033,034,035,009
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 024,049,051,053,055,057,059,061,063,065,067,069,071,073,075,077
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 079,081,083,085,087,089,091,093,095,097,099,019,027,020,013,002
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 012,048,050,052,054,056,058,060,062,064,066,068,070,072,074,076
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 078,080,082,084,086,088,090,092,094,096,098,021,036,022,014,172
   ;                                               
  db "H","H","G","G",134,134,135,135,"S","S",139,139,140,140,"J","J"
   ;                                               
  db "L","L","N","N","H","H","K","K",152,152,"C","C",163,163,161,161
   ;                                               
  db 128,128,129,129,155,155,132,132,133,133,153,153,131,131,061,062
   ;                                               
  db 176,177,178,179,180,154,154,138,138,185,186,187,188,141,141,191
   ;                                               
  db 192,193,194,195,196,197,142,142,200,201,202,203,204,205,206,"$"
   ;                                               
  db 143,143,144,144,145,145,146,146,147,217,218,219,220,147,164,223
   ;                                               
  db 164,148,148,149,149,150,150,151,151,136,136,130,130,159,159,"#"
   ;                                               
  db "-",160,160,137,137,157,157,162,162,158,158,156,156,253,254,255


Cyrillic_855_collate label word
 ctable  <,'COLLATE',256>
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 001,008,016,030,025,031,028,015,017,018,026,032,005,004,011,010
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 038,039,040,041,042,043,044,045,046,047,007,006,033,034,035,009
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 024,049,051,053,055,057,059,061,063,065,067,069,071,073,075,077
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 079,081,083,085,087,089,091,093,095,097,099,019,027,020,013,002
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 012,048,050,052,054,056,058,060,062,064,066,068,070,072,074,076
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 078,080,082,084,086,088,090,092,094,096,098,021,036,022,014,200
   ;                                               
  db 112,113,110,111,118,119,116,117,124,125,128,129,130,131,134,135
   ;                                               
  db 140,141,146,147,160,161,158,159,164,165,174,175,188,189,180,181
   ;                                               
  db 100,101,102,103,170,171,108,109,114,115,166,167,106,107,021,022
   ;                                               
  db 240,240,240,240,240,168,169,126,127,240,240,240,240,132,133,240
   ;                                               
  db 240,240,240,240,240,240,136,137,240,240,240,240,240,240,240,025
   ;                                               
  db 138,139,142,143,144,145,148,149,150,240,240,240,240,151,190,240
   ;                                               
  db 191,152,153,154,155,156,157,162,163,120,121,104,105,184,185,029
   ;                                               
  db 004,182,183,122,123,176,177,186,187,178,179,172,173,023,240,255


;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 855
;
; ---------------------------------------------------------------
;
Cyrillic_855_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls861.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 861
;
; -----------------------------------------
;
Icelandic_861_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,040,047,041,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,040,047,041,126,127
   ;                                               
  db 067,089,'E',065,091,065,093,067,069,069,069,'D','D','[',091,093
   ;                                               
  db 'E','\','\',079,']','[',085,'Y','Y',']',089,092,036,092,036,036
   ;                                               
  db 'A','I','O','U','A','I','O','U',063,169,170,171,172,033,034,036
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 861
;
; ---------------------------------------------------------------
;
Icelandic_861_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","A","","A","","","E","E","E","","","","",""
   ;                                               
  db "","","","O","","","U","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls857.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 857
;
; -----------------------------------------
;
Turkish_857_collate label word
 ctable  <,'COLLATE',256>
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 000,009,023,045,039,046,044,022,026,027,042,047,006,005,014,013
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 060,064,066,068,070,071,072,073,074,075,008,007,051,052,053,011
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 036,077,094,096,100,102,112,114,118,120,132,134,136,138,140,144
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 159,161,163,165,170,172,182,184,186,188,191,028,043,029,017,002
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 016,076,093,095,099,101,111,113,117,121,131,133,135,137,139,143
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 158,160,162,164,169,171,181,183,185,187,190,030,055,031,019,192
   ;                                               
  db 098,179,103,083,087,081,085,097,107,109,105,129,127,119,088,086
   ;                                               
  db 104,091,092,150,156,148,177,175,122,157,180,154,040,155,168,167
   ;                                               
  db 079,123,146,173,141,142,116,115,012,035,054,062,061,010,024,025
   ;                                               
  db 240,240,240,240,240,080,084,082,034,240,240,240,240,038,041,240
   ;                                               
  db 240,240,240,240,240,240,089,090,240,240,240,240,240,240,240,037
   ;                                               
  db 145,078,108,110,106,001,124,128,130,240,240,240,240,056,126,240
   ;                                               
  db 147,166,151,149,152,153,058,001,050,174,178,176,125,189,003,015
   ;                                               
  db 005,048,001,063,033,032,049,021,057,018,020,065,069,067,240,255


;
; ---------------------------------------------------------------
;
;       World Trade Case Mappings
;
; ---------------------------------------------------------------
;
Turkish_857_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","","","","","","","","","","","I","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","",""," ","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls863.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 863
;
; -----------------------------------------
;
FrnCdn_863_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,065,065,134,067,069,069,069,073,073,141,065,143
   ;                                               
  db 069,069,069,079,069,073,085,085,152,079,085,155,156,085,085,159
   ;                                               
  db 160,161,079,085,164,165,166,167,073,169,170,171,172,173,174,175
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 863
;
; ---------------------------------------------------------------
;
FrnCdn_863_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "C","U","E","A","A","A","","C","E","E","E","I","I","","A",""
   ;                                               
  db "E","E","E","O","E","I","U","U","","O","U","","","U","U",""
   ;                                               
  db "","","O","U","","","","","I","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls862.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 862
;
; -----------------------------------------
;
Hebrew_862_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143
   ;                                               
  db 144,145,146,147,148,149,150,151,152,153,154,036,036,036,036,036
   ;                                               
  db 065,073,079,085,078,078,166,167,063,169,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


;
; ---------------------------------------------------------------
;
;      World Trade Case Mappings for Code Page 862
;
; ---------------------------------------------------------------
;
Hebrew_862_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "A","I","O","U","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls865.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 865
;
; -----------------------------------------
;
Danish_865_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,040,047,041,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,040,047,041,126,127
   ;                                               
  db 067,089,069,065,091,065,093,067,069,069,069,073,073,073,091,093
   ;                                               
  db 069,091,091,079,092,079,085,085,089,092,089,092,036,092,036,036
   ;                                               
  db 065,073,079,085,078,078,065,079,063,169,170,171,172,033,034,036
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


Norwegian_865_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,089,069,065,091,065,093,067,069,069,069,073,073,073,091,093
   ;                                               
  db 069,091,091,079,092,079,085,085,089,092,089,092,036,092,036,036
   ;                                               
  db 065,073,079,085,078,078,065,079,063,169,170,171,172,033,034,036
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 865
;
; ---------------------------------------------------------------
;
Nordic_865_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","A","","A","","","E","E","E","I","I","I","",""
   ;                                               
  db "","","","O","","O","U","U","Y","","","","","","",""
   ;                                               
  db "A","I","O","U","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls860.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 860
;
; -----------------------------------------
;
Portuguese_860_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 067,085,069,065,065,065,065,067,069,069,069,073,079,073,065,065
   ;                                               
  db 069,065,069,079,079,079,085,085,073,079,085,036,036,085,036,079
   ;                                               
  db 065,073,079,085,078,078,166,167,063,079,170,171,172,033,034,034
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,083,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
;
; ---------------------------------------------------------------
;
;     World Trade Case Mappings for Code Page 860
;
; ---------------------------------------------------------------
;
Portuguese_860_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls864.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 864
;
; -----------------------------------------
;
Arabic_864_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 032,033,034,035,036,037,038,039,040,041,042,043,044,045,046,047
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 048,049,050,051,052,053,054,055,056,057,058,059,060,061,062,063
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 064,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 080,081,082,083,084,085,086,087,088,089,090,091,092,093,094,095
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 096,065,066,067,068,069,070,071,072,073,074,075,076,077,078,079
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 080,081,082,083,084,085,086,087,088,089,090,123,124,125,126,127
   ;                                               
  db 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143
   ;                                               
  db 144,145,146,147,148,149,150,151,152,233,234,251,255,235,236,179
   ;                                               
  db 153,154,182,155,156,184,253,254,188,189,192,194,163,196,198,200
   ;                                               
  db 164,165,166,167,168,169,170,171,172,173,224,174,206,208,210,175
   ;                                               
  db 157,180,181,183,185,217,186,187,190,191,193,195,197,199,201,202
   ;                                               
  db 203,204,205,207,209,211,213,214,215,218,222,158,159,160,161,216
   ;                                               
  db 178,225,227,229,237,239,241,243,245,246,250,212,219,221,220,238
   ;                                               
  db 177,176,240,242,244,247,249,223,226,231,232,230,228,248,162,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\disp_win\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\disp_win\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\disp_win\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\font_win\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls93x.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 932
;
; -----------------------------------------
;
Japan_932_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db " ","!",'"',"#","$","%","&","'","(",")","*","+",",","-",".","/"
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db "0","1","2","3","4","5","6","7","8","9",":",";","<","=",">","?"
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db "@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db "P","Q","R","S","T","U","V","W","X","Y","Z","[","\","]","^","_"
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db "`","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db "P","Q","R","S","T","U","V","W","X","Y","Z","{","|","}","~",127
   ;                                               
  db 128,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 129,130,131,132,133,189,134,135,136,137,138,139,140,141,142,143
   ;                                               
  db 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159
   ;                                               
  db 160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,190,191,192
   ;                                               
  db 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 949
;
; -----------------------------------------
;
Korea_949_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db " ","!",'"',"#","$","%","&","'","(",")","*","+",",","-",".","/"
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db "0","1","2","3","4","5","6","7","8","9",":",";","<","=",">","?"
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db "@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db "P","Q","R","S","T","U","V","W","X","Y","Z","[","\","]","^","_"
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db "`","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db "P","Q","R","S","T","U","V","W","X","Y","Z","{","|","}","~",127
   ;                                               
  db 128,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204
   ;                                               
  db 205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220
   ;                                               
  db 221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236
   ;                                               
  db 237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252
   ;                                               
  db 129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144
   ;                                               
  db 145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160
   ;                                               
  db 161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176
   ;                                               
  db 177,178,179,180,181,182,183,184,185,186,187,188,189,253,254,255


;
; -----------------------------------------------
;
;     Collating Table(s) for Code Pages 936 & 938
;
; -----------------------------------------------
;
PRC_936_collate    label word
Taiwan_938_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db " ","!",'"',"#","$","%","&","'","(",")","*","+",",","-",".","/"
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db "0","1","2","3","4","5","6","7","8","9",":",";","<","=",">","?"
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db "@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db "P","Q","R","S","T","U","V","W","X","Y","Z","[","\","]","^","_"
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db "`","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O"
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db "P","Q","R","S","T","U","V","W","X","Y","Z","{","|","}","~",127
   ;                                               
  db 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143
   ;                                               
  db 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159
   ;                                               
  db 160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175
   ;                                               
  db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
   ;                                               
  db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207
   ;                                               
  db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
   ;                                               
  db 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239
   ;                                               
  db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255


;
; --------------------------------------------------------------------
;
;     World Trade Case Mappings for Code Pages 932, 949, 936, and 938
;
; --------------------------------------------------------------------
;
DBCS_93x_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls869.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 869
;
; -----------------------------------------
;
Greek_869_collate label word
 ctable  <,'COLLATE',256>
  db 000,001,002,003,004,005,006,007,008,009,010,011,012,013,014,015
  db 016,017,018,019,020,021,022,023,024,025,026,027,028,029,030,031
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 001,015,044,084,072,085,082,043,050,052,079,089,010,009,022,021
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 112,114,115,117,119,120,121,123,124,125,014,012,097,100,103,018
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 069,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 226,228,230,232,234,236,238,240,242,244,246,054,081,055,027,003
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 042,197,199,201,203,205,207,209,211,213,215,217,219,221,223,225
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 227,229,231,233,235,237,239,241,243,245,247,056,105,057,033,063
   ;                                               
  db 111,111,111,111,111,111,128,111,036,104,106,042,043,139,009,145
   ;                                               
  db 151,153,168,111,111,181,183,066,194,117,119,130,076,140,146,152
   ;                                               
  db 154,155,169,182,126,131,133,135,137,141,143,114,147,149,048,049
   ;                                               
  db 110,110,110,110,110,156,158,160,162,110,110,110,110,164,166,110
   ;                                               
  db 110,110,110,110,110,110,170,172,110,110,110,110,110,110,100,174
   ;                                               
  db 177,179,186,188,190,190,127,132,134,110,110,110,110,136,138,110
   ;                                               
  db 142,144,148,150,157,159,161,163,165,167,171,173,175,176,178,024
   ;                                               
  db 007,091,180,187,189,064,181,029,045,030,193,184,185,195,110,112


;
; ---------------------------------------------------------------
;
;      World Trade Case Mappings for Code Page 869
;
; ---------------------------------------------------------------
;
Greek_869_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","",""," ","",""," ","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\font_win\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\font_win\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\country\nls866.inc ===
;
; -----------------------------------------
;
;     Collating Table(s) for Code Page 866
;
; -----------------------------------------
;
Russian_866_collate label word
 ctable  <,'COLLATE',256>
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
  db 254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254
   ;      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
  db 001,008,016,030,025,031,028,015,017,018,026,032,005,004,011,010
   ;  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
  db 038,039,040,041,042,043,044,045,046,047,007,006,033,034,035,009
   ;  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
  db 024,049,051,053,055,057,059,061,063,065,067,069,071,073,075,077
   ;  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
  db 079,081,083,085,087,089,091,093,095,097,099,019,027,020,013,002
   ;  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
  db 012,048,050,052,054,056,058,060,062,064,066,068,070,072,074,076
   ;  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   
  db 078,080,082,084,086,088,090,092,094,096,098,021,036,022,014,172
   ;                                               
  db 101,103,105,107,109,111,115,117,119,121,123,125,127,129,131,133
   ;                                               
  db 135,137,139,141,143,145,147,149,151,153,155,157,159,161,163,165
   ;                                               
  db 100,102,104,106,108,110,114,116,118,120,122,124,126,128,130,132
   ;                                               
  db 240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240
   ;                                               
  db 240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240
   ;                                               
  db 240,240,240,240,240,240,240,240,240,240,240,240,240,240,240,240
   ;                                               
  db 134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164
   ;                                               
  db 113,112,167,166,169,168,171,170,037,037,037,173,029,025,240,255


;
; ---------------------------------------------------------------
;
;      World Trade Case Mappings for Code Page 866
;
; ---------------------------------------------------------------
;
Russian_866_ucase label word
 ctable  <,'UCASE  ',128>
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db 176,177,178,179,180,"","","","",185,186,187,188,"","",191
   ;                                               
  db 192,193,194,195,196,197,"","",200,201,202,203,204,205,206,""
   ;                                               
  db "","","","","","","","","",217,218,219,220,"","",223
   ;                                               
  db "","","","","","","","","","","","","","","",""
   ;                                               
  db "","","","","","","","","","","","","","",254,255


ru866_lcase        label   word
		ctable <,'LCASE ',256>
		db        0,  1,  2,  3,  4,  5,  6,  7
		db        8,  9, 10, 11, 12, 13, 14, 15
		db       16, 17, 18, 19, 20, 21, 22, 23
		db       24, 25, 26, 27, 28, 29, 30, 31
		db      " ","!",'"',"#","$","%","&","'"
		db      "(",")","*","+",",","-",".","/"
		db      "0","1","2","3","4","5","6","7"
		db      "8","9",":",";","<","=",">","?"
		db      "@","a","b","c","d","e","f","g"
		db      "h","i","j","k","l","m","n","o"
		db      "p","q","r","s","t","u","v","w"
		db      "x","y","z","[","\","]","^","_"
		db      "`","a","b","c","d","e","f","g"
		db      "h","i","j","k","l","m","n","o"
		db      "p","q","r","s","t","u","v","w"
		db      "x","y","z","{","|","}","~",127
		db      "","","","","","","",""   ; 80..87
		db      "","","","","","","",""   ; 88..8f
		db      "","","","","","","",""   ; 90..97
		db      "","","","","","","",""   ; 98..9f
		db      "","","","","","","",""   ; a0..a7
		db      "","","","","","",'',''   ; a8..af
		db      176,177,178,179,180,"","",""   ; b0..b7
		db      "",185,186,187,188,"","",191   ; b8..bf
		db      192,193,194,195,196,197,"",""   ; c0..c7
		db      200,201,202,203,204,205,206,""   ; c8..cf
		db      "","","","","","","",""   ; d0..d7
		db      "",217,218,219,220,"","",223   ; d8..df
		db      "","","","","","","",""   ; e0..e7
		db      "","","","","","","",""   ; e8..ef
		db      "","","","","","","",""   ; f0..f7
		db      "","","","","","",254,255   ; f8..ff
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\font_win\font_win.inc ===
;----------------------------------------------------------------------------;
;			Define macros
;----------------------------------------------------------------------------;

ShowStr MACRO str
    mov	    dx, offset str
    mov     ah, 9
    int     21h
ENDM

BOP MACRO func

	db	0c4h,0c4h,func
;	jmp	cs:[pass_disp_add]
;	int	44h
ENDM

;----------------------------------------------------------------------------;
;                          Flags & Numeric Equates                
;----------------------------------------------------------------------------;

MAX_LOW	EQU	25		; Max low count
MAX_CUL	EQU	80		; Max culumn count
MaxFunc	EQU	1Dh		; int 10h max function No.
MaxCmd 	EQU     24              ; max command code for DOS 3.2+
cr      EQU     0Dh             ; carriage return
lf      EQU     0Ah             ; linefeed
eom     EQU     '$'             ; end-of-message signal
space   EQU     20h             ; ascii space
tab     EQU     09h             ; ascii tab

VECTOR_SEG	EQU	0000h	; Interrupt Vector segment
WORK_SEG	EQU	0040h	; BIOS work area segment
FULLSCREEN	EQU	1

; definition of a Request Header structure so that we can access its elements. 
; this structure is not exhaustive at all: block device use some addresses for
; different purposes, and have data beyond the cmd_seg word.


REQ_HEADER      STRUC
	lengt   DB    ?               ; request header length
	unit    DB    ?               ; unit number (for Block Devs. only)
	ccode   DB    ?               ; command code
	stat    DW    ?               ; status word
	reserv  DB 8 DUP(?)           ; reserved for DOS us
	media   DB    ?               ; Media ID    (for Block Devs. only)
	xfer    DW    ?               ; offset of data buffer
	xseg    DW    ?               ; segment of data buffer
	cmd_off	DW    ?               ; count of bytes in request, or
	cmd_seg DW    ?               ; segment of CONFIG.SYS line
REQ_HEADER      ENDS

; values for the different 'magic numbers' used with Device Drivers

fNEXTLINK   EQU -1              ; word to tell DOS to substitute by address of
				; next device
fCHARDEVICE EQU 8000h           ; bit to define device as a character device
fOPENCLOSE  EQU 0040h           ; bit to indicate that device supports open/close
fDONE       EQU 0100h           ; Status Done bit meaning device is done
fERROR      EQU 8000h           ; Status Error bit meaning error on operation
fWRITE_E    EQU 000Ah           ; Write Fault Error bit
fREAD_E     EQU 000Bh           ; Read Fault Error bit
fUNKNOWN_E  EQU 0003h           ; Unknown Command Error bit

; values for the search flags used by Write Routine

fDELETE EQU     2
fINSERT EQU     4
fSEARCH EQU     8
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\disp_win\disp_win.asm ===
;
; Windows-NT MVDM Japanese DOS/V $DISP.SYS Dispatch Driver (High)
;

	.286
	include struc.inc
	include disp_win.inc
	include vint.inc

;----------------------------------------------------------------------------;
;                             Code Segment                                   
;----------------------------------------------------------------------------;
TEXT	segment byte public
	assume	cs:TEXT,ds:TEXT,es:TEXT

	org     0               ; drivers should start at address 0000h
	                        ; this will cause a linker warning - ignore it.

	public	Header
Header:                         ; device driver header
	DD	fNEXTLINK       ; link to next device driver
	DW	fCHARDEVICE+fOPENCLOSE  ; device attribute word: 
					; char.device+open/close
	DW	Strat           ; 'Strat' entry point
	DW	Intr            ; 'Intr' entry point
	DB	'NTDISP2$'      ; logical device name (needs to be 8 chars)


;----------------------------------------------------------------------------;
; data variables
;----------------------------------------------------------------------------;

	public	null
null     	dw      0       ; dummy to do a quick erase of pAtomValue
pAtomVal 	dw offset null  ; pointer to value of result of atom search
MemEnd   	dw  ddddhList   ; end of used memory:      initially AtomList
MaxMem   	dw  ddddhList   ; end of available memory: initially AtomList
lpHeader	dd      0       ; far pointer to request header
org_int10_add	dd	0	; $disp.sys's int10 vector
new_int10_add	dd	0	; $disp.sys's int10 vector
pass_disp_add	dd	0	; Original int10 vector
org_int08_add	dd	0	; original int 08 vector
dbcs_vector	dd	0	; DBCS Vector address
use_ntdisp_flag	db	0
display_mode	db	3
window_mode	db	0
nt_cons_mode	db	0
disp_init_flag	db	0
;; #3086: VDM crash when exit 16bit apps of video mode 11h
;; 12/9/93 yasuho
IMEStatusLines	db	0

setmode_flag	db      0	; for IME status line
cursor_pos	dw	0050h
		dw	0040h
cursor_type	dw	0060h
		dw	0040h
bios_disp_mode	dw	0049h
		dw	0040h
bios_disp_hight	dw	0085h
		dw	0040h

packet_len	dw	30
video_buffer	dw	0
		dw	0
dmode_add	dw	0
		dw	0
windowed_add	dw	0
		dw	0
nt_cons_add	dw	0
		dw	0
disp_sys_init	dw	0
		dw	0

fullsc_resume_ptr   dw	0
		    dw	0
ias_setmode_add dw	0
		dw	0
;----------------------------------------------------------------------------;
; Dispatch table for the interrupt routine command codes                     
;----------------------------------------------------------------------------;

	public	Dispatch
Dispatch:                       
	DW    Init            ;  0 = init driver 
	DW    Error           ;  1 = Media Check         (block devices only) 
	DW    Error           ;  2 = build BPB           (block devices only)
	DW    Error           ;  3 = I/O control read         (not supported)
	DW    Error           ;  4 = read (input) from device  (int 21h, 3Fh)
	DW    Error           ;  5 = nondestructive read      (not supported)  
	DW    Error           ;  6 = ret input status        (int 21h, 4406h) 
	DW    Error           ;  7 = flush device input buffer (not supportd)         
	DW    Error           ;  8 = write (output) to device  (int 21h, 40h)
	DW    Error           ;  9 = write with verify (== write)  (21h, 40h)
	DW    Error           ; 10 = ret output status       (int 21h, 4407h)
	DW    Error           ; 11 = flush output buffer      (not supported) 
	DW    Error           ; 12 = I/O control write        (not supported)
	DW    Success         ; 13 = device open               (int 21h, 3Dh)
	DW    Success         ; 14 = device close              (int 21h, 3Eh)
	DW    Error           ; 15 = removable media     (block devices only)
	DW    Error           ; 16 = Output until Busy   (mostly for spooler)
	DW    Error           ; 17 = not used
	DW    Error           ; 18 = not used
	DW    Error           ; 19 = generic IOCTL            (not supported)
	DW    Error           ; 20 = not used
	DW    Error           ; 21 = not used
	DW    Error           ; 22 = not used
	DW    Error           ; 23 = get logical device  (block devices only)
	DW    Error           ; 24 = set logical device  (block devices only)

;----------------------------------------------------------------------------;
; Dispatch table for the int 10h routine command codes                     
;----------------------------------------------------------------------------;
	public	table_int10
table_int10:
	DW	mode_set	; 00 = Video mode set
	DW	ctype_set	; 01 = Cursor type set
	DW	cpos_set	; 02 = Cursor position set
	DW	cpos_get	; 03 = Cursor position get
	DW	go_disp_sys	; 04 = Not used
	DW	go_disp_sys	; 05 = Use $disp.sys
	DW	scroll_up	; 06 = Scroll up
	DW	scroll_down	; 07 = Scroll down
	DW	read_cell	; 08 = read chractor with attribute
	DW	write_cell	; 09 = write chractor with attribute
	DW	write_char	; 0A = write chractor
	DW	go_disp_sys	; 0B = Not used
	DW	go_disp_sys	; 0C = Use $disp.sys
	DW	go_disp_sys	; 0D = Use $disp.sys
	DW	write_tty	; 0E = write teletype
	DW	disply_get	; 0F = get display status
	DW	palet_set	; 10 = set palet registor
	DW	char_set	; 11 = set sbcs charactor
	DW	go_disp_sys	; 12 = Not used
	DW	write_string	; 13 = read / write string
	DW	go_disp_sys	; 14 = Not used
	DW	go_disp_sys	; 15 = Not used
	DW	go_disp_sys	; 16 = Not used
	DW	go_disp_sys	; 17 = Not used
	DW	go_disp_sys	; 18 = Use $disp.sys
	DW	go_disp_sys	; 19 = Not used
	DW	go_disp_sys	; 1A = Use $disp.sys
	DW	go_disp_sys	; 1B = Not used
	DW	go_disp_sys	; 1C = Not used
	DW	getset_status	; 1D = IME status line manipulate functions

;; #3176: vz display white letter on white screen
;; 11/27/93 reviewed by yasuho
;;
;; save buffer for color palette and overscan registers.
;; what we did is we grab an initial set of there values, put it here and
;; then monitor int10 ah=10xx function to update these value accordiningly
;; so when win->fullscreen or reenter fullscreen happens, we know what
;; should be the palette/overscan/DAC should be and retore them
;; The reason that we are doing this is because console has differernt
;; palette and DAC(only the first 16 colors).
NUM_PALETTE_REGISTERS	equ	16
	public	Palette_Registers
Palette_Registers   label   BYTE
	DB	NUM_PALETTE_REGISTERS dup(?)

Over_Scan_Register  label   byte
	DB	?

NUM_DAC_REGISTERS	equ	256
	public	DAC_Registers
DAC_Registers	    label   BYTE
	DB	NUM_DAC_REGISTERS * 3 dup(?);

;; #3741: WordStar6.0: Hilight color is changed after running in window
;; 12/2/93 yasuho
	public	Default_Palette_Regs
Default_Palette_Regs	label	byte
	DB	NUM_PALETTE_REGISTERS dup(?)
Default_Over_Scan_Regs	label	byte
	DB	?
Default_DAC_Regs	label	byte
	DB	16 * 3 dup(?);


;; #4210: Status of $IAS not display in full-screen
;; 12/16/93 yasuho
IMEStat_buffer	db	160 dup(?)

;----------------------------------------------------------------------------;
; Strategy Routine
;----------------------------------------------------------------------------;
; device driver Strategy routine, called by MS-DOS kernel with
; ES:BX = address of request header
;----------------------------------------------------------------------------;

	public	Strat
Strat   PROC FAR
	mov     word ptr cs:[lpHeader], bx      ; save the address of the 
	mov     word ptr cs:[lpHeader+2], es    ; request into 'lpHeader', and
	ret                                     ; back to MS-DOS kernel
Strat   ENDP


;----------------------------------------------------------------------------;
; Intr
;----------------------------------------------------------------------------;
; Device driver interrupt routine, called by MS-DOS kernel after call to     
; Strategy routine                                                           
; This routine basically calls the appropiate driver routine to handle the
; requested function. 
; Routines called by Intr expect:
;       ES:DI   will have the address of the request header
;       DS      will be set to cs
; These routines should only affect ax, saving es,di,ds at least
;
; Input: NONE   Output: NONE   -- data is transferred through request header
;
;----------------------------------------------------------------------------;

	public	Intr
Intr    PROC FAR
	push	ds
	push	es
	pusha                   ; save registers
	pushf                   ; save flags
	cld                     ; direction flag: go from low to high address
				
	mov     si, cs          ; make local data addressable
	mov     ds, si          ; by setting ds = cs
			
	les     di, [lpHeader]  ; ES:DI = address of req.header

	xor     bx, bx        ; erase bx
	mov     bl,es:[di].ccode ; get BX = command code (from req.header)
	mov	si,bx
	shl	si,1
	add	si,offset dispatch
	
	.IF <bx gt MaxCmd>                ; check to make sure we have a valid
		call    Error             ; command code
	.ELSE                             ; else, call command-code routine,  
		call    [si]              ; indexed from Dispatch table
	.ENDIF                            ; (Ebx used to allow scaling factors)

	or      ax, fDONE       ; merge Done bit into status and
	mov     es:[di].stat,ax ; store status into request header
	
	popf                    ; restore registers
	popa                    ; restore flags
	pop	es
	pop	ds
	ret                     ; return to MS-DOS kernel
Intr    ENDP

;----------------------------------------------------------------------------;
; Success: When the only thing the program needs to do is set status to OK 
;----------------------------------------------------------------------------;

	public	Success
Success PROC NEAR
	xor     ax, ax          ; set status to OK
	ret
Success ENDP

;----------------------------------------------------------------------------;
; error: set the status word to error: unknown command                       
;----------------------------------------------------------------------------;
	public	Error
Error   PROC    NEAR            
	mov     ax, fERROR + fUNKNOWN_E  ; error bit + "Unknown command" code
	ret                     
Error   ENDP

;----------------------------------------------------------------------------;
; Int10_dispatch: 
;----------------------------------------------------------------------------;

	public	Int10_dispatch
Int10_dispatch PROC FAR

if (MAX_ROW * MAX_COL * 4) GT 0FFFFh
	.err
	%out	MAX_ROW or MAX_COL out of range
endif
	.IF <cs:[setmode_flag] ne 0>   ; flag is set by nt_resume_event_thread
		.IF <ah eq 0>
			mov	cs:[setmode_flag],0	; clear
			jmp	simulate_iret 		; no call original
		.ENDIF
	.ENDIF

	mov	cs:[use_ntdisp_flag],1
	push	bx
	push	ax
	mov	bx,ax
	push	es
	push	di
	.IF <cs:[disp_init_flag] eq 0>
		mov	ax,0003h	; Clear display
		BOP	42h
;		call	reenter_win
		mov	cs:[disp_init_flag],1
	.ENDIF
	les	di,dword ptr cs:[dbcs_vector]
	mov	ax,word ptr es:[di]

	.IF <cs:[nt_cons_mode] eq 1>			; Check Re-enter
		.IF <ax eq 0>				; Check SBCS or DBCS
			mov	cs:[active_cp],CP_US	; Set bilingal US
                .ELSE
ifdef JAPAN
                        mov     cs:[active_cp],CP_JP    ; Set bilingal JAPAN
endif
ifdef KOREA
                        mov     cs:[active_cp],CP_KO    ; Set bilingal KOREA
endif
                .ENDIF
	.ENDIF

	.IF <ax eq 0>					; Check SBCS world
; Not nessesary after build #26
;		.IF <cs:[nt_cons_mode] eq 1>		; Re-enter
;			call	reenter_fullsc
;			mov	cs:[nt_cons_mode],0
;		.ENDIF

		pop	di
		pop	es
		pop	ax
		pop	bx
		pushf
		call	cs:[pass_disp_add]		; Go SBCS world
		mov	cs:[use_ntdisp_flag],0
		jmp	simulate_iret
	.ENDIF
	
; williamh - The following checks are not necessary.
;	     When nt_event_event_thread get called, the video
;	     state is in console's default and we have no idea
;	     what it is at this moment so we have to reset the
;	     video to what we know - that is why reenter_win and
;	     reenter_fullsc for. If DBCS mode is enabled and the
;	     video mode is in  SBCS graphic mode, we still have
;	     to reset the video, otherwise, the underneath driver
;	     will get confused.
;	     This reenter_win and reenter_fulsc are very very costy
;	     and we have to find ways to get rid of them if possible.
;
;
;	.IF <bh ne 00h>					; Check SBCS mode
;		mov	al,cs:[display_mode]
;		.IF <al ne 03h> and
;		.IF <al ne 11h> and
;		.IF <al ne 12h> and
;		.IF <al ne 72h> and
;		.IF <al ne 73h>
;			pop	di
;			pop	es
;			pop	ax
;			pop	bx
;			pushf
;			call	cs:[pass_disp_add]	; Go SBCS world
;			mov	cs:[use_ntdisp_flag],0
;			jmp	simulate_iret
;		.ENDIF
;	.ENDIF
IFDEF _X86_			; By DEC-J. On ALPHA windowed_add is meanless.
	les	di,dword ptr cs:[windowed_add]
	mov	al,es:[di]

	.IF <al eq FULLSCREEN>
;		.IF <cs:[nt_cons_mode] eq 1>		; Re-enter
;			call	reenter_fullsc
;			mov	cs:[nt_cons_mode],0
;			mov	cs:[window_mode],al
;		.ENDIF

		.IF <al ne cs:[window_mode]>		; Win->Fullsc switched
			call	wintofullsc
		.ENDIF

	.ELSE
;		.IF <cs:[nt_cons_mode] eq 1>		; Re-enter
;			call	reenter_win
;			mov	cs:[nt_cons_mode],0
;		.ENDIF
		.IF <bh eq 00h>				; Win->Fullsc switch
;			.IF <bl eq 03h> or
;			.IF <bl eq 73h> or
			.IF <bl eq 04h> or
			.IF <bl eq 05h> or
			.IF <bl eq 06h> or
			.IF <bl eq 0dh> or
			.IF <bl eq 0eh> or
			.IF <bl eq 0fh> or
			.IF <bl eq 10h> or
			.IF <bl eq 11h> or
			.IF <bl eq 12h> or
			.IF <bl eq 13h> or
			.IF <bl eq 72h>
				call	wintofullsc
				mov	cs:[nt_cons_mode],0
				mov	al,FULLSCREEN
			.ENDIF
		.ENDIF
	.ENDIF

	mov	cs:[window_mode],al
ENDIF ;_ALPHA_
	pop	di
	pop	es
	pop	ax
	pop	bx

	.IF <ah eq 0feh>
		jmp	teach_buffer
	.ENDIF
	.IF <ah eq 0ffh>
		jmp	refresh_buffer
	.ENDIF
	.IF <ah be MaxFunc>
		push	si
		push	ax
		xchg	ah,al
		xor	ah,ah
		shl	ax,1
		mov	si,offset cs:table_int10
		add	si,ax
		pop	ax
		jmp     cs:[si]
	.ENDIF

	public	go_org_int10
go_org_int10	label	near
		pushf
		call	cs:org_int10_add		;go to original int10
		mov	cs:[use_ntdisp_flag],0
		jmp	simulate_iret
Int10_dispatch ENDP

	public	mode_set
mode_set	proc	near
		pop	si
IFDEF _X86_			; By DEC-J.
		mov	cs:[display_mode],al
		.IF <cs:[window_mode] ne FULLSCREEN>
ELSE
		mov	ah, al
		and	ah, 7fh
		mov	cs:[display_mode], ah
		.IF <ah eq 03h> or
		.IF <ah eq 73h>
			mov	ah,0
			.IF< cs:[window_mode] eq FULLSCREEN>
			;tobu tori atowo nigosu ichitaro.
				pushf
				call	cs:org_int10_add
				mov cs:[window_mode], 0
			.ENDIF
ENDIF ;_ALPHA_
			BOP	42h
			mov	cs:[use_ntdisp_flag],0
			jmp	simulate_iret
		.ENDIF
IFNDEF _X86_			; By DEC-J.
		mov	ah, 0
		.IF< cs:[window_mode] ne FULLSCREEN>
			call wintofullsc	;for initialize $disp.sys
			mov cs:[window_mode], FULLSCREEN
		.ENDIF
ENDIF ;_ALPHA_
		jmp	go_org_int10
mode_set	endp

	public	cpos_get
cpos_get	proc	near
cpos_set	label	near
ctype_set	label	near
read_cell	label	near
disply_get	label	near
palet_set	label	near
		pop	si
		.IF <cs:[window_mode] ne FULLSCREEN>
			BOP	42h
			mov	cs:[use_ntdisp_flag],0
			jmp	simulate_iret
		.ENDIF
		jmp	go_org_int10
cpos_get	endp

; MSKK kksuzuka #1223 9/7/94
; when dosshell is started with full screen, ntvdm must generate character
	public	char_set
char_set	proc	near
		pop	si
		.IF <cs:[window_mode] ne FULLSCREEN>
			BOP	42h
			mov	cs:[use_ntdisp_flag],0
			jmp	simulate_iret
		.ENDIF
		.IF <al eq 00h> or
		.IF <al eq 11h>
			BOP	42h
		.ENDIF
		jmp	go_org_int10
char_set	endp

;; #3741: WordStar6.0: Hilight color is changed after running in window
;; 11/27/93 yasuho
;;
;; restore palette/overscan and DAC registers

	public	restore_palette_regs
restore_palette_regs	proc	near
		mov	ax, cs
		mov	es, ax
		mov	dx, offset DAC_Registers
		mov	ax, 1012h
		mov	cx, NUM_DAC_REGISTERS
		xor	bx, bx
		pushf
		call	cs:[org_int10_add]

		mov	ax, cs
		mov	es, ax
		mov	dx, offset Palette_Registers
		mov	ax, 1002h
		pushf
		call	cs:[org_int10_add]

		ret
restore_palette_regs	endp

	public	write_cell
write_cell	proc	near
write_char	label	near
scroll_up	label	near
scroll_down	label	near
write_tty	label	near
write_string	label	near
		pop	si
		.IF <cs:[window_mode] ne FULLSCREEN>
			BOP	42h
;			call	get_vram
			mov	cs:[use_ntdisp_flag],0
			jmp	simulate_iret
		.ENDIF
		jmp	go_org_int10
write_cell	endp

;; #3086: VDM crash when exit 16bit apps of video mode 11h
;; 12/9/93 yasuho
;; IME status line monitoring function.
;; so far, we don't use this value.
	public	getset_status
getset_status	proc    near
		pop	si
		push	ax
		cmp	al, 0
		je	show_status_line
		cmp	al, 1
		jne	@F
hidden_status_line:
		xor	al, al
		jmp	set_IME_info
show_status_line:
		mov	al, bl
set_IME_info:
		mov	cs:[IMEStatusLines], al
;; #4183: status line of oakv(DOS/V FEP) doesn't disappear
;; 12/11/93 yasuho
		mov	ah, 23h		; also tell to NTVDM
		BOP	43h
@@:
		pop	ax
		jmp	go_org_int10
getset_status	endp

	public	teach_buffer
teach_buffer    proc    near
ifdef JAPAN
		.IF <cs:[window_mode] ne FULLSCREEN>
			push	ax
			push	es
			push	di
			les	di,dword ptr cs:[bios_disp_mode]
			mov	al,byte ptr es:[di]
			pop	di
			pop	es
			.IF <al eq 3>
				mov	ax,cs:[video_buffer+0]
				mov	di,ax
				mov	ax,cs:[video_buffer+2]
				mov	es,ax
			.ENDIF
			pop	ax
			jmp	simulate_iret
                .ENDIF
                jmp     go_org_int10
endif
ifdef KOREA     ; WriteTtyInterim
                jmp     go_org_int10
endif
teach_buffer    endp

	public	refresh_buffer
refresh_buffer	proc	near
		.IF <cs:[window_mode] ne FULLSCREEN>
;			call	put_vram
			BOP	43h
			mov	cs:[use_ntdisp_flag],0
			jmp	simulate_iret
		.ENDIF
		jmp	go_org_int10
refresh_buffer	endp

	public	go_disp_sys
go_disp_sys	proc	near
		pop	si
		jmp	go_org_int10
go_disp_sys	endp

if 0
	public	get_vram
get_vram	proc	near
		push	ax
		push	cx
		push	si
		push	di
		push	ds
		push	es
		pushf
		mov	di,cs:[video_buffer+0]
		mov	es,cs:[video_buffer+2]
		xor	si,si
		mov	ax,0b800h
		mov	ds,ax
		.IF <cs:[display_mode] eq 73h>
			mov	cx,MAX_ROW*MAX_COL*4
		.ELSE
			mov	cx,MAX_ROW*MAX_COL*2
		.ENDIF
		cld
		shr	cx,1
		rep	movsw
		adc	cx, 0
		rep	movsb
		popf
		pop	es
		pop	ds
		pop	di
		pop	si
		pop	cx
		pop	ax
		ret
get_vram	endp

	public	put_vram
put_vram	proc	near
		push	ax
		push	cx
		push	si
		push	di
		push	ds
		push	es
		pushf
		mov	si,cs:[video_buffer+0]
		mov	ds,cs:[video_buffer+2]
		xor	di,di
		mov	ax,0b800h
		mov	es,ax
		.IF <cs:[display_mode] eq 73h>
			mov	cx,MAX_ROW*MAX_COL*4
		.ELSE
			mov	cx,MAX_ROW*MAX_COL*2
		.ENDIF
		cld
		shr	cx,1
		rep	movsw
		adc	cx,0
		rep	movsb
		popf
		pop	es
		pop	ds
		pop	di
		pop	si
		pop	cx
		pop	ax
		ret
put_vram	endp
endif

	public	wintofullsc
wintofullsc	proc	near
		pusha
		push	es
;; save max rows number because we are going to set video mode
;; which will reset this value and the IME got messed up.
;; #3086: VDM crash when exit 16bit apps of video mode 11h
;; 12/9/93 yasuho
;;		push	es
;;		mov	ax, 40h
;;		mov	es, ax
;;		mov	al, es:[84h]
;;		push	ax
IFDEF _X86_			; By DEC-J
		mov	ah,03h
		mov	bh,00h
		pushf
		call	cs:[pass_disp_add]
		push	dx
		push	cx

		mov	ax,2100h			; Save Text
		.IF <cs:[display_mode] eq 73h>
			mov	cx,MAX_ROW*MAX_COL*4
		.ELSE
			mov	cx,MAX_ROW*MAX_COL*2
		.ENDIF
		les	di,dword ptr cs:[video_buffer]
		bop	43h

ENDIF ;_ALPHA_
		mov	ah,0
IFDEF _X86_ ;DEC-J
		mov	al,cs:[display_mode]		; Set display mode
ELSE
		mov	al, 03h
ENDIF ;_ALPHA_ DEC-J
		pushf
		call	cs:[org_int10_add]
;; #3176: vz display white letter on white screen
;; 11/27/93 reviewed by yasuho
;;
;; restore color states after set mode
		mov	ax, cs
		mov	es, ax
		mov	di, offset Palette_Registers
		mov	ax, 2200h			; get palette/DAC
		BOP	43h
		call	restore_palette_regs

IFDEF _X86_			; By DEC-J
		mov	ax,2101h			; Restore Text
		.IF <cs:[display_mode] eq 73h>
			mov	cx,MAX_ROW*MAX_COL*4
		.ELSE
			mov	cx,MAX_ROW*MAX_COL*2
		.ENDIF
		les	di,dword ptr cs:[video_buffer]
		bop	43h

;		mov	ax,0012h			; Set display mode
;		pushf
;		call	cs:[pass_disp_add]

;		les	di,dword ptr cs:[bios_disp_mode]; Set display mode
;		mov	byte ptr es:[di],3

		.IF <cs:[display_mode] eq 73h>
			push	bp
			les	bp,dword ptr cs:[video_buffer]; Refresh display
			mov	cx,MAX_ROW*MAX_COL
			mov	dx,0
			mov	bh,0
			mov	ax,1321h
			pushf
			call	cs:[org_int10_add]
			pop	bp
		.ELSE
ENDIF ;_ALPHA_
			les	di,dword ptr cs:[video_buffer]; Refresh display
			mov	cx,MAX_ROW*MAX_COL
			mov	ah,0ffh
			pushf
			call	cs:[org_int10_add]
IFDEF _X86_			; By DEC-J
		.ENDIF

		pop	cx
;		les	di,dword ptr cs:[cursor_type]	; Set cursor type
;		mov	cx,es:[di]
		mov	ah,01h
		pushf
		call	cs:[org_int10_add]

		pop	dx
;		les	di,dword ptr cs:[cursor_pos]	; Set cursor position
;		mov	dx,es:[di]
		mov	bh,0
		mov	ah,02h
		pushf
		call	cs:[org_int10_add]
ENDIF ;_ALPHA_
;; #3086: VDM crash when exit 16bit apps of video mode 11h
;; 12/9/93 yasuho
		mov	ax, 40h
		mov	es, ax
		mov	al, es:[84h]
		sub	al, cs:[IMEStatusLines]
		mov	es:[84h], al		; #3019: incorrect cursor pos.
						; 10/29/93 yasuho
		pop	es
		popa
		ret
wintofullsc	endp

	public	reenter_fullsc
reenter_fullsc	proc	near
		push	es
		push	ds
		pusha
;; #3741: WordStar6.0: Hilight color is changed after running in window
;; 11/27/93 yasuho
;;
;; restore palette and DAC register if SBCS world
		les	di, dword ptr cs:[dbcs_vector]
		cmp	word ptr es:[di], 0	; DBCS mode ?
		jnz	short @F		; yes
		mov	ax, cs
		mov	es, ax
		mov	dx, offset Default_DAC_Regs
		mov	ax, 1012h
		mov	cx, 16
		xor	bx, bx
		pushf
		call	cs:[org_int10_add]	; restore DAC registers
		mov	dx, offset Default_Palette_Regs
		mov	ax, 1002h
		pushf
		call	cs:[org_int10_add]	; restore palette registers
		jmp	exit_reenter_fullsc
@@:

;; save max rows number because we are going to set video mode
;; which will reset this value and the IME got messed up.
;; #3086: VDM crash when exit 16bit apps of video mode 11h
;; 12/2/93 yasuho
;;		mov	ax, 40h
;;		mov	es, ax
;;		mov	al, es:[84h]
;;		push	ax
;; #4210: Status of $IAS not display in full-screen
;; 12/16/93 yasuho
;; save IME status lines if IME is active
;; NOTE: This is easy fix. We should save the # of IME status lines
;; in the future.
		cmp	cs:[IMEStatusLines], 0
		je	short @F
		lds	si, dword ptr cs:[video_buffer]
		add	si, 24*160
		mov	di, offset IMEstat_buffer
		mov	ax, cs
		mov	es, ax
		mov	cx, 160
		cld
		rep movsb
@@:

IFDEF _X86_			; By DEC-J
		mov	ah,03h
		mov	bh,00h
		pushf
		call	cs:[pass_disp_add]
		push	dx
		push	cx

;; #3086: VDM crash when exit 16bit apps of video mode 11h
;; 12/2/93 yasuho
;;		les	di,dword ptr cs:[video_buffer]
;;		mov	ax,2100h			; Save Text
;;		mov	cx,MAX_ROW*MAX_COL*2
;;		bop	43h
ENDIF ;_ALPHA_

		les	di,dword ptr cs:[bios_disp_mode]
		mov	ah,0
		mov	al,es:[di]			; Set display mode
		pushf
		call	cs:[org_int10_add]
IFDEF _X86_			; By DEC-J
;		mov	ax,0b800h
;		mov	es,ax
;		xor	di,di
;		mov	ah,0feh				; Get video buffer
;		pushf
;		call	cs:[org_int10_add]
;		mov	ax,es
;		mov	cs:[video_buffer+0],di
;		mov	cs:[video_buffer+2],ax

;; #3086: VDM crash when exit 16bit apps of video mode 11h
;; 12/2/93 yasuho
		les	di,dword ptr cs:[video_buffer]
		mov	ax,2103h			; Restore Text
		mov	cx,MAX_ROW*MAX_COL*2
		bop	43h

;; #4210: Status of $IAS not display in full-screen
;; 12/16/93 yasuho
;; restore IME status lines if IME is active
;; NOTE: This is easy fix. We should save the # of IME status lines
;; in the future.
		cmp	cs:[IMEStatusLines], 0
		je	short @F
		mov	si, offset IMEstat_buffer
		mov	ax, cs
		mov	ds, ax
		les	di, dword ptr cs:[video_buffer]
		add	di, 24*160
		mov	cx, 160
		cld
		rep movsb
@@:

ENDIF ;_ALPHA_
		les	di,dword ptr cs:[video_buffer]	; Refresh display
		mov	cx,MAX_ROW*MAX_COL
		mov	ah,0ffh
		pushf
		call	cs:[org_int10_add]

IFDEF _X86_			; By DEC-J
		pop	cx
		mov	ah,01h
		pushf
		call	cs:[org_int10_add]

		pop	dx
		mov	bh,0
		mov	ah,02h
		pushf
		call	cs:[org_int10_add]
ENDIF ;_ALPHA_
;; #3086: VDM crash when exit 16bit apps of video mode 11h
;; 12/2/93 yasuho
		mov	ax, 40h
		mov	es, ax
		mov	al, es:[84h]
		sub	al, cs:[IMEStatusLines]
		mov	es:[84h], al
exit_reenter_fullsc:
		popa
		pop	ds
		pop	es
		BOP	0FEh
reenter_fullsc	endp

	public	reenter_win
reenter_win	proc	near
;		pusha
;
;		mov	ax,0b800h
;		mov	es,ax
;		xor	di,di
;		mov	ah,0feh				; Get video buffer
;		pushf
;		call	cs:[org_int10_add]
;		mov	ax,es
;		mov	cs:[video_buffer+0],di
;		mov	cs:[video_buffer+2],ax
;
;		call	get_vram
;
;		popa
		ret
reenter_win	endp

;----------------------------------------------------------------------------;
; Int08_dispatch: 
;----------------------------------------------------------------------------;

	public	Int08_dispatch
Int08_dispatch PROC FAR

	push	ax
	push	es
	push	di
	les	di,dword ptr cs:[dbcs_vector]
	mov	ax,word ptr es:[di]

	.IF <ax ne 0> 					; Check DBCS mode
		.IF <cs:[display_mode] eq 3> or		; Check TEXT mode
		.IF <cs:[display_mode] eq 73h>
			.IF <cs:[use_ntdisp_flag] eq 0>	; Check using int10h
;			les	di,dword ptr cs:[windowed_add]
;				mov	al,es:[di]
;				.IF <al eq FULLSCREEN> and	; Full-screen?
;				.IF <al ne cs:[window_mode]>	; Win->Fullsc
					call	wintofullsc
					mov	cs:[window_mode],FULLSCREEN
;				.ENDIF
			.ENDIF
		.ENDIF
	.ENDIF
	pop	di
	pop	es
	pop	ax

	BOP	0feh

	ret

Int08_dispatch ENDP

;----------------------------------------------------------------------------;
; Int2f (Bilingal function) dispatch from "biling.sys"
;----------------------------------------------------------------------------;

;Data area for bilingal system
	public	org_int2f_add
org_int2f_add   dd      ?
ifdef JAPAN
default_cp	dw	CP_JP
active_cp       dw      CP_JP
endif
ifdef KOREA
default_cp      dw      CP_KO
active_cp       dw      CP_KO
endif
video_flag      db      1


	public	biling_func_tbl
biling_func_tbl	label	word
	dw	get_ver
	dw	get_cp
	dw	regist_video
	dw	strip_video

BILING_FUNC_MAX	equ	($ - offset biling_func_tbl) / 2

	public	Int2f_dispatch
Int2f_dispatch PROC FAR
	cmp	ah,4fh
	jnz	biling_pass
	cmp	al,BILING_FUNC_MAX
	jae	biling_pass
	push	bx
	mov	bl,al
	xor	bh,bh
	shl	bx,1
	mov	ax,cs:[biling_func_tbl+bx]	; get subfunction address
	pop	bx
	call	ax			; execute subfunction
simulate_iret:
	FIRET
biling_pass:
	jmp	cs:[org_int2f_add]
Int2f_dispatch	ENDP

	public	get_ver
get_ver		proc	near
	mov	dl,MAJOR_VER
	mov	dh,MINOR_VER
	mov	ax,0
	ret
get_ver		endp

	public	get_cp
get_cp		proc	near

	;
	;	Reload active code page when code page changed
	;	ntraid:mskkbug#2708	10/13/93 yasuho
	;
	push	ds
	lds	bx,dword ptr cs:[dbcs_vector]
	mov	ax,word ptr [bx]
	pop	ds
	.IF <ax eq 0>				; Check SBCS or DBCS
		mov	ax,CP_US		; US
        .ELSE
ifdef JAPAN
                mov     ax,CP_JP                ; JAPAN
endif
ifdef KOREA
                mov     ax,CP_KO                ; KOREA
endif
        .ENDIF
	mov	cs:[active_cp],ax		; Set active code page
	mov	bx,cs:active_cp
	cmp	cs:video_flag,1
	jz	@f
	mov	bx,-1			; if DBCS video system is not available
@@:
	mov	ax,0
	ret
get_cp		endp

	public	regist_video
regist_video	proc	near
	mov	cs:video_flag,1
	mov	ax,0
	ret
regist_video	endp

	public	strip_video
strip_video	proc	near
	mov	cs:video_flag,0
	mov	ax,0
	ret
strip_video	endp


;----------------------------------------------------------------------------;
;****************************************************************************;
;----------------------------------------------------------------------------;
;                                                                            ;
;       BEGINNING OF SPACE TO BE USED AS DRIVER MEMORY                       ;
;       ALL CODE AFTER ATOMLIST WILL BE ERASED BY THE DRIVER'S DATA          ; 
;       OR BY OTHER LOADED DRIVERS                                           ;
;                                                                            ;
;----------------------------------------------------------------------------;
;****************************************************************************;
;----------------------------------------------------------------------------;


;----------------------------------------------------------------------------;
;                    Initialization Data and Code               
; Only needed once, so after the driver is loaded and initialized it releases
; any memory that it won't use. The device allocates memory for its own use
; starting from 'ddddlList'.
;----------------------------------------------------------------------------;

	public	ddddhList
ddddhList       label   near
ifndef KOREA
ini_msg	db "Windows-NT DISP.SYS Dispatch Driver 2 version 0.1"
        db lf,cr,eom
endif
err_msg	db "NTDISP1.SYS is not installed"
	db lf,cr,eom
devnam	db "NTDISP1$",0

	public	Init
Init    PROC NEAR
	push	ds
	push	es
	pusha

	les     di, [lpHeader]          ; allow us to use the request values

	mov     ax, MemEnd              ; set ax to End of Memory relative to
					; previous end of memory.
	mov     MaxMem, ax              ; store the new value in MaxMem 
	mov     es:[di].xseg,cs         ; tell MS-DOS the end of our used 
	mov     es:[di].xfer,ax         ; memory (the break address)

ifndef KOREA
        ShowStr ini_msg
endif

	mov	dx,offset devnam	; open ddddl.sys
	mov	ax,3d00h
	int	21h
	jnc	get_prev_int10_vector

not_install:
	ShowStr err_msg

	mov     es:[di].xfer,0          ; clean up memory (the break address)
	jmp	init_exit
	popa
;	xor	ax,ax
	mov	ax,0100h
	ret
	

get_prev_int10_vector:
	mov	bx,ax

                                        ; kksuzuka:#4041
        push    bx                      ; handle
        mov     ax,4400h
        int     21h                     ; get device data
        pop     bx
        jc      not_install
                                        ; dx=device word
        push    bx
        xor     dh,dh                   ; should not change
        or      dl,20h                  ; set binary mode
        mov     ax,4401h
        int     21h                     ; set device data
        pop     bx
        jc      not_install

	push	bx
	mov	dx,offset pass_disp_add	; get original int10 address
	mov	cx,4
	mov	ax,3f00h
	int	21h
	pop	bx			; close ddddl.sys
	mov	ax,3e00h
	int	21h

	mov	ax,0b800h
	mov	es,ax
	xor	di,di
	mov	ah,0feh			; Get video buffer
	int	10h
	mov	ax,es
	mov	[video_buffer+0],di
	mov	[video_buffer+2],ax

	mov	ax,offset display_mode	; Tell NTVDM Virtual TEXT V-RAM address
	mov	[dmode_add+0],ax	; ,display mode address
	mov	ax,ds			; and get Windowed flag address
	mov	[dmode_add+2],ax	; and tell Nt console mode flag add
	mov	ax,offset nt_cons_mode
	mov	[nt_cons_add+0],ax
	mov	ax,ds
	mov	[nt_cons_add+2],ax
	mov	ax,offset int08_dispatch
	mov	[disp_sys_init+0],ax
	mov	ax,cs
	mov	[disp_sys_init+2],ax
	mov	[fullsc_resume_ptr], offset reenter_fullsc
	mov	[fullsc_resume_ptr + 2], ax
	mov	[ias_setmode_add], offset setmode_flag
	mov	[ias_setmode_add + 2], ax
	mov	si,offset packet_len
	mov	ah,20h
	BOP	43h

	mov	ax,VECTOR_SEG			;Get original int10 vector
	mov	es,ax
	mov	ax,word ptr es:[4*10h+0]
	mov	word ptr [org_int10_add+0],ax
	mov	ax,word ptr es:[4*10h+2]
	mov	word ptr [org_int10_add+2],ax

	mov	ax,offset cs:Int10_dispatch	;Set my int10 vector
	mov	word ptr [new_int10_add+0],ax
	mov	word ptr es:[4*10h+0],ax
	mov	ax,cs
	mov	word ptr es:[4*10h+2],ax
	mov	word ptr [new_int10_add+2],ax

	push	ds
	mov	ax,6300h			; Get DBCS Vector address
	int	21h
	mov	bx,[si]
	mov	ax,ds
	pop	ds
	mov	word ptr [dbcs_vector+0],si
	mov	word ptr [dbcs_vector+2],ax

IFDEF _X86_			; By DEC-J
	les	di,dword ptr [windowed_add]
	mov	al,es:[di]
	.IF <al eq FULLSCREEN>
		mov	ah,03h
		mov	bh,00h
		pushf
		call	cs:[pass_disp_add]	; Save Cursor
		push	dx
		push	cx

		mov	ax,0003h		; set DOS/V text mode
		pushf
		call	[org_int10_add]

                ; kksuzuka #6168 set screen attibutes
		mov	ah,24h			; get console attributes
		BOP	43h
		shl	ax,8			; ah = console attributes
		mov	al,20h

		les	di,dword ptr cs:[video_buffer]	; DOS/V VRAM
		mov	cx,MAX_ROW*MAX_COL
		push	di
		push	es
		rep	stosw

		pop	es
		pop	di
		mov	cx,MAX_ROW*MAX_COL
		mov	ah,0ffh
		pushf
		call	cs:[org_int10_add]

		mov	[nt_cons_mode],0
		mov	[window_mode],FULLSCREEN
		mov	cs:[disp_init_flag],1

		pop	cx			; Restore cursor
		mov	ah,01h
		pushf
		call	cs:[org_int10_add]

		pop	dx
		mov	bh,0
		mov	ah,02h
		pushf
		call	cs:[org_int10_add]
	.ENDIF
ENDIF ;_ALPHA_
;; #3741: WordStar6.0: Hilight color is changed after running in window
;; 12/2/93 yasuho
;;
;; get initial color palette and DAC registers

	mov	ax, cs
	mov	es, ax
	mov	dx, offset Default_Palette_Regs
	mov	ax, 1009h
	pushf
	call	cs:[org_int10_add]

	mov	ax, cs
	mov	es, ax
	mov	dx, offset Default_DAC_Regs
	mov	ax, 1017h
	mov	cx, 16
	xor	bx, bx
	pushf
	call	cs:[org_int10_add]

	mov	ax,VECTOR_SEG
	mov	es,ax

;	mov	ax,word ptr es:[4*08h+0]	;Get original int08 vector
;	mov	word ptr [org_int08_add+0],ax
;	mov	ax,word ptr es:[4*08h+2]
;	mov	word ptr [org_int08_add+2],ax
;
;	mov	ax,offset cs:Int08_dispatch	;Set my int08 vector
;	mov	word ptr es:[4*08h+0],ax
;	mov	ax,cs
;	mov	word ptr es:[4*08h+2],ax

	mov	ax,word ptr es:[4*2fh+0]	;Get original int2f vector
	mov	word ptr [org_int2f_add+0],ax
	mov	ax,word ptr es:[4*2fh+2]
	mov	word ptr [org_int2f_add+2],ax

	mov	ax,offset cs:Int2f_dispatch	;Set my int2f vector
	mov	word ptr es:[4*2fh+0],ax
	mov	ax,cs
	mov	word ptr es:[4*2fh+2],ax

init_exit:
	popa
	pop	es
	pop	ds
;	xor	ax,ax
	mov	ax,0100h
	ret
Init	ENDP

TEXT	ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\ascii.inc ===
DW      0,0,0,0,0,0,0,0
        DW      0,0,0,1F00h,1010h,1010h,1010h,1010h
        DW      0,0,0,0F000h,1010h,1010h,1010h,1010h
        DW      1010h,1010h,1010h,1F10h,0,0,0,0
        DW      1010h,1010h,1010h,0F010h,0,0,0,0
        DW      1010h,1010h,1010h,1010h,1010h,1010h,1010h,1010h
        DW      0,0,0,0FF00h,0,0,0,0
        DW      0,0,0,3C18h,183Ch,0,0,0
        DW      0FFFFh,0FFFFh,0FFFFh,0C3E7h,0E7C3h,0FFFFh,0FFFFh,0FFFFh
        DW      0,0,1800h,663Ch,3C66h,18h,0,0
        DW      0FFFFh,0FFFFh,0E7FFh,99C3h,0C399h,0FFE7h,0FFFFh,0FFFFh
        DW      0,3E00h,1A0Eh,6C3Ah,0C6C6h,386Ch,0,0
        DW      0,1800h,663Ch,3C66h,7E18h,1818h,0,0
        DW      0,1000h,1C18h,1216h,7412h,60F0h,0,0
        DW      0,1907h,1917h,1111h,7F17h,60F6h,0,0
        DW      0,2442h,0E73Ch,4242h,3CE7h,4224h,0,0
        DW      1010h,1010h,1010h,0FF10h,1010h,1010h,1010h,1010h
        DW      0,0,0F03h,0FF3Fh,3FFFh,30Fh,0,0
        DW      0,1800h,7E3Ch,18DBh,7EDBh,183Ch,0,0
        DW      0,6600h,6666h,6666h,66h,6666h,0,0
        DW      0,7F00h,0DBDBh,7BDBh,1B1Bh,1B1Bh,0,0
        DW      1010h,1010h,1010h,0FF10h,0,0,0,0
        DW      0,0,0,0FF00h,1010h,1010h,1010h,1010h
        DW      1010h,1010h,1010h,0F010h,1010h,1010h,1010h,1010h
        DW      0,3C18h,0DB7Eh,1899h,1818h,1818h,0,0
        DW      1010h,1010h,1010h,1F10h,1010h,1010h,1010h,1010h
        DW      0,0,0C18h,0FF06h,6FFh,180Ch,0,0
        DW      0,0,3018h,0FF60h,60FFh,1830h,0,0
        DW      0,0,0C000h,0C0C0h,0C0C0h,0FEh,0,0
        DW      0,0,2400h,0FF66h,66FFh,24h,0,0
        DW      0,0,1818h,3C3Ch,7E7Eh,0FFFFh,0,0
        DW      0,0,0FFFFh,7E7Eh,3C3Ch,1818h,0,0
        DW      0,0,0,0,0,0,0,0
        DW      0,1800h,3C3Ch,183Ch,18h,1818h,0,0
        DW      0,6666h,4466h,0,0,0,0,0
        DW      0,6C00h,0FE6Ch,6C6Ch,0FE6Ch,6C6Ch,0,0
        DW      1800h,7C18h,0C2C6h,7CC0h,8606h,7CC6h,1818h,0
        DW      0,0,0C200h,0CC6h,3018h,0C666h,0,0
        DW      0,3800h,6C6Ch,7638h,0CCDCh,76CCh,0,0
        DW      0,3030h,6030h,0,0,0,0,0
        DW      0,0C00h,3018h,3030h,3030h,0C18h,0,0
        DW      0,3000h,0C18h,0C0Ch,0C0Ch,3018h,0,0
        DW      0,0,6600h,0FF3Ch,663Ch,0,0,0
        DW      0,0,1818h,0FF18h,1818h,18h,0,0
        DW      0,0,0,0,0,1800h,1818h,30h
        DW      0,0,0,7E00h,0,0,0,0
        DW      0,0,0,0,0,0,3030h,0
        DW      0,200h,0C06h,3018h,0C060h,80h,0,0
        DW      0,7C00h,0CEC6h,0F6DEh,0C6E6h,7CC6h,0,0
        DW      0,1800h,7838h,1818h,1818h,7E18h,0,0
        DW      0,7C00h,6C6h,180Ch,6030h,0FEC6h,0,0
        DW      0,7C00h,6C6h,3C06h,606h,7CC6h,0,0
        DW      0,0C00h,3C1Ch,0CC6Ch,0CFEh,1E0Ch,0,0
        DW      0,0FE00h,0C0C0h,0FCC0h,606h,7CC6h,0,0
        DW      0,3800h,0C060h,0FCC0h,0C6C6h,7CC6h,0,0
        DW      0,0FE00h,6C6h,180Ch,3030h,3030h,0,0
        DW      0,7C00h,0C6C6h,7CC6h,0C6C6h,7CC6h,0,0
        DW      0,7C00h,0C6C6h,7EC6h,606h,780Ch,0,0
        DW      0,0,1818h,0,1800h,18h,0,0
        DW      0,0,1818h,0,1800h,3018h,0,0
        DW      0,600h,180Ch,6030h,1830h,60Ch,0,0
        DW      0,0,0,7Eh,7E00h,0,0,0
        DW      0,6000h,1830h,60Ch,180Ch,6030h,0,0
        DW      0,7C00h,0C6C6h,180Ch,18h,1818h,0,0
        DW      0,7C00h,0C6C6h,0DEDEh,0DCDEh,7CC0h,0,0
        DW      0,1000h,6C38h,0C6C6h,0C6FEh,0C6C6h,0,0
        DW      0,0FC00h,6666h,7C66h,6666h,0FC66h,0,0
        DW      0,3C00h,0C266h,0C0C0h,0C2C0h,3C66h,0,0
        DW      0,0F800h,666Ch,6666h,6666h,0F86Ch,0,0
        DW      0,0FE00h,6266h,7868h,6268h,0FE66h,0,0
        DW      0,0FE00h,6266h,7868h,6068h,0F060h,0,0
        DW      0,3C00h,0C266h,0C0C0h,0C6DEh,3A66h,0,0
        DW      0,0C600h,0C6C6h,0FEC6h,0C6C6h,0C6C6h,0,0
        DW      0,3C00h,1818h,1818h,1818h,3C18h,0,0
        DW      0,1E00h,0C0Ch,0C0Ch,0CC0Ch,78CCh,0,0
        DW      0,0E600h,6C66h,786Ch,6C6Ch,0E666h,0,0
        DW      0,0F000h,6060h,6060h,6260h,0FE66h,0,0
        DW      0,0C600h,0FEEEh,0C6D6h,0C6C6h,0C6C6h,0,0
        DW      0,0C600h,0F6E6h,0DEFEh,0C6CEh,0C6C6h,0,0
        DW      0,3800h,0C66Ch,0C6C6h,0C6C6h,386Ch,0,0
        DW      0,0FC00h,6666h,7C66h,6060h,0F060h,0,0
        DW      0,7C00h,0C6C6h,0C6C6h,0DED6h,0C7Ch,0Eh,0
        DW      0,0FC00h,6666h,7C66h,666Ch,0E766h,0,0
        DW      0,7C00h,0C6C6h,3860h,0C60Ch,7CC6h,0,0
        DW      0,0FF00h,1899h,1818h,1818h,3C18h,0,0
        DW      0,0C600h,0C6C6h,0C6C6h,0C6C6h,7CC6h,0,0
        DW      0,0C600h,0C6C6h,0C6C6h,6CC6h,1038h,0,0
        DW      0,0C600h,0C6C6h,0C6C6h,0FED6h,0C6EEh,0,0
        DW      0,0C600h,0C6C6h,386Ch,0C66Ch,0C6C6h,0,0
        DW      0,0C300h,66C3h,183Ch,1818h,3C18h,0,0
        DW      0,0FE00h,8CC6h,3018h,0C260h,0FEC6h,0,0
        DW      0,3C00h,3030h,3030h,3030h,3C30h,0,0
        DW      0,0C600h,0D6D6h,0D6FEh,0D6D6h,0C6EEh,0,0
        DW      0,3C00h,0C0Ch,0C0Ch,0C0Ch,3C0Ch,0,0
        DW      1000h,6C38h,0C6h,0,0,0,0,0
        DW      0,0,0,0,0,0,0FF00h,0
        DW      1800h,0C18h,0,0,0,0,0,0
        DW      0,0,0,0C78h,0CC7Ch,76CCh,0,0
        DW      0,0E000h,6060h,6C78h,6666h,0DC66h,0,0
        DW      0,0,0,0C67Ch,0C0C0h,7CC6h,0,0
        DW      0,1C00h,0C0Ch,6C3Ch,0CCCCh,76CCh,0,0
        DW      0,0,0,0C67Ch,0C0FEh,7CC6h,0,0
        DW      0,1C00h,3236h,7C30h,3030h,7830h,0,0
        DW      0,0,0,0CC76h,0CCCCh,0C7Ch,78CCh,0
        DW      0,0E000h,6060h,766Ch,6666h,0E666h,0,0
        DW      0,1800h,18h,1838h,1818h,3C18h,0,0
        DW      0,600h,6,60Eh,606h,6606h,3C66h,0
        DW      0,0E000h,6060h,6C66h,6C78h,0E666h,0,0
        DW      0,3800h,1818h,1818h,1818h,3C18h,0,0
        DW      0,0,0,0FEECh,0D6D6h,0D6D6h,0,0
        DW      0,0,0,66DCh,6666h,6666h,0,0
        DW      0,0,0,0C67Ch,0C6C6h,7CC6h,0,0
        DW      0,0,0,66DCh,6666h,607Ch,0F060h,0
        DW      0,0,0,0CC76h,0CCCCh,0C7Ch,1E0Ch,0
        DW      0,0,0,76DCh,6066h,0F060h,0,0
        DW      0,0,0,0C67Ch,1C70h,7CC6h,0,0
        DW      0,1000h,3030h,30FCh,3030h,1C36h,0,0
        DW      0,0,0,0CCCCh,0CCCCh,76CCh,0,0
        DW      0,0,0,0C6C6h,6CC6h,1038h,0,0
        DW      0,0,0,0C6C6h,0D6C6h,6CFEh,0,0
        DW      0,0,0,6CC6h,3838h,0C66Ch,0,0
        DW      0,0,0,0C6C6h,0C6C6h,67Eh,780Ch,0
        DW      0,0,0,0CCFEh,3018h,0FE66h,0,0
        DW      0,0E00h,1818h,7018h,1818h,0E18h,0,0
        DW      0,1800h,1818h,18h,1818h,1818h,0,0
        DW      0,7000h,1818h,0E18h,1818h,7018h,0,0
        DW      0,7600h,0DCh,0,0,0,0,0
        DW      0,0,1818h,1800h,3C18h,3C3Ch,18h,0
        DW      0,0,663Ch,0C0C2h,66C2h,183Ch,0C0Eh,78h
        DW      0,0CC00h,0CCh,0CCCCh,0CCCCh,76CCh,0,0
        DW      0,180Ch,30h,0C67Ch,0C0FEh,7CC6h,0,0
        DW      0,3810h,6Ch,0C78h,0CC7Ch,76CCh,0,0
        DW      0,0CC00h,0CCh,0C78h,0CC7Ch,76CCh,0,0
        DW      0,3060h,18h,0C78h,0CC7Ch,76CCh,0,0
        DW      0,6C38h,38h,0C78h,0CC7Ch,76CCh,0,0
        DW      0,0,0,663Ch,6660h,0C3Ch,3C06h,0
        DW      0,3810h,6Ch,0C67Ch,0C0FEh,7CC6h,0,0
        DW      0,0CC00h,0CCh,0C67Ch,0C0FEh,7CC6h,0,0
        DW      0,3060h,18h,0C67Ch,0C0FEh,7CC6h,0,0
        DW      0,6600h,66h,1838h,1818h,3C18h,0,0
        DW      0,3C18h,66h,1838h,1818h,3C18h,0,0
        DW      0,3060h,18h,1838h,1818h,3C18h,0,0
        DW      0C600h,0C6h,3810h,0C66Ch,0FEC6h,0C6C6h,0,0
        DW      3800h,386Ch,3810h,0C66Ch,0FEC6h,0C6C6h,0,0
        DW      1800h,6030h,0FE00h,6066h,607Ch,0FE66h,0,0
        DW      0,0,6E00h,1BBBh,0D8FFh,76D9h,0,0
        DW      0,3F00h,0CC6Ch,0FFCCh,0CCCCh,0CCCCh,0,0
        DW      0,3810h,6Ch,0C67Ch,0C6C6h,7CC6h,0,0
        DW      0,0C600h,0C6h,0C67Ch,0C6C6h,7CC6h,0,0
        DW      0,3060h,18h,0C67Ch,0C6C6h,7CC6h,0,0
        DW      0,7830h,0CCh,0CCCCh,0CCCCh,76CCh,0,0
        DW      0,3060h,18h,0CCCCh,0CCCCh,76CCh,0,0
        DW      0,0C600h,0C6h,0C6C6h,0C6C6h,67Eh,780Ch,0
        DW      0C600h,0C6h,6C38h,0C6C6h,0C6C6h,386Ch,0,0
        DW      0C600h,0C6h,0C600h,0C6C6h,0C6C6h,7CC6h,0,0
        DW      0,1818h,0C37Eh,0C0C0h,7EC3h,1818h,0,0
        DW      0,6C38h,6064h,60F0h,6060h,0FCE6h,0,0
        DW      0,66C3h,183Ch,18FFh,18FFh,1818h,0,0
        DW      0,66FCh,7C66h,6662h,666Fh,0F366h,0,0
        DW      0,1B0Eh,1818h,187Eh,1818h,70D8h,0,0
        DW      0,180Ch,30h,0C78h,0CC7Ch,76CCh,0,0
        DW      0,0C06h,18h,1838h,1818h,3C18h,0,0
        DW      0,180Ch,30h,0C67Ch,0C6C6h,7CC6h,0,0
        DW      0,180Ch,30h,0CCCCh,0CCCCh,76CCh,0,0
        DW      0,7600h,0DCh,66DCh,6666h,6666h,0,0
        DW      7600h,0DCh,0E6C6h,0FEF6h,0CEDEh,0C6C6h,0,0
        DW      0,6C3Ch,3E6Ch,7E00h,0,0,0,0
        DW      0,663Ch,3C66h,7E00h,0,0,0,0
        DW      0,0,3030h,3000h,6030h,0C6C6h,7Ch,0
        DW      0,0,7E00h,6060h,6060h,60h,0,0
        DW      0,0,7E00h,606h,606h,6,0,0
        DW      6000h,6260h,6864h,367Ch,8C46h,1E18h,0,0
        DW      6000h,6260h,6864h,2E76h,9F5Ah,202h,0,0
        DW      0,0,1818h,1800h,3C18h,3C3Ch,18h,0
        DW      0,0,3612h,0D86Ch,366Ch,12h,0,0
        DW      0,0,6C48h,1B36h,6C36h,48h,0,0
        DW      8822h,8822h,8822h,8822h,8822h,8822h,8822h,8822h
        DW      0AA55h,0AA55h,0AA55h,0AA55h,0AA55h,0AA55h,0AA55h,0AA55h
        DW      6DDBh,6DDBh,6DDBh,6DDBh,6DDBh,6DDBh,6DDBh,6DDBh
        DW      1010h,1010h,1010h,1010h,1010h,1010h,1010h,1010h
        DW      1010h,1010h,1010h,0F010h,1010h,1010h,1010h,1010h
        DW      1010h,1010h,1010h,10F0h,0F010h,1010h,1010h,1010h
        DW      2424h,2424h,2424h,0E424h,2424h,2424h,2424h,2424h
        DW      0,0,0,0FC00h,2424h,2424h,2424h,2424h
        DW      0,0,0,10F0h,0F010h,1010h,1010h,1010h
        DW      2424h,2424h,2424h,4E4h,0E404h,2424h,2424h,2424h
        DW      2424h,2424h,2424h,2424h,2424h,2424h,2424h,2424h
        DW      0,0,0,4FCh,0E404h,2424h,2424h,2424h
        DW      2424h,2424h,2424h,4E4h,0FC04h,0,0,0
        DW      2424h,2424h,2424h,0FC24h,0,0,0,0
        DW      1010h,1010h,1010h,10F0h,0F010h,0,0,0
        DW      0,0,0,0F000h,1010h,1010h,1010h,1010h
        DW      1010h,1010h,1010h,1F10h,0,0,0,0
        DW      1010h,1010h,1010h,0FF10h,0,0,0,0
        DW      0,0,0,0FF00h,1010h,1010h,1010h,1010h
        DW      1010h,1010h,1010h,1F10h,1010h,1010h,1010h,1010h
        DW      0,0,0,0FF00h,0,0,0,0
        DW      1010h,1010h,1010h,0FF10h,1010h,1010h,1010h,1010h
        DW      1010h,1010h,1010h,101Fh,1F10h,1010h,1010h,1010h
        DW      2424h,2424h,2424h,2724h,2424h,2424h,2424h,2424h
        DW      2424h,2424h,2424h,2027h,3F20h,0,0,0
        DW      0,0,0,203Fh,2720h,2424h,2424h,2424h
        DW      2424h,2424h,2424h,0E7h,0FF00h,0,0,0
        DW      0,0,0,0FFh,0E700h,2424h,2424h,2424h
        DW      2424h,2424h,2424h,2027h,2720h,2424h,2424h,2424h
        DW      0,0,0,0FFh,0FF00h,0,0,0
        DW      2424h,2424h,2424h,0E7h,0E700h,2424h,2424h,2424h
        DW      1010h,1010h,1010h,0FFh,0FF00h,0,0,0
        DW      2424h,2424h,2424h,0FF24h,0,0,0,0
        DW      0,0,0,0FFh,0FF00h,1010h,1010h,1010h
        DW      0,0,0,0FF00h,2424h,2424h,2424h,2424h
        DW      2424h,2424h,2424h,3F24h,0,0,0,0
        DW      1010h,1010h,1010h,101Fh,1F10h,0,0,0
        DW      0,0,0,101Fh,1F10h,1010h,1010h,1010h
        DW      0,0,0,3F00h,2424h,2424h,2424h,2424h
        DW      2424h,2424h,2424h,0FF24h,2424h,2424h,2424h,2424h
        DW      1010h,1010h,1010h,10FFh,0FF10h,1010h,1010h,1010h
        DW      1010h,1010h,1010h,0F010h,0,0,0,0
        DW      0,0,0,1F00h,1010h,1010h,1010h,1010h
        DW      0FFFFh,0FFFFh,0FFFFh,0FFFFh,0FFFFh,0FFFFh,0FFFFh,0FFFFh
        DW      0,0,0,0,0FFFFh,0FFFFh,0FFFFh,0FFFFh
        DW      0F0F0h,0F0F0h,0F0F0h,0F0F0h,0F0F0h,0F0F0h,0F0F0h,0F0F0h
        DW      0F0Fh,0F0Fh,0F0Fh,0F0Fh,0F0Fh,0F0Fh,0F0Fh,0F0Fh
        DW      0FFFFh,0FFFFh,0FFFFh,0FFFFh,0,0,0,0
        DW      0,0,6200h,0CCD6h,0CCCCh,76DCh,0,0
        DW      0,3800h,646Ch,667Ch,6666h,7C66h,0C0h,0
        DW      0,0,62FEh,6060h,6060h,0F060h,0,0
        DW      0,0,66FFh,6666h,6666h,6666h,0,0
        DW      0,0,0C2FEh,3060h,2010h,0FE42h,0FEh,0
        DW      0,0,7E00h,0CCCCh,0CCCCh,386Ch,0,0
        DW      0,0,6600h,6666h,6666h,607Ch,0C0h,0
        DW      0,0,7E00h,18D8h,1818h,3818h,0,0
        DW      0,187Eh,3C18h,6666h,183Ch,7E18h,0,0
        DW      0,3800h,0C66Ch,0FEC6h,0C6C6h,386Ch,0,0
        DW      0,3800h,0C66Ch,0C6C6h,286Ch,0EEAAh,0,0
        DW      0,0,6438h,1830h,0CC7Ch,78CCh,0,0
        DW      0,0,0,0DB7Eh,0DBDBh,7Eh,0,0
        DW      0,200h,3C06h,0CE6Ch,6CD6h,0C078h,80h,0
        DW      0,1E00h,6030h,7E60h,6060h,1E30h,0,0
        DW      0,0,6C38h,0C6C6h,0C6C6h,0C6C6h,0,0
        DW      0,0,7E7Eh,7E00h,7Eh,7E7Eh,0,0
        DW      0,1800h,7E18h,187Eh,18h,7E7Eh,0,0
        DW      0,0,38E0h,0E0Eh,0E038h,0FEFEh,0,0
        DW      0,0,380Eh,0E0E0h,0E38h,0FEFEh,0,0
        DW      0,0,0,1B0Eh,181Bh,1818h,1818h,1818h
        DW      1818h,1818h,1818h,0D818h,70D8h,0,0,0
        DW      0,1800h,183Ch,7E00h,7Eh,3C18h,18h,0
        DW      0,0,7600h,0DCh,0DC76h,0,0,0
        DW      0,6C38h,386Ch,0,0,0,0,0
        DW      0,0,3C00h,3C3Ch,3Ch,0,0,0
        DW      0,0,0,3C3Ch,0,0,0,0
        DW      0C07h,0C0Ch,180Ch,1818h,0D098h,70F0h,30h,0
        DW      6C00h,3636h,3636h,0,0,0,0,0
        DW      3800h,0C6Ch,6038h,7Ch,0,0,0,0
        DW      0,0,7C00h,7C7Ch,7C7Ch,0,0,0
        DW      0,0,0,0,0,0,0,0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\chab.inc ===
;========================================================================
;
; PRINTER DRIVER program
;
;========================================================================

ASSUME CS:CODE,DS:CODE,ES:CODE

; *** SUPPORTED PRINTER ***
;
; (WS)
;  1. KS printer
;  2. Qnix LBP
;  3. KSSM
; (CH)
;  4. Qnix printer
;  5. Qnix LBP
;  6. TG
;  7. KSSM
;
; concept
;
; 1. WanSung code system   80h - feh
;    check MSB(1st/2nd byte)
;    check ESC code
;
; 2. ChoHab code system    40h - ffh
;    check MSB(1st byte), check range(>3FH, 2nd byte)
;    check ESC code
;
; 3. ChoHab 7 bit code system  21h - 7eh
;    check code range(1st/2nd byte)
;    check ESC code

TblEnd          =       -1
FsKey           =       1ch

; PrtAuto
AutoNor         =       00h     ; 00h, 01h              ; have no
AutoEsc         =       01h     ; 00h, 02h, 03h, 04h    ; have ESC/FS
                                ; 06h, 08h, 0ah, 0bh, 0ch, 0dh, 0eh, 0fh
Auto3           =       02h     ; 00h                   ; spend 1 byte
Auto4           =       03h     ; 05h                   ; spend 2 byte
AutoV1          =       04h     ; 00h, 06h, 08h         ; spend n+1 byte
AutoVCnt        =       05h     ; 00h                   ; spend n byte
AutoV1stx1      =       06h     ; 07h                   ; have 1st counter
AutoV2ndx1      =       07h     ; 05h                   ; have 2nd counter
AutoV1stx3      =       08h     ; 09h                   ; have 1st counter
AutoV2ndx3      =       09h     ; 05h                   ; have 2nd counter
AutoNull        =       0ah     ; 00h, 0ah              ; spend until null.
AutoEng         =       0bh     ; 00h, 0bh              ; spend until eng-char
AutoEngLow      =       0ch     ; 00h, 0ch              ; spend until eng-low-char
Auto74          =       0dh     ; 05h                   ; spend 74 byte
Auto5           =       0eh     ; 05h                   ; spend 5 byte
Auto8           =       0fh     ; 05h                   ; spend 8 byte
Auto3Cnt        =       10h     ; 05h                   ; spend 3 byte
Auto78          =       11h     ; 05h                   ; spend 78 byte
AutoEnd         =       12h

PrtAuto         db      0       ; automata variable
CharCnt         dw      0       ; ESC control char counter
HanCnt          db      0       ; 2 byte char counter
Han1stCode      db      0       ; 1 st char code
EscCode2Addr    dw      0
EscCode3Addr    dw      0
EscCodeNAddr    dw      0
EscCode4Addr    dw      0

public  Int17

Int17:
        or      ah,ah
        jnz     SkipNew17
        test    cs:[CodeStat],HangeulMode
        jz      SkipNew17                       ; jump if english print
        @push   bx,cx,dx,si,di,es,ds,bp
        mov     bx,cs
        mov     ds,bx
        mov     es,bx
        mov     bl,[PrtAuto]
        cmp     bl,AutoEnd
        jb      @f
        xor     bl,bl
        mov     [PrtAuto],bl
@@:
        xor     bh,bh
        shl     bx,1
        add     bx,offset PioJumpTbl
        call    [bx]
        mov     ah,0                    ; assume write char.
        jnc     @f
        mov     ah,2                    ; get status.
@@:
        @pop    bp,ds,es,di,si,dx,cx,bx
SkipNew17:
        jmp     cs:[OldInt17]

PioJumpTbl      label   word
                dw      offset sAutoNor          ; 0
                dw      offset sAutoEsc          ; 1
                dw      offset sAuto3            ; 2
                dw      offset sAuto4            ; 3
                dw      offset sAutoV1           ; 4
                dw      offset sAutoVCnt         ; 5
                dw      offset sAutoV1stx1       ; 6
                dw      offset sAutoV2ndx1       ; 7
                dw      offset sAutoV1stx3       ; 8
                dw      offset sAutoV2ndx3       ; 9
                dw      offset sAutoNull         ; a
                dw      offset sAutoEng          ; b
                dw      offset sAutoEngLow       ; c
                dw      offset sAuto74           ; d
                dw      offset sAuto5            ; e
                dw      offset sAuto8            ; f
                dw      offset sAuto3Cnt         ; 10
                dw      offset sAuto78           ; 11

;========================================================================
sAutoNor:                               ; 0
; FUNCTION = check ESC code, code range, convert code if need.
;            check 1st/2nd byte code.
; AUTO = 0, 1
        cmp     al,EscKey
        jz      @f
        cmp     al,FsKey
        jz      @f
        cmp     al,' '
        jbe     NorEnd
        call    ChkRange
        jc      NorEnd
        call    ChgCodeTy
        ret
@@:
        mov     bl,[Printer]
        and     bl,not ChPrinter
        cmp     bl,wKmPrt
        jnz     NorEnd
        mov     [PrtAuto],AutoEsc
        cmp     al,EscKey
        jnz     @f                      ; jump if "FS" code
        mov     [EscCode2Addr],offset KmEscCode2
        mov     [EscCode3Addr],offset KmEscCode3
        mov     [EscCodeNAddr],offset KmEscCodeN
        mov     [EscCode4Addr],offset KmEscCode4
        jmp     short NorEnd
@@:
        mov     [EscCode2Addr],offset KmFsCode2
        mov     [EscCode3Addr],offset KmFsCode3
        mov     [EscCodeNAddr],offset KmFsCodeN
        mov     [EscCode4Addr],offset KmFsCode4
NorEnd:
        cmp     [HanCnt],0
        jz      @f
        mov     [HanCnt],0
        mov     bl,al
        mov     al,[Han1stCode]
        xor     ah,ah
        pushf
        call    [OldInt17]              ; print a char.
        mov     al,bl
@@:
        clc
        ret

;========================================================================
;   << sAutoEsc >>
; FUNCTION = search 2nd ESC code, send 1st byte if saved.
; AUTO = 0, 2, 3, 4, 6, 8, a, b, c, d, e, f
sAutoEsc:                               ; 1
        mov     si,[EscCode2Addr]
        call    SearchEscCode1
        mov     ah,0
        jc      @f                      ; jump if found.
        mov     si,[EscCode3Addr]
        call    SearchEscCode1
        mov     ah,Auto3
        jc      @f                      ; jump if found.
        mov     si,[EscCodeNAddr]
        call    SearchEscCode2
        jc      @f                      ; jump if found.
        mov     [PrtAuto],AutoNor
        jmp     sAutoNor
@@:
        mov     [PrtAuto],ah
        clc
        ret

;========================================================================
;   << sAuto3 >>
; FUNCTION = return to normal.
; AUTO = 0
sAuto3:                                 ; 2
        mov     [PrtAuto],AutoNor
        clc
        ret

;========================================================================
;   << sAuto4 >>
; FUNCTION = go to sAutoVCnt for spend 1 byte.
; AUTO = 8
sAuto4:                                 ; 3
        mov     [CharCnt],1
        mov     [PrtAuto],AutoV1stx3
        clc
        ret

;========================================================================
;   << sAutoV1 >>
; FUNCTION = check 3rd ESC code
; AUTO = 0, 6, 8
sAutoV1:                                ; 4
        mov     si,[EscCode4Addr]
        call    SearchEscCode2
        jnc     @f                      ; jump if not found.
        mov     [PrtAuto],ah
        clc
        ret
@@:
        mov     [PrtAuto],AutoNor
        ret

;========================================================================
;   << sAutoVCnt >>
; FUNCTION = spend n char.
; AUTO = 0
sAutoVCnt:                              ; 5
        dec     [CharCnt]
        jnz     @f
        mov     [PrtAuto],AutoNor
@@:
        clc
        ret

;========================================================================
;   << sAutoV1stx1 >>
; FUNCTION = save 1st counter.
; AUTO = 7
sAutoV1stx1:                            ; 6
        xor     ah,ah
        mov     [CharCnt],ax
        mov     [PrtAuto],AutoV2ndx1
        clc
        ret

;========================================================================
;   << sAutoV2ndx1 >>
; FUNCTION = save 2nd counter, calc size(*1).
; AUTO = 5
sAutoV2ndx1:                            ; 7
        mov     cl,al
        mov     bx,[CharCnt]
        mul     bx
        mov     [CharCnt],ax
        mov     al,cl
        mov     [PrtAuto],AutoVCnt
        clc
        ret

;========================================================================
;   << sAutoV1stx3 >>
; FUNCTION = save 1st counter.
; AUTO = 9
sAutoV1stx3:                            ; 8
        xor     ah,ah
        mov     [CharCnt],ax
        mov     [PrtAuto],AutoV2ndx3
        clc
        ret

;========================================================================
;   << sAutoV2ndx3 >>
; FUNCTION = save 2nd counter, calc size(*3).
; AUTO = 5
sAutoV2ndx3:                            ; 9
        mov     cl,al
        mov     bx,[CharCnt]
        mul     bx
        mov     bl,3
        mul     bx
        mov     [CharCnt],ax
        mov     al,cl
        mov     [PrtAuto],AutoVCnt
        clc
        ret

;========================================================================
;   << sAutoNull >>
; FUNCTION = spend until null.
; AUTO = 0
sAutoNull:                              ; a
        or      al,al
        jnz     @f
        mov     [PrtAuto],AutoNor
@@:
        clc
        ret

;========================================================================
;   << sAutoEng >>
; FUNCTION = spend until english char.
; AUTO = 0
sAutoEng:                               ; b
        mov     ah,al
        or      ah,20h                  ; make low char.
        cmp     ah,'a'
        jb      @f
        cmp     ah,'z'
        ja      @f
        mov     [PrtAuto],AutoNor
@@:
        clc
        ret

;========================================================================
;   << sAutoEngLow >>
; FUNCTION = spend until english low char.
; AUTO = 0
sAutoEngLow:                            ; c
        cmp     al,'a'
        jb      @f
        cmp     al,'z'
        ja      @f
        mov     [PrtAuto],AutoNor
@@:
        clc
        ret

;========================================================================
;   << sAuto74 >>
; FUNCTION = set counter to 73.
; AUTO = 5
sAuto74:                                ; d
        mov     [HanCnt],73
        mov     [PrtAuto],AutoVCnt
        clc
        ret

;========================================================================
;   << sAuto5 >>
; FUNCTION = set counter to 4.
; AUTO = 5
sAuto5:                                 ; e
        mov     [HanCnt],4
        mov     [PrtAuto],AutoVCnt
        clc
        ret

;========================================================================
;   << sAuto8 >>
; FUNCTION = set counter to 7.
; AUTO = 5
sAuto8:                                 ; f
        mov     [HanCnt],7
        mov     [PrtAuto],AutoVCnt
        clc
        ret

;========================================================================
;   << sAuto3Cnt >>
; FUNCTION = set counter to 2.
; AUTO = 5
sAuto3Cnt:                              ; 10
        mov     [HanCnt],2
        mov     [PrtAuto],AutoVCnt
        clc
        ret

;========================================================================
;   << sAuto78 >>
; FUNCTION = set counter to 73.
; AUTO = 5
sAuto78:                                ; 11
        mov     [HanCnt],78
        mov     [PrtAuto],AutoVCnt
        clc
        ret

;------------------------------------------------------------------------
ChkRange:
        test    [CodeStat],Chab
        jz      @f
        call    ChkRangeCh
        jmp     short ChkEnd
;@@:
;        test    [CodeStat],Wsung7
;        jz      @f
;        call    ChkRangeCh7
;        jmp     short ChkEnd
@@:
        call    ChkRangeWs
ChkEnd:
        ret

ChkRangeWs:
        test    [Printer],ChPrinter
        jz      @f                      ; jump if code == printer type
        call    CheckCodeRange1st
        ret
@@:
        stc                             ; out range
        ret

ChkRangeCh:
        test    [Printer],ChPrinter
        jnz     @b                      ; jump if code == printer type
        cmp     [HanCnt],0
        jnz     @f
        call    CheckCodeRange1st
        ret
@@:
        mov     ah,[Han1stCode]
        call    CheckCodeRangeword
        ret

ChkRangeCh7:
        cmp     [HanCnt],0
        jnz     @f
        call    CheckCodeRange1st
        ret
@@:
        mov     ah,[Han1stCode]
        call    CheckCodeRangeword
        ret

;------------------------------------------------------------------------
ChgCodeTy:
        cmp     [HanCnt],0
        jnz     @f
        mov     [Han1stCode],al
        inc     [HanCnt]
        stc                             ; does not print char.
        ret
@@:
        mov     [HanCnt],0
        mov     ah,[Han1stCode]
        mov     cx,ax                   ; save code
        push    cx
        push    dx
        test    [Printer],ChPrinter
        jnz     ChoHabPrt
        test    [CodeStat],Chab
        jz      @f
        call    ChgCh2Ks
        jmp     short ChgEnd
@@:
;        test    [CodeStat],Wsung7
;        jz      ChgEnd
;        call    ChgCh72Ks
;        jmp     short ChgEnd
ChoHabPrt:
;        test    [CodeStat],Wsung7
;        jnz     @f
        test    [CodeStat],Chab
        jnz     ChgEnd
        call    ChgKs2Ch
        jmp     short ChgEnd
;@@:
;        call    ChgCh72Ks
;        jc      ChgEnd
;        call    ChgKs2Ch
ChgEnd:
        pop     dx
        pop     cx
        jc      @f
        mov     bx,ax
        mov     al,bh                   ; print 1st byte
        xor     ah,ah
        pushf
        call    [OldInt17]              ; print a char.
        mov     al,bl                   ; set 2nd byte
        clc
        ret
@@:
        mov     al,ch
        xor     ah,ah
        pushf
        call    [OldInt17]              ; print a char.
        mov     al,cl
;        test    [CodeStat],Wsung7
;        jz      @f
;        call    ChkRange                ; It's ChoHab 7 bit code system only.
;        jnc     @f
;        mov     [Han1stCode],al
;        inc     [HanCnt]
;        stc                             ; does not print char.
clc
@@:
        ret

;------------------------------------------------------------------------
SearchEscCode1:
        mov     bl,al
@@:
        lodsb
        cmp     al,TblEnd
        jz      @f
        cmp     al,bl
        jnz     @b
        stc                             ; found
@@:
        mov     al,bl
        ret

;------------------------------------------------------------------------
SearchEscCode2:
        mov     bl,al
@@:
        lodsw
        cmp     al,TblEnd
        jz      @f
        cmp     al,bl
        jnz     @b
        stc                             ; found
@@:
        mov     al,bl
        ret

EscCode2Tbl     label   word
                dw      offset KsEscCode2
                dw      offset LbpEscCode2
                dw      offset KmEscCode2
                dw      0
                dw      0
                dw      0
                dw      offset KmEscCode2
                dw      offset TgEscCode2

EscCode3Tbl     label   word
                dw      offset KsEscCode3
                dw      offset LbpEscCode3
                dw      offset KmEscCode3
                dw      0
                dw      0
                dw      0
                dw      offset KmEscCode3
                dw      offset TgEscCode3

EscCodeNTbl     label   word
                dw      offset KsEscCodeN
                dw      offset LbpEscCodeN
                dw      offset KmEscCodeN
                dw      0
                dw      0
                dw      0
                dw      offset KmEscCodeN
                dw      offset TgEscCodeN

EscCode4Tbl     label   word
                dw      offset KsEscCode4
                dw      offset LbpEscCode4
                dw      offset KmEscCode4
                dw      0
                dw      0
                dw      0
                dw      offset KmEscCode4
                dw      offset TgEscCode4


KsEscCode2 label   byte
        db      '01267<EFGH',TblEnd
KsEscCode3 label   byte
        db      '-3ACJUWcdhimqruwxyz',TblEnd
KsEscCodeN label   byte
        db      't', Auto4
        db      'K', AutoV1stx1
        db      'L', AutoV1stx1
        db      'n', AutoV1stx3
        db      'D', AutoNull
KsEscCode4 label   byte
        db      TblEnd

ChEscCode2 label   byte
        db      '01267<EFGHMPTqy',TblEnd
ChEscCode3 label   byte
        db      '-3ACJQSUWbcfghimprsvl',TblEnd
ChEscCodeN label   byte
        db      'R', Auto4
        db      '*', AutoV1
        db      't', Auto3Cnt
        db      'K', AutoV1stx1
        db      'L', AutoV1stx1
        db      'Y', AutoV1stx1
        db      'k', AutoV1stx3
        db      'D', AutoNull
        db      TblEnd
ChEscCode4 label   byte
        db      'p', AutoV1stx1
        db      '!', AutoV1stx3
        db      TblEnd

TgEscCode2 label   byte
        db      'heWwIiDLdNjk6c7GgUuFfBbSsVv'
TgEscCode3 label   byte
        db      TblEnd
TgEscCodeN label   byte
        db      'T',Auto3Cnt
        db      '[',AutoV1
        db      TblEnd
TgEscCode4 label   byte
        db      'M',Auto4
        db      'm',AutoNor
        db      'R',AutoNor
        db      'r',AutoNor
        db      TblEnd

KmEscCode2 label   byte
        db      'O01267MPTg45EFGH@<',0fh,0eh,TblEnd
KmEscCode3 label   byte
        db      'CNQl3A/JRSkptx% a-w!WqUdr',19h,TblEnd
KmEscCodeN label   byte
        db      '$', Auto4
        db      'C', Auto4
        db      '\', Auto4
        db      ' ', Auto4
        db      '?', Auto4
        db      ':', Auto5
        db      '(', Auto8
        db      '*', AutoV1
        db      'K', AutoV1stx1
        db      'L', AutoV1stx1
        db      'Y', AutoV1stx1
        db      'Z', AutoV1stx1
        db      'B', AutoNull
        db      'D', AutoNull
        db      'b', AutoNull
        db      TblEnd
KmEscCode4 label   byte
        db      0, AutoV1stx1
        db      1, AutoV1stx1
        db      2, AutoV1stx1
        db      3, AutoV1stx1
        db      4, AutoV1stx1
        db      6, AutoV1stx1
        db      32, AutoV1stx3
        db      33, AutoV1stx3
        db      38, AutoV1stx3
        db      39, AutoV1stx3
        db      40, AutoV1stx3
        db      TblEnd

KmFsCode2 label   byte
        db      'JK&.UV ',0fh,12h,0eh,14h,TblEnd
KmFsCode3 label   byte
        db      '$a!-WXvkrtx ',TblEnd
KmFsCodeN label   byte
        db      'D', Auto4
        db      'M', Auto4
        db      'S', Auto4
        db      'T', Auto4
        db      '&', Auto78
        db      '2', Auto74
KmFsCode4 label   byte
        db      TblEnd

LbpEscCode2 label   byte
        db      '@SJKBbRrUuWwMmDdIi'
LbpEscCode3 label   byte
        db      TblEnd
LbpEscCodeN label   byte
        db      '[', AutoEng             ; ESC "[" ____ ENGLISH-char
        db      '(', AutoEngLow          ; ESC "(" ____ ENGLISH-low-char
        db      ')', AutoEngLow          ; ESC ")" ____ ENGLISH-low-char
LbpEscCode4 label   byte
        db      TblEnd

;========================================================================
;
; CODE CONVERSION program
;
;========================================================================

ASSUME CS:CODE,DS:CODE,ES:CODE

EXTRN   ChHgWTbl:byte, ChHgWLng:word, ChHgCTbl:byte, ChHgIndexTbl:word
EXTRN   ah88h:byte

;========================================================================
;   << ChgCh2Ks >>
; FUNCTION = Code convertion ChoHab to WanSung in HanJa/Grp/Hangeul
;
; RANGE :
;         84-d3, 41h-7eh 81h-feh ()
;         d9-de, 31h-7eh 91h-feh ()
;         e0-f9, 31h-7eh 91h-feh ()
;         d8,    31h-7eh 91h-feh (udc)
;
; Code array :  88 ...... 61   00 =  B0A1
;                          |    |    B0A2
;                         FD   BF     :
;               89 ...... 41   C0     :
;                          |    |
;                         B7   17F
;               90 ...... 61   180
;                |         |    |
;                |         |    |
;               D3        B7
;
; INPUT   : AX=code
; OUTPUT  : if CY=fail
;           if NC=success, AX= code, BX=code

EXTRN   Ch2Ks:near
PUBLIC  ChgCh2Ks

ChgCh2Ks:
        @push   cx,dx,si,di,es,ds,bp
        push    ax
        mov     bx,cs
        mov     ds,bx
        mov     es,bx
        mov     di,ax
ChHgKs:
        cmp     ah,084h
        jb      ChgCh2KsErr
        cmp     ah,0d3h
        ja      ChHjKs
        cmp     al,41h                  ; 41h - 7eh, 81h - feh
        jb      ChgCh2KsErr
        cmp     al,0feh
        ja      ChgCh2KsErr
        cmp     al,07eh
        jbe     @f
        cmp     al,81h
        jb      ChgCh2KsErr
@@:
        jmp     Ch2KsHg
ChHjKs:
        cmp     al,31h                  ; 31h - 7eh, 91h - feh
        jb      ChgCh2KsErr
        cmp     al,0feh
        ja      ChgCh2KsErr
        cmp     al,07eh
        jbe     @f
        cmp     al,91h
        jb      ChgCh2KsErr
@@:
        cmp     ah,0d8h
        jz      ChUdcKs
        cmp     ah,0d9h                 ; d9h - deh
        jb      ChgCh2KsErr
        cmp     ah,0deh
        ja      @f
        jmp     Ch2KsHj
@@:
        cmp     ah,0e0h                 ; e0h - f9h
        jb      ChgCh2KsErr
        cmp     ah,0f9h
        ja      ChgCh2KsErr
        jmp     Ch2KsHj2
ChgCh2KsErr:
        jmp     PostSetRegErr

Ch2KsHg:
        call    Ch2Ks
        jmp     PostSetReg

ChUdcKs:
        cmp     al,07eh
        ja      @f
        sub     ax,00e90h
        jmp     PostSetRegSuc
@@:
        cmp     al,0a1h
        jae     @f
        sub     ax,00ea2h
        jmp     PostSetRegSuc
@@:
        mov     ah,0feh
        jmp     PostSetRegSuc

Ch2KsHj:
        mov     bx,ax
        sub     bh,0d9h-0a1h
        sub     bh,0a1h
        shl     bh,1
        add     bh,0a1h
        jmp     @f
Ch2KsHj2:
        mov     bx,ax
        sub     bh,0e0h-0cah
        sub     bh,0cah
        shl     bh,1
        add     bh,0cah
@@:
        inc     bh
        cmp     al,0a1h
        jae     @f
        dec     bh
        add     bl,0a1h-31h
        cmp     al,7eh
        jbe     @f
        mov     bl,al
        add     bl,0efh-91h
@@:
        mov     ax,bx
        jmp     PostSetRegSuc

;========================================================================
;   << ChgKs2Ch >>
; FUNCTION = Code conversion Wansung to Chohab in HanJa/Grp/hanguel
;
; RANGE : A4A1 - A4D3(Hangeul Component)
;         A1A1 - ABF6(Graphics)
;         B0A1 - C8FE(Hangeul)
;         CAA1 - FDFE(Hanja)
;
; Code array :  88 ...... 61   00 =  B0A1
;                          |    |    B0A2
;                         FD   BF     :
;               89 ...... 41   C0     :
;                          |    |
;                         B7   17F
;               90 ...... 61   180
;                |         |    |
;                |         |    |
;               D3        B7
;
; INPUT   : AX=code
; OUTPUT  : if CY=fail
;           if NC=success, AX= code, BX=code

EXTRN   Ks2Ch:near
PUBLIC  ChgKs2Ch

ChgKs2Ch:
        @push   cx,dx,si,di,es,ds,bp
        push    ax
        mov     bx,cs
        mov     ds,bx
        mov     es,bx
        mov     di,ax
@@:
        cmp     al,0a1h
        jb      isnotJH
        cmp     al,0feh
        ja      isnotJH
        cmp     ah,0a1h
        jb      isnotJH
        cmp     ah,0feh
        ja      isnotJH
        cmp     ah,0ach
        ja      @f
        jmp     Ks2ChGrp
@@:
        cmp     ah,0b0h
        jb      isnotJH
        cmp     ah,0c8h
        ja      @f
        jmp     Ks2ChHg
@@:
        cmp     ah,0feh
        jne     @f
        mov     ah,0d8h
        jmp     PostSetRegSuc
@@:
        cmp     ah,0c9h
        ja      Ks2ChHj
        cmp     al,0eeh
        jbe     @f
        add     ax,00012h
@@:
        add     ax,00e90h
        jmp     PostSetRegSuc
isnotJH:
        jmp     PostSetRegErr

Ks2ChHgComp:
Ks2ChHg:
        call    Ks2Ch
        jmp     PostSetReg
Ks2ChGrp:
        mov     bx,ax
        sub     bh,0a1h
        shr     bh,1
        add     bh,0a1h
        add     bh,0d9h-0a1h
        xor     ah,1
        jmp     short @f
Ks2ChHj:
        mov     bx,ax
        sub     bh,0cah
        shr     bh,1
        add     bh,0cah
        add     bh,0e0h-0cah
@@:
        test    ah,1
        jnz     @f
        sub     bl,0a1h-31h
        cmp     al,0eeh
        jb      @f
        mov     bl,al
        sub     bl,0efh-91h
@@:
        mov     ax,bx
        jmp     PostSetRegSuc

;========================================================================
;   << ChgCh72Ks >>
; FUNCTION = Code conversion Chohab7 to Wansung in Hangule
;
; RANGE : B0A1 - C8FE(Hanguel)
;
; Code array :    00    B0A1
;                  |     |
;                 5D    B0FE
;                 5E    B1A1
;                  |     |
;                 BB    B1FE
;                 BC    B2A1
;                  |     |
;
;                       C8FE
;
; INPUT   : AX=code
; OUTPUT  : if CY=fail
;           if NC=success, AX= code, BX=code

EXTRN   LinearWordSearch:near, LinearByteSearch:near
PUBLIC  ChgCh72Ks

ChgCh72Ks:
        @push   cx,dx,si,di,es,ds,bp
        push    ax
        mov     bx,cs
        mov     ds,bx
        mov     es,bx
        cmp     ax,5f21h
        jb      isnotJ7Wan
        cmp     ax,5f54h
        ja      @f
        mov     si,offset Ch7HgETbl
        mov     cx,ChHgWLng+1
        mov     di,offset ChHgWTbl
        mov     dh,0a4h
        jmp     GetCodeInUnSort2
@@:
        mov     di,ax
        cmp     ax,7e7eh
        ja      isnotJ7Wan
        sub     ah,05Fh
        mov     si,offset Ch7HgTbl
        xor     dx,dx
        xor     bx,bx
        xor     cx,cx
        mov     bl,ah
        mov     cl,bl
        shl     bx,1
        add     bx,cx
        cmp     ah,0
        jz      short @f
        mov     dx,[si+bx+1]
        mov     cx,[si+1]
        sub     dx,cx
@@:
        xor     ch,ch
        mov     cl,[si+bx]
        mov     si,[si+bx+1]
        call    LinearByteSearch
        jc      short @f
        mov     ax,bx
        add     ax,dx
        mov     bl,05eh
        div     bl
        xchg    ah,al
        add     ax,0B0A1h
        jmp     PostSetRegSuc
@@:
        mov     ax,di
        cmp     ah,07eh
        jnz     isnotJ7Wan
        mov     si,offset Ch7HgCTbl
        mov     cx,Ch7HgCLng
        mov     di,offset Ch7HgWTbl
        jmp     GetCodeInUnSort1
isnotJ7Wan:
        jmp     PostSetRegErr

;========================================================================
;   << ChgKs2Ch7 >>
; FUNCTION = Code convertion Wansung to Chohab7 in Hanguel
;
; RANGE : B0A1 - C8FE(Hanguel)
;
; Code array :   B0A1    00
;                 |       |
;                B0FE    5D
;                B1A1    5E
;                 |       |
;                B1FE    BB
;                B2A1    BC
;                 |
;
;                C8FE
;
; INPUT   : AX=code
; OUTPUT  : if CY=fail
;           if NC=success, AX= code, BX=code

PUBLIC  ChgKs2Ch7

ChgKs2Ch7:
        @push   cx,dx,si,di,es,ds,bp
        push    ax
        mov     bx,cs
        mov     ds,bx
        mov     es,bx
        cmp     ax,0a4a1h
        jb      ChWanJ7Err
        cmp     ax,0a4d3h
        ja      @f
        mov     si,offset ChHgWTbl
        mov     cx,ChHgWLng+1
        mov     dh,05fh
        mov     di,offset Ch7HgETbl
        jmp     GetCodeInUnSort2
@@:
        cmp     ax,0B0A1h
        jb      ChWanJ7Err
        cmp     ax,0C8FEh
        ja      ChWanJ7Err
        mov     di,ax
        mov     si,offset AH5F
        sub     ax,0B0A1h
        mov     bx,ax
        mov     al,ah
        mov     ah,0A2h
        mul     ah
        sub     bx,ax
        mov     al,[bx+si]
        cmp     al,0
        je      ChWan7C
        mov     si,offset Ch7HgTbl
        xor     dx,dx
        mov     cx,dx
        mov     ah,dh
@@:
        mov     cl,[si]
        add     dx,cx
        cmp     bx,dx
        jb      short @f
        add     si,3
        inc     ah
        jmp     short @b
@@:
        add     ah,05fh
        jmp     ChWanJ7End
ChWan7C:
        mov     ax,di
        mov     si,offset Ch7HgWTbl
        mov     cx,Ch7HgCLng
        mov     di,offset Ch7HgCTbl
        mov     dh,07eh
        jmp     GetCodeInUnSort3
ChWanJ7End:
        jmp     PostSetRegSuc
ChWanJ7Err:
        jmp     PostSetRegErr

;------------------------------------------------------------------------
GetCodeInUnSort1:
        call    LinearByteSearch
        jc      SetFail
        shl     bx,1
        mov     si,di
        mov     ax,word ptr [si+bx]
SetSuccess:
        jmp     PostSetRegSuc
SetFail:
        jmp     PostSetRegErr
GetCodeInUnSort2:
        call    LinearByteSearch
        jc      SetFail
        jmp     short @f
GetCodeInUnSort3:
        call    LinearWordSearch
        jc      SetFail
        shr     bx,1
@@:
        mov     ah,dh
        mov     si,di
        mov     al,byte ptr [si+bx]
        jmp     SetSuccess

PostSetReg:
        pop     bx
        jnc     @f
        mov     ax,bx
@@:
        @pop    bp,ds,es,di,si,dx,cx
        ret

PostSetRegErr:
        stc
        pop     ax
        @pop    bp,ds,es,di,si,dx,cx
        ret
PostSetRegSuc:
        clc
        pop     bx
        @pop    bp,ds,es,di,si,dx,cx
        ret

include CHOHAB7.TBL


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\font_win\font_win.asm ===
;
; Windows-NT MVDM Japanese DOS/V $FONT.SYS Dispatch Driver
;
	.286

	include struc.inc
	include font_win.inc
	include vint.inc

NO_ERROR		equ	00h
IRREGAL_FONT_TYPE	equ	01h
IRREGAL_BL		equ	02h
IRREGAL_FONT_SIZE	equ	03h
IRREGAL_CODE_PAGE	equ	04h
IRREGAL_CODE_NUMBER	equ	05h
READ_ONLY_FONT		equ	06h

FONT_ENABLE		equ	0001h

FONT_CONF	STRUC
READ_WRITE	DB	?		; Read=0, Write=1
FONT_TYPE	DB	?		; SBCS=0, DBCS=1
FONT_SIZE	DW	?
FONT_ADDR	DW	?		; Font read/write routine
FONT_FLAG	DW	?		; Font flag(Now Enable bit only)
FONT_ORG	DW	?		; Original Font write routine
FONT_CONF	ENDS

FONTCNF_SIZE	equ	10


;----------------------------------------------------------------------------;
;                             Code Segment                                   
;----------------------------------------------------------------------------;
TEXT	segment byte public
	assume	cs:TEXT,ds:TEXT,es:TEXT

	org     0               ; drivers should start at address 0000h
	                        ; this will cause a linker warning - ignore it.

Header:                         ; device driver header
	DD	fNEXTLINK       ; link to next device driver
	DW	fCHARDEVICE+fOPENCLOSE  ; device attribute word: 
					; char.device+open/close
	DW	Strat           ; 'Strat' entry point
	DW	Intr            ; 'Intr' entry point
	DB	'NTDISP1$'      ; logical device name (needs to be 8 chars)


;----------------------------------------------------------------------------;
; data variables
;----------------------------------------------------------------------------;

null     	dw      0       ; dummy to do a quick erase of pAtomValue
pAtomVal 	dw offset null  ; pointer to value of result of atom search
MemEnd   	dw  ddddlList   ; end of used memory:      initially AtomList
MaxMem   	dw  ddddlList   ; end of available memory: initially AtomList
lpHeader	dd      0       ; far pointer to request header
org_int10_add	dd	0	; Original int10 vector
org_int15_add	dd	0	; Original int15 vector
mode12cnt	dw	1	; mode 12h call count
read_offset	dw	0	; read count

org_SBCS_06x12	dd	0	; Fornt write routine address
org_SBCS_08x16	dd	0
org_SBCS_08x19	dd	0
org_SBCS_12x24	dd	0
org_DBCS_12x12	dd	0
org_DBCS_16x16	dd	0
org_DBCS_24x24	dd	0

;----------------------------------------------------------------------------;
; Dispatch table for the interrupt routine command codes                     
;----------------------------------------------------------------------------;

Dispatch:                       
	DW     Init     ;  0 = init driver 
	DW     Error    ;  1 = Media Check         (block devices only) 
	DW     Error    ;  2 = build BPB           (block devices only)
	DW     Error    ;  3 = I/O control read         (not supported)
	DW     Read     ;  4 = read (input) from device  (int 21h, 3Fh)
	DW     Error    ;  5 = nondestructive read      (not supported)
	DW     Error    ;  6 = ret input status        (int 21h, 4406h)
	DW     Error    ;  7 = flush device input buffer (not supportd)
	DW     Error    ;  8 = write (output) to device  (int 21h, 40h)
	DW     Error    ;  9 = write with verify (== write)  (21h, 40h)
	DW     Error    ; 10 = ret output status       (int 21h, 4407h)
	DW     Error    ; 11 = flush output buffer      (not supported) 
	DW     Error    ; 12 = I/O control write        (not supported)
	DW     Success  ; 13 = device open               (int 21h, 3Dh)
	DW     Success  ; 14 = device close              (int 21h, 3Eh)
	DW     Error    ; 15 = removable media     (block devices only)
	DW     Error    ; 16 = Output until Busy   (mostly for spooler)
	DW     Error    ; 17 = not used
	DW     Error    ; 18 = not used
	DW     Error    ; 19 = generic IOCTL            (not supported)
	DW     Error    ; 20 = not used
	DW     Error    ; 21 = not used
	DW     Error    ; 22 = not used
	DW     Error    ; 23 = get logical device  (block devices only)
	DW     Error    ; 24 = set logical device  (block devices only)

font_write_table:
	FONT_CONF	<01h,00h,060ch,SBCS_06x12,0,offset org_SBCS_06x12>
	FONT_CONF	<01h,00h,0810h,SBCS_08x16,0,offset org_SBCS_08x16>
	FONT_CONF	<01h,00h,0813h,SBCS_08x19,0,offset org_SBCS_08x19>
	FONT_CONF	<01h,00h,0c18h,SBCS_12x24,0,offset org_SBCS_12x24>
	FONT_CONF	<01h,01h,0c0ch,DBCS_12x12,0,offset org_DBCS_12x12>
	FONT_CONF	<01h,01h,1010h,DBCS_16x16,0,offset org_DBCS_16x16>
	FONT_CONF	<01h,01h,1818h,DBCS_24x24,0,offset org_DBCS_24x24>
	DW		0FFFFh

;----------------------------------------------------------------------------;
; Strategy Routine
;----------------------------------------------------------------------------;
; device driver Strategy routine, called by MS-DOS kernel with
; ES:BX = address of request header
;----------------------------------------------------------------------------;

Strat   PROC FAR
	mov     word ptr cs:[lpHeader], bx      ; save the address of the 
	mov     word ptr cs:[lpHeader+2], es    ; request into 'lpHeader', and                  
	ret                                     ; back to MS-DOS kernel
Strat   ENDP


;----------------------------------------------------------------------------;
; Intr
;----------------------------------------------------------------------------;
; Device driver interrupt routine, called by MS-DOS kernel after call to     
; Strategy routine                                                           
; This routine basically calls the appropiate driver routine to handle the
; requested function. 
; Routines called by Intr expect:
;       ES:DI   will have the address of the request header
;       DS      will be set to cs
; These routines should only affect ax, saving es,di,ds at least
;
; Input: NONE   Output: NONE   -- data is transferred through request header
;
;----------------------------------------------------------------------------;

Intr    PROC FAR
	pusha
	pushf                   ; save flags
	cld                     ; direction flag: go from low to high address
				
	mov     si, cs          ; make local data addressable
	mov     ds, si          ; by setting ds = cs
			
	les     di, [lpHeader]  ; ES:DI = address of req.header

	xor     bx, bx        ; erase bx
	mov     bl,es:[di].ccode ; get BX = command code (from req.header)
	mov	si,bx
	shl	si,1
	add	si,offset dispatch
	
	.IF <bx gt MaxCmd>                ; check to make sure we have a valid
		call    Error             ; command code
	.ELSE                             ; else, call command-code routine,  
		call    [si]              ; indexed from Dispatch table
	.ENDIF                            ; (Ebx used to allow scaling factors)

	or      ax, fDONE       ; merge Done bit into status and
	mov     es:[di].stat,ax ; store status into request header
	
	popf                    ; restore registers
	popa                    ; restore flags
	ret                     ; return to MS-DOS kernel
Intr    ENDP


;----------------------------------------------------------------------------;
; Success: When the only thing the program needs to do is set status to OK 
;----------------------------------------------------------------------------;

Success PROC NEAR
	xor     ax, ax          ; set status to OK
	ret
Success ENDP

;----------------------------------------------------------------------------;
; error: set the status word to error: unknown command                       
;----------------------------------------------------------------------------;
Error   PROC    NEAR            
	mov     ax, fERROR + fUNKNOWN_E  ; error bit + "Unknown command" code
	ret                     
Error   ENDP


;----------------------------------------------------------------------------;
; read: put org_int10_add to ddddh.sys                        
;----------------------------------------------------------------------------;
Read    PROC    NEAR

	lds     si, [lpHeader]          ; put request header address in DS:SI

	mov     cx, [si].cmd_off         ; load cx with the size of buffer
	mov     es, [si].xseg           ; load es with segment of buffer
	mov     di, [si].xfer           ; load di with offset of buffer

	mov	ax,cs
	mov	ds,ax
	mov	si,offset org_int10_add
	add	si,[read_offset]
	mov	ax,4
	sub	ax,[read_offset]
	.IF <cx gt ax>
		mov	cx,ax
	.ENDIF
	.IF <cx gt 0>
		xor	bx,bx
tfr_loop:	movsb
		inc	read_offset
		inc	bx
		loop	tfr_loop
	.ENDIF

	les     di, [lpHeader]          ; re-load the request header
	mov     es:[di].cmd_off, bx      ; store the number of chars transferred
	xor 	ax,ax
	ret
Read    ENDP


;----------------------------------------------------------------------------;
; Int10_dispatch: 
;----------------------------------------------------------------------------;

Int10_dispatch PROC FAR
	.IF <ax eq 0012h>
		.IF <cs:[mode12cnt] ne 0>
			mov	al,03h			; Use mode 3
			dec	cs:[mode12cnt]
			jmp	simulate_iret		; Ignore mode 12
		.ENDIF
	.ENDIF
IFNDEF _X86_
;support mouse_video_io DEC-J Dec. 20 1993 TakeS
;; updated Mar. 24 1994 TakeS
;; BUG in using IME. change also mouse_video_io()
;	.IF< ah ge 0f0h > and
;	.IF< ah be 0fah >
;;; mvdm subsystem error with NT4.0
;;;		BOP	0beh			;call mouse_video_io()
;	.ENDIF
ENDIF ; !_X86_
	jmp	cs:org_int10_add		;go to original int10
Int10_dispatch ENDP

;----------------------------------------------------------------------------;
; Int15_dispatch: 
;----------------------------------------------------------------------------;

Int15_dispatch PROC FAR
	.IF <ah ne 50h>
		jmp	go_org_int15
	.ENDIF
	.IF <al ne 01h>
		jmp	go_org_int15
	.ENDIF
	.IF <bh ne 00h> and
	.IF <bh ne 01h>
		mov	ah,IRREGAL_FONT_TYPE
		stc
		ret	2
	.ENDIF
	.IF <bl ne 00h>
		mov	ah,IRREGAL_BL
		stc
		ret	2
	.ENDIF
	.IF <bp ne 00h>
		mov	ah,IRREGAL_CODE_PAGE
		stc
		ret	2
	.ENDIF

	push	si
	mov	si,offset font_write_table
search_font_routine:
	.IF <cs:[si].READ_WRITE eq 0ffh>
		pop	si
		jmp	error_font_size
	.ENDIF
	.IF <cs:[si].READ_WRITE eq al> and
	.IF <cs:[si].FONT_TYPE  eq bh> and
	.IF <cs:[si].FONT_SIZE  eq dx> and
	.IF <cs:[si].FONT_FLAG  eq FONT_ENABLE>
		mov	ax,cs
		mov	es,ax
		mov	bx,cs:[si].FONT_ADDR
		pop	si
		mov	ah,NO_ERROR
		clc
		ret	2
	.ENDIF
	add	si,FONTCNF_SIZE
	jmp	search_font_routine
error_font_size:
	mov	ah,IRREGAL_FONT_SIZE
	stc
	ret	2

go_org_int15:
	jmp	cs:org_int15_add		;go to original int15
Int15_dispatch ENDP

SBCS_06x12	PROC FAR		; SBCS font write routines
	call	cs:[org_SBCS_06x12]
	.IF <al eq 0>
		push	bx
		mov	bx,060ch
		mov	ah,3
		BOP	43h
		pop	bx
	.ENDIF
	ret
SBCS_06x12	ENDP

SBCS_08x16	PROC FAR
	call	cs:[org_SBCS_08x16]
	.IF <al eq 0>
		push	bx
		mov	bx,0810h
		mov	ah,3
		BOP	43h
		pop	bx
	.ENDIF
	ret
SBCS_08x16	ENDP

SBCS_08x19	PROC FAR
	call	cs:[org_SBCS_08x19]
	.IF <al eq 0>
		push	bx
		mov	bx,0813h
		mov	ah,3
		BOP	43h
		pop	bx
	.ENDIF
	ret
SBCS_08x19	ENDP

SBCS_12x24	PROC FAR
	call	cs:[org_SBCS_12x24]
	.IF <al eq 0>
		push	bx
		mov	bx,0c18h
		mov	ah,3
		BOP	43h
		pop	bx
	.ENDIF
	ret
SBCS_12x24	ENDP

DBCS_12x12	PROC FAR		; DBCS font write routines
	call	cs:[org_DBCS_12x12]
	.IF <al eq 0>
		push	bx
		mov	bx,0c0ch
		mov	ah,3
		BOP	43h
		pop	bx
	.ENDIF
	ret
DBCS_12x12	ENDP

DBCS_16x16	PROC FAR
	call	cs:[org_DBCS_16x16]
	.IF <al eq 0>
		push	bx
		mov	bx,1010h
		mov	ah,3
		BOP	43h
		pop	bx
	.ENDIF
	ret
DBCS_16x16	ENDP

DBCS_24x24	PROC FAR
	call	cs:[org_DBCS_24x24]
	.IF <al eq 0>
		push	bx
		mov	bx,1818h
		mov	ah,3
		BOP	43h
		pop	bx
	.ENDIF
	ret
DBCS_24x24	ENDP

; DON'T EVER EVER CALL HERE!!!!!!!!!
simulate_iret:
	IRET

;----------------------------------------------------------------------------;
;****************************************************************************;
;----------------------------------------------------------------------------;
;                                                                            ;
;       BEGINNING OF SPACE TO BE USED AS DRIVER MEMORY                       ;
;       ALL CODE AFTER ATOMLIST WILL BE ERASED BY THE DRIVER'S DATA          ; 
;       OR BY OTHER LOADED DRIVERS                                           ;
;                                                                            ;
;----------------------------------------------------------------------------;
;****************************************************************************;
;----------------------------------------------------------------------------;


;----------------------------------------------------------------------------;
;                    Initialization Data and Code               
; Only needed once, so after the driver is loaded and initialized it releases
; any memory that it won't use. The device allocates memory for its own use
; starting from 'ddddlList'.
;----------------------------------------------------------------------------;

ddddlList        label  NEAR
ifndef KOREA
ini_msg	db "Windows-NT MVDM Font Dispatch Driver Version 1.00"
        db lf,cr,eom
endif

Init    PROC NEAR

	les     di, [lpHeader]          ; allow us to use the request values

	mov     ax, MemEnd              ; set ax to End of Memory relative to
					; previous end of memory.
	mov     MaxMem, ax              ; store the new value in MaxMem 
	mov     es:[di].xseg,cs         ; tell MS-DOS the end of our used 
	mov     es:[di].xfer,ax         ; memory (the break address)
	push	es
	push	ds
	pusha

	mov	ax,0003h		; Clear display
	int	10h

ifndef KOREA
        ShowStr ini_msg
endif

	mov	ax,6300h		; Get DBCS Vector address
	int	21h
	mov	ax,[si]
	.IF <ax eq 0>
		mov	cs:[mode12cnt],0
	.ENDIF
	mov	ah,10h			; Tell NTVDM DOS DBCS Vector address
	BOP	43h

	mov	si,offset font_write_table
check_font_routine:
		.IF <cs:[si].READ_WRITE eq 0ffh>
			jmp	check_font_end
		.ENDIF
		mov ah,50h
		mov al,cs:[si].READ_WRITE
		mov bh,cs:[si].FONT_TYPE
		xor bl,bl
		mov dx,cs:[si].FONT_SIZE
		mov bp,0
		int 15h
		.IF <nc> and
		.IF <ah eq 0>
			mov	cs:[si].FONT_FLAG,FONT_ENABLE
			mov	di,cs:[si].FONT_ORG
			mov	ax,es
			mov	word ptr cs:[di],bx
			mov	word ptr cs:[di+2],ax
		.ENDIF
		add	si,FONTCNF_SIZE
		jmp	check_font_routine
check_font_end:

	mov	ax,VECTOR_SEG		;Get original int10 vector
	mov	es,ax
	mov	ax,word ptr es:[4*10h+0]
	mov	word ptr cs:[org_int10_add+0],ax
	mov	ax,word ptr es:[4*10h+2]
	mov	word ptr cs:[org_int10_add+2],ax

	mov	ax,offset cs:Int10_dispatch	;Set my int10 vector
	mov	word ptr es:[4*10h+0],ax
	mov	ax,cs
	mov	word ptr es:[4*10h+2],ax

	mov	ax,word ptr es:[4*15h+0]
	mov	word ptr cs:[org_int15_add+0],ax
	mov	ax,word ptr es:[4*15h+2]
	mov	word ptr cs:[org_int15_add+2],ax

	mov	ax,offset cs:Int15_dispatch	;Set my int15 vector
	mov	word ptr es:[4*15h+0],ax
	mov	ax,cs
	mov	word ptr es:[4*15h+2],ax

	popa
	pop	ds
	pop	es

	xor	ax,ax
	ret
Init    ENDP

TEXT	ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\disp_win\disp_win.inc ===
;----------------------------------------------------------------------------;
;			Define macros
;----------------------------------------------------------------------------;

ShowStr MACRO str
    mov	    dx, offset str
    mov     ah, 9
    int     21h
ENDM

BOP MACRO func

	db	0c4h,0c4h,func
;	jmp	cs:[pass_disp_add]
;	int	44h
ENDM

;----------------------------------------------------------------------------;
;                          Flags & Numeric Equates                
;----------------------------------------------------------------------------;

MAX_ROW	EQU	25		; Max row count
MAX_COL	EQU	80		; Max column count
MaxFunc	EQU	1Dh		; int 10h max function No.
MaxCmd 	EQU     24              ; max command code for DOS 3.2+
cr      EQU     0Dh             ; carriage return
lf      EQU     0Ah             ; linefeed
eom     EQU     '$'             ; end-of-message signal
space   EQU     20h             ; ascii space
tab     EQU     09h             ; ascii tab

VECTOR_SEG	EQU	0000h	; Interrupt Vector segment
WORK_SEG	EQU	0040h	; BIOS work area segment
FULLSCREEN	EQU	1

MAJOR_VER	equ	1
MINOR_VER	equ	0
CP_JP           equ     932
CP_KO           equ     949
CP_US		equ	437

; definition of a Request Header structure so that we can access its elements. 
; this structure is not exhaustive at all: block device use some addresses for
; different purposes, and have data beyond the cmd_seg word.


REQ_HEADER      STRUC
	lengt   DB    ?               ; request header length
	unit    DB    ?               ; unit number (for Block Devs. only)
	ccode   DB    ?               ; command code
	stat    DW    ?               ; status word
	reserv  DB 8 DUP(?)           ; reserved for DOS us
	media   DB    ?               ; Media ID    (for Block Devs. only)
	xfer    DW    ?               ; offset of data buffer
	xseg    DW    ?               ; segment of data buffer
	cmd_off	DW    ?               ; count of bytes in request, or
	cmd_seg DW    ?               ; segment of CONFIG.SYS line
REQ_HEADER      ENDS

; values for the different 'magic numbers' used with Device Drivers

fNEXTLINK   EQU -1              ; word to tell DOS to substitute by address of
				; next device
fCHARDEVICE EQU 8000h           ; bit to define device as a character device
fOPENCLOSE  EQU 0040h           ; bit to indicate that device supports open/close
fDONE       EQU 0100h           ; Status Done bit meaning device is done
fERROR      EQU 8000h           ; Status Error bit meaning error on operation
fWRITE_E    EQU 000Ah           ; Write Fault Error bit
fREAD_E     EQU 000Bh           ; Read Fault Error bit
fUNKNOWN_E  EQU 0003h           ; Unknown Command Error bit

; values for the search flags used by Write Routine

fDELETE EQU     2
fINSERT EQU     4
fSEARCH EQU     8
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\cho.inc ===
DW      0FFFFh
        DW      904h, 7Eh,6,6,6,0Ch,0Ch,18h,30h,40h
        DW      704h, 7Eh,6,6,0Ch,18h,30h,40h
        DW      904h, 0F03Fh,3000h,3000h,3000h,3000h,3000h,2000h,6000h,4000h
        DW      502h, 0F81Fh,1800h,1800h,1800h,1000h
        DW      602h, 0F01Fh,3000h,3000h,3000h,3000h,2000h
        DW      704h, 7Fh,3,3,3,3,3,2
        DW      504h, 7Fh,3,3,3,2
        DW      502h, 7Fh,3,3,3,2
        DW      904h, 0FEh,36h,36h,36h,6Ch,6Ch,58h,90h,20h
        DW      704h, 7Fh,1Bh,1Bh,36h,26h,4Ch,10h
        DW      904h, 0F83Eh,1806h,1806h,1806h,1806h,1804h,1008h,3008h,2000h
        DW      502h, 0F83Eh,1806h,1806h,1806h,1008h
        DW      602h, 0F83Eh,1806h,1806h,1806h,1804h,1008h
        DW      704h, 0FFh,33h,33h,33h,33h,43h,2
        DW      504h, 0FFh,33h,33h,23h,42h
        DW      504h, 0FFh,33h,33h,33h,22h
        DW      502h, 0FFh,33h,33h,33h,22h
        DW      804h, 70h,30h,30h,30h,30h,30h,8030h,1Fh
        DW      604h, 70h,30h,30h,30h,8030h,1Fh
        DW      604h, 38h,18h,18h,18h,18h,0F80Fh
        DW      402h, 38h,18h,18h,0F00Fh
        DW      502h, 38h,18h,18h,18h,0F00Fh
        DW      504h, 0E0h,60h,60h,60h,3Fh
        DW      404h, 0E0h,60h,60h,3Fh
        DW      402h, 0E0h,60h,60h,3Fh
        DW      804h, 7Eh,30h,30h,30h,30h,30h,8030h,1Fh
        DW      604h, 0FEh,60h,60h,60h,8060h,3Fh
        DW      604h, 0F03Fh,18h,18h,18h,18h,0F00Fh
        DW      402h, 0F03Fh,18h,18h,0F00Fh
        DW      502h, 0F03Fh,18h,18h,18h,0F00Fh
        DW      504h, 0FFh,60h,60h,60h,3Fh
        DW      404h, 0FFh,60h,60h,3Fh
        DW      402h, 0FFh,60h,60h,3Fh
        DW      804h, 0FFh,6Ch,6Ch,6Ch,6Ch,6Ch,806Ch,3Fh
        DW      604h, 0FFh,6Ch,6Ch,6Ch,806Ch,3Fh
        DW      604h, 0F83Eh,0C018h,0C018h,0C018h,0C019h,0F80Eh
        DW      402h, 0F83Eh,0C018h,0C018h,0F80Fh
        DW      502h, 0F83Eh,0C018h,0C018h,0C018h,0F80Fh
        DW      504h, 0FFh,6Ch,6Ch,6Ch,3Fh
        DW      404h, 0FFh,6Ch,6Ch,3Fh
        DW      402h, 0FFh,6Ch,6Ch,3Fh
        DW      804h, 0FEh,6,6,0FEh,60h,60h,8060h,3Fh
        DW      604h, 0FEh,6,0FEh,60h,8060h,3Fh
        DW      704h, 0F03Fh,3000h,3000h,0F03Fh,18h,18h,0F00Fh
        DW      502h, 0F03Fh,3000h,0F03Fh,18h,0F01Fh
        DW      602h, 0F03Fh,3000h,0F03Fh,18h,18h,0F00Fh
        DW      604h, 0FFh,3,0FFh,60h,60h,3Fh
        DW      504h, 0FFh,3,0FFh,60h,3Fh
        DW      502h, 0FFh,3,0FFh,60h,3Fh
        DW      704h, 0FEh,66h,66h,66h,66h,66h,7Eh
        DW      604h, 0FEh,66h,66h,66h,66h,7Eh
        DW      604h, 0F03Fh,3018h,3018h,3018h,3018h,0F01Fh
        DW      402h, 0F03Fh,3018h,3018h,0F01Fh
        DW      502h, 0F03Fh,3018h,3018h,3018h,0F01Fh
        DW      504h, 0FFh,63h,63h,63h,7Fh
        DW      404h, 0FFh,63h,63h,7Fh
        DW      402h, 0FFh,63h,63h,7Fh
        DW      804h, 0Eh,0E6h,66h,7Eh,66h,66h,66h,7Eh
        DW      604h, 0Eh,0E6h,7Eh,66h,66h,7Eh
        DW      704h, 7000h,3038h,3018h,0F01Fh,3018h,3018h,0F01Fh
        DW      502h, 7000h,3038h,0F01Fh,3018h,0F01Fh
        DW      602h, 7000h,3038h,0F01Fh,3018h,3018h,0F01Fh
        DW      702h, 7,0E3h,63h,7Fh,63h,63h,7Fh
        DW      602h, 7,0E3h,63h,7Fh,63h,7Fh
        DW      504h, 7,0E3h,7Fh,63h,7Fh
        DW      502h, 7,0E3h,7Fh,63h,7Fh
        DW      804h, 6,0FBh,0DBh,0DBh,0FFh,0DBh,0DBh,0FFh
        DW      604h, 0B6h,0DBh,0FFh,0DBh,0DBh,0FFh
        DW      704h, 0B83Bh,9819h,9819h,0F81Fh,9819h,9819h,0F81Fh
        DW      502h, 0B83Bh,9819h,0F81Fh,9819h,0F81Fh
        DW      602h, 0B83Bh,9819h,0F81Fh,9819h,9819h,0F81Fh
        DW      702h, 7,0FBh,0DBh,0FFh,0DBh,0DBh,0FFh
        DW      602h, 7,0FBh,0DBh,0FFh,0DBh,0FFh
        DW      804h, 1Ch,0Ch,0Ch,18h,1Ch,36h,63h,0C1h
        DW      702h, 0Ch,6,6,0Ch,1Eh,33h,41h
        DW      702h, 8003h,8001h,8001h,0C003h,3006h,180Ch,0C30h
        DW      500h, 8003h,8001h,0C003h,700Eh,1838h
        DW      502h, 8003h,8001h,0C003h,700Eh,1838h
        DW      602h, 18h,0Ch,0Ch,1Bh,8031h,80C0h
        DW      502h, 1Ch,0Ch,1Bh,8031h,80C0h
        DW      502h, 1Ch,0Ch,1Ch,33h,80C1h
        DW      402h, 1Ch,0Ch,1Bh,8061h
        DW      904h, 36h,1Bh,1Bh,13h,36h,3Fh,4Dh,89h,10h
        DW      702h, 36h,1Bh,1Bh,36h,7Eh,0DBh,31h
        DW      702h, 0C00Ch,6006h,6006h,0F00Fh,9819h,0C23h,4
        DW      600h, 0C00Ch,6006h,0C00Ch,0B01Fh,1863h,0Ch
        DW      602h, 0C00Ch,6006h,0C00Eh,0B01Bh,1823h,4
        DW      702h, 6Ch,36h,36h,7Ch,6Fh,8099h,20h
        DW      602h, 6Ch,36h,36h,7Fh,80D9h,30h
        DW      502h, 36h,1Bh,1Bh,803Fh,0C06Ch
        DW      502h, 3Fh,1Bh,803Fh,0C04Ch,10h
        DW      704h, 3Ch,66h,0C3h,0C3h,0C3h,66h,3Ch
        DW      604h, 3Ch,66h,0C3h,0C3h,66h,3Ch
        DW      702h, 8003h,600Ch,3018h,3018h,3018h,600Ch,8003h
        DW      600h, 0C003h,6006h,300Ch,300Ch,6006h,0C003h
        DW      700h, 8001h,6006h,300Ch,300Ch,300Ch,6006h,8001h
        DW      604h, 1Eh,33h,8061h,8061h,33h,1Eh
        DW      502h, 3Eh,63h,63h,63h,3Eh
        DW      502h, 1Eh,33h,8061h,33h,1Eh
        DW      402h, 3Eh,63h,63h,3Eh
        DW      904h, 7Eh,0Ch,0Ch,18h,18h,34h,26h,42h,82h
        DW      604h, 7Eh,6,0Ch,1Eh,33h,41h
        DW      704h, 0F81Fh,8001h,8001h,0C003h,3006h,180Ch,830h
        DW      502h, 0F81Fh,8001h,0C003h,700Eh,1838h
        DW      604h, 7Fh,0Ch,0Ch,1Eh,33h,41h
        DW      504h, 7Fh,0Ch,1Eh,33h,41h
        DW      502h, 7Fh,0Ch,1Eh,33h,41h
        DW      904h, 0FFh,33h,33h,26h,76h,5Fh,8Dh,9,10h
        DW      704h, 7Fh,1Bh,36h,3Ch,4Eh,9Bh,21h
        DW      704h, 0F03Fh,3006h,600Ch,0C01Eh,0B033h,1843h,806h
        DW      502h, 0F03Fh,3006h,600Fh,0F019h,1823h
        DW      602h, 0F03Fh,3006h,600Eh,0F01Bh,9821h,802h
        DW      604h, 7Fh,1Bh,36h,3Fh,8049h,10h
        DW      504h, 7Fh,1Bh,3Eh,4Fh,19h
        DW      502h, 807Fh,8019h,3Fh,8047h,8008h
        DW      0A02h, 38h,18h,7Eh,6,6,0Ch,0Ch,1Eh,33h,41h
        DW      800h, 38h,18h,7Eh,6,0Ch,1Eh,33h,41h
        DW      802h, 7,3,0F03Fh,6000h,0C000h,8003h,700Eh,1830h
        DW      600h, 8001h,0F81Fh,8001h,0C003h,700Eh,1838h
        DW      700h, 8003h,8001h,0F83Fh,8001h,0C003h,700Eh,1838h
        DW      802h, 1Ch,0Ch,807Fh,0Ch,1Eh,33h,8061h,8080h
        DW      700h, 1Ch,0Ch,807Fh,0Ch,1Bh,8031h,80C0h
        DW      602h, 1Ch,0Ch,7Fh,0Ch,3Bh,80E1h
        DW      600h, 1Ch,0Ch,7Fh,0Ch,3Bh,80E1h
        DW      904h, 7Eh,6,6,7Eh,0Ch,0Ch,18h,30h,40h
        DW      704h, 7Eh,6,7Eh,0Ch,18h,30h,40h
        DW      904h, 0F03Fh,3000h,3000h,0F03Fh,3000h,3000h,2000h,6000h,4000h
        DW      502h, 0F81Fh,1800h,0F81Fh,1800h,1000h
        DW      602h, 0F01Fh,3000h,3000h,0F01Fh,3000h,2000h
        DW      704h, 7Fh,3,3,7Fh,3,3,2
        DW      504h, 7Fh,3,7Fh,3,2
        DW      502h, 7Fh,3,7Fh,3,2
        DW      804h, 0FEh,60h,60h,7Ch,60h,60h,8060h,3Fh
        DW      604h, 0FEh,60h,7Ch,60h,8060h,3Fh
        DW      704h, 0F03Fh,18h,18h,0F01Fh,18h,18h,0F00Fh
        DW      502h, 0F03Fh,18h,0F01Fh,18h,0F00Fh
        DW      604h, 0FFh,60h,7Eh,60h,60h,3Fh
        DW      504h, 0FFh,60h,7Eh,60h,3Fh
        DW      504h, 0FFh,60h,7Fh,60h,3Fh
        DW      502h, 0FFh,60h,7Eh,60h,3Fh
        DW      804h, 7Fh,26h,26h,36h,36h,34h,34h,7Fh
        DW      604h, 7Fh,26h,36h,36h,34h,7Fh
        DW      604h, 0F81Fh,6004h,6006h,6006h,4006h,0F81Fh
        DW      402h, 0F81Fh,6006h,6006h,0F81Fh
        DW      502h, 0F81Fh,6004h,6006h,4006h,0F81Fh
        DW      504h, 7Fh,26h,36h,34h,7Fh
        DW      404h, 7Fh,26h,34h,7Fh
        DW      402h, 7Fh,36h,36h,7Fh
        DW      0A02h, 1Ch,0Ch,7Fh,0,1Ch,36h,63h,63h,36h,1Ch
        DW      800h, 1Ch,0Ch,0FFh,36h,63h,63h,36h,1Ch
        DW      902h, 8003h,8001h,0FC3Fh,0,0E007h,300Ch,300Ch,300Ch,0E007h
        DW      600h, 8003h,8001h,0F83Fh,0C007h,600Ch,0C007h
        DW      700h, 8003h,8001h,0FC3Fh,0E007h,300Ch,300Ch,0E007h
        DW      802h, 1Ch,0Ch,807Fh,1Eh,33h,33h,33h,1Eh
        DW      700h, 1Ch,0Ch,807Fh,1Eh,33h,33h,1Eh
        DW      600h, 0Ch,807Fh,1Eh,33h,33h,1Eh
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\choi.inc ===
DW      0,2,22,38,58,70,58,84
        DW      100,100,112,124,144,160,180,192
        DW      180,206,222,234,246,258,276,290
        DW      304,314,304,326,338,338,348,358
        DW      376,390,404,414,404,426,438,438
        DW      448,458,476,490,504,514,504,526
        DW      538,526,548,558,576,590,606,618
        DW      606,632,646,646,658,670,686,700
        DW      714,724,714,736,748,736,758,768
        DW      786,800,816,828,816,842,858,872
        DW      884,896,914,928,944,956,944,970
        DW      986,986,986,1000,1018,1034,1050,1062
        DW      1050,1074,1088,1100,1112,1122,1142,1158
        DW      1174,1188,1174,1202,1218,1232,1244,1256
        DW      1272,1286,1302,1316,1302,1332,1346,1358
        DW      1370,1380,1400,1414,1430,1430,1430,1442
        DW      1456,1456,1468,1480,1500,1516,1532,1544
        DW      1532,1558,1572,1558,1584,1596,1618,1636
        DW      1654,1668,1654,1684,1702,1718,1732,1746
        DW      1766,1782,1802,1814,1802,1828,1844,1844
        DW      1856,1868,1886,1900,1916,1916,1916,1928
        DW      1942,1954,1966,1978,1996,2010,2024,2034
        DW      2024,2046,2058,2046,2068,2078,2100,2118
        DW      2138,2152,2138,2168,2186,2186,2202
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\debug.inc ===
;--- Debugging Facilities (skkhang) ------------------------------

IF DEBUG
        EXTRN   _DebugChar:Near, _DebugString:Near, _DebugNumber:Near
ENDIF

DBGCh   MACRO   reg
IF DEBUG
        IFDIF   <reg>, <al>
        push    ax
        mov     al, reg
        ENDIF
        call    _DebugChar
        IFDIF   <reg>, <al>
        pop     ax
        ENDIF
ENDIF
        ENDM

DBGStr  MACRO   addr
IF DEBUG
        IFDIF   <addr>, <bx>
        push    bx
        mov     bx, addr
        ENDIF
        call    _DebugString
        IFDIF   <addr>, <bx>
        pop     bx
        ENDIF
ENDIF
        ENDM

DBGNum  MACRO   val
IF DEBUG
        push    ax
        IFDIF   <val>, <ax>
        mov     ax, val
        ENDIF
        call    _DebugNumber
        mov     al, 0Dh
        call    _DebugChar
        mov     al, 0Ah
        call    _DebugChar
        pop     ax
ENDIF
        ENDM

DBGNum2 MACRO   val
IF DEBUG
        IFDIF   <val>, <ax>
        push    ax
        mov     ax, val
        ENDIF
        call    _DebugNumber
        IFDIF   <val>, <ax>
        pop     ax
        ENDIF
ENDIF
        ENDM

DBGCrLf MACRO
IF DEBUG
        push    ax
        mov     al, 0Dh
        call    _DebugChar
        mov     al, 0Ah
        call    _DebugChar
        pop     ax
ENDIF
        ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\dual.asm ===
CODE    SEGMENT
ASSUME  CS:CODE,DS:CODE

        ORG     100h

INCLUDE EQU.INC

Start:
        jmp     PrgStart

eom             =       0

LogoPos         =       0600h
CodePos         =       LogoPos+421h
MemPos          =       LogoPos+521h
FilePos         =       LogoPos+621h
PrinterPos      =       LogoPos+721h
HekeyPos        =       LogoPos+821h
HjkeyPos        =       LogoPos+921h
KbdPos          =       LogoPos+0a21h
HelpPos         =       LogoPos+0C10h

MenuData        STRUC
mFlag           db      ?
mCurPos         dw      ?
mFlagAddr       dw      ?
mKbdSrv         dw      ?
mMaxItem        db      ?
mCurItem        db      ?
mHelpMsg        dw      ?
mMenuMsg        dw      ?
MenuData        ENDS

; mFlag
ByteDisp        =       00000010b
StringDisp      =       00000100b


;------------------------
LogoMsg label   byte
 db '              ',cr,lf
 db '               HanGeul BIOS setup program Version 6.12           ',cr,lf
 db '               (C)Copyright Qnix computer Co., Ltd.  1992        ',cr,lf
 db '              ',cr,lf
 db '               CODE/SPEC.                                       ',cr,lf
 db '               FONT MEMORY                                      ',cr,lf
 db '               FONT FILENAME                                    ',cr,lf
 db '               PRINTER TYPE                                     ',cr,lf
 db '               HAN/ENG KEY                                      ',cr,lf
 db '               HANJA KEY                                        ',cr,lf
 db '               KBD TYPE                                         ',cr,lf
 db '              ',cr,lf
 db '                                                                 ',cr,lf
 db '              '
LogoLng         =       $-LogoMsg

MenuSelHelp     db      'USAGE : cursor, enter, ESC      ',eom
StringSelHelp   label   byte
CodeSelHelp     db      'USAGE : up, down, BS, enter, ESC',eom
CodeSelHelpLng  =       $-CodeSelHelp-1
SaveMsg         db      ' Save and exit (N/y) ',eom
DefaultMsg      db      'default',eom
DefaultMsgLng   =       $-DefaultMsg-1
FileCreatErrMsg db      cr,lf,'File creation error !',7,cr,lf,'$'

;------------------------
GrpCnvtTbl      db      '',''
                db      '',''
                db      '',''
                db      '',''
                db      '',''
                db      '',''
                db      '',''
                db      '',''
                db      '',''
                db      '',''
GrpCnvtTblLng   =       ($-GrpCnvtTbl)/2

;------------------------
MenuSelect      label   byte
                db      48h,1           ; up
                db      50h,2           ; down
                db      4bh,3           ; left
                db      4dh,4           ; right
                db      1ch,5           ; enter
                db      01h,6           ; ESC
                dw      -1

MakeCode        label   byte
                db      48h,1           ; up
                db      50h,2           ; down
                db      4bh,8           ; left
                db      4dh,9           ; right
                db      1ch,5           ; enter
                db      01h,6           ; ESC
                dw      -1

MakeString      label   byte
                db      48h,1           ; up
                db      50h,2           ; down
                db      1ch,5           ; enter
                db      01h,6           ; ESC
                db      0eh,7           ; BS
                dw      -1


;------------------------
MainTbl         label   word
                dw      offset Sub1Tbl
                dw      offset Sub2Tbl
                dw      offset Sub3Tbl
                dw      offset Sub4Tbl
                dw      offset Sub5Tbl
                dw      offset Sub6Tbl
                dw      offset Sub7Tbl
MainTblLng      =       ($-MainTbl)/2

Sub1Tbl         label   byte
                db      0
                dw      CodePos
                dw      offset Sub1DataTbl
                dw      offset KbdMenu
                db      Sub1DataTblLng
CurCode         db      1
                dw      offset MenuSelHelp
                dw      offset Sub1Msg1
                dw      offset Sub1Msg2
                dw      offset Sub1Msg3
                dw      offset Sub1Msg4
Sub1Msg1        db      'English         ',eom
Sub1Msg2        db      'KS C 5842 - 1991',eom
Sub1Msg3        db      'Chohab          ',eom
Sub1Msg4        db      'Wansung 7 bit   ',eom
Sub1DataTbl     label   byte
                db      0
                db      WSung or HangeulMode
                db      Chab or HangeulMode
                db      WSung7 or HangeulMode
Sub1DataTblLng  =       $-Sub1DataTbl

Sub2Tbl         label   byte
                db      0
                dw      MemPos
                dw      offset Sub2DataTbl
                dw      offset KbdMenu
                db      Sub2DataTblLng
CurMem          db      0
                dw      offset MenuSelHelp
                dw      offset Sub2Msg1
                dw      offset Sub2Msg2
                dw      offset Sub2Msg3
                dw      offset Sub2Msg4
                dw      offset Sub2Msg5
Sub2Msg1        db      'Automatic',eom
Sub2Msg2        db      'HIMEM    ',eom
Sub2Msg3        db      'EMS      ',eom
Sub2Msg4        db      'Extended ',eom
Sub2Msg5        db      'Real     ',eom
Sub2DataTbl     label   byte
                db      0
                db      HiMem
                db      EmsMem
                db      ExtMem
                db      RealMem
Sub2DataTblLng  =       $-Sub2DataTbl

Sub3Tbl         label   byte
                db      StringDisp
                dw      FilePos
                dw      offset FontFileName
                dw      offset KbdString
                db      1
                db      0
                dw      offset StringSelHelp

Sub4Tbl         label   byte
                db      0
                dw      PrinterPos
                dw      offset Sub4DataTbl
                dw      offset KbdMenu
                db      Sub4DataTblLng
CurPrinter      db      1
                dw      offset MenuSelHelp
                dw      offset Sub4Msg1
                dw      offset Sub4Msg2
                dw      offset Sub4Msg3
                dw      offset Sub4Msg4
                dw      offset Sub4Msg5
                dw      offset Sub4Msg6
Sub4Msg1        db      'none select ',eom
Sub4Msg2        db      'KS          ',eom
Sub4Msg3        db      'QLBP        ',eom
Sub4Msg4        db      'KSSM        ',eom
Sub4Msg5        db      'KSSM(Chohab)',eom
Sub4Msg6        db      'TG(Chohab)  ',eom
Sub4DataTbl     label   byte
                db      NoPrt
                db      KsPrt
                db      wLbp
                db      wKmPrt
                db      cKmPrt
                db      TgPrt
Sub4DataTblLng  =       $-Sub4DataTbl

Sub5Tbl         label   byte
                db      ByteDisp
                dw      HekeyPos
                dw      offset HeKey
                dw      offset KbdCode
                db      1
                db      0
                dw      offset MenuSelHelp

Sub6Tbl         label   byte
                db      ByteDisp
                dw      HjkeyPos
                dw      offset HjKey
                dw      offset KbdCode
                db      1
                db      0
                dw      offset MenuSelHelp

Sub7Tbl         label   byte
                db      0
                dw      KbdPos
                dw      offset Sub7DataTbl
                dw      offset KbdMenu
                db      Sub7DataTblLng
CurKbd          db      0
                dw      offset MenuSelHelp
                dw      offset Sub7Msg1
                dw      offset Sub7Msg2
Sub7Msg1        db      'Default',eom
Sub7Msg2        db      '101 KBD',eom
Sub7DataTbl     label   byte
                db      0
                db      SetKbd101
Sub7DataTblLng  =       $-Sub7DataTbl


;------------------------
MenuPos dw      0                       ; main table index
CharCnt dw      0                       ; char counter
CurPos  dw      FilePos

OrgMode db      0
NorAttr db      0
SelAttr db      0
BakAttr db      0

FileName db     'C:\HECON.CFG',eom
Handle  dw      0

;------------------------
ConfigData      label   byte
CfgFilename     db      'HECON.CFG'     ; 9 byte
CodeStat        db      HangeulMode
FontFileName    db      'FONT.SYS'
                db      24 dup(0)       ; drive/path/filename
MemStat         db      0               ; real/EMS/ext./HIMEM
HeKey           db      0
HjKey           db      0
PrinterStat     db      0
KbdType         db      0
                db      3 dup(0)        ; reserved


;------------------------
PrgStart:
        call    Modeset
        call    SetAttribute
        call    DisplayLogo
        call    OpenFile
        call    DisplayAll
        mov     ah,1
        xor     bh,bh
        mov     cx,220dh
        int     10h
        call    Action
        call    RestoreScreen
Exit:
        mov     ah,4ch
        int     21h

;------------------------------------------------------------------------
Modeset:
        mov     ah,0fh
        int     10h
        mov     [OrgMode],al
        int     11h
        test    al,30h
        mov     ax,7
        jpe     @f
        mov     al,3
@@:
        int     10h
        mov     ah,1
        mov     cx,2000h
        int     10h
        ret

;------------------------
SetAttribute:
        int     11h
        mov     [NorAttr],70h
        mov     [SelAttr],7
        mov     [BakAttr],70h
        cmp     al,30h
        jpe     @f
        mov     [NorAttr],70h
        mov     [SelAttr],7
        mov     [BakAttr],70h
@@:
        ret

;------------------------
DisplayLogo:
        mov     ax,920h
        xor     bh,bh
        mov     bl,[BakAttr]
        mov     cx,80*25
        int     10h
        push    es
        mov     ax,0fd00h
        int     10h
        mov     si,bx
        mov     si,es:[si+16]
        mov     ah,byte ptr es:[si+7+4+1]
        pop     es
        cmp     al,0fdh
        jnz     DisplayLogoDo           ; jump if english environment
        test    ah,00000001b
        jz      DisplayLogoDo           ; jump if english mode
        mov     di,offset LogoMsg
        mov     cx,LogoLng
@@:
        mov     al,[di]
        call    ChgTblGrp
        mov     [di],al
        inc     di
        loop    @b
DisplayLogoDo:
        mov     bp,offset LogoMsg
        mov     dx,LogoPos
        mov     cx,LogoLng
        mov     bl,[NorAttr]
        xor     bh,bh
        mov     ax,1300h
        int     10h
        ret
ChgTblGrp:
        push    cx
        mov     bl,al
        mov     si,offset GrpCnvtTbl
        mov     cx,GrpCnvtTblLng
@@:
        lodsw
        cmp     al,bl
        jz      @f
        loop    @b
        mov     ah,bl
@@:
        mov     al,ah
        pop     cx
        ret

;------------------------
OpenFile:
        mov     ah,19h
        int     21h
        cmp     al,2
        jbe     @f
        mov     al,2
@@:
        add     al,'A'
        mov     si,offset Filename
        mov     [si],al                 ; set drive latter
        mov     dx,offset FileName
        mov     ax,3d02h
        int     21h
        jc      GetConfigFileCreat
        mov     [Handle],ax
        mov     dx,offset ConfigData
        mov     ah,3fh
        mov     bx,[Handle]
        mov     cx,50
        int     21h
        jnc     GetConfigFileRead
GetConfigFileCreat:
        mov     dx,offset FileName
        mov     ah,3ch
        mov     cx,2                    ; hidden file
        int     21h
        mov     [Handle],ax
        jnc     @f
        mov     ah,9
        mov     dx,offset FileCreatErrMsg
        int     21h
@@:
        ret
GetConfigFileRead:
        mov     si,offset CfgFilename
        mov     di,offset FileName
        add     di,3
        mov     cx,9
        rep cmpsb
        jnz     GetConfigFileCreat
;
        mov     ah,[CodeStat]
        and     ah,not ChabLoad
        mov     si,offset Sub1DataTbl
        mov     bx,si
        mov     cx,Sub1DataTblLng
@@:
        lodsb
        cmp     al,ah
        jz      @f
        loop    @b
@@:
        sub     si,bx
        mov     bx,si
        dec     bx
        mov     [CurCode],bl
;
        mov     ah,[MemStat]
        mov     si,offset Sub2DataTbl
        mov     bx,si
        mov     cx,Sub2DataTblLng
@@:
        lodsb
        cmp     al,ah
        jz      @f
        loop    @b
@@:
        sub     si,bx
        mov     bx,si
        dec     bx
        mov     [CurMem],bl
;
        mov     ah,[PrinterStat]
        mov     si,offset Sub4DataTbl
        mov     bx,si
        mov     cx,Sub4DataTblLng
@@:
        lodsb
        cmp     al,ah
        jz      @f
        loop    @b
@@:
        sub     si,bx
        mov     bx,si
        dec     bx
        mov     [CurPrinter],bl
;
        mov     ah,[KbdType]
        mov     si,offset Sub7DataTbl
        mov     bx,si
        mov     cx,Sub7DataTblLng
@@:
        lodsb
        cmp     al,ah
        jz      @f
        loop    @b
@@:
        sub     si,bx
        mov     bx,si
        dec     bx
        mov     [CurKbd],bl
        ret

;------------------------
DisplayAll:
        mov     cx,MainTblLng
@@:
        push    cx
        mov     bl,[NorAttr]
        call    DispMenu
        inc     [MenuPos]
        pop     cx
        loop    @b
        mov     [MenuPos],0
        mov     bl,[SelAttr]
        call    DispMenu
        call    DispHelp
        ret


;------------------------------------------------------------------------
Action:
        xor     ah,ah
        int     16h
        mov     bx,[MenuPos]
        shl     bx,1
        mov     bx,[bx+MainTbl]
        call    [bx+mKbdSrv]
        jnc     @f
        mov     ax,0e07h
        int     10h
        jmp     short Action
@@:
        mov     cl,ah
        xor     ch,ch
        shl     cx,1
        mov     si,cx
        call    [si].ActionTbl
        jnc     Action
        ret
ActionTbl       label   word
                dw      offset EditString       ; 0
                dw      offset MenuUp           ; 1
                dw      offset MenuDown         ; 2
                dw      offset MenuPost         ; 3
                dw      offset MenuNext         ; 4
                dw      offset CheckSave        ; 5
                dw      offset Escape           ; 6
                dw      offset EditBs           ; 7
                dw      offset CodeDec          ; 8
                dw      offset CodeInc          ; 9

;------------------------
EditString:
        cmp     [CharCnt],StringLng
        jae     EditStringErr
        mov     si,[MenuPos]
        shl     si,1
        mov     si,[si+MainTbl]
        mov     di,[si].mFlagAddr
        cmp     [CharCnt],0
        jnz     @f
        push    ax
        push    di
        mov     dx,[si].mCurPos
        mov     [CurPos],dx
        mov     di,offset FontFileName
        mov     cx,StringLng
        xor     al,al
        rep stosb
        pop     di
        pop     ax
@@:
        add     di,[CharCnt]
        mov     [di],al
        inc     [CharCnt]
        mov     bl,[SelAttr]
        call    DispMenu
        inc     [CurPos]
        mov     dx,[CurPos]
        mov     ah,2
        xor     bh,bh
        int     10h
        clc
        ret
EditStringErr:
        call    Beep
        clc
        ret

;------------------------
MenuUp:
        mov     [CharCnt],0
        mov     [CurPos],FilePos
        mov     bl,[NorAttr]
        call    DispMenu
        dec     [MenuPos]
        cmp     [MenuPos],-1
        jnz     @f
        mov     [MenuPos],MainTblLng-1
@@:
        call    DispHelp
        mov     bl,[SelAttr]
        call    DispMenu
        call    CursorControl
        clc
        ret

;------------------------
MenuDown:
        mov     [CharCnt],0
        mov     [CurPos],FilePos
        mov     bl,[NorAttr]
        call    DispMenu
        inc     [MenuPos]
        cmp     [MenuPos],MainTblLng
        jb      @f
        mov     [MenuPos],0
@@:
        call    DispHelp
        mov     bl,[SelAttr]
        call    DispMenu
        call    CursorControl
        clc
        ret

;------------------------
MenuPost:
        mov     si,[MenuPos]
        shl     si,1
        mov     si,[si+MainTbl]
        mov     al,[si].mMaxItem
        dec     [si].mCurItem
        cmp     [si].mCurItem,-1
        jnz     @f
        dec     al
        mov     [si].mCurItem,al
@@:
        mov     bl,[SelAttr]
        call    DispMenu
        clc
        ret

;------------------------
MenuNext:
        mov     si,[MenuPos]
        shl     si,1
        mov     si,[si+MainTbl]
        mov     al,[si].mMaxItem
        inc     [si].mCurItem
        cmp     [si].mCurItem,al
        jb      @f
        mov     [si].mCurItem,0
@@:
        mov     bl,[SelAttr]
        call    DispMenu
        clc
        ret

;------------------------
CheckSave:
        xor     bh,bh
        mov     ah,3
        int     10h
        and     ch,not 20h
        mov     ah,1
        int     10h
        mov     dx,HelpPos
        mov     bl,[NorAttr]
        xor     bh,bh
        mov     ah,2
        int     10h
        mov     cx,CodeSelHelpLng
        mov     ah,9
        mov     al,' '
        int     10h
        mov     si,offset SaveMsg
        mov     bl,[SelAttr]
        call    DispString
        xor     ah,ah
        int     16h
        or      al,20h
        cmp     al,'y'
        jnz     CheckSaveEnd
        mov     bl,[CurCode]
        xor     bh,bh
        mov     al,[bx+Sub1DataTbl]
        mov     [CodeStat],al
        mov     bl,[CurMem]
        xor     bh,bh
        mov     al,[bx+Sub2DataTbl]
        mov     [MemStat],al
        mov     bl,[CurKbd]
        xor     bh,bh
        mov     al,[bx+Sub7DataTbl]
        mov     [KbdType],al
        mov     bl,[CurPrinter]
        xor     bh,bh
        mov     al,[bx+Sub4DataTbl]
        mov     [PrinterStat],al
        cmp     [PrinterStat],NoPrt
        jz      @f
        or      [CodeStat],ChabLoad
@@:
        test    [CodeStat],Chab or WSung7
        jz      @f
        or      [CodeStat],ChabLoad
@@:
        test    [CodeStat],ChabLoad
        jnz     @f
        and     [CodeStat],not (Chab or WSung7)
        mov     [PrinterStat],NoPrt
@@:
        xor     cx,cx
        xor     dx,dx
        mov     bx,[Handle]
        mov     ax,4200h
        int     21h
        mov     dx,offset ConfigData
        mov     ah,40h
        mov     cx,50
        int     21h
        mov     ah,3eh
        int     21h
        stc
        ret
CheckSaveEnd:
        call    DispHelp
        call    CursorControl
        mov     bl,[SelAttr]
        call    DispMenu
        clc
        ret

;------------------------
Escape:
        stc
        ret

;------------------------
EditBs:
        cmp     [CharCnt],0
        jz      EditBsErr
        dec     [CharCnt]
        mov     si,[MenuPos]
        shl     si,1
        mov     si,[si+MainTbl]
        mov     di,[si].mFlagAddr
        add     di,[CharCnt]
        mov     byte ptr [di],0
        mov     bl,[SelAttr]
        call    DispMenu
        dec     [CurPos]
        mov     dx,[CurPos]
        mov     ah,2
        xor     bh,bh
        int     10h
        clc
        ret
EditBsErr:
        call    Beep
        clc
        ret

;------------------------
CodeDec:
        mov     si,[MenuPos]
        shl     si,1
        mov     si,[si+MainTbl]
        mov     dx,[si].mCurPos
        mov     si,[si].mFlagAddr
        mov     bl,[SelAttr]
        dec     byte ptr [si]
        jz      CodeDefMsg
CodeHexMsg:
        mov     bl,[NorAttr]
        xor     bh,bh
        mov     ah,2
        int     10h
        mov     cx,DefaultMsgLng
        mov     ah,9
        mov     al,' '
        int     10h
        mov     bl,[SelAttr]
        call    DispMenu
        ret

;------------------------
CodeInc:
        mov     si,[MenuPos]
        shl     si,1
        mov     si,[si+MainTbl]
        mov     dx,[si].mCurPos
        mov     si,[si].mFlagAddr
        mov     bl,[SelAttr]
        inc     byte ptr [si]
        jnz     CodeHexMsg
CodeDefMsg:
        mov     bl,[SelAttr]
        mov     si,offset DefaultMsg
        call    DispString
        ret


;------------------------------------------------------------------------
DispMenu:
        mov     si,[MenuPos]
        shl     si,1
        mov     si,[si+MainTbl]
        mov     dx,[si].mCurPos
        mov     al,[si].mFlag
        and     ax,00000110b
        mov     di,ax
        call    [di].DispMenuTbl
        ret
DispMenuTbl     label   word
                dw      offset DispMenuStringMsg
                dw      offset DispByteMsg
                dw      offset DispStringMsg
                dw      offset DispStringMsg
DispMenuStringMsg:
        mov     al,[si].mCurItem
        xor     ah,ah
        shl     ax,1
        add     si,ax
        mov     si,[si].mMenuMsg
        call    DispString
        ret
DispByteMsg:
        mov     si,[si].mFlagAddr
        mov     al,[si]
        or      al,al
        jnz     @f
        mov     si,offset DefaultMsg
        push    bx
        mov     bl,[NorAttr]
        xor     bh,bh
        mov     ah,2
        int     10h
        mov     cx,DefaultMsgLng
        mov     ah,9
        mov     al,' '
        int     10h
        pop     bx
        call    DispString
        ret
@@:
        mov     ah,al
        and     ax,0f00fh
        shr     ah,1
        shr     ah,1
        shr     ah,1
        shr     ah,1
        add     ax,'00'
        cmp     al,'9'
        jbe     @f
        add     al,7
@@:
        cmp     ah,'9'
        jbe     @f
        add     ah,7
@@:
        push    ax
        mov     al,ah
        mov     cx,1
        xor     bh,bh
        mov     ah,2
        int     10h
        mov     ah,9
        int     10h
        inc     dl
        mov     ah,2
        int     10h
        pop     ax
        mov     ah,9
        int     10h
        ret
DispStringMsg:
        xor     bh,bh
        mov     ah,2
        int     10h
        mov     cx,StringLng
        mov     ah,9
        mov     al,' '
        int     10h
        mov     si,[si].mFlagAddr
        call    DispString
        mov     ax,920h
        int     10h                     ; clear han 1st flag
        mov     dx,[CurPos]
        xor     bh,bh
        mov     ah,2
        int     10h
        ret

;------------------------
DispHelp:
        mov     si,[MenuPos]
        shl     si,1
        mov     si,[si+MainTbl]
        mov     si,[si].mHelpMsg
        mov     bl,[NorAttr]
        mov     dx,HelpPos
        call    DispString
        ret

;------------------------
RestoreScreen:
        mov     al,[OrgMode]
        xor     ah,ah
        int     10h
        ret

;------------------------
KbdMenu:
        mov     si,offset MenuSelect
        call    ParsingKey
        ret

;------------------------
KbdCode:
        mov     si,offset MakeCode
        call    ParsingKey
        ret

;------------------------
KbdString:
        mov     bh,al
        mov     si,offset MakeString
        call    ParsingKey
        jnc     @f
        mov     al,bh
        xor     ah,ah                   ; CLC
@@:
        ret

;------------------------
ParsingKey:
        mov     bl,ah
@@:
        lodsw
        cmp     ax,-1
        jz      @f
        cmp     al,bl
        jnz     @b
        ret
@@:
        stc
        ret

;------------------------
Beep:
        mov     ax,0e07h
        int     10h
        ret

;------------------------
CursorControl:
        push    dx
        xor     bh,bh
        mov     ah,3
        int     10h
        or      ch,20h
        cmp     [MenuPos],3-1
        jnz     @f
        and     ch,not 20h
        mov     si,[MenuPos]
        shl     si,1
        mov     si,[si+MainTbl]
        mov     dx,[si].mCurPos
        mov     [CurPos],dx
@@:
        mov     ah,1
        int     10h
        pop     dx
        ret

;------------------------
DispString:
        mov     cx,1
        xor     bh,bh
@@:
        mov     ah,2
        int     10h
        lodsb
        cmp     al,eom
        jz      @f
        mov     ah,9
        int     10h
        inc     dl
        jmp     short @b
@@:
        ret


CODE    ENDS
        END     Start

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\compose.inc ===
EXTRN   Ks2ChAddr : Word


GenFont PROC    Near
;
; Make Hangeul Font Pattern Completely.
;
;  INPUT :  DS = CS
;           CX = Hangeul Code
;           ES:DI = Buffer Pointer
;
;  OUTPUT : N-Carry
;           ES:DI = Buffer Pointer
;
;  USES :   ALL
;
        push    bp
        push    di

        mov     ax, cx
        mov     bp, di      ; Save Buffer Offset to BP
        test    [CodeStat], Chab
        jnz     @f
        call    [Ks2ChAddr]
        jnc     @f
        jmp     @gfEnd
@@:
        mov     di, bp
        mov     cx, 16
        mov     bx, ax      ; Save Hangeul Code to DX
        xor     ax, ax
        rep     stosw       ; Clear Image Buffer

        push    bp

        mov     cl, 5
        mov     ax, 00111110b
        shl     bx, 1
        mov     bp, bx
        and     bp, ax      ; BP <- JONG Code
        shr     bx, cl
        mov     di, bx
        and     di, ax      ; DI <- JUNG Code
        shr     bx, cl
        and     bx, ax      ; BX <- CHO Code

        pop     cx          ; CX <- Buffer Offset
        xor     dh, dh

        mov     si, _hfBaseCho[bx]
        cmp     si, -1
        je      @gfExit
        or      si, si
        jz      @f
        add     si, _hfCnvJungCho[di]
        add     si, ds:_hfCnvJongCho[bp]
        mov     si, [si]
        add     si, _hfBmpCho
        call    ORingImage
@@:
        mov     si, _hfBaseJung[di]
        cmp     si, -1
        je      @gfExit
        or      si, si
        jz      @f
        add     si, _hfCnvChoJung[bx]
        add     si, ds:_hfCnvJongJung[bp]
        mov     si, [si]
        add     si, _hfBmpJung
        call    ORingImage
@@:
        mov     si, ds:_hfBaseJong[bp]
        cmp     si, -1
        je      @gfExit
        or      si, si
        jz      @f
        add     si, _hfCnvChoJong[bx]
        add     si, _hfCnvJungJong[di]
        mov     si, [si]
        add     si, _hfBmpJong
        call    ORingImage
@@:
        clc
@gfEnd:
        pop     di
        pop     bp
        ret
@gfExit:
        stc
        jmp     SHORT @gfEnd

GenFont ENDP


ORingImage  PROC    Near
;
;  INPUT :  DS = CS
;           ES:CX = Buffer Pointer
;           SI = Image Pointer
;           DH = 0
;
;  Must Reserve DI register
;
        push    di
        mov     di, cx

        lodsw
        cmp     ax, -1
        je      @oriTerm

        mov     dl, al
        add     di, dx
        mov     dl, ah
@@:
          lodsw
          or      es:[di], ax
          add     di, 2
          dec     dl
        jnz     @b
@oriTerm:
        pop     di
        ret

ORingImage  ENDP


CharTbl LABEL   Word

        INCLUDE hf.inc


GenFontLng  =       $ - GenFont
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\dual.inc ===
;========================================================================
;
;               Hot Key Service Function
;
;========================================================================

ASSUME  CS:CODE, DS:CODE, ES:CODE

MainPos         =       0
Sub1Pos         =       112h
Sub2Pos         =       133h
MsgLength       =       16
eom             =       '$'

DataStr         STRUC
mCurValue       db      ?
mMaxValue       db      ?
mCurPos         dw      ?
mDataAddr       dw      ?
mMsgs           dw      ?
DataStr         ENDS

CurMenu         dw      0               ; current main menu
tCodeStat       db      0
tPrinter        db      0
NorAttr         db      70h
SelAttr         db      7
BakAttr         db      70h
OldCodeStat     db      0
BilingCall      db      0               ; [CHM001]

MainTbl         label   word
                dw      offset Menu1
                dw      offset Menu2
MainTblLng      =       ($-MainTbl)/2

Menu1           label   word
Menu1Cur        db      0
Menu1Max        db      Sub1DataLng-1
                dw      Sub1Pos
                dw      offset Sub1Data
                dw      offset Menu1Msg1
                dw      offset Menu1Msg2
                dw      offset Menu1Msg3
;                dw      offset Menu1Msg4
Sub1Data        label   byte
                db      0
                db      HangeulMode or WSung
                db      HangeulMode or Chab
;                db      HangeulMode or WSung7
Sub1DataLng     =       $-Sub1Data
Menu1Msg1       db      'English',eom
Menu1Msg2       db      'KS C 5842 - 1991',eom
Menu1Msg3       db      'Chohab',eom
;Menu1Msg4       db      'Wansung 7 bit',eom

Menu2           label   word
Menu2Cur        db      0
Menu2Max        db      Sub2DataLng-1
                dw      Sub2Pos
                dw      offset Sub2Data
                dw      offset Menu2Msg1
                dw      offset Menu2Msg2
;                dw      offset Menu2Msg3
                dw      offset Menu2Msg4
                dw      offset Menu2Msg5
                dw      offset Menu2Msg6
Sub2Data        label   byte
                db      NoPrt
                db      KsPrt
;                db      wLbp
                db      wKmPrt
                db      cKmPrt
                db      TgPrt
Sub2DataLng     =       $-Sub2Data
Menu2Msg1       db      'None selected',eom
Menu2Msg2       db      'KS',eom
;Menu2Msg3       db      'QLBP',eom
Menu2Msg4       db      'KSSM',eom
Menu2Msg5       db      'KSSM(Chohab)',eom
Menu2Msg6       db      'TG(Chohab)',eom

MainMenu        label   byte
        dw      0fh
        db      'Hangeul BIOS environment changing program',0
        dw      10bh
        db      'CODE :',0
        dw      129h
        db      'PRINTER :',0
        dw      215h
        db      'USAGE : Enter, Esc, Arrows',eom


;========================================================================
;   << EnvrChange >>
; FUNCTION =  Hot_ key function 
; INPUT   : none
; OUTPUT  : none
; PROTECT : all

EXTRN   PushKeyBuf:near
PUBLIC  EnvrChange
public  EscCode2Tbl, EscCode3Tbl, EscCodeNTbl, EscCode4Tbl
public  EscCode2Addr, EscCode3Addr, EscCodeNAddr, EscCode4Addr

dSaveCurrPage    db   0
dSaveCurPos      dw   0
dSaveCurType     dw   0

INCLUDE debug.inc
EnvrChange:
ASSUME  DS:DATA, ES:CODE
        @push   ax,bx,cx,dx,si,di,es,ds
        xor     bx,bx
        mov     ds,bx
        mov     bx,cs
        cmp     bx,word ptr [rKbioInt+2]
        jnz     EnvrChgRet
        mov     bx,cs
        mov     es,bx
        mov     ds,bx
ASSUME  DS:CODE
        mov     al,[CodeStat]
        mov     [OldCodeStat],al
if      AltHotKey
        test    [HotStat],AltHotChg
        jz      NotAltChg
        test    [CodeStat],(Chab or WSung7)
        jnz     EnvrChgRet
        and     [CodeStat],not (HangeulMode or Chab or WSung or WSung7)
        test    al,HangeulMode
        jnz     @f
        or      [CodeStat],(HangeulMode or WSung)
@@:
        call    AltHotChgProc
        jmp     EnvrChgRet
NotAltChg:
endif   ; if AltHotKey
        call    AdjustParms
        call    SaveScrn
        call    DispMain
        call    DispStatus
        call    MainLoop
        call    RestoreScrn
        jc      EnvrChgRet
        call    ChgEnvr
EnvrChgRet:
        @pop    ds,es,di,si,dx,cx,bx,ax
        ret

if      AltHotKey
AltHotChgProc:
        test    cs:[Card1st],HanCard
        jz      @f
        mov     ah,0fh
        int     10h
        cmp     al,2
        jz      AltHotChgText
        cmp     al,3
        jz      AltHotChgText
        test    cs:[Card1st],VgaCard
        jz      @f
        test    cs:[Card1st],DualMnt
        jnz     @f
        cmp     al,7
        jz      AltHotChgText
@@:
if      AtiVga
        mov     [PreModeV],al
endif   ;AtiVga
        call    ChgEnvrProc
        ret
AltHotChgText:
        call    SaveScrData
;if      KseVga
;        test    cs:[KseCard],00000001b
;        jz      @f
;        test    [CodeStat],HangeulMode
;        jnz     @f
;        CALL    SaveEngPat
;@@:
;endif   ; if KseVga
        push    es
        test    cs:[CodeStat],HangeulMode
        jnz     SetHanVideoI
        call    ChgParmH2E
        jmp     @f
SetHanVideoI:
        call    ChgParmE2H
@@:
        push    ax
        push    bx
        mov     ax,0
        mov     es,ax
ASSUME  ES:DATA
        mov     ah,0fh
        int     10h
        or      al, 80h
        mov     ah, 0
        int     10h
        JMP     SetParmKse
        cli
        push    ax
        mov     [ModeStat],0
        and     [KbStat],not HanKeyinMode
        and     [CodeStat],not HangeulVideoMode
        mov     [CurMode],al
        call    HanCardReset
        call    SearchMode
        jnc     @f
        pop     ax
        or      al, 080h
        pushf
        call    [OLDVIDEO]
if      KseVga
        test    cs:[KseCard],00000001b
        jz      SetParmKse
        ;or      al,080h
        ;PUSHF
        ;CALL    [OLDVIDEO]
;       CALL    LoadEngPat
        call    SetParmAlt
endif   ;   KseVga
        JMP     SetParmKse
@@:
        pop     ax
        or      [KbStat],HanKeyInMode
        or      [CodeStat],HangeulVideoMode
if      KseVga
        test    cs:[KseCard],00000001b
        jnz     ProContKA
endif   ; KseVga
if      AtiVga
        test    cs:[KseCard],00000001b
        jnz     @f
        call    LoadEngPattern
        mov     bx,ax
        cmp     al,[PreModeV]
        jnz     @f
        call    HanCardSet
        push    si
        call    GetParmTbl
        mov     dx,03cch
        in      al,dx
        mov     ah,al
        lodsb
        pop     si
        cmp     ah,al
        jnz     @f
        jmp     SetParmKse
@@:
        mov     [PreModeV],bl
        mov     ax,bx
endif   ;AtiVga
ProContKA:
        call    PreModeSet
        call    ClearGrpBuf
if      KseVga
        test    cs:[KseCard],00000001b
        jz      @f
        or      al,080h
        PUSHF
        CALL    [OLDVIDEO]
@@:
endif   ;   KseVga
        call    LoadEngPattern
        CALL    SettingVariables
        call    HanCardSet
        call    SetParmAlt
SetParmKse:
        pop     bx
        pop     ax
        pop     es
assume  es:code
        sti
        call    WritScrData
if      KseVga
        test    cs:[KseCard],00000001b
        jz      @f
        call    KseVEop
@@:
endif   ; if KseVga
        ret

SetParmAlt:
        call    GetParmTbl
        mov     dx,03c2h
        lodsb
        out     dx,al
        mov     dx,03c4h
        mov     ah,1
        lodsb
        xchg    ah,al
        out     dx,ax
        mov     dx,cx
        mov     cx,25
        mov     ax,0
        out     dx,ax
        xor     ah,ah
        call    OutParms
        add     dl,0ah-4
        in      al,dx
        in      al,dx
        mov     dx,03c0h
        mov     al,13h
        out     dx,al
        lodsb
        out     dx,al
        mov     al,03fh
        out     dx,al
if      KseVga
        test    cs:[KseCard],00000001b
        jz      @f
        jmp     SetParmVgaRet
@@:
endif   ;   KseVga
        mov     cx,02h
        mov     dx,01ceh
        mov     ah,0a8h
        call    OutParms
SetParmVgaRet:
        ret

GetParmTbl:
        push    bx
        mov     bx,0
        test    [CodeStat],HangeulMode
        jz      @f
        mov     bx,1
@@:
        push    es
        mov     ax,0
        mov     es,ax
        mov     cx,ES:[rAddr6845]
        pop     es
        test    cs:[KseCard],MonoMntC
        jz      @f
        or      bx,000000100b
        jmp     SetParmProc
@@:
        cmp     cx,3b4h
        jnz     SetParmProc
        or      bx,000000010b
SetParmProc:
        shl     bx,1
if      AtiVga
        mov     si,offset AttrTblAti
endif   ; AtiVga
if      KseVga
        test    cs:[KseCard],00000001b
        jz      @f
        mov     si,offset AttrTblKse
@@:
endif   ;   KseVga
        mov     si,[si+bx]
        pop     bx
        ret

OutParms:
        lodsb
        xchg    al,ah
        out     dx,ax
        xchg    al,ah
        inc     ah
        loop    OutParms
        ret

if      KseVga

KseEng2Vga  db 067h
         db 000h
         db 05Fh,04Fh,050h,082h,055h,081h,0BFh,01Fh,000h,04Fh,00Dh,00Eh,000h,000h,000h,000h
         db 09Ch,00Eh,08Fh,028h,01Fh,096h,0B9h,0A3h,0FFh
         db 008h

KseHan2Vga  db 063h
         db 001h
         db 061h,052h,053h,023h,057h,06Fh,0BFh,01Fh,000h,04Fh,00Dh,06Eh,000h,000h,000h,000h
         db 09Ch,00Eh,08Fh,028h,01Fh,096h,0B9h,0A3h,0FFh
         db 000h

KseEng7Vga  db 066h
         db 000h
         db 05Fh,04Fh,050h,082h,055h,081h,0BFh,01Fh,000h,04Fh,00Dh,00Eh,000h,000h,000h,000h
         db 09Ch,00Eh,08Fh,028h,00Fh,096h,0B9h,0A3h,0FFh
         db 008h

KseHan7Vga  db 062h
         db 001h
         db 061h,052h,053h,023h,057h,06Fh,0BFh,01Fh,000h,04Fh,00Dh,06Eh,000h,000h,000h,000h
         db 09Ch,00Eh,08Fh,028h,00Fh,096h,0B9h,0A3h,0FFh
         db 000h

KseEng7Mda  db 0A6h
         db 000h
         db 060h,04Fh,056h,03Ah,051h,060h,070h,01Fh,000h,00Dh,00Bh,00Dh,000h,000h,000h,000h
         db 05Eh,02Eh,05Dh,028h,00Dh,05Eh,00Eh,0A3h,0FFh
         db 008h

KseHan7Mda  db 0A6h
         db 001h
         db 05Fh,052h,055h,025h,053h,0E3h,0B0h,01Fh,000h,00Fh,00Eh,060h,000h,000h,000h,000h
         db 090h,020h,08Fh,028h,00Dh,090h,000h,0A3h,0FFh
         db 000h


AttrTblKse      label   byte
        dw      offset KseEng2Vga
        dw      offset KseHan2Vga
        dw      offset KseEng7Vga
        dw      offset KseHan7Vga
        dw      offset KseEng7Mda
        dw      offset KseHan7Mda
endif   ;   KseVga

if      AtiVga
PreModeV        DB      0

AtiEng2Vga  db 067h
         db 000h
         db 05Fh,04Fh,050h,082h,055h,081h,0BFh,01Fh,000h,04Fh,00Dh,00Eh,000h,000h,007h,080h
         db 09Ch,00Eh,08Fh,028h,01Fh,096h,0B9h,0A3h,0FFh
         db 008h
         db 001h,072h
;        db 048h,012h,000h,000h,054h,076h,004h,000h,001h,072h,005h,080h,000h,000h,000h,000h
;        db 010h,000h,000h,000h,000h,008h,000h,02Dh,040h,073h,000h,063h,000h,090h,010h,008h


AtiHan2Vga  db 063h
         db 001h
         db 05Fh,04Fh,050h,082h,054h,080h,0BFh,01Fh,000h,04Fh,00Dh,00Eh,000h,000h,007h,080h
         db 09Ch,00Eh,08Fh,028h,01Fh,096h,0B9h,0A3h,0FFh
         db 000h
         db 001h,0aeh
;        db 048h,012h,000h,000h,054h,076h,004h,000h,001h,0AEh,005h,080h,000h,000h,000h,000h
;        db 010h,000h,000h,000h,000h,008h,000h,02Dh,040h,073h,000h,063h,000h,090h,010h,028h

AtiEng7Vga  db 066h
         db 000h
         db 05Fh,04Fh,050h,082h,055h,081h,0BFh,01Fh,000h,04Fh,00Dh,00Eh,000h,000h,002h,030h
         db 09Ch,00Eh,08Fh,028h,00Fh,096h,0B9h,0A3h,0FFh
         db 008h
         db 01h,079h
;        db 048h,012h,000h,000h,054h,076h,004h,000h,001h,079h,005h,080h,000h,000h,000h,000h
;        db 010h,000h,000h,000h,000h,008h,000h,02Dh,040h,073h,000h,063h,000h,090h,010h,008h

AtiHan7Vga  db 062h
         db 001h
         db 05Fh,04Fh,050h,082h,054h,080h,0BFh,01Fh,000h,04Fh,00Dh,00Eh,000h,000h,007h,080h
         db 09Ch,00Eh,08Fh,028h,01Fh,096h,0B9h,0A3h,0FFh
         db 000h
         db 00h,0cdh
;        db 048h,012h,000h,000h,054h,076h,004h,000h,000h,0CDh,005h,080h,000h,000h,000h,000h
;        db 010h,000h,000h,000h,000h,008h,000h,025h,040h,073h,000h,063h,000h,090h,010h,028h

AtiEng7Mda  db 0A6h
         db 001h
         db 06Ch,04Fh,050h,02Bh,055h,067h,09Fh,01Fh,000h,00Fh,00Dh,00Fh,000h,000h,007h,080h
         db 000h,000h,08Fh,028h,00Fh,091h,015h,0A3h,0FFh
         db 000h
         db 00h,093h
;        db 058h,017h,000h,000h,054h,076h,004h,000h,000h,093h,005h,080h,000h,000h,000h,000h
;        db 010h,007h,000h,000h,002h,008h,0A2h,025h,086h,0F1h,00Fh,062h,000h,0D0h,015h,008h

AtiHan7Mda  db 0A6h
         db 001h
         db 06Ch,04Fh,050h,02Bh,055h,067h,09Fh,01Fh,000h,00Fh,00Dh,00Fh,000h,000h,007h,080h
         db 000h,000h,08Fh,028h,00Fh,091h,015h,0A3h,0FFh
         db 000h
         db 00h,0e6h
;        db 058h,017h,000h,000h,054h,076h,004h,000h,000h,0E6h,005h,080h,000h,000h,000h,000h
;        db 000h,007h,000h,000h,002h,008h,0A2h,025h,086h,0F1h,00Fh,042h,000h,0D0h,015h,008h

AttrTblAti      label   byte
        dw      offset AtiEng2Vga
        dw      offset AtiHan2Vga
        dw      offset AtiEng7Vga
        dw      offset AtiHan7Vga
        dw      offset AtiEng7Mda
        dw      offset AtiHan7Mda
endif   ;   AtiVga

SaveScrData:
        @push   ds,es,cx,di,si
        mov     ah,0fh
        int     10h
        push    ax
        mov     cs:[dSaveCurrPage],bh
        mov     ah,03h
        int     10h
        mov     cs:[dSaveCurType],cx
        mov     cs:[dSaveCurPos],dx
        mov     cx,0
        mov     es,cx
        mov     cx,es:[rCrtStart]
        les     di,[CodeBuf2Addr]
        lds     si,[CodeBuf1Addr]
        pop     ax
        mov     dx,0b000h
        cmp     al,07h
        jz      @f
        mov     dx,0b800h
@@:
        mov     ds,dx
        shr     cx,1
        shr     cx,1
        shr     cx,1
        shr     cx,1
        mov     dx,ds
        add     cx,dx
        mov     ds,cx
        mov     cx,25*80
        mov     ax,ds
        mov     bx,si
        rep movsw
        @pop    si,di,cx,es,ds
        ret

WritScrData:
        @push   es,ds
        lds     si,[CodeBuf2Addr]
        mov     es,ax
        mov     di,bx
        mov     cx,25*80
        rep movsw
        mov     bh,cs:[dSaveCurrPage]
        mov     dx,cs:[dSaveCurPos]
        mov     ah,02h
        int     10h
        mov     cx,cs:[dSaveCurType]
        mov     ah,01h
        int     10h
        @pop    ds,es
        ret
endif   ;   AltHotKey


;------------------------------------------------------------------------
;   << AdjustParms >>
; FUNCTION =  initialize menu value
; INPUT   : none
; OUTPUT  : none
; PROTECT : DS, ES, BP
AdjustParms:
        mov     [CurMenu],0
        mov     ah,[Printer]
        and     ah,00000111b
        mov     al,[CodeStat]
        and     al,HangeulMode or Chab or WSung or WSung7
        test    [CodeStat],ChabLoad
        jnz     @f
        mov     [Menu1Max],2-1
        mov     [Menu2Max],1-1
        and     al,HangeulMode or WSung
        mov     ah,NoPrt
@@:
        mov     [tPrinter],ah
        mov     [tCodeStat],al
        mov     si,offset Sub1Data
        mov     dx,si
        mov     cx,Sub1DataLng
@@:
        cmp     [si],al
        jz      @f
        inc     si
        loop    @b
        mov     si,dx                   ; initiale
@@:
        sub     si,dx
        mov     dx,si
        mov     [Menu1Cur],dl
        mov     al,[tPrinter]
        mov     si,offset Sub2Data
        mov     dx,si
        mov     cx,Sub2DataLng
@@:
        cmp     [si],al
        jz      @f
        inc     si
        loop    @b
        mov     si,dx                   ; initiale
@@:
        sub     si,dx
        mov     dx,si
        mov     [Menu2Cur],dl
        ret

;------------------------------------------------------------------------
;   << SaveScrn >>
; FUNCTION =  save menu screen
; INPUT   : none
; OUTPUT  : none
; PROTECT : DS, ES, BP
SaveScrn:
        mov     ah,0fh
        int     10h
        mov     [dSaveCurrPage],bh
        mov     [NorAttr],70h
        mov     [SelAttr],7
        mov     [BakAttr],70h
        cmp     al,3
        jbe     @f
        cmp     al,7
        jz      @f
        mov     [NorAttr],7
        mov     [SelAttr],0fh
        mov     [BakAttr],0
@@:
        mov     ah,3
        int     10h
        mov     [dSaveCurType],cx
        mov     [dSaveCurPos],dx
        mov     ah,1
        or      ch,20h
        int     10h
        xor     dx,dx
        mov     di,offset MenuBuffer
        mov     cx,80*3
SaveLp:
        mov     ah,2
        int     10h
        mov     ah,8
        int     10h
        stosw
        inc     dl
        cmp     dl,80
        jb      @f
        xor     dl,dl
        inc     dh
@@:
        loop    SaveLp
        ret


;------------------------------------------------------------------------
;   << DispMain >>
; FUNCTION =  Display main menu
; INPUT   : none
; OUTPUT  : none
; PROTECT : DS, ES, BP
DispMain:
        mov     bh,[BakAttr]
        xor     cx,cx
        mov     dx,024fh
        mov     ax,600h
        int     10h
        mov     bh,[dSaveCurrPage]
        mov     bl,[NorAttr]
        mov     si,offset MainMenu
        inc     cx
DispMainLp:
        lodsw
        mov     dx,ax
@@:
        mov     ah,2
        int     10h
        lodsb
        cmp     al,eom
        jz      @f
        cmp     al,0
        jz      DispMainLp
        mov     ah,9
        int     10h
        inc     dl
        jmp     short @b
@@:
        ret

;------------------------------------------------------------------------
;   << DispStatus >>
; FUNCTION =  display sub Menu
; INPUT   : none
; OUTPUT  : none
; PROTECT : DS, ES, BP
DispStatus:
        mov     cx,MainTblLng
@@:
        push    cx
        mov     bl,[NorAttr]
        call    DispMenu
        inc     [CurMenu]
        pop     cx
        loop    @b
        mov     [CurMenu],0
        mov     bl,[SelAttr]
        call    DispMenu
        ret

;------------------------------------------------------------------------
;   << MainLoop >>
; FUNCTION =  user interface
; INPUT   : none
; OUTPUT  : none
; PROTECT : DS, ES, BP
MainLoop:
        call    GetKey
        jc      MainLoopAbort
        xor     ah,ah
        shl     ax,1
        mov     si,ax
        call    [si].KeySrv
        jnc     MainLoop
        clc
MainLoopAbort:
        ret
KeySrv          label   word
                dw      offset MenuUp   ; up
                dw      offset MenuDown ; down
                dw      offset MenuLeft ; left
                dw      offset MenuRight; right
                dw      offset MenuSave ; enter

;--------------------------------
MenuUp:
        mov     bl,[NorAttr]
        call    DispMenu
        mov     si,[CurMenu]
        shl     si,1
        mov     si,[si].MainTbl
        mov     al,[si].mCurValue
        dec     al
        cmp     al,-1
        jnz     @f
        mov     al,[si].mMaxValue
@@:
        mov     [si].mCurValue,al
        mov     bl,[SelAttr]
        call    DispMenu
        clc
        ret

;--------------------------------
MenuDown:
        mov     bl,[NorAttr]
        call    DispMenu
        mov     si,[CurMenu]
        shl     si,1
        mov     si,[si].MainTbl
        mov     al,[si].mCurValue
        mov     ah,[si].mMaxValue
        inc     al
        cmp     al,ah
        jbe     @f
        mov     al,0
@@:
        mov     [si].mCurValue,al
        mov     bl,[SelAttr]
        call    DispMenu
        clc
        ret

;--------------------------------
MenuLeft:
        mov     bl,[NorAttr]
        call    DispMenu
        dec     [CurMenu]
        cmp     [CurMenu],-1
        jnz     @f
        mov     [CurMenu],MainTblLng-1
@@:
        mov     bl,[SelAttr]
        call    DispMenu
        clc
        ret

;--------------------------------
MenuRight:
        mov     bl,[NorAttr]
        call    DispMenu
        inc     [CurMenu]
        cmp     [CurMenu],MainTblLng
        jb      @f
        mov     [CurMenu],0
@@:
        mov     bl,[SelAttr]
        call    DispMenu
        clc
        ret

;--------------------------------
MenuSave:
        stc
        ret

;--------------------------------
DispMenu:
        mov     si,[CurMenu]
        shl     si,1
        mov     si,[si].MainTbl
        mov     dx,[si].mCurPos
        mov     al,[si].mCurValue
        xor     ah,ah
        shl     ax,1
        add     si,ax
        mov     si,[si].mMsgs
        mov     bh,[dSaveCurrPage]
        push    bx
        mov     ah,2
        int     10h
        mov     cx,MsgLength
        mov     ah,9
        mov     al,' '
        mov     bl,[NorAttr]
        int     10h
        pop     bx
        mov     cx,1
@@:
        mov     ah,2
        int     10h
        lodsb
        cmp     al,eom
        jz      @f
        inc     dl
        mov     ah,9
        int     10h
        jmp     short @b
@@:
        ret

;--------------------------------
GetKey:
        xor     ah,ah
        pushf
        call    [OldKbioInt]
        cmp     ah,1                    ; ESC key
        jz      GetKeyEnd
        mov     bl,ah
        mov     si,offset KeyTbl
        mov     cx,KeyTblLng
@@:
        lodsw
        cmp     al,bl
        jz      @f
        loop    @b
        mov     ax,0e07h
        int     10h
        jmp     short GetKey
@@:
        mov     al,ah
        ret
GetKeyEnd:
        stc
        ret

KeyTbl  label   byte
        db      48h,0                   ; up
        db      50h,1                   ; down
        db      4bh,2                   ; left
        db      4dh,3                   ; right
        db      1ch,4                   ; enter
KeyTblLng       =       ($-KeyTbl)/2

;------------------------------------------------------------------------
;   << ChgEnvr >>
; FUNCTION =  check status & environment change
; INPUT   : none
; OUTPUT  : carry(set = no change & exit)
; PROTECT : DS, ES, BP
ChgEnvr:
        test    [CodeStat],ChabLoad
        jz      @f
        mov     al,[Menu2Cur]
        xor     ah,ah
        mov     si,ax
        mov     al,[si].Sub2Data
        cmp     [tPrinter],al
        jz      @f
        mov     [Printer],al
        mov     [PrtAuto],0
        mov     [HanCnt],0
        xor     ah,ah
        mov     si,ax
        shl     si,1
        mov     ax,[si].EscCode2Tbl
        mov     [EscCode2Addr],ax
        mov     ax,[si].EscCode3Tbl
        mov     [EscCode3Addr],ax
        mov     ax,[si].EscCodeNTbl
        mov     [EscCodeNAddr],ax
        mov     ax,[si].EscCode4Tbl
        mov     [EscCode4Addr],ax
@@:
        mov     al,[Menu1Cur]
        xor     ah,ah
        mov     si,ax
        mov     al,[si].Sub1Data
        cmp     [tCodeStat],al
        jz      ChgEnvrEnd
        and     [CodeStat],not (HangeulMode or Chab or WSung or WSung7)
        or      [CodeStat],al
ChgEnvrProc:
if      not ComFile
        push    bx
        mov     bx,437
        test    [CodeStat],HangeulMode
        jz      @f
        mov     bx,1361
        test    [CodeStat],Chab
        jnz     @f
        mov     bx,949
@@:
        mov     ax,6602h
        int     21h
        pop     bx
endif   ;  not ComFile
        mov     ah,0fh
        int     10h
        call    ChgEnvrDo
        mov     ah,0f3h
        int     16h
        mov     ah,0f3h
        int     16h

if 0
;       mov     ah,0fh          ; [CHM001]
;       int     10h             ; [CHM001]
;       call    ChgEnvrDo       ; [CHM001]

        mov     ax, 6602h               ; [CHM001]
        mov     bx, 437                 ; [CHM001]
        test    [CodeStat], HangeulMode ; [CHM001]
        jz      ChangeCodePage          ; [CHM001]
        mov     bx, 1361                ; [CHM001]
        test    [CodeStat], Chab        ; [CHM001]
        jnz     ChangeCodePage          ; [CHM001]
;        test    [CodeStat], Wsung7      ; [CHM001]
;        jnz     ChangeCodePage          ; [CHM001]
        mov     bx, 949                 ; [CHM001]
ChangeCodePage:                         ; [CHM001]
        mov     [BilingCall], 0ffh      ; [CHM001]
        int     21h                     ; [CHM001]

        mov     ah,0f3h
        int     16h
        mov     ah,0f3h
        int     16h
;@@:
;        mov     ah,1
;        int     16h
;        jz      @f
;        mov     ah,0
;        int     16h
;        jmp     short @b
;@@:
endif

        test    [KbStat],ReqEnvrChg
        jnz     ChgEnvrEnd
        push    ds
ASSUME  DS:KbSeg
        mov     ax,SEG KbSeg
        mov     ds,ax
        mov     ax,1c0dh
        mov     bx,[rBufferTail]
        call    PushKeyBuf
        pop     ds
ASSUME  DS:CODE
ChgEnvrEnd:
        ret


;------------------------------------------------------------------------
;   << ChgEnvrDo >>
; FUNCTION =  mode set with given mode & status
; INPUT   : AL = mode value
; OUTPUT  : none
; PROTECT : DS, ES, BP
ChgEnvrDo:
        push    ax
        test    cs:[Card1st],VgaCard
        jnz     @f
        test    cs:[CodeStat],HangeulMode
        jnz     SetHanEnvr
        call    ChgParmH2E
        jmp     @f
SetHanEnvr:
        call    ChgParmE2H
@@:
        test    [CodeStat],ChabLoad
        jz      ChgEnvrContin
;        push    ds
;        mov     ax,6300h
;        int     21h
;        cmp     byte ptr [si+1],0feh
;        jnz     @f
;        mov     byte ptr [si],0a1h
;        test    cs:[CodeStat],CHab
;        jz      @f
;        mov     byte ptr [si],084h
;@@:
;        pop     ds
        mov     [PrtAuto],0
        mov     [HanCnt],0
        xor     ah,ah
        mov     si,ax
        shl     si,1
        mov     ax,[si].EscCode2Tbl
        mov     [EscCode2Addr],ax
        mov     ax,[si].EscCode3Tbl
        mov     [EscCode3Addr],ax
        mov     ax,[si].EscCodeNTbl
        mov     [EscCodeNAddr],ax
        mov     ax,[si].EscCode4Tbl
        mov     [EscCode4Addr],ax
ChgEnvrContin:
        pop     ax
        and     al,01111111b
        test    [CodeStat],HangeulMode
        jnz     EnvrValidMode
        cmp     al,40h
        jz      @f
        cmp     al,60h
        jz      @f
        cmp     al,70h
        jnz     EnvrValidMode
@@:
        and     [KbStat],not ReqEnvrChg
        int     11h
        cmp     al,00110000b
        mov     al,7
        jpe     EnvrValidMode
        mov     al,3
EnvrValidMode:
        cmp     al,3
        jbe     @f
        cmp     al,7
        jz      @f
        and     [KbStat],not ReqEnvrChg
@@:
        push    ax
        mov     al,[CodeStat]
        xchg    al,[OldCodeStat]
        mov     [CodeStat],al
        call    SaveCodeBuffer
        mov     dx,3bfh
        mov     al,3
        out     dx,al
        mov     dl,0b8h
        mov     al,28h
        out     dx,al
        xor     al,al
        mov     dl,0bfh
        out     dx,al
        mov     al,[OldCodeStat]
        mov     [CodeStat],al
        test    [Card1st],DualMnt
        jz      ModeSet1st
        push    ds
        xor     ax,ax
        mov     ds,ax
ASSUME  DS:DATA
        mov     bl,byte ptr [rEquip]
        mov     ax,7
        or      byte ptr [rEquip],00110000b
        test    cs:[Card2nd],ColorMnt
        jz      @f
        mov     al,3
        and     byte ptr [rEquip],11101111b
@@:
        int     10h
        mov     byte ptr [rEquip],bl
        pop     ds
ASSUME  DS:CODE
ModeSet1st:
        pop     ax
if      WINNT
        call    RestoreCodeBuffer
        ret
else
        xor     ah,ah
if      AltHotKey and AtiVga
        mov     [PreModeV],ah
endif   ;  AltHotKey and AtiVga
        int     10h
        call    RestoreCodeBuffer
        ret
endif

;--------------------------------
SaveCodeBuffer:
        test    [KbStat],ReqEnvrChg
        jz      SaveCodeBufferEnd
        mov     ah,0fh
        int     10h                     ; get page #
        mov     [dSaveCurrPage],bh
        mov     ah,3
        int     10h                     ; get cursor position
        mov     [dSaveCurPos],dx
        mov     [dSaveCurType],cx        ; save cursor type
        or      ch,20h                  ; disable cursor
        mov     ah,1
        int     10h
        xor     dx,dx
        mov     di,word ptr [CodeBuf2Addr]
@@:
        mov     ah,2
        int     10h
        mov     ah,8
        int     10h
        stosw
        inc     dl
        cmp     dl,80
        jb      @b
        xor     dl,dl
        inc     dh
        cmp     dh,25
        jb      @b
        jmp     short ChgEnvrRestore
SaveCodeBufferEnd:
        ret

;--------------------------------
RestoreCodeBuffer:
        test    [KbStat],ReqEnvrChg
        jz      RestoreCodeBufferEnd
        mov     al,[dSaveCurrPage]
        mov     ah,5
        int     10h
        mov     bh,[dSaveCurrPage]
        mov     ah,3
        int     10h                     ; get cursor position
;       mov     [dSaveCurType],cx        ; save cursor type
        or      ch,20h                  ; disable cursor
        mov     ah,1
        int     10h
        xor     dx,dx
        mov     cx,1
        mov     si,word ptr [CodeBuf2Addr]
@@:
        mov     ah,2
        int     10h
        lodsw
        mov     bl,ah
        mov     ah,9
        int     10h
        inc     dl
        cmp     dl,80
        jb      @b
        xor     dl,dl
        inc     dh
        cmp     dh,25
        jb      @b
ChgEnvrRestore:
        mov     bh,[dSaveCurrPage]
        mov     cx,[dSaveCurType]        ; restore cursor type
        mov     ah,1
        int     10h
        mov     dx,[dSaveCurPos]         ; restore cursor position
        mov     ah,2
        int     10h
RestoreCodeBufferEnd:
        ret

;------------------------------------------------------------------------
;   << RestoreScrn >>
; FUNCTION =  restore menu screen
; INPUT   : none
; OUTPUT  : none
; PROTECT : DS, ES, BP, FLAG
RestoreScrn:
        pushf
        mov     bh,[dSaveCurrPage]
        mov     dx,MainPos
        mov     si,offset MenuBuffer
        mov     cx,80*3
RestoreLp:
        mov     ah,2
        int     10h
        push    cx
        lodsw
        mov     cx,1
        mov     bl,ah
        mov     ah,9
        int     10h
        pop     cx
        inc     dl
        cmp     dl,80
        jb      @f
        xor     dl,dl
        inc     dh
@@:
        loop    RestoreLp
        mov     dx,[dSaveCurPos]
        mov     ah,2
        int     10h
        mov     cx,[dSaveCurType]
        mov     ah,1
        int     10h
        popf
        ret


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\debug.asm ===
code    SEGMENT Public byte 'CODE'
        ASSUME  Cs:code, Ds:code


buffer  DB      6 DUP (?)


_DebugChar      PROC    Near
;
; AL < Character To Be Shown
;
        push    ax
        push    dx
        mov     ah, 1
        mov     dx, 0
        int     14h
        pop     dx
        pop     ax
        ret
_DebugChar      ENDP

_DebugString    PROC    Near
;
; BX < Offset of String To Be Shown (Null Terminate)
;
        push    ax
        push    bx
        push    ds
        mov     ax, cs
        mov     ds, ax
@@:
        mov     al, [bx]
        inc     bx
        or      al, al
        jz      @f
        call    _DebugChar
        jmp     @b
@@:
        pop     ds
        pop     bx
        pop     ax
        ret
_DebugString    ENDP

NumHex  PROC    Near
;
; AL(0..3) < Hex Value
; AL > ASCII Code
;
        and     al, 0Fh
        cmp     al, 0Ah
        jb      @f
        add     al, 'A'-'0'-10
@@:
        add     al, '0'
        ret
NumHex  ENDP

NumByte PROC    Near
;
; AL < Byte Value
; AX > Two ASCII Codes for Byte Value
;
        push    dx
        mov     dl, al
        call    NumHex
        mov     dh, al
        mov     al, dl
        shr     al, 1
        shr     al, 1
        shr     al, 1
        shr     al, 1
        call    NumHex
        mov     dl, al
        mov     ax, dx
        pop     dx
        ret
NumByte ENDP

_DebugNumber    PROC    Near
;
; AX < Word Value To Be Shown
;
        push    ax
        push    bx
        push    dx
        push    bp
        push    ds
        mov     bx, cs
        mov     ds, bx

        lea     bx, buffer
        mov     Byte Ptr [bx], 32
        mov     dx, ax
        mov     al, dh
        call    NumByte
        mov     [bx+1], ax
        mov     al, dl
        call    NumByte
        mov     [bx+3], ax
        lea     bx, buffer
        call    _DebugString

        pop     ds
        pop     bp
        pop     dx
        pop     bx
        pop     ax
        ret
_DebugNumber    ENDP


        PUBLIC  _DebugChar, _DebugString, _DebugNumber

code    ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\equ.inc ===
.xlist
;========================================================================;
;                                                                        ;
;                        GLOBAL EQUATION                                 ;
;                                                                        ;
;========================================================================;

if WINNT
Version         equ     '5.0'
else
Version         equ     '1.20a.'
endif

false           =       0
true            =       not false
hWin31Sw        =       true
GetSwitch       =       true
Kbd101On        =       true
ChkW32Trident   =       true            ; card check(true), switch(false)

HotKey          =       true            ; support(true)
AltHotKey       =       true            ; support(true)
VirtualKey      =       false           ; 84 kbd

KseVga          =       true
AtiVga          =       true

if1
%OUT    *****************************************************************
if      Debug
%OUT    DEBUGGING mode
endif
if      ComFile
%OUT    .COM file type
else
%OUT    .SYS file type
endif
if      HotKey
%OUT    Hot_key support
endif
%OUT    *****************************************************************
endif


;------------------------------------------------------------------------
DATA            SEGMENT AT      0
                ORG     8*4
rRtcInt         dd      ?               ; INT 8
                ORG     9*4
rKbInt          dd      ?               ; INT 9
                ORG     10h*4
rVideoInt       dd      ?               ; INT 10
                ORG     15h*4
rCasetInt       dd      ?               ; INT 15
                ORG     16h*4
rKbioInt        dd      ?               ; INT 16
                ORG     17h*4
rPrinter        dd      ?               ; INT 17
                ORG     1dh*4
rVdParm         dd      ?               ; INT 1D
                ORG     2fh*4
rInt2f          dd      ?               ; INT 2F
                ORG     410h
rEquip          db      ?
                ORG     449h
rCrtMode        db      ?               ; current CRT mode
rCrtCols        dw      ?               ; number of columns on screen
rCrtLen         dw      ?               ; length of regen in bytes
rCrtStart       dw      ?               ; starting address in regen buffer
rCurPos         dw      8 dup (?)       ; cursor for each of up to 8 pages
rCurType        dw      ?               ; current cursor mode setting
rCurPage        db      ?               ; current page being displayed
rAddr6845       dw      ?               ; base address for active display card
rCrtModeSet     db      ?               ; current setting of the 3x8 register
rCrtPallette    db      ?               ; current pallette setting color card
                ORG     46ch
rTimerLow       dw      ?               ; low word of timer count
rTimerHigh      dw      ?               ; high word of timer count
rTimerOverflow  db      ?               ; timer has rolled over since last read
                ORG     484h
rRows           db      ?               ; rows on the active screen (less 1)
rPoints         dw      ?               ; bytes per character
rInfo           db      ?               ; mode options
rInfo3          db      ?               ; feature bit switches
rMiscFlags      db      ?               ; miscellaneous flags
rDCC            db      ?               ; display config comb code table index
                ORG     4a8h
rSavePtr        dd      ?               ; pointer to E/VGA parms control block
DATA            ENDS

KbSeg           SEGMENT AT      40h
                ORG     17h
rKbFlag         db      ?
rKbFlag1        db      ?
rAltInput       db      ?               ; storage for alternate keypad entry
rBufferHead     dw      ?               ; pointer to head of keyboard buffer
rBufferTail     dw      ?               ; pointer to tail of keyboard buffer
rKbBuffer       dw      16 dup (?)
                ORG     80h            ; buffer location within segment 40H
rBufferStart    dw      ?               ; offset of keyboard buffer start
rBufferEnd      dw      ?               ; offset of keyboard buffer end
                ORG     96h
rKbFlag3        db      ?               ; keyboard mode state and type flags
rKbFlag2        db      ?               ; keyboard LED flags
KbSeg           ENDS


;------------------------------------------------------------------------
@PUSH           MACRO   a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12
                IRP     REGISTER,<a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12>
                        IFB     <REGISTER>
                                ;;if REGISTER is blank do nothing.
                        ELSE
                                PUSH    REGISTER
                        ENDIF
                ENDM
                ENDM
@POP            MACRO   a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12
                IRP     REGISTER,<a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12>
                        IFB     <REGISTER>
                                ;;if REGISTER is blank do nothing.
                        ELSE
                                POP     REGISTER
                        ENDIF
                ENDM
                ENDM

BOP             MACRO   func

        db      0c4h,0c4h,func
;       jmp     cs:[pass_disp_add]
;       int     44h
                ENDM


;------------------------------------------------------------------------
Config          STRUC                   ; total 50 byte
sConfigId       db      'HECON.CFG'     ; 9 byte
sCodeType       db      ?
sFont           db      32 dup(?)       ; drive/path/filename
sMemory         db      ?               ; real/EMS/ext./HIMEM
sHeKey          db      ?
sHjKey          db      ?
sPrinterType    db      ?
sKbdType        db      ?
                db      3 dup(?)        ; reserved
Config          ENDS

UserCard        STRUC
uHanOn          dw      ?
uHanOff         dw      ?
uGetFont        dw      ?
uPutFont        dw      ?
uModeset        dw      ?
uEop            dw      ?
uInit           dw      ?
UserCard        ENDS

CrtParm         STRUC                   ; video parms structure
                db      2 dup(?)
cPoints         db      ?
                db      6 dup(?)
cMisc           db      ?
cCrtc           db      25 dup(?)
cAttr           db      20 dup(?)
cGrp            db      6 dup(?)
cMap            db      ?
                db      2 dup(?)
CrtParm         ENDS

ModeParms       STRUC
sMode           db      ?               ; input mode(modified if eng-card/text)
sModeId         db      ?               ; mode ID for application
sRealMode       db      ?               ; used for mode set really
sCodeVram       db      ?               ; code buffer address
sGrpVram        db      ?               ; grp video byte address
sCodeSize       db      ?               ; code buffer size
sGrpSize        db      ?               ; grp video byte size
sStatus         db      ?               ; mode status byte
sRows           db      ?               ; rows
sAdjParms       dw      ?               ; adjust video mode parms pointer
sParms          dw      ?               ; video mode parms pointer
sCurType        dw      ?               ; cursor type
ModeParms       ENDS

UdcHeader       STRUC
UdcMapTblPtr    dw      ?
UdcMapTblSize   dw      ?
UdcIndexTblPtr  dw      ?
UdcIndexTblSize dw      ?
UdcSetTblPtr    dw      ?
UdcSetTblSize   dw      ?
UdcPatPtr       dw      ?
UdcPatSize      dw      ?
UdcFileId       db      8 dup (?)
UdcUpdateDate   db      8 dup (?)
UdcReserved     db      16 dup (?)
UdcHeader       ENDS

GdtTbl          STRUC
                db      16 dup(?)
GdtCntS         dw      ?
GdtSL           dw      ?
GdtSH           db      ?
                db      ?
                db      2 dup(?)
GdtCntD         dw      ?
GdtDL           dw      ?
GdtDH           db      ?
                db      ?
                db      18 dup(?)
GdtTbl          ENDS

VDM_INFO_TBL    STRUC
packet_len              dw      30
video_buffer            dd      0
dmode_add               dd      0
windowed_add            dd      0
nt_cons_add             dd      0
disp_sys_init           dd      0
fullsc_resume_ptr       dd      0
ias_setmode_add         dd      0
VDM_INFO_TBL    ENDS

;------------------------------------------------------------------------
GrpIndex        =       3ceh
MiscReg         =       3c2h
AttrReg         =       3c0h
SeqIndex        =       3c4h


;------------------------------------------------------------------------
; stack pointer
rBX             =       2*7
rCX             =       2*6
rDX             =       2*5
rSI             =       2*4
rDI             =       2*3
rES             =       2*2
rDS             =       2*1
rBP             =       2*0

StringLng       =       32              ; size of 'HECON.CFG' file
EnvrParmPtr     =       2ch

; << ModeStat >>
TextEmulation   =       10000000b       ; fixed
ColorMode       =       01000000b       ; fixed
GrpMode         =       00100000b       ; fixed
MultiPage       =       00001000b       ; fixed
EmuCursor       =       00000100b       ; fixed
HwScroll        =       00000001b       ; fixed

; << CodeStat >>
InstPatGen      =       10000000b       ; installed PatGen
HangeulMode     =       01000000b       ;   
ChabLoad        =       00100000b       ; request to chohab service
WSung7          =       00000100b       ; fixed
Chab            =       00000010b       ; fixed
WSung           =       00000000b       ; fixed
HangeulVideoMode=       00000001b       ;  display mode

; << DisplayStat >>
RunEsc          =       00000001b

; << HanStat >>                         ; reserved flag
Han1st          =       00000001b       ; fixed

; << KbStat >>
UserDefineKey   =       10000000b
ReqEnvrChg      =       01000000b       ; request hot-key processing
HanKeyinMode    =       00100000b       ; hangeul displayable video mode
Ext10xKey       =       00010000b       ; fixed
HEStat          =       00000100b       ; fixed
JJStat          =       00000001b       ; fixed

; <<HotStat>>
AltHotChg       =       00000001b

; << HjStat >> << OrgHjStat >>
UdcLoaded       =       10000000b
UdcArea         =       01000000b
HjLoaded        =       00100000b
HjModeEnable    =       00000001b       ; fixed

; << HjMenuStat >>                      ; reserved flag
HjMenuMode      =       00000001b       ; fixed

; << MachineType >>
AtMachine       =       00000001b

; << Card1st >> , << Card2nd >>
FontCard        =       10000000b
HanCard         =       01000000b
ColorMnt        =       00100000b       ; color monitor(1), mono monitor(0)
DualMnt         =       00010000b
CardType        =       00001110b       ; fixed, card mask
VgaCard         =       00001010b       ; fixed
McgaCard        =       00001000b       ; fixed
EgaCardC        =       00000110b       ; fixed
EgaCardM        =       00000100b       ; fixed
CgaCard         =       00000010b       ; fixed
MgaCard         =       00000000b       ; fixed

; << MemStat >>
RealMem         =       10000000b
ExtMem          =       01000000b
EmsMem          =       00100000b
HiMem           =       00010000b

; << ErrStat >>
UdcLoadErr      =       10000000b
FontLoadErr     =       01000000b
MemoryErr       =       00100000b
FileErr         =       00010000b

; << Printer >>
NoPrt           =       00000011b       ; WanSung printer
KsPrt           =       00000000b       ; WanSung printer
wLbp            =       00000001b       ; WanSung printer
wKmPrt          =       00000010b       ; WanSung printer
cKmPrt          =       00000110b       ; ChoHab printer
TgPrt           =       00000111b       ; ChoHab printer
ChPrinter       =       00000100b

; << KbMisc >>
InterimCtrlDisp =       00000001b
HaveInterim     =       00000010b
SavedInterim    =       00000100b
RunningHot      =       00001000b

; << KseCard >>
MonoMntC        =       00000010b
PassHanCdCheck  =       00000100b
Page1Fix        =       00001000b

; << KbdType >>
SetKbd101       =       00000001b

;------------------------------------------------------------------------
EscKey          =       1bh
CR              =       0Dh
LF              =       0Ah
BS              =       08h
BELL            =       07h
DelKey          =       53h

DefXtKsHeKey    =       0f0h
DefAtKsHeKey    =       0f2h
DefKsHjKey      =       0f1h
Def101HeKey     =       38h
Def101HjKey     =       1dh
DefAtHeKey      =       6eh
DefAtHjKey      =       62h
DefXtHeKey      =       57h
DefXtHjKey      =       56h

;------------------------------------------------------------------------
.list

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\data.inc ===
;========================================================================;
;                                                                        ;
;                        GLOBAL DATA                                     ;
;                                                                        ;
;========================================================================;
;
;    BIOS     interface 
;   .
;

public  KbStat, Card1st, Card2nd, HeKey, HjKey, HjStat, DisplayStat, KseCard
public  ModeStat, MemStat, Printer, CodeStat, HanStat, HjMenuStat, ErrStat
public  MachineType, ModeId, WinOffset, WinSegment, KbMisc, VideoActive
public  iVersion, HotStat, KbdType, HanSavePtr

public  HjMenuLine, UdcTblPtr, CodeBuf2Addr, EndSegment, EndOffset
public  EmsHandle, MaxMemSize, EmsSeg, CurEmsPage, CodeBufSize, MemSize

public  OldVdParms, OldSavePtr, OldKbInt, OldVideo, OldRtcInt, OldKbInt
public  OldInt17, OldInt15, OldKbioInt

public  PatGenAddr, HanPatternPtr, Ks2ChAddr
public  HanAddr, HanAddrH, UdcAddr, UdcAddrH
public  HanOn1st, HanOff1st, HanOn2nd, HanOff2nd
public  GetHan1st, GetUdc1st, PutUdc1st, GetHan2nd, GetUdc2nd, PutUdc2nd

public  CompleteCharCnt, CompleteCharBuf, InterimCharCnt
public  InterimCharBuf, Auto, TmpKbdType
public  InterimCurPage,InterimMaxCols,InterimCurPos
public  SavedChar1,SavedChar2
public  MenuPtr, CurrMenuCnt, SaveCurrPage, CrtMaxCols
public  SaveCurPos, SaveCurType, prebufptr
public  DispIChar1, DispIChar2, InterimDispP
public  PreInCode, CurInCode, TmpBuf, PreTmpBuf, KsKbBuf, TmpBufCnt
if      WINNT
public  ActiveCodePage
endif

IF  Hwin31Sw
        PUBLIC  OldInt2f
ENDIF ;Hwin31Sw

;************************************
StartInst:
;------------------------------------------------------------------------
;   public data area   
PublicData      label   word            ; INT 10 entry FD
CodeBuf1Addr    label   dword
                dw      0
                dw      0
HanStat         db      0               ; indicate whether HanGeul 1st byte have
HjMenuStat      db      0               ; progress HanJa menu or ChgEnvr
                db      08 dup(0)       ; reserved
                db      'H'
                db      'B'
                dw      offset WinData

WinData         db      'WINDOWS'
WinOffset       dw      offset WinEnvrChange
WinSegment      dw      0               ; code segment address
                db      LocalDataLng
CodeStat        db      HangeulMode     ; code/spec status
KbStat          db      0               ; general KBD status
HjMenuLine      db      0               ; hanja menu display line #
LocalDataLng    =       $-CodeStat

CodeBufSize     dw      ?               ; 80*25*2, 80*30*2 ,Init 

iVersion        db      Version         ; 5 byte

;------------------------------------------------------------------------
ModeId          db      0
UdcTblPtr       dw      0               ; UDC table address(real memory)
CodeBuf2Addr    dd      0               ; 2nd code buffer segment:offset address
VideoActive     db      80h             ;  service routine  
ModeStat        db      0               ; video mode status
DisplayStat     db      0               ; Han1st, RunEsc
PatGenAddr      dw      0               ; pattern generator
HanPatternPtr   dw      0               ; pattern generator
Ks2ChAddr       dw      0               ; code conversion(KS -> CH)
KbMisc          db      InterimCtrlDisp
HotStat         db      0
Port3bf         db      0               ; for KSE VGA card
KseCard         db      0
KbdType         db      0

HjStat          db      0               ; hanja, UDC font status
OrgHjStat       db      0               ; original hanja, UDC font status

;  -------------kb.asm DATA -------------
CompleteCharCnt dw      0
CompleteCharBuf dw      16 dup(0)
InterimCharCnt  dw      0
InterimCharBuf  dw      2 dup(0)
Auto            db      0

TmpKbdType      db      0

InterimCurPage  db      0
InterimMaxCols  db      0
InterimCurPos   dw      0
SavedChar1      db      0
SavedChar2      db      0

MenuPtr         db      0
CurrMenuCnt     db      0
SaveCurrPage    db      0
CrtMaxCols      db      0
SaveCurPos      dw      0
SaveCurType     dw      0
prebufptr       dw      0

; interim display
DispIChar1      DB      0
DispIChar2      DB      0
InterimDispP    dw      0

;automata
PreInCode       dw      0
CurInCode       dw      0
TmpBuf          dw      0
PreTmpBuf       dw      0
KsKbBuf         dw      0
TmpBufCnt       db      0

; ------------- video.asm DATA -------------
; Display buffer 
GrpBufAddr      dd      ?       ; grp buffer pointer

; Cursor position  pointer 
TextPos1Addr    dw      ?       ; cursor buffer address
TextPos2Addr    dw      ?       ; cursor buffer address
GrpPosAddr      dw      ?       ; cursor buffer address

OldTextPos1Addr dw      ?       ; Han1st/RunEsc 
OldTextPos2Addr dw      ?       ; Han1st/RunEsc 
OldGrpPosAddr   dw      ?       ; Han1st/RunEsc 
OldChar         db      ?
OldAttr         db      ?
OldPage         db      ?
OldCurPos       dw      ?
OldCounter      dw      ?
OldHanStat      db      0

EscIndex        dw      0
CursorStat      db      0

MaxRows         db      ?
MaxPage         db      ?

CurPos          dw      ?               ; real position, be seted by char write
CurMode         db      ?
CurPage         db      ?               ; function AH = 5

OrgCurPos       dw      ?               ; cursor display position for delete
OrgCurType      dw      ?               ; cursor display type for delete

TimerTick       db      0
ScrUpDnFlag     db      0               ; screen up data
BlockAdj        dw      0               ; block move,copy data
HanSavePtr      dd      7 dup(0)

if              WINNT
WanSungCP       =       949             ; For NT 5.0
ActiveCodePage  dw      WanSungCP
endif

;------------------------------------------------------------------------
OldVdParms      dd      0               ; MGA/CGA video parm pointer
OldSavePtr      dd      0               ; EGA/VGA parms pointer
SizeInst        equ     ($ - StartInst)
;************************************

OldKbInt        dd      0               ; INT 9
OldKbioInt      dd      0               ; INT 16
OldRtcInt       dd      0               ; Int 8
OldVideo        dd      0               ; INT 10
OldInt15        dd      0               ; INT 15 or HIMEM address
OldInt17        dd      0               ; printer interrupt vector address
IF  Hwin31Sw
OldInt2f        dd      0               ; codechg dos int
ENDIF ;Hwin31Sw
;
EndSegment      dw      0               ;  BIOS   segment
EndOffset       dw      0               ;  BIOS   offset
;
MemStat         db      0               ; memory 
MemSize         dw      0
EmsSeg          dw      0
EmsHandle       dw      0
CurEmsPage      dw      0
MaxMemSize      dw      0
HanAddr         dw      0
HanAddrH        db      0
UdcAddr         dw      0
UdcAddrH        db      0
;
Card1st         db      0               ; active video card status
Card2nd         db      0               ; inactive video card status
HeKey           db      0               ;     key
HjKey           db      0               ;     key
Printer         db      0               ; printer type
ErrStat         db      0               ; initialize 

;------------------------------------------------------------------------
GetHan1st       dw      0
GetUdc1st       dw      0
PutUdc1st       dw      0
HanOn1st        dw      0
HanOff1st       dw      0
GetHan2nd       dw      0
GetUdc2nd       dw      0
PutUdc2nd       dw      0
HanOn2nd        dw      0
HanOff2nd       dw      0

MachineType     db      0               ; machine type(AT/XT)

;------------------------------------------------------------------------
public          vdm_info
vdm_info        VDM_INFO_TBL<>


if      Debug
public  DebugData
DebugData       dw      0
endif   ; if Debug

WinEnvrChange:
        @push   ax, bx, cx, dx, di, si, es, ds, bp
        mov     ax,cs
        mov     es,ax
        mov     ds,ax
        mov     al,[CodeStat]
        mov     [OldCodeStat],al
        mov     ah,0fh
        int     10h
        call    ChgEnvrDo
        @pop    bp, ds, es, si, di, dx, cx, bx, ax
WinEnvr PROC    far
        ret
WinEnvr ENDP


;------------------------------------------------------------------------
;   initialize  
public  TotalMenuCnt,MenuBuffer, MenuLineBuf, PatternBuf
PatternBuf      db      32 dup(0)
TotalMenuCnt    db      0
MenuBuffer      label   byte            ; hanja set buffer
MenuLineBuf     =       MenuBuffer+376+1; hanja menu buffer
;
; Install:
;       LoadUdc(-/-);
;       InstallFontFileReal(-/-);
;       InitMode(-/-);
;       DispSignonMsg(-/-);
;       [OrgHjStat] = [HjStat];
;       CX = [EndSegment];
;       DX = [EndOffset];
;       [VideoActive] = 0;
;       Restore BP, DI, SI, ES, DS;
;
public  Install, InitEnd
Install:
        call    LoadUdc
if      ComFile
        mov     sp,offset TmpStack
endif   ; if ComFile
        call    InstallFontFileReal
        mov     al,[HjStat]
        test    al,HjLoaded
        jz      @f
        or      [HjStat],HjModeEnable
@@:
        mov     [OrgHjStat],al
        call    InitMode
        call    DispSignonMsg
        mov     cx,[EndSegment]
        mov     dx,[EndOffset]
        mov     [VideoActive],0
InitEnd:
if      ComFile
        mov     ah,49h
        mov     es,ds:[EnvrParmPtr]
        int     21h
        mov     ax,cs
        sub     cx,ax
        add     dx,15
        shr     dx,1
        shr     dx,1
        shr     dx,1
        shr     dx,1
        add     dx,cx
        mov     ax,3100h
        int     21h
else
        pop     bp
        pop     si
        pop     di
        pop     es
        pop     ds
        ret
endif   ; if ComFile


;------------------------------------------------------------------------
;   << LoadUdc >>
; FUNCTION = install UDC file
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; LoadUdc(-/-)
;       {
;       }
;
;    structure of header of UDCCON.SYS
;       offset 00H-01H (2)  :  pointer of UDC map table
;       offset 02H-03H (2)  :  size of UDC map table
;       offset 04H-05H (2)  :  pointer of UDC index table
;       offset 06H-07H (2)  :  size of UDC index table
;       offset 08H-09H (2)  :  pointer of UDC set table
;       offset 0aH-0bH (2)  :  size of UDC set table
;       offset 0cH-0dH (2)  :  pointer of start of pattern
;       offset 0eH-0fH (2)  :  size of pattern
;       offset 10H-17H (8)  :  UDC file ID
;       offset 18H-1fH (8)  :  last update date
;       offset 20H-2fH (16) :  reserved
;
LoadUdc:
        test    [HjStat],UdcArea
        jz      LoadUdcEnd
        test    [ErrStat],FontLoadErr
        jnz     LoadUdcEnd
        mov     dx,offset UdcFileName
        mov     ax,3d00h
        int     21h
        mov     bx,ax
        jnc     HaveUdc
LoadUdcEnd:
        ret
HaveUdc:
        mov     [UdcHandle],bx
        mov     dx,[EndOffset]
        mov     di,dx
        mov     [UdcTblPtr],di
        mov     cx,(30H+188*2+188*4+188*2) ; # of bytes to read
        mov     ah,3fH
        int     21h
        jc      LoadUdcErr
        mov     ax,[di+UdcSetTblSize]
        shl     ax,1
        add     ax,[di+UdcSetTblPtr]
        add     [EndOffset],ax          ; save UdcTbl END address
        mov     si,di
        add     si,10H                  ; point to file identifier
        mov     di,offset UdcConId
        mov     cx,8                    ; repeat counter
        rep movsw
        mov     dx,[EndOffset]
        test    [MemStat],RealMem
        jz      @f
        mov     [UdcAddr],dx            ; save UdcFont address
@@:
        mov     cx,94*32
        mov     bx,[UdcHandle]
        mov     ah,3fH
        int     21h
        jc      LoadUdcErr
        mov     cx,ax
        mov     si,dx
        mov     ax,0c9a1h
        call    WriteUdc
        jc      LoadUdcErr
        mov     dx,[EndOffset]
        mov     cx,94*32
        mov     bx,[UdcHandle]
        mov     ah,3fH
        int     21h
        jc      LoadUdcErr
        mov     cx,ax
        mov     si,dx
        mov     ax,0fea1h
        call    WriteUdc
        jc      LoadUdcErr
        or      [HjStat],UdcLoaded
        mov     bx,[UdcHandle]
        mov     ah,3eH                  ; close file handle
        int     21h
        ret
LoadUdcErr:
        or      [ErrStat],UdcLoadErr
        ret
WriteUdc:
        test    [MemStat],RealMem
        jz      @f
        add     [EndOffset],cx          ; save END address
        clc
        ret
@@:
        mov     cx,94
WriteUdcloop:
        mov     bx,ax
        test    [CodeStat],Chab
        jz      @f
        call    ChgKs2Ch
@@:
        xchg    cx,ax                   ; get code (ch,cl)
        call    PutPattern
        xchg    cx,ax
        mov     ax,bx
        jc      @f
        inc     ax                      ; next code
        add     si,32
        loop    WriteUdcloop
        clc
@@:
        ret
UdcHandle       label   word
UdcFileName     db      'UDCCON.SYS',0
TmpStack        label   word


;------------------------------------------------------------------------
;   << InstallFontFileReal >>
; FUNCTION =   real memory 
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; InstallFontFileReal(-/-)
;       {
;       }
;
InstallFontFileReal:
        test    [MemStat],RealMem
        jz      NotRealFont
        cmp     [MemSize],0
        jz      NotRealFont
        mov     dx,offset FontFileName
        mov     ax,3d00h
        int     21h
        jc      @f
        mov     bx,ax
        mov     ax,4200h
        xor     cx,cx
        mov     dx,30h
        int     21h                     ; set absolute file pointer
        or      [HjStat],HjLoaded
        mov     dx,[EndOffset]
        mov     [HanAddr],dx
        xor     ax,ax
        add     [EndOffset],61440       ; 32*94*64 = 192512
        adc     ah,0
        mov     cl,4
        shl     ah,cl
        add     [EndSegment],ax
        add     [EndSegment],2000h
ReadRealLoop:
        mov     ax,dx
        mov     cl,4
        shr     ax,cl
        mov     cx,ds
        add     cx,ax
        mov     ds,cx
        and     dx,0fh
        mov     cx,4000h
        mov     ah,3fh
        int     21h
        jc      ReadRealErr
        or      ax,ax
        jz      @f
        add     dx,ax
        jmp     short ReadRealLoop
ReadRealErr:
        or      cs:[ErrStat],FontLoadErr
@@:
        mov     ax,cs
        mov     ds,ax
        mov     ah,3eh
        int     21h
NotRealFont:
        ret


;------------------------------------------------------------------------
;   << InitMode >>
; FUNCTION =  video mode 
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; InitMode(-/-)
;       {
;       Save ES;
;       ES = 0;
;       if ([Card1st] == DualMnt)
;               {
;               xchg [Card1st], [Card2nd];
;               ES:[rEquip] = ES:[rEquip] || 00110000b;
;               if ([Card1st] == ColorMnt)
;                       ES:[rEquip] = ES:[rEquip] && 11101111b;
;               AX = 3;
;               INT 10h;
;               xchg [Card1st], [Card2nd];
;               }
;       ES:[rEquip] = ES:[rEquip] || 00110000b;
;       if ([Card1st] == ColorMnt)
;               ES:[rEquip] = ES:[rEquip] && 11101111b;
;       AX = 3;
;       INT 10h;
;       Restore ES;
;       }
;
InitMode:
        test    [Card1st],DualMnt
        jz      InitMode1st
        push    word ptr [CodeStat]
        or      [CodeStat],HangeulMode
        int     11h
        cmp     al,00110000b
        mov     ax,7
        jpe     @f
        mov     al,3
@@:
        int     10h
        pop     ax
        mov     [CodeStat],al
InitMode1st:
        mov     ah,0fh
        int     10h
        call    ChgEnvrDo

        push    ax
        push    bx
        call    SearchMode
        jc      InitMode2nd
        mov     bh,[si+sCodeVram]
        xor     bl,bl
        xor     ax,ax
        mov     word ptr [CodeBuf1Addr],ax
        mov     word ptr [CodeBuf1Addr+2],bx
if      WINNT   ; if we run HBIOS on windowed mode for the first time,
                ; these variables are not initialized.
        cmp     [ActiveCodePage], WanSungCP
        jnz     @f
        or      [CodeStat],HangeulVideoMode
        mov     [MaxRows],25
@@:
endif
InitMode2nd:
        pop     bx
        pop     ax
        ret


;------------------------------------------------------------------------
;   << DispSignonMsg >>
; FUNCTION =  BIOS   font/UDC  message display
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; DispSignonMsg(-/-)
;       {
;       SI = SignonMsg;
;       DispMsg(SI/-);
;       if ([OrgHjStat] == HjLoaded)
;               {
;               SI = FontMsg;
;               DispMsg(SI/-);
;               SI = LoadMsg;
;               if ([ErrStat] == FontLoadErr), SI = FontErrMsg;
;               DispMsg(SI/-);
;               }
;       if ([OrgHjStat] == UdcLoaded)
;               {
;               SI = UdcMsg;
;               DispMsg(SI/-);
;               SI = UdcConId;
;               if ([ErrStat] == UdcLoadErr), SI = UdcErrMsg;
;               DispMsg(SI/-);
;               }
;       }
;
; DispString(si/-)
;       {
;       if ([si] != 0)
;               {
;               AL = [si];
;               + SI;
;               AH = 0eh;
;               BX = 7;
;               INT 10h;
;               }
;       }
;
DispSignonMsg:
if      WINNT
        ; Don't need to display version information
        test    [ErrStat],FontLoadErr
        jz      @f
        mov     si,offset FontErrMsg
        call    DispString
@@:
        test    [Card1st],FontCard or HanCard
        jnz     DispNoneFontFile
        test    [Card2nd],FontCard or HanCard
        jnz     DispNoneFontFile
        test    [OrgHjStat],HjLoaded
        jz      DispNoneFontFile
else
        mov     si,offset SignonMsg
        test    [CodeStat],Chab
        jz      @f
        mov     si,offset SignonMsgCh
@@:
        call    DispString
        test    [Card1st],FontCard or HanCard
        jnz     DispNoneFontFile
        test    [Card2nd],FontCard or HanCard
        jnz     DispNoneFontFile
        test    [OrgHjStat],HjLoaded
        jz      DispNoneFontFile
        ;mov     si,offset FontMsg
        ;call    DispString
        mov     si,offset LoadMsg
        test    [ErrStat],FontLoadErr
        jz      @f
        mov     si,offset FontErrMsg
@@:
        call    DispString
endif
DispNoneFontFile:
        test    [OrgHjStat],UdcLoaded
        jz      DispNoneUdc
        mov     si,offset UdcMsg
        call    DispString
        mov     si,offset UdcConId
        test    [ErrStat],UdcLoadErr
        jz      @f
        mov     si,offset UdcErrMsg
@@:
        call    DispString
DispNoneUdc:
        ret
DispString:
        lodsb
        or      al,al
        jz      @f
        mov     ah,0eh
        mov     bx,7
        int     10h
        jmp     short DispString
@@:
        ret

if      WINNT
        ; Don't need to display version information
else
SignonMsg       db      'HBIOS  ', Version, cr,lf     ; [CHM0]
                db      'Copyright (C) Microsoft Corp 1993',cr,lf,0     ; [CHM0]
SignonMsgCh     db      'HBIOS e ', Version, cr,lf
                db      'Copyright (C) Microsoft Corp 1993',cr,lf,0
LoadMsg         db      '**   .',cr,lf,0
endif
UdcErrMsg       label   byte
FontErrMsg      db      '**    .',cr,lf,0
UdcMsg          db      'UDC : ',0
UdcConId        db      16 dup(' '),cr,lf,0
public  FontFilename
FontFilename    db      'hfont.sys'     ; [CHM001]
                db      80-8 dup(0)

;------------------------------------------------------------------------

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\hecon.asm ===
TITLE   Hangeul/Hanja Console Device Driver Header
        page    ,132

;****************************************************************************;
; (C)Copyright Qnix Co., Ltd., 1985-1991.                                    ;
; This program contains proprietary and confidential information.            ;
; All rights reserved.                                                       ;
;****************************************************************************;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; File name: HECON.ASM
;; Description:
;;      These routine are the header of HECON.SYS which is Installable
;;      Device Driver that is the console device driver to handle
;;      Hangeul/Hanja console IO services
;;
;;      Called routine:
;;              HAN_INIT   -   procedure in INIT.ASM file
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.sall                                   ; supress macro listings

BreakInt        equ     1bH * 4
;
;------------------------------------------------------------------------
;       MACRO DEFINITION                                                ;
;------------------------------------------------------------------------
; Given a label <lbl> generate either 2 byte jump to another label <lbl>_J
; if it is near enough or 3 byte jump to <lbl>
;
Jump    macro lbl
    local a
 .xcref

    ifndef lbl&_J                       ; is this the first invocation
a:      jmp lbl
    else
        if (lbl&_J GE $) or ($-lbl&_J GT 126)
a:      jmp lbl                         ; is the jump too far away?
        else
a:      jmp lbl&_J                      ; do the short one...
        endif
    endif
    lbl&_j = a
 .cref
endm
 .xcref  Jump
;------------------------------------------------------------------------

code    segment public byte 'code'
        assume  cs:code, ds:code

INCLUDE EQU.INC

if      ComFile
        org     100h
extrn   HanInit:near
HeconStart:
        jmp     HanInit
else

HeconStart:                     ; dummy

; start of HECON.SYS routine
public  ConHeader
ConHeader       label   word
                dw      -1,-1           ; pointer to next device
                dw      1000000001010011B ; con-in and con-out + special
                dw      Strategy        ; strategy entry point
                dw      ConIO           ; interrupt entry point
                db      'CON     '      ; device name

ConTbl:
                db      13h
                dw      ConInit         ;0
                dw      Exit            ;1
                dw      Exit            ;2
                dw      CmdErr          ;3
                dw      ConRead         ;4
                dw      ConCheck        ;5
                dw      Exit            ;6
                dw      ConFlush        ;7
                dw      ConWrite        ;8
                dw      ConWrite        ;9
                dw      Exit            ;A
                dw      Exit            ;B
if      hdos60
                dw      Exit            ;C
                dw      Exit            ;D
                dw      Exit            ;E
                dw      Exit            ;F
                dw      Exit            ;10H
                dw      Exit            ;11H
                dw      Exit            ;12H
                dw      GenIoctl        ;13H
                dw      Exit            ;14H
endif   ;  hdos60

        page
;
; The next nine equ's describe the offset into the request header for
; different information.  For example STATUS is in byte 3 of the request
; header (starting count at zero).
;
CmdLen  =       0                       ; length of this command
Unit    =       1                       ; sub unit specifier
Cmd     =       2                       ; command code
Status  =       3                       ; status
Media   =       13                      ; media descriptor
Trans   =       14                      ; transfer address
Count   =       18                      ; count of blocks or characters
Start   =       20                      ; first block to transfer
Extra   =       22                      ; Usually pointer to Vol Id for err 15

if      hdos60
; Bilingual implementation
WansungCode     =       949
ChohabCode      =      1361
EnglishCode     =       437
SetCode         =       04ah

IoctlReq        struc
                db      13 dup(?)
MajorCode       db      ?
MinorCode       db      ?
SiReg           dw      ?
DiReg           dw      ?
DataBuf         dd      ?
IoctlReq        ends
endif   ;   hdos60

;
; PtrSav - pointer save
;
; This variable holds the pointer to the Request Header passed by a program
; wishing to use a device driver.  When the strategy routine is called
; it puts the address of the Request header in this variable and returns.
;
public  PtrSav
PtrSav          dd      0

Foo     proc    far
Strategy:
        mov     word ptr cs:[PtrSav],bx
        mov     word ptr cs:[PtrSav+2],es
        ret
Foo     endp

;
; This section is the prolog to all default device drivers.  All registers
; are saved, the registers are filled with information fromthe request header,
; and the routine from the jump table is called.  Error checking is done
; to assure command code is valid.  Before calling the routine in the
; jump table the register are:
;
;       AH = Media Descriptor
;       BX = offset to PtrSav (request header is therefore at DS:BX)
;       CX = count from request header
;       DS:SI = tranfer address
;
; Once the routine finishes its job it jumps back to one of the eight
; pieces of code below labeled Exit Points.
;

;------------------------------------------------------------------------
;
;                       Device entry point
;
; The following ten pieces of code are the interrupt entry points for the
; default device drivers.  These small pieces of code have two jobs.
;
;       1) Make SI point to the beginning of the proper command jump table.
;          SI must first be pushed to preserve original contents.
;
; Con device:
;
ConIO:
Entry:
        sti                             ; enable interrupts
        push    ax                      ; save all registers
        push    bx
        push    cx
        push    si
        push    ds
        mov     si,offset ConTbl        ; get pointer to console IO table
        lds     bx,cs:[PtrSav]          ; get pointer to I/O packet
        mov     cx,ds:[bx].Count        ; cx = count
        mov     al,ds:[bx].Cmd
        cmp     al,cs:[si]              ; is command code a valid number?
        ja      CmdErr                  ; no, jump to handle error
        cbw                             ; note that al <= 15 means OK
        shl     ax,1
        inc     si
        add     si,ax                   ; get di to point to address of routine
        mov     ah,ds:[bx].Media        ; ah = media descriptor
        shr     ah,1
        shr     ah,1
        jmp     word ptr cs:[si]        ; go to the command

        page

;------------------------------------------------------------------------
;
;               Exit  Points
;
; All device driver call return through one of these eight
; pieces of code.  The code set error and status conditions
; and then restores the registers.
;
CmdErr:
;       sub     [bx].Count,cx           ; # of successful I/O's
        mov     ax,1000000100000011B    ; mark error(unknown command) & return
        jmp     short Exit1
BusyExit:                               ; device busy exit
        mov     ah,00000011B            ; set error code
        jmp     short Exit1
Exit:
        mov     ah,00000001B
Exit1:  lds     bx,cs:[PtrSav]
Exit2:  and     ah,11111011b
        mov     [bx].Status,ax          ; mark operation complete
        pop     ds                      ; restore register and return
        pop     si
        pop     cx
        pop     bx
        pop     ax
FarRet1 proc    far
        ret
FarRet1 endp

;------------------------------------------------------------------------
;                                                                       ;
;             C O N - Console Device Driver                             ;
;                                                                       ;
;------------------------------------------------------------------------
;
; Device Header for the CON Device Driver
;
; ALTAH is a single character buffer used to handle special keys.
;

AltAH           db      0               ; Special key handling

;------------------------------------------------------------------------
;                                                                       ;
;                   Console Read routine                                ;
;                                                                       ;
;------------------------------------------------------------------------
ConRead:
        jcxz    ConReadExit             ; to be read -- just exit
        lds     si,ds:[bx].Trans        ; get ds:si to point to trans addr
        test    ah,00000001B
        jnz     ConReadNonDisp
        mov     bx,0                    ; get complete char code
ConReadLoop:
        call    CharIn                  ; get char in al
        mov     ds:[si],al              ; store char at ds:si, specified buffer
        inc     si                      ; point to next buffer position
        loop    ConReadLoop             ; if cx is non-zero more char to read
ConReadExit:
        Jump    Exit                    ; all done, successful return

ConReadNonDisp:
        mov     bx,(240 shl 8)          ; get interim char code
        cmp     cx,1
        jne     ConReadNonDispLoop
        call    CharIn                  ; get char in al
        mov     ds:[si],al              ; store char at ds:si, specified buffer
        inc     si                      ; point to next buffer position
        cmp     ah,0f0H                 ; interim char?
        jne     ConReadExit             ; jump no
        mov     ah,00000101B            ; indicate interim char
        Jump    Exit1

ConReadNonDispLoop:
        call    CharIn                  ; get char in al
        cmp     ah,0f0H                 ; interim char?
        je      ConReadNonDispLoop      ; jump so
        mov     ds:[si],al              ; store char at ds:si, specified buffer
        inc     si                      ; point to next buffer position
        loop    ConReadNonDispLoop      ; if cx is non-zero more char to read
        Jump    Exit

;------------------------------------------------------------------------
;                                                                       ;
;           Input single character into AL                              ;
;                                                                       ;
;------------------------------------------------------------------------
CharIn:
        xor     ax,ax                   ; set cmd and clear al
        xchg    al,cs:[AltAH]           ; get character & zero AltAH
        or      al,al                   ; see if buffer has a character
        jnz     CharInRet               ; if so - return this character
        mov     ax,bx
        int     16H                     ; call ROM-Bios keyboard routine
        or      ax,ax                   ; Check for non-key after BREAK
        jz      CharIn
        cmp     ax,7200H                ; Check for Ctrl-PrtSc
        jnz     CharInOk
        mov     al,16                   ; indicate prtsc
CharInOk:
        or      al,al                   ; special case?
        jnz     CharInRet               ; no, return with character
        mov     cs:[AltAH],ah           ; yes, store special key
CharInRet:
        ret

;----------------------------------------------------------------
;                                                               :
;          Keyboard non destructive read, no wait               :
;                                                               :
; If bit 10 is set by the DOS in the status word of the request :
; packet, and there is no character in the input buffer, the    :
; driver issues a system WAIT request to the ROM. On return     :
; from the ROM, it returns a 'char-not-found' to the DOS.       :
;                                                               :
;----------------------------------------------------------------
ConCheck:
        mov     al,cs:[AltAH]           ; first see if there is a
        or      al,al                   ; character in the buffer?
        jnz     ConCheckExit            ; yes, return that character
                                        ; no, continue
        mov     bx,(1 shl 8)
        test    ah,00000001B
        jz      ReConCheck              ; jump if wanted complete char code
        mov     bx,(241 shl 8)
ReConCheck:
        mov     ax,bx
        int     16H                     ; call ROM-BIOS keyboard routine
        jz      ConBusy                 ; not available char, jump to busy
        or      ax,ax                   ; check for null after break
        jnz     ConCheckOk              ; no, skip down
; note: AH is already zero, no need to set command
        int     16H                     ; yes, read the null
        jmp     short ReConCheck

ConCheckOk:
        cmp     ah,0f0H                 ; incomplete scan code?
        jnz     ConCheckFinal
        lds     bx,cs:[PtrSav]          ; get pointer to request header
        mov     [bx].Media,al           ; move character into req. header
        mov     ah,00000101B            ; indicate interim char
        Jump    Exit2
ConCheckFinal:
        cmp     ax,7200H                ; check for Ctrl-PrtSc
        jnz     ConCheckExit            ; no
        mov     al,16                   ; yes, indicate Ctrl-PrtSc
ConCheckExit:
        lds     bx,cs:[PtrSav]          ; get pointer to request header
        mov     [bx].Media,al           ; move character into req. header
        Jump    Exit                    ; all done -- successful return

ConBusy:
        Jump    BusyExit                ; done -- con device is busy

;----------------------------------------------------------------
;                                                               :
;               Keyboard flush routine                          :
;                                                               :
;----------------------------------------------------------------
ConFlush:
        mov     cs:[AltAH],0            ; clear out holding buffer
        mov     ah,243                  ; Keyboard flush entry
        int     16H
        Jump    Exit

;----------------------------------------------------------------
;                                                               :
;              Console Write Routine                            :
;                                                               :
;----------------------------------------------------------------
ConWrite:
        cld                             ; clear the direction flag
        jcxz    ConWriteExit            ; if cx is zero, get out
        lds     si,ds:[bx].Trans        ; get ds:si to point to trans addr
        mov     bx,7                    ; set page #(bh), foreground color(bl)
        test    ah,00000001B
        jnz     ConWriteLoopNac         ; output character & no cursor advance
ConWriteLoop:
        lodsb                           ; get character
        mov     ah,0eH                  ; write char with cursor advancing
        int     10H                     ; call bios
        loop    ConWriteLoop            ; repeat until all through
ConWriteExit:
        mov     ah,00000001B
        lds     bx,cs:[PtrSav]
        mov     [bx].Status,ax          ; mark operation complete
        pop     ds                      ; restore register and return
        pop     si
        pop     cx
        pop     bx
        pop     ax
FarRet2 proc    far
        ret
FarRet2 endp

ConWriteLoopNac:
        lodsb                           ; get character
        mov     ah,0feH                 ; write char w/o cursor advancing
        int     10H                     ; call bios
        loop    ConWriteLoopNac         ; repeat until all through
        Jump    Exit

;------------------------------------------------
;
;       CONSOLE INIT ROUTINE
;
;------------------------------------------------
ConInit:
        push    dx                      ; save registers
; patch the BREAK key handling interrupt routine
        sub     ax,ax
        mov     ds,ax
        mov     bx,BreakInt
        mov     ax,offset cBreak
        mov     dx,cs
        cli
        mov     ds:[bx],ax
        mov     ds:[bx+2],dx
        sti
extrn   HanInit:near
        call    HanInit
;
;       Now, CX:DX points to the end of HECON.SYS resident part
;
        lds     bx,cs:[PtrSav]
        mov     [bx].Trans,dx
        mov     [bx].Trans+2,cx
        pop     dx                      ; restore registers
        Jump    Exit

;-----------------------------------------------------------------------
;
;       BREAK KEY HANDLING
;
;-----------------------------------------------------------------------
cBreak:
        mov     cs:[AltAH],3            ; indicate break key set
        push    ax                      ; save register
        mov     ah,243                  ; keyboard flush
        int     16H
        pop     ax                      ; recover register
        iret

if      hdos60
;
; Bilingual      implementation
;
extrn   ChangeCodeR:near
GenIoctl:
        mov     al,ds:[bx.MinorCode]
        cmp     al,SetCode
        je      @f
        jmp     CmdErr
@@:
        push    bx
        push    es
        push    dx
        les     bx,ds:[bx.DataBuf]
        mov     ax,es:[bx+2]
        mov     dl,0
        cmp     ax,WansungCode
        je      CallChange
        mov     dl,1
        cmp     ax,ChohabCode
        je      CallChange
        mov     dl,2
        cmp     ax,EnglishCode
        je      CallChange
        pop     dx
        pop     es
        pop     bx
        jmp     CmdErr
CallChange:
        mov     al,dl
        call    ChangeCodeR
        pop     dx
        pop     es
        pop     bx
        jmp     Exit
endif   ;   hdos60

endif   ; if ComFile

code    ends
        end     HeconStart
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\jungi.inc ===
DW      0,2,34,34,2,34,34,56
        DW      88,88,56,88,88,110,142,142
        DW      110,142,142,164,196,196,164,196
        DW      196,218,250,250,272,250,304,326
        DW      358,358,380,358,412,434,466,466
        DW      488,466,520,542,574,574,596,574
        DW      628,650,662,662,670,680,680,688
        DW      720,720,742,720,774,796,828,828
        DW      850,828,882,904,936,936,958,936
        DW      990,1012,1026,1026,1036,1046,1046,1054
        DW      1072,1072,1080,1072,1096,1108,1140,1140
        DW      1162,1140,1194,1216,1248,1248,1270,1248
        DW      1302,1324,1356,1356,1378,1356,1410,1432
        DW      1450,1450,1458,1450,1474,1486,1490,1490
        DW      1486,1490,1490,1494,1526,1526,1548,1526
        DW      1526,1580,1612,1612,1580,1612,1612
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\jong.inc ===
DW      0FFFFh
        DW      514h, 0F01Fh,3000h,3000h,3000h,2000h
        DW      514h, 0F80Fh,1800h,1800h,1800h,1000h
        DW      514h, 0FC07h,0C00h,0C00h,0C00h,800h
        DW      612h, 0F01Fh,3000h,3000h,3000h,3000h,2000h
        DW      514h, 0F03Fh,3006h,3006h,3006h,2004h
        DW      514h, 0F81Fh,1803h,1803h,1803h,1002h
        DW      514h, 0FC0Fh,8C01h,8C01h,8C01h,801h
        DW      612h, 0F03Fh,3006h,3006h,3006h,3006h,2004h
        DW      514h, 0E03Eh,6006h,0F006h,9807h,805h
        DW      514h, 701Fh,3003h,7803h,0CC03h,8402h
        DW      514h, 0B80Fh,9801h,0BC01h,0E601h,4201h
        DW      612h, 0E03Eh,6006h,6006h,0F006h,9807h,805h
        DW      514h, 1Ch,0Ch,0Ch,0Ch,0F007h
        DW      514h, 0Eh,6,6,6,0F803h
        DW      514h, 7,3,3,3,0FC01h
        DW      514h, 0F839h,6018h,0F018h,9819h,80Fh
        DW      514h, 0FC1Ch,300Ch,780Ch,0CC0Ch,8407h
        DW      612h, 0F839h,6018h,6018h,0F018h,9819h,80Fh
        DW      514h, 6038h,0F819h,0F018h,9819h,0F00Eh
        DW      514h, 301Ch,0FC0Ch,780Ch,0CC0Ch,7807h
        DW      612h, 0E000h,6038h,0F819h,0F018h,9819h,0F00Eh
        DW      514h, 0F01Fh,0Ch,0Ch,0Ch,0F007h
        DW      514h, 0F80Fh,6,6,6,0F803h
        DW      514h, 0FC07h,3,3,3,0FC01h
        DW      514h, 0F01Fh,3000h,0F01Fh,0Ch,0F007h
        DW      514h, 0F80Fh,1800h,0F80Fh,6,0F803h
        DW      514h, 0FC07h,0C00h,0FC07h,3,0FC01h
        DW      612h, 0F01Fh,3000h,0F01Fh,0Ch,0Ch,0F007h
        DW      514h, 0F03Fh,3006h,303Eh,3030h,201Eh
        DW      514h, 0F81Fh,1803h,181Fh,1818h,100Fh
        DW      514h, 0FC0Fh,8C01h,8C0Fh,0C0Ch,8807h
        DW      612h, 0F81Fh,1803h,181Fh,1818h,1818h,100Fh
        DW      514h, 0F03Fh,0B007h,0B03Fh,0B031h,0F01Eh
        DW      514h, 0F81Fh,0D803h,0D81Fh,0D818h,780Fh
        DW      514h, 0FC0Fh,0EC01h,0EC0Fh,6C0Ch,0BC07h
        DW      612h, 0F81Fh,0D803h,0D81Fh,0D818h,0D818h,780Fh
        DW      514h, 0B03Fh,0B007h,0F03Fh,0B031h,0F01Eh
        DW      514h, 0D81Fh,0D803h,0F81Fh,0D818h,780Fh
        DW      514h, 0EC0Fh,0EC01h,0FC0Fh,6C0Ch,0BC07h
        DW      612h, 0D81Fh,0D803h,0F81Fh,0D818h,0D818h,780Fh
        DW      514h, 0E03Eh,6006h,0F03Eh,9831h,81Fh
        DW      514h, 701Fh,3003h,781Fh,0CC18h,840Fh
        DW      514h, 0B80Fh,9801h,0BC0Fh,660Ch,0C207h
        DW      612h, 701Fh,3003h,301Fh,7818h,0CC18h,840Fh
        DW      514h, 0F03Fh,8007h,0F03Fh,8031h,0F01Eh
        DW      514h, 0F81Fh,0C003h,0F81Fh,0C018h,780Fh
        DW      514h, 0FC0Fh,0E001h,0FC0Fh,600Ch,0BC07h
        DW      612h, 0F81Fh,0C003h,0F81Fh,0C018h,0C018h,780Fh
        DW      514h, 0F83Fh,3007h,0B03Fh,0A031h,0F81Fh
        DW      514h, 0FC1Fh,9803h,0D81Fh,0D018h,0FC0Fh
        DW      514h, 0FE0Fh,0CC01h,0EC0Fh,680Ch,0FE07h
        DW      612h, 0FC1Fh,9803h,0D81Fh,0D818h,0D018h,0FC0Fh
        DW      514h, 603Eh,0F807h,0F03Eh,9831h,0F01Eh
        DW      514h, 301Fh,0FC03h,781Fh,0CC18h,780Fh
        DW      514h, 980Fh,0FE01h,0BC0Fh,660Ch,0BC07h
        DW      612h, 301Fh,0FC03h,781Fh,0CC18h,0CC18h,780Fh
        DW      514h, 0F01Fh,300Ch,300Ch,300Ch,0F00Fh
        DW      514h, 0F80Fh,1806h,1806h,1806h,0F807h
        DW      514h, 0FC07h,0C03h,0C03h,0C03h,0FC03h
        DW      514h, 701Ch,300Ch,0F00Fh,300Ch,0F00Fh
        DW      514h, 380Eh,1806h,0F807h,1806h,0F807h
        DW      514h, 1C07h,0C03h,0FC03h,0C03h,0FC03h
        DW      612h, 701Ch,300Ch,0F00Fh,300Ch,300Ch,0F00Fh
        DW      514h, 0E00Eh,6076h,0F03Eh,9837h,83Fh
        DW      514h, 7007h,303Bh,781Fh,0CC1Bh,841Fh
        DW      514h, 0B803h,981Dh,0BC0Fh,0E60Dh,0C20Fh
        DW      612h, 7007h,303Bh,301Bh,781Fh,0CC1Bh,841Fh
        DW      514h, 8003h,8001h,0C003h,600Ch,1830h
        DW      514h, 0C001h,0C000h,0E001h,3006h,0C18h
        DW      514h, 0E000h,6000h,0F000h,1803h,60Ch
        DW      612h, 8003h,8001h,8003h,6006h,300Ch,1830h
        DW      514h, 0E01Ch,600Ch,0F01Eh,9833h,842h
        DW      514h, 700Eh,3006h,780Fh,0CC19h,421h
        DW      514h, 3807h,1803h,0BC07h,0E60Ch,8210h
        DW      612h, 600Ch,3006h,3006h,780Fh,0CC19h,421h
        DW      514h, 0E007h,300Ch,300Ch,300Ch,0E007h
        DW      514h, 0F003h,1806h,1806h,1806h,0F003h
        DW      514h, 0F801h,0C03h,0C03h,0C03h,0F801h
        DW      514h, 0F01Fh,8001h,6003h,3006h,1818h
        DW      514h, 0F80Fh,0C000h,0B001h,1803h,0C0Ch
        DW      514h, 0FC07h,6000h,0D800h,8C01h,606h
        DW      612h, 0F01Fh,8001h,8001h,6003h,3006h,1818h
        DW      514h, 8003h,0F81Fh,0C001h,6007h,181Ch
        DW      514h, 0C001h,0FC0Fh,0E000h,0B003h,0C0Eh
        DW      612h, 8003h,0F81Fh,8001h,0C003h,3006h,1818h
        DW      514h, 0F01Fh,3000h,0F01Fh,3000h,2000h
        DW      514h, 0F80Fh,1800h,0F80Fh,1800h,1000h
        DW      514h, 0FC07h,0C00h,0FC07h,0C00h,800h
        DW      612h, 0F01Fh,3000h,0F01Fh,3000h,3000h,2000h
        DW      514h, 0F01Fh,0Ch,0F00Fh,0Ch,0F007h
        DW      514h, 0F80Fh,6,0F807h,6,0F803h
        DW      514h, 0FC07h,3,0FC03h,3,0FC01h
        DW      612h, 0F01Fh,0Ch,0F00Fh,0Ch,0Ch,0F007h
        DW      514h, 0F81Fh,6004h,6006h,4006h,0F81Fh
        DW      514h, 0FC0Fh,3002h,3003h,2003h,0FC0Fh
        DW      612h, 8003h,0F01Fh,0C007h,600Ch,600Ch,0C007h
        DW      612h, 0C001h,0F80Fh,0E003h,3006h,3006h,0E003h
        DW      612h, 0E000h,0FC07h,0F001h,1803h,1803h,0F001h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\init.asm ===
TITLE   Initialization routines

;=======================================================================;
; (C)Copyright Qnix Computer Co. Ltd.   1985-1992.                      ;
; This program contains proprietary and confidential information.       ;
; All rights reserved.                                                  ;
;=======================================================================;

;=======================================================================;
;                                                                       ;
;                    SPECIFICATION for initialize                       ;
;                                                                       ;
;=======================================================================;
;
; Keyboard type : english 84 KBD
;               : hangeul 86 KBD(none standard)
;               : hangeul 86 KBD(KS C 5853)
;               : 101 KBD
;               : 103 KBD(KS C 5853)
;
; Video card : MGA
;              CGA
;              EGA-mono
;              EGA-color
;              VGA
;              Font card
;              Dual monitor
;              / video card
;               file  : HIMEM, EMS, Ext., real memory
;              UDC file 
;
; User definable / key
; Configuration file 
;

CODE    SEGMENT PUBLIC WORD 'CODE'
ASSUME  CS:CODE, DS:CODE, ES:CODE

        INCLUDE EQU.INC
INCLUDE debug.inc
        INCLUDE compose.INC

;************************************************************************
;**                                                                    **
;**                    GLOBAL DATA & FLAG                              **
;**                                                                    **
;************************************************************************

; ----------- EQUATION -----------
; ------------- FLAG -------------
; ------------- DATA -------------

extrn   OldKbInt:dword, OldKbioInt:dword, OldRtcInt:dword, OldVdParms:dword
extrn   OldVideo:dword, OldSavePtr:dword, OldInt15:dword, OldInt17:dword
extrn   EndSegment:word, EndOffset:word
extrn   MemStat:byte, MemSize:word
extrn   EmsSeg:word, EmsHandle:word, MaxMemSize:word, CurEmsPage:word
extrn   HanAddr:word, HanAddrH:byte, UdcAddr:word, UdcAddrH:byte
extrn   CodeStat:byte, Card1st:byte, Card2nd:byte, HeKey:byte, HjKey:byte
extrn   KbStat:byte, Printer:byte, ErrStat:byte, HjStat:byte, MachineType:byte
extrn   WinSegment:word, WinOffset:word, KbdType:byte

extrn   HanPatternPtr:word, PatGenAddr:word

extrn   CodeBuf2Addr:dword, CodeBufSize:word

extrn   GetHan1st:word, GetHan2nd:word, GetUdc1st:word, GetUdc2nd:word
extrn   PutUdc1st:word, PutUdc2nd:word, HanOn1st:word, HanOn2nd:word
extrn   HanOff1st:word, HanOff2nd:word

extrn   GetFontHanExt:near, GetFontUdcExt:near, PutFontUdcExt:near
extrn   GdtDataTbl:word
extrn   GetFontHanEms:near, GetFontUdcEms:near, PutFontUdcEms:near
extrn   GetFontHanReal:near, GetFontUdcReal:near, PutFontUdcReal:near

extrn   Int9:near, Int16:near, Int8:near, Int10:near, Int17:near, Int15Srv:near
extrn   ChgCode:near, VgaService:near
extrn   InitEnd:near, Install:near

extrn   VideoParms:byte
extrn   Mda70h:byte, Mda07h:byte
extrn   Cga40h:byte, Cga23h:byte
extrn   RegSize:byte, CrtcSet:byte

extrn   HanSavePtr:dword, VideoParmsTbl:byte
extrn   Mode2E:byte, Mode3E:byte, Mode7:byte
extrn   Mode07:byte, Mode23:byte
extrn   Mode3V:byte, Mode07V:byte, Mode3Ega:byte, Mode7Ega:byte

extrn   FontFilename:byte, iVersion:byte

extrn   vdm_info:near

if      Hwin31Sw
extrn   OldInt2f:dword, Int2f:near
endif   ;   Hwin31Sw

if      GetSwitch
if      not comfile
extrn   PtrSav:dword
InitBpb =       18                      ; init BPB(Bios Parameter Block)
endif
endif   ;   GetSwitch

;************************************************************************
;**                                                                    **
;**                           INITIALIZE                               **
;**                                                                    **
;************************************************************************
;

ParsKeyboard    PROC    Near

        @push   bx, dx
        lodsb                           ; Skip ':' character
        xor     bx, bx
@@:
        lodsb
        cmp     al, '0'
        jb      @f
        cmp     al, '9'
        ja      @f
        xchg    ax, bx
        mov     dx, 10
        mul     dx
        xor     bh, bh
        sub     bl, '0'
        add     bx, ax
        jmp     @b
@@:
dec     bx
dec     si
        cmp     bx, 6
        jae     @HEUnknown

        cmp     bx, 0
        jne     @F
        mov     cs:HeKey, 38h
        mov     cs:HjKey, 1Dh
        jmp     short @HEend
@@:
        cmp     bx, 1
        jne     @f
        mov     cs:HeKey, 1Dh
        mov     cs:HjKey, 38h
        jmp     SHORT @HEend
@@:
        cmp     bx, 2
        je      @HEdefined
        cmp     bx, 4
        jne     @f
@HEdefined:
        mov     cs:HeKey, 0F0h
        mov     cs:HjKey, 0F1h
        jmp     short @HEend
@@:
        cmp     bx, 3
        jne     @F
        mov     cs:HeKey, 2
        mov     cs:HjKey, 2
        jmp     short @HEend
@@:
        cmp     bx, 5                   ; BUGBUG - Testing code
        jne     @HEUnknown              ; BUGBUG - Testing code
        mov     cs:HeKey, 1                ; BUGBUG - Testing code
        mov     cs:HjKey, 1                ; BUGBUG - Testing code
        jmp     short @HEend
@HEUnknown:
        @pop    dx, bx
        stc                             ; Unknown number
        ret
@HEend:                                 ; OK
        @pop    dx, bx
        clc
        ret

ParsKeyboard    ENDP

;------------------------------------------------------------------------
;   << HanInit >>
; FUNCTION =  BIOS 
; INPUT   : SS, SP
; OUTPUT  : CX:DX =  BIOS  segment:offset address
; PROTECT : SS, SP
;
; HanInit(-/CX, DX)
;       {
;       Save DS, ES, SI, DI, BP;
;       DS = CS;
;       ES = CS;
;       SetMachineType(-/-);
;       SetHeHjKey(-/-);
;       if (CheckVideoCardType(-/flag) == CY)
;               {
;               /* disp error message */
;               CX = CS;
;               DX = 0;
;               return;
;               }
;       CheckHanCard(-/-);
;       GetConfigFile(-/-);
;       SetVideoParms(-/-);
;       CalcEndAddr(-/-);
;       SetPatGen(-/-);
;       SetCodeBuffer(-/-);
;       CheckMemory(-/-);
;       SetVector(-/-);
;       InstallFontFile(-/-);
;       jmp Install;
;
hbiosExist  DB      0
codePage    DB      0

public  HanInit
HanInit:
        push    ds
        push    es
        push    di
        push    si
        push    bp
        mov     ax,cs
        mov     ds,ax
        mov     es,ax
if      ComFile
        mov     ah, 66h
        mov     al, 1
        int     21h     ; Get Current Code Page
        cmp     bx, 949
        jne     @f
        mov     codePage, 2
        jmp     @join
@@:
        cmp     bx, 1361
        jne     @join
        mov     codePage, 4
@join:
        push    es
        mov     ax,0fd00h
        int     10h
        pop     es
        cmp     al,0fdh
        jne     @f
        mov     hbiosExist, 1
@@:
        call    ParsCommand
        mov     dx,offset DupErrMsg
        jc      ComFileEnd
        cmp     [hbiosExist], 0
        je      @f
ComFileEnd:
        mov     ah, 9
        int     21h
        mov     ax, 4C00h
        int     21h
@@:
endif   ; if ComFile
        call    SetMachineType
        cmp     [HeKey], 0
        jnz     @f
        call    SetHeHjKey
@@:
        call    CheckVideoCardType
        jnc     @f
        mov     dx,offset CardErrMsg
if      ComFile
        jmp     short ComFileEnd
else
        mov     ah,9
        int     21h
        mov     cx,cs
        xor     dx,dx
        jmp     InitEnd
endif   ; if ComFile
@@:
        mov     [WinSegment],cs

        ;
        ; Get VDM Information.
        ;
        mov     si,offset vdm_info
        mov     ah,20h
        BOP     43H

        call    GetConfigFile
        call    CheckHanCard
        call    InstPrinter
        call    SetVideoParms
        call    CalcEndAddr
        call    SetPatGen
        call    SetCodeBuffer
        call    CheckMemory
        call    SetVector
        call    InstallFontFile
if      hdos60
        push    ax
        mov     ax,04f02h
        int     2fh
        pop     ax
endif   ;   hdos60
        jmp     Install
CardErrMsg      db      cr,lf,'Invalid video card !!!',7,'$'
DupErrMsg       db      ' BIOS   !',7,cr,lf,'$'
;CardErrMsg      db      cr,lf,'Invalid video card !!!',7,'$'
;DupErrMsg       db      cr,lf,'Already installed !!!',7,'$'


ParsSkipOptions PROC    Near
@@:
        lodsb
        cmp     al, ' '
        je      @f
        cmp     al, 9
        je      @f
        cmp     al, cr
        je      @f
        cmp     al, lf
        jne     @b
@@:
        dec     si
        ret
ParsSkipOptions ENDP

;------------------------------------------------------------------------
if      ComFile
ParsCommand:
        mov     si,81h
@@:
        lodsb
        cmp     al,cr
        je      ParsEnd
        cmp     al,lf
        je      ParsEnd
        cmp     al,'/'
        jnz     @b
        lodsb
        or      al,20h
        cmp     al, 'u'         ; "/u" = uninstall option
        je      ParsRemove
        cmp     al, '?'
        je      ParsHelp
        call    ParsSkipOptions
        jmp     @b
ParsEnd:
        clc
        ret

;-------------------------------
DispRemoveEnd:
        mov     ax, cs
        mov     ds, ax
        mov     bl, [codePage]
        xor     bh, bh
        mov     si, [si+bx]
        mov     ah, 0fh
        int     10h
        mov     bl, 7
@@:
        lodsb
        or      al,al
        jz      @ParsExit
        mov     ah,0eh
        int     10h
        jmp     short @b
@ParsExit:
        mov     ax,4c00h
        int     21h

ParsHelp:
        mov     bx, Offset msgHelp
        call    ShowMultiMessage
        jmp     @ParsExit

ParsBadCmd:
        mov     bx, Offset msgBadCmd
        call    ShowMultiMessage
        jmp     @ParsExit

ParsRemove:
        cmp     cs:[hbiosExist], 0
        jnz     @f
        mov     ax, cs
        mov     ds, ax
        mov     dx, Offset msgNotExist
        mov     ah, 9
        int     21h
        jmp     @ParsExit
@@:
        mov     ax,0fd00h
        int     10h
        mov     si,offset iVersion
        mov     di,si
        mov     cx,5
        rep cmpsb                       ; compare same BIOS
        mov     si,offset msgUnknown
        jnz     DispRemoveEnd
        mov     si,offset msgUnable
        push    ds
        xor     ax,ax
        mov     ds,ax
ASSUME  DS:DATA
        mov     dx,es
        cmp     dx,word ptr [rKbInt+2]
        jnz     DispRemoveEnd
        cmp     dx,word ptr [rVideoInt+2]
        jnz     DispRemoveEnd
        cmp     dx,word ptr [rKbioInt+2]
        jnz     DispRemoveEnd
        cmp     dx,word ptr [rRtcInt+2]
        jnz     DispRemoveEnd
        and     es:[CodeStat],not HangeulMode
        call    dword ptr es:[WinOffset]
        cli
        mov     ax,word ptr es:[OldKbint]
        mov     bx,word ptr es:[OldKbint+2]
        mov     word ptr [rKbInt],ax
        mov     word ptr [rKbInt+2],bx
        mov     ax,word ptr es:[OldVideo]
        mov     bx,word ptr es:[OldVideo+2]
        mov     word ptr [rVideoInt],ax
        mov     word ptr [rVideoInt+2],bx
        mov     ax,word ptr es:[OldKbioInt]
        mov     bx,word ptr es:[OldKbioInt+2]
        mov     word ptr [rKbioInt],ax
        mov     word ptr [rKbioInt+2],bx
        mov     ax,word ptr es:[OldRtcInt]
        mov     bx,word ptr es:[OldRtcInt+2]
        mov     word ptr [rRtcInt],ax
        mov     word ptr [rRtcInt+2],bx
if      Hwin31Sw
        mov     ax,word ptr es:[OldInt2f]
        mov     bx,word ptr es:[OldInt2f+2]
        mov     word ptr [rInt2f],ax
        mov     word ptr [rInt2f+2],bx
endif   ;   Hwin31Sw
        mov     ax,word ptr es:[OldVdParms]
        mov     bx,word ptr es:[OldVdParms+2]
        mov     word ptr [rVdParm],ax
        mov     word ptr [rVdParm+2],bx
        mov     ax,word ptr es:[OldInt17]
        mov     bx,word ptr es:[OldInt17+2]
        cmp     dx,word ptr [rPrinter+2]
        jnz     @f
        mov     word ptr [rPrinter],ax
        mov     word ptr [rPrinter+2],bx
@@:
        mov     ax,word ptr es:[OldSavePtr]
        mov     bx,word ptr es:[OldSavePtr+2]
        cmp     dx,word ptr [rSavePtr+2]
        jnz     @f
        mov     word ptr [rSavePtr],ax
        mov     word ptr [rSavePtr+2],bx
@@:
        mov     ax,word ptr es:[OldInt15]
        mov     bx,word ptr es:[OldInt15+2]
        cmp     dx,word ptr [rCasetInt+2] ; same segment ?
        jnz     @f                        ; jump if no
        mov     word ptr [rCasetInt],ax
        mov     word ptr [rCasetInt+2],bx
@@:
        sti
        pop     ds
ASSUME  DS:CODE
        mov     dx,es:[EmsHandle]
        test    es:[MemStat],HiMem
        jz      @f
        mov     ah,0dh
        call    es:[OldInt15]
        mov     ah,0ah
        call    es:[OldInt15]
@@:
        test    es:[MemStat],EmsMem
        jz      @f
        mov     ah,45h                  ; close handle
        int     67h
@@:
        mov     ah,49h
        int     21h
        mov     si,offset msgRemove
        jmp     DispRemoveEnd

U_Unable    db  'Cannot remove installed HBIOS!', 7,cr,lf,0
C_Unable    DB  '   HBIOS   !', 7,cr,lf,0
W_Unable    DB  'e A e HBIOSi Ai  sa!', 7,cr,lf,0
msgUnable   DW  U_Unable, C_Unable, W_Unable

U_Unknown   db  'Unknown Hangeul BIOS!', 7,cr,lf,0
C_Unknown   DB  '   BIOS  !', 7,cr,lf,0
W_Unknown   DB  'ae  ei BIOSa A sa!', 7,cr,lf,0
msgUnknown  DW  U_Unknown, C_Unknown, W_Unknown

U_Remove    db  'Uninstalled!',cr,lf,0
msgRemove   DW  U_Remove, U_Remove, U_Remove

U_Help  DB      'Usage: HBIOS [/?|/U|/F|/K|/E|/P]', 0Dh, 0Ah
        DB      '       /?   - Help', 0Dh, 0Ah
        DB      '       /U   - Uninstall', 0Dh, 0Ah
        DB      '       /F:<font file name>', 0Dh,0Ah
        DB      '            - Specify Extended Font File', 0Dh,0Ah
        DB      '       /K:# - Set Han/Eng toggle key', 0Dh, 0Ah
        DB      '          1 - Right Alt, Right Ctrl', 0Dh, 0Ah
        DB      '          2 - Right Ctrl, Right Alt', 0Dh, 0Ah
        DB      '          3 - 103 Key Keyboard Defined', 0Dh, 0Ah
        DB      '          4 - 84 Key Keyboard (Alt-Shift, Ctrl-Shift)', 0Dh,0Ah
        DB      '          5 - 86 Key Keyboard Defined', 0Dh,0Ah
        DB      '          6 - Left Shift-Space, Left Ctrl-Space', 0Dh, 0Ah
        DB      '       /E   - English Card Only', 0Dh, 0Ah
        DB      '       /P   - Page 1 Only', 0Dh, 0Ah, '$'
W_Help  DB      ': HBIOS [/?|/U|/F|/K|/E|/P]', 0Dh, 0Ah
        DB      '       /?   - ', 0Dh, 0Ah
        DB      '       /U   -  ', 0Dh, 0Ah
        DB      '       /F:<  >', 0Dh,0Ah
        DB      '            -    ', 0Dh,0Ah
        DB      '       /K:# - /     ', 0Dh, 0Ah
        DB      '          1 -  Alt,  Ctrl', 0Dh, 0Ah
        DB      '          2 -  Ctrl,  Alt', 0Dh, 0Ah
        DB      '          3 - 103   ', 0Dh, 0Ah
        DB      '          4 - 84  (Alt-Shift, Ctrl-Shift)', 0Dh, 0Ah
        DB      '          5 - 86   ', 0Dh,0Ah
        DB      '          6 -  Shift-Space,  Ctrl-Space', 0Dh,0Ah
        DB      '       /E   -    ', 0Dh, 0Ah
        DB      '       /P   -  1Page ', 0Dh, 0Ah, '$'
C_Help  DB      'aw: HBIOS [/?|/U|/F|/K|/E|/P]', cr,lf
        DB      '       /?   - i', cr,lf
        DB      '       /U   - AA bA', cr,lf
        DB      '       /F:<i a q>', cr,lf
        DB      '            - w i a ', cr,lf
        DB      '       /K:# - ', cr,lf,'$'
        DB      '       /E   - English Card Only', 0Dh, 0Ah
        DB      '       /P   - Page 1 Only', 0Dh, 0Ah
msgHelp DW      U_Help, W_Help, C_Help

U_BadCmd    DB  'Invalid option parameter', cr,lf,'$'
W_BadCmd    DB  '  .', cr,lf,'$'
C_BadCmd    DB  ' ea iAsa.', cr,lf,'$'
msgBadCmd   DW  U_BadCmd, W_BadCmd, C_BadCmd

msgNotExist DB      'Cannot find resident HBIOS!', 0Dh,0Ah,'$'


ShowMultiMessage PROC    Near
;
; BX < Offset Table for Message
; DS = Unknown
;
        add     bl, [codePage]
        adc     bh, 0
        mov     dx, [bx]
        mov     ah, 9
        int     21h
        ret

ShowMultiMessage ENDP

endif   ; if ComFile


;------------------------------------------------------------------------
;   << SetMachineType >>
; FUNCTION = check XT or AT machine type, KBD type
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; SetMachineType(-/-)
;       {
;       Save ES;
;       ES = 0f000h;
;       if (ES:[0fffeh] == 0fch), [MachineType] = AtMachine;
;       ES = KbSeg
;       if (ES:[rKbFlag] == Ext10xKey), [KbStat] = [KbStat] || Ext10xKey;
;       Restore ES;
;       }
;
TmpPatBuf       label   byte
SetMachineType:
        push    es
        mov     ax,0f000h
        mov     es,ax
        mov     di,0fffeh
        cmp     byte ptr es:[di],0fch
        jnz     @f
        or      [MachineType],AtMachine
@@:
ASSUME  ES:KbSeg
        mov     ax,SEG KbSeg
        mov     es,ax
        test    es:[rKbFlag3],Ext10xKey
        jz      @f
        or      [KbStat],Ext10xKey
@@:
        pop     es
ASSUME  ES:CODE
        ret


;------------------------------------------------------------------------
;   << SetHeHjKey >>
; FUNCTION = set / key
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; SetHeHjKey(-/-)
;       {
;       if ([KbStat] == Ext10xKey)
;               {
;               [HeKey] = Def101HeKey;
;               [HjKey] = Def101HjKey;
;               }
;       else
;               {
;               if ([MachineType] == AtMachine)
;                       {
;                       [HeKey] = DefAtHeKey;
;                       [HjKey] = DefAtHjKey;
;                       }
;               else
;                       {
;                       [HeKey] = DefXtHeKey;
;                       [HjKey] = DefXtHjKey;
;                       }
;               }
;       }
;
SetHeHjKey:
if      not Kbd101On
        test    [KbStat],Ext10xKey
        jz     @f
        mov     al,DefAtKsHeKey
        mov     ah,DefKsHjKey
        test    [MachineType],AtMachine
        jnz     SetHeHjKeyRet
        mov     al,DefXtKsHeKey
        mov     ah,DefKsHjKey
        jmp     SetHeHjKeyRet
@@:
        mov     al,DefAtHeKey
        mov     ah,DefAtHjKey
        test    [MachineType],AtMachine
        jnz     SetHeHjKeyRet
        mov     al,DefXtHeKey
        mov     ah,DefXtHjKey
SetHeHjKeyRet:
else
        mov     al,Def101HeKey
        mov     ah,Def101HjKey
        test    [KbStat],Ext10xKey
        jnz     @f
        mov     al,DefAtHeKey
        mov     ah,DefAtHjKey
        test    [MachineType],AtMachine
        jnz     @f
        mov     al,DefXtHeKey
        mov     ah,DefXtHjKey
@@:
endif
        mov     [HeKey],al
        mov     [HjKey],ah
        ret


;------------------------------------------------------------------------
;   << CheckVideoCardType >>
; FUNCTION = video card type dual monitor  .
; INPUT   : none
; OUTPUT  : CARRY(set = invalid video card)
; PROTECT : SS, SP, DS, ES
;
; CheckVideoCardType(-/-)
;       {
;       DX = -1;
;       AX = 101ah;
;       BX = -1;
;       int 10h;                /* VGA function */
;       AX = 1a00h;
;       int 10h;                /* get card type */
;       if ((BX != -1) && (AL == 1ah) && (BL < 14) && (BH < 14))
;               {
;               switch(BL)
;                       {
;                       case 1:
;                               [Card1st] = MgaCard;
;                               break;
;                       case 2:
;                               [Card1st] = CgaCard || ColorMnt;
;                               break;
;                       case 4:
;                               [Card1st] = EgaCardC || ColorMnt;
;                               break;
;                       case 5:
;                               [Card1st] = EgaCardM;
;                               break;
;                       case 0bh:
;                               [Card1st] = VgaCard;
;                               break;
;                       case 0ah:
;                       case 0ch:
;                       default:
;                               [Card1st] = VgaCard || ColorMnt;
;                               break;
;                       case 7:
;                               [Card1st] = McgaCard;
;                               break;
;                       case 6:
;                       case 8:
;                               [Card1st] = McgaCard || ColorMnt;
;                       }
;               switch(BH)
;                       {
;                       case 1:
;                               [Card2nd] = MgaCard || DualMnt;
;                               break;
;                       case 2:
;                               [Card2nd] = CgaCard || ColorMnt || DualMnt;
;                               break;
;                       case 4:
;                               [Card2nd] = EgaCardC || ColorMnt || DualMnt;
;                               break;
;                       case 5:
;                               [Card2nd] = EgaCardM || DualMnt;
;                               break;
;                       case 0bh:
;                               [Card2nd] = VgaCard || DualMnt;
;                               break;
;                       case 0ah:
;                       case 0ch:
;                               [Card2nd] = VgaCard || ColorMnt || DualMnt;
;                               break;
;                       case 7:
;                               [Card2nd] = McgaCard || DualMnt;
;                               break;
;                       case 6:
;                       case 8:
;                               [Card2nd] = McgaCard || ColorMnt || DualMnt;
;                       default:
;                       }
;               return;
;               }
;       else
;               {
;               AH = 12h;
;               BX = 0ff10h;
;               int 10h;
;               if (BL == 0), return(CY);
;               if ((BL != 10h) || (!BL))
;                       {
;                       if (ES:[rEquip] == 30h)
;                               {
;                               [Card1st] = EgaCard;
;                               AH = 0b8h;
;                               if (CheckVram(AH/flag) == ZR)
;                                       [Card2nd] = CgaCard || ColorMnt || DualMnt;
;                               }
;                       else
;                               {
;                               [Card1st] = EgaCard || ColorMnt;
;                               AH = 0b0h;
;                               if (CheckVram(AH/flag) == ZR)
;                                       [Card2nd] = MgaCard || DualMnt;
;                               }
;                       }
;               if (ES:[rEquip] == 30h)
;                       {
;                       [Card1st] = MgaCard;
;                       AH = 0b8h;
;                       if (CheckVram(AH/flag) == ZR)
;                               [Card2nd] = CgaCard || ColorMnt || DualMnt;
;                       }
;               else
;                       {
;                       [Card1st] = CgaCard || ColorMnt;
;                       AH = 0b0h;
;                       if (CheckVram(AH/flag) == ZR)
;                               [Card2nd] = MgaCard || DualMnt;
;                       }
;               }
;       if ([Card2nd] == DualMnt)
;               [Card1st] = DualMnt;
;       }
;
; CheckVram(AH/flag)
;       {
;       Save DS;
;       AL = 0;
;       DS = AX;
;       AX = 55aah;
;       DI = 0;
;       xchg [DI+3],AX;
;       xchg [DI+3],AX;
;       xchg [DI+9],AX;
;       xchg [DI+9],AX;
;       Restore DS;
;       /* cmp AX,55aah */
;       }
;
CheckVideoCardType:
        mov     dx,-1
        mov     ax,101ah
        mov     bx,-1
        int     10h
        cmp     bx,-1
        jz      CheckEga
        mov     ax,1a00H
        int     10h
        cmp     al,1aH                  ; VGA?
        jne     CheckEga                ; jump if no
VgaBoard:
        cmp     bl,VgaModeTblLng
        jae     CheckEga
        cmp     bh,VgaModeTblLng
        jae     CheckEga
        mov     al,bh
        xor     bh,bh
        mov     dl,[bx+VgaModeTbl]
        cmp     dl,-1                   ; invalid vide card ?
        jnz     @f                      ; jump if no
        mov     dl,VgaCard or ColorMnt
        xor     dh,dh
        jmp     SetCardParm
@@:
        mov     bl,al
        mov     dh,[bx+VgaModeTbl]
        jmp     short SetCardParm
CheckEga:
        mov     ah,12H
        mov     bx,0ff10H
        int     10h
        cmp     bl,10H                  ; which video mode
        jz      CheckCga
        or      bl,bl
        jz      CheckCardErr            ; jump if installed 64KByte video memory only
        or      bh,bh                   ; color mode?
        jz      Check2ndEColor
        int     11h
        test    al,00110000b
        jpo     Set1CE2M
        jmp     short SetE1M2C
CheckCardErr:
        stc
        ret
Check2ndEColor:
        int     11h
        test    al,00110000b
        jpo     SetE1C2M
        jmp     short Set1ME2C
SetE1C2M:
        mov     dl,EgaCardC or ColorMnt
        mov     ah,0b0h
        call    CheckVRam
        jnz     SetCardParm
        mov     dh,MgaCard
        jmp     short SetCardParm
SetE1M2C:
        mov     dl,EgaCardM
        mov     ah,0b8h
        call    CheckVRam
        jnz     SetCardParm
        mov     dh,CgaCard or ColorMnt
        jmp     short SetCardParm
Set1CE2M:
        mov     dl,CgaCard or ColorMnt
        mov     ah,0b8h
        call    CheckVRam
        jnz     SetCardParm
        mov     dh,EgaCardM
        jmp     short SetCardParm
Set1ME2C:
        mov     dl,MgaCard
        mov     ah,0b0h
        call    CheckVRam
        jnz     SetCardParm
        mov     dh,EgaCardC or ColorMnt
        jmp     short SetCardParm
CheckCga:
        int     11h
        test    al,30h
        jpo     Check2ndMono
        mov     dl,MgaCard
        mov     ah,0b8h
        call    CheckVRam
        jnz     SetCardParm
        mov     dh,CgaCard or ColorMnt
        jmp     short SetCardParm
Check2ndMono:
        mov     dl,CgaCard or ColorMnt
        mov     ah,0b0h
        call    CheckVRam
        jnz     SetCardParm
        mov     dh,MgaCard
SetCardParm:
        cmp     dh,-1
        jz      @f
        or      dl,DualMnt
        or      dh,DualMnt
@@:
        mov     [Card1st],dl
        mov     [Card2nd],0
        test    dl,DualMnt
        jz      @f
        mov     [Card2nd],dh
@@:
        clc
        ret
VgaModeTbl      db      -1                      ; 0
                db      MgaCard                 ; 1
                db      CgaCard or ColorMnt     ; 2
                db      -1                      ; 3
                db      EgaCardC or ColorMnt    ; 4
                db      EgaCardM                ; 5
                db      McgaCard or ColorMnt    ; 6
                db      McgaCard                ; 7
                db      McgaCard or ColorMnt    ; 8
                db      -1                      ; 9
                db      VgaCard or ColorMnt     ; A
                db      VgaCard                 ; B
                db      VgaCard or ColorMnt     ; C
VgaModeTblLng = $-VgaModeTbl
CheckVram:
        push    ds
        xor     al,al
        mov     ds,ax
        mov     ax,55aah
        xor     di,di
        xchg    [di+3],ax
        xchg    [di+3],ax
        xchg    [di+7],ax
        xchg    [di+7],ax
        cmp     ax,55aah
        pop     ds
        ret


;------------------------------------------------------------------------
;   << CheckHanCard >>
; FUNCTION =  video card 
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; CheckHanCard(-/-)
;       {
;       switch([Card1st])
;               {
;               case MgaCard :
;                       if (MgaInit(-/flag) == NC)
;                               {
;                               [Card1st] = [Card1st] || HanCard;
;                               [GetHan1st] = AX;
;                               [GetUdc1st] = AX;
;                               [PutUdc1st] = BX;
;                               [HanOn1st] = CX;
;                               [HanOff1st] = DX;
;                               }
;                       break;
;               case CgaCard :
;                       if (CgaInit(-/flag) == NC)
;                               {
;                               [Card1st] = [Card1st] || HanCard;
;                               [GetHan1st] = AX;
;                               [GetUdc1st] = AX;
;                               [PutUdc1st] = BX;
;                               [HanOn1st] = CX;
;                               [HanOff1st] = DX;
;                               }
;                       break;
;               case EgaCardM :
;               case EgaCardC :
;                       if (EgaInit(-/flag) == NC)
;                               {
;                               [Card1st] = [Card1st] || HanCard;
;                               [GetHan1st] = AX;
;                               [GetUdc1st] = AX;
;                               [PutUdc1st] = BX;
;                               [HanOn1st] = CX;
;                               [HanOff1st] = DX;
;                               }
;                       break;
;               case McgaCard :
;               case VgaCard :
;                       if (VgaInit(-/flag) == NC)
;                               {
;                               [Card1st] = [Card1st] || HanCard;
;                               [GetHan1st] = AX;
;                               [GetUdc1st] = AX;
;                               [PutUdc1st] = BX;
;                               [HanOn1st] = CX;
;                               [HanOff1st] = DX;
;                               }
;               }
;       switch([Card2nd])
;               {
;               case MgaCard :
;                       if (MgaInit(-/flag) == NC)
;                               {
;                               [Card2nd] = [Card2nd] || HanCard;
;                               [GetHan2nd] = AX;
;                               [GetUdc2nd] = AX;
;                               [PutUdc2nd] = BX;
;                               [HanOn2nd] = CX;
;                               [HanOff2nd] = DX;
;                               }
;                       break;
;               case CgaCard :
;                       if (CgaInit(-/flag) == NC)
;                               {
;                               [Card2nd] = [Card2nd] || HanCard;
;                               [GetHan2nd] = AX;
;                               [GetUdc2nd] = AX;
;                               [PutUdc2nd] = BX;
;                               [HanOn2nd] = CX;
;                               [HanOff2nd] = DX;
;                               }
;                       break;
;               case EgaCardM :
;               case EgaCardC :
;                       if (EgaInit(-/flag) == NC)
;                               {
;                               [Card2nd] = [Card2nd] || HanCard;
;                               [GetHan2nd] = AX;
;                               [GetUdc2nd] = AX;
;                               [PutUdc2nd] = BX;
;                               [HanOn2nd] = CX;
;                               [HanOff2nd] = DX;
;                               }
;                       break;
;               case McgaCard :
;               case VgaCard :
;                       if (VgaInit(-/flag) == NC)
;                               {
;                               [Card2nd] = [Card2nd] || HanCard;
;                               [GetHan2nd] = AX;
;                               [GetUdc2nd] = AX;
;                               [PutUdc2nd] = BX;
;                               [HanOn2nd] = CX;
;                               [HanOff2nd] = DX;
;                               }
;               }
;       if (([Card1st] != HanCard) && ([Card2nd] != HanCard))
;               {
;               if (FontInit(-/flag) == NC)
;                       {
;                       [Card1st] = [Card1st] || FontCard;
;                       [Card2nd] = [Card2nd] || FontCard;
;                       [HjStat] = [HjStat] || HjLoaded;
;                       [GetHan1st] = AX;
;                       [GetUdc1st] = AX;
;                       [PutUdc1st] = BX;
;                       [HanOn1st] = CX;
;                       [HanOff1st] = DX;
;                       [GetHan2nd] = AX;
;                       [GetUdc2nd] = AX;
;                       [PutUdc2nd] = BX;
;                       [HanOn2nd] = CX;
;                       [HanOff2nd] = DX;
;                       }
;               }
;       if (([Card1st] == HanCard) || ([Card2nd] == HanCard))
;               [HjStat] = [HjStat] || HjLoaded;
;       if (([Card1st] != HanCard) && ([Card2nd] == HanCard))
;               {
;               [GetHan1st] = [GetHan2nd];
;               [GetUdc1st] = [GetUdc2nd];
;               [PutUdc1st] = [PutUdc2nd];
;               [HanOn1st] = [HanOn2nd];
;               [HanOff1st] = [HanOff2nd];
;               }
;       if (([Card1st] == HanCard) && ([Card2nd] != HanCard))
;               {
;               [GetHan2nd] = [GetHan1st];
;               [GetUdc2nd] = [GetUdc1st];
;               [PutUdc2nd] = [PutUdc1st];
;               [HanOn2nd] = [HanOn1st];
;               [HanOff2nd] = [HanOff1st];
;               }
;       }
;
extrn   GetFontMga:near, PutFontMga:near, HanOnMga:near, HanOffMga:near
extrn   GetFontCga:near, PutFontCga:near, HanOnCga:near, HanOffCga:near
extrn   GetFontEga:near, PutFontEga:near, HanOnEga:near, HanOffEga:near
extrn   GetFontFont:near, PutFontFont:near, HanOnFont:near, HanOffFont:near
CheckHanCard:
        mov     bl,[Card1st]
        and     bx,CardType
        call    [bx+HanInitTbl]
        jc      @f
        or      [Card1st],HanCard
        mov     [GetHan1st],ax
        mov     [GetUdc1st],ax
        mov     [PutUdc1st],bx
        mov     [HanOn1st],cx
        mov     [HanOff1st],dx
@@:
        test    [Card1st],DualMnt
        jz      @f
        mov     bl,[Card2nd]
        and     bx,CardType
        call    [bx+HanInitTbl]
        jc      @f
        or      [Card2nd],HanCard
        mov     [GetHan2nd],ax
        mov     [GetUdc2nd],ax
        mov     [PutUdc2nd],bx
        mov     [HanOn2nd],cx
        mov     [HanOff2nd],dx
@@:
        test    [Card1st],HanCard
        jnz     @f
        test    [Card2nd],HanCard
        jnz     @f
        call    FontInit
        jc      @f
        or      [Card1st],FontCard
        or      [Card2nd],FontCard
        or      [HjStat],HjLoaded
        mov     [GetHan1st],ax
        mov     [GetUdc1st],ax
        mov     [PutUdc1st],bx
        mov     [HanOn1st],cx
        mov     [HanOff1st],dx
        mov     [GetHan2nd],ax
        mov     [GetUdc2nd],ax
        mov     [PutUdc2nd],bx
        mov     [HanOn2nd],cx
        mov     [HanOff2nd],dx
@@:
        mov     al,[Card1st]
        or      al,[Card2nd]
        test    al,HanCard
        jz      @f
        or      [HjStat],HjLoaded or UdcArea
@@:
        xor     bx,bx
        test    [Card1st],HanCard
        jz      @f
        or      bx,00000010b
@@:
        test    [Card2nd],HanCard
        jz      @f
        or      bx,00000100b
@@:
        call    [bx+SetFontPtrTbl]
        ret
SetFontPtrTbl   label   word
                dw      offset NoFont   ; 00
                dw      offset C1to2    ; 01
                dw      offset C2to1    ; 10
                dw      offset NoFont   ; 11
C1to2:
        mov     ax,[GetHan1st]
        mov     [GetHan2nd],ax
        mov     ax,[GetUdc1st]
        mov     [GetUdc2nd],ax
        mov     ax,[PutUdc1st]
        mov     [PutUdc2nd],ax
        mov     ax,[HanOn1st]
        mov     [HanOn2nd],ax
        mov     ax,[HanOff1st]
        mov     [HanOff2nd],ax
NoFont:
        ret
C2to1:
        mov     ax,[GetHan2nd]
        mov     [GetHan1st],ax
        mov     ax,[GetUdc2nd]
        mov     [GetUdc1st],ax
        mov     ax,[PutUdc2nd]
        mov     [PutUdc1st],ax
        mov     ax,[HanOn2nd]
        mov     [HanOn1st],ax
        mov     ax,[HanOff2nd]
        mov     [HanOff1st],ax
        ret


;------------------------------------------------------------------------
HanInitTbl      label   word
                dw      offset MgaInit
                dw      offset CgaInit
                dw      offset EgaInit
                dw      offset EgaInit
                dw      offset VgaInit
                dw      offset VgaInit

;------------------------------------------------------------------------
MgaInit:
if      AltHotKey
if      AtiVga
        call    CheckAti
        jc      @f
        ret
@@:
endif   ; if AtiVga
endif   ; AltHotKey
        mov     di,offset TmpPatBuf
        push    di
        push    ds
        mov     cx,0a1a2h
        call    GetFontMga
        pop     ds
        pop     si
        mov     cx,32/2
        xor     dx,dx
@@:
        lodsw
        add     dx,ax
        loop    @b
        cmp     dx,30h
        jz      @f
        cmp     dx,0c0h
        jz      @f
        stc
        ret
@@:
        mov     ax,offset GetFontMga
        mov     bx,offset PutFontMga
        mov     cx,offset HanOnMga
        mov     dx,offset HanOffMga
        ret

;------------------------------------------------------------------------
CgaInit:
        mov     di,offset TmpPatBuf
        push    di
        push    ds
        mov     cx,0a1a2h
        call    GetFontCga
        pop     ds
        pop     si
        mov     cx,32/2
        xor     dx,dx
@@:
        lodsw
        add     dx,ax
        loop    @b
        cmp     dx,30h
        jz      @f
        stc
        ret
@@:
        mov     ax,offset GetFontCga
        mov     bx,offset PutFontCga
        mov     cx,offset HanOnCga
        mov     dx,offset HanOffCga
        ret

;------------------------------------------------------------------------
EgaInit:
VgaInit:
if      ChkW32Trident
        call    CheckTrident
endif   ;   ChkW32Trident
        test    [KseCard],PassHanCdCheck
        jz      @f
        stc
        ret
@@:
if      AtiVga
        call    CheckAti
        jnc     @f
endif   ; if AtiVga
if      KseVga
        call    CheckKasan
        jnc     @f
endif   ; if KseVga
if      ChkW32Trident
        call    CheckW32Tseng
endif   ;   ChkW32Trident
@@:
if      not (KseVga or AtiVga)
        stc
endif   ; if not (KseVga or AtiVga)
        ret

if      ChkW32Trident
CheckW32Tseng:
        push    ds
        mov     ax,0c000h
        mov     ds,ax
        mov     bx,0076h
        cmp     ds:[bx],'sT'
        jnz     @f
        add     bx,2
        cmp     ds:[bx],'ne'
        jnz     @f
        or      cs:[KseCard],Page1Fix
@@:
        pop     ds
        stc
        ret

CheckTrident:
        push    ds
        mov     ax,0c000h
        mov     ds,ax
        mov     bx,0065h
        cmp     ds:[bx],'RT'
        jnz     @f
        add     bx,2
        cmp     ds:[bx],'DI'
        jnz     @f
        or      cs:[KseCard],PassHanCdCheck
@@:
        pop     ds
        ret
endif   ;   ChkW32Trident

if      KseVga
extrn   KseGetFontVga:near, KsePutFontVga:near, KseHanOnVga:near
extrn   KseHanOffVga:near, KseCard:byte
CheckKasan:
        mov     dx,258h
        mov     ax,0aaf1h               ; sample data
        out     dx,ax
        mov     ax,002f2h               ; init F2-02
        out     dx,ax
        mov     al,0f1h
        out     dx,al
        inc     dx
        in      al,dx
        cmp     al,0aah                 ; GaSan video card ?
        jz      @f
        jmp     NoneKasan
@@:
        dec     dl
        mov     ax,050f1h               ; init F1-50
        out     dx,ax
        mov     ax,006f3h               ; init F3-06
        out     dx,ax
        mov     ax,0fff5h               ; init F5-FF
        out     dx,ax
        mov     ax,0c9f6h               ; init F6-C9
        out     dx,ax
        mov     ax,0fef7h               ; init F7-FE
        out     dx,ax
        mov     al,0f4h
        out     dx,al
        inc     dx
        in      al,dx
        and     al,11110111b            ; release KEY bit(FONT)
        out     dx,al
        dec     dl
        mov     al,0f0h
        out     dx,al
        inc     dx
        in      al,dx
        or      al,00000011b            ; UDC write operation
        out     dx,al
        mov     dl,56h
        mov     al,80h
        out     dx,al                   ; set UDC write ready
        mov     bx,0c9a1h               ; UDC code
        mov     ax,bx
        shl     al,1
        shr     ax,1
        mov     cx,32
        mul     cx
        mov     cx,dx
        mov     dx,250h                 ; font address register 250
        mov     bl,al
        out     dx,al
        inc     dl                      ; font address register 251
        mov     al,ah
        out     dx,al
        inc     dl                      ; font address register 252
        mov     al,cl
        out     dx,al
        mov     dl,54h                  ; font data register 254
        mov     al,55h                  ; sample data
        out     dx,al
        mov     dl,56h
        out     dx,al                   ; write data to UDC RAM
        mov     dl,54h
        xor     al,al
        out     dx,al
        mov     dl,58h
        mov     al,0f0h
        out     dx,al
        inc     dl
        in      al,dx
        and     al,11111110b            ; set font read operation
        out     dx,al
        mov     dl,54h
        in      al,dx                   ; read sample data
        mov     ah,20h
        mov     dl,58h
        mov     al,0f0h
        out     dx,al
        inc     dl
        in      al,dx
        and     al,11111100b
        or      al,ah
        out     dx,al
        or      [KseCard],00000001b
        clc
        jmp     CheckKasanRet
NoneKasan:
        stc
        ret
CheckKasanRet:
        mov     si,offset KseVga23
        mov     di,offset Mode23TextV
        mov     cx,64/2
        rep movsw
        mov     si,offset KseVga23
        mov     di,offset Mode2TextE
        mov     cl,64/2
        rep movsw
        mov     si,offset KseVga7
        mov     di,offset Mode7TextV
        mov     cl,64/2
        rep movsw
        mov     si,offset KseVga7
        mov     di,offset Mode7TextE
        mov     cl,64/2
        rep movsw
if      AltHotKey
        mov     ax,01a00h
        int     10h
        cmp     bl,5
        jnz     @f
        or      [KseCard],MonoMntC
        mov     si,offset KseMda7
        mov     di,offset Mode7TextE
        mov     cl,64/2
        rep movsw
@@:
endif   ;  AltHotKey
        mov     ax,offset KseGetFontVga
        mov     bx,offset KsePutFontVga
        mov     cx,offset KseHanOnVga
        mov     dx,offset KseHanOffVga
        ret
KseVga23        label   byte
        db 50h,18h,10h,00h,10h,00h,03h,00h,02h,063h
        db 61h,52h,53h,23h,57h,06fh,0bfh,01fh,0,04fh,0eh,0fh,0,0,0,0
        db  9ch,00eh,08fh,28h,1fh,96h,0b9h,0a3h,0ffh
        db 0,01h,02h,03h,04h,05h,14h,07h,38h,39h,3Ah,3Bh,3Ch,3Dh,3Eh,3Fh
        db  0Ch,00h,0Fh,0;8h
        db 00h,00h,00h,00h,00h,10h,0Eh,00h,0FFh
KseVga7         label   byte
        db 50h,18h,10h,00h,10h,00h,03h,00h,02h,062h
        db 61h,52h,53h,23h,57h,06Fh,0bfh,01fh,0,04fh,0eh,0fh,0,0,0,0
        db  9ch,00eh,08fh,28h,0fh,96h,0b9h,0a3h,0ffh
        db 0,8,8,8,8,8,8,8,10h,18h,18h,18h,18h,18h,18h,18h
        db  0Eh,0,0Fh,0;8h
        db 00h,00h,00h,00h,00h,10h,0Ah,00h,0FFh
KseMda7         label   byte
        db 50h,18h,10h,00h,10h,00h,03h,00h,02h,0A6h
        db 5Fh,52h,55h,25h,53h,0E3h,0B0h,01fh,0,00Fh,0eh,060h,0,0,0,0
        db  90h,020h,08fh,28h,0Dh,90h,000h,0a3h,0ffh
        db 0,8,8,8,8,8,8,8,10h,18h,18h,18h,18h,18h,18h,18h
        db  0Eh,0,0Fh,0;8h
        db 00h,00h,00h,00h,00h,10h,0Ah,00h,0FFh
endif   ; if KseVga

if      AtiVga
extrn   AtiGetFontVga:near, AtiPutFontVga:near, AtiHanOnVga:near
extrn   AtiHanOffVga:near, KseCard:byte
CheckAti:

        mov     cx,0a1a2h
        mov     dx,3ddh
        mov     ah,ch
        mov     al,10h
        out     dx,ax
        mov     ah,cl
        mov     al,8
        out     dx,ax
        mov     ax,201h
        mov     cl,4
        cmp     ch,0feh                 ; assume FExx
        jnz     @f
        mov     ah,6                    ; set C9xx
        mov     cl,2
@@:
        cmp     ch,0c9h
        jnz     @f
        mov     cl,2
@@:
        out     dx,ax
        mov     al,cl
        out     dx,al
        inc     dx
        xor     bx,bx
        mov     cx,16
@@:
        in      al,dx
        add     bl,al
        adc     bh,0
        inc     di
        loop    @b
        mov     cl,16
@@:
        inc     di
        in      al,dx
        add     bh,al
        loop    @b
        dec     dx
        mov     ax,1
        out     dx,ax
        cmp     bx,8004h
        jnz     NoneAtiVga
        mov     dx,3ddh
        mov     ax,101h
        out     dx,ax
        mov     dx,1ceh
        mov     al,0bfh
        mov     ah,al
        out     dx,al
        inc     dx
        in      al,dx
        or      al,00100000b
        dec     dx
        xchg    al,ah
        out     dx,ax
        mov     dx,1ceh
        mov     al,0bbh
        out     dx,al
        inc     dx
        in      al,dx
        mov     bh,al
        dec     dx
        mov     ax,55bbh
        out     dx,ax
        out     dx,al
        inc     dx
        in      al,dx
        mov     bl,al
        dec     dx
        mov     ax,0aabbh
        out     dx,ax
        out     dx,al
        inc     dx
        in      al,dx
        mov     ah,bl
        dec     dx
        cmp     ax,55aah
        jz      @f
NoneAtiVga:
        stc
        ret
@@:
        mov     al,0bbh                 ;restore register value
        mov     ah,bh
        out     dx,ax
        call    AtiHanOffVga
        mov     si,offset AtiVga23
        mov     di,offset Mode23TextV
        mov     cx,64/2
        rep movsw
        mov     si,offset AtiVga23
        mov     di,offset Mode2TextE
        mov     cl,64/2
        rep movsw
        mov     si,offset AtiVga7
        mov     di,offset Mode7TextV
        mov     cl,64/2
        rep movsw
        mov     si,offset AtiVga7
        mov     di,offset Mode7TextE
        mov     cl,64/2
        rep movsw
        mov     ax,01a00h
        int     10h
        cmp     bl,5
        jnz     @f
        or      [KseCard],MonoMntC
@@:
        mov     ax,offset AtiGetFontVga
        mov     bx,offset AtiPutFontVga
        mov     cx,offset AtiHanOnVga
        mov     dx,offset AtiHanOffVga
        clc
        ret
AtiVga23        label   byte
        db 80,24,16,0,10H,  1,3,0,2,  063H
        db 5Fh,4Fh,50h,82h,54h,80h,0BFh,1Fh,0,4Fh,0DH,0EH,0,0,0,0
        db  9Ch,0Eh,8Fh,28h,1FH,96h,0B9h,0A3h,0FFh
        db 0,1,2,3,4,5,14H,7,38H,39H,3AH,3BH,3CH,3DH,3EH,3FH
        db  0CH,0,0FH,0;8
        db 0,0,0,0,0,10H,0EH,0,0FFH
AtiVga7         label   byte
        db 80,24,16,0,10H,  1,3,0,2,  062h
        db 5Fh,4Fh,50h,82h,54h,80h,0BFh,1Fh,0,4Fh,0DH,0EH,0,0,0,0
        db  9Ch,0Eh,8Fh,28h,1FH,96h,0B9h,0A3h,0FFh
        db 0,8,8,8,8,8,8,8,10H,18H,18H,18H,18H,18H,18H,18H
        db  0EH,0,0FH,0;8
        db 0,0,0,0,0,10H,0AH,0,0FFH
endif   ; if AtiVga


;------------------------------------------------------------------------
FontInit:
        mov     ax,offset GetFontFont
        mov     bx,offset PutFontFont
        mov     cx,offset HanOnFont
        mov     dx,offset HanOffFont
        stc
        ret


;------------------------------------------------------------------------
;   << GetConfigFile >>
; FUNCTION = "HECON.CFG" file    
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; GetConfigFile(-/-)
;       {
;       /* open 'HECON.CFG' file */
;       /* read file to end of file */
;       /* copy data */
;       }
;
GetConfigFile:
        push    ds
        call    SetPreConfig
        mov     ah,19h
        int     21h
        cmp     al,2
        jbe     @f
        mov     al,2
@@:
        add     al,'A'
        mov     si,offset CfgFilename
        mov     [si],al                 ; set drive latter
if      not GetSwitch
        mov     ax,3d00h
        mov     dx,offset CfgFilename
        int     21h
        jc      GetConfigFileEnd
        mov     bx,ax
        mov     ah,3fh
        mov     cx,100
        mov     dx,offset EndOfInit
        int     21h
        jc      GetConfigFileClose
        mov     si,dx
        mov     di,offset CfgFilename
        add     di,3
        mov     cx,9
        rep cmpsb
        jnz     GetConfigFileClose
        mov     si,dx
        add     si,sFont
        mov     di,offset FontFileName
        mov     cx,StringLng
        rep movsb
        mov     si,dx
        mov     al,[si].sCodeType
if      hdos60
        and     al,WSung or Chab or WSung7 or HangeulMode
        and     [CodeStat],not (WSung or Chab or WSung7 or HangeulMode)
else    ;hdos60
        and     al,WSung or Chab or WSung7 or HangeulMode or ChabLoad
        and     [CodeStat],not (WSung or Chab or WSung7 or HangeulMode or ChabLoad)
endif   ;   hdos60
        or      [CodeStat],al
        mov     al,[si].sMemory
        and     al,HiMem or EmsMem or ExtMem or RealMem
        and     [MemStat],not (HiMem or EmsMem or ExtMem or RealMem)
        or      [MemStat],al
        mov     al,[si].sKbdType
        and     al,SetKbd101
        and     [KbdType],not SetKbd101
        or      [KbdType],al
        mov     al,[si].sHeKey
        or      al,al
        jz      @f
        or      [KbStat],UserDefineKey
        mov     [HeKey],al
@@:
        mov     al,[si].sHjKey
        or      al,al
        jz      @f
        or      [KbStat],UserDefineKey
        mov     [HjKey],al
@@:
        mov     al,[si].sPrinterType
        mov     [Printer],al
GetConfigFileClose:
        mov     ah,3eh
        int     21h
else
if      ComFile
        mov     si,81h
else
        lds     si,[PtrSav]
        lds     si,[si].InitBpb         ; ds:si points to CONFIG.SYS
endif   ; ComFile
DBGNum 1
        mov     di,offset FontFileName
@gcfLoop:
        lodsb
DBGNum ax
        cmp     al,CR                   ; terminate with CR or LF
        je      GetConfigFileEndj
        cmp     al,LF
        je      GetConfigFileEndj
        cmp     al,9
        je      GetConfigFileEndj
        Cmp     AL,"/"                  ; MS-DOS 5.00
        jnz     @gcfLoop

        lodsb
        or      al, 20h
        cmp     al, 'f'                  ; file spec?
        jne     @f
        call    @fontFileOption
        jmp     @gcfLoop
@@:
        cmp     al, 'k'
        jne     @f
        call    ParsKeyboard
        jmp     @gcfLoop
@@:
if      not ChkW32Trident
        cmp     al, 'e'
        jne     @f
        or      [KseCard],PassHanCdCheck
        jmp     @gcfLoop
@@:
        cmp     al, 'p'
        jne     @f
        or      [KseCard],Page1Fix
        jmp     @gcfLoop
@@:
endif   ;   not ChkW32Trident
        call    ParsSkipOptions
        jmp     @gcfLoop
GetConfigFileEndj:
        jmp     GetConfigFileEnd

@fontFileOption:
        lodsb
        cmp     al,CR                   ; ill-terminate with CR or LF
        je      GetConfigFileEnd
        cmp     al,LF
        je      GetConfigFileEnd
        cmp     al," "                  ; skip delimiter " ", tab
        je      @b
        cmp     al,":"                  ; "/F:"?
        jne     GetConfigFileEnd
GetParmsFileSpec:
        lodsb
        cmp     al,CR                   ; ill-terminate with CR or LF
        je      GetConfigFileEnd
        cmp     al,LF
        je      GetConfigFileEnd
        cmp     al," "                  ; skip delimiter " ", tab
        je      GetParmsFileSpec
        cmp     al,9
        je      GetConfigFileEnd
;       je      GetParmsFileSpec
        mov     ah,al
        lodsb
        xchg    ah,al
        cmp     ah,":"                  ; is drive name given?
        je      HaveDrvName             ; jump if so
;       inc     di
;       inc     di
HaveDrvName:
        stosw
@@:
        lodsb
        cmp     al,CR                   ; terminate with CR or LF
        je      ParseBpbRetJ
        cmp     al,LF
        je      ParseBpbRetJ
        cmp     al," "                  ; skip delimiter " ", tab, ","
        je      ParseBpbRetJ
        cmp     al,9
        je      ParseBpbRetJ
        stosb
        jmp     @b
ParseBpbRetJ:
        sub     ax,ax
        stosw
        ret
endif
GetConfigFileEnd:
        test    [KbStat],UserDefineKey
        jnz     @f
        test    [KbdType],SetKbd101
        jz      @f
        mov     [HeKey],Def101HeKey
        mov     [HjKey],Def101HjKey
@@:
        pop     ds
        ret
CfgFilename     db      'C:\HECON.CFG',0

SetPreConfig:
        and     [CodeStat],not (WSung or Chab or WSung7 or HangeulMode or ChabLoad)
        or      [CodeStat],WSung or HangeulMode or ChabLoad
        and     [MemStat],not (HiMem or EmsMem or ExtMem or RealMem)
        and     [KbdType],not SetKbd101
        and     [Printer],11111000b
        ret



;------------------------------------------------------------------------
extrn   EscCode2Tbl:word, EscCode3Tbl:word, EscCodeNTbl:word, EscCode4Tbl:word
extrn   EscCode2Addr:word, EscCode3Addr:word, EscCodeNAddr:word, EscCode4Addr:word
InstPrinter:
        test    [CodeStat],ChabLoad
        jz      InstPrinterEnd
        mov     al,[Printer]
        xor     ah,ah
        mov     si,ax
        shl     si,1
        mov     ax,[si].EscCode2Tbl
        mov     [EscCode2Addr],ax
        mov     ax,[si].EscCode3Tbl
        mov     [EscCode3Addr],ax
        mov     ax,[si].EscCodeNTbl
        mov     [EscCodeNAddr],ax
        mov     ax,[si].EscCode4Tbl
        mov     [EscCode4Addr],ax
InstPrinterEnd:
        ret


;------------------------------------------------------------------------
;   << SetVideoParms >>
; FUNCTION = video parm 
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; SetVideoParms(-/-)
;       {
;       }
;
SetVideoParms:
        mov     al,[Card1st]
        call    SetVdParmsDo
        test    [Card1st],DualMnt
        jz      @f
        mov     al,[Card2nd]
        call    SetVdParmsDo
@@:
        ret
SetVdParmsDo:
        mov     dl,al
        and     al,CardType
        xor     ah,ah
        mov     si,ax
        jmp     [si+SetVdParmsTbl]
SetVdParmsTbl   label   word
                dw      offset MParms
                dw      offset CParms
                dw      offset EParms
                dw      offset EParms
                dw      offset VParms
                dw      offset VParms
MParms:
        test    dl,HanCard
        jnz     @f
        mov     si,offset Mda70H
        mov     di,offset Mda07H
        mov     cx,10/2
        rep movsw
        mov     ax,0e0dh
        stosw
        inc     si
        inc     si
        movsw
        movsw
        mov     di,offset RegSize
        add     di,6
        mov     ax,8000h
        stosw
        mov     di,offset CrtcSet
        add     di,7
        mov     al,0ah
        test    dl,DualMnt
        jnz     MgaTextEmu
        mov     al,8ah
MgaTextEmu:
        stosb
@@:
        ret
CParms:
        test    dl,HanCard
        jnz     @f
        mov     si,offset Cga40H
        mov     di,offset Cga23H
        mov     cx,10/2
        rep movsw
        mov     ax,706h
        stosw
        inc     si
        inc     si
        movsw
        movsw
        mov     di,offset RegSize
        add     di,4
        mov     ax,8000h
        stosw
        mov     di,offset CrtcSet
        add     di,6
        mov     al,1eh
        stosb
@@:
        ret
EParms:
        call    InstallVdParmsPtr
        xor     ch,ch
        mov     si,offset Mode7Ega
        mov     bx,offset Mode3Ega
        test    dl,HanCard
        jz      @f
        mov     si,offset Mode7TextE
        mov     bx,offset Mode2TextE
@@:
        mov     di,offset Mode7
        mov     cl,64/2
        rep movsw
        mov     si,bx
        mov     di,offset Mode2E
        mov     cl,64/2
        rep movsw
        test    dl,DualMnt
        jz      @f
        mov     di,offset Mode7Ega
        mov     [di].cMap,9
        mov     di,offset Mode3Ega
        mov     [di].cMap,0dh
        test    dl,HanCard
        jnz     @f
        mov     di,offset Mode7
        mov     [di].cMap,9
        mov     di,offset Mode2E
        mov     [di].cMap,0dh
@@:
        mov     si,offset Mode2E
        mov     di,offset Mode3E
        mov     cl,64/2
        rep movsw
        ret
VParms:
        call    InstallVdParmsPtr
        xor     ch,ch

IFDEF _X86_             ; On ALPHA, doesn't have full screen mode
        mov     si,offset Mode7TextV
        mov     bx,offset Mode23TextV
        test    dl,HanCard
        jnz     @f

                ;
                ; Hangul Video card is not found.
                ; HBIOS should emulate Hangul Video card for display Hangul character.
                ; We use graphic video mode.
                ;
                mov     si,offset Mode07V
                mov     bx,offset Mode3V

                push    es
                push    di
                les     di,dword ptr cs:[vdm_info.windowed_add]
                mov     al,es:[di]
                pop     es
                pop     di

                cmp     al,0        ; windowed mode ?
                                    ; 0 = windowed, 1 = full screen
                jne     @f

ENDIF   ; _X86_
                        ;
                        ; Windowed mode doesn't need for set graphics video mode.
                        ; Becase console window can display Hangul character without HBIOS.
                        ;

                        mov     si,offset Mode7TextV
                        mov     bx,offset Mode23TextV

@@:
        mov     di,offset Mode07
        mov     cl,64/2
        rep movsw
        mov     si,bx
        mov     di,offset Mode23
        mov     cl,64/2
        rep movsw
        test    dl,DualMnt
        jz      @f
        mov     di,offset Mode07V
        mov     [di].cMap,9
        mov     di,offset Mode3V
        mov     [di].cMap,0dh
        test    dl,DualMnt
        jnz     @f
        mov     di,offset Mode07
        mov     [di].cMap,9
        mov     di,offset Mode23
        mov     [di].cMap,0dh
@@:
        ret
InstallVdParmsPtr:
        push    es
        push    ds
        xor     ax,ax
        mov     ds,ax
ASSUME  DS:DATA
        les     di,[rSavePtr]
        mov     word ptr cs:[OldSavePtr],di
        mov     word ptr cs:[OldSavePtr+2],es
        mov     word ptr [rSavePtr],offset HanSavePtr
        mov     word ptr [rSavePtr+2],cs
        mov     si,es
        mov     ds,si
        mov     si,di
        mov     di,cs
        mov     es,di
        mov     di,offset HanSavePtr
        mov     cx,7*2
        rep     movsw
        mov     word ptr cs:[HanSavePtr],offset VideoParmsTbl
        mov     word ptr cs:[HanSavePtr+2],cs
        pop     ds
        pop     es
ASSUME  DS:CODE
        push    ds
        lds     si,[OldSavePtr]
        lds     si,[si]
        mov     di,offset VideoParmsTbl
        test    cs:[Card1st],00001000b
        jnz     @f
        mov     cx,64*23/2
        rep movsw
        pop     ds
        ret
@@:
        mov     cx,64*8/2
        rep movsw
        add     si,64*3
        add     di,64*3
        mov     cx,64*18/2
        rep movsw
        pop     ds
        ret
;------------------------------------------------------------------------
; text VGA mode 7
Mode7TextV      label   byte
        db 80,24,16,0,10H,  1,3,0,2,  062h
        db 5Fh,4Fh,50h,82h,54h,80h,0BFh,1Fh,0,4Fh,0DH,0EH,0,0,0,0
        db  9Ch,0Eh,8Fh,28h,1FH,96h,0B9h,0A3h,0FFh
        db 0,8,8,8,8,8,8,8,10H,18H,18H,18H,18H,18H,18H,18H
        db  0EH,0,0FH,8
        db 0,0,0,0,0,10H,0AH,0,0FFH

Mode23TextV     label   byte
        db 80,24,16,0,10H,  1,3,0,2,  063H
        db 5Fh,4Fh,50h,82h,54h,80h,0BFh,1Fh,0,4Fh,0DH,0EH,0,0,0,0
        db  9Ch,0Eh,8Fh,28h,1FH,96h,0B9h,0A3h,0FFh
        db 0,1,2,3,4,5,14H,7,38H,39H,3AH,3BH,3CH,3DH,3EH,3FH
        db  0CH,0,0FH,8
        db 0,0,0,0,0,10H,0EH,0,0FFH

; text EGA mode 7
Mode7TextE      label   byte
        db 80,24,16,0,10h,  1,3,0,3,  0A6h
        db 5Bh,4Fh,53h,37h,52h,00h,09Fh,1Fh,0,0,0DH,0EH,0,0,0,0 ; crtc
        db  90h,2Bh,8Fh,28h,0FH,95h,1Dh,0E3h,0FFh               ; crtc
        db 0,8,8,8,8,8,8,8,10h,18h,18h,18h,18h,18h,18h,18h
        db  0EH,0,0FH,8
        db 0,0,0,0,0,10H,0Ah,0,0FFh

Mode2TextE      label   byte
        db 80,24,16,0,10h,  1,3,0,3,  0A7h
        db 5Bh,4Fh,53h,37h,52h,00h,09Fh,1Fh,0,0,0DH,0EH,0,0,0,0 ; crtc
        db  90h,2Bh,8Fh,28h,0FH,95h,1Dh,0E3h,0FFh               ; crtc
        db 0,1,2,3,4,5,14H,7,38H,39H,3AH,3BH,3CH,3DH,3EH,3FH
        db  0CH,0,0FH,8
        db 0,0,0,0,0,10H,0Eh,0,0FFh


;------------------------------------------------------------------------
;  << CalcEndAddr >>
; FUNCTION = calculate end of program
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; CalcEndAddr(-/-)
;       {
;       [EndSegment] = CS;
;       [EndOffset] = ChgCode;
;       if ([CodeStat] == ChabLoad), return;
;       [EndOffset] = GenFont;
;       if (([Card1st] < EgaCardM) || ([Card2nd] < EgaCardM))
;               [EndOffset] = VgaService;
;       }
;
CalcEndAddr:
        mov     [EndSegment],cs
        mov     [EndOffset],offset GenFont      ; max size
        test    [CodeStat],ChabLoad
        jnz     @f
        mov     [EndOffset],offset ChgCode      ; W/O code conversion & printer
        mov     al,[Card1st]
        or      al,[Card2nd]
        test    al,00001100b
        jnz     @f
        mov     [EndOffset],offset VgaService   ; W/O VGA service
@@:
        ret


;------------------------------------------------------------------------
;  << SetPatGen >>
; FUNCTION = install pattern generator
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; SetPatGen(-/-)
;       {
;       if ([Card1st != FontCard or HanCard) && ([Card1st != FontCard or HanCard)
;               {
;               [Ks2ChAddr] = Ks2Ch;
;               DI = [EndOffset];
;               [GetHan1st] = DI;
;               [GetHan2nd] = DI;
;               SI = GenFont;
;               CX = GenFontLng;
;               /* rep movsb */
;               [EndOffset] = DI;
;               }
;       }
;
extrn   Ks2Ch:near, Ks2ChAddr:word
SetPatGen:
        mov     di,[EndOffset]
        test    [Card1st],FontCard or HanCard
        jnz     @f
        test    [Card2nd],FontCard or HanCard
        jnz     @f
        mov     [GetHan1st],di
        mov     [GetHan2nd],di
        jmp     short SetPatGenDo
@@:
        test    [CodeStat],ChabLoad
        jz      @f
SetPatGenDo:
        or      [CodeStat],InstPatGen
        mov     [Ks2ChAddr],offset Ks2Ch
        mov     si,offset GenFont
        mov     [PatGenAddr],di
        mov     cx,offset CharTbl
        sub     cx,si
        add     cx,di
        mov     [HanPatternPtr],cx
        mov     cx,GenFontLng
        rep movsb
        mov     [EndOffset],di
@@:
        ret


;------------------------------------------------------------------------
;   << SetCodeBuffer >>
; FUNCTION = code buffer 
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; SetCodeBuffer(-/-)
;       {
;       [CodeBuf2Addr] = [EndOffset];
;       [CodeBuf2Addr+2] = CS;
;       switch ([Card1st])
;               {
;               case MgaCard:
;                       AX = 80*25;
;                       return;
;               case CgaCard:
;                       AX = 80*25;
;                       return;
;               case EgaCardM:
;                       AX = 80*25;
;                       return;
;               case EgaCardC:
;                       AX = 80*25;
;                       return;
;               case McgaCard:
;                       AX = 80*30;
;                       return;
;               case VgaCard:
;                       AX = 80*05;
;               }
;       switch ([Card2nd])
;               {
;               case MgaCard:
;                       AX = 80*25;
;                       return;
;               case CgaCard:
;                       AX = 80*25;
;                       return;
;               case EgaCardM:
;                       AX = 80*25;
;                       return;
;               case EgaCardC:
;                       AX = 80*25;
;                       return;
;               case McgaCard:
;                       AX = 80*30;
;                       return;
;               case VgaCard:
;                       AX = 80*30;
;               }
;       [EndOffset] = [EndOffset] + AX;
;       }
;
SetCodeBuffer:
        mov     ax,[EndOffset]
        mov     word ptr [CodeBuf2Addr],ax
        mov     word ptr [CodeBuf2Addr+2],cs
        mov     bl,[Card1st]
        and     bl,CardType
        mov     bh,[Card2nd]
        and     bh,CardType
        cmp     bl,bh
        jae     @f
        mov     bl,bh
@@:
        xor     bh,bh
        mov     ax,[bx+BufferSizeTbl]
        add     [EndOffset],ax
        mov     [CodeBufSize],ax
        ret
BufferSizeTbl   label   word
                dw      80*25*2         ; MGA card
                dw      80*25*2         ; CGA card
                dw      80*25*2         ; EGA mono card
                dw      80*25*2         ; EGA color card
                dw      80*30*2         ; MCGA card
                dw      80*30*2         ; VGA card


;------------------------------------------------------------------------
;   << CheckMemory >>
; CheckMemory(-/-)
;       {
;       }
;
CheckMemory:
        mov     dx,offset FontFileName
        mov     ax,3d00h                ; find first filename
        int     21h
        jc      CheckMemErr
        mov     bx,ax
        mov     ah,3eh                  ; close file
        int     21h
        test    [Card1st],HanCard
        jnz     CheckMemErr
        test    [Card2nd],HanCard
        jnz     CheckMemErr
        mov     ax,188+6                ; 32*94*64+94*2*32 = 192512+6016 Byte
        test    [Card1st],FontCard
        jz      @f
        mov     ax,6                    ; 94*2*32 = 6016 Byte
@@:
        mov     [MemSize],ax
        test    [MemStat],RealMem or ExtMem or EmsMem or HiMem
        jz      AutoMemory
        test    [MemStat],EmsMem
        jz      @f
        call    CheckEms
        jc      CheckMemErr
        jmp     short CheckMemEnd
@@:
        test    [MemStat],HiMem
        jz      @f
        call    CheckHimem
        jc      CheckMemErr
        jmp     short CheckMemEnd
@@:
        test    [MemStat],ExtMem
        jz      @f
        call    CheckExt
        jc      CheckMemErr
        jmp     short CheckMemEnd
@@:
        test    [MemStat],RealMem
        jz      CheckMemEnd
        call    CheckReal
        jc      CheckMemErr
CheckMemEnd:
        ret
CheckMemErr:
        and     [MemStat],not (RealMem or ExtMem or EmsMem or HiMem)
        ret
AutoMemory:
        call    CheckEms
        jc      @f
        or      [MemStat],EmsMem
        jmp     short AutoMemEnd
@@:
        call    CheckHimem
        jc      @f
        or      [MemStat],HiMem
        jmp     short AutoMemEnd
@@:
        call    CheckExt
        jc      @f
        or      [MemStat],ExtMem
        jmp     short AutoMemEnd
@@:
        call    CheckReal
        jc      CheckMemErr
        or      [MemStat],RealMem
AutoMemEnd:
        ret


CheckEms:
        push    es
        mov     ax,3567h
        int     21h
        mov     di,0ah
        mov     si,offset EmmDrvName
        mov     cx,EmmDrvNameLng
        repe cmpsb
        pop     es
        jnz     @f
        mov     ah,46h                  ; get version
        int     67h
        or      ah,ah
        jnz     @f
        cmp     al,30h                  ; version 3.0
        jb      @f
        mov     ah,41h                  ; get segment address
        int     67h
        or      ah,ah
        jnz     @f
        mov     [EmsSeg],bx
        mov     ah,42h                  ; get page number
        int     67h
        or      ah,ah
        jnz     @f
        mov     ax,16                   ; kbyte units
        mul     bx
        cmp     [MemSize],ax
        ja      @f
        mov     [MaxMemSize],ax
        clc
        ret
@@:
        stc
        ret
EmmDrvName      db      'EMMXXXX0'
EmmDrvNameLng   =       $-EmmDrvName
CheckHimem:
        mov     ax,4300h
        int     2fh
        cmp     al,80h
        jnz     @f
        push    es
        mov     ax,4310h
        int     2fh
        mov     ax,es
        pop     es
        mov     word ptr [OldInt15],bx
        mov     word ptr [OldInt15+2],ax
        xor     ah,ah
        call    [OldInt15]
        cmp     dl,1
        jnz     @f
        cmp     ax,200h                 ; V2.00
        jb      @f
        mov     ah,8
        call    [OldInt15]
        or      bl,bl
        jnz     @f
        cmp     [MemSize],ax
        ja      @f
        mov     [MaxMemSize],ax
        clc
        ret
@@:
        stc
        ret
CheckExt:
        test    [MachineType],AtMachine
        jz      @f
        mov     ah,88h
        int     15h
        cmp     [MemSize],ax
        ja      @f
        mov     [MaxMemSize],ax
        clc
        ret
@@:
        stc
        ret
CheckReal:
        int     12h
        mov     bx,cs
        mov     cl,6
        shr     bx,cl
        sub     ax,bx
        sub     ax,256                  ; add 256 kbyte
        cmp     [MemSize],ax
        ja      @f
        mov     [MaxMemSize],ax
        clc
        ret
@@:
        stc
        ret


;------------------------------------------------------------------------
;   << SetVector >>
; FUNCTION = initialize vector table
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; SetVector(-/-)
;       {
;       Save ES;
;       ES = 0;
;       [OldKbInt] = ES:[rKbInt];
;       [OldKbInt+2] = ES:[rKbInt+2];
;       ES:[rKbInt] = Int9;
;       ES:[rKbInt+2] = CS;
;       [OldKbioInt] = ES:[rKbioInt];
;       [OldKbioInt+2] = ES:[rKbioInt+2];
;       ES:[rKbioInt] = Int16;
;       ES:[rKbioInt+2] = CS;
;       [OldRtcInt] = ES:[rRtcInt];
;       [OldRtcInt+2] = ES:[rRtcInt+2];
;       ES:[rRtcInt] = Int8;
;       ES:[rRtcInt+2] = CS;
;       [OldVideo] = ES:[rVideoInt];
;       [OldVideo+2] = ES:[rVideoInt+2];
;       ES:[rVideoInt] = Int10;
;       ES:[rVideoInt+2] = CS;
;       [OldVdParms] = ES:[rVdParm];
;       [OldVdParms+2] = ES:[rVdParm+2];
;       ES:[rVdParm] = VideoParms;
;       ES:[rVdParm+2] = CS;
;       if ([CodeStat] == ChabLoad)
;               {
;               [OldInt17] = ES:[rPrinter];
;               [OldInt17+2] = ES:[rPrinter+2];
;               ES:[rPrinter] = Int17;
;               ES:[rPrinter+2] = CS;
;               }
;       Restore ES;
;       }
;
SetVector:
        cli
        push    es
        xor     ax,ax
        mov     es,ax
        mov     ax,word ptr es:[rKbInt]
        mov     bx,word ptr es:[rKbInt+2]
        mov     word ptr [OldKbInt],ax
        mov     word ptr [OldKbInt+2],bx
        mov     word ptr es:[rKbInt],offset Int9
        mov     word ptr es:[rKbInt+2],cs
        mov     ax,word ptr es:[rKbioInt]
        mov     bx,word ptr es:[rKbioInt+2]
        mov     word ptr [OldKbioInt],ax
        mov     word ptr [OldKbioInt+2],bx
        mov     word ptr es:[rKbioInt],offset Int16
        mov     word ptr es:[rKbioInt+2],cs
        mov     ax,word ptr es:[rRtcInt]
        mov     bx,word ptr es:[rRtcInt+2]
        mov     word ptr [OldRtcInt],ax
        mov     word ptr [OldRtcInt+2],bx
        mov     word ptr es:[rRtcInt],offset Int8
        mov     word ptr es:[rRtcInt+2],cs
if      Hwin31Sw
        mov     ax,word ptr es:[rInt2f]
        mov     bx,word ptr es:[rInt2f+2]
        mov     word ptr [OldInt2f],ax
        mov     word ptr [OldInt2f+2],bx
        mov     word ptr es:[rInt2f],offset Int2f
        mov     word ptr es:[rInt2f+2],cs
endif   ;   Hwin31Sw
        mov     ax,word ptr es:[rVideoInt]
        mov     bx,word ptr es:[rVideoInt+2]
        mov     word ptr [OldVideo],ax
        mov     word ptr [OldVideo+2],bx
        mov     word ptr es:[rVideoInt],offset Int10
        mov     word ptr es:[rVideoInt+2],cs
        mov     ax,word ptr es:[rVdParm]
        mov     bx,word ptr es:[rVdParm+2]
        mov     word ptr [OldVdParms],ax
        mov     word ptr [OldVdParms+2],bx
        mov     word ptr es:[rVdParm],offset VideoParms
        mov     word ptr es:[rVdParm+2],cs
        test    [CodeStat],ChabLoad
        jz      @f
        mov     ax,word ptr es:[rPrinter]
        mov     bx,word ptr es:[rPrinter+2]
        mov     word ptr [OldInt17],ax
        mov     word ptr [OldInt17+2],bx
        mov     word ptr es:[rPrinter],offset Int17
        mov     word ptr es:[rPrinter+2],cs
@@:
        pop     es
        sti
        ret


;------------------------------------------------------------------------
;   << InstallFontFile >>
; FUNCTION =   EMS/Ext./HIMEM memory 
; INPUT   : none
; OUTPUT  : none
; PROTECT : SS, SP, DS, ES
;
; InstallFontFile(-/-)
;       {
;       }
;
InstallFontFile:
        test    [MemStat],HiMem
        jz      @f
        mov     ah,9
        mov     dx,[MemSize]
        call    [OldInt15]
        dec     ax
        jnz     HimemErr
        mov     [EmsHandle],dx
        mov     ah,0ch
        call    [OldInt15]
        dec     ax
        jnz     HimemErr
        mov     ax,bx
        call    InstallFontHi
        jmp     short InstallFileEnd
HimemErr:
        or      [ErrStat],FontLoadErr
        and     [MemStat],not HiMem
        jmp     short InstallFileEnd
@@:
        test    [MemStat],ExtMem
        jz      @f
        call    InstallFontExt
        jmp     short InstallFileEnd
@@:
        test    [MemStat],EmsMem
        jz      @f
        call    InstallFontEms
        jmp     short InstallFileEnd
@@:
        test    [MemStat],RealMem
        jz      InstallFileEnd
        call    InstallFontReal
InstallFileEnd:
        ret
InstallFontExt:
        mov     dx,[MaxMemSize]
        sub     dx,[MemSize]
        mov     [MaxMemSize],dx
        mov     ax,1024
        mul     dx
        add     dl,10h                  ; 1MByte boundary
InstallFontHi:
        mov     bl,dl
        test    [MemStat],ExtMem
        jz      @f
        push    ds
        push    es
ASSUME  DS:DATA
        xor     dx,dx
        mov     ds,dx
        les     di,[rCasetInt]
        mov     word ptr cs:[OldInt15],di
        mov     word ptr cs:[OldInt15+2],es
        mov     word ptr [rCasetInt],offset Int15Srv
        mov     word ptr [rCasetInt+2],cs
        pop     es
        pop     ds
ASSUME  DS:CODE
@@:
        test    [HjStat],HjLoaded
        jnz     @f
        mov     [HanAddr],ax
        mov     [HanAddrH],bl
        mov     [GetHan1st],offset GetFontHanExt
        mov     [GetHan2nd],offset GetFontHanExt
        mov     dx,offset FontFileName
        call    SaveFontFile
        or      [HjStat],HjLoaded
        add     ax,61440                ; 32*94*64 = 192512
        adc     bl,2
@@:
        mov     [UdcAddr],ax            ; 94*2*32 = 6016
        mov     [UdcAddrH],bl
        mov     [GetUdc1st],offset GetFontUdcExt
        mov     [GetUdc2nd],offset GetFontUdcExt
        mov     [PutUdc1st],offset PutFontUdcExt
        mov     [PutUdc2nd],offset PutFontUdcExt
        or      [HjStat],UdcArea
        ret
SaveFontFile:
        push    ax
        push    bx
        push    cx
        mov     si,offset GdtDataTbl
        mov     [si].GdtDL,ax
        mov     [si].GdtDH,bl
        mov     ax,3d00h
        int     21h
        jc      SaveFontFileErr
        mov     bx,ax                   ; copy handle
        mov     ax,4200h
        xor     cx,cx
        mov     dx,30h
        int     21h                     ; set absolute file pointer
        push    ds
        mov     ax,cs
        add     ah,10h                  ; next segment
        mov     ds,ax
        mov     cl,4
        shl     ax,cl
        mov     cs:[si].GdtSL,ax
        mov     ax,ds
        shr     ah,cl
        mov     cs:[si].GdtSH,ah
@@:
        xor     dx,dx
        mov     cx,8000h
        mov     ah,3fh
        int     21h
        jc      SaveFontFileErr2
        mov     cx,ax
        jcxz    @f
        inc     cx
        shr     cx,1                    ; word count
        push    cx
        mov     ah,87h
        int     15h
        pop     cx
        shl     cx,1
        add     cs:[si].GdtDL,cx
        adc     cs:[si].GdtDH,0
        jmp     short @b
SaveFontFileErr2:
        or      cs:[ErrStat],FontLoadErr
@@:
        pop     ds
        mov     ah,3eh
        int     21h                     ; close handle
        jmp     short @f
SaveFontFileErr:
        or      [ErrStat],FontLoadErr
@@:
        pop     cx
        pop     bx
        pop     ax
        ret
InstallFontEms:
        mov     bx,[MemSize]
        mov     cl,4
        shr     bx,cl
        inc     bx
        mov     ah,43h                  ; allocate page
        int     67h
        or      ah,ah
        jz      @f
        mov     ah,45h                  ; close handle
        int     67h
        ret
@@:
        mov     [EmsHandle],dx
        xor     bl,bl
        xor     ax,ax
        test    [HjStat],HjLoaded
        jnz     @f
        mov     [HanAddr],ax
        mov     [HanAddrH],bl
        mov     [GetHan1st],offset GetFontHanEms
        mov     [GetHan2nd],offset GetFontHanEms
        mov     si,offset FontFileName
        call    SaveEmsFontFile
        or      [HjStat],HjLoaded
        add     ax,12288                ; 32*94*64 = 192512
        add     bl,11
        cmp     ax,16384
        jb      @f
        sub     ax,16384
        inc     bl
@@:
        mov     [UdcAddr],ax            ; 94*2*32 = 6016
        mov     [UdcAddrH],bl
        mov     [GetUdc1st],offset GetFontUdcEms
        mov     [GetUdc2nd],offset GetFontUdcEms
        mov     [PutUdc1st],offset PutFontUdcEms
        mov     [PutUdc2nd],offset PutFontUdcEms
        or      [HjStat],UdcArea
        ret
SaveEmsFontFile:
        push    ax
        push    bx
        push    cx
        push    es
        mov     es,[EmsSeg]
        mov     di,ax
        mov     ax,4400h                ; set page
        xor     bh,bh
        mov     [CurEmsPage],bx
        mov     dx,[EmsHandle]
        int     67h
        or      ah,ah
        jnz     SaveEmsFontFileErr
        mov     dx,si
        mov     ax,3d00h
        int     21h
        jc      SaveEmsFontFileErr
        mov     bx,ax                   ; BX = file handle
        mov     ax,4200h
        xor     cx,cx
        mov     dx,30h
        int     21h                     ; set absolute file pointer
        push    ds
        mov     ax,cs
        add     ah,10h                  ; next segment
        mov     ds,ax
EmsSaveLoop:
        xor     dx,dx
        mov     cx,8000h
        mov     ah,3fh
        int     21h
        jc      SaveEmsFontFileErr2
        mov     cx,ax
        jcxz    SaveEmsFontFileEnd2
        xor     si,si
@@:
        cmp     di,16384
        jae     IncEmsPage
        movsb
        dec     cx
        jz      EmsSaveLoop
        jmp     short @b
IncEmsPage:
        push    bx
        mov     ax,4400h                ; set page
        inc     cs:[CurEmsPage]
        mov     bx,cs:[CurEmsPage]
        mov     dx,cs:[EmsHandle]
        int     67h
        pop     bx
        or      ah,ah
        jnz     SaveEmsFontFileErr2
        xor     di,di
        jmp     short @b
SaveEmsFontFileErr2:
        or      cs:[ErrStat],FontLoadErr
SaveEmsFontFileEnd2:
        pop     ds
        mov     ah,3eh
        int     21h                     ; close handle
        jmp     short @f
SaveEmsFontFileErr:
        or      [ErrStat],FontLoadErr
@@:
        pop     es
        pop     cx
        pop     bx
        pop     ax
        ret
InstallFontReal:
        test    [HjStat],HjLoaded
        jnz     @f
        mov     [GetHan1st],offset GetFontHanReal
        mov     [GetHan2nd],offset GetFontHanReal
@@:
        mov     [GetUdc1st],offset GetFontUdcReal
        mov     [GetUdc2nd],offset GetFontUdcReal
        mov     [PutUdc1st],offset PutFontUdcReal
        mov     [PutUdc2nd],offset PutFontUdcReal
        or      [HjStat],UdcArea
        ret

public  EndOfInit                       ; for .MAP file
EndOfInit       label   byte

CODE    ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\jongi.inc ===
DW      0,2,14,26,38,52,64,76
        DW      88,102,114,126,138,152,164,176
        DW      152,188,188,200,212,226,238,238
        DW      250,264,276,288,264,300,312,324
        DW      336,350,362,374,386,400,412,424
        DW      436,450,462,474,486,500,512,524
        DW      536,550,562,574,586,600,612,624
        DW      636,650,662,674,686,700,712,724
        DW      700,736,748,760,772,786,798,810
        DW      822,836,848,860,872,886,898,910
        DW      922,936,948,960,936,972,984,996
        DW      1008,1022,1022,1034,1046,1060,1072,1084
        DW      1096,1110,1122,1134,1146,1160,1160,1172
        DW      1160,1184,1198,1212,1184
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\hf.inc ===
_hfBaseCho      LABEL   Word
        DW      -1, 0, __hfIndexCho+2,__hfIndexCho+22
        DW      __hfIndexCho+42,__hfIndexCho+62,__hfIndexCho+82,__hfIndexCho+102
        DW      __hfIndexCho+122,__hfIndexCho+142,__hfIndexCho+162,__hfIndexCho+182
        DW      __hfIndexCho+202,__hfIndexCho+222,__hfIndexCho+242,__hfIndexCho+262
        DW      __hfIndexCho+282,__hfIndexCho+302,__hfIndexCho+322,__hfIndexCho+342
        DW      __hfIndexCho+362, 11 DUP ( -1 )

_hfBaseJung     LABEL   Word
        DW      -1, 0, 0, __hfIndexJung+2
        DW      __hfIndexJung+14,__hfIndexJung+26,__hfIndexJung+38,__hfIndexJung+50
        DW      -1, -1, __hfIndexJung+62,__hfIndexJung+74
        DW      __hfIndexJung+86,__hfIndexJung+98,__hfIndexJung+110,__hfIndexJung+122
        DW      -1, -1, __hfIndexJung+134,__hfIndexJung+146
        DW      __hfIndexJung+158,__hfIndexJung+170,__hfIndexJung+182,__hfIndexJung+194
        DW      -1, -1, __hfIndexJung+206,__hfIndexJung+218
        DW      __hfIndexJung+230,__hfIndexJung+242, -1, -1

_hfBaseJong     LABEL   Word
        DW      -1, 0, __hfIndexJong+2,__hfIndexJong+10
        DW      __hfIndexJong+18,__hfIndexJong+26,__hfIndexJong+34,__hfIndexJong+42
        DW      __hfIndexJong+50,__hfIndexJong+58,__hfIndexJong+66,__hfIndexJong+74
        DW      __hfIndexJong+82,__hfIndexJong+90,__hfIndexJong+98,__hfIndexJong+106
        DW      __hfIndexJong+114,__hfIndexJong+122, -1, __hfIndexJong+130
        DW      __hfIndexJong+138,__hfIndexJong+146,__hfIndexJong+154,__hfIndexJong+162
        DW      __hfIndexJong+170,__hfIndexJong+178,__hfIndexJong+186,__hfIndexJong+194
        DW      __hfIndexJong+202,__hfIndexJong+210, -1, -1

_hfCnvChoJung   LABEL   Word
        DW      -1, 0, 6, 6, 6, 6, 6, 6
        DW      6, 6, 6, 6, 6, 6, 6, 6
        DW      6, 6, 6, 6, 6, -1, -1, -1
        DW      -1, -1, -1, -1, -1, -1, -1, -1

_hfCnvChoJong   LABEL   Word
        DW      0, 0, 0, 0, 0, 0, 0, 0
        DW      0, 0, 0, 0, 0, 0, 0, 0
        DW      0, 0, 0, 0, 0, 0, 0, 0
        DW      0, 0, 0, 0, 0, 0, 0, 0

_hfCnvJungCho   LABEL   Word
        DW      -1, 0, 0, 0, 0, 0, 0, 0
        DW      -1, -1, 0, 0, 0, 4, 12, 12
        DW      -1, -1, 12, 4, 8, 16, 16, 16
        DW      -1, -1, 8, 4, 12, 0, -1, -1
_hfCnvJungJong  LABEL   Word
        DW      -1, 6, 6, 0, 4, 0, 4, 2
        DW      -1, -1, 4, 2, 4, 6, 0, 4
        DW      -1, -1, 2, 6, 6, 2, 4, 2
        DW      -1, -1, 6, 6, 2, 2, -1, -1

_hfCnvJongCho   LABEL   Word
        DW      -1, 0, 2, 2, 2, 2, 2, 2
        DW      2, 2, 2, 2, 2, 2, 2, 2
        DW      2, 2, -1, 2, 2, 2, 2, 2
        DW      2, 2, 2, 2, 2, 2, -1, -1

_hfCnvJongJung  LABEL   Word
        DW      -1, 0, 2, 2, 2, 4, 2, 2
        DW      2, 2, 2, 2, 2, 2, 2, 2
        DW      2, 2, -1, 2, 2, 2, 2, 2
        DW      2, 2, 2, 2, 2, 2, -1, -1


__hfIndexCho    LABEL   Word

        INCLUDE choi.inc

__hfBmpCho      LABEL   Word

        INCLUDE cho.inc


__hfIndexJung   LABEL   Word

        INCLUDE jungi.inc

__hfBmpJung     LABEL   Word

        INCLUDE jung.inc


__hfIndexJong   LABEL   Word

        INCLUDE jongi.inc

__hfBmpJong     LABEL   Word

        INCLUDE jong.inc


_hfBmpCho       DW      __hfBmpCho
_hfBmpJung      DW      __hfBmpJung
_hfBmpJong      DW      __hfBmpJong
_hfBmpSeg       DW      ?

        PUBLIC  _hfBaseCho, _hfBaseJung, _hfBaseJong
        PUBLIC  _hfCnvChoJung, _hfCnvChoJong
        PUBLIC  _hfCnvJungCho, _hfCnvJungJong
        PUBLIC  _hfCnvJongCho, _hfCnvJongJung
        PUBLIC  _hfBmpCho, _hfBmpJung, _hfBmpJong
        PUBLIC  _hfBmpSeg
        PUBLIC  __hfBmpCho, __hfBmpJung, __hfBmpJong
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\jung.inc ===
DW      0FFFFh
        DW      0F00h, 6000h,3000h,3000h,3000h,3000h,3000h,3E00h,3000h,3000h,3000h,3000h,3000h,3000h,3000h,2000h
        DW      0A00h, 6000h,3000h,3000h,3000h,3000h,3E00h,3000h,3000h,3000h,2000h
        DW      0F00h, 1800h,0CC00h,6C00h,6C00h,6C00h,6C00h,7C00h,6C00h,6C00h,6C00h,6C00h,6C00h,6C00h,4C00h,800h
        DW      0A00h, 1800h,0CC00h,6C00h,6C00h,7C00h,6C00h,6C00h,6C00h,4C00h,800h
        DW      0F00h, 6000h,3000h,3000h,3000h,3E00h,3000h,3000h,3000h,3E00h,3000h,3000h,3000h,3000h,3000h,2000h
        DW      0A00h, 6000h,3000h,3000h,3E00h,3000h,3000h,3E00h,3000h,3000h,2000h
        DW      0F00h, 1800h,0CC00h,6C00h,6C00h,7C00h,6C00h,6C00h,7C00h,6C00h,6C00h,6C00h,6C00h,6C00h,4C00h,800h
        DW      0A00h, 1800h,0CC00h,6C00h,7C00h,6C00h,6C00h,7C00h,6C00h,4C00h,800h
        DW      0F00h, 3000h,1800h,1800h,1800h,1800h,1800h,0F800h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1000h
        DW      0A00h, 3000h,1800h,1800h,1800h,1800h,0F800h,1800h,1800h,1800h,1000h
        DW      0F00h, 3000h,1800h,1800h,1800h,1800h,0F800h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1000h
        DW      0A00h, 3000h,1800h,1800h,1800h,0F800h,1800h,1800h,1800h,1800h,1000h
        DW      0F00h, 1800h,0CC00h,6C00h,6C00h,6C00h,6C00h,0EC01h,6C00h,6C00h,6C00h,6C00h,6C00h,6C00h,4C00h,800h
        DW      0A00h, 1800h,0CC00h,6C00h,6C00h,6C00h,0EC03h,6C00h,6C00h,4C00h,800h
        DW      0F00h, 1800h,0CC00h,6C00h,6C00h,6C00h,0EC01h,6C00h,6C00h,6C00h,6C00h,6C00h,6C00h,6C00h,4C00h,800h
        DW      0A00h, 1800h,0CC00h,6C00h,6C00h,0EC01h,6C00h,6C00h,6C00h,4C00h,800h
        DW      0F00h, 3000h,1800h,1800h,1800h,0F800h,1800h,1800h,0F800h,1800h,1800h,1800h,1800h,1800h,1800h,1000h
        DW      0A00h, 3000h,1800h,1800h,0F800h,1800h,1800h,0F800h,1800h,1800h,1000h
        DW      0F00h, 3000h,1800h,1800h,1800h,1800h,0F800h,1800h,1800h,0F800h,1800h,1800h,1800h,1800h,1800h,1000h
        DW      0A00h, 3000h,1800h,1800h,0F800h,1800h,0F800h,1800h,1800h,1800h,1000h
        DW      0F00h, 1800h,0CC00h,6C00h,6C00h,0EC01h,6C00h,6C00h,0EC01h,6C00h,6C00h,6C00h,6C00h,6C00h,4C00h,800h
        DW      0A00h, 1800h,0CC00h,6C00h,0EC03h,6C00h,6C00h,0EC03h,6C00h,4C00h,800h
        DW      0F00h, 1800h,0CC00h,6C00h,6C00h,6C00h,0EC01h,6C00h,6C00h,0EC01h,6C00h,6C00h,6C00h,6C00h,4C00h,800h
        DW      0A00h, 1800h,0CC00h,6C00h,0EC03h,6C00h,0EC03h,6C00h,6C00h,4C00h,800h
        DW      510h, 0Eh,6,6,6,0FC7Fh
        DW      30Ah, 7,3,0FC7Fh
        DW      412h, 3,3,3,0FC7Fh
        DW      30Ah, 8001h,8001h,0FC7Fh
        DW      0F00h, 6000h,3000h,3000h,3000h,3000h,3000h,3E00h,3038h,3018h,0F018h,30FFh,3000h,3000h,3000h,2000h
        DW      0A00h, 6000h,3000h,3000h,3000h,3000h,3E00h,3038h,0F018h,30FFh,2000h
        DW      0F00h, 6000h,3000h,3000h,3000h,3000h,3000h,3E00h,3000h,300Ch,700Ch,0B0FFh,3000h,3000h,3000h,2000h
        DW      0A00h, 6000h,3000h,3000h,3000h,3000h,3E00h,300Ch,700Ch,0B0FFh,2000h
        DW      0F00h, 1800h,0CC00h,6C00h,6C00h,6C00h,6C00h,7C00h,6C38h,6C18h,0EC18h,6CFFh,6C00h,6C00h,4C00h,800h
        DW      0A00h, 1800h,0CC00h,6C00h,6C00h,6C00h,7C00h,6C38h,0EC18h,6CFFh,4800h
        DW      0F00h, 1800h,0CC00h,6C00h,6C00h,6C00h,6C00h,6C00h,7C00h,6C0Ch,0EC0Ch,6CFFh,6C00h,6C00h,4C00h,800h
        DW      0A00h, 1800h,0CC00h,6C00h,6C00h,6C00h,7C00h,6C0Ch,0EC0Ch,6CFFh,4800h
        DW      0F00h, 3000h,1800h,1800h,1800h,1800h,1800h,1800h,1838h,1818h,7818h,98FFh,1800h,1800h,1800h,1000h
        DW      0A00h, 3000h,1800h,1800h,1800h,1800h,1800h,1838h,3818h,0D8FFh,1000h
        DW      0F00h, 3000h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,180Ch,780Ch,98FFh,1800h,1800h,1800h,1000h
        DW      0A00h, 3000h,1800h,1800h,1800h,1800h,1800h,180Ch,780Ch,98FFh,1000h
        DW      60Eh, 8003h,801Dh,800Dh,800Dh,800Dh,0FC7Fh
        DW      408h, 8003h,801Dh,800Dh,0FC7Fh
        DW      412h, 6006h,6006h,6006h,0FC7Fh
        DW      30Ah, 6006h,6006h,0FC7Fh
        DW      80Eh, 0FC7Fh,8001h,8001h,8001h,8001h,8001h,8001h,1
        DW      30Eh, 0FC7Fh,8001h,8001h
        DW      710h, 0FC7Fh,8001h,8001h,8001h,8001h,8001h,1
        DW      50Eh, 0FC7Fh,8001h,8001h,8001h,1
        DW      0F00h, 3000h,1800h,1800h,1800h,1800h,1800h,3800h,0D8FFh,180Ch,0F80Ch,180Ch,180Ch,180Ch,1808h,1000h
        DW      0A00h, 3000h,1800h,1800h,1800h,1800h,3800h,0D8FFh,180Ch,0F80Ch,1008h
        DW      0F00h, 3000h,1800h,1800h,1800h,1800h,1800h,1800h,3800h,0D8FFh,180Ch,0F80Ch,180Ch,180Ch,1808h,1000h
        DW      0A00h, 3000h,1800h,1800h,1800h,1800h,1800h,7800h,98FFh,0F80Ch,1008h
        DW      0F00h, 1800h,0CC00h,6C00h,6C00h,6C00h,6C00h,0EC00h,6CFFh,6C0Ch,0EC0Dh,6C0Ch,6C0Ch,6C0Ch,6C08h,4800h
        DW      0A00h, 1800h,0CC00h,6C00h,6C00h,6C00h,0EC00h,6CFFh,6C0Ch,0EC0Dh,4808h
        DW      0F00h, 1800h,0CC00h,6C00h,6C00h,6C00h,6C00h,6C00h,0EC00h,6CFFh,6C0Ch,0EC0Dh,6C0Ch,6C0Ch,6C08h,4800h
        DW      0A00h, 1800h,0CC00h,6C00h,6C00h,6C00h,6C00h,0EC01h,6CFEh,0EC19h,4810h
        DW      0F00h, 3000h,1800h,1800h,1800h,1800h,1800h,3800h,0D8FFh,180Ch,180Ch,180Ch,180Ch,180Ch,1808h,1000h
        DW      0A00h, 3000h,1800h,1800h,1800h,1800h,3800h,0D8FFh,180Ch,180Ch,1008h
        DW      0F00h, 3000h,1800h,1800h,1800h,1800h,1800h,1800h,3800h,0D8FFh,180Ch,180Ch,180Ch,180Ch,1808h,1000h
        DW      0A00h, 3000h,1800h,1800h,1800h,1800h,1800h,3800h,0D8FFh,180Ch,1008h
        DW      80Eh, 0FC7Fh,6006h,6006h,6006h,6006h,6006h,6006h,4004h
        DW      30Eh, 0FC7Fh,6006h,6006h
        DW      710h, 0FC7Fh,6006h,6006h,6006h,6006h,6006h,4004h
        DW      50Eh, 0FC7Fh,6006h,6006h,6006h,4004h
        DW      118h, 0FC7Fh
        DW      10Eh, 0FC7Fh
        DW      0F00h, 3000h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,7800h,98FFh,1800h,1800h,1800h,1000h
        DW      0A00h, 3000h,1800h,1800h,1800h,1800h,1800h,1800h,3800h,0D8FFh,1000h
        DW      0F00h, 3000h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,7800h,98FFh,1800h,1800h,1000h
        DW      0F00h, 3000h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1000h
        DW      0A00h, 3000h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1800h,1000h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\test.asm ===
CODE    SEGMENT
ASSUME  CS:CODE,DS:CODE

        ORG     100h
Start:
        jmp     PrgStart




LogoPos         =       0600h

;------------------------
LogoMsg label   byte
 db ' ****** Mode Set Program ******   ',cr,lf
 db '(C)Copyright Qnix Co., Ltd.  1993 ',cr,lf
 db '                   resolution     ',cr,lf
 db '      0 =  132x44 (1188x396)      ',cr,lf
 db '      1 =  132x28 (1188x448)      ',cr,lf
 db '      2 =  132x43 (1188x387)      ',cr,lf
 db '      3 =  132x25 (1188x400)      ',cr,lf
 db '      4 =  132x50 (1056x400)      ',cr,lf
 db '      5 =  80x25  (640x480)       ',cr,lf
 db '     select 0~5                   ',cr,lf
 db '                                  ',cr,lf
 db '    ex) hecon /5                   ,cr,lf
LogoLng         =       $-LogoMsg

PrgStart:
        push    ax
        push    bx
        push    cx
        push    dx
        push    ds
        push    es
        push    si
        push    di
        push    bp
        mov     ax,cs
        mov     ds,ax
        mov     es,ax
        call    ParsCommand
        pop     bp
        pop     di
        pop     si
        pop     es
        pop     ds
        pop     dx
        pop     cx
        pop     bx
        pop     ax
Exit:
        mov     ah,4ch
        int     21h

;------------------------------------------------------------------------
Modeset:
        mov     ax,00
        int     10h
        ret

ParsCommand:
        mov     si,81h
@@:
        lodsb
        cmp     al,cr
        je      ParsEnd
        cmp     al,lf
        je      ParsEnd
        cmp     al,'/'
        jnz     @b
        lodsb
        cmp     al,'?'
        je      Document
        cmp     al,'0'
        jb      ParsEnd
        cmp     al,'9'
        ja      ParsEnd
        jmp     ModeSet
ParsEnd:
        ret

Document:
        mov     bp,offset LogoMsg
        mov     dx,LogoPos
        mov     cx,LogoLng
        mov     bl,07h
        xor     bh,bh
        mov     ax,1300h
        int     10h
        ret
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\kb.asm ===
TITLE   KeyBoard Interrupt 09h 16h

;=======================================================================;
; (C)Copyright Qnix Computer Co. Ltd.   1992                            ;
; This program contains proprietary and confidential information.       ;
; All rights reserved.                                                  ;
;=======================================================================;

;=======================================================================;
;                                                                       ;
;              SPECIFICATION for keyboard                               ;
;                                                                       ;
;=======================================================================;
;
;  KBD service routine video routine   video INT
; sub-routine   data/flag  .
;
; KBD Spec. : KS C 5853
;           : KS C 5842 - 1991
;
; Keyboard type : english 84 KBD
;               : hangeul 86 KBD(none standard)
;               : hangeul 86 KBD(KS C 5853)
;               : 101 KBD
;               : 103 KBD(KS C 5853)
;
; Etc. Spec. : user definable HE/HJ key scan code
;            : Hot key detection & service

CODE    SEGMENT PUBLIC WORD 'CODE'
ASSUME  CS:CODE,DS:CODE,ES:CODE

INCLUDE         EQU.INC

;=======================================================================;
;                                                                       ;
;                      GLOBAL DATA & FLAG                               ;
;                                                                       ;
;=======================================================================;
;
;    KBD main routine    
;     .
;  ----------- EQUATION -----------
HanEngKey       =       03800H
HanjaKey        =       01d00H
BanJunKey       =       08300H
Upper2Low       =       020H
HjNumOf1Line    =       10

EXTRN   HanCardReset:near, pHanCardReset:near, EnvrChange:near
EXTRN   KbStat:byte, HjStat:byte, HjMenuStat:byte,TotalMenuCnt:byte
EXTRN   OldKbInt:dword, OldKbioInt:dword, CodeStat:byte,KbdType:byte
EXTRN   DisplayStat:byte, HanStat:byte, HjMenuLine:byte
EXTRN   MenuBuffer:word, MenuLineBuf:word, KbMisc:byte, HotStat:byte

EXTRN   CompleteCharCnt:word, CompleteCharBuf:word, InterimCharCnt:word
EXTRN   InterimCharBuf:word, Auto:byte, TmpKbdType:byte
EXTRN   InterimCurPage:byte,InterimMaxCols:byte,InterimCurPos:word
EXTRN   SavedChar1:byte,SavedChar2:byte
EXTRN   MenuPtr:byte, CurrMenuCnt:byte, SaveCurrPage:byte, CrtMaxCols:byte
EXTRN   SaveCurPos:word, SaveCurType:word, prebufptr:word
EXTRN   DispIChar1:byte, DispIChar2:byte, InterimDispP:word
EXTRN   PreInCode:word, CurInCode:word, TmpBuf:word, PreTmpBuf:word
EXTRN   KsKbBuf:word, TmpBufCnt:byte
if      WINNT
EXTRN   ActiveCodePage:word
endif

;=======================================================================;
;                                                                       ;
;                      KEYBOARD INTERRUPT 9                             ;
;                                                                       ;
;=======================================================================;
;
;   << Int9 >>
; FUNCTION = KBD hardware interrupt service routine
; Int9(-/-)
;         {
;         /* save AX, DS */
;         DS = KbSeg;
;         AL = in port 60H;
;         if (AL == DelKey) && ([rKbFlag] == (AltFlag || CtrlFlag))
;                 {
;                 /* save DX */
;                 HanCardReset(-/-);
;                 pHanCardReset(-/-);
;                 /* reset 3bf port */
;                 /* Restore DX, DS, AX */
;                 /* goto cs:[OldKbInt] */
;                 }
;         /* save BX, CX, DX */
;         BX = [rBufferTail];
;         AH = [rKbFlag3]
;         DL = [rKbFlag]
;         /* call cs:[OldKbInt] */
;         if (CheckHeHjKey(AL/CX,flag) == NC)
;               {
;               if (AX == HanjaKey) && ([rKbFlag] == 00000100)
;                       {
;                       CS:[KbStat] = CS:[KbStat] || ReqEnvrChg;
;                       [rBufferTail] = BX
;                       }
;               else
;                       if (CS:[KbStat] == HanKeyinMode), PushKeyBuf(BX,CX/-);
;               }
;         else
;                 {
;                 if ((CS:[KbStat] == HanKeyinMode) && ([rKbFlag] == CapsFlag)&&
;                     (BX != [rBufferTail]) && ((A<=AL<=Z)||(a<=AL<=z))
;                         XOR [rBufferTail],00100000b;
;                 }
;         if ([rKbFlag3] == Ext10xKey)
;                 {
;                 cs:[KbStat] = cs:[KbStat] || Ext10xKey
;                 if (cs:[KbStat] != UserDefineKey) /* off right ALT+CTRL flag */
;                 }
;         /* restore DX, CX, BX, DS, AX */
;         iret;
;         }
;

EXTRN   MachineType:byte, HeKey:byte, HjKey:byte
PUBLIC  Int9, PushKeyBuf
E0Flag  db      0

Int9:
ASSUME  DS:KBSEG
if      Debug
Extrn   DebugData:word
        pushf
        cli
        push    ax
        push    bx
        mov     ax,cs:[DebugData]
        mov     bx,ax
        and     bx,0f0h
        and     ax,0ff0fh
        add     bx,10h
        and     bx,0f0h
        or      ax,bx
        out     10h,ax
        mov     cs:[DebugData],ax
        pop     bx
        pop     ax
        popf
endif   ; if Debug
        @push   ax,ds
        mov     ax,seg KbSeg
        mov     ds,ax
        in      al,60h
        cmp     al,DelKey
        jnz     @f
        mov     ah,[rKbFlag]
        and     ah,00001100b
        cmp     ah,00001100b
        jnz     @f
        push    dx
        call    HanCardReset
        call    pHanCardReset
        mov     dx,3bfh
        mov     al,3
        out     dx,al
        mov     dl,0b8h
        mov     al,28h
        out     dx,al
        xor     al,al
        mov     dl,0bfh
        out     dx,al
        @pop    dx,ds,ax
        jmp     cs:[OldKbInt]
@@:
        @push   bx,cx,dx
        mov     bx,[rBufferTail]
        mov     dl,[rKbFlag]
        mov     ah,[rKbFlag3]
        test    cs:[E0Flag],00000001b
        jz      @f
        or      ah,00000010b    ;e0flag
        mov     [rKbFlag3],ah
@@:
        and     cs:[E0Flag],11111110b
        cmp     al,0e0h
        jnz     @f
        or      cs:[E0Flag],00000001b
@@:
;;      cmp     al,0e0h
;;      jnz     @f
;;      or      ah,00000010b    ;e0flag
;;      mov     [rKbFlag3],ah
@@:
        pushf
        call    cs:[OldKbInt]
;       mov     al,ah
;       out     21h,al
;       pop     ax
        call    CheckHeHjKey
        jc      NoneHeHjKey
if      HotKey
        cmp     ax,HanjaKey
        jnz     @f
        test    dl,00000100b            ; Ctrl + HanJa
        jz      @f
        cmp     cs:[HeKey], 1
        je      @f
        cmp     cs:[HeKey], 2
        je      @f
        or      cs:[KbStat],ReqEnvrChg
        mov     [rBufferTail],bx
        jmp     short Int9hExit
@@:
endif   ; if HotKey
if      AltHotKey
        cmp     ax,HanEngKey
        jnz     @f
        test    dl,00001000b            ; Alt + HanEng
        jz      @f
        cmp     cs:[HeKey], 2
        je      @f
        or      cs:[KbStat],ReqEnvrChg
        or      cs:[HotStat],AltHotChg
        mov     [rBufferTail],bx
        jmp     short Int9hExit
@@:
endif   ; if AltHotKey
        test    cs:[KbStat],HanKeyinMode
        jz      Int9hExit
        cmp     ax,HanjaKey
        jnz     @f
        test    dl,00001000b            ; Alt + HanJa
        jz      @f
        mov     [rBufferTail],bx
        jmp     short Int9hExit
@@:
        call    PushKeyBuf
        jmp     short Int9hExit
NoneHeHjKey:
        test    cs:[KbStat],HanKeyinMode
        jz      Int9hExit
        test    cs:[KbStat],HEStat
        jz      Int9hExit
        test    [rKbFlag],01000000B
        jz      Int9hExit
        mov     bx,cs:[PreBufPtr]       ; get prev buffer pointer
        cmp     bx,[rBufferTail]
        je      Int9hExit
        mov     al,byte ptr [bx]
        cmp     al,'A'
        jb      Int9hExit
        cmp     al,'z'
        ja      Int9hExit
        cmp     al,'Z'
        jbe     @f
        cmp     al,'a'
        jb      Int9hExit
@@:
        xor     byte ptr [bx],00100000b
Int9hExit:
        mov     ax,[rBufferTail]         ; get ptr of ROM kb buffer tail
        mov     cs:[PreBufPtr],ax
        test    [rKbFlag3],Ext10xKey
        jz      @f
        or      cs:[KbStat],Ext10xKey
if      Kbd101On
        test    cs:[KbStat],UserDefineKey
        jnz     @f
else
        test    cs:[KbdType],SetKbd101
        jz      @f
endif
        and     [rKbFlag3],11110011b
        and     [rKbFlag],11110011b
        mov     ah,[rKbFlag1]
        and     ah,3
        shl     ah,1
        shl     ah,1
        or      [rKbFlag],ah
@@:
        @pop    dx,cx,bx,ds,ax
if      Debug
        pushf
        cli
        push    ax
        push    bx
        mov     ax,cs:[DebugData]
        mov     bx,ax
        and     bx,0f0h
        and     ax,0ff0fh
        sub     bx,10h
        and     bx,0f0h
        or      ax,bx
        out     10h,ax
        mov     cs:[DebugData],ax
        pop     bx
        pop     ax
        popf
endif   ; if Debug
        iret

;------------------------------------------------------------------------
;   << PushKeyBuf >>
; FUNCTION =  push / key to buffer
; INPUT   : AX = han/eng or hanja key, BX = buffer pointer
; OUTPUT  : none
; PROTECT :
; PushKeyBuf(AX,BX/-)
;       {
;       CX = BX;
;       if (CX == [rBufferTail])
;               {
;               CX = CX + 2;
;               if (CX == [rBufferEnd])
;                       CX = [rBufferStart];
;               }
;       if (CX == [rBufferHead])
;               Beep(-/-);
;       else
;               [BX] = AX;
;               [rBufferTail] = CX;
;       }
;
PushKeyBuf:
        mov     bx,[rBufferTail]
        mov     cx,bx
;       cmp     [rBufferTail],cx
;       jnz     @f
        inc     cx
        inc     cx
        cmp     cx,[rBufferEnd]
        jne     @f
        mov     cx,[rBufferStart]
@@:
        cmp     cx,[rBufferHead]
        je      KbBufFull
        mov     [bx],ax
        mov     [rBufferTail],cx
        ret
KbBufFull:
        call    Beep
        ret

PopKeyQueue PROC    Near
        push    di
        cli
        mov     di, rBufferHead
        cmp     di, rBufferTail
        je      @f
        inc     di
        inc     di
        cmp     di, rBufferEnd
        jne     @f
        mov     di, rBufferStart
@@:
        xchg    rBufferHead, di
        mov     di, [di]
@pkqTerm:
        sti
        pop     di
        ret
PopKeyQueue ENDP

INCLUDE debug.inc
;------------------------------------------------------------------------
;   << CheckHeHjKey >>
; FUNCTION =  check Han/Eng and Hanja key
; INPUT   : AL = raw code, AH = [rKbFlag3]
; OUTPUT  : (NC)AX = Han/Eng or Hanja code
;           (CY)AL = raw code
; PROTECT : BX
; CheckHeHjKey(AL/AX)
;       {
;       if ([KbStat] == UserDefineKey)
;               {
;               if (AL == [HeKey]), AX = HanEngKey, return(NC);
;               if (AL == [HjKey]), AX = HanjaKey, return(NC);
;               }
;       else
;               {
;               if ([MachineType] == AtMachine)
;                       {
;                       if ((AL = 0f2h) || (AL == 0f1h))
;                               {
;                               [HeKey] = 0f2h;
;                               [HjKey] = 0f1h;
;                               [KbStat] = [KbStat] || UserDefineKey;
;                               }
;                       }
;               else
;                       }
;                       if ((AL = 0f0h) || (AL == 0f1h))
;                               {
;                               [HeKey] = 0f0h;
;                               [HjKey] = 0f1h;
;                               [KbStat = [KbStat] || UserDefineKey;
;                               }
;                       }
;               if ([KbStat] == UserDefineKey)
;                       {
;                       if (AL == [HeKey]), AX = HanEngKey, return(NC);
;                       if (AL == [HjKey]), AX = HanjaKey, return(NC);
;                       }
;               else
;                       if ([rKbFlag3] == Ext10xKey)
;                               {
;                               if ([rKbFlag3] == /* E0 flag */)
;                                       {
;                                       if (AL == [HeKey]), AX = HanEngKey, return(NC);
;                                       if (AL == [HjKey]), AX = HanjaKey, return(NC);
;                                       }
;                               }
;                       else
;                               {
;                               if (AL == [HeKey]), AX = HanEngKey, return(NC);
;                               if (AL == [HjKey]), AX = HanjaKey, return(NC);
;                               }
;               }
;       return(CY);
;       }
;
EQUAL       =       0Dh
CTRL        =       1Dh
ALT         =       38h
SHIFT       =       2Ah
RSHIFT      =       36h
SPACE       =       39h
DEL         =       53h

ASSUME  DS:KBSEG
CheckHeHjKey:
        cmp     cs:[HeKey], 1
        jne     @checkNext
        cmp     al, SPACE
        jne     @noHotHe
@@:
        test    [rKbFlag], 00000010b    ; Check Left-Shift Pressed (HE)
    ;jnz     @HGHot
        jz      @f
        call    PopKeyQueue
        jmp     @HGHot
@@:
        test    [rKbFlag1], 00000001b   ; Check Left-Ctrl Pressed (HJ)
    ;jnz     @HJHot
        jz      @f
        call    PopKeyQueue
        jmp     @HJHot
@@:
        jmp     @noHotHj
@checkNext:
        cmp     cs:[HeKey], 2
        jne     @checkAltOrCtrl
        cmp     al, SHIFT
        je      @f
        cmp     al, RSHIFT
        jne     @noHotHj
@@:
        test    [rKbFlag], 00001000b      ; Check Alt Pressed (HE)
        jnz     @HGHot
        test    [rKbFlag], 00000100b      ; Check Ctrl Pressed (HJ)
        jnz     @HJHot
        jmp     SHORT @noHotHj

@checkAltOrCtrl:
        cmp     al, ALT
        je      @f
        cmp     al, CTRL
        jne     @noAltOrCtrl
@@:
        test    ah, 00000010b
        jz      @noHotHj
        cmp     al, cs:[HeKey]
        je      @HGHot
        cmp     al, cs:[HjKey]
        je      @HjHot
        jmp     @noHotHj

@noAltOrCtrl:
        cmp     al, cs:[HeKey]
        je      @HGHot
        cmp     cs:[HeKey], 0F0h
        jne     @noHotHe
        cmp     al, 0F2h
        jne     @noHotHe

@HGHot:
        mov     cx, HanEngKey
        jmp     @end
@noHotHe:
        cmp     al, 1
        je      @noHotHj
        cmp     al, cs:[HjKey]
        jne     @noHotHj
@HjHot:
        mov     cx, HanjaKey
        jmp     @end
@noHotHj:
        stc
        ret
@end:
        mov     ax, cx
        clc
        ret

if 0 ; 1993/7/21 skkhang
if      Kbd101On
        test    cs:[KbStat],UserDefineKey
        jnz     CompHeHjKey
@@:
        test    cs:[MachineType],AtMachine
        jnz     AtHe103Cmp
        cmp     al,0f0h
        je      @f
        cmp     al,0f1h
        jne     AtCmpEo
@@:
        mov     cs:[HeKey],0f0h
        mov     cs:[HjKey],0f1h
        or      cs:[KbStat],UserDefineKey
        jmp     AtCmpEo
AtHe103Cmp:
        cmp     al,0f2h
        je      @f
        cmp     al,0f1h
        jne     AtCmpEo
@@:
        mov     cs:[HeKey],0f2h
        mov     cs:[HjKey],0f1h
        or      cs:[KbStat],UserDefineKey
AtCmpEo:
        test    cs:[KbStat],UserDefinekey
        jnz     CompHeHjKey
        test    [rKbFlag3],Ext10xKey
        jz      CompHeHjKey
        test    ah,00000010b
        jnz     CompHeHjKey
else
        test    cs:[KbdType],SetKbd101
        jz      CompHeHjKey
        test    ah,00000010b
        jnz     CompHeHjKey
endif
        stc
        ret
CompHeHjKey:
        mov     cx,HanEngKey
        cmp     al,cs:[HeKey]
        jz      CompHeHjKeyS
        mov     cx,HanjaKey
        cmp     al,cs:[HjKey]
        jz      CompHeHjKeyS
if      VirtualKey
        test    [rKbFlag3],Ext10xKey
        jnz     @f
        mov     ah,[rKbFlag]
        test    ah,00000011b            ; LRShift
        jz      @f
        test    ah,00001100b            ; Alt+Ctrl
        jz      @f
        test    ah,00000100b            ;Ctrl
        jnz     CompHeHjKeyS
        mov     cx,HanEngKey
        jmp     CompHeHjKeyS
@@:
endif   ; VirtualKey
        stc
        ret
CompHeHjKeyS:
        mov     ax,cx
        clc
        ret
endif ;0


;************************************************************************
;**                                                                    **
;**                    KEYBOARD INTERRUPT 16H                          **
;**                                                                    **
;************************************************************************
;------------------------------------------------------------------------
;   << Kbd16hInt >>
; FUNCTION = keyboard interrupt service routine
; Int16(*/*)
;        {
;        Save BX,CX,DX,SI,DI,ES,DS,BP;
;        DS = ES = CS
;        BP = SP;
;        if ([KbStat] == ReqEnvrChg)
;                {
;                [KbStat] = [KbStat] || (not ReqEnvrChg)
;                if ([KbMisc] != RunningHot)
;                       {
;                       [KbMisc] = [KbMisc] || RunningHot
;                       EnvrChange(-/-);
;                       [KbMisc] = [KbMisc] && (not RunningHot)
;                }
;        if ([KbStat] != HanKeyinMode), /* call OldKbioInt() */;
;        else
;                {
;                switch(AH)
;                        {
;                        case 0    : GetCompleteCode(-/AX);
;                                    break;
;                        case 1    : CheckCompleteCode(-/ZF,AX);
;                                    break;
;                        case 2    : GetKbStatus(-/AX);
;                                    break;
;                        case 5    : PushCompleteCode(CX/AL);
;                                    break;
;                        case 10h  : GetCompleteCode(-/AX);
;                                    break;
;                        case 11h  : CheckCompleteCode(-/ZF,AX);
;                                    break;
;                        case 12h  : /* call OldKbioInt() */;
;                                    break;
;                        case 0f0h : GetInterimCode(-/AX);
;                                    break;
;                        case 0f1h : CheckInterimCode(-/ZF,AX);
;                                    break;
;                        case 0f2h : ChangeKbStatus(AL/AL);
;                                    break;
;                        case 0f3h : FlushKbBuffer(-/-);
;                                    break;
;                        case 0f4h : CtrlInterimDisplay(DX/-);
;                                    break;
;                        case 0f8h : xGetInterimCode(-/AX);
;                                    break;
;                        case 0f9h : xCheckInterimCode(-/ZF,AX);
;                                    break;
;                        case 0feh : CtrlHanJa(AL,BX,DL/AL,DL);
;                                    break;
;                        default   : /* call OldKbioInt() */;
;                        }
;                Restore BP,DS,ES,DI,SI,DX,CX,BX;
;                iret;
;                }
;        }
;

Extrn   EnvrChange:near, VideoActive:byte
PUBLIC  Int16

Int16:
ASSUME  DS:CODE, ES:CODE
if      Debug
        pushf
        cli
        push    ax
        push    bx
        mov     ax,cs:[DebugData]
        mov     bx,ax
        and     bx,0f000h
        and     ax,0fffh
        add     bx,1000h
        and     bx,0f000h
        or      ax,bx
        out     10h,ax
        mov     cs:[DebugData],ax
        pop     bx
        pop     ax
        popf
endif   ; if Debug
        sti
        cld
        @push   bx,cx,dx,si,di,es,ds,bp
        mov     bp,cs
        mov     ds,bp
        mov     es,bp
        mov     bp,sp
if      HotKey
        test    [KbStat],ReqEnvrChg
        jz      @f
        test    [KbMisc],RunningHot
        jnz     @f
        or      [KbMisc],RunningHot
        inc     [VideoActive]
        call    EnvrChange
        dec     [VideoActive]
if      AltHotKey
        and     [HotStat],not AltHotChg
endif   ;   AltHotKey
        and     [KbStat],not ReqEnvrChg
        and     [KbMisc],not RunningHot
@@:
endif   ; if HotKey
        sub     bx,bx
        mov     bl,ah
        add     bl,10h
        cmp     bl,21h
        ja      OldInt16Call
        test    cs:[KbStat],HanKeyinMode
        jz      OldInt16Call
        cmp     bl,15h
        jbe     @f
        sub     bl,10
@@:
        shl     bx,1
        call    [bx+Int16Tbl]
        @pop    bp,ds,es,di,si,dx,cx,bx
if      Debug
        pushf
        cli
        push    ax
        push    bx
        mov     ax,cs:[DebugData]
        mov     bx,ax
        and     bx,0f000h
        and     ax,0fffh
        sub     bx,1000h
        and     bx,0f000h
        or      ax,bx
        out     10h,ax
        mov     cs:[DebugData],ax
        pop     bx
        pop     ax
        popf
endif   ; if Debug
        iret

OldInt16jmp     label   word
        add     sp,2
OldInt16Call:
        @pop    bp,ds,es,di,si,dx,cx,bx
        cmp     ah,0f8h
        jnz     @f
        mov     ah,010h
@@:
        cmp     ah,0f9h
        jnz     @f
        mov     ah,011h
@@:
        cmp     ah,0f0h
        jnz     @f
        mov     ah,000h
@@:
        cmp     ah,0f1h
        jnz     @f
        mov     ah,001h
@@:
if      Debug
        pushf
        call    cs:[OldKbioInt]
        pushf
        cli
        push    ax
        push    bx
        mov     ax,cs:[DebugData]
        mov     bx,ax
        and     bx,0f000h
        and     ax,0fffh
        sub     bx,1000h
        and     bx,0f000h
        or      ax,bx
        out     10h,ax
        mov     cs:[DebugData],ax
        pop     bx
        pop     ax
        popf
        iret
else
        jmp     cs:[OldKbioInt]
endif   ; if Debug

Int16Tbl       label   word
        dw      offset  GetInterimCode          ;AH=F0H
        dw      offset  CheckInterimCode
        dw      offset  ChangeKbStatus
        dw      offset  FlushKbBuffer
        dw      offset  CtrlInterimDisplay
        dw      offset  OldInt16jmp
        dw      offset  OldInt16jmp
        dw      offset  OldInt16jmp
        dw      offset  GetInterimCode
        dw      offset  CheckInterimCode
        dw      offset  OldInt16jmp
        dw      offset  OldInt16jmp
        dw      offset  OldInt16jmp
        dw      offset  OldInt16jmp
        dw      offset  CtrlHanJa               ;AH=FEH
        dw      offset  OldInt16jmp
        dw      offset  GetCompleteCode         ;AH=00H
        dw      offset  CheckCompleteCode       ;AH=01H
        dw      offset  GetKbStatus             ;AH=02H
        dw      offset  OldInt16jmp             ;AH=03H
        dw      offset  OldInt16jmp             ;AH=04H
        dw      offset  PushCompleteCode        ;AH=05H
        dw      offset  GetCompleteCode         ;AH=10H
        dw      offset  CheckCompleteCode       ;AH=11H


;========================================================================
;   << GetCompleteCode >>
; FUNCTION = get complete code
; INPUT   : none
; OUTPUT  : AX = KBD scan code & system scan code
; PROTECT : AX
; GetCompleteCode(AH/AX)
;        {
;        [TmpKbdType] = AH;
;        while (![CompleteCharCnt])
;                {
;                DispInterimChar(-/-);
;                AH = [TmpKbdType];
;                /* call [OldKbioInt] */
;                Automata(AX/-);
;                }
;        ClearInterimChar(-/-);
;        GetCompleteChar(-/AX,flag);
;        }

GetCompleteCode:
        mov     [TmpKbdType],ah
WaitCompleteKeyin:
        cmp     [CompleteCharCnt],0
        jne     @f
        call    DispInterimChar
        call    WaitKeyin
        call    Automata
        jmp     WaitCompleteKeyin
@@:
        call    ClearInterimChar
        call    GetCompleteChar
        call    Filter84
        ret
;------------------------------------------------------------------------
Filter84:
        pushf
        test    [TmpKbdType],Ext10xKey
        jnz     @f
        cmp     ah,0f0h
        jae     @f
        mov     bx,ax
        mov     al,0
        cmp     bl,0e0h
        jz      @f
        mov     ax,bx
        cmp     bh,0e0h
        jnz     @f
        mov     ah,35h
        cmp     bl,2fh
        jz      @f
        mov     ah,1ch
        cmp     bl,0dh
        jz      @f
        cmp     bl,0ah
        jz      @f
        mov     ax,bx
@@:
        popf
        ret


;========================================================================
;   << GetInterimCode >>
; FUNCTION = get interim code
; INPUT   : none
; OUTPUT  : AX = KBD scan code & system scan code
; PROTECT : AX
; GetInterimCode(AH/AX)
;        {
;        AH = AH && 00001000b;
;        AH = AH shl 1;
;        [TmpKbdType] = AH;
;        while (![CompleteCharCnt]) || (![InterimCharCnt])
;                {
;                AH = [TmpKbdType];
;                /* call [OldKbioInt] */
;                Automata(AX/-);
;                }
;        if ([CompleteCharCnt])
;                GetCompleteChar(-/AX,flag);
;        else
;                GetInterimChar(-/AX,flag);
;        }
GetInterimCode:
        and     ah,00001000b
        shl     ah,1
        mov     [TmpKbdType],ah
WaitInterimKeyin:
        cmp     [CompleteCharCnt],0
        jne     GetCompleteCharCall
        cmp     [InterimCharCnt],0
        jnz     GetInterimCharCall
        call    WaitKeyin
        call    Automata
        jmp     WaitInterimKeyin
GetCompleteCharCall:
        call    GetCompleteChar
        call    Filter84
        jmp     @f
GetInterimCharCall:
        call    GetInterimChar
@@:
        ret
;------------------------------------------------------------------------
WaitKeyin:
if      HotKey
        test    [KbStat],ReqEnvrChg
        jz      @f
        test    [KbMisc],RunningHot
        jnz     @f
        or      [KbMisc],RunningHot
        inc     [VideoActive]
        call    EnvrChange
        dec     [VideoActive]
if      AltHotKey
        and     [HotStat],not AltHotChg
endif   ;   AltHotKey
        and     [KbStat],not ReqEnvrChg
        and     [KbMisc],not RunningHot
@@:
endif   ; if HotKey
        mov     ah,[TmpKbdType]
        inc     ah
        pushf
        call    [OldKbioInt]
        jz      WaitKeyin
        mov     ah,[TmpKbdType]
        pushf
        call    [OldKbioInt]
        ret


;========================================================================
;   << CheckCompleteCode >>
; FUNCTION = check complete code
; INPUT   : none
; OUTPUT  : if ZF = 0, AX = KBD scan code & system scan code
; PROTECT : AX
; CheckCompleteCode(AH/AX,zero-flag)
;        {
;        [TmpKbdType] = AH;
;        while ((![CompleteCharCnt]) ||
;               (AH = [TmpKbdType], /* call [OldKbioInt] */ = NZ))
;                {
;                DispInterimChar(-/-);
;                AH = [TmpKbdType];
;                - AH;
;                /* call [OldKbioInt] */
;                Automata(AX/-);
;                }
;        AX = [CompleteCharBuf];
;        if ([CompleteCharCnt])
;                /* reset zero-flag */
;        else
;                /* set zero-flag */
;        Restore BP,BP,DS,ES,DI,SI,DX,CX,BX;     /* include return addr */
;        far ret 2;
;        }

CheckCompleteCode:
        dec     ah
        mov     [TmpKbdType],ah
CheckCompleteKeyin:
        mov     ax,[CompleteCharBuf]
        cmp     [CompleteCharCnt],0
        jne     @f
        call    DispInterimChar
        mov     ah,[TmpKbdType]
        inc     ah
        pushf
        call    [OldKbioInt]
        jz      @f
        mov     ah,[TmpKbdType]
        pushf
        call    [OldKbioInt]
        call    Automata
        jmp     CheckCompleteKeyin
@@:
        call    Filter84
        pop     bp
        @pop    bp,ds,es,di,si,dx,cx,bx
if      Debug
        pushf
        cli
        push    ax
        push    bx
        mov     ax,cs:[DebugData]
        mov     bx,ax
        and     bx,0f000h
        and     ax,0fffh
        sub     bx,1000h
        and     bx,0f000h
        or      ax,bx
        out     10h,ax
        mov     cs:[DebugData],ax
        pop     bx
        pop     ax
        popf
endif   ; if Debug
FarRet2 proc    far
        ret     2
FarRet2 endp


;========================================================================
;   << CheckInterimCode >>
; FUNCTION = check interim code
; INPUT   : none
; OUTPUT  : if ZF = 0, AX = KBD scan code & system scan code
; PROTECT : AX
; CheckInterimCode(AH/AX,zero-flag)
;        {
;        AH = AH && 00001000b;
;        AH = AH shl 1;
;        + AH;
;        [TmpKbdType] = AH;
;        if !((![CompleteCharCnt]) || ([InterimCharCnt] == 1))
;                {
;                while ((![CompleteCharCnt]) || (![InterimCharCnt]) ||
;                       (AH = [TmpKbdType], /* call [OldKbioInt] */ = NZ))
;                        {
;                        AH = [TmpKbdType];
;                        - AH;
;                        /* call [OldKbioInt] */
;                        Automata(AX/-);
;                        }
;                }
;        if ([CompleteCharCnt])
;                {
;                AX = [CompleteCharBuf];
;                /* reset zero-flag */
;                }
;        else
;                {
;                if ([InterimCharCnt] == 0)
;                        /* set zero-flag */
;                else
;                        {
;                        AX = [InterimCharBuf];
;                        /* reset zero-flag */
;                        }
;                }
;        Restore BP,BP,DS,ES,DI,SI,DX,CX,BX;
;        far ret 2;
;        }

CheckInterimCode:
        and     ah,00001000b
        shl     ah,1
        mov     [TmpKbdType],ah
CheckInterimKeyin:
        mov     ax,[CompleteCharBuf]
        cmp     [CompleteCharCnt],0
        jne     CheckInterimCodeRet
        cmp     [InterimCharCnt],1
        jz      CheckInterimCode2nd
        mov     ah,[TmpKbdType]
        inc     ah
        pushf
        call    [OldKbioInt]
        jz      CheckInterimCode1st
        mov     ah,[TmpKbdType]
        pushf
        call    [OldKbioInt]
        call    Automata
        jmp     CheckInterimKeyin
CheckInterimCode2nd:
        mov     ax,[InterimCharBuf+2]
        jmp     short @f
CheckInterimCode1st:
        mov     ax,[InterimCharBuf]
@@:
        cmp     [InterimCharCnt],0
CheckInterimCodeRet:
        call    Filter84
        pop     bp
        @pop    bp,ds,es,di,si,dx,cx,bx
if      Debug
        pushf
        cli
        push    ax
        push    bx
        mov     ax,cs:[DebugData]
        mov     bx,ax
        and     bx,0f000h
        and     ax,0fffh
        sub     bx,1000h
        and     bx,0f000h
        or      ax,bx
        out     10h,ax
        mov     cs:[DebugData],ax
        pop     bx
        pop     ax
        popf
endif   ; if Debug
FarRet  proc    far
        ret     2
FarRet  endp


;========================================================================
;   << GetKbStatus >>
; FUNCTION = get keyboard status(84/86 KBD)
; INPUT   : none
; OUTPUT  : AX = 84/86 KBD status
; PROTECT : none
; GetKbStatus(AH/AX)
;        {
;        AH = [KbStat]
;        AH = AH && Ext10xKey
;        [TmpKbdType] = AH
;        while (([CompleteCharCnt] < 16) &&
;               (AH = [TmpKbdType] || 1, /* call [OldKbioInt] */ = NZ))
;                {
;                ClearInterimChar(-/-);
;                AH = [TmpKbdType];
;                /* call [OldKbioInt] */
;                Automata(AX/-);
;                }
;        AH = 2;
;        /* call [OldKbioInt] */
;        AH = [KbStat];
;        AH = AH && (JJStat || HEStat);
;        }

GetKbStatus:
        mov     ah,[KbStat]
        and     ah,Ext10xKey
        mov     [TmpKbdType],ah
@@:
        cmp     [InterimCharCnt],1
        jz      @f
        cmp     [CompleteCharCnt],16
        jae     @f
        mov     ah,[TmpKbdType]
        inc     ah
        pushf
        call    [OldKbioInt]
        jz      @f
;       call    ClearInterimChar
        mov     ah,[TmpKbdType]
        pushf
        call    [OldKbioInt]
        call    Automata
        jmp     short @b
@@:
        mov     ah,2
        pushf
        call    [OldKbioInt]
        mov     ah,[KbStat]
        and     ah,(JJStat or HEStat)
        ret

;========================================================================
;   << PushCompleteCode >>
; FUNCTION = push complete code
; INPUT   : CX = KBD scan code & system scan code
; OUTPUT  : if error, AL = -1
; PROTECT : none
; PushCompleteCode(-/-)
;        {
;        AutoReset(-/-);
;        pushf
;        /* call OldKbioInt() */
;        }

PushCompleteCode:
        call    AutoReset
        pushf
        call    [OldKbioInt]
        push    ds
ASSUME  DS:KBSEG
        mov     bx,seg KbSeg
        mov     ds,bx
        mov     bx,[rBufferTail]         ; get ptr of ROM kb buffer tail
        mov     cs:[PreBufPtr],bx
ASSUME  DS:CODE
        pop     ds
        ret


;========================================================================
;   << FlushKbBuffer >>
; FUNCTION = flush kbd buffer & status flag without interim code
; INPUT   : none
; OUTPUT  : none
; PROTECT : none
; FlushKbBuffer(-/-)
;        {
;        /* Save DS */
;        DS = KbSeg;
;        BX = [rBufferStart];
;        [rBufferTail] = BX;
;        [rBufferHead] = BX;
;        /* Restore DS */
;        [CompleteCharCnt] = 0;
;        AutoReset(-/-);
;        }

FlushKbBuffer:
        push    ds
ASSUME  DS:KBSEG
        mov     bx,Seg KbSeg
        mov     ds,bx
        mov     bx,[rBufferStart]
        mov     [rBufferTail],bx
        mov     [rBufferHead],bx
ASSUME  DS:CODE
        pop     ds
        mov     [PreBufPtr],bx
        mov     [CompleteCharCnt],0
        call    AutoReset
        ret

;========================================================================
;   << CtrlInterimDisplay >>
; FUNCTION = interim display control
; INPUT   : DX = -1(interim display) or 0fefeh(interim not display)
; OUTPUT  : none
; PROTECT : none
; CtrlInterimDisplay(-/-)
;        {
;        if (DX == 0ffffh), [KbMisc] = [KbMisc] || InterimCtrlDisp;
;        if (DX == 0fefeh), [KbMisc] = [KbMisc] && !(InterimCtrlDisp);
;        }

CtrlInterimDisplay:
        cmp     dx,0ffffh
        jne     @f
        or      [KbMisc],InterimCtrlDisp
@@:
        cmp     dx,0fefeh
        jne     @f
        and     [KbMisc],not InterimCtrlDisp
@@:
        ret


;========================================================================
;   << ChangeKbStatus >>
; FUNCTION = change hangeul status
; INPUT   : AL = Hangeul/Hanja/Junja status
; OUTPUT  : if error, AL = -1
; PROTECT : none
; ChangeKbStatus(AL/AL)
;        {
;        BH = AL;
;        BL = AL && 00000011b            /* junja flag */
;        switch(BL)
;                case 0: SetBanja(-/AL)
;                        break;
;                case 1: SetJunja(-/AL)
;                        break;
;                case 2: ToggleBanJun(-/AL)
;                        break;
;                case 3: ChangeError(-/AL)
;        if (AL = 0)
;                {
;                BL = BL && 00001000b;   /* han/eng flag */
;                switch(BL)
;                        case 0:
;                                if ([KbStat] == HEStat)
;                                        {
;                                        [KbSTat] = [KbStat] && !(HEStat);
;                                        AutoReset(-/-);
;                                        }
;                                else
;                                        [KbSTat] = [KbStat] && !(HEStat);
;                                break;
;                        case 8:
;                                [KbSTat] = [KbStat] || HEStat;
;                                break;
;                }
;        }
; SetBanja(-/AL)
;        {
;        [KbStat] = [KbStat] && !(JJStat);
;        AL = 0;
;        }
; SetJunja(-/AL)
;        {
;        if ([HjStat] == HjLoaded)
;                {
;                [KbStat] = [KbStat] || JJStat;
;                }
;        else
;                AL = -1;
;        }
; ToggleBanJun(-/AL)
;        {
;        if ([KbStat] == JJStat)
;                SetBanja(-/AL);
;        else
;                SetJunja(-/AL);
;        }
; ChangeError(-/AL)
;        {
;         AL = -1, return;
;        }

ChangeKbStatus:
ifdef   WINNT
        cmp     cs:[ActiveCodePage], 949 ;For NT 5.0. 949=WanSungCP
        jz      @f
        mov     al,-1
        jmp     ChangeKbStatusRet
@@:
endif
        xor     bx,bx
        mov     bl,al
        and     bl,00000011b
        shl     bl,1
        mov     si,bx
        mov     bh,al
        call    [si+BanJunTbl]
        cmp     al,0
        jne     ChangeError
        and     bh,00001000b
        shr     bh,1
        mov     bl,[KbStat]
        and     [KbStat],11111011b
        or      [KbStat],bh
        xor     bl,bh
        test    bl,00000100b
        jz      ChangeKbStatusRet
        call    AutoReset
ChangeKbStatusRet:
        ret
SetHanInStat:
        or      [KbStat],HEStat
        ret

BanJunTbl       label   word
        dw      offset  SetBanja
        dw      offset  SetJunja
        dw      offset  ToggleBanJun
        dw      offset  ChangeError

SetBanja:
        and     [KbStat],not JJStat
        xor     al,al
        ret

SetJunja:
        mov     al,-1
        test    [HjStat],HjLoaded
        jz      @f
        or      [KbStat],JJStat
        xor     al,al
@@:
        ret

ToggleBanJun:
        test    [KbStat],JJStat
        jz      @f
        jmp     SetBanja
@@:
        jmp     SetJunja

ChangeError:
        mov     al,-1
        ret


;========================================================================
;   << CtrlHanJa >>
; FUNCTION : hanja function(see each sun-routines)
; INPUT    : AL=0, DL=0/1 -  /
; OUTPUT   : AL=0/FFH -  /
; INPUT    : AL=1
; OUTPUT   : DL=0/1 -  / 
; INPUT    : AL=2, BX - (1st,2nd)
; OUTPUT   : AL=0/1/2 - //.
;            BX -(1st,2nd)
; INPUT    : AL=3, BX - (1st,2nd)
; OUTPUT   : AL=0/FFH -  /
;            ES:BX -   (/1st/2nd/1st/...2nd/0)
; INPUT    : AL=4, DL=
; OUTPUT   : AL=0/FFH -  /
; PROTECT  : none
; CtrlHanJa(*/*)
;        {
;        if ([HjStat] == HjLoaded)
;                BX = [BP+rBX]
;                {
;                switch(AL)
;                        {
;                        case 0 :
;                                [HjStat] = [HjStat] && !(HjModeEnable);
;                                [HjStat] = [HjStat] || DL;
;                                break;
;                        case 1 :
;                                DL = [HjStat] && (HjModeEnable);
;                                [BP+rDX] = DL;
;                                break;
;                        case 2 : ChangeHangeul2Hanja(BX/AL,BX);
;                                break;
;                        case 3 :
;                                [BP + rKES] = CS;
;                                [BP + rKBX] = offset MenuBuffer;
;                                if (MakeHanjaList(BX/AL); AL == 0)
;                                        {
;                                        if ([TotalMenuCnt] > 1) ret(AL=FFh);
;                                        -[TotalMenuCnt]
;                                        DI = DI-4
;                                        ES:[DI] = 0
;                                        }
;                                break;
;                        case 4 :
;                                AH = 0Fh
;                                int 10h
;                                if DL < [MaxRows]
;                                        [HjMenuLine] = DL;
;                                        AL = 0;
;                                else
;                                        AL = -1;
;                                break;
;                        default: AL = -1;
;                        }
;                }
;        else
;                AL = -1;
;        }
;
; ChangeHangeul2Hanja(BX/AL,BX)
;        {
;        MakeHanjaList(BX/AL)
;        if ((!AL) && ([TotalMenuCnt] > 1))
;                {
;                SaveMenuline(-/-);
;                TrapLoop:
;                        AH = cs:[KbStat] && Ext10xKey
;                        /* call OldKbioInt */
;                if (TrapHjMenu(AX/flag,AL,BX) == NC && NZ), goto TrapLoop; ;                if (
;                else CY RestoreMenuLine(-/-); ret(AL=1);
;                [BP+rBX] = BX;
;                RestoreMenuline(-/-);
;                ret(AL=0);
;                }
;        else
;                ret(AL=2);
;        }
;
; MakeHanjaList(BX/AL,ES,BX)
;        {
;        [TotalMenuCnt] = 0;               /* clear counter */
;        AX = BX;
;        if [CodeStat] == Chab)
;                if (ChgCh2Ks(AX/AX,BX,flag) == CY), return(AL = -1);
;        DI = MenuBuffer;
;        if (MakeHanjaListHg(AX,DI/AX,DI,flag) == NC)
;                {
;                MakeHanjaListUdc(AX,DI/AX,DI,flag);
;                if ([CodeStat] == Chab)
;                        {
;                        DI = MenuBuffer;
;                        SI = DI;
;                        CL = [TotalMenuCnt];
;                        while (CL)
;                                {
;                                AL = [SI+1];
;                                AH = [SI];
;                                if ((ChgKs2Ch(AX/AX,BX,flag) == NC)
;                                        {
;                                        [DI+1] = AL;
;                                        [DI] = AH;
;                                        DI = DI + 2;
;                                        }
;                                SI = SI + 2;
;                                -CL;
;                                }
;                        AX = (DI - SI)/2;
;                        [TotalMenuCnt] = AL;
;                        }
;                CL = [MenuBuffer];
;                SI = MenuBuffer;
;                DI = SI;
;                while (CL)
;                        {
;                        AX = [SI];
;                        xchg AL,AH;
;                        [DI] = AX;
;                        DI = DI + 2;
;                        SI = SI + 2;
;                        -CL;
;                        }
;                ES:[DI] = 0
;                AL = 0;
;                }
;        else
;                AL = -1;
;        }

EXTRN   ChgCh2Ks:near,ChgKs2Ch:near

CtrlHanJa:
        mov     byte ptr [bp+rDX],0     ; assume hanja disabled(DL)
        test    [HjStat],HjLoaded
        jz      CtrlHanJaErr
        cmp     al,4
        ja      CtrlHanJaErr
        mov     bx,[bp+rBX]
        mov     cl,al
        xor     ch,ch
        mov     si,cx
        shl     si,1
        jmp     [si+HanjaSupportTbl]
CtrlHanJaErr:
        mov     al,-1
        ret

HanjaSupportTbl label   word
        dw      SetHjMode
        dw      GetHjMode
        dw      ChangeHangeul2Hanja
        dw      Hg2HjList
        dw      SetMenuLine

SetHjMode:
        and     [HjStat],not HjModeEnable
        and     dl,HjModeEnable
        or      [HjStat],dl
        ret

GetHjMode:
        mov     dl,[HjStat]
        and     dl,HjModeEnable
        mov     [bp+rDX],dl
        ret

ChangeHangeul2Hanja:
        call    MakeHanjaList
        or      al,al
        jnz     NoHanjaCode
        cmp     [TotalMenuCnt],1
        jbe     NoHanjaCode
        call    SaveMenuline
@@:
        mov     ah,cs:[KbStat]
        and     ah,Ext10xKey
        pushf
        call    [OldKbioInt]
        call    TrapHjMenu
        jc      @f
        jz      @b
        mov     [bp+rBX],ax
        call    RestoreMenuline
        xor     al,al
        ret
@@:
        call    RestoreMenuline
        mov     al,1
        ret
NoHanjaCode:
        mov     al,2
        ret

Hg2HjList:
        mov     [bp + rES],cs
        mov     ax,offset MenuBuffer
        dec     ax
        mov     [bp + rBX],ax
        call    MakeHanjaList
        or      al,al
        jnz     @f
        cmp     [TotalMenuCnt],1
        jbe     ReturnFail
        dec     [TotalMenuCnt]
        sub     di,4
        stosw
@@:
        ret

SetMenuLine:
        mov     ah,0fh
        int     10h
        mov     al,-1
        cmp     dl,ah
        jae     @f
        mov     [HjMenuLine],dl
        mov     al,0
@@:
        ret

MakeHanjaList:
        mov     [TotalMenuCnt],0
        mov     ax,bx
        test    [CodeStat],chab
        jz      @f
        call    ChgCh2Ks
        jc      ReturnFail
@@:
        mov     di,offset MenuBuffer
        call    MakeHanjaListHg
        jc      ReturnFail
        call    MakeHanjaListUdc
        test    [CodeStat],Chab
        jz      MakeHjWan
        mov     di,offset MenuBuffer
        mov     si,di
        mov     cl,[TotalMenuCnt]
        dec     cl
        cmp     cl,0
        jz      MakeHjcho
MakeHJListLoop:
        lodsw
        call    ChgKs2Ch
        jc      @f
        stosw
@@:
        dec     cl
        jnz     MakeHjListLoop
MakeHjcho:
        lodsw
        call    Ks2Ch
        stosw
        sub     di,si
        shr     di,1
        mov     ax,di
        sub     [TotalMenuCnt],al
MakeHjWan:
        mov     cl,[TotalMenuCnt]
        mov     si,offset MenuBuffer
        mov     di,si
@@:
        lodsw
        xchg    al,ah
        stosw
        dec     cl
        jnz     @b
        xor     ax,ax
        stosw
        ret
ReturnFail:
        mov     al,-1
        ret


;------------------------------------------------------------------------
; << DisplayHanja >>
; FUNCTION = display Hj menu (end with null)
; INPUT   : none ([MenuPtr], [MenuBuffer], [CurrMenuCnt])
; OUTPUT  : none
; PROTECT : ax, bx, cx, dx, si
; DisplayHanja()
;       {
;       BH = [SaveCurrPage];
;       DX = CX = 0;
;       DH = [HjMenuLine];
;       AH = 2;
;       INT 10h;
;       CL = [CrtMaxCols]
;       BL = 70h;
;       AH = 09;
;       AL = ' ';
;       INT 10h;
;       DL = 15;
;       AH = 2;
;       INT 10h;
;       BH = 0
;       BX = [MenuPtr] * 2;
;       SI = BX+offset MenuBuffer;
;       CX=[CurrMenuCnt];
;       BH = '0';
;       BL = 70h;
;       if ([ModeId] == 6*2)
;               bl = 0fh;
;       while (CL != 0)
;               {
;               AL = BH;
;               AH = 0Eh;
;               INT 10h;
;               AL = '.';
;               INT 10h;
;               /* display [DS:SI];word */
;               /* display '  ' */
;               +BH;
;               -CX;
;               }
;       if ( [DS:SI] != 0 )  ;the end of hanja list
;               /* display NextMenuMsg */
;       return;
;       }
NextMenuMsg     db      '...',0
ModeVal db      0

DisplayHanja:
        mov     bh,[SaveCurrPage]
        xor     cx,cx
        mov     dx,cx
        mov     dh,[HjMenuLine]
        mov     ah,2
        int     10h
        mov     cl,[CrtMaxCols]
        mov     bl,70H
        mov     ah,9
        mov     al,' '
        int     10h
        cmp     [ModeVal],6*2
        jnz     @f
        mov     ax,00601h
        mov     bh,0ffh
        mov     cx,dx
        mov     dl,[CrtMaxCols]
        dec     dl
        int     10h
        mov     bh,[SaveCurrPage]
        xor     ch,ch
@@:
        mov     dl,15
        mov     ah,2
        int     10h
        xor     bh,bh
        mov     bl,[MenuPtr]
        shl     bx,1
        mov     si,offset MenuBuffer
        add     si,bx
        mov     cl,[CurrMenuCnt]
        mov     bh,'0'
        mov     bl,70h
        cmp     [ModeVal],6*2
        jnz     @f
        mov     bl,0ffh
@@:
        mov     al,bh
        mov     ah,0Eh
        int     10h
        mov     ah,0Eh
        mov     al,'.'
        int     10h
        lodsw
        mov     dx,ax
        mov     ah,0Eh
        int     10h
        mov     al,dh
        mov     ah,0Eh
        int     10h
        mov     al,' '
        mov     ah,0Eh
        int     10h
        mov     al,' '
        mov     ah,0Eh
        int     10h
        inc     bh
        loop    @b
        lodsw
        or      ax,ax
        jz      DisplayHanjaRet
        mov     si,offset NextMenuMsg
@@:
        lodsb
        or      al,al
        jz      DisplayHanjaRet
        mov     ah,0Eh
        int     10h
        jmp     @b
DisplayHanjaRet:
        ret


;------------------------------------------------------------------------
;   << DispInterimChar >>
; FUNCTION =   DISPLAY
; INPUT   : none
; OUTPUT  : none
; PROTECT : AX,BX,CX,DX
; DispInterimChar(-/-)
;        {
;        if !(([HjMenuStat] == HjMenuMode) || ([KbMisc] != HaveInterim) ||
;            ([KbMisc] != InterimCtrlDisp) || ([InterimCharCnt] < 2) ||
;            [HanStat] == Han1st))
;                {
;                [DisplayStat] = [DisplayStat] && !(RunEsc);
;                [KbMisc] == [KbMisc] && !(HaveInterim);
;                AH = 0FH;
;                Int 10h;
;                [InterimCurPage] = BH;
;                [InterimMaxCols] = AH-1;
;                AH = 3;
;                Int 10h;
;                if (([KbMisc] == SavedInterim) &&
;                    (([InterimCurPage] != bh) || ([InterimCurPos] != dx)))
;                       {
;                       [KbMisc] = [KbMISC] && !(SavedInterim);
;                       xchg BH,[InterimCurPage];
;                       xchg DX,[InterimCurPos];
;                       AH = 2;
;                       int 10h
;                       AH = 8;
;                       int 10h
;                       if ([DispIChar1] == al)
;                               {
;                               DL+
;                               AH = 2
;                               int 10h
;                               AH = 8
;                               int 10h
;                               if ([DispIChar2] == al)
;                                       {
;                                       CX = 1
;                                       DL-
;                                       AH = 2
;                                       int 10h
;                                       AH = 8
;                                       int 10h
;                                       BL = AH
;                                       AL = [SavedChar1]
;                                       AH = 9
;                                       int 10h
;                                       DL+
;                                       AH = 2
;                                       int 10h
;                                       AH = 8
;                                       int 10h
;                                       BL = AH
;                                       AL = [SavedChar2]
;                                       AH = 9
;                                       int 10h
;                                       }
;                               }
;                       xchg BH,[InterimCurPage];
;                       xchg DX,[InterimCurPos];
;                       AH = 2;
;                       int 10h
;                       }
;                if (DL >= [InterimMaxCols])
;                        {
;                        AH = 8;
;                        Int 10h
;                        BL = AH;
;                        AX = 0e20h;
;                        Int 10h
;                        AH = 3
;                        Int 10h
;                        }
;                CX = 1;
;                AH = 8
;                Int 10h
;                if ([KbMisc] != SavedInterim)
;                        {
;                        [InterimCurPos] = DX;
;                        [SavedChar1] = AL
;                        }
;                BL = AH;
;                AL = [InterimCharBuf];
;                AH = 9;
;                Int 10h
;                +DL;
;                AH = 2;
;                Int 10h
;                AH = 8;
;                Int 10h
;                if ([KbMisc] != SavedInterim)
;                        {
;                        [KbMisc] = [KbMisc] || SavedInterim;
;                        [SavedChar2] = AL
;                        }
;                BL = AH;
;                AL = [InterimCharBuf+2];
;                AH = 9;
;                Int 10h
;                -DL;
;                AH = 2;
;                Int 10h
;                }
;        }

DispInterimCharRet:
        ret
DispInterimChar:
        test    [HjMenuStat],HjMenuMode
        jnz     DispInterimCharRet
;       test    [KbMisc],HaveInterim
;       jz      DispInterimCharRet
        test    [KbMisc],InterimctrlDisp
        jz      DispInterimCharRet
        cmp     [InterimCharCnt],2
        jb      DispInterimCharRet
        test    [HanStat],Han1st
        jnz     DispInterimCharRet
        and     [DisplayStat],not RunEsc
;       and     [KbMisc],not HaveInterim
        mov     ah,0fh
        int     10h
        mov     ah,3
        int     10h
        cmp     [InterimDispP],dx
        jnz     @f
        mov     al,byte ptr [InterimCharBuf+2]
        cmp     al,[DispIChar2]
        jnz     @f
        mov     al,byte ptr [InterimCharBuf]
        cmp     al,[DispIChar1]
        jnz     @f
        jmp     DispInterimCharRet
@@:

        mov     ah,0fh
        int     10h
        dec     ah
        mov     [InterimMaxCols],ah
        mov     ah,3
        int     10h
        test    [KbMisc],SavedInterim
        jz      NormalAct
        cmp     [InterimCurPage],bh
        jnz     @f
        cmp     [InterimCurPos],dx
        jz      NormalAct
@@:
        and     [KbMisc],not SavedInterim
NormalAct:
        mov     [InterimCurPage],bh
        cmp     dl,[InterimMaxCols]
        jb      @f
        mov     ah,8
        int     10h
        mov     bl,ah
        mov     ax,0e20h
        int     10h
        mov     ah,3
        int     10h
@@:
        mov     cx,1
        mov     ah,8
        int     10h
        test    [KbMisc],SavedInterim
        jnz     @f
        mov     [InterimCurPos],dx
        mov     [SavedChar1],al
@@:
        mov     bl,ah
        mov     al,byte ptr [InterimCharBuf]
        mov     [DispIChar1],al
        mov     [InterimDispP],dx
        mov     ah,9
        int     10h
        inc     dl
        mov     ah,2
        int     10h
        mov     ah,8
        int     10h
        test    [KbMisc],SavedInterim
        jnz     @f
        or      [KbMisc],SavedInterim
        mov     [SavedChar2],al
@@:
        mov     bl,ah
        mov     al,byte ptr [InterimCharBuf+2]
        mov     [DispIChar2],al
        mov     ah,9
        int     10h
        dec     dl
        mov     ah,2
        int     10h
        ret


;------------------------------------------------------------------------
;   << ClearInterimChar >>
; FUNCTION =   CLEAR
; INPUT   : none
; OUTPUT  : none
; PROTECT : AX,BX,CX,DX
; ClearInterimChar(-/-)
;        {
;        if ([KbMisc] == SavedInterim)
;                {
;                [KbMisc] = [KbMisc] && !(SavedInterim);
;                if ([HanStat] != Han1st)
;                        {
;                        [DisplayStat] = [DisplayStat] && !(RunEsc);
;                        AH = 0Fh
;                        Int 10h
;                        AH = 3
;                        Int 10h
;                        CX = 1
;                        if (([InterimCurPage] != bh) || ([InterimCurPos] != dx))
;                               {
;                               xchg BH,[InterimCurPage];
;                               xchg DX,[InterimCurPos];
;                               AH = 2;
;                               int 10h
;                               AH = 8;
;                               int 10h
;                               if ([DispIChar1] == al)
;                                       {
;                                       DL+
;                                       AH = 2
;                                       int 10h
;                                       AH = 8
;                                       int 10h
;                                       if ([DispIChar2] == al)
;                                               {
;                                               DL-
;                                               AH = 2
;                                               int 10h
;                                               AH = 8
;                                               }
;                                       else
;                                               {
;                                               xchg BH,[InterimCurPage];
;                                               xchg DX,[InterimCurPos];
;                                               AH = 2;
;                                               int 10h;
;                                               ret;
;                                               }
;                               else
;                                       {
;                                       xchg BH,[InterimCurPage];
;                                       xchg DX,[InterimCurPos];
;                                       AH = 2;
;                                       int 10h;
;                                       ret;
;                                       }
;                               }
;                       int 10h
;                       BL = AH
;                       AL = [SavedChar1]
;                       AH = 9
;                       int 10h
;                       DL+
;                       AH = 2
;                       int 10h
;                       AH = 8
;                       int 10h
;                       BL = AH
;                       AL = [SavedChar2]
;                       AH = 9
;                       int 10h
;                       xchg BH,[InterimCurPage];
;                       xchg DX,[InterimCurPos];
;                       AH = 2;
;                       int 10h;
;                       }
;               }
;       }

ClearInterimCharretj:
        ret
ClearInterimChar:
        test    [KbMisc],SavedInterim
        jz      ClearInterimCharRetj
        and     [KbMisc],not SavedInterim
        test    [HanStat],Han1st
        jnz     ClearInterimCharRet
        and     [DisplayStat],not RunEsc
        mov     ah,0fh
        int     10h
        mov     ah,3
        int     10h
        mov     cx,1
        cmp     [InterimCurPage],bh
        jnz     @f
        cmp     [InterimCurPos],dx
        jz      ClearAct
@@:
        xchg    bh,[InterimCurPage]
        xchg    dx,[InterimCurPos]
        mov     ah,2
        int     10h
        mov     ah,8
        int     10h
        cmp     [DispIChar1],al
        jnz     @f
        inc     dl
        mov     ah,2
        int     10h
        mov     ah,8
        int     10h
        cmp     [DispIChar2],al
        jnz     @f
        dec     dl
        mov     ah,2
        int     10h
ClearAct:
        mov     ah,8
        int     10h
        mov     bl,ah
        mov     al,[SavedChar1]
        mov     ah,9
        int     10h
        inc     dl
        mov     ah,2
        int     10h
        mov     ah,8
        int     10h
        mov     bl,ah
        mov     al,[SavedChar2]
        mov     ah,9
        int     10h
@@:
        xchg    bh,[InterimCurPage]
        xchg    dx,[InterimCurPos]
        mov     ah,2
        int     10h
ClearInterimCharRet:
        ret


;------------------------------------------------------------------------
;   << GetCompleteChar >>
; FUNCTION = get character from complete character buffer
; INPUT   : none
; OUTPUT  : NC = success ; get code(AX)
;           CY = fail
; PROTECT : AX
; GetCompleteChar(-/AX,flag)
;        {
;        if ( CompleteCharCnt = 0 )  ret(CY);
;        else
;                {
;                AX = [CompleteCharBuf];
;                CompleteCharCnt-- ;
;                for (j=CompleteCharCnt;j=0;j--)
;                   [CompleteCharBuf]=[CompleteCharBuf+2];
;                ret(AX,NC);
;                }
;        }
GetCompleteChar:
        cmp     [CompleteCharCnt],0
        je      GetCompleteCharErr
        mov     bx,offset CompleteCharBuf
        mov     ax,[bx]
        mov     cx,[CompletecharCnt]
        dec     cx
        mov     [CompletecharCnt],cx
        jcxz    GetCompleteCharRet
@@:
        mov     dx,[bx+2]
        mov     [bx],dx
        add     bx,2
        loop    @b
GetCompleteCharRet:
        clc
        ret
GetCompleteCharErr:
        stc
        ret

;------------------------------------------------------------------------
;   << GetInterimChar >>
; FUNCTION = get character from interim character buffer
; INPUT   : none
; OUTPUT  : NC = success ; get code(AX)
;           CY = fail
; PROTECT : AX
; GetInterimChar(-/AX,flag)
;        {
;        if (InterimCharCnt = 0)  ret(CY);
;        else
;                {
;                AX = [InterimCharBuf];
;                InterimCharCnt--;
;                [InterimCharBuf]=[InterimCharBuf+2];
;                ret(AX,NC);
;                }
;        }
GetInterimChar:
        cmp     [InterimCharCnt],0
        je      @f
        mov     ax,[InterimCharBuf]
        dec     [InterimCharCnt]
        mov     dx,[InterimCharBuf+2]
        mov     [InterimCharBuf],dx
        clc
        ret
@@:
        stc
        ret


;------------------------------------------------------------------------
;   << PutCompleteHg >>
; FUNCTION = put  code into complete character buffer
; INPUT   : none
; OUTPUT  : none
; PROTECT : AX
; PutCompleteHg(-/-)
;        {
;        DH=CompleteHgAttr
;        DL=AH
;        AH=DH
;        PutCompleteBuf(DX,AX/-)
;        ret
;        }
; PutCompleteBuf(DX,AX/-)
;       {
;       BX = offset CompleteCharBuf
;       SI = [CompleteCharCnt] * 2
;       [BX+SI] = DX
;       [BX+SI+2] = AX
;       [CompleteCharCnt]+2
;       ret;
;       }
CompleteHgAttr  =       0f1H            ; attr of complete Hangeul code
PutCompleteHg:
        mov     dh,CompleteHgAttr
        mov     dl,ah
        mov     ah,dh
PutCompleteBuf:
        mov     bx,offset CompleteCharBuf
        mov     si,[CompleteCharCnt]
        shl     si,1
        mov     [bx+si],dx
        add     si,2
        mov     [bx+si],ax
        add     [CompleteCharCnt],2
        ret

;------------------------------------------------------------------------
;   << PutInterimHg >>
; FUNCTION = put  code into interim character buffer
; INPUT   : none
; OUTPUT  : none
; PROTECT : AX
; PutInterimHg(-/-)
;        {
;        DH=InterimHgAttr
;        DL=AL
;        AH=DH
;        [InterimCharBuf]=code;
;        [InterimCharCnt]+2;
;        [KbMisc]=[KbMisc]&&HaveInterim
;        ret;
;        }
InterimHgAttr   =       0f0H            ; attr of interim Hangeul code
PutInterimHg:
        mov     dh,InterimHgAttr
        mov     dl,ah
        mov     ah,dh
        mov     [InterimCharBuf],dx
        mov     [InterimCharBuf+2],ax
        mov     [InterimCharCnt],2
        or      [KbMisc],HaveInterim
        ret


;------------------------------------------------------------------------
;   << PutHjJjChar >>
; FUNCTION = put Hanja/Junja characters into CcKbBuf
; INPUT   : AX (Hj codes; ah-1st, al-2nd)
; OUTPUT  : [CompleteCharBuf],[CompleteCharCnt]
; PROTECT :
; PutHjJjChar()
;        {
;        DH=HanjaAttr
;        DL=AH
;        AH=DH
;        PutCompleteBuf(DX,AX/-)
;        ret
;        }
HanjaAttr       =       0f2H            ; Hanja attr converted at CCP
PutHjJjChar:
        mov     dh,HanjaAttr
        mov     dl,ah
        mov     ah,dh
        call    PutCompleteBuf
        ret


;------------------------------------------------------------------------
;   << MakeHanjaListHg >>
; FUNCTION = make hanja list
; INPUT   : AX = code,ES:DI = menubuffer
; OUTPUT  : none
; PROTECT : AX
; MakeHanjaListHg(AX,DI/AX,DI,flag)
;       {
;       if (AX is in code range)
;               {
;               CX = 0
;               DX = HjTblMax
;               if (BinarySearch(AX,CX,DX/FLAG,SI) == NC)
;                       {
;                       SI = SI*2 + offset IndexTbl
;                       CX = [SI+2]
;                       SI = [SI] + offset SetTbl
;                       [TotalMenuCnt]= [TotalMenuCnt]+CL
;                       do loop CX
;                               [ES:DI] = [DS:SI] ;word unit
;                       ret(NC);
;                       }
;               else
;                       ret(CY);
;               }
;       else
;               ret(CY);
;       }

HjTblMax        =       473 + 18 - 1

MakeHanjaListHg:
        cmp     ah,0a1h
        jb      MakeHanjaListHgRet
        cmp     ah,0feh
        ja      MakeHanjaListHgRet
        cmp     al,0a1h
        jb      MakeHanjaListHgRet
        cmp     al,0feh
        ja      MakeHanjaListHgRet
        mov     bx,offset MapTbl
        sub     cx,cx
        mov     dx,HjTblMax
        push    ax
        call    BinarySearch
        jc      @f
        shl     si,1
        add     si,offset IndexTbl
        mov     ch,0
        mov     cl,[si+2]
        mov     ah,[si+3]
        add     [TotalMenuCnt],cl
        mov     si,[si]
        add     si,offset SetTbl
        cmp     ah,0
        jnz     GetByteHj
        rep     movsw
        jmp     @f
GetByteHj:
        lodsb
        stosw
        loop    GetByteHj
        mov     cl,[TotalMenuCnt]
@@:
        pop     ax
        clc
        ret
MakeHanjaListHgRet:
        stc
        ret


;------------------------------------------------------------------------
;   << MakeHanjaListUdc >>
; FUNCTION = make hanja list + udc
; INPUT   : none
; OUTPUT  : none
; PROTECT : AX
; MakeHanjaListUdc(AX,DI/AX,DI,flag)
;       {
;       if ([HjStat] == UdcLoaded)
;               {
;               BX = [UdcTblPtr]
;               CX = 0
;               DX = [BX+UdcMapTblSize]
;               BX = BX + [BX+UdcMapTblPtr]
;               if (BinarySearch(AX,BX,CX,DX/CY,SI)=NC)
;                       {
;                       BX = [UdctblPtr]
;                       SI = (SI*2 + [BX+UdcMapTblPtr] + BX)
;                       CX = [SI+2]
;                       SI = [SI]
;                       SI = (SI + [BX+UdcSetTblPtr] + BX)
;                       do loop CX
;                               [ES:DI] = [DS:SI] ;word unit
;                       ret(NC);
;                       }
;               else
;                       ret(CY);
;               }
;       else
;               ret(CY);
;       }

EXTRN   UdcTblPtr:word

MakeHanjaListUdc:
        test    [HjStat],UdcLoaded
        jz      @f
        mov     bx,[UdcTblPtr]
        sub     cx,cx
        mov     dx,[bx+UdcMapTblSize]
        add     bx,[bx+UdcMapTblPtr]
        call    BinarySearch
        jc      @f
        mov     bx,[UdcTblPtr]
        shl     si,1
        add     si,[bx+UdcIndexTblPtr]
        add     si,bx
        mov     cx,[si+2]
        mov     si,[si]
        add     si,[bx+UdcSetTblPtr]
        add     si,bx
        add     [TotalMenuCnt],cl
        rep     movsw
@@:
        inc     [TotalMenuCnt]
        stosw
        ret


;------------------------------------------------------------------------
;   << BinarySearch >>
; FUNCTION = search designated characters(word) in the given table
;            in word unit (emulate recursive call)
; INPUT   : AX (codes; ah-1st, al-2nd)
;           BX (table start address)
;           CX (low byte-index)
;           DX (high byte-index = # of items - 1)
; OUTPUT  : SI (word-index of matching code), if CC=0(NC)
;           no found, if CC=1(CY)
; PROTECT : cx, dx, si
; BinarySearch()
;       {
;       while (CX <= DX) && (AX != [BX+SI])
;               {
;               SI = (CX+DX)
;               SI = SI && (not 1)
;               if (AX > [BX+SI])
;                       {
;                       SI = (SI/2)+1
;                       CX = SI
;                       }
;               if (AX < [BX+SI])
;                       {
;                       SI = (SI/2)-1
;                       DX = SI
;                       }
;               }
;       if (AX = [BX+SI])
;               ret(NC,SI);
;       else
;               ret(CY);
BinarySearch:
        cmp     cx,dx
        jg      NotFound
        mov     si,cx
        add     si,dx
        and     si,not 1
        cmp     ax,[bx+si]
        ja      HighPart
        je      Found
LowPart:
        shr     si,1
        dec     si
        mov     dx,si
        jmp     BinarySearch
HighPart:
        shr     si,1
        inc     si
        mov     cx,si
        jmp     BinarySearch
NotFound:
        stc
Found:
        ret


;------------------------------------------------------------------------
;   << TrapHjMenu >>
; FUNCTION =  menu display  control
; INPUT   : none
; OUTPUT  : ZR = next / back or other key
;           CY = escape key in flag
;           NZ,NC= success flag, AX = hanja code
; PROTECT : AX
; TrapHjMenu(AX/flag,AL,BX)
;       switch(AX)
;       {
;       case next menu key:   /* right arrow */
;               {
;               get maximum menu counter;
;               if ( maximum menu counter > # of hanja menu 1 line )
;                       {
;                       get menu pointer;
;                       add current menu counter to menu pointer;
;                       if ( menu pointer >= maximum menu counter )
;                            set menu pointer to 0;
;                       set (MaximumMenuCounter-MenuPointer) to CurMenuCnt
;                       if ( not last menu )
;                            set CurMenuCnt to # of hanja menu 1 line;
;                       DisplayHanja();
;                       ret(ZR);
;                       }
;               break;
;               }
;       case back menu key: /* left arrow */
;               {
;               if (maximum menu counter > # of hanja menu 1 line) &
;                   menu pointer is not 0 )
;                       {
;                       sub # of hanja menu 1 line from menu pointer;
;                       set current menu counter to # of hanja menu 1 line;
;                       DisplayHanja();
;                       ret(ZR);
;                       }
;               break;
;               }
;       case "esc":
;               {
;               ret(CY);
;               }
;       case  "0" =< AX =< "9"
;               {
;               if (the code =< current menu counter)
;                       {
;                       get selected code;
;                       ret(NZ,NC,AX);
;                       }
;               }
;       default:
;               {
;               beep();
;               ret(ZR);
;               }

TrapHjMenu:
        cmp     al,030h
        jb      @f
        cmp     al,039h
        jbe     TrapHjNum
@@:
        cmp     ah,04dh
        je      TrapHjNextMenu
        cmp     ah,04bh
        je      TrapHjBackMenu
        cmp     al,EscKey
        je      TrapHjMenuAbort
        jmp     TrapHjMenuErr
TrapHjNum:
        sub     al,030h
        cbw
        cmp     al,[CurrMenuCnt]
        jae     TrapHjMenuErr
        xor     bh,bh
        mov     bl,[MenuPtr]
        add     bx,ax
        shl     bx,1
        mov     ax,[bx+MenuBuffer]
        xchg    ah,al
        or      ax,ax
        ret
TrapHjNextMenu:
        mov     ah,[TotalMenuCnt]
        cmp     ah,HjNumOf1Line
        jbe     TrapHjMenuRet
        mov     al,[MenuPtr]
        add     al,[CurrMenuCnt]
        cmp     al,ah
        jb      @f
        sub     al,al
@@:
        mov     [MenuPtr],al
        neg     al
        add     al,ah
        cmp     al,HjNumOf1Line
        jbe     @f
        mov     al,HjNumOf1Line
@@:
        mov     [CurrMenuCnt],al
        call    DisplayHanja
        jmp     TrapHjMenuRet
TrapHjBackMenu:
        cmp     [TotalMenuCnt],HjNumOf1Line
        jbe     TrapHjMenuErr
        cmp     [MenuPtr],0
        je      TrapHjMenuErr
        sub     [MenuPtr],HjNumOf1Line
        mov     [CurrMenuCnt],HjNumOf1Line
        call    DisplayHanja
        jmp     TrapHjMenuRet
TrapHjMenuAbort:
        stc
        ret
TrapHjMenuErr:
        call    Beep
TrapHjMenuRet:
        sub     ax,ax
        ret


;------------------------------------------------------------------------
;   << SaveMenuLine >>
; FUNCTION = save menu
; INPUT   : none
; OUTPUT  : none
; PROTECT : AX
; SaveMenuLine(-/-)
;       {
;       AH = 0Fh;
;       int 10h
;       [SaveCurrPage] = bh;
;       [CrtMaxCols] = ah;
;       AH = 3;
;       int 10h
;       [SaveCurPos] = dx;
;       [SaveCurType] = cx;
;       CX = 2020h;
;       AH = 1;
;       int 10h
;       DL = 0;
;       DH = [HjMenuLine];
;       AH = 2;
;       int 10h
;       CL = [CrtMaxCols];
;       DI = offset MenuLineBuf
;       loop(CL)
;               {
;               AH = 8
;               int 10h
;               [ES:DI] = AX
;               +DL
;               AH = 2
;               int 10h
;               }
;       if ([TotalMenuCnt] > HjNumOf1Line)
;               [CurrMenuCnt] = HjNumOf1Line;
;       else
;               [CurrMenuCnt] = [TotalMenuCnt];
;       DisplayHanja();
;       ret;

SaveMenuLine:
        mov     ah,0fh
        int     10h
        mov     [SaveCurrPage],bh
        mov     [CrtMaxCols],ah
        mov     [ModeVal],6*2
        cmp     al,060h
        jz      @f
        cmp     al,011h
        jz      @f
        cmp     al,012h
        jz      @f
        mov     [ModeVal],0*2
@@:
        mov     ah,3
        int     10h
        mov     [SaveCurPos],dx
        mov     [SaveCurType],cx
        mov     cx,2020h
        mov     ah,1
        int     10h
        xor     dl,dl
        mov     dh,[HjMenuLine]
        mov     ah,2
        int     10h
        xor     ch,ch
        mov     cl,[CrtMaxCols]
        mov     di, offset MenuLineBuf
@@:
        mov     ah,8
        int     10h
        stosw
        inc     dl
        mov     ah,2
        int     10h
        loop    @b
        mov     al,[TotalMenuCnt]
        cmp     al,HjNumOf1Line
        jbe     @f
        mov     al,HjNumOf1Line
@@:
        mov     [CurrMenuCnt],al
        call    DisplayHanja
        ret


;------------------------------------------------------------------------
;   << RestoreMenuline >>
; FUNCTION = restore menu
; INPUT   : none
; OUTPUT  : none
; PROTECT : AX
; RestoreMenuline(-/-)
;       {
;       BH = [SaveCurrPage]
;       DL =0
;       DH = [HjMenuLine]
;       AH = 2
;       int 10h
;       CL = [CrtMaxCols]
;       SI = offset MenuLineBuf
;       loop (CX)
;               {
;               DI = CX
;               AX = [DS:SI]
;               /* display the char */
;               /* set cursor position */
;               CX = DI
;               }
;       DX = [SaveCurPos]
;       AH = 2
;       int 10h
;       CX = [SaveCurType]
;       AH = 1
;       int 10h
;       }
RestoreMenuline:
        xor     dl,dl
        mov     [MenuPtr],dl
        mov     bh,[SaveCurrPage]
        mov     dh,[HjMenuLine]
        mov     ah,2
        int     10h
        xor     ch,ch
        mov     cl,[CrtMaxCols]
        mov     si,offset MenuLineBuf
@@:
        mov     di,cx
        lodsw
        mov     cx,1
        mov     bl,ah
        mov     ah,9
        int     10h
        inc     dl
        mov     ah,2
        int     10h
        mov     cx,di
        loop    @b
        mov     dx,[SaveCurPos]
        mov     ah,2
        int     10h
        mov     cx,[SaveCurType]
        mov     ah,1
        int     10h
        ret


;------------------------------------------------------------------------
EXTRN   ChgKs2Ch7:near

Ch2KsAuto:
        test    [CodeStat],Chab
        jnz     ChabAuto
;        test    [CodeStat],Wsung7
;        jnz     @f
        jmp     Ch2Ks
@@:
        call    Ch2Ks
        jc      @f
        call    ChgKs2Ch7
@@:
        ret
ChabAuto:
        test    [CodeStat],InstPatGen
        jnz     @f
        push    ax
        call    Ch2Ks
        pop     ax
        ret
@@:
        clc
        ret
;------------------------------------------------------------------------
;   << Ch2Ks >>
; FUNCTION = convert chohab code to wansung code
; INPUT   : AX(XXYY)
; OUTPUT  : NC ;AX=
;           CY ;fail
; PROTECT : AX
; Ch2Ks(AX/AX,flag)
;       {
;       AH = AH - 80h
;       SI = offset ChHgIndexTbl
;       /* get DX=# of (XX-1) list */
;       CL = # of XX list
;       SI = offset XX list
;       if (LinearByteSearch(SI,CX/CC,BX) == NC)
;               {
;               BL = 05Eh
;               AX = SI + DX
;               AH = AX/BL ...AL
;               AX = AX + B0A1h
;               ret(NC);
;               }
;       SI = offset ChHgCTbl
;       CX = ChHgWLng-1
;       if (LinearWordSearch((SI,CX/CC,BX) == NC)
;               {
;               SI = SI/2
;               AH = 0A4h
;               BX = offset ChHgWTbl
;               AL = [SI+BX]
;               ret(NC);
;               }
;       ret(CY);
;       }
PUBLIC  ChHgWTbl, ChHgWLng, ChHgCTbl, ChHgIndexTbl, ah88h
PUBLIC  Ch2Ks, LinearWordSearch, LinearByteSearch

Ch2Ks:
        @push   cx,dx,si,di,es,ds
        push    ax
        mov     bx,cs
        mov     ds,bx
        mov     es,bx
        cmp     ax,08442h
        jb      Ch2KsErr
        cmp     ax,0845dh
        ja      @f
        cmp     ax,08452h
        je      Ch2KsErr
        call    Ch2Kscompn
        jmp     Ch2KsSuccess
@@:
        mov     si,offset ChHgCTbl
        mov     cx,ChHgWLng+1
        call    LinearWordSearch
        jc      @f
        shr     bx,1
        mov     ah,0a4h
        mov     si,offset ChHgWTbl
        mov     al,byte ptr [si+bx]
        jmp     Ch2KsSuccess
@@:
        cmp     ah,088h
        jb      Ch2KsErr
        sub     ah,088h
        mov     si,offset ChHgIndexTbl
        xor     bx,bx
        mov     cx,bx
        mov     dx,bx
        mov     bl,ah
        mov     cl,bl
        shl     bx,1
        add     bx,cx
        cmp     ah,0
        je      @f
        mov     dx,[si+bx+1]
        mov     cx,[si+1]
        sub     dx,cx
@@:
        xor     ch,ch
        mov     cl,[si+bx]
        mov     si,[si+bx+1]
        call    LinearByteSearch
        jc      Ch2KsErr
        mov     ax,bx
        add     ax,dx
        mov     bl,05eh
        div     bl
        xchg    ah,al
        add     ax,0B0A1h
Ch2KsSuccess:
        clc
        pop     bx
        @pop    ds,es,di,si,dx,cx
        ret
Ch2KsErr:
        stc
        pop     ax
        @pop    ds,es,di,si,dx,cx
        ret

Ch2Kscompn:
        mov     ah,0a4h
        add     al,05fh
        cmp     al,0a8h
        jb      @f
        add     al,1
        cmp     al,0b2h
        jb      @f
        sub     al,1
        cmp     al,0b3h
        jb      @f
        add     al,1
        cmp     al,0b9h
        jb      @f
        add     al,1
@@:
        ret

;------------------------------------------------------------------------
;   << Ks2Ch >>
; FUNCTION = convert chohab code to wansung code
; INPUT   : AX(XXYY)
PUBLIC  Ks2Ch
Ks2Ch:
        @push   cx,dx,si,di,es,ds
        push    ax
        mov     bx,cs
        mov     ds,bx
        mov     es,bx
        cmp     ah,0a4h
        jne     Ks2ChHg
        mov     si,offset ChHgWTbl
        mov     cx,ChHgWLng+1
        call    LinearByteSearch
        jc      Ks2ChHg
        shl     bx,1
        mov     si,offset ChHgCTbl
        mov     ax,word ptr [si+bx]
        jmp     Ks2ChEnd
Ks2ChHg:
        mov     si,offset ah88h
        sub     ax,0B0A1h
        mov     bx,ax
        mov     al,ah
        mov     ah,0A2h
        mul     ah
        sub     bx,ax
        mov     al,[bx+si]
        cmp     al,0
        je      Ks2ChErr
        mov     si,offset ChHgIndexTbl
        xor     dx,dx
        mov     cx,dx
        mov     ah,dh
@@:
        mov     cl,[si]
        add     dx,cx
        cmp     bx,dx
        jb      short @f
        add     si,3
        inc     ah
        jmp     short @b
@@:
        add     ah,088h
Ks2ChEnd:
        clc
        pop     bx
        @pop    ds,es,di,si,dx,cx
        ret
Ks2ChErr:
        pop     ax
        @pop    ds,es,di,si,dx,cx
        stc
        ret

;------------------------------------------------------------------------
;   << linearWordSearch >>
; linearWordSearch()
; FUNCTION = linear search word unit
; INPUT   : none
; OUTPUT  : BX (index) , if CC=0(NC)
;           not found , if CC=1(CY)
; PROTECT : AX
;
linearWordSearch:
        xor     bx,bx
@@:
        cmp     ax,[si+bx]
        je      @f
        add     bx,2
        loop    @b
        stc
@@:
        ret

;------------------------------------------------------------------------
;   << LinearByteSearch >>
; FUNCTION = linear search byte unit
; INPUT   : SI = pointer of list
;           CX = # of list
; OUTPUT  : BX (index), if CC=0(NC)
;           not found , if CC=1(CY)
; PROTECT : AX
LinearByteSearch:
        xor     bx,bx
@@:
        cmp     [si+bx],al
        je      @f
        inc     bx
        loop    @b
        stc
@@:
        ret


;------------------------------------------------------------------------
;   << Ban2Jun >>
; FUNCTION = code conversion from Banja to Junja if needed
; INPUT   : AX (English raw code)
; OUTPUT  : none ([CcKbCnt], [CcKbBuf])
; PROTECT : AX, BX, DX, SI
; Ban2Jun(AX/AX,flag)
;        {
;        BX = AX;
;        if ((!BH) && (BL>=' ') && (BL <= '~'))
;                {
;                if (BL = ' ')
;                        AX = 0a1a1h;
;                else
;                        {
;                        if (BL = '~')
;                                AX = 0a1adh;
;                        else
;                                {
;                                AH = 0a3h;
;                                AL = AL || 80h;
;                                }
;                        }
;                if ([CodeStat] == Chab)
;                         ChgKs2Ch(AX/AX,BX,flag);
;                /* reset carry */
;                }
;        else
;                AX = BX;
;                /* set carry */
;        }

BlankChar       =       ' '
TildeChar       =       '~'
JunjaBlankCode  =       0a1a1H
JunjaTildeCode  =       0a1adH
Junja1stCode    =       0a3H

Ban2Jun:
        test    [KbStat],JJStat
        jnz     PutJunja
PutBanja:
        mov     bx,offset CompleteCharBuf
        mov     si,[CompleteCharCnt]
        shl     si,1
        mov     [bx+si],ax
        inc     [CompleteCharCnt]
        ret
PutJunja:
        or      ah,ah
        jz      PutBanja
        cmp     al,BlankChar
        je      PutJunjaBlank
        jb      PutBanja
        cmp     al,TildeChar
        je      PutJunjaTilde
        ja      PutBanja
        mov     ah,Junja1stCode
        or      al,80H
        call    PutHjJjChar
        ret
PutJunjaBlank:
        mov     ax,JunjaBlankCode
        call    PutHjJjChar
        ret
PutJunjaTilde:
        mov     ax,JunjaTildeCode
        call    PutHjJjChar
        ret


;------------------------------------------------------------------------
;   << InitHjMenu >>
; FUNCTION =  prepare KS Hangeul code to Hanja code conversion
; INPUT   : none ([KbStatus])
; OUTPUT  : none (prepare KS Hangeul to Hanja conversion)
;           if there's no Hj for given Hg, beep & no action
; PROTECT : ax, bx, cx, dx, si
; InitHjMenu()
;       {
;       if ([HjStat] == HjModeEnable)
;               {
;               AH = 0Fh;
;               int 10h;
;               BL = AH; /* column */
;               AH = 3;
;               int 10h;
;               +DL
;               if (DL < BL)
;               AH = 8;
;               int 10h /* read char/attr at current cursor pos */
;               CH = AL;
;               +DL
;               AH = 2;
;               int 10h;
;               AH = 8;
;               int 10h;
;               CL = AL;
;               -DL
;               AH = 2;
;               int 10h;
;               AX = CX;
;               if (MakeHanjaList(AX/AL) == 0
;                       {
;                       SaveMenuLine();
;                       [HjMenuStat] = [HjMenuStat] || HjMenuMode;
;                       }
;               else
;                       {
;                       Beep();
;                       AutoReset(-/-);
;                       }
;               }
;       else
;               {
;               CX = AX;
;               AutoReset(-/-);
;               AX = CX;
;               PutBanja(AX/-);
;       }
InitHjMenu:
        test    [HjStat],HjModeEnable
        jz      InitHjMenuQuit
        mov     ah,0fh
        int     10h
        mov     bl,ah
        inc     bl
        mov     ah,3
        int     10h
        cmp     dl,bl
        jae     InitHjMenuErr
        mov     ah,8
        int     10h
        mov     ch,al
        inc     dl
        mov     ah,2
        int     10h
        mov     ah,8
        int     10h
        mov     cl,al
        dec     dl
        mov     ah,2
        int     10h
        mov     bx,cx
        call    MakeHanjaList
        or      al,al
        jnz     InitHjMenuErr
        call    SaveMenuLine
        or      [HjMenuStat],HjMenuMode
        ret
InitHjMenuErr:
        call    Beep
        call    AutoReset
        ret
InitHjMenuQuit:
        call    AutoReset
        mov     ax,0f100h
        call    PutBanja
        ret


;------------------------------------------------------------------------
;   << HjMenuSelect >>
; FUNCTION = select one from Hanja menu by numeric key('0'-'9')
;            and put them into CcKbBuf & clear automata state,
;            process next(right)/back(left) menu key & abort(Esc)
; INPUT   : ax (English raw code), Hanja Menu List
; OUTPUT  : [CcKbCnt], [CcKbBuf]<-(Hanja code), if selected
;            and restore menu line & cursor position,
;            no action(escape from this mode), if Esc,
;            prepare next/prev menu, if NextMenuKey/BackMenuKey,
;            no action, if any other key is pressed(ignore key-in)
; PROTECT : ax, bx, cx, dx, si
; HjMenuSelect()
;       {
;       if (TrapHjMenu(AX/CC,ZF,AX) == CY)
;               {
;               RestoreMenuLine();
;               [HjMenuStat] = [HjMenuStat] && !(HjMenuMode)
;               }
;       if (TrapHjMenu(AX/CC,ZF,AX) == NC && NZ)
;               {
;               PutHjJjChar(AX/-);
;               InitHanState(-/-);
;               RestoreMenuLine();
;               [HjMenuStat] = [HjMenuStat] && !(HjMenuMode)
;               }
;       }

HjMenuSelect:
        call    TrapHjMenu
        jc      AbortHjMenuSelect
        jz      @f
        call    PutHjJjChar
        call    InitHanState
AbortHjMenuSelect:
        call    RestoreMenuLine
        and     [HjMenuStat],not HjMenuMode
@@:
        ret


;------------------------------------------------------------------------
;   << Automata >>
; Automata(AX/-)
; FUNCTION =  Automata
; INPUT   : AX=code(english law code)
; OUTPUT  : none,CompleteKbBuf,InterimKbBuf
; PROTECT : AX,BX
;
;        {
;        if ( HanVdMode )
;                {
;                if ( SupportHj & HjMenuMode )
;                        {
;                        if ( the code is HanjaKey ), Beep(); ret;
;                        HjMenuSelect();
;                        ret;
;                        }
;                if ( SupportHj )
;                        if ( the code is HanjaKey ), InitHjMenu(); ret;
;                else
;                        if ( the code is HanjaKey ), EngVdModeAuto(); ret;
;                endif
;                switch([CodeStat])
;                        case BanJunKey: ToggleBanJun(); break;
;                        case HanEngKey: ToggleHanEng(); break;
;                        default:
;                                {
;                                if HanKinMode, HangeulAutomata(); Break;
;                                else           Ban2Jun();
;                                }
;                }
;        else
;                {
;                ResetAotomata();
;                CompleteKbBuf=AX
;                }
;        ret;
;        }

fFillCode       =       04h
vFillCode       =       40h
lFillCode       =       01h
MsbCode         =       80h

Automata:
        test    [KbStat],HanKeyinMode
        jz      EngVdModeAuto
        test    [HjStat],HjLoaded
        jz      NonSupportHj
        test    [HjMenuStat],HjMenuMode
        jz      @f
        cmp     ax,HanjaKey
        jne     HjMenuSelect
        call    beep
        ret
@@:
        cmp     ax,HanjaKey
        jne     NonSupportHj
        mov     ax,0f100h
        jmp     InitHjMenu
NonSupportHj:
        cmp     ax,HanjaKey
        jne     @f
        mov     ax,0f100h
        jmp     EngVdModeAuto
@@:
        cmp     ax,BanJunKey
        je      ToggleBanJunInMode
        cmp     ax,HanEngKey
        je      ToggleHanEngInMode
        cmp     [HeKey],ah
        jne     @f
        or      al,al
        jnz     @f
        ret
@@:
        cmp     [HjKey],ah
        jne     @f
        or      al,al
        jnz     @f
        ret
@@:
        test    [KbStat],HEStat
        jnz     HangeulAutomata
        jmp     Ban2Jun
EngVdModeAuto:
        call    AutoReset
        call    PutBanja
        ret

ToggleBanJunInMode:
        call    ToggleBanJun
        ret
ToggleHanEngInMode:
        xor     [KbStat],HEStat

;------------------------------------------------------------------------
;   << AutoReset >>
; AutoReset()
; FUNCTION =
; INPUT   : none
; OUTPUT  : none
; PROTECT : AX
;        {
;        [HjMenuStat] = [HjMenuStat] && !(HjMenuMode)
;        if ( Auto != 0 )
;                {
;                AX = [KsKbBuf];
;                PutCompleteHg(AX);
;                }
;        InitHanState();
;        ret;
;        }
;
AutoReset:
        cmp     [Auto],0
        jz      InitHanState
        push    ax
        mov     ax,[KsKbBuf]
        call    PutCompleteHg
        pop     ax
;------------------------------------------------------------------------
;   << InitHanState >>
; InitHanState()
; FUNCTION =
; INPUT   : none
; OUTPUT  : none
; PROTECT : AX
;        {
;        Auto = 0;
;        InterimCharCnt = 0;
;        TmpBufCnt = 0;
;        ret;
;        }
InitHanState:
        mov     [Auto],0
        mov     [InterimCharCnt],0
        mov     [TmpBufCnt],0
        ret


;------------------------------------------------------------------------
;   << HangeulAutomata >>
; HangeulAutomata()
; FUNCTION =
; INPUT   : AX=english code
; OUTPUT  : CompleteKbBuf,InterimKbBuf
; PROTECT : AX
;
; type0= DC (Double Consonant)-- ,,,
; type1= SC (Single Consonant)-- ,,,,,
;                                ,,,,,
; type2= FC (First Consonant)--- ,,
; type3= SV (Single Vowel)------ ,,,,,
;                                ,,,,
; type4= DV (Double Vowel)------ ,,
; 
;               0     DC  1     SC  2     FC  3     SV  4     DV  
;                                                       
; 
; a0                                                              
;                        1         2         2         4         5
; 
; a1       DC                                                     
;                      3         3         2         7         8
; 
; a2       SC,FC                                                  
;          ,         1         2         2         7         8
; 
; a3       DC+C                                                   
;                      1         2         2         7         8
; 
; a4       SV                                                     
;                      1         2         2         4         5
; 
; a5       DV                                                     
;                      1         2         2         6         5
; 
; a6     DV+SV                                                    
;                      1         2         2         4         5
; 
; a7      C+SV                                                    
;                      A         B         2         4         5
; 
; a8      C+DV                                                    
;                      A         B         2         9         5
; 
; a9    C+DV+SV                                                   
;                      A         B         2         4         5
; 
; aA    C+V+DC                                                    
;                      C         C         2         7         8
; 
; aB    C+V+SC                                                    
;                      1         2         2         7         8
; 
; aC   C+V+DC+C                                                   
;                      1         2         2         7         8
; 
HangeulAutomata:
        or      ah,ah
        jz      @f
        cmp     al,041h
        jb      @f
        cmp     al,05ah
        jbe     Eng2HanAuto
        cmp     al,061h
        jb      @f
        cmp     al,07ah
        jbe     Eng2HanAuto
@@:
        cmp     [Auto],0
        je      @f
        mov     cx,ax
        mov     ax,[KsKbBuf]
        call    PutCompleteHg
        call    InitHanState
        mov     ax,cx
@@:
        call    Ban2Jun
        ret

Eng2HanAuto:
        mov     bx,[CurInCode]
        mov     [PreInCode],bx
        mov     [CurInCode],ax
        mov     bx,offset TypeTbl
        sub     cx,cx
        mov     cl,al
        sub     cl,041h
        add     bx,cx
        mov     cl,[bx]
        sub     bx,bx
        mov     bl,[Auto]
        mov     bh,bl
        shl     bl,1
        shl     bl,1
        add     bl,bh
        xor     bh,bh
        add     bx,cx
        add     bx,offset StateTbl
        mov     bl,[bx]
        mov     [Auto],bl
        sub     bh,bh
        shl     bx,1
        jmp     word ptr [bx+ActTbl]

TypeTbl:
        db      001h,003h,001h,001h,002h,000h,001h,004h,003h,003h,003h,003h,004h
        db      004h,003h,003h,002h,001h,000h,001h,003h,001h,002h,001h,003h,001h
        db      00,00,00,00,00,00
        db      001h,003h,001h,001h,001h,000h,001h,004h,003h,003h,003h,003h,004h
        db      004h,003h,003h,000h,000h,000h,001h,003h,001h,001h,001h,003h,001h

StateTbl:
; 0 state
        db      01h,02h,02h,04h,05h
; 1 state
        db      03h,03h,02h,07h,08h
; 2 state
        db      01h,02h,02h,07h,08h
; 3 state
        db      01h,02h,02h,07h,08h
; 4 state
        db      01h,02h,02h,04h,05h
; 5 state
        db      01h,02h,02h,06h,05h
; 6 state
        db      01h,02h,02h,04h,05h
; 7 state
        db      0Ah,0Bh,02h,04h,05h
; 8 state
        db      0Ah,0Bh,02h,09h,05h
; 9 state
        db      0Ah,0Bh,02h,04h,05h
; A state
        db      0Ch,0Ch,02h,07h,08h
; B state
        db      01h,02h,02h,07h,08h
; C state
        db      01h,02h,02h,07h,08h

;action table
ActTbl          label   word
        dw      offset  Act0
        dw      offset  Act1
        dw      offset  Act2
        dw      offset  Act3
        dw      offset  Act4
        dw      offset  Act5
        dw      offset  Act6
        dw      offset  Act7
        dw      offset  Act8
        dw      offset  Act9
        dw      offset  ActA
        dw      offset  ActB
        dw      offset  ActC

ConversionTbl:
DCTbl:         ; DC=
        db      051h,074h,014h       ;
;
        db      052h,074h,004h       ;
;
        db      053h,047h,007h       ;
        db      053h,067h,007h       ;
        db      053h,077h,006h       ;
;
        db      046h,041h,00Bh       ;
        db      046h,047h,010h       ;
        db      046h,056h,00Fh       ;
        db      046h,058h,00Eh       ;
        db      046h,061h,00Bh       ;
        db      046h,067h,010h       ;
        db      046h,071h,00Ch       ;
        db      046h,072h,00Ah       ;
        db      046h,074h,00Dh       ;
        db      046h,076h,00Fh       ;
        db      046h,078h,00Eh       ;
DCTblLen        =       ( $ - offset DCTbl ) / 3
DVTbl:         ; DV=
        db      048h,04Bh,01Ch       ;
        db      048h,04Ch,024h       ;
        db      048h,06Bh,01Ch       ;
        db      048h,06Ch,024h       ;
        db      048h,06Fh,01Eh       ;
;
        db      04Eh,04Ah,02Ah       ;
        db      04Eh,04Ch,02Eh       ;
        db      04Eh,06Ah,02Ah       ;
        db      04Eh,06Ch,02Eh       ;
        db      04Eh,070h,02Ch       ;
;
        db      04Dh,04Ch,038h       ;
        db      04Dh,06Ch,038h       ;
DVTblLen        =       ( $ - offset DVTbl ) / 3
ConvTbl1:
;+( +0+0, 0++0 )
;+shift
        db      020h,034h,040h,034h,018h,01Ch,050h,01Ah,00Ah,00Eh,006h,03Ah,036h
        db      028h,00Ch,018h,028h,00Ch,010h,030h,016h,04Ch,03Ch,048h,026h,044h
        db      00,00,00,00,00,00      ;null
        db      020h,034h,040h,034h,014h,01Ch,050h,01Ah,00Ah,00Eh,006h,03Ah,036h
        db      028h,008h,014h,024h,008h,010h,02Ch,016h,04Ch,038h,048h,026h,044h
ConvTbl2:
;+( 0++0, 0+0+ )
        db      011h,034h,019h,017h,018h,009h,01Dh,01Ah,00Ah,00Eh,006h,03Ah,036h
        db      028h,00Ch,018h,028h,003h,005h,016h,016h,01Ch,03Ch,01Bh,026h,01Ah
        db      00,00,00,00,00,00       ;null
        db      011h,034h,019h,017h,008h,009h,01Dh,01Ah,00Ah,00Eh,006h,03Ah,036h
        db      028h,008h,014h,013h,002h,005h,015h,016h,01Ch,018h,01Bh,026h,01Ah


;------------------------------------------------------------------------
;   << CompleteStart >>
; CompleteStart()
; FUNCTION =
; INPUT   : AX = english code
; OUTPUT  : AX = conversion code
; PROTECT : AX
CompleteStart:
        mov     cx,ax
        mov     [TmpBufCnt],0
        mov     [InterimCharCnt],0
        mov     ax,[KsKbBuf]
        call    PutCompleteHg
        mov     ax,cx
        ret
Act0:
        call    CompleteStart
        mov     [Auto],0
        mov     ax,[CurInCode]
        jmp     Eng2HanAuto
Act1:
Act2:
        call    act11
        call    PutInterimHg
        ret
Act11:
        mov     bl,[TmpBufCnt]
        cmp     bl,0
        je      @f
        call    CompleteStart
@@:
        call    GetCharCodeXX00
        or      al,vFillCode
        or      al,lFillCode
        call    GetKCode
        ret
Act1Sub1:
        call    GetKCode
        call    PutInterimHg
        ret
Act3:
        mov     bx,offset DCTbl
        mov     cx,DCTblLen
        call    SearchCompound
        jc      GoAct0
        xor     ah,ah
        or      al,vFillCode
        or      ah,fFillCode
AutoProcess:
        or      ah,MsbCode
AutoProcess1:
        call    PutTmpBuf
        call    Ch2KsAuto
        jc      GoAct0
        mov     [KsKbBuf],ax
        call    PutInterimHg
        ret
Act4:
        call    GetVowelCode
        call    GetKCode
        mov     [Auto],0
        jmp     CompleteStart
GoAct0:
        jmp     Act0
Act5:
        call    GetVowelCode
        jmp     Act1Sub1
Act6:
        mov     bx,offset DVTbl
        mov     cx,DVTblLen
        call    SearchCompound
        jc      GoAct0
        xor     ah,ah
        shl     ax,1
        shl     ax,1
        shl     ax,1
        shl     ax,1
        or      ah,fFillCode
        or      al,lFillCode
        or      ah,MsbCode
        call    PutTmpBuf
        call    Ch2KsAuto
        jc      GoAct0
        mov     [KsKbBuf],ax
        mov     [Auto],0
        jmp     CompleteStart
Act7:
Act8:
        mov     bl,[TmpBufCnt]
        cmp     bl,3
        jb      @f
        mov     ax,[PreTmpBuf]
        call    Ch2KsAuto
        mov     [KsKbBuf],ax
        mov     [InterimCharCnt],0
        call    PutCompleteHg
        mov     [TmpBufCnt],0
        mov     ax,[PreInCode]
        call    Act11
        mov     ax,[CurInCode]
@@:
        call    GetCharCode0XX0
        mov     cl,not vFillCode
        call    Or2Code
        jmp     AutoProcess1
Act9:
        mov     bx,offset DVTbl
        mov     cx,DVTblLen
        call    SearchCompound
        jc      GoAct0
        xor     ah,ah
        shl     ax,1
        shl     ax,1
        shl     ax,1
        shl     ax,1
        mov     bx,[TmpBuf]
        and     bx,not 03E0h
        or      ax,bx
        jmp     AutoProcess1
ActA:
ActB:
        call    GetCharCode00XX
        mov     cl,not lFillCode
        call    Or2Code
        jmp     AutoProcess1
ActC:
        mov     bx,offset DCTbl
        mov     cx,DCTblLen
        call    SearchCompound
        jnc     @f
        jmp     Act0
@@:
        xor     ah,ah
        mov     cl,not 01Fh
        call    Or2Code
        jmp     AutoProcess1

;------------------------------------------------------------------------
GetVowelCode:
        mov     bl,[TmpBufCnt]
        cmp     bl,0
        je      @f
        call    CompleteStart
@@:
        call    GetCharCode0XX0
        or      ah,fFillCode
        or      al,lFillCode
        ret
;------------------------------------------------------------------------
GetKCode:
        or      ah,MsbCode
        call    PutTmpBuf
        call    Ch2KsAuto
        mov     [KsKbBuf],ax
        ret

;------------------------------------------------------------------------
GetCharCodeXX00:
        mov     bx, offset ConvTbl1
        sub     al,041h
        xlat
        mov     ah,al
        xor     al,al
        ret

;------------------------------------------------------------------------
GetCharCode0XX0:
        mov     bx, offset ConvTbl1
        sub     al,041h
        xlat
        xor     ah,ah
        shl     ax,1
        shl     ax,1
        shl     ax,1
        shl     ax,1
        ret

;------------------------------------------------------------------------
GetCharCode00XX:
        mov     bx, offset ConvTbl2
        sub     al,041h
        xlat
        xor     ah,ah
        ret
;------------------------------------------------------------------------
PutTmpBuf:
        mov     bx,[TmpBuf]
        mov     [PreTmpBuf],bx
        mov     [TmpBuf],ax
        mov     bl,[TmpBufCnt]
        inc     bl
        mov     [TmpBufCnt],bl
        ret

;------------------------------------------------------------------------
;   << Or2Code >>
Or2Code:
        mov     bx,[TmpBuf]
        and     bl,cl
        or      ax,bx
        ret

;------------------------------------------------------------------------
;   << SearchCompound >>
; SearchCompound()
; FUNCTION =  / .
; INPUT   : BX=pointer of conversion table
; OUTPUT  : CY=success --> AX=conversioned code
;           NC=fail
; PROTECT : AX
SearchCompound:
        mov     ax,[PreInCode]
        and     al,not Upper2Low
        mov     dx,[CurInCode]
SearchCompoundLoop:
        cmp     al,[bx]
        jne     @f
        cmp     dl,[bx+1]
        jne     @f
        mov     al,[bx+2]
        clc
        ret
@@:
        add     bx,3
        loop    SearchCompoundLoop
        stc
        ret

;------------------------------------------------------------------------
;   << Beep >>
; Beep()
; FUNCTION = beeping for a time
; INPUT   : none
; OUTPUT  : none
; PROTECT : ALL

Beep:
        mov     ax,0e07h
        int     10h
        ret

public  MapTbl, KbEnd, ChHgWTbl         ; for .MAP file
        include CH2KS.TBL
        include HANJA.TBL
KbEnd   label   byte

CODE    ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\dev\hbios\video.asm ===
TITLE   Video interrupt 10h

;=======================================================================;
; (C)Copyright Qnix Computer Co. Ltd.   1992                            ;
; This program contains proprietary and confidential information.       ;
; All rights reserved.                                                  ;
;=======================================================================;

;=======================================================================;
;                                                                       ;
;              SPECIFICATION for video                                  ;
;                                                                       ;
;=======================================================================;
;
; Video card : MGA
;              CGA
;              EGA-mono
;              EGA-color
;              VGA
;              Font card
;              Dual monitor
;              / video card
;
; Code/spec. : KS C 5842 - 1991
;                , KSSM 
;               
;
; Video mode : 2/3      640*400 16      H/TE/TG
; (8*16font)    7       640*400 B/W     H/TE/TG
;              40h      640*400 B/W     G
;              60h      640*400 16      G
;              70h      640*400 B/W     G
;              11h      640*480 B/W     G
;              12h      640*480 16      G
;
; Video mode : 2/3      960*600 16      H
; (12*24font)   7       960*600 B/W     H
;  * H =  text mode
;    TE = Text emulation mode
;    TG = Text emulation mode(not refresh)
;    G = Graphics mode
;
; Font box   : 8*16
;
;  
;            : 16 * 16  font        - 'HJ16.PAT'


;========================================================================;
;                                                                        ;
;                        VIDEO INTERRUPT 10H                             ;
;                                                                        ;
;========================================================================;
;
;  Video service routine    
;   .
;
;  Reserved register : BP = stack pointer
;                      DS = CS
;                      ES = DataSeg
;
;
; Int10(AX, BX, CX, DX, SI, DI, ES)
;       {
;       if ([CodeStat] != HangeulMode), goto [OldInt10], Iret;
;       sti
;       cld
;       if (AH=0,0fch,0fdh) || HangeulVideoMode
;               {
;               +[VideoActive];                 /* INT10 nesting */
;               Save BX,CX,DX,SI,DI,ES,DS,BP;   /* AX = destory */
;               BP = SP;                        /* save stack pointer */
;               ES = DataSeg;                   /* default */
;               DS = CodeSeg;                   /* default */
;               switch(AH)
;                       case 0    : ModeSet(AL/-);
;                                   break;
;                       case 1    : SetCurType(CX/-);
;                                   break;
;                       case 2    : SetCurPos(BH,DX/-);
;                                   break;
;                       case 3    : GetCurPos(BH/CX,DX);
;                                   break;
;                       case 5    : SetPage(AL/-);
;                                   break;
;                       case 6    : ScrollUp(AL,BH,CX,DX/-);
;                                   break;
;                       case 7    : ScrollDown(AL,BH,CX,DX/-);
;                                   break;
;                       case 8    : ReadCharAttr(BH/AX);
;                                   break;
;                       case 9    : WriteCharAttr(AL,BX,CX/-);
;                                   break;
;                       case 0ah  : WriteChar(AL,BX,CX/-);
;                                   break;
;                       case 0ch  : WritePixel(AL,BH,CX,DX/-);
;                                   break;
;                       case 0dh  : ReadPixel(BH,CX,DX/AL);
;                                   break;
;                       case 0eh  : WriteTty(AL,BL/-);
;                                   break;
;                       case 0fh  : GetMode(-/AX,BH);
;                                   break;
;                       case 0f6h : BlockMove(AL,BX,CX,DX/-);
;                                   break;
;                       case 0f7h : BlockCopy(BX,CX,DX/-);
;                                   break;
;                       case 0f8h : GetCharType(-/AL);
;                                   break;
;                       case 0fch : FontCtrl(AL,*/*);
;                                   break;
;                       case 0fdh : GetInfor(-/AL,BX,ES);
;                                   break;
;                       case 0feh : WriteTtyInterim(AL,BL/-);
;                                   break;
;                       default   : Restore BX,CX,DX,SI,DI,ES,DS,BP;
;                                   goto [OldInt10];
;               UserEOP(-/-);
;               Restore BX,CX,DX,SI,DI,ES,DS,BP;
;               -[VideoActive];
;               }
;       else    goto [OldInt10];
;       iret;
;       }

CODE    SEGMENT PUBLIC   WORD 'CODE'
        ASSUME  CS:CODE,DS:CODE,ES:DATA

INCLUDE         EQU.INC
INCLUDE         DATA.INC

; CursorStat
CursorOn        =       00000001b

PUBLIC  Int10
Int10:
if      Debug
        pushf
        cli
        push    ax
        push    bx
        mov     ax,cs:[DebugData]
        mov     bx,ax
        and     bx,0f00h
        and     ax,0f0ffh
        add     bx,100h
        and     bx,0f00h
        or      ax,bx
        out     10h,ax
        mov     cs:[DebugData],ax
        pop     bx
        pop     ax
        popf
endif   ; if Debug
        cmp     ah,01ch
        jnz     @f
        jmp     Return1ch
@@:
        cmp     ah,00h
        jz      @f
        cmp     ah,0fch
        jz      @f
        cmp     ah,0fdh
        jz      @f
        test    cs:[CodeStat],HangeulMode or HangeulVideoMode
        jz      EngInt10Do
        jpo     EngInt10Do
@@:
        sti
        cld
        inc     cs:[VideoActive]
        @push   bx,cx,dx,si,di,es,ds,bp
        xor     bp,bp
        mov     es,bp
        mov     bp,cs
        mov     ds,bp
        mov     bp,sp
        mov     si,ax
        mov     al,ah
        xor     ah,ah
        add     al,(10h-4)
        xchg    si,ax
        cmp     si,(23h-4)
        ja      EngInt10
        shl     si,1
        call    [si+JumpTbl]
        @pop    bp,ds,es,di,si,dx,cx,bx
        dec     cs:[VideoActive]
if      Debug
        pushf
        cli
        push    ax
        push    bx
        mov     ax,cs:[DebugData]
        mov     bx,ax
        and     bx,0f00h
        and     ax,0f0ffh
        sub     bx,100h
        and     bx,0f00h
        or      ax,bx
        out     10h,ax
        mov     cs:[DebugData],ax
        pop     bx
        pop     ax
        popf
endif   ; if Debug
        iret

VdDummyRet:
        add     sp,2
EngInt10:
        @pop    bp,ds,es,di,si,dx,cx,bx
        dec     cs:[VideoActive]
EngInt10Do:
; KSE VGA mode 6 & AX = 1003h
        cmp     ax,1003h
        jnz     @f
        push    ax
        push    es
        xor     ax,ax
        mov     es,ax
        cmp     [rCrtMode],6
        pop     es
        pop     ax
        jnz     @f
        iret
@@:
if      Debug
        pushf
        call    cs:[OldVideo]
        pushf
        cli
        push    ax
        push    bx
        mov     ax,cs:[DebugData]
        mov     bx,ax
        and     bx,0f00h
        and     ax,0f0ffh
        sub     bx,100h
        and     bx,0f00h
        or      ax,bx
        out     10h,ax
        mov     cs:[DebugData],ax
        pop     bx
        pop     ax
        popf
        iret
else
        jmp     cs:[OldVideo]
endif   ; if Debug

Return1ch:
        pushf
        call    cs:[OldVideo]
        mov     al,01ch
        iret

JumpTbl         label   word            ; to be set at init by invoking SetMode
        dw      offset  ControlCode     ; ah=f4
        dw      offset  CodeChange      ; ah=f5
        dw      offset  BlockMove       ; ah=f6
        dw      offset  BlockCopy       ; ah=f7
        dw      offset  GetCharType     ; ah=f8
        dw      offset  VdDummyRet      ; ah=f9
        dw      offset  VdDummyRet      ; ah=fa
        dw      offset  VdDummyRet      ; ah=fb
        dw      offset  FontCtrl        ; ah=fc
        dw      offset  GetInfor        ; ah=fd
        dw      offset  WriteTtyInterim ; ah=fe
        dw      offset  VdDummyRet      ; ah=ff (x)

        dw      offset  ModeSet         ; ah=0
        dw      offset  SetCurType      ; ah=1
        dw      offset  SetCurPosAll    ; ah=2
        dw      offset  GetCurPos       ; ah=3
        dw      offset  VdDummyRet      ; ah=4
        dw      offset  SetPage         ; ah=5
        dw      offset  ScrollUp        ; ah=6
        dw      offset  ScrollDown      ; ah=7
        dw      offset  ReadCharAttr    ; ah=8
        dw      offset  WriteCharAttr   ; ah=9
        dw      offset  WriteChar       ; ah=0a
        dw      offset  VdDummyRet      ; ah=0b
        dw      offset  WritePixel      ; ah=0c
        dw      offset  ReadPixel       ; ah=0d
        dw      offset  WriteTty        ; ah=0e
        dw      offset  GetMode         ; ah=0f
        dw      offset  Attribute       ; ah=10
        dw      offset  VdDummyRet      ; ah=11
        dw      offset  VdDummyRet      ; ah=12
        dw      offset  WriteString     ; ah=13


;=======================================================================
;  << ModeSet >>
; FUNCTION = set video mode
; INPUT   : AH = 00h
;           AL = mode value & MSB
; OUTPUT  : none
; PROTECT : none
;
;       video card  mode (mode-ID)
;               0 -  video card, mode 2/3/7, MGA/CGA/EGA/VGA
;               1 - text emulation mode 7, MGA
;               2 - text emulation mode 2/3, CGA
;               3 - text emulation mode 7, EGA/VGA
;               4 - text emulation mode 2/3, EGA/VGA
;               5 - mode 40/70
;               6 - mode 60/11/12, EGA/VGA
;
;       video card 
;               0 - MGA
;               1 - CGA
;               2 - EGA mono
;               3 - EGA color
;               4 - MCGA
;               5 - VGA
;
;       video card mode  modeset 
;               0 -  video card, mode 2/3/7, MGA/CGA
;               1 -  video card, mode 2/3/7, EGA/VGA
;               2 - grp mode or TE mode, MGA
;               3 - grp mode or TE mode, CGA
;               4 - grp mode or TE mode, EGA/VGA
;
;       video buffer   
;               0 - 80*25, 8*16 font
;               1 - 80*30, 8*16 font
;
;         video mode set (TEXT mode)
;               0 -  card, single monitor   - TEXT, 8 page
;               1 -  card, dual monitor     - TEXT, 8 page
;               2 -  card, single monitor   - TE  , 8 page (not CGA)
;               3 -  card, dual monitor     - grp , 1 page
;


;========================================================================
;   << ModeSet >>
; FUNCTION = initialize the video mode
; INPUT   : AL
; OUTPUT  : none
; PROTECT : SS, SP
;
; ModeSet(AL/-)
;       {
;       save AX;
;       ClearCursor(-/-);
;       [ModeStat] = 0;
;       [KbStat] = [KbStat] && not HanKeyinMode;
;       [CodeStat] = [CodeStat] && not HangeulVideoMode;
;       [CurMode] = AL;
;       AL = AL && 01111111b;
;       PreModeset(AL/AL);      /* monitor type  equip/crtc addr set */
;       HanCardReset(-/-);
;       if (SearchMode(AL/AL,SI,carry) == CY)
;               {
;               Resrore AX;
;               Restore BX,CX,DX,SI,DI,ES,DS,BP;
;               goto [OldInt10];
;               }
;       Restore BX;             /* = AX */
;       [KbStat] = HanKeyinMode;
;       [CodeStat] = [CodeStat] || HangeulVideoMode;
;       NorModeset(AL,SI/SI);
;       SettingVariables(SI/SI);
;       InitVideoBuffer(SI/-);
;       [CurMode] = [CurMode] && 01111111b;
;       HanCardSet(-/-);                /*  card enable */
;       }
;
ModeSet:
if      Hwin31sw
        jmp     WinModeSet
endif   ; Hwin31sw
ModeSet2:
        push    ax
        call    ClearCursor
        mov     [ModeStat],0
        and     [KbStat],not HanKeyinMode
        and     [CodeStat],not HangeulVideoMode
        mov     [CurMode],al
        and     al,01111111b
        call    PreModeset
        call    HanCardReset
        call    SearchMode
        jnc     ModeSetH
if      KseVga
        test    cs:[KseCard],00000001b
        jz      @f
        pop     ax
        push    ax
        cmp     al,038h
        jnz     @f
        call    HanCardReSetGr
        call    kseveop
@@:
endif   ; if KseVga
        pop     ax
        pushf
        call    cs:[OldVideo]
        ret
ModeSetH:
        pop     bx                      ; AX
        or      [KbStat],HanKeyinMode
        or      [CodeStat],HangeulVideoMode
        test    cs:[Card1st],VgaCard
        jz      @f
        call    ChgParmE2H
@@:
        call    NorModeset
        test    cs:[Card1st],VgaCard
        jz      @f
        call    ChgParmH2E
@@:
        call    SettingVariables
        call    InitVideoBuffer
        and     [CurMode],01111111b
        call    HanCardSet
        ret

if      KseVga
HanCardReSetGr:
        call    KseVgaKey
        mov     al,37h
        out     dx,al
        inc     dl
        in      al,dx
        and     al,11111110b
        or      al,00000011b
        out     dx,al
        ret
endif   ;   KseVga

ChgParmH2E:
        @push   es,ds,di
ASSUME  DS:DATA
        xor     di,di
        mov     ds,di
        les     di,cs:[OldVdParms]
        mov     word ptr [rVdParm],di
        mov     word ptr [rVdParm+2],es
        test    cs:[Card1st],VgaCard
        jz      @f
        les     di,cs:[OldSavePtr]
        les     di,es:[di]
        mov     word ptr cs:[HanSavePtr],di
        mov     word ptr cs:[HanSavePtr+2],es
@@:
ASSUME  DS:CODE
        @pop    di,ds,es
         ret

ChgParmE2H:
        @push   ds,di
ASSUME  DS:DATA
        xor     di,di
        mov     ds,di
        mov     word ptr [rVdParm],offset VideoParms
        mov     word ptr [rVdParm+2],cs
        test    cs:[Card1st],VgaCard
        jz      @f
        mov     word ptr cs:[HanSavePtr],offset VideoParmsTbl
        mov     word ptr cs:[HanSavePtr+2],cs
@@:
ASSUME  DS:CODE
        @pop    di,ds
        ret

;------------------------------------------------------------------------
;   << PreModeSet >>
; FUNCTION = initialize video card state
; INPUT   : AL
; OUTPUT  : AL
; PROTECT : DS, ES, AL
;
; PreModeSet(AL/AL)
;       {
;       if (([Card1st] == DualMnt) && ([Card1st] != ES:[rEquip]))
;               {
;               XCHG [GetHan1st],[GetHan2nd];
;               XCHG [GetUdc1st],[GetUdc2nd];
;               XCHG [PutUdc1st],[PutUdc2nd];
;               XCHG [HanOn1st],[HanOn2nd];
;               XCHG [HanOff1st],[HanOff2nd];
;               XCHG [Card1st],[Card2nd];
;               }
;       else
;               {
;               if ([Card1st] == EgaCardM)
;                       {
;                       ES:[rEquip] = mono equip;
;                       ES:[rAddr6845] = 3b4h;
;                       OUT 3c2h,62h;
;                       }
;               if ([Card1st] == EgaCardC)
;                       {
;                       ES:[rEquip] = color equip;
;                       ES:[rAddr6845] = 3d4h;
;                       OUT 3c2h,63h;
;                       }
;               }
;       }
;
PreModeSet:
        test    [Card1st],DualMnt
        jz      PreModeSetSingle
        xor     ah,ah
        test    [Card1st],ColorMnt
        jz      @f
        xor     ah,1
@@:
        test    [rEquip],00110000b
        jpe     @f
        xor     ah,1
@@:
        or      ah,ah
        jz      @f
        call    XchgCardParms
@@:
        ret
XchgCardParms:
        mov     bx,[GetHan1st]
        xchg    bx,[GetHan2nd]
        mov     [GetHan1st],bx
        mov     bx,[GetUdc1st]
        xchg    bx,[GetUdc2nd]
        mov     [GetUdc1st],bx
        mov     bx,[PutUdc1st]
        xchg    bx,[PutUdc2nd]
        mov     [PutUdc1st],bx
        mov     bx,[HanOn1st]
        xchg    bx,[HanOn2nd]
        mov     [HanOn1st],bx
        mov     bx,[HanOff1st]
        xchg    bx,[HanOff2nd]
        mov     [HanOff1st],bx
        mov     bl,[Card1st]
        xchg    bl,[Card2nd]
        mov     [Card1st],bl
        ret
PreModeSetSingle:
        push    ax
        mov     ah,[Card1st]
        and     ah,CardType
        cmp     ah,EgaCardM
        jnz     @f
        or      [rEquip],00110000b
        mov     [rAddr6845],3b4h
        mov     dx,GrpIndex
        mov     al,62h
        out     dx,al
@@:
        cmp     ah,EgaCardC
        jnz     @f
        and     [rEquip],11101111b
        or      [rEquip],00100000b
        mov     [rAddr6845],3d4h
        mov     dx,3c2h
        mov     al,63h
        out     dx,al
@@:
        pop     ax
        ret

;------------------------------------------------------------------------
;   << SearchMode >>
; FUNCTION = search video mode & get parms pointer
; INPUT   : AL = mode value(W/O MSB)
; OUTPUT  : AL, SI, carry(set = english mode)
; PROTECT : DS, ES, AL
;
; SearchMode(AL/AL,SI,carry)
;       {
;       switch([Card1st])
;               {
;               case MgaCard:
;                       if (AL != 7/40h/70h), AL = 7;
;                       break;
;               case CgaCard:
;                       if (AL != 0-6/40h), AL = 3;
;                       break;
;               case EgaCardM:
;                       if (AL != 7/0fh/40h/70h), AL = 7;
;                       break;
;               case EgaCardC:
;                       if (AL != 0-6/0dh/0eh/10h/40h/70h/60h), AL = 3;
;                       break;
;               case VgaCard:
;               case McgaCard:
;                       if (AL != 0-6/0dh-13h/40h/70h/60h), AL = 3;
;               }
;       if (AL == 2), AL = 3;
;       if ([Card1st] == DualMnt)
;               {
;               if (([rEquip] == mono) && (AL == 40h))
;                       AL = 7;
;               if (([rEquip] == color) && (AL == 70h))
;                       AL = 3;
;               }
;       if (([Card1st] != HanCard) && (AL == 3/7))
;               {
;               AL = AL || 10h;
;               if ([Card1st] == DualMnt), AL = AL || 80h;
;               }
;       switch([card1st])
;               {
;               case MgaCard:
;                       SI = MgaModeTbl;
;                       break;
;               case CgaCard:
;                       SI = CgaModeTbl;
;                       break;
;               case EgaCardM:
;               case EgaCardC:
;                       SI = EgaModeTbl;
;                       break;
;               case VgaCard:
;               case McgaCard:
;                       SI = VgaModeTbl;
;               }
;       /* search AL */
;       /* if match, NC */
;       /* if not, CY */
;       }
;
SearchMode:
        test    [CodeStat],HangeulMode
        jz      SearchModeErr
        test    [Card1st],DualMnt
        jz      SearchModeDual
        cmp     al,7
        jz      @f
        cmp     al,0fh
        jz      @f
        cmp     al,70h
        jz      @f
        test    [rEquip],00110000b
        jpo     SearchModeDual          ; jump if color mode & color equip
        mov     al,7
        mov     [CurMode],al
        jmp     short SearchModeDual
@@:
        test    [rEquip],00110000b
        jpe     SearchModeDual          ; jump if mono mode & mono equip
        mov     al,3
        mov     [CurMode],al
SearchModeDual:
        mov     bl,[Card1st]
        and     bx,CardType
        mov     si,[bx+ModeTable]
@@:
        cmp     [si],al
        jz      SearchModeAdj
        cmp     byte ptr [si],-1
        jz      SearchModeDefault
        cmp     byte ptr [si],-2
        jz      SearchModeErr
        inc     si
        jmp     short @b
SearchModeErr:
        stc
        ret
SearchModeDefault:
        mov     al,7
        test    [Card1st],ColorMnt
        jz      @f
        mov     al,3
@@:
        mov     [CurMode],al
SearchModeAdj:
        cmp     al,2
        jnz     @f
        mov     al,3
@@:
        test    [Card1st],DualMnt
        jz      SearchModeAdj2
        cmp     al,40h
        jnz     @f
        test    [rEquip],00110000b
        jpo     @f
        mov     al,70h
        mov     [CurMode],al
@@:
        cmp     al,70h
        jnz     SearchModeAdj2
        test    [rEquip],00110000b
        jpe     SearchModeAdj2
        mov     al,40h
        mov     [CurMode],al
SearchModeAdj2:
        mov     ah,al
        cmp     ah,3
        jz      @f
        cmp     ah,7
        jnz     SearchModeDo
@@:
        test    [CodeStat],Chab or WSung7
        jnz     @f
        test    [Card1st],HanCard
        jnz     SearchModeDo
@@:
        or      ah,80h
        test    [Card1st],DualMnt
        jz      SearchModeDo
        or      ah,10h
SearchModeDo:
        mov     bl,[Card1st]
        and     bx,CardType
        shl     bx,1
        mov     si,[bx+ModeParmsTbl]
        add     bx,2
        mov     cx,[bx+ModeParmsTbl]
        mov     bx,ModeTblLng
@@:
        cmp     [si],ah
        jz      @f
        add     si,bx
        loop    @b
        jmp     SearchModeErr
@@:
        clc
        ret
ModeTable       label   word
                dw      offset MgaAllModeTbl
                dw      offset CgaAllModeTbl
                dw      offset EgaMAllModeTbl
                dw      offset EgaCAllModeTbl
                dw      offset McgaAllModeTbl
                dw      offset VgaAllModeTbl

MgaAllModeTbl   db      7, 40h, 70h, -1
CgaAllModeTbl   db      0, 1, 2, 3, 4, 5, 6, 40h, -1

ModeParmsTbl    label   word
                dw      offset MgaModeTbl
                dw      5
                dw      offset CgaModeTbl
                dw      4
                dw      offset EgaModeTbl
                dw      9
                dw      offset EgaModeTbl
                dw      9
                dw      offset VgaModeTbl
                dw      11
                dw      offset VgaModeTbl
                dw      11

MgaModeTbl      label   byte
        db  07h,0*2,07h,0b0h,0b0h,10h,000h,00000000b,25 ; han
        dw  0,  0,0b0ch
ModeTblLng      =       $-MgaModeTbl
        db  87h,1*2,07h,0b0h,0b8h,10h,080h,10000100b,25 ; single
        dw  38h,38ah,0b0ch
        db  97h,1*2,07h,000h,0b0h,00h,080h,00000100b,25 ; dual
        dw  38h,10ah,0b0ch
        db  40h,5*2,07h,000h,0b8h,00h,080h,01100100b,25 ;
        dw  38h,38ah,2e0fh
        db  70h,5*2,07h,000h,0b0h,00h,080h,00100100b,25 ;
        dw  38h,10ah,2e0fh

CgaModeTbl      label   byte
        db  03h,0*2,03h,0b8h,0b8h,10h,000h,01001000b,25 ; han
        dw  0,0,0607h
        db  83h,2*2,06h,000h,0b8h,00h,080h,01000100b,25 ; single
        dw  38h,0,0607h
        db  93h,2*2,06h,000h,0b8h,00h,080h,01000100b,25 ; dual
        dw  38h,0,0607h
        db  40h,5*2,06h,000h,0b8h,00h,080h,01100100b,25 ;
        dw  38h,0,2e0fh

;------------------------------------------------------------------------
;   << NorModeset >>
; FUNCTION = video mode setting
; INPUT   : AL, SI
; OUTPUT  : SI
; PROTECT : DS, ES, SI
;
; NorModeset(AL,SI/SI)
;       {
;       if (([Card1st] == CgaCard) || ([Card1st] == MgaCard))
;               {
;               if ([SI+sRealMode] ==  3/7)
;                       {
;                       ModeSetMonoText(SI/-);
;                       }
;               else
;                       {
;                       ModeSetMonoGrp(SI/-);
;                       }
;               }
;       else
;               {
;               if ([SI+sRealMode] ==  3/7)
;                       {
;                       ModeSetVgaText(SI/-);
;                       }
;               else
;                       {
;                       ModeSetVgaGrp(SI/-);
;                       }
;               }
;       }
;
NorModeset:
        mov     al,[si+sRealMode]
        mov     ah,[CurMode]
        and     ah,10000000B
        or      al,ah
        xor     ah,ah
        mov     bh,[si+sMode]
        mov     bl,[Card1st]
        and     bl,CardType
        cmp     bl,CgaCard
        ja      NorModesetVga
        cmp     bh,3
        jz      @f
        cmp     bh,7
        jz      @f
        jmp     ModeSetMonoGrp
@@:
        jmp     ModeSetMonoText
NorModesetVga:
        cmp     bh,3
        jz      @f
        cmp     bh,7
        jz      @f
        jmp     ModeSetVgaGrp
@@:
        jmp     ModeSetVgaText
ModeSetMonoText:
        pushf
        call    [OldVideo]
        mov     [Port3bf],0
        ret
ModeSetMonoGrp:
        mov     di,word ptr [rVdParm]
        add     di,[si+sAdjParms]
        xchg    di,word ptr [rVdParm]
        pushf
        call    [OldVideo]
        xchg    di,word ptr [rVdParm]
        mov     bx,[si].sParms
        or      bx,bx
        jz      @f
        mov     dx,3bfh
        mov     al,00000011b
        out     dx,al
        mov     dl,0b8h
        mov     al,bl
        out     dx,al
        mov     [rCrtModeSet],al
        mov     dl,0bfh
        mov     al,bh
        mov     [Port3bf],al
        out     dx,al
@@:
        ret

;------------------------------------------------------------------------
;   << SettingVariables >>
; FUNCTION = initialize variables
; INPUT   : SI
; OUTPUT  : SI
; PROTECT : DS, ES, SI
;
; SettingVariables(SI/SI)
;       {
; set flages
;       [HjStat] = [HjStat] || [OrgHjStat];
;       if ([CodeStat] == Chab), [HjStat] = [HjStat] && not (UdcLoaded or UdcArea);
;       if ([CodeStat] == WSung7), [HjStat] = [HjStat] && not (UdcLoaded or UdcArea or HjLoaded);
;       [ModeStat] = [SI+sStatus];
;       [DisplayStat] = [DisplayStat] && not RunEsc;
;       [ModeId] = [SI+sModeId];
;       [KbStat] = [KbStat] && not (HEStat or JJStat);
;       [HanStat] = 0;
;       [HjMenuStat] = 0;
;
; set internal constant
;       [MaxPage] = 1;
;       if ([ModeStat] == MultiPage), [MaxPage] = 8;
;       [MaxRows] = [SI+sRows];
;       [HjMenuLine] = [SI+sRows] - 1;
;       [CurPos] = 0;
;       [CurPage] = 0;
;       [TextPos1Addr] = 0;
;       [TextPos2Addr] = 0;
;       [GrpPosAddr] = 0;
;
; set ROM BIOS data area
;       AL = [CurMode];
;       if(AL != 1000000B)
;               {
;               [rInfo] == [rInfo] || 10000000B;
;               }
;       AL = AL && 01111111b;
;       ES:[rCrtMode] = AL;
;       ES:[rPoints] = 16;
;       ES:[rCrtCols] = 80;
;       ES:[rRows] = [MaxRows] - 1;
;       ES:[rCrtLen] = [SI+CodeSize];
;       if (ES:[rCrtLen] == 0), ES:[rCrtLen] = [SI+GrpSize];
;       ES:[rCurType] = [SI+sCurType];
;
; set code buffer address
;       BH = [SI+sCodeVram];
;       BL = 0;
;       AX = 0
;       if (BX == 0)
;               {
;               AX = [CodeBuf2Addr];
;               BX = [CodeBuf2Addr+2];
;               }
;       [CodeBuf1Addr] = AX;
;       [CodeBuf1Addr+2] = BX;
;
; Set EQUIP flag
;       if ([Card1st] != DualMnt)
;               {
;               if ([ModeStat] == ColorMode)
;                       /* set color equip */
;               else
;                       /* set mono equip */
;               }
;       }
;
SettingVariables:
; set flages
        mov     ah,[OrgHjStat]
        or      [HjStat],ah
        test    [CodeStat],WSung7
        jz      @f
        and     [HjStat],not (UdcLoaded or UdcArea or HjLoaded )
@@:
        mov     ah,[si+sStatus]
        test    [KseCard],Page1Fix
        jz      @f
        and     ah,not MultiPage
@@:
        mov     [ModeStat],ah
        and     [DisplayStat],not RunEsc
        mov     ah,[si+sModeId]
        mov     [ModeId],ah
if      WINNT
else
        and     [KbStat],not (HEStat or JJStat)
endif
        mov     [HanStat],0
        mov     [HjMenuStat],0
; set internal constant
        mov     [MaxPage],1
        test    [ModeStat],MultiPage
        jz      @f
        mov     [MaxPage],8
@@:
        mov     ah,[si+sRows]
        mov     [MaxRows],ah
        dec     ah
        mov     [HjMenuLine],ah
        mov     [CurPos],0
        mov     [CurPage],0
        mov     [TextPos1Addr],0
        mov     [TextPos2Addr],0
        mov     [GrpPosAddr],0
; set ROM BIOS data area
        mov     ah,[CurMode]
        and     [rInfo],01111111B
        mov     al,ah
        and     al,10000000B
        or      [rInfo],al
        and     ah,01111111b
        mov     [rCrtMode],ah
        mov     [rPoints],16
        mov     [rCrtCols],80
        mov     bl,[MaxRows]
        dec     bl
        mov     [rRows],bl
        mov     bh,[si+sCodeSize]
        or      bh,bh
        jnz     @f
        mov     bh,[si+sGrpSize]
@@:
        xor     bl,bl
        mov     [rCrtLen],bx
        mov     bx,[si+sCurType]
        mov     [rCurType],bx
; set code buffer address
        mov     bh,[si+sCodeVram]
        xor     bl,bl
        xor     ax,ax
        or      bx,bx
        jnz     @f
        mov     ax,word ptr [CodeBuf2Addr]
        mov     bx,word ptr [CodeBuf2Addr+2]
@@:
        mov     word ptr [CodeBuf1Addr],ax
        mov     word ptr [CodeBuf1Addr+2],bx
; set grp buffer address
        mov     bh,[si+sGrpVram]
        xor     bl,bl
        or      bx,bx
        jz      @f
        mov     word ptr [GrpBufAddr],0
        mov     word ptr [GrpBufAddr+2],bx
@@:
; Set EQUIP flag
        test    [Card1st],DualMnt
        jnz     @f
        or      [rEquip],00110000b
        test    [ModeStat],ColorMode
        jz      @f
        and     [rEquip],11101111b
@@:
        ret


;------------------------------------------------------------------------
;   << InitVideoBuffer >>
; FUNCTION = initialize video buffer(1st code, 2nd code and grp buffer)
; INPUT   : SI
; OUTPUT  : none
; PROTECT : DS, ES
;
; InitVideoBuffer(SI/-)
;       {
;       if ([CurMode] == 10000000b)
;               {
;               AX = 720h;
;               LES DI,[CodeBuf1Addr];
;               CX = 8000h;
;               if ([SI+sCodeSize] == 0), CX = [CodeBufSize];
;               CX = CX/2;
;               REP STOSW;
;               LES DI,[CodeBuf2Addr];
;               CX = [CodeBufSize]/2;
;               REP STOSW;
;               if ([SI+sGrpSize] != 0)
;                       {
;                       LES DI,[GrpBufAddr];
;                       CH = [SI+sGrpSize];
;                       CL = 0;
;                       CX = CX/2;
;                       AX = 0;
;                       REP STOSW;
;                       }
;               }
;       }
;
InitVideoBuffer:
        test    [CurMode],10000000b
        jnz     InitVideoBufferEnd
        push    es
        mov     ax,720h
        les     di,[CodeBuf1Addr]
        mov     cx,8000h
        cmp     [si+sCodeSize],0
        jnz     @f
        mov     cx,[CodeBufSize]
@@:
        shr     cx,1
if      HotKey
        test    [KbStat],ReqEnvrChg
        jz      @f
        test    [KbMisc],RunningHot
        jz      @f
        or      di,di
        jnz     InitGrpBuffer
        rep stosw
        jmp     short InitGrpBuffer
@@:
endif   ; if HotKey
        rep stosw
        les     di,[CodeBuf2Addr]
        mov     cx,[CodeBufSize]
        shr     cx,1
        rep stosw
InitGrpBuffer:
        mov     ch,[si+sGrpSize]
        or      ch,ch
        jz      @f
        les     di,[GrpBufAddr]
        xor     cl,cl
        shr     cx,1
        xor     ax,ax
        rep stosw
@@:
        pop     es
InitVideoBufferEnd:
        ret

;========================================================================
;       << SetCurType >>
; FUNCTION = set cursor type
; INPUT   :  AH = 01h
;            CH = cursor start, CL = cursor end
;           (CH)    7 6 5 4 3 2 1 0
;                   | | | | | | | |
;                   | | | +-+-+-+-+--- cursor start
;                   | | +------------- 0 : cursor on, 1 : off
;                   +-+--------------- not used
;           (CL)    7 6 5 4 3 2 1 0
;                         | | | | |
;                         +-+-+-+-+--- cursor end
; OUTPUT  : none
; PROTECT : none
; SetCurType(CX/-)
;       {
;       ClearCursor(-/-);
;       switch([ModeId])
;               case 0 :                        ;  card, TEXT mode 2/3/7
;                       call [OldInt10];
;                       break;
;               case 2 :                        ; TE mode 7, MGA
;               case 4 :                        ; TE mode 2/3, CGA
;               case 6 :                        ; TE mode 7, EGA/VGA
;               case 8 :                        ; TE mode 2/3, EGA/VGA
;               case 10 :                       ; mode 40/70
;               case 12 :                       ; mode 60/11/12, EGA/VGA
;       ES:[rCurType] = CX;
;       }

SetCurType:
        call    ClearCursor
        pushf
        call    [OldVideo]
        mov     [rCurType],cx
        cmp     [Modeid],2*0
        jnz     SetCurTypeEnd
        test    [rInfo],00000001b
        jz      SetCurTypeEnd
        test    [Card1st],00001100b
        jz      SetCurTypeEnd           ; jump if not EGA or VGA card
        cmp     ch,cl
        ja      @f
        mov     ax,cx
        and     cx,0f0fh
        cmp     cl,5
        jb      SetCurTypeMonoCL
        inc     cl
        cmp     cl,10
        jb      SetCurTypeMonoCL
        inc     cl
SetCurTypeMonoCL:
        cmp     ch,5
        jb      SetCurTypeMonoCH
        inc     ch
        cmp     ch,10
        jb      SetCurTypeMonoCH
        inc     ch
SetCurTypeMonoCH:
        mov     dh,ah
        and     dh,20h
        or      ch,dh
        test    [ModeStat],ColorMode
        jz      @f
        mov     cx,ax
        and     cx,0707h
        shl     cx,1
        mov     dh,ah
        and     dh,20h
        or      ch,dh
@@:
        mov     dx,[rAddr6845]
        mov     al,0ah
        mov     ah,ch
        out     dx,ax
        inc     al
        mov     ah,cl
        out     dx,ax
SetCurTypeEnd:
        ret


;========================================================================
;       << SetCurPos >>
; FUNCTION = set cursor position
; INPUT   : AH = 02h
;           BH = page #, DX = cursor position
; OUTPUT  : none
; PROTECT : AX, BX, CX, DX, ES, DS
; SetCurPos(BH,DX/-)
;       {
;       if ([MaxPage] == 1), BH = 0;
;       if (BH >= [MaxPage]), BH = [CurPage];
;       if (DL >= 80), return;
;       if (DH >= [MaxRows]), return;
;       save AX, BX;
;       ClearCursor(-/-);
;       if ([ModeId = 0*2)
;               AH = 2;
;               call [OldInt10];
;       ES:[BH*2+rCurPos] = DX;
;       restore AX,BX;
;       }

SetCurPosAll:
        cmp     [ModeId],0*2
        jne     SetCurPos
        jmp     VdDummyRet
SetCurPos:
        cmp     [MaxPage],1
        ja      @f
        xor     bh,bh
@@:
        cmp     bh,[MaxPage]
        jb      @f
        mov     bh,[CurPage]
@@:
        @push   ax,bx
        call    ClearCursor
        cmp     [ModeId],0*2
        jne     @f
        mov     ah,2
        pushf
        call    [OldVideo]
@@:
        xchg    bh,bl
        xor     bh,bh
        shl     bx,1
        mov     [bx+rCurPos],dx
        @pop     bx,ax
        ret


;========================================================================
;       << GetCurPos >>
; FUNCTION = get cursor position
; INPUT   : AH = 03h
;           BH = page #
; OUTPUT  : CX = cursor type, DX = cursor position
; PROTECT : none
; GetCurPos(BH/CX,DX)
;       {
;       if ([MaxPage] == 1), BH = 0;
;       if (BH >= [MaxPage]), BH = [CurPage];
;       SS:[BP+rCX] = ES:[rCurType];
;       SS:[BP+rDX] = ES:[BH*2 + rCurPos];
;       }

GetCurPos:
        cmp     [MaxPage],1
        ja      @f
        xor     bh,bh
@@:
        cmp     bh,[MaxPage]
        jb      @f

        mov     bh,[CurPage]
@@:
        mov     ax,[rCurType]
        mov     [bp+rCX],ax
        xchg    bh,bl
        xor     bh,bh
        shl     bx,1
        mov     ax,[bx+rCurPos]
        mov     [bp+rDX],ax
        ret


;========================================================================
;       << SetPage >>
; FUNCTION = set display page
; INPUT   : AH = 05h
;           AL = page #
; OUTPUT  : none
; PROTECT : none
; SetPage(AL/-)
;       {
;       if (AL >= [MaxPage]), return;
;       if (AL = [CurPage] || [MaxPage] = 1), return;
;       [HanStat] = [HanStat] && not Han1st;
;       ClearCursor(-/-);
;       if ([ModeId] = 0*2)
;               {
;               call [OldInt10];
;               AL = ES:[rCurPage];
;               }
;       ES:[rCurPage] = AL;
;       [CurPage] = AL;
;       ES:[rCrtStart] = AL * ES:[rCrtLen];
;       }

SetPage:
        cmp     al,[MaxPage]
        jae     SetPageExit
        cmp     al,[CurPage]
        jz      SetPageExit
        cmp     [MaxPage],1
        jz      SetPageExit
        and     [HanStat],not Han1st
        call    ClearCursor
        cmp     [ModeId],0*2
        jnz     @f
        pushf
        call    [OldVideo]
        mov     al,[rCurPage]
@@:
        mov     [rCurPage],al
        mov     [CurPage],al
        xor     ah,ah
        mul     [rCrtLen]
        mov     [rCrtStart],ax
SetPageExit:
        ret


;========================================================================
;       << ReadCharAttr >>
; FUNCTION = read character & attribute at current cursor position
; INPUT   : AH = 08h
;           BH = page #
; OUTPUT  : AL = char, AH = attribute(grp mode = don't care)
; PROTECT : none
; ReadCharAttr(BH/AL,AH)
;       {
;       if ([MaxPage] == 1), BH = 0;
;       if (BH >= [MaxPage]), BH = [CurPage];
;       DX = [BH*2+rCurPos];
;       SI = DH*80*2+DL*2;
;       AX = [CodeBuf1Addr:[SI + [rCrtLen] * BH]];
;       }

ReadCharAttr:
        cmp     [MaxPage],1
        ja      @f
        xor     bh,bh
@@:
        cmp     bh,[MaxPage]
        jb      @f
        mov     bh,[CurPage]
@@:
        mov     bl,bh
        xor     bh,bh
        shl     bx,1
        mov     dx,[bx+rCurPos]
        mov     ax,80
        mul     dh
        xor     dh,dh
        add     ax,dx
        shl     ax,1
        mov     si,ax
        mov     ax,[rCrtLen]
        shr     bx,1
        mul     bx
        add     ax,si
        lds     si,[CodeBuf1Addr]
        add     si,ax
        lodsw                                   ; AX = Cahracter : Attribute
@@:
        ret


;========================================================================
;       << GetMode >>
; FUNCTION = get mode, page and columns
; INPUT   : AH = 0Fh
; OUTPUT  : AL = video mode,  AH = columns, BH = current page
; PROTECT : none
; GetMode(-/AL,AH,BH)
;       {
;       call [OldInt10];
;       AL = [CurMode] + buffer clear information(0:487 bit7);
;       SS:[BP+rBX] = BX
;       }

GetMode:
        pushf
        call    [OldVideo]
        mov     al,[rCrtMode]
        mov     bl,[rInfo]
        and     bl,10000000b                    ; buffer clear information
        or      al,bl
        mov     cx,ss:[bp+rBX]
        mov     bl,cl
        mov     ss:[bp+rBX],bx
        ret


;========================================================================
;       << Attribute >>
; Function = Skip if english ext. video card and video mode 2, 3, 7, 40, 70
;            in EGA/VGA/MCGA card.
; INPUT : AH = 010h
;         AL = 03h
;         BL = blink/intensity toggle ( 0 : enable intensity, 1 : enable blinking)
; OUTPUT  : none
; PROTECT : none
Attribute:
        test    [ModeStat],EmuCursor
        jz      GoToVdRom
        test    [ModeStat],GrpMode
        jnz     GoToVdRom
        cmp     ax,1002h
        jz      @f
        cmp     ax,1003h                ; intensity function ?
        jnz     GoToVdRom
@@:
        ret
JmpVdDummyjj:
        jmp     JmpVdDummy
GoToVdRom:
if      KseVga
        test    cs:[KseCard],00000001b
        jz      JmpVdDummyjj
        cmp     [ModeId],0
        jnz     JmpVdDummyjj
        cmp     al,1
        jz      @f
        cmp     al,2
        jnz     JmpVdDummyjj
@@:
        push    ax
        push    bx
        push    dx
        mov     ah,4                    ; border chip on
        mov     dx,03CCh
        in      al,dx
        test    al,80h                  ; VS Negative ?
        jnz     @f                      ; No Positive
        or      ah,1                    ; border_0
@@:                                     ; border_1
        test    al,40h                  ; HS Negative ?
        jnz     @f                      ; No Positive
        or      ah,2
@@:                                     ; border_2
        mov     dx,257h
        in      al,dx
        mov     al,2                    ; index 2 control reg
        out     dx,al
        mov     al,ah
        out     dx,al
        in      al,dx
        mov     al,0                    ; index 0 border position
        out     dx,al
        mov     al,94h
        out     dx,al
        in      al,dx
        mov     al,1                    ; index 0 border width
        out     dx,al
        mov     al,8
        out     dx,al
        in      al,dx
        mov     al,3                    ; index 0 border color sampling position
        out     dx,al
        mov     al,8
        out     dx,al
        pop     dx
        pop     bx
        pop     ax
endif   ;KseVga
        cmp     ax,1001h
        jz      @f
        cmp     ax,1002h
        jz      @f
        jmp     JmpVdDummy
@@:
        mov     bl,010h
        cmp     [CurMode],060h
        jz      @f
        cmp     [CurMode],040h
        jz      @f
        mov     bl,00fh
        cmp     [CurMode],070h
        jz      @f
        jmp     JmpVdDummy
@@:
        mov     ES:[rCrtMode],bl
        add     sp,2
        @pop    bp,ds,es,di,si,dx,cx,bx
        pushf
        call    cs:[OldVideo]
        dec     cs:[VideoActive]
        @push   ax,es
        xor     ax,ax
        mov     es,ax
        mov     al,CS:[CurMode]
        mov     ES:[rCrtMode],al
        @pop    es,ax
        iret
JmpVdDummy:
        jmp     VdDummyRet              ; go to ROM bios


;========================================================================
;       << WriteCharAttr >>
; FUNCTION = write character & attribute at given page
; INPUT   : AH = 09h
;           AL = char, BL = attr, BH = page, CX = counter
; OUTPUT  : none
; PROTECT : none
;========================================================================
;       << WriteChar >>
; FUNCTION = write character at given page with current attribute
; INPUT   : AH = 0Ah
;           AL = char, (BL = attr), BH = page, CX = counter
; OUTPUT  : none
; PROTECT : none
; WriteCharAttr(AL,BX,CX/-)
; WriteChar(AL,BX,CX/-)
;       {
;       CalcCurPosPage(BH/DX,[TextPos1Addr],[TextPos2Addr],[GrpPosAddr]);
;       if ([DisplayStat] == RunEsc), jump EscSequence(AX,BX,CX,DX/-);
;       if (AL = EscKey) && (CX = 1), jump EscSequence(AX,BX,CX,DX/-);
;       if ([MaxPage] == 1), BH = 0;
;       if (BH >= [MaxPage]), BH = [CurPage];
;       WriteCharAll(AL,AH,BL,BH,CX,DX/-);
;       }

WriteCharAttr:
WriteChar:
        cmp     [MaxPage],1
        ja      @f
        xor     bh,bh
@@:
        cmp     bh,[MaxPage]
        jb      @f
        mov     bh,[CurPage]
@@:
        call    CalcCurPosPage
        test    [DisplayStat],RunEsc
        jz      @f
        jmp     EscSequence
@@:
        cmp     al,EscKey
        jne     WriteCharEsc
        cmp     cx,1
        jne     WriteCharEsc
        jmp     EscSequence
WriteCharEsc:
        call    WriteCharAll
        ret


;========================================================================
;       << WriteTty >>
; FUNCTION = write character with cursor moving
; INPUT   : AH = 0Eh
;           AL = charr, (BL = attr)
; OUTPUT  : none
; PROTECT : none
;========================================================================
;       << WriteTtyInterim >>
; FUNCTION = write char and cursor move with interim char
; INPUT   : AH = 0FEh
;           AL = char, (BL = attr)
; OUTPUT  : none
; PROTECT : none
;
; WriteTty(AL,BL/-)
; WriteTtyInterim(AL,BL/-)
;       {
;       BH = [CurPage];
;       CalcCurPosPage(BH/DX,[TextPos1Addr],[TextPos2Addr],[GrpPosAddr]);
;       switch(AL)
;               case CR :
;                       if ([HanStat] == Han1st), DispEnglishOld(-/-);
;                       [HanStat] = [HanStat] && not Han1st;
;                       DL = 0;
;                       SetCurPos(BH,DX/-);
;                       break;
;               case LF :
;                       if ([HanStat] == Han1st), DispEnglishOld(-/-);
;                       [HanStat] = [HanStat] && not Han1st;
;                       if (DH = [MaxRows]-1), FullScroll(BH/-);
;                       if (DH < [MaxRows]-1), DH = DH+1;
;                       SetCurPos(BH,DX/-);
;                       break;
;               case BELL :
;                       AX = 0e07h;
;                       call [OldInt10];
;                       break;
;               case BS :
;                       if (DL = 0), return;
;                       if ([HanStat] == Han1st), DispEnglishOld(-/-);
;                       [HanStat] = [HanStat] && not Han1st;
;                       DL = DL-1
;                       SetCurPos(BH,DX/-);
;                       break;
;               default :
;                       CX = 1;
;                       if (AH == 0eh)
;                               {
;                               WriteCharAll(AL,AH,BL,BH,CX,DX/-);
;                               +DL;
;                               if (DL >= 80)
;                                       {
;                                       DL = 0;
;                                       +DH;
;                                       if (DH >= [MaxRows])
;                                               FullScroll(BH/-);
;                                               -DH;
;                                       }
;                               SetCurPos(BH,DX/-);
;                               }
;                       else
;                               {
;                               AH = 0eh;
;                               [OldHanStat] = [HanStat];
;                               WriteCharAll(AL,AH,BL,BH,CX,DX/-);
;                               DL = DL+1;
;                               if ([HanStat] != Han1st) &&
;                                  ([OldHanStat] == Han1st)), DL = DL-2;
;                               SetCurPos(BH,DX/-);
;                               }
WriteTty:
WriteTtyInterim:
        mov     bh,[CurPage]
        call    CalcCurPosPage
        cmp     al,CR
        jne     WriteTtyLF
        test    [HanStat],Han1st
        jz      @f
        call    DispEnglishOld
        and     [HanStat], not Han1st
@@:
        xor     dl,dl
        call    SetCurPos
        ret

WriteTtyLF:
        cmp     al,LF
        jne     WriteTtyBELL
        test    [HanStat],Han1st
        jz      @f
        call    DispEnglishOld
        and     [HanStat],not Han1st
@@:
        inc     dh
        cmp     dh,[MaxRows]
        jne     @f
        dec     dh
        jmp     FullScroll
@@:
        call    SetCurPos
        ret

WriteTtyBELL:
        cmp     al,BELL
        jne     @f
        mov     ax,0e07h
        pushf
        call    [OldVideo]
        ret
@@:
        cmp     al,BS
        jne     WriteTtyDefault
        or      dl,dl
        jz      WriteTtyTmpExit
        test    [HanStat],Han1st
        jz      @f
        call    DispEnglishOld
        and     [HanStat], not Han1st
@@:
        dec     dl
        call    SetCurPos
WriteTtyTmpExit:
        ret

WriteTtyDefault:
        mov     cx,1
        cmp     ah,0Eh
        jnz     WriteTtyFE
        call    WriteCharAll
        inc     dl
        cmp     dl,80
        jb      @f
        xor     dl,dl
        inc     dh
        cmp     dh,[MaxRows]
        jnz     @f
        dec     dh
        call    FullScroll
@@:
        call    SetCurPos
        ret

WriteTtyFE:
;
;       old Han1st      new Han1st
;           0               0           none
;           0               1           inc
;           1               0           dec
;           1               1           dec
;
        mov     ah,[HanStat]
        mov     [OldHanStat],ah
        mov     ah,0eh
        call    WriteCharAll
        test    [OldHanStat],Han1st     ; 00, 01, 10, 11
        jz      @f
        dec     dl                      ; 10, 11
        jmp     short TtySeyCurPos
@@:
        test    [HanStat],Han1st        ; 00, 01
        jz      TtySeyCurPos
        inc     dl                      ; 01
TtySeyCurPos:
        call    SetCurPos
WriteStringEnd:
        ret


;========================================================================
;       << WriteString >>
; FUNCTION = write string
; INPUT   : AH = 13h, AL = function
;           BH = page, BL = attr(AL=0,1), CX = counter, DX = curpos
;           ES:BP = string pointer
; OUTPUT  : none
; PROTECT : none
WriteString:
        cmp     al,3
        ja      WriteStringEnd
        jcxz    WriteStringEnd
        mov     si,[bp+rBP]
        mov     ds,[bp+rES]
        mov     di,bx
        mov     bl,bh
        xchg    di,bx
        and     di,0fh
        shl     di,1
        push    [di+rCurPos]            ; save curpos
        mov     di,ax
        mov     ah,2
        int     10h
WriteStrLoop:
; BL = attr(AL=0,1), BH = page, DX = curpos, DS:SI = string position
; ES = data segment, DI = function
        lodsb
        test    di,00000010b
        jz      @f
        xchg    al,bl
        lodsb
        xchg    al,bl
@@:
        push    cx
        push    si
        push    ds
        mov     cx,cs
        mov     ds,cx
        cmp     al,cr
        jz      WriteStr0E
        cmp     al,lf
        jz      WriteStr0E
        cmp     al,bell
        jz      WriteStr0E
        cmp     al,bs
        jz      WriteStr0E
        test    [HanStat],Han1st
        jnz     WriteStrEng
        call    CheckCodeRange1st
        jc      WriteStrEng
        cmp     dl,80-1
        jb      WriteStrEng
        test    [CodeStat],WSung7
        jnz     WriteStrEng
        xor     dl,dl
        inc     dh
        cmp     dh,[MaxRows]
        jnz     @f
        dec     dh
        call    FullScroll
@@:
        call    SetCurPos
WriteStrEng:
        mov     cx,1
        mov     ah,9
        int     10h
        inc     dl
        cmp     dl,80
        jb      @f
        xor     dl,dl
        inc     dh
        cmp     dh,[MaxRows]
        jnz     @f
        dec     dh
        call    FullScroll
@@:
        call    SetCurPos
        jmp     short @f
WriteStr0E:
        mov     ah,0eh
        int     10h
        mov     ah,3
        int     10h
@@:
        pop     ds
        pop     si
        pop     cx
        loop    WriteStrLoop
        pop     dx                      ; restore curpos
        test    di,00000001b
        jnz     @f
        mov     ah,2
        int     10h
@@:
        ret


;------------------------------------------------------------------------
;       << WriteCharAll >>
; FUNCTION = write hangeul/english char
; INPUT   : AH = 9/0ah/0eh function
;           AL = char, (BL = attr), BH = page, CX = counter, DX = cursor pos
; OUTPUT  : none
; PROTECT : BH, DX, DS, ES
;
; WriteCharAll(AL,AH,BL,BH,CX,DX/-)
;       {
;       GetAttr(AH,BL,BH/BL);
;       if (CheckCodeRangeWord(AX/carry)=DBCS(NC) && ([HanStat] == Han1st)
;          && ([OldCurPos] = DX) && ([OldPage] = BH))
;               DispHangeul(AL,BL,BH/-);
;       else
;               {
;               if ([HanStat] == Han1st)
;                       DispEnglishOld(-/-);
;               if (CheckCodeRange1st(AL/carry) = DBCS(NC))
;                       {
;                       if ((DL >= 80-1)
;                               {
;                               if ([CodeStat] == WSung7)
;                                       goto DispEnglishNew(AL,BX,CX/-);
;                               else
;                                       {
;                                       DL = 0;
;                                       +DH;
;                                       if (DH >= [MaxRows])
;                                               {
;                                               FullScroll(BH/-);
;                                               -DH;
;                                               }
;                                       SetCurPos(BH,DX/-);
;                                       CalcCurPosPage(BH/DX,[TextPos1Addr],[TextPos2Addr],[GrpPosAddr]);
;                                       }
;                               }
;                       /* save AL,BL,BH,CX,DH,DL+1,[TextPos1Addr],[TextPos2Addr],
;                               [GrpPosAddr] to old */
;                       if ([CodeStat] == WSung7), DispEnglishNew(AL,BX,CX/-);
;                       [HanStat] = [HanStat] || Han1st;
;                       }
;               else
;                       DispEnglishNew(AL,BX,CX/-);
;               }
;       }

WriteCharAll:
        call    GetAttr
        test    [HanStat],Han1st
        jz      DispHanEnglish
        cmp     [OldCurPos],dx
        jnz     @f
        cmp     [OldPage],bh
        jnz     @f
        push    ax
        mov     ah,[OldChar]
        call    CheckCodeRangeWord
        pop     ax
        jc      @f
        jmp     DispHangeul
@@:
        call    DIspEnglishOld
        and     [HanStat],not Han1st
DispHanEnglish:
        call    CheckCodeRange1st
        jc      DispEnglish
         call    CheckCurPos1st
         jc      @f
         jmp     DispHangeul
 @@:
        cmp     dl,80-1
        jb      DispSaveAddr
        cmp     ah,0ah
        jbe     DispEnglish
        test    [CodeStat],WSung7
        jnz     DispEnglish
        xor     dl,dl
        inc     dh
        cmp     dh,[MaxRows]
        jnz     @f
        dec     dh
        call    FullScroll
@@:
        call    SetCurPos
        call    CalcCurPosPage
DispSaveAddr:
        mov     [OldChar],al
        mov     [OldAttr],bl
        mov     [OldPage],bh
        mov     [OldCounter],cx
        mov     [OldCurPos],dx
        inc     [OldCurPos]
        mov     di,[TextPos1Addr]
        mov     [OldTextPos1Addr],di
        mov     di,[TextPos2Addr]
        mov     [OldTextPos2Addr],di
        mov     di,[GrpPosAddr]
        mov     [OldGrpPosAddr],di
        test    [CodeStat],WSung7
        jz      @f
        call    DispEnglishNew
@@:
        or      [HanStat],Han1st
        ret
DispEnglish:
        call    DispEnglishNew
        ret

CheckCurPos1st:
        test    [CodeStat],Chab or WSung7
        jnz     CheckCurPos1stR
        test    [Card1st],HanCard
        jnz     CheckCurPos1stR
        cmp     dl,0
        jz      CheckCurPos1stR
        @push   ds,si,ax,bx,cx,dx
        mov     cl,dl
        sub     cl,1
        std
        lds     si,[CodeBuf1Addr]
        add     si,cs:[TextPos1Addr]
        lodsw
        xor     ch,ch
        xor     bl,bl
        lodsw
        mov     dx,ax
        call    CheckHanType
        and     al,00000011b
        cld
        cmp     al,00000001b
        jnz     @f
        mov     [OldChar],dl
        mov     [OldAttr],dh
        mov     cx,01
        mov     [OldCounter],cx
        @pop    dx,cx,bx,ax
        mov     [OldPage],bh
        mov     [OldCurPos],dx
        mov     si,[TextPos1Addr]
        sub     si,2
        mov     [OldTextPos1Addr],di
        mov     si,[TextPos2Addr]
        sub     si,2
        mov     [OldTextPos2Addr],di
        mov     si,[GrpPosAddr]
        sub     si,2
        mov     [OldGrpPosAddr],di
        @pop    si,ds
        clc
        ret
@@:
        @pop    dx,cx,bx,ax,si,ds
CheckCurPos1stR:
        stc
        ret

;------------------------------------------------------------------------
;       << EscSequence >>
; FUNCTION = write english char
; INPUT   : AL = char, BL = attr, BH = page, CX = counter, DX = cursor pos
; OUTPUT  : none
; PROTECT : AX, BX, CX, DX, DS, ES
;
; EscSequence(AX,BX,CX,DX/-)
;       {
;       if ([DisplayStat] == RunEsc)
;               {
;               switch([EscIndex])
;                       case 0:
;                               if (AL == '$'), EscIndex=1*2, break;
;                               if (AL == '('), EscIndex=3*2, break;
;                               DispEnglishOld(-/-);
;                               [EscIndex] = 0;
;                               [DisplayStat] = [DisplayStat] && not RunEsc;
;                               jmp WriteCharEsc;
;                       case 2:
;                               if (AL == ')'), [EscIndex] = 2*2, break;
;                               [EscIndex] = 0;
;                               [DisplayStat] = [DisplayStat] && not RunEsc;
;                               jmp WriteCharEsc;
;                       case 4:
;                               if (AL == '1'), /* set hangeul key in mode */
;                               [EscIndex] = 0;
;                               [DisplayStat] = [DisplayStat] && not RunEsc;
;                               jmp WriteCharEsc;
;                       case 6:
;                               if (AL == '2'), /* reset hangeul key in mode */
;                               [EscIndex] = 0;
;                               [DisplayStat] = [DisplayStat] && not RunEsc;
;                               jmp WriteCharEsc;
;               }
;       else
;               /* save AL,BL,BH,CX,DX
;                       [TextPos1Addr],[TextPos2Addr],[GrpPosAddr] to old */
;               [DisplayStat] = [DisplayStat] || RunEsc;
;               [EscIndex] = 0;
;       }

EscSequence:
        test    [DisplayStat],RunEsc
        jz      RunEscStart
        mov     si,[EscIndex]
        jmp     [si+EscSeqJmpTbl]

EscSeqJmpTbl    Label   Word
        dw      offset  EscIndexDollar
        dw      offset  EscIndexLeftBr
        dw      offset  EscIndex1
        dw      offset  EscIndex2

RunEscStart:
        mov     [OldChar],al
        mov     [OldAttr],bl
        mov     [OldPage],bh
        mov     [OldCounter],cx
        mov     [OldCurPos],dx
        mov     di,[TextPos1Addr]
        mov     [OldTextPos1Addr],di
        mov     di,[TextPos2Addr]
        mov     [OldTextPos2Addr],di
        mov     di,[GrpPosAddr]
        mov     [OldGrpPosAddr],di
        or      [DisplayStat],RunEsc
        mov     [EscIndex],0
        ret
EscIndexDollar:
        cmp     al,'$'
        jne     @f
        mov     [EscIndex],1*2
        ret
@@:
        cmp     al,'('
        jne     @f
        mov     [EscIndex],3*2
        ret
@@:
        call    DispEnglishOld
EscBreak:
        mov     [EscIndex],0
        and     [DisplayStat],not RunEsc
        jmp     WriteCharEsc
EscIndexLeftBr:
        cmp     al,')'
        jne     EscBreak
        mov     [EscIndex],2*2
        ret
EscIndex1:
        cmp     al,'1'
        jne     EscBreak
        or      [KbStat],HEStat                 ; Hangeul On
        mov     [EscIndex],0
        and     [DisplayStat],not RunEsc
        ret
EscIndex2:
        cmp     al,'2'
        jne     EscBreak
        and     [KbStat],not HEStat             ; Hangeul Off
        mov     [EscIndex],0
        and     [DisplayStat],not RunEsc
        ret


;------------------------------------------------------------------------
;       << CalcCurPosPage >>
; FUNCTION = calculation cursor position
; INPUT    : BH
; OUTPUT   : DX
;          : [TextPos1Addr],[TextPos2Addr],[GrpPosAddr]
; PROTECT  : AX,BX,CX
;
; CalcCurPosPage(BH/DX,[TextPos1Addr],[TextPos2Addr],[GrpPosAddr])
;       {
;       save AX,BX,CX;
;       CX = ES:[BH*2+rCurPos];
;       [TextPos1Addr] = CH*80*2+CL*2+ES:[rCrtLen]*BH;
;       [TextPos2Addr] = CH*80*2+CL*2;
;       if ([ModeId] == HgcGrpMode(ModeId=2/4/10)
;               {
;               [GrpPosAddr] = CH*80*4+CL;
;               }
;       [GrpPosAddr] = CH*80*16+CL;
;       [CurPos] = CX;
;       DX = CX;
;       restore AX,BX,CX;
;       }

CalcCurPosPage:
        @push   ax,bx,cx
        mov     bl,bh
        xor     bh,bh
        shl     bx,1
        mov     cx,[bx+rCurPos]
        mov     [CurPos],cx
        mov     al,80
        mul     ch
        mov     dx,cx                   ; GrpPosAddr  
        xor     dh,dh
        add     ax,dx
        shl     ax,1
        mov     [TextPos1Addr],ax
        mov     [TextPos2Addr],ax
        mov     ax,[rCrtLen]
        shr     bx,1
        mul     bx
        add     [TextPos1Addr],ax
        mov     ax,80*4
        cmp     [ModeId],4
        jbe     @f
        cmp     [ModeId],5*2
        jz      @f
        mov     ax,80*16
@@:
        mov     dl,ch
        xor     dh,dh
        mul     dx
        xor     ch,ch
        add     ax,cx
        mov     [GrpPosAddr],ax
        mov     dx,[CurPos]
        @pop    cx,bx,ax
        ret


;------------------------------------------------------------------------
;       << GetAttr >>
; FUNCTION = get attribute
; INPUT    : AH = 9/0ah/0eh function
;            BH = page#
;            BL = attribute
; OUTPUT   : BL = attribute
; PROTECT  : AX,BH,CX,DX,DS,ES,SI
;       {
;       if (([ModeStat] != GrpMode) || (AH != 9))
;               {
;               save DS,SI;
;               BL = CodeBuf1Addr:[[CodeBuf1Addr]+[TextPos1Addr]+1];
;               restore DS,SI;
;               }
;       }
; GetAttr(AH,BL,BH/BL)

GetAttr:
        test    [ModeStat],GrpMode
        jnz     @f
        cmp     ah,09h
        jz      @f
        @push   di,es
        les     di,[CodeBuf1Addr]
        add     di,[TextPos1Addr]
        mov     bl,es:[di+1]
        @pop    es,di
@@:
        ret


;========================================================================
;       << WritePixel >>
; FUNCTION = write graphics pixel
; INPUT   : AH = 0Ch
;           AL = color, BH = page, CX = graphics columns, DX = graphics rows
; OUTPUT  : none
; PROTECT : none
; WritePixel(AL,BH,CX,DX/-)
;       {
;       switch([ModeId])
;               case 0 :                        ;  card, TEXT mode 2/3/7
;               case 2 :                        ; TE mode 7, MGA
;               case 4 :                        ; TE mode 2/3, CGA
;               case 6 :                        ; TE mode 7, EGA/VGA
;               case 8 :                        ; TE mode 2/3, EGA/VGA
;                       break;
;               case 10 :                       ; mode 40/70
;                       MgaWritePixel(AL,CX,DX/-);
;                       break;
;               case 12 :                       ; mode 60/11/12, EGA/VGA
;                       VgaWritePixel(AL,CX,DX/-);
;                       break;
;       }

WritePixel:
        les     di,[GrpBufAddr]
        xchg    si,bx
        mov     bl,[ModeId]
        xor     bh,bh
        xchg    si,bx
        jmp     [si+WritePixelJmpTbl]

WritePixelJmpTbl        Label   Word
        dw      offset  WrtPxlHanCardText
        dw      offset  WrtPxlMgaTE
        dw      offset  WrtPxlCgaTE
        dw      offset  WrtPxlEgaVgaTE7
        dw      offset  WrtPxlEgaVgaTE2_3
        dw      offset  MgaWritePixel
        dw      offset  VgaWritePixel

WrtPxlHanCardText:
WrtPxlMgaTE:
WrtPxlCgaTE:
WrtPxlEgaVgaTE7:
WrtPxlEgaVgaTE2_3:
        ret


;========================================================================
;       << ReadPixel >>
; FUNCTION = write graphics pixel
; INPUT   : BH = page, CX = graphics columns, DX = graphics rows
; OUTPUT  : AL = color
; PROTECT : none
; ReadPixel(BH,CX,DX/)
;       {
;       switch([ModeId])
;               case 0 :                        ;  card, TEXT mode 2/3/7
;               case 2 :                        ; TE mode 7, MGA
;               case 4 :                        ; TE mode 2/3, CGA
;               case 6 :                        ; TE mode 7, EGA/VGA
;               case 8 :                        ; TE mode 2/3, EGA/VGA
;                       break;
;               case 10 :                       ; mode 40/70
;                       MgaReadPixel(BH,CX,DX/AL);
;                       break;
;               case 12 :                       ; mode 60/11/12, EGA/VGA
;                       VgaReadPixel(BH,CX,DX/AL);
;                       break;
;       }

ReadPixel:
        les     di,[GrpBufAddr]
        xchg    si,bx
        mov     bl,[ModeId]
        xor     bh,bh
        xchg    si,bx
        jmp     [si+ReadPixelJmpTbl]

ReadPixelJmpTbl Label   Word
        dw      offset  RdPxlHanCardText
        dw      offset  RdPxlMgaTE
        dw      offset  RdPxlCgaTE
        dw      offset  RdPxlEgaVgaTE7
        dw      offset  RdPxlEgaVgaTE2_3
        dw      offset  MgaReadPixel
        dw      offset  VgaReadPixel

RdPxlHanCardText:
RdPxlMgaTE:
RdPxlCgaTE:
RdPxlEgaVgaTE7:
RdPxlEgaVgaTE2_3:
        ret


;========================================================================
;       << ScrollUp >>
; FUNCTION = window scroll up
; INPUT   : AH = 06h
;           AL = scroll line #, CX = window start, DX = window end
;           BH = attribute to be used on blank lines
; OUTPUT  : none
; PROTECT : none
;========================================================================
;       << ScrollDown >>
; FUNCTION = window scroll down
; INPUT   : AH = 07h
;           AL = scroll line #, CX = window start, DX = window end
;           BH = attribute to be used on blank lines
; OUTPUT  : none
; PROTECT : none
; ScrollUp(AL,BH,CX,DX/-)
; ScrollDown(AL,BH,CX,DX/-)
;       {
;       if (CL > DL), xchg CL,DL;
;       if (CH > DH), xchg CH,DH;
;       if (DL >= 80), return;
;       if (DH >= [MaxRows]), return;
;       if (AL > (DL-CL)), AL=(DL-CL);            /* scroll line counter */
;       if ([ModeStat] == GrpMode)
;               {
;               if (BH = 0), BH = 7;
;               if (BH = -1), BH = 70h;
;               }
;       [HanStat] = [HanStat] && not Han1st;
;       TextEmu(-/-);
;       ClearCursor(-/-);
;       save CX;
;       CalcScrollParms(AL,CX,DX/...);
;       TextBufferScroll(1st code buffer's segment:offset/-);
;       if ([ModeStat] == TextEmulation), TextBufferScroll(2nd code buffer's segment:offset/-);
;       restore CX;
;       switch([ModeId])
;               case 0 :                        ;  card, TEXT mode 2/3/7
;                       break;
;               case 2 :                        ; TE mode 7, MGA
;               case 4 :                        ; TE mode 2/3, CGA
;               case 10 :                       ; mode 40/70
;                       MgaGrpScroll(.../-);
;                       break;
;               case 6 :                        ; TE mode 7, EGA/VGA
;               case 8 :                        ; TE mode 2/3, EGA/VGA
;               case 12 :                       ; mode 60/11/12, EGA/VGA
;                       VgaGrpScroll(.../-);
;                       break;
;       }

ScrollUp:
ScrollDown:
        and     [DisplayStat],not Han1st
        and     [DisplayStat],not RunEsc                ; reset ESC sequence
        call    ClearCursor
        mov     cs:[ScrUpDnFlag],1
        cmp     ah,6
        jz      @f
        mov     cs:[ScrUpDnFlag],2
@@:
        cmp     cl,dl
        jb      @f
        xchg    cl,dl
@@:
        cmp     ch,dh
        jb      @f
        xchg    ch,dh
@@:
        cmp     dl,80
        jb      @f
        mov     dl,80-1
@@:
        cmp     dh,[MaxRows]
        jb      @f
        mov     dh,[MaxRows]
        dec     dh
@@:
        mov     bl,dh
        sub     bl,ch
        inc     bl
        cmp     bl,al
        jae     @f
        mov     al,bl
@@:
        or      al,al
        jnz     @f
        mov     al,bl
@@:
        cmp     [ModeId],5*2            ; 5 - mode 40/70
        jnz     NotBlank
        or      bh,bh
        jne     @f
        mov     bh,7                    ; 0 -> 7
        jmp     NotBlank
@@:
        cmp     bh,-1
        jne     NotBlank
        mov     bh,70h                  ; FF -> 70h
NotBlank:
        call    TextEmu
        call    CalcScrollParms
        push    bx
        mov     bx,[rCrtStart]
        les     ax,[CodeBuf1Addr]
        add     ax,bx
        pop     bx
        call    TextBufferScroll                ; 1st code buffer
        test    [ModeStat],TextEmulation
        jz      @f
        les     ax,[CodeBuf2Addr]
        call    TextBufferScroll                ; 2nd code buffer
@@:
        mov     al,[ModeId]
        xor     ah,ah
        mov     si,ax
        call    [si+ScrollUpDownJmpTbl]
ScrollUpDownExit:
ScrUpDownHanCardText:
        ret

ScrollUpDownJmpTbl      Label   Word
        dw      offset  ScrUpDownHanCardText
        dw      offset  MgaGrpScroll
        dw      offset  MgaGrpScroll
        dw      offset  VgaGrpScroll
        dw      offset  VgaGrpScroll
        dw      offset  MgaGrpScroll
        dw      offset  VgaGrpScroll


;========================================================================
;       << CodeChange >>
; FUNCTION = 
; INPUT   : AH = 0F5h
;           input : AL = 00h ;    
;                   BX = 
;           output: AL = 00H=success ,BX =  
;                   AL = FFH=fail
;           input : AL = 01h ;    
;                   BX = 
;           output: AL = 00H=success ,BX =  
;                   AL = FEH     
;                        BX =     
;                        CX =     
;                        DX =     
;                   AL = FFH=fail(  .)
;           input : AL = 02h ;    
;                   BX =   
;                   CX =   
;                   DX =   
;           output: AL = 00H success ,BX =  
;                   AL = FFH fail
; PROTECT : none
fFillCode       =       84h
vFillCode       =       40h
lFillCode       =       01h

CodeChange:
        cmp     al,02h
        ja      CodeChgErr
        xor     ah,ah
        mov     si,ax
        shl     si,1
        mov     ax,bx
        jmp     [si+CodeChangeTbl]

CodeChangeTbl   Label   word
        dw      offset Ks2ChCall
        dw      offset Ch2KsCall
        dw      offset KsComp2ChCall

Ks2ChCall:
        call    ChgKs2Ch
        jc      CodeChgErr
        jmp     CodeChgSuc

Ch2KsCall:
        call    CheckCodeRangeCh
        jc      CodeChgErr
        call    ChgCh2Ks
        jnc     CodeChgSuc
        jmp     SplitCompKS

KsComp2ChCall:
        call    CheckCodeRangeWs
        jc      CodeChgErr
        call    Ks2Ch
        jc      CodeChgErr
        xchg    ax,cx
        call    Ks2Ch
        jc      CodeChgErr
        xchg    ax,dx
        mov     bl,lFillCode
        cmp     ax,0a4d4h
        jz      @f
        cmp     ax,0a4a1h
        jb      CodeChgErr
        cmp     ax,0a4beh
        ja      CodeChgErr
        call    Ks2Chcompn
        jc      CodeChgErr

@@:
        and     ch,11111100b
        and     dh,10000011b
        and     dl,11100000b
        and     bl,00011111b
        xor     bh,bh
        or      bx,dx
        or      bh,ch
        mov     ax,bx
CodeChgSuc:
        mov     [bp+rBX],ax
        xor     al,al
        ret
CodeChgErr:
        mov     al,0ffh
        ret

;------------------
SplitCompKS:
        mov     ax,bx
        mov     d