 remove
    //
    if ((pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass)) == NULL)
        goto bail;

    //
    // disable this node and remember that we have something to clean up
    //
    pCall->pfnSubclass = NULL;

    uCall = (UINT) (pCall - pHeader->CallArray);

    if (!pHeader->uCleanup || (uCall < pHeader->uCleanup))
        pHeader->uCleanup = uCall;

    //
    // now try to clean up any unused nodes
    //
    CompactSubclassHeader(hWnd, pHeader);
#ifdef DEBUG
    // the call above can realloc or free the subclass header for this window
    pHeader = NULL;
#endif

    bResult = TRUE;     // it worked

bail:
    //
    // release the critical section and return the result
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    return bResult;
}

//-----------------------------------------------------------------------------
// DefSubclassProc
//
// this procedure calls the next handler in the window's subclass chain.  the
// last handler in the subclass chain is installed by us, and calls the
// original window procedure for the window.
//
//-----------------------------------------------------------------------------
LRESULT DefSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SUBCLASS_HEADER *pHeader;
    LRESULT lResult = 0L;

    //
    // make sure the window is still valid
    //
    if (!IsWindow(hWnd))
    {
        AssertMsg(FALSE, TEXT("warning: DefSubclassProc - %08X not a window"), hWnd);
        goto BailNonCritical;
    }

    //
    // take the critical section while we figure out who to call next
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
        
    //
    // complain if we are being called improperly
    //
    if ((pHeader = FastGetSubclassHeader(hWnd)) == NULL)
    {
        AssertMsg(FALSE, TEXT("error: DefSubclassProc - window %08X not subclassed"), hWnd);
        goto BailCritical;
    }
    else if (GetCurrentThreadId() != pHeader->dwThreadId)
    {
        AssertMsg(FALSE, TEXT("error: DefSubclassProc - wrong thread for window %08X"), hWnd);
        goto BailCritical;
    }
    else if (!pHeader->pFrameCur)
    {
        AssertMsg(FALSE, TEXT("error: DefSubclassProc - window %08X not in callback"), hWnd);
        goto BailCritical;
    }

    //
    // call the next proc in the subclass chain
    //
    // WARNING: this call temporarily releases the critical section
    // WARNING: pHeader is invalid when this call returns
    //
    lResult = CallNextSubclassProc(pHeader, hWnd, uMsg, wParam, lParam);
#ifdef DEBUG
    pHeader = NULL;
#endif

    //
    // return the result
    //
BailCritical:
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

BailNonCritical:
    return lResult;
}

//-----------------------------------------------------------------------------
// UpdateDeepestCall
//
// this procedure updates the deepest call index for the specified frame
//
//-----------------------------------------------------------------------------
void UpdateDeepestCall(SUBCLASS_FRAME *pFrame)
{
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // we are partying on the frame list
#endif

    if (pFrame->pFramePrev &&
        (pFrame->pFramePrev->uDeepestCall < pFrame->uCallIndex))
    {
        pFrame->uDeepestCall = pFrame->pFramePrev->uDeepestCall;
    }
    else
        pFrame->uDeepestCall = pFrame->uCallIndex;
}

//-----------------------------------------------------------------------------
// EnterSubclassFrame
//
// this procedure sets up a new subclass frame for the specified header, saving
// away the previous one
//
//-----------------------------------------------------------------------------
__inline void EnterSubclassFrame(SUBCLASS_HEADER *pHeader,
    SUBCLASS_FRAME *pFrame)
{
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // we are partying on the header and frame list
#endif

    //
    // fill in the frame and link it into the header
    //
    pFrame->uCallIndex   = pHeader->uRefs;
    pFrame->pFramePrev   = pHeader->pFrameCur;
    pFrame->pHeader      = pHeader;
    pHeader->pFrameCur   = pFrame;

    //
    // initialize the deepest call index for this frame
    //
    UpdateDeepestCall(pFrame);
}

//-----------------------------------------------------------------------------
// LeaveSubclassFrame
//
// this procedure cleans up the current subclass frame for the specified
// header, restoring the previous one
//
//-----------------------------------------------------------------------------
__inline SUBCLASS_HEADER *LeaveSubclassFrame(SUBCLASS_FRAME *pFrame)
{
    SUBCLASS_HEADER *pHeader;

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // we are partying on the header
#endif

    //
    // unlink the frame from its header (if it still exists)
    //
    if ((pHeader = pFrame->pHeader) != NULL)
        pHeader->pFrameCur = pFrame->pFramePrev;

    return pHeader;
}

//-----------------------------------------------------------------------------
// SubclassFrameException
//
// this procedure cleans up when an exception is thrown from a subclass frame
//
//-----------------------------------------------------------------------------
void SubclassFrameException(SUBCLASS_FRAME *pFrame)
{
    //
    // clean up the current subclass frame
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#endif
    DebugMsg(TF_ALWAYS, TEXT("warning: cleaning up subclass frame after exception"));
    LeaveSubclassFrame(pFrame);
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#endif
}

//-----------------------------------------------------------------------------
// MasterSubclassProc
//
// this is the window procedure we install to dispatch subclass callbacks.
// it maintains a linked list of 'frames' through the stack which allow
// DefSubclassProc to call the right subclass procedure in multiple-message
// scenarios.
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK MasterSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam)
{
    SUBCLASS_FRAME Frame;
    SUBCLASS_HEADER *pHeader;
    LRESULT lResult = 0;

    //
    // prevent people from partying on the callback chain while we look at it
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    //
    // we're in big trouble if we got here and we don't have our data
    //
    if ((pHeader = FastGetSubclassHeader(hWnd)) == NULL)
    {
#ifdef FREETHREADEDSUBCLASSGOOP
        LEAVECRITICAL;
#else
        ASSERT(IsWindowOnCurrentThread(hWnd));        
#endif
        return SubclassDeath(hWnd, uMsg, wParam, lParam);
    }

    //
    // set up a new subclass frame and save away the previous one
    //
    EnterSubclassFrame(pHeader, &Frame);

    __try   // protect our state information from exceptions
    {
        //
        // go ahead and call the subclass chain on this frame
        //
        // WARNING: this call temporarily releases the critical section
        // WARNING: pHeader is invalid when this call returns
        //
        lResult =
            CallNextSubclassProc(pHeader, hWnd, uMsg, wParam, lParam);
#ifdef DEBUG
        pHeader = NULL;
#endif
    }
    __except ((SubclassFrameException(&Frame), EXCEPTION_CONTINUE_SEARCH))
    {
        ASSERT(FALSE);
    }
    __endexcept

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    //
    // restore the previous subclass frame
    //
    pHeader = LeaveSubclassFrame(&Frame);

    //
    // if the header is gone we have already cleaned up in a nested frame
    //
    if (!pHeader)
        goto BailOut;

    //
    // was the window nuked (somehow) without us seeing the WM_NCDESTROY?
    //
    if (!IsWindow(hWnd))
    {
        //
        // EVIL! somebody subclassed after us and didn't pass on WM_NCDESTROY
        //
        AssertMsg(FALSE, TEXT("unknown subclass proc swallowed a WM_NCDESTROY"));

        // go ahead and clean up now
        hWnd = NULL;
        uMsg = WM_NCDESTROY;
    }

    //
    // if we are returning from a WM_NCDESTROY then we need to clean up
    //
    if (uMsg == WM_NCDESTROY)
    {
        DetachSubclassHeader(hWnd, pHeader, TRUE);
        goto BailOut;
    }

    //
    // is there any pending cleanup, or are all our clients gone?
    //
    if (pHeader->uCleanup || (!pHeader->pFrameCur && (pHeader->uRefs <= 1)))
    {
        CompactSubclassHeader(hWnd, pHeader);
#ifdef DEBUG
        pHeader = NULL;
#endif
    }

    //
    // all done
    //
BailOut:
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#endif
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTNONCRITICAL;
#endif
    return lResult;
}

//-----------------------------------------------------------------------------
// EnterSubclassCallback
//
// this procedure finds the next callback in the subclass chain and updates
// pFrame to indicate that we are calling it
//
//-----------------------------------------------------------------------------
UINT EnterSubclassCallback(SUBCLASS_HEADER *pHeader, SUBCLASS_FRAME *pFrame,
    SUBCLASS_CALL *pCallChosen)
{
    SUBCLASS_CALL *pCall;
    UINT uDepth;

    //
    // we will be scanning the subclass chain and updating frame data
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;
#endif

    //
    // scan the subclass chain for the next callable subclass callback
    //
    pCall = pHeader->CallArray + pFrame->uCallIndex;
    uDepth = 0;
    do
    {
        uDepth++;
        pCall--;

    } while (!pCall->pfnSubclass);

    //
    // copy the callback information for the caller
    //
    pCallChosen->pfnSubclass = pCall->pfnSubclass;
    pCallChosen->uIdSubclass = pCall->uIdSubclass;
    pCallChosen->dwRefData   = pCall->dwRefData;

    //
    // adjust the frame's call index by the depth we entered
    //
    pFrame->uCallIndex -= uDepth;

    //
    // keep the deepest call index up to date
    //
    UpdateDeepestCall(pFrame);

    return uDepth;
}

//-----------------------------------------------------------------------------
// LeaveSubclassCallback
//
// this procedure finds the next callback in the cal
//
//-----------------------------------------------------------------------------
__inline void LeaveSubclassCallback(SUBCLASS_FRAME *pFrame, UINT uDepth)
{
    //
    // we will be updating subclass frame data
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;
#endif

    //
    // adjust the frame's call index by the depth we entered and return
    //
    pFrame->uCallIndex += uDepth;

    //
    // keep the deepest call index up to date
    //
    UpdateDeepestCall(pFrame);
}

//-----------------------------------------------------------------------------
// SubclassCallbackException
//
// this procedure cleans up when a subclass callback throws an exception
//
//-----------------------------------------------------------------------------
void SubclassCallbackException(SUBCLASS_FRAME *pFrame, UINT uDepth)
{
    //
    // clean up the current subclass callback
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#endif
    DebugMsg(TF_ALWAYS, TEXT("warning: cleaning up subclass callback after exception"));
    LeaveSubclassCallback(pFrame, uDepth);
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#endif
}

//-----------------------------------------------------------------------------
// CallNextSubclassProc
//
// this procedure calls the next subclass callback in the subclass chain
//
// WARNING: this call temporarily releases the critical section
// WARNING: pHeader is invalid when this call returns
//
//-----------------------------------------------------------------------------
LRESULT CallNextSubclassProc(SUBCLASS_HEADER *pHeader, HWND hWnd, UINT uMsg,
    WPARAM wParam, LPARAM lParam)
{
    SUBCLASS_CALL Call;
    SUBCLASS_FRAME *pFrame;
    LRESULT lResult;
    UINT uDepth;

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // sanity
#endif
    ASSERT(pHeader);    // paranoia

    //
    // get the current subclass frame
    //
    pFrame = pHeader->pFrameCur;
    ASSERT(pFrame);

    //
    // get the next subclass call we need to make
    //
    uDepth = EnterSubclassCallback(pHeader, pFrame, &Call);

    //
    // leave the critical section so we don't deadlock in our callback
    //
    // WARNING: pHeader is invalid when this call returns
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#endif
#ifdef DEBUG
    pHeader = NULL;
#endif

    //
    // we call the outside world so prepare to deadlock if we have the critsec
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTNONCRITICAL;
#endif

    __try   // protect our state information from exceptions
    {
        //
        // call the chosen subclass proc
        //
        ASSERT(Call.pfnSubclass);

        lResult = Call.pfnSubclass(hWnd, uMsg, wParam, lParam,
            Call.uIdSubclass, Call.dwRefData);
    }
    __except ((SubclassCallbackException(pFrame, uDepth),
        EXCEPTION_CONTINUE_SEARCH))
    {
        ASSERT(FALSE);
    }
    __endexcept

    //
    // we left the critical section before calling out so re-enter it
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#endif
    
    //
    // finally, clean up and return
    //
    LeaveSubclassCallback(pFrame, uDepth);
    return lResult;
}

///////////////////////////////////////////////////////////////////////////////

#if defined(RETAIL_ZOMBIE_MESSAGE_WNDPROC) || defined(DEBUG)
#ifdef DEBUG
static const TCHAR c_szZombieMessage[] =                                     \
    TEXT("This window has encountered an internal error which is preventing ")    \
    TEXT("it from operating normally.\r\n\nPlease report this problem to ")       \
    TEXT("FrancisH immediately.");
#else
static const TCHAR c_szZombieMessage[] =                                     \
    TEXT("This window has encountered an internal error which is preventing ")    \
    TEXT("it from operating normally.\r\n\nPlease report this as a bug in the ")  \
    TEXT("COMCTL32 library.");
#endif

LRESULT ZombieWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_ERASEBKGND:
        {
            HDC hDC = (HDC)wParam;
            HBRUSH hBrush = CreateSolidBrush(RGB(255,255,0));

            if (hBrush)
            {
                RECT rcErase;

                switch (GetClipBox(hDC, &rcErase))
                {
                default:
                    FillRect(hDC, &rcErase, hBrush);
                    break;
                case NULLREGION:
                case ERROR:
                    break;
                }

                DeleteBrush(hBrush);
            }
        }
        return 1;

    case WM_PAINT:
        {
            RECT rcClient;
            PAINTSTRUCT ps;
            HDC hDC = BeginPaint(hWnd, &ps);

            if (hDC && GetClientRect(hWnd, &rcClient))
            {
                COLORREF clrBkSave = SetBkColor(hDC, RGB(255,255,0));
                COLORREF clrFgSave = SetTextColor(hDC, RGB(255,0,0));

                DrawText(hDC, c_szZombieMessage, -1, &rcClient,
                    DT_LEFT | DT_TOP | DT_NOPREFIX | DT_WORDBREAK |
                    DT_WORD_ELLIPSIS);

                SetTextColor(hDC, clrFgSave);
                SetBkColor(hDC, clrBkSave);
            }

            EndPaint(hWnd, &ps);
        }
        return 0;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}
#endif

///////////////////////////////////////////////////////////////////////////////
//
//  See comments in InitForWinlogon() for an explanation of why this is
//  necessary.
//

// FixupEnumChildWindowProc
//      hwnd = child window
//      lParam = new ATOM for subclass data
//
// If this window has an old subclass record, move it to the new atom

BOOL CALLBACK FixupEnumChildWindowProc(HWND hwnd, LPARAM lParam)
{
    HANDLE hSubclass = RemoveProp(hwnd, MAKEINTATOM(g_aCC32Subclass));
    if (hSubclass)
    {
        SetProp(hwnd, (LPCTSTR)lParam, hSubclass);
    }
    return TRUE;
}

// FixupEnumWindowProc
//      hwnd = top-level window
//      lParam = new ATOM for subclass data
//
// If this window belongs to our process, fix it up and fix up
// all its children, too.

BOOL CALLBACK FixupEnumWindowProc(HWND hwnd, LPARAM lParam)
{
    DWORD dwPid;
    if (GetWindowThreadProcessId(hwnd, &dwPid) &&
        dwPid == GetCurrentProcessId())
    {
        FixupEnumChildWindowProc(hwnd, lParam); // fix up the window itself
        EnumChildWindows(hwnd, FixupEnumChildWindowProc, lParam); // and all its kids
    }
    return TRUE;
}

//
//  FixupEnumDesktopProc
//      lpszDesktop = desktop name
//      lParam = new ATOM for subclass data
//

BOOL CALLBACK FixupEnumDesktopProc(LPTSTR lpszDesktop, LPARAM lParam)
{
    HDESK hdesk = OpenDesktop(lpszDesktop, 0, FALSE,
                              DESKTOP_ENUMERATE | DESKTOP_READOBJECTS |
                              DESKTOP_WRITEOBJECTS);
    if (hdesk)
    {
        HDESK hdeskPrev = GetThreadDesktop(GetCurrentThreadId());
        if (hdeskPrev)
        {
            if (SetThreadDesktop(hdesk))
            {
                EnumWindows(FixupEnumWindowProc, lParam);
                SetThreadDesktop(hdeskPrev);
            }
        }
        CloseDesktop(hdesk);
    }
    return TRUE;
}

STDAPI_(void) FixupSubclassRecordsAfterLogoff()
{
    ATOM a;

    if (!g_aCC32Subclass)
        return;             // No active subclasses; nothing to do

    a = GlobalAddAtom(c_szCC32Subclass);
    if (a == g_aCC32Subclass)
        return;             // We lucked out -- no actual change

    EnumDesktops(GetProcessWindowStation(), FixupEnumDesktopProc, a);
    g_aCC32Subclass = a;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\thunk.h ===
/*************************************************************************\
*
* thunk.h
*
* These are helper functions to make thunking easier.
*
* 18-Aug-1994 JonPa     Created it.
*
\ *************************************************************************/

/*
 * Creates a buffer for a unicode string, and then copies the ANSI text
 * into it (converting it to unicode in the process)
 *
 * The returned pointer should be freed with FreeProducedString after use.
 */
LPWSTR ProduceWFromA( UINT uiCodePage, LPCSTR pszAnsi );

/*
 * Creates a buffer for a ANSI string, and then copies the UNICODE text
 * into it (converting it to ANSI in the process)
 *
 * The returned pointer should be freed with FreeProducedString after use.
 */
LPSTR ProduceAFromW( UINT uiCodePage, LPCWSTR pszW );


/*
 * FreeProducedString
 *
 * Takes a pointer returned from Produce?From?() and frees it.  No
 * validity checking is needed before calling this function.  (ie, any
 * value returned by Produce?From?() can be safely sent to this function)
 */
#define FreeProducedString( psz )   \
    if((psz) != NULL && ((LPSTR)psz) != LPSTR_TEXTCALLBACKA) {LocalFree(psz);} else


/*
 * Converts a UNICODE string to ANSI
 */
#define ConvertWToAN( uiCodePage, pszABuf, cchA, pszW, cchW )         \
    WideCharToMultiByte(uiCodePage, 0, pszW, cchW, pszABuf, cchA, NULL, NULL)

#define ConvertWToA( uiCodePage, pszABuf, pszW )     \
    ConvertWToAN( uiCodePage, pszABuf, INT_MAX, pszW, -1 )

/*
 * Converts an ANSI string to UNICODE
 */
#define ConvertAToWN( uiCodePage, pszWBuf, cchW, pszA, cchA )         \
    MultiByteToWideChar( uiCodePage, MB_PRECOMPOSED, pszA, cchA, pszWBuf, cchW )

#define ConvertAToW( uiCodePage, pszWBuf, pszAnsi )     \
    ConvertAToWN( uiCodePage, pszWBuf, INT_MAX, pszAnsi, -1 )


/*
 * IsFlagPtr
 *  Returns TRUE if the pointer == NULL or -1
 */
#define IsFlagPtr( p )  ((p) == NULL || (LPSTR)(p) == LPSTR_TEXTCALLBACKA)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\toolbar.c ===
/*
** Toolbar.c
**
** This is it, the incredibly famous toolbar control.  Most of
** the customization stuff is in another file.
*/

#include "ctlspriv.h"
#include "toolbar.h"
#include "image.h"
#include <limits.h>

#define __IOleControl_INTERFACE_DEFINED__       // There is a conflich with the IOleControl's def of CONTROLINFO
#include "shlobj.h"

#define TBP_ONRELEASECAPTURE (WM_USER + 0x500)

#define TBIMAGELIST
// these values are defined by the UI gods...
#define DEFAULTBITMAPX 16
#define DEFAULTBITMAPY 15

#define LIST_GAP        (g_cxEdge * 2)
#define DROPDOWN_GAP    (g_cxEdge * 2)
#define CX_TOP_FUDGE    (g_cxEdge * 2)

#define SMALL_DXYBITMAP     16      // new dx dy for sdt images
#define LARGE_DXYBITMAP     24

#define DEFAULTBUTTONX      24
#define DEFAULTBUTTONY      22
// the insert mark is 6 pixels high/wide depending on horizontal or vertical mode...
#define INSERTMARKSIZE      6

const int g_dxButtonSep = 8;
const int s_xFirstButton = 0;   // was 8 in 3.1
#define s_dxOverlap 0           // was 1 in 3.1
#define USE_MIXED_BUTTONS(ptb) (((ptb)->dwStyleEx & TBSTYLE_EX_MIXEDBUTTONS) && ((ptb)->ci.style & TBSTYLE_LIST))
#define BTN_NO_SHOW_TEXT(ptb, ptbb) (!(ptb)->nTextRows || (USE_MIXED_BUTTONS(ptb) && !((ptbb)->fsStyle & BTNS_SHOWTEXT)))
#define BTN_IS_AUTOSIZE(ptb, ptbb) (((ptbb)->fsStyle & BTNS_AUTOSIZE) || (USE_MIXED_BUTTONS(ptb) && !((ptbb)->fsStyle & BTNS_SEP)))
#define DRAW_MONO_BTN(ptb, state)   (!(state & TBSTATE_ENABLED) || ((ptb->ci.style & WS_DISABLED) && ptb->ci.iVersion >= 5))

// Globals - since all of these globals are used durring a paint we have to
// take a criticial section around all toolbar paints.  can we do better?
//

const UINT wStateMasks[] = {
    TBSTATE_ENABLED,
    TBSTATE_CHECKED,
    TBSTATE_PRESSED,
    TBSTATE_HIDDEN,
    TBSTATE_INDETERMINATE,
    TBSTATE_MARKED
};

#define TBISSTRINGPTR(iString)  (((iString) != -1) && (!IS_INTRESOURCE(iString)))

#define TBDraw_State(ptbdraw)   ((ptbdraw)->tbcd.nmcd.uItemState)

LRESULT CALLBACK ToolbarWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
void TBOnButtonStructSize(PTBSTATE ptb, UINT uStructSize);
BOOL SetBitmapSize(PTBSTATE ptb, int width, int height);
int  AddBitmap(PTBSTATE ptb, int nButtons, HINSTANCE hBMInst, UINT_PTR wBMID);
void TBBuildImageList(PTBSTATE ptb);
BOOL GetInsertMarkRect(PTBSTATE ptb, LPRECT lpRect, BOOL fHorizMode);
LPTSTR TB_StrForButton(PTBSTATE ptb, LPTBBUTTONDATA pTBButton);
UINT TBGetDrawTextFlags(PTBSTATE ptb, UINT uiStyle, LPTBBUTTONDATA);
BOOL TBGetMaxSize( PTBSTATE ptb, LPSIZE lpsize );
void TBGetItem(PTBSTATE ptb,LPTBBUTTONDATA ptButton, LPNMTBDISPINFO ptbdi);

#define GT_INSIDE       0x0001
#define GT_MASKONLY     0x0002
BOOL GrowToolbar(PTBSTATE ptb, int newButWidth, int newButHeight, UINT flags);


//Pager Control Functions
LRESULT TB_OnScroll(PTBSTATE ptb, LPNMHDR pnm);
LRESULT TB_OnPagerControlNotify(PTBSTATE ptb,LPNMHDR pnm);
void TBAutoSize(PTBSTATE ptb);
LRESULT TB_OnCalcSize(PTBSTATE ptb, LPNMHDR pnm);

#define TBInvalidateImageList(ptb)  ((ptb)->fHimlValid = FALSE)
#define TBHasStrings(ptb)  ((ptb)->nStrings || (ptb)->fNoStringPool)


__inline BOOL TB_IsDropDown(LPTBBUTTONDATA ptbb)
{
    BOOL fRet = (ptbb->fsStyle & (BTNS_DROPDOWN | BTNS_WHOLEDROPDOWN));

    return fRet;
}

__inline BOOL TB_HasDDArrow(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    BOOL fRet = (((ptb->dwStyleEx & TBSTYLE_EX_DRAWDDARROWS) &&
                        (ptbb->fsStyle & BTNS_DROPDOWN)) ||
                  (ptbb->fsStyle & BTNS_WHOLEDROPDOWN));

    return fRet;
}

__inline BOOL TB_HasSplitDDArrow(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    // If the button is both BTNS_DROPDOWN and BTNS_WHOLEDROPDOWN,
    // BTNS_WHOLEDROPDOWN wins.

    BOOL fRet = ((ptb->dwStyleEx & TBSTYLE_EX_DRAWDDARROWS) &&
                (ptbb->fsStyle & BTNS_DROPDOWN) &&
                !(ptbb->fsStyle & BTNS_WHOLEDROPDOWN));

    return fRet;
}

__inline BOOL TB_HasUnsplitDDArrow(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    BOOL fRet = (ptbb->fsStyle & BTNS_WHOLEDROPDOWN);

    return fRet;
}

__inline BOOL TB_HasTopDDArrow(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    BOOL fRet = (!(ptb->ci.style & TBSTYLE_LIST) &&
                TB_HasUnsplitDDArrow(ptb, ptbb) &&
                (ptb->nTextRows > 0) && TB_StrForButton(ptb, ptbb));

    return fRet;
}


BOOL TBIsHotTrack(PTBSTATE ptb, LPTBBUTTONDATA ptButton, UINT state)
{
    BOOL fHotTrack = FALSE;

    if ((ptb->ci.style & TBSTYLE_FLAT) && (&ptb->Buttons[ptb->iHot]==ptButton))
        fHotTrack = TRUE;

    // The following is in place to prevent hot tracking during the following conds:
    //  - drag & drop toolbar customization
    //  - when the mouse capture is on a particular button-press.
    // This does _not_ drop out of the loop because we don't want to break update
    // behavior; thus we'll have a little flickering on refresh as we pass over
    // these buttons.
    if (!(state & TBSTATE_PRESSED) && (GetKeyState (VK_LBUTTON) < 0) &&
        GetCapture() == ptb->ci.hwnd)
    {
        fHotTrack = FALSE;
    }

    if (!fHotTrack && (ptb->iPressedDD == ptButton - ptb->Buttons))
        fHotTrack = TRUE;

    return fHotTrack;
}


UINT StateFromCDIS(UINT uItemState)
{
    UINT state = 0;

    if (uItemState & CDIS_CHECKED)
        state |= TBSTATE_CHECKED;

    if (uItemState & CDIS_SELECTED)
        state |= TBSTATE_PRESSED;

    if (!(uItemState & CDIS_DISABLED))
        state |= TBSTATE_ENABLED;

    if (uItemState & CDIS_MARKED)
        state |= TBSTATE_MARKED;

    if (uItemState & CDIS_INDETERMINATE)
        state |= TBSTATE_INDETERMINATE;

    return state;
}


UINT CDISFromState(UINT state)
{
    UINT uItemState = 0;

    // Here are the TBSTATE - to - CDIS mappings:
    //
    //  TBSTATE_CHECKED         = CDIS_CHECKED
    //  TBSTATE_PRESSED         = CDIS_SELECTED
    // !TBSTATE_ENABLED         = CDIS_DISABLED
    //  TBSTATE_MARKED          = CDIS_MARKED
    //  TBSTATE_INDETERMINATE   = CDIS_INDETERMINATE
    //
    //  Hot tracked item        = CDIS_HOT
    //

    if (state & TBSTATE_CHECKED)
        uItemState |= CDIS_CHECKED;

    if (state & TBSTATE_PRESSED)
        uItemState |= CDIS_SELECTED;

    if (!(state & TBSTATE_ENABLED))
        uItemState |= CDIS_DISABLED;

    if (state & TBSTATE_MARKED)
        uItemState |= CDIS_MARKED;

    if (state & TBSTATE_INDETERMINATE)
        uItemState |= CDIS_INDETERMINATE;

    return uItemState;
}

void FlushToolTipsMgrNow(PTBSTATE ptb);

void TB_ForceCreateTooltips(PTBSTATE ptb)
{
    if (ptb->ci.style & TBSTYLE_TOOLTIPS && !ptb->hwndToolTips)
    {
        TOOLINFO ti;
        // don't bother setting the rect because we'll do it below
        // in TBInvalidateItemRects;
        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_IDISHWND;
        ti.hwnd = ptb->ci.hwnd;
        ti.uId = (UINT_PTR)ptb->ci.hwnd;
        ti.lpszText = 0;

        ptb->hwndToolTips = CreateWindow(c_szSToolTipsClass, NULL,
                                         WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                         ptb->ci.hwnd, NULL, HINST_THISDLL, NULL);
        if (ptb->hwndToolTips) {
            int i;
            NMTOOLTIPSCREATED nm;

            CCSetInfoTipWidth(ptb->ci.hwnd, ptb->hwndToolTips);

            SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                        (LPARAM)(LPTOOLINFO)&ti);

            nm.hwndToolTips = ptb->hwndToolTips;
            CCSendNotify(&ptb->ci, NM_TOOLTIPSCREATED, &nm.hdr);

            // don't bother setting the rect because we'll do it below
            // in TBInvalidateItemRects;
            ti.uFlags = 0;
            ti.lpszText = LPSTR_TEXTCALLBACK;

            for (i = 0; i < ptb->iNumButtons; i++) {
                if (!(ptb->Buttons[i].fsStyle & BTNS_SEP)) {
                    ti.uId = ptb->Buttons[i].idCommand;
                    SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                                (LPARAM)(LPTOOLINFO)&ti);
                }
            }

            FlushToolTipsMgrNow(ptb);
        }
    }
}

void TBRelayToToolTips(PTBSTATE ptb, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    TB_ForceCreateTooltips(ptb);
    if (ptb->hwndToolTips) {
        RelayToToolTips(ptb->hwndToolTips, ptb->ci.hwnd, wMsg, wParam, lParam);
    }
}


LRESULT ToolbarDragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp)
{
    PTBSTATE ptb = (PTBSTATE)GetWindowInt(hwnd, 0);
    LRESULT lres;

    switch (code)
    {
    case DPX_DRAGHIT:
        if (lp)
        {
            POINT pt;
            int item;
            pt.x = ((POINTL *)lp)->x;
            pt.y = ((POINTL *)lp)->y;
            MapWindowPoints(NULL, ptb->ci.hwnd, &pt, 1);
            item = TBHitTest(ptb, pt.x, pt.y);

            if (0 <= item && item < ptb->iNumButtons)
                lres = (LRESULT)ptb->Buttons[item].idCommand;
            else
                lres = (LRESULT)-1;
        }
        else
            lres = -1;
        break;

    case DPX_GETOBJECT:
        lres = (LRESULT)GetItemObject(&ptb->ci, TBN_GETOBJECT, &IID_IDropTarget, (LPNMOBJECTNOTIFY)lp);
        break;

    case DPX_SELECT:
        if ((int)wp >= 0)
        {
            NMTBHOTITEM nmhi;
            nmhi.idNew = (int) wp;
            if (!CCSendNotify(&ptb->ci, TBN_DRAGOVER, &nmhi.hdr))
            {
                SendMessage(ptb->ci.hwnd, TB_MARKBUTTON, wp,
                    MAKELPARAM((lp != DROPEFFECT_NONE), 0));
            }
        }
        lres = 0;
        break;

    default:
        lres = -1;
        break;
    }

    return lres;
}

int TBMixedButtonHeight(PTBSTATE ptb, int iIndex)
{
    int iHeight;
    LPTBBUTTONDATA ptbb = &(ptb->Buttons[iIndex]);

    if (ptbb->fsStyle & BTNS_SHOWTEXT)                      // text and icon
        iHeight = max(ptb->iDyBitmap, ptb->dyIconFont);
    else                                                    // icon, no text
        iHeight = ptb->iDyBitmap;

    return iHeight;
}

int TBMixedButtonsHeight(PTBSTATE ptb)
{
    int i;
    int iHeightMax = 0;
    int iHeight;
    ASSERT(ptb->ci.style & TBSTYLE_LIST);
    ASSERT(USE_MIXED_BUTTONS(ptb));
    for (i = 0; i < ptb->iNumButtons; i++) {
        iHeight = TBMixedButtonHeight(ptb, i);
        iHeightMax = max(iHeightMax, iHeight);
    }
    return iHeightMax;
}

int HeightWithString(PTBSTATE ptb, int h)
{
    if (USE_MIXED_BUTTONS(ptb))
    {
        int hMixed = TBMixedButtonsHeight(ptb);
        return (max(h, hMixed));
    }
    else if (ptb->ci.style & TBSTYLE_LIST)
        return (max(h, ptb->dyIconFont));
    else if (ptb->dyIconFont)
        return (h + ptb->dyIconFont + 1);
    else
        return (h);
}

int TBGetSepHeight(PTBSTATE ptb, LPTBBUTTONDATA pbtn)
{
    ASSERT(pbtn->fsStyle & BTNS_SEP);

    if (ptb->ci.style & (CCS_VERT | TBSTYLE_FLAT) )
        return pbtn->DUMMYUNION_MEMBER(cxySep);
    else
        return pbtn->DUMMYUNION_MEMBER(cxySep) * 2 / 3;
}

UINT TBWidthOfString(PTBSTATE ptb, LPTBBUTTONDATA ptbb, HDC hdc)
{
    UINT uiWidth = 0;

    LPTSTR pstr = TB_StrForButton(ptb, ptbb);
    if (pstr)
    {
        HDC hdcCreated = NULL;
        HFONT hOldFont;
        UINT uiStyle;
        RECT rcText = {0,0,1000,10};

        if (!hdc)
        {
            hdcCreated = GetDC(ptb->ci.hwnd);
            hdc = hdcCreated;
        }
        hOldFont = SelectObject(hdc, ptb->hfontIcon);

        uiStyle = DT_CALCRECT | TBGetDrawTextFlags(ptb, 0, ptbb);
        DrawText(hdc, pstr, -1, &rcText, uiStyle);

        uiWidth += rcText.right;

        SelectObject(hdc, hOldFont);
        if (hdcCreated)
            ReleaseDC(ptb->ci.hwnd, hdcCreated);
    }

    return uiWidth;
}

// TBDDArrowAdjustment(ptb, ptbb): the amount by which we change the width of
// this button to accomodate the drop-down arrow.  not necessarily the same as
// ptb->dxDDArrowChar.
int TBDDArrowAdjustment(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    int iAdjust = 0;

    if (TB_HasDDArrow(ptb, ptbb))
    {
        // If a whole dd, non-autosize button, then we'll just use the standard
        // button width which ought to have room for this button (i.e., return 0).

        if (!TB_HasTopDDArrow(ptb, ptbb) || BTN_IS_AUTOSIZE(ptb, ptbb))
        {
            iAdjust += (WORD)ptb->dxDDArrowChar;

            if (TB_HasUnsplitDDArrow(ptb, ptbb))
            {
                // subtract off a bit since there won't be a border
                // around dd arrow part of this button
                iAdjust -= 2 * g_cxEdge;

                if (ptbb->iBitmap != I_IMAGENONE)
                {
                    // nudge over a bit more to overlap bitmap border padding
                    iAdjust -= g_cxEdge;
                }
            }

            if (TB_HasTopDDArrow(ptb, ptbb))
            {
                // If string width >= icon width + iAdjust, then no need
                // to add extra space for the arrow.

                if ((int)TBWidthOfString(ptb, ptbb, NULL) >= ptb->iDxBitmap + iAdjust)
                    iAdjust = 0;
            }
        }
    }

    return max(iAdjust, 0);
}

int TBWidthOfButton(PTBSTATE ptb, LPTBBUTTONDATA pButton, HDC hdc)
{
    RECT rc;
    if (BTN_IS_AUTOSIZE(ptb, pButton)) {
        // if they've set this button for autosize, calculate it and cache
        // it in cx
        if (BTN_NO_SHOW_TEXT(ptb, pButton)) {
            pButton->cx = 0;
            goto CalcIconWidth;
        }

        if (pButton->cx == 0) {
            UINT uiStringWidth = TBWidthOfString(ptb, pButton, hdc);
            pButton->cx = (WORD) ptb->xPad + uiStringWidth;

            if (uiStringWidth) {
                // Since we have a string for this button, we need to add
                // some padding around it.
                if ((ptb->ci.style & TBSTYLE_LIST) && TB_HasSplitDDArrow(ptb, pButton))
                    pButton->cx += (WORD) ptb->iDropDownGap;
                else
                    pButton->cx += 2 * g_cxEdge;
            }

CalcIconWidth:
            if (pButton->iBitmap != I_IMAGENONE) {

                if (ptb->ci.style & TBSTYLE_LIST) {
                    pButton->cx += ptb->iDxBitmap + ptb->iListGap;
                    if (BTN_NO_SHOW_TEXT(ptb, pButton))
                        pButton->cx += g_cxEdge * 2;
                }
                else {
                    // Use wider of string width (pButton->cx so far) and bitmap width.
                    pButton->cx = max(pButton->cx, ptb->iDxBitmap + ptb->xPad);
                }
            }

            pButton->cx += (USHORT)TBDDArrowAdjustment(ptb, pButton);
        }
    }

    if (pButton->cx) {
        return (int)pButton->cx;
    } else if (pButton->fsStyle & BTNS_SEP) {
        if (ptb->ci.style & CCS_VERT) {
            GetWindowRect(ptb->ci.hwnd, &rc);
            return RECTWIDTH(rc);
        } else {
            // Compat: Corel (Font navigator) expects the separators to be
            // 8 pixels wide.  So do not return pButton->cxySep here, since
            // that can be calculated differently depending on the flat style.
            //
            // No.  owner draw items are added by specifying separator, and
            // the iBitmap width which is then copied down to cxySep.
            // the preserving of size for corel needs to be done at that point.
            return pButton->DUMMYUNION_MEMBER(cxySep);
        }
    } else if (!(TBSTYLE_EX_VERTICAL & ptb->dwStyleEx)) {
        return ptb->iButWidth + TBDDArrowAdjustment(ptb, pButton);
    } else {
        return ptb->iButWidth;
    }
}

UINT TBGetDrawTextFlags(PTBSTATE ptb, UINT uiStyle, TBBUTTONDATA* ptbb)
{
    if (ptb->nTextRows > 1)
        uiStyle |= DT_WORDBREAK | DT_EDITCONTROL;
    else
        uiStyle |= DT_SINGLELINE;


    if (ptb->ci.style & TBSTYLE_LIST)
    {
        uiStyle |= DT_LEFT | DT_VCENTER | DT_SINGLELINE;
    }
    else
    {
        uiStyle |= DT_CENTER;
    }

    uiStyle &= ~(ptb->uDrawTextMask);
    uiStyle |= ptb->uDrawText;
    if (ptbb->fsStyle & BTNS_NOPREFIX)
        uiStyle |= DT_NOPREFIX;

    if (CCGetUIState(&(ptb->ci)) & UISF_HIDEACCEL)
    {
        uiStyle |= DT_HIDEPREFIX;
    }
    return uiStyle;
}

BOOL TBRecalc(PTBSTATE ptb)
{
    TEXTMETRIC tm = {0};
    int i;
    HDC hdc;
    int cxMax = 0, cxMask, cy;
    HFONT hOldFont=NULL;

    if (ptb->fRedrawOff) {
        // redraw is off; defer recalc until redraw is turned back on
        ptb->fRecalc = TRUE;
        return TRUE;    // The recalc "succeeded" - actual work will happen later
    }

    ptb->dyIconFont = 0;
    if (!TBHasStrings(ptb) || !ptb->nTextRows ) {

        cxMax = ptb->iDxBitmap;
        cxMask = cxMax;

    } else {

        SIZE size = {0};
        LPCTSTR pstr;
        RECT rcText = {0,0,0,0};
        int cxExtra = ptb->xPad;

        ptb->iButWidth = 0;

        hdc = GetDC(ptb->ci.hwnd);
        if (!hdc)
            return(FALSE);

        if (ptb->hfontIcon)
            hOldFont = SelectObject(hdc, ptb->hfontIcon);
        GetTextMetrics(hdc, &tm);
        if (ptb->nTextRows)
            ptb->dyIconFont = (tm.tmHeight * ptb->nTextRows) +
                (tm.tmExternalLeading * (ptb->nTextRows - 1)); // add an edge ?

        if (ptb->ci.style & TBSTYLE_LIST)
            cxExtra += ptb->iDxBitmap + ptb->iListGap;

        // default to the image size...
        cxMax = ptb->iDxBitmap;

        // walk strings to find max width
        for (i = 0; i < ptb->iNumButtons; i++)
        {
            if (ptb->Buttons[i].fsState & TBSTATE_HIDDEN)
                continue;

            if (BTN_IS_AUTOSIZE(ptb, &ptb->Buttons[i]))
                ptb->Buttons[i].cx = 0;

            pstr = TB_StrForButton(ptb, &ptb->Buttons[i]);
            if (pstr) 
            {
                if ( ptb->ci.iVersion < 5 )
                {
                    // we used to use GetTextExtentPoint instead of DrawText.  This function would include the width
                    // of the "&" character if it was present.  As a result, it returned larger values and thus created
                    // wider buttons.  Without this extra fudge certain buttons will be about 6 pixels too narrow.
                    GetTextExtentPoint(hdc, pstr, lstrlen(pstr), &size);
                }
                else
                {
                    // wordbreak is not allowed in the calcrect w/ singleline
                    UINT uiStyle = DT_CALCRECT | DT_SINGLELINE | (TBGetDrawTextFlags(ptb, 0, &ptb->Buttons[i]) & ~DT_WORDBREAK);
                    RECT rcTemp = {0,0,0,0};
                    rcTemp.bottom = ptb->dyIconFont;

                    DrawText(hdc, pstr, -1, &rcTemp, uiStyle);
                    size.cx = RECTWIDTH(rcTemp);
                    size.cy = RECTHEIGHT(rcTemp);
                    // BUGBUG: size.cy stuff is fishy -- last one wins
                }
            }
            else
            {
                size.cx = 0;
            }

            if (TB_HasTopDDArrow(ptb, &ptb->Buttons[i])) {
                int iBmpWithArrow = CX_TOP_FUDGE + ptb->iDxBitmap + ptb->dxDDArrowChar;
                size.cx = max(size.cx, iBmpWithArrow);
            }
            else if ((ptb->dwStyleEx & TBSTYLE_EX_VERTICAL) && 
                TB_HasDDArrow(ptb, &ptb->Buttons[i])) {

                // for vertical toolbars, buttons with drop-down arrows
                // are drawn with the same width as normal buttons, so
                // we need to figure them into our max width calculation.

                size.cx += ptb->dxDDArrowChar;
            }

            if (cxMax < size.cx)
                cxMax = size.cx;
        }

        // if cxMax is less than the iButMinWidth - dxBitmap (if LIST) then
        // cxMax = iButMinWidth
        if (ptb->iButMinWidth && (ptb->iButMinWidth > (cxMax + cxExtra)))
            cxMax = ptb->iButMinWidth - cxExtra;

        cxMask = cxMax;

        // Is the cxMax +  dxBitmap (if LIST) more than the max width ?
        if (ptb->iButMaxWidth && (ptb->iButMaxWidth < (cxMax + cxExtra)))
        {
            int cyMax = 0;
            int cxTemp = 0;

            cxMax = ptb->iButMaxWidth - cxExtra;

            // But leave cxMask at its old value since AUTOSIZE buttons
            // are exempt from button truncation.  This exemption is a bug,
            // but IE4 shipped that way so we're stuck with it.  (You can
            // tell it's a bug because we go ahead and flip TBSTATE_ELLIPSIS
            // even on AUTOSIZE buttons, only to "forget" about the ellipsis
            // in TBWidthOfString().)

            // walk strings to set the TBSTATE_ELLIPSES
            for (i = 0; i < ptb->iNumButtons; i++)
            {
                BOOL fEllipsed = FALSE;
                UINT uiStyle;

                if (ptb->Buttons[i].fsState & TBSTATE_HIDDEN)
                    continue;

                if (BTN_NO_SHOW_TEXT(ptb, &ptb->Buttons[i]))
                    pstr = NULL;
                else
                {
                    pstr = TB_StrForButton(ptb, &ptb->Buttons[i]);
                    uiStyle = DT_CALCRECT | TBGetDrawTextFlags(ptb, 0, &ptb->Buttons[i]);
                }

                if (pstr) 
                {
                    int cxMaxText;
                    if ((ptb->dwStyleEx & TBSTYLE_EX_VERTICAL) && 
                        TB_HasDDArrow(ptb, &ptb->Buttons[i]))
                    {
                        // if a drop-down button on a vertical toolbar,
                        // need to make space for drop-down arrow
                        cxMaxText = cxMax - ptb->dxDDArrowChar;
                    } 
                    else 
                    {
                        cxMaxText = cxMax;
                    }
                    // DrawText doesn't like it when cxMaxText <= 0
                    cxMaxText = max(cxMaxText, 1);

                    rcText.bottom = ptb->dyIconFont;
                    rcText.right = cxMaxText;

                    DrawText(hdc, pstr, -1, &rcText, uiStyle);
                    if (ptb->nTextRows > 1)
                    {
                        // width is width of text plus width we might
                        // have lopped off for drop-down arrow
                        int cx = rcText.right + (cxMax - cxMaxText);
                        if (cx > cxTemp)
                        {
                            // this is our new multiline text hack max
                            cxTemp = cx;
                        }
                        fEllipsed = (BOOL)(rcText.bottom > ptb->dyIconFont);
                    }
                    else
                        fEllipsed = (BOOL)(rcText.right > cxMaxText);

                    if (cyMax < rcText.bottom)
                        cyMax = rcText.bottom;
                }

                if (fEllipsed)
                    ptb->Buttons[i].fsState |= TBSTATE_ELLIPSES;
                else
                    ptb->Buttons[i].fsState &= ~TBSTATE_ELLIPSES;
            }

            if (cxTemp && (ptb->nTextRows > 1 ))
                cxMax = cxTemp;

            // Set the text height to the tallest text, with the top end being the number
            // of rows specified by MAXTEXTROWS
            if (ptb->dyIconFont > cyMax)
                ptb->dyIconFont = cyMax;
        }
        else
        {
            for (i = 0; i < ptb->iNumButtons; i++)
                ptb->Buttons[i].fsState &= ~TBSTATE_ELLIPSES;

            if ((ptb->nTextRows) && ptb->iNumButtons && (ptb->dyIconFont > size.cy))
                ptb->dyIconFont = size.cy;
        }

        if (ptb->iButMinWidth && (ptb->iButMinWidth > (cxMax + cxExtra)))
            cxMax = ptb->iButMinWidth - cxExtra;

        if (hOldFont)
            SelectObject(hdc, hOldFont);
        ReleaseDC(ptb->ci.hwnd, hdc);
    }

    //
    //  Need to call GrowToolbar twice, once to grow the mask, and again
    //  to grow the buttons.  (Yes, this is sick.)
    //
    cy = HeightWithString(ptb, ptb->iDyBitmap);

    if (!GrowToolbar(ptb, max(cxMax, cxMask), cy, GT_INSIDE | GT_MASKONLY))
        return(FALSE);

    return(GrowToolbar(ptb, cxMax, cy, GT_INSIDE));
}

BOOL TBChangeFont(PTBSTATE ptb, WPARAM wParam, HFONT hFont)
{
    LOGFONT lf;
    BOOL fWasFontCreated = ptb->fFontCreated;

    if ((wParam != 0) && (wParam != SPI_SETICONTITLELOGFONT) && (wParam != SPI_SETNONCLIENTMETRICS))
        return(FALSE);

    if (!SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
        return(FALSE);

    if (!hFont) {
        if (!(hFont = CreateFontIndirect(&lf)))
            return(FALSE);
        ptb->fFontCreated = TRUE;
    } else {
        ptb->fFontCreated = FALSE;
    }

    if (ptb->hfontIcon && fWasFontCreated)
        DeleteObject(ptb->hfontIcon);

    ptb->hfontIcon = hFont;

    return(TBRecalc(ptb));
}

void TBSetFont(PTBSTATE ptb, HFONT hFont, BOOL fInval)
{
    TBChangeFont(ptb, 0, hFont);
    if (fInval)
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

}

HWND WINAPI CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps,
            HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons,
            int iNumButtons, int dxButton, int dyButton,
            int dxBitmap, int dyBitmap, UINT uStructSize)
{
    HWND hwndToolbar = CreateWindow(c_szToolbarClass, NULL, WS_CHILD | ws,
          0, 0, 100, 30, hwnd, IntToPtr_(HMENU, wID), HINST_THISDLL, NULL);
    if (hwndToolbar)
    {
        TBADDBITMAP tbab;

        // Need to send messages, instead of call our internal functions, because we may have created
        // a v6 window above.
        SendMessage(hwndToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM)uStructSize, (LPARAM)0);

        if ((dxBitmap && dyBitmap &&
            !SendMessage(hwndToolbar, TB_SETBITMAPSIZE, (WPARAM)0, MAKELPARAM(dxBitmap, dyBitmap))) ||
            (dxButton && dyButton &&
            !SendMessage(hwndToolbar, TB_SETBITMAPSIZE, (WPARAM)0, MAKELPARAM(dxButton, dyButton))))
        {
            //!!!! do we actually need to deal with this?
            DestroyWindow(hwndToolbar);
            hwndToolbar = NULL;
            goto Error;
        }
        
        tbab.hInst = hBMInst;
        tbab.nID = wBMID;
        SendMessage(hwndToolbar, TB_ADDBITMAP, (WPARAM)nBitmaps, (LPARAM)&tbab);

        SendMessage(hwndToolbar, TB_ADDBUTTONS, (WPARAM)iNumButtons, (LPARAM)lpButtons);
    }
Error:
    return hwndToolbar;
}

/* This is no longer declared in COMMCTRL.H.  It only exists for compatibility
** with existing apps; new apps must use CreateToolbarEx.
*/
HWND WINAPI CreateToolbar(HWND hwnd, DWORD ws, UINT wID, int nBitmaps, HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons, int iNumButtons)
{
    // old-style toolbar, so no divider.
    return CreateToolbarEx(hwnd, ws | CCS_NODIVIDER, wID, nBitmaps, hBMInst, wBMID,
                lpButtons, iNumButtons, 0, 0, 0, 0, sizeof(OLDTBBUTTON));
}

#pragma code_seg(CODESEG_INIT)

BOOL InitToolbarClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = ToolbarWndProc;

    wc.lpszClassName = c_szToolbarClass;
    wc.style     = CS_DBLCLKS | CS_GLOBALCLASS;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PTBSTATE);
    wc.hInstance     = hInstance;   // use DLL instance if in DLL
    wc.hIcon     = NULL;
    wc.hCursor   = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    wc.lpszMenuName  = NULL;

    RegisterClass(&wc);

    return TRUE;
}
#pragma code_seg()

void PatB(HDC hdc,int x,int y,int dx,int dy, DWORD rgb)
{
    RECT    rc;

    SetBkColor(hdc,rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

// Parameter fHighlight determines whether to draw text highlighted, for
// new TBSTATE_MARKED
//
void DrawString(HDC hdc, int x, int y, int dx, int dy, PTSTR pszString,
                            BOOL fHighlight, TBDRAWITEM * ptbdraw)
{
    int oldMode;
    COLORREF oldBkColor;
    COLORREF oldTextColor;
    RECT rcText;
    UINT uiStyle = 0;
    PTBSTATE ptb;
    LPTBBUTTONDATA ptbb;

    ASSERT(ptbdraw);

    ptb = ptbdraw->ptb;
    ptbb = ptbdraw->pbutton;

    if (!(ptb->ci.style & TBSTYLE_LIST) && ((ptb->iDyBitmap + ptb->yPad + g_cyEdge) >= ptb->iButHeight))
        // there's no room to show the text -- bail out
        return;

    if (BTN_NO_SHOW_TEXT(ptb, ptbb))
        // don't show text for this button -- bail out
        return;

    if (fHighlight)
    {
        oldMode = SetBkMode (hdc, ptbdraw->tbcd.nHLStringBkMode);
        oldBkColor = SetBkColor (hdc, ptbdraw->tbcd.clrMark);
        oldTextColor = SetTextColor (hdc, ptbdraw->tbcd.clrTextHighlight);
    }
    else
        oldMode = SetBkMode(hdc, ptbdraw->tbcd.nStringBkMode);

    uiStyle = TBGetDrawTextFlags(ptb, DT_END_ELLIPSIS, ptbb);

    // If we're ex_vertical want to center the text
    if (!(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL))
    {
        if (ptb->ci.style & TBSTYLE_LIST)
        {
            dy = max(ptb->dyIconFont, ptb->iDyBitmap);
        }
        else
        {
            if (!dy || ptb->dyIconFont < dy)
                dy = ptb->dyIconFont;
        }
    }


    SetRect( &rcText, x, y, x + dx, y + dy);

    DrawText(hdc, (LPTSTR)pszString, -1, &rcText, uiStyle);

    SetBkMode(hdc, oldMode);
    if (fHighlight)
    {
        SetBkColor (hdc, oldBkColor);
        SetTextColor (hdc, oldTextColor);
    }
}

LPTSTR TB_StrForButton(PTBSTATE ptb, LPTBBUTTONDATA pTBButton)
{
    if (TBISSTRINGPTR(pTBButton->iString))
        return (LPTSTR)pTBButton->iString;
    else {
        if (pTBButton->iString != -1 &&
            pTBButton->iString < ptb->nStrings)
            return ptb->pStrings[pTBButton->iString];
        return NULL;
    }
}

HIMAGELIST TBGetImageList(PTBSTATE ptb, int iMode, int iIndex)
{
    HIMAGELIST himl = NULL;

    ASSERT(iMode <= HIML_MAX);
    if (iIndex >= 0 && iIndex < ptb->cPimgs) {
        himl = ptb->pimgs[iIndex].himl[iMode];
    }

    return himl;
}

//
//  v5 toolbars support multiple imagelists.  To use images from an alternate
//  imagelist, set the imagelist handle via TB_SETIMAGELIST(iIndex, himlAlt)
//  and set your button's iImage to MAKELONG(iImage, iIndex).
//
//  APP COMPAT:  GroupWise 5.5 passes garbage as the iIndex (even though it
//  was documented as "must be zero"), so we enable this functionality
//  only for v5 toolbars.  IE4 ignored the iIndex, which is why they got
//  away with it up until now.
//
#define MAX_TBIMAGELISTS 20             // arbitrary limit

HIMAGELIST TBSetImageList(PTBSTATE ptb, int iMode, int iIndex, HIMAGELIST himl)
{
    HIMAGELIST himlOld = NULL;

    // Watch out for app compat or for totally bogus parameters
    if (ptb->ci.iVersion < 5 || iIndex < 0 || iIndex >= MAX_TBIMAGELISTS)
        iIndex = 0;

    ASSERT(iMode <= HIML_MAX);
    if (iIndex >= ptb->cPimgs)
    {
        // asking for more than we have, realloc.

        void *p = CCLocalReAlloc(ptb->pimgs, (iIndex+1) * SIZEOF(TBIMAGELISTS));
        if (p)
        {
            ptb->pimgs = (TBIMAGELISTS*)p;
            ZeroMemory(&ptb->pimgs[ptb->cPimgs], (iIndex + 1 - ptb->cPimgs)*SIZEOF(TBIMAGELISTS));
            ptb->cPimgs = iIndex + 1;  // iIndex is 0 based, but cPimgs is 1 based (it's a count, not an index)
        }
    }

    if (iIndex < ptb->cPimgs)
    {
        himlOld = ptb->pimgs[iIndex].himl[iMode];
        ptb->pimgs[iIndex].himl[iMode] = himl;
    }

    return himlOld;
}

// create a mono bitmap mask:
//   1's where color == COLOR_BTNFACE || COLOR_3DHILIGHT
//   0's everywhere else

void CreateMask(int xoffset, int yoffset, int dx, int dy, BOOL fDrawGlyph, TBDRAWITEM * ptbdraw)
{
    LPTSTR psz;
    HIMAGELIST himl;
    PTBSTATE ptb = ptbdraw->ptb;
    LPTBBUTTONDATA pTBButton = ptbdraw->pbutton;
    // initalize whole area with 1's
    PatBlt(ptb->hdcMono, 0, 0, dx, dy, WHITENESS);

    // create mask based on color bitmap
    // convert this to 1's

    himl = TBGetImageList(ptb, HIML_NORMAL, ptbdraw->iIndex);
    if (fDrawGlyph && himl)
    {
        IMAGELISTDRAWPARAMS imldp = {0};
        imldp.cbSize = sizeof(imldp);
        imldp.himl   = himl;
        imldp.i      = ptbdraw->iImage;
        imldp.hdcDst = ptb->hdcMono;
        imldp.x      = xoffset;
        imldp.y      = yoffset;
        imldp.cx     = 0;
        imldp.cy     = 0;
        imldp.xBitmap= 0;
        imldp.yBitmap= 0;
        imldp.rgbBk  = g_clrBtnFace;
        imldp.rgbFg  = CLR_DEFAULT;
        imldp.fStyle = ILD_ROP | ILD_MASK;
        imldp.dwRop  = SRCCOPY;

        ImageList_DrawIndirect(&imldp);

        imldp.fStyle = ILD_ROP | ILD_IMAGE;
        imldp.rgbBk  = g_clrBtnHighlight;
        imldp.dwRop  = SRCPAINT;
        ImageList_DrawIndirect(&imldp);
    }

    psz = TB_StrForButton(ptb, pTBButton);
    if (psz)
    {
        xoffset = 1;
        yoffset = 1;

        if (ptb->ci.style & TBSTYLE_LIST)
        {
            if (!(pTBButton->iBitmap == I_IMAGENONE &&
                (pTBButton->fsStyle & BTNS_AUTOSIZE)))
            {
                xoffset += ptb->iDxBitmap + ptb->iListGap;
                dx -= ptb->iDxBitmap + ptb->iListGap;
            }
        }
        else 
        {
            yoffset += ptb->iDyBitmap + 1;
            dy -= ptb->iDyBitmap + 1;
        }

        if (!(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL))
        {
            dx -= g_cxEdge;
            dy -= g_cyEdge;
        }

        // The FALSE in 4th param is so we don't get a box in the mask.
        DrawString(ptb->hdcMono, xoffset, yoffset, dx, dy, psz,
                   FALSE, ptbdraw);
    }
}

void DrawBlankButton(HDC hdc, int x, int y, int dx, int dy, TBDRAWITEM * ptbdraw)
{
    RECT r1;
    UINT state;

    // face color
    // The Office toolbar sends us bitmaps that are smaller than they claim they are
    // So we need to do the PatB or the window background shows through around the
    // edges of the button bitmap  -jjk
    ASSERT(ptbdraw);

    state = ptbdraw->state;

    if (!(state & TBSTATE_CHECKED))
        PatB(hdc, x, y, dx, dy, ptbdraw->tbcd.clrBtnFace);

    if  ( !(ptbdraw->dwCustom & TBCDRF_NOEDGES))
    {
        r1.left = x;
        r1.top = y;
        r1.right = x + dx;
        r1.bottom = y + dy;

        DrawEdge(hdc, &r1, (state & (TBSTATE_CHECKED | TBSTATE_PRESSED)) ? EDGE_SUNKEN : EDGE_RAISED, BF_RECT | BF_SOFT);
    }
}

// these are raster ops
#define DSPDxax     0x00E20746  // BUGBUG: not used
#define PSDPxax     0x00B8074A

HWND g_hwndDebug = NULL;

void DrawFace(HDC hdc, int x, int y, int offx, int offy, int dxText,
              int dyText, TBDRAWITEM * ptbdraw)
{
    LPTSTR psz;
    IMAGELISTDRAWPARAMS imldp = {0};
    BOOL fHotTrack = FALSE;
    UINT state;
    PTBSTATE ptb;
    LPTBBUTTONDATA ptButton;
    BOOL fImage;        // !fImage means no image (as opposed to a blank image)

    ASSERT(ptbdraw);

    ptb = ptbdraw->ptb;
    ptButton = ptbdraw->pbutton;

    // AutosizeTextNoImage
    if ((ptb->ci.style & TBSTYLE_LIST) &&
        (ptbdraw->iImage == I_IMAGENONE) &&
        (ptButton->fsStyle & BTNS_AUTOSIZE)) {
        fImage = FALSE;
    } else {
        fImage = TRUE;
    }

    state = ptbdraw->state;

    if (state & TBSTATE_ENABLED)
    {
        fHotTrack = ptbdraw->fHotTrack;

        if (ptb->ci.style & TBSTYLE_FLAT)
        {
            UINT bdr = 0;

            if (state & (TBSTATE_PRESSED | TBSTATE_CHECKED))
                bdr = BDR_SUNKENOUTER;
            else if (fHotTrack)
                bdr = BDR_RAISEDINNER;

            if (bdr)
            {
                RECT rc;
                TB_GetItemRect(ptb, (UINT)(ptButton - ptb->Buttons), &rc);

                if (TB_HasSplitDDArrow(ptb, ptButton))
                    rc.right -= ptb->dxDDArrowChar;

                if (!(ptbdraw->dwCustom & TBCDRF_NOEDGES) && ptb)
                    CCDrawEdge(hdc, &rc, bdr, BF_RECT, &(ptb->clrsc));
            }
        }
    }

    imldp.himl = NULL;

    if (fHotTrack || (state & TBSTATE_CHECKED)) {
        imldp.himl   = TBGetImageList(ptb, HIML_HOT, ptbdraw->iIndex);
        if (!imldp.himl)
            imldp.himl = TBGetImageList(ptb, HIML_NORMAL, ptbdraw->iIndex);
    } else if (DRAW_MONO_BTN(ptb, state) && (imldp.himl = TBGetImageList(ptb, HIML_DISABLED, ptbdraw->iIndex))) {
        // assigned in if statement
    } else if (imldp.himl = TBGetImageList(ptb, HIML_NORMAL, ptbdraw->iIndex)) {
        // assigned in if statement
    }

    if (imldp.himl && (ptbdraw->iImage != -1) && fImage)
    {
        COLORREF rgbBk = ptbdraw->tbcd.clrBtnFace;
        if (ptb->ci.style & TBSTYLE_TRANSPARENT) 
            rgbBk = CLR_NONE;
        
        if (ptb->dwStyleEx & TBSTYLE_EX_INVERTIBLEIMAGELIST)
            rgbBk = CLR_DEFAULT;

        imldp.cbSize = sizeof(imldp);
        imldp.i      = ptbdraw->iImage;
        imldp.hdcDst = hdc;
        imldp.x      = x + offx;
        imldp.y      = y + offy;
        imldp.cx     = 0;
        imldp.cy     = 0;
        imldp.xBitmap= 0;
        imldp.yBitmap= 0;
        imldp.rgbBk  = rgbBk;
        imldp.rgbFg  = CLR_DEFAULT;
        imldp.fStyle = ILD_NORMAL;
        if (state & (TBSTATE_CHECKED | TBSTATE_INDETERMINATE))
            imldp.fStyle = ILD_TRANSPARENT;

#ifdef TBHIGHLIGHT_GLYPH
        if ((state & TBSTATE_MARKED) && !(ptbdraw->dwCustom & TBCDRF_NOMARK))
            imldp.fStyle = ILD_TRANSPARENT | ILD_BLEND50;
#endif

        if (ptbdraw->dwCustom & TBCDRF_BLENDICON)
            imldp.fStyle = ILD_TRANSPARENT | ILD_BLEND50;

        ImageList_DrawIndirect(&imldp);
#ifdef DEBUG
        if (g_hwndDebug == ptb->ci.hwnd) {
            imldp.hdcDst = GetDC(NULL);
            ImageList_DrawIndirect(&imldp);
            ReleaseDC(NULL, imldp.hdcDst);
        }
#endif
    }

    psz = TB_StrForButton(ptb, ptButton);
    if (psz)
    {
        BOOL bHighlight = (state & TBSTATE_MARKED) && (ptb->ci.style & TBSTYLE_LIST) &&
                          !(ptbdraw->dwCustom & TBCDRF_NOMARK);

        if ((state & (TBSTATE_PRESSED | TBSTATE_CHECKED)) &&
            !(ptbdraw->dwCustom & TBCDRF_NOOFFSET))
        {
            x++;
            if (ptb->ci.style & TBSTYLE_LIST)
                y++;
        }

        if (ptb->ci.style & TBSTYLE_LIST)
        {
            if (fImage)
            {
                x += ptb->iDxBitmap + ptb->iListGap;
                dxText -= ptb->iDxBitmap + ptb->iListGap;
            }
            else
            {
                // fudge for I_IMAGENONE buttons
                x += g_cxEdge;
            }
        }
        else
        {
            y += offy + ptb->iDyBitmap;
            dyText -= offy + ptb->iDyBitmap;
        }

        DrawString(hdc, x + 1, y + 1, dxText, dyText, psz, bHighlight, ptbdraw);
    }
}

void InitTBDrawItem(TBDRAWITEM * ptbdraw, PTBSTATE ptb, LPTBBUTTONDATA pbutton,
                    UINT state, BOOL fHotTrack, int dxText, int dyText)
{
    NMTBCUSTOMDRAW * ptbcd;
    NMCUSTOMDRAW * pnmcd;

    ASSERT(ptbdraw);

    ptbdraw->ptb = ptb;
    ptbdraw->pbutton = pbutton;
    ptbdraw->fHotTrack = fHotTrack;
    ptbdraw->iIndex = GET_HIML_INDEX(pbutton->DUMMYUNION_MEMBER(iBitmap));
    ptbdraw->iImage = GET_IMAGE_INDEX(pbutton->DUMMYUNION_MEMBER(iBitmap));
    ptbdraw->state = state;

    ptbcd = &ptbdraw->tbcd;

    ptbcd->hbrMonoDither = g_hbrMonoDither;
    ptbcd->hbrLines = GetStockObject(BLACK_BRUSH);
    ptbcd->hpenLines = GetStockObject(BLACK_PEN);
    ptbcd->clrMark = g_clrHighlight;
    ptbcd->clrBtnHighlight = g_clrBtnHighlight;
    ptbcd->clrTextHighlight = g_clrHighlightText;
    ptbcd->clrBtnFace = g_clrBtnFace;
    ptbcd->nStringBkMode = TRANSPARENT;
    ptbcd->nHLStringBkMode = OPAQUE;
    ptbcd->clrText = g_clrBtnText;
    SetRect(&ptbcd->rcText, 0, 0, dxText, dyText);

    pnmcd = (NMCUSTOMDRAW *)ptbcd;

    pnmcd->uItemState = CDISFromState(state);

    if ((ptb->ci.style & TBSTYLE_FLAT) && fHotTrack)
        pnmcd->uItemState |= CDIS_HOT;
}

void DrawButton(HDC hdc, int x, int y, PTBSTATE ptb, LPTBBUTTONDATA ptButton, BOOL fActive)
{
    // BUGBUG: cleanup -- separate layout calculation & rendering

    int yOffset;
    HBRUSH hbrOld;
    UINT state;
    int dxFace, dyFace;
    int dxText, dyText;
    int xCenterOffset;
    int dx = TBWidthOfButton(ptb, ptButton, hdc);
    HFONT oldhFont;
    int dy = ptb->iButHeight;
    TBDRAWITEM tbdraw = { 0 };
    NMTBCUSTOMDRAW * ptbcd = &tbdraw.tbcd;
    NMCUSTOMDRAW * pnmcd = (NMCUSTOMDRAW *)ptbcd;
    COLORREF clrSave;
    BOOL fHotTrack;
    HFONT hFontNoAntiAlias = NULL;

    state = (UINT)ptButton->fsState;
    // make local copy of state and do proper overriding
    if (state & TBSTATE_INDETERMINATE) {
        if (state & TBSTATE_PRESSED)
            state &= ~TBSTATE_INDETERMINATE;
        else if (state & TBSTATE_ENABLED)
            state = TBSTATE_INDETERMINATE;
        else
            state &= ~TBSTATE_INDETERMINATE;
    }

    if (!fActive) {
        state &= ~TBSTATE_ENABLED;
    }

    fHotTrack = TBIsHotTrack(ptb, ptButton, state);

    pnmcd->hdc = hdc;
    pnmcd->dwItemSpec = ptButton->idCommand;
    pnmcd->uItemState = 0;
    pnmcd->lItemlParam = (LPARAM)ptButton->dwData;
    SetRect(&pnmcd->rc, x, y, x + dx, y + dy);

    dxText = dx - (3 * g_cxEdge);

    if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
    {
        dyText = dy;
    }
    else
    {
        dyText = dy - (2 * g_cyEdge);
    }

    InitTBDrawItem(&tbdraw, ptb, ptButton, state, fHotTrack, dxText, dyText);

    tbdraw.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, (NMCUSTOMDRAW *)ptbcd);

    // We gotta update our concept of hotness
    tbdraw.fHotTrack = fHotTrack = pnmcd->uItemState & CDIS_HOT;

    if (!(tbdraw.dwCustom & CDRF_SKIPDEFAULT ))
    {
        // Get the state back from what custom draw may have set
        state = tbdraw.state = StateFromCDIS(pnmcd->uItemState);

        dxFace = dx - (2 * g_cxEdge);
        dyFace = dy - (2 * g_cyEdge);
        dxText = ptbcd->rcText.right - ptbcd->rcText.left;
        dyText = ptbcd->rcText.bottom - ptbcd->rcText.top;

        if (TB_HasDDArrow(ptb, ptButton) && !TB_HasTopDDArrow(ptb, ptButton)) {
            int iAdjust = TBDDArrowAdjustment(ptb, ptButton);
            dxFace -= iAdjust;
            dxText -= iAdjust;
        }

        // Should we display the font using the GDI AntiAliasing?
        if (!ptb->fAntiAlias)
        {
            // No. Must be doing drag and drop. We don't want to AntiAlias because the
            // Purple color key will show through and it looks ugly.
            LOGFONT lfFont;

            if (GetObject(ptb->hfontIcon, sizeof(lfFont), &lfFont))
            {
                lfFont.lfQuality = NONANTIALIASED_QUALITY;
                hFontNoAntiAlias = CreateFontIndirect(&lfFont);
            }
        }

        if (hFontNoAntiAlias)
            oldhFont = SelectObject(hdc, hFontNoAntiAlias);
        else
            oldhFont = SelectObject(hdc, ptb->hfontIcon);

        clrSave = SetTextColor(hdc, ptbcd->clrText);

        if (!(ptb->ci.style & TBSTYLE_FLAT))
            DrawBlankButton(hdc, x, y, dx, dy, &tbdraw);


        // move coordinates inside border and away from upper left highlight.
        // the extents change accordingly.
        x += g_cxEdge;
        y += g_cyEdge;

        if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
        {
            yOffset = (ptb->iButHeight - ptb->iDyBitmap) / 2;
        }
        else
        {
            // calculate offset of face from (x,y).  y is always from the top,
            // so the offset is easy.  x needs to be centered in face.
            // center it taking the padding into account the padding area
            yOffset = (ptb->yPad - (2 * g_cyEdge)) / 2;
        }

        if (yOffset < 0)
            yOffset = 0;


        if ((ptb->ci.style & TBSTYLE_LIST) && !BTN_NO_SHOW_TEXT(ptb, ptButton)) {
            xCenterOffset = ptb->xPad / 2;
        } else if (TB_HasTopDDArrow(ptb, ptButton)) {
            //
            // Layout of "top dropdown" buttons looks like this:
            //
            //       icon            
            // fudge   |  dropdown arrow
            //    |    |    |
            //    v    v    v
            // +-+-+-------+--+-+
            // | | |       |  | |
            // | | |       |  | |
            // +-+-+-------+--+-+
            // |     <text>     |
            // +----------------+
            //
            // |<--- dxFace --->|
            //
            // xCenterOffset is the offset at which to start drawing the icon.
            //
            xCenterOffset = (dxFace + CX_TOP_FUDGE - (ptb->iDxBitmap + ptb->dxDDArrowChar)) / 2;
        } else {
            xCenterOffset = (dxFace - ptb->iDxBitmap) / 2;
        }

        if (state & (TBSTATE_PRESSED | TBSTATE_CHECKED) &&
            !(tbdraw.dwCustom & TBCDRF_NOOFFSET))
        {
            // pressed state moves down and to the right
            xCenterOffset++;
            yOffset++;
        }


        // draw the dithered background
        if  ((!fHotTrack || ptb->ci.iVersion < 5) &&
             (((state & (TBSTATE_CHECKED | TBSTATE_INDETERMINATE)) ||
              ((state & TBSTATE_MARKED) &&
               !(ptb->ci.style & TBSTYLE_FLAT) &&
               !(tbdraw.dwCustom & TBCDRF_NOMARK)))))
        {

            //Custom Draw can set hbrMonoDither to be NULL. Validate it before using it
            hbrOld = ptbcd->hbrMonoDither ? SelectObject(hdc, ptbcd->hbrMonoDither) : NULL;
            if (hbrOld)
            {
                COLORREF clrText, clrBack;

#ifdef TBHIGHLIGHT_BACK
                if (state & TBSTATE_MARKED)
                    clrText = SetTextColor(hdc, ptbcd->clrMark);
                else
#endif
                clrText = SetTextColor(hdc, ptbcd->clrBtnHighlight); // 0 -> 0
                clrBack = SetBkColor(hdc, ptbcd->clrBtnFace);        // 1 -> 1

                // only draw the dither brush where the mask is 1's
                PatBlt(hdc, x, y, dxFace, dyFace, PATCOPY);

                SelectObject(hdc, hbrOld);
                SetTextColor(hdc, clrText);
                SetBkColor(hdc, clrBack);
            }
        }

        // Paint the background of the hot-tracked item if the
        // custom draw said so
        if ((tbdraw.dwCustom & TBCDRF_HILITEHOTTRACK) && fHotTrack)
        {
            PatB(hdc, pnmcd->rc.left, pnmcd->rc.top,
                 pnmcd->rc.right - pnmcd->rc.left, pnmcd->rc.bottom - pnmcd->rc.top,
                 ptbcd->clrHighlightHotTrack);
        }

        tbdraw.iImage = ptButton->DUMMYUNION_MEMBER(iBitmap);
        if((ptButton->DUMMYUNION_MEMBER(iBitmap) == I_IMAGECALLBACK) && ptb->fHimlNative)
        {
            NMTBDISPINFO  tbgdi = {0};
            tbgdi.dwMask  = TBNF_IMAGE;
            TBGetItem(ptb,ptButton,&tbgdi);
            tbdraw.iImage = tbgdi.iImage;
        }
        tbdraw.iIndex = GET_HIML_INDEX(tbdraw.iImage);
        tbdraw.iImage = GET_IMAGE_INDEX(tbdraw.iImage);

        // Now put on the face.
        // TODO: Validate himlDisabled and ensure that the index is in range
        if (!DRAW_MONO_BTN(ptb, state) ||
            TBGetImageList(ptb, HIML_DISABLED, tbdraw.iIndex))
        {
            // regular version
            int yStart = y;

            if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
                yStart -= g_cyEdge;

            DrawFace(hdc, x, yStart, xCenterOffset, yOffset, dxText, dyText, &tbdraw);
        }

        if (DRAW_MONO_BTN(ptb, state))
        {
            HBITMAP hbmOld;

            //initialize the monochrome dc
            if (!ptb->hdcMono) {
                ptb->hdcMono = CreateCompatibleDC(hdc);
                if (!ptb->hdcMono)
                    return;
                SetTextColor(ptb->hdcMono, 0L);
                SelectObject(ptb->hdcMono, ptb->hfontIcon);
            }

            hbmOld = SelectObject(ptb->hdcMono, ptb->hbmMono);

            //
            // If we a mirrored DC, mirror the Memory DC so that
            // text written on the bitmap won't get flipped.
            //
            if ((IS_DC_RTL_MIRRORED(hdc)) &&
                (!(IS_DC_RTL_MIRRORED(ptb->hdcMono))))
            {
                SET_DC_RTL_MIRRORED(ptb->hdcMono);
            }


            // disabled version (or indeterminate)
            CreateMask(xCenterOffset, yOffset, dxFace, dyFace, (TBGetImageList(ptb, HIML_DISABLED, tbdraw.iIndex) == NULL), &tbdraw);

            SetTextColor(hdc, 0L);       // 0's in mono -> 0 (for ROP)
            SetBkColor(hdc, 0x00FFFFFF); // 1's in mono -> 1

            // draw glyph's etched-effect
            if (!(state & TBSTATE_INDETERMINATE) &&
                !(tbdraw.dwCustom & TBCDRF_NOETCHEDEFFECT)) {

                hbrOld = SelectObject(hdc, g_hbrBtnHighlight);
                if (hbrOld) {
                    // draw hilight color where we have 0's in the mask
                    BitBlt(hdc, x + 1, y + 1, dxFace, dyFace, ptb->hdcMono, 0, 0, PSDPxax);
                    SelectObject(hdc, hbrOld);
                }
            }

            // gray out glyph
            hbrOld = SelectObject(hdc, g_hbrBtnShadow);
            if (hbrOld) {
                // draw the shadow color where we have 0's in the mask
                BitBlt(hdc, x, y, dxFace, dyFace, ptb->hdcMono, 0, 0, PSDPxax);
                SelectObject(hdc, hbrOld);
            }

            if (state & TBSTATE_CHECKED) {
                BitBlt(ptb->hdcMono, 1, 1, dxFace - 1, dyFace - 1, ptb->hdcMono, 0, 0, SRCAND);
            }

            SelectObject(ptb->hdcMono, hbmOld);
        }

        if (TB_HasDDArrow(ptb, ptButton))
        {
            WORD wDSAFlags = DCHF_TRANSPARENT | DCHF_FLIPPED;
            BOOL fPressedDD = ((ptb->Buttons + ptb->iPressedDD) == ptButton);

            RECT rc;
            if (TB_HasTopDDArrow(ptb, ptButton)) {
                // position the dd arrow up next to the bitmap
                rc.left = x + xCenterOffset + ptb->iDxBitmap;
                rc.right = rc.left + ptb->dxDDArrowChar;
                rc.top = y + yOffset;
                rc.bottom = rc.top + ptb->iDyBitmap;
            }
            else 
            {
                // position the dd arrow to the right of the text & bitmap
                TB_GetItemRect(ptb, (UINT)(ptButton - ptb->Buttons), &rc);
                rc.left = rc.right - ptb->dxDDArrowChar;
            }

            if (TB_HasUnsplitDDArrow(ptb, ptButton)) {
                // if a non-split dd arrow, don't draw a border.
                wDSAFlags |= DCHF_NOBORDER;
            }

            if (DRAW_MONO_BTN(ptb, state)) {
                // DFCS_INACTIVE means "draw the arrow part grayed"
                wDSAFlags |= DCHF_INACTIVE;
            }
            // if TB_HasTopDDArrow, we've already offset rect, so don't draw DCHF_PUSHED
            else if ((fPressedDD || (state & (TBSTATE_CHECKED | TBSTATE_PRESSED))) &&
                   !TB_HasTopDDArrow(ptb, ptButton)) {
                // DCHF_PUSHED means "offset the arrow and draw indented border"
                wDSAFlags |= DCHF_PUSHED;
            } 
            else if (fHotTrack || !(ptb->ci.style & TBSTYLE_FLAT)) {
                // DCHF_HOT means "draw raised border"
                // non-flat dropdown arrows are either pushed or hot
                wDSAFlags |= DCHF_HOT;
            }

            DrawScrollArrow(hdc, &rc, wDSAFlags);
        }

        SelectObject(hdc, oldhFont);
        SetTextColor(hdc, clrSave);

        if (hFontNoAntiAlias)
        {
            DeleteObject(hFontNoAntiAlias);
        }
    }

    if (tbdraw.dwCustom & CDRF_NOTIFYPOSTPAINT)
        CICustomDrawNotify(&ptb->ci, CDDS_ITEMPOSTPAINT, (NMCUSTOMDRAW *)ptbcd);
}

// make sure that g_hbmMono is big enough to do masks for this
// size of button.  if not, fail.
BOOL CheckMonoMask(PTBSTATE ptb, int width, int height)
{
    BITMAP bm;
    HBITMAP hbmTemp;

    if (ptb->hbmMono) {
        GetObject(ptb->hbmMono, sizeof(BITMAP), &bm);
        if (width <= bm.bmWidth && height <= bm.bmHeight) {
            return TRUE;
        }
    }


    // Add a bit of fudge to keep this from being reallocated too often.
    hbmTemp = CreateMonoBitmap(width+8, height+8);
    if (!hbmTemp)
        return FALSE;

    if (ptb->hbmMono)
        DeleteObject(ptb->hbmMono);
    ptb->hbmMono = hbmTemp;
    return TRUE;
}

/*
** GrowToolbar
**
** Attempt to grow the button size.
**
** The calling function can either specify a new internal measurement
** (GT_INSIDE) or a new external measurement.
**
** GT_MASKONLY updates the mono mask and nothing else.
*/
BOOL GrowToolbar(PTBSTATE ptb, int newButWidth, int newButHeight, UINT flags)
{
    if (!newButWidth)
        newButWidth = DEFAULTBUTTONX;
    if (!newButHeight)
        newButHeight = DEFAULTBUTTONY;

    // if growing based on inside measurement, get full size
    if (flags & GT_INSIDE)
    {
        if (ptb->ci.style & TBSTYLE_LIST)
            newButWidth += ptb->iDxBitmap + ptb->iListGap;

        newButHeight += ptb->yPad;
        newButWidth += ptb->xPad;

        // if toolbar already has strings, don't shrink width it because it
        // might clip room for the string
        if ((newButWidth < ptb->iButWidth) && ptb->nStrings &&
            (ptb->ci.iVersion < 5 || ptb->nTextRows > 0))
            newButWidth = ptb->iButWidth;
    }
    else {
        if (newButHeight == -1)
            newButHeight = ptb->iButHeight;
        if (newButWidth == -1)
            newButWidth = ptb->iButWidth;

        if (newButHeight < ptb->iDyBitmap + ptb->yPad)
            newButHeight = ptb->iDyBitmap + ptb->yPad;
        if (newButWidth < ptb->iDxBitmap + ptb->xPad)
            newButWidth = ptb->iDxBitmap + ptb->xPad;
    }

    // if the size of the toolbar is actually growing, see if shadow
    // bitmaps can be made sufficiently large.
    if (!ptb->hbmMono || (newButWidth > ptb->iButWidth) || (newButHeight > ptb->iButHeight)) {
        if (!CheckMonoMask(ptb, newButWidth, newButHeight))
            return(FALSE);
    }

    if (flags & GT_MASKONLY)
        return(TRUE);

    if (!(flags & GT_INSIDE) && ((ptb->iButWidth != newButWidth) || (ptb->iButHeight != newButHeight)))
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

    ptb->iButWidth = newButWidth;
    ptb->iButHeight = newButHeight;

    // bar height has 2 pixels above, 2 below
    if (ptb->ci.style & TBSTYLE_FLAT)
        ptb->iYPos = 0;
    else
        ptb->iYPos = 2;

    TBInvalidateItemRects(ptb);

    return TRUE;
}

BOOL SetBitmapSize(PTBSTATE ptb, int width, int height)
{
    int realh;

    if (!width)
        width = 1;
    if (!height)
        height = 1;

    if (width == -1)
        width = ptb->iDxBitmap;

    if (height == -1)
        height = ptb->iDyBitmap;

    realh = height;

    if ((ptb->iDxBitmap == width) && (ptb->iDyBitmap == height))
        return TRUE;

    if (TBHasStrings(ptb))
        realh = HeightWithString(ptb, height);

    if (GrowToolbar(ptb, width, realh, GT_INSIDE)) {
        ptb->iDxBitmap = width;
        ptb->iDyBitmap = height;

        // the size changed, we need to rebuild the imagelist
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
        TBInvalidateImageList(ptb);
        return TRUE;
    }
    return FALSE;
}

void TB_OnSysColorChange(PTBSTATE ptb)
{

    int i;
    InitGlobalColors();
    //  Reset all of the bitmaps

    for (i = 0; i < ptb->cPimgs; i++) {
        HIMAGELIST himl = TBGetImageList(ptb, HIML_NORMAL, i);
        if (himl)
            ImageList_SetBkColor(himl, (ptb->ci.style & TBSTYLE_TRANSPARENT) ? CLR_NONE : g_clrBtnFace);
        himl = TBGetImageList(ptb, HIML_HOT, i);
        if (himl)
            ImageList_SetBkColor(himl, (ptb->ci.style & TBSTYLE_TRANSPARENT) ? CLR_NONE : g_clrBtnFace);
    }
}

#define CACHE 0x01
#define BUILD 0x02


void PASCAL ReleaseMonoDC(PTBSTATE ptb)
{
    if (ptb->hdcMono) {
        SelectObject(ptb->hdcMono, g_hfontSystem);
        DeleteDC(ptb->hdcMono);
        ptb->hdcMono = NULL;
    }
}

void TB_OnEraseBkgnd(PTBSTATE ptb, HDC hdc)
{
    NMTBCUSTOMDRAW  tbcd = { 0 };
    DWORD           dwRes = FALSE;

    tbcd.nmcd.hdc = hdc;

    if (ptb->ci.style & TBSTYLE_CUSTOMERASE) {
        ptb->ci.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_PREERASE, (NMCUSTOMDRAW *)&tbcd);
    } else {
        ptb->ci.dwCustom = CDRF_DODEFAULT;
    }

    if (!(ptb->ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        // for transparent toolbars, forward erase background to parent
        // but handle thru DefWindowProc in the event parent doesn't paint
        if (!(ptb->ci.style & TBSTYLE_TRANSPARENT) ||
            !CCForwardEraseBackground(ptb->ci.hwnd, hdc))
            DefWindowProc(ptb->ci.hwnd, WM_ERASEBKGND, (WPARAM) hdc, 0);
    }

    if (ptb->ci.dwCustom & CDRF_NOTIFYPOSTERASE)
        CICustomDrawNotify(&ptb->ci, CDDS_POSTERASE, (NMCUSTOMDRAW *)&tbcd);
}

void PASCAL DrawInsertMark(HDC hdc, LPRECT prc, BOOL fHorizMode, COLORREF clr)
{
    HPEN hPnMark = CreatePen(PS_SOLID, 1, clr);
    HPEN hOldPn;
    POINT rgPoint[4];
    if (!hPnMark)
        hPnMark = (HPEN)GetStockObject(BLACK_PEN);    // fallback to draw with black pen
    hOldPn = (HPEN)SelectObject(hdc, (HGDIOBJ)hPnMark);

    if ( fHorizMode )
    {
        int iXCentre = (prc->left + prc->right) /2;

        rgPoint[0].x = iXCentre + 1;
        rgPoint[0].y = prc->top + 2;
        rgPoint[1].x = iXCentre + 3;
        rgPoint[1].y = prc->top;
        rgPoint[2].x = iXCentre - 2;
        rgPoint[2].y = prc->top;
        rgPoint[3].x = iXCentre;
        rgPoint[3].y = prc->top + 2;

        // draw the top bit...
        Polyline( hdc, rgPoint, 4 );

        rgPoint[0].x = iXCentre;
        rgPoint[0].y = prc->top;
        rgPoint[1].x = iXCentre;
        rgPoint[1].y = prc->bottom - 1;
        rgPoint[2].x = iXCentre + 1;
        rgPoint[2].y = prc->bottom - 1;
        rgPoint[3].x = iXCentre + 1;
        rgPoint[3].y = prc->top;

        // draw the middle...
        Polyline( hdc, rgPoint, 4 );

        rgPoint[0].x = iXCentre + 1;
        rgPoint[0].y = prc->bottom - 3;
        rgPoint[1].x = iXCentre + 3;
        rgPoint[1].y = prc->bottom - 1;
        rgPoint[2].x = iXCentre - 2;
        rgPoint[2].y = prc->bottom - 1;
        rgPoint[3].x = iXCentre;
        rgPoint[3].y = prc->bottom - 3;

        // draw the bottom bit...
        Polyline( hdc, rgPoint, 4 );
    }
    else
    {
        int iYCentre = (prc->top + prc->bottom) /2;

        rgPoint[0].x = prc->left + 2;
        rgPoint[0].y = iYCentre;
        rgPoint[1].x = prc->left;
        rgPoint[1].y = iYCentre - 2;
        rgPoint[2].x = prc->left;
        rgPoint[2].y = iYCentre + 3;
        rgPoint[3].x = prc->left + 2;
        rgPoint[3].y = iYCentre + 1;

        // draw the top bit...
        Polyline( hdc, rgPoint, 4 );

        rgPoint[0].x = prc->left;
        rgPoint[0].y = iYCentre;
        rgPoint[1].x = prc->right - 1;
        rgPoint[1].y = iYCentre;
        rgPoint[2].x = prc->right - 1;
        rgPoint[2].y = iYCentre + 1;
        rgPoint[3].x = prc->left;
        rgPoint[3].y = iYCentre + 1;

        // draw the middle...
        Polyline( hdc, rgPoint, 4 );

        rgPoint[0].x = prc->right - 3;
        rgPoint[0].y = iYCentre;
        rgPoint[1].x = prc->right - 1;
        rgPoint[1].y = iYCentre - 2;
        rgPoint[2].x = prc->right - 1;
        rgPoint[2].y = iYCentre + 3;
        rgPoint[3].x = prc->right - 3;
        rgPoint[3].y = iYCentre + 1;

        // draw the bottom bit...
        Polyline( hdc, rgPoint, 4 );
    }

    SelectObject( hdc, hOldPn );
    DeleteObject((HGDIOBJ)hPnMark);
}

BOOL TBIsRectClipped(PTBSTATE ptb, LPRECT prc)
{
    RECT rc;
    RECT rcTB;

    if (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
        CopyRect(&rcTB, &ptb->rc);
    else
        GetClientRect(ptb->ci.hwnd, &rcTB);

    if (IntersectRect(&rc, &rcTB, prc)) {
        if (EqualRect(prc, &rc))
            return FALSE;
    }

    return TRUE;
}

BOOL TBShouldDrawButton(PTBSTATE ptb, LPRECT prcBtn, HDC hdc)
{
    // don't bother drawing buttons that aren't in the dc clipping region
    if (RectVisible(hdc, prcBtn)) {
        if (ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS)
            return !TBIsRectClipped(ptb, prcBtn);
        else
            return TRUE;
    }

    return FALSE;
}

// goin horizontal . . .
void DrawToolbarH(PTBSTATE ptb, HDC hdc, LPRECT prc)
{
    int iButton, xButton, yButton, cxBar;
    LPTBBUTTONDATA pAllButtons = ptb->Buttons;
    cxBar = prc->right - prc->left;

    yButton   = ptb->iYPos;
    prc->top    = ptb->iYPos;
    prc->bottom = ptb->iYPos + ptb->iButHeight;   // BUGBUG (scotth): what if first btn is a separator?


    for (iButton = 0, xButton = ptb->xFirstButton;
            iButton < ptb->iNumButtons; iButton++)
    {
        LPTBBUTTONDATA pButton = &pAllButtons[iButton];
        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            int cxButton = TBWidthOfButton(ptb, pButton, hdc);

            // Is there anything to draw?
            if (!(pButton->fsStyle & BTNS_SEP) || (ptb->ci.style & TBSTYLE_FLAT))
            {
                // Yes
                prc->left = xButton;
                prc->right = xButton + cxButton;

                if (TBShouldDrawButton(ptb, prc, hdc))
                {
                    // Draw separator?
                    if (pButton->fsStyle & BTNS_SEP)
                    {
                        // Yes; must be a flat separator.  Is this toolbar vertical?
                        if (ptb->ci.style & CCS_VERT)
                        {
                            // Yes; draw a horizontal separator.  Center w/in the
                            // button rect
                            int iSave = prc->top;
                            prc->top += (TBGetSepHeight(ptb, pButton) - 1) / 2;
                            InflateRect(prc, -g_cxEdge, 0);
                            CCDrawEdge(hdc, prc, EDGE_ETCHED, BF_TOP, &(ptb->clrsc));
                            InflateRect(prc, g_cxEdge, 0);
                            prc->top = iSave;
                        }
                        else
                        {
                            // No; draw a vertical separator
                            prc->left += (cxButton - 1) / 2;
                            InflateRect(prc, 0, -g_cyEdge);
                            CCDrawEdge(hdc, prc, EDGE_ETCHED, BF_LEFT, &(ptb->clrsc));
                            InflateRect(prc, 0, g_cyEdge);
                        }
                    }
                    else
                    {
                        // No
                        DrawButton(hdc, xButton, yButton, ptb, pButton, ptb->fActive);
                    }
                }
            }

            xButton += (cxButton - s_dxOverlap);

            if (pButton->fsState & TBSTATE_WRAP)
            {
                int dy;

                if (pButton->fsStyle & BTNS_SEP)
                {
                    if (ptb->ci.style & CCS_VERT)
                        dy = TBGetSepHeight(ptb, pButton);
                    else
                    {
                        if (ptb->ci.style & TBSTYLE_FLAT)
                        {
                            // Draw a separator across the entire toolbar to separate rows.
                            // For horizontal toolbars only.
                            RECT rcMid;
                            rcMid.top = prc->top + ptb->iButHeight + ((TBGetSepHeight(ptb, pButton) - 1) / 2);
                            rcMid.bottom = rcMid.top + g_cxEdge;
                            rcMid.left = g_cxEdge;
                            rcMid.right = cxBar - g_cxEdge;

                            CCDrawEdge(hdc, &rcMid, EDGE_ETCHED, BF_TOP, &(ptb->clrsc));
                        }

                        dy = ptb->iButHeight + TBGetSepHeight(ptb, pButton);
                    }
                }
                else
                    dy = ptb->iButHeight;

                xButton = ptb->xFirstButton;
                yButton   += dy;
                prc->top    += dy;
                prc->bottom += dy;
            }
        }
    }
}

// goin vertical . . .
void DrawToolbarV(PTBSTATE ptb, HDC hdc, LPRECT prc)
{
    int iButton, xButton, yButton, cyBar;
    LPTBBUTTONDATA pAllButtons = ptb->Buttons;
    NMTBCUSTOMDRAW  tbcd = { 0 };
    LPTBBUTTONDATA pButton = pAllButtons;

    cyBar = prc->bottom - prc->top;

    xButton = ptb->xFirstButton;
    prc->left = xButton;
    prc->right = prc->left + ptb->iButWidth;

    for (iButton = 0, yButton = 0;
            iButton < ptb->iNumButtons; iButton++, pButton++)
    {
        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            // Is there anything to draw?
            if (!(pButton->fsStyle & BTNS_SEP) || (ptb->ci.style & TBSTYLE_FLAT))
            {
                int cyButton;
                
                if (pButton->fsStyle & BTNS_SEP)
                    cyButton = TBGetSepHeight(ptb, pButton);
                else
                    cyButton = ptb->iButHeight;

                prc->top = yButton;
                prc->bottom = yButton + cyButton;

                if (TBShouldDrawButton(ptb, prc, hdc))
                {
                    // Draw separator?
                    if (pButton->fsStyle & BTNS_SEP)
                    {
                        DWORD dwCustRet;
                        NMTBCUSTOMDRAW  tbcd = { 0 };

                        tbcd.nmcd.hdc = hdc;
                        tbcd.nmcd.dwItemSpec = -1;
                        CopyRect(&tbcd.nmcd.rc, prc);

                        dwCustRet = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, (NMCUSTOMDRAW *)&tbcd);

                        if ( !(CDRF_SKIPDEFAULT &  dwCustRet) )
                        {
                            // Yes; must be a flat separator.
                            InflateRect(prc, -g_cxEdge, 0);
                            CCDrawEdge(hdc, prc, EDGE_ETCHED, BF_TOP, &(ptb->clrsc));
                            InflateRect(prc, g_cxEdge, 0);
                        }
                    }
                    else
                    {
                        // No
                        DrawButton(hdc, xButton, yButton, ptb, pButton, ptb->fActive);
                    }
                }
                
                yButton += cyButton;
            }

            if (pButton->fsState & TBSTATE_WRAP)
            {
                int dx;
            
                if (ptb->ci.style & TBSTYLE_FLAT)
                {
                    // Draw a separator vertival across the entire toolbar to separate cols.
                    // For vertical toolbars only.

                    RECT rcMid;

                    rcMid.top = ptb->rc.top + g_cxEdge;
                    rcMid.bottom = ptb->rc.bottom - g_cxEdge;
                    rcMid.left = xButton + ptb->iButWidth;
                    rcMid.right = rcMid.left + g_cxEdge;
                    CCDrawEdge(hdc, &rcMid, EDGE_ETCHED, BF_LEFT, &(ptb->clrsc));
                }

                dx = ptb->iButWidth + g_cxEdge;

                yButton  = 0;
                xButton += dx;
                prc->left += dx;
                prc->right += dx;
            }
        }
    }
}

COLORREF TB_GetInsertMarkColor(PTBSTATE ptb)
{
    if (ptb->clrim == CLR_DEFAULT)
        return g_clrBtnText;
    else
        return ptb->clrim;
}

void TBPaint(PTBSTATE ptb, HDC hdcIn)
{
    RECT rc;
    HDC hdc;
    PAINTSTRUCT ps;
    NMTBCUSTOMDRAW  tbcd = { 0 };

    GetClientRect(ptb->ci.hwnd, &rc);
    if (hdcIn)
    {
        hdc = hdcIn;
    }
    else
        hdc = BeginPaint(ptb->ci.hwnd, &ps);

    if (!rc.right)
        goto Error1;

    tbcd.nmcd.hdc = hdc;
    tbcd.nmcd.rc = rc;
    ptb->ci.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_PREPAINT, (NMCUSTOMDRAW *)&tbcd);

    if (!(ptb->ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        if (!ptb->fHimlValid)
            TBBuildImageList(ptb);

        if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
            DrawToolbarV(ptb, hdc, &rc);
        else
            DrawToolbarH(ptb, hdc, &rc);

        if (ptb->iInsert!=-1)
        {
            BOOL fHorizMode = !(ptb->ci.style & CCS_VERT);
            RECT rc;
            if (GetInsertMarkRect(ptb, &rc, fHorizMode))
            {
                DrawInsertMark(hdc, &rc, fHorizMode, TB_GetInsertMarkColor(ptb));
            }
        }

        ReleaseMonoDC(ptb);
    }

    if (ptb->ci.dwCustom & CDRF_NOTIFYPOSTPAINT)
    {
        tbcd.nmcd.hdc = hdc;
        tbcd.nmcd.uItemState = 0;
        tbcd.nmcd.lItemlParam = 0;
        CICustomDrawNotify(&ptb->ci, CDDS_POSTPAINT, (NMCUSTOMDRAW *)&tbcd);
    }

Error1:
    if (hdcIn == NULL)
        EndPaint(ptb->ci.hwnd, &ps);

}

void TB_GetItemDropDownRect(PTBSTATE ptb, UINT uButton, LPRECT lpRect)
{
    TB_GetItemRect(ptb,uButton,lpRect);
    lpRect->left = lpRect->right - ptb->dxDDArrowChar;
}

int TBHeightOfButton(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    int dy;

	if ((ptbb->fsStyle & BTNS_SEP)  && 
		(ptbb->fsState & TBSTATE_WRAP || ptb->dwStyleEx & TBSTYLE_EX_VERTICAL))
	{
		if (!(ptb->ci.style & CCS_VERT) && !(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)) 
		{
			dy = TBGetSepHeight(ptb, ptbb) + ptb->iButHeight;
		} 
		else 
		{
			dy = TBGetSepHeight(ptb, ptbb);
		}
	}
	else
	{
		dy = ptb->iButHeight;
	}

    return dy;
}

void TB_CalcItemRects(PTBSTATE ptb)
{
    int iButton, xPos, yPos;

    ASSERT(!ptb->fItemRectsValid);

    xPos = ptb->xFirstButton;
    yPos = ptb->iYPos;

    for (iButton = 0; iButton < ptb->iNumButtons; iButton++)
    {
        int xPosButton;
        LPTBBUTTONDATA pButton = &ptb->Buttons[iButton];

        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            if ((pButton->fsState & TBSTATE_WRAP) && (pButton->fsStyle & BTNS_SEP))
                xPosButton = ptb->xFirstButton;
            else
                xPosButton = xPos;

            pButton->pt.x = xPosButton;
            pButton->pt.y = yPos;

            if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
            {
                if (pButton->fsState & TBSTATE_WRAP)
                {
                    xPos += (ptb->iButWidth + g_cxEdge);    // to not overwrite the edge.
                    yPos = 0;
                }
                else if (pButton->fsStyle & BTNS_SEP)
                    yPos += (TBGetSepHeight(ptb, pButton));
                else
                    yPos += ptb->iButHeight;
            }
            else // standard horizontal toolbar.
            {
                xPos += TBWidthOfButton(ptb, pButton, NULL) - s_dxOverlap;

                if (pButton->fsState & TBSTATE_WRAP)
                {
                    yPos += ptb->iButHeight;

                    if (pButton->fsStyle & BTNS_SEP)
                    {
                        if (ptb->ci.style & CCS_VERT) {
                            yPos -= ptb->iButHeight;
                        }
                        yPos += (TBGetSepHeight(ptb, pButton));
                    }

                    xPos = ptb->xFirstButton;
                }
            }
        }
    }
}

BOOL TB_GetItemRect(PTBSTATE ptb, UINT uButton, LPRECT lpRect)
{
    int dy = ptb->iButHeight;

    if (uButton >= (UINT)ptb->iNumButtons
        || (ptb->Buttons[uButton].fsState & TBSTATE_HIDDEN))
    {
        return FALSE;
    }

    if (!ptb->fItemRectsValid) {
        TB_CalcItemRects(ptb);
        ptb->fItemRectsValid = TRUE;
    }

    lpRect->left   = ptb->Buttons[uButton].pt.x;
    lpRect->right  = lpRect->left + TBWidthOfButton(ptb, &ptb->Buttons[uButton], NULL);
    lpRect->top    = ptb->Buttons[uButton].pt.y;
    lpRect->bottom = lpRect->top + TBHeightOfButton(ptb, &ptb->Buttons[uButton]);

    return TRUE;
}

void InvalidateButton(PTBSTATE ptb, LPTBBUTTONDATA pButtonToPaint, BOOL fErase)
{
    RECT rc;

    if (TB_GetItemRect(ptb, (UINT) (pButtonToPaint - ptb->Buttons), &rc))
    {
        InvalidateRect(ptb->ci.hwnd, &rc, fErase);
    }
}

/*----------------------------------------------------------
Purpose: Toggles the button as a dropdown

Returns: TRUE if handled
*/
BOOL TBToggleDropDown(PTBSTATE ptb, int iPos, BOOL fEatMsg)
{
    BOOL bRet = FALSE;
    LPTBBUTTONDATA ptbButton = &ptb->Buttons[iPos];

    ASSERT(TB_IsDropDown(ptbButton));

    if (ptbButton->fsState & TBSTATE_ENABLED)
    {
        UINT nVal;

        ptb->iPressedDD = iPos;

        if (TB_HasUnsplitDDArrow(ptb, ptbButton))
            ptbButton->fsState |= TBSTATE_PRESSED;

        InvalidateButton(ptb, ptbButton, TRUE);
        UpdateWindow(ptb->ci.hwnd);

        MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, ptb->ci.hwnd, OBJID_CLIENT, iPos+1);

        nVal = (UINT) SendItemNotify(ptb, ptbButton->idCommand, TBN_DROPDOWN);
        if (TBDDRET_DEFAULT == nVal || TBDDRET_TREATPRESSED == nVal)
        {
            if (fEatMsg)
            {
                MSG msg;

                PeekMessage(&msg, ptb->ci.hwnd, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_REMOVE);
            }

            ptb->iPressedDD = -1;

            if (TB_HasUnsplitDDArrow(ptb, ptbButton))
                ptbButton->fsState &= ~TBSTATE_PRESSED;

            InvalidateButton(ptb, ptbButton, TRUE);
            UpdateWindow(ptb->ci.hwnd);

            MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, ptb->ci.hwnd, OBJID_CLIENT, iPos+1);
        }

        bRet = (TBDDRET_DEFAULT == nVal);
    }
    return bRet;
}


void TBInvalidateButton(PTBSTATE ptb, int i, BOOL fErase)
{
    if (i != -1) {
        InvalidateButton(ptb, &ptb->Buttons[i], fErase);
   }
}


void TBSetHotItem(PTBSTATE ptb, int iPos, DWORD dwReason)
{
    HWND hwnd;

    if ((ptb->ci.style & TBSTYLE_FLAT) ) {

        // Either one of these values can be -1, but refrain
        // from processing if both are negative b/c it is wasteful
        // and very common

        if ((ptb->iHot != iPos || (dwReason & HICF_RESELECT)) &&
            (0 <= ptb->iHot || 0 <= iPos) &&
            iPos < ptb->iNumButtons)
        {
            NMTBHOTITEM nmhot = {0};

            // Has the mouse moved away from the toolbar but
            // do we still anchor the highlight?
            if (0 > iPos && ptb->fAnchorHighlight && (dwReason & HICF_MOUSE))
                return ;        // Yes; deny the hot item change

            // Send a notification about the hot item change
            if (0 > ptb->iHot)
            {
                if (iPos >= 0)
                    nmhot.idNew = ptb->Buttons[iPos].idCommand;
                nmhot.dwFlags = HICF_ENTERING;
            }
            else if (0 > iPos)
            {
                if (ptb->iHot >= 0 && ptb->iHot < ptb->iNumButtons)
                    nmhot.idOld = ptb->Buttons[ptb->iHot].idCommand;
                nmhot.dwFlags = HICF_LEAVING;
            }
            else
            {
                if (ptb->iHot < ptb->iNumButtons)
                    nmhot.idOld = ptb->Buttons[ptb->iHot].idCommand;
                nmhot.idNew = ptb->Buttons[iPos].idCommand;
            }
            nmhot.dwFlags |= dwReason;

            // must save this for revalidation
            hwnd = ptb->ci.hwnd;

            if (CCSendNotify(&ptb->ci, TBN_HOTITEMCHANGE, &nmhot.hdr))
                return;         // deny the hot item change

            // Revalidate the window
            if (!IsWindow(hwnd)) return;

            TBInvalidateButton(ptb, ptb->iHot, TRUE);
            if ((iPos < 0) || !(ptb->Buttons[iPos].fsState & TBSTATE_ENABLED))
                iPos = -1;

            ptb->iHot = iPos;

            if (GetFocus() == ptb->ci.hwnd)
                MyNotifyWinEvent(EVENT_OBJECT_FOCUS, ptb->ci.hwnd, OBJID_CLIENT, iPos + 1);

            TBInvalidateButton(ptb, ptb->iHot, TRUE);

            if ((iPos >= 0 && iPos < ptb->iNumButtons) &&
                (TB_IsDropDown(&ptb->Buttons[iPos])) &&
                (dwReason & HICF_TOGGLEDROPDOWN))
            {
                TBToggleDropDown(ptb, iPos, FALSE);
            }
        }
    }
}

BOOL GetInsertMarkRect(PTBSTATE ptb, LPRECT prc, BOOL fHorizMode)
{
    BOOL fRet = TB_GetItemRect(ptb, ptb->iInsert, prc);
    if (fRet)
    {
        // if we are in horizontal mode, we need a vertical insertion marker
        if ( fHorizMode )
        {
            if (ptb->fInsertAfter)
                prc->left = prc->right;
            else
                prc->right = prc->left;

            prc->left -= INSERTMARKSIZE/2;
            prc->right += INSERTMARKSIZE/2 + 1;
        }
        else
        {
            if (ptb->fInsertAfter)
                prc->top = prc->bottom;
            else
                prc->bottom = prc->top;

            prc->top -= INSERTMARKSIZE/2;
            prc->bottom += INSERTMARKSIZE/2 + 1;
        }
    }
    return fRet;
}

void TBInvalidateMark(PTBSTATE ptb)
{
    RECT rc;

    if (GetInsertMarkRect(ptb, &rc, !(ptb->ci.style & CCS_VERT)))
    {
        InvalidateRect(ptb->ci.hwnd, &rc, TRUE);
    }
}

void TBSetInsertMark(PTBSTATE ptb, LPTBINSERTMARK ptbim)
{
    if (ptbim->iButton != ptb->iInsert ||
        BOOLIFY(ptb->fInsertAfter) != BOOLIFY(ptbim->dwFlags & TBIMHT_AFTER))
    {
        if (ptb->iInsert != -1)
            TBInvalidateMark(ptb);

        ptb->iInsert = ptbim->iButton;
        ptb->fInsertAfter = BOOLIFY(ptbim->dwFlags & TBIMHT_AFTER);

        if (ptb->iInsert != -1)
            TBInvalidateMark(ptb);
    }
}

void TBCycleHotItem(PTBSTATE ptb, int iStart, int iDirection, UINT nReason)
{
    int i;
    int iPrev;
    NMTBWRAPHOTITEM nmwh;

    nmwh.iDir = iDirection;
    nmwh.nReason = nReason;


    //When cycling around the menu, without this check, the second to last menu
    //item would be selected.
    if (iStart == -1 && iDirection == -1)
        iStart = 0;

    for (i = 0; i < ptb->iNumButtons; i++)
    {
        iPrev = iStart;
        iStart += iDirection + ptb->iNumButtons;
        iStart %= ptb->iNumButtons;

        if ( ( iPrev + iDirection >= ptb->iNumButtons) || (iPrev + iDirection < 0) )
        {
            nmwh.iStart = iStart;
            if (CCSendNotify(&ptb->ci, TBN_WRAPHOTITEM, &nmwh.hdr))
                return;
        }

        if (ptb->Buttons[iStart].fsState & TBSTATE_ENABLED &&
            !(ptb->Buttons[iStart].fsState & TBSTATE_HIDDEN) &&
            !(ptb->Buttons[iStart].fsStyle & BTNS_SEP))
        {
            // if the old hot item was dropped down, undrop it.
            if (ptb->iHot != -1 && ptb->iHot == ptb->iPressedDD)
                TBToggleDropDown(ptb, ptb->iHot, FALSE);

            TBSetHotItem(ptb, iStart, nReason);
            break;
        }
    }
}


// Do hit testing by sliding the origin of the supplied point
//
// returns:
//  >= 0    index of non separator item hit
//  < 0     index of separator or nearest non separator item (area
//          just below and to the left)
//
// +--------------------------------------
// |      -1    -1    -1    -1
// |      btn   sep   btn
// |    +-----+     +-----+
// |    |     |     |     |
// | -1 |  0  | -1  |  2  | -3
// |    |     |     |     |
// |    +-----+     +-----+
// |
// | -1   -1    -1    -2    -3
//

int TBHitTest(PTBSTATE ptb, int xPos, int yPos)
{
    int prev = 0;
    int last = 0;
    int i;
    RECT rc;

    if (ptb->iNumButtons == 0)
        return(-1);

    for (i=0; i<ptb->iNumButtons; i++)
    {
        if (TB_GetItemRect(ptb, i, &rc))
        {
            // ignore this button if hidden because of HideClippedButtons style
            if (!(ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS) || !(TBIsRectClipped(ptb, &rc)))
            {
                // From PtInRect docs:
                //   A point is within a rectangle if it lies on the left or top
                //   side or is within all four sides. A point on the right or
                //   bottom side is considered outside the rectangle.

                if (yPos >= rc.top && yPos < rc.bottom)
                {
                    if (xPos >= rc.left && xPos < rc.right)
                    {
                        if (ptb->Buttons[i].fsStyle & BTNS_SEP)
                            return - i - 1;
                        else
                            return i;
                    }
                    else
                    {
                        prev = i + 1;
                    }
                }
                else
                {
                    last = i;
                }
            }
        }
    }

    if (prev)
        return -1 - prev;
    else if (yPos > rc.bottom)
        // this means that we are off the bottom of the toolbar
        return(- i - 1);

    return last + 1;
}

// Same as above except:
//  - returns TRUE if the cursor is on the button edge.
//  - returns FALSE is the cursor is b/t buttons or on the button itself

BOOL TBInsertMarkHitTest(PTBSTATE ptb, int xPos, int yPos, LPTBINSERTMARK ptbim)
{
    TBINSERTMARK prev = {-1, TBIMHT_AFTER|TBIMHT_BACKGROUND}; // best guess if we hit a row
    TBINSERTMARK last = {-1, TBIMHT_AFTER|TBIMHT_BACKGROUND}; // best guess if we don't
    int i;

    // restrict hit testing depending upon whether we are vertical or horizontal
    BOOL fHorizMode = !(ptb->ci.style & CCS_VERT);

    for (i=0; i<ptb->iNumButtons; i++)
    {
        RECT rc;

        if (TB_GetItemRect(ptb, i, &rc))
        {
            if (yPos >= rc.top && yPos < rc.bottom)
            {
                if (xPos >= rc.left && xPos < rc.right)
                {
                    ptbim->iButton = i;

                    if ( fHorizMode )
                    {
                        if (xPos < rc.left + g_cxEdge*4)
                        {
                            ptbim->dwFlags = 0;
                            return TRUE;
                        }
                        else if (xPos > rc.right - g_cxEdge*4)
                        {
                            ptbim->dwFlags = TBIMHT_AFTER;
                            return TRUE;
                        }
                    }
                    else
                    {
                        // vertical....
                        if (yPos < rc.top + g_cyEdge*4)
                        {
                            ptbim->dwFlags = 0;
                            return TRUE;
                        }
                        else if (yPos > rc.bottom - g_cyEdge*4)
                        {
                            ptbim->dwFlags = TBIMHT_AFTER;
                            return TRUE;
                        }
                    }

                    // else we are just on a button...
                    ptbim->dwFlags = 0;
                    return FALSE;
                }
                else
                {
                    if (xPos < rc.left)
                    {
                        // since buttons are laid out left to right
                        // and rows are laid out top to bottom,
                        // if we ever hit this case, we can't hit anything else
                        ptbim->iButton = i;
                        ptbim->dwFlags = TBIMHT_BACKGROUND;
                        return FALSE;
                    }
                    else // (xPos > rc.right)
                    {
                        // remember the last one we've seen on this row
                        prev.iButton = i;
                    }
                }
            }
            else
            {
                if (yPos < rc.top)
                {
                    if (prev.iButton != -1)
                    {
                        *ptbim = prev;
                    }
                    else
                    {
                        ptbim->iButton = i;
                        ptbim->dwFlags = TBIMHT_BACKGROUND;
                    }
                }
                else
                {
                    // remember the last one we've seen
                    last.iButton = i;
                }
            }
        }
    }

    if (prev.iButton != -1)
        *ptbim = prev;
    else
        *ptbim = last;

    return FALSE;
}

int CountRows(PTBSTATE ptb)
{
    LPTBBUTTONDATA pButton, pBtnLast;
    int rows = 1;

    // BUGBUG (scotth): this doesn't look vertical-friendly
    // chrisny:  semantically no, technically it will work like a charm :-)

    pBtnLast = &(ptb->Buttons[ptb->iNumButtons]);
    for (pButton = ptb->Buttons; pButton<pBtnLast; pButton++) {
        if (pButton->fsState & TBSTATE_WRAP) {
            rows++;
            if (pButton->fsStyle & BTNS_SEP)
                rows++;
        }
    }

    return rows;
}

#define CountCols(ptb)  CountRows(ptb)

void WrapToolbarCol(PTBSTATE ptb, int dy, LPRECT lpRect, int *pCols)
{
    LPTBBUTTONDATA pButton, pBtnLast, pBtnPrev;
    LPTBBUTTONDATA pbtnLastVisible = NULL;
    LPTBBUTTONDATA pbtnPrev = NULL;
    int xPos, yPos;
    int dyButton;
    int yPosWrap = 0;
    int cCols = 1;

    DEBUG_CODE( int cItemsPerCol = 0; )

    ASSERT(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL);
    TraceMsg(TF_TOOLBAR, "Toolbar: calculating WrapToolbar");

    // dy must be at least the button height, otherwise the final
    // rect is mis-calculated and will be too big.
    if (dy < ptb->iButHeight)
        dy = ptb->iButHeight;

    dyButton = ptb->iButHeight;
    xPos = ptb->xFirstButton;
    yPos = ptb->iYPos;
    pBtnLast = &(ptb->Buttons[ptb->iNumButtons]);
    ptb->szCached.cx = -1;
    ptb->szCached.cy = -1;

    if (pCols)
        (*pCols) = 1;

    pBtnPrev = ptb->Buttons;

    for (pButton = ptb->Buttons; pButton < pBtnLast; pButton++)
    {
        DEBUG_CODE( cItemsPerCol++; )

        // we nuke the wrap state at the start of the loop.
        // so we don't know if/when we are adding on a wrap bit that wasn't there
        // before.  we overstep the button, then back up when we've gone too far,
        pButton->fsState &= ~TBSTATE_WRAP;
        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            if (pButton->fsStyle & BTNS_SEP)
                yPos += (TBGetSepHeight(ptb, pButton));
            else
                yPos += dyButton;
            // Is this button out of bounds?
            if (yPos > dy)
            {
                // Yes; wrap it.
                if ((pButton->fsStyle & BTNS_SEP) &&
                    yPos - TBGetSepHeight(ptb, pButton) > yPosWrap)
                {
                    yPosWrap = yPos - TBGetSepHeight(ptb, pButton); // wrap at first in next col.
                }
                else if (yPos - dyButton > yPosWrap)
                    yPosWrap = yPos - dyButton; // wrap at first in next col.

                if (xPos + ptb->iButWidth <= ptb->sizeBound.cx)
                    xPos += ptb->iButWidth;
                yPos = dyButton;
                cCols++;
                pBtnPrev->fsState |= TBSTATE_WRAP;

                DEBUG_CODE( cItemsPerCol = 0; )
            }
           // button in bounds gets handled above.
            pBtnPrev = pButton; // save previous for wrap point
        }
    }
    yPos = yPosWrap ? yPosWrap : yPos;
    if (pCols)
        *pCols = cCols;
    ptb->rc.left = 0;
    ptb->rc.right = xPos + ptb->iButWidth;
    ptb->rc.top = 0;
    ptb->rc.bottom = yPos;

    if (lpRect)
        CopyRect(lpRect, &ptb->rc);

    InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
}

/**** WrapToolbar: * The buttons in the toolbar is layed out from left to right,
 * top to bottom. If adding another button to the current row,
 * while computing the layout, would cause that button to extend
 * beyond the right edge or the client area, then locate a break-
 * point (marked with the TBSTATE_WRAP flag). A break-point is:
 *
 * a) The right-most separator on the current row.
 *
 * b) The right-most button if there is no separator on the current row.
 *
 * A new row is also started at the end of any button group (sequence
 * of buttons that are delimited by separators) that are taller than
 * or equal to two rows.
 */

void WrapToolbar(PTBSTATE ptb, int dx, LPRECT lpRect, int *pRows)
{
    BOOL fInvalidate = FALSE;
    LPTBBUTTONDATA pButton, pBtnT, pBtnLast;
    LPTBBUTTONDATA pbtnLastVisible = NULL;
    LPTBBUTTONDATA pbtnPrev = NULL;
    BOOL fLastVisibleWrapped = FALSE;
    int xPos, yPos, xMax;
    int dyButton;
    BOOL bWrapAtNextSeparator = FALSE;

    ASSERT(!(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL));
    TraceMsg(TF_TOOLBAR, "Toolbar: calculating WrapToolbar");

    if (ptb->iNumButtons == 0) {
        // no buttons, so we're not going to go through the loop below; initialize 
        // dyButton to 0 so that we fill in lpRect with 0 height.  this fixes ideal 
        // size calculation for empty toolbars (NT5 #180430)
        dyButton = 0;
    } else {
        if (dx < ptb->iButWidth) {
            // dx must be at least the button width, otherwise the final
            // rect is mis-calculated and will be too big.
            dx = ptb->iButWidth;
        }
        dyButton = ptb->iButHeight;
    }

    xMax = 0;
    xPos = ptb->xFirstButton;
    yPos = ptb->iYPos;
    pBtnLast = &(ptb->Buttons[ptb->iNumButtons]);
    ptb->szCached.cx = -1;
    ptb->szCached.cy = -1;

    if (pRows)
        (*pRows)=1;

    for (pButton = ptb->Buttons; pButton < pBtnLast; pButton++)
    {
        // we nuke the wrap state at the start of the loop.
        // so we don't know if/when we are adding on a wrap bit that wasn't there
        // before.  we overstep the button, then back up when we've gone too far,
        // so we can't simply keep the at the start of the loop
        // we need to keep it over to the next iteration
        BOOL fNextLastVisibleWrapped = (pButton->fsState & TBSTATE_WRAP);
        LPTBBUTTONDATA pbtnSav = pButton;

        pButton->fsState &= ~TBSTATE_WRAP;

        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            LPTBBUTTONDATA pbtnNextLastVisible = pButton;

            xPos += TBWidthOfButton(ptb, pButton, NULL) - s_dxOverlap;

            // Is this a normal button and is the button out of bounds?
            if (!(pButton->fsStyle & BTNS_SEP) && (xPos > dx)) {

                // Yes; wrap it.  Go back to the first non-hidden separator
                // as a break-point candidate.
                for (pBtnT=pButton;
                     pBtnT>ptb->Buttons && !(pBtnT->fsState & TBSTATE_WRAP);
                     pBtnT--)
                {
                    if ((pBtnT->fsStyle & BTNS_SEP) &&
                        !(pBtnT->fsState & TBSTATE_HIDDEN))
                    {
                        yPos += (TBGetSepHeight(ptb, pBtnT)) + dyButton;
                        bWrapAtNextSeparator = FALSE;
                        if (pRows)
                            (*pRows)++;

                        goto SetWrapHere;
                    }
                }

                pBtnT = pButton;

                // Are we at the first button?
                if (pButton != ptb->Buttons) {
                    // No; back up to first non-hidden button
                    do {
                        pBtnT--;
                    } while ((pBtnT>ptb->Buttons) &&
                             (pBtnT->fsState & TBSTATE_HIDDEN));

                    // Is it already wrapped?
                    if (pBtnT->fsState & TBSTATE_WRAP)
                    {
                        // Yes; wrap the button we were looking at originally
                        pBtnT = pButton;
                    }
                }

                // Wrap at the next separator because we've now wrapped in the middle
                // of a group of buttons.
                bWrapAtNextSeparator = TRUE;
                yPos += dyButton;

SetWrapHere:
                pBtnT->fsState |= TBSTATE_WRAP;

                // find out if this wrap bit is new...
                // it isn't if this button was the last visible button
                // and that last visible button started off wrapped
                if (pBtnT != pbtnLastVisible || !fLastVisibleWrapped)
                    fInvalidate = TRUE;

                xPos = ptb->xFirstButton;
                pButton = pBtnT;

                // Count another row.
                if (pRows)
                    (*pRows)++;
            }
            else
            {
                // No; this is a separator (in or out of bounds) or a button that is in-bounds.

                if (pButton->fsStyle & BTNS_SEP)
                {
                    if (ptb->ci.style & CCS_VERT)
                    {
                        if (pbtnPrev && !(pbtnPrev->fsState & TBSTATE_WRAP))
                        {
                            pbtnPrev->fsState |= TBSTATE_WRAP;
                            yPos += dyButton;
                        }
                        xPos = ptb->xFirstButton;
                        yPos += TBGetSepHeight(ptb, pButton);
                        pButton->fsState |= TBSTATE_WRAP;
                        if (pRows)
                            (*pRows)++;
                    }
                    else if (bWrapAtNextSeparator)
                    {
                        bWrapAtNextSeparator = FALSE;
                        pButton->fsState |= TBSTATE_WRAP;
                        xPos = ptb->xFirstButton;
                        yPos += dyButton + (TBGetSepHeight(ptb, pButton));
                        if (pRows)
                            (*pRows)+=2;
                    }
                }

                // This button is visible and it's one we cached at the top of the loop
                // set it for the next loop
                if (pButton == pbtnNextLastVisible) {
                    ASSERT(!(pButton->fsState & TBSTATE_HIDDEN));
                    if (!(pButton->fsState & TBSTATE_HIDDEN)) {

                        // we don't know that we're not going to re-wrap an item that was initially wrapped
                        // until this point
                        if (pbtnLastVisible && fLastVisibleWrapped && !(pbtnLastVisible->fsState & TBSTATE_WRAP))
                            fInvalidate = TRUE;

                        pbtnLastVisible = pButton;
                        fLastVisibleWrapped = fNextLastVisibleWrapped;
                    }
                }
            }
            if (!(pButton->fsStyle&BTNS_SEP))
                xMax = max(xPos, xMax);

            pbtnPrev = pbtnSav;
        }
    }

    if (lpRect)
    {
        lpRect->left = 0;
        lpRect->right = xMax;
        lpRect->top = 0;
        lpRect->bottom = yPos + ptb->iYPos + dyButton;
    }

    if (fInvalidate)
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
}


// only called from TB_SETROWS so no worry's about TBSTYLE_EX_MULTICOLUMN
BOOL BoxIt(PTBSTATE ptb, int height, BOOL fLarger, LPRECT lpRect)
{
    int dx, bwidth;
    int rows, prevRows, prevWidth;
    RECT rcCur;

    if (height<1)
        height = 1;

    rows = CountRows(ptb);
    if (height==rows || ptb->iNumButtons==0)
    {
        GetClientRect(ptb->ci.hwnd, lpRect);
        return FALSE;
    }

    bwidth = ptb->iButWidth-s_dxOverlap;
    prevRows = ptb->iNumButtons+1;
    prevWidth = bwidth;
    for (rows=height+1, dx = bwidth; rows>height;dx+=bwidth/4)
    {
        WrapToolbar(ptb, dx, &rcCur, &rows);
        if (rows<prevRows && rows>height)
        {
            prevWidth = dx;
            prevRows = rows;
        }
    }

    if (rows<height && fLarger)
    {
        WrapToolbar(ptb, prevWidth, &rcCur, NULL);
    }

    if (lpRect)
        *lpRect = rcCur;

    return TRUE;
}


int PositionFromID(PTBSTATE ptb, LONG_PTR id)
{
    int i;

    // Handle case where this is sent at the wrong time..
    if (ptb == NULL || id == -1)
        return -1;

    // note, we don't skip separators, so you better not have conflicting
    // cmd ids and separator ids.
    for (i = 0; i < ptb->iNumButtons; i++)
        if (ptb->Buttons[i].idCommand == id)
            return i;       // position found

    return -1;      // ID not found!
}

// check a radio button by button index.
// the button matching idCommand was just pressed down.  this forces
// up all other buttons in the group.
// this does not work with buttons that are forced up with

void MakeGroupConsistant(PTBSTATE ptb, int idCommand)
{
    int i, iFirst, iLast, iButton;
    int cButtons = ptb->iNumButtons;
    LPTBBUTTONDATA pAllButtons = ptb->Buttons;

    iButton = PositionFromID(ptb, idCommand);

    if (iButton < 0)
        return;

    // assertion

//    if (!(pAllButtons[iButton].fsStyle & BTNS_CHECK))
//  return;

    // did the pressed button just go down?
    if (!(pAllButtons[iButton].fsState & TBSTATE_CHECKED))
        return;         // no, can't do anything

    // find the limits of this radio group

    // there was a bug here since win95 days -- ; there was no ; at the end of for loop
    // and if was part of it -- some apps may rely on that (reljai 6/16/98)
    for (iFirst = iButton; (iFirst > 0) && (pAllButtons[iFirst].fsStyle & BTNS_GROUP); iFirst--);
    
    if (!(pAllButtons[iFirst].fsStyle & BTNS_GROUP))
        iFirst++;

    cButtons--;
    for (iLast = iButton; (iLast < cButtons) && (pAllButtons[iLast].fsStyle & BTNS_GROUP); iLast++);

    if (!(pAllButtons[iLast].fsStyle & BTNS_GROUP))
        iLast--;

    // search for the currently down button and pop it up
    for (i = iFirst; i <= iLast; i++) {
        if (i != iButton) {
            // is this button down?
            if (pAllButtons[i].fsState & TBSTATE_CHECKED) {
                pAllButtons[i].fsState &= ~TBSTATE_CHECKED;     // pop it up
                TBInvalidateButton(ptb, i, TRUE);
                break;          // only one button is down right?
            }
        }
    }
}

void DestroyStrings(PTBSTATE ptb)
{
    PTSTR *p;
    PTSTR end = 0, start = 0;
    int i;

    p = ptb->pStrings;
    for (i = 0; i < ptb->nStrings; i++) {
        if (!((*p < end) && (*p > start))) {
            start = (*p);
            end = start + (LocalSize((HANDLE)*p) / sizeof(TCHAR));
            LocalFree((HANDLE)*p);
        }
    p++;
    }

    LocalFree((HANDLE)ptb->pStrings);
}

// gets the iString from pStrings and copies it to pszText.
// returns the lstrlen.
// pszText can be null to just fetch the length.
int TBGetString(PTBSTATE ptb, int iString, int cchText, LPTSTR pszText)
{
    int iRet = -1;
    if (iString < ptb->nStrings)
    {
        iRet = lstrlen(ptb->pStrings[iString]);
        if (pszText)
        {
            StringCchCopy(pszText, cchText, ptb->pStrings[iString]);
        }
    }

    return iRet;
}

// gets the iString from pStrings and copies it to pszText.
// returns the lstrlen.
// pszText can be null to just fetch the length.
int TBGetStringA(PTBSTATE ptb, int iString, int cchText, LPSTR pszText)
{
    int iRet = -1;
    if (iString < ptb->nStrings)
    {
        iRet = lstrlenW(ptb->pStrings[iString]);
        if (pszText)
        {
            WideCharToMultiByte (CP_ACP, 0, ptb->pStrings[iString],
                                 -1, pszText, cchText, NULL, NULL);
        }
    }

    return iRet;
}

#define MAXSTRINGSIZE 1024
int TBAddStrings(PTBSTATE ptb, WPARAM wParam, LPARAM lParam)
{
    int i = 0,j = 0, cxMax = 0;
    LPTSTR lpsz;
    PTSTR  pString, pStringAlloc, psz;
    int numstr;
    PTSTR *pFoo;
    PTSTR *pOffset;
    TCHAR cSeparator;
    int len;

    // read the string as a resource
    if (wParam != 0) {
        pString = (PTSTR)LocalAlloc(LPTR, (MAXSTRINGSIZE * sizeof (TCHAR)));
        if (!pString)
            return -1;
        i = LoadString((HINSTANCE)wParam, LOWORD(lParam), (LPTSTR)pString, MAXSTRINGSIZE);
        if (!i) {
            LocalFree(pString);
            return -1;
        }
        // realloc string buffer to actual needed size
        psz = LocalReAlloc(pString, (i+1) * sizeof (TCHAR), LMEM_MOVEABLE);
        if (psz)
            pString = psz;

        // convert separators to '\0' and count number of strings
        cSeparator = *pString;
        for (numstr = 0, psz = pString + 1, i--; i; i--, psz++) {
            if (*psz == cSeparator) {
                if (i != 1)     // We don't want to count the second terminator as another string
                    numstr++;

                *psz = 0;   // terminate with 0
            }
            // shift string to the left to overwrite separator identifier
            *(psz - 1) = *psz;
        }
    }
    // read explicit string.  copy it into local memory, too.
    else {

        // Common mistake is to forget to check the return value of
        // LoadLibrary and accidentally pass wParam=NULL.
        if (IS_INTRESOURCE(lParam))
            return -1;

        // find total length and number of strings
        for (i = 0, numstr = 0, lpsz = (LPTSTR)lParam;;) {
            i++;
            if (*lpsz == 0) {
                numstr++;
                if (*(lpsz + 1) == 0)
                    break;
            }
            lpsz++;
        }

        pString = (PTSTR)LocalAlloc(LPTR, (i * sizeof (TCHAR)));
        if (!pString)
            return -1;
        hmemcpy(pString, (void *)lParam, i * sizeof(TCHAR));
    }

    pStringAlloc = pString;         // in case something bad happens

    // make room for increased string pointer table
    pFoo = (PTSTR *)CCLocalReAlloc(ptb->pStrings,
            (ptb->nStrings + numstr) * sizeof(PTSTR));
    if (!pFoo) {
        goto Failure;
    }

    ptb->pStrings = pFoo;
    // pointer to next open slot in string index table.
    pOffset = ptb->pStrings + ptb->nStrings;

    for (i = 0; i < numstr; i++, pOffset++)
    {
        *pOffset = pString;
        len = lstrlen(pString);
        pString += len + 1;
    }
    // is the world big enough to handle the larger buttons?
    i = ptb->nStrings;
    ptb->nStrings += numstr;
    if (!TBRecalc(ptb))
    {
        ptb->nStrings -= numstr;
        // back out changes.
        pFoo = (PTSTR *)CCLocalReAlloc(ptb->pStrings,
                    ptb->nStrings * sizeof(PTSTR));
        if (pFoo)
            ptb->pStrings = pFoo;
         // don't get mad if pFoo == NULL; it means the shrink failed, no big deal

Failure:
        LocalFree(pStringAlloc);
        return -1;
    }

    return i;               // index of first added string
}

void MapToStandardBitmaps(HINSTANCE *phinst, UINT_PTR *pidBM, int *pnButtons)
{
    if (*phinst == HINST_COMMCTRL) {
        *phinst = g_hinst;

        // low 2 bits are coded M(mono == ~color) L(large == ~small)
        //  0 0   -> color small
        //  0 1   -> color large
        //  ...
        //  1 1   -> mono  large

        switch (*pidBM)
        {
        case IDB_STD_SMALL_COLOR:
        case IDB_STD_LARGE_COLOR:
        case IDB_STD_SMALL_MONO:
        case IDB_STD_LARGE_MONO:
            *pidBM = IDB_STDTB_SMALL_COLOR + (*pidBM & 1);
            *pnButtons = STD_PRINT + 1;
            break;

        case IDB_HIST_SMALL_COLOR:
        case IDB_HIST_LARGE_COLOR:
        //case IDB_HIST_SMALL_MONO:
        //case IDB_HIST_LARGE_MONO:
            *pidBM = IDB_HISTTB_SMALL_COLOR + (*pidBM & 1);
            *pnButtons = HIST_LAST + 1;
            break;

        case IDB_VIEW_SMALL_COLOR:
        case IDB_VIEW_LARGE_COLOR:
        case IDB_VIEW_SMALL_MONO:
        case IDB_VIEW_LARGE_MONO:
            *pidBM = IDB_VIEWTB_SMALL_COLOR + (*pidBM & 1);
            *pnButtons = VIEW_NEWFOLDER + 1;
            break;
        }
    }
}

//
//  the PBITMAP points to the BITMAP structure that was GetObject'd from
//  the hbm, except that pbm->bmWidth and pbm->bmHeight have been adjusted
//  to represent the *desired* height and width, not the actual height
//  and width.
//
HBITMAP _CopyBitmap(PTBSTATE ptb, HBITMAP hbm, PBITMAP pbm)
{
    HBITMAP hbmCopy = NULL;
    HDC hdcWin;
    HDC hdcSrc, hdcDest;

    // Old code called CreateColorBitmap, which is bad on multimon systems
    // because it will create a bitmap that ImageList_AddMasked can't handle,
    // resulting in disabled toolbar buttons looking bad.

    // so we have to create the bitmap copy in the same format as the source

    hdcWin = GetDC(ptb->ci.hwnd);
    hdcSrc = CreateCompatibleDC(hdcWin);
    hdcDest = CreateCompatibleDC(hdcWin);
    if (hdcWin && hdcSrc && hdcDest) {

        SelectObject(hdcSrc, hbm);

        if (pbm->bmBits) {
            // Source was a DIB section.  Create a DIB section in the same
            // color format with the same palette.
            //
            // Man, creating a DIB section is so annoying.

            struct
            {
                // Our private version of BITMAPINFO
                BITMAPINFOHEADER bmiHeader;
                RGBQUAD bmiColors[256];
            } bmi;
            UINT cBitsPixel;
            LPVOID pvDummy;

            ZeroMemory(&bmi.bmiHeader, SIZEOF(bmi.bmiHeader));

            bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
            bmi.bmiHeader.biWidth = pbm->bmWidth;
            bmi.bmiHeader.biHeight = pbm->bmHeight;
            bmi.bmiHeader.biPlanes = 1;

            // DIB color depths must be exactly 1, 4, 8 or 24.
            cBitsPixel = pbm->bmPlanes * pbm->bmBitsPixel;
            if (cBitsPixel <= 1)
                bmi.bmiHeader.biBitCount = 1;
            else if (cBitsPixel <= 4)
                bmi.bmiHeader.biBitCount = 4;
            else if (cBitsPixel <= 8)
                bmi.bmiHeader.biBitCount = 8;
            else
                goto CreateDDB; // ImageList_AddMasked doesn't like DIBs deeper than 8bpp

            // And get the color table too
            ASSERT(bmi.bmiHeader.biBitCount <= 8);
            bmi.bmiHeader.biClrUsed = GetDIBColorTable(hdcSrc, 0, 1 << bmi.bmiHeader.biBitCount, bmi.bmiColors);

            ASSERT(bmi.bmiHeader.biCompression == BI_RGB);
            ASSERT(bmi.bmiHeader.biSizeImage == 0);

            hbmCopy = CreateDIBSection(hdcWin, (LPBITMAPINFO)&bmi, DIB_RGB_COLORS, &pvDummy, NULL, 0);

        } else {
            // Source was a DDB.  Create a duplicate DDB.
        CreateDDB:
            // Since the caller may have dorked the bmWidth,
            // we have to recompute the bmWidthBytes, because GDI
            // gets mad if it's not exactly right, even in the bmBits == NULL
            // case.
            pbm->bmBits = NULL;
            pbm->bmWidthBytes = ((pbm->bmBitsPixel * pbm->bmWidth + 15) >> 4) << 1;
            hbmCopy = CreateBitmapIndirect(pbm);

        }

        SelectObject(hdcDest, hbmCopy);

        // fill the background
        PatB(hdcDest, 0, 0, pbm->bmWidth, pbm->bmHeight, g_clrBtnFace);

        BitBlt(hdcDest, 0, 0, pbm->bmWidth, pbm->bmHeight,
               hdcSrc, 0, 0, SRCCOPY);

    }

    if (hdcWin)
        ReleaseDC(ptb->ci.hwnd, hdcWin);

    if (hdcSrc)
        DeleteDC(hdcSrc);
    if (hdcDest)
        DeleteDC(hdcDest);
    return hbmCopy;
}

BOOL TBAddBitmapToImageList(PTBSTATE ptb, PTBBMINFO pTemp)
{
    HBITMAP hbm = NULL, hbmTemp = NULL;
    HIMAGELIST himl = TBGetImageList(ptb, HIML_NORMAL, 0);
    if (!himl) {
        himl = ImageList_Create(ptb->iDxBitmap, ptb->iDyBitmap, ILC_MASK | ILC_COLORDDB, 4, 4);
        if (!himl)
            return(FALSE);
        TBSetImageList(ptb, HIML_NORMAL, 0, himl);
        ImageList_SetBkColor(himl, (ptb->ci.style & TBSTYLE_TRANSPARENT) ? CLR_NONE : g_clrBtnFace);
    }

    if (pTemp->hInst) {
        // can't use LoadImage(..., LR_MAP3DCOLORS) - more than 3 colors
        hbm = hbmTemp = CreateMappedBitmap(pTemp->hInst, pTemp->wID, CMB_DIBSECTION, NULL, 0);

    } else if (pTemp->wID) {
        hbm = (HBITMAP)pTemp->wID;
    }

    if (hbm) {

        //
        // Fix up bitmaps that aren't iDxBitmap x iDyBitmap
        //

        BITMAP bm;

        GetObject( hbm, sizeof(bm), &bm);

        if (bm.bmWidth < ptb->iDxBitmap) {
            bm.bmWidth = ptb->iDxBitmap;
        }

        if (bm.bmHeight < ptb->iDyBitmap) {
            bm.bmHeight = ptb->iDyBitmap;
        }

        // The error cases we are catching are:
        // If the pTemp->nButtons is 0 then we assume there is one button
        // If width of the bitmap is less than what it is supposed to be, we fix it.
        if (!pTemp->nButtons)
            bm.bmWidth = ptb->iDxBitmap;
        else if (pTemp->nButtons > (bm.bmWidth / ptb->iDxBitmap))
            bm.bmWidth = ptb->iDxBitmap * pTemp->nButtons;

        // Must preserve color depth to keep ImageList_AddMasked happy
        // And if we started with a DIB section, then create a DIB section.
        // (Curiously, CopyImage does not preserve DIB-ness.)
        hbm = (HBITMAP)_CopyBitmap(ptb, hbm, &bm);

    }

    // AddMasked parties on the bitmap, so we want to use a local copy
    if (hbm) {
        ImageList_AddMasked(himl, hbm, g_clrBtnFace);

        DeleteObject(hbm);
    }

    if (hbmTemp) {
        DeleteObject(hbmTemp);
    }

    return(TRUE);

}

void TBBuildImageList(PTBSTATE ptb)
{
    int i;
    PTBBMINFO pTemp;
    HIMAGELIST himl;

    ptb->fHimlValid = TRUE;

    // is the parent dealing natively with imagelists?  if so,
    // don't do this back compat building
    if (ptb->fHimlNative)
        return;

    himl = TBSetImageList(ptb, HIML_NORMAL, 0, NULL);
    ImageList_Destroy(himl);

    for (i = 0, pTemp = ptb->pBitmaps; i < ptb->nBitmaps; i++, pTemp++) {

        TBAddBitmapToImageList(ptb, pTemp);
    }

}

/* Adds a new bitmap to the list of BMs available for this toolbar.
 * Returns the index of the first button in the bitmap or -1 if there
 * was an error.
 */
int AddBitmap(PTBSTATE ptb, int nButtons, HINSTANCE hBMInst, UINT_PTR idBM)
{
    PTBBMINFO pTemp;
    int nBM, nIndex;

    // map things to the standard toolbar images
    if (hBMInst == HINST_COMMCTRL)        // -1
    {
        // set the proper dimensions...
        if (idBM & 1)
            SetBitmapSize(ptb, LARGE_DXYBITMAP, LARGE_DXYBITMAP);
        else
            SetBitmapSize(ptb, SMALL_DXYBITMAP, SMALL_DXYBITMAP);

        MapToStandardBitmaps(&hBMInst, &idBM, &nButtons);
    }

    if (ptb->pBitmaps)
    {
      /* Check if the bitmap has already been added
       */
        for (nBM=ptb->nBitmaps, pTemp=ptb->pBitmaps, nIndex=0;
            nBM>0; --nBM, ++pTemp)
        {
            if (pTemp->hInst==hBMInst && pTemp->wID==idBM)
            {
                /* We already have this bitmap, but have we "registered" all
                 * the buttons in it?
                 */
                if (pTemp->nButtons >= nButtons)
                    return(nIndex);
                if (nBM == 1)
                {
                /* If this is the last bitmap, we can easily increase the
                 * number of buttons without messing anything up.
                 */
                    pTemp->nButtons = nButtons;
                    return(nIndex);
                }
            }

            nIndex += pTemp->nButtons;
        }

    }

    pTemp = (PTBBMINFO)CCLocalReAlloc(ptb->pBitmaps,
            (ptb->nBitmaps + 1)*sizeof(TBBMINFO));
    if (!pTemp)
        return(-1);
    ptb->pBitmaps = pTemp;

    pTemp = ptb->pBitmaps + ptb->nBitmaps;

    pTemp->hInst = hBMInst;
    pTemp->wID = idBM;
    pTemp->nButtons = nButtons;

    if (!TBAddBitmapToImageList(ptb, pTemp))
        return(-1);

    ++ptb->nBitmaps;

    for (nButtons=0, --pTemp; pTemp>=ptb->pBitmaps; --pTemp)
        nButtons += pTemp->nButtons;


    return(nButtons);
}

/* Adds a bitmap to the list of  BMs available for this
 * toolbar. Returns the index of the first button in the bitmap or -1 if there
 * was an error.
 */

int PASCAL TBLoadImages(PTBSTATE ptb, UINT_PTR id, HINSTANCE hinst)
{
    int iTemp;
    TBBMINFO bmi;
    HIMAGELIST himl;

    MapToStandardBitmaps(&hinst, &id, &iTemp);

    bmi.hInst = hinst;
    bmi.wID = id;
    bmi.nButtons = iTemp;

    himl = TBGetImageList(ptb, HIML_NORMAL, 0);
    if (himl)
        iTemp = ImageList_GetImageCount(himl);
    else
        iTemp = 0;

    if (!TBAddBitmapToImageList(ptb, &bmi))
        return(-1);

    ptb->fHimlNative = TRUE;
    return iTemp;
}

BOOL ReplaceBitmap(PTBSTATE ptb, LPTBREPLACEBITMAP lprb)
{
    int nBM;
    PTBBMINFO pTemp;

    int iTemp;

    MapToStandardBitmaps(&lprb->hInstOld, &lprb->nIDOld, &iTemp);
    MapToStandardBitmaps(&lprb->hInstNew, &lprb->nIDNew, &lprb->nButtons);

    for (nBM=ptb->nBitmaps, pTemp=ptb->pBitmaps;
         nBM>0; --nBM, ++pTemp)
    {
        if (pTemp->hInst==lprb->hInstOld && pTemp->wID==lprb->nIDOld)
        {
            // number of buttons must match
            pTemp->hInst = lprb->hInstNew;
            pTemp->wID = lprb->nIDNew;
            pTemp->nButtons = lprb->nButtons;
            TBInvalidateImageList(ptb);
            return TRUE;
        }
    }

    return FALSE;
}


void TBInvalidateItemRects(PTBSTATE ptb)
{
    // Invalidate item rect cache
    ptb->fItemRectsValid = FALSE;

    // Invalidate the tooltips
    ptb->fTTNeedsFlush = TRUE;

    // Invalidate the ideal size cache
    ptb->szCached.cx = -1;
    ptb->szCached.cy = -1;
}

void FlushToolTipsMgrNow(PTBSTATE ptb) {

    // change all the rects for the tool tips mgr.  this is
    // cheap, and we don't do it often, so go ahead
    // and do them all.
    if(ptb->hwndToolTips) {
        UINT i;
        TOOLINFO ti;
        LPTBBUTTONDATA pButton;

        ti.cbSize = SIZEOF(ti);
        ti.hwnd = ptb->ci.hwnd;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        for ( i = 0, pButton = ptb->Buttons;
             i < (UINT)ptb->iNumButtons;
             i++, pButton++) {

            if (!(pButton->fsStyle & BTNS_SEP)) {
                ti.uId = pButton->idCommand;

                if (!TB_GetItemRect(ptb, i, &ti.rect) ||
                   ((ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS) && TBIsRectClipped(ptb, &ti.rect))) {

                    ti.rect.left = ti.rect.right = ti.rect.top = ti.rect.bottom = 0;
                }

                SendMessage(ptb->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
            }
        }

        ptb->fTTNeedsFlush = FALSE;
    }
}

BOOL TBReallocButtons(PTBSTATE ptb, UINT uButtons)
{
    LPTBBUTTONDATA ptbbNew;
    LPTBBUTTONDATA pOldCaptureButton;

    if (!ptb || !ptb->uStructSize)
        return FALSE;

    // When we realloc the Button array, make sure all interior pointers
    //  move with it.  (This should probably be an index.)
    pOldCaptureButton = ptb->pCaptureButton;

    // realloc the button table
    ptbbNew = (LPTBBUTTONDATA)CCLocalReAlloc(ptb->Buttons,
                                             uButtons * sizeof(TBBUTTONDATA));

    if (!ptbbNew) return FALSE;

    if (pOldCaptureButton)
        ptb->pCaptureButton = (LPTBBUTTONDATA)(
                        (LPBYTE)ptbbNew +
                          ((LPBYTE)pOldCaptureButton - (LPBYTE)ptb->Buttons));
    ptb->Buttons = ptbbNew;

    return TRUE;
}

BOOL TBInsertButtons(PTBSTATE ptb, UINT uWhere, UINT uButtons, LPTBBUTTON lpButtons, BOOL fNative)
{
    LPTBBUTTONDATA pOut;
    LPTBBUTTONDATA ptbbIn;
    UINT    uAdded;
    UINT    uStart;
    BOOL fRecalc;
    int idHot = -1;

    if (!TBReallocButtons(ptb, ptb->iNumButtons + uButtons))
        return FALSE;

    // comments by chee (not the original author) so they not be
    // exactly right... be warned.

    // if where points beyond the end, set it at the end
    if (uWhere > (UINT)ptb->iNumButtons)
        uWhere = ptb->iNumButtons;

    // Need to save these since the values gues toasted.
    uAdded = uButtons;
    uStart = uWhere;

    // Correct the hot item when we add something something. Since the hot item is index based, the index
    // has probrably changed
    if (ptb->iHot >= 0 && ptb->iHot < ptb->iNumButtons)
        idHot = ptb->Buttons[ptb->iHot].idCommand;

    // move buttons above uWhere up uButton spaces
    // the uWhere gets inverted and counts to zero..
    //
    // REVIEW: couldn't this be done with MoveMemory?
    //  MoveMemory(&ptb->Buttons[uWhere], &ptb->Buttons[uWhere+uButtons], sizeof(ptb->Buttons[0])*(ptb->iNumButtons - uWhere));
    //
    for (ptbbIn = &ptb->Buttons[ptb->iNumButtons-1], pOut = ptbbIn+uButtons,
         uWhere=(UINT)ptb->iNumButtons-uWhere; uWhere>0;
     --ptbbIn, --pOut, --uWhere)
        *pOut = *ptbbIn;

    // only need to recalc if there are strings & room enough to actually show them
    fRecalc = (TBHasStrings(ptb) && ((ptb->ci.style & TBSTYLE_LIST) || ((ptb->iDyBitmap + ptb->yPad + g_cyEdge) < ptb->iButHeight)));

    // now do the copy.
    for (lpButtons=(LPTBBUTTON)((LPBYTE)lpButtons+ptb->uStructSize*(uButtons-1)),
        ptb->iNumButtons+=(int)uButtons;  // init
        uButtons>0; //test
        --pOut, lpButtons=(LPTBBUTTON)((LPBYTE)lpButtons-ptb->uStructSize), --uButtons)
    {
        TBInputStruct(ptb, pOut, lpButtons);

        // If this button is a seperator, then should not use the string
        // buffer passed in, because it could be bogus data.
        if (pOut->fsStyle & BTNS_SEP)
            pOut->iString = -1;

        if (TBISSTRINGPTR(pOut->iString)) {
            LPTSTR psz = (LPTSTR)pOut->iString;
            if (!fNative) {
                psz = ProduceWFromA(ptb->ci.uiCodePage, (LPSTR)psz);
            }
            pOut->iString = 0;
            Str_Set((LPTSTR*)&pOut->iString, psz);

            if (!fNative)
                FreeProducedString(psz);

            if (!ptb->fNoStringPool)
                fRecalc = TRUE;

            ptb->fNoStringPool = TRUE;
        }

        if(ptb->hwndToolTips && !(lpButtons->fsStyle & BTNS_SEP)) {
            TOOLINFO ti;
            // don't bother setting the rect because we'll do it below
            // in TBInvalidateItemRects;
            ti.cbSize = sizeof(ti);
            ti.uFlags = 0;
            ti.hwnd = ptb->ci.hwnd;
            ti.uId = lpButtons->idCommand;
            ti.lpszText = LPSTR_TEXTCALLBACK;
            SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                (LPARAM)(LPTOOLINFO)&ti);
        }

        if (pOut->fsStyle & BTNS_SEP && pOut->DUMMYUNION_MEMBER(cxySep) <= 0)
        {

            // Compat: Corel (Font navigator) expects the separators to be
            // 8 pixels wide.
            // as do many old apps.
            //
            // so if it's not flat or not vertical, put it to defautl to win95 size
            pOut->DUMMYUNION_MEMBER(cxySep) = g_dxButtonSep;
        }
    }

    // Re-compute layout if toolbar is wrappable.
    if ((ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN) || 
        (ptb->ci.style & TBSTYLE_WRAPABLE))
    {
        // NOTE: we used to do send ourself a message instead of call directly...
        //SendMessage(ptb->ci.hwnd, TB_AUTOSIZE, 0, 0);
        TBAutoSize(ptb);
    }

    TBInvalidateItemRects(ptb);

    // adding and removing buttons during toolbar customization shouldn't
    // result in recalcing the sizes of buttons.
    if (fRecalc && !ptb->hdlgCust)
        TBRecalc(ptb);

    //
    // Reorder notification so apps can go requery what's on the toolbar if
    // more than 1 button was added; otherwise, just say create.
    //
    if (uAdded == 1)
        MyNotifyWinEvent(EVENT_OBJECT_CREATE, ptb->ci.hwnd, OBJID_CLIENT,
            uWhere+1);
    else
        MyNotifyWinEvent(EVENT_OBJECT_REORDER, ptb->ci.hwnd, OBJID_CLIENT, 0);

    // was there a hot item before the delete?
    if (idHot != -1)
    {
        // Yes; Then update it to the current index
        ptb->iHot = PositionFromID(ptb, idHot);
    }

    TBInvalidateItemRects(ptb);

    // We need to completely redraw the toolbar at this point.
    // this MUST be done last!
    // tbrecalc and others will nuke out invalid area and we won't paint if this isn't last
    InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
    return(TRUE);
}


/* Notice that the state structure is not realloc'ed smaller at this
 * point.  This is a time optimization, and the fact that the structure
 * will not move is used in other places.
 */
BOOL DeleteButton(PTBSTATE ptb, UINT uIndex)
{
    TBNOTIFY tbn = { 0 };
    LPTBBUTTONDATA pIn, pOut;
    BOOL fRecalc;
    int idHot = -1;



    if (uIndex >= (UINT)ptb->iNumButtons)
        return FALSE;

    if (&ptb->Buttons[uIndex] == ptb->pCaptureButton) {
        if (ptb->uStructSize == 0x14)
            ptb->fRequeryCapture = TRUE;
        if (!CCReleaseCapture(&ptb->ci)) return FALSE;
        ptb->pCaptureButton = NULL;
    }

    // Correct the hot item when we remove something. Since the hot item is index based, the index
    // has probrably changed
    if (ptb->iHot >= 0 && ptb->iHot < ptb->iNumButtons)
        idHot = ptb->Buttons[ptb->iHot].idCommand;

    // Notify Active Accessibility of the delete
    MyNotifyWinEvent(EVENT_OBJECT_DESTROY, ptb->ci.hwnd, OBJID_CLIENT, uIndex+1);

    // Notify client of the delete
    tbn.iItem = ptb->Buttons[uIndex].idCommand;
    TBOutputStruct(ptb, &ptb->Buttons[uIndex], &tbn.tbButton);
    CCSendNotify(&ptb->ci, TBN_DELETINGBUTTON, &tbn.hdr);


    if (TBISSTRINGPTR(ptb->Buttons[uIndex].iString))
        Str_Set((LPTSTR*)&ptb->Buttons[uIndex].iString, NULL);

    if (ptb->hwndToolTips) {
        TOOLINFO ti;

        ti.cbSize = sizeof(ti);
        ti.hwnd = ptb->ci.hwnd;
        ti.uId = ptb->Buttons[uIndex].idCommand;
        SendMessage(ptb->hwndToolTips, TTM_DELTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
    }

    --ptb->iNumButtons;

    pOut = ptb->Buttons + uIndex;

    fRecalc = (pOut->fsState & TBSTATE_WRAP);

    for (pIn = pOut + 1; uIndex<(UINT)ptb->iNumButtons; ++uIndex, ++pIn, ++pOut)
    {
        fRecalc |= (pIn->fsState & TBSTATE_WRAP);
        *pOut = *pIn;
    }

    // We need to completely recalc or redraw the toolbar at this point.
    if (((ptb->ci.style & TBSTYLE_WRAPABLE)
            || (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)) && fRecalc)
    {
        RECT rc;
        HWND hwnd = ptb->ci.hwnd;

        if (!(ptb->ci.style & CCS_NORESIZE) && !(ptb->ci.style & CCS_NOPARENTALIGN))
            hwnd = GetParent(hwnd);

        GetWindowRect(hwnd, &rc);

        if (ptb->ci.style & TBSTYLE_WRAPABLE)
            WrapToolbar(ptb, rc.right - rc.left, &rc, NULL);
        else
            WrapToolbarCol(ptb, ptb->sizeBound.cy, &rc, NULL);
    }

    // was there a hot item before the delete?
    if (idHot != -1)
    {
        // Yes; Then update it to the current index
        ptb->iHot = PositionFromID(ptb, idHot);
    }


    InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

    TBInvalidateItemRects(ptb);

    return TRUE;
}

// move button at location iOld to location iNew, sliding everything
// after iNew UP.
BOOL PASCAL TBMoveButton(PTBSTATE ptb, UINT iOld, UINT iNew)
{
    TBBUTTONDATA tbd, *ptbdOld, *ptbdNew;

    if (iOld >= (UINT)ptb->iNumButtons)
        return FALSE;

    if (iNew > (UINT)ptb->iNumButtons-1)
        iNew = (UINT)ptb->iNumButtons-1;

    if (iOld == iNew)
        return FALSE;

    TBInvalidateItemRects(ptb);

    ptbdOld = &(ptb->Buttons[iOld]);
    ptbdNew = &(ptb->Buttons[iNew]);

    tbd = *ptbdOld;

    {
        TBBUTTONDATA *ptbdSrc;
        TBBUTTONDATA *ptbdDst;
        int iCount, iInc;

        if (iOld < iNew)
        {
            // move [iOld+1..iNew] to [iOld..iNew-1]
            iCount = iNew - iOld;
            iInc = 1;
            ptbdSrc = ptbdOld + 1;
            ptbdDst = ptbdOld;

            if (ptb->pCaptureButton > ptbdOld && ptb->pCaptureButton <= ptbdNew)
                ptb->pCaptureButton--;
        }
        else
        {
            ASSERT(iNew < iOld);

            // move [iNew..iOld-1] to [iNew+1..iOld]
            iCount = iOld - iNew;
            iInc = -1;
            ptbdSrc = ptbdNew + iCount - 1;
            ptbdDst = ptbdNew + iCount;

            if (ptb->pCaptureButton >= ptbdNew && ptb->pCaptureButton < ptbdOld)
                ptb->pCaptureButton++;
        }

        do {
            *ptbdDst = *ptbdSrc;
            ptbdDst += iInc;
            ptbdSrc += iInc;
            iCount--;
        } while (iCount);
    }

    *ptbdNew = tbd;

    if (ptb->pCaptureButton == ptbdOld)
        ptb->pCaptureButton = ptbdNew;

    TBAutoSize(ptb);
    InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

    return TRUE;
}


// deal with old TBBUTON structs for compatibility
void TBInputStruct(PTBSTATE ptb, LPTBBUTTONDATA pButtonInt, LPTBBUTTON pButtonExt)
{
    pButtonInt->DUMMYUNION_MEMBER(iBitmap) = pButtonExt->iBitmap;
    pButtonInt->idCommand = pButtonExt->idCommand;
    pButtonInt->fsState = pButtonExt->fsState;
    pButtonInt->fsStyle = pButtonExt->fsStyle;
    pButtonInt->cx = 0;

    if (ptb->uStructSize >= sizeof(TBBUTTON))
    {
        pButtonInt->dwData = pButtonExt->dwData;
        pButtonInt->iString = pButtonExt->iString;
    }
    else
    {
        /* It is assumed the only other possibility is the OLDBUTTON struct */
        /* We don't care about dwData */
        pButtonInt->dwData = 0;
        pButtonInt->iString = -1;
    }
}


void TBOutputStruct(PTBSTATE ptb, LPTBBUTTONDATA pButtonInt, LPTBBUTTON pButtonExt)
{
    ZeroMemory(pButtonExt, ptb->uStructSize);
    pButtonExt->iBitmap = pButtonInt->DUMMYUNION_MEMBER(iBitmap);
    pButtonExt->idCommand = pButtonInt->idCommand;
    pButtonExt->fsState = pButtonInt->fsState;
    pButtonExt->fsStyle = pButtonInt->fsStyle;

    // We're returning cx in the bReserved field
    COMPILETIME_ASSERT(FIELD_OFFSET(TBBUTTONDATA, cx) == FIELD_OFFSET(TBBUTTON, bReserved));
    COMPILETIME_ASSERT(sizeof(pButtonInt->cx) <= sizeof(pButtonExt->bReserved));
    ((LPTBBUTTONDATA)pButtonExt)->cx = pButtonInt->cx;

    if (ptb->uStructSize >= sizeof(TBBUTTON))
    {
        pButtonExt->dwData = pButtonInt->dwData;
        pButtonExt->iString = pButtonInt->iString;
    }
}

void TBOnButtonStructSize(PTBSTATE ptb, UINT uStructSize)
{
    /* You are not allowed to change this after adding buttons.
    */
    if (ptb && !ptb->iNumButtons)
    {
        ptb->uStructSize = uStructSize;
    }
}

void TBAutoSize(PTBSTATE ptb)
{
    HWND hwndParent;
    RECT rc;
    int nTBThickness = 0;

    if (ptb->fRedrawOff) {
        // redraw is off; defer autosize until redraw is turned back on
        ptb->fRecalc = TRUE;
        return;
    }

    if (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
    {
        ASSERT(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL);
        nTBThickness = ptb->iButWidth * CountCols(ptb) + g_cyEdge * 2;
    }
    else
        nTBThickness = ptb->iButHeight * CountRows(ptb) + g_cxEdge * 2;

    hwndParent = GetParent(ptb->ci.hwnd);
    if (!hwndParent)
        return;

    if ((ptb->ci.style & TBSTYLE_WRAPABLE)
                    || (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN))
    {
        RECT rcNew;

        if ((ptb->ci.style & CCS_NORESIZE) || (ptb->ci.style & CCS_NOPARENTALIGN))
            GetWindowRect(ptb->ci.hwnd, &rc);
        else
            GetWindowRect(hwndParent, &rc);

        if (ptb->ci.style & TBSTYLE_WRAPABLE)
            WrapToolbar(ptb, rc.right - rc.left, &rcNew, NULL);
        else
            WrapToolbarCol(ptb, ptb->sizeBound.cy, &rcNew, NULL);

        // Some sample app found a bug in our autosize code which this line
        // fixes. Unfortunately Carbon Copy 32 (IE4 bug 31943) relies on the
        // broken behavior and fixing this clips the buttons.
        //
        //nTBThickness = rcNew.bottom - rcNew.top + g_cxEdge;
    }

    if ((ptb->ci.style & TBSTYLE_WRAPABLE) ||
        (ptb->dwStyleEx & (TBSTYLE_EX_MULTICOLUMN | TBSTYLE_EX_HIDECLIPPEDBUTTONS)))
    {
        TBInvalidateItemRects(ptb);
    }

    GetWindowRect(ptb->ci.hwnd, &rc);
    MapWindowPoints(HWND_DESKTOP, hwndParent, (LPPOINT)&rc, 2);
    NewSize(ptb->ci.hwnd, nTBThickness, ptb->ci.style,
            rc.left, rc.top, rc.right, rc.bottom);
}

void TBSetStyle(PTBSTATE ptb, DWORD dwStyle)
{
    BOOL fSizeChanged = FALSE;

    if ((BOOL)(ptb->ci.style & TBSTYLE_WRAPABLE) != (BOOL)(dwStyle & TBSTYLE_WRAPABLE))
    {
        int i;
        fSizeChanged = TRUE;

        for (i=0; i<ptb->iNumButtons; i++)
            ptb->Buttons[i].fsState &= ~TBSTATE_WRAP;
    }

    ptb->ci.style = dwStyle;

    if (fSizeChanged)
        TBRecalc(ptb);

    TBAutoSize(ptb);

    TraceMsg(TF_TOOLBAR, "toolbar window style changed %x", ptb->ci.style);
}

void TBSetStyleEx(PTBSTATE ptb, DWORD dwStyleEx, DWORD dwStyleMaskEx)
{
    BOOL fSizeChanged = FALSE;

    if (dwStyleMaskEx)
        dwStyleEx = (ptb->dwStyleEx & ~dwStyleMaskEx) | (dwStyleEx & dwStyleMaskEx);

    // Second, we can validate a few of the bits:
    // Multicolumn should never be set w/o the vertical style...
    ASSERT((ptb->dwStyleEx & TBSTYLE_EX_VERTICAL) || !(ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN));
    // also can't be set with hide clipped buttons style (for now)
    ASSERT(!(ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS) || !(ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN));
    // ...but just in case someone gets it wrong, we'll set the vertical
    // style and rip off the hide clipped buttons style
    if (dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
    {
        dwStyleEx |= TBSTYLE_EX_VERTICAL;
        dwStyleEx &= ~TBSTYLE_EX_HIDECLIPPEDBUTTONS;
    }

    // Then, some things need to be tweaked when they change
    if ((ptb->dwStyleEx ^ dwStyleEx) & TBSTYLE_EX_MULTICOLUMN)
    {
        int i;
        // Clear all the wrap states if we're changing multicolumn styles
        for (i = 0; i < ptb->iNumButtons; i++)
            ptb->Buttons[i].fsState &= ~TBSTATE_WRAP;

        fSizeChanged = TRUE;
    }
    if ((ptb->dwStyleEx ^ dwStyleEx) & TBSTYLE_EX_MIXEDBUTTONS)
    {
        int i;
        for (i = 0; i < ptb->iNumButtons; i++)
            (ptb->Buttons[i]).cx = 0;

        fSizeChanged = TRUE;
        
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
    }
    if ((ptb->dwStyleEx ^ dwStyleEx) & TBSTYLE_EX_HIDECLIPPEDBUTTONS)
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

    ptb->dwStyleEx = dwStyleEx;

    if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
        TBSetStyle(ptb, CCS_VERT);      // vertical sep and insert mark orientation

    if (fSizeChanged)
    {
        TBRecalc(ptb);
        TBAutoSize(ptb);
    }

    TraceMsg(TF_TOOLBAR, "toolbar window extended style changed %x", ptb->dwStyleEx);
}


LRESULT TB_OnSetImage(PTBSTATE ptb, LPTBBUTTONDATA ptbButton, int iImage)
{
    if (!ptb->fHimlNative) {
        if (ptb->fHimlValid) {
            if (!TBGetImageList(ptb, HIML_NORMAL, 0) ||
                iImage >= ImageList_GetImageCount(TBGetImageList(ptb, HIML_NORMAL, 0)))
                return FALSE;
        } else {

            PTBBMINFO pTemp;
            int nBitmap;
            UINT nTot;

            // we're not natively himl and we've got some invalid
            // image state, so we need to count the bitmaps ourselvesa
            pTemp = ptb->pBitmaps;
            nTot = 0;

            for (nBitmap=0; nBitmap < ptb->nBitmaps; nBitmap++) {
                nTot += pTemp->nButtons;
                pTemp++;
            }

            if (iImage >= (int)nTot)
                return FALSE;
        }
    }

    ptbButton->DUMMYUNION_MEMBER(iBitmap) = iImage;

    InvalidateButton(ptb, ptbButton, FALSE);
    UpdateWindow(ptb->ci.hwnd);
    return TRUE;
}

void TB_OnDestroy(PTBSTATE ptb)
{
    HWND hwnd = ptb->ci.hwnd;
    int i;

    for (i = 0; i < ptb->iNumButtons; i++) {
        if (TBISSTRINGPTR(ptb->Buttons[i].iString))
            Str_Set((LPTSTR*)&ptb->Buttons[i].iString, NULL);
    }

    //
    // If the toolbar created tooltips, then destroy them.
    //
    if ((ptb->ci.style & TBSTYLE_TOOLTIPS) && IsWindow(ptb->hwndToolTips)) {
        DestroyWindow (ptb->hwndToolTips);
        ptb->hwndToolTips = NULL;
    }

    if (ptb->hDragProxy)
        DestroyDragProxy(ptb->hDragProxy);

    if (ptb->hbmMono)
        DeleteObject(ptb->hbmMono);

    ReleaseMonoDC(ptb);

    if (ptb->nStrings > 0)
        DestroyStrings(ptb);

    if (ptb->hfontIcon && ptb->fFontCreated)
        DeleteObject(ptb->hfontIcon);

    // only do this destroy if pBitmaps exists..
    // this is our signal that it was from an old style toolba
    // and we created it ourselves.
    if (ptb->pBitmaps)
        ImageList_Destroy(TBGetImageList(ptb, HIML_NORMAL, 0));

    if (ptb->pBitmaps)
        LocalFree(ptb->pBitmaps);

    // couldn't have created tb if pimgs creation failed
    CCLocalReAlloc(ptb->pimgs, 0);

    Str_Set(&ptb->pszTip, NULL);
    if (ptb->Buttons) LocalFree(ptb->Buttons);
    LocalFree((HLOCAL)ptb);
    SetWindowInt(hwnd, 0, 0);

    TerminateDitherBrush();
}

void TB_OnSetState(PTBSTATE ptb, LPTBBUTTONDATA ptbButton, BYTE bState, int iPos)
{
    BYTE fsState;
    fsState = bState ^ ptbButton->fsState;
    ptbButton->fsState = bState;

    if (fsState)
    {
        if (ptb->fRedrawOff)
        {
            ptb->fInvalidate = ptb->fRecalc = TRUE;
        }
        else
        {
            if (fsState & TBSTATE_HIDDEN)
            {
                InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
                TBRecalc(ptb);
            }
            else
                InvalidateButton(ptb, ptbButton, TRUE);

            MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, ptb->ci.hwnd, OBJID_CLIENT,
                             iPos+1);
        }
    }
}

void TB_OnSetCmdID(PTBSTATE ptb, LPTBBUTTONDATA ptbButton, UINT idCommand)
{
    UINT uiOldID;

    uiOldID = ptbButton->idCommand;
    ptbButton->idCommand = idCommand;

    //
    // If the app was using tooltips, then
    // we need to update the command id there also.
    //

    if(ptb->hwndToolTips) {
        TOOLINFO ti;

        //
        // Query the old information
        //

        ti.cbSize = sizeof(ti);
        ti.hwnd = ptb->ci.hwnd;
        ti.uId = uiOldID;
        SendMessage(ptb->hwndToolTips, TTM_GETTOOLINFO, 0,
                    (LPARAM)(LPTOOLINFO)&ti);

        //
        // Delete the old tool since we can't just
        // change the command id.
        //

        SendMessage(ptb->hwndToolTips, TTM_DELTOOL, 0,
                    (LPARAM)(LPTOOLINFO)&ti);

        //
        // Add the new tool with the new command id.
        //

        ti.uId = idCommand;
        SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                    (LPARAM)(LPTOOLINFO)&ti);
    }
}



LRESULT TB_OnSetButtonInfo(PTBSTATE ptb, int idBtn, LPTBBUTTONINFO ptbbi)
{
    int iPos;
    BOOL fInvalidateAll = FALSE;

    if (ptbbi->cbSize != SIZEOF(TBBUTTONINFO))
        return 0;

    if (ptbbi->dwMask & TBIF_BYINDEX)
        iPos = idBtn;
    else
        iPos = PositionFromID(ptb, idBtn);

    if (iPos != -1)
    {
        LPTBBUTTONDATA ptbButton;
        BOOL fInvalidate = FALSE;

        ptbButton = ptb->Buttons + iPos;

        if (ptbbi->dwMask & TBIF_STYLE) {
            if ((ptbButton->fsStyle ^ ptbbi->fsStyle) & (BTNS_DROPDOWN | BTNS_WHOLEDROPDOWN))
            {
                // Width may have changed!
                fInvalidateAll = TRUE;
            }
            if ((ptbButton->fsStyle ^ ptbbi->fsStyle) & BTNS_AUTOSIZE)
                ptbButton->cx = 0;

            ptbButton->fsStyle = ptbbi->fsStyle;
            fInvalidate = TRUE;
        }

        if (ptbbi->dwMask & TBIF_STATE) {
            TB_OnSetState(ptb, ptbButton, ptbbi->fsState, iPos);
        }

        if (ptbbi->dwMask & TBIF_IMAGE) {
            TB_OnSetImage(ptb, ptbButton, ptbbi->iImage);
        }

        if (ptbbi->dwMask & TBIF_SIZE) {
            ptbButton->cx = ptbbi->cx;
            fInvalidate = TRUE;
            fInvalidateAll = TRUE;
        }

        if (ptbbi->dwMask & TBIF_TEXT) {

            // changing the text on an autosize button means recalc
            if (BTN_IS_AUTOSIZE(ptb, ptbButton)) {
                fInvalidateAll = TRUE;
                ptbButton->cx = (WORD)0;
            }

            ptb->fNoStringPool = TRUE;
            if (!TBISSTRINGPTR(ptbButton->iString)) {
                ptbButton->iString = 0;
            }

            Str_Set((LPTSTR*)&ptbButton->iString, ptbbi->pszText);
            fInvalidate = TRUE;

        }

        if (ptbbi->dwMask & TBIF_LPARAM) {
            ptbButton->dwData = ptbbi->lParam;
        }

        if (ptbbi->dwMask & TBIF_COMMAND) {
            TB_OnSetCmdID(ptb, ptbButton, ptbbi->idCommand);
        }

        if (fInvalidateAll || fInvalidate) {
            TBInvalidateItemRects(ptb);
            if (fInvalidateAll)
                InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
            else
                InvalidateButton(ptb, ptbButton, TRUE);
        }

        return TRUE;
    }

    return FALSE;
}

LRESULT TB_OnGetButtonInfo(PTBSTATE ptb, int idBtn, LPTBBUTTONINFO ptbbi)
{
    int iPos;

    if (ptbbi->cbSize != SIZEOF(TBBUTTONINFO))
        return -1;

    if (ptbbi->dwMask & TBIF_BYINDEX)
        iPos = idBtn;
    else
        iPos = PositionFromID(ptb, idBtn);
    if (iPos >= 0 && iPos < ptb->iNumButtons)
    {
        LPTBBUTTONDATA ptbButton;
        ptbButton = ptb->Buttons + iPos;

        if (ptbbi->dwMask & TBIF_STYLE) {
            ptbbi->fsStyle = ptbButton->fsStyle;
        }

        if (ptbbi->dwMask & TBIF_STATE) {
            ptbbi->fsState = ptbButton->fsState;
        }

        if (ptbbi->dwMask & TBIF_IMAGE) {
            ptbbi->iImage = ptbButton->DUMMYUNION_MEMBER(iBitmap);
        }

        if (ptbbi->dwMask & TBIF_SIZE) {
            ptbbi->cx = (WORD) ptbButton->cx;
        }

        if (ptbbi->dwMask & TBIF_TEXT)
        {
            if (TBISSTRINGPTR(ptbButton->iString))
            {
                StringCchCopy(ptbbi->pszText, ptbbi->cchText, (LPCTSTR)ptbButton->iString);
            }
        }

        if (ptbbi->dwMask & TBIF_LPARAM) {
            ptbbi->lParam = ptbButton->dwData;
        }

        if (ptbbi->dwMask & TBIF_COMMAND) {
            ptbbi->idCommand = ptbButton->idCommand;
        }
    } else
        iPos = -1;

    return iPos;
}

UINT GetAccelerator(LPTSTR psz)
{
    UINT ch = (UINT)-1;
    LPTSTR pszAccel = psz;
    // then prefixes are allowed.... see if it has one
    do 
    {
        pszAccel = StrChr(pszAccel, CH_PREFIX);
        if (pszAccel) 
        {
            pszAccel = FastCharNext(pszAccel);

            // handle having &&
            if (*pszAccel != CH_PREFIX)
                ch = *pszAccel;
            else
                pszAccel = FastCharNext(pszAccel);
        }
    } 
    while (pszAccel && (ch == (UINT)-1));

    return ch;
}


UINT TBButtonAccelerator(PTBSTATE ptb, LPTBBUTTONDATA ptbn)
{
    UINT ch = (UINT)-1;
    LPTSTR psz = TB_StrForButton(ptb, ptbn);

    if (psz && *psz) {
        if (!(ptb->uDrawTextMask & ptb->uDrawText & DT_NOPREFIX)) {
            ch = GetAccelerator(psz);
        }

        if (ch == (UINT)-1) {
            // no prefix found.  use the first char
            ch = (UINT)*psz;
        }
    }
    return (UINT)ch;
}


/*----------------------------------------------------------
Purpose: Returns the number of buttons that have the passed
            in char as their accelerator

*/
int TBHasAccelerator(PTBSTATE ptb, UINT ch)
{
    int i;
    int c = 0;
    for (i = 0; i < ptb->iNumButtons; i++)
    {
        if (!ChrCmpI((WORD)TBButtonAccelerator(ptb, &ptb->Buttons[i]), (WORD)ch))
            c++;
    }

    if (c == 0)
    {
        NMCHAR nm = {0};
        nm.ch = ch;
        nm.dwItemPrev = 0;
        nm.dwItemNext = -1;

        // The duplicate accelerator is used to expand or execute a menu item,
        // if we determine that there are no items, we still want to ask the 
        // owner if there are any...

        if (CCSendNotify(&ptb->ci, TBN_MAPACCELERATOR, &nm.hdr) &&
            nm.dwItemNext != -1)
        {
            c++;
        }
    }

    return c;
}

/*----------------------------------------------------------
Purpose: Returns TRUE if the character maps to more than one
         button.

*/
BOOL TBHasDupChar(PTBSTATE ptb, UINT ch)
{
    BOOL bRet = FALSE;
    NMTBDUPACCELERATOR nmda;

    int c = 0;

    nmda.ch = ch;

    // BUGBUG (lamadio): this is going away
    if (CCSendNotify(&ptb->ci, TBN_DUPACCELERATOR, &nmda.hdr))
    {
        bRet = nmda.fDup;
    }
    else
    {
        if (TBHasAccelerator(ptb, ch) > 1)
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Returns the index of the item whose accelerator matches
         the given character.  Starts at the current hot item.

Returns: -1 if nothing found

*/
int TBItemFromAccelerator(PTBSTATE ptb, UINT ch, BOOL * pbDup)
{
    int iRet = -1;
    int i;
    int iStart = ptb->iHot;

    NMTBWRAPACCELERATOR nmwa;
    NMCHAR nm = {0};
    nm.ch = ch;
    nm.dwItemPrev = iStart;
    nm.dwItemNext = -1;

    // Ask the client if they want to handle this keyboard press
    if (CCSendNotify(&ptb->ci, TBN_MAPACCELERATOR, &nm.hdr) &&
        (int)nm.dwItemNext > iStart && (int)nm.dwItemNext < ptb->iNumButtons)
    {
        // They handled it, so we're just going to return the position
        // that they said.
        iRet =  nm.dwItemNext;
    }
    else for (i = 0; i < ptb->iNumButtons; i++)
    {

        if ( iStart + 1 >= ptb->iNumButtons )
        {
            nmwa.ch = ch;
            if (CCSendNotify(&ptb->ci, TBN_WRAPACCELERATOR, &nmwa.hdr))
                return nmwa.iButton;
        }

        iStart += 1 + ptb->iNumButtons;
        iStart %= ptb->iNumButtons;

        if ((ptb->Buttons[iStart].fsState & TBSTATE_ENABLED) &&
            !ChrCmpI((WORD)TBButtonAccelerator(ptb, &ptb->Buttons[iStart]), (WORD)ch))
        {
            iRet = iStart;
            break;
        }

    }

    *pbDup = TBHasDupChar(ptb, ch);

    return iRet;
}


BOOL TBOnChar(PTBSTATE ptb, UINT ch)
{
    NMCHAR nm = {0};
    BOOL bDupChar;
    int iPos = TBItemFromAccelerator(ptb, ch, &bDupChar);
    BOOL fHandled = FALSE;

    // Send the notification.  Parent may want to change the next button.
    nm.ch = ch;
    nm.dwItemPrev = (0 <= ptb->iHot) ? ptb->Buttons[ptb->iHot].idCommand : -1;
    nm.dwItemNext = (0 <= iPos) ? ptb->Buttons[iPos].idCommand : -1;
    if (CCSendNotify(&ptb->ci, NM_CHAR, (LPNMHDR)&nm))
        return TRUE;

    iPos = PositionFromID(ptb, nm.dwItemNext);

    if (-1 != iPos)
    {
        DWORD dwFlags = HICF_ACCELERATOR;

        if (ptb->iHot == iPos)
            dwFlags |= HICF_RESELECT;

        if (bDupChar)
            dwFlags |= HICF_DUPACCEL;

        TBSetHotItem(ptb, iPos, dwFlags);

        if (bDupChar)
            iPos = -1;

        fHandled = TRUE;
    } else {

        // handle this here instead of VK_KEYDOWN
        // because a typical thing to do is to pop down a menu
        // which will beep when it gets the WM_CHAR resulting from
        // the VK_KEYDOWN
        switch (ch) {
        case ' ':
        case 13:
            if (ptb->iHot != -1)
            {
                LPTBBUTTONDATA ptbButton = &ptb->Buttons[ptb->iHot];
                if (TB_IsDropDown(ptbButton) &&
                    !TB_HasSplitDDArrow(ptb, ptbButton))
                {
                    iPos = ptb->iHot;
                    fHandled = TRUE;
                }
                break;
            }
        }
    }

    if (-1 != iPos) {
        LPTBBUTTONDATA ptbButton = &ptb->Buttons[iPos];
        if (TB_IsDropDown(ptbButton))
            TBToggleDropDown(ptb, iPos, FALSE);
    }
    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);

    return fHandled;
}


BOOL TBOnMapAccelerator(PTBSTATE ptb, UINT ch, UINT * pidCmd)
{
    int iPos;
    BOOL bDupChar;

    ASSERT(IS_VALID_WRITE_PTR(pidCmd, UINT));

    iPos = TBItemFromAccelerator(ptb, ch, &bDupChar);
    if (-1 != iPos)
    {
        *pidCmd = ptb->Buttons[iPos].idCommand;
        return TRUE;
    }
    return FALSE;
}


BOOL TBOnKey(PTBSTATE ptb, int nVirtKey, UINT uFlags)
{
    NMKEY nm;

    // Send the notification
    nm.nVKey = nVirtKey;
    nm.uFlags = uFlags;
    if (CCSendNotify(&ptb->ci, NM_KEYDOWN, &nm.hdr))
        return TRUE;

    // Swap the left and right arrow key if the control is mirrored.
    nVirtKey = RTLSwapLeftRightArrows(&ptb->ci, nVirtKey);

    if (ptb->iHot != -1 && TB_IsDropDown(&ptb->Buttons[ptb->iHot])) {
        // if we're on a dropdown button and you hit the up/down arrow (left/rigth in vert mode)
        // then drop the button down.
        // escape undrops it if it's dropped
        switch (nVirtKey) {
        case VK_RIGHT:
        case VK_LEFT:
            if (!(ptb->ci.style & CCS_VERT))
                break;
            goto DropDown;

        case VK_DOWN:
        case VK_UP:
            if ((ptb->ci.style & CCS_VERT) || (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL))
                break;
            goto DropDown;


        case VK_ESCAPE:
            if (ptb->iHot != ptb->iPressedDD)
                break;
DropDown:
            TBToggleDropDown(ptb, ptb->iHot, FALSE);
            //notify of navigation key usage
            CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);
            return TRUE;
        }
    }


    switch (nVirtKey) {
    case VK_RIGHT:
    case VK_DOWN:
        TBCycleHotItem(ptb, ptb->iHot, 1, HICF_ARROWKEYS);
        break;

    case VK_LEFT:
    case VK_UP:
        TBCycleHotItem(ptb, ptb->iHot, -1, HICF_ARROWKEYS);
        break;

    case VK_SPACE:
    case VK_RETURN:
        if (ptb->iHot != -1)
        {
            FORWARD_WM_COMMAND(ptb->ci.hwndParent, ptb->Buttons[ptb->iHot].idCommand, ptb->ci.hwnd, BN_CLICKED, SendMessage);
        }
        break;

    default:
        return FALSE;
    }

    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);
    return TRUE;
}

LRESULT TB_OnSetButtonInfoA(PTBSTATE ptb, int idBtn, LPTBBUTTONINFOA ptbbiA)
{
    TBBUTTONINFO tbbi = *(LPTBBUTTONINFO)ptbbiA;
    WCHAR szText[256];

    if ((ptbbiA->dwMask & TBIF_TEXT) && ptbbiA->pszText)
    {
        tbbi.pszText = szText;
        tbbi.cchText = ARRAYSIZE(szText);

        MultiByteToWideChar(CP_ACP, 0, (LPCSTR) ptbbiA->pszText, -1,
                            szText, ARRAYSIZE(szText));
    }

    return TB_OnSetButtonInfo(ptb, idBtn, (LPTBBUTTONINFO)&tbbi);
}

LRESULT TB_OnGetButtonInfoA(PTBSTATE ptb, int idBtn, LPTBBUTTONINFOA ptbbiA)
{
    LPTBBUTTONDATA ptbButton;
    int iPos;
    DWORD dwMask = ptbbiA->dwMask;

    ptbbiA->dwMask &= ~TBIF_TEXT;

    iPos = (int) TB_OnGetButtonInfo(ptb, idBtn, (LPTBBUTTONINFO)ptbbiA);

    if (iPos != -1)
    {
        ptbButton = ptb->Buttons + iPos;

        ptbbiA->dwMask = dwMask;
        if (ptbbiA->dwMask & TBIF_TEXT)
        {
            if (TBISSTRINGPTR(ptbButton->iString))
            {
                WideCharToMultiByte (CP_ACP, 0, (LPCTSTR)ptbButton->iString,
                                     -1, ptbbiA->pszText , ptbbiA->cchText, NULL, NULL);
            }
            else
            {
                ptbbiA->pszText[0] = 0;
            }
        }
    }

    return iPos;
}


void TBOnMouseMove(PTBSTATE ptb, HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    if (ptb->fActive)
    {
        BOOL fSameButton;
        BOOL fDragOut = FALSE;
        int iPos;

        // do drag notifies/drawing first
        if (ptb->pCaptureButton != NULL)
        {
            if (hwnd != GetCapture())
            {
                //DebugMsg(DM_TRACE, TEXT("capture isn't us"));
                SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_ENDDRAG);

                // Revalidate after calling out
                if (!IsWindow(hwnd)) return;

                // if the button is still pressed, unpress it.
                if (EVAL(ptb->pCaptureButton) &&
                    (ptb->pCaptureButton->fsState & TBSTATE_PRESSED))
                    SendMessage(hwnd, TB_PRESSBUTTON, ptb->pCaptureButton->idCommand, 0L);
                ptb->pCaptureButton = NULL;
                ptb->fRightDrag = FALSE; // just in case we were right dragging
            }
            else
            {
                //DebugMsg(DM_TRACE, TEXT("capture IS us, and state is enabled"));
                iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
                fSameButton = (iPos >= 0 && ptb->pCaptureButton == ptb->Buttons + iPos);

                // notify on first drag out
                if (!fSameButton && !ptb->fDragOutNotify)
                {
                    ptb->fDragOutNotify = TRUE;
                    fDragOut = (BOOL)SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_DRAGOUT);

                    // Revalidate after calling out
                    if (!IsWindow(hwnd)) return;

                }

                // Check for ptb->pCaptureButton in case it was somehow nuked
                // in TBN_DRAGOUT.
                // This happens in the case when dragging an item out of start menu. When the
                // notify TBN_DRAGOUT is received, they go into a modal drag drop loop. Before
                // This loop finishes, the file is moved, causing a shell change notify to nuke
                // the button, which invalidates pCatpure button. So I'm getting rid of the
                // eval (lamadio) 4.14.98

                if (ptb->pCaptureButton &&
                    (ptb->pCaptureButton->fsState & TBSTATE_ENABLED) &&
                    (fSameButton == !(ptb->pCaptureButton->fsState & TBSTATE_PRESSED)) &&
                    !ptb->fRightDrag)
                {
                    //DebugMsg(DM_TRACE, TEXT("capture IS us, and Button is different"));

                    ptb->pCaptureButton->fsState ^= TBSTATE_PRESSED;

                    InvalidateButton(ptb, ptb->pCaptureButton, TRUE);

                    MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd,
                        OBJID_CLIENT, (ptb->pCaptureButton - ptb->Buttons) + 1);
                }
            }
        }

        if (!fDragOut)
        {
            TBRelayToToolTips(ptb, wMsg, wParam, lParam);

            // Support hot tracking?
            if ((ptb->ci.style & TBSTYLE_FLAT) )
            {
                // Yes; set the hot item
                iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
                TBSetHotItem(ptb, iPos, HICF_MOUSE);

                // Track mouse events now?
                if (!ptb->fMouseTrack && !ptb->fAnchorHighlight)
                {
                    // Yes
                    TRACKMOUSEEVENT tme;

                    tme.cbSize = sizeof(TRACKMOUSEEVENT);
                    tme.dwFlags = TME_LEAVE;
                    tme.hwndTrack = hwnd;
                    ptb->fMouseTrack = TRUE;
                    TrackMouseEvent(&tme);
                }
            }
        }
    }

}


void TBHandleLButtonDown(PTBSTATE ptb, LPARAM lParam, int iPos)
{
    LPTBBUTTONDATA ptbButton;
    HWND hwnd = ptb->ci.hwnd;
    if (iPos >= 0 && iPos < ptb->iNumButtons)
    {
        POINT pt;
        RECT rcDropDown;

        LPARAM_TO_POINT(lParam, pt);

        // should this check for the size of the button struct?
        ptbButton = ptb->Buttons + iPos;

        if (TB_IsDropDown(ptbButton))
            TB_GetItemDropDownRect(ptb, iPos, &rcDropDown);

        if (TB_IsDropDown(ptbButton) &&
            (!TB_HasSplitDDArrow(ptb, ptbButton) || PtInRect(&rcDropDown, pt))) {

            // Was the dropdown handled?
            if (!TBToggleDropDown(ptb, iPos, TRUE))
            {
                // No; consider it a drag-out
                ptb->pCaptureButton = ptbButton;
                SetCapture(hwnd);

                ptb->fDragOutNotify = FALSE;
                SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_BEGINDRAG);
                GetMessagePosClient(ptb->ci.hwnd, &ptb->ptCapture);
            }

        } else {
            ptb->pCaptureButton = ptbButton;
            SetCapture(hwnd);

            if (ptbButton->fsState & TBSTATE_ENABLED)
            {
                ptbButton->fsState |= TBSTATE_PRESSED;
                InvalidateButton(ptb, ptbButton, TRUE);
                UpdateWindow(hwnd);         // immediate feedback

                MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd,
                    OBJID_CLIENT, iPos+1);
            }

            ptb->fDragOutNotify = FALSE;

            // pCaptureButton may have changed
            if (ptb->pCaptureButton)
                SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_BEGINDRAG);
            GetMessagePosClient(ptb->ci.hwnd, &ptb->ptCapture);
        }
    }
}


void TBOnLButtonDown(PTBSTATE ptb, HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    int iPos;
    NMCLICK nm = {0};

    ptb->fRequeryCapture = FALSE;
    TBRelayToToolTips(ptb, wMsg, wParam, lParam);

    iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
    if ((ptb->ci.style & CCS_ADJUSTABLE) &&
        (((wParam & MK_SHIFT) && !(ptb->ci.style & TBSTYLE_ALTDRAG)) ||
         ((GetKeyState(VK_MENU) & ~1) && (ptb->ci.style & TBSTYLE_ALTDRAG))))
    {
        MoveButton(ptb, iPos);
    }
    else {
        TBHandleLButtonDown(ptb, lParam, iPos);
    }

    if ((iPos >= 0) && (iPos < ptb->iNumButtons))
    {
        nm.dwItemSpec = ptb->Buttons[iPos].idCommand;
        nm.dwItemData = ptb->Buttons[iPos].dwData;
    }
    else
        nm.dwItemSpec = (UINT_PTR) -1;

    LPARAM_TO_POINT(lParam, nm.pt);

    CCSendNotify(&ptb->ci, NM_LDOWN, (LPNMHDR )&nm);
}


void TBOnLButtonUp(PTBSTATE ptb, HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    int iPos = -1;
    NMCLICK nm = { 0 };

    TBRelayToToolTips(ptb, wMsg, wParam, lParam);
    if (lParam != (LPARAM)-1)
        iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    if (ptb->fRequeryCapture && iPos >= 0) {
        // hack for broderbund (and potentially mand mfc apps.
        // on button down, they delete the pressed button and insert another one right underneat that
        // has pretty much the same characteristics.
        // on win95, we allowed pCaptureButton to temporarily point to garbage.
        // now we validate against it.
        // we detect this case on delete now and if the creation size (uStructSize == old 0x14 size)
        // we reget the capture button here
        ptb->pCaptureButton = &ptb->Buttons[iPos];
    }

    if (ptb->pCaptureButton != NULL) {

        int idCommand = ptb->pCaptureButton->idCommand;

        if (!CCReleaseCapture(&ptb->ci)) return;

        SendItemNotify(ptb, idCommand, TBN_ENDDRAG);
        if (!IsWindow(hwnd)) return;

        if (ptb->pCaptureButton && (ptb->pCaptureButton->fsState & TBSTATE_ENABLED) && iPos >=0
            && (ptb->pCaptureButton == ptb->Buttons+iPos)) {

            ptb->pCaptureButton->fsState &= ~TBSTATE_PRESSED;

            if (ptb->pCaptureButton->fsStyle & BTNS_CHECK) {
                if (ptb->pCaptureButton->fsStyle & BTNS_GROUP) {

                    // group buttons already checked can't be force
                    // up by the user.

                    if (ptb->pCaptureButton->fsState & TBSTATE_CHECKED) {
                        ptb->pCaptureButton = NULL;
                        return; // bail!
                    }

                    ptb->pCaptureButton->fsState |= TBSTATE_CHECKED;
                    MakeGroupConsistant(ptb, idCommand);
                } else {
                    ptb->pCaptureButton->fsState ^= TBSTATE_CHECKED; // toggle
                }
            }
            InvalidateButton(ptb, ptb->pCaptureButton, TRUE);
            ptb->pCaptureButton = NULL;

            MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd,  OBJID_CLIENT,
                iPos+1);

            FORWARD_WM_COMMAND(ptb->ci.hwndParent, idCommand, hwnd, BN_CLICKED, SendMessage);

            // do not dereference ptb... it might have been destroyed on the WM_COMMAND.
            // if the window has been destroyed, bail out.
            if (!IsWindow(hwnd))
                return;

            goto SendUpClick;
        }
        else {
            ptb->pCaptureButton = NULL;
        }
    }
    else
    {
SendUpClick:
        if ((iPos >= 0) && (iPos < ptb->iNumButtons)) {
            nm.dwItemSpec = ptb->Buttons[iPos].idCommand;
            nm.dwItemData = ptb->Buttons[iPos].dwData;
        } else
            nm.dwItemSpec = (UINT_PTR) -1;

        LPARAM_TO_POINT(lParam, nm.pt);

        CCSendNotify(&ptb->ci, NM_CLICK, (LPNMHDR )&nm);
    }
}


BOOL CALLBACK GetUpdateRectEnumProc(HWND hwnd, LPARAM lParam)
{
    PTBSTATE ptb = (PTBSTATE)lParam;

    if (IsWindowVisible(hwnd))
    {
        RECT rcInvalid;

        if (GetUpdateRect(hwnd, &rcInvalid, FALSE))
        {
            RECT rcNew;

            MapWindowPoints(hwnd, ptb->ci.hwnd, (LPPOINT)&rcInvalid, 2);
            UnionRect(&rcNew, &rcInvalid, &ptb->rcInvalid);
            ptb->rcInvalid = rcNew;
        }
    }

    return TRUE;
}

void TB_OnSize(PTBSTATE ptb, int nWidth, int nHeight)
{
    if (ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS)
    {
        // figure out which buttons intersect the resized region
        // and invalidate the rects for those buttons
        //
        // +---------------+------+
        // |               |     <--- rcResizeH
        // |               |      |
        // +---------------+------+
        // |   ^           |      |
        // +---|-----------+------+
        //     rcResizeV
        
        int i;
        RECT rcResizeH, rcResizeV;

        SetRect(&rcResizeH, min(ptb->rc.right, nWidth),
                            ptb->rc.top,
                            max(ptb->rc.right, nWidth),
                            min(ptb->rc.bottom, nHeight));

        SetRect(&rcResizeV, ptb->rc.left,
                            min(ptb->rc.bottom, nHeight),
                            min(ptb->rc.right, nWidth),
                            max(ptb->rc.bottom, nHeight));

        for (i = 0; i < ptb->iNumButtons; i++)
        {
            RECT rc, rcBtn;
            TB_GetItemRect(ptb, i, &rcBtn);
            if (IntersectRect(&rc, &rcBtn, &rcResizeH) ||
                IntersectRect(&rc, &rcBtn, &rcResizeV))
            {
                InvalidateRect(ptb->ci.hwnd, &rcBtn, TRUE);
            }
        }

        SetRect(&ptb->rc, 0, 0, nWidth, nHeight);
    }
}

BOOL TB_TranslateAccelerator(HWND hwnd, LPMSG lpmsg)
{
    if (!lpmsg)
        return FALSE;

    if (GetFocus() != hwnd)
        return FALSE;

    switch (lpmsg->message) {

    case WM_KEYUP:
    case WM_KEYDOWN:

        switch (lpmsg->wParam) {

        case VK_RIGHT:
        case VK_LEFT:
        case VK_UP:
        case VK_DOWN:
        case VK_ESCAPE:
        case VK_SPACE:
        case VK_RETURN:
            TranslateMessage(lpmsg);
            DispatchMessage(lpmsg);
            return TRUE;
        }
        break;

    case WM_CHAR:
        switch (lpmsg->wParam) {

        case VK_ESCAPE:
        case VK_SPACE:
        case VK_RETURN:
            TranslateMessage(lpmsg);
            DispatchMessage(lpmsg);
            return TRUE;
        }
        break;

    }

    return FALSE;
}

void TBInitMetrics(PTBSTATE ptb)
{
    // init our g_clr's
    InitGlobalColors();

    // get the size of a drop down arrow
    ptb->dxDDArrowChar = GetSystemMetrics(SM_CYMENUCHECK);
}

LRESULT TBGenerateDragImage(PTBSTATE ptb, SHDRAGIMAGE* pshdi)
{
    HBITMAP hbmpOld = NULL;
    NMTBCUSTOMDRAW  tbcd = { 0 };
    HDC  hdcDragImage;
    // Do we have a hot item?
    if (ptb->iHot == -1)
        return 0;       // No? Return...

    hdcDragImage = CreateCompatibleDC(NULL);

    if (!hdcDragImage)
        return 0;

    //
    // Mirror the the DC, if the toolbar is mirrored.
    //
    if (ptb->ci.dwExStyle & RTL_MIRRORED_WINDOW)
    {
        SET_DC_RTL_MIRRORED(hdcDragImage);
    }

    tbcd.nmcd.hdc = hdcDragImage;
    ptb->ci.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_PREPAINT, (NMCUSTOMDRAW *)&tbcd);
    pshdi->sizeDragImage.cx = TBWidthOfButton(ptb, &ptb->Buttons[ptb->iHot], hdcDragImage);
    pshdi->sizeDragImage.cy = ptb->iButHeight;
    pshdi->hbmpDragImage = CreateBitmap( pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy,
        GetDeviceCaps(hdcDragImage, PLANES), GetDeviceCaps(hdcDragImage, BITSPIXEL),
        NULL);

    if (pshdi->hbmpDragImage)
    {
        DWORD dwStyle;
        RECT  rc = {0, 0, pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy};
        hbmpOld = SelectObject(hdcDragImage, pshdi->hbmpDragImage);

        pshdi->crColorKey = RGB(0xFF, 0x00, 0x55);

        FillRectClr(hdcDragImage, &rc, pshdi->crColorKey);

        // We want the button to be drawn transparent. This is a hack, because I
        // don't want to rewrite the draw code. Fake a transparent draw.
        dwStyle = ptb->ci.style;
        ptb->ci.style |= TBSTYLE_TRANSPARENT;
        ptb->fAntiAlias = FALSE;

        DrawButton(hdcDragImage, 0, 0, ptb, &ptb->Buttons[ptb->iHot], TRUE);

        ptb->fAntiAlias = TRUE;
        ptb->ci.style = dwStyle;

        TB_GetItemRect(ptb, ptb->iHot, &rc);
        if (PtInRect(&rc, ptb->ptCapture))
        {
           if (ptb->ci.dwExStyle & RTL_MIRRORED_WINDOW)
               pshdi->ptOffset.x = rc.right - ptb->ptCapture.x;
           else
               pshdi->ptOffset.x = ptb->ptCapture.x - rc.left;
           pshdi->ptOffset.y = ptb->ptCapture.y - rc.top;
        }

        SelectObject(hdcDragImage, hbmpOld);
        DeleteDC(hdcDragImage);

        // We're passing back the created HBMP.
        return 1;
    }

    return 0;
}

LRESULT CALLBACK ToolbarWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPTBBUTTONDATA ptbButton;
    int iPos;
    LRESULT dw;
    PTBSTATE ptb = (PTBSTATE)GetWindowPtr0(hwnd);   // GetWindowPtr(hwnd, 0)

    if (uMsg == WM_NCCREATE)
    {
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;

        CCCreateWindow();

        InitDitherBrush();

        // create the state data for this toolbar

        ptb = (PTBSTATE)LocalAlloc(LPTR, sizeof(TBSTATE));
        if (!ptb)
            return 0;   // WM_NCCREATE failure is 0

        // note, zero init memory from above
        CIInitialize(&ptb->ci, hwnd, lpcs);
        ptb->xFirstButton = s_xFirstButton;
        ptb->iHot = -1;
        ptb->iPressedDD = -1;
        ptb->iInsert = -1;
        ptb->clrim = CLR_DEFAULT;
        ptb->fAntiAlias = TRUE; // Anti Alias fonts by default.
        // initialize system metric-dependent stuff
        TBInitMetrics(ptb);

        // horizontal/vertical space taken up by button chisel, sides,
        // and a 1 pixel margin.  used in GrowToolbar.
        ptb->xPad = 7;
        ptb->yPad = 6;
        ptb->fShowPrefix = TRUE;

        ptb->iListGap = LIST_GAP;
        ptb->iDropDownGap = DROPDOWN_GAP;

        ptb->clrsc.clrBtnHighlight = ptb->clrsc.clrBtnShadow = CLR_DEFAULT;

        ASSERT(ptb->uStructSize == 0);
        ASSERT(ptb->hfontIcon == NULL);  // initialize to null.
        ASSERT(ptb->iButMinWidth == 0);
        ASSERT(ptb->iButMaxWidth == 0);

        ptb->nTextRows = 1;
        ptb->fActive = TRUE;

        // IE 3 passes in TBSTYLE_FLAT, but they really
        // wanted TBSTYLE_TRANSPARENT also.
        //
        if (ptb->ci.style & TBSTYLE_FLAT) {
            ptb->ci.style |= TBSTYLE_TRANSPARENT;
        }

#ifdef DEBUG
        if (IsFlagSet(g_dwPrototype, PTF_FLATLOOK))
        {
            TraceMsg(TF_TOOLBAR, "Using flat look for toolbars.");
            ptb->ci.style |= TBSTYLE_FLAT;
        }
#endif

        // Now Initialize the hfont we will use.
        TBChangeFont(ptb, 0, NULL);

        // grow the button size to the appropriate girth
        if (!SetBitmapSize(ptb, DEFAULTBITMAPX, DEFAULTBITMAPX))
        {
            goto Failure;
        }

        SetWindowPtr(hwnd, 0, ptb);

        if (!(ptb->ci.style & (CCS_TOP | CCS_NOMOVEY | CCS_BOTTOM)))
        {
            ptb->ci.style |= CCS_TOP;
            SetWindowLong(hwnd, GWL_STYLE, ptb->ci.style);
        }

        return TRUE;

Failure:
        if (ptb) {
            ASSERT(!ptb->Buttons);  // App hasn't had a change to AddButtons yet
            LocalFree(ptb);
        }
        return FALSE;
    }

    if (!ptb)
        goto DoDefault;

    switch (uMsg) {

    case WM_CREATE:
        if (ptb->ci.style & TBSTYLE_REGISTERDROP)
        {
            ptb->hDragProxy = CreateDragProxy(ptb->ci.hwnd, ToolbarDragCallback, TRUE);
        }
        goto DoDefault;

    case WM_DESTROY:
        CCDestroyWindow();
        TB_OnDestroy(ptb);
        break;

    case WM_KEYDOWN:
        if (TBOnKey(ptb, (int) wParam, HIWORD(lParam)))
            break;
        goto DoDefault;

    case WM_UPDATEUISTATE:
    {
        if (CCOnUIState(&(ptb->ci), WM_UPDATEUISTATE, wParam, lParam))
        {
            BOOL fSmooth = FALSE;
#ifdef CLEARTYPE    // Don't use SPI_CLEARTYPE because it's defined because of APIThk, but not in NT.
            SystemParametersInfo(SPI_GETCLEARTYPE, 0, &fSmooth, 0);
#endif
            // We erase background only if we are removing underscores or focus rect,
            // or if Font smooting is enabled
            InvalidateRect(hwnd, NULL, 
                 fSmooth || ((UIS_SET == LOWORD(wParam)) ? TRUE : FALSE));
        }

        goto DoDefault;
    }

    case WM_GETDLGCODE:
        return (LRESULT) (DLGC_WANTARROWS | DLGC_WANTCHARS);

    case WM_SYSCHAR:
    case WM_CHAR:
        if (!TBOnChar(ptb, (UINT) wParam) &&
            (ptb->ci.iVersion >= 5))
        {
            // didn't handle it & client is >= v5
            // forward to default handler
            goto DoDefault;
        }
        break;

    case WM_SETFOCUS:
        if (ptb->iHot == -1) {
            // set hot the first enabled button
            TBCycleHotItem(ptb, -1, 1, HICF_OTHER);
        }
        break;

    case WM_KILLFOCUS:
        TBSetHotItem(ptb, -1, HICF_OTHER);
        break;

    case WM_SETFONT:
        TBSetFont(ptb, (HFONT)wParam, (BOOL)lParam);
        return TRUE;

    case WM_NCCALCSIZE:
        // let defwindowproc handle the standard borders etc...
        dw = DefWindowProc(hwnd, uMsg, wParam, lParam ) ;

        // add the extra edge at the top of the toolbar to seperate from the menu bar
        if (!(ptb->ci.style & CCS_NODIVIDER))
        {
            ((NCCALCSIZE_PARAMS *)lParam)->rgrc[0].top += g_cyEdge;
        }

        return dw;

    case WM_NCHITTEST:
        return HTCLIENT;

    case WM_NCACTIVATE:

        // only make sense to do this stuff if we're top level
        if ((BOOLIFY(ptb->fActive) != (BOOL)wParam && !GetParent(hwnd))) {
            int iButton;

            ptb->fActive = (BOOL) wParam;

            for (iButton = 0; iButton < ptb->iNumButtons; iButton++) {
                ptbButton = &ptb->Buttons[iButton];
                InvalidateButton(ptb, ptbButton, FALSE);
            }
        }
        // fall through...

    case WM_NCPAINT:
        // old-style toolbars are forced to be without dividers above
        if (!(ptb->ci.style & CCS_NODIVIDER))
        {
            RECT rc;
            HDC hdc = GetWindowDC(hwnd);
            GetWindowRect(hwnd, &rc);
            MapWindowRect(NULL, hwnd, &rc); // screen -> client

                rc.bottom = -rc.top;                // bottom of NC area
                rc.top = rc.bottom - g_cyEdge;

            CCDrawEdge(hdc, &rc, BDR_SUNKENOUTER, BF_TOP | BF_BOTTOM, &(ptb->clrsc));
            ReleaseDC(hwnd, hdc);
        }
        goto DoDefault;

    case WM_ENABLE:
        if (wParam) {
            ptb->ci.style &= ~WS_DISABLED;
        } else {
            ptb->ci.style |= WS_DISABLED;
        }
        InvalidateRect(hwnd, NULL, ptb->ci.style & TBSTYLE_TRANSPARENT);
        goto DoDefault;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        if (ptb->fTTNeedsFlush)
            FlushToolTipsMgrNow(ptb);

        if (ptb->fRedrawOff)
        {
            if (!wParam)
            {
                HDC hdcPaint;
                PAINTSTRUCT ps;

                hdcPaint = BeginPaint(hwnd, &ps);
                EndPaint(hwnd, &ps);
            }

            // we got a paint region, so invalidate
            // when we get redraw back on...
            ptb->fInvalidate = TRUE;
        }
        else
        {
            TBPaint(ptb, (HDC)wParam);
        }
        break;

    case WM_SETREDRAW:
        {
            // HACKHACK: only respect WM_SETREDRAW message if tbstyle is flat
            // HACKHACK: fixes appcompat bug #60120
            if (ptb->ci.style & TBSTYLE_FLAT || 
                ptb->dwStyleEx & TBSTYLE_EX_VERTICAL || 
                (ptb->ci.iVersion >= 5))
            {
                BOOL fRedrawOld = !ptb->fRedrawOff;

                if ( wParam && ptb->fRedrawOff )
                {
                    if ( ptb->fInvalidate )
                    {
                        // If font smoothing is enabled, then we need to erase the background too.
                        BOOL fSmooth = FALSE;
#ifdef CLEARTYPE    // Don't use SPI_CLEARTYPE because it's defined because of APIThk, but not in NT.
                        SystemParametersInfo(SPI_GETCLEARTYPE, 0, &fSmooth, 0);
#endif


                        // invalidate before turning back on ...
                        RedrawWindow( hwnd, NULL, NULL, (fSmooth? RDW_ERASE: 0)  | RDW_INVALIDATE );
                        ptb->fInvalidate = FALSE;
                    }
                    ptb->fRedrawOff = FALSE;

                    if ( ptb->fRecalc )
                    {
                        // recalc & autosize after turning back on
                        TBRecalc(ptb);
                        TBAutoSize(ptb);
                        ptb->fRecalc = FALSE;
                    }
                }
                else
                {
                    ptb->fRedrawOff = !wParam;
                }

                if (ptb->ci.iVersion >= 5)
                    return fRedrawOld;
            }
            else
            {
                goto DoDefault;
            }
        }
        break;

    case WM_ERASEBKGND:
        TB_OnEraseBkgnd(ptb, (HDC) wParam);
        return(TRUE);

    case WM_SYSCOLORCHANGE:
        TB_OnSysColorChange(ptb);
        if (ptb->hwndToolTips)
            SendMessage(ptb->hwndToolTips, uMsg, wParam, lParam);
        break;

    case TB_GETROWS:
        return CountRows(ptb);
        break;

    case TB_GETPADDING:
        lParam = MAKELONG(-1, -1);
        // fall through
    case TB_SETPADDING:
    {
        LRESULT lres = MAKELONG(ptb->xPad, ptb->yPad);
        int xPad = GET_X_LPARAM(lParam);
        int yPad = GET_Y_LPARAM(lParam);
        if (xPad != -1)
            ptb->xPad = xPad;
        if (yPad != -1)
            ptb->yPad = yPad;
        return lres;
    }


    case TB_SETROWS:
        {
            RECT rc;

            if (BoxIt(ptb, LOWORD(wParam), HIWORD(wParam), &rc))
            {
                TBInvalidateItemRects(ptb);
                SetWindowPos(hwnd, NULL, 0, 0, rc.right, rc.bottom,
                             SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE);
                InvalidateRect(hwnd, NULL, TRUE);
            }
            if (lParam)
                *((RECT *)lParam) = rc;
        }
        break;

    case WM_MOVE:
        // JJK TODO: This needs to be double buffered to get rid of the flicker
        if (ptb->ci.style & TBSTYLE_TRANSPARENT)
            InvalidateRect(hwnd, NULL, TRUE);
        goto DoDefault;

    case WM_SIZE:
        TB_OnSize(ptb, LOWORD(lParam), HIWORD(lParam));
        // fall through
    case TB_AUTOSIZE:
        TBAutoSize(ptb);
        break;

    case WM_COMMAND:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
        SendMessage(ptb->ci.hwndParent, uMsg, wParam, lParam);
        break;

    case WM_RBUTTONDBLCLK:
        if (!CCSendNotify(&ptb->ci, NM_RDBLCLK, NULL))
            goto DoDefault;
        break;

    case WM_RBUTTONUP:
        {
            NMCLICK nm = {0};
            int iIndex;

            if (ptb->pCaptureButton != NULL)
            {
                if (!CCReleaseCapture(&ptb->ci)) break;
                ptb->pCaptureButton = NULL;
                ptb->fRightDrag = FALSE;
            }

            iIndex = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            if ((iIndex >= 0) && (iIndex < ptb->iNumButtons)) {
                nm.dwItemSpec = ptb->Buttons[iIndex].idCommand;
                nm.dwItemData = ptb->Buttons[iIndex].dwData;
            } else
                nm.dwItemSpec = (UINT_PTR) -1;

            LPARAM_TO_POINT(lParam, nm.pt);

            if (!CCSendNotify(&ptb->ci, NM_RCLICK, (LPNMHDR )&nm))
                goto DoDefault;
        }
        break;

    case WM_LBUTTONDBLCLK:
        iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        if (iPos < 0 && (ptb->ci.style & CCS_ADJUSTABLE))
        {
            iPos = -1 - iPos;
            CustomizeTB(ptb, iPos);
        } else {
            TBHandleLButtonDown(ptb, lParam, iPos);
        }
        break;

    case WM_LBUTTONDOWN:
        TBOnLButtonDown(ptb, hwnd, uMsg, wParam, lParam);
        break;

    case WM_CAPTURECHANGED:
        // do this only for newer apps because some apps
        // do things like delete a button when you
        // mouse down and add it back in immediately.
        // also do it on a post because we call ReleaseCapture
        // internally and only want to catch this on external release
        if (ptb->ci.iVersion >= 5)
            PostMessage(hwnd, TBP_ONRELEASECAPTURE, 0, 0);

        //
        //  QFE fix for Autodesk.  We used to hold capture
        //  even though the app wanted it back.  Oops.
        //
        else if (ptb->fRightDrag && ptb->pCaptureButton) {
            CCReleaseCapture(&ptb->ci);
            ptb->fRightDrag = FALSE;
        }

        break;

    case TBP_ONRELEASECAPTURE:
        if (ptb->pCaptureButton) {
            // abort current capture
            // simulate a lost capture mouse move.  this will restore state
            TBOnMouseMove(ptb, hwnd, WM_MOUSEMOVE, 0, (LPARAM)-1);
            ptb->pCaptureButton = NULL;
        }
        break;


    case WM_RBUTTONDOWN:

        if (ptb->pCaptureButton) {
            // abort current capture
            if (hwnd == GetCapture()) {
                // we were left clicking.   abort that now
                if (!CCReleaseCapture(&ptb->ci)) break;
                // simulate a lost capture mouse move.  this will restore state
                TBOnMouseMove(ptb, hwnd, WM_MOUSEMOVE, 0, (LPARAM)-1);
            }
        }

        iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

        // we need to check VK_RBUTTON because some apps subclass us to pick off rbuttondown to do their menu
        // (instead of up, or the notify, or wm_contextmenu)
        // then after it's done and the button is up, they then send us a button down
        if ((iPos >= 0) && (iPos < ptb->iNumButtons) && (GetAsyncKeyState(VK_RBUTTON) < 0))
        {
            ptb->pCaptureButton = ptb->Buttons + iPos;
            ptb->fRightDrag = TRUE;
            SetCapture(hwnd);
            GetMessagePosClient(ptb->ci.hwnd, &ptb->ptCapture);

            SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_BEGINDRAG);
            if (!IsWindow(hwnd)) break;
            ptb->fDragOutNotify = FALSE;
        }
        break;

    case WM_MOUSELEAVE:
        {
            TRACKMOUSEEVENT tme;

            // We only track mouse events on the flat style (for
            // hot tracking)
            ASSERT(ptb->ci.style & TBSTYLE_FLAT);

            // Cancel the mouse event tracking
            tme.cbSize = sizeof(TRACKMOUSEEVENT);
            tme.dwFlags = TME_CANCEL | TME_LEAVE;
            tme.hwndTrack = hwnd;
            TrackMouseEvent(&tme);
            ptb->fMouseTrack = FALSE;

            TBSetHotItem(ptb, -1, HICF_MOUSE);
        }
        break;

    case WM_MOUSEMOVE:
        TBOnMouseMove(ptb, hwnd, uMsg, wParam, lParam);
        break;

    case WM_LBUTTONUP:
        TBOnLButtonUp(ptb, hwnd, uMsg, wParam, lParam);
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        if (ptb->fFontCreated)
            TBChangeFont(ptb, wParam, NULL);
        if (ptb->hwndToolTips)
            SendMessage(ptb->hwndToolTips, uMsg, wParam, lParam);

        // recalc & redraw
        TBInitMetrics(ptb);
        TBRecalc(ptb);
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&ptb->ci, lParam);
        break;


    case WM_NOTIFY:
#define lpNmhdr ((LPNMHDR)(lParam))
        //The following statement traps all pager control notification messages.
        if((lpNmhdr->code <= PGN_FIRST)  && (lpNmhdr->code >= PGN_LAST)) {
            return TB_OnPagerControlNotify(ptb, lpNmhdr);
        }
    {
        LRESULT lres = 0;
        if (lpNmhdr->code == TTN_NEEDTEXT) {
            int i = PositionFromID(ptb, lpNmhdr->idFrom);
            BOOL fEllipsied = FALSE;
            LRESULT lres;
            LPTOOLTIPTEXT lpnmTT = ((LPTOOLTIPTEXT) lParam);

            if (i != -1) {
                // if infotip not supported, try for TTN_NEEDTEXT in client.
                if (!TBGetInfoTip(ptb, lpnmTT, &ptb->Buttons[i]))
                    lres = SendNotifyEx(ptb->ci.hwndParent, (HWND) -1,
                                        lpNmhdr->code, lpNmhdr, ptb->ci.bUnicode);

#define IsTextPtr(lpszText)  (((lpszText) != LPSTR_TEXTCALLBACK) && (!IS_INTRESOURCE(lpszText)))

                fEllipsied = (BOOL)(ptb->Buttons[i].fsState & TBSTATE_ELLIPSES);

                // if we don't get a string from TTN_NEEDTEXT try to use the title text.
                if ((lpNmhdr->code == TTN_NEEDTEXT) &&
                    (BTN_NO_SHOW_TEXT(ptb, &ptb->Buttons[i]) || fEllipsied) &&
                    lpnmTT->lpszText && IsTextPtr(lpnmTT->lpszText) &&
                    !lpnmTT->lpszText[0])
                {
                    LPCTSTR psz = TB_StrForButton(ptb, &ptb->Buttons[i]);
                    if (psz)
                        lpnmTT->lpszText = (LPTSTR)psz;
                }
            }
        } else {
            //
            // We are just going to pass this on to the
            // real parent.  Note that -1 is used as
            // the hwndFrom.  This prevents SendNotifyEx
            // from updating the NMHDR structure.
            //
            lres = SendNotifyEx(ptb->ci.hwndParent, (HWND) -1,
                                lpNmhdr->code, lpNmhdr, ptb->ci.bUnicode);
        }
        return(lres);
    }

    case WM_STYLECHANGING:
        if (wParam == GWL_STYLE)
        {
            LPSTYLESTRUCT lpStyle = (LPSTYLESTRUCT) lParam;

            // is MFC dorking with just our visibility bit?
            if ((lpStyle->styleOld ^ lpStyle->styleNew) == WS_VISIBLE)
            {
                if (lpStyle->styleNew & WS_VISIBLE)
                {
                    BOOL fSmooth = FALSE;
#ifdef CLEARTYPE    // Don't use SPI_CLEARTYPE because it's defined because of APIThk, but not in NT.
                    SystemParametersInfo(SPI_GETCLEARTYPE, 0, &fSmooth, 0);
#endif

                    // MFC trying to make us visible,
                    // convert it to WM_SETREDRAW instead.
                    DefWindowProc(hwnd, WM_SETREDRAW, TRUE, 0);

                    // Reinvalidate everything we lost when we
                    // did the WM_SETREDRAW stuff.
                    RedrawWindow(hwnd, &ptb->rcInvalid, NULL, (fSmooth? RDW_ERASE: 0)  | RDW_INVALIDATE | RDW_ALLCHILDREN);
                    ZeroMemory(&ptb->rcInvalid, SIZEOF(ptb->rcInvalid));
                }
                else
                {
                    // Save the invalid rectangle in ptb->rcInvalid since
                    // WM_SETREDRAW will blow it away.
                    ZeroMemory(&ptb->rcInvalid, SIZEOF(ptb->rcInvalid));
                    GetUpdateRect(ptb->ci.hwnd, &ptb->rcInvalid, FALSE);
                    EnumChildWindows(ptb->ci.hwnd, GetUpdateRectEnumProc, (LPARAM)ptb);

                    // MFC trying to make us invisible,
                    // convert it to WM_SETREDRAW instead.
                    DefWindowProc(hwnd, WM_SETREDRAW, FALSE, 0);
                }
            }
        }
        break;

    case WM_STYLECHANGED:
        if (wParam == GWL_STYLE)
        {
            TBSetStyle(ptb, ((LPSTYLESTRUCT)lParam)->styleNew);
        }
        else if (wParam == GWL_EXSTYLE)
        {
            //
            // If the RTL_MIRROR extended style bit had changed, let's
            // repaint the control window
            //
            if ((ptb->ci.dwExStyle&RTL_MIRRORED_WINDOW) !=
                (((LPSTYLESTRUCT)lParam)->styleNew&RTL_MIRRORED_WINDOW))
                TBAutoSize(ptb);

            //
            // Save the new ex-style bits
            //
            ptb->ci.dwExStyle = ((LPSTYLESTRUCT)lParam)->styleNew;

        }
        return 0;

    case TB_GETIDEALSIZE:
        {
            NMPGCALCSIZE nm;
            LPSIZE psize = (LPSIZE) lParam;
            ASSERT(psize);  // This should never be NULL
            nm.dwFlag = wParam ? PGF_CALCHEIGHT : PGF_CALCWIDTH;
            nm.iWidth = psize->cx;
            nm.iHeight = psize->cy;
            TB_OnCalcSize(ptb, (LPNMHDR)&nm);

            // Since both values may have changed, reset the out-param.
            psize->cy = nm.iHeight;
            psize->cx = nm.iWidth;
            return 1;
        }

    case TB_SETSTYLE:
        TBSetStyle(ptb, (DWORD) lParam);
        break;

    case TB_GETSTYLE:
        return (ptb->ci.style);

    case TB_GETBUTTONSIZE:
        return (MAKELONG(ptb->iButWidth,ptb->iButHeight));

    case TB_SETBUTTONWIDTH:
        if (ptb->iButMinWidth  != LOWORD(lParam) ||
            ptb->iButMaxWidth != HIWORD(lParam)) {

            ptb->iButMinWidth  = LOWORD(lParam);
            ptb->iButMaxWidth = HIWORD(lParam);
            ptb->iButWidth = 0;
            TBRecalc(ptb);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        return TRUE;

    case TB_TRANSLATEACCELERATOR:
        return TB_TranslateAccelerator(hwnd, (LPMSG)lParam);

    case TB_SETSTATE:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return FALSE;
        ptbButton = ptb->Buttons + iPos;

        TB_OnSetState(ptb, ptbButton, (BYTE)(LOWORD(lParam)), iPos);
        TBInvalidateItemRects(ptb);
        return TRUE;

    // set the cmd ID of a button based on its position
    case TB_SETCMDID:
        if (wParam >= (UINT)ptb->iNumButtons)
            return FALSE;

        TB_OnSetCmdID(ptb, &ptb->Buttons[wParam], (UINT)lParam);
        return TRUE;

    case TB_GETSTATE:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return -1L;
        return ptb->Buttons[iPos].fsState;

    case TB_MAPACCELERATORA:
    {
        char szAcl[2];
        WCHAR wszAcl[2];
        szAcl[0] = (BYTE)wParam;
        szAcl[1] = '\0';
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szAcl, ARRAYSIZE(szAcl), wszAcl, ARRAYSIZE(wszAcl));
        // no need to check return we just take junk if MbtoWc has failed
        wParam = (WPARAM)wszAcl[0];
    }
    // fall through...
    case TB_MAPACCELERATOR:
        return TBOnMapAccelerator(ptb, (UINT)wParam, (UINT *)lParam);

    case TB_ENABLEBUTTON:
    case TB_CHECKBUTTON:
    case TB_PRESSBUTTON:
    case TB_HIDEBUTTON:
    case TB_INDETERMINATE:
    case TB_MARKBUTTON:
    {
        BYTE fsState;

        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return FALSE;
        ptbButton = &ptb->Buttons[iPos];
        fsState = ptbButton->fsState;

        if (LOWORD(lParam))
            ptbButton->fsState |= wStateMasks[uMsg - TB_ENABLEBUTTON];
        else
            ptbButton->fsState &= ~wStateMasks[uMsg - TB_ENABLEBUTTON];

        // did this actually change the state?
        if (fsState != ptbButton->fsState) {
            // is this button a member of a group?
            if ((uMsg == TB_CHECKBUTTON) && (ptbButton->fsStyle & BTNS_GROUP))
                MakeGroupConsistant(ptb, (int)wParam);

            if (uMsg == TB_HIDEBUTTON) {
                InvalidateRect(hwnd, NULL, TRUE);
                TBInvalidateItemRects(ptb);
            } else
                InvalidateButton(ptb, ptbButton, TRUE);

            MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, iPos+1);
        }
        return(TRUE);
    }

    case TB_ISBUTTONENABLED:
    case TB_ISBUTTONCHECKED:
    case TB_ISBUTTONPRESSED:
    case TB_ISBUTTONHIDDEN:
    case TB_ISBUTTONINDETERMINATE:
    case TB_ISBUTTONHIGHLIGHTED:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return(-1L);
        return (LRESULT)ptb->Buttons[iPos].fsState & wStateMasks[uMsg - TB_ISBUTTONENABLED];

    case TB_ADDBITMAP:
    case TB_ADDBITMAP32:    // only for compatibility with mail
        {
            LPTBADDBITMAP pab = (LPTBADDBITMAP)lParam;
            return AddBitmap(ptb, (int) wParam, pab->hInst, pab->nID);
        }

    case TB_REPLACEBITMAP:
        return ReplaceBitmap(ptb, (LPTBREPLACEBITMAP)lParam);

    case TB_ADDSTRINGA:
        {
        LPWSTR lpStrings;
        UINT   uiCount;
        LPSTR  lpAnsiString = (LPSTR) lParam;
        int    iResult;
        BOOL   bAllocatedMem = FALSE;

        if (!wParam && !IS_INTRESOURCE(lpAnsiString)) {
            //
            // We have to figure out how many characters
            // are in this string.
            //
            
            uiCount = 0;

            while (TRUE) {
               uiCount++;
               if ((*lpAnsiString == 0) && (*(lpAnsiString+1) == 0)) {
                  uiCount++;  // needed for double null
                  break;
               }

               lpAnsiString++;
            }

            lpStrings = LocalAlloc(LPTR, uiCount * sizeof(TCHAR));

            if (!lpStrings)
                return -1;

            bAllocatedMem = TRUE;

            MultiByteToWideChar(CP_ACP, 0, (LPCSTR) lParam, uiCount, lpStrings, uiCount);

        } 
        else
        {
            lpStrings = (LPWSTR)lParam;
        }

        iResult = TBAddStrings(ptb, wParam, (LPARAM)lpStrings);

        if (bAllocatedMem)
            LocalFree(lpStrings);

        return iResult;
        }

    case TB_ADDSTRING:
        return TBAddStrings(ptb, wParam, lParam);

    case TB_GETSTRING:
        return TBGetString(ptb, HIWORD(wParam), LOWORD(wParam), (LPTSTR)lParam);

    case TB_GETSTRINGA:
        return TBGetStringA(ptb, HIWORD(wParam), LOWORD(wParam), (LPSTR)lParam);

    case TB_ADDBUTTONSA:
        return TBInsertButtons(ptb, (UINT)-1, (UINT) wParam, (LPTBBUTTON)lParam, FALSE);

    case TB_INSERTBUTTONA:
        return TBInsertButtons(ptb, (UINT) wParam, 1, (LPTBBUTTON)lParam, FALSE);

    case TB_ADDBUTTONS:
        return TBInsertButtons(ptb, (UINT)-1, (UINT) wParam, (LPTBBUTTON)lParam, TRUE);

    case TB_INSERTBUTTON:
        return TBInsertButtons(ptb, (UINT) wParam, 1, (LPTBBUTTON)lParam, TRUE);

    case TB_DELETEBUTTON:
        return DeleteButton(ptb, (UINT) wParam);

    case TB_GETBUTTON:
        if (wParam >= (UINT)ptb->iNumButtons)
            return(FALSE);

        TBOutputStruct(ptb, ptb->Buttons + wParam, (LPTBBUTTON)lParam);
        return TRUE;

    case TB_SETANCHORHIGHLIGHT:
        BLOCK
        {
            BOOL bAnchor = BOOLIFY(ptb->fAnchorHighlight);
            ptb->fAnchorHighlight = BOOLFROMPTR(wParam);
            return bAnchor;
        }
        break;

    case TB_GETANCHORHIGHLIGHT:
        return BOOLIFY(ptb->fAnchorHighlight);

    case TB_HASACCELERATOR:
        ASSERT(IS_VALID_WRITE_PTR(lParam, int*));
        *((int*)lParam) = TBHasAccelerator(ptb, (UINT)wParam);
        break;

    case TB_SETHOTITEM:
        lParam = HICF_OTHER;
        // Fall through
    case TB_SETHOTITEM2:
        BLOCK
        {
            int iPos = ptb->iHot;

            TBSetHotItem(ptb, (int)wParam, (DWORD)lParam);
            return iPos;
        }
        break;

    case TB_GETHOTITEM:
        return ptb->iHot;

    case TB_SETINSERTMARK:
        TBSetInsertMark(ptb, (LPTBINSERTMARK)lParam);
        break;

    case TB_GETINSERTMARK:
    {
        LPTBINSERTMARK ptbim = (LPTBINSERTMARK)lParam;

        ptbim->iButton = ptb->iInsert;
        ptbim->dwFlags = ptb->fInsertAfter ? TBIMHT_AFTER : 0;
        return TRUE;
    }

    case TB_SETINSERTMARKCOLOR:
    {
        LRESULT lres = (LRESULT)TB_GetInsertMarkColor(ptb);
        ptb->clrim = (COLORREF) lParam;
        return lres;
    }

    case TB_GETINSERTMARKCOLOR:
        return TB_GetInsertMarkColor(ptb);

    case TB_INSERTMARKHITTEST:
    return (LRESULT)TBInsertMarkHitTest(ptb, ((LPPOINT)wParam)->x, ((LPPOINT)wParam)->y, (LPTBINSERTMARK)lParam);

    case TB_MOVEBUTTON:
        return (LRESULT)TBMoveButton(ptb, (UINT)wParam, (UINT)lParam);

    case TB_GETMAXSIZE:
        return (LRESULT)TBGetMaxSize(ptb, (LPSIZE) lParam );

    case TB_BUTTONCOUNT:
        return ptb->iNumButtons;

    case TB_COMMANDTOINDEX:
        return PositionFromID(ptb, wParam);

    case TB_SAVERESTOREA:
        {
        LPWSTR lpSubKeyW, lpValueNameW;
        TBSAVEPARAMSA * lpSaveA = (TBSAVEPARAMSA *) lParam;
        BOOL bResult;

        lpSubKeyW = ProduceWFromA (CP_ACP, lpSaveA->pszSubKey);
        lpValueNameW = ProduceWFromA (CP_ACP, lpSaveA->pszValueName);

        bResult = SaveRestoreFromReg(ptb, (BOOL) wParam, lpSaveA->hkr, lpSubKeyW, lpValueNameW);

        FreeProducedString(lpSubKeyW);
        FreeProducedString(lpValueNameW);

        return bResult;
        }

    case TB_SAVERESTORE:
        {
            TBSAVEPARAMS* psr = (TBSAVEPARAMS *)lParam;
            return SaveRestoreFromReg(ptb, (BOOL) wParam, psr->hkr, psr->pszSubKey, psr->pszValueName);
        }

    case TB_CUSTOMIZE:
        CustomizeTB(ptb, ptb->iNumButtons);
        break;

    case TB_GETRECT:
        // PositionFromID() accepts NULL ptbs!
        wParam = PositionFromID(ptb, wParam);
        // fall through
    case TB_GETITEMRECT:
        if (!lParam)
            break;
        return TB_GetItemRect(ptb, (UINT) wParam, (LPRECT)lParam);

    case TB_BUTTONSTRUCTSIZE:
        TBOnButtonStructSize(ptb, (UINT) wParam);
        break;

    case TB_SETBUTTONSIZE:
        return GrowToolbar(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), 0);

    case TB_SETBITMAPSIZE:
        return SetBitmapSize(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    case TB_SETIMAGELIST:
    {
        HIMAGELIST himl = (HIMAGELIST)lParam;
        HIMAGELIST himlOld = TBSetImageList(ptb, HIML_NORMAL, (int) wParam, himl);
        ptb->fHimlNative = TRUE;

        if (!ptb->uStructSize) {
            // let people get away without calling TB_BUTTONSTRUCTSIZE... no other control requires this
            ptb->uStructSize = 20;
            ASSERT(ptb->uStructSize == SIZEOF(TBBUTTON));
        }

        // The bitmap size is based on the primary image list
        if (wParam == 0)
        {
            int cx = 0, cy = 0;
            if (himl) {
                // Update the bitmap size based on this image list
                ImageList_GetIconSize(himl, &cx, &cy);
            }
            SetBitmapSize(ptb, cx, cy);
        }

        return (LRESULT)himlOld;
    }

    case TB_GETIMAGELIST:
        return (LRESULT)TBGetImageList(ptb, HIML_NORMAL, (int) wParam);

    case TB_GETIMAGELISTCOUNT:
        return ptb->cPimgs;

    case TB_SETHOTIMAGELIST:
        return (LRESULT)TBSetImageList(ptb, HIML_HOT, (int) wParam, (HIMAGELIST)lParam);

    case TB_GETHOTIMAGELIST:
        return (LRESULT)TBGetImageList(ptb, HIML_HOT, (int) wParam);

    case TB_GETDISABLEDIMAGELIST:
        return (LRESULT)TBGetImageList(ptb, HIML_DISABLED, (int) wParam);

    case TB_SETDISABLEDIMAGELIST:
        return (LRESULT)TBSetImageList(ptb, HIML_DISABLED, (int) wParam, (HIMAGELIST)lParam);

    case TB_GETOBJECT:
        if (IsEqualIID((IID *)wParam, &IID_IDropTarget))
        {
            // if we have not already registered create an unregistered target now
            if (ptb->hDragProxy == NULL)
                ptb->hDragProxy = CreateDragProxy(ptb->ci.hwnd, ToolbarDragCallback, FALSE);

            if (ptb->hDragProxy)
                return (LRESULT)GetDragProxyTarget(ptb->hDragProxy, (IDropTarget **)lParam);
        }
        return E_FAIL;

    case WM_GETFONT:
        return (LRESULT)(ptb? ptb->hfontIcon : 0);

    case TB_LOADIMAGES:
        return TBLoadImages(ptb, (UINT_PTR) wParam, (HINSTANCE)lParam);

    case TB_GETTOOLTIPS:
        TB_ForceCreateTooltips(ptb);
        return (LRESULT)ptb->hwndToolTips;

    case TB_SETTOOLTIPS:
        ptb->hwndToolTips = (HWND)wParam;
        break;

    case TB_SETPARENT:
        {
            HWND hwndOld = ptb->ci.hwndParent;

        ptb->ci.hwndParent = (HWND)wParam;
        return (LRESULT)hwndOld;
        }

    case TB_GETBUTTONINFOA:
        return TB_OnGetButtonInfoA(ptb, (int)wParam, (LPTBBUTTONINFOA)lParam);

    case TB_SETBUTTONINFOA:
        return TB_OnSetButtonInfoA(ptb, (int)wParam, (LPTBBUTTONINFOA)lParam);

    case TB_GETBUTTONINFO:
        return TB_OnGetButtonInfo(ptb, (int)wParam, (LPTBBUTTONINFO)lParam);

    case TB_SETBUTTONINFO:
        return TB_OnSetButtonInfo(ptb, (int)wParam, (LPTBBUTTONINFO)lParam);

    case TB_CHANGEBITMAP:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return(FALSE);

        //
        // Check to see if the new bitmap ID is
        // valid.
        //
        ptbButton = &ptb->Buttons[iPos];
        return TB_OnSetImage(ptb, ptbButton, LOWORD(lParam));

    case TB_GETBITMAP:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return(FALSE);
        ptbButton = &ptb->Buttons[iPos];
        return ptbButton->DUMMYUNION_MEMBER(iBitmap);

    case TB_GETBUTTONTEXTA:
        iPos = PositionFromID(ptb, wParam);
        if (iPos >= 0) {
            LPTSTR psz;

            ptbButton = &ptb->Buttons[iPos];
            psz = TB_StrForButton(ptb, ptbButton);
            if (psz)
            {
                // Passing a 0 for the length of the buffer when the
                // buffer is NULL returns the number bytes required
                // to convert the string.
                int cbBuff = WideCharToMultiByte(CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL);

                // We used to pass an obscenly large number for the buffer length,
                // but on checked builds, this causes badness. So no we double-dip
                // into WideCharToMultiByte to calculate the real size required.
                if (lParam)
                {
                    WideCharToMultiByte(CP_ACP, 0, psz, -1, (LPSTR)lParam, cbBuff, NULL, NULL);
                }

                // WideChar include a trailing NULL but we don't want to.
                return cbBuff - 1;
            }
        }
        return -1;

    case TB_GETBUTTONTEXT:
        iPos = PositionFromID(ptb, wParam);
        if (iPos >= 0)
        {
            LPCTSTR psz;

            ptbButton = &ptb->Buttons[iPos];
            psz = TB_StrForButton(ptb, ptbButton);
            if (psz)
            {
                DWORD cch = lstrlen(psz);
                if (lParam)
                {
                    // REVIEW: message parameters do not indicate the size of the
                    // destination buffer.
                    StringCchCopy((LPTSTR)lParam, cch+1, psz);
                }
                return cch;
            }
        }
        return -1;


    case TB_GETBITMAPFLAGS:
        {
            DWORD fFlags = 0;
            HDC hdc = GetDC(NULL);

            if (GetDeviceCaps(hdc, LOGPIXELSY) >= 120)
                fFlags |= TBBF_LARGE;

            ReleaseDC(NULL, hdc);

            return fFlags;
        }

    case TB_SETINDENT:
        ptb->xFirstButton = (int) wParam;
        InvalidateRect (hwnd, NULL, TRUE);
        TBInvalidateItemRects(ptb);
        return 1;

    case TB_SETMAXTEXTROWS:

        if (ptb->nTextRows != (int)wParam) {
            ptb->nTextRows = (int) wParam;
            TBRecalc(ptb);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        return 1;

    case TB_SETLISTGAP:
        ptb->iListGap = (int) wParam;
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case TB_SETDROPDOWNGAP:
        ptb->iDropDownGap = (int) wParam;
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case TB_GETTEXTROWS:
        return ptb->nTextRows;

    case TB_HITTEST:
        return TBHitTest(ptb, ((LPPOINT)lParam)->x, ((LPPOINT)lParam)->y);

    case TB_SETDRAWTEXTFLAGS:
    {
        UINT uOld = ptb->uDrawText;
        ptb->uDrawText = (UINT) (lParam & wParam);
        ptb->uDrawTextMask = (UINT) wParam;
        return uOld;
    }

    case TB_GETEXTENDEDSTYLE:
        return (ptb->dwStyleEx);

    case TB_SETEXTENDEDSTYLE:
    {
        DWORD dwRet = ptb->dwStyleEx;
        TBSetStyleEx(ptb, (DWORD) lParam, (DWORD) wParam);
        return dwRet;
    }
    case TB_SETBOUNDINGSIZE:
    {
        LPSIZE lpSize = (LPSIZE)lParam;
        ptb->sizeBound = *lpSize;
        break;
    }
    case TB_GETCOLORSCHEME:
    {
        LPCOLORSCHEME lpclrsc = (LPCOLORSCHEME) lParam;
        if (lpclrsc) {
            if (lpclrsc->dwSize == sizeof(COLORSCHEME))
                *lpclrsc = ptb->clrsc;
        }
        return (LRESULT) lpclrsc;
    }

    case TB_SETCOLORSCHEME:
    {
        if (lParam) {
            if (((LPCOLORSCHEME) lParam)->dwSize == sizeof(COLORSCHEME)) {
                ptb->clrsc.clrBtnHighlight = ((LPCOLORSCHEME) lParam)->clrBtnHighlight;
                ptb->clrsc.clrBtnShadow = ((LPCOLORSCHEME) lParam)->clrBtnShadow;
                InvalidateRect(hwnd, NULL, FALSE);
                if (ptb->ci.style & WS_BORDER)
                    CCInvalidateFrame(hwnd);
            }
        }
    }
    break;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_TOOLBAR;
        goto DoDefault;

    case WM_NULL:
            // Trap failed RegsiterWindowMessages;
        break;

    default:
    {
        LRESULT lres;
        if (g_uDragImages == uMsg)
            return TBGenerateDragImage(ptb, (SHDRAGIMAGE*)lParam);

        if (CCWndProc(&ptb->ci, uMsg, wParam, lParam, &lres))
            return lres;
    }
DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}


int TB_CalcWidth(PTBSTATE ptb, int iHeight)
{
    RECT rc;
    int iWidth = 0;
    int iMaxBtnWidth = 0;  // ptb->iButWidth isn't always width of widest button
    LPTBBUTTONDATA pButton, pBtnLast;
    pBtnLast = &(ptb->Buttons[ptb->iNumButtons]);

    for(pButton = ptb->Buttons; pButton < pBtnLast; pButton++)
    {
        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            int iBtnWidth = TBWidthOfButton(ptb, pButton, NULL);
            iWidth += iBtnWidth - s_dxOverlap;
            iMaxBtnWidth = max(iMaxBtnWidth, iBtnWidth);
        }

    }

    if (ptb->ci.style & TBSTYLE_WRAPABLE) {
        //Make sure the height is a multiple of button height
        iHeight -= (iHeight % ptb->iButHeight);
        if (iHeight < ptb->iButHeight)
            iHeight = ptb->iButHeight;

        WrapToolbar(ptb, iWidth, &rc, NULL);

        // if wrapping at full width gives us a height that's too big,
        // then there's nothing we can do because widening it still keeps us at 1 row
        if (iHeight > RECTHEIGHT(rc)) {
            int iPrevWidth;
            BOOL fDivide = TRUE; //first start by dividing for speed, then narrow it down by subtraction

            TraceMsg(TF_TOOLBAR, "Toolbar: performing expensive width calculation!");

            while (iMaxBtnWidth < iWidth) {
                iPrevWidth = iWidth;
                if (fDivide)
                    iWidth = (iWidth * 2) / 3;
                else
                    iWidth -= ptb->iButWidth;

                if (iWidth == iPrevWidth)
                    break;

                WrapToolbar(ptb, iWidth, &rc, NULL);

                if (iHeight < RECTHEIGHT(rc)) {
                    iWidth = iPrevWidth;
                    if (fDivide) {
                        // we've overstepped on dividing.  go to the previous width
                        // that was ok, and now try subtracting one button at a time
                        fDivide = FALSE;
                    } else
                        break;
                }
            };

            WrapToolbar(ptb, iWidth, &rc, NULL);
            iWidth = max(RECTWIDTH(rc), iMaxBtnWidth);
        }


        // WrapToolbar above has the side effect of actually modifying
        // the layout.  we need to restore it after doing all this calculations
        TBAutoSize(ptb);
    }

    return iWidth;
}


LRESULT TB_OnScroll(PTBSTATE ptb, LPNMHDR pnm)
{
    POINT pt, ptTemp;
    LPNMPGSCROLL pscroll = (LPNMPGSCROLL)pnm;
    int iDir = pscroll->iDir;
    RECT rcTemp, rc = pscroll->rcParent;
    int parentsize = 0;
    int scroll = pscroll->iScroll;
    int iButton = 0;
    int iButtonSize  = ptb->iButHeight;
    int y = 0;
    int iCurrentButton = 0;
   //This variable holds the number of buttons in a row
    int iButInRow = 0;

    pt.x = pscroll->iXpos;
    pt.y = pscroll->iYpos;
    ptTemp = pt;

    //We need to add the offset of the toolbar to the scroll position to get the
    //correct scroll positon in terms of toolbar window
    pt.x += ptb->xFirstButton;
    pt.y += ptb->iYPos;
    ptTemp = pt;


    if ((iDir == PGF_SCROLLUP) || (iDir == PGF_SCROLLDOWN))
    {
        //Vertical Mode
        if (ptb->iButWidth == 0 )
        {
            iButInRow = 1;
        }
        else
        {
            iButInRow = RECTWIDTH(rc) / ptb->iButWidth;
        }

    }
    else
    {
        //Horizontal Mode
        iButInRow =  1;
    }
    // if the parent height/width is less than button height/width then set the  number of
    // buttons in a row to be 1
    if (0 == iButInRow)
    {
        iButInRow = 1;
    }

    iCurrentButton = TBHitTest(ptb, pt.x + 1, pt.y + 1);

    //if the button is negative then we have hit a seperator.
    //Convert the index of the seperator into button index
    if (iCurrentButton < 0)
         iCurrentButton = -iCurrentButton - 1;

    switch ( iDir )
    {
    case PGF_SCROLLUP:
    case PGF_SCROLLLEFT:
        if(iDir == PGF_SCROLLLEFT)
        {
            FlipRect(&rc);
            FlipPoint(&pt);
            FlipPoint(&ptTemp);
            iButtonSize = ptb->iButWidth;
        }

        //Check if any button is partially visible at the left/top. if so then set the bottom
        // of that button to be our current offset and then scroll. This avoids skipping over
        // certain buttons when partial buttons are displayed at the left or top
        y = pt.y;
        TB_GetItemRect(ptb, iCurrentButton, &rcTemp);
        if(iDir == PGF_SCROLLLEFT)
        {
            FlipRect(&rcTemp);
        }

        if (rcTemp.top  <  y-1)
        {
            iCurrentButton += iButInRow;
        }

        //Now do the actual calculation

        parentsize = RECTHEIGHT(rc);

        //if  the control key is down and we have more than parentsize size of child window
        // then scroll by that amount
        if (pscroll->fwKeys & PGK_CONTROL)

        {
            if ((y - parentsize) > 0 )
            {
                scroll = parentsize;
            }
            else
            {
                scroll = y;
                return 0L;
            }

        } else  if ((y - iButtonSize) > 0 ){
        // we dont have control key down so scroll by one buttonsize
            scroll = iButtonSize;

        } else {
            scroll = pt.y;
            return 0L;
        }
        ptTemp.y -= scroll;

        if(iDir == PGF_SCROLLLEFT)
        {
            FlipPoint(&ptTemp);
        }

        iButton = TBHitTest(ptb, ptTemp.x, ptTemp.y);

        //if the button is negative then we have hit a seperator.
        //Convert the index of the seperator into button index
        if (iButton < 0)
            iButton = -iButton -1 ;

       // if  the hit test gives us the same button as our prevbutton then set the button
       // to one button to the left  of the prev button

       if ((iButton == iCurrentButton) && (iButton >= iButInRow))
       {
           iButton -= iButInRow;
           if ((ptb->Buttons[iButton].fsStyle & BTNS_SEP)  && (iButton >= iButInRow))
           {
               iButton -= iButInRow;
           }
       }
       //When scrolling left if we end up in the middle of some button then we align it to the
       //right of that button this is to avoid scrolling more than the pager window width but if the
       // button happens to be the left button of  our current button then we end up in not scrolling
       //if thats the case then move one more button to the left.


       if (iButton == iCurrentButton-iButInRow)
       {
           iButton -= iButInRow;
       }

       TB_GetItemRect(ptb, iButton, &rcTemp);
       if(iDir == PGF_SCROLLLEFT)
       {
           FlipRect(&rcTemp);
       }
       scroll = pt.y - rcTemp.bottom;
       //Set the scroll value
       pscroll->iScroll = scroll;
       break;

    case PGF_SCROLLDOWN:
    case PGF_SCROLLRIGHT:
        {
            RECT rcChild;
            int childsize;

            GetWindowRect(ptb->ci.hwnd, &rcChild);
            if( iDir == PGF_SCROLLRIGHT)
            {
                FlipRect(&rcChild);
                FlipRect(&rc);
                FlipPoint(&pt);
                FlipPoint(&ptTemp);
                iButtonSize = ptb->iButWidth;
            }

            childsize = RECTHEIGHT(rcChild);
            parentsize = RECTHEIGHT(rc);

            //if  the control key is down and we have more than parentsize size of child window
            // then scroll by that amount

            if (pscroll->fwKeys & PGK_CONTROL)
            {
                if ((childsize - pt.y - parentsize) > parentsize)
                {
                    scroll = parentsize;
                }
                else
                {
                    scroll = childsize - pt.y - parentsize;
                    return 0L;
                }

            } else if (childsize - pt.y - parentsize > iButtonSize) {
            // we dont have control key down so scroll by one buttonsize
                scroll = iButtonSize;

            } else {
                pscroll->iScroll = childsize - pt.y - parentsize;
                return 0L;
            }
            ptTemp.y += scroll;

            if(iDir == PGF_SCROLLRIGHT)
            {
                FlipPoint(&ptTemp);
            }

            iButton = TBHitTest(ptb, ptTemp.x, ptTemp.y);

            //if the button is negative then we have hit a seperator.
            //Convert the index of the seperator into button index
                if (iButton < 0)
                iButton = -iButton - 1 ;

            if ((iButton == iCurrentButton) && ((iButton + iButInRow) < ptb->iNumButtons))
            {
                iButton += iButInRow;
                if ((ptb->Buttons[iButton].fsStyle & BTNS_SEP)  && ((iButton + iButInRow) < ptb->iNumButtons))
                {
                    iButton += iButInRow;
                }
            }

            TB_GetItemRect(ptb, iButton, &rcTemp);
            if(iDir == PGF_SCROLLRIGHT)
            {
                FlipRect(&rcTemp);
            }
            scroll = rcTemp.top  - pt.y ;

            //Set the scroll value
            pscroll->iScroll = scroll;
            break;
        }
    }
    return 0L;
}

int TB_CalcHeight(PTBSTATE ptb)
{
    int iHeight = 0;
    int i;

    ASSERT(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL);
    ASSERT(!(ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN));

    for (i = 0; i < ptb->iNumButtons; i++)
    {
        if (!(ptb->Buttons[i].fsState & TBSTATE_HIDDEN))
        {
            if (ptb->Buttons[i].fsStyle & BTNS_SEP)
                iHeight += (TBGetSepHeight(ptb, &ptb->Buttons[i]));
            else
                iHeight += ptb->iButHeight;
        }
    }

    return iHeight;
}

LRESULT TB_OnCalcSize(PTBSTATE ptb, LPNMHDR pnm)
{
    LPNMPGCALCSIZE pcalcsize = (LPNMPGCALCSIZE)pnm;
    RECT rc;

    switch(pcalcsize->dwFlag)
    {
    case PGF_CALCHEIGHT:

        if (ptb->szCached.cx == pcalcsize->iWidth)
            pcalcsize->iHeight = ptb->szCached.cy;
        else
        {
            if (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
            {
                WrapToolbarCol(ptb, ptb->sizeBound.cy,  &rc, NULL);
                pcalcsize->iWidth = RECTWIDTH(rc);
                pcalcsize->iHeight = RECTHEIGHT(rc);
            }
            else if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
            {
                pcalcsize->iHeight = TB_CalcHeight(ptb);
            }
            else
            {
                // BUGBUG: this WrapToolbar call can modify toolbar layout ...
                // seems busted.  should perhaps call TBAutoSize after to restore.
                WrapToolbar(ptb, pcalcsize->iWidth,  &rc, NULL);
                pcalcsize->iHeight = RECTHEIGHT(rc);
            }
        }
        break;

    case PGF_CALCWIDTH:
        if (ptb->szCached.cy == pcalcsize->iHeight) {
            pcalcsize->iWidth = ptb->szCached.cx;
        } else {
            pcalcsize->iWidth = TB_CalcWidth(ptb, pcalcsize->iHeight);
        }
        break;
    }

    ptb->szCached.cx = pcalcsize->iWidth;
    ptb->szCached.cy = pcalcsize->iHeight;
    return 0L;
}

LRESULT TB_OnPagerControlNotify(PTBSTATE ptb, LPNMHDR pnm)
{
    switch(pnm->code) {
    case PGN_SCROLL:
        return TB_OnScroll(ptb, pnm);
        break;
    case PGN_CALCSIZE:
        return TB_OnCalcSize(ptb, pnm);
        break;
    }
    return 0L;
}


BOOL TBGetMaxSize( PTBSTATE ptb, LPSIZE lpsize )
{
    // need to calc the number of buttons and then the number of separators...
    int iButton;
    LPTBBUTTONDATA pAllButtons = ptb->Buttons;
    int iRealButtons = 0;
    int iSeparators = 0;

    if ( !lpsize )
        return FALSE;
    if (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
    {
        ASSERT(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL);
        lpsize->cx = RECTWIDTH(ptb->rc);
        lpsize->cy = RECTHEIGHT(ptb->rc);
        return TRUE;
    }
    for (iButton = 0; iButton < ptb->iNumButtons; iButton++)
    {
        LPTBBUTTONDATA pButton = &pAllButtons[iButton];

        if (!( pButton->fsState & TBSTATE_HIDDEN ))
        {
            if ( pButton->fsStyle & BTNS_SEP )
                iSeparators ++;
            else
                iRealButtons ++;
        }
    }

    // BUGBUG: g_dxButtonSep is handy, but what if the separator style changes,
    // BUGBUG: for example we don't distinguish between flat and non-flat separators..
    if ( ptb->ci.style & CCS_VERT )
    {
        // we are vertical ...
        lpsize->cx = ptb->iButWidth;
        lpsize->cy = ptb->iButHeight * iRealButtons + g_dxButtonSep * iSeparators;
    }
    else
    {
        lpsize->cx = ptb->iButWidth * iRealButtons + g_dxButtonSep * iSeparators;
        lpsize->cy = ptb->iButHeight;
    }
    return TRUE;
}


void TBGetItem(PTBSTATE ptb, LPTBBUTTONDATA ptButton, LPNMTBDISPINFO ptbdi)
{

    ptbdi->idCommand = ptButton->idCommand;
    ptbdi->iImage  =  -1;
    ptbdi->lParam  = ptButton->dwData;


    CCSendNotify(&ptb->ci, TBN_GETDISPINFO, &(ptbdi->hdr));

    if(ptbdi->dwMask & TBNF_DI_SETITEM) {
        if(ptbdi->dwMask & TBNF_IMAGE)
            ptButton->DUMMYUNION_MEMBER(iBitmap) = ptbdi->iImage;
    }

}

BOOL TBGetInfoTip(PTBSTATE ptb, LPTOOLTIPTEXT lpttt, LPTBBUTTONDATA pTBButton)
{
    NMTBGETINFOTIP git;
    TCHAR   szBuf[INFOTIPSIZE];

    szBuf[0] = 0;
    git.pszText = szBuf;
    git.cchTextMax = ARRAYSIZE(szBuf);
    git.iItem = pTBButton->idCommand;
    git.lParam = pTBButton->dwData;

    CCSendNotify(&ptb->ci, TBN_GETINFOTIP, &git.hdr);

    if (git.pszText && git.pszText[0]) {
        // if they didn't fill anything in, go to the default stuff
        // without modifying the notify structure

        Str_Set(&ptb->pszTip, git.pszText);
        lpttt->lpszText = ptb->pszTip;
        return lpttt->lpszText && lpttt->lpszText[0];
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\tbcust.c ===
#include "ctlspriv.h"
#include "toolbar.h"
#include "help.h" // Help IDs

#define SEND_WM_COMMAND(hwnd, id, hwndCtl, codeNotify) \
    (void)SendMessage((hwnd), WM_COMMAND, MAKEWPARAM((UINT)(id),(UINT)(codeNotify)), (LPARAM)(HWND)(hwndCtl))

#define SPACESTRLEN 20

#define FLAG_NODEL  0x8000
#define FLAG_HIDDEN 0x4000
#define FLAG_SEP    0x2000
#define FLAG_ALLFLAGS   (FLAG_NODEL|FLAG_HIDDEN|FLAG_SEP)

typedef struct {        /* instance data for toolbar edit dialog */
    HWND hDlg;          /* dialog hwnd */
    PTBSTATE ptb;       // current toolbar state
    int iPos;           /* position to insert into */
} ADJUSTDLGDATA, *LPADJUSTDLGDATA;


int g_dyButtonHack = 0;     // to pass on before WM_INITDIALOG

LPTSTR TB_StrForButton(PTBSTATE ptb, LPTBBUTTONDATA pTBButton);

int GetPrevButton(PTBSTATE ptb, int iPos)
{
    /* This means to delete the preceding space
     */
    for (--iPos; ; --iPos)
    {
        if (iPos < 0)
            break;

        if (!(ptb->Buttons[iPos].fsState & TBSTATE_HIDDEN))
            break;;
    }

    return(iPos);
}

BOOL GetAdjustInfo(PTBSTATE ptb, int iItem, LPTBBUTTONDATA ptbButton, LPTSTR lpString, int cbString)
{
    TBNOTIFY tbn;
    tbn.pszText = lpString;
    tbn.cchText = cbString;
    tbn.iItem = iItem;

    if (lpString)
        *lpString = 0;

    if ((BOOL)CCSendNotify(&ptb->ci, TBN_GETBUTTONINFO, &tbn.hdr))
    {
        TBInputStruct(ptb, ptbButton, &tbn.tbButton);
        return TRUE;
    }
    return FALSE;
}

LRESULT SendItemNotify(PTBSTATE ptb, int iItem, int code)
{
    TBNOTIFY tbn = {0};
    tbn.iItem = iItem;

    switch (code) {

    case TBN_QUERYDELETE:
    case TBN_QUERYINSERT:
        // The following is to provide the parent app with information
        // about the button that information is being requested for...
        // Otherwise it's really awful trying to have control over
        // certain aspects of toolbar customization... [t-mkim]
        // IE4.0's toolbar wants this information.
        //      Should ONLY be done for TBN_QUERY* notifications BECAUSE
        //      this can be either a zero-based index _or_ Command ID depending
        //      on the particular notification code.
        if (iItem < ptb->iNumButtons)
            CopyMemory (&tbn.tbButton, &ptb->Buttons[iItem], sizeof (TBBUTTON));
        break;

    case TBN_DROPDOWN:
        TB_GetItemRect(ptb, PositionFromID(ptb, iItem), &tbn.rcButton);
        break;
    }

    // default return from SendNotify is false
    // this actually shouldnt return a bool, TBN_DROPDOWN needs to return 0, 1, or 2.
    return CCSendNotify(&ptb->ci, code, &tbn.hdr);
}

#define SendCmdNotify(ptb, code)   CCSendNotify(&ptb->ci, code, NULL)


// this is used to deal with the case where the ptb structure is re-alloced
// after a TBInsertButtons()

PTBSTATE FixPTB(HWND hwnd)
{
    PTBSTATE ptb = (PTBSTATE)GetWindowInt(hwnd, 0);

    if (ptb->hdlgCust)
    {
        LPADJUSTDLGDATA lpad = (LPADJUSTDLGDATA)GetWindowPtr(ptb->hdlgCust, DWLP_USER);
#ifdef DEBUG
        if (lpad->ptb != ptb)
            DebugMsg(DM_TRACE, TEXT("Fixing busted ptb pointer"));
#endif
        lpad->ptb = ptb;
    }
    return ptb;
}


void MoveButton(PTBSTATE ptb, int nSource)
{
    int nDest;
    RECT rc;
    HCURSOR hCursor;
    MSG32 msg32;

    /* You can't move separators like this
     */
    if (nSource < 0)
        return;

    // Make sure it is all right to "delete" the selected button
    if (!SendItemNotify(ptb, nSource, TBN_QUERYDELETE))
        return;

    hCursor = SetCursor(LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_MOVEBUTTON)));
    SetCapture(ptb->ci.hwnd);

    // Get the dimension of the window.
    GetClientRect(ptb->ci.hwnd, &rc);
    for ( ; ; )
    {
        while (!PeekMessage32(&msg32, NULL, 0, 0, PM_REMOVE, TRUE))
            ;

        if (GetCapture() != ptb->ci.hwnd)
            goto AbortMove;

        // See if the application wants to process the message...
        if (CallMsgFilter32(&msg32, MSGF_COMMCTRL_TOOLBARCUST, TRUE) != 0)
            continue;


        switch (msg32.message)
        {
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:
            //notify of navigation key usage
            CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS);
            break;

        case WM_LBUTTONUP:
            RelayToToolTips(ptb->hwndToolTips, ptb->ci.hwnd, msg32.message, msg32.wParam, msg32.lParam);
            if ((GET_Y_LPARAM(msg32.lParam) > (short)(rc.bottom+ptb->iButWidth)) ||
                (GET_X_LPARAM(msg32.lParam) > (short)(rc.right+ptb->iButWidth)) ||
                (GET_Y_LPARAM(msg32.lParam) < -ptb->iButWidth) ||
                (GET_X_LPARAM(msg32.lParam) < -ptb->iButWidth))

            {
                /* If the button was dragged off the toolbar, delete it.
                 */
DeleteSrcButton:
                DeleteButton(ptb, nSource);
                SendCmdNotify(ptb, TBN_TOOLBARCHANGE);
                TBInvalidateItemRects(ptb);
            }
            else
            {
                TBBUTTONDATA tbbAdd;

                /* Add half a button to X so that it looks like it is centered
                 * over the target button, iff we have a horizontal layout.
                 * Add half a button to Y otherwise.
                 */
                if (rc.right!=ptb->iButWidth)
                    nDest = TBHitTest(ptb,
                                      GET_X_LPARAM(msg32.lParam) + ptb->iButWidth / 2,
                                      GET_Y_LPARAM(msg32.lParam));
                else
                    nDest = TBHitTest(ptb,
                                      GET_X_LPARAM(msg32.lParam),
                                      GET_Y_LPARAM(msg32.lParam) + ptb->iButHeight / 2);

                if (nDest < 0)
                    nDest = -1 - nDest;

                if (nDest>0 &&
                    (ptb->Buttons[nDest-1].fsState & TBSTATE_WRAP) &&
                    GET_X_LPARAM(msg32.lParam)>ptb->iButWidth &&
                    SendItemNotify(ptb, --nDest, TBN_QUERYINSERT))
                {
                    tbbAdd = ptb->Buttons[nSource];
                    DeleteButton(ptb, nSource);
                    if (nDest>nSource)
                        --nDest;

                    /* Insert before spaces, but after buttons. */
                    if (!(ptb->Buttons[nDest].fsStyle & TBSTYLE_SEP))
                        nDest++;

                    goto InsertSrcButton;
                }
                else if (nDest == nSource)
                {
                    /* This means to delete the preceding space, or to move a
                    button to the previous row.
                    */
                    nSource = GetPrevButton(ptb, nSource);
                    if (nSource < 0)
                        goto AbortMove;

                    // If the preceding item is a space with no ID, and
                    // the app says it's OK, then delete it.
                    if ((ptb->Buttons[nSource].fsStyle & TBSTYLE_SEP)
                        && !ptb->Buttons[nSource].idCommand
                        && SendItemNotify(ptb, nSource, TBN_QUERYDELETE))
                        goto DeleteSrcButton;
                }
                else if (nDest == nSource+1)
                {
                    // This means to add a preceding space
                    --nDest;
                    if (SendItemNotify(ptb, nDest, TBN_QUERYINSERT))
                    {
                        tbbAdd.DUMMYUNION_MEMBER(iBitmap) = 0;
                        tbbAdd.idCommand = 0;
                        tbbAdd.iString = -1;
                        tbbAdd.fsState = 0;
                        tbbAdd.fsStyle = TBSTYLE_SEP;
                        goto InsertSrcButton;
                    }
                }
                else if (SendItemNotify(ptb, nDest, TBN_QUERYINSERT))
                {
                    HWND hwndT;
                    TBBUTTON tbbAddExt;

                    /* This is a normal move operation
                     */
                    tbbAdd = ptb->Buttons[nSource];

                    ptb->Buttons[nSource].iString = -1;
                    DeleteButton(ptb, nSource);
                    if (nDest > nSource)
                        --nDest;
InsertSrcButton:
                    hwndT = ptb->ci.hwnd;

                    TBOutputStruct(ptb, &tbbAdd, &tbbAddExt);
                    TBInsertButtons(ptb, nDest, 1, &tbbAddExt, TRUE);

                    ptb = FixPTB(hwndT);

                    SendCmdNotify(ptb, TBN_TOOLBARCHANGE);
                    TBInvalidateItemRects(ptb);
                }
                else
                {
AbortMove:
                    ;
                }
            }
            goto AllDone;

        case WM_RBUTTONDOWN:
            goto AbortMove;

        default:
            TranslateMessage32(&msg32, TRUE);
            DispatchMessage32(&msg32, TRUE);
            break;
        }
    }
AllDone:

    SetCursor(hCursor);
    CCReleaseCapture(&ptb->ci);
}


#define GNI_HIGH    0x0001
#define GNI_LOW     0x0002

int GetNearestInsert(PTBSTATE ptb, int iPos, int iNumButtons, UINT uFlags)
{
    int i;
    BOOL bKeepTrying;

    // Find the nearest index where we can actually insert items
    for (i = iPos; ; ++i, --iPos)
    {
        bKeepTrying = FALSE;

        // Notice we favor going high if both flags are set
        if ((uFlags & GNI_HIGH) && i <= iNumButtons)
        {
            bKeepTrying = TRUE;

            if (SendItemNotify(ptb, i, TBN_QUERYINSERT))
                return i;
        }

        if ((uFlags & GNI_LOW) && iPos >= 0)
        {
            bKeepTrying = TRUE;

            if (SendItemNotify(ptb, iPos, TBN_QUERYINSERT))
                return iPos;
        }

        if (!bKeepTrying)
            return -1;   // There was no place to add buttons
    }
}


BOOL InitAdjustDlg(HWND hDlg, LPADJUSTDLGDATA lpad)
{
    HDC hDC;
    HFONT hFont;
    HWND hwndCurrent, hwndNew;
    LPTBBUTTONDATA ptbButton;
    int i, iPos, nItem, nWid, nMaxWid;
    TBBUTTONDATA tbAdjust;
    TCHAR szDesc[128];
    NMTBCUSTOMIZEDLG nm;
    TCHAR szSeparator[MAX_PATH];

    szSeparator[0] = 0;
    LocalizedLoadString(IDS_SPACE, szSeparator, ARRAYSIZE(szSeparator));

    lpad->hDlg = hDlg;
    lpad->ptb->hdlgCust = hDlg;

    /* Determine the item nearest the desired item that will allow
     * insertion.
     */
    iPos = GetNearestInsert(lpad->ptb, lpad->iPos, lpad->ptb->iNumButtons,
                            GNI_HIGH | GNI_LOW);
    if (iPos < 0)
    /* No item allowed insertion, so leave the dialog */
    {
        return(FALSE);
    }

    /* Reset the lists of used and available items.
     */
    hwndCurrent = GetDlgItem(hDlg, IDC_CURRENT);
    SendMessage(hwndCurrent, LB_RESETCONTENT, 0, 0L);

    hwndNew = GetDlgItem(hDlg, IDC_BUTTONLIST);
    SendMessage(hwndNew, LB_RESETCONTENT, 0, 0L);

    nm.hDlg = hDlg;
    if (CCSendNotify(&lpad->ptb->ci, TBN_INITCUSTOMIZE, &nm.hdr) == TBNRF_HIDEHELP) {
        ShowWindow(GetDlgItem(hDlg, IDC_APPHELP), SW_HIDE);
    }

    for (i=0, ptbButton = lpad->ptb->Buttons; i < lpad->ptb->iNumButtons; ++i, ++ptbButton)
    {
        UINT uFlags;
        int iBitmap;
        LPTSTR pszStr = NULL;

        uFlags = 0;

        // Non-deletable and hidden items show up grayed.

        if (!SendItemNotify(lpad->ptb, i, TBN_QUERYDELETE))
        {
            uFlags |= FLAG_NODEL;
        }
        if (ptbButton->fsState & TBSTATE_HIDDEN)
        {
            uFlags |= FLAG_HIDDEN;
        }

        /* Separators have no bitmaps (even ones with IDs).  Only set
         * the separator flag if there is no ID (it is a "real"
         * separator rather than an owner item).
         */
        if (ptbButton->fsStyle&TBSTYLE_SEP)
        {
            if (!(ptbButton->idCommand))
            {
                uFlags |= FLAG_SEP;
            }
            iBitmap = -1;

            pszStr = szSeparator;
        }
        else
        {
            iBitmap = ptbButton->DUMMYUNION_MEMBER(iBitmap);
            // this specifies an imagelist.
            // pack this into the loword of the ibitmap.
            // this causes a restriction of max 16 imagelists, and 4096 images in any imagelist
            iBitmap = LOWORD(iBitmap) | (HIWORD(iBitmap) << 12);

            /* Add the item and the data
             * Note: A negative number in the LOWORD indicates no bitmap;
             * otherwise it is the bitmap index.
             */
            pszStr = TB_StrForButton(lpad->ptb, ptbButton);
        }

        if ((int)SendMessage(hwndCurrent, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)(pszStr ? pszStr : (LPTSTR)c_szNULL)) != i)
        {
            return(FALSE);
        }
        SendMessage(hwndCurrent, LB_SETITEMDATA, i, MAKELPARAM(iBitmap, uFlags));
    }

    /* Add a dummy "nodel" space at the end so things can be inserted at the end.
     */
    if ((int)SendMessage(hwndCurrent, LB_ADDSTRING, 0,(LPARAM)(LPTSTR)szSeparator) == i)
    {
        SendMessage(hwndCurrent, LB_SETITEMDATA, i, MAKELPARAM(-1, FLAG_NODEL|FLAG_SEP));
    }

    /* Now add a space at the beginning of the "new" list.
     */
        if (SendMessage(hwndNew, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)szSeparator) == LB_ERR)
            return(FALSE);
            
        SendMessage(hwndNew, LB_SETITEMDATA, 0, MAKELPARAM(-1, FLAG_SEP));

    /* We need this to determine the widest (in pixels) item string.
     */
    hDC = GetDC(hwndCurrent);
    hFont = (HFONT)(INT_PTR)SendMessage(hwndCurrent, WM_GETFONT, 0, 0L);
    if (hFont)
    {
        hFont = SelectObject(hDC, hFont);
    }
    nMaxWid = 0;

    for (i=0; ; ++i)
    {
        // Get the info about the i'th item from the app.
        if (!GetAdjustInfo(lpad->ptb, i, &tbAdjust, szDesc, ARRAYSIZE(szDesc)))
            break;
        
        if (!szDesc[0]) 
        {
            LPTSTR psz = TB_StrForButton(lpad->ptb, &tbAdjust);
            if (psz)
            {
                StringCchCopy(szDesc, ARRAYSIZE(szDesc), psz);
            }
        }

        /* Don't show separators that don't have commands
         */
        if (!(tbAdjust.fsStyle & TBSTYLE_SEP) || tbAdjust.idCommand)
        {
            
            /* Get the maximum width of a string.
             */
            MGetTextExtent(hDC, szDesc, lstrlen(szDesc), &nWid, NULL);

            if (nMaxWid < nWid)
            {
                nMaxWid = nWid;
            }

            nItem = PositionFromID(lpad->ptb, tbAdjust.idCommand);
            if (nItem < 0)
            /* If the item is not on the toolbar already */
            {
                /* Don't show hidden buttons
                 */
                if (!(tbAdjust.fsState & TBSTATE_HIDDEN))
                {
                    nItem = (int)SendMessage(hwndNew, LB_ADDSTRING, 0,
                                             (LPARAM)(LPTSTR)szDesc);
                    if (nItem != LB_ERR)
                    {
                        
                        if (tbAdjust.fsStyle & TBSTYLE_SEP)
                            SendMessage(hwndNew, LB_SETITEMDATA, nItem,
                                        MAKELPARAM(-1, i));
                        else {
                            int iBitmap = tbAdjust.DUMMYUNION_MEMBER(iBitmap);
                            iBitmap = LOWORD(iBitmap) | (HIWORD(iBitmap) << 12);
                            SendMessage(hwndNew, LB_SETITEMDATA, nItem,
                                        MAKELPARAM(iBitmap, i));
                        }
                    }
                }
            }
            else
            /* The item is on the toolbar already */
            {
                /* Preserve the flags and bitmap.
                 */
                DWORD dwTemp = (DWORD)SendMessage(hwndCurrent, LB_GETITEMDATA, nItem, 0L);

                if (szDesc[0]) {
                    SendMessage(hwndCurrent, LB_DELETESTRING, nItem, 0L);

                    if ((int)SendMessage(hwndCurrent, LB_INSERTSTRING, nItem,
                                         (LPARAM)(LPTSTR)szDesc) != nItem)
                    {
                        ReleaseDC(hwndCurrent, hDC);
                        return(FALSE);
                    }
                }
                SendMessage(hwndCurrent, LB_SETITEMDATA, nItem,
                    MAKELPARAM(LOWORD(dwTemp), HIWORD(dwTemp)|i));
            }
        }
    }

    if (hFont)
    {
        SelectObject(hDC, hFont);
    }
    ReleaseDC(hwndCurrent, hDC);

    /* Add on some extra and set the extents for both lists.
     */
    nMaxWid += lpad->ptb->iButWidth + 2 + 1;
    SendMessage(hwndNew, LB_SETHORIZONTALEXTENT, nMaxWid, 0L);
    SendMessage(hwndCurrent, LB_SETHORIZONTALEXTENT, nMaxWid, 0L);

    /* Set the sels and return.
     */
    SendMessage(hwndNew, LB_SETCURSEL, 0, 0L);
    SendMessage(hwndCurrent, LB_SETCURSEL, iPos, 0L);
    SEND_WM_COMMAND(hDlg, IDC_CURRENT, hwndCurrent, LBN_SELCHANGE);

    return(TRUE);
}


#define IsSeparator(x) (HIWORD(x) & FLAG_SEP)

void PaintAdjustLine(PTBSTATE ptb, DRAWITEMSTRUCT *lpdis)
{
    HDC hdc = lpdis->hDC;
    HWND hwndList = lpdis->hwndItem;
    PTSTR pszText;
    RECT rc = lpdis->rcItem;
    int nBitmap, nLen, nItem = lpdis->itemID;
    COLORREF oldBkColor, oldTextColor;
    BOOL bSelected, bHasFocus;
    int wHeight;
    int x;


    if (lpdis->CtlID != IDC_BUTTONLIST && lpdis->CtlID != IDC_CURRENT)
        return;

    nBitmap = LOWORD(lpdis->itemData);
    // unpack the nBitmap.  we stored the imagelist spec in the hi char of loword
    if (nBitmap != 0xFFFF)
        nBitmap = (nBitmap & 0x0FFF) | ((nBitmap & 0xF000) << 4);

    nLen = (int)SendMessage(hwndList, LB_GETTEXTLEN, nItem, 0L);
    if (nLen < 0)
        return;

    pszText = (PTSTR)LocalAlloc(LPTR, (nLen+1)*sizeof(TCHAR));
    if (!pszText)
        return;

    // This needs to work for separators also or ActiveAccessibility
    // won't work.
    SendMessage(hwndList, LB_GETTEXT, nItem, (LPARAM)(LPTSTR)pszText);
    if (lpdis->itemAction != ODA_FOCUS)
    {
        COLORREF clr;
        TCHAR szSample[2];

        /* We don't care about focus if the item is not selected.
        */
        bSelected = lpdis->itemState & ODS_SELECTED;
        bHasFocus = bSelected && (GetFocus() == hwndList);

        if (HIWORD(lpdis->itemData) & (FLAG_NODEL | FLAG_HIDDEN))
            clr = g_clrGrayText;
        else if (bHasFocus)
            clr = g_clrHighlightText;
        else
            clr = g_clrWindowText;

        oldTextColor = SetTextColor(hdc, clr);
        oldBkColor = SetBkColor(hdc, bHasFocus ? g_clrHighlight : g_clrWindow);

        szSample[0] = TEXT('W');
        szSample[1] = TEXT('\0');

        MGetTextExtent(hdc, szSample, 1, NULL, &wHeight);

        x = rc.left + 2;
        x += (ptb->ci.style & TBSTYLE_FLAT) ? (ptb->iDxBitmap + g_cxEdge) : ptb->iButWidth;
        ExtTextOut(hdc, x,
                   (rc.top + rc.bottom-wHeight) / 2,
                   ETO_CLIPPED | ETO_OPAQUE, &rc, pszText, nLen, NULL);

        /* We really care about the bitmap value here; this is not just an
        * indicator for the separator.
        */
        if (nBitmap >= 0)
        {
            TBBUTTONDATA tbbAdd = {0};
            TBDRAWITEM tbdraw = {0};

            tbbAdd.DUMMYUNION_MEMBER(iBitmap) = nBitmap;
            tbbAdd.iString = -1;
            tbbAdd.fsStyle = TBSTYLE_BUTTON;
            tbbAdd.fsState = (BYTE)((HIWORD(lpdis->itemData) & FLAG_HIDDEN) ? 0 : TBSTATE_ENABLED);

            InitTBDrawItem(&tbdraw, ptb, &tbbAdd, tbbAdd.fsState, 0, 0, 0);

            if (ptb->ci.style & TBSTYLE_FLAT)
                DrawFace(hdc, rc.left + 1, rc.top + 1, 0, 0, 0, 0, &tbdraw);
            else
                DrawButton(hdc, rc.left + 1, rc.top + 1, ptb, &tbbAdd, TRUE);
            ReleaseMonoDC(ptb);
        }

        SetBkColor(hdc, oldBkColor);
        SetTextColor(hdc, oldTextColor);

        /* Frame the item if it is selected but does not have the focus.
        */
        if (bSelected && !bHasFocus)
        {
            nLen = rc.left + (int)SendMessage(hwndList,
            LB_GETHORIZONTALEXTENT, 0, 0L);
            if (rc.right < nLen)
                rc.right = nLen;

            FrameRect(hdc, &rc, g_hbrHighlight);
        }
    }

    if ((lpdis->itemAction == ODA_FOCUS || (lpdis->itemState & ODS_FOCUS))
        && !(CCGetUIState(&(ptb->ci)) & UISF_HIDEFOCUS)
        )
        DrawFocusRect(hdc, &rc); 

    LocalFree((HLOCAL)pszText);
}


void LBMoveButton(LPADJUSTDLGDATA lpad, UINT wIDSrc, int iPosSrc,
      UINT wIDDst, int iPosDst, int iSelOffset)
{
    HWND hwndSrc, hwndDst;
    DWORD dwDataSrc;
    PTSTR pStr;
    TBBUTTONDATA tbAdjust = {0};
    TBBUTTON tbbAddExt;
    int iTopDst;
    TCHAR szDesc[128];

    hwndSrc = GetDlgItem(lpad->hDlg, wIDSrc);
    hwndDst = GetDlgItem(lpad->hDlg, wIDDst);

    // Make sure we can delete the source and insert at the dest
    //
    dwDataSrc = (DWORD)SendMessage(hwndSrc, LB_GETITEMDATA, iPosSrc, 0L);
    if (iPosSrc < 0 || (HIWORD(dwDataSrc) & FLAG_NODEL))
        return;
    if (wIDDst == IDC_CURRENT && 
        !SendItemNotify(lpad->ptb, iPosDst, TBN_QUERYINSERT))
        return;

    // Get the string for the source
    //
    pStr = (PTSTR)LocalAlloc(LPTR,
        ((int)(SendMessage(hwndSrc, LB_GETTEXTLEN, iPosSrc, 0L))+1)*sizeof(TCHAR));
    if (!pStr)
        return;
    SendMessage(hwndSrc, LB_GETTEXT, iPosSrc, (LPARAM)(LPTSTR)pStr);

    SendMessage(hwndSrc, WM_SETREDRAW, 0, 0L);
    SendMessage(hwndDst, WM_SETREDRAW, 0, 0L);
    iTopDst = (int)SendMessage(hwndDst, LB_GETTOPINDEX, 0, 0L);

    // If we are inserting into the available button list, we need to determine
    // the insertion point
    //
    if (wIDDst == IDC_BUTTONLIST)
    {
        // Insert this back in the available list if this is not a space or a
        // hidden button.
        //
        if (HIWORD(dwDataSrc)&(FLAG_SEP|FLAG_HIDDEN))
        {
            iPosDst = 0;
            goto DelTheSrc;
        }
        else
        {
            UINT uCmdSrc = HIWORD(dwDataSrc) & ~(FLAG_ALLFLAGS);

            // This just does a linear search for where to put the
            // item.  Slow, but this only happens when the user clicks
            // the "Remove" button.
            //
            iPosDst = 1;
            
            for ( ; ; ++iPosDst)
            {
                // Notice that this will break out when iPosDst is
                // past the number of items, since -1 will be returned
                //
                if ((UINT)HIWORD(SendMessage(hwndDst, LB_GETITEMDATA,
                    iPosDst, 0L)) >= uCmdSrc)
                break;
            }
        }
    }
    else if (iPosDst < 0)
        goto CleanUp;

    // Attempt to insert the new string
    //
    if ((int)SendMessage(hwndDst, LB_INSERTSTRING, iPosDst, (LPARAM)(LPTSTR)pStr)
      == iPosDst)
    {
        // Attempt to sync up the actual toolbar.
        //
        if (wIDDst == IDC_CURRENT)
        {
            HWND hwndT;

            if (IsSeparator(dwDataSrc))
            {
                // Make up a dummy lpInfo if this is a space
                //
                tbAdjust.DUMMYUNION_MEMBER(iBitmap) = 0;
                tbAdjust.idCommand = 0;
                tbAdjust.fsState = 0;
                tbAdjust.fsStyle = TBSTYLE_SEP;
            }
            else
            {
                // Call back to client to get the source button info
                //
                int iCmdSrc = HIWORD(dwDataSrc) & ~FLAG_ALLFLAGS;
                if (!GetAdjustInfo(lpad->ptb, iCmdSrc, &tbAdjust, szDesc, ARRAYSIZE(szDesc)))
                    goto DelTheDst;
            }

            hwndT = lpad->ptb->ci.hwnd;

            TBOutputStruct(lpad->ptb, &tbAdjust, &tbbAddExt);
            if (!TBInsertButtons(lpad->ptb, iPosDst, 1, &tbbAddExt, TRUE))
            {
DelTheDst:
                SendMessage(hwndDst, LB_DELETESTRING, iPosDst, 0L);
                goto CleanUp;
            }
            else
            {
                lpad->ptb = FixPTB(hwndT);
            }

            if (wIDSrc == IDC_CURRENT && iPosSrc >= iPosDst)
                ++iPosSrc;
        }

        SendMessage(hwndDst, LB_SETITEMDATA, iPosDst, dwDataSrc);

DelTheSrc:
        // Don't delete the "Separator" in the new list
        //
        if ((wIDSrc != IDC_BUTTONLIST) || (iPosSrc != 0))
        {
            SendMessage(hwndSrc, LB_DELETESTRING, iPosSrc, 0L);
            if (wIDSrc == wIDDst)
            {
                if (iPosSrc < iPosDst)
                    --iPosDst;
                if (iPosSrc < iTopDst)
                    --iTopDst;
            }
        }

        // Delete the corresponding button
        //
        if (wIDSrc == IDC_CURRENT)
            DeleteButton(lpad->ptb, iPosSrc);

        // Only set the src index if the two windows are different
        //
        if (wIDSrc != wIDDst)
        {
            if (iPosSrc >= SendMessage(hwndSrc, LB_GETCOUNT, 0, 0L))
            {
                // HACKHACK: workaround for funkdified listbox scrolling behavior.
                // Select the first item (to force scroll back to top of list),
                // then select the item we really want selected.
                SendMessage(hwndSrc, LB_SETCURSEL, 0, 0L);
            }

            if (SendMessage(hwndSrc, LB_SETCURSEL, iPosSrc, 0L) == LB_ERR)
                SendMessage(hwndSrc, LB_SETCURSEL, iPosSrc-1, 0L);
            SEND_WM_COMMAND(lpad->hDlg, wIDSrc, hwndSrc, LBN_SELCHANGE);
        }

        // Send the final SELCHANGE message after everything else is done
        //
        SendMessage(hwndDst, LB_SETCURSEL, iPosDst+iSelOffset, 0L);
        SEND_WM_COMMAND(lpad->hDlg, wIDDst, hwndDst, LBN_SELCHANGE);
    }

CleanUp:

    LocalFree((HLOCAL)pStr);

    if (wIDSrc == wIDDst)
    {
        SendMessage(hwndDst, LB_SETTOPINDEX, iTopDst, 0L);
        //make sure that the selected item is still  visible
        SendMessage(hwndDst, LB_SETCURSEL, (int)SendMessage(hwndDst, LB_GETCURSEL, 0, 0L), 0);
    }
    SendMessage(hwndSrc, WM_SETREDRAW, 1, 0L);
    SendMessage(hwndDst, WM_SETREDRAW, 1, 0L);

    InvalidateRect(hwndDst, NULL, TRUE);

    SendCmdNotify(lpad->ptb, TBN_TOOLBARCHANGE);
}


void SafeEnableWindow(HWND hDlg, UINT wID, HWND hwndDef, BOOL bEnable)
{
    HWND hwndEnable;

    hwndEnable = GetDlgItem(hDlg, wID);

    if (!bEnable && GetFocus()==hwndEnable)
        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hwndDef, 1L);
    EnableWindow(hwndEnable, bEnable);
}

int InsertIndex(LPADJUSTDLGDATA lpad, POINT pt, BOOL bDragging)
{
    HWND hwndCurrent = GetDlgItem(lpad->hDlg, IDC_CURRENT);
    int nItem = LBItemFromPt(hwndCurrent, pt, bDragging);
    if (nItem >= 0)
    {
        if (!SendItemNotify(lpad->ptb, nItem, TBN_QUERYINSERT))
            nItem = -1;
    }

    DrawInsert(lpad->hDlg, hwndCurrent, bDragging ? nItem : -1);

    return(nItem);
}


BOOL IsInButtonList(HWND hDlg, POINT pt)
{
    ScreenToClient(hDlg, &pt);

    return(ChildWindowFromPoint(hDlg, pt) == GetDlgItem(hDlg, IDC_BUTTONLIST));
}


BOOL HandleDragMsg(LPADJUSTDLGDATA lpad, HWND hDlg, WPARAM wID, LPDRAGLISTINFO lpns)
{
    switch (wID)
    {
    case IDC_CURRENT:
        switch (lpns->uNotification)
        {
        case DL_BEGINDRAG:
            {
                int nItem = (int)SendMessage(lpns->hWnd, LB_GETCURSEL, 0, 0L);
                if (HIWORD(SendMessage(lpns->hWnd, LB_GETITEMDATA, nItem, 0L)) & FLAG_NODEL)
                    return SetDlgMsgResult(hDlg, WM_COMMAND, FALSE);
                return SetDlgMsgResult(hDlg, WM_COMMAND, TRUE);
            }
            
        case DL_DRAGGING:
            {
                int nDropIndex;

DraggingSomething:
                nDropIndex = InsertIndex(lpad, lpns->ptCursor, TRUE);
                if (nDropIndex>=0 || IsInButtonList(hDlg, lpns->ptCursor))
                {
                    SetCursor(LoadCursor(HINST_THISDLL,
                        MAKEINTRESOURCE(IDC_MOVEBUTTON)));
                    return SetDlgMsgResult(hDlg, WM_COMMAND, 0);
                }
                return SetDlgMsgResult(hDlg, WM_COMMAND, DL_STOPCURSOR);
            }
            
        case DL_DROPPED:
            {
                int nDropIndex, nSrcIndex;
                
                nDropIndex = InsertIndex(lpad, lpns->ptCursor, FALSE);
                nSrcIndex = (int)SendMessage(lpns->hWnd, LB_GETCURSEL, 0, 0L);
                
                if (nDropIndex >= 0)
                {
                    if ((UINT)(nDropIndex-nSrcIndex) > 1)
                        LBMoveButton(lpad, IDC_CURRENT, nSrcIndex,
                        IDC_CURRENT, nDropIndex, 0);
                }
                else if (IsInButtonList(hDlg, lpns->ptCursor))
                {
                    LBMoveButton(lpad, IDC_CURRENT, nSrcIndex, IDC_BUTTONLIST, 0, 0);
                }
                break;
            }
            
        case DL_CANCELDRAG:
CancelDrag:
            /* This erases the insert icon if it exists.
             */
            InsertIndex(lpad, lpns->ptCursor, FALSE);
            break;
            
        default:
            break;
        }
        break;
        
        case IDC_BUTTONLIST:
            switch (lpns->uNotification)
            {
            case DL_BEGINDRAG:
                return SetDlgMsgResult(hDlg, WM_COMMAND, TRUE);
                
            case DL_DRAGGING:
                goto DraggingSomething;
                
            case DL_DROPPED:
                {
                    int nDropIndex;
                    
                    nDropIndex = InsertIndex(lpad, lpns->ptCursor, FALSE);
                    if (nDropIndex >= 0)
                        LBMoveButton(lpad, IDC_BUTTONLIST,
                            (int)SendMessage(lpns->hWnd,LB_GETCURSEL,0,0L),
                            IDC_CURRENT, nDropIndex, 0);
                    break;
                }
                
            case DL_CANCELDRAG:
                goto CancelDrag;
                
            default:
                break;
            }
            break;
            
            default:
                break;
    }
    
    return(0);
}


const static DWORD aAdjustHelpIDs[] = {  // Context Help IDs
    IDC_RESET,       IDH_COMCTL_RESET,
    IDC_APPHELP,     IDH_HELP,
    IDC_MOVEUP,      IDH_COMCTL_MOVEUP,
    IDC_MOVEDOWN,    IDH_COMCTL_MOVEDOWN,
    IDC_BUTTONLIST,  IDH_COMCTL_AVAIL_BUTTONS,
    IDOK,            IDH_COMCTL_ADD,
    IDC_REMOVE,      IDH_COMCTL_REMOVE,
    IDC_CURRENT,     IDH_COMCTL_BUTTON_LIST,
    IDCANCEL,        IDH_COMCTL_CLOSE,
    0, 0
};

BOOL_PTR CALLBACK AdjustDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPADJUSTDLGDATA lpad = (LPADJUSTDLGDATA)GetWindowPtr(hDlg, DWLP_USER);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);  /* LPADJUSTDLGDATA pointer */
        if (!InitAdjustDlg(hDlg, (LPADJUSTDLGDATA)lParam))
            EndDialog(hDlg, FALSE);
        
        ShowWindow(hDlg, SW_SHOW);
        UpdateWindow(hDlg);
        SetFocus(GetDlgItem(hDlg, IDC_CURRENT));
        
        MakeDragList(GetDlgItem(hDlg, IDC_CURRENT));
        MakeDragList(GetDlgItem(hDlg, IDC_BUTTONLIST));
        
        return FALSE;
        
    case WM_MEASUREITEM:
#define lpmis ((MEASUREITEMSTRUCT *)lParam)
        
        if (lpmis->CtlID == IDC_BUTTONLIST || lpmis->CtlID == IDC_CURRENT)
        {
            int nHeight;
            HWND hwndList = GetDlgItem(hDlg, lpmis->CtlID);
            HDC hDC = GetDC(hwndList);
            TCHAR szSample[2];
            
            szSample[0] = TEXT('W');
            szSample[1] = TEXT('\0');
            
            MGetTextExtent(hDC, szSample, 1, NULL, &nHeight);
            
            // note, we use this hack because we get WM_MEASUREITEMS
            // before our WM_INITDIALOG where we get the lpad setup
            
            if (nHeight < g_dyButtonHack + 2)
                nHeight = g_dyButtonHack + 2;
            
            lpmis->itemHeight = nHeight;
            ReleaseDC(hwndList, hDC);
        }
        break;
        
    case WM_DRAWITEM:
        PaintAdjustLine(lpad->ptb, (DRAWITEMSTRUCT *)lParam);
        break;
        
    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aAdjustHelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(LPVOID) aAdjustHelpIDs);
        break;
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_APPHELP:
            SendCmdNotify(lpad->ptb, TBN_CUSTHELP);
            break;
            
        case IDOK:
            {
                int iPos, nItem;
                
                nItem = (int)SendDlgItemMessage(hDlg, IDC_BUTTONLIST,
                    LB_GETCURSEL, 0, 0L);
                
                iPos = (int)SendDlgItemMessage(hDlg, IDC_CURRENT,
                    LB_GETCURSEL, 0, 0L);
                
                if (iPos == -1)
                    iPos = 0;
                
                LBMoveButton(lpad, IDC_BUTTONLIST, nItem, IDC_CURRENT, iPos, 1);
                break;
            }
            
        case IDC_BUTTONLIST:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case LBN_DBLCLK:
                SendMessage(hDlg, WM_COMMAND, IDOK, 0L);
                break;
                
            case LBN_SETFOCUS:
            case LBN_KILLFOCUS:
                {
                    RECT rc;
                    
                    if (SendMessage(GET_WM_COMMAND_HWND(wParam, lParam), LB_GETITEMRECT,
                        (int)SendMessage(GET_WM_COMMAND_HWND(wParam, lParam), LB_GETCURSEL,
                        0, 0L), (LPARAM)(LPRECT)&rc) != LB_ERR)
                        InvalidateRect(GET_WM_COMMAND_HWND(wParam, lParam), &rc, FALSE);
                }
                
            default:
                break;
            }
            break;
            
        case IDC_CURRENT:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case LBN_SELCHANGE:
                {
                    BOOL bDelOK;
                    HWND hwndList = GET_WM_COMMAND_HWND(wParam, lParam);
                    int iPos = (int)SendMessage(hwndList, LB_GETCURSEL, 0, 0L);
                    
                    SafeEnableWindow(hDlg, IDOK, hwndList, BOOLFROMPTR(SendItemNotify(lpad->ptb, iPos, TBN_QUERYINSERT)));
                    
                    bDelOK = !(HIWORD(SendMessage(hwndList, LB_GETITEMDATA, iPos, 0L)) & FLAG_NODEL);
                    
                    SafeEnableWindow(hDlg, IDC_REMOVE, hwndList, bDelOK);
                    
                    SafeEnableWindow(hDlg, IDC_MOVEUP, hwndList, bDelOK &&
                        GetNearestInsert(lpad->ptb, iPos - 1, 0, GNI_LOW) >= 0);
                    
                    SafeEnableWindow(hDlg, IDC_MOVEDOWN, hwndList, bDelOK &&
                        GetNearestInsert(lpad->ptb, iPos + 2,
                        lpad->ptb->iNumButtons, GNI_HIGH) >=0 );
                    break;
                }
                
            case LBN_DBLCLK:
                SendMessage(hDlg, WM_COMMAND, IDC_REMOVE, 0L);
                break;
                
            case LBN_SETFOCUS:
            case LBN_KILLFOCUS:
                {
                    RECT rc;

                    if (SendMessage(GET_WM_COMMAND_HWND(wParam, lParam), LB_GETITEMRECT,
                        (int)SendMessage(GET_WM_COMMAND_HWND(wParam, lParam), LB_GETCURSEL,
                        0, 0L), (LPARAM)(LPRECT)&rc) != LB_ERR)
                        InvalidateRect(GET_WM_COMMAND_HWND(wParam, lParam), &rc, FALSE);
                }
                
            default:
                break;
            }
            break;
            
        case IDC_REMOVE:
            {
                int iPos = (int)SendDlgItemMessage(hDlg, IDC_CURRENT, LB_GETCURSEL, 0, 0);
                
                LBMoveButton(lpad, IDC_CURRENT, iPos, IDC_BUTTONLIST, 0, 0);
                break;
            }
            
        case IDC_MOVEUP:
        case IDC_MOVEDOWN:
            {
                int iPosSrc, iPosDst;
                
                iPosSrc = (int)SendDlgItemMessage(hDlg, IDC_CURRENT, LB_GETCURSEL, 0, 0L);
                if (wParam == IDC_MOVEUP)
                    iPosDst = GetNearestInsert(lpad->ptb, iPosSrc - 1, 0, GNI_LOW);
                else
                    iPosDst = GetNearestInsert(lpad->ptb, iPosSrc + 2, lpad->ptb->iNumButtons, GNI_HIGH);
                
                LBMoveButton(lpad, IDC_CURRENT, iPosSrc, IDC_CURRENT,iPosDst,0);
                break;
            }
            
        case IDC_RESET:
            {
                // ptb will change across call below
                HWND hwndT = lpad->ptb->ci.hwnd;
                BOOL fClose = FALSE;
                NMTBCUSTOMIZEDLG nm;
                nm.hDlg = hDlg;
                if (CCSendNotify(&lpad->ptb->ci, TBN_RESET, &nm.hdr) == TBNRF_ENDCUSTOMIZE)
                    fClose = TRUE;
                
                // ptb probably changed across above call
                lpad->ptb = FixPTB(hwndT);
            
                /* Reset the dialog, but exit if something goes wrong. */
                lpad->iPos = 0;
                if (!fClose && InitAdjustDlg(hDlg, lpad))
                    break;
            }
            
            /* We have to fall through because we won't know where to insert
             * buttons after resetting.
             */
        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            break;
            
        default:
            return(FALSE);
        }
        break;
        
    default:
        if (uMsg == uDragListMsg)
            return HandleDragMsg(lpad, hDlg, wParam, (LPDRAGLISTINFO)lParam);
        
        return(FALSE);
    }
    
    return(TRUE);
}

// BUGBUG: this should support saving to an IStream

/* This saves the state of the toolbar.  Spaces are saved as -1 (-2 if hidden)
 * and other buttons are just saved as the command ID.  When restoring, all
 * ID's are filled in, and the app is queried for all buttons so that the
 * bitmap and state information may be filled in.  Button ID's that are not
 * returned from the app are removed.
 */

BOOL SaveRestoreFromReg(PTBSTATE ptb, BOOL bWrite, HKEY hkr, LPCTSTR pszSubKey, LPCTSTR pszValueName)
{
    BOOL bRet = FALSE;
    TCHAR szDesc[128];
    
    if (bWrite)
    {
        UINT uSize = ptb->iNumButtons * sizeof(DWORD);
        NMTBSAVE nmtbs;
        BOOL fAlloced = FALSE;
        nmtbs.pData = NULL;
        nmtbs.cbData = uSize;
        nmtbs.pCurrent = NULL;
        nmtbs.iItem = -1; // signal pre saving
        nmtbs.cButtons = ptb->iNumButtons;
        CCSendNotify(&ptb->ci, TBN_SAVE, &nmtbs.hdr);
        if (!nmtbs.pData) {
            nmtbs.pData = (DWORD *)LocalAlloc(LPTR, nmtbs.cbData);
            fAlloced = TRUE;
        }

        // BUGBUG -- Somebody could've changed ptb->iNumButtons
        // during the CCSendNotify

        if (!nmtbs.pCurrent)
            nmtbs.pCurrent = nmtbs.pData;
        
        if (nmtbs.pData)
        {
            HKEY hkeySave;
            if (RegCreateKey(hkr, pszSubKey, &hkeySave) == ERROR_SUCCESS)
            {
                int i;
                for (i = 0; i < ptb->iNumButtons; i++)
                {
                    if (ptb->Buttons[i].idCommand)
                        *nmtbs.pCurrent = ptb->Buttons[i].idCommand;
                    else
                    {
                        // If the separator has an ID, then it is an "owner" item.
                        if (ptb->Buttons[i].fsState & TBSTATE_HIDDEN)
                            *nmtbs.pCurrent = (DWORD)-2;   // hidden
                        else
                            *nmtbs.pCurrent = (DWORD)-1;   // normal seperator
                    }
                    nmtbs.pCurrent++;
                    nmtbs.iItem = i;
                    TBOutputStruct(ptb, &ptb->Buttons[i], &nmtbs.tbButton);
                    CCSendNotify(&ptb->ci, TBN_SAVE, &nmtbs.hdr);
                }
                if (RegSetValueEx(hkeySave, (LPTSTR)pszValueName, 0, REG_BINARY, (LPVOID)nmtbs.pData, nmtbs.cbData) == ERROR_SUCCESS)
                    bRet = TRUE;
                RegCloseKey(hkeySave);
            }
            
            if (fAlloced)
                LocalFree((HLOCAL)nmtbs.pData);
        }
    }
    else
    {
        HKEY hkey;
        
        if (RegOpenKeyEx(hkr, pszSubKey, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
        {
            DWORD cbSize = 0;
            
            if ((RegQueryValueEx(hkey, (LPTSTR)pszValueName, 0, NULL, NULL, &cbSize) == ERROR_SUCCESS) &&
                (cbSize > sizeof(DWORD)))
            {
                UINT uSize = (UINT)cbSize;
                DWORD *pData = (DWORD *)LocalAlloc(LPTR, uSize);
                if (pData)
                {
                    DWORD dwType;
                    DWORD cbSize = (DWORD)uSize;
                    
                    if ((RegQueryValueEx(hkey, (LPTSTR)pszValueName, 0, &dwType, (LPVOID)pData, &cbSize) == ERROR_SUCCESS) &&
                        (dwType == REG_BINARY) &&
                        (cbSize == (DWORD)uSize))
                    {
                        int iButtonIndex;

                        NMTBRESTORE nmtbs;
                        BOOL fAlloced = FALSE;
                        nmtbs.pData = pData;
                        nmtbs.pCurrent = pData;
                        nmtbs.iItem = -1; // signal pre saving
                        nmtbs.cButtons = (int)uSize / SIZEOF(DWORD);
                        nmtbs.cbBytesPerRecord = SIZEOF(DWORD);
                        nmtbs.cbData = uSize;
                        // since we don't know the cButtons if they've added on extra data to pData,
                        // we'll use whatever they fill for cButtons
                        if (!CCSendNotify(&ptb->ci, TBN_RESTORE, &nmtbs.hdr)) {

                            //
                            // Before reloading the buttons, delete the tooltips
                            // of the previous buttons (if they exist).
                            //
                            if (ptb && ptb->hwndToolTips) {
                                TOOLINFO ti;

                                ti.cbSize = sizeof(ti);
                                ti.hwnd = ptb->ci.hwnd;

                                for (iButtonIndex = 0;
                                     iButtonIndex < ptb->iNumButtons; iButtonIndex++) {

                                    if (!(ptb->Buttons[iButtonIndex].fsStyle & TBSTYLE_SEP)) {
                                        ti.uId = ptb->Buttons[iButtonIndex].idCommand;
                                        SendMessage(ptb->hwndToolTips, TTM_DELTOOL,
                                            0, (LPARAM)(LPTOOLINFO)&ti);
                                    }
                                }
                            }

                            // BUGBUG -- can ptb be NULL here? - raymondc
                            // BUGBUG -- what if pCaptureButton != NULL?

                            // grow (or maybe shrink) pbt to hold new buttons
                            if (TBReallocButtons(ptb, nmtbs.cButtons))
                            {
                                int i;
                                if (ptb->iNumButtons < nmtbs.cButtons)
                                    ZeroMemory(&ptb->Buttons[ptb->iNumButtons], (nmtbs.cButtons - ptb->iNumButtons) * SIZEOF(TBBUTTON));
                                ptb->iNumButtons = nmtbs.cButtons;

                                for (i = 0; i < ptb->iNumButtons; i++)
                                {
                                    nmtbs.iItem = i;

                                    if ((long)*nmtbs.pCurrent < 0)
                                    {
                                        ptb->Buttons[i].fsStyle = TBSTYLE_SEP;
                                        ptb->Buttons[i].DUMMYUNION_MEMBER(iBitmap) = g_dxButtonSep;
                                        ptb->Buttons[i].idCommand = 0;
                                        if (*nmtbs.pCurrent == (DWORD)-1)
                                            ptb->Buttons[i].fsState = 0;
                                        else
                                        {
                                            ASSERT(*nmtbs.pCurrent == (DWORD)-2);
                                            ptb->Buttons[i].fsState = TBSTATE_HIDDEN;
                                        }
                                    }
                                    else
                                    {
                                        ptb->Buttons[i].fsStyle = 0;
                                        ptb->Buttons[i].idCommand = *nmtbs.pCurrent;
                                        ptb->Buttons[i].DUMMYUNION_MEMBER(iBitmap) = -1;
                                    }
                                    
                                    nmtbs.pCurrent++;
                                    
                                    TBOutputStruct(ptb, &ptb->Buttons[i], &nmtbs.tbButton);
                                    CCSendNotify(&ptb->ci, TBN_RESTORE, &nmtbs.hdr);
                                    ASSERT(nmtbs.tbButton.iString == -1 || !HIWORD(nmtbs.tbButton.iString));
                                    // we don't thunk.  only allow string index in string pool here
                                    if (HIWORD(nmtbs.tbButton.iString))
                                        nmtbs.tbButton.iString = 0;
                                    TBInputStruct(ptb, &ptb->Buttons[i], &nmtbs.tbButton);
                                }

                                // Now query for all buttons, and fill in the rest of the info

                                // For backward compatibility, ignore return value of TBN_BEGINADJUST
                                // if client is older than version 5 (NT5 #185499).
                                if (!SendCmdNotify(ptb, TBN_BEGINADJUST) || (ptb->ci.iVersion < 5)) {
                                    for (i = 0; ; i++)
                                    {
                                        TBBUTTONDATA tbAdjust;

                                        tbAdjust.idCommand = 0;

                                        if (!GetAdjustInfo(ptb, i, &tbAdjust, szDesc, ARRAYSIZE(szDesc)))
                                            break;

                                        if (!(tbAdjust.fsStyle & TBSTYLE_SEP) || tbAdjust.idCommand)
                                        {
                                            int iPos = PositionFromID(ptb, tbAdjust.idCommand);
                                            if (iPos >= 0) {
                                                ptb->Buttons[iPos] = tbAdjust;

                                            }
                                        }

                                    }
                                    SendCmdNotify(ptb, TBN_ENDADJUST);
                                }

                                // cleanup all the buttons that were not recognized
                                // do this backwards to minimize data movement (and nmtbs.cButtons changes)
                                for (i = ptb->iNumButtons - 1; i >= 0; i--)
                                {
                                    // DeleteButton does no realloc, so ptb will not move
                                    if (ptb->Buttons[i].DUMMYUNION_MEMBER(iBitmap) < 0)
                                        DeleteButton(ptb, (UINT)i);
                                    else {
                                        // the rest, add to tooltips 
                                        if(ptb->hwndToolTips &&
                                          (!(ptb->Buttons[i].fsStyle & TBSTYLE_SEP || !ptb->Buttons[i].idCommand))) {
                                            TOOLINFO ti;
                                            // don't bother setting the rect because we'll do it below
                                            // in TBInvalidateItemRects;
                                            ti.cbSize = sizeof(ti);
                                            ti.uFlags = 0;
                                            ti.hwnd = ptb->ci.hwnd;
                                            ti.uId = ptb->Buttons[i].idCommand;
                                            ti.lpszText = LPSTR_TEXTCALLBACK;

                                            SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
                                        }
                                    }

                                }
                                bRet = (ptb->iNumButtons != 0); // success

                                // bugbug: break autosize to a function and call it
                                SendMessage(ptb->ci.hwnd, TB_AUTOSIZE, 0, 0);
                                InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
                                TBInvalidateItemRects(ptb);
                            }
                        }
                    }
                    LocalFree((HLOCAL)pData);
                }
            }
            RegCloseKey(hkey);
        }
    }
    
    return bRet;
}


void CustomizeTB(PTBSTATE ptb, int iPos)
{
    ADJUSTDLGDATA ad;
    HWND hwndT = ptb->ci.hwnd;  // ptb will change across call below
    HRSRC hrsrc;
    LANGID wLang;
    LPVOID pTemplate;

    if (ptb->hdlgCust)      // We are already customizing this toolbar
        return;
    
    ad.ptb = ptb;
    ad.iPos = iPos;
    
    // REVIEW: really should be per thread data, but not likely to cause a problem
    
    // see note in WM_MEASUREITEM code
    g_dyButtonHack = (ptb->ci.style & TBSTYLE_FLAT) ? ptb->iDyBitmap : ptb->iButHeight;
    
    SendCmdNotify(ptb, TBN_BEGINADJUST);

    //
    //  Do locale-specific futzing.
    //
    wLang = LANGIDFROMLCID(CCGetProperThreadLocale(NULL));
    hrsrc = FindResourceExRetry(HINST_THISDLL, RT_DIALOG, MAKEINTRESOURCE(ADJUSTDLG), wLang);
    if (hrsrc &&
        (pTemplate = (LPVOID)LoadResource(HINST_THISDLL, hrsrc)))
    {
        DialogBoxIndirectParam(HINST_THISDLL, pTemplate,
                   ptb->ci.hwndParent, AdjustDlgProc, (LPARAM)(LPADJUSTDLGDATA)&ad);
    }

    // ptb probably changed across above call
    ptb = (PTBSTATE)GetWindowInt(hwndT, 0);
    ptb->hdlgCust = NULL;
    
    SendCmdNotify(ptb, TBN_ENDADJUST);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\toolbar.h ===
// common stuff for the toolbar control

#ifndef _TOOLBAR_H
#define _TOOLBAR_H

#define TBHIGHLIGHT_BACK
#define TBHIGHLIGHT_GLYPH

typedef struct {        /* info for recreating the bitmaps */
    int nButtons;
    HINSTANCE hInst;
    UINT_PTR wID;
} TBBMINFO, NEAR *PTBBMINFO;

typedef struct _TBBUTTONDATA {
    union
    {
        // Someone wanted to conserve space.  This is a union to make 
        // the code easier to read.
        int iBitmap;
        int cxySep;         // Used by separators
    }DUMMYUNIONNAME;
    int idCommand;
    BYTE fsState;
    BYTE fsStyle;
    WORD cx;                // BUGBUG raymondc: Can we change this INT?
    DWORD_PTR dwData;
    INT_PTR iString;
    POINT pt;               // top left corner of this button
} TBBUTTONDATA, * LPTBBUTTONDATA;

#define HIML_NORMAL 0
#define HIML_HOT    1   // Image list for the hot-tracked image
#define HIML_DISABLED 2 // Image list for the hot-tracked image
#define HIML_MAX        2

typedef struct {
    HIMAGELIST himl[3];
} TBIMAGELISTS, *LPTBIMAGELISTS;

typedef struct {            /* instance data for toolbar window */
    CONTROLINFO ci;
    DWORD dwStyleEx;
    HDC hdcMono;
    HBITMAP hbmMono;
    LPTBBUTTONDATA Buttons;     // Array of actual buttons
    LPTBBUTTONDATA pCaptureButton;
    POINT   ptCapture;
    HWND hwndToolTips;
    LPTSTR      pszTip;         // store current tooltip string.
    HWND hdlgCust;
    HFONT hfontIcon;
    int nBitmaps;
#ifdef GLYPHCACHE
    int nSelectedBM;            // currently selected pBitmaps index
#endif
    PTBBMINFO pBitmaps;
#ifdef FACECACHE
    HBITMAP hbmCache;
#endif
    PTSTR *pStrings;
    int nStrings;
    int nTextRows;              // # Rows of text per button
    UINT uStructSize;
    int iDxBitmap;
    int iDyBitmap;
    int iButWidth;
    int iButHeight;
    int iButMinWidth;           // The min and max width of the button. If the app does not
    int iButMaxWidth;           // have an opinion on what the min and max should be, these will be 0
    int iYPos;
    int iNumButtons;
    int dyIconFont;
    int dxDDArrowChar;
    int xFirstButton;
    int xPad;
    int yPad;
    int iListGap;               // space between icon and text on list-style buttons
    int iDropDownGap;           // padding after text on list-style drop-down buttons
    SIZE szCached;
    
    HDRAGPROXY hDragProxy;
    
    UINT uDrawText;
    UINT uDrawTextMask;

    COLORSCHEME clrsc;

    TBIMAGELISTS* pimgs;
    int cPimgs;
    
    int iHot;                   // Index of the currently Hot Tracked Button
    int iPressedDD;             // Index of the currently pressed dropdown button
    int iInsert;                // Index of the insertion mark, or -1 if none
    COLORREF    clrim;          // current insert mark color
    RECT rcInvalid;             // Saved invalid rectangle

    BITBOOL fHimlValid : 1;
    BITBOOL fHimlNative : 1;
    BITBOOL fFontCreated: 1;
    BITBOOL fNoStringPool :1;
    BITBOOL fTTNeedsFlush :1;

    BITBOOL fMouseTrack: 1;     // Are we currently tracking Mouse over this toolbar ?
    BITBOOL fActive: 1;
    BITBOOL fAnchorHighlight: 1;// TRUE: anchor the highlight to current position 
                                //       when mouse goes out of toolbar
    BITBOOL fRightDrag: 1;      // TRUE if current drag is right drag
    BITBOOL fDragOutNotify: 1;  // FALSE from start of drag until mouse leaves button
                                //       at which point it is TRUE until next drag
    BITBOOL fInsertAfter: 1;    // insert after (TRUE) or before (FALSE) button at iInsert?

    BITBOOL fRedrawOff : 1;     // did we get a WM_SETREDRAW = FALSE
    BITBOOL fInvalidate : 1;    // did we get any paint messages whilst we were fRedrawOff
    BITBOOL fRecalc : 1;        // did we try to call TBRecalc while we were fRedrawOff?
    
    BITBOOL fRequeryCapture :1; // app hack see comment on lbutton up
    BITBOOL fShowPrefix: 1;     // Show the underline of an item. Set with WM_KEYBOARDCUES

    BITBOOL fItemRectsValid:1;  // Are the cached button item rects valid?
    BITBOOL fAntiAlias: 1;    // Turn off AntiAliasing durning the create of a drag image.
    
    RECT rc;                    // cache rc of toolbar. (used only for TBSTYLE_EX_MULTICOL and TBSTYLE_EX_HIDECLIPPEDBUTTONS)
    SIZE sizeBound;             // largest bounding size in vertical multicolumn mode.
    
} TBSTATE, NEAR *PTBSTATE;

typedef struct {
/*REVIEW: index, command, flag words, resource ids should be UINT */
    int iBitmap;    /* index into bitmap of this button's picture */
    int idCommand;  /* WM_COMMAND menu ID that this button sends */
    BYTE fsState;   /* button's state */
    BYTE fsStyle;   /* button's style */
    int idsHelp;    /* string ID for button's status bar help */
} OLDTBBUTTON, FAR* LPOLDTBBUTTON;


typedef struct _TBDRAWITEM
{
    TBSTATE * ptb;
    LPTBBUTTONDATA pbutton;

    UINT state;
    BOOL fHotTrack;

    // himl and image index
    int iIndex;
    int iImage;

    DWORD dwCustom;
    NMTBCUSTOMDRAW tbcd;
} TBDRAWITEM, * PTBDRAWITEM;


#ifdef __cplusplus
extern "C" {
#endif
    
HIMAGELIST TBGetImageList(PTBSTATE ptb, int iMode, int iIndex);
HIMAGELIST TBSetImageList(PTBSTATE ptb, int iMode, int iIndex, HIMAGELIST himl);
#define GET_HIML_INDEX GET_Y_LPARAM
#define GET_IMAGE_INDEX GET_X_LPARAM

HBITMAP FAR PASCAL SelectBM(HDC hDC, PTBSTATE pTBState, int nButton);
void FAR PASCAL DrawButton(HDC hdc, int x, int y, PTBSTATE pTBState, LPTBBUTTONDATA ptButton, BOOL fActive);
void DrawFace(HDC hdc, int x, int y, int offx, int offy, int dxText, 
              int dyText, TBDRAWITEM * ptbdraw);
int  FAR PASCAL TBHitTest(PTBSTATE pTBState, int xPos, int yPos);
int  FAR PASCAL PositionFromID(PTBSTATE pTBState, LONG_PTR id);
void FAR PASCAL BuildButtonTemplates(void);
void FAR PASCAL TBInputStruct(PTBSTATE ptb, LPTBBUTTONDATA pButtonInt, LPTBBUTTON pButtonExt);
void NEAR PASCAL TBOutputStruct(PTBSTATE ptb, LPTBBUTTONDATA pButtonInt, LPTBBUTTON pButtonExt);

BOOL FAR PASCAL SaveRestore(PTBSTATE pTBState, BOOL bWrite, LPTSTR FAR *lpNames);
BOOL FAR PASCAL SaveRestoreFromReg(PTBSTATE ptb, BOOL bWrite, HKEY hkr, LPCTSTR pszSubKey, LPCTSTR pszValueName);

void FAR PASCAL CustomizeTB(PTBSTATE pTBState, int iPos);
void FAR PASCAL MoveButton(PTBSTATE pTBState, int nSource);
BOOL FAR PASCAL DeleteButton(PTBSTATE ptb, UINT uIndex);
BOOL FAR PASCAL TBReallocButtons(PTBSTATE ptb, UINT uButtons);
BOOL FAR PASCAL TBInsertButtons(PTBSTATE ptb, UINT uWhere, UINT uButtons, LPTBBUTTON lpButtons, BOOL fNative);

LRESULT FAR PASCAL SendItemNotify(PTBSTATE ptb, int iItem, int code);
void TBInvalidateItemRects(PTBSTATE ptb);
void PASCAL ReleaseMonoDC(PTBSTATE ptb);
void InitTBDrawItem(TBDRAWITEM * ptbdraw, PTBSTATE ptb, LPTBBUTTONDATA pbutton, 
                    UINT state, BOOL fHotTrack, int dxText, int dyText);
BOOL TBGetInfoTip(PTBSTATE ptb, LPTOOLTIPTEXT lpttt, LPTBBUTTONDATA pTBButton);
extern const int g_dxButtonSep;

BOOL TB_GetItemRect(PTBSTATE ptb, UINT uButton, LPRECT lpRect);

#ifdef __cplusplus
}
#endif

#endif // _TOOLBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\tooltips.c ===
#include "ctlspriv.h"

#define TF_TT 0x10

//#define TTDEBUG

#define ACTIVE          0x10
#define BUTTONISDOWN    0x20
#define BUBBLEUP        0x40
#define VIRTUALBUBBLEUP 0x80  // this is for dead areas so we won't
                                //wait after moving through dead areas
#define TRACKMODE       0x01

#define MAXTIPSIZE       128
#define INITIALTIPSIZE    80
#define XTEXTOFFSET        2
#define YTEXTOFFSET        1
#define XBALLOONOFFSET    10
#define YBALLOONOFFSET     8
#define BALLOON_X_CORNER  13
#define BALLOON_Y_CORNER  13
#define STEMOFFSET        16
#define STEMHEIGHT        20
#define STEMWIDTH         14
#define MINBALLOONWIDTH   30 // min width for stem to show up

#define TTT_INITIAL        1
#define TTT_RESHOW         2
#define TTT_POP            3
#define TTT_AUTOPOP        4

#define TIMEBETWEENANIMATE  2000        // 2 Seconds between animates

#define MAX_TIP_CHARACTERS 100
#define TITLEICON_WIDTH   16
#define TITLEICON_HEIGHT  16
#define TITLEICON_DIST    8     // Distance from Icon to Title
#define TITLE_INFO_DIST   6     // Distance from the Title to the Tip Text
#define MAX_TIP_WIDTH     300   // Seems kind of arbitrary. Width of the tip.


typedef struct tagWIN95TOOLINFO {
    UINT cbSize;
    UINT uFlags;
    HWND hwnd;
    UINT uId;
    RECT rect;
    HINSTANCE hinst;
    LPSTR lpszText;
} WIN95TTTOOLINFO;


/* tooltips.c */

typedef struct {
    CONTROLINFO ci;
    //HWND hwnd;       // in ci
    int iNumTools;
    int iDelayTime;
    int iReshowTime;
    int iAutoPopTime;
    PTOOLINFO tools;
    PTOOLINFO pCurTool;
    BOOL fMyFont;
    HFONT hFont;
    //UINT uiCodePage; // in ci
    DWORD dwFlags;
    //DWORD dwStyle;   // in ci

    // Timer info;
    UINT_PTR idTimer;
    POINT pt;

    UINT_PTR idtAutoPop;

    // Tip buffer
    LPTSTR lpTipText;
    UINT   cchTipText;

    LPTSTR lpTipTitle;
    UINT   cchTipTitle; 
    UINT   uTitleBitmap;
    int    iTitleHeight;
    HIMAGELIST himlTitleBitmaps;

    POINT ptTrack; // the saved track point from TTM_TRACKPOSITION

    BOOL fBkColorSet :1;
    BOOL fTextColorSet :1;
    BOOL fUnderStem : 1;        // true if stem is under the balloon
    BOOL fInWindowFromPoint:1;  // handling a TTM_WINDOWFROMPOINT message
    BOOL fEverShown:1;          // Have we ever been shown before?
    COLORREF clrTipBk;          // This is joeb's idea...he wants it
    COLORREF clrTipText;        // to be able to _blend_ more, so...
    
    int  iMaxTipWidth;          // the maximum tip width
    RECT rcMargin;              // margin offset b/t border and text
    int  iStemHeight;           // balloon mode stem/wedge height
    DWORD dwLastDisplayTime;    // The tick count taken at the last display. Used for animate puroposes.
} CToolTipsMgr, NEAR *PToolTipsMgr;

#define TTToolHwnd(pTool)  ((pTool->uFlags & TTF_IDISHWND) ? (HWND)pTool->uId : pTool->hwnd)
#define IsTextPtr(lpszText)  (((lpszText) != LPSTR_TEXTCALLBACK) && (!IS_INTRESOURCE(lpszText)))

//
// Function prototypes
//
LRESULT WINAPI ToolTipsWndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
void NEAR PASCAL TTSetDelayTime(PToolTipsMgr pTtm, WPARAM wParam, LPARAM lParam);
int NEAR PASCAL TTGetDelayTime(PToolTipsMgr pTtm, WPARAM wParam);

BOOL ThunkToolInfoAtoW (LPTOOLINFOA lpTiA, LPTOOLINFOW lpTiW, BOOL bThunkText, UINT uiCodePage);
BOOL ThunkToolInfoWtoA (LPTOOLINFOW lpTiW, LPTOOLINFOA lpTiA, UINT uiCodePage);
BOOL ThunkToolTipTextAtoW (LPTOOLTIPTEXTA lpTttA, LPTOOLTIPTEXTW lpTttW, UINT uiCodePage);

#pragma code_seg(CODESEG_INIT)

BOOL FAR PASCAL InitToolTipsClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    // See if we must register a window class
    wc.lpfnWndProc = ToolTipsWndProc;

    wc.lpszClassName = c_szSToolTipsClass;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = NULL;
    wc.lpszMenuName = NULL;
    wc.hbrBackground = (HBRUSH)(NULL);
    wc.hInstance = hInstance;
    wc.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_SAVEBITS;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(PToolTipsMgr);

    RegisterClass(&wc);

    return TRUE;
}
#pragma code_seg()


/* _  G E T  H C U R S O R  P D Y 3 */
/*-------------------------------------------------------------------------
 %%Function: _GetHcursorPdy3
 %%Contact: migueldc

 With the new mouse drivers that allow you to customize the mouse
 pointer size, GetSystemMetrics returns useless values regarding
 that pointer size.

 Assumptions:
 1. The pointer's width is equal to its height. We compute
 its height and infer its width.
 2. The pointer's leftmost pixel is located in the 0th column
 of the bitmap describing it.
 3. The pointer's topmost pixel is located in the 0th row
 of the bitmap describing it.

 This function looks at the mouse pointer bitmap,
 to find out the height of the mouse pointer (not returned),
 the vertical distance between the cursor's hot spot and
 the cursor's lowest visible pixel (pdyBottom),
 the horizontal distance between the hot spot and the pointer's
 left edge (pdxLeft) annd the horizontal distance between the
 hot spot and the pointer's right edge (pdxRight).
 -------------------------------------------------------------------------*/
typedef WORD CURMASK;
#define _BitSizeOf(x) (sizeof(x)*8)

void NEAR PASCAL _GetHcursorPdy3(int *pdxRight, int *pdyBottom)
{
    int i;
    int iXOR = 0;
    int dy, dx;
    CURMASK CurMask[16*8];
    ICONINFO iconinfo;
    BITMAP bm;
    HCURSOR hCursor = GetCursor();

    *pdyBottom = 16; //best guess
    *pdxRight = 16;  //best guess
    if (!GetIconInfo(hCursor, &iconinfo))
        return;
    if (!GetObject(iconinfo.hbmMask, sizeof(bm), (LPSTR)&bm))
        return;
    if (!GetBitmapBits(iconinfo.hbmMask, sizeof(CurMask), CurMask))
        return;
    i = (int)(bm.bmWidth * bm.bmHeight / _BitSizeOf(CURMASK) );
    
    if (!iconinfo.hbmColor) 
    {
        // if no color bitmap, then the hbmMask is a double height bitmap
        // with the cursor and the mask stacked.
        iXOR = i - 1;
        i /= 2;    
    } 
    
    if ( i >= sizeof(CurMask)) i = sizeof(CurMask) -1;
    if (iXOR >= sizeof(CurMask)) iXOR = 0;
    
    for (i--; i >= 0; i--)
    {
        if (CurMask[i] != 0xFFFF || (iXOR && (CurMask[iXOR--] != 0)))
            break;
    }
    
    if (iconinfo.hbmColor) DeleteObject(iconinfo.hbmColor);
    if (iconinfo.hbmMask) DeleteObject(iconinfo.hbmMask);

    // Compute the pointer height
    dy = (i + 1) * _BitSizeOf(CURMASK) / (int)bm.bmWidth;
    dx = (i + 1) * _BitSizeOf(CURMASK) / (int)bm.bmHeight;

    // Compute the distance between the pointer's lowest, left, rightmost
    //  pixel and the HotSpotspot
    *pdyBottom = dy - (int)iconinfo.yHotspot;
    *pdxRight  = dx - (int)iconinfo.xHotspot;
}

// this returns the values in work area coordinates because
// that's what set window placement uses
void NEAR PASCAL _GetCursorLowerLeft(int *piLeft, int *piTop, int *piWidth, int *piHeight)
{
    DWORD dwPos;
    
    dwPos = GetMessagePos();
    _GetHcursorPdy3(piWidth, piHeight);
    *piLeft = GET_X_LPARAM(dwPos);
    *piTop  = GET_Y_LPARAM(dwPos) + *piHeight;
}

void NEAR PASCAL ToolTips_NewFont(PToolTipsMgr pTtm, HFONT hFont)
{
    if (pTtm->fMyFont && pTtm->hFont)
    {
        DeleteObject(pTtm->hFont);
        pTtm->fMyFont = FALSE;
    }

    if ( !hFont )
    {
        hFont = CCCreateStatusFont();
        pTtm->fMyFont = TRUE;
        
        if (!hFont) {
            hFont = g_hfontSystem;
            pTtm->fMyFont = FALSE;
        }
    }

    pTtm->hFont = hFont;
    pTtm->ci.uiCodePage = GetCodePageForFont(hFont);
}

BOOL NEAR PASCAL ChildOfActiveWindow(HWND hwndChild)
{
    HWND hwnd = hwndChild;
    HWND hwndActive = GetForegroundWindow();

    while (hwnd)    {
        if (hwnd == hwndActive)
            return TRUE;
        else
            hwnd = GetParent(hwnd);
    }
    return FALSE;
}

void NEAR PASCAL PopBubble(PToolTipsMgr pTtm)
{
    // we're at least waiting to show;
    DebugMsg(TF_TT, TEXT("PopBubble (killing timer)"));
    if(pTtm->idTimer) {
        KillTimer(pTtm->ci.hwnd, pTtm->idTimer);
        pTtm->idTimer = 0;
    }

    if (pTtm->idtAutoPop) {
        KillTimer(pTtm->ci.hwnd, pTtm->idtAutoPop);
        pTtm->idtAutoPop = 0;
    }


    if (IsWindowVisible(pTtm->ci.hwnd) && pTtm->pCurTool) {
        NMHDR nmhdr;
        nmhdr.hwndFrom = pTtm->ci.hwnd;
        nmhdr.idFrom = pTtm->pCurTool->uId;
        nmhdr.code = TTN_POP;

        SendNotifyEx(pTtm->pCurTool->hwnd, (HWND)-1,
                     TTN_POP, &nmhdr,
                     (pTtm->pCurTool->uFlags & TTF_UNICODE) ? 1 : 0);
    }

    KillTimer(pTtm->ci.hwnd, TTT_POP);
    ShowWindow(pTtm->ci.hwnd, SW_HIDE);
    pTtm->dwFlags &= ~(BUBBLEUP|VIRTUALBUBBLEUP);
    pTtm->pCurTool = NULL;

}

PToolTipsMgr NEAR PASCAL ToolTipsMgrCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct)
{
    PToolTipsMgr pTtm = (PToolTipsMgr)LocalAlloc(LPTR, sizeof(CToolTipsMgr));
    if (pTtm) {

        CIInitialize(&pTtm->ci, hwnd, lpCreateStruct);

        // LPTR zeros the rest of the struct for us
        TTSetDelayTime(pTtm, TTDT_AUTOMATIC, (LPARAM)-1);
        pTtm->dwFlags = ACTIVE;
        pTtm->iMaxTipWidth = -1;
        
        // These are the defaults (straight from cutils.c), 
        // but you can always change them...
        pTtm->clrTipBk = g_clrInfoBk;
        pTtm->clrTipText = g_clrInfoText;

        // Setup the default tooltip text buffer
        pTtm->lpTipText = LocalAlloc (LPTR, INITIALTIPSIZE * sizeof(TCHAR));

        if (pTtm->lpTipText) {
            pTtm->cchTipText = INITIALTIPSIZE;

        } else {
            LocalFree (pTtm);
            pTtm = NULL;
        }
    }
    return pTtm;
}

void NEAR PASCAL TTSetTimer(PToolTipsMgr pTtm, int id)
{
    int iDelayTime = 0;

    if(pTtm->idTimer) {
        KillTimer(pTtm->ci.hwnd, pTtm->idTimer);
    }

    switch (id) {
        case TTT_POP:
        case TTT_RESHOW:
            iDelayTime = pTtm->iReshowTime;
            if (iDelayTime < 0)
                iDelayTime = GetDoubleClickTime() / 5;
            break;

        case TTT_INITIAL:
            iDelayTime = pTtm->iDelayTime;
            if (iDelayTime < 0)
                iDelayTime = GetDoubleClickTime();
            break;

    case TTT_AUTOPOP:
        iDelayTime = pTtm->iAutoPopTime;
        if (iDelayTime < 0)
            iDelayTime = GetDoubleClickTime() * 10;
        pTtm->idtAutoPop = SetTimer(pTtm->ci.hwnd, id, iDelayTime, NULL);
        return;
    }

    
    DebugMsg(TF_TT, TEXT("TTSetTimer %d for %d ms"), id, iDelayTime);
    
    if (SetTimer(pTtm->ci.hwnd, id, iDelayTime, NULL) &&
        (id != TTT_POP)) {
        pTtm->idTimer = id;
        GetCursorPos(&pTtm->pt);
    }
}

//
//  Double-hack to solve blinky-tooltips problems.
//
//  fInWindowFromPoint makes us temporarily transparent.
//
//  Clear the WS_DISABLED flag to trick USER into hit-testing against us.
//  USER by default skips disabled windows.  Restore the flag afterwards.
//  VB in particular likes to run around disabling all top-level windows
//  owned by his process.
//
//  We must use SetWindowBits() instead of EnableWindow() because
//  EnableWindow() will mess with the capture and focus.
//
HWND TTWindowFromPoint(PToolTipsMgr pTtm, LPPOINT ppt)
{
    HWND hwnd;
    DWORD dwStyle;
    dwStyle = SetWindowBits(pTtm->ci.hwnd, GWL_STYLE, WS_DISABLED, 0);
    pTtm->fInWindowFromPoint = TRUE;
    hwnd = (HWND)SendMessage(pTtm->ci.hwnd, TTM_WINDOWFROMPOINT, 0, (LPARAM)ppt);
    pTtm->fInWindowFromPoint = FALSE;
    SetWindowBits(pTtm->ci.hwnd, GWL_STYLE, WS_DISABLED, dwStyle);
    return hwnd;
}

BOOL NEAR PASCAL ToolHasMoved(PToolTipsMgr pTtm)
{
    // this is in case Raymond pulls something sneaky like moving
    // the tool out from underneath the cursor.

    HWND hwnd;
    RECT rc;
    PTOOLINFO pTool = pTtm->pCurTool;

    if (!pTool)
        return TRUE;

    hwnd = TTToolHwnd(pTool);

    // if the window is no longer visible, or is no long a child
    // of the active (without the always tip flag)
    // also check window at point to ensure that the window isn't covered
    if (IsWindowVisible(hwnd) &&
        ((pTtm->ci.style & TTS_ALWAYSTIP) || ChildOfActiveWindow(hwnd)) &&
        (hwnd == TTWindowFromPoint(pTtm, &pTtm->pt))) {

        GetWindowRect(hwnd, &rc);
        if(PtInRect(&rc, pTtm->pt) )
            return FALSE;
    }

    return TRUE;
}

PTOOLINFO NEAR PASCAL FindTool(PToolTipsMgr pTtm, LPTOOLINFO lpToolInfo)
{
    int i;
    PTOOLINFO pTool;
    
    
    if (!(pTtm && lpToolInfo))
    {
        DebugMsg(TF_ALWAYS, TEXT("FindTool passed invalid argumnet. Exiting..."));
        return NULL;
    }

    // BUGBUG: in win95, this was NOT validated... by doing so now, we may
    // cause some compat problems... if so, we need to assume for 4.0 marked
    // guys that cbSize == &(0->lParam)
    if (lpToolInfo->cbSize > sizeof(TOOLINFO))
        return NULL;
        
    // you can pass in an index or a toolinfo descriptor
    if (IS_INTRESOURCE(lpToolInfo)) {
        i = PtrToUlong(lpToolInfo);
        if (i < pTtm->iNumTools) {
            return &pTtm->tools[i];
        } else
            return NULL;
        
    }
    
    for(i = 0 ; i < pTtm->iNumTools; i++) {
    pTool = &pTtm->tools[i];
    if((pTool->hwnd == lpToolInfo->hwnd) &&
       (pTool->uId == lpToolInfo->uId))
        return pTool;        
    }
    return NULL;
}


LRESULT WINAPI TTSubclassProc(HWND hwnd, UINT message, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData);

void NEAR PASCAL TTUnsubclassHwnd(HWND hwnd, HWND hwndTT, BOOL fForce)
{
    ULONG_PTR dwRefs;
    
    if (IsWindow(hwnd) &&
        GetWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT, (PULONG_PTR) &dwRefs))
    {
        if (!fForce && (dwRefs > 1))
            SetWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT, dwRefs - 1);
        else
            RemoveWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT);
    }
}

LRESULT WINAPI TTSubclassProc(HWND hwnd, UINT message, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData)
{
    if (((message >= WM_MOUSEFIRST) && (message <= WM_MOUSELAST)) ||
        (message == WM_NCMOUSEMOVE))
    {
        RelayToToolTips((HWND)uIdSubclass, hwnd, message, wParam, lParam);
    }
    else if (message == WM_NCDESTROY)
    {
        TTUnsubclassHwnd(hwnd, (HWND)uIdSubclass, TRUE);
    }

    return DefSubclassProc(hwnd, message, wParam, lParam);
}

void NEAR PASCAL TTSubclassHwnd(PTOOLINFO pTool, HWND hwndTT)
{
    HWND hwnd;
    
    if (IsWindow(hwnd = TTToolHwnd(pTool)))
    {
        ULONG_PTR dwRefs;

        GetWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT, &dwRefs);
        SetWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT, dwRefs + 1);
    }
}
    
    
void NEAR PASCAL TTSetTipText(LPTOOLINFO pTool, LPTSTR lpszText)
{
    // if it wasn't alloc'ed before, set it to NULL now so we'll alloc it
    // otherwise, don't touch it and it will be realloced
    if (!IsTextPtr(pTool->lpszText)) {
        pTool->lpszText = NULL;
    }
    
    if (IsTextPtr(lpszText)) {
        DebugMsg(TF_TT, TEXT("TTSetTipText %s"), lpszText);
        Str_Set(&pTool->lpszText, lpszText);
    } else {
        // if it was alloc'ed before free it now.
        Str_Set(&pTool->lpszText, NULL);
        pTool->lpszText = lpszText;
    }
}

LRESULT NEAR PASCAL AddTool(PToolTipsMgr pTtm, LPTOOLINFO lpToolInfo)
{
    PTOOLINFO pTool;
    PTOOLINFO ptoolsNew;
    LRESULT lResult;

    // bail for right now;
    
    if (lpToolInfo->cbSize > sizeof(TOOLINFO)) {
        ASSERT(0);
        return 0L;
    }

    // on failure to alloc do nothing.
    ptoolsNew = CCLocalReAlloc(pTtm->tools,
                               sizeof(TOOLINFO)*(pTtm->iNumTools+1));
    if ( !ptoolsNew )
            return 0L;
    
    if(pTtm->tools) {
        // realloc could have moved stuff around.  repoint pCurTool
        if (pTtm->pCurTool) {
            pTtm->pCurTool = ((PTOOLINFO)ptoolsNew) + (pTtm->pCurTool - pTtm->tools);
        }
    }
    
    pTtm->tools = ptoolsNew;
    

    pTool = &pTtm->tools[pTtm->iNumTools];
    pTtm->iNumTools++;
    hmemcpy(pTool, lpToolInfo, lpToolInfo->cbSize); 
    pTool->lpszText = NULL;

    //
    // If the tooltip will be displayed within a RTL mirrored window, then
    // simulate mirroring the tooltip. [samera]
    // 
    //
    if (IS_WINDOW_RTL_MIRRORED(lpToolInfo->hwnd) &&
        (!(pTtm->ci.dwExStyle & RTL_MIRRORED_WINDOW)))
    {
        // toggle (mirror) the flags
        pTool->uFlags ^= (TTF_RTLREADING | TTF_RIGHT);
    }

    TTSetTipText(pTool, lpToolInfo->lpszText);
    if (pTool->uFlags & TTF_SUBCLASS) {
        TTSubclassHwnd(pTool, pTtm->ci.hwnd);
    }

    if (!lpToolInfo->hwnd || !IsWindow(lpToolInfo->hwnd)) {
        lResult = NFR_UNICODE;
    } else if (pTool->uFlags & TTF_UNICODE) {
        lResult = NFR_UNICODE;
    } else {
        lResult = SendMessage (pTool->hwnd, WM_NOTIFYFORMAT,
                               (WPARAM)pTtm->ci.hwnd, NF_QUERY);
    }

    if (lResult == NFR_UNICODE) {
        pTool->uFlags |= TTF_UNICODE;
    }

#ifdef TTDEBUG
    DebugMsg(TF_TT, TEXT("Tool Added: ptr=%d, uFlags=%d, wid=%d, hwnd=%d"),
             pTool, pTool->uFlags, pTool->uId, pTool->hwnd);
#endif

    return 1L;
}

void NEAR PASCAL TTBeforeFreeTool(PToolTipsMgr pTtm, LPTOOLINFO pTool)
{
    if (pTool->uFlags & TTF_SUBCLASS) 
        TTUnsubclassHwnd(TTToolHwnd(pTool), pTtm->ci.hwnd, FALSE);

    // clean up
    TTSetTipText(pTool, NULL);
}

void NEAR PASCAL DeleteTool(PToolTipsMgr pTtm, LPTOOLINFO lpToolInfo)
{
    PTOOLINFO pTool;

    // bail for right now;
    if (lpToolInfo->cbSize > sizeof(TOOLINFO)) {
        ASSERT(0);
        return;
    }

    pTool = FindTool(pTtm, lpToolInfo);
    if(pTool) {
        if (pTtm->pCurTool == pTool)
            PopBubble(pTtm);

        TTBeforeFreeTool(pTtm, pTool);

        // replace it with the last one.. no need to waste cycles in realloc
        pTtm->iNumTools--;
        *pTool = pTtm->tools[pTtm->iNumTools]; // struct copy

        //cleanup if we moved the current tool
        if(pTtm->pCurTool == &pTtm->tools[pTtm->iNumTools])
            pTtm->pCurTool = pTool;
    }
}

// this strips out & markers so that people can use menu text strings
void NEAR PASCAL StripAccels(PToolTipsMgr pTtm)
{
    if (!(pTtm->ci.style & TTS_NOPREFIX)) {
        StripAccelerators(pTtm->lpTipText, pTtm->lpTipText, FALSE);
    }
}


//
//  The way we detect if a window is a toolbar or not is by asking it
//  for its MSAA class ID.  We cannot use GetClassWord(GCL_ATOM) because
//  Microsoft LiquidMotion **superclasses** the toolbar, so the classname
//  won't match.
//
#define IsToolbarWindow(hwnd) \
    (SendMessage(hwnd, WM_GETOBJECT, 0, OBJID_QUERYCLASSNAMEIDX) == MSAA_CLASSNAMEIDX_TOOLBAR)

LPTSTR NEAR PASCAL GetToolText(PToolTipsMgr pTtm, PTOOLINFO pTool)
{
    int id;
    HINSTANCE hinst;
    DWORD dwStrLen;
    TOOLTIPTEXT ttt;
    
    if (!pTool)
        return NULL;

#ifdef TTDEBUG
    DebugMsg(TF_TT, TEXT("        **Enter GetToolText: ptr=%d, wFlags=%d, wid=%d, hwnd=%d"),
             pTool, pTool->uFlags, pTool->uId, pTool->hwnd);
#endif

    if (pTtm->lpTipText) {
        *pTtm->lpTipText = TEXT('\0');
    } else {
        pTtm->lpTipText = LocalAlloc (LPTR, INITIALTIPSIZE * sizeof(TCHAR));
        pTtm->cchTipText = INITIALTIPSIZE;
    }

    if (pTool->lpszText == LPSTR_TEXTCALLBACK) {

        ttt.hdr.idFrom = pTool->uId;
        ttt.hdr.code = TTN_NEEDTEXT;
        ttt.hdr.hwndFrom = pTtm->ci.hwnd;

        ttt.szText[0] = TEXT('\0');
        ttt.lpszText = ttt.szText;
        ttt.uFlags = pTool->uFlags;
        ttt.lParam = pTool->lParam;
        ttt.hinst = NULL;

        SendNotifyEx(pTool->hwnd, (HWND) -1,
                     0, (NMHDR FAR *)&ttt,
                     (pTool->uFlags & TTF_UNICODE) ? 1 : 0);

        // APPHACK for Elcom Advanced Disk Catalog and for Microsoft
        // LiquidMotion:
        // they subclass toolbar & expect this notification to
        // be ANSI.  So if the UNICODE notification failed,
        // and our parent is a toolbar, then try again in ANSI.

        if (ttt.lpszText == ttt.szText && ttt.szText[0] == TEXT('\0') &&
            (pTool->uFlags & TTF_UNICODE) && pTtm->ci.iVersion < 5 &&
            IsToolbarWindow(pTool->hwnd)) {
            SendNotifyEx(pTool->hwnd, (HWND) -1,
                     0, (NMHDR FAR *)&ttt,
                     FALSE);
        }

        if (ttt.uFlags & TTF_DI_SETITEM) {
            if (IS_INTRESOURCE(ttt.lpszText)) {
                pTool->lpszText = ttt.lpszText;
                pTool->hinst = ttt.hinst;
            } else if (ttt.lpszText != LPSTR_TEXTCALLBACK) {
                TTSetTipText(pTool, ttt.lpszText);
            }
        }
        
        if (IsFlagPtr(ttt.lpszText))
            return NULL;

        //
        // we allow the RtlReading flag ONLY to be changed here.
        //
        if (ttt.uFlags & TTF_RTLREADING)
        {
            pTool->uFlags |= TTF_RTLREADING;
        }
        else
        {
            pTool->uFlags &= ~TTF_RTLREADING;
        }

        if (IS_INTRESOURCE(ttt.lpszText)) {
            id = PtrToUlong(ttt.lpszText);
            hinst = ttt.hinst;
            ttt.lpszText = ttt.szText;
            goto LoadFromResource;
        }
        
        if (*ttt.lpszText == TEXT('\0'))
            return NULL;


        dwStrLen = lstrlen(ttt.lpszText) + 1;
        if (pTtm->cchTipText < dwStrLen)
        {
            LPTSTR psz = LocalReAlloc (pTtm->lpTipText,
                                       dwStrLen * sizeof(TCHAR),
                                       LMEM_MOVEABLE);
            if (psz)
            {
                pTtm->lpTipText = psz;
                pTtm->cchTipText = dwStrLen;
            }
        }

        if (pTtm->lpTipText)
        {
            StringCchCopy(pTtm->lpTipText, pTtm->cchTipText, ttt.lpszText);
        }

        //
        //  if ttt.lpszText != ttt.szText and the ttt.uFlags has TTF_MEMALLOCED, then
        //  the ANSI thunk allocated the buffer for us, so free it.
        //

        if ((ttt.lpszText != ttt.szText) && (ttt.uFlags & TTF_MEMALLOCED)) {
            LocalFree (ttt.lpszText);
        }

        StripAccels(pTtm);

    } else if (pTool->lpszText && IS_INTRESOURCE(pTool->lpszText)) {
        id = PtrToLong(pTool->lpszText);
        hinst = pTool->hinst;

LoadFromResource:

        if (pTtm->lpTipText) {
            if (!LoadString(hinst, id, pTtm->lpTipText, pTtm->cchTipText))
                return NULL;

            StripAccels(pTtm);
        }

    } else  {
        // supplied at creation time.
#ifdef TTDEBUG
        DebugMsg(TF_TT, TEXT("GetToolText returns %s"), pTool->lpszText);
#endif

        if (pTool->lpszText && *pTool->lpszText) {

            dwStrLen = lstrlen(pTool->lpszText) + 1;
            if (pTtm->cchTipText < dwStrLen)
            {
                LPTSTR psz = LocalReAlloc (pTtm->lpTipText,
                                           dwStrLen * sizeof(TCHAR),
                                           LMEM_MOVEABLE);
                if (psz)
                {
                    pTtm->lpTipText = psz;
                    pTtm->cchTipText = dwStrLen;
                }
            }

            if (pTtm->lpTipText)
            {
                StringCchCopy(pTtm->lpTipText, pTtm->cchTipText, pTool->lpszText);
                StripAccels(pTtm);
            }
        }
    }

#ifdef TTDEBUG
    DebugMsg(TF_TT, TEXT("        **GetToolText returns %s"), pTtm->lpTipText ? pTtm->lpTipText : TEXT("NULL"));
#endif
    return pTtm->lpTipText;
}

LPTSTR NEAR PASCAL GetCurToolText(PToolTipsMgr pTtm)
{
    LPTSTR psz = NULL;
    if (pTtm->pCurTool)
        psz = GetToolText(pTtm, pTtm->pCurTool);

    // this could have changed during the WM_NOTIFY back
    if (!pTtm->pCurTool)
        psz = NULL;
    
    return psz;
}

void NEAR PASCAL GetToolRect(PTOOLINFO pTool, LPRECT lprc)
{
    if (pTool->uFlags & TTF_IDISHWND) {
        GetWindowRect((HWND)pTool->uId, lprc);
    } else {
        *lprc = pTool->rect;
        MapWindowPoints(pTool->hwnd, HWND_DESKTOP, (LPPOINT)lprc, 2);
    }
}

BOOL NEAR PASCAL PointInTool(PTOOLINFO pTool, HWND hwnd, int x, int y)
{
    // We never care if the point is in a track tool or we're using
    // a hit-test.
    if (pTool->uFlags & (TTF_TRACK | TTF_USEHITTEST))
        return FALSE;
    

    if (pTool->uFlags & TTF_IDISHWND) {
        if (hwnd == (HWND)pTool->uId) {
            return TRUE;
        }
    } else if(hwnd == pTool->hwnd) {
    POINT pt;
    pt.x = x;
    pt.y = y;
    if (PtInRect(&pTool->rect, pt)) {
        return TRUE;
    }
    }
    return FALSE;
}

#ifdef TTDEBUG
void NEAR PASCAL DebugDumpTool(PTOOLINFO pTool)
{
    if (pTool) {
        DebugMsg(TF_TT, TEXT("                DumpTool: (%d) hwnd = %d %d, %d %d %d %d"),pTool,
                 pTool->hwnd,
                 (UINT)pTool->uFlags,
                 pTool->rect.left, pTool->rect.top,
                 pTool->rect.right, pTool->rect.bottom);
    } else {
        DebugMsg(TF_TT, TEXT("                DumpTool: (NULL)"));
    }
}
#else
#define DebugDumpTool(p)
#endif

#define HittestInTool(pTool, hwnd, ht) \
    ((pTool->uFlags & TTF_USEHITTEST) && pTool->hwnd == hwnd && ht == pTool->rect.left)

PTOOLINFO NEAR PASCAL GetToolAtPoint(PToolTipsMgr pTtm, HWND hwnd, int x, int y, 
        int ht, BOOL fCheckText)
{
    PTOOLINFO pToolReturn = NULL;
    PTOOLINFO pTool;

    // short cut..  if we're in the same too, and the bubble is up (not just virtual)
    // return it.  this prevents us from having to poll all the time and
    // prevents us from switching to another tool when this one is good
    if ((pTtm->dwFlags & BUBBLEUP) && pTtm->pCurTool != NULL &&
        (HittestInTool(pTtm->pCurTool, hwnd, ht) ||
         PointInTool(pTtm->pCurTool, hwnd, x, y)))
    {
        return pTtm->pCurTool;
    }

#ifdef TTDEBUG
    DebugMsg(TF_TT, TEXT("******Entering GetToolAtPoint"));
#endif
    if(pTtm->iNumTools) {
        for(pTool = &pTtm->tools[pTtm->iNumTools-1];
            pTool >= pTtm->tools;
            pTool--) {

#ifdef TTDEBUG
            //DebugMsg(TF_TT, TEXT("    Point in Tool Check"));
            //DebugDumpTool(pTool);
#endif

        if(HittestInTool(pTool, hwnd, ht) || PointInTool(pTool, hwnd, x, y)) {
#ifdef TTDEBUG
                //DebugMsg(TF_TT, TEXT("        yes"));
#endif

                // if this tool has text, return it.
                // otherwise, save it away as a dead area tool,
                // and keep looking
                if (fCheckText) {
                    if (GetToolText(pTtm, pTool)) {
#ifdef TTDEBUG
                        //DebugMsg(TF_TT, TEXT("            Return! case it Has text"));
                        //DebugDumpTool(pTool);
#endif
                        return pTool;
                    } else if (pTtm->dwFlags & (BUBBLEUP|VIRTUALBUBBLEUP)) {
                        // only return this (only allow a virutal tool
                        // if there was previously a tool up.
                        // IE, we can't start things off with a virutal tool
                        pToolReturn = pTool;
                    }
                } else {
#ifdef TTDEBUG
                    //DebugMsg(TF_TT, TEXT("            Return! No text check"));
                    //DebugDumpTool(pTool);
#endif
                    return pTool;
                }
            }
    }
    }
#ifdef TTDEBUG
    DebugMsg(TF_TT, TEXT("            Return! no text but returning anyways"));
    DebugDumpTool(pToolReturn);
#endif
    return pToolReturn;
}

void NEAR PASCAL ShowVirtualBubble(PToolTipsMgr pTtm)
{
    PTOOLINFO pTool = pTtm->pCurTool;

    DebugMsg(TF_TT, TEXT("Entering ShowVirtualBubble so popping bubble"));
    PopBubble(pTtm);

    // Set this back in so that while we're in this tool's area,
    // we won't keep querying for info
    pTtm->pCurTool = pTool;
    pTtm->dwFlags |= VIRTUALBUBBLEUP;
}

#define TRACK_TOP    0
#define TRACK_LEFT   1
#define TRACK_BOTTOM 2
#define TRACK_RIGHT  3 


void NEAR PASCAL TTGetTipPosition(PToolTipsMgr pTtm, LPRECT lprc, int cxText, int cyText, int *pxStem, int *pyStem)
{
    RECT rcWorkArea;
    // ADJUSTRECT!  Keep TTAdjustRect and TTM_GETBUBBLESIZE in sync.
    int cxMargin = pTtm->rcMargin.left + pTtm->rcMargin.right;
    int cyMargin = pTtm->rcMargin.top + pTtm->rcMargin.bottom;
    int iBubbleWidth =  2*XTEXTOFFSET * g_cxBorder + cxText + cxMargin;
    int iBubbleHeight = 2*YTEXTOFFSET * g_cyBorder + cyText + cyMargin;
    UINT uSide = (UINT)-1;
    RECT rcTool;
    MONITORINFO mi;
    HMONITOR    hMonitor;
    POINT pt;
    BOOL bBalloon = pTtm->ci.style & TTS_BALLOON;
    int  xStem, yStem;
    int iCursorHeight=0;
    int iCursorWidth=0;
        
    if (bBalloon  || pTtm->cchTipTitle)
    {
        // ADJUSTRECT!  Keep TTAdjustRect and TTM_GETBUBBLESIZE in sync.
        iBubbleWidth += 2*XBALLOONOFFSET;
        iBubbleHeight += 2*YBALLOONOFFSET;

        if (bBalloon)
        {
            if (iBubbleWidth < MINBALLOONWIDTH)
                pTtm->iStemHeight = 0;
            else
            {
                pTtm->iStemHeight = STEMHEIGHT;
                if (pTtm->iStemHeight > iBubbleHeight/3)
                    pTtm->iStemHeight = iBubbleHeight/3; // don't let the stem be longer than the bubble -- looks ugly
            }
        }
    }
    
    GetToolRect(pTtm->pCurTool, &rcTool);
    
    if (pTtm->pCurTool->uFlags & TTF_TRACK) {

        lprc->left = pTtm->ptTrack.x;
        lprc->top = pTtm->ptTrack.y;
        if (bBalloon)
        {
            // adjust the desired left hand side
            xStem = pTtm->ptTrack.x;
            yStem = pTtm->ptTrack.y;
        }

        // BUGBUG: should we not do this in case of TTS_BALLOON?
        if (pTtm->pCurTool->uFlags & TTF_CENTERTIP) {
            // center the bubble around the ptTrack
            lprc->left -= (iBubbleWidth / 2);
            if (!bBalloon)
                lprc->top -=  (iBubbleHeight / 2);
        }
        
        if (pTtm->pCurTool->uFlags & TTF_ABSOLUTE)
        {
            // with goto bellow we'll skip adjusting
            // bubble height -- so do it here
            if (bBalloon)
                iBubbleHeight += pTtm->iStemHeight;
            goto CompleteRect;
        }

        // in balloon style the positioning depends on the position
        // of the stem and we don't try to position the tooltip
        // next to the tool rect
        if (!bBalloon)
        {
            // now align it so that the tip sits beside the rect.
            if (pTtm->ptTrack.y > rcTool.bottom) 
            {
                uSide = TRACK_BOTTOM;
                if (lprc->top < rcTool.bottom)
                    lprc->top = rcTool.bottom;    
            }
            else if (pTtm->ptTrack.x < rcTool.left) 
            {
                uSide = TRACK_LEFT;
                if (lprc->left + iBubbleWidth > rcTool.left)
                    lprc->left = rcTool.left - iBubbleWidth;
            } 
            else if (pTtm->ptTrack.y < rcTool.top) 
            {    
                uSide = TRACK_TOP;
                if (lprc->top + iBubbleHeight > rcTool.top) 
                    lprc->top = rcTool.top - iBubbleHeight;    
            } 
            else 
            {    
                uSide = TRACK_RIGHT;
                if (lprc->left < rcTool.right)
                    lprc->left = rcTool.right;
            }
        }        
    } 
    else if (pTtm->pCurTool->uFlags & TTF_CENTERTIP) 
    {
        lprc->left = (rcTool.right + rcTool.left - iBubbleWidth)/2;
        lprc->top = rcTool.bottom;
        if (bBalloon)
        {
            xStem = (rcTool.left + rcTool.right)/2;
            yStem = rcTool.bottom;
        }
    } 
    else 
    {
        // now set it
        _GetCursorLowerLeft((LPINT)&lprc->left, (LPINT)&lprc->top, &iCursorWidth, &iCursorHeight);
        if (bBalloon)
        {
            HMONITOR  hMon1, hMon2;
            POINT     pt;
            BOOL      bOnSameMonitor = FALSE;
            int iTop = lprc->top - (iCursorHeight + iBubbleHeight + pTtm->iStemHeight);

            xStem = lprc->left;
            yStem = lprc->top;

            pt.x = xStem;
            pt.y = lprc->top;
            hMon1 = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);
            pt.y = iTop;
            hMon2 = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);

            if (hMon1 == hMon2)
            {
                // the hmons are the same but maybe iTop is off any monitor and we just defaulted 
                // to the nearest one -- check if it's really on the monitor
                mi.cbSize = sizeof(mi);
                GetMonitorInfo(hMon1, &mi);

                if (PtInRect(&mi.rcMonitor, pt))
                {
                    // we'd like to show balloon above the cursor so that wedge/stem points
                    // to tip of the cursor not its bottom left corner
                    yStem -= iCursorHeight;
                    lprc->top = iTop;
                    bOnSameMonitor = TRUE;
                }   
            }

            if (!bOnSameMonitor)
            {
                xStem += iCursorWidth/2;
                iCursorHeight = iCursorWidth = 0;
            }
        }
    }

    //
    //  At this point, (lprc->left, lprc->top) is the position
    //  at which we would prefer that the tooltip appear.
    //
    if (bBalloon)
    {
        // adjust the left point now that all calculations are done
        // but only if we're not in the center tip mode
        // note we use height as width so we can have 45 degree angle that looks nice
        if (!(pTtm->pCurTool->uFlags & TTF_CENTERTIP) && iBubbleWidth > STEMOFFSET + pTtm->iStemHeight)
            lprc->left -= STEMOFFSET;
        // adjust the height to include stem
        iBubbleHeight += pTtm->iStemHeight;
    }

    pt.x = lprc->left;
    pt.y = lprc->top;
    hMonitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &mi);
    
    if (GetWindowLong(pTtm->ci.hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
    {
        CopyRect(&rcWorkArea, &mi.rcMonitor);
    } else {
        CopyRect(&rcWorkArea, &mi.rcWork);
    }

    //
    //  At this point, rcWorkArea is the rectangle within which
    //  the tooltip should finally appear.
    //
    //  Now fiddle with the coordinates to try to find a sane location
    //  for the tip.
    //


    // move it up if it's at the bottom of the screen
    if ((lprc->top + iBubbleHeight) >= (rcWorkArea.bottom)) {
        if (uSide == TRACK_BOTTOM) 
            lprc->top = rcTool.top - iBubbleHeight;     // flip to top
        else 
        {
            //
            //  We can't "stick to bottom" because that would cause
            //  our tooltip to lie under the mouse cursor, causing it
            //  to pop immediately!  So go just above the mouse cursor.
            //
            // cannot do that in the track mode -- tooltip randomly on the 
            // screen, not even near the button
            //
            // BUGBUG raymondc v6: This messes up Lotus SmartCenter.
            // Need to be smarter about when it is safe to flip up.
            // Perhaps by checking if the upflip would put the tip too
            // far away from the mouse.
            if (pTtm->pCurTool->uFlags & TTF_TRACK)
                lprc->top = pTtm->ptTrack.y - iBubbleHeight;
            else
            {            
                int y = GET_Y_LPARAM(GetMessagePos());
                lprc->top = y - iBubbleHeight;
                if (bBalloon)
                    yStem = y;
            }
        }
    }
    
    // If above the top of the screen...
    if (lprc->top < rcWorkArea.top) 
    {
        if (uSide == TRACK_TOP) 
            lprc->top = rcTool.bottom;      // flip to bottom
        else 
            lprc->top = rcWorkArea.top;     // stick to top
    }

    // move it over if it extends past the right.
    if ((lprc->left + iBubbleWidth) >= (rcWorkArea.right)) 
    {
        // flipping is not the right thing to do with balloon style
        // because the wedge/stem can stick out of the window and 
        // would therefore be clipped so
        if (bBalloon)
        {
            // move it to the left so that stem appears on the right side of the balloon
            // again we use height as width so we can have 45 degree angle
            if (iBubbleWidth >= MINBALLOONWIDTH)
                lprc->left = xStem + min(STEMOFFSET, (iBubbleWidth-pTtm->iStemHeight)/2) - iBubbleWidth;
            // are we still out?
            if (lprc->left + iBubbleWidth >= rcWorkArea.right)
                lprc->left = rcWorkArea.right - iBubbleWidth - 1;
        }
        else if (uSide == TRACK_RIGHT) 
            lprc->left = rcTool.left - iBubbleWidth;    // flip to left
        else 
            // not in right tracking mode, just scoot it over
            lprc->left = rcWorkArea.right - iBubbleWidth - 1; // stick to right
    }

    // if too far left...
    if (lprc->left < rcWorkArea.left) 
    {
        if (uSide == TRACK_LEFT)
        {
            // flipping is not the right thing to do with balloon style
            // because the wedge/stem can stick out of the window and 
            // would therefore be clipped so
            if (bBalloon)
                lprc->left = rcWorkArea.left; //pTtm->ptTrack.x;
            else
                lprc->left = rcTool.right;          // flip to right
        }
        else 
            lprc->left = rcWorkArea.left;       // stick to left
    }
    
CompleteRect:
    lprc->right = lprc->left + iBubbleWidth;
    lprc->bottom = lprc->top + iBubbleHeight;
    if (bBalloon && pxStem && pyStem)
    {
        *pxStem = xStem;
        *pyStem = yStem;
    }
}

BOOL TTCreateTitleBitmaps(PToolTipsMgr pTtm)
{
    if (pTtm->himlTitleBitmaps)
        return TRUE;

    pTtm->himlTitleBitmaps = ImageList_Create(TITLEICON_WIDTH, TITLEICON_HEIGHT, ILC_COLOR24 | ILC_MASK, 3, 1);
    if (pTtm->himlTitleBitmaps)
    {
        HICON hicon;
        
        hicon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_TITLE_INFO), IMAGE_ICON, 
                  TITLEICON_WIDTH, TITLEICON_HEIGHT, LR_DEFAULTCOLOR);
        ImageList_AddIcon(pTtm->himlTitleBitmaps, hicon);
        DestroyIcon(hicon);
        hicon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_TITLE_WARNING), IMAGE_ICON, 
                  TITLEICON_WIDTH, TITLEICON_HEIGHT, LR_DEFAULTCOLOR);
        ImageList_AddIcon(pTtm->himlTitleBitmaps, hicon);
        DestroyIcon(hicon);
        hicon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_TITLE_ERROR), IMAGE_ICON, 
                  TITLEICON_WIDTH, TITLEICON_HEIGHT, LR_DEFAULTCOLOR);
        ImageList_AddIcon(pTtm->himlTitleBitmaps, hicon);
        DestroyIcon(hicon);
        return TRUE;
    }

    return FALSE;
}

// Called when caclulating the size of a "titled tool tip" or actually drawing
// based on the boolean value bCalcRect.
BOOL TTRenderTitledTip(PToolTipsMgr pTtm, HDC hdc, BOOL bCalcRect, RECT* prc, UINT uDrawFlags)
{
    RECT rc;
    int lWidth=0, lHeight=0;
    HFONT hfont;
    COLORREF crOldTextColor;
    int iOldBKMode;

    // If we don't have a title, we don't need to be here.
    if (pTtm->cchTipTitle == 0)
        return FALSE;

    CopyRect(&rc, prc);
    if (pTtm->uTitleBitmap != TTI_NONE)
    {
        lWidth    = TITLEICON_WIDTH + TITLEICON_DIST;
        lHeight  += TITLEICON_HEIGHT;
        if (!bCalcRect && pTtm->himlTitleBitmaps)
        {
            ImageList_Draw(pTtm->himlTitleBitmaps, pTtm->uTitleBitmap - 1, hdc, rc.left, rc.top, ILD_TRANSPARENT);
        }
        rc.left  += lWidth;
    }

    if (!bCalcRect)
    {
        crOldTextColor = SetTextColor(hdc, pTtm->clrTipText);
        iOldBKMode = SetBkMode(hdc, TRANSPARENT);
    }
    
    if (pTtm->lpTipTitle[0] != TEXT('\0'))
    {
        LOGFONT lf;
        HFONT   hfTitle;
        UINT    uFlags = uDrawFlags | DT_SINGLELINE; // title should be on one line only

        hfont = GetCurrentObject(hdc, OBJ_FONT);
        GetObject(hfont, sizeof(lf), &lf);
        lf.lfWeight = FW_BOLD;
        hfTitle = CreateFontIndirect(&lf);
        // hfont should already be set to this
        hfont = SelectObject(hdc, hfTitle);

        // drawtext does not calculate the height if these are specified
        if (!bCalcRect)
            uFlags |= DT_BOTTOM;

        // we need to calc title height -- either we did it before or we'll do it now
        ASSERT(pTtm->iTitleHeight != 0 || uFlags & DT_CALCRECT);

        // adjust the rect so we can stick the title to the bottom of it
        rc.bottom = rc.top + max(pTtm->iTitleHeight, TITLEICON_HEIGHT);
        // problems in DrawText if margins make rc.right < rc.left
        // even though we are asking for calculation of the rect nothing happens, so ...
        if (bCalcRect)
            rc.right = rc.left + MAX_TIP_WIDTH;

        DrawText(hdc, pTtm->lpTipTitle, lstrlen(pTtm->lpTipTitle), &rc, uFlags);

        if (pTtm->iTitleHeight == 0)
            pTtm->iTitleHeight = RECTHEIGHT(rc);    // Use rc instead of lfHeight, because it can be Negative.

        lHeight  = max(lHeight, pTtm->iTitleHeight) + TITLE_INFO_DIST;
        lWidth  += RECTWIDTH(rc);
        
        SelectObject(hdc, hfont);
        DeleteObject(hfTitle);
    }

    // adjust the rect for the info text
    CopyRect(&rc, prc);
    rc.top += lHeight;

    // we want multi line text -- tooltip will give us single line if we did not set MAXWIDTH
    uDrawFlags &= ~DT_SINGLELINE;
    DrawText(hdc, pTtm->lpTipText, lstrlen(pTtm->lpTipText), &rc, uDrawFlags);
    lHeight += RECTHEIGHT(rc);
    lWidth   = max(lWidth, RECTWIDTH(rc));

    if (bCalcRect)
    {
        prc->right = prc->left + lWidth;
        prc->bottom = prc->top + lHeight;
    }
    else
    {
        SetTextColor(hdc, crOldTextColor);
        SetBkMode(hdc, iOldBKMode);
    }

    return TRUE;
}

void NEAR PASCAL TTGetTipSize(PToolTipsMgr pTtm, PTOOLINFO pTool,LPTSTR lpstr, LPINT pcxText, LPINT pcyText)
{

    // get the size it will be
    HDC hdc  = GetDC(pTtm->ci.hwnd);
    HFONT hOldFont;
    
    if(pTtm->hFont) hOldFont = SelectObject(hdc, pTtm->hFont);

    /* If need to fire off the pre-DrawText notify then do so, otherwise use the
       original implementation that just called MGetTextExtent */


    {
        NMTTCUSTOMDRAW nm;
        DWORD dwCustom;
        UINT  uDefDrawFlags = 0;

        nm.nmcd.hdr.hwndFrom = pTtm->ci.hwnd;
        nm.nmcd.hdr.idFrom = pTool->uId;
        nm.nmcd.hdr.code = NM_CUSTOMDRAW;
        nm.nmcd.hdc = hdc;
        // TTGetTipSize must use CDDS_PREPAINT so the client can tell
        // whether we are measuring or painting
        nm.nmcd.dwDrawStage = CDDS_PREPAINT;
        nm.nmcd.rc.left = nm.nmcd.rc.top = 0;

        if (pTtm->ci.style & TTS_NOPREFIX)
            uDefDrawFlags = DT_NOPREFIX;

        if (pTtm->iMaxTipWidth == -1) 
        {
            uDefDrawFlags |= DT_CALCRECT|DT_SINGLELINE |DT_LEFT;
            MGetTextExtent(hdc, lpstr, -1, pcxText, pcyText);
            nm.nmcd.rc.right = *pcxText;
            nm.nmcd.rc.bottom = *pcyText;
            
        }
        else 
        {    
            uDefDrawFlags |= DT_CALCRECT | DT_LEFT | DT_WORDBREAK | DT_EXPANDTABS | DT_EXTERNALLEADING;
            nm.nmcd.rc.right = pTtm->iMaxTipWidth;
            nm.nmcd.rc.bottom = 0;
            DrawText( hdc, lpstr, lstrlen(lpstr), &nm.nmcd.rc, uDefDrawFlags );
            *pcxText = nm.nmcd.rc.right;
            *pcyText = nm.nmcd.rc.bottom;
        }

        if ( (pTtm->pCurTool->uFlags & TTF_RTLREADING) || (pTtm->ci.dwExStyle & WS_EX_RTLREADING) )
        {
            uDefDrawFlags |= DT_RTLREADING;
        }

        //
        // Make it right aligned, if requested. [samera]
        //
        if (pTool->uFlags & TTF_RIGHT)
            uDefDrawFlags |= DT_RIGHT;

        nm.uDrawFlags = uDefDrawFlags;

        dwCustom = (DWORD)SendNotifyEx(pTool->hwnd, (HWND) -1,
                     0, (NMHDR*) &nm,
                     (pTool->uFlags & TTF_UNICODE) ? 1 : 0);

        if (TTRenderTitledTip(pTtm, hdc, TRUE, &nm.nmcd.rc, uDefDrawFlags))
        {
            *pcxText = nm.nmcd.rc.right - nm.nmcd.rc.left;
            *pcyText = nm.nmcd.rc.bottom - nm.nmcd.rc.top;
        }
        else if ((dwCustom & CDRF_NEWFONT) || nm.uDrawFlags != uDefDrawFlags)
        {
            DrawText( hdc, lpstr, lstrlen(lpstr), &nm.nmcd.rc, nm.uDrawFlags );

            *pcxText = nm.nmcd.rc.right - nm.nmcd.rc.left;
            *pcyText = nm.nmcd.rc.bottom - nm.nmcd.rc.top;
        }
        // did the owner specify the size?
        else if (pTtm->ci.iVersion >= 5 && (nm.nmcd.rc.right - nm.nmcd.rc.left != *pcxText || 
                                            nm.nmcd.rc.bottom - nm.nmcd.rc.top != *pcyText))
        {
            *pcxText = nm.nmcd.rc.right - nm.nmcd.rc.left;
            *pcyText = nm.nmcd.rc.bottom - nm.nmcd.rc.top;
        }

        // notify parent afterwards if they want us to
        if (!(dwCustom & CDRF_SKIPDEFAULT) &&
            dwCustom & CDRF_NOTIFYPOSTPAINT) {
            nm.nmcd.dwDrawStage = CDDS_POSTPAINT;
            SendNotifyEx(pTool->hwnd, (HWND) -1,
                         0, (NMHDR*) &nm,
                         (pTool->uFlags & TTF_UNICODE) ? 1 : 0);
        }

    }


    if(pTtm->hFont) SelectObject(hdc, hOldFont);
    ReleaseDC(pTtm->ci.hwnd, hdc);

    // after the calc rect, add a little space on the right
    *pcxText += g_cxEdge;
    *pcyText += g_cyEdge;
}

//
//  Given an inner rectangle, return the coordinates of the outer,
//  or vice versa.
//
//  "outer rectangle" = window rectangle.
//  "inner rectangle" = the area where we draw the text.
//
//  This allows people like listview and treeview to position
//  the tooltip so the inner rectangle exactly coincides with
//  their existing text.
//
//  All the places we do rectangle adjusting are marked with
//  the comment
//
//      // ADJUSTRECT!  Keep TTAdjustRect in sync.
//
LRESULT TTAdjustRect(PToolTipsMgr pTtm, BOOL fLarger, LPRECT prc)
{
    RECT rc;

    if (!prc)
        return 0;

    //
    //  Do all the work on our private little rectangle on the
    //  assumption that everything is getting bigger.  At the end,
    //  we'll flip all the numbers around if in fact we're getting
    //  smaller.
    //
    rc.top = rc.left = rc.bottom = rc.right = 0;

    // TTRender adjustments -
    rc.left   -= XTEXTOFFSET*g_cxBorder + pTtm->rcMargin.left;
    rc.right  += XTEXTOFFSET*g_cxBorder + pTtm->rcMargin.right;
    rc.top    -= YTEXTOFFSET*g_cyBorder + pTtm->rcMargin.top;
    rc.bottom += YTEXTOFFSET*g_cyBorder + pTtm->rcMargin.bottom;

    // Compensate for the hack in TTRender that futzes all the rectangles
    // by one pixel.  Look for "Account for off-by-one."
    rc.bottom--;
    rc.right--;

    if (pTtm->ci.style & TTS_BALLOON || pTtm->cchTipTitle)
    {
        InflateRect(&rc, XBALLOONOFFSET, YBALLOONOFFSET);
    }

    //
    //  Ask Windows how much adjusting he will do to us.
    //
    //  Since we don't track WM_STYLECHANGED/GWL_EXSTYLE, we have to ask USER
    //  for our style information, since the app may have changed it.
    //
    AdjustWindowRectEx(&rc,
                       pTtm->ci.style,
                       BOOLFROMPTR(GetMenu(pTtm->ci.hwnd)),
                       GetWindowLong(pTtm->ci.hwnd, GWL_EXSTYLE));

    //
    //  Now adjust our caller's rectangle.
    //
    if (fLarger)
    {
        prc->left   += rc.left;
        prc->right  += rc.right;
        prc->top    += rc.top;
        prc->bottom += rc.bottom;
    }
    else
    {
        prc->left   -= rc.left;
        prc->right  -= rc.right;
        prc->top    -= rc.top;
        prc->bottom -= rc.bottom;
    }

    return TRUE;
}

#define CSTEMPOINTS 3
// bMirrored does not mean a mirrored tooltip.
// It means simulating the behavior or a mirrored tooltip for a tooltip created with a mirrored parent.
HRGN CreateBalloonRgn(int xStem, int yStem, int iWidth, int iHeight, int iStemHeight, BOOL bUnderStem, BOOL bMirrored)
{
    int  y = 0, yHeight = iHeight;
    HRGN rgn;

    if (bUnderStem)
        yHeight -= iStemHeight;
    else
        y = iStemHeight;
        
    rgn = CreateRoundRectRgn(0, y, iWidth, yHeight, BALLOON_X_CORNER, BALLOON_Y_CORNER);
    if (rgn)
    {
        // create wedge/stem rgn
        if (iWidth >= MINBALLOONWIDTH)
        {
            HRGN rgnStem;
            POINT aptStemRgn[CSTEMPOINTS];
            POINT *ppt = aptStemRgn;
            POINT pt;
            BOOL  bCentered;
            int   iStemWidth = iStemHeight+1; // for a 45 degree angle

            // we center the stem if we have TTF_CENTERTIP or the width
            // of the balloon is not big enough to offset the stem by 
            // STEMOFFSET
            // can't quite center the tip on TTF_CENTERTIP because it may be
            // moved left or right it did not fit on the screen: just check
            // if xStem is in the middle
            bCentered = (xStem == iWidth/2) || (iWidth < 2*STEMOFFSET + iStemWidth);

            if (bCentered)
                pt.x = (iWidth - iStemWidth)/2;
            else if (xStem > iWidth/2)
            {
                if(bMirrored)
                {
                    pt.x = STEMOFFSET + iStemWidth;
                }
                else
                {
                    pt.x = iWidth - STEMOFFSET - iStemWidth;
                }    
            }    
            else
            {
                if(bMirrored)
                {
                    pt.x = iWidth - STEMOFFSET;
                }
                else
                {
                    pt.x = STEMOFFSET;
                }    
            }    

            if (bMirrored && (ABS(pt.x - (iWidth - xStem)) <= 2))
            {
                pt.x = iWidth - xStem; // avoid rough edges, have a straight line
                
            }
            else if (!bMirrored && (ABS(pt.x - xStem) <= 2))
            {
                pt.x = xStem; // avoid rough edges, have a straight line
            }    
            if (bUnderStem)
                pt.y = iHeight - iStemHeight - 2;
            else
                pt.y = iStemHeight + 2;
            *ppt++ = pt;
            if(bMirrored)
            {
                pt.x -= iStemWidth;            
            }
            else
            {
                pt.x += iStemWidth;
            }    
            if (bMirrored && (ABS(pt.x - (iWidth - xStem)) <= 2))
            {
                pt.x = iWidth - xStem; // avoid rough edges, have a straight line
                
            }
            else if (!bMirrored && (ABS(pt.x - xStem) <= 2))
            {
                pt.x = xStem; // avoid rough edges, have a straight line
            }    
            *ppt++ = pt;
            if(bMirrored)
            {
                pt.x = iWidth - xStem;
            }
            else
            {
                pt.x = xStem;                
            }
            pt.y = yStem;
            *ppt = pt;

            rgnStem = CreatePolygonRgn(aptStemRgn, CSTEMPOINTS, ALTERNATE);
            if (rgnStem)
            {
                CombineRgn(rgn, rgn, rgnStem, RGN_OR);
                DeleteObject(rgnStem);
            }
        }
    }
    return rgn;
}

void NEAR PASCAL DoShowBubble(PToolTipsMgr pTtm)
{
    HFONT hFontPrev;
    RECT rc;
    int cxText, cyText;
    int xStem, yStem;
    LPTSTR lpstr;
    NMTTSHOWINFO si;
    
    DebugMsg(TF_TT, TEXT("Entering DoShowBubble"));
    
    lpstr = GetCurToolText(pTtm);

    if (pTtm->dwFlags & TRACKMODE) {
        
        if (!lpstr || !*lpstr) {
            PopBubble(pTtm);
            pTtm->dwFlags &= ~TRACKMODE;
            return;
        }
        
    } else {

        TTSetTimer(pTtm, TTT_POP);
        if( !lpstr || !*lpstr ) {

            ShowVirtualBubble(pTtm);
            return;
        }
        TTSetTimer(pTtm, TTT_AUTOPOP);
    }
    

    do {
        // get the size it will be
        TTGetTipSize(pTtm, pTtm->pCurTool, lpstr, &cxText, &cyText);
        TTGetTipPosition(pTtm, &rc, cxText, cyText, &xStem, &yStem);

        {
            UINT uFlags = SWP_NOACTIVATE | SWP_NOZORDER;

            if (pTtm->ci.style & TTS_BALLOON)
                uFlags |= SWP_HIDEWINDOW;
            SetWindowPos(pTtm->ci.hwnd, NULL, rc.left, rc.top,
                         rc.right-rc.left, rc.bottom-rc.top, uFlags);
        }

        // BUGBUG: chicago id was busted.  I *hope* no one relied on it...
        // bzzzz...  folks did.  we're stuck with it
        si.hdr.hwndFrom = pTtm->ci.hwnd;
        si.hdr.idFrom = pTtm->pCurTool->uId;
        si.hdr.code = TTN_SHOW;
        si.dwStyle = pTtm->ci.style;

        hFontPrev = pTtm->hFont;
        if (!SendNotifyEx(pTtm->pCurTool->hwnd, (HWND)-1,
                          TTN_SHOW, &si.hdr,
                          (pTtm->pCurTool->uFlags & TTF_UNICODE) ? 1 : 0)) {

            // Bring to top only if we are an unowned tooltip, since we
            // may have sunken below our tool in the Z-order.  Do this
            // only if unowned; if we are owned, then USER will make sure
            // we are above our owner.
            //
            // We must scrupulously avoid messing with our Z-order in the
            // owned case, because Office curiously creates a tooltip
            // owned by toplevel window 1, but attached to a tool on
            // toplevel window 2.  When you hover over window 2, the
            // tooltip from window 1 wants to appear.  If we brought
            // ourselves to the top, this would also bring window 1
            // to the top (because USER raises and lowers owned/owner
            // windows as a group).  Result:  Window 1 covers window 2.

            UINT uFlags = SWP_NOACTIVATE | SWP_NOSIZE;
            if (GetWindow(pTtm->ci.hwnd, GW_OWNER))
                uFlags |= SWP_NOZORDER;

            SetWindowPos(pTtm->ci.hwnd, HWND_TOP, rc.left, rc.top,
                         0, 0, uFlags);
        }
    
    } while (hFontPrev != pTtm->hFont);

    // create the balloon region if necessary
    // Note: Don't use si.dwStyle here, since other parts of comctl32
    // look at pTtm->ci.style to decide what to do
    if (pTtm->ci.style & TTS_BALLOON)
    {
        HRGN rgn;
        BOOL bMirrored = FALSE;
        if(pTtm->pCurTool)
        {
            bMirrored = (IS_WINDOW_RTL_MIRRORED(pTtm->pCurTool->hwnd) && (!(pTtm->ci.dwExStyle & RTL_MIRRORED_WINDOW)));
        }
        pTtm->fUnderStem = yStem >= rc.bottom-1;
        rgn = CreateBalloonRgn(bMirrored ? (rc.right - xStem) : (xStem - rc.left), yStem-rc.top, rc.right-rc.left, rc.bottom-rc.top, 
                               pTtm->iStemHeight, pTtm->fUnderStem, bMirrored);

        if (rgn && !SetWindowRgn(pTtm->ci.hwnd, rgn, FALSE))
            DeleteObject(rgn);
         // AnimateWindow does not support regions so we must do SetWindowPos    
        SetWindowPos(pTtm->ci.hwnd,HWND_TOP,0,0,0,0,SWP_NOACTIVATE|SWP_SHOWWINDOW|SWP_NOSIZE|SWP_NOMOVE);
    }
    else
    {
        BOOL fAllowFade = !(si.dwStyle & TTS_NOFADE);
        BOOL fAllowAnimate = !(si.dwStyle & TTS_NOANIMATE);
        DWORD dwCurrentTime = (pTtm->dwLastDisplayTime == 0)? TIMEBETWEENANIMATE : GetTickCount();
        DWORD dwDelta = dwCurrentTime - pTtm->dwLastDisplayTime;


        // If we're under the minimum time between animates, then we don't animate
        if (dwDelta < TIMEBETWEENANIMATE)
            fAllowFade = fAllowAnimate = FALSE;

        CoolTooltipBubble(pTtm->ci.hwnd, &rc, fAllowFade, fAllowAnimate);

        pTtm->dwLastDisplayTime = GetTickCount();

        //
        //  HACK! for MetaStock 6.5.  They superclass the tooltips class and install
        //  their own class which takes over WM_PAINT completely.  Animation causes
        //  them to get confused because that causes us to receive a WM_PRINTCLIENT,
        //  which causes TTRender to send a TTN_NEEDTEXT, and they never expected
        //  to receive that notification at that time.
        //
        //  We used to show ourselves with an empty window region, then see if the
        //  WM_PAINT ever reached us.  Unfortunately, that roached Outlook.  So we
        //  just look at the flag afterwards.  This means that MetaStock's first
        //  tooltip will look bad, but the rest will be okay.
        //
        if (pTtm->ci.iVersion < 4 && !pTtm->fEverShown &&
            (si.dwStyle & (TTS_NOFADE | TTS_NOANIMATE)) == 0) {
            // Force a WM_PAINT message so we can check if we got it
            InvalidateRect(pTtm->ci.hwnd, NULL, TRUE);
            UpdateWindow(pTtm->ci.hwnd);
            if (!pTtm->fEverShown) {
                // Detected a hacky app.  Turn off animation.
                SetWindowBits(pTtm->ci.hwnd, GWL_STYLE, TTS_NOFADE | TTS_NOANIMATE,
                                                        TTS_NOFADE | TTS_NOANIMATE);
                pTtm->fEverShown = TRUE;        // don't make this check again
            }
        }
    }

    pTtm->dwFlags |= BUBBLEUP;
    RedrawWindow(pTtm->ci.hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW);
}

void NEAR PASCAL ShowBubbleForTool(PToolTipsMgr pTtm, PTOOLINFO pTool)
{
    DebugMsg(TF_TT, TEXT("ShowBubbleForTool"));
    // if there's a bubble up for a different tool, pop it.
    if ((pTool != pTtm->pCurTool) && (pTtm->dwFlags & BUBBLEUP)) {
        PopBubble(pTtm);
    }

    // if the bubble was for a different tool, or no bubble, show it
    if ((pTool != pTtm->pCurTool) || !(pTtm->dwFlags & (VIRTUALBUBBLEUP|BUBBLEUP))) {
        
        pTtm->pCurTool = pTool;
        DoShowBubble(pTtm);

    } else {
        DebugMsg(TF_TT, TEXT("ShowBubbleForTool not showinb bubble"));
    }
}

void NEAR PASCAL HandleRelayedMessage(PToolTipsMgr pTtm, HWND hwnd, 
        UINT message, WPARAM wParam, LPARAM lParam)
{
    int ht = HTERROR;

    if (pTtm->dwFlags & TRACKMODE) {
        // punt all messages if we're in track mode
        return;
    }
    
    if (pTtm->dwFlags & BUTTONISDOWN) {
        // verify that the button is down
        // this can happen if the tool didn't set capture so it didn't get the up message
        if (GetKeyState(VK_LBUTTON) >= 0 &&
            GetKeyState(VK_RBUTTON) >= 0 &&
            GetKeyState(VK_MBUTTON) >= 0)
            pTtm->dwFlags &= ~BUTTONISDOWN;
    }
    
    switch(message) {
    case WM_NCLBUTTONUP:
    case WM_NCRBUTTONUP:
    case WM_NCMBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONUP:
    case WM_LBUTTONUP:
        pTtm->dwFlags &= ~BUTTONISDOWN;
        break;

    case WM_NCLBUTTONDOWN:
    case WM_NCRBUTTONDOWN:
    case WM_NCMBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_LBUTTONDOWN:
        pTtm->dwFlags |= BUTTONISDOWN;
        ShowVirtualBubble(pTtm);
        break;

    case WM_NCMOUSEMOVE:
    {
        // convert to client coords
        POINT pt;
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        ScreenToClient(hwnd, &pt);
        lParam = MAKELONG(pt.x, pt.y);
        ht = (int) wParam;

        // Fall thru...
    }
    case WM_MOUSEMOVE: {

        PTOOLINFO pTool;
        // to prevent us from popping up when some
        // other app is active
        if(((!(pTtm->ci.style & TTS_ALWAYSTIP)) && !(ChildOfActiveWindow(hwnd))) ||
           !(pTtm->dwFlags & ACTIVE) ||
           (pTtm->dwFlags & BUTTONISDOWN))
        {
            break;
        }

        pTool = GetToolAtPoint(pTtm, hwnd, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), ht, FALSE);
        if(pTool) {
            int id;
            // show only if another is showing
            if (pTtm->dwFlags & (VIRTUALBUBBLEUP | BUBBLEUP)) {
                // call show if bubble is up to make sure we're showing
                // for the right tool
                if (pTool != pTtm->pCurTool) {

                    DebugMsg(TF_TT, TEXT("showing virtual bubble"));
                    PopBubble(pTtm);
                    pTtm->pCurTool = pTool;
                    ShowVirtualBubble(pTtm);
                    id = TTT_RESHOW;
                } else {
                    if (pTtm->idTimer == TTT_RESHOW) {
                        // if the timer is currently waiting to reshow,
                        // don't reset the timer on mouse moves
                        id = 0;
                    } else {
                        // if we're looking to pop the bubble,
                        // any mouse move within the same window
                        // should reset our timer.
                        id = TTT_POP;
                    }
                }

                if (pTtm->idtAutoPop)
                    TTSetTimer(pTtm, TTT_AUTOPOP);

            } else {
                pTtm->pCurTool = pTool;
                id = TTT_INITIAL;
            }

            DebugMsg(TF_TT, TEXT("MouseMove over pTool id = %d"), id);
            if (id)
                TTSetTimer(pTtm, id);

        } else {
            
            DebugMsg(TF_TT, TEXT("MouseMove over non-tool"));
            PopBubble(pTtm);
        }
        break;
        }
    }
}

void NEAR PASCAL TTUpdateTipText(PToolTipsMgr pTtm, LPTOOLINFO lpti)
{
    LPTOOLINFO lpTool;

    lpTool = FindTool(pTtm, lpti);
    if (lpTool) {
        lpTool->hinst = lpti->hinst;
        TTSetTipText(lpTool, lpti->lpszText);
        if (pTtm->dwFlags & TRACKMODE) {
            // if track mode is in effect and active, then
            // redisplay the bubble.
            if (pTtm->pCurTool)
                DoShowBubble(pTtm);
        } else
        if (lpTool == pTtm->pCurTool) {

            // set the current position to our saved position.
            // ToolHasMoved will return false for us if those this point
            // is no longer within pCurTool's area
            GetCursorPos(&pTtm->pt);
            if (!ToolHasMoved(pTtm)) {
                if (pTtm->dwFlags & ( VIRTUALBUBBLEUP | BUBBLEUP)) 
                    DoShowBubble(pTtm);
            } else {
                
                DebugMsg(TF_TT, TEXT("TTUpdateTipText popping bubble"));
                PopBubble(pTtm);
            }
        }
    }
}

void NEAR PASCAL TTSetFont(PToolTipsMgr pTtm, HFONT hFont, BOOL fInval)
{
    ToolTips_NewFont(pTtm, hFont);
    if (fInval)
    {
        // is a balloon up and is it in the track mode?
        if ((pTtm->dwFlags & ACTIVE) && pTtm->pCurTool && (pTtm->pCurTool->uFlags & TTF_TRACK))
        {
            PTOOLINFO pCurTool = pTtm->pCurTool;
            
            PopBubble(pTtm); // sets pTtm->pCurTool to NULL
            ShowBubbleForTool(pTtm, pCurTool);
        }
        else
            InvalidateRect(pTtm->ci.hwnd, NULL, FALSE);
    }
}

void NEAR PASCAL TTSetDelayTime(PToolTipsMgr pTtm, WPARAM wParam, LPARAM lParam)
{
    int iDelayTime = GET_X_LPARAM(lParam);

    switch (wParam) 
    {
    case TTDT_INITIAL:
        pTtm->iDelayTime = iDelayTime;
        break;

    case TTDT_AUTOPOP:
        pTtm->iAutoPopTime = iDelayTime;
        break;

    case TTDT_RESHOW:
        pTtm->iReshowTime = iDelayTime;
        break;

    case TTDT_AUTOMATIC:
        if (iDelayTime > 0)
        {
            pTtm->iDelayTime = iDelayTime;
            pTtm->iReshowTime = pTtm->iDelayTime / 5;
            pTtm->iAutoPopTime = pTtm->iDelayTime * 10;
        }
        else
        {
            pTtm->iDelayTime = -1;
            pTtm->iReshowTime = -1;
            pTtm->iAutoPopTime = -1;
        }
        break;
    }
}

int NEAR PASCAL TTGetDelayTime(PToolTipsMgr pTtm, WPARAM wParam)
{
    switch (wParam) {

    case TTDT_AUTOMATIC:
    case TTDT_INITIAL:
        return (pTtm->iDelayTime < 0 ? GetDoubleClickTime() : pTtm->iDelayTime);

    case TTDT_AUTOPOP:
        return (pTtm->iAutoPopTime < 0 ? GetDoubleClickTime()*10 : pTtm->iAutoPopTime);

    case TTDT_RESHOW:
        return (pTtm->iReshowTime < 0 ? GetDoubleClickTime()/5 : pTtm->iReshowTime);

    default:
        return -1;
    }
}

BOOL NEAR PASCAL CopyToolInfoA(PTOOLINFO pToolSrc, PTOOLINFOA lpTool, UINT uiCodePage)
{
    if (pToolSrc && lpTool)
    {
        if (lpTool->cbSize >= sizeof(TOOLINFOA) - sizeof(LPARAM))
        {
            lpTool->uFlags = pToolSrc->uFlags;
            lpTool->hwnd = pToolSrc->hwnd;
            lpTool->uId = pToolSrc->uId;
            lpTool->rect = pToolSrc->rect;
            lpTool->hinst = pToolSrc->hinst;
            if ((pToolSrc->lpszText != LPSTR_TEXTCALLBACK) &&
                !IS_INTRESOURCE(pToolSrc->lpszText))
            {
                if (lpTool->lpszText)
                {
                    WideCharToMultiByte(uiCodePage, 0,
                                                 pToolSrc->lpszText,
                                                 -1,
                                                 lpTool->lpszText,
                                                 80, NULL, NULL);
                }
            } 
            else 
            {
                lpTool->lpszText = (LPSTR)pToolSrc->lpszText;
            }
        }

        if (lpTool->cbSize > FIELD_OFFSET(TOOLINFOA, lParam))
            lpTool->lParam = pToolSrc->lParam;
        
        if (lpTool->cbSize > sizeof(TOOLINFOA))
            return FALSE;
            
        return TRUE;
    } 
    else
        return FALSE;
}

BOOL NEAR PASCAL CopyToolInfo(PTOOLINFO pToolSrc, PTOOLINFO lpTool)
{
    if (pToolSrc && lpTool && lpTool->cbSize <= sizeof(TOOLINFO))
    {
        if (lpTool->cbSize >= sizeof(TOOLINFO) - sizeof(LPARAM))
        {
            lpTool->uFlags = pToolSrc->uFlags;
            lpTool->hwnd = pToolSrc->hwnd;
            lpTool->uId = pToolSrc->uId;
            lpTool->rect = pToolSrc->rect;
            lpTool->hinst = pToolSrc->hinst;
            if ((pToolSrc->lpszText != LPSTR_TEXTCALLBACK) && !IS_INTRESOURCE(pToolSrc->lpszText)) 
            {
                if (lpTool->lpszText) 
                {
                    // REVIEW: message parameters do not indicate the size of the
                    // destination buffer.
                    StringCchCopy(lpTool->lpszText, lstrlen(pToolSrc->lpszText)+1, pToolSrc->lpszText);
                }
            }
            else 
                lpTool->lpszText = pToolSrc->lpszText;
        }
        if (lpTool->cbSize > FIELD_OFFSET(TOOLINFO, lParam))
            lpTool->lParam = pToolSrc->lParam;
        
        if (lpTool->cbSize > sizeof(TOOLINFO))
            return FALSE;
    
        return TRUE;
    }
    else
        return FALSE;
}

PTOOLINFO TTToolAtMessagePos(PToolTipsMgr pTtm)
{
    PTOOLINFO pTool;
    HWND hwndPt;
    POINT pt;
    DWORD dwPos = GetMessagePos();
    //int ht;

    pt.x = GET_X_LPARAM(dwPos);
    pt.y = GET_Y_LPARAM(dwPos);
    hwndPt = TTWindowFromPoint(pTtm, &pt);
    //ht = SendMessage(hwndPt, WM_NCHITTEST, 0, MAKELONG(pt.x, pt.y));
    ScreenToClient(hwndPt, &pt);
    pTool = GetToolAtPoint(pTtm, hwndPt, pt.x, pt.y, HTERROR, TRUE);

    return pTool;
}

void TTCheckCursorPos(PToolTipsMgr pTtm)
{
    PTOOLINFO pTool;

    pTool = TTToolAtMessagePos(pTtm);
    if ((pTtm->pCurTool != pTool) || 
        ToolHasMoved(pTtm)) {
        PopBubble(pTtm);

        DebugMsg(TF_TT, TEXT("TTCheckCursorPos popping bubble"));
    }
}

void NEAR PASCAL TTHandleTimer(PToolTipsMgr pTtm, UINT_PTR id)
{
    PTOOLINFO pTool;
    
    // punt all timers in track mode
    if (pTtm->dwFlags & TRACKMODE)
        return;

    switch (id) {

    case TTT_AUTOPOP:
        TTCheckCursorPos(pTtm); 
        if (pTtm->pCurTool) {
            DebugMsg(TF_TT, TEXT("ToolTips: Auto popping"));
            ShowVirtualBubble(pTtm);
        }
        break;

    case TTT_POP:

        // this could be started up again by a slight mouse touch
        if (pTtm->dwFlags & VIRTUALBUBBLEUP) {
            KillTimer(pTtm->ci.hwnd, TTT_POP);
        }

        TTCheckCursorPos(pTtm); 
        break;
        
    case TTT_INITIAL:
        if(ToolHasMoved(pTtm)) {
            // this means the timer went off
            // without us getting a mouse move
            // which means they left our tools.
            PopBubble(pTtm);
            break;
        }

        // else fall through

    case TTT_RESHOW:

        pTool = TTToolAtMessagePos(pTtm);
        if (!pTool) {
            if (pTtm->pCurTool) 
                PopBubble(pTtm);
        } else if (pTtm->dwFlags & ACTIVE) {
            if (id == TTT_RESHOW) {
                // this will force a re-show
                pTtm->dwFlags &= ~(BUBBLEUP|VIRTUALBUBBLEUP);
            }
            ShowBubbleForTool(pTtm, pTool);
        }
        break;  
    }
}    

BOOL TTRender(PToolTipsMgr pTtm, HDC hdc)
{
    BOOL bRet = FALSE;
    RECT rc;
    LPTSTR lpszStr;

    if (pTtm->pCurTool &&
        (lpszStr = GetCurToolText(pTtm)) &&
        *lpszStr) {
        UINT uFlags;
        NMTTCUSTOMDRAW nm;
        UINT uDefDrawFlags = 0;
        BOOL bUseDrawText;
        LPRECT prcMargin = &pTtm->rcMargin;

        HBRUSH hbr;
        DWORD  dwCustomDraw;

        uFlags = 0;

        if ( (pTtm->pCurTool->uFlags & TTF_RTLREADING) || (pTtm->ci.dwExStyle & WS_EX_RTLREADING) )
        {
            uFlags |= ETO_RTLREADING;
        }

        SelectObject(hdc, pTtm->hFont);
        GetClientRect(pTtm->ci.hwnd, &rc);
        SetTextColor(hdc, pTtm->clrTipText);

        /* If we support pre-Draw text then call the client allowing them to modify
         /  the item, and then render.  Otherwise just use ExTextOut */
        nm.nmcd.hdr.hwndFrom = pTtm->ci.hwnd;
        nm.nmcd.hdr.idFrom = pTtm->pCurTool->uId;
        nm.nmcd.hdr.code = NM_CUSTOMDRAW;
        nm.nmcd.hdc = hdc;
        nm.nmcd.dwDrawStage = CDDS_PREPAINT;

        // ADJUSTRECT!  Keep TTAdjustRect and TTGetTipPosition in sync.
        nm.nmcd.rc.left   = rc.left   + XTEXTOFFSET*g_cxBorder + prcMargin->left;
        nm.nmcd.rc.right  = rc.right  - XTEXTOFFSET*g_cxBorder - prcMargin->right;
        nm.nmcd.rc.top    = rc.top    + YTEXTOFFSET*g_cyBorder + prcMargin->top;
        nm.nmcd.rc.bottom = rc.bottom - YTEXTOFFSET*g_cyBorder - prcMargin->bottom;

        if (pTtm->ci.style & TTS_BALLOON)
        {
            InflateRect(&(nm.nmcd.rc), -XBALLOONOFFSET, -YBALLOONOFFSET);
            if (!pTtm->fUnderStem)
                OffsetRect(&(nm.nmcd.rc), 0, pTtm->iStemHeight);
        }

        if (pTtm->iMaxTipWidth == -1) 
            uDefDrawFlags = DT_SINGLELINE |DT_LEFT;
        else 
            uDefDrawFlags = DT_LEFT | DT_WORDBREAK | DT_EXPANDTABS | DT_EXTERNALLEADING;

        if (pTtm->ci.style & TTS_NOPREFIX)
            uDefDrawFlags |= DT_NOPREFIX;

        if ( (pTtm->pCurTool->uFlags & TTF_RTLREADING) || (pTtm->ci.dwExStyle & WS_EX_RTLREADING) )
        {
            uDefDrawFlags |= DT_RTLREADING;
        }

        //
        // Make it right aligned, if requested. [samera]
        //
        if (pTtm->pCurTool->uFlags & TTF_RIGHT)
            uDefDrawFlags |= DT_RIGHT;
 
        nm.uDrawFlags = uDefDrawFlags;

        dwCustomDraw = (DWORD)SendNotifyEx(pTtm->pCurTool->hwnd, (HWND) -1,
                     0, (NMHDR*) &nm,
                     (pTtm->pCurTool->uFlags & TTF_UNICODE) ? 1 : 0);
        // did the owner do custom draw? yes, we're done
        if (pTtm->ci.iVersion >= 5 && dwCustomDraw == CDRF_SKIPDEFAULT)
            return TRUE;

        bUseDrawText = (nm.uDrawFlags != uDefDrawFlags ||
                        !(uDefDrawFlags & DT_SINGLELINE) ||
                        (uDefDrawFlags & (DT_RTLREADING|DT_RIGHT)) ||
                        (pTtm->cchTipTitle != 0));

        if (pTtm->clrTipBk != GetNearestColor(hdc, pTtm->clrTipBk) ||
            bUseDrawText) 
        {
            // if this fails, it may be the a dither...
            // in which case, we can't set the bk color
            hbr = CreateSolidBrush(pTtm->clrTipBk);
            FillRect(hdc, &rc, hbr);
            DeleteObject(hbr);

            SetBkMode(hdc, TRANSPARENT);
            uFlags |= ETO_CLIPPED;
        } 
        else 
        {
            uFlags |= ETO_OPAQUE;
            SetBkColor(hdc, pTtm->clrTipBk);
        }

        if (bUseDrawText) 
        {
            // Account for off-by-one.  Something wierd about DrawText
            // clips the bottom-most pixelrow, so increase one more
            // into the margin space.

            // ADJUSTRECT!  Keep TTAdjustRect in sync.
            nm.nmcd.rc.bottom++;
            nm.nmcd.rc.right++;
            // if in balloon style the text is already indented so no need for inflate..
            if (pTtm->cchTipTitle > 0 && !(pTtm->ci.style & TTS_BALLOON))
                InflateRect(&nm.nmcd.rc, -XBALLOONOFFSET, -YBALLOONOFFSET);

            if (!TTRenderTitledTip(pTtm, hdc, FALSE, &nm.nmcd.rc, uDefDrawFlags))
                DrawText(hdc, lpszStr, lstrlen(lpszStr), &nm.nmcd.rc, nm.uDrawFlags);
        }
        else
        {
            // ADJUSTRECT!  Keep TTAdjustRect and TTGetTipPosition in sync.
            int x = XTEXTOFFSET*g_cxBorder + prcMargin->left;
            int y = YTEXTOFFSET*g_cyBorder + prcMargin->top;

            if (pTtm->ci.style & TTS_BALLOON)
            {
                HRGN rgn;
                
                x += XBALLOONOFFSET;
                y += YBALLOONOFFSET;
                InflateRect(&rc, -XBALLOONOFFSET, -YBALLOONOFFSET);
                if (!pTtm->fUnderStem)
                {
                    y += pTtm->iStemHeight;
                    OffsetRect(&rc, 0, pTtm->iStemHeight);
                }
                
                rgn = CreateRectRgn(1,1,2,2);
                if (rgn)
                {
                    int iRet = GetWindowRgn(pTtm->ci.hwnd, rgn);
                    if (iRet != ERROR)
                    {
                        // ExtTextOut only fills the rect specified and that
                        // only if uFlags & ETO_OPAQUE
                        HBRUSH hbr = CreateSolidBrush(pTtm->clrTipBk);
                        FillRgn(hdc, rgn, hbr);
                        DeleteObject(hbr);
                    }
                    DeleteObject(rgn);
                }
            }
            else if (pTtm->cchTipTitle > 0)
            {
                InflateRect(&rc, -XBALLOONOFFSET, -YBALLOONOFFSET);
            }

            if (!TTRenderTitledTip(pTtm, hdc, FALSE, &rc, uDefDrawFlags))
                ExtTextOut(hdc, x, y, uFlags, &rc, lpszStr, lstrlen(lpszStr), NULL);
        }

        if (pTtm->ci.style & TTS_BALLOON)
        {
            HRGN rgn = CreateRectRgn(1,1,2,2);

            if (rgn)
            {
                int iRet = GetWindowRgn(pTtm->ci.hwnd, rgn);
                if (iRet != ERROR)
                {
                    HBRUSH hbr = CreateSolidBrush(pTtm->clrTipText);
                    FrameRgn(hdc, rgn, hbr, 1, 1);
                    DeleteObject(hbr);
                }
                DeleteObject(rgn);
            }
        }

        // notify parent afterwards if they want us to
        if (!(dwCustomDraw & CDRF_SKIPDEFAULT) &&
            dwCustomDraw & CDRF_NOTIFYPOSTPAINT) {
            // Convert PREPAINT to POSTPAINT and ITEMPREPAINT to ITEMPOSTPAINT
            COMPILETIME_ASSERT(CDDS_POSTPAINT - CDDS_PREPAINT ==
                               CDDS_ITEMPOSTPAINT - CDDS_ITEMPREPAINT);
            nm.nmcd.dwDrawStage += CDDS_POSTPAINT - CDDS_PREPAINT;
            SendNotifyEx(pTtm->pCurTool->hwnd, (HWND) -1,
                         0, (NMHDR*) &nm,
                         (pTtm->pCurTool->uFlags & TTF_UNICODE) ? 1 : 0);
        }

        bRet = TRUE;
    }

    return bRet;
}

void TTOnPaint(PToolTipsMgr pTtm)
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(pTtm->ci.hwnd, &ps);

    if (!TTRender(pTtm, hdc)) {
        DebugMsg(TF_TT, TEXT("TTOnPaint render failed popping bubble"));
        PopBubble(pTtm);
    }

    EndPaint(pTtm->ci.hwnd, &ps);
    pTtm->fEverShown = TRUE;                // See TTOnFirstShow
}

LRESULT WINAPI ToolTipsWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PTOOLINFO pTool;
    PTOOLINFO pToolSrc;
    PToolTipsMgr pTtm = GetWindowPtr(hwnd, 0);
    
    if (!pTtm && uMsg != WM_CREATE)
        goto DoDefault;

    switch(uMsg)
    {
    case TTM_ACTIVATE:
        if (wParam) {
            pTtm->dwFlags |= ACTIVE;
        } else {
            PopBubble(pTtm);
            pTtm->dwFlags &= ~(ACTIVE | TRACKMODE);
        }
        break;

    case TTM_SETDELAYTIME:
        TTSetDelayTime(pTtm, wParam, lParam);
        break;

    case TTM_GETDELAYTIME:
        return (LRESULT)(UINT)TTGetDelayTime(pTtm, wParam);
        
    case TTM_ADDTOOLA:
        {
        LRESULT res;
        TOOLINFOW ti;

        if (!lParam) {
            return FALSE;
        }

        if (!ThunkToolInfoAtoW ((LPTOOLINFOA)lParam, &ti, TRUE, pTtm->ci.uiCodePage)) {
            return FALSE;
        }

        res = AddTool(pTtm, &ti);

        if ((ti.uFlags & TTF_MEMALLOCED) && (ti.lpszText != LPSTR_TEXTCALLBACK)) {
            LocalFree (ti.lpszText);
        }

        return res;
        }

    case TTM_ADDTOOL:
        if (!lParam)
            return FALSE;

        return AddTool(pTtm, (LPTOOLINFO)lParam);

    case TTM_DELTOOLA:
        {
        TOOLINFOW ti;

        if (!lParam) {
            return FALSE;
        }

        if (!ThunkToolInfoAtoW ((LPTOOLINFOA)lParam, &ti, FALSE, pTtm->ci.uiCodePage)) {
            break;
        }
        DeleteTool(pTtm, &ti);

        break;
        }
        
    case TTM_DELTOOL:
        if (!lParam)
            return FALSE;

        DeleteTool(pTtm, (LPTOOLINFO)lParam);
        break;

    case TTM_NEWTOOLRECTA:
        {
        TOOLINFOW ti;

        if (!lParam) {
            return FALSE;
        }

        if (!ThunkToolInfoAtoW ((LPTOOLINFOA)lParam, &ti, FALSE, pTtm->ci.uiCodePage)) {
            break;
        }

        pTool = FindTool(pTtm, &ti);
        if(pTool) {
            pTool->rect = ((LPTOOLINFOA)lParam)->rect;
        }

        break;
        }
        
    case TTM_NEWTOOLRECT:
        if (!lParam)
            return FALSE;

        pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
        if(pTool) {
            pTool->rect = ((LPTOOLINFO)lParam)->rect;
        }

        break;

    case TTM_GETTOOLCOUNT:
        return pTtm->iNumTools;

    case TTM_GETTOOLINFOA:
        {
        TOOLINFOW ti;

        if (!lParam) {
            return FALSE;
        }

        if (!ThunkToolInfoAtoW ((LPTOOLINFOA)lParam, &ti, FALSE, pTtm->ci.uiCodePage)) {
            return FALSE;
        }

        pToolSrc = FindTool(pTtm, &ti);

        return (LRESULT)(UINT)CopyToolInfoA(pToolSrc, (LPTOOLINFOA)lParam, pTtm->ci.uiCodePage);
        }

    case TTM_GETCURRENTTOOLA:
        if (lParam) 
            return (LRESULT)(UINT)CopyToolInfoA(pTtm->pCurTool, (LPTOOLINFOA)lParam, pTtm->ci.uiCodePage);
        else
            return BOOLFROMPTR(pTtm->pCurTool);

    case TTM_ENUMTOOLSA:
    {
        if (wParam < (UINT)pTtm->iNumTools) {
            pToolSrc = &pTtm->tools[wParam];
            return (LRESULT)(UINT)CopyToolInfoA(pToolSrc, (LPTOOLINFOA)lParam, pTtm->ci.uiCodePage);
        }
        return FALSE;
    }

    case TTM_GETTOOLINFO:
        if (!lParam)
            return FALSE;
        pToolSrc = FindTool(pTtm, (LPTOOLINFO)lParam);
        return (LRESULT)(UINT)CopyToolInfo(pToolSrc, (LPTOOLINFO)lParam);

    case TTM_GETCURRENTTOOL:
        if (lParam)
            return (LRESULT)(UINT)CopyToolInfo(pTtm->pCurTool, (LPTOOLINFO)lParam);
        else 
            return BOOLFROMPTR(pTtm->pCurTool);

    case TTM_ENUMTOOLS:
    {
        if (wParam < (UINT)pTtm->iNumTools) {
            pToolSrc = &pTtm->tools[wParam];
            return (LRESULT)(UINT)CopyToolInfo(pToolSrc, (LPTOOLINFO)lParam);
        }
        return FALSE;
    }

    case TTM_SETTOOLINFOA:
        {
        TOOLINFOW ti;

        if (!lParam) {
            return FALSE;
        }

        if (!ThunkToolInfoAtoW ((LPTOOLINFOA)lParam, &ti, TRUE, pTtm->ci.uiCodePage)) {
            return FALSE;
        }

        pTool = FindTool(pTtm, &ti);
        if (pTool)
        {
            TTSetTipText(pTool, NULL);
            hmemcpy(pTool, &ti, ti.cbSize);
            pTool->lpszText = NULL;
            TTSetTipText(pTool, ti.lpszText);

            if (pTool == pTtm->pCurTool)
            {
                DoShowBubble(pTtm);
            }
        }


        if ((ti.uFlags & TTF_MEMALLOCED) && (ti.lpszText != LPSTR_TEXTCALLBACK)) {
            LocalFree (ti.lpszText);
        }

        break;
        }

    case TTM_SETTOOLINFO:
        if (!lParam)
            return FALSE;
        pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
        if (pTool)
        {
            TTSetTipText(pTool, NULL);
            hmemcpy(pTool,(LPTOOLINFO)lParam, ((LPTOOLINFO)lParam)->cbSize); 
            pTool->lpszText = NULL;
            TTSetTipText(pTool, ((LPTOOLINFO)lParam)->lpszText);
            
            if (pTool == pTtm->pCurTool)
            {
                DoShowBubble(pTtm);
            }
        }
        break;

    case TTM_HITTESTA:
#define lphitinfoA ((LPHITTESTINFOA)lParam)
        if (!lParam)
            return FALSE;
        pTool = GetToolAtPoint(pTtm, lphitinfoA->hwnd, lphitinfoA->pt.x, lphitinfoA->pt.y, HTERROR, TRUE);
        if (pTool) {
            ThunkToolInfoWtoA(pTool, (LPTOOLINFOA)(&(lphitinfoA->ti)), pTtm->ci.uiCodePage);
            return TRUE;
        }
        return FALSE;

    case TTM_HITTEST:
#define lphitinfo ((LPHITTESTINFO)lParam)
        if (!lParam)
            return FALSE;
        pTool = GetToolAtPoint(pTtm, lphitinfo->hwnd, lphitinfo->pt.x, lphitinfo->pt.y, HTERROR, TRUE);
        if (pTool) {
            
            // for back compat...  if thesize isn't set right, we only give
            // them the win95 amount.
            if (lphitinfo->ti.cbSize != sizeof(TTTOOLINFO)) {
                *((WIN95TTTOOLINFO*)&lphitinfo->ti) = *(WIN95TTTOOLINFO*)pTool;
            } else {
                lphitinfo->ti = *pTool;
            }
            return TRUE;
        }
        return FALSE;

    case TTM_GETTEXTA:
    {
        LPWSTR lpszTemp;
        TOOLINFOW ti;

        if (!lParam || !((LPTOOLINFOA)lParam)->lpszText)
            return FALSE;

        if (!ThunkToolInfoAtoW((LPTOOLINFOA)lParam, &ti, FALSE, pTtm->ci.uiCodePage))
            break;
                       
        ((LPTOOLINFOA)lParam)->lpszText[0] = 0;
        pTool = FindTool(pTtm, &ti);
        lpszTemp = GetToolText(pTtm, pTool);
        if (lpszTemp) 
        {
            WideCharToMultiByte (pTtm->ci.uiCodePage,
                                 0,
                                 lpszTemp,
                                 -1,
                                 (((LPTOOLINFOA)lParam)->lpszText),
                                 80, NULL, NULL);
        }
        
        break;
    }

    case TTM_GETTEXT:
    {
        LPTSTR lpszTemp;
        if (!lParam || !pTtm || !((LPTOOLINFO)lParam)->lpszText)
            return FALSE;

        ((LPTOOLINFO)lParam)->lpszText[0] = 0;
        pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
        lpszTemp = GetToolText(pTtm, pTool);
        if (lpszTemp) 
        {
            // REVIEW: message parameters do not indicate the size of the
            // destination buffer.
            StringCchCopy((((LPTOOLINFO)lParam)->lpszText), lstrlen(lpszTemp)+1, lpszTemp);
        }
    }
        break;


    case WM_GETTEXTLENGTH:
    case WM_GETTEXT:
    {
        LPTSTR lpszStr;
        TCHAR *pszDest = uMsg == WM_GETTEXT ? (TCHAR *)lParam : NULL;
        LRESULT lres;

        // Pre-terminate the string just in case
        if (pszDest && wParam)
        {
            pszDest[0] = 0;
        }

        if (pTtm && (lpszStr = GetCurToolText(pTtm)))
        {
            if (pszDest && wParam)
            {
                StringCchCopy(pszDest, wParam, lpszStr);
                lres = lstrlen(pszDest);
            }
            else
            {
                lres = lstrlen(lpszStr);
            }
        }
        else
        {
            // No current tool
            lres = 0;
        }
        return lres;
    }

    case TTM_RELAYEVENT:
#define lpmsg ((LPMSG)lParam)
        if (!lParam)
            return FALSE;
        HandleRelayedMessage(pTtm, lpmsg->hwnd, lpmsg->message, lpmsg->wParam,
                lpmsg->lParam);
#undef lpmsg
        break;

        // this is here for people to subclass and fake out what we
        // think the window from point is.  this facilitates "transparent" windows
        case TTM_WINDOWFROMPOINT: {
            HWND hwndPt = WindowFromPoint(*((POINT FAR *)lParam));
            DebugMsg(TF_TT, TEXT("TTM_WINDOWFROMPOINT %x"), hwndPt);
            return (LRESULT)hwndPt;
        }

        case TTM_UPDATETIPTEXTA:
            {
            TOOLINFOW ti;

            if (lParam) {
                if (!ThunkToolInfoAtoW ((LPTOOLINFOA)lParam, &ti, TRUE, pTtm->ci.uiCodePage)) {
                    break;
                }
                TTUpdateTipText(pTtm, &ti);

                if ((ti.uFlags & TTF_MEMALLOCED) && (ti.lpszText != LPSTR_TEXTCALLBACK)) {
                    LocalFree (ti.lpszText);
                }
            }
            break;
            }

    case TTM_UPDATETIPTEXT:
        if (lParam)
            TTUpdateTipText(pTtm, (LPTOOLINFO)lParam);
        break;

    /* Pop the current tooltip if there is one displayed, ensuring that the virtual
    /  bubble is also discarded. */

    case TTM_POP:
    {
        if ( pTtm ->dwFlags & BUBBLEUP )
            PopBubble( pTtm );

        pTtm ->dwFlags &= ~VIRTUALBUBBLEUP;

        break;
    }


    case TTM_TRACKPOSITION:
        if ((GET_X_LPARAM(lParam) != pTtm->ptTrack.x) || 
            (GET_Y_LPARAM(lParam) != pTtm->ptTrack.y)) 
        {
            pTtm->ptTrack.x = GET_X_LPARAM(lParam); 
            pTtm->ptTrack.y = GET_Y_LPARAM(lParam);
        
            // if track mode is in effect, update the position
            if ((pTtm->dwFlags & TRACKMODE) && 
                pTtm->pCurTool) {
                DoShowBubble(pTtm);
            }
        }
        break;
        
    case TTM_UPDATE:
        if (!lParam ||
            lParam == (LPARAM)pTtm->pCurTool) {
            DoShowBubble(pTtm);
        }
        break;

    case TTM_TRACKACTIVATE:
        if (pTtm->dwFlags & ACTIVE) {
            if (wParam && lParam)
                wParam = TRACKMODE;
            else 
                wParam = 0;
            
            if ((wParam ^ pTtm->dwFlags) & TRACKMODE) {
                // if the trackmode changes by this..
                PopBubble(pTtm);

                pTtm->dwFlags ^= TRACKMODE;
                if (wParam) {

                    // turning on track mode
                    pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
                    if (pTool) {
                        // only if the tool is found
                        ShowBubbleForTool(pTtm, pTool);
                    }
                }
            }
        }
        return TRUE;
        
    case TTM_SETTIPBKCOLOR:
        if (pTtm->clrTipBk != (COLORREF)wParam) {
            pTtm->clrTipBk = (COLORREF)wParam;
            InvalidateRgn(pTtm->ci.hwnd,NULL,TRUE);
        }
        pTtm->fBkColorSet = TRUE;
        break;
        
    case TTM_GETTIPBKCOLOR:
        return (LRESULT)(UINT)pTtm->clrTipBk;
        
    case TTM_SETTIPTEXTCOLOR:
        if (pTtm->clrTipText != (COLORREF)wParam) {
            InvalidateRgn(pTtm->ci.hwnd,NULL,TRUE);
            pTtm->clrTipText = (COLORREF)wParam;
        }
        pTtm->fTextColorSet = TRUE;
        break;
        
    case TTM_GETTIPTEXTCOLOR:
        return (LRESULT)(UINT)pTtm->clrTipText;
        
    case TTM_SETMAXTIPWIDTH:
    {
        int iOld = pTtm->iMaxTipWidth;
        pTtm->iMaxTipWidth = (int)lParam;
        return iOld;
    }
        
    case TTM_GETMAXTIPWIDTH:
        return pTtm->iMaxTipWidth;
        
    case TTM_SETMARGIN:
        if (lParam)
            pTtm->rcMargin = *(LPRECT)lParam;
        break;

    case TTM_GETMARGIN:
        if (lParam)
            *(LPRECT)lParam = pTtm->rcMargin;
        break;

    case TTM_GETBUBBLESIZE:
        if (lParam)
        {
            pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
            if (pTool)
            {
                LPTSTR lpstr = GetToolText(pTtm, pTool);
                int    cxText, cyText, cxMargin, cyMargin, iBubbleWidth, iBubbleHeight;

                TTGetTipSize(pTtm, pTool, lpstr, &cxText, &cyText);

                cxMargin = pTtm->rcMargin.left + pTtm->rcMargin.right;
                cyMargin = pTtm->rcMargin.top + pTtm->rcMargin.bottom;
                iBubbleWidth =  2*XTEXTOFFSET * g_cxBorder + cxText + cxMargin;
                iBubbleHeight = 2*YTEXTOFFSET * g_cyBorder + cyText + cyMargin;

                if (pTtm->ci.style & TTS_BALLOON)
                {
                    iBubbleWidth += 2*XBALLOONOFFSET;
                    iBubbleHeight += 2*YBALLOONOFFSET;
                }   
                return MAKELONG(iBubbleWidth, iBubbleHeight);
            }
        }
        break;

    case TTM_ADJUSTRECT:
        return TTAdjustRect(pTtm, BOOLFROMPTR(wParam), (LPRECT)lParam);

    case TTM_SETTITLEA:
        {
            TCHAR szTitle[MAX_TIP_CHARACTERS];
            pTtm->uTitleBitmap = (UINT)wParam;
            Str_Set(&pTtm->lpTipTitle, NULL);
            pTtm->iTitleHeight = 0;

            TTCreateTitleBitmaps(pTtm);

            if (lParam)
            {
                pTtm->cchTipTitle = lstrlenA((LPCSTR)lParam);
                if (pTtm->cchTipTitle < ARRAYSIZE(szTitle))
                {
                    ConvertAToWN(pTtm->ci.uiCodePage, szTitle, ARRAYSIZE(szTitle),
                        (LPCSTR)lParam, -1);
                    Str_Set(&pTtm->lpTipTitle, szTitle);
                    return TRUE;
                }
            }
            pTtm->cchTipTitle = 0;
            return FALSE;
        }
        break;
    case TTM_SETTITLE:
        {
            pTtm->uTitleBitmap = (UINT)wParam;
            Str_Set(&pTtm->lpTipTitle, NULL);
            pTtm->iTitleHeight = 0;

            TTCreateTitleBitmaps(pTtm);

            if (lParam)
            {
                pTtm->cchTipTitle = lstrlen((LPCTSTR)lParam);
                if (pTtm->cchTipTitle < MAX_TIP_CHARACTERS)
                {
                    Str_Set(&pTtm->lpTipTitle, (LPCTSTR)lParam);
                    return TRUE;
                }
            }
            pTtm->cchTipTitle = 0;
            return FALSE;
        }
        break;


        /* uMsgs that REALLY came for me. */
    case WM_CREATE:
        {
            DWORD dwBits, dwValue;
            
            CCCreateWindow();
            pTtm = ToolTipsMgrCreate(hwnd, (LPCREATESTRUCT)lParam);
            if (!pTtm)
                return -1;
            
            SetWindowPtr(hwnd, 0, pTtm);
            SetWindowBits(hwnd, GWL_EXSTYLE, WS_EX_TOOLWINDOW, WS_EX_TOOLWINDOW);

            dwBits = WS_CHILD | WS_POPUP | WS_BORDER | WS_DLGFRAME;
            dwValue = WS_POPUP | WS_BORDER;
            // we don't want border for balloon style
            if (pTtm->ci.style & TTS_BALLOON)
                dwValue &= ~WS_BORDER;
            SetWindowBits(hwnd, GWL_STYLE, dwBits, dwValue);
            
            TTSetFont(pTtm, 0, FALSE);
            break;
        }

    case WM_TIMER:  
        TTHandleTimer(pTtm, wParam);
        break;

        
    case WM_NCHITTEST:
        // we should not return HTTRANSPARENT here because then we don't receive the mouse events
        // and we cannot forward them down to our parent. but because of the backcompat we keep doing
        // it unless we are using comctl32 v5 or greater
        //
        // If we are inside TTWindowFromPoint, then respect transparency
        // even on v5 clients.
        //
        // Otherwise, your tooltips flicker because the tip appears,
        // then WM_NCHITTEST says "not over the tool any more" (because
        // it's over the tooltip), so the bubble pops, and then the tip
        // reappears, etc.
        if (pTtm && (pTtm->ci.iVersion < 5 || pTtm->fInWindowFromPoint) &&
            pTtm->pCurTool && (pTtm->pCurTool->uFlags & TTF_TRANSPARENT))
        {
            return HTTRANSPARENT;
        } 
        goto DoDefault;
        
    case WM_MOUSEMOVE:
        // the cursor moved onto the tips window.
        if (!(pTtm->dwFlags & TRACKMODE) && pTtm->pCurTool && !(pTtm->pCurTool->uFlags & TTF_TRANSPARENT))
            PopBubble(pTtm);
        // fall through

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
        if (pTtm->pCurTool && (pTtm->pCurTool->uFlags & TTF_TRANSPARENT))
        {
            POINT pt;
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
            
            MapWindowPoints(pTtm->ci.hwnd, pTtm->pCurTool->hwnd, &pt, 1);
            SendMessage(pTtm->pCurTool->hwnd, uMsg, wParam, MAKELPARAM(pt.x, pt.y));
        }
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        if (pTtm) {
            if (!pTtm->fBkColorSet)
                pTtm->clrTipBk = g_clrInfoBk;
            if (!pTtm->fTextColorSet)
                pTtm->clrTipText = g_clrInfoText;
        }
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        if (pTtm->fMyFont)
            TTSetFont(pTtm, 0, FALSE);
        break;

    case WM_PAINT: 
        TTOnPaint(pTtm);
        break;

    case WM_SETFONT:
        TTSetFont(pTtm, (HFONT)wParam, (BOOL)lParam);
        return(TRUE);

    case WM_GETFONT:
        if (pTtm) {
           return((LRESULT)pTtm->hFont);
        }
        break;

    case WM_NOTIFYFORMAT:
        if (lParam == NF_QUERY) {
            return NFR_UNICODE;
        } else if (lParam == NF_REQUERY) {
            int i;

            for(i = 0 ; i < pTtm->iNumTools; i++) {
                pTool = &pTtm->tools[i];

                if (SendMessage (pTool->hwnd, WM_NOTIFYFORMAT,
                                 (WPARAM)hwnd, NF_QUERY) == NFR_UNICODE) {
                    pTool->uFlags |= TTF_UNICODE;
                } else {
                    pTool->uFlags &= ~TTF_UNICODE;
                }
            }

            return CIHandleNotifyFormat(&pTtm->ci, lParam);
        }
        return 0;

    case WM_ERASEBKGND:
        break;
        
    case WM_STYLECHANGED:
        if ((wParam == GWL_STYLE) && pTtm) 
        {
            DWORD dwNewStyle = ((LPSTYLESTRUCT)lParam)->styleNew;
            if ( pTtm->ci.style & TTS_BALLOON &&    // If the old style was a balloon,
                !(dwNewStyle & TTS_BALLOON))        // And the new style is not a balloon,
            {
                // Then we need to unset the region.
                SetWindowRgn(pTtm->ci.hwnd, NULL, FALSE);
            }

            pTtm->ci.style = ((LPSTYLESTRUCT)lParam)->styleNew;
        }
        break;
        
    case WM_DESTROY: 
        {
            CCDestroyWindow();
            if (pTtm->tools) 
            {
                int i;
            
                // free the tools
                for(i = 0 ; i < pTtm->iNumTools; i++) 
                {
                    TTBeforeFreeTool(pTtm, &pTtm->tools[i]);
                }
            
                LocalFree((HANDLE)pTtm->tools);
            }
        
            TTSetFont(pTtm, (HFONT)1, FALSE); // delete font if we made one.

            Str_Set(&pTtm->lpTipText, NULL);
            Str_Set(&pTtm->lpTipTitle, NULL);

            if (pTtm->himlTitleBitmaps)
                ImageList_Destroy(pTtm->himlTitleBitmaps);
        
            LocalFree((HANDLE)pTtm);
            SetWindowPtr(hwnd, 0, 0);
        }
        break;

    case WM_PRINTCLIENT:
        TTRender(pTtm, (HDC)wParam);
        break;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_TOOLTIPS;
        goto DoDefault;

    default:
    {
        LRESULT lres;
        if (CCWndProc(&pTtm->ci, uMsg, wParam, lParam, &lres))
            return lres;
    }
DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

//========================================================================
//
// Ansi <=> Unicode Thunk Routines
//
//========================================================================


//*************************************************************
//
//  ThunkToolInfoAtoW()
//
//  Purpose:    Thunks a TOOLINFOA structure to a TOOLINFOW
//              structure.
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//*************************************************************

BOOL ThunkToolInfoAtoW (LPTOOLINFOA lpTiA, LPTOOLINFOW lpTiW, BOOL bThunkText, UINT uiCodePage)
{

    //
    // Copy the constants to the new structure.
    //

    lpTiW->uFlags      = lpTiA->uFlags;
    lpTiW->hwnd        = lpTiA->hwnd;
    lpTiW->uId         = lpTiA->uId;

    lpTiW->rect.left   = lpTiA->rect.left;
    lpTiW->rect.top    = lpTiA->rect.top;
    lpTiW->rect.right  = lpTiA->rect.right;
    lpTiW->rect.bottom = lpTiA->rect.bottom;

    lpTiW->hinst       = lpTiA->hinst;

    //
    //  Set the size properly and optionally copy the new fields if the
    //  structure is large enough.
    //
    if (lpTiA->cbSize <= TTTOOLINFOA_V1_SIZE) {
        lpTiW->cbSize  = TTTOOLINFOW_V1_SIZE;
    } else {
        lpTiW->cbSize  = sizeof(TOOLINFOW);
        lpTiW->lParam  = lpTiA->lParam;
    }

    if (bThunkText) {
        //
        // Thunk the string to the new structure.
        // Special case LPSTR_TEXTCALLBACK.
        //

        if (lpTiA->lpszText == LPSTR_TEXTCALLBACKA) {
            lpTiW->lpszText = LPSTR_TEXTCALLBACKW;

        } else if (!IS_INTRESOURCE(lpTiA->lpszText)) {

            DWORD dwBufSize;
            int iResult;

            dwBufSize = lstrlenA(lpTiA->lpszText) + 1;
            lpTiW->lpszText = LocalAlloc (LPTR, dwBufSize * sizeof(WCHAR));

            if (!lpTiW->lpszText) {
                return FALSE;
            }

            iResult = MultiByteToWideChar (uiCodePage, 0, lpTiA->lpszText, -1,
                                           lpTiW->lpszText, dwBufSize);

            //
            // If iResult is 0, and GetLastError returns an error code,
            // then MultiByteToWideChar failed.
            //

            if (!iResult) {
                if (GetLastError()) {
                    return FALSE;
                }
            }

            lpTiW->uFlags |= TTF_MEMALLOCED;

        } else {
            lpTiW->lpszText = (LPWSTR)lpTiA->lpszText;
        }

    }
    return TRUE;
}

//*************************************************************
//
//  ThunkToolInfoWtoA()
//
//  Purpose:    Thunks a TOOLINFOW structure to a TOOLINFOA
//              structure.
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//*************************************************************

BOOL ThunkToolInfoWtoA (LPTOOLINFOW lpTiW, LPTOOLINFOA lpTiA, UINT uiCodePage)
{
    int iResult = 1;

    //
    // Copy the constants to the new structure.
    //

    lpTiA->uFlags      = lpTiW->uFlags;
    lpTiA->hwnd        = lpTiW->hwnd;
    lpTiA->uId         = lpTiW->uId;

    lpTiA->rect.left   = lpTiW->rect.left;
    lpTiA->rect.top    = lpTiW->rect.top;
    lpTiA->rect.right  = lpTiW->rect.right;
    lpTiA->rect.bottom = lpTiW->rect.bottom;

    lpTiA->hinst       = lpTiW->hinst;

    //
    //  Set the size properly and optionally copy the new fields if the
    //  structure is large enough.
    //
    if (lpTiW->cbSize <= TTTOOLINFOW_V1_SIZE) {
        lpTiA->cbSize  = TTTOOLINFOA_V1_SIZE;
    } else {
        lpTiA->cbSize  = sizeof(TOOLINFOA);
        lpTiA->lParam  = lpTiA->lParam;
    }

    //
    // Thunk the string to the new structure.
    // Special case LPSTR_TEXTCALLBACK.
    //

    if (lpTiW->lpszText == LPSTR_TEXTCALLBACKW) {
        lpTiA->lpszText = LPSTR_TEXTCALLBACKA;

    } else if (!IS_INTRESOURCE(lpTiW->lpszText)) {

        //
        // It is assumed that lpTiA->lpszText is already setup to
        // a valid buffer, and that buffer is 80 characters.
        // 80 characters is defined in the TOOLTIPTEXT structure.
        //

        iResult = WideCharToMultiByte (uiCodePage, 0, lpTiW->lpszText, -1,
                                       lpTiA->lpszText, 80, NULL, NULL);
    } else {
        lpTiA->lpszText = (LPSTR)lpTiW->lpszText;
    }

    //
    // If iResult is 0, and GetLastError returns an error code,
    // then WideCharToMultiByte failed.
    //

    if (!iResult) {
        if (GetLastError()) {
            return FALSE;
        }
    }

    return TRUE;
}


//*************************************************************
//
//  ThunkToolTipTextAtoW()
//
//  Purpose:    Thunks a TOOLTIPTEXTA structure to a TOOLTIPTEXTW
//              structure.
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//*************************************************************

BOOL ThunkToolTipTextAtoW (LPTOOLTIPTEXTA lpTttA, LPTOOLTIPTEXTW lpTttW, UINT uiCodePage)
{
    int iResult;


    if (!lpTttA || !lpTttW)
        return FALSE;

    //
    // Thunk the NMHDR structure.
    //
    lpTttW->hdr.hwndFrom = lpTttA->hdr.hwndFrom;
    lpTttW->hdr.idFrom   = lpTttA->hdr.idFrom;
    lpTttW->hdr.code     = TTN_NEEDTEXTW;

    lpTttW->hinst  = lpTttA->hinst;
    lpTttW->uFlags = lpTttA->uFlags;
    lpTttW->lParam = lpTttA->lParam;

    //
    // Thunk the string to the new structure.
    // Special case LPSTR_TEXTCALLBACK.
    //

    if (lpTttA->lpszText == LPSTR_TEXTCALLBACKA) {
        lpTttW->lpszText = LPSTR_TEXTCALLBACKW;

    } else if (!IS_INTRESOURCE(lpTttA->lpszText)) {

        //
        //  Transfer the lpszText into the lpTttW...
        //
        //  First see if it fits into the buffer, and optimistically assume
        //  it will.
        //
        lpTttW->lpszText = lpTttW->szText;
        iResult = MultiByteToWideChar (uiCodePage, 0, lpTttA->lpszText, -1,
                                       lpTttW->szText, ARRAYSIZE(lpTttW->szText));
        if (!iResult) {
            //
            //  Didn't fit into the small buffer; must alloc our own.
            //
            lpTttW->lpszText = ProduceWFromA(uiCodePage, lpTttA->lpszText);
            lpTttW->uFlags |= TTF_MEMALLOCED;
        }

    } else {
        lpTttW->lpszText = (LPWSTR)lpTttA->lpszText;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\trackbar.c ===
//----------------------------------------------------------
//
// BUGBUG: make sure this stuff really works with the DWORD
//         ranges
//
//----------------------------------------------------------

#include "ctlspriv.h"
#include "limits.h"
#include "image.h"          // for CreateColorBitmap

//#define TB_DEBUG
//#define FEATURE_DEBUG     // Ctrl+Shift force-enables rare features for debugging

typedef struct {

    // standard header information for each control
    CONTROLINFO ci;

    HDC     hdc;            // current DC
    HBITMAP hbmBuffer;      // double buffer

    LONG    lLogMin;        // Logical minimum
    LONG    lLogMax;        // Logical maximum
    LONG    lLogPos;        // Logical position

    LONG    lSelStart;      // Logical selection start
    LONG    lSelEnd;        // Logical selection end

    int     iThumbWidth;    // Width of the thumb
    int     iThumbHeight;   // Height of the thumb

    int     iSizePhys;      // Size of where thumb lives
    RECT    rc;             // track bar rect.

    RECT    rcThumb;          // Rectangle we current thumb
    DWORD   dwDragPos;      // Logical position of mouse while dragging.
    int     dwDragOffset;   // how many pixels off the center did they click

    int     nTics;          // number of ticks.
    PDWORD  pTics;          // the tick marks.

    int     ticFreq;        // the frequency of ticks

    LONG     lPageSize;      // how much to thumb up and down.
    LONG     lLineSize;      // how muhc to scroll up and down on line up/down

    HWND     hwndToolTips;

    // these should probably be word or bytes
    UINT     wDirtyFlags;
    UINT     uTipSide;   // which side should the tip be on?
    UINT     Flags;          // Flags for our window
    UINT     Cmd;            // The command we're repeating.


#if defined(FE_IME)
    HIMC    hPrevImc;       // previous input context handle
#endif


    HWND        hwndBuddyLeft;
    HWND        hwndBuddyRight;

} TRACKBAR, *PTRACKBAR;

// Trackbar flags

#define TBF_NOTHUMB     0x0001  // No thumb because not wide enough.
#define TBF_SELECTION   0x0002  // a selection has been established (draw the range)

#define MIN_THUMB_HEIGHT (2 * g_cxEdge)

/*
        useful constants.
*/

#define REPEATTIME      500     // mouse auto repeat 1/2 of a second
#define TIMER_ID        1

/*
        Function Prototypes
*/

void   NEAR PASCAL DoTrack(PTRACKBAR, int, DWORD);
WORD   NEAR PASCAL WTrackType(PTRACKBAR, LONG);
void   NEAR PASCAL TBTrackInit(PTRACKBAR, LPARAM);
void   NEAR PASCAL TBTrackEnd(PTRACKBAR);
void   NEAR PASCAL TBTrack(PTRACKBAR, LPARAM);
void   NEAR PASCAL DrawThumb(PTRACKBAR, LPRECT, BOOL);

HBRUSH NEAR PASCAL SelectColorObjects(PTRACKBAR, BOOL);
void   NEAR PASCAL SetTBCaretPos(PTRACKBAR);

#define TICKHEIGHT 3
#define BORDERSIZE 2

#define ISVERT(tb) (tb->ci.style & TBS_VERT)

#define TBC_TICS        0x1
#define TBC_THUMB       0x2
#define TBC_ALL         0xF


// this is called internally when the trackbar has
// changed and we need to update the double buffer bitmap
// we only set a flag.  we do the actual draw
// during WM_PAINT.  This prevents wasted efforts drawing.
#define TBChanged(ptb, wFlags) ((ptb)->wDirtyFlags |= (wFlags))

//
// Function Prototypes
//
LPARAM FAR CALLBACK TrackBarWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
void NEAR PASCAL FlushChanges(PTRACKBAR tb);

//--------------------------------------------------------------------------;
//
//  LONG MulDiv32(a,b,c)    = (a * b + c/2) / c
//
//--------------------------------------------------------------------------;

#define MulDiv32 MulDiv     // use KERNEL32 version (it rounds)

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

//
//  convert a logical scroll-bar position to a physical pixel position
//
int NEAR PASCAL TBLogToPhys(PTRACKBAR tb, DWORD dwPos)
{
    int x;
    x = tb->rc.left;
    if (tb->lLogMax == tb->lLogMin)
        return x;

    return (int)MulDiv32(dwPos - tb->lLogMin, tb->iSizePhys - 1,
                          tb->lLogMax - tb->lLogMin) + x;
}

LONG NEAR PASCAL TBPhysToLog(PTRACKBAR ptb, int iPos)
{
    int min, max, x;
    min = ptb->rc.left;
    max = ptb->rc.right;
    x = ptb->rc.left;

    if (ptb->iSizePhys <= 1)
        return ptb->lLogMin;

    if (iPos <= min)
        return ptb->lLogMin;

    if (iPos >= max)
        return ptb->lLogMax;

    return MulDiv32(iPos - x, ptb->lLogMax - ptb->lLogMin,
                    ptb->iSizePhys - 1) + ptb->lLogMin;
}



/*
 * Initialize the trackbar code
 */

BOOL FAR PASCAL InitTrackBar(HINSTANCE hInstance)
{
    WNDCLASS wc;

    // See if we must register a window class
    wc.lpfnWndProc = TrackBarWndProc;
    wc.lpszClassName = s_szSTrackBarClass;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = NULL;
    wc.lpszMenuName = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.hInstance = hInstance;
    wc.style = CS_GLOBALCLASS;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(PTRACKBAR);

    RegisterClass(&wc);

    return TRUE;
}



/* 
 * To add vertical capabilities, I'm using a virtual coordinate
 * system.  the ptb->rcThumb and ptb->rc are in the virtual space (which
 * is just a horizontal trackbar).  Draw routines use PatRect 
 * which switch to the real coordinate system as needed.
 *
 * The one gotcha is that the Thumb Bitmap has the pressed bitmap
 * to the real right, and the masks to the real right again for both
 * the vertical and horizontal Thumbs.  So those cases are hardcoded.
 * Do a search for ISVERT to find these dependancies.
 *                              -Chee
 */

/*
  FlipRect Function is moved to cutils.c as  other controls  were also using it.
  -Arul

*/

void TBFlipPoint(PTRACKBAR ptb, LPPOINT lppt)
{
    if (ISVERT(ptb)) {
        FlipPoint(lppt);
    }
}


/* added trackbar variable to do auto verticalization */
void NEAR PASCAL PatRect(HDC hdc,int x,int y,int dx,int dy, PTRACKBAR ptb)
{
    RECT    rc;

    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    if (ISVERT(ptb))
        FlipRect(&rc);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

#define TBInvalidateRect(hwnd, prc, bErase, ptb) VertInvalidateRect(hwnd, prc, bErase, ISVERT(ptb))
void FAR PASCAL VertInvalidateRect(HWND hwnd, LPRECT qrc, BOOL b, BOOL fVert)
{
    RECT rc;
    rc = *qrc;
    if (fVert) FlipRect(&rc);
    InvalidateRect(hwnd, &rc, b);
}

#define TBDrawEdge(hdc, prc, uType, grfFlags, ptb) VertDrawEdge(hdc, prc, uType, grfFlags, ISVERT(ptb))
void FAR PASCAL VertDrawEdge(HDC hdc, LPRECT qrc, UINT edgeType, UINT grfFlags,
                               BOOL fVert)
{
    RECT temprc;
    UINT uFlags = grfFlags;

    temprc = *qrc;
    if (fVert) {
        FlipRect(&temprc);

        if (!(uFlags & BF_DIAGONAL)) {
            if (grfFlags & BF_TOP) uFlags |= BF_LEFT;
            else uFlags &= ~BF_LEFT;

            if (grfFlags & BF_LEFT) uFlags |= BF_TOP;
            else uFlags &= ~BF_TOP;

            if (grfFlags & BF_BOTTOM) uFlags |= BF_RIGHT;
            else uFlags &= ~BF_RIGHT;

            if (grfFlags & BF_RIGHT) uFlags |= BF_BOTTOM;
            else uFlags &= ~BF_BOTTOM;
        } else {
            if ((grfFlags & (BF_BOTTOM | BF_RIGHT)) == (BF_BOTTOM | BF_RIGHT)) {
                uFlags = BF_TOP | BF_LEFT;

                if (edgeType == EDGE_RAISED) {
                    edgeType = EDGE_SUNKEN;
                } else {
                    edgeType = EDGE_RAISED;
                }


                uFlags |= grfFlags & (~BF_RECT);
                uFlags ^= BF_SOFT;
            }
        }
    }
    DrawEdge(hdc, &temprc, edgeType, uFlags);
}

#define TBPatBlt(hdc1, x1, y1, w, h, rop, ptb) VertPatBlt(hdc1, x1, y1, w, h, rop, ISVERT(ptb))
void FAR PASCAL VertPatBlt(HDC hdc1, int x1, int y1, int w, int h,
                          DWORD rop, BOOL fVert)
{
    if (fVert)
        PatBlt(hdc1, y1, x1, h, w, rop);
    else
        PatBlt(hdc1, x1, y1, w, h, rop);
}


void NEAR PASCAL DrawTic(PTRACKBAR ptb, int x, int y, int dir)
{
    if (dir == -1) y -= TICKHEIGHT;
    SetBkColor(ptb->hdc, g_clrBtnText);
    PatRect(ptb->hdc,x,y,1,TICKHEIGHT, ptb);
}

// dir = direction multiplier (drawing up or down)
// yTic = where (vertically) to draw the line of tics
void NEAR PASCAL DrawTicsOneLine(PTRACKBAR ptb, int dir, int yTic)
{
    PDWORD pTics;
    int    iPos;
    int    i;

    DrawTic(ptb, ptb->rc.left, yTic, dir);             // first
    DrawTic(ptb, ptb->rc.left, yTic+ (dir * 1), dir);
    DrawTic(ptb, ptb->rc.right-1, yTic, dir);            // last
    DrawTic(ptb, ptb->rc.right-1, yTic+ (dir * 1), dir);

    // those inbetween
    pTics = ptb->pTics;
    if (ptb->ticFreq && pTics) {
        for (i = 0; i < ptb->nTics; ++i) {
            if (((i+1) % ptb->ticFreq) == 0) {
                iPos = TBLogToPhys(ptb,pTics[i]);
                DrawTic(ptb, iPos, yTic, dir);
            }
        }
    }

    // draw the selection range (triangles)

    if ((ptb->Flags & TBF_SELECTION) &&
        (ptb->lSelStart <= ptb->lSelEnd) && (ptb->lSelEnd >= ptb->lLogMin)) {

        SetBkColor(ptb->hdc, g_clrBtnText);

        iPos = TBLogToPhys(ptb,ptb->lSelStart);

        for (i = 0; i < TICKHEIGHT; i++)
            PatRect(ptb->hdc,iPos-i,yTic+(dir==1 ? i : -TICKHEIGHT),
                    1,TICKHEIGHT-i, ptb);

        iPos = TBLogToPhys(ptb,ptb->lSelEnd);

        for (i = 0; i < TICKHEIGHT; i++)
            PatRect(ptb->hdc,iPos+i,yTic+(dir==1 ? i : -TICKHEIGHT),
                    1,TICKHEIGHT-i, ptb);
    }

}

/* DrawTics() */
/* There is always a tick at the beginning and end of the bar, but you can */
/* add some more of your own with a TBM_SETTIC message.  This draws them.  */
/* They are kept in an array whose handle is a window word.  The first     */
/* element is the number of extra ticks, and then the positions.           */

void NEAR PASCAL DrawTics(PTRACKBAR ptb)
{
    // do they even want this?
    if (ptb->ci.style & TBS_NOTICKS) return;

    if ((ptb->ci.style & TBS_BOTH) || !(ptb->ci.style & TBS_TOP)) {
        DrawTicsOneLine(ptb, 1, ptb->rc.bottom + 1);
    }

    if ((ptb->ci.style & (TBS_BOTH | TBS_TOP))) {
        DrawTicsOneLine(ptb, -1, ptb->rc.top - 1);
    }
}

void NEAR PASCAL GetChannelRect(PTRACKBAR ptb, LPRECT lprc)
{
        int iwidth, iheight;

        if (!lprc)
            return;

        lprc->left = ptb->rc.left - ptb->iThumbWidth / 2;
        iwidth = ptb->iSizePhys + ptb->iThumbWidth - 1;
        lprc->right = lprc->left + iwidth;

        if (ptb->ci.style & TBS_ENABLESELRANGE) {
                iheight =  ptb->iThumbHeight / 4 * 3; // this is Scrollheight
        } else {
                iheight = 4;
        }

        lprc->top = (ptb->rc.top + ptb->rc.bottom - iheight) /2;
        if (!(ptb->ci.style & TBS_BOTH))
            if (ptb->ci.style & TBS_TOP) lprc->top++;
            else lprc->top--;

        lprc->bottom = lprc->top + iheight;

}

/* This draws the track bar itself */

void NEAR PASCAL DrawChannel(PTRACKBAR ptb, LPRECT lprc)
{

        TBDrawEdge(ptb->hdc, lprc, EDGE_SUNKEN, BF_RECT,ptb);

        SetBkColor(ptb->hdc, g_clrBtnHighlight);
        // Fill the center
        PatRect(ptb->hdc, lprc->left+2, lprc->top+2, (lprc->right-lprc->left)-4,
                (lprc->bottom-lprc->top)-4, ptb);


        // now highlight the selection range
        if ((ptb->Flags & TBF_SELECTION) &&
            (ptb->lSelStart <= ptb->lSelEnd) && (ptb->lSelEnd > ptb->lLogMin)) {
                int iStart, iEnd;

                iStart = TBLogToPhys(ptb,ptb->lSelStart);
                iEnd   = TBLogToPhys(ptb,ptb->lSelEnd);

                if (iStart + 2 <= iEnd) {
                        SetBkColor(ptb->hdc, g_clrHighlight);
                        PatRect(ptb->hdc, iStart+1, lprc->top+3,
                                iEnd-iStart-1, (lprc->bottom-lprc->top)-6, ptb);
                }
        }
}

void NEAR PASCAL DrawThumb(PTRACKBAR ptb, LPRECT lprc, BOOL fSelected)
{

    // iDpt direction from middle to point of thumb
    // a negative value inverts things.
    // this allows one code path..
    int iDpt = 0;
    int i = 0;  // size of point triangle
    int iYpt = 0;       // vertical location of tip;
    int iXmiddle = 0;
    int icount;  // just a loop counter
    UINT uEdgeFlags;
    RECT rcThumb = *lprc;

    if (ptb->Flags & TBF_NOTHUMB ||
        ptb->ci.style & TBS_NOTHUMB)            // If no thumb, just leave.
        return;

    ASSERT(ptb->iThumbHeight >= MIN_THUMB_HEIGHT);
    ASSERT(ptb->iThumbWidth > 1);


    // draw the rectangle part
    if (!(ptb->ci.style & TBS_BOTH))  {
        int iMiddle;
        // do -3  because wThumb is odd (triangles ya know)
        // and because draw rects draw inside the rects passed.
        // actually should be (width-1)/2-1, but this is the same...

        i = (ptb->iThumbWidth - 3) / 2;
        iMiddle = ptb->iThumbHeight / 2 + rcThumb.top;

        //draw the rectangle part
        if (ptb->ci.style & TBS_TOP) {
            iMiddle++; //correction because drawing routines
            iDpt = -1;
            rcThumb.top += (i+1);
            uEdgeFlags = BF_SOFT | BF_LEFT | BF_RIGHT | BF_BOTTOM;
        } else {
            iDpt = 1;
            rcThumb.bottom -= (i+1);
            // draw on the inside, not on the bottom and rt edge
            uEdgeFlags = BF_SOFT | BF_LEFT | BF_RIGHT | BF_TOP;
        }

        iYpt = iMiddle + (iDpt * (ptb->iThumbHeight / 2));
        iXmiddle = rcThumb.left + i;
    }  else {
        uEdgeFlags = BF_SOFT | BF_RECT;
    }

    // fill in the center
    if (fSelected || !IsWindowEnabled(ptb->ci.hwnd)) {
        HBRUSH hbrTemp;
        // draw the dithered insides;
        hbrTemp = SelectObject(ptb->hdc, g_hbrMonoDither);
        if (hbrTemp) {
            SetTextColor(ptb->hdc, g_clrBtnHighlight);
            SetBkColor(ptb->hdc, g_clrBtnFace);
            TBPatBlt(ptb->hdc, rcThumb.left +2 , rcThumb.top,
                     rcThumb.right-rcThumb.left -4, rcThumb.bottom-rcThumb.top,
                     PATCOPY,ptb);

            if (!(ptb->ci.style & TBS_BOTH)) {

                for (icount = 1;  icount <= i;  icount++) {
                    TBPatBlt(ptb->hdc, iXmiddle-icount+1,
                         iYpt - (iDpt*icount),
                         icount*2, 1, PATCOPY, ptb);
                }
            }
            SelectObject(ptb->hdc, hbrTemp);
        }

    } else {


        SetBkColor(ptb->hdc, g_clrBtnFace);
        PatRect(ptb->hdc, rcThumb.left+2, rcThumb.top,
                rcThumb.right-rcThumb.left-4, rcThumb.bottom-rcThumb.top, ptb);

        if (!(ptb->ci.style & TBS_BOTH)) {
            for (icount = 1; icount <= i; icount++) {
                PatRect(ptb->hdc, iXmiddle-icount+1,
                        iYpt - (iDpt*icount),
                        icount*2, 1, ptb);
            }
        }

    }

    TBDrawEdge(ptb->hdc, &rcThumb, EDGE_RAISED, uEdgeFlags, ptb);


    //now draw the point
    if (!(ptb->ci.style & TBS_BOTH)) {
        UINT uEdgeFlags2;

        // uEdgeFlags is now used to switch between top and bottom.
        // we'll or it in with the diagonal and left/right flags below
        if (ptb->ci.style & TBS_TOP) {
            rcThumb.bottom = rcThumb.top + 1;
            rcThumb.top = rcThumb.bottom - (i + 2);
            uEdgeFlags = BF_TOP | BF_RIGHT | BF_DIAGONAL | BF_SOFT;
            uEdgeFlags2 = BF_BOTTOM | BF_RIGHT | BF_DIAGONAL;
        } else {
            rcThumb.top = rcThumb.bottom - 1;
            rcThumb.bottom = rcThumb.top + (i + 2);

            uEdgeFlags = BF_TOP | BF_LEFT | BF_DIAGONAL | BF_SOFT;
            uEdgeFlags2 = BF_BOTTOM | BF_LEFT | BF_DIAGONAL;
        }

        rcThumb.right = rcThumb.left + (i + 2);
        // do the left side first
        TBDrawEdge(ptb->hdc, &rcThumb, EDGE_RAISED, uEdgeFlags , ptb);
        // then do th right side
        OffsetRect(&rcThumb, i + 1, 0);
        TBDrawEdge(ptb->hdc, &rcThumb, EDGE_RAISED, uEdgeFlags2 , ptb);
    }
}
void NEAR PASCAL TBInvalidateAll(PTRACKBAR ptb)
{
    if (ptb) {
        TBChanged(ptb, TBC_ALL);
        InvalidateRect(ptb->ci.hwnd, NULL, FALSE);
    }
}

void NEAR PASCAL MoveThumb(PTRACKBAR ptb, LONG lPos)
{
    long    lOld = ptb->lLogPos;

    TBInvalidateRect(ptb->ci.hwnd, &ptb->rcThumb, FALSE,ptb);

    ptb->lLogPos  = BOUND(lPos,ptb->lLogMin,ptb->lLogMax);
    ptb->rcThumb.left   = TBLogToPhys(ptb, ptb->lLogPos) - ptb->iThumbWidth / 2;
    ptb->rcThumb.right  = ptb->rcThumb.left + ptb->iThumbWidth;

    TBInvalidateRect(ptb->ci.hwnd, &ptb->rcThumb, FALSE,ptb);
    TBChanged(ptb, TBC_THUMB);
    UpdateWindow(ptb->ci.hwnd);

    if (lOld != ptb->lLogPos)
        MyNotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ptb->ci.hwnd, OBJID_CLIENT, 0);
}


void NEAR PASCAL DrawFocus(PTRACKBAR ptb, HBRUSH hbrBackground)
{
    RECT rc;
    if (ptb->ci.hwnd == GetFocus()
        && !(CCGetUIState(&(ptb->ci)) & UISF_HIDEFOCUS)
        )
    {
        SetBkColor(ptb->hdc, g_clrBtnHighlight);
        GetClientRect(ptb->ci.hwnd, &rc);

        // Successive calls to DrawFocusRect will invert it thereby erasing it.
        // To avoid this, whenever we process WM_PAINT, we erase the focus rect ourselves
        // before we draw it below.
        if (hbrBackground)
            FrameRect(ptb->hdc, &rc, hbrBackground);

        DrawFocusRect(ptb->hdc, &rc);
    }
}

void NEAR PASCAL DoAutoTics(PTRACKBAR ptb)
{
    LONG NEAR *pl;
    LONG l;

    if (!(ptb->ci.style & TBS_AUTOTICKS))
        return;

    if (ptb->pTics)
        LocalFree((HLOCAL)ptb->pTics);

    ptb->nTics = (int)(ptb->lLogMax - ptb->lLogMin - 1);

    if (ptb->nTics > 0)
        ptb->pTics = (DWORD NEAR *)LocalAlloc(LPTR, sizeof(DWORD) * ptb->nTics);
    else
        ptb->pTics = NULL;

    if (!ptb->pTics) {
        ptb->nTics = 0;
        return;
    }

    for (pl = (LONG NEAR *)ptb->pTics, l = ptb->lLogMin + 1; l < ptb->lLogMax; l++)
        *pl++ = l;
}


void NEAR PASCAL ValidateThumbHeight(PTRACKBAR ptb)
{
    if (ptb->iThumbHeight < MIN_THUMB_HEIGHT)
        ptb->iThumbHeight = MIN_THUMB_HEIGHT;

    ptb->iThumbWidth = ptb->iThumbHeight / 2;
    ptb->iThumbWidth |= 0x01;  // make sure it's odd at at least 3

    if (ptb->ci.style & TBS_ENABLESELRANGE) {
        if (ptb->ci.style & TBS_FIXEDLENGTH) {
            // half of 9/10
            ptb->iThumbWidth = (ptb->iThumbHeight * 9) / 20;
            ptb->iThumbWidth |= 0x01;
        } else {
            ptb->iThumbHeight += (ptb->iThumbWidth * 2) / 9;
        }
    }
}

void TBPositionBuddies(PTRACKBAR ptb)
{
    POINT pt;
    HWND hwndParent;
    RECT rcBuddy;
    RECT rcClient;
    RECT rcChannel;

    int yMid;

    GetChannelRect(ptb, &rcChannel);
    yMid = (rcChannel.top + rcChannel.bottom) / 2;

    GetClientRect(ptb->ci.hwnd, &rcClient);
    if (ISVERT(ptb))
        FlipRect(&rcClient);


    if (ptb->hwndBuddyLeft) {
        GetClientRect(ptb->hwndBuddyLeft, &rcBuddy);
        if (ISVERT(ptb))
            FlipRect(&rcBuddy);

        pt.y = yMid - ((RECTHEIGHT(rcBuddy))/2);
        pt.x = rcClient.left - RECTWIDTH(rcBuddy) - g_cxEdge;

        // x and y are now in trackbar's coordinates.
        // convert them to the parent of the buddy's coordinates
        hwndParent = GetParent(ptb->hwndBuddyLeft);
        TBFlipPoint(ptb, &pt);
        MapWindowPoints(ptb->ci.hwnd, hwndParent, &pt, 1);
        SetWindowPos(ptb->hwndBuddyLeft, NULL, pt.x, pt.y, 0, 0, SWP_NOSIZE |SWP_NOZORDER | SWP_NOACTIVATE);
    }

    if (ptb->hwndBuddyRight) {
        GetClientRect(ptb->hwndBuddyRight, &rcBuddy);
        if (ISVERT(ptb))
            FlipRect(&rcBuddy);

        pt.y = yMid - ((RECTHEIGHT(rcBuddy))/2);
        pt.x = rcClient.right + g_cxEdge;

        // x and y are now in trackbar's coordinates.
        // convert them to the parent of the buddy's coordinates
        hwndParent = GetParent(ptb->hwndBuddyRight);
        TBFlipPoint(ptb, &pt);
        MapWindowPoints(ptb->ci.hwnd, hwndParent, &pt, 1);
        SetWindowPos(ptb->hwndBuddyRight, NULL, pt.x, pt.y, 0, 0, SWP_NOSIZE |SWP_NOZORDER | SWP_NOACTIVATE);
    }

}

void NEAR PASCAL TBNukeBuffer(PTRACKBAR ptb)
{
    if (ptb->hbmBuffer) {
        DeleteObject(ptb->hbmBuffer);
        ptb->hbmBuffer = NULL;
        TBChanged(ptb, TBC_ALL);            // Must do a full repaint
    }
}

void NEAR PASCAL TBResize(PTRACKBAR ptb)
{
    GetClientRect(ptb->ci.hwnd, &ptb->rc);

    if (ISVERT(ptb))
        FlipRect(&ptb->rc);


    if (!(ptb->ci.style & TBS_FIXEDLENGTH)) {
        ptb->iThumbHeight = (g_cyHScroll * 4) / 3;

        ValidateThumbHeight(ptb);
        if ((ptb->iThumbHeight > MIN_THUMB_HEIGHT) && (ptb->rc.bottom < (int)ptb->iThumbHeight)) {
            ptb->iThumbHeight = ptb->rc.bottom - 3*g_cyEdge; // top, bottom, and tic
            if (ptb->ci.style & TBS_ENABLESELRANGE)
                ptb->iThumbHeight = (ptb->iThumbHeight * 3 / 4);
            ValidateThumbHeight(ptb);
        }
    } else {
        ValidateThumbHeight(ptb);
    }


    if (ptb->ci.style & (TBS_BOTH | TBS_TOP) && !(ptb->ci.style & TBS_NOTICKS))
        ptb->rc.top += TICKHEIGHT + BORDERSIZE + 3;
    ptb->rc.top   += BORDERSIZE;
    ptb->rc.bottom  = ptb->rc.top + ptb->iThumbHeight;
    ptb->rc.left   += (ptb->iThumbWidth + BORDERSIZE);
    ptb->rc.right  -= (ptb->iThumbWidth + BORDERSIZE);

    ptb->rcThumb.top = ptb->rc.top;
    ptb->rcThumb.bottom = ptb->rc.bottom;

    // Figure out how much room we have to move the thumb in
    ptb->iSizePhys = ptb->rc.right - ptb->rc.left;

    // Elevator isn't there if there's no room.
    if (ptb->iSizePhys == 0) {
        // Lost our thumb.
        ptb->Flags |= TBF_NOTHUMB;
        ptb->iSizePhys = 1;
    } else {
        // Ah. We have a thumb.
        ptb->Flags &= ~TBF_NOTHUMB;
    }

    TBNukeBuffer(ptb);

    MoveThumb(ptb, ptb->lLogPos);
    TBInvalidateAll(ptb);

    TBPositionBuddies(ptb);
}

LRESULT NEAR PASCAL TrackOnCreate(HWND hwnd, LPCREATESTRUCT lpCreate)
{
    PTRACKBAR       ptb;
    DWORD exStyle = 0;

    InitDitherBrush();
    InitGlobalColors();

    // Get us our window structure.
    ptb = (PTRACKBAR)LocalAlloc(LPTR, sizeof(TRACKBAR));
    if (!ptb)
        return -1;

    SetWindowPtr(hwnd, 0, ptb);
    CIInitialize(&ptb->ci, hwnd, lpCreate);

    ptb->Cmd = (UINT)-1;
    ptb->lLogMax = 100;
    ptb->ticFreq = 1;
    // ptb->hbmBuffer = 0;
    ptb->lPageSize = -1;
    ptb->lLineSize = 1;
    // initial size;
    ptb->iThumbHeight = (g_cyHScroll * 4) / 3;
#if defined(FE_IME)
    if (g_fDBCSInputEnabled)
        ptb->hPrevImc = ImmAssociateContext(hwnd, 0L);
#endif

#ifdef FEATURE_DEBUG
    if (GetAsyncKeyState(VK_SHIFT) < 0 &&
        GetAsyncKeyState(VK_CONTROL) < 0)
        ptb->ci.style |= TBS_TOOLTIPS;
#endif

    if (ISVERT(ptb)) {
        if (ptb->ci.style & TBS_TOP) {
            ptb->uTipSide = TBTS_RIGHT;
        } else {
            ptb->uTipSide = TBTS_LEFT;
        }
    } else {
        if (ptb->ci.style & TBS_TOP) {
            ptb->uTipSide = TBTS_BOTTOM;
        } else {
            ptb->uTipSide = TBTS_TOP;
        }
    }

    if (ptb->ci.style & TBS_TOOLTIPS) {
        ptb->hwndToolTips = CreateWindowEx(exStyle, 
                                              c_szSToolTipsClass, TEXT(""),
                                              WS_POPUP,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              ptb->ci.hwnd, NULL, HINST_THISDLL,
                                              NULL);
        if (ptb->hwndToolTips) {
            TOOLINFO ti;
            // don't bother setting the rect because we'll do it below
            // in FlushToolTipsMgr;
            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_TRACK | TTF_IDISHWND | TTF_CENTERTIP;
            ti.hwnd = ptb->ci.hwnd;
            ti.uId = (UINT_PTR)ptb->ci.hwnd;
            ti.lpszText = LPSTR_TEXTCALLBACK;
            ti.rect.left = ti.rect.top = ti.rect.bottom = ti.rect.right = 0; // update this on size
            SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                        (LPARAM)(LPTOOLINFO)&ti);
        } else
            ptb->ci.style &= ~(TBS_TOOLTIPS);
    }


    TBResize(ptb);

#ifdef FEATURE_DEBUG
    if (GetAsyncKeyState(VK_SHIFT) < 0 &&
        GetAsyncKeyState(VK_CONTROL) < 0 )
    {
        HWND hwnd =
            CreateWindowEx(WS_EX_STATICEDGE, TEXT("static"), TEXT("left"), WS_CHILD | WS_VISIBLE, 0, 0, 30, 20, GetParent(ptb->ci.hwnd), NULL, HINST_THISDLL, NULL);
        HWND hwnd2 =
            CreateWindowEx(WS_EX_STATICEDGE, TEXT("static"), TEXT("right"), WS_CHILD |WS_VISIBLE, 0, 0, 50, 20, GetParent(ptb->ci.hwnd), NULL, HINST_THISDLL, NULL);

        SendMessage(ptb->ci.hwnd, TBM_SETBUDDY, TRUE, (LPARAM)hwnd);
        SendMessage(ptb->ci.hwnd, TBM_SETBUDDY, FALSE, (LPARAM)hwnd2);
    }
#endif


    return 0;
}

void NEAR PASCAL TrackOnNotify(PTRACKBAR ptb, LPNMHDR lpnm)
{
    if (lpnm->hwndFrom == ptb->hwndToolTips)
    {
        switch (lpnm->code)
        {
        case TTN_NEEDTEXT:
            #define lpttt ((LPTOOLTIPTEXT)lpnm)
            StringCchPrintf(lpttt->szText, ARRAYSIZE(lpttt->szText), TEXT("%d"), ptb->lLogPos);

        default:
            SendNotifyEx(ptb->ci.hwndParent, (HWND)-1,
                         lpnm->code, lpnm, ptb->ci.bUnicode);
            break;
        }
    }
}

HWND TBSetBuddy(PTRACKBAR ptb, BOOL fLeft, HWND hwndBuddy)
{
    HWND hwndOldBuddy;

    if (fLeft) {
        hwndOldBuddy = ptb->hwndBuddyLeft;
        ptb->hwndBuddyLeft = hwndBuddy;
    } else {
        hwndOldBuddy = ptb->hwndBuddyRight;
        ptb->hwndBuddyRight = hwndBuddy;
    }

    TBResize(ptb);

    return hwndOldBuddy;
}

LPARAM FAR CALLBACK TrackBarWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
        PTRACKBAR       ptb;
        PAINTSTRUCT     ps;
        HLOCAL          h;

        ptb = GetWindowPtr(hwnd, 0);
        if (!ptb) {
            if (uMsg == WM_CREATE)
                return TrackOnCreate(hwnd, (LPCREATESTRUCT)lParam);

            goto DoDefault;
        }

        switch (uMsg) {

        // If color depth changes, the old buffer is no longer any good
        case WM_DISPLAYCHANGE:
            TBNukeBuffer(ptb);
            break;

        case WM_WININICHANGE:

            InitGlobalMetrics(wParam);
            // fall through to WM_SIZE

        case WM_SIZE:
            TBResize(ptb);
            break;

        case WM_SYSCOLORCHANGE:
            InitGlobalColors();
            TBInvalidateAll(ptb);
            break;

        case WM_NOTIFYFORMAT:
            return CIHandleNotifyFormat(&ptb->ci,lParam);

        case WM_NOTIFY:
            TrackOnNotify(ptb, (LPNMHDR)lParam);
            break;

        case WM_DESTROY:
            TerminateDitherBrush();
            if (ptb) {
#if defined(FE_IME)
                if (g_fDBCSInputEnabled)
                    ImmAssociateContext(hwnd, ptb->hPrevImc);
#endif
                if ((ptb->ci.style & TBS_TOOLTIPS) && IsWindow(ptb->hwndToolTips)) {
                    DestroyWindow (ptb->hwndToolTips);
                }

                TBNukeBuffer(ptb);

                if (ptb->pTics)
                    LocalFree((HLOCAL)ptb->pTics);

                LocalFree((HLOCAL)ptb);
                SetWindowPtr(hwnd, 0, 0);
            }
            break;

        case WM_KILLFOCUS:
            // Reset wheel scroll amount
            gcWheelDelta = 0;
            // fall-through

        case WM_SETFOCUS:
            ASSERT(gcWheelDelta == 0);
            if (ptb)
                TBInvalidateAll(ptb);
            break;

        case WM_ENABLE:
            if (wParam) {
                ptb->ci.style &= ~WS_DISABLED;
            } else {
                ptb->ci.style |= WS_DISABLED;
            }
            TBChanged(ptb, TBC_THUMB);
            InvalidateRect(hwnd, NULL, FALSE);
            break;

        case WM_PRINTCLIENT:
        case WM_PAINT: {
            RECT rc;
            HBITMAP hbmOld;
            HDC hdc;

            hdc = wParam ?  (HDC)wParam : BeginPaint(hwnd, &ps);

            //DebugMsg(DM_TRACE, "NumTics = %d", SendMessage(ptb->ci.hwnd, TBM_GETNUMTICS, 0, 0));

            //ptb->hdc = GetDC(NULL);
            ptb->hdc = CreateCompatibleDC(hdc);
            if (!ptb->hbmBuffer) {
                GetClientRect(hwnd, &rc);
                ptb->hbmBuffer = CreateColorBitmap(rc.right, rc.bottom);
            }

            hbmOld = SelectObject(ptb->hdc, ptb->hbmBuffer);
            FlushChanges(ptb);

            //only copy the area that's changable.. ie the clip box
            switch(GetClipBox(hdc, &rc)) {
                case NULLREGION:
                case ERROR:
                    GetClientRect(ptb->ci.hwnd, &rc);
            }
            BitBlt(hdc, rc.left, rc.top,
                     rc.right - rc.left, rc.bottom - rc.top,
                     ptb->hdc, rc.left, rc.top, SRCCOPY);

#ifdef TB_DEBUG
            {
                HDC hdcScreen;
                RECT rcClient;
                hdcScreen = GetDC(NULL);
                GetClientRect(ptb->ci.hwnd, &rcClient);
                BitBlt(hdcScreen, 0, 0, rcClient.right, rcClient.bottom, ptb->hdc, 0,0, SRCCOPY);
                ReleaseDC(NULL, hdcScreen);
            }
#endif

            SelectObject(ptb->hdc, hbmOld);
            DeleteDC(ptb->hdc);
            //ReleaseDC(NULL, ptb->hdc);
            if (wParam == 0)
                EndPaint(hwnd, &ps);

            ptb->hdc = NULL;
            break;
        }

        case WM_GETDLGCODE:
            return DLGC_WANTARROWS;

        case WM_LBUTTONDOWN:
            /* Give ourselves focus */
            if (!(ptb->ci.style & WS_DISABLED)) {
                SetFocus(hwnd); // REVIEW: we may not want to do this
                TBTrackInit(ptb, lParam);
            }
            break;

        case WM_LBUTTONUP:
            // We're through doing whatever we were doing with the
            // button down.
            if (!(ptb->ci.style & WS_DISABLED)) {
                TBTrackEnd(ptb);
                if (GetCapture() == hwnd)
                    CCReleaseCapture(&ptb->ci);
            }
            break;

        case WM_TIMER:
            // The only way we get a timer message is if we're
            // autotracking.
            lParam = GetMessagePosClient(ptb->ci.hwnd, NULL);
            // fall through to WM_MOUSEMOVE

        case WM_MOUSEMOVE:
            // We only care that the mouse is moving if we're
            // tracking the bloody thing.
            if ((ptb->Cmd != (UINT)-1) && (!(ptb->ci.style & WS_DISABLED)))
                TBTrack(ptb, lParam);
            break;

        case WM_CAPTURECHANGED:
            // someone is stealing the capture from us
            TBTrackEnd(ptb);
            break;

        case WM_KEYUP:
            if (!(ptb->ci.style & WS_DISABLED)) {
                // If key was any of the keyboard accelerators, send end
                // track message when user up clicks on keyboard
                switch (wParam) {
                case VK_HOME:
                case VK_END:
                case VK_PRIOR:
                case VK_NEXT:
                case VK_LEFT:
                case VK_UP:
                case VK_RIGHT:
                case VK_DOWN:
                    DoTrack(ptb, TB_ENDTRACK, 0);
                    break;
                default:
                    break;
                }
            }
            break;

        case WM_KEYDOWN:
            if (!(ptb->ci.style & WS_DISABLED)) {

                // Swap the left and right arrow key if the control is mirrored.
                wParam = RTLSwapLeftRightArrows(&ptb->ci, wParam);

                // If TBS_DOWNISLEFT, then swap left/right or up/down
                // depending on whether we are vertical or horizontal.
                // Some horizontal trackbars (e.g.) prefer that
                // UpArrow=TB_PAGEDOWN.
                if (ptb->ci.style & TBS_DOWNISLEFT) {
                    if (ISVERT(ptb)) {
                        wParam = CCSwapKeys(wParam, VK_LEFT, VK_RIGHT);
                    } else {
                        wParam = CCSwapKeys(wParam, VK_UP, VK_DOWN);
                        wParam = CCSwapKeys(wParam, VK_PRIOR, VK_NEXT);
                    }
                }

                switch (wParam) {
                case VK_HOME:
                    wParam = TB_TOP;
                    goto KeyTrack;

                case VK_END:
                    wParam = TB_BOTTOM;
                    goto KeyTrack;

                case VK_PRIOR:
                    wParam = TB_PAGEUP;
                    goto KeyTrack;

                case VK_NEXT:
                    wParam = TB_PAGEDOWN;
                    goto KeyTrack;

                case VK_LEFT:
                case VK_UP:
                    wParam = TB_LINEUP;
                    goto KeyTrack;

                case VK_RIGHT:
                case VK_DOWN:
                    wParam = TB_LINEDOWN;
                KeyTrack:
                    DoTrack(ptb, (int) wParam, 0);
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS);
                    break;

                default:
                    break;
                }
            }
            break;

        case WM_MBUTTONDOWN:
            SetFocus(hwnd);
            break;

        case WM_STYLECHANGED:
            if (wParam == GWL_STYLE) {
                ptb->ci.style = ((LPSTYLESTRUCT)lParam)->styleNew;
                TBResize(ptb);
            }
            break;

        case WM_UPDATEUISTATE:
        {
            DWORD dwUIStateMask = MAKEWPARAM(0xFFFF, UISF_HIDEFOCUS);

            if (CCOnUIState(&(ptb->ci), WM_UPDATEUISTATE, wParam & dwUIStateMask, lParam))
                InvalidateRect(hwnd, NULL, TRUE);

            goto DoDefault;
        }
        case TBM_GETPOS:
            return ptb->lLogPos;

        case TBM_GETSELSTART:
            return ptb->lSelStart;

        case TBM_GETSELEND:
            return ptb->lSelEnd;

        case TBM_GETRANGEMIN:
            return ptb->lLogMin;

        case TBM_GETRANGEMAX:
            return ptb->lLogMax;

        case TBM_GETPTICS:
            return (LRESULT)ptb->pTics;

        case TBM_CLEARSEL:
            ptb->Flags &= ~TBF_SELECTION;
            ptb->lSelStart = -1;
            ptb->lSelEnd   = -1;
            goto RedrawTB;

        case TBM_CLEARTICS:
            if (ptb->pTics)
                LocalFree((HLOCAL)ptb->pTics);

            ptb->pTics = NULL;
            ptb->nTics = 0;
            goto RedrawTB;

        case TBM_GETTIC:

            if (ptb->pTics == NULL || (int)wParam >= ptb->nTics)
                return -1L;

            return ptb->pTics[wParam];

        case TBM_GETTICPOS:

            if (ptb->pTics == NULL || (int)wParam >= ptb->nTics)
                return -1L;

            return TBLogToPhys(ptb,ptb->pTics[wParam]);

        case TBM_GETNUMTICS:
            if (ptb->ci.style & TBS_NOTICKS)
                return 0;

            if (ptb->ticFreq) {
                // first and last +
                return 2 + (ptb->nTics / ptb->ticFreq);
            }

            // if there's no ticFreq, then we fall down here.
            // 2 for the first and last tics that we always draw
            // when NOTICS isn't set.
            return 2;


        case TBM_SETTIC:
            /* not a valid position */
            if (((LONG)lParam) < ptb->lLogMin || ((LONG)lParam) > ptb->lLogMax)
                break;

            h = CCLocalReAlloc(ptb->pTics,
                                 sizeof(DWORD) * (ptb->nTics + 1));
            if (!h)
                return (LONG)FALSE;
            
            ptb->pTics = (PDWORD)h;
            ptb->pTics[ptb->nTics++] = (DWORD)lParam;

            TBInvalidateAll(ptb);
            return (LONG)TRUE;

        case TBM_SETTICFREQ:
            ptb->ticFreq = (int) wParam;
            DoAutoTics(ptb);
            goto RedrawTB;

        case TBM_SETPOS:
            /* Only redraw if it will physically move */
            if (wParam && TBLogToPhys(ptb, (DWORD) lParam) !=
                TBLogToPhys(ptb, ptb->lLogPos))
                MoveThumb(ptb, (DWORD) lParam);
            else
                ptb->lLogPos = BOUND((LONG)lParam,ptb->lLogMin,ptb->lLogMax);
            break;

        case TBM_SETSEL:

            if (!(ptb->ci.style & TBS_ENABLESELRANGE)) break;
            ptb->Flags |= TBF_SELECTION;

            if (((LONG)(SHORT)LOWORD(lParam)) < ptb->lLogMin)
                ptb->lSelStart = ptb->lLogMin;
            else
                ptb->lSelStart = (LONG)(SHORT)LOWORD(lParam);

            if (((LONG)(SHORT)HIWORD(lParam)) > ptb->lLogMax)
                ptb->lSelEnd = ptb->lLogMax;
            else
                ptb->lSelEnd   = (LONG)(SHORT)HIWORD(lParam);

            if (ptb->lSelEnd < ptb->lSelStart)
                ptb->lSelEnd = ptb->lSelStart;
            goto RedrawTB;

        case TBM_SETSELSTART:

            if (!(ptb->ci.style & TBS_ENABLESELRANGE)) break;
            ptb->Flags |= TBF_SELECTION;
            if (lParam < ptb->lLogMin)
                ptb->lSelStart = ptb->lLogMin;
            else
                ptb->lSelStart = (LONG) lParam;
            if (ptb->lSelEnd < ptb->lSelStart || ptb->lSelEnd == -1)
                ptb->lSelEnd = ptb->lSelStart;
            goto RedrawTB;

        case TBM_SETSELEND:

            if (!(ptb->ci.style & TBS_ENABLESELRANGE)) break;
            ptb->Flags |= TBF_SELECTION;
            if (lParam > ptb->lLogMax)
                ptb->lSelEnd = ptb->lLogMax;
            else
                ptb->lSelEnd = (LONG) lParam;
            if (ptb->lSelStart > ptb->lSelEnd || ptb->lSelStart == -1)
                ptb->lSelStart = ptb->lSelEnd;
            goto RedrawTB;

        case TBM_SETRANGE:

            ptb->lLogMin = (LONG)(SHORT)LOWORD(lParam);
            ptb->lLogMax = (LONG)(SHORT)HIWORD(lParam);
            if (ptb->lSelStart < ptb->lLogMin)
                ptb->lSelStart = ptb->lLogMin;
            if (ptb->lSelEnd > ptb->lLogMax)
                ptb->lSelEnd = ptb->lLogMax;
            DoAutoTics(ptb);
            goto RedrawTB;

        case TBM_SETRANGEMIN:
            ptb->lLogMin = (LONG)lParam;
            if (ptb->lSelStart < ptb->lLogMin)
                ptb->lSelStart = ptb->lLogMin;
            DoAutoTics(ptb);
            goto RedrawTB;

        case TBM_SETRANGEMAX:
            ptb->lLogMax = (LONG)lParam;
            if (ptb->lSelEnd > ptb->lLogMax)
                ptb->lSelEnd = ptb->lLogMax;
            DoAutoTics(ptb);

RedrawTB:
            ptb->lLogPos = BOUND(ptb->lLogPos, ptb->lLogMin,ptb->lLogMax);
            TBChanged(ptb, TBC_ALL);
            /* Only redraw if flag says so */
            if (wParam) {
                InvalidateRect(hwnd, NULL, FALSE);
                MoveThumb(ptb, ptb->lLogPos);
            }
            break;

        case TBM_SETTHUMBLENGTH:
            if (ptb->ci.style & TBS_FIXEDLENGTH) {
                ptb->iThumbHeight = (UINT)wParam;
                TBResize(ptb);
            }
            break;

        case TBM_GETTHUMBLENGTH:
            return ptb->iThumbHeight;

        case TBM_SETPAGESIZE: {
            LONG lOldPage = ptb->lPageSize == -1 ? (ptb->lLogMax - ptb->lLogMin)/5 : ptb->lPageSize;
            ptb->lPageSize = (LONG)lParam;
            return lOldPage;
        }

        case TBM_GETPAGESIZE:
            return ptb->lPageSize == -1 ? (ptb->lLogMax - ptb->lLogMin)/5 : ptb->lPageSize;

        case TBM_SETLINESIZE:  {
            LONG lOldLine = ptb->lLineSize;
            ptb->lLineSize = (LONG)lParam;
            return lOldLine;
        }

        case TBM_GETLINESIZE:
            return ptb->lLineSize;

        case TBM_GETTHUMBRECT:
            if (lParam) {
                *((LPRECT)lParam) = ptb->rcThumb;
                if (ISVERT(ptb)) FlipRect((LPRECT)lParam);
            }
            break;

        case TBM_GETTOOLTIPS:
            return (LRESULT)ptb->hwndToolTips;

        case TBM_SETTOOLTIPS:
            ptb->hwndToolTips = (HWND)wParam;
            break;

        case TBM_SETTIPSIDE:
        {
            UINT uOldSide = ptb->uTipSide;
            
            ptb->uTipSide = (UINT) wParam;
            return uOldSide;
        }

        case TBM_GETCHANNELRECT:
            GetChannelRect(ptb, (LPRECT)lParam);
            break;

        case TBM_SETBUDDY:
            return (LRESULT)TBSetBuddy(ptb, (BOOL)wParam, (HWND)lParam);

        case TBM_GETBUDDY:
            return (LRESULT)(wParam ? ptb->hwndBuddyLeft : ptb->hwndBuddyRight);

        case WM_GETOBJECT:
            if( lParam == OBJID_QUERYCLASSNAMEIDX )
                return MSAA_CLASSNAMEIDX_TRACKBAR;
            goto DoDefault;

        default:
            if (uMsg == g_msgMSWheel) {
                int   iWheelDelta;
                int   cDetants;
                long  lPos;
                ULONG ulPos;

                if (g_bRunOnNT || g_bRunOnMemphis)
                    iWheelDelta = (int)(short)HIWORD(wParam);
                else
                    iWheelDelta = (int)wParam;

                // Update count of scroll amount
                gcWheelDelta -= iWheelDelta;
                cDetants = gcWheelDelta / WHEEL_DELTA;
                if (cDetants != 0) {
                    gcWheelDelta %= WHEEL_DELTA;
                }

                if (g_bRunOnNT || g_bRunOnMemphis)
                {
                    if (wParam & (MK_SHIFT | MK_CONTROL))
                        goto DoDefault;
                }
                else
                {
                    if (GetKeyState(VK_SHIFT) < 0 || GetKeyState(VK_CONTROL) < 0)
                        goto DoDefault;
                }

                if (SHRT_MIN <= ptb->lLogPos && ptb->lLogPos <= SHRT_MAX) {
                    lPos = ptb->lLogPos + cDetants;
                    lPos = BOUND(lPos, ptb->lLogMin, ptb->lLogMax);
                    ulPos = BOUND(lPos, SHRT_MIN, SHRT_MAX);
                    if ((long) ulPos != ptb->lLogPos) {
                        MoveThumb(ptb, (long) ulPos);
                        DoTrack(ptb, TB_THUMBPOSITION, ulPos);
                    }
                }

                return TRUE;
            } else {
                LRESULT lres;
                if (CCWndProc(&ptb->ci, uMsg, wParam, lParam, &lres))
                    return lres;
            }

DoDefault:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}

/* DoTrack() */

void NEAR PASCAL DoTrack(PTRACKBAR ptb, int cmd, DWORD dwPos)
{
    LONG dpos;
    switch(cmd) {
        case TB_LINEDOWN:
            dpos = ptb->lLineSize;
            goto DMoveThumb;

        case TB_LINEUP:
            dpos = -ptb->lLineSize;
            goto DMoveThumb;

        case TB_PAGEUP:
        case TB_PAGEDOWN:
            if (ptb->lPageSize == -1) {
                dpos = (ptb->lLogMax - ptb->lLogMin) / 5;
                if (!dpos)
                    dpos = 1;
            } else {
                dpos = ptb->lPageSize;
            }

            if (cmd == TB_PAGEUP)
                dpos *= -1;

DMoveThumb: // move delta
            MoveThumb(ptb, ptb->lLogPos + dpos);
            break;

        case TB_BOTTOM:
            dpos = ptb->lLogMax; // the BOUND will take care of this;
            goto ABSMoveThumb;

        case TB_TOP:
            dpos = ptb->lLogMin; // the BOUND will take care of this;

ABSMoveThumb: // move absolute
            MoveThumb(ptb, dpos);
            break;

        default:  // do nothing
            break;

    }

    // BUGBUG:  for now, send both in vertical mode
    // note: we only send back a WORD worth of the position.
    if (ISVERT(ptb)) {
        FORWARD_WM_VSCROLL(ptb->ci.hwndParent, ptb->ci.hwnd, cmd, LOWORD(dwPos), SendMessage);
    } else
        FORWARD_WM_HSCROLL(ptb->ci.hwndParent, ptb->ci.hwnd, cmd, LOWORD(dwPos), SendMessage);
}

/* WTrackType() */

WORD NEAR PASCAL WTrackType(PTRACKBAR ptb, LONG lParam)
{
    POINT pt;

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    if (ptb->Flags & TBF_NOTHUMB ||
        ptb->ci.style & TBS_NOTHUMB)            // If no thumb, just leave.
        return 0;

    if (ISVERT(ptb)) {
        // put point in virtual coordinates
        int temp;
        temp = pt.x;
        pt.x = pt.y;
        pt.y = temp;
    }

    if (PtInRect(&ptb->rcThumb, pt))
        return TB_THUMBTRACK;

    if (!PtInRect(&ptb->rc, pt))
        return 0;

    if (pt.x >= ptb->rcThumb.left)
        return TB_PAGEDOWN;
    else
        return TB_PAGEUP;
}

/* TBTrackInit() */

void NEAR PASCAL TBTrackInit(PTRACKBAR ptb, LPARAM lParam)
{
        WORD wCmd;

        if (ptb->Flags & TBF_NOTHUMB ||
            ptb->ci.style & TBS_NOTHUMB)         // No thumb:  just leave.
            return;

        wCmd = WTrackType(ptb, (LONG) lParam);
        if (!wCmd)
            return;

        SetCapture(ptb->ci.hwnd);

        ptb->Cmd = wCmd;
        ptb->dwDragPos = (DWORD)-1;

        // Set up for auto-track (if needed).
        if (wCmd != TB_THUMBTRACK) {
                // Set our timer up
                SetTimer(ptb->ci.hwnd, TIMER_ID, REPEATTIME, NULL);
        } else {
            int xPos;
            // thumb tracking...

            // store the offset between the cursor's position and the center of the thumb
            xPos = TBLogToPhys(ptb, ptb->lLogPos);
            ptb->dwDragOffset = (ISVERT(ptb) ? HIWORD(lParam) : LOWORD(lParam)) - xPos;

            if (ptb->hwndToolTips) {
                TOOLINFO ti;
                // don't bother setting the rect because we'll do it below
                // in FlushToolTipsMgr;
                ti.cbSize = sizeof(ti);
                ti.uFlags = TTF_TRACK | TTF_CENTERTIP;
                ti.hwnd = ptb->ci.hwnd;
                ti.uId = (UINT_PTR)ptb->ci.hwnd;
                SendMessage(ptb->hwndToolTips, TTM_TRACKACTIVATE, (WPARAM)TRUE, (LPARAM)&ti);
            }
        }

        TBTrack(ptb, lParam);
}

/* EndTrack() */

void NEAR PASCAL TBTrackEnd(PTRACKBAR ptb)
{
        // Decide how we're ending this thing.
        if (ptb->Cmd == TB_THUMBTRACK) {

            if (ptb->hwndToolTips)
                SendMessage(ptb->hwndToolTips, TTM_TRACKACTIVATE, (WPARAM)FALSE, 0);

            DoTrack(ptb, TB_THUMBPOSITION, ptb->dwDragPos);

        }

        KillTimer(ptb->ci.hwnd, TIMER_ID);

        // Always send TB_ENDTRACK message if there's some sort of command tracking.
        if (ptb->Cmd != (UINT)-1) {
            DoTrack(ptb, TB_ENDTRACK, 0);

            // Nothing going on.
            ptb->Cmd = (UINT)-1;
        }

        MoveThumb(ptb, ptb->lLogPos);
}

#define TBTS_RIGHTLEFT   1   // low bit means it's on the right or left

void NEAR PASCAL TBTrack(PTRACKBAR ptb, LPARAM lParam)
{
    DWORD dwPos;
    WORD pos;


    // See if we're tracking the thumb
    if (ptb->Cmd == TB_THUMBTRACK) {


        pos = (ISVERT(ptb)) ? HIWORD(lParam) : LOWORD(lParam);
        pos -= (WORD) ptb->dwDragOffset;
        dwPos = TBPhysToLog(ptb, (int)(SHORT)pos);

        // Tentative position changed -- notify the guy.
        if (dwPos != ptb->dwDragPos) {
            ptb->dwDragPos = dwPos;
            MoveThumb(ptb, dwPos);
            DoTrack(ptb, TB_THUMBTRACK, dwPos);
        }

        if (ptb->hwndToolTips) {
            RECT rc;
            POINT pt;
            int iPixel;
            UINT uTipSide = ptb->uTipSide;

            // find the center of the window
            GetClientRect(ptb->ci.hwnd, &rc);
            pt.x = rc.right / 2;
            pt.y = rc.bottom / 2;

            //find the position of the thumb
            iPixel = TBLogToPhys(ptb, dwPos);
            if (ISVERT(ptb)) {
                pt.y = iPixel;
                uTipSide |= TBTS_RIGHTLEFT;
            } else {
                pt.x = iPixel;
                uTipSide &= ~TBTS_RIGHTLEFT;
            }
            
            // move it out to the requested side
            switch (uTipSide) {

            case TBTS_TOP:
                pt.y = -1;
                break;

            case TBTS_LEFT:
                pt.x = -1;
                break;

            case TBTS_BOTTOM:
                pt.y = rc.bottom + 1;
                break;

            case TBTS_RIGHT:
                pt.x = rc.right + 1;
                break;
            }

            // map it to screen coordinates
            MapWindowPoints(ptb->ci.hwnd, HWND_DESKTOP, &pt, 1);

            SendMessage(ptb->hwndToolTips, TTM_TRACKPOSITION, 0, MAKELONG(pt.x, pt.y));
        }

    }
    else {
        if (ptb->Cmd != WTrackType(ptb, (LONG) lParam))
            return;

        DoTrack(ptb, ptb->Cmd, 0);
    }
}




void NEAR PASCAL FlushChanges(PTRACKBAR ptb)
{
    HBRUSH hbr;
    NMCUSTOMDRAW nmcd;

    hbr = FORWARD_WM_CTLCOLORSTATIC(ptb->ci.hwndParent, ptb->hdc, ptb->ci.hwnd, SendMessage);

    if (hbr) {
        RECT rc;
        BOOL fClear = FALSE;

        if ( ptb->wDirtyFlags == TBC_ALL ) {
            GetClientRect(ptb->ci.hwnd, &rc);
            fClear = TRUE;
        } else if (ptb->wDirtyFlags & TBC_THUMB) {
            rc = ptb->rc;
            rc.left = 0;
            rc.right += ptb->iThumbWidth;
            if (ISVERT(ptb))
                FlipRect(&rc);
            fClear = TRUE;
        }
        if (fClear)
            FillRect(ptb->hdc, &rc, hbr);
    }

    nmcd.hdc = ptb->hdc;
    if (ptb->ci.hwnd == GetFocus())
        nmcd.uItemState = CDIS_FOCUS;
    else
        nmcd.uItemState = 0;

    nmcd.lItemlParam = 0;
    ptb->ci.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_PREPAINT, &nmcd);

    // for skip default, no other flags make sense..  only allow that one
    if (!(ptb->ci.dwCustom == CDRF_SKIPDEFAULT)) {
        DWORD dwRet = 0;
        // do the actual drawing

        if (nmcd.uItemState & CDIS_FOCUS)
        {
            DrawFocus(ptb, hbr);
        }

        nmcd.uItemState = 0;
        if (ptb->wDirtyFlags & TBC_TICS) {

            nmcd.dwItemSpec = TBCD_TICS;
            dwRet = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, &nmcd);

            if (!(dwRet == CDRF_SKIPDEFAULT)) {
                DrawTics(ptb);

                if (dwRet & CDRF_NOTIFYPOSTPAINT) {
                    nmcd.dwItemSpec = TBCD_TICS;
                    CICustomDrawNotify(&ptb->ci, CDDS_ITEMPOSTPAINT, &nmcd);
                }
            }
        }

        if (ptb->wDirtyFlags & TBC_THUMB) {


            // the channel
            GetChannelRect(ptb, &nmcd.rc);
            if (ISVERT(ptb))
                FlipRect(&nmcd.rc);
            nmcd.dwItemSpec = TBCD_CHANNEL;
            dwRet = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, &nmcd);

            if (!(dwRet == CDRF_SKIPDEFAULT)) {

                // flip it back from the last notify
                if (ISVERT(ptb))
                    FlipRect(&nmcd.rc);

                // the actual drawing
                DrawChannel(ptb, &nmcd.rc);

                if (dwRet & CDRF_NOTIFYPOSTPAINT) {

                    if (ISVERT(ptb))
                        FlipRect(&nmcd.rc);
                    nmcd.dwItemSpec = TBCD_CHANNEL;
                    CICustomDrawNotify(&ptb->ci, CDDS_ITEMPOSTPAINT, &nmcd);
                }
            }


            // the thumb
            nmcd.rc = ptb->rcThumb;
            if (ptb->Cmd == TB_THUMBTRACK) {
                nmcd.uItemState = CDIS_SELECTED;
            }

            if (ISVERT(ptb))
                FlipRect(&nmcd.rc);
            nmcd.dwItemSpec = TBCD_THUMB;
            dwRet = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, &nmcd);

            if (!(dwRet == CDRF_SKIPDEFAULT)) {

                if (ISVERT(ptb))
                    FlipRect(&nmcd.rc);

                // the actual drawing
                DrawThumb(ptb, &nmcd.rc, nmcd.uItemState & CDIS_SELECTED);

                if (dwRet & CDRF_NOTIFYPOSTPAINT) {
                    if (ISVERT(ptb))
                        FlipRect(&nmcd.rc);
                    nmcd.dwItemSpec = TBCD_THUMB;
                    CICustomDrawNotify(&ptb->ci, CDDS_ITEMPOSTPAINT, &nmcd);
                }
            }

        }
        ptb->wDirtyFlags = 0;

        // notify parent afterwards if they want us to
        if (ptb->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
            CICustomDrawNotify(&ptb->ci, CDDS_POSTPAINT, &nmcd);
        }
    }

#ifdef TB_DEBUG
    DebugMsg(DM_TRACE, TEXT("DrawDone"));
    {
        HDC hdcScreen;
        RECT rcClient;
        hdcScreen = GetDC(NULL);
        GetClientRect(ptb->ci.hwnd, &rcClient);
        BitBlt(hdcScreen, 200, 0, 200 + rcClient.right, rcClient.bottom, ptb->hdc, 0,0, SRCCOPY);
        ReleaseDC(NULL, hdcScreen);
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\treeview.c ===
#include "ctlspriv.h"
#include "treeview.h"
#include "listview.h"

// BUGBUG -- penwin.h is messed up; define local stuff for now
#define HN_BEGINDIALOG                  40              // Lens/EditText/garbage detection dialog is about
                                    // to come up on this hedit/bedit
#define HN_ENDDIALOG                       41           // Lens/EditText/garbage detection dialog has
                                    // just been destroyed

//---------------------------------------------------------
#define IDT_SCROLLWAIT 43

//-----------------------
// ToolTip stuff...
//
#define REPEATTIME      SendMessage(pTree->hwndToolTips,TTM_GETDELAYTIME,(WPARAM)TTDT_RESHOW, 0)
#define CHECKFOCUSTIME  (REPEATTIME)
#define IDT_TOOLTIPWAIT   2
#define IDT_FOCUSCHANGE   3
// in tooltips.c
BOOL ChildOfActiveWindow(HWND hwnd);
void TV_HandleStateIconClick(PTREE pTree, HTREEITEM hItem);

HWND TV_EditLabel(PTREE pTree, HTREEITEM hItem, LPTSTR pszInitial);
void TV_CancelEditTimer(PTREE pTree);
BOOL TV_SetItem(PTREE pTree, LPCTVITEMEX ptvi);
void TV_DeleteHotFonts(PTREE pTree);
BOOL TV_IsShowing(HTREEITEM hItem);

LRESULT TV_OnScroll(PTREE ptv, LPNMHDR pnm);

#define TVBD_FROMWHEEL      0x0001
#define TVBD_WHEELFORWARD   0x0002
#define TVBD_WHEELBACK      0x0004

BOOL ValidateTreeItem(TREEITEM FAR * hItem, UINT flags)
{
    BOOL fValid = TRUE;

    /*
     *  Check the values to make sure the new Win64-compatible values
     *  are consistent with the old Win32 values.
     */
    COMPILETIME_ASSERT(
           (DWORD)(ULONG_PTR)TVI_ROOT  == 0xFFFF0000 &&
           (DWORD)(ULONG_PTR)TVI_FIRST == 0xFFFF0001 &&
           (DWORD)(ULONG_PTR)TVI_LAST  == 0xFFFF0002 &&
           (DWORD)(ULONG_PTR)TVI_SORT  == 0xFFFF0003);

    if (hItem) {
        if (HIWORD64(hItem) == HIWORD64(TVI_ROOT)) {
            switch (LOWORD(hItem)) {
//#pragma warning(disable:4309)
            case LOWORD(TVI_ROOT):
            case LOWORD(TVI_FIRST):
            case LOWORD(TVI_LAST):
            case LOWORD(TVI_SORT):
//#pragma warning(default:4309)
                break;

            default:
                AssertMsg(FALSE, TEXT("ValidateTreeItem() Invalid special item"));
                fValid = FALSE;
                break;
            }
        } else {
            __try {
                // Use "volatile" to force memory access at start of struct
                *(volatile LPVOID *)hItem;
                fValid = hItem->wSignature == TV_SIG;
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                fValid = FALSE;
            } __endexcept
        }

    } else if (!flags) {            // The only flag is VTI_NULLOK
        DebugMsg(DM_ERROR, TEXT("ValidateTreeItem(): NULL HTREEITEM"));
        fValid = FALSE;
    }

    return fValid;
}

// ----------------------------------------------------------------------------
//
//  Initialize TreeView on library entry -- register SysTreeView class
//
// ----------------------------------------------------------------------------

#pragma code_seg(CODESEG_INIT)

BOOL FAR TV_Init(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = TV_WndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = c_szTreeViewClass;
    wc.hbrBackground   = NULL;
    wc.style           = CS_DBLCLKS | CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(PTREE);
    wc.cbClsExtra      = 0;

    RegisterClass(&wc);

    return TRUE;
}
#pragma code_seg()


// ----------------------------------------------------------------------------
//
// If the tooltip bubble is up, then pop it.
//
// ----------------------------------------------------------------------------

void TV_PopBubble(PTREE pTree)
{
    if (pTree->hwndToolTips && pTree->hToolTip)
    {
        pTree->hToolTip = NULL;
        SendMessage(pTree->hwndToolTips, TTM_POP, 0L, 0L);
    }
}


// ----------------------------------------------------------------------------
//
//  Sends a TVN_BEGINDRAG or TVN_BEGINRDRAG notification with information in the ptDrag and
//  itemNew fields of an NM_TREEVIEW structure
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SendBeginDrag(PTREE pTree, int code, TREEITEM FAR * hItem, int x, int y)
{
    NM_TREEVIEW nm;
        
    TV_PopBubble(pTree);            // dismiss the infotip if we start to drag

    nm.itemNew.hItem = hItem;
    nm.itemNew.state = hItem->state;
    nm.itemNew.lParam = hItem->lParam;
    nm.itemNew.mask = (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM);
    nm.itemOld.mask = 0;
    nm.ptDrag.x = x;
    nm.ptDrag.y = y;

    return (BOOL)CCSendNotify(&pTree->ci, code, &nm.hdr);
}


// ----------------------------------------------------------------------------
//
//  Sends a TVN_ITEMEXPANDING or TVN_ITEMEXPANDED notification with information
//  in the action and itemNew fields of an NM_TREEVIEW structure
//
//  Returns FALSE to allow processing to continue, or TRUE to stop.
//
//  If the hItem is destroyed by the callback, then we always return TRUE.
//
//  Note that the application cannot stop a TVN_ITEMEXPANDED, so the only
//  way a TVN_ITEMEXPANDED can return "Stop" is if the item got destroyed.
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SendItemExpand(PTREE pTree, int code, TREEITEM FAR * hItem, WPARAM action)
{
    NM_TREEVIEW nm;
    TVWATCHEDITEM wi;
    BOOL fResult;
    BOOL fWatched;

    ASSERT(code == TVN_ITEMEXPANDING || code == TVN_ITEMEXPANDED);

    nm.itemNew.mask = 0;
    nm.itemNew.hItem = hItem;
    if (hItem == TVI_ROOT)
        hItem = pTree->hRoot;
    nm.itemNew.state = hItem->state;
    nm.itemNew.lParam = hItem->lParam;
    nm.itemNew.iImage = hItem->iImage;
    nm.itemNew.iSelectedImage = hItem->iSelectedImage;
    switch(hItem->fKids) {
        case KIDS_CALLBACK:
        case KIDS_FORCE_YES:
            nm.itemNew.cChildren = 1;
            nm.itemNew.mask = TVIF_CHILDREN;
            break;
        case KIDS_FORCE_NO:
            nm.itemNew.cChildren = 0;
            nm.itemNew.mask = TVIF_CHILDREN;
            break;
    }
    nm.itemNew.mask |= (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE);
    nm.itemOld.mask = 0;

    nm.action = (UINT)(action & TVE_ACTIONMASK);

    //
    //  Some apps will delete the item while it is being expanded, since
    //  during expansion, they will realize, "Hey, the thing represented
    //  by this item no longer exists, I'd better delete it."  (E.g,.
    //  Explorer.)  So keep an eye on the item so we don't fault when
    //  this happens.
    //

    // If we can't start a watch, then tough, just send the notification
    // the unsafe way.
    fWatched = TV_StartWatch(pTree, &wi, hItem);

    fResult = (BOOL)CCSendNotify(&pTree->ci, code, &nm.hdr);

    // The app return code from TVN_ITEMEXPANDED is ignored.
    // You can't stop a TVN_ITEMEXPANDED; it's already happened.
    if (code == TVN_ITEMEXPANDED)
        fResult = FALSE;                // Continue processing

    if (fWatched) {
        if (!TV_IsWatchValid(pTree, &wi))
            fResult = TRUE;             // Oh no!  Stop!

        TV_EndWatch(pTree, &wi);
    }

    return fResult;
}


// ----------------------------------------------------------------------------
//
//  Sends a TVN_SELCHANGING or TVN_SELCHANGED notification with information in
//  the itemOld and itemNew fields of an NM_TREEVIEW structure
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SendSelChange(PTREE pTree, int code, TREEITEM FAR * hOldItem, TREEITEM FAR * hNewItem, UINT action)
{
    NM_TREEVIEW nm;

    nm.action = action;

    nm.itemNew.hItem = hNewItem;
    nm.itemNew.state = hNewItem ? hNewItem->state : 0;
    nm.itemNew.lParam = hNewItem ? hNewItem->lParam : 0;
    nm.itemNew.mask = (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM);

    nm.itemOld.hItem = hOldItem;
    nm.itemOld.state = hOldItem ? hOldItem->state : 0;
    nm.itemOld.lParam = hOldItem ? hOldItem->lParam : 0;
    nm.itemOld.mask = (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM);

    return (BOOL)CCSendNotify(&pTree->ci, code, &nm.hdr);
}
// ----------------------------------------------------------------------------
//
//  Returns the first visible item above the given item in the tree.
//
// ----------------------------------------------------------------------------

TREEITEM FAR * NEAR TV_GetPrevVisItem(TREEITEM FAR * hItem)
{
    TREEITEM FAR * hParent = hItem->hParent;
    TREEITEM FAR * hWalk;

    DBG_ValidateTreeItem(hItem, 0);

    if (hParent->hKids == hItem)
        return VISIBLE_PARENT(hItem);

    for (hWalk = hParent->hKids; hWalk->hNext != hItem; hWalk = hWalk->hNext);

checkKids:
    if (hWalk->hKids && (hWalk->state & TVIS_EXPANDED))
    {
        for (hWalk = hWalk->hKids; hWalk->hNext; hWalk = hWalk->hNext);

        goto checkKids;
    }
    return(hWalk);
}


// ----------------------------------------------------------------------------
//
//  Returns the first visible item below the given item in the tree.
//
// ----------------------------------------------------------------------------

TREEITEM FAR * NEAR TV_GetNextVisItem(TREEITEM FAR * hItem)
{
    DBG_ValidateTreeItem(hItem, 0);

    if (hItem->hKids && (hItem->state & TVIS_EXPANDED))
        return hItem->hKids;

checkNext:
    if (hItem->hNext)
        return(hItem->hNext);

    hItem = hItem->hParent;
    if (hItem)
        goto checkNext;

    return NULL;
}


// ----------------------------------------------------------------------------
//
//  Determine what part of what item is at the given (x,y) location in the
//  tree's client area.  If the location is outside the client area, NULL is
//  returned with the TVHT_TOLEFT, TVHT_TORIGHT, TVHT_ABOVE, and/or TVHT_BELOW
//  flags set in the wHitCode as appropriate.  If the location is below the
//  last item, NULL is returned with wHitCode set to TVHT_NOWHERE.  Otherwise,
//  the item is returned with wHitCode set to either TVHT_ONITEMINDENT,
//  TVHT_ONITEMBUTTON, TVHT_ONITEMICON, TVHT_ONITEMLABEL, or TVHT_ONITEMRIGHT
//
// ----------------------------------------------------------------------------

TREEITEM FAR * NEAR TV_CheckHit(PTREE pTree, int x, int y, UINT FAR *wHitCode)
{
    TREEITEM FAR * hItem = pTree->hTop;
    int cxState;

    TVITEMEX sItem;

    *wHitCode = 0;

    if (x < 0)
        *wHitCode |= TVHT_TOLEFT;
    else if (x > (int) pTree->cxWnd)
        *wHitCode |= TVHT_TORIGHT;

    if (y < 0)
        *wHitCode |= TVHT_ABOVE;
    else if (y > (int) pTree->cyWnd)
        *wHitCode |= TVHT_BELOW;

    if (*wHitCode)
        return NULL;

    {
        int index = y / pTree->cyItem;

        while (hItem && index >= hItem->iIntegral) {
            index -= hItem->iIntegral;
            hItem = TV_GetNextVisItem(hItem);
        }
    }

    if (!hItem)
    {
        *wHitCode = TVHT_NOWHERE;
        return NULL;
    }

    x -= (pTree->cxBorder + (hItem->iLevel * pTree->cxIndent));
    x += pTree->xPos;

    if ((pTree->ci.style & (TVS_HASLINES | TVS_HASBUTTONS)) &&
        (pTree->ci.style &TVS_LINESATROOT))
    {
        // Subtract some more to make up for the pluses at the root
        x -= pTree->cxIndent;
    }

    TV_GetItem(pTree, hItem, TVIF_CHILDREN, &sItem);
    cxState = TV_StateIndex(&sItem) ? pTree->cxState : 0;
    if (x <= (int) (hItem->iWidth + pTree->cxImage + cxState))
    {

        if (x >= 0) {
            if (pTree->himlState &&  (x < cxState)) {
                *wHitCode = TVHT_ONITEMSTATEICON;
            } else if (pTree->hImageList && (x < (int) pTree->cxImage + cxState)) {
                *wHitCode = TVHT_ONITEMICON;
            } else {
                *wHitCode = TVHT_ONITEMLABEL;
            }
        } else if ((x >= -pTree->cxIndent) && sItem.cChildren && (pTree->ci.style & TVS_HASBUTTONS))
            *wHitCode = TVHT_ONITEMBUTTON;
        else
            *wHitCode = TVHT_ONITEMINDENT;
    }
    else
        *wHitCode = TVHT_ONITEMRIGHT;

    return hItem;
}

//  This is tricky because CheckForDragBegin yields and the app may have
//  destroyed the item we are thinking about dragging
//
//  To give the app some feedback, we give the hItem the drop highlight
//  if it isn't already the caret.  This also allows us to check if the
//  item got deleted behind our back - TV_DeleteItemRecurse makes sure
//  that deleted items are never the hCaret or hDropTarget.
//
//  After TV_CheckForDragBegin, the caller must call TV_FinishCheckDrag
//  to clean up the UI changes that TV_CheckForDragBegin temporarily
//  performed.
//
BOOL TV_CheckForDragBegin(PTREE pTree, HTREEITEM hItem, int x, int y)
{
    BOOL fDrag;

    //
    //  If the item is not the caret, then make it the (temporary)
    //  drop target so the user gets some feedback.
    //
    //  BUGBUG raymondc - If hItem == pTree->hCaret, it still might not
    //  be visible if the control doesn't yet have focus and the treeview
    //  is not marked showselalways.  Maybe we should just always set
    //  hItem to DROPHILITE.
    //
    if (hItem == pTree->hCaret)
    {
        pTree->hOldDrop = NULL;
        pTree->fRestoreOldDrop = FALSE;
    }
    else
    {
        pTree->hOldDrop = pTree->hDropTarget;
        pTree->fRestoreOldDrop = TRUE;
        TV_SelectItem(pTree, TVGN_DROPHILITE, hItem, 0, TVC_BYMOUSE);
        ASSERT(hItem == pTree->hDropTarget);
    }

    //
    //  We are dragging the hItem if CheckForDragBegin says okay,
    //  and TV_DeleteItemRecurse didn't wipe us out.
    //
    fDrag = CheckForDragBegin(pTree->ci.hwnd, x, y) &&
           (hItem == pTree->hDropTarget || hItem == pTree->hCaret);

    return fDrag;
}

void TV_FinishCheckDrag(PTREE pTree)
{
    //
    //  Clean up our temporary UI changes that happened when we started
    //  dragging.
    //
    if (pTree->fRestoreOldDrop)
    {
        HTREEITEM hOldDrop = pTree->hOldDrop;
        pTree->fRestoreOldDrop = FALSE;
        pTree->hOldDrop = NULL;
        TV_SelectItem(pTree, TVGN_DROPHILITE, hOldDrop, 0, TVC_BYMOUSE);
    }
}

void NEAR TV_SendRButtonDown(PTREE pTree, int x, int y)
{
    BOOL fRet = FALSE;
    UINT wHitCode;
    TREEITEM FAR * hItem = TV_CheckHit(pTree, x, y, &wHitCode);
    HWND hwnd = pTree->ci.hwnd;

    if (!TV_DismissEdit(pTree, FALSE))   // end any previous editing (accept it)
        return;     // Something happened such that we should not process button down

    //
    // Need to see if the user is going to start a drag operation
    //

    GetMessagePosClient(pTree->ci.hwnd, &pTree->ptCapture);

    if (TV_CheckForDragBegin(pTree, hItem, x, y))
    {
        // let them start dragging
        if (hItem)
        {
            pTree->htiDrag = hItem;
            TV_SendBeginDrag(pTree, TVN_BEGINRDRAG, hItem, x, y);
        }
    }
    else if (!IsWindow(hwnd))
    {
        return;             // bail!
    }
    else
    {
        SetFocus(pTree->ci.hwnd);  // Activate this window like listview...
        fRet = !CCSendNotify(&pTree->ci, NM_RCLICK, NULL);
    }

    // Don't finish the CheckForDragBegin until after the NM_RCLICK
    // because apps want to display the context menu while the
    // temporary drag UI is still active.
    TV_FinishCheckDrag(pTree);

    if (fRet)
        SendMessage(pTree->ci.hwndParent, WM_CONTEXTMENU, (WPARAM)pTree->ci.hwnd, GetMessagePos());
}


// ----------------------------------------------------------------------------
//
//  If the given item is visible in the client area, the rectangle that
//  surrounds that item is invalidated
//
// ----------------------------------------------------------------------------

void NEAR TV_InvalidateItem(PTREE pTree, TREEITEM FAR * hItem, UINT fRedraw)
{
    RECT rc;

    if (hItem && pTree->fRedraw && TV_GetItemRect(pTree, hItem, &rc, FALSE))
    {
        RedrawWindow(pTree->ci.hwnd, &rc, NULL, fRedraw);
    }
}

//
//  Given an item, compute where the text of this item ends up being painted.
//  Basically, stare at TV_DrawItem and dutifully reproduce all the code that
//  messes with the x-coordinate.
//
int FAR PASCAL ITEM_OFFSET(PTREE pTree, HTREEITEM hItem)
{
    int x = pTree->cxBorder + (hItem->iLevel * pTree->cxIndent);

    // state image
    // BUGBUG -- doesn't handle TVCDRF_NOIMAGES - whose idea was that?
    if (pTree->himlState && TV_StateIndex(hItem))
        x += pTree->cxState;

    // image
    if (pTree->hImageList) {
        // even if not drawing image, draw text in right place
        x += pTree->cxImage;
    }
    
    // "plus" at the front of the tree
    if ((pTree->ci.style & TVS_LINESATROOT) &&
        (pTree->ci.style & (TVS_HASLINES | TVS_HASBUTTONS)))
        x += pTree->cxIndent;


    return x;
}

// ----------------------------------------------------------------------------
//
//  If the given item is visible in the client area, the rectangle that
//  surrounds that item is filled into lprc
//
//  Returns TRUE if the item is shown, FALSE otherwise
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_GetItemRect(PTREE pTree, TREEITEM FAR * hItem, LPRECT lprc, BOOL bItemRect)
{
    UINT iOffset;

    if (!hItem)
        return FALSE;

    DBG_ValidateTreeItem(hItem, 0);

    if (!ITEM_VISIBLE(hItem))
        return FALSE;

    iOffset = hItem->iShownIndex - pTree->hTop->iShownIndex;

    if (bItemRect) {
        // Calculate where X position should start...
        lprc->left = -pTree->xPos + ITEM_OFFSET(pTree, hItem);
        lprc->right = lprc->left + hItem->iWidth;
    } else {
        lprc->left = 0;
        lprc->right = pTree->cxWnd;
    }

    lprc->top = iOffset * pTree->cyItem;
    lprc->bottom = lprc->top + (pTree->cyItem * hItem->iIntegral) ;

    return TRUE;
}

void NEAR TV_OnSetRedraw(PTREE pTree, BOOL fRedraw)
{
    pTree->fRedraw = TRUE && fRedraw;
    if (pTree->fRedraw)
    {
        // This use to only refresh the items from hTop down, this is bad as if items are inserted
        // before the visible point within the tree then we would fail!
        if ( pTree->hRoot )
            pTree->cShowing = TV_UpdateShownIndexes(pTree,pTree->hRoot);

        //  Must force recalculation of all tree items to get the right cxMax.
        TV_ScrollBarsAfterSetWidth(pTree, NULL);
        InvalidateRect(pTree->ci.hwnd, NULL, TRUE); //REVIEW: could be smarter
    }
}

//  Treeview item watching implementation
//
//  You need to "watch" an item any time you hold onto its HTREEITEM
//  and then yield control to the application.  If you didn't watch
//  the item, then if the app deletes the item, you end up with a
//  stale HTREEITEM pointer and fault.
//
//  To begin watching an item, call TV_StartWatch with the item you
//  want to start watching.  When finished watching, call TV_EndWatch.
//
//  In between, you can call TV_IsWatchStale() which tells you if the
//  item has been deleted behind your back and you shouldn't use it.
//  Alternatively, use TV_IsWatchValid() which says if it's okay.
//
//  Additional bonus behavior for enumeration:  If the watched item
//  is deleted, we cache the hNext item so that you can step to the
//  item after the one that got deleted.  Note that this works even
//  if the hNext item gets deleted before you get a chance to look,
//  because we just move the cached item to the hNext's hNext.
//
//  Sample usage for watching:
//
//  TVWATCHEDITEM wi;
//  if (TV_StartWatch(pTree, &wi, htiStartHere)) {
//      FunctionThatYields();
//      if (TV_IsWatchValid(pTree, &wi)) {
//          KeepUsing(htiStartHere);
//      } else {
//          // item was deleted while we yielded; stop using it
//      }
//      TV_EndWatch(pTree, &wi);
//  }
//
//  Sample usage for enumerating:
//
//  TVWATCHEDITEM wi;
//  if (TV_StartWatch(pTree, &wi, htiFirst)) {
//      while (TV_GetWatchItem(pTree, &wi)) {
//          FunctionThatYields(TV_GetWatchItem(pTree, &wi));
//          if (TV_IsWatchValid(pTree, &wi)) {
//              KeepUsing(htiStartHere);
//          } else {
//              // item was deleted while we yielded; stop using it
//          }
//          TV_NextWatchItem(pTree, &wi);
//      }
//      TV_EndWatch(pTree, &wi);
//  }
//
//
//

//
//  TV_StartWatch - Begin watching an item.
//
//  Returns FALSE if out of memory.
//
BOOL TV_StartWatch(PTREE pTree, PTVWATCHEDITEM pwi, HTREEITEM htiStart)
{
    pwi->hti = htiStart;
    pwi->fStale = FALSE;
    return DPA_AppendPtr(pTree->hdpaWatch, pwi) != -1;
}

//
//  TV_EndWatch - Remove the item from the watch list.
//
BOOL TV_EndWatch(PTREE pTree, PTVWATCHEDITEM pwi)
{
    int i = DPA_GetPtrCount(pTree->hdpaWatch);
    while (--i >= 0)
    {
        PTVWATCHEDITEM pwiT = DPA_FastGetPtr(pTree->hdpaWatch, i);
        ASSERT(pwiT);
        if (pwi == pwiT)
        {
            DPA_DeletePtr(pTree->hdpaWatch, i);
            return TRUE;
        }
    }
    ASSERT(!"TV_EndWatch: Item not in list");
    return FALSE;
}

//  End of treeview item watching implementation

void NEAR TV_SetItemRecurse(PTREE pTree, TREEITEM FAR *hItem, LPTVITEMEX ptvi)
{
    // Note:  This code assumes nobody will try to delete an item
    //        during a SetItem notification.
    while (hItem) {
        ptvi->hItem = hItem;
        TV_SetItem(pTree, ptvi);
        if (hItem->hKids) {
            TV_SetItemRecurse(pTree, hItem->hKids, ptvi);
        }

        hItem = hItem->hNext;
    }
}

BOOL NEAR TV_DoExpandRecurse(PTREE pTree, TREEITEM FAR *hItem, BOOL fNotify)
{
    TVWATCHEDITEM wi;
    BOOL fRc = FALSE;

    if (TV_StartWatch(pTree, &wi, hItem))
    {
        while ((hItem = TV_GetWatchItem(pTree, &wi))) {

            // was the escape key pressed at any point since the last check?
            if (GetAsyncKeyState(VK_ESCAPE) & 0x1)
                goto failed;

            TV_Expand(pTree, TVE_EXPAND, hItem, fNotify); // yields
            if (TV_IsWatchValid(pTree, &wi)) {
                if (hItem->hKids) {
                    if (!TV_DoExpandRecurse(pTree, hItem->hKids, fNotify))
                        goto failed;
                }
            }
            TV_NextWatchItem(pTree, &wi);
        }
        fRc = TRUE;
    failed:
        TV_EndWatch(pTree, &wi);
    }
    return fRc;
}


void NEAR TV_ExpandRecurse(PTREE pTree, TREEITEM FAR *hItem, BOOL fNotify)
{
    BOOL fRedraw = pTree->fRedraw;

    TV_OnSetRedraw(pTree, FALSE);
    
    // we're going to check this after each expand so clear it first
    GetAsyncKeyState(VK_ESCAPE);
    
    TV_Expand(pTree, TVE_EXPAND, hItem, fNotify);
    // BUGBUG hItem may have gone bad during that TV_Expand
    TV_DoExpandRecurse(pTree, hItem->hKids, fNotify);
    TV_OnSetRedraw(pTree, fRedraw);
}

void NEAR TV_ExpandParents(PTREE pTree, TREEITEM FAR *hItem, BOOL fNotify)
{
    hItem = hItem->hParent;
    if (hItem) {
        TVWATCHEDITEM wi;
        if (TV_StartWatch(pTree, &wi, hItem)) {
            TV_ExpandParents(pTree, hItem, fNotify);

            // Item may have gone invalid during expansion
            if (TV_IsWatchValid(pTree, &wi) &&

                // make sure this item is not in a collapsed branch
                !(hItem->state & TVIS_EXPANDED)) {

                TV_Expand(pTree, TVE_EXPAND, hItem, fNotify);
            }
            TV_EndWatch(pTree, &wi);
        }
    }
}

// makes sure an item is expanded and scrolled into view

BOOL NEAR TV_EnsureVisible(PTREE pTree, TREEITEM FAR * hItem)
{
    TV_ExpandParents(pTree, hItem, TRUE);
    return TV_ScrollIntoView(pTree, hItem);
}

//
//  Walk up the tree towards the root until we find the item at level iLevel.
//  Note the cast to (char) because iLevel is a BYTE, so the root's level is
//  0xFF.  Casting to (char) turns 0xFF it into -1.
//
HTREEITEM TV_WalkToLevel(HTREEITEM hWalk, int iLevel)
{
    int i;
    for (i = (char)hWalk->iLevel - iLevel; i > 0; i--)
        hWalk = hWalk->hParent;
    return hWalk;
}

// this is to handle single expand mode.
// The new selection is toggled, and the old selection is collapsed

// assume that parents of hNewSel are already fully expanded
// to do this, we build a parent dpa for the old and new
// then go through find the first parent node of the old selection that's not in
// the new sel tree.  and expand that.
void TV_ExpandOnSelChange(PTREE pTree, TREEITEM *hNewSel, TREEITEM *hOldSel)
{
    LRESULT dwAbort;
    NM_TREEVIEW nm;
    BOOL fCollapsing;
    TVWATCHEDITEM wiOld, wiNew;

    // Revalidate hNewSel and hOldSel since they may have been deleted
    // during all the notifications that occurred in the meantime.
    if (!ValidateTreeItem(hOldSel, VTI_NULLOK) ||
        !ValidateTreeItem(hNewSel, VTI_NULLOK))
        return;

    if (TV_StartWatch(pTree, &wiOld, hOldSel))
    {
        if (TV_StartWatch(pTree, &wiNew, hNewSel))
        {
            // Let the app clean up after itself
            nm.itemOld.hItem = hOldSel;
            if (hOldSel)
                nm.itemOld.lParam = hOldSel->lParam;
            nm.itemOld.mask = (TVIF_HANDLE | TVIF_PARAM);

            nm.itemNew.hItem = hNewSel;
            if (hNewSel)
                nm.itemNew.lParam = hNewSel->lParam;
            nm.itemNew.mask = (TVIF_HANDLE | TVIF_PARAM);

            dwAbort = CCSendNotify(&pTree->ci, TVN_SINGLEEXPAND, &nm.hdr);

            UpdateWindow(pTree->ci.hwnd);

            // Revalidate hNewSel and hOldSel since they may have been deleted
            // by that notification.
            if (!TV_IsWatchValid(pTree, &wiOld) ||
                !TV_IsWatchValid(pTree, &wiNew))
                goto cleanup;

            // Collapse if the NewSel currently expanded.
            fCollapsing = hNewSel && (hNewSel->state & TVIS_EXPANDED);

            // Note that Ctrl+select allows the user to suppress the collapse
            // of the old selection.
            if ((!(dwAbort & TVNRET_SKIPOLD)) && hOldSel  && (GetKeyState(VK_CONTROL) >= 0)) {

                //
                //  Collapse parents until we reach the common ancestor between
                //  hOldSel and hNewSel.  Note carefully that we don't cache
                //  any HTREEITEMs to avoid revalidation problems.
                //

                //
                //  Find the common ancestor, which might be the tree root.
                //
                int iLevelCommon;

                if (!hNewSel)
                    iLevelCommon = -1;          // common ancestor is root
                else
                {
                    HTREEITEM hItemO, hItemN;
                    iLevelCommon = min((char)hOldSel->iLevel, (char)hNewSel->iLevel);
                    hItemO = TV_WalkToLevel(hOldSel, iLevelCommon);
                    hItemN = TV_WalkToLevel(hNewSel, iLevelCommon);
                    while (iLevelCommon >= 0 && hItemO != hItemN) {
                        iLevelCommon--;
                        hItemO = hItemO->hParent;
                        hItemN = hItemN->hParent;
                    }
                }

                //
                //  Now walk up the tree from hOldSel, collapsing everything
                //  until we reach the common ancestor.  Do not collapse the
                //  common ancestor.
                //

                while ((char)hOldSel->iLevel > iLevelCommon)
                {
                    TV_Expand(pTree, TVE_COLLAPSE, hOldSel, TRUE);
                    if (!TV_IsWatchValid(pTree, &wiOld))
                        break;
                    hOldSel = hOldSel->hParent;
                    TV_RestartWatch(pTree, &wiOld, hOldSel);
                }

            }

            if ((!(dwAbort & TVNRET_SKIPNEW)) && hNewSel && TV_IsWatchValid(pTree, &wiNew)) {
                TV_Expand(pTree, TVE_TOGGLE, hNewSel, TRUE);
                UpdateWindow(pTree->ci.hwnd);

            }

cleanup:
            TV_EndWatch(pTree, &wiNew);
        }
        TV_EndWatch(pTree, &wiOld);
    }
}

// ----------------------------------------------------------------------------
//
//  Notify the parent that the selection is about to change.  If the change is
//  accepted, de-select the current selected item and select the given item
//
//  sets hCaret
//
// in:
//      hItem   item to become selected
//      wType   TVGN_ values (TVGN_CARET, TVGN_DROPHILIGHT are only valid values)
//      flags   combination of flags
//          TVSIF_NOTIFY        - send notify to parent window
//          TVSIF_UPDATENOW     - do UpdateWindow() to force sync painting
//          TVSIF_NOSINGLEEXPAND- don't do single-expand stuff
//      action  action code to send identifying how selection is being made
//
//  NOTE: Multiple Selection still needs to be added -- this multiplesel code
//        is garbage
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SelectItem(PTREE pTree, WPARAM wType, TREEITEM FAR * hItem, UINT flags, UINT action)
{
    UINT uRDWFlags = RDW_INVALIDATE;

    if (pTree->hImageList && (ImageList_GetBkColor(pTree->hImageList) == (COLORREF)-1))
        uRDWFlags |= RDW_ERASE;

    if (!ValidateTreeItem(hItem, VTI_NULLOK))
        return FALSE;                   // Invalid parameter

    switch (wType) {

    case TVGN_FIRSTVISIBLE:
        if (!hItem)
            return FALSE;

        TV_EnsureVisible(pTree, hItem);
        if (pTree->fVert) TV_SetTopItem(pTree, hItem->iShownIndex);
        break;

    case TVGN_DROPHILITE:

        ASSERT(hItem == NULL || ITEM_VISIBLE(hItem));

        if (hItem != pTree->hDropTarget) {
            if (pTree->hDropTarget) {
                pTree->hDropTarget->state &= ~TVIS_DROPHILITED;
                TV_InvalidateItem(pTree, pTree->hDropTarget, uRDWFlags);
            }

            if (hItem) {
                hItem->state |= TVIS_DROPHILITED;
                TV_InvalidateItem(pTree, hItem, uRDWFlags);
            }
            pTree->hDropTarget = hItem;

            if (pTree->hCaret) {
                TV_InvalidateItem(pTree, pTree->hCaret, uRDWFlags);
            }


            if (flags & TVSIF_UPDATENOW)
                UpdateWindow(pTree->ci.hwnd);
        }
        break;

    case TVGN_CARET:

        // REVIEW: we may want to scroll into view in this case
        // it's already the selected item, just return
        if (pTree->hCaret != hItem) {

            TREEITEM FAR * hOldSel;

            if ((flags & TVSIF_NOTIFY) && TV_SendSelChange(pTree, TVN_SELCHANGING, pTree->hCaret, hItem, action))
                return FALSE;

            if (pTree->hCaret) {
                pTree->hCaret->state &= ~TVIS_SELECTED;
                TV_InvalidateItem(pTree, pTree->hCaret, uRDWFlags);
            }

            hOldSel = pTree->hCaret;
            pTree->hCaret = hItem;

            if (hItem) {
                hItem->state |= TVIS_SELECTED;

                // make sure this item is not in a collapsed branch
                TV_ExpandParents(pTree, hItem, (flags & TVSIF_NOTIFY));

                TV_InvalidateItem(pTree, hItem, uRDWFlags );

                if (action == TVC_BYMOUSE) {
                    // if selected by mouse, let's wait a doubleclick sec before scrolling
                    SetTimer(pTree->ci.hwnd, IDT_SCROLLWAIT, GetDoubleClickTime(), NULL);
                    pTree->fScrollWait = TRUE;
                } else if (pTree->fRedraw)
                    TV_ScrollVertIntoView(pTree, hItem);
            }
            if (pTree->hwndToolTips)
                TV_Timer(pTree, IDT_TOOLTIPWAIT);

            if (flags & TVSIF_NOTIFY)
                TV_SendSelChange(pTree, TVN_SELCHANGED, hOldSel, hItem, action);

            if ((pTree->ci.style & TVS_SINGLEEXPAND) &&
                !(flags & TVSIF_NOSINGLEEXPAND) &&
                action != TVC_BYKEYBOARD)
            {
                    TV_ExpandOnSelChange(pTree, pTree->hCaret, hOldSel);
            }

            if (flags & TVSIF_UPDATENOW)
                UpdateWindow(pTree->ci.hwnd);

            MyNotifyWinEvent(EVENT_OBJECT_FOCUS, pTree->ci.hwnd, OBJID_CLIENT,
                (LONG_PTR)hItem);
            MyNotifyWinEvent(EVENT_OBJECT_SELECTION, pTree->ci.hwnd, OBJID_CLIENT,
                (LONG_PTR)hItem);
        }
        break;

    default:
        DebugMsg(DM_TRACE, TEXT("Invalid type passed to TV_SelectItem"));
        return FALSE;
    }

    return TRUE;        // success
}

// remove all the children, but pretend they are still there

BOOL NEAR TV_ResetItem(PTREE pTree, HTREEITEM hItem)
{
    TV_DeleteItem(pTree, hItem, TVDI_CHILDRENONLY);

    hItem->state &= ~TVIS_EXPANDEDONCE;
    hItem->fKids = KIDS_FORCE_YES;      // force children

    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  Expand or collapse an item's children
//  Returns TRUE if any change took place and FALSE if unchanged
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_Expand(PTREE pTree, WPARAM wCode, TREEITEM FAR * hItem, BOOL fNotify)
{
    WORD fOldState;
    UINT cntVisDescendants;
    TVITEMEX sItem;
    TREEITEM FAR * hItemExpanding;

// deal with the evil invisible root for multiple root trees.
    hItemExpanding = hItem;
    if ((hItem == NULL) || (hItem == TVI_ROOT))
        hItem = pTree->hRoot;

    DBG_ValidateTreeItem(hItem, 0);

    TV_GetItem(pTree, hItem, TVIF_CHILDREN, &sItem);

    if (!(wCode & TVE_ACTIONMASK) || sItem.cChildren == 0)
        return FALSE;           // no children to expand or collapse

    if ((wCode & TVE_ACTIONMASK) == TVE_TOGGLE) {
        wCode = (wCode & ~TVE_ACTIONMASK);

        // if it's not expaned, or not fully expanded, expand now
        wCode |=
            (((!(hItem->state & TVIS_EXPANDED)) ||
              hItem->state & TVIS_EXPANDPARTIAL) ?
             TVE_EXPAND : TVE_COLLAPSE);
    }

    if (((wCode & TVE_ACTIONMASK) == TVE_EXPAND) && !(hItem->state & TVIS_EXPANDEDONCE))
    {
        // if its the first expand, ALWAYS notify the parent
        fNotify = TRUE;
    }

    // at this point the children may be added if they aren't already there (callback)

    if (fNotify && TV_SendItemExpand(pTree, TVN_ITEMEXPANDING, hItemExpanding, wCode))
        return FALSE;

    // if (!hItem->hKids && (hItem->fKids == KIDS_FORCE_NO))    // this may be right, but I don't
                                                                // have proof now.
    if (!hItem->hKids)
    {
        // kids we removed, or never there
        TV_InvalidateItem(pTree, hItem, RDW_INVALIDATE);
        return FALSE;
    }

    fOldState = hItem->state;

    if (hItem->hParent) // never turn off TVIS_EXPANED for the invisible root
    {
        if ((wCode & TVE_ACTIONMASK) == TVE_EXPAND)
           hItem->state |= TVIS_EXPANDED;
        else
           hItem->state &= ~(TVIS_EXPANDED | TVIS_EXPANDPARTIAL);

        if (wCode & TVE_EXPANDPARTIAL) {
            hItem->state |= TVIS_EXPANDPARTIAL;
        } else {
            hItem->state &= ~(TVIS_EXPANDPARTIAL);
        }
    }

    // if we're not changing the expanded state
    // check to see if we're supposed to collapse reset
    if (!(fOldState & TVIS_EXPANDED) &&
        !(hItem->state & TVIS_EXPANDED))
    {
        if ((wCode & (TVE_ACTIONMASK | TVE_COLLAPSERESET)) == (TVE_COLLAPSE | TVE_COLLAPSERESET))
        {
            TV_ResetItem(pTree, hItem);
        }

        return FALSE;
    }

    // if we changed expaneded states, recalc the scrolling
    if ((fOldState ^ hItem->state) & TVIS_EXPANDED) {

        cntVisDescendants = TV_ScrollBelow(pTree, hItem, TRUE, hItem->state & TVIS_EXPANDED);

        if (hItem->state & TVIS_EXPANDED)
        {
            UINT wNewTop, wTopOffset, wLastKid;

            TV_ScrollBarsAfterExpand(pTree, hItem);

            wNewTop = pTree->hTop->iShownIndex;
            wTopOffset = hItem->iShownIndex - wNewTop;

            wLastKid = wTopOffset + cntVisDescendants + 1;

            if (wLastKid > pTree->cFullVisible)
            {
                wNewTop += min(wLastKid - pTree->cFullVisible, wTopOffset);
                TV_SetTopItem(pTree, wNewTop);
            }
        }
        else
        {
            TV_ScrollBarsAfterCollapse(pTree, hItem);
            TV_ScrollVertIntoView(pTree, hItem);

            // If we collapsed the subtree that contains the caret, then
            // pop the caret back to the last visible ancestor
            // Pass TVIS_NOSINGLEEXPAND so we won't expand an item right
            // after we collapsed it (d'oh!)
            if (pTree->hCaret)
            {
                TREEITEM FAR * hWalk = TV_WalkToLevel(pTree->hCaret, hItem->iLevel);

                if (hWalk == hItem)
                    TV_SelectItem(pTree, TVGN_CARET, hItem, (fNotify ? TVSIF_NOTIFY : 0) | TVSIF_UPDATENOW | TVSIF_NOSINGLEEXPAND, TVC_UNKNOWN);
            }

        }
    } else if ((fOldState ^ hItem->state) & TVIS_EXPANDPARTIAL) {
        // we didn't change the expanded state, only the expand partial
        TV_InvalidateItem(pTree, hItem, RDW_INVALIDATE);
    }

    if (fNotify && TV_SendItemExpand(pTree, TVN_ITEMEXPANDED, hItem, wCode))
        return FALSE;

    hItem->state |= TVIS_EXPANDEDONCE;

    if ((wCode & (TVE_ACTIONMASK | TVE_COLLAPSERESET)) == (TVE_COLLAPSE | TVE_COLLAPSERESET))
    {
        TV_ResetItem(pTree, hItem);
    }

    // BUGBUG raymondc v6 we generate a notification even if nothing happened,
    // which cunfuses accessibility.  E.g., app tried to expand something
    // that was already expanded.  Explorer Band does this when you navigate.
    MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, pTree->ci.hwnd, OBJID_CLIENT,
        (LONG_PTR)hItem);

    return TRUE;
}

BOOL PASCAL BetweenItems(PTREE pTree, HTREEITEM hItem, HTREEITEM hItemStart, HTREEITEM hItemEnd)
{
    if (hItemStart) {
        while ((hItemStart = TV_GetNextVisItem(hItemStart)) && (hItemEnd != hItemStart))
        {
            if (hItem == hItemStart)
                return TRUE;
        }
    }
    return FALSE;
}

#ifdef  FE_IME
// Now only Korean version is interested in incremental search with composition string.

#define FREE_COMP_STRING(pszCompStr)    LocalFree((HLOCAL)(pszCompStr))

BOOL NEAR TV_OnImeComposition(PTREE pTree, WPARAM wParam, LPARAM lParam)
{
    LPTSTR lpsz;
    int iCycle = 0;
    HTREEITEM hItem;
    TCHAR szTemp[MAXLABELTEXT];
    TVITEMEX ti;
    LPTSTR lpszAlt = NULL; // use only if SameChar
    int iLen;
    HIMC hImc;
    TCHAR *pszCompStr;
    BOOL fRet = TRUE;

    if (hImc = ImmGetContext(pTree->ci.hwnd))
    {
        if (lParam & GCS_RESULTSTR)
        {
            fRet = FALSE;
            pszCompStr = GET_COMP_STRING(hImc, GCS_RESULTSTR);
            if (pszCompStr)
            {
                IncrementSearchImeCompStr(&pTree->is, FALSE, pszCompStr, &lpsz);
                FREE_COMP_STRING(pszCompStr);
            }
        }
        if (lParam & GCS_COMPSTR)
        {
            fRet = TRUE;
            pszCompStr = GET_COMP_STRING(hImc, GCS_COMPSTR);
            if (pszCompStr)
            {
                if (IncrementSearchImeCompStr(&pTree->is, TRUE, pszCompStr, &lpsz)) {
                    if (pTree->hCaret) {
                        pTree->htiSearch = pTree->hCaret;
                    } else if (pTree->hRoot && pTree->hRoot->hKids) {
                        pTree->htiSearch = pTree->hRoot->hKids;
                    } else
                        return fRet;
                }

                if (!lpsz || !*lpsz || !pTree->hRoot || !pTree->hRoot->hKids)
                    return fRet;

                hItem = pTree->htiSearch;
                ti.cchTextMax  = sizeof(szTemp);
                iLen = lstrlen(lpsz);

                if (iLen > 1 && SameChars(lpsz, lpsz[0]))
                    lpszAlt = lpsz + iLen - 1;

                do {
                    ti.pszText = szTemp;
                    hItem = TV_GetNextVisItem(hItem);
                    if (!hItem) {
                        iCycle++;
                        hItem = pTree->hRoot->hKids;
                    }

                    TV_GetItem(pTree, hItem, TVIF_TEXT, &ti);
                    if ((ti.pszText != LPSTR_TEXTCALLBACK) &&
                        HIWORD64(ti.pszText)) {
                        // DebugMsg(DM_TRACE, "treesearch %d %s %s", (LPSTR)lpsz, (LPSTR)lpsz, (LPSTR)ti.pszText);
                        if (IntlStrEqNI(lpsz, ti.pszText, iLen) ||
                            (lpszAlt && IntlStrEqNI(lpszAlt, ti.pszText, 1) &&
                             BetweenItems(pTree, hItem, pTree->hCaret, pTree->htiSearch)))
                        {
                            DebugMsg(DM_TRACE, TEXT("Selecting"));
                            TV_SelectItem(pTree, TVGN_CARET, hItem, TVSIF_NOTIFY | TVSIF_UPDATENOW, TVC_BYKEYBOARD);
                            //notify of navigation key usage
                            CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
                            return fRet;
                        }
                    }
                }  while(iCycle < 2);

                // if they hit the same key twice in a row at the beginning of
                // the search, and there was no item found, they likely meant to
                // retstart the search
                if (lpszAlt) {

                    // first clear out the string so that we won't recurse again
                    IncrementSearchString(&pTree->is, 0, NULL);
                    TV_OnImeComposition(pTree, wParam, lParam);
                } else {
                    IncrementSearchBeep(&pTree->is);
                }
                //notify of navigation key usage
                CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
                FREE_COMP_STRING(pszCompStr);
            }
        }
        ImmReleaseContext(pTree->ci.hwnd, hImc);
    }
    return fRet;
}
#endif


void NEAR TV_OnChar(PTREE pTree, UINT ch, int cRepeat)
{
    LPTSTR lpsz;
    int iCycle = 0;
    HTREEITEM hItem;
    TCHAR szTemp[MAXLABELTEXT];
    TVITEMEX ti;
    LPTSTR lpszAlt = NULL; // use only if SameChar
    int iLen;

    if (IncrementSearchString(&pTree->is, ch, &lpsz) || !pTree->htiSearch) {
        if (pTree->hCaret) {
            pTree->htiSearch = pTree->hCaret;
        } else if (pTree->hRoot && pTree->hRoot->hKids) {
            pTree->htiSearch = pTree->hRoot->hKids;
        } else
            return;
    }

    if (!lpsz || !*lpsz || !pTree->hRoot || !pTree->hRoot->hKids)
        return;

    hItem = pTree->htiSearch;
    ti.cchTextMax  = ARRAYSIZE(szTemp);
    iLen = lstrlen(lpsz);
    if (iLen > 1 && SameChars(lpsz, lpsz[0]))
        lpszAlt = lpsz + iLen - 1;

    do {
        ti.pszText = szTemp;
        hItem = TV_GetNextVisItem(hItem);
        if (!hItem) {
            iCycle++;
            hItem = pTree->hRoot->hKids;
        }

        TV_GetItem(pTree, hItem, TVIF_TEXT, &ti);
        if ((ti.pszText != LPSTR_TEXTCALLBACK) &&
            HIWORD64(ti.pszText)) {
            // DebugMsg(DM_TRACE, TEXT("treesearch %d %s %s"), (LPTSTR)lpsz, (LPTSTR)lpsz, (LPTSTR)ti.pszText);
            if (IntlStrEqNI(lpsz, ti.pszText, iLen) ||
                (lpszAlt && IntlStrEqNI(lpszAlt, ti.pszText, 1) &&
                 BetweenItems(pTree, hItem, pTree->hCaret, pTree->htiSearch)))
            {
                DebugMsg(DM_TRACE, TEXT("Selecting"));
                TV_SelectItem(pTree, TVGN_CARET, hItem, TVSIF_NOTIFY | TVSIF_UPDATENOW, TVC_BYKEYBOARD);
                //notify of navigation key usage
                CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
                return;
            }
        }
    }  while(iCycle < 2);

    // if they hit the same key twice in a row at the beginning of
    // the search, and there was no item found, they likely meant to
    // retstart the search
    if (lpszAlt) {

        // first clear out the string so that we won't recurse again
        IncrementSearchString(&pTree->is, 0, NULL);
        TV_OnChar(pTree, ch, cRepeat);
    } else {
        IncrementSearchBeep(&pTree->is);
    }
    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
}

// ----------------------------------------------------------------------------
//
//  Handle WM_KEYDOWN messages
//  If control key is down, treat keys as scroll codes; otherwise, treat keys
//  as caret position changes.
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_KeyDown(PTREE pTree, WPARAM wKey, LPARAM dwKeyData)
{
    TREEITEM FAR * hItem;
    UINT wShownIndex;
    TV_KEYDOWN nm;
    BOOL fPuntChar;
    BOOL ret = TRUE;

    // Notify
    nm.wVKey = (WORD)wKey;
    fPuntChar = (BOOL)CCSendNotify(&pTree->ci, TVN_KEYDOWN, &nm.hdr);

    wKey = RTLSwapLeftRightArrows(&pTree->ci, wKey);

    if (GetKeyState(VK_CONTROL) < 0)
    {
        // control key is down
        UINT wScrollCode;

        switch (wKey)
        {
            case VK_LEFT:
                TV_HorzScroll(pTree, SB_LINEUP, 0);
                break;

            case VK_RIGHT:
                TV_HorzScroll(pTree, SB_LINEDOWN, 0);
                break;

            case VK_PRIOR:
                wScrollCode = SB_PAGEUP;
                goto kdVertScroll;

            case VK_HOME:
                wScrollCode = SB_TOP;
                goto kdVertScroll;

            case VK_NEXT:
                wScrollCode = SB_PAGEDOWN;
                goto kdVertScroll;

            case VK_END:
                wScrollCode = SB_BOTTOM;
                goto kdVertScroll;

            case VK_UP:
                wScrollCode = SB_LINEUP;
                goto kdVertScroll;

            case VK_DOWN:
                wScrollCode = SB_LINEDOWN;
kdVertScroll:
                TV_VertScroll(pTree, wScrollCode, 0);
                break;

            default:
                ret = FALSE;
        }

    } else {

        switch (wKey)
        {
        case VK_RETURN:
            fPuntChar = (BOOL)CCSendNotify(&pTree->ci, NM_RETURN, NULL);
            break;

        case VK_PRIOR:
            if (pTree->hCaret && (pTree->hCaret->iShownIndex > (pTree->cFullVisible - 1)))
            {
                wShownIndex = pTree->hCaret->iShownIndex - (pTree->cFullVisible - 1);
                goto selectIndex;
            }
            // fall thru

        case VK_HOME:
            wShownIndex = 0;
            goto selectIndex;

        case VK_NEXT:
            if (!pTree->hCaret)
            {
                wShownIndex = 0;
                goto selectIndex;
            }
            wShownIndex = pTree->hCaret->iShownIndex + (pTree->cFullVisible - 1);
            if (wShownIndex < pTree->cShowing)
                goto selectIndex;
            // fall thru

        case VK_END:
            wShownIndex = pTree->cShowing - 1;
selectIndex:
            hItem = TV_GetShownIndexItem(pTree->hRoot->hKids, wShownIndex);
            goto kdSetCaret;
            break;

        case VK_SUBTRACT:
            if (pTree->hCaret) {
                fPuntChar = TRUE;
                TV_Expand(pTree, TVE_COLLAPSE, pTree->hCaret, TRUE);
            }
            break;

        case VK_ADD:
            if (pTree->hCaret) {
                fPuntChar = TRUE;
                TV_Expand(pTree, TVE_EXPAND, pTree->hCaret, TRUE);
            }
            break;

        case VK_MULTIPLY:
            if (pTree->hCaret) {
                fPuntChar = TRUE;
                TV_ExpandRecurse(pTree, pTree->hCaret, TRUE);
            }
            break;

        case VK_LEFT:
            if (pTree->hCaret && (pTree->hCaret->state & TVIS_EXPANDED)) {
                TV_Expand(pTree, TVE_COLLAPSE, pTree->hCaret, TRUE);
                break;
            } else if (pTree->hCaret) {
                hItem = VISIBLE_PARENT(pTree->hCaret);
                goto kdSetCaret;
            }
            break;

        case VK_BACK:
            // get the parent, avoiding the root item
            fPuntChar = TRUE;
            if (pTree->hCaret) {
                hItem = VISIBLE_PARENT(pTree->hCaret);
                goto kdSetCaret;
            }
            break;

        case VK_UP:
            if (pTree->hCaret)
                hItem = TV_GetPrevVisItem(pTree->hCaret);
            else
                hItem = pTree->hRoot->hKids;

            goto kdSetCaret;
            break;


        case VK_RIGHT:
            if (pTree->hCaret && !(pTree->hCaret->state & TVIS_EXPANDED)) {
                TV_Expand(pTree, TVE_EXPAND, pTree->hCaret, TRUE);
                break;
            } // else fall through

        case VK_DOWN:
            if (pTree->hCaret)
                hItem = TV_GetNextVisItem(pTree->hCaret);
            else
                hItem = pTree->hRoot->hKids;

kdSetCaret:
            if (hItem)
                TV_SelectItem(pTree, TVGN_CARET, hItem, TVSIF_NOTIFY | TVSIF_UPDATENOW, TVC_BYKEYBOARD);

            break;

        case VK_SPACE:
            if ((pTree->ci.style & TVS_CHECKBOXES) && pTree->hCaret)
            {
                TV_HandleStateIconClick(pTree, pTree->hCaret);
                fPuntChar = TRUE; // don't beep
            }
            break;

        default:
            ret = FALSE;
        }
    }

    if (fPuntChar) {
        pTree->iPuntChar++;
    } else if (pTree->iPuntChar){
        // this is tricky...  if we want to punt the char, just increment the
        // count.  if we do NOT, then we must clear the queue of WM_CHAR's
        // this is to preserve the iPuntChar to mean "punt the next n WM_CHAR messages
        MSG msg;
        while((pTree->iPuntChar > 0) && PeekMessage(&msg, pTree->ci.hwnd, WM_CHAR, WM_CHAR, PM_REMOVE)) {
            pTree->iPuntChar--;
        }
        ASSERT(!pTree->iPuntChar);
    }

    if(VK_MENU!=wKey)
    {
        // notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
    }
    return ret;

}


// ----------------------------------------------------------------------------
//
//  Sets the tree's indent width per hierarchy level and recompute widths.
//
//  sets cxIndent
//
// ----------------------------------------------------------------------------

void NEAR TV_SetIndent(PTREE pTree, WPARAM cxIndent)
{
    if (pTree->hImageList) {
        if ((SHORT)cxIndent < pTree->cxImage)
            cxIndent = pTree->cxImage;
    }

    if ((SHORT)cxIndent < pTree->cyText)
        cxIndent = pTree->cyText;

    if (cxIndent < MAGIC_MININDENT)
        cxIndent = MAGIC_MININDENT;

    pTree->cxIndent = (SHORT)cxIndent;

    TV_CreateIndentBmps(pTree);
    TV_ScrollBarsAfterSetWidth(pTree, NULL);
}

// ----------------------------------------------------------------------------
//
//  Sets the tree's item height to be the maximum of the image height and text
//  height.  Then recompute the tree's full visible count.
//
//  sets cyItem, cFullVisible
//
// ----------------------------------------------------------------------------

void NEAR TV_SetItemHeight(PTREE pTree)
{
    // height MUST be even with TVS_HASLINES -- go ahead and make it always even
    if (!pTree->fCyItemSet)
        pTree->cyItem = (max(pTree->cyImage, pTree->cyText) + 1);
    // height not always even not, only on haslines style.
    if (pTree->cyItem <= 1) {
        pTree->cyItem = 1;          // Don't let it go zero or negative!
    } else if (!(pTree->ci.style & TVS_NONEVENHEIGHT))
        pTree->cyItem &= ~1;

    pTree->cFullVisible = pTree->cyWnd / pTree->cyItem;

    TV_CreateIndentBmps(pTree);
    TV_CalcScrollBars(pTree);
}

// BUGBUG: does not deal with hfont == NULL

void NEAR TV_OnSetFont(PTREE pTree, HFONT hNewFont, BOOL fRedraw)
{
    HDC hdc;
    HFONT hfontSel;
    TCHAR c = TEXT('J');       // for bog
    SIZE size;

    if (pTree->fCreatedFont && pTree->hFont) {
        DeleteObject(pTree->hFont);
        pTree->fCreatedFont = FALSE;
    }

    if (hNewFont == NULL) {
        LOGFONT lf;
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
        // B#210235 - because NT4 initializes icontitle logfont with Ansi charset
        // no matter what font is selected, following A/W conversion would fail
        // on non US environment if we use this logfont to get codepage. 
        // The ACP is guaranteed to work with any Ansi apps because these apps
        // assume ACP to be matching to their desired codepage.
        if (staticIsOS(OS_NT4ORGREATER) && !staticIsOS(OS_WIN2000ORGREATER))
        {
            CHARSETINFO csi;
            TranslateCharsetInfo(IntToPtr_(DWORD *, g_uiACP), &csi, TCI_SRCCODEPAGE);
            lf.lfCharSet = (BYTE)csi.ciCharset;
        }
        hNewFont = CreateFontIndirect(&lf);
        pTree->fCreatedFont = TRUE;         // make sure we delete it
    }

    hdc = GetDC(pTree->ci.hwnd);

    hfontSel = hNewFont ? SelectObject(hdc, hNewFont) : NULL;

    // Office9 Setup had a bug where they installed a bogus font,
    // which created okay but all APIs against it (e.g., GetTextExtentPoint)
    // failed!  Protect against failure by pre-setting the value to something
    // non-garbage.
    size.cy = 0;
    GetTextExtentPoint(hdc, &c, 1, &size);
    pTree->cyText = (SHORT)(size.cy + (g_cyBorder * 2));

    if (hfontSel)
        SelectObject(hdc, hfontSel);

    ReleaseDC(pTree->ci.hwnd, hdc);

    pTree->hFont = hNewFont;
    if (pTree->hFontBold) {
        TV_CreateBoldFont(pTree);
    }
    pTree->ci.uiCodePage = GetCodePageForFont(hNewFont);

    TV_DeleteHotFonts(pTree);

    if (pTree->cxIndent == 0)   // first time init?
    {
        if (!pTree->cyItem) pTree->cyItem = pTree->cyText;
        TV_SetIndent(pTree, 16 /*g_cxSmIcon*/ + MAGIC_INDENT);
    }

    TV_ScrollBarsAfterSetWidth(pTree, NULL);
    TV_SetItemHeight(pTree);

    if (pTree->hwndToolTips)
        SendMessage(pTree->hwndToolTips, WM_SETFONT, (WPARAM)pTree->hFont, (LPARAM)TRUE);

    // REVIEW: does this happen as a result of the above?
    // if (fRedraw)
    //    RedrawWindow(pTree->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
}

VOID NEAR PASCAL TV_CreateBoldFont(PTREE pTree)
{
    LOGFONT lf;

    if (pTree->hFontBold)
        DeleteObject (pTree->hFontBold);

    GetObject(pTree->hFont, sizeof (lf), &lf);
    lf.lfWeight = FW_BOLD;
    pTree->hFontBold = CreateFontIndirect(&lf);
}


HIMAGELIST NEAR TV_SetImageList(PTREE pTree, HIMAGELIST hImage, int iImageIndex)
{
    int cx, cy;
    HIMAGELIST hImageOld = NULL;

    switch (iImageIndex) {

        case TVSIL_STATE:

            hImageOld = pTree->himlState;
            pTree->himlState = hImage;
            if (hImage) {
                ImageList_GetIconSize(hImage, &pTree->cxState , &pTree->cyState);
            } else {
                pTree->cxState = 0;
            }
            break;

        case TVSIL_NORMAL:
            hImageOld = pTree->hImageList;
            if (hImage && ImageList_GetIconSize(hImage, &cx, &cy))
            {
                pTree->cxImage = (cx + MAGIC_INDENT);
                pTree->cyImage = (SHORT)cy;
                if (pTree->cxIndent < pTree->cxImage)
                    TV_SetIndent(pTree, pTree->cxImage);
                pTree->hImageList = hImage;

                if (!hImageOld && pTree->ci.style & TVS_CHECKBOXES) {
                    TV_InitCheckBoxes(pTree);
                }
            }
            else
            {
                pTree->cxImage = pTree->cyImage = 0;
                pTree->hImageList = NULL;
            }
            break;

        default:
            DebugMsg(DM_TRACE, TEXT("sh TR - TVM_SETIMAGELIST: unrecognized iImageList"));
            break;

    }

    TV_ScrollBarsAfterSetWidth(pTree, NULL);
    TV_SetItemHeight(pTree);

    return hImageOld;
}


// ----------------------------------------------------------------------------
//
//  Gets the item with the described relationship to the given item, NULL if
//  no item can be found with that relationship.
//
// ----------------------------------------------------------------------------

TREEITEM FAR * NEAR TV_GetNextItem(PTREE pTree, TREEITEM FAR * hItem, WPARAM wGetCode)
{
    switch (wGetCode) {
    case TVGN_ROOT:
        return pTree->hRoot->hKids;

    case TVGN_DROPHILITE:
        return pTree->hDropTarget;

    case TVGN_CARET:
        return pTree->hCaret;

    case TVGN_FIRSTVISIBLE:
        return pTree->hTop;

    case TVGN_LASTVISIBLE:
        return TV_GetShownIndexItem(pTree->hRoot->hKids, pTree->cShowing-1);

    case TVGN_CHILD:
        if (!hItem || (hItem == TVI_ROOT))
            return pTree->hRoot->hKids;
        break;
    }

    // all of these require a valid hItem
    if (!ValidateTreeItem(hItem, 0))
        return NULL;

    switch (wGetCode) {
    case TVGN_NEXTVISIBLE:
        return TV_GetNextVisItem(hItem);

    case TVGN_PREVIOUSVISIBLE:
        return TV_GetPrevVisItem(hItem);

    case TVGN_NEXT:
        return hItem->hNext;

    case TVGN_PREVIOUS:
        if (hItem->hParent->hKids == hItem)
            return NULL;
        else {
            TREEITEM FAR * hWalk;
            for (hWalk = hItem->hParent->hKids; hWalk->hNext != hItem; hWalk = hWalk->hNext);
            return hWalk;
        }

    case TVGN_PARENT:
        return VISIBLE_PARENT(hItem);

    case TVGN_CHILD:
        return hItem->hKids;
    }

    return NULL;
}


// ----------------------------------------------------------------------------
//
//  Returns the number of items (including the partially visible item at the
//  bottom based on the given flag) that fit in the tree's client window.
//
// ----------------------------------------------------------------------------

LRESULT NEAR TV_GetVisCount(PTREE pTree, BOOL fIncludePartial)
{
    int  i;

    if (!fIncludePartial)
        return(MAKELRESULTFROMUINT(pTree->cFullVisible));

    i = pTree->cFullVisible;

    if (pTree->cyWnd - (i * pTree->cyItem))
        i++;

    return i;
}


void TV_InvalidateInsertMarkRect(PTREE pTree, BOOL fErase)
{
    RECT rc;
    if (TV_GetInsertMarkRect(pTree, &rc))
        InvalidateRect(pTree->ci.hwnd, &rc, fErase);
}

// ----------------------------------------------------------------------------
//
//  recomputes tree's fields that rely on the tree's client window size
//
//  sets cxWnd, cyWnd, cFullVisible
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SizeWnd(PTREE pTree, UINT cxWnd, UINT cyWnd)
{
    RECT rc;
    UINT cxOld = pTree->cxWnd;
    if (!cxWnd || !cyWnd)
    {
        GetClientRect(pTree->ci.hwnd, &rc);
        cxWnd = rc.right;
        cyWnd = rc.bottom;
    }
    pTree->cxWnd = (SHORT)cxWnd;
    pTree->cyWnd = (SHORT)cyWnd;
    pTree->cFullVisible = cyWnd / pTree->cyItem;
    
    if (pTree->ci.style & TVS_NOSCROLL)
        pTree->cxMax = (WORD) cxWnd;
    
    TV_CalcScrollBars(pTree);
    if (pTree->cxBorder)
    {
        rc.top = 0;
        rc.bottom = cyWnd;
        rc.right = cxOld;
        rc.left = cxOld - pTree->cxBorder;
        if (rc.left < (int)cxWnd) {
            // invalidate so clipping happens on right on size.
            InvalidateRect(pTree->ci.hwnd, &rc, TRUE);  
        }
    }

    TV_InvalidateInsertMarkRect(pTree, TRUE);

    return TRUE;
}


void TV_HandleStateIconClick(PTREE pTree, HTREEITEM hItem)
{
    TVITEMEX tvi;
    int iState;

    tvi.stateMask = TVIS_STATEIMAGEMASK;
    TV_GetItem(pTree, hItem, TVIF_STATE, &tvi);

    iState = STATEIMAGEMASKTOINDEX(tvi.state & tvi.stateMask);
    iState %= (ImageList_GetImageCount(pTree->himlState) - 1);
    iState++;

    tvi.mask = TVIF_STATE;
    tvi.state = INDEXTOSTATEIMAGEMASK(iState);
    tvi.hItem = hItem;
    TV_SetItem(pTree, &tvi);

}


//
//  Eudora is a piece of work.
//
//  When they get a NM_DBLCLK notification from a treeview, they say,
//  "Oh, I know that treeview allocates its NMHDR from the stack, and
//  there's this local variable on Treeview's stack I'm really interested
//  in, so I'm going to hard-code an offset from the pnmhdr and read the
//  DWORD at that location so I can get at the local variable.  I will then
//  stop working if this value is zero."
//
//  The conversion to UNICODE changed our stack layout enough that they
//  end up always getting zero -- it's the NULL parameter which is the
//  final argument to CCSendNotify.  Since all this stack layout stuff is
//  sensitive to how the compiler's optimizer feels today, we create a
//  special notify structure Just For Eudora which mimics the stack layout
//  they expected to see in Win95.
//
typedef struct NMEUDORA {
    NMHDR   nmhdr;
    BYTE    Padding[48];
    DWORD   MustBeNonzero;      // Eudora fails to install if this is zero
} NMEUDORA;

// ----------------------------------------------------------------------------
//
//  WM_LBUTTONDBLCLK message -- toggle expand/collapse state of item's children
//  WM_LBUTTONDOWN message -- on item's button, do same as WM_LBUTTONDBLCLK,
//  otherwise select item and ensure that item is fully visible
//
// ----------------------------------------------------------------------------

void NEAR TV_ButtonDown(PTREE pTree, UINT wMsg, UINT wFlags, int x, int y, UINT TVBD_flags)
{
    UINT wHitCode;
    TREEITEM FAR * hItem;
    HWND hwndTree;
    LRESULT lResult;
#ifdef _X86_
    NMEUDORA nmeu;
    nmeu.MustBeNonzero = 1;
    COMPILETIME_ASSERT(FIELD_OFFSET(NMEUDORA, MustBeNonzero) == 0x3C);
#endif

    GetMessagePosClient(pTree->ci.hwnd, &pTree->ptCapture);

    if (!TV_DismissEdit(pTree, FALSE))   // end any previous editing (accept it)
        return;     // Something happened such that we should not process button down


    hItem = TV_CheckHit(pTree, x, y, &wHitCode);

    // Excel likes to destroy the entire tree when it gets a double-click
    // so we need to watch the item in case it vanishes behind our back.
    hwndTree = pTree->ci.hwnd;

    if (wMsg == WM_LBUTTONDBLCLK)
    {
        //
        // Cancel any name editing that might happen.
        //

        TV_CancelEditTimer(pTree);

        if (wHitCode & (TVHT_ONITEM | TVHT_ONITEMBUTTON)) {
            goto ExpandItem;
        }

        //
        // Collapses node above the line double clicked on
        //
        else if ((pTree->ci.style & TVS_HASLINES) && (wHitCode & TVHT_ONITEMINDENT) &&
            (abs(x % pTree->cxIndent - pTree->cxIndent/2) <= g_cxDoubleClk)) {

            int i;

            for (i = hItem->iLevel - x/pTree->cxIndent + ((pTree->ci.style & TVS_LINESATROOT)?1:0); i > 1; i--)
                hItem = hItem->hParent;

ExpandItem:
#ifdef _X86_
            lResult = CCSendNotify(&pTree->ci, wFlags & MK_RBUTTON ? NM_RDBLCLK : NM_DBLCLK, &nmeu.nmhdr);
#else
            lResult = CCSendNotify(&pTree->ci, wFlags & MK_RBUTTON ? NM_RDBLCLK : NM_DBLCLK, NULL);
#endif
            if (!IsWindow(hwndTree))
                goto bail;
            if (!lResult) {
                // don't auto expand this if we're in single expand mode because the first click did it already
                if (!(pTree->ci.style & TVS_SINGLEEXPAND))
                    TV_Expand(pTree, TVE_TOGGLE, hItem, TRUE);
            }

        }

        pTree->fScrollWait = FALSE;

    } else {    // WM_LBUTTONDOWN

        if (wHitCode == TVHT_ONITEMBUTTON)
        {
            if (!CCSendNotify(&pTree->ci, NM_CLICK, NULL)) {
                if (TVBD_flags & TVBD_FROMWHEEL)
                    TV_Expand(pTree, (TVBD_flags & TVBD_WHEELFORWARD) ? TVE_EXPAND : TVE_COLLAPSE, hItem, TRUE);
                else
                    TV_Expand(pTree, TVE_TOGGLE, hItem, TRUE);
            }
        }
        else if (wHitCode & TVHT_ONITEM ||
                ((pTree->ci.style & TVS_FULLROWSELECT) && (wHitCode & (TVHT_ONITEMRIGHT | TVHT_ONITEMINDENT))))
        {
            BOOL fSameItem, bDragging;

            ASSERT(hItem);

            fSameItem = (hItem == pTree->hCaret);

            if (TVBD_flags & TVBD_FROMWHEEL)
                bDragging = FALSE;
            else if (pTree->ci.style & TVS_DISABLEDRAGDROP)
                bDragging = FALSE;
            else {
                bDragging = TV_CheckForDragBegin(pTree, hItem, x, y);
                TV_FinishCheckDrag(pTree);
            }

            if (bDragging)
            {
                pTree->htiDrag = hItem;
                TV_SendBeginDrag(pTree, TVN_BEGINDRAG, hItem, x, y);
                return;
            }

            if (!CCSendNotify(&pTree->ci, NM_CLICK, NULL)) {

                if (wHitCode == TVHT_ONITEMSTATEICON &&
                    (pTree->ci.style & TVS_CHECKBOXES)) {
                    TV_HandleStateIconClick(pTree, hItem);
                } else {

                    // Only set the caret (selection) if not dragging
                    TV_SelectItem(pTree, TVGN_CARET, hItem, TVSIF_NOTIFY | TVSIF_UPDATENOW, TVC_BYMOUSE);

                    if (fSameItem && (wHitCode & TVHT_ONITEMLABEL) && pTree->fFocus)
                    {
                        //
                        // The item and window are currently selected and user clicked
                        // on label.  Try to enter into name editing mode.
                        //
                        SetTimer(pTree->ci.hwnd, IDT_NAMEEDIT, GetDoubleClickTime(), NULL);
                        pTree->fNameEditPending = TRUE;
                    }

                    if (fSameItem && pTree->ci.style & TVS_SINGLEEXPAND) {
                        // single click on the focus item toggles expand state
                        TV_Expand(pTree, TVE_TOGGLE, pTree->hCaret, TRUE);
                    }
                }
            }
        } else {
            CCSendNotify(&pTree->ci, NM_CLICK, NULL);
        }
    }

    if (!pTree->fFocus)
        SetFocus(pTree->ci.hwnd);

bail:;
}


// ----------------------------------------------------------------------------
//
//  Gets the item's text, data, and/or image.
//
// ----------------------------------------------------------------------------
BOOL NEAR TV_OnGetItem(PTREE pTree, LPTVITEMEX ptvi)
{
    if (!ptvi)
        return FALSE;

    if (!ValidateTreeItem(ptvi->hItem, 0))
        return FALSE;           // Invalid parameter

    TV_GetItem(pTree, ptvi->hItem, ptvi->mask, ptvi);

    return TRUE;        // success
}

BOOL NEAR TV_OnGetItemA(PTREE pTree, LPTVITEMEXA ptvi)
{
    BOOL bRet;
    LPSTR pszA = NULL;
    LPWSTR pszW = NULL;

    //HACK Alert!  This code assumes that TVITEMA is exactly the same
    // as TVITEMW except for the text pointer in the TVITEM
    ASSERT(sizeof(TVITEMA) == sizeof(TVITEMW));

    if (!IsFlagPtr(ptvi) && (ptvi->mask & TVIF_TEXT) && !IsFlagPtr(ptvi->pszText)) {
        pszA = ptvi->pszText;
        pszW = LocalAlloc(LMEM_FIXED, ptvi->cchTextMax * sizeof(WCHAR));
        if (pszW == NULL) {
            return FALSE;
        }
        ptvi->pszText = (LPSTR)pszW;
    }
    bRet = TV_OnGetItem(pTree, (LPTVITEMEXW)ptvi);
    if (pszA) {
        if (bRet && ptvi->cchTextMax)
            ConvertWToAN(pTree->ci.uiCodePage, pszA, ptvi->cchTextMax, (LPWSTR)(ptvi->pszText), -1);
        LocalFree(pszW);
        ptvi->pszText = pszA;
    }
    return bRet;
}

// ----------------------------------------------------------------------------
//
//  Sets the item's text, data, and/or image.
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SetItemA(PTREE pTree, LPTVITEMEXA ptvi)
{
    LPSTR pszA = NULL;
    BOOL lRet;

    //HACK Alert!  This code assumes that TVITEMA is exactly the same
    // as TVITEMW except for the text pointer in the TVITEM
    ASSERT(sizeof(TVITEMA) == sizeof(TVITEMW));

    if (!IsFlagPtr(ptvi) && (ptvi->mask & TVIF_TEXT) && !IsFlagPtr(ptvi->pszText)) {
        pszA = ptvi->pszText;
        ptvi->pszText = (LPSTR)ProduceWFromA(pTree->ci.uiCodePage, pszA);

        if (ptvi->pszText == NULL) {
            ptvi->pszText = pszA;
            return -1;
        }
    }

    lRet = TV_SetItem(pTree, (LPCTVITEMEX)ptvi);

    if (pszA) {
        FreeProducedString(ptvi->pszText);
        ptvi->pszText = pszA;
    }

    return lRet;
}

BOOL NEAR TV_SetItem(PTREE pTree, LPCTVITEMEX ptvi)
{
    UINT uRDWFlags = RDW_INVALIDATE;
    BOOL fEraseIfTransparent = FALSE;
    HTREEITEM hItem;
    BOOL bActualChange = FALSE; // HACK: We want to keep track of which
                                // attributes were changed from CALLBACK to
                                // "real", and don't invalidate if those were
                                // the only changes
    int iIntegralPrev;
    BOOL fName = FALSE;
    BOOL fFocusSel = FALSE;
    BOOL fRecalcWidth = FALSE;
    BOOL fStateImageChange = FALSE;

    if (!ptvi)
        return FALSE;

    hItem = ptvi->hItem;

    // deal with the evil invisible root for multiple root trees.
    if (hItem == TVI_ROOT)
    {
        hItem = pTree->hRoot;
    }

    if (!ValidateTreeItem(hItem, 0))
        return FALSE;

    iIntegralPrev = hItem->iIntegral;

    // BUGBUG: send ITEMCHANING and ITEMCHANGED msgs

    if (ptvi->mask & TVIF_TEXT)
    {
        uRDWFlags = RDW_INVALIDATE |RDW_ERASE;
        bActualChange = TRUE;

        if (!ptvi->pszText)
        {
            Str_Set(&hItem->lpstr, LPSTR_TEXTCALLBACK);
        }
        else
        {
            if (!Str_Set(&hItem->lpstr, ptvi->pszText))
            {
                //
                // Memory allocation failed -  The best we can do now
                // is to set the item back to callback, and hope that
                // the top level program can handle it.
                //
                DebugMsg(DM_ERROR, TEXT("TreeView: Out of memory"));
                hItem->lpstr = LPSTR_TEXTCALLBACK;
            }
        }

        fRecalcWidth = TRUE;
        fName = TRUE;
    }

    if (ptvi->mask & TVIF_PARAM)
    {
        bActualChange = TRUE;
        hItem->lParam = ptvi->lParam;
    }

    if (ptvi->mask & TVIF_IMAGE)
    {
        if (hItem->iImage != (WORD)I_IMAGECALLBACK) {
            bActualChange = TRUE;
            fEraseIfTransparent = TRUE;
            if (pTree->hImageList && (ImageList_GetBkColor(pTree->hImageList) == (COLORREF)-1))
                uRDWFlags |= RDW_ERASE;

        }
        hItem->iImage = (SHORT)ptvi->iImage;
    }

    if (ptvi->mask & TVIF_SELECTEDIMAGE)
    {
        if (hItem->iSelectedImage != (WORD)I_IMAGECALLBACK)
            bActualChange = TRUE;
        hItem->iSelectedImage = (SHORT)ptvi->iSelectedImage;
    }

    if (ptvi->mask & TVIF_CHILDREN)
    {
        if (hItem->fKids != KIDS_CALLBACK)
            bActualChange = TRUE;

        if (ptvi->cChildren == I_CHILDRENCALLBACK) {
            hItem->fKids = KIDS_CALLBACK;
        } else {
            if (ptvi->cChildren)
                hItem->fKids = KIDS_FORCE_YES;
            else
                hItem->fKids = KIDS_FORCE_NO;
        }

        //
        // If this item currently has no kid, reset the item.
        //
        if ((ptvi->cChildren == I_CHILDRENCALLBACK) && (hItem->hKids == NULL))
        {
            hItem->state &= ~TVIS_EXPANDEDONCE;
            if (hItem->hParent)
                hItem->state &= ~TVIS_EXPANDED;
        }
    }

    if (ptvi->mask & TVIF_INTEGRAL)
    {
        if (LOWORD(ptvi->iIntegral) > 0)
            hItem->iIntegral = LOWORD(ptvi->iIntegral);
    }

    if (ptvi->mask & TVIF_STATE)
    {
        // don't & ptvi->state with TVIS_ALL because win95 didn't
        // and setting TVIS_FOCUS was retrievable even though we don't use it
        UINT change = (hItem->state ^ ptvi->state) & ptvi->stateMask;

        if (change)
        {
            // BUGBUG: (TVIS_SELECTED | TVIS_DROPHILITED) changes
            // should effect tree state
            hItem->state ^= change;
            bActualChange = TRUE;
            fEraseIfTransparent = TRUE;

            if (hItem->state & TVIS_BOLD) {
                if (!pTree->hFontBold)
                    TV_CreateBoldFont(pTree);
             }

            if (change & TVIS_BOLD){
                // do this because changing the boldness
                uRDWFlags |= RDW_ERASE;
                fRecalcWidth = TRUE;
            }

            fStateImageChange = change & TVIS_STATEIMAGEMASK;
            if (fStateImageChange) {
                uRDWFlags |= RDW_ERASE;
                // Adding/removing a state image changes the ITEM_OFFSET
                // If old image was 0, then we are adding.
                // If new image is 0, then we are removing.
                // (If old=new, then we don't get into this code path, so we
                // don't have to worry about that case.)
                if (!(hItem->state & TVIS_STATEIMAGEMASK) || // new
                    !((hItem->state ^ change) & TVIS_STATEIMAGEMASK)) { // old
                    fRecalcWidth = TRUE;
                }
            }

            fFocusSel = ((change & TVIS_SELECTED) != 0);
        }
    }

    if (fRecalcWidth) {
        hItem->iWidth = 0;          // Invalidate old width
        if (TV_IsShowing(hItem)) {
            TV_ScrollBarsAfterSetWidth(pTree, hItem);
        }
    }

    // force a redraw if something changed AND if we are not
    // inside of a paint of this guy (callbacks will set the
    // item on the paint callback to implement lazy data schemes)

    if (bActualChange && (pTree->hItemPainting != hItem))
    {
        if (fEraseIfTransparent) {
            if (pTree->hImageList) {
                if (ImageList_GetBkColor(pTree->hImageList) == CLR_NONE) {
                    uRDWFlags |= RDW_ERASE;
                }
            }

        }

        // If item height changed, then we've got a lot of cleaning up
        // to do.
        if (hItem->iIntegral != iIntegralPrev)
        {
            TV_ScrollBarsAfterResize(pTree, hItem, iIntegralPrev, uRDWFlags);
        }
        else
        {
            TV_InvalidateItem(pTree, hItem, uRDWFlags);
        }

        // REVIEW: we might need to update the scroll bars if the
        // text length changed!
    }

    if (bActualChange)
    {
        if (fName)
            MyNotifyWinEvent(EVENT_OBJECT_NAMECHANGE, pTree->ci.hwnd, OBJID_CLIENT,
                (LONG_PTR)hItem);

        if (fFocusSel)
        {
            MyNotifyWinEvent(EVENT_OBJECT_FOCUS, pTree->ci.hwnd, OBJID_CLIENT,
                (LONG_PTR)hItem);
            MyNotifyWinEvent(((hItem->state & TVIS_SELECTED) ?
                EVENT_OBJECT_SELECTIONADD : EVENT_OBJECT_SELECTIONREMOVE),
                pTree->ci.hwnd, OBJID_CLIENT, (LONG_PTR)hItem);
        }

        if (fStateImageChange)
            MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, pTree->ci.hwnd, OBJID_CLIENT,
                (LONG_PTR)hItem);
    }
    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  Calls TV_CheckHit to get the hit test results and then package it in a
//  structure back to the app.
//
// ----------------------------------------------------------------------------

HTREEITEM NEAR TV_OnHitTest(PTREE pTree, LPTV_HITTESTINFO lptvh)
{
    if (!lptvh)
        return 0; //BUGBUG: Validate LPTVHITTEST

    lptvh->hItem = TV_CheckHit(pTree, lptvh->pt.x, lptvh->pt.y, &lptvh->flags);

    return lptvh->hItem;
}

BOOL TV_IsItemTruncated(PTREE pTree, TREEITEM *hItem, LPRECT lprc)
{
    if (TV_GetItemRect(pTree,hItem,lprc,TRUE)) {
        lprc->left -= g_cxEdge;
        lprc->top -= g_cyBorder;
        if ((lprc->left + hItem->iWidth) > pTree->cxWnd) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL TV_HandleTTNShow(PTREE pTree, LPNMHDR lpnm)
{
    if (pTree->hToolTip && pTree->fPlaceTooltip) {
        LPNMTTSHOWINFO psi = (LPNMTTSHOWINFO)lpnm;
        RECT rc;
        TVITEMEX item;

        // Now get the text associated with that item
        item.stateMask = TVIS_BOLD;
        TV_GetItem(pTree, pTree->hToolTip, TVIF_STATE, &item);
        SendMessage(pTree->hwndToolTips, WM_SETFONT, (WPARAM)((item.state & TVIS_BOLD) ? pTree->hFontBold : pTree->hFont), 0);

        TV_GetItemRect(pTree, pTree->hToolTip, &rc, TRUE);

        MapWindowRect(pTree->ci.hwnd, HWND_DESKTOP, &rc);
        // We draw the text with margins, so take those into account too.
        // These values come from TV_DrawItem...
        rc.top += g_cyBorder;
        rc.left += g_cxLabelMargin;

        //
        //  At this point, (rc.left, rc.top) are the coordinates we pass
        //  to DrawText.  Ask the tooltip how we should position it so the
        //  tooltip text shows up in precisely the same location.
        //
        // BUGBUG raymondc v6: wrong coordinates if app has used TVM_SETITEMHEIGHT

        SendMessage(pTree->hwndToolTips, TTM_ADJUSTRECT, TRUE, (LPARAM)&rc);
        SetWindowPos(pTree->hwndToolTips, NULL, rc.left, rc.top,0,0,
                     SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
        // This is an inplace tooltip, so disable animation.
        psi->dwStyle |= TTS_NOANIMATE;
        // handled!
        return TRUE;
    }

    return FALSE;
}

//
//  Copy the font from the treeview item into the tooltip so the tooltip
//  shows up in the correct font.
//
BOOL TV_HandleTTCustomDraw(PTREE pTree, LPNMTTCUSTOMDRAW pnm)
{
    if (pTree->hToolTip && pTree->fPlaceTooltip &&
        (pnm->nmcd.dwDrawStage == CDDS_PREPAINT ||
         pnm->nmcd.dwDrawStage == CDDS_ITEMPREPAINT))
    {
        //
        //  Set up the customdraw DC to match the font of the TV item.
        //
        TVFAKEDRAW tvfd;
        DWORD dwCustom = 0;
        TreeView_BeginFakeCustomDraw(pTree, &tvfd);
        dwCustom = TreeView_BeginFakeItemDraw(&tvfd, pTree->hToolTip);

        // If client changed the font, then transfer the font
        // from our private hdc into the tooltip's HDC.  We use
        // a private HDC because we only want to let the app change
        // the font, not the colors or anything else.
        if (dwCustom & CDRF_NEWFONT)
        {
            SelectObject(pnm->nmcd.hdc, GetCurrentObject(tvfd.nmcd.nmcd.hdc, OBJ_FONT));
        }
        TreeView_EndFakeItemDraw(&tvfd);
        TreeView_EndFakeCustomDraw(&tvfd);

        // Don't return other wacky flags to TT, since all we
        // did was change the font (if even that)
        return dwCustom & CDRF_NEWFONT;

    }
    return CDRF_DODEFAULT;

}

BOOL TV_SetToolTipTarget(PTREE pTree, HTREEITEM hItem)
{
    // update the item we're showing the bubble for...
    if (pTree->hToolTip != hItem) {
        // the hide will keep us from flashing
        ShowWindow(pTree->hwndToolTips, SW_HIDE);
        UpdateWindow(pTree->hwndToolTips);
        pTree->hToolTip = hItem;
        SendMessage(pTree->hwndToolTips, TTM_UPDATE, 0, 0);
        return TRUE;
    }
    return FALSE;
}

TREEITEM* TV_ItemAtCursor(PTREE pTree, LPRECT prc)
{
    RECT rc;
    UINT wHitCode;
    TREEITEM* hItem;

    GetCursorPos((LPPOINT)&rc);
    ScreenToClient(pTree->ci.hwnd, (LPPOINT)&rc);
    hItem = TV_CheckHit(pTree,rc.left,rc.top,&wHitCode);

    if (prc)
        *prc = rc;
    if (!(wHitCode & TVHT_ONITEM))
        hItem = NULL;

    return hItem;
}

BOOL TV_UpdateToolTipTarget(PTREE pTree)
{
    RECT rc;
    TREEITEM *hItem = TV_ItemAtCursor(pTree, &rc);

    if (!(pTree->ci.style & TVS_NOTOOLTIPS) 
            && !TV_IsItemTruncated(pTree, hItem, &rc)
            && !(pTree->ci.style & TVS_INFOTIP))
        hItem = NULL;
//    else if (!(pTree->ci.style & TVS_NOTOOLTIPS)
//                    || (pTree->ci.style & TVS_INFOTIP))
    return TV_SetToolTipTarget(pTree, hItem);
}

BOOL TV_UpdateToolTip(PTREE pTree)
{
    if (pTree->hwndToolTips && pTree->fRedraw)
       return (TV_UpdateToolTipTarget(pTree));
    return TRUE;
}

BOOL TV_SetInsertMark(PTREE pTree, HTREEITEM hItem, BOOL fAfter)
{
    if (!ValidateTreeItem(hItem, VTI_NULLOK))   // NULL means remove insert mark
        return FALSE;

    TV_InvalidateInsertMarkRect(pTree, TRUE); // Make sure the old one gets erased

    pTree->fInsertAfter = BOOLIFY(fAfter);
    pTree->htiInsert = hItem;

    TV_InvalidateInsertMarkRect(pTree, FALSE); // Make sure the new one gets drawn

    return TRUE;
}

BOOL TV_GetInfoTip(PTREE pTree, LPTOOLTIPTEXT lpttt, HTREEITEM hti, LPTSTR szBuf, int cch)
{
    NMTVGETINFOTIP git;

    szBuf[0] = 0;
    git.pszText = szBuf;
    git.cchTextMax = cch;
    git.hItem = hti;
    git.lParam = hti->lParam;

    // for folded items pszText is prepopulated with the
    // item text, clients should append to this

    CCSendNotify(&pTree->ci, TVN_GETINFOTIP, &git.hdr);

    CCSetInfoTipWidth(pTree->ci.hwnd, pTree->hwndToolTips);
    Str_Set(&pTree->pszTip, git.pszText);
    lpttt->lpszText = pTree->pszTip;

    if(pTree->ci.style & TVS_RTLREADING)
    {
        lpttt->uFlags |= TTF_RTLREADING;
    }

    return lpttt->lpszText && lpttt->lpszText[0];
}




void TV_HandleNeedText(PTREE pTree, LPTOOLTIPTEXT lpttt)
{
    TVITEMEX tvItem;
    TCHAR szBuf[INFOTIPSIZE];
    RECT rc;
    HTREEITEM hItem;

    // No distracting tooltips while in-place editing, please
    if (pTree->htiEdit)
    {
        return;
    }

    // If the cursor isn't over anything, then stop
    hItem = TV_ItemAtCursor(pTree, &rc);
    if (!hItem)
        return;

    // If the item has an infotip, then use it
    if (pTree->ci.style & TVS_INFOTIP) {
        if (hItem && TV_GetInfoTip(pTree, lpttt, hItem, szBuf, ARRAYSIZE(szBuf))) {
            pTree->fPlaceTooltip = FALSE;
            pTree->hToolTip = hItem;
            return;
        }
    }

    // Else it isn't an infotip
    CCResetInfoTipWidth(pTree->ci.hwnd, pTree->hwndToolTips);

    // If the item is not truncated, then no need for a tooltip
    if (!TV_IsItemTruncated(pTree, hItem, &rc))
    {
        tvItem.hItem = NULL;
        return;
    }

    // Display an in-place tooltip for the item
    pTree->fPlaceTooltip = TRUE;
    pTree->hToolTip = hItem;
    tvItem.hItem = hItem;
    tvItem.mask = TVIF_TEXT | TVIF_STATE;
    tvItem.pszText = szBuf;
    tvItem.stateMask = TVIS_DROPHILITED | TVIS_SELECTED;
    COMPILETIME_ASSERT(MAXLABELTEXT <= ARRAYSIZE(szBuf));
    tvItem.cchTextMax = MAXLABELTEXT;
    TV_OnGetItem(pTree,&tvItem);

    Str_Set(&pTree->pszTip, tvItem.pszText);
    lpttt->lpszText = pTree->pszTip;
    DebugMsg(DM_TRACE, TEXT("TV_HandleNeedText for %d returns %s"), tvItem.hItem, lpttt->szText);
}

//
//  Visual Studio 5.0 Books Online (part of VB 5.0) subclasses
//  us and responds NFR_ANSI, so we end up getting TTN_NEEDTEXTA
//  instead of TTN_NEEDTEXTW.  We can't risk forcing the tooltip
//  to UNICODE because some other apps may have done this on purpose
//  (because they intend to intercept TTN_NEEDTEXTA and do custom tooltips).
//  So support the ANSI tooltip notification so VB stays happy.
//  Note: This doesn't have to be efficient, as it's an error case anyway.
//
void TV_HandleNeedTextA(PTREE pTree, LPTOOLTIPTEXTA lptttA)
{
    TOOLTIPTEXT ttt;
    ttt.szText[0] = TEXT('\0');
    ttt.hdr       = lptttA->hdr;
    ttt.lpszText  = ttt.szText;
    ttt.hinst     = lptttA->hinst;
    ttt.uFlags    = lptttA->uFlags;
    ttt.lParam    = lptttA->lParam;

    TV_HandleNeedText(pTree, &ttt);
    if (pTree->pszTipA)
        LocalFree(pTree->pszTipA);
    pTree->pszTipA = ProduceAFromW(pTree->ci.uiCodePage, ttt.lpszText);
    lptttA->lpszText = pTree->pszTipA;
    lptttA->uFlags  = ttt.uFlags;
}

// ----------------------------------------------------------------------------
//
//  TV_Timer
//
//  Checks to see if it is our name editing timer.  If so it  calls of to
//  do name editing
//
// ----------------------------------------------------------------------------
LRESULT NEAR TV_Timer(PTREE pTree, UINT uTimerId)
{
    switch (uTimerId)
    {
        case IDT_NAMEEDIT:
            // Kill the timer as we wont need any more messages from it.
            KillTimer(pTree->ci.hwnd, IDT_NAMEEDIT);

            if (pTree->fNameEditPending)
            {
                // And start name editing mode.
                if (!TV_EditLabel(pTree, pTree->hCaret, NULL))
                {
                    TV_DismissEdit(pTree, FALSE);
                }

                // remove the flag...
                pTree->fNameEditPending = FALSE;
            }
            break;
            
        case IDT_SCROLLWAIT:
            KillTimer(pTree->ci.hwnd, IDT_SCROLLWAIT);
            if (pTree->fScrollWait)
            {
                if (pTree->hCaret) {
                    TV_ScrollVertIntoView(pTree, pTree->hCaret);
                }
                pTree->fScrollWait = FALSE;
            }
            break;


    }
    return 0;
}

// ----------------------------------------------------------------------------
//
//  TV_Command
//
//  Process the WM_COMMAND.  See if it is an input from our edit windows.
//  if so we may want to dismiss it, and or set it is being dirty...
//
// ----------------------------------------------------------------------------
void NEAR TV_Command(PTREE pTree, int id, HWND hwndCtl, UINT codeNotify)
{
    if ((pTree != NULL) && (hwndCtl == pTree->hwndEdit))
    {
        switch (codeNotify)
        {
        case EN_UPDATE:
            // We will use the ID of the window as a Dirty flag...
            SetWindowID(pTree->hwndEdit, 1);
            TV_SetEditSize(pTree);
            break;

        case EN_KILLFOCUS:
            // We lost focus, so dismiss edit and save changes
            // (Note that the owner might reject the change and restart
            // edit mode, which traps the user.  Owners need to give the
            // user a way to get out.)

            if (!TV_DismissEdit(pTree, FALSE))
               return;
            break;

        case HN_BEGINDIALOG: // penwin is bringing up a dialog
            ASSERT(GetSystemMetrics(SM_PENWINDOWS)); // only on a pen system
            pTree->fNoDismissEdit = TRUE;
            break;

        case HN_ENDDIALOG: // penwin has destroyed dialog
            ASSERT(GetSystemMetrics(SM_PENWINDOWS)); // only on a pen system
            pTree->fNoDismissEdit = FALSE;
            break;
        }

        // Forward edit control notifications up to parent
        //
        if (IsWindow(hwndCtl))
            FORWARD_WM_COMMAND(pTree->ci.hwndParent, id, hwndCtl, codeNotify, SendMessage);
    }
}

HIMAGELIST CreateCheckBoxImagelist(HIMAGELIST himl, BOOL fTree, BOOL fUseColorKey, BOOL fMirror);
void TV_CreateToolTips(PTREE pTree);

void TV_InitCheckBoxes(PTREE pTree)
{
    HIMAGELIST himl;
    TVITEMEX ti;
    BOOL fNoColorKey = FALSE;    // Backwards: If Cleartype is turned on, then we don't use colorkey.

    if (g_bRunOnNT5)
    {
#ifdef CLEARTYPE    // Don't use SPI_CLEARTYPE because it's defined because of APIThk, but not in NT.
        SystemParametersInfo(SPI_GETCLEARTYPE, 0, &fNoColorKey, 0);
#endif
    }

    himl = CreateCheckBoxImagelist(pTree->hImageList, TRUE, !fNoColorKey, IS_WINDOW_RTL_MIRRORED(pTree->ci.hwnd));
    if (pTree->hImageList) 
    {
        COLORREF cr = ImageList_GetBkColor(pTree->hImageList);
        ImageList_SetBkColor(himl, fNoColorKey? (CLR_NONE) : (cr));
    }

    TV_SetImageList(pTree, himl, TVSIL_STATE);

    ti.mask = TVIF_STATE;
    ti.state = INDEXTOSTATEIMAGEMASK(1);
    ti.stateMask = TVIS_STATEIMAGEMASK;
    TV_SetItemRecurse(pTree, pTree->hRoot, &ti);
}

void NEAR TV_OnStyleChanged(PTREE pTree, WPARAM gwl, LPSTYLESTRUCT pinfo)
{
    // Style changed: redraw everything...
    //
    // try to do this smartly, avoiding unnecessary redraws
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags;
        DWORD styleNew;

        TV_DismissEdit(pTree, FALSE);   // BUGBUG:  FALSE == accept changes.  Is this right?

        // You cannot combine TVS_HASLINES and TVS_FULLROWSELECT
        // because it doesn't work
        styleNew = pinfo->styleNew;
        if (styleNew & TVS_HASLINES) {
            if (styleNew & TVS_FULLROWSELECT) {
                DebugMsg(DM_ERROR, TEXT("Cannot combine TVS_HASLINES and TVS_FULLROWSELECT"));
            }
            styleNew &= ~TVS_FULLROWSELECT;
        }

        changeFlags = pTree->ci.style ^ styleNew; // those that changed
        pTree->ci.style = styleNew;               // change our version
        pTree->ci.style &= ~TVS_RTLREADING;
        pTree->ci.style |= (pinfo->styleNew & TVS_RTLREADING);       

        if (changeFlags & (TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT))
            TV_CreateIndentBmps(pTree);

        if (changeFlags & TVS_CHECKBOXES) {
            if (pTree->ci.style & TVS_CHECKBOXES) {
                TV_InitCheckBoxes(pTree);
            }
        }

        if (changeFlags & TVS_NOTOOLTIPS) {
            if (pTree->ci.style & TVS_NOTOOLTIPS) {
                DestroyWindow(pTree->hwndToolTips);
                pTree->hwndToolTips = NULL;
            } else {
                TV_CreateToolTips(pTree);
            }
        }

        if (changeFlags & TVS_TRACKSELECT) {
            if (!(pTree->ci.style & TVS_TRACKSELECT)) {
                if (pTree->hHot) {
                    TV_InvalidateItem(pTree, pTree->hHot, RDW_INVALIDATE | RDW_ERASE);
                    pTree->hHot = NULL;
                }
            }
        }
        // Checkboxes and stuff may have changed width - go recompute
        TV_ScrollBarsAfterSetWidth(pTree, NULL);
    }
    else if (gwl == GWL_EXSTYLE)
    {
        DWORD changeFlags;
        changeFlags = (pinfo->styleNew & WS_EX_RTLREADING) ?TVS_RTLREADING :0;

        if (changeFlags ^ (pTree->ci.style & TVS_RTLREADING))
        {
            pTree->ci.style ^= TVS_RTLREADING;
            TV_DismissEdit(pTree, FALSE);   // Cancels edits

            DestroyWindow(pTree->hwndToolTips);
            pTree->hwndToolTips = NULL;
            TV_CreateToolTips(pTree);
        }
    }
}

void TV_OnMouseMove(PTREE pTree, DWORD dwPos, WPARAM wParam)
{
    if (pTree->ci.style & TVS_TRACKSELECT) {
        POINT pt;
        HTREEITEM hHot;
        UINT wHitCode;

        pt.x = GET_X_LPARAM(dwPos);
        pt.y = GET_Y_LPARAM(dwPos);

        hHot = TV_CheckHit(pTree,pt.x,pt.y,&wHitCode);

        if (!(pTree->ci.style & TVS_FULLROWSELECT) &&
            !(wHitCode & TVHT_ONITEM)) {
            hHot = NULL;
        }

        if (hHot != pTree->hHot) {
            TV_InvalidateItem(pTree, pTree->hHot, RDW_INVALIDATE);
            TV_InvalidateItem(pTree, hHot, RDW_INVALIDATE);
            pTree->hHot = hHot;
            // update now so that we won't have an invalid area
            // under the tooltips
            UpdateWindow(pTree->ci.hwnd);
        }
    }

    if (pTree->hwndToolTips) {

        if (!TV_UpdateToolTip(pTree)) {
            RelayToToolTips(pTree->hwndToolTips, pTree->ci.hwnd, WM_MOUSEMOVE, wParam, dwPos);
        }
    }
}

void NEAR TV_OnWinIniChange(PTREE pTree, WPARAM wParam)
{
    if (!wParam ||
        (wParam == SPI_SETNONCLIENTMETRICS) ||
        (wParam == SPI_SETICONTITLELOGFONT)) {

        if (pTree->fCreatedFont)
            TV_OnSetFont(pTree, NULL, TRUE);

        if (!pTree->fIndentSet) {
            // this will validate against the minimum
            TV_SetIndent(pTree, 0);
        }
    }
}

void TV_OnSetBkColor(PTREE pTree, COLORREF clr)
{
    if (pTree->clrBk != (COLORREF)-1) {
        DeleteObject(pTree->hbrBk);
    }

    pTree->clrBk = clr;
    if (clr != (COLORREF)-1) {
        pTree->hbrBk = CreateSolidBrush(clr);
    }
    TV_CreateIndentBmps(pTree); // This also invalidates
}

BOOL TV_TranslateAccelerator(HWND hwnd, LPMSG lpmsg)
{
    if (!lpmsg)
        return FALSE;

    if (GetFocus() != hwnd)
        return FALSE;

    switch (lpmsg->message) {

    case WM_KEYUP:
    case WM_KEYDOWN:

        if (GetKeyState(VK_CONTROL) < 0) {
            switch (lpmsg->wParam) {
            case VK_LEFT:
            case VK_RIGHT:
            case VK_PRIOR:
            case VK_HOME:
            case VK_NEXT:
            case VK_END:
            case VK_UP:
            case VK_DOWN:
                TranslateMessage(lpmsg);
                DispatchMessage(lpmsg);
                return TRUE;
            }
        } else {

            switch (lpmsg->wParam) {

            case VK_RETURN:
            case VK_PRIOR:
            case VK_HOME:
            case VK_NEXT:
            case VK_END:
            case VK_SUBTRACT:
            case VK_ADD:
            case VK_MULTIPLY:
            case VK_LEFT:
            case VK_BACK:
            case VK_UP:
            case VK_RIGHT:
            case VK_DOWN:
            case VK_SPACE:
                TranslateMessage(lpmsg);
                DispatchMessage(lpmsg);
                return TRUE;
            }
        }
        break;
    }

    return FALSE;
}

// ----------------------------------------------------------------------------
//
//  TV_WndProc
//
//  Take a guess.
//
// ----------------------------------------------------------------------------

LRESULT CALLBACK TV_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PTREE pTree = (PTREE)GetWindowPtr(hwnd, 0);

    if (pTree) 
    {
        if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST) &&
            (pTree->ci.style & TVS_TRACKSELECT) && !pTree->fTrackSet) 
        {

            TRACKMOUSEEVENT tme;

            pTree->fTrackSet = TRUE;
            tme.cbSize = sizeof(tme);
            tme.hwndTrack = pTree->ci.hwnd;
            tme.dwFlags = TME_LEAVE;

            TrackMouseEvent(&tme);
        }
        else if (uMsg == g_uDragImages)
        {
            return TV_GenerateDragImage(pTree, (SHDRAGIMAGE*)lParam);
        }

    } 
    else 
    {
        if (uMsg == WM_CREATE) 
        {
            CCCreateWindow();
            return TV_OnCreate(hwnd, (LPCREATESTRUCT)lParam);
        }

        goto DoDefault;
    }



    switch (uMsg)
    {
        case WM_MOUSELEAVE:
            pTree->fTrackSet = FALSE;
            TV_InvalidateItem(pTree, pTree->hHot, RDW_INVALIDATE);
            pTree->hHot = NULL;
            TV_PopBubble(pTree);
            break;
            
        case TVMP_CALCSCROLLBARS:
            TV_CalcScrollBars(pTree);
            break;
            

        case TVM_GETITEMSTATE:
            {
                TVITEMEX tvi;

                tvi.mask = TVIF_STATE;
                tvi.stateMask = (UINT) lParam;
                tvi.hItem = (HTREEITEM)wParam;
                if (!TV_OnGetItem(pTree, &tvi))
                    return 0;

                return tvi.state;
            }
            
        case TVM_SETBKCOLOR:
        {
            LRESULT lres = (LRESULT)pTree->clrBk;
            TV_OnSetBkColor(pTree, (COLORREF)lParam);
            return lres;
        }

        case TVM_SETTEXTCOLOR:
        {
            LRESULT lres = (LRESULT)pTree->clrText;
            pTree->clrText = (COLORREF)lParam;
            TV_CreateIndentBmps(pTree); // This also invalidates
            return lres;
        }

        case TVM_GETBKCOLOR:
            return (LRESULT)pTree->clrBk;

        case TVM_GETTEXTCOLOR:
            return (LRESULT)pTree->clrText;

        case TVM_GETSCROLLTIME:
            return (LRESULT)pTree->uMaxScrollTime;

        case TVM_SETSCROLLTIME:
        {
            UINT u = pTree->uMaxScrollTime;
            pTree->uMaxScrollTime = (UINT)wParam;
            return (LRESULT)u;
        }


        case TVM_INSERTITEMA:
            if (!lParam)
                return 0;

            return (LRESULT)TV_InsertItemA(pTree, (LPTV_INSERTSTRUCTA)lParam);

        case TVM_GETITEMA:
            if (!lParam)
                return 0;

            return (LRESULT)TV_OnGetItemA(pTree, (LPTVITEMEXA)lParam);

        case TVM_SETITEMA:
            if (!lParam)
                return 0;

            return (LRESULT)TV_SetItemA(pTree, (LPTVITEMEXA)lParam);

        case TVM_INSERTITEM:
            return (LRESULT)TV_InsertItem(pTree, (LPTV_INSERTSTRUCT)lParam);

        case TVM_DELETEITEM:
            // Assume if items are being deleted that name editing is invalid.
            TV_DismissEdit(pTree, TRUE);
            return TV_DeleteItem(pTree, (TREEITEM FAR *)lParam, TVDI_NORMAL);

        case TVM_GETNEXTITEM:
            return (LRESULT)TV_GetNextItem(pTree, (TREEITEM FAR *)lParam, wParam);

        case TVM_GETITEMRECT:
            // lParam points to hItem to get rect from on input
            if (!lParam)
                return 0;
            if (!ValidateTreeItem(*(HTREEITEM FAR *)lParam, 0))
                return 0;               // Invalid parameter
            return (LRESULT)TV_GetItemRect(pTree, *(HTREEITEM FAR *)lParam, (LPRECT)lParam, (BOOL)wParam);

        case TVM_GETITEM:
            return (LRESULT)TV_OnGetItem(pTree, (LPTVITEMEX)lParam);

        case TVM_SETITEM:
            return (LRESULT)TV_SetItem(pTree, (LPCTVITEMEX)lParam);

        case TVM_ENSUREVISIBLE:
            if (!ValidateTreeItem((HTREEITEM)lParam, 0))
                return 0;
            return TV_EnsureVisible(pTree, (TREEITEM FAR *)lParam);

        case TVM_SETIMAGELIST:
            return (LRESULT)(ULONG_PTR)TV_SetImageList(pTree, (HIMAGELIST)lParam, (int)wParam);

        case TVM_EXPAND:
            if (!ValidateTreeItem((HTREEITEM)lParam, 0))
                return FALSE;               // invalid parameter
            return TV_Expand(pTree, wParam, (TREEITEM FAR *)lParam, FALSE);

        case TVM_HITTEST:
            return (LRESULT)TV_OnHitTest(pTree, (LPTV_HITTESTINFO)lParam);

        case TVM_GETCOUNT:
            return MAKELRESULTFROMUINT(pTree->cItems);

        case TVM_GETIMAGELIST:
            switch (wParam) {
            case TVSIL_NORMAL:
                return MAKELRESULTFROMUINT(pTree->hImageList);
            case TVSIL_STATE:
                return MAKELRESULTFROMUINT(pTree->himlState);
            default:
                return 0;
            }

        case TVM_GETISEARCHSTRINGA:
            if (GetFocus() == pTree->ci.hwnd)
                return (LRESULT)GetIncrementSearchStringA(&pTree->is, pTree->ci.uiCodePage, (LPSTR)lParam);
            else
                return 0;

        case TVM_GETISEARCHSTRING:
            if (GetFocus() == pTree->ci.hwnd)
                return (LRESULT)GetIncrementSearchString(&pTree->is, (LPTSTR)lParam);
            else
                return 0;

        case TVM_EDITLABELA:
            {
            LPWSTR lpEditString = NULL;
            HWND   hRet;

            if (wParam) {
                lpEditString = ProduceWFromA(pTree->ci.uiCodePage, (LPSTR)wParam);
            }

            hRet = TV_EditLabel(pTree, (HTREEITEM)lParam, lpEditString);

            if (lpEditString) {
                FreeProducedString(lpEditString);
            }

            return MAKELRESULTFROMUINT(hRet);
            }

        case TVM_EDITLABEL:
            return MAKELRESULTFROMUINT(TV_EditLabel(pTree, (HTREEITEM)lParam,
                    (LPTSTR)wParam));


        case TVM_GETVISIBLECOUNT:
            return TV_GetVisCount(pTree, (BOOL) wParam);

        case TVM_SETINDENT:
            TV_SetIndent(pTree, wParam);
            pTree->fIndentSet = TRUE;
            break;

        case TVM_GETINDENT:
            return MAKELRESULTFROMUINT(pTree->cxIndent);

        case TVM_CREATEDRAGIMAGE:
            return MAKELRESULTFROMUINT(TV_CreateDragImage(pTree, (TREEITEM FAR *)lParam));

        case TVM_GETEDITCONTROL:
            return (LRESULT)(ULONG_PTR)pTree->hwndEdit;

        case TVM_SORTCHILDREN:
            return TV_SortChildren(pTree, (TREEITEM FAR *)lParam, (BOOL)wParam);

        case TVM_SORTCHILDRENCB:
            return TV_SortChildrenCB(pTree, (TV_SORTCB FAR *)lParam, (BOOL)wParam);

        case TVM_SELECTITEM:
            return TV_SelectItem(pTree, wParam, (TREEITEM FAR *)lParam, TVSIF_NOTIFY | TVSIF_UPDATENOW, TVC_UNKNOWN);

        case TVM_ENDEDITLABELNOW:
            return TV_DismissEdit(pTree, (BOOL)wParam);

        case TVM_GETTOOLTIPS:
            return (LRESULT)(ULONG_PTR)pTree->hwndToolTips;

        case TVM_SETTOOLTIPS:{
            HWND hwndOld = pTree->hwndToolTips;

            pTree->hwndToolTips = (HWND)wParam;
            return (LRESULT)(ULONG_PTR)hwndOld;
        }

        case TVM_GETITEMHEIGHT:
            return pTree->cyItem;

        case TVM_SETITEMHEIGHT:
        {
            int iOld = pTree->cyItem;
            pTree->fCyItemSet = (wParam != (WPARAM)-1);
            pTree->cyItem = (SHORT)wParam; // must be even
            TV_SetItemHeight(pTree);
            return iOld;
        }
        case TVM_SETBORDER:
        {
            int cyOld = pTree->cyBorder
                , cxOld = pTree->cxBorder;

            if (wParam & TVSBF_YBORDER)
                pTree->cyBorder = HIWORD(lParam);
            if (wParam & TVSBF_XBORDER)
                pTree->cxBorder = LOWORD(lParam);

            TV_CalcScrollBars(pTree);
            return MAKELONG(cxOld, cyOld);
        }
        case TVM_GETBORDER:
            return MAKELONG(pTree->cxBorder, pTree->cyBorder);
        case TVM_SETINSERTMARK:
            return TV_SetInsertMark(pTree, (TREEITEM FAR *)lParam, (BOOL) wParam);
        
        case TVM_SETINSERTMARKCOLOR:
        {
            LRESULT lres = (LRESULT)pTree->clrim;
            pTree->clrim = (COLORREF) lParam;
            TV_InvalidateInsertMarkRect(pTree, FALSE); // Repaint in new color
            return lres;
        }
        case TVM_GETINSERTMARKCOLOR:
            return pTree->clrim;

        case TVM_TRANSLATEACCELERATOR:
            return TV_TranslateAccelerator(hwnd, (LPMSG)lParam);

        case TVM_SETLINECOLOR:
        {
            LRESULT lres = (LRESULT)pTree->clrLine;
            pTree->clrLine = (COLORREF)lParam;
            TV_CreateIndentBmps(pTree); // This also invalidates
            return lres;
        }

        case TVM_GETLINECOLOR:
            return (LRESULT)pTree->clrLine;

#if defined(FE_IME)
        case WM_IME_COMPOSITION:
            // Now only Korean version is interested in incremental search with composition string.
            if (g_fDBCSInputEnabled) {
            if (((ULONG_PTR)GetKeyboardLayout(0L) & 0xF000FFFFL) == 0xE0000412L)
            {
                if (TV_OnImeComposition(pTree, wParam, lParam))
                {
                    lParam &= ~GCS_RESULTSTR;
                    goto DoDefault;
                }
                else
                    break;
            }
            }
            goto DoDefault;
#endif

        case WM_CHAR:
            if (pTree->iPuntChar) {
                pTree->iPuntChar--;
                return TRUE;
            } else {
                return HANDLE_WM_CHAR(pTree, wParam, lParam, TV_OnChar);
            }

        case WM_DESTROY:
            CCDestroyWindow();
            TV_DestroyTree(pTree);
            break;

        case WM_SETCURSOR:
            {
                NMMOUSE nm;
                HTREEITEM hItem;
                nm.dwHitInfo = lParam;
                hItem = TV_ItemAtCursor(pTree, NULL);
                if(hItem)
                {
                    nm.dwItemSpec = (ULONG_PTR)hItem;
                    nm.dwItemData = (ULONG_PTR)(hItem->lParam);
                }
                else
                {
                    nm.dwItemSpec = 0;
                    nm.dwItemData = 0;
                }
                             
                if (CCSendNotify(&pTree->ci, NM_SETCURSOR, &nm.hdr)) 
                {
                    return 0;
                }
            }
            if (pTree->ci.style & TVS_TRACKSELECT) {
                if (pTree->hHot) {
                    if (!pTree->hCurHot)
                        pTree->hCurHot = LoadHandCursor(0);
                    SetCursor(pTree->hCurHot);
                    return TRUE;
                }
            }
            goto DoDefault;
            break;

        case WM_WININICHANGE:
            TV_OnWinIniChange(pTree, wParam);
            break;

        case WM_STYLECHANGED:
            TV_OnStyleChanged(pTree, wParam, (LPSTYLESTRUCT)lParam);
            break;

        case WM_SETREDRAW:
            TV_OnSetRedraw(pTree, (BOOL)wParam);
            break;

        case WM_PRINTCLIENT:
        case WM_PAINT:
            TV_Paint(pTree, (HDC)wParam);
            break;

        case WM_ERASEBKGND:
            {
                RECT rc;

                TV_GetBackgroundBrush(pTree, (HDC) wParam);
                GetClipBox((HDC) wParam, &rc);
                FillRect((HDC)wParam, &rc, pTree->hbrBk);
            }
            return TRUE;

        case WM_GETDLGCODE:
            return (LRESULT) (DLGC_WANTARROWS | DLGC_WANTCHARS);

        case WM_HSCROLL:
            TV_HorzScroll(pTree, GET_WM_HSCROLL_CODE(wParam, lParam), GET_WM_HSCROLL_POS(wParam, lParam));
            break;

        case WM_VSCROLL:
            TV_VertScroll(pTree, GET_WM_VSCROLL_CODE(wParam, lParam), GET_WM_VSCROLL_POS(wParam, lParam));
            break;

        case WM_KEYDOWN:
            if (TV_KeyDown(pTree, wParam, lParam))
                IncrementSearchString(&pTree->is, 0, NULL);
                goto DoDefault;


        case WM_LBUTTONDBLCLK:
        case WM_LBUTTONDOWN:
            TV_ButtonDown(pTree, uMsg, (UINT) wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), 0);
            break;

        case WM_KILLFOCUS:
            // Reset wheel scroll amount
            gcWheelDelta = 0;

            pTree->fFocus = FALSE;
            if (pTree->hCaret)
            {
                TV_InvalidateItem(pTree, pTree->hCaret, RDW_INVALIDATE);
                UpdateWindow(pTree->ci.hwnd);
            }
            CCSendNotify(&pTree->ci, NM_KILLFOCUS, NULL);
            IncrementSearchString(&pTree->is, 0, NULL);
            break;

        case WM_SETFOCUS:
            ASSERT(gcWheelDelta == 0);

            pTree->fFocus = TRUE;
            if (pTree->hCaret)
            {
                TV_InvalidateItem(pTree, pTree->hCaret, RDW_INVALIDATE);
                MyNotifyWinEvent(EVENT_OBJECT_FOCUS, hwnd, OBJID_CLIENT, (LONG_PTR)pTree->hCaret);
            }
            else
                TV_SelectItem(pTree, TVGN_CARET, pTree->hTop, TVSIF_NOTIFY | TVSIF_UPDATENOW, TVC_INTERNAL);

            CCSendNotify(&pTree->ci, NM_SETFOCUS, NULL);
            break;

        case WM_GETFONT:
            return MAKELRESULTFROMUINT(pTree->hFont);

        case WM_SETFONT:
            TV_OnSetFont(pTree, (HFONT) wParam, (BOOL) lParam);
            break;

        case WM_SIZE:
            TV_SizeWnd(pTree, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            break;

        case WM_ENABLE:
            // HACK: we don't get WM_STYLECHANGE on EnableWindow()
            if (wParam)
                pTree->ci.style &= ~WS_DISABLED;        // enabled
            else
                pTree->ci.style |= WS_DISABLED; // disabled
            TV_CreateIndentBmps(pTree); // This invalidates the whole window!
            break;

        case WM_SYSCOLORCHANGE:
            InitGlobalColors();
            TV_CreateIndentBmps(pTree); // This invalidates the whole window!
            break;

        case WM_RBUTTONDOWN:
            TV_SendRButtonDown(pTree, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            break;

        case WM_TIMER:
            TV_Timer(pTree, (UINT) wParam);
            break;

    case WM_MOUSEMOVE:
        TV_OnMouseMove(pTree, (DWORD) lParam, wParam);
        break;

        case WM_COMMAND:
            TV_Command(pTree, (int)GET_WM_COMMAND_ID(wParam, lParam), GET_WM_COMMAND_HWND(wParam, lParam),
                    (UINT)GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case WM_NOTIFY: {
            LPNMHDR lpnm = (LPNMHDR)lParam;

            if ((lpnm->code <= PGN_FIRST) && (PGN_LAST <= lpnm->code)) {
                LRESULT TV_OnPagerControlNotify(PTREE pTree, LPNMHDR pnm);

                return TV_OnPagerControlNotify(pTree, lpnm);
            }
            if (lpnm->hwndFrom == pTree->hwndToolTips) {
                switch (lpnm->code) {
                case TTN_NEEDTEXT:
                    TV_HandleNeedText(pTree, (LPTOOLTIPTEXT)lpnm);
                    break;

                case TTN_NEEDTEXTA:
                    TV_HandleNeedTextA(pTree, (LPTOOLTIPTEXTA)lpnm);
                    break;

                case TTN_SHOW:
                    return TV_HandleTTNShow(pTree, lpnm);

                case NM_CUSTOMDRAW:
                    return TV_HandleTTCustomDraw(pTree, (LPNMTTCUSTOMDRAW)lpnm);
                }
            }
            break;
        }

        case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&pTree->ci, lParam);

        case WM_MBUTTONDOWN:
            SetFocus(hwnd);
            goto DoDefault;

        case WM_GETOBJECT:
            if( lParam == OBJID_QUERYCLASSNAMEIDX )
                return MSAA_CLASSNAMEIDX_TREEVIEW;
            goto DoDefault;

        case WM_UPDATEUISTATE:
        {
            DWORD dwUIStateMask = MAKEWPARAM(0xFFFF, UISF_HIDEFOCUS);

            if (CCOnUIState(&(pTree->ci), WM_UPDATEUISTATE, wParam & dwUIStateMask, lParam))
                if (pTree->hCaret)
                    TV_InvalidateItem(pTree, pTree->hCaret, TRUE);

            goto DoDefault;
        }
        case WM_SYSKEYDOWN:
            TV_KeyDown(pTree, wParam, lParam);
            //fall through

        default:
            // Special handling of magellan mouse message
            if (uMsg == g_msgMSWheel) {
                BOOL  fScroll;
                BOOL  fDataZoom;
                DWORD dwStyle;
                int   cScrollLines;
                int   cPage;
                int   pos;
                int   cDetants;
                int iWheelDelta;

                if (g_bRunOnNT || g_bRunOnMemphis)
                {
                    iWheelDelta = (int)(short)HIWORD(wParam);
                    fScroll = !(wParam & (MK_SHIFT | MK_CONTROL));
                    fDataZoom = (BOOL) (wParam & MK_SHIFT);
                }
                else
                {
                    iWheelDelta = (int)wParam;
                    fDataZoom = (GetKeyState(VK_SHIFT) < 0);
                    fScroll = !fDataZoom && GetKeyState(VK_CONTROL) >= 0;
                }

                // Update count of scroll amount
                gcWheelDelta -= iWheelDelta;
                cDetants = gcWheelDelta / WHEEL_DELTA;
                if (cDetants != 0) {
                    gcWheelDelta %= WHEEL_DELTA;
                }

                if (fScroll) {
                    if (    g_ucScrollLines > 0 &&
                            cDetants != 0 &&
                            (WS_VSCROLL | WS_HSCROLL) & (dwStyle = GetWindowStyle(hwnd))) {

                        if (dwStyle & WS_VSCROLL) {
                            cPage = max(1, (pTree->cFullVisible - 1));
                            cScrollLines =
                                          cDetants *
                                          min(g_ucScrollLines, (UINT) cPage);

                            pos = max(0, pTree->hTop->iShownIndex + cScrollLines);
                            TV_VertScroll(pTree, SB_THUMBPOSITION, pos);
                        } else {
                            cPage = max(MAGIC_HORZLINE,
                                        (pTree->cxWnd - MAGIC_HORZLINE)) /
                                    MAGIC_HORZLINE;

                            cScrollLines =
                                          cDetants *
                                          (int) min((ULONG) cPage, g_ucScrollLines) *
                                          MAGIC_HORZLINE;

                            pos = max(0, pTree->xPos + cScrollLines);
                            TV_HorzScroll(pTree, SB_THUMBPOSITION, pos);
                        }
                    }
                    return 1;
                } else if (fDataZoom) {
                    UINT wHitCode;
                    POINT pt;

                    pt.x = GET_X_LPARAM(lParam);
                    pt.y = GET_Y_LPARAM(lParam);
                    ScreenToClient(hwnd, &pt);

                    // If we are rolling forward and hit an item then navigate into that
                    // item or expand tree (simulate lbuttondown which will do it).  We
                    // also need to handle rolling backwards over the ITEMBUTTON so
                    // that we can collapse the tree in that case.  Otherwise
                    // just fall through so it isn't handled.  In that case if we
                    // are being hosted in explorer it will do a backwards
                    // history navigation.
                    if (TV_CheckHit(pTree, pt.x, pt.y, &wHitCode) &&
                        (wHitCode & (TVHT_ONITEM | TVHT_ONITEMBUTTON))) {
                        UINT uFlags = TVBD_FROMWHEEL;
                        uFlags |= (iWheelDelta > 0) ? TVBD_WHEELFORWARD : TVBD_WHEELBACK;

                        if ((uFlags & TVBD_WHEELFORWARD) || (wHitCode == TVHT_ONITEMBUTTON)) {
                            TV_ButtonDown(pTree, WM_LBUTTONDOWN, 0, pt.x, pt.y, uFlags);
                            return 1;
                        }
                    }
                    // else fall through
                }
            } else {
                LRESULT lres;
                if (CCWndProc(&pTree->ci, uMsg, wParam, lParam, &lres))
                    return lres;
            }

DoDefault:
            return(DefWindowProc(hwnd, uMsg, wParam, lParam));
    }

    return(0L);
}

// NOTE: there is very similar code in the listview
//
// Totally disgusting hack in order to catch VK_RETURN
// before edit control gets it.
//
LRESULT CALLBACK TV_EditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PTREE pTree = (PTREE)GetWindowInt(GetParent(hwnd), 0);
    ASSERT(pTree);

    if (!pTree)
        return 0L;  // wierd cases can get here...

    switch (msg) {
    case WM_KEYDOWN:
        switch (wParam) {
        case VK_RETURN:
            TV_DismissEdit(pTree, FALSE);
            return 0L;

        case VK_ESCAPE:
            TV_DismissEdit(pTree, TRUE);
            return 0L;
        }
        break;

    case WM_CHAR:
        switch (wParam) {
        case VK_RETURN:
            // Eat the character, so edit control wont beep!
            return 0L;
        }
    }

    return CallWindowProc(pTree->pfnEditWndProc, hwnd, msg, wParam, lParam);
}


void NEAR TV_SetEditSize(PTREE pTree)
{
    RECT rcLabel;
    UINT seips;

    if (pTree->htiEdit == NULL)
        return;

    TV_GetItemRect(pTree, pTree->htiEdit, &rcLabel, TRUE);

    // get exact the text bounds (acount for borders used when drawing)

    InflateRect(&rcLabel, -g_cxLabelMargin, -g_cyBorder);

    seips = 0;
#ifdef DEBUG
    // If we are in one of the no-scroll modes then it's possible for the
    // resulting rectangle not to be visible.  Similarly, if the item itself
    // isn't visible, then the resulting rectangle is definitely not visible.
    // Tell SetEditInPlaceSize not to get upset in those cases.
    if ((pTree->ci.style & (TVS_NOSCROLL | TVS_NOHSCROLL)) ||
        !ITEM_VISIBLE(pTree->htiEdit))
        seips |= SEIPS_NOSCROLL;
#endif

    SetEditInPlaceSize(pTree->hwndEdit, &rcLabel, (HFONT)SendMessage(pTree->hwndEdit, WM_GETFONT, 0, 0), seips);
}


void NEAR TV_CancelEditTimer(PTREE pTree)
{
    if (pTree->fNameEditPending)
    {
        KillTimer(pTree->ci.hwnd, IDT_NAMEEDIT);
        pTree->fNameEditPending = FALSE;
    }
}

// BUGBUG: very similar code in lvicon.c


HWND NEAR TV_EditLabel(PTREE pTree, HTREEITEM hItem, LPTSTR pszInitial)
{
    TCHAR szLabel[MAXLABELTEXT];
    TV_DISPINFO nm;

    if (!(pTree->ci.style & TVS_EDITLABELS))
        return NULL;

    if (!ValidateTreeItem(hItem, 0))
        return NULL;

    TV_DismissEdit(pTree, FALSE);


    // Now get the text associated with that item
    nm.item.pszText = szLabel;
    nm.item.cchTextMax = ARRAYSIZE(szLabel);
    nm.item.stateMask = TVIS_BOLD;
    // this cast is ok as long as TVIF_INTEGRAL or anything past it isn't asked for
    TV_GetItem(pTree, hItem, TVIF_TEXT | TVIF_STATE, (LPTVITEMEX)&nm.item);

    // Must subtract one from ARRAYSIZE(szLabel) because Edit_LimitText
    // doesn't include the terminating NULL
    pTree->hwndEdit = CreateEditInPlaceWindow(pTree->ci.hwnd,
        pszInitial? pszInitial : nm.item.pszText, ARRAYSIZE(szLabel) - 1,
        WS_BORDER | WS_CLIPSIBLINGS | WS_CHILD | ES_LEFT | ES_AUTOHSCROLL,
        (nm.item.state & TVIS_BOLD) ? pTree->hFontBold : pTree->hFont);

    if (pTree->hwndEdit) {
        if (pszInitial)     // if initialized, it's dirty.
            SetWindowID(pTree->hwndEdit, 1);
        //
        // Now notify the parent of this window and see if they want it.
        // We do it after we cretae the window, but before we show it
        // such that our parent can query for it and do things like limit
        // the number of characters that are input
        nm.item.hItem = hItem;
        nm.item.state = hItem->state;
        nm.item.lParam = hItem->lParam;
        nm.item.mask = (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM | TVIF_TEXT);

        if ((BOOL)CCSendNotify(&pTree->ci, TVN_BEGINLABELEDIT, &nm.hdr))
        {
            DestroyWindow(pTree->hwndEdit);
            pTree->hwndEdit = NULL;
            return NULL;
        }

        TV_PopBubble(pTree);

        TV_ScrollIntoView(pTree, hItem);

        pTree->pfnEditWndProc = SubclassWindow(pTree->hwndEdit, TV_EditWndProc);

        pTree->htiEdit = hItem;

        TV_SetEditSize(pTree);

        // Show the window and set focus to it.  Do this after setting the
        // size so we don't get flicker.
        SetFocus(pTree->hwndEdit);
        ShowWindow(pTree->hwndEdit, SW_SHOW);
        TV_InvalidateItem(pTree, hItem, RDW_INVALIDATE | RDW_ERASE);

        RescrollEditWindow(pTree->hwndEdit);
    }

    return pTree->hwndEdit;
}


// BUGBUG: very similar code in lvicon.c

BOOL NEAR TV_DismissEdit(PTREE pTree, BOOL fCancel)
{
    HWND hwndEdit;
    BOOL fOkToContinue = TRUE;
    HTREEITEM htiEdit;

    if (pTree->fNoDismissEdit)
        return FALSE;

    hwndEdit = pTree->hwndEdit;

    if (!hwndEdit) {
        // Also make sure there are no pending edits...
        TV_CancelEditTimer(pTree);
        return TRUE;
    }

    // Assume that if we are not visible that the window is in the
    // process of being destroyed and we should not process the
    // editing of the window...
    if (!IsWindowVisible(pTree->ci.hwnd))
        fCancel = TRUE;

    //
    // We are using the Window ID of the control as a BOOL to
    // state if it is dirty or not.
    switch (GetWindowID(hwndEdit)) {
    case 0:
        // The edit control is not dirty so act like cancel.
        fCancel = TRUE;
        //  FALL THROUGH
    case 1:
        // The edit control is dirty so continue.
        SetWindowID(hwndEdit, 2);    // Don't recurse
        break;
    case 2:
        // We are in the process of processing an update now, bail out
        return TRUE;
    }

    // TV_DeleteItemRecurse will set htiEdit to NULL if the program
    // deleted the items out from underneath us (while we are waiting
    // for the edit timer).
    htiEdit = pTree->htiEdit;

    if (htiEdit != NULL)
    {
        TV_DISPINFO nm;
        TCHAR szLabel[MAXLABELTEXT];

        DBG_ValidateTreeItem(htiEdit, 0);

        // Initialize notification message.
        nm.item.hItem = htiEdit;
        nm.item.lParam = htiEdit->lParam;
        nm.item.mask = 0;

        if (fCancel)
            nm.item.pszText = NULL;
        else {
            Edit_GetText(hwndEdit, szLabel, ARRAYSIZE(szLabel));
            nm.item.pszText = szLabel;
            nm.item.cchTextMax = ARRAYSIZE(szLabel);
            nm.item.mask |= TVIF_TEXT;
        }

        // Make sure the text redraws properly
        TV_InvalidateItem(pTree, htiEdit, RDW_INVALIDATE | RDW_ERASE);
        pTree->fNoDismissEdit = TRUE; // this is so that we don't recurse due to killfocus
        ShowWindow(hwndEdit, SW_HIDE);
        pTree->fNoDismissEdit = FALSE;

        //
        // Notify the parent that we the label editing has completed.
        // We will use the LV_DISPINFO structure to return the new
        // label in.  The parent still has the old text available by
        // calling the GetItemText function.
        //

        fOkToContinue = (BOOL)CCSendNotify(&pTree->ci, TVN_ENDLABELEDIT, &nm.hdr);
        if (fOkToContinue && !fCancel)
        {
            // BUGBUG raymondc: The caller might have deleted the item in
            // response to the edit.  We should revalidate here (or make
            // delete item invalidate our edit item).  Treat a deletion
            // as if it were a rejected edit.

            //
            // If the item has the text set as CALLBACK, we will let the
            // ower know that they are supposed to set the item text in
            // their own data structures.  Else we will simply update the
            // text in the actual view.
            //
            // Note: The callee may have set the handle to null to tell
            // us that the handle to item is no longer valid.
            if (nm.item.hItem != NULL)
            {
                if (htiEdit->lpstr != LPSTR_TEXTCALLBACK)
                {
                    // Set the item text (everything's set up in nm.item)
                    //
                    nm.item.mask = TVIF_TEXT;
                    TV_SetItem(pTree, (LPTVITEMEX)&nm.item);
                }
                else
                {
                    CCSendNotify(&pTree->ci, TVN_SETDISPINFO, &nm.hdr);
                }
            }
        }
    }

    // If we did not reenter edit mode before now reset the edit state
    // variables to NULL
    if (hwndEdit == pTree->hwndEdit)
    {
        pTree->htiEdit = NULL;
        pTree->hwndEdit = NULL; // so we don't get reentered on the kill focus
    }

    // done with the edit control
    DestroyWindow(hwndEdit);

    return fOkToContinue;
}

LRESULT TV_OnCalcSize(PTREE pTree, LPNMHDR pnm)
{
    LPNMPGCALCSIZE pcalcsize = (LPNMPGCALCSIZE)pnm;

    switch(pcalcsize->dwFlag) {
    case PGF_CALCHEIGHT:
        pcalcsize->iHeight = pTree->cShowing * pTree->cyItem;
        TraceMsg(TF_WARNING, "tv.PGF_CALCHEIGHT: cShow=%d cShow*cyItem=%d AWR()=%d",
            pTree->cShowing, pTree->cShowing * pTree->cyItem, pcalcsize->iHeight);
        break;

    case PGF_CALCWIDTH:
        break;
    }
    return 0L;
}

LRESULT TV_OnPagerControlNotify(PTREE pTree, LPNMHDR pnm)
{
    switch(pnm->code) {
    case PGN_SCROLL:
        return TV_OnScroll(pTree, pnm);
        break;
    case PGN_CALCSIZE:
        return TV_OnCalcSize(pTree, pnm);
        break;
    }
    return 0L;
}

LRESULT TV_OnScroll(PTREE pTree, LPNMHDR pnm)
{
  
    LPNMPGSCROLL pscroll = (LPNMPGSCROLL)pnm;
    RECT rc = pscroll->rcParent;
    RECT rcTemp;
    int iDir = pscroll->iDir;
    int dyScroll = pscroll->iScroll;
    TREEITEM FAR * hItem;
    UINT uCode;
    int parentsize;
    TREEITEM FAR *  hPrevItem;
    TREEITEM FAR *  hNextItem;
    int y;
    
    POINT pt = {pscroll->iXpos, pscroll->iYpos};
    POINT ptTemp = pt;
    TREEITEM FAR *  hCurrentItem = TV_CheckHit(pTree, pt.x + 1, pt.y + 1 , &uCode);

    switch(iDir)
    {
        case PGF_SCROLLUP:
            //Check if any Item is partially visible at the left/top. if so then set the bottom 
            // of that Item to be our current offset and then scroll. This avoids skipping over
            // certain Items when partial Items are displayed at the left or top
            y = pt.y;       
            TV_GetItemRect(pTree,hCurrentItem,&rcTemp, TRUE);
 
            if (rcTemp.top  <  y-1)
            {
                hCurrentItem =TV_GetNextItem(pTree,hCurrentItem,TVGN_NEXTVISIBLE);
            }

            // Now do the calculation
            parentsize = RECTHEIGHT(rc);

            //if  the control key is down and we have more than parentsize size of child window
            // then scroll by that amount
            if ((pscroll->fwKeys & PGK_CONTROL) && ((pt.y - parentsize) > 0))
            {
                dyScroll = parentsize;
            } else if ((pt.y - pTree->cyItem) > 0) {
            // we dont have control key down so scroll by one buttonsize    
                dyScroll = pTree->cyItem;
            } else {
                pscroll->iScroll = pt.y;
                return 0L;
            }
            ptTemp.y -= dyScroll;
            hItem = TV_CheckHit(pTree, ptTemp.x, ptTemp.y, &uCode);

            if (hItem)
            {
                // if  the hit test gives us the same Item as our CurrentItem then set the Item 
                // to one Item to the top/left  of the  CurrentItem 

                hPrevItem = TV_GetNextItem(pTree,hCurrentItem, TVGN_PREVIOUSVISIBLE);
                if ((hItem == hCurrentItem) && ( hPrevItem != NULL))
                {
                    hItem = hPrevItem;
                }

                //When scrolling left if we end up in the middle of some Item then we align it to the 
                //right of that Item this is to avoid scrolling more than the pager window width but if the
                // Item happens to be the left Item of  our current Item then we end up in not scrolling
                //if thats the case then move one more Item to the left.


                if (hItem == hPrevItem) 
                {
                    hItem = TV_GetNextItem(pTree, hItem, TVGN_PREVIOUSVISIBLE);
                    if(!hItem)
                    {
                        dyScroll = pt.y;
                        break;
                    }
                }

                TV_GetItemRect(pTree,hItem,&rcTemp, TRUE);
                dyScroll = pt.y - rcTemp.bottom;
            }
            break;
        case PGF_SCROLLDOWN:
        {
            RECT rcChild;
            int childsize;

            GetWindowRect(pTree->ci.hwnd, &rcChild);
            childsize = RECTHEIGHT(rcChild);
            parentsize = RECTHEIGHT(rc);

            //if  the control key is down and we have more than parentsize size of child window
            // then scroll by that amount
            if ((pscroll->fwKeys & PGK_CONTROL) && ((childsize - pt.y - parentsize) > parentsize))
            {
                dyScroll = parentsize;
            } else if ( (childsize - pt.y - parentsize) > (pTree->cyItem * hCurrentItem->iIntegral) ) {
            // we dont have control key down so scroll by one buttonsize    
                dyScroll = pTree->cyItem * hCurrentItem->iIntegral;
            } else {
                pscroll->iScroll = childsize - pt.y - parentsize;
                return 0L;
            }
            ptTemp.y += dyScroll;

            hItem = TV_CheckHit(pTree, ptTemp.x, ptTemp.y, &uCode);

            if (hItem)
            {
                if ((hItem == hCurrentItem) && 
                    ((hNextItem = TV_GetNextItem(pTree,hItem,TVGN_NEXTVISIBLE)) != NULL))
                {
                    hItem = hNextItem;
                }
                TV_GetItemRect(pTree, hItem, &rcTemp, TRUE);
                dyScroll = rcTemp.top  - pt.y ;
            }

            break;
        }
    }
    //Set the scroll value
    pscroll->iScroll = dyScroll;
    return 0L;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\treeview.h ===
#include "listview.h"   // for some helper routines and border metrics
#define __IOleControl_INTERFACE_DEFINED__       // There is a conflich with the IOleControl's def of CONTROLINFO
#include "shlobj.h"

//
//  Definitions missing from commctrl.h
//
typedef const TVITEMEX *LPCTVITEMEX;

//
//  Private definitions
//
#define MAGIC_MININDENT 5
#define MAGIC_INDENT    3
#define MAGIC_HORZLINE  5

// flags for TV_DrawItem
#define TVDI_NOIMAGE    0x0001  // don't draw image
#define TVDI_NOTREE     0x0002  // don't draw indent, lines, +/-
#define TVDI_TRANSTEXT  0x0004  // draw text transparently in black
#define TVDI_ERASE      0x0008  // erase while drawing
#define TVDI_GRAYTEXT   0x0010  // text is gray (disabled item)
#define TVDI_GRAYCTL    0x0020  // text and background is gray (disabled control)
#define TVDI_FORCEIMAGE 0x0040  // Always draw image
#define TVDI_NOBK       0x0080

// Internal flags for TV_SelectItem
#define TVC_INTERNAL   0x1000

typedef struct _TREE {
    CONTROLINFO ci;

    // Flags
    BITBOOL        fHorz:1;        // horizontal scrollbar present
    BITBOOL        fVert:1;        // vertical scrollbar present
    BITBOOL        fFocus:1;       // currently has focus
    BITBOOL        fNameEditPending:1;  // Is a name edit pending?
    BITBOOL        fRedraw:1;      // should redraw?
    BITBOOL        fScrollWait:1;  // are we waiting for a dblclk to not scroll?
    BITBOOL        fCreatedFont:1; // we created our font
    BITBOOL        fNoDismissEdit:1; // don't dismiss in-place edit control
    BITBOOL        fIndentSet:1;    // is the parent managing the indent size?
    BITBOOL        fTrackSet:1;    // have we set a track event?
    BITBOOL        fPlaceTooltip:1; // should we do the placement of tooltip over the text?
    BITBOOL        fCyItemSet:1;    // the the parent set our item height?
    BITBOOL        fInsertAfter:1; // insert mark should be after htiInsert instead of before
    BITBOOL        fRestoreOldDrop:1; // hOldDrop needs to be restored to hDropTarget

    // Handles
    HTREEITEM   hRoot;          // tree root item
    HTREEITEM   hCaret;         // item with focus caret
    HTREEITEM   hDropTarget;    // item which is the drop target
    HTREEITEM   hOldDrop;       // item which used to be the drop target
    HTREEITEM   htiEdit;        // The item that is being edited.
    HTREEITEM   hHot;           // the currently hottracked item
    HTREEITEM   hToolTip;       // the current item set in tooltips
    HTREEITEM   htiInsert;      // item that is relative to the insert mark
    HTREEITEM   htiSearch;      // item active in most recent incremental search
    HTREEITEM   htiDrag;        // item that's being dragged.
    HDPA        hdpaWatch;      // array of PTVWATCHEDITEMs - items being watched
    HIMAGELIST  hImageList;     // image list
    HIMAGELIST  himlState;      // state image list

    HCURSOR hCurHot; // the cursor when we're over a hot item

    int         iPuntChar;      // number of wm_char's to punt
    int         cxState;
    int         cyState;

    UINT        uDBCSChar;      // DBCS character for incremental search

    HBRUSH      hbrBk;          // background brush
    HFONT       hFont;          // tree font
    HFONT       hFontHot;       // underlined for hot tracking
    HFONT       hFontBold;      // bold tree font
    HFONT       hFontBoldHot;       // underlined for hot tracking
    HBITMAP     hStartBmp;      // initial DC mono bitmap
    HBITMAP     hBmp;           // indent bitmaps in hdcBits
    HDC         hdcBits;        // HDC for drawing indent bitmaps
    HTREEITEM   hItemPainting;  // the guy we are currently painting
    HANDLE      hheap;          // heap for allocs for win32

    POINT       ptCapture;      // Point where the mouse was capture

    COLORREF    clrText;
    COLORREF    clrBk; 
    COLORREF    clrim;          // insert mark color.
    COLORREF    clrLine;        // line color

    // Dimensions
    SHORT       cxImage;        // image width
    SHORT       cyImage;        // image height
    SHORT       cyText;         // text height
    SHORT       cyItem;         // item height
    SHORT       cxBorder;   // horizontal item border
    SHORT       cyBorder;   // vert item border
    SHORT       cxIndent;       // indent width
    SHORT       cxWnd;          // window width
    SHORT       cyWnd;          // window height

    // Scroll Positioners
    WORD        cxMax;          // width of longest item
    WORD        cFullVisible;   // number of items that CAN fully fit in window
    SHORT       xPos;           // horizontal scrolled position
    UINT        cShowing;       // number of showing (non-collapsed) items
    UINT        cItems;         // total number of items
    HTREEITEM   hTop;           // first visible item (i.e., at top of client rect)
    UINT        uMaxScrollTime; // the maximum smooth scroll timing

    // stuff for edit in place
    HWND        hwndEdit;       // Edit window for name editing.
    WNDPROC     pfnEditWndProc; // edit field subclass proc

    //tooltip stuff
    HWND        hwndToolTips;
    LPTSTR      pszTip;         // store current tooltip/infotip string.
    LPSTR       pszTipA;        // store current ANSI tooltip/infotip string.

    //incremental search stuff
    ISEARCHINFO is;

} TREE, NEAR *PTREE;

#define TV_StateIndex(pitem) ((int)(((DWORD)((pitem)->state) >> 12) & 0xF))

#define KIDS_COMPUTE            0    // use hKids to determine if a node has children
#define KIDS_FORCE_YES          1    // force a node to have kids (ignore hKids)
#define KIDS_FORCE_NO           2    // force a node to not have kids (ignore hKids)
#define KIDS_CALLBACK           3    // callback to see if a node has kids
#define KIDS_INVALID            4    // all values this and above are bogus

#define MAXLABELTEXT            MAX_PATH

// BUGBUG: OINK OINK

//
//  Note that there are multiple senses of "visible" going on.
//
//  TREE.hTop tracks visibility in the sense of "will it be painted?"
//
//  TREEITEM.iShownIndex tracks visibility in the sense of "not collapsed".
//  You can be off the screen but as long as your parent is expanded
//  you get an iShownIndex.
//
//

typedef struct _TREEITEM {
    HTREEITEM hParent;          // allows us to walk back out of the tree
    HTREEITEM hNext;            // next sibling
    HTREEITEM hKids;            // first child
    LPTSTR    lpstr;            // item text, can be LPSTR_TEXTCALLBACK
    LPARAM lParam;              // item data

    WORD      state;            // TVIS_ state flags
    WORD      iImage;           // normal state image at iImage
    WORD      iSelectedImage;   // selected state image
    WORD      iWidth;           // cached: width of text area (for hit test, drawing)
    WORD      iShownIndex;      // cached: -1 if not visible, otherwise nth visible item
                                // invisible = parent is invisible or collapsed
    BYTE      iLevel;           // cached: level of item (indent)
    BYTE      fKids;            // KIDS_ values
    WORD      iIntegral;        // integral height
    WORD      wSignature;       // for parameter validation, put at end of struct

} TREEITEM;

//
//  The signature is intentionally not ASCII characters, so it's
//  harder to run into by mistake.  I choose a value greater than
//  0x8000 so it can't be the high word of a pointer.
//
#define TV_SIG      0xABCD

#define TV_MarkAsDead(hti)      ((hti)->wSignature = 0)

#define ITEM_VISIBLE(hti) ((hti)->iShownIndex != (WORD)-1)

// get the parent, avoiding the hidden root node
#define VISIBLE_PARENT(hItem) (!(hItem)->iLevel ? NULL : (hItem)->hParent)

// REVIEW: make this a function if the optimizer doesn't do well with this
#define FULL_WIDTH(pTree, hItem)  (ITEM_OFFSET(pTree,hItem) + hItem->iWidth)
int FAR PASCAL ITEM_OFFSET(PTREE pTree, HTREEITEM hItem);

#define VTI_NULLOK      1
BOOL ValidateTreeItem(HTREEITEM hItem, UINT flags);

#ifdef DEBUG
#define DBG_ValidateTreeItem(hItem, flags) ValidateTreeItem(hItem, flags)
#else
#define DBG_ValidateTreeItem(hItem, flags)
#endif

//
//  TVWATCHEDITEM
//
//  Structure that tracks items being watched.
//
//  See TV_StartWatch for more information, and TV_DoExpandRecurse
//  for an example.
//
//  The hti field is a bit odd.
//
//  if fStale == FALSE, then hti is the item being watched.
//  if fStale == TRUE , then hti is the item *after* the item being watched.
//
//  We keep this strange semantic for fStale==TRUE so that TV_NextWatchItem
//  can successfully step to the item after a deleted item.  (Normally,
//  trying to do anything with a deleted item will fault.)
//

typedef struct TVWATCHEDITEM {
    HTREEITEM   hti;                    // current item
    BOOL        fStale;                 // has the original item been deleted?
} TVWATCHEDITEM, *PTVWATCHEDITEM;

BOOL TV_StartWatch(PTREE pTree, PTVWATCHEDITEM pwi, HTREEITEM htiStart);
BOOL TV_EndWatch(PTREE pTree, PTVWATCHEDITEM pwi);
#define TV_GetWatchItem(pTree, pwi) ((pwi)->hti)
#define TV_RestartWatch(pTree, pwi, htiStart) \
                        ((pwi)->hti = (htiStart), (pwi)->fStale = FALSE)
#define TV_IsWatchStale(pTree, pwi) ((pwi)->fStale)
#define TV_IsWatchValid(pTree, pwi) (!(pwi)->fStale)

//
//  TV_NextWatchItem - Enumerate the item after the watched item.
//                     This works even if the watched item was deleted.
//
#define TV_NextWatchItem(pTree, pwi) \
    ((pwi)->fStale || ((pwi)->hti = (pwi)->hti->hNext)), \
     (pwi)->fStale = FALSE

// in TVSCROLL.C
BOOL      NEAR  TV_ScrollBarsAfterAdd       (PTREE, HTREEITEM);
BOOL      NEAR  TV_ScrollBarsAfterRemove    (PTREE, HTREEITEM);
BOOL      NEAR  TV_ScrollBarsAfterExpand    (PTREE, HTREEITEM);
BOOL      NEAR  TV_ScrollBarsAfterCollapse  (PTREE, HTREEITEM);
void      NEAR  TV_ScrollBarsAfterResize    (PTREE, HTREEITEM, int, UINT);
BOOL      NEAR  TV_ScrollBarsAfterSetWidth  (PTREE, HTREEITEM);
BOOL      NEAR  TV_HorzScroll               (PTREE, UINT, UINT);
BOOL      NEAR  TV_VertScroll               (PTREE, UINT, UINT);
BOOL      NEAR  TV_SetLeft                  (PTREE, int);
#define TV_SetTopItem(pTree, i) TV_SmoothSetTopItem(pTree, i, 0)
BOOL      NEAR  TV_SmoothSetTopItem               (PTREE, UINT, UINT);
BOOL      NEAR  TV_CalcScrollBars           (PTREE);
BOOL      NEAR  TV_ScrollIntoView           (PTREE, HTREEITEM);
BOOL      NEAR  TV_ScrollVertIntoView       (PTREE, HTREEITEM);
HTREEITEM NEAR  TV_GetShownIndexItem        (HTREEITEM, UINT);
UINT      NEAR  TV_ScrollBelow              (PTREE, HTREEITEM, BOOL, BOOL);
BOOL      NEAR  TV_SortChildren(PTREE, HTREEITEM, BOOL);
BOOL      NEAR  TV_SortChildrenCB(PTREE, LPTV_SORTCB, BOOL);
void      NEAR  TV_ComputeItemWidth(PTREE pTree, HTREEITEM hItem, HDC hdc);

// in TVPAINT.C
void       NEAR  TV_GetBackgroundBrush       (PTREE pTree, HDC hdc);
void       NEAR  TV_UpdateTreeWindow         (PTREE, BOOL);
void       NEAR  TV_ChangeColors             (PTREE);
void       NEAR  TV_CreateIndentBmps         (PTREE);
void       NEAR  TV_Paint                    (PTREE, HDC);
HIMAGELIST NEAR  TV_CreateDragImage          (PTREE pTree, HTREEITEM hItem);
BOOL       NEAR  TV_ShouldItemDrawBlue       (PTREE pTree, TVITEMEX *ti, UINT flags);
LRESULT    NEAR  TV_GenerateDragImage        (PTREE ptree, SHDRAGIMAGE* pshdi);

BOOL TV_GetInsertMarkRect(PTREE pTree, LPRECT prc);

// in TVMEM.C

#define TVDI_NORMAL             0x0000  // TV_DeleteItem flags
#define TVDI_NONOTIFY           0x0001
#define TVDI_CHILDRENONLY       0x0002
#define TVDI_NOSELCHANGE        0x0004

BOOL      NEAR  TV_DeleteItem(PTREE, HTREEITEM, UINT);
HTREEITEM NEAR  TV_InsertItem(PTREE pTree, LPTV_INSERTSTRUCT lpis);
void      NEAR  TV_DestroyTree(PTREE);
LRESULT   NEAR  TV_OnCreate(HWND, LPCREATESTRUCT);
HTREEITEM NEAR  TV_InsertItemA(PTREE pTree, LPTV_INSERTSTRUCTA lpis);


// in TREEVIEW.C
BOOL      NEAR TV_GetItemRect(PTREE, HTREEITEM, LPRECT, BOOL);
BOOL      NEAR TV_Expand(PTREE pTree, WPARAM wCode, TREEITEM FAR * hItem, BOOL fNotify);
HTREEITEM NEAR TV_GetNextItem(PTREE, HTREEITEM, WPARAM);
void      NEAR TV_GetItem(PTREE pTree, HTREEITEM hItem, UINT mask, LPTVITEMEX lpItem);
void      TV_PopBubble(PTREE pTree);

// Flags for TV_SelectItem
#define TVSIF_NOTIFY            0x0001
#define TVSIF_UPDATENOW         0x0002
#define TVSIF_NOSINGLEEXPAND    0x0004

BOOL      NEAR TV_SelectItem(PTREE, WPARAM, HTREEITEM, UINT, UINT);
BOOL      NEAR TV_SendChange(PTREE, HTREEITEM, int, UINT, UINT, UINT, int, int);
HTREEITEM NEAR TV_GetNextVisItem(HTREEITEM);
HTREEITEM NEAR TV_GetPrevItem(HTREEITEM);
HTREEITEM NEAR TV_GetPrevVisItem(HTREEITEM);
void      NEAR TV_CalcShownItems(PTREE, HTREEITEM hItem);
void      NEAR TV_OnSetFont(PTREE, HFONT, BOOL);
BOOL      NEAR TV_SizeWnd(PTREE, UINT, UINT);
void      NEAR TV_InvalidateItem(PTREE, HTREEITEM, UINT uFlags);
VOID NEAR PASCAL TV_CreateBoldFont(PTREE pTree);
BOOL TV_SetInsertMark(PTREE pTree, HTREEITEM hItem, BOOL fAfter);

LRESULT CALLBACK _export TV_EditWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK _export TV_WndProc(HWND, UINT, WPARAM, LPARAM);
BOOL FAR                 TV_Init(HINSTANCE hinst);
void FAR                 TV_Terminate(BOOL fSystemExit);

LRESULT   NEAR  TV_Timer                    (PTREE pTree, UINT uTimerId);
HWND      NEAR  TV_OnEditLabel              (PTREE pTree, HTREEITEM hItem);
void      NEAR  TV_SetEditSize              (PTREE pTree);
BOOL      NEAR  TV_DismissEdit              (PTREE pTree, BOOL fCancel);
void      NEAR  TV_CancelPendingEdit        (PTREE pTree);
int       NEAR  TV_UpdateShownIndexes       (PTREE pTree, HTREEITEM hWalk);


void NEAR TV_UnsubclassToolTips(PTREE pTree);
LRESULT WINAPI TV_SubClassWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
void NEAR TV_SubclassToolTips(PTREE pTree);
BOOL TV_UpdateToolTip(PTREE pTree);
BOOL TV_SetToolTipTarget(PTREE pTree, HTREEITEM hItem);
void TV_OnSetBkColor(PTREE pTree, COLORREF clr);
void TV_InitCheckBoxes(PTREE pTree);

#define TVMP_CALCSCROLLBARS (TV_FIRST + 0x1000)

// Fake customdraw.  See comment block in tvscroll.c

typedef struct TVFAKEDRAW {
    NMTVCUSTOMDRAW nmcd;
    PTREE pTree;
    HFONT hfontPrev;
    DWORD dwCustomPrev;
    DWORD dwCustomItem;
} TVFAKEDRAW, *PTVFAKEDRAW;

void TreeView_BeginFakeCustomDraw(PTREE pTree, PTVFAKEDRAW ptvfd);
DWORD TreeView_BeginFakeItemDraw(PTVFAKEDRAW plvfd, HTREEITEM hitem);
void TreeView_EndFakeItemDraw(PTVFAKEDRAW ptvfd);
void TreeView_EndFakeCustomDraw(PTVFAKEDRAW ptvfd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\trackme.c ===
//---------------------------------------------------------------------------
//
//     TrackME.C   (TrackMouseEvent)
//
// Created by:  Sankar  on 1/24/96
//
// What:
//     This emulates the TrackMouseEvent() API for the Nashville project
//     in comctl32.dll
//
// How:
//     This subclasses the given window to get mouse messages and uses a 
//     high frequency timer to learn about mouse leaves.
//
//---------------------------------------------------------------------------

#include "ctlspriv.h"

#ifdef TrackMouseEvent
#undef TrackMouseEvent
#endif

extern const TCHAR FAR c_szTMEdata[];

extern DWORD g_dwHoverSelectTimeout;

#define ID_MOUSEHOVER          0xFFFFFFF0L
#define ID_MOUSELEAVE          0xFFFFFFF1L

#define TME_MOUSELEAVE_TIME    (GetDoubleClickTime() / 5)

#define IsKeyDown(Key)   (GetKeyState(Key) & 0x8000)

// This is the structure whose pointer gets added as a property of a window
// being tracked.
typedef struct  tagTMEDATA {
       TRACKMOUSEEVENT TrackMouseEvent;
       RECT            rcMouseHover;  //In screen co-ordinates.
   }  TMEDATA, FAR *LPTMEDATA;


void NEAR TME_ResetMouseHover(LPTRACKMOUSEEVENT lpTME, LPTMEDATA lpTMEdata);
LRESULT CALLBACK TME_SubclassProc(HWND hwnd, UINT message, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData);

LPTMEDATA NEAR GetTMEdata(HWND hwnd)
{
    LPTMEDATA lpTMEdata;

    GetWindowSubclass(hwnd, TME_SubclassProc, 0, (ULONG_PTR *)&lpTMEdata);

    return lpTMEdata;
}

void NEAR TME_PostMouseLeave(HWND hwnd)
{
  PostMessage(hwnd, WM_MOUSELEAVE, 0, 0L);
}

void NEAR TME_CancelMouseLeave(LPTMEDATA lpTMEdata)
{
  if(!(lpTMEdata->TrackMouseEvent.dwFlags & TME_LEAVE))
      return;

  // Remove the flag.
  lpTMEdata->TrackMouseEvent.dwFlags &= ~(TME_LEAVE);

  // We leave the timer set here since our hover implementation uses it too.
  // TME_CancelTracking will kill it later.
}

void NEAR TME_CancelMouseHover(LPTMEDATA lpTMEdata)
{
  if(!(lpTMEdata->TrackMouseEvent.dwFlags & TME_HOVER))
      return;

  lpTMEdata->TrackMouseEvent.dwFlags &= ~(TME_HOVER);

  KillTimer(lpTMEdata->TrackMouseEvent.hwndTrack, ID_MOUSEHOVER);
}

void NEAR TME_CancelTracking(LPTMEDATA lpTMEdata)
{
  HWND hwndTrack;

  //If either MouseLeave or MouseHover is ON, don't cancel tracking.
  if(lpTMEdata->TrackMouseEvent.dwFlags & (TME_HOVER | TME_LEAVE))
      return;

  hwndTrack = lpTMEdata->TrackMouseEvent.hwndTrack;

  // Uninstall our subclass callback.
  RemoveWindowSubclass(hwndTrack, TME_SubclassProc, 0);

  // Kill the mouseleave timer.
  KillTimer(hwndTrack, ID_MOUSELEAVE);

  // Free the tracking data.
  LocalFree((HANDLE)lpTMEdata);
}

void NEAR TME_RemoveAllTracking(LPTMEDATA lpTMEdata)
{
  TME_CancelMouseLeave(lpTMEdata);
  TME_CancelMouseHover(lpTMEdata);
  TME_CancelTracking(lpTMEdata);
}

//---------------------------------------------------------------------------
//
// TME_MouseHasLeft()
//     The mouse has left the region being tracked. Send the MOUSELEAVE msg
// and then cancel all tracking.
//
//---------------------------------------------------------------------------
void NEAR TME_MouseHasLeft(LPTMEDATA  lpTMEdata)
{
  DWORD  dwFlags;

  //Is WM_MOUSELEAVE notification requied?
  if((dwFlags = lpTMEdata->TrackMouseEvent.dwFlags) & TME_LEAVE)
      TME_PostMouseLeave(lpTMEdata->TrackMouseEvent.hwndTrack); //Then, do it!

  // Cancel all the tracking since the mouse has left.
  TME_RemoveAllTracking(lpTMEdata);
}

// --------------------------------------------------------------------------
//  
//  TME_SubclassWndProc()
//  
//  The subclass proc used for TrackMouseEvent()...!
//
// --------------------------------------------------------------------------

LRESULT CALLBACK TME_SubclassProc(HWND hwnd, UINT message, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData)
{
      LPTMEDATA lpTMEdata = (LPTMEDATA)dwRefData;

      ASSERT(lpTMEdata);

      switch(message)
        {
          case WM_DESTROY:
          case WM_NCDESTROY:
              TME_RemoveAllTracking(lpTMEdata);
              break;

          case WM_ENTERMENULOOP:
              // If the window being tracked enters menu mode, then we need to
              // act asif the mouse has left.
              // NOTE: Because when we are in menu mode, the SCREEN_CAPTURE has occurred
              // and we don't see any mouse moves. This is the only way out!

              // Post mouse leave and cancel all tracking!
              TME_MouseHasLeft(lpTMEdata);
              break;

          case WM_LBUTTONDOWN:
          case WM_LBUTTONUP:
          case WM_MBUTTONDOWN:
          case WM_MBUTTONUP:
          case WM_RBUTTONDOWN:
          case WM_RBUTTONUP:
          case WM_NCLBUTTONDOWN:
          case WM_NCLBUTTONUP:
          case WM_NCMBUTTONDOWN:
          case WM_NCMBUTTONUP:
          case WM_NCRBUTTONDOWN:
          case WM_NCRBUTTONUP:
              //Whenever there is a mouse click, reset mouse hover.
              if(lpTMEdata->TrackMouseEvent.dwFlags & TME_HOVER)
                  TME_ResetMouseHover(&(lpTMEdata->TrackMouseEvent), lpTMEdata);
              break;

          case WM_NCMOUSEMOVE:
              TME_MouseHasLeft(lpTMEdata);
              break;

          case WM_MOUSEMOVE:
              {
                POINT Pt;

                Pt.x = GET_X_LPARAM(lParam);
                Pt.y = GET_Y_LPARAM(lParam);

                ClientToScreen(hwnd, &Pt);
 
                //Check if the mouse is within the hover rect.
                if((lpTMEdata->TrackMouseEvent.dwFlags & TME_HOVER) &&
                   !PtInRect(&(lpTMEdata->rcMouseHover), Pt))
                    TME_ResetMouseHover(&(lpTMEdata->TrackMouseEvent), lpTMEdata);
              }
              break;
        }

      return DefSubclassProc(hwnd, message, wParam, lParam);
}

// --------------------------------------------------------------------------
//  
//  TME_CheckInWindow()
//  
//  This get the current cursor position and checks if it still lies in the
//  "valid" area.
//   Returns TRUE, if it lies in the valid area.
//   FALSE, otherwise.
//
// --------------------------------------------------------------------------

BOOL NEAR TME_CheckInWindow(LPTRACKMOUSEEVENT lpTME, LPPOINT lpPt)
{
    POINT      pt;
    HWND       hwnd;   // Given window.
    HWND       hwndPt; //Window from the given point.
    HWND       hwndCapture;

    hwnd = lpTME->hwndTrack;  //Given window handle.

    //See if anyone has captured the mouse input.
    if((hwndCapture = GetCapture()) && IsWindow(hwndCapture))
      {
        // If tracking is required for a window other than the one that
        // has the capture, forget it! It is not possible!

        if(hwndCapture != hwnd)
            return(FALSE);
      }

    GetCursorPos(&pt);  //Get cursor point in screen co-ordinates.

    if (!hwndCapture)
    {
        hwndPt = WindowFromPoint(pt);

        if (!hwndPt || !IsWindow(hwndPt) || (hwnd != hwndPt))
            return FALSE;

        if (SendMessage(hwnd, WM_NCHITTEST, 0,
            MAKELPARAM((SHORT)pt.x, (SHORT)pt.y)) != HTCLIENT)
        {
            return FALSE;
        }
    }

    // The current point falls on the same area of the same window.
    // It is a valid location.
    if (lpPt)
        *lpPt = pt;

    return(TRUE);
}

// --------------------------------------------------------------------------
//  TME_MouseLeaveTimer()
//
//  Timer callback for WM_MOUSELEAVE generation and cancelling HOVER!
//
// --------------------------------------------------------------------------
VOID CALLBACK TME_MouseLeaveTimer(HWND hwnd, UINT msg, UINT_PTR id, DWORD dwTime)
{
    LPTMEDATA  lpTMEdata;

    if(!(lpTMEdata = GetTMEdata(hwnd)))
        return;

    // YIELD!!!
    if(TME_CheckInWindow(&(lpTMEdata->TrackMouseEvent), NULL))
        return;  //The mouse is still in the valid region. So, do nothing.

    if (!IsWindow(hwnd))
        return;

    //The mouse has left the valid region. So, post mouse-leave if requested
    //Because we are cancelling mouse-leave, we need to cancel mouse-hover too!
    // There can be no hover tracking, if the mouse has already left!

    TME_MouseHasLeft(lpTMEdata);
}


WPARAM NEAR GetMouseKeyFlags()
{
    WPARAM wParam = 0;

    if (IsKeyDown(VK_LBUTTON))
        wParam |= MK_LBUTTON;
    if (IsKeyDown(VK_RBUTTON))
        wParam |= MK_RBUTTON;
    if (IsKeyDown(VK_MBUTTON))
        wParam |= MK_MBUTTON;
    if (IsKeyDown(VK_SHIFT))
        wParam |= MK_SHIFT;
    if (IsKeyDown(VK_CONTROL))
        wParam |= MK_CONTROL;

    return wParam;
}

// --------------------------------------------------------------------------
//  TME_MouseHoverTimer()
//
//  Timer callback for WM_MOUSEHOVER/WM_NCMOUSEHOVER generation.
//
// --------------------------------------------------------------------------
VOID CALLBACK TME_MouseHoverTimer(HWND hwnd, UINT msg, UINT_PTR id, DWORD dwTime)
{
    POINT pt;
    WPARAM wParam;
    LPTMEDATA lpTMEdata;

    if (!(lpTMEdata = GetTMEdata(hwnd)))
        return;

    //BOGUS: we can not detect hwndSysModal from here!
    //Also, tracking is for a per-window basis now!
    //
    // BOGUS: We don't have to worry about JournalPlayback?
    //pt = fJournalPlayback? Lpq(hwnd->hq)->ptLast : ptTrueCursor;

    // YIELD!!!
    if(!TME_CheckInWindow(&(lpTMEdata->TrackMouseEvent), &pt))
      {
        // Mouse has left the valid region of the window. So, cancel all
        // the tracking.
        TME_MouseHasLeft(lpTMEdata);
        return;
      }

    if (!IsWindow(hwnd))
        return;

    if (!PtInRect(&(lpTMEdata->rcMouseHover), pt))
      {
        // Mouse has gone out of the hover rectangle. Reset the hovering.
        TME_ResetMouseHover(&(lpTMEdata->TrackMouseEvent), lpTMEdata);
        return;
      }

    //
    // set up to check the tolerance and 
    //
    wParam = GetMouseKeyFlags();
    ScreenToClient(hwnd, &pt);

    //Mouse is still within the hover rectangle. Let's post hover msg
    PostMessage(hwnd, WM_MOUSEHOVER, wParam, MAKELPARAM(pt.x, pt.y));

    //And then cancel the hovering.
    TME_CancelMouseHover(lpTMEdata);
    TME_CancelTracking(lpTMEdata);  //Cancel the tracking, if needed.
}

BOOL NEAR TME_SubclassWnd(LPTMEDATA lpTMEdata)
{
    BOOL fResult;

    fResult = SetWindowSubclass(lpTMEdata->TrackMouseEvent.hwndTrack,
        TME_SubclassProc, 0, (ULONG_PTR)lpTMEdata);

    ASSERT(fResult);
    return fResult;
}

void NEAR TME_ResetMouseLeave(LPTRACKMOUSEEVENT lpTME, LPTMEDATA lpTMEdata)
{
  //See if already MouseLeave is being tracked.
  if(lpTMEdata->TrackMouseEvent.dwFlags & TME_LEAVE)
      return;   // Nothing else to do.
  
  //Else, set the flag.
  lpTMEdata ->TrackMouseEvent.dwFlags |= TME_LEAVE;

  //Set the high frequency Timer.
  SetTimer(lpTME->hwndTrack, ID_MOUSELEAVE, TME_MOUSELEAVE_TIME, TME_MouseLeaveTimer);
}

void NEAR TME_ResetMouseHover(LPTRACKMOUSEEVENT lpTME, LPTMEDATA lpTMEdata)
{
    DWORD  dwMouseHoverTime;
    POINT  pt;

    // Even if the hover tracking is already happening, the caller might 
    // change the timer value, restart the timer or change the hover 
    // rectangle.
    lpTMEdata->TrackMouseEvent.dwFlags |= TME_HOVER;

    dwMouseHoverTime = lpTME->dwHoverTime;
    if (!dwMouseHoverTime || (dwMouseHoverTime == HOVER_DEFAULT))
        dwMouseHoverTime = (g_dwHoverSelectTimeout ? g_dwHoverSelectTimeout : GetDoubleClickTime()*4/5); // BUGBUG: Can't we remember this?
    GetCursorPos(&pt);

    //
    // update the tolerance rectangle for the hover window.
    //
    *((POINT *)&(lpTMEdata->rcMouseHover.left)) = *((POINT *)&(lpTMEdata->rcMouseHover.right)) = pt;

    //BOGUS: Can we use globals to remeber these metrics. What about NT?
    InflateRect(&(lpTMEdata->rcMouseHover), g_cxDoubleClk/2, g_cyDoubleClk/2);
                       
    // We need to remember the timer interval we are setting. This value
    // needs to be returned when TME_QUERY is used.
    lpTME->dwHoverTime = dwMouseHoverTime;
    lpTMEdata->TrackMouseEvent.dwHoverTime = dwMouseHoverTime;
    SetTimer(lpTME->hwndTrack, ID_MOUSEHOVER, dwMouseHoverTime, TME_MouseHoverTimer);
}

// --------------------------------------------------------------------------
//  QueryTrackMouseEvent()
//
//  Fills in a TRACKMOUSEEVENT structure describing current tracking state
//  for a given window. The given window is in lpTME->hwndTrack.
//
// --------------------------------------------------------------------------
BOOL NEAR QueryTrackMouseEvent(LPTRACKMOUSEEVENT lpTME)
{
    HWND hwndTrack;
    LPTMEDATA lpTMEdata;

    //
    // if there isn't anything being tracked get out
    //
    if((!(hwndTrack = lpTME->hwndTrack)) || !IsWindow(hwndTrack))
        goto Sorry;

    if(!(lpTMEdata = GetTMEdata(hwndTrack)))
        goto Sorry;

    if(!(lpTMEdata->TrackMouseEvent.dwFlags & (TME_HOVER | TME_LEAVE)))
        goto Sorry;

    //
    // fill in the requested information
    //
    lpTME->dwFlags = lpTMEdata->TrackMouseEvent.dwFlags;

    if (lpTMEdata->TrackMouseEvent.dwFlags & TME_HOVER)
        lpTME->dwHoverTime = lpTMEdata->TrackMouseEvent.dwHoverTime;
    else
        lpTME->dwHoverTime = 0;

    goto Done;

Sorry:
    // zero out the struct
    lpTME->dwFlags = 0;
    lpTME->hwndTrack = NULL;
    lpTME->dwHoverTime = 0;

Done:
    return TRUE;
}


// --------------------------------------------------------------------------
//  EmulateTrackMouseEvent()
//
//  emulate API for requesting extended mouse notifications (hover, leave...)
//
// --------------------------------------------------------------------------
BOOL WINAPI EmulateTrackMouseEvent(LPTRACKMOUSEEVENT lpTME)
{
    HWND    hwnd;
    DWORD   dwFlags;
    LPTMEDATA  lpTMEdata;

    if (lpTME->dwFlags & ~TME_VALID)
        return FALSE;

#ifdef TME_NONCLIENT
    //
    // this implementation does not handle TME_NONCLIENT (anymore)
    // we agreed with the NT team to rip it out until the system uses it...
    //
    if (lpTME->dwFlags & TME_NONCLIENT)
        return FALSE;
#endif

    //
    // implement queries separately
    //
    if (lpTME->dwFlags & TME_QUERY)
        return QueryTrackMouseEvent(lpTME);
    
    // 
    // Check the validity of the request.
    //
    hwnd = lpTME->hwndTrack;
    dwFlags = lpTME->dwFlags;

    if (!IsWindow(hwnd))
        return FALSE;

    // Check if the mouse is currently in a valid position
    // Use GetCursorPos() to get the mouse position and then check if
    // it lies within the client/non-client portion of the window as
    // defined in this call;

    // YIELD!!!
    if(!TME_CheckInWindow(lpTME, NULL))
      {
        //If the mouse leave is requested when the mouse is already outside
        // the window, then generate one mouse leave immly.
        if((dwFlags & TME_LEAVE) && !(dwFlags & TME_CANCEL))
            TME_PostMouseLeave(hwnd);
        
        //Because it is an invalid request, we return immly.
        return(TRUE);
      }

    if (!IsWindow(hwnd))
        return FALSE;

    //It is a valid request, either to install or remove tracking.

    //See if we already have tracking for this window.
    if(!(lpTMEdata = GetTMEdata(hwnd)))
      {
        //We are not tracking this window already.
        if(dwFlags & TME_CANCEL)
            return(TRUE);   //There is nothing to cancel; Ignore!
        
        //Do they want any tracking at all?
        ASSERT(dwFlags & (TME_HOVER | TME_LEAVE));

        //Allocate global mem to remember the tracking data
        if(!(lpTMEdata = (LPTMEDATA)LocalAlloc(LPTR, sizeof(TMEDATA))))
            return(FALSE);

        // copy in the hwnd
        lpTMEdata->TrackMouseEvent.hwndTrack = lpTME->hwndTrack;

        // Make sure our subclass callback is installed.
        if (!TME_SubclassWnd(lpTMEdata))
          {
            TME_CancelTracking(lpTMEdata);
            return(FALSE);
          }
      }

    //Else fall through!

    if(dwFlags & TME_CANCEL)
      {
        if(dwFlags & TME_HOVER)
            TME_CancelMouseHover(lpTMEdata);
        
        if(dwFlags & TME_LEAVE)
            TME_CancelMouseLeave(lpTMEdata);

        // If both hover and leave are cancelled, then we don't need any
        // tracking.
        TME_CancelTracking(lpTMEdata);

        return(TRUE); // Cancelled whatever they asked for.
      }

    if(dwFlags & TME_HOVER)
        TME_ResetMouseHover(lpTME, lpTMEdata);

    if(dwFlags & TME_LEAVE)
        TME_ResetMouseLeave(lpTME, lpTMEdata);

    return(TRUE);
}

typedef BOOL (WINAPI* PFNTME)(LPTRACKMOUSEEVENT);

PFNTME g_pfnTME = NULL;

// --------------------------------------------------------------------------
//  _TrackMouseEvent() entrypoint
//
//  calls TrackMouseEvent if present, otherwise uses EmulateTrackMouseEvent
//
// --------------------------------------------------------------------------
BOOL WINAPI _TrackMouseEvent(LPTRACKMOUSEEVENT lpTME)
{
    if (!g_pfnTME)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));

        if (hmod)
            g_pfnTME = (PFNTME)GetProcAddress(hmod, "TrackMouseEvent");

        if (!g_pfnTME)
            g_pfnTME = EmulateTrackMouseEvent;
    }

    return g_pfnTME(lpTME);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\tvscroll.c ===
#include "ctlspriv.h"
#include "treeview.h"

BOOL NEAR TV_EnsureVisible(PTREE pTree, TREEITEM FAR * hItem);

// ----------------------------------------------------------------------------
//
//  Updates the iShownIndex for every item below (in list order) a given item
//
// ----------------------------------------------------------------------------

int NEAR TV_UpdateShownIndexes(PTREE pTree, HTREEITEM hWalk)
{
    WORD iShownIndex;

    if (hWalk == pTree->hRoot) {
        hWalk = pTree->hRoot->hKids;
        if (hWalk) {
            hWalk->iShownIndex = 0;
        } else {
            return -1;
        }
    }

    iShownIndex = hWalk->iShownIndex + hWalk->iIntegral;
    if (iShownIndex <= 0)
    {
        // BUGBUG: We should #define the special TVITEM_HIDDEN value and check
        // for it explicitly
        // This can happen if TV_SortCB passes in a hidden item
        return(-1);
    }

    while ((hWalk = TV_GetNextVisItem(hWalk)) != NULL) {
        hWalk->iShownIndex = iShownIndex;
        iShownIndex += (WORD) hWalk->iIntegral;
    }

//#ifdef DEBUG
//      TraceMsg(TF_TREEVIEW, "tv: updated show indexes (now %d items)", (int)iShownIndex);
//#endif
    return (int)iShownIndex;
}

//
// in:
//      hItem   expanded node to count decendants of
//
// returns:
//      total number of expanded descendants below the given item.
//

UINT NEAR TV_CountVisibleDescendants(HTREEITEM hItem)
{
    UINT cnt;

    for (cnt = 0, hItem = hItem->hKids; hItem; hItem = hItem->hNext)
    {
        cnt += hItem->iIntegral;
        if (hItem->hKids && (hItem->state & TVIS_EXPANDED))
            cnt += TV_CountVisibleDescendants(hItem);
    }
    return cnt;
}

//  scrolls nItems in the direction of fDown starting from iTopShownIndex
void TV_ScrollItems(PTREE pTree, int nItems, int iTopShownIndex, BOOL fDown)
{
    RECT rc;
    rc.left = 0;
    rc.top = (iTopShownIndex+1) * pTree->cyItem;
    rc.right = pTree->cxWnd;
    rc.bottom = pTree->cyWnd;

    {
        SMOOTHSCROLLINFO si =
        {
            sizeof(si),
            SSIF_MINSCROLL | SSIF_MAXSCROLLTIME,
            pTree->ci.hwnd,
            0,
            ((fDown)?1:-1) * nItems * pTree->cyItem,
            &rc,
            &rc,
            NULL,
            NULL,
            SW_ERASE|SW_INVALIDATE,
            pTree->uMaxScrollTime,
            1,
            1
        };
        SmoothScrollWindow(&si);
    }
    TV_UpdateToolTip(pTree);
}

//
//  If fRedrawParent is FALSE, then the return value is garbage.
//  If fRedrawParent is TRUE, then returns the number of children scrolled.
//
//  Does not update iShownIndex for any items.
//
UINT NEAR TV_ScrollBelow(PTREE pTree, HTREEITEM hItem, BOOL fRedrawParent, BOOL fDown)
{
    int     iTop;
    UINT    cnt;

    // Do nothing if the item is not visible
    if (!ITEM_VISIBLE(hItem))
        return 0;
    
    cnt = hItem->iIntegral; // default return val
    if (pTree->fRedraw) {
        UINT cVisDesc;
        BOOL fEffect;

        // iTop is the top edge (client coordinates) of the bottom integral
        // cell of the item that just got expanded/contracted.
        // (Confused yet?  I sure am.)
        iTop = hItem->iShownIndex - pTree->hTop->iShownIndex + hItem->iIntegral - 1;
        cVisDesc = TV_CountVisibleDescendants(hItem);

        // See if the item being expanded/contracted has any effect on the
        // screen.  If not, then don't TV_ScrollItems or we will end up
        // double-counting them when we do post-scroll adjustment.
        if (fDown)
        {
            // When scrolling down, we have an effect if the item that just
            // got expanded was below the top of the screen
            fEffect = iTop >= 0;
        }
        else
        {
            // When scrolling up, we have an effect if any of the items
            // that just got collapsed out were below the top of the screen
            fEffect = (int)(iTop + cVisDesc) >= 0;
        }

        if (fEffect)
            TV_ScrollItems(pTree, cVisDesc, iTop, fDown);
        TV_InvalidateItem(pTree, hItem, TRUE);

        if (fRedrawParent)
            cnt = cVisDesc;

    } else {

        if (fRedrawParent)
            cnt = TV_CountVisibleDescendants(hItem);

    }

    return(cnt);
}

// The FakeCustomDraw functions are used when you want the customdraw client
// to set up a HDC so you can do stuff like GetTextExtent.
//
//  Usage:
//
//      TVFAKEDRAW tvfd;
//      TreeView_BeginFakeCustomDraw(pTree, &tvfd);
//      for each item you care about {
//          TreeView_BeginFakeItemDraw(&tvfd, hitem);
//          <party on the HDC in tvfd.nmcd.nmcd.hdc>
//          TreeView_EndFakeItemDraw(&tvfd);
//      }
//      TreeView_EndFakeCustomDraw(&tvfd);
//

void TreeView_BeginFakeCustomDraw(PTREE pTree, PTVFAKEDRAW ptvfd)
{
    ptvfd->nmcd.nmcd.hdc = GetDC(pTree->ci.hwnd);
    ptvfd->nmcd.nmcd.uItemState = 0;
    ptvfd->nmcd.nmcd.dwItemSpec = 0;
    ptvfd->nmcd.nmcd.lItemlParam = 0;
    ptvfd->hfontPrev = (HFONT)GetCurrentObject(ptvfd->nmcd.nmcd.hdc, OBJ_FONT);

    //
    //  Since we aren't actually painting anything, we pass an empty
    //  paint rectangle.  Gosh, I hope no app faults when it sees an
    //  empty paint rectangle.
    //
    SetRectEmpty(&ptvfd->nmcd.nmcd.rc);

    ptvfd->pTree = pTree;
    ptvfd->dwCustomPrev = pTree->ci.dwCustom;

    pTree->ci.dwCustom = CIFakeCustomDrawNotify(&pTree->ci, CDDS_PREPAINT, &ptvfd->nmcd.nmcd);
}

DWORD TreeView_BeginFakeItemDraw(PTVFAKEDRAW ptvfd, HTREEITEM hitem)
{
    PTREE pTree = ptvfd->pTree;

    // Note that if the client says CDRF_SKIPDEFAULT (i.e., is owner-draw)
    // we measure the item anyway, because that's what IE4 did.

    ptvfd->nmcd.nmcd.dwItemSpec = (DWORD_PTR)hitem;
    ptvfd->nmcd.nmcd.lItemlParam = hitem->lParam;

    if (hitem->state & TVIS_BOLD) {
        SelectFont(ptvfd->nmcd.nmcd.hdc, pTree->hFontBold);
    } else {
        SelectFont(ptvfd->nmcd.nmcd.hdc, pTree->hFont);
    }

    if (!(pTree->ci.dwCustom & CDRF_SKIPDEFAULT)) {
        // Font should not depend on colors or flags since those change
        // dynamically but we cache the width info forever.  So we don't
        // need to set up uItemState.
        ptvfd->nmcd.clrText = pTree->clrText;
        ptvfd->nmcd.clrTextBk = pTree->clrBk;
        ptvfd->nmcd.iLevel = hitem->iLevel;
        ptvfd->dwCustomItem = CIFakeCustomDrawNotify(&pTree->ci, CDDS_ITEMPREPAINT, &ptvfd->nmcd.nmcd);
    } else {
        ptvfd->dwCustomItem = CDRF_DODEFAULT;
    }

    return ptvfd->dwCustomItem;
}

void TreeView_EndFakeItemDraw(PTVFAKEDRAW ptvfd)
{
    PTREE pTree = ptvfd->pTree;

    if (!(ptvfd->dwCustomItem & CDRF_SKIPDEFAULT) &&
         (ptvfd->dwCustomItem & CDRF_NOTIFYPOSTPAINT)) {
        CIFakeCustomDrawNotify(&pTree->ci, CDDS_ITEMPOSTPAINT, &ptvfd->nmcd.nmcd);
    }
}

void TreeView_EndFakeCustomDraw(PTVFAKEDRAW ptvfd)
{
    PTREE pTree = ptvfd->pTree;

    // notify parent afterwards if they want us to
    if (!(pTree->ci.dwCustom & CDRF_SKIPDEFAULT) &&
        pTree->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
        CIFakeCustomDrawNotify(&pTree->ci, CDDS_POSTPAINT, &ptvfd->nmcd.nmcd);
    }

    // Restore previous state
    pTree->ci.dwCustom = ptvfd->dwCustomPrev;
    SelectObject(ptvfd->nmcd.nmcd.hdc, ptvfd->hfontPrev);
    ReleaseDC(pTree->ci.hwnd, ptvfd->nmcd.nmcd.hdc);
}


// ----------------------------------------------------------------------------
//
//  Returns the width of the widest shown item in the tree
//
// ----------------------------------------------------------------------------

UINT NEAR TV_RecomputeMaxWidth(PTREE pTree)
{
    if (!(pTree->ci.style & TVS_NOSCROLL)) {
        HTREEITEM hItem;
        WORD wMax = 0;

        // REVIEW: this might not be the most efficient traversal of the tree

        for (hItem = pTree->hRoot->hKids; hItem; hItem = TV_GetNextVisItem(hItem))
        {
            if (wMax < FULL_WIDTH(pTree, hItem))
                wMax = FULL_WIDTH(pTree, hItem);
        }

        return((UINT)wMax);
    } else {
        return pTree->cxWnd;
    }
}


// ----------------------------------------------------------------------------
//
//  Returns the horizontal text extent of the given item's text
//
// ----------------------------------------------------------------------------

WORD NEAR TV_GetItemTextWidth(HDC hdc, PTREE pTree, HTREEITEM hItem)
{
    TVITEMEX sItem;
    TCHAR szTemp[MAX_PATH];
    SIZE size = {0,0};

    sItem.pszText = szTemp;
    sItem.cchTextMax = ARRAYSIZE(szTemp);

    TV_GetItem(pTree, hItem, TVIF_TEXT, &sItem);

    GetTextExtentPoint(hdc, sItem.pszText, lstrlen(sItem.pszText), &size);
    return (WORD)(size.cx + (g_cxLabelMargin * 2));
}


// ----------------------------------------------------------------------------
//
//  Compute the text extent and the full width (indent, image, and text) of
//  the given item.
//
//  If there is a HDC, then we assume that the HDC has been set up with
//  the proper attributes (specifically, the font).  If there is no HDC,
//  then we will set one up, measure the text, then tear it down.
//  If you will be measuring more than one item, it is recommended that
//  the caller set up the HDC and keep re-using it, because creating,
//  initializing, then destroy the HDC is rather slow.
//
// ----------------------------------------------------------------------------

void NEAR TV_ComputeItemWidth(PTREE pTree, HTREEITEM hItem, HDC hdc)
{
    TVFAKEDRAW  tvfd;                    // in case client uses customdraw
    int iOldWidth = hItem->iWidth;

    if (hdc == NULL) {
        TreeView_BeginFakeCustomDraw(pTree, &tvfd);
        TreeView_BeginFakeItemDraw(&tvfd, hItem);
    }
    else
    {
        tvfd.nmcd.nmcd.hdc = hdc;
    }
    
    hItem->iWidth = TV_GetItemTextWidth(tvfd.nmcd.nmcd.hdc, pTree, hItem);

    if (!(pTree->ci.style & TVS_NOSCROLL) && iOldWidth != hItem->iWidth)
        if (pTree->cxMax < FULL_WIDTH(pTree, hItem)) {
            PostMessage(pTree->ci.hwnd, TVMP_CALCSCROLLBARS, 0, 0);
            pTree->cxMax = FULL_WIDTH(pTree, hItem);
        }
    
    if (hdc == NULL)
    {
        TreeView_EndFakeItemDraw(&tvfd);
        TreeView_EndFakeCustomDraw(&tvfd);
    }
}


// ----------------------------------------------------------------------------
//
//  Returns TRUE if the item is expanded, FALSE otherwise
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_IsShowing(HTREEITEM hItem)
{
    for (hItem = hItem->hParent; hItem; hItem = hItem->hParent)
        if (!(hItem->state & TVIS_EXPANDED))
            return FALSE;

    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  If the added item is showing, update the shown (expanded) count, the max
//  item width -- then recompute the scroll bars.
//
//  sets cxMax, cShowing
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollBarsAfterAdd(PTREE pTree, HTREEITEM hItem)
{
    HTREEITEM   hPrev;

    if (!TV_IsShowing(hItem))
    {
        // item isn't visible -- set index to NOTVISIBLE and return
        hItem->iShownIndex = (WORD)-1;
        return FALSE;
    }

    hPrev = TV_GetPrevVisItem(hItem);

    // increment every shown index after newly added item

    hItem->iShownIndex = (hPrev) ? hPrev->iShownIndex + hPrev->iIntegral : 0;

    TV_UpdateShownIndexes(pTree, hItem);

    pTree->cShowing += hItem->iIntegral;

    TV_ComputeItemWidth(pTree, hItem, NULL);

    TV_CalcScrollBars(pTree);
    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  If the removed item was showing, update the shown (expanded) count, the max
//  item width -- then recompute the scroll bars.
//
//  sets cxMax, cShowing
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollBarsAfterRemove(PTREE pTree, HTREEITEM hItem)
{
    HTREEITEM hWalk;
    if (!ITEM_VISIBLE(hItem))
        return FALSE;

    // decrement every shown index after removed item
    hItem->iShownIndex = (WORD)-1;

    hWalk = TV_GetNextVisItem(hItem);
    if (hWalk) {
        hWalk->iShownIndex -= (WORD) hItem->iIntegral;
        TV_UpdateShownIndexes(pTree, hWalk);

        // If we delete the top item, the tree scrolls to the end, so ...
        if (pTree->hTop == hItem) {
            TV_SetTopItem(pTree, hWalk->iShownIndex);
            ASSERT(pTree->hTop != hItem);
        }
    }

    pTree->cShowing -= hItem->iIntegral;

    if (pTree->fRedraw) {
        if (!hItem->iWidth)
            TV_ComputeItemWidth(pTree, hItem, NULL);


        if (!(pTree->ci.style & TVS_NOSCROLL))
            if (pTree->cxMax == FULL_WIDTH(pTree, hItem))
                pTree->cxMax = (WORD) TV_RecomputeMaxWidth(pTree);

        TV_CalcScrollBars(pTree);
    }
    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  Common worker function for
//  TV_ScrollBarsAfterExpand and TV_ScrollBarsAfterCollapse, since they
//  are completely identical save for two lines of code.
//
//  If the expanded items are / collapsed items were showing, update
//  the shown (expanded) count, the max item width -- then recompute
//  the scroll bars.
//
// ----------------------------------------------------------------------------

#define SBAEC_COLLAPSE  0
#define SBAEC_EXPAND    1

BOOL NEAR TV_ScrollBarsAfterExpandCollapse(PTREE pTree, HTREEITEM hParent, UINT flags)
{
    WORD cxMax = 0;
    HTREEITEM hWalk;
    TVFAKEDRAW tvfd;

    if (!ITEM_VISIBLE(hParent))
        return FALSE;

    //
    // We're going to be measuring a lot of items, so let's set up
    // our DC ahead of time.
    //
    TreeView_BeginFakeCustomDraw(pTree, &tvfd);

    for (hWalk = hParent->hKids;
         hWalk && (hWalk->iLevel > hParent->iLevel);
         hWalk = TV_GetNextVisItem(hWalk))
    {
         if (flags == SBAEC_COLLAPSE)
            hWalk->iShownIndex = (WORD)-1;
         if (!hWalk->iWidth)
         {
            TreeView_BeginFakeItemDraw(&tvfd, hWalk);
            TV_ComputeItemWidth(pTree, hWalk, tvfd.nmcd.nmcd.hdc);
            TreeView_EndFakeItemDraw(&tvfd);
         }
         if (cxMax < FULL_WIDTH(pTree, hWalk))
             cxMax = FULL_WIDTH(pTree, hWalk);
    }

    TreeView_EndFakeCustomDraw(&tvfd);

    // update every shown index after expanded parent
    pTree->cShowing = TV_UpdateShownIndexes(pTree, hParent);

    // Update the pTree->cxMax if it is affected by the items we
    // expanded/collapsed.

    if (!(pTree->ci.style & TVS_NOSCROLL))
    {
        if (flags == SBAEC_COLLAPSE)
        {
            // If one of our newly-hidden items was responsible for
            // the width being what it is, recompute the max width
            // since we hid those items.
            if (cxMax == pTree->cxMax)
                pTree->cxMax = (WORD) TV_RecomputeMaxWidth(pTree);
        }
        else
        {
            // If one of our newly-shown items was responsible is wider
            // then the previous max, then we have set a new max.
            if (cxMax > pTree->cxMax)
                pTree->cxMax = cxMax;
        }
    }

    TV_CalcScrollBars(pTree);
    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  If the expanded items are showing, update the shown (expanded) count,
//  the max item width -- then recompute the scroll bars.
//
//  sets cxMax, cShowing
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollBarsAfterExpand(PTREE pTree, HTREEITEM hParent)
{
    return TV_ScrollBarsAfterExpandCollapse(pTree, hParent, SBAEC_EXPAND);
}


// ----------------------------------------------------------------------------
//
//  If the collapsed items were showing, update the shown (expanded) count,
//  the max item width -- then recompute the scroll bars.
//
//  sets cxMax, cShowing
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollBarsAfterCollapse(PTREE pTree, HTREEITEM hParent)
{
    return TV_ScrollBarsAfterExpandCollapse(pTree, hParent, SBAEC_COLLAPSE);
}

// ----------------------------------------------------------------------------
//
//  If the added item changed height, then scroll thing around,
//  update the shown (expanded) count, recompute the scroll bars.
//
//  sets cShowing
//
// ----------------------------------------------------------------------------

void NEAR TV_ScrollBarsAfterResize(PTREE pTree, HTREEITEM hItem, int iIntegralPrev, UINT uRDWFlags)
{
    int iMaxIntegral = max(hItem->iIntegral, iIntegralPrev);

    ASSERT(hItem->iIntegral != iIntegralPrev);

    if (pTree->fRedraw)
    {
        int iTop = hItem->iShownIndex - pTree->hTop->iShownIndex +
                    iMaxIntegral - 1;
        if (iTop >= 0)
        {
            int iGrowth = hItem->iIntegral - iIntegralPrev;
            TV_ScrollItems(pTree, abs(iGrowth), iTop, iGrowth > 0);
        }
    }

    // update every shown index after resized item
    pTree->cShowing = TV_UpdateShownIndexes(pTree, hItem);
    TV_CalcScrollBars(pTree);

    // Invalidate based on the worst-case height so we handle
    // both the grow and shrink cases.
    if (pTree->fRedraw)
    {
        RECT rc;
        if (TV_GetItemRect(pTree, hItem, &rc, FALSE))
        {
            rc.bottom = rc.top + pTree->cyItem * iMaxIntegral;
            RedrawWindow(pTree->ci.hwnd, &rc, NULL, uRDWFlags);
        }
    }
}



// ----------------------------------------------------------------------------
//
//  Returns the item just below the given item in the tree.
//
// ----------------------------------------------------------------------------

TREEITEM FAR * NEAR TV_GetNext(TREEITEM FAR * hItem)
{
    DBG_ValidateTreeItem(hItem, FALSE);

    if (hItem->hKids)
        return hItem->hKids;

checkNext:
    if (hItem->hNext)
        return hItem->hNext;

    hItem = hItem->hParent;
    if (hItem)
        goto checkNext;

    return NULL;
}


// ----------------------------------------------------------------------------
//
//  Go through all the items in the tree, recomputing each item's text extent
//  and full width (indent, image, and text).
//
// ----------------------------------------------------------------------------

void NEAR TV_RecomputeItemWidths(PTREE pTree)
{
    HTREEITEM hItem;
    TVFAKEDRAW tvfd;

    TreeView_BeginFakeCustomDraw(pTree, &tvfd);

    hItem = pTree->hRoot->hKids;
    while (hItem)
    {
        TreeView_BeginFakeItemDraw(&tvfd, hItem);
        TV_ComputeItemWidth(pTree, hItem, tvfd.nmcd.nmcd.hdc);
        TreeView_EndFakeItemDraw(&tvfd);
        hItem = TV_GetNext(hItem);
    }
    TreeView_EndFakeCustomDraw(&tvfd);
}


// ----------------------------------------------------------------------------
//
//  If a single item's width changed, alter the max width if needed.
//  If all widths changed, recompute widths and max width.
//  Then recompute the scroll bars.
//
//  sets cxMax
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollBarsAfterSetWidth(PTREE pTree, HTREEITEM hItem)
{
    if (hItem)
    {
        UINT iOldWidth = FULL_WIDTH(pTree, hItem);
        TV_ComputeItemWidth(pTree, hItem, NULL);

        if (!(pTree->ci.style & TVS_NOSCROLL)) {
            if (pTree->cxMax == iOldWidth)
                pTree->cxMax = (WORD) TV_RecomputeMaxWidth(pTree);
            else
                return(FALSE);
        }
    }
    else
    {
        TV_RecomputeItemWidths(pTree);
        pTree->cxMax = (WORD) TV_RecomputeMaxWidth(pTree);
    }

    TV_CalcScrollBars(pTree);
    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  Scroll window vertically as needed to make given item fully visible
//  vertically
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollVertIntoView(PTREE pTree, HTREEITEM hItem)
{
    // This function has crashed in stress before, so we need to assert the incoming parameters.
    ASSERT(hItem);
    ASSERT(pTree && pTree->hTop);

    // Do nothing if the parameters are invalid
    if (!hItem || !pTree || !(pTree->hTop))
        return FALSE;

    // Do nothing if this item is not visible
    if (!ITEM_VISIBLE(hItem))
        return FALSE;

    if (hItem->iShownIndex < pTree->hTop->iShownIndex)
        return(TV_SetTopItem(pTree, hItem->iShownIndex));

    if (hItem->iShownIndex >= (pTree->hTop->iShownIndex + pTree->cFullVisible))
        return(TV_SetTopItem(pTree, hItem->iShownIndex + 1 - pTree->cFullVisible));

    return FALSE;
}


// ----------------------------------------------------------------------------
//
//  Scroll window vertically and horizontally as needed to make given item
//  fully visible vertically and horizontally
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollIntoView(PTREE pTree, HTREEITEM hItem)
{
    UINT iWidth, iOffset;
    BOOL fChange;

    fChange = TV_ScrollVertIntoView(pTree, hItem);

    // ensure that item's text is fully visible horizontally
    iWidth = pTree->cxImage + pTree->cxState + hItem->iWidth;
    if (iWidth > (UINT)pTree->cxWnd)
        iWidth = pTree->cxWnd; //hItem->iWidth;

    iOffset = ITEM_OFFSET(pTree, hItem);

    if ((int) (iOffset) < pTree->xPos)
        fChange |= TV_SetLeft(pTree, iOffset);
    else if ((iOffset + iWidth) > (UINT)(pTree->xPos + pTree->cxWnd))
        fChange |= TV_SetLeft(pTree, iOffset + iWidth - pTree->cxWnd);

    return fChange;
}


// ----------------------------------------------------------------------------
//
//  Sets position of horizontal scroll bar and scrolls window to match that
//  position
//
//  sets xPos
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SetLeft(PTREE pTree, int x)
{
    if (!pTree->fHorz || pTree->ci.style & (TVS_NOSCROLL | TVS_NOHSCROLL))
        return(FALSE);

    if (x > (int) (pTree->cxMax - pTree->cxWnd))
        x = (pTree->cxMax - pTree->cxWnd);
    if (x < 0)
        x = 0;

    if (x == pTree->xPos)
        return(FALSE);

    if (pTree->fRedraw) {
        SMOOTHSCROLLINFO si =
        {
            sizeof(si),
            SSIF_MINSCROLL | SSIF_MAXSCROLLTIME,
            pTree->ci.hwnd,
            pTree->xPos - x,
            0,
            NULL,
            NULL,
            NULL,
            NULL,
            SW_INVALIDATE | SW_ERASE,
            pTree->uMaxScrollTime,
            1,
            1
        };
        SmoothScrollWindow(&si);
    }

    pTree->xPos = (SHORT) x;

    SetScrollPos(pTree->ci.hwnd, SB_HORZ, x, TRUE);
    TV_UpdateToolTip(pTree);

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  Returns the tree's item that has the given shown index, NULL if no item
//  found with that index.
//
// ----------------------------------------------------------------------------

HTREEITEM NEAR TV_GetShownIndexItem(HTREEITEM hItem, UINT wShownIndex)
{
    HTREEITEM hWalk;

    if (hItem == NULL)
        return NULL;

    ASSERT((int)wShownIndex >= 0);

    for (hWalk = hItem;
         hWalk && (hWalk->iShownIndex <= wShownIndex);
         hWalk = hWalk->hNext) {
        
         hItem = hWalk;
         
         if (hWalk->iShownIndex + (UINT)hWalk->iIntegral > wShownIndex) 
             return hWalk;
    }

    return TV_GetShownIndexItem(hItem->hKids, wShownIndex);
}


// ----------------------------------------------------------------------------
//
//  Sets position of vertical scroll bar and scrolls window to match that
//  position
//
//  sets hTop
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SmoothSetTopItem(PTREE pTree, UINT wNewTop, UINT uSmooth)
{
    HTREEITEM hItem = pTree->hRoot->hKids;
    UINT wOldTop;

    if (!hItem)
        return FALSE;
    
    if ((pTree->ci.style & TVS_NOSCROLL) || (wNewTop == (UINT)-1) || (pTree->cShowing <= pTree->cFullVisible)) {
        // we've wrapped around (treat as a negative index) -- use min pos
        // or there aren't enough items to scroll
        wNewTop = 0;
    } else if (wNewTop > (UINT)(pTree->cShowing - pTree->cFullVisible)) {
        // we've gone too far down -- use max pos
        wNewTop = (pTree->cShowing - pTree->cFullVisible);

    }

    // if there's no room for anything to show. peg at the end
    if (wNewTop > 0 && wNewTop >= pTree->cShowing) {
        wNewTop = pTree->cShowing - 1;
    }

    hItem = TV_GetShownIndexItem(hItem, wNewTop);

    if (NULL == hItem || pTree->hTop == hItem)
        return FALSE;
    // need to refetch because wNewTop couldhave pointed to the middle of this item,
    // which is not allowed
    wNewTop = hItem->iShownIndex;
    
    wOldTop = pTree->hTop->iShownIndex;

    pTree->hTop = hItem;

    if (pTree->fRedraw) {
        SMOOTHSCROLLINFO si =
        {
            sizeof(si),
            SSIF_MINSCROLL | SSIF_MAXSCROLLTIME,
            pTree->ci.hwnd,
            0,
            (int) (wOldTop - wNewTop) * (int) pTree->cyItem,
            NULL,
            NULL,
            NULL,
            NULL,
            SW_INVALIDATE | SW_ERASE | uSmooth,
            pTree->uMaxScrollTime,
            1,
            1
        };
        SmoothScrollWindow(&si);
    }

    SetScrollPos(pTree->ci.hwnd, SB_VERT, wNewTop, TRUE);
    TV_UpdateToolTip(pTree);

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  Computes the horizontal and vertical scroll bar ranges, pages, and
//  positions, adding or removing the scroll bars as needed.
//
//  sets fHorz, fVert
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_CalcScrollBars(PTREE pTree)
{
    // UINT wMaxPos;
    BOOL fChange = FALSE;
    SCROLLINFO si;
    
    if (pTree->ci.style & TVS_NOSCROLL)
        return FALSE;

    si.cbSize = sizeof(SCROLLINFO);

    if (!(pTree->ci.style & TVS_NOHSCROLL))
    {
        if ((SHORT)pTree->cxMax > (SHORT)pTree->cxWnd)
        {
            if (!pTree->fHorz)
            {
                fChange = TRUE;
                pTree->fHorz = TRUE;
            }

            si.fMask = SIF_PAGE | SIF_RANGE;
            si.nMin = 0;
            si.nMax = pTree->cxMax - 1;
            si.nPage = pTree->cxWnd;

            TV_SetLeft(pTree, (UINT)SetScrollInfo(pTree->ci.hwnd, SB_HORZ, &si, TRUE));
        }
        else if (pTree->fHorz)
        {
            TV_SetLeft(pTree, 0);
            SetScrollRange(pTree->ci.hwnd, SB_HORZ, 0, 0, TRUE);

            pTree->fHorz = FALSE;
            fChange = TRUE;
        }
    }

    if (pTree->cShowing > pTree->cFullVisible)
    {
        if (!pTree->fVert)
        {
            pTree->fVert = TRUE;
            fChange = TRUE;
        }

        si.fMask = SIF_PAGE | SIF_RANGE;
        si.nMin = 0;
        si.nMax = pTree->cShowing - 1;
        si.nPage = pTree->cFullVisible;

        TV_SetTopItem(pTree, (UINT)SetScrollInfo(pTree->ci.hwnd, SB_VERT, &si, TRUE));

    }
    else if (pTree->fVert)
    {
        TV_SetTopItem(pTree, 0);
        SetScrollRange(pTree->ci.hwnd, SB_VERT, 0, 0, TRUE);

        pTree->fVert = FALSE;
        fChange = TRUE;
    }

    if (fChange)
        TV_SizeWnd(pTree, 0, 0);

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  Handles horizontal scrolling.
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_HorzScroll(PTREE pTree, UINT wCode, UINT wNewPos)
{
    BOOL fChanged;

    TV_DismissEdit(pTree, FALSE);

    switch (wCode)
    {
        case SB_BOTTOM:
            wNewPos = pTree->cxMax - pTree->cxWnd;
            break;

        case SB_ENDSCROLL:
            wNewPos = pTree->xPos;
            break;

        case SB_LINEDOWN:
            wNewPos = pTree->xPos + MAGIC_HORZLINE;
            break;

        case SB_LINEUP:
            wNewPos = pTree->xPos - MAGIC_HORZLINE;
            break;

        case SB_PAGEDOWN:
            wNewPos = pTree->xPos + (pTree->cxWnd - MAGIC_HORZLINE);
            break;

        case SB_PAGEUP:
            wNewPos = pTree->xPos - (pTree->cxWnd - MAGIC_HORZLINE);
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            break;

        case SB_TOP:
            wNewPos = 0;
            break;
    }

    if (fChanged = TV_SetLeft(pTree, wNewPos))
        UpdateWindow(pTree->ci.hwnd);

    return(fChanged);
}


// ----------------------------------------------------------------------------
//
//  Handles vertical scrolling.
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_VertScroll(PTREE pTree, UINT wCode, UINT wPos)
{
    UINT wNewPos = 0;
    UINT wOldPos;
    BOOL fChanged;
    UINT uSmooth = 0;

    if (!pTree->hTop)
        return FALSE;
    
    wOldPos = pTree->hTop->iShownIndex;
    TV_DismissEdit(pTree, FALSE);

    switch (wCode)
    {
        case SB_BOTTOM:
            wNewPos = pTree->cShowing - pTree->cFullVisible;
            break;

        case SB_ENDSCROLL:
            wNewPos = wOldPos;
            break;

        case SB_LINEDOWN:
            wNewPos = wOldPos + pTree->hTop->iIntegral;
            break;

        case SB_LINEUP:
            wNewPos = wOldPos - 1;
            if (wNewPos > wOldPos)
                wNewPos = 0;
            break;

        case SB_PAGEDOWN:
            wNewPos = wOldPos + (pTree->cFullVisible - 1);
            break;

        case SB_PAGEUP:
            wNewPos = wOldPos - (pTree->cFullVisible - 1);
            if (wNewPos > wOldPos)
                wNewPos = 0;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            uSmooth = SSW_EX_IMMEDIATE;
            wNewPos = wPos;
            break;

        case SB_TOP:
            wNewPos = 0;
            break;
    }

    if (fChanged = TV_SmoothSetTopItem(pTree, wNewPos, uSmooth))
        UpdateWindow(pTree->ci.hwnd);
    return(fChanged);
}


#ifdef DEBUG
static int nCompares;
#endif

typedef struct {
    LPTSTR lpstr;
    BOOL bCallBack;
    HTREEITEM hItem;
} TVCOMPARE, FAR *LPTVCOMPARE;

// Pointer comparision function for Sort and Search functions.
// lParam is lParam passed to sort/search functions.  Returns
// -1 if p1 < p2, 0 if p1 == p2, and 1 if p1 > p2.
//
int CALLBACK TV_DefCompare(LPTVCOMPARE sCmp1, LPTVCOMPARE sCmp2, LPARAM lParam)
{
#ifdef DEBUG
        ++nCompares;
#endif

        return lstrcmpi(sCmp1->lpstr, sCmp2->lpstr);
}


int CALLBACK TV_CompareItems(LPTVCOMPARE sCmp1, LPTVCOMPARE sCmp2, LPARAM lParam)
{
        TV_SORTCB FAR *pSortCB = (TV_SORTCB FAR *)lParam;
#ifdef DEBUG
        ++nCompares;
#endif

        return(pSortCB->lpfnCompare(sCmp1->hItem->lParam, sCmp2->hItem->lParam,
                pSortCB->lParam));
}


UINT NEAR TV_CountKids(HTREEITEM hItem)
{
    int cnt;

    for (cnt = 0, hItem = hItem->hKids; hItem; hItem = hItem->hNext)
        cnt++;

    return cnt;
}


// BUGBUG: bRecurse not implemented

BOOL PASCAL TV_SortCB(PTREE pTree, TV_SORTCB FAR *pSortCB, BOOL bRecurse,
        PFNDPACOMPARE lpfnDPACompare)
{
        HDPA dpaSort;
        HDSA dsaCmp;
        HTREEITEM hItem, hNext, hFirstMoved;
        LPTVCOMPARE psCompare, FAR *ppsCompare;
        int i, cKids;
        HTREEITEM hParent = pSortCB->hParent;

#ifdef DEBUG
        DWORD dwTime = GetTickCount();
        nCompares = 0;
#endif

        if (!hParent || hParent == TVI_ROOT)
            hParent = pTree->hRoot;

        if (!ValidateTreeItem(hParent, FALSE))
            return FALSE;               // Invalid parameter

        // Code below assumes at least one kid
        cKids = TV_CountKids(hParent);
        if (!cKids)
            return FALSE;

        // Create a DSA for all the extra info we'll need
        dsaCmp = DSA_Create(sizeof(TVCOMPARE), cKids);
        if (!dsaCmp)
            goto Error1;

        // Create a DPA containing all the tree items
        dpaSort = DPA_Create(cKids);
        if (!dpaSort)
            goto Error2;

        for (hItem = hParent->hKids; hItem; hItem = hItem->hNext)
        {
                TVCOMPARE sCompare;
                int nItem;

                // If I can't sort all of them, I don't want to sort any of them

                // We want to cache the text callback for default processing
                if (!lpfnDPACompare && hItem->lpstr==LPSTR_TEXTCALLBACK)
                {
                        TVITEMEX sItem;
                        TCHAR szTemp[MAX_PATH];

                        sItem.pszText = szTemp;
                        sItem.cchTextMax  = ARRAYSIZE(szTemp);
                        TV_GetItem(pTree, hItem, TVIF_TEXT, &sItem);

                        sCompare.lpstr = NULL;
                        sCompare.bCallBack = TRUE;
                        Str_Set(&sCompare.lpstr, sItem.pszText);
                        if (!sCompare.lpstr)
                        {
                                goto Error3;
                        }
                }
                else
                {
                        sCompare.lpstr = hItem->lpstr;
                        sCompare.bCallBack = FALSE;
                }

                // Create the pointer for this guy and add it to the DPA list
                sCompare.hItem = hItem;
                nItem = DSA_AppendItem(dsaCmp, &sCompare);
                if (nItem < 0)
                {
                        if (sCompare.bCallBack)
                        {
                                Str_Set(&sCompare.lpstr, NULL);
                        }
                        goto Error3;
                }

                if (DPA_AppendPtr(dpaSort, DSA_GetItemPtr(dsaCmp, nItem)) < 0)
                {
                        goto Error3;
                }
        }

        // Sort the DPA, then stick them back under the parent in the new order
        DPA_Sort(dpaSort, lpfnDPACompare ? (PFNDPACOMPARE)lpfnDPACompare :
                 (PFNDPACOMPARE) TV_DefCompare, (LPARAM)pSortCB);


        // Look for the first moved item, so we can invalidate a smaller area
        ppsCompare = (LPTVCOMPARE FAR *)DPA_GetPtrPtr(dpaSort);
        if (hParent->hKids != (*ppsCompare)->hItem)
        {
                hParent->hKids = (*ppsCompare)->hItem;
                hFirstMoved = hParent->hKids;
        }
        else
        {
                hFirstMoved = NULL;
        }

        // We do n-1 iterations here
        for (i = DPA_GetPtrCount(dpaSort) - 1; i > 0; --i, ++ppsCompare)
        {
                hNext = (*(ppsCompare+1))->hItem;
                if ((*ppsCompare)->hItem->hNext != hNext && !hFirstMoved)
                {
                        hFirstMoved = hNext;
                }
                (*ppsCompare)->hItem->hNext = hNext;
        }
        (*ppsCompare)->hItem->hNext = NULL;

        TV_UpdateShownIndexes(pTree, hParent);
        if ((pSortCB->hParent == TVI_ROOT) || !hParent) {
            if (pTree->cShowing < pTree->cFullVisible) {
                pTree->hTop = pTree->hRoot->hKids;
            }
        }

        if (hFirstMoved && (hParent->state & TVIS_EXPANDED))
        {
                RECT rcUpdate;

                TV_GetItemRect(pTree, hFirstMoved, &rcUpdate, FALSE);
                if (hParent->hNext)
                {
                        RECT rcTemp;

                        TV_GetItemRect(pTree, hParent->hNext, &rcTemp, FALSE);
                        rcUpdate.bottom = rcTemp.bottom;
                }
                else
                {
                        RECT rcClient;
                        GetClientRect(pTree->ci.hwnd, &rcClient);
                        // Set to maximal positive number, so the whole rest of
                        // the treeview gets invalidated
                        rcUpdate.bottom = rcClient.bottom;
                }
                if (pTree->fRedraw)
                    InvalidateRect(pTree->ci.hwnd, &rcUpdate, TRUE);
        }

Error3:
        DPA_Destroy(dpaSort);
Error2:
        for (i = DSA_GetItemCount(dsaCmp) - 1; i >= 0; --i)
        {
                psCompare = DSA_GetItemPtr(dsaCmp, i);
                if (psCompare->bCallBack)
                {
                        Str_Set(&(psCompare->lpstr), NULL);
                }
        }
        DSA_Destroy(dsaCmp);
Error1:

#ifdef DEBUG
        TraceMsg(TF_TREEVIEW, "tv.sort: %ld ms; %d cmps", GetTickCount()-dwTime, nCompares);
#endif

    {
        int wNewPos;
        // restore the scroll position
        if (GetWindowStyle(pTree->ci.hwnd) & WS_VSCROLL) {
            SCROLLINFO si;

            si.cbSize = sizeof(SCROLLINFO);
            si.fMask = SIF_POS;
            wNewPos = 0;
            if (GetScrollInfo(pTree->ci.hwnd, SB_VERT, &si)) {
                wNewPos = si.nPos;
            }

        } else {
            wNewPos = 0;
        }

        if (TV_SetTopItem(pTree, wNewPos))
            UpdateWindow(pTree->ci.hwnd);
    }

    // if the caret is the child of the thing that was sorted, make sure it's
    // visible (but if we're sorting something completely unrelated, don't bother
    if (pTree->hCaret) {
        hItem = pTree->hCaret;
        do {
            // do this first.  if hParent is hCaret, we don't want to ensure visible...
            // only if it's an eventual child
            hItem = hItem->hParent;
            if (hParent == hItem) {
                TV_EnsureVisible(pTree, pTree->hCaret);
            }
        } while(hItem && hItem != pTree->hRoot);
    }

    // The items in the view may have moved around; let apps know
    // Do this last because this call might yield
    MyNotifyWinEvent(EVENT_OBJECT_REORDER, pTree->ci.hwnd, OBJID_CLIENT, 0);

    return TRUE;
}


BOOL NEAR TV_SortChildrenCB(PTREE pTree, LPTV_SORTCB pSortCB, BOOL bRecurse)
{
        return(TV_SortCB(pTree, pSortCB, bRecurse, (PFNDPACOMPARE)TV_CompareItems));
}


BOOL NEAR TV_SortChildren(PTREE pTree, HTREEITEM hParent, BOOL bRecurse)
{
        TV_SORTCB sSortCB;

        sSortCB.hParent = hParent;
        return(TV_SortCB(pTree, &sSortCB, bRecurse, NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\multilingual\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\tvpaint.c ===
#include "ctlspriv.h"
#include "treeview.h"
#include "image.h"

extern void  TruncateString(char *sz, int cch);

void NEAR TV_GetBackgroundBrush(PTREE pTree, HDC hdc)
{
    if (pTree->clrBk == (COLORREF)-1) {
        if (pTree->ci.style & WS_DISABLED)
            pTree->hbrBk = FORWARD_WM_CTLCOLORSTATIC(pTree->ci.hwndParent, hdc, pTree->ci.hwnd, SendMessage);
        else
            pTree->hbrBk = FORWARD_WM_CTLCOLOREDIT(pTree->ci.hwndParent, hdc, pTree->ci.hwnd, SendMessage);
    }
}

// ----------------------------------------------------------------------------
//
//  Draws a horizontal or vertical dotted line from the given (x,y) location
//  for the given length (c).
//
// ----------------------------------------------------------------------------

void NEAR TV_DrawDottedLine(HDC hdc, int x, int y, int c, BOOL fVert)
{
    while (c > 0)
    {
        PatBlt(hdc, x, y, 1, 1, PATCOPY);
        if (fVert)
            y += 2;
        else
            x += 2;
        c -= 2;
    }
}


// ----------------------------------------------------------------------------
//
//  Draws a plus or minus sign centered around the given (x,y) location and
//  extending out from that location the given distance (c).
//
// ----------------------------------------------------------------------------

void NEAR TV_DrawPlusMinus(HDC hdc, int x, int y, int c, HBRUSH hbrSign, HBRUSH hbrBox, HBRUSH hbrBk, BOOL fPlus)
{
    int n;
    int p = (c * 7) / 10;
    
    n = p * 2 + 1;
    
    SelectObject(hdc, hbrSign);
    
    if (p >= 5)
    {
        PatBlt(hdc, x - p, y - 1, n, 3, PATCOPY);
        if (fPlus)
            PatBlt(hdc, x - 1, y - p, 3, n, PATCOPY);
        
        SelectObject(hdc, hbrBk);
        p--;
        n -= 2;
    }
    
    PatBlt(hdc, x - p, y, n, 1, PATCOPY);
    if (fPlus)
        PatBlt(hdc, x, y - p, 1, n, PATCOPY);
    
    n = c * 2 + 1;
    
    SelectObject(hdc, hbrBox);
    
    PatBlt(hdc, x - c, y - c, n, 1, PATCOPY);
    PatBlt(hdc, x - c, y - c, 1, n, PATCOPY);
    PatBlt(hdc, x - c, y + c, n, 1, PATCOPY);
    PatBlt(hdc, x + c, y - c, 1, n, PATCOPY);
}


// ----------------------------------------------------------------------------
//
//  Create the bitmaps for the indent area of the tree as follows
//  if  fHasLines &&  fHasButtons --> 7 bitmaps
//  if  fHasLines && !fHasButtons --> 3 bitmaps
//  if !fHasLines &&  fHasButtons --> 2 bitmaps
//
//  sets hStartBmp, hBmp, hdcBits
//
//  If "has lines" then there are three basic bitmaps.
//
//      |       |       |
//      |       +---    +---
//      |       |
//
//  (The plan vertical line does not get buttons.)
//
//  Otherwise, there are no lines, so the basic bitmaps are blank.
//
//  If "has buttons", then the basic bitmaps are augmented with buttons.
//
//       [+]      [-]
//
//  And if you have "lines at root", you get
//
//      __
//
//
//  And if you have "lines at root" with "has buttons", then you also get
//
//      --[+]   --[-]
//
//  So, there are twelve image types.  Here they are, with the code names
//  written underneath.
//
//      |       |       |       |       |       |       |
//      |       +---    +---   [+]--   [+]--   [-]--   [-]--
//      |       |               |               |
//
//     "|"     "|-"    "L"     "|-+"   "L+"    "|--"   "L-"
//
//      ---    [+]--   [-]--   [+]     [-]
//
//     ".-"    ".-+"   ".--"   "+"     "-"
//
//      And the master table of which styles get which images.
//
//
//  LINES   BTNS    ROOT    |   |-  L   |-+ L+  |-- L-  .-  .-+ .-- +   -
//
//           x                                                      0   1
//    x                     0   1   2                   3
//    x                     0   1   2                   3
//    x      x              0   1   2   3   4   5   6
//    x              x      0   1   2                   3
//    x      x       x      0   1   2   3   4   5   6   7   8   9
//
// ----------------------------------------------------------------------------

void NEAR TV_CreateIndentBmps(PTREE pTree)
{
    int  cnt;
    RECT rc;
    HBRUSH hbrOld;
    int xMid, yMid;
    int x, c;
    HBITMAP hBmpOld;
    HBRUSH hbrLine;
    HBRUSH hbrText;
    HDC hdc;

    if (pTree->fRedraw)
        InvalidateRect(pTree->ci.hwnd, NULL, TRUE);
    
    if (pTree->ci.style & TVS_HASLINES)
    {
        if (pTree->ci.style & TVS_HASBUTTONS)
            cnt = 7;  //   | |-  L   |-+ L+  |-- L-
        else
            cnt = 3;  //   | |-  L
        
        if (pTree->ci.style & TVS_LINESATROOT) {
            if (pTree->ci.style & TVS_HASBUTTONS)
                cnt += 3;    // -  -+ --
            else 
                cnt += 1;    // -
        }
    }
    else if (pTree->ci.style & TVS_HASBUTTONS)
        cnt = 2;
    else
        return;

    if (!pTree->hdcBits)
        pTree->hdcBits = CreateCompatibleDC(NULL);
    
    hdc = pTree->hdcBits;
    
    // Get a new background brush, just like an Edit does.
    
    TV_GetBackgroundBrush(pTree, hdc);
    
    hBmpOld = pTree->hBmp;
    pTree->hBmp = CreateColorBitmap(cnt * pTree->cxIndent, pTree->cyItem);
    if (hBmpOld) {
        SelectObject(hdc, pTree->hBmp);
        DeleteObject(hBmpOld);
    } else
        pTree->hStartBmp = SelectObject(hdc, pTree->hBmp);

    if (pTree->clrLine != CLR_DEFAULT)
        hbrLine = CreateSolidBrush(pTree->clrLine);
    else
        hbrLine = g_hbrGrayText;

    if (pTree->clrText != (COLORREF)-1)
        hbrText = CreateSolidBrush(pTree->clrText);
    else
        hbrText = g_hbrWindowText;

    hbrOld = SelectObject(hdc, hbrLine);

    rc.top = 0;
    rc.left = 0;
    rc.right = cnt * pTree->cxIndent;
    rc.bottom = pTree->cyItem;

    FillRect(hdc, &rc, pTree->hbrBk);
    x = 0;
    
    if (pTree->hImageList)
        xMid = (pTree->cxImage - MAGIC_INDENT) / 2;
    else
        xMid = pTree->cxIndent / 2;
    
    yMid = ((pTree->cyItem / 2) + 1) & ~1;
    
    c = (min(xMid, yMid)) / 2;
    
    if (pTree->ci.style & TVS_HASLINES)
    {
        TV_DrawDottedLine(hdc, x + xMid, 0, pTree->cyItem, TRUE);
        x += pTree->cxIndent;
        
        TV_DrawDottedLine(hdc, x + xMid, 0, pTree->cyItem, TRUE);
        TV_DrawDottedLine(hdc, x + xMid, yMid, pTree->cxIndent - xMid, FALSE);
        x += pTree->cxIndent;
        
        TV_DrawDottedLine(hdc, x + xMid, 0, yMid, TRUE);
        TV_DrawDottedLine(hdc, x + xMid, yMid, pTree->cxIndent - xMid, FALSE);
        x += pTree->cxIndent;
    }
    
    if (pTree->ci.style & TVS_HASBUTTONS)
    {
        BOOL fPlus = TRUE;
        
        x += xMid;
        
doDrawPlusMinus:
        TV_DrawPlusMinus(hdc, x, yMid, c, hbrText, hbrLine, pTree->hbrBk, fPlus);
        
        if (pTree->ci.style & TVS_HASLINES)
        {
            TV_DrawDottedLine(hdc, x, 0, yMid - c, TRUE);
            TV_DrawDottedLine(hdc, x + c, yMid, pTree->cxIndent - xMid - c, FALSE);
            TV_DrawDottedLine(hdc, x, yMid + c, yMid - c, TRUE);
            
            x += pTree->cxIndent;
            
            TV_DrawPlusMinus(hdc, x, yMid, c, hbrText, hbrLine, pTree->hbrBk, fPlus);
            
            TV_DrawDottedLine(hdc, x, 0, yMid - c, TRUE);
            TV_DrawDottedLine(hdc, x + c, yMid, pTree->cxIndent - xMid - c, FALSE);
        }
        
        x += pTree->cxIndent;
        
        if (fPlus)
        {
            fPlus = FALSE;
            goto doDrawPlusMinus;
        }
        x -= xMid;
    }
    
    if (pTree->ci.style & TVS_LINESATROOT) {
        
        // -
        TV_DrawDottedLine(hdc, x + xMid, yMid, pTree->cxIndent - xMid, FALSE);
        x += pTree->cxIndent;
        
        if (pTree->ci.style & TVS_HASBUTTONS) {
            x += xMid;
            TV_DrawPlusMinus(hdc, x, yMid, c, hbrText, hbrLine, pTree->hbrBk, TRUE);
            TV_DrawDottedLine(hdc, x + c, yMid, pTree->cxIndent - xMid - c, FALSE);
            x += pTree->cxIndent;
            
            TV_DrawPlusMinus(hdc, x, yMid, c, hbrText, hbrLine, pTree->hbrBk, FALSE);
            TV_DrawDottedLine(hdc, x + c, yMid, pTree->cxIndent - xMid - c, FALSE);
            //  uncomment if there's more to be added
            //x += pTree->cxIndent - xMid;
            
        }
    }
    
    if (hbrOld)
        SelectObject(pTree->hdcBits, hbrOld);
    
    if (pTree->clrLine != CLR_DEFAULT)
        DeleteObject(hbrLine);
    if (pTree->clrText != (COLORREF)-1)
        DeleteObject(hbrText);
}


// ----------------------------------------------------------------------------
//
//  fills in a TVITEM structure based by coying data from the item or
//  by calling the callback to get it.
//
//  in:
//	hItem	item to get TVITEM struct for
//	mask	which bits of the TVITEM struct you want (TVIF_ flags)
//  out:
//	lpItem	TVITEM filled in
//
// ----------------------------------------------------------------------------

void NEAR TV_GetItem(PTREE pTree, HTREEITEM hItem, UINT mask, LPTVITEMEX lpItem)
{
    TV_DISPINFO nm;
    
    if (!hItem || !lpItem)
        return;
    
    DBG_ValidateTreeItem(hItem, FALSE);

    nm.item.mask = 0;
    
    // We need to check the mask to see if lpItem->pszText is valid
    // And even then, it might not be, so be paranoid
    if ((mask & TVIF_TEXT) && lpItem->pszText && lpItem->cchTextMax) {
        if (hItem->lpstr == LPSTR_TEXTCALLBACK) {
            nm.item.mask |= TVIF_TEXT;
            // caller had to fill in pszText and cchTextMax with valid data
            nm.item.pszText = lpItem->pszText;
            nm.item.cchTextMax = lpItem->cchTextMax;
            nm.item.pszText[0] = 0;

        }
        else
        {
            ASSERT(hItem->lpstr);
            // we could do this but this is dangerous (when responding
            // to TVM_GETITEM we would be giving the app a pointer to our data)
            // lpItem->pszText = hItem->lpstr;
            StringCchCopy(lpItem->pszText, lpItem->cchTextMax, hItem->lpstr);
        }

    }
    
    if (mask & TVIF_IMAGE) {
        if (hItem->iImage == (WORD)I_IMAGECALLBACK)
            nm.item.mask |= TVIF_IMAGE;
        else
            lpItem->iImage = hItem->iImage;
    }
    
    if (mask & TVIF_SELECTEDIMAGE) {
        if (hItem->iSelectedImage == (WORD)I_IMAGECALLBACK)
            nm.item.mask |= TVIF_SELECTEDIMAGE;
        else
            lpItem->iSelectedImage = hItem->iSelectedImage;
    }
    
    if (mask & TVIF_INTEGRAL) {
        lpItem->iIntegral = hItem->iIntegral;
    }
    
    if (mask & TVIF_CHILDREN) {
        switch (hItem->fKids) {
        case KIDS_COMPUTE:
            lpItem->cChildren = hItem->hKids ? 1 : 0;// the actual count doesn't matter
            break;
            
        case KIDS_FORCE_YES:
            lpItem->cChildren = 1;// the actual count doesn't matter
            break;
            
        case KIDS_FORCE_NO:
            lpItem->cChildren = 0;
            break;
            
        case KIDS_CALLBACK:
            nm.item.mask |= TVIF_CHILDREN;
            break;
        }
    }

    // copy out constant parameters (and prepare for callback)
    // IE4 and IE5.0 did this unconditionally
    lpItem->state = nm.item.state = hItem->state;

    //
    //  NOTICE!  We do not set TVIF_STATE nm.item.mask and we do not
    //  check for TVIF_STATE in the "any items need to be filled in
    //  by callback?" test a few lines below.  This is necessary for
    //  backwards compat.  IE5 and earlier did not call the app back
    //  if the only thing you asked for was TVIF_STATE.  You can't
    //  change this behavior unless you guard it with a version check, or
    //  apps will break.  (They'll get callbacks when they didn't used to.)
    //  Besides, nobody knows that they can customize the state, so it's
    //  not like we're missing out on anything.
    //

#ifdef DEBUG_TEST_BOLD
    if ((((int)hItem) / 100) % 2)
        lpItem->state |= TVIS_BOLD;
    if (!pTree->hFontBold)
        TV_CreateBoldFont(pTree);
#endif
    
    lpItem->lParam = nm.item.lParam = hItem->lParam;
    
    // any items need to be filled in by callback?
    if (nm.item.mask & (TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN)) {
        nm.item.hItem = hItem;
        
        CCSendNotify(&pTree->ci, TVN_GETDISPINFO, &nm.hdr);

        // copy out things that may have been filled in on the callback
        if (nm.item.mask & TVIF_CHILDREN)
            lpItem->cChildren = nm.item.cChildren;

        if (nm.item.mask & TVIF_IMAGE)
            lpItem->iImage = nm.item.iImage;

        if (nm.item.mask & TVIF_SELECTEDIMAGE)
            lpItem->iSelectedImage = nm.item.iSelectedImage;

        // callback may have redirected pszText to point into its own buffer
        if (nm.item.mask & TVIF_TEXT)
        {
            if (mask & TVIF_TEXT) // did the *original* mask specify TVIF_TEXT?
                lpItem->pszText = CCReturnDispInfoText(nm.item.pszText, lpItem->pszText, lpItem->cchTextMax);
            else
                lpItem->pszText = nm.item.pszText;   // do what we used to do
        }

        if (nm.item.mask & TVIF_STATE) {
            lpItem->state = (nm.item.state & nm.item.stateMask) | (lpItem->state & ~nm.item.stateMask);
            if ((lpItem->state & TVIS_BOLD) && !pTree->hFontBold)
                TV_CreateBoldFont(pTree);
        }
        
        
        if (nm.item.mask & TVIF_DI_SETITEM) {
            
            if (nm.item.mask & TVIF_TEXT)
                if (nm.item.pszText) {
                    ASSERT(hItem->lpstr == LPSTR_TEXTCALLBACK);
                    Str_Set(&hItem->lpstr, nm.item.pszText);
                }
                if (nm.item.mask & TVIF_STATE) {
                    // if the bold bit changed, then the width changed
                    if ((hItem->state ^ lpItem->state) & TVIS_BOLD)
                        hItem->iWidth = 0;
                    hItem->state = (WORD) lpItem->state;
                }
                if (nm.item.mask & TVIF_IMAGE)
                    hItem->iImage = (WORD) lpItem->iImage;
                if (nm.item.mask & TVIF_SELECTEDIMAGE)
                    hItem->iSelectedImage = (WORD) lpItem->iSelectedImage;
                if (nm.item.mask & TVIF_CHILDREN) {
                    switch(nm.item.cChildren) {
                    case I_CHILDRENCALLBACK:
                        hItem->fKids = KIDS_CALLBACK;
                        break;
                        
                    case 0:
                        hItem->fKids = KIDS_FORCE_NO;
                        break;
                        
                    default:
                        hItem->fKids = KIDS_FORCE_YES;
                        break;
                    }
                    
                }
        }
    }
}


// ----------------------------------------------------------------------------
//
//  Draws the given item starting at the given (x,y) and extending down and to
//  the right.
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ShouldItemDrawBlue(PTREE pTree, TVITEMEX *ti, UINT flags) 
{
    return  ( (ti->state & TVIS_DROPHILITED) ||
        (!pTree->hDropTarget && 
        !(flags & TVDI_GRAYCTL) &&
        (ti->state & TVIS_SELECTED) &&
        pTree->fFocus));
}

#define TV_ShouldItemDrawDisabled(pTree, pti, flags) (flags & TVDI_GRAYCTL)

//
//  Caution:  Depending on the user's color scheme, a Gray item may
//  end up looking Blue if Gray would otherwise be invisible.  So make
//  sure that there are other cues that the user can use to tell whether
//  the item is "Really Blue" or "Gray masquerading as Blue".
//
//  For example, you might get both is if the treeview is
//  participating in drag/drop while it is not the active window,
//  because the selected item gets "Gray masquerading as Blue" and
//  the drop target gets "Really Blue".  But we special-case that
//  and turn off the selection while we are worrying about drag/drop,
//  so there is no confusion after all.
//
BOOL TV_ShouldItemDrawGray(PTREE pTree, TVITEMEX *pti, UINT flags) 
{
    return  ((flags & TVDI_GRAYCTL) ||
        (!pTree->hDropTarget && 
        ((pti->state & TVIS_SELECTED) &&
        (!pTree->fFocus && (pTree->ci.style & TVS_SHOWSELALWAYS)) )));
}

//
//  Draw a descender line for the item.  It is the caller's job to
//  draw the appropriate glyph at level 0.
//
void
TV_DrawDescender(PTREE pTree, HDC hdc, int x, int y, HTREEITEM hItem)
{
    int i;
    for (i = 1; i < hItem->iIntegral; i++)
        BitBlt(hdc, x, y + i * pTree->cyItem, pTree->cxIndent, pTree->cyItem, pTree->hdcBits, 0, 0, SRCCOPY);

}

//
//  Erase any previous descender line for the item.
//
void
TV_EraseDescender(PTREE pTree, HDC hdc, int x, int y, HTREEITEM hItem)
{
    RECT rc;
    rc.left = x;
    rc.right = x + pTree->cxIndent;
    rc.top = y + pTree->cyItem;
    rc.bottom = y + hItem->iIntegral * pTree->cyItem;
    FillRect(hdc, &rc, pTree->hbrBk);
}

//
//  Draw (or erase) descenders for siblings and children.
//
void TV_DrawKinDescender(PTREE pTree, HDC hdc, int x, int y, HTREEITEM hItem, UINT state)
{
    if (hItem->hNext)   // Connect to next sibling
        TV_DrawDescender(pTree, hdc, x, y, hItem);
    else
        TV_EraseDescender(pTree, hdc, x, y, hItem);

    // If any bonus images, then need to connect the image to the kids.
    if (pTree->himlState || pTree->hImageList) {
        if (state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL)) // Connect to expanded kids
            TV_DrawDescender(pTree, hdc, x + pTree->cxIndent, y, hItem);
        else
            TV_EraseDescender(pTree, hdc, x + pTree->cxIndent, y, hItem);
    }
}

void NEAR TV_DrawItem(PTREE pTree, HTREEITEM hItem, HDC hdc, int x, int y, UINT flags)
{
    UINT cxIndent = pTree->cxIndent;
    COLORREF rgbOldBack = 0, rgbOldText;
    COLORREF clrBk = CLR_DEFAULT;
    RECT rc;
    int iBack, iText;
    HTREEITEM hItemSave = hItem;
    LPTSTR lpstr;
    int cch;
    UINT etoFlags = ETO_OPAQUE | ETO_CLIPPED;
    TVITEMEX ti;
    TCHAR szTemp[MAX_PATH];
    int iState = 0;
    HFONT hFont;                        //$BOLD
    DWORD dwRet;
    NMTVCUSTOMDRAW nmcd;
    BOOL fItemFocused = ((pTree->fFocus) && (hItem == pTree->hCaret));
    DWORD clrTextTemp, clrTextBkTemp;
    BOOL fSelectedIcon = FALSE;

    rc.top = y;
    rc.bottom = rc.top + (pTree->cyItem * hItem->iIntegral);
    rc.left = 0;
    rc.right = pTree->cxWnd;
    
    if (flags & TVDI_ERASE) {
        // Opaque the whole item
        FillRect(hdc, &rc, pTree->hbrBk);
    }
    
    
    // make sure the callbacks don't invalidate this item
    pTree->hItemPainting = hItem;	
    
    ti.pszText = szTemp;
    ti.cchTextMax  = ARRAYSIZE(szTemp);
    ti.stateMask = TVIS_OVERLAYMASK | TVIS_CUT | TVIS_BOLD; //$BOLD
    TV_GetItem(pTree, hItem, TVIF_IMAGE | TVIF_STATE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM, &ti);
    
    pTree->hItemPainting = NULL;
    
    
    ////////////////
    // set up the HDC

    if (TV_ShouldItemDrawBlue(pTree,&ti,flags)) {
        // selected 
        iBack = COLOR_HIGHLIGHT;
        iText = COLOR_HIGHLIGHTTEXT;
    } else if (TV_ShouldItemDrawDisabled(pTree, &pti, flags)) {
        iBack = COLOR_3DFACE;
        iText = COLOR_GRAYTEXT;
    } else if  (TV_ShouldItemDrawGray(pTree, &ti, flags)) {
        // On some color schemes, the BTNFACE color equals the WINDOW color,
        // and our gray comes out invisible.  In such case, change from gray
        // to blue so you can see it at all.
        if (GetSysColor(COLOR_WINDOW) != GetSysColor(COLOR_BTNFACE))
        {
            iBack = COLOR_BTNFACE;
            iText = COLOR_BTNTEXT;
        }
        else
        {
            iBack = COLOR_HIGHLIGHT;
            iText = COLOR_HIGHLIGHTTEXT;
        }
    } else {
        // not selected
        iBack = COLOR_WINDOW;
        iText = COLOR_WINDOWTEXT;
        if (hItem == pTree->hHot) {
            iText = COLOR_HOTLIGHT;
        }
    }
    
    if (iBack == COLOR_WINDOW && (pTree->clrBk != (COLORREF)-1))
        nmcd.clrTextBk = clrTextBkTemp = pTree->clrBk;
    else
        nmcd.clrTextBk = clrTextBkTemp = GetSysColor(iBack);

    if (iText == COLOR_WINDOWTEXT && (pTree->clrText != (COLORREF)-1))
        nmcd.clrText = clrTextTemp = pTree->clrText;
    else
        nmcd.clrText = clrTextTemp = GetSysColor(iText);

    // if forcing black and transparent, do so.  dc's BkMode should
    // already be set to TRANSPARENT by caller
    if (flags & TVDI_TRANSTEXT)
    {
        nmcd.clrText = clrTextTemp = 0x000000;
        etoFlags = 0;			// don't opaque nothin'
    }
    
    rgbOldBack = SetBkColor(hdc, nmcd.clrTextBk);
    rgbOldText = SetTextColor(hdc, nmcd.clrText);
    
    
    if (pTree->ci.style & TVS_RTLREADING)
    {
        etoFlags |= ETO_RTLREADING;
    }
    
    // Figure out which font to use.    
    if (ti.state & TVIS_BOLD) {         
        hFont = pTree->hFontBold;
        if (hItem == pTree->hHot) {
            hFont = CCGetHotFont(pTree->hFontBold, &pTree->hFontBoldHot);
        }
    } else {                            
        hFont = pTree->hFont;
        if (hItem == pTree->hHot) {
            hFont = CCGetHotFont(pTree->hFont, &pTree->hFontHot);
        }
    }                                   
    hFont = SelectObject(hdc, hFont);   
    // End HDC setup
    ////////////////
    
    
    // notify on custom draw then do it!
    nmcd.nmcd.hdc = hdc;
    nmcd.nmcd.dwItemSpec = (DWORD_PTR)hItem;
    nmcd.nmcd.uItemState = 0;
    nmcd.nmcd.rc = rc;
    if (flags & TVDI_NOTREE)
        nmcd.iLevel = 0;
    else 
        nmcd.iLevel = hItem->iLevel;
    
    if (ti.state & TVIS_SELECTED) {
        
        fSelectedIcon = TRUE;
        
        if (pTree->fFocus || (pTree->ci.style & TVS_SHOWSELALWAYS))
            nmcd.nmcd.uItemState |= CDIS_SELECTED;
    }
    if (fItemFocused)
        nmcd.nmcd.uItemState |= CDIS_FOCUS;
    if (hItem == pTree->hHot)
        nmcd.nmcd.uItemState |= CDIS_HOT;

    nmcd.nmcd.lItemlParam = ti.lParam;
    
    dwRet = CICustomDrawNotify(&pTree->ci, CDDS_ITEMPREPAINT, &nmcd.nmcd);
    if (dwRet & CDRF_SKIPDEFAULT) 
        return;
    
    fItemFocused = (nmcd.nmcd.uItemState & CDIS_FOCUS);
    if (nmcd.nmcd.uItemState & CDIS_SELECTED)
        ti.state |= TVIS_SELECTED;
    else {
        ti.state &= ~TVIS_SELECTED;
    }
    
    if (nmcd.clrTextBk != clrTextBkTemp)
        SetBkColor(hdc, nmcd.clrTextBk);
    
    if (nmcd.clrText != clrTextTemp)
        SetTextColor(hdc, nmcd.clrText);
    
    if (pTree->ci.style & TVS_FULLROWSELECT && 
         !(flags & TVDI_TRANSTEXT)) 
    {
        FillRectClr(hdc, &nmcd.nmcd.rc, GetBkColor(hdc));
        etoFlags |= ETO_OPAQUE;
        clrBk = CLR_NONE;
    }
    
    if (!(flags & TVDI_NOTREE)) {
        if ((pTree->ci.style & (TVS_HASLINES | TVS_HASBUTTONS)) &&
            (pTree->ci.style & TVS_LINESATROOT))
            // Make room for the "plus" at the front of the tree
            x += cxIndent;
    }
    
    
    // deal with margin, etc.
    x += (pTree->cxBorder + (nmcd.iLevel * cxIndent));
    y += pTree->cyBorder;
    
    // draw image
    if ((!(flags & TVDI_NOTREE) && !(dwRet & TVCDRF_NOIMAGES)) || (flags & TVDI_FORCEIMAGE))
    {
        int dx, dy;     // to clip the images within the borders.
        COLORREF clrImage = CLR_HILIGHT;
        COLORREF clrBkImage = clrBk;

        if (flags & TVDI_NOBK)
        {
            clrBkImage = CLR_NONE;
        }


        if (pTree->himlState) {
            iState = TV_StateIndex(&ti);
            // go figure.  in the treeview, 0 for the state image index
            // means draw nothing... the 0th item is unused.
            // the listview is 0 based and uses the 0th item.  
            if (iState) {
                dx = min(pTree->cxState, pTree->cxMax - pTree->cxBorder - x);
                dy = min(pTree->cyState, pTree->cyItem - (2 * pTree->cyBorder));
                ImageList_DrawEx(pTree->himlState, iState, hdc, x, 
                    y + max(pTree->cyItem - pTree->cyState, 0), dx, dy, clrBk, CLR_DEFAULT, ILD_NORMAL);
                x += pTree->cxState;            
            }
        }
        
        if (pTree->hImageList) {
            UINT fStyle = 0;
            int i = (fSelectedIcon) ? ti.iSelectedImage : ti.iImage;
            
            if (ti.state & TVIS_CUT) {
                fStyle |= ILD_BLEND50;
                clrImage = ImageList_GetBkColor(pTree->hImageList);
            }
            
            dx = min(pTree->cxImage - MAGIC_INDENT, pTree->cxMax - pTree->cxBorder - x);
            dy = min(pTree->cyImage, pTree->cyItem - (2 * pTree->cyBorder));
            ImageList_DrawEx(pTree->hImageList, i, hdc,
                x, y + (max(pTree->cyItem - pTree->cyImage, 0) / 2), dx, dy,
                clrBkImage, clrImage,
                fStyle | (ti.state & TVIS_OVERLAYMASK));
            
        }
    }
    
    if (pTree->hImageList) {
        // even if not drawing image, draw text in right place
        x += pTree->cxImage;
    }
    
    // draw text
    lpstr = ti.pszText;
    cch = lstrlen(lpstr);
    
    if (!hItem->iWidth || (hItem->lpstr == LPSTR_TEXTCALLBACK))
    {
        TV_ComputeItemWidth(pTree, hItem, hdc); //$BOLD
    }
    
    rc.left = x;
    rc.top = y + pTree->cyBorder;
    rc.right = min((x + hItem->iWidth),
                   (pTree->cxMax - pTree->cxBorder));
    rc.bottom-= pTree->cyBorder;
    
    // Draw the text, unless it's the one we are editing
    if (pTree->htiEdit != hItem || !IsWindow(pTree->hwndEdit) || !IsWindowVisible(pTree->hwndEdit))
    {
        ExtTextOut(hdc, x + g_cxLabelMargin, y + ((pTree->cyItem - pTree->cyText) / 2) + g_cyBorder,
            etoFlags, &rc, lpstr, cch, NULL);
    
        // Draw the focus rect, if appropriate.
        if (pTree->fFocus && (fItemFocused) && 
            !(pTree->ci.style & TVS_FULLROWSELECT) &&
            !(flags & (TVDI_TRANSTEXT | TVDI_GRAYCTL))
			&& !(CCGetUIState(&(pTree->ci)) & UISF_HIDEFOCUS)
			)
            DrawFocusRect(hdc, &rc);
    }
    
    SetBkColor(hdc, rgbOldBack);
    SetTextColor(hdc, rgbOldText);
    
    // Restore the original font.       //$BOLD
    SelectObject(hdc, hFont);           //$BOLD
    
    // Notice that we should have opaque'd the rest of the line above if no tree
    if (!(flags & TVDI_NOTREE))
    {
        int dx, dy;
        
        if (pTree->hImageList)
            x -= pTree->cxImage;
        
        if (iState)
            x -= pTree->cxState;
        
        if (pTree->ci.style & TVS_HASLINES)
        {
            int i;

            x -= cxIndent;
            if (nmcd.iLevel-- || (pTree->ci.style & TVS_LINESATROOT))
            {
                // HACK: Special case the first root
                // We will draw a "last" sibling button upside down
                if (nmcd.iLevel == -1 && hItem == hItem->hParent->hKids)
                {
                    if (hItem->hNext) {
                        i = 2;              // "L"
                        if (ti.cChildren && (pTree->ci.style & TVS_HASBUTTONS))
                        {
                            i += 2;         // "L+"
                            if ((ti.state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL)) == TVIS_EXPANDED)
                                i += 2;     // "L-"
                        }
                        
                        dx = min((int)cxIndent, pTree->cxMax - pTree->cxBorder - x);
                        dy = pTree->cyItem - (2 * pTree->cyBorder);
                        StretchBlt(hdc, x, y + pTree->cyItem, cxIndent, -pTree->cyItem, pTree->hdcBits
                            , i * cxIndent, 0, dx, dy, SRCCOPY);
                        i = -1;
                    }
                    else 
                    {
                        // first root no siblings
                        // if there's no other item, draw just the button if button mode,
                        if (pTree->ci.style & TVS_HASBUTTONS)
                        {
                            if (ti.cChildren) {
                                // hasbuttons, has lines, lines at root
                                i = ((ti.state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL)) == TVIS_EXPANDED) ? 
                                    9 : 8;  // ".--" : ".-+"
                            } else {
                                i = 7;      // ".-"
                            }
                        }
                        else
                        {
                            i = 3;          // ".-"
                        }
                    }
                }
                else
                {
                    i = (hItem->hNext) ? 1 : 2; // "|-" (rep) : "L"
                    if (ti.cChildren && (pTree->ci.style & TVS_HASBUTTONS))
                    {
                        i += 2;                 // "|-+" (rep) : "L+"
                        if ((ti.state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL)) == TVIS_EXPANDED)
                            i += 2;             // "|--" (rep) : "L-"
                    }
                }
                if (hItem->iIntegral > 1)
                    TV_DrawKinDescender(pTree, hdc, x, y, hItem, ti.state);

                if (i != -1)
                {
                    dx = min((int)cxIndent, pTree->cxMax - pTree->cxBorder - x);
                    dy = pTree->cyItem - (2 * pTree->cyBorder);
                    if ((dx > 0) && (dy > 0))
                        BitBlt(hdc, x, y, dx, dy, pTree->hdcBits
                            , i * cxIndent, 0, SRCCOPY);
                }
                
                while ((--nmcd.iLevel >= 0) || ((pTree->ci.style & TVS_LINESATROOT) && nmcd.iLevel >= -1))
                {
                    hItem = hItem->hParent;
                    x -= cxIndent;
                    if (hItem->hNext)
                    {
                        dx = min((int)cxIndent, (pTree->cxMax - pTree->cxBorder - x));
                        dy = min(pTree->cyItem, pTree->cyWnd - pTree->cyBorder - y);
                        if ((dx > 0) && (dy > 0))
                            BitBlt(hdc, x, y, dx, dy, pTree->hdcBits, 0, 0, SRCCOPY);
                        TV_DrawDescender(pTree, hdc, x, y, hItemSave);
                    }
                }
            }
        }
        else
        {               // no lines
            if ((pTree->ci.style & TVS_HASBUTTONS) && (nmcd.iLevel || pTree->ci.style & TVS_LINESATROOT)
                && ti.cChildren)
            {
                int i = (ti.state & TVIS_EXPANDED) ? cxIndent : 0;
                
                x -= cxIndent;
                dx = min((int)cxIndent, pTree->cxMax - pTree->cxBorder - x);
                dy = min(pTree->cyItem, pTree->cyWnd - pTree->cyBorder - y);
                if ((dx > 0) && (dy > 0))
                    BitBlt(hdc, x, y, dx, dy, pTree->hdcBits, i, 0, SRCCOPY);
            }
        }
    }
    
    
    if (dwRet & CDRF_NOTIFYPOSTPAINT) {
        nmcd.nmcd.dwItemSpec = (DWORD_PTR)hItemSave;
        CICustomDrawNotify(&pTree->ci, CDDS_ITEMPOSTPAINT, &nmcd.nmcd);
    }
}

#define INSERTMARKSIZE      6

BOOL TV_GetInsertMarkRect(PTREE pTree, LPRECT prc)
{
    ASSERT(pTree);

    if(pTree->htiInsert && TV_GetItemRect(pTree, pTree->htiInsert, prc, TRUE))
    {
        if (pTree->fInsertAfter)
            prc->top = prc->bottom;
        else
            prc->bottom = prc->top;
        
        prc->top -= INSERTMARKSIZE/2;
        prc->bottom += INSERTMARKSIZE/2 + 1;
        prc->right = pTree->cxWnd - INSERTMARKSIZE;      // should always go all the way to right with pad.
        prc->left -= pTree->cxImage;
        
        return TRUE;
    }
    return FALSE;
}

//  this is implemented in toolbar.c, but we should be able to use 
//  as well as long as we always set fHorizMode to FALSE
void PASCAL DrawInsertMark(HDC hdc, LPRECT prc, BOOL fHorizMode, COLORREF clr);

__inline COLORREF TV_GetInsertMarkColor(PTREE pTree)
{
    if (pTree->clrim == CLR_DEFAULT)
        return g_clrWindowText;
    else
        return pTree->clrim;
}

void NEAR TV_DrawTree(PTREE pTree, HDC hdc, BOOL fErase, LPRECT lprc)
{
    int x;
    int iStart, iCnt;
    UINT uFlags;
    RECT rc;
    NMCUSTOMDRAW nmcd;
    
    if (!pTree->fRedraw)
        return;

    if (pTree->ci.style & TVS_CHECKBOXES)
        if (!pTree->himlState)
            TV_InitCheckBoxes(pTree);
    
    x = -pTree->xPos;
    
    TV_GetBackgroundBrush(pTree, hdc);
    
    rc = *lprc;
    
    iStart = lprc->top / pTree->cyItem;

    if (pTree->cItems && pTree->hTop) {
        ASSERT(ITEM_VISIBLE(pTree->hTop));

        iCnt = pTree->cShowing - pTree->hTop->iShownIndex;
    } else {
        iCnt = 0;                   // Nothing to draw
    }

    nmcd.hdc = hdc;
    /// not implemented yet
    //if (ptb->ci.hwnd == GetFocus()) 
    //nmcd.uItemState = CDIS_FOCUS;
    //else 
    nmcd.uItemState = 0;
    nmcd.lItemlParam = 0;
    nmcd.rc = rc;
    pTree->ci.dwCustom = CICustomDrawNotify(&pTree->ci, CDDS_PREPAINT, &nmcd);
    if (!(pTree->ci.dwCustom & CDRF_SKIPDEFAULT)) {
        
        if (iStart < iCnt)
        {
            HTREEITEM   hItem;
            HFONT       hOldFont;
            RECT        rcT;
            int y = 0;
            
            for (hItem = pTree->hTop; hItem; ) {
                if (iStart > hItem->iIntegral) {
                    iStart -= hItem->iIntegral;
                    y += hItem->iIntegral * pTree->cyItem;
                    hItem = TV_GetNextVisItem(hItem);
                } else
                    break;
            }
            
            hOldFont = pTree->hFont ? SelectObject(hdc, pTree->hFont) : NULL;
            
            // TVDI_* for all items
            uFlags = (pTree->ci.style & WS_DISABLED) ? TVDI_GRAYCTL : 0;
            if (fErase)
                uFlags |= TVDI_ERASE;
            
            // loop from the first visible item until either all visible items are
            // drawn or there are no more items to draw
            for ( ; hItem && y < lprc->bottom; hItem = TV_GetNextVisItem(hItem))
            {
                TV_DrawItem(pTree, hItem, hdc, x, y, uFlags);
                y += pTree->cyItem * hItem->iIntegral;
            }
            
            //
            // handle drawing the InsertMark next to this item.
            //
            if(TV_GetInsertMarkRect(pTree, &rcT))
                DrawInsertMark(hdc, &rcT, FALSE, TV_GetInsertMarkColor(pTree));

            
            if (hOldFont)
                SelectObject(hdc, hOldFont);
            
            rc.top = y;
        }
        
        if (fErase)
            // Opaque out everything we have not drawn explicitly
            FillRect(hdc, &rc, pTree->hbrBk);
        
        // notify parent afterwards if they want us to
        if (pTree->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
            CICustomDrawNotify(&pTree->ci, CDDS_POSTPAINT, &nmcd);
        }
    }

}


// ----------------------------------------------------------------------------
//
//  Set up for paint, call DrawTree, and clean up after paint.
//
// ----------------------------------------------------------------------------

void NEAR TV_Paint(PTREE pTree, HDC hdc)
{
    PAINTSTRUCT ps;
    
    if (hdc)
    {
        // hdc != 0 indicates a subclassed paint -- use the hdc passed in
        SetRect(&ps.rcPaint, 0, 0, pTree->cxWnd, pTree->cyWnd);
        TV_DrawTree(pTree, hdc, TRUE, &ps.rcPaint);
    }
    else
    {
        BeginPaint(pTree->ci.hwnd, &ps);
        TV_DrawTree(pTree, ps.hdc, ps.fErase, &ps.rcPaint);
        EndPaint(pTree->ci.hwnd, &ps);
    }
}

// ----------------------------------------------------------------------------
// Create an imagelist to be used for dragging.
//
// 1) create mask and image bitmap matching the select bounds size
// 2) draw the text to both bitmaps (in black for now)
// 3) create an imagelist with these bitmaps
// 4) make a dithered copy of the image onto the new imagelist
// ----------------------------------------------------------------------------

HIMAGELIST NEAR TV_CreateDragImage(PTREE pTree, HTREEITEM hItem)
{
    HDC hdcMem = NULL;
    HBITMAP hbmImage = NULL;
    HBITMAP hbmMask = NULL;
    HBITMAP hbmOld;
    HIMAGELIST himl = NULL;
    BOOL bMirroredWnd = (pTree->ci.dwExStyle&RTL_MIRRORED_WINDOW);
    int dx, dy;
    int iSrc;

    TVITEMEX ti;

    if (!pTree->hImageList)
        return NULL;

    if (hItem == NULL)
        hItem = pTree->htiDrag;

    if (hItem == NULL)
        return NULL;

    
    // BUGBUG??? we know it's already been drawn, so is iWidth valid???
    dx = hItem->iWidth + pTree->cxImage;
    dy = pTree->cyItem;
    
    if (!(hdcMem = CreateCompatibleDC(NULL)))
        goto CDI_Exit;
    if (!(hbmImage = CreateColorBitmap(dx, dy)))
        goto CDI_Exit;
    if (!(hbmMask = CreateMonoBitmap(dx, dy)))
        goto CDI_Exit;
    
    //
    // Mirror the memory DC so that the transition from
    // mirrored(memDC)->non-mirrored(imagelist DCs)->mirrored(screenDC)
    // is consistent. [samera]
    //
    if (bMirroredWnd) {
        SET_DC_RTL_MIRRORED(hdcMem);
    }

    // prepare for drawing the item
    if (pTree->hFont)
        SelectObject(hdcMem, pTree->hFont);
    SetBkMode(hdcMem, TRANSPARENT);
    
    /*
    ** draw the text to both bitmaps
    */
    hbmOld = SelectObject(hdcMem, hbmImage);
    // fill image with black for transparency
    PatBlt(hdcMem, 0, 0, dx, dy, BLACKNESS);
    TV_DrawItem(pTree, hItem, hdcMem, 0, 0,
        TVDI_NOIMAGE | TVDI_NOTREE | TVDI_TRANSTEXT);

    //
    // If the header is RTL mirrored, then
    // mirror the Memory DC, so that when copying back
    // we don't get any image-flipping. [samera]
    //
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmImage);

    SelectObject(hdcMem, hbmMask);
    // fill mask with white for transparency
    PatBlt(hdcMem, 0, 0, dx, dy, WHITENESS);
    TV_DrawItem(pTree, hItem, hdcMem, 0, 0,
        TVDI_NOIMAGE | TVDI_NOTREE | TVDI_TRANSTEXT);
    
    //
    // If the header is RTL mirrored, then
    // mirror the Memory DC, so that when copying back
    // we don't get any image-flipping. [samera]
    //
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmMask);

    // unselect objects that we used
    SelectObject(hdcMem, hbmOld);
    SelectObject(hdcMem, g_hfontSystem);
    
    /*
    ** make an image list that for now only has the text
    */
    //
    // BUGBUG: To fix a pri-1 M7 bug, we create a shared image list.
    //
    if (!(himl = ImageList_Create(dx, dy, ILC_MASK, 1, 0)))
        goto CDI_Exit;
    ImageList_SetBkColor(himl, CLR_NONE);
    ImageList_Add(himl, hbmImage, hbmMask);
    
    /*
    ** make a dithered copy of the image part onto our bitmaps
    ** (need both bitmap and mask to be dithered)
    */
    TV_GetItem(pTree, hItem, TVIF_IMAGE, &ti);
    iSrc = ti.iImage;
    
    ImageList_CopyDitherImage(himl, 0, 0, (pTree->cyItem - pTree->cyImage) / 2,
        pTree->hImageList, iSrc, ((pTree->ci.dwExStyle & dwExStyleRTLMirrorWnd) ? ILD_MIRROR : 0L) | (hItem->state & TVIS_OVERLAYMASK));

CDI_Exit:
    if (hdcMem)
        DeleteObject(hdcMem);
    if (hbmImage)
        DeleteObject(hbmImage);
    if (hbmMask)
        DeleteObject(hbmMask);
    
    return himl;
}

#define COLORKEY RGB(0xF4, 0x0, 0x0)

LRESULT TV_GenerateDragImage(PTREE pTree, SHDRAGIMAGE* pshdi)
{
    LRESULT lRet = 0;
    HBITMAP hbmpOld = NULL;
    HTREEITEM hItem = pTree->htiDrag;
    RECT rc;
    HDC  hdcDragImage;

    if (hItem == NULL)
        return FALSE;

    hdcDragImage = CreateCompatibleDC(NULL);

    if (!hdcDragImage)
        return 0;

    // After this rc contains the bounds of all the items in Client Coordinates.
    //
    // Mirror the the DC, if the listview is mirrored.
    //
    if (pTree->ci.dwExStyle & RTL_MIRRORED_WINDOW)
    {
        SET_DC_RTL_MIRRORED(hdcDragImage);
    }

    TV_GetItemRect(pTree, hItem, &rc, TRUE);

    // Subtract off the image...
    rc.left -= pTree->cxImage;

    pshdi->sizeDragImage.cx = RECTWIDTH(rc);
    pshdi->sizeDragImage.cy = RECTHEIGHT(rc);
    pshdi->hbmpDragImage = CreateBitmap( pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy,
        GetDeviceCaps(hdcDragImage, PLANES), GetDeviceCaps(hdcDragImage, BITSPIXEL),
        NULL);

    if (pshdi->hbmpDragImage)
    {
        COLORREF clrBkSave;
        RECT  rcImage = {0, 0, pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy};

        hbmpOld = SelectObject(hdcDragImage, pshdi->hbmpDragImage);

        pshdi->crColorKey = COLORKEY;
        FillRectClr(hdcDragImage, &rcImage, pshdi->crColorKey);

        // Calculate the offset... The cursor should be in the bitmap rect.

        if (pTree->ci.dwExStyle & RTL_MIRRORED_WINDOW)
            pshdi->ptOffset.x = rc.right - pTree->ptCapture.x;
        else
            pshdi->ptOffset.x = pTree->ptCapture.x - rc.left;

        pshdi->ptOffset.y = pTree->ptCapture.y - rc.top;

        clrBkSave = pTree->clrBk;

        pTree->clrBk = COLORKEY;

        TV_DrawItem(pTree, hItem, hdcDragImage, 0, 0,
            TVDI_NOTREE | TVDI_TRANSTEXT | TVDI_FORCEIMAGE | TVDI_NOBK);

        pTree->clrBk = clrBkSave;

        SelectObject(hdcDragImage, hbmpOld);
        DeleteDC(hdcDragImage);

        // We're passing back the created HBMP.
        return 1;
    }


    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\tvmem.c ===
#include "ctlspriv.h"
#include "treeview.h"


void TV_ScrollItems(PTREE pTree, int nItems, int iTopShownIndex, BOOL fDown);


// in:
//      hItem   item to delete
//      flags   controls how/what to delete
//              TVDI_NORMAL             delete this node and all children
//              TVDI_NONOTIFY           don't send notify messages
//              TVDI_CHILDRENONLY       just delete the kids (not the item)

void NEAR TV_DeleteItemRecurse(PTREE pTree, TREEITEM FAR * hItem, UINT flags)
{
    TREEITEM FAR *hKid;
    TREEITEM FAR *hNext;
    TREEITEM FAR *hParent;
    int i;

    DBG_ValidateTreeItem(hItem, 0);

    //
    // We do this from DeleteItemRecurse(), kind of like how USER sends
    // Destroy notifications from its FreeWindow() code, so that we get
    // deletes for parent and children both.
    //
    MyNotifyWinEvent(EVENT_OBJECT_DESTROY, pTree->ci.hwnd, OBJID_CLIENT,
        (LONG_PTR)hItem);

    //
    //  While the item is still valid, clean up if it's the insertion point.
    //  The item needs to be valid because we're going to call other
    //  functions that validate their parameters...
    //
    if (hItem == pTree->htiInsert)
    {
        TV_SetInsertMark(pTree, NULL, FALSE);
        ASSERT(pTree->htiInsert == NULL);
    }

    // remove all kids (and their kids)
    for (hKid = hItem->hKids; hKid; hKid = hNext) {
        hNext = hKid->hNext;

        // recurse on each child
        TV_DeleteItemRecurse(pTree, hKid, flags & ~TVDI_CHILDRENONLY);
    }

    if ((flags & TVDI_CHILDRENONLY) || !hItem->hParent)
        return;

    if (!(flags & TVDI_NONOTIFY))    // BUGBUG: this is not set by anyone
    {
        NM_TREEVIEW nm;
        // Let the app clean up after itself
        nm.itemOld.hItem = hItem;
        nm.itemOld.lParam = hItem->lParam;
        nm.itemNew.mask = 0;
        nm.itemOld.mask = (TVIF_HANDLE | TVIF_PARAM);
        CCSendNotify(&pTree->ci, TVN_DELETEITEM, &nm.hdr);
    }

    //
    // If anybody has a watch on our item, let him know that it's gone.
    //
    i = DPA_GetPtrCount(pTree->hdpaWatch);
    while (--i >= 0)
    {
        PTVWATCHEDITEM pwi = DPA_FastGetPtr(pTree->hdpaWatch, i);
        ASSERT(pwi);
        if (pwi->hti == hItem) {
            pwi->hti = hItem->hNext;
            pwi->fStale = TRUE;
        }
    }

    hParent = hItem->hParent;
    ASSERT(hParent);

    // unlink ourselves from the parent child chain

    if (hParent->hKids == hItem) {
        hParent->hKids = hItem->hNext;
        hKid = NULL; 
    } else {
        // not the first child, find our previous item (linear search!)
        hKid = TV_GetNextItem(pTree, hItem, TVGN_PREVIOUS);
        ASSERT(hKid);
        hKid->hNext = hItem->hNext;
    }

    pTree->cItems--;

    TV_ScrollBarsAfterRemove(pTree, hItem);

    // reset tooltip after unlink from the parent child chain
    if (pTree->hToolTip == hItem)
        TV_SetToolTipTarget(pTree, NULL);

    Str_Set(&hItem->lpstr, NULL);

    TV_MarkAsDead(hItem);

    // be careful from here down.  hItem is unlinked but
    // still has some valid fields

    // Check to see if the user has deleted one of the
    // special items that is stored in the main tree structure.
    if (hItem == pTree->htiEdit)
        pTree->htiEdit = NULL;

    if (hItem == pTree->hDropTarget)
        pTree->hDropTarget = NULL;

    if (hItem == pTree->hOldDrop)
        pTree->hOldDrop = NULL;

    if (hItem == pTree->hHot )
        pTree->hHot = NULL;

    if (hItem == pTree->htiSearch )
        pTree->htiSearch = NULL;

    // if the caret escaped the collapsed area and landed on us, push it away
    if (pTree->hCaret == hItem) {
        HTREEITEM hTemp;
        if (hItem->hNext)
            hTemp = hItem->hNext;
        else {
            hTemp = VISIBLE_PARENT(hItem);
            if (!hTemp) 
                hTemp = hKid;  // set above when we unlinked from the previous item
        }
        // Reset the caret to NULL as to not try to reference our
        // invalidated item.
        pTree->hCaret = NULL;
        TV_SelectItem(pTree, TVGN_CARET, hTemp, (flags & TVDI_NOSELCHANGE) ? 0 : TVSIF_NOTIFY, 0);
        ASSERT(pTree->hCaret != hItem);
    }

    // BUGBUG: might want to really do this
    ASSERT(pTree->hItemPainting != hItem);

    ControlFree(pTree->hheap, hItem);
}


// ----------------------------------------------------------------------------
//
//  Removes the given item and all children from the tree.
//  Special case: if the given item is the hidden root, all children are
//  removed, but the hidden root is NOT removed.
//
//  sets cItems
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_DeleteItem(PTREE pTree, TREEITEM FAR * hItem, UINT flags)
{
    if (hItem == TVI_ROOT || !hItem)
        hItem = pTree->hRoot;

    // BUGUBG: send TVN_DELETEALLITEMS and TVDI_NONOTIFY if they respond
    // if (hItem == pTree->hRoot)
    //     etc.

    if (!ValidateTreeItem(hItem, 0))
        return FALSE;

    // Collapse first to speed things up (not as much scroll bar recalcs) and
    // to set the top index correctly after the remove.
    if (hItem != pTree->hRoot)
        TV_Expand(pTree, TVE_COLLAPSE, hItem, FALSE);
    else
    {
        // TV_Expand punts on the root item, so manually iterate through it's kids
        TREEITEM *hKid = hItem->hKids;
        while (hKid)
        {
            TV_Expand(pTree, TVE_COLLAPSE, hKid, FALSE);
            if (!ValidateTreeItem(hKid, 0)) break;      // callback during collapse could delete
            hKid = hKid->hNext;
        }
    }

    // Invalidate everything below this item; must be done AFTER setting the
    // selection
    if (hItem->hParent == pTree->hRoot || hItem == pTree->hRoot || ITEM_VISIBLE(hItem->hParent)) {
        if (pTree->fRedraw) {
            InvalidateRect(pTree->ci.hwnd, NULL, TRUE);
        }
    } else {
        TV_ScrollBelow(pTree, hItem->hParent, FALSE, FALSE);
    }

    // We can pass in the root to clear all items
    if (hItem == pTree->hRoot)
        flags |= TVDI_CHILDRENONLY;

    TV_DeleteItemRecurse(pTree, hItem, flags);

    ASSERT(pTree->hRoot); // didn't go too far, did we?

    // maybe everything's gone...
    // check out our cleanup job
    if (!pTree->hRoot->hKids) {
        // the tree itself
        ASSERT(pTree->cItems == 0);
        pTree->cItems = 0; // just removed it all, didn't we?

        // BUGBUG: this fails because we don't touch hTop if redraw is off
        // in TV_DeleteItemRecurse()
        // AssertMsg(pTree->hTop == NULL, TEXT("hTop not NULL, but empty tree"));
        pTree->hTop = NULL;

        AssertMsg(pTree->hCaret == NULL, TEXT("hCaret not NULL, but empty tree"));
        pTree->hCaret = NULL;

        pTree->fNameEditPending = FALSE;
        pTree->cxMax = 0;
        pTree->xPos = 0;

        // the invisible root
        ASSERT(pTree->hRoot->hNext == NULL);            
        pTree->hRoot->hNext = NULL;
        ASSERT(pTree->hRoot->hParent == NULL);          
        pTree->hRoot->hParent = NULL;
        ASSERT(pTree->hRoot->hKids == NULL);            
        pTree->hRoot->hKids = NULL;
        ASSERT(pTree->hRoot->state & TVIS_EXPANDED);
        pTree->hRoot->state |= (TVIS_EXPANDED | TVIS_EXPANDEDONCE);
        ASSERT(pTree->hRoot->iLevel == (BYTE)-1);
        pTree->hRoot->iLevel = (BYTE) -1;
        ASSERT(pTree->hRoot->iShownIndex == (WORD)-1);
        pTree->hRoot->iShownIndex = (WORD) -1;
    }

    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  Creates the hidden root node for the tree -- all items will trace up to
//  this root, and the first child of the root is the first item in the tree.
//
//  sets hRoot
//
// ----------------------------------------------------------------------------

BOOL NEAR PASCAL TV_CreateRoot(PTREE pTree)
{
    TREEITEM FAR * hRoot = ControlAlloc(pTree->hheap, sizeof(TREEITEM));
    if (!hRoot)
        return FALSE;

    // hRoot->hNext        = NULL;
    // hRoot->hKids        = NULL;
    // hRoot->hParent      = NULL;
    hRoot->iLevel = (BYTE) -1;
    hRoot->state = (TVIS_EXPANDED | TVIS_EXPANDEDONCE);
    hRoot->iShownIndex = (WORD)-1;
    hRoot->wSignature      = TV_SIG;

    pTree->hRoot = hRoot;

    // OLEACC asks for the text of the root item (d'oh!)
    Str_Set(&hRoot->lpstr, c_szNULL);
    return TRUE;
}

#ifdef DEBUG

void NEAR DumpItem(TREEITEM FAR *hItem)
{
    LPTSTR p;

    if (hItem->lpstr == LPSTR_TEXTCALLBACK)
        p = TEXT("(callback)");
    else if (hItem->lpstr == NULL)
        p = TEXT("(null)");
    else
        p = hItem->lpstr;

    TraceMsg(TF_TREEVIEW, "%s", p);
    TraceMsg(TF_TREEVIEW, "\tstate:%4.4x show index:%3d level:%2d kids:%ld lparam:%4.4x",
            hItem->state, hItem->iShownIndex,
            hItem->iLevel, hItem->fKids, hItem->lParam);

}

#else
#define DumpItem(hItem)
#endif


// ----------------------------------------------------------------------------
//
//  Adds the item described by the given arguments to the tree.
//
//  sets hTop, cItems
//
// ----------------------------------------------------------------------------

TREEITEM FAR * NEAR TV_InsertItemA(PTREE pTree, LPTV_INSERTSTRUCTA lpis) 
{
    LPSTR pszA = NULL;
    TREEITEM *ptvi;

    //HACK Alert!  This code assumes that TV_INSERTSTRUCTA is exactly the same
    // as TV_INSERTSTRUCTW except for the text pointer in the TVITEM
    COMPILETIME_ASSERT(sizeof(TV_INSERTSTRUCTA) == sizeof(TV_INSERTSTRUCTW));

    if (!IsFlagPtr(lpis) && (lpis->DUMMYUNION_MEMBER(item).mask & TVIF_TEXT) && !IsFlagPtr(lpis->DUMMYUNION_MEMBER(item).pszText)) {

        pszA = lpis->DUMMYUNION_MEMBER(item).pszText;
        lpis->DUMMYUNION_MEMBER(item).pszText = (LPSTR)ProduceWFromA(pTree->ci.uiCodePage, lpis->DUMMYUNION_MEMBER(item).pszText);

        if (lpis->DUMMYUNION_MEMBER(item).pszText == NULL) {
            lpis->DUMMYUNION_MEMBER(item).pszText = pszA;
            return NULL;
        }
    }

    ptvi = TV_InsertItem( pTree, (LPTV_INSERTSTRUCTW)lpis );

    if (pszA) {
        FreeProducedString(lpis->DUMMYUNION_MEMBER(item).pszText);
        lpis->DUMMYUNION_MEMBER(item).pszText = pszA;
    }

    return ptvi;
}

TREEITEM FAR * NEAR TV_InsertItem(PTREE pTree, LPTV_INSERTSTRUCT lpis)
{
    TREEITEM FAR *hNewItem, FAR *hItem;
    TREEITEM FAR *hParent;
    TREEITEM FAR *hInsertAfter;
    UINT mask;

    if (!lpis)
        return NULL; //BUGBUG: Validate LPTV_INSERTSTRUCT

    // initialize _after_ the check for NULL!
    hParent      = lpis->hParent;
    hInsertAfter = lpis->hInsertAfter;
    mask         = lpis->DUMMYUNION_MEMBER(item).mask;
           
    // don't allow undefined bits
    AssertMsg((lpis->DUMMYUNION_MEMBER(item).mask & ~TVIF_ALL) == 0, TEXT("Invalid TVIF mask specified"));
    if (mask & ~TVIF_ALL) {
        // if they used bogus bits,
        // restrict to win95 bits only
        // I'd like to fail completely, but for win95 compat, we can't
        //
        // this fixes  QuaterDesk's CleanSweep which has bogus garbage on the stack for a mask
        mask = (TVIF_WIN95 & mask);
    }

    TV_DismissEdit(pTree, FALSE);

    //
    //  Zillions of apps pass garbage for hInsertAfter, so don't fail if
    //  it's invalid.  Fortunately, we never dereference hInsertAfter, so
    //  garbage is okay.

    if (!ValidateTreeItem(hParent, VTI_NULLOK))     // NULL means TVI_ROOT
        return NULL;

    DBG_ValidateTreeItem(hInsertAfter, 0);

    hNewItem = ControlAlloc(pTree->hheap, sizeof(TREEITEM));
    if (!hNewItem)
    {
        TraceMsg(TF_ERROR, "TreeView: Out of memory");
        return NULL;
    }

    hNewItem->wSignature = TV_SIG;

    if (mask & TVIF_TEXT)
    {
        //
        // We will setup the text string next, before we link our self in
        // as to handle the case where we run out of memory and need to
        // destroy ourself without having to unlink.
        //
        if (!lpis->DUMMYUNION_MEMBER(item).pszText)
        {
            hNewItem->lpstr = LPSTR_TEXTCALLBACK;
        }
        else
        {
            if (!Str_Set(&hNewItem->lpstr, lpis->DUMMYUNION_MEMBER(item).pszText))
            {
                // Memory allocation failure...
                TraceMsg(TF_ERROR, "TreeView: Out of memory");
                TV_MarkAsDead(hNewItem);
                ControlFree(pTree->hheap, hNewItem);
                return NULL;
            }
        }
    } else
        Str_Set(&hNewItem->lpstr, c_szNULL);

    AssertMsg(hNewItem->lpstr != NULL, TEXT("Item added with NULL text"));

    if ((hParent == NULL) || (hParent == TVI_ROOT))
    {
        hParent = pTree->hRoot;
        if (!pTree->hTop)
            pTree->hTop = hNewItem;
    }
    else if (!pTree->hRoot->hKids)
    {
        TV_MarkAsDead(hNewItem);
        ControlFree(pTree->hheap, hNewItem);
        return NULL;
    }

    // We will do the sort later, so we can handle TEXTCALLBACK things
    if ((hInsertAfter == TVI_FIRST || hInsertAfter == TVI_SORT) || !hParent->hKids)
    {
        hNewItem->hNext = hParent->hKids;
        hParent->hKids = hNewItem;
    }
    else
    {
        // BUGBUG: we should cache the last insert after pointer to try to
        // catch the case of consecutive adds to the end of a node

        if (hInsertAfter == TVI_LAST)
            for (hItem = hParent->hKids; hItem->hNext; hItem = hItem->hNext)
                ;
        else
        {
            for (hItem = hParent->hKids; hItem->hNext; hItem = hItem->hNext)
                if (hItem == hInsertAfter)
                    break;
        }

        hNewItem->hNext = hItem->hNext;
        hItem->hNext = hNewItem;
    }

    // hNewItem->hKids     = NULL;
    hNewItem->hParent   = hParent;
    hNewItem->iLevel    = hParent->iLevel + 1;
    // hNewItem->iWidth = 0;
    // hNewItem->state = 0;
    if ((mask & TVIF_INTEGRAL) &&
        LOWORD(lpis->DUMMYUNION_MEMBER(itemex).iIntegral) > 0) {
        hNewItem->iIntegral = LOWORD(lpis->DUMMYUNION_MEMBER(itemex).iIntegral);
    } else {
#ifdef CHEEDEBUG
        // just to get some variety
        hNewItem->iIntegral = ((((int)hNewItem) /100) % 2) + 1;
#else
        hNewItem->iIntegral = 1;
#endif
    }
    
    if (pTree->hTop == hNewItem)
        hNewItem->iShownIndex = 0; // calc me please!
    else
        hNewItem->iShownIndex = (WORD)-1; // calc me please!

    if (mask & TVIF_IMAGE)
        hNewItem->iImage = (WORD) lpis->DUMMYUNION_MEMBER(item).iImage;

    if (mask & TVIF_SELECTEDIMAGE)
        hNewItem->iSelectedImage = (WORD) lpis->DUMMYUNION_MEMBER(item).iSelectedImage;

    if (mask & TVIF_PARAM)
        hNewItem->lParam = lpis->DUMMYUNION_MEMBER(item).lParam;

    if (mask & TVIF_STATE)
        hNewItem->state = lpis->DUMMYUNION_MEMBER(item).state & lpis->DUMMYUNION_MEMBER(item).stateMask;
    
    // if we're in check box mode, inforce that it has a check box
    if (pTree->ci.style & TVS_CHECKBOXES) {
        if ((hNewItem->state & TVIS_STATEIMAGEMASK) == 0) {
            hNewItem->state |= INDEXTOSTATEIMAGEMASK(1);
        }
    }
    
    
    

    if ((hNewItem->state & TVIS_BOLD) && !pTree->hFontBold) //$BOLD
        TV_CreateBoldFont(pTree);                           //$BOLD

    // TraceMsg(TF_TRACE, "Tree: Inserting i = %d state = %d", TV_StateIndex(&lpis->item), lpis->item.state);

    if (mask & TVIF_CHILDREN) {
        switch (lpis->DUMMYUNION_MEMBER(item).cChildren) {
        case I_CHILDRENCALLBACK:
            hNewItem->fKids = KIDS_CALLBACK;
            break;

        case 0:
            hNewItem->fKids = KIDS_FORCE_NO;
            break;

        default:
            hNewItem->fKids = KIDS_FORCE_YES;
            break;
        }
    }

    // accept state bits on create?
    // mask & TVIF_STATE

    pTree->cItems++;

    // I don't want to do any callbacks until the item is completed
    // so sorting waits until the end
    // special case an only child for speed
    // (hKids && hKids->hNext means more than one child)
    if ((hInsertAfter == TVI_SORT) && hParent->hKids && hParent->hKids->hNext)
    {
        TVITEMEX sThisItem, sNextItem;
        TCHAR szThis[64], szNext[64];    // BUGBUG: these are too small

        sThisItem.pszText = szThis;
        sThisItem.cchTextMax  = ARRAYSIZE(szThis);
        TV_GetItem(pTree, hNewItem, TVIF_TEXT, &sThisItem);

        // We know that the first kid of hParent is hNewItem
        for (hItem = hNewItem->hNext; hItem; hItem = hItem->hNext)
        {

            sNextItem.pszText = szNext;
            sNextItem.cchTextMax  = ARRAYSIZE(szNext);

            TV_GetItem(pTree, hItem, TVIF_TEXT, &sNextItem);

            if (lstrcmpi(sThisItem.pszText, sNextItem.pszText) < 0)
                break;

            hInsertAfter = hItem;
        }

        // Check if this is still the first item
        if (hInsertAfter != TVI_SORT)
        {
            // Move this item from the beginning to where it
            // should be
            hParent->hKids = hNewItem->hNext;
            hNewItem->hNext = hInsertAfter->hNext;
            hInsertAfter->hNext = hNewItem;
        }
    }

    
    if ((hNewItem->hNext == pTree->hTop) && !pTree->fVert) {
        
        // there's no scrollbars and we got added before the top 
        // item.  we're now the top.
        hNewItem->iShownIndex = 0;
        pTree->hTop = hNewItem;
    }

    if (pTree->fRedraw)
    {
        BOOL fVert = pTree->fVert;
        RECT rc;
        RECT rc2;

        if (TV_ScrollBarsAfterAdd(pTree, hNewItem)) {
            // scroll everything down one
            if (ITEM_VISIBLE(hNewItem)) {
                int iTop = hNewItem->iShownIndex - pTree->hTop->iShownIndex;

                // if there wasn't a scrollbar and we're the 0th item,
                // TV_ScrollBarsAfterAdd already scrolled us
                if (iTop > 0 || !fVert)
                    TV_ScrollItems(pTree, hNewItem->iIntegral, iTop + hNewItem->iIntegral - 1, TRUE);
            }
        }

        // connect the lines, add the buttons, etc. on the item above
        // TV_GetPrevVisItem only works after TV_Scroll* stuff is done
            
        if (TV_GetItemRect(pTree, hNewItem, &rc, FALSE)) {

            // find the previous sibling or the parent if no prev sib.
            if (hParent->hKids == hNewItem) {
                hItem = hParent;
            } else {
                hItem = hParent->hKids;
                while ( hItem->hNext != hNewItem ) {
                    ASSERT(hItem->hNext);
                    hItem = hItem->hNext;
                }
            }

            // invalidate from there to the new one
            if (TV_GetItemRect(pTree, hItem, &rc2, FALSE)) {
                rc.top = rc2.top;
            }
            RedrawWindow(pTree->ci.hwnd, &rc, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }

    // DumpItem(hNewItem);

    MyNotifyWinEvent(EVENT_OBJECT_CREATE, pTree->ci.hwnd, OBJID_CLIENT, (LONG_PTR)hNewItem);

    if (pTree->hToolTip)
    {
        TV_PopBubble(pTree);
    }

    return hNewItem;
}

void TV_DeleteHotFonts(PTREE pTree)
{
    if (pTree->hFontHot)
        DeleteObject(pTree->hFontHot);
    
    if (pTree->hFontBoldHot)
        DeleteObject(pTree->hFontBoldHot);
    
    pTree->hFontHot = pTree->hFontBoldHot = NULL;
}

// ----------------------------------------------------------------------------
//
//  Frees all allocated memory and objects associated with the tree.
//
// ----------------------------------------------------------------------------

void NEAR TV_DestroyTree(PTREE pTree)
{
    HWND hwnd = pTree->ci.hwnd;

    ASSERT(pTree->hRoot);

    pTree->fRedraw = FALSE;
    
    TV_OnSetBkColor(pTree, (COLORREF)-1);
    
    if (pTree->hCurHot)
        DestroyCursor(pTree->hCurHot);

    if (IsWindow(pTree->hwndToolTips)) {
        DestroyWindow(pTree->hwndToolTips);
    }

    pTree->hwndToolTips = NULL;

    if (IsWindow(pTree->hwndEdit)) {
        DestroyWindow(pTree->hwndEdit);
    }
    pTree->hwndEdit = NULL;


    // BUGUBG: send TVN_DELETEALLITEMS and TVDI_NONOTIFY if they respond
    TV_DeleteItem(pTree, pTree->hRoot, TVDI_CHILDRENONLY | TVDI_NOSELCHANGE);

    if (pTree->hRoot)
    {
        Str_Set(&pTree->hRoot->lpstr, NULL);

        // No point in marking dead since the entire control is going away
        ControlFree(pTree->hheap, pTree->hRoot);
    }

    if (pTree->hdcBits)
    {
        if (pTree->hBmp)
        {
            SelectObject(pTree->hdcBits, pTree->hStartBmp);
            DeleteObject(pTree->hBmp);
        }

        DeleteDC(pTree->hdcBits);
    }

    if (pTree->fCreatedFont && pTree->hFont)
        DeleteObject(pTree->hFont);

    if (pTree->hFontBold)                    //$BOLD
        DeleteObject(pTree->hFontBold);      //$BOLD
    Str_Set(&pTree->pszTip, NULL);

    if (pTree->pszTipA)
        LocalFree(pTree->pszTipA);

    TV_DeleteHotFonts(pTree);

    if (pTree->hdpaWatch)
        DPA_Destroy(pTree->hdpaWatch);

    IncrementSearchFree(&pTree->is);

    NearFree(pTree);

    // Don't try to use this var when window is destroyed...
    SetWindowInt(hwnd, 0, 0);
}

void TV_CreateToolTips(PTREE pTree);

// ----------------------------------------------------------------------------
//
//  Allocates space for the tree and initializes the tree's data
//
// ----------------------------------------------------------------------------

LRESULT NEAR TV_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreate)
{
    PTREE pTree = NearAlloc(sizeof(TREE));

    if (!pTree)
        return -1;      // fail the create window

    pTree->hheap = GetProcessHeap();

    if (!TV_CreateRoot(pTree)) {
        NearFree((HLOCAL)pTree);
        return -1;      // fail the create window
    }

    pTree->hdpaWatch = DPA_Create(8);
    if (!pTree->hdpaWatch) {
        // No point in marking dead since the entire control is going away
        ControlFree(pTree->hheap, pTree->hRoot);
        NearFree((HLOCAL)pTree);
        return -1;      // fail the create window
    }

    SetWindowPtr(hwnd, 0, pTree);

    CIInitialize(&pTree->ci, hwnd, lpCreate);

    if (lpCreate->dwExStyle & WS_EX_RTLREADING)
    {
        pTree->ci.style |= TVS_RTLREADING;
    }
    
#ifdef DEBUG
    if (GetAsyncKeyState(VK_SHIFT) < 0 &&
        GetAsyncKeyState(VK_CONTROL) < 0) {
        pTree->ci.style |= TVS_SHOWSELALWAYS; // | TVS_CHECKBOXES;
        SetWindowLong(pTree->ci.hwnd, GWL_STYLE, pTree->ci.style);
    }
#endif
    pTree->fRedraw    = TRUE;
    pTree->clrBk = (COLORREF)-1;
    pTree->clrText = (COLORREF)-1;
    pTree->clrim = CLR_DEFAULT;
    pTree->clrLine = CLR_DEFAULT;

    // pTree->fHorz        = FALSE;
    // pTree->fVert        = FALSE;
    // pTree->fFocus       = FALSE;
    // pTree->fNameEditPending = FALSE;
    // pTree->cxMax        = 0;
    // pTree->cxWnd        = 0;
    // pTree->cyWnd        = 0;
    // pTree->hTop         = NULL;
    // pTree->hCaret       = NULL;
    // pTree->hDropTarget  = NULL;
    // pTree->hOldDrop     = NULL;
    // pTree->cItems       = 0;
    // pTree->cShowing     = 0;
    pTree->cFullVisible = 1;
    // pTree->hdcBits      = NULL;
    // pTree->hBmp         = NULL;
    // pTree->hbrBk        = NULL;
    // pTree->xPos         = 0;
    // pTree->cxIndent     = 0; // init this for real in TV_OnSetFont()
    // pTree->dwCDDepth    = 0;
    pTree->uMaxScrollTime = SSI_DEFAULT;
    
    TV_OnSetFont(pTree, NULL, TRUE);
    
    // You cannot combine TVS_HASLINES and TVS_FULLROWSELECT
    // because it doesn't work
    if (pTree->ci.style & TVS_HASLINES) {
        if (pTree->ci.style & TVS_FULLROWSELECT) {
            DebugMsg(DM_ERROR, TEXT("Cannot combine TVS_HASLINES and TVS_FULLROWSELECT"));
        }
        pTree->ci.style &= ~TVS_FULLROWSELECT;
    }

    if (!(pTree->ci.style & TVS_NOTOOLTIPS)) {
        TV_CreateToolTips(pTree);
    }

    SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
    SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);

    return 0;   // success
}


void TV_CreateToolTips(PTREE pTree)
{
    DWORD exStyle = 0;

    if (pTree->ci.style & TVS_RTLREADING) 
    {
        exStyle |= WS_EX_RTLREADING;
    }

    pTree->hwndToolTips = CreateWindowEx(exStyle, c_szSToolTipsClass, NULL,
                                       WS_POPUP | TTS_NOPREFIX,
                                       CW_USEDEFAULT, CW_USEDEFAULT,
                                       CW_USEDEFAULT, CW_USEDEFAULT,
                                       pTree->ci.hwnd, NULL, HINST_THISDLL,
                                       NULL);
    if (pTree->hwndToolTips)
    {
        TOOLINFO ti;

        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_IDISHWND | TTF_TRANSPARENT;
        ti.hwnd = pTree->ci.hwnd;
        ti.uId = (UINT_PTR)pTree->ci.hwnd; 
        ti.lpszText = LPSTR_TEXTCALLBACK;
        ti.lParam = 0;
        SendMessage(pTree->hwndToolTips, TTM_ADDTOOL, 0,
                    (LPARAM)(LPTOOLINFO)&ti);
        SendMessage(pTree->hwndToolTips, WM_SETFONT, (WPARAM)pTree->hFont, (LPARAM)TRUE);
        SendMessage(pTree->hwndToolTips, TTM_SETDELAYTIME, TTDT_INITIAL, (LPARAM)500);
    }
    else
    {
        pTree->ci.style |= (TVS_NOTOOLTIPS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\updown.c ===
#include "ctlspriv.h"

/////////////////////////////////////////////////////////////////////////////
//
// updown.c : A micro-scrollbar control; useful for increment/decrement.
//
/////////////////////////////////////////////////////////////////////////////

#define NUM_UDACCELS 3

#define DONTCARE    0
#define SIGNED      1
#define UNSIGNED    2

#define UD_HITNOWHERE 0
#define UD_HITDOWN 1
#define UD_HITUP 2

typedef struct {
    CONTROLINFO ci;
    HWND    hwndBuddy;
    unsigned fUp        : 1;
    unsigned fDown      : 1;
    unsigned fUnsigned  : 1;    // BUGBUG: no way to turn this on
    unsigned fSharedBorder  : 1;
    unsigned fSunkenBorder  : 1;
    unsigned fUpDownDestroyed : 1;  // This tells the buddy that updown destoryed.
    BOOL     fTrackSet: 1;
    unsigned fSubclassed:1;     // did we subclass the buddy?

    UINT     nBase;
    int      nUpper;
    int      nLower;
    int      nPos;
    UINT     uClass;
    BOOL     bDown;
    DWORD    dwStart;
    UINT     nAccel;
    UDACCEL  udAccel[NUM_UDACCELS];
    UINT        uHot;
    int      cReenterSetint;    // To avoid recursion death in setint()
} UDSTATE, NEAR *PUDSTATE;


// Constants:
//
#define CLASS_UNKNOWN   0
#define CLASS_EDIT      1
#define CLASS_LISTBOX   2

#define MAX_INTLENGTH   18 // big enough for all intl stuff, too

// this is the space to the left and right of the arrow (in pixels)
#define XBORDER 0

#define BASE_DECIMAL    10
#define BASE_HEX        16

#define CURSORMAX       1300

// Declarations:
//
LRESULT CALLBACK ArrowKeyProc(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData);

/////////////////////////////////////////////////////////////////////////////

//
// ***** Internal workhorses *****
//


// Validates the buddy.
//
void NEAR PASCAL isgoodbuddy(PUDSTATE np)
{
    if (!np->hwndBuddy)
        return;
    if (!IsWindow(np->hwndBuddy))
    {
        np->hwndBuddy = NULL;
        np->uClass = CLASS_UNKNOWN;
    }
    if (GetParent(np->hwndBuddy) != np->ci.hwndParent)
    {
        np->hwndBuddy = NULL;
        np->uClass = CLASS_UNKNOWN;
    }
}

// Picks a good buddy.
//
void NEAR PASCAL pickbuddy(PUDSTATE np)
{
    if (np->ci.style & UDS_AUTOBUDDY)
        np->hwndBuddy = GetWindow(np->ci.hwnd, GW_HWNDPREV);
}

void NEAR PASCAL unachor(PUDSTATE np)
{
    RECT rc;
    RECT rcBuddy;
    RECT rcUD;

    if ( np->hwndBuddy && (np->ci.style & (UDS_ALIGNLEFT | UDS_ALIGNRIGHT))) {
        GetWindowRect(np->hwndBuddy, &rcBuddy);
        GetWindowRect(np->ci.hwnd, &rcUD);
        UnionRect(&rc, &rcUD, &rcBuddy);
        MapWindowRect(NULL, np->ci.hwndParent, &rc);
        MoveWindow(np->hwndBuddy, rc.left, rc.top,
                                rc.right - rc.left, rc.bottom - rc.top, FALSE);

    }
}

// Anchor this control to the buddy's edge, if appropriate.
//
void NEAR PASCAL anchor(PUDSTATE np)
{
    BOOL bAlignToBuddy;
    int nOver = 0,  nHasBorder;
    RECT rc, rcBuddy;
    int nHeight, nWidth;

    np->fSharedBorder = FALSE;

    isgoodbuddy(np);
    nHasBorder = (np->ci.style & WS_BORDER) == WS_BORDER;

    bAlignToBuddy = np->hwndBuddy && (np->ci.style & (UDS_ALIGNLEFT | UDS_ALIGNRIGHT));

    if (bAlignToBuddy)
    {
        if ((np->uClass == CLASS_EDIT) ||
                (GetWindowLong(np->hwndBuddy, GWL_EXSTYLE) & WS_EX_CLIENTEDGE))
        {
            np->fSunkenBorder = TRUE;
        }

        GetWindowRect(np->hwndBuddy, &rc);

        if ((np->uClass == CLASS_EDIT) || (GetWindowLong(np->hwndBuddy, GWL_STYLE) & WS_BORDER))
        {
            // BUGBUG for full generalization, should handle border AND clientedge

            nOver = g_cxBorder * (np->fSunkenBorder ? 2 : 1);
            np->fSharedBorder = TRUE;

            // turn off border styles...
            np->ci.style &= ~WS_BORDER;

            SetWindowLong(np->ci.hwnd, GWL_STYLE, np->ci.style);
            SetWindowLong(np->ci.hwnd, GWL_EXSTYLE, GetWindowLong(np->ci.hwnd, GWL_EXSTYLE) & ~(WS_EX_CLIENTEDGE));
        }
    }
    else
    {
        GetWindowRect(np->ci.hwnd, &rc);
    }

    nHeight = rc.bottom - rc.top;
    nWidth = rc.right - rc.left;

    //
    // If the parent is RTL mirrored, then placement of the
    // child (i.e. anchor point) should be relative to the visual 
    // right edge (near edge). [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(np->ci.hwndParent))
    {
        rc.left = rc.right;
    }

    ScreenToClient(np->ci.hwndParent, (LPPOINT)&rc.left);
    rc.right = rc.left + nWidth;

    if (bAlignToBuddy)
    {
        nWidth = g_cxVScroll - g_cxBorder;
        if (nWidth > nHeight) {             // don't let the aspect ratio
            nWidth = nHeight;               // get worse than square
        }
        nWidth += nOver;
        rcBuddy = rc;

        if (np->ci.style & UDS_ALIGNLEFT)
        {
            // size buddy to right
            rcBuddy.left += nWidth - nOver;
            rc.right = rc.left + nWidth;
        }
        else
        {
            // size buddy to left
            rcBuddy.right -= nWidth - nOver;
            rc.left = rc.right - nWidth;
        }
        // size the buddy to fit the updown on the appropriate side
        MoveWindow(np->hwndBuddy, rcBuddy.left, rcBuddy.top,
                                rcBuddy.right - rcBuddy.left, nHeight, TRUE);
    }
    else if (!(np->ci.style & UDS_HORZ))
    {
        nWidth = g_cxVScroll + 2 * nHasBorder;
    }

    SetWindowPos(np->ci.hwnd, NULL, rc.left, rc.top, nWidth, nHeight,
        SWP_DRAWFRAME | SWP_NOZORDER | SWP_NOACTIVATE);
}


// Use this to make any and all comparisons involving the nPos,
// nUpper or nLower fields of the PUDSTATE. It determines
// whether to do a signed or unsigned comparison and returns
//  > 0 for (x > y)
//  < 0 for (x < y)
// == 0 for (x == y).
//
// fCompareType is SIGNED to force a signed comparison,
// fCompareType is UNSIGNED to force an unsigned comparison,
// fCompareType is DONTCARE to use the np->fUnsigned flag to decide.
//
// In comments, comparison operators are suffixed with "D", "U" or "S"
// to emphasize whether the comparison is DONTCARE, UNSIGNED, or SIGNED.
// For example "x <U y" means "x < y as UNSIGNED".

int NEAR PASCAL compare(PUDSTATE np, int x, int y, UINT fCompareType)
{
    if ((fCompareType == UNSIGNED) || ((np->fUnsigned) && !(fCompareType == SIGNED)) )
    {
        // Do unsigned comparisons
        if ((UINT)x > (UINT)y)
            return 1;
        else if ((UINT)x < (UINT)y)
            return -1;
    }
    else
    {
        // Do signed comparisons
        if (x > y)
            return 1;
        else if (x < y)
            return -1;
    }

    return 0;
}

// Use this after any pos change to make sure pos stays in range.
// Wraps as necessary.
// returns nonzero if the current value was out of range (and therefore
// got changed so it fit into range again)
//
// BUGBUG -- doesn't handle values that exceed MAXINT or MININT.

BOOL NEAR PASCAL nudge(PUDSTATE np)
{
    BOOL bOutOfRange = TRUE;
    int min = np->nUpper;
    int max = np->nLower;

    // if (max <D min) swap(min, max)
    if (compare(np,max,min, DONTCARE) < 0)
    {
        int t;
        t = min;
        min = max;
        max = t;
    }


    if (np->ci.style & UDS_WRAP)
    {
        // if (nPos <D min) nPos = max      -- wrap from below to above
        // else if (nPos >D max) nPos = min -- wrap from above to below

        if ((compare(np, np->nPos, min, DONTCARE) < 0))
            np->nPos = max;
        else if ((compare(np, np->nPos, max, DONTCARE) > 0))
            np->nPos = min;
        else bOutOfRange = FALSE;
    }
    else
    {
        // if (nPos <D min) nPos = min      -- pin at min
        // else if (nPos >D max) nPos = max -- pin at max

        if (compare(np,np->nPos,min, DONTCARE) < 0)
            np->nPos = min;
        else if (compare(np,np->nPos,max, DONTCARE) > 0)
            np->nPos = max;
        else
            bOutOfRange = FALSE;
    }

    return(bOutOfRange);
}

// Sets the state of the buttons (pushed, released).
//
void NEAR PASCAL squish(PUDSTATE np, UINT bTop, UINT bBottom)
{
    BOOL bInvalidate = FALSE;

    if (np->nUpper == np->nLower || !IsWindowEnabled(np->ci.hwnd))
    {
        bTop = FALSE;
        bBottom = FALSE;
    }
    else
    {
        bTop = !!bTop;
        bBottom = !!bBottom;
    }

    if (np->fUp != bTop)
    {
        np->fUp = bTop;
        bInvalidate = TRUE;

        MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, np->ci.hwnd, OBJID_CLIENT, 1);
    }

    if (np->fDown != bBottom)
    {
        np->fDown = bBottom;
        bInvalidate = TRUE;

        MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, np->ci.hwnd, OBJID_CLIENT, 2);
    }

    if (bInvalidate)
    {
        np->dwStart = GetTickCount();
        InvalidateRect(np->ci.hwnd, NULL, FALSE);
    }
}

// Gets the intl 1000 separator
//
void NEAR PASCAL getthousands(LPTSTR pszThousand)
{
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, pszThousand, 2))
    {
        pszThousand[0] = TEXT(',');
        pszThousand[1] = TEXT('\0');
    }
}

//
//  Obtain NLS info about how numbers should be grouped.
//
//  The annoying thing is that LOCALE_SGROUPING and NUMBERFORMAT
//  have different ways of specifying number grouping.
//
//          LOCALE      NUMBERFMT      Sample   Country
//
//          3;0         3           1,234,567   United States
//          3;2;0       32          12,34,567   India
//          3           30           1234,567   ??
//
//  Not my idea.  That's the way it works.
//
//  Bonus treat - Win9x doesn't support complex number formats,
//  so we return only the first number.
//
UINT getgrouping(void)
{
    UINT grouping;
    LPTSTR psz;
    TCHAR szGrouping[32];

    // If no locale info, then assume Western style thousands
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, ARRAYSIZE(szGrouping)))
        return 3;

    grouping = 0;
    psz = szGrouping;
    for (;;)
    {
        if (*psz == '0') break;             // zero - stop

        else if ((UINT)(*psz - '0') < 10)   // digit - accumulate it
            grouping = grouping * 10 + (UINT)(*psz - '0');

        else if (*psz)                      // punctuation - ignore it
            { }

        else                                // end of string, no "0" found
        {
            grouping = grouping * 10;       // put zero on end (see examples)
            break;                          // and finished
        }

        psz++;
    }

    return grouping;
}

// Gets the caption of the buddy
// Returns the current position of the updown control
// and sets *pfError on error.
//
LRESULT NEAR PASCAL getint(PUDSTATE np, BOOL *pfError)
{
    TCHAR szInt[MAX_INTLENGTH]; // big enough for all intl stuff, too
    TCHAR szThousand[2];
    TCHAR cTemp;
    int nPos;
    int sign = 1;
    LPTSTR p = szInt;
    BOOL bInValid = TRUE;

    isgoodbuddy(np);
    if (np->hwndBuddy && np->ci.style & UDS_SETBUDDYINT)
    {
        if (np->uClass == CLASS_LISTBOX)
        {
            np->nPos = (int)SendMessage(np->hwndBuddy, LB_GETCURSEL, 0, 0L);
            bInValid = nudge(np);
        }
        else
        {
            GetWindowText(np->hwndBuddy, szInt, ARRAYSIZE(szInt));

            switch (np->nBase)
            {
                case BASE_HEX:
                    if ((*p == TEXT('x')) || (*p == TEXT('X')))
                        // ignore first character
                        p++;
                    else if ((*p == TEXT('0')) && ((*(p + 1) == TEXT('x')) || (*(p + 1) == TEXT('X'))))
                        // ignore first two characters (TEXT("0x") or "0X")
                        p += 2;

                    for (nPos = 0; *p; p++)
                    {
                        if ((*p >= TEXT('A')) && (*p <= TEXT('F')))
                            cTemp = (TCHAR)(*p - TEXT('A') + 10);
                        else if ((*p >= TEXT('a')) && (*p <= TEXT('f')))
                            cTemp = (TCHAR)(*p - TEXT('a') + 10);
                        else if ((*p >= TEXT('0')) && (*p <= TEXT('9')))
                            cTemp = (TCHAR)(*p - TEXT('0'));
                        else
                            goto BadValue;

                        nPos = (nPos * 16) + cTemp;
                    }
                    np->nPos = nPos;
                    break;

                case BASE_DECIMAL:
        default:
                    getthousands(szThousand);
                    if (*p == TEXT('-') && !np->fUnsigned)
                    {
                        sign = -1;
                        ++p;
                    }

                    for (nPos=0; *p; p++)
                    {
                        cTemp = *p;

                        // If there is a thousand separator, just ignore it.
                        // Do not validate that it's in the right place,
                        // because it prevents the user from editing the
                        // middle of a number.
                        if (cTemp == szThousand[0])
                        {
                            continue;
                        }

                        cTemp -= TEXT('0');
                        if ((UINT)cTemp > 9)
                        {
                            goto BadValue;
                        }
                        nPos = (nPos*10) + cTemp;
                    }

                    np->nPos = nPos*sign;
                    break;
            }
            bInValid = nudge(np);
        }
    }

BadValue:
    if (pfError)
        *pfError = bInValid;
    return np->nPos;
}

// Sets the caption of the buddy if appropriate.
//
void NEAR PASCAL setint(PUDSTATE np)
{
    TCHAR szInt[MAX_INTLENGTH];
    TCHAR szThousand[2];
    int pos = np->nPos;

    isgoodbuddy(np);
    if (np->hwndBuddy && np->ci.style & UDS_SETBUDDYINT)
    {
        BOOL fError;
        /*
         * If we have reentered, then maybe the app has set up a loop.
         * Check to see if the value has actually changed.  If not,
         * then there's no need to set it again.  This breaks the
         * recursion.
         */
        if (np->cReenterSetint && (LRESULT)pos==getint(np, &fError) && !fError)
        {
            return;
        }
        np->nPos = pos;

        np->cReenterSetint++;

        if (np->uClass == CLASS_LISTBOX)
        {
            SendMessage(np->hwndBuddy, LB_SETCURSEL, pos, 0L);
            FORWARD_WM_COMMAND(GetParent(np->hwndBuddy),
                                GetDlgCtrlID(np->hwndBuddy),
                np->hwndBuddy, LBN_SELCHANGE, SendMessage);
        }
        else
        {
            switch (np->nBase)
            {
                case BASE_HEX:

                    if ((np->nUpper | np->nLower) >= 0x00010000)
                    {
                        StringCchPrintf(szInt, ARRAYSIZE(szInt), TEXT("0x%08X"), pos);
                    }
                    else
                    {
                        StringCchPrintf(szInt, ARRAYSIZE(szInt), TEXT("0x%04X"), pos);
                    }
                    break;

                case BASE_DECIMAL:
                default:
                {
                    LPTSTR pszInt = szInt;

                    if (pos < 0 && !np->fUnsigned)
                    {
                        *pszInt++ = TEXT('-');
                        pos = -pos;
                    }

                    if (pos >= 1000 && !(np->ci.style & UDS_NOTHOUSANDS))
                    {
                        TCHAR szFmt[MAX_INTLENGTH];

                        NUMBERFMT nf;
                        nf.NumDigits     = 0;               // no digits after decimal point
                        nf.LeadingZero   = 0;               // no leading zeros
                        nf.Grouping      = getgrouping();
                        nf.lpDecimalSep  = TEXT("");        // no decimal point
                        nf.lpThousandSep = szThousand;
                        nf.NegativeOrder = 0;               // (not used - we always pass positive numbers)

                        getthousands(szThousand);

                        StringCchPrintf(szFmt, ARRAYSIZE(szFmt), TEXT("%u"), pos);
                        GetNumberFormat(LOCALE_USER_DEFAULT, 
                                        0,
                                        szFmt,
                                        &nf,
                                        pszInt,
                                        ARRAYSIZE(szInt) - ((pszInt == szInt) ? 0 : 1));
                    }
                    else
                    {
                        StringCchPrintf(pszInt,
                                        ARRAYSIZE(szInt) - ((pszInt == szInt) ? 0 : 1),
                                        TEXT("%u"),
                                        pos);
                    }
                    break;
                }
            }

            SetWindowText(np->hwndBuddy, szInt);
        }

        np->cReenterSetint;
    }
}

// Use this to click the pos up or down by one.
//
void NEAR PASCAL bump(PUDSTATE np)
{
    BOOL bChanged = FALSE;
    UINT uElapsed, increment;
    int direction, i;

    /* So I'm not really getting seconds here; it's close enough, and
     * dividing by 1024 keeps __aFuldiv from being needed.
     */
    uElapsed = (UINT)((GetTickCount() - np->dwStart) / 1024);

    increment = np->udAccel[0].nInc;
    for (i=np->nAccel-1; i>=0; --i)
    {
        if (np->udAccel[i].nSec <= uElapsed)
        {
            increment = np->udAccel[i].nInc;
            break;
        }
    }

    if (increment == 0)
    {
        DebugMsg(DM_ERROR, TEXT("bad accelerator value"));
        return;
    }

    direction = compare(np,np->nUpper,np->nLower, DONTCARE) < 0 ? -1 : 1;
    if (np->fUp)
    {
        bChanged = TRUE;
    }
    if (np->fDown)
    {
        direction = -direction;
        bChanged = TRUE;
    }

    if (bChanged)
    {
        /* Make sure we have a multiple of the increment
         * Note that we should loop only when the increment changes
         */
        NM_UPDOWN nm;

        nm.iPos = np->nPos;
        nm.iDelta = increment*direction;
        if (CCSendNotify(&np->ci, UDN_DELTAPOS, &nm.hdr))
            return;

        np->nPos += nm.iDelta;
        for ( ; ; )
        {
            if (!((int)np->nPos % (int)increment))
            {
                break;
            }
            np->nPos += direction;
        }

        nudge(np);
        setint(np);
        if (np->ci.style & UDS_HORZ)
            FORWARD_WM_HSCROLL(np->ci.hwndParent, np->ci.hwnd, SB_THUMBPOSITION, np->nPos, SendMessage);
        else
            FORWARD_WM_VSCROLL(np->ci.hwndParent, np->ci.hwnd, SB_THUMBPOSITION, np->nPos, SendMessage);

        MyNotifyWinEvent(EVENT_OBJECT_VALUECHANGE, np->ci.hwnd, OBJID_CLIENT, 0);
    }
}

//#pragma data_seg(DATASEG_READONLY)
const TCHAR c_szListbox[] = TEXT("listbox");
//#pragma data_seg()

// Sets the new buddy
//
LRESULT NEAR PASCAL setbuddy(PUDSTATE np, HWND hwndBuddy)
{
    HWND hOldBuddy;
    TCHAR szClName[10];

    hOldBuddy = np->hwndBuddy;

    if ((np->hwndBuddy = hwndBuddy) == NULL)
    {
        pickbuddy(np);
        hwndBuddy = np->hwndBuddy;
    }

    if ((hOldBuddy != hwndBuddy) && np->fSubclassed)
    {
        ASSERT(hOldBuddy);
        RemoveWindowSubclass(hOldBuddy, ArrowKeyProc, 0);
        np->fSubclassed = FALSE;
    }

    np->uClass = CLASS_UNKNOWN;
    if (hwndBuddy)
    {
        if (np->ci.style & UDS_ARROWKEYS)
        {
            np->fSubclassed = TRUE;
            SetWindowSubclass(hwndBuddy, ArrowKeyProc, 0, (ULONG_PTR)np);
        }

        GetClassName(hwndBuddy, szClName, ARRAYSIZE(szClName));
        if (!lstrcmpi(szClName, c_szEdit))
        {
            np->uClass = CLASS_EDIT;
        }
        else if (!lstrcmpi(szClName, c_szListbox))
        {
            np->uClass = CLASS_LISTBOX;
        }
    }

    anchor(np);
    return (LRESULT)hOldBuddy;
}


// Paint the whole control
//
void NEAR PASCAL PaintUpDownControl(PUDSTATE np, HDC hdc)
{
    UINT uFlags;
    PAINTSTRUCT ps;
    RECT rcBtn;
    RECT rc;

    BOOL bEnabled = (np->nUpper != np->nLower) && IsWindowEnabled(np->ci.hwnd);

    if (np->hwndBuddy)
        bEnabled = bEnabled && IsWindowEnabled(np->hwndBuddy);

    if (hdc)
        ps.hdc = hdc;
    else
        BeginPaint(np->ci.hwnd, &ps);

    GetClientRect(np->ci.hwnd, &rcBtn);

    // if we are autobuddy'd and anchored to a sunken-edge control, we draw the
    // "nonclient" area of ourselves to blend in with our buddy.
    if (np->fSharedBorder && np->fSunkenBorder)
    {
        UINT bf = BF_TOP | BF_BOTTOM | BF_ADJUST |
            (np->ci.style & UDS_ALIGNLEFT ? BF_LEFT : 0) |
            (np->ci.style & UDS_ALIGNRIGHT ? BF_RIGHT : 0);
        DrawEdge(ps.hdc, &rcBtn, EDGE_SUNKEN, bf);
    }

    // with remaining space, draw appropriate scrollbar arrow controls in
    // upper and lower halves

    rc = rcBtn;
    if (np->ci.style & UDS_HORZ)
    {

        uFlags = DFCS_SCROLLLEFT;
        if (np->fDown)
            uFlags |= DFCS_PUSHED;
        if (!bEnabled)
            uFlags |= DFCS_INACTIVE;
            
        if (g_bRunOnNT5 || g_bRunOnMemphis)
        {
            if (np->uHot == UD_HITDOWN)
                uFlags |= DFCS_HOT;
        }
        
        // Horizontal ones
        rc.right = (rcBtn.right + rcBtn.left) / 2;
        DrawFrameControl(ps.hdc, &rc, DFC_SCROLL,
                         uFlags);

        uFlags = DFCS_SCROLLRIGHT;
        if (np->fUp)
            uFlags |= DFCS_PUSHED;
        if (!bEnabled)
            uFlags |= DFCS_INACTIVE;
            
        if (g_bRunOnNT5 || g_bRunOnMemphis)
        {
            if (np->uHot == UD_HITUP)
                uFlags |= DFCS_HOT;
        }

        rc.left = rcBtn.right - (rc.right - rc.left); // handles odd-x case, too
        rc.right = rcBtn.right;
        DrawFrameControl(ps.hdc, &rc, DFC_SCROLL, uFlags);
    }
    else
    {
        uFlags = DFCS_SCROLLUP;
        if (np->fUp)
            uFlags |= DFCS_PUSHED;
        if (!bEnabled)
            uFlags |= DFCS_INACTIVE;
            
        if (g_bRunOnNT5 || g_bRunOnMemphis)
        {
            if (np->uHot == UD_HITUP)
                uFlags |= DFCS_HOT;
        }

        rc.bottom = (rcBtn.bottom + rcBtn.top) / 2;
        DrawFrameControl(ps.hdc, &rc, DFC_SCROLL, uFlags);

        uFlags = DFCS_SCROLLDOWN;
        if (np->fDown)
            uFlags |= DFCS_PUSHED;
        if (!bEnabled)
            uFlags |= DFCS_INACTIVE;
            
        if (g_bRunOnNT5 || g_bRunOnMemphis)
        {
            if (np->uHot == UD_HITDOWN)
                uFlags |= DFCS_HOT;
        }

        rc.top = rcBtn.bottom - (rc.bottom - rc.top); // handles odd-y case, too
        rc.bottom = rcBtn.bottom;
        DrawFrameControl(ps.hdc, &rc, DFC_SCROLL,
                         uFlags);
    }

    if (hdc == NULL)
        EndPaint(np->ci.hwnd, &ps);
}


LRESULT CALLBACK ArrowKeyProc(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData)
{
    PUDSTATE    np = (PUDSTATE)dwRefData;
    int         cDetants;

    switch (uMsg)
    {
    case WM_NCDESTROY:
        RemoveWindowSubclass(hWnd, ArrowKeyProc, 0);
        np->fSubclassed = FALSE;
        np->hwndBuddy = NULL;
        if (np->fUpDownDestroyed)
        {
            // The buddy was destroyed after updown so free the memory now
            // And pass off to the message to who we subclassed...
            LocalFree((HLOCAL)np);
        }
        break;

    case WM_GETDLGCODE:
        return (DefSubclassProc(hWnd, uMsg, wParam, lParam) | DLGC_WANTARROWS);

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_UP:
        case VK_DOWN:
            if (GetCapture() != np->ci.hwnd)
            {
                /* Get the value from the buddy if this is the first key down
                 */
                if (!(lParam&(1L<<30)))
                {
                    getint(np, NULL);
                }

                /* Update the visuals and bump the value
                 */
                np->bDown = (wParam == VK_DOWN);
                squish(np, !np->bDown, np->bDown);
                bump(np);
                //notify of navigation key usage
                CCNotifyNavigationKeyUsage(&(np->ci), UISF_HIDEFOCUS);
            }
            return(0L);

        default:
            break;
        }
        break;

    case WM_KEYUP:
        switch (wParam)
        {
        case VK_UP:
        case VK_DOWN:
            if (GetCapture() != np->ci.hwnd)
            {
                squish(np, FALSE, FALSE);
            }
            return(0L);

        default:
            break;
        }
        break;

    case WM_KILLFOCUS:
        // Reset wheel scroll amount
        gcWheelDelta = 0;
        break;

    case WM_SETFOCUS:
        ASSERT(gcWheelDelta == 0);
        break;

    default:
        if (uMsg == g_msgMSWheel && GetCapture() != np->ci.hwnd) {

            int iWheelDelta;

            if (g_bRunOnNT || g_bRunOnMemphis)
            {
                iWheelDelta = (int)(short)HIWORD(wParam);
            }
            else
            {
                iWheelDelta = (int)wParam;
            }

            // Update count of scroll amount
            gcWheelDelta -= iWheelDelta;
            cDetants = gcWheelDelta / WHEEL_DELTA;

            if (cDetants != 0) {
                gcWheelDelta %= WHEEL_DELTA;

                if (g_bRunOnNT || g_bRunOnMemphis)
                {
                    if (wParam & (MK_SHIFT | MK_CONTROL))
                        break;
                }
                else
                {
                    if (GetKeyState(VK_SHIFT) < 0 || GetKeyState(VK_CONTROL) < 0)
                        break;
                }

                getint(np, NULL);
                np->bDown = (cDetants > 0);
                cDetants = abs(cDetants);
                while (cDetants-- > 0) {
                    squish(np, !np->bDown, np->bDown);
                    bump(np);
                }
                squish(np, FALSE, FALSE);
            }

            return 1;
        }

        break;
    }

    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}

UINT NEAR PASCAL setbase(PUDSTATE np, UINT wNewBase)
{
    UINT wOldBase;

    switch (wNewBase)
    {
        case BASE_DECIMAL:
        case BASE_HEX:
            np->fUnsigned = (wNewBase != BASE_DECIMAL);
            wOldBase = np->nBase;
            np->nBase = wNewBase;
            setint(np);
            return wOldBase;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////

HWND WINAPI CreateUpDownControl(DWORD dwStyle, int x, int y, int cx, int cy,
                                HWND hParent, int nID, HINSTANCE hInst,
                                HWND hwndBuddy, int nUpper, int nLower, int nPos)
{
    HWND hWnd = CreateWindow(s_szUpdownClass, NULL, dwStyle, x, y, cx, cy,
                             hParent, IntToPtr_(HMENU, nID), hInst, 0L);
    if (hWnd)
    {
        SendMessage(hWnd, UDM_SETBUDDY, (WPARAM)hwndBuddy, 0L);
        SendMessage(hWnd, UDM_SETRANGE, 0, MAKELONG(nUpper, nLower));
        SendMessage(hWnd, UDM_SETPOS, 0, MAKELONG(nPos, 0));
    }
    return hWnd;
}

UINT UD_HitTest(PUDSTATE np, int x, int y)
{
    RECT rc;

    GetClientRect(np->ci.hwnd, &rc);
    if (np->ci.style & UDS_HORZ)
    {
        // Horizontal placement
        if (x < (rc.right / 2))
        {
            return UD_HITDOWN;
        }
        else if (x > (rc.right / 2))
        {
            return UD_HITUP;
        }
    }
    else
    {
        if (y > (rc.bottom / 2))
        {
            return UD_HITDOWN;
        }
        else if (y < (rc.bottom / 2))
        {
            return UD_HITUP;
        }
    }

    return UD_HITNOWHERE;
}

void UD_Invalidate(PUDSTATE np, UINT uWhich, BOOL fErase)
{
    int iMid;
    RECT rc;

    GetClientRect(np->ci.hwnd, &rc);
    if (np->ci.style & UDS_HORZ)
    {
        iMid = rc.right / 2;
        if (uWhich == UD_HITDOWN) {
            rc.right = iMid;
        } else if (uWhich == UD_HITUP) {
            rc.left = iMid;
        } else
            return;
    }
    else
    {
        iMid = rc.bottom /2;
        if (uWhich == UD_HITDOWN) {
            rc.top = iMid;
        } else if (uWhich == UD_HITUP){
            rc.bottom = iMid;
        } else
            return;
    }

    InvalidateRect(np->ci.hwnd, &rc, fErase);
}

void UD_OnMouseMove(PUDSTATE np, DWORD dwPos)
{
    if (np->ci.style & UDS_HOTTRACK) {

        UINT uHot = UD_HitTest(np, GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos));

        if (uHot != np->uHot) {
            UD_Invalidate(np, np->uHot, FALSE);
            UD_Invalidate(np, uHot, FALSE);
            np->uHot = uHot;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

// UpDownWndProc:
//
LRESULT CALLBACK UpDownWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    int i;
    BOOL f;
    LRESULT lres;
    PUDSTATE np = GetWindowPtr(hwnd, 0);

    if (np) {
        if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST) &&
            (np->ci.style & UDS_HOTTRACK) && !np->fTrackSet) {

            TRACKMOUSEEVENT tme;

            np->fTrackSet = TRUE;

            tme.cbSize = sizeof(tme);
            tme.hwndTrack = np->ci.hwnd;
            tme.dwFlags = TME_LEAVE;

            TrackMouseEvent(&tme);
        }
    } else if (uMsg != WM_CREATE)
        goto DoDefault;

    switch (uMsg)
    {

    case WM_MOUSEMOVE:
        UD_OnMouseMove(np, (DWORD) lParam);
        break;

    case WM_MOUSELEAVE:
        np->fTrackSet = FALSE;
        UD_Invalidate(np, np->uHot, FALSE);
        np->uHot = UD_HITNOWHERE;
        break;

    case WM_LBUTTONDOWN:
    {
        // Don't set a timer if on the middle border
        BOOL bTimeIt = TRUE;

        if (np->hwndBuddy && !IsWindowEnabled(np->hwndBuddy))
            break;

        SetCapture(hwnd);
        getint(np, NULL);

        switch (np->uClass)
        {
        case CLASS_EDIT:
        case CLASS_LISTBOX:
            SetFocus(np->hwndBuddy);
            break;
        }

        switch(UD_HitTest(np, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))) {
        case UD_HITDOWN:
            np->bDown = TRUE;
            squish(np, FALSE, TRUE);
            break;

        case UD_HITUP:
            np->bDown = FALSE;
            squish(np, TRUE, FALSE);
            break;

        case UD_HITNOWHERE:
            bTimeIt = FALSE;
            break;
        }

        if (bTimeIt)
        {
            UINT uElapse = min(GetCaretBlinkTime(), CURSORMAX);
            SetTimer(hwnd, 1, uElapse, NULL);
            bump(np);
        }
        break;
    }

    case WM_TIMER:
    {
        POINT pt;

        if (GetCapture() != hwnd)
        {
            goto EndScroll;
        }

        SetTimer(hwnd, 1, 100, NULL);

        GetWindowRect(hwnd, &rc);
        if (np->ci.style & UDS_HORZ) {
            i = (rc.left + rc.right) / 2;
            if (np->bDown)
            {
                rc.right = i;
            }
            else
            {
                rc.left = i;
            }
        } else {
            i = (rc.top + rc.bottom) / 2;
            if (np->bDown)
            {
                rc.top = i;
            }
            else
            {
                rc.bottom = i;
            }
        }
        InflateRect(&rc, (g_cxFrame+1)/2, (g_cyFrame+1)/2);
        GetCursorPos(&pt);
        if (PtInRect(&rc, pt))
        {
            squish(np, !np->bDown, np->bDown);
            bump(np);
        }
        else
        {
            squish(np, FALSE, FALSE);
        }
        break;
    }

    case WM_LBUTTONUP:
        if (np->hwndBuddy && !IsWindowEnabled(np->hwndBuddy))
            break;

        if (GetCapture() == hwnd)
        {
EndScroll:
            squish(np, FALSE, FALSE);
            // We cannot call CCReleaseCapture() here, because it busts a lot of apps.
            ReleaseCapture();
            KillTimer(hwnd, 1);

            if (np->uClass == CLASS_EDIT)
                Edit_SetSel(np->hwndBuddy, 0, -1);

                        if (np->ci.style & UDS_HORZ)
                            FORWARD_WM_HSCROLL(np->ci.hwndParent, np->ci.hwnd,
                                      SB_ENDSCROLL, np->nPos, SendMessage);
                        else
                            FORWARD_WM_VSCROLL(np->ci.hwndParent, np->ci.hwnd,
                                      SB_ENDSCROLL, np->nPos, SendMessage);
        }
        break;

    case WM_ENABLE:
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_WININICHANGE:
        if (np && (!wParam ||
            (wParam == SPI_SETNONCLIENTMETRICS) ||
            (wParam == SPI_SETICONTITLELOGFONT))) {
            InitGlobalMetrics(wParam);
            unachor(np);
            anchor(np);
        }
        break;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        PaintUpDownControl(np, (HDC)wParam);
        break;

    case WM_UPDATEUISTATE:
        //not sure need to set bit, will probably not use it, on the other hand this
        //  is consistent with remaining of common controls and not very expensive
        CCOnUIState(&(np->ci), WM_UPDATEUISTATE, wParam, lParam);

        goto DoDefault;
    case UDM_SETRANGE:
        np->nUpper = GET_X_LPARAM(lParam);
        np->nLower = GET_Y_LPARAM(lParam);
        nudge(np);
        break;
        
    case UDM_SETRANGE32:
        np->nUpper = (int)lParam;
        np->nLower = (int)wParam;
        break;
        
    case UDM_GETRANGE32:
        if (lParam) {
            *((LPINT)lParam) = np->nUpper;
        }
        if (wParam) {
            *((LPINT)wParam) = np->nLower;
        }
        break;
        
    case UDM_GETRANGE:
        return MAKELONG(np->nUpper, np->nLower);

    case UDM_SETBASE:
        // wParam: new base
        // lParam: not used
        // return: 0 if invalid base is specified,
        //         previous base otherwise
        return (LRESULT)setbase(np, (UINT)wParam);

    case UDM_GETBASE:
        return np->nBase;

    case UDM_SETPOS:
        lParam = GET_X_LPARAM(lParam);
        // FALL THROUGH

    case UDM_SETPOS32:
    {
        int iNewPos = (int)lParam;
        if (compare(np, np->nLower, np->nUpper, DONTCARE) < 0) {

            if (compare(np, iNewPos, np->nUpper, DONTCARE) > 0) {
                iNewPos = np->nUpper;
            }

            if (compare(np, iNewPos, np->nLower, DONTCARE) < 0) {
                iNewPos = np->nLower;
            }
        } else {
            if (compare(np, iNewPos, np->nUpper, DONTCARE) < 0) {
                iNewPos = np->nUpper;
            }

            if (compare(np, iNewPos, np->nLower, DONTCARE) > 0) {
                iNewPos = np->nLower;
            }
        }

        i = np->nPos;
        np->nPos = iNewPos;
        setint(np);
        MyNotifyWinEvent(EVENT_OBJECT_VALUECHANGE, np->ci.hwnd, OBJID_CLIENT, 0);
        return (LRESULT)i;
    }

    case UDM_GETPOS:
        lres = getint(np, &f);
        return MAKELRESULT(lres, f);

    case UDM_GETPOS32:
        return getint(np, (BOOL *)lParam);

    case UDM_SETBUDDY:
        return setbuddy(np, (HWND)wParam);

    case UDM_GETBUDDY:
        return (LRESULT)np->hwndBuddy;

    case UDM_SETACCEL:
            if (wParam == 0)
                return(FALSE);
            if (wParam >= NUM_UDACCELS)
            {
                HANDLE npPrev = (HANDLE)np;
                np = (PUDSTATE)LocalReAlloc((HLOCAL)npPrev, sizeof(UDSTATE)+(wParam-NUM_UDACCELS)*sizeof(UDACCEL),
                    LMEM_MOVEABLE);
                if (!np)
                {
                    return(FALSE);
                }
                else
                {
                    SetWindowPtr(hwnd, 0, np);

                    if ((np->ci.style & UDS_ARROWKEYS) && np->hwndBuddy)
                    {
                        np->fSubclassed = TRUE;
                        SetWindowSubclass(np->hwndBuddy, ArrowKeyProc, 0,
                            (ULONG_PTR)np);
                    }
                }
            }

            np->nAccel = (UINT) wParam;
        for (i=0; i<(int)wParam; ++i)
        {
                np->udAccel[i] = ((LPUDACCEL)lParam)[i];
        }
        return(TRUE);

    case UDM_GETACCEL:
        if (wParam > np->nAccel)
        {
            wParam = np->nAccel;
        }
        for (i=0; i<(int)wParam; ++i)
        {
            ((LPUDACCEL)lParam)[i] = np->udAccel[i];
        }
        return(np->nAccel);

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&np->ci, lParam);

    case WM_CREATE:
        CCCreateWindow();
        // Allocate the instance data space.
        np = (PUDSTATE)LocalAlloc(LPTR, sizeof(UDSTATE));
        if (!np)
            return -1;

        SetWindowPtr(hwnd, 0, np);

            #define lpCreate ((CREATESTRUCT FAR *)lParam)

        CIInitialize(&np->ci, hwnd, lpCreate);

        // np->fUp =
        // np->fDown =
            // np->fUnsigned =
            // np->fSharedBorder =
            // np->fSunkenBorder =
        //  FALSE;

        if (lpCreate->style & UDS_UNSIGNED)
            np->fUnsigned = TRUE;

        if (lpCreate->dwExStyle & WS_EX_CLIENTEDGE)
            np->fSunkenBorder = TRUE;

        np->nBase = BASE_DECIMAL;
        np->nUpper = 0;
        np->nLower = 100;
        np->nPos = 0;
        np->hwndBuddy = NULL;
        np->uClass = CLASS_UNKNOWN;
        ASSERT(np->cReenterSetint == 0);

            np->nAccel = NUM_UDACCELS;
            np->udAccel[0].nSec = 0;
            np->udAccel[0].nInc = 1;
        np->udAccel[1].nSec = 2;
            np->udAccel[1].nInc = 5;
            np->udAccel[2].nSec = 5;
            np->udAccel[2].nInc = 20;

        /* This does the pickbuddy and anchor
         */
        setbuddy(np, NULL);
        setint(np);
        break;

    case WM_DESTROY:
        CCDestroyWindow();
        if (np) {
            if (np->hwndBuddy)
            {
                //  Our buddy needs to be unsubclassed, which we'll do
                //  in response to WM_NCDESTROY;  doing so now would 
                //  bust any subsequent call to the suclass proc.
                DebugMsg(DM_TRACE, TEXT("UpDown Destroyed while buddy subclassed"));
                np->fUpDownDestroyed = TRUE;
            }
            else
                LocalFree((HLOCAL)np);
            SetWindowPtr(hwnd, 0, 0);
        }
        break;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_UPDOWN;
        goto DoDefault;

    default:
    {
        LRESULT lres;
        if (CCWndProc(&np->ci, uMsg, wParam, lParam, &lres))
            return lres;
    }

DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}

/////////////////////////////////////////////////////////////////////////////

// InitUpDownClass:
// Adds our WNDCLASS to the system.
//
#pragma code_seg(CODESEG_INIT)

BOOL FAR PASCAL InitUpDownClass(HINSTANCE hInst)
{
    WNDCLASS wndclass;

    wndclass.lpfnWndProc    = UpDownWndProc;
    wndclass.lpszClassName  = s_szUpdownClass;
    wndclass.hInstance  = hInst;
    wndclass.hCursor    = LoadCursor(NULL, IDC_ARROW);
    wndclass.hIcon      = NULL;
    wndclass.lpszMenuName   = NULL;
    wndclass.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
    wndclass.style      = CS_HREDRAW | CS_VREDRAW | CS_GLOBALCLASS;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = sizeof(PUDSTATE);

    RegisterClass(&wndclass);

    return TRUE;
}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\usonly\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\blur.cpp ===
/*
**  CUTILS.C
**
**  Common utilities for common controls
**
*/

#include "ctlspriv.h"
#include <shfusion.h>

#define ARGB(a,r,g,b)          ((COLORREF)(( \
                         ((BYTE)(r))       | \
                 ((WORD) ((BYTE)(g))<< 8)) | \
                (((DWORD)((BYTE)(b))<<16)) | \
                (((DWORD)((BYTE)(a))<<24))))

#define PREMULTIPLY(c, alpha)  ((( ((c) * (alpha)) + 128) >> 8) + 1)


typedef struct tagCCBUFFER
{
    HDC hdc;
    HBITMAP hbmp;
    HBITMAP hbmpOld;
    RGBQUAD* prgb;
} CCBUFFER;

BOOL Buffer_CreateBuffer(HDC hdc, int cx, int cy, CCBUFFER* pbuf)
{
    BOOL fRet = FALSE;
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    pbuf->hdc = CreateCompatibleDC(hdc);
    if (pbuf->hdc)
    {
        pbuf->hbmp = CreateDIBSection(pbuf->hdc, &bi, DIB_RGB_COLORS, (VOID**)&pbuf->prgb, NULL, 0);
        if (!pbuf->hbmp)
        {
            DeleteDC(pbuf->hdc);
            ZeroMemory(pbuf, sizeof(CCBUFFER));
        }
        else
        {
            pbuf->hbmpOld = (HBITMAP)SelectObject(pbuf->hdc, pbuf->hbmp);
            fRet = TRUE;
        }
    }

    return fRet;
}

void Buffer_DestroyBuffer(CCBUFFER* pbuf)
{
    if (pbuf->hdc)
    {
        SelectObject(pbuf->hdc, pbuf->hbmpOld);
        DeleteDC(pbuf->hdc);
        DeleteObject(pbuf->hbmp);
    }
}
void BlurBitmapNormal(ULONG* prgb, int cx, int cy, COLORREF crFill)
{

    BYTE r = GetRValue(crFill);
    BYTE g = GetGValue(crFill);
    BYTE b = GetBValue(crFill);

    int cxMax = cx - 5;
    int cyMax = cy - 5;
    int iOffset;
    int y;
    for (y=0, iOffset = 0; y < cy; y++, iOffset += cx)
    {
        ULONG* p = &prgb[iOffset];
        int Accum = ((*p)) +
                    ((*(p + 1))) +
                    ((*(p + 2))) +
                    ((*(p + 3)));

        for (int x=0; x< cxMax; x++)
        {
            Accum = Accum - ((*p)) + ((*(p + 4)));
            *p++ = (Accum >> 2);
        }
    }

    int cx2 = cx << 1;
    int cx3 = cx + cx + cx;
    int cx4 = cx << 2;

    for (iOffset = 0, y=0; y < cyMax; y++, iOffset += cx)
    {
        ULONG* p = &prgb[iOffset];
        for (int x=0; x < cx; x++)
        {
            DWORD Alpha = (((*p)      ) +
                          (*(p + cx)  ) +
                          (*(p + cx2) ) +
                          (*(p + cx3) ) +
                          (*(p + cx4) )) >> 2;
            if (Alpha > 255)
                Alpha = 255;

            *p = (ULONG)ARGB(Alpha, PREMULTIPLY(r, Alpha), PREMULTIPLY(g, Alpha), PREMULTIPLY(b, Alpha));

            p++;
        }
    }
}

#ifdef _X86_

QWORD qw128 = 0x0000008000800080;
QWORD qw1   = 0x0000000100010001;

void BlurBitmapMMX(ULONG* prgb, int cx, int cy, COLORREF crFill)
{
    RGBQUAD rgbFill;                    // ColorRef is opposite of RGBQUAD
    rgbFill.rgbRed = GetRValue(crFill);
    rgbFill.rgbGreen = GetGValue(crFill);
    rgbFill.rgbBlue = GetBValue(crFill);

    int cxMax = cx - 5;
    int cyMax = cy - 5;
    int iOffset;
    int y;
    for (y=0, iOffset = 0; y < cy; y++, iOffset += cx)
    {
        ULONG* p = &prgb[iOffset];
        int Accum = ((*p)) +
                    ((*(p + 1))) +
                    ((*(p + 2))) +
                    ((*(p + 3)));

        for (int x=0; x< cxMax; x++)
        {
            Accum = Accum - ((*p)) + ((*(p + 4)));
            *p++ = (Accum >> 2);
        }
    }

    int cx2 = cx << 1;
    int cx3 = cx + cx + cx;
    int cx4 = cx << 2;
    _asm
    {
        pxor mm0, mm0
        pxor mm1, mm1
        pxor mm5, mm5
        movd mm4, dword ptr [rgbFill]
        movq mm6, qw128                 // mm6 is filled with 128
        movq mm7, qw1                   // mm7 is filled with 1
    }

    for (iOffset = 0, y=0; y < cyMax; y++, iOffset += cx)
    {
        ULONG* p = &prgb[iOffset];
        for (int x=0; x < cx; x++)
        {
            DWORD Alpha = (((*p)      ) +
                          (*(p + cx)  ) +
                          (*(p + cx2) ) +
                          (*(p + cx3) ) +
                          (*(p + cx4) )) >> 2;
            if (Alpha > 255)
                Alpha = 255;

            *p = ((BYTE)Alpha);

        _asm
        {
            mov edx, dword ptr [p]
            mov ebx, dword ptr [edx]
            mov eax, ebx                    // a -> b
            or eax, eax
            jz EarlyOut
            shl ebx, 8                      // b << 8
            or eax, ebx                     // a |= b
            shl ebx, 8                      // b << 8
            or eax, ebx                     // a |= b
            shl ebx, 8                      // b << 8
                                            // Note high byte of alpha is zero.
            movd mm0, eax                   //  a -> mm0        
              movq mm1, mm4                    // Load the pixel
            punpcklbw mm0,mm5               //  mm0 -> Expands  <-   mm0 Contains the Alpha channel for this multiply

              punpcklbw mm1, mm5               // Unpack the pixel
            pmullw mm1, mm0                 // Multiply by the alpha channel <- mm1 contains c * alpha

            paddusw mm1, mm6                 // perform the (c * alpha) + 128
            psrlw mm1, 8                    // Divide by 255
            paddusw mm1, mm7                 // Add 1 to finish the divide by 255
            packuswb mm1, mm5

            movd eax, mm1
            or eax, ebx                     // Transfer alpha channel
EarlyOut:
            mov dword ptr [edx], eax
        }

            p++;
        }
    }

    _asm emms
}

void BlurBitmap(ULONG* plBitmapBits, int cx, int cy, COLORREF crFill)
{
    if (IsProcessorFeaturePresent(PF_MMX_INSTRUCTIONS_AVAILABLE))
        BlurBitmapMMX(plBitmapBits, cx, cy, crFill);
    else
        BlurBitmapNormal(plBitmapBits, cx, cy, crFill);
}

#else

void BlurBitmap(ULONG* plBitmapBits, int cx, int cy, COLORREF crFill)
{
    BlurBitmapNormal(plBitmapBits, cx, cy, crFill);
}

#endif


int DrawShadowText(HDC hdc, LPCTSTR pszText, UINT cch, RECT* prc, DWORD dwFlags, COLORREF crText, 
    COLORREF crShadow, int ixOffset, int iyOffset)
{
    int iRet = -1;
    if (dwFlags & DT_CALCRECT)
    {
        iRet = DrawText(hdc, pszText, cch, prc, dwFlags | DT_CALCRECT);
    }
    else
    {
        if (GetLayout(hdc) == LAYOUT_RTL)
        {
            COLORREF crTextSave = SetTextColor(hdc, crShadow);
            int iMode = SetBkMode(hdc, TRANSPARENT);
            RECT rc = *prc;
            OffsetRect(&rc, ixOffset, iyOffset);

            DrawText(hdc, pszText, cch, &rc, dwFlags);
            SetBkMode(hdc, iMode);
            SetTextColor(hdc, crTextSave);

        }
        else
        {
            RECT rc = *prc;
            CCBUFFER buf;

            int cx = RECTWIDTH(rc) + 10;
            int cy = RECTHEIGHT(rc) + 10;

            if (Buffer_CreateBuffer(hdc, cx, cy, &buf))
            {
                OffsetRect(&rc, 5, 5);
                RECT rcMem = {5, 5, RECTWIDTH(rc) + 5, RECTHEIGHT(rc) + 5};

                HFONT hFontOldhdc = (HFONT)SelectObject(hdc, GetStockObject(SYSTEM_FONT));
                HFONT hFontOldhdcMem = (HFONT)SelectObject(buf.hdc, hFontOldhdc);

                SetTextColor(buf.hdc, crText);
                SetBkColor(buf.hdc, crShadow);
                SetBkMode(buf.hdc, TRANSPARENT);

                DrawText(buf.hdc, pszText, cch, &rcMem, dwFlags);
                int Total = cx * cy;
                for (int z = 0; z < Total; z++)
                {
                    if (((PULONG)buf.prgb)[z] != 0)
                        ((PULONG)buf.prgb)[z] = 0x000000ff;
                }

                BlurBitmap((ULONG*)buf.prgb, cx, cy, crShadow);

                BLENDFUNCTION bf = {0};
                bf.BlendOp = AC_SRC_OVER;
                bf.SourceConstantAlpha = 255;
                bf.AlphaFormat = AC_SRC_ALPHA;
                GdiAlphaBlend(hdc, prc->left - 4 + ixOffset, prc->top - 8 + iyOffset, cx, cy, buf.hdc, 0, 0, cx, cy, bf);

                SelectObject(buf.hdc, hFontOldhdcMem);
                SelectObject(hdc, hFontOldhdc);

                Buffer_DestroyBuffer(&buf);
            }
        }

        int iMode = SetBkMode(hdc, TRANSPARENT);
        COLORREF crTextSave = SetTextColor(hdc, crText);
        iRet = DrawText(hdc, pszText, cch, prc, dwFlags);
        SetTextColor(hdc, crTextSave);
        SetBkMode(hdc, iMode);
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\bmimgctx.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  CBitmapImgCtx
//
//  Implement IImgCtx for drawing out of a bitmap
//
//  WARNING:  Incomplete implementation -- just barely enough to keep
//  listview happy.  Should not be exposed to anyone other than listview.
//
//////////////////////////////////////////////////////////////////////////


#include "ctlspriv.h"
#include <iimgctx.h>

class CBitmapImgCtx : public IImgCtx
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IImgCtx methods ***
    STDMETHODIMP Load(LPCWSTR pszUrl, DWORD dwFlags);
    STDMETHODIMP SelectChanges(ULONG ulChgOn, ULONG ulChgOff, BOOL fSignal);
    STDMETHODIMP SetCallback(PFNIMGCTXCALLBACK pfn, void * pvPrivateData);
    STDMETHODIMP Disconnect();

    STDMETHODIMP GetUpdateRects(LPRECT prc, LPRECT prcImg, LPLONG pcrc);
    STDMETHODIMP GetStateInfo(PULONG pulState, LPSIZE psize, BOOL fClearChanges);
    STDMETHODIMP GetPalette(HPALETTE *phpal);

    STDMETHODIMP Draw(HDC hdc, LPRECT prcBounds);
    STDMETHODIMP Tile(HDC hdc, LPPOINT pptBackOrg, LPRECT prcClip, LPSIZE psize);
    STDMETHODIMP StretchBlt(HDC hdc, int dstX, int dstY, int dstXE, int dstYE, int srcX, int srcY, int srcXE, int srcYE, DWORD dwROP);

public:
    CBitmapImgCtx() : _cRef(1) { }
    BOOL Initialize(HBITMAP hbm);

protected:
    ~CBitmapImgCtx()
    {
        if (_hbr) DeleteObject(_hbr);
    }

    // Keep _cRef as first member so we can coalesce
    // with ILVRange's IUnknown implementation
    int         _cRef;

    HBRUSH      _hbr;                   // Bitmap pattern brush
    SIZE        _sizBmp;                // Size of original bitmap

    PFNIMGCTXCALLBACK _pfnCallback;
    LPVOID      _pvRefCallback;
};

STDAPI_(IImgCtx *) CBitmapImgCtx_Create(HBITMAP hbm)
{
    CBitmapImgCtx *pbic = new CBitmapImgCtx();
    if (pbic && !pbic->Initialize(hbm))
    {
        pbic->Release();
        pbic = NULL;
    }
    return pbic;
}

// CBitmapImgCtx::Initialize

BOOL CBitmapImgCtx::Initialize(HBITMAP hbm)
{
    BOOL fSuccess = FALSE;

    _hbr = CreatePatternBrush(hbm);
    if (_hbr)
    {
        BITMAP bm;
        if (GetObject(hbm, sizeof(bm), &bm))
        {
            _sizBmp.cx = bm.bmWidth;
            _sizBmp.cy = bm.bmHeight;
            fSuccess = TRUE;
        }
    }
    return fSuccess;
}

// IUnknown::QueryInterface

HRESULT CBitmapImgCtx::QueryInterface(REFIID iid, void **ppv)
{
    if (IsEqualIID(iid, IID_IImgCtx) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = SAFECAST(this, IImgCtx *);
    }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    _cRef++;
    return NOERROR;
}

// IUnknown::AddRef

ULONG CBitmapImgCtx::AddRef()
{
    return ++_cRef;
}

// IUnknown::Release

ULONG CBitmapImgCtx::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

// IImgCtx::Load

HRESULT CBitmapImgCtx::Load(LPCWSTR pszUrl, DWORD dwFlags)
{
    ASSERT(0);              // Listview should never call this
    return E_NOTIMPL;
}

// IImgCtx::SelectChanges

HRESULT CBitmapImgCtx::SelectChanges(ULONG ulChgOn, ULONG ulChgOff, BOOL fSignal)
{
    // Listview always calls with exactly these parameters
    ASSERT(ulChgOn == IMGCHG_COMPLETE);
    ASSERT(ulChgOff == 0);
    ASSERT(fSignal == TRUE);

    // Listview always calls after setting the callback
    ASSERT(_pfnCallback);

    _pfnCallback(this, _pvRefCallback);
    return S_OK;
}

// IImgCtx::SetCallback

HRESULT CBitmapImgCtx::SetCallback(PFNIMGCTXCALLBACK pfn, void * pvPrivateData)
{
    _pfnCallback = pfn;
    _pvRefCallback = pvPrivateData;
    return S_OK;
}

// IImgCtx::Disconnect

HRESULT CBitmapImgCtx::Disconnect()
{
    ASSERT(0);              // Listview should never call this
    return E_NOTIMPL;
}

// IImgCtx::GetUpdateRects

HRESULT CBitmapImgCtx::GetUpdateRects(LPRECT prc, LPRECT prcImg, LPLONG pcrc)
{
    ASSERT(0);              // Listview should never call this
    return E_NOTIMPL;
}

// IImgCtx::GetStateInfo

HRESULT CBitmapImgCtx::GetStateInfo(PULONG pulState, LPSIZE psize, BOOL fClearChanges)
{
    *pulState = IMGCHG_COMPLETE;
    *psize = _sizBmp;
    return S_OK;
}

// IImgCtx::GetPalette

HRESULT CBitmapImgCtx::GetPalette(HPALETTE *phpal)
{
    *phpal = NULL;
    return S_OK;
}

// IImgCtx::Draw
//
//  Drawing is a special case of tiling where only one tile's worth
//  gets drawn.  Listview (our only caller) is careful never to ask
//  for more than one tile's worth, so we can just forward straight
//  to IImgCtx::Tile().

HRESULT CBitmapImgCtx::Draw(HDC hdc, LPRECT prcBounds)
{
    POINT pt = { prcBounds->left, prcBounds->top };

    ASSERT(prcBounds->right - prcBounds->left <= _sizBmp.cx);
    ASSERT(prcBounds->bottom - prcBounds->top <= _sizBmp.cy);

    return Tile(hdc, &pt, prcBounds, NULL);
}

// IImgCtx::Tile

HRESULT CBitmapImgCtx::Tile(HDC hdc, LPPOINT pptBackOrg, LPRECT prcClip, LPSIZE psize)
{
    ASSERT(psize == NULL);  // Listview always passes NULL

    POINT pt;
    if (SetBrushOrgEx(hdc, pptBackOrg->x, pptBackOrg->y, &pt))
    {
        FillRect(hdc, prcClip, _hbr);
        SetBrushOrgEx(hdc, pt.x, pt.y, NULL);
    }

    // Nobody checks the return value
    return S_OK;
}

// IImgCtx::StretchBlt

HRESULT CBitmapImgCtx::StretchBlt(HDC hdc, int dstX, int dstY, int dstXE, int dstYE, int srcX, int srcY, int srcXE, int srcYE, DWORD dwROP)
{
    ASSERT(0);              // Listview should never call this
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\ccverp.h ===
//
// Version numbering for comctl32.dll
//

#ifndef FEATURE_IE40

#undef VER_PRODUCTBETA_STR
#undef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION_W
#undef VER_PRODUCTVERSION_DW

//
// NT SUR, IE 3.0
//

#define COMCTL32_BUILD_NUMBER	   1146

#define VER_PRODUCTVERSION          4,70,COMCTL32_BUILD_NUMBER,1

#define VER_PRODUCTBETA_STR         ""
#define VER_PRODUCTVERSION_STR      "4.70"
#define VER_PRODUCTVERSION_W        (0x0446)
#define VER_PRODUCTVERSION_DW       (0x04460000 | COMCTL32_BUILD_NUMBER)

#endif  // FEATURE_IE40
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\animate.c ===
#include "ctlspriv.h"
#include "rlefile.h"

#define RectWid(_rc)    ((_rc).right-(_rc).left)
#define RectHgt(_rc)    ((_rc).bottom-(_rc).top)

typedef struct 
{
    HWND        hwnd;                   // my window
    int         id;                     // my id
    HWND        hwndP;                  // my owner (get notify messages)
    DWORD       style;

    BOOL        fFirstPaint;            // TRUE until first paint.
    RLEFILE     *prle;

    CRITICAL_SECTION    crit;

    RECT        rc;
    int         NumFrames;
    int         Rate;

    int         iFrame;
    int         PlayCount;
    int         PlayFrom;
    int         PlayTo;
    HANDLE      PaintThread;
    HANDLE      hStopEvent;
} ANIMATE;

#define Enter(p)    EnterCriticalSection(&p->crit)
#define Leave(p)    LeaveCriticalSection(&p->crit)

#define OPEN_WINDOW_TEXT 42

// Threading is broken with the new "Transparent" animations. If we decide to reenable
// this, we need to figure out how to get the bits without using sendmessage.
#define Ani_UseThread(p) (FALSE)

LRESULT CALLBACK AnimateWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

BOOL HandleOpen(ANIMATE *p, HINSTANCE hInst, LPCTSTR pszName, UINT flags);
BOOL HandleStop(ANIMATE *p);
BOOL HandlePlay(ANIMATE *p, int from, int to, int count);
void HandlePaint(ANIMATE *p, HDC hdc);
int  HandleTick(ANIMATE *p);

BOOL InitAnimateClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = AnimateWndProc;
    wc.lpszClassName = ANIMATE_CLASS;
    wc.style         = CS_DBLCLKS | CS_GLOBALCLASS;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(LPVOID);
    wc.hInstance     = hInstance;       // use DLL instance if in DLL
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    wc.lpszMenuName  = NULL;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}

BOOL HandleOpen(ANIMATE *p, HINSTANCE hInst, LPCTSTR pszName, UINT flags)
{
    TCHAR ach[MAX_PATH];

    //
    // use window text as file name
    //
    if (flags == OPEN_WINDOW_TEXT)
    {
        GetWindowText(p->hwnd, ach, ARRAYSIZE(ach));
        pszName = ach;
    }

    if (hInst == NULL)
        hInst = (HINSTANCE)GetWindowLongPtr(p->hwnd, GWLP_HINSTANCE);

    HandleStop(p);              // stop a play first

    if (p->prle)
    {
        RleFile_Free(p->prle);
        p->prle = NULL;
    }

    p->iFrame = 0;
    p->NumFrames = 0;

    if (pszName == NULL || (!IS_INTRESOURCE(pszName) && *pszName == 0))
        return FALSE;
    //
    //  now open the file/resource we got.
    //
    p->prle = RleFile_New();

    if (p->prle == NULL)
        return FALSE;

    if (!RleFile_OpenFromResource(p->prle, hInst, pszName, TEXT("AVI")) &&
        !RleFile_OpenFromFile(p->prle, pszName))
    {
        RleFile_Free(p->prle);
        p->prle = NULL;
        return FALSE;
    }
    else
    {
        p->NumFrames = RleFile_NumFrames(p->prle);
        p->Rate = (int)RleFile_Rate(p->prle);
        SetRect(&p->rc, 0, 0, RleFile_Width(p->prle), RleFile_Height(p->prle));
    }

    //
    // handle a transparent color
    //
    if ((p->style & ACS_TRANSPARENT) && p->hwndP)
    {
        HDC hdc;
        HDC hdcM;
        HBITMAP hbm;
        COLORREF rgbS = {0};
        COLORREF rgbD = {0};

        hdc = GetDC(p->hwnd);

        //
        //  create a bitmap and draw image into it.
        //  get upper left pixel and make that transparent.
        //
        hdcM= CreateCompatibleDC(hdc);
        if (hdcM)
        {
            hbm = CreateCompatibleBitmap(hdc, 1, 1);
            if (hbm)
            {
                HBITMAP hbmO = SelectObject(hdcM, hbm);

                RleFile_Paint( p->prle, hdcM, p->iFrame, p->rc.left, p->rc.top );
                rgbS = GetPixel(hdcM, 0, 0);

                SelectObject(hdcM, hbmO);
                DeleteObject(hbm);
            }
            DeleteDC(hdcM);
        }

        SendMessage(p->hwndP, GET_WM_CTLCOLOR_MSG(CTLCOLOR_STATIC),
            GET_WM_CTLCOLOR_MPS(hdc, p->hwnd, CTLCOLOR_STATIC));

        rgbD = GetBkColor(hdc);


        ReleaseDC(p->hwnd, hdc);

        //
        // now replace the color
        //
        RleFile_ChangeColor(p->prle, rgbS, rgbD);
    }

    //
    //  ok it worked, resize window.
    //
    if (p->style & ACS_CENTER)
    {
        RECT rc;
        GetClientRect(p->hwnd, &rc);
        OffsetRect(&p->rc, (rc.right-p->rc.right)/2,(rc.bottom-p->rc.bottom)/2);
    }
    else
    {
        RECT rc;
        rc = p->rc;
        AdjustWindowRectEx(&rc, GetWindowStyle(p->hwnd), FALSE, GetWindowExStyle(p->hwnd));
        SetWindowPos(p->hwnd, NULL, 0, 0, RectWid(rc), RectHgt(rc),
            SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
    }

    if (p->style & ACS_AUTOPLAY)
    {
        PostMessage(p->hwnd, ACM_PLAY, (UINT_PTR)-1, MAKELONG(0, -1));
    }
    else
    {
        InvalidateRect(p->hwnd, NULL, TRUE);
    }

    return TRUE;
}

void DoNotify(ANIMATE *p, int cmd)
{
    if (p->hwndP)
        PostMessage(p->hwndP, WM_COMMAND, GET_WM_COMMAND_MPS(p->id, p->hwnd, cmd));
}

BOOL HandleStop(ANIMATE *p)
{
    if (p == NULL || !p->PaintThread)
        return FALSE;

    if (Ani_UseThread(p)) 
    {
        // set thread up to terminate between frames
        Enter( p );
        p->PlayCount = 0;
        Leave( p );
        if (p->hStopEvent)
            SetEvent(p->hStopEvent);
        WaitForSingleObject(p->PaintThread, INFINITE);
        CloseHandle(p->PaintThread);

        // PORT QSY
        p->PaintThread = NULL;
        if (p->hStopEvent)
            CloseHandle(p->hStopEvent);
        p->hStopEvent = NULL;
    } 
    else 
    {
        KillTimer(p->hwnd, HandleToUlong(p->PaintThread)); // really was a UINT
        p->PaintThread = 0;
        DoNotify(p, ACN_STOP);
    }
    return TRUE;
}

int PlayThread(ANIMATE *p)
{
    int result;
    
    DoNotify(p, ACN_START);

    while (result = HandleTick(p))
    {
        // Sleep for a bit (4 seconds) longer if we are hidden
        //
        // Old code here slept, which can block the UI thread
        // if the app tries to stop/shutdown/change the animation
        // right near the beginning of the sleep.
        //        Sleep((result < 0 ? p->Rate+4000 : p->Rate));
        // Do a timed wait for the stop event instead
        //
        if (p->hStopEvent)
            WaitForSingleObject(p->hStopEvent, (result < 0 ? p->Rate+4000 : p->Rate));
        else
            Sleep((result < 0 ? p->Rate+4000 : p->Rate));
    }

    DoNotify(p, ACN_STOP);
    return 0;
}

BOOL HandlePlay(ANIMATE *p, int from, int to, int count)
{
    if (p == NULL || p->prle == NULL)
        return FALSE;

    HandleStop(p);

    if (from >= p->NumFrames)
        from = p->NumFrames-1;

    if (to == -1)
        to = p->NumFrames-1;

    if (to < 0)
        to = 0;

    if (to >= p->NumFrames)
        to = p->NumFrames-1;

    p->PlayCount = count;
    p->PlayTo    = to;
    if (from >= 0) 
    {
        p->iFrame = from;
        p->PlayFrom  = from;
    } 
    else
        from = p->PlayFrom;

    if ( (from == to) || !count )
    {
        InvalidateRect(p->hwnd, NULL, TRUE);
        return TRUE;
    }

    InvalidateRect(p->hwnd, NULL, FALSE);
    UpdateWindow(p->hwnd);

    if (Ani_UseThread(p))
    {
        DWORD dw;
        p->hStopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        p->PaintThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PlayThread, (void*)p, 0, &dw);
    }
    else
    {
        DoNotify(p, ACN_START);
        p->PaintThread = (HANDLE)SetTimer(p->hwnd, 42, (UINT)p->Rate, NULL);
    }
    return TRUE;
}

void HandleFirstPaint(ANIMATE *p)
{
    if (p->fFirstPaint)
    {
        p->fFirstPaint = FALSE;

        if (p->NumFrames == 0 &&
            (p->style & WS_CHILD))
        {
            HandleOpen(p, NULL, NULL, OPEN_WINDOW_TEXT);
        }
    }
}

void HandlePaint(ANIMATE *p, HDC hdc)
{
    if( p && p->prle )
    {
        HDC h;
        HBRUSH hbr;
        RECT rc;
        CCDBUFFER db;

        GetClientRect(p->hwnd, &rc);
        h = CCBeginDoubleBuffer(hdc, &rc, &db);

        hbr = (HBRUSH)SendMessage(p->hwndP, GET_WM_CTLCOLOR_MSG(CTLCOLOR_STATIC),
            GET_WM_CTLCOLOR_MPS(hdc, p->hwnd, CTLCOLOR_STATIC));

        FillRect(h, &rc, hbr);

        Enter( p );
        RleFile_Paint( p->prle, h, p->iFrame, p->rc.left, p->rc.top );
        Leave( p );

        CCEndDoubleBuffer(&db);
    }
}

void HandlePrint(ANIMATE *p, HDC hdc)
{
    HandleFirstPaint(p);
    HandlePaint(p, hdc);
}

int HandleTick(ANIMATE *p)
// - if something to do but we are hidden
// returns 0 if nothing left
// + if something to do
{
    int result = 0;

    if( p && p->prle )
    {
        HDC hdc;
        RECT dummy;

        Enter( p );
        hdc = GetDC( p->hwnd );

        if( GetClipBox( hdc, &dummy ) != NULLREGION )
        {
            HandlePaint( p, hdc );

            if( p->iFrame >= p->PlayTo )
            {
                if( p->PlayCount > 0 )
                    p->PlayCount--;

                if( p->PlayCount != 0 )
                    p->iFrame = p->PlayFrom;
            }
            else
                p->iFrame++;


            // Something to do? and visible, return + value
            result = ( p->PlayCount != 0 );
        }
        else
        {
            // Something to do? but hidden, so return - value
            p->iFrame = p->PlayFrom;

            result = -( p->PlayCount != 0 );
        }

        ReleaseDC( p->hwnd, hdc );
        Leave( p );
    }

    return result;
}

void Ani_OnStyleChanged(ANIMATE* p, WPARAM gwl, STYLESTRUCT *pinfo)
{
    if (gwl == GWL_STYLE) 
    {
        p->style = pinfo->styleNew;
    }
}

LRESULT CALLBACK AnimateWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    ANIMATE *p = (ANIMATE *)GetWindowPtr(hwnd, 0);
    HDC hdc;
    PAINTSTRUCT ps;

    // First, the messages that can handle p == NULL.
    // All these handlers must end with a "return" or a "goto DoDefault".

    switch (msg) 
    {
    case WM_NCCREATE:

        #define lpcs ((LPCREATESTRUCT)lParam)

        p = (ANIMATE *)LocalAlloc(LPTR, sizeof(ANIMATE));

        if (!p)
            return 0;       // WM_NCCREATE failure is 0

        // note, zero init memory from above
        p->hwnd = hwnd;
        p->hwndP = lpcs->hwndParent;
        p->id = PtrToUlong(lpcs->hMenu);        // really was an int
        p->fFirstPaint = TRUE;
        p->style = lpcs->style;

        // Must do this before SetWindowBits because that will recursively
        // cause us to receive WM_STYLECHANGED and possibly even WM_SIZE
        // messages.
        InitializeCriticalSection(&p->crit);


        SetWindowPtr(hwnd, 0, p);

        //
        // UnMirror the control, if it is mirrored. We shouldn't mirror
        // a movie! [samera]
        //
        SetWindowBits(hwnd, GWL_EXSTYLE, RTL_MIRRORED_WINDOW, 0);

        goto DoDefault;

    case WM_CLOSE:
        Animate_Stop(hwnd);
        goto DoDefault;

    case WM_NCHITTEST:
        return HTTRANSPARENT;

    case WM_GETOBJECT:
        if (lParam == OBJID_QUERYCLASSNAMEIDX)
            return MSAA_CLASSNAMEIDX_ANIMATE;
        goto DoDefault;
    }

    // Okay, now the messages that cannot handle p == NULL.
    // We check p == NULL once and for all.

    if (!p) 
        goto DoDefault;

    switch (msg) 
    {
    case WM_DESTROY:
        Animate_Close(hwnd);
        DeleteCriticalSection(&p->crit);
        LocalFree((HLOCAL)p);
        SetWindowPtr(hwnd, 0, 0);
        break;

    case WM_ERASEBKGND:
        return(1);

    case WM_PAINT:
        HandleFirstPaint(p);
        hdc = BeginPaint(hwnd, &ps);
        HandlePaint(p, hdc);
        EndPaint(hwnd, &ps);
        return 0;

    case WM_PRINTCLIENT:
        HandlePrint(p, (HDC)wParam);
        return 0;

    case WM_STYLECHANGED:
        Ani_OnStyleChanged(p, wParam, (LPSTYLESTRUCT)lParam);
        return 0L;
        
    case WM_SIZE:
        if (p->style & ACS_CENTER)
        {
            OffsetRect(&p->rc, (LOWORD(lParam)-RectWid(p->rc))/2-p->rc.left,
                       (HIWORD(lParam)-RectHgt(p->rc))/2-p->rc.top);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        break;

    case WM_TIMER:
        {
            int result = HandleTick(p);
            if (!result)
            {
                HandleStop(p);
            }
            else if (result < 0)
            {
                p->PaintThread = (HANDLE)SetTimer(p->hwnd, 42, (UINT)p->Rate+4000, NULL);
            } 
            else
            {
                p->PaintThread = (HANDLE)SetTimer(p->hwnd, 42, (UINT)p->Rate, NULL);
            }
        }
        break;


    case ACM_OPENA:
    {
        WCHAR szFileNameW[MAX_PATH];
        LPTSTR lpFileName = szFileNameW;

        if (!IS_INTRESOURCE(lParam)) 
        {
            MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lParam, -1, szFileNameW, ARRAYSIZE(szFileNameW));
        } 
        else 
        {
            lpFileName = (LPTSTR) lParam;
        }
        
        return HandleOpen(p, (HINSTANCE)wParam, lpFileName, 0);
    }

    case ACM_OPEN:
        return HandleOpen(p, (HINSTANCE)wParam, (LPCTSTR)lParam, 0);

    case ACM_STOP:
        return HandleStop(p);

    case ACM_PLAY:
        return HandlePlay(p, (int)(SHORT)LOWORD(lParam), (int)(SHORT)HIWORD(lParam), (int)wParam);
    }

DoDefault:
    return DefWindowProc(hwnd, msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\ccontrol.h ===
class CControl
{
protected:
    
    //Function Memebers
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnPaint(HDC hdc);

    virtual ~CControl() {};
    virtual void v_OnNCPaint() {};
    virtual void v_OnPaint(HDC hdc) = 0;
    virtual LRESULT v_OnCreate() = 0;
    virtual void v_OnSize(int x, int y) = 0;
    virtual LRESULT v_OnCommand(WPARAM wParam, LPARAM lParam) { return 0;};
    virtual LRESULT v_OnNotify(WPARAM wParam, LPARAM lParam) { return 0;};
    virtual DWORD v_OnStyleChanged(WPARAM wParam, LPARAM lParam);
    
    virtual BOOL v_OnNCCalcSize(WPARAM wParam, LPARAM lParam, LRESULT* plres);

    virtual LPCTSTR GetThemeClass() { return TEXT(""); }

    //Data Members
    CCONTROLINFO ci;     // common control header info
    HTHEME _hTheme;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\button.h ===
#if !defined(__Button_h__INCLUDED)
#define __Button_h__INCLUDED

/////////////////////////////////////////////////////////////////////////////
//
// Button Control
//
/////////////////////////////////////////////////////////////////////////////

//
// Button states
//
#define BST_CHECKMASK   0x0003
#define BST_INCLICK     0x0010
#define BST_CAPTURED    0x0020
#define BST_MOUSE       0x0040
#define BST_DONTCLICK   0x0080
#define BST_INBMCLICK   0x0100

#define PBF_PUSHABLE    0x0001
#define PBF_DEFAULT     0x0002

//
// Button_DrawText codes
//
#define DBT_TEXT        0x0001
#define DBT_FOCUS       0x0002

#define BS_PUSHBOX      0x0000000AL
#define BS_TYPEMASK     0x0000000FL
#define BS_IMAGEMASK    0x000000C0L
#define BS_HORZMASK     0x00000300L
#define BS_VERTMASK     0x00000C00L
#define BS_ALIGNMASK    0x00000F00L

//
// Button macros
//
#define ISBSTEXTOROD(ulStyle)   \
            (((ulStyle & BS_BITMAP) == 0) && ((ulStyle & BS_ICON) == 0))


#define BUTTONSTATE(pbutn)      \
            (pbutn->buttonState)

//
// Instance data pointer access functions
//
#define Button_GetPtr(hwnd)    \
            (PBUTN)GetWindowPtr(hwnd, 0)

#define Button_SetPtr(hwnd, p) \
            (PBUTN)SetWindowPtr(hwnd, 0, p)

//
//  Button data structure
//
typedef struct tagBUTN 
{
    CCONTROLINFO ci;
    UINT    buttonState;    // Leave this a word for compatibility with SetWindowWord( 0L )
    HANDLE  hFont;
    HANDLE  hImage;
    UINT    fPaintKbdCuesOnly : 1;
    RECT    rcText;
    RECT    rcIcon;
    HIMAGELIST himl;
    UINT    uAlign;
    HTHEME  hTheme;         // Handle to the theme manager
    PWW     pww;            // RO pointer into the pwnd to ExStyle, Style, State, State2
} BUTN, *PBUTN;


//
// Button WndProc Prototype
//
extern LRESULT Button_WndProc(
    HWND   hwnd, 
    UINT   uMsg, 
    WPARAM wParam,
    LPARAM lParam);


#endif // __Button_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\ccver.h ===
//
//  ccver.h
//
//  App compat hack.  Apps, as always, mess up the major/minor version
//  check, so they think that 5.0 is less than 4.71 because they use
//
//    if (major < 4 && minor < 71) Fail();
//
//
//  So we artificially add 80 to our minor version, so 5.0 becomes 5.80,
//  etc.  Note that the hex version is 0x050, since 0x50 = 80 decimal.
//
//
//  The C preprocessor isn't smart enough to extract the commas out of
//  a value string, so we just do it all by hand and assert that nobody
//  has messed with <ntverp.h> or <ieverp.h> in a significant way.
//

#if _WIN32_IE == 0x0500

#define VER_FILEVERSION             5,80,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_FILEVERSION_STR         "5.80"
#define VER_FILEVERSION_W           0x0550
#define VER_FILEVERSION_DW          (0x05500000 | VER_PRODUCTBUILD)

#elif _WIN32_IE == 0x0501

#define VER_FILEVERSION             5,81,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_FILEVERSION_STR         "5.81"
#define VER_FILEVERSION_W           0x0551
#define VER_FILEVERSION_DW          (0x05510000 | VER_PRODUCTBUILD)

#elif _WIN32_IE == 0x0600

#define VER_FILEVERSION             6,0,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_FILEVERSION_STR         "6.0"
#define VER_FILEVERSION_W           0x0600
#define VER_FILEVERSION_DW          (0x06000000 | VER_PRODUCTBUILD)


#else
//
//  If this #error fires, you have to add a new version mapping.
//
#error Need to modify ccver.h for new IE/NT version.
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\button.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "button.h"

//
// ButtonCalcRect codes
//
#define CBR_CLIENTRECT 0
#define CBR_CHECKBOX   1
#define CBR_CHECKTEXT  2
#define CBR_GROUPTEXT  3
#define CBR_GROUPFRAME 4
#define CBR_PUSHBUTTON 5
#define CBR_RADIOBUTTON 6


#define Button_IsThemed(pbutn)  ((pbutn)->hTheme && (pbutn)->hImage == NULL)

//---------------------------------------------------------------------------//
CONST BYTE mpStyleCbr[] = 
{
    CBR_PUSHBUTTON,     // BS_PUSHBUTTON
    CBR_PUSHBUTTON,     // BS_DEFPUSHBUTTON
    CBR_CHECKTEXT,      // BS_CHECKBOX
    CBR_CHECKTEXT,      // BS_AUTOCHECKBOX
    CBR_CHECKTEXT,      // BS_RADIOBUTTON
    CBR_CHECKTEXT,      // BS_3STATE
    CBR_CHECKTEXT,      // BS_AUTO3STATE
    CBR_GROUPTEXT,      // BS_GROUPBOX
    CBR_CLIENTRECT,     // BS_USERBUTTON
    CBR_CHECKTEXT,      // BS_AUTORADIOBUTTON
    CBR_CLIENTRECT,     // BS_PUSHBOX
    CBR_CLIENTRECT,     // BS_OWNERDRAW
};

#define IMAGE_BMMAX    IMAGE_CURSOR+1
static CONST BYTE rgbType[IMAGE_BMMAX] = 
{
    BS_BITMAP,          // IMAGE_BITMAP
    BS_ICON,            // IMAGE_CURSOR
    BS_ICON             // IMAGE_ICON
};

#define IsValidImage(imageType, realType, max)   \
    ((imageType < max) && (rgbType[imageType] == realType))

typedef struct tagBTNDATA 
{
    LPTSTR  pszText;    // Text string
    INT     cchText;    // char count of string
    PBUTN   pbutn;      // Button data
    WORD    wFlags;     // Alignment flags
} BTNDATA, *LPBTNDATA;

//---- to support multiple themes in a single process, move these into PBUTN ----
static SIZE sizeCheckBox = {0};
static SIZE sizeRadioBox = {0};

//---------------------------------------------------------------------------//
//
// Forwards
//
VOID    Button_DrawPush(PBUTN pbutn, HDC hdc, UINT pbfPush);
VOID    GetCheckBoxSize(HDC hdc, PBUTN pbutn, BOOL fCheckBox, LPSIZE psize);
WORD    GetAlignment(PBUTN pbutn);
VOID    Button_CalcRect(PBUTN pbutn, HDC hdc, LPRECT lprc, int iCode, UINT uFlags);
VOID    Button_MultiExtent(WORD wFlags, HDC hdc, LPRECT lprcMax, LPTSTR lpsz, INT cch, PINT pcx, PINT pcy);

__inline UINT    IsPushButton(PBUTN pbutn);
__inline ULONG   GetButtonType(ULONG ulWinStyle);


//---------------------------------------------------------------------------//
//
//  InitButtonClass() - Registers the control's window class 
//
BOOL InitButtonClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = Button_WndProc;
    wc.lpszClassName = WC_BUTTON;
    wc.style         = CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS | CS_VREDRAW | CS_HREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PBUTN);
    wc.hInstance     = hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}


//---------------------------------------------------------------------------//
//
// Button_GetThemeIds() - Gets the associated iPartId and iStateId needed for
//                        the theme manager APIs for the button control passed
//                        in pbutn. 
//
HRESULT Button_GetThemeIds(PBUTN pbutn, LPINT piPartId, LPINT piStateId)
{
    if ( piPartId )
    {
        ULONG ulStyle = GET_STYLE(pbutn);

        if (IsPushButton(pbutn))
        {
            *piPartId = BP_PUSHBUTTON;
        }
        else
        {

            switch (GetButtonType(ulStyle)) 
            {
            case BS_CHECKBOX:
            case BS_AUTOCHECKBOX:
            case BS_3STATE:
            case BS_AUTO3STATE:
                *piPartId = BP_CHECKBOX;
                break;

            case BS_RADIOBUTTON:
            case BS_AUTORADIOBUTTON:
                *piPartId = BP_RADIOBUTTON;
                break;

            case BS_GROUPBOX:
                *piPartId = BP_GROUPBOX;
                break;

            case BS_OWNERDRAW:
                //
                // don't do anything with owerdrawn buttons
                //
                return E_FAIL;

            default:
                TraceMsg(TF_STANDARD, "What kind of buttonType is this, %#.2x", GetButtonType(ulStyle));
                *piPartId = BP_PUSHBUTTON;
                break;
            }
        }

        if (piStateId)
        {
            switch (*piPartId)
            {
            case BP_PUSHBUTTON:
                if ((pbutn->buttonState & BST_PUSHED) || 
                    ((pbutn->buttonState & (BST_CHECKED|BST_HOT)) == BST_CHECKED))
                {
                    *piStateId = PBS_PRESSED;
                }
                else if (!IsWindowEnabled(pbutn->ci.hwnd))
                {
                    *piStateId = PBS_DISABLED;
                }
                else if (pbutn->buttonState & BST_HOT)
                {
                    *piStateId = PBS_HOT;
                }
                else if (ulStyle & BS_DEFPUSHBUTTON)
                {
                    *piStateId = PBS_DEFAULTED;
                }
                else
                {
                    *piStateId = PBS_NORMAL;
                }
                break;

            case BP_CHECKBOX:
            case BP_RADIOBUTTON:
                //
                // NOTE (phellyar): We're relying on the order of the RADIOBUTTONSTATES and 
                //                  CHECKBOXSTATES enums in tmdefs.h to calculate the correct 
                //                  StateId. If the ordering of those enums changes, revisit 
                //                  the logic here.
                //                  Note also that CHECKBOXSTATES is a super set of 
                //                  RADIOBUTTONSTATES which is why we're using CBS_* here.
                //
                if ( pbutn->buttonState & BST_CHECKED )
                {
                    //
                    // button is checked
                    //
                    *piStateId = CBS_CHECKEDNORMAL;
                }
                else if ( pbutn->buttonState & BST_INDETERMINATE )
                {
                    //
                    // button is intedeterminate
                    //
                    *piStateId = CBS_MIXEDNORMAL;
                }
                else
                {
                    //
                    // button is unchecked
                    //
                    *piStateId = CBS_UNCHECKEDNORMAL;
                }

                if ( pbutn->buttonState & BST_PUSHED )
                {
                    //
                    // being pressed 
                    //
                    *piStateId += 2;
                }
                else if (!IsWindowEnabled(pbutn->ci.hwnd))
                {
                    //
                    // disabled
                    //
                    *piStateId += 3;
                }
                else if (pbutn->buttonState & BST_HOT )
                {
                    //
                    // mouse over
                    //
                    *piStateId += 1;
                }

                break;

            case BP_GROUPBOX:
                if (!IsWindowEnabled(pbutn->ci.hwnd))
                {
                    *piStateId = GBS_DISABLED;
                }
                else
                {
                    *piStateId = GBS_NORMAL;
                }
                break;
            }
        }
        
    }

    return S_OK;
}


//---------------------------------------------------------------------------//
//
// Button_GetTextFlags() - Returns the DrawTextEx flags that should be used
//                         when rendering text for this control, needed by
//                         DrawThemeText.
//
DWORD Button_GetTextFlags(PBUTN pbutn)
{
    DWORD dwTextFlags = 0;
    WORD  wAlign = GetAlignment(pbutn);
    ULONG ulStyle = GET_STYLE(pbutn);

    //
    // Set up text flags
    //
      
    //
    // horizontal text alignment 
    //
    switch (wAlign & HIBYTE(BS_HORZMASK))
    {
    case HIBYTE(BS_LEFT):
        dwTextFlags |= DT_LEFT;
        break;

    case HIBYTE(BS_RIGHT):
        dwTextFlags |= DT_RIGHT;
        break;

    case HIBYTE(BS_CENTER):
        dwTextFlags |= DT_CENTER;
        break;
    }

    //
    // vertical text alignment
    //
    switch (wAlign & HIBYTE(BS_VERTMASK))
    {
    case HIBYTE(BS_TOP):
        dwTextFlags |= DT_TOP;
        break;

    case HIBYTE(BS_BOTTOM):
        dwTextFlags |= DT_BOTTOM;
        break;

    case HIBYTE(BS_VCENTER):
        dwTextFlags |= DT_VCENTER;
        break;

    }

    //
    // line break
    //
    if (ulStyle & BS_MULTILINE)
    {
        dwTextFlags |= (DT_WORDBREAK | DT_EDITCONTROL);
    }
    else
    {
        dwTextFlags |= DT_SINGLELINE;
    }


    if (ulStyle & SS_NOPREFIX)
    {
        dwTextFlags |= DT_NOPREFIX;
    }
 
    //
    // Draw the underscore for accelorators?
    //
    if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIACCELHIDDEN))
    {
        dwTextFlags |= DT_HIDEPREFIX;
    }

    return dwTextFlags;
}

DWORD ButtonStateToCustomDrawState(PBUTN pbutn)
{
    DWORD itemState = 0;
    if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIFOCUSHIDDEN))
    {
        itemState |= CDIS_SHOWKEYBOARDCUES;
    }

    if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIACCELHIDDEN))
    {
        itemState |= CDIS_SHOWKEYBOARDCUES;
    }

    if (BUTTONSTATE(pbutn) & BST_FOCUS) 
    {
        itemState |= CDIS_FOCUS;
    }

    if (BUTTONSTATE(pbutn) & BST_PUSHED) 
    {
        itemState |= CDIS_SELECTED;
    }

    if (BUTTONSTATE(pbutn) & BST_HOT) 
    {
        itemState |= CDIS_HOT;
    }

    if (!IsWindowEnabled(pbutn->ci.hwnd))
    {
        itemState |= CDIS_DISABLED;
    }

    return itemState;
}


void Button_GetImagePosition(PBUTN pbutn, RECT* prc, int* px, int* py)
{
    int cx = 0;
    int cy = 0;
    CCGetIconSize(&pbutn->ci, pbutn->himl, &cx, &cy);

    cx += pbutn->rcIcon.left + pbutn->rcIcon.right;
    cy += pbutn->rcIcon.top + pbutn->rcIcon.bottom;
    switch (pbutn->uAlign)
    {
    case BUTTON_IMAGELIST_ALIGN_RIGHT:
        *px = prc->right - cx;
        *py = prc->top + (RECTHEIGHT(*prc) - cy) / 2 + pbutn->rcIcon.top;
        prc->right -= cx;
        break;

    case BUTTON_IMAGELIST_ALIGN_CENTER:     // This means no text
        *px = prc->left + (RECTWIDTH(*prc) - cx) / 2 + pbutn->rcIcon.left;
        *py = prc->top + (RECTHEIGHT(*prc) - cy) / 2 + pbutn->rcIcon.top;
        break;

    case BUTTON_IMAGELIST_ALIGN_TOP: 
       *px = prc->left + (RECTWIDTH(*prc) - cx) / 2 + pbutn->rcIcon.left;
        *py = pbutn->rcIcon.top;
        prc->top += cy;
        break;

    case BUTTON_IMAGELIST_ALIGN_BOTTOM:
        *px = (RECTWIDTH(*prc) - cx) / 2 + pbutn->rcIcon.left;
        *py = prc->bottom - cy;
        prc->bottom -= cy;
        break;

    case BUTTON_IMAGELIST_ALIGN_LEFT:
        // Fall
    default:
        *px = prc->left + pbutn->rcIcon.left;
        *py = prc->top + (RECTHEIGHT(*prc) - cy) / 2 + pbutn->rcIcon.top;
        prc->left += cx;
        break;

    }
}


//---------------------------------------------------------------------------//
//
//  Button_DrawThemed() - Renders button control according to the current
//                        theme.
//                        pbutn    - the button control to render
//                        hdc      - the hdc to draw on
//                        iPartId  - the button part
//                        iStateId - the button state
//
HRESULT Button_DrawThemed(PBUTN pbutn, HDC hdc, int iPartId, int iStateId)
{
    HRESULT hr;
    RECT    rcClient;
    RECT    rcContent;
    RECT    rcFocus;
    RECT    rcCheck;
    DWORD   dwTextFlags;
    LPWSTR  pszText;
    INT     cchText;
    NMCUSTOMDRAW nmcd = {0};

    BOOL    fRadioOrCheck = (iPartId == BP_RADIOBUTTON || iPartId == BP_CHECKBOX );

    //
    // Render the button background
    //
    GetClientRect(pbutn->ci.hwnd, &rcClient);
    rcCheck = rcContent = rcClient;
    if ( fRadioOrCheck )
    {
        SIZE sizeChar; 
        SIZE sizeCheck;
        int iCode;

        //
        // Compat....
        //

        GetTextExtentPoint32(hdc, TEXT("0"), 1, &sizeChar); 

        GetCheckBoxSize(hdc, pbutn, (iPartId == BP_CHECKBOX), &sizeCheck);
        
        if (iPartId == BP_CHECKBOX)
            iCode = CBR_CHECKBOX;
        else
            iCode = CBR_RADIOBUTTON;

        Button_CalcRect(pbutn, hdc, &rcCheck, iCode, 0);

        rcCheck.bottom = rcCheck.top + sizeCheck.cx;

        if ((GET_STYLE(pbutn) & BS_RIGHTBUTTON) != 0)
        {
            rcCheck.left = rcContent.right - sizeCheck.cx;
            rcContent.right = rcCheck.left - (sizeChar.cx/2);
        }
        else
        {
            rcCheck.right = rcContent.left + sizeCheck.cx;
            rcContent.left = rcCheck.right + (sizeChar.cx/2);
        }

        //---- shrink radiobutton/checkbox button to fix client rect ----
        if (RECTWIDTH(rcClient) < RECTWIDTH(rcCheck))
        {
            rcCheck.right = rcCheck.left + RECTWIDTH(rcClient);
        }

        if (RECTHEIGHT(rcClient) < RECTHEIGHT(rcCheck))
        {
            rcCheck.bottom = rcCheck.top + RECTHEIGHT(rcClient);
        }
    }

    nmcd.hdc = hdc;
    nmcd.rc = rcClient;
    nmcd.dwItemSpec = GetWindowID(pbutn->ci.hwnd);
    nmcd.uItemState = ButtonStateToCustomDrawState(pbutn);


    pbutn->ci.dwCustom = CICustomDrawNotify(&pbutn->ci, CDDS_PREERASE, &nmcd);

    if (!(pbutn->ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        hr = DrawThemeBackground(pbutn->hTheme, hdc, iPartId, iStateId, &rcCheck, 0);
        if (FAILED(hr))
        {
            TraceMsg(TF_STANDARD, "Failed to render theme background");
            return hr;
        }

        if (pbutn->ci.dwCustom & CDRF_NOTIFYPOSTERASE)
            CICustomDrawNotify(&pbutn->ci, CDDS_POSTERASE, &nmcd);

        pbutn->ci.dwCustom = CICustomDrawNotify(&pbutn->ci, CDDS_PREPAINT, &nmcd);

        if (!(pbutn->ci.dwCustom & CDRF_SKIPDEFAULT))
        {
            //
            // Render the button text
            //
            GetThemeBackgroundContentRect(pbutn->hTheme, hdc, iPartId, iStateId, &rcContent, &rcContent);

            rcFocus = rcContent;

            if (pbutn->himl)
            {
                int x, y;
                int iImage = 0;
                if (ImageList_GetImageCount(pbutn->himl) > 1)
                {
                    iImage = (iStateId - PBS_NORMAL);
                }

                Button_GetImagePosition(pbutn, &rcContent, &x, &y);

                ImageList_Draw(pbutn->himl, iImage, hdc, x, y, ILD_TRANSPARENT | (CCDPIScale(pbutn->ci)?ILD_DPISCALE:0));
            }

            //
            // Get the button text
            //
            cchText = GetWindowTextLength(pbutn->ci.hwnd);
            if (cchText <= 0)
            {
                //
                // Nothing to draw
                //
                return hr;
            }

            pszText = UserLocalAlloc(0, (cchText+1)*SIZEOF(WCHAR));
            if (pszText == NULL) 
            {
                TraceMsg(TF_STANDARD, "Can't allocate buffer");
                return E_FAIL;
            }

            GetWindowTextW(pbutn->ci.hwnd, pszText, cchText+1);

            dwTextFlags = Button_GetTextFlags(pbutn);

            if ( TESTFLAG(GET_STYLE(pbutn), BS_MULTILINE) || fRadioOrCheck )
            {
                int  cxWidth, cyHeight;
                TEXTMETRIC tm;

                if ( TESTFLAG(GET_STYLE(pbutn), BS_MULTILINE) )
                {
                    RECT rcTextExtent = rcContent;

                    cyHeight = DrawTextEx(hdc, pszText, cchText, &rcTextExtent, dwTextFlags|DT_CALCRECT, NULL);
                    cxWidth  = RECTWIDTH(rcTextExtent);
                }
                else
                {
                    SIZE   size;
                    LPWSTR pszStrip = UserLocalAlloc(0, (cchText+1)*SIZEOF(WCHAR));

                    if (pszStrip)
                    {
                        INT cchStrip = StripAccelerators(pszText, pszStrip, TRUE);
                        GetTextExtentPoint32(hdc, pszStrip, cchStrip, &size);
                        UserLocalFree(pszStrip);
                    }
                    else
                    {
                        GetTextExtentPoint32(hdc, pszText, cchText, &size);
                    }

                    cyHeight = size.cy;
                    cxWidth = size.cx;
                }

                if (fRadioOrCheck && (cyHeight < RECTHEIGHT(rcCheck)))
                {
                    // optimization for single line check/radios, align them with the top
                    // of the check no matter when the vertical alignment
                    rcContent.top = rcCheck.top;
                }
                else
                {
                    if (dwTextFlags & DT_VCENTER)
                    {
                        rcContent.top += (RECTHEIGHT(rcContent) - cyHeight) / 2;
                    }
                    else if (dwTextFlags & DT_BOTTOM)
                    {
                        rcContent.top = rcContent.bottom - cyHeight;
                    }
                }

                if ( GetTextMetrics( hdc, &tm ) && (tm.tmInternalLeading == 0) )
                {
                    // Far East fonts that have no leading. Leave space to prevent
                    // focus rect from obscuring text.
                    rcContent.top += g_cyBorder;
                }
                rcContent.bottom = rcContent.top + cyHeight;

                if (dwTextFlags & DT_CENTER)
                {
                    rcContent.left += (RECTWIDTH(rcContent) - cxWidth) / 2;
                }
                else if (dwTextFlags & DT_RIGHT)
                {
                    rcContent.left = rcContent.right - cxWidth;
                }
                rcContent.right= rcContent.left + cxWidth;
                

                if ( fRadioOrCheck )
                {
                    //
                    // Inflate the bounding rect a litte, but contrained to
                    // within the client area.
                    //
                    rcFocus.top    = max(rcClient.top,    rcContent.top-1);
                    rcFocus.bottom = min(rcClient.bottom, rcContent.bottom+1);

                    rcFocus.left   = max(rcClient.left,  rcContent.left-1);
                    rcFocus.right  = min(rcClient.right, rcContent.right+1);
                }
            }

            hr = DrawThemeText(pbutn->hTheme, hdc, iPartId, iStateId, pszText, cchText, dwTextFlags, 0, &rcContent);
            if (FAILED(hr))
            {
                TraceMsg(TF_STANDARD, "Failed to render button text");
            }

            if (!TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIFOCUSHIDDEN) && (BUTTONSTATE(pbutn) & BST_FOCUS))
            {
                DrawFocusRect(hdc, &rcFocus);
            }


            UserLocalFree(pszText);
            if (pbutn->ci.dwCustom & CDRF_NOTIFYPOSTPAINT)
            {
                CICustomDrawNotify(&pbutn->ci, CDDS_POSTPAINT, &nmcd);
            }
        }
    }

    return hr;
}


//---------------------------------------------------------------------------//
//
//  Button_GetTheme() - Get a handle to the theme for this button control 
//
HTHEME Button_GetTheme(PBUTN pbutn)
{
    //
    // Button's with predefined IDs can be 
    // themed differently
    //
    static LPWSTR szButtonClasses[] = 
    {
        L"Button",                  // =0
        L"Button-OK;Button",        // IDOK=1
        L"Button-CANCEL;Button",    // IDCANCEL=2
        L"Button-ABORT;Button",     // IDABORT=3
        L"Button-RETRY;Button",     // IDRETRY=4
        L"Button-IGNORE;Button",    // IDIGNORE=5
        L"Button-YES;Button",       // IDYES=6
        L"Button-NO;Button",        // IDNO=7
        L"Button-CLOSE;Button",     // IDCLOSE=8
        L"Button-HELP;Button",      // IDHELP=9
        L"Button-TRYAGAIN;Button",  // IDTRYAGAIN=10
        L"Button-CONTINUE;Button",  // IDCONTINUE=11
        L"Button-APPLY;Button",     // IDAPPLY=12 (not yet std)
    };
    int iButtonId = GetWindowID(pbutn->ci.hwnd);

    if (iButtonId < 0 || iButtonId >= ARRAYSIZE(szButtonClasses))  // outside range
    {
        iButtonId = 0;
    }

    EnableThemeDialogTexture(GetParent(pbutn->ci.hwnd), ETDT_ENABLE);

    return OpenThemeData(pbutn->ci.hwnd, szButtonClasses[iButtonId]);
}



//---------------------------------------------------------------------------//
//
VOID GetCheckBoxSize(HDC hdc, PBUTN pbutn, BOOL fCheckBox, LPSIZE psize)
{
    SIZE *psz;

    if (fCheckBox)
        psz = &sizeCheckBox;
    else
        psz = &sizeRadioBox;

    if ((! psz->cx) && (! psz->cy))         // not yet calculated
    {
        BOOL fGotSize = FALSE;

        if (pbutn->hTheme)          // get themed size
        {
            int iPartId;
            HRESULT hr;

            if (fCheckBox)
                iPartId = BP_CHECKBOX;
            else
                iPartId = BP_RADIOBUTTON;

            hr = GetThemePartSize(pbutn->hTheme, hdc, iPartId, 1, NULL, TS_DRAW, psz);
            if (FAILED(hr))
            {
                TraceMsg(TF_STANDARD, "Failed to get theme part size for checkbox/radiobutton");
            }
            else
            {
                fGotSize = TRUE;
            }
        }

        if (! fGotSize)            // get classic size (use checkbox for both)
        {
            HBITMAP hbmp = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_CHECKBOXES));

            if (hbmp != NULL) 
            {
                BITMAP  bmp;

                GetObject(hbmp, sizeof(BITMAP), &bmp);

                //
                // Checkbox bitmap is arranged 4 over and three down.  Only need to get
                // the size of a single checkbox, so do the math here.
                //
                psz->cx = bmp.bmWidth / 4;
                psz->cy = bmp.bmHeight / 3;

                DeleteObject(hbmp);
            }
            else
            {
                AssertMsg(hbmp != NULL, TEXT("Unable to load checkbox bitmap"));
            }
        }
    }

    *psize = *psz;
}


//---------------------------------------------------------------------------//
//
__inline BYTE GetButtonStyle(ULONG ulWinStyle)
{
    return (BYTE) LOBYTE(ulWinStyle & BS_TYPEMASK);
}


//---------------------------------------------------------------------------//
//
__inline ULONG GetButtonType(ULONG ulWinStyle)
{
    return ulWinStyle & BS_TYPEMASK;
}


//---------------------------------------------------------------------------//
//
// IsPushButton()
//
// Returns non-zero if the window is a push button.  Returns flags that
// are interesting if it is.  These flags are
//
UINT IsPushButton(PBUTN pbutn)
{
    BYTE bStyle;
    UINT flags;

    ULONG ulStyle = GET_STYLE(pbutn);

    bStyle = GetButtonStyle(ulStyle);
    flags = 0;

    switch (bStyle) 
    {
    case LOBYTE(BS_PUSHBUTTON):
        flags |= PBF_PUSHABLE;
        break;

    case LOBYTE(BS_DEFPUSHBUTTON):
        flags |= PBF_PUSHABLE | PBF_DEFAULT;
        break;

    default:
        if (ulStyle & BS_PUSHLIKE)
        {
            flags |= PBF_PUSHABLE;
        }
    }

    return flags;
}


//---------------------------------------------------------------------------//
//
// GetAlignment()
//
// Gets default alignment of button.  If BS_HORZMASK and/or BS_VERTMASK
// is specified, uses those.  Otherwise, uses default for button.
//
// It's probably a fine time to describe what alignment flags mean for
// each type of button.  Note that the presence of a bitmap/icon affects
// the meaning of alignments.
//
// (1) Push like buttons
//      With one of {bitmap, icon, text}:
//          Just like you'd expect
//      With one of {bitmap, icon} AND text:
//          Image & text are centered as a unit; alignment means where
//          the image shows up.  E.G., left-aligned means the image
//          on the left, text on the right.
// (2) Radio/check like buttons
//      Left aligned means check/radio box is on left, then bitmap/icon
//          and text follows, left justified.
//      Right aligned means checkk/radio box is on right, preceded by
//          text and bitmap/icon, right justified.
//      Centered has no meaning.
//      With one of {bitmap, icon} AND text:
//          Top aligned means bitmap/icon above, text below
//          Bottom aligned means text above, bitmap/icon below
//      With one of {bitmap, icon, text}
//          Alignments mean what you'd expect.
// (3) Group boxes
//      Left aligned means text is left justified on left side
//      Right aligned means text is right justified on right side
//      Center aligned means text is in middle
//
WORD GetAlignment(PBUTN pbutn)
{
    BYTE bHorz;
    BYTE bVert;

    ULONG ulStyle = GET_STYLE(pbutn);

    bHorz = HIBYTE(ulStyle & BS_HORZMASK);
    bVert = HIBYTE(ulStyle & BS_VERTMASK);

    if (!bHorz || !bVert) 
    {
        if (IsPushButton(pbutn)) 
        {
            if (!bHorz)
            {
                bHorz = HIBYTE(BS_CENTER);
            }
        } 
        else 
        {
            if (!bHorz)
            {
                bHorz = HIBYTE(BS_LEFT);
            }
        }

        if (GetButtonStyle(ulStyle) == BS_GROUPBOX)
        {
            if (!bVert)
            {
                bVert = HIBYTE(BS_TOP);
            }
        }
        else
        {
            if (!bVert)
            {
                bVert = HIBYTE(BS_VCENTER);
            }
        }
    }

    return bHorz | bVert;
}


//---------------------------------------------------------------------------//
//
// Button_SetFont()
//
// Changes button font, and decides if we can use real bold font for default
// push buttons or if we have to simulate it.
//
VOID Button_SetFont(PBUTN pbutn, HFONT hFont, BOOL fRedraw)
{
    pbutn->hFont = hFont;

    if (fRedraw && IsWindowVisible(pbutn->ci.hwnd)) 
    {
        InvalidateRect(pbutn->ci.hwnd, NULL, TRUE);
    }
}


//---------------------------------------------------------------------------//
//
HBRUSH Button_InitDC(PBUTN pbutn, HDC hdc)
{
    UINT    uMsg;
    BYTE    bStyle;
    HBRUSH  hBrush;
    ULONG   ulStyle   = GET_STYLE(pbutn);
    ULONG   ulStyleEx = GET_EXSTYLE(pbutn);

    //
    // Set BkMode before getting brush so that the app can change it to
    // transparent if it wants.
    //
    SetBkMode(hdc, OPAQUE);

    bStyle = GetButtonStyle(ulStyle);

    switch (bStyle) 
    {
    default:
        if (TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN40COMPAT) && ((ulStyle & BS_PUSHLIKE) == 0)) 
        {
            uMsg = WM_CTLCOLORSTATIC;
            break;
        }

    case LOBYTE(BS_PUSHBUTTON):
    case LOBYTE(BS_DEFPUSHBUTTON):
    case LOBYTE(BS_OWNERDRAW):
    case LOBYTE(BS_USERBUTTON):
        uMsg = WM_CTLCOLORBTN;
        break;
    }

    hBrush = (HBRUSH)SendMessage(GetParent(pbutn->ci.hwnd), uMsg, (WPARAM)hdc, (LPARAM)pbutn->ci.hwnd);

    //
    // Select in the user's font if set, and save the old font so that we can
    // restore it when we release the dc.
    //
    if (pbutn->hFont) 
    {
        SelectObject(hdc, pbutn->hFont);
    }

    //
    // Clip output to the window rect if needed.
    //
    if (bStyle != LOBYTE(BS_GROUPBOX)) 
    {
        RECT rcClient;

        GetClientRect(pbutn->ci.hwnd, &rcClient);
        IntersectClipRect(hdc, 0, 0,
            rcClient.right,
            rcClient.bottom);
    }

    if ((ulStyleEx & WS_EX_RTLREADING) != 0)
    {
        SetTextAlign(hdc, TA_RTLREADING | GetTextAlign(hdc));
    } 

    return hBrush;
}


//---------------------------------------------------------------------------//
//
HDC Button_GetDC(PBUTN pbutn, HBRUSH *phBrush)
{
    HDC hdc = NULL;

    if (IsWindowVisible(pbutn->ci.hwnd)) 
    {
        HBRUSH  hBrush;

        hdc = GetDC(pbutn->ci.hwnd);
        hBrush = Button_InitDC(pbutn, hdc);

        if ((phBrush != NULL) && hBrush)
        {
            *phBrush = hBrush;
        }
    }

    return hdc;
}


//---------------------------------------------------------------------------//
//
VOID Button_ReleaseDC(PBUTN pbutn, HDC hdc, HBRUSH *phBrush)
{
    ULONG ulStyleEx = GET_EXSTYLE(pbutn);

    if ((ulStyleEx & WS_EX_RTLREADING) != 0)
    {
        SetTextAlign(hdc, GetTextAlign(hdc) & ~TA_RTLREADING);
    }

    if (pbutn->hFont) 
    {
        SelectObject(hdc, GetStockObject(SYSTEM_FONT));
    }

    ReleaseDC(pbutn->ci.hwnd, hdc);
}


//---------------------------------------------------------------------------//
//
VOID Button_OwnerDraw(PBUTN pbutn, HDC hdc, UINT itemAction)
{
    DRAWITEMSTRUCT drawItemStruct;
    UINT itemState = 0;
    int  iButtonId = GetWindowID(pbutn->ci.hwnd);

    if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIFOCUSHIDDEN)) 
    {
        itemState |= ODS_NOFOCUSRECT;
    }

    if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIACCELHIDDEN)) 
    {
        itemState |= ODS_NOACCEL;
    }

    if (TESTFLAG(BUTTONSTATE(pbutn), BST_FOCUS)) 
    {
        itemState |= ODS_FOCUS;
    }

    if (TESTFLAG(BUTTONSTATE(pbutn), BST_PUSHED)) 
    {
        itemState |= ODS_SELECTED;
    }

    if (!IsWindowEnabled(pbutn->ci.hwnd))
    {
        itemState |= ODS_DISABLED;
    }

    //
    // Populate the draw item struct
    //
    drawItemStruct.CtlType    = ODT_BUTTON;
    drawItemStruct.CtlID      = iButtonId;
    drawItemStruct.itemAction = itemAction;
    drawItemStruct.itemState  = itemState;
    drawItemStruct.hwndItem   = pbutn->ci.hwnd;
    drawItemStruct.hDC        = hdc;
    GetClientRect(pbutn->ci.hwnd, &drawItemStruct.rcItem);
    drawItemStruct.itemData   = 0L;

    //
    // Send a WM_DRAWITEM message to our parent
    //
    SendMessage(GetParent(pbutn->ci.hwnd), 
                WM_DRAWITEM, 
                (WPARAM)iButtonId,
                (LPARAM)&drawItemStruct);
}


//---------------------------------------------------------------------------//
//
VOID Button_CalcRect(PBUTN pbutn, HDC hdc, LPRECT lprc, int iCode, UINT uFlags)
{
    CONST TCHAR szOneChar[] = TEXT("0");

    SIZE   sizeExtent;
    int    dy;
    WORD   wAlign;
    int    cxEdge, cyEdge;
    int    cxBorder, cyBorder;

    ULONG  ulStyle   = GET_STYLE(pbutn);
    ULONG  ulStyleEx = GET_EXSTYLE(pbutn);

    cxEdge   = GetSystemMetrics(SM_CXEDGE);
    cyEdge   = GetSystemMetrics(SM_CYEDGE);
    cxBorder = GetSystemMetrics(SM_CXBORDER);
    cyBorder = GetSystemMetrics(SM_CYBORDER);

    GetClientRect(pbutn->ci.hwnd, lprc);

    wAlign = GetAlignment(pbutn);

    switch (iCode) 
    {
        case CBR_PUSHBUTTON:
            //
            // Subtract out raised edge all around
            //
            InflateRect(lprc, -cxEdge, -cyEdge);

            if (uFlags & PBF_DEFAULT)
            {
                InflateRect(lprc, -cxBorder, -cyBorder);
            }
            break;

        case CBR_CHECKBOX:
        case CBR_RADIOBUTTON:
        {
            SIZE sizeChk = {0};

            GetCheckBoxSize(hdc, pbutn, (iCode == CBR_CHECKBOX), &sizeChk);

            switch (wAlign & HIBYTE(BS_VERTMASK))
            {
            case HIBYTE(BS_VCENTER):
                lprc->top = (lprc->top + lprc->bottom - sizeChk.cy) / 2;
                break;

            case HIBYTE(BS_TOP):
            case HIBYTE(BS_BOTTOM):
                GetTextExtentPoint32(hdc, (LPTSTR)szOneChar, 1, &sizeExtent);
                dy = sizeExtent.cy + sizeExtent.cy/4;

                //
                // Save vertical extent
                //
                sizeExtent.cx = dy;

                //
                // Get centered amount
                //
                dy = (dy - sizeChk.cy) / 2;
                if ((wAlign & HIBYTE(BS_VERTMASK)) == HIBYTE(BS_TOP))
                {
                    lprc->top += dy;
                }
                else
                {
                    lprc->top = lprc->bottom - sizeExtent.cx + dy;
                }

                break;
            }

            if ((ulStyle & BS_RIGHTBUTTON) != 0)
            {
                lprc->left = lprc->right - sizeChk.cx;
            }
            else
            {
                lprc->right = lprc->left + sizeChk.cx;
            }

            break;
        }

        case CBR_CHECKTEXT:
        {
            SIZE sizeChk = {0};

            GetCheckBoxSize(hdc, pbutn, TRUE, &sizeChk);

            if ((ulStyle & BS_RIGHTBUTTON) != 0) 
            {
                lprc->right -= sizeChk.cx;

                //
                // More spacing for 4.0 dudes
                //
                if (TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN40COMPAT)) 
                {
                    GetTextExtentPoint32(hdc, szOneChar, 1, &sizeExtent);
                    lprc->right -= sizeExtent.cx  / 2;
                }

            } 
            else 
            {
                lprc->left += sizeChk.cx;

                //
                // More spacing for 4.0 dudes
                //
                if (TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN40COMPAT)) 
                {
                    GetTextExtentPoint32(hdc, szOneChar, 1, &sizeExtent);
                    lprc->left +=  sizeExtent.cx / 2;
                }
            }

            break;
        }

        case CBR_GROUPTEXT:
        {
            LPWSTR pszText = NULL;
            INT    cchText = GetWindowTextLength(pbutn->ci.hwnd);
            BOOL   fSucceeded = FALSE;

            if (cchText > 0)
            {
                pszText = UserLocalAlloc(0, (cchText+1)*SIZEOF(WCHAR));

                if (pszText)
                {
                    if (GetWindowText(pbutn->ci.hwnd, pszText, cchText+1) > 0)
                    {
                        //
                        // if not themed
                        //
                        if (!Button_IsThemed(pbutn))
                        {
                            GetTextExtentPoint32(hdc, pszText, cchText, &sizeExtent);
                        }
                        else
                        {
                            DWORD dwTextFlags = Button_GetTextFlags(pbutn);
                            RECT  rcExtent;
                            GetThemeTextExtent(pbutn->hTheme, 
                                               hdc, 
                                               BP_GROUPBOX, 
                                               0, 
                                               pszText,
                                               cchText,
                                               dwTextFlags,
                                               lprc,
                                               &rcExtent);

                            sizeExtent.cx = RECTWIDTH(rcExtent);
                            sizeExtent.cy = RECTHEIGHT(rcExtent);
                                                
                        }

                        sizeExtent.cx += GetSystemMetrics(SM_CXEDGE) * 2;

                        switch (wAlign & HIBYTE(BS_HORZMASK))
                        {
                            //
                            // BFLEFT, nothing
                            //
                            case HIBYTE(BS_LEFT):
                                lprc->left += (SYSFONT_CXCHAR - GetSystemMetrics(SM_CXBORDER));
                                lprc->right = lprc->left + (int)(sizeExtent.cx);
                                break;

                            case HIBYTE(BS_RIGHT):
                                lprc->right -= (SYSFONT_CXCHAR - GetSystemMetrics(SM_CXBORDER));
                                lprc->left = lprc->right - (int)(sizeExtent.cx);
                                break;

                            case HIBYTE(BS_CENTER):
                                lprc->left = (lprc->left + lprc->right - (int)(sizeExtent.cx)) / 2;
                                lprc->right = lprc->left + (int)(sizeExtent.cx);
                                break;
                        }

                        //
                        // Center aligned.
                        //
                        lprc->bottom = lprc->top + sizeExtent.cy + GetSystemMetrics(SM_CYEDGE);
                        fSucceeded = TRUE;
                    }

                    UserLocalFree(pszText);
                }
            }

            if (!fSucceeded)
            {
                SetRectEmpty(lprc);
            }

            break;
        }
        case CBR_GROUPFRAME:
            GetTextExtentPoint32(hdc, (LPTSTR)szOneChar, 1, &sizeExtent);
            lprc->top += sizeExtent.cy / 2;
            break;
    }
}


//---------------------------------------------------------------------------//
//
// Button_MultiExtent()
//
// Calculates button text extent, given alignment flags.
//
VOID Button_MultiExtent(WORD wFlags, HDC hdc, LPRECT lprcMax, LPTSTR pszBuffer, INT cchBuffer, PINT pcx, PINT pcy)
{
    RECT rc;
    UINT dtFlags = DT_CALCRECT | DT_WORDBREAK | DT_EDITCONTROL;

    CopyRect(&rc, lprcMax);

    //
    // Note that since we're just calculating the maximum dimensions,
    // left-justification and top-justification are not important.
    // Also, remember to leave margins horz and vert that follow our rules
    // in DrawBtnText().
    //

    InflateRect(&rc, -GetSystemMetrics(SM_CXEDGE), -GetSystemMetrics(SM_CYBORDER));

    if ((wFlags & LOWORD(BS_HORZMASK)) == LOWORD(BS_CENTER))
    {
        dtFlags |= DT_CENTER;
    }

    if ((wFlags & LOWORD(BS_VERTMASK)) == LOWORD(BS_VCENTER))
    {
        dtFlags |= DT_VCENTER;
    }

    DrawTextEx(hdc, pszBuffer, cchBuffer, &rc, dtFlags, NULL);

    if (pcx)
    {
        *pcx = rc.right-rc.left;
    }

    if (pcy)
    {
        *pcy = rc.bottom-rc.top;
    }
}


//---------------------------------------------------------------------------//
//
// Button_MultiDraw()
//
// Draws multiline button text
//
BOOL Button_MultiDraw(HDC hdc, LPARAM lParam, WPARAM wParam, INT cx, INT cy)
{
    BTNDATA *pBtnData = (BTNDATA *)lParam;

    if (pBtnData)
    {
        RECT  rc;
        UINT  dtFlags = DT_WORDBREAK | DT_EDITCONTROL;
        PBUTN pbutn   = pBtnData->pbutn;

        SetRect(&rc, 0, 0, cx, cy);

        if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIACCELHIDDEN)) 
        {
            dtFlags |= DT_HIDEPREFIX;
        } 
        else if (pbutn->fPaintKbdCuesOnly)
        {
            dtFlags |= DT_PREFIXONLY;
        }

        //
        // Horizontal alignment
        //
        switch (pBtnData->wFlags & LOWORD(BS_HORZMASK)) 
        {
            case LOWORD(BS_CENTER):
                dtFlags |= DT_CENTER;
                break;

            case LOWORD(BS_RIGHT):
                dtFlags |= DT_RIGHT;
                break;
        }

        //
        // Vertical alignment
        //
        switch (pBtnData->wFlags & LOWORD(BS_VERTMASK))
        {
            case LOWORD(BS_VCENTER):
                dtFlags |= DT_VCENTER;
                break;

            case LOWORD(BS_BOTTOM):
                dtFlags |= DT_BOTTOM;
                break;
        }

        DrawTextEx(hdc, pBtnData->pszText, pBtnData->cchText, &rc, dtFlags, NULL);
    }

    return TRUE;
}

//---------------------------------------------------------------------------//
//
BOOL Button_SetCapture(PBUTN pbutn, UINT uCodeMouse)
{
    BUTTONSTATE(pbutn) |= uCodeMouse;

    if (!(BUTTONSTATE(pbutn) & BST_CAPTURED)) 
    {
        SetCapture(pbutn->ci.hwnd);
        BUTTONSTATE(pbutn) |= BST_CAPTURED;

        //
        // To prevent redundant CLICK messages, we set the INCLICK bit so
        // the WM_SETFOCUS code will not do a Button_NotifyParent(BN_CLICKED).
        //
        BUTTONSTATE(pbutn) |= BST_INCLICK;

        SetFocus(pbutn->ci.hwnd);

        BUTTONSTATE(pbutn) &= ~BST_INCLICK;
    }

    return BUTTONSTATE(pbutn) & BST_CAPTURED;
}


//---------------------------------------------------------------------------//
//
VOID Button_NotifyParent(PBUTN pbutn, UINT uCode)
{
    HWND hwndParent = GetParent(pbutn->ci.hwnd);
    int  iButtonId = GetWindowID(pbutn->ci.hwnd);

    if ( !hwndParent )
    {
        hwndParent = pbutn->ci.hwnd;
    }

    SendMessage(hwndParent, 
                WM_COMMAND,
                MAKELONG(iButtonId, uCode), 
                (LPARAM)pbutn->ci.hwnd);
}


//---------------------------------------------------------------------------//
//
VOID Button_ReleaseCapture(PBUTN pbutn, BOOL fCheck)
{
    UINT  uCheck;
    BOOL  fNotifyParent = FALSE;
    ULONG ulStyle = GET_STYLE(pbutn);

    if (BUTTONSTATE(pbutn) & BST_PUSHED) 
    {

        SendMessage(pbutn->ci.hwnd, BM_SETSTATE, FALSE, 0);

        if (fCheck) 
        {
            switch (GetButtonType(ulStyle)) 
            {
            case BS_AUTOCHECKBOX:
            case BS_AUTO3STATE:

                uCheck = (UINT)((BUTTONSTATE(pbutn) & BST_CHECKMASK) + 1);

                if (uCheck > (UINT)(GetButtonType(ulStyle) == BS_AUTO3STATE ? BST_INDETERMINATE : BST_CHECKED)) 
                {
                    uCheck = BST_UNCHECKED;
                }

                SendMessage(pbutn->ci.hwnd, BM_SETCHECK, uCheck, 0);

                break;

            case BS_AUTORADIOBUTTON:
                {
                    //
                    // Walk the radio buttons in the same group as us. Check ourself
                    // and uncheck everyone else. 
                    //
                    HWND hwndNext   = pbutn->ci.hwnd;
                    HWND hwndParent = GetParent(pbutn->ci.hwnd);

                    do 
                    {
                        if ((UINT)SendMessage(hwndNext, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON) 
                        {
                            SendMessage(hwndNext, BM_SETCHECK, hwndNext == pbutn->ci.hwnd, 0L);
                        }

                        hwndNext = GetNextDlgGroupItem(hwndParent, hwndNext, FALSE);
                    } 
                    //
                    // Loop until we see ourself again
                    //
                    while (hwndNext != pbutn->ci.hwnd);

                    break;
                }
            }

            fNotifyParent = TRUE;
        }
    }

    if (BUTTONSTATE(pbutn) & BST_CAPTURED) 
    {
        BUTTONSTATE(pbutn) &= ~(BST_CAPTURED | BST_MOUSE);
        ReleaseCapture();
    }

    if (fNotifyParent) 
    {
        //
        // We have to do the notification after setting the buttonstate bits.
        //
        Button_NotifyParent(pbutn, BN_CLICKED);
    }
}


//---------------------------------------------------------------------------//
//
// Button_DrawText()
//
// Draws text of button.
//
VOID Button_DrawText(PBUTN pbutn, HDC hdc, DWORD dwFlags, BOOL fDepress)
{
    ULONG ulStyle = GET_STYLE(pbutn);
    BYTE  bStyle  = GetButtonStyle(ulStyle);

    if ((bStyle != LOBYTE(BS_GROUPBOX)) || TESTFLAG(dwFlags, DBT_TEXT))
    {
        LPTSTR  pszText = NULL;
        INT     cchText = GetWindowTextLength(pbutn->ci.hwnd);

        if (cchText >= 0)
        {
            pszText = UserLocalAlloc(0, (cchText+1)*SIZEOF(WCHAR));

            if (pszText)
            {
                UINT pbfPush = IsPushButton(pbutn);
                RECT rc;
                int  x = 0, y = 0;
                int  cx = 0, cy = 0;

                GetWindowText(pbutn->ci.hwnd, pszText, cchText+1);

                if (!pbfPush && (bStyle == LOBYTE(BS_OWNERDRAW)))
                {
                    //
                    // Skip stuff for ownerdraw buttons, since we aren't going to
                    // draw text/image.
                    //
                    Button_CalcRect(pbutn, hdc, &rc, mpStyleCbr[bStyle], pbfPush);
                }
                else if (!Button_IsThemed(pbutn))
                {
                    HBRUSH  hbr;
                    UINT    dsFlags;
                    BTNDATA btnData;


                    LPARAM lData = 0;
                    WPARAM wData;
                    WORD   wFlags = GetAlignment(pbutn);

                    if (pbfPush) 
                    {
                        Button_CalcRect(pbutn, hdc, &rc, CBR_PUSHBUTTON, pbfPush);
                        IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

                        //
                        // This is because we didn't have WM_CTLCOLOR,
                        // CTLCOLOR_BTN actually set up the button colors.  For
                        // old apps, CTLCOLOR_BTN needs to work like CTLCOLOR_STATIC.
                        //
                        SetBkColor(hdc, GetSysColor(COLOR_3DFACE));
                        SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
                        hbr = GetSysColorBrush(COLOR_BTNTEXT);

                    } 
                    else 
                    {
                        Button_CalcRect(pbutn, hdc, &rc, mpStyleCbr[bStyle], pbfPush);
                        hbr = GetSysColorBrush(COLOR_WINDOWTEXT);
                    }

                    if (pbutn->himl)
                    {
                        int x, y;
                        Button_GetImagePosition(pbutn, &rc, &x, &y);

                        if (fDepress) 
                        {
                            x += GetSystemMetrics(SM_CXBORDER);
                            y += GetSystemMetrics(SM_CYBORDER);
                        }

                        ImageList_Draw(pbutn->himl, 
                                       0,
                                       hdc,
                                       x,
                                       y,
                                       ILD_TRANSPARENT | (CCDPIScale(pbutn->ci)?ILD_DPISCALE:0));
                    }


                    // Initialize data for DrawState
                    if ((ulStyle & BS_BITMAP) != 0) 
                    {
                        // bitmap
                        // lData is an hbitmap
                        // wData is 0

                        BITMAP bmp;

                        GetObject(pbutn->hImage, sizeof(BITMAP), &bmp);
                        cx = bmp.bmWidth;
                        cy = bmp.bmHeight;

                        dsFlags = DST_BITMAP;
                        lData   = (LPARAM)pbutn->hImage;
                        wData   = 0;
                    } 
                    else if ((ulStyle & BS_ICON) != 0) 
                    {
                        // icon
                        // lData is an hicon
                        // wData is 0

                        SIZE sizeIcon;

                        GetIconSize(pbutn->hImage, &sizeIcon);
                        cx = sizeIcon.cx;
                        cy = sizeIcon.cy;

                        dsFlags = DST_ICON;
                        lData   = (LPARAM)pbutn->hImage;
                        wData   = 0;
                    } 
                    else 
                    {
                        if ((ulStyle & BS_MULTILINE) != 0) 
                        {
                            // multiline
                            // package the button data in bdt. DrawState wull call Button_MultiDraw
                            // lData is PBTNDATA
                            // wData is 0

                            Button_MultiExtent(wFlags, hdc, &rc, pszText, cchText, &cx, &cy);

                            btnData.pszText = pszText;
                            btnData.cchText = cchText;
                            btnData.pbutn   = pbutn;
                            btnData.wFlags  = wFlags;

                            dsFlags = DST_COMPLEX;
                            lData   = (LPARAM)&btnData;
                            wData   = 0;
                        } 
                        else 
                        {
                            // simple text button
                            // lData is pszText
                            // wData is cchText

                            // Try to get the text extent with mnemonics stripped.
                            SIZE   size;
                            LPWSTR pszStrip = UserLocalAlloc(0, (cchText+1)*SIZEOF(WCHAR));

                            if (pszStrip != NULL)
                            {
                                INT cchStrip = StripAccelerators(pszText, pszStrip, TRUE);
                                GetTextExtentPoint32(hdc, pszStrip, cchStrip, &size);
                                UserLocalFree(pszStrip);
                            }
                            else
                            {
                                GetTextExtentPoint32(hdc, pszText, cchText, &size);
                            }

                            cx = size.cx;
                            cy = size.cy;

                            //
                            // If the control doesn't need underlines, set DST_HIDEPREFIX and
                            // also do not show the focus indicator
                            //
                            dsFlags = DST_PREFIXTEXT;
                            if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIACCELHIDDEN)) 
                            {
                                dsFlags |= DSS_HIDEPREFIX;
                            } 
                            else if (pbutn->fPaintKbdCuesOnly) 
                            {
                                dsFlags |= DSS_PREFIXONLY;
                            }

                            lData = (LPARAM)pszText;
                            wData = cchText;
                        }


                        //
                        // Add on a pixel or two of vertical space to make centering
                        // happier.  That way underline won't abut focus rect unless
                        // spacing is really tight.
                        //
                        cy++;
                    }

                    //
                    // ALIGNMENT
                    //

                    //
                    // Horizontal
                    //
                    switch (wFlags & HIBYTE(BS_HORZMASK)) 
                    {
                        //
                        // For left & right justified, we leave a margin of CXEDGE on either
                        // side for eye-pleasing space.
                        //
                        case HIBYTE(BS_LEFT):
                            x = rc.left + GetSystemMetrics(SM_CXEDGE);
                            break;

                        case HIBYTE(BS_RIGHT):
                            x = rc.right - cx - GetSystemMetrics(SM_CXEDGE);
                            break;

                        default:
                            x = (rc.left + rc.right - cx) / 2;
                            break;
                    }

                    //
                    // Vertical
                    //
                    switch (wFlags & HIBYTE(BS_VERTMASK)) 
                    {
                        //
                        // For top & bottom justified, we leave a margin of CYBORDER on
                        // either side for more eye-pleasing space.
                        //
                        case HIBYTE(BS_TOP):
                            y = rc.top + GetSystemMetrics(SM_CYBORDER);
                            break;

                        case HIBYTE(BS_BOTTOM):
                            y = rc.bottom - cy - GetSystemMetrics(SM_CYBORDER);
                            break;

                        default:
                            y = (rc.top + rc.bottom - cy) / 2;
                            break;
                    }

                    //
                    // Draw the text
                    //
                    if (lData && TESTFLAG(dwFlags, DBT_TEXT))
                    {
                        //
                        // This isn't called for USER buttons.
                        //
                        UserAssert(bStyle != LOBYTE(BS_USERBUTTON));

                        if (fDepress) 
                        {
                            x += GetSystemMetrics(SM_CXBORDER);
                            y += GetSystemMetrics(SM_CYBORDER);
                        }

                        if (!IsWindowEnabled(pbutn->ci.hwnd)) 
                        {
                            UserAssert(HIBYTE(BS_ICON) == HIBYTE(BS_BITMAP));
                            if (GetSystemMetrics(SM_SLOWMACHINE)  &&
                                ((ulStyle & (BS_ICON | BS_BITMAP)) != 0) &&
                                (GetBkColor(hdc) != GetSysColor(COLOR_GRAYTEXT)))
                            {
                                //
                                // Perf && consistency with menus, statics
                                //
                                SetTextColor(hdc, GetSysColor(COLOR_GRAYTEXT));
                            }
                            else
                            {
                                dsFlags |= DSS_DISABLED;
                            }
                        }

                        //
                        // Use transparent mode for checked push buttons since we're going to
                        // fill background with dither.
                        //
                        if (pbfPush) 
                        {
                            switch (BUTTONSTATE(pbutn) & BST_CHECKMASK) 
                            {
                            case BST_INDETERMINATE:
                                hbr = GetSysColorBrush(COLOR_GRAYTEXT);
                                dsFlags |= DSS_MONO;
                                //
                                // FALL THRU
                                //

                            case BST_CHECKED:
                                //
                                // Drawing on dithered background...
                                //
                                SetBkMode(hdc, TRANSPARENT);
                                break;
                            }
                        }

                        //
                        // Use brush and colors currently selected into hdc when we grabbed
                        // color
                        //
                        DrawState(hdc,
                                  hbr,
                                  (DRAWSTATEPROC)Button_MultiDraw,
                                  lData,
                                  wData,
                                  x,
                                  y,
                                  cx,
                                  cy,
                                  dsFlags);
                    }

                }

                // Draw focus rect.
                //
                // This can get called for OWNERDRAW and USERDRAW buttons. However, only
                // OWNERDRAW buttons let the owner change the drawing of the focus button.
                if (TESTFLAG(dwFlags, DBT_FOCUS))
                {
                    if (bStyle == LOBYTE(BS_OWNERDRAW)) 
                    {
                        //
                        // For ownerdraw buttons, this is only called in response to a
                        // WM_SETFOCUS or WM_KILL FOCUS message.  So, we can check the
                        // new state of the focus by looking at the BUTTONSTATE bits
                        // which are set before this procedure is called.
                        //
                        Button_OwnerDraw(pbutn, hdc, ODA_FOCUS);
                    } 
                    else 
                    {
                        //
                        // Don't draw the focus if underlines are not turned on
                        //
                        if (!TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIFOCUSHIDDEN)) 
                        {
                            //
                            // Let focus rect always hug edge of push buttons.  We already
                            // have the client area setup for push buttons, so we don't have
                            // to do anything.
                            //
                            if (!pbfPush) 
                            {
                                RECT rcClient;

                                GetClientRect(pbutn->ci.hwnd, &rcClient);
                                
                                if (bStyle == LOBYTE(BS_USERBUTTON))
                                {
                                    CopyRect(&rc, &rcClient);
                                } 
                                else if (Button_IsThemed(pbutn))
                                {
                                    //
                                    // if themed
                                    //
                                    int iPartId = 0;
                                    int iStateId = 0;

                                    Button_GetThemeIds(pbutn, &iPartId, &iStateId);
                                    GetThemeBackgroundContentRect(pbutn->hTheme,
                                                                  hdc,
                                                                  iPartId,
                                                                  iStateId,
                                                                  &rcClient,
                                                                  &rc);

                                    GetThemeTextExtent(pbutn->hTheme, 
                                                       hdc, 
                                                       iPartId, 
                                                       iStateId, 
                                                       pszText, 
                                                       -1,
                                                       Button_GetTextFlags(pbutn), 
                                                       &rc, 
                                                       &rc);

                                    //
                                    // Inflate the bounding rect a litte, but contrained to
                                    // within the client area.
                                    //
                                    rc.top = max(rcClient.top, rc.top-1);
                                    rc.bottom = min(rcClient.bottom, rc.bottom+1);

                                    rc.left = max(rcClient.left, rc.left-1);
                                    rc.right = min(rcClient.right, rc.right+1);
                                }
                                else 
                                {
                                    //
                                    // Try to leave a border all around text.  That causes
                                    // focus to hug text.
                                    //
                                    rc.top = max(rcClient.top, y-GetSystemMetrics(SM_CYBORDER));
                                    rc.bottom = min(rcClient.bottom, rc.top + GetSystemMetrics(SM_CYEDGE) + cy);

                                    rc.left = max(rcClient.left, x-GetSystemMetrics(SM_CXBORDER));
                                    rc.right = min(rcClient.right, rc.left + GetSystemMetrics(SM_CXEDGE) + cx);
                                }
                            } 
                            else
                            {
                                InflateRect(&rc, -GetSystemMetrics(SM_CXBORDER), -GetSystemMetrics(SM_CYBORDER));
                            }

                            //
                            // Are back & fore colors set properly?
                            //
                            DrawFocusRect(hdc, &rc);
                        }
                    }
                }

                UserLocalFree(pszText);
            }
        }
    }
}


//---------------------------------------------------------------------------//
//
//  DrawCheck()
//
VOID Button_DrawCheck(PBUTN pbutn, HDC hdc, HBRUSH hBrush)
{
    //
    // if not themed
    //
    if (!Button_IsThemed(pbutn))       // Images don't have a mask so look ugly. Need to use old painting
    {
        RECT  rc;
        UINT  uFlags;
        BOOL  fDoubleBlt = FALSE;
        ULONG ulStyle = GET_STYLE(pbutn);
        SIZE  sizeChk = {0};

        Button_CalcRect(pbutn, hdc, &rc, CBR_CHECKBOX, 0);

        uFlags = 0;

        if ( BUTTONSTATE(pbutn) & BST_CHECKMASK )
        {
            uFlags |= DFCS_CHECKED;
        }

        if ( BUTTONSTATE(pbutn) & BST_PUSHED )
        {
            uFlags |= DFCS_PUSHED;
        }

        if ( !IsWindowEnabled(pbutn->ci.hwnd) )
        {
            uFlags |= DFCS_INACTIVE;
        }

        switch (GetButtonType(ulStyle)) 
        {
        case BS_AUTORADIOBUTTON:
        case BS_RADIOBUTTON:
            fDoubleBlt = TRUE;
            uFlags |= DFCS_BUTTONRADIO;
            break;

        case BS_3STATE:
        case BS_AUTO3STATE:
            if ((BUTTONSTATE(pbutn) & BST_CHECKMASK) == BST_INDETERMINATE) 
            {
                uFlags |= DFCS_BUTTON3STATE;
                break;
            }
            //
            // FALL THRU
            //

        default:
            uFlags |= DFCS_BUTTONCHECK;
            break;
        }

        if ((ulStyle & BS_FLAT) != 0)
        {
            uFlags |= DFCS_FLAT | DFCS_MONO;
        }

        GetCheckBoxSize(hdc, pbutn, TRUE, &sizeChk);

        rc.right = rc.left + sizeChk.cx;
        rc.bottom = rc.top + sizeChk.cy;

        FillRect(hdc, &rc, hBrush);

        DrawFrameControl(hdc, &rc, DFC_BUTTON, uFlags);
    }
    else
    {
        int iStateId = 0;
        int iPartId = 0;

        Button_GetThemeIds(pbutn, &iPartId, &iStateId);

        if ((iPartId != BP_RADIOBUTTON) && (iPartId != BP_CHECKBOX))
        {
            TraceMsg(TF_STANDARD, "Button_DrawCheck: Not a radio or check, iPartId = %d", iPartId);
            return;
        }
        

        Button_DrawThemed(pbutn, hdc, iPartId, iStateId);

    }
}


//---------------------------------------------------------------------------//
//
VOID Button_DrawNewState(PBUTN pbutn, HDC hdc, HBRUSH hbr, UINT sOld)
{
    if (sOld != (UINT)(BUTTONSTATE(pbutn) & BST_PUSHED)) 
    {
        UINT    pbfPush;
        ULONG   ulStyle = GET_STYLE(pbutn);

        pbfPush = IsPushButton(pbutn);

        switch (GetButtonType(ulStyle)) 
        {
        case BS_GROUPBOX:
        case BS_OWNERDRAW:
            break;

        default:
            if (!pbfPush) 
            {
                Button_DrawCheck(pbutn, hdc, hbr);
                break;
            }

        case BS_PUSHBUTTON:
        case BS_DEFPUSHBUTTON:
        case BS_PUSHBOX:
            Button_DrawPush(pbutn, hdc, pbfPush);
            break;
        }
    }
}


//---------------------------------------------------------------------------//
//
// Button_DrawPush()
//
// Draws push-like button with text
//
VOID Button_DrawPush(PBUTN pbutn, HDC hdc, UINT pbfPush)
{

    //
    // if not themed
    //
    if (!Button_IsThemed(pbutn))
    {

        RECT  rc;
        UINT  uFlags = 0;
        UINT  uState = 0;
        ULONG ulStyle = GET_STYLE(pbutn);
        NMCUSTOMDRAW nmcd = {0};

        //
        // Always a push button if calling this function
        //
        uState = DFCS_BUTTONPUSH;

        GetClientRect(pbutn->ci.hwnd, &rc);
        nmcd.hdc = hdc;
        nmcd.rc = rc;
        nmcd.dwItemSpec = GetWindowID(pbutn->ci.hwnd);
        nmcd.uItemState = ButtonStateToCustomDrawState(pbutn);

        if (BUTTONSTATE(pbutn) & BST_PUSHED)
        {
            uState |= DFCS_PUSHED;
        }

        pbutn->ci.dwCustom = CICustomDrawNotify(&pbutn->ci, CDDS_PREERASE, &nmcd);

        if (!(pbutn->ci.dwCustom & CDRF_SKIPDEFAULT))
        {
            if (!pbutn->fPaintKbdCuesOnly) 
            {

                if (BUTTONSTATE(pbutn) & BST_CHECKMASK)
                {
                    uState |= DFCS_CHECKED;
                }

                if (TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN40COMPAT)) 
                {
                    uFlags = BF_SOFT;
                }

                if ((ulStyle & BS_FLAT) != 0)
                {
                    uFlags |= DFCS_FLAT | DFCS_MONO;
                }

                if (pbfPush & PBF_DEFAULT) 
                {
                    int cxBorder = GetSystemMetrics(SM_CXBORDER);
                    int cyBorder = GetSystemMetrics(SM_CYBORDER);

                    int clFrame = 1;

                    int x = rc.left;
                    int y = rc.top;
        
                    int cxWidth = cxBorder * clFrame;
                    int cyWidth = cyBorder * clFrame;
        
                    int cx = rc.right - x - cxWidth;
                    int cy = rc.bottom - y - cyWidth;

                    HBRUSH hbrFill = GetSysColorBrush(COLOR_WINDOWFRAME);
                    HBRUSH hbrSave = SelectObject(hdc, hbrFill);

                    PatBlt(hdc, x, y, cxWidth, cy, PATCOPY);
                    PatBlt(hdc, x + cxWidth, y, cx, cyWidth, PATCOPY);
                    PatBlt(hdc, x, y + cy, cx, cyWidth, PATCOPY);
                    PatBlt(hdc, x + cx, y + cyWidth, cxWidth, cy, PATCOPY);

                    SelectObject(hdc, hbrSave);

                    InflateRect(&rc, -cxBorder, -cyBorder);

                    if (uState & DFCS_PUSHED)
                    {
                        uFlags |= DFCS_FLAT;
                    }
                }

                DrawFrameControl(hdc, &rc, DFC_BUTTON, uState | uFlags);
            }
            if (pbutn->ci.dwCustom & CDRF_NOTIFYPOSTERASE)
                CICustomDrawNotify(&pbutn->ci, CDDS_POSTERASE, &nmcd);

            pbutn->ci.dwCustom = CICustomDrawNotify(&pbutn->ci, CDDS_PREPAINT, &nmcd);

            if (!(pbutn->ci.dwCustom & CDRF_SKIPDEFAULT))
            {
                Button_DrawText(pbutn, hdc, DBT_TEXT | (BUTTONSTATE(pbutn) &
                       BST_FOCUS ? DBT_FOCUS : 0), (uState & DFCS_PUSHED));

                if (pbutn->ci.dwCustom & CDRF_NOTIFYPOSTPAINT)
                    CICustomDrawNotify(&pbutn->ci, CDDS_POSTPAINT, &nmcd);
            }

        }
    }
    else
    {
        int iStateId = 0;
        int iPartId = 0;

        Button_GetThemeIds(pbutn, &iPartId, &iStateId);
        if (iPartId != BP_PUSHBUTTON)
        {
            TraceMsg(TF_STANDARD, "Not a Pushbutton");
            return;
        }
        Button_DrawThemed(pbutn, hdc, iPartId, iStateId);

    }
}


BOOL Button_OnSetImageList(PBUTN pbutn, BUTTON_IMAGELIST* biml)
{
    BOOL fRet = FALSE;

    if (biml)
    {
        if (biml->himl)
        {
            pbutn->rcIcon = biml->margin;
            pbutn->himl = biml->himl;
            pbutn->uAlign = biml->uAlign;

            fRet = TRUE;
        }
    }
    return fRet;
}

void ApplyMarginsToRect(RECT* prcm, RECT* prc)
{
    prc->left -= prcm->left;
    prc->top -= prcm->top;
    prc->right += prcm->right;
    prc->bottom += prcm->bottom;
}

BOOL Button_OnGetIdealSize(PBUTN pbutn, PSIZE psize)
{
    UINT   bsWnd;
    RECT   rc = {0};
    HBRUSH hBrush;
    HDC hdc;

    if (psize == NULL)
        return FALSE;

    GetWindowRect(pbutn->ci.hwnd, &rc);

    hdc = GetDC (pbutn->ci.hwnd);
    if (hdc)
    {
        ULONG  ulStyle = GET_STYLE(pbutn);

        bsWnd = GetButtonType(ulStyle);
        hBrush = Button_InitDC(pbutn, hdc);

        switch (bsWnd) 
        {
            case BS_PUSHBUTTON:
            case BS_DEFPUSHBUTTON:
            {
                LPWSTR pszText = NULL;
                INT    cchText = GetWindowTextLength(pbutn->ci.hwnd);

                if (cchText > 0)
                {
                    pszText = UserLocalAlloc(0, (cchText+1)*SIZEOF(WCHAR));

                    if (pszText) 
                    {
                        RECT rcText = {0};
                        RECT rcIcon = {0};
                        int  cx = 0, cy = 0;
                        int  iStateId = 0;
                        int  iPartId = 0;

                        GetWindowText(pbutn->ci.hwnd, pszText, cchText+1);

                        if (Button_IsThemed(pbutn))
                        {
                            Button_GetThemeIds(pbutn, &iPartId, &iStateId);

                            // First: Get the text rect
                            GetThemeTextExtent(pbutn->hTheme, hdc, iPartId, iStateId, pszText, cchText, 0, &rcText, &rcText);
                            ApplyMarginsToRect(&pbutn->rcText, &rcText);

                            rc = rcText;

                            // We should now have The button with text.
                        }
                        else
                        {
                            int cxWidth = 2 * GetSystemMetrics(SM_CXEDGE);
                            int cyWidth = 3 * GetSystemMetrics(SM_CYEDGE);
                            if (IsPushButton(pbutn) & PBF_DEFAULT)
                            {
                                cxWidth += 2 * GetSystemMetrics(SM_CXBORDER);
                                cyWidth += 2 * GetSystemMetrics(SM_CXBORDER);
                            }

                            DrawText(hdc, pszText, cchText, &rcText, DT_CALCRECT);
                            ApplyMarginsToRect(&pbutn->rcText, &rcText);

                            rcText.bottom += cyWidth + 1;   // +1 because draw text adds a single pixel to the first char, but not the last...
                            rcText.right += cxWidth + 1;
                        }

                        if (pbutn->himl)
                        {
                            rc.top = rc.left = 0;       // We turn this into a width not a position

                            CCGetIconSize(&pbutn->ci, pbutn->himl, &cx, &cy);

                            rcIcon.bottom = cy;
                            rcIcon.right = cx;

                            ApplyMarginsToRect(&pbutn->rcIcon, &rcIcon);

                            switch (pbutn->uAlign)
                            {
                                case BUTTON_IMAGELIST_ALIGN_TOP: 
                                case BUTTON_IMAGELIST_ALIGN_BOTTOM:
                                    rc.bottom = RECTHEIGHT(rcIcon) + RECTHEIGHT(rcText);
                                    rc.right = max(RECTWIDTH(rcIcon), RECTWIDTH(rcText));
                                    break;

                                case BUTTON_IMAGELIST_ALIGN_CENTER:
                                    // This means no text
                                    rc.bottom = RECTHEIGHT(rcIcon);
                                    rc.right = RECTWIDTH(rcIcon);
                                    break;

                                case BUTTON_IMAGELIST_ALIGN_RIGHT:
                                case BUTTON_IMAGELIST_ALIGN_LEFT:
                                    // Fall
                                default:
                                    rc.right = RECTWIDTH(rcIcon) + RECTWIDTH(rcText);
                                    rc.bottom = max(RECTHEIGHT(rcIcon), RECTHEIGHT(rcText));
                                    break;
                            }
                        }
                        else
                        {
                            rc = rcText;
                        }

                        if (Button_IsThemed(pbutn))
                        {
                            GetThemeBackgroundExtent(pbutn->hTheme, hdc, iPartId, iStateId, &rc, &rc);
                        }

                        UserLocalFree(pszText);
                    }
                }

                break;
            }
        }

        //
        // Release the font which may have been loaded by ButtonInitDC.
        //
        if (pbutn->hFont) 
        {
            SelectObject(hdc, GetStockObject(SYSTEM_FONT));
        }
        ReleaseDC(pbutn->ci.hwnd, hdc);
    }

    psize->cx = RECTWIDTH(rc);
    psize->cy = RECTHEIGHT(rc);

    return TRUE;
}


//---------------------------------------------------------------------------//
//
VOID Button_Paint(PBUTN pbutn, HDC hdc)
{
    RECT   rc;
    RECT   rcText;
    HBRUSH hBrush;
    HBRUSH hBrushSave = NULL;
    BOOL   fDrawBackground = TRUE;
    ULONG  ulStyle = GET_STYLE(pbutn);
    CCDBUFFER db = {0};
    UINT bsWnd = GetButtonType(ulStyle);
    UINT   pbfPush = IsPushButton(pbutn);
    BOOL fTransparent = FALSE;
    int    iPartId = 0;
    int    iStateId = 0;

    GetClientRect(pbutn->ci.hwnd, &rc);

    if (Button_IsThemed(pbutn) && 
        (bsWnd != LOBYTE(BS_GROUPBOX)) && 
        (bsWnd != LOBYTE(BS_OWNERDRAW)) && 
        !pbutn->fPaintKbdCuesOnly)
    {
        hdc = CCBeginDoubleBuffer(hdc, &rc, &db); 
        
        Button_GetThemeIds(pbutn, &iPartId, &iStateId);
        fTransparent = CCShouldAskForBits(&pbutn->ci, pbutn->hTheme, iPartId, iStateId);
        if (fTransparent)
        {
            fDrawBackground = (TRUE != CCSendPrint(&pbutn->ci, hdc));
        }
    }

    hBrush = Button_InitDC(pbutn, hdc);


    if ((!pbfPush || fTransparent) && !pbutn->fPaintKbdCuesOnly &&
        fDrawBackground)
    {
        if ((bsWnd != LOBYTE(BS_OWNERDRAW)) &&
            (bsWnd != LOBYTE(BS_GROUPBOX)))
        {
            //
            // Fill the client area with the background brush
            // before we begin painting.
            //
            FillRect(hdc, &rc, hBrush);
        }

        hBrushSave = SelectObject(hdc, hBrush);
    }

    switch (bsWnd) 
    {
    case BS_CHECKBOX:
    case BS_RADIOBUTTON:
    case BS_AUTORADIOBUTTON:
    case BS_3STATE:
    case BS_AUTOCHECKBOX:
    case BS_AUTO3STATE:
        if (!pbfPush) 
        {
            if (!Button_IsThemed(pbutn))
            {
                Button_DrawText(pbutn, hdc,
                    DBT_TEXT | (BUTTONSTATE(pbutn) & BST_FOCUS ? DBT_FOCUS : 0), FALSE);
            }

            if (!pbutn->fPaintKbdCuesOnly || Button_IsThemed(pbutn)) 
            {
                Button_DrawCheck(pbutn, hdc, hBrush);
            }
            break;
        }
        //
        // Fall through for PUSHLIKE buttons
        //

    case BS_PUSHBUTTON:
    case BS_DEFPUSHBUTTON:
        Button_DrawPush(pbutn, hdc, pbfPush);
        break;

    case BS_PUSHBOX:
        Button_DrawText(pbutn, hdc,
            DBT_TEXT | (BUTTONSTATE(pbutn) & BST_FOCUS ? DBT_FOCUS : 0), FALSE);

        Button_DrawNewState(pbutn, hdc, hBrush, 0);
        break;

    case BS_USERBUTTON:
        // Don't support USERBUTTON in v6. This has been superceded by OWNERDRAW in win32.
        break;

    case BS_OWNERDRAW:
        Button_OwnerDraw(pbutn, hdc, ODA_DRAWENTIRE);
        break;

    case BS_GROUPBOX:
        Button_CalcRect(pbutn, hdc, &rcText, CBR_GROUPTEXT, 0);

        //----- get theme part, state for groupbox ----
        if (Button_IsThemed(pbutn))
        {
            Button_GetThemeIds(pbutn, &iPartId, &iStateId);
        }

        if (!pbutn->fPaintKbdCuesOnly) 
        {
            UINT uFlags;
            BOOL fFillMyself = TRUE;

            Button_CalcRect(pbutn, hdc, &rc, CBR_GROUPFRAME, 0);

            uFlags = ((ulStyle & BS_FLAT) != 0) ? BF_FLAT | BF_MONO : 0;
            if (!Button_IsThemed(pbutn))
            {
                DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT | uFlags);
            }
            else
            {
                DrawThemeBackground(pbutn->hTheme, hdc, iPartId, iStateId, &rc, 0);
                fFillMyself = (FALSE == CCSendPrintRect(&pbutn->ci, hdc, &rcText));
            }

            if (fFillMyself)
            {
                FillRect(hdc, &rcText, hBrush);
            }
        }

        // FillRect(hdc, &rc, hBrush);
        if (!Button_IsThemed(pbutn))
        {
            Button_DrawText(pbutn, hdc, DBT_TEXT, FALSE);
        }
        else
        {
            LPWSTR pszText = NULL;
            INT    cchText = GetWindowTextLength(pbutn->ci.hwnd);

            if (cchText > 0)
            {
                pszText = UserLocalAlloc(0, (cchText+1)*SIZEOF(WCHAR));
                if (pszText)
                {
                    DWORD dwTextFlags = Button_GetTextFlags(pbutn);

                    GetWindowTextW(pbutn->ci.hwnd, pszText, cchText+1);

                    //
                    // Button_CalcRect padded by a CXEDGE so the groupbox frame wouldn't
                    // be flush with the Group text 
                    //
                    rcText.left += GetSystemMetrics(SM_CXEDGE);

                    if (FAILED(DrawThemeText(pbutn->hTheme,
                                       hdc,
                                       iPartId,
                                       iStateId,
                                       pszText,
                                       cchText,
                                       dwTextFlags,
                                       0,
                                       &rcText)))
                    {
                        TraceMsg(TF_STANDARD, "Button_Paint failed to render groupbox text");
                    }

                    UserLocalFree(pszText);
                }
            }
        }

        break;
    }

    if (!pbfPush && hBrushSave)
    {
        SelectObject(hdc, hBrushSave);
    }

    //
    // Release the font which may have been loaded by ButtonInitDC.
    //
    if (pbutn->hFont) 
    {
        SelectObject(hdc, GetStockObject(SYSTEM_FONT));
    }

    CCEndDoubleBuffer(&db);
}


//---------------------------------------------------------------------------//
//
VOID Button_Repaint(PBUTN pbutn)
{
    HDC hdc = Button_GetDC(pbutn, NULL);

    if (hdc != NULL) 
    {
        Button_Paint(pbutn, hdc);
        Button_ReleaseDC(pbutn, hdc, NULL);
    }
}

VOID Button_SetHot(PBUTN pbutn, BOOL fHot, DWORD dwReason)
{
    NMBCHOTITEM nmhot = {0};

    // Send a notification about the hot item change
    if (fHot)
    {
        nmhot.dwFlags = HICF_ENTERING;
        pbutn->buttonState |= BST_HOT;
    }
    else
    {
        nmhot.dwFlags = HICF_LEAVING;
        pbutn->buttonState &= ~BST_HOT;
    }

    nmhot.dwFlags |= dwReason;

    CCSendNotify(&pbutn->ci, BCN_HOTITEMCHANGE, &nmhot.hdr);
}

void Button_EraseOwnerDraw(PBUTN pbutn, HDC hdc)
{
    if (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_OWNERDRAW))
    {
        RECT rc;
        HBRUSH hbr;
        //
        // Handle erase background for owner draw buttons.
        //
        GetClientRect(pbutn->ci.hwnd, &rc);
        hbr = (HBRUSH)SendMessage(GetParent(pbutn->ci.hwnd), WM_CTLCOLORBTN, (WPARAM)hdc, (LPARAM)pbutn->ci.hwnd);
        FillRect(hdc, &rc, hbr);
    }
}

//---------------------------------------------------------------------------//
//
// Button_WndProc
//
// WndProc for buttons, check boxes, etc.
//
LRESULT APIENTRY Button_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UINT        wOldState;
    RECT        rc;
    HDC         hdc;
    HBRUSH      hbr;
    PAINTSTRUCT ps;
    PBUTN       pbutn;
    LRESULT     lResult = FALSE;

    //
    // Get the instance data for this button control
    //
    pbutn = Button_GetPtr(hwnd);
    if (!pbutn && uMsg != WM_NCCREATE)
    {
        goto CallDWP;
    }


    switch (uMsg) 
    {
    case WM_NCHITTEST:
        if (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_GROUPBOX)) 
        {
            lResult = (LONG)HTTRANSPARENT;
        } 
        else 
        {
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

            if ( lResult == HTCLIENT && Button_IsThemed(pbutn))
            {
                HRESULT hr;
                int     iPartId = 0;
                int     iStateId = 0;
                POINT   pt;
                WORD    wHitTestCode;

                hr = Button_GetThemeIds(pbutn, &iPartId, &iStateId);
                if ( SUCCEEDED(hr) )
                    GetWindowRect(pbutn->ci.hwnd, &rc);
                    pt.x = GET_X_LPARAM(lParam);
                    pt.y = GET_Y_LPARAM(lParam);
                    hr = HitTestThemeBackground(pbutn->hTheme, 
                                                NULL,
                                                iPartId, 
                                                iStateId, 
                                                0,
                                                &rc, 
                                                NULL,
                                                pt, 
                                                &wHitTestCode);
                    if ( SUCCEEDED(hr) && wHitTestCode == HTTRANSPARENT)
                    {
                        lResult = (LRESULT)HTTRANSPARENT;
                    }
            }
        }

        break;

    case WM_ERASEBKGND:
        Button_EraseOwnerDraw(pbutn, (HDC)wParam);
        //
        // Do nothing for other buttons, but don't let DefWndProc() do it
        // either.  It will be erased in Button_Paint().
        //
        lResult = (LONG)TRUE;
        break;

    case WM_PRINTCLIENT:
        Button_EraseOwnerDraw(pbutn, (HDC)wParam);
        Button_Paint(pbutn, (HDC)wParam);
        break;

    case WM_CREATE:
        pbutn->hTheme = Button_GetTheme(pbutn);
        CIInitialize(&pbutn->ci, hwnd, (LPCREATESTRUCT)lParam);

        SendMessage(hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);
        break;

    case WM_PAINT:
        {
            //
            // If wParam != NULL, then this is a subclassed paint.
            //
            if (wParam)
            {
                hdc = (HDC)wParam;
            }
            else
            {
                hdc = BeginPaint(hwnd, &ps);
            }

            if (IsWindowVisible(pbutn->ci.hwnd))
            {
                Button_Paint(pbutn, hdc);
            }

            if (!wParam)
            {
                EndPaint(hwnd, &ps);
            }
        }

        break;

    case WM_SETFOCUS:

        BUTTONSTATE(pbutn) |= BST_FOCUS;
        if (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_OWNERDRAW))
        {
            HDC hdc = Button_GetDC(pbutn, NULL);
            if (hdc)
            {
                Button_DrawText(pbutn, hdc, DBT_FOCUS, FALSE);
                Button_ReleaseDC(pbutn, hdc, NULL);
            }
        }
        else
        {
            InvalidateRect(pbutn->ci.hwnd, NULL, FALSE);
        }

        if ((GET_STYLE(pbutn)& BS_NOTIFY) != 0)
        {
            Button_NotifyParent(pbutn, BN_SETFOCUS);
        }

        if (!(BUTTONSTATE(pbutn) & BST_INCLICK)) 
        {
            switch (GetButtonType(GET_STYLE(pbutn))) 
            {
            case LOBYTE(BS_RADIOBUTTON):
            case LOBYTE(BS_AUTORADIOBUTTON):

                if (!(BUTTONSTATE(pbutn) & BST_DONTCLICK)) 
                {
                    if (!(BUTTONSTATE(pbutn) & BST_CHECKMASK)) 
                    {
                        Button_NotifyParent(pbutn, BN_CLICKED);
                    }
                }
                break;
            }
        }
        break;

    case WM_GETDLGCODE:

        lResult = DLGC_BUTTON;

        switch (GetButtonType(GET_STYLE(pbutn))) 
        {
        case LOBYTE(BS_DEFPUSHBUTTON):
            lResult |= DLGC_DEFPUSHBUTTON;
            break;

        case LOBYTE(BS_PUSHBUTTON):
        case LOBYTE(BS_PUSHBOX):
            lResult |= DLGC_UNDEFPUSHBUTTON;
            break;

        case LOBYTE(BS_AUTORADIOBUTTON):
        case LOBYTE(BS_RADIOBUTTON):
            lResult |= DLGC_RADIOBUTTON;
            break;

        case LOBYTE(BS_GROUPBOX):
            //
            // remove DLGC_BUTTON
            //
            lResult = DLGC_STATIC;
            break;

        case LOBYTE(BS_CHECKBOX):
        case LOBYTE(BS_AUTOCHECKBOX):

            //
            // If this is a char that is a '=/+', or '-', we want it
            //
            if (lParam && ((LPMSG)lParam)->message == WM_CHAR) 
            {
                switch (wParam) 
                {
                case TEXT('='):
                case TEXT('+'):
                case TEXT('-'):
                    lResult |= DLGC_WANTCHARS;
                    break;

                }
            } 

            break;
        }

        break;

    case WM_CAPTURECHANGED:

        if (BUTTONSTATE(pbutn) & BST_CAPTURED) 
        {
            //
            // Unwittingly, we've been kicked out of capture,
            // so undepress etc.
            //
            if (BUTTONSTATE(pbutn) & BST_MOUSE)
            {
                SendMessage(pbutn->ci.hwnd, BM_SETSTATE, FALSE, 0);
            }
            BUTTONSTATE(pbutn) &= ~(BST_CAPTURED | BST_MOUSE);

        }
        break;

    case WM_KILLFOCUS:

        //
        // If we are losing the focus and we are in "capture mode", click
        // the button.  This allows tab and space keys to overlap for
        // fast toggle of a series of buttons.
        //
        if (BUTTONSTATE(pbutn) & BST_MOUSE) 
        {
            //
            // If for some reason we are killing the focus, and we have the
            // mouse captured, don't notify the parent we got clicked.  This
            // breaks Omnis Quartz otherwise.
            //
            SendMessage(pbutn->ci.hwnd, BM_SETSTATE, FALSE, 0);
        }

        Button_ReleaseCapture(pbutn, TRUE);

        BUTTONSTATE(pbutn) &= ~BST_FOCUS;

        if ((GET_STYLE(pbutn) & BS_NOTIFY) != 0)
        {
            Button_NotifyParent(pbutn, BN_KILLFOCUS);
        }

        //
        // Since the bold border around the defpushbutton is done by
        // someone else, we need to invalidate the rect so that the
        // focus rect is repainted properly.
        //
        InvalidateRect(hwnd, NULL, FALSE);
        break;

    case WM_LBUTTONDBLCLK:

        //
        // Double click messages are recognized for BS_RADIOBUTTON,
        // BS_USERBUTTON, and BS_OWNERDRAW styles.  For all other buttons,
        // double click is handled like a normal button down.
        //
        switch (GetButtonType(GET_STYLE(pbutn))) 
        {
        default:
            if ((GET_STYLE(pbutn) & BS_NOTIFY) == 0)
                goto btnclick;

        case LOBYTE(BS_USERBUTTON):
        case LOBYTE(BS_RADIOBUTTON):
        case LOBYTE(BS_OWNERDRAW):
            Button_NotifyParent(pbutn, BN_DOUBLECLICKED);
            break;
        }

        break;

    case WM_LBUTTONUP:
        if (BUTTONSTATE(pbutn) & BST_MOUSE) 
        {
            Button_ReleaseCapture(pbutn, TRUE);
        }
        break;

    case WM_MOUSELEAVE:
        {
            //
            // We should only be requesting mouseleave messages
            // if we are themed but check anyway
            //
            if (pbutn->buttonState & BST_HOT)
            {
                Button_SetHot(pbutn, FALSE, HICF_MOUSE);
                InvalidateRect(pbutn->ci.hwnd, NULL, TRUE);
            }
        }
        break;

    case WM_MOUSEMOVE:
        {
            //
            // If the hot bit is not already set
            //
            // 300925: Can't hottrack ownerdraw buttons for app compat reasons
            //
            if (!TESTFLAG(pbutn->buttonState, BST_HOT) &&
                GetButtonType(GET_STYLE(pbutn)) != LOBYTE(BS_OWNERDRAW))
            {
                TRACKMOUSEEVENT tme;

                //
                // Set the hot bit and request that
                // we be notified when the mouse leaves
                //
                Button_SetHot(pbutn, TRUE, HICF_MOUSE);

                tme.cbSize      = sizeof(tme);
                tme.dwFlags     = TME_LEAVE;
                tme.hwndTrack   = pbutn->ci.hwnd;
                tme.dwHoverTime = 0;

                TrackMouseEvent(&tme);
                InvalidateRect(pbutn->ci.hwnd, NULL, TRUE);
            }

            if (!(BUTTONSTATE(pbutn) & BST_MOUSE)) 
            {
                break;
            }
        }

        //
        // FALL THRU 
        //

    case WM_LBUTTONDOWN:
btnclick:
        if (Button_SetCapture(pbutn, BST_MOUSE)) 
        {
            POINT pt;
            GetClientRect(pbutn->ci.hwnd, &rc);
            POINTSTOPOINT(pt, lParam);
            SendMessage(pbutn->ci.hwnd, BM_SETSTATE, PtInRect(&rc, pt), 0);
        }

        break;

    case WM_CHAR:
        if (BUTTONSTATE(pbutn) & BST_MOUSE)
        {
            goto CallDWP;
        }

        if (GetButtonType(GET_STYLE(pbutn)) != LOBYTE(BS_CHECKBOX) &&
            GetButtonType(GET_STYLE(pbutn)) != LOBYTE(BS_AUTOCHECKBOX))
        {
            goto CallDWP;
        }

        switch (wParam) 
        {
        case TEXT('+'):
        case TEXT('='):
            //
            // we must Set the check mark on.
            //
            wParam = 1;    

            goto SetCheck;

        case TEXT('-'):
            //
            // Set the check mark off.
            //
            wParam = 0;
SetCheck:
            //
            // Must notify only if the check status changes
            //
            if ((WORD)(BUTTONSTATE(pbutn) & BST_CHECKMASK) != (WORD)wParam)
            {
                //
                // We must check/uncheck only if it is AUTO
                //
                if (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_AUTOCHECKBOX))
                {
                    if (Button_SetCapture(pbutn, 0))
                    {
                        SendMessage(pbutn->ci.hwnd, BM_SETCHECK, wParam, 0);
                        Button_ReleaseCapture(pbutn, TRUE);
                    }
                }

                Button_NotifyParent(pbutn, BN_CLICKED);
            }

            break;

        default:
            goto CallDWP;
        }

        break;

    case BCM_GETIDEALSIZE:
        return Button_OnGetIdealSize(pbutn, (PSIZE)lParam);

    case BCM_SETIMAGELIST:
        return Button_OnSetImageList(pbutn, (BUTTON_IMAGELIST*)lParam);

    case BCM_GETIMAGELIST:
        {
            BUTTON_IMAGELIST* biml = (BUTTON_IMAGELIST*)lParam;
            if (biml)
            {
                biml->himl = pbutn->himl;
                biml->uAlign = pbutn->uAlign;
                biml->margin = pbutn->rcIcon;
                return TRUE;
            }
        }
        break;

    case BCM_SETTEXTMARGIN:
        {
            RECT* prc = (RECT*)lParam;
            if (prc)
            {
                pbutn->rcText = *prc;
                return TRUE;
            }
        }
        break;

    case BCM_GETTEXTMARGIN:
        {
            RECT* prc = (RECT*)lParam;
            if (prc)
            {
                *prc = pbutn->rcText;
                return TRUE;
            }
        }
        break;

    case BM_CLICK:

        //
        // Don't recurse into this code!
        //
        if (BUTTONSTATE(pbutn) & BST_INBMCLICK)
        {
            break;
        }

        BUTTONSTATE(pbutn) |= BST_INBMCLICK;
        SendMessage(pbutn->ci.hwnd, WM_LBUTTONDOWN, 0, 0);
        SendMessage(pbutn->ci.hwnd, WM_LBUTTONUP, 0, 0);
        BUTTONSTATE(pbutn) &= ~BST_INBMCLICK;

        //
        // FALL THRU
        //

    case WM_KEYDOWN:

        if (BUTTONSTATE(pbutn) & BST_MOUSE)
        {
            break;
        }

        if (wParam == VK_SPACE) 
        {
            if (Button_SetCapture(pbutn, 0)) 
            {
                SendMessage(pbutn->ci.hwnd, BM_SETSTATE, TRUE, 0);
            }
        } 
        else 
        {
            Button_ReleaseCapture(pbutn, FALSE);
        }

        break;

    case WM_KEYUP:
    case WM_SYSKEYUP:

        if (BUTTONSTATE(pbutn) & BST_MOUSE) 
        {
            goto CallDWP;
        }

        //
        // Don't cancel the capture mode on the up of the tab in case the
        // guy is overlapping tab and space keys.
        //
        if (wParam == VK_TAB) 
        {
            goto CallDWP;
        }

        //
        // WARNING: pbutn->ci.hwnd is history after this call!
        //
        Button_ReleaseCapture(pbutn, (wParam == VK_SPACE));

        if (uMsg == WM_SYSKEYUP) 
        {
            goto CallDWP;
        }

        break;

    case BM_GETSTATE:

        lResult = (LONG)BUTTONSTATE(pbutn);
        break;

    case BM_SETSTATE:

        wOldState = (UINT)(BUTTONSTATE(pbutn) & BST_PUSHED);

        if (wParam) 
        {
            BUTTONSTATE(pbutn) |= BST_PUSHED;
        } 
        else 
        {
            BUTTONSTATE(pbutn) &= ~BST_PUSHED;
        }

        if (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_USERBUTTON)) 
        {
            Button_NotifyParent(pbutn, (UINT)(wParam ? BN_PUSHED : BN_UNPUSHED));
        } 

        if (wOldState != (BOOL)(BUTTONSTATE(pbutn) & BST_PUSHED))
        {
            // Only invalidate if the state changed.
            InvalidateRect(pbutn->ci.hwnd, NULL, FALSE);
            NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
        }

        break;

    case BM_GETCHECK:

        lResult = (LONG)(BUTTONSTATE(pbutn) & BST_CHECKMASK);
        break;

    case BM_SETCHECK:

        switch (GetButtonType(GET_STYLE(pbutn))) 
        {
        case LOBYTE(BS_RADIOBUTTON):
        case LOBYTE(BS_AUTORADIOBUTTON):

            if (wParam) 
            {
                SetWindowState(pbutn->ci.hwnd, WS_TABSTOP);
            } 
            else 
            {
                ClearWindowState(pbutn->ci.hwnd, WS_TABSTOP);
            }

            //
            // FALL THRU
            //

        case LOBYTE(BS_CHECKBOX):
        case LOBYTE(BS_AUTOCHECKBOX):

            if (wParam) 
            {
                wParam = 1;
            }
            goto CheckIt;

        case LOBYTE(BS_3STATE):
        case LOBYTE(BS_AUTO3STATE):

            if (wParam > BST_INDETERMINATE) 
            {
                wParam = BST_INDETERMINATE;
            }

CheckIt:
            if ((UINT)(BUTTONSTATE(pbutn) & BST_CHECKMASK) != (UINT)wParam) 
            {
                BUTTONSTATE(pbutn) &= ~BST_CHECKMASK;
                BUTTONSTATE(pbutn) |= (UINT)wParam;

                if (!IsWindowVisible(pbutn->ci.hwnd))
                {
                    break;
                }

                InvalidateRect(pbutn->ci.hwnd, NULL, FALSE);

                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
            }

            break;
        }

        break;

    case BM_SETSTYLE:

        AlterWindowStyle(hwnd, BS_TYPEMASK, (DWORD)wParam);

        if (lParam) 
        {
            InvalidateRect(hwnd, NULL, TRUE);
        }

        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
        break;

    case WM_SETTEXT:

        //
        // In case the new group name is longer than the old name,
        // this paints over the old name before repainting the group
        // box with the new name.
        //
        if (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_GROUPBOX)) 
        {
            hdc = Button_GetDC(pbutn, &hbr);
            if (hdc != NULL) 
            {
                Button_CalcRect(pbutn, hdc, &rc, CBR_GROUPTEXT, 0);
                InvalidateRect(hwnd, &rc, TRUE);
                FillRect(hdc, &rc, hbr);
                Button_ReleaseDC(pbutn, hdc, &hbr);
            }
        }

        lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

        NotifyWinEvent(EVENT_OBJECT_NAMECHANGE, hwnd, OBJID_WINDOW, INDEXID_CONTAINER);
        goto DoEnable;

    case WM_ENABLE:
        lResult = 0L;

DoEnable:
        Button_Repaint(pbutn);
        break;

    case WM_SETFONT:

        //
        // wParam - handle to the font
        // lParam - if true, redraw else don't
        //
        Button_SetFont(pbutn, (HFONT)wParam, (BOOL)(lParam != 0));
        break;

    case WM_GETFONT:
        lResult = (LRESULT)pbutn->hFont;
        break;

    case BM_GETIMAGE:
    case BM_SETIMAGE:

        if (!IsValidImage(wParam, (GET_STYLE(pbutn) & BS_IMAGEMASK) != 0, IMAGE_BMMAX)) 
        {
            TraceMsg(TF_STANDARD, "UxButton: Invalid button image type");
            SetLastError(ERROR_INVALID_PARAMETER);
        } 
        else 
        {
            HANDLE hOld = pbutn->hImage;

            if (uMsg == BM_SETIMAGE) 
            {
                pbutn->hImage = (HANDLE)lParam;
                if (IsWindowVisible(pbutn->ci.hwnd)) 
                {
                    InvalidateRect(hwnd, NULL, TRUE);
                }
            }

            lResult = (LRESULT)hOld;
        }

        break;

    case WM_NCDESTROY:

        if (pbutn->hTheme)
        {
            CloseThemeData(pbutn->hTheme);
        }
        UserLocalFree(pbutn);

        TraceMsg(TF_STANDARD, "BUTTON: Clearing button instance pointer.");
        Button_SetPtr(hwnd, NULL);

        break;

    case WM_NCCREATE:

        pbutn = (PBUTN)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(BUTN));
        if (pbutn)
        {
            //
            // Success... store the instance pointer.
            //
            TraceMsg(TF_STANDARD, "BUTTON: Setting button instance pointer.");
            Button_SetPtr(hwnd, pbutn);
            pbutn->ci.hwnd = hwnd;
            pbutn->pww = (PWW)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);

            SetRect(&pbutn->rcText, GetSystemMetrics(SM_CXEDGE) / 2, GetSystemMetrics(SM_CYEDGE) / 2,
                GetSystemMetrics(SM_CXEDGE) / 2, GetSystemMetrics(SM_CYEDGE) / 2);

            //
            // Borland's OBEX has a button with style 0x98; We didn't strip
            // these bits in win3.1 because we checked for 0x08.
            // Stripping these bits cause a GP Fault in OBEX.
            // For win3.1 guys, I use the old code to strip the style bits.
            //
            if (TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN31COMPAT)) 
            {
                if ((!TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN40COMPAT) &&
                    (((LOBYTE(GET_STYLE(pbutn))) & (LOBYTE(~BS_LEFTTEXT))) == LOBYTE(BS_USERBUTTON))) ||
                    (TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN40COMPAT) &&
                    (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_USERBUTTON))))
                {
                    //
                    // BS_USERBUTTON is no longer allowed for 3.1 and beyond.
                    // Just turn to normal push button.
                    //
                    AlterWindowStyle(hwnd, BS_TYPEMASK, 0);
                    TraceMsg(TF_STANDARD, "UxButton: BS_USERBUTTON no longer supported");
                }
            }

            if ((GET_EXSTYLE(pbutn) & WS_EX_RIGHT) != 0) 
            {
                AlterWindowStyle(hwnd, BS_RIGHT | BS_RIGHTBUTTON, BS_RIGHT | BS_RIGHTBUTTON);
            }

            goto CallDWP;
        }
        else
        {
            //
            // Failed... return FALSE.
            //
            // From a WM_NCCREATE msg, this will cause the
            // CreateWindow call to fail.
            //
            TraceMsg(TF_STANDARD, "BUTTON: Unable to allocate button instance structure.");
            lResult = FALSE;
        }

        break;

    case WM_UPDATEUISTATE:

        DefWindowProc(hwnd, uMsg, wParam, lParam);
        if (ISBSTEXTOROD(GET_STYLE(pbutn))) 
        {
            pbutn->fPaintKbdCuesOnly = !IsUsingCleartype();
            Button_Repaint(pbutn);
            pbutn->fPaintKbdCuesOnly = FALSE;
        }

        break;

    case WM_GETOBJECT:

        if(lParam == OBJID_QUERYCLASSNAMEIDX)
        {
            lResult = MSAA_CLASSNAMEIDX_BUTTON;
        }
        else
        {
            lResult = FALSE;
        }

        break;

    case WM_THEMECHANGED:
        if ( pbutn->hTheme )
        {
            CloseThemeData(pbutn->hTheme);
        }

        //---- reset cached sizes that may change with a theme change ----
        sizeCheckBox.cx = 0;
        sizeCheckBox.cy = 0;
        sizeRadioBox.cx = 0;
        sizeRadioBox.cy = 0;

        pbutn->hTheme = Button_GetTheme(pbutn);

        InvalidateRect(pbutn->ci.hwnd, NULL, TRUE);

        CCSendNotify(&pbutn->ci, NM_THEMECHANGED, NULL);

        lResult = TRUE;

        break;

    default:

        if (CCWndProc(&pbutn->ci, uMsg, wParam, lParam, &lResult))
            return lResult;

CallDWP:
        lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

    }

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\combo.h ===
#if !defined(__Combo_h__INCLUDED)
#define __Combo_h__INCLUDED

//---------------------------------------------------------------------------//
//
//  Controls Controls
//
//---------------------------------------------------------------------------//

//
//  Combobox animation time in MS
//
#define CMS_QANIMATION  165

//
//  ID numbers (hMenu) for the child controls in the combo box
//
#define CBLISTBOXID     1000
#define CBEDITID        1001
#define CBBUTTONID      1002


//
//  For CBOX.c. BoxType field, we define the following combo box styles. These
//  numbers are the same as the CBS_ style codes as defined in winuser.h.
//
#define SDROPPABLE      CBS_DROPDOWN
#define SEDITABLE       CBS_SIMPLE


#define SSIMPLE         SEDITABLE
#define SDROPDOWNLIST   SDROPPABLE
#define SDROPDOWN       (SDROPPABLE | SEDITABLE)


//
//  Combobox & Listbox OwnerDraw types
//
#define OWNERDRAWFIXED  1
#define OWNERDRAWVAR    2

#define UPPERCASE       1
#define LOWERCASE       2


//
//  Special styles for static controls, edit controls & listboxes so that we
//  can do combo box specific stuff in their wnd procs.
//
#define LBS_COMBOBOX    0x8000L


//
//  The default minimun number of items that should fit in a dropdown list before
//  the list should start showing in scrollbars.
//
#define DEFAULT_MINVISIBLE  30

//
//  Combobox macros
//
#define IsComboVisible(pcbox)   \
            (!pcbox->fNoRedraw && IsWindowVisible(pcbox->hwnd))

//
//  Combine two DBCS WM_CHAR messages to
//  a single WORD value.
//
#define CrackCombinedDbcsLB(c)  \
            ((BYTE)(c))
#define CrackCombinedDbcsTB(c)  \
            ((c) >> 8)

//
// Instance data pointer access functions
//
#define ComboBox_GetPtr(hwnd)    \
            (PCBOX)GetWindowPtr(hwnd, 0)

#define ComboBox_SetPtr(hwnd, p) \
            (PCBOX)SetWindowPtr(hwnd, 0, p)


//
// Combobox WndProc Prototype
//
extern LRESULT 
ComboBox_WndProc(
    HWND   hwnd, 
    UINT   uMsg, 
    WPARAM wParam,
    LPARAM lParam);


typedef struct tagCBox 
{
    HWND   hwnd;                // Window for the combo box
    HWND   hwndParent;          // Parent of the combo box
    HTHEME hTheme;              // Handle to the theme manager
    RECT   editrc;              // Rectangle for the edit control/static text area
    RECT   buttonrc;            // Rectangle where the dropdown button is

    int    cxCombo;             // Width of sunken area
    int    cyCombo;             // Height of sunken area
    int    cxDrop;              // 0x24 Width of dropdown
    int    cyDrop;              // Height of dropdown or shebang if simple

    HWND   hwndEdit;            // Edit control window handle
    HWND   hwndList;            // List box control window handle

    UINT   CBoxStyle:2;         // Combo box style
    UINT   fFocus:1;            // Combo box has focus?
    UINT   fNoRedraw:1;         // Stop drawing?
    UINT   fMouseDown:1;        // Was the popdown button just clicked and mouse still down?
    UINT   fButtonPressed:1;    // Is the dropdown button in an inverted state?
    UINT   fLBoxVisible:1;      // Is list box visible? (dropped down?)
    UINT   OwnerDraw:2;         // Owner draw combo box if nonzero. value 
                                // specifies either fixed or varheight
    UINT   fKeyboardSelInListBox:1;     // Is the user keyboarding through the
                                        // listbox. So that we don't hide the
                                        // listbox on selchanges caused by the
                                        // user keyboard through it but we do
                                        // hide it if the mouse causes the selchange.
    UINT   fExtendedUI:1;       // Are we doing TandyT's UI changes on this combo box?
    UINT   fCase:2;

    UINT   f3DCombo:1;          // 3D or flat border?
    UINT   fNoEdit:1;           // True if editing is not allowed in the edit window.
    UINT   fButtonHotTracked:1; // Is the dropdown hot-tracked?
    UINT   fRightAlign:1;       // used primarily for MidEast right align
    UINT   fRtoLReading:1;      // used only for MidEast, text rtol reading order
    HANDLE hFont;               // Font for the combo box
    LONG   styleSave;           // Temp to save the style bits when creating
                                // window.  Needed because we strip off some
                                // bits and pass them on to the listbox or edit box.
    PWW    pww;                 // RO pointer into the pwnd to ExStyle, Style, State, State2
    int    iMinVisible;         // The minimun number of visible items before scrolls
} CBOX, *PCBOX;



//  Combobox function prototypes. 

// Defined in combo.c
BOOL    ComboBox_HideListBoxWindow(PCBOX, BOOL, BOOL);
VOID    ComboBox_ShowListBoxWindow(PCBOX, BOOL);
VOID    ComboBox_InternalUpdateEditWindow(PCBOX, HDC);



// Defined in comboini.c
LONG    ComboBox_NcCreateHandler(PCBOX, HWND);
LRESULT ComboBox_CreateHandler(PCBOX, HWND);
VOID    ComboBox_NcDestroyHandler(PWND, PCBOX);
VOID    ComboBox_SetFontHandler(PCBOX, HANDLE, BOOL);
LONG    ComboBox_SetEditItemHeight(PCBOX, int);
VOID    ComboBox_SizeHandler(PCBOX);
VOID    ComboBox_Position(PCBOX);


// Defined in combodir.c
INT     CBDir(PCBOX, UINT, LPWSTR);







#endif // __Combo_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\combodir.c ===
/**************************** Module Header ********************************\
* Module Name: combodir.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Directory Combo Box Routines
*
* History:
* ??-???-???? ??????    Ported from Win 3.0 sources
* 01-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "ctlspriv.h"
#pragma hdrstop
#include "UsrCtl32.h"
#include "Combo.h"
#include "Listbox.h"

/***************************************************************************\
* CBDir
*
* Supports the CB_DIR message which adds a list of files from the
* current directory to the combo box.
*
* History:
\***************************************************************************/
int CBDir(PCBOX pcbox, UINT attrib, LPWSTR pFileName)
{
    PLBIV plb;
    int errorValue;
    
    UserAssert(pcbox->hwndList);
    
    plb = ListBox_GetPtr(pcbox->hwndList);
    
    errorValue = ListBox_DirHandler(plb, attrib, pFileName);
    
    switch (errorValue) 
    {
    case LB_ERR:
        return CB_ERR;
        break;
    case LB_ERRSPACE:
        return CB_ERRSPACE;
        break;
    default:
        return errorValue;
        break;
    }
}

//#define INCLUDE_COMBOBOX_FUNCTIONS
#ifdef  INCLUDE_COMBOBOX_FUNCTIONS

/***************************************************************************\
* DlgDirSelectComboBoxEx
*
* Retrieves the current selection from the listbox of a combobox.
* It assumes that the combo box was filled by DlgDirListComboBox()
* and that the selection is a drive letter, a file, or a directory name.
*
* History:
* 12-05-90 IanJa    converted to internal version
\***************************************************************************/

int DlgDirSelectComboBoxExA(
                            HWND hwndDlg,
                            LPSTR pszOut,
                            int cchOut,
                            int idComboBox)
{
    LPWSTR lpwsz;
    BOOL fRet;
    
    lpwsz = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchOut * sizeof(WCHAR));
    if (!lpwsz) {
        return FALSE;
    }
    
    fRet = DlgDirSelectComboBoxExW(hwndDlg, lpwsz, cchOut, idComboBox);
    
    WCSToMB(lpwsz, -1, &pszOut, cchOut, FALSE);
    
    UserLocalFree(lpwsz);
    
    return fRet;
}

int DlgDirSelectComboBoxExW(
                            HWND hwndDlg,
                            LPWSTR pwszOut,
                            int cchOut,
                            int idComboBox)
{
    HWND  hwndComboBox;
    PCBOX pcbox;
    
    if (hwndDlg == NULL)
        return FALSE;
    
    hwndComboBox = GetDlgItem(hwndDlg, idComboBox);
    if (hwndComboBox == NULL) {
        TraceMsg(TF_STANDARD, "ControlId = %d not found in Dlg = %#.4x", idComboBox, hwndDlg);
        return 0;
    }
    pcbox = ComboBox_GetPtr(hwndComboBox);
    if (pcbox == NULL) {
        TraceMsg(TF_STANDARD, "ControlId = %d is not a combobox", idComboBox);
        return 0;
    }
    
    return DlgDirSelectHelper(pwszOut, cchOut, pcbox->hwndList);
}


/***************************************************************************\
* DlgDirListComboBox
*
* History:
* 12-05-90 IanJa    converted to internal version
\***************************************************************************/

int DlgDirListComboBoxA(
                        HWND hwndDlg,
                        LPSTR lpszPathSpecClient,
                        int idComboBox,
                        int idStaticPath,
                        UINT attrib)
{
    LPWSTR lpszPathSpec;
    BOOL fRet;
    
    if (hwndDlg == NULL)
        return FALSE;
    
    lpszPathSpec = NULL;
    if (lpszPathSpecClient) {
        if (!MBToWCS(lpszPathSpecClient, -1, &lpszPathSpec, -1, TRUE))
            return FALSE;
    }
    
    fRet = DlgDirListHelper(hwndDlg, lpszPathSpec, lpszPathSpecClient,
        idComboBox, idStaticPath, attrib, FALSE);
    
    if (lpszPathSpec) {
        if (fRet) {
        /*
        * Non-zero retval means some text to copy out.  Copy out up to
        * the nul terminator (buffer will be big enough).
            */
            WCSToMB(lpszPathSpec, -1, &lpszPathSpecClient, MAXLONG, FALSE);
        }
        UserLocalFree(lpszPathSpec);
    }
    
    return fRet;
}

int DlgDirListComboBoxW(
                        HWND hwndDlg,
                        LPWSTR lpszPathSpecClient,
                        int idComboBox,
                        int idStaticPath,
                        UINT attrib)
{
    LPWSTR lpszPathSpec;
    BOOL fRet;
    
    if (hwndDlg == NULL)
        return FALSE;
    
    lpszPathSpec = lpszPathSpecClient;
    
    fRet = DlgDirListHelper(hwndDlg, lpszPathSpec, (LPBYTE)lpszPathSpecClient,
        idComboBox, idStaticPath, attrib, FALSE);
    
    return fRet;
}
#endif  // INCLUDE_COMBOBOX_FUNCTIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\combo.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "combo.h"
#include "listbox.h"    // For LBIV struct


//---------------------------------------------------------------------------//
//
//  InitComboboxClass() - Registers the control's window class 
//
BOOL InitComboboxClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = ComboBox_WndProc;
    wc.lpszClassName = WC_COMBOBOX;
    wc.style         = CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PCBOX);
    wc.hInstance     = hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}


//---------------------------------------------------------------------------//
//
//  InitComboLBoxClass() - Registers the control's dropdown window class 
//
// The dropdown list is a specially registered version
// of the listbox control called ComboLBox. We need to
// register this dummy control since apps looking for a
// combobox's listbox look for the classname ComboLBox 
//
BOOL FAR PASCAL InitComboLBoxClass(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = ListBox_WndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = WC_COMBOLBOX;
    wc.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1); // NULL;
    wc.style           = CS_GLOBALCLASS | CS_SAVEBITS | CS_DBLCLKS;
    wc.cbWndExtra      = sizeof(PLBIV);
    wc.cbClsExtra      = 0;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}


//---------------------------------------------------------------------------//
//
// ComboBox_PressButton()
//
// Pops combobox button back up.
//
VOID ComboBox_PressButton(PCBOX pcbox, BOOL fPress)
{
    //
    // Publisher relies on getting a WM_PAINT message after the combo list
    // pops back up.  On a WM_PAINT they change the focus, which causes
    // toolbar combos to send CBN_SELENDCANCEL notifications.  On this
    // notification they apply the font/pt size change you made to the
    // selection.
    //
    // This happened in 3.1 because the dropdown list overlapped the button
    // on the bottom or top by a pixel.  Since we'd end up painting under
    // the list SPB, when it went away USER would reinvalidate the dirty
    // area.  This would cause a paint message.
    //
    // In 4.0, this doesn't happen because the dropdown doesn't overlap.  So
    // we need to make sure Publisher gets a WM_PAINT anyway.  We do this
    // by changing where the dropdown shows up for 3.x apps
    //
    //

    if ((pcbox->fButtonPressed != 0) != (fPress != 0)) 
    {
        HWND hwnd = pcbox->hwnd;

        pcbox->fButtonPressed = (fPress != 0);
        if (pcbox->f3DCombo)
        {
            InvalidateRect(hwnd, &pcbox->buttonrc, TRUE);
        }
        else
        {
            RECT rc;

            CopyRect(&rc, &pcbox->buttonrc);
            InflateRect(&rc, 0, GetSystemMetrics(SM_CYEDGE));
            InvalidateRect(hwnd, &rc, TRUE);
        }

        UpdateWindow(hwnd);

        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_COMBOBOX_BUTTON);
    }
}


//---------------------------------------------------------------------------//
//
// ComboBox_HotTrack
//
// If we're not already hot-tracking and the mouse is over the combobox,
// turn on hot-tracking and invalidate the drop-down button.
//
VOID ComboBox_HotTrack(PCBOX pcbox, POINT pt)
{
    if (!pcbox->fButtonHotTracked && !pcbox->fMouseDown) 
    {
        TRACKMOUSEEVENT tme; 

        tme.cbSize      = sizeof(TRACKMOUSEEVENT);
        tme.dwFlags     = TME_LEAVE;
        tme.hwndTrack   = pcbox->hwnd;
        tme.dwHoverTime = 0;
        if (TrackMouseEvent(&tme)) 
        {
            if ((pcbox->CBoxStyle == SDROPDOWN &&
                 PtInRect(&pcbox->buttonrc, pt)) ||
                 pcbox->CBoxStyle == SDROPDOWNLIST) 
            {
                pcbox->fButtonHotTracked = TRUE;
                InvalidateRect(pcbox->hwnd, NULL, TRUE);
            }
            else
            {
                pcbox->fButtonHotTracked = FALSE;
            }
        }
    }
}


//---------------------------------------------------------------------------//
//
// ComboBox_DBCharHandler
//
// Double Byte character handler for ANSI ComboBox
//
LRESULT ComboBox_DBCharHandler(PCBOX pcbox, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    WORD w;
    HWND hwndSend;

    w = DbcsCombine(hwnd, (BYTE)wParam);
    if (w == 0) 
    {
        return CB_ERR;  // Failed to assemble DBCS
    }

    UserAssert(pcbox->hwndList);
    if (pcbox->fNoEdit) 
    {
        hwndSend = pcbox->hwndList;
    } 
    else if (pcbox->hwndEdit) 
    {
        TraceMsg(TF_STANDARD, "UxCombobox: ComboBoxWndProcWorker: WM_CHAR is posted to Combobox itself(%08x).",
                hwnd);
        hwndSend = pcbox->hwndEdit;
    } 
    else 
    {
        return CB_ERR;
    }

    TraceMsg(TF_STANDARD, "UxCombobox: ComboBoxWndProcWorker: sending WM_CHAR %04x", w);

    if (!TestWF(hwndSend, WFANSIPROC)) 
    {
        //
        // If receiver is not ANSI WndProc (may be subclassed?),
        // send a UNICODE message.
        //
        WCHAR wChar;
        LPWSTR lpwstr = &wChar;

        if (MBToWCSEx(CP_ACP, (LPCSTR)&w, 2, &lpwstr, 1, FALSE) == 0) 
        {
            TraceMsg(TF_STANDARD, "UxCombobox: ComboBoxWndProcWorker: cannot convert 0x%04x to UNICODE.", w);
            return CB_ERR;
        }

        return SendMessage(hwndSend, message, wChar, lParam);
    }

    //
    // Post the Trailing byte to the target
    // so that they can peek the second WM_CHAR
    // message later.
    // Note: it's safe since sender is A and receiver is A,
    // translation layer does not perform any DBCS combining and cracking.
    //PostMessageA(hwndSend, message, CrackCombinedDbcsTB(w), lParam);
    //
    return SendMessage(hwndSend, message, wParam, lParam);
}


//---------------------------------------------------------------------------//
BOOL ComboBox_MsgOKInit(UINT message, LRESULT* plRet)
{
    switch (message) 
    {
    default:
        break;
    case WM_SIZE:
    case CB_SETMINVISIBLE:
    case CB_GETMINVISIBLE:
        *plRet = 0;
        return FALSE;
    case WM_STYLECHANGED:
    case WM_GETTEXT:
    case WM_GETTEXTLENGTH:
    case WM_PRINT:
    case WM_COMMAND:
    case CBEC_KILLCOMBOFOCUS:
    case WM_PRINTCLIENT:
    case WM_SETFONT:
    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
    case WM_CHAR:
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_MOUSEWHEEL:
    case WM_CAPTURECHANGED:
    case WM_LBUTTONUP:
    case WM_MOUSEMOVE:
    case WM_SETFOCUS:
    case WM_KILLFOCUS:
    case WM_SETREDRAW:
    case WM_ENABLE:
    case CB_SETDROPPEDWIDTH:
    case CB_DIR:
    case CB_ADDSTRING:
        //
        // Cannot handle those messages yet. Bail out.
        //
        *plRet = CB_ERR;
        return FALSE;
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// ComboBox_MessageItemHandler
//
// Handles WM_DRAWITEM,WM_MEASUREITEM,WM_DELETEITEM,WM_COMPAREITEM
// messages from the listbox.
//
LRESULT ComboBox_MessageItemHandler(PCBOX pcbox, UINT uMsg, LPVOID lpv)
{
    LRESULT lRet;

    //
    // Send the <lpv>item message back to the application after changing some
    // parameters to their combo box specific versions.
    //
    ((LPMEASUREITEMSTRUCT)lpv)->CtlType = ODT_COMBOBOX;
    ((LPMEASUREITEMSTRUCT)lpv)->CtlID = GetWindowID(pcbox->hwnd);
 
    switch (uMsg)
    {
    case WM_DRAWITEM:
        ((LPDRAWITEMSTRUCT)lpv)->hwndItem = pcbox->hwnd;
        break;

    case WM_DELETEITEM:
        ((LPDELETEITEMSTRUCT)lpv)->hwndItem = pcbox->hwnd;
        break;

    case WM_COMPAREITEM:
        ((LPCOMPAREITEMSTRUCT)lpv)->hwndItem = pcbox->hwnd;
        break;
    }

    lRet = SendMessage(pcbox->hwndParent, uMsg, (WPARAM)GetWindowID(pcbox->hwnd), (LPARAM)lpv);

    return lRet;
}


//---------------------------------------------------------------------------//
VOID ComboBox_Paint(PCBOX pcbox, HDC hdc)
{
    RECT rc;
    UINT msg;
    HBRUSH hbr;
    INT iStateId;

    CCDBUFFER ccdb;

    if (pcbox->fButtonPressed)
    {
        iStateId = CBXS_PRESSED;
    }
    else if ( !IsWindowEnabled(pcbox->hwnd))
    {
        iStateId = CBXS_DISABLED;
    }
    else if (pcbox->fButtonHotTracked)
    {
        iStateId = CBXS_HOT;
    }
    else
    {
        iStateId = CBXS_NORMAL;
    }
        
    rc.left = rc.top = 0;
    rc.right = pcbox->cxCombo;
    rc.bottom = pcbox->cyCombo;

    hdc = CCBeginDoubleBuffer(hdc, &rc, &ccdb);

    if ( !pcbox->hTheme )
    {
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST | (!pcbox->f3DCombo ? BF_FLAT | BF_MONO : 0));
    }
    else
    {
        DrawThemeBackground(pcbox->hTheme, hdc, 0, iStateId, &rc, 0);
    }

    if ( !IsRectEmpty(&pcbox->buttonrc) )
    {
        //
        // Draw in the dropdown arrow button
        //
        if (!pcbox->hTheme)
        {
            DrawFrameControl(hdc, &pcbox->buttonrc, DFC_SCROLL,
                DFCS_SCROLLCOMBOBOX |
                (pcbox->fButtonPressed ? DFCS_PUSHED | DFCS_FLAT : 0) |
                (TESTFLAG(GET_STYLE(pcbox), WS_DISABLED) ? DFCS_INACTIVE : 0) |
                (pcbox->fButtonHotTracked ? DFCS_HOT: 0));
        }
        else
        {
            DrawThemeBackground(pcbox->hTheme, hdc, CP_DROPDOWNBUTTON, iStateId, &pcbox->buttonrc, 0);
        }

        if (pcbox->fRightAlign )
        {
            rc.left = pcbox->buttonrc.right;
        }
        else
        {
            rc.right = pcbox->buttonrc.left;
        }
    }

    //
    // Erase the background behind the edit/static item.  Since a combo
    // is an edit field/list box hybrid, we use the same coloring
    // conventions.
    //
    msg = WM_CTLCOLOREDIT;
    if (TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT)) 
    {
        ULONG ulStyle = pcbox->hwndEdit ? GetWindowStyle(pcbox->hwndEdit) : 0;
        if (TESTFLAG(GET_STYLE(pcbox), WS_DISABLED) ||
            (!pcbox->fNoEdit && pcbox->hwndEdit && (ulStyle & ES_READONLY)))
        {
            msg = WM_CTLCOLORSTATIC;
        }
    } 
    else
    {
        msg = WM_CTLCOLORLISTBOX;
    }

    //
    // GetControlBrush
    //
    hbr = (HBRUSH)SendMessage(GetParent(pcbox->hwnd), msg, (WPARAM)hdc, (LPARAM)pcbox->hwnd);

    if (pcbox->fNoEdit)
    {
        ComboBox_InternalUpdateEditWindow(pcbox, hdc);
    }
    else if (!pcbox->hTheme)
    {
        FillRect(hdc, &rc, hbr);
    }

    CCEndDoubleBuffer(&ccdb);
}


//---------------------------------------------------------------------------//
//
// ComboBox_NotifyParent
//
// Sends the notification code to the parent of the combo box control
//
VOID ComboBox_NotifyParent(PCBOX pcbox, short notificationCode)
{
    HWND hwndSend = (pcbox->hwndParent != 0) ? pcbox->hwndParent : pcbox->hwnd;

    //
    // wParam contains Control ID and notification code.
    // lParam contains Handle to window
    //
    SendMessage(hwndSend, WM_COMMAND,
            MAKELONG(GetWindowID(pcbox->hwnd), notificationCode),
            (LPARAM)pcbox->hwnd);
}


//---------------------------------------------------------------------------//
//
// ComboBox_UpdateListBoxWindow
//
// matches the text in the editcontrol. If fSelectionAlso is false, then we
// unselect the current listbox selection and just move the caret to the item
// which is the closest match to the text in the editcontrol.
//
VOID ComboBox_UpdateListBoxWindow(PCBOX pcbox, BOOL fSelectionAlso)
{

    if (pcbox->hwndEdit) 
    {
        INT    cchText;
        INT    sItem, sSel;
        LPWSTR pText = NULL;

        sItem = CB_ERR;

        cchText = (int)SendMessage(pcbox->hwndEdit, WM_GETTEXTLENGTH, 0, 0);
        if (cchText) 
        {
            cchText++;
            pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchText*sizeof(WCHAR));
            if (pText != NULL) 
            {
                try 
                {
                    SendMessage(pcbox->hwndEdit, WM_GETTEXT, cchText, (LPARAM)pText);
                    sItem = (int)SendMessage(pcbox->hwndList, LB_FINDSTRING,
                            (WPARAM)-1L, (LPARAM)pText);
                } 
                finally 
                {
                    UserLocalFree((HANDLE)pText);
                }
            }
        }

        if (fSelectionAlso) 
        {
            sSel = sItem;
        } 
        else 
        {
            sSel = CB_ERR;
        }

        if (sItem == CB_ERR)
        {
            sItem = 0;

            //
            // Old apps:  w/ editable combos, selected 1st item in list even if
            // it didn't match text in edit field.  This is not desirable
            // behavior for 4.0 dudes esp. with cancel allowed.  Reason:
            //      (1) User types in text that doesn't match list choices
            //      (2) User drops combo
            //      (3) User pops combo back up
            //      (4) User presses OK in dialog that does stuff w/ combo
            //          contents.
            // In 3.1, when the combo dropped, we'd select the 1st item anyway.
            // So the last CBN_SELCHANGE the owner got would be 0--which is
            // bogus because it really should be -1.  In fact if you type anything
            // into the combo afterwards it will reset itself to -1.
            //
            // 4.0 dudes won't get this bogus 0 selection.
            //
            if (fSelectionAlso && !TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT))
            {
                sSel = 0;
            }
        }

        SendMessage(pcbox->hwndList, LB_SETCURSEL, (DWORD)sSel, 0);
        SendMessage(pcbox->hwndList, LB_SETCARETINDEX, (DWORD)sItem, 0);
        SendMessage(pcbox->hwndList, LB_SETTOPINDEX, (DWORD)sItem, 0);
    }
}


//---------------------------------------------------------------------------//
//
// ComboBox_InvertStaticWindow
//
// Inverts the static text/picture window associated with the combo
// box.  Gets its own hdc, if the one given is null.
//
VOID ComboBox_InvertStaticWindow(PCBOX pcbox, BOOL fNewSelectionState, HDC hdc)
{
    BOOL focusSave = pcbox->fFocus;

    pcbox->fFocus = (UINT)fNewSelectionState;
    ComboBox_InternalUpdateEditWindow(pcbox, hdc);

    pcbox->fFocus = (UINT)focusSave;
}


//---------------------------------------------------------------------------//
//
// ComboBox_GetFocusHandler
//
// Handles getting the focus for the combo box
//
VOID ComboBox_GetFocusHandler(PCBOX pcbox)
{
    if (pcbox->fFocus)
    {
        return;
    }

    //
    // The combo box has gotten the focus for the first time.
    //

    //
    // First turn on the listbox caret
    //

    if (pcbox->CBoxStyle == SDROPDOWNLIST)
    {
       SendMessage(pcbox->hwndList, LBCB_CARETON, 0, 0);
    }

    //
    // and select all the text in the editcontrol or static text rectangle.
    //

    if (pcbox->fNoEdit) 
    {
        //
        // Invert the static text rectangle
        //
        ComboBox_InvertStaticWindow(pcbox, TRUE, (HDC)NULL);
    } 
    else if (pcbox->hwndEdit) 
    {
        UserAssert(pcbox->hwnd);
        SendMessage(pcbox->hwndEdit, EM_SETSEL, 0, MAXLONG);
    }

    pcbox->fFocus = TRUE;

    //
    // Notify the parent we have the focus
    //
    ComboBox_NotifyParent(pcbox, CBN_SETFOCUS);
}


//---------------------------------------------------------------------------//
//
// ComboBox_KillFocusHandler
//
// Handles losing the focus for the combo box.
//
VOID ComboBox_KillFocusHandler(PCBOX pcbox)
{
    if (!pcbox->fFocus || pcbox->hwndList == NULL)
    {
        return;
    }

    //
    // The combo box is losing the focus.  Send buttonup clicks so that
    // things release the mouse capture if they have it...  If the
    // pwndListBox is null, don't do anything.  This occurs if the combo box
    // is destroyed while it has the focus.
    //
    SendMessage(pcbox->hwnd, WM_LBUTTONUP, 0L, 0xFFFFFFFFL);
    if (!ComboBox_HideListBoxWindow(pcbox, TRUE, FALSE))
    {
        return;
    }

    //
    // Turn off the listbox caret
    //
    if (pcbox->CBoxStyle == SDROPDOWNLIST)
    {
       SendMessage(pcbox->hwndList, LBCB_CARETOFF, 0, 0);
    }

    if (pcbox->fNoEdit) 
    {
        //
        // Invert the static text rectangle
        //
        ComboBox_InvertStaticWindow(pcbox, FALSE, (HDC)NULL);
    } 
    else if (pcbox->hwndEdit) 
    {
        SendMessage(pcbox->hwndEdit, EM_SETSEL, 0, 0);
    }

    pcbox->fFocus = FALSE;
    ComboBox_NotifyParent(pcbox, CBN_KILLFOCUS);
}


//---------------------------------------------------------------------------//
//
// ComboBox_CommandHandler
//
// Check the various notification codes from the controls and do the
// proper thing.
// always returns 0L
//
LONG ComboBox_CommandHandler(PCBOX pcbox, DWORD wParam, HWND hwndControl)
{
    //
    // Check the edit control notification codes.  Note that currently, edit
    // controls don't send EN_KILLFOCUS messages to the parent.
    //
    if (!pcbox->fNoEdit && (hwndControl == pcbox->hwndEdit)) 
    {
        //
        // Edit control notification codes
        //
        switch (HIWORD(wParam)) 
        {
        case EN_SETFOCUS:
            if (!pcbox->fFocus) 
            {
                //
                // The edit control has the focus for the first time which means
                // this is the first time the combo box has received the focus
                // and the parent must be notified that we have the focus.
                //
                ComboBox_GetFocusHandler(pcbox);
            }

            break;

        case EN_CHANGE:
            ComboBox_NotifyParent(pcbox, CBN_EDITCHANGE);
            ComboBox_UpdateListBoxWindow(pcbox, FALSE);
            break;

        case EN_UPDATE:
            ComboBox_NotifyParent(pcbox, CBN_EDITUPDATE);
            break;

        case EN_ERRSPACE:
            ComboBox_NotifyParent(pcbox, CBN_ERRSPACE);
            break;
        }
    }

    //
    // Check listbox control notification codes
    //
    if (hwndControl == pcbox->hwndList) 
    {
        //
        // Listbox control notification codes
        //
        switch ((int)HIWORD(wParam)) 
        {
        case LBN_DBLCLK:
            ComboBox_NotifyParent(pcbox, CBN_DBLCLK);
            break;

        case LBN_ERRSPACE:
            ComboBox_NotifyParent(pcbox, CBN_ERRSPACE);
            break;

        case LBN_SELCHANGE:
        case LBN_SELCANCEL:
            if (!pcbox->fKeyboardSelInListBox) 
            {
                //
                // If the selchange is caused by the user keyboarding through,
                // we don't want to hide the listbox.
                //
                if (!ComboBox_HideListBoxWindow(pcbox, TRUE, TRUE))
                {
                    return 0;
                }
            } 
            else 
            {
                pcbox->fKeyboardSelInListBox = FALSE;
            }

            ComboBox_NotifyParent(pcbox, CBN_SELCHANGE);
            ComboBox_InternalUpdateEditWindow(pcbox, NULL);

            if (pcbox->fNoEdit)
            {
                NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, pcbox->hwnd, OBJID_CLIENT, INDEX_COMBOBOX);
            }

            break;
        }
    }

    return 0;
}


//---------------------------------------------------------------------------//
//
// ComboBox_CompleteEditWindow
//
//
// Completes the text in the edit box with the closest match from the
// listbox.  If a prefix match can't be found, the edit control text isn't
// updated. Assume a DROPDOWN style combo box.
//
VOID ComboBox_CompleteEditWindow(PCBOX pcbox)
{
    int cchText;
    int cchItemText;
    int itemNumber;
    LPWSTR pText;

    //
    // Firstly check the edit control.
    // 
    if (pcbox->hwndEdit == NULL) 
    {
        return;
    }

    //
    // +1 for null terminator
    //
    cchText = (int)SendMessage(pcbox->hwndEdit, WM_GETTEXTLENGTH, 0, 0);

    if (cchText) 
    {
        cchText++;
        pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchText*sizeof(WCHAR));
        if (!pText)
        {
            goto Unlock;
        }

        //
        // We want to be sure to free the above allocated memory even if
        // the client dies during callback (xxx) or some of the following
        // window revalidation fails.
        //
        try 
        {
            SendMessage(pcbox->hwndEdit, WM_GETTEXT, cchText, (LPARAM)pText);
            itemNumber = (int)SendMessage(pcbox->hwndList,
                    LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pText);

            if (itemNumber == -1)
            {
                itemNumber = (int)SendMessage(pcbox->hwndList,
                        LB_FINDSTRING, (WPARAM)-1, (LPARAM)pText);
            }
        } 
        finally 
        {
            UserLocalFree((HANDLE)pText);
        }

        if (itemNumber == -1) 
        {
            //
            // No close match.  Blow off.
            //
            goto Unlock;
        }

        cchItemText = (int)SendMessage(pcbox->hwndList, LB_GETTEXTLEN,
                itemNumber, 0);
        if (cchItemText) 
        {
            cchItemText++;
            pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchItemText*sizeof(WCHAR));
            if (!pText)
            {
                goto Unlock;
            }

            //
            // We want to be sure to free the above allocated memory even if
            // the client dies during callback (xxx) or some of the following
            // window revalidation fails.
            //
            try 
            {
                SendMessage(pcbox->hwndList, LB_GETTEXT, itemNumber, (LPARAM)pText);
                SendMessage(pcbox->hwndEdit, WM_SETTEXT, 0, (LPARAM)pText);
            } 
            finally 
            {
                UserLocalFree((HANDLE)pText);
            }

            SendMessage(pcbox->hwndEdit, EM_SETSEL, 0, MAXLONG);
        }
    }

Unlock:
    return;
}


//---------------------------------------------------------------------------//
//
// ComboBox_HideListBoxWindow
//
// Hides the dropdown listbox window if it is a dropdown style.
//
BOOL ComboBox_HideListBoxWindow(PCBOX pcbox, BOOL fNotifyParent, BOOL fSelEndOK)
{
    HWND hwnd = pcbox->hwnd;
    HWND hwndList = pcbox->hwndList;

    //
    // For 3.1+ apps, send CBN_SELENDOK to all types of comboboxes but only
    // allow CBN_SELENDCANCEL to be sent for droppable comboboxes
    //
    if (fNotifyParent && TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN31COMPAT) &&
        ((pcbox->CBoxStyle & SDROPPABLE) || fSelEndOK)) 
    {
        if (fSelEndOK)
        {
            ComboBox_NotifyParent(pcbox, CBN_SELENDOK);
        }
        else
        {
            ComboBox_NotifyParent(pcbox, CBN_SELENDCANCEL);
        }

        if (!IsWindow(hwnd))
        {
            return FALSE;
        }
    }

    //
    // return, we don't hide simple combo boxes.
    //
    if (!(pcbox->CBoxStyle & SDROPPABLE)) 
    {
        return TRUE;
    }

    //
    // Send a faked buttonup message to the listbox so that it can release
    // the capture and all.
    //
    SendMessage(pcbox->hwndList, LBCB_ENDTRACK, fSelEndOK, 0);

    if (pcbox->fLBoxVisible) 
    {
        WORD swpFlags = SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE;

        if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN31COMPAT))
        {
            swpFlags |= SWP_FRAMECHANGED;
        }

        pcbox->fLBoxVisible = FALSE;

        //
        // Hide the listbox window
        //
        ShowWindow(hwndList, SW_HIDE);

        //
        // Invalidate the item area now since SWP() might update stuff.
        // Since the combo is CS_VREDRAW/CS_HREDRAW, a size change will
        // redraw the whole thing, including the item rect.  But if it
        // isn't changing size, we still want to redraw the item anyway
        // to show focus/selection.
        //
        if (!(pcbox->CBoxStyle & SEDITABLE))
        {
            InvalidateRect(hwnd, &pcbox->editrc, TRUE);
        }

        SetWindowPos(hwnd, HWND_TOP, 0, 0,
                pcbox->cxCombo, pcbox->cyCombo, swpFlags);

        //
        // In case size didn't change
        //
        UpdateWindow(hwnd);

        if (pcbox->CBoxStyle & SEDITABLE) 
        {
            ComboBox_CompleteEditWindow(pcbox);
        }

        if (fNotifyParent) 
        {
            //
            // Notify parent we will be popping up the combo box.
            //
            ComboBox_NotifyParent(pcbox, CBN_CLOSEUP);

            if (!IsWindow(hwnd))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// ComboBox_ShowListBoxWindow
//
// Lowers the dropdown listbox window.
//
VOID ComboBox_ShowListBoxWindow(PCBOX pcbox, BOOL fTrack)
{
    RECT        editrc;
    RECT        rcWindow;
    RECT        rcList;
    int         itemNumber;
    int         iHeight;
    int         yTop;
    DWORD       dwMult;
    int         cyItem;
    HWND        hwnd = pcbox->hwnd;
    HWND        hwndList = pcbox->hwndList;
    BOOL        fAnimPos;
    HMONITOR    hMonitor;
    MONITORINFO mi = {0};
    BOOL        bCBAnim = FALSE;

    //
    // This function is only called for droppable list comboboxes
    //
    UserAssert(pcbox->CBoxStyle & SDROPPABLE);

    //
    // Notify parent we will be dropping down the combo box.
    //
    ComboBox_NotifyParent(pcbox, CBN_DROPDOWN);

    //
    // Invalidate the button rect so that the depressed arrow is drawn.
    //
    InvalidateRect(hwnd, &pcbox->buttonrc, TRUE);

    pcbox->fLBoxVisible = TRUE;

    if (pcbox->CBoxStyle == SDROPDOWN) 
    {
        //
        // If an item in the listbox matches the text in the edit control,
        // scroll it to the top of the listbox.  Select the item only if the
        // mouse button isn't down otherwise we will select the item when the
        // mouse button goes up.
        //
        ComboBox_UpdateListBoxWindow(pcbox, !pcbox->fMouseDown);

        if (!pcbox->fMouseDown)
        {
            ComboBox_CompleteEditWindow(pcbox);
        }
    } 
    else 
    {
        //
        // Scroll the currently selected item to the top of the listbox.
        //
        itemNumber = (int)SendMessage(pcbox->hwndList, LB_GETCURSEL, 0, 0);
        if (itemNumber == -1) 
        {
            itemNumber = 0;
        }

        SendMessage(pcbox->hwndList, LB_SETTOPINDEX, itemNumber, 0);
        SendMessage(pcbox->hwndList, LBCB_CARETON, 0, 0);

        //
        // We need to invalidate the edit rect so that the focus frame/invert
        // will be turned off when the listbox is visible.  Tandy wants this for
        // his typical reasons...
        //
        InvalidateRect(hwnd, &pcbox->editrc, TRUE);
    }

    //
    // Figure out where to position the dropdown listbox.  We want it just
    // touching the edge around the edit rectangle.  Note that since the
    // listbox is a popup, we need the position in screen coordinates.
    //

    //
    // We want the dropdown to pop below or above the combo
    //

    //
    // Get screen coords
    //
    GetWindowRect(pcbox->hwnd, &rcWindow);
    editrc.left   = rcWindow.left;
    editrc.top    = rcWindow.top;
    editrc.right  = rcWindow.left + pcbox->cxCombo;
    editrc.bottom = rcWindow.top  + pcbox->cyCombo;

    //
    // List area
    //
    cyItem = (int)SendMessage(pcbox->hwndList, LB_GETITEMHEIGHT, 0, 0);

    if (cyItem == 0) 
    {
        //
        // Make sure that it's not 0
        //
        TraceMsg(TF_STANDARD, "UxCombobox: LB_GETITEMHEIGHT is returning 0" );
        cyItem = SYSFONT_CYCHAR;
    }

    //
    //  we shoulda' just been able to use cyDrop here, but thanks to VB's need
    //  to do things their OWN SPECIAL WAY, we have to keep monitoring the size
    //  of the listbox 'cause VB changes it directly (jeffbog 03/21/94)
    //
    GetWindowRect(pcbox->hwndList, &rcList);
    iHeight = max(pcbox->cyDrop, rcList.bottom - rcList.top);

    if (dwMult = (DWORD)SendMessage(pcbox->hwndList, LB_GETCOUNT, 0, 0)) 
    {
        dwMult = (DWORD)(LOWORD(dwMult) * cyItem);
        dwMult += GetSystemMetrics(SM_CYEDGE);

        if (dwMult < 0x7FFF)
        {
            iHeight = min(LOWORD(dwMult), iHeight);
        }
    }

    if (!TESTFLAG(GET_STYLE(pcbox), CBS_NOINTEGRALHEIGHT))
    {
        UserAssert(cyItem);
        iHeight = ((iHeight - GetSystemMetrics(SM_CYEDGE)) / cyItem) * cyItem + GetSystemMetrics(SM_CYEDGE);
    }

    //
    // Other 1/2 of old app combo fix.  Make dropdown overlap combo window
    // a little.  That way we can have a chance of invalidating the overlap
    // and causing a repaint to help out Publisher 2.0's toolbar combos.
    // See comments for PressButton() above.
    //
    hMonitor = MonitorFromWindow(pcbox->hwnd, MONITOR_DEFAULTTOPRIMARY);
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &mi);
    if (editrc.bottom + iHeight <= mi.rcMonitor.bottom) 
    {
        yTop = editrc.bottom;
        if (!pcbox->f3DCombo)
        {
            yTop -= GetSystemMetrics(SM_CYBORDER);
        }

        fAnimPos = TRUE;
    } 
    else 
    {
        yTop = max(editrc.top - iHeight, mi.rcMonitor.top);
        if (!pcbox->f3DCombo)
        {
            yTop += GetSystemMetrics(SM_CYBORDER);
        }

        fAnimPos = FALSE;
    }

    if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT))
    {
        //
        // fix for Winword B#7504, Combo-ListBox text gets
        // truncated by a small width, this is do to us
        // now setting size here in SetWindowPos, rather than
        // earlier where we did this in Win3.1
        //

        GetWindowRect(pcbox->hwndList, &rcList);
        if ((rcList.right - rcList.left ) > pcbox->cxDrop)
        {
            pcbox->cxDrop = rcList.right - rcList.left;
        }
    }

    if (!TESTFLAG(GET_EXSTYLE(pcbox), WS_EX_LAYOUTRTL))
    {
        SetWindowPos(hwndList, HWND_TOPMOST, editrc.left,
            yTop, max(pcbox->cxDrop, pcbox->cxCombo), iHeight, SWP_NOACTIVATE);
    }
    else
    {
        int cx = max(pcbox->cxDrop, pcbox->cxCombo);

        SetWindowPos(hwndList, HWND_TOPMOST, editrc.right - cx,
            yTop, cx, iHeight, SWP_NOACTIVATE);
    }

    //
    // Get any drawing in the combo box window out of the way so it doesn't
    // invalidate any of the SPB underneath the list window.
    //
    UpdateWindow(hwnd);

    SystemParametersInfo(SPI_GETCOMBOBOXANIMATION, 0, (LPVOID)&bCBAnim, 0);
    if (!bCBAnim)
    {
        ShowWindow(hwndList, SW_SHOWNA);
    } 
    else 
    {
        AnimateWindow(hwndList, CMS_QANIMATION, (fAnimPos ? AW_VER_POSITIVE :
                AW_VER_NEGATIVE) | AW_SLIDE);
    }

    //
    // Restart search buffer from first char
    //
    {
        PLBIV plb = ListBox_GetPtr(pcbox->hwndList);

        if ((plb != NULL) && (plb != (PLBIV)-1)) 
        {
            plb->iTypeSearch = 0;
        }
    }

    if (fTrack && TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT))
    {
        SendMessage(pcbox->hwndList, LBCB_STARTTRACK, FALSE, 0);
    }
}


//---------------------------------------------------------------------------//
//
// ComboBox_InternalUpdateEditWindow
//
// Updates the editcontrol/statictext window so that it contains the text
// given by the current selection in the listbox.  If the listbox has no
// selection (ie. -1), then we erase all the text in the editcontrol.
// 
// hdcPaint is from WM_PAINT messages Begin/End Paint hdc. If null, we should
// get our own dc.
//
VOID ComboBox_InternalUpdateEditWindow(PCBOX pcbox, HDC hdcPaint)
{
    int cchText = 0;
    LPWSTR pText = NULL;
    int sItem;
    HDC hdc;
    UINT msg;
    HBRUSH hbrSave;
    HBRUSH hbrControl;
    HANDLE hOldFont;
    DRAWITEMSTRUCT dis;
    RECT rc;
    HWND hwnd = pcbox->hwnd;

    sItem = (int)SendMessage(pcbox->hwndList, LB_GETCURSEL, 0, 0);

    //
    // This 'try-finally' block ensures that the allocated 'pText' will
    // be freed no matter how this routine is exited.
    //
    try 
    {
        if (sItem != -1) 
        {
            cchText = (int)SendMessage(pcbox->hwndList, LB_GETTEXTLEN, (DWORD)sItem, 0);
            pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, (cchText+1) * sizeof(WCHAR));
            if (pText) 
            {
                cchText = (int)SendMessage(pcbox->hwndList, LB_GETTEXT,
                        (DWORD)sItem, (LPARAM)pText);
            }
            else
            {
                cchText = 0;
            }
        }

        if (!pcbox->fNoEdit) 
        {
            if (pcbox->hwndEdit) 
            {
                if (GET_STYLE(pcbox) & CBS_HASSTRINGS)
                {
                    SetWindowText(pcbox->hwndEdit, pText ? pText : TEXT(""));
                }

                if (pcbox->fFocus) 
                {
                    //
                    // Only hilite the text if we have the focus.
                    //
                    SendMessage(pcbox->hwndEdit, EM_SETSEL, 0, MAXLONG);
                }
            }
        } 
        else if (IsComboVisible(pcbox)) 
        {
            if (hdcPaint) 
            {
                hdc = hdcPaint;
            } 
            else 
            {
                hdc = GetDC(hwnd);
            }

            SetBkMode(hdc, OPAQUE);
            if (TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT)) 
            {
                if (TESTFLAG(GET_STYLE(pcbox), WS_DISABLED))
                {
                    msg = WM_CTLCOLORSTATIC;
                }
                else
                {
                    msg = WM_CTLCOLOREDIT;
                }
            } 
            else
            {
                msg = WM_CTLCOLORLISTBOX;
            }

            hbrControl = (HBRUSH)SendMessage(GetParent(hwnd), msg, (WPARAM)hdc, (LPARAM)hwnd);
            hbrSave = SelectObject(hdc, hbrControl);

            CopyRect(&rc, &pcbox->editrc);
            InflateRect(&rc, GetSystemMetrics(SM_CXBORDER), GetSystemMetrics(SM_CYBORDER));
            PatBlt(hdc, rc.left, rc.top, rc.right - rc.left,
                rc.bottom - rc.top, PATCOPY);
            InflateRect(&rc, -GetSystemMetrics(SM_CXBORDER), -GetSystemMetrics(SM_CYBORDER));

            if (pcbox->fFocus && !pcbox->fLBoxVisible) 
            {
                //
                // Fill in the selected area
                //

                //
                // only do the FillRect if we know its not
                // ownerdraw item, otherwise we mess up people up
                // BUT: for Compat's sake we still do this for Win 3.1 guys
                //
                if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT) || !pcbox->OwnerDraw)
                {
                    FillRect(hdc, &rc, GetSysColorBrush(COLOR_HIGHLIGHT));
                }

                SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
            } 
            else if (TESTFLAG(GET_STYLE(pcbox), WS_DISABLED) && !pcbox->OwnerDraw) 
            {
                if ((COLORREF)GetSysColor(COLOR_GRAYTEXT) != GetBkColor(hdc))
                {
                    SetTextColor(hdc, GetSysColor(COLOR_GRAYTEXT));
                }
            }

            if (pcbox->hFont != NULL)
            {
                hOldFont = SelectObject(hdc, pcbox->hFont);
            }

            if (pcbox->OwnerDraw) 
            {
                //
                // Let the app draw the stuff in the static text box.
                //
                dis.CtlType = ODT_COMBOBOX;
                dis.CtlID = GetWindowID(pcbox->hwnd);
                dis.itemID = sItem;
                dis.itemAction = ODA_DRAWENTIRE;
                dis.itemState = (UINT)
                    ((pcbox->fFocus && !pcbox->fLBoxVisible ? ODS_SELECTED : 0) |
                    (TESTFLAG(GET_STYLE(pcbox), WS_DISABLED) ? ODS_DISABLED : 0) |
                    (pcbox->fFocus && !pcbox->fLBoxVisible ? ODS_FOCUS : 0) |
                    (TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT) ? ODS_COMBOBOXEDIT : 0) |
                    (TESTFLAG(GET_EXSTYLE(pcbox), WS_EXP_UIFOCUSHIDDEN) ? ODS_NOFOCUSRECT : 0) |
                    (TESTFLAG(GET_EXSTYLE(pcbox), WS_EXP_UIACCELHIDDEN) ? ODS_NOACCEL : 0));

                dis.hwndItem = hwnd;
                dis.hDC = hdc;
                CopyRect(&dis.rcItem, &rc);

                //
                // Don't let ownerdraw dudes draw outside of the combo client
                // bounds.
                //
                IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

                dis.itemData = (ULONG_PTR)SendMessage(pcbox->hwndList,
                        LB_GETITEMDATA, (UINT)sItem, 0);

                SendMessage(pcbox->hwndParent, WM_DRAWITEM, dis.CtlID, (LPARAM)&dis);
            } 
            else 
            {
                //
                // Start the text one pixel within the rect so that we leave a
                // nice hilite border around the text.
                //

                int x;
                UINT align;

                if (pcbox->fRightAlign ) 
                {
                    align = TA_RIGHT;
                    x = rc.right - GetSystemMetrics(SM_CXBORDER);
                } 
                else 
                {
                    x = rc.left + GetSystemMetrics(SM_CXBORDER);
                    align = 0;
                }

                if (pcbox->fRtoLReading)
                {
                    align |= TA_RTLREADING;
                }

                if (align)
                {
                    SetTextAlign(hdc, GetTextAlign(hdc) | align);
                }

                //
                // Draw the text, leaving a gap on the left & top for selection.
                //
                ExtTextOut(hdc, x, rc.top + GetSystemMetrics(SM_CYBORDER), ETO_CLIPPED | ETO_OPAQUE,
                       &rc, pText ? pText : TEXT(""), cchText, NULL);
                if (pcbox->fFocus && !pcbox->fLBoxVisible) 
                {
                    if (!TESTFLAG(GET_EXSTYLE(pcbox), WS_EXP_UIFOCUSHIDDEN)) 
                    {
                        DrawFocusRect(hdc, &rc);
                    }
                }
            }

            if (pcbox->hFont && hOldFont) 
            {
                SelectObject(hdc, hOldFont);
            }

            if (hbrSave) 
            {
                SelectObject(hdc, hbrSave);
            }

            if (!hdcPaint) 
            {
                ReleaseDC(hwnd, hdc);
            }
        }

    } 
    finally 
    {
        if (pText != NULL)
        {
            UserLocalFree((HANDLE)pText);
        }
    }
}


//---------------------------------------------------------------------------//
//
// ComboBox_GetTextLengthHandler
//
// For the combo box without an edit control, returns size of current selected
// item
//
LONG ComboBox_GetTextLengthHandler(PCBOX pcbox)
{
    int item;
    int cchText;

    item = (int)SendMessage(pcbox->hwndList, LB_GETCURSEL, 0, 0);

    if (item == LB_ERR) 
    {
        //
        // No selection so no text.
        //
        cchText = 0;
    } 
    else 
    {
        cchText = (int)SendMessage(pcbox->hwndList, LB_GETTEXTLEN, item, 0);
    }

    return cchText;
}


//---------------------------------------------------------------------------//
//
// ComboBox_GetTextHandler
//
// For the combo box without an edit control, copies cbString bytes of the
// string in the static text box to the buffer given by pszString.
//
DWORD ComboBox_GetTextHandler(PCBOX pcbox, LPWSTR pszBuffer, DWORD cchBuffer)
{
    DWORD cchRet = 0;

    if ((pszBuffer != NULL) && (cchBuffer > 0))
    {
        int iItem = ListBox_GetCurSel(pcbox->hwndList);

        // Null the buffer to be nice.
        *pszBuffer = 0;

        if (iItem != LB_ERR)
        {
            DWORD cchItem = ListBox_GetTextLen(pcbox->hwndList, iItem);

            if (cchItem < cchBuffer)
            {
                // Buffer size is large enough to hold item text
                cchRet = ListBox_GetText(pcbox->hwndList, iItem, pszBuffer);
            }
            else
            {
                // Buffer isn't large enough to hold item text. 
                // Copy as much as will fit.
                LPWSTR pszItem = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, (cchItem+1)*SIZEOF(WCHAR));
                if (pszItem)
                {
                    ListBox_GetText(pcbox->hwndList, iItem, pszItem);
                    StringCchCopy(pszBuffer, cchBuffer, pszItem);

                    cchRet = lstrlen(pszBuffer);

                    UserLocalFree(pszBuffer);
                }
            }
        }
    }

    return cchRet;
}


//---------------------------------------------------------------------------//
// ComboBox_GetInfo 
//
// return information about this combobox to the caller
// in the ComboBoxInfo struct
//
BOOL ComboBox_GetInfo(PCBOX pcbox, PCOMBOBOXINFO pcbi)
{
    BOOL bRet = FALSE;

    if (!pcbi || pcbi->cbSize != sizeof(COMBOBOXINFO))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        //
        // populate the structure
        //
        pcbi->hwndCombo = pcbox->hwnd;
        pcbi->hwndItem  = pcbox->hwndEdit;
        pcbi->hwndList  = pcbox->hwndList;

        pcbi->rcItem   = pcbox->editrc;
        pcbi->rcButton = pcbox->buttonrc;

        pcbi->stateButton = 0;
        if (pcbox->CBoxStyle == CBS_SIMPLE)
        {
            pcbi->stateButton |= STATE_SYSTEM_INVISIBLE;
        }
        if (pcbox->fButtonPressed)
        {
            pcbi->stateButton |= STATE_SYSTEM_PRESSED;
        }

        bRet = TRUE;
    }

    return bRet;
}


//---------------------------------------------------------------------------//
//
// ComboBox_WndProc
//
// WndProc for comboboxes.
//
LRESULT WINAPI ComboBox_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PCBOX       pcbox;
    POINT       pt;
    LPWSTR      lpwsz = NULL;
    LRESULT     lReturn = TRUE;
    static BOOL fInit = TRUE;
    INT         i;
    RECT        rcCombo;
    RECT        rcList;
    RECT        rcWindow;

    //
    // Get the instance data for this combobox control
    //
    pcbox = ComboBox_GetPtr(hwnd);
    if (!pcbox && uMsg != WM_NCCREATE)
    {
        goto CallDWP;
    }

    //
    // Protect the combobox during the initialization.
    //
    if (!pcbox || pcbox->hwndList == NULL) 
    {
        if (!ComboBox_MsgOKInit(uMsg, &lReturn)) 
        {
            TraceMsg(TF_STANDARD, "UxCombobox: ComboBoxWndProcWorker: msg=%04x is sent to hwnd=%08x in the middle of initialization.",
                    uMsg, hwnd);
            return lReturn;
        }
    }

    //
    // Dispatch the various messages we can receive
    //
    switch (uMsg) 
    {
    case CBEC_KILLCOMBOFOCUS:

        //
        // Private message coming from editcontrol informing us that the combo
        // box is losing the focus to a window which isn't in this combo box.
        //
        ComboBox_KillFocusHandler(pcbox);
        break;

    case WM_COMMAND:

        //
        // So that we can handle notification messages from the listbox and
        // edit control.
        //
        return ComboBox_CommandHandler(pcbox, (DWORD)wParam, (HWND)lParam);

    case WM_STYLECHANGED:
    {
        LONG OldStyle;
        LONG NewStyle = 0;

        UserAssert(pcbox->hwndList != NULL);

        pcbox->fRtoLReading = TESTFLAG(GET_EXSTYLE(pcbox), WS_EX_RTLREADING);
        pcbox->fRightAlign  = TESTFLAG(GET_EXSTYLE(pcbox), WS_EX_RIGHT);

        if (pcbox->fRtoLReading)
        {
            NewStyle |= (WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);
        }

        if (pcbox->fRightAlign)
        {
            NewStyle |= WS_EX_RIGHT;
        }

        OldStyle = GetWindowExStyle(pcbox->hwndList) & ~(WS_EX_RIGHT|WS_EX_RTLREADING|WS_EX_LEFTSCROLLBAR);
        SetWindowLong(pcbox->hwndList, GWL_EXSTYLE, OldStyle|NewStyle);

        if (!pcbox->fNoEdit && pcbox->hwndEdit) 
        {
            OldStyle = GetWindowExStyle(pcbox->hwndEdit) & ~(WS_EX_RIGHT|WS_EX_RTLREADING|WS_EX_LEFTSCROLLBAR);
            SetWindowLong(pcbox->hwndEdit, GWL_EXSTYLE, OldStyle|NewStyle);
        }

        ComboBox_Position(pcbox);
        InvalidateRect(hwnd, NULL, FALSE);

        break;
    }
    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLOR:
        //
        // Causes compatibility problems for 3.X apps.  Forward only
        // for 4.0
        //
        if (TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT)) 
        {
            LRESULT ret;

            ret = SendMessage(pcbox->hwndParent, uMsg, wParam, lParam);
            return ret;
        } 
        else
        {
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }

        break;

    case WM_GETTEXT:
        if (pcbox->fNoEdit) 
        {
            return ComboBox_GetTextHandler(pcbox, (LPWSTR)lParam, (int)wParam);
        }

        goto CallEditSendMessage;

        break;

    case WM_GETTEXTLENGTH:

        //
        // If the is not edit control, CBS_DROPDOWNLIST, then we have to
        // ask the list box for the size
        //

        if (pcbox->fNoEdit) 
        {
            return ComboBox_GetTextLengthHandler(pcbox);
        }

        // FALL THROUGH

    case WM_CLEAR:
    case WM_CUT:
    case WM_PASTE:
    case WM_COPY:
    case WM_SETTEXT:
        goto CallEditSendMessage;
        break;

    case WM_CREATE:

        //
        // wParam - not used
        // lParam - Points to the CREATESTRUCT data structure for the window.
        //
        return ComboBox_CreateHandler(pcbox, hwnd);

    case WM_ERASEBKGND:

        //
        // Just return 1L so that the background isn't erased
        //
        return 1L;

    case WM_GETFONT:
        return (LRESULT)pcbox->hFont;

    case WM_PRINT:
        if (!DefWindowProc(hwnd, uMsg, wParam, lParam))
            return FALSE;

        if ( (lParam & PRF_OWNED) && 
             (pcbox->CBoxStyle & SDROPPABLE) &&
             IsWindowVisible(pcbox->hwndList) ) 
        {
            INT iDC = SaveDC((HDC) wParam);

            GetWindowRect(hwnd, &rcCombo);
            GetWindowRect(pcbox->hwndList, &rcList);

            OffsetWindowOrgEx((HDC) wParam, 0, rcCombo.top - rcList.top, NULL);

            lParam &= ~PRF_CHECKVISIBLE;
            SendMessage(pcbox->hwndList, WM_PRINT, wParam, lParam);
            RestoreDC((HDC) wParam, iDC);
        }

        return TRUE;

    case WM_PRINTCLIENT:
        ComboBox_Paint(pcbox, (HDC) wParam);
        break;

    case WM_PAINT: 
    {
        HDC hdc;
        PAINTSTRUCT ps;

        //
        // wParam - perhaps a hdc
        //
        hdc = (wParam) ? (HDC) wParam : BeginPaint(hwnd, &ps);

        if (IsComboVisible(pcbox))
        {
            ComboBox_Paint(pcbox, hdc);
        }

        if (!wParam)
        {
            EndPaint(hwnd, &ps);
        }

        break;
    }

    case WM_GETDLGCODE:
    //
    // wParam - not used
    // lParam - not used
    //
    {
        LRESULT code = DLGC_WANTCHARS | DLGC_WANTARROWS;

        //
        // If the listbox is dropped and the ENTER key is pressed,
        // we want this message so we can close up the listbox
        //
        if ((lParam != 0) &&
            (((LPMSG)lParam)->message == WM_KEYDOWN) &&
            pcbox->fLBoxVisible &&
            ((wParam == VK_RETURN) || (wParam == VK_ESCAPE)))
        {
            code |= DLGC_WANTMESSAGE;
        }

        return code;
    }

    case WM_SETFONT:
        ComboBox_SetFontHandler(pcbox, (HANDLE)wParam, LOWORD(lParam));
        break;

    case WM_SYSKEYDOWN:
        //
        // Check if the alt key is down
        //
        if (lParam & 0x20000000L)
        {
            //
            // Handle Combobox support.  We want alt up or down arrow to behave
            //  like F4 key which completes the combo box selection
            //
            if (lParam & 0x1000000) 
            {
                //
                // This is an extended key such as the arrow keys not on the
                // numeric keypad so just drop the combobox.
                //
                if (wParam == VK_DOWN || wParam == VK_UP)
                {
                    goto DropCombo;
                }

                goto CallDWP;
            }

            if (GetKeyState(VK_NUMLOCK) & 0x1) 
            {
                //
                // If numlock down, just send all system keys to dwp
                //
                goto CallDWP;
            } 
            else 
            {
                //
                // We just want to ignore keys on the number pad...
                //
                if (!(wParam == VK_DOWN || wParam == VK_UP))
                {
                    goto CallDWP;
                }
            }
DropCombo:
            if (!pcbox->fLBoxVisible) 
            {
                //
                // If the listbox isn't visible, just show it
                //
                ComboBox_ShowListBoxWindow(pcbox, TRUE);
            } 
            else 
            {
                //
                // Ok, the listbox is visible.  So hide the listbox window.
                //
                if (!ComboBox_HideListBoxWindow(pcbox, TRUE, TRUE))
                {
                    return 0L;
                }
            }
        }
        goto CallDWP;
        break;

    case WM_KEYDOWN:
        //
        // If the listbox is dropped and the ENTER key is pressed,
        // close up the listbox successfully.  If ESCAPE is pressed,
        // close it up like cancel.
        //
        if (pcbox->fLBoxVisible) 
        {
            if ((wParam == VK_RETURN) || (wParam == VK_ESCAPE)) 
            {
                ComboBox_HideListBoxWindow(pcbox, TRUE, (wParam != VK_ESCAPE));
                break;
            }
        }

        //
        // FALL THROUGH
        //

    case WM_CHAR:
        if (g_fDBCSEnabled && IsDBCSLeadByte((BYTE)wParam)) 
        {
            return ComboBox_DBCharHandler(pcbox, hwnd, uMsg, wParam, lParam);
        }

        if (pcbox->fNoEdit) 
        {
            goto CallListSendMessage;
        }
        else
        {
            goto CallEditSendMessage;
        }
        break;

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:

        pcbox->fButtonHotTracked = FALSE;
        //
        // Set the focus to the combo box if we get a mouse click on it.
        //
        if (!pcbox->fFocus) 
        {
            SetFocus(hwnd);
            if (!pcbox->fFocus) 
            {
                //
                // Don't do anything if we still don't have the focus.
                //
                break;
            }
        }

        //
        // If user clicked in button rect and we are a combobox with edit, then
        // drop the listbox.  (The button rect is 0 if there is no button so the
        // ptinrect will return false.) If a drop down list (no edit), clicking
        // anywhere on the face causes the list to drop.
        //

        POINTSTOPOINT(pt, lParam);
        if ((pcbox->CBoxStyle == SDROPDOWN &&
                PtInRect(&pcbox->buttonrc, pt)) ||
                pcbox->CBoxStyle == SDROPDOWNLIST) 
        {
            //
            // Set the fMouseDown flag so that we can handle clicking on
            // the popdown button and dragging into the listbox (when it just
            // dropped down) to make a selection.
            //
            pcbox->fButtonPressed = TRUE;
            if (pcbox->fLBoxVisible) 
            {
                if (pcbox->fMouseDown) 
                {
                    pcbox->fMouseDown = FALSE;
                    ReleaseCapture();
                }
                ComboBox_PressButton(pcbox, FALSE);

                if (!ComboBox_HideListBoxWindow(pcbox, TRUE, TRUE))
                {
                    return 0L;
                }
            } 
            else 
            {
                ComboBox_ShowListBoxWindow(pcbox, FALSE);

                // Setting and resetting this flag must always be followed
                // imediately by SetCapture or ReleaseCapture
                //
                pcbox->fMouseDown = TRUE;
                SetCapture(hwnd);
                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_COMBOBOX_BUTTON);
            }
        }
        break;

    case WM_MOUSEWHEEL:
        //
        // Handle only scrolling.
        //
        if (wParam & (MK_CONTROL | MK_SHIFT))
        {
            goto CallDWP;
        }

        //
        // If the listbox is visible, send it the message to scroll.
        //
        if (pcbox->fLBoxVisible)
        {
            goto CallListSendMessage;
        }

        //
        // If we're in extended UI mode or the edit control isn't yet created,
        // bail.
        //
        if (pcbox->fExtendedUI || pcbox->hwndEdit == NULL)
        {
            return TRUE;
        }

        //
        // Emulate arrow up/down messages to the edit control.
        //
        i = abs(((short)HIWORD(wParam))/WHEEL_DELTA);
        wParam = ((short)HIWORD(wParam) > 0) ? VK_UP : VK_DOWN;

        while (i-- > 0) 
        {
            SendMessage(pcbox->hwndEdit, WM_KEYDOWN, wParam, 0);
        }

        return TRUE;

    case WM_CAPTURECHANGED:
        if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT))
        {
            return 0;
        }

        if ((pcbox->fMouseDown)) 
        {
            pcbox->fMouseDown = FALSE;
            ComboBox_PressButton(pcbox, FALSE);

            //
            // Pop combo listbox back up, canceling.
            //
            if (pcbox->fLBoxVisible)
            {
                ComboBox_HideListBoxWindow(pcbox, TRUE, FALSE);
            }
        }
        break;

    case WM_LBUTTONUP:
        ComboBox_PressButton(pcbox, FALSE);

        //
        // Clear this flag so that mouse moves aren't sent to the listbox
        //
        if (pcbox->fMouseDown || ((pcbox->CBoxStyle & SDROPPABLE) && pcbox->fLBoxVisible))  
        {
            if (pcbox->fMouseDown)
            {
                pcbox->fMouseDown = FALSE;

                if (pcbox->CBoxStyle == SDROPDOWN) 
                {
                    //
                    // If an item in the listbox matches the text in the edit
                    // control, scroll it to the top of the listbox. Select the
                    // item only if the mouse button isn't down otherwise we
                    // will select the item when the mouse button goes up.
                    //
                    ComboBox_UpdateListBoxWindow(pcbox, TRUE);
                    ComboBox_CompleteEditWindow(pcbox);
                }

                ReleaseCapture();
            }

            //
            // Now, we want listbox to track mouse moves while mouse up
            // until mouse down, and select items as though they were
            // clicked on.
            //
            if (TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT)) 
            {
                SendMessage(pcbox->hwndList, LBCB_STARTTRACK, FALSE, 0);
            }
        }

        if (pcbox->hTheme)
        {
            POINTSTOPOINT(pt, lParam);
            ComboBox_HotTrack(pcbox, pt);
        }
        
        break;

    case WM_MOUSELEAVE:
        pcbox->fButtonHotTracked = FALSE;
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_MOUSEMOVE:
        if (pcbox->fMouseDown) 
        {
            POINTSTOPOINT(pt, lParam);

            ClientToScreen(hwnd, &pt);
            GetWindowRect(pcbox->hwndList, &rcList);
            if (PtInRect(&rcList, pt)) 
            {
                //
                // This handles dropdown comboboxes/listboxes so that clicking
                // on the dropdown button and dragging into the listbox window
                // will let the user make a listbox selection.
                //
                pcbox->fMouseDown = FALSE;
                ReleaseCapture();

                if (pcbox->CBoxStyle & SEDITABLE) 
                {
                    // If an item in the listbox matches the text in the edit
                    // control, scroll it to the top of the listbox.  Select the
                    // item only if the mouse button isn't down otherwise we
                    // will select the item when the mouse button goes up.

                    //
                    // We need to select the item which matches the editcontrol
                    // so that if the user drags out of the listbox, we don't
                    // cancel back to his origonal selection
                    //
                    ComboBox_UpdateListBoxWindow(pcbox, TRUE);
                }

                //
                // Convert point to listbox coordinates and send a buttondown
                // message to the listbox window.
                //
                ScreenToClient(pcbox->hwndList, &pt);
                lParam = POINTTOPOINTS(pt);
                uMsg = WM_LBUTTONDOWN;

                goto CallListSendMessage;
            }
        }

        if (pcbox->hTheme)
        {
            POINTSTOPOINT(pt, lParam);
            ComboBox_HotTrack(pcbox, pt);
        }

        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        ComboBox_NcDestroyHandler(hwnd, pcbox);

        break;

    case WM_SETFOCUS:
        if (pcbox->fNoEdit) 
        {
            //
            // There is no editcontrol so set the focus to the combo box itself.
            //
            ComboBox_GetFocusHandler(pcbox);
        } 
        else if (pcbox->hwndEdit) 
        {
            //
            // Set the focus to the edit control window if there is one
            //
            SetFocus(pcbox->hwndEdit);
        }
        break;

    case WM_KILLFOCUS:

        //
        // wParam has the new focus hwnd
        //
        if ((wParam == 0) || !IsChild(hwnd, (HWND)wParam)) 
        {
            //
            // We only give up the focus if the new window getting the focus
            // doesn't belong to the combo box.
            //
            ComboBox_KillFocusHandler(pcbox);
        }

        if ( IsWindow(hwnd) )
        {
            PLBIV plb = ListBox_GetPtr(pcbox->hwndList);

            if ((plb != NULL) && (plb != (PLBIV)-1)) 
            {
                plb->iTypeSearch = 0;
                if (plb->pszTypeSearch) 
                {
                    UserLocalFree(plb->pszTypeSearch);
                    plb->pszTypeSearch = NULL;
                }
            }
        }
        break;

    case WM_SETREDRAW:

        //
        // wParam - specifies state of the redraw flag.  nonzero = redraw
        // lParam - not used
        //

        //
        // effects: Sets the state of the redraw flag for this combo box
        // and its children.
        //
        pcbox->fNoRedraw = (UINT)!((BOOL)wParam);

        //
        // Must check pcbox->spwnEdit in case we get this message before
        // WM_CREATE - PCBOX won't be initialized yet. (Eudora does this)
        //
        if (!pcbox->fNoEdit && pcbox->hwndEdit) 
        {
            SendMessage(pcbox->hwndEdit, uMsg, wParam, lParam);
        }

        goto CallListSendMessage;
        break;

    case WM_ENABLE:

        //
        // Invalidate the rect to cause it to be drawn in grey for its
        // disabled view or ungreyed for non-disabled view.
        //
        InvalidateRect(hwnd, NULL, FALSE);
        if ((pcbox->CBoxStyle & SEDITABLE) && pcbox->hwndEdit) 
        {
            //
            // Enable/disable the edit control window
            //
            EnableWindow(pcbox->hwndEdit, !TESTFLAG(GET_STYLE(pcbox), WS_DISABLED));
        }

        //
        // Enable/disable the listbox window
        //
        UserAssert(pcbox->hwndList);
        EnableWindow(pcbox->hwndList, !TESTFLAG(GET_STYLE(pcbox), WS_DISABLED));
      break;

    case WM_SIZE:

        //
        // wParam - defines the type of resizing fullscreen, sizeiconic,
        //          sizenormal etc.
        // lParam - new width in LOWORD, new height in HIGHUINT of client area
        //
        UserAssert(pcbox->hwndList);
        if (LOWORD(lParam) == 0 || HIWORD(lParam) == 0) 
        {
            //
            // If being sized to a zero width or to a zero height or we aren't
            // fully initialized, just return.
            //
            return 0;
        }

        //
        // OPTIMIZATIONS -- first check if old and new widths are the same
        //
        GetWindowRect(hwnd, &rcWindow);
        if (pcbox->cxCombo == rcWindow.right - rcWindow.left) 
        {
            int iNewHeight = rcWindow.bottom - rcWindow.top;

            //
            // now check if new height is the dropped down height
            //
            if (pcbox->fLBoxVisible) 
            {
                //
                // Check if new height is the full size height
                //
                if (pcbox->cyDrop + pcbox->cyCombo == iNewHeight)
                {
                    return 0;
                }
            } 
            else 
            {
                //
                // Check if new height is the closed up height
                //
                if (pcbox->cyCombo == iNewHeight)
                {
                    return 0;
                }
            }
        }

        ComboBox_SizeHandler(pcbox);

        break;

    case WM_WINDOWPOSCHANGING:
        if (lParam)
        {
            ((LPWINDOWPOS)lParam)->flags |= SWP_NOCOPYBITS;
        }

        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        break;

    case CB_GETDROPPEDSTATE:

        //
        // returns 1 if combo is dropped down else 0
        // wParam - not used
        // lParam - not used
        //
        return pcbox->fLBoxVisible;

    case CB_GETDROPPEDCONTROLRECT:

        //
        // wParam - not used
        // lParam - lpRect which will get the dropped down window rect in
        //          screen coordinates.
        //
        if ( lParam )
        {
            GetWindowRect(hwnd, &rcWindow);
            ((LPRECT)lParam)->left      = rcWindow.left;
            ((LPRECT)lParam)->top       = rcWindow.top;
            ((LPRECT)lParam)->right     = rcWindow.left + max(pcbox->cxDrop, pcbox->cxCombo);
            ((LPRECT)lParam)->bottom    = rcWindow.top + pcbox->cyCombo + pcbox->cyDrop;
        }
        else
        {
            lReturn = 0;
        }

        break;

    case CB_SETDROPPEDWIDTH:
        if (pcbox->CBoxStyle & SDROPPABLE) 
        {
            if (wParam) 
            {
                wParam = max(wParam, (UINT)pcbox->cxCombo);

                if (wParam != (UINT) pcbox->cxDrop)
                {
                    pcbox->cxDrop = (int)wParam;
                    ComboBox_Position(pcbox);
                }
            }
        }
        //
        // fall thru
        //

    case CB_GETDROPPEDWIDTH:
        if (pcbox->CBoxStyle & SDROPPABLE)
        {
            return (LRESULT)max(pcbox->cxDrop, pcbox->cxCombo);
        }
        else
        {
            return CB_ERR;
        }

        break;

    case CB_DIR:
        //
        // wParam - Dos attribute value.
        // lParam - Points to a file specification string
        //
        return lParam ? CBDir(pcbox, LOWORD(wParam), (LPWSTR)lParam) : CB_ERR;

    case CB_SETEXTENDEDUI:

        //
        // wParam - specifies state to set extendui flag to.
        // Currently only 1 is allowed.  Return CB_ERR (-1) if
        // failure else 0 if success.
        //
        if (pcbox->CBoxStyle & SDROPPABLE) 
        {
            if (!wParam) 
            {
                pcbox->fExtendedUI = 0;
                return 0;
            }

            if (wParam == 1) 
            {
                pcbox->fExtendedUI = 1;
                return 0;
            }

            TraceMsg(TF_STANDARD,
                    "UxCombobox: Invalid parameter \"wParam\" (%ld) to ComboBoxWndProcWorker",
                    wParam);

        } 
        else 
        {
            TraceMsg(TF_STANDARD,
                    "UxCombobox: Invalid message (%ld) sent to ComboBoxWndProcWorker",
                    uMsg);
        }

        return CB_ERR;

    case CB_GETEXTENDEDUI:
        if (pcbox->CBoxStyle & SDROPPABLE) 
        {
            if (pcbox->fExtendedUI)
            {
                return TRUE;
            }
        }

        return FALSE;

    case CB_GETEDITSEL:

        //
        // wParam - not used
        // lParam - not used
        // effects: Gets the selection range for the given edit control.  The
        // starting BYTE-position is in the low order word.  It contains the
        // the BYTE-position of the first nonselected character after the end
        // of the selection in the high order word.  Returns CB_ERR if no
        // editcontrol.
        //
        uMsg = EM_GETSEL;

        goto CallEditSendMessage;
        break;

    case CB_LIMITTEXT:

        //
        // wParam - max number of bytes that can be entered
        // lParam - not used
        // effects: Specifies the maximum number of bytes of text the user may
        // enter.  If maxLength is 0, we may enter MAXINT number of BYTES.
        //
        uMsg = EM_LIMITTEXT;

        goto CallEditSendMessage;
        break;

    case CB_SETEDITSEL:

        //
        // wParam - ichStart
        // lParam - ichEnd
        //
        uMsg = EM_SETSEL;

        wParam = (int)(SHORT)LOWORD(lParam);
        lParam = (int)(SHORT)HIWORD(lParam);

        goto CallEditSendMessage;
        break;

    case CB_ADDSTRING:

        //
        // wParam - not used
        // lParam - Points to null terminated string to be added to listbox
        //
        if (!pcbox->fCase)
        {
            uMsg = LB_ADDSTRING;
        }
        else
        {
            uMsg = (pcbox->fCase & UPPERCASE) ? LB_ADDSTRINGUPPER : LB_ADDSTRINGLOWER;
        }

        goto CallListSendMessage;
        break;

    case CB_DELETESTRING:

        //
        // wParam - index to string to be deleted
        // lParam - not used
        //
        uMsg = LB_DELETESTRING;

        goto CallListSendMessage;
        break;

    case CB_INITSTORAGE:
        //
        // wParamLo - number of items
        // lParam - number of bytes of string space
        //
        uMsg = LB_INITSTORAGE;

        goto CallListSendMessage;

    case CB_SETTOPINDEX:
        //
        // wParamLo - index to make top
        // lParam - not used
        //
        uMsg = LB_SETTOPINDEX;

        goto CallListSendMessage;

    case CB_GETTOPINDEX:
        //
        // wParamLo / lParam - not used
        //
        uMsg = LB_GETTOPINDEX;

        goto CallListSendMessage;

    case CB_GETCOUNT:
        //
        // wParam - not used
        // lParam - not used
        //
        uMsg = LB_GETCOUNT;

        goto CallListSendMessage;
        break;

    case CB_GETCURSEL:
        //
        // wParam - not used
        // lParam - not used
        //
        uMsg = LB_GETCURSEL;

        goto CallListSendMessage;
        break;

    case CB_GETLBTEXT:
        //
        // wParam - index of string to be copied
        // lParam - buffer that is to receive the string
        //
        uMsg = LB_GETTEXT;

        goto CallListSendMessage;
        break;

    case CB_GETLBTEXTLEN:
        //
        // wParam - index to string
        // lParam - now used for cbANSI
        //
        uMsg = LB_GETTEXTLEN;

        goto CallListSendMessage;
        break;

    case CB_INSERTSTRING:
        //
        // wParam - position to receive the string
        // lParam - points to the string
        //
        if (!pcbox->fCase)
        {
            uMsg = LB_INSERTSTRING;
        }
        else
        {
            uMsg = (pcbox->fCase & UPPERCASE) ? LB_INSERTSTRINGUPPER : LB_INSERTSTRINGLOWER;
        }

        goto CallListSendMessage;
        break;

    case CB_RESETCONTENT:
        //
        // wParam - not used
        // lParam - not used
        // If we come here before WM_CREATE has been processed,
        // pcbox->spwndList will be NULL.
        //
        UserAssert(pcbox->hwndList);
        SendMessage(pcbox->hwndList, LB_RESETCONTENT, 0, 0);
        ComboBox_InternalUpdateEditWindow(pcbox, NULL);

        break;

    case CB_GETHORIZONTALEXTENT:
        uMsg = LB_GETHORIZONTALEXTENT;

        goto CallListSendMessage;

    case CB_SETHORIZONTALEXTENT:
        uMsg = LB_SETHORIZONTALEXTENT;

        goto CallListSendMessage;

    case CB_FINDSTRING:
        //
        // wParam - index of starting point for search
        // lParam - points to prefix string
        //
        uMsg = LB_FINDSTRING;

        goto CallListSendMessage;
        break;

    case CB_FINDSTRINGEXACT:
        //
        // wParam - index of starting point for search
        // lParam - points to a exact string
        //
        uMsg = LB_FINDSTRINGEXACT;

        goto CallListSendMessage;
        break;

    case CB_SELECTSTRING:
        //
        // wParam - index of starting point for search
        // lParam - points to prefix string
        //
        UserAssert(pcbox->hwndList);
        lParam = SendMessage(pcbox->hwndList, LB_SELECTSTRING, wParam, lParam);
        ComboBox_InternalUpdateEditWindow(pcbox, NULL);

        return lParam;

    case CB_SETCURSEL:
        //
        // wParam - Contains index to be selected
        // lParam - not used
        // If we come here before WM_CREATE has been processed,
        // pcbox->spwndList will be NULL.
        //
        UserAssert(pcbox->hwndList);

        lParam = SendMessage(pcbox->hwndList, LB_SETCURSEL, wParam, lParam);
        if (lParam != -1) 
        {
            SendMessage(pcbox->hwndList, LB_SETTOPINDEX, wParam, 0);
        }
        ComboBox_InternalUpdateEditWindow(pcbox, NULL);

        return lParam;

    case CB_GETITEMDATA:
        uMsg = LB_GETITEMDATA;

        goto CallListSendMessage;
        break;

    case CB_SETITEMDATA:
        uMsg = LB_SETITEMDATA;

        goto CallListSendMessage;
        break;

    case CB_SETITEMHEIGHT:
        if (wParam == -1) 
        {
            if (HIWORD(lParam) != 0)
            {
                return CB_ERR;
            }

            return ComboBox_SetEditItemHeight(pcbox, LOWORD(lParam));
        }

        uMsg = LB_SETITEMHEIGHT;
        goto CallListSendMessage;

        break;

    case CB_GETITEMHEIGHT:
        if (wParam == -1)
        {
            return pcbox->editrc.bottom - pcbox->editrc.top;
        }

        uMsg = LB_GETITEMHEIGHT;

        goto CallListSendMessage;
        break;

    case CB_SHOWDROPDOWN:
        //
        // wParam - True then drop down the listbox if possible else hide it
        // lParam - not used
        //
        if (wParam && !pcbox->fLBoxVisible) 
        {
            ComboBox_ShowListBoxWindow(pcbox, TRUE);
        } 
        else 
        {
            if (!wParam && pcbox->fLBoxVisible) 
            {
                ComboBox_HideListBoxWindow(pcbox, TRUE, FALSE);
            }
        }

        break;

    case CB_SETLOCALE:
        //
        // wParam - locale id
        // lParam - not used
        //
        uMsg = LB_SETLOCALE;
        goto CallListSendMessage;

        break;

    case CB_GETLOCALE:
        //
        // wParam - not used
        // lParam - not used
        //
        uMsg = LB_GETLOCALE;
        goto CallListSendMessage;
        break;

    case CB_GETCOMBOBOXINFO:
        //
        // wParam - not used
        // lParam - pointer to COMBOBOXINFO struct
        //
        lReturn = ComboBox_GetInfo(pcbox, (PCOMBOBOXINFO)lParam);
        break;

    case CB_SETMINVISIBLE:
        if (wParam > 0)
        {
            PLBIV plb = ListBox_GetPtr(pcbox->hwndList);

            pcbox->iMinVisible = (int)wParam;
            if (plb && !plb->fNoIntegralHeight)
            {
                // forward through to the listbox to let him adjust
                // his size if necessary
                SendMessage(pcbox->hwndList, uMsg, wParam, 0L);
            }

            lReturn = TRUE;
        }
        else
        {
            lReturn = FALSE;
        }

        break;

    case CB_GETMINVISIBLE:

        return pcbox->iMinVisible;

    case WM_MEASUREITEM:
    case WM_DELETEITEM:
    case WM_DRAWITEM:
    case WM_COMPAREITEM:
        return ComboBox_MessageItemHandler(pcbox, uMsg, (LPVOID)lParam);

    case WM_NCCREATE:
        //
        // wParam - Contains a handle to the window being created
        // lParam - Points to the CREATESTRUCT data structure for the window.
        //

        //
        // Allocate the combobox instance stucture
        //
        pcbox = (PCBOX)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(CBOX));
        if (pcbox)
        {
            //
            // Success... store the instance pointer.
            //
            TraceMsg(TF_STANDARD, "COMBOBOX: Setting combobox instance pointer.");
            ComboBox_SetPtr(hwnd, pcbox);

            return ComboBox_NcCreateHandler(pcbox, hwnd);
        }
        else
        {
            //
            // Failed... return FALSE.
            //
            // From a WM_NCCREATE msg, this will cause the
            // CreateWindow call to fail.
            //
            TraceMsg(TF_STANDARD, "COMBOBOX: Unable to allocate combobox instance structure.");
            lReturn = FALSE;
        }

        break;

    case WM_PARENTNOTIFY:
        if (LOWORD(wParam) == WM_DESTROY) 
        {
            if ((HWND)lParam == pcbox->hwndEdit) 
            {
                pcbox->CBoxStyle &= ~SEDITABLE;
                pcbox->fNoEdit = TRUE;
                pcbox->hwndEdit = hwnd;
            } 
            else if ((HWND)lParam == pcbox->hwndList) 
            {
                pcbox->CBoxStyle &= ~SDROPPABLE;
                pcbox->hwndList = NULL;
            }
        }
        break;

    case WM_UPDATEUISTATE:
        //
        // Propagate the change to the list control, if any
        //
        UserAssert(pcbox->hwndList);
        SendMessage(pcbox->hwndList, WM_UPDATEUISTATE, wParam, lParam);

        goto CallDWP;

    case WM_GETOBJECT:

        if(lParam == OBJID_QUERYCLASSNAMEIDX)
        {
            lReturn = MSAA_CLASSNAMEIDX_COMBOBOX;
        }
        else
        {
            lReturn = FALSE;
        }

        break;

    case WM_THEMECHANGED:

        if ( pcbox->hTheme )
        {
            CloseThemeData(pcbox->hTheme);
        }

        pcbox->hTheme = OpenThemeData(pcbox->hwnd, L"Combobox");

        ComboBox_Position(pcbox);
        InvalidateRect(pcbox->hwnd, NULL, TRUE);

        lReturn = TRUE;

        break;

    case WM_HELP:
    {
        LPHELPINFO lpHelpInfo;

        //
        // Check if this message is from a child of this combo
        //
        if ((lpHelpInfo = (LPHELPINFO)lParam) != NULL &&
            ((pcbox->hwndEdit && lpHelpInfo->iCtrlId == (SHORT)GetWindowID(pcbox->hwndEdit)) ||
             lpHelpInfo->iCtrlId == (SHORT)GetWindowID(pcbox->hwndList) )) 
        {
            //
            // Make it look like the WM_HELP is coming form this combo.
            // Then DefWindowProcWorker will pass it up to our parent,
            // who can do whatever he wants with it.
            //
            lpHelpInfo->iCtrlId = (SHORT)GetWindowID(hwnd);
            lpHelpInfo->hItemHandle = hwnd;
        }
        //
        // Fall through to DefWindowProc
        //
    }

    default:

        if ( (GetSystemMetrics(SM_PENWINDOWS)) &&
                  (uMsg >= WM_PENWINFIRST && uMsg <= WM_PENWINLAST))
        {
            goto CallEditSendMessage;
        }
        else
        {

CallDWP:
            lReturn = DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
    }

    return lReturn;

//
// The following forward messages off to the child controls.
//
CallEditSendMessage:
    if (!pcbox->fNoEdit && pcbox->hwndEdit) 
    {
        lReturn = SendMessage(pcbox->hwndEdit, uMsg, wParam, lParam);
    }
    else 
    {
        TraceMsg(TF_STANDARD, "COMBOBOX: Invalid combobox message %#.4x", uMsg);
        lReturn = CB_ERR;
    }
    return lReturn;

CallListSendMessage:
    UserAssert(pcbox->hwndList);
    lReturn = SendMessage(pcbox->hwndList, uMsg, wParam, lParam);

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\comboex.c ===
#include "ctlspriv.h"


#define EDIT_SELECTALL( hwnd )  Edit_SetSel(hwnd, 0, 0);  \
                                Edit_SetSel(hwnd, 0, -1);

const TCHAR c_szComboBox[] = TEXT("combobox");
const TCHAR c_szComboBoxEx[] = WC_COMBOBOXEX;

#ifdef DPITEST
#define ComboEx_IsDPIScaled() TRUE
#else
#define ComboEx_IsDPIScaled() (CCDPIScale(pce->ci))
#endif


#define COMBO_MARGIN        4
#define COMBO_WIDTH         g_cxSmIcon
#define COMBO_HEIGHT        g_cySmIcon
#define COMBO_BORDER        3

typedef struct {
    LPTSTR pszText;
    int iImage;
    int iSelectedImage;
    int iOverlay;
    int iIndent;
    LPARAM lParam;
} CEITEM, *PCEITEM;


typedef struct {
    CCONTROLINFO ci;
    HWND hwndCombo;
    HWND hwndEdit;
    DWORD dwExStyle;
    HIMAGELIST himl;
    HFONT hFont;
    int cxIndent;
    WPARAM iSel;
    CEITEM cei;
    BOOL fEditItemSet       :1;
    BOOL fEditChanged       :1;
    BOOL fFontCreated       :1;
    BOOL fInEndEdit         :1;
    BOOL fInDrop            :1;
} COMBOEX, *PCOMBOBOXEX;


void ComboEx_OnWindowPosChanging(PCOMBOBOXEX pce, LPWINDOWPOS pwp);
HFONT ComboEx_GetFont(PCOMBOBOXEX pce);
BOOL ComboEx_OnGetItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem);
int ComboEx_ComputeItemHeight(PCOMBOBOXEX pce, BOOL);
int ComboEx_OnFindStringExact(PCOMBOBOXEX pce, int iStart, LPCTSTR lpsz);
int WINAPI ShellEditWordBreakProc(LPTSTR lpch, int ichCurrent, int cch, int code);

LRESULT CALLBACK ComboSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
LRESULT CALLBACK EditSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
int ComboEx_StrCmp(PCOMBOBOXEX pce, LPCTSTR psz1, LPCTSTR psz2);

#define ComboEx_Editable(pce) (((pce)->ci.style & CBS_DROPDOWNLIST) == CBS_DROPDOWN)

void ComboEx_OnSetFont(PCOMBOBOXEX pce, HFONT hFont, BOOL fRedraw)
{
    int iHeight;
    HFONT hfontOld = NULL;

    if (pce->fFontCreated)
        hfontOld = ComboEx_GetFont(pce);

    if (!hFont) {
        LOGFONT lf;
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
        hFont = CreateFontIndirect(&lf);
        pce->fFontCreated = TRUE;
    } else {
        pce->fFontCreated = FALSE;
    }
    pce->ci.uiCodePage = GetCodePageForFont(hFont);

    SendMessage(pce->hwndCombo, WM_SETFONT, (WPARAM)hFont, fRedraw);
    if (pce->hwndEdit)
    {
        SendMessage(pce->hwndEdit, WM_SETFONT, (WPARAM)hFont, fRedraw);
        SendMessage(pce->hwndEdit, EM_SETMARGINS, EC_USEFONTINFO, 0L);
    }

    iHeight = ComboEx_ComputeItemHeight(pce, FALSE);
    SendMessage(pce->ci.hwnd, CB_SETITEMHEIGHT, (WPARAM)-1, (LPARAM)iHeight);
    SendMessage(pce->hwndCombo, CB_SETITEMHEIGHT, 0, (LPARAM)iHeight);

    // do this last so that we don't have a nuked font as we try to create the new one
    if (hfontOld)
        DeleteObject(hfontOld);
}


void ComboEx_OnDestroy(PCOMBOBOXEX pce)
{
    // don't need do destroy hwndCombo.. it will be destroyed along with us.
    SendMessage(pce->hwndCombo, CB_RESETCONTENT, 0, 0);
    // we may still have string allocated for the item in the edit box so free it
    if (pce->cei.pszText)
        Str_Set(&(pce->cei.pszText), NULL);
    if (pce->fFontCreated) {
        DeleteObject(ComboEx_GetFont(pce));
    }

    if (pce->hwndEdit)
        RemoveWindowSubclass(pce->hwndEdit,  EditSubclassProc,  0);

    if (pce->hwndCombo)
        RemoveWindowSubclass(pce->hwndCombo, ComboSubclassProc, 0);

    SetWindowPtr(pce->ci.hwnd, 0, 0);
    LocalFree(pce);
}

// this gets the client rect without the scrollbar part and the border
void ComboEx_GetComboClientRect(PCOMBOBOXEX pce, LPRECT lprc)
{
    GetClientRect(pce->hwndCombo, lprc);
    InflateRect(lprc, -g_cxEdge, -g_cyEdge);
    lprc->right -= g_cxScrollbar;
}

// returns the edit box (creating it if necessary) or NULL if the combo does
// not have an edit box
HWND ComboEx_GetEditBox(PCOMBOBOXEX pce)
{
    HFONT hfont;
    DWORD dwStyle;
    DWORD dwExStyle = 0;

    if (pce->hwndEdit)
        return(pce->hwndEdit);

    if (!ComboEx_Editable(pce))
        return(NULL);

    dwStyle = WS_VISIBLE | WS_CLIPSIBLINGS | WS_CHILD | ES_LEFT;

    if (pce->ci.style & CBS_AUTOHSCROLL)
    {
        dwStyle |= ES_AUTOHSCROLL;
    }

    if (pce->ci.style & CBS_OEMCONVERT)
    {
        dwStyle |= ES_OEMCONVERT;
    }

    dwExStyle = pce->ci.dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

    pce->hwndEdit = CreateWindowEx(dwExStyle, WC_EDIT, c_szNULL, dwStyle, 0, 0, 0, 0,
                                   pce->hwndCombo, IntToPtr_(HMENU, GetDlgCtrlID(pce->ci.hwnd)), HINST_THISDLL, 0);

    if (!pce->hwndEdit ||
        !SetWindowSubclass(pce->hwndEdit, EditSubclassProc, 0, (DWORD_PTR)pce))
    {
        return NULL;
    }

    // Override the edit's theme with combobox
    SetWindowTheme(pce->hwndEdit, L"Combobox", NULL);

    hfont = ComboEx_GetFont(pce);
    if (hfont)
        FORWARD_WM_SETFONT(pce->hwndEdit, hfont,
                           FALSE, SendMessage);

    return(pce->hwndEdit);
}

///
/// the edit box handling...
/*

 we want the edit box up on CBN_SETFOCUS and CBN_CLOSEUP
 remove it on CBN_DROPDOWN and on CBN_KILLFOCUS

 this assumes that CBN_SETFOCUS and CBN_KILLFOCUS will come before and after
 CBN_DROPDOWN and CBN_CLOSEUP respectively
 */

// Really a BOOL return value
LRESULT ComboEx_EndEdit(PCOMBOBOXEX pce, int iWhy)
{
    NMCBEENDEDIT    nm;
    LRESULT         fRet;

    if (!ComboEx_GetEditBox(pce))
        return(FALSE);

    pce->fInEndEdit = TRUE;

    GetWindowText(pce->hwndEdit, nm.szText, ARRAYSIZE(nm.szText));

    nm.fChanged = pce->fEditChanged;
    nm.iWhy = iWhy;

    nm.iNewSelection = ComboEx_OnFindStringExact(pce, ComboBox_GetCurSel(pce->hwndCombo) - 1, nm.szText);
    fRet = BOOLFROMPTR(CCSendNotify(&pce->ci, CBEN_ENDEDIT, &nm.hdr));

    pce->fInEndEdit = FALSE;

    if (!fRet) 
    {
        if (nm.iNewSelection != ComboBox_GetCurSel(pce->hwndCombo))
        {
            if (nm.iNewSelection != -1)
            {
                SendMessage(pce->ci.hwnd, CB_SETCURSEL, nm.iNewSelection, 0);
            }
            else
            {
                //if the selection is -1 and if we do a CB_SETCURSEL  on comboboxex then it nukes the text in
                //the edit window. Which is not the desired behavior. We need to update the Current Selection in the                 
                //child combobox but leave the text as it is.
                SendMessage(pce->hwndCombo, CB_SETCURSEL, nm.iNewSelection,0);
            }
        }
        pce->fEditChanged = FALSE;
    }
    InvalidateRect(pce->hwndCombo, NULL, FALSE);

    return(fRet);
}

void ComboEx_SizeEditBox(PCOMBOBOXEX pce)
{
    RECT rc;
    int cxIcon = 0, cyIcon = 0;

    ComboEx_GetComboClientRect(pce, &rc);
    InvalidateRect(pce->hwndCombo, &rc, TRUE); // erase so that the selection highlight is erased
    if (pce->himl && !(pce->dwExStyle & CBES_EX_NOEDITIMAGEINDENT))
    {
        // Make room for icons.
        CCGetIconSize(&pce->ci, pce->himl, &cxIcon, &cyIcon);

        if (cxIcon)
            cxIcon += COMBO_MARGIN;
    }

    // combobox edit field is one border in from the entire combobox client
    // rect -- thus add one border to edit control's left side
    rc.left += g_cxBorder + cxIcon;
    rc.bottom -= g_cyBorder;
    rc.top = rc.bottom - ComboEx_ComputeItemHeight(pce, TRUE) - g_cyBorder;
    SetWindowPos(pce->hwndEdit, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
                 SWP_NOACTIVATE | SWP_NOZORDER | SWP_SHOWWINDOW);

}

BOOL ComboEx_GetCurSelText(PCOMBOBOXEX pce, LPTSTR pszText, int cchText)
{

    COMBOBOXEXITEM cei;
    BOOL bRet = TRUE;

    cei.mask = CBEIF_TEXT;
    cei.pszText = pszText;
    cei.cchTextMax = cchText;
    cei.iItem = (INT)ComboBox_GetCurSel(pce->hwndCombo);
    
    if (cei.iItem == -1 ) 
    {
        pszText[0] = 0;
        bRet = FALSE;
    } 
    else 
    {
        ComboEx_OnGetItem(pce, &cei);
    }
    return bRet;
}

void ComboEx_UpdateEditText(PCOMBOBOXEX pce, BOOL fClearOnNoSel)
{
    if (!pce->fInEndEdit)
    {
        TCHAR szText[CBEMAXSTRLEN];

        HWND hwndEdit = ComboEx_Editable(pce) ? pce->hwndEdit : pce->hwndCombo;

        if (ComboEx_GetCurSelText(pce, szText, ARRAYSIZE(szText)) || fClearOnNoSel) {
            SendMessage(hwndEdit, WM_SETTEXT, 0, (LPARAM)szText);
            EDIT_SELECTALL( hwndEdit );
        }
    }
}

BOOL ComboEx_BeginEdit(PCOMBOBOXEX pce)
{
    if (!ComboEx_GetEditBox(pce))
        return(FALSE);

    SetFocus(pce->hwndEdit);
    return(TRUE);
}

BOOL ComboSubclass_HandleButton(PCOMBOBOXEX pce, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

    ComboEx_GetComboClientRect(pce, &rc);
    InflateRect(&rc, g_cxEdge, g_cyEdge);

    if (PtInRect(&rc, pt)) {

        //
        //  CheckForDragBegin yields, so we must revalidate on the way back.
        //
        HWND hwndCombo = pce->hwndCombo;
        if (CheckForDragBegin(pce->hwndCombo, LOWORD(lParam), HIWORD(lParam)))
        {
            NMCBEDRAGBEGIN  nmcbebd;
            LRESULT fRet;

            nmcbebd.iItemid = -1;
            GetWindowText(pce->hwndEdit, nmcbebd.szText, ARRAYSIZE(nmcbebd.szText));

            fRet = CCSendNotify(&pce->ci, CBEN_DRAGBEGIN, &nmcbebd.hdr);
            return TRUE;
        }
        // CheckForDragBegin yields, so revalidate before continuing
        else if (IsWindow(hwndCombo)) {

            if (uMsg == WM_LBUTTONDOWN)
            {
                // Post a fake WM_LBUTTONUP message because CheckForDragBegin may have
                // removed it from the combo's message queue but the combo expects to
                // get it.
                PostMessage(hwndCombo, WM_LBUTTONUP, 0, 0);
            }

            // a click on our border should start edit mode as well
            if (ComboEx_Editable(pce)) {
                if (!ComboEx_BeginEdit(pce))
                    SetFocus(pce->hwndCombo);
                return TRUE;
            }
            return FALSE;
        }
   }
   return FALSE;
}

BOOL ComboSubclass_HandleCommand(PCOMBOBOXEX pce, WPARAM wParam, LPARAM lParam)
{
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);
    HWND hwnd = GET_WM_COMMAND_HWND(wParam, lParam);

    switch (uCmd)
    {
        case EN_SETFOCUS:
            if (!pce->fInDrop)
            {
                EDIT_SELECTALL( pce->hwndEdit );
                CCSendNotify(&pce->ci, CBEN_BEGINEDIT, NULL);
                pce->fEditChanged = FALSE;
            }
            break;

        case EN_KILLFOCUS:
        {
            HWND hwndFocus;
            hwndFocus = GetFocus();
            if (hwndFocus != pce->hwndCombo)
            {
                ComboEx_EndEdit(pce, CBENF_KILLFOCUS);
                SendMessage(pce->hwndCombo, WM_KILLFOCUS, (WPARAM)hwndFocus, 0);
            }

            break;
        }

        case EN_CHANGE:
        {
            TCHAR szTextOrig[CBEMAXSTRLEN];
            TCHAR szTextNow[CBEMAXSTRLEN];
            WPARAM iItem;

            iItem = ComboBox_GetCurSel(pce->hwndCombo);

            if(iItem == -1)
            {
                if (pce->fEditItemSet && pce->cei.pszText) 
                {
                    Str_GetPtr(pce->cei.pszText, szTextOrig, ARRAYSIZE(szTextOrig));
                }
                else
                {
                    szTextOrig[0] = TEXT('\0');
                }
            }
            else 
            {
                ComboEx_GetCurSelText(pce,szTextOrig, ARRAYSIZE(szTextOrig));
            }

            GetWindowText(pce->hwndEdit, szTextNow, ARRAYSIZE(szTextNow));
            pce->fEditChanged = (ComboEx_StrCmp(pce, szTextOrig, szTextNow) != 0);
            SendMessage(pce->ci.hwndParent, WM_COMMAND,
                    GET_WM_COMMAND_MPS(idCmd, pce->ci.hwnd, CBN_EDITCHANGE));

            break;
        }
    }

    return(hwnd == pce->hwndEdit);
}

LRESULT CALLBACK EditSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    PCOMBOBOXEX pce = (PCOMBOBOXEX)dwRefData;

    if (uMsg == WM_SETFONT ||
        uMsg == WM_WININICHANGE) 
    {
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);

    }

    switch(uMsg) 
    {
    case WM_DESTROY:
        RemoveWindowSubclass(hwnd, EditSubclassProc, 0);
        break;

    case WM_CHAR:
        switch ((TCHAR)wParam) {
        case TEXT('\n'):
        case TEXT('\r'):
            // return... don't go to wndproc because
            // the edit control beeps on enter
            return 0;
        }
        break;

    case WM_SIZE:
        if (GetFocus() != hwnd) {
            Edit_SetSel(pce->hwndEdit, 0, 0);    // makesure everything is scrolled over first
        }
        break;

    case WM_KEYDOWN:
        switch(wParam) {
        case VK_RETURN:
            if (!ComboEx_EndEdit(pce, CBENF_RETURN))
                // we know we have an edit window, so FALSE return means
                // app returned FALSE to CBEN_ENDEDIT notification
                ComboEx_BeginEdit(pce);
            break;

        case VK_ESCAPE:
            pce->fEditChanged = FALSE;
            if (!ComboEx_EndEdit(pce, CBENF_ESCAPE)) {
                if(pce->fEditItemSet) {
                    if(pce->cei.pszText) {
                        SendMessage(pce->hwndEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)pce->cei.pszText);
                        EDIT_SELECTALL( pce->hwndEdit );
                    }
                    RedrawWindow(pce->hwndCombo, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
                }else {
                    ComboEx_BeginEdit(pce);
                }
            }
            break;

        // Pass these to the combobox itself to make it work properly...
        case VK_HOME:
        case VK_END:
            if (!pce->fInDrop)
                break;

        case VK_F4:
        case VK_UP:
        case VK_DOWN:
        case VK_PRIOR:
        case VK_NEXT:
            if (pce->hwndCombo)
                return SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
            break;
        }
        break;

    case WM_LBUTTONDOWN:
        if (GetFocus() != pce->hwndEdit)
        {
            SetFocus(pce->hwndEdit);
            // since we disabled autoselection on first click in address bar,
            // we should not eat this message. This allows the dragging to begin with
            // the first click.
            return(0L); // eat this message
        }
        break;

    case WM_SYSKEYDOWN:
        switch(wParam) {
        // Pass these to the combobox itself to make it work properly...
        case VK_UP:
        case VK_DOWN:
            {
                LRESULT lR;
                if (pce->hwndCombo)
                {
                    lR=SendMessage(pce->hwndCombo, uMsg, wParam, lParam);

                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(pce->ci), UISF_HIDEFOCUS);

                    return lR;
                }
            }
        }
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

LRESULT ComboEx_GetLBText(PCOMBOBOXEX pce, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DWORD cchResult = CB_ERR;
    TCHAR szText[CBEMAXSTRLEN];

    COMBOBOXEXITEM cei;
    cei.mask = CBEIF_TEXT;
    cei.pszText = szText;
    cei.cchTextMax = ARRAYSIZE(szText);
    cei.iItem = (INT)wParam;

    if (ComboEx_OnGetItem(pce, &cei))
    {
        cchResult = lstrlen(szText);

        if (lParam && uMsg == CB_GETLBTEXT)
        {
            // REVIEW: trusts that the lParam points to a buffer of sufficient
            // size to support the string and null terminator.
            StringCchCopy((LPTSTR)lParam, cchResult+1, szText);
        }
    }

    return cchResult;
}

LRESULT CALLBACK ComboSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    PCOMBOBOXEX pce = (PCOMBOBOXEX)dwRefData;

    switch (uMsg) 
    {
    case CB_GETLBTEXT:
    case CB_GETLBTEXTLEN:
        return ComboEx_GetLBText(pce, uMsg, wParam, lParam);

    case WM_RBUTTONDOWN:
    case WM_LBUTTONDOWN:
        if (ComboSubclass_HandleButton(pce, uMsg, wParam, lParam)) 
        {
            return 0;
        }
        break;

    case WM_PAINT:
        if (pce->hwndEdit)
        {
            RedrawWindow(pce->hwndEdit, NULL, NULL, RDW_INVALIDATE);
        }
        break;

    case WM_COMMAND:
        if (ComboSubclass_HandleCommand(pce, wParam, lParam))
        {
            return 0;
        }
        break;

    case WM_DESTROY:
        RemoveWindowSubclass(hwnd, ComboSubclassProc, 0);
        break;

    case WM_SETCURSOR:
        if (pce) 
        {
            NMMOUSE nm = {0};
            nm.dwHitInfo = lParam;
            if (CCSendNotify(&pce->ci, NM_SETCURSOR, &nm.hdr))
            {
                return 0;
            }
        }
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

BOOL ComboEx_OnCreate(HWND hwnd, LPCREATESTRUCT lpcs)
{
    PCOMBOBOXEX pce;
    DWORD dwStyle;
    DWORD dwExStyle = 0;

    pce = (PCOMBOBOXEX)LocalAlloc(LPTR, sizeof(COMBOEX));
    if (!pce)
        return FALSE;

    SetWindowPtr(hwnd, 0, pce);

    // force off borders off ourself
    lpcs->style &= ~(WS_BORDER | WS_VSCROLL | WS_HSCROLL | CBS_UPPERCASE | CBS_LOWERCASE);
    SetWindowLong(hwnd, GWL_STYLE, lpcs->style);
    CIInitialize(&pce->ci, hwnd, lpcs);

    // or in CBS_SIMPLE because we can never allow the sub combo box
    // to have just drop down.. it's either all simple or dropdownlist
    dwStyle = CBS_OWNERDRAWFIXED | CBS_SIMPLE | CBS_NOINTEGRALHEIGHT | WS_VISIBLE |WS_VSCROLL | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;

    dwStyle |= (lpcs->style & (CBS_DROPDOWNLIST | CBS_HASSTRINGS | WS_CHILD));

    if ((lpcs->style & CBS_DROPDOWNLIST) == CBS_SIMPLE)
        dwStyle |= (lpcs->style & (CBS_AUTOHSCROLL | CBS_OEMCONVERT | CBS_UPPERCASE | CBS_LOWERCASE));

    dwExStyle = lpcs->dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

    pce->hwndCombo = CreateWindowEx(dwExStyle, WC_COMBOBOX, lpcs->lpszName,
                                    dwStyle,
                                    0, 0, lpcs->cx, lpcs->cy,
                                    hwnd, lpcs->hMenu, lpcs->hInstance, 0);

    if (!pce->hwndCombo ||
        !SetWindowSubclass(pce->hwndCombo, ComboSubclassProc, 0, (DWORD_PTR)pce) ||
        (!ComboEx_GetEditBox(pce) && ComboEx_Editable(pce)))
    {
        ComboEx_OnDestroy(pce);
        return FALSE;
    }

    ComboEx_OnSetFont(pce, NULL, FALSE);
    pce->cxIndent = 10;
    pce->iSel = -1;

    ComboEx_OnWindowPosChanging(pce, NULL);
    return TRUE;
}


HIMAGELIST ComboEx_OnSetImageList(PCOMBOBOXEX pce, HIMAGELIST himl)
{
    int iHeight;
    HIMAGELIST himlOld = pce->himl;

    pce->himl = himl;

    iHeight = ComboEx_ComputeItemHeight(pce, FALSE);
    SendMessage(pce->ci.hwnd, CB_SETITEMHEIGHT, (WPARAM)-1, iHeight);
    SendMessage(pce->hwndCombo, CB_SETITEMHEIGHT, 0, iHeight);

    InvalidateRect(pce->hwndCombo, NULL, TRUE);

    if (pce->hwndEdit)
        ComboEx_SizeEditBox(pce);

    return himlOld;
}

void ComboEx_OnDrawItem(PCOMBOBOXEX pce, LPDRAWITEMSTRUCT pdis)
{
    HDC hdc = pdis->hDC;
    RECT rc = pdis->rcItem;
    TCHAR szText[CBEMAXSTRLEN];
    int offset = 0;
    int xString, yString, xCombo;
    int cxIcon = 0, cyIcon = 0;
    int iLen;
    BOOL fSelected = FALSE;
    SIZE sizeText;
    COMBOBOXEXITEM cei;
    BOOL fNoText = FALSE;
    BOOL fEnabled = IsWindowEnabled(pce->hwndCombo);
    BOOL fRTLReading = FALSE;
    UINT OldTextAlign;

    // Setup the dc before we use it.
    fRTLReading = GetWindowLong(pdis->hwndItem, GWL_EXSTYLE) & WS_EX_RTLREADING;
    if (fRTLReading) 
    {
        OldTextAlign = GetTextAlign(hdc);
        SetTextAlign(hdc, OldTextAlign|TA_RTLREADING);
    }

    rc.top += g_cyBorder;

    szText[0] = 0;
    if (pdis->itemID != -1)
    {
        cei.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_OVERLAY | CBEIF_SELECTEDIMAGE| CBEIF_INDENT;
        cei.pszText = szText;
        cei.cchTextMax = ARRAYSIZE(szText);
        cei.iItem = (INT)pdis->itemID;

        ComboEx_OnGetItem(pce, &cei);

        if (pce->iSel == (int)pdis->itemID ||
            ((pce->iSel == -1) && ((int)pdis->itemID == ComboBox_GetCurSel(pce->hwndCombo))))
            fSelected = TRUE;
    }
    else 
    {
        if (pce->fEditItemSet) 
        {
            cei.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_OVERLAY | CBEIF_SELECTEDIMAGE| CBEIF_INDENT;
            cei.pszText = szText;
            cei.cchTextMax = ARRAYSIZE(szText);
            cei.iItem = (INT)pdis->itemID;

            ComboEx_OnGetItem(pce, &cei);
        }
    }

    if (pce->himl && !(pce->dwExStyle & CBES_EX_NOEDITIMAGEINDENT))
    {
        CCGetIconSize(&pce->ci, pce->himl, &cxIcon, &cyIcon);

        if (cxIcon)
            cxIcon += COMBO_MARGIN;
    }

    // if we're not drawing the edit box, figure out how far to indent
    // over
    if (!(pdis->itemState & ODS_COMBOBOXEDIT))
    {
        offset = (pce->cxIndent * cei.iIndent) + COMBO_BORDER;
    }
    else
    {
        if (pce->hwndEdit)
            fNoText = TRUE;

        if (pce->dwExStyle & CBES_EX_NOEDITIMAGEINDENT)
            cxIcon = 0;
    }

    xCombo = rc.left + offset;
    rc.left = xString = xCombo + cxIcon;
    iLen = lstrlen(szText);
    GetTextExtentPoint(hdc, szText, iLen, &sizeText);

    rc.right = rc.left + sizeText.cx;
    rc.left--;
    rc.right++;

    if (pdis->itemAction != ODA_FOCUS)
    {
        int yMid;
        BOOL fTextHighlight = FALSE;;

        yMid = (rc.top + rc.bottom) / 2;
        // center the string within rc
        yString = yMid - (sizeText.cy/2);

        if (pdis->itemState & ODS_SELECTED) 
        {
            if (!(pdis->itemState & ODS_COMBOBOXEDIT) ||
                !ComboEx_Editable(pce)) 
            {
                fTextHighlight = TRUE;
            }
        }

        if ( !fEnabled ) {
            SetBkColor(hdc, g_clrBtnFace);
            SetTextColor(hdc, GetSysColor(COLOR_GRAYTEXT));
        } else {
            SetBkColor(hdc, GetSysColor(fTextHighlight ?
                            COLOR_HIGHLIGHT : COLOR_WINDOW));
            SetTextColor(hdc, GetSysColor(fTextHighlight ?
                            COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));
        }

        if ((pdis->itemState & ODS_COMBOBOXEDIT) &&
                (rc.right > pdis->rcItem.right))
        {
            // Need to clip as user does not!
            rc.right = pdis->rcItem.right;
        }

        if (!fNoText) {
            ExtTextOut(hdc, xString, yString, ETO_OPAQUE | ETO_CLIPPED, &rc, szText, iLen, NULL);
        }

        if (pce->himl && (pdis->itemID != -1 || pce->fEditItemSet) &&
            !((pce->dwExStyle & (CBES_EX_NOEDITIMAGE | CBES_EX_NOEDITIMAGEINDENT)) &&
              (pdis->itemState & ODS_COMBOBOXEDIT))) 
        {

            DWORD dwDrawFlags = ILD_NORMAL;
        
            if ((pdis->itemState & ODS_COMBOBOXEDIT) && !fEnabled) 
            {
                dwDrawFlags = ILD_TRANSPARENT;
            }

            if (pce->himl && (pdis->itemID != -1 || pce->fEditItemSet) &&
                !((pce->dwExStyle & (CBES_EX_NOEDITIMAGE | CBES_EX_NOEDITIMAGEINDENT))))
            {
                if (pdis->itemState & ODS_SELECTED)
                    dwDrawFlags |= ILD_SELECTED | ILD_FOCUS;

                if (ComboEx_IsDPIScaled())
                {
                    dwDrawFlags |= ILD_DPISCALE;
                }

                ImageList_Draw(pce->himl,
                               (fSelected) ? cei.iSelectedImage : cei.iImage,
                               hdc, xCombo, yMid - (cyIcon/2),
                               INDEXTOOVERLAYMASK(cei.iOverlay) | dwDrawFlags);
            }
        }
    }


    if ((pdis->itemAction == ODA_FOCUS ||
        (pdis->itemState & ODS_FOCUS)) && 
        !(CCGetUIState(&(pce->ci)) & UISF_HIDEFOCUS))
    {
        if (!fNoText) 
        {
            DrawFocusRect(hdc, &rc);
        }
    }

    // Restore the text align in the dc.
    if (fRTLReading) 
    {
        SetTextAlign(hdc, OldTextAlign);
    }
}

int ComboEx_ComputeItemHeight(PCOMBOBOXEX pce, BOOL fTextOnly)
{
    HDC hdc;
    HFONT hfontOld;
    int dyDriveItem;
    SIZE siz;

    hdc = GetDC(NULL);
    hfontOld = ComboEx_GetFont(pce);
    if (hfontOld)
        hfontOld = SelectObject(hdc, hfontOld);

    GetTextExtentPoint(hdc, TEXT("W"), 1, &siz);
    dyDriveItem = siz.cy;

    if (hfontOld)
        SelectObject(hdc, hfontOld);
    ReleaseDC(NULL, hdc);

    if (fTextOnly)
        return dyDriveItem;

    dyDriveItem += COMBO_BORDER;

    // now take into account the icon
    if (pce->himl) 
    {
        int cxIcon = 0, cyIcon = 0;
        CCGetIconSize(&pce->ci, pce->himl, &cxIcon, &cyIcon);

        if (dyDriveItem < cyIcon)
            dyDriveItem = cyIcon;
    }

    return dyDriveItem;
}

void ComboEx_OnMeasureItem(PCOMBOBOXEX pce, LPMEASUREITEMSTRUCT pmi)
{

    pmi->itemHeight = ComboEx_ComputeItemHeight(pce, FALSE);

}

void ComboEx_ISetItem(PCOMBOBOXEX pce, PCEITEM pcei, PCOMBOBOXEXITEM pceItem)
{
    if (pceItem->mask & CBEIF_INDENT)
        pcei->iIndent = pceItem->iIndent;
    if (pceItem->mask & CBEIF_IMAGE)
        pcei->iImage = pceItem->iImage;
    if (pceItem->mask & CBEIF_SELECTEDIMAGE)
        pcei->iSelectedImage = pceItem->iSelectedImage;
    if (pceItem->mask & CBEIF_OVERLAY)
        pcei->iOverlay = pceItem->iOverlay;

    if (pceItem->mask & CBEIF_TEXT) {
        Str_Set(&pcei->pszText, pceItem->pszText);
    }

    if (pceItem->mask & CBEIF_LPARAM) {
        pcei->lParam = pceItem->lParam;
    }

}

#define ComboEx_GetItemPtr(pce, iItem) \
        ((PCEITEM)SendMessage((pce)->hwndCombo, CB_GETITEMDATA, iItem, 0))
#define ComboEx_Count(pce) \
        ((int)SendMessage((pce)->hwndCombo, CB_GETCOUNT, 0, 0))


BOOL ComboEx_OnGetItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem)
{
    PCEITEM pcei;
    NMCOMBOBOXEX nm;

    if(pceItem->iItem != -1) {
        pcei = ComboEx_GetItemPtr(pce, pceItem->iItem);
    }
    else {
        pcei = &(pce->cei);
    }

    if ((!pcei) || (pcei == (PCEITEM)-1))
        return FALSE;

    nm.ceItem.mask = 0;

    if (pceItem->mask & CBEIF_TEXT) {

        if (pcei->pszText == LPSTR_TEXTCALLBACK) {
            nm.ceItem.mask |= CBEIF_TEXT;
        } 
        else 
        {
            if(pceItem->iItem != -1) 
            {
                Str_GetPtr(pcei->pszText, pceItem->pszText, pceItem->cchTextMax);
            }
            else if (pce->hwndEdit) 
            {
                SendMessage(pce->hwndEdit, WM_GETTEXT, (WPARAM)pceItem->cchTextMax, (LPARAM)pceItem->pszText);
            }
        }
    }

    if (pceItem->mask & CBEIF_IMAGE) {

        if (pcei->iImage == I_IMAGECALLBACK) {
            nm.ceItem.mask |= CBEIF_IMAGE;
        }
        pceItem->iImage = pcei->iImage;

    }

    if (pceItem->mask & CBEIF_SELECTEDIMAGE) {

        if (pcei->iSelectedImage == I_IMAGECALLBACK) {
            nm.ceItem.mask |= CBEIF_SELECTEDIMAGE;
        }
        pceItem->iSelectedImage = pcei->iSelectedImage;
    }

    if (pceItem->mask & CBEIF_OVERLAY) {

        if (pcei->iOverlay == I_IMAGECALLBACK) {
            nm.ceItem.mask |= CBEIF_OVERLAY;
        }
        pceItem->iOverlay = pcei->iOverlay;
    }

    if (pceItem->mask & CBEIF_INDENT) {

        if (pcei->iIndent == I_INDENTCALLBACK) {
            nm.ceItem.mask |= CBEIF_INDENT;
            pceItem->iIndent = 0;
        } else {
            pceItem->iIndent = pcei->iIndent;
        }
    }

    if (pceItem->mask & CBEIF_LPARAM) {
        pceItem->lParam = pcei->lParam;
    }



    // is there anything to call back for?
    if (nm.ceItem.mask) {
        UINT uMask = nm.ceItem.mask;

        nm.ceItem = *pceItem;
        nm.ceItem.lParam = pcei->lParam;
        nm.ceItem.mask = uMask;

        if ((nm.ceItem.mask & CBEIF_TEXT) &&
            nm.ceItem.cchTextMax) {
            // null terminate just in case they don't respond
            *nm.ceItem.pszText = 0;
        }

        CCSendNotify(&pce->ci, CBEN_GETDISPINFO, &nm.hdr);

        if (nm.ceItem.mask & CBEIF_INDENT)
            pceItem->iIndent = nm.ceItem.iIndent;
        if (nm.ceItem.mask & CBEIF_IMAGE)
            pceItem->iImage = nm.ceItem.iImage;
        if (nm.ceItem.mask & CBEIF_SELECTEDIMAGE)
            pceItem->iSelectedImage = nm.ceItem.iSelectedImage;
        if (nm.ceItem.mask & CBEIF_OVERLAY)
            pceItem->iOverlay = nm.ceItem.iOverlay;
        if (nm.ceItem.mask & CBEIF_TEXT)
            pceItem->pszText = CCReturnDispInfoText(nm.ceItem.pszText, pceItem->pszText, pceItem->cchTextMax);

        if (nm.ceItem.mask & CBEIF_DI_SETITEM) {

            ComboEx_ISetItem(pce, pcei, &nm.ceItem);
        }
    }
    return TRUE;

}

BOOL ComboEx_OnGetItemA(PCOMBOBOXEX pce, PCOMBOBOXEXITEMA pceItem)
{
    LPWSTR pwszText;
    LPSTR pszTextSave;
    BOOL fRet;

    if (!(pceItem->mask & CBEIF_TEXT)) {
        return ComboEx_OnGetItem(pce, (PCOMBOBOXEXITEM)pceItem);
    }

    pwszText = (LPWSTR)LocalAlloc(LPTR, (pceItem->cchTextMax+1)*sizeof(WCHAR));
    if (!pwszText)
        return FALSE;
    pszTextSave = pceItem->pszText;
    ((PCOMBOBOXEXITEM)pceItem)->pszText = pwszText;
    fRet = ComboEx_OnGetItem(pce, (PCOMBOBOXEXITEM)pceItem);
    pceItem->pszText = pszTextSave;

    if (fRet) 
    {
        // WCTMB failes w/ ERROR_INSUFFICIENT_BUFFER whereas the native-A implementation truncates
        WideCharToMultiByte(CP_ACP, 0, pwszText, -1,
                            (LPSTR)pszTextSave, pceItem->cchTextMax, NULL, NULL);
    }
    LocalFree(pwszText);
    return fRet;

}

BOOL ComboEx_OnSetItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem)
{
    if(pceItem->iItem != -1) {
        PCEITEM pcei = ComboEx_GetItemPtr(pce, pceItem->iItem);
        UINT rdwFlags = 0;

        if (pcei == (PCEITEM)-1)
            return FALSE;

        ComboEx_ISetItem(pce, pcei, pceItem);

        if (rdwFlags & (CBEIF_INDENT | CBEIF_IMAGE |CBEIF_SELECTEDIMAGE | CBEIF_TEXT | CBEIF_OVERLAY)) {
            rdwFlags = RDW_ERASE | RDW_INVALIDATE;
        }

        if (rdwFlags) 
        {
            RedrawWindow(pce->hwndCombo, NULL, NULL, rdwFlags);
        }

        if (pceItem->iItem == (INT)ComboBox_GetCurSel(pce->hwndCombo))
            ComboEx_UpdateEditText(pce, FALSE);
        // FEATURE: notify item changed
        return TRUE;

  } else {

        pce->cei.iImage = -1;
        pce->cei.iSelectedImage = -1;

        ComboEx_ISetItem(pce, &(pce->cei), pceItem);

        pce->fEditItemSet = TRUE;

        if (!pce->hwndEdit){
            Str_Set(&pce->cei.pszText, NULL);
            pce->fEditItemSet = FALSE;
            return(CB_ERR);
        }

        if(pce->cei.pszText) {
            SendMessage(pce->hwndEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)pce->cei.pszText);
            EDIT_SELECTALL( pce->hwndEdit );
        }
        RedrawWindow(pce->hwndCombo, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
        return TRUE;

   }
}

void ComboEx_HandleDeleteItem(PCOMBOBOXEX pce, LPDELETEITEMSTRUCT pdis)
{
    PCEITEM pcei = (PCEITEM)pdis->itemData;
    if (pcei) {
        NMCOMBOBOXEX nm;

        Str_Set(&pcei->pszText, NULL);

        nm.ceItem.iItem = (INT)pdis->itemID;
        nm.ceItem.mask = CBEIF_LPARAM;
        nm.ceItem.lParam = pcei->lParam;
        CCSendNotify(&pce->ci, CBEN_DELETEITEM, &nm.hdr);

        LocalFree(pcei);
    }
}

LRESULT ComboEx_OnInsertItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem)
{
    LRESULT iRet;
    PCEITEM pcei = (PCEITEM)LocalAlloc(LPTR, sizeof(CEITEM));

    if (!pcei)
        return -1;

    pcei->iImage = -1;
    pcei->iSelectedImage = -1;
    //pcei->iOverlay = 0;
    //pcei->iIndent = 0;

    ComboEx_ISetItem(pce, pcei, pceItem);

    iRet = ComboBox_InsertString(pce->hwndCombo, pceItem->iItem, pcei);
    if (iRet != -1) {
        NMCOMBOBOXEX nm;

        nm.ceItem = *pceItem;
        CCSendNotify(&pce->ci, CBEN_INSERTITEM, &nm.hdr);
    }
    return iRet;
}


void ComboEx_OnWindowPosChanging(PCOMBOBOXEX pce, LPWINDOWPOS pwp)
{
    RECT rcWindow, rcClient;
    RECT rc;
    int  cxInner;
    int cy;

    GetWindowRect(pce->ci.hwnd, &rcWindow);

    if (pwp) {
        // check to see if our size & position aren't actually changing (rebar, for one, 
        // does lots of DeferWindowPos calls that don't actually change our size or position
        // but still generate WM_WINDOWPOSCHANGING msgs).  we avoid flicker by bailing here.
        RECT rcWp;
        SetRect(&rcWp, pwp->x, pwp->y, pwp->x + pwp->cx, pwp->y + pwp->cy);
        MapWindowRect(GetParent(pce->ci.hwnd), HWND_DESKTOP, (LPPOINT)&rcWp);
        if (EqualRect(&rcWp, &rcWindow)) {
            // this is a noop, so bail
            return;
        }
    }

    GetClientRect(pce->ci.hwnd, &rcClient);

    if (pwp)
        cxInner = pwp->cx + RECTWIDTH(rcWindow) - RECTWIDTH(rcClient);
    else
        cxInner = RECTWIDTH(rcClient);

    GetWindowRect(pce->hwndCombo, &rc);
    if (cxInner) {

        // don't size the inner combo if width is 0; otherwise, the below
        // computation will make the comboEX the height of the inner combo
        // top + inner combo dropdown instead of JUST the inner combo top
        cy = (pwp && ((pce->ci.style & CBS_DROPDOWNLIST) == CBS_SIMPLE)) ?  pwp->cy : RECTHEIGHT(rc);

        SetWindowPos(pce->hwndCombo, NULL, 0, 0, cxInner, cy,
                                          SWP_NOACTIVATE | (pce->hwndEdit ? SWP_NOREDRAW : 0));
    }

    GetWindowRect(pce->hwndCombo, &rc);

    cy = RECTHEIGHT(rc) + (RECTHEIGHT(rcWindow) - RECTHEIGHT(rcClient));

    if (pwp) 
    {
        if (cy < pwp->cy || !(pce->dwExStyle & CBES_EX_NOSIZELIMIT)) 
        {
            pwp->cy = cy;
        }
    }
    else 
    {

        if (cy < RECTHEIGHT(rcWindow) || !(pce->dwExStyle & CBES_EX_NOSIZELIMIT)) 
        {
            SetWindowPos(pce->ci.hwnd, NULL, 0, 0,
                         RECTWIDTH(rcWindow),
                         cy,
                         SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
        }
    }

    if (pce->hwndEdit)
    {
        ComboEx_SizeEditBox(pce);
        InvalidateRect(pce->hwndCombo, NULL, TRUE);
    }
}

LRESULT ComboEx_HandleCommand(PCOMBOBOXEX pce, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);

    if (!pce)
        return 0;

    if (uCmd == CBN_SELCHANGE)
        // update the edit text before forwarding this notification 'cause in
        // a normal combobox, the edit control will have already been updated
        // upon receipt of this notification
        ComboEx_UpdateEditText(pce, FALSE);

    lres = SendMessage(pce->ci.hwndParent, WM_COMMAND, GET_WM_COMMAND_MPS(idCmd, pce->ci.hwnd, uCmd));

    switch (uCmd) 
    {

    case CBN_DROPDOWN:
        pce->iSel = ComboBox_GetCurSel(pce->hwndCombo);
        ComboEx_EndEdit(pce, CBENF_DROPDOWN);
        if (GetFocus() == pce->hwndEdit)
            SetFocus(pce->hwndCombo);
        pce->fInDrop = TRUE;
        break;

    case CBN_KILLFOCUS:
        ComboEx_EndEdit(pce, CBENF_KILLFOCUS);
        break;

    case CBN_CLOSEUP:
        pce->iSel = -1;
        ComboEx_BeginEdit(pce);
        pce->fInDrop = FALSE;
        break;

    case CBN_SETFOCUS:
        ComboEx_BeginEdit(pce);
        break;

    }

    return lres;
}

LRESULT ComboEx_OnGetItemData(PCOMBOBOXEX pce, WPARAM i)
{
    PCEITEM pcei = (PCEITEM)SendMessage(pce->hwndCombo, CB_GETITEMDATA, i, 0);
    if (pcei == NULL || pcei == (PCEITEM)CB_ERR) 
    {
        return CB_ERR;
    }

    return pcei->lParam;
}

LRESULT ComboEx_OnSetItemData(PCOMBOBOXEX pce, int i, LPARAM lParam)
{
    PCEITEM pcei = (PCEITEM)SendMessage(pce->hwndCombo, CB_GETITEMDATA, i, 0);
    if (pcei == NULL || pcei == (PCEITEM)CB_ERR) 
    {
        return CB_ERR;
    }
    pcei->lParam = lParam;
    return 0;
}

int ComboEx_OnFindStringExact(PCOMBOBOXEX pce, int iStart, LPCTSTR lpsz)
{
    int i;
    int iMax = ComboEx_Count(pce);
    TCHAR szText[CBEMAXSTRLEN];
    COMBOBOXEXITEM cei;

    if (iStart < 0)
        iStart = -1;

    cei.mask = CBEIF_TEXT;
    cei.pszText = szText;
    cei.cchTextMax = ARRAYSIZE(szText);

    for (i = iStart + 1 ; i < iMax; i++)
    {
        cei.iItem = i;
        if (ComboEx_OnGetItem(pce, &cei)) 
        {
            if (!ComboEx_StrCmp(pce, lpsz, szText)) 
            {
                return i;
            }
        }
    }

    for (i = 0; i <= iStart; i++)
    {
        cei.iItem = i;
        if (ComboEx_OnGetItem(pce, &cei))
        {
            if (!ComboEx_StrCmp(pce, lpsz, szText)) 
            {
                return i;
            }
        }
    }

    return CB_ERR;
}

int ComboEx_StrCmp(PCOMBOBOXEX pce, LPCTSTR psz1, LPCTSTR psz2)
{
    if (pce->dwExStyle & CBES_EX_CASESENSITIVE) 
    {
        return lstrcmp(psz1, psz2);
    }
    return lstrcmpi(psz1, psz2);
}

DWORD ComboEx_OnSetExStyle(PCOMBOBOXEX pce, DWORD dwExStyle, DWORD dwExMask)
{
    DWORD dwRet;
    DWORD dwChange;

    if (dwExMask)
        dwExStyle = (pce->dwExStyle & ~ dwExMask) | (dwExStyle & dwExMask);

    dwRet = pce->dwExStyle;
    dwChange = (pce->dwExStyle ^ dwExStyle);

    pce->dwExStyle = dwExStyle;
    if (dwChange & (CBES_EX_NOEDITIMAGE | CBES_EX_NOEDITIMAGEINDENT))
    {
        InvalidateRect(pce->ci.hwnd, NULL, TRUE);
        if (pce->hwndEdit)
        {
            ComboEx_SizeEditBox(pce);
            InvalidateRect(pce->hwndEdit, NULL, TRUE);
        }
    }

    if (dwChange & CBES_EX_PATHWORDBREAKPROC)
        SetPathWordBreakProc(pce->hwndEdit, (pce->dwExStyle & CBES_EX_PATHWORDBREAKPROC));

    return dwRet;
}

HFONT ComboEx_GetFont(PCOMBOBOXEX pce)
{
    if (pce->hwndCombo)
        return (HFONT)SendMessage(pce->hwndCombo, WM_GETFONT, 0, 0);

    return NULL;
}

LRESULT CALLBACK ComboExWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    PCOMBOBOXEX pce = (PCOMBOBOXEX)GetWindowPtr(hwnd, 0);

    if (!pce) 
    {
        if (uMsg != WM_NCCREATE &&
            uMsg != WM_CREATE)
            goto DoDefault;
    }

    switch (uMsg) 
    {
        HANDLE_MSG(pce, WM_SETFONT, ComboEx_OnSetFont);

    case WM_ENABLE:
        if (pce->hwndCombo)
            EnableWindow(pce->hwndCombo, (BOOL) wParam);
        if (pce->hwndEdit)
            EnableWindow(pce->hwndEdit, (BOOL) wParam);
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        // only need to re-create this font if we created it in the first place
        // and somebody changed the font (or did a wildcard change)
        //
        // NOTE: Some people broadcast a nonclient metrics change when they
        //       change the icon title logfont, so watch for both.
        //
        if (pce && pce->fFontCreated &&
            ((wParam == 0 && lParam == 0) ||
             wParam == SPI_SETICONTITLELOGFONT ||
             wParam == SPI_SETNONCLIENTMETRICS))
        {
            ComboEx_OnSetFont(pce, NULL, TRUE);
        }
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&pce->ci, lParam);
        break;

    case WM_NCCREATE:
        // strip off the scroll bits
        SetWindowBits(hwnd, GWL_STYLE, WS_BORDER | WS_VSCROLL | WS_HSCROLL, 0);
        goto DoDefault;

    case WM_CREATE:
        if (!ComboEx_OnCreate(hwnd, (LPCREATESTRUCT)lParam))
            lres = -1; // OnCreate falied. Fail WM_CREATE
        break;

    case WM_PRINTCLIENT:
        CCSendPrint(&pce->ci, (HDC)wParam);
        break;

    case WM_DESTROY:
        ASSERT(pce);
        ComboEx_OnDestroy(pce);
        break;

    case WM_WINDOWPOSCHANGING:
        ComboEx_OnWindowPosChanging(pce, (LPWINDOWPOS)lParam);
        break;

    case WM_DRAWITEM:
        ComboEx_OnDrawItem(pce, (LPDRAWITEMSTRUCT)lParam);
        break;

    case WM_MEASUREITEM:
        ComboEx_OnMeasureItem(pce, (LPMEASUREITEMSTRUCT)lParam);
        break;

    case WM_COMMAND:
        return ComboEx_HandleCommand(pce, wParam, lParam);

    case WM_GETFONT:
        return (LRESULT)ComboEx_GetFont(pce);

    case WM_SETFOCUS:
        if (pce->hwndCombo)
            SetFocus(pce->hwndCombo);
        break;

    case WM_DELETEITEM:
        ComboEx_HandleDeleteItem(pce, (LPDELETEITEMSTRUCT)lParam);
        return TRUE;

    case WM_UPDATEUISTATE:
        //not sure need to set bit, will probably not use it, on the other hand this
        //  is consistent with remaining of common controls and not very expensive
        CCOnUIState(&(pce->ci), WM_UPDATEUISTATE, wParam, lParam);

        goto DoDefault;

    // this is for backcompat only.
    case CBEM_SETEXSTYLE:
        return ComboEx_OnSetExStyle(pce, (DWORD)wParam, 0);
        
    case CBEM_SETEXTENDEDSTYLE:
        return ComboEx_OnSetExStyle(pce, (DWORD)lParam, (DWORD)wParam);

    case CBEM_GETEXTENDEDSTYLE:
        return pce->dwExStyle;

    case CBEM_GETCOMBOCONTROL:
        return (LRESULT)pce->hwndCombo;

    case CBEM_SETIMAGELIST:
        return (LRESULT)ComboEx_OnSetImageList(pce, (HIMAGELIST)lParam);

    case CBEM_GETIMAGELIST:
        return (LRESULT)pce->himl;

    case CBEM_GETITEMA:
        return ComboEx_OnGetItemA(pce, (PCOMBOBOXEXITEMA)lParam);

    case CBEM_GETITEM:
        return ComboEx_OnGetItem(pce, (PCOMBOBOXEXITEM)lParam);

    case CBEM_SETITEMA: 
        {
            LRESULT lResult;
            LPWSTR lpStrings;
            UINT   uiCount;
            LPSTR  lpAnsiString = (LPSTR) ((PCOMBOBOXEXITEM)lParam)->pszText;

           if ((((PCOMBOBOXEXITEM)lParam)->mask & CBEIF_TEXT) &&
               (((PCOMBOBOXEXITEM)lParam)->pszText != LPSTR_TEXTCALLBACK)) {

                uiCount = lstrlenA(lpAnsiString)+1;
                lpStrings = LocalAlloc(LPTR, (uiCount) * sizeof(TCHAR));

                if (!lpStrings)
                    return -1;

                MultiByteToWideChar(CP_ACP, 0, (LPCSTR) lpAnsiString, uiCount,
                                   lpStrings, uiCount);

                ((PCOMBOBOXEXITEMA)lParam)->pszText = (LPSTR)lpStrings;
                lResult = ComboEx_OnSetItem(pce, (PCOMBOBOXEXITEM)lParam);
                ((PCOMBOBOXEXITEMA)lParam)->pszText = lpAnsiString;
                LocalFree(lpStrings);

                return lResult;
            } else {
                return ComboEx_OnSetItem(pce, (PCOMBOBOXEXITEM)lParam);
            }
        }
    case CBEM_SETITEM:
        return ComboEx_OnSetItem(pce, (PCOMBOBOXEXITEM)lParam);

    case CBEM_INSERTITEMA: 
        {
            LRESULT lResult;
            LPWSTR lpStrings;
            UINT   uiCount;
            LPSTR  lpAnsiString = (LPSTR) ((PCOMBOBOXEXITEM)lParam)->pszText;

            if (!lpAnsiString || lpAnsiString == (LPSTR)LPSTR_TEXTCALLBACK)
                return ComboEx_OnInsertItem(pce, (PCOMBOBOXEXITEM)lParam);

            uiCount = lstrlenA(lpAnsiString)+1;
            lpStrings = LocalAlloc(LPTR, (uiCount) * sizeof(TCHAR));

            if (!lpStrings)
                return -1;

            MultiByteToWideChar(CP_ACP, 0, (LPCSTR) lpAnsiString, uiCount,
                               lpStrings, uiCount);

            ((PCOMBOBOXEXITEMA)lParam)->pszText = (LPSTR)lpStrings;
            lResult = ComboEx_OnInsertItem(pce, (PCOMBOBOXEXITEM)lParam);
            ((PCOMBOBOXEXITEMA)lParam)->pszText = lpAnsiString;
            LocalFree(lpStrings);

            return lResult;
        }

    case CBEM_INSERTITEM:
        return ComboEx_OnInsertItem(pce, (PCOMBOBOXEXITEM)lParam);



    case CBEM_GETEDITCONTROL:
        return (LRESULT)pce->hwndEdit;

    case CBEM_HASEDITCHANGED:
        return pce->fEditChanged;

    case CBEM_SETWINDOWTHEME:
        if (lParam)
        {
            SetWindowTheme(hwnd, (LPWSTR)lParam, NULL);
            if (pce->hwndCombo)
                SetWindowTheme(pce->hwndCombo, (LPWSTR)lParam, NULL);
            if (pce->hwndEdit)
                SetWindowTheme(pce->hwndEdit, (LPWSTR)lParam, NULL);
        }
        break;

    case CB_GETITEMDATA:
        return ComboEx_OnGetItemData(pce, (int)wParam);

    case CB_SETITEMDATA:
        return ComboEx_OnSetItemData(pce, (int)wParam, lParam);

    case CB_LIMITTEXT:
        if (ComboEx_GetEditBox(pce))
            Edit_LimitText(pce->hwndEdit, wParam);
        break;

    case CB_FINDSTRINGEXACT:
    {
        LPCTSTR psz = (LPCTSTR)lParam;
        return ComboEx_OnFindStringExact(pce, (int)wParam, psz);
    }

    case CB_SETITEMHEIGHT:
        lres = SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
        if (wParam == (WPARAM)-1) 
        {
            RECT rcWindow, rcClient;
            int cy;

            GetWindowRect(pce->hwndCombo, &rcWindow);
            cy = RECTHEIGHT(rcWindow);

            GetWindowRect(pce->ci.hwnd, &rcWindow);
            GetClientRect(pce->ci.hwnd, &rcClient);

            cy = cy + (RECTHEIGHT(rcWindow) - RECTHEIGHT(rcClient));

            SetWindowPos(pce->ci.hwnd, NULL, 0, 0,
                         RECTWIDTH(rcWindow),
                         cy,
                         SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
        }
        break;

    case CB_INSERTSTRING:
    case CB_ADDSTRING:
    case CB_SETEDITSEL:
    case CB_FINDSTRING:
    case CB_DIR:
        // override to do nothing
        break;

    case CB_SETCURSEL:
    case CB_RESETCONTENT:
    case CB_DELETESTRING:
        lres = SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
        ComboEx_UpdateEditText(pce, uMsg == CB_SETCURSEL);
        break;

    case WM_SETTEXT:
        if (!pce->hwndEdit)
            return(CB_ERR);
        
        lres = SendMessage(pce->hwndEdit, uMsg, wParam, lParam);
        EDIT_SELECTALL( pce->hwndEdit );
        RedrawWindow(pce->hwndCombo, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
        return(lres);

    case WM_CUT:
    case WM_COPY:
    case WM_PASTE:
    case WM_GETTEXT:
    case WM_GETTEXTLENGTH:
        if (!pce->hwndEdit)
            return 0;
        return(SendMessage(pce->hwndEdit, uMsg, wParam, lParam));

    case WM_SETREDRAW:
        if (pce->hwndEdit)
            SendMessage(pce->hwndEdit, uMsg, wParam, lParam);
        break;

    case CB_GETEDITSEL:
        if (pce->hwndEdit)
            return SendMessage(pce->hwndEdit, EM_GETSEL, wParam, lParam);
        // else fall through

    // Handle it being in a dialog...
    // May want to handle it differently when edit control has
    // focus...
    case WM_GETDLGCODE:
    case CB_SHOWDROPDOWN:
    case CB_SETEXTENDEDUI:
    case CB_GETEXTENDEDUI:
    case CB_GETDROPPEDSTATE:
    case CB_GETDROPPEDCONTROLRECT:
    case CB_GETCURSEL:
    case CB_GETCOUNT:
    case CB_SELECTSTRING:
    case CB_GETITEMHEIGHT:
    case CB_SETDROPPEDWIDTH:
        return SendMessage(pce->hwndCombo, uMsg, wParam, lParam);

    case CB_GETLBTEXT:
    case CB_GETLBTEXTLEN:
        return ComboEx_GetLBText(pce, uMsg, wParam, lParam);

    default:
        if (CCWndProc(&pce->ci, uMsg, wParam, lParam, &lres))
            return lres;

DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lres;
}


BOOL InitComboExClass(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = ComboExWndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = c_szComboBoxEx;
    wc.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1); // NULL;
    wc.style           = CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(PCOMBOBOXEX);
    wc.cbClsExtra      = 0;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}

//---------------------------------------------------------------------------
// SetPathWordBreakProc does special break processing for edit controls.
//
// The word break proc is called when ctrl-(left or right) arrow is pressed in the
// edit control.  Normal processing provided by USER breaks words at spaces or tabs,
// but for us it would be nice to break words at slashes, backslashes, & periods too
// since it may be common to have paths or url's typed in.
void WINAPI SetPathWordBreakProc(HWND hwndEdit, BOOL fSet)
{
   PROC lpfnOld;
    // Don't shaft folks who set their own break proc - leave it alone.
    lpfnOld = (FARPROC)SendMessage(hwndEdit, EM_GETWORDBREAKPROC, 0, 0L);

    if (fSet) 
    {
        if (!lpfnOld)
            SendMessage(hwndEdit, EM_SETWORDBREAKPROC, 0, (LPARAM)ShellEditWordBreakProc);
    }
    else
    {
        if (lpfnOld == (FARPROC)ShellEditWordBreakProc)
            SendMessage(hwndEdit, EM_SETWORDBREAKPROC, 0, 0L);
    }
}

BOOL IsDelimiter(TCHAR ch)
{
    return (ch == TEXT(' ')  ||
            ch == TEXT('\t') ||
            ch == TEXT('.')  ||
            ch == TEXT('/')  ||
            ch == TEXT('\\'));
}

int WINAPI ShellEditWordBreakProc(LPTSTR lpch, int ichCurrent, int cch, int code)
{
    LPTSTR lpchT = lpch + ichCurrent;
    int iIndex;
    BOOL fFoundNonDelimiter = FALSE;
    static BOOL fRight = FALSE;  // hack due to bug in USER

    switch (code)
    {
        case WB_ISDELIMITER:
            fRight = TRUE;
            // Simple case - is the current character a delimiter?
            iIndex = (int)IsDelimiter(*lpchT);
            break;

        case WB_LEFT:
            // Move to the left to find the first delimiter.  If we are
            // currently at a delimiter, then skip delimiters until we
            // find the first non-delimiter, then start from there.
            //
            // Special case for fRight - if we are currently at a delimiter
            // then just return the current word!
            while ((lpchT = CharPrev(lpch, lpchT)) != lpch) 
            {
                if (IsDelimiter(*lpchT))
                {
                    if (fRight || fFoundNonDelimiter)
                        break;
                } 
                else 
                {
                    fFoundNonDelimiter = TRUE;
                    fRight = FALSE;
                }
            }
            iIndex = (int) (lpchT - lpch);

            // We are currently pointing at the delimiter, next character
            // is the beginning of the next word.
            if (iIndex > 0 && iIndex < cch)
                iIndex++;

            break;

        case WB_RIGHT:
            fRight = FALSE;

            // If we are not at a delimiter, then skip to the right until
            // we find the first delimiter.  If we started at a delimiter, or
            // we have just finished scanning to the first delimiter, then
            // skip all delimiters until we find the first non delimiter.
            //
            // Careful - the string passed in to us may not be NULL terminated!
            fFoundNonDelimiter = !IsDelimiter(*lpchT);
            if (lpchT != (lpch + cch))
            {
                while ((lpchT = FastCharNext(lpchT)) != (lpch + cch))
                {
                    if (IsDelimiter(*lpchT)) 
                    {
                        fFoundNonDelimiter = FALSE;
                    } 
                    else
                    {
                        if (!fFoundNonDelimiter)
                            break;
                    }
                }
            }
            // We are currently pointing at the next word.
            iIndex = (int) (lpchT - lpch);
            break;
    }

    return iIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\comctl32.inc ===
#
#  Common settings for comctl32
#

# Turn structure validation ON in debug builds
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DVSTF
!endif

USE_MSVCRT      = 1

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

MSC_WARNING_LEVEL=/W4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\comboini.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "combo.h"


//---------------------------------------------------------------------------//
//
#define RECALC_CYDROP   -1

//---------------------------------------------------------------------------//
VOID ComboBox_CalcControlRects(PCBOX pcbox, LPRECT lprcList)
{
    CONST TCHAR szOneChar[] = TEXT("0");

    HDC hdc;
    HANDLE hOldFont = NULL;
    int dyEdit, dxEdit;
    MEASUREITEMSTRUCT mis;
    SIZE size;
    HWND hwnd = pcbox->hwnd;

    //
    // Determine height of the edit control.  We can use this info to center
    // the button with recpect to the edit/static text window.  For example
    // this will be useful if owner draw and this window is tall.
    //
    hdc = GetDC(hwnd);
    if (pcbox->hFont) 
    {
        hOldFont = SelectObject(hdc, pcbox->hFont);
    }

    //
    // Add on CYEDGE just for some extra space in the edit field/static item.
    // It's really only for static text items, but we want static & editable
    // controls to be the same height.
    //
    GetTextExtentPoint(hdc, szOneChar, 1, &size);
    dyEdit = size.cy + GetSystemMetrics(SM_CYEDGE);

    if (hOldFont) 
    {
        SelectObject(hdc, hOldFont);
    }

    ReleaseDC(hwnd, hdc);

    if (pcbox->OwnerDraw) 
    {
        //
        // This is an ownerdraw combo.  Have the owner tell us how tall this
        // item is.
        //
        int iOwnerDrawHeight;

        iOwnerDrawHeight = pcbox->editrc.bottom - pcbox->editrc.top;
        if (iOwnerDrawHeight)
        {
            dyEdit = iOwnerDrawHeight;
        } 
        else 
        {
            //
            // No height has been defined yet for the static text window.  Send
            // a measure item message to the parent
            //
            mis.CtlType = ODT_COMBOBOX;
            mis.CtlID = GetWindowID(pcbox->hwnd);
            mis.itemID = (UINT)-1;
            mis.itemHeight = dyEdit;
            mis.itemData = 0;

            SendMessage(pcbox->hwndParent, WM_MEASUREITEM, mis.CtlID, (LPARAM)&mis);

            dyEdit = mis.itemHeight;
        }
    }

    //
    // Set the initial width to be the combo box rect.  Later we will shorten it
    // if there is a dropdown button.
    //
    pcbox->cyCombo = 2*GetSystemMetrics(SM_CYFIXEDFRAME) + dyEdit;
    dxEdit = pcbox->cxCombo - (2 * GetSystemMetrics(SM_CXFIXEDFRAME));

    if (pcbox->cyDrop == RECALC_CYDROP)
    {
        RECT rcWindow;

        //
        // recompute the max height of the dropdown listbox -- full window
        // size MINUS edit/static height
        //
        GetWindowRect(pcbox->hwnd, &rcWindow);
        pcbox->cyDrop = max((rcWindow.bottom - rcWindow.top) - pcbox->cyCombo, 0);

        if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT) && (pcbox->cyDrop == 23))
        {
            //
            // This is VC++ 2.1's debug/release dropdown that they made super
            // small -- let's make 'em a wee bit bigger so the world can
            // continue to spin -- jeffbog -- 4/19/95 -- B#10029
            //
            pcbox->cyDrop = 28;
        }
    }

    //
    // Determine the rectangles for each of the windows...  1.  Pop down button 2.
    // Edit control or generic window for static text or ownerdraw...  3.  List
    // box
    //

    //
    // Is there a button?
    //
    if (pcbox->CBoxStyle & SDROPPABLE) 
    {
        INT  cxBorder, cyBorder;

        //
        // Determine button's rectangle.
        //

        if (pcbox->hTheme && SUCCEEDED(GetThemeInt(pcbox->hTheme, 0, CBXS_NORMAL, TMT_BORDERSIZE, &cxBorder))) 
        {
            cyBorder = cxBorder;
        }
        else
        {
            cxBorder = g_cxEdge;
            cyBorder = g_cyEdge;
        }

        pcbox->buttonrc.top = cyBorder;
        pcbox->buttonrc.bottom = pcbox->cyCombo - cyBorder;

        if (pcbox->fRightAlign) 
        {
            pcbox->buttonrc.left  = cxBorder;
            pcbox->buttonrc.right = pcbox->buttonrc.left + GetSystemMetrics(SM_CXVSCROLL);
        } 
        else 
        {
            pcbox->buttonrc.right = pcbox->cxCombo - cxBorder;
            pcbox->buttonrc.left  = pcbox->buttonrc.right - GetSystemMetrics(SM_CXVSCROLL);
        }

        //
        // Reduce the width of the edittext window to make room for the button.
        //
        dxEdit = max(dxEdit - GetSystemMetrics(SM_CXVSCROLL), 0);

    } 
    else 
    {
        //
        // No button so make the rectangle 0 so that a point in rect will always
        // return false.
        //
        SetRectEmpty(&pcbox->buttonrc);
    }

    //
    // So now, the edit rect is really the item area.
    // 
    pcbox->editrc.left      = GetSystemMetrics(SM_CXFIXEDFRAME);
    pcbox->editrc.right     = pcbox->editrc.left + dxEdit;
    pcbox->editrc.top       = GetSystemMetrics(SM_CYFIXEDFRAME);
    pcbox->editrc.bottom    = pcbox->editrc.top + dyEdit;

    //
    // Is there a right-aligned button?
    //
    if ((pcbox->CBoxStyle & SDROPPABLE) && (pcbox->fRightAlign)) 
    {
        pcbox->editrc.right = pcbox->cxCombo - GetSystemMetrics(SM_CXEDGE);
        pcbox->editrc.left  = pcbox->editrc.right - dxEdit;
    }

    lprcList->left          = 0;
    lprcList->top           = pcbox->cyCombo;
    lprcList->right         = max(pcbox->cxDrop, pcbox->cxCombo);
    lprcList->bottom        = pcbox->cyCombo + pcbox->cyDrop;
}


//---------------------------------------------------------------------------//
//
// ComboBox_SetDroppedSize()
//
// Compute the drop down window's width and max height
//
VOID ComboBox_SetDroppedSize(PCBOX pcbox, LPRECT lprc)
{
    pcbox->fLBoxVisible = TRUE;
    ComboBox_HideListBoxWindow(pcbox, FALSE, FALSE);

    MoveWindow(pcbox->hwndList, lprc->left, lprc->top,
        lprc->right - lprc->left, lprc->bottom - lprc->top, FALSE);
}


//---------------------------------------------------------------------------//
//
// ComboBox_NcCreateHandler
// 
// Allocates space for the CBOX structure and sets the window to point to it.
//
LONG ComboBox_NcCreateHandler(PCBOX pcbox, HWND hwnd)
{
    ULONG ulStyle;
    ULONG ulExStyle;
    ULONG ulMask;

    pcbox->hwnd = hwnd;
    pcbox->pww = (PWW)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);

    ulStyle   = GET_STYLE(pcbox);
    ulExStyle = GET_EXSTYLE(pcbox); 

    //
    // Save the style bits so that we have them when we create the client area
    // of the combo box window.
    //
    pcbox->styleSave = ulStyle & (WS_VSCROLL|WS_HSCROLL);

    if (!(ulStyle & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)))
    {
        //
        // Add in CBS_HASSTRINGS if the style is implied...
        //
        SetWindowState(hwnd, CBS_HASSTRINGS);
    }

    ClearWindowState(hwnd, WS_VSCROLL|WS_HSCROLL|WS_BORDER);

    //
    // If the window is 4.0 compatible or has a CLIENTEDGE, draw the combo
    // in 3D.  Otherwise, use a flat border.
    //
    if (TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT) || TESTFLAG(ulExStyle, WS_EX_CLIENTEDGE))
    {
        pcbox->f3DCombo = TRUE;
    }

    ulMask = WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE;
    if ( (ulExStyle & ulMask) != 0 ) 
    {
        SetWindowLong(hwnd, GWL_EXSTYLE, ulExStyle & (~ ulMask));
    }

    return (LONG)TRUE;
}


//---------------------------------------------------------------------------//
//
// ComboBox_CreateHandler
//
// Creates all the child controls within the combo box
// Returns -1 if error
//
LRESULT ComboBox_CreateHandler(PCBOX pcbox, HWND hwnd)
{
    RECT rcList;
    RECT rcWindow;

    HWND hwndList;
    HWND hwndEdit;

    ULONG ulStyle;
    ULONG ulExStyle;
    ULONG ulStyleT;

    pcbox->hwndParent = GetParent(hwnd);
    pcbox->hTheme = OpenThemeData(pcbox->hwnd, L"Combobox");

    //
    // Break out the style bits so that we will be able to create the listbox
    // and editcontrol windows.
    //
    ulStyle = GET_STYLE(pcbox);
    if ((ulStyle & CBS_DROPDOWNLIST) == CBS_DROPDOWNLIST)
    {
        pcbox->CBoxStyle = SDROPDOWNLIST;
        pcbox->fNoEdit = TRUE;
    } 
    else if ((ulStyle & CBS_DROPDOWN) == CBS_DROPDOWN)
    {
        pcbox->CBoxStyle = SDROPDOWN;
    }
    else
    {
        pcbox->CBoxStyle = SSIMPLE;
    }

    pcbox->fRtoLReading = TESTFLAG(GET_EXSTYLE(pcbox), WS_EX_RTLREADING);
    pcbox->fRightAlign  = TESTFLAG(GET_EXSTYLE(pcbox), WS_EX_RIGHT);

    if (ulStyle & CBS_UPPERCASE)
    {
        pcbox->fCase = UPPERCASE;
    }
    else if (ulStyle & CBS_LOWERCASE)
    {
        pcbox->fCase = LOWERCASE;
    }
    else
    {
        pcbox->fCase = 0;
    }

    //
    // Listbox item flags.
    //
    if (ulStyle & CBS_OWNERDRAWVARIABLE)
    {
        pcbox->OwnerDraw = OWNERDRAWVAR;
    }

    if (ulStyle & CBS_OWNERDRAWFIXED)
    {
        pcbox->OwnerDraw = OWNERDRAWFIXED;
    }

    //
    // Get the size of the combo box rectangle.
    //
    // Get control sizes.
    GetWindowRect(hwnd, &rcWindow);
    pcbox->cxCombo = rcWindow.right - rcWindow.left;
    pcbox->cyDrop  = RECALC_CYDROP;
    pcbox->cxDrop  = 0;
    ComboBox_CalcControlRects(pcbox, &rcList);

    //
    // We need to do this because listboxes, as of VER40, have stopped
    // reinflating themselves by CXBORDER and CYBORDER.
    //
    if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT))
    {
        InflateRect(&rcList, -GetSystemMetrics(SM_CXBORDER), -GetSystemMetrics(SM_CYBORDER));
    }

    //
    // Note that we have to create the listbox before the editcontrol since the
    // editcontrol code looks for and saves away the listbox pwnd and the
    // listbox pwnd will be NULL if we don't create it first.  Also, hack in
    // some special +/- values for the listbox size due to the way we create
    // listboxes with borders.
    //
    ulStyleT = pcbox->styleSave;

    ulStyleT |= WS_CHILD | WS_VISIBLE | LBS_NOTIFY | LBS_COMBOBOX | WS_CLIPSIBLINGS;

    if (ulStyle & WS_DISABLED)
    {
        ulStyleT |= WS_DISABLED;
    }

    if (ulStyle & CBS_NOINTEGRALHEIGHT)
    {
        ulStyleT |= LBS_NOINTEGRALHEIGHT;
    }

    if (ulStyle & CBS_SORT)
    {
        ulStyleT |= LBS_SORT;
    }

    if (ulStyle & CBS_HASSTRINGS)
    {
        ulStyleT |= LBS_HASSTRINGS;
    }

    if (ulStyle & CBS_DISABLENOSCROLL)
    {
        ulStyleT |= LBS_DISABLENOSCROLL;
    }

    if (pcbox->OwnerDraw == OWNERDRAWVAR)
    {
        ulStyleT |= LBS_OWNERDRAWVARIABLE;
    }
    else if (pcbox->OwnerDraw == OWNERDRAWFIXED)
    {
        ulStyleT |= LBS_OWNERDRAWFIXED;
    }

    if (pcbox->CBoxStyle & SDROPPABLE)
    {
        ulStyleT |= WS_BORDER;
    }

    ulExStyle = GET_EXSTYLE(pcbox) & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

    hwndList = CreateWindowEx(
                ulExStyle | ((pcbox->CBoxStyle & SDROPPABLE) ? WS_EX_TOOLWINDOW : WS_EX_CLIENTEDGE),
                WC_COMBOLBOX, 
                NULL, 
                ulStyleT,
                rcList.left, 
                rcList.top, 
                rcList.right - rcList.left,
                rcList.bottom - rcList.top,
                hwnd, 
                (HMENU)CBLISTBOXID, 
                GetWindowInstance(hwnd),
                NULL);

    pcbox->hwndList = hwndList;

    if (!pcbox->hwndList) 
    {
        return -1;
    }

    //
    // Override the listbox's theme with combobox
    //
    SetWindowTheme(pcbox->hwndList, L"Combobox", NULL);

    //
    // Create either the edit control or the static text rectangle.
    //
    if (pcbox->fNoEdit) 
    {
        //
        // No editcontrol so we will draw text directly into the combo box
        // window.
        //
        // Don't lock the combobox window: this would prevent WM_FINALDESTROY
        // being sent to it, so pwnd and pcbox wouldn't get freed (zombies)
        // until thread cleanup. (IanJa)  LATER: change name from spwnd to pwnd.
        // Lock(&(pcbox->spwndEdit), pcbox->spwnd); - caused a 'catch-22'
        //
        pcbox->hwndEdit = pcbox->hwnd;
    } 
    else 
    {
        ulStyleT = WS_CHILD | WS_VISIBLE | ES_COMBOBOX | ES_NOHIDESEL;

        if (ulStyle & WS_DISABLED)
        {
            ulStyleT |= WS_DISABLED;
        }

        if (ulStyle & CBS_AUTOHSCROLL)
        {
            ulStyleT |= ES_AUTOHSCROLL;
        }

        if (ulStyle & CBS_OEMCONVERT)
        {
            ulStyleT |= ES_OEMCONVERT;
        }

        if (pcbox->fCase)
        {
            ulStyleT |= (pcbox->fCase & UPPERCASE) ? ES_UPPERCASE : ES_LOWERCASE;
        }

        //
        // Edit control need to know whether original CreateWindow*() call
        // was ANSI or Unicode.
        //
        if (ulExStyle & WS_EX_RIGHT)
        {
            ulStyleT |= ES_RIGHT;
        }

        hwndEdit = CreateWindowEx(
                    ulExStyle,
                    WC_EDIT, 
                    NULL, 
                    ulStyleT,
                    pcbox->editrc.left, 
                    pcbox->editrc.top,
                    pcbox->editrc.right - pcbox->editrc.left, 
                    pcbox->editrc.bottom - pcbox->editrc.top, 
                    hwnd, 
                    (HMENU)CBEDITID,
                    GetWindowInstance(hwnd),
                    NULL);

        pcbox->hwndEdit = hwndEdit;

        //
        // Override the edit's theme with combobox
        //
        SetWindowTheme(pcbox->hwndEdit, L"Combobox", NULL);

    }

    if (!pcbox->hwndEdit)
    {
        return -1L;
    }

    pcbox->iMinVisible = DEFAULT_MINVISIBLE;

    if (pcbox->CBoxStyle & SDROPPABLE) 
    {
        ShowWindow(hwndList, SW_HIDE);
        SetParent(hwndList, NULL);

        //
        // We need to do this so dropped size works right
        //
        if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT))
        {
            InflateRect(&rcList, GetSystemMetrics(SM_CXBORDER), GetSystemMetrics(SM_CYBORDER));
        }

        ComboBox_SetDroppedSize(pcbox, &rcList);
    }

    //
    // return anything as long as it's not -1L (-1L == error)
    //
    return (LRESULT)hwnd;
}



//---------------------------------------------------------------------------//
//
// ComboBox_NcDestroyHandler
//
// Destroys the combobox and frees up all memory used by it
//
VOID ComboBox_NcDestroyHandler(HWND hwnd, PCBOX pcbox)
{
    //
    // If there is no pcbox, there is nothing to clean up.
    //
    if (pcbox != NULL) 
    {
        //
        // Destroy the list box here so that it'll send WM_DELETEITEM messages
        // before the combo box turns into a zombie.
        //
        if (pcbox->hwndList != NULL) 
        {
            DestroyWindow(pcbox->hwndList);
            pcbox->hwndList = NULL;
        }

        pcbox->hwnd = NULL;
        pcbox->hwndParent = NULL;

        //
        // If there is no editcontrol, spwndEdit is the combobox window which
        // isn't locked (that would have caused a 'catch-22').
        //
        if (hwnd != pcbox->hwndEdit) 
        {
            pcbox->hwndEdit = NULL;
        }

        if (pcbox->hTheme != NULL)
        {
            CloseThemeData(pcbox->hTheme);
        }

        //
        // free the combobox instance structure
        //
        UserLocalFree(pcbox);
    }

    TraceMsg(TF_STANDARD, "COMBOBOX: Clearing combobox instance pointer.");
    ComboBox_SetPtr(hwnd, NULL);
}


//---------------------------------------------------------------------------//
VOID ComboBox_SetFontHandler(PCBOX pcbox, HANDLE hFont, BOOL fRedraw)
{
    pcbox->hFont = hFont;

    if (!pcbox->fNoEdit && pcbox->hwndEdit) 
    {
        SendMessage(pcbox->hwndEdit, WM_SETFONT, (WPARAM)hFont, FALSE);
    }

    SendMessage(pcbox->hwndList, WM_SETFONT, (WPARAM)hFont, FALSE);

    //
    // Recalculate the layout of controls.  This will hide the listbox also.
    //
    ComboBox_Position(pcbox);

    if (fRedraw) 
    {
        InvalidateRect(pcbox->hwnd, NULL, TRUE);
    }
}


//---------------------------------------------------------------------------//
//
// ComboBox_SetEditItemHeight
//
// Sets the height of the edit/static item of a combo box.
//
LONG ComboBox_SetEditItemHeight(PCBOX pcbox, int dyEdit)
{
    if (dyEdit > 255) 
    {
        TraceMsg(TF_STANDARD, "CCCombobox: CBSetEditItmeHeight: Invalid Parameter dwEdit = %d", dyEdit);
        return CB_ERR;
    }

    pcbox->editrc.bottom = pcbox->editrc.top + dyEdit;
    pcbox->cyCombo = pcbox->editrc.bottom + GetSystemMetrics(SM_CYFIXEDFRAME);

    if (pcbox->CBoxStyle & SDROPPABLE) 
    {
        int cyBorder = g_cyEdge;

        if ( pcbox->hTheme )
        {
            GetThemeInt(pcbox->hTheme, 0, CBXS_NORMAL, TMT_BORDERSIZE, &cyBorder);
        }

        pcbox->buttonrc.bottom = pcbox->cyCombo - cyBorder;
    }

    //
    // Reposition the editfield.
    // Don't let spwndEdit or List of NULL go through; if someone adjusts
    // the height on a NCCREATE; same as not having
    // HW instead of HWq but we don't go to the kernel.
    //
    if (!pcbox->fNoEdit && pcbox->hwndEdit) 
    {
        MoveWindow(pcbox->hwndEdit, pcbox->editrc.left, pcbox->editrc.top,
            pcbox->editrc.right-pcbox->editrc.left, dyEdit, TRUE);
    }

    //
    // Reposition the list and combobox windows.
    //
    if (pcbox->CBoxStyle == SSIMPLE) 
    {
        if (pcbox->hwndList != 0) 
        {
            RECT rcList;

            MoveWindow(pcbox->hwndList, 0, pcbox->cyCombo, pcbox->cxCombo,
                pcbox->cyDrop, FALSE);

            GetWindowRect(pcbox->hwndList, &rcList);
            SetWindowPos(pcbox->hwnd, HWND_TOP, 0, 0,
                pcbox->cxCombo, pcbox->cyCombo +
                rcList.bottom - rcList.top,
                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
    } 
    else 
    {
         RECT rcWindow;

        GetWindowRect(pcbox->hwnd, &rcWindow);
        if (pcbox->hwndList != NULL) 
        {
            MoveWindow(pcbox->hwndList, rcWindow.left,
                rcWindow.top + pcbox->cyCombo,
                max(pcbox->cxDrop, pcbox->cxCombo), pcbox->cyDrop, FALSE);
        }

        SetWindowPos(pcbox->hwnd, HWND_TOP, 0, 0,
            pcbox->cxCombo, pcbox->cyCombo,
            SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    return CB_OKAY;
}


//---------------------------------------------------------------------------//
//
// ComboBox_SizeHandler
//
// Recalculates the sizes of the internal controls in response to a
// resizing of the combo box window.  The app must size the combo box to its
// maximum open/dropped down size.
//
VOID ComboBox_SizeHandler(PCBOX pcbox)
{
    RECT rcWindow;

    //
    // Assume listbox is visible since the app should size it to its maximum
    // visible size.
    //
    GetWindowRect(pcbox->hwnd, &rcWindow);
    pcbox->cxCombo = RECTWIDTH(rcWindow);

    if (RECTHEIGHT(rcWindow) > pcbox->cyCombo)
    {
        pcbox->cyDrop = RECALC_CYDROP;
    }

    //
    // Reposition everything.
    //
    ComboBox_Position(pcbox);
}


//---------------------------------------------------------------------------//
//
// ComboBox_Position()
//
// Repositions components of edit control.
//
VOID ComboBox_Position(PCBOX pcbox)
{
    RECT rcList;

    //
    // Calculate placement of components--button, item, list
    //
    ComboBox_CalcControlRects(pcbox, &rcList);

    if (!pcbox->fNoEdit && pcbox->hwndEdit) 
    {
        MoveWindow(pcbox->hwndEdit, pcbox->editrc.left, pcbox->editrc.top,
            pcbox->editrc.right - pcbox->editrc.left,
            pcbox->editrc.bottom - pcbox->editrc.top, TRUE);
    }

    //
    // Recalculate drop height & width
    //
    ComboBox_SetDroppedSize(pcbox, &rcList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\crtfree.cpp ===
#include <windows.h>

// do this so that we can override new with an allocator that zero-inits
#define CPP_FUNCTIONS
#include <crtfree.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\commctrl.c ===
/***************************************************************************
 *  msctls.c
 *
 *      Utils library initialization code
 *
 ***************************************************************************/

#include "ctlspriv.h"
#include <shfusion.h>
HINSTANCE g_hinst = 0;


BOOL g_fCriticalInitialized = FALSE;

CRITICAL_SECTION g_csDll = {{0},0, 0, NULL, NULL, 0 };

ATOM g_aCC32Subclass = 0;
ATOM g_atomThemeScrollBar = 0;

UINT g_uiACP = CP_ACP;

//
// Global DCs used during mirroring an Icon.
//
HDC g_hdc     = NULL;
HDC g_hdcMask = NULL;

// per process mem to store PlugUI information
LANGID g_PUILangId = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

BOOL InitAnimateClass(HINSTANCE hInstance);
BOOL ListView_Init(HINSTANCE hinst);
BOOL TV_Init(HINSTANCE hinst);
BOOL InitComboExClass(HINSTANCE hinst);
BOOL Header_Init(HINSTANCE hinst);
BOOL Tab_Init(HINSTANCE hinst);
int  InitIPAddr(HANDLE hInstance);
BOOL InitPager(HINSTANCE hinst);
BOOL InitNativeFontCtl(HINSTANCE hinst);
void UnregisterClasses();
void Mem_Terminate();


// IMM initialize state 
BOOL g_fDBCSEnabled      = FALSE;
BOOL g_fMEEnabled        = FALSE;
BOOL g_fDBCSInputEnabled = FALSE;
BOOL g_fIMMEnabled       = FALSE;

void InitIme()
{
    g_fMEEnabled = GetSystemMetrics(SM_MIDEASTENABLED);
    
    g_fDBCSEnabled = g_fDBCSInputEnabled = GetSystemMetrics(SM_DBCSENABLED);
    g_fIMMEnabled = GetSystemMetrics(SM_IMMENABLED);

    if (!g_fDBCSInputEnabled)
    {
        g_fDBCSInputEnabled = g_fIMMEnabled;
    }
}


#ifdef DEBUG

// Verify that the localizers didn't accidentally change
// DLG_PROPSHEET from a DIALOG to a DIALOGEX.  _RealPropertySheet
// relies on this (as well as any apps which parse the dialog template
// in their PSCB_PRECREATE handler).

BOOL IsSimpleDialog(LPCTSTR ptszDialog)
{
    HRSRC hrsrc;
    LPDLGTEMPLATE pdlg;
    BOOL fSimple = FALSE;

    if ( (hrsrc = FindResource(HINST_THISDLL, ptszDialog, RT_DIALOG)) &&
         (pdlg = LoadResource(HINST_THISDLL, hrsrc)))
    {
        fSimple = HIWORD(pdlg->style) != 0xFFFF;
    }
    return fSimple;
}

//
//  For sublanguages to work, every language in our resources must contain
//  a SUBLANG_NEUTRAL variation so that (for example) Austria gets
//  German dialog boxes instead of English ones.
//
//  The DPA is really a DSA of WORDs, but DPA's are easier to deal with.
//  We just collect all the languages into the DPA, and study them afterwards.
//
BOOL CALLBACK CheckLangProc(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName, WORD wIdLang, LPARAM lparam)
{
    HDPA hdpa = (HDPA)lparam;
    DPA_AppendPtr(hdpa, (LPVOID)(UINT_PTR)wIdLang);
    return TRUE;
}

void CheckResourceLanguages(void)
{
    HDPA hdpa = DPA_Create(8);
    if (hdpa) {
        int i, j;
        EnumResourceLanguages(HINST_THISDLL, RT_DIALOG,
                              MAKEINTRESOURCE(DLG_PROPSHEET), CheckLangProc,
                              (LPARAM)hdpa);

        // Walk the language list.  For each language we find, make sure
        // there is a SUBLANG_NEUTRAL version of it somewhere else
        // in the list.  We use an O(n^2) algorithm because this is debug
        // only code and happens only at DLL load.

        for (i = 0; i < DPA_GetPtrCount(hdpa); i++) {
            UINT_PTR uLangI = (UINT_PTR)DPA_FastGetPtr(hdpa, i);
            BOOL fFound = FALSE;

            //
            //  It is okay to have English (American) with no
            //  English (Neutral) because Kernel32 uses English (American)
            //  as its fallback, so we fall back to the correct language
            //  after all.
            //
            if (uLangI == MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
                continue;

            //
            //  If this language is already the Neutral one, then there's
            //  no point looking for it - here it is!
            //
            if (SUBLANGID(uLangI) == SUBLANG_NEUTRAL)
                continue;

            //
            //  Otherwise, this language is a dialect.  See if there is
            //  a Neutral version elsewhere in the table.
            //
            for (j = 0; j < DPA_GetPtrCount(hdpa); j++) {
                UINT_PTR uLangJ = (UINT_PTR)DPA_FastGetPtr(hdpa, j);
                if (PRIMARYLANGID(uLangI) == PRIMARYLANGID(uLangJ) &&
                    SUBLANGID(uLangJ) == SUBLANG_NEUTRAL) {
                    fFound = TRUE; break;
                }
            }

            //
            //  If this assertion fires, it means that the localization team
            //  added support for a new language but chose to specify the
            //  language as a dialect instead of the Neutral version.  E.g.,
            //  specifying Romanian (Romanian) instead of Romanian (Neutral).
            //  This means that people who live in Moldavia will see English
            //  strings, even though Romanian (Romanian) would almost
            //  certainly have been acceptable.
            //
            //  If you want to support multiple dialects of a language
            //  (e.g., Chinese), you should nominate one of the dialects
            //  as the Neutral one.  For example, we currently support
            //  both Chinese (PRC) and Chinese (Taiwan), but the Taiwanese
            //  version is marked as Chinese (Neutral), so people who live in
            //  Singapore get Chinese instead of English.  Sure, it's
            //  Taiwanese Chinese, but at least it's Chinese.
            //
            AssertMsg(fFound, TEXT("Localization bug: No SUBLANG_NEUTRAL for language %04x"), uLangI);
        }

        DPA_Destroy(hdpa);
    }
}

#endif

BOOL IsRunningIn16BitProcess()
{
    NTSTATUS status;
    ULONG    ulVDMFlags = 0;
    status = NtQueryInformationProcess(GetCurrentProcess(), ProcessWx86Information, &ulVDMFlags, sizeof(ulVDMFlags), NULL);
    return (NT_SUCCESS(status) && (ulVDMFlags != 0));
}


int _ProcessAttach(HANDLE hInstance)
{
    g_hinst = hInstance;

    g_uiACP = GetACP();
    g_atomThemeScrollBar = GlobalAddAtom(TEXT("ThemePropScrollBarCtl"));

    SHFusionInitialize(NULL);

#ifdef DEBUG
    CcshellGetDebugFlags();
#endif

    g_fCriticalInitialized = InitializeCriticalSectionAndSpinCount(&g_csDll, 0);

    InitGlobalMetrics(0);
    InitGlobalColors();
    
    InitIme();

    //
    // Initialize special language pack callouts for
    // the edit controls. Once per process.
    //
    InitEditLpk();

    if (IsRunningIn16BitProcess())
    {
        // This is a 16bit process. We need to artificially init the common controls
        INITCOMMONCONTROLSEX icce;
        icce.dwSize = sizeof(icce);
        icce.dwICC = ICC_ALL_CLASSES & ~ICC_STANDARD_CLASSES;
        InitCommonControlsEx(&icce);
    }

    return TRUE;
}



void _ProcessDetach(HANDLE hInstance)
{
    //
    // Cleanup cached DCs. No need to synchronize the following section of
    // code since it is only called in DLL_PROCESS_DETACH which is 
    // synchronized by the OS Loader.
    //
    if (g_hdc)
        DeleteDC(g_hdc);

    if (g_hdcMask)
        DeleteDC(g_hdcMask);

    g_hdc = g_hdcMask = NULL;

    UnregisterClasses();
    g_fCriticalInitialized = FALSE;
    DeleteCriticalSection(&g_csDll);
    SHFusionUninitialize();
}


STDAPI_(BOOL) LibMain(HANDLE hDll, DWORD dwReason, LPVOID pv)
{
    switch(dwReason) 
    {
    case DLL_PROCESS_ATTACH:
#ifdef DEBUG
        GdiSetBatchLimit(1);
#else
        DisableThreadLibraryCalls(hDll);
#endif
        return _ProcessAttach(hDll);

    case DLL_PROCESS_DETACH:
        _ProcessDetach(hDll);
        break;

    case DLL_THREAD_ATTACH:
#ifdef DEBUG
        GdiSetBatchLimit(1);
#endif
    case DLL_THREAD_DETACH:
    default:
        break;

    } // end switch()

    return TRUE;

} // end DllEntryPoint()


/* Stub function to call if all you want to do is make sure this DLL is loaded
 */
void WINAPI InitCommonControls(void)
{
}

STDAPI_(void) FixupSubclassRecordsAfterLogoff();

BOOL InitForWinlogon(HINSTANCE hInstance)
{
    //  Some people like to use comctl32 from inside winlogon, and
    //  for C2 security reasons, all global atoms are nuked from the
    //  window station when you log off.
    //
    //  So the rule is that all winlogon clients of comctl32 must
    //  call InitCommonControlsEx(ICC_WINLOGON_REINIT) immediately
    //  before doing any common control things (creating windows
    //  or property sheets/wizards) from winlogon.

    FixupSubclassRecordsAfterLogoff();

    InitGlobalMetrics(0);
    InitGlobalColors();

    return TRUE;
}

/* InitCommonControlsEx creates the classes. Only those classes requested are created!
** The process attach figures out if it's an old app and supplies ICC_WIN95_CLASSES.
*/
typedef BOOL (PASCAL *PFNINIT)(HINSTANCE);
typedef struct 
{
    PFNINIT pfnInit;
    LPCTSTR pszName;
    DWORD   dwClassSet;
    BOOL    fRegistered;
} INITCOMMONCONTROLSINFO;

#define MAKEICC(pfnInit, pszClass, dwFlags) { pfnInit, pszClass, dwFlags, FALSE }

INITCOMMONCONTROLSINFO icc[] =
{
     // Init function      Class name         Requested class sets which use this class
MAKEICC(InitToolbarClass,  TOOLBARCLASSNAME,  ICC_BAR_CLASSES),
MAKEICC(InitReBarClass,    REBARCLASSNAME,    ICC_COOL_CLASSES),
MAKEICC(InitToolTipsClass, TOOLTIPS_CLASS,    ICC_TREEVIEW_CLASSES|ICC_BAR_CLASSES|ICC_TAB_CLASSES),
MAKEICC(InitStatusClass,   STATUSCLASSNAME,   ICC_BAR_CLASSES),
MAKEICC(ListView_Init,     WC_LISTVIEW,       ICC_LISTVIEW_CLASSES),
MAKEICC(Header_Init,       WC_HEADER,         ICC_LISTVIEW_CLASSES),
MAKEICC(Tab_Init,          WC_TABCONTROL,     ICC_TAB_CLASSES),
MAKEICC(TV_Init,           WC_TREEVIEW,       ICC_TREEVIEW_CLASSES),
MAKEICC(InitTrackBar,      TRACKBAR_CLASS,    ICC_BAR_CLASSES),
MAKEICC(InitUpDownClass,   UPDOWN_CLASS,      ICC_UPDOWN_CLASS),
MAKEICC(InitProgressClass, PROGRESS_CLASS,    ICC_PROGRESS_CLASS),
MAKEICC(InitHotKeyClass,   HOTKEY_CLASS,      ICC_HOTKEY_CLASS),
MAKEICC(InitAnimateClass,  ANIMATE_CLASS,     ICC_ANIMATE_CLASS),
MAKEICC(InitDateClasses,   DATETIMEPICK_CLASS,ICC_DATE_CLASSES),
MAKEICC(InitDateClasses,   MONTHCAL_CLASS,    0),
MAKEICC(InitComboExClass,  WC_COMBOBOXEX,     ICC_USEREX_CLASSES),
MAKEICC(InitIPAddr,        WC_IPADDRESS,      ICC_INTERNET_CLASSES),
MAKEICC(InitPager,         WC_PAGESCROLLER,   ICC_PAGESCROLLER_CLASS),
MAKEICC(InitNativeFontCtl, WC_NATIVEFONTCTL,  ICC_NATIVEFNTCTL_CLASS),
MAKEICC(InitButtonClass,   WC_BUTTON,         ICC_STANDARD_CLASSES),
MAKEICC(InitStaticClass,   WC_STATIC,         ICC_STANDARD_CLASSES),
MAKEICC(InitEditClass,     WC_EDIT,           ICC_STANDARD_CLASSES),
MAKEICC(InitListBoxClass,  WC_LISTBOX,        ICC_STANDARD_CLASSES),
MAKEICC(InitComboboxClass, WC_COMBOBOX,       ICC_STANDARD_CLASSES),
MAKEICC(InitComboLBoxClass,WC_COMBOLBOX,      ICC_STANDARD_CLASSES),
MAKEICC(InitScrollBarClass,WC_SCROLLBAR,      ICC_STANDARD_CLASSES),
MAKEICC(InitLinkClass,     WC_LINK,           ICC_LINK_CLASS),
MAKEICC(InitReaderModeClass,WC_READERMODE,    ICC_STANDARD_CLASSES),


//
//  These aren't really classes.  They're just goofy flags.
//
MAKEICC(InitForWinlogon,   NULL,              ICC_WINLOGON_REINIT),
};

BOOL WINAPI InitCommonControlsEx(LPINITCOMMONCONTROLSEX picce)
{
    ULONG_PTR ul;
    int  i;
    BOOL fRet = TRUE;

    if (!picce ||
        (picce->dwSize != sizeof(INITCOMMONCONTROLSEX)) ||
        (picce->dwICC & ~ICC_ALL_VALID))
    {
        DebugMsg(DM_WARNING, TEXT("comctl32 - picce is bad"));
        return FALSE;
    }

    SHActivateContext(&ul);

    for (i=0 ; i < ARRAYSIZE(icc); i++)
    {
        if (picce->dwICC & icc[i].dwClassSet)
        {
            if (!icc[i].pfnInit(HINST_THISDLL))
            {
                fRet = FALSE;
                break;
            }
            else
            {
                icc[i].fRegistered = TRUE;
            }
        }
    }

    SHDeactivateContext(ul);

    return fRet;
}
//
// InitMUILanguage / GetMUILanguage implementation
//
// we have a per process PUI language setting. For NT it's just a global
// initialized with LANG_NEUTRAL and SUBLANG_NEUTRAL
// For Win95 it's DPA slot for the current process.
// InitMUILanguage sets callers preferred language id for common control
// GetMUILangauge returns what the caller has set to us 
// 
void WINAPI
InitMUILanguage(LANGID wLang)
{
    ENTERCRITICAL;
    g_PUILangId = wLang;
    LEAVECRITICAL;
}

LANGID WINAPI
GetMUILanguage(void)
{
    return g_PUILangId;
}
// end MUI functions

//
//  Unlike Win9x, WinNT does not automatically unregister classes
//  when a DLL unloads.  We have to do it manually.  Leaving the
//  class lying around means that if an app loads our DLL, then
//  unloads it, then reloads it at a different address, all our
//  leftover RegisterClass()es will point the WndProc at the wrong
//  place and we fault at the next CreateWindow().
//
//  This is not purely theoretical - NT4/FE hit this bug.
//
void UnregisterClasses()
{
    int i;

    for (i=0 ; i < ARRAYSIZE(icc) ; i++)
    {
        if (icc[i].pszName && icc[i].fRegistered)
        {
            UnregisterClass(icc[i].pszName, HINST_THISDLL);
        }
    }
}

#if defined(DEBUG)
LRESULT WINAPI SendMessageD(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    ASSERTNONCRITICAL;
    return SendMessageW(hWnd, Msg, wParam, lParam);
}
#endif // defined(DEBUG)


BOOL WINAPI RegisterClassNameW(LPCWSTR pszClass)
{
    ULONG_PTR ul;
    int  i;
    BOOL fRet = FALSE;

    SHActivateContext(&ul);

    for (i = 0; i < ARRAYSIZE(icc); i++)
    {
        if (lstrcmpi(icc[i].pszName, pszClass) == 0)
        {
            if (icc[i].pfnInit(HINST_THISDLL))
            {
                icc[i].fRegistered = TRUE;
                fRet = TRUE;
            }

            break;
        }
    }

    SHDeactivateContext(ul);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\cutils.c ===
/*
**  CUTILS.C
**
**  Common utilities for common controls
**
*/

#include "ctlspriv.h"
#include "advpub.h"             // For REGINSTALL
#include <ntverp.h>
#include "ccver.h"              // App compat version hacks
#include <shfusion.h>

#ifndef SSW_EX_IGNORESETTINGS
#define SSW_EX_IGNORESETTINGS   0x00040000  // ignore system settings to turn on/off smooth scroll
#endif

// the insert mark is 6 pixels wide
#define INSERTMARKSIZE      6


//
// Globals - REVIEW_32
//

BOOL g_fAnimate;
BOOL g_fSmoothScroll;
BOOL g_fEnableBalloonTips = TRUE;

int g_cxEdge;
int g_cyEdge;
int g_cxEdgeScaled;
int g_cyEdgeScaled;
int g_cxBorder;
int g_cyBorder;
int g_cxScreen;
int g_cyScreen;
int g_cxFrame;
int g_cyFrame;
int g_cxVScroll;
int g_cyHScroll;
int g_cxIcon, g_cyIcon;
int g_cxSmIcon, g_cySmIcon;
int g_cxIconSpacing, g_cyIconSpacing;
int g_cxIconMargin, g_cyIconMargin;
int g_cyLabelSpace;
int g_cxLabelMargin;
int g_cxDoubleClk;
int g_cyDoubleClk;
int g_cxScrollbar;
int g_cyScrollbar;
int g_fDragFullWindows;
double g_dScaleX = 1.0;
double g_dScaleY = 1.0;
BOOL   g_fScale = FALSE;
int g_iDPI = 96.0;
BOOL g_fHighContrast = FALSE;
int g_cyCompensateInternalLeading;
int g_fLeftAligned = FALSE;


COLORREF g_clrWindow;
COLORREF g_clrWindowText;
COLORREF g_clrWindowFrame;
COLORREF g_clrGrayText;
COLORREF g_clrBtnText;
COLORREF g_clrBtnFace;
COLORREF g_clrBtnShadow;
COLORREF g_clrBtnHighlight;
COLORREF g_clrHighlight;
COLORREF g_clrHighlightText;
COLORREF g_clrInfoText;
COLORREF g_clrInfoBk;
COLORREF g_clr3DDkShadow;
COLORREF g_clr3DLight;
COLORREF g_clrMenuHilight;
COLORREF g_clrMenuText;

HBRUSH g_hbrGrayText;
HBRUSH g_hbrWindow;
HBRUSH g_hbrWindowText;
HBRUSH g_hbrWindowFrame;
HBRUSH g_hbrBtnFace;
HBRUSH g_hbrBtnHighlight;
HBRUSH g_hbrBtnShadow;
HBRUSH g_hbrHighlight;
HBRUSH g_hbrMenuHilight;
HBRUSH g_hbrMenuText;


DWORD  g_dwHoverSelectTimeout;

HFONT g_hfontSystem;

void InitGlobalColors()
{
    BOOL fFlatMenuMode = FALSE;
    static fMenuColorAlloc = FALSE;
    g_clrWindow = GetSysColor(COLOR_WINDOW);
    g_clrWindowText = GetSysColor(COLOR_WINDOWTEXT);
    g_clrWindowFrame = GetSysColor(COLOR_WINDOWFRAME);
    g_clrGrayText = GetSysColor(COLOR_GRAYTEXT);
    g_clrBtnText = GetSysColor(COLOR_BTNTEXT);
    g_clrBtnFace = GetSysColor(COLOR_BTNFACE);
    g_clrBtnShadow = GetSysColor(COLOR_BTNSHADOW);
    g_clrBtnHighlight = GetSysColor(COLOR_BTNHIGHLIGHT);
    g_clrHighlight = GetSysColor(COLOR_HIGHLIGHT);
    g_clrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_clrInfoText = GetSysColor(COLOR_INFOTEXT);
    g_clrInfoBk = GetSysColor(COLOR_INFOBK);
    g_clr3DDkShadow = GetSysColor(COLOR_3DDKSHADOW);
    g_clr3DLight = GetSysColor(COLOR_3DLIGHT);

    SystemParametersInfo(SPI_GETFLATMENU, 0, (PVOID)&fFlatMenuMode, 0);

    if (fFlatMenuMode)
    {
        g_clrMenuHilight = GetSysColor(COLOR_MENUHILIGHT);
        g_clrMenuText = GetSysColor(COLOR_MENUTEXT);
    }
    else
    {
        g_clrMenuHilight = GetBorderSelectColor(60, GetSysColor(COLOR_HIGHLIGHT));
        g_clrMenuText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    }

    g_hbrGrayText = GetSysColorBrush(COLOR_GRAYTEXT);
    g_hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    g_hbrWindowText = GetSysColorBrush(COLOR_WINDOWTEXT);
    g_hbrWindowFrame = GetSysColorBrush(COLOR_WINDOWFRAME);
    g_hbrBtnFace = GetSysColorBrush(COLOR_BTNFACE);
    g_hbrBtnHighlight = GetSysColorBrush(COLOR_BTNHIGHLIGHT);
    g_hbrBtnShadow = GetSysColorBrush(COLOR_BTNSHADOW);
    g_hbrHighlight = GetSysColorBrush(COLOR_HIGHLIGHT);
    g_hfontSystem = GetStockObject(SYSTEM_FONT);

    if (fMenuColorAlloc)
    {
        DeleteObject(g_hbrMenuHilight);
    }

    if (fFlatMenuMode)
    {
        fMenuColorAlloc = FALSE;
        g_hbrMenuHilight = GetSysColorBrush(COLOR_MENUHILIGHT);
        g_hbrMenuText = GetSysColorBrush(COLOR_MENUTEXT);
    }
    else
    {
        fMenuColorAlloc = TRUE;
        g_hbrMenuHilight = CreateSolidBrush(g_clrMenuHilight);
        g_hbrMenuText = GetSysColorBrush(COLOR_HIGHLIGHTTEXT);
    }

}


#define CCS_ALIGN (CCS_TOP | CCS_NOMOVEY | CCS_BOTTOM)

///
//
// Implement MapWindowPoints as if the hwndFrom and hwndTo aren't
// mirrored. This is used when any of the windows (hwndFrom or hwndTo)
// are mirrored. See below. [samera]
//
int TrueMapWindowPoints(HWND hwndFrom, HWND hwndTo, LPPOINT lppt, UINT cPoints)
{
    int dx, dy;
    RECT rcFrom={0,0,0,0}, rcTo={0,0,0,0};

    if (hwndFrom) {
        GetClientRect(hwndFrom, &rcFrom);
        MapWindowPoints(hwndFrom, NULL, (LPPOINT)&rcFrom.left, 2);
    }

    if (hwndTo) {
        GetClientRect(hwndTo, &rcTo);
        MapWindowPoints(hwndTo, NULL, (LPPOINT)&rcTo.left, 2);
    }

    dx = rcFrom.left - rcTo.left;
    dy = rcFrom.top  - rcTo.top;

    /*
     * Map the points
     */
    while (cPoints--) {
        lppt->x += dx;
        lppt->y += dy;
        ++lppt;
    }
    
    return MAKELONG(dx, dy);
}


// Note that the default alignment is CCS_BOTTOM
//
void NewSize(HWND hWnd, int nThickness, LONG style, int left, int top, int width, int height)
{
    // Resize the window unless the user said not to
    //
    if (!(style & CCS_NORESIZE))
    {
        RECT rc, rcWindow, rcBorder;

        // Remember size that was passed in and don't bother calling SetWindowPos if we're not
        // actually going to change the window size
        int leftSave = left;
        int topSave = top;
        int widthSave = width;
        int heightSave = height;

        // Calculate the borders around the client area of the status bar
        GetWindowRect(hWnd, &rcWindow);
        rcWindow.right -= rcWindow.left;  // -> dx
        rcWindow.bottom -= rcWindow.top;  // -> dy

        GetClientRect(hWnd, &rc);

        //
        // If the window is mirrored, mirror the anchor point
        // since it will be passed to SWP which accepts screen
        // ccordinates. This mainly fixes the display of status bar
        // and others. [samera]
        //
        if (IS_WINDOW_RTL_MIRRORED(hWnd))
        {
            TrueMapWindowPoints(hWnd, NULL, (LPPOINT)&rc.left, 1);
        }
        else
        {
            ClientToScreen(hWnd, (LPPOINT)&rc);
        }

        rcBorder.left = rc.left - rcWindow.left;
        rcBorder.top  = rc.top  - rcWindow.top ;
        rcBorder.right  = rcWindow.right  - rc.right  - rcBorder.left;
        rcBorder.bottom = rcWindow.bottom - rc.bottom - rcBorder.top ;

        if (style & CCS_VERT)
            nThickness += rcBorder.left + rcBorder.right;
        else
            nThickness += rcBorder.top + rcBorder.bottom;

        // Check whether to align to the parent window
        //
        if (style & CCS_NOPARENTALIGN)
        {
            // Check out whether this bar is top aligned or bottom aligned
            //
            switch (style & CCS_ALIGN)
            {
            case CCS_TOP:
            case CCS_NOMOVEY:
                break;

            default: // CCS_BOTTOM
                if(style & CCS_VERT)
                    left = left + width - nThickness;
                else
                    top = top + height - nThickness;
            }
        }
        else
        {
            // It is assumed there is a parent by default
            //
            GetClientRect(GetParent(hWnd), &rc);

            // Don't forget to account for the borders
            //
            if(style & CCS_VERT)
            {
                top = -rcBorder.right;
                height = rc.bottom + rcBorder.top + rcBorder.bottom;
            }
            else
            {
                left = -rcBorder.left;
                width = rc.right + rcBorder.left + rcBorder.right;
            }

            if ((style & CCS_ALIGN) == CCS_TOP)
            {
                if(style & CCS_VERT)
                    left = -rcBorder.left;
                else
                    top = -rcBorder.top;
            }
            else if ((style & CCS_ALIGN) != CCS_NOMOVEY)
            {
                if (style & CCS_VERT)
                    left = rc.right - nThickness + rcBorder.right;
                else
                    top = rc.bottom - nThickness + rcBorder.bottom;
            }
        }
        if (!(style & CCS_NOMOVEY) && !(style & CCS_NODIVIDER))
        {
            if (style & CCS_VERT)
                left += g_cxEdge;
            else
                top += g_cyEdge;      // double pixel edge thing
        }

        if(style & CCS_VERT)
            width = nThickness;
        else
            height = nThickness;

        SetWindowPos(hWnd, NULL, left, top, width, height, SWP_NOZORDER);
    }
}


BOOL MGetTextExtent(HDC hdc, LPCTSTR lpstr, int cnt, int * pcx, int * pcy)
{
    BOOL fSuccess;
    SIZE size = {0,0};
    
    if (cnt == -1)
        cnt = lstrlen(lpstr);
    
    fSuccess=GetTextExtentPoint(hdc, lpstr, cnt, &size);
    if (pcx)
        *pcx=size.cx;
    if (pcy)
        *pcy=size.cy;

    return fSuccess;
}


// these are the default colors used to map the dib colors
// to the current system colors

#define RGB_BUTTONTEXT      (RGB(000,000,000))  // black
#define RGB_BUTTONSHADOW    (RGB(128,128,128))  // dark grey
#define RGB_BUTTONFACE      (RGB(192,192,192))  // bright grey
#define RGB_BUTTONHILIGHT   (RGB(255,255,255))  // white
#define RGB_BACKGROUNDSEL   (RGB(000,000,255))  // blue
#define RGB_BACKGROUND      (RGB(255,000,255))  // magenta

#define FlipColor(rgb)      (RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb)))

#define MAX_COLOR_MAPS      16

void _MapBitmapColors(LPBITMAPINFOHEADER pbih, LPCOLORMAP pcmp, int iCmps, COLOR_STRUCT* pcsMask, UINT cMask, DWORD wFlags)
{
    static const COLORMAP c_acmpSys[] =
    {
        { RGB_BUTTONTEXT,    COLOR_BTNTEXT },       // black
        { RGB_BUTTONSHADOW,  COLOR_BTNSHADOW },     // dark grey
        { RGB_BUTTONFACE,    COLOR_BTNFACE },       // bright grey
        { RGB_BUTTONHILIGHT, COLOR_BTNHIGHLIGHT },  // white
        { RGB_BACKGROUNDSEL, COLOR_HIGHLIGHT },     // blue
        { RGB_BACKGROUND,    COLOR_WINDOW },        // magenta
    };

    COLORMAP acmpDef[ARRAYSIZE(c_acmpSys)];
    COLORMAP acmpDIB[MAX_COLOR_MAPS];
    COLOR_STRUCT* pcs = (COLOR_STRUCT*)(((LPBYTE)pbih) + pbih->biSize);

    int i;

    if (!pcmp)
    {
        // Get system colors for the default color map

        for (i = 0; i < ARRAYSIZE(acmpDef); i++)
        {
            acmpDef[i].from = c_acmpSys[i].from;
            acmpDef[i].to = GetSysColor((int)c_acmpSys[i].to);
        }

        pcmp = acmpDef;
        iCmps = ARRAYSIZE(acmpDef);
    }
    else
    {
        // Sanity check color map count

        if (iCmps > MAX_COLOR_MAPS)
            iCmps = MAX_COLOR_MAPS;
    }

    for (i = 0; i < iCmps; i++)
    {
        acmpDIB[i].to = FlipColor(pcmp[i].to);
        acmpDIB[i].from = FlipColor(pcmp[i].from);
    }

    // if we are creating a mask, build a color table with white
    // marking the transparent section (where it used to be background)
    // and black marking the opaque section (everything else).  this
    // table is used below to build the mask using the original DIB bits.
    if (wFlags & CMB_MASKED)
    {
        COLOR_STRUCT csBkgnd = FlipColor(RGB_BACKGROUND);

        ASSERT(cMask == MAX_COLOR_MAPS);

        for (i = 0; i < MAX_COLOR_MAPS; i++)
        {
            if (pcs[i] == csBkgnd)
                pcsMask[i] = 0xFFFFFF;       // transparent section
            else
                pcsMask[i] = 0x000000;       // opaque section
        }
    }

    for (i = 0; i < MAX_COLOR_MAPS; i++)
    {
        int j;
        for (j = 0; j < iCmps; j++)
        {
            if ((pcs[i] & 0x00FFFFFF) == acmpDIB[j].from)
            {
                pcs[i] = acmpDIB[j].to;
                break;
            }
        }
    }
}

HBITMAP _CreateMappedBitmap(LPBITMAPINFOHEADER pbih, LPBYTE lpBits, COLOR_STRUCT* pcsMask, UINT cMask, UINT wFlags)
{
    HBITMAP hbm = NULL;

    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        HDC hdcMem = CreateCompatibleDC(hdc);
        if (hdcMem)
        {
            int nWidth = (int)pbih->biWidth;
            int nHeight = (int)pbih->biHeight;

            if (wFlags & CMB_DIBSECTION)
            {
                // Have to edit the header slightly, since CreateDIBSection supports
                // only BI_RGB and BI_BITFIELDS.  This is the same whackery that USER
                // does in LoadImage.
                LPVOID pvDummy;
                DWORD dwCompression = pbih->biCompression;
                if (dwCompression != BI_BITFIELDS)
                    pbih->biCompression = BI_RGB;
                hbm = CreateDIBSection(hdc, (LPBITMAPINFO)pbih, DIB_RGB_COLORS,
                                       &pvDummy, NULL, 0);
                pbih->biCompression = dwCompression;
            }

            if (hbm == NULL)
            {
                // If CMB_DIBSECTION failed, then create a DDB instead.  Not perfect,
                // but better than creating nothing.  We also get here if the caller
                // didn't ask for a DIB section.

                // if creating a mask, the bitmap needs to be twice as wide.
                int nWidthBmp;
                if (wFlags & CMB_MASKED)
                    nWidthBmp = nWidth * 2;
                else
                    nWidthBmp = nWidth;

                hbm = CreateCompatibleBitmap(hdc, nWidthBmp, nHeight);
            }

            if (hbm)
            {
                HBITMAP hbmOld = SelectObject(hdcMem, hbm);

                // set the main image
                StretchDIBits(hdcMem, 0, 0, nWidth, nHeight, 0, 0, nWidth, nHeight, lpBits,
                         (LPBITMAPINFO)pbih, DIB_RGB_COLORS, SRCCOPY);

                // if building a mask, replace the DIB's color table with the
                // mask's black/white table and set the bits.  in order to
                // complete the masked effect, the actual image needs to be
                // modified so that it has the color black in all sections
                // that are to be transparent.
                if (wFlags & CMB_MASKED)
                {
                    if (cMask > 0)
                    {
                        COLOR_STRUCT* pcs = (COLOR_STRUCT*)(((LPBYTE)pbih) + pbih->biSize);
                        hmemcpy(pcs, pcsMask, cMask * sizeof(RGBQUAD));
                    }

                    StretchDIBits(hdcMem, nWidth, 0, nWidth, nHeight, 0, 0, nWidth, nHeight, lpBits,
                         (LPBITMAPINFO)pbih, DIB_RGB_COLORS, SRCCOPY);

                    BitBlt(hdcMem, 0, 0, nWidth, nHeight, hdcMem, nWidth, 0, 0x00220326);   // DSna
                }
                SelectObject(hdcMem, hbmOld);
            }

            DeleteObject(hdcMem);
        }

        ReleaseDC(NULL, hdc);
    }

    return hbm;
}

// This is almost the same as LoadImage(..., LR_MAP3DCOLORS) except that
//
//  -   The app can specify a custom color map,
//  -   The default color map maps colors beyond the 3D colors,
//
HBITMAP CreateMappedBitmap(HINSTANCE hInstance, INT_PTR idBitmap,
      UINT wFlags, LPCOLORMAP lpColorMap, int iNumMaps)
{
    HBITMAP hbm = NULL;
    BOOL bColorTable;

    HRSRC hrsrc = FindResource(hInstance, MAKEINTRESOURCE(idBitmap), RT_BITMAP);

    if (hrsrc)
    {
        HGLOBAL hglob = LoadResource(hInstance, hrsrc);

        LPBITMAPINFOHEADER pbihRes = (LPBITMAPINFOHEADER)LockResource(hglob);
        if (pbihRes)
        {
            // munge on a copy of the color table instead of the original
            // (prevent possibility of "reload" with messed table
            UINT cbOffset;
            LPBITMAPINFOHEADER pbih;
            WORD biBitCount = pbihRes->biBitCount;
            if ((biBitCount > 8) && (pbihRes->biCompression == BI_RGB))
            {
                // No bmiColors table, image bits start right after header
                cbOffset = pbihRes->biSize;
                bColorTable = FALSE;
            }
            else
            {
                // Bits start after bmiColors table
                cbOffset = pbihRes->biSize + ((1 << (pbihRes->biBitCount)) * sizeof(RGBQUAD));
                bColorTable = TRUE;
            }

            pbih = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, cbOffset);
            if (pbih)
            {
                COLOR_STRUCT acsMask[MAX_COLOR_MAPS];
                LPBYTE lpBits = (LPBYTE)(pbihRes) + cbOffset;
                UINT uColorTableLength = (bColorTable ? ARRAYSIZE(acsMask) : 0);

                memcpy(pbih, pbihRes, cbOffset);

                if (bColorTable)
                    _MapBitmapColors(pbih, lpColorMap, iNumMaps, acsMask, uColorTableLength, wFlags);

                hbm = _CreateMappedBitmap(pbih, lpBits, acsMask, uColorTableLength, wFlags);

                LocalFree(pbih);
            }

            UnlockResource(hglob);
        }

        FreeResource(hrsrc);
    }

    return hbm;
}

// moved from shelldll\dragdrop.c

// should caller pass in message that indicates termination
// (WM_LBUTTONUP, WM_RBUTTONUP)?
//
// in:
//      hwnd    to do check on
//      x, y    in client coordinates
//
// returns:
//      TRUE    the user began to drag (moved mouse outside double click rect)
//      FALSE   mouse came up inside click rect
//
// FEATURE, should support VK_ESCAPE to cancel

BOOL CheckForDragBegin(HWND hwnd, int x, int y)
{
    RECT rc;
    int dxClickRect = GetSystemMetrics(SM_CXDRAG);
    int dyClickRect = GetSystemMetrics(SM_CYDRAG);

    if (dxClickRect < 4)
    {
        dxClickRect = dyClickRect = 4;
    }

    // See if the user moves a certain number of pixels in any direction

    SetRect(&rc, x - dxClickRect, y - dyClickRect, x + dxClickRect, y + dyClickRect);
    MapWindowRect(hwnd, HWND_DESKTOP, &rc); // client -> screen

    //
    //  SUBTLE!  We use PeekMessage+WaitMessage instead of GetMessage,
    //  because WaitMessage will return when there is an incoming
    //  SendMessage, whereas GetMessage does not.  This is important,
    //  because the incoming message might've been WM_CAPTURECHANGED.
    //

    SetCapture(hwnd);
    do {
        MSG32 msg32;
        if (PeekMessage32(&msg32, NULL, 0, 0, PM_REMOVE, TRUE))
        {
            // See if the application wants to process the message...
            if (CallMsgFilter32(&msg32, MSGF_COMMCTRL_BEGINDRAG, TRUE) != 0)
                continue;

            switch (msg32.message) {
            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
                ReleaseCapture();
                return FALSE;

            case WM_MOUSEMOVE:
                if (IsWindow(hwnd) && !PtInRect(&rc, msg32.pt)) {
                    ReleaseCapture();
                    return TRUE;
                }
                break;

            default:
                TranslateMessage32(&msg32, TRUE);
                DispatchMessage32(&msg32, TRUE);
                break;
            }
        }
        else WaitMessage();

        // WM_CANCELMODE messages will unset the capture, in that
        // case I want to exit this loop
    } while (IsWindow(hwnd) && GetCapture() == hwnd);

    return FALSE;
}


/* Regular StrToInt; stops at first non-digit. */

int WINAPI StrToInt(LPCTSTR lpSrc)      // atoi()
{

#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == TEXT('-')) {
        bNeg = TRUE;
        lpSrc++;
    }

    while (ISDIGIT(*lpSrc)) {
        n *= 10;
        n += *lpSrc - TEXT('0');
        lpSrc++;
    }
    return bNeg ? -n : n;
}

//
// Wrappers for StrToInt
//

int WINAPI StrToIntA(LPCSTR lpSrc)      // atoi()
{
    LPWSTR lpString;
    INT    iResult;

    lpString = ProduceWFromA (CP_ACP, lpSrc);

    if (!lpString) {
        return 0;
    }

    iResult = StrToIntW(lpString);

    FreeProducedString (lpString);

    return iResult;

}

//
// From zmouse.h in the Magellan SDK
//

#define MSH_MOUSEWHEEL TEXT("MSWHEEL_ROLLMSG")

// Class name for Magellan/Z MSWHEEL window
// use FindWindow to get hwnd to MSWHEEL
#define MOUSEZ_CLASSNAME  TEXT("MouseZ")           // wheel window class
#define MOUSEZ_TITLE      TEXT("Magellan MSWHEEL") // wheel window title

#define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
#define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)

#define MSH_SCROLL_LINES  TEXT("MSH_SCROLL_LINES_MSG")

#define DI_GETDRAGIMAGE TEXT("ShellGetDragImage")       // Copied from Shlobj.w

UINT g_msgMSWheel;
UINT g_ucScrollLines = 3;                        /* default */
int  gcWheelDelta;
UINT g_uDragImages;

// --------------------------------------------------------------------------
//  _TrackMouseEvent() entrypoint
//
//  calls TrackMouseEvent because we run on an OS where this exists
//
// --------------------------------------------------------------------------
BOOL WINAPI _TrackMouseEvent(LPTRACKMOUSEEVENT lpTME)
{
    return TrackMouseEvent(lpTME);
}



//
// Checks the process to see if it is running under the system SID
//
BOOL IsSystemProcess()
{
    BOOL bRet = FALSE;  // assume we are not a system process
    HANDLE hProcessToken;
    
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
    {
        PSID pSIDSystem;
        static SID_IDENTIFIER_AUTHORITY sSystemSidAuthority = SECURITY_NT_AUTHORITY;

        if (AllocateAndInitializeSid(&sSystemSidAuthority,
                                     1,
                                     SECURITY_LOCAL_SYSTEM_RID,
                                     0, 0, 0, 0, 0, 0, 0,
                                     &pSIDSystem))
        {
            CheckTokenMembership(hProcessToken, pSIDSystem, &bRet);

            FreeSid(pSIDSystem);
        }

        CloseHandle(hProcessToken);
    }

    return bRet;
}

//
// !! WARNING !! - Be very careful about opening HKCU in InitGlobalMetrics(). Basically this gets
//                 called during processattach and system process will end up loading the user hive
//                 and because advapi32 is lame we end up pinning the hive for the life of this process.
//
void InitGlobalMetrics(WPARAM wParam)
{
    static BOOL fInitMouseWheel;
    static HWND hwndMSWheel;
    static UINT msgMSWheelGetScrollLines;
    HDC hdcScreen;
    BOOL fRemoteSession = (BOOL)GetSystemMetrics( SM_REMOTESESSION );
    HKEY hkcu = NULL;
    
    if (!fInitMouseWheel)
    {
        fInitMouseWheel = TRUE;

        g_msgMSWheel = WM_MOUSEWHEEL;
    }

    g_uDragImages = RegisterWindowMessage(DI_GETDRAGIMAGE);

    SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &g_ucScrollLines, 0);

    g_cxIcon = GetSystemMetrics(SM_CXICON);
    g_cyIcon = GetSystemMetrics(SM_CYICON);
    g_cxSmIcon = GetSystemMetrics(SM_CXSMICON);
    g_cySmIcon = GetSystemMetrics(SM_CYSMICON);

    g_cxIconSpacing = GetSystemMetrics( SM_CXICONSPACING );
    g_cyIconSpacing = GetSystemMetrics( SM_CYICONSPACING );

    hdcScreen = GetDC(NULL);
    if (hdcScreen)
    {
        g_iDPI = GetDeviceCaps(hdcScreen, LOGPIXELSX);
        g_dScaleX = GetDeviceCaps(hdcScreen, LOGPIXELSX) / 96.0;
        g_dScaleY = GetDeviceCaps(hdcScreen, LOGPIXELSY) / 96.0;
        if (g_dScaleX > 1.0 ||
            g_dScaleY > 1.0)
        {
            g_fScale = TRUE;
        }

        ReleaseDC(NULL, hdcScreen);
    }

    // Full window drag stays off if running remotely.  Sessions could become remote after
    // being started.
    if (!fRemoteSession &&
        (wParam == 0 || wParam == SPI_SETDRAGFULLWINDOWS)) 
    {
        SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, sizeof(g_fDragFullWindows), &g_fDragFullWindows, 0);
    }

    if (wParam == 0 || wParam == SPI_SETHIGHCONTRAST)
    {
        HIGHCONTRAST hc = { sizeof(hc) };
        if (SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0))
        {
            g_fHighContrast = (hc.dwFlags & HCF_HIGHCONTRASTON);
        }
    }

    // (see warning at the top of this fn.)
    //
    // As this function may be called within a DllMain, open HKCU via RegOpenCurrentUser, 
    // instead of RegOpenKeyEx (which locks the hive in memory) - see the comment at the
    // top of this function.
    RegOpenCurrentUser(KEY_READ, &hkcu);

    // Smooth scrolling stays off if running remotely
    if (!fRemoteSession)
    {
        g_fSmoothScroll = TRUE;

        //
        // (see warning at the top of this fn.)
        //
        // we want to avoid loading the users hive if we are running as a system process since advapi32 
        // will hold the hive for as long as this process exists 
        if (!IsSystemProcess() && hkcu)
        {
            HKEY hkey;
            if (RegOpenKeyEx(hkcu, TEXT("Control Panel\\Desktop"), 0, KEY_READ, &hkey) == ERROR_SUCCESS)
            {
                DWORD dwSize = sizeof(g_fSmoothScroll);
                RegQueryValueEx(hkey, TEXT("SmoothScroll"), 0, NULL, (LPBYTE)&g_fSmoothScroll, &dwSize);

                RegCloseKey(hkey);
            }
        }
    }

    if (fRemoteSession)
    {
        // Nobody should've turned these on
        g_fDragFullWindows = FALSE;
        g_fSmoothScroll = FALSE;
    }

    // some of these are also not members of NONCLIENTMETRICS
    if ((wParam == 0) || (wParam == SPI_SETNONCLIENTMETRICS))
    {
        NONCLIENTMETRICS ncm;

        // REVIEW, make sure all these vars are used somewhere.
        g_cxEdgeScaled = g_cxEdge = GetSystemMetrics(SM_CXEDGE);
        g_cyEdgeScaled = g_cyEdge = GetSystemMetrics(SM_CYEDGE);

        CCDPIScaleX(&g_cxEdgeScaled);
        CCDPIScaleY(&g_cyEdgeScaled);

        g_cxBorder = GetSystemMetrics(SM_CXBORDER);
        g_cyBorder = GetSystemMetrics(SM_CYBORDER);
        g_cxScreen = GetSystemMetrics(SM_CXSCREEN);
        g_cyScreen = GetSystemMetrics(SM_CYSCREEN);
        g_cxFrame  = GetSystemMetrics(SM_CXFRAME);
        g_cyFrame  = GetSystemMetrics(SM_CYFRAME);

        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

        g_cxVScroll = g_cxScrollbar = (int)ncm.iScrollWidth;
        g_cyHScroll = g_cyScrollbar = (int)ncm.iScrollHeight;

        // this is true for 4.0 modules only
        // for 3.x modules user lies and adds one to these values
        // ASSERT(g_cxVScroll == GetSystemMetrics(SM_CXVSCROLL));
        // ASSERT(g_cyHScroll == GetSystemMetrics(SM_CYHSCROLL));

        g_cxIconMargin = g_cxBorder * 8;
        g_cyIconMargin = g_cyEdge;
        g_cyLabelSpace = g_cyIconMargin + (g_cyEdge);
        g_cxLabelMargin = g_cxEdge;

        g_cxDoubleClk = GetSystemMetrics(SM_CXDOUBLECLK);
        g_cyDoubleClk = GetSystemMetrics(SM_CYDOUBLECLK);

        g_fEnableBalloonTips = TRUE;

        //
        // (see warning at the top of this fn.)
        //
        // we want to avoid loading the users hive if we are running as a system process since advapi32 
        // will hold the hive for as long as this process exists 
        if (!IsSystemProcess() && hkcu)
        {
            HKEY hkey;
            if (RegOpenKeyEx(hkcu, REGSTR_EXPLORER_ADVANCED, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
            {
                DWORD dwSize = sizeof(g_fEnableBalloonTips);
                RegQueryValueEx(hkey, TEXT("EnableBalloonTips"), 0, NULL, (LPBYTE)&g_fEnableBalloonTips, &dwSize);
                
                RegCloseKey(hkey);
            }
        }
    }

    SystemParametersInfo(SPI_GETMENUDROPALIGNMENT, 0, &g_fLeftAligned, 0);

    //NT 4.0 has this SPI_GETMOUSEHOVERTIME
    SystemParametersInfo(SPI_GETMOUSEHOVERTIME, 0, &g_dwHoverSelectTimeout, 0);

    if (hkcu != NULL)
    {
        RegCloseKey(hkcu);
    }
}

void RelayToToolTips(HWND hwndToolTips, HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    if(hwndToolTips) 
    {
        MSG msg;
        msg.lParam = lParam;
        msg.wParam = wParam;
        msg.message = wMsg;
        msg.hwnd = hWnd;
        SendMessage(hwndToolTips, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
    }
}

#define DT_SEARCHTIMEOUT    1000L       // 1 seconds

__inline BOOL IsISearchTimedOut(PISEARCHINFO pis)
{
    return GetMessageTime() - pis->timeLast > DT_SEARCHTIMEOUT &&
           !IsFlagSet(g_dwPrototype, PTF_NOISEARCHTO);

}

int GetIncrementSearchString(PISEARCHINFO pis, LPTSTR lpsz)
{
    if (IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf && lpsz)
    {
        StringCchCopy(lpsz, pis->ichCharBuf+1, pis->pszCharBuf);
    }

    return pis->ichCharBuf;
}

// Now only Korean version is interested in incremental search with composition string.
BOOL IncrementSearchImeCompStr(PISEARCHINFO pis, BOOL fCompStr, LPTSTR lpszCompStr, LPTSTR *lplpstr)
{
    BOOL fRestart = FALSE;

    if (!pis->fReplaceCompChar && IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf == 0)
    {
        fRestart = TRUE;
        pis->fReplaceCompChar = FALSE;
    }
    pis->timeLast = GetMessageTime();

    // Is there room for new character plus zero terminator?
    //
    if (!pis->fReplaceCompChar && pis->ichCharBuf + 1 + 1 > pis->cbCharBuf)
    {
        LPTSTR psz = ReAlloc(pis->pszCharBuf, sizeof(TCHAR)*(pis->cbCharBuf + 16));
        if (!psz)
            return fRestart;

        pis->cbCharBuf += 16;
        pis->pszCharBuf = psz;
    }

    if (pis->fReplaceCompChar)
    {
        if (lpszCompStr[0])
        {
            pis->pszCharBuf[pis->ichCharBuf-1] = lpszCompStr[0];
            pis->pszCharBuf[pis->ichCharBuf] = 0;
        }
        else
        {
            pis->ichCharBuf--;
            pis->pszCharBuf[pis->ichCharBuf] = 0;
        }
    }
    else
    {
        pis->pszCharBuf[pis->ichCharBuf++] = lpszCompStr[0];
        pis->pszCharBuf[pis->ichCharBuf] = 0;
    }

    pis->fReplaceCompChar = (fCompStr && lpszCompStr[0]);

    if (pis->ichCharBuf == 1 && pis->fReplaceCompChar)
        fRestart = TRUE;

    *lplpstr = pis->pszCharBuf;

    return fRestart;

}

/*
 * Thunk for LVM_GETISEARCHSTRINGA
 */
int GetIncrementSearchStringA(PISEARCHINFO pis, UINT uiCodePage, LPSTR lpsz)
{
    if (IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf && lpsz) {
        ConvertWToAN( uiCodePage, lpsz, pis->ichCharBuf, pis->pszCharBuf, pis->ichCharBuf );
        lpsz[pis->ichCharBuf] = '\0';
    }
    return pis->ichCharBuf;
}

// Beep only on the first failure.

void IncrementSearchBeep(PISEARCHINFO pis)
{
    if (!pis->iIncrSearchFailed)
    {
        pis->iIncrSearchFailed = TRUE;
        MessageBeep(0);
    }
}

//
//  IncrementSearchString - Add or clear the search string
//
//      ch == 0:  Reset the search string.  Return value meaningless.
//
//      ch != 0:  Append the character to the search string, starting
//                a new search string if we timed out the last one.
//                lplpstr receives the string so far.
//                Return value is TRUE if a new search string was
//                created, or FALSE if we appended to an existing one.
//

BOOL IncrementSearchString(PISEARCHINFO pis, UINT ch, LPTSTR *lplpstr)
{
    BOOL fRestart = FALSE;

    if (!ch) {
        pis->ichCharBuf =0;
        pis->iIncrSearchFailed = 0;
        return FALSE;
    }

    if (IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf == 0)
        fRestart = TRUE;

    pis->timeLast = GetMessageTime();

    // Is there room for new character plus zero terminator?
    //
    if (pis->ichCharBuf + 1 + 1 > pis->cbCharBuf)
    {
        LPTSTR psz = ReAlloc(pis->pszCharBuf, ((pis->cbCharBuf + 16) * sizeof(TCHAR)));
        if (!psz)
            return fRestart;

        pis->cbCharBuf += 16;
        pis->pszCharBuf = psz;
    }

    pis->pszCharBuf[pis->ichCharBuf++] = (TCHAR)ch;
    pis->pszCharBuf[pis->ichCharBuf] = 0;

    *lplpstr = pis->pszCharBuf;

    return fRestart;
}

// strips out the accelerators.  they CAN be the same buffers.
int StripAccelerators(LPTSTR lpszFrom, LPTSTR lpszTo, BOOL fAmpOnly)
{
    LPTSTR lpszStart = lpszTo;

    while (*lpszTo = *lpszFrom)
    {
        if (!fAmpOnly && (g_fDBCSInputEnabled))
        {
            if (*lpszFrom == TEXT('(') && *(lpszFrom + 1) == CH_PREFIX)
            {
                int i;
                LPTSTR psz = lpszFrom + 2;

                for(i = 0; i < 2 && *psz; i++, psz = FastCharNext(psz))
                {
                    ;
                }


                if (*psz == '\0')
                {
                    *lpszTo = 0;
                    break;
                }
                else if (i == 2 && *psz == TEXT(')'))
                {
                    lpszTo--;
                    lpszFrom = psz+1;
                    continue;
                }
            }
        }

        if (*lpszFrom == TEXT('\t'))
        {
            *lpszTo = TEXT('\0');
            break;
        }

        if ((*lpszFrom++ != CH_PREFIX) || (*lpszFrom == CH_PREFIX))
        {
            lpszTo++;
        }
    }

    return (int)(lpszTo - lpszStart);
}


void ScrollShrinkRect(int x, int y, LPRECT lprc)
{
    if (lprc) {
        if (x > 0) {
            lprc->left += x;
        } else {
            lprc->right += x;
        }

        if (y > 0) {
            lprc->top += y;
        } else {
            lprc->bottom += y;
        }

    }
}



// common control info helpers
void CIInitialize(LPCCONTROLINFO lpci, HWND hwnd, LPCREATESTRUCT lpcs)
{
    TEXTMETRIC tm;
    HFONT hfStatus;
    lpci->hwnd = hwnd;
    lpci->hwndParent = lpcs->hwndParent;
    lpci->style = lpcs->style;
    lpci->uiCodePage = CP_ACP;
    lpci->dwExStyle = lpcs->dwExStyle;
    lpci->iVersion = 6;
#ifdef DPITEST
    lpci->fDPIAware = TRUE;
#endif

    // See if the default listview font has no internal leading.
    // If not, then we have to inflate the focus rectangle so we
    // don't overlap the first pixel.
    //
    // Note that this is a global and not per-TextOut.
    // Otherwise controls with a mix of fonts will get
    // inconsistently-placed focus rectangles.
    //
    hfStatus = CCCreateStatusFont();
    if (hfStatus)
    {
        HDC hdc = GetDC(hwnd);
        if (hdc)
        {
            HFONT hfPrev = SelectFont(hdc, hfStatus);
            if (GetTextMetrics(hdc, &tm) &&
                tm.tmInternalLeading == 0)
            {
                g_cyCompensateInternalLeading = 1;
            }
            SelectFont(hdc, hfPrev);
            ReleaseDC(hwnd, hdc);
        }

        DeleteObject(hfStatus);
    }

    lpci->bUnicode = lpci->hwndParent &&
                     SendMessage (lpci->hwndParent, WM_NOTIFYFORMAT,
                                 (WPARAM)lpci->hwnd, NF_QUERY) == NFR_UNICODE;

    if (lpci->hwndParent)
    {
        LRESULT lRes = SendMessage(lpci->hwndParent, WM_QUERYUISTATE, 0, 0);
            lpci->wUIState = LOWORD(lRes);
    }
}

LRESULT CIHandleNotifyFormat(LPCCONTROLINFO lpci, LPARAM lParam)
{
    if (lParam == NF_QUERY) 
    {
        return NFR_UNICODE;
    } 
    else if (lParam == NF_REQUERY) 
    {
        LRESULT uiResult;

        uiResult = SendMessage (lpci->hwndParent, WM_NOTIFYFORMAT,
                                (WPARAM)lpci->hwnd, NF_QUERY);

        lpci->bUnicode = BOOLIFY(uiResult == NFR_UNICODE);

        return uiResult;
    }
    return 0;
}

UINT CCSwapKeys(WPARAM wParam, UINT vk1, UINT vk2)
{
    if (wParam == vk1)
        return vk2;
    if (wParam == vk2)
        return vk1;
    return (UINT)wParam;
}

UINT RTLSwapLeftRightArrows(CCONTROLINFO *pci, WPARAM wParam)
{
    if (pci->dwExStyle & RTL_MIRRORED_WINDOW) 
    {
        return CCSwapKeys(wParam, VK_LEFT, VK_RIGHT);
    }
    return (UINT)wParam;
}

//
//  New for v5.01:
//
//  Accessibility (and some other callers, sometimes even us) relies on
//  a XXM_GETITEM call filling the buffer and not just redirecting the
//  pointer.  Accessibility is particularly impacted by this because they
//  live outside the process, so the redirected pointer means nothing
//  to them.  Here, we copy the result back into the app buffer and return
//  the raw pointer.  The caller will return the raw pointer back to the
//  app, so the answer is in two places, either the app buffer, or in
//  the raw pointer.
//
//  Usage:
//
//      if (nm.item.mask & LVIF_TEXT)
//          pitem->pszText = CCReturnDispInfoText(nm.item.pszText,
//                              pitem->pszText, pitem->cchTextMax);
//
LPTSTR CCReturnDispInfoText(LPTSTR pszSrc, LPTSTR pszDest, UINT cchDest)
{
    // Test pszSrc != pszDest first since the common case is that they
    // are equal.
    if (pszSrc != pszDest && !IsFlagPtr(pszSrc) && !IsFlagPtr(pszDest))
    {
        StringCchCopy(pszDest, cchDest, pszSrc);
    }

    return pszSrc;
}

#define SUBSCROLLS 100
#define abs(x) ( ( x > 0 ) ? x : -x)


#define DEFAULT_MAXSCROLLTIME ((GetDoubleClickTime() / 2) + 1)  // Ensure >= 1
#define DEFAULT_MINSCROLL 8
int SmoothScrollWindow(PSMOOTHSCROLLINFO psi)
{
    int dx = psi->dx;
    int dy = psi->dy;
    LPCRECT lprcSrc = psi->lprcSrc;
    LPCRECT lprcClip = psi->lprcClip;
    HRGN hrgnUpdate = psi->hrgnUpdate;
    LPRECT lprcUpdate = psi->lprcUpdate;
    UINT fuScroll = psi->fuScroll;
    int iRet = SIMPLEREGION;
    RECT rcUpdate;
    RECT rcSrc;
    RECT rcClip;
    int xStep;
    int yStep;
    int iSlicesDone = 0;
    int iSlices;
    DWORD dwTimeStart, dwTimeNow;
    HRGN hrgnLocalUpdate;
    UINT cxMinScroll = psi->cxMinScroll;
    UINT cyMinScroll = psi->cyMinScroll;
    UINT uMaxScrollTime = psi->uMaxScrollTime;
    int iSubScrolls;
    PFNSMOOTHSCROLLPROC pfnScrollProc;
    DWORD dwRedrawFlags = RDW_ERASE | RDW_ERASENOW | RDW_INVALIDATE;

    if (!lprcUpdate)
        lprcUpdate = &rcUpdate;

    SetRectEmpty(lprcUpdate);

    if (psi->cbSize != sizeof(SMOOTHSCROLLINFO))
    {
        return 0;
    }

    // check the defaults
    if (!(psi->fMask & SSIF_MINSCROLL )
        || cxMinScroll == SSI_DEFAULT)
    {
        cxMinScroll = DEFAULT_MINSCROLL;
    }

    if (!(psi->fMask & SSIF_MINSCROLL)
        || cyMinScroll == SSI_DEFAULT)
    {
        cyMinScroll = DEFAULT_MINSCROLL;
    }

    if (!(psi->fMask & SSIF_MAXSCROLLTIME)
        || uMaxScrollTime == SSI_DEFAULT)
    {
        uMaxScrollTime = DEFAULT_MAXSCROLLTIME;
    }

    if (uMaxScrollTime < SUBSCROLLS)
    {
        uMaxScrollTime = SUBSCROLLS;
    }


    if ((!(fuScroll & SSW_EX_IGNORESETTINGS)) &&
        (!g_fSmoothScroll))
    {
        fuScroll |= SSW_EX_IMMEDIATE;
    }

    if ((psi->fMask & SSIF_SCROLLPROC) && psi->pfnScrollProc)
    {
        pfnScrollProc = psi->pfnScrollProc;
    }
    else 
    {
        pfnScrollProc = ScrollWindowEx;
    }

#ifdef ScrollWindowEx
#undef ScrollWindowEx
#endif

    if (fuScroll & SSW_EX_IMMEDIATE) 
    {
        return pfnScrollProc(psi->hwnd, dx, dy, lprcSrc, lprcClip, hrgnUpdate,
                             lprcUpdate, LOWORD(fuScroll));
    }

    if (fuScroll & SSW_EX_UPDATEATEACHSTEP)
    {
        dwRedrawFlags |= RDW_UPDATENOW;
    }

    // copy input rects locally
    if (lprcSrc) 
    {
        rcSrc = *lprcSrc;
        lprcSrc = &rcSrc;
    }
    if (lprcClip)
    {
        rcClip = *lprcClip;
        lprcClip = &rcClip;
    }

    if (!hrgnUpdate)
        hrgnLocalUpdate = CreateRectRgn(0,0,0,0);
    else
        hrgnLocalUpdate = hrgnUpdate;

    //set up initial vars
    dwTimeStart = GetTickCount();

    if (fuScroll & SSW_EX_NOTIMELIMIT)
    {
        xStep = cxMinScroll * (dx < 0 ? -1 : 1);
        yStep = cyMinScroll * (dy < 0 ? -1 : 1);
    }
    else
    {
        iSubScrolls = (uMaxScrollTime / DEFAULT_MAXSCROLLTIME) * SUBSCROLLS;
        if (!iSubScrolls)
            iSubScrolls = SUBSCROLLS;
        xStep = dx / iSubScrolls;
        yStep = dy / iSubScrolls;
    }

    if (xStep == 0 && dx)
        xStep = dx < 0 ? -1 : 1;

    if (yStep == 0 && dy)
        yStep = dy < 0 ? -1 : 1;

    while (dx || dy)
    {
        int x,y;
        RECT rcTempUpdate;

        if (fuScroll & SSW_EX_NOTIMELIMIT) 
        {
            x = xStep;
            y = yStep;
            if (abs(x) > abs(dx))
                x = dx;

            if (abs(y) > abs(dy))
                y = dy;

        }
        else
        {
            int iTimePerScroll = uMaxScrollTime / iSubScrolls;
            if (!iTimePerScroll)
                iTimePerScroll = 1;
            
            dwTimeNow = GetTickCount();

            iSlices = ((dwTimeNow - dwTimeStart) / iTimePerScroll) - iSlicesDone;
            if (iSlices < 0)
                iSlices = 0;
            do 
            {

                int iRet = 0;

                iSlices++;
                if ((iSlicesDone + iSlices) <= iSubScrolls) 
                {
                    x = xStep * iSlices;
                    y = yStep * iSlices;

                    // this could go over if we rounded ?Step up to 1(-1) above
                    if (abs(x) > abs(dx))
                        x = dx;

                    if (abs(y) > abs(dy))
                        y = dy;

                }
                else 
                {
                    x = dx;
                    y = dy;
                }

                //DebugMsg(DM_TRACE, "SmoothScrollWindowCallback %d", iRet);

                if (x == dx && y == dy)
                    break;

                if ((((UINT)(abs(x)) >= cxMinScroll) || !x) &&
                    (((UINT)(abs(y)) >= cyMinScroll) || !y))
                    break;

            }
            while (1);
        }

        if (pfnScrollProc(psi->hwnd, x, y, lprcSrc, lprcClip, hrgnLocalUpdate, &rcTempUpdate, LOWORD(fuScroll)) == ERROR) 
        {
            iRet = ERROR;
            goto Bail;
        }

        UnionRect(lprcUpdate, &rcTempUpdate, lprcUpdate);

        RedrawWindow(psi->hwnd, NULL, hrgnLocalUpdate, dwRedrawFlags);

        ScrollShrinkRect(x,y, (LPRECT)lprcSrc);

        dx -= x;
        dy -= y;
        iSlicesDone += iSlices;
    }

Bail:
    if (fuScroll & SW_SCROLLCHILDREN) 
    {
        RedrawWindow(psi->hwnd, lprcUpdate, NULL, RDW_ERASE | RDW_UPDATENOW | RDW_INVALIDATE);
    }

    if (hrgnLocalUpdate != hrgnUpdate)
        DeleteObject(hrgnLocalUpdate);

    return iRet;
}

#define CCH_KEYMAX 256

void CCPlaySound(LPCTSTR lpszName)
{
    TCHAR szFileName[MAX_PATH];
    LONG cbSize = SIZEOF(szFileName);
    TCHAR szKey[CCH_KEYMAX];

    // check the registry first
    // if there's nothing registered, we blow off the play,
    // but we don't set the MM_DONTLOAD flag so taht if they register
    // something we will play it
    StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT("AppEvents\\Schemes\\Apps\\.Default\\%s\\.current"), lpszName);
    if ((RegQueryValue(HKEY_CURRENT_USER, szKey, szFileName, &cbSize) == ERROR_SUCCESS) &&
        (cbSize > SIZEOF(szFileName[0])))
    {
        PlaySound(szFileName, NULL, SND_FILENAME | SND_ASYNC);
    }
}

BOOL CCForwardEraseBackground(HWND hwnd, HDC hdc)
{
    HWND hwndParent = GetParent(hwnd);
    LRESULT lres = 0;

    if (hwndParent)
    {
        // Adjust the origin so the parent paints in the right place
        POINT pt = {0,0};

        MapWindowPoints(hwnd, hwndParent, &pt, 1);
        OffsetWindowOrgEx(hdc, 
                          pt.x, 
                          pt.y, 
                          &pt);

        lres = SendMessage(hwndParent, WM_ERASEBKGND, (WPARAM) hdc, 0L);

        SetWindowOrgEx(hdc, pt.x, pt.y, NULL);
    }
    return(lres != 0);
}

HFONT CCGetHotFont(HFONT hFont, HFONT *phFontHot)
{
    if (!*phFontHot) {
        LOGFONT lf;

        // create the underline font
        GetObject(hFont, sizeof(lf), &lf);
#ifndef DONT_UNDERLINE
        lf.lfUnderline = TRUE;
#endif
        *phFontHot = CreateFontIndirect(&lf);
    }
    return *phFontHot;
}


HFONT CCCreateStatusFont(void)
{
    NONCLIENTMETRICS ncm;

    ncm.cbSize = sizeof(NONCLIENTMETRICS);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

    return CreateFontIndirect(&ncm.lfStatusFont);
}

HFONT CCCreateUnderlineFont(HFONT hf)
{
    HFONT hUnderline = NULL;
    LOGFONT lf;
    if (hf && GetObject(hf, sizeof(lf), &lf))
    {
        lf.lfUnderline = TRUE;
        hUnderline = CreateFontIndirect(&lf);
    }

    return hUnderline;
}


void* CCLocalReAlloc(void* p, UINT uBytes)
{
    if (uBytes) {
        if (p) {
            return LocalReAlloc(p, uBytes, LMEM_MOVEABLE | LMEM_ZEROINIT);
        } else {
            return LocalAlloc(LPTR, uBytes);
        }
    } else {
        if (p)
            LocalFree(p);
        return NULL;
    }
}

/*----------------------------------------------------------
Purpose: This function provides the commctrl version info.  This
         allows the caller to distinguish running NT SUR vs.
         Win95 shell vs. Nashville, etc.

         This API was not supplied in Win95 or NT SUR, so
         the caller must GetProcAddress it.  If this fails,
         the caller is running on Win95 or NT SUR.

Returns: NO_ERROR
         ERROR_INVALID_PARAMETER if pinfo is invalid

Cond:    --
*/

// All we have to do is declare this puppy and CCDllGetVersion does the rest
// Note that we use VER_FILEVERSION_DW because comctl32 uses a funky
// version scheme
DLLVER_DUALBINARY(VER_FILEVERSION_DW, VER_PRODUCTBUILD_QFE);

//
// Translate the given font to a code page used for thunking text
//
UINT GetCodePageForFont(HFONT hFont)
{
    LOGFONT lf;
    TCHAR szFontName[LF_FACESIZE];
    CHARSETINFO csi;
    DWORD dwSize, dwType;
    HKEY hKey;


    if (!GetObject (hFont, sizeof(lf), &lf))
    {
        return CP_ACP;
    }


    //
    // Check for font substitutes
    //

    StringCchCopy(szFontName, ARRAYSIZE(szFontName), lf.lfFaceName);

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = SIZEOF(szFontName);
        RegQueryValueEx(hKey, lf.lfFaceName, NULL, &dwType, (LPBYTE)szFontName, &dwSize);
        RegCloseKey (hKey);
    }

    //
    //  This is to fix office for locales that use non 1252 versions
    //  of Ms Sans Serif and Ms Serif.  These fonts incorrectly identify
    //  themselves as having an Ansi charset, so TranslateCharsetInfo will
    //  return the wrong value.
    //
    //  NT bug 260697: Office 2000 uses Tahoma.
    //
    if ((lf.lfCharSet == ANSI_CHARSET) &&
        (!lstrcmpi(L"Helv", szFontName) ||
         !lstrcmpi(L"Ms Sans Serif", szFontName) ||
         !lstrcmpi(L"Ms Serif", szFontName) ||
         !lstrcmpi(L"Tahoma", szFontName)))
    {
        return CP_ACP;
    }
    //
    //  This is to fix FE office95a and Pro. msofe95.dll sets wrong charset when create
    //  listview control. so TranslateCharsetInfo will return the wrong value.
    //  Korea  : DotumChe.
    //  Taiwan : New MingLight
    //  China  : SongTi

    if ((lf.lfCharSet == SHIFTJIS_CHARSET) &&
        (!lstrcmpi(L"\xb3cb\xc6c0\xccb4", lf.lfFaceName))        || // Korea
        (!lstrcmpi(L"\x65b0\x7d30\x660e\x9ad4", lf.lfFaceName))  || // Taiwan
        (!lstrcmpi(L"\x5b8b\x4f53", lf.lfFaceName)))                // PRC
    {
        return CP_ACP;
    }

    if (!TranslateCharsetInfo((DWORD *) lf.lfCharSet, &csi, TCI_SRCCHARSET)) {
        return CP_ACP;
    }

    return csi.ciACP;
}

LONG GetMessagePosClient(HWND hwnd, LPPOINT ppt)
{
    LPARAM lParam;
    POINT pt;
    if (!ppt)
        ppt = &pt;
    
    lParam = GetMessagePos();
    ppt->x = GET_X_LPARAM(lParam);
    ppt->y = GET_Y_LPARAM(lParam);
    ScreenToClient(hwnd, ppt);

    return MAKELONG(ppt->x, ppt->y);
}


LPTSTR StrDup(LPCTSTR lpsz)
{
    DWORD  cchRet = (lstrlen(lpsz) + 1);
    LPTSTR lpszRet = (LPTSTR)LocalAlloc(LPTR, cchRet * sizeof(TCHAR));

    if (lpszRet)
    {
        StringCchCopy(lpszRet, cchRet,  lpsz);
    }

    return lpszRet;
}

LPSTR StrDupA(LPCSTR lpsz)
{
    DWORD cchRet = (lstrlenA(lpsz) + 1);
    LPSTR lpszRet = (LPSTR)LocalAlloc(LPTR, cchRet * sizeof(CHAR));

    if (lpszRet)
    {
        StringCchCopyA(lpszRet, cchRet, lpsz);
    }

    return lpszRet;
}

HWND GetDlgItemRect(HWND hDlg, int nIDItem, LPRECT prc) //relative to hDlg
{
    HWND hCtrl = NULL;
    if (prc)
    {
        hCtrl = GetDlgItem(hDlg, nIDItem);
        if (hCtrl)
        {
            GetWindowRect(hCtrl, prc);
            MapWindowRect(NULL, hDlg, prc);
        }
        else
            SetRectEmpty(prc);
    }
    return hCtrl;
} 


/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

*/
HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            hr = pfnri(g_hinst, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

/*----------------------------------------------------------
Purpose: Install/uninstall user settings

*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hres = S_OK;
#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllInstall");
        DEBUG_BREAK;
    }
#endif

    if (bInstall)
    {
        // Delete any old registration entries, then add the new ones.
        // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
        // (The inf engine doesn't guarantee DelReg/AddReg order, that's
        // why we explicitly unreg and reg here.)
        //
        CallRegInstall("RegDll");

    }
    else
    {
        CallRegInstall("UnregDll");
    }

    return hres;    
}    



//---------------------------------------------------------------------------------------
void FlipRect(LPRECT prc)
{
    SWAP(prc->left, prc->top, int);
    SWAP(prc->right, prc->bottom, int);
}


//---------------------------------------------------------------------------------------
//
//  Returns previous window bits.

DWORD SetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue)
{
    DWORD dwStyle;
    DWORD dwNewStyle;

    dwStyle = GetWindowLong(hWnd, iWhich);
    dwNewStyle = ( dwStyle & ~dwBits ) | (dwValue & dwBits);
    if (dwStyle != dwNewStyle) {
        dwStyle = SetWindowLong(hWnd, iWhich, dwNewStyle);
    }
    return dwStyle;
}

//---------------------------------------------------------------------------------------

BOOL CCDrawEdge(HDC hdc, LPRECT lprc, UINT edge, UINT flags, LPCOLORSCHEME lpclrsc)
{
    RECT    rc, rcD;
    UINT    bdrType;
    COLORREF clrTL, clrBR;    

    //
    // Enforce monochromicity and flatness
    //    

    // if (oemInfo.BitCount == 1)
    //    flags |= BF_MONO;
    if (flags & BF_MONO)
        flags |= BF_FLAT;    

    CopyRect(&rc, lprc);

    //
    // Draw the border segment(s), and calculate the remaining space as we
    // go.
    //
    if (bdrType = (edge & BDR_OUTER))
    {
DrawBorder:
        //
        // Get colors.  Note the symmetry between raised outer, sunken inner and
        // sunken outer, raised inner.
        //

        if (flags & BF_FLAT)
        {
            if (flags & BF_MONO)
                clrBR = (bdrType & BDR_OUTER) ? g_clrWindowFrame : g_clrWindow;
            else
                clrBR = (bdrType & BDR_OUTER) ? g_clrBtnShadow: g_clrBtnFace;
            
            clrTL = clrBR;
        }
        else
        {
            // 5 == HILIGHT
            // 4 == LIGHT
            // 3 == FACE
            // 2 == SHADOW
            // 1 == DKSHADOW

            switch (bdrType)
            {
                // +2 above surface
                case BDR_RAISEDOUTER:           // 5 : 4
                    clrTL = ((flags & BF_SOFT) ? g_clrBtnHighlight : g_clr3DLight);
                    clrBR = g_clr3DDkShadow;     // 1
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnHighlight;
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnShadow;
                    }                                            
                    break;

                // +1 above surface
                case BDR_RAISEDINNER:           // 4 : 5
                    clrTL = ((flags & BF_SOFT) ? g_clr3DLight : g_clrBtnHighlight);
                    clrBR = g_clrBtnShadow;       // 2
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnHighlight;
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnShadow;
                    }                                            
                    break;

                // -1 below surface
                case BDR_SUNKENOUTER:           // 1 : 2
                    clrTL = ((flags & BF_SOFT) ? g_clr3DDkShadow : g_clrBtnShadow);
                    clrBR = g_clrBtnHighlight;      // 5
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnShadow;
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnHighlight;                        
                    }
                    break;

                // -2 below surface
                case BDR_SUNKENINNER:           // 2 : 1
                    clrTL = ((flags & BF_SOFT) ? g_clrBtnShadow : g_clr3DDkShadow);
                    clrBR = g_clr3DLight;        // 4
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnShadow;
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnHighlight;                        
                    }
                    break;

                default:
                    return(FALSE);
            }
        }

        //
        // Draw the sides of the border.  NOTE THAT THE ALGORITHM FAVORS THE
        // BOTTOM AND RIGHT SIDES, since the light source is assumed to be top
        // left.  If we ever decide to let the user set the light source to a
        // particular corner, then change this algorithm.
        //
            
        // Bottom Right edges
        if (flags & (BF_RIGHT | BF_BOTTOM))
        {            
            // Right
            if (flags & BF_RIGHT)
            {       
                rc.right -= g_cxBorder;
                // PatBlt(hdc, rc.right, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rcD.left = rc.right;
                rcD.right = rc.right + g_cxBorder;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom;

                FillRectClr(hdc, &rcD, clrBR);
            }
            
            // Bottom
            if (flags & BF_BOTTOM)
            {
                rc.bottom -= g_cyBorder;
                // PatBlt(hdc, rc.left, rc.bottom, rc.right - rc.left, g_cyBorder, PATCOPY);
                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.bottom;
                rcD.bottom = rc.bottom + g_cyBorder;

                FillRectClr(hdc, &rcD, clrBR);
            }
        }
        
        // Top Left edges
        if (flags & (BF_TOP | BF_LEFT))
        {
            // Left
            if (flags & BF_LEFT)
            {
                // PatBlt(hdc, rc.left, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rc.left += g_cxBorder;

                rcD.left = rc.left - g_cxBorder;
                rcD.right = rc.left;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom; 

                FillRectClr(hdc, &rcD, clrTL);
            }
            
            // Top
            if (flags & BF_TOP)
            {
                // PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, g_cyBorder, PATCOPY);
                rc.top += g_cyBorder;

                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.top - g_cyBorder;
                rcD.bottom = rc.top;

                FillRectClr(hdc, &rcD, clrTL);
            }
        }
        
    }

    if (bdrType = (edge & BDR_INNER))
    {
        //
        // Strip this so the next time through, bdrType will be 0.
        // Otherwise, we'll loop forever.
        //
        edge &= ~BDR_INNER;
        goto DrawBorder;
    }

    //
    // Fill the middle & clean up if asked
    //
    if (flags & BF_MIDDLE)    
        FillRectClr(hdc, &rc, (flags & BF_MONO) ? g_clrWindow : g_clrBtnFace);

    if (flags & BF_ADJUST)
        CopyRect(lprc, &rc);

    return(TRUE);
}

BOOL CCThemeDrawEdge(HTHEME hTheme, HDC hdc, PRECT prc, int iPart, int iState, UINT edge, UINT flags, LPCOLORSCHEME pclrsc)
{
    RECT rc;
    if (!hTheme)
        return CCDrawEdge(hdc, prc, edge, flags, pclrsc);

    return S_OK == DrawThemeEdge(hTheme, hdc, iPart, iState, prc, edge, flags, &rc);
}



//---------------------------------------------------------------------------------------
//CCInvalidateFrame -- SWP_FRAMECHANGED, w/o all the extra params
//
void CCInvalidateFrame(HWND hwnd)
{
    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_FRAMECHANGED|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
    return;
}

//---------------------------------------------------------------------------------------
// FlipPoint - flip the x and y coordinates of a point
//
void FlipPoint(LPPOINT lppt)
{
    SWAP(lppt->x, lppt->y, int);
}

//
//  When we want to turn a tooltip into an infotip, we set its
//  width to 300 "small pixels", where there are 72 small pixels
//  per inch when you are in small fonts mode.
//
//  Scale this value based on the magnification in effect
//  on the owner's monitor.  But never let the tooltip get
//  bigger than 3/4 of the screen.
//
void CCSetInfoTipWidth(HWND hwndOwner, HWND hwndToolTips)
{
    HDC hdc = GetDC(hwndOwner);
    int iWidth = MulDiv(GetDeviceCaps(hdc, LOGPIXELSX), 300, 72);
    int iMaxWidth = GetDeviceCaps(hdc, HORZRES) * 3 / 4;
    SendMessage(hwndToolTips, TTM_SETMAXTIPWIDTH, 0, min(iWidth, iMaxWidth));
    ReleaseDC(hwndOwner, hdc);
}

// Mirror a bitmap in a DC (mainly a text object in a DC)
//
// [samera]
//
void MirrorBitmapInDC( HDC hdc , HBITMAP hbmOrig )
{
  HDC     hdcMem;
  HBITMAP hbm;
  BITMAP  bm;


  if( !GetObject( hbmOrig , sizeof(BITMAP) , &bm ))
    return;

  hdcMem = CreateCompatibleDC( hdc );

  if( !hdcMem )
    return;

  hbm = CreateCompatibleBitmap( hdc , bm.bmWidth , bm.bmHeight );

  if( !hbm )
  {
    DeleteDC( hdcMem );
    return;
  }

  //
  // Flip the bitmap
  //
  SelectObject( hdcMem , hbm );
  SET_DC_RTL_MIRRORED(hdcMem);

  BitBlt( hdcMem , 0 , 0 , bm.bmWidth , bm.bmHeight ,
          hdc , 0 , 0 , SRCCOPY );

  SET_DC_LAYOUT(hdcMem,0);

  //
  // The offset by 1 is to solve the off-by-one (in hdcMem) problem. Solved.
  // [samera]
  //
  BitBlt( hdc , 0 , 0 , bm.bmWidth , bm.bmHeight ,
          hdcMem , 0 , 0 , SRCCOPY );


  DeleteDC( hdcMem );
  DeleteObject( hbm );

  return;
}

// returns TRUE if handled
BOOL CCWndProc(CCONTROLINFO* pci, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    if (uMsg >= CCM_FIRST && uMsg < CCM_LAST)
    {
        LRESULT lres = 0;
        switch (uMsg) 
        {
        case CCM_SETUNICODEFORMAT:
            lres = pci->bUnicode;
            pci->bUnicode = BOOLFROMPTR(wParam);
            break;

        case CCM_GETUNICODEFORMAT:
            lres = pci->bUnicode;
            break;
            
        case CCM_SETVERSION:
            lres = 6;
            break;

        case CCM_GETVERSION:
            lres = 6;
            break;

        case CCM_DPISCALE:
            pci->fDPIAware = (BOOL)wParam;
            lres = 1;
            break;

        }
        
        ASSERT(plres);
        *plres = lres;
        
        return TRUE;
    }
    
    return FALSE;
}

// Draws an insertmark.
void CCDrawInsertMark(HDC hdc, LPRECT prc, BOOL fHorizMode, COLORREF clr)
{
    HPEN hPnMark = CreatePen(PS_SOLID, 1, clr);
    HPEN hOldPn;
    POINT rgPoint[4];
    if (!hPnMark)
        hPnMark = (HPEN)GetStockObject(BLACK_PEN);    // fallback to draw with black pen
    hOldPn = (HPEN)SelectObject(hdc, (HGDIOBJ)hPnMark);

    if ( fHorizMode )
    {
        if (RECTWIDTH(*prc)>INSERTMARKSIZE && RECTHEIGHT(*prc)>3)
        {
            int iXCentre = prc->left + RECTWIDTH(*prc)/2;  // make sure we truncate towards prc->left (not towards 0!)

            rgPoint[0].x = iXCentre + 1;
            rgPoint[0].y = prc->top + 2;
            rgPoint[1].x = iXCentre + 3;
            rgPoint[1].y = prc->top;
            rgPoint[2].x = iXCentre - 2;
            rgPoint[2].y = prc->top;
            rgPoint[3].x = iXCentre;
            rgPoint[3].y = prc->top + 2;

            ASSERT(rgPoint[0].x >= prc->left && rgPoint[0].x < prc->right && rgPoint[0].y >= prc->top && rgPoint[0].y < prc->bottom);
            ASSERT(rgPoint[1].x >= prc->left && rgPoint[1].x < prc->right && rgPoint[1].y >= prc->top && rgPoint[1].y < prc->bottom);
            ASSERT(rgPoint[2].x >= prc->left && rgPoint[2].x < prc->right && rgPoint[2].y >= prc->top && rgPoint[2].y < prc->bottom);
            ASSERT(rgPoint[3].x >= prc->left && rgPoint[3].x < prc->right && rgPoint[3].y >= prc->top && rgPoint[3].y < prc->bottom);

            // draw the top bit...
            Polyline( hdc, rgPoint, 4 );

            rgPoint[0].x = iXCentre;
            rgPoint[0].y = prc->top;
            rgPoint[1].x = iXCentre;
            rgPoint[1].y = prc->bottom - 1;
            rgPoint[2].x = iXCentre + 1;
            rgPoint[2].y = prc->bottom - 1;
            rgPoint[3].x = iXCentre + 1;
            rgPoint[3].y = prc->top;

            ASSERT(rgPoint[0].x >= prc->left && rgPoint[0].x < prc->right && rgPoint[0].y >= prc->top && rgPoint[0].y < prc->bottom);
            ASSERT(rgPoint[1].x >= prc->left && rgPoint[1].x < prc->right && rgPoint[1].y >= prc->top && rgPoint[1].y < prc->bottom);
            ASSERT(rgPoint[2].x >= prc->left && rgPoint[2].x < prc->right && rgPoint[2].y >= prc->top && rgPoint[2].y < prc->bottom);
            ASSERT(rgPoint[3].x >= prc->left && rgPoint[3].x < prc->right && rgPoint[3].y >= prc->top && rgPoint[3].y < prc->bottom);

            // draw the middle...
            Polyline( hdc, rgPoint, 4 );

            rgPoint[0].x = iXCentre + 1;
            rgPoint[0].y = prc->bottom - 3;
            rgPoint[1].x = iXCentre + 3;
            rgPoint[1].y = prc->bottom - 1;
            rgPoint[2].x = iXCentre - 2;
            rgPoint[2].y = prc->bottom - 1;
            rgPoint[3].x = iXCentre;
            rgPoint[3].y = prc->bottom - 3;

            ASSERT(rgPoint[0].x >= prc->left && rgPoint[0].x < prc->right && rgPoint[0].y >= prc->top && rgPoint[0].y < prc->bottom);
            ASSERT(rgPoint[1].x >= prc->left && rgPoint[1].x < prc->right && rgPoint[1].y >= prc->top && rgPoint[1].y < prc->bottom);
            ASSERT(rgPoint[2].x >= prc->left && rgPoint[2].x < prc->right && rgPoint[2].y >= prc->top && rgPoint[2].y < prc->bottom);
            ASSERT(rgPoint[3].x >= prc->left && rgPoint[3].x < prc->right && rgPoint[3].y >= prc->top && rgPoint[3].y < prc->bottom);

            // draw the bottom bit...
            Polyline( hdc, rgPoint, 4 );
        }
    }
    else
    {
        if (RECTHEIGHT(*prc)>INSERTMARKSIZE && RECTWIDTH(*prc)>3)
        {
            int iYCentre = prc->top + RECTHEIGHT(*prc)/2;   // make sure we truncate towards prc->top (not towards 0!)

            rgPoint[0].x = prc->left + 2;
            rgPoint[0].y = iYCentre;
            rgPoint[1].x = prc->left;
            rgPoint[1].y = iYCentre - 2;
            rgPoint[2].x = prc->left;
            rgPoint[2].y = iYCentre + 3;
            rgPoint[3].x = prc->left + 2;
            rgPoint[3].y = iYCentre + 1;

            ASSERT(rgPoint[0].x >= prc->left && rgPoint[0].x < prc->right && rgPoint[0].y >= prc->top && rgPoint[0].y < prc->bottom);
            ASSERT(rgPoint[1].x >= prc->left && rgPoint[1].x < prc->right && rgPoint[1].y >= prc->top && rgPoint[1].y < prc->bottom);
            ASSERT(rgPoint[2].x >= prc->left && rgPoint[2].x < prc->right && rgPoint[2].y >= prc->top && rgPoint[2].y < prc->bottom);
            ASSERT(rgPoint[3].x >= prc->left && rgPoint[3].x < prc->right && rgPoint[3].y >= prc->top && rgPoint[3].y < prc->bottom);

            // draw the top bit...
            Polyline( hdc, rgPoint, 4 );

            rgPoint[0].x = prc->left;
            rgPoint[0].y = iYCentre;
            rgPoint[1].x = prc->right - 1;
            rgPoint[1].y = iYCentre;
            rgPoint[2].x = prc->right - 1;
            rgPoint[2].y = iYCentre + 1;
            rgPoint[3].x = prc->left;
            rgPoint[3].y = iYCentre + 1;

            ASSERT(rgPoint[0].x >= prc->left && rgPoint[0].x < prc->right && rgPoint[0].y >= prc->top && rgPoint[0].y < prc->bottom);
            ASSERT(rgPoint[1].x >= prc->left && rgPoint[1].x < prc->right && rgPoint[1].y >= prc->top && rgPoint[1].y < prc->bottom);
            ASSERT(rgPoint[2].x >= prc->left && rgPoint[2].x < prc->right && rgPoint[2].y >= prc->top && rgPoint[2].y < prc->bottom);
            ASSERT(rgPoint[3].x >= prc->left && rgPoint[3].x < prc->right && rgPoint[3].y >= prc->top && rgPoint[3].y < prc->bottom);

            // draw the middle...
            Polyline( hdc, rgPoint, 4 );

            rgPoint[0].x = prc->right - 3;
            rgPoint[0].y = iYCentre;
            rgPoint[1].x = prc->right - 1;
            rgPoint[1].y = iYCentre - 2;
            rgPoint[2].x = prc->right - 1;
            rgPoint[2].y = iYCentre + 3;
            rgPoint[3].x = prc->right - 3;
            rgPoint[3].y = iYCentre + 1;

            ASSERT(rgPoint[0].x >= prc->left && rgPoint[0].x < prc->right && rgPoint[0].y >= prc->top && rgPoint[0].y < prc->bottom);
            ASSERT(rgPoint[1].x >= prc->left && rgPoint[1].x < prc->right && rgPoint[1].y >= prc->top && rgPoint[1].y < prc->bottom);
            ASSERT(rgPoint[2].x >= prc->left && rgPoint[2].x < prc->right && rgPoint[2].y >= prc->top && rgPoint[2].y < prc->bottom);
            ASSERT(rgPoint[3].x >= prc->left && rgPoint[3].x < prc->right && rgPoint[3].y >= prc->top && rgPoint[3].y < prc->bottom);

            // draw the bottom bit...
            Polyline( hdc, rgPoint, 4 );
        }
    }

    SelectObject( hdc, hOldPn );
    DeleteObject((HGDIOBJ)hPnMark);
}

BOOL CCGetIconSize(LPCCONTROLINFO pCI, HIMAGELIST himl, int* pcx, int* pcy)
{
    BOOL f = ImageList_GetIconSize(himl, pcx, pcy);
    if (f && pCI->fDPIAware)
    {
        CCDPIScaleX(pcx);
        CCDPIScaleY(pcy);
    }

    return f;
}

// The return value tells if the state changed or not (TRUE == change)
BOOL CCOnUIState(LPCCONTROLINFO pControlInfo,
                                  UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    WORD wOldUIState = pControlInfo->wUIState;

    // That's the only message we handle
    if (WM_UPDATEUISTATE == uMessage)
    {
        switch (LOWORD(wParam))
        {
            case UIS_SET:
                pControlInfo->wUIState |= HIWORD(wParam);
                break;

            case UIS_CLEAR:
                pControlInfo->wUIState &= ~(HIWORD(wParam));
                break;
        }
    }

    // These message always need to be passed to DefWindowProc
    return (wOldUIState != pControlInfo->wUIState);
}

BOOL CCNotifyNavigationKeyUsage(LPCCONTROLINFO pControlInfo, WORD wFlag)
{
    BOOL fRet = FALSE;

    // do something only if not already in keyboard mode
    if ((CCGetUIState(pControlInfo) & (UISF_HIDEFOCUS | UISF_HIDEACCEL)) != wFlag)
    {
        SendMessage(pControlInfo->hwndParent, WM_CHANGEUISTATE, 
            MAKELONG(UIS_CLEAR, wFlag), 0);

        pControlInfo->wUIState &= ~(wFlag);

        // we did the notify
        fRet = TRUE;
    }

    return fRet;
}

BOOL CCGetUIState(LPCCONTROLINFO pControlInfo)
{
    return pControlInfo->wUIState;
}



#ifdef FULL_DEBUG
void DebugPaintInvalid(HWND hwnd, RECT* prc, HRGN rgn)
{
    if (GetKeyState(VK_SCROLL) < 0)
    {
        HDC hdc;
        HBRUSH hbrush;
        int bkMode;
        static int s_iclr;
        static COLORREF s_aclr[] =
        {
                RGB(0,   0,   0), 
                RGB(255, 0,   0), 
                RGB(0,   255, 0),
                RGB(0,   0,   255),
                RGB(255, 255, 0), 
                RGB(0,   255, 255),
                RGB(255, 255, 255), 
                RGB(255, 0,   255),
        };

        s_iclr = (s_iclr + 1) % ARRAYSIZE(s_aclr);
        hdc = GetDC(hwnd);
        hbrush = CreateHatchBrush(HS_DIAGCROSS, s_aclr[s_iclr]);
        bkMode = SetBkMode(hdc, TRANSPARENT);
        if (rgn)
        {
            FillRgn(hdc, rgn, hbrush);
        }
        else
        {
            RECT rc;
            if (prc == NULL)
            {
                prc = &rc;
                GetClientRect(hwnd, &rc);
                OffsetRect(&rc, -rc.left, -rc.top);
            }

            FillRect(hdc, prc, hbrush);
        }
        DeleteObject((HGDIOBJ)hbrush);
        SetBkMode(hdc, bkMode);
        ReleaseDC(hwnd, hdc);

        if (GetKeyState(VK_SHIFT) < 0)
            Sleep(500);
        else
            Sleep(120);
    }
}

void DebugPaintClip(HWND hwnd, HDC hdc)
{
    if (GetKeyState(VK_SCROLL) < 0)
    {
        HDC hdcH = GetDC(hwnd);
        HRGN hrgn = CreateRectRgn(0, 0, 0, 0);
        GetClipRgn(hdc, hrgn);
        InvertRgn(hdcH, hrgn);

        if (GetKeyState(VK_SHIFT) < 0)
            Sleep(500);
        else
            Sleep(120);

        InvertRgn(hdcH, hrgn);

        DeleteObject(hrgn);

        ReleaseDC(hwnd, hdcH);
    }
}

void DebugPaintRect(HDC hdc, PRECT prc)
{
    if (GetKeyState(VK_SCROLL) < 0)
    {
        HRGN hrgn = CreateRectRgnIndirect(prc);
        InvertRgn(hdc, hrgn);

        if (GetKeyState(VK_SHIFT) < 0)
            Sleep(500);
        else
            Sleep(120);

        InvertRgn(hdc, hrgn);

        DeleteObject(hrgn);
    }
}
#endif



void SHOutlineRectThickness(HDC hdc, const RECT* prc, COLORREF cr, COLORREF crDefault, int cp)
{
    RECT rc;
    COLORREF clrSave = SetBkColor(hdc, cr == CLR_DEFAULT ? crDefault : cr);

    // See if we overflow the bounding rect
    if (IsRectEmpty(prc))
    {
        return;
    }
    
    //top
    rc.left = prc->left;
    rc.top = prc->top;
    rc.right = prc->right;
    rc.bottom = prc->top + cp;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    //left
    rc.left = prc->left;
    rc.top = prc->top;
    rc.right = prc->left + cp;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    //right
    rc.left = prc->right - cp;
    rc.top = prc->top;
    rc.right = prc->right;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    // bottom
    rc.left = prc->left;
    rc.top = prc->bottom - cp;
    rc.right = prc->right;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    SetBkColor(hdc, clrSave);
}

BOOL IsUsingCleartype()
{
    int iSmoothingType = FE_FONTSMOOTHINGSTANDARD;

    SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, &iSmoothingType, 0);

    return FE_FONTSMOOTHINGCLEARTYPE == iSmoothingType;
}

//#define NO_UXTHEME_PRINTING

// Gets the bits from the parent for a rect relative to the client
BOOL CCSendPrintRect(CCONTROLINFO* pci, HDC hdc, RECT* prc)
{
#ifndef NO_UXTHEME_PRINTING


    // Call into UxTheme to get the background image. They have hooks to
    // tell us if an app processed this message.
    return (S_OK == DrawThemeParentBackground(pci->hwnd, hdc, prc));


#else
    HRGN hrgnOld = NULL;
    POINT pt;
    RECT rc;

    if (prc)
    {
        hrgnOld = CreateRectRgn(0,0,0,0);
        // Is there a clipping rgn set on the context already?
        if (GetClipRgn(hdc, hrgnOld) == 0)
        {
            // No, then get rid of the one I just created. NOTE: hrgnOld is NULL meaning we will 
            // remove the region later that we set in this next call to SelectClipRgn
            DeleteObject(hrgnOld);
            hrgnOld = NULL;
        }

        IntersectClipRect(hdc, prc->left, prc->top, prc->right, prc->bottom);
    }

    GetWindowRect(pci->hwnd, &rc);
    MapWindowPoints(NULL, pci->hwndParent, (POINT*)&rc, 2);

    GetViewportOrgEx(hdc, &pt);
    SetViewportOrgEx(hdc, pt.x - rc.left, pt.y - rc.top, NULL);
    SendMessage(pci->hwndParent, WM_PRINTCLIENT, (WPARAM)hdc, (LPARAM)PRF_CLIENT);
    SetViewportOrgEx(hdc, pt.x, pt.y, NULL);

    if (hrgnOld)
    {
        SelectClipRgn(hdc, hrgnOld);
        DeleteObject(hrgnOld);
    }
    return TRUE;
#endif
}

// Gets the bits from the parent for the whole control
BOOL CCSendPrint(CCONTROLINFO* pci, HDC hdc)
{
#ifndef NO_UXTHEME_PRINTING


    // Call into UxTheme to get the background image. They have hooks to
    // tell us if an app processed this message.
    return (S_OK == DrawThemeParentBackground(pci->hwnd, hdc, NULL));



#else
    return CCSendPrintRect(pci, hdc, NULL);
#endif
}

BOOL CCForwardPrint(CCONTROLINFO* pci, HDC hdc)
{
#ifndef NO_UXTHEME_PRINTING


    // Call into UxTheme to get the background image. They have hooks to
    // tell us if an app processed this message.
    return (S_OK == DrawThemeParentBackground(pci->hwnd, hdc, NULL));



#else
    return CCSendPrintRect(pci, hdc, NULL);
#endif
}


BOOL CCShouldAskForBits(CCONTROLINFO* pci, HTHEME hTheme, int iPart, int iState)
{
    // If the control is transparent, we assume composited.
    return !(pci->dwExStyle & WS_EX_TRANSPARENT) &&
            IsThemeBackgroundPartiallyTransparent(hTheme, iPart, iState);
}

BOOL AreAllMonitorsAtLeast(int iBpp)
{
    DISPLAY_DEVICE DisplayDevice = { SIZEOF(DISPLAY_DEVICE) };
    BOOL fAreAllMonitorsAtLeast = TRUE;
    int iEnum = 0;

    while (EnumDisplayDevices(NULL, iEnum, &DisplayDevice, 0))
    {
        if (DisplayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP)
        {

            HDC hdc = CreateDC(NULL, (LPTSTR)DisplayDevice.DeviceName, NULL, NULL);
            if (hdc)
            {
                int iBits = GetDeviceCaps(hdc, BITSPIXEL);

                if (iBits < iBpp)
                    fAreAllMonitorsAtLeast = FALSE;

                DeleteDC(hdc);
            }
        }

        ZeroMemory(&DisplayDevice, SIZEOF(DisplayDevice));
        DisplayDevice.cb = SIZEOF(DisplayDevice);
        iEnum++;
    }

    return fAreAllMonitorsAtLeast;
}


int CCGetScreenDPI()
{
    return g_iDPI;
}

BOOL CCIsHighDPI()
{
    return g_fScale;
}

void CCDPIScaleX(int* x)
{
    if (g_fScale)
        *x = (int)( *x * g_dScaleX);
}

void CCDPIScaleY(int* y)
{
    if (g_fScale)
        *y = (int)( *y * g_dScaleY);
}

void CCAdjustForBold(LOGFONT* plf)
{
    ASSERT(plf);
    plf->lfWeight = FW_BOLD;
}

#ifdef DEBUG
void DumpRgn(ULONGLONG qwFlags, char* trace, HRGN hrgn)
{
    int iSize = GetRegionData(hrgn, 0, NULL);
    if (iSize > 0)
    {
        RGNDATA* rd = (RGNDATA*)LocalAlloc(LPTR, iSize + sizeof(RGNDATA));
        if (rd)
        {
            DWORD i;
            RECT* prc;

            rd->rdh.dwSize = sizeof(rd->rdh);
            rd->rdh.iType = RDH_RECTANGLES;
            GetRegionData(hrgn, iSize, rd);

            prc = (RECT*)&rd->Buffer;
            for (i = 0; i < rd->rdh.nCount; i++)
            {
                TraceMsg(qwFlags, "%s: %d, %d, %d, %d", trace, prc[i].left, prc[i].top, prc[i].right, prc[i].bottom);
            }


            LocalFree(rd);
        }
    }
}
#endif


HDC CCBeginDoubleBuffer(HDC hdcIn, RECT* prc, CCDBUFFER* pdb)
{
    HDC hdc = hdcIn;
    
    ZeroMemory(pdb, sizeof(CCDBUFFER));

    pdb->hPaintDC = hdcIn;
    pdb->rc = *prc;

    pdb->hMemDC = CreateCompatibleDC(hdcIn);
    if (pdb->hMemDC)
    {
        pdb->hMemBm = CreateCompatibleBitmap(hdc, RECTWIDTH(pdb->rc), RECTHEIGHT(pdb->rc));
        if (pdb->hMemBm)
        {

            pdb->hOldBm = (HBITMAP) SelectObject(pdb->hMemDC, pdb->hMemBm);

            // Offset painting to paint in region
            OffsetWindowOrgEx(pdb->hMemDC, pdb->rc.left, pdb->rc.top, NULL);

            pdb->fInitialized = TRUE;

            hdc = pdb->hMemDC;
        }
        else
        {
            DeleteDC(pdb->hMemDC);
        }
    }

    return hdc;
}


void CCEndDoubleBuffer(CCDBUFFER* pdb)
{
    if (pdb->fInitialized)
    {
        BitBlt(pdb->hPaintDC, pdb->rc.left, pdb->rc.top, RECTWIDTH(pdb->rc), RECTHEIGHT(pdb->rc), pdb->hMemDC, pdb->rc.left, pdb->rc.top, SRCCOPY);

        SelectObject(pdb->hMemDC, pdb->hOldBm);

        DeleteObject(pdb->hMemBm);
        DeleteDC(pdb->hMemDC);
    }
}

#ifdef FEATURE_FOLLOW_FOCUS_RECT
HWND g_hwndFocus = NULL;

void CCLostFocus(HWND hwnd)
{
//    if (g_hwndFocus)
//        DestroyWindow(g_hwndFocus);
//    g_hwndFocus = NULL;
}

HDC CreateLayer(RECT* prc)
{
    HDC hdc;
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = RECTWIDTH(*prc);
    bi.bmiHeader.biHeight = RECTHEIGHT(*prc);
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        ULONG* prgb;
        HBITMAP hbmp = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, (void**)&prgb, NULL, 0);
        if (hbmp)
        {
            int z;
            SIZE sz = {RECTWIDTH(*prc), RECTHEIGHT(*prc)};
            RECT rc = {0, 0, sz.cx, sz.cy};
            int iTotalSize = sz.cx * sz.cy;
            DeleteObject(SelectObject(hdc, hbmp));

            InflateRect(&rc, -2, -2);
            SHOutlineRectThickness(hdc, &rc, RGB(0,0,255), RGB(0,0,255), 1);
            for (z = 0; z < iTotalSize; z++)
            {
                if (((PULONG)prgb)[z] != 0)
                    ((PULONG)prgb)[z] = 0xa0000000;
            }

            BlurBitmap(prgb, sz, RGB(0,0,255));
            InflateRect(&rc, -2, -2);
            FillRectClr(hdc, &rc, RGB(0,0,0));
        }
    }

    return hdc;
}


typedef struct tagEffect
{
    HDC hdcImage;
    RECT rcCurrent;
    RECT rcSrc;
    RECT rcDest;
    int iStep;
} Effect;

#define EW_SETFOCUS    WM_USER+1
#define EW_LOSTFOCUS   WM_USER+2

void Effect_GenerateRect(Effect* pe, RECT* prc)
{
    HDC hdcWin = GetDC(g_hwndFocus);

    if (hdcWin)
    {
        BLENDFUNCTION bf = {0};
        POINT pt = {0};
        POINT ptDest = {pe->rcCurrent.left, pe->rcCurrent.top};
        SIZE sz = {RECTWIDTH(*prc), RECTHEIGHT(*prc)};
        if (pe->hdcImage)
            DeleteDC(pe->hdcImage);
        pe->hdcImage = CreateLayer(prc);

        bf.BlendOp = AC_SRC_OVER;
        bf.AlphaFormat = AC_SRC_ALPHA;
        bf.SourceConstantAlpha = 255;


        UpdateLayeredWindow(g_hwndFocus, hdcWin, &ptDest, &sz, pe->hdcImage, &pt, 0, &bf, ULW_ALPHA);

        SetWindowPos(g_hwndFocus, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOACTIVATE | SWP_SHOWWINDOW);

        ReleaseDC(g_hwndFocus, hdcWin);
    }
}


LRESULT EffectWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    Effect* pe = (Effect*)GetWindowLongPtr(hwnd, GWL_USERDATA);
    if ( pe == NULL)
    {
        if (uMsg == WM_NCCREATE)
        {
            pe = LocalAlloc(LPTR, sizeof(Effect));
            SetWindowLong(hwnd, GWL_USERDATA, (LONG)pe);
        }

        if (pe == NULL)
            return 0;
    }
    else switch (uMsg)
    {
    case EW_SETFOCUS:
        {
            RECT* prc = (RECT*)lParam;
            if (IsRectEmpty(&pe->rcCurrent))
                pe->rcSrc = pe->rcCurrent = *prc;

            pe->rcDest = *prc;

            Effect_GenerateRect(pe, prc);

            KillTimer(hwnd, 1);
            pe->rcSrc = pe->rcCurrent;
            pe->iStep = 1;
            SetTimer(hwnd, 2, 5, NULL);
        }
        break;
    case EW_LOSTFOCUS:
        //SetTimer(hwnd, 1, 100, NULL);
        break;

    case WM_TIMER:
        if (wParam == 1)
        {
            DestroyWindow(hwnd);
            g_hwndFocus = NULL;
        }
        else if (wParam == 2)
        {
            BLENDFUNCTION bf = {0};
            POINT pt = {0};
            POINT ptDest;
            SIZE sz;
            if (pe->iStep >= 20 || IsRectEmpty(&pe->rcCurrent) || EqualRect(&pe->rcCurrent, &pe->rcDest))
            {
                pe->rcCurrent = pe->rcDest;
                pe->iStep = 0;
                KillTimer(hwnd, 2);
            }
            else
            {
                pe->rcCurrent.top += (pe->rcDest.top - pe->rcSrc.top) / 20;
                pe->rcCurrent.left += (pe->rcDest.left - pe->rcSrc.left) / 20;
                pe->rcCurrent.right += (pe->rcDest.right - pe->rcSrc.right) / 20;
                pe->rcCurrent.bottom += (pe->rcDest.bottom - pe->rcSrc.bottom) / 20;
                pe->iStep++;
            }

            sz.cx = RECTWIDTH(pe->rcCurrent);
            sz.cy = RECTHEIGHT(pe->rcCurrent);

            ptDest.x = pe->rcCurrent.left;
            ptDest.y = pe->rcCurrent.top;

            Effect_GenerateRect(pe, &pe->rcCurrent);
        }
        break;

    case WM_DESTROY:
        if (pe->hdcImage)
            DeleteDC(pe->hdcImage);
        LocalFree(pe);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 1;
}

void CCSetFocus(HWND hwnd, RECT* prc)
{
    RECT rc;
    if (prc == NULL)
    {
        prc = &rc;
        GetWindowRect(hwnd, &rc);
    }

    InflateRect(prc, 4, 4);

    if (!g_hwndFocus)
    {
        WNDCLASS wc ={0};
        wc.hbrBackground = GetStockObject(BLACK_BRUSH);
        wc.hInstance = HINST_THISDLL;
        wc.lpfnWndProc = EffectWndProc;
        wc.lpszClassName = TEXT("Effect");

        RegisterClass(&wc);

        g_hwndFocus = CreateWindowEx(WS_EX_TRANSPARENT | WS_EX_LAYERED | WS_EX_TOOLWINDOW, TEXT("Effect"),
            NULL, WS_POPUP, prc->left, prc->top, RECTWIDTH(*prc), RECTHEIGHT(*prc), 
            NULL, NULL, HINST_THISDLL, NULL);
    }


    if (g_hwndFocus)
    {
        SendMessage(g_hwndFocus, EW_SETFOCUS, (WPARAM)hwnd, (LPARAM)prc);
    }
}

#endif

BOOL CCDrawNonClientTheme(HTHEME hTheme, HWND hwnd, HRGN hRgnUpdate, HBRUSH hbr, int iPartId, int iStateId)
{
    BOOL fRet = FALSE;
    HDC  hdc;
    DWORD dwFlags = DCX_USESTYLE | DCX_WINDOW | DCX_LOCKWINDOWUPDATE;

    if (hRgnUpdate)
        dwFlags |= DCX_INTERSECTRGN | DCX_NODELETERGN;


    hdc = GetDCEx(hwnd, hRgnUpdate, dwFlags);

    if (hdc)
    {
        RECT rc;
        HRGN hrgn;
        int  cxBorder = g_cxBorder, cyBorder = g_cyBorder;

        if (SUCCEEDED(GetThemeInt(hTheme, iPartId, iStateId, TMT_SIZINGBORDERWIDTH, &cxBorder)))
        {
            cyBorder = cxBorder;
        }

        GetWindowRect(hwnd, &rc);            

        //
        // Create an update region without the client edge
        // to pass to DefWindowProc
        //
        InflateRect(&rc, -g_cxEdge, -g_cyEdge);
        hrgn = CreateRectRgn(rc.left, rc.top, rc.right, rc.bottom);
        if (hrgn)
        {
            if (hRgnUpdate)
            {
                CombineRgn(hrgn, hRgnUpdate, hrgn, RGN_AND);
            }

            //
            // Zero-origin the rect
            //
            OffsetRect(&rc, -rc.left, -rc.top);

            //
            // clip our drawing to the non-client edge
            //
            OffsetRect(&rc, g_cxEdge, g_cyEdge);
            ExcludeClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
            InflateRect(&rc, g_cxEdge, g_cyEdge);

            DrawThemeBackground(hTheme, hdc, iPartId, iStateId, &rc, 0);

            //
            // Fill with the control's brush first since the ThemeBackground
            // border may not be as thick as the client edge
            //
            if ((cxBorder < g_cxEdge) && (cyBorder < g_cyEdge))
            {
                InflateRect(&rc, cxBorder-g_cxEdge, cyBorder-g_cyEdge);
                FillRect(hdc, &rc, hbr);
            }

            DefWindowProc(hwnd, WM_NCPAINT, (WPARAM)hrgn, 0);

            DeleteObject(hrgn);
        }

        ReleaseDC(hwnd, hdc);
        fRet = TRUE;
    }


    return fRet;
}

void FillRectClr(HDC hdc, PRECT prc, COLORREF clr)
{
    COLORREF clrSave = SetBkColor(hdc, clr);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, prc, NULL, 0, NULL);
    SetBkColor(hdc, clrSave);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\cstrings.h ===
extern TCHAR const c_szNULL[];
extern TCHAR const c_szSpace[];
extern TCHAR const c_szTabControlClass[];
extern TCHAR const c_szListViewClass[];
extern TCHAR const c_szHeaderClass[];
extern TCHAR const c_szTreeViewClass[];
extern TCHAR const c_szStatusClass[];
extern TCHAR const c_szSToolTipsClass[];
extern TCHAR const c_szToolbarClass[];
extern TCHAR const c_szReBarClass[];
extern TCHAR const c_szEllipses[];
extern TCHAR const c_szShell[];
extern TCHAR const c_szEdit[];
extern TCHAR const c_szSelect[];

extern const TCHAR s_szUpdownClass[];
extern const TCHAR s_szBUTTONLISTBOX[];
#define s_szEllipses c_szEllipses
#ifdef WANT_SUCKY_HEADER
extern const TCHAR s_szHeaderClass[];
#endif
extern const TCHAR s_szHOTKEY_CLASS[];
extern const TCHAR s_szSTrackBarClass[];
extern const TCHAR s_szPROGRESS_CLASS[];

extern const TCHAR c_szCC32Subclass[];

#define CCHELLIPSES 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\cstrings.c ===
#include "ctlspriv.h"

const TCHAR c_szNULL[] = TEXT("");
const TCHAR c_szSpace[] = TEXT(" ");
const TCHAR c_szTabControlClass[] = WC_TABCONTROL;
const TCHAR c_szListViewClass[] = WC_LISTVIEW;
const TCHAR c_szHeaderClass[] = WC_HEADER;
const TCHAR c_szTreeViewClass[] = WC_TREEVIEW;
const TCHAR c_szStatusClass[] = STATUSCLASSNAME;
const TCHAR c_szSToolTipsClass[] = TOOLTIPS_CLASS;
const TCHAR c_szToolbarClass[] = TOOLBARCLASSNAME;
const TCHAR c_szReBarClass[] = REBARCLASSNAME;
const TCHAR c_szEllipses[] = TEXT("...");
const TCHAR c_szShell[] = TEXT("Shell");
const TCHAR c_szEdit[] = TEXT("EDIT");
const TCHAR c_szSelect[] = TEXT("CCSelect");
const TCHAR s_szUpdownClass[] = UPDOWN_CLASS;
const TCHAR s_szHOTKEY_CLASS[] = HOTKEY_CLASS;
const TCHAR s_szSTrackBarClass[] = TRACKBAR_CLASS;
const TCHAR s_szPROGRESS_CLASS[] = PROGRESS_CLASS;
const TCHAR c_szCC32Subclass[] = TEXT("UxSubclassInfo");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\dlgcset.cpp ===
//
// File: dlgcset.cpp
//
// This file contains the code that implements CNativeFont class.
//
// history:
//     7-21-97 created; 
// 
#include "ctlspriv.h"
#include "ccontrol.h"

#define THISCLASS CNativeFont
#define SUPERCLASS CControl

typedef enum 
{
    FAS_NOTINITIALIZED = 0,
    FAS_DISABLED,
    FAS_ENABLED,
} FASTATUS;

class CNativeFont : public CControl
{
public:
    //Function Memebers
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT NativeFontWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
protected:
    
    CNativeFont();
    
    //Function Members    

    virtual void v_OnPaint(HDC hdc) ;
    virtual LRESULT v_OnCreate();
    virtual void v_OnSize(int x, int y)  {};

    virtual LRESULT v_OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT v_OnNotify(WPARAM wParam, LPARAM lParam);
    virtual DWORD v_OnStyleChanged(WPARAM wParam, LPARAM lParam) { return 0; };    
    
    HRESULT _GetNativeDialogFont(HWND hDlg);
    static HRESULT _GetFontAssocStatus(FASTATUS  *uiAssoced);
    static BOOL _SetFontEnumProc(HWND hwnd, LPARAM lparam);
    static LRESULT _SubclassDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uIdSubclass, ULONG_PTR dwRefData);

    HFONT   m_hfontOrg;
    HFONT   m_hfontNative;
    HFONT   m_hfontDelete;
    typedef struct {
                HFONT hfontSet;
                DWORD dwStyle;
            } NFENUMCHILDDATA;
    static FASTATUS _s_uiFontAssocStatus;
};

// static variable initialization
FASTATUS CNativeFont::_s_uiFontAssocStatus = FAS_NOTINITIALIZED;

// reg keys
static const TCHAR s_szRegFASettings[] = TEXT("System\\CurrentControlSet\\Control\\FontAssoc\\Associated Charset");

CNativeFont::CNativeFont(void)
{
    m_hfontOrg = NULL;
    m_hfontNative = NULL;
    m_hfontDelete = NULL;
}

LRESULT THISCLASS::NativeFontWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CNativeFont *pn = (CNativeFont *)GetWindowLongPtr(hwnd, 0);
    if (uMsg == WM_CREATE) {
        ASSERT(!pn);
        pn = new CNativeFont();
        if (!pn)
            return 0L;
    } 

    if (pn) {
        return pn->v_WndProc(hwnd, uMsg, wParam, lParam);
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void THISCLASS::v_OnPaint(HDC hdc)
{
    return;
}

LRESULT THISCLASS::v_OnCommand(WPARAM wParam, LPARAM lParam)
{
    // forward to parent (do we really need this?)
    return SendMessage(ci.hwndParent, WM_COMMAND, wParam, lParam);
}

LRESULT THISCLASS::v_OnNotify(WPARAM wParam, LPARAM lParam)
{
    // forward to parent
    LPNMHDR lpNmhdr = (LPNMHDR)lParam;
    
    return SendNotifyEx(ci.hwndParent, (HWND) -1,
                         lpNmhdr->code, lpNmhdr, ci.bUnicode);
}

LRESULT THISCLASS::v_OnCreate()
{
    return TRUE;
}

BOOL THISCLASS::_SetFontEnumProc(HWND hwnd, LPARAM lparam)
{
     NFENUMCHILDDATA *  pdt = (NFENUMCHILDDATA *)lparam; 
     BOOL bMatch = FALSE;
     
     if (pdt && pdt->hfontSet)
     {
         if (pdt->dwStyle & NFS_ALL)
         {
             bMatch = TRUE;
         }
         else
         {
             TCHAR szClass[32];
             
             GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
             
             if (pdt->dwStyle & NFS_EDIT)
             {
                 bMatch |= (lstrcmpi(TEXT("Edit"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("RichEdit20A"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("RichEdit20W"), szClass) == 0);
             }
             
             if (pdt->dwStyle & NFS_STATIC)
                 bMatch |= (lstrcmpi(TEXT("Static"), szClass) == 0);
             
             if (pdt->dwStyle & NFS_BUTTON)
                 bMatch |= (lstrcmpi(TEXT("Button"), szClass) == 0);

             if (pdt->dwStyle & NFS_LISTCOMBO)
             {
                 bMatch |= (lstrcmpi(TEXT("ListBox"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("ComboBox"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("ComboBoxEx32"), szClass) == 0);
                 bMatch |= (lstrcmpi(WC_LISTVIEW, szClass) == 0);
             }
         }

         if (bMatch) 
             SendMessage(hwnd, WM_SETFONT, (WPARAM)pdt->hfontSet, MAKELPARAM(FALSE, 0));

         return TRUE;
     }
     else
         return FALSE;
}

LRESULT THISCLASS::_SubclassDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uIdSubclass, ULONG_PTR dwRefData)
{
    LRESULT lret = 0;
    CNativeFont * pnf = (CNativeFont *)dwRefData;
    
    if (pnf)
    {
    
        switch (uMsg)
        {
            case WM_INITDIALOG:
                // we enumerate its children so they get font 
                // in native charset selected if necessary
                // 
                if (S_OK == pnf->_GetNativeDialogFont(hdlg))
                {
                    // S_OK means we have different charset from 
                    // the default of the platform on which we're 
                    // running.
                    NFENUMCHILDDATA dt;
                    dt.hfontSet = pnf->m_hfontNative;
                    dt.dwStyle = pnf->ci.style;
                    EnumChildWindows(hdlg, pnf->_SetFontEnumProc, (LPARAM)&dt);
                }
                // we no longer need subclass procedure.
                // assumes no one has subclassed this dialog by now
                break;

            case WM_DESTROY:
                // if we've created a font, we have to clean it up.
                if (pnf->m_hfontDelete)
                {
                    NFENUMCHILDDATA dt;
                
                    dt.hfontSet = pnf->m_hfontOrg;
                    dt.dwStyle = pnf->ci.style;
                    // just in case anyone is still alive
                    EnumChildWindows(hdlg, pnf->_SetFontEnumProc, (LPARAM)&dt);
                    DeleteObject(pnf->m_hfontDelete);
                    pnf->m_hfontDelete = NULL;
                }
                RemoveWindowSubclass(hdlg, pnf->_SubclassDlgProc, 0);

                break;
        }
    
        lret = DefSubclassProc(hdlg, uMsg, wParam, lParam);
    }
 
    return lret;
}

LRESULT THISCLASS::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hdlg;
    
    switch (uMsg)
    {
        case WM_CREATE:
        // subclass the parent dialog just to get notified for WM_INITDIALOG
            hdlg = GetParent(hwnd);
            if (hdlg)
            {
                // if we had an error just do nothing, we have to succeed in creating
                // window anyway otherwise dialog fails.
                SetWindowSubclass(hdlg, _SubclassDlgProc, 0, (ULONG_PTR)this);
            }
            break;
    }
    return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
}

// _GetNativeDialogFont
//
// Retreive font handle in platform native character set
//
// returns S_OK if the given dialogbox requires setting font
//              in native charset
//         S_FALSE if the given dialogbox already has native
//              charset.
//         E_FAIL if anyother error occurs
//
HRESULT THISCLASS::_GetNativeDialogFont(HWND hDlg)
{
    HRESULT hres = E_FAIL;
    
    if(!m_hfontNative)
    {
        HFONT hfontNative, hfont = GetWindowFont(hDlg);
        LOGFONT lf, lfNative;
        FASTATUS uiFAStat = FAS_NOTINITIALIZED;
        GetObject(hfont, sizeof(LOGFONT), &lf);

        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lfNative, 0);
        
        // there are two cases we don't want to create/set font
        // for the platform native character set.
        // 1) we already have matching character set
        // 2) the platform has 'font assoc' enabled or 'font link'
        //    and our client wants to use it instead of
        //    setting the right character set. (NFS_USEFONTASSOC)
        //    this solution sometimes provides better
        //    appearance (thought it is broken in its 
        //    font metrics) because it would use 
        //    'western font' as is.
        if (ci.style & NFS_USEFONTASSOC)
        {
            _GetFontAssocStatus(&uiFAStat);
        }

        if ( uiFAStat == FAS_ENABLED
           || lfNative.lfCharSet == lf.lfCharSet)
        {
                
            m_hfontOrg = m_hfontNative = hfont;
        }
        else
        {
            // we have non-native charset for the platform
            // Save away the original font first.
            m_hfontOrg = hfont;
            
            // Use the height of original dialog font
            lfNative.lfHeight = lf.lfHeight;
            if (!(hfontNative=CreateFontIndirect(&lfNative)))
            {
                hfontNative = hfont;
            }

            // save it away so we can delete it later
            if (hfontNative != hfont)
                m_hfontDelete = hfont;
        
            // set this variable to avoid calling createfont twice
            // if we get called again.
            m_hfontNative = hfontNative;
        }
    }

    return hres = (m_hfontNative == m_hfontOrg ? S_FALSE : S_OK);
}

//
// _GetFontAssocStatus
//
// synopsis: check to see if the platform has "Font Association"
//           enabled or 'Font Link' capability
//
HRESULT THISCLASS::_GetFontAssocStatus(FASTATUS  *puiAssoced)
{
    HRESULT hr = S_OK;
    ASSERT(puiAssoced);
    
    // I assume the setting won't change without rebooting
    // the system
    //
    if (FAS_NOTINITIALIZED == _s_uiFontAssocStatus)
    {
        // NT5 has fontlink functionality
        _s_uiFontAssocStatus = FAS_ENABLED;
    }
    *puiAssoced = _s_uiFontAssocStatus;

    return hr;
}

extern "C" {
    
BOOL InitNativeFontCtl(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = THISCLASS::NativeFontWndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = WC_NATIVEFONTCTL;
    wc.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1); // NULL;
    wc.style           = CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(LPVOID);
    wc.cbClsExtra      = 0;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\dlgcvt.cpp ===
//
// This module provides the following functions:
//
//      CvtDlgToDlgEx - Converts a DLGTEMPLATE to a DLGTEMPLATEEX
//
//
#include "ctlspriv.h"


#include "dlgcvt.h"

//
// Define the amount (bytes) the stream buffer grows when required.
// It will grow enough to satisfy the required write PLUS this
// amount.
//
#ifdef DEBUG
#   define STREAM_GROW_BYTES 32     // Exercise stream growth.
#else
#   define STREAM_GROW_BYTES 512
#endif

//
// Simple MIN/MAX inline helpers.
//
template <class T>
inline const T& MIN(const T& a, const T& b)
{
    return a < b ? a : b;
}

template <class T>
inline const T& MAX(const T& a, const T& b)
{
    return a > b ? a : b;
}

//
// This class implements a simple dynamic stream that grows as you
// add data to it.  It's modeled after the strstream class provided
// by the C++ std lib.  Unlike the std lib implementation, this one
// doesn't require C++ EH to be enabled.  If comctl32 compiled with
// C++ EH enabled, I would have used strstream instead.
// [brianau - 10/5/98]
// 
class CByteStream
{
    public:
        explicit CByteStream(int cbDefGrow = 512);
        ~CByteStream(void);

        //
        // Used as argument to AlignXXXX member functions.
        //
        enum AlignType { eAlignWrite, eAlignRead };
        //
        // Basic read/write functions.
        //
        int Read(LPVOID pb, int cb);
        int Write(const VOID *pb, int cb);
        //
        // Determine if there was an error when reading or 
        // writing to the stream.
        //
        bool ReadError(void) const
            { return m_bReadErr; }

        bool WriteError(void) const
            { return m_bWriteErr; }
        //
        // Reset the stream read or write pointer.
        //
        void ResetRead(void)
            { m_pbRead = m_pbBuf; m_bReadErr = false; }

        void ResetWrite(void)
            { m_pbWrite = m_pbBuf; m_bWriteErr = false; }
        //
        // Reset the stream.
        //
        void Reset(void);
        //
        // These functions align the read and write stream pointers.
        //
        void AlignReadWord(void)
            { Align(eAlignRead, sizeof(WORD)); }

        void AlignReadDword(void)
            { Align(eAlignRead, sizeof(DWORD)); }

        void AlignReadQword(void)
            { Align(eAlignRead, sizeof(ULONGLONG)); }

        void AlignWriteWord(void)
            { Align(eAlignWrite, sizeof(WORD)); }

        void AlignWriteDword(void)
            { Align(eAlignWrite, sizeof(DWORD)); }

        void AlignWriteQword(void)
            { Align(eAlignWrite, sizeof(ULONGLONG)); }

        //
        // GetBuffer returns the address of the stream buffer in memory.
        // The buffer is "frozen" so it will not be released if the stream
        // object is destroyed.  At this point, you own the buffer.
        // If bPermanent is false, you can call ReleaseBuffer to return 
        // control of the buffer to the stream object.
        //
        LPBYTE GetBuffer(bool bPermanent = false);
        //
        // ReleaseBuffer returns control of the buffer obtained with GetBuffer
        // to the stream object.
        //
        bool ReleaseBuffer(LPBYTE pbBuf);
        //
        // Overload the insertion and extraction operators so we can
        // work like a normal std lib stream class.
        //
        template <class T>
        CByteStream& operator >> (T& x)
            { Read(&x, sizeof(x)); return *this; }

        template <class T>
        CByteStream& operator << (const T& x)
            { Write(&x, sizeof(x)); return *this; }

    private:
        int    m_cbDefGrow;  // Default amount (bytes) to grow when expanding buffer.
        LPBYTE m_pbBuf;      // Addr of allocated buffer.
        LPBYTE m_pbRead;     // Addr for next read.
        LPBYTE m_pbWrite;    // Addr for next write.
        LPBYTE m_pbEnd;      // Addr of byte following last byte in buffer.
        bool   m_bWriteErr;  // Any read errors?
        bool   m_bReadErr;   // Any write errors?
        bool   m_bOwnsBuf;   // true == delete buffer in dtor.

        //
        // Expand the buffer as needed.
        //
        bool GrowBuffer(int cb = 0);
        //
        // Align the read or write buffer pointer.
        // Used internally by the AlignXXXXX member functions.
        //
        void Align(AlignType a, size_t n);
        //
        // Internal consistency checks for debug builds.
        //
        void Validate(void) const;
        //
        // Prevent copy.
        //
        CByteStream(const CByteStream& rhs);
        CByteStream& operator = (const CByteStream& rhs);
};


//
// Class for converting in-memory dialog templates between the two
// structures DLGTEMPLATE <-> DLGTEMPLATEEX.
//
// Currently, the object only converts from DLGTEMPLATE -> DLGTEMPLATEEX.
// It would be simple to create the code for the inverse conversion.  However,
// it's currently not needed so I didn't create it.
//
class CDlgTemplateConverter
{
    public:
        explicit CDlgTemplateConverter(int iCharSet = DEFAULT_CHARSET)
            : m_iCharset(iCharSet),
              m_stm(STREAM_GROW_BYTES) { }

        ~CDlgTemplateConverter(void) { }

        HRESULT DlgToDlgEx(LPDLGTEMPLATE pTemplateIn, LPDLGTEMPLATEEX *ppTemplateOut);

        HRESULT DlgExToDlg(LPDLGTEMPLATEEX pTemplateIn, LPDLGTEMPLATE *ppTemplateOut)
            { return E_NOTIMPL; }

    private:
        int         m_iCharset;
        CByteStream m_stm;       // For converted template.

        HRESULT DlgHdrToDlgEx(CByteStream& s, LPWORD *ppw);
        HRESULT DlgItemToDlgEx(CByteStream& s, LPWORD *ppw);

        HRESULT DlgExHdrToDlg(CByteStream& s, LPWORD *ppw)
            { return E_NOTIMPL; }
        HRESULT DlgExItemToDlg(CByteStream& s, LPWORD *ppw)
            { return E_NOTIMPL; }
        //
        // Copy a string from pszW into a CByteStream object.
        // Copies at most cch chars.  If cch is -1, assumes the string is 
        // nul-terminated and will copy all chars in string including
        // terminating NULL.
        //
        int CopyStringW(CByteStream& stm, LPWSTR pszW, int cch = -1);
        //
        // Prevent copy.
        //
        CDlgTemplateConverter(const CDlgTemplateConverter& rhs);
        CDlgTemplateConverter& operator = (const CDlgTemplateConverter& rhs);
};


//
// Generic alignment function.
// Give it an address and an alignment size and it returns
// the address adjusted for the requested alignment.
//
// n :  2 = 16-bit
//      4 = 32-bit
//      8 = 64-bit
//
LPVOID Align(LPVOID pv, size_t n)
{
    const ULONG_PTR x = static_cast<ULONG_PTR>(n) - 1;
    return reinterpret_cast<LPVOID>((reinterpret_cast<ULONG_PTR>(pv) + x) & ~x);
}

inline LPVOID AlignWord(LPVOID pv)
{
    return ::Align(pv, sizeof(WORD));
}

inline LPVOID AlignDWord(LPVOID pv)
{
    return ::Align(pv, sizeof(DWORD));
}

inline LPVOID AlignQWord(LPVOID pv)
{
    return ::Align(pv, sizeof(ULONGLONG));
}



CByteStream::CByteStream(
    int cbDefGrow
    ) : m_cbDefGrow(MAX(cbDefGrow, 1)),
        m_pbBuf(NULL),
        m_pbRead(NULL),
        m_pbWrite(NULL),
        m_pbEnd(NULL),
        m_bWriteErr(false),
        m_bReadErr(false),
        m_bOwnsBuf(true) 
{ 

}


CByteStream::~CByteStream(
    void
    )
{
    if (m_bOwnsBuf && NULL != m_pbBuf)
    {
        LocalFree(m_pbBuf);
    }
}

//
// Simple checks to validate stream state.
// In non-debug builds, this will be a no-op.
// Use ASSERT_VALIDSTREAM macro.
//
void
CByteStream::Validate(
    void
    ) const
{
    ASSERT(m_pbEnd >= m_pbBuf);
    ASSERT(m_pbWrite >= m_pbBuf);
    ASSERT(m_pbRead >= m_pbBuf);
    ASSERT(m_pbWrite <= m_pbEnd);
    ASSERT(m_pbRead <= m_pbEnd);
}

#ifdef DEBUG
#   define ASSERT_VALIDSTREAM(ps)  ps->Validate()
#else
#   define ASSERT_VALIDSTREAM(ps)
#endif

//
// Read "cb" bytes from the stream and write them to 
// the location specified in "pb".  Return number
// of bytes read.  Note that if we don't "own" the
// buffer (i.e. the client has called GetBuffer but
// not ReleaseBuffer), no read will occur.
//
int 
CByteStream::Read(
    LPVOID pb,
    int cb
    )
{
    ASSERT_VALIDSTREAM(this);

    int cbRead = 0;
    if (m_bOwnsBuf)
    {
        cbRead = MIN(static_cast<int>(m_pbEnd - m_pbRead), cb);
        CopyMemory(pb, m_pbRead, cbRead);
        m_pbRead += cbRead;
        if (cb != cbRead)
            m_bReadErr = true;
    }

    ASSERT_VALIDSTREAM(this);

    return cbRead;
}


//
// Write "cb" bytes from location "pb" into the stream.
// Return number of bytes written.  Note that if we don't "own" the
// buffer (i.e. the client has called GetBuffer but
// not ReleaseBuffer), no write will occur.
//
int 
CByteStream::Write(
    const VOID *pb,
    int cb
    )
{
    ASSERT_VALIDSTREAM(this);

    int cbWritten = 0;
    if (m_bOwnsBuf)
    {
        if (m_pbWrite + cb < m_pbEnd || 
            GrowBuffer(static_cast<int>(m_pbEnd - m_pbBuf) + cb + m_cbDefGrow))
        {
            CopyMemory(m_pbWrite, pb, cb);
            m_pbWrite += cb;
            cbWritten = cb;
        }
        else
            m_bWriteErr = true;
    }

    ASSERT_VALIDSTREAM(this);

    return cbWritten;
}

//
// Reallocate the buffer by cb or m_cbDefGrow.
// Copy existing contents to new buffer.  All internal
// pointers are updated.
//
bool 
CByteStream::GrowBuffer(
    int cb               // optional.  Default is 0 causing us to use m_cbDefGrow.
    )
{
    bool bResult         = false;
    int cbGrow           = 0 < cb ? cb : m_cbDefGrow;
    ULONG_PTR ulReadOfs  = m_pbRead - m_pbBuf;
    ULONG_PTR ulWriteOfs = m_pbWrite - m_pbBuf;
    ULONG_PTR cbAlloc    = m_pbEnd - m_pbBuf;
    LPBYTE pNew = static_cast<LPBYTE>(LocalAlloc(LPTR, cbAlloc + cbGrow));
    if (NULL != pNew)
    {
        if (NULL != m_pbBuf)
        {
            CopyMemory(pNew, m_pbBuf, cbAlloc);
            LocalFree(m_pbBuf);
        }
        m_pbBuf   = pNew;
        m_pbRead  = m_pbBuf + ulReadOfs;
        m_pbWrite = m_pbBuf + ulWriteOfs;
        m_pbEnd   = m_pbBuf + cbAlloc + cbGrow;
        bResult   = true;
    }

    ASSERT_VALIDSTREAM(this);
    return bResult;
}

//
// Align the read or write pointer on the stream.
// The write pointer is aligned by padding skipped bytes with 0.
//
void
CByteStream::Align(
    CByteStream::AlignType a,
    size_t n
    )
{
    static const BYTE fill[8] = {0};
    if (m_bOwnsBuf)
    {
        switch(a)
        {
            case eAlignWrite:
                Write(fill, static_cast<int>(reinterpret_cast<LPBYTE>(::Align(m_pbWrite, n)) - m_pbWrite));
                break;

            case eAlignRead:
                m_pbRead = reinterpret_cast<LPBYTE>(::Align(m_pbRead, n));
                if (m_pbRead >= m_pbEnd)
                    m_bReadErr = true;
                break;

            default:
                break;
        }
    }
    ASSERT_VALIDSTREAM(this);
}


//
// Caller takes ownership of the buffer.
//
LPBYTE 
CByteStream::GetBuffer(
    bool bPermanent       // optional.  Default is false.
    )
{ 
    LPBYTE pbRet = m_pbBuf;
    if (bPermanent)
    {
        //
        // Caller now permanently owns the buffer.
        // Can't return it through ReleaseBuffer().
        // Reset the internal stream control values.
        //
        m_pbBuf = m_pbWrite = m_pbRead = m_pbEnd = NULL;
        m_bWriteErr = m_bReadErr = false;
        m_bOwnsBuf = true;
    }
    else
    {
        //
        // Caller now owns the buffer but it can be returned
        // through ReleaseBuffer().
        //
        m_bOwnsBuf = false; 
    }
    return pbRet; 
}


//
// Take back ownership of the buffer.
// Returns:  
//
//      true   = CByteStream object took back ownership.
//      false  = CByteStream object couldn't take ownership.
//
bool 
CByteStream::ReleaseBuffer(
    LPBYTE pbBuf
    )
{
    if (pbBuf == m_pbBuf)
    {
        m_bOwnsBuf = true;
        return true;
    }
    return false;
}
     

//
// Reset the stream.
//
void 
CByteStream::Reset(
    void
    )
{
    if (NULL != m_pbBuf)
    {
        LocalFree(m_pbBuf);
    }
    m_pbBuf = m_pbWrite = m_pbRead = m_pbEnd = NULL;
    m_bWriteErr = m_bReadErr = false;
    m_bOwnsBuf = true;
}


//
// Copy one or more WORDs from the location provided in "pszW" into
// the stream.  If cch is -1, it's assumed that the string is nul-terminated.
// Returns the number of WCHARs written.
//    
int 
CDlgTemplateConverter::CopyStringW(
    CByteStream& stm,
    LPWSTR pszW,
    int cch
    )
{
    if (-1 == cch)
        cch = lstrlenW(pszW) + 1;
    return stm.Write(pszW, cch * sizeof(WCHAR)) / sizeof(WCHAR);
}

//
// Convert a DLGTEMPLATE structure to a DLGTEMPLATEEX structure.
// pti is the address of the DLGTEMPLATE to be converted.
// ppto points to a LPDLGTEMPLATEEX ptr to receive the address of the
// converted template structure.  Caller is responsible for freeing
// this buffer with LocalFree.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT
CDlgTemplateConverter::DlgToDlgEx(
    LPDLGTEMPLATE pti,
    LPDLGTEMPLATEEX *ppto
    )
{
    HRESULT hr = NOERROR;
    LPWORD pw = reinterpret_cast<LPWORD>(pti);

    *ppto = NULL;

    //
    // Reset the stream.
    //
    m_stm.Reset();
    //
    // Convert DLGTEMPLATE -> DLGTEMPLATEEX
    //
    hr = DlgHdrToDlgEx(m_stm, &pw);
    //
    // Convert each DLGITEMTEMPLATE -> DLGITEMTEMPLATEEX
    //
    for (int i = 0; i < pti->cdit && SUCCEEDED(hr); i++)
    {
        pw = reinterpret_cast<LPWORD>(::AlignDWord(pw));
        m_stm.AlignWriteDword();
        hr = DlgItemToDlgEx(m_stm, &pw);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Return the buffer to the caller.  Buffer is permanently
        // detached from the stream object so the stream's dtor
        // won't free it.
        //
        *ppto = reinterpret_cast<LPDLGTEMPLATEEX>(m_stm.GetBuffer(true));    
    }
    return hr;
};


//
// Convert DLGTEMPLATE -> DLGTEMPLATEEX
//
// s   = Stream to hold converted template.
// ppw = Address of current read pointer into the template being converted.
//       On exit, the referenced pointer is updated with the current read location.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT
CDlgTemplateConverter::DlgHdrToDlgEx(
    CByteStream& s,
    LPWORD *ppw
    )
{
    LPWORD pw = *ppw;
    LPDLGTEMPLATE pt = reinterpret_cast<LPDLGTEMPLATE>(pw);

    //
    // Convert the fixed-length stuff.
    //
    s << static_cast<WORD>(1)                        // wDlgVer
      << static_cast<WORD>(0xFFFF)                   // wSignature
      << static_cast<DWORD>(0)                       // dwHelpID
      << static_cast<DWORD>(pt->dwExtendedStyle)
      << static_cast<DWORD>(pt->style)
      << static_cast<WORD>(pt->cdit)
      << static_cast<short>(pt->x)
      << static_cast<short>(pt->y)
      << static_cast<short>(pt->cx)
      << static_cast<short>(pt->cy);

    //
    // Arrays are always WORD aligned.
    //
    pw = reinterpret_cast<LPWORD>(::AlignWord(reinterpret_cast<LPBYTE>(pw) + sizeof(DLGTEMPLATE)));
    s.AlignWriteWord();

    //
    // Copy the menu array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            //
            // Fall through...
            //
        case 0x0000:
            s << *pw++;
            break;
                        
        default:
            pw += CopyStringW(s, (LPWSTR)pw);
            break;
    };
    //
    // Copy the class array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            //
            // Fall through...
            //
        case 0x0000:
            s << *pw++;
            break;
            
        default:
            pw += CopyStringW(s, (LPWSTR)pw);
            break;
    };
    //
    // Copy the title array.
    //
    switch(*pw)
    {
        case 0x0000:
            s << *pw++;
            break;

        default:
            pw += CopyStringW(s, (LPWSTR)pw);
            break;
    };
    //
    // Copy font information if it's present.
    //
    if (DS_SETFONT & pt->style)
    {
        s << *pw++;                              // pt size
        s << static_cast<WORD>(FW_NORMAL);       // weight (default, not in DLGTEMPLATE)
        s << static_cast<BYTE>(FALSE);           // italic (default, not in DLGTEMPLATE)
        s << static_cast<BYTE>(m_iCharset);        // charset (default if not given, 
                                                 //          not in DLGTEMPLATE)
        pw += CopyStringW(s, (LPWSTR)pw);
    }

    *ppw = pw;

    return s.WriteError() ? E_OUTOFMEMORY : NOERROR;
}


//
// Convert DLGITEMTEMPLATE -> DLGITEMTEMPLATEEX
//
// s   = Stream to hold converted template.
// ppw = Address of current read pointer into the template being converted.
//       On exit, the referenced pointer is updated with the current read location.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT
CDlgTemplateConverter::DlgItemToDlgEx(
    CByteStream& s,
    LPWORD *ppw
    )
{
    LPWORD pw = *ppw;
    LPDLGITEMTEMPLATE pit = reinterpret_cast<LPDLGITEMTEMPLATE>(pw);

    //
    // Convert the fixed-length stuff.
    //
    s << static_cast<DWORD>(0)                     // dwHelpID
      << static_cast<DWORD>(pit->dwExtendedStyle)
      << static_cast<DWORD>(pit->style)
      << static_cast<short>(pit->x)
      << static_cast<short>(pit->y)
      << static_cast<short>(pit->cx)
      << static_cast<short>(pit->cy)
      << static_cast<DWORD>(pit->id);

    //
    // Arrays are always word aligned.
    //
    pw = reinterpret_cast<LPWORD>(::AlignWord(reinterpret_cast<LPBYTE>(pw) + sizeof(DLGITEMTEMPLATE)));
    s.AlignWriteWord();
    //
    // Copy the class array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            s << *pw++;   // Class code.
            break;
            
        default:
            pw += CopyStringW(s, (LPWSTR)pw);
            break;
    };
    //
    // Copy the title array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            s << *pw++;   // Resource ordinal value.
            break;
            
        default:
            pw += CopyStringW(s, (LPWSTR)pw);
            break;
    };
    //
    // Copy the creation data.
    // *pw is either 0 or the number of bytes of creation data,
    // including *pw.
    //
    switch(*pw)
    {
        case 0x0000:
            s << *pw++;
            break;

        default:
            pw += s.Write(pw, *pw) / sizeof(WORD);
            break;
    };

    *ppw = pw;

    return s.WriteError() ? E_OUTOFMEMORY : NOERROR;
}


//
// This is the public function for converting a DLGTEMPLATE to
// a DLGTEMPLATEEX.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT 
CvtDlgToDlgEx(
    LPDLGTEMPLATE pTemplate, 
    LPDLGTEMPLATEEX *ppTemplateExOut,
    int iCharset
    )
{
    CDlgTemplateConverter dtc(iCharset);
    return dtc.DlgToDlgEx(pTemplate, ppTemplateExOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\dlgcvt.h ===
#ifndef _INC_COMCTL32_DLGCVT_H
#define _INC_COMCTL32_DLGCVT_H



#ifndef _INC_WINDOWSX
#   include <windowsx.h>
#endif
#ifndef __CCSTOCK_H__
#   include <ccstock.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif 

HRESULT CvtDlgToDlgEx(LPDLGTEMPLATE pTemplate, LPDLGTEMPLATEEX *ppTemplateExOut, int iCharset);

#ifdef __cplusplus
} // extern "C"
#endif



#endif // _INC_COMCTL32_DLGCVT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\ctlspriv.h ===
#undef STRICT
#define STRICT

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntlsa.h"

#ifndef RC_INVOKED
// disable "non-standard extension" warnings in out code
#pragma warning(disable:4001)

// disable "nonstandard extension used : zero-sized array in struct/union"
// warning from immp.h
#pragma warning(disable:4200)
#endif

#include <w4warn.h>
/*
 *   Level 4 warnings to be turned on.
 *   Do not disable any more level 4 warnings.
 */
#pragma warning(disable:4127) // conditional expression is constant
#pragma warning(disable:4305) // 'type cast' : truncation from 'LPWSTR ' to 'WORD'
#pragma warning(disable:4189) // 'cyRet' : local variable is initialized but not referenced
#pragma warning(disable:4328) // indirection alignment of formal parameter 1 (4) is greater than the actual argument alignment (2)
#pragma warning(disable:4245) // 'initializing' : conversion from 'const int' to 'UINT', signed/unsigned mismatch
#pragma warning(disable:4706) // <func:#77> assignment within conditional expression
#pragma warning(disable:4701) // local variable 'crOldTextColor' may be used without having been initialized
#pragma warning(disable:4057) // 'function' : 'LONG *__ptr64 ' differs in indirection to slightly different base types 'UINT *__ptr64 '
#pragma warning(disable:4267) // 'initializing' : conversion from 'size_t' to 'UINT', possible loss of data
#pragma warning(disable:4131) // 'ComboBox_NcDestroyHandler' : uses old-style declarator
#pragma warning(disable:4310) // cast truncates constant value
#pragma warning(disable:4306) // 'type cast' : conversion from 'BYTE' to 'DWORD *__ptr64 ' of greater size
#pragma warning(disable:4054) // 'type cast' : from function pointer 'FARPROC ' to data pointer 'PLPKEDITCALLOUT '
#pragma warning(disable:4055) // 'type cast' : from data pointer 'IStream *__ptr64 ' to function pointer 'FARPROC '
#pragma warning(disable:4221) // nonstandard extension used : 'lprcClip' : cannot be initialized using address of automatic variable 'rcClip'
#pragma warning(disable:4702) // <func:#191 ".ListView_RedrawSelection"> unreachable code
#pragma warning(disable:4327) // '=' : indirection alignment of LHS (4) is greater than RHS (2)
#pragma warning(disable:4213) // nonstandard extension used : cast on l-value
#pragma warning(disable:4210) // nonstandard extension used : function given file scope


#define _COMCTL32_
#define _INC_OLE
#define _SHLWAPI_
#define CONST_VTABLE

#define CC_INTERNAL
#define OEMRESOURCE     // Get the OEM bitmaps OBM_XXX from winuser.h
#include <windows.h>
#include <uxtheme.h>
#include <tmschema.h>
#include <windowsx.h>
#include <ole2.h>               // to get IStream for image.c
#include <commctrl.h>
#include <wingdip.h>
#include <winuserp.h>
#define NO_SHLWAPI_UNITHUNK     // We have our own private thunks
#include <shlwapi.h>
#include <port32.h>

#define DISALLOW_Assert
#include <debug.h>
#include <winerror.h>
#include <ccstock.h>
#include <imm.h>
#include <immp.h>

#include <shfusion.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


#include "thunk.h"      // Ansi / Wide string conversions
#include "mem.h"
#include "rcids.h"
#include "cstrings.h"

#include "shobjidl.h"
#include <CommonControls.h>
#include "shpriv.h"

#include <strsafe.h>


#ifndef DS_BIDI_RTL
#define DS_BIDI_RTL  0x8000
#endif

#define REGSTR_EXPLORER_ADVANCED TEXT("software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")


#define DCHF_TOPALIGN       0x00000002  // default is center-align
#define DCHF_HORIZONTAL     0x00000004  // default is vertical
#define DCHF_HOT            0x00000008  // default is flat
#define DCHF_PUSHED         0x00000010  // default is flat
#define DCHF_FLIPPED        0x00000020  // if horiz, default is pointing right
                                        // if vert, default is pointing up
#define DCHF_TRANSPARENT    0x00000040
#define DCHF_INACTIVE       0x00000080
#define DCHF_NOBORDER       0x00000100

extern void DrawCharButton(HDC hdc, LPRECT lprc, UINT wControlState, TCHAR ch, COLORREF rgbOveride);
extern void DrawScrollArrow(HDC hdc, LPRECT lprc, UINT wControlState, COLORREF rgbOveride);
extern void DrawChevron(HTHEME hTheme, int iPartId, HDC hdc, LPRECT lprc, DWORD dwFlags);


#define EVENT_OBJECT_CREATE             0x8000
#define EVENT_OBJECT_DESTROY            0x8001
#define EVENT_OBJECT_SHOW               0x8002
#define EVENT_OBJECT_HIDE               0x8003
#define EVENT_OBJECT_REORDER            0x8004
#define EVENT_OBJECT_FOCUS              0x8005
#define EVENT_OBJECT_SELECTION          0x8006
#define EVENT_OBJECT_SELECTIONADD       0x8007
#define EVENT_OBJECT_SELECTIONREMOVE    0x8008
#define EVENT_OBJECT_SELECTIONWITHIN    0x8009
#define EVENT_OBJECT_STATECHANGE        0x800A
#define EVENT_OBJECT_LOCATIONCHANGE     0x800B
#define EVENT_OBJECT_NAMECHANGE         0x800C
#define EVENT_OBJECT_DESCRIPTIONCHANGE  0x800D
#define EVENT_OBJECT_VALUECHANGE        0x800E

#define EVENT_SYSTEM_SOUND              0x0001
#define EVENT_SYSTEM_ALERT              0x0002
#define EVENT_SYSTEM_SCROLLINGSTART     0x0012
#define EVENT_SYSTEM_SCROLLINGEND       0x0013

// Secret SCROLLBAR index values
#define INDEX_SCROLLBAR_SELF            0
#define INDEX_SCROLLBAR_UP              1
#define INDEX_SCROLLBAR_UPPAGE          2
#define INDEX_SCROLLBAR_THUMB           3
#define INDEX_SCROLLBAR_DOWNPAGE        4
#define INDEX_SCROLLBAR_DOWN            5

#define INDEX_SCROLLBAR_MIC             1
#define INDEX_SCROLLBAR_MAC             5

#define INDEX_SCROLLBAR_LEFT            7
#define INDEX_SCROLLBAR_LEFTPAGE        8
#define INDEX_SCROLLBAR_HORZTHUMB       9
#define INDEX_SCROLLBAR_RIGHTPAGE       10
#define INDEX_SCROLLBAR_RIGHT           11

#define INDEX_SCROLLBAR_HORIZONTAL      6
#define INDEX_SCROLLBAR_GRIP            12

#define CHILDID_SELF                    0
#define INDEXID_OBJECT                  0
#define INDEXID_CONTAINER               0

#ifndef WM_GETOBJECT
#define WM_GETOBJECT                    0x003D
#endif

#define MSAA_CLASSNAMEIDX_BASE 65536L

#define MSAA_CLASSNAMEIDX_LISTBOX    (MSAA_CLASSNAMEIDX_BASE+0)
#define MSAA_CLASSNAMEIDX_BUTTON     (MSAA_CLASSNAMEIDX_BASE+2)
#define MSAA_CLASSNAMEIDX_STATIC     (MSAA_CLASSNAMEIDX_BASE+3)
#define MSAA_CLASSNAMEIDX_EDIT       (MSAA_CLASSNAMEIDX_BASE+4)
#define MSAA_CLASSNAMEIDX_COMBOBOX   (MSAA_CLASSNAMEIDX_BASE+5)
#define MSAA_CLASSNAMEIDX_SCROLLBAR  (MSAA_CLASSNAMEIDX_BASE+10)
#define MSAA_CLASSNAMEIDX_STATUS     (MSAA_CLASSNAMEIDX_BASE+11)
#define MSAA_CLASSNAMEIDX_TOOLBAR    (MSAA_CLASSNAMEIDX_BASE+12)
#define MSAA_CLASSNAMEIDX_PROGRESS   (MSAA_CLASSNAMEIDX_BASE+13)
#define MSAA_CLASSNAMEIDX_ANIMATE    (MSAA_CLASSNAMEIDX_BASE+14)
#define MSAA_CLASSNAMEIDX_TAB        (MSAA_CLASSNAMEIDX_BASE+15)
#define MSAA_CLASSNAMEIDX_HOTKEY     (MSAA_CLASSNAMEIDX_BASE+16)
#define MSAA_CLASSNAMEIDX_HEADER     (MSAA_CLASSNAMEIDX_BASE+17)
#define MSAA_CLASSNAMEIDX_TRACKBAR   (MSAA_CLASSNAMEIDX_BASE+18)
#define MSAA_CLASSNAMEIDX_LISTVIEW   (MSAA_CLASSNAMEIDX_BASE+19)
#define MSAA_CLASSNAMEIDX_UPDOWN     (MSAA_CLASSNAMEIDX_BASE+22)
#define MSAA_CLASSNAMEIDX_TOOLTIPS   (MSAA_CLASSNAMEIDX_BASE+24)
#define MSAA_CLASSNAMEIDX_TREEVIEW   (MSAA_CLASSNAMEIDX_BASE+25)
//
// End BOGUS insertion from \win\core\access\inc32\winable.h
//

#ifdef MAXINT
#undef MAXINT
#endif
#define MAXINT  (int)0x7FFFFFFF
// special value for pt.y or cyLabel indicating recomputation needed
// NOTE: icon ordering code considers (RECOMPUTE, RECOMPUTE) at end
// of all icons
//
#define RECOMPUTE  (DWORD)MAXINT
#define SRECOMPUTE ((short)0x7FFF)

#define RECTWIDTH(rc) ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)
#define ABS(i)  (((i) < 0) ? -(i) : (i))
#define BOUND(x,low,high)   max(min(x, high),low)

#define LPARAM_TO_POINT(lParam, pt)       ((pt).x = LOWORD(lParam), \
                                           (pt).y = HIWORD(lParam))

// common control info stuff

typedef struct tagControlInfo 
{
    HWND        hwnd;
    HWND        hwndParent;
    DWORD       style;
    DWORD       dwCustom;
    BITBOOL     bUnicode : 1;
    BITBOOL     bInFakeCustomDraw:1;
    BITBOOL     fDPIAware:1;
    UINT        uiCodePage;
    DWORD       dwExStyle;
    LRESULT     iVersion;
    WORD        wUIState;
} CCONTROLINFO, *LPCCONTROLINFO;

#define CCDPIScale(ci)  ((ci).fDPIAware)

BOOL CCGetIconSize(LPCCONTROLINFO pCI, HIMAGELIST himl, int* pcx, int* pcy);
BOOL CCOnUIState(LPCCONTROLINFO pCI, UINT uMessage, WPARAM wParam, LPARAM lParam);
BOOL CCGetUIState(LPCCONTROLINFO pControlInfo);
BOOL CCNotifyNavigationKeyUsage(LPCCONTROLINFO pControlInfo, WORD wFlag);
BOOL CCWndProc(CCONTROLINFO* pci, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
void CCDrawInsertMark(HDC hdc, LPRECT prc, BOOL fHorizMode, COLORREF clr);
void CIInitialize(LPCCONTROLINFO lpci, HWND hwnd, LPCREATESTRUCT lpcs);
LRESULT CIHandleNotifyFormat(LPCCONTROLINFO lpci, LPARAM lParam);
DWORD CICustomDrawNotify(LPCCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd);
DWORD CIFakeCustomDrawNotify(LPCCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd);
UINT RTLSwapLeftRightArrows(CCONTROLINFO *pci, WPARAM wParam);
UINT CCSwapKeys(WPARAM wParam, UINT vk1, UINT vk2);
LPTSTR CCReturnDispInfoText(LPTSTR pszSrc, LPTSTR pszDest, UINT cchDest);

void FillRectClr(HDC hdc, PRECT prc, COLORREF clr);


//
// helpers for drag-drop enabled controls
//
typedef LRESULT (*PFNDRAGCB)(HWND hwnd, UINT code, WPARAM wp, LPARAM lp);
#define DPX_DRAGHIT   (0)  // WP = (unused)  LP = POINTL*         ret = item id
#define DPX_GETOBJECT (1)  // LP = nmobjectnotify   ret = HRESULT
#define DPX_SELECT    (2)  // WP = item id   LP = DROPEFFECT_     ret = (unused)
#define DPX_ENTER     (3)  // WP = (unused)  LP = (unused)        ret = BOOL
#define DPX_LEAVE     (4)  // WP = (unused)  LP = (unused)        ret = (unused)


// ddproxy.cpp

DECLARE_HANDLE(HDRAGPROXY);

STDAPI_(HDRAGPROXY) CreateDragProxy(HWND hwnd, PFNDRAGCB pfn, BOOL bRegister);
STDAPI_(void) DestroyDragProxy(HDRAGPROXY hdp);
STDAPI GetDragProxyTarget(HDRAGPROXY hdp, IDropTarget **ppdtgt);
STDAPI GetItemObject(CCONTROLINFO *, UINT, const IID *, LPNMOBJECTNOTIFY);
STDAPI_(struct IImgCtx *) CBitmapImgCtx_Create(HBITMAP hbm);

#define SWAP(x,y, _type)  { _type i; i = x; x = y; y = i; }

//
// This is for widened dispatch loop stuff
//
typedef MSG MSG32;
typedef MSG32 *     LPMSG32;

#define GetMessage32(lpmsg, hwnd, min, max, f32)        GetMessage(lpmsg, hwnd, min, max)
#define PeekMessage32(lpmsg, hwnd, min, max, flags, f32)       PeekMessage(lpmsg, hwnd, min, max, flags)
#define TranslateMessage32(lpmsg, f32)  TranslateMessage(lpmsg)
#define DispatchMessage32(lpmsg, f32)   DispatchMessage(lpmsg)
#define CallMsgFilter32(lpmsg, u, f32)  CallMsgFilter(lpmsg, u)
#define IsDialogMessage32(hwnd, lpmsg, f32)   IsDialogMessage(hwnd, lpmsg)

//
// This is a very important piece of performance hack for non-DBCS codepage.
//
// was !defined(DBCS) || defined(UNICODE)

// FastCharNext and FastCharPrev are like CharNext and CharPrev except that
// they don't check if you are at the beginning/end of the string.

#define FastCharNext(pch) ((pch)+1)
#define FastCharPrev(pchStart, pch) ((pch)-1)

#define CH_PREFIX TEXT('&')


#define lstrfns_StrEndN         lstrfns_StrEndNW
#define ChrCmp                  ChrCmpW
#define ChrCmpI                 ChrCmpIW

BOOL ChrCmpIA(WORD w1, WORD wMatch);
BOOL ChrCmpIW(WCHAR w1, WCHAR wMatch);
void  TruncateString(char *sz, int cch); // from strings.c

void InitGlobalMetrics(WPARAM);
void InitGlobalColors();

BOOL InitToolbarClass(HINSTANCE hInstance);
BOOL InitReBarClass(HINSTANCE hInstance);
BOOL InitToolTipsClass(HINSTANCE hInstance);
BOOL InitStatusClass(HINSTANCE hInstance);
BOOL InitHeaderClass(HINSTANCE hInstance);
BOOL InitButtonListBoxClass(HINSTANCE hInstance);
BOOL InitTrackBar(HINSTANCE hInstance);
BOOL InitUpDownClass(HINSTANCE hInstance);
BOOL InitProgressClass(HINSTANCE hInstance);
BOOL InitHotKeyClass(HINSTANCE hInstance);
BOOL InitToolTips(HINSTANCE hInstance);
BOOL InitDateClasses(HINSTANCE hinst);
BOOL InitButtonClass(HINSTANCE hinst);
BOOL InitStaticClass(HINSTANCE hinst);
BOOL InitEditClass(HINSTANCE hinst);
BOOL InitLinkClass(HINSTANCE hinst);
BOOL InitListBoxClass(HINSTANCE hinst);
BOOL InitComboboxClass(HINSTANCE hInstance);
BOOL InitComboLBoxClass(HINSTANCE hInstance);
BOOL InitScrollBarClass(HINSTANCE hInstance);
BOOL InitReaderModeClass(HINSTANCE hinst);

VOID InitEditLpk(VOID);

BOOL ChildOfActiveWindow(HWND hwnd);

/* cutils.c */

HFONT CCCreateUnderlineFont(HFONT hf);
HFONT CCGetHotFont(HFONT hFont, HFONT *phFontHot);
HFONT CCCreateStatusFont(void);
BOOL CCForwardEraseBackground(HWND hwnd, HDC hdc);
void CCPlaySound(LPCTSTR lpszName);
BOOL CheckForDragBegin(HWND hwnd, int x, int y);
void NewSize(HWND hWnd, int nHeight, LONG style, int left, int top, int width, int height);
BOOL MGetTextExtent(HDC hdc, LPCTSTR lpstr, int cnt, int * pcx, int * pcy);
void RelayToToolTips(HWND hwndToolTips, HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
int StripAccelerators(LPTSTR lpszFrom, LPTSTR lpszTo, BOOL fAmpOnly);
UINT GetCodePageForFont (HFONT hFont);
void* CCLocalReAlloc(void* p, UINT uBytes);
LONG GetMessagePosClient(HWND hwnd, LPPOINT ppt);
void FlipRect(LPRECT prc);
DWORD SetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue);
BOOL CCDrawEdge(HDC hdc, LPRECT lprc, UINT edge, UINT flags, LPCOLORSCHEME lpclrsc);
BOOL CCThemeDrawEdge(HTHEME hTheme, HDC hdc, LPRECT lprc, int iPart, int iState, UINT edge, UINT flags, LPCOLORSCHEME lpclrsc);
void CCInvalidateFrame(HWND hwnd);
void FlipPoint(LPPOINT lppt);
void CCSetInfoTipWidth(HWND hwndOwner, HWND hwndToolTips);
#define CCResetInfoTipWidth(hwndOwner, hwndToolTips) \
    SendMessage(hwndToolTips, TTM_SETMAXTIPWIDTH, 0, -1)

// Incremental search
typedef struct ISEARCHINFO 
{
    int iIncrSearchFailed;
    LPTSTR pszCharBuf;                  // isearch string lives here
    int cbCharBuf;                      // allocated size of pszCharBuf
    int ichCharBuf;                     // number of live chars in pszCharBuf
    DWORD timeLast;                     // time of last input event
    BOOL fReplaceCompChar;

} ISEARCHINFO, *PISEARCHINFO;

BOOL IncrementSearchImeCompStr(PISEARCHINFO pis, BOOL fCompStr, LPTSTR lpszCompChar, LPTSTR *lplpstr);
BOOL IncrementSearchString(PISEARCHINFO pis, UINT ch, LPTSTR *lplpstr);
int GetIncrementSearchString(PISEARCHINFO pis, LPTSTR lpsz);
int GetIncrementSearchStringA(PISEARCHINFO pis, UINT uiCodePage, LPSTR lpsz);
void IncrementSearchBeep(PISEARCHINFO pis);

#define IncrementSearchFree(pis) ((pis)->pszCharBuf ? Free((pis)->pszCharBuf) : 0)

// For RTL mirroring use
void MirrorBitmapInDC( HDC hdc , HBITMAP hbmOrig );

BOOL CCForwardPrint(CCONTROLINFO* pci, HDC hdc);
BOOL CCSendPrint(CCONTROLINFO* pci, HDC hdc);
BOOL CCSendPrintRect(CCONTROLINFO* pci, HDC hdc, RECT* prc);

// consider folding hTheme in with CControlInfo
BOOL CCShouldAskForBits(CCONTROLINFO* pci, HTHEME hTheme, int iPart, int iState);

BOOL AreAllMonitorsAtLeast(int iBpp);
void BlurBitmap(ULONG* plBitmapBits, int cx, int cy, COLORREF crFill);
int CCGetScreenDPI();
void CCDPIScaleX(int* x);
void CCDPIScaleY(int* y);
BOOL CCIsHighDPI();
void CCAdjustForBold(LOGFONT* plf);

typedef struct tagCCDBUFFER
{
    BOOL fInitialized;
    HDC hMemDC;
    HBITMAP hMemBm;
    HBITMAP hOldBm;
    HDC hPaintDC;
    RECT rc;
} CCDBUFFER;

HDC CCBeginDoubleBuffer(HDC hdcIn, RECT* prc, CCDBUFFER* pdb);
void CCEndDoubleBuffer(CCDBUFFER* pdb);

#ifdef FEATURE_FOLLOW_FOCUS_RECT
void CCSetFocus(HWND hwnd, RECT* prc);
void CCLostFocus(HWND hwnd);
#endif

BOOL CCDrawNonClientTheme(HTHEME hTheme, HWND hwnd, HRGN hRgnUpdate, HBRUSH hbr, int iPartId, int iStateId);

BOOL DSA_ForceGrow(HDSA hdsa, int iNumberToAdd);

#ifdef DEBUG
void DumpRgn(ULONGLONG qwFlags, char*trace, HRGN hrgn);
#else
#define DumpRgn(qwFlags, trace, hrgn)     0
#endif

// Locale manipulation (prsht.c)
//
//  The "proper thread locale" is the thread locale we should
//  be using for our UI elements.
//
//  If you need to change the thread locale temporarily
//  to the proper thread locale, use
//
//  LCID lcidPrev;
//  CCSetProperThreadLocale(&lcidPrev);
//  munge munge munge
//  CCRestoreThreadLocale(lcidPrev);
//
//  If you just want to retrieve the proper thread locale,
//  call CCGetProperThreadLocale(NULL).
//
//
LCID CCGetProperThreadLocale(OPTIONAL LCID *plcidPrev);

__inline void CCSetProperThreadLocale(LCID *plcidPrev) {
    SetThreadLocale(CCGetProperThreadLocale(plcidPrev));
}

#define CCRestoreThreadLocale(lcid) SetThreadLocale(lcid)

int CCLoadStringExInternal(HINSTANCE hInst, UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang);
int CCLoadStringEx(UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang);
int LocalizedLoadString(UINT uID, LPWSTR lpBuffer, int nBufferMax);
HRSRC FindResourceExRetry(HMODULE hmod, LPCTSTR lpType, LPCTSTR lpName, WORD wLang);

// assign most unlikely used value for the fake sublang id
#define SUBLANG_JAPANESE_ALTFONT 0x3f // max within 6bit

// used to get resource lang of shell32
#define DLG_EXITWINDOWS         1064

//
// Plug UI Setting funcions (commctrl.c)
//
LANGID WINAPI GetMUILanguage(void);

//
// Tooltip thunking api's
//

BOOL ThunkToolTipTextAtoW (LPTOOLTIPTEXTA lpTttA, LPTOOLTIPTEXTW lpTttW, UINT uiCodePage);

HWND GetDlgItemRect(HWND hDlg, int nIDItem, LPRECT prc);

//
// Global variables
//
extern HINSTANCE g_hinst;
extern UINT uDragListMsg;
extern int g_iIncrSearchFailed;
extern ATOM g_atomThemeScrollBar;
extern UINT g_uiACP;
#ifndef QWORD
#define QWORD unsigned __int64
#endif
extern QWORD qw128;
extern QWORD qw1;

#define g_bMirroredOS TRUE
    
//
// Icon mirroring stuff
//
extern HDC g_hdc;
extern HDC g_hdcMask;


#define HINST_THISDLL   g_hinst

#ifdef DEBUG
#undef SendMessage
#define SendMessage  SendMessageD
#ifdef __cplusplus
extern "C"
{
#endif
LRESULT WINAPI SendMessageD(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int WINAPI Str_GetPtr0(LPCTSTR pszCurrent, LPTSTR pszBuf, int cchBuf);
#ifdef __cplusplus
}
#endif
#else  // !DEBUG
#define Str_GetPtr0     Str_GetPtr
#endif // DEBUG / !DEBUG

// REVIEW, should this be a function? (inline may generate a lot of code)
#define CBBITMAPBITS(cx, cy, cPlanes, cBitsPerPixel)    \
        (((((cx) * (cBitsPerPixel) + 15) & ~15) >> 3)   \
        * (cPlanes) * (cy))

#define WIDTHBYTES(cx, cBitsPerPixel)   \
        ((((cx) * (cBitsPerPixel) + 31) / 32) * 4)

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))                          /* ;Internal */

#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))

void ColorDitherBrush_OnSysColorChange();
extern HBRUSH g_hbrMonoDither;              // gray dither brush from image.c
void InitDitherBrush();
void TerminateDitherBrush();


#ifndef DT_NOFULLWIDTHCHARBREAK
#define DT_NOFULLWIDTHCHARBREAK     0x00080000
#endif  // DT_NOFULLWIDTHCHARBREAK

#define SHDT_DRAWTEXT       0x00000001
#define SHDT_ELLIPSES       0x00000002
#define SHDT_CLIPPED        0x00000004
#define SHDT_SELECTED       0x00000008
#define SHDT_DESELECTED     0x00000010
#define SHDT_DEPRESSED      0x00000020
#define SHDT_EXTRAMARGIN    0x00000040
#define SHDT_TRANSPARENT    0x00000080
#define SHDT_SELECTNOFOCUS  0x00000100
#define SHDT_HOTSELECTED    0x00000200
#define SHDT_DTELLIPSIS     0x00000400
#define SHDT_RTLREADING     0x00000800
#define SHDT_NODBCSBREAK    0x00001000
#define SHDT_VCENTER        0x00002000
#define SHDT_LEFT           0x00004000
#define SHDT_BORDERSELECT   0x00008000
// Do not draw text in selected style:
#define SHDT_NOSELECTED     0x00010000
#define SHDT_NOMARGIN       0x00020000
#define SHDT_SHADOWTEXT     0x00040000

void WINAPI SHDrawText(HDC hdc, LPCTSTR pszText, RECT* prc,
        int fmt, UINT flags, int cyChar, int cxEllipses,
        COLORREF clrText, COLORREF clrTextBk);

void WINAPI SHThemeDrawText(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCTSTR pszText, RECT* prc,
        int fmt, UINT flags, int cyChar, int cxEllipses,
        COLORREF clrText, COLORREF clrTextBk);


// notify.c
LRESULT WINAPI CCSendNotify(CCONTROLINFO * pci, int code, LPNMHDR pnm);
BOOL CCReleaseCapture(CCONTROLINFO * pci);

// treeview.c, listview.c for FE_IME code
LPTSTR GET_COMP_STRING(HIMC hImc, DWORD dwFlags);

// lvicon.c in-place editing
#define SEIPS_WRAP          0x0001
#ifdef DEBUG
#define SEIPS_NOSCROLL      0x0002      // Flag is used only in DEBUG
#endif
void SetEditInPlaceSize(HWND hwndEdit, RECT *prc, HFONT hFont, UINT seips);
HWND CreateEditInPlaceWindow(HWND hwnd, LPCTSTR lpText, int cbText, LONG style, HFONT hFont);
void RescrollEditWindow(HWND hwndEdit);
void SHOutlineRectThickness(HDC hdc, const RECT* prc, COLORREF cr, COLORREF crDefault, int cp);
#define SHOutlineRect(hdc, prc, cr, crDefault) SHOutlineRectThickness(hdc, prc, cr, crDefault, 1)

COLORREF GetSortColor(int iPercent, COLORREF clr);
COLORREF GetBorderSelectColor(int iPercent, COLORREF clr);
BOOL IsUsingCleartype();

// readermode.c auto scroll control entry point
BOOL EnterReaderMode(HWND hwnd);


// Global System metrics.

extern int g_cxEdge;
extern int g_cyEdge;
extern int g_cxEdgeScaled;
extern int g_cyEdgeScaled;
extern int g_cxBorder;
extern int g_cyBorder;
extern int g_cxScreen;
extern int g_cyScreen;
extern int g_cxDoubleClk;
extern int g_cyDoubleClk;

extern int g_cxSmIcon;
extern int g_cySmIcon;
//extern int g_cxIcon;
//extern int g_cyIcon;
extern int g_cxFrame;
extern int g_cyFrame;
extern int g_cxIconSpacing, g_cyIconSpacing;
extern int g_cxScrollbar, g_cyScrollbar;
extern int g_cxIconMargin, g_cyIconMargin;
extern int g_cyLabelSpace;
extern int g_cxLabelMargin;
//extern int g_cxIconOffset, g_cyIconOffset;
extern int g_cxVScroll;
extern int g_cyHScroll;
extern int g_cxHScroll;
extern int g_cyVScroll;
extern int g_fDragFullWindows;
extern int g_fDBCSEnabled;
extern int g_fMEEnabled;
extern int g_fDBCSInputEnabled;
extern int g_fIMMEnabled;
extern int g_cyCompensateInternalLeading;
extern int g_fLeftAligned;

extern COLORREF g_clrWindow;
extern COLORREF g_clrWindowText;
extern COLORREF g_clrWindowFrame;
extern COLORREF g_clrGrayText;
extern COLORREF g_clrBtnText;
extern COLORREF g_clrBtnFace;
extern COLORREF g_clrBtnShadow;
extern COLORREF g_clrBtnHighlight;
extern COLORREF g_clrHighlight;
extern COLORREF g_clrHighlightText;
extern COLORREF g_clrInfoText;
extern COLORREF g_clrInfoBk;
extern COLORREF g_clr3DDkShadow;
extern COLORREF g_clr3DLight;
extern COLORREF g_clrMenuHilight;
extern COLORREF g_clrMenuText;

extern HBRUSH g_hbrGrayText;
extern HBRUSH g_hbrWindow;
extern HBRUSH g_hbrWindowText;
extern HBRUSH g_hbrWindowFrame;
extern HBRUSH g_hbrBtnFace;
extern HBRUSH g_hbrBtnHighlight;
extern HBRUSH g_hbrBtnShadow;
extern HBRUSH g_hbrHighlight;
extern HBRUSH g_hbrMenuHilight;
extern HBRUSH g_hbrMenuText;

extern HFONT g_hfontSystem;
#define WHEEL_DELTA     120
extern UINT g_msgMSWheel;
extern UINT g_ucScrollLines;
extern int  gcWheelDelta;
extern UINT g_uDragImages;
extern BOOL g_fEnableBalloonTips;
extern BOOL g_fHighContrast;
extern double g_dScaleX;
extern double g_dScaleY;

#ifdef __cplusplus
}
#endif // __cplusplus

// TRACE FLAGS
//
#define TF_MONTHCAL     0x00000100  // MonthCal and DateTimePick
#define TF_BKIMAGE      0x00000200  // ListView background image
#define TF_TOOLBAR      0x00000400  // Toolbar stuff
#define TF_PAGER        0x00000800  // Pager  Stuff
#define TF_REBAR        0x00001000  // Rebar
#define TF_LISTVIEW     0x00002000  // Listview
#define TF_TREEVIEW     0x00004000  // Treeview
#define TF_STATUS       0x00008000  // Status bar
#define TF_STANDARD     0x00010000  // Standard controls ported from user32
#define TF_IMAGELIST    0x00020000        

// Prototype flags
#define PTF_FLATLOOK    0x00000001  // Overall flatlook
#define PTF_NOISEARCHTO 0x00000002  // No incremental search timeout

#include <platform.h>

// Dummy union macros for code compilation on platforms not
// supporting nameless stuct/union

#ifdef NONAMELESSUNION
#define DUMMYUNION_MEMBER(member)   DUMMYUNIONNAME.member
#define DUMMYUNION2_MEMBER(member)  DUMMYUNIONNAME2.member
#define DUMMYUNION3_MEMBER(member)  DUMMYUNIONNAME3.member
#define DUMMYUNION4_MEMBER(member)  DUMMYUNIONNAME4.member
#define DUMMYUNION5_MEMBER(member)  DUMMYUNIONNAME5.member
#else
#define DUMMYUNION_MEMBER(member)    member
#define DUMMYUNION2_MEMBER(member)   member
#define DUMMYUNION3_MEMBER(member)   member
#define DUMMYUNION4_MEMBER(member)   member
#define DUMMYUNION5_MEMBER(member)   member
#endif

#ifdef FULL_DEBUG
#ifdef __cplusplus
extern "C" {
#endif
void DebugPaintInvalid(HWND hwnd, RECT* prc, HRGN rgn);
void DebugPaintClip(HWND hwnd, HDC hdc);
void DebugPaintRect(HDC hdc, RECT* prc);
#ifdef __cplusplus
}
#endif
#else
#define DebugPaintInvalid(hwnd, prc, rgn)   0
#define DebugPaintClip(hwnd, hdc)  0
#define DebugPaintRect(hdc, prc) 0
#endif

#define COLOR_STRUCT DWORD
#define QUAD_PART(a) ((a)##.QuadPart)

#ifndef ISREMOTESESSION
#define ISREMOTESESSION() GetSystemMetrics(SM_REMOTESESSION)
#endif

EXTERN_C BOOL g_fCriticalInitialized;

#undef ENTERCRITICAL
#undef LEAVECRITICAL
#undef ASSERTCRITICAL
#define ENTERCRITICAL do { if (g_fCriticalInitialized) EnterCriticalSection(&g_csDll); } while (0);
#define LEAVECRITICAL do { if (g_fCriticalInitialized) LeaveCriticalSection(&g_csDll); } while (0); 
#define ASSERTCRITICAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\ddproxy.cpp ===
#include "ctlspriv.h"

//------------------------------------------------------------------------------

STDAPI GetItemObject(CCONTROLINFO *pci, UINT uMsg, const IID *piid, LPNMOBJECTNOTIFY pnon)
{
    pnon->piid = piid;
    pnon->pObject = NULL;
    pnon->hResult = E_NOINTERFACE;

    CCSendNotify(pci, uMsg, &pnon->hdr);

    ASSERT(SUCCEEDED(pnon->hResult) ? (pnon->pObject != NULL) : (pnon->pObject == NULL));

    return pnon->hResult;
}

//------------------------------------------------------------------------------

class CDragProxy : public IDropTarget
{

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *, DWORD, POINTL, DWORD *);
    STDMETHODIMP DragOver(DWORD, POINTL, DWORD *);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *, DWORD, POINTL, DWORD *);

    CDragProxy(HWND hwnd, PFNDRAGCB pfn);
    BOOL Register();
    void RevokeAndFreeCB();

private:
    ~CDragProxy();

    int          _cRef;             // object reference count
    HWND         _hwnd;             // window that owns us
    PFNDRAGCB    _pfnCallback;      // callback for that window
    IDataObject *_pdtobj;           // data object being dragged
    IDropTarget *_pdtgtItem;        // drop target of item under mouse
    int          _idItem;           // id of item under mouse
    DWORD        _dwFlags;
    int          _idDefault;        // id to use when outside a drag etc
    DWORD        _dwEffectItem;     // DROPEFFECT returned for item under mouse
    DWORD        _fKeysLast;        // key flags from last DragOver
    POINTL       _ptLast;           // location of last DragOver
    DWORD        _dwEffectLast;     // effect available from last DragOver
    HMODULE      _hmodOLE;          // OLE32 ref, also indicates we did a Register()

    void SetTargetItem(int id, DWORD dwFlags);
    void SetDropTarget(IDropTarget *pdt);
    void UpdateSelection(DWORD dwEffect);
    LRESULT CallCB(UINT code, WPARAM wp, LPARAM lp);
};

//------------------------------------------------------------------------------

STDAPI_(HDRAGPROXY) CreateDragProxy(HWND hwnd, PFNDRAGCB pfn, BOOL bRegister)
{
    CDragProxy *pdp = new CDragProxy(hwnd, pfn);

    //
    // register as needed
    //
    if (pdp && bRegister && !pdp->Register())
    {
        pdp->Release();
        pdp = NULL;
    }

    return (HDRAGPROXY)pdp;
}

STDAPI_(void) DestroyDragProxy(HDRAGPROXY hdp)
{
    if (hdp)
    {
        ((CDragProxy *)hdp)->RevokeAndFreeCB();
        ((CDragProxy *)hdp)->Release();
    }
}

STDAPI GetDragProxyTarget(HDRAGPROXY hdp, IDropTarget **ppdtgt)
{
    if (hdp)
    {
        *ppdtgt = SAFECAST((CDragProxy *)hdp, IDropTarget *);
        ((CDragProxy *)hdp)->AddRef();
        return NOERROR;
    }

    *ppdtgt = NULL;
    return E_FAIL;
}


//------------------------------------------------------------------------------

CDragProxy::CDragProxy(HWND hwnd, PFNDRAGCB pfn)
    :   _hwnd(hwnd), _pfnCallback(pfn),
        _cRef(1),
        _hmodOLE(NULL),
        _pdtobj(NULL),
        _pdtgtItem(NULL),
        _dwEffectItem(DROPEFFECT_NONE)
{
    _idDefault = _idItem = (int)CallCB(DPX_DRAGHIT, 0, 0);
}

CDragProxy::~CDragProxy()
{
    DragLeave();

}

HRESULT CDragProxy::QueryInterface(REFIID iid, void **ppv)
{
    if (IsEqualIID(iid, IID_IDropTarget) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = SAFECAST(this, IDropTarget *);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    _cRef++;
    return NOERROR;
}

ULONG CDragProxy::AddRef()
{
    return ++_cRef;
}

ULONG CDragProxy::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDragProxy::DragEnter(IDataObject *pdo, DWORD fKeys, POINTL pt, DWORD *pdwEffect)
{
    //
    // some sanity
    //
    ASSERT(!_pdtgtItem);
    ASSERT(!_pdtobj);

    if (!pdo)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    //
    // make sure our callback will allow us to do d/d now
    //
    if (!CallCB(DPX_ENTER, 0, 0))
        return E_FAIL;

    //
    // save away the data object
    //
    pdo->AddRef();
    _pdtobj = pdo;

    //
    // and process this like a DragOver
    //
    DragOver(fKeys, pt, pdwEffect);

    //
    // always succeed DragEnter
    //
    return NOERROR;
}

HRESULT CDragProxy::DragLeave()
{
    //
    // release any drop target that we are holding
    //
    SetDropTarget(NULL);
    _idItem = _idDefault;

    //
    // if we had a data object then we were actually dragging
    //
    if (_pdtobj)
    {
        CallCB(DPX_LEAVE, 0, 0);

        IDataObject* p = _pdtobj;
        _pdtobj = NULL;
        p->Release();
    }

    //
    // all done
    //
    return NOERROR;
}

HRESULT CDragProxy::DragOver(DWORD fKeys, POINTL pt, DWORD *pdwEffect)
{
    DWORD dwFlags = 0;
    HRESULT hres;
    int id;
    ASSERT(_pdtobj);

    //
    // save the current drag state
    //
    _fKeysLast    = fKeys;
    _ptLast       = pt;
    _dwEffectLast = *pdwEffect;

    //
    // make sure we have the correct drop target for this location
    //
    id = (int)CallCB(DPX_DRAGHIT, (WPARAM)&dwFlags, (LPARAM)&pt);
    SetTargetItem(id, dwFlags);
    //
    // do we have a target to drop on?
    //
    if (_pdtgtItem)
    {
        //
        // forward the DragOver along to the item's drop target (if any)
        //
        hres = _pdtgtItem->DragOver(fKeys, pt, pdwEffect);
    }
    else
    {
        //
        // can't drop here
        //
        *pdwEffect = DROPEFFECT_NONE;
        hres = NOERROR;
    }

    //
    // and update our selection state accordingly
    //
    UpdateSelection(*pdwEffect);

    return hres;
}

HRESULT CDragProxy::Drop(IDataObject *pdo, DWORD fKeys, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hres;

    AddRef();

    //
    // do we have a target to drop on?
    //
    if (_pdtgtItem)
    {
        // From a comment in browseui, there's apparently a chance to put up UI
        // which could cause us to get re-entered.  Hard to believe, but see if
        // this fixes the fault:
        //
        IDropTarget * pdtCur = _pdtgtItem;
        _pdtgtItem = NULL;

        //
        // do the drop
        //
        hres = pdtCur->Drop(pdo, fKeys, pt, pdwEffect);

        //
        // we call our DragLeave below but we don't want the item's to be
        // called (since it already saw the Drop) so we release right away
        //
        pdtCur->Release();
    }
    else
    {
        //
        // can't drop here
        //
        *pdwEffect = DROPEFFECT_NONE;
        hres = NOERROR;
    }

    //
    // now clean up
    //
    DragLeave();

    Release();

    return hres;
}

void CDragProxy::SetTargetItem(int id, DWORD dwFlags)
{
    //
    // anything to do?
    //
    if (id == _idItem && dwFlags == _dwFlags)
        return;

    //
    // deselect the old item (if any)
    //
    // the GETOBJECT below could take a long time and we don't want a
    // lingering highlight on the object we are leaving
    //

    UpdateSelection(DROPEFFECT_NONE);

    //
    // get a drop target for the new item
    //
    _idItem = id;
    _dwFlags = dwFlags;

    NMOBJECTNOTIFY non;
    non.iItem = id;
    non.dwFlags = dwFlags;
    if (!_pdtobj || FAILED((HRESULT)CallCB(DPX_GETOBJECT, 0, (LPARAM)&non)))
        non.pObject = NULL;

        //
    // use this drop target (if any)
    //
    SetDropTarget((IDropTarget*)non.pObject);

    //
    // release our ref from the GETOBJECT above
    //
    if (non.pObject)
        ((IDropTarget*)non.pObject)->Release();
}

void CDragProxy::SetDropTarget(IDropTarget *pdt)
{
    //
    // NOTE: we intentionally skip the test for drop-target equality here
    // this allows controls owners to share a target among multiple items
    // while retaining the proper leave/enter sequence...
    //
    // BOGUS: we should actually compare here when the Internet Toolbar gets
    //  fixed (see comment in CDragProxy::SetTargetItem).  anybody who wants
    //  to share a target like this should just do the right hit-testing in
    //  their DragOver implementation
    //


    //
    // make sure nothing is selected
    //
    UpdateSelection(DROPEFFECT_NONE);

    //
    // leave/release the old item
    //
    if (_pdtgtItem)
    {
        _pdtgtItem->DragLeave();
        _pdtgtItem->Release();
    }

    //
    // store the new item
    //
    _pdtgtItem = pdt;

    //
    // addref/enter the new item
    //
    if (_pdtgtItem)
    {
        ASSERT(_pdtobj);    // must have a data object by now

        _pdtgtItem->AddRef();

        DWORD dwEffect = _dwEffectLast;
        if (FAILED(_pdtgtItem->DragEnter(_pdtobj, _fKeysLast, _ptLast, &dwEffect)))
            dwEffect = DROPEFFECT_NONE;

        //
        // update the selection
        //
        UpdateSelection(dwEffect);
    }
}

void CDragProxy::UpdateSelection(DWORD dwEffect)
{
    //
    // anything to do?
    //
    if (dwEffect == _dwEffectItem)
        return;

    //
    // update the flags and tell the callback they changed
    //
    _dwEffectItem = dwEffect;
    CallCB(DPX_SELECT, (WPARAM)_idItem, (LPARAM)dwEffect);
}

LRESULT CDragProxy::CallCB(UINT code, WPARAM wp, LPARAM lp)
{
    return _pfnCallback ? _pfnCallback(_hwnd, code, wp, lp) : (LRESULT)-1;
}

BOOL CDragProxy::Register()
{
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        if (SUCCEEDED(RegisterDragDrop(_hwnd, this)))
            return TRUE;

        CoUninitialize();
    }
    return FALSE;
}

void CDragProxy::RevokeAndFreeCB()
{
    RevokeDragDrop(_hwnd);
    CoUninitialize();
    _pfnCallback = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\da.c ===
#include "ctlspriv.h"

//
// Heapsort is a bit slower, but it doesn't use any stack or memory...
// Mergesort takes a bit of memory (O(n)) and stack (O(log(n)), but very fast...
//
#define MERGESORT
// #define USEHEAPSORT

#ifdef DEBUG
#define DSA_MAGIC   ('S' | ('A' << 8))
#define IsDSA(pdsa) ((pdsa) && (pdsa)->magic == DSA_MAGIC)
#define DPA_MAGIC   ('P' | ('A' << 8))
#define IsDPA(pdpa) ((pdpa) && (pdpa)->magic == DPA_MAGIC)
#else
#define IsDSA(pdsa)
#define IsDPA(pdsa)
#endif


typedef struct {
    void** pp;
    PFNDPACOMPARE pfnCmp;
    LPARAM lParam;
    int cp;
#ifdef MERGESORT
    void** ppT;
#endif
} SORTPARAMS;

BOOL DPA_QuickSort(SORTPARAMS* psp);
BOOL DPA_QuickSort2(int i, int j, SORTPARAMS* psp);
BOOL DPA_HeapSort(SORTPARAMS* psp);
void DPA_HeapSortPushDown(int first, int last, SORTPARAMS* psp);
BOOL DPA_MergeSort(SORTPARAMS* psp);
void DPA_MergeSort2(SORTPARAMS* psp, int iFirst, int cItems);



//========== Dynamic structure array ====================================

// Dynamic structure array

typedef struct _DSA 
{
    // NOTE: The following field MUST be defined at the beginning of the
    // structure in order for GetItemCount() to work.
    int cItem;		// # of elements in dsa

    void* aItem;	// memory for elements
    int cItemAlloc;	// # items which fit in aItem
    int cbItem;		// size of each item
    int cItemGrow;	// # items to grow cItemAlloc by
#ifdef DEBUG
    UINT magic;
#endif
} DSA;

#define DSA_PITEM(pdsa, index)    ((void*)(((BYTE*)(pdsa)->aItem) + ((index) * (pdsa)->cbItem)))

#ifdef DEBUG
#define BF_ONDAVALIDATE     0x00001000

void DABreakFn(void)
{
    if (IsFlagSet(g_dwBreakFlags, BF_ONDAVALIDATE))
        ASSERT(0);
}

#define DABreak()    DABreakFn()
#else
#define DABreak()
#endif


HDSA WINAPI DSA_Create(int cbItem, int cItemGrow)
{
    HDSA pdsa = Alloc(sizeof(DSA));

    ASSERT(cbItem);

    if (pdsa)
    {
        ASSERT(pdsa->cItem == 0);
        ASSERT(pdsa->cItemAlloc == 0);
        pdsa->cbItem = cbItem;
        pdsa->cItemGrow = (cItemGrow == 0 ? 1 : cItemGrow);
        ASSERT(pdsa->aItem == NULL);
#ifdef DEBUG
        pdsa->magic = DSA_MAGIC;
#endif
    }
    return pdsa;
}

BOOL WINAPI DSA_Destroy(HDSA pdsa)
{

    if (pdsa == NULL)
    {
        // allow NULL for low memory cases
        return TRUE;
    }

    // Components rely on not having to check for NULL
    ASSERT(IsDSA(pdsa));

#ifdef DEBUG
    pdsa->cItem = 0;
    pdsa->cItemAlloc = 0;
    pdsa->cbItem = 0;
    pdsa->magic = 0;
#endif

    if (pdsa->aItem && !Free(pdsa->aItem))
    {
        return FALSE;
    }

    return Free(pdsa);
}

void WINAPI DSA_EnumCallback(HDSA pdsa, PFNDSAENUMCALLBACK pfnCB, void *pData)
{
    int i;
    
    if (!pdsa)
        return;
    
    ASSERT(IsDSA(pdsa));

    for (i = 0; i < pdsa->cItem; i++) {
        if (!pfnCB(DSA_GetItemPtr(pdsa, i), pData))
            break;
    }
}

void WINAPI DSA_DestroyCallback(HDSA pdsa, PFNDSAENUMCALLBACK pfnCB, void *pData)
{
    DSA_EnumCallback(pdsa, pfnCB, pData);
    DSA_Destroy(pdsa);
}


BOOL WINAPI DSA_GetItem(HDSA pdsa, int index, void* pitem)
{
    ASSERT(IsDSA(pdsa));
    ASSERT(pitem);

    if (index < 0 || index >= pdsa->cItem)
    {
#ifdef DEBUG
        // Don't assert if index == pdsa->cItems as some clients simply want to walk the list and no need to call getcount...

        if (index != pdsa->cItem)
        {
            DebugMsg(DM_ERROR, TEXT("DSA: GetItem: Invalid index: %d"), index);
            DABreak();
        }
#endif
        return FALSE;
    }

    CopyMemory(pitem, DSA_PITEM(pdsa, index), pdsa->cbItem);
    return TRUE;
}

void* WINAPI DSA_GetItemPtr(HDSA pdsa, int index)
{
    ASSERT(IsDSA(pdsa));

    if (index < 0 || index >= pdsa->cItem)
    {
#ifdef DEBUG
        // Don't assert if index == pdsa->cItems as some clients simply want to walk the list and no need to call getcount...

        if (index != pdsa->cItem)
        {
            DebugMsg(DM_ERROR, TEXT("DSA: GetItemPtr: Invalid index: %d"), index);
            // DABreak();   // caller knows
        }
#endif
        return NULL;
    }
    return DSA_PITEM(pdsa, index);
}

BOOL DSA_ForceGrow(HDSA pdsa, int iNumberToAdd)
{
    ASSERT(IsDSA(pdsa));

    if (!pdsa)
        return FALSE;

    if (pdsa->cItem + iNumberToAdd > pdsa->cItemAlloc)
    {
        int cItemAlloc = (((pdsa->cItemAlloc + iNumberToAdd) + pdsa->cItemGrow - 1) / pdsa->cItemGrow) * pdsa->cItemGrow;

        void* aItemNew = ReAlloc(pdsa->aItem, cItemAlloc * pdsa->cbItem);
        if (!aItemNew)
        {
            return FALSE;
        }

        pdsa->aItem = aItemNew;
        pdsa->cItemAlloc = cItemAlloc;
    }
    return TRUE;
}


BOOL WINAPI DSA_SetItem(HDSA pdsa, int index, void* pitem)
{
    ASSERT(pitem);
    ASSERT(IsDSA(pdsa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: SetItem: Invalid index: %d"), index);
        DABreak();
        return FALSE;
    }

    if (index >= pdsa->cItem)
    {
        if (index + 1 > pdsa->cItemAlloc)
        {
            int cItemAlloc = (((index + 1) + pdsa->cItemGrow - 1) / pdsa->cItemGrow) * pdsa->cItemGrow;

            void* aItemNew = ReAlloc(pdsa->aItem, cItemAlloc * pdsa->cbItem);
            if (!aItemNew)
            {
                return FALSE;
            }

            pdsa->aItem = aItemNew;
            pdsa->cItemAlloc = cItemAlloc;
        }
        pdsa->cItem = index + 1;
    }

    CopyMemory(DSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return TRUE;
}

int WINAPI DSA_InsertItem(HDSA pdsa, int index, void* pitem)
{
    ASSERT(pitem);
    ASSERT(IsDSA(pdsa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: InsertItem: Invalid index: %d"), index);
        DABreak();
        return -1;
    }

    if (index > pdsa->cItem)
        index = pdsa->cItem;

    if (pdsa->cItem + 1 > pdsa->cItemAlloc)
    {
        void* aItemNew = ReAlloc(pdsa->aItem, (pdsa->cItemAlloc + pdsa->cItemGrow) * pdsa->cbItem);
        if (!aItemNew)
        {
            return -1;
        }

        pdsa->aItem = aItemNew;
        pdsa->cItemAlloc += pdsa->cItemGrow;
    }

    if (index < pdsa->cItem)
    {
        MoveMemory(DSA_PITEM(pdsa, index + 1),
                   DSA_PITEM(pdsa, index),
                   (pdsa->cItem - index) * pdsa->cbItem);
    }
    pdsa->cItem++;
    MoveMemory(DSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return index;
}

BOOL WINAPI DSA_DeleteItem(HDSA pdsa, int index)
{
    ASSERT(IsDSA(pdsa));

    if (index < 0 || index >= pdsa->cItem)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: DeleteItem: Invalid index: %d"), index);
        DABreak();
        return FALSE;
    }

    if (index < pdsa->cItem - 1)
    {
        MoveMemory(DSA_PITEM(pdsa, index),
                   DSA_PITEM(pdsa, index + 1),
                   (pdsa->cItem - (index + 1)) * pdsa->cbItem);
    }
    pdsa->cItem--;

    if (pdsa->cItemAlloc - pdsa->cItem > pdsa->cItemGrow)
    {
        void* aItemNew = ReAlloc(pdsa->aItem, (pdsa->cItemAlloc - pdsa->cItemGrow) * pdsa->cbItem);
        if (aItemNew)
        {
            pdsa->aItem = aItemNew;
        }
        else
        {
            // If the shrink fails, then just continue with the old (slightly
            // too big) allocation.  Go ahead and let cItemAlloc decrease
            // so we don't keep trying to realloc smaller
        }
        pdsa->cItemAlloc -= pdsa->cItemGrow;
    }
    return TRUE;
}

BOOL WINAPI DSA_DeleteAllItems(HDSA pdsa)
{
    ASSERT(IsDSA(pdsa));

    if (pdsa->aItem && !Free(pdsa->aItem))
    {
        return FALSE;
    }

    pdsa->aItem = NULL;
    pdsa->cItem = pdsa->cItemAlloc = 0;
    return TRUE;
}


//================== Dynamic pointer array implementation ===========

typedef struct _DPA 
{
    // NOTE: The following two fields MUST be defined in this order, at
    // the beginning of the structure in order for the macro APIs to work.
    int cp;
    void** pp;

    HANDLE hheap;        // Heap to allocate from if NULL use shared

    int cpAlloc;
    int cpGrow;
#ifdef DEBUG
    UINT magic;
#endif
} DPA;



HDPA WINAPI DPA_Create(int cpGrow)
{
    return DPA_CreateEx(cpGrow, NULL);
}

// Should nuke the standard DPA above...
HDPA WINAPI DPA_CreateEx(int cpGrow, HANDLE hheap)
{
    HDPA pdpa;
    if (hheap == NULL)
    {
        hheap = GetProcessHeap();
        pdpa = ControlAlloc(hheap, sizeof(DPA));
    }
    else
        pdpa = ControlAlloc(hheap, sizeof(DPA));
    if (pdpa)
    {
        ASSERT(pdpa->cp == 0);
        ASSERT(pdpa->cpAlloc == 0);
        pdpa->cpGrow = (cpGrow < 8 ? 8 : cpGrow);
        ASSERT(pdpa->pp == NULL);
        pdpa->hheap = hheap;
#ifdef DEBUG
        pdpa->magic = DPA_MAGIC;
#endif
    }
    return pdpa;
}

BOOL WINAPI DPA_Destroy(HDPA pdpa)
{
    if (pdpa == NULL)       // allow NULL for low memory cases, still assert
        return TRUE;

    ASSERT(IsDPA(pdpa));
    ASSERT(pdpa->hheap);

#ifdef DEBUG
    pdpa->cp = 0;
    pdpa->cpAlloc = 0;
    pdpa->magic = 0;
#endif
    if (pdpa->pp && !ControlFree(pdpa->hheap, pdpa->pp))
        return FALSE;

    return ControlFree(pdpa->hheap, pdpa);
}

HDPA WINAPI DPA_Clone(HDPA pdpa, HDPA pdpaNew)
{
    BOOL fAlloc = FALSE;

    if (!pdpaNew)
    {
        pdpaNew = DPA_CreateEx(pdpa->cpGrow, pdpa->hheap);
        if (!pdpaNew)
        {
            return NULL;
        }

        fAlloc = TRUE;
    }

    if (!DPA_Grow(pdpaNew, pdpa->cpAlloc))
    {
        if (!fAlloc)
        {
            DPA_Destroy(pdpaNew);
        }
        return NULL;
    }

    pdpaNew->cp = pdpa->cp;
    CopyMemory(pdpaNew->pp, pdpa->pp, pdpa->cp * sizeof(void*));

    return pdpaNew;
}

void* WINAPI DPA_GetPtr(HDPA pdpa, INT_PTR index)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa || index < 0 || index >= pdpa->cp)
        return NULL;

    return pdpa->pp[index];
}

int WINAPI DPA_GetPtrIndex(HDPA pdpa, void* p)
{
    void** pp;
    void** ppMax;

    ASSERT(IsDPA(pdpa));
    if (pdpa && pdpa->pp)
    {
        pp = pdpa->pp;
        ppMax = pp + pdpa->cp;
        for ( ; pp < ppMax; pp++)
        {
            if (*pp == p)
                return (int) (pp - pdpa->pp);
        }
    }
    return -1;
}

BOOL WINAPI DPA_Grow(HDPA pdpa, int cpAlloc)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return FALSE;

    if (cpAlloc > pdpa->cpAlloc)
    {
        void** ppNew;

        cpAlloc = ((cpAlloc + pdpa->cpGrow - 1) / pdpa->cpGrow) * pdpa->cpGrow;

        if (pdpa->pp)
            ppNew = (void**)ControlReAlloc(pdpa->hheap, pdpa->pp, cpAlloc * sizeof(void*));
        else
            ppNew = (void**)ControlAlloc(pdpa->hheap, cpAlloc * sizeof(void*));
        if (!ppNew)
            return FALSE;

        pdpa->pp = ppNew;
        pdpa->cpAlloc = cpAlloc;

        //
        // Grow more agressively as we get bigger, up to a maximum of
        // 512 at a time.  Note, we'll only hit our outer bound growth
        // at a time limit once we've already got that many items in the
        // DPA anyway...
        //
        if (pdpa->cpGrow < 256)
        {
            pdpa->cpGrow = pdpa->cpGrow << 1;
        }
    }
    return TRUE;
}

BOOL WINAPI DPA_SetPtr(HDPA pdpa, int index, void* p)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return FALSE;

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: SetPtr: Invalid index: %d"), index);
        DABreak();
        return FALSE;
    }

    if (index >= pdpa->cp)
    {
        if (!DPA_Grow(pdpa, index + 1))
            return FALSE;
        // If we grew by more than one, must zero-init all the stuff in the middle
        ZeroMemory(pdpa->pp + pdpa->cp, sizeof(void *) * (index - pdpa->cp));
        pdpa->cp = index + 1;
    }

    pdpa->pp[index] = p;

    return TRUE;
}

int WINAPI DPA_InsertPtr(HDPA pdpa, int index, void* p)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return -1;

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: InsertPtr: Invalid index: %d"), index);
        DABreak();
        return -1;
    }
    if (index > pdpa->cp)
        index = pdpa->cp;

    // Make sure we have room for one more item
    //
    if (pdpa->cp + 1 > pdpa->cpAlloc)
    {
        if (!DPA_Grow(pdpa, pdpa->cp + 1))
            return -1;
    }

    // If we are inserting, we need to slide everybody up
    //
    if (index < pdpa->cp)
    {
        MoveMemory(&pdpa->pp[index + 1],
                   &pdpa->pp[index],
                   (pdpa->cp - index) * sizeof(void*));
    }

    pdpa->pp[index] = p;
    pdpa->cp++;

    return index;
}

void* WINAPI DPA_DeletePtr(HDPA pdpa, int index)
{
    void* p;

    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return FALSE;

    if (index < 0 || index >= pdpa->cp)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: DeltePtr: Invalid index: %d"), index);
        DABreak();
        return NULL;
    }

    p = pdpa->pp[index];

    if (index < pdpa->cp - 1)
    {
        MoveMemory(&pdpa->pp[index],
                   &pdpa->pp[index + 1],
                   (pdpa->cp - (index + 1)) * sizeof(void*));
    }
    pdpa->cp--;

    if (pdpa->cpAlloc - pdpa->cp > pdpa->cpGrow)
    {
        void** ppNew;
        ppNew = ControlReAlloc(pdpa->hheap, pdpa->pp, (pdpa->cpAlloc - pdpa->cpGrow) * sizeof(void*));

        if (ppNew)
            pdpa->pp = ppNew;
        else
        {
            // If the shrink fails, then just continue with the old (slightly
            // too big) allocation.  Go ahead and let cpAlloc decrease
            // so we don't keep trying to realloc smaller
        }
        pdpa->cpAlloc -= pdpa->cpGrow;
    }
    return p;
}

BOOL WINAPI DPA_DeleteAllPtrs(HDPA pdpa)
{
    if (!pdpa)
        return FALSE;

    ASSERT(IsDPA(pdpa));

    if (pdpa->pp && !ControlFree(pdpa->hheap, pdpa->pp))
        return FALSE;
    pdpa->pp = NULL;
    pdpa->cp = pdpa->cpAlloc = 0;
    return TRUE;
}

void WINAPI DPA_EnumCallback(HDPA pdpa, PFNDPAENUMCALLBACK pfnCB, void *pData)
{
    int i;
    
    if (!pdpa)
        return;
    
    ASSERT(IsDPA(pdpa));

    for (i = 0; i < pdpa->cp; i++) {
        if (!pfnCB(DPA_FastGetPtr(pdpa, i), pData))
            break;
    }
}

void WINAPI DPA_DestroyCallback(HDPA pdpa, PFNDPAENUMCALLBACK pfnCB, void *pData)
{
    DPA_EnumCallback(pdpa, pfnCB, pData);
    DPA_Destroy(pdpa);
}


typedef struct _DPASTREAMHEADER
{
    DWORD cbSize;       // Size of entire stream
    DWORD dwVersion;    // For versioning
    int   celem;
} DPASTREAMHEADER;

#define DPASTREAM_VERSION   1


/*----------------------------------------------------------
Purpose: Saves the DPA to a stream by writing out a header,
         and then calling the given callback to write each
         element.

         The callback can end the write early by returning 
         something other than S_OK.  Returning an error will
         cancel the entire write.  Returning S_FALSE will 
         stop the write.

Returns: S_OK or S_FALSE for success.  
         S_FALSE only if callback stops early
         errors
*/
HRESULT
WINAPI
DPA_SaveStream(
    IN HDPA         pdpa,
    IN PFNDPASTREAM pfn,
    IN IStream *    pstm,
    IN void *      pvInstData)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_HANDLE(pdpa, DPA) &&
        IS_VALID_CODE_PTR(pstm, IStream *) &&
        IS_VALID_CODE_PTR(pfn, PFNDPASTREAM))
    {
        DPASTREAMHEADER header;
        LARGE_INTEGER dlibMove = { 0 };
        ULARGE_INTEGER ulPosBegin;

        // Get the current seek position, so we can update the header
        // once we know how much we've written
        hres = pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_CUR, &ulPosBegin);
        if (SUCCEEDED(hres))
        {
            // Write the header (we will update some of this once we're
            // finished)
            header.cbSize = 0;
            header.dwVersion = DPASTREAM_VERSION;
            header.celem = 0;

            // First write out the header
            hres = pstm->lpVtbl->Write(pstm, &header, sizeof(header), NULL);

            if (SUCCEEDED(hres))
            {
                DPASTREAMINFO info;
                int cel = DPA_GetPtrCount(pdpa);
                void **ppv = DPA_GetPtrPtr(pdpa);

                // This keeps the count of what is actually written
                info.iPos = 0;

                // Write each element
                for (; 0 < cel; cel--, ppv++) 
                {
                    info.pvItem = *ppv;
                    hres = pfn(&info, pstm, pvInstData);

                    // Returning S_FALSE from callback means it didn't
                    // write anything for this element, so don't increment 
                    // the iPos (which refers to the count written).

                    if (S_OK == hres)
                        info.iPos++;
                    else if (FAILED(hres))
                    {
                        hres = S_FALSE;
                        break;
                    }
                }

                if (FAILED(hres))
                {
                    // Reposition pointer to beginning
                    dlibMove.LowPart = ulPosBegin.LowPart;
                    dlibMove.HighPart = ulPosBegin.HighPart;
                    pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                }
                else
                {
                    ULARGE_INTEGER ulPosEnd;

                    // Calculate how much was written
                    hres = pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_CUR, 
                                              &ulPosEnd);
                    if (SUCCEEDED(hres))
                    {
                        // We only save the low part
                        ASSERT(ulPosEnd.HighPart == ulPosBegin.HighPart);

                        // Update the header
                        header.celem = info.iPos;
                        header.cbSize = ulPosEnd.LowPart - ulPosBegin.LowPart;

                        dlibMove.LowPart = ulPosBegin.LowPart;
                        dlibMove.HighPart = ulPosBegin.HighPart;
                        pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                        pstm->lpVtbl->Write(pstm, &header, sizeof(header), NULL);

                        // Reposition pointer
                        dlibMove.LowPart = ulPosEnd.LowPart;
                        dlibMove.HighPart = ulPosEnd.HighPart;
                        pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                    }
                }
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Loads the DPA from a stream by calling the given callback 
         to read each element.

         The callback can end the read early by returning 
         something other than S_OK.  

Returns: S_OK on success
         S_FALSE if the callback aborted early or the stream ended
           abruptly. DPA is partially filled.
         error on anything else
*/
HRESULT
WINAPI
DPA_LoadStream(
    OUT HDPA *      ppdpa,
    IN PFNDPASTREAM pfn,
    IN IStream *    pstm,
    IN void *      pvInstData)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_WRITE_PTR(ppdpa, HDPA) &&
        IS_VALID_CODE_PTR(pstm, IStream *) &&
        IS_VALID_CODE_PTR(pfn, PFNDPASTREAM))
    {
        DPASTREAMHEADER header;
        LARGE_INTEGER dlibMove = { 0 };
        ULARGE_INTEGER ulPosBegin;
        ULONG cbRead;

        *ppdpa = NULL;

        // Get the current seek position so we can position pointer 
        // correctly upon error.
        hres = pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_CUR, &ulPosBegin);
        if (SUCCEEDED(hres))
        {
            // Read the header
            hres = pstm->lpVtbl->Read(pstm, &header, sizeof(header), &cbRead);
            if (SUCCEEDED(hres))
            {
                if (sizeof(header) > cbRead ||
                    sizeof(header) > header.cbSize ||
                    DPASTREAM_VERSION != header.dwVersion)
                {
                    hres = E_FAIL;
                }
                else
                {
                    // Create the list 
                    HDPA pdpa = DPA_Create(header.celem);
                    if ( !pdpa || !DPA_Grow(pdpa, header.celem))
                        hres = E_OUTOFMEMORY;
                    else
                    {
                        // Read each element
                        DPASTREAMINFO info;
                        void **ppv = DPA_GetPtrPtr(pdpa);

                        for (info.iPos = 0; info.iPos < header.celem; ) 
                        {
                            info.pvItem = NULL;
                            hres = pfn(&info, pstm, pvInstData);

                            // Returning S_FALSE from the callback means
                            // it skipped this stream element.
                            // Don't increment iPos (which refers to the
                            // count read).
                            if (S_OK == hres)
                            {
                                *ppv = info.pvItem;

                                info.iPos++;
                                ppv++;    
                            }
                            else if (FAILED(hres))
                            {
                                hres = S_FALSE;
                                break;
                            }
                        }

                        pdpa->cp = info.iPos;
                        *ppdpa = pdpa;
                    }
                }

                // Reposition pointer if we failed
                if (S_OK != hres)
                {
                    if (S_FALSE == hres)
                    {
                        // Position pointer to the end
                        dlibMove.LowPart = ulPosBegin.LowPart + header.cbSize;
                    }
                    else
                    {
                        // Position pointer to beginning 
                        dlibMove.LowPart = ulPosBegin.LowPart;
                    }
                    dlibMove.HighPart = ulPosBegin.HighPart;
                    pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                }
            }
        }

        ASSERT(SUCCEEDED(hres) && *ppdpa ||
               FAILED(hres) && NULL == *ppdpa);
    }

    return hres;
}



/*----------------------------------------------------------
Purpose: Merge two DPAs.  This takes two arrays and merges the
         source array into the destination.   

         Merge options:

          DPAM_SORTED       The arrays are already sorted; don't sort
          DPAM_UNION        The resulting array is the union of all elements
                            in both arrays.
          DPAM_INTERSECT    Only elements in the source array that intersect
                            with the dest array are merged.  
          DPAM_NORMAL       Like DPAM_INTERSECT except the dest array 
                            also maintains its original, additional elements.


Returns: S_OK for success.  
         errors if merge fails

Cond:    --
*/
BOOL
WINAPI
DPA_Merge(
    IN HDPA          pdpaDest,
    IN HDPA          pdpaSrc,
    IN DWORD         dwFlags,
    IN PFNDPACOMPARE pfnCompare,
    IN PFNDPAMERGE   pfnMerge,
    IN LPARAM        lParam)
{
    BOOL bRet = FALSE;

    if (IS_VALID_HANDLE(pdpaSrc, DPA) &&
        IS_VALID_HANDLE(pdpaDest, DPA) &&
        IS_VALID_CODE_PTR(pfnCompare, PFNDPACOMPARE) &&
        IS_VALID_CODE_PTR(pfnMerge, PFNDPAMERGE))
    {
        int iSrc;
        int iDest;
        int nCmp;
        void **ppvSrc;
        void **ppvDest;

        bRet = TRUE;

        // Are the arrays already sorted?
        if ( !(dwFlags & DPAM_SORTED) )
        {
            // No; sort them
            DPA_Sort(pdpaSrc, pfnCompare, lParam);
            DPA_Sort(pdpaDest, pfnCompare, lParam);
        }

        // This merges in-place. The size of the resulting DPA 
        // depends on the options:
        //
        //   DPAM_NORMAL    Same size as the dest DPA before 
        //                  the merge.  
        //
        //   DPAM_UNION     Min size is the larger of the two.
        //                  Max size is the sum of the two.
        //
        //   DPAM_INTERSECT Min size is zero.
        //                  Max size is the smaller of the two.
        // 
        // We iterate backwards to minimize the amount of moves we 
        // incur by calling DPA_DeletePtr.
        //

        iSrc = pdpaSrc->cp - 1;
        iDest = pdpaDest->cp - 1;
        ppvSrc = &DPA_FastGetPtr(pdpaSrc, iSrc);
        ppvDest = &DPA_FastGetPtr(pdpaDest, iDest);

        while (0 <= iSrc && 0 <= iDest)
        {
            void *pv;

            nCmp = pfnCompare(*ppvDest, *ppvSrc, lParam);

            if (0 == nCmp)
            {
                // Elements match; merge them.  
                pv = pfnMerge(DPAMM_MERGE, *ppvDest, *ppvSrc, lParam);
                if (NULL == pv)
                {
                    bRet = FALSE;
                    break;
                }
                *ppvDest = pv;

                iSrc--;
                ppvSrc--;
                iDest--;
                ppvDest--;
            }
            else if (0 < nCmp)
            {
                // pvSrc < pvDest. The source array doesn't have pvDest.
                if (dwFlags & DPAM_INTERSECT)
                {
                    // Delete pvDest 
                    pfnMerge(DPAMM_DELETE, DPA_DeletePtr(pdpaDest, iDest), NULL, lParam);
                }
                else
                {
                    ; // Keep it (do nothing)
                }

                // Move onto the next element in the dest array
                iDest--;
                ppvDest--;
            }
            else
            {
                // pvSrc > pvDest. The dest array doesn't have pvSrc.
                if (dwFlags & DPAM_UNION)
                {
                    // Add pvSrc
                    pv = pfnMerge(DPAMM_INSERT, *ppvSrc, NULL, lParam);
                    if (NULL == pv)
                    {
                        bRet = FALSE;
                        break;
                    }

                    DPA_InsertPtr(pdpaDest, iDest+1, pv);
                    // DPA_InsertPtr may end up reallocating the pointer array
                    // thus making ppvDest invalid
                    ppvDest = &DPA_FastGetPtr(pdpaDest, iDest);
                }
                else
                {
                    ;  // Skip it (do nothing)
                }

                // Move onto the next element in the source array
                iSrc--;
                ppvSrc--;
            }
        }
        // there are some items left in src
        if ((dwFlags & DPAM_UNION) && 0 <= iSrc)
        {
            for (; 0 <= iSrc; iSrc--, ppvSrc--)
            {
                void *pv = pfnMerge(DPAMM_INSERT, *ppvSrc, NULL, lParam);
                if (NULL == pv)
                {
                    bRet = FALSE;
                    break;
                }
                DPA_InsertPtr(pdpaDest, 0, pv);
            }
        }
    }

    return bRet;
}


BOOL WINAPI DPA_Sort(HDPA pdpa, PFNDPACOMPARE pfnCmp, LPARAM lParam)
{
    SORTPARAMS sp;

    sp.cp = pdpa->cp;
    sp.pp = pdpa->pp;
    sp.pfnCmp = pfnCmp;
    sp.lParam = lParam;

#ifdef USEQUICKSORT
    return DPA_QuickSort(&sp);
#endif
#ifdef USEHEAPSORT
    return DPA_HeapSort(&sp);
#endif
#ifdef MERGESORT
    return DPA_MergeSort(&sp);
#endif
}

#ifdef USEQUICKSORT

BOOL DPA_QuickSort(SORTPARAMS* psp)
{
    return DPA_QuickSort2(0, psp->cp - 1, psp);
}

BOOL DPA_QuickSort2(int i, int j, SORTPARAMS* psp)
{
    void** pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNDPACOMPARE pfnCmp = psp->pfnCmp;

    int iPivot;
    void* pFirst;
    int k;
    int result;

    iPivot = -1;
    pFirst = pp[i];
    for (k = i + 1; k <= j; k++)
    {
        result = (*pfnCmp)(pp[k], pFirst, lParam);

        if (result > 0)
        {
            iPivot = k;
            break;
        }
        else if (result < 0)
        {
            iPivot = i;
            break;
        }
    }

    if (iPivot != -1)
    {
        int l = i;
        int r = j;
        void* pivot = pp[iPivot];

        do
        {
            void* p;

            p = pp[l];
            pp[l] = pp[r];
            pp[r] = p;

            while ((*pfnCmp)(pp[l], pivot, lParam) < 0)
                l++;
            while ((*pfnCmp)(pp[r], pivot, lParam) >= 0)
                r--;
        } while (l <= r);

        if (l - 1 > i)
            DPA_QuickSort2(i, l - 1, psp);
        if (j > l)
            DPA_QuickSort2(l, j, psp);
    }
    return TRUE;
}
#endif  // USEQUICKSORT

#ifdef USEHEAPSORT

void DPA_HeapSortPushDown(int first, int last, SORTPARAMS* psp)
{
    void** pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNDPACOMPARE pfnCmp = psp->pfnCmp;
    int r;
    int r2;
    void* p;

    r = first;
    while (r <= last / 2)
    {
        int wRTo2R;
        r2 = r * 2;

        wRTo2R = (*pfnCmp)(pp[r-1], pp[r2-1], lParam);

        if (r2 == last)
        {
            if (wRTo2R < 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2-1]; pp[r2-1] = p;
            }
            break;
        }
        else
        {
            int wR2toR21 = (*pfnCmp)(pp[r2-1], pp[r2+1-1], lParam);

            if (wRTo2R < 0 && wR2toR21 >= 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2-1]; pp[r2-1] = p;
                r = r2;
            }
            else if ((*pfnCmp)(pp[r-1], pp[r2+1-1], lParam) < 0 && wR2toR21 < 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2+1-1]; pp[r2+1-1] = p;
                r = r2 + 1;
            }
            else
            {
                break;
            }
        }
    }
}

BOOL DPA_HeapSort(SORTPARAMS* psp)
{
    void** pp = psp->pp;
    int c = psp->cp;
    int i;

    for (i = c / 2; i >= 1; i--)
        DPA_HeapSortPushDown(i, c, psp);

    for (i = c; i >= 2; i--)
    {
        void* p = pp[0]; pp[0] = pp[i-1]; pp[i-1] = p;

        DPA_HeapSortPushDown(1, i - 1, psp);
    }
    return TRUE;
}
#endif  // USEHEAPSORT

#if defined(MERGESORT)

#define SortCompare(psp, pp1, i1, pp2, i2) \
    (psp->pfnCmp(pp1[i1], pp2[i2], psp->lParam))

//
//  This function merges two sorted lists and makes one sorted list.
//   psp->pp[iFirst, iFirst+cItes/2-1], psp->pp[iFirst+cItems/2, iFirst+cItems-1]
//
void DPA_MergeThem(SORTPARAMS* psp, int iFirst, int cItems)
{
    //
    // Notes:
    //  This function is separated from DPA_MergeSort2() to avoid comsuming
    // stack variables. Never inline this.
    //
    int cHalf = cItems/2;
    int iIn1, iIn2, iOut;
    void **ppvSrc = &psp->pp[iFirst];

    // Copy the first part to temp storage so we can write directly into
    // the final buffer.  Note that this takes at most psp->cp/2 DWORD's
    CopyMemory(psp->ppT, ppvSrc, cHalf * sizeof(void*));

    for (iIn1=0, iIn2=cHalf, iOut=0;;)
    {
        if (SortCompare(psp, psp->ppT, iIn1, ppvSrc, iIn2) <= 0) {
            ppvSrc[iOut++] = psp->ppT[iIn1++];

            if (iIn1==cHalf) {
                // We used up the first half; the rest of the second half
                // should already be in place
                break;
            }
        } else {
            ppvSrc[iOut++] = ppvSrc[iIn2++];
            if (iIn2==cItems) {
                // We used up the second half; copy the rest of the first half
                // into place
                CopyMemory(&ppvSrc[iOut], &psp->ppT[iIn1], (cItems-iOut)*sizeof(void *));
                break;
            }
        }
    }
}

//
//  This function sorts a give list (psp->pp[iFirst,iFirst-cItems-1]).
//
void DPA_MergeSort2(SORTPARAMS* psp, int iFirst, int cItems)
{
    //
    // Notes:
    //   This function is recursively called. Therefore, we should minimize
    //  the number of local variables and parameters. At this point, we
    //  use one local variable and three parameters.
    //
    int cHalf;

    switch(cItems)
    {
    case 1:
        return;

    case 2:
        // Swap them, if they are out of order.
        if (SortCompare(psp, psp->pp, iFirst, psp->pp, iFirst+1) > 0)
        {
            psp->ppT[0] = psp->pp[iFirst];
            psp->pp[iFirst] = psp->pp[iFirst+1];
            psp->pp[iFirst+1] = psp->ppT[0];
        }
        break;

    default:
        cHalf = cItems/2;

        // Sort each half
        DPA_MergeSort2(psp, iFirst, cHalf);
        DPA_MergeSort2(psp, iFirst+cHalf, cItems-cHalf);
        // Then, merge them.
        DPA_MergeThem(psp, iFirst, cItems);
        break;
    }
}

BOOL DPA_MergeSort(SORTPARAMS* psp)
{
    if (psp->cp==0)
        return TRUE;

    // Note that we divide by 2 below; we want to round down
    psp->ppT = LocalAlloc(LPTR, psp->cp/2 * sizeof(void *));
    if (!psp->ppT)
        return FALSE;

    DPA_MergeSort2(psp, 0, psp->cp);
    LocalFree(psp->ppT);
    return TRUE;
}
#endif // MERGESORT

// Search function
//
int WINAPI DPA_Search(HDPA pdpa, void* pFind, int iStart,
            PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options)
{
    int cp = DPA_GetPtrCount(pdpa);

    ASSERT(pfnCompare);
    ASSERT(0 <= iStart);

    // Only allow these wierd flags if the list is sorted
    ASSERT((options & DPAS_SORTED) || !(options & (DPAS_INSERTBEFORE | DPAS_INSERTAFTER)));

    if (!(options & DPAS_SORTED))
    {
        // Not sorted: do linear search.
        int i;

        for (i = iStart; i < cp; i++)
        {
            if (0 == pfnCompare(pFind, DPA_FastGetPtr(pdpa, i), lParam))
                return i;
        }
        return -1;
    }
    else
    {
        // Search the array using binary search.  If several adjacent
        // elements match the target element, the index of the first
        // matching element is returned.

        int iRet = -1;      // assume no match
        BOOL bFound = FALSE;
        int nCmp = 0;
        int iLow = 0;       // Don't bother using iStart for binary search
        int iMid = 0;
        int iHigh = cp - 1;

        // (OK for cp == 0)
        while (iLow <= iHigh)
        {
            iMid = (iLow + iHigh) / 2;

            nCmp = pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid), lParam);

            if (0 > nCmp)
                iHigh = iMid - 1;       // First is smaller
            else if (0 < nCmp)
                iLow = iMid + 1;        // First is larger
            else
            {
                // Match; search back for first match
                bFound = TRUE;
                while (0 < iMid)
                {
                    if (0 != pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid-1), lParam))
                        break;
                    else
                        iMid--;
                }
                break;
            }
        }

        if (bFound)
        {
            ASSERT(0 <= iMid);
            iRet = iMid;
        }

        // Did the search fail AND
        // is one of the strange search flags set?
        if (!bFound && (options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)))
        {
            // Yes; return the index where the target should be inserted
            // if not found
            if (0 < nCmp)       // First is larger
                iRet = iLow;
            else
                iRet = iMid;
            // (We don't distinguish between the two flags anymore)
        }
        else if ( !(options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)) )
        {
            // Sanity check with linear search
            ASSERT(DPA_Search(pdpa, pFind, iStart, pfnCompare, lParam, options & ~DPAS_SORTED) == iRet);
        }
        return iRet;
    }
}

//===========================================================================
//
// String ptr management routines
//
// Copy as much of *psz to *pszBuf as will fit
//
// Warning:  this same code is duplicated below.
//
int WINAPI Str_GetPtr(LPCTSTR pszCurrent, LPTSTR pszBuf, int cchBuf)
{
    int cchToCopy;

    if (!pszCurrent)
    {
        ASSERT(FALSE);
        
        if (cchBuf > 0)
        {
            *pszBuf = TEXT('\0');
        }

        return 0;
    }

    cchToCopy = lstrlen(pszCurrent);

    // if pszBuf is NULL, or they passed cchBuf = 0, return the needed buff size
    if (!pszBuf || !cchBuf)
    {
        return cchToCopy + 1;
    }
    
    if (cchToCopy >= cchBuf)
    {
        cchToCopy = cchBuf - 1;
    }

    CopyMemory(pszBuf, pszCurrent, cchToCopy * sizeof(TCHAR));
    pszBuf[cchToCopy] = TEXT('\0');

    return cchToCopy + 1;
}

#ifdef DEBUG
//
//  Str_GetPtr0 is just like Str_GetPtr except that it doesn't assert if
//  pszCurrent = NULL.
//
int WINAPI Str_GetPtr0(LPCTSTR pszCurrent, LPTSTR pszBuf, int cchBuf)
{
    return Str_GetPtr(pszCurrent ? pszCurrent : c_szNULL, pszBuf, cchBuf);
}
#endif

//
// If we are build Unicode, then this is the ANSI version
// of the above function.
//

int WINAPI Str_GetPtrA(LPCSTR pszCurrent, LPSTR pszBuf, int cchBuf)
{
    int cchToCopy;

    if (!pszCurrent)
    {
        ASSERT(FALSE);

        if (cchBuf > 0)
        {
            *pszBuf = '\0';
        }

        return 0;
    }

    cchToCopy = lstrlenA(pszCurrent);

    // if pszBuf is NULL, or they passed cchBuf = 0, return the needed buff size
    if (!pszBuf || !cchBuf)
    {
        return cchToCopy + 1;
    }
    
    if (cchToCopy >= cchBuf)
    {
        cchToCopy = cchBuf - 1;
    }

    CopyMemory(pszBuf, pszCurrent, cchToCopy * sizeof(CHAR));
    pszBuf[cchToCopy] = TEXT('\0');

    return cchToCopy + 1;
}

//
// This function is not exported.
//

BOOL Str_Set(LPTSTR *ppsz, LPCTSTR psz)
{
    if (!psz || (psz == LPSTR_TEXTCALLBACK))
    {
        if (*ppsz)
        {
            if (*ppsz != (LPSTR_TEXTCALLBACK))
                LocalFree(*ppsz);
        }
        *ppsz = (LPTSTR)psz;
    }
    else
    {
        LPTSTR pszNew = *ppsz;
        UINT   cbNew = (lstrlen(psz) + 1) * sizeof(TCHAR);

        if (pszNew == LPSTR_TEXTCALLBACK)
        {
            pszNew = NULL;
        }
        
        pszNew = CCLocalReAlloc(pszNew, cbNew);

        if (!pszNew)
        {
            return FALSE;
        }

        StringCbCopy(pszNew, cbNew, psz);
        *ppsz = pszNew;
    }
    return TRUE;
}

// Set *ppszCurrent to a copy of pszNew, and free the previous value, if necessary
//
// WARNING:  This same code is duplicated below
//
BOOL WINAPI Str_SetPtr(LPTSTR * ppszCurrent, LPCTSTR pszNew)
{
    LPTSTR pszOld;
    LPTSTR pszNewCopy = NULL;

    if (pszNew)
    {
        DWORD cchNewCopy = lstrlen(pszNew)+1;

        // alloc a new buffer w/ room for the null terminator
        pszNewCopy = (LPTSTR) Alloc(cchNewCopy * sizeof(TCHAR));

        if (!pszNewCopy)
        {
            return FALSE;
        }

        StringCchCopy(pszNewCopy, cchNewCopy, pszNew);
    }
    
    pszOld = InterlockedExchangePointer((void **)ppszCurrent, pszNewCopy);

    if (pszOld)
    {
        Free(pszOld);
    }

    return TRUE;
}

//
// ANSI stub when built Unicode.
//

BOOL WINAPI Str_SetPtrA(LPSTR * ppszCurrent, LPCSTR pszNew)
{
    LPSTR pszOld;
    LPSTR pszNewCopy = NULL;

    if (pszNew)
    {
        DWORD cchNewCopy = lstrlenA(pszNew)+1;

        // alloc a new buffer w/ room for the null terminator
        pszNewCopy = (LPSTR) Alloc(cchNewCopy * sizeof(CHAR));

        if (!pszNewCopy)
        {
            return FALSE;
        }

        StringCchCopyA(pszNewCopy, cchNewCopy, pszNew);
    }

    pszOld = InterlockedExchangePointer((void **)ppszCurrent, pszNewCopy);

    if (pszOld)
    {
        Free(pszOld);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\editrare.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "edit.h"


//---------------------------------------------------------------------------//
#define WS_EX_EDGEMASK (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)


#define GetCharABCWidthsAorW    ((ped)->fAnsi ? GetCharABCWidthsA : GetCharABCWidthsW)
#define GetCharWidthAorW        ((ped)->fAnsi ? GetCharWidthA : GetCharWidthW)


//---------------------------------------------------------------------------//
INT Edit_GetStateId(PED ped)
{
    INT iStateId;

    if (ped->fDisabled)
    {
        iStateId = ETS_DISABLED;
    }
    else if (ped->fReadOnly)
    {
        iStateId = ETS_READONLY;
    }
    else if (ped->fFocus)
    {
        iStateId = ETS_FOCUSED;
    }
    else if (ped->fHot)
    {
        iStateId = ETS_HOT;
    }
    else
    {
        iStateId = ETS_NORMAL;
    }

    return iStateId;
}


//---------------------------------------------------------------------------//
VOID Edit_SetMargin(PED ped, UINT  wFlags, long lMarginValues, BOOL fRedraw)
{
    BOOL fUseFontInfo = FALSE;
    UINT wValue, wOldLeftMargin, wOldRightMargin;


    if (wFlags & EC_LEFTMARGIN)
    {
        //
        // Set the left margin
        //
        if ((int) (wValue = (int)(short)LOWORD(lMarginValues)) < 0) 
        {
            fUseFontInfo = TRUE;
            wValue = min((ped->aveCharWidth / 2), (int)ped->wMaxNegA);
        }

        ped->rcFmt.left += wValue - ped->wLeftMargin;
        wOldLeftMargin = ped->wLeftMargin;
        ped->wLeftMargin = wValue;
    }

    if (wFlags & EC_RIGHTMARGIN)
    {
        //
        // Set the Right margin
        //
        if ((int) (wValue = (int)(short)HIWORD(lMarginValues)) < 0) 
        {
            fUseFontInfo = TRUE;
            wValue = min((ped->aveCharWidth / 2), (int)ped->wMaxNegC);
        }

        ped->rcFmt.right -= wValue - ped->wRightMargin;
        wOldRightMargin = ped->wRightMargin;
        ped->wRightMargin = wValue;
    }

    if (fUseFontInfo) 
    {
        if (ped->rcFmt.right - ped->rcFmt.left < 2 * ped->aveCharWidth) 
        {
            TraceMsg(TF_STANDARD, "EDIT: Edit_SetMargin: rcFmt is too narrow for EC_USEFONTINFO");

            if (wFlags & EC_LEFTMARGIN)
            {
                //
                // Reset the left margin
                //
                ped->rcFmt.left += wOldLeftMargin - ped->wLeftMargin;
                ped->wLeftMargin = wOldLeftMargin;
            }

            if (wFlags & EC_RIGHTMARGIN)
            {
                //
                // Reset the Right margin
                //
                ped->rcFmt.right -= wOldRightMargin - ped->wRightMargin;
                ped->wRightMargin = wOldRightMargin;
            }

            return;
        }
    }

    if (fRedraw) 
    {
        Edit_InvalidateClient(ped, TRUE);
    }
}


//---------------------------------------------------------------------------//
VOID Edit_CalcMarginForDBCSFont(PED ped, BOOL fRedraw)
{
    if (ped->fTrueType)
    {
        if (!ped->fSingle) 
        {
            //
            // wMaxNegA came from ABC CharWidth.
            //
            if (ped->wMaxNegA != 0) 
            {
                Edit_SetMargin(ped, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                        MAKELONG(EC_USEFONTINFO, EC_USEFONTINFO),fRedraw);
            }
        } 
        else 
        {
            int    iMaxNegA = 0, iMaxNegC = 0;
            int    i;
            PVOID  lpBuffer;
            LPABC  lpABCBuff;
            ABC    ABCInfo;
            HFONT  hOldFont;
            HDC    hdc = GetDC(ped->hwnd);

            if (!ped->hFont || !(hOldFont = SelectFont(hdc, ped->hFont))) 
            {
                ReleaseDC(ped->hwnd, hdc);
                return;
            }

            if (lpBuffer = UserLocalAlloc(0,sizeof(ABC) * 256)) 
            {
                lpABCBuff = lpBuffer;
                GetCharABCWidthsAorW(hdc, 0, 255, lpABCBuff);
            } 
            else 
            {
                lpABCBuff = &ABCInfo;
                GetCharABCWidthsAorW(hdc, 0, 0, lpABCBuff);
            }

            i = 0;
            while (TRUE) 
            {
                iMaxNegA = min(iMaxNegA, lpABCBuff->abcA);
                iMaxNegC = min(iMaxNegC, lpABCBuff->abcC);

                if (++i == 256)
                {
                    break;
                }

                if (lpBuffer) 
                {
                    lpABCBuff++;
                } 
                else 
                {
                    GetCharABCWidthsAorW(hdc, i, i, lpABCBuff);
                }
            }

            SelectFont(hdc, hOldFont);

            if (lpBuffer)
            {
                UserLocalFree(lpBuffer);
            }

            ReleaseDC(ped->hwnd, hdc);

            if ((iMaxNegA != 0) || (iMaxNegC != 0))
            {
               Edit_SetMargin(ped, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                        MAKELONG((UINT)(-iMaxNegC), (UINT)(-iMaxNegA)),fRedraw);
            }
        }

    }
}


//---------------------------------------------------------------------------//
//
// GetCharDimensionsEx(HDC hDC, HFONT hfont, LPTEXTMETRIC lptm, LPINT lpcy)
//
// if an app set a font for vertical writing, even though we don't
// handle it with EC, the escapement of tm can be NON 0. Then cxWidth from
// GetCharDimenstions() could be 0 in GetCharDimensions().
// This will break our caller who don't expect 0 at return. So I created
// this entry  for the case the caller set vertical font.
//
//
// PORTPORT: Duplicates functionality of GetCharDimensions() in prsht.c
int UserGetCharDimensionsEx(HDC hDC, HFONT hfont, LPTEXTMETRICW lptm, LPINT lpcy)
{
    static CONST WCHAR AveCharWidthData[] = L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    int         cxWidth;
    TEXTMETRICW tm;
    LOGFONTW    lf;
    WCHAR       wchFaceName[LF_FACESIZE];

    //
    // Is this font vertical font ??
    //
    wchFaceName[0] = 0;
    GetTextFaceW(hDC, LF_FACESIZE, wchFaceName);
    if (wchFaceName[0] != L'@') 
    {
        //
        // if not call GDI...
        //
        return(GdiGetCharDimensions(hDC, lptm, lpcy));
    }

    if (!lptm)
    {
        lptm = &tm;
    }

    GetTextMetricsW(hDC, lptm);

    // TMPF_FIXED_PITCH
    //
    //   If this bit is set the font is a variable pitch font.
    //   If this bit is clear the font is a fixed pitch font.
    // Note very carefully that those meanings are the opposite of what the constant name implies.
    //
    if (!(lptm->tmPitchAndFamily & TMPF_FIXED_PITCH)) 
    {
        //
        // This is fixed pitch font....
        //
        cxWidth = lptm->tmAveCharWidth;
    } 
    else 
    {
        //
        // This is variable pitch font...
        //
        if (hfont && GetObjectW(hfont, sizeof(LOGFONTW), &lf) && (lf.lfEscapement != 0)) 
        {
            cxWidth = lptm->tmAveCharWidth;
        } 
        else 
        {
            SIZE size;
            GetTextExtentPointW(hDC, AveCharWidthData, 52, &size);
            cxWidth = ((size.cx / 26) + 1) / 2;
        }
    }

    if (lpcy)
    {
        *lpcy = lptm->tmHeight;
    }

    return cxWidth;
}


//---------------------------------------------------------------------------//
//
// Edit_GetTextHandler AorW
//
// Copies at most maxCchToCopy chars to the buffer lpBuffer. Returns
// how many chars were actually copied. Null terminates the string based
// on the fNullTerminate flag:
// fNullTerminate --> at most (maxCchToCopy - 1) characters will be copied
// !fNullTerminate --> at most (maxCchToCopy) characters will be copied
//
ICH Edit_GetTextHandler(PED ped, ICH maxCchToCopy, LPSTR lpBuffer, BOOL fNullTerminate)
{
    PSTR pText;

    if (maxCchToCopy) 
    {
        //
        // Zero terminator takes the extra byte
        //
        if (fNullTerminate)
        {
            maxCchToCopy--;
        }
        maxCchToCopy = min(maxCchToCopy, ped->cch);

        //
        // Zero terminate the string
        //
        if (ped->fAnsi)
        {
            *(LPSTR)(lpBuffer + maxCchToCopy) = 0;
        }
        else
        {
            *(((LPWSTR)lpBuffer) + maxCchToCopy) = 0;
        }

        pText = Edit_Lock(ped);
        RtlCopyMemory(lpBuffer, pText, maxCchToCopy * ped->cbChar);
        Edit_Unlock(ped);
    }

    return maxCchToCopy;
}


//---------------------------------------------------------------------------//
BOOL Edit_NcCreate( PED ped, HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    BOOL    fAnsi;
    ULONG   ulStyle;
    ULONG   ulStyleEx;

    //
    // Initialize the ped
    //
    ped->hwnd = hwnd;
    ped->pww = (PWW)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);

    ulStyle = GET_STYLE(ped);
    ulStyleEx = GET_EXSTYLE(ped);

    //
    // (phellyar) All strings sent to us via standard WM_* messages or 
    //            control specific EM_* messages are expanded to unicode 
    //            for us by user. Therefore we need worry about 
    //            whether be are created by and ANSI app.
    //
    //fAnsi = TESTFLAG(GET_STATE(ped), WS_ST_ANSICREATOR);
    fAnsi = 0;

    ped->fEncoded = FALSE;
    ped->iLockLevel = 0;

    ped->chLines = NULL;
    ped->pTabStops = NULL;
    ped->charWidthBuffer = NULL;
    ped->fAnsi = fAnsi ? 1 : 0; // Force TRUE to be 1 because its a 1 bit field
    ped->cbChar = (WORD)(fAnsi ? sizeof(CHAR) : sizeof(WCHAR));
    ped->hInstance = lpCreateStruct->hInstance;
    // IME
    ped->hImcPrev = NULL_HIMC;

    {
        DWORD dwVer = UserGetVersion();

        ped->fWin31Compat = Is310Compat(dwVer);
        ped->f40Compat = Is400Compat(dwVer);

    }

    //
    // NOTE:
    // The order of the following two checks is important.  People can
    // create edit fields with a 3D and a normal border, and we don't
    // want to disallow that.  But we need to detect the "no 3D border"
    // border case too.
    //
    if ( ulStyleEx & WS_EX_EDGEMASK )
    {
        ped->fBorder = TRUE;
    }
    else if ( ulStyle & WS_BORDER )
    {
        ClearWindowState(hwnd, WS_BORDER);
        ped->fFlatBorder = TRUE;
        ped->fBorder = TRUE;
    }

    if ( !(ulStyle & ES_MULTILINE) )
    {
        ped->fSingle = TRUE;
    }

    if ( ulStyle & WS_DISABLED )
    {
        ped->fDisabled = TRUE;
    }

    if ( ulStyle & ES_READONLY) 
    {
        if (!ped->fWin31Compat) 
        {
            //
            // BACKWARD COMPATIBILITY HACK
            // 
            // "MileStone" unknowingly sets the ES_READONLY style. So, we strip this
            // style here for all Win3.0 apps (this style is new for Win3.1).
            // Fix for Bug #12982 -- SANKAR -- 01/24/92 --
            //
            ClearWindowState(hwnd, ES_READONLY);
        } 
        else
        {
            ped->fReadOnly = TRUE;
        }
    }


    //
    // Allocate storage for the text for the edit controls. Storage for single
    // line edit controls will always get allocated in the local data segment.
    // Multiline will allocate in the local ds but the app may free this and
    // allocate storage elsewhere...
    //
    ped->hText = LocalAlloc(LHND, CCHALLOCEXTRA*ped->cbChar);
    if (!ped->hText) 
    {
        return FALSE;
    }

    ped->cchAlloc = CCHALLOCEXTRA;
    ped->lineHeight = 1;

    ped->hwndParent = lpCreateStruct->hwndParent;
    ped->hTheme = OpenThemeData(ped->hwnd, L"Edit");

    ped->wImeStatus = 0;

    return (BOOL)DefWindowProc(hwnd, WM_NCCREATE, 0, (LPARAM)lpCreateStruct);
}


//---------------------------------------------------------------------------//
BOOL Edit_Create(PED ped, LONG windowStyle)
{
    HDC hdc;

    //
    // Get values from the window instance data structure and put 
    // them in the ped so that we can access them easier.
    //
    if ( windowStyle & ES_AUTOHSCROLL )
    {
        ped->fAutoHScroll = 1;
    }

    if ( windowStyle & ES_NOHIDESEL )
    {
        ped->fNoHideSel = 1;
    }

    ped->format = (LOWORD(windowStyle) & LOWORD(ES_FMTMASK));
    if ((windowStyle & ES_RIGHT) && !ped->format)
    {
        ped->format = ES_RIGHT;
    }

    //
    // Max # chars we will initially allow
    //
    ped->cchTextMax = MAXTEXT;

    //
    // Set up undo initial conditions... (ie. nothing to undo)
    //
    ped->ichDeleted = (ICH)-1;
    ped->ichInsStart = (ICH)-1;
    ped->ichInsEnd = (ICH)-1;

    //
    // initial charset value - need to do this BEFORE EditML_Create is called
    // so that we know not to fool with scrollbars if nessacary
    //
    hdc = Edit_GetDC(ped, TRUE);
    ped->charSet = (BYTE)GetTextCharset(hdc);
    Edit_ReleaseDC(ped, hdc, TRUE);

    //
    // FE_IME
    // EC_INSERT_COMPOSITION_CHARACTER: Edit_Create() - call Edit_InitInsert()
    //
    Edit_InitInsert(ped, GetKeyboardLayout(0));


    if( g_pLpkEditCallout )
    {
        ped->pLpkEditCallout = g_pLpkEditCallout;
    } 
    else
    {
        ped->pLpkEditCallout = NULL;
    }

    return ped->pLpkEditCallout ? ped->pLpkEditCallout->EditCreate((PED0)ped, ped->hwnd) : TRUE;
}


//---------------------------------------------------------------------------//
//
// Do this once at process startup. The edit control has special
// callouts in lpk.dll to help it render complex script languages
// such as Arabic. The registry probing alg executed here is the same
// as the one performed in win32k!InitializeGre.
//
// We then call GetModuleHandle rather than LoadLibrary, since lpk.dll
// will be guaranteed to be loaded and initialized already by gdi32. This 
// fixes the scenario in which the user turns on complex scripts but
// doesn't reboot, which caused us to try and load lpk without it having
// been initialized on the kernel side.
// 
VOID InitEditLpk()
{
    LONG lError;
    HKEY hKey;

    lError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\LanguagePack"),
                          0,
                          KEY_QUERY_VALUE,
                          &hKey);

    if (lError == ERROR_SUCCESS)
    {
        HANDLE hLpk;
        DWORD  dwLpkShapingDlls;
        DWORD  dwIndex;
        TCHAR  szTemp[256];
        DWORD  dwTempSize;
        DWORD  dwValueType;
        DWORD  dwValue;
        DWORD  dwValueSize;

        dwLpkShapingDlls = 0;
        dwIndex = 0;
        do 
        {
            dwTempSize  = ARRAYSIZE(szTemp);
            dwValueSize = SIZEOF(DWORD);
            lError = RegEnumValue(hKey,
                                  dwIndex++,
                                  szTemp,
                                  &dwTempSize,
                                  NULL,
                                  &dwValueType,
                                  (LPVOID)&dwValue,
                                  &dwValueSize);

            if ((lError == ERROR_SUCCESS) && (dwValueType == REG_DWORD))
            {
                dwLpkShapingDlls |= 1 << dwValue;
            }
        } 
        while (lError != ERROR_NO_MORE_ITEMS);

        if (dwLpkShapingDlls != 0)
        {
            hLpk = GetModuleHandle(TEXT("LPK"));
            if (hLpk != NULL)
            {
                g_pLpkEditCallout = (PLPKEDITCALLOUT)GetProcAddress(hLpk, "LpkEditControl");

                if (g_pLpkEditCallout == NULL)
                {
                    FreeLibrary(hLpk);
                }
            }
        }

        RegCloseKey(hKey);
    }
}


//---------------------------------------------------------------------------//
//
// Destroys the edit control ped by freeing up all memory used by it.
//
VOID Edit_NcDestroyHandler(HWND hwnd, PED ped)
{
    //
    // ped could be NULL if WM_NCCREATE failed to create it...
    //
    if (ped) 
    {
        //
        // Free the text buffer (always present?)
        //
        if (TESTFLAG(GET_STYLE(ped), ES_PASSWORD))
        {
            LPWSTR pszText = LocalLock(ped->hText);
            RtlSecureZeroMemory(pszText, LocalSize(ped->hText));
            LocalUnlock(ped->hText);
        }
        LocalFree(ped->hText);

        
        //
        // Free up undo buffer and line start array (if present)
        //
        if (ped->hDeletedText != NULL)
        {
            GlobalFree(ped->hDeletedText);
        }

        //
        // Free tab stop buffer (if present)
        //
        if (ped->pTabStops)
        {
            UserLocalFree(ped->pTabStops);
        }

        //
        // Free line start array (if present)
        //
        if (ped->chLines) 
        {
            UserLocalFree(ped->chLines);
        }

        //
        // Free the character width buffer (if present)
        //
        if (ped->charWidthBuffer)
        {
            UserLocalFree(ped->charWidthBuffer);
        }

        //
        // Free the cursor bitmap
        //
        if (ped->pLpkEditCallout && ped->hCaretBitmap)
        {
            DeleteObject(ped->hCaretBitmap);
        }

        //
        // Free the cached font handle
        //
        if ( ped->hFontSave )
        {
            DeleteObject(ped->hFontSave);
        }

        //
        // Close an open theme handle
        //
        if ( ped->hTheme )
        {
            CloseThemeData(ped->hTheme);
        }

        // 
        // Free the memory used by CueBannerText
        //
        Str_SetPtr(&(ped->pszCueBannerText), NULL);

        //
        // free the allocated password font
        //
        if ( ped->hFontPassword )
        {
            DeleteObject(ped->hFontPassword);
        }

        //
        // Last but not least, free the ped
        //
        UserLocalFree(ped);
    }

    TraceMsg(TF_STANDARD, "EDIT: Clearing edit instance pointer.");
    Edit_SetPtr(hwnd, NULL);
}


//---------------------------------------------------------------------------//
// 
// Edit_SetPasswordCharHandler AorW
//
// Sets the password char to display.
//
VOID Edit_SetPasswordCharHandler(PED ped, UINT pwchar)
{
    HDC hdc;
    SIZE size = {0};

    ped->charPasswordChar = pwchar;

    if (pwchar) 
    {
        hdc = Edit_GetDC(ped, TRUE);

        if (ped->fAnsi)
        {
            GetTextExtentPointA(hdc, (LPSTR)&pwchar, 1, &size);
        }
        else
        {
            GetTextExtentPointW(hdc, (LPWSTR)&pwchar, 1, &size);
        }

        GetTextExtentPointW(hdc, (LPWSTR)&pwchar, 1, &size);
        ped->cPasswordCharWidth = max(size.cx, 1);
        Edit_ReleaseDC(ped, hdc, TRUE);
    }

    if (pwchar)
    {
        SetWindowState(ped->hwnd, ES_PASSWORD);
    }
    else
    {
        ClearWindowState(ped->hwnd, ES_PASSWORD);
    }

    if ( g_fIMMEnabled )
    {
        Edit_EnableDisableIME(ped);
    }
}


//---------------------------------------------------------------------------//
//
// GetNegABCwidthInfo()
//
// This function fills up the ped->charWidthBuffer buffer with the
// negative A,B and C widths for all the characters below 0x7f in the
// currently selected font.
//
// Returns:
//   TRUE, if the function succeeded.
//   FALSE, if GDI calls to get the char widths have failed.
//
// Note: not used if LPK installed
// 
BOOL GetNegABCwidthInfo(PED ped, HDC hdc)
{
    LPABC lpABCbuff;
    int   i;
    int   CharWidthBuff[CHAR_WIDTH_BUFFER_LENGTH]; // Local char width buffer.
    int   iOverhang;

    if (!GetCharABCWidthsA(hdc, 0, CHAR_WIDTH_BUFFER_LENGTH-1, (LPABC)ped->charWidthBuffer)) 
    {
        TraceMsg(TF_STANDARD, "UxEdit: GetNegABCwidthInfo: GetCharABCWidthsA Failed");
        return FALSE;
    }

    // 
    // The (A+B+C) returned for some fonts (eg: Lucida Caligraphy) does not
    // equal the actual advanced width returned by GetCharWidths() minus overhang.
    // This is due to font bugs. So, we adjust the 'B' width so that this
    // discrepancy is removed.
    // Fix for Bug #2932 --sankar-- 02/17/93
    //
    iOverhang = ped->charOverhang;
    GetCharWidthA(hdc, 0, CHAR_WIDTH_BUFFER_LENGTH-1, (LPINT)CharWidthBuff);
    lpABCbuff = (LPABC)ped->charWidthBuffer;
    for(i = 0; i < CHAR_WIDTH_BUFFER_LENGTH; i++) 
    {
         lpABCbuff->abcB = CharWidthBuff[i] - iOverhang
                 - lpABCbuff->abcA
                 - lpABCbuff->abcC;
         lpABCbuff++;
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// Edit_Size() -
//
// Handle sizing for an edit control's client rectangle.
// Use lprc as the bounding rectangle if specified; otherwise use the current
// client rectangle.
//
VOID Edit_Size(PED ped, LPRECT lprc, BOOL fRedraw)
{
    RECT rc;

    //
    // BiDi VB32 Creates an Edit Control and immediately sends a WM_SIZE
    // message which causes EXSize to be called before Edit_SetFont, which
    // in turn causes a divide by zero exception below. This check for
    // ped->lineHeight will pick it up safely. [samera] 3/5/97
    //
    if(ped->lineHeight == 0)
    {
        return;
    }

    //
    // assume that we won't be able to display the caret
    //
    ped->fCaretHidden = TRUE;


    if ( lprc )
    {
        CopyRect(&rc, lprc);
    }
    else
    {
        GetClientRect(ped->hwnd, &rc);
    }

    if (!(rc.right - rc.left) || !(rc.bottom - rc.top)) 
    {
        if (ped->rcFmt.right - ped->rcFmt.left)
        {
            return;
        }

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = ped->aveCharWidth * 10;
        rc.bottom   = ped->lineHeight;
    }

    if (!lprc) 
    {
        //
        // subtract the margins from the given rectangle --
        // make sure that this rectangle is big enough to have these margins.
        //
        if ((rc.right - rc.left) > (int)(ped->wLeftMargin + ped->wRightMargin)) 
        {
            rc.left  += ped->wLeftMargin;
            rc.right -= ped->wRightMargin;
        }
    }

    //
    // Leave space so text doesn't touch borders.
    // For 3.1 compatibility, don't subtract out vertical borders unless
    // there is room.
    //
    if (ped->fBorder) 
    {
        INT cxBorder = GetSystemMetrics(SM_CXBORDER);
        INT cyBorder = GetSystemMetrics(SM_CYBORDER);

        if (ped->fFlatBorder)
        {
            cxBorder *= 2;
            cyBorder *= 2;
        }

        if (rc.bottom < rc.top + ped->lineHeight + 2*cyBorder)
        {
            cyBorder = 0;
        }

        InflateRect(&rc, -cxBorder, -cyBorder);
    }

    //
    // Is the resulting rectangle too small?  Don't change it then.
    //
    if ((!ped->fSingle) && ((rc.right - rc.left < (int) ped->aveCharWidth) ||
        ((rc.bottom - rc.top) / ped->lineHeight == 0)))
    {
        return;
    }

    //
    // now, we know we're safe to display the caret
    //
    ped->fCaretHidden = FALSE;

    CopyRect(&ped->rcFmt, &rc);

    if (ped->fSingle)
    {
        ped->rcFmt.bottom = min(rc.bottom, rc.top + ped->lineHeight);
    }
    else
    {
        EditML_Size(ped, fRedraw);
    }

    if (fRedraw) 
    {
        InvalidateRect(ped->hwnd, NULL, TRUE);
    }

    //
    // FE_IME
    // Edit_Size()  - call Edit_ImmSetCompositionWindow()
    //
    // normally this isn't needed because WM_SIZE will cause
    // WM_PAINT and the paint handler will take care of IME
    // composition window. However when the edit window is
    // restored from maximized window and client area is out
    // of screen, the window will not be redrawn.
    //
    if (ped->fFocus && g_fIMMEnabled && ImmIsIME(GetKeyboardLayout(0))) 
    {
        POINT pt;

        GetCaretPos(&pt);
        Edit_ImmSetCompositionWindow(ped, pt.x, pt.y);
    }
}


//---------------------------------------------------------------------------//
// 
// Edit_SetFont AorW
// 
// Sets the font used in the edit control.  Warning:  Memory compaction may
// occur if the font wasn't previously loaded.  If the font handle passed
// in is NULL, assume the system font.
//
BOOL Edit_SetFont(PED ped, HFONT hfont, BOOL fRedraw)
{
    TEXTMETRICW TextMetrics = {0};
    HDC         hdc;
    HFONT       hOldFont=NULL;
    DWORD       dwMaxOverlapChars;
    CHWIDTHINFO cwi;
    UINT        uExtracharPos;
    BOOL        fRet = FALSE;

    hdc = GetDC(ped->hwnd);
    if (hdc)
    {

#ifdef _USE_DRAW_THEME_TEXT_
        if (hfont)
        {
            ped->hFontSave = hfont;
        }

        if ( ped->hTheme )
        {
            //
            // use the theme font if we're themed
            //
            HRESULT hr;
            LOGFONT lf;
            hr = GetThemeFont(ped->hTheme, hdc, EP_EDITTEXT, 0, TMT_FONT, &lf);
            if ( SUCCEEDED(hr) )
            {
                hfont = CreateFontIndirect(&lf);
            }
        }
#endif // _USE_DRAW_THEME_TEXT_

        ped->hFont = hfont;
        if (ped->hFont)
        {
            //
            // Since the default font is the system font, no need to select it in
            // if that's what the user wants.
            //
            hOldFont = SelectObject(hdc, hfont);
            if (!hOldFont) 
            {
                hfont = ped->hFont = NULL;
            }

            //
            // Get the metrics and ave char width for the currently selected font
            //

            //
            // Call Vertical font-aware AveWidth compute function...
            //
            // FE_SB
            ped->aveCharWidth = UserGetCharDimensionsEx(hdc, hfont, &TextMetrics, &ped->lineHeight);

            //
            // This might fail when people uses network fonts (or bad fonts).
            //
            if (ped->aveCharWidth == 0) 
            {
                TraceMsg(TF_STANDARD, "EDIT: Edit_SetFont: GdiGetCharDimensions failed");
                if (hOldFont != NULL) 
                {
                    SelectObject(hdc, hOldFont);
                }

                //
                // We've messed up the ped so let's reset the font.
                // Note that we won't recurse more than once because we'll
                // pass hfont == NULL.
                // Too bad WM_SETFONT doesn't return a value.
                //
                return Edit_SetFont(ped, NULL, fRedraw);
            }
        } 
        else 
        {
            ped->aveCharWidth = UserGetCharDimensionsEx(hdc, hfont, &TextMetrics, &ped->lineHeight);

            // We should always be able to get the dimensions of the system font. Just in case
            // set these guys to known system font constants
            if ( ped->aveCharWidth == 0 )
            {
                ped->aveCharWidth = SYSFONT_CXCHAR;
                ped->lineHeight = SYSFONT_CYCHAR;
            }
        }

        ped->charOverhang = TextMetrics.tmOverhang;

        //
        // assume that they don't have any negative widths at all.
        //
        ped->wMaxNegA = ped->wMaxNegC = ped->wMaxNegAcharPos = ped->wMaxNegCcharPos = 0;

        //
        // Check if Proportional Width Font
        //
        // NOTE: as SDK doc says about TEXTMETRIC:
        // TMPF_FIXED_PITCH
        // If this bit is set the font is a variable pitch font. If this bit is clear
        // the font is a fixed pitch font. Note very carefully that those meanings are
        // the opposite of what the constant name implies.
        //
        // Thus we have to reverse the value using logical not (fNonPropFont has 1 bit width)
        //
        ped->fNonPropFont = !(TextMetrics.tmPitchAndFamily & FIXED_PITCH);

        //
        // Check for a TrueType font
        // Older app OZWIN chokes if we allocate a bigger buffer for TrueType fonts
        // So, for apps older than 4.0, no special treatment for TrueType fonts.
        //
        if (ped->f40Compat && (TextMetrics.tmPitchAndFamily & TMPF_TRUETYPE)) 
        {
            ped->fTrueType = GetCharWidthInfo(hdc, &cwi);
#if DBG
            if (!ped->fTrueType) 
            {
                TraceMsg(TF_STANDARD, "EDIT: Edit_SetFont: GetCharWidthInfo Failed");
            }
#endif
        } 
        else 
        {
            ped->fTrueType = FALSE;
        }

        // FE_SB
        //
        // In DBCS Windows, Edit Control must handle Double Byte Character
        // if tmCharSet field of textmetrics is double byte character set
        // such as SHIFTJIS_CHARSET(128:Japan), HANGEUL_CHARSET(129:Korea).
        //
        // We call Edit_GetDBCSVector even when fAnsi is false so that we could
        // treat ped->fAnsi and ped->fDBCS indivisually. I changed Edit_GetDBCSVector
        // function so that it returns 0 or 1, because I would like to set ped->fDBCS
        // bit field here.
        //
        ped->fDBCS = Edit_GetDBCSVector(ped,hdc,TextMetrics.tmCharSet);
        ped->charSet = TextMetrics.tmCharSet;

        if (ped->fDBCS) 
        {
            //
            // Free the character width buffer if ped->fDBCS.
            //
            // I expect single GetTextExtentPoint call is faster than multiple
            // GetTextExtentPoint call (because the graphic engine has a cache buffer).
            // See editec.c/ECTabTheTextOut().
            //
            if (ped->charWidthBuffer) 
            {
                LocalFree(ped->charWidthBuffer);
                ped->charWidthBuffer = NULL;
            }

            //
            // if FullWidthChar : HalfWidthChar == 2 : 1....
            //
            // TextMetrics.tmMaxCharWidth = FullWidthChar width
            // ped->aveCharWidth          = HalfWidthChar width
            //
            if (ped->fNonPropFont &&
                ((ped->aveCharWidth * 2) == TextMetrics.tmMaxCharWidth)) 
            {
                ped->fNonPropDBCS = TRUE;
            } 
            else 
            {
                ped->fNonPropDBCS = FALSE;
            }

        } 
        else 
        {
            //
            // Since the font has changed, let us obtain and save the character width
            // info for this font.
            //
            // First left us find out if the maximum chars that can overlap due to
            // negative widths. Since we can't access USER globals, we make a call here.
            //
            if (!(ped->fSingle || ped->pLpkEditCallout)) 
            {
                //
                // Is this a multiline edit control with no LPK present?
                //
                UINT  wBuffSize;
                LPINT lpCharWidthBuff;
                SHORT i;

                //
                // For multiline edit controls, we maintain a buffer that contains
                // the character width information.
                //
                wBuffSize = (ped->fTrueType) ? (CHAR_WIDTH_BUFFER_LENGTH * sizeof(ABC)) :
                                               (CHAR_WIDTH_BUFFER_LENGTH * sizeof(int));

                if (ped->charWidthBuffer) 
                {
                    //
                    // If buffer already present
                    //
                    lpCharWidthBuff = ped->charWidthBuffer;
                    ped->charWidthBuffer = UserLocalReAlloc(lpCharWidthBuff, wBuffSize, HEAP_ZERO_MEMORY);
                    if (ped->charWidthBuffer == NULL) 
                    {
                        UserLocalFree((HANDLE)lpCharWidthBuff);
                    }
                } 
                else 
                {
                    ped->charWidthBuffer = UserLocalAlloc(HEAP_ZERO_MEMORY, wBuffSize);
                }

                if (ped->charWidthBuffer != NULL) 
                {
                    if (ped->fTrueType) 
                    {
                        ped->fTrueType = GetNegABCwidthInfo(ped, hdc);
                    }

                    //
                    // It is possible that the above attempts could have failed and reset
                    // the value of fTrueType. So, let us check that value again.
                    //
                    if (!ped->fTrueType) 
                    {
                        if (!GetCharWidthA(hdc, 0, CHAR_WIDTH_BUFFER_LENGTH-1, ped->charWidthBuffer)) 
                        {
                            UserLocalFree((HANDLE)ped->charWidthBuffer);
                            ped->charWidthBuffer=NULL;
                        } 
                        else 
                        {
                            //
                            // We need to subtract out the overhang associated with
                            // each character since GetCharWidth includes it...
                            //
                            for (i=0;i < CHAR_WIDTH_BUFFER_LENGTH;i++)
                            {
                                ped->charWidthBuffer[i] -= ped->charOverhang;
                            }
                        }
                    }
                }
            }
        }

        {
            //
            // Calculate MaxNeg A C metrics
            //
            dwMaxOverlapChars = 0; 
            if (ped->fTrueType) 
            {
                if (cwi.lMaxNegA < 0)
                {
                    ped->wMaxNegA = -cwi.lMaxNegA;
                }
                else
                {
                    ped->wMaxNegA = 0;
                }

                if (cwi.lMaxNegC < 0)
                {
                    ped->wMaxNegC = -cwi.lMaxNegC;
                }
                else
                {
                    ped->wMaxNegC = 0;
                }

                if (cwi.lMinWidthD != 0) 
                {
                    ped->wMaxNegAcharPos = (ped->wMaxNegA + cwi.lMinWidthD - 1) / cwi.lMinWidthD;
                    ped->wMaxNegCcharPos = (ped->wMaxNegC + cwi.lMinWidthD - 1) / cwi.lMinWidthD;
                    if (ped->wMaxNegA + ped->wMaxNegC > (UINT)cwi.lMinWidthD) 
                    {
                        uExtracharPos = (ped->wMaxNegA + ped->wMaxNegC - 1) / cwi.lMinWidthD;
                        ped->wMaxNegAcharPos += uExtracharPos;
                        ped->wMaxNegCcharPos += uExtracharPos;
                    }
                } 
                else 
                {
                    ped->wMaxNegAcharPos = LOWORD(dwMaxOverlapChars);     // Left
                    ped->wMaxNegCcharPos = HIWORD(dwMaxOverlapChars);     // Right
                }

            } 
            else if (ped->charOverhang != 0) 
            {
                //
                // Some bitmaps fonts (i.e., italic) have under/overhangs;
                // this is pretty much like having negative A and C widths.
                //
                ped->wMaxNegA = ped->wMaxNegC = ped->charOverhang;
                ped->wMaxNegAcharPos = LOWORD(dwMaxOverlapChars);     // Left
                ped->wMaxNegCcharPos = HIWORD(dwMaxOverlapChars);     // Right
            }
        }

        if (!hfont) 
        {
            //
            // We are getting the stats for the system font so update the system
            // font fields in the ed structure since we use these when calculating
            // some spacing.
            //
            ped->cxSysCharWidth = ped->aveCharWidth;
            ped->cySysCharHeight= ped->lineHeight;
        } 
        else if (hOldFont)
        {
            SelectObject(hdc, hOldFont);
        }

        if (ped->fFocus) 
        {
            UINT cxCaret;

            SystemParametersInfo(SPI_GETCARETWIDTH, 0, (LPVOID)&cxCaret, 0);

            //
            // Update the caret.
            //
            HideCaret(ped->hwnd);
            DestroyCaret();

            if (ped->pLpkEditCallout) 
            {
                ped->pLpkEditCallout->EditCreateCaret((PED0)ped, hdc, cxCaret, ped->lineHeight, 0);
            }
            else 
            {
                CreateCaret(ped->hwnd, (HBITMAP)NULL, cxCaret, ped->lineHeight);
            }
            ShowCaret(ped->hwnd);
        }

        ReleaseDC(ped->hwnd, hdc);

        //
        // Update password character.
        //
        if (ped->charPasswordChar)
        {
            Edit_SetPasswordCharHandler(ped, ped->charPasswordChar);
        }

        //
        // If it is a TrueType font and it's a new app, set both the margins at the
        // max negative width values for all types of the edit controls.
        // (NOTE: Can't use ped->f40Compat here because edit-controls inside dialog
        // boxes without DS_LOCALEDIT style are always marked as 4.0 compat.
        // This is the fix for NETBENCH 3.0)
        //

        if (ped->fTrueType && ped->f40Compat)
        {
            if (ped->fDBCS) 
            {
                //
                // For DBCS TrueType Font, we calc margin from ABC width.
                //
                Edit_CalcMarginForDBCSFont(ped, fRedraw);
            } 
            else 
            {
                Edit_SetMargin(ped, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                            MAKELONG(EC_USEFONTINFO, EC_USEFONTINFO), fRedraw);
            }
        }

        //
        // We need to calc maxPixelWidth when font changes.
        // If the word-wrap is ON, then this is done in EditML_Size() called later.
        //
        if((!ped->fSingle) && (!ped->fWrap))
        {
            EditML_BuildchLines(ped, 0, 0, FALSE, NULL, NULL);
        }

        //
        // Recalc the layout.
        //
        Edit_Size(ped, NULL, fRedraw);

        if ( ped->fFocus && ImmIsIME(GetKeyboardLayout(0)) ) 
        {
            Edit_SetCompositionFont( ped );
        }

        fRet = TRUE;
    }

    return fRet;
}


//---------------------------------------------------------------------------//
//
// Edit_IsCharNumeric AorW
//
// Tests whether the character entered is a numeral.
// For multiline and singleline edit controls with the ES_NUMBER style.
// 
BOOL Edit_IsCharNumeric(PED ped, DWORD keyPress)
{
    WORD wCharType;

    if (ped->fAnsi) 
    {
        char ch = (char)keyPress;
        LCID lcid = (LCID)((ULONG_PTR)GetKeyboardLayout(0) & 0xFFFF);
        GetStringTypeA(lcid, CT_CTYPE1, &ch, 1, &wCharType);
    } 
    else 
    {
        WCHAR wch = (WCHAR)keyPress;
        GetStringTypeW(CT_CTYPE1, &wch, 1, &wCharType);
    }
    return (wCharType & C1_DIGIT ? TRUE : FALSE);
}


//---------------------------------------------------------------------------//
VOID Edit_EnableDisableIME(PED ped)
{
    if ( ped->fReadOnly || ped->charPasswordChar ) 
    {
        //
        // IME should be disabled
        //
        HIMC hImc;
        hImc = ImmGetContext( ped->hwnd );

        if ( hImc != NULL_HIMC ) 
        {
            ImmReleaseContext( ped->hwnd, hImc );
            ped->hImcPrev = ImmAssociateContext( ped->hwnd, NULL_HIMC );
        }

    } 
    else 
    {
        //
        // IME should be enabled
        //
        if ( ped->hImcPrev != NULL_HIMC ) 
        {
            ped->hImcPrev = ImmAssociateContext( ped->hwnd, ped->hImcPrev );

            //
            // Font and the caret position might be changed while
            // IME was being disabled. Set those now if the window
            // has the focus.
            //
            if ( ped->fFocus ) 
            {
                POINT pt;

                Edit_SetCompositionFont( ped );

                GetCaretPos( &pt );
                Edit_ImmSetCompositionWindow( ped, pt.x, pt.y  );
            }
        }
    }

    Edit_InitInsert(ped, GetKeyboardLayout(0));
}


//---------------------------------------------------------------------------//
VOID Edit_ImmSetCompositionWindow(PED ped, LONG x, LONG y)
{
    COMPOSITIONFORM cf  = {0};
    COMPOSITIONFORM cft = {0};
    RECT rcScreenWindow;
    HIMC hImc;

    hImc = ImmGetContext(ped->hwnd);
    if ( hImc != NULL_HIMC ) 
    {
        if ( ped->fFocus ) 
        {
            GetWindowRect( ped->hwnd, &rcScreenWindow);

            //
            // assuming RECT.left is the first and and RECT.top is the second field
            //
            MapWindowPoints( ped->hwnd, HWND_DESKTOP, (LPPOINT)&rcScreenWindow, 2);
            if (ped->fInReconversion) 
            {
                DWORD dwPoint = (DWORD)(ped->fAnsi ? SendMessageA : SendMessageW)(ped->hwnd, EM_POSFROMCHAR, ped->ichMinSel, 0);

                x = GET_X_LPARAM(dwPoint);
                y = GET_Y_LPARAM(dwPoint);

                TraceMsg(TF_STANDARD, "UxEdit: Edit_ImmSetCompositionWindow: fInReconversion (%d,%d)", x, y);
            }

            //
            // The window currently has the focus.
            //
            if (ped->fSingle) 
            {
                //
                // Single line edit control.
                //
                cf.dwStyle = CFS_POINT;
                cf.ptCurrentPos.x = x;
                cf.ptCurrentPos.y = y;
                SetRectEmpty(&cf.rcArea);

            } 
            else 
            {
                //
                // Multi line edit control.
                //
                cf.dwStyle = CFS_RECT;
                cf.ptCurrentPos.x = x;
                cf.ptCurrentPos.y = y;
                cf.rcArea = ped->rcFmt;
            }
            ImmGetCompositionWindow( hImc, &cft );
            if ( (!RtlEqualMemory(&cf,&cft,sizeof(COMPOSITIONFORM))) ||
                 (ped->ptScreenBounding.x != rcScreenWindow.left)    ||
                 (ped->ptScreenBounding.y  != rcScreenWindow.top) ) 
            {

                ped->ptScreenBounding.x = rcScreenWindow.left;
                ped->ptScreenBounding.y = rcScreenWindow.top;
                ImmSetCompositionWindow( hImc, &cf );
            }
        }
        ImmReleaseContext( ped->hwnd, hImc );
    }
}


//---------------------------------------------------------------------------//
VOID Edit_SetCompositionFont(PED ped)
{
    HIMC hImc;
    LOGFONTW lf;

    hImc = ImmGetContext( ped->hwnd );
    if (hImc != NULL_HIMC) 
    {
        if (ped->hFont) 
        {
            GetObjectW(ped->hFont, sizeof(LOGFONTW), (LPLOGFONTW)&lf);
        } 
        else 
        {
            GetObjectW(GetStockObject(SYSTEM_FONT), sizeof(LOGFONTW), (LPLOGFONTW)&lf);
        }

        ImmSetCompositionFontW( hImc, &lf );
        ImmReleaseContext( ped->hwnd, hImc );
    }
}


//---------------------------------------------------------------------------//
//
// Edit_InitInsert
//
// this function is called when:
// 1) a edit control window is initialized
// 2) active keyboard layout of current thread is changed
// 3) read only attribute of this edit control is changed
//
VOID Edit_InitInsert( PED ped, HKL hkl )
{
    ped->fKorea = FALSE;
    ped->fInsertCompChr = FALSE;
    ped->fNoMoveCaret = FALSE;
    ped->fResultProcess = FALSE;

    if (g_fIMMEnabled && ImmIsIME(hkl) ) 
    {
        if (PRIMARYLANGID(LOWORD(HandleToUlong(hkl))) == LANG_KOREAN ) 
        {
            ped->fKorea = TRUE;
        }

        //
        // LATER:this flag should be set based on the IME caps
        // retrieved from IME. (Such IME caps should be defined)
        // For now, we can safely assume that only Korean IMEs
        // set CS_INSERTCHAR.
        //
        if ( ped->fKorea ) 
        {
            ped->fInsertCompChr = TRUE;
        }
    }

    //
    // if we had a composition character, the shape of caret
    // is changed. We need to reset the caret shape.
    //
    if ( ped->fReplaceCompChr ) 
    {
        ped->fReplaceCompChr = FALSE;
        Edit_SetCaretHandler( ped );
    }
}


//---------------------------------------------------------------------------//
VOID Edit_SetCaretHandler(PED ped)
{
    HDC     hdc;
    PSTR    pText;
    SIZE    size = {0};

    //
    // In any case destroy caret beforehand otherwise SetCaretPos()
    // will get crazy.. win95d-B#992,B#2370
    //
    if (ped->fFocus) 
    {
        HideCaret(ped->hwnd);
        DestroyCaret();
        if ( ped->fReplaceCompChr ) 
        {

            hdc = Edit_GetDC(ped, TRUE );
            pText = Edit_Lock(ped);

            if ( ped->fAnsi)
            {
                 GetTextExtentPointA(hdc, pText + ped->ichCaret, 2, &size);
            }
            else
            {
                 GetTextExtentPointW(hdc, (LPWSTR)pText + ped->ichCaret, 1, &size);
            }

            Edit_Unlock(ped);
            Edit_ReleaseDC(ped, hdc, TRUE);

            CreateCaret(ped->hwnd, (HBITMAP)NULL, size.cx, ped->lineHeight);
        }
        else 
        {
            CreateCaret(ped->hwnd,
                        (HBITMAP)NULL,
                        (ped->cxSysCharWidth > ped->aveCharWidth ? 1 : 2),
                        ped->lineHeight);
        }

        hdc = Edit_GetDC(ped, TRUE );
        if ( ped->fSingle )
        {
            EditSL_SetCaretPosition( ped, hdc );
        }
        else
        {
            EditML_SetCaretPosition( ped, hdc );
        }

        Edit_ReleaseDC(ped, hdc, TRUE);
        ShowCaret(ped->hwnd);
    }
}


//---------------------------------------------------------------------------//
#define GET_COMPOSITION_STRING  (ped->fAnsi ? ImmGetCompositionStringA : ImmGetCompositionStringW)

BOOL Edit_ResultStrHandler(PED ped)
{
    HIMC himc;
    LPSTR lpStr;
    LONG dwLen;

    ped->fInsertCompChr = FALSE;    // clear the state
    ped->fNoMoveCaret = FALSE;

    himc = ImmGetContext(ped->hwnd);
    if ( himc == NULL_HIMC ) 
    {
        return FALSE;
    }

    dwLen = GET_COMPOSITION_STRING(himc, GCS_RESULTSTR, NULL, 0);

    if (dwLen == 0) 
    {
        ImmReleaseContext(ped->hwnd, himc);
        return FALSE;
    }

    dwLen *= ped->cbChar;
    dwLen += ped->cbChar;

    lpStr = (LPSTR)GlobalAlloc(GPTR, dwLen);
    if (lpStr == NULL) 
    {
        ImmReleaseContext(ped->hwnd, himc);
        return FALSE;
    }

    GET_COMPOSITION_STRING(himc, GCS_RESULTSTR, lpStr, dwLen);

    if (ped->fSingle) 
    {
        EditSL_ReplaceSel(ped, lpStr);
    } 
    else 
    {
        EditML_ReplaceSel(ped, lpStr);
    }

    GlobalFree((HGLOBAL)lpStr);

    ImmReleaseContext(ped->hwnd, himc);

    ped->fReplaceCompChr = FALSE;
    ped->fNoMoveCaret = FALSE;
    ped->fResultProcess = FALSE;

    Edit_SetCaretHandler(ped);

    return TRUE;
}


//---------------------------------------------------------------------------//
LRESULT Edit_ImeComposition(PED ped, WPARAM wParam, LPARAM lParam)
{
    INT ich;
    LRESULT lReturn = 1;
    HDC hdc;
    BOOL fSLTextUpdated = FALSE;
    ICH iResult;
    HIMC hImc;
    BYTE TextBuf[4];

    if (!ped->fInsertCompChr) 
    {
        if (lParam & GCS_RESULTSTR) 
        {
            Edit_InOutReconversionMode(ped, FALSE);

            if (!ped->fKorea && ped->wImeStatus & EIMES_GETCOMPSTRATONCE) 
            {
ResultAtOnce:
                Edit_ResultStrHandler(ped);
                lParam &= ~GCS_RESULTSTR;
            }
        }
        return DefWindowProc(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
    }

    //
    // In case of Ansi edit control, the length of minimum composition string
    // is 2. Check here maximum byte of edit control.
    //
    if( ped->fAnsi && ped->cchTextMax == 1 ) 
    {
        HIMC hImc;

        hImc = ImmGetContext( ped->hwnd );
        ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0L);
        ImmReleaseContext( ped->hwnd, hImc );
        MessageBeep(MB_ICONEXCLAMATION);
        return lReturn;
    }

    //
    // Don't move this after CS_NOMOVECARET check.
    // In case if skip the message, fNoMoveCaret should not be set.
    //
    if ((lParam & CS_INSERTCHAR) && ped->fResultProcess) 
    {
        //
        // Now we're in result processing. GCS_RESULTSTR ends up
        // to WM_IME_CHAR and WM_CHAR. Since WM_CHAR is posted,
        // the message(s) will come later than this CS_INSERTCHAR
        // message. This composition character should be handled
        // after the WM_CHAR message(s).
        //
        if(ped->fAnsi)
        {
            PostMessageA(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
        }
        else
        {
            PostMessageW(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
        }

        ped->fResultProcess = FALSE;

        return lReturn;
    }

    if (lParam & GCS_RESULTSTR) 
    {
        if (!ped->fKorea && ped->wImeStatus & EIMES_GETCOMPSTRATONCE) 
        {
            goto ResultAtOnce;
        }

        ped->fResultProcess = TRUE;
        if ( ped->fReplaceCompChr ) 
        {
            //
            // we have a DBCS character to be replaced.
            // let's delete it before inserting the new one.
            //
            ich = (ped->fAnsi) ? 2 : 1;
            ped->fReplaceCompChr = FALSE;
            ped->ichMaxSel = min(ped->ichCaret + ich, ped->cch);
            ped->ichMinSel = ped->ichCaret;

            if ( Edit_DeleteText( ped ) > 0 ) 
            {
                if ( ped->fSingle ) 
                {
                    //
                    // Update the display
                    //
                    Edit_NotifyParent(ped, EN_UPDATE);
                    hdc = Edit_GetDC(ped,FALSE);
                    EditSL_DrawText(ped, hdc, 0);
                    Edit_ReleaseDC(ped,hdc,FALSE);
                    //
                    // Tell parent our text contents changed.
                    //
                    Edit_NotifyParent(ped, EN_CHANGE);
                }
            }
            Edit_SetCaretHandler( ped );
        }

    } 
    else if (lParam & CS_INSERTCHAR) 
    {

        //
        // If we are in the middle of a mousedown command, don't do anything.
        //
        if (ped->fMouseDown) 
        {
            return lReturn;
        }

        //
        // We can safely assume that interimm character is always DBCS.
        //
        ich = ( ped->fAnsi ) ? 2 : 1;

        if ( ped->fReplaceCompChr ) 
        {
            //
            // we have a character to be replaced.
            // let's delete it before inserting the new one.
            // when we have a composition characters, the
            // caret is placed before the composition character.
            //
            ped->ichMaxSel = min(ped->ichCaret+ich, ped->cch);
            ped->ichMinSel = ped->ichCaret;
        }

        //
        // let's delete current selected text or composition character
        //
        if ( ped->fSingle ) 
        {
            if ( Edit_DeleteText( ped ) > 0 ) 
            {
                fSLTextUpdated = TRUE;
            }
        } 
        else 
        {
            EditML_DeleteText( ped );
        }

        //
        // When the composition charcter is canceled, IME may give us NULL wParam,
        // with CS_INSERTCHAR flag on. We shouldn't insert a NULL character.
        //
        if ( wParam != 0 ) 
        {

            if ( ped->fAnsi ) 
            {
                TextBuf[0] = HIBYTE(LOWORD(wParam)); // leading byte
                TextBuf[1] = LOBYTE(LOWORD(wParam)); // trailing byte
                TextBuf[2] = '\0';
            } 
            else 
            {
                TextBuf[0] = LOBYTE(LOWORD(wParam));
                TextBuf[1] = HIBYTE(LOWORD(wParam));
                TextBuf[2] = '\0';
                TextBuf[3] = '\0';
            }

            if ( ped->fSingle ) 
            {
                iResult = EditSL_InsertText( ped, (LPSTR)TextBuf, ich );
                if (iResult == 0) 
                {
                    //
                    // Couldn't insert the text, for e.g. the text exceeded the limit.
                    //
                    MessageBeep(0);
                } 
                else if (iResult > 0) 
                {
                    //
                    // Remember we need to update the text.
                    //
                    fSLTextUpdated = TRUE;
                }

            } 
            else 
            {
                iResult = EditML_InsertText( ped, (LPSTR)TextBuf, ich, TRUE);
            }

            if ( iResult > 0 ) 
            {
                //
                // ped->fReplaceCompChr will be reset:
                //
                // 1) when the character is finalized.
                //    we will receive GCS_RESULTSTR
                //
                // 2) when the character is canceled.
                //
                //    we will receive WM_IME_COMPOSITION|CS_INSERTCHAR
                //    with wParam == 0 (in case of user types backspace
                //    at the first element of composition character).
                //
                //      or
                //
                //    we will receive WM_IME_ENDCOMPOSITION message
                //
                ped->fReplaceCompChr = TRUE;

                //
                // Caret should be placed BEFORE the composition
                // character.
                //
                ped->ichCaret = max( 0, (INT)ped->ichCaret - ich);
                Edit_SetCaretHandler( ped );
            } 
            else 
            {
                //
                // We failed to insert a character. We might run out
                // of memory, or reached to the text size limit. let's
                // cancel the composition character.
                //
                hImc = ImmGetContext(ped->hwnd);
                ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
                ImmReleaseContext(ped->hwnd, hImc);

                ped->fReplaceCompChr = FALSE;
                Edit_SetCaretHandler( ped );
            }
        } 
        else 
        {
            //
            // the composition character is canceled.
            //
            ped->fReplaceCompChr = FALSE;
            Edit_SetCaretHandler( ped );
        }

        //
        // We won't notify parent the text change
        // because the composition character has
        // not been finalized.
        //
        if ( fSLTextUpdated ) 
        {
            //
            // Update the display
            //
            Edit_NotifyParent(ped, EN_UPDATE);

            hdc = Edit_GetDC(ped,FALSE);

            if ( ped->fReplaceCompChr ) 
            {
                //
                // move back the caret to the original position
                // temporarily so that our new block cursor can
                // be located within the visible area of window.
                //
                ped->ichCaret = min( ped->cch, ped->ichCaret + ich);
                EditSL_ScrollText(ped, hdc);
                ped->ichCaret = max( 0, (INT)ped->ichCaret - ich);
            } 
            else 
            {
                EditSL_ScrollText(ped, hdc);
            }
            EditSL_DrawText(ped, hdc, 0);

            Edit_ReleaseDC(ped,hdc,FALSE);

            //
            // Tell parent our text contents changed.
            //
            Edit_NotifyParent(ped, EN_CHANGE);
        }
        return lReturn;
    }

    return DefWindowProc(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
}


//---------------------------------------------------------------------------//
//
// HanjaKeyHandler
//
// VK_HANJA handler - Korean only
//
BOOL HanjaKeyHandler(PED ped)
{
    BOOL changeSelection = FALSE;

    if (ped->fKorea && !ped->fReadOnly) 
    {
        ICH oldCaret = ped->ichCaret;

        if (ped->fReplaceCompChr)
        {
            return FALSE;
        }

        if (ped->ichMinSel < ped->ichMaxSel)
        {
            ped->ichCaret = ped->ichMinSel;
        }

        if (!ped->cch || ped->cch == ped->ichCaret) 
        {
            ped->ichCaret = oldCaret;
            MessageBeep(MB_ICONEXCLAMATION);
            return FALSE;
        }

        if (ped->fAnsi) 
        {
            if (ImmEscapeA(GetKeyboardLayout(0), ImmGetContext(ped->hwnd),
                IME_ESC_HANJA_MODE, (Edit_Lock(ped) + ped->ichCaret * ped->cbChar))) 
            {
                changeSelection = TRUE;
            }
            else
            {
                ped->ichCaret = oldCaret;
            }

            Edit_Unlock(ped);
        }
        else 
        {
            if (ImmEscapeW(GetKeyboardLayout(0), ImmGetContext(ped->hwnd),
                IME_ESC_HANJA_MODE, (Edit_Lock(ped) + ped->ichCaret * ped->cbChar))) 
            {
                changeSelection = TRUE;
            }
            else
            {
                ped->ichCaret = oldCaret;
            }

            Edit_Unlock(ped);
        }
    }

    return changeSelection;
}



//---------------------------------------------------------------------------//
// Edit_RequestHandler()
//
// Handles WM_IME_REQUEST message originated by IME
//

#define MAX_ECDOCFEED 20


ICH Edit_ImeGetDocFeedMin(PED ped, LPSTR lpstr)
{
    ICH ich;


    if (ped->ichMinSel > MAX_ECDOCFEED) 
    {
        ich = ped->ichMinSel - MAX_ECDOCFEED;
        ich = Edit_AdjustIch(ped, lpstr, ich);
    } 
    else 
    {
        ich = 0;
    }

    return ich;
}

ICH Edit_ImeGetDocFeedMax(PED ped, LPSTR lpstr)
{
    ICH ich;

    if ((ped->cch - ped->ichMaxSel) > MAX_ECDOCFEED) 
    {
        ich = ped->ichMaxSel + MAX_ECDOCFEED;
        ich = Edit_AdjustIch(ped, lpstr, ich);
    } 
    else 
    {
        ich = ped->cch;
    }

    return ich;
}

LRESULT Edit_RequestHandler(PED ped, WPARAM dwSubMsg, LPARAM lParam)
{
    LRESULT lreturn = 0L;

    switch (dwSubMsg) 
    {
    case IMR_CONFIRMRECONVERTSTRING:

        //
        // CHECK VERSION of the structure
        //
        if (lParam && ((LPRECONVERTSTRING)lParam)->dwVersion != 0) 
        {
            TraceMsg(TF_STANDARD, "Edit_RequestHandler: RECONVERTSTRING dwVersion is not expected.",
                ((LPRECONVERTSTRING)lParam)->dwVersion);
            return 0L;
        }

        if (lParam && ped && ped->fFocus && ped->hText && ImmIsIME(GetKeyboardLayout(0))) 
        {
            LPVOID lpSrc;
            lpSrc = Edit_Lock(ped);
            if (lpSrc == NULL) 
            {
                TraceMsg(TF_STANDARD, "Edit_RequestHandler: LOCALLOCK(ped) failed.");
            } 
            else 
            {
                LPRECONVERTSTRING lpRCS = (LPRECONVERTSTRING)lParam;
                ICH ichStart;
                ICH ichEnd;
                UINT cchLen;

                ichStart = Edit_ImeGetDocFeedMin(ped, lpSrc);
                ichEnd = Edit_ImeGetDocFeedMax(ped, lpSrc);
                UserAssert(ichEnd >= ichStart);

                cchLen = ichEnd - ichStart;    // holds character count.

                Edit_Unlock(ped);

                if (lpRCS->dwStrLen != cchLen) 
                {
                    TraceMsg(TF_STANDARD, "Edit_RequestHandler: the given string length is not expected.");
                } 
                else 
                {
                    ICH ichSelStart;
                    ICH ichSelEnd;

                    ichSelStart = ichStart + (lpRCS->dwCompStrOffset  / ped->cbChar);
                    ichSelEnd = ichSelStart + lpRCS->dwCompStrLen;


                    (ped->fAnsi ? SendMessageA : SendMessageW)(ped->hwnd, EM_SETSEL, ichSelStart, ichSelEnd);

                    lreturn = 1L;
                }
            }
        }
        break;

    case IMR_RECONVERTSTRING:
        //
        // CHECK VERSION of the structure
        //
        if (lParam && ((LPRECONVERTSTRING)lParam)->dwVersion != 0) 
        {
            TraceMsg(TF_STANDARD, "UxEdit: Edit_RequestHandler: RECONVERTSTRING dwVersion is not expected.");

            return 0L;
        }

        if (ped && ped->fFocus && ped->hText && ImmIsIME(GetKeyboardLayout(0))) 
        {
            ICH ichStart;
            ICH ichEnd;
            UINT cchLen;
            UINT cchSelLen;
            LPVOID lpSrc;
            lpSrc = Edit_Lock(ped);
            if (lpSrc == NULL) 
            {
                TraceMsg(TF_STANDARD, "Edit_RequestHandler: LOCALLOCK(ped) failed.");
                return 0L;
            }

            ichStart = Edit_ImeGetDocFeedMin(ped, lpSrc);
            ichEnd = Edit_ImeGetDocFeedMax(ped, lpSrc);
            UserAssert(ichEnd >= ichStart);

            cchLen = ichEnd - ichStart;    // holds character count.
            cchSelLen = ped->ichMaxSel - ped->ichMinSel;    // holds character count.
            if (cchLen == 0) 
            {
                // if we have no selection,
                // just return 0.
                break;
            }

            UserAssert(ped->cbChar == sizeof(BYTE) || ped->cbChar == sizeof(WCHAR));

            // This Edit Control has selection.
            if (lParam == 0) 
            {
                //
                // IME just want to get required size for buffer.
                // cchLen + 1 is needed to reserve room for trailing L'\0'.
                //       ~~~~
                lreturn = sizeof(RECONVERTSTRING) + (cchLen + 1) * ped->cbChar;
            } 
            else 
            {
                LPRECONVERTSTRING lpRCS = (LPRECONVERTSTRING)lParam;
                LPVOID lpDest = (LPBYTE)lpRCS + sizeof(RECONVERTSTRING);

                // check buffer size
                // if the given buffer is smaller than actual needed size,
                // shrink our size to fit the buffer
                if ((INT)lpRCS->dwSize <= sizeof(RECONVERTSTRING) + cchLen * ped->cbChar) 
                {
                    TraceMsg(TF_STANDARD, "UxEdit: Edit_Request: ERR09");
                    cchLen = (lpRCS->dwSize - sizeof(RECONVERTSTRING)) / ped->cbChar - ped->cbChar;
                }

                lpRCS->dwStrOffset = sizeof(RECONVERTSTRING); // buffer begins just after RECONVERTSTRING
                lpRCS->dwCompStrOffset =
                lpRCS->dwTargetStrOffset = (ped->ichMinSel - ichStart) * ped->cbChar; // BYTE count offset
                lpRCS->dwStrLen = cchLen; // TCHAR count
                lpRCS->dwCompStrLen = 
                lpRCS->dwTargetStrLen = cchSelLen; // TCHAR count

                RtlCopyMemory(lpDest,
                              (LPBYTE)lpSrc + ichStart * ped->cbChar,
                              cchLen * ped->cbChar);
                // Null-Terminate the string
                if (ped->fAnsi) 
                {
                    LPBYTE psz = (LPBYTE)lpDest;
                    psz[cchLen] = '\0';
                } 
                else 
                {
                    LPWSTR pwsz = (LPWSTR)lpDest;
                    pwsz[cchLen] = L'\0';
                }
                Edit_Unlock(ped);
                // final buffer size
                lreturn = sizeof(RECONVERTSTRING) + (cchLen + 1) * ped->cbChar;

                Edit_InOutReconversionMode(ped, TRUE);
                Edit_ImmSetCompositionWindow(ped, 0, 0);
            }

        }
        break;
    }

    return lreturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\edit.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "edit.h"

//---------------------------------------------------------------------------//
//
// Forwards
//
ICH     Edit_FindTabA(LPSTR, ICH);
ICH     Edit_FindTabW(LPWSTR, ICH);
HBRUSH  Edit_GetControlBrush(PED, HDC, LONG);

NTSYSAPI
VOID
NTAPI
RtlRunEncodeUnicodeString(
    PUCHAR          Seed        OPTIONAL,
    PUNICODE_STRING String
    );


NTSYSAPI
VOID
NTAPI
RtlRunDecodeUnicodeString(
    UCHAR           Seed,
    PUNICODE_STRING String
    );

//
// private export from GDI
//
UINT WINAPI QueryFontAssocStatus(void);

#define umin(a, b)      \
            ((unsigned)(a) < (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))

#define umax(a, b)      \
            ((unsigned)(a) > (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))


#define UNICODE_CARRIAGERETURN ((WCHAR)0x0d)
#define UNICODE_LINEFEED ((WCHAR)0x0a)
#define UNICODE_TAB ((WCHAR)0x09)

//
// IME Menu IDs
//
#define ID_IMEOPENCLOSE      10001
#define ID_SOFTKBDOPENCLOSE  10002
#define ID_RECONVERTSTRING   10003


#define ID_EDITTIMER        10007
#define EDIT_TIPTIMEOUT     10000

#pragma code_seg(CODESEG_INIT)

//---------------------------------------------------------------------------//
//
//  InitEditClass() - Registers the control's window class 
//
BOOL InitEditClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = Edit_WndProc;
    wc.lpszClassName = WC_EDIT;
    wc.style         = CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PED);
    wc.hInstance     = hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_IBEAM);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}

#pragma code_seg()


//---------------------------------------------------------------------------//
//
PSTR Edit_Lock(PED ped)
{
    PSTR ptext = LocalLock(ped->hText);
    ped->iLockLevel++;

    //
    // If this is the first lock of the text and the text is encoded
    // decode the text.
    //

    //TraceMsg(TF_STANDARD, "EDIT: lock  : %d '%10s'", ped->iLockLevel, ptext);
    if (ped->iLockLevel == 1 && ped->fEncoded) 
    {
        //
        // rtlrundecode can't handle zero length strings
        //
        if (ped->cch != 0) 
        {
            STRING string;
            string.Length = string.MaximumLength = (USHORT)(ped->cch * ped->cbChar);
            string.Buffer = ptext;

            RtlRunDecodeUnicodeString(ped->seed, (PUNICODE_STRING)&string);
            //TraceMsg(TF_STANDARD, "EDIT: Decoding: '%10s'", ptext);
        }
        ped->fEncoded = FALSE;
    }

    return ptext;
}


//---------------------------------------------------------------------------//
//
VOID Edit_Unlock(PED ped)
{
    //
    // if we are removing the last lock on the text and the password
    // character is set then encode the text
    //

    //TraceMsg(TF_STANDARD, "EDIT: unlock: %d '%10s'", ped->iLockLevel, ped->ptext);
    if (ped->charPasswordChar && ped->iLockLevel == 1 && ped->cch != 0) 
    {
        UNICODE_STRING string;
        string.Length = string.MaximumLength = (USHORT)(ped->cch * ped->cbChar);
        string.Buffer = LocalLock(ped->hText);

        RtlRunEncodeUnicodeString(&(ped->seed), &string);
        //TraceMsg(TF_STANDARD, "EDIT: Encoding: '%10s'", ped->ptext);
        ped->fEncoded = TRUE;
        LocalUnlock(ped->hText);
    }

    LocalUnlock(ped->hText);
    ped->iLockLevel--;
}


//---------------------------------------------------------------------------//
//
// GetActualNegA()
//
// For a given strip of text, this function computes the negative A width
// for the whole strip and returns the value as a postive number.
// It also fills the NegAInfo structure with details about the postion
// of this strip that results in this Negative A.
//
UINT GetActualNegA(HDC hdc, PED ped, INT x, LPSTR lpstring, ICH ichString, INT nCount, LPSTRIPINFO NegAInfo)
{
    INT  iCharCount, i;
    INT  iLeftmostPoint = x;
    PABC pABCwidthBuff;
    UINT wCharIndex;
    INT  xStartPoint = x;
    ABC  abc;

    //
    // To begin with, let us assume that there is no negative A width for
    // this strip and initialize accodingly.
    //

    NegAInfo->XStartPos = x;
    NegAInfo->lpString = lpstring;
    NegAInfo->nCount  = 0;
    NegAInfo->ichString = ichString;

    //
    // If the current font is not a TrueType font, then there can not be any
    // negative A widths.
    //
    if (!ped->fTrueType) 
    {
        if(!ped->charOverhang) 
        {
            return 0;
        } 
        else 
        {
            NegAInfo->nCount = min(nCount, (INT)ped->wMaxNegAcharPos);
            return ped->charOverhang;
        }
    }

    //
    // How many characters are to be considered for computing Negative A ?
    //
    iCharCount = min(nCount, (INT)ped->wMaxNegAcharPos);

    //
    // Do we have the info on individual character's widths?
    //
    if(!ped->charWidthBuffer) 
    {
        //
        // No! So, let us tell them to consider all the characters.
        //
        NegAInfo->nCount = iCharCount;
        return (iCharCount * ped->aveCharWidth);
    }

    pABCwidthBuff = (PABC)ped->charWidthBuffer;

    if (ped->fAnsi) 
    {
        for (i = 0; i < iCharCount; i++) 
        {
            wCharIndex = (UINT)(*((PUCHAR)lpstring));
            if (*lpstring == VK_TAB) 
            {
                //
                // To play it safe, we assume that this tab results in a tab length of
                // 1 pixel because this is the minimum possible tab length.
                //
                x++;
            } 
            else 
            {
                if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH)
                {
                    //
                    // Add the 'A' width.
                    //
                    x += pABCwidthBuff[wCharIndex].abcA;
                }
                else 
                {
                    GetCharABCWidthsA(hdc, wCharIndex, wCharIndex, &abc);
                    x += abc.abcA;
                }

                if (x < iLeftmostPoint)
                {
                    //
                    // Reset the leftmost point.
                    //
                    iLeftmostPoint = x;
                }

                if (x < xStartPoint)
                {
                    //
                    // 'i' is index; To get the count add 1.
                    //
                    NegAInfo->nCount = i+1;
                }

                if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH) 
                {
                    x += pABCwidthBuff[wCharIndex].abcB + pABCwidthBuff[wCharIndex].abcC;
                } 
                else 
                {
                    x += abc.abcB + abc.abcC;
                }
            }

            lpstring++;
        }
    } 
    else 
    {
        LPWSTR lpwstring = (LPWSTR)lpstring;

        for (i = 0; i < iCharCount; i++) 
        {
            wCharIndex = *lpwstring ;
            if (*lpwstring == VK_TAB) 
            {
                //
                // To play it safe, we assume that this tab results in a tab length of
                // 1 pixel because this is the minimum possible tab length.
                //
                x++;
            } 
            else 
            {
                if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH)
                {
                    //
                    // Add the 'A' width.
                    //
                    x += pABCwidthBuff[wCharIndex].abcA;
                }
                else 
                {
                    GetCharABCWidthsW(hdc, wCharIndex, wCharIndex, &abc);
                    x += abc.abcA ;
                }

                if (x < iLeftmostPoint)
                {
                    //
                    // Reset the leftmost point.
                    //
                    iLeftmostPoint = x;
                }

                if (x < xStartPoint)
                {
                    //
                    // 'i' is index; To get the count add 1.
                    //
                    NegAInfo->nCount = i+1;
                }

                if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH)
                {
                    x += pABCwidthBuff[wCharIndex].abcB +
                         pABCwidthBuff[wCharIndex].abcC;
                }
                else
                {
                    x += abc.abcB + abc.abcC;
                }
            }

            lpwstring++;
        }
    }

    //
    // Let us return the negative A for the whole strip as a positive value.
    //
    return (UINT)(xStartPoint - iLeftmostPoint);
}


//---------------------------------------------------------------------------//
//
// Edit_IsAncestorActive()
//
// Returns whether or not we're the child of an "active" window.  Looks for
// the first parent window that has a caption.
//
// This is a function because we might use it elsewhere when getting left
//  clicked on, etc.
//
BOOL Edit_IsAncestorActive(HWND hwnd)
{
    BOOL fResult = TRUE;
    //
    // We want to return TRUE always for top level windows.  That's because
    // of how WM_MOUSEACTIVATE works.  If we see the click at all, the
    // window is active.  However, if we reach a child ancestor that has
    // a caption, return the frame-on style bit.
    //
    // Note that calling FlashWindow() will have an effect.  If the user
    // clicks on an edit field in a child window that is flashed off, nothing
    // will happen unless the window stops flashing and ncactivates first.
    //

    for(; hwnd != NULL; hwnd = GetParent(hwnd))
    {
        PWW pww = (PWW)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);
        //
        // Bail out if some parent window isn't 4.0 compatible or we've
        // reached the top.  Fixes compatibility problems with 3.x apps,
        // especially MFC samples.
        //
        if (!TESTFLAG(pww->dwState2, WS_S2_WIN40COMPAT) || !TESTFLAG(pww->dwStyle, WS_CHILD))
        {
            break;
        }
        else if (TESTFLAG(pww->dwState, WS_ST_CPRESENT))
        {
            fResult = (TESTFLAG(pww->dwState, WS_ST_FRAMEON) != 0);
            break;
        }
    }

    return fResult;
}

//---------------------------------------------------------------------------//
//
// Edit_SetIMEMenu()
//
// support IME specific context menu
//
BOOL Edit_SetIMEMenu(HMENU hMenu, HWND hwnd, EditMenuItemState state)
{
    MENUITEMINFO mii;
    HIMC  hIMC;
    HKL   hKL;
    HMENU hmenuSub;
    WCHAR szRes[32];
    INT   nPrevLastItem;
    INT   nItemsAdded = 0;

    UserAssert(g_fIMMEnabled && state.fIME);

    hKL = GetKeyboardLayout(0);
    if (!ImmIsIME(hKL))
    {
        return TRUE;
    }

    hIMC = ImmGetContext(hwnd);
    if (hIMC == NULL) 
    {
        //
        // early out
        //
        return FALSE;
    }

    hmenuSub = GetSubMenu(hMenu, 0);

    if (hmenuSub == NULL) 
    {
        return FALSE;
    }

    nPrevLastItem = GetMenuItemCount(hmenuSub);

    if (hIMC) 
    {
        if (LOWORD(HandleToUlong(hKL)) != 0x412) 
        {
            //
            // If Korean, do not show open/close menus
            //
            if (ImmGetOpenStatus(hIMC))
            {
                LoadString(HINST_THISDLL, IDS_IMECLOSE, szRes, ARRAYSIZE(szRes));
            }
            else
            {
                LoadString(HINST_THISDLL, IDS_IMEOPEN, szRes, ARRAYSIZE(szRes));
            }

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.dwTypeData = szRes;
            mii.cch = 0xffff;
            mii.wID = ID_IMEOPENCLOSE;
            InsertMenuItem(hmenuSub, 0xffff, TRUE, &mii);
            ++nItemsAdded;
        }

        if (ImmGetProperty(hKL, IGP_CONVERSION) & IME_CMODE_SOFTKBD) 
        {
            DWORD fdwConversion;

            if (ImmGetConversionStatus(hIMC, &fdwConversion, NULL) && 
                (fdwConversion & IME_CMODE_SOFTKBD))
            {
               LoadString(HINST_THISDLL, IDS_SOFTKBDCLOSE, szRes, ARRAYSIZE(szRes));
            }
            else
            {
               LoadString(HINST_THISDLL, IDS_SOFTKBDOPEN, szRes, ARRAYSIZE(szRes));
            }

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.dwTypeData = szRes;
            mii.cch = 0xffff;
            mii.wID = ID_SOFTKBDOPENCLOSE;
            InsertMenuItem(hmenuSub, 0xffff, TRUE, &mii);
            ++nItemsAdded;
        }

        if (LOWORD(HandleToUlong(hKL)) != 0x412) 
        {
            //
            // If Korean, do not show reconversion menus
            //
            DWORD dwSCS = ImmGetProperty(hKL, IGP_SETCOMPSTR);

            LoadString(HINST_THISDLL, IDS_RECONVERTSTRING, szRes, ARRAYSIZE(szRes));

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID | MIIM_STATE;
            mii.dwTypeData = szRes;
            mii.fState = 0;
            mii.cch = 0xffff;
            mii.wID = ID_RECONVERTSTRING;

            if (state.fDisableCut ||
                    !(dwSCS & SCS_CAP_SETRECONVERTSTRING) ||
                    !(dwSCS & SCS_CAP_MAKEREAD)) 
            {
                mii.fState |= MFS_GRAYED;
            }

            InsertMenuItem(hmenuSub, 0xffff, TRUE, &mii);
            ++nItemsAdded;
        }
    }

    //
    // Add or remove the menu separator
    //
    if (state.fNeedSeparatorBeforeImeMenu && nItemsAdded != 0) 
    {
        //
        // If the menu for Middle East has left a separator,
        // fNeedSeparatorBeforeImeMenu is FALSE.
        // I.e. we don't need to add more.
        //
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_FTYPE;
        mii.fType = MFT_SEPARATOR;
        InsertMenuItem(hmenuSub, nPrevLastItem, TRUE, &mii);
    }
    else if (!state.fNeedSeparatorBeforeImeMenu && nItemsAdded == 0) 
    {
        //
        // Extra separator is left by ME menus. Remove it.
        //
        DeleteMenu(hmenuSub, nPrevLastItem - 1, MF_BYPOSITION);
    }

    ImmReleaseContext(hwnd, hIMC);

    return TRUE;
}


//---------------------------------------------------------------------------//
//
VOID Edit_InOutReconversionMode(PED ped, BOOL fIn)
{
    UserAssert(fIn == TRUE || fIn == FALSE);
    if (fIn != ped->fInReconversion) 
    {
        ped->fInReconversion = fIn;
        if (ped->fFocus) 
        {
            (fIn ? HideCaret: ShowCaret)(ped->hwnd);
        }
    }

}

//---------------------------------------------------------------------------//
//
BOOL Edit_EnumInputContextCB(HIMC hImc, LPARAM lParam)
{
    DWORD dwConversion = 0, dwSentence = 0, dwNewConversion = 0;

    ImmGetConversionStatus(hImc, &dwConversion, &dwSentence);

    if (lParam) 
    {
        dwNewConversion = dwConversion | IME_CMODE_SOFTKBD;
    } 
    else 
    {
        dwNewConversion = dwConversion & ~IME_CMODE_SOFTKBD;
    }

    if (dwNewConversion != dwConversion) 
    {
        ImmSetConversionStatus(hImc, dwNewConversion, dwSentence);
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// Edit_DoIMEMenuCommand()
//
// support IME specific context menu
//
BOOL Edit_DoIMEMenuCommand(PED ped, int cmd, HWND hwnd)
{
    HIMC hIMC;

    // early out
    switch (cmd) 
    {
    case ID_IMEOPENCLOSE:
    case ID_SOFTKBDOPENCLOSE:
    case ID_RECONVERTSTRING:
        break;
    default:
        return FALSE;
    }

    //
    // everybody needs hIMC, so get it here
    //
    hIMC = ImmGetContext(hwnd);
    if (hIMC == NULL) 
    {
        //
        // indicate to caller, that no further command processing needed
        //
        return TRUE;
    }

    switch (cmd) 
    {
    case ID_IMEOPENCLOSE:
    {
        // switch IME Open/Close status
        BOOL fOpen = ImmGetOpenStatus(hIMC);

        ImmSetOpenStatus(hIMC, !fOpen);
    }

    break;

    case ID_SOFTKBDOPENCLOSE:
    {
        DWORD fdwConversion;

        if (ImmGetConversionStatus(hIMC, &fdwConversion, NULL)) 
        {
            //
            // Toggle soft keyboard Open/Close status
            //
            ImmEnumInputContext(0, Edit_EnumInputContextCB,
                    (fdwConversion & IME_CMODE_SOFTKBD) != IME_CMODE_SOFTKBD);
        }
    }

    break;

    case ID_RECONVERTSTRING:
    {
        DWORD dwStrLen; // holds TCHAR count of recionversion string
        DWORD cbLen;    // holds BYTE SIZE of reconversion string
        DWORD dwSize;
        LPRECONVERTSTRING lpRCS;

        //
        // pass current selection to IME for reconversion
        //
        dwStrLen = ped->ichMaxSel - ped->ichMinSel;
        cbLen = dwStrLen * ped->cbChar;
        dwSize = cbLen + sizeof(RECONVERTSTRING) + 8;

        lpRCS = (LPRECONVERTSTRING)UserLocalAlloc(0, dwSize);

        if (lpRCS) 
        {
            LPBYTE pText;
            ICH    ichSelMinOrg;

            ichSelMinOrg = ped->ichMinSel;

            pText = Edit_Lock(ped);
            if (pText != NULL) 
            {
                LPBYTE lpDest;
                BOOL (WINAPI* fpSetCompositionStringAW)(HIMC, DWORD, LPVOID, DWORD, LPVOID, DWORD);

                lpRCS->dwSize = dwSize;
                lpRCS->dwVersion = 0;

                lpRCS->dwStrLen =
                lpRCS->dwCompStrLen =
                lpRCS->dwTargetStrLen = dwStrLen;

                lpRCS->dwStrOffset = sizeof(RECONVERTSTRING);
                lpRCS->dwCompStrOffset =
                lpRCS->dwTargetStrOffset = 0;

                lpDest = (LPBYTE)lpRCS + sizeof(RECONVERTSTRING);

                RtlCopyMemory(lpDest, pText + ped->ichMinSel * ped->cbChar, cbLen);
                if (ped->fAnsi) 
                {
                    LPBYTE psz = (LPBYTE)lpDest;
                    psz[cbLen] = '\0';
                    fpSetCompositionStringAW = ImmSetCompositionStringA;
                } 
                else 
                {
                    LPWSTR pwsz = (LPWSTR)lpDest;
                    pwsz[dwStrLen] = L'\0';
                    fpSetCompositionStringAW = ImmSetCompositionStringW;
                }

                Edit_Unlock(ped);

                UserAssert(fpSetCompositionStringAW != NULL);

                Edit_InOutReconversionMode(ped, TRUE);
                Edit_ImmSetCompositionWindow(ped, 0, 0); // x and y will be overriden anyway

                // Query the IME for a valid Reconvert string range first.
                fpSetCompositionStringAW(hIMC, SCS_QUERYRECONVERTSTRING, lpRCS, dwSize, NULL, 0);

                // If current IME updates the original reconvert structure,
                // it is necessary to update the text selection based on the 
                // new reconvert text range.
                if ((lpRCS->dwCompStrLen != dwStrLen) || (ichSelMinOrg != ped->ichMinSel)) 
                {
                    ICH ichSelStart;
                    ICH ichSelEnd;

                    ichSelStart = ichSelMinOrg + (lpRCS->dwCompStrOffset  / ped->cbChar);
                    ichSelEnd = ichSelStart + lpRCS->dwCompStrLen;

                    (ped->fAnsi ? SendMessageA : SendMessageW)(ped->hwnd, EM_SETSEL, ichSelStart, ichSelEnd);
                }

                fpSetCompositionStringAW(hIMC, SCS_SETRECONVERTSTRING, lpRCS, dwSize, NULL, 0);
            }

            UserLocalFree(lpRCS);
        }

        break;
    }

    default:
        //
        // should never reach here.
        //
        TraceMsg(TF_STANDARD, "EDIT: Edit_DoIMEMenuCommand: unknown command id %d; should never reach here.", cmd);
        return FALSE;
    }

    UserAssert(hIMC != NULL);
    ImmReleaseContext(hwnd, hIMC);

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// Edit_Menu()
//
// Handles context menu for edit fields.  Disables inappropriate commands.
// Note that this is NOT subclassing friendly, like most of our functions,
// for speed and convenience.
//
VOID Edit_Menu(HWND hwnd, PED ped, LPPOINT pt)
{
    HMENU   hMenu;
    INT     cmd = 0;
    INT     x;
    INT     y;
    UINT    uFlags = TPM_NONOTIFY | TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_RIGHTBUTTON;
    EditMenuItemState state = 
    {
        FALSE,              // fDisableCut
        TRUE,               // fDisablePaste
        TRUE,               // fNeedSeparatorBeforeImeMenu
        g_fIMMEnabled && ImmIsIME(GetKeyboardLayout(0)), // fIME
    };

    //
    // Set focus if we don't have its
    //
    if (!ped->fFocus)
    {
        SetFocus(hwnd);
    }

    //
    // Grab the menu from our resources...
    //
    hMenu = LoadMenu( HINST_THISDLL, MAKEINTRESOURCE( ID_EC_PROPERTY_MENU ));
    if (hMenu)
    {

        //
        // Undo -- not allowed if we have no saved undo info
        //
        if (ped->undoType == UNDO_NONE)
        {
            EnableMenuItem(hMenu, WM_UNDO, MF_BYCOMMAND | MFS_GRAYED);
        }

        if (ped->fReadOnly || ped->charPasswordChar) 
        {
            //
            // Cut and Delete -- not allowed if read-only or password
            //
            state.fDisableCut = TRUE;
        } 
        else 
        {
            //
            // Cut, Delete -- not allowed if there's no selection
            //
            if (ped->ichMinSel == ped->ichMaxSel)
            {
                state.fDisableCut = TRUE;
            }
        }

        //
        // Paste -- not allowed if there's no text on the clipboard
        // (this works for both OEM and Unicode)
        // Used to be always disabled for password edits MCostea #221035
        //

        if (IsClipboardFormatAvailable(CF_TEXT))
        {
            state.fDisablePaste = FALSE;
        }

        if (state.fDisableCut) 
        {
            EnableMenuItem(hMenu, WM_CUT,   MF_BYCOMMAND | MFS_GRAYED);
            EnableMenuItem(hMenu, WM_CLEAR, MF_BYCOMMAND | MFS_GRAYED);
        }

        if (state.fDisablePaste)
        {
            EnableMenuItem(hMenu, WM_PASTE, MF_BYCOMMAND | MFS_GRAYED);
        }

        //
        // Copy -- not allowed if there's no selection or password ec
        //
        if ((ped->ichMinSel == ped->ichMaxSel) || (ped->charPasswordChar))
        {
            EnableMenuItem(hMenu, WM_COPY, MF_BYCOMMAND | MFS_GRAYED);
        }

        //
        // Select All -- not allowed if there's no text or if everything is
        // selected.   Latter case takes care of first one.
        //
        if ((ped->ichMinSel == 0) && (ped->ichMaxSel == ped->cch))
        {
            EnableMenuItem(hMenu, EM_SETSEL, MF_BYCOMMAND | MFS_GRAYED);
        }

        if (ped->pLpkEditCallout) 
        {
            ped->pLpkEditCallout->EditSetMenu((PED0)ped, hMenu);
        } 
        else 
        {
            DeleteMenu(hMenu, ID_CNTX_DISPLAYCTRL, MF_BYCOMMAND);
            DeleteMenu(hMenu, ID_CNTX_RTL,         MF_BYCOMMAND);
            DeleteMenu(hMenu, ID_CNTX_INSERTCTRL,  MF_BYCOMMAND);

            if (state.fIME) 
            {
                //
                // One separator is left in the menu,
                // no need to add the one before IME menus
                //
                state.fNeedSeparatorBeforeImeMenu = FALSE;

            } 
            else 
            {
                //
                // Extra separator is left. Remove it.
                //
                HMENU hmenuSub = GetSubMenu(hMenu, 0);
                INT   nItems = GetMenuItemCount(hmenuSub) - 1;

                UserAssert(nItems >= 0);
                UserAssert(GetMenuState(hmenuSub, nItems, MF_BYPOSITION) & MF_SEPARATOR);

                //
                // remove needless separator
                //
                DeleteMenu(hmenuSub, nItems, MF_BYPOSITION);
            }
        }

        //
        // IME specific menu
        //
        if (state.fIME) 
        {
            Edit_SetIMEMenu(hMenu, hwnd, state);
        }

        //
        // BOGUS
        // We position the menu below & to the right of the point clicked on.
        // Is this cool?  I think so.  Excel 4.0 does the same thing.  It
        // seems like it would be neat if we could avoid obscuring the
        // selection.  But in actuality, it seems even more awkward to move
        // the menu out of the way of the selection.  The user can't click
        // and drag that way, and they have to move the mouse a ton.
        //
        // We need to use TPM_NONOTIFY because VBRUN100 and VBRUN200 GP-fault
        // on unexpected menu messages.
        //

        //
        // if message came via the keyboard then center on the control
        // We use -1 && -1 here not 0xFFFFFFFF like Win95 becuase we
        // previously converted the lParam to a point with sign extending.
        //
        if (pt->x == -1 && pt->y == -1) 
        {
            RECT rc;

            GetWindowRect(hwnd, &rc);
            x = rc.left + (rc.right - rc.left) / 2;
            y = rc.top + (rc.bottom - rc.top) / 2;
        } 
        else 
        {
            x = pt->x;
            y = pt->y;
        }

        if ( IS_BIDI_LOCALIZED_SYSTEM() )
        {
            uFlags |= TPM_LAYOUTRTL;
        }

        cmd = TrackPopupMenuEx(GetSubMenu(hMenu, 0), uFlags, x, y, hwnd, NULL);

        //
        // Free our menu
        //
        DestroyMenu(hMenu);

        if (cmd && (cmd != -1)) 
        {
            if (ped->pLpkEditCallout && cmd) 
            {
                ped->pLpkEditCallout->EditProcessMenu((PED0)ped, cmd);
            }
            if (!state.fIME || !Edit_DoIMEMenuCommand(ped, cmd, hwnd)) 
            {
                //
                // if cmd is not IME specific menu, send it.
                //
                SendMessage(hwnd, cmd, 0, (cmd == EM_SETSEL) ? 0xFFFFFFFF : 0L );
            }
        }
    }
}



//---------------------------------------------------------------------------//
//
// Edit_ClearText()
//
// Clears selected text.  Does NOT _send_ a fake char backspace.
//
VOID Edit_ClearText(PED ped)
{
    if (!ped->fReadOnly && (ped->ichMinSel < ped->ichMaxSel))
    {
        if (ped->fSingle)
        {
            EditSL_WndProc(ped, WM_CHAR, VK_BACK, 0L );
        }
        else
        {
            EditML_WndProc(ped, WM_CHAR, VK_BACK, 0L );
        }
    }

}


//---------------------------------------------------------------------------//
//
// Edit_CutText()
//
// Cuts selected text.  This removes and copies the selection to the clip,
// or if nothing is selected we delete (clear) the left character.
//
VOID Edit_CutText(PED ped)
{
    //
    // Cut selection--IE, remove and copy to clipboard, or if no selection,
    // delete (clear) character left.
    //
    if (!ped->fReadOnly &&
        (ped->ichMinSel < ped->ichMaxSel) &&
        SendMessage(ped->hwnd, WM_COPY, 0, 0L))
    {
        //
        // If copy was successful, delete the copied text by sending a
        // backspace message which will redraw the text and take care of
        // notifying the parent of changes.
        //
        Edit_ClearText(ped);
    }
}


//---------------------------------------------------------------------------//
//
// Edit_GetModKeys()
//
// Gets modifier key states.  Currently, we only check for VK_CONTROL and
// VK_SHIFT.
//
INT Edit_GetModKeys(INT keyMods) 
{
    INT scState;

    scState = 0;

    if (!keyMods) 
    {
        if (GetKeyState(VK_CONTROL) < 0)
        {
            scState |= CTRLDOWN;
        }

        if (GetKeyState(VK_SHIFT) < 0)
        {
            scState |= SHFTDOWN;
        }
    } 
    else if (keyMods != NOMODIFY)
    {
        scState = keyMods;
    }

    return scState;
}


//---------------------------------------------------------------------------//
//
// Edit_TabTheTextOut() AorW
// If fDrawText == FALSE, then this function returns the text extent of
// of the given strip of text. It does not worry about the Negative widths.
//
// If fDrawText == TRUE, this draws the given strip of Text expanding the
// tabs to proper lengths, calculates and fills up the NegCInfoForStrip with
// details required to draw the portions of this strip that goes beyond the
// xClipEndPos due to Negative C widths.
//
// Returns the max width AS A DWORD.  We don't care about the height
// at all.  No one uses it.  We keep a DWORD because that way we avoid
// overflow.
//
// NOTE: If the language pack is loaded EcTabTheTextOut is not used - the
// language pack must take care of all tab expansion and selection
// highlighting with full support for bidi layout and complex script
// glyph reordering.
//
UINT Edit_TabTheTextOut( 
    HDC hdc, 
    INT xClipStPos, 
    INT xClipEndPos, 
    INT xStart, 
    INT y, 
    LPSTR lpstring,
    INT nCount,
    ICH ichString,
    PED ped,
    INT iTabOrigin,
    BOOL fDraw,
    LPSTRIPINFO NegCInfoForStrip)
{
    INT     nTabPositions;         // Count of tabstops in tabstop array.
    LPINT   lpintTabStopPositions; // Tab stop positions in pixels.

    INT     cch;
    UINT    textextent;
    INT     xEnd;
    INT     pixeltabstop = 0;
    INT     i;
    INT     cxCharWidth;
    RECT    rc;
    BOOL    fOpaque;
    BOOL    fFirstPass = TRUE;
    PINT    charWidthBuff;

    INT     iTabLength;
    INT     nConsecutiveTabs;
    INT     xStripStPos;
    INT     xStripEndPos;
    INT     xEndOfStrip;
    STRIPINFO  RedrawStripInfo;
    STRIPINFO  NegAInfo;
    LPSTR    lpTab;
    LPWSTR   lpwTab;
    UINT     wNegCwidth, wNegAwidth;
    INT      xRightmostPoint = xClipStPos;
    INT      xTabStartPos;
    INT      iSavedBkMode = 0;
    WCHAR    wchar;
    SIZE     size = {0};
    ABC      abc ;

    COLORREF clrBkSave;
    COLORREF clrTextSave;
    HBRUSH   hbrBack = NULL;
    BOOL     fNeedDelete = FALSE;
    HRESULT  hr = E_FAIL;
    UINT     uRet;

    //
    // Algorithm: Draw the strip opaquely first. If a tab length is so
    // small that the portions of text on either side of a tab overlap with
    // the other, then this will result in some clipping. So, such portion
    // of the strip is remembered in "RedrawStripInfo" and redrawn
    // transparently later to compensate the clippings.
    //    NOTE: "RedrawStripInfo" can hold info about just one portion. So, if
    // more than one portion of the strip needs to be redrawn transparently,
    // then we "merge" all such portions into a single strip and redraw that
    // strip at the end.
    //

    if (fDraw) 
    {
        //
        // To begin with, let us assume that there is no Negative C for this
        // strip and initialize the Negative Width Info structure.
        //
        NegCInfoForStrip->nCount = 0;
        NegCInfoForStrip->XStartPos = xClipEndPos;

        //
        // We may not have to redraw any portion of this strip.
        //
        RedrawStripInfo.nCount = 0;

        fOpaque = (GetBkMode(hdc) == OPAQUE) || (fDraw == ECT_SELECTED);
    }
#if DBG
    else 
    {
        //
        // Both EditML_GetLineWidth() and Edit_CchInWidth() should be clipping
        // nCount to avoid overflow.
        //
        if (nCount > MAXLINELENGTH)
        {
            TraceMsg(TF_STANDARD, "EDIT: Edit_TabTheTextOut: %d > MAXLINELENGTH", nCount);
        }
    }
#endif

    //
    // Let us define the Clip rectangle.
    //
    rc.left   = xClipStPos;
    rc.right  = xClipEndPos;
    rc.top    = y;
    rc.bottom = y + ped->lineHeight;

#ifdef _USE_DRAW_THEME_TEXT_
    //
    // Check if we are themed.
    //
    if (ped->hTheme)
    {
        COLORREF clrBk;
        COLORREF clrText;
        INT iState;
        INT iProp;

        iState = (fDraw == ECT_SELECTED) ? ETS_SELECTED : Edit_GetStateId(ped);
        iProp = (fDraw == ECT_SELECTED) ? TMT_HIGHLIGHT : TMT_FILLCOLOR;
        hr = GetThemeColor(ped->hTheme, EP_EDITTEXT, iState, iProp, &clrBk);

        if (SUCCEEDED(hr))
        {
            iProp = (fDraw == ECT_SELECTED) ? TMT_HIGHLIGHTTEXT : TMT_TEXTCOLOR;
            hr = GetThemeColor(ped->hTheme, EP_EDITTEXT, iState, iProp, &clrText);

            if (SUCCEEDED(hr))
            {
                hbrBack     = CreateSolidBrush(clrBk);
                fNeedDelete = TRUE;
                clrBkSave   = SetBkColor(hdc, clrBk);
                clrTextSave = SetTextColor(hdc, clrText);
            }
        }
    }
#endif // _USE_DRAW_THEME_TEXT_

    if (!ped->hTheme || FAILED(hr))
    {
        if (fDraw == ECT_SELECTED)
        {
            //
            // use normal colors
            //
            hbrBack = GetSysColorBrush(COLOR_HIGHLIGHT);
            clrBkSave   = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
            clrTextSave = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
        else
        {
            hbrBack = Edit_GetBrush(ped, hdc, &fNeedDelete);
            clrBkSave = GetBkColor(hdc);
            clrTextSave = GetTextColor(hdc);
        }
    }


    //
    // Check if anything needs to be drawn.
    //
    if (!lpstring || !nCount) 
    {
        if (fDraw)
        {
            ExtTextOutW(hdc, xClipStPos, y,
                  (fOpaque ? ETO_OPAQUE | ETO_CLIPPED : ETO_CLIPPED),
                  &rc, L"", 0, 0L);
        }
        
        uRet = 0;
    }
    else
    {

        //
        // Starting position
        //
        xEnd = xStart;

        cxCharWidth  = ped->aveCharWidth;

        nTabPositions = (ped->pTabStops ? *(ped->pTabStops) : 0);
        if (ped->pTabStops) 
        {
            lpintTabStopPositions = (LPINT)(ped->pTabStops+1);
            if (nTabPositions == 1) 
            {
                pixeltabstop = lpintTabStopPositions[0];
                if (!pixeltabstop)
                {
                    pixeltabstop = 1;
                }
            }
        } 
        else 
        {
            lpintTabStopPositions = NULL;
            pixeltabstop = 8*cxCharWidth;
        }

        //
        // The first time we will draw the strip Opaquely. If some portions need
        // to be redrawn , then we will set the mode to TRANSPARENT and
        // jump to this location to redraw those portions.
        //

    RedrawStrip:
        while (nCount) 
        {
            wNegCwidth = ped->wMaxNegC;

            //
            // Search for the first TAB in this strip; also compute the extent
            // of the the strip upto and not including the tab character.
            //
            // Note - If the langpack is loaded, there will be no charWidthBuffer.
            //

            //
            // Do we have a character width buffer?
            //
            if (ped->charWidthBuffer) 
            {
                textextent = 0;
                cch = nCount;

                //
                // If so, does it have ABC widths?
                //
                if (ped->fTrueType) 
                {
                    UINT iRightmostPoint = 0;
                    UINT wCharIndex;
                    PABC pABCwidthBuff;

                    pABCwidthBuff = (PABC) ped->charWidthBuffer;

                    if (ped->fAnsi) 
                    {
                        for (i = 0; i < nCount; i++) 
                        {

                            if (lpstring[i] == VK_TAB) 
                            {
                                cch = i;
                                break;
                            }

                            wCharIndex = (UINT)(((PUCHAR)lpstring)[i]);
                            if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH) 
                            {
                                textextent += (UINT)(pABCwidthBuff[wCharIndex].abcA +
                                    pABCwidthBuff[wCharIndex].abcB);
                            } 
                            else 
                            {
                                //
                                // not in cache, will ask driver
                                //
                                GetCharABCWidthsA(hdc, wCharIndex, wCharIndex, &abc);
                                textextent += abc.abcA + abc.abcB ;
                            }

                            if (textextent > iRightmostPoint)
                            {
                                iRightmostPoint = textextent;
                            }

                            if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH) 
                            {
                                textextent += pABCwidthBuff[wCharIndex].abcC;
                            } 
                            else 
                            {
                                //
                                // not in cache
                                //
                                textextent += abc.abcC;
                            }

                            if (textextent > iRightmostPoint)
                            {
                                iRightmostPoint = textextent;
                            }
                        }

                    } 
                    else 
                    {
                        for (i = 0; i < nCount; i++) 
                        {
                            WCHAR UNALIGNED * lpwstring = (WCHAR UNALIGNED *)lpstring;

                            if (lpwstring[i] == VK_TAB) 
                            {
                                cch = i;

                                break;
                            }

                            wCharIndex = lpwstring[i] ;
                            if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                            {
                                textextent += pABCwidthBuff[wCharIndex].abcA +
                                              pABCwidthBuff[wCharIndex].abcB;
                            }
                            else 
                            {
                                GetCharABCWidthsW(hdc, wCharIndex, wCharIndex, &abc) ;
                                textextent += abc.abcA + abc.abcB ;
                            }

                            //
                            // Note that abcC could be negative so we need this
                            // statement here *and* below
                            //
                            if (textextent > iRightmostPoint)
                            {
                                iRightmostPoint = textextent;
                            }

                            if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                            {
                                textextent += pABCwidthBuff[wCharIndex].abcC;
                            }
                            else
                            {
                                textextent += abc.abcC ;
                            }

                            if (textextent > iRightmostPoint)
                            {
                                iRightmostPoint = textextent;
                            }
                        }
                    }

                    wNegCwidth = (int)(iRightmostPoint - textextent);
                } 
                else 
                {
                    //
                    // No! This is not a TrueType font; So, we have only character
                    // width info in this buffer.
                    //

                    charWidthBuff = ped->charWidthBuffer;

                    if (ped->fAnsi) 
                    {
                        //
                        // Initially assume no tabs exist in the text so cch=nCount.
                        //
                        for (i = 0; i < nCount; i++) 
                        {
                            if (lpstring[i] == VK_TAB) 
                            {
                                cch = i;
                                break;
                            }

                            //
                            // Call GetTextExtentPoint for dbcs/hankaku characters
                            //
                            if (ped->fDBCS && (i+1 < nCount)
                                    && Edit_IsDBCSLeadByte(ped,lpstring[i])) 
                            {
                                GetTextExtentPointA(hdc, &lpstring[i], 2, &size);
                                textextent += size.cx;
                                i++;
                            } 
                            else if ((UCHAR)lpstring[i] >= CHAR_WIDTH_BUFFER_LENGTH) 
                            {
                                //
                                // Skip this GetExtentPoint call for non hankaku code points
                                // Or if the character is in the width cache.
                                //
                                GetTextExtentPointA(hdc, &lpstring[i], 1, &size);
                                textextent += size.cx;
                            } 
                            else 
                            {
                                textextent += (UINT)(charWidthBuff[(UINT)(((PUCHAR)lpstring)[i])]);
                            }
                        }
                    } 
                    else 
                    {
                        LPWSTR lpwstring = (LPWSTR) lpstring ;
                        INT    cchUStart;  // start of unicode character count

                        for (i = 0; i < nCount; i++) 
                        {
                            if (lpwstring[i] == VK_TAB) 
                            {
                                cch = i;
                                break;
                            }

                            wchar = lpwstring[i];
                            if (wchar >= CHAR_WIDTH_BUFFER_LENGTH) 
                            {
                                //
                                // We have a Unicode character that is not in our
                                // cache, get all the characters outside the cache
                                // before getting the text extent on this part of the
                                // string.
                                //
                                cchUStart = i;
                                while (wchar >= CHAR_WIDTH_BUFFER_LENGTH &&
                                        wchar != VK_TAB && i < nCount) 
                                {
                                    wchar = lpwstring[++i];
                                }

                                GetTextExtentPointW(hdc, (LPWSTR)lpwstring + cchUStart,
                                        i-cchUStart, &size);
                                textextent += size.cx;


                                if (wchar == VK_TAB || i >= nCount) 
                                {
                                    cch = i;
                                    break;
                                }

                                //
                                // We have a char that is in the cache, fall through.
                                //
                            }

                            //
                            // The width of this character is in the cache buffer.
                            //
                            textextent += ped->charWidthBuffer[wchar];
                        }
                    }
                }

                nCount -= cch;
            } 
            else 
            {
                //
                // Gotta call the driver to do our text extent.
                //
                if (ped->fAnsi) 
                {
                    cch = (INT)Edit_FindTabA(lpstring, nCount);
                    GetTextExtentPointA(hdc, lpstring, cch, &size);
                } 
                else 
                {
                    cch = (INT)Edit_FindTabW((LPWSTR) lpstring, nCount);
                    GetTextExtentPointW(hdc, (LPWSTR)lpstring, cch, &size);
                }
                nCount -= cch;

                //
                // Subtruct Overhang for Italic fonts.
                //
                textextent = size.cx - ped->charOverhang;
            }

            //
            // textextent is computed.
            //

            xStripStPos = xEnd;
            xEnd += (int)textextent;
            xStripEndPos = xEnd;

            //
            // We will consider the negative widths only if when we draw opaquely.
            //
            if (fFirstPass && fDraw) 
            {
                xRightmostPoint = max(xStripEndPos + (int)wNegCwidth, xRightmostPoint);

                //
                // Check if this strip peeps beyond the clip region.
                //
                if (xRightmostPoint > xClipEndPos) 
                {
                    if (!NegCInfoForStrip->nCount) 
                    {
                        NegCInfoForStrip->lpString = lpstring;
                        NegCInfoForStrip->ichString = ichString;
                        NegCInfoForStrip->nCount = nCount+cch;
                        NegCInfoForStrip->XStartPos = xStripStPos;
                    }
                }
            }

            if (ped->fAnsi)
            {
                //
                // Possibly Points to a tab character.
                //
                lpTab = lpstring + cch;
            }
            else
            {
                lpwTab = ((LPWSTR)lpstring) + cch ;
            }

            //
            // we must consider all the consecutive tabs and calculate the
            // the begining of next strip.
            //
            nConsecutiveTabs = 0;
            while (nCount &&
                   (ped->fAnsi ? (*lpTab == VK_TAB) : (*lpwTab == VK_TAB))) 
            {
                //
                // Find the next tab position and update the x value.
                //
                xTabStartPos = xEnd;
                if (pixeltabstop)
                {
                    xEnd = (((xEnd-iTabOrigin)/pixeltabstop)*pixeltabstop) +
                        pixeltabstop + iTabOrigin;
                }
                else 
                {
                    for (i = 0; i < nTabPositions; i++) 
                    {
                        if (xEnd < (lpintTabStopPositions[i] + iTabOrigin)) 
                        {
                            xEnd = (lpintTabStopPositions[i] + iTabOrigin);
                            break;
                        }
                     }

                    //
                    // Check if all the tabstops set are exhausted; Then start using
                    // default tab stop positions.
                    //
                    if (i == nTabPositions) 
                    {
                        pixeltabstop = 8*cxCharWidth;
                        xEnd = ((xEnd - iTabOrigin)/pixeltabstop)*pixeltabstop +
                            pixeltabstop + iTabOrigin;
                    }
                }

                if (fFirstPass && fDraw) 
                {
                    xRightmostPoint = max(xEnd, xRightmostPoint);

                    //
                    // Check if this strip peeps beyond the clip region
                    //
                    if (xRightmostPoint > xClipEndPos) 
                    {
                        if (!NegCInfoForStrip->nCount) 
                        {
                            NegCInfoForStrip->ichString = ichString + cch + nConsecutiveTabs;
                            NegCInfoForStrip->nCount = nCount;
                            NegCInfoForStrip->lpString = (ped->fAnsi ?
                                                            lpTab : (LPSTR) lpwTab);
                            NegCInfoForStrip->XStartPos = xTabStartPos;
                        }
                    }
                }

                nConsecutiveTabs++;
                nCount--;
                ped->fAnsi ? lpTab++ : (LPSTR) (lpwTab++) ;  // Move to the next character.
            }

            if (fDraw) 
            {
                if (fFirstPass) 
                {
                    //
                    // Is anything remaining to be drawn in this strip?
                    //
                    if (!nCount)
                    {
                        //
                        // No! We are done.
                        //
                        rc.right = xEnd;
                    }
                    else 
                    {
                        //
                        // "x" is the effective starting position of next strip.
                        //
                        iTabLength = xEnd - xStripEndPos;

                        //
                        // Check if there is a possibility of this tab length being too small
                        // compared to the negative A and C widths if any.
                        //
                        if ((wNegCwidth + (wNegAwidth = ped->wMaxNegA)) > (UINT)iTabLength) 
                        {
                            //
                            // Unfortunately, there is a possiblity of an overlap.
                            // Let us find out the actual NegA for the next strip.
                            //
                            wNegAwidth = GetActualNegA(
                                  hdc,
                                  ped,
                                  xEnd,
                                  lpstring + (cch + nConsecutiveTabs)*ped->cbChar,
                                  ichString + cch + nConsecutiveTabs,
                                  nCount,
                                  &NegAInfo);
                        }

                        //
                        // Check if they actually overlap
                        //
                        if ((wNegCwidth + wNegAwidth) <= (UINT)iTabLength) 
                        {
                            //
                            // No overlap between the strips. This is the ideal situation.
                            //
                            rc.right = xEnd - wNegAwidth;
                        } 
                        else 
                        {
                            //
                            // Yes! They overlap.
                            //
                            rc.right = xEnd;

                            //
                            // See if negative C width is too large compared to tab length.
                            //
                            if (wNegCwidth > (UINT)iTabLength) 
                            {
                                //
                                // Must redraw transparently a part of the current strip later.
                                //
                                if (RedrawStripInfo.nCount) 
                                {
                                    //
                                    // A previous strip also needs to be redrawn; So, merge this
                                    // strip to that strip.
                                    //
                                    RedrawStripInfo.nCount = (ichString -
                                        RedrawStripInfo.ichString) + cch;
                                } 
                                else 
                                {
                                    RedrawStripInfo.nCount = cch;
                                    RedrawStripInfo.lpString = lpstring;
                                    RedrawStripInfo.ichString = ichString;
                                    RedrawStripInfo.XStartPos = xStripStPos;
                                }
                            }

                            if (wNegAwidth) 
                            {
                                //
                                // Must redraw transparently the first part of the next strip later.
                                //
                                if (RedrawStripInfo.nCount) 
                                {
                                    //
                                    // A previous strip also needs to be redrawn; So, merge this
                                    // strip to that strip.
                                    //
                                    RedrawStripInfo.nCount = (NegAInfo.ichString - RedrawStripInfo.ichString) +
                                           NegAInfo.nCount;
                                } 
                                else
                                {
                                    RedrawStripInfo = NegAInfo;
                                }
                            }
                        }
                    }
                }

                if (rc.left < xClipEndPos) 
                {
                    if (fFirstPass) 
                    {
                        //
                        // If this is the end of the strip, then complete the rectangle.
                        //
                        if ((!nCount) && (xClipEndPos == MAXCLIPENDPOS))
                        {
                            rc.right = max(rc.right, xClipEndPos);
                        }
                        else
                        {
                            rc.right = min(rc.right, xClipEndPos);
                        }
                    }

                    //
                    // Draw the current strip.
                    //
                    if (rc.left < rc.right)
                    {
                        if (ped->fAnsi)
                        {
                            ExtTextOutA(hdc,
                                        xStripStPos,
                                        y,
                                        (fFirstPass && fOpaque ? (ETO_OPAQUE | ETO_CLIPPED) : ETO_CLIPPED),
                                        (LPRECT)&rc, lpstring, cch, 0L);
                        }
                        else
                        {
                            ExtTextOutW(hdc,
                                        xStripStPos,
                                        y,
                                        (fFirstPass && fOpaque ? (ETO_OPAQUE | ETO_CLIPPED) : ETO_CLIPPED),
                                        (LPRECT)&rc, (LPWSTR)lpstring, cch, 0L);
                        }
                    }
                }

                if (fFirstPass)
                {
                    rc.left = max(rc.right, xClipStPos);
                }
                ichString += (cch+nConsecutiveTabs);
            }

            //
            // Skip over the tab and the characters we just drew.
            //
            lpstring += (cch + nConsecutiveTabs) * ped->cbChar;
        }

        xEndOfStrip = xEnd;

        //
        // check if we need to draw some portions transparently.
        //
        if (fFirstPass && fDraw && RedrawStripInfo.nCount) 
        {
            iSavedBkMode = SetBkMode(hdc, TRANSPARENT);
            fFirstPass = FALSE;

            nCount = RedrawStripInfo.nCount;
            rc.left = xClipStPos;
            rc.right = xClipEndPos;
            lpstring = RedrawStripInfo.lpString;
            ichString = RedrawStripInfo.ichString;
            xEnd = RedrawStripInfo.XStartPos;

            //
            // Redraw Transparently.
            //
            goto RedrawStrip;
        }

        //
        // Did we change the Bk mode?
        //
        if (iSavedBkMode)
        {
            SetBkMode(hdc, iSavedBkMode);
        }

        uRet = (UINT)(xEndOfStrip - xStart);
    }

    SetTextColor(hdc, clrTextSave);
    SetBkColor(hdc, clrBkSave);
    if (hbrBack && fNeedDelete)
    {
        DeleteObject(hbrBack);
    }

    return uRet;
}


//---------------------------------------------------------------------------//
//
// Edit_CchInWidth AorW
//
// Returns maximum count of characters (up to cch) from the given
// string (starting either at the beginning and moving forward or at the
// end and moving backwards based on the setting of the fForward flag)
// which will fit in the given width. ie. Will tell you how much of
// lpstring will fit in the given width even when using proportional
// characters. WARNING: If we use kerning, then this loses...
// 
// NOTE: Edit_CchInWidth is not called if the language pack is loaded.
// 
ICH Edit_CchInWidth(
    PED   ped,
    HDC   hdc,
    LPSTR lpText,
    ICH   cch,
    INT   width,
    BOOL  fForward)
{
    INT stringExtent;
    INT cchhigh;
    INT cchnew = 0;
    INT cchlow = 0;
    SIZE size;
    LPSTR lpStart;

    if ((width <= 0) || !cch)
    {
        return (0);
    }

    //
    // Optimize nonproportional fonts for single line ec since they don't have
    // tabs.
    //

    //
    // Change optimize condition for fixed pitch font
    //
    if (ped->fNonPropFont && ped->fSingle && !ped->fDBCS) 
    {
        return Edit_AdjustIch(ped, lpText, umin(width/ped->aveCharWidth, (INT)cch));
    }

    //
    // Check if password hidden chars are being used.
    //
    if (ped->charPasswordChar) 
    {
        return (umin(width / ped->cPasswordCharWidth, (INT)cch));
    }

    //
    // ALWAYS RESTRICT TO AT MOST MAXLINELENGTH to avoid overflow...
    //
    cch = umin(MAXLINELENGTH, cch);

    cchhigh = cch + 1;
    while (cchlow < cchhigh - 1) 
    {
        cchnew = umax((cchhigh - cchlow) / 2, 1) + cchlow;

        lpStart = lpText;

        //
        // If we want to figure out how many fit starting at the end and moving
        // backwards, make sure we move to the appropriate position in the
        // string before calculating the text extent.
        //
        if (!fForward)
        {
            lpStart += (cch - cchnew)*ped->cbChar;
        }

        if (ped->fSingle) 
        {
            if (ped->fAnsi)
            {
                GetTextExtentPointA(hdc, (LPSTR)lpStart, cchnew, &size);
            }
            else
            {
                GetTextExtentPointW(hdc, (LPWSTR)lpStart, cchnew, &size);
            }

            stringExtent = size.cx;
        } 
        else 
        {
            stringExtent = Edit_TabTheTextOut(hdc, 0, 0, 0, 0,
                lpStart,
                cchnew, 0,
                ped, 0, ECT_CALC, NULL );
        }

        if (stringExtent > width) 
        {
            cchhigh = cchnew;
        } 
        else 
        {
            cchlow = cchnew;
        }
    }

    //
    // Call Edit_AdjustIch ( generic case )
    //
    cchlow = Edit_AdjustIch(ped, lpText, cchlow);

    return cchlow;
}


//---------------------------------------------------------------------------//
//
// Edit_FindTab
//
// Scans lpstr and return s the number of CHARs till the first TAB.
// Scans at most cch chars of lpstr.
//
ICH Edit_FindTabA(
    LPSTR lpstr,
    ICH cch)
{
    LPSTR copylpstr = lpstr;

    if (cch)
    {
        while (*lpstr != VK_TAB) 
        {
            lpstr++;
            if (--cch == 0)
            {
                break;
            }
        }
    }

    return (ICH)(lpstr - copylpstr);
}


//---------------------------------------------------------------------------//
//
ICH Edit_FindTabW(
    LPWSTR lpstr,
    ICH cch)
{
    LPWSTR copylpstr = lpstr;

    if (cch)
    {
        while (*lpstr != VK_TAB) 
        {
            lpstr++;
            if (--cch == 0)
            {
                break;
            }
        }
    }

    return ((ICH)(lpstr - copylpstr));
}

//---------------------------------------------------------------------------//
//
// Edit_GetBrush()
// 
// Gets appropriate background brush to erase with.
//
HBRUSH Edit_GetBrush(PED ped, HDC hdc, LPBOOL pfNeedDelete)
{
    HBRUSH   hbr;
    COLORREF clr;
    HRESULT  hr = E_FAIL;

#ifdef _USE_DRAW_THEME_TEXT_
    if (ped->hTheme)
    {
        INT iStateId = Edit_GetStateId(ped);

        hr = GetThemeColor(ped->hTheme, EP_EDITTEXT, iStateId, TMT_FILLCOLOR, &clr);
        if (SUCCEEDED(hr))
        {
            hbr = CreateSolidBrush(clr);

            if (pfNeedDelete)
            {
                //
                // tell the caller this brush needs to be deleted
                //
                *pfNeedDelete = TRUE;
            }
        }
    }
#endif // _USE_DRAW_THEME_TEXT_

    if (!ped->hTheme || FAILED(hr))
    {
        BOOL f40Compat;

        f40Compat = Is400Compat(UserGetVersion());

        //
        // Get background brush
        //
        if ((ped->fReadOnly || ped->fDisabled) && f40Compat) 
        {
            hbr = Edit_GetControlBrush(ped, hdc, WM_CTLCOLORSTATIC);
        } 
        else
        {
            hbr = Edit_GetControlBrush(ped, hdc, WM_CTLCOLOREDIT);
        }

        if (ped->fDisabled && (ped->fSingle || f40Compat)) 
        {
            //
            // Change text color
            //
            clr = GetSysColor(COLOR_GRAYTEXT);
            if (clr != GetBkColor(hdc))
            {
                SetTextColor(hdc, clr);
            }
        }
    }

    return hbr;
}


//---------------------------------------------------------------------------//
//
// NextWordCallBack
//
VOID NextWordCallBack(PED ped, ICH ichStart, BOOL fLeft, ICH  *pichMin, ICH  *pichMax)
{
    ICH ichMinSel;
    ICH ichMaxSel;
    LPSTR pText;

    pText = Edit_Lock(ped);

    if (fLeft || 
        (!(BOOL)CALLWORDBREAKPROC(ped->lpfnNextWord, (LPSTR)pText, ichStart, ped->cch, WB_ISDELIMITER) &&
        (ped->fAnsi ? (*(pText + ichStart) != VK_RETURN) : (*((LPWSTR)pText + ichStart) != VK_RETURN))))
    {
        ichMinSel = CALLWORDBREAKPROC(*ped->lpfnNextWord, (LPSTR)pText, ichStart, ped->cch, WB_LEFT);
    }
    else
    {
        ichMinSel = CALLWORDBREAKPROC(*ped->lpfnNextWord, (LPSTR)pText, ichStart, ped->cch, WB_RIGHT);
    }

    ichMaxSel = min(ichMinSel + 1, ped->cch);

    if (ped->fAnsi) 
    {
        if (*(pText + ichMinSel) == VK_RETURN) 
        {
            if (ichMinSel > 0 && *(pText + ichMinSel - 1) == VK_RETURN) 
            {
                //
                // So that we can treat CRCRLF as one word also.
                //
                ichMinSel--;
            } 
            else if (*(pText+ichMinSel + 1) == VK_RETURN) 
            {
                //
                // Move MaxSel on to the LF
                //
                ichMaxSel++;
            }
        }
    } 
    else 
    {
        if (*((LPWSTR)pText + ichMinSel) == VK_RETURN) 
        {
            if (ichMinSel > 0 && *((LPWSTR)pText + ichMinSel - 1) == VK_RETURN) 
            {
                //
                // So that we can treat CRCRLF as one word also.
                //
                ichMinSel--;
            } 
            else if (*((LPWSTR)pText+ichMinSel + 1) == VK_RETURN) 
            {
                //
                // Move MaxSel on to the LF
                //
                ichMaxSel++;
            }
        }
    }

    ichMaxSel = CALLWORDBREAKPROC(ped->lpfnNextWord, (LPSTR)pText, ichMaxSel, ped->cch, WB_RIGHT);
    Edit_Unlock(ped);

    if (pichMin)  
    {
        *pichMin = ichMinSel;
    }

    if (pichMax)
    {
        *pichMax = ichMaxSel;
    }
}


//---------------------------------------------------------------------------//
//
// NextWordLpkCallback
// 
// Identifies next/prev word position for complex scripts
//
VOID NextWordLpkCallBack(PED  ped, ICH  ichStart, BOOL fLeft, ICH *pichMin, ICH *pichMax)
{
    PSTR pText = Edit_Lock(ped);
    HDC  hdc   = Edit_GetDC(ped, TRUE);

    ped->pLpkEditCallout->EditNextWord((PED0)ped, hdc, pText, ichStart, fLeft, pichMin, pichMax);

    Edit_ReleaseDC(ped, hdc, TRUE);
    Edit_Unlock(ped);
}


//---------------------------------------------------------------------------//
//
// Edit_Word
//
// if fLeft, Returns the ichMinSel and ichMaxSel of the word to the
// left of ichStart. ichMinSel contains the starting letter of the word,
// ichmaxsel contains all spaces up to the first character of the next word.
// 
// if !fLeft, Returns the ichMinSel and ichMaxSel of the word to the right of
// ichStart. ichMinSel contains the starting letter of the word, ichmaxsel
// contains the first letter of the next word. If ichStart is in the middle
// of a word, that word is considered the left or right word.
// 
// A CR LF pair or CRCRLF triple is considered a single word in
// multiline edit controls.
//
VOID Edit_Word(PED ped, ICH ichStart, BOOL fLeft, LPICH pichMin, LPICH pichMax)
{
    BOOL charLocated = FALSE;
    BOOL spaceLocated = FALSE;

    if ((!ichStart && fLeft) || (ichStart == ped->cch && !fLeft)) 
    {
        //
        // We are at the beginning of the text (looking left) or we are at end
        // of text (looking right), no word here
        //
        if (pichMin)
        {
            *pichMin = 0;
        }

        if (pichMax)
        { 
            *pichMax = 0;
        }

        return;
    }

    //
    // Don't give out hints about word breaks if password chars are being used,
    //
    if (ped->charPasswordChar) 
    {
        if (pichMin)
        {
            *pichMin = 0;
        }

        if (pichMax) 
        {
            *pichMax = ped->cch;
        }

        return;
    }

    if (ped->fAnsi) 
    {
        PSTR pText; 
        PSTR pWordMinSel;
        PSTR pWordMaxSel;
        PSTR pPrevChar;

        UserAssert(ped->cbChar == sizeof(CHAR));

        if (ped->lpfnNextWord) 
        {
            NextWordCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        if (ped->pLpkEditCallout) 
        {
            NextWordLpkCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        pText = Edit_Lock(ped);
        pWordMinSel = pWordMaxSel = pText + ichStart;

        //
        // if fLeft: Move pWordMinSel to the left looking for the start of a word.
        // If we start at a space, we will include spaces in the selection as we
        // move left untill we find a nonspace character. At that point, we continue
        // looking left until we find a space. Thus, the selection will consist of
        // a word with its trailing spaces or, it will consist of any leading at the
        // beginning of a line of text.
        //

        //
        // if !fLeft: (ie. right word) Move pWordMinSel looking for the start of a
        // word. If the pWordMinSel points to a character, then we move left
        // looking for a space which will signify the start of the word. If
        // pWordMinSel points to a space, we look right till we come upon a
        // character. pMaxWord will look right starting at pMinWord looking for the
        // end of the word and its trailing spaces.
        //

        if (fLeft || !ISDELIMETERA(*pWordMinSel) && *pWordMinSel != 0x0D) 
        {
            //
            // If we are moving left or if we are moving right and we are not on a
            // space or a CR (the start of a word), then we was look left for the
            // start of a word which is either a CR or a character. We do this by
            // looking left till we find a character (or if CR we stop), then we
            // continue looking left till we find a space or LF.
            //
            while (pWordMinSel > pText && ((!ISDELIMETERA(*(pWordMinSel - 1)) &&
                    *(pWordMinSel - 1) != 0x0A) || !charLocated)) 
            {
                //
                // Treat double byte character as a word  ( in ansi pWordMinSel loop )
                //
                pPrevChar = Edit_AnsiPrev( ped, pText, pWordMinSel );

                //
                // are looking right ( !fLeft ).
                // current character is a double byte chararacter or
                // character is a double byte character, we
                // on the beggining of a word.
                //
                if ( !fLeft && ( ISDELIMETERA( *pPrevChar )           ||
                                 *pPrevChar == 0x0A                   ||
                                 Edit_IsDBCSLeadByte(ped, *pWordMinSel)  ||
                                 pWordMinSel - pPrevChar == 2 ) ) 
                {
                    //
                    // If we are looking for the start of the word right, then we
                    // stop when we have found it. (needed in case charLocated is
                    // still FALSE)
                    //
                    break;
                }

                if (pWordMinSel - pPrevChar == 2) 
                {
                    //
                    // character is a double byte character.
                    // we are in a word ( charLocated == TRUE )
                    // position is the beginning of the word
                    // we are not in a word ( charLocated == FALSE )
                    // previous character is what we looking for.
                    //
                    if (!charLocated) 
                    {
                        pWordMinSel = pPrevChar;
                    }

                    break;
                }

                pWordMinSel = pPrevChar;

                if (!ISDELIMETERA(*pWordMinSel) && *pWordMinSel != 0x0A) 
                {
                    //
                    // We have found the last char in the word. Continue looking
                    // backwards till we find the first char of the word
                    //
                    charLocated = TRUE;

                    //
                    // We will consider a CR the start of a word
                    //
                    if (*pWordMinSel == 0x0D)
                    {
                        break;
                    }
                }
            }
        } 
        else 
        {
            while ((ISDELIMETERA(*pWordMinSel) || *pWordMinSel == 0x0A) && pWordMinSel < pText + ped->cch)
            {
                pWordMinSel++;
            }
        }

        //
        // Adjust the initial position of pWordMaxSel ( in ansi )
        //
        pWordMaxSel = Edit_AnsiNext(ped, pWordMinSel);
        pWordMaxSel = min(pWordMaxSel, pText + ped->cch);

        //
        // pWordMinSel points a double byte character AND
        // points non space
        // then
        // pWordMaxSel points the beggining of next word.
        //
        if ((pWordMaxSel - pWordMinSel == 2) && !ISDELIMETERA(*pWordMaxSel))
        {
            goto FastReturnA;
        }

        if (*pWordMinSel == 0x0D) 
        {
            if (pWordMinSel > pText && *(pWordMinSel - 1) == 0x0D)
            {
                //
                // So that we can treat CRCRLF as one word also.
                //
                pWordMinSel--;
            }
            else if (*(pWordMinSel + 1) == 0x0D)
            {
                //
                // Move MaxSel on to the LF
                //
                pWordMaxSel++;
            }
        }

        //
        // Check if we have a one character word
        //
        if (ISDELIMETERA(*pWordMaxSel))
        {
            spaceLocated = TRUE;
        }

        //
        // Move pWordMaxSel to the right looking for the end of a word and its
        // trailing spaces. WordMaxSel stops on the first character of the next
        // word. Thus, we break either at a CR or at the first nonspace char after
        // a run of spaces or LFs.
        //
        while ((pWordMaxSel < pText + ped->cch) && (!spaceLocated || (ISDELIMETERA(*pWordMaxSel)))) 
        {
            if (*pWordMaxSel == 0x0D)
            {
                break;
            }

            //
            // Treat double byte character as a word ( in ansi pWordMaxSel loop )
            // if it's a double byte character then
            // we are at the beginning of next word
            // which is a double byte character.
            //
            if (Edit_IsDBCSLeadByte( ped, *pWordMaxSel))
            {
                break;
            }

            pWordMaxSel++;

            if (ISDELIMETERA(*pWordMaxSel))
            {
                spaceLocated = TRUE;
            }

            if (*(pWordMaxSel - 1) == 0x0A)
            {
                break;
            }
        }

        //
        // label for fast return ( for Ansi )
        //
FastReturnA:
        Edit_Unlock(ped);

        if (pichMin)
        {
            *pichMin = (ICH)(pWordMinSel - pText);
        }

        if (pichMax)
        {
            *pichMax = (ICH)(pWordMaxSel - pText);
        }
    } 
    else 
    {
        LPWSTR pwText;
        LPWSTR pwWordMinSel;
        LPWSTR pwWordMaxSel;
        BOOL   charLocated = FALSE;
        BOOL   spaceLocated = FALSE;
        PWSTR  pwPrevChar;

        UserAssert(ped->cbChar == sizeof(WCHAR));

        if (ped->lpfnNextWord) 
        {
            NextWordCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        if (ped->pLpkEditCallout) 
        {
            NextWordLpkCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        pwText = (LPWSTR)Edit_Lock(ped);
        pwWordMinSel = pwWordMaxSel = pwText + ichStart;

        //
        // if fLeft: Move pWordMinSel to the left looking for the start of a word.
        // If we start at a space, we will include spaces in the selection as we
        // move left untill we find a nonspace character. At that point, we continue
        // looking left until we find a space. Thus, the selection will consist of
        // a word with its trailing spaces or, it will consist of any leading at the
        // beginning of a line of text.
        //

        //
        // if !fLeft: (ie. right word) Move pWordMinSel looking for the start of a
        // word. If the pWordMinSel points to a character, then we move left
        // looking for a space which will signify the start of the word. If
        // pWordMinSel points to a space, we look right till we come upon a
        // character. pMaxWord will look right starting at pMinWord looking for the
        // end of the word and its trailing spaces.
        //

        if (fLeft || (!ISDELIMETERW(*pwWordMinSel) && *pwWordMinSel != 0x0D))
        {
            //
            // If we are moving left or if we are moving right and we are not on a
            // space or a CR (the start of a word), then we was look left for the
            // start of a word which is either a CR or a character. We do this by
            // looking left till we find a character (or if CR we stop), then we
            //
            // continue looking left till we find a space or LF.
            while (pwWordMinSel > pwText && ((!ISDELIMETERW(*(pwWordMinSel - 1)) && *(pwWordMinSel - 1) != 0x0A) || !charLocated))
            {
                //
                // Treat double byte character as a word  ( in unicode pwWordMinSel loop )
                //
                pwPrevChar = pwWordMinSel - 1;

                //
                // we are looking right ( !fLeft ).
                //  
                // if current character is a double width chararacter
                // or previous character is a double width character,
                // we are on the beggining of a word.
                //
                if (!fLeft && (ISDELIMETERW( *pwPrevChar)  ||
                               *pwPrevChar == 0x0A         ||
                               Edit_IsFullWidth(CP_ACP,*pwWordMinSel) ||
                               Edit_IsFullWidth(CP_ACP,*pwPrevChar)))
                {
                    //
                    // If we are looking for the start of the word right, then we
                    // stop when we have found it. (needed in case charLocated is
                    // still FALSE)
                    //
                    break;
                }

                if (Edit_IsFullWidth(CP_ACP,*pwPrevChar)) 
                {
                    //
                    // Previous character is a double width character.
                    // 
                    // if we are in a word ( charLocated == TRUE )
                    // current position is the beginning of the word
                    // if we are not in a word ( charLocated == FALSE )
                    // the previous character is what we looking for.
                    //
                    if ( !charLocated ) 
                    {
                        pwWordMinSel = pwPrevChar;
                    }

                    break;
                }

                pwWordMinSel = pwPrevChar;

                if (!ISDELIMETERW(*pwWordMinSel) && *pwWordMinSel != 0x0A)
                {
                    //
                    // We have found the last char in the word. Continue looking
                    // backwards till we find the first char of the word
                    //
                    charLocated = TRUE;

                    //
                    // We will consider a CR the start of a word
                    //
                    if (*pwWordMinSel == 0x0D)
                    {
                        break;
                    }
                }
            }
        } 
        else 
        {
            //
            // We are moving right and we are in between words so we need to move
            // right till we find the start of a word (either a CR or a character.
            //
            while ((ISDELIMETERW(*pwWordMinSel) || *pwWordMinSel == 0x0A) && pwWordMinSel < pwText + ped->cch)
            {
                pwWordMinSel++;
            }
        }

        pwWordMaxSel = min((pwWordMinSel + 1), (pwText + ped->cch));

        //
        // If pwWordMinSel points a double width character AND
        // pwWordMaxSel points non space then
        // pwWordMaxSel points the beggining of next word.
        //
        if (Edit_IsFullWidth(CP_ACP,*pwWordMinSel) && ! ISDELIMETERW(*pwWordMaxSel))
        {
            goto FastReturnW;
        }

        if (*pwWordMinSel == 0x0D) 
        {
            if (pwWordMinSel > pwText && *(pwWordMinSel - 1) == 0x0D)
            {
                //
                // So that we can treat CRCRLF as one word also.
                //
                pwWordMinSel--;
            }
            else if (*(pwWordMinSel + 1) == 0x0D)
            {
                //
                // Move MaxSel on to the LF
                //
                pwWordMaxSel++;
            }
        }

        //
        // Check if we have a one character word
        //
        if (ISDELIMETERW(*pwWordMaxSel))
        {
            spaceLocated = TRUE;
        }

        //
        // Move pwWordMaxSel to the right looking for the end of a word and its
        // trailing spaces. WordMaxSel stops on the first character of the next
        // word. Thus, we break either at a CR or at the first nonspace char after
        // a run of spaces or LFs.
        //
        while ((pwWordMaxSel < pwText + ped->cch) && (!spaceLocated || (ISDELIMETERW(*pwWordMaxSel)))) 
        {
            if (*pwWordMaxSel == 0x0D)
            {
                break;
            }

            //
            // treat double byte character as a word ( in unicode pwWordMaxSel loop )
            // if it's a double width character
            // then we are at the beginning of
            // the next word which is a double
            // width character.
            //
            if (Edit_IsFullWidth(CP_ACP,*pwWordMaxSel))
            {
                break;
            }

            pwWordMaxSel++;

            if (ISDELIMETERW(*pwWordMaxSel))
            {
                spaceLocated = TRUE;
            }


            if (*(pwWordMaxSel - 1) == 0x0A)
            {
                break;
            }
        }

        //
        // label for fast return ( for Unicode )
        //
FastReturnW:
        Edit_Unlock(ped);

        if (pichMin)
        {
            *pichMin = (ICH)(pwWordMinSel - pwText);
        }

        if (pichMax)
        {
            *pichMax = (ICH)(pwWordMaxSel - pwText);
        }
    }
}


//---------------------------------------------------------------------------//
//
// Edit_SaveUndo()
//
// Saves old undo information into given buffer, and clears out info in
// passed in undo buffer.  If we're restoring, pundoFrom and pundoTo are
// reversed.
//
VOID Edit_SaveUndo(PUNDO pundoFrom, PUNDO pundoTo, BOOL fClear)
{
    //
    // Save undo data
    //
    RtlCopyMemory(pundoTo, pundoFrom, sizeof(UNDO));

    //
    // Clear passed in undo buffer
    //
    if (fClear)
    {
        RtlZeroMemory(pundoFrom, sizeof(UNDO));
    }
}


//---------------------------------------------------------------------------//
//
// Edit_EmptyUndo AorW
//
// Empties the undo buffer.
//
VOID Edit_EmptyUndo(PUNDO pundo)
{
    if (pundo->hDeletedText)
    {
        GlobalFree(pundo->hDeletedText);
    }

    RtlZeroMemory(pundo, sizeof(UNDO));
}


//---------------------------------------------------------------------------//
//
// Edit_MergeUndoInsertInfo() -
//
// When an insert takes place, this function is called with the info about
// the new insertion (the insertion point and the count of chars inserted);
// This looks at the existing Undo info and merges the new new insert info
// with it.
//
VOID Edit_MergeUndoInsertInfo(PUNDO pundo, ICH ichInsert, ICH cchInsert)
{
    //
    // If undo buffer is empty, just insert the new info as UNDO_INSERT
    //
    if (pundo->undoType == UNDO_NONE) 
    {
        pundo->undoType    = UNDO_INSERT;
        pundo->ichInsStart = ichInsert;
        pundo->ichInsEnd   = ichInsert+cchInsert;
    } 
    else if (pundo->undoType & UNDO_INSERT) 
    {
        //
        // If there's already some undo insert info,
        // try to merge the two.
        //

        //
        // Check they are adjacent.
        //
        if (pundo->ichInsEnd == ichInsert)
        {
            //
            // if so, just concatenate.
            //
            pundo->ichInsEnd += cchInsert;
        }
        else 
        {
            //
            // The new insert is not contiguous with the old one.
            //
UNDOINSERT:
            //
            // If there is some UNDO_DELETE info already here, check to see
            // if the new insert takes place at a point different from where
            // that deletion occurred.
            //
            if ((pundo->undoType & UNDO_DELETE) && (pundo->ichDeleted != ichInsert))
            {
                //
                // User is inserting into a different point; So, let us
                // forget any UNDO_DELETE info;
                //
                if (pundo->hDeletedText)
                {
                    GlobalFree(pundo->hDeletedText);
                }

                pundo->hDeletedText = NULL;
                pundo->ichDeleted = 0xFFFFFFFF;
                pundo->undoType &= ~UNDO_DELETE;
            }

            //
            // Since the old insert and new insert are not adjacent, let us
            // forget everything about the old insert and keep just the new
            // insert info as the UNDO_INSERT.
            //
            pundo->ichInsStart = ichInsert;
            pundo->ichInsEnd   = ichInsert + cchInsert;
            pundo->undoType |= UNDO_INSERT;
        }
    } 
    else if (pundo->undoType == UNDO_DELETE) 
    {
        //
        // If there is some Delete Info already present go and handle it.
        //
        goto UNDOINSERT;
    }
}


//---------------------------------------------------------------------------//
//
// Edit_InsertText AorW
//
// Adds cch characters from lpText into the ped->hText starting at
// ped->ichCaret. Returns TRUE if successful else FALSE. Updates
// ped->cchAlloc and ped->cch properly if additional memory was allocated or
// if characters were actually added. Updates ped->ichCaret to be at the end
// of the inserted text. min and maxsel are equal to ichcaret.
//
BOOL Edit_InsertText(PED ped, LPSTR lpText, ICH* pcchInsert)
{
    PSTR pedText;
    PSTR pTextBuff;
    LONG style;
    HANDLE hTextCopy;
    DWORD allocamt;

    //
    // If the last byte (lpText[cchInsert - 1]) is a DBCS leading byte
    // we need to adjust it.
    //
    *pcchInsert = Edit_AdjustIch(ped, lpText, *pcchInsert);

    if (!*pcchInsert)
    {
        return TRUE;
    }

    //
    // Do we already have enough memory??
    //
    if (*pcchInsert >= (ped->cchAlloc - ped->cch)) 
    {
        //
        // Allocate what we need plus a little extra. Return FALSE if we are
        // unsuccessful.
        //
        allocamt = (ped->cch + *pcchInsert) * ped->cbChar;
        allocamt += CCHALLOCEXTRA;

        // if (!ped->fSingle) 
        // {
            hTextCopy = LocalReAlloc(ped->hText, allocamt, LHND);
            if (hTextCopy) 
            {
                ped->hText = hTextCopy;
            } 
            else 
            {
                return FALSE;
            }
        // } 
        // else 
        // {
        // if (!LocalReallocSafe(ped->hText, allocamt, LHND, pped))
        //                return FALSE;
        // }

        ped->cchAlloc = (ICH) LocalSize(ped->hText) / ped->cbChar;
    }

    //
    // Ok, we got the memory. Now copy the text into the structure
    // 
    pedText = Edit_Lock(ped);

    if (ped->pLpkEditCallout) 
    {
        HDC hdc;
        INT iResult;

        hdc = Edit_GetDC(ped, TRUE);
        iResult = ped->pLpkEditCallout->EditVerifyText((PED0)ped, hdc, pedText, ped->ichCaret, lpText, *pcchInsert);
        Edit_ReleaseDC (ped, hdc, TRUE);

        if (iResult == 0) 
        {
            Edit_Unlock (ped);
            return TRUE;
        }
    }

    //
    // Get a pointer to the place where text is to be inserted
    //
    pTextBuff = pedText + ped->ichCaret * ped->cbChar;

    if (ped->ichCaret != ped->cch) 
    {
        //
        // We are inserting text into the middle. We have to shift text to the
        // right before inserting new text.
        //
        memmove(pTextBuff + *pcchInsert * ped->cbChar, pTextBuff, (ped->cch-ped->ichCaret) * ped->cbChar);
    }

    //
    // Make a copy of the text being inserted in the edit buffer.
    // Use this copy for doing UPPERCASE/LOWERCASE ANSI/OEM conversions
    // Fix for Bug #3406 -- 01/29/91 -- SANKAR --
    //
    memmove(pTextBuff, lpText, *pcchInsert * ped->cbChar);
    ped->cch += *pcchInsert;

    //
    // Get the control's style
    //
    style = GET_STYLE(ped);

    //
    // Do the Upper/Lower conversion
    //
    if (style & ES_LOWERCASE) 
    {
        if (ped->fAnsi)
        {
            CharLowerBuffA((LPSTR)pTextBuff, *pcchInsert);
        }
        else
        {
            CharLowerBuffW((LPWSTR)pTextBuff, *pcchInsert);
        }
    } 
    else 
    {
        if (style & ES_UPPERCASE) 
        {
            if (ped->fAnsi) 
            {
                CharUpperBuffA(pTextBuff, *pcchInsert);
            } 
            else 
            {
                CharUpperBuffW((LPWSTR)pTextBuff, *pcchInsert);
            }
        }
    }

    //
    // Do the OEM conversion
    //
    // For backward compatibility with NT4, we don't perform OEM conversion
    // for older apps if the system locale is FarEast.
    //
    if ((style & ES_OEMCONVERT) &&
        (!g_fDBCSEnabled || Is500Compat(UserGetVersion()) || GetOEMCP() != GetACP())) 
    {
        ICH i;

        if (ped->fAnsi) 
        {
            for (i = 0; i < *pcchInsert; i++) 
            {
                //
                // We don't need to call CharToOemBuff etc. if the character
                // is a double byte character.  And, calling Edit_IsDBCSLeadByte is
                // faster and less complicated because we don't have to deal
                // with the 2 byte dbcs cases.
                //
                if (g_fDBCSEnabled && Edit_IsDBCSLeadByte(ped, *(lpText+i))) 
                {
                    i++;
                    continue;
                }

                if (IsCharLowerA(*(pTextBuff + i))) 
                {
                    CharUpperBuffA(pTextBuff + i, 1);
                    CharToOemBuffA(pTextBuff + i, pTextBuff + i, 1);
                    OemToCharBuffA(pTextBuff + i, pTextBuff + i, 1);
                    CharLowerBuffA(pTextBuff + i, 1);
                } 
                else 
                {
                    CharToOemBuffA(pTextBuff + i, pTextBuff + i, 1);
                    OemToCharBuffA(pTextBuff + i, pTextBuff + i, 1);
                }
            }
        } 
        else 
        {
            //
            // Because 'ch' may become DBCS, and have a space for NULL.
            //
            UCHAR ch[4];
            LPWSTR lpTextW = (LPWSTR)pTextBuff;

            for (i = 0; i < *pcchInsert; i++) 
            {
                if (*(lpTextW + i) == UNICODE_CARRIAGERETURN ||
                    *(lpTextW + i) == UNICODE_LINEFEED ||
                    *(lpTextW + i) == UNICODE_TAB) 
                {
                    continue;
                }

                if (IsCharLowerW(*(lpTextW + i))) 
                {
                    CharUpperBuffW(lpTextW + i, 1);

                    //
                    // make sure the null-terminate.
                    //
                    *(LPDWORD)ch = 0;
                    CharToOemBuffW(lpTextW + i, ch, 1);

                    //
                    // We assume any SBCS/DBCS character will converted
                    // to 1 Unicode char, Otherwise, we may overwrite
                    // next character...
                    //
                    OemToCharBuffW(ch, lpTextW + i, strlen(ch));
                    CharLowerBuffW(lpTextW + i, 1);
                }
                else 
                {
                    //
                    // make sure the null-terminate.
                    //
                    *(LPDWORD)ch = 0;
                    CharToOemBuffW(lpTextW + i, ch, 1);

                    //
                    // We assume any SBCS/DBCS character will converted
                    // to 1 Unicode char, Otherwise, we may overwrite
                    // next character...
                    //
                    OemToCharBuffW(ch, lpTextW + i, strlen(ch));
                }
            }
        }
    }

    //
    // Adjust UNDO fields so that we can undo this insert...
    //
    Edit_MergeUndoInsertInfo(Pundo(ped), ped->ichCaret, *pcchInsert);

    ped->ichCaret += *pcchInsert;

    if (ped->pLpkEditCallout) 
    {
        HDC hdc;

        hdc = Edit_GetDC(ped, TRUE);
        ped->ichCaret = ped->pLpkEditCallout->EditAdjustCaret((PED0)ped, hdc, pedText, ped->ichCaret);
        Edit_ReleaseDC (ped, hdc, TRUE);
    }

    ped->ichMinSel = ped->ichMaxSel = ped->ichCaret;

    Edit_Unlock(ped);

    //
    // Set dirty bit
    //
    ped->fDirty = TRUE;

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// Edit_DeleteText AorW
// 
// Deletes the text between ped->ichMinSel and ped->ichMaxSel. The
// character at ichMaxSel is not deleted. But the character at ichMinSel is
// deleted. ped->cch is updated properly and memory is deallocated if enough
// text is removed. ped->ichMinSel, ped->ichMaxSel, and ped->ichCaret are set
// to point to the original ped->ichMinSel. Returns the number of characters
// deleted.
//
ICH Edit_DeleteText(PED ped)
{
    PSTR   pedText;
    ICH    cchDelete;
    LPSTR  lpDeleteSaveBuffer;
    HANDLE hDeletedText;
    DWORD  bufferOffset;

    cchDelete = ped->ichMaxSel - ped->ichMinSel;

    if (cchDelete)
    {

        //
        // Ok, now lets delete the text.
        //
        pedText = Edit_Lock(ped);

        //
        // Adjust UNDO fields so that we can undo this delete...
        //
        if (ped->undoType == UNDO_NONE) 
        {
UNDODELETEFROMSCRATCH:
            if (ped->hDeletedText = GlobalAlloc(GPTR, (LONG)((cchDelete+1)*ped->cbChar))) 
            {
                ped->undoType = UNDO_DELETE;
                ped->ichDeleted = ped->ichMinSel;
                ped->cchDeleted = cchDelete;
                lpDeleteSaveBuffer = ped->hDeletedText;
                RtlCopyMemory(lpDeleteSaveBuffer, pedText + ped->ichMinSel*ped->cbChar, cchDelete*ped->cbChar);
                lpDeleteSaveBuffer[cchDelete*ped->cbChar] = 0;
            }
        } 
        else if (ped->undoType & UNDO_INSERT) 
        {
UNDODELETE:
            Edit_EmptyUndo(Pundo(ped));

            ped->ichInsStart = ped->ichInsEnd = 0xFFFFFFFF;
            ped->ichDeleted = 0xFFFFFFFF;
            ped->cchDeleted = 0;

            goto UNDODELETEFROMSCRATCH;

        } 
        else if (ped->undoType == UNDO_DELETE) 
        {
            if (ped->ichDeleted == ped->ichMaxSel) 
            {
                //
                // Copy deleted text to front of undo buffer
                //
                hDeletedText = GlobalReAlloc(ped->hDeletedText, (LONG)(cchDelete + ped->cchDeleted + 1)*ped->cbChar, GHND);
                if (!hDeletedText)
                {
                    goto UNDODELETE;
                }

                bufferOffset = 0;
                ped->ichDeleted = ped->ichMinSel;

            } 
            else if (ped->ichDeleted == ped->ichMinSel) 
            {
                //
                // Copy deleted text to end of undo buffer
                //
                hDeletedText = GlobalReAlloc(ped->hDeletedText, (LONG)(cchDelete + ped->cchDeleted + 1)*ped->cbChar, GHND);
                if (!hDeletedText)
                {
                    goto UNDODELETE;
                }

                bufferOffset = ped->cchDeleted*ped->cbChar;

            } 
            else 
            {
                //
                // Clear the current UNDO delete and add the new one since
                // the deletes aren't contiguous.
                //
                goto UNDODELETE;
            }

            ped->hDeletedText = hDeletedText;
            lpDeleteSaveBuffer = (LPSTR)hDeletedText;

            if (!bufferOffset) 
            {
                //
                // Move text in delete buffer up so that we can insert the next
                // text at the head of the buffer.
                //
                RtlMoveMemory(lpDeleteSaveBuffer + cchDelete*ped->cbChar, lpDeleteSaveBuffer, ped->cchDeleted*ped->cbChar);
            }

            RtlCopyMemory(lpDeleteSaveBuffer + bufferOffset, pedText + ped->ichMinSel*ped->cbChar, cchDelete*ped->cbChar);

            lpDeleteSaveBuffer[(ped->cchDeleted + cchDelete)*ped->cbChar] = 0;
            ped->cchDeleted += cchDelete;
        }

        if (ped->ichMaxSel != ped->cch) 
        {
            //
            // We are deleting text from the middle of the buffer so we have to
            // shift text to the left.
            //
            RtlMoveMemory(pedText + ped->ichMinSel*ped->cbChar, pedText + ped->ichMaxSel*ped->cbChar, (ped->cch - ped->ichMaxSel)*ped->cbChar);
        }

        if (ped->cchAlloc - ped->cch > CCHALLOCEXTRA) 
        {
            //
            // Free some memory since we deleted a lot
            //
            LocalReAlloc(ped->hText, (DWORD)(ped->cch + (CCHALLOCEXTRA / 2))*ped->cbChar, LHND);
            ped->cchAlloc = (ICH)LocalSize(ped->hText) / ped->cbChar;
        }

        ped->cch -= cchDelete;

        if (ped->pLpkEditCallout) 
        {
            HDC hdc;

            hdc = Edit_GetDC(ped, TRUE);
            ped->ichMinSel = ped->pLpkEditCallout->EditAdjustCaret((PED0)ped, hdc, pedText, ped->ichMinSel);
            Edit_ReleaseDC(ped, hdc, TRUE);
        }

        ped->ichCaret = ped->ichMaxSel = ped->ichMinSel;

        Edit_Unlock(ped);

        //
        // Set dirty bit
        //
        ped->fDirty = TRUE;

    }

    return cchDelete;
}


//---------------------------------------------------------------------------//
//
// Edit_NotifyParent AorW
// 
// Sends the notification code to the parent of the edit control
//
VOID Edit_NotifyParent(PED ped, INT notificationCode)
{
    //
    // wParam is NotificationCode (hiword) and WindowID (loword)
    // lParam is HWND of control sending the message
    // Windows 95 checks for hwndParent != NULL before sending the message, but
    // this is surely rare, and SendMessage NULL hwnd does nowt anyway (IanJa)
    //
    SendMessage(ped->hwndParent, WM_COMMAND,
            (DWORD)MAKELONG(GetWindowID(ped->hwnd), notificationCode),
            (LPARAM)ped->hwnd);
}


//---------------------------------------------------------------------------//
//
// Edit_SetClip AorW
// 
// Sets the clip rect for the hdc to the formatting rectangle intersected
// with the client area.
//
VOID Edit_SetClip(PED ped, HDC hdc, BOOL fLeftMargin)
{
    RECT rcClient;
    RECT rcClip;
    INT  cxBorder;
    INT  cyBorder;

    CopyRect(&rcClip, &ped->rcFmt);

    if (ped->pLpkEditCallout) 
    {
        //
        // Complex script handling chooses whether to write margins later
        //
        rcClip.left  -= ped->wLeftMargin;
        rcClip.right += ped->wRightMargin;
    } 
    else 
    {
        //
        // Should we consider the left margin?
        //
        if (fLeftMargin)
        {
            rcClip.left -= ped->wLeftMargin;
        }

        //
        // Should we consider the right margin?
        //
        if (ped->fWrap)
        {
            rcClip.right += ped->wRightMargin;
        }
    }

    //
    // Set clip rectangle to rectClient intersect rectClip
    // We must clip for single line edits also. -- B#1360
    //
    GetClientRect(ped->hwnd, &rcClient);
    if (ped->fFlatBorder)
    {
        cxBorder = GetSystemMetrics(SM_CXBORDER);
        cyBorder = GetSystemMetrics(SM_CYBORDER);
        InflateRect(&rcClient, cxBorder, cyBorder);
    }

    IntersectRect(&rcClient, &rcClient, &rcClip);
    IntersectClipRect(hdc,rcClient.left, rcClient.top,
            rcClient.right, rcClient.bottom);
}


//---------------------------------------------------------------------------//
//
// Edit_GetDC AorW
//
// Hides the caret, gets the DC for the edit control, and clips to
// the rcFmt rectangle specified for the edit control and sets the proper
// font. If fFastDC, just select the proper font but don't bother about clip
// regions or hiding the caret.
//
HDC Edit_GetDC(PED ped, BOOL fFastDC)
{
    HDC hdc;

    if (!fFastDC)
    {
        HideCaret(ped->hwnd);
    }

    hdc = GetDC(ped->hwnd);
    if (hdc != NULL) 
    {
        Edit_SetClip(ped, hdc, (BOOL)(ped->xOffset == 0));

        //
        // Select the proper font for this edit control's dc.
        //
        if (ped->hFont)
        {
            SelectObject(hdc, ped->hFont);
        }
    }

    return hdc;
}


//---------------------------------------------------------------------------//
//
// Edit_ReleaseDC AorW
// 
// Releases the DC (hdc) for the edit control and shows the caret.
// If fFastDC, just select the proper font but don't bother about showing the
// caret.
//
VOID Edit_ReleaseDC(PED ped, HDC hdc, BOOL fFastDC)
{
    //
    // Restoring font not necessary
    //
    ReleaseDC(ped->hwnd, hdc);

    if (!fFastDC)
    {
        ShowCaret(ped->hwnd);
    }
}


//---------------------------------------------------------------------------//
//
// Edit_ResetTextInfo() AorW
//
// Handles a global change to the text by resetting text offsets, emptying
// the undo buffer, and rebuilding the lines
//
VOID Edit_ResetTextInfo(PED ped)
{
    //
    // Reset caret, selections, scrolling, and dirty information.
    //
    ped->iCaretLine = ped->ichCaret = 0;
    ped->ichMinSel = ped->ichMaxSel = 0;
    ped->xOffset = ped->ichScreenStart = 0;
    ped->fDirty = FALSE;

    Edit_EmptyUndo(Pundo(ped));

    if (ped->fSingle) 
    {
        if (!ped->listboxHwnd)
        {
            Edit_NotifyParent(ped, EN_UPDATE);
        }
    } 
    else 
    {
        EditML_BuildchLines(ped, 0, 0, FALSE, NULL, NULL);
    }

    if (IsWindowVisible(ped->hwnd)) 
    {
        BOOL fErase;

        if (ped->fSingle)
        {
            fErase = FALSE;
        }
        else
        {
            fErase = ((ped->ichLinesOnScreen + ped->ichScreenStart) >= ped->cLines);
        }

        //
        // Always redraw whether or not the insert was successful.  We might
        // have NULL text.  Paint() will check the redraw flag for us.
        //
        Edit_InvalidateClient(ped, fErase);

        //
        // BACKWARD COMPAT HACK: RAID expects the text to have been updated,
        // so we have to do an UpdateWindow here.  It moves an edit control
        // around with fRedraw == FALSE, so it'll never get the paint message
        // with the control in the right place.
        //
        if (!ped->fWin31Compat)
        {
            UpdateWindow(ped->hwnd);
        }
    }

    if (ped->fSingle && !ped->listboxHwnd)
    {
        Edit_NotifyParent(ped, EN_CHANGE);
    }

    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
}


//---------------------------------------------------------------------------//
//
// Edit_SetEditText AorW
// 
// Copies the null terminated text in lpstr to the ped. Notifies the
// parent if there isn't enough memory. Sets the minsel, maxsel, and caret to
// the beginning of the inserted text. Returns TRUE if successful else FALSE
// if no memory (and notifies the parent).
//
BOOL Edit_SetEditText(PED ped, LPSTR lpstr)
{
    ICH cchLength;
    ICH cchSave = ped->cch;
    ICH ichCaretSave = ped->ichCaret;
    HWND hwndSave    = ped->hwnd;
    HANDLE hText;

    ped->cch = ped->ichCaret = 0;

    ped->cchAlloc = (ICH)LocalSize(ped->hText) / ped->cbChar;
    if (!lpstr) 
    {
        hText = LocalReAlloc(ped->hText, CCHALLOCEXTRA*ped->cbChar, LHND);
        if (hText != NULL) 
        {
            ped->hText = hText;
        } 
        else 
        {
            return FALSE;
        }
    } 
    else 
    {
        cchLength = (ped->fAnsi ? strlen((LPSTR)lpstr) : wcslen((LPWSTR)lpstr));

        //
        // Add the text
        //
        if (cchLength && !Edit_InsertText(ped, lpstr, &cchLength)) 
        {
            //
            // Restore original state and notify parent we ran out of memory.
            //
            ped->cch = cchSave;
            ped->ichCaret = ichCaretSave;
            Edit_NotifyParent(ped, EN_ERRSPACE);
            return FALSE;
        }
    }

    ped->cchAlloc = (ICH)LocalSize(ped->hText) / ped->cbChar;

    if (IsWindow(hwndSave))
    {
        Edit_ResetTextInfo(ped);
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// Edit_InvalidateClient()
//
// Invalidates client of edit field.  For old 3.x guys with borders,
// we draw it ourself (compatibility).  So we don't want to invalidate
// the border or we'll get flicker.
//
VOID Edit_InvalidateClient(PED ped, BOOL fErase)
{
    if (ped->fFlatBorder) 
    {
        RECT rcT;
        INT  cxBorder;
        INT  cyBorder;

        GetClientRect(ped->hwnd, &rcT);
        cxBorder = GetSystemMetrics(SM_CXBORDER);
        cyBorder = GetSystemMetrics(SM_CYBORDER);
        InflateRect(&rcT, cxBorder, cyBorder);
        InvalidateRect(ped->hwnd, &rcT, fErase);
    } 
    else 
    {
        InvalidateRect(ped->hwnd, NULL, fErase);
    }
}


//---------------------------------------------------------------------------//
//
// Edit_Copy AorW
// 
// Copies the text between ichMinSel and ichMaxSel to the clipboard.
// Returns the number of characters copied.
// 
ICH Edit_Copy(PED ped)
{
    HANDLE hData;
    char *pchSel;
    char *lpchClip;
    ICH cbData;

    //
    // Don't allow copies from password style controls
    //
    if (ped->charPasswordChar) 
    {

        Edit_ShowBalloonTipWrap(ped->hwnd, IDS_PASSWORDCUT_TITLE, IDS_PASSWORDCUT_MSG, TTI_ERROR);
        MessageBeep(0);

        return 0;
    }

    cbData = (ped->ichMaxSel - ped->ichMinSel) * ped->cbChar;

    if (!cbData)
    {
        return 0;
    }

    if (!OpenClipboard(ped->hwnd))
    {
        return 0;
    }

    EmptyClipboard();

    hData = GlobalAlloc(LHND, (LONG)(cbData + ped->cbChar));
    if (!hData) 
    {
        CloseClipboard();
        return 0;
    }

    lpchClip = GlobalLock(hData);
    UserAssert(lpchClip);
    pchSel = Edit_Lock(ped);
    pchSel = pchSel + (ped->ichMinSel * ped->cbChar);

    RtlCopyMemory(lpchClip, pchSel, cbData);

    if (ped->fAnsi)
    {
        *(lpchClip + cbData) = 0;
    }
    else
    {
        *(LPWSTR)(lpchClip + cbData) = (WCHAR)0;
    }

    Edit_Unlock(ped);
    GlobalUnlock(hData);

    SetClipboardData(ped->fAnsi ? CF_TEXT : CF_UNICODETEXT, hData);

    CloseClipboard();

    return cbData;
}


//---------------------------------------------------------------------------//
LRESULT Edit_TrackBalloonTip(PED ped)
{
    if (ped->hwndBalloon)
    {
        DWORD dwPackedCoords;
        HDC   hdc = Edit_GetDC(ped, TRUE);
        RECT  rcWindow;
        POINT pt;
        int   cxCharOffset = TESTFLAG(GET_EXSTYLE(ped), WS_EX_RTLREADING) ? -ped->aveCharWidth : ped->aveCharWidth;

        //
        // Get the caret position
        //
        if (ped->fSingle)
        {
            pt.x = EditSL_IchToLeftXPos(ped, hdc, ped->ichCaret) + cxCharOffset;
            pt.y = ped->rcFmt.bottom;
        }
        else
        {
            EditML_IchToXYPos(ped, hdc, ped->ichCaret, FALSE, &pt);
            pt.x += cxCharOffset;
            pt.y += ped->lineHeight;
        }

        //
        // Translate to window coords
        //
        GetWindowRect(ped->hwnd, &rcWindow);
        pt.x += rcWindow.left;
        pt.y += rcWindow.top;

        //
        // Position the tip stem at the caret position
        //
        dwPackedCoords = (DWORD) MAKELONG(pt.x, pt.y);
        SendMessage(ped->hwndBalloon, TTM_TRACKPOSITION, 0, (LPARAM) dwPackedCoords);

        Edit_ReleaseDC(ped, hdc, TRUE);

        return 1;
    }

    return 0;
}


//---------------------------------------------------------------------------//
LRESULT CALLBACK Edit_BalloonTipParentSubclassProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData)
{
    PED ped = (PED)dwRefData;
    switch (uMessage)
    {
    case WM_MOVE:
    case WM_SIZING:
        //
        // dismiss any showing tips
        //
        Edit_HideBalloonTip(ped->hwnd);

        break;

    case WM_DESTROY:
        // Clean up subclass
        RemoveWindowSubclass(hDlg, Edit_BalloonTipParentSubclassProc, (UINT_PTR) ped->hwnd);
        break;

    default:
        break;
    }

    return DefSubclassProc(hDlg, uMessage, wParam, lParam);
}


//---------------------------------------------------------------------------//
LRESULT Edit_BalloonTipSubclassParents(PED ped)
{
    // Subclass all windows along the parent chain from the edit control
    // and in the same thread (can only subclass windows with same thread affinity)
    HWND  hwndParent = GetAncestor(ped->hwnd, GA_PARENT);
    DWORD dwTid      = GetWindowThreadProcessId(ped->hwnd, NULL);

    while (hwndParent && (dwTid == GetWindowThreadProcessId(hwndParent, NULL)))
    {
        SetWindowSubclass(hwndParent, Edit_BalloonTipParentSubclassProc, (UINT_PTR)ped->hwnd, (DWORD_PTR)ped);
        hwndParent = GetAncestor(hwndParent, GA_PARENT);
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
HWND Edit_BalloonTipRemoveSubclasses(PED ped)
{
    HWND  hwndParent  = GetAncestor(ped->hwnd, GA_PARENT);
    HWND  hwndTopMost = NULL;
    DWORD dwTid       = GetWindowThreadProcessId(ped->hwnd, NULL);

    while (hwndParent && (dwTid == GetWindowThreadProcessId(hwndParent, NULL)))
    {
        RemoveWindowSubclass(hwndParent, Edit_BalloonTipParentSubclassProc, (UINT_PTR) ped->hwnd);
        hwndTopMost = hwndParent;
        hwndParent = GetAncestor(hwndParent, GA_PARENT);
    }

    return hwndTopMost;
}


//---------------------------------------------------------------------------//
LRESULT Edit_HideBalloonTipHandler(PED ped)
{
    if (ped->hwndBalloon)
    {
        HWND hwndParent;

        KillTimer(ped->hwnd, ID_EDITTIMER);

        SendMessage(ped->hwndBalloon, TTM_TRACKACTIVATE, FALSE, 0);
        DestroyWindow(ped->hwndBalloon);

        ped->hwndBalloon = NULL;

        hwndParent = Edit_BalloonTipRemoveSubclasses(ped);

        if (hwndParent && IsWindow(hwndParent))
        {
            InvalidateRect(hwndParent, NULL, TRUE);
            UpdateWindow(hwndParent);
        }

        if (hwndParent != ped->hwnd)
        {
            RedrawWindow(ped->hwnd, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
        }
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
__inline LRESULT Edit_ShowBalloonTipWrap(HWND hwnd, DWORD dwTitleId, DWORD dwMsgId, DWORD dwIconId)
{
    WCHAR szTitle[56];
    WCHAR szMsg[MAX_PATH];
    EDITBALLOONTIP ebt;

    LoadString(HINST_THISDLL, dwTitleId, szTitle, ARRAYSIZE(szTitle));
    LoadString(HINST_THISDLL, dwMsgId,   szMsg,   ARRAYSIZE(szMsg));

    ebt.cbStruct = sizeof(ebt);
    ebt.pszTitle = szTitle;
    ebt.pszText  = szMsg;
    ebt.ttiIcon  = dwIconId;

    return Edit_ShowBalloonTip(hwnd, &ebt);
}


//---------------------------------------------------------------------------//
LRESULT Edit_ShowBalloonTipHandler(PED ped, PEDITBALLOONTIP pebt)
{
    LRESULT lResult = FALSE;

    Edit_HideBalloonTipHandler(ped);

    if (sizeof(EDITBALLOONTIP) == pebt->cbStruct)
    {
        ped->hwndBalloon = CreateWindowEx(
                                (IS_BIDI_LOCALIZED_SYSTEM() ? WS_EX_LAYOUTRTL : 0), 
                                TOOLTIPS_CLASS, NULL,
                                WS_POPUP | TTS_NOPREFIX | TTS_BALLOON,
                                CW_USEDEFAULT, CW_USEDEFAULT,
                                CW_USEDEFAULT, CW_USEDEFAULT,
                                ped->hwnd, NULL, g_hinst,
                                NULL);

        if (NULL != ped->hwndBalloon)
        {
            TOOLINFO ti = {0};

            ti.cbSize = TTTOOLINFOW_V2_SIZE;
            ti.uFlags = TTF_IDISHWND | TTF_TRACK;
            ti.hwnd   = ped->hwnd;
            ti.uId    = (WPARAM)1;
            ti.lpszText = (LPWSTR)pebt->pszText;

            SendMessage(ped->hwndBalloon, TTM_ADDTOOL, 0, (LPARAM)&ti);
            SendMessage(ped->hwndBalloon, TTM_SETMAXTIPWIDTH, 0, 300);
            SendMessage(ped->hwndBalloon, TTM_SETTITLE, (WPARAM) pebt->ttiIcon, (LPARAM)pebt->pszTitle);

            Edit_TrackBalloonTip(ped);

            SendMessage(ped->hwndBalloon, TTM_TRACKACTIVATE, (WPARAM) TRUE, (LPARAM)&ti);

            SetFocus(ped->hwnd);

            Edit_BalloonTipSubclassParents(ped);

            //
            // set timeout to kill the tip
            //
            KillTimer(ped->hwnd, ID_EDITTIMER);
            SetTimer(ped->hwnd, ID_EDITTIMER, EDIT_TIPTIMEOUT, NULL);

            lResult = TRUE;
        }
    }

    return lResult;
}


//---------------------------------------------------------------------------//
BOOL Edit_ClientEdgePaint(PED ped, HRGN hRgnUpdate)
{
    HDC  hdc;
    BOOL bRet = FALSE;

    hdc = (hRgnUpdate != NULL) ? 
            GetDCEx(ped->hwnd, 
                    hRgnUpdate, 
                    DCX_USESTYLE | DCX_WINDOW | DCX_LOCKWINDOWUPDATE | DCX_INTERSECTRGN | DCX_NODELETERGN) :
            GetDCEx(ped->hwnd, 
                    NULL, 
                    DCX_USESTYLE | DCX_WINDOW | DCX_LOCKWINDOWUPDATE);

    if (hdc)
    {
        HBRUSH hbr;
        BOOL fDeleteBrush = FALSE;

        hbr = Edit_GetBrush(ped, hdc, &fDeleteBrush);

        if (hbr)
        {
            RECT rc;
            HRGN hrgn;
            INT  iStateId = Edit_GetStateId(ped);
            INT  cxBorder = 0, cyBorder = 0;

            if (SUCCEEDED(GetThemeInt(ped->hTheme, EP_EDITTEXT, iStateId, TMT_SIZINGBORDERWIDTH, &cxBorder)))
            {
                cyBorder = cxBorder;
            }
            else
            {
                cxBorder = g_cxBorder;
                cyBorder = g_cyBorder;
            }

            GetWindowRect(ped->hwnd, &rc);            

            //
            // Create an update region without the client edge
            // to pass to DefWindowProc
            //
            InflateRect(&rc, -g_cxEdge, -g_cyEdge);
            hrgn = CreateRectRgn(rc.left, rc.top, rc.right, rc.bottom);
            if (hRgnUpdate != NULL)
            {
                CombineRgn(hrgn, hRgnUpdate, hrgn, RGN_AND);
            }

            //
            // Zero-origin the rect
            //
            OffsetRect(&rc, -rc.left, -rc.top);

            //
            // clip our drawing to the non-client edge
            //
            OffsetRect(&rc, g_cxEdge, g_cyEdge);
            ExcludeClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
            InflateRect(&rc, g_cxEdge, g_cyEdge);

            DrawThemeBackground(ped->hTheme, hdc, EP_EDITTEXT, iStateId, &rc, 0);

            //
            // Fill with the control's brush first since the ThemeBackground
            // border may not be as thick as the client edge
            //
            if ((cxBorder < g_cxEdge) && (cyBorder < g_cyEdge))
            {
                InflateRect(&rc, cxBorder-g_cxEdge, cyBorder-g_cyEdge);
                FillRect(hdc, &rc, hbr);
            }

            DefWindowProc(ped->hwnd, WM_NCPAINT, (WPARAM)hrgn, 0);

            DeleteObject(hrgn);

            if (fDeleteBrush)
            {
                DeleteObject(hbr);
            }

            bRet = TRUE;
        }

        ReleaseDC(ped->hwnd, hdc);
    }

    return bRet;
}


//---------------------------------------------------------------------------//
//
// Edit_WndProc
//
// WndProc for all edit controls.
// Dispatches all messages to the appropriate handlers which are named
// as follows:
//     EditSL_ (single line) prefixes all single line edit control 
//     EditML_ (multi line) prefixes all multi- line edit controls
//     Edit_   (edit control) prefixes all common handlers
//
// The Edit_WndProc only handles messages common to both single and multi
// line edit controls. Messages which are handled differently between
// single and multi are sent to EditSL_WndProc or EditML_WndProc.
//
LRESULT Edit_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PED     ped;
    LRESULT lResult;

    //
    // Get the instance data for this edit control
    //
    ped = Edit_GetPtr(hwnd);
    if (!ped && uMsg != WM_NCCREATE)
    {
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    //
    // Dispatch the various messages we can receive
    //
    lResult = 1L;
    switch (uMsg) 
    {

    //
    // Messages which are handled the same way for both single and multi line
    // edit controls.
    //
    case WM_KEYDOWN:
        //
        // LPK handling of Ctrl/LShift, Ctrl/RShift
        //
        if (ped && ped->pLpkEditCallout && ped->fAllowRTL) 
        {
            //
            // Any keydown cancels a ctrl/shift reading order change
            //
            ped->fSwapRoOnUp = FALSE; 

            switch (wParam) 
            {
            case VK_SHIFT:

                if ((GetKeyState(VK_CONTROL) & 0x8000) && !(GetKeyState(VK_MENU) & 0x8000)) 
                {
                    //
                    // Left shift or right shift pressed while control held down
                    // Check that alt (VK_MENU) isn't down to avoid false firing 
                    // on AltGr which equals Ctrl+Alt.
                    //
                    if (MapVirtualKey((LONG)lParam>>16&0xff, 3) == VK_LSHIFT) 
                    {

                        //
                        // User wants left to right reading order
                        //
                        ped->fSwapRoOnUp = (ped->fRtoLReading) || (ped->format & ES_RIGHT);
                        ped->fLShift = TRUE;

                    } 
                    else 
                    {
                        //
                        // User wants right to left reading order
                        //
                        ped->fSwapRoOnUp = (!ped->fRtoLReading) || (ped->format & ES_RIGHT);
                        ped->fLShift = FALSE;

                    }
                }

                break;

            case VK_LEFT:

                if (ped->fRtoLReading) 
                {
                   wParam = VK_RIGHT;
                }

                break;

            case VK_RIGHT:

                if (ped->fRtoLReading) 
                {
                    wParam = VK_LEFT;
                }
                break;
            }
        }

        goto HandleEditMsg;

    case WM_KEYUP:

        if (ped && ped->pLpkEditCallout && ped->fAllowRTL && ped->fSwapRoOnUp) 
        {
            BOOL fReadingOrder;
            //
            // Complete reading order change detected earlier during keydown
            //

            ped->fSwapRoOnUp = FALSE;
            fReadingOrder = ped->fRtoLReading;

            //
            // Remove any overriding ES_CENTRE or ES_RIGHT format from dwStyle
            //
            SetWindowLong(hwnd, GWL_STYLE, (GET_STYLE(ped) & ~ES_FMTMASK));

            if (ped->fLShift) 
            {
                // 
                // Set Left to Right reading order and right scrollbar in EX_STYLE
                //
                SetWindowLong(hwnd, GWL_EXSTYLE, (GET_EXSTYLE(ped) & ~(WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR)));

                //
                // Edit control is LTR now, then notify the parent.
                //
                Edit_NotifyParent(ped, EN_ALIGN_LTR_EC);

                //
                // ? Select a keyboard layout appropriate to LTR operation
                //
            } 
            else 
            {
                //
                // Set Right to Left reading order, right alignment and left scrollbar
                //
                SetWindowLong(hwnd, 
                              GWL_EXSTYLE, 
                              GET_EXSTYLE(ped) | WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR);

                //
                // Edit control is RTL now, then notify the parent.
                //
                Edit_NotifyParent(ped, EN_ALIGN_RTL_EC);

                //
                // ? Select a keyboard layout appropriate to RTL operation
                //
            }

            //
            // If reading order didn't change, so we are sure the alignment 
            // changed and the edit window didn't invalidate yet.
            //

            if (fReadingOrder == (BOOL) ped->fRtoLReading) 
            {
              Edit_InvalidateClient(ped, TRUE);
            }
        }

        goto HandleEditMsg;

    case WM_INPUTLANGCHANGE:

        if (ped) 
        {
            //
            // EC_INSERT_COMPOSITION_CHAR : WM_INPUTLANGCHANGE - call Edit_InitInsert()
            //
            HKL hkl = GetKeyboardLayout(0);

            Edit_InitInsert(ped, hkl);

            if (ped->fInReconversion) 
            {
                Edit_InOutReconversionMode(ped, FALSE);
            }

            //
            // Font and caret position might be changed while
            // another keyboard layout is active. Set those
            // if the edit control has the focus.
            //
            if (ped->fFocus && ImmIsIME(hkl)) 
            {
                POINT pt;

                Edit_SetCompositionFont(ped);
                GetCaretPos(&pt);
                Edit_ImmSetCompositionWindow(ped, pt.x, pt.y);
            }
        }

        goto HandleEditMsg;

    case WM_COPY:

        //
        // wParam - not used
        // lParam - not used
        //
        lResult = (LONG)Edit_Copy(ped);

        break;

    case WM_CUT:

        //
        // wParam -- not used
        // lParam -- not used
        //
        Edit_CutText(ped);
        lResult = 0;

        break;

    case WM_CLEAR:

        //
        // wParam - not used
        // lParam - not used
        //
        Edit_ClearText(ped);
        lResult = 0;

        break;

    case WM_ENABLE:

        //
        // wParam - nonzero if window is enabled else disable window if 0.
        // lParam - not used
        //
        ped->fDisabled = !((BOOL)wParam);
        CCInvalidateFrame(hwnd);
        Edit_InvalidateClient(ped, TRUE);
        lResult = (LONG)ped->fDisabled;

        break;

    case WM_SYSCHAR:

        //
        // wParam - key value
        // lParam - not used
        //

        //
        // If this is a WM_SYSCHAR message generated by the UNDO
        // keystroke we want to EAT IT
        //
        if ((lParam & SYS_ALTERNATE) && 
            ((WORD)wParam == VK_BACK))
        {
            lResult = TRUE;
        }
        else 
        {
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
        }

        break;

    case EM_GETLINECOUNT:

        //
        // wParam - not used
        // lParam - not used
        //
        lResult = (LONG)ped->cLines;

        break;

    case EM_GETMODIFY:

        //
        // wParam - not used
        // lParam - not used
        //

        //
        // Gets the state of the modify flag for this edit control.
        //
        lResult = (LONG)ped->fDirty;

        break;

    case EM_SETMODIFY:

        //
        // wParam - specifies the new value for the modify flag
        // lParam - not used
        //

        //
        // Sets the state of the modify flag for 
        // this edit control.
        //
        ped->fDirty = (wParam != 0);

        break;

    case EM_GETRECT:

        //
        // wParam - not used
        // lParam - pointer to a RECT data structure that gets the dimensions.
        //

        //
        // Copies the rcFmt rect to *lpRect.
        //
        CopyRect((LPRECT)lParam, (LPRECT)&ped->rcFmt);
        lResult = (LONG)TRUE;

        break;

    case WM_GETFONT:

        //
        // wParam - not used
        // lParam - not used
        //
        lResult = (LRESULT)ped->hFont;

        break;

    case WM_SETFONT:

        //
        // wParam - handle to the font
        // lParam - redraw if true else don't
        //
        Edit_SetFont(ped, (HANDLE)wParam, (BOOL)LOWORD(lParam));

        break;

    case WM_GETTEXT:

        //
        // wParam - max number of _bytes_ (not characters) to copy
        // lParam - buffer to copy text to. Text is 0 terminated.
        //
        lResult = (LRESULT)Edit_GetTextHandler(ped, (ICH)wParam, (LPSTR)lParam, TRUE);
        break;

    case WM_SETTEXT:

        //
        // wParam - not used
        // lParam - LPSTR, null-terminated, with new text.
        //
        lResult = (LRESULT)Edit_SetEditText(ped, (LPSTR)lParam);
        break;

    case WM_GETTEXTLENGTH:

        //
        // Return count of CHARs!!!
        //
        lResult = (LONG)ped->cch;

        break;

    case WM_DESTROY:
        //
        // Make sure we unsubclass for the balloon tip, if appropriate
        //
        lResult = Edit_HideBalloonTipHandler(ped);
        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:

        //
        // wParam - not used
        // lParam - not used
        //
        Edit_NcDestroyHandler(hwnd, ped);
        lResult = 0;

        break;

    case WM_RBUTTONDOWN:

        //
        // Most apps (i.e. everyone but Quicken) don't pass on the rbutton
        // messages when they do something with 'em inside of subclassed
        // edit fields.  As such, we keep track of whether we saw the
        // down before the up.  If we don't see the up, then DefWindowProc
        // won't generate the context menu message, so no big deal.  If
        // we didn't see the down, then don't let WM_CONTEXTMENU do
        // anything.
        //
        // We also might want to not generate WM_CONTEXTMENUs for old
        // apps when the mouse is captured.
        //
        ped->fSawRButtonDown = TRUE;

        goto HandleEditMsg;

    case WM_RBUTTONUP:
        if (ped->fSawRButtonDown) 
        {
            ped->fSawRButtonDown = FALSE;

            if (!ped->fInReconversion) 
            {
                goto HandleEditMsg;
            }
        }

        //
        // Don't pass this on to DWP so WM_CONTEXTMENU isn't generated.
        //
        lResult = 0;

        break;

    case WM_CONTEXTMENU: 
    {
        POINT pt;
        INT   nHit = (INT)DefWindowProc(hwnd, WM_NCHITTEST, 0, lParam);

        if ((nHit == HTVSCROLL) || (nHit == HTHSCROLL)) 
        {
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
        else
        {
            POINTSTOPOINT(pt, lParam);

            if (!TESTFLAG(GET_STATE2(ped), WS_S2_OLDUI) && Edit_IsAncestorActive(hwnd))
            {
                Edit_Menu(hwnd, ped, &pt);
            }

            lResult = 0;
        }

        break;
    }

    case EM_CANUNDO:

        //
        // wParam - not used
        // lParam - not used
        //
        lResult = (LONG)(ped->undoType != UNDO_NONE);
        break;

    case EM_EMPTYUNDOBUFFER:

        //
        // wParam - not used
        // lParam - not used
        //
        Edit_EmptyUndo(Pundo(ped));

        break;

    case EM_GETMARGINS:

        //
        // wParam - not used
        // lParam - not used
        //
        lResult = MAKELONG(ped->wLeftMargin, ped->wRightMargin);

        break;

    case EM_SETMARGINS:

        //
        // wParam - EC_ margin flags
        // lParam - LOWORD is left, HIWORD is right margin
        //
        Edit_SetMargin(ped, (UINT)wParam, (DWORD)lParam, TRUE);
        lResult = 0;

        break;

    case EM_GETSEL:

        //
        // Gets the selection range for the given edit control. The
        // starting position is in the low order word. It contains the position
        // of the first nonselected character after the end of the selection in
        // the high order word.
        //
        if ((PDWORD)wParam != NULL) 
        {
           *((PDWORD)wParam) = ped->ichMinSel;
        }

        if ((PDWORD)lParam != NULL) 
        {
           *((PDWORD)lParam) = ped->ichMaxSel;
        }

        lResult = MAKELONG(ped->ichMinSel,ped->ichMaxSel);

        break;

    case EM_GETLIMITTEXT:

        //
        // wParam - not used
        // lParam - not used
        //
        lResult = ped->cchTextMax;

        break;

    case EM_SETLIMITTEXT:
    
        //
        // wParam - max number of CHARACTERS that can be entered
        // lParam - not used
        //

        //
        // Specifies the maximum number of characters of text the user may
        // enter. If maxLength is 0, we may enter MAXINT number of CHARACTERS.
        //
        if (ped->fSingle) 
        {
            if (wParam) 
            {
                wParam = min(0x7FFFFFFEu, wParam);
            } 
            else 
            {
                wParam = 0x7FFFFFFEu;
            }
        }

        if (wParam) 
        {
            ped->cchTextMax = (ICH)wParam;
        } 
        else 
        {
            ped->cchTextMax = 0xFFFFFFFFu;
        }

        break;

    case EM_POSFROMCHAR:

        //
        // Validate that char index is within text range
        //

        if (wParam >= ped->cch) 
        {
            lResult = -1L;
        }
        else
        {
            goto HandleEditMsg;
        }

        break;

    case EM_CHARFROMPOS: 
    {
        //
        // Validate that point is within client of edit field
        //
        RECT    rc;
        POINT   pt;

        POINTSTOPOINT(pt, lParam);
        GetClientRect(hwnd, &rc);
        if (!PtInRect(&rc, pt)) 
        {
            lResult = -1L;
        }
        else
        {
            goto HandleEditMsg;
        }

        break;
    }

    case EM_SETPASSWORDCHAR:

        //
        // wParam - sepecifies the new char to display instead of the
        // real text. if null, display the real text.
        //
        Edit_SetPasswordCharHandler(ped, (UINT)wParam);

        break;

    case EM_GETPASSWORDCHAR:

        lResult = (DWORD)ped->charPasswordChar;

        break;

    case EM_SETREADONLY:

        //
        // wParam - state to set read only flag to
        //
        ped->fReadOnly = (wParam != 0);
        if (wParam)
        {
            SetWindowState(hwnd, ES_READONLY);
        }
        else
        {
            ClearWindowState(hwnd, ES_READONLY);
        }

        lResult = 1L;

        if ( g_fIMMEnabled )
        {
            Edit_EnableDisableIME( ped );
        }

        //
        // We need to redraw the edit field so that the background color
        // changes.  Read-only edits are drawn in CTLCOLOR_STATIC while
        // others are drawn with CTLCOLOR_EDIT.
        //
        Edit_InvalidateClient(ped, TRUE);

        break;

    case EM_SETWORDBREAKPROC:

        // wParam - not used
        // lParam - PROC address of an app supplied call back function
        ped->lpfnNextWord = (EDITWORDBREAKPROCA)lParam;

        break;

    case EM_GETWORDBREAKPROC:

        lResult = (LRESULT)ped->lpfnNextWord;

        break;

    case EM_GETIMESTATUS:

        //
        // wParam == sub command
        //
        if (wParam == EMSIS_COMPOSITIONSTRING)
        {
            lResult = ped->wImeStatus;
        }

        break;

    case EM_SETIMESTATUS:

        //
        // wParam == sub command
        //
        if (wParam == EMSIS_COMPOSITIONSTRING) 
        {
            ped->wImeStatus = (WORD)lParam;
        }

        break;

    case WM_NCCREATE:

        ped = (PED)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(ED));
        if (ped)
        {
            //
            // Success... store the instance pointer.
            //
            TraceMsg(TF_STANDARD, "EDIT: Setting edit instance pointer.");
            Edit_SetPtr(hwnd, ped);

            lResult = Edit_NcCreate(ped, hwnd, (LPCREATESTRUCT)lParam);
        }
        else
        {
            //
            // Failed... return FALSE.
            //
            // From a WM_NCCREATE msg, this will cause the
            // CreateWindow call to fail.
            //
            TraceMsg(TF_STANDARD, "EDIT: Unable to allocate edit instance structure.");
            lResult = FALSE;
        }
        break;

    case WM_LBUTTONDOWN:

        //
        // B#3623
        // Don't set focus to edit field if it is within an inactive,
        // captioned child.
        // We might want to version switch this...  I haven't found
        // any problems by not, but you never know...
        //
        if (Edit_IsAncestorActive(hwnd)) 
        {
            //
            // Reconversion support: quit reconversion if left button is clicked.
            // Otherwise, if the current KL is Korean, finailize the composition string.
            //
            if (ped->fInReconversion || ped->fKorea) 
            {
                BOOLEAN fReconversion = (BOOLEAN)ped->fInReconversion;
                DWORD   dwIndex = fReconversion ? CPS_CANCEL : CPS_COMPLETE;
                HIMC hImc;

                ped->fReplaceCompChr = FALSE;

                hImc = ImmGetContext(ped->hwnd);
                if (hImc) 
                {
                    ImmNotifyIME(hImc, NI_COMPOSITIONSTR, dwIndex, 0);
                    ImmReleaseContext(ped->hwnd, hImc);
                }

                if (fReconversion) 
                {
                    Edit_InOutReconversionMode(ped, FALSE);
                }

                Edit_SetCaretHandler(ped);
            }

            goto HandleEditMsg;
        }

        break;

    case WM_MOUSELEAVE:

        if (ped->hTheme && ped->fHot)
        {
            ped->fHot = FALSE;
            SendMessage(ped->hwnd, WM_NCPAINT, 1, 0);
        }
        break;

    case WM_MOUSEMOVE:

        //
        // If the hot bit is not already set
        // and we are themed
        //
        if (ped->hTheme && !ped->fHot)
        {
            TRACKMOUSEEVENT tme;

            //
            // Set the hot bit and request that
            // we be notified when the mouse leaves
            //
            ped->fHot = TRUE;

            tme.cbSize      = sizeof(tme);
            tme.dwFlags     = TME_LEAVE;
            tme.hwndTrack   = ped->hwnd;
            tme.dwHoverTime = 0;

            TrackMouseEvent(&tme);
            SendMessage(ped->hwnd, WM_NCPAINT, 1, 0);
        }

        //
        // We only care about mouse messages when mouse is down.
        //
        if (ped->fMouseDown)
        {
            goto HandleEditMsg;
        }

        break;

    case WM_NCPAINT:

        //
        // Draw our own client edge border when themed
        //
        if (ped->hTheme && TESTFLAG(GET_EXSTYLE(ped), WS_EX_CLIENTEDGE))
        {
            if (Edit_ClientEdgePaint(ped, ((wParam != 1) ? (HRGN)wParam : NULL)))
            {
                break;
            }
        }

        goto HandleEditMsg;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        break;

    case WM_IME_SETCONTEXT:

        //
        // If ped->fInsertCompChr is TRUE, that means we will do
        // all the composition character drawing by ourself.
        //
        if (ped->fInsertCompChr ) 
        {
            lParam &= ~ISC_SHOWUICOMPOSITIONWINDOW;
        }

        if (wParam) 
        {
            PINPUTCONTEXT pInputContext;
            HIMC hImc;

            hImc = ImmGetContext(hwnd);
            pInputContext = ImmLockIMC(hImc);

            if (pInputContext != NULL) 
            {
                pInputContext->fdw31Compat &= ~F31COMPAT_ECSETCFS;
                ImmUnlockIMC( hImc );
            }

            ImmReleaseContext( hwnd, hImc );
        }

        lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

        break;

    case WM_IME_ENDCOMPOSITION:

        Edit_InOutReconversionMode(ped, FALSE);

        if (ped->fReplaceCompChr) 
        {
            ICH ich;
            HDC hdc;

            //
            // we have a DBCS character to be replaced.
            // let's delete it before inserting the new one.
            //
            ich = (ped->fAnsi) ? 2 : 1;
            ped->fReplaceCompChr = FALSE;
            ped->ichMaxSel = min(ped->ichCaret + ich, ped->cch);
            ped->ichMinSel = ped->ichCaret;
            if (ped->fSingle) 
            {
                if (Edit_DeleteText( ped ) > 0) 
                {
                    //
                    // Update the display
                    //
                    Edit_NotifyParent(ped, EN_UPDATE);
                    hdc = Edit_GetDC(ped, FALSE);
                    EditSL_DrawText(ped, hdc, 0);
                    Edit_ReleaseDC(ped, hdc, FALSE);

                    //
                    // Tell parent our text contents changed.
                    //
                    Edit_NotifyParent(ped, EN_CHANGE);
                }
            }
            else 
            {
                EditML_DeleteText(ped);
            }

            Edit_SetCaretHandler( ped );
        }

        lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

        break;

    case WM_IME_STARTCOMPOSITION:
        if ( ped->fInsertCompChr ) 
        {
            //
            // BUG BUG
            //
            // sending WM_IME_xxxCOMPOSITION will let
            // IME draw composition window. IME should
            // not do that since we cleared
            // ISC_SHOWUICOMPOSITIONWINDOW bit when
            // we got WM_IME_SETCONTEXT message.
            //
            // Korean IME should be fixed in the future.
            //
            break;

        } 
        else 
        {
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
        }

        break;

    case WM_IME_COMPOSITION:

        //
        // simple composition character support for FE IME.
        //
        lResult = Edit_ImeComposition(ped, wParam, lParam);

        break;

    case WM_IME_NOTIFY:

        if (ped->fInReconversion && (wParam == IMN_GUIDELINE))
        {
            HIMC hImc = ImmGetContext(hwnd);

            if ((hImc != NULL_HIMC) && (ImmGetGuideLine(hImc, GGL_LEVEL, NULL, 0) >= GL_LEVEL_WARNING))
            {
                // #266916 Restore the cursor if conversion failed. Conversion can fail
                //         if you try converting 100+ chars at once. 
                Edit_InOutReconversionMode(ped, FALSE);
            }
        }

        lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

        break;

    case WM_KILLFOCUS:

        //
        // remove any tips
        //
        if (ped->hwndBalloon)
        {
            BOOL fClickedTip = (ped->hwndBalloon == (HWND)wParam) ? TRUE : FALSE;

            Edit_HideBalloonTip(ped->hwnd);

            if (fClickedTip)
            {
                //
                // Don't remove focus from the edit because they
                // clicked on the tip.
                //
                SetFocus(hwnd);
                break;
            }
        }

        //
        // when focus is removed from the window,
        // composition character should be finalized
        //
        if (ped && g_fIMMEnabled && ImmIsIME(GetKeyboardLayout(0))) 
        {
            HIMC hImc = ImmGetContext(hwnd);

            if (hImc != NULL_HIMC) 
            {
                if (ped->fReplaceCompChr || (ped->wImeStatus & EIMES_COMPLETECOMPSTRKILLFOCUS)) 
                {
                    //
                    // If the composition string to be determined upon kill focus,
                    // do it now.
                    //
                    ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
                } 
                else if (ped->fInReconversion) 
                {
                    //
                    // If the composition string it not to be determined,
                    // and if we're in reconversion mode, cancel reconversion now.
                    //
                    ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
                }

                //
                // Get out from reconversion mode
                //
                if (ped->fInReconversion) 
                {
                    Edit_InOutReconversionMode(ped, FALSE);
                }

                ImmReleaseContext(hwnd, hImc);
            }
        }

        goto HandleEditMsg;

        break;

    case WM_SETFOCUS:
        if (ped && !ped->fFocus) 
        {
            HKL hkl = GetKeyboardLayout(0);

            if (g_fIMMEnabled && ImmIsIME(hkl)) 
            {
                HIMC hImc;

                hImc = ImmGetContext(hwnd);
                if (hImc) 
                {
                    LPINPUTCONTEXT lpImc;

                    if (ped->wImeStatus & EIMES_CANCELCOMPSTRINFOCUS) 
                    {
                        //
                        // cancel when in-focus
                        //
                        ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
                    }

                    Edit_SetCompositionFont(ped);

                    if ((lpImc = ImmLockIMC(hImc)) != NULL) 
                    {

                        //
                        // We presume the CompForm will reset to CFS_DEFAULT,
                        // when the edit control loses Focus.
                        // IMEWndProc32 will call ImmSetCompositionWindow with
                        // CFS_DEFAULT, when it receive WM_IME_SETCONTEXT.
                        //
                        lpImc->fdw31Compat |= F31COMPAT_ECSETCFS;

                        ImmUnlockIMC(hImc);
                    }
                    ImmReleaseContext(hwnd, hImc);
                }

                //
                // force to set IME composition window when
                // first getting focus.
                //
                ped->ptScreenBounding.x = -1;
                ped->ptScreenBounding.y = -1;
            }

            Edit_InitInsert(ped, hkl);
        }

        goto HandleEditMsg;

        break;

    case WM_IME_REQUEST:
        //
        // simple ImeRequest Handler
        //

        lResult = Edit_RequestHandler(ped, wParam, lParam);

        break;
        
    case WM_CREATE:

        if (g_fIMMEnabled && ped)
        {
            Edit_EnableDisableIME(ped);
        }

        goto HandleEditMsg;

        break;

    case WM_GETOBJECT:

        if(lParam == OBJID_QUERYCLASSNAMEIDX)
        {
            lResult = MSAA_CLASSNAMEIDX_EDIT;
        }
        else
        {
            lResult = FALSE;
        }

        break;

    case WM_THEMECHANGED:

        if ( ped->hTheme )
        {
            CloseThemeData(ped->hTheme);
        }

        ped->hTheme = OpenThemeData(ped->hwnd, L"Edit");

        if ( ped->hFontSave )
        {
            Edit_SetFont(ped, ped->hFontSave, FALSE);
        }
        InvalidateRect(ped->hwnd, NULL, TRUE);

        lResult = TRUE;

        break;

    case EM_SHOWBALLOONTIP: 

        lResult = Edit_ShowBalloonTipHandler(ped, (PEDITBALLOONTIP) lParam);
        break;

    case EM_HIDEBALLOONTIP: 
        
        lResult = Edit_HideBalloonTipHandler(ped); 
        break;

    case WM_TIMER:

        if (wParam == ID_EDITTIMER)
        {
            KillTimer(ped->hwnd, ID_EDITTIMER);
            lResult = Edit_HideBalloonTip(ped->hwnd);
        }

        break;

    default:

HandleEditMsg:
        if (ped != NULL) 
        {
            if (ped->fSingle) 
            {
                lResult = EditSL_WndProc(ped, uMsg, wParam, lParam);
            } 
            else 
            {
                lResult = EditML_WndProc(ped, uMsg, wParam, lParam);
            }
        }
    }

    return lResult;
}


//---------------------------------------------------------------------------//
//
// Edit_FindXORblks
// 
// This finds the XOR of lpOldBlk and lpNewBlk and return s resulting blocks
// through the lpBlk1 and lpBlk2; This could result in a single block or
// at the maximum two blocks;
// If a resulting block is empty, then it's StPos field has -1.
//
// NOTE:
// When called from MultiLine edit control, StPos and EndPos fields of
// these blocks have the Starting line and Ending line of the block;
// When called from SingleLine edit control, StPos and EndPos fields
// of these blocks have the character index of starting position and
// ending position of the block.
//
VOID Edit_FindXORblks(LPSELBLOCK lpOldBlk, LPSELBLOCK lpNewBlk, LPSELBLOCK lpBlk1, LPSELBLOCK lpBlk2)
{
    if (lpOldBlk->StPos >= lpNewBlk->StPos) 
    {
        lpBlk1->StPos = lpNewBlk->StPos;
        lpBlk1->EndPos = min(lpOldBlk->StPos, lpNewBlk->EndPos);
    } 
    else 
    {
        lpBlk1->StPos = lpOldBlk->StPos;
        lpBlk1->EndPos = min(lpNewBlk->StPos, lpOldBlk->EndPos);
    }

    if (lpOldBlk->EndPos <= lpNewBlk->EndPos) 
    {
        lpBlk2->StPos = max(lpOldBlk->EndPos, lpNewBlk->StPos);
        lpBlk2->EndPos = lpNewBlk->EndPos;
    } 
    else 
    {
        lpBlk2->StPos = max(lpNewBlk->EndPos, lpOldBlk->StPos);
        lpBlk2->EndPos = lpOldBlk->EndPos;
    }
}


//---------------------------------------------------------------------------//
//
BOOL Edit_CalcChangeSelection(PED ped, ICH ichOldMinSel, ICH ichOldMaxSel, LPSELBLOCK OldBlk, LPSELBLOCK NewBlk)
{
    SELBLOCK Blk[2];
    int iBlkCount = 0;

    Blk[0].StPos = Blk[0].EndPos = Blk[1].StPos = Blk[1].EndPos = 0xFFFFFFFF;

    //
    // Check if the Old selection block existed
    //
    if (ichOldMinSel != ichOldMaxSel) 
    {
        //
        // Yes! Old block existed.
        //
        Blk[0].StPos = OldBlk->StPos;
        Blk[0].EndPos = OldBlk->EndPos;
        iBlkCount++;
    }

    //
    // Check if the new Selection block exists
    //
    if (ped->ichMinSel != ped->ichMaxSel) 
    {
        //
        // Yes! New block exists
        //
        Blk[1].StPos = NewBlk->StPos;
        Blk[1].EndPos = NewBlk->EndPos;
        iBlkCount++;
    }

    //
    // If both the blocks exist find the XOR of them
    //
    if (iBlkCount == 2) 
    {
        //
        // Check if both blocks start at the same character position
        //
        if (ichOldMinSel == ped->ichMinSel) 
        {
            //
            // Check if they end at the same character position
            //
            if (ichOldMaxSel == ped->ichMaxSel)
            {
                //
                // Nothing changes
                //
                return FALSE;
            }

            Blk[0].StPos = min(NewBlk -> EndPos, OldBlk -> EndPos);
            Blk[0].EndPos = max(NewBlk -> EndPos, OldBlk -> EndPos);
            Blk[1].StPos = 0xFFFFFFFF;

        } 
        else 
        {
            if (ichOldMaxSel == ped->ichMaxSel) 
            {
                Blk[0].StPos = min(NewBlk->StPos, OldBlk->StPos);
                Blk[0].EndPos = max(NewBlk->StPos, OldBlk->StPos);
                Blk[1].StPos = 0xFFFFFFFF;
            } 
            else 
            {
                Edit_FindXORblks(OldBlk, NewBlk, &Blk[0], &Blk[1]);
            }
        }
    }

    RtlCopyMemory(OldBlk, &Blk[0], sizeof(SELBLOCK));
    RtlCopyMemory(NewBlk, &Blk[1], sizeof(SELBLOCK));

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// Edit_GetControlBrush
// 
// Client side optimization replacement for NtUserGetControlBrush
// message is one of the WM_CTLCOLOR* messages.
//
HBRUSH Edit_GetControlBrush(PED ped, HDC hdc, LONG message)
{
    HWND hwndSend;

    hwndSend = (GET_STYLE(ped) & WS_POPUP) ? GetWindowOwner(ped->hwnd) : GetParent(ped->hwnd);
    if (!hwndSend)
    {
        hwndSend = ped->hwnd;
    }

    //
    // By using the correct A/W call we avoid a c/s transition
    // on this SendMessage().
    //
    return (HBRUSH)SendMessage(hwndSend, message, (WPARAM)hdc, (LPARAM)ped->hwnd);
}


//---------------------------------------------------------------------------//
//
// Edit_GetDBCSVector
//
// This function sets DBCS Vector for specified character set and sets
// ped->fDBCS flag if needed.
//
INT Edit_GetDBCSVector(PED ped, HDC hdc, BYTE CharSet)
{
    BOOL bDBCSCodePage = FALSE;
    static UINT fFontAssocStatus = 0xffff;

    //
    // if DEFAUT_CHARSET was passed, we will convert that to Shell charset..
    //
    if (CharSet == DEFAULT_CHARSET) 
    {
        CharSet = (BYTE)GetTextCharset(hdc);

        //
        // if CharSet is still DEFAULT_CHARSET, it means gdi has some problem..
        // then just return default.. we get charset from CP_ACP..
        //
        if (CharSet == DEFAULT_CHARSET) 
        {
            CharSet = (BYTE)GetACPCharSet();
        }
    }

    switch (CharSet) 
    {
    case SHIFTJIS_CHARSET:
    case HANGEUL_CHARSET:
    case CHINESEBIG5_CHARSET:
    case GB2312_CHARSET:

        bDBCSCodePage = TRUE;
        break;

    case ANSI_CHARSET:            // 0
    case SYMBOL_CHARSET:          // 2
    case OEM_CHARSET:             // 255

        if (fFontAssocStatus == 0xffff)
        {
            fFontAssocStatus = QueryFontAssocStatus();
        }

        if ((((CharSet + 2) & 0xf) & fFontAssocStatus)) 
        {
            bDBCSCodePage = TRUE;

            //
            // Bug 117558, etc.
            // Try to get a meaningful character set for associated font.
            //
            CharSet = (BYTE)GetACPCharSet();
        } 
        else 
        {
            bDBCSCodePage = FALSE;
        }

        break;

    default:
        bDBCSCodePage = FALSE;
    }

    if (bDBCSCodePage) 
    {
        CHARSETINFO CharsetInfo;
        DWORD CodePage;
        CPINFO CPInfo;
        INT lbIX;

        if (TranslateCharsetInfo((DWORD *)CharSet, &CharsetInfo, TCI_SRCCHARSET)) 
        {
            CodePage = CharsetInfo.ciACP;
        } 
        else 
        {
            CodePage = CP_ACP;
        }

        GetCPInfo(CodePage, &CPInfo);
        for (lbIX=0 ; CPInfo.LeadByte[lbIX] != 0 ; lbIX+=2) 
        {
            ped->DBCSVector[lbIX  ] = CPInfo.LeadByte[lbIX];
            ped->DBCSVector[lbIX+1] = CPInfo.LeadByte[lbIX+1];
        }
        ped->DBCSVector[lbIX  ] = 0x0;
        ped->DBCSVector[lbIX+1] = 0x0;
    }
    else 
    {
        ped->DBCSVector[0] = 0x0;
        ped->DBCSVector[1] = 0x0;
    }

    //
    // Final check: if the font supports DBCS glyphs
    //
    // If we've got a font with DBCS glyphs, let's mark PED so.
    // But since the font's primary charset is the one other than FE,
    // we can only support UNICODE Edit control.
    //
    //  a) GDI performs A/W conversion for ANSI apps based on the primary
    //     character set in hDC, so it will break anyway.
    //  b) ANSI applications are only supported on their native system locales:
    //     GetACPCharSet() is expected to return a FE code page.
    //  c) ANSI Edit control requires DBCSVector, which cannot be
    //     initialized without a FE code page.
    //
    if (!ped->fAnsi) 
    {
        FONTSIGNATURE fontSig;

        GetTextCharsetInfo(hdc, &fontSig, 0);
        if (fontSig.fsCsb[0] &FAREAST_CHARSET_BITS) 
        {
            //
            // Since this is UNICODE, we're not
            //
            bDBCSCodePage = TRUE;
        }
    }

    return bDBCSCodePage;
}


//---------------------------------------------------------------------------//
//
// Edit_AnsiNext
//
// This function advances string pointer for Edit Control use only.
//
LPSTR Edit_AnsiNext(PED ped, LPSTR lpCurrent)
{
    return lpCurrent+((Edit_IsDBCSLeadByte(ped,*lpCurrent)==TRUE) ? 2 : 1);
}


//---------------------------------------------------------------------------//
//
// Edit_AnsiPrev
// 
// This function decrements string pointer for Edit Control use only.
//
LPSTR Edit_AnsiPrev(PED ped, LPSTR lpBase, LPSTR lpStr )
{
    LPSTR lpCurrent = lpStr -1;

    if (!ped->fDBCS)
    {
        //
        // just return ( lpStr - 1 )
        //
        return lpCurrent;
    }

    if (lpBase >= lpCurrent)
    {
        return lpBase;
    }

    //
    // this check makes things faster
    //
    if (Edit_IsDBCSLeadByte(ped, *lpCurrent))
    {
        return (lpCurrent - 1);
    }

    do 
    {
        lpCurrent--;
        if (!Edit_IsDBCSLeadByte(ped, *lpCurrent)) 
        {
            lpCurrent++;
            break;
        }
    } 
    while(lpCurrent != lpBase);

    return lpStr - (((lpStr - lpCurrent) & 1) ? 1 : 2);
}


//---------------------------------------------------------------------------//
//
// Edit_NextIch
// 
// This function advances string pointer for Edit Control use only.
//
ICH Edit_NextIch( PED ped, LPSTR pStart, ICH ichCurrent )
{
    if (!ped->fDBCS || !ped->fAnsi) 
    {
        return (ichCurrent + 1);
    } 
    else 
    {

        ICH ichRet;
        LPSTR pText;

        if (pStart)
        {
            pText = pStart + ichCurrent;
        }
        else
        {
            pText = (LPSTR)Edit_Lock(ped) + ichCurrent;
        }

        ichRet = ichCurrent + ( Edit_IsDBCSLeadByte(ped, *pText) ? 2 : 1 );

        if (!pStart)
        {
            Edit_Unlock(ped);
        }

        return ichRet;
    }
}


//---------------------------------------------------------------------------//
//
// Edit_PrevIch
//
// This function decrements string pointer for Edit Control use only.
//
ICH Edit_PrevIch(PED ped, LPSTR pStart, ICH ichCurrent)
{
    LPSTR lpCurrent;
    LPSTR lpStr;
    LPSTR lpBase;

    if (!ped->fDBCS || !ped->fAnsi)
    {

        if (ichCurrent)
        {
            return (ichCurrent - 1);
        }
        else
        {
            return (ichCurrent);
        }
    }

    if (ichCurrent <= 1)
    {
        return 0;
    }

    if (pStart)
    {
        lpBase = pStart;
    }
    else
    {
        lpBase = Edit_Lock(ped);
    }


    lpStr = lpBase + ichCurrent;
    lpCurrent = lpStr - 1;
    if (Edit_IsDBCSLeadByte(ped,*lpCurrent)) 
    {
        if (!pStart)
        {
            Edit_Unlock(ped);
        }
        return (ichCurrent - 2);
    }

    do 
    {
        lpCurrent--;
        if (!Edit_IsDBCSLeadByte(ped, *lpCurrent)) 
        {
            lpCurrent++;
            break;
        }
    } 
    while(lpCurrent != lpBase);

    if (!pStart)
    {
        Edit_Unlock(ped);
    }

    return (ichCurrent - (((lpStr - lpCurrent) & 1) ? 1 : 2));

}


//---------------------------------------------------------------------------//
//
// Edit_IsDBCSLeadByte
// 
// IsDBCSLeadByte for Edit Control use only.
//
BOOL Edit_IsDBCSLeadByte(PED ped, BYTE cch)
{
    INT i;

    if (!ped->fDBCS || !ped->fAnsi)
    {
        return (FALSE);
    }

    for (i = 0; ped->DBCSVector[i]; i += 2) 
    {
        if ((ped->DBCSVector[i] <= cch) && (ped->DBCSVector[i+1] >= cch))
        {
            return (TRUE);
        }
    }

    return (FALSE);
}

//---------------------------------------------------------------------------//
//
// DbcsCombine
//
// Assemble two WM_CHAR messages to single DBCS character.
// If program detects first byte of DBCS character in WM_CHAR message,
// it calls this function to obtain second WM_CHAR message from queue.
// finally this routine assembles first byte and second byte into single
// DBCS character.
//
WORD DbcsCombine(HWND hwnd, WORD ch)
{
    MSG msg;
    INT i = 10; // loop counter to avoid the infinite loop

    while (!PeekMessageA(&msg, hwnd, WM_CHAR, WM_CHAR, PM_REMOVE)) 
    {
        if (--i == 0)
            return 0;
        Sleep(1);
    }

    return (WORD)ch | ((WORD)(msg.wParam) << 8);
}


//---------------------------------------------------------------------------//
//
// Edit_AdjustIch 
//
// This function adjusts a current pointer correctly. If a current
// pointer is lying between DBCS first byte and second byte, this
// function adjusts a current pointer to a first byte of DBCS position
// by decrement once.
//
ICH Edit_AdjustIch( PED ped, LPSTR lpstr, ICH ch )
{
    ICH newch = ch;

    if (!ped->fAnsi || !ped->fDBCS || newch == 0)
    {
        return ch;
    }

    if (!Edit_IsDBCSLeadByte(ped,lpstr[--newch]))
    {
        //
        // previous char is SBCS
        //
        return ch;
    }

    while (1) 
    {
        if (!Edit_IsDBCSLeadByte(ped,lpstr[newch])) 
        {
            newch++;
            break;
        }

        if (newch)
        {
            newch--;
        }
        else
        {
            break;
        }
    }

    return ((ch - newch) & 1) ? ch-1 : ch;
}


//---------------------------------------------------------------------------//
//
// Edit_AdjustIchNext
//
ICH Edit_AdjustIchNext(PED ped, LPSTR lpstr, ICH ch)
{
    ICH   ichNew = Edit_AdjustIch(ped,lpstr,ch);
    LPSTR lpnew  = lpstr + ichNew;

    //
    // if ch > ichNew then Edit_AdjustIch adjusted ich.
    //
    if (ch > ichNew)
    {
       lpnew = Edit_AnsiNext(ped, lpnew);
    }

    return (ICH)(lpnew-lpstr);
}


//---------------------------------------------------------------------------//
//
// Edit_UpdateFormat
//
// Computes ped->format and ped->fRtoLReading from dwStyle and dwExStyle.
// Refreshes the display if either are changed.
//
VOID Edit_UpdateFormat(PED ped, DWORD dwStyle, DWORD dwExStyle)
{
    UINT fNewRtoLReading;
    UINT uiNewFormat;

    //
    // Extract new format and reading order from style
    //
    fNewRtoLReading = dwExStyle & WS_EX_RTLREADING ? 1 : 0;
    uiNewFormat     = dwStyle & ES_FMTMASK;

    //
    // WS_EX_RIGHT is ignored unless dwStyle is ES_LEFT
    //
    if (uiNewFormat == ES_LEFT && dwExStyle & WS_EX_RIGHT) 
    {
        uiNewFormat = ES_RIGHT;
    }


    //
    // Internally ES_LEFT and ES_RIGHT are swapped for RtoLReading order
    // (Think of them as ES_LEADING and ES_TRAILING)
    //
    if (fNewRtoLReading) 
    {
        switch (uiNewFormat) 
        {
        case ES_LEFT:  
            uiNewFormat = ES_RIGHT; 
            break;

        case ES_RIGHT: 
            uiNewFormat = ES_LEFT;  
            break;
        }
    }


    //
    // Format change does not cause redisplay by itself
    //
    ped->format = uiNewFormat;

    //
    // Refresh display on change of reading order
    //
    if (fNewRtoLReading != ped->fRtoLReading) 
    {
        ped->fRtoLReading = fNewRtoLReading;

        if (ped->fWrap) 
        {
            //
            // Redo wordwrap
            //
            EditML_BuildchLines(ped, 0, 0, FALSE, NULL, NULL);
            EditML_UpdateiCaretLine(ped);
        } 
        else 
        {
            //
            // Refresh horizontal scrollbar display
            //
            EditML_Scroll(ped, FALSE, 0xffffffff, 0, TRUE);
        }

        Edit_InvalidateClient(ped, TRUE);
    }
}


//---------------------------------------------------------------------------//
//
// Edit_IsFullWidth
//
// Detects Far East FullWidth character.
//
BOOL Edit_IsFullWidth(DWORD dwCodePage,WCHAR wChar)
{
    INT index;
    INT cChars;

    static struct _FULLWIDTH_UNICODE 
    {
        WCHAR Start;
        WCHAR End;
    } FullWidthUnicodes[] = 
    {
       { 0x4E00, 0x9FFF }, // CJK_UNIFIED_IDOGRAPHS
       { 0x3040, 0x309F }, // HIRAGANA
       { 0x30A0, 0x30FF }, // KATAKANA
       { 0xAC00, 0xD7A3 }  // HANGUL
    };

    //
    // Early out for ASCII.
    //
    if (wChar < 0x0080) 
    {
        //
        // if the character < 0x0080, it should be a halfwidth character.
        //
        return FALSE;
    }

    //
    // Scan FullWdith definition table... most of FullWidth character is
    // defined here... this is more faster than call NLS API.
    //
    for (index = 0; index < ARRAYSIZE(FullWidthUnicodes); index++) 
    {
        if ((wChar >= FullWidthUnicodes[index].Start) &&
            (wChar <= FullWidthUnicodes[index].End)) 
        {
            return TRUE;
        }
    }

    //
    // if this Unicode character is mapped to Double-Byte character,
    // this is also FullWidth character..
    //
    cChars = WideCharToMultiByte((UINT)dwCodePage, 0, &wChar, 1, NULL, 0, NULL, NULL);

    return cChars > 1 ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\flat_sb.h ===
#ifndef _NEW_WSBCONTROL_H
#define _NEW_WSBCONTROL_H
#endif  //  _NEW_WSBCONTROL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\flat_sb.c ===
#include "ctlspriv.h"
#include "flat_sb.h"

HRESULT WINAPI UninitializeFlatSB(HWND hwnd)
{
    return S_OK;
}

BOOL WINAPI InitializeFlatSB(HWND hwnd)
{
    return TRUE;
}

int WINAPI FlatSB_GetScrollPos(HWND hwnd, int code)
{
    return GetScrollPos(hwnd, code);
}

BOOL WINAPI FlatSB_GetScrollPropPtr(HWND hwnd, int propIndex, PINT_PTR pValue)
{
    return FALSE;
}

#ifdef _WIN64

BOOL WINAPI FlatSB_GetScrollProp(HWND hwnd, int propIndex, LPINT pValue)
{
    return FALSE;
}
#endif

BOOL WINAPI FlatSB_GetScrollRange(HWND hwnd, int code, LPINT lpposMin, LPINT lpposMax)
{
    return GetScrollRange(hwnd, code, lpposMin, lpposMax);
}

BOOL WINAPI FlatSB_GetScrollInfo(HWND hwnd, int fnBar, LPSCROLLINFO lpsi)
{
    return GetScrollInfo(hwnd, fnBar, lpsi);
}

BOOL WINAPI FlatSB_ShowScrollBar(HWND hwnd, int fnBar, BOOL fShow)
{
    return ShowScrollBar(hwnd, fnBar, fShow);
}

BOOL WINAPI FlatSB_EnableScrollBar(HWND hwnd, int wSBflags, UINT wArrows)
{
    return EnableScrollBar(hwnd, wSBflags, wArrows);
}

int WINAPI FlatSB_SetScrollPos(HWND hwnd, int code, int pos, BOOL fRedraw)
{
    return SetScrollPos(hwnd, code, pos, fRedraw);
}

BOOL WINAPI FlatSB_SetScrollRange(HWND hwnd, int code, int nMin, int nMax, BOOL fRedraw)
{
    return SetScrollRange(hwnd, code, nMin, nMax, fRedraw);
}


int WINAPI FlatSB_SetScrollInfo(HWND hwnd, int code, LPSCROLLINFO lpsi, BOOL fRedraw)
{
    return SetScrollInfo(hwnd, code, lpsi, fRedraw);
}

BOOL WINAPI FlatSB_SetScrollProp(HWND hwnd, UINT index, INT_PTR newValue, BOOL fRedraw)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\editml.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "edit.h"


//---------------------------------------------------------------------------//

//
// Number of lines to bump when reallocating index buffer
//
#define LINEBUMP 32

//
// Used for ML scroll updates
//
#define ML_REFRESH  0xffffffff


//---------------------------------------------------------------------------//
//
// Forwards
//
ICH  EditML_Line(PED, ICH);
VOID EditML_ShiftchLines(PED, ICH, int);
VOID EditML_Char(PED, DWORD, int);
VOID EditML_MouseMotion(PED, UINT, UINT, LPPOINT);
BOOL EditML_EnsureCaretVisible(PED);
VOID EditML_DrawText(PED, HDC, ICH, ICH, BOOL);
BOOL EditML_InsertCrCrLf(PED);
VOID EditML_StripCrCrLf(PED);
VOID EditML_SetHandle(PED, HANDLE);
LONG EditML_GetLine(PED, ICH, ICH, LPSTR);
ICH  EditML_LineIndex(PED, ICH);
ICH  EditML_LineLength(PED, ICH);
VOID EditML_SetSelection(PED, BOOL, ICH, ICH);
BOOL EditML_SetTabStops(PED, int, LPINT);
BOOL EditML_Undo(PED);
LONG EditML_Create(PED, LPCREATESTRUCT);


//---------------------------------------------------------------------------//
__inline void EditML_SanityCheck(PED ped)
{
    UNREFERENCED_PARAMETER(ped);    // For free build

    UserAssert(ped->cch >= ped->chLines[ped->cLines - 1]);
}


//---------------------------------------------------------------------------//
// 
// EditML_GetLineWidth
// 
// Returns the max width in a line.  Edit_TabTheTextOut() ensures that max
// width won't overflow.
//
UINT EditML_GetLineWidth(HDC hdc, LPSTR lpstr, int nCnt, PED ped)
{
    return Edit_TabTheTextOut(hdc, 0, 0, 0, 0, lpstr, nCnt, 0, ped, 0, ECT_CALC, NULL);
}


//---------------------------------------------------------------------------//
//
// EditML_Size
// 
// Handles resizing of the edit control window and updating thereof.
// 
// Sets the edit field's formatting area given the passed in "client area".
// We fudge it if it doesn't seem reasonable.
// 
VOID EditML_Size(PED ped, BOOL fRedraw)
{
    //
    // Calculate the # of lines we can fit in our rectangle.
    //
    ped->ichLinesOnScreen = (ped->rcFmt.bottom - ped->rcFmt.top) / ped->lineHeight;

    //
    // Make the format rectangle height an integral number of lines
    //
    ped->rcFmt.bottom = ped->rcFmt.top + ped->ichLinesOnScreen * ped->lineHeight;

    //
    // Rebuild the line array
    //
    if (ped->fWrap) 
    {
        EditML_BuildchLines(ped, 0, 0, FALSE, NULL, NULL);
        EditML_UpdateiCaretLine(ped);
    } 
    else 
    {
        EditML_Scroll(ped, TRUE,  ML_REFRESH, 0, fRedraw);
        EditML_Scroll(ped, FALSE, ML_REFRESH, 0, fRedraw);
    }
}


//---------------------------------------------------------------------------//
//
// EditML_CalcXOffset
// 
// Calculates the horizontal offset (indent) required for centered
// and right justified lines.
//
int EditML_CalcXOffset(PED ped, HDC hdc, int lineNumber)
{
    PSTR pText;
    ICH lineLength;
    ICH lineWidth;

    if (ped->format == ES_LEFT)
    {
        return 0;
    }

    lineLength = EditML_Line(ped, lineNumber);

    if (lineLength) 
    {
        pText = Edit_Lock(ped) + ped->chLines[lineNumber] * ped->cbChar;
        hdc = Edit_GetDC(ped, TRUE);
        lineWidth = EditML_GetLineWidth(hdc, pText, lineLength, ped);
        Edit_ReleaseDC(ped, hdc, TRUE);
        Edit_Unlock(ped);
    } 
    else 
    {
        lineWidth = 0;
    }

    //
    // If a SPACE or a TAB was eaten at the end of a line by EditML_BuildchLines
    // to prevent a delimiter appearing at the begining of a line, the
    // the following calculation will become negative causing this bug.
    // So, now, we take zero in such cases.
    // Fix for Bug #3566 --01/31/91-- SANKAR --
    //
    lineWidth = max(0, (int)(ped->rcFmt.right-ped->rcFmt.left-lineWidth));

    if (ped->format == ES_CENTER)
    {
        return (lineWidth / 2);
    }

    if (ped->format == ES_RIGHT) 
    {
        //
        // Subtract 1 so that the 1 pixel wide cursor will be in the visible
        // region on the very right side of the screen.
        //
        return max(0, (int)(lineWidth-1));
    }

    return 0;
}


//---------------------------------------------------------------------------//
//
// Edit_MoveSelection AorW
//
// Moves the selection character in the direction indicated. Assumes
// you are starting at a legal point, we decrement/increment the ich. Then,
// This decrements/increments it some more to get past CRLFs...
//
ICH Edit_MoveSelection(PED ped, ICH ich, BOOL fLeft)
{

    if (fLeft && ich > 0) 
    {
        //
        // Move left
        //
        ich = Edit_PrevIch( ped, NULL, ich );
        if (ich) 
        {
            if (ped->fAnsi) 
            {
                LPSTR pText;

                //
                // Check for CRLF or CRCRLF
                //
                pText = Edit_Lock(ped) + ich;

                //
                // Move before CRLF or CRCRLF
                //
                if (*(WORD UNALIGNED *)(pText - 1) == 0x0A0D) 
                {
                    ich--;
                    if (ich && *(pText - 2) == 0x0D)
                        ich--;
                }

                Edit_Unlock(ped);
            } 
            else 
            {
                LPWSTR pwText;

                //
                // Check for CRLF or CRCRLF
                //
                pwText = (LPWSTR)Edit_Lock(ped) + ich;

                //
                // Move before CRLF or CRCRLF
                //
                if (*(pwText - 1) == 0x0D && *pwText == 0x0A) 
                {
                    ich--;
                    if (ich && *(pwText - 2) == 0x0D)
                        ich--;
                }

                Edit_Unlock(ped);
            }
        }
    } 
    else if (!fLeft && ich < ped->cch) 
    {
        //
        // Move right.
        //
        ich = Edit_NextIch( ped, NULL, ich );
        if (ich < ped->cch) 
        {
            if (ped->fAnsi) 
            {
                LPSTR pText;
                pText = Edit_Lock(ped) + ich;

                //
                // Move after CRLF
                //
                if (*(WORD UNALIGNED *)(pText - 1) == 0x0A0D)
                {
                    ich++;
                }
                else 
                {
                    //
                    // Check for CRCRLF
                    //
                    if (ich && *(WORD UNALIGNED *)pText == 0x0A0D && *(pText - 1) == 0x0D)
                    {
                        ich += 2;
                    }
                }

                Edit_Unlock(ped);
            } 
            else 
            {
                LPWSTR pwText;
                pwText = (LPWSTR)Edit_Lock(ped) + ich;

                //
                // Move after CRLF
                //
                if (*(pwText - 1) == 0x0D && *pwText == 0x0A)
                {
                    ich++;
                }
                else 
                {
                    //
                    // Check for CRCRLF
                    //
                    if (ich && *(pwText - 1) == 0x0D && *pwText == 0x0D &&
                            *(pwText + 1) == 0x0A)
                    {
                        ich += 2;
                    }
                }

                Edit_Unlock(ped);
            }
        }
    }

    return ich;
}


//---------------------------------------------------------------------------//
//
// Edit_MoveSelectionRestricted AorW
// 
// Moves the selection like Edit_MoveSelection, but also obeys limitations
// imposed by some languages such as Thai, where the cursor cannot stop
// between a character and it's attached vowel or tone marks.
//
// Only called if the language pack is loaded.
//
ICH Edit_MoveSelectionRestricted(PED ped, ICH ich, BOOL fLeft)
{
    PSTR pText;
    HDC  hdc;
    ICH  ichResult;

    pText = Edit_Lock(ped);
    hdc = Edit_GetDC(ped, TRUE);
    ichResult = ped->pLpkEditCallout->EditMoveSelection((PED0)ped, hdc, pText, ich, fLeft);
    Edit_ReleaseDC(ped, hdc, TRUE);
    Edit_Unlock(ped);

    return ichResult;
}


//---------------------------------------------------------------------------//
//
// EditML_SetCaretPosition AorW
//
// If the window has the focus, find where the caret belongs and move
// it there.
//
VOID EditML_SetCaretPosition(PED ped, HDC hdc)
{
    POINT position;
    BOOL prevLine;
    int  x = -20000;
    int  y = -20000;

    //
    // We will only position the caret if we have the focus since we don't want
    // to move the caret while another window could own it.
    //
    if (!ped->fFocus || !IsWindowVisible(ped->hwnd))
    {
         return;
    }

    //
    // Find the position of the caret
    //
    if (!ped->fCaretHidden &&
        ((ICH) ped->iCaretLine >= ped->ichScreenStart) &&
        ((ICH) ped->iCaretLine <  (ped->ichScreenStart + ped->ichLinesOnScreen))) 
    {
        RECT rcRealFmt;

        if (ped->f40Compat)
        {
            GetClientRect(ped->hwnd, &rcRealFmt);
            IntersectRect(&rcRealFmt, &rcRealFmt, &ped->rcFmt);
        } 
        else 
        {
            CopyRect(&rcRealFmt, &ped->rcFmt);
        }

        if (ped->cLines - 1 != ped->iCaretLine && ped->ichCaret == ped->chLines[ped->iCaretLine + 1]) 
        {
            prevLine = TRUE;
        } 
        else 
        {
            prevLine = FALSE;
        }

        EditML_IchToXYPos(ped, hdc, ped->ichCaret, prevLine, &position);

        if ( (position.y >= rcRealFmt.top) &&
             (position.y <= rcRealFmt.bottom - ped->lineHeight)) 
        {
            int xPos = position.x;
            int cxCaret;
 
            SystemParametersInfo(SPI_GETCARETWIDTH, 0, (LPVOID)&cxCaret, 0);

            if (ped->fWrap ||
                ((xPos > (rcRealFmt.left - cxCaret)) &&
                 (xPos <= rcRealFmt.right))) 
            {
                //
                // Make sure the caret is in the visible region if word
                // wrapping. This is so that the caret will be visible if the
                // line ends with a space.
                //
                x = max(xPos, rcRealFmt.left);
                x = min(x, rcRealFmt.right - cxCaret);
                y = position.y;
            }
        }
    }

    if (ped->pLpkEditCallout) 
    {
        SetCaretPos(x + ped->iCaretOffset, y);
    } 
    else 
    {
        SetCaretPos(x, y);
    }

    //
    // FE_IME : EditML_SetCaretPosition -- ImmSetCompositionWindow(CFS_RECT)
    //
    if (g_fIMMEnabled && ImmIsIME(GetKeyboardLayout(0))) 
    {
        if (x != -20000 && y != -20000) 
        {
            Edit_ImmSetCompositionWindow(ped, x, y);
        }
    }
}


//---------------------------------------------------------------------------//
//
// EditML_Line
//
// Returns the length of the line (cch) given by lineNumber ignoring any
// CRLFs in the line.
//
ICH EditML_Line(PED ped, ICH lineNumber) 
{
    ICH result;

    if (lineNumber >= ped->cLines)
    {
        return 0;
    }

    if (lineNumber == ped->cLines - 1) 
    {
        //
        // Since we can't have a CRLF on the last line
        //
        return (ped->cch - ped->chLines[ped->cLines - 1]);
    } 
    else 
    {
        result = ped->chLines[lineNumber + 1] - ped->chLines[lineNumber];
        TraceMsg(TF_STANDARD, "Edit: MLLine result=%d", result);

        //
        // Now check for CRLF or CRCRLF at end of line
        //
        if (result > 1) 
        {
            if (ped->fAnsi) 
            {
                LPSTR pText;

                pText = Edit_Lock(ped) + ped->chLines[lineNumber + 1] - 2;
                if (*(WORD UNALIGNED *)pText == 0x0A0D) 
                {
                    result -= 2;
                    if (result && *(--pText) == 0x0D)
                    {
                        //
                        // In case there was a CRCRLF
                        //
                        result--;
                    }
                }
            } 
            else 
            {
                LPWSTR pwText;

                pwText = (LPWSTR)Edit_Lock(ped) + (ped->chLines[lineNumber + 1] - 2);
                if (*(DWORD UNALIGNED *)pwText == 0x000A000D) 
                {
                    result = result - 2;
                    if (result && *(--pwText) == 0x0D)
                    {
                        //
                        // In case there was a CRCRLF
                        //
                        result--;
                    }
                }

            }

            Edit_Unlock(ped);
        }
    }

    return result;
}


//---------------------------------------------------------------------------//
//
// EditML_IchToLine AorW
//
// Returns the line number (starting from 0) which contains the given
// character index. If ich is -1, return the line the first char in the
// selection is on (the caret if no selection)
//
INT EditML_IchToLine(PED ped, ICH ich)
{
    int iLo, iHi, iLine;

    iLo = 0;
    iHi = ped->cLines;

    if (ich == (ICH)-1)
    {
        ich = ped->ichMinSel;
    }

    while (iLo < iHi - 1) 
    {
        iLine = max((iHi - iLo)/2, 1) + iLo;

        if (ped->chLines[iLine] > ich) 
        {
            iHi = iLine;
        } 
        else 
        {
            iLo = iLine;
        }
    }

    return iLo;
}


//---------------------------------------------------------------------------//
//
// EditML_IchToYPos
//
// Given an ich, return its y coordinate with respect to the top line
// displayed in the window. If prevLine is TRUE and if the ich is at the
// beginning of the line, return the y coordinate of the
// previous line (if it is not a CRLF).
// 
// Added for the LPK (3Dec96) - with an LPK installed, calculating X position is
// a far more processor intensive job. Where only the Y position is required
// this routine should be called instead of EditML_IchToXYPos.
// 
// Called only when LPK installed.
//
INT EditML_IchToYPos( PED  ped, ICH  ich, BOOL prevLine)
{
    int  iline;
    int  yPosition;
    PSTR pText;

    //
    // Determine what line the character is on
    //
    iline = EditML_IchToLine(ped, ich);

    //
    // Calc. the yPosition now. Note that this may change by the height of one
    // char if the prevLine flag is set and the ICH is at the beginning of a line.
    //
    yPosition = (iline - ped->ichScreenStart) * ped->lineHeight + ped->rcFmt.top;

    pText = Edit_Lock(ped);
    if (prevLine && iline && (ich == ped->chLines[iline]) &&
            (!AWCOMPARECHAR(ped, pText + (ich - 2) * ped->cbChar, 0x0D) ||
             !AWCOMPARECHAR(ped, pText + (ich - 1) * ped->cbChar, 0x0A))) 
    {
        //
        // First char in the line. We want Y position of the previous
        // line if we aren't at the 0th line.
        //
        iline--;

        yPosition = yPosition - ped->lineHeight;
    }

    Edit_Unlock(ped);

    return yPosition;
}


//---------------------------------------------------------------------------//
//
// EditML_IchToXYPos
//
// Given an ich, return its x,y coordinates with respect to the top
// left character displayed in the window. Returns the coordinates of the top
// left position of the char. If prevLine is TRUE then if the ich is at the
// beginning of the line, we will return the coordinates to the right of the
// last char on the previous line (if it is not a CRLF).
//
VOID EditML_IchToXYPos(PED ped, HDC hdc, ICH ich, BOOL prevLine, LPPOINT ppt)
{
    int iline;
    ICH cch;
    int xPosition, yPosition;
    int xOffset;

    //
    // For horizontal scroll displacement on left justified text and
    // for indent on centered or right justified text
    //
    PSTR pText, pTextStart, pLineStart;

    //
    // Determine what line the character is on
    //
    iline = EditML_IchToLine(ped, ich);

    //
    // Calc. the yPosition now. Note that this may change by the height of one
    // char if the prevLine flag is set and the ICH is at the beginning of a line.
    //
    yPosition = (iline - ped->ichScreenStart) * ped->lineHeight + ped->rcFmt.top;

    //
    // Now determine the xPosition of the character
    //
    pTextStart = Edit_Lock(ped);

    if (prevLine && iline && (ich == ped->chLines[iline]) &&
            (!AWCOMPARECHAR(ped, pTextStart + (ich - 2) * ped->cbChar, 0x0D) ||
            !AWCOMPARECHAR(ped, pTextStart + (ich - 1) * ped->cbChar, 0x0A))) 
    {
        //
        // First char in the line. We want text extent upto end of the previous
        // line if we aren't at the 0th line.
        //
        iline--;

        yPosition = yPosition - ped->lineHeight;
        pLineStart = pTextStart + ped->chLines[iline] * ped->cbChar;

        //
        // Note that we are taking the position in front of any CRLFs in the
        // text.
        //
        cch = EditML_Line(ped, iline);

    } 
    else 
    {
        pLineStart = pTextStart + ped->chLines[iline] * ped->cbChar;
        pText = pTextStart + ich * ped->cbChar;

        //
        // Strip off CRLF or CRCRLF. Note that we may be pointing to a CR but in
        // which case we just want to strip off a single CR or 2 CRs.
        //

        //
        // We want pText to point to the first CR at the end of the line if
        // there is one. Thus, we will get an xPosition to the right of the last
        // visible char on the line otherwise we will be to the left of
        // character ich.
        //

        //
        // Check if we at the end of text
        //
        if (ich < ped->cch) 
        {
            if (ped->fAnsi) 
            {
                if (ich && *(WORD UNALIGNED *)(pText - 1) == 0x0A0D) 
                {
                    pText--;
                    if (ich > 2 && *(pText - 1) == 0x0D)
                    {
                        pText--;
                    }
                }
            } 
            else 
            {
                LPWSTR pwText = (LPWSTR)pText;

                if (ich && *(DWORD UNALIGNED *)(pwText - 1) == 0x000A000D) 
                {
                    pwText--;
                    if (ich > 2 && *(pwText - 1) == 0x0D)
                    {
                        pwText--;
                    }
                }

                pText = (LPSTR)pwText;
            }
        }

        if (pText < pLineStart)
        {
            pText = pLineStart;
        }

        cch = (ICH)(pText - pLineStart)/ped->cbChar;
    }

    //
    // Find out how many pixels we indent the line for funny formats
    //
    if (ped->pLpkEditCallout) 
    {
        //
        // Must find position at start of character offset cch from start of line.
        // This depends on the layout and the reading order
        //
        xPosition = ped->pLpkEditCallout->EditIchToXY(
                          (PED0)ped, hdc, pLineStart, EditML_Line(ped, iline), cch);
    } 
    else 
    {
        if (ped->format != ES_LEFT) 
        {
            xOffset = EditML_CalcXOffset(ped, hdc, iline);
        } 
        else 
        {
            xOffset = -(int)ped->xOffset;
        }

        xPosition = ped->rcFmt.left + xOffset +
                EditML_GetLineWidth(hdc, pLineStart, cch, ped);
    }

    Edit_Unlock(ped);

    ppt->x = xPosition;
    ppt->y = yPosition;

    return;
}


//---------------------------------------------------------------------------//
//
// EditML_MouseToIch AorW
//
// Returns the closest cch to where the mouse point is.  Also optionally
// returns lineindex in pline (So that we can tell if we are at the beginning
// of the line or end of the previous line.)
//
ICH EditML_MouseToIch(PED ped, HDC hdc, LPPOINT mousePt, LPICH pline)
{
    int xOffset;
    LPSTR pLineStart;
    int height = mousePt->y;
    int line; //WASINT
    int width = mousePt->x;
    ICH cch;
    ICH cLineLength;
    ICH cLineLengthNew;
    ICH cLineLengthHigh;
    ICH cLineLengthLow;
    ICH cLineLengthTemp;
    int textWidth;
    int iCurWidth;
    int lastHighWidth, lastLowWidth;

    //
    // First determine which line the mouse is pointing to.
    //
    line = ped->ichScreenStart;
    if (height <= ped->rcFmt.top) 
    {
        //
        // Either return 0 (the very first line, or one line before the top line
        // on the screen. Note that these are signed mins and maxes since we
        // don't expect (or allow) more than 32K lines.
        //
        line = max(0, line-1);
    } 
    else if (height >= ped->rcFmt.bottom) 
    {
        //
        // Are we below the last line displayed
        //
        line = min(line+(int)ped->ichLinesOnScreen, (int)(ped->cLines-1));
    } 
    else 
    {
        //
        // We are somewhere on a line visible on screen
        //
        line = min(line + (int)((height - ped->rcFmt.top) / ped->lineHeight),
                (int)(ped->cLines - 1));
    }

    //
    // Now determine what horizontal character the mouse is pointing to.
    //
    pLineStart = Edit_Lock(ped) + ped->chLines[line] * ped->cbChar;
    cLineLength = EditML_Line(ped, line); // Length is sans CRLF or CRCRLF
    TraceMsg(TF_STANDARD, "Edit: EditML_Line(ped=%x, line=%d) returned %d", ped, line, cLineLength);
    UserAssert((int)cLineLength >= 0);

    //
    // If the language pack is loaded, visual and logical character order
    // may differ.
    //
    if (ped->pLpkEditCallout) 
    {
        //
        // Use the language pack to find the character nearest the cursor.
        //
        cch = ped->chLines[line] + ped->pLpkEditCallout->EditMouseToIch
            ((PED0)ped, hdc, pLineStart, cLineLength, width);
    } 
    else 
    {
        //
        // xOffset will be a negative value for center and right justified lines.
        // ie. We will just displace the lines left by the amount of indent for
        // right and center justification. Note that ped->xOffset will be 0 for
        // these lines since we don't support horizontal scrolling with them.
        //
        if (ped->format != ES_LEFT) 
        {
            xOffset = EditML_CalcXOffset(ped, hdc, line);
        } 
        else 
        {
            //
            // So that we handle a horizontally scrolled window for left justified
            // text.
            //
            xOffset = 0;
        }

        width = width - xOffset;

        //
        // The code below is tricky... I depend on the fact that ped->xOffset is 0
        // for right and center justified lines
        //

        //
        // Now find out how many chars fit in the given width
        //
        if (width >= ped->rcFmt.right) 
        {
            //
            // Return 1+last char in line or one plus the last char visible
            //
            cch = Edit_CchInWidth(ped, hdc, pLineStart, cLineLength,
                    ped->rcFmt.right - ped->rcFmt.left + ped->xOffset, TRUE);

            //
            // Consider DBCS in case of width >= ped->rcFmt.right
            //
            // Since Edit_CchInWidth and EditML_LineLength takes care of DBCS, we only need to
            // worry about if the last character is a double byte character or not.
            //
            // cch = ped->chLines[line] + min( Edit_NextIch(ped, pLineStart, cch), cLineLength);
            //
            // we need to adjust the position. LiZ -- 5/5/93
            //
            if (ped->fAnsi && ped->fDBCS) 
            {
                ICH cch2 = min(cch+1,cLineLength);
                if (Edit_AdjustIch(ped, pLineStart, cch2) != cch2) 
                {
                    //
                    // Displayed character on the right edge is DBCS
                    //
                    cch = min(cch+2,cLineLength);
                } 
                else 
                {
                    cch = cch2;
                }

                cch += ped->chLines[line];
            } 
            else 
            {
                cch = ped->chLines[line] + min(cch + 1, cLineLength);
            }
        } 
        else if (width <= ped->rcFmt.left + ped->aveCharWidth / 2) 
        {
            //
            // Return first char in line or one minus first char visible. Note that
            // ped->xOffset is 0 for right and centered text so we will just return
            // the first char in the string for them. (Allow a avecharwidth/2
            // positioning border so that the user can be a little off...
            //
            cch = Edit_CchInWidth(ped, hdc, pLineStart, cLineLength, ped->xOffset, TRUE);
            if (cch)
            {
                cch--;
            }

            cch = Edit_AdjustIch( ped, pLineStart, cch );
            cch += ped->chLines[line];
        } 
        else 
        {
            if (cLineLength == 0) 
            {
                cch = ped->chLines[line];
                goto edUnlock;
            }

            iCurWidth = width + ped->xOffset - ped->rcFmt.left;

            //
            // If the user clicked past the end of the text, return the last character
            //
            lastHighWidth = EditML_GetLineWidth(hdc, pLineStart, cLineLength, ped);
            if (lastHighWidth <= iCurWidth) 
            {
                cLineLengthNew = cLineLength;
                goto edAdjust;
            }

            //
            // Now the mouse is somewhere on the visible portion of the text
            // remember cch contains the length of the line.
            //
            cLineLengthLow = 0;
            cLineLengthHigh = cLineLength + 1;
            lastLowWidth = 0;

            while (cLineLengthLow < cLineLengthHigh - 1) 
            {
                cLineLengthNew = (cLineLengthHigh + cLineLengthLow) / 2;

                if (ped->fAnsi && ped->fDBCS) 
                {
                    //
                    // EditML_GetLineWidth returns meaningless value for truncated DBCS.
                    //
                    cLineLengthTemp = Edit_AdjustIch(ped, pLineStart, cLineLengthNew);
                    textWidth = EditML_GetLineWidth(hdc, pLineStart, cLineLengthTemp, ped);

                } 
                else 
                {
                    textWidth = EditML_GetLineWidth(hdc, pLineStart, cLineLengthNew, ped);
                }

                if (textWidth > iCurWidth) 
                {
                    cLineLengthHigh = cLineLengthNew;
                    lastHighWidth = textWidth;
                } 
                else 
                {
                    cLineLengthLow = cLineLengthNew;
                    lastLowWidth = textWidth;
                }
            }

            //
            // When the while ends, you can't know the exact desired position.
            // Try to see if the mouse pointer was on the farest half
            // of the char we got and if so, adjust cch.
            //
            if (cLineLengthLow == cLineLengthNew) 
            {
                //
                // Need to compare with lastHighWidth
                //
                if ((lastHighWidth - iCurWidth) < (iCurWidth - textWidth)) 
                {
                    cLineLengthNew++;
                }
            } 
            else 
            {
                //
                // Need to compare with lastLowHigh
                //
                if ((iCurWidth - lastLowWidth) < (textWidth - iCurWidth)) 
                {
                    cLineLengthNew--;
                }
            }
edAdjust:
            cLineLength = Edit_AdjustIch( ped, pLineStart, cLineLengthNew );

            cch = ped->chLines[line] + cLineLength;
        }
    }

edUnlock:
    Edit_Unlock(ped);

    if (pline) 
    {
        *pline = line;
    }

    return cch;
}


//---------------------------------------------------------------------------//
//
// EditML_ChangeSelection AorW
// 
// Changes the current selection to have the specified starting and
// ending values. Properly highlights the new selection and unhighlights
// anything deselected. If NewMinSel and NewMaxSel are out of order, we swap
// them. Doesn't update the caret position.
//
VOID EditML_ChangeSelection(PED ped, HDC hdc, ICH ichNewMinSel, ICH ichNewMaxSel)
{

    ICH temp;
    ICH ichOldMinSel, ichOldMaxSel;

    if (ichNewMinSel > ichNewMaxSel) 
    {
        temp = ichNewMinSel;
        ichNewMinSel = ichNewMaxSel;
        ichNewMaxSel = temp;
    }

    ichNewMinSel = min(ichNewMinSel, ped->cch);
    ichNewMaxSel = min(ichNewMaxSel, ped->cch);

    //
    // Save the current selection
    //
    ichOldMinSel = ped->ichMinSel;
    ichOldMaxSel = ped->ichMaxSel;

    //
    // Set new selection
    //
    ped->ichMinSel = ichNewMinSel;
    ped->ichMaxSel = ichNewMaxSel;

    //
    // This finds the XOR of the old and new selection regions and redraws it.
    // There is nothing to repaint if we aren't visible or our selection
    // is hidden.
    //
    if (IsWindowVisible(ped->hwnd) && (ped->fFocus || ped->fNoHideSel)) 
    {

        SELBLOCK Blk[2];
        int i;

        if (ped->fFocus) 
        {
            HideCaret(ped->hwnd);
        }

        Blk[0].StPos = ichOldMinSel;
        Blk[0].EndPos = ichOldMaxSel;
        Blk[1].StPos = ped->ichMinSel;
        Blk[1].EndPos = ped->ichMaxSel;

        if (Edit_CalcChangeSelection(ped, ichOldMinSel, ichOldMaxSel, (LPSELBLOCK)&Blk[0], (LPSELBLOCK)&Blk[1])) 
        {
            //
            // Paint both Blk[0] and Blk[1], if they exist
            //
            for (i = 0; i < 2; i++) 
            {
                if (Blk[i].StPos != 0xFFFFFFFF)
                    EditML_DrawText(ped, hdc, Blk[i].StPos, Blk[i].EndPos, TRUE);
            }
        }

        //
        // Update caret.
        //
        EditML_SetCaretPosition(ped, hdc);

        if (ped->fFocus) 
        {
            ShowCaret(ped->hwnd);
        }
    }
}


//---------------------------------------------------------------------------//
//
// EditML_UpdateiCaretLine AorW
// 
// This updates the ped->iCaretLine field from the ped->ichCaret;
// Also, when the caret gets to the beginning of next line, pop it up to
// the end of current line when inserting text;
//
VOID EditML_UpdateiCaretLine(PED ped)
{
    PSTR pText;

    ped->iCaretLine = EditML_IchToLine(ped, ped->ichCaret);

    //
    // If caret gets to beginning of next line, pop it up to end of current line
    // when inserting text.
    //
    pText = Edit_Lock(ped) +
            (ped->ichCaret - 1) * ped->cbChar;
    if (ped->iCaretLine && ped->chLines[ped->iCaretLine] == ped->ichCaret &&
            (!AWCOMPARECHAR(ped, pText - ped->cbChar, 0x0D) ||
            !AWCOMPARECHAR(ped, pText, 0x0A)))
    {
        ped->iCaretLine--;
    }

    Edit_Unlock(ped);
}


//---------------------------------------------------------------------------//
//
// EditML_InsertText AorW
//
// Adds up to cchInsert characters from lpText to the ped starting at
// ichCaret. If the ped only allows a maximum number of characters, then we
// will only add that many characters to the ped. The number of characters
// actually added is return ed (could be 0). If we can't allocate the required
// space, we notify the parent with EN_ERRSPACE and no characters are added.
// do some stuff faster since we will be getting only one or two chars of input.
//
ICH EditML_InsertText(PED ped, LPSTR lpText, ICH cchInsert, BOOL fUserTyping)
{
    HDC hdc;
    ICH validCch = cchInsert;
    ICH oldCaret = ped->ichCaret;
    int oldCaretLine = ped->iCaretLine;
    BOOL fCRLF = FALSE;
    LONG ll, hl;
    POINT xyPosInitial;
    POINT xyPosFinal;
    HWND hwndSave = ped->hwnd;
    UNDO undo;
    ICH validCchTemp;

    xyPosInitial.x=0;
    xyPosInitial.y=0;
    xyPosFinal.x=0;
    xyPosFinal.y=0;

    if (validCch == 0)
    {
        return 0;
    }

    if (ped->cchTextMax <= ped->cch) 
    {
        //
        // When the max chars is reached already, notify parent
        // Fix for Bug #4183 -- 02/06/91 -- SANKAR --
        //
        Edit_NotifyParent(ped,EN_MAXTEXT);
        return 0;
    }

    //
    // Limit the amount of text we add
    //
    validCch = min(validCch, ped->cchTextMax - ped->cch);

    //
    // Make sure we don't split a CRLF in half
    //
    if (validCch) 
    {
        if (ped->fAnsi) 
        {
            if (*(WORD UNALIGNED *)(lpText + validCch - 1) == 0x0A0D)
            {
                validCch--;
            }
        } 
        else 
        {
            if (*(DWORD UNALIGNED *)(lpText + (validCch - 1) * ped->cbChar) == 0x000A000D)
            {
                validCch--;
            }
        }
    }

    if (!validCch) 
    {
        //
        // When the max chars is reached already, notify parent
        // Fix for Bug #4183 -- 02/06/91 -- SANKAR --
        //
        Edit_NotifyParent(ped,EN_MAXTEXT);
        return 0;
    }

    if (validCch == 2) 
    {
        if (ped->fAnsi) 
        {
            if (*(WORD UNALIGNED *)lpText == 0x0A0D)
            {
                fCRLF = TRUE;
            }
        } 
        else 
        {
            if (*(DWORD UNALIGNED *)lpText == 0x000A000D)
            {
                fCRLF = TRUE;
            }
        }
    }

    //
    // Save current undo state always, but clear it out only if !AutoVScroll
    //
    Edit_SaveUndo(Pundo(ped), (PUNDO)&undo, !ped->fAutoVScroll);

    hdc = Edit_GetDC(ped, FALSE);

    //
    // We only need the y position. Since with an LPK loaded
    // calculating the x position is an intensive job, just
    // call EditML_IchToYPos.
    //
    if (ped->cch)
    {
        if (ped->pLpkEditCallout)
        {
            xyPosInitial.y = EditML_IchToYPos(ped, ped->cch-1, FALSE);
        }
        else
        {
            EditML_IchToXYPos(ped, hdc, ped->cch - 1, FALSE, &xyPosInitial);
        }
    }

    //
    // Insert the text
    //
    validCchTemp = validCch;    // may not be needed, but just for precautions..
    if (!Edit_InsertText(ped, lpText, &validCchTemp)) 
    {
        //
        // Restore previous undo buffer if it was cleared
        //
        if (!ped->fAutoVScroll)
        {
            Edit_SaveUndo((PUNDO)&undo, Pundo(ped), FALSE);
        }

        Edit_ReleaseDC(ped, hdc, FALSE);
        Edit_NotifyParent(ped, EN_ERRSPACE);

        return 0;
    }

#if DBG
    if (validCch != validCchTemp) 
    {
        //
        // All characters in lpText has not been inserted to ped.
        // This could happen when cch is close to cchMax.
        // Better revisit this after NT5 ships.
        //
        TraceMsg(TF_STANDARD, "Edit: EditML_InsertText: validCch is changed (%x -> %x) in Edit_InsertText.",
            validCch, validCchTemp);
    }
#endif

    //
    // Note that ped->ichCaret is updated by Edit_InsertText
    //
    EditML_BuildchLines(ped, (ICH)oldCaretLine, (int)validCch, fCRLF?(BOOL)FALSE:fUserTyping, &ll, &hl);

    if (ped->cch)
    {
        //
        // We only need the y position. Since with an LPK loaded
        // calculating the x position is an intensive job, just
        // call EditML_IchToYPos.
        if (ped->pLpkEditCallout)
        {
            xyPosFinal.y = EditML_IchToYPos(ped, ped->cch-1, FALSE);
        }
        else
        {
            EditML_IchToXYPos(ped, hdc, ped->cch - 1, FALSE,&xyPosFinal);
        }
    }

    if (xyPosFinal.y < xyPosInitial.y && ((ICH)ped->ichScreenStart) + ped->ichLinesOnScreen >= ped->cLines - 1) 
    {
        RECT rc;

        CopyRect((LPRECT)&rc, (LPRECT)&ped->rcFmt);
        rc.top = xyPosFinal.y + ped->lineHeight;
        if (ped->pLpkEditCallout) 
        {
            int xFarOffset = ped->xOffset + ped->rcFmt.right - ped->rcFmt.left;

            //
            // Include left or right margins in display unless clipped
            // by horizontal scrolling.
            //
            if (ped->wLeftMargin) 
            {
                if (!(ped->format == ES_LEFT     // Only ES_LEFT (Nearside alignment) can get clipped
                      && (   (!ped->fRtoLReading && ped->xOffset > 0)  // LTR and first char not fully in view
                          || ( ped->fRtoLReading && xFarOffset < ped->maxPixelWidth)))) //RTL and last char not fully in view
                { 
                    rc.left  -= ped->wLeftMargin;
                }
            }

            //
            // Process right margin
            //
            if (ped->wRightMargin) 
            {
                if (!(ped->format == ES_LEFT     // Only ES_LEFT (Nearside alignment) can get clipped
                      && (( ped->fRtoLReading && ped->xOffset > 0)  // RTL and first char not fully in view
                          || (!ped->fRtoLReading && xFarOffset < ped->maxPixelWidth)))) // LTR and last char not fully in view
                { 
                    rc.right += ped->wRightMargin;
                }
            }
        }

        InvalidateRect(ped->hwnd, (LPRECT)&rc, TRUE);
    }

    if (!ped->fAutoVScroll) 
    {
        if (ped->ichLinesOnScreen < ped->cLines) 
        {
            EditML_Undo(ped);
            Edit_EmptyUndo(Pundo(ped));

            Edit_SaveUndo(&undo, Pundo(ped), FALSE);

            MessageBeep(0);
            Edit_ReleaseDC(ped, hdc, FALSE);

            //
            // When the max lines is reached already, notify parent
            // Fix for Bug #7586 -- 10/14/91 -- SANKAR --
            //
            Edit_NotifyParent(ped,EN_MAXTEXT);

            return 0;
        } 
        else 
        {
            Edit_EmptyUndo(&undo);
        }
    }

    if (fUserTyping && ped->fWrap) 
    {
        //
        // To avoid oldCaret points intermediate of DBCS character,
        // adjust oldCaret position if necessary.
        //
        // !!!CR If EditML_BuildchLines() returns reasonable value ( and I think
        //       it does), we don't probably need this. Check this out later.
        //
        if (ped->fDBCS && ped->fAnsi) 
        {
            oldCaret = Edit_AdjustIch(ped,
                                   Edit_Lock(ped),
                                   min((ICH)LOWORD(ll),oldCaret));
        } 
        else 
        {
            oldCaret = min((ICH)LOWORD(ll), oldCaret);
        }
    }

    //
    // Update ped->iCaretLine properly.
    //
    EditML_UpdateiCaretLine(ped);

    Edit_NotifyParent(ped, EN_UPDATE);

    //
    // Make sure window still exists.
    //
    if (!IsWindow(hwndSave))
    {
        return 0;
    }

    if (IsWindowVisible(ped->hwnd)) 
    {
        //
        // If the current font has negative A widths, we may have to start
        // drawing a few characters before the oldCaret position.
        //
        if (ped->wMaxNegAcharPos) 
        {
            int iLine = EditML_IchToLine(ped, oldCaret);
            oldCaret = max( ((int)(oldCaret - ped->wMaxNegAcharPos)),
                          ((int)(ped->chLines[iLine])));
        }

        //
        // Redraw to end of screen/text if CRLF or large insert
        //
        if (fCRLF || !fUserTyping) 
        {
            //
            // Redraw to end of screen/text if crlf or large insert.
            //
            EditML_DrawText(ped, hdc, (fUserTyping ? oldCaret : 0), ped->cch, FALSE);
        } 
        else
        {
            EditML_DrawText(ped, hdc, oldCaret, max(ped->ichCaret, (ICH)hl), FALSE);
        }
    }

    Edit_ReleaseDC(ped, hdc, FALSE);

    //
    // Make sure we can see the cursor
    //
    EditML_EnsureCaretVisible(ped);

    ped->fDirty = TRUE;

    Edit_NotifyParent(ped, EN_CHANGE);

    if (validCch < cchInsert)
    {
        Edit_NotifyParent(ped, EN_MAXTEXT);
    }

    if (validCch) 
    {
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }

    //
    // Make sure the window still exists.
    //
    return IsWindow(hwndSave) ? validCch : 0;
}


//---------------------------------------------------------------------------//
//
// EditML_ReplaceSel
// 
// Replaces currently selected text with the passed in text, WITH UNDO
// CAPABILITIES.
//
VOID EditML_ReplaceSel(PED ped, LPSTR lpText)
{
    ICH  cchText;

    //
    // Delete text, which will put it into the clean undo buffer.
    //
    Edit_EmptyUndo(Pundo(ped));
    EditML_DeleteText(ped);

    //
    // B#3356
    // Some apps do "clear" by selecting all of the text, then replacing
    // it with "", in which case EditML_InsertText() will return 0.  But that
    // doesn't mean failure...
    //
    if ( ped->fAnsi )
    {
        cchText = strlen(lpText);
    }
    else
    {
        cchText = wcslen((LPWSTR)lpText);
    }

    if (cchText) 
    {
        BOOL fFailed;
        UNDO undo;
        HWND hwndSave;

        //
        // B#1385,1427
        // Save undo buffer, but DO NOT CLEAR IT.  We want to restore it
        // if insertion fails due to OOM.
        //
        Edit_SaveUndo(Pundo(ped), (PUNDO)&undo, FALSE);

        hwndSave = ped->hwnd;
        fFailed = (BOOL) !EditML_InsertText(ped, lpText, cchText, FALSE);
        if (!IsWindow(hwndSave))
        {
            return;
        }

        if (fFailed) 
        {
            //
            // UNDO the previous edit
            //
            Edit_SaveUndo((PUNDO)&undo, Pundo(ped), FALSE);
            EditML_Undo(ped);
        }
    }
}


//---------------------------------------------------------------------------//
// 
// EditML_DeleteText AorW
//
// Deletes the characters between ichMin and ichMax. Returns the
// number of characters we deleted.
//
ICH EditML_DeleteText(PED ped)
{
    ICH minSel = ped->ichMinSel;
    ICH maxSel = ped->ichMaxSel;
    ICH cchDelete;
    HDC hdc;
    int minSelLine;
    int maxSelLine;
    POINT xyPos;
    RECT rc;
    BOOL fFastDelete = FALSE;
    LONG hl;
    INT  cchcount = 0;

    //
    // Get what line the min selection is on so that we can start rebuilding the
    // text from there if we delete anything.
    //
    minSelLine = EditML_IchToLine(ped, minSel);
    maxSelLine = EditML_IchToLine(ped, maxSel);

    //
    // Calculate fFastDelete and cchcount
    //
    if (ped->fAnsi && ped->fDBCS) 
    {
        if ((ped->fAutoVScroll) &&
            (minSelLine == maxSelLine) &&
            (ped->chLines[minSelLine] != minSel)  &&
            (Edit_NextIch(ped,NULL,minSel) == maxSel)) 
        {

                fFastDelete = TRUE;
                cchcount = ((maxSel - minSel) == 1) ? 0 : -1;
        }
    } 
    else if (((maxSel - minSel) == 1) && (minSelLine == maxSelLine) && (ped->chLines[minSelLine] != minSel)) 
    {
        fFastDelete = ped->fAutoVScroll ? TRUE : FALSE;
    }

    cchDelete = Edit_DeleteText(ped);
    if (!cchDelete)
    {
        return 0;
    }

    //
    // Start building lines at minsel line since caretline may be at the max sel
    // point.
    //
    if (fFastDelete) 
    {
        //
        // cchcount is (-1) if it's a double byte character
        //
        EditML_ShiftchLines(ped, minSelLine + 1, -2 + cchcount);
        EditML_BuildchLines(ped, minSelLine, 1, TRUE, NULL, &hl);
    } 
    else 
    {
        EditML_BuildchLines(ped, max(minSelLine-1,0), -(int)cchDelete, FALSE, NULL, NULL);
    }

    EditML_UpdateiCaretLine(ped);

    Edit_NotifyParent(ped, EN_UPDATE);

    if (IsWindowVisible(ped->hwnd)) 
    {
        //
        // Now update the screen to reflect the deletion
        //
        hdc = Edit_GetDC(ped, FALSE);

        //
        // Otherwise just redraw starting at the line we just entered
        //
        minSelLine = max(minSelLine-1,0);
        EditML_DrawText(ped, hdc, ped->chLines[minSelLine], fFastDelete ? hl : ped->cch, FALSE);

        CopyRect(&rc, &ped->rcFmt);
        rc.left  -= ped->wLeftMargin;
        rc.right += ped->wRightMargin;

        if (ped->cch) 
        {
            //
            //  Clear from end of text to end of window.
            //  
            //  We only need the y position. Since with an LPK loaded
            //  calculating the x position is an intensive job, just
            //  call EditML_IchToYPos.
            //
            if (ped->pLpkEditCallout)
            {
                xyPos.y = EditML_IchToYPos(ped, ped->cch, FALSE);
            }
            else
            {
                EditML_IchToXYPos(ped, hdc, ped->cch, FALSE, &xyPos);
            }

            rc.top = xyPos.y + ped->lineHeight;
        }

        InvalidateRect(ped->hwnd, &rc, TRUE);
        Edit_ReleaseDC(ped, hdc, FALSE);

        EditML_EnsureCaretVisible(ped);
    }

    ped->fDirty = TRUE;

    Edit_NotifyParent(ped, EN_CHANGE);

    if (cchDelete)
    {
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }

    return cchDelete;
}


//---------------------------------------------------------------------------//
//
// EditML_InsertchLine AorW
//
// Inserts the line iline and sets its starting character index to be
// ich. All the other line indices are moved up. Returns TRUE if successful
// else FALSE and notifies the parent that there was no memory.
//
BOOL EditML_InsertchLine(PED ped, ICH iLine, ICH ich, BOOL fUserTyping)
{
    DWORD dwSize;

    if (fUserTyping && iLine < ped->cLines) 
    {
        ped->chLines[iLine] = ich;
        return TRUE;
    }

    dwSize = (ped->cLines + 2) * sizeof(int);

    if (dwSize > UserLocalSize(ped->chLines)) 
    {
        LPICH hResult;

        //
        // Grow the line index buffer
        //
        dwSize += LINEBUMP * sizeof(int);
        hResult = (LPICH)UserLocalReAlloc(ped->chLines, dwSize, 0);

        if (!hResult) 
        {
            Edit_NotifyParent(ped, EN_ERRSPACE);
            return FALSE;
        }
        ped->chLines = hResult;
    }

    //
    // Move indices starting at iLine up
    //
    if (ped->cLines != iLine)
    {
        RtlMoveMemory(&ped->chLines[iLine + 1], &ped->chLines[iLine],
                (ped->cLines - iLine)*SIZEOF(INT));
    }

    ped->cLines++;
    ped->chLines[iLine] = ich;

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// EditML_ShiftchLines AorW
//
// Move the starting index of all lines iLine or greater by delta
// bytes.
//
void EditML_ShiftchLines(PED ped, ICH iLine, int delta)
{
    if (iLine < ped->cLines)
    {
        //
        // Just add delta to the starting point of each line after iLine
        //
        for (; iLine < ped->cLines; iLine++)
        {
            ped->chLines[iLine] += delta;
        }
    }
}


//---------------------------------------------------------------------------//
//
// EditML_BuildchLines AorW
// 
// Rebuilds the start of line array (ped->chLines) starting at line
// number ichLine.
//
void EditML_BuildchLines( PED ped, ICH iLine, int cchDelta, BOOL fUserTyping, PLONG pll, PLONG phl)
{
    PSTR ptext;     // Starting address of the text

    //
    // We keep these ICH's so that we can Unlock ped->hText when we have to grow
    // the chlines array. With large text handles, it becomes a problem if we
    // have a locked block in the way.
    //
    ICH ichLineStart;
    ICH ichLineEnd;
    ICH ichLineEndBeforeCRLF;
    ICH ichCRLF;

    ICH cch;
    HDC hdc;

    BOOL fLineBroken = FALSE;   // Initially, no new line breaks are made
    ICH minCchBreak;
    ICH maxCchBreak;
    BOOL fOnDelimiter;

    if (!ped->cch) 
    {
        ped->maxPixelWidth = 0;
        ped->xOffset = 0;
        ped->ichScreenStart = 0;
        ped->cLines = 1;

        if (pll)
        {
            *pll = 0;
        }

        if (phl)
        {
            *phl = 0;
        }

        goto UpdateScroll;
    }

    if (fUserTyping && cchDelta)
    {
        EditML_ShiftchLines(ped, iLine + 1, cchDelta);
    }

    hdc = Edit_GetDC(ped, TRUE);

    if (!iLine && !cchDelta && !fUserTyping) 
    {
        //
        // Reset maxpixelwidth only if we will be running through the whole
        // text. Better too long than too short.
        //
        ped->maxPixelWidth = 0;

        //
        // Reset number of lines in text since we will be running through all
        // the text anyway...
        //
        ped->cLines = 1;
    }

    //
    // Set min and max line built to be the starting line
    //
    minCchBreak = maxCchBreak = (cchDelta ? ped->chLines[iLine] : 0);

    ptext = Edit_Lock(ped);

    ichCRLF = ichLineStart = ped->chLines[iLine];

    while (ichLineStart < ped->cch) 
    {
        if (ichLineStart >= ichCRLF) 
        {
            ichCRLF = ichLineStart;

            //
            // Move ichCRLF ahead to either the first CR or to the end of text.
            //
            if (ped->fAnsi) 
            {
                while (ichCRLF < ped->cch) 
                {
                    if (*(ptext + ichCRLF) == 0x0D) 
                    {
                        if (*(ptext + ichCRLF + 1) == 0x0A ||
                                *(WORD UNALIGNED *)(ptext + ichCRLF + 1) == 0x0A0D)
                        {
                            break;
                        }
                    }

                    ichCRLF++;
                }
            } 
            else 
            {
                LPWSTR pwtext = (LPWSTR)ptext;

                while (ichCRLF < ped->cch) 
                {
                    if (*(pwtext + ichCRLF) == 0x0D) 
                    {
                        if (*(pwtext + ichCRLF + 1) == 0x0A ||
                                *(DWORD UNALIGNED *)(pwtext + ichCRLF + 1) == 0x000A000D)
                        {
                            break;
                        }
                    }

                    ichCRLF++;
                }
            }
        }

        if (!ped->fWrap) 
        {
            UINT  LineWidth;

            //
            // If we are not word wrapping, line breaks are signified by CRLF.
            //

            //
            // If we cut off the line at MAXLINELENGTH, we should
            // adjust ichLineEnd.
            //
            if ((ichCRLF - ichLineStart) <= MAXLINELENGTH) 
            {
                ichLineEnd = ichCRLF;
            } 
            else 
            {
                ichLineEnd = ichLineStart + MAXLINELENGTH;

                if (ped->fAnsi && ped->fDBCS) 
                {
                    ichLineEnd = Edit_AdjustIch( ped, (PSTR)ptext, ichLineEnd);
                }
            }

            //
            // We will keep track of what the longest line is for the horizontal
            // scroll bar thumb positioning.
            //
            if (ped->pLpkEditCallout) 
            {
                LineWidth = ped->pLpkEditCallout->EditGetLineWidth(
                    (PED0)ped, hdc, ptext + ichLineStart*ped->cbChar,
                    ichLineEnd - ichLineStart);
            } 
            else 
            {
                LineWidth = EditML_GetLineWidth(hdc, ptext + ichLineStart * ped->cbChar,
                                            ichLineEnd - ichLineStart,
                                            ped);
            }

            ped->maxPixelWidth = max(ped->maxPixelWidth,(int)LineWidth);

        } 
        else 
        {
            //
            // Check if the width of the edit control is non-zero;
            // a part of the fix for Bug #7402 -- SANKAR -- 01/21/91 --
            //
            if(ped->rcFmt.right > ped->rcFmt.left) 
            {
                //
                // Find the end of the line based solely on text extents
                //
                if (ped->pLpkEditCallout) 
                {
                    ichLineEnd = ichLineStart +
                        ped->pLpkEditCallout->EditCchInWidth(
                            (PED0)ped, hdc, ptext + ped->cbChar*ichLineStart,
                            ichCRLF - ichLineStart,
                            ped->rcFmt.right - ped->rcFmt.left);
                } 
                else 
                {
                    if (ped->fAnsi) 
                    {
                        ichLineEnd = ichLineStart +
                                 Edit_CchInWidth(ped, hdc,
                                              ptext + ichLineStart,
                                              ichCRLF - ichLineStart,
                                              ped->rcFmt.right - ped->rcFmt.left,
                                              TRUE);
                    } 
                    else 
                    {
                        ichLineEnd = ichLineStart +
                                 Edit_CchInWidth(ped, hdc,
                                              (LPSTR)((LPWSTR)ptext + ichLineStart),
                                              ichCRLF - ichLineStart,
                                              ped->rcFmt.right - ped->rcFmt.left,
                                              TRUE);
                    }
                }
            } 
            else 
            {
                ichLineEnd = ichLineStart;
            }

            if (ichLineEnd == ichLineStart && ichCRLF - ichLineStart) 
            {
                //
                // Maintain a minimum of one char per line
                // Since it might be a double byte char, so calling Edit_NextIch.
                //
                ichLineEnd = Edit_NextIch(ped, NULL, ichLineEnd);
            }

            //
            // Now starting from ichLineEnd, if we are not at a hard line break,
            // then if we are not at a space AND the char before us is
            // not a space,(OR if we are at a CR) we will look word left for the
            // start of the word to break at.
            // This change was done for TWO reasons:
            // 1. If we are on a delimiter, no need to look word left to break at.
            // 2. If the previous char is a delimter, we can break at current char.
            // Change done by -- SANKAR --01/31/91--
            //
            if (ichLineEnd != ichCRLF) 
            {
                if(ped->lpfnNextWord) 
                {
                     fOnDelimiter = (CALLWORDBREAKPROC(*ped->lpfnNextWord, ptext,
                            ichLineEnd, ped->cch, WB_ISDELIMITER) ||
                            CALLWORDBREAKPROC(*ped->lpfnNextWord, ptext, ichLineEnd - 1,
                            ped->cch, WB_ISDELIMITER));

                    //
                    // This change was done for FOUR reasons:
                    //
                    // 1. If we are on a delimiter, no need to look word left to break at.
                    // 2. If we are on a double byte character, we can break at current char.
                    // 3. If the previous char is a delimter, we can break at current char.
                    // 4. If the previous char is a double byte character, we can break at current char.
                    //
                } 
                else if (ped->fAnsi) 
                {
                    fOnDelimiter = (ISDELIMETERA(*(ptext + ichLineEnd)) ||
                                    Edit_IsDBCSLeadByte(ped, *(ptext + ichLineEnd)));

                    if (!fOnDelimiter) 
                    {
                        PSTR pPrev = Edit_AnsiPrev(ped,ptext,ptext+ichLineEnd);

                        fOnDelimiter = ISDELIMETERA(*pPrev) ||
                                       Edit_IsDBCSLeadByte(ped,*pPrev);
                    }
                } 
                else 
                { 
                    fOnDelimiter = (ISDELIMETERW(*((LPWSTR)ptext + ichLineEnd))     ||
                                    Edit_IsFullWidth(CP_ACP,*((LPWSTR)ptext + ichLineEnd))      ||
                                    ISDELIMETERW(*((LPWSTR)ptext + ichLineEnd - 1)) ||
                                    Edit_IsFullWidth(CP_ACP,*((LPWSTR)ptext + ichLineEnd - 1)));
                }

                if (!fOnDelimiter ||
                    (ped->fAnsi && *(ptext + ichLineEnd) == 0x0D) ||
                    (!ped->fAnsi && *((LPWSTR)ptext + ichLineEnd) == 0x0D)) 
                {
                    if (ped->lpfnNextWord != NULL) 
                    {
                        cch = CALLWORDBREAKPROC(*ped->lpfnNextWord, (LPSTR)ptext, ichLineEnd,
                                ped->cch, WB_LEFT);
                    } 
                    else 
                    {
                        ped->fCalcLines = TRUE;
                        Edit_Word(ped, ichLineEnd, TRUE, &cch, NULL);
                        ped->fCalcLines = FALSE;
                    }

                    if (cch > ichLineStart) 
                    {
                        ichLineEnd = cch;
                    }

                    //
                    // Now, if the above test fails, it means the word left goes
                    // back before the start of the line ie. a word is longer
                    // than a line on the screen. So, we just fit as much of
                    // the word on the line as possible. Thus, we use the
                    // pLineEnd we calculated solely on width at the beginning
                    // of this else block...
                    //
                }
            }
        }

        if (AWCOMPARECHAR(ped,ptext + ichLineEnd * ped->cbChar, ' ') ||
                AWCOMPARECHAR(ped,ptext + ichLineEnd * ped->cbChar, VK_TAB)) 
        {
            //
            // Swallow the space at the end of a line.
            //
            if (ichLineEnd < ped->cch) 
            {
                ichLineEnd++;
            }
        }

        //
        // Skip over crlf or crcrlf if it exists. Thus, ichLineEnd is the first
        // character in the next line.
        //
        ichLineEndBeforeCRLF = ichLineEnd;

        if (ped->fAnsi) 
        {
            if (ichLineEnd < ped->cch && *(ptext + ichLineEnd) == 0x0D)
            {
                ichLineEnd += 2;
            }

            //
            // Skip over CRCRLF
            //
            if (ichLineEnd < ped->cch && *(ptext + ichLineEnd) == 0x0A)
            {
                ichLineEnd++;
            }
        } 
        else 
        {
            if (ichLineEnd < ped->cch && *(((LPWSTR)ptext) + ichLineEnd) == 0x0D)
            {
                ichLineEnd += 2;
            }

            //
            // Skip over CRCRLF
            //
            if (ichLineEnd < ped->cch && *(((LPWSTR)ptext) + ichLineEnd) == 0x0A) 
            {
                ichLineEnd++;
                TraceMsg(TF_STANDARD, "Edit: Skip over CRCRLF");
            }
        }
#if DBG
        if (ichLineEnd > ped->cch)
        {
            TraceMsg(TF_STANDARD, "Edit: ichLineEnd (%d)> ped->cch (%d)", ichLineEnd, ped->cch);
        }
#endif

        //
        // Now, increment iLine, allocate space for the next line, and set its
        // starting point
        //
        iLine++;

        if (!fUserTyping || (iLine > ped->cLines - 1) || (ped->chLines[iLine] != ichLineEnd)) 
        {
            //
            // The line break occured in a different place than before.
            //
            if (!fLineBroken) 
            {
                //
                // Since we haven't broken a line before, just set the min
                // break line.
                //
                fLineBroken = TRUE;

                if (ichLineEndBeforeCRLF == ichLineEnd)
                {
                    minCchBreak = maxCchBreak = (ichLineEnd ? ichLineEnd - 1 : 0);
                }
                else
                {
                    minCchBreak = maxCchBreak = ichLineEndBeforeCRLF;
                }
            }

            maxCchBreak = max(maxCchBreak, ichLineEnd);

            Edit_Unlock(ped);

            //
            // Now insert the new line into the array
            //
            if (!EditML_InsertchLine(ped, iLine, ichLineEnd, (BOOL)(cchDelta != 0)))
            {
                goto EndUp;
            }

            ptext = Edit_Lock(ped);
        } 
        else 
        {
            maxCchBreak = ped->chLines[iLine];

            //
            // Quick escape
            //
            goto UnlockAndEndUp;
        }

        ichLineStart = ichLineEnd;
    }


    if (iLine != ped->cLines) 
    {
        TraceMsg(TF_STANDARD, "Edit: chLines[%d] is being cleared.", iLine);
        ped->cLines = iLine;
        ped->chLines[ped->cLines] = 0;
    }

    //
    // Note that we incremented iLine towards the end of the while loop so, the
    // index, iLine, is actually equal to the line count
    //
    if (ped->cch && AWCOMPARECHAR(ped, ptext + (ped->cch - 1)*ped->cbChar, 0x0A) &&
            ped->chLines[ped->cLines - 1] < ped->cch) 
    {
        //
        // Make sure last line has no crlf in it
        //
        if (!fLineBroken) 
        {
            //
            // Since we haven't broken a line before, just set the min break
            // line.
            //
            fLineBroken = TRUE;
            minCchBreak = ped->cch - 1;
        }

        maxCchBreak = max(maxCchBreak, ichLineEnd);
        Edit_Unlock(ped);
        EditML_InsertchLine(ped, iLine, ped->cch, FALSE);
        EditML_SanityCheck(ped);
    } 
    else
    {
UnlockAndEndUp:
        Edit_Unlock(ped);
    }

EndUp:
    Edit_ReleaseDC(ped, hdc, TRUE);

    if (pll)
    {
        *pll = minCchBreak;
    }

    if (phl)
    {
        *phl = maxCchBreak;
    }

UpdateScroll:
    EditML_Scroll(ped, FALSE, ML_REFRESH, 0, TRUE);
    EditML_Scroll(ped, TRUE,  ML_REFRESH, 0, TRUE);

    EditML_SanityCheck(ped);

    return;
}


//---------------------------------------------------------------------------//
//
// EditML_Paint()
// 
// Response to WM_PAINT message.
//
VOID EditML_Paint(PED ped, HDC hdc, LPRECT lprc)
{
    HFONT  hOldFont;
    ICH    imin;
    ICH    imax;
    HBRUSH hbr;
    BOOL   fNeedDelete = FALSE;

    //
    // Do we need to draw the border ourself for old apps?
    //
    if (ped->fFlatBorder)
    {
        RECT    rcT;
        ULONG   ulStyle;
        INT     cxBorder;
        INT     cyBorder;
        INT     cxFrame;
        INT     cyFrame;

        ulStyle = GET_STYLE(ped);
        cxBorder = GetSystemMetrics(SM_CXBORDER);
        cyBorder = GetSystemMetrics(SM_CYBORDER);
        cxFrame  = GetSystemMetrics(SM_CXFRAME);
        cyFrame  = GetSystemMetrics(SM_CYFRAME);

        GetClientRect(ped->hwnd, &rcT);
        if (ulStyle & WS_SIZEBOX)
        {
            InflateRect(&rcT, cxBorder - cxFrame, cyBorder - cyFrame);
        }
        DrawFrame(hdc, &rcT, 1, DF_WINDOWFRAME);
    }

    Edit_SetClip(ped, hdc, (BOOL) (ped->xOffset == 0));

    if (ped->hFont)
    {
        hOldFont = SelectObject(hdc, ped->hFont);
    }

    if (!lprc) 
    {
        //
        // no partial rect given -- draw all text
        //
        imin = 0;
        imax = ped->cch;
    } 
    else 
    {
        //
        // only draw pertinent text
        //
        imin = (ICH) EditML_MouseToIch(ped, hdc, ((LPPOINT) &lprc->left), NULL) - 1;
        if (imin == -1)
        {
            imin = 0;
        }

        //
        // HACK_ALERT:
        // The 3 is required here because, EditML_MouseToIch() returns decremented
        // value; We must fix EditML_MouseToIch.
        //
        imax = (ICH) EditML_MouseToIch(ped, hdc, ((LPPOINT) &lprc->right), NULL) + 3;
        if (imax > ped->cch)
        {
            imax = ped->cch;
        }
    }

    hbr = Edit_GetBrush(ped, hdc, &fNeedDelete);
    if (hbr)
    {
        RECT rc;
        GetClientRect(ped->hwnd, &rc);
        FillRect(hdc, &rc, hbr);

        if (fNeedDelete)
        {
            DeleteObject(hbr);
        }
    }

    EditML_DrawText(ped, hdc, imin, imax, FALSE);

    if (ped->hFont)
    {
        SelectObject(hdc, hOldFont);
    }
}


//---------------------------------------------------------------------------//
//
// EditML_KeyDown AorW
// 
// Handles cursor movement and other VIRT KEY stuff. keyMods allows
// us to make EditML_KeyDownHandler calls and specify if the modifier keys (shift
// and control) are up or down. If keyMods == 0, we get the keyboard state
// using GetKeyState(VK_SHIFT) etc. Otherwise, the bits in keyMods define the
// state of the shift and control keys.
//
VOID EditML_KeyDown(PED ped, UINT virtKeyCode, int keyMods)
{
    HDC hdc;
    BOOL prevLine;
    POINT mousePt;
    int defaultDlgId;
    int iScrollAmt;

    //
    // Variables we will use for redrawing the updated text
    //

    //
    // new selection is specified by newMinSel, newMaxSel
    //
    ICH newMaxSel = ped->ichMaxSel;
    ICH newMinSel = ped->ichMinSel;

    //
    // Flags for drawing the updated text
    //
    BOOL changeSelection = FALSE;

    //
    // Comparisons we do often
    //
    BOOL MinEqMax = (newMaxSel == newMinSel);
    BOOL MinEqCar = (ped->ichCaret == newMinSel);
    BOOL MaxEqCar = (ped->ichCaret == newMaxSel);

    //
    // State of shift and control keys.
    //
    int scState;

    if (ped->fMouseDown) 
    {
        //
        // If we are in the middle of a mousedown command, don't do anything.
        //
        return;
    }

    if (ped->hwndBalloon)
    {
        Edit_HideBalloonTip(ped->hwnd);
    }

    scState = Edit_GetModKeys(keyMods);

    switch (virtKeyCode) 
    {
    case VK_ESCAPE:
        if (ped->fInDialogBox) 
        {
            //
            // This condition is removed because, if the dialogbox does not
            // have a CANCEL button and if ESC is hit when focus is on a
            // ML edit control the dialogbox must close whether it has cancel
            // button or not to be consistent with SL edit control;
            // DefDlgProc takes care of the disabled CANCEL button case.
            // Fix for Bug #4123 -- 02/07/91 -- SANKAR --
            //
            // User hit ESC...Send a close message (which in turn sends a
            // cancelID to the app in DefDialogProc...
            //
            PostMessage(ped->hwndParent, WM_CLOSE, 0, 0L);
        }

        return;

    case VK_RETURN:
        if (ped->fInDialogBox) 
        {
            //
            // If this multiline edit control is in a dialog box, then we want
            // the RETURN key to be sent to the default dialog button (if there
            // is one). CTRL-RETURN will insert a RETURN into the text. Note
            // that CTRL-RETURN automatically translates into a linefeed (0x0A)
            // and in the EditML_CharHandler, we handle this as if a return was
            // entered.
            //
            if (scState != CTRLDOWN) 
            {
                if (GET_STYLE(ped) & ES_WANTRETURN) 
                {
                    //
                    // This edit control wants cr to be inserted so break out of
                    // case.
                    //
                    return;
                }

                defaultDlgId = (int)(DWORD)LOWORD(SendMessage(ped->hwndParent,
                        DM_GETDEFID, 0, 0L));
                if (defaultDlgId) 
                {
                    HWND hwnd = GetDlgItem(ped->hwndParent, defaultDlgId);
                    if (hwnd) 
                    {
                        SendMessage(ped->hwndParent, WM_NEXTDLGCTL, (WPARAM)hwnd, 1L);
                        if (!ped->fFocus)
                        {
                            PostMessage(hwnd, WM_KEYDOWN, VK_RETURN, 0L);
                        }
                    }
                }
            }

            return;
        }

        break;

    case VK_TAB:

        //
        // If this multiline edit control is in a dialog box, then we want the
        // TAB key to take you to the next control, shift TAB to take you to the
        // previous control. We always want CTRL-TAB to insert a tab into the
        // edit control regardless of weather or not we're in a dialog box.
        //
        if (scState == CTRLDOWN)
        {
            EditML_Char(ped, virtKeyCode, keyMods);
        }
        else if (ped->fInDialogBox)
        {
            SendMessage(ped->hwndParent, WM_NEXTDLGCTL, scState == SHFTDOWN, 0L);
        }

        return;

    case VK_LEFT:

        //
        // If the caret isn't at the beginning, we can move left
        //
        if (ped->ichCaret) 
        {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) 
            {
                //
                // Move caret word left
                //
                Edit_Word(ped, ped->ichCaret, TRUE, &ped->ichCaret, NULL);
            } 
            else 
            {
                if (ped->pLpkEditCallout) 
                {
                    ped->ichCaret = Edit_MoveSelectionRestricted(ped, ped->ichCaret, TRUE);
                } 
                else 
                {
                    //
                    // Move caret char left
                    //
                    ped->ichCaret = Edit_MoveSelection(ped, ped->ichCaret, TRUE);
                }
            }

            //
            // Get new selection
            //
            if (scState & SHFTDOWN) 
            {
                if (MaxEqCar && !MinEqMax) 
                {
                    //
                    // Reduce selection
                    //
                    newMaxSel = ped->ichCaret;

                    UserAssert(newMinSel == ped->ichMinSel);
                }
                else 
                {
                    //
                    // Extend selection
                    //
                    newMinSel = ped->ichCaret;
                }
            } 
            else 
            {
                //
                // Clear selection
                //
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } 
        else 
        {
            //
            // If the user tries to move left and we are at the 0th
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) 
            {
                changeSelection = TRUE;
                newMaxSel = newMinSel = ped->ichCaret;
            }
        }

        break;

    case VK_RIGHT:

        //
        // If the caret isn't at the end, we can move right.
        //
        if (ped->ichCaret < ped->cch) 
        {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) 
            {
                //
                // Move caret word right
                //
                Edit_Word(ped, ped->ichCaret, FALSE, NULL, &ped->ichCaret);
            } 
            else 
            {
                //
                // Move caret char right
                //
                if (ped->pLpkEditCallout) 
                {
                    ped->ichCaret = Edit_MoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } 
                else 
                {
                    ped->ichCaret = Edit_MoveSelection(ped, ped->ichCaret, FALSE);
                }
            }

            //
            // Get new selection.
            //
            if (scState & SHFTDOWN) 
            {
                if (MinEqCar && !MinEqMax) 
                {
                    //
                    // Reduce selection
                    //
                    newMinSel = ped->ichCaret;

                    UserAssert(newMaxSel == ped->ichMaxSel);
                }
                else 
                {
                    //
                    // Extend selection
                    //
                    newMaxSel = ped->ichCaret;
                }
            } 
            else 
            {
                //
                // Clear selection
                //
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } 
        else 
        {
            //
            // If the user tries to move right and we are at the last
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) 
            {
                newMaxSel = newMinSel = ped->ichCaret;
                changeSelection = TRUE;
            }
        }

        break;

    case VK_UP:
    case VK_DOWN:
        if (ped->cLines - 1 != ped->iCaretLine &&
                ped->ichCaret == ped->chLines[ped->iCaretLine + 1])
        {
            prevLine = TRUE;
        }
        else
        {
            prevLine = FALSE;
        }

        hdc = Edit_GetDC(ped, TRUE);
        EditML_IchToXYPos(ped, hdc, ped->ichCaret, prevLine, &mousePt);
        Edit_ReleaseDC(ped, hdc, TRUE);
        mousePt.y += 1 + (virtKeyCode == VK_UP ? -ped->lineHeight : ped->lineHeight);

        if (!(scState & CTRLDOWN)) 
        {
            //
            // Send fake mouse messages to handle this
            // If VK_SHIFT is down, extend selection & move caret up/down
            // 1 line.  Otherwise, clear selection & move caret.
            //
            EditML_MouseMotion(ped, WM_LBUTTONDOWN,
                            !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);
            EditML_MouseMotion(ped, WM_LBUTTONUP,
                            !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);
        }

        break;

    case VK_HOME:
        //
        // Update caret.
        //
        if (scState & CTRLDOWN) 
        {
            //
            // Move caret to beginning of text.
            //
            ped->ichCaret = 0;
        } 
        else 
        {
            //
            // Move caret to beginning of line.
            //
            ped->ichCaret = ped->chLines[ped->iCaretLine];
        }

        //
        // Update selection.
        //
        newMinSel = ped->ichCaret;

        if (scState & SHFTDOWN) 
        {
            if (MaxEqCar && !MinEqMax) 
            {
                if (scState & CTRLDOWN)
                {
                    newMaxSel = ped->ichMinSel;
                }
                else 
                {
                    newMinSel = ped->ichMinSel;
                    newMaxSel = ped->ichCaret;
                }
            }
        } 
        else 
        {
            //
            // Clear selection
            //
            newMaxSel = ped->ichCaret;
        }

        changeSelection = TRUE;

        break;

    case VK_END:
        //
        // Update caret.
        //
        if (scState & CTRLDOWN) 
        {
            //
            // Move caret to end of text.
            //
            ped->ichCaret = ped->cch;
        } 
        else 
        {
            //
            // Move caret to end of line.
            //
            ped->ichCaret = ped->chLines[ped->iCaretLine] +
                EditML_Line(ped, ped->iCaretLine);
        }

        //
        // Update selection.
        //
        newMaxSel = ped->ichCaret;

        if (scState & SHFTDOWN) 
        {
            if (MinEqCar && !MinEqMax) 
            {
                //
                // Reduce selection
                //
                if (scState & CTRLDOWN) 
                {
                    newMinSel = ped->ichMaxSel;
                } 
                else 
                {
                    newMinSel = ped->ichCaret;
                    newMaxSel = ped->ichMaxSel;
                }
            }
        } 
        else 
        {
            //
            // Clear selection
            //
            newMinSel = ped->ichCaret;
        }

        changeSelection = TRUE;

        break;

    //
    // FE_IME // EC_INSERT_COMPOSITION_CHAR : EditML_KeyDown() : VK_HANJA support
    //
    case VK_HANJA:
        if ( HanjaKeyHandler( ped ) ) 
        {
            changeSelection = TRUE;
            newMinSel = ped->ichCaret;
            newMaxSel = ped->ichCaret + (ped->fAnsi ? 2 : 1);
        }

        break;

    case VK_PRIOR:
    case VK_NEXT:
        if (!(scState & CTRLDOWN)) 
        {
            //
            // Vertical scroll by one visual screen
            //
            hdc = Edit_GetDC(ped, TRUE);
            EditML_IchToXYPos(ped, hdc, ped->ichCaret, FALSE, &mousePt);
            Edit_ReleaseDC(ped, hdc, TRUE);
            mousePt.y += 1;

            SendMessage(ped->hwnd, WM_VSCROLL, virtKeyCode == VK_PRIOR ? SB_PAGEUP : SB_PAGEDOWN, 0L);

            //
            // Move the cursor there
            //
            EditML_MouseMotion(ped, WM_LBUTTONDOWN, !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);
            EditML_MouseMotion(ped, WM_LBUTTONUP,   !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);

        } 
        else 
        {
            //
            // Horizontal scroll by one screenful minus one char
            //
            iScrollAmt = ((ped->rcFmt.right - ped->rcFmt.left) / ped->aveCharWidth) - 1;
            if (virtKeyCode == VK_PRIOR)
            {
                //
                // For previous page
                //
                iScrollAmt *= -1;
            }

            SendMessage(ped->hwnd, WM_HSCROLL, MAKELONG(EM_LINESCROLL, iScrollAmt), 0);

            break;
        }

        break;

    case VK_DELETE:
        if (ped->fReadOnly)
        {
            break;
        }

        switch (scState) 
        {
        case NONEDOWN:

            //
            // Clear selection. If no selection, delete (clear) character
            // right
            //
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) 
            {
                //
                // Move cursor forwards and send a backspace message...
                //
                if (ped->pLpkEditCallout) 
                {
                    ped->ichMinSel = ped->ichCaret;
                    ped->ichMaxSel = Edit_MoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } 
                else 
                {
                    ped->ichCaret = Edit_MoveSelection(ped, ped->ichCaret, FALSE);
                    ped->ichMaxSel = ped->ichMinSel = ped->ichCaret;
                }

                goto DeleteAnotherChar;
            }

            break;

        case SHFTDOWN:

            //
            // CUT selection ie. remove and copy to clipboard, or if no
            // selection, delete (clear) character left.
            //
            if (ped->ichMinSel == ped->ichMaxSel) 
            {
                goto DeleteAnotherChar;
            } 
            else 
            {
                SendMessage(ped->hwnd, WM_CUT, (UINT)0, 0L);
            }

            break;

        case CTRLDOWN:

            //
            // Clear selection, or delete to end of line if no selection
            //
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) 
            {
                ped->ichMaxSel = ped->ichCaret = ped->chLines[ped->iCaretLine] +
                                                 EditML_Line(ped, ped->iCaretLine);
            }

            break;
        }

        if (!(scState & SHFTDOWN) && (ped->ichMinSel != ped->ichMaxSel)) 
        {

DeleteAnotherChar:
            if (Is400Compat(UserGetVersion())) 
            {
                EditML_Char(ped, VK_BACK, 0);
            } 
            else 
            {
                SendMessage(ped->hwnd, WM_CHAR, VK_BACK, 0);
            }
        }

        //
        // No need to update text or selection since BACKSPACE message does it
        // for us.
        //
        break;

    case VK_INSERT:
        if (scState == CTRLDOWN || scState == SHFTDOWN) 
        {
            //
            // if CTRLDOWN Copy current selection to clipboard
            //

            //
            // if SHFTDOWN Paste clipboard
            //
            SendMessage(ped->hwnd, (UINT)(scState == CTRLDOWN ? WM_COPY : WM_PASTE), 0, 0);
        }

        break;
    }

    if (changeSelection) 
    {
        hdc = Edit_GetDC(ped, FALSE);
        EditML_ChangeSelection(ped, hdc, newMinSel, newMaxSel);

        //
        // Set the caret's line
        //
        ped->iCaretLine = EditML_IchToLine(ped, ped->ichCaret);

        if (virtKeyCode == VK_END &&
                // Next line: Win95 Bug#11822, EditControl repaint (Sankar)
                (ped->ichCaret == ped->chLines[ped->iCaretLine]) &&
                ped->ichCaret < ped->cch &&
                ped->fWrap && ped->iCaretLine > 0) 
        {
            LPSTR pText = Edit_Lock(ped);

            //
            // Handle moving to the end of a word wrapped line. This keeps the
            // cursor from falling to the start of the next line if we have word
            // wrapped and there is no CRLF.
            //
            if ( ped->fAnsi ) 
            {
                if (*(WORD UNALIGNED *)(pText + ped->chLines[ped->iCaretLine] - 2) != 0x0A0D) 
                {
                    ped->iCaretLine--;
                }
            } 
            else 
            {
                if (*(DWORD UNALIGNED *)(pText +
                     (ped->chLines[ped->iCaretLine] - 2)*ped->cbChar) != 0x000A000D) 
                {
                    ped->iCaretLine--;
                }
            }

            Edit_Unlock(ped);
        }

        //
        // Since drawtext sets the caret position
        //
        EditML_SetCaretPosition(ped, hdc);
        Edit_ReleaseDC(ped, hdc, FALSE);

        //
        // Make sure we can see the cursor
        //
        EditML_EnsureCaretVisible(ped);
    }
}


//---------------------------------------------------------------------------//
// 
// EditML_Char
//
// Handles character and virtual key input
//
VOID EditML_Char(PED ped, DWORD keyValue, int keyMods)
{
    WCHAR keyPress;
    BOOL  updateText = FALSE;

    //
    // keyValue is either:
    // a Virtual Key (eg: VK_TAB, VK_ESCAPE, VK_BACK)
    // a character (Unicode or "ANSI")
    //
    if (ped->fAnsi)
    {
        keyPress = LOBYTE(keyValue);
    }
    else
    {
        keyPress = LOWORD(keyValue);
    }

    if (ped->fMouseDown || keyPress == VK_ESCAPE) 
    {
        //
        // If we are in the middle of a mousedown command, don't do anything.
        // Also, just ignore it if we get a translated escape key which happens
        // with multiline edit controls in a dialog box.
        //
        return;
    }

    Edit_InOutReconversionMode(ped, FALSE);

    {
        int scState;
        scState = Edit_GetModKeys(keyMods);

        if (ped->fInDialogBox && scState != CTRLDOWN) 
        {
            //
            // If this multiline edit control is in a dialog box, then we want the
            // TAB key to take you to the next control, shift TAB to take you to the
            // previous control, and CTRL-TAB to insert a tab into the edit control.
            // We moved the focus when we received the keydown message so we will
            // ignore the TAB key now unless the ctrl key is down. Also, we want
            // CTRL-RETURN to insert a return into the text and RETURN to be sent to
            // the default button.
            //
            if (keyPress == VK_TAB || (keyPress == VK_RETURN && !(GET_STYLE(ped) & ES_WANTRETURN)))
            {
                return;
            }
        }

        //
        // Allow CTRL+C to copy from a read only edit control
        // Ignore all other keys in read only controls
        //
        if ((ped->fReadOnly) && !((keyPress == 3) && (scState == CTRLDOWN))) 
        {
            return;
        }
    }

    switch (keyPress) 
    {
    case 0x0A: 
        // linefeed
        keyPress = VK_RETURN;

        //
        // FALL THRU
        //

    case VK_RETURN:
    case VK_TAB:
    case VK_BACK:
DeleteSelection:
        if (EditML_DeleteText(ped))
        {
            updateText = TRUE;
        }

        break;

    default:
        if (keyPress >= TEXT(' ')) 
        {
            //
            // If this is in [a-z],[A-Z] and we are an ES_NUMBER
            // edit field, bail.
            //
            if (Is400Compat(UserGetVersion()) && GET_STYLE(ped) & ES_NUMBER) 
            {
                if (!Edit_IsCharNumeric(ped, keyPress)) 
                {
                    Edit_ShowBalloonTipWrap(ped->hwnd, IDS_NUMERIC_TITLE, IDS_NUMERIC_MSG, TTI_ERROR);
                    goto IllegalChar;
                }
            }

            goto DeleteSelection;
        }

        break;
    }

    //
    // Handle key codes
    //
    switch(keyPress) 
    {
    UINT msg;

    // Ctrl+Z == Undo
    case 26:
        msg = WM_UNDO;
        goto SendEditingMessage;
        break;

    // Ctrl+X == Cut
    case 24:
        if (ped->ichMinSel == ped->ichMaxSel)
        {
            goto IllegalChar;
        }
        else
        {
            msg = WM_CUT;
            goto SendEditingMessage;
        }
        break;

    // Ctrl+C == Copy
    case 3:
        msg = WM_COPY;
        goto SendEditingMessage;
        break;

    // Ctrl+V == Paste
    case 22:
        msg = WM_PASTE;
SendEditingMessage:
        SendMessage(ped->hwnd, msg, 0, 0L);
        break;

    case VK_BACK:
        //
        // Delete any selected text or delete character left if no sel
        //
        if (!updateText && ped->ichMinSel)
        {
            //
            // There was no selection to delete so we just delete
            // character left if available
            //
            ped->ichMinSel = Edit_MoveSelection(ped, ped->ichCaret, TRUE);
            EditML_DeleteText(ped);
        }
        break;

    default:
        if (keyPress == VK_RETURN)
        {
            if (ped->fAnsi)
            {
                keyValue = 0x0A0D;
            }
            else
            {
                keyValue = 0x000A000D;
            }
        }

        if (   keyPress >= TEXT(' ')
            || keyPress == VK_RETURN
            || keyPress == VK_TAB
            || keyPress == 0x1E     // RS - Unicode block separator
            || keyPress == 0x1F     // US - Unicode segment separator
            ) 
        {

            // Don't hide the cursor if someone has capture. 
            if (GetCapture() == NULL)
            {
                SetCursor(NULL);
            }
            if (ped->fAnsi) 
            {
                //
                // check if it's a leading byte of double byte character
                //
                if (Edit_IsDBCSLeadByte(ped,(BYTE)keyPress)) 
                {
                    int DBCSkey;

                    DBCSkey = DbcsCombine(ped->hwnd, keyPress);
                    if ( DBCSkey != 0)
                    {
                        keyValue = DBCSkey;
                    }
                }

                EditML_InsertText(ped, (LPSTR)&keyValue, HIBYTE(keyValue) ? 2 : 1, TRUE);
            } 
            else
            {
                EditML_InsertText(ped, (LPSTR)&keyValue, HIWORD(keyValue) ? 2 : 1, TRUE);
            }

        } 
        else 
        {
IllegalChar:
            MessageBeep(0);
        }
        break;
    }
}


//---------------------------------------------------------------------------//
//
// EditML_PasteText AorW
//
// Pastes a line of text from the clipboard into the edit control
// starting at ped->ichCaret. Updates ichMaxSel and ichMinSel to point to the
// end of the inserted text. Notifies the parent if space cannot be
// allocated. Returns how many characters were inserted.
//
ICH EditML_PasteText(PED ped)
{
    HANDLE hData;
    LPSTR lpchClip;
    ICH cchAdded = 0;
    HCURSOR hCursorOld;

#ifdef UNDO_CLEANUP           // #ifdef Added in Chicago  - johnl
    if (!ped->fAutoVScroll) 
    {
        //
        // Empty the undo buffer if this edit control limits the amount of text
        // the user can add to the window rect. This is so that we can undo this
        // operation if doing in causes us to exceed the window boundaries.
        //
        Edit_EmptyUndo(ped);
    }
#endif

    hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (!OpenClipboard(ped->hwnd))
    {
        goto PasteExitNoCloseClip;
    }

    if (!(hData = GetClipboardData(ped->fAnsi ? CF_TEXT : CF_UNICODETEXT)) ||
            (GlobalFlags(hData) == GMEM_INVALID_HANDLE)) 
    {
        TraceMsg(TF_STANDARD, "Edit: EditML_PasteText(): couldn't get a valid handle(%x)", hData);
        goto PasteExit;
    }

    //
    // See if any text should be deleted
    //
    EditML_DeleteText(ped);

    lpchClip = GlobalLock(hData);
    if (lpchClip == NULL) 
    {
        TraceMsg(TF_STANDARD, "Edit: EditML_PasteText: USERGLOBALLOCK(%x) failed.", hData);
        goto PasteExit;
    }

    //
    // Get the length of the addition.
    //
    if (ped->fAnsi)
    {
        cchAdded = strlen(lpchClip);
    }
    else
    {
        cchAdded = wcslen((LPWSTR)lpchClip);
    }

    //
    // Insert the text (EditML_InsertText checks line length)
    //
    cchAdded = EditML_InsertText(ped, lpchClip, cchAdded, FALSE);

    GlobalUnlock(hData);

PasteExit:
    CloseClipboard();

PasteExitNoCloseClip:
    SetCursor(hCursorOld);

    return cchAdded;
}


//---------------------------------------------------------------------------//
VOID EditML_MouseMotion(PED ped, UINT message, UINT virtKeyDown, LPPOINT mousePt)
{
    BOOL fChangedSel = FALSE;
    UINT dtScroll = GetDoubleClickTime() / 5;

    HDC hdc = Edit_GetDC(ped, TRUE);

    ICH ichMaxSel = ped->ichMaxSel;
    ICH ichMinSel = ped->ichMinSel;

    ICH mouseCch;
    ICH mouseLine;
    int i, j;
    LONG  ll, lh;

    mouseCch = EditML_MouseToIch(ped, hdc, mousePt, &mouseLine);

    //
    // Save for timer
    //
    ped->ptPrevMouse = *mousePt;
    ped->prevKeys = virtKeyDown;

    switch (message) 
    {
    case WM_LBUTTONDBLCLK:
        //
        // if shift key is down, extend selection to word we double clicked on
        // else clear current selection and select word.
        // LiZ -- 5/5/93
        //
        if (ped->fAnsi && ped->fDBCS) 
        {
            LPSTR pText = Edit_Lock(ped);
            Edit_Word(ped,ped->ichCaret,
                   Edit_IsDBCSLeadByte(ped, *(pText+(ped->ichCaret)))
                        ? FALSE :
                          (ped->ichCaret == ped->chLines[ped->iCaretLine]
                              ? FALSE : TRUE), &ll, &lh);
            Edit_Unlock(ped);
        } 
        else 
        {
            Edit_Word(ped, mouseCch, !(mouseCch == ped->chLines[mouseLine]), &ll, &lh);
        }
        if (!(virtKeyDown & MK_SHIFT)) 
        {
            //
            // If shift key isn't down, move caret to mouse point and clear
            // old selection
            //
            ichMinSel = ll;
            ichMaxSel = ped->ichCaret = lh;
        } 
        else 
        {
            //
            // Shiftkey is down so we want to maintain the current selection
            // (if any) and just extend or reduce it
            //
            if (ped->ichMinSel == ped->ichCaret) 
            {
                ichMinSel = ped->ichCaret = ll;
                Edit_Word(ped, ichMaxSel, TRUE, &ll, &lh);
            } 
            else 
            {
                ichMaxSel = ped->ichCaret = lh;
                Edit_Word(ped, ichMinSel, FALSE, &ll, &lh);
            }
        }

        ped->ichStartMinSel = ll;
        ped->ichStartMaxSel = lh;

        goto InitDragSelect;

    case WM_MOUSEMOVE:
        if (ped->fMouseDown) 
        {
            //
            // Set the system timer to automatically scroll when mouse is
            // outside of the client rectangle. Speed of scroll depends on
            // distance from window.
            //
            i = mousePt->y < 0 ? -mousePt->y : mousePt->y - ped->rcFmt.bottom;
            j = dtScroll - ((UINT)i << 4);
            if (j < 1)
            {
                j = 1;
            }
            SetTimer(ped->hwnd, IDSYS_SCROLL, (UINT)j, NULL);

            fChangedSel = TRUE;

            //
            // Extend selection, move caret right
            //
            if (ped->ichStartMinSel || ped->ichStartMaxSel) 
            {
                //
                // We're in WORD SELECT mode
                //
                BOOL fReverse = (mouseCch <= ped->ichStartMinSel);
                Edit_Word(ped, mouseCch, !fReverse, &ll, &lh);
                if (fReverse) 
                {
                    ichMinSel = ped->ichCaret = ll;
                    ichMaxSel = ped->ichStartMaxSel;
                } 
                else 
                {
                    ichMinSel = ped->ichStartMinSel;
                    ichMaxSel = ped->ichCaret = lh;
                }
            } 
            else if ((ped->ichMinSel == ped->ichCaret) &&
                    (ped->ichMinSel != ped->ichMaxSel))
            {
                //
                // Reduce selection extent
                //
                ichMinSel = ped->ichCaret = mouseCch;
            }
            else
            {
                //
                // Extend selection extent
                //
                ichMaxSel = ped->ichCaret = mouseCch;
            }

            ped->iCaretLine = mouseLine;
        }

        break;

    case WM_LBUTTONDOWN:
        ll = lh = mouseCch;

        if (!(virtKeyDown & MK_SHIFT)) 
        {
            //
            // If shift key isn't down, move caret to mouse point and clear
            // old selection
            //
            ichMinSel = ichMaxSel = ped->ichCaret = mouseCch;
        } 
        else 
        {
            //
            // Shiftkey is down so we want to maintain the current selection
            // (if any) and just extend or reduce it
            //
            if (ped->ichMinSel == ped->ichCaret)
            {
                ichMinSel = ped->ichCaret = mouseCch;
            }
            else
            {
                ichMaxSel = ped->ichCaret = mouseCch;
            }
        }

        ped->ichStartMinSel = ped->ichStartMaxSel = 0;

InitDragSelect:
        ped->iCaretLine = mouseLine;

        ped->fMouseDown = FALSE;
        SetCapture(ped->hwnd);
        ped->fMouseDown = TRUE;
        fChangedSel = TRUE;

        //
        // Set the timer so that we can scroll automatically when the mouse
        // is moved outside the window rectangle.
        //
        SetTimer(ped->hwnd, IDSYS_SCROLL, dtScroll, NULL);
        break;

    case WM_LBUTTONUP:
        if (ped->fMouseDown) 
        {
            //
            // Kill the timer so that we don't do auto mouse moves anymore
            //
            KillTimer(ped->hwnd, IDSYS_SCROLL);
            ReleaseCapture();
            EditML_SetCaretPosition(ped, hdc);
            ped->fMouseDown = FALSE;
        }

        break;
    }


    if (fChangedSel) 
    {
        EditML_ChangeSelection(ped, hdc, ichMinSel, ichMaxSel);
        EditML_EnsureCaretVisible(ped);
    }

    Edit_ReleaseDC(ped, hdc, TRUE);

    if (!ped->fFocus && (message == WM_LBUTTONDOWN)) 
    {
        //
        // If we don't have the focus yet, get it
        //
        SetFocus(ped->hwnd);
    }
}


//---------------------------------------------------------------------------//
LONG EditML_Scroll(PED ped, BOOL fVertical, int cmd, int iAmt, BOOL fRedraw)
{
    SCROLLINFO  si;
    int         dx = 0;
    int         dy = 0;
    BOOL        fIncludeLeftMargin;
    int         newPos;
    int         oldPos;
    BOOL        fUp = FALSE;
    UINT        wFlag;
    DWORD       dwTime = 0;

    if (fRedraw && (cmd != ML_REFRESH)) 
    {
        UpdateWindow(ped->hwnd);
    }

    if (ped->pLpkEditCallout && ped->fRtoLReading && !fVertical
        && ped->maxPixelWidth > ped->rcFmt.right - ped->rcFmt.left)  
    {
        //
        // Horizontal scoll of a right oriented window with a scrollbar.
        // Map the logical xOffset to visual coordinates.
        //
        oldPos = ped->maxPixelWidth
                 - ((int)ped->xOffset + ped->rcFmt.right - ped->rcFmt.left);
    } 
    else
    {
        oldPos = (int) (fVertical ? ped->ichScreenStart : ped->xOffset);
    }

    fIncludeLeftMargin = (ped->xOffset == 0);

    switch (cmd) 
    {
        case ML_REFRESH:
            newPos = oldPos;
            break;

        case EM_GETTHUMB:
            return oldPos;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:

            //
            // If the edit contains more than 0xFFFF lines
            // it means that the scrolbar can return a position
            // that cannot fit in a WORD (16 bits), so use
            // GetScrollInfo (which is slower) in this case.
            //
            if (ped->cLines < 0xFFFF) 
            {
                newPos = iAmt;
            } 
            else 
            {
                SCROLLINFO si;

                si.cbSize   = sizeof(SCROLLINFO);
                si.fMask    = SIF_TRACKPOS;

                GetScrollInfo( ped->hwnd, SB_VERT, &si);

                newPos = si.nTrackPos;
            }
            break;

        case SB_TOP:      // == SB_LEFT
            newPos = 0;
            break;

        case SB_BOTTOM:   // == SB_RIGHT
            if (fVertical)
            {
                newPos = ped->cLines;
            }
            else
            {
                newPos = ped->maxPixelWidth;
            }

            break;

        case SB_PAGEUP:   // == SB_PAGELEFT
            fUp = TRUE;

        case SB_PAGEDOWN: // == SB_PAGERIGHT

            if (fVertical)
            {
                iAmt = ped->ichLinesOnScreen - 1;
            }
            else
            {
                iAmt = (ped->rcFmt.right - ped->rcFmt.left) - 1;
            }

            if (iAmt == 0)
            {
                iAmt++;
            }

            if (fUp)
            {
                iAmt = -iAmt;
            }

            goto AddDelta;

        case SB_LINEUP:   // == SB_LINELEFT
            fUp = TRUE;

        case SB_LINEDOWN: // == SB_LINERIGHT

            dwTime = iAmt;

            iAmt = 1;

            if (fUp)
            {
                iAmt = -iAmt;
            }

            //   |             |
            //   |  FALL THRU  |
            //   V             V

        case EM_LINESCROLL:
            if (!fVertical)
            {
                iAmt *= ped->aveCharWidth;
            }

AddDelta:
            newPos = oldPos + iAmt;

            break;

        default:

            return(0L);
    }

    if (fVertical) 
    {
        if (si.nMax = ped->cLines)
        {
            si.nMax--;
        }

        if (!ped->hwndParent ||
            TestWF(ped->hwndParent, WFWIN40COMPAT))
        {
            si.nPage = ped->ichLinesOnScreen;
        }
        else
        {
            si.nPage = 0;
        }

        wFlag = WS_VSCROLL;
    }
    else
    {
        si.nMax  = ped->maxPixelWidth;
        si.nPage = ped->rcFmt.right - ped->rcFmt.left;

        wFlag = WS_HSCROLL;
    }

    if (TESTFLAG(GET_STYLE(ped), wFlag)) 
    {
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_ALL | SIF_DISABLENOSCROLL;
        si.nMin  = 0;
        si.nPos = newPos;
        newPos = SetScrollInfo(ped->hwnd, fVertical ? SB_VERT : SB_HORZ,
                                     &si, fRedraw);
    } 
    else 
    {
        //
        // BOGUS -- this is duped code from ScrollBar code
        // but it's for the case when we want to limit the position without
        // actually having the scroll bar
        //
        int iMaxPos;

        //
        // Clip page to 0, range + 1
        //
        si.nPage = max(min((int)si.nPage, si.nMax + 1), 0);


        iMaxPos = si.nMax - (si.nPage ? si.nPage - 1 : 0);
        newPos = min(max(newPos, 0), iMaxPos);
    }

    oldPos -= newPos;

    if (!oldPos)
    {
        return 0;
    }


    if (ped->pLpkEditCallout && ped->fRtoLReading && !fVertical
        && ped->maxPixelWidth > ped->rcFmt.right - ped->rcFmt.left) 
    {
        //
        // Map visual oldPos and newPos back to logical coordinates
        //
        newPos = ped->maxPixelWidth
                 - (newPos + ped->rcFmt.right - ped->rcFmt.left);
        oldPos = -oldPos;
        if (newPos<0) 
        {
            //
            // Compensate for scroll bar returning pos > max-page
            //
            oldPos += newPos;
            newPos=0;
        }
    }

    if (fVertical) 
    {
        ped->ichScreenStart = newPos;
        dy = oldPos * ped->lineHeight;
    } 
    else 
    {
        ped->xOffset = newPos;
        dx = oldPos;
    }

    if (cmd != SB_THUMBTRACK)
    {
        //
        // We don't want to notify the parent of thumbtracking since they might
        // try to set the thumb position to something bogus.
        // NOTEPAD used to be guilty of this -- but I rewrote it so it's not.
        // The question is WHO ELSE does this? (jeffbog)
        //
        Edit_NotifyParent(ped, fVertical ? EN_VSCROLL : EN_HSCROLL);
    }

    if (fRedraw && IsWindowVisible(ped->hwnd)) 
    {
        RECT    rc;
        RECT    rcUpdate;
        RECT    rcClipRect;
        HDC     hdc;
        HBRUSH  hbr = NULL;
        BOOL    fNeedDelete = FALSE;
        

        GetClientRect(ped->hwnd, &rc);
        CopyRect(&rcClipRect, &ped->rcFmt);

        if (fVertical) 
        {
            rcClipRect.left -= ped->wLeftMargin;
            rcClipRect.right += ped->wRightMargin;
        }

        IntersectRect(&rc, &rc, &rcClipRect);
        rc.bottom++;

        //
        // Chicago has this HideCaret but there doesn't appear to be a
        // corresponding ShowCaret, so we lose the Caret under NT when the
        // EC scrolls - Johnl
        //
         
        // HideCaret(ped->hwnd);

        hdc = Edit_GetDC(ped, FALSE);
        Edit_SetClip(ped, hdc, fIncludeLeftMargin);
        if (ped->hFont)
        {
            SelectObject(hdc, ped->hFont);
        }

        hbr = Edit_GetBrush(ped, hdc, &fNeedDelete);
        if (hbr && fNeedDelete)
        {
            DeleteObject(hbr);
        }

        if (ped->pLpkEditCallout && !fVertical) 
        {
            //
            // Horizontal scroll with complex script support
            //
            int xFarOffset = ped->xOffset + ped->rcFmt.right - ped->rcFmt.left;

            rc = ped->rcFmt;
            if (dwTime != 0)
            {
                ScrollWindowEx(ped->hwnd, ped->fRtoLReading ? -dx : dx, dy, NULL, NULL, NULL,
                        &rcUpdate, MAKELONG(SW_SMOOTHSCROLL | SW_SCROLLCHILDREN, dwTime));
            }
            else
            {
                ScrollDC(hdc, ped->fRtoLReading ? -dx : dx, dy,
                               &rc, &rc, NULL, &rcUpdate);
            }

            //
            // Handle margins: Blank if clipped by horizontal scrolling,
            // display otherwise.
            //
            if (ped->wLeftMargin) 
            {
                rc.left  = ped->rcFmt.left - ped->wLeftMargin;
                rc.right = ped->rcFmt.left;
                if (   (ped->format != ES_LEFT)   // Always display margin for centred or far-aligned text
                    ||  // Display LTR left margin if first character fully visible
                        (!ped->fRtoLReading && ped->xOffset == 0)
                    ||  // Display RTL left margin if last character fully visible
                        (ped->fRtoLReading && xFarOffset >= ped->maxPixelWidth)) 
                {
                    UnionRect(&rcUpdate, &rcUpdate, &rc);
                } 
                else 
                {
                    ExtTextOutW(hdc, rc.left, rc.top,
                        ETO_CLIPPED | ETO_OPAQUE | ETO_GLYPH_INDEX,
                        &rc, L"", 0, 0L);
                }
            }

            if (ped->wRightMargin) 
            {
                rc.left  = ped->rcFmt.right;
                rc.right = ped->rcFmt.right + ped->wRightMargin;
                if (   (ped->format != ES_LEFT)   // Always display margin for centred or far-aligned text
                    ||  // Display RTL right margin if first character fully visible
                        (ped->fRtoLReading && ped->xOffset == 0)
                    ||  // Display LTR right margin if last character fully visible
                        (!ped->fRtoLReading && xFarOffset >= ped->maxPixelWidth)) 
                {
                    UnionRect(&rcUpdate, &rcUpdate, &rc);
                } 
                else 
                {
                    ExtTextOutW(hdc, rc.left, rc.top,
                        ETO_CLIPPED | ETO_OPAQUE | ETO_GLYPH_INDEX,
                        &rc, L"", 0, 0L);
                }
            }
        } 
        else 
        {
            if (dwTime != 0)
            {
                ScrollWindowEx(ped->hwnd, dx, dy, NULL, NULL, NULL,
                        &rcUpdate, MAKELONG(SW_SMOOTHSCROLL | SW_SCROLLCHILDREN, dwTime));
            }
            else
            {
                ScrollDC(hdc, dx, dy, &rc, &rc, NULL, &rcUpdate);
            }

            //
            // If we need to wipe out the left margin area
            //
            if (ped->wLeftMargin && !fVertical) 
            {
                //
                // Calculate the rectangle to be wiped out
                //
                rc.right = rc.left;
                rc.left = max(0, ped->rcFmt.left - (LONG)ped->wLeftMargin);
                if (rc.left < rc.right) 
                {
                    if (fIncludeLeftMargin && (ped->xOffset != 0)) 
                    {
                        ExtTextOutW(hdc, rc.left, rc.top, ETO_CLIPPED | ETO_OPAQUE,
                            &rc, L"", 0, 0L);
                    } 
                    else
                    {
                        if((!fIncludeLeftMargin) && (ped->xOffset == 0))
                        {
                            UnionRect(&rcUpdate, &rcUpdate, &rc);
                        }
                    }
                }
            }
        }

        EditML_SetCaretPosition(ped,hdc);

        Edit_ReleaseDC(ped, hdc, FALSE);
        InvalidateRect(ped->hwnd, &rcUpdate, TRUE);
        UpdateWindow(ped->hwnd);
    }

    return MAKELONG(-oldPos, 1);
}


//---------------------------------------------------------------------------//
//
// EditML_SetFocus AorW
//
// Gives the edit control the focus and notifies the parent
// EN_SETFOCUS.
//
void EditML_SetFocus(PED ped)
{
    HDC hdc;
    INT cxCaret;

    SystemParametersInfo(SPI_GETCARETWIDTH, 0, (LPVOID)&cxCaret, 0);

    if (!ped->fFocus) 
    {
        ped->fFocus = TRUE;
        InvalidateRect(ped->hwnd, NULL, TRUE);

        hdc = Edit_GetDC(ped, TRUE);

        //
        // Draw the caret. We need to do this even if the window is hidden
        // because in dlg box initialization time we may set the focus to a
        // hidden edit control window. If we don't create the caret etc, it will
        // never end up showing properly.
        //
        if (ped->pLpkEditCallout) 
        {
            ped->pLpkEditCallout->EditCreateCaret((PED0)ped, hdc, cxCaret, ped->lineHeight, 0);
        }
        else 
        {
            CreateCaret(ped->hwnd, (HBITMAP)NULL, cxCaret, ped->lineHeight);
        }
        ShowCaret(ped->hwnd);
        EditML_SetCaretPosition(ped, hdc);

        //
        // Show the current selection. Only if the selection was hidden when we
        // lost the focus, must we invert (show) it.
        //
        if (!ped->fNoHideSel && ped->ichMinSel != ped->ichMaxSel &&
                IsWindowVisible(ped->hwnd))
        {
            EditML_DrawText(ped, hdc, ped->ichMinSel, ped->ichMaxSel, TRUE);
        }

        Edit_ReleaseDC(ped, hdc, TRUE);

    }

    //
    // Notify parent we have the focus
    //
    Edit_NotifyParent(ped, EN_SETFOCUS);
}


//---------------------------------------------------------------------------//
//
// EditML_KillFocus AorW
//
// The edit control loses the focus and notifies the parent via
// EN_KILLFOCUS.
//
VOID EditML_KillFocus(PED ped)
{
    HDC hdc;

    //
    // Reset the wheel delta count.
    //

    if (ped->fFocus) 
    {
        ped->fFocus = 0;

        //
        // Do this only if we still have the focus. But we always notify the
        // parent that we lost the focus whether or not we originally had the
        // focus.
        //

        //
        // Hide the current selection if needed
        //
#ifdef _USE_DRAW_THEME_TEXT_
        if (((!ped->fNoHideSel && ped->ichMinSel != ped->ichMaxSel &&
            IsWindowVisible(ped->hwnd))) || ped->hTheme) 
        {
            hdc = Edit_GetDC(ped, FALSE);
            if ( !ped->hTheme )
            {
                EditML_DrawText(ped, hdc, ped->ichMinSel, ped->ichMaxSel, TRUE);
            }
            else
            {
                InvalidateRect(ped->hwnd, NULL, TRUE);
            }
            Edit_ReleaseDC(ped, hdc, FALSE);
        }
#else
        if (((!ped->fNoHideSel && ped->ichMinSel != ped->ichMaxSel &&
            IsWindowVisible(ped->hwnd)))) 
        {
            hdc = Edit_GetDC(ped, FALSE);

            EditML_DrawText(ped, hdc, ped->ichMinSel, ped->ichMaxSel, TRUE);

            Edit_ReleaseDC(ped, hdc, FALSE);
        }
#endif // _USE_DRAW_THEME_TEXT_

        //
        // Destroy the caret
        //
        DestroyCaret();
    }

    //
    // Notify parent that we lost the focus.
    //
    Edit_NotifyParent(ped, EN_KILLFOCUS);
}


//---------------------------------------------------------------------------//
//
// EditML_EnsureCaretVisible AorW
// 
// Scrolls the caret into the visible region.
// Returns TRUE if scrolling was done else return s FALSE.
//
BOOL EditML_EnsureCaretVisible(PED ped)
{
    UINT   iLineMax;
    int    xposition;
    BOOL   fPrevLine;
    HDC    hdc;
    BOOL   fVScroll = FALSE;
    BOOL   fHScroll = FALSE;

    if (IsWindowVisible(ped->hwnd)) 
    {
        int iAmt;
        int iFmtWidth = ped->rcFmt.right - ped->rcFmt.left;

        if (ped->fAutoVScroll) 
        {
            iLineMax = ped->ichScreenStart + ped->ichLinesOnScreen - 1;

            if (fVScroll = (ped->iCaretLine > iLineMax))
            {
                iAmt = iLineMax;
            }
            else if (fVScroll = (ped->iCaretLine < ped->ichScreenStart))
            {
                iAmt = ped->ichScreenStart;
            }

            if (fVScroll)
            {
                EditML_Scroll(ped, TRUE, EM_LINESCROLL, ped->iCaretLine - iAmt, TRUE);
            }
        }

        if (ped->fAutoHScroll && ((int) ped->maxPixelWidth > iFmtWidth)) 
        {
            POINT pt;

            //
            // Get the current position of the caret in pixels
            //
            if ((UINT) (ped->cLines - 1) != ped->iCaretLine &&
                ped->ichCaret == ped->chLines[ped->iCaretLine + 1])
            {
                fPrevLine = TRUE;
            }
            else
            {
                fPrevLine = FALSE;
            }

            hdc = Edit_GetDC(ped,TRUE);
            EditML_IchToXYPos(ped, hdc, ped->ichCaret, fPrevLine, &pt);
            Edit_ReleaseDC(ped, hdc, TRUE);
            xposition = pt.x;

            //
            // Remember, EditML_IchToXYPos returns coordinates with respect to the
            // top left pixel displayed on the screen.  Thus, if xPosition < 0,
            // it means xPosition is less than current ped->xOffset.
            //

            iFmtWidth /= 3;
            if (fHScroll = (xposition < ped->rcFmt.left))
            {
                //
                // scroll to the left
                //
                iAmt = ped->rcFmt.left + iFmtWidth;
            }
            else if (fHScroll = (xposition > ped->rcFmt.right))
            {
                //
                // scroll to the right
                //
                iAmt = ped->rcFmt.right - iFmtWidth;
            }

            if (fHScroll)
            {
                EditML_Scroll(ped, FALSE, EM_LINESCROLL, (xposition - iAmt) / ped->aveCharWidth, TRUE);
            }
        }
    }
    return fVScroll;
}


//---------------------------------------------------------------------------//
// 
// EditML_WndProc
// 
// Class procedure for all multi line edit controls.
// Dispatches all messages to the appropriate handlers which are named
// as follows:
//
// EditSL_ (single line) prefixes all single line edit control procedures while
// Edit_   (edit control) prefixes all common handlers.
//
// The EditML_WndProc only handles messages specific to multi line edit
// controls.
//
LRESULT EditML_WndProc(PED ped, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    LPRECT      lprc;
    POINT       pt;
    DWORD       windowstyle;
    static INT  scWheelDelta;

    switch (message) 
    {

    case WM_INPUTLANGCHANGE:
        if (ped && ped->fFocus && ped->pLpkEditCallout) 
        {
            INT cxCaret;

            SystemParametersInfo(SPI_GETCARETWIDTH, 0, (LPVOID)&cxCaret, 0);

            HideCaret(ped->hwnd);
            hdc = Edit_GetDC(ped, TRUE);
            DestroyCaret();

            ped->pLpkEditCallout->EditCreateCaret((PED0)ped, hdc, cxCaret, ped->lineHeight, (UINT)lParam);

            EditML_SetCaretPosition(ped, hdc);
            Edit_ReleaseDC(ped, hdc, TRUE);
            ShowCaret(ped->hwnd);
        }
        goto PassToDefaultWindowProc;


    case WM_STYLECHANGED:
        if (ped && ped->pLpkEditCallout) 
        {
            switch (wParam) 
            {

                case GWL_STYLE:
                    Edit_UpdateFormat(ped,
                        ((LPSTYLESTRUCT)lParam)->styleNew,
                        GET_EXSTYLE(ped));

                    return 1L;

                case GWL_EXSTYLE:
                    Edit_UpdateFormat(ped,
                        GET_STYLE(ped),
                        ((LPSTYLESTRUCT)lParam)->styleNew);

                    return 1L;
            }
        }

        goto PassToDefaultWindowProc;

    case WM_CHAR:

        //
        // wParam - the value of the key
        // lParam - modifiers, repeat count etc (not used)
        //
        EditML_Char(ped, (UINT)wParam, 0);

        break;

    case WM_ERASEBKGND:  
    {
        RECT    rc;
        GetClientRect(ped->hwnd, &rc);
#ifdef _USE_DRAW_THEME_TEXT_
        if (!ped->hTheme)
#endif // _USE_DRAW_THEME_TEXT_
        {
            HBRUSH hbr = NULL;
            BOOL   fNeedDelete = FALSE;

            hbr = Edit_GetBrush(ped, (HDC)wParam, &fNeedDelete);
            if (hbr)
            {
                FillRect((HDC)wParam, &rc, hbr);

                if (fNeedDelete)
                {
                    DeleteObject(hbr);
                }
            }

        }
#ifdef _USE_DRAW_THEME_TEXT_
        else
        {
            HRESULT hr;
            INT     iStateId = Edit_GetStateId(ped);
            hr = DrawThemeBackground(ped->hTheme, (HDC)wParam, EP_EDITTEXT, iStateId, &rc, 0);
        }
#endif // _USE_DRAW_THEME_TEXT_
        return TRUE;

    }
    case WM_GETDLGCODE: 
    {
            LONG code = DLGC_WANTCHARS | DLGC_HASSETSEL | DLGC_WANTARROWS | DLGC_WANTALLKEYS;

            //
            // !!! JEFFBOG HACK !!!
            // Only set Dialog Box Flag if GETDLGCODE message is generated by
            // IsDialogMessage -- if so, the lParam will be a pointer to the
            // message structure passed to IsDialogMessage; otherwise, lParam
            // will be NULL. Reason for the HACK alert: the wParam & lParam
            // for GETDLGCODE is still not clearly defined and may end up
            // changing in a way that would throw this off
            //
            if (lParam)
            {
               // Mark ML edit ctrl as in a dialog box
               ped->fInDialogBox = TRUE;
            }

            //
            // If this is a WM_SYSCHAR message generated by the UNDO keystroke
            // we want this message so we can EAT IT in "case WM_SYSCHAR:"
            //
            if (lParam && (((LPMSG)lParam)->message == WM_SYSCHAR) &&
                    ((DWORD)((LPMSG)lParam)->lParam & SYS_ALTERNATE) &&
                    ((WORD)wParam == VK_BACK))
            {
                 code |= DLGC_WANTMESSAGE;
            }

            return code;
        }

    case EM_SCROLL:
        message = WM_VSCROLL;

        //
        // FALL THROUGH
        //

    case WM_HSCROLL:
    case WM_VSCROLL:
        return EditML_Scroll(ped, (message==WM_VSCROLL), LOWORD(wParam), HIWORD(wParam), TRUE);

    case WM_MOUSEWHEEL:
    {
        UINT ucWheelScrollLines;

        //
        // Don't handle zoom and datazoom.
        //
        if (wParam & (MK_SHIFT | MK_CONTROL)) 
        {
            goto PassToDefaultWindowProc;
        }

        scWheelDelta -= (short) HIWORD(wParam);
        windowstyle = GET_STYLE(ped);
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, (LPVOID)&ucWheelScrollLines, 0); 
        if (    abs(scWheelDelta) >= WHEEL_DELTA &&
                ucWheelScrollLines > 0 &&
                (windowstyle & (WS_VSCROLL | WS_HSCROLL))) 
        {
            int     cLineScroll;
            BOOL    fVert;
            int     cPage;

            if (windowstyle & WS_VSCROLL) 
            {
                fVert = TRUE;
                cPage = ped->ichLinesOnScreen;
            } 
            else 
            {
                fVert = FALSE;
                cPage = (ped->rcFmt.right - ped->rcFmt.left) / ped->aveCharWidth;
            }

            //
            // Limit a roll of one (1) WHEEL_DELTA to scroll one (1) page.
            //
            cLineScroll = (int) min(
                    (UINT) (max(1, (cPage - 1))),
                    ucWheelScrollLines);

            cLineScroll *= (scWheelDelta / WHEEL_DELTA);
            UserAssert(cLineScroll != 0);
            scWheelDelta = scWheelDelta % WHEEL_DELTA;
            EditML_Scroll(ped, fVert, EM_LINESCROLL, cLineScroll, TRUE);
        }

        break;

    }
    case WM_KEYDOWN:

        //
        // wParam - virt keycode of the given key
        // lParam - modifiers such as repeat count etc. (not used)
        //
        EditML_KeyDown(ped, (UINT)wParam, 0);
        break;

    case WM_KILLFOCUS:

        //
        // wParam - handle of the window that receives the input focus
        // lParam - not used
        //
        scWheelDelta = 0;
        EditML_KillFocus(ped);
        break;

    case WM_CAPTURECHANGED:
        //
        // wParam -- unused
        // lParam -- hwnd of window gaining capture.
        //
        if (ped->fMouseDown) 
        {
            //
            // We don't change the caret pos here.  If this is happening
            // due to button up, then we'll change the pos in the
            // handler after ReleaseCapture().  Otherwise, just end
            // gracefully because someone else has stolen capture out
            // from under us.
            //

            ped->fMouseDown = FALSE;
            KillTimer(ped->hwnd, IDSYS_SCROLL);
        }

        break;

    case WM_SYSTIMER:

        //
        // This allows us to automatically scroll if the user holds the mouse
        // outside the edit control window. We simulate mouse moves at timer
        // intervals set in MouseMotionHandler.
        //
        if (ped->fMouseDown)
        {
            EditML_MouseMotion(ped, WM_MOUSEMOVE, ped->prevKeys, &ped->ptPrevMouse);
        }

        break;

    case WM_MBUTTONDOWN:
        EnterReaderMode(ped->hwnd);

        break;

    case WM_MOUSEMOVE:
        UserAssert(ped->fMouseDown);

        //
        // FALL THROUGH
        //

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
        //
        // wParam - contains a value that indicates which virtual keys are down
        // lParam - contains x and y coords of the mouse cursor
        //
        POINTSTOPOINT(pt, lParam);
        EditML_MouseMotion(ped, message, (UINT)wParam, &pt);

        break;

    case WM_CREATE:

        //
        // wParam - handle to window being created
        // lParam - points to a CREATESTRUCT that contains copies of parameters
        // passed to the CreateWindow function.
        //
        return EditML_Create(ped, (LPCREATESTRUCT)lParam);

    case WM_PRINTCLIENT:
        EditML_Paint(ped, (HDC) wParam, NULL);

        break;

    case WM_PAINT:
        //
        // wParam - can be hdc from subclassed paint
        // lParam - not used
        //
        if (wParam) 
        {
            hdc = (HDC)wParam;
            lprc = NULL;
        } 
        else 
        {
            hdc = BeginPaint(ped->hwnd, &ps);
            lprc = &ps.rcPaint;
        }

        if (IsWindowVisible(ped->hwnd))
        {
            EditML_Paint(ped, hdc, lprc);
        }

        if (!wParam)
        {
            EndPaint(ped->hwnd, &ps);
        }

        break;

    case WM_PASTE:

        //
        // wParam - not used
        // lParam - not used
        //
        if (!ped->fReadOnly)
        {
            EditML_PasteText(ped);
        }

        break;

    case WM_SETFOCUS:

        //
        // wParam - handle of window that loses the input focus (may be NULL)
        // lParam - not used
        //
        EditML_SetFocus(ped);

        break;

    case WM_SIZE:

        //
        // wParam - defines the type of resizing fullscreen, sizeiconic,
        //          sizenormal etc.
        // lParam - new width in LOWORD, new height in HIGHWORD of client area
        //
        Edit_Size(ped, NULL, TRUE);

        break;

    case EM_FMTLINES:

        //
        // wParam - indicates disposition of end-of-line chars. If non
        // zero, the chars CR CR LF are placed at the end of a word
        // wrapped line. If wParam is zero, the end of line chars are
        // removed. This is only done when the user gets a handle (via
        // EM_GETHANDLE) to the text. lParam - not used.
        //
        if (wParam)
        {
            EditML_InsertCrCrLf(ped);
        }
        else
        {
            EditML_StripCrCrLf(ped);
        }

        EditML_BuildchLines(ped, 0, 0, FALSE, NULL, NULL);

        return (LONG)(wParam != 0);

    case EM_GETHANDLE:

        //
        // wParam - not used
        // lParam - not used
        //

        //
        // Returns a handle to the edit control's text.
        //

        //
        // Null terminate the string. Note that we are guaranteed to have the
        // memory for the NULL since Edit_InsertText allocates an extra
        // WCHAR for the NULL terminator.
        //

        if (ped->fAnsi)
        {
            *(Edit_Lock(ped) + ped->cch) = 0;
        }
        else
        {
            *((LPWSTR)Edit_Lock(ped) + ped->cch) = 0;
        }

        Edit_Unlock(ped);

        return ((LRESULT)ped->hText);

    case EM_GETLINE:

        //
        // wParam - line number to copy (0 is first line)
        // lParam - buffer to copy text to. First WORD is max # of bytes to
        // copy
        //
        return EditML_GetLine(ped, (ICH)wParam, (ICH)*(WORD UNALIGNED *)lParam, (LPSTR)lParam);

    case EM_LINEFROMCHAR:

        //
        // wParam - Contains the index value for the desired char in the text
        // of the edit control. These are 0 based.
        // lParam - not used
        //
        return (LRESULT)EditML_IchToLine(ped, (ICH)wParam);

    case EM_LINEINDEX:

        //
        // wParam - specifies the desired line number where the number of the
        // first line is 0. If linenumber = 0, the line with the caret is used.
        // lParam - not used.
        // This function return s the number of character positions that occur
        // preceeding the first char in a given line.
        //
        return (LRESULT)EditML_LineIndex(ped, (ICH)wParam);

    case EM_LINELENGTH:

        //
        // wParam - specifies the character index of a character in the
        // specified line, where the first line is 0. If -1, the length
        // of the current line (with the caret) is return ed not including the
        // length of any selected text.
        // lParam - not used
        //
        return (LRESULT)EditML_LineLength(ped, (ICH)wParam);

    case EM_LINESCROLL:

        //
        // wParam - not used
        // lParam - Contains the number of lines and char positions to scroll
        //
        EditML_Scroll(ped, TRUE,  EM_LINESCROLL, (INT)lParam, TRUE);
        EditML_Scroll(ped, FALSE, EM_LINESCROLL, (INT)wParam, TRUE);

        break;

    case EM_REPLACESEL:

        //
        // wParam - flag for 4.0+ apps saying whether to clear undo
        // lParam - Points to a null terminated replacement text.
        //
        EditML_ReplaceSel(ped, (LPSTR)lParam);

        if (!ped->f40Compat || !wParam)
        {
            Edit_EmptyUndo(Pundo(ped));
        }

        break;

    case EM_SETHANDLE:

        //
        // wParam - contains a handle to the text buffer
        // lParam - not used
        //
        EditML_SetHandle(ped, (HANDLE)wParam);

        break;

    case EM_SETRECT:
    case EM_SETRECTNP:

        //
        // wParamLo --    not used
        // lParam --    LPRECT with new formatting area
        //
        Edit_Size(ped, (LPRECT) lParam, (message != EM_SETRECTNP));

        break;

    case EM_SETSEL:

        //
        // wParam - Under 3.1, specifies if we should scroll caret into
        // view or not. 0 == scroll into view. 1 == don't scroll
        // lParam - starting pos in lowword ending pos in high word
        // 
        // Under Win32, wParam is the starting pos, lParam is the
        // ending pos, and the caret is not scrolled into view.
        // The message EM_SCROLLCARET forces the caret to be scrolled
        // into view.
        //
        EditML_SetSelection(ped, TRUE, (ICH)wParam, (ICH)lParam);

        break;

    case EM_SCROLLCARET:

        //
        // Scroll caret into view
        //
        EditML_EnsureCaretVisible(ped);
        break;

    case EM_GETFIRSTVISIBLELINE:

        //
        // Returns the first visible line for multiline edit controls.
        //
        return (LONG)ped->ichScreenStart;

    case WM_SYSKEYDOWN:
        if (((WORD)wParam == VK_BACK) && ((DWORD)lParam & SYS_ALTERNATE)) 
        {
            SendMessage(ped->hwnd, EM_UNDO, 0, 0L);
            break;
        }

        goto PassToDefaultWindowProc;

    case WM_UNDO:
    case EM_UNDO:
        return EditML_Undo(ped);

    case EM_SETTABSTOPS:

        //
        // This sets the tab stop positions for multiline edit controls.
        // wParam - Number of tab stops
        // lParam - Far ptr to a UINT array containing the Tab stop positions
        //
        return EditML_SetTabStops(ped, (int)wParam, (LPINT)lParam);

    case EM_POSFROMCHAR:
        //
        // wParam --    char index in text
        // lParam --    not used
        // This function returns the (x,y) position of the character
        //
    case EM_CHARFROMPOS:
        //
        // wParam --    unused
        // lParam --    pt in client coordinates
        // This function returns
        //      LOWORD: the position of the closest character
        //              to the passed in point.  Beware of
        //              points not actually in the edit client...
        //      HIWORD: the index of the line the char is on
        //
        {
            LONG  xyPos;
            LONG  line;

            hdc = Edit_GetDC(ped, TRUE);

            if (message == EM_POSFROMCHAR) 
            {
                EditML_IchToXYPos(ped, hdc, (ICH)wParam, FALSE, &pt);
                xyPos = MAKELONG(pt.x, pt.y);
            } 
            else 
            {
                POINTSTOPOINT(pt, lParam);
                xyPos = EditML_MouseToIch(ped, hdc, &pt, &line);
                xyPos = MAKELONG(xyPos, line);
            }

            Edit_ReleaseDC(ped, hdc, TRUE);

            return (LRESULT)xyPos;
        }

    case WM_SETREDRAW:
        DefWindowProc(ped->hwnd, message, wParam, lParam);
        if (wParam) 
        {
            //
            // Backwards compatability hack needed so that winraid's edit
            // controls work fine.
            //
            RedrawWindow(ped->hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME);
        }

        break;

    default:
PassToDefaultWindowProc:
        return DefWindowProc(ped->hwnd, message, wParam, lParam);
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// EditML_DrawText AorW
// 
// This function draws all the characters between ichStart and ichEnd for
// the given Multiline Edit Control.
//
// This function divides the block of text between ichStart and ichEnd
// into lines and each line into strips of text based on the selection
// attributes. It calls Edit_TabTheTextOut() to draw each strip.
// This takes care of the Negative A anc C widths of the current font, if
// it has any, on either side of each strip of text.
//
// NOTE: If the language pack is loaded the text is not divided into strips,
// nor is selection highlighting performed here. Whole lines are passed
// to the language pack to display with tab expansion and selection
// highlighting. (Since the language pack supports scripts with complex
// character re-ordering rules, only it can do this).
//
VOID EditML_DrawText(PED ped, HDC hdc, ICH ichStart, ICH ichEnd, BOOL fSelChange)
{
    DWORD   textColorSave;
    DWORD   bkColorSave;
    PSTR    pText;
    UINT    wCurLine;
    UINT    wEndLine;
    INT     xOffset;
    ICH     LengthToDraw;
    ICH     CurStripLength;
    ICH     ichAttrib, ichNewStart;
    ICH     ExtraLengthForNegA;
    ICH     ichT;
    INT     iRemainingLengthInLine;
    INT     xStPos, xClipStPos, xClipEndPos, yPos;

    BOOL    fFirstLineOfBlock   = TRUE;
    BOOL    fDrawEndOfLineStrip = FALSE;
    BOOL    fDrawOnSameLine     = FALSE;
    BOOL    fSelected           = FALSE;
    BOOL    fLineBegins         = FALSE;

    STRIPINFO   NegCInfo;
    POINT   pt;
    HBRUSH  hbr = NULL;
    BOOL    fNeedDelete = FALSE;
 
    //
    // Just return if nothing to draw
    //
    if (!ped->ichLinesOnScreen)
    {
        return;
    }

    hbr = Edit_GetBrush(ped, hdc, &fNeedDelete);
    if (hbr && fNeedDelete)
    {
        DeleteObject(hbr);
    }

    //
    // Adjust the value of ichStart such that we need to draw only those lines
    // visible on the screen.
    //
    if ((UINT)ichStart < (UINT)ped->chLines[ped->ichScreenStart]) 
    {
        ichStart = ped->chLines[ped->ichScreenStart];
        if (ichStart > ichEnd)
        {
            return;
        }
    }

    //
    // Adjust the value of ichEnd such that we need to draw only those lines
    // visible on the screen.
    //
    wCurLine = min(ped->ichScreenStart+ped->ichLinesOnScreen,ped->cLines-1);
    ichT = ped->chLines[wCurLine] + EditML_Line(ped, wCurLine);
    ichEnd = min(ichEnd, ichT);

    wCurLine = EditML_IchToLine(ped, ichStart);  // Starting line.
    wEndLine = EditML_IchToLine(ped, ichEnd);    // Ending line.

    UserAssert(ped->chLines[wCurLine] <= ped->cch + 1);
    UserAssert(ped->chLines[wEndLine] <= ped->cch + 1);

    if (fSelChange && (GetBkMode(hdc) != OPAQUE))
    {
        //
        // if changing selection on a transparent edit control, just
        // draw those lines from scratch
        //
        RECT rcStrip;
        CopyRect(&rcStrip, &ped->rcFmt);
        rcStrip.left -= ped->wLeftMargin;
        if (ped->pLpkEditCallout) 
        {
            rcStrip.right += ped->wRightMargin;
        }

        rcStrip.top += (wCurLine - ped->ichScreenStart) * ped->lineHeight;
        rcStrip.bottom = rcStrip.top + ((wEndLine - wCurLine) + 1) * ped->lineHeight;
        InvalidateRect(ped->hwnd, &rcStrip, TRUE);
        return;
    }

    //
    // If it is either centered or right-justified, then draw the whole lines.
    // Also draw whole lines if the language pack is handling line layout.
    //
    if ((ped->format != ES_LEFT) || (ped->pLpkEditCallout)) 
    {
        ichStart = ped->chLines[wCurLine];
        ichEnd = ped->chLines[wEndLine] + EditML_Line(ped, wEndLine);
    }

    pText = Edit_Lock(ped);

    HideCaret(ped->hwnd);

    //
    // If ichStart stays on Second byte of DBCS, we have to
    // adjust it. LiZ -- 5/5/93
    //
    if (ped->fAnsi && ped->fDBCS) 
    {
        ichStart = Edit_AdjustIch( ped, pText, ichStart );
    }
    UserAssert(ichStart <= ped->cch);
    UserAssert(ichEnd <= ped->cch);

    while (ichStart <= ichEnd) 
    {
        //
        // Pass whole lines to the language pack to display with selection
        // marking and tab expansion.
        //
        if (ped->pLpkEditCallout) 
        {
            ped->pLpkEditCallout->EditDrawText(
                (PED0)ped, hdc, pText + ped->cbChar*ichStart,
                EditML_Line(ped, wCurLine),
                (INT)ped->ichMinSel - (INT)ichStart, (INT)ped->ichMaxSel - (INT)ichStart,
                EditML_IchToYPos(ped, ichStart, FALSE));
        } 
        else 
        {
        
            //
            // xStPos:      The starting Position where the string must be drawn.
            // xClipStPos:  The starting position for the clipping rect for the block.
            // xClipEndPos: The ending position for the clipping rect for the block.
            //

            //
            // Calculate the xyPos of starting point of the block.
            //
            EditML_IchToXYPos(ped, hdc, ichStart, FALSE, &pt);
            xClipStPos = xStPos = pt.x;
            yPos = pt.y;

            //
            // The attributes of the block is the same as that of ichStart.
            //
            ichAttrib = ichStart;

            //
            // If the current font has some negative C widths and if this is the
            // begining of a block, we must start drawing some characters before the
            // block to account for the negative C widths of the strip before the
            // current strip; In this case, reset ichStart and xStPos.
            //

            if (fFirstLineOfBlock && ped->wMaxNegC) 
            {
                fFirstLineOfBlock = FALSE;
                ichNewStart = max(((int)(ichStart - ped->wMaxNegCcharPos)), ((int)ped->chLines[wCurLine]));

                //
                // If ichStart needs to be changed, then change xStPos also accordingly.
                //
                if (ichNewStart != ichStart) 
                {
                    if (ped->fAnsi && ped->fDBCS) 
                    {
                        //
                        // Adjust DBCS alignment...
                        //
                        ichNewStart = Edit_AdjustIchNext( ped, pText, ichNewStart );
                    }
                    EditML_IchToXYPos(ped, hdc, ichStart = ichNewStart, FALSE, &pt);
                    xStPos = pt.x;
                }
            }

            //
            // Calc the number of characters remaining to be drawn in the current line.
            //
            iRemainingLengthInLine = EditML_Line(ped, wCurLine) -
                                    (ichStart - ped->chLines[wCurLine]);

            //
            // If this is the last line of a block, we may not have to draw all the
            // remaining lines; We must draw only upto ichEnd.
            //
            if (wCurLine == wEndLine)
            {
                LengthToDraw = ichEnd - ichStart;
            }
            else
            {
                LengthToDraw = iRemainingLengthInLine;
            }

            //
            // Find out how many pixels we indent the line for non-left-justified
            // formats
            //
            if (ped->format != ES_LEFT)
            {
                xOffset = EditML_CalcXOffset(ped, hdc, wCurLine);
            }
            else
            {
                xOffset = -((int)(ped->xOffset));
            }

            //
            // Check if this is the begining of a line.
            //
            if (ichAttrib == ped->chLines[wCurLine]) 
            {
                fLineBegins = TRUE;
                xClipStPos = ped->rcFmt.left - ped->wLeftMargin;
            }

            //
            // The following loop divides this 'wCurLine' into strips based on the
            // selection attributes and draw them strip by strip.
            //
            do  
            {
                //
                // If ichStart is pointing at CRLF or CRCRLF, then iRemainingLength
                // could have become negative because MLLine does not include
                // CR and LF at the end of a line.
                //
                if (iRemainingLengthInLine < 0)  // If Current line is completed,
                {
                    break;                   // go on to the next line.
                }

                //
                // Check if a part of the block is selected and if we need to
                // show it with a different attribute.
                //
                if (!(ped->ichMinSel == ped->ichMaxSel ||
                            ichAttrib >= ped->ichMaxSel ||
                            ichEnd   <  ped->ichMinSel ||
                            (!ped->fNoHideSel && !ped->fFocus))) 
                {
                    //
                    // OK! There is a selection somewhere in this block!
                    // Check if this strip has selection attribute.
                    //
                    if (ichAttrib < ped->ichMinSel) 
                    {
                        fSelected = FALSE;  // This strip is not selected

                        // Calculate the length of this strip with normal attribute.
                        CurStripLength = min(ichStart+LengthToDraw, ped->ichMinSel)-ichStart;
                        fLineBegins = FALSE;
                    } 
                    else 
                    {
                        //
                        // The current strip has the selection attribute.
                        //
                        if (fLineBegins) // Is it the first part of a line?
                        {  
                            //
                            // Then, draw the left margin area with normal attribute.
                            //
                            fSelected = FALSE;
                            CurStripLength = 0;
                            xClipStPos = ped->rcFmt.left - ped->wLeftMargin;
                            fLineBegins = FALSE;
                        } 
                        else 
                        {
                            //
                            // Else, draw the strip with selection attribute.
                            //
                            fSelected = TRUE;
                            CurStripLength = min(ichStart+LengthToDraw, ped->ichMaxSel)-ichStart;

                            //
                            // Select in the highlight colors.
                            //
                            bkColorSave = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                            if (!ped->fDisabled)
                            {
                                textColorSave = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                            }
                        }
                    }
                } 
                else 
                {
                    //
                    // The whole strip has no selection attributes.
                    //
                    CurStripLength = LengthToDraw;
                }

                //
                // Other than the current strip, do we still have anything
                // left to be drawn in the current line?
                //
                fDrawOnSameLine = (LengthToDraw != CurStripLength);

                //
                // When we draw this strip, we need to draw some more characters
                // beyond the end of this strip to account for the negative A
                // widths of the characters that follow this strip.
                //
                ExtraLengthForNegA = min(iRemainingLengthInLine-CurStripLength, ped->wMaxNegAcharPos);

                //
                // The blank strip at the end of the line needs to be drawn with
                // normal attribute irrespective of whether the line has selection
                // attribute or not. Hence, if the last strip of the line has selection
                // attribute, then this blank strip needs to be drawn separately.
                // Else, we can draw the blank strip along with the last strip.
                //

                //
                // Is this the last strip of the current line?
                //
                if (iRemainingLengthInLine == (int)CurStripLength) 
                {
                    if (fSelected)  // Does this strip have selection attribute?
                    { 
                        //
                        // Then we need to draw the end of line strip separately.
                        //
                        fDrawEndOfLineStrip = TRUE;  // Draw the end of line strip.
                        EditML_IchToXYPos(ped, hdc, ichStart+CurStripLength, TRUE, &pt);
                        xClipEndPos = pt.x;
                    } 
                    else 
                    {
                        //
                        // Set the xClipEndPos to a big value sothat the blank
                        // strip will be drawn automatically when the last strip
                        // is drawn.
                        //
                        xClipEndPos = MAXCLIPENDPOS;
                    }
                } 
                else 
                {
                    //
                    // This is not the last strip of this line; So, set the ending
                    // clip position accurately.
                    //
                    EditML_IchToXYPos(ped, hdc, ichStart+CurStripLength, FALSE, &pt);
                    xClipEndPos = pt.x;
                }

                //
                // Draw the current strip starting from xStPos, clipped to the area
                // between xClipStPos and xClipEndPos. Obtain "NegCInfo" and use it
                // in drawing the next strip.
                //
                Edit_TabTheTextOut(hdc, xClipStPos, xClipEndPos,
                        xStPos, yPos, (LPSTR)(pText+ichStart*ped->cbChar),
                    CurStripLength+ExtraLengthForNegA, ichStart, ped,
                    ped->rcFmt.left+xOffset, fSelected ? ECT_SELECTED : ECT_NORMAL, &NegCInfo);

                if (fSelected) 
                {
                    //
                    // If this strip was selected, then the next strip won't have
                    // selection attribute
                    //
                    fSelected = FALSE;
                    SetBkColor(hdc, bkColorSave);
                    if (!ped->fDisabled)
                    {
                        SetTextColor(hdc, textColorSave);
                    }
                }

                //
                // Do we have one more strip to draw on the current line?
                //
                if (fDrawOnSameLine || fDrawEndOfLineStrip) 
                {
                    int  iLastDrawnLength;

                    //
                    // Next strip's attribute is decided based on the char at ichAttrib
                    //
                    ichAttrib = ichStart + CurStripLength;

                    //
                    // When drawing the next strip, start at a few chars before
                    // the actual start to account for the Neg 'C' of the strip
                    // just drawn.
                    //
                    iLastDrawnLength = CurStripLength +ExtraLengthForNegA - NegCInfo.nCount;
                    //
                    // Adjust DBCS alignment...
                    //
                    if (ped->fAnsi && ped->fDBCS) 
                    {
                        ichNewStart = Edit_AdjustIch(ped,pText,ichStart+iLastDrawnLength);
                        iLastDrawnLength = ichNewStart - ichStart;
                        ichStart = ichNewStart;
                    } 
                    else 
                    {
                        ichStart += iLastDrawnLength;
                    }
                    LengthToDraw -= iLastDrawnLength;
                    iRemainingLengthInLine -= iLastDrawnLength;

                    //
                    // The start of clip rect for the next strip.
                    //
                    xStPos = NegCInfo.XStartPos;
                    xClipStPos = xClipEndPos;
                }

                //
                // Draw the blank strip at the end of line seperately, if required.
                //
                if (fDrawEndOfLineStrip) 
                {
                    Edit_TabTheTextOut(hdc, xClipStPos, MAXCLIPENDPOS, xStPos, yPos,
                        (LPSTR)(pText+ichStart*ped->cbChar), LengthToDraw, ichStart,
                        ped, ped->rcFmt.left+xOffset, ECT_NORMAL, &NegCInfo);

                    fDrawEndOfLineStrip = FALSE;
                }
            }
            while(fDrawOnSameLine);   // do while loop ends here.
        }

        // Let us move on to the next line of this block to be drawn.
        wCurLine++;
        if (ped->cLines > wCurLine)
        {
            ichStart = ped->chLines[wCurLine];
        }
        else
        {
            ichStart = ichEnd+1;   // We have reached the end of the text.
        }
    }  // while loop ends here

    Edit_Unlock(ped);

    ShowCaret(ped->hwnd);
    EditML_SetCaretPosition(ped, hdc);
}


//---------------------------------------------------------------------------//
//
// Multi-Line Support Routines called Rarely


//---------------------------------------------------------------------------//
//
// EditML_InsertCrCrLf AorW
//
// Inserts CR CR LF characters into the text at soft (word-wrap) line
// breaks. CR LF (hard) line breaks are unaffected. Assumes that the text
// has already been formatted ie. ped->chLines is where we want the line
// breaks to occur. Note that ped->chLines is not updated to reflect the
// movement of text by the addition of CR CR LFs. Returns TRUE if successful
// else notify parent and return FALSE if the memory couldn't be allocated.
//
BOOL EditML_InsertCrCrLf(PED ped)
{
    ICH dch;
    ICH li;
    ICH lineSize;
    unsigned char *pchText;
    unsigned char *pchTextNew;

    if (!ped->fWrap || !ped->cch) 
    {
        //
        // There are no soft line breaks if word-wrapping is off or if no chars
        //
        return TRUE;
    }

    //
    // Calc an upper bound on the number of additional characters we will be
    // adding to the text when we insert CR CR LFs.
    //
    dch = 3 * ped->cLines;

    if (!LocalReAlloc(ped->hText, (ped->cch + dch) * ped->cbChar, 0)) 
    {
        Edit_NotifyParent(ped, EN_ERRSPACE);
        return FALSE;
    }

    ped->cchAlloc = ped->cch + dch;

    //
    // Move the text up dch bytes and then copy it back down, inserting the CR
    // CR LF's as necessary.
    //
    pchTextNew = pchText = Edit_Lock(ped);
    pchText += dch * ped->cbChar;

    //
    // We will use dch to keep track of how many chars we add to the text
    //
    dch = 0;

    //
    // Copy the text up dch bytes to pchText. This will shift all indices in
    // ped->chLines up by dch bytes.
    //
    memmove(pchText, pchTextNew, ped->cch * ped->cbChar);

    //
    // Now copy chars from pchText down to pchTextNew and insert CRCRLF at soft
    // line breaks.
    //
    if (ped->fAnsi) 
    {
        for (li = 0; li < ped->cLines - 1; li++) 
        {
            lineSize = ped->chLines[li + 1] - ped->chLines[li];
            memmove(pchTextNew, pchText, lineSize);
            pchTextNew += lineSize;
            pchText += lineSize;

            //
            // If last character in newly copied line is not a line feed, then we
            // need to add the CR CR LF triple to the end
            //
            if (*(pchTextNew - 1) != 0x0A) 
            {
                *pchTextNew++ = 0x0D;
                *pchTextNew++ = 0x0D;
                *pchTextNew++ = 0x0A;
                dch += 3;
            }
        }

        //
        // Now move the last line up. It won't have any line breaks in it...
        //
        memmove(pchTextNew, pchText, ped->cch - ped->chLines[ped->cLines - 1]);
    } 
    else 
    {
        LPWSTR pwchTextNew = (LPWSTR)pchTextNew;

        for (li = 0; li < ped->cLines - 1; li++) 
        {
            lineSize = ped->chLines[li + 1] - ped->chLines[li];
            memmove(pwchTextNew, pchText, lineSize * sizeof(WCHAR));
            pwchTextNew += lineSize;
            pchText += lineSize * sizeof(WCHAR);

            //
            // If last character in newly copied line is not a line feed, then we
            // need to add the CR CR LF triple to the end
            //
            if (*(pwchTextNew - 1) != 0x0A) 
            {
                *pwchTextNew++ = 0x0D;
                *pwchTextNew++ = 0x0D;
                *pwchTextNew++ = 0x0A;
                dch += 3;
            }
        }

        //
        // Now move the last line up. It won't have any line breaks in it...
        //
        memmove(pwchTextNew, pchText,
            (ped->cch - ped->chLines[ped->cLines - 1]) * sizeof(WCHAR));
    }

    Edit_Unlock(ped);

    if (dch) 
    {
        //
        // Update number of characters in text handle
        //
        ped->cch += dch;

        //
        // So that the next time we do anything with the text, we can strip the
        // CRCRLFs
        //
        ped->fStripCRCRLF = TRUE;

        return TRUE;
    }

    return FALSE;
}


//---------------------------------------------------------------------------//
//
// EditML_StripCrCrLf AorW
//
// Strips the CR CR LF character combination from the text. This
// shows the soft (word wrapped) line breaks. CR LF (hard) line breaks are
// unaffected.
//
void EditML_StripCrCrLf(PED ped)
{
    if (ped->cch) 
    {
        if (ped->fAnsi) 
        {
            unsigned char *pchSrc;
            unsigned char *pchDst;
            unsigned char *pchLast;

            pchSrc = pchDst = Edit_Lock(ped);
            pchLast = pchSrc + ped->cch;
            while (pchSrc < pchLast) 
            {
                if (   (pchSrc[0] == 0x0D)
                    && (pchSrc[1] == 0x0D)
                    && (pchSrc[2] == 0x0A)
                ) 
                {
                    pchSrc += 3;
                    ped->cch -= 3;
                } 
                else 
                {
                    *pchDst++ = *pchSrc++;
                }
            }
        }   
        else 
        {
            LPWSTR pwchSrc;
            LPWSTR pwchDst;
            LPWSTR pwchLast;

            pwchSrc = pwchDst = (LPWSTR)Edit_Lock(ped);
            pwchLast = pwchSrc + ped->cch;
            while (pwchSrc < pwchLast) 
            {
                if (   (pwchSrc[0] == 0x0D)
                    && (pwchSrc[1] == 0x0D)
                    && (pwchSrc[2] == 0x0A)
                ) 
                {
                    pwchSrc += 3;
                    ped->cch -= 3;
                } 
                else 
                {
                    *pwchDst++ = *pwchSrc++;
                }
            }
        }

        Edit_Unlock(ped);

        //
        // Make sure we don't have any values past the last character
        //
        if (ped->ichCaret > ped->cch)
        {
            ped->ichCaret  = ped->cch;
        }

        if (ped->ichMinSel > ped->cch)
        {
            ped->ichMinSel = ped->cch;
        }

        if (ped->ichMaxSel > ped->cch)
        {
            ped->ichMaxSel = ped->cch;
        }
    }
}


//---------------------------------------------------------------------------//
//
// EditML_SetHandle AorW
//
// Sets the ped to contain the given handle.
//
void EditML_SetHandle(PED ped, HANDLE hNewText)
{
    ICH newCch;

    ped->cch = ped->cchAlloc =
            (ICH)LocalSize(ped->hText = hNewText) / ped->cbChar;
    ped->fEncoded = FALSE;

    if (ped->cch) 
    {
        //
        // We have to do it this way in case the app gives us a zero size handle
        //
        if (ped->fAnsi)
        {
            ped->cch = strlen(Edit_Lock(ped));
        }
        else
        {
            ped->cch = wcslen((LPWSTR)Edit_Lock(ped));
        }

        Edit_Unlock(ped);
    }

    newCch = (ICH)(ped->cch + CCHALLOCEXTRA);

    //
    // We do this LocalReAlloc in case the app changed the size of the handle
    //
    if (LocalReAlloc(ped->hText, newCch*ped->cbChar, 0))
    {
        ped->cchAlloc = newCch;
    }

    Edit_ResetTextInfo(ped);
}


//---------------------------------------------------------------------------//
//
// EditML_GetLine AorW
//
// Copies maxCchToCopy bytes of line lineNumber to the buffer
// lpBuffer. The string is not zero terminated.
// 
// Returns number of characters copied
//
LONG EditML_GetLine(PED ped, ICH lineNumber, ICH maxCchToCopy, LPSTR lpBuffer)
{
    PSTR pText;
    ICH cchLen;

    if (lineNumber > ped->cLines - 1) 
    {
        TraceMsg(TF_STANDARD,
                "Edit: Invalid parameter \"lineNumber\" (%ld) to EditML_GetLine",
                lineNumber);

        return 0L;
    }

    cchLen = EditML_Line(ped, lineNumber);
    maxCchToCopy = min(cchLen, maxCchToCopy);

    if (maxCchToCopy) 
    {
        pText = Edit_Lock(ped) +
                ped->chLines[lineNumber] * ped->cbChar;
        memmove(lpBuffer, pText, maxCchToCopy*ped->cbChar);
        Edit_Unlock(ped);
    }

    return maxCchToCopy;
}


//---------------------------------------------------------------------------//
//
// EditML_LineIndex AorW
//
// This function return s the number of character positions that occur
// preceeding the first char in a given line.
//
ICH EditML_LineIndex( PED ped, ICH iLine)
{
    if (iLine == -1)
    {
        iLine = ped->iCaretLine;
    }

    if (iLine < ped->cLines) 
    {
        return ped->chLines[iLine];
    } 
    else 
    {
        TraceMsg(TF_STANDARD,
                "Edit: Invalid parameter \"iLine\" (%ld) to EditML_LineIndex",
                iLine);

        return (ICH)-1;
    }
}


//---------------------------------------------------------------------------//
//
// EditML_LineLength AorW
//
// if ich = -1, return the length of the lines containing the current
// selection but not including the selection. Otherwise, return the length of
// the line containing ich.
//
ICH EditML_LineLength(PED ped, ICH ich)
{
    ICH il1, il2;
    ICH temp;

    if (ich != 0xFFFFFFFF)
    {
        return (EditML_Line(ped, EditML_IchToLine(ped, ich)));
    }

    //
    // Find length of lines corresponding to current selection
    //
    il1 = EditML_IchToLine(ped, ped->ichMinSel);
    il2 = EditML_IchToLine(ped, ped->ichMaxSel);
    if (il1 == il2)
    {
        return (EditML_Line(ped, il1) - (ped->ichMaxSel - ped->ichMinSel));
    }

    temp = ped->ichMinSel - ped->chLines[il1];
    temp += EditML_Line(ped, il2);
    temp -= (ped->ichMaxSel - ped->chLines[il2]);

    return temp;
}


//---------------------------------------------------------------------------//
// 
// EditML_SetSelection AorW
//
// Sets the selection to the points given and puts the cursor at
// ichMaxSel.
//
VOID EditML_SetSelection(PED ped, BOOL fDoNotScrollCaret, ICH ichMinSel, ICH ichMaxSel)
{
    HDC hdc;

    if (ichMinSel == 0xFFFFFFFF) 
    {
        //
        // Set no selection if we specify -1
        //
        ichMinSel = ichMaxSel = ped->ichCaret;
    }

    //
    // Since these are unsigned, we don't check if they are greater than 0.
    //
    ichMinSel = min(ped->cch, ichMinSel);
    ichMaxSel = min(ped->cch, ichMaxSel);

#ifdef FE_SB // EditML_SetSelectionHander()
    //
    // To avoid position to half of DBCS, check and ajust position if necessary
    //
    // We check ped->fDBCS and ped->fAnsi though Edit_AdjustIch checks these bits
    // at first. We're worrying about the overhead of Edit_Lock and Edit_Unlock.
    //
    if ( ped->fDBCS && ped->fAnsi ) 
    {
        PSTR pText;

        pText = Edit_Lock(ped);

        ichMinSel = Edit_AdjustIch( ped, pText, ichMinSel );
        ichMaxSel = Edit_AdjustIch( ped, pText, ichMaxSel );

        Edit_Unlock(ped);
    }
#endif // FE_SB

    //
    // Set the caret's position to be at ichMaxSel.
    //
    ped->ichCaret = ichMaxSel;
    ped->iCaretLine = EditML_IchToLine(ped, ped->ichCaret);

    hdc = Edit_GetDC(ped, FALSE);
    EditML_ChangeSelection(ped, hdc, ichMinSel, ichMaxSel);

    EditML_SetCaretPosition(ped, hdc);
    Edit_ReleaseDC(ped, hdc, FALSE);

#ifdef FE_SB // EditML_SetSelectionHander()
    if (!fDoNotScrollCaret)
    {
        EditML_EnsureCaretVisible(ped);
    }

    //
    // #ifdef KOREA is history, with FE_SB (FarEast Single Binary).
    //
#else
#ifdef KOREA
    //
    // Extra parameter specified interim character mode
    //
    EditML_EnsureCaretVisible(ped,NULL);
#else
    if (!fDoNotScrollCaret)
    {
        EditML_EnsureCaretVisible(ped);
    }
#endif
#endif // FE_SB

}


//---------------------------------------------------------------------------//
//
// EditML_SetTabStops AorW
//
// This sets the tab stop positions set by the App by sending
// a EM_SETTABSTOPS message.
// 
// nTabPos : Number of tab stops set by the caller
// lpTabStops: array of tab stop positions in Dialog units.
// 
// Returns:
// TRUE if successful
// FALSE if memory allocation error.
//
BOOL EditML_SetTabStops(PED ped, int nTabPos, LPINT lpTabStops)
{
    int *pTabStops;

    //
    // Check if tab positions already exist
    //
    if (!ped->pTabStops) 
    {
        //
        // Check if the caller wants the new tab positions
        //
        if (nTabPos) 
        {
            //
            // Allocate the array of tab stops
            //
            pTabStops = (LPINT)UserLocalAlloc(HEAP_ZERO_MEMORY, (nTabPos + 1) * sizeof(int));
            if (!pTabStops) 
            {
                return FALSE;
            }
        } 
        else 
        {
            //
            // No stops then and no stops now!
            //
            return TRUE;
        }
    } 
    else 
    {
        //
        // Check if the caller wants the new tab positions
        //
        if (nTabPos) 
        {
            //
            // Check if the number of tab positions is different
            //
            if (ped->pTabStops[0] != nTabPos) 
            {
                //
                // Yes! So ReAlloc to new size
                //
                pTabStops = (LPINT)UserLocalReAlloc(ped->pTabStops, (nTabPos + 1) * sizeof(int), 0);
                if (!pTabStops)
                {
                    return FALSE;
                }
            } 
            else 
            {
                pTabStops = ped->pTabStops;
            }
        } 
        else 
        {
            //
            // Caller wants to remove all the tab stops; So, release
            //
            if (!UserLocalFree(ped->pTabStops))
            {
                return FALSE;
            }

            ped->pTabStops = NULL;

            goto RedrawAndReturn;
        }
    }

    //
    // Copy the new tab stops onto the tab stop array after converting the
    // dialog co-ordinates into the pixel co-ordinates
    //
    ped->pTabStops = pTabStops;

    //
    // First element contains the count
    //
    *pTabStops++ = nTabPos;
    while (nTabPos--) 
    {
        //
        // aveCharWidth must be used instead of cxSysCharWidth.
        // Fix for Bug #3871 --SANKAR-- 03/14/91
        //
        *pTabStops++ = MultDiv(*lpTabStops++, ped->aveCharWidth, 4);
    }

RedrawAndReturn:
    //
    // Because the tabstops have changed, we need to recompute the
    // maxPixelWidth. Otherwise, horizontal scrolls will have problems.
    // Fix for Bug #6042 - 3/15/94
    //
    EditML_BuildchLines(ped, 0, 0, FALSE, NULL, NULL);

    //
    // Caret may have changed line by the line recalc above.
    //
    EditML_UpdateiCaretLine(ped);

    EditML_EnsureCaretVisible(ped);

    //
    // Also, we need to redraw the whole window.
    //
    InvalidateRect(ped->hwnd, NULL, TRUE);

    return TRUE;
}

//---------------------------------------------------------------------------//
//
// EditML_Undo AorW
// 
// Handles Undo for multiline edit controls.
//
BOOL EditML_Undo(PED ped)
{
    HANDLE hDeletedText = ped->hDeletedText;
    BOOL fDelete = (BOOL)(ped->undoType & UNDO_DELETE);
    ICH cchDeleted = ped->cchDeleted;
    ICH ichDeleted = ped->ichDeleted;

    if (ped->undoType == UNDO_NONE) 
    {
        //
        // No undo...
        //
        return FALSE;
    }

    ped->hDeletedText = NULL;
    ped->cchDeleted = 0;
    ped->ichDeleted = (ICH)-1;
    ped->undoType &= ~UNDO_DELETE;

    if (ped->undoType == UNDO_INSERT) 
    {
        ped->undoType = UNDO_NONE;

        //
        // Set the selection to the inserted text
        //
        EditML_SetSelection(ped, FALSE, ped->ichInsStart, ped->ichInsEnd);
        ped->ichInsStart = ped->ichInsEnd = (ICH)-1;

        //
        // Now send a backspace to delete and save it in the undo buffer...
        //
        SendMessage(ped->hwnd, WM_CHAR, (WPARAM)VK_BACK, 0L);
    }

    if (fDelete) 
    {
        //
        // Insert deleted chars
        //

        //
        // Set the selection to the inserted text
        //
        EditML_SetSelection(ped, FALSE, ichDeleted, ichDeleted);
        EditML_InsertText(ped, hDeletedText, cchDeleted, FALSE);

        GlobalFree(hDeletedText);
        EditML_SetSelection(ped, FALSE, ichDeleted, ichDeleted + cchDeleted);
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
// 
// EditML_Create AorW
// 
// Creates the edit control for the window hwnd by allocating memory
// as required from the application's heap. Notifies parent if no memory
// error (after cleaning up if needed). Returns TRUE if no error else return s
// -1.
//
LONG EditML_Create(PED ped, LPCREATESTRUCT lpCreateStruct)
{
    LONG windowStyle;
    LPWSTR lpszName;

    //
    // Get values from the window instance data structure and put them in the
    // ped so that we can access them easier
    //
    windowStyle = GET_STYLE(ped);

    //
    // Do the standard creation stuff
    //
    if (!Edit_Create(ped, windowStyle)) 
    {
        return -1;
    }

    //
    // Allocate line start array in local heap and lock it down
    //
    ped->chLines = (LPICH)LocalAlloc(LPTR, 2 * sizeof(int));
    if (ped->chLines == NULL) 
    {
        return -1;
    }

    //
    // Call it one line of text...
    //
    ped->cLines = 1;

    //
    // If app wants WS_VSCROLL or WS_HSCROLL, it automatically gets AutoVScroll
    // or AutoHScroll.
    //
    if ((windowStyle & ES_AUTOVSCROLL) || (windowStyle & WS_VSCROLL)) 
    {
        ped->fAutoVScroll = 1;
    }

    if (ped->format != ES_LEFT)
    {
        //
        // If user wants right or center justified text, then we turn off
        // AUTOHSCROLL and WS_HSCROLL since non-left styles don't make sense
        // otherwise.
        //
        windowStyle &= ~WS_HSCROLL;
        ClearWindowState(ped->hwnd, WS_HSCROLL);
        ped->fAutoHScroll = FALSE;
    }
    else if (windowStyle & WS_HSCROLL) 
    {
        ped->fAutoHScroll = TRUE;
    }

    ped->fWrap = (!ped->fAutoHScroll && !(windowStyle & WS_HSCROLL));

    //
    // Max # chars we will allow user to enter
    //
    ped->cchTextMax = MAXTEXT;

    //
    // Set the default font to be the system font.
    //
    if ( !Edit_SetFont(ped, NULL, FALSE) )
    {

        // If setting the font fails, our textmetrics can potentially be left 
        // unitialized. Fail to create the control.
        return -1;
    }

    //
    // Set the window text if needed and notify parent if not enough memory to
    // set the initial text.
    //
    lpszName = (LPWSTR)lpCreateStruct->lpszName;

    if (!Edit_SetEditText(ped, (LPSTR)lpszName))
    {
        return -1;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\edit.h ===
#if !defined(__Edit_h__INCLUDED)
#define __Edit_h__INCLUDED


// 
// Problems arising with edit control and DrawThemeText cause us not to
// render text using theme APIs. However, we still want to use a theme
// handle to draw out client edge.
// Uncomment the following to turn on theme defined text rendering 
// #define _USE_DRAW_THEME_TEXT_
//

//
// Edit WndProc Prototype
//
extern LRESULT Edit_WndProc(
    HWND   hwnd, 
    UINT   uMsg, 
    WPARAM wParam,
    LPARAM lParam);

#define DF_WINDOWFRAME      (COLOR_WINDOWFRAME << 3)

//
// Edit macros
//

//
// Instance data pointer access functions
//
#define Edit_GetPtr(hwnd)       \
            (PED)GetWindowPtr(hwnd, 0)

#define Edit_SetPtr(hwnd, p)    \
            (PED)SetWindowPtr(hwnd, 0, p)

//
// We don't need 64-bit intermediate precision so we use this macro
// instead of calling MulDiv.
//
#define MultDiv(x, y, z)    \
            (((INT)(x) * (INT)(y) + (INT)(z) / 2) / (INT)(z))

#define ISDELIMETERA(ch)    \
            ((ch == ' ') || (ch == '\t'))

#define ISDELIMETERW(ch)    \
            ((ch == L' ') || (ch == L'\t'))

#define AWCOMPARECHAR(ped,pbyte,awchar) \
            (ped->fAnsi ? (*(PUCHAR)(pbyte) == (UCHAR)(awchar)) : (*(LPWSTR)(pbyte) == (WCHAR)(awchar)))

#define CALLWORDBREAKPROC(proc, pText, iStart, cch, iAction)                \
        (* proc)(pText, iStart, cch, iAction)

#ifndef NULL_HIMC
#define NULL_HIMC        (HIMC)  0
#endif

#define EditWndProc EditWndProcW

#define SYS_ALTERNATE           0x2000
#define FAREAST_CHARSET_BITS   (FS_JISJAPAN | FS_CHINESESIMP | FS_WANSUNG | FS_CHINESETRAD)

//
// Length of the buffer for ASCII character width caching: for characters
// 0x00 to 0xff (field charWidthBuffer in PED structure below).
// As the upper half of the cache was not used by almost anyone and fixing
// it's usage required a lot of conversion, we decided to get rid of it
// MCostea #174031
//
#define CHAR_WIDTH_BUFFER_LENGTH 128

//
// NOTE: Text handle is sized as multiple of this constant
//       (should be power of 2).
//
#define CCHALLOCEXTRA   0x20

//
// Maximum width in pixels for a line/rectangle
//
#define MAXPIXELWIDTH   30000
#define MAXCLIPENDPOS   32764


//
// Limit multiline edit controls to at most 1024 characters on a single line.
// We will force a wrap if the user exceeds this limit.
//
#define MAXLINELENGTH   1024

//
// Allow an initial maximum of 30000 characters in all edit controls since
// some apps will run into unsigned problems otherwise.  If apps know about
// the 64K limit, they can set the limit themselves.
//
#define MAXTEXT         30000

//
// Key modifiers which have been pressed.  Code in KeyDownHandler and
// CharHandler depend on these exact values.
//
#define NONEDOWN   0    // Neither shift nor control down
#define CTRLDOWN   1    // Control key only down
#define SHFTDOWN   2    // Shift key only down
#define SHCTDOWN   3    // Shift and control keys down = CTRLDOWN + SHFTDOWN
#define NOMODIFY   4    // Neither shift nor control down

#define IDSYS_SCROLL        0x0000FFFEL

//
// ECTabTheTextOut draw codes
//
#define ECT_CALC        0
#define ECT_NORMAL      1
#define ECT_SELECTED    2

typedef DWORD  ICH;
typedef ICH *LPICH;

//
// Types of undo supported in this ped
//
#define UNDO_NONE   0   // We can't undo the last operation.
#define UNDO_INSERT 1   // We can undo the user's insertion of characters
#define UNDO_DELETE 2   // We can undo the user's deletion of characters

typedef struct 
{
    DWORD fDisableCut : 1;
    DWORD fDisablePaste : 1;
    DWORD fNeedSeparatorBeforeImeMenu : 1;
    DWORD fIME : 1;
} EditMenuItemState;


//
// The following structure is used to store a selection block; In Multiline
// edit controls, "StPos" and "EndPos" fields contain the Starting and Ending
// lines of the block. In Single line edit controls, "StPos" and "EndPos"
// contain the Starting and Ending character positions of the block;
//
typedef struct tagSELBLOCK 
{
    ICH StPos;
    ICH EndPos;
} SELBLOCK, *LPSELBLOCK;


//
// The following structure is used to store complete information about a
// a strip of text.
//
typedef struct 
{
    LPSTR lpString;
    ICH   ichString;
    ICH   nCount;
    int   XStartPos;
}  STRIPINFO;
typedef  STRIPINFO *LPSTRIPINFO;


typedef struct tagUNDO 
{
    UINT  undoType;     // Current type of undo we support
    PBYTE hDeletedText; // Pointer to text which has been deleted (for
                        //   undo) -- note, the memory is allocated as fixed
    ICH   ichDeleted;   // Starting index from which text was deleted
    ICH   cchDeleted;   // Count of deleted characters in buffer
    ICH   ichInsStart;  // Starting index from which text was inserted
    ICH   ichInsEnd;    // Ending index of inserted text
} UNDO, *PUNDO;

#define Pundo(ped)             ((PUNDO)&(ped)->undoType)

typedef struct tagED0 *PED0;
//
// Language pack edit control callouts.
//
// Functions are accessed through the pLpkEditCallout pointer in the ED
// structure. pLpkEditCallout points to a structure containing a pointer
// to each callout routine.
//
#define DECLARE_LPK_CALLOUT(_ret, _fn, _args) \
            _ret (__stdcall *##_fn) _args


typedef struct tagLPKEDITCALLOUT 
{

    DECLARE_LPK_CALLOUT(BOOL, EditCreate,        (PED0, HWND));
    DECLARE_LPK_CALLOUT(INT,  EditIchToXY,       (PED0, HDC, PSTR, ICH, ICH));
    DECLARE_LPK_CALLOUT(ICH,  EditMouseToIch,    (PED0, HDC, PSTR, ICH, INT));
    DECLARE_LPK_CALLOUT(ICH,  EditCchInWidth,    (PED0, HDC, PSTR, ICH, INT));
    DECLARE_LPK_CALLOUT(INT,  EditGetLineWidth,  (PED0, HDC, PSTR, ICH));
    DECLARE_LPK_CALLOUT(VOID, EditDrawText,      (PED0, HDC, PSTR, INT, INT, INT, INT));
    DECLARE_LPK_CALLOUT(BOOL, EditHScroll,       (PED0, HDC, PSTR));
    DECLARE_LPK_CALLOUT(ICH,  EditMoveSelection, (PED0, HDC, PSTR, ICH, BOOL));
    DECLARE_LPK_CALLOUT(INT,  EditVerifyText,    (PED0, HDC, PSTR, ICH, PSTR, ICH));
    DECLARE_LPK_CALLOUT(VOID, EditNextWord ,     (PED0, HDC, PSTR, ICH, BOOL, LPICH, LPICH));
    DECLARE_LPK_CALLOUT(VOID, EditSetMenu,       (PED0, HMENU));
    DECLARE_LPK_CALLOUT(INT,  EditProcessMenu,   (PED0, UINT));
    DECLARE_LPK_CALLOUT(INT,  EditCreateCaret,   (PED0, HDC, INT, INT, UINT));
    DECLARE_LPK_CALLOUT(ICH,  EditAdjustCaret,   (PED0, HDC, PSTR, ICH));

} LPKEDITCALLOUT, *PLPKEDITCALLOUT;

PLPKEDITCALLOUT g_pLpkEditCallout;


#if defined(BUILD_WOW6432)

//
// In user a PWND is actually pointer to kernel memory, so
// it needs to be 64-bits on wow6432 as well.
//
typedef VOID * _ptr64 PWND;

#else

typedef VOID * PWND;

#endif


//
// ! WARNING ! Don't modify this struct. This is is the same user32's tagED struct.
//             Unfortunately the EditLpk callouts expect that struct. Change the 
//             tagED struct below.
//
typedef struct tagED0
{
    HANDLE  hText;              // Block of text we are editing
    ICH     cchAlloc;           // Number of chars we have allocated for hText
    ICH     cchTextMax;         // Max number bytes allowed in edit control
    ICH     cch;                // Current number of bytes of actual text
    ICH     cLines;             // Number of lines of text
    ICH     ichMinSel;          // Selection extent.  MinSel is first selected char
    ICH     ichMaxSel;          // MaxSel is first unselected character
    ICH     ichCaret;           // Caret location. Caret is on left side of char
    ICH     iCaretLine;         // The line the caret is on. So that if word
                                // wrapping, we can tell if the caret is at end
                                // of a line of at beginning of next line...
    ICH     ichScreenStart;     // Index of left most character displayed on
                                // screen for sl ec and index of top most line
                                // for multiline edit controls
    ICH     ichLinesOnScreen;   // Number of lines we can display on screen
    UINT    xOffset;            // x (horizontal) scroll position in pixels
                                // (for multiline text horizontal scroll bar)
    UINT    charPasswordChar;   // If non null, display this character instead
                                // of the real text. So that we can implement
                                // hidden text fields.
    INT     cPasswordCharWidth; // Width of password char
    HWND    hwnd;               // Window for this edit control
    PWND    pwnd;               // placeholder for compatability with user's PED struct
    RECT    rcFmt;              // Client rectangle
    HWND    hwndParent;         // Parent of this edit control window
                                // These vars allow us to automatically scroll
                                // when the user holds the mouse at the bottom
                                // of the multiline edit control window.
    POINT   ptPrevMouse;        // Previous point for the mouse for system timer.
    UINT    prevKeys;           // Previous key state for the mouse


    UINT     fSingle       : 1; // Single line edit control? (or multiline)
    UINT     fNoRedraw     : 1; // Redraw in response to a change?
    UINT     fMouseDown    : 1; // Is mouse button down? when moving mouse
    UINT     fFocus        : 1; // Does ec have the focus?
    UINT     fDirty        : 1; // Modify flag for the edit control
    UINT     fDisabled     : 1; // Window disabled?
    UINT     fNonPropFont  : 1; // Fixed width font?
    UINT     fNonPropDBCS  : 1; // Non-Propotional DBCS font
    UINT     fBorder       : 1; // Draw a border?
    UINT     fAutoVScroll  : 1; // Automatically scroll vertically
    UINT     fAutoHScroll  : 1; // Automatically scroll horizontally
    UINT     fNoHideSel    : 1; // Hide sel when we lose focus?
    UINT     fDBCS         : 1; // Are we using DBCS font set for editing?
    UINT     fFmtLines     : 1; // For multiline only. Do we insert CR CR LF at
                                // word wrap breaks?
    UINT     fWrap         : 1; // Do int  wrapping?
    UINT     fCalcLines    : 1; // Recalc ped->chLines array? (recalc line breaks?)
    UINT     fEatNextChar  : 1; // Hack for ALT-NUMPAD stuff with combo boxes.
                                // If numlock is up, we want to eat the next
                                // character generated by the keyboard driver
                                // if user enter num pad ascii value...
    UINT     fStripCRCRLF  : 1; // CRCRLFs have been added to text. Strip them
                                // before doing any internal edit control stuff
    UINT     fInDialogBox  : 1; // True if the ml edit control is in a dialog
                                // box and we have to specially treat TABS and ENTER
    UINT     fReadOnly     : 1; // Is this a read only edit control? Only
                                // allow scrolling, selecting and copying.
    UINT     fCaretHidden  : 1; // This indicates whether the caret is
                                // currently hidden because the width or height
                                // of the edit control is too small to show it.
    UINT     fTrueType     : 1; // Is the current font TrueType?
    UINT     fAnsi         : 1; // is the edit control Ansi or unicode
    UINT     fWin31Compat  : 1; // TRUE if created by Windows 3.1 app
    UINT     f40Compat     : 1; // TRUE if created by Windows 4.0 app
    UINT     fFlatBorder   : 1; // Do we have to draw this baby ourself?
    UINT     fSawRButtonDown : 1;
    UINT     fInitialized  : 1; // If any more bits are needed, then
    UINT     fSwapRoOnUp   : 1; // Swap reading order on next keyup
    UINT     fAllowRTL     : 1; // Allow RTL processing
    UINT     fDisplayCtrl  : 1; // Display unicode control characters
    UINT     fRtoLReading  : 1; // Right to left reading order

    BOOL    fInsertCompChr  :1; // means WM_IME_COMPOSITION:CS_INSERTCHAR will come
    BOOL    fReplaceCompChr :1; // means need to replace current composition str.
    BOOL    fNoMoveCaret    :1; // means stick to current caret pos.
    BOOL    fResultProcess  :1; // means now processing result.
    BOOL    fKorea          :1; // for Korea
    BOOL    fInReconversion :1; // In reconversion mode
    BOOL    fLShift         :1; // L-Shift pressed with Ctrl

    WORD    wImeStatus;         // current IME status

    WORD    cbChar;             // count of bytes in the char size (1 or 2 if unicode)
    LPICH   chLines;            // index of the start of each line

    UINT    format;             // Left, center, or right justify multiline text.
    EDITWORDBREAKPROCA lpfnNextWord;  // use CALLWORDBREAKPROC macro to call

                                // Next word function
    INT     maxPixelWidth;      // WASICH Width (in pixels) of longest line

    UNDO;                       // Undo buffer

    HANDLE  hFont;              // Handle to the font for this edit control.
                                //  Null if system font.
    INT     aveCharWidth;       // Ave width of a character in the hFont
    INT     lineHeight;         // Height of a line in the hFont
    INT     charOverhang;       // Overhang associated with the hFont
    INT     cxSysCharWidth;     // System font ave width
    INT     cySysCharHeight;    // System font height
    HWND    listboxHwnd;        // ListBox hwnd. Non null if we are a combobox
    LPINT   pTabStops;          // Points to an array of tab stops; First
                                // element contains the number of elements in
                                // the array
    LPINT   charWidthBuffer;
    BYTE    charSet;            // Character set for currently selected font
                                // needed for all versions
    UINT    wMaxNegA;           // The biggest negative A width
    UINT    wMaxNegAcharPos;    // and how many characters it can span accross
    UINT    wMaxNegC;           // The biggest negative C width,
    UINT    wMaxNegCcharPos;    // and how many characters it can span accross
    UINT    wLeftMargin;        // Left margin width in pixels.
    UINT    wRightMargin;       // Right margin width in pixels.

    ICH     ichStartMinSel;
    ICH     ichStartMaxSel;

    PLPKEDITCALLOUT pLpkEditCallout;
    HBITMAP hCaretBitmap;       // Current caret bitmap handle
    INT     iCaretOffset;       // Offset in pixels (for LPK use)

    HANDLE  hInstance;          // for WOW
    UCHAR   seed;               // used to encode and decode password text
    BOOLEAN fEncoded;           // is the text currently encoded
    INT     iLockLevel;         // number of times the text has been locked

    BYTE    DBCSVector[MAX_LEADBYTES];      // DBCS vector table
    HIMC    hImcPrev;           // place to save hImc if we disable IME
    POINT   ptScreenBounding;   // top left corner of edit window in screen
} ED0, *PED0;


typedef struct tagED
{
    ED0;                        // lpk callouts expect user32's ped struct 
                                // so for compatability we'll give it to them.
    HTHEME  hTheme;             // Handle to the theme manager
    PWW     pww;                // RO pointer into the pwnd to ExStyle, Style, State, State2
    HFONT   hFontSave;          // saved the font
    LPWSTR  pszCueBannerText;   // pointer to the text for the cue banner (grey help text)
    UINT    fHot          : 1;  // Is mouse over edit control?
    HWND    hwndBalloon;        // Balloon tip hwnd for EM_BALLOONTIP
    HFONT   hFontPassword;
} ED, *PED, **PPED;


//
//  Edit function prototypes. 
//

//
//  Defined in edit.c
//
PSTR    Edit_Lock(PED);
VOID    Edit_Unlock(PED);
VOID    Edit_InOutReconversionMode(PED, BOOL);
INT     Edit_GetModKeys(INT);
UINT    Edit_TabTheTextOut(HDC, INT, INT, INT, INT, LPSTR, INT, ICH, PED, INT, BOOL, LPSTRIPINFO);
ICH     Edit_CchInWidth(PED, HDC, LPSTR, ICH, INT, BOOL);
HBRUSH  Edit_GetBrush(PED, HDC, LPBOOL);
VOID    Edit_Word(PED, ICH, BOOL, LPICH, LPICH);
VOID    Edit_SaveUndo(PUNDO, PUNDO, BOOL);
VOID    Edit_EmptyUndo(PUNDO);
BOOL    Edit_InsertText(PED, LPSTR, LPICH);
ICH     Edit_DeleteText(PED);
VOID    Edit_NotifyParent(PED, INT);
VOID    Edit_SetClip(PED, HDC, BOOL);
HDC     Edit_GetDC(PED, BOOL);
VOID    Edit_ReleaseDC(PED, HDC, BOOL);
VOID    Edit_ResetTextInfo(PED);
BOOL    Edit_SetEditText(PED, LPSTR);
VOID    Edit_InvalidateClient(PED, BOOL);
BOOL    Edit_CalcChangeSelection(PED, ICH, ICH, LPSELBLOCK, LPSELBLOCK);
INT     Edit_GetDBCSVector(PED, HDC, BYTE);
LPSTR   Edit_AnsiNext(PED, LPSTR);
LPSTR   Edit_AnsiPrev(PED, LPSTR, LPSTR);
ICH     Edit_NextIch(PED, LPSTR, ICH);
ICH     Edit_PrevIch(PED, LPSTR, ICH);
BOOL    Edit_IsDBCSLeadByte(PED, BYTE);
WORD    DbcsCombine(HWND, WORD);
ICH     Edit_AdjustIch(PED, LPSTR, ICH);
ICH     Edit_AdjustIchNext(PED, LPSTR, ICH);
VOID    Edit_UpdateFormat(PED, DWORD, DWORD);
BOOL    Edit_IsFullWidth(DWORD,WCHAR);

__inline LRESULT Edit_ShowBalloonTipWrap(HWND, DWORD, DWORD, DWORD);


//
//  Defined in editrare.c
//
INT     Edit_GetStateId(PED ped);
VOID    Edit_SetMargin(PED, UINT, long, BOOL);
INT     UserGetCharDimensionsEx(HDC, HFONT, LPTEXTMETRICW, LPINT);
ICH     Edit_GetTextHandler(PED, ICH, LPSTR, BOOL);
BOOL    Edit_NcCreate(PED, HWND, LPCREATESTRUCT);
BOOL    Edit_Create(PED ped, LONG windowStyle);
VOID    Edit_NcDestroyHandler(HWND, PED);
VOID    Edit_SetPasswordCharHandler(PED, UINT);
BOOL    GetNegABCwidthInfo(PED ped, HDC hdc);
VOID    Edit_Size(PED ped, LPRECT lprc, BOOL fRedraw);
BOOL    Edit_SetFont(PED, HFONT, BOOL);
BOOL    Edit_IsCharNumeric(PED ped, DWORD keyPress);
VOID    Edit_EnableDisableIME(PED ped);
VOID    Edit_ImmSetCompositionWindow(PED ped, LONG, LONG);
VOID    Edit_SetCompositionFont(PED ped);
VOID    Edit_InitInsert(PED ped, HKL hkl);
VOID    Edit_SetCaretHandler(PED ped);
LRESULT Edit_ImeComposition(PED ped, WPARAM wParam, LPARAM lParam);
BOOL    HanjaKeyHandler(PED ped);  // Korean Support
LRESULT Edit_RequestHandler(PED, WPARAM, LPARAM);  // NT 5.0


//
//  Single line Edit function prototypes 
//
//  Defined in editsl.c
//
INT     EditSL_IchToLeftXPos(PED, HDC, ICH);
VOID    EditSL_SetCaretPosition(PED, HDC);
VOID    EditSL_DrawText(PED, HDC, ICH);
BOOL    EditSL_ScrollText(PED, HDC);
ICH     EditSL_InsertText(PED, LPSTR, ICH);
VOID    EditSL_ReplaceSel(PED, LPSTR);
LRESULT EditSL_WndProc(PED, UINT, WPARAM, LPARAM);


//
//  Multi line Edit function prototypes 
//
//  Defined in editsl.c
//
VOID    EditML_Size(PED, BOOL);
VOID    EditML_SetCaretPosition(PED,HDC);
VOID    EditML_IchToXYPos(PED, HDC, ICH, BOOL, LPPOINT);
VOID    EditML_UpdateiCaretLine(PED ped);
ICH     EditML_InsertText(PED, LPSTR, ICH, BOOL);
VOID    EditML_ReplaceSel(PED, LPSTR);
ICH     EditML_DeleteText(PED);
VOID    EditML_BuildchLines(PED, ICH, int, BOOL, PLONG, PLONG);
LONG    EditML_Scroll(PED, BOOL, int, int, BOOL);
LRESULT EditML_WndProc(PED, UINT, WPARAM, LPARAM);

#endif // __Edit_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\draglist.c ===
#include "ctlspriv.h"

#define DF_ACTUALLYDRAG	0x0001
#define DF_DEFERRED	0x0002

#define INITLINESPERSECOND	6
#define VERTCHANGENUMLINES	25

#define TIMERID		238
#define TIMERLEN	50

#define DX_INSERT	16
#define DY_INSERT	16


typedef struct {
    HWND hwndDrag;
    UINT uFlags;
} DRAGPROP, *PDRAGPROP;

UINT uDragListMsg = 0;
const TCHAR szDragListMsgString[] = DRAGLISTMSGSTRING;

BOOL PtInLBItem(HWND hLB, int nItem, POINT pt, int xInflate, int yInflate)
{
  RECT rc;

  if (nItem < 0)
      nItem = (int)SendMessage(hLB, LB_GETCURSEL, 0, 0L);

  if (SendMessage(hLB, LB_GETITEMRECT, nItem, (LPARAM)(LPRECT)&rc) == LB_ERR)
      return(FALSE);

  InflateRect(&rc, xInflate, yInflate);

  return(PtInRect(&rc, pt));
}


/*
 * DragListSubclassProc
 * --------------------
 *
 * Window procedure for subclassed list boxes
 */
LRESULT CALLBACK DragListSubclassProc(HWND hLB, UINT uMsg, WPARAM wParam,
      LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  PDRAGPROP pDragProp;
  DRAGLISTINFO sNotify;
  BOOL bDragging;
  POINT pt;

  pDragProp = (PDRAGPROP)dwRefData;
  bDragging = pDragProp->hwndDrag == hLB;

  switch (uMsg)
    {
      case WM_NCDESTROY:
        if (bDragging)
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);	/* cancel drag */

        RemoveWindowSubclass(hLB, DragListSubclassProc, 0);

        if (pDragProp)
            LocalFree((HLOCAL)pDragProp);
        break;

      case WM_LBUTTONDOWN:
        {
          int nItem;

          if (bDragging)				/* nested button-down */
              SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);	/* cancel drag */

          SetFocus(hLB);

          pt.x = GET_X_LPARAM(lParam);
          pt.y = GET_Y_LPARAM(lParam);
          ClientToScreen(hLB, &pt);
          nItem = LBItemFromPt(hLB, pt, FALSE);

          if (nItem >= 0)
            {
              SendMessage(hLB, LB_SETCURSEL, nItem, 0L);
              if (GetWindowLong(hLB, GWL_STYLE) & LBS_NOTIFY)
                  SendMessage(GetParent(hLB), WM_COMMAND,
                              GET_WM_COMMAND_MPS(GetDlgCtrlID(hLB), hLB, LBN_SELCHANGE));
              sNotify.uNotification = DL_BEGINDRAG;
              goto QueryParent;
            }
          else
              goto FakeDrag;
        }

      case WM_TIMER:
        if (wParam != TIMERID)
            break;
        lParam = GetMessagePosClient(hLB, &pt);


        // fall through
      case WM_MOUSEMOVE:
	if (bDragging)
	  {
	    HWND hwndParent;
	    LRESULT lResult;

	    /* We may be just simulating a drag, but not actually doing
	     * anything.
	     */
	    if (!(pDragProp->uFlags&DF_ACTUALLYDRAG))
		return(0L);

	    /* We don't want to do any dragging until the user has dragged
	     * outside of the current selection.
	     */
	    if (pDragProp->uFlags & DF_DEFERRED)
	      {
                pt.x = GET_X_LPARAM(lParam);
                pt.y = GET_Y_LPARAM(lParam);
		if (PtInLBItem(hLB, -1, pt, 0, 4))
		    return 0;
		pDragProp->uFlags &= ~DF_DEFERRED;
	      }

	    sNotify.uNotification = DL_DRAGGING;

QueryParent:
	    hwndParent = GetParent(hLB);
	    sNotify.hWnd = hLB;

            sNotify.ptCursor.x = GET_X_LPARAM(lParam);
            sNotify.ptCursor.y = GET_Y_LPARAM(lParam);
	    ClientToScreen(hLB, &sNotify.ptCursor);

            lResult = SendMessage(hwndParent, uDragListMsg, GetDlgCtrlID(hLB),
		  (LPARAM)(LPDRAGLISTINFO)&sNotify);

	    if (uMsg == WM_LBUTTONDOWN)
	      {
		/* Some things may not be draggable
		 */
		if (lResult)
		  {
		    SetTimer(hLB, TIMERID, TIMERLEN, NULL);
		    pDragProp->uFlags = DF_DEFERRED | DF_ACTUALLYDRAG;
		  }
		else
		  {
FakeDrag:
		    pDragProp->uFlags = 0;
		  }

		/* Set capture and change mouse cursor
		 */
		pDragProp->hwndDrag = hLB;

		SetCapture(hLB);
	      }
	    else
	      {
		switch (lResult)
		  {
		    case DL_STOPCURSOR:
                      SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_NO)));
		      break;

		    case DL_COPYCURSOR:
                      SetCursor(LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_COPY)));
		      break;

		    case DL_MOVECURSOR:
                      SetCursor(LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_MOVE)));
		      break;

		    default:
		      break;
		  }
	      }

	    /* Don't call the def proc, since it may try to change the
	     * selection or set timers or things like that.
	     */
	    return(0L);
	  }
	break;

      case  WM_RBUTTONDOWN:
      case  WM_LBUTTONUP:
	/* if we are capturing mouse - release it and check for acceptable place
	 * where mouse is now to decide drop or not
	 */
	if (bDragging)
	  {
	    HWND hwndParent;

	    pDragProp->hwndDrag = NULL;
	    KillTimer(hLB, TIMERID);
	    ReleaseCapture();
	    SetCursor(LoadCursor(NULL, IDC_ARROW));

	    hwndParent = GetParent(hLB);

	    sNotify.uNotification = uMsg==WM_LBUTTONUP ? DL_DROPPED : DL_CANCELDRAG;
	    sNotify.hWnd = hLB;
            sNotify.ptCursor.x = GET_X_LPARAM(lParam);
            sNotify.ptCursor.y = GET_Y_LPARAM(lParam);
	    ClientToScreen(hLB, &sNotify.ptCursor);

	    SendMessage(hwndParent, uDragListMsg, GetDlgCtrlID(hLB),
		  (LPARAM)(LPDRAGLISTINFO)&sNotify);

	    /* We need to make sure to return 0 in case this is from a
	     * keyboard message.
	     */
	    return(0L);
	  }
	break;

      case WM_GETDLGCODE:
	if (bDragging)
          {
            return (DefSubclassProc(hLB, uMsg, wParam, lParam) |
                DLGC_WANTMESSAGE);
          }
	break;

      case WM_KEYDOWN:
        if (wParam == VK_ESCAPE)
          {
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);
          }
        // fall through
      case WM_CHAR:
      case WM_KEYUP:
	/* We don't want the listbox processing this if we are dragging.
	 */
	if (bDragging)
	    return(0L);
	break;

      default:
	break;
    }

  return(DefSubclassProc(hLB, uMsg, wParam, lParam));
}


BOOL WINAPI MakeDragList(HWND hLB)
{
  PDRAGPROP pDragProp;

  if (!uDragListMsg)
      uDragListMsg = RegisterWindowMessage(szDragListMsgString);

  /* Check that we have not already subclassed this window.
   */
  if (GetWindowSubclass(hLB, DragListSubclassProc, 0, NULL))
      return(TRUE);

  pDragProp = (PDRAGPROP)LocalAlloc(LPTR, sizeof(DRAGPROP));
  if (!pDragProp)
      return(FALSE);

  if (!SetWindowSubclass(hLB, DragListSubclassProc, 0, (DWORD_PTR)pDragProp))
  {
      LocalFree((HLOCAL)pDragProp);
      return(FALSE);
  }

  return(TRUE);
}


int WINAPI LBItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll)
{
  static LONG dwLastScroll = 0;

  RECT rc;
  DWORD dwNow;
  int nItem;
  WORD wScrollDelay, wActualDelay;

  ScreenToClient(hLB, &pt);
  GetClientRect(hLB, &rc);

  nItem = (int)SendMessage(hLB, LB_GETTOPINDEX, 0, 0L);

  /* Is the point in the LB client area?
   */
  if (PtInRect(&rc, pt))
    {
      /* Check each visible item in turn.
       */
      for ( ; ; ++nItem)
	{
	  if (SendMessage(hLB, LB_GETITEMRECT, nItem, (LPARAM)(LPRECT)&rc)
		== LB_ERR)
	      break;

	  if (PtInRect(&rc, pt))
	      return(nItem);
	}
    }
  else
    {
      /* If we want autoscroll and the point is directly above or below the
       * LB, determine the direction and if it is time to scroll yet.
       */
      if (bAutoScroll && (UINT)pt.x<(UINT)rc.right)
	{
	  if (pt.y <= 0)
	    {
	      --nItem;
	    }
	  else
	    {
	      ++nItem;
	      pt.y = rc.bottom - pt.y;
	    }
	  wScrollDelay = (WORD)(1000 /
		(INITLINESPERSECOND - pt.y/VERTCHANGENUMLINES));

	  dwNow = GetTickCount();
	  wActualDelay = (WORD)(dwNow - dwLastScroll);

	  if (wActualDelay > wScrollDelay)
	    {
	      /* This will the actual number of scrolls per second to be
	       * much closer to the required number.
	       */
	      if (wActualDelay > wScrollDelay * 2)
		  dwLastScroll = dwNow;
	      else
		  dwLastScroll += wScrollDelay;

	      SendMessage(hLB, LB_SETTOPINDEX, nItem, 0L);
	    }
	}
    }

  return(-1);
}


void WINAPI DrawInsert(HWND hwndParent, HWND hLB, int nItem)
{
  static POINT ptLastInsert;
  static int nLastInsert = -1;

  RECT rc;

  /* Erase the old mark if necessary
   */
  if (nLastInsert>=0 && nItem!=nLastInsert)
    {
      rc.left = ptLastInsert.x;
      rc.top = ptLastInsert.y;
      rc.right = rc.left + DX_INSERT;
      rc.bottom = rc.top + DY_INSERT;

      /* Need to update immediately in case the insert rects overlap.
       */
      InvalidateRect(hwndParent, &rc, TRUE);
      UpdateWindow(hwndParent);

      nLastInsert = -1;
    }

  /* Draw a new mark if necessary
   */
  if (nItem!=nLastInsert && nItem>=0)
    {
      HICON hInsert = NULL;

      if (!hInsert)
	  hInsert = LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(IDI_INSERT));

      if (hInsert)
	{
	  HDC hDC;

	  GetWindowRect(hLB, &rc);
	  ScreenToClient(hLB, (LPPOINT)&rc);
	  ptLastInsert.x = rc.left - DX_INSERT;

	  SendMessage(hLB, LB_GETITEMRECT, nItem, (LPARAM)(LPRECT)&rc);
	  ptLastInsert.y = rc.top - DY_INSERT/2;

	  nLastInsert = nItem;

	  ClientToScreen(hLB, &ptLastInsert);
	  ScreenToClient(hwndParent, &ptLastInsert);

	  hDC = GetDC(hwndParent);
	  DrawIcon(hDC, ptLastInsert.x, ptLastInsert.y, hInsert);
	  ReleaseDC(hwndParent, hDC);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\editsl.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "edit.h"

//---------------------------------------------------------------------------//
//
// Language pack notes:
// With the language pack loaded all positional processing is based on
// ped->xOffset rather than ped->ichScreenStart. The non-lpk optimisation of
// maintaining ped->ichScreenStart doesn't work because of the
// glyph reordering features of complex scripts.
//


//---------------------------------------------------------------------------//
//
// Forwards
//
VOID EditSL_ChangeSelection(PED, HDC, ICH, ICH);
VOID EditSL_DrawLine(PED, HDC, int, int, ICH, int, BOOL);
BOOL EditSL_Undo(PED);


//---------------------------------------------------------------------------//
//
typedef BOOL (*FnGetTextExtentPoint)(HDC, PVOID, int, LPSIZE);


//---------------------------------------------------------------------------//
INT EditSL_CalcStringWidth(PED ped, HDC hdc, ICH ich, ICH cch)
{
    if (cch == 0)
    {
        return 0;
    }

    if (ped->charPasswordChar) 
    {
        return cch * ped->cPasswordCharWidth;
    } 
    else 
    {
        SIZE size;

        if (ped->fNonPropFont && !ped->fDBCS) 
        {
            size.cx = cch * ped->aveCharWidth;
        } 
        else 
        {
            PSTR pText = Edit_Lock(ped);

            if (ped->fAnsi) 
            {
                GetTextExtentPointA(hdc, (LPSTR)(pText + ich), cch, &size);
            } 
            else 
            {
                GetTextExtentPointW(hdc, (LPWSTR)pText + ich, cch, &size);
            }

            Edit_Unlock(ped);
        }

        return size.cx - ped->charOverhang;
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_CalcXOffsetLeft
//
// Calculates the starting offset for left-aligned strings.
//
INT EditSL_CalcXOffsetLeft(PED ped, HDC hdc, ICH ich)
{
    int cch = (int)(ich - ped->ichScreenStart);

    if (cch <= 0)
    {
        return 0;
    }

    return EditSL_CalcStringWidth(ped, hdc, ped->ichScreenStart, cch);
}


//---------------------------------------------------------------------------//
//
// EditSL_CalcXOffsetSpecial
//
// Calculates the horizontal offset (indent) required for right or center
// justified lines.
//
INT EditSL_CalcXOffsetSpecial(PED ped, HDC hdc, ICH ich)
{
    PSTR pText;
    ICH cch, ichStart = ped->ichScreenStart;
    int cx;

    //
    // Calc the number of characters from start to right end.
    //
    pText = Edit_Lock(ped);
    cch = Edit_CchInWidth(ped, hdc, (LPSTR)(pText + ichStart * ped->cbChar),
            ped->cch - ichStart, ped->rcFmt.right - ped->rcFmt.left, TRUE);
    Edit_Unlock(ped);

    //
    // Once the last character of the string has been scrolled out of
    // the view, use normal offset calculation.
    //
    if (ped->ichScreenStart + cch < ped->cch)
    {
        return EditSL_CalcXOffsetLeft(ped, hdc, ich);
    }

    cx = ped->rcFmt.right - ped->rcFmt.left - EditSL_CalcStringWidth(ped,
            hdc, ichStart, cch);

    if (ped->format == ES_CENTER) 
    {
         cx = max(0, cx / 2);
    } 
    else if (ped->format == ES_RIGHT) 
    {
        //
        // Subtract 1 so that the 1 pixel wide cursor will be in the visible
        // region on the very right side of the screen, mle does this.
        //
        cx = max(0, cx - 1);
    }

    return cx + EditSL_CalcStringWidth(ped, hdc, ichStart, ich - ichStart);
}


//---------------------------------------------------------------------------//
//
// EditSL_SetCaretPosition AorW
//
// If the window has the focus, find where the caret belongs and move
// it there.
//
VOID EditSL_SetCaretPosition(PED ped, HDC hdc)
{
    int xPosition;

    //
    // We will only position the caret if we have the focus since we don't want
    // to move the caret while another window could own it.
    //
    if (!ped->fFocus)
    {
        return;
    }

    if (ped->fCaretHidden) 
    {
        SetCaretPos(-20000, -20000);
        return;
    }

    xPosition = EditSL_IchToLeftXPos(ped, hdc, ped->ichCaret);

    //
    // Don't let caret go out of bounds of edit control if there is too much
    // text.
    //
    if (ped->pLpkEditCallout) 
    {
        xPosition += ped->iCaretOffset;
        xPosition = max(xPosition , 0);
        xPosition = min(xPosition, ped->rcFmt.right - 1 -
            ((ped->cxSysCharWidth > ped->aveCharWidth) ? 1 : 2));
    } 
    else 
    {
        xPosition = min(xPosition, ped->rcFmt.right -
            ((ped->cxSysCharWidth > ped->aveCharWidth) ? 1 : 2));
    }

    SetCaretPos(xPosition, ped->rcFmt.top);

    //
    // FE_IME EditSL_SetCaretPosition - ECImmSetCompostionWindow( CFS_POINT )
    //
    if (g_fIMMEnabled && ImmIsIME(GetKeyboardLayout(0))) 
    {
        Edit_ImmSetCompositionWindow(ped, xPosition, ped->rcFmt.top);
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_IchToLeftXPos AorW
//
// Given a character index, find its (left side) x coordinate within
// the ped->rcFmt rectangle assuming the character ped->ichScreenStart is at
// coordinates (ped->rcFmt.top, ped->rcFmt.left). A negative value is
// return ed if the character ich is to the left of ped->ichScreenStart. WARNING:
// ASSUMES AT MOST 1000 characters will be VISIBLE at one time on the screen.
// There may be 64K total characters in the editcontrol, but we can only
// display 1000 without scrolling. This shouldn't be a problem obviously.
//
INT EditSL_IchToLeftXPos(PED ped, HDC hdc, ICH ich)
{
    int textExtent;
    PSTR pText;
    SIZE size;
    int  cchDiff;

    if (ped->pLpkEditCallout) 
    {
       pText = Edit_Lock(ped);
       textExtent = ped->pLpkEditCallout->EditIchToXY((PED0)ped, hdc, pText, ped->cch, ich);
       Edit_Unlock(ped);

       return textExtent;

    }

    //
    // Check if we are adding lots and lots of chars. A paste for example could
    // cause this and GetTextExtents could overflow on this.
    //
    cchDiff = (int)ich - (int)ped->ichScreenStart;
    if (cchDiff > 1000)
    {
        return (30000);
    }
    else if (cchDiff < -1000)
    {
        return (-30000);
    }

    if (ped->format != ES_LEFT)
    {
        return (ped->rcFmt.left + EditSL_CalcXOffsetSpecial(ped, hdc, ich));
    }

    //
    // Caret position /w DBCS text, we can not optimize...
    //
    if (ped->fNonPropFont && !ped->fDBCS)
    {
        return (ped->rcFmt.left + cchDiff*ped->aveCharWidth);
    }

    //
    // Check if password hidden chars are being used.
    //
    if (ped->charPasswordChar)
    {
        return ( ped->rcFmt.left + cchDiff*ped->cPasswordCharWidth);
    }

    pText = Edit_Lock(ped);

    if (ped->fAnsi) 
    {
        if (cchDiff >= 0) 
        {

            GetTextExtentPointA(hdc, (LPSTR)(pText + ped->ichScreenStart),
                    cchDiff, &size);
            textExtent =  size.cx;

            //
            // In case of signed/unsigned overflow since the text extent may be
            // greater than maxint. This happens with long single line edit
            // controls. The rect we edit text in will never be greater than 30000
            // pixels so we are ok if we just ignore them.
            //
            if (textExtent < 0 || textExtent > 31000)
            {
                textExtent = 30000;
            }
        } 
        else 
        {
            GetTextExtentPointA(hdc,(LPSTR)(pText + ich), -cchDiff, &size);
            textExtent = (-1) * size.cx;
        }
    } 
    else 
    {
        if (cchDiff >= 0) 
        {

            GetTextExtentPointW(hdc, (LPWSTR)(pText + ped->ichScreenStart*sizeof(WCHAR)),
                    cchDiff, &size);
            textExtent =  size.cx;

            //
            // In case of signed/unsigned overflow since the text extent may be
            // greater than maxint. This happens with long single line edit
            // controls. The rect we edit text in will never be greater than 30000
            // pixels so we are ok if we just ignore them.
            //
            if (textExtent < 0 || textExtent > 31000)
            {
                textExtent = 30000;
            }
        } 
        else 
        {
            GetTextExtentPointW(hdc,(LPWSTR)(pText + ich*sizeof(WCHAR)), -cchDiff, &size);
            textExtent = (-1) * size.cx;
        }
    }

    Edit_Unlock(ped);

    return (ped->rcFmt.left + textExtent - (textExtent ? ped->charOverhang : 0));
}


//---------------------------------------------------------------------------//
//
// EditSL_SetSelection AorW
//
// Sets the PED to have the new selection specified.
//
VOID EditSL_SetSelection(PED ped, ICH ichSelStart, ICH ichSelEnd)
{
    HDC hdc = Edit_GetDC(ped, FALSE);

    if (ichSelStart == 0xFFFFFFFF) 
    {
        //
        // Set no selection if we specify -1
        //
        ichSelStart = ichSelEnd = ped->ichCaret;
    }

    //
    // Bounds ichSelStart, ichSelEnd are checked in EditSL_ChangeSelection...
    //
    EditSL_ChangeSelection(ped, hdc, ichSelStart, ichSelEnd);

    //
    // Put the caret at the end of the selected text
    //
    ped->ichCaret = ped->ichMaxSel;

    EditSL_SetCaretPosition(ped, hdc);

    //
    // We may need to scroll the text to bring the caret into view...
    //
    EditSL_ScrollText(ped, hdc);

    Edit_ReleaseDC(ped, hdc, FALSE);
}


//---------------------------------------------------------------------------//
VOID EditSL_GetClipRect(PED ped, HDC hdc, ICH ichStart, int iCount, LPRECT lpClipRect)
{
    int  iStCount;
    PSTR pText;

    if (ped->pLpkEditCallout) 
    {
        TraceMsg(TF_STANDARD, "UxEdit: EditSL_GetClipRect - Error - Invalid call with language pack loaded");
        memset(lpClipRect, 0, SIZEOF(RECT));

        return;
    }

    CopyRect(lpClipRect, &ped->rcFmt);

    pText = Edit_Lock(ped);

    //
    // Calculates the starting pos for this piece of text
    //
    if ((iStCount = (int)(ichStart - ped->ichScreenStart)) > 0) 
    {
        if (ped->format == ES_LEFT) 
        {
            lpClipRect->left += EditSL_CalcXOffsetLeft(ped, hdc, ichStart);
        }
    } 
    else 
    {
        //
        // Reset the values to visible portions
        //
        iCount -= (ped->ichScreenStart - ichStart);
        ichStart = ped->ichScreenStart;
    }

    if (ped->format != ES_LEFT) 
    {
        lpClipRect->left += EditSL_CalcXOffsetSpecial(ped, hdc, ichStart);
    }

    if (iCount < 0) 
    {
        //
        // This is not in the visible area of the edit control, so return
        // an empty rect.
        //
        SetRectEmpty(lpClipRect);
        Edit_Unlock(ped);

        return;
    }

    if (ped->charPasswordChar)
    {
        lpClipRect->right = lpClipRect->left + ped->cPasswordCharWidth * iCount;
    }
    else 
    {
        SIZE size;

        if ( ped->fAnsi) 
        {
            GetTextExtentPointA(hdc, pText + ichStart, iCount, &size);
        } 
        else 
        {
            GetTextExtentPointW(hdc, ((LPWSTR)pText) + ichStart, iCount, &size);
        }

        lpClipRect->right = lpClipRect->left + size.cx - ped->charOverhang;
    }

    Edit_Unlock(ped);
}


//---------------------------------------------------------------------------//
//
// EditSL_LpkEditDrawText
//
// lpk!EditDrawText always sets the BkMode for single line edits to OPAQUE.
// This causes painting problems for read-only edits in property sheets.
// Unfortunately, lpk.dll can't be changed since it would break the user32
// edit, so I'm faking lpk!EditDrawText into thinking this isn't a single
// line edit.
//
__inline VOID EditSL_LpkEditDrawText(PED ped, HDC hdc, PSTR pText)
{
    BOOL fSingleSave;
    fSingleSave = ped->fSingle;
    ped->fSingle = FALSE;
    ped->pLpkEditCallout->EditDrawText((PED0)ped, hdc, pText, ped->cch, ped->ichMinSel, ped->ichMaxSel, ped->rcFmt.top);
    ped->fSingle = fSingleSave;
    
}


//---------------------------------------------------------------------------//
//
// EditSL_ChangeSelection AorW
//
// Changes the current selection to have the specified starting and
// ending values. Properly highlights the new selection and unhighlights
// anything deselected. If NewMinSel and NewMaxSel are out of order, we swap
// them. Doesn't update the caret position.
//
VOID EditSL_ChangeSelection(PED ped, HDC hdc, ICH ichNewMinSel, ICH ichNewMaxSel)
{
    ICH temp;
    ICH ichOldMinSel;
    ICH ichOldMaxSel;

    if (ichNewMinSel > ichNewMaxSel) 
    {
        temp = ichNewMinSel;
        ichNewMinSel = ichNewMaxSel;
        ichNewMaxSel = temp;
    }

    ichNewMinSel = min(ichNewMinSel, ped->cch);
    ichNewMaxSel = min(ichNewMaxSel, ped->cch);

    //
    // To avoid position to half of DBCS, check and ajust position if necessary
    //
    // We check ped->fDBCS and ped->fAnsi though Edit_AdjustIch checks these bits.
    // We're worrying about the overhead of EcLock and EcUnlock.
    //
    if (ped->fDBCS && ped->fAnsi) 
    {
        PSTR pText;

        pText = Edit_Lock(ped);
        ichNewMinSel = Edit_AdjustIch( ped, pText, ichNewMinSel );
        ichNewMaxSel = Edit_AdjustIch( ped, pText, ichNewMaxSel );
        Edit_Unlock(ped);
    }

    //
    // Preserve the Old selection
    //
    ichOldMinSel = ped->ichMinSel;
    ichOldMaxSel = ped->ichMaxSel;

    //
    // Set new selection
    //
    ped->ichMinSel = ichNewMinSel;
    ped->ichMaxSel = ichNewMaxSel;

    //
    // We will find the intersection of current selection rectangle with the new
    // selection rectangle. We will then invert the parts of the two rectangles
    // not in the intersection.
    //
    if (IsWindowVisible(ped->hwnd) && (ped->fFocus || ped->fNoHideSel)) 
    {
        SELBLOCK Blk[2];
        int   i;
        RECT  rc;

        if (ped->fFocus)
        {
            HideCaret(ped->hwnd);
        }

        if (ped->pLpkEditCallout) 
        {
            //
            // The language pack handles display while complex script support present
            //
            PSTR   pText;
            HBRUSH hbr = NULL;
            BOOL   fNeedDelete = FALSE;

            //
            // Give user a chance to manipulate the DC
            //
            hbr = Edit_GetBrush(ped, hdc, &fNeedDelete);
            FillRect(hdc, &ped->rcFmt, hbr);
            pText = Edit_Lock(ped);
            EditSL_LpkEditDrawText(ped, hdc, pText);
            Edit_Unlock(ped);
            if (hbr && fNeedDelete)
            {
                DeleteObject(hbr);
            }
        } 
        else 
        {
            Blk[0].StPos = ichOldMinSel;
            Blk[0].EndPos = ichOldMaxSel;
            Blk[1].StPos = ped->ichMinSel;
            Blk[1].EndPos = ped->ichMaxSel;

            if (Edit_CalcChangeSelection(ped, ichOldMinSel, ichOldMaxSel,
                (LPSELBLOCK)&Blk[0], (LPSELBLOCK)&Blk[1])) 
            {
                //
                // Paint the rectangles where selection has changed.
                // Paint both Blk[0] and Blk[1], if they exist.
                //
                for (i = 0; i < 2; i++) 
                {
                    if (Blk[i].StPos != 0xFFFFFFFF) 
                    {
                           EditSL_GetClipRect(ped, hdc, Blk[i].StPos,
                                                   Blk[i].EndPos - Blk[i].StPos, (LPRECT)&rc);
                           EditSL_DrawLine(ped, hdc, rc.left, rc.right, Blk[i].StPos,
                                                Blk[i].EndPos - Blk[i].StPos,
                                      ((Blk[i].StPos >= ped->ichMinSel) &&
                                   (Blk[i].StPos < ped->ichMaxSel)));
                    }
                }
            }
        }

        //
        // Update caret.
        //
        EditSL_SetCaretPosition(ped, hdc);

        if (ped->fFocus)
        {
            ShowCaret(ped->hwnd);
        }
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_DrawLine()
//
// This draws the line starting from ichStart, iCount number of characters;
// fSelStatus is TRUE if we're to draw the text as selected.
//
VOID EditSL_DrawLine(PED ped, HDC hdc, int xClipStPos, int xClipEndPos, ICH ichStart, int iCount, BOOL fSelStatus)
{
    RECT    rc;
    RECT    rcClip;
    PSTR    pText;
    DWORD   rgbSaveBk;
    DWORD   rgbSaveText;
    DWORD   wSaveBkMode;
    int     iStCount;
    ICH     ichNewStart;
    HBRUSH  hbrBack = NULL;
    BOOL    fNeedDelete = FALSE;
    HRESULT  hr;

    if (ped->pLpkEditCallout) 
    {
        TraceMsg(TF_STANDARD, "UxEdit: EditSL_DrawLine - Error - Invalid call with language pack loaded");
        return;
    }

    //
    // Anything to draw?
    //
    // PORTPORT: Note the symantics of IsWindowVisible and _IsWindowVisible are
    //           slightly different.
    if (xClipStPos >= xClipEndPos || !IsWindowVisible(ped->hwnd) )
    {
        return;
    }

    if (ped->fAnsi && ped->fDBCS) 
    {
        PSTR pT,pTOrg;
        int iTCount;

        pText = Edit_Lock(ped);
        ichNewStart = 0;
        if (ichStart > 0) 
        {
            pT = pText + ichStart;
            ichNewStart = ichStart;

            while (ichNewStart &&
                  (ichStart - ichNewStart < ped->wMaxNegCcharPos)) 
            {
                pT = Edit_AnsiPrev(ped, pText, pT);
                ichNewStart = (ICH)(pT - pText);
                if (!ichNewStart)
                {
                    break;
                }
            }

            //
            // B#16152 - win95.
            // In case of T2, SLE always set an additional margin
            // to erase a character (iCount == 0 case), using aveCharWidth.
            // It erases unexpected an extra char if we don't use ichNewStart
            // and it happens when wMaxNegCcharPos == 0.
            //
            if (ped->wMaxNegCcharPos == 0 && iCount == 0) 
            {
                pT = Edit_AnsiPrev(ped, pText, pT);
                ichNewStart = (ICH)(pT - pText);
            }
        }

        iTCount = 0;
        if (ichStart + iCount < ped->cch) 
        {
            pTOrg = pT = pText + ichStart + iCount;
            while ((iTCount < (int)ped->wMaxNegAcharPos) &&
                   (ichStart + iCount + iTCount < ped->cch)) 
            {
                pT = Edit_AnsiNext(ped, pT);
                iTCount = (int)(pT - pTOrg);
            }
        }

        Edit_Unlock(ped);
        iCount = (int)(min(ichStart+iCount+iTCount, ped->cch) - ichNewStart);
    } 
    else 
    {
        //
        // Reset ichStart to take care of the negative C widths
        //
        ichNewStart = max((int)(ichStart - ped->wMaxNegCcharPos), 0);

        //
        // Reset ichCount to take care of the negative C and A widths
        //
        iCount = (int)(min(ichStart+iCount+ped->wMaxNegAcharPos, ped->cch)
                    - ichNewStart);
    }

    ichStart = ichNewStart;

    //
    // Reset ichStart and iCount to the first one visible on the screen
    //
    if (ichStart < ped->ichScreenStart) 
    {
        if (ichStart+iCount < ped->ichScreenStart)
        {
            return;
        }

        iCount -= (ped->ichScreenStart-ichStart);
        ichStart = ped->ichScreenStart;
    }

    CopyRect(&rc, &ped->rcFmt);

    //
    // Set the drawing rectangle
    //
    rcClip.left   = xClipStPos;
    rcClip.right  = xClipEndPos;
    rcClip.top    = rc.top;
    rcClip.bottom = rc.bottom;

    //
    // Set the proper clipping rectangle
    //
    Edit_SetClip(ped, hdc, TRUE);

    pText = Edit_Lock(ped);

    //
    // Calculate the starting pos for this piece of text
    //
    if (ped->format == ES_LEFT) 
    {
        if (iStCount = (int)(ichStart - ped->ichScreenStart)) 
        {
            rc.left += EditSL_CalcXOffsetLeft(ped, hdc, ichStart);
        }
    } 
    else 
    {
        rc.left += EditSL_CalcXOffsetSpecial(ped, hdc, ichStart);
    }

    //
    // Set the background mode before calling NtUserGetControlBrush so that the app
    // can change it to TRANSPARENT if it wants to.
    //
    SetBkMode(hdc, OPAQUE);

    hr = E_FAIL;
#ifdef _USE_DRAW_THEME_TEXT_
    if ( ped->hTheme )
    {
        INT iState;
        INT iProp;
        COLORREF clrBk;
        COLORREF clrText;

        iState = fSelStatus ? ETS_SELECTED : Edit_GetStateId(ped);
        iProp  = fSelStatus ? TMT_HIGHLIGHT : TMT_FILLCOLOR;
        hr = GetThemeColor(ped->hTheme, EP_EDITTEXT, iState, iProp, &clrBk);
        if ( SUCCEEDED(hr) )
        {
            iProp  = fSelStatus ? TMT_HIGHLIGHTTEXT : TMT_TEXTCOLOR;
            hr = GetThemeColor(ped->hTheme, EP_EDITTEXT, iState, iProp, &clrText);

            if ( SUCCEEDED(hr) )
            {
                hbrBack     = CreateSolidBrush(clrBk);
                fNeedDelete = TRUE;
                rgbSaveBk   = SetBkColor(hdc, clrBk);
                rgbSaveText = SetTextColor(hdc, clrText);
            }
        }
    }
#endif // _USE_DRAW_THEME_TEXT_

    if ( !ped->hTheme || FAILED(hr) )
    {
        if (fSelStatus)
        {
            //
            // if we're not themed or we are themed but failed
            // to get the highlight and highlighttext colors
            //
            // use normal colors
            //
            hbrBack = GetSysColorBrush(COLOR_HIGHLIGHT);
            if (hbrBack == NULL) 
            {
                goto sldl_errorexit;
            }

            rgbSaveBk = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
            rgbSaveText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

        } 
        else
        {
            //
            // We always want to send this so that the app has a chance to muck
            // with the DC.
            //
            // Note that ReadOnly and Disabled edit fields are drawn as "static"
            // instead of as "active."
            //
            hbrBack = Edit_GetBrush(ped, hdc, &fNeedDelete);
            rgbSaveBk = GetBkColor(hdc);
            rgbSaveText = GetTextColor(hdc);
        }
    }

    //
    // Erase the rectangular area before text is drawn. Note that we inflate
    // the rect by 1 so that the selection color has a one pixel border around
    // the text.
    //
    InflateRect(&rcClip, 0, 1);
    FillRect(hdc, &rcClip, hbrBack);
    InflateRect(&rcClip, 0, -1);

    if (ped->charPasswordChar) 
    {
        wSaveBkMode = SetBkMode(hdc, TRANSPARENT);

        for (iStCount = 0; iStCount < iCount; iStCount++) 
        {
            if ( ped->fAnsi )
            {
                ExtTextOutA(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                            (LPSTR)&ped->charPasswordChar, 1, NULL);
            }
            else
            {
                ExtTextOutW(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                            (LPWSTR)&ped->charPasswordChar, 1, NULL);
            }

            rc.left += ped->cPasswordCharWidth;
        }

        SetBkMode(hdc, wSaveBkMode);
    } 
    else 
    {
        if ( ped->fAnsi )
        {
            ExtTextOutA(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                    pText+ichStart,iCount, NULL);
        }
        else
        {
            ExtTextOutW(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                    ((LPWSTR)pText)+ichStart,iCount, NULL);
        }
    }

    SetTextColor(hdc, rgbSaveText);
    SetBkColor(hdc, rgbSaveBk);

    if (hbrBack && fNeedDelete)
    {
        DeleteObject(hbrBack);
    }

sldl_errorexit:

    Edit_Unlock(ped);
}


//---------------------------------------------------------------------------//
//
// EditSL_GetBlkEnd AorW
// 
// Given a Starting point and and end point, this function return s whether the
// first few characters fall inside or outside the selection block and if so,
// howmany characters?
//
INT EditSL_GetBlkEnd(PED ped, ICH ichStart, ICH ichEnd, BOOL *lpfStatus)
{
    *lpfStatus = FALSE;
    if (ichStart >= ped->ichMinSel) 
    {
        if (ichStart >= ped->ichMaxSel)
        {
            return (ichEnd - ichStart);
        }

        *lpfStatus = TRUE;

        return (min(ichEnd, ped->ichMaxSel) - ichStart);
    }

    return (min(ichEnd, ped->ichMinSel) - ichStart);
}


//---------------------------------------------------------------------------//
//
// EditSL_DrawCueBannerText (Unicode Only!)
//
// This function is called by EditSL_DrawText to display the cue banner text in
// the edit box.
// 
// Note:
//  May need to call pLpkEditCallout to support complex scripts.
//
VOID EditSL_DrawCueBannerText(PED ped, HDC hdc, RECT rc)
{
    //
    // Draw the overlay of the cue banner text.
    // Only draw this text if:
    //		1. has cue banner text to display
    //		2. the edit box is empty,  
    // 		3. does not have focus, 
    //		4. is not disabled 
    //      5. and is not read only
    //
    if (ped->pszCueBannerText
    	&& ped->cch == 0 
    	&& !ped->fFocus 
    	&& !ped->fDisabled
    	&& !ped->fReadOnly)
    {
        COLORREF crOldColor;
        UINT iOldAlign; 
    
        //
    	// Setup the font to be light gray
    	// NOTE: Should this be read from the theme manager?
    	//
    	crOldColor = SetTextColor(hdc, GetSysColor(COLOR_BTNSHADOW));
        
        //
    	// Setup the alignment for the text to display.
    	// We will match our alignment with the alignment that is
    	// actually used for text in the edit control
    	//
    	switch (ped->format)
    	{
    	case ES_LEFT:
    		iOldAlign = SetTextAlign(hdc, TA_LEFT);		
    		break;
    	case ES_RIGHT:
    		iOldAlign = SetTextAlign(hdc, TA_RIGHT);		
    		break;
    	case ES_CENTER:
    		iOldAlign = SetTextAlign(hdc, TA_CENTER);		
    		break;
    	}

    	// Draw the text to the box:
        ExtTextOutW(hdc, 				
                    rc.left,
                    rc.top,
                    ETO_CLIPPED, 		
                    &(ped->rcFmt),
                    ped->pszCueBannerText,          // Text
                    wcslen(ped->pszCueBannerText),  // Size of text
                    NULL);

        //
        // Reset the alignment
        //
        SetTextAlign(hdc, iOldAlign);

        //
        // Reset the color back:
        //
        SetTextColor(hdc, crOldColor);
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_DrawText AorW
//
// Draws text for a single line edit control in the rectangle
// specified by ped->rcFmt. If ichStart == 0, starts drawing text at the left
// side of the window starting at character index ped->ichScreenStart and draws
// as much as will fit. If ichStart > 0, then it appends the characters
// starting at ichStart to the end of the text showing in the window. (ie. We
// are just growing the text length and keeping the left side
// (ped->ichScreenStart to ichStart characters) the same. Assumes the hdc came
// from Edit_GetDC so that the caret and such are properly hidden.
//
VOID EditSL_DrawText(PED ped, HDC hdc, ICH ichStart)
{
    ICH    cchToDraw;
    RECT   rc;
    PSTR   pText;
    BOOL   fSelStatus;
    int    iCount, iStCount;
    ICH    ichEnd;
    BOOL   fNoSelection;
    BOOL   fCalcRect;
    BOOL   fDrawLeftMargin = FALSE;
    BOOL   fDrawEndOfLineStrip = FALSE;
    SIZE   size;
    HBRUSH hbr = NULL;
    BOOL   fNeedDelete = FALSE;

    //
    // PORTPORT: Note the symantics of IsWindowVisible and _IsWindowVisible are
    //           slightly different.
    //
    if (!IsWindowVisible(ped->hwnd))
    {
        return;
    }

    if (ped->pLpkEditCallout) 
    {
        //
        // The language pack handles display while complex script support present
        //

        //
        // Give user a chance to manipulate the DC
        //
        hbr = Edit_GetBrush(ped, hdc, &fNeedDelete);
        pText = Edit_Lock(ped);
        EditSL_LpkEditDrawText(ped, hdc, pText);
        Edit_Unlock(ped);
        EditSL_SetCaretPosition(ped, hdc);
        if (hbr && fNeedDelete)
        {
            DeleteObject(hbr);
        }

        return;
    }

    //
    // When drawing the entire visible content of special-aligned sle
    // erase the view.
    //
    if (ped->format != ES_LEFT && ichStart == 0)
    {
        hbr = Edit_GetBrush(ped, hdc, &fNeedDelete);
        FillRect(hdc, &ped->rcFmt, hbr);
        if (hbr && fNeedDelete)
        {
            DeleteObject(hbr);
        }
    }

    pText = Edit_Lock(ped);

    if (ichStart < ped->ichScreenStart) 
    {
#if DBG
        ICH ichCompare = Edit_AdjustIch(ped, pText, ped->ichScreenStart);
        UserAssert(ichCompare == ped->ichScreenStart);
#endif
        ichStart = ped->ichScreenStart;
    }
    else if (ped->fDBCS && ped->fAnsi) 
    {
        //
        // If ichStart stays on trailing byte of DBCS, we have to
        // adjust it.
        //
        ichStart = Edit_AdjustIch(ped, pText, ichStart);
    }

    CopyRect((LPRECT)&rc, (LPRECT)&ped->rcFmt);

    //
    // Find out how many characters will fit on the screen so that we don't do
    // any needless drawing.
    //
    cchToDraw = Edit_CchInWidth(ped, hdc,
            (LPSTR)(pText + ped->ichScreenStart * ped->cbChar),
            ped->cch - ped->ichScreenStart, rc.right - rc.left, TRUE);
    ichEnd = ped->ichScreenStart + cchToDraw;

    //
    // There is no selection if,
    // 1. MinSel and MaxSel are equal OR
    // 2. (This has lost the focus AND Selection is to be hidden)
    //
    fNoSelection = ((ped->ichMinSel == ped->ichMaxSel) || (!ped->fFocus && !ped->fNoHideSel));

    if (ped->format == ES_LEFT) 
    {
        if (iStCount = (int)(ichStart - ped->ichScreenStart)) 
        {
            rc.left += EditSL_CalcXOffsetLeft(ped, hdc, ichStart);
        }
    } 
    else 
    {
        rc.left += EditSL_CalcXOffsetSpecial(ped, hdc, ichStart);
    }

    //
    // If this is the begining of the whole line, we may have to draw a blank
    // strip at the begining.
    //
    if ((ichStart == 0) && ped->wLeftMargin)
    {
        fDrawLeftMargin = TRUE;
    }

    //
    // If there is nothing to draw, that means we need to draw the end of
    // line strip, which erases the last character.
    //
    if (ichStart == ichEnd) 
    {
        fDrawEndOfLineStrip = TRUE;
        rc.left -= ped->wLeftMargin;
    }

    while (ichStart < ichEnd) 
    {
        fCalcRect = TRUE;

        if (fNoSelection) 
        {
            fSelStatus = FALSE;
            iCount = ichEnd - ichStart;
        } 
        else 
        {
            if (fDrawLeftMargin) 
            {
                iCount = 0;
                fSelStatus = FALSE;
                fCalcRect = FALSE;
                rc.right = rc.left;
            } 
            else
            {
                iCount = EditSL_GetBlkEnd(ped, ichStart, ichEnd,
                    (BOOL  *)&fSelStatus);
            }
        }


        if (ichStart+iCount == ichEnd) 
        {
            if (fSelStatus)
            {
                fDrawEndOfLineStrip = TRUE;
            }
            else 
            {
                rc.right = ped->rcFmt.right + ped->wRightMargin;
                fCalcRect = FALSE;
            }
        }

        if (fCalcRect) 
        {
            if (ped->charPasswordChar)
            {
                rc.right = rc.left + ped->cPasswordCharWidth * iCount;
            }
            else 
            {
                if ( ped->fAnsi )
                {
                    GetTextExtentPointA(hdc, pText + ichStart,
                                        iCount, &size);
                }
                else
                {
                    GetTextExtentPointW(hdc, ((LPWSTR)pText) + ichStart,
                                        iCount, &size);
                }

                rc.right = rc.left + size.cx;

                //
                // The extent is equal to the advance width. So for TrueType fonts
                // we need to take care of Neg A and C. For non TrueType, the extent
                // includes the overhang.
                // If drawing the selection, draw only the advance width
                //
                if (fSelStatus) 
                {
                    rc.right -= ped->charOverhang;
                } 
                else if (ped->fTrueType) 
                {
                    rc.right += ped->wMaxNegC;
                    if (iStCount > 0) 
                    {
                        rc.right += ped->wMaxNegA;
                        iStCount = 0;
                    }
                }

            }

        }

        if (fDrawLeftMargin) 
        {
            fDrawLeftMargin = FALSE;
            rc.left -= ped->wLeftMargin;
            if (rc.right < rc.left) 
            {
                rc.right = rc.left;
            }
        }

        EditSL_DrawLine(ped, hdc, rc.left, rc.right, ichStart, iCount, fSelStatus);

        ichStart += iCount;
        rc.left = rc.right;

        //
        // If we're going to draw the selection, adjust rc.left
        // to include advance width of the selected text
        // For non TT fonts, ped->wMaxNegC equals ped->charOverhang
        //
        if (!fSelStatus && (iCount != 0) && (ichStart < ichEnd)) 
        {
            rc.left -= ped->wMaxNegC;
        }
    }
	   
    Edit_Unlock(ped);

    //
    // Check if anything to be erased on the right hand side
    //
    if (fDrawEndOfLineStrip &&
            (rc.left < (rc.right = (ped->rcFmt.right+ped->wRightMargin))))
    {
        EditSL_DrawLine(ped, hdc, rc.left, rc.right, ichStart, 0, FALSE);
    }

    EditSL_SetCaretPosition(ped, hdc);

    //
    // Call the function to display the cue banner text into the edit box
    //
    EditSL_DrawCueBannerText(ped, hdc, rc);
}


//---------------------------------------------------------------------------//
//
// EditSL_ScrollText AorW
//
// Scrolls the text to bring the caret into view. If the text is
// scrolled, the current selection is unhighlighted. Returns TRUE if the text
// is scrolled else return s false.
//
BOOL EditSL_ScrollText(PED ped, HDC hdc)
{
    PSTR pTextScreenStart;
    ICH scrollAmount;
    ICH newScreenStartX = ped->ichScreenStart;
    ICH cch;
    BOOLEAN fAdjustNext = FALSE;

    if (!ped->fAutoHScroll)
    {
        return FALSE;
    }

    if (ped->pLpkEditCallout) 
    {
        BOOL fChanged;

        //
        // With complex script glyph reordering, use lpk to do horz scroll
        //
        pTextScreenStart = Edit_Lock(ped);
        fChanged = ped->pLpkEditCallout->EditHScroll((PED0)ped, hdc, pTextScreenStart);
        Edit_Unlock(ped);

        if (fChanged) 
        {
            EditSL_DrawText(ped, hdc, 0);
        }

        return fChanged;
    }

    //
    // Calculate the new starting screen position
    //
    if (ped->ichCaret <= ped->ichScreenStart) 
    {
        //
        // Caret is to the left of the starting text on the screen we must
        // scroll the text backwards to bring it into view. Watch out when
        // subtracting unsigned numbers when we have the possibility of going
        // negative.
        //
        pTextScreenStart = Edit_Lock(ped);

        scrollAmount = Edit_CchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                ped->ichCaret, (ped->rcFmt.right - ped->rcFmt.left) / 4, FALSE);

        newScreenStartX = ped->ichCaret - scrollAmount;
        Edit_Unlock(ped);
    } 
    else if (ped->ichCaret != ped->ichScreenStart) 
    {
        pTextScreenStart = Edit_Lock(ped);
        pTextScreenStart += ped->ichScreenStart * ped->cbChar;

        cch = Edit_CchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                ped->ichCaret - ped->ichScreenStart,
                ped->rcFmt.right - ped->rcFmt.left, FALSE);

        if (cch < ped->ichCaret - ped->ichScreenStart) 
        {
            fAdjustNext = TRUE;

            //
            // Scroll Forward 1/4 -- if that leaves some empty space
            // at the end, scroll back enough to fill the space
            //
            newScreenStartX = ped->ichCaret - (3 * cch / 4);

            cch = Edit_CchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                    ped->cch - ped->ichScreenStart,
                    ped->rcFmt.right - ped->rcFmt.left, FALSE);

            if (newScreenStartX > (ped->cch - cch))
            {
                newScreenStartX = ped->cch - cch;
            }
        } 
        else if (ped->format != ES_LEFT) 
        {
            cch = Edit_CchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                    ped->cch - ped->ichScreenStart,
                    ped->rcFmt.right - ped->rcFmt.left, FALSE);

            //
            // Scroll the text hidden behind the left border back
            // into view.
            //
            if (ped->ichScreenStart == ped->cch - cch) 
            {
                pTextScreenStart -= ped->ichScreenStart * ped->cbChar;
                cch = Edit_CchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                        ped->cch, ped->rcFmt.right - ped->rcFmt.left, FALSE);

                newScreenStartX = ped->cch - cch;
            }
        }

        Edit_Unlock(ped);
    }

    //
    // Adjust newScreenStartX
    //
    if (ped->fAnsi && ped->fDBCS) 
    {
        newScreenStartX = (fAdjustNext ? Edit_AdjustIchNext : Edit_AdjustIch)(ped,
                                                                        Edit_Lock(ped),
                                                                        newScreenStartX);
        Edit_Unlock(ped);
    }

    if (ped->ichScreenStart != newScreenStartX) 
    {
        //
        // Check if we have to wipe out the left margin
        //
        if (ped->wLeftMargin && (ped->ichScreenStart == 0)) 
        {
            RECT   rc;
            HBRUSH hBrush = NULL;
            BOOL   fNeedDelete = FALSE;

            hBrush = Edit_GetBrush(ped, hdc, &fNeedDelete);

            CopyRect(&rc, &ped->rcFmt);
            InflateRect(&rc, 0, 1);
            rc.right = rc.left;
            rc.left -= ped->wLeftMargin;

            FillRect(hdc, &rc, hBrush);
            if (hBrush && fNeedDelete)
            {
                DeleteObject(hBrush);
            }
        }

        ped->ichScreenStart = newScreenStartX;
        EditSL_DrawText(ped, hdc, 0);

        //
        // Caret pos is set by EditSL_DrawText().
        //
        return TRUE;
    }

    return FALSE;
}


//---------------------------------------------------------------------------//
//
// EditSL_InsertText AorW
//
// Adds up to cchInsert characters from lpText to the ped starting at
// ichCaret. If the ped only allows a maximum number of characters, then we
// will only add that many characters to the ped and send a EN_MAXTEXT
// notification code to the parent of the ec. Also, if !fAutoHScroll, then we
// only allow as many chars as will fit in the client rectangle. The number of
// characters actually added is return ed (could be 0). If we can't allocate
// the required space, we notify the parent with EN_ERRSPACE and no characters
// are added.
//
ICH EditSL_InsertText(PED ped, LPSTR lpText, ICH cchInsert)
{
    HDC hdc;
    PSTR pText;
    ICH cchInsertCopy = cchInsert;
    ICH cchT;
    int textWidth;
    SIZE size;

    //
    // First determine exactly how many characters from lpText we can insert
    // into the ped.
    //
    if( ped->cchTextMax <= ped->cch)
    {
       cchInsert = 0;
    }
    else 
    {
        if (!ped->fAutoHScroll) 
        {
            pText = Edit_Lock(ped);
            hdc = Edit_GetDC(ped, TRUE);

            cchInsert = min(cchInsert, (unsigned)(ped->cchTextMax - ped->cch));
            if (ped->charPasswordChar)
            {
                textWidth = ped->cch * ped->cPasswordCharWidth;
            }
            else 
            {
                if (ped->fAnsi)
                {
                    GetTextExtentPointA(hdc, (LPSTR)pText,  ped->cch, &size);
                }
                else
                {
                    GetTextExtentPointW(hdc, (LPWSTR)pText, ped->cch, &size);
                }

                textWidth = size.cx;
            }

            cchT = Edit_CchInWidth(ped, hdc, lpText, cchInsert,
                                ped->rcFmt.right - ped->rcFmt.left -
                                textWidth, TRUE);
            cchInsert = min(cchInsert, cchT);

            Edit_Unlock(ped);
            Edit_ReleaseDC(ped, hdc, TRUE);
        } 
        else 
        {
            cchInsert = min((unsigned)(ped->cchTextMax - ped->cch), cchInsert);
        }
    }

    //
    // Now try actually adding the text to the ped
    //
    if (cchInsert && !Edit_InsertText(ped, lpText, &cchInsert)) 
    {
        Edit_NotifyParent(ped, EN_ERRSPACE);
        return 0;
    }
    if (cchInsert)
    {
        ped->fDirty = TRUE;
    }

    if (cchInsert < cchInsertCopy) 
    {
        //
        // Notify parent that we couldn't insert all the text requested
        //
        Edit_NotifyParent(ped, EN_MAXTEXT);
    }

    //
    // Update selection extents and the caret position. Note that Edit_InsertText
    // updates ped->ichCaret, ped->ichMinSel, and ped->ichMaxSel to all be after
    // the inserted text.
    //
    return cchInsert;
}


//---------------------------------------------------------------------------//
//
// EditSL_PasteText AorW
//
// Pastes a line of text from the clipboard into the edit control
// starting at ped->ichMaxSel. Updates ichMaxSel and ichMinSel to point to
// the end of the inserted text. Notifies the parent if space cannot be
// allocated. Returns how many characters were inserted.
//
ICH EditSL_PasteText(PED ped)
{
    HANDLE hData;
    LPSTR lpchClip;
    ICH cchAdded = 0;
    ICH clipLength;

    if (!OpenClipboard(ped->hwnd))
    {
        goto PasteExitNoCloseClip;
    }
    
    hData = GetClipboardData(ped->fAnsi ? CF_TEXT : CF_UNICODETEXT);
    if (!hData || (GlobalFlags(hData) == GMEM_INVALID_HANDLE)) 
    {
        TraceMsg(TF_STANDARD, "UxEdit: EditSL_PasteText(): couldn't get a valid handle(%x)", hData);
        goto PasteExit;
    }

    lpchClip = GlobalLock(hData);
    if (lpchClip == NULL) 
    {
        TraceMsg(TF_STANDARD, "UxEdit: EditSL_PasteText(): USERGLOBALLOCK(%x) failed.", hData);
        goto PasteExit;
    }

    if (ped->fAnsi) 
    {
        LPSTR lpchClip2 = lpchClip;

        //
        // Find the first carrage return or line feed. Just add text to that point.
        //
        clipLength = (UINT)strlen(lpchClip);
        for (cchAdded = 0; cchAdded < clipLength; cchAdded++)
        {
            if (*lpchClip2++ == 0x0D)
            {
                break;
            }
        }

    } 
    else 
    {
        LPWSTR lpwstrClip2 = (LPWSTR)lpchClip;

        //
        // Find the first carrage return or line feed. Just add text to that point.
        //
        clipLength = (UINT)wcslen((LPWSTR)lpchClip);
        for (cchAdded = 0; cchAdded < clipLength; cchAdded++)
        {
            if (*lpwstrClip2++ == 0x0D)
            {
                break;
            }
        }
    }

    //
    // Insert the text (EditSL_InsertText checks line length)
    //
    cchAdded = EditSL_InsertText(ped, lpchClip, cchAdded);

    GlobalUnlock(hData);

PasteExit:
    CloseClipboard();

PasteExitNoCloseClip:
    return cchAdded;
}


//---------------------------------------------------------------------------//
//
// EditSL_ReplaceSel AorW
//
// Replaces the text in the current selection with the given text.
//
VOID EditSL_ReplaceSel(PED ped, LPSTR lpText)
{
    UINT cchText;

    //
    // Delete text, putting it into the clean undo buffer.
    //
    Edit_EmptyUndo(Pundo(ped));
    Edit_DeleteText(ped);

    //
    // B#3356
    // Some apps do "clear" by selecting all of the text, then replacing it
    // with "", in which case EditSL_InsertText() will return 0.  But that
    // doesn't mean failure...
    //
    if ( ped->fAnsi )
    {
        cchText = strlen(lpText);
    }
    else
    {
        cchText = wcslen((LPWSTR)lpText);
    }

    if (cchText) 
    {
        BOOL fFailed;
        UNDO undo;
        HWND hwndSave;

        //
        // Save undo buffer, but DO NOT CLEAR IT!
        //
        Edit_SaveUndo(Pundo(ped), &undo, FALSE);

        hwndSave = ped->hwnd;
        fFailed = (BOOL) !EditSL_InsertText(ped, lpText, cchText);
        if (!IsWindow(hwndSave))
        {
            return;
        }

        if (fFailed) 
        {
            //
            // UNDO the previous edit.
            //
            Edit_SaveUndo(&undo, Pundo(ped), FALSE);
            EditSL_Undo(ped);
            return;
        }
    }

    //
    // Success.  So update the display
    //
    Edit_NotifyParent(ped, EN_UPDATE);

    // PORTPORT: Note the symantics of IsWindowVisible and _IsWindowVisible are
    //           slightly different.
    if (IsWindowVisible(ped->hwnd)) 
    {
        HDC hdc;

        hdc = Edit_GetDC(ped, FALSE);

        if (!EditSL_ScrollText(ped, hdc))
        {
            EditSL_DrawText(ped, hdc, 0);
        }

        Edit_ReleaseDC(ped, hdc, FALSE);
    }

    Edit_NotifyParent(ped, EN_CHANGE);

    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
}


//---------------------------------------------------------------------------//
//
// EditSL_Char AorW
// 
// Handles character input
//
VOID EditSL_Char(PED ped, DWORD keyValue)
{
    HDC hdc;
    WCHAR keyPress;
    BOOL updateText = FALSE;
    HWND hwndSave = ped->hwnd;
    int InsertTextLen = 1;
    int DBCSkey;

    if (ped->fAnsi)
    {
        keyPress = LOBYTE(keyValue);
    }
    else
    {
        keyPress = LOWORD(keyValue);
    }

    if (ped->fMouseDown || (ped->fReadOnly && keyPress != 3)) 
    {
        //
        // Don't do anything if we are in the middle of a mousedown deal or if
        // this is a read only edit control, with exception of allowing
        // ctrl-C in order to copy to the clipboard.
        //
        return;
    }

    if (g_fIMMEnabled) 
    {
        Edit_InOutReconversionMode(ped, FALSE);
    }

    switch (keyPress) 
    {
    case VK_BACK:
DeleteSelection:
        if (Edit_DeleteText(ped))
        {
            updateText = TRUE;
        }

        break;

    default:
        if (keyPress >= TEXT(' '))
        {
            //
            // If this is in [a-z],[A-Z] and we are an ES_NUMBER
            // edit field, bail.
            //
            if (ped->f40Compat && (GET_STYLE(ped) & ES_NUMBER)) 
            {
                if (!Edit_IsCharNumeric(ped, keyPress)) 
                {
                    Edit_ShowBalloonTipWrap(ped->hwnd, IDS_NUMERIC_TITLE, IDS_NUMERIC_MSG, TTI_ERROR);
                    goto IllegalChar;
                }
            }

            goto DeleteSelection;
        }

        break;
    }

    switch (keyPress) 
    {
    case 3:

        //
        // CTRL-C Copy
        //
        SendMessage(ped->hwnd, WM_COPY, 0, 0L);
        return;

    case VK_BACK:

        //
        // Delete any selected text or delete character left if no sel
        //
        if (!updateText && ped->ichMinSel) 
        {
            //
            // There was no selection to delete so we just delete character
            // left if available
            //
            // Calling PrevIch rather than just doing a decrement for VK_BACK
            //
            ped->ichMinSel = Edit_PrevIch( ped, NULL, ped->ichMinSel);
            Edit_DeleteText(ped);
            updateText = TRUE;
        }

        break;

    case 22:
        //
        // CTRL-V Paste
        //
        SendMessage(ped->hwnd, WM_PASTE, 0, 0L);
        return;

    case 24:
        //
        // CTRL-X Cut
        //
        if (ped->ichMinSel == ped->ichMaxSel)
        {
            goto IllegalChar;
        }

        SendMessage(ped->hwnd, WM_CUT, 0, 0L);
        return;

    case 26: 
        //
        // CTRL-Z Undo
        //
        SendMessage(ped->hwnd, EM_UNDO, 0, 0L);
        return;

    case VK_RETURN:
    case VK_ESCAPE:
        //
        // If this is an edit control for a combobox and the dropdown list
        // is visible, forward it up to the combo.
        //
        if (ped->listboxHwnd && SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0L)) 
        {
            SendMessage(ped->hwndParent, WM_KEYDOWN, (WPARAM)keyPress, 0L);
        } 
        else
        {
            goto IllegalChar;
        }

        return;

    default:
        if (keyPress >= 0x1E) 
        {
            //
            // 1E,1F are unicode block and segment separators
            //

            //
            // Hide the cursor if typing, if the mouse is captured, do not mess with this
            // as it is going to desapear forever (no WM_SETCURSOR is sent to restore it
            // at the first mouse-move)
            // MCostea #166951
            //
            if (GetCapture() == NULL)
            {
                SetCursor(NULL);
            }

            if (g_fDBCSEnabled && ped->fAnsi && (Edit_IsDBCSLeadByte(ped,(BYTE)keyPress))) 
            {
                if ((DBCSkey = DbcsCombine(ped->hwnd, keyPress)) != 0 &&
                     EditSL_InsertText(ped,(LPSTR)&DBCSkey, 2) == 2) 
                {
                    InsertTextLen = 2;
                    updateText = TRUE;
                } 
                else 
                {
                    MessageBeep(0);
                }
            } 
            else 
            {
                InsertTextLen = 1;
                if (EditSL_InsertText(ped, (LPSTR)&keyPress, 1))
                {
                    updateText = TRUE;
                }
                else
                {
                    //
                    // Beep. Since we couldn't add the text
                    //
                    MessageBeep(0);
                }
            }
        } 
        else 
        {
IllegalChar:
            MessageBeep(0);
        }

        if (!IsWindow(hwndSave))
        {
            return;
        }

        break;
    }

    if (updateText) 
    {
        //
        // Dirty flag (ped->fDirty) was set when we inserted text
        //
        Edit_NotifyParent(ped, EN_UPDATE);
        hdc = Edit_GetDC(ped, FALSE);
        if (!EditSL_ScrollText(ped, hdc)) 
        {
            if (ped->format == ES_LEFT) 
            {
                //
                // Call EditSL_DrawText with correct ichStart
                //
                EditSL_DrawText(ped, hdc, max(0, (int)(ped->ichCaret - InsertTextLen - ped->wMaxNegCcharPos)));
            } 
            else 
            {
                //
                // We can't just draw from ichStart because string may have
                // shifted because of alignment.
                //
                EditSL_DrawText(ped, hdc, 0);
            }
        }

        Edit_ReleaseDC(ped, hdc, FALSE);
        Edit_NotifyParent(ped, EN_CHANGE);

        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_MoveSelectionRestricted AorW
//
// Moves the selection like Edit_MoveSelection, but also obeys limitations
// imposed by some languages such as Thai, where the cursor cannot stop
// between a character and it's attached vowel or tone marks.
//
// Only called if the language pack is loaded.
//
ICH EditSL_MoveSelectionRestricted(PED ped, ICH ich, BOOL fLeft)
{
    PSTR pText;
    HDC  hdc;
    ICH  ichResult;

    pText = Edit_Lock(ped);
    hdc = Edit_GetDC(ped, TRUE);
    ichResult = ped->pLpkEditCallout->EditMoveSelection((PED0)ped, hdc, pText, ich, fLeft);
    Edit_ReleaseDC(ped, hdc, TRUE);
    Edit_Unlock(ped);

    return ichResult;
}


//---------------------------------------------------------------------------//
void EditSL_CheckCapsLock(PED ped)
{
    if ((GetKeyState(VK_CAPITAL) & 0x0001) != 0)
    {
        Edit_ShowBalloonTipWrap(ped->hwnd, IDS_CAPSLOCK_TITLE, IDS_CAPSLOCK_MSG, TTI_WARNING);
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_KeyDown AorW
//
// Handles cursor movement and other VIRT KEY stuff. keyMods allows
// us to make EditSL_KeyDownHandler calls and specify if the modifier keys (shift
// and control) are up or down. This is useful for imnplementing the
// cut/paste/clear messages for single line edit controls. If keyMods == 0,
// we get the keyboard state using GetKeyState(VK_SHIFT) etc. Otherwise, the
// bits in keyMods define the state of the shift and control keys.
//
VOID EditSL_KeyDown(PED ped, DWORD virtKeyCode, int keyMods)
{
    HDC hdc;

    //
    // Variables we will use for redrawing the updated text
    //
    ICH newMaxSel = ped->ichMaxSel;
    ICH newMinSel = ped->ichMinSel;

    //
    // Flags for drawing the updated text
    //
    BOOL updateText = FALSE;
    BOOL changeSelection = FALSE;   // new selection is specified by
                                    // newMinSel, newMaxSel

    //
    // Comparisons we do often
    //
    BOOL MinEqMax = (newMaxSel == newMinSel);
    BOOL MinEqCar = (ped->ichCaret == newMinSel);
    BOOL MaxEqCar = (ped->ichCaret == newMaxSel);

    //
    // State of shift and control keys.
    //
    int scState;

    //
    // Combo box support
    //
    BOOL fIsListVisible;
    BOOL fIsExtendedUI;

    if (ped->fMouseDown) 
    {
        //
        // If we are in the middle of a mouse down handler, then don't do
        // anything. ie. ignore keyboard input.
        //
        return;
    }

    if (ped->hwndBalloon)
    {
        Edit_HideBalloonTip(ped->hwnd);
    }

    scState = Edit_GetModKeys(keyMods);

    switch (virtKeyCode) 
    {
    case VK_UP:
        if ( ped->listboxHwnd ) 
        {
            //
            // Handle Combobox support
            //
            fIsExtendedUI = (BOOL)SendMessage(ped->hwndParent, CB_GETEXTENDEDUI, 0, 0);
            fIsListVisible = (BOOL)SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0);

            if (!fIsListVisible && fIsExtendedUI) 
            {
DropExtendedUIListBox:
                //
                // Since an extendedui combo box doesn't do anything on f4, we
                // turn off the extended ui, send the f4 to drop, and turn it
                // back on again.
                //
                SendMessage(ped->hwndParent, CB_SETEXTENDEDUI, 0, 0);
                SendMessage(ped->listboxHwnd, WM_KEYDOWN, VK_F4, 0);
                SendMessage(ped->hwndParent, CB_SETEXTENDEDUI, 1, 0);

                return;
            } 
            else
            {
                goto SendKeyToListBox;
            }
        }

    //
    // else fall through
    //
    case VK_LEFT:
        //
        // If the caret isn't at the beginning, we can move left
        //
        if (ped->ichCaret) 
        {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) 
            {
                //
                // Move caret word left
                //
                Edit_Word(ped, ped->ichCaret, TRUE, &ped->ichCaret, NULL);
            } 
            else 
            {
                //
                // Move caret char left
                //
                if (ped->pLpkEditCallout) 
                {
                    ped->ichCaret = EditSL_MoveSelectionRestricted(ped, ped->ichCaret, TRUE);
                } 
                else
                {
                    ped->ichCaret = Edit_PrevIch(ped,NULL,ped->ichCaret);
                }
            }

            //
            // Get new selection
            //
            if (scState & SHFTDOWN) 
            {
                if (MaxEqCar && !MinEqMax) 
                {
                    //
                    // Reduce selection
                    //
                    newMaxSel = ped->ichCaret;

                    UserAssert(newMinSel == ped->ichMinSel);
                } 
                else 
                {
                    //
                    // Extend selection
                    //
                    newMinSel = ped->ichCaret;
                }
            } 
            else 
            {
                //
                // Clear selection
                //
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } 
        else 
        {
            //
            // If the user tries to move left and we are at the 0th
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) && !(scState & SHFTDOWN) ) 
            {
                changeSelection = TRUE;
                newMaxSel = newMinSel = ped->ichCaret;
            }
        }
        break;

    case VK_DOWN:
        if (ped->listboxHwnd) 
        {
            //
            // Handle Combobox support
            //
            fIsExtendedUI = (BOOL)SendMessage(ped->hwndParent, CB_GETEXTENDEDUI, 0, 0);
            fIsListVisible = (BOOL)SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0);

            if (!fIsListVisible && fIsExtendedUI) 
            {
                goto DropExtendedUIListBox;
            } 
            else
            {
                goto SendKeyToListBox;
            }
        }

    //
    // else fall through
    //
    case VK_RIGHT:
        //
        // If the caret isn't at the end, we can move right.
        //
        if (ped->ichCaret < ped->cch) 
        {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) 
            {
                //
                // Move caret word right
                //
                Edit_Word(ped, ped->ichCaret, FALSE, NULL, &ped->ichCaret);
            } 
            else 
            {
                //
                // Move caret char right
                //
                if (ped->pLpkEditCallout) 
                {
                    ped->ichCaret = EditSL_MoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } 
                else
                {
                    ped->ichCaret = Edit_NextIch(ped,NULL,ped->ichCaret);
                }
            }

            //
            // Get new selection.
            //
            if (scState & SHFTDOWN) 
            {
                if (MinEqCar && !MinEqMax) 
                {
                    //
                    // Reduce selection
                    //
                    newMinSel = ped->ichCaret;

                    UserAssert(newMaxSel == ped->ichMaxSel);
                } 
                else 
                {
                    //
                    // Extend selection
                    //
                    newMaxSel = ped->ichCaret;
                }
            } 
            else 
            {
                //
                // Clear selection
                //
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } 
        else 
        {
            //
            // If the user tries to move right and we are at the last
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) 
            {
                newMaxSel = newMinSel = ped->ichCaret;
                changeSelection = TRUE;
            }
        }
        break;

    case VK_HOME:
        //
        // Move caret to top.
        //
        ped->ichCaret = 0;

        //
        // Update selection.
        //
        if (scState & SHFTDOWN) 
        {
            if (MaxEqCar && !MinEqMax) 
            {
                //
                // Reduce selection
                //
                newMinSel = ped->ichCaret;
                newMaxSel = ped->ichMinSel;
            } 
            else 
            {
                //
                // Extend selection
                //
                newMinSel = ped->ichCaret;
            }
        } 
        else 
        {
            //
            // Clear selection
            //
            newMaxSel = newMinSel = ped->ichCaret;
        }

        changeSelection = TRUE;
        break;

    case VK_END:
        //
        // Move caret to end.
        //
        ped->ichCaret = ped->cch;

        //
        // Update selection.
        //
        newMaxSel = ped->ichCaret;
        if (scState & SHFTDOWN) 
        {
            if (MinEqCar && !MinEqMax) 
            {
                //
                // Reduce selection
                //
                newMinSel = ped->ichMaxSel;
            }
        } 
        else 
        {
            //
            // Clear selection
            //
            newMinSel = ped->ichCaret;
        }

        changeSelection = TRUE;
        break;

    case VK_DELETE:
        if (ped->fReadOnly)
        {
            break;
        }

        switch (scState) 
        {
        case NONEDOWN:

            //
            // Clear selection. If no selection, delete (clear) character
            // right.
            //
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) 
            {
                //
                // Move cursor forwards and simulate a backspace.
                //
                if (ped->pLpkEditCallout) 
                {
                    ped->ichMinSel = ped->ichCaret;
                    ped->ichMaxSel = ped->ichCaret = EditSL_MoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } 
                else 
                {
                    ped->ichCaret = Edit_NextIch(ped,NULL,ped->ichCaret);
                    ped->ichMaxSel = ped->ichMinSel = ped->ichCaret;
                }

                EditSL_Char(ped, (UINT)VK_BACK);
            }

            if (ped->ichMinSel != ped->ichMaxSel)
            {
                EditSL_Char(ped, (UINT)VK_BACK);
            }

            break;

        case SHFTDOWN:

            //
            // Send ourself a WM_CUT message if a selection exists.
            // Otherwise, delete the left character.
            //
            if (ped->ichMinSel == ped->ichMaxSel) 
            {
                UserAssert(!ped->fEatNextChar);
                EditSL_Char(ped, VK_BACK);
            } 
            else
            {
                SendMessage(ped->hwnd, WM_CUT, 0, 0L);
            }

            break;

        case CTRLDOWN:

            //
            // Delete to end of line if no selection else delete (clear)
            // selection.
            //
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) 
            {
                //
                // Move cursor to end of line and simulate a backspace.
                //
                ped->ichMaxSel = ped->ichCaret = ped->cch;
            }

            if (ped->ichMinSel != ped->ichMaxSel)
            {
                EditSL_Char(ped, (UINT)VK_BACK);
            }

            break;

        }

        //
        // No need to update text or selection since BACKSPACE message does it
        // for us.
        //
        break;

    case VK_INSERT:
        switch (scState) 
        {
        case CTRLDOWN:

            //
            // Copy current selection to clipboard
            //
            SendMessage(ped->hwnd, WM_COPY, 0, 0);
            break;

        case SHFTDOWN:
            SendMessage(ped->hwnd, WM_PASTE, 0, 0L);
            break;
        }
        break;

    case VK_HANJA:
        //
        // VK_HANJA support
        //
        if ( HanjaKeyHandler( ped ) ) 
        {
            changeSelection = TRUE;
            newMinSel = ped->ichCaret;
            newMaxSel = ped->ichCaret + (ped->fAnsi ? 2 : 1);
        }

        break;

    case VK_CAPITAL:

        if (GET_STYLE(ped) & ES_PASSWORD)
        {
            EditSL_CheckCapsLock(ped);
        }

        break;

    case VK_F4:
    case VK_PRIOR:
    case VK_NEXT:

        //
        // Send keys to the listbox if we are a part of a combo box. This
        // assumes the listbox ignores keyup messages which is correct right
        // now.
        //
SendKeyToListBox:
        if (ped->listboxHwnd) 
        {
            //
            // Handle Combobox support
            //
            SendMessage(ped->listboxHwnd, WM_KEYDOWN, virtKeyCode, 0L);
            return;
        }
    }

    if (changeSelection || updateText) 
    {
        hdc = Edit_GetDC(ped, FALSE);

        //
        // Scroll if needed
        //
        EditSL_ScrollText(ped, hdc);

        if (changeSelection)
        {
            EditSL_ChangeSelection(ped, hdc, newMinSel, newMaxSel);
        }

        if (updateText)
        {
            EditSL_DrawText(ped, hdc, 0);
        }

        Edit_ReleaseDC(ped, hdc, FALSE);
        if (updateText) 
        {
            Edit_NotifyParent(ped, EN_CHANGE);

            NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
        }
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_MouseToIch AorW
//
// Returns the closest cch to where the mouse point is.
//
ICH EditSL_MouseToIch(PED ped, HDC hdc, LPPOINT mousePt)
{
    PSTR pText;
    int width = mousePt->x;
    int lastHighWidth, lastLowWidth;
    SIZE size;
    ICH cch;
    ICH cchLo, cchHi;
    LPSTR lpText;
    FnGetTextExtentPoint pGetTextExtentPoint;

    if (ped->pLpkEditCallout) 
    {
        pText = Edit_Lock(ped);
        cch = ped->pLpkEditCallout->EditMouseToIch((PED0)ped, hdc, pText, ped->cch, width);
        Edit_Unlock(ped);

        return cch;
    }

    if (width <= ped->rcFmt.left) 
    {
        //
        // Return either the first non visible character or return 0 if at
        // beginning of text
        //
        if (ped->ichScreenStart)
        {
            return (ped->ichScreenStart - 1);
        }
        else
        {
            return 0;
        }
    }

    if (width > ped->rcFmt.right) 
    {
        pText = Edit_Lock(ped);

        //
        // Return last char in text or one plus the last char visible
        //
        cch = Edit_CchInWidth(ped, hdc,
                (LPSTR)(pText + ped->ichScreenStart * ped->cbChar),
                ped->cch - ped->ichScreenStart, ped->rcFmt.right -
                ped->rcFmt.left, TRUE) + ped->ichScreenStart;

        //
        // This is marked as JAPAN in Win31J. But it should be a DBCS
        // issue. LiZ -- 5/5/93
        // We must check DBCS Lead byte. Because Edit_AdjustIch() pick up Prev Char.
        //  1993.3.9 by yutakas
        //
        if (ped->fAnsi && ped->fDBCS) 
        {
            if (cch >= ped->cch) 
            {
                cch = ped->cch;
            } 
            else 
            {
                if (Edit_IsDBCSLeadByte(ped,*(pText+cch))) 
                {
                    cch += 2;
                } 
                else 
                {
                    cch ++;
                }
            }

            Edit_Unlock(ped);

            return cch;
        } 
        else 
        {
            Edit_Unlock(ped);
            if (cch >= ped->cch)
            {
                return (ped->cch);
            }
            else
            {
                return (cch + 1);
            }
        }
    }

    if (ped->format != ES_LEFT) 
    {
        width -= EditSL_CalcXOffsetSpecial(ped, hdc, ped->ichScreenStart);
    }

    //
    // Check if password hidden chars are being used.
    //
    if (ped->charPasswordChar)
    {
        return min( (DWORD)( (width - ped->rcFmt.left) / ped->cPasswordCharWidth),
                    ped->cch);
    }

    if (!ped->cch)
    {
        return 0;
    }

    pText = Edit_Lock(ped);
    lpText = pText + ped->ichScreenStart * ped->cbChar;

    pGetTextExtentPoint = ped->fAnsi ? (FnGetTextExtentPoint)GetTextExtentPointA
                                     : (FnGetTextExtentPoint)GetTextExtentPointW;
    width -= ped->rcFmt.left;

    //
    // If the user clicked past the end of the text, return the last character
    //
    cchHi = ped->cch - ped->ichScreenStart;
    pGetTextExtentPoint(hdc, lpText, cchHi, &size);
    if (size.cx <= width) 
    {
        cch = cchHi;
        goto edAdjust;
    }

    //
    // Initialize Binary Search Bounds
    //
    cchLo = 0;
    cchHi ++;
    lastLowWidth = 0;
    lastHighWidth = size.cx;

    //
    // Binary search for closest char
    //
    while (cchLo < cchHi - 1) 
    {
        cch = (cchHi + cchLo) / 2;
        pGetTextExtentPoint(hdc, lpText, cch, &size);

        if (size.cx <= width) 
        {
            cchLo = cch;
            lastLowWidth = size.cx;
        } 
        else 
        {
            cchHi = cch;
            lastHighWidth = size.cx;
        }
    }

    //
    // When the while ends, you can't know the exact position.
    // Try to see if the mouse pointer was on the farest half
    // of the char we got and if so, adjust cch.
    //
    if (cchLo == cch) 
    {
        //
        // Need to compare with lastHighWidth
        //
        if ((lastHighWidth - width) < (width - size.cx)) 
        {
            cch++;
        }
    } 
    else 
    {
        //
        // Need to compare with lastLowWidth
        //
        if ((width - lastLowWidth) < (size.cx - width)) 
        {
            cch--;
        }
    }

edAdjust:
    //
    // Avoid to point the intermediate of double byte character
    //
    cch = Edit_AdjustIch(ped, pText, cch + ped->ichScreenStart);
    Edit_Unlock(ped);
    return cch;
}


//---------------------------------------------------------------------------//
VOID EditSL_MouseMotion(PED ped, UINT message, UINT virtKeyDown, LPPOINT mousePt)
{
    DWORD   selectionl;
    DWORD   selectionh;
    BOOL    changeSelection;
    ICH     newMaxSel;
    ICH     newMinSel;
    HDC     hdc;
    ICH     mouseIch;
    LPSTR   pText;

    changeSelection = FALSE;

    newMinSel = ped->ichMinSel;
    newMaxSel = ped->ichMaxSel;

    hdc = Edit_GetDC(ped, FALSE);
    mouseIch = EditSL_MouseToIch(ped, hdc, mousePt);

    switch (message) 
    {
        case WM_LBUTTONDBLCLK:

            //
            // if shift key is down, extend selection to word we double clicked on
            // else clear current selection and select word.
            //
            // in DBCS, we have different word breaking. LiZ -- 5/5/93
            // In Hangeul Environment we use word selection feature because Hangeul
            // use SPACE as word break
            //
            if (ped->fAnsi && ped->fDBCS) 
            {
                pText = Edit_Lock(ped) + mouseIch;
                Edit_Word(ped, mouseIch,
                       (Edit_IsDBCSLeadByte(ped,*pText) && mouseIch < ped->cch) ? FALSE : TRUE,
                       &selectionl, &selectionh);
                Edit_Unlock(ped);
            } 
            else 
            {
                Edit_Word(ped, mouseIch, (mouseIch) ? TRUE : FALSE, &selectionl, &selectionh);
            }

            if (!(virtKeyDown & MK_SHIFT)) 
            {
                //
                // If shift key isn't down, move caret to mouse point and clear
                // old selection
                //
                newMinSel = selectionl;
                newMaxSel = ped->ichCaret = selectionh;
            } 
            else 
            {
                //
                // Shiftkey is down so we want to maintain the current selection
                // (if any) and just extend or reduce it
                //
                if (ped->ichMinSel == ped->ichCaret) 
                {
                    newMinSel = ped->ichCaret = selectionl;
                    Edit_Word(ped, newMaxSel, TRUE, &selectionl, &selectionh);
                } 
                else 
                {
                    newMaxSel = ped->ichCaret = selectionh;
                    Edit_Word(ped, newMinSel, FALSE, &selectionl, &selectionh);
                }

                ped->ichMaxSel = ped->ichCaret;
            }

            ped->ichStartMinSel = selectionl;
            ped->ichStartMaxSel = selectionh;

            goto InitDragSelect;

        case WM_MOUSEMOVE:
            //
            // We know the mouse button's down -- otherwise the OPTIMIZE
            // test would've failed in EditSL_WndProc and never called
            //
            changeSelection = TRUE;

            //
            // Extend selection, move caret word right
            //
            if (ped->ichStartMinSel || ped->ichStartMaxSel) 
            {
                //
                // We're in WORD SELECT mode
                //
                BOOL fReverse = (mouseIch <= ped->ichStartMinSel);

                Edit_Word(ped, mouseIch, !fReverse, &selectionl, &selectionh);

                if (fReverse) 
                {
                    newMinSel = ped->ichCaret = selectionl;
                    newMaxSel = ped->ichStartMaxSel;
                } 
                else 
                {
                    newMinSel = ped->ichStartMinSel;
                    newMaxSel = ped->ichCaret = selectionh;
                }
            } 
            else if ((ped->ichMinSel == ped->ichCaret) &&
                (ped->ichMinSel != ped->ichMaxSel))
            {
                //
                // Reduce selection extent
                //
                newMinSel = ped->ichCaret = mouseIch;
            }
            else
            {
                // Extend selection extent
                newMaxSel = ped->ichCaret=mouseIch;
            }

            break;

        case WM_LBUTTONDOWN:
            //
            // If we currently don't have the focus yet, try to get it.
            //
            if (!ped->fFocus) 
            {
                if (!ped->fNoHideSel)
                {
                    //
                    // Clear the selection before setting the focus so that we
                    // don't get refresh problems and flicker. Doesn't matter
                    // since the mouse down will end up changing it anyway.
                    //
                    ped->ichMinSel = ped->ichMaxSel = ped->ichCaret;
                }

                SetFocus(ped->hwnd);

                //
                // BOGUS
                // (1) We should see if SetFocus() succeeds.
                // (2) We should ignore mouse messages if the first window
                //      ancestor with a caption isn't "active."
                //
                // If we are part of a combo box, then this is the first time
                // the edit control is getting the focus so we just want to
                // highlight the selection and we don't really want to position
                // the caret.
                //
                if (ped->listboxHwnd)
                {
                    break;
                }

                //
                // We yield at SetFocus -- text might have changed at that point
                // update selection and caret info accordingly
                // FIX for bug # 11743 -- JEFFBOG 8/23/91
                //
                newMaxSel = ped->ichMaxSel;
                newMinSel = ped->ichMinSel;
                mouseIch  = min(mouseIch, ped->cch);
            }

            if (ped->fFocus) 
            {
                //
                // Only do this if we have the focus since a clever app may not
                // want to give us the focus at the SetFocus call above.
                //
                if (!(virtKeyDown & MK_SHIFT)) 
                {
                    //
                    // If shift key isn't down, move caret to mouse point and
                    // clear old selection
                    //
                    newMinSel = newMaxSel = ped->ichCaret = mouseIch;
                } 
                else 
                {
                    //
                    // Shiftkey is down so we want to maintain the current
                    // selection (if any) and just extend or reduce it
                    //
                    if (ped->ichMinSel == ped->ichCaret)
                    {
                        newMinSel = ped->ichCaret = mouseIch;
                    }
                    else
                    {
                        newMaxSel = ped->ichCaret = mouseIch;
                    }
                }

                ped->ichStartMinSel = ped->ichStartMaxSel = 0;

InitDragSelect:
                ped->fMouseDown = FALSE;
                SetCapture(ped->hwnd);
                ped->fMouseDown = TRUE;
                changeSelection = TRUE;
            }

            break;

        case WM_LBUTTONUP:
            if (ped->fMouseDown) 
            {
                ped->fMouseDown = FALSE;
                ReleaseCapture();
            }

            break;
    }

    if (changeSelection) 
    {
        EditSL_ScrollText(ped,hdc);
        EditSL_ChangeSelection(ped, hdc, newMinSel, newMaxSel);
    }

    Edit_ReleaseDC(ped, hdc, FALSE);
}


//---------------------------------------------------------------------------//
//
// EditSL_Paint AorW
//
// Handles painting of the edit control window. Draws the border if
// necessary and draws the text in its current state.
//
VOID EditSL_Paint(PED ped, HDC hdc)
{
    RECT   rcEdit;
    HWND   hwnd = ped->hwnd;
    HBRUSH hBrushRemote = NULL;
    BOOL   fNeedDelete = FALSE;
    HANDLE hOldFont;

    //
    // Had to put in hide/show carets. The first one needs to be done before
    // beginpaint to correctly paint the caret if part is in the update region
    // and part is out. The second is for 1.03 compatibility. It breaks
    // micrografix's worksheet edit control if not there.
    //
    HideCaret(hwnd);

    if (IsWindowVisible(hwnd)) 
    {
        CCDBUFFER db;

        //
        // Erase the background since we don't do it in the erasebkgnd message.
        //
        GetClientRect(hwnd, &rcEdit);


        hdc = CCBeginDoubleBuffer(hdc, &rcEdit, &db);
#ifdef _USE_DRAW_THEME_TEXT_
        if (!ped->hTheme)
#endif // _USE_DRAW_THEME_TEXT_
        {
            hBrushRemote = Edit_GetBrush(ped, hdc, &fNeedDelete);
            if (hBrushRemote)
            {
                FillRect(hdc, &rcEdit, hBrushRemote);

                if (fNeedDelete)
                {
                    DeleteObject(hBrushRemote);
                }
            }

            if (ped->fFlatBorder)
            {
                DrawFrame(hdc, &rcEdit, 1, DF_WINDOWFRAME);
            }

        }
#ifdef _USE_DRAW_THEME_TEXT_
        else
        {
            HRESULT hr;
            INT     iStateId = Edit_GetStateId(ped);

            hr = DrawThemeBackground(ped->hTheme, hdc, EP_EDITTEXT, iStateId, &rcEdit, 0);
        }
#endif // _USE_DRAW_THEME_TEXT_

        if (ped->hFont != NULL) 
        {
            //
            // We have to select in the font since this may be a subclassed dc
            // or a begin paint dc which hasn't been initialized with out fonts
            // like Edit_GetDC does.
            //
            hOldFont = SelectObject(hdc, ped->hFont);
        }
        EditSL_DrawText(ped, hdc, 0);

        if (ped->hFont != NULL && hOldFont != NULL) 
        {
            SelectObject(hdc, hOldFont);
        }

        CCEndDoubleBuffer(&db);
    }

    ShowCaret(hwnd);
}


//---------------------------------------------------------------------------//
//
// EditSL_SetFocus AorW
//
// Gives the edit control the focus and notifies the parent
// EN_SETFOCUS.
//
VOID EditSL_SetFocus(PED ped)
{
    if (!ped->fFocus) 
    {
        HDC  hdc;
        UINT cxCaret;

        ped->fFocus = TRUE;
        InvalidateRect(ped->hwnd, NULL, TRUE);

        //
        // We don't want to muck with the caret since it isn't created.
        //
        hdc = Edit_GetDC(ped, TRUE);

        //
        // Show the current selection if necessary.
        //
        if (!ped->fNoHideSel)
        {
            EditSL_DrawText(ped, hdc, 0);
        }

        //
        // Create the caret
        //
        SystemParametersInfo(SPI_GETCARETWIDTH, 0, (LPVOID)&cxCaret, 0);
        if (ped->pLpkEditCallout) 
        {
            ped->pLpkEditCallout->EditCreateCaret ((PED0)ped, hdc, cxCaret,
                                                   ped->lineHeight, 0);
        }
        else 
        {
            CreateCaret(ped->hwnd, (HBITMAP)NULL, cxCaret, ped->lineHeight);
        }
        EditSL_SetCaretPosition(ped, hdc);
        Edit_ReleaseDC(ped, hdc, TRUE);
        ShowCaret(ped->hwnd);

        //
        // check the capslock key
        //
        if (GET_STYLE(ped) & ES_PASSWORD)
        {
            EditSL_CheckCapsLock(ped);
        }

    }

    //
    // Notify parent we have the focus
    //
    Edit_NotifyParent(ped, EN_SETFOCUS);
}


//---------------------------------------------------------------------------//
//
// EditSL_KillFocus
//
// The edit control loses the focus and notifies the parent via EN_KILLFOCUS.
//
void EditSL_KillFocus(PED ped, HWND newFocusHwnd)
{
    HWND hwnd = ped->hwnd;

    if (ped->fFocus) 
    {
        DestroyCaret();
        ped->fFocus = FALSE;

        //
        // Do this only if we still have the focus. But we always notify the
        // parent that we lost the focus whether or not we originally had the
        // focus.
        //
        // Hide the current selection if needed
        //
#ifdef _USE_DRAW_THEME_TEXT_
        if ((!ped->fNoHideSel && (ped->ichMinSel != ped->ichMaxSel)) || ped->hTheme) 
#else
        if ((!ped->fNoHideSel && (ped->ichMinSel != ped->ichMaxSel))) 
#endif // _USE_DRAW_THEME_TEXT_
        {
            InvalidateRect(hwnd, NULL, FALSE);
        }

    }

    //
    // If we aren't a combo box, notify parent that we lost the focus.
    //
    if (!ped->listboxHwnd)
    {
        Edit_NotifyParent(ped, EN_KILLFOCUS);
    }
    else 
    {
        //
        // This editcontrol is part of a combo box and is losing the focus. If
        // the focus is NOT being sent to another control in the combo box
        // window, then it means the combo box is losing the focus. So we will
        // notify the combo box of this fact.
        //
        if ((newFocusHwnd == NULL) || (!IsChild(ped->hwndParent, newFocusHwnd))) 
        {
            //
            // Excel has a slaker in it's midst.  They're not using our combo
            // boxes, but they still expect to get all the internal messages
            // that we give to OUR comboboxes.  And they expect them to be at
            // the same offset from WM_USER as they were in 3.1.
            //                                           (JEFFBOG - 01/26/94)

            //
            // Focus is being sent to a window which is not a child of the combo
            // box window which implies that the combo box is losing the focus.
            // Send a message to the combo box informing him of this fact so
            // that he can clean up...
            //
            SendMessage(ped->hwndParent, CBEC_KILLCOMBOFOCUS, 0, 0L);
        }
    }

    //
    // If we're still valid, invalidate to cause a redraw. It's common
    // for some controls be destroyed after losing focus.
    //
    if ( IsWindow(hwnd) )
    {
        InvalidateRect(hwnd, NULL, FALSE);
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_Paste()
//
// Does actual text paste and update.
//
VOID EditSL_Paste(PED ped)
{
    HDC hdc;

    //
    // Insert contents of clipboard, after unhilighting current selection
    // and deleting it.
    //
    Edit_DeleteText(ped);
    EditSL_PasteText(ped);

    //
    // Update display
    //
    Edit_NotifyParent(ped, EN_UPDATE);

    hdc = Edit_GetDC(ped,FALSE);

    EditSL_ScrollText(ped, hdc);
    EditSL_DrawText(ped, hdc, 0);

    Edit_ReleaseDC(ped,hdc,FALSE);

    //
    // Tell parent our text contents changed.
    //
    Edit_NotifyParent(ped, EN_CHANGE);
    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
}


//---------------------------------------------------------------------------//
//
// EditSL_Create
//
// Creates the edit control for the window hwnd by allocating memory
// as required from the application's heap. Notifies parent if no memory
// error (after cleaning up if needed). Returns TRUE if no error else return s
// -1.
//
LONG EditSL_Create(PED ped, LPCREATESTRUCT lpCreateStruct)
{
    LPSTR lpWindowText;
    LONG windowStyle = GET_STYLE(ped);

    //
    // Do the standard creation stuff
    //
    if (!Edit_Create(ped, windowStyle))
    {
        return -1;
    }

    //
    // Single lines always have no undo and 1 line
    //
    ped->cLines = 1;
    ped->undoType = UNDO_NONE;

    //
    // Check if this edit control is part of a combobox and get a pointer to the
    // combobox structure.
    //
    if (windowStyle & ES_COMBOBOX)
    {
        ped->listboxHwnd = GetDlgItem(lpCreateStruct->hwndParent, CBLISTBOXID);
    }

    //
    // Set the default font to be the system font.
    //
    if ( !Edit_SetFont(ped, NULL, FALSE) )
    {

        // If setting the font fails, our textmetrics can potentially be left 
        // unitialize. Fail to create the control.
        return -1;
    }


    //
    // Set the window text if needed. Return false if we can't set the text
    // SLSetText notifies the parent in case there is a no memory error.
    //
    lpWindowText = (LPSTR)lpCreateStruct->lpszName;

    if ((lpWindowText != NULL)
            && !IsEmptyString(lpWindowText, ped->fAnsi)
            && !Edit_SetEditText(ped, lpWindowText)) 
    {
        return -1;
    }

    if (windowStyle & ES_PASSWORD)
    {
        LOGFONT lfFont = {0};
        
        LoadString(HINST_THISDLL, IDS_PASSWORDCHARFONT, lfFont.lfFaceName, ARRAYSIZE(lfFont.lfFaceName));
        lfFont.lfWeight   = FW_NORMAL;
        lfFont.lfCharSet  = DEFAULT_CHARSET;

        ped->hFontPassword = CreateFontIndirect(&lfFont);   
        if (ped->hFontPassword && Edit_SetFont(ped, ped->hFontPassword, FALSE))
        {
            WCHAR szChar[10];
            UINT  uChar;

            LoadString(HINST_THISDLL, IDS_PASSWORDCHAR, szChar, ARRAYSIZE(szChar));
            uChar = StrToInt(szChar);
            Edit_SetPasswordCharHandler(ped, uChar);
        }
        else
        {
            Edit_SetPasswordCharHandler(ped, (UINT)'*');
        }
    }

    //
    // Since memory cleared to 0 when allocated, this should still be NULL
    //
    ASSERT(ped->pszCueBannerText == NULL);

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// EditSL_Undo AorW
//
// Handles UNDO for single line edit controls.
//
BOOL EditSL_Undo(PED ped)
{
    PBYTE hDeletedText = ped->hDeletedText;
    BOOL fDelete = (BOOL)(ped->undoType & UNDO_DELETE);
    ICH cchDeleted = ped->cchDeleted;
    ICH ichDeleted = ped->ichDeleted;
    BOOL fUpdate = FALSE;

    if (ped->undoType == UNDO_NONE) 
    {
        //
        // No undo...
        //
        return FALSE;
    }

    ped->hDeletedText = NULL;
    ped->cchDeleted = 0;
    ped->ichDeleted = (ICH)-1;
    ped->undoType &= ~UNDO_DELETE;

    if (ped->undoType == UNDO_INSERT) 
    {
        ped->undoType = UNDO_NONE;

        //
        // Set the selection to the inserted text
        //
        EditSL_SetSelection(ped, ped->ichInsStart, ped->ichInsEnd);
        ped->ichInsStart = ped->ichInsEnd = (ICH)-1;

        //
        // Delete the selected text and save it in undo buff.
        // Call Edit_DeleteText() instead of sending a VK_BACK message
        // which results in an EN_UPDATE notification send even before
        // we insert the deleted chars. This results in Bug #6610.
        // Fix for Bug #6610 -- SANKAR -- 04/19/91 --
        //
        if (Edit_DeleteText(ped)) 
        {
            //
            // Text was deleted -- flag for update and clear selection
            //
            fUpdate = TRUE;
            EditSL_SetSelection(ped, ichDeleted, ichDeleted);
        }
    }

    if (fDelete) 
    {
        HWND hwndSave = ped->hwnd; // Used for validation.

        //
        // Insert deleted chars. Set the selection to the inserted text.
        //
        EditSL_SetSelection(ped, ichDeleted, ichDeleted);
        EditSL_InsertText(ped, hDeletedText, cchDeleted);
        GlobalFree(hDeletedText);

        if (!IsWindow(hwndSave))
        {
            return FALSE;
        }

        EditSL_SetSelection(ped, ichDeleted, ichDeleted + cchDeleted);
        fUpdate = TRUE;
    }

    if (fUpdate) 
    {
        //
        // If we have something to update, send EN_UPDATE before and
        // EN_CHANGE after the actual update.
        // A part of the fix for Bug #6610 -- SANKAR -- 04/19/91 --
        //
        Edit_NotifyParent(ped, EN_UPDATE);

        if (IsWindowVisible(ped->hwnd)) 
        {
            Edit_InvalidateClient(ped, FALSE);
        }

        Edit_NotifyParent(ped, EN_CHANGE);

        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }

    return TRUE;
}



//---------------------------------------------------------------------------//
//
// EditSL_SetCueBanner (Unicode Only)
//
// Handles setting the cue banner text for an edit control.
//
BOOL EditSL_SetCueBanner(PED ped, LPCWSTR pszBanner)
{
    BOOL retVal = FALSE;

    if (pszBanner != NULL)
    {
        //
        // Store the input string into the ped's pointer.  Str_SetPtr will
        // allocate/free memory as needed.
        //
        retVal = Str_SetPtr(&(ped->pszCueBannerText), pszBanner);

        //
        // Redraw the control
        //
        InvalidateRect(ped->hwnd, NULL, FALSE);
    }

    return retVal;
}


//---------------------------------------------------------------------------//
//
// EditSL_WndProc
// 
// Class procedure for all single line edit controls.
// Dispatches all messages to the appropriate handlers which are named
// as follows:
// EditSL_ (single line) prefixes all single line edit control procedures while
// Edit_   (edit control) prefixes all common handlers.
//
// The EditSL_WndProc only handles messages specific to single line edit
// controls.
//
LRESULT EditSL_WndProc(PED ped, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    POINT       pt;

    switch (message) 
    {
    case WM_INPUTLANGCHANGE:
        if (ped && ped->fFocus && ped->pLpkEditCallout) 
        {
            UINT cxCaret;

            SystemParametersInfo(SPI_GETCARETWIDTH, 0, (LPVOID)&cxCaret, 0);
            HideCaret(ped->hwnd);
            hdc = Edit_GetDC(ped, TRUE);
            DestroyCaret();
            ped->pLpkEditCallout->EditCreateCaret ((PED0)ped, hdc, cxCaret, ped->lineHeight, (UINT)lParam);
            EditSL_SetCaretPosition(ped, hdc);
            Edit_ReleaseDC(ped, hdc, TRUE);
            ShowCaret(ped->hwnd);
        }
        goto PassToDefaultWindowProc;

    case WM_STYLECHANGED:
        if (ped && ped->pLpkEditCallout) 
        {
            switch (wParam) 
            {
            case GWL_STYLE:
                Edit_UpdateFormat(ped, ((LPSTYLESTRUCT)lParam)->styleNew, GET_EXSTYLE(ped));
                return 1L;

            case GWL_EXSTYLE:
                Edit_UpdateFormat(ped, GET_STYLE(ped), ((LPSTYLESTRUCT)lParam)->styleNew);
                return 1L;
            }
        }

        goto PassToDefaultWindowProc;

    case WM_CHAR:

        //
        // wParam - the value of the key
        // lParam - modifiers, repeat count etc (not used)
        //
        if (!ped->fEatNextChar)
        {
            EditSL_Char(ped, (UINT)wParam);
        }
        else
        {
            ped->fEatNextChar = FALSE;
        }
        break;

    case WM_ERASEBKGND:

        //
        // wParam - device context handle
        // lParam - not used
        // We do nothing on this message and we don't want DefWndProc to do
        // anything, so return 1
        //
        return 1;

    case WM_GETDLGCODE: 
    {
           LONG code = DLGC_WANTCHARS | DLGC_HASSETSEL | DLGC_WANTARROWS;

            //
            // If this is a WM_SYSCHAR message generated by the UNDO keystroke
            // we want this message so we can EAT IT in "case WM_SYSCHAR:"
            //
            if (lParam) 
            {
                switch (((LPMSG)lParam)->message) 
                {
                case WM_SYSCHAR:
                    if ((HIWORD(((LPMSG)lParam)->lParam) & SYS_ALTERNATE) &&
                        ((WORD)wParam == VK_BACK)) 
                    {
                        code |= DLGC_WANTMESSAGE;
                    }
                    break;

                case WM_KEYDOWN:
                    if (( (((WORD)wParam == VK_RETURN) ||
                           ((WORD)wParam == VK_ESCAPE)) &&
                        (ped->listboxHwnd)      &&
                        (GetWindowStyle(ped->hwndParent) & CBS_DROPDOWN) &&
                        SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0L))) 
                    {
                        code |= DLGC_WANTMESSAGE;
                    }
                    break;
                }
            }

            return code;
        }

        break;

    case WM_KEYDOWN:

        //
        // wParam - virt keycode of the given key
        // lParam - modifiers such as repeat count etc. (not used)
        //
        EditSL_KeyDown(ped, (UINT)wParam, 0);

        break;

    case WM_KILLFOCUS:

        //
        // wParam - handle of the window that receives the input focus
        // lParam - not used
        //
        EditSL_KillFocus(ped, (HWND)wParam);

        break;

    case WM_CAPTURECHANGED:
        if (ped->fMouseDown)
        {
            ped->fMouseDown = FALSE;
        }

        break;

    case WM_MOUSEMOVE:
        UserAssert(ped->fMouseDown);
        //
        // FALL THRU
        //
        
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
        //
        // wParam - contains a value that indicates which virtual keys are down
        // lParam - contains x and y coords of the mouse cursor
        //
        POINTSTOPOINT(pt, lParam);
        EditSL_MouseMotion(ped, message, (UINT)wParam, &pt);

        break;

    case WM_CREATE:

        //
        // wParam - handle to window being created
        // lParam - points to a CREATESTRUCT that contains copies of parameters
        //          passed to the CreateWindow function.
        //
        return EditSL_Create(ped, (LPCREATESTRUCT)lParam);

        break;

    case WM_PRINTCLIENT:
        //
        // wParam --    can be hdc from subclassed paint
        // lParam --    unused
        //
        EditSL_Paint(ped, (HDC) wParam);

        break;

    case WM_PAINT:

        //
        // wParam --    can be hdc from subclassed paint
        // lParam --    unused
        //
        if (wParam)
        {
            hdc = (HDC) wParam;
        }
        else 
        {
            //
            // this hide/show caret is outside Begin/EndPaint to handle the
            // case when the caret is half in/half out of the update region
            //
            HideCaret(ped->hwnd);
            hdc = BeginPaint(ped->hwnd, &ps);
        }

        //
        // PORTPORT: Note the symantics of IsWindowVisible and _IsWindowVisible are
        //           slightly different.
        //
        if (IsWindowVisible(ped->hwnd))
        {
            EditSL_Paint(ped, hdc);
        }

        if (!wParam) 
        {
            EndPaint(ped->hwnd, &ps);
            ShowCaret(ped->hwnd);
        }

        break;

    case WM_PASTE:

        //
        //  wParam - not used
        // lParam - not used
        //
        if (!ped->fReadOnly)
        {
            EditSL_Paste(ped);
        }

        break;

    case WM_SETFOCUS:

        //
        // wParam - handle of window that loses the input focus (may be NULL)
        // lParam - not used
        //
        EditSL_SetFocus(ped);

        break;

    case WM_SIZE:

        // wParam - defines the type of resizing fullscreen, sizeiconic,
        //          sizenormal etc.
        // lParam - new width in LOWORD, new height in HIGHWORD of client area
        Edit_Size(ped, NULL, TRUE);

        return 0;

    case WM_SYSKEYDOWN:
        //
        // wParam --    virtual key code
        // lParam --    modifiers
        //

        //
        // Are we in a combobox with the Alt key down?
        //
        if (ped->listboxHwnd && (lParam & 0x20000000L)) 
        {
            //
            // Handle Combobox support. We want alt up or down arrow to behave
            // like F4 key which completes the combo box selection
            //
            if (lParam & 0x1000000) 
            {
                //
                // This is an extended key such as the arrow keys not on the
                // numeric keypad so just drop the combobox.
                //
                if (wParam == VK_DOWN || wParam == VK_UP)
                {
                    goto DropCombo;
                }
                else
                {
                    goto SkipDropCombo;
                }
            }

            if (!(GetKeyState(VK_NUMLOCK) & 1) &&
                    (wParam == VK_DOWN || wParam == VK_UP)) 
            {
                //
                // NUMLOCK is up and the keypad up or down arrow hit:
                // eat character generated by keyboard driver.
                //
                ped->fEatNextChar = TRUE;
            } 
            else 
            {
                goto SkipDropCombo;
            }

DropCombo:
            if (SendMessage(ped->hwndParent, CB_GETEXTENDEDUI, 0, 0) & 0x00000001) 
            {
                //
                // Extended ui doesn't honor VK_F4.
                //
                if (SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0))
                {
                    return SendMessage(ped->hwndParent, CB_SHOWDROPDOWN, 0, 0);
                }
                else
                {
                    return SendMessage(ped->hwndParent, CB_SHOWDROPDOWN, 1, 0);
                }
            } 
            else
            {
                return SendMessage(ped->listboxHwnd, WM_KEYDOWN, VK_F4, 0);
            }
        }

SkipDropCombo:
        if (wParam == VK_BACK) 
        {
            SendMessage(ped->hwnd, WM_UNDO, 0, 0L);
            break;
        }
        else
        {
            goto PassToDefaultWindowProc;
        }

        break;

    case EM_GETLINE:

        //
        // wParam - line number to copy (always the first line for SL)
        // lParam - buffer to copy text to. FIrst word is max # of bytes to copy
        //
        return Edit_GetTextHandler(ped, (*(LPWORD)lParam), (LPSTR)lParam, FALSE);

    case EM_LINELENGTH:

        //
        // wParam - ignored
        // lParam - ignored
        //
        return (LONG)ped->cch;

    case EM_SETSEL:
        //
        // wParam -- start pos
        // lParam -- end pos
        //
        EditSL_SetSelection(ped, (ICH)wParam, (ICH)lParam);

        break;

    case EM_REPLACESEL:

        //
        // wParam - flag for 4.0+ apps saying whether to clear undo
        // lParam - points to a null terminated string of replacement text
        //
        EditSL_ReplaceSel(ped, (LPSTR)lParam);
        if (!ped->f40Compat || !wParam)
        {
            Edit_EmptyUndo(Pundo(ped));
        }

        break;

    case EM_GETFIRSTVISIBLELINE:

        //
        // wParam - not used
        // lParam - not used
        // 
        // effects: Returns the first visible line for single line edit controls.
        //
        return ped->ichScreenStart;

    case EM_POSFROMCHAR:
        //
        // wParam --    char index in text
        // lParam --    not used
        // This function returns the (x,y) position of the character.
        //      y is always 0 for single.
        //
    case EM_CHARFROMPOS:
        //
        // wParam --    unused
        // lParam --    pt in edit client coords
        // This function returns
        //          LOWORD: the position of the _closest_ char
        //                  to the passed in point.
        //          HIWORD: the index of the line (always 0 for single)

        {
            LONG xyPos;

            hdc = Edit_GetDC(ped, TRUE);

            if (message == EM_POSFROMCHAR)
            {
                xyPos = MAKELONG(EditSL_IchToLeftXPos(ped, hdc, (ICH)wParam), 0);
            }
            else 
            {
                POINTSTOPOINT(pt, lParam);
                xyPos = EditSL_MouseToIch(ped, hdc, &pt);
            }

            Edit_ReleaseDC(ped, hdc, TRUE);
            return (LRESULT)xyPos;
        }

    case WM_UNDO:
    case EM_UNDO:
        EditSL_Undo(ped);
        break;

    case EM_SETCUEBANNER:
        //
        // This message passes in a LPCWSTR as the lParam to set the
        // cue banner text.
        //

        // Call function to set the text:
        return (LRESULT)EditSL_SetCueBanner(ped, (LPCWSTR) lParam);
        break;


    default:
PassToDefaultWindowProc:
        return DefWindowProc(ped->hwnd, message, wParam, lParam);
        break;
    }

    return 1L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\fontlink.h ===
#ifndef _FONTLINK_H_

#define SPACE_CHAR       0x20
#define EURODOLLAR_CHAR  0x20A0 // New Euro dollar symbol
#define CAPZCARON_CHAR   0x017D
#define SMALLZCARON_CHAR 0x017E

//
//  Unicode SubRange (USR) definitions
//
#define usrBasicLatin           0       // 0x20->0x7f
#define usrLatin1               1       // 0xa0->0xff
#define usrLatinXA              2       // 0x100->0x17f
#define usrLatinXB              3       // 0x180->0x24f
#define usrIPAExtensions        4       // 0x250->0x2af
#define usrSpacingModLetters    5       // 0x2b0->0x2ff
#define usrCombDiacritical      6       // 0x300->0x36f
#define usrBasicGreek           7       // 0x370->0x3cf
#define usrGreekSymbolsCop      8       // 0x3d0->0x3ff
#define usrCyrillic             9       // 0x400->0x4ff
#define usrArmenian             10      // 0x500->0x58f
#define usrBasicHebrew          11      // 0x5d0->0x5ff
#define usrHebrewXA             12      // 0x590->0x5cf
#define usrBasicArabic          13      // 0x600->0x652
#define usrArabicX              14      // 0x653->0x6ff
#define usrDevangari            15      // 0x900->0x97f
#define usrBengali              16      // 0x980->0x9ff
#define usrGurmukhi             17      // 0xa00->0xa7f
#define usrGujarati             18      // 0xa80->0xaff
#define usrOriya                19      // 0xb00->0xb7f
#define usrTamil                20      // 0x0B80->0x0BFF
#define usrTelugu               21      // 0x0C00->0x0C7F
#define usrKannada              22      // 0x0C80->0x0CFF
#define usrMalayalam            23      // 0x0D00->0x0D7F
#define usrThai                 24      // 0x0E00->0x0E7F
#define usrLao                  25      // 0x0E80->0x0EFF
#define usrBasicGeorgian        26      // 0x10D0->0x10FF
#define usrGeorgianExtended     27      // 0x10A0->0x10CF
#define usrHangulJamo           28      // 0x1100->0x11FF
#define usrLatinExtendedAdd     29      // 0x1E00->0x1EFF
#define usrGreekExtended        30      // 0x1F00->0x1FFF
#define usrGeneralPunct         31      // 0x2000->0x206F
#define usrSuperAndSubscript    32      // 0x2070->0x209F
#define usrCurrencySymbols      33      // 0x20A0->0x20CF
#define usrCombDiacriticsS      34      // 0x20D0->0x20FF   
#define usrLetterlikeSymbols    35      // 0x2100->0x214F   
#define usrNumberForms          36      // 0x2150->0x218F   
#define usrArrows               37      // 0x2190->0x21FF   
#define usrMathematicalOps      38      // 0x2200->0x22FF   
#define usrMiscTechnical        39      // 0x2300->0x23FF   
#define usrControlPictures      40      // 0x2400->0x243F   
#define usrOpticalCharRecog     41      // 0x2440->0x245F   
#define usrEnclosedAlphanum     42      // 0x2460->0x24FF   
#define usrBoxDrawing           43      // 0x2500->0x257F   
#define usrBlockElements        44      // 0x2580->0x259F   
#define usrGeometricShapes      45      // 0x25A0->0x25FF   
#define usrMiscDingbats         46      // 0x2600->0x26FF   
#define usrDingbats             47      // 0x2700->0x27BF   
#define usrCJKSymAndPunct       48      // 0x3000->0x303F   
#define usrHiragana             49      // 0x3040->0x309F   
#define usrKatakana             50      // 0x30A0->0x30FF   
#define usrBopomofo             51      // 0x3100->0x312F   
#define usrHangulCompatJamo     52      // 0x3130->0x318F   
#define usrCJKMisc              53      // 0x3190->0x319F   
#define usrEnclosedCJKLtMnth    54      // 0x3200->0x32FF   
#define usrCJKCompatibility     55      // 0x3300->0x33FF   
#define usrHangul               56      // 0xac00->0xd7a3
#define usrReserved1            57
#define usrReserved2            58
#define usrCJKUnifiedIdeo       59      // 0x4E00->0x9FFF   
#define usrPrivateUseArea       60      // 0xE000->0xF8FF   
#define usrCJKCompatibilityIdeographs   61      // 0xF900->0xFAFF   
#define usrAlphaPresentationForms       62      // 0xFB00->0xFB4F   
#define usrArabicPresentationFormsA     63      // 0xFB50->0xFDFF   
#define usrCombiningHalfMarks           64      // 0xFE20->0xFE2F   
#define usrCJKCompatForms               65      // 0xFE30->0xFE4F   
#define usrSmallFormVariants            66      // 0xFE50->0xFE6F   
#define usrArabicPresentationFormsB     67      // 0xFE70->0xFEFE   
#define usrHFWidthForms                 68      // 0xFF00->0xFFEF   
#define usrSpecials                     69      // 0xFFF0->0xFFFD   
#define usrMax                          70

#define FBetween(a, b, c)  (((unsigned)((a) - (b))) <= (c) - (b))

#endif  // _FONTLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\fontlink.cpp ===
//---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       fontlink.cpp
//
//  Contents:   Exports that we available in downlevel comctrl. Note that
//              since v6 runs only on Winnt, we don't need the fonl link stuff
//              in this dll any more.
//
//----------------------------------------------------------------------------
#include "ctlspriv.h"
BOOL GetTextExtentPointWrap(HDC hdc, LPCWSTR lpwch, int cch, LPSIZE lpSize)
{
    return GetTextExtentPoint(hdc, lpwch, cch, lpSize);
}

BOOL GetTextExtentPoint32Wrap(HDC hdc, LPCWSTR lpwch, int cch, LPSIZE lpSize)
{
    return GetTextExtentPointWrap(hdc, lpwch, cch, lpSize);
}
 
BOOL ExtTextOutWrap(HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect, LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp)
{
    return ExtTextOut(hdc, xp, yp, eto, lprect, lpwch, cLen, lpdxp);
}

BOOL GetCharWidthWrap(HDC hdc, UINT uFirstChar, UINT uLastChar, LPINT lpnWidths)
{
    return GetCharWidth(hdc, uFirstChar, uLastChar, lpnWidths);
}

BOOL TextOutWrap(HDC hdc, int xp, int yp, LPCWSTR lpwch, int cLen)
{
    return ExtTextOutWrap(hdc, xp, yp, 0, NULL, lpwch, cLen, NULL);
}    

int  DrawTextExPrivWrap(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, 
                        UINT dwDTformat, LPDRAWTEXTPARAMS lpDTparams)
{
    return DrawTextEx(hdc, lpchText, cchText, lprc, dwDTformat, lpDTparams);
}

int DrawTextWrap(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
{
    return DrawText(hdc, lpchText, cchText, lprc, format);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\image.h ===
#ifndef _INC_IMAGE
#define _INC_IMAGE


// internal image stuff
EXTERN_C void InitDitherBrush(void);
EXTERN_C void TerminateDitherBrush(void);

EXTERN_C HBITMAP CreateMonoBitmap(int cx, int cy);
EXTERN_C HBITMAP CreateColorBitmap(int cx, int cy);

EXTERN_C void WINAPI ImageList_CopyDitherImage(HIMAGELIST pimlDest, WORD iDst,
    int xDst, int yDst, HIMAGELIST pimlSrc, int iSrc, UINT fStyle);

// function to create a imagelist using the params of a given image list
EXTERN_C HIMAGELIST WINAPI ImageList_Clone(HIMAGELIST himl, int cx, int cy,
    UINT flags, int cInitial, int cGrow);

EXTERN_C DWORD WINAPI ImageList_GetItemFlags(HIMAGELIST himl, int i);
EXTERN_C HBITMAP CreateDIB(HDC h, int cx, int cy, RGBQUAD** pprgb);
EXTERN_C BOOL DIBHasAlpha(int cx, int cy, RGBQUAD* prgb);
EXTERN_C void PreProcessDIB(int cx, int cy, RGBQUAD* pargb);

#define GLOW_RADIUS     10
#define DROP_SHADOW     3

#ifndef ILC_COLORMASK
#define ILC_COLORMASK   0x00FE
#define ILD_BLENDMASK   0x000E
#endif
#undef ILC_COLOR
#undef ILC_BLEND

#define CLR_WHITE   0x00FFFFFFL
#define CLR_BLACK   0x00000000L

#define IsImageListIndex(i) ((i) >= 0 && (i) < _cImage)

#define IMAGELIST_SIG   mmioFOURCC('H','I','M','L') // in memory magic
#define IMAGELIST_MAGIC ('I' + ('L' * 256))         // file format magic
// Version has to stay 0x0101 if we want both back ward and forward compatibility for
// our imagelist_read code
#define IMAGELIST_VER0  0x0101                      // file format ver
#define IMAGELIST_VER6  0x0600                      // Comctl32 version 6 imagelist

#define BFTYPE_BITMAP   0x4D42      // "BM"

#define CBDIBBUF        4096

#ifdef __cplusplus
// Define this structure such that it will read and write the same
// format for both 16 and 32 bit applications...
#pragma pack(2)
typedef struct _ILFILEHEADER
{
    WORD    magic;
    WORD    version;
    SHORT   cImage;
    SHORT   cAlloc;
    SHORT   cGrow;
    SHORT   cx;
    SHORT   cy;
    COLORREF clrBk;
    SHORT    flags;
    SHORT       aOverlayIndexes[NUM_OVERLAY_IMAGES];  // array of special images
} ILFILEHEADER;

// This is the old size which has only 4 overlay slots
#define ILFILEHEADER_SIZE0 (SIZEOF(ILFILEHEADER) - SIZEOF(SHORT) * (NUM_OVERLAY_IMAGES - NUM_OVERLAY_IMAGES_0)) 

#pragma pack()



#include "../CommonImageList.h"

class CImageList : public CImageListBase, 
                   public IImageList, 
                   public IImageListPriv, 
                   public IPersistStream,
                   public IImageListPersistStream

{
    long _cRef;

    ~CImageList();
    void _Destroy();

public:
    CImageList();

    static HRESULT InitGlobals();
    HRESULT Initialize(int cx, int cy, UINT flags, int cInitial, int cGrow);
    void _RemoveItemBitmap(int i);
    BOOL _IsSameObject(IUnknown* punk);
    HRESULT _SetIconSize(int cxImage, int cyImage);
    HBITMAP _CreateMirroredBitmap(HBITMAP hbmOrig, BOOL fMirrorEach, int cx);
    HRESULT _ReAllocBitmaps(int cAlloc);
    HRESULT _Add(HBITMAP hbmImage, HBITMAP hbmMask, int cImage, int xStart, int yStart, int* pi);
    HRESULT _AddMasked(HBITMAP hbmImage, COLORREF crMask, int* pi);
    HRESULT _AddValidated(HBITMAP hbmImage, HBITMAP hbmMask, int* pi);
    HRESULT _ReplaceValidated(int i, HBITMAP hbmImage, HBITMAP hbmMask);
    HRESULT _Replace(int i, int cImage, HBITMAP hbmImage, HBITMAP hbmMask, int xStart, int yStart);
    HRESULT _Remove(int i);
    HRESULT _SetOverlayImage(int iImage, int iOverlay);
    HRESULT _ReplaceIcon(int i, HICON hIcon, int* pi);
    HBITMAP _CopyBitmap(HBITMAP hbm, HDC hdc);
    HBITMAP _CopyDIBBitmap(HBITMAP hbm, HDC hdc, RGBQUAD** ppargb);
    HRESULT LoadNormal(IStream* pstm);
    HRESULT SaveNormal(IStream* pstm);

    
    void    _Merge(IImageList* pux, int i, int dx, int dy);
    HRESULT _Merge(int i1, IUnknown* punk, int i2, int dx, int dy, CImageList** ppiml);
    HRESULT _Read(ILFILEHEADER *pilfh, HBITMAP hbmImage, PVOID pvBits, HBITMAP hbmMask);
    BOOL    _MoreOverlaysUsed();
    BOOL GetSpareImageRect(RECT * prcImage);
    BOOL GetSpareImageRectInverted(RECT * prcImage);
    void _CopyOneImage(int iDst, int x, int y, CImageList* piml, int iSrc);
    BOOL CreateDragBitmaps();
    COLORREF _SetBkColor(COLORREF clrBk);
    HBITMAP _CreateBitmap(int cx, int cy, RGBQUAD** ppargb);
    void _ResetBkColor(int iFirst, int iLast, COLORREF clr);
    BOOL _HasAlpha(int i);
    void _ScanForAlpha();
    BOOL _PreProcessImage(int i);
    inline DWORD _GetItemFlags(int i);
    BOOL _MaskStretchBlt(BOOL fStretch, int i, HDC hdcDest, int xDst, int yDst, int cxDst, int cyDst,
                                   HDC hdcImage, int xSrc, int ySrc, int cxSrc, int cySrc,
                                   int xMask, int yMask,
                                   DWORD dwRop);
    BOOL _StretchBlt(BOOL fStretch, HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int xs, int ys, int cxs, int cys, DWORD dwRop);

    inline void SetItemFlags(int i, DWORD dwFlag);
    void _GenerateAlphaForImageUsingMask(int iImage, BOOL fSpare);
    void BlendCTHelper(DWORD *pdw, DWORD rgb, UINT n, UINT count);
    void BlendCT(HDC hdcDst, int xDst, int yDst, int x, int y, int cx, int cy, COLORREF rgb, UINT fStyle);
    void BlendDither(HDC hdcDst, int xDst, int yDst, int x, int y, int cx, int cy, COLORREF rgb, UINT fStyle);
    void Blend16Helper(int xSrc, int ySrc, int xDst, int yDst, int cx, int cy, COLORREF rgb, int a);
    void Blend16(HDC hdcDst, int xDst, int yDst, int iImage, int cx, int cy, COLORREF rgb, UINT fStyle);
    BOOL Blend32(HDC hdcDst, int xDst, int yDst, int iImage, int cx, int cy, COLORREF rgb, UINT fStyle);
    BOOL Blend(HDC hdcDst, int xDst, int yDst, int iImage, int cx, int cy, COLORREF rgb, UINT fStyle);
    HRESULT GetImageRectInverted(int i, RECT * prcImage);

    static BOOL GlobalInit(void);
    static void GlobalUninit(void);
    static void SelectDstBitmap(HBITMAP hbmDst);
    static void SelectSrcBitmap(HBITMAP hbmSrc);
    static CImageList* Create(int cx, int cy, UINT flags, int cInitial, int cGrow);
    static void    _DeleteBitmap(HBITMAP hbmp);

    BOOL        _fInitialized;
    BOOL        _fSolidBk;   // is the bkcolor a solid color (in hbmImage)
    BOOL        _fColorsSet;  // The DIB colors have been set with SetColorTable()
    int         _cImage;     // count of images in image list
    int         _cAlloc;     // # of images we have space for
    int         _cGrow;      // # of images to grow bitmaps by
    int         _cx;         // width of each image
    int         _cy;         // height
    int         _cStrip;     // # images in horizontal strip
    UINT        _flags;      // ILC_* flags
    COLORREF    _clrBlend;   // last blend color
    COLORREF    _clrBk;      // bk color or CLR_NONE for transparent.
    HBRUSH      _hbrBk;      // bk brush or black
    HBITMAP     _hbmImage;   // all images are in here
    HBITMAP     _hbmMask;    // all image masks are in here.
    HDSA        _dsaFlags;    // Flags for the images
    RGBQUAD*    _pargbImage;    // The alpha values of the imagelist.
    HDC         _hdcImage;
    HDC         _hdcMask;
    int         _aOverlayIndexes[NUM_OVERLAY_IMAGES];    // array of special images
    int         _aOverlayX[NUM_OVERLAY_IMAGES];          // x offset of image
    int         _aOverlayY[NUM_OVERLAY_IMAGES];          // y offset of image
    int         _aOverlayDX[NUM_OVERLAY_IMAGES];         // cx offset of image
    int         _aOverlayDY[NUM_OVERLAY_IMAGES];         // cy offset of image
    int         _aOverlayF[NUM_OVERLAY_IMAGES];          // ILD_ flags for image
    CImageList* _pimlMirror;  // Set only when another mirrored imagelist is needed (ILC_MIRROR)    

    //
    // used for "blending" effects on a HiColor display.
    // assumes layout of a DIBSECTION.
    //
    struct 
    {
        BITMAP              bm;
        BITMAPINFOHEADER    bi;
        DWORD               ct[256];
    }   dib;

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG)AddRef();
    STDMETHODIMP_(ULONG)Release();


    // *** IImageList ***
    STDMETHODIMP Add(HBITMAP hbmImage, HBITMAP hbmMask, int* pi);
    STDMETHODIMP ReplaceIcon(int i, HICON hIcon, int* pi);
    STDMETHODIMP SetOverlayImage(int iImage, int iOverlay);
    STDMETHODIMP Replace(int i, HBITMAP hbmImage, HBITMAP hbmMask);
    STDMETHODIMP AddMasked(HBITMAP hbmImage, COLORREF crMask, int* pi);
    STDMETHODIMP Draw(IMAGELISTDRAWPARAMS* pimldp);
    STDMETHODIMP Remove(int i);
    STDMETHODIMP GetIcon(int i, UINT flags, HICON* phicon);
    STDMETHODIMP GetImageInfo(int i, IMAGEINFO * pImageInfo);
    STDMETHODIMP Copy(int iDst, IUnknown* punkSrc, int iSrc, UINT uFlags);
    STDMETHODIMP Merge(int i1, IUnknown* punk, int i2, int dx, int dy, REFIID riid, void** ppv);
    STDMETHODIMP Clone(REFIID riid, void** ppv);
    STDMETHODIMP GetImageRect(int i, RECT * prcImage);
    STDMETHODIMP SetIconSize(int cxImage, int cyImage);
    STDMETHODIMP GetIconSize(int* pcx, int* pcy);
    STDMETHODIMP SetImageCount(UINT uAlloc);
    STDMETHODIMP GetImageCount(int* pi);
    STDMETHODIMP SetBkColor(COLORREF clrBk, COLORREF* pclr);
    STDMETHODIMP GetBkColor(COLORREF* pclr);
    STDMETHODIMP BeginDrag(int iTrack, int dxHotspot, int dyHotspot);
    STDMETHODIMP DragEnter(HWND hwndLock, int x, int y);
    STDMETHODIMP DragMove(int x, int y);
    STDMETHODIMP DragLeave(HWND hwndLock);
    STDMETHODIMP EndDrag();
    STDMETHODIMP SetDragCursorImage(IUnknown* punk, int i, int dxHotspot, int dyHotspot);
    STDMETHODIMP DragShowNolock(BOOL fShow);
    STDMETHODIMP GetDragImage(POINT * ppt, POINT * pptHotspot, REFIID riid, void** ppv);
    STDMETHODIMP GetItemFlags(int i, DWORD *dwFlags);
    STDMETHODIMP GetOverlayImage(int iOverlay, int *piIndex);

    // *** IImageListPriv ***
    STDMETHODIMP SetFlags(UINT uFlags);
    STDMETHODIMP GetFlags(UINT* puFlags);
    STDMETHODIMP SetColorTable(int start, int len, RGBQUAD *prgb, int* pi);
    STDMETHODIMP GetPrivateGoo(HBITMAP* hbmp, HDC* hdc, HBITMAP* hbmpMask, HDC* hdcMask);
    STDMETHODIMP GetMirror(REFIID riid, void** ppv);
    STDMETHODIMP CopyDitherImage(WORD iDst, int xDst, int yDst, IUnknown* punkSrc, int iSrc, UINT fStyle);

    // *** IPersist ***
    STDMETHODIMP GetClassID(CLSID *pClassID)    {   *pClassID = CLSID_ImageList; return S_OK;   }
    STDMETHODIMP IsDirty()                      {   return E_NOTIMPL; }

    // *** IPersistStream ***
    STDMETHODIMP Load(IStream *pStm);
    STDMETHODIMP Save(IStream *pStm, int fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize)   { return E_NOTIMPL; }

    // *** IImageListPersistStream ***
    STDMETHODIMP LoadEx(DWORD dwFlags, IStream* pstm);
    STDMETHODIMP SaveEx(DWORD dwFlags, IStream* pstm);

};
#endif // __cplusplus
#endif  // _INC_IMAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\hotkey.c ===
/*-----------------------------------------------------------------------
**
** Hotkey.c
**
** Hotkey edit control.
**
**-----------------------------------------------------------------------*/
//
// Win32 REVIEW:
//  See all the Get/SetWindowInt().
//
#include "ctlspriv.h"

#define F_EXT       0x01000000L

#define GWU_VIRTKEY  0
#define GWU_MODS     1*sizeof(ULONG_PTR)
#define GWU_INVALID  2*sizeof(ULONG_PTR)
#define GWU_DEFAULT  3*sizeof(ULONG_PTR)
#define GWU_HFONT    4*sizeof(ULONG_PTR)
#define GWU_YFONT    5*sizeof(ULONG_PTR)
#define GWU_HTHEME   6*sizeof(ULONG_PTR)
#define NUM_WND_EXTRA (GWU_HTHEME+sizeof(ULONG_PTR))

LRESULT CALLBACK HotKeyWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);

BOOL InitHotKeyClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = HotKeyWndProc;
    wc.lpszClassName = s_szHOTKEY_CLASS;
    wc.style         = CS_GLOBALCLASS;
    wc.hInstance     = hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = NUM_WND_EXTRA;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}

const UINT s_Combos[8] = {
                    HKCOMB_NONE,
                    HKCOMB_S,
                    HKCOMB_C,
                    HKCOMB_SC,
                    HKCOMB_A,
                    HKCOMB_SA,
                    HKCOMB_CA,
                    HKCOMB_SCA};

void SetHotKey(HWND hwnd, WORD wVirtKey, WORD wMods, BOOL fSendNotify)
{
    /* don't invalidate if it's the same
     */
    if (wVirtKey == GetWindowInt(hwnd, GWU_VIRTKEY) &&
        wMods == GetWindowInt(hwnd, GWU_MODS))
        return;

    SetWindowInt(hwnd, GWU_VIRTKEY ,wVirtKey);
    SetWindowInt(hwnd, GWU_MODS ,wMods);
    InvalidateRect(hwnd,NULL,TRUE);

    if (fSendNotify) {
        FORWARD_WM_COMMAND(GetParent(hwnd), GetDlgCtrlID(hwnd), hwnd, EN_CHANGE, SendMessage);
    }

    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, hwnd, OBJID_CLIENT, 0);
}

DWORD GetKeyName(UINT vk, LPTSTR lpsz, DWORD cch, BOOL fExt)
{
    LONG scan;

    scan = (LONG)MapVirtualKey(vk,0) << 16;
    if (fExt)
    {
        scan |= F_EXT;
    }

    return (cch > 0) ? GetKeyNameText(scan, lpsz, cch) : 0;
}

void PaintHotKey(register HWND hwnd)
{
    TCHAR sz[128];
    TCHAR szPlus[10];
    int cch;
    register HDC hdc;
    UINT wMods;
    UINT wVirtKey;
    PAINTSTRUCT ps;
    int x, y;
    HANDLE hFont;

    LocalizedLoadString(IDS_PLUS, szPlus, ARRAYSIZE(szPlus));

    wVirtKey = (UINT) GetWindowInt(hwnd, GWU_VIRTKEY);
    wMods = (UINT) GetWindowInt(hwnd, GWU_MODS);
    if (wVirtKey || wMods)
    {
        sz[0] = 0;
        cch = 0;
        if (wMods & HOTKEYF_CONTROL)
        {
            GetKeyName(VK_CONTROL, sz, ARRAYSIZE(sz), FALSE);
            StringCchCat(sz, ARRAYSIZE(sz), szPlus);
        }

        if (wMods & HOTKEYF_SHIFT)
        {
            cch = lstrlen(sz);
            GetKeyName(VK_SHIFT, sz+cch, ARRAYSIZE(sz)-cch, FALSE);
            StringCchCat(sz, ARRAYSIZE(sz), szPlus);
        }

        if (wMods & HOTKEYF_ALT)
        {
            cch = lstrlen(sz);
            GetKeyName(VK_MENU, sz+cch, ARRAYSIZE(sz)-cch, FALSE);
            StringCchCat(sz, ARRAYSIZE(sz), szPlus);
        }

        cch = lstrlen(sz);
        GetKeyName(wVirtKey, sz+cch, ARRAYSIZE(sz)-cch, wMods & HOTKEYF_EXT);
    }
    else
    {
        LocalizedLoadString(IDS_NONE,sz,100);
    }

    cch = lstrlen(sz);

    HideCaret(hwnd);

    InvalidateRect(hwnd, NULL, TRUE);
    hdc = BeginPaint(hwnd,&ps);


    hFont = SelectObject(hdc, (HFONT)GetWindowInt(hwnd,GWU_HFONT));

    x = g_cxBorder;
    y = g_cyBorder;

    if (IsWindowEnabled(hwnd))
    {
        SetBkColor(hdc, g_clrWindow);
        SetTextColor(hdc, g_clrWindowText);
        TextOut(hdc,x,y,sz,cch);
    }
    else
    {
        // set the background color to Grayed like edit controls
        SetBkColor(hdc, g_clrBtnFace);
        if (g_clrGrayText)
        {
            SetTextColor(hdc,g_clrGrayText);
            TextOut(hdc,x,y,sz,cch);
        }
        else
        {
            GrayString(hdc,NULL,NULL,(ULONG_PTR)(LPTSTR)sz,cch,x,y,0,0);
        }
    }

    MGetTextExtent(hdc, sz, cch, &x, NULL);
     if (GetFocus() == hwnd)
         SetCaretPos(x+g_cxBorder,
                    g_cyBorder);
    ShowCaret(hwnd);

    EndPaint(hwnd,&ps);
}

void HKMSetRules(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    SetWindowInt(hwnd, GWU_INVALID, wParam);
    SetWindowInt(hwnd, GWU_DEFAULT, lParam);
}

HFONT HKMSetFont(HWND hwnd, HFONT wParam)
{
    HFONT lParam;
    HDC hdc;
    INT cy;

    lParam = (HFONT)GetWindowInt(hwnd,GWU_HFONT);
    SetWindowInt(hwnd,GWU_HFONT,(LONG_PTR)wParam);
    hdc = GetDC(hwnd);
    if (wParam)
        wParam = SelectObject(hdc, wParam);
    MGetTextExtent(hdc, TEXT("C"), 1, NULL, &cy);
    SetWindowInt(hwnd,GWU_YFONT,cy);
    if (wParam)
        SelectObject(hdc, wParam);
    ReleaseDC(hwnd,hdc);
    InvalidateRect(hwnd,NULL,TRUE);
    return lParam;
}

LRESULT CALLBACK HotKeyWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    WORD wVirtKey;
    WORD wMods;
    RECT rc;
    HDC hdc;

    switch (wMsg)
    {
    case WM_NCCREATE:
        SetWindowBits(hwnd, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);
        InitGlobalColors();
        return TRUE;

    case WM_CREATE:
        {
            HTHEME hTheme;
            SetHotKey(hwnd, 0, 0, FALSE);
            HKMSetRules(hwnd, 0, 0);
            HKMSetFont(hwnd, g_hfontSystem);
            hTheme = OpenThemeData(hwnd, L"Combobox");
            if (hTheme)
                SetWindowLongPtr(hwnd, GWU_HTHEME, (ULONG_PTR)hTheme);
        }
        break;

    case WM_DESTROY:
        {
            HTHEME hTheme = (HTHEME)GetWindowLongPtr(hwnd, GWU_HTHEME);
            if (hTheme)
                CloseThemeData(hTheme);
        }
        break;

    case WM_NCPAINT:
        {
            HTHEME hTheme = (HTHEME)GetWindowLongPtr(hwnd, GWU_HTHEME);
            if (hTheme)
            {
                HRGN hrgn = (wParam != 1) ? (HRGN)wParam : NULL;
                HBRUSH hbr = (HBRUSH)GetClassLongPtr(hwnd, GCLP_HBRBACKGROUND);

                if (CCDrawNonClientTheme(hTheme, hwnd, hrgn, hbr, 0, CBXS_NORMAL))
                {
                    break;
                }
            }
        }
        goto DoDefault;

    case WM_THEMECHANGED:
        {
            HTHEME hTheme = (HTHEME)GetWindowLongPtr(hwnd, GWU_HTHEME);
            if (hTheme)
                CloseThemeData(hTheme);
                
            hTheme = OpenThemeData(hwnd, L"Combobox");

            SetWindowLongPtr(hwnd, GWU_HTHEME, (ULONG_PTR)hTheme);    // Set a NULL if OpenThemeData fails
        }
        break;



    case WM_SETFOCUS:
        InvalidateRect(hwnd,NULL,TRUE);
        CreateCaret(hwnd,NULL,0,(int)GetWindowInt(hwnd,GWU_YFONT));
        ShowCaret(hwnd);
        break;

    case WM_KILLFOCUS:
        if (!GetWindowInt(hwnd, GWU_VIRTKEY))
        SetHotKey(hwnd, 0, 0, TRUE);
        DestroyCaret();
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTCHARS | DLGC_WANTARROWS; // | DLGC_WANTALLKEYS;

    case HKM_SETHOTKEY:
        SetHotKey(hwnd, LOBYTE(wParam), HIBYTE(wParam), FALSE);
        break;

    case HKM_GETHOTKEY:
        return (256*(BYTE)GetWindowInt(hwnd, GWU_MODS)) +
                ((BYTE)GetWindowInt(hwnd, GWU_VIRTKEY));
        break;

    case HKM_SETRULES:
        HKMSetRules(hwnd, wParam, LOWORD(lParam));
        break;

    case WM_LBUTTONDOWN:
        SetFocus(hwnd);
        break;

    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_RETURN:
        case VK_TAB:
        case VK_SPACE:
        case VK_DELETE:
        case VK_ESCAPE:
        case VK_BACK:
        case VK_LWIN:
        case VK_RWIN:
        case VK_APPS:
            SetHotKey(hwnd, 0, 0, TRUE);
            return DefWindowProc(hwnd,wMsg,wParam,lParam);

        case VK_MENU:
        case VK_SHIFT:
        case VK_CONTROL:
            wVirtKey = 0;
            goto SetNewHotKey;

        default:
            wVirtKey = (WORD) wParam;
SetNewHotKey:
            wMods = 0;
            if (GetKeyState(VK_CONTROL) < 0)
                wMods |= HOTKEYF_CONTROL;
            if (GetKeyState(VK_SHIFT) < 0)
                wMods |= HOTKEYF_SHIFT;
            if (GetKeyState(VK_MENU) < 0)
                wMods |= HOTKEYF_ALT;

            #define IsFUNKEY(vk) ((vk) >= VK_F1 && (vk) <= VK_F24)
            #define IsNUMKEY(vk) ((vk) >= VK_NUMPAD0 && (vk) <= VK_DIVIDE)

            //
            //  dont enforce any rules on the Function keys or
            //  on the number pad keys.
            //
            // if this combination is invalid, use the default
            if (!IsFUNKEY(wVirtKey) &&
                !IsNUMKEY(wVirtKey) &&
                (s_Combos[wMods] & GetWindowInt(hwnd, GWU_INVALID)))
            {
                wMods = (WORD)GetWindowInt(hwnd, GWU_DEFAULT);
            }

            if (lParam & F_EXT)
                wMods |= HOTKEYF_EXT;

            SetHotKey(hwnd, wVirtKey, wMods, TRUE);
            break;
        }
        break;

    case WM_SYSKEYUP:
    case WM_CHAR:
    case WM_SYSCHAR:
    case WM_KEYUP:
        if (!GetWindowInt(hwnd, GWU_VIRTKEY))
            SetHotKey(hwnd, 0, 0, TRUE);
        break;

    case WM_GETFONT:
        return GetWindowInt(hwnd,GWU_HFONT);

    case WM_SETFONT:
        return (LRESULT)(UINT_PTR)HKMSetFont(hwnd, (HFONT)wParam);

    case WM_PAINT:
        PaintHotKey(hwnd);
        break;

    case WM_ERASEBKGND:
        HideCaret(hwnd);
        hdc = GetDC(hwnd);
        GetClientRect(hwnd, &rc);
        if (IsWindowEnabled(hwnd)) {
            FillRect(hdc, &rc, g_hbrWindow);
        } else {
            FillRect(hdc, &rc, g_hbrBtnFace);
        }
        ReleaseDC(hwnd, hdc);
        // lParam = DefWindowProc(hwnd,wMsg,wParam,lParam);
        ShowCaret(hwnd);
        return TRUE;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_HOTKEY;
        goto DoDefault;

    case WM_ENABLE:
        InvalidateRect(hwnd, NULL, TRUE);
        goto DoDefault;

    default:
DoDefault:
        return DefWindowProc(hwnd,wMsg,wParam,lParam);
    }
    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\image.cpp ===
#include "ctlspriv.h"
#include "image.h"
#include "math.h"

#ifndef AC_MIRRORBITMAP
#define AC_MIRRORBITMAP  0          // BUGBUG: Remove me
#endif

void ImageList_DeleteDragBitmaps();

BOOL ImageList_SetDragImage(HIMAGELIST piml, int i, int dxHotspot, int dyHotspot);

HDC g_hdcSrc = NULL;
HBITMAP g_hbmSrc = NULL;
HBITMAP g_hbmDcDeselect = NULL;

HDC g_hdcDst = NULL;
HBITMAP g_hbmDst = NULL;
int g_iILRefCount = 0;

HRESULT WINAPI HIMAGELIST_QueryInterface(HIMAGELIST himl, REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (himl)
    {
        // First Convert the HIMAGELIST to an IUnknown.
        IUnknown* punk = reinterpret_cast<IUnknown*>(himl);

        // Now, we need to validate the object. CImageListBase contains the goo needed to figure out if this
        // is a valid imagelist.
        CImageListBase* pval = FindImageListBase(punk);

        // Now we call some private member.
        if (pval->IsValid())
        {
            // If it's valid then we can QI safely.
            return punk->QueryInterface(riid, ppv);
        }
    }

    return E_POINTER;
}

HRESULT WimpyDrawEx(IImageList* pux, int i, HDC hdcDst, int x, int y, int cx, int cy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
{
    IMAGELISTDRAWPARAMS imldp = {0};

    imldp.cbSize = sizeof(imldp);
    imldp.himl   = reinterpret_cast<HIMAGELIST>(pux);
    imldp.i      = i;
    imldp.hdcDst = hdcDst;
    imldp.x      = x;
    imldp.y      = y;
    imldp.cx     = cx;
    imldp.cy     = cy;
    imldp.rgbBk  = rgbBk;
    imldp.rgbFg  = rgbFg;
    imldp.fStyle = fStyle;
    imldp.dwRop  = SRCCOPY;
    
    return pux->Draw(&imldp);
}

HRESULT WimpyDraw(IImageList* pux, int i, HDC hdcDst, int x, int y, UINT fStyle)
{
    IMAGELISTDRAWPARAMS imldp = {0};

    imldp.cbSize = sizeof(imldp);
    imldp.himl   = reinterpret_cast<HIMAGELIST>(pux);
    imldp.i      = i;
    imldp.hdcDst = hdcDst;
    imldp.x      = x;
    imldp.y      = y;
    imldp.rgbBk  = CLR_DEFAULT;
    imldp.rgbFg  = CLR_DEFAULT;
    imldp.fStyle = fStyle;
    imldp.dwRop  = SRCCOPY;
    
    return pux->Draw(&imldp);
}



CImageList::CImageList() : _cRef(1)
{
}

CImageList::~CImageList()
{
    if (_pimlMirror)
    {
        _pimlMirror->Release();
    }

    _Destroy();
}


DWORD CImageList::_GetItemFlags(int i)
{
    DWORD dw = 0;

    // NOTE: Currently we only add the flags in 32bit mode. If needed, you have
    // to modify ::Load in order to add items during a load. I'm just lazy
    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
        DSA_GetItem(_dsaFlags, i, &dw);
    return dw;
}

void CImageList::SetItemFlags(int i, DWORD dwFlags)
{
    if (_dsaFlags)
        DSA_SetItem(_dsaFlags, i, &dwFlags);
}


HRESULT CImageList::Initialize(int cxI, int cyI, UINT flagsI, int cInitialI, int cGrowI)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (cGrowI < 4)
    {
        cGrowI = 4;
    }
    else 
    {
        // round up by 4's
        cGrowI = (cGrowI + 3) & ~3;
    }
    _cStrip = 1;
    _cGrow = cGrowI;
    _cx = cxI;
    _cy = cyI;
    _clrBlend = CLR_NONE;
    _clrBk = CLR_NONE;
    _hbrBk = (HBRUSH)GetStockObject(BLACK_BRUSH);
    _fSolidBk = TRUE;
    _flags = flagsI;
    _pimlMirror = NULL;        

    //
    // Initialize the overlay indexes to -1 since 0 is a valid index.
    //

    for (int i = 0; i < NUM_OVERLAY_IMAGES; i++) 
    {
        _aOverlayIndexes[i] = -1;
    }

    _hdcImage = CreateCompatibleDC(NULL);

    if (_hdcImage)
    {
        hr = S_OK;
        if (_flags & ILC_MASK)
        {
            _hdcMask = CreateCompatibleDC(NULL);

            if (!_hdcMask)
                hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            hr = _ReAllocBitmaps(cInitialI + 1);
            if (FAILED(hr))
            {
                hr = _ReAllocBitmaps(2);
            }
        }
    }

    // Don't do this if we are already initialized, we just want to pass new information....
    if (!_fInitialized)
        g_iILRefCount++;

    _fInitialized = TRUE;

    return hr;
}


HRESULT CImageList::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CImageList, IImageListPriv),
        QITABENT(CImageList, IImageList),
        QITABENT(CImageList, IImageListPersistStream),
        QITABENT(CImageList, IPersistStream),
        QITABENTMULTI(CImageList, IPersist, IPersistStream),
        { 0 },
    };
    return QISearch(this, (LPCQITAB)qit, riid, ppv);
}

ULONG CImageList::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CImageList::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CImageList::GetPrivateGoo(HBITMAP* phbmp, HDC* phdc, HBITMAP* phbmpMask, HDC* phdcMask)
{
    if (phbmp)
        *phbmp = _hbmImage;

    if (phdc)
        *phdc = _hdcImage;

    if (phbmpMask)
        *phbmpMask = _hbmMask;

    if (phdcMask)
        *phdcMask = _hdcMask;

    return S_OK;
}

HRESULT CImageList::GetMirror(REFIID riid, void** ppv)
{
    if (_pimlMirror)
        return _pimlMirror->QueryInterface(riid, ppv);

    return E_NOINTERFACE;
}

//
// global work buffer, this buffer is always a DDB never a DIBSection
//
HBITMAP g_hbmWork = NULL;                   // work buffer.
BITMAP  g_bmWork = {0};                     // work buffer size

HBRUSH g_hbrMonoDither = NULL;              // gray dither brush for dragging
HBRUSH g_hbrStripe = NULL;

#define NOTSRCAND       0x00220326L
#define ROP_PSo         0x00FC008A
#define ROP_DPo         0x00FA0089
#define ROP_DPna        0x000A0329
#define ROP_DPSona      0x00020c89
#define ROP_SDPSanax    0x00E61ce8
#define ROP_DSna        0x00220326
#define ROP_PSDPxax     0x00b8074a

#define ROP_PatNotMask  0x00b8074a      // D <- S==0 ? P : D
#define ROP_PatMask     0x00E20746      // D <- S==1 ? P : D
#define ROP_MaskPat     0x00AC0744      // D <- P==1 ? D : S

#define ROP_DSo         0x00EE0086L
#define ROP_DSno        0x00BB0226L
#define ROP_DSa         0x008800C6L

static int g_iDither = 0;

void InitDitherBrush()
{
    HBITMAP hbmTemp;
    static const WORD graybits[] = {0xAAAA, 0x5555, 0xAAAA, 0x5555,
                       0xAAAA, 0x5555, 0xAAAA, 0x5555};

    if (g_iDither) 
    {
        g_iDither++;
    } 
    else 
    {
        // build the dither brush.  this is a fixed 8x8 bitmap
        hbmTemp = CreateBitmap(8, 8, 1, 1, graybits);
        if (hbmTemp)
        {
            // now use the bitmap for what it was really intended...
            g_hbrMonoDither = CreatePatternBrush(hbmTemp);
            DeleteObject(hbmTemp);
            g_iDither++;
        }
    }
}

void TerminateDitherBrush()
{
    g_iDither--;
    if (g_iDither == 0) 
    {
        DeleteObject(g_hbrMonoDither);
        g_hbrMonoDither = NULL;
    }
}

/*
** GetScreenDepth()
*/
int GetScreenDepth()
{
    int i;
    HDC hdc = GetDC(NULL);
    i = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
    ReleaseDC(NULL, hdc);
    return i;
}

//
// should we use a DIB section on the current device?
//
// the main goal of using DS is to save memory, but they draw slow
// on some devices.
//
// 4bpp Device (ie 16 color VGA)    dont use DS
// 8bpp Device (ie 256 color SVGA)  use DS if DIBENG based.
// >8bpp Device (ie 16bpp 24bpp)    always use DS, saves memory
//

#define CAPS1           94          /* other caps */
#define C1_DIBENGINE    0x0010      /* DIB Engine compliant driver          */

//
// create a bitmap compatible with the given ImageList
//
HBITMAP CImageList::_CreateBitmap(int cx, int cy, RGBQUAD** ppargb)
{
    HDC hdc;
    HBITMAP hbm;

    struct 
    {
        BITMAPINFOHEADER bi;
        DWORD            ct[256];
    } dib;

    hdc = GetDC(NULL);

    // no color depth was specifed
    //
    // if we are on a DIBENG based DISPLAY, we use 4bit DIBSections to save
    // memory.
    //
    if ((_flags & ILC_COLORMASK) == 0)
    {
        _flags |= ILC_COLOR4;
    }

    if ((_flags & ILC_COLORMASK) != ILC_COLORDDB)
    {
        dib.bi.biSize            = sizeof(BITMAPINFOHEADER);
        dib.bi.biWidth           = cx;
        dib.bi.biHeight          = cy;
        dib.bi.biPlanes          = 1;
        dib.bi.biBitCount        = (_flags & ILC_COLORMASK);
        dib.bi.biCompression     = BI_RGB;
        dib.bi.biSizeImage       = 0;
        dib.bi.biXPelsPerMeter   = 0;
        dib.bi.biYPelsPerMeter   = 0;
        dib.bi.biClrUsed         = 16;
        dib.bi.biClrImportant    = 0;
        dib.ct[0]                = 0x00000000;    // 0000  black
        dib.ct[1]                = 0x00800000;    // 0001  dark red
        dib.ct[2]                = 0x00008000;    // 0010  dark green
        dib.ct[3]                = 0x00808000;    // 0011  mustard
        dib.ct[4]                = 0x00000080;    // 0100  dark blue
        dib.ct[5]                = 0x00800080;    // 0101  purple
        dib.ct[6]                = 0x00008080;    // 0110  dark turquoise
        dib.ct[7]                = 0x00C0C0C0;    // 1000  gray
        dib.ct[8]                = 0x00808080;    // 0111  dark gray
        dib.ct[9]                = 0x00FF0000;    // 1001  red
        dib.ct[10]               = 0x0000FF00;    // 1010  green
        dib.ct[11]               = 0x00FFFF00;    // 1011  yellow
        dib.ct[12]               = 0x000000FF;    // 1100  blue
        dib.ct[13]               = 0x00FF00FF;    // 1101  pink (magenta)
        dib.ct[14]               = 0x0000FFFF;    // 1110  cyan
        dib.ct[15]               = 0x00FFFFFF;    // 1111  white

        if (dib.bi.biBitCount == 8)
        {
            HPALETTE hpal;
            int i;

            if (hpal = CreateHalftonePalette(NULL))
            {
                i = GetPaletteEntries(hpal, 0, 256, (LPPALETTEENTRY)&dib.ct[0]);
                DeleteObject(hpal);

                if (i > 64)
                {
                    dib.bi.biClrUsed = i;
                    for (i=0; i<(int)dib.bi.biClrUsed; i++)
                        dib.ct[i] = RGB(GetBValue(dib.ct[i]),GetGValue(dib.ct[i]),GetRValue(dib.ct[i]));
                }
            }
            else
            {
                dib.bi.biBitCount = (_flags & ILC_COLORMASK);
                dib.bi.biClrUsed = 256;
            }

            if (dib.bi.biClrUsed <= 16)
                dib.bi.biBitCount = 4;
        }

        hbm = CreateDIBSection(hdc, (LPBITMAPINFO)&dib, DIB_RGB_COLORS, (PVOID*)ppargb, NULL, 0);
    }
    else
    {
        hbm = CreateCompatibleBitmap(hdc, cx, cy);
    }

    ReleaseDC(NULL, hdc);

    return hbm;
}

EXTERN_C HBITMAP CreateColorBitmap(int cx, int cy)
{
    HBITMAP hbm;
    HDC hdc;

    hdc = GetDC(NULL);

    //
    // on a multimonitor system with mixed bitdepths
    // always use a 32bit bitmap for our work buffer
    // this will prevent us from losing colors when
    // blting to and from the screen.  this is mainly
    // important for the drag & drop offscreen buffers.
    //
    if (!(GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) &&
        GetSystemMetrics(SM_CMONITORS) > 1 &&
        GetSystemMetrics(SM_SAMEDISPLAYFORMAT) == 0)
    {
        void* p;
        BITMAPINFO bi = {sizeof(BITMAPINFOHEADER), cx, cy, 1, 32};
        hbm = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, &p, NULL, 0);
    }
    else
    {
        hbm = CreateCompatibleBitmap(hdc, cx, cy);
    }

    ReleaseDC(NULL, hdc);
    return hbm;
}

HBITMAP CreateDIB(HDC h, int cx, int cy, RGBQUAD** pprgb)
{
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    return CreateDIBSection(h, &bi, DIB_RGB_COLORS, (void**)pprgb, NULL, 0);
}

BOOL DIBHasAlpha(int cx, int cy, RGBQUAD* prgb)
{
    int cTotal = cx * cy;
    for (int i = 0; i < cTotal; i++)
    {
        if (prgb[i].rgbReserved != 0)
            return TRUE;
    }

    return FALSE;
}

void PreProcessDIB(int cx, int cy, RGBQUAD* pargb)
{
    int cTotal = cx * cy;
    for (int i = 0; i < cTotal; i++)
    {
        RGBQUAD* prgb = &pargb[i];
        if (prgb->rgbReserved != 0)
        {
            prgb->rgbRed      = ((prgb->rgbRed   * prgb->rgbReserved) + 128) / 255;
            prgb->rgbGreen    = ((prgb->rgbGreen * prgb->rgbReserved) + 128) / 255;
            prgb->rgbBlue     = ((prgb->rgbBlue  * prgb->rgbReserved) + 128) / 255;
        }
        else
        {
            *((DWORD*)prgb) = 0;
        }
    }
}

EXTERN_C HBITMAP CreateMonoBitmap(int cx, int cy)
{
#ifdef MONO_DIB
    struct 
    {
        BITMAPINFOHEADER bi;
        DWORD            ct[2];
    } dib = {0};
    dib.bi.biSize = sizeof(dib.bi);
    dib.bi.biWidth = cx;
    dib.bi.biHeight = cy;
    dib.bi.biPlanes = 1;
    dib.bi.biBitCount = 1;
    dib.bi.biCompression = BI_RGB;
    dib.ct[0] = 0x00000000;
    dib.ct[1] = 0x00ffffff;

    HBITMAP hbmp = NULL;
    HDC hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        hbmp = CreateDIBSection(hdc, (BITMAPINFO*)&dib, DIB_PAL_COLORS, NULL, NULL, 0);
        DeleteDC(hdc);
    }

    return hbmp;
#else
    return CreateBitmap(cx, cy, 1, 1, NULL);
#endif
}

//============================================================================

BOOL CImageList::GlobalInit(void)
{
    HDC hdcScreen;
    static const WORD stripebits[] = {0x7777, 0xdddd, 0x7777, 0xdddd,
                         0x7777, 0xdddd, 0x7777, 0xdddd};
    HBITMAP hbmTemp;

    TraceMsg(TF_IMAGELIST, "CImageList::GlobalInit");

    // if already initialized, there is nothing to do
    if (g_hdcDst)
        return TRUE;

    hdcScreen = GetDC(HWND_DESKTOP);

    g_hdcSrc = CreateCompatibleDC(hdcScreen);
    g_hdcDst = CreateCompatibleDC(hdcScreen);

    InitDitherBrush();

    hbmTemp = CreateBitmap(8, 8, 1, 1, stripebits);
    if (hbmTemp)
    {
        // initialize the deselect 1x1 bitmap
        g_hbmDcDeselect = SelectBitmap(g_hdcDst, hbmTemp);
        SelectBitmap(g_hdcDst, g_hbmDcDeselect);

        g_hbrStripe = CreatePatternBrush(hbmTemp);
        DeleteObject(hbmTemp);
    }

    ReleaseDC(HWND_DESKTOP, hdcScreen);

    if (!g_hdcSrc || !g_hdcDst || !g_hbrMonoDither)
    {
        CImageList::GlobalUninit();
        TraceMsg(TF_ERROR, "ImageList: Unable to initialize");
        return FALSE;
    }
    return TRUE;
}

void CImageList::GlobalUninit()
{
    TerminateDitherBrush();

    if (g_hbrStripe)
    {
        DeleteObject(g_hbrStripe);
        g_hbrStripe = NULL;
    }

    ImageList_DeleteDragBitmaps();

    if (g_hdcDst)
    {
        CImageList::SelectDstBitmap(NULL);
        DeleteDC(g_hdcDst);
        g_hdcDst = NULL;
    }

    if (g_hdcSrc)
    {
        CImageList::SelectSrcBitmap(NULL);
        DeleteDC(g_hdcSrc);
        g_hdcSrc = NULL;
    }

    if (g_hbmWork)
    {
        DeleteBitmap(g_hbmWork);
        g_hbmWork = NULL;
    }
}

void CImageList::SelectDstBitmap(HBITMAP hbmDst)
{
    ASSERTCRITICAL;

    if (hbmDst != g_hbmDst)
    {
        // If it's selected in the source DC, then deselect it first
        //
        if (hbmDst && hbmDst == g_hbmSrc)
            CImageList::SelectSrcBitmap(NULL);

        SelectBitmap(g_hdcDst, hbmDst ? hbmDst : g_hbmDcDeselect);
        g_hbmDst = hbmDst;
    }
}

void CImageList::SelectSrcBitmap(HBITMAP hbmSrc)
{
    ASSERTCRITICAL;

    if (hbmSrc != g_hbmSrc)
    {
        // If it's selected in the dest DC, then deselect it first
        //
        if (hbmSrc && hbmSrc == g_hbmDst)
            CImageList::SelectDstBitmap(NULL);

        SelectBitmap(g_hdcSrc, hbmSrc ? hbmSrc : g_hbmDcDeselect);
        g_hbmSrc = hbmSrc;
    }
}

HDC ImageList_GetWorkDC(HDC hdc, BOOL f32bpp, int dx, int dy)
{
    ASSERTCRITICAL;
    int iDepth = GetDeviceCaps(hdc, BITSPIXEL);

    if (g_hbmWork == NULL ||
        iDepth != g_bmWork.bmBitsPixel ||
        g_bmWork.bmWidth  != dx || 
        g_bmWork.bmHeight != dy ||
        (f32bpp && iDepth != 32))
    {
        CImageList::_DeleteBitmap(g_hbmWork);
        g_hbmWork = NULL;

        if (dx == 0 || dy == 0)
            return NULL;

        if (f32bpp)
            g_hbmWork = CreateDIB(hdc, dx, dy, NULL);
        else
            g_hbmWork = CreateCompatibleBitmap(hdc, dx, dy);

        if (g_hbmWork)
        {
            GetObject(g_hbmWork, sizeof(g_bmWork), &g_bmWork);
        }
    }

    CImageList::SelectSrcBitmap(g_hbmWork);

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        HPALETTE hpal = (HPALETTE)SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
        SelectPalette(g_hdcSrc, hpal, TRUE);
    }

    return g_hdcSrc;
}

void ImageList_ReleaseWorkDC(HDC hdc)
{
    ASSERTCRITICAL;
    ASSERT(hdc == g_hdcSrc);

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
    }
}

void CImageList::_DeleteBitmap(HBITMAP hbm)
{
    ASSERTCRITICAL;
    if (hbm)
    {
        if (g_hbmDst == hbm)
            CImageList::SelectDstBitmap(NULL);
        if (g_hbmSrc == hbm)
            CImageList::SelectSrcBitmap(NULL);
        DeleteBitmap(hbm);
    }
}


#define ILC_WIN95   (ILC_MASK | ILC_COLORMASK | ILC_SHARED | ILC_PALETTE)


//============================================================================

HRESULT CImageList::InitGlobals()
{
    HRESULT hr = S_OK;
    ENTERCRITICAL;
    if (!g_iILRefCount)
    {
        if (!CImageList::GlobalInit())
        {
            hr = E_OUTOFMEMORY;
        }
    }
    LEAVECRITICAL;

    return S_OK;
}

CImageList* CImageList::Create(int cx, int cy, UINT flags, int cInitial, int cGrow)
{
    CImageList* piml = NULL;
    HRESULT hr = S_OK;

    if (cx < 0 || cy < 0)
        return NULL;

    // Validate the flags
    if (flags & ~ILC_VALID)
        return NULL;

    hr = InitGlobals();


    ENTERCRITICAL;

    if (SUCCEEDED(hr))
    {
        piml = new CImageList();

        // allocate the bitmap PLUS one re-usable entry
        if (piml)
        {
            hr = piml->Initialize(cx, cy, flags, cInitial, cGrow);
            if (FAILED(hr))
            {
                piml->Release();
                piml = NULL;
            }
        }
    }

    LEAVECRITICAL;

    return piml;
}



void CImageList::_Destroy()
{
    ENTERCRITICAL;
    // nuke dc's
    if (_hdcImage)
    {
        SelectObject(_hdcImage, g_hbmDcDeselect);
        DeleteDC(_hdcImage);
    }
    if (_hdcMask)
    {
        SelectObject(_hdcMask, g_hbmDcDeselect);
        DeleteDC(_hdcMask);
    }

    // nuke bitmaps
    if (_hbmImage)
        _DeleteBitmap(_hbmImage);

    if (_hbmMask)
        _DeleteBitmap(_hbmMask);

    if (_hbrBk)
        DeleteObject(_hbrBk);

    //Clean up DSA
    if (_dsaFlags)
        DSA_Destroy(_dsaFlags);

    if (_fInitialized)
    {
        // one less use of imagelists.  if it's the last, terminate the imagelist
        g_iILRefCount--;
        if (!g_iILRefCount)
            CImageList::GlobalUninit();
    }
    LEAVECRITICAL;
}

HRESULT CImageList::GetImageCount(int* pi)
{
    *pi = _cImage;

    return S_OK;
}

HRESULT CImageList::SetImageCount(UINT uAlloc)
{
    ENTERCRITICAL;
    HRESULT hr = _ReAllocBitmaps(-((int)uAlloc + 2));   // Two because we need a spare image
    if (SUCCEEDED(hr))
    {
        _cImage = (int)uAlloc;
    }
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::GetIconSize(int* pcx, int* pcy)
{
    if (!pcx || !pcy)
        return E_INVALIDARG;

    *pcx = _cx;
    *pcy = _cy;

    return S_OK;
}

//
//  change the size of a existing image list
//  also removes all items
//
HRESULT CImageList::_SetIconSize(int cxImage, int cyImage)
{
    if (_cx == cxImage && _cy == cyImage)
        return S_FALSE;       // no change

    if (_cx < 0 || _cy < 0)
        return E_INVALIDARG;       // invalid dimensions

    _cx = cxImage;
    _cy = cyImage;

    return Remove(-1);
}

HRESULT CImageList::SetIconSize(int cxImage, int cyImage)
{
   if (_pimlMirror)
   {
       _pimlMirror->_SetIconSize(cxImage, cyImage);
   }

   return _SetIconSize(cxImage, cyImage);
}

//
//  ImageList_SetFlags
//
//  change the image list flags, then rebuilds the bitmaps.
//
//  the only reason to call this function is to change the
//  color depth of the image list, the shell needs to do this
//  when the screen depth changes and it wants to use HiColor icons.
//
HRESULT CImageList::SetFlags(UINT uFlags)
{
    HBITMAP hOldImage;
    // check for valid input flags
    if (uFlags & ~ILC_VALID)
        return E_INVALIDARG;

    // you cant change these flags.
    if ((uFlags ^ _flags) & ILC_SHARED)
        return E_INVALIDARG;

   if (_pimlMirror)
       _pimlMirror->SetFlags(uFlags);

    // now change the flags and rebuild the bitmaps.
    _flags = uFlags;

    // set the old bitmap to NULL, so when Imagelist_remove calls
    // ImageList_createBitmap, it will not call CreatecomptibleBitmap,
    // it will create the spec for the bitmap from scratch..
    hOldImage = _hbmImage;
    _hbmImage = NULL;
    
    Remove(-1);

    // imagelist::remove will have ensured that the old image is no longer selected
    // thus we can now delete it...
    if ( hOldImage )
        DeleteObject( hOldImage );
        
    return S_OK;
}

HRESULT CImageList::GetFlags(UINT* puFlags)
{
    *puFlags = (_flags & ILC_VALID) | (_pimlMirror ? ILC_MIRROR : 0);

    return S_OK;
}

// reset the background color of images iFirst through iLast

void CImageList::_ResetBkColor(int iFirst, int iLast, COLORREF clr)
{
    HBRUSH hbrT=NULL;
    DWORD  rop;

    if (_hdcMask == NULL)
        return;

    if (clr == CLR_BLACK || clr == CLR_NONE)
    {
        rop = ROP_DSna;
    }
    else if (clr == CLR_WHITE)
    {
        rop = ROP_DSo;
    }
    else
    {
        ASSERT(_hbrBk);
        ASSERT(_clrBk == clr);

        rop = ROP_PatMask;
        hbrT = SelectBrush(_hdcImage, _hbrBk);
    }

    for ( ;iFirst <= iLast; iFirst++)
    {
        RECT rc;

        GetImageRect(iFirst, &rc);
        if (_GetItemFlags(iFirst) == 0)
        {
            BitBlt(_hdcImage, rc.left, rc.top, _cx, _cy,
               _hdcMask, rc.left, rc.top, rop);
        }
    }

    if (hbrT)
        SelectBrush(_hdcImage, hbrT);
}

//
//  GetNearestColor is problematic.  If you have a 32-bit HDC with a 16-bit bitmap
//  selected into it, and you call GetNearestColor, GDI ignores the
//  color-depth of the bitmap and thinks you have a 32-bit bitmap inside,
//  so of course it returns the same color unchanged.
//
//  So instead, we have to emulate GetNearestColor with SetPixel.
//
COLORREF GetNearestColor32(HDC hdc, COLORREF rgb)
{
    COLORREF rgbT;

    rgbT = GetPixel(hdc, 0, 0);
    rgb = SetPixel(hdc, 0, 0, rgb);
    SetPixelV(hdc, 0, 0, rgbT);

    return rgb;
}

COLORREF CImageList::_SetBkColor(COLORREF clrBkI)
{
    COLORREF clrBkOld;

    // Quick out if there is no change in color
    if (_clrBk == clrBkI)
    {
        return _clrBk;
    }

    // The following code deletes the brush, resets the background color etc.,
    // so, protect it with a critical section.
    ENTERCRITICAL;
    
    if (_hbrBk)
    {
        DeleteBrush(_hbrBk);
    }

    clrBkOld = _clrBk;
    _clrBk = clrBkI;

    if (_clrBk == CLR_NONE)
    {
        _hbrBk = (HBRUSH)GetStockObject(BLACK_BRUSH);
        _fSolidBk = TRUE;
    }
    else
    {
        _hbrBk = CreateSolidBrush(_clrBk);
        _fSolidBk = GetNearestColor32(_hdcImage, _clrBk) == _clrBk;
    }

    if (_cImage > 0)
    {
        _ResetBkColor(0, _cImage - 1, _clrBk);
    }

    LEAVECRITICAL;
    
    return clrBkOld;
}

HRESULT CImageList::SetBkColor(COLORREF clrBk, COLORREF* pclr)
{
   if (_pimlMirror)
   {
       _pimlMirror->_SetBkColor(clrBk);
   }    

   *pclr = _SetBkColor(clrBk);
   return S_OK;
}

HRESULT CImageList::GetBkColor(COLORREF* pclr)
{
    *pclr = _clrBk;
    return S_OK;
}

HRESULT CImageList::_ReAllocBitmaps(int cAllocI)
{
    HBITMAP hbmImageNew = NULL;
    HBITMAP hbmMaskNew = NULL;
    RGBQUAD* pargbImageNew = NULL;
    int cxL, cyL;

    // HACK: don't shrink unless the caller passes a negative count
    if (cAllocI > 0)
    {
        if (_cAlloc >= cAllocI)
            return S_OK;
    }
    else
        cAllocI *= -1;


    cxL = _cx * _cStrip;
    cyL = _cy * ((cAllocI + _cStrip - 1) / _cStrip);
    if (cAllocI > 0)
    {
        if (_flags & ILC_MASK)
        {
            hbmMaskNew = CreateMonoBitmap(cxL, cyL);
            if (!hbmMaskNew)
            {
                TraceMsg(TF_ERROR, "ImageList: Can't create bitmap");
                return E_OUTOFMEMORY;
            }
        }
        hbmImageNew = _CreateBitmap(cxL, cyL, &pargbImageNew);
        if (!hbmImageNew)
        {
            if (hbmMaskNew)
                CImageList::_DeleteBitmap(hbmMaskNew);
            TraceMsg(TF_ERROR, "ImageList: Can't create bitmap");
            return E_OUTOFMEMORY;
        }

        if (_dsaFlags == NULL)
            _dsaFlags = DSA_Create(sizeof(DWORD), _cGrow);

        if (!_dsaFlags)
        {
            if (hbmMaskNew)
                CImageList::_DeleteBitmap(hbmMaskNew);
            if (hbmImageNew)
                CImageList::_DeleteBitmap(hbmImageNew);
            TraceMsg(TF_ERROR, "ImageList: Can't create flags array");
            return E_OUTOFMEMORY;

        }
    }

    if (_cImage > 0)
    {
        int cyCopy = _cy * ((min(cAllocI, _cImage) + _cStrip - 1) / _cStrip);

        if (_flags & ILC_MASK)
        {
            CImageList::SelectDstBitmap(hbmMaskNew);
            BitBlt(g_hdcDst, 0, 0, cxL, cyCopy, _hdcMask, 0, 0, SRCCOPY);
        }

        CImageList::SelectDstBitmap(hbmImageNew);
        BitBlt(g_hdcDst, 0, 0, cxL, cyCopy, _hdcImage, 0, 0, SRCCOPY);
    }

    // select into DC's, delete then assign
    CImageList::SelectDstBitmap(NULL);
    CImageList::SelectSrcBitmap(NULL);
    SelectObject(_hdcImage, hbmImageNew);

    if (_hdcMask)
        SelectObject(_hdcMask, hbmMaskNew);

    if (_hbmMask)
        CImageList::_DeleteBitmap(_hbmMask);

    if (_hbmImage)
        CImageList::_DeleteBitmap(_hbmImage);

    _hbmMask = hbmMaskNew;
    _hbmImage = hbmImageNew;
    _pargbImage = pargbImageNew;
    _clrBlend = CLR_NONE;

    _cAlloc = cAllocI;

    return S_OK;
}

HBITMAP CImageList::_CreateMirroredBitmap(HBITMAP hbmOrig, BOOL fMirrorEach, int cx)
{
    HBITMAP hbm = NULL, hOld_bm1, hOld_bm2;
    BITMAP  bm;

    if (!hbmOrig)
        return NULL;

    if (!GetObject(hbmOrig, sizeof(BITMAP), &bm))
        return NULL;

    // Grab the screen DC
    HDC hdc = GetDC(NULL);

    HDC hdcMem1 = CreateCompatibleDC(hdc);

    if (!hdcMem1)
    {
        ReleaseDC(NULL, hdc);
        return NULL;
    }
    
    HDC hdcMem2 = CreateCompatibleDC(hdc);
    if (!hdcMem2)
    {
        DeleteDC(hdcMem1);
        ReleaseDC(NULL, hdc);
        return NULL;
    }

    if (bm.bmBitsPixel == 32)
    {
        void* p;
        BITMAPINFO bi = {sizeof(BITMAPINFOHEADER), bm.bmWidth, bm.bmHeight, 1, 32};
        hbm = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, &p, NULL, 0);
    }
    else
    {
        hbm = CreateColorBitmap(bm.bmWidth, bm.bmHeight);
    }

    if (!hbm)
    {
        DeleteDC(hdcMem2);
        DeleteDC(hdcMem1);        
        ReleaseDC(NULL, hdc);
        return NULL;
    }

    //
    // Flip the bitmap
    //
    hOld_bm1 = (HBITMAP)SelectObject(hdcMem1, hbmOrig);
    hOld_bm2 = (HBITMAP)SelectObject(hdcMem2 , hbm );

    SET_DC_RTL_MIRRORED(hdcMem2);

    if (fMirrorEach)
    {
        for (int i = 0; i < bm.bmWidth; i += cx)        // Flip the bits in the imagelist...
        {
            BitBlt(hdcMem2, bm.bmWidth - i - cx, 0, cx, bm.bmHeight, hdcMem1, i, 0, SRCCOPY);
        }
    }
    else
    {
        BitBlt(hdcMem2, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCCOPY);
    }

    SelectObject(hdcMem1, hOld_bm1 );
    SelectObject(hdcMem1, hOld_bm2 );
    
    DeleteDC(hdcMem2);
    DeleteDC(hdcMem1);
    ReleaseDC(NULL, hdc);

    return hbm;
}

HRESULT CImageList::SetColorTable(int start, int len, RGBQUAD *prgb, int* pi)
{
    // mark it that we have set the color table so that it won't be overwritten 
    // by the first bitmap add....
    _fColorsSet = TRUE;
    if (_hdcImage)
    {
        *pi = SetDIBColorTable(_hdcImage, start, len, prgb);

        return S_OK;
    }

    return E_FAIL;
}


BOOL CImageList::_HasAlpha(int i)
{
    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        RECT rc;
        if (SUCCEEDED(GetImageRectInverted(i, &rc)))
        {
            for (int y = rc.top; y < rc.bottom; y++)
            {
                for (int x = rc.left; x < rc.right; x++)
                {
                    if (_pargbImage[x + y * _cx].rgbReserved != 0)
                        return TRUE;
                }
            }
        }
    }

    return FALSE;
}

void CImageList::_ScanForAlpha()
{
    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        for (int i = 0; i < _cImage; i++)
        {
            SetItemFlags(i, _HasAlpha(i)? ILIF_ALPHA : 0);
        }
    }
}


BOOL CImageList::_PreProcessImage(int i)
{
    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        RECT rc;
        GetImageRectInverted(i, &rc);

#ifdef _X86_ 
        if (IsProcessorFeaturePresent(PF_MMX_INSTRUCTIONS_AVAILABLE))
        {
            _asm
            {
                pxor mm0, mm0
                pxor mm1, mm1
                pxor mm5, mm5
                movq mm6, qw128                 // mm6 is filled with 128
                movq mm7, qw1                   // mm7 is filled with 1
            }

            for (int y = rc.top; y < rc.bottom; y++)
            {
                int Offset = y * _cx;
                RGBQUAD* prgb = &_pargbImage[rc.left + Offset];
                for (int x = rc.left; x < rc.right; x++)
                {
                    _asm
                    {
                        push ecx
                        mov edx, dword ptr [prgb]                     // Read alpha channel
                        mov ecx, dword ptr [edx]
                        mov ebx, ecx
                        shr ebx, 24                     // a >> 24
                        mov eax, ebx                    // a -> b
                        or eax, eax
                        jz EarlyOut
                        shl ebx, 8                      // b << 8
                        or eax, ebx                     // a |= b
                        shl ebx, 8                      // b << 8
                        or eax, ebx                     // a |= b
                        shl ebx, 8                      // b << 8
                                                        // Note high byte of alpha is zero.
                        movd mm0, eax                   //  a -> mm0        
                            movd mm1, ecx                    // Load the pixel
                        punpcklbw mm0,mm5               //  mm0 -> Expands  <-   mm0 Contains the Alpha channel for this multiply

                            punpcklbw mm1,mm5               // Unpack the pixel
                        pmullw mm1, mm0                 // Multiply by the alpha channel <- mm1 contains c * alpha

                        paddusw mm1, mm6                 // perform the (c * alpha) + 128
                        psrlw mm1, 8                    // Divide by 255
                        paddusw mm1, mm7                 // Add 1 to finish the divide by 255
                        packuswb mm1, mm5

                        movd eax, mm1
                        or eax, ebx                     // Transfer alpha channel
                    EarlyOut:
                        mov dword ptr [edx], eax
                        pop ecx
                    }

                    prgb++;
                }
            }

            _asm emms
        }
        else
#endif
        {
            for (int y = rc.top; y < rc.bottom; y++)
            {
                int Offset = y * _cx;
                for (int x = rc.left; x < rc.right; x++)
                {
                    RGBQUAD* prgb = &_pargbImage[x + Offset];
                    if (prgb->rgbReserved)
                    {
                        prgb->rgbRed      = ((prgb->rgbRed   * prgb->rgbReserved) + 128) / 255;
                        prgb->rgbGreen    = ((prgb->rgbGreen * prgb->rgbReserved) + 128) / 255;
                        prgb->rgbBlue     = ((prgb->rgbBlue  * prgb->rgbReserved) + 128) / 255;
                    }
                    else
                    {
                        *((DWORD*)prgb) = 0;
                    }
                }
            }
        }
        return TRUE;
    }

    return FALSE;
}


HRESULT CImageList::_Add(HBITMAP hbmImageI, HBITMAP hbmMaskI, int cImageI, int xStart, int yStart, int* pi)
{
    int i = -1;
    HRESULT hr = S_OK;

    ENTERCRITICAL;

    //
    // if the ImageList is empty clone the color table of the first
    // bitmap you add to the imagelist.
    //
    // the ImageList needs to be a 8bpp image list
    // the bitmap being added needs to be a 8bpp DIBSection
    //
    if (hbmImageI && _cImage == 0 &&
        (_flags & ILC_COLORMASK) != ILC_COLORDDB)
    {
        if (!_fColorsSet)
        {
            int n;
            RGBQUAD argb[256];

            CImageList::SelectDstBitmap(hbmImageI);

            if (n = GetDIBColorTable(g_hdcDst, 0, 256, argb))
            {
                int i;
                SetColorTable(0, n, argb, &i);
            }

            CImageList::SelectDstBitmap(NULL);
        }
        
        _clrBlend = CLR_NONE;
    }

    if (_cImage + cImageI + 1 > _cAlloc)
    {
        hr = _ReAllocBitmaps(_cAlloc + max(cImageI, _cGrow) + 1);
    }

    if (SUCCEEDED(hr))
    {
        i = _cImage;
        _cImage += cImageI;

        if (hbmImageI)
        {
            hr = _Replace(i, cImageI, hbmImageI, hbmMaskI, xStart, yStart);

            if (FAILED(hr))
            {
                _cImage -= cImageI;
                i = -1;
            }
        }
    }

    LEAVECRITICAL;
    *pi = i;

    return hr;
}


HRESULT CImageList::_AddValidated(HBITMAP hbmImage, HBITMAP hbmMask, int* pi)
{
    BITMAP bm;
    int cImageI;

    if (GetObject(hbmImage, sizeof(bm), &bm) != sizeof(bm) || bm.bmWidth < _cx)
    {
        return E_INVALIDARG;
    }

    ASSERT(hbmImage);
    ASSERT(_cx);

    cImageI = bm.bmWidth / _cx;     // # of images in source

    // serialization handled within Add2.
    return  _Add(hbmImage, hbmMask, cImageI, 0, 0, pi);
}

HRESULT CImageList::Add(HBITMAP hbmImage, HBITMAP hbmMask, int* pi)
{
   if (_pimlMirror)
   {
       HBITMAP hbmMirroredImage = _CreateMirroredBitmap(hbmImage, (ILC_PERITEMMIRROR & _flags), _cx);
       HBITMAP hbmMirroredMask = _CreateMirroredBitmap(hbmMask, (ILC_PERITEMMIRROR & _flags), _cx);

       _pimlMirror->_AddValidated(hbmMirroredImage, hbmMirroredMask, pi);

       // The caller will take care of deleting hbmImage, hbmMask
       // He knows nothing about hbmMirroredImage, hbmMirroredMask
       DeleteObject(hbmMirroredImage);
       DeleteObject(hbmMirroredMask);
   }    

   return _AddValidated(hbmImage, hbmMask, pi);
}

HRESULT CImageList::_AddMasked(HBITMAP hbmImageI, COLORREF crMask, int* pi)
{
    HRESULT hr = S_OK;
    COLORREF crbO, crtO;
    HBITMAP hbmMaskI;
    int cImageI;
    int n,i;
    BITMAP bm;
    DWORD ColorTableSave[256];
    DWORD ColorTable[256];

    *pi = -1;

    if (GetObject(hbmImageI, sizeof(bm), &bm) != sizeof(bm))
        return E_INVALIDARG;

    hbmMaskI = CreateMonoBitmap(bm.bmWidth, bm.bmHeight);
    if (!hbmMaskI)
        return E_OUTOFMEMORY;

    ENTERCRITICAL;

    // copy color to mono, with crMask turning 1 and all others 0, then
    // punch all crMask pixels in color to 0
    CImageList::SelectSrcBitmap(hbmImageI);
    CImageList::SelectDstBitmap(hbmMaskI);

    // crMask == CLR_DEFAULT, means use the pixel in the upper left
    //
    if (crMask == CLR_DEFAULT)
        crMask = GetPixel(g_hdcSrc, 0, 0);

    // DIBSections dont do color->mono like DDBs do, so we have to do it.
    // this only works for <=8bpp DIBSections, this method does not work
    // for HiColor DIBSections.
    //
    // This code is a workaround for a problem in Win32 when a DIB is converted to 
    // monochrome. The conversion is done according to closeness to white or black
    // and without regard to the background color. This workaround is is not required 
    // under MainWin. 
    //
    // Please note, this code has an endianship problems the comparision in the if statement
    // below is sensitive to endianship
    // ----> if (ColorTableSave[i] == RGB(GetBValue(crMask),GetGValue(crMask),GetRValue(crMask))
    //
    if (bm.bmBits != NULL && bm.bmBitsPixel <= 8)
    {
        n = GetDIBColorTable(g_hdcSrc, 0, 256, (RGBQUAD*)ColorTableSave);

        for (i=0; i<n; i++)
        {
            if (ColorTableSave[i] == RGB(GetBValue(crMask),GetGValue(crMask),GetRValue(crMask)))
                ColorTable[i] = 0x00FFFFFF;
            else
                ColorTable[i] = 0x00000000;
        }

        SetDIBColorTable(g_hdcSrc, 0, n, (RGBQUAD*)ColorTable);
    }

    crbO = ::SetBkColor(g_hdcSrc, crMask);
    BitBlt(g_hdcDst, 0, 0, bm.bmWidth, bm.bmHeight, g_hdcSrc, 0, 0, SRCCOPY);
    ::SetBkColor(g_hdcSrc, 0x00FFFFFFL);
    crtO = SetTextColor(g_hdcSrc, 0x00L);
    BitBlt(g_hdcSrc, 0, 0, bm.bmWidth, bm.bmHeight, g_hdcDst, 0, 0, ROP_DSna);
    ::SetBkColor(g_hdcSrc, crbO);
    SetTextColor(g_hdcSrc, crtO);

    if (bm.bmBits != NULL && bm.bmBitsPixel <= 8)
    {
        SetDIBColorTable(g_hdcSrc, 0, n, (RGBQUAD*)ColorTableSave);
    }

    CImageList::SelectSrcBitmap(NULL);
    CImageList::SelectDstBitmap(NULL);

    ASSERT(_cx);
    cImageI = bm.bmWidth / _cx;    // # of images in source

    hr = _Add(hbmImageI, hbmMaskI, cImageI, 0, 0, pi);

    DeleteObject(hbmMaskI);
    LEAVECRITICAL;
    return hr;
}

HRESULT CImageList::AddMasked(HBITMAP hbmImage, COLORREF crMask, int* pi)
{
   if (_pimlMirror)
   {
       HBITMAP hbmMirroredImage = CImageList::_CreateMirroredBitmap(hbmImage, (ILC_PERITEMMIRROR & _flags), _cx);

       _pimlMirror->_AddMasked(hbmMirroredImage, crMask, pi);

       // The caller will take care of deleting hbmImage
       // He knows nothing about hbmMirroredImage
       DeleteObject(hbmMirroredImage);

   }    

   return _AddMasked(hbmImage, crMask, pi);
}

HRESULT CImageList::_ReplaceValidated(int i, HBITMAP hbmImage, HBITMAP hbmMask)
{
    HRESULT hr = E_INVALIDARG;
    if (!IsImageListIndex(i))
        return hr;

    ENTERCRITICAL;
    hr = _Replace(i, 1, hbmImage, hbmMask, 0, 0);
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::Replace(int i, HBITMAP hbmImage, HBITMAP hbmMask)
{
   if (_pimlMirror)
   {
       HBITMAP hbmMirroredImage = CImageList::_CreateMirroredBitmap(hbmImage, (ILC_PERITEMMIRROR & _flags), _cx);
       if (hbmMirroredImage)
       {
           HBITMAP hbmMirroredMask = NULL;
           
           if (hbmMask)
               hbmMirroredMask = CImageList::_CreateMirroredBitmap(hbmMask, (ILC_PERITEMMIRROR & _flags), _cx);

           _pimlMirror->_ReplaceValidated(i, hbmMirroredImage, hbmMirroredMask);

           if (hbmMirroredMask)
               DeleteObject(hbmMirroredMask);

           DeleteObject(hbmMirroredImage);
       }
   }    

   return _ReplaceValidated(i, hbmImage, hbmMask);
}


// replaces images in piml with images from bitmaps
//
// in:
//    piml
//    i    index in image list to start at (replace)
//    _cImage    count of images in source (hbmImage, hbmMask)
//

HRESULT CImageList::_Replace(int i, int cImageI, HBITMAP hbmImageI, HBITMAP hbmMaskI,
    int xStart, int yStart)
{
    RECT rcImage;
    int x, iImage;
    BOOL fBitmapIs32 = FALSE;

    ASSERT(_hbmImage);

    BITMAP bm;
    GetObject(hbmImageI, sizeof(bm), &bm);
    if (bm.bmBitsPixel == 32)
    {
        fBitmapIs32 = TRUE;
    }

    CImageList::SelectSrcBitmap(hbmImageI);
    if (_hdcMask) 
        CImageList::SelectDstBitmap(hbmMaskI); // using as just a second source hdc

    for (x = xStart, iImage = 0; iImage < cImageI; iImage++, x += _cx) 
    {
    
        GetImageRect(i + iImage, &rcImage);

        if (_hdcMask)
        {
            BitBlt(_hdcMask, rcImage.left, rcImage.top, _cx, _cy,
                    g_hdcDst, x, yStart, SRCCOPY);
        }

        BitBlt(_hdcImage, rcImage.left, rcImage.top, _cx, _cy,
                g_hdcSrc, x, yStart, SRCCOPY);

        if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
        {
            DWORD dw = 0;
            if (fBitmapIs32)
            {
                BOOL fHasAlpha = _HasAlpha(i + iImage);
                if (fHasAlpha)
                {
                    dw = ILIF_ALPHA;

                    _PreProcessImage(i + iImage);
                }
            }

            SetItemFlags(i + iImage, dw);
        }
    }

    _ResetBkColor(i, i + cImageI - 1, _clrBk);

    CImageList::SelectSrcBitmap(NULL);
    if (_hdcMask) 
        CImageList::SelectDstBitmap(NULL);

    return S_OK;
}

void UnPremultiply(RGBQUAD* pargb, int cx, int cy)
{
    int cTotal = cx * cy;
    for (int i = 0; i < cTotal; i++)
    {
        RGBQUAD* prgb = &pargb[i];
        if (prgb->rgbReserved != 0)
        {
            prgb->rgbRed = ((255 * prgb->rgbRed) - 128)/prgb->rgbReserved;
            prgb->rgbGreen = ((255 * prgb->rgbGreen) - 128)/prgb->rgbReserved;
            prgb->rgbBlue = ((255 * prgb->rgbBlue) - 128)/prgb->rgbReserved;
        }
    }
}

HRESULT CImageList::GetIcon(int i, UINT flags, HICON* phicon)
{
    UINT cxImage, cyImage;
    HICON hIcon = NULL;
    HBITMAP hbmMask = NULL;
    HBITMAP hbmColor = NULL;
    ICONINFO ii;
    HRESULT hr = E_OUTOFMEMORY;
    RGBQUAD* prgb;
    DWORD fHasAlpha = FALSE;

    ENTERCRITICAL;
    if (!IsImageListIndex(i))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        fHasAlpha = (_GetItemFlags(i) & ILIF_ALPHA);
    }
    LEAVECRITICAL;

    if (E_INVALIDARG == hr)
        return hr;

    cxImage = _cx;
    cyImage = _cy;
    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        // If the source image is not an alpha image, we need to create a lower than 32bpp dib.
        // We need to do this because if the overlay contains an alpha channel, this will
        // be propogated to the final icon, and the only visible portion will be the link item.
        BITMAPINFO bi = {0};
        bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
        bi.bmiHeader.biWidth = cxImage;
        bi.bmiHeader.biHeight = cyImage;
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biBitCount = fHasAlpha?32:24;
        bi.bmiHeader.biCompression = BI_RGB;

        HDC hdcScreen = GetDC(NULL);
        if (hdcScreen)
        {
            hbmColor = CreateDIBSection(hdcScreen, &bi, DIB_RGB_COLORS, (void**)&prgb, NULL, 0);
            ReleaseDC(NULL, hdcScreen);
        }

        flags |= ILD_PRESERVEALPHA;
    }
    else
    {
        fHasAlpha = FALSE;
        hbmColor = CreateColorBitmap(cxImage, cyImage);
    }

    if (hbmColor)
    {
        hbmMask = CreateMonoBitmap(cxImage, cyImage);
        if (hbmMask)
        {
            ENTERCRITICAL;
            CImageList::SelectDstBitmap(hbmMask);
            PatBlt(g_hdcDst, 0, 0, cxImage, cyImage, WHITENESS);
            WimpyDraw(SAFECAST(this, IImageList*), i, g_hdcDst, 0, 0, ILD_MASK | flags);

            CImageList::SelectDstBitmap(hbmColor);
            PatBlt(g_hdcDst, 0, 0, cxImage, cyImage, BLACKNESS);
            WimpyDraw(SAFECAST(this, IImageList*), i, g_hdcDst, 0, 0, ILD_TRANSPARENT | flags);

            CImageList::SelectDstBitmap(NULL);
            LEAVECRITICAL;

            if (fHasAlpha)
            {
                UnPremultiply(prgb, _cx, _cy);
            }

            ii.fIcon    = TRUE;
            ii.xHotspot = 0;
            ii.yHotspot = 0;
            ii.hbmColor = hbmColor;
            ii.hbmMask  = hbmMask;
            hIcon = CreateIconIndirect(&ii);
            DeleteObject(hbmMask);

            hr = S_OK;
        }
        DeleteObject(hbmColor);
    }
    *phicon = hIcon;

    return hr;
}

// this removes an image from the bitmap but doing all the
// proper shuffling.
//
//   this does the following:
//    if the bitmap being removed is not the last in the row
//        it blts the images to the right of the one being deleted
//        to the location of the one being deleted (covering it up)
//
//    for all rows until the last row (where the last image is)
//        move the image from the next row up to the last position
//        in the current row.  then slide over all images in that
//        row to the left.

void CImageList::_RemoveItemBitmap(int i)
{
    RECT rc1;
    RECT rc2;
    int dx, y;
    int x;
    
    GetImageRect(i, &rc1);
    GetImageRect(_cImage - 1, &rc2);

    if (i < _cImage && 
        (_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        DSA_DeleteItem(_dsaFlags, i);
    }

    SetItemFlags(_cImage, 0);


    // the row with the image being deleted, do we need to shuffle?
    // amount of stuff to shuffle
    dx = _cStrip * _cx - rc1.right;

    if (dx) 
    {
        // yes, shuffle things left
        BitBlt(_hdcImage, rc1.left, rc1.top, dx, _cy, _hdcImage, rc1.right, rc1.top, SRCCOPY);
        if (_hdcMask)  
            BitBlt(_hdcMask,  rc1.left, rc1.top, dx, _cy, _hdcMask,  rc1.right, rc1.top, SRCCOPY);
    }

    y = rc1.top;    // top of row we are working on
    x = _cx * (_cStrip - 1); // x coord of last bitmaps in each row
    while (y < rc2.top) 
    {
    
        // copy first from row below to last image position on this row
        BitBlt(_hdcImage, x, y,
                   _cx, _cy, _hdcImage, 0, y + _cy, SRCCOPY);

            if (_hdcMask)
                BitBlt(_hdcMask, x, y,
                   _cx, _cy, _hdcMask, 0, y + _cy, SRCCOPY);

        y += _cy;    // jump to row to slide left

        if (y <= rc2.top) 
        {

            // slide the rest over to the left
            BitBlt(_hdcImage, 0, y, x, _cy,
                       _hdcImage, _cx, y, SRCCOPY);

            // slide the rest over to the left
            if (_hdcMask)
            {
                BitBlt(_hdcMask, 0, y, x, _cy,
                       _hdcMask, _cx, y, SRCCOPY);
            }
        }
    }
}

//
//  ImageList_Remove - remove a image from the image list
//
//  i - image to remove, or -1 to remove all images.
//
//  NOTE all images are "shifted" down, ie all image index's
//  above the one deleted are changed by 1
//
HRESULT CImageList::_Remove(int i)
{
    HRESULT hr = S_OK;

    ENTERCRITICAL;

    if (i == -1)
    {
        _cImage = 0;
        _cAlloc = 0;

        for (i=0; i<NUM_OVERLAY_IMAGES; i++)
            _aOverlayIndexes[i] = -1;

        if (_dsaFlags)
        {
            DSA_Destroy(_dsaFlags);
            _dsaFlags = NULL;
        }

        _ReAllocBitmaps(-_cGrow);
    }
    else
    {
        if (!IsImageListIndex(i))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            _RemoveItemBitmap(i);

            --_cImage;

            if (_cAlloc - (_cImage + 1) > _cGrow)
                _ReAllocBitmaps(_cAlloc - _cGrow);
        }
    }
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::Remove(int i)
{
    if (_pimlMirror)
    {
        _pimlMirror->_Remove(i);
    }

    return _Remove(i);
}

BOOL CImageList::_IsSameObject(IUnknown* punk)
{
    BOOL fRet = FALSE;
    IUnknown* me;
    IUnknown* them;

    if (punk == NULL)
        return FALSE;

    QueryInterface(IID_PPV_ARG(IUnknown, &me));
    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IUnknown, &them))))
    {
        fRet = (me == them);
        them->Release();
    }

    me->Release();

    return fRet;
}

//
//  ImageList_Copy - move an image in the image list
//
HRESULT CImageList::Copy(int iDst, IUnknown* punkSrc, int iSrc, UINT uFlags)
{
    RECT rcDst, rcSrc, rcTmp;
    CImageList* pimlTmp;
    CImageList* pimlSrc;
    HRESULT hr = E_FAIL;

    if (uFlags & ~ILCF_VALID)
    {
        // don't let hosers pass bogus flags
        RIPMSG(0, "ImageList_Copy: Invalid flags %08x", uFlags);
        return E_INVALIDARG;
    }

    // Not supported 
    if (!_IsSameObject(punkSrc))
    {
        return E_INVALIDARG;
    }


    // We only support copies on ourself... Weird
    pimlSrc = this;

    ENTERCRITICAL;
    pimlTmp = (uFlags & ILCF_SWAP)? pimlSrc : NULL;

    if (SUCCEEDED(GetImageRect(iDst, &rcDst)) &&
        SUCCEEDED(pimlSrc->GetImageRect(iSrc, &rcSrc)) &&
        (!pimlTmp || pimlTmp->GetSpareImageRect(&rcTmp)))
    {
        int cx = pimlSrc->_cx;
        int cy = pimlSrc->_cy;

        //
        // iff we are swapping we need to save the destination image
        //
        if (pimlTmp)
        {
            BitBlt(pimlTmp->_hdcImage, rcTmp.left, rcTmp.top, cx, cy,
                   _hdcImage, rcDst.left, rcDst.top, SRCCOPY);

            if (pimlTmp->_hdcMask)
            {
                BitBlt(pimlTmp->_hdcMask, rcTmp.left, rcTmp.top, cx, cy,
                       _hdcMask, rcDst.left, rcDst.top, SRCCOPY);
            }
        }

        //
        // copy the image
        //
        BitBlt(_hdcImage, rcDst.left, rcDst.top, cx, cy,
           pimlSrc->_hdcImage, rcSrc.left, rcSrc.top, SRCCOPY);

        if (pimlSrc->_hdcMask)
        {
            BitBlt(_hdcMask, rcDst.left, rcDst.top, cx, cy,
                   pimlSrc->_hdcMask, rcSrc.left, rcSrc.top, SRCCOPY);
        }

        //
        // iff we are swapping we need to copy the saved image too
        //
        if (pimlTmp)
        {
            BitBlt(pimlSrc->_hdcImage, rcSrc.left, rcSrc.top, cx, cy,
                   pimlTmp->_hdcImage, rcTmp.left, rcTmp.top, SRCCOPY);

            if (pimlSrc->_hdcMask)
            {
                BitBlt(pimlSrc->_hdcMask, rcSrc.left, rcSrc.top, cx, cy,
                       pimlTmp->_hdcMask, rcTmp.left, rcTmp.top, SRCCOPY);
            }
        }

        hr = S_OK;
    }

    LEAVECRITICAL;
    return hr;
}

// IS_WHITE_PIXEL, BITS_ALL_WHITE are macros for looking at monochrome bits
// to determine if certain pixels are white or black.  Note that within a byte
// the most significant bit represents the left most pixel.
//
#define IS_WHITE_PIXEL(pj,x,y,cScan) \
    ((pj)[((y) * (cScan)) + ((x) >> 3)] & (1 << (7 - ((x) & 7))))

#define BITS_ALL_WHITE(b) (b == 0xff)

// Set the image iImage as one of the special images for us in combine
// drawing.  to draw with these specify the index of this
// in:
//      piml    imagelist
//      iImage  image index to use in speical drawing
//      iOverlay        index of special image, values 1-4

HRESULT CImageList::_SetOverlayImage(int iImage, int iOverlay)
{
    RECT    rcImage;
    RECT    rc;
    int     x,y;
    int     cxI,cyI;
    ULONG   cScan;
    ULONG   cBits;
    HBITMAP hbmMem;
    HRESULT hr = S_FALSE;

    iOverlay--;         // make zero based
    if (_hdcMask == NULL ||
        iImage < 0 || iImage >= _cImage ||
        iOverlay < 0 || iOverlay >= NUM_OVERLAY_IMAGES)
    {
        return E_INVALIDARG;
    }

    if (_aOverlayIndexes[iOverlay] == (SHORT)iImage)
        return S_OK;

    _aOverlayIndexes[iOverlay] = (SHORT)iImage;

    //
    // find minimal rect that bounds the image
    //
    GetImageRect(iImage, &rcImage);
    SetRect(&rc, 0x7FFF, 0x7FFF, 0, 0);

    //
    // now compute the black box.  This is much faster than GetPixel but
    // could still be improved by doing more operations looking at entire
    // bytes.  We basicaly get the bits in monochrome form and then use
    // a private GetPixel.  This decreased time on NT from 50 milliseconds to
    // 1 millisecond for a 32X32 image.
    //
    cxI     = rcImage.right  - rcImage.left;
    cyI     = rcImage.bottom - rcImage.top;

    // compute the number of bytes in a scan.  Note that they are WORD alligned
    cScan  = (((cxI + (sizeof(SHORT)*8 - 1)) / 16) * 2);
    cBits  = cScan * cyI;

    hbmMem = CreateMonoBitmap(cxI,cyI);

    if (hbmMem)
    {
        HDC     hdcMem = CreateCompatibleDC(_hdcMask);

        if (hdcMem)
        {
            PBYTE   pBits  = (PBYTE)LocalAlloc(LMEM_FIXED,cBits);
            PBYTE   pScan;

            if (pBits)
            {
                SelectObject(hdcMem,hbmMem);

                //
                // map black pixels to 0, white to 1
                //
                BitBlt(hdcMem, 0, 0, cxI, cyI, _hdcMask, rcImage.left, rcImage.top, SRCCOPY);

                //
                // fill in the bits
                //
                GetBitmapBits(hbmMem,cBits,pBits);

                //
                // for each scan, find the bounds
                //
                for (y = 0, pScan = pBits; y < cyI; ++y,pScan += cScan)
                {
                    int i;

                    //
                    // first go byte by byte through white space
                    //
                    for (x = 0, i = 0; (i < (cxI >> 3)) && BITS_ALL_WHITE(pScan[i]); ++i)
                    {
                        x += 8;
                    }

                    //
                    // now finish the scan bit by bit
                    //
                    for (; x < cxI; ++x)
                    {
                        if (!IS_WHITE_PIXEL(pBits, x,y,cScan))
                        {
                            rc.left   = min(rc.left, x);
                            rc.right  = max(rc.right, x+1);
                            rc.top    = min(rc.top, y);
                            rc.bottom = max(rc.bottom, y+1);

                            // now that we found one, quickly jump to the known right edge

                            if ((x >= rc.left) && (x < rc.right))
                            {
                                x = rc.right-1;
                            }
                        }
                    }
                }

                if (rc.left == 0x7FFF) 
                {
                    rc.left = 0;
                    TraceMsg(TF_ERROR, "SetOverlayImage: Invalid image. No white pixels specified");
                }

                if (rc.top == 0x7FFF) 
                {
                    rc.top = 0;
                    TraceMsg(TF_ERROR, "SetOverlayImage: Invalid image. No white pixels specified");
                }

                _aOverlayDX[iOverlay] = (SHORT)(rc.right - rc.left);
                _aOverlayDY[iOverlay] = (SHORT)(rc.bottom- rc.top);
                _aOverlayX[iOverlay]  = (SHORT)(rc.left);
                _aOverlayY[iOverlay]  = (SHORT)(rc.top);
                _aOverlayF[iOverlay]  = 0;

                //
                // see if the image is non-rectanglar
                //
                // if the overlay does not require a mask to be drawn set the
                // ILD_IMAGE flag, this causes ImageList_DrawEx to just
                // draw the image, ignoring the mask.
                //
                for (y=rc.top; y<rc.bottom; y++)
                {
                    for (x=rc.left; x<rc.right; x++)
                    {
                        if (IS_WHITE_PIXEL(pBits, x, y,cScan))
                            break;
                    }

                    if (x != rc.right)
                        break;
                }

                if (y == rc.bottom)
                    _aOverlayF[iOverlay] = ILD_IMAGE;

                LocalFree(pBits);

                hr = S_OK;
            }

            DeleteDC(hdcMem);
        }

        DeleteObject(hbmMem);
    }

    return hr;
}

HRESULT CImageList::SetOverlayImage(int iImage, int iOverlay)
{
    if (_pimlMirror)
    {
        _pimlMirror->_SetOverlayImage(iImage, iOverlay);
    }

    return _SetOverlayImage(iImage, iOverlay);
}

/*
**  BlendCT
**
*/
void CImageList::BlendCTHelper(DWORD *pdw, DWORD rgb, UINT n, UINT count)
{
    UINT i;

    for (i=0; i<count; i++)
    {
        pdw[i] = RGB(
            ((UINT)GetRValue(pdw[i]) * (100-n) + (UINT)GetBValue(rgb) * (n)) / 100,
            ((UINT)GetGValue(pdw[i]) * (100-n) + (UINT)GetGValue(rgb) * (n)) / 100,
            ((UINT)GetBValue(pdw[i]) * (100-n) + (UINT)GetRValue(rgb) * (n)) / 100);
    }
}

/*
** BlendDither
**
**  copy the source to the dest blended with the given color.
**
**  simulate a blend with a dither pattern.
**
*/
void CImageList::BlendDither(HDC hdcDst, int xDst, int yDst, int x, int y, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    HBRUSH hbr;
    HBRUSH hbrT;
    HBRUSH hbrMask;
    HBRUSH hbrFree = NULL;         // free if non-null

    ASSERT(GetTextColor(hdcDst) == CLR_BLACK);
    ASSERT(::GetBkColor(hdcDst) == CLR_WHITE);

    // choose a dither/blend brush

    switch (fStyle & ILD_BLENDMASK)
    {
        default:
        case ILD_BLEND50:
            hbrMask = g_hbrMonoDither;
            break;
    }

    // create (or use a existing) brush for the blend color

    switch (rgb)
    {
        case CLR_DEFAULT:
            hbr = g_hbrHighlight;
            break;

        case CLR_NONE:
            hbr = _hbrBk;
            break;

        default:
            if (rgb == _clrBk)
                hbr = _hbrBk;
            else
                hbr = hbrFree = CreateSolidBrush(rgb);
            break;
    }

    hbrT = (HBRUSH)SelectObject(hdcDst, hbr);
    PatBlt(hdcDst, xDst, yDst, cx, cy, PATCOPY);
    SelectObject(hdcDst, hbrT);

    hbrT = (HBRUSH)SelectObject(hdcDst, hbrMask);
    BitBlt(hdcDst, xDst, yDst, cx, cy, _hdcImage, x, y, ROP_MaskPat);
    SelectObject(hdcDst, hbrT);

    if (hbrFree)
        DeleteBrush(hbrFree);
}

/*
** BlendCT
**
**  copy the source to the dest blended with the given color.
**
*/
void CImageList::BlendCT(HDC hdcDst, int xDst, int yDst, int x, int y, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    BITMAP bm;

    GetObject(_hbmImage, sizeof(bm), &bm);

    if (rgb == CLR_DEFAULT)
        rgb = GetSysColor(COLOR_HIGHLIGHT);

    ASSERT(rgb != CLR_NONE);

    //
    // get the DIB color table and blend it, only do this when the
    // blend color changes
    //
    if (_clrBlend != rgb)
    {
        int n,cnt;

        _clrBlend = rgb;

        GetObject(_hbmImage, sizeof(dib), &dib.bm);
        cnt = GetDIBColorTable(_hdcImage, 0, 256, (LPRGBQUAD)&dib.ct);

        if ((fStyle & ILD_BLENDMASK) == ILD_BLEND50)
            n = 50;
        else
            n = 25;

        BlendCTHelper(dib.ct, rgb, n, cnt);
    }

    //
    // draw the image with a different color table
    //
    StretchDIBits(hdcDst, xDst, yDst, cx, cy,
        x, dib.bi.biHeight-(y+cy), cx, cy,
        bm.bmBits, (LPBITMAPINFO)&dib.bi, DIB_RGB_COLORS, SRCCOPY);
}

//  RGB555 macros
#define RGB555(r,g,b)       (((((r)>>3)&0x1F)<<10) | ((((g)>>3)&0x1F)<<5) | (((b)>>3)&0x1F))
#define R_555(w)            (int)(((w) >> 7) & 0xF8)
#define G_555(w)            (int)(((w) >> 2) & 0xF8)
#define B_555(w)            (int)(((w) << 3) & 0xF8)

void CImageList::Blend16Helper(int xSrc, int ySrc, int xDst, int yDst, int cx, int cy, COLORREF rgb, int a)          // alpha value
{
    // If it's odd, Adjust. 
    if ((cx & 1) == 1)
    {
        cx++;
    }

    if (rgb == CLR_NONE)
    {
        // blending with the destination, we ignore the alpha and always
        // do 50% (this is what the old dither mask code did)

        int ys = ySrc;
        int yd = yDst;

        for (; ys < ySrc + cy; ys++, yd++)
        {
            WORD* pSrc = &((WORD*)_pargbImage)[xSrc + ys * cx];  // Cast because we've gotten to this case because we are a 555 imagelist
            WORD* pDst = &((WORD*)_pargbImage)[xDst + yd * cx];
            for (int x = 0; x < cx; x++)
            {
                *pDst++ = ((*pDst & 0x7BDE) >> 1) + ((*pSrc++ & 0x7BDE) >> 1);
            }

        }
    }
    else
    {
        // blending with a solid color

        // pre multiply source (constant) rgb by alpha
        int sr = GetRValue(rgb) * a;
        int sg = GetGValue(rgb) * a;
        int sb = GetBValue(rgb) * a;

        // compute inverse alpha for inner loop
        a = 256 - a;

        // special case a 50% blend, to avoid a multiply
        if (a == 128)
        {
            sr = RGB555(sr>>8,sg>>8,sb>>8);

            int ys = ySrc;
            int yd = yDst;
            for (; ys < ySrc + cy; ys++, yd++)
            {
                WORD* pSrc = &((WORD*)_pargbImage)[xSrc + ys * cx];
                WORD* pDst = &((WORD*)_pargbImage)[xDst + yd * cx];
                for (int x = 0; x < cx; x++)
                {
                    int i = *pSrc++;
                    i = sr + ((i & 0x7BDE) >> 1);
                    *pDst++ = (WORD) i;
                }
            }
        }
        else
        {
            int ys = ySrc;
            int yd = yDst;
            for (; ys < ySrc + cy; ys++, yd++)
            {
                WORD* pSrc = &((WORD*)_pargbImage)[xSrc + ys * cx];
                WORD* pDst = &((WORD*)_pargbImage)[xDst + yd * cx];
                for (int x = 0; x < cx; x++)
                {
                    int i = *pSrc++;
                    int r = (R_555(i) * a + sr) >> 8;
                    int g = (G_555(i) * a + sg) >> 8;
                    int b = (B_555(i) * a + sb) >> 8;
                    *pDst++ = RGB555(r,g,b);
                }
            }
        }
    }
}

/*
** ImageList_Blend16
**
**  copy the source to the dest blended with the given color.
**
**  source is assumed to be a 16 bit (RGB 555) bottom-up DIBSection
**  (this is the only kind of DIBSection we create)
*/
void CImageList::Blend16(HDC hdcDst, int xDst, int yDst, int iImage, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    BITMAP bm;
    RECT rc;
    RECT rcSpare;
    RECT rcSpareInverted;
    int a, x, y;

    // get bitmap info for source bitmap
    GetObject(_hbmImage, sizeof(bm), &bm);
    ASSERT(bm.bmBitsPixel==16);

    // get blend RGB
    if (rgb == CLR_DEFAULT)
        rgb = GetSysColor(COLOR_HIGHLIGHT);

    // get blend factor as a fraction of 256
    // only 50% or 25% is currently used.
    if ((fStyle & ILD_BLENDMASK) == ILD_BLEND50)
        a = 128;
    else
        a = 64;

    GetImageRectInverted(iImage, &rc);
    x = rc.left;
    y = rc.top;


    // blend the image with the specified color and place at end of image list
    if (GetSpareImageRectInverted(&rcSpareInverted) &&
        GetSpareImageRect(&rcSpare))
    {
        // if blending with the destination, copy the dest to our work buffer
        if (rgb == CLR_NONE)
            BitBlt(_hdcImage, rcSpare.left, rcSpare.top, cx, cy, hdcDst, xDst, yDst, SRCCOPY);
        // sometimes the user can change the icon size (via plustab) between 32x32 and 48x48,
        // thus the values we have might be bigger than the actual bitmap. To prevent us from
        // crashing in Blend16 when this happens we do some bounds checks here
        if (rc.left + cx <= bm.bmWidth  &&
            rc.top  + cy <= bm.bmHeight &&
            x + cx       <= bm.bmWidth  &&
            y + cy       <= bm.bmHeight)
        {
            // Needs inverted coordinates
            Blend16Helper(x, y, rcSpareInverted.left, rcSpareInverted.top, cx, cy, rgb, a);
        }

        // blt blended image to the dest DC
        BitBlt(hdcDst, xDst, yDst, cx, cy, _hdcImage, rcSpare.left, rcSpare.top, SRCCOPY);
    }
}

#define ALPHA_50    128
#define ALPHA_25    64

void CImageList::_GenerateAlphaForImageUsingMask(int iImage, BOOL fSpare)
{
    RECT rcImage;
    RECT rcInverted;
    HRESULT hr;
    
    GetImageRect(iImage, &rcImage);
    
    if (fSpare)
    {
        hr = GetSpareImageRectInverted(&rcInverted);
    }
    else
    {
        hr = GetImageRectInverted(iImage, &rcInverted);
    }

    if (!SUCCEEDED(hr))
        return;

    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = _cx;
    bi.bmiHeader.biHeight = _cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    HDC hdcMem = CreateCompatibleDC(_hdcMask);
    if (hdcMem)
    {
        RGBQUAD* pbMask;
        HBITMAP hbmp = CreateDIBSection(hdcMem, &bi, DIB_RGB_COLORS, (void**)&pbMask, NULL, 0);

        if (hbmp)
        {
            HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcMem, hbmp);
            SetTextColor(hdcMem, RGB(0xFF, 0xFF, 0xFF));
            ::SetBkColor(hdcMem, RGB(0x0,0x0,0x0));

            BitBlt(hdcMem, 0, 0, _cx, _cy, _hdcMask, rcImage.left, rcImage.top, SRCCOPY);

            for (int y = 0; y < _cy; y++)
            {
                int Offset = (y + rcInverted.top) * _cx;
                int MaskOffset = y * _cx;
                for (int x = 0; x < _cx; x++)
                {
                    RGBQUAD* prgb = &_pargbImage[x + rcInverted.left + Offset];
                    if (pbMask[x + MaskOffset].rgbBlue != 0)
                    {
                        prgb->rgbReserved = 255;
                    }
                    else
                    {
                        *(DWORD*)prgb = 0;
                    }
                }
            }

            SelectObject(hdcMem, hbmpOld);
            DeleteObject(hbmp);
        }
        DeleteDC(hdcMem);
    }

    if (!fSpare)
    {
        SetItemFlags(iImage, ILIF_ALPHA);
        _PreProcessImage(iImage);
    }
}

void ScaleAlpha(RGBQUAD* prgbImage, RECT* prc, int aScale)
{
    int cx = RECTWIDTH(*prc);
    for (int y = prc->top; y < prc->bottom; y++)
    {
        int Offset = y * cx;
        for (int x = prc->left; x < prc->right; x++)
        {
            RGBQUAD* prgb = &prgbImage[x + Offset];
            if (prgb->rgbReserved != 0)
            {
                prgb->rgbReserved = (BYTE)(prgb->rgbReserved / aScale);      // New alpha
                prgb->rgbRed      = ((prgb->rgbRed   * prgb->rgbReserved) + 128) / 255;
                prgb->rgbGreen    = ((prgb->rgbGreen * prgb->rgbReserved) + 128) / 255;
                prgb->rgbBlue     = ((prgb->rgbBlue  * prgb->rgbReserved) + 128) / 255;
            }
        }
    }
}

#define COLORBLEND_ALPHA 128

BOOL CImageList::Blend32(HDC hdcDst, int xDst, int yDst, int iImage, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    BITMAP bm;
    RECT rc;
    RECT rcSpare;
    RECT rcSpareInverted;
    int aScale;
    BOOL fBlendWithColor = FALSE;
    int r,g,b;

    // get bitmap info for source bitmap
    GetObject(_hbmImage, sizeof(bm), &bm);
    ASSERT(bm.bmBitsPixel==32);

    // get blend RGB
    if (rgb == CLR_DEFAULT)
    {
        rgb = GetSysColor(COLOR_HIGHLIGHT);
        fBlendWithColor = TRUE;
        r = GetRValue(rgb) * COLORBLEND_ALPHA;
        g = GetGValue(rgb) * COLORBLEND_ALPHA;
        b = GetBValue(rgb) * COLORBLEND_ALPHA;
    }

    // get blend factor as a fraction of 256
    // only 50% or 25% is currently used.
    if ((fStyle & ILD_BLENDMASK) == ILD_BLEND50 || rgb == CLR_NONE)
        aScale = 2;
    else
        aScale = 4;

    GetImageRect(iImage, &rc);
    if (GetSpareImageRectInverted(&rcSpareInverted) &&
        GetSpareImageRect(&rcSpare))
    {
        BitBlt(_hdcImage, rcSpare.left, rcSpare.top, _cx, _cy, _hdcImage, rc.left, rc.top, SRCCOPY);

        BOOL fHasAlpha = (_GetItemFlags(iImage) & ILIF_ALPHA);
        if (!fHasAlpha)
        {
            _GenerateAlphaForImageUsingMask(iImage, TRUE);
        }

        // if blending with the destination, copy the dest to our work buffer
        if (rgb == CLR_NONE)
        {
            ScaleAlpha(_pargbImage, &rcSpareInverted, aScale);

            BLENDFUNCTION bf = {0};
            bf.BlendOp = AC_SRC_OVER;
            bf.SourceConstantAlpha = 255;
            bf.AlphaFormat = AC_SRC_ALPHA;
            bf.BlendFlags = AC_MIRRORBITMAP | ((fStyle & ILD_DPISCALE)?AC_USE_HIGHQUALITYFILTER:0);
            GdiAlphaBlend(hdcDst,  xDst, yDst, cx, cy, _hdcImage, rcSpare.left, rcSpare.top, _cx, _cy, bf);
            return FALSE;
        }
        else
        {
            if (fBlendWithColor)
            {
                for (int y = rcSpareInverted.top; y < rcSpareInverted.bottom; y++)
                {
                    int Offset = y * _cx;
                    for (int x = rcSpareInverted.left; x < rcSpareInverted.right; x++)
                    {
                        RGBQUAD* prgb = &_pargbImage[x + Offset];
                        if (prgb->rgbReserved > 128)
                        {
                            prgb->rgbRed      = (prgb->rgbRed   * COLORBLEND_ALPHA + r) / 255;
                            prgb->rgbGreen    = (prgb->rgbGreen * COLORBLEND_ALPHA + g) / 255;
                            prgb->rgbBlue     = (prgb->rgbBlue  * COLORBLEND_ALPHA + b) / 255;
                        }
                    }
                }
            }
            else
            {
                ScaleAlpha(_pargbImage, &rcSpareInverted, aScale);

            }


            BitBlt(hdcDst, xDst, yDst, cx, cy, _hdcImage, rcSpare.left, rcSpare.top, SRCCOPY);
            return TRUE;
        }
    }

    return FALSE;
}


/*
** ImageList_Blend
**
**  copy the source to the dest blended with the given color.
**  top level function to decide what blend function to call
*/
BOOL CImageList::Blend(HDC hdcDst, int xDst, int yDst, int iImage, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    BOOL fRet = FALSE;
    BITMAP bm;
    RECT rc;
    int bpp = GetDeviceCaps(hdcDst, BITSPIXEL);

    GetObject(_hbmImage, sizeof(bm), &bm);
    GetImageRect(iImage, &rc);

    //
    // if _hbmImage is a DIBSection and we are on a HiColor device
    // the do a "real" blend
    //
    if (bm.bmBits && bm.bmBitsPixel <= 8 && (bpp > 8 || bm.bmBitsPixel==8))
    {
        // blend from a 4bit or 8bit DIB
        BlendCT(hdcDst, xDst, yDst, rc.left, rc.top, cx, cy, rgb, fStyle);
    }
    else if (bm.bmBits && bm.bmBitsPixel == 16 && bpp > 8)
    {
        // blend from a 16bit 555 DIB
        Blend16(hdcDst, xDst, yDst, iImage, cx, cy, rgb, fStyle);
    }
    else if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        fRet = Blend32(hdcDst, xDst, yDst, iImage, cx, cy, rgb, fStyle);
    }
    else
    {
        // simulate a blend with a dither pattern.
        BlendDither(hdcDst, xDst, yDst, rc.left, rc.top, cx, cy, rgb, fStyle);
    }

    return fRet;
}

#define RGB_to_Gray(x) ((54 * GetRValue((x)) + 183 * GetGValue((x)) + 19 * GetBValue((x))) >> 8)

void TrueSaturateBits(void* pvBitmapBits, int Amount, int cx, int cy)
{
    ULONG* pulSrc = (ULONG*)pvBitmapBits;

    if ((cx > 0) && (cy > 0) && pulSrc)
    {
        for (int i = cx*cy - 1; i >= 0; i--)
        {
            /* 
            Enable this if you need true saturation adjustment
            justmann 25-JAN-2001

            ULONG ulR = GetRValue(*pulSrc);
            ULONG ulG = GetGValue(*pulSrc);
            ULONG ulB = GetBValue(*pulSrc);
            ulGray = (54 * ulR + 183 * ulG + 19 * ulB) >> 8;
            ULONG ulTemp = ulGray * (0xff - Amount);
            ulR = (ulR * Amount + ulTemp) >> 8;
            ulG = (ulG * Amount + ulTemp) >> 8;
            ulB = (ulB * Amount + ulTemp) >> 8;
            *pulSrc = (*pulSrc & 0xff000000) | RGB(R, G, B);
            */
            ULONG ulGray = RGB_to_Gray(*pulSrc);
            *pulSrc = (*pulSrc & 0xff000000) | RGB(ulGray, ulGray, ulGray);
            pulSrc++;
        }
    }
    else
    {
        // This should never happen, if it does somebody has a bogus DIB section or does not
        // understand what width or height is!
        ASSERT(0);
    }
}


BOOL CImageList::_MaskStretchBlt(BOOL fStretch, int i, HDC hdcDst, int xDst, int yDst, int cxDst, int cyDst,
                                   HDC hdcImage, int xSrc, int ySrc, int cxSrc, int cySrc,
                                   int xMask, int yMask,
                                   DWORD dwRop)
{
    BOOL fRet = TRUE;
    if (fStretch == FALSE)
    {
        fRet = MaskBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcImage, 
                xSrc, ySrc, _hbmMask, xMask, yMask, dwRop);
    }
    else
    {
        //
        //  we have some special cases:
        //
        //  if the background color is black, we just do a AND then OR
        //  if the background color is white, we just do a OR then AND
        //  otherwise change source, then AND then OR
        //

        COLORREF clrTextSave = SetTextColor(hdcDst, CLR_BLACK);
        COLORREF clrBkSave = ::SetBkColor(hdcDst, CLR_WHITE);

        // we cant do white/black special cases if we munged the mask or image

        if (i != -1 && _clrBk == CLR_WHITE)
        {
            StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, _hdcMask,  xMask, yMask, cxSrc, cySrc,  ROP_DSno);
            StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcImage, xSrc, ySrc, cxSrc, cySrc, ROP_DSa);
        }
        else if (i != -1 && (_clrBk == CLR_BLACK || _clrBk == CLR_NONE))
        {
            StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, _hdcMask,  xMask, yMask, cxSrc, cySrc,  ROP_DSa);
            StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcImage, xSrc, ySrc, cxSrc, cySrc, ROP_DSo);
        }
        else
        {
            // black out the source image.
            BitBlt(hdcImage, xSrc, ySrc, cxSrc, cySrc, _hdcMask, xMask, yMask, ROP_DSna);

            StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, _hdcMask, xMask, yMask, cxSrc, cySrc, ROP_DSa);
            StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcImage, xSrc, ySrc, cxSrc, cySrc, ROP_DSo);

            if (i != -1)
                _ResetBkColor(i, i, _clrBk);
        }

        SetTextColor(hdcDst, clrTextSave);
        ::SetBkColor(hdcDst, clrBkSave);
    }

    return fRet;
}

BOOL CImageList::_StretchBlt(BOOL fStretch, HDC hdc, int x, int y, int cx, int cy, 
                             HDC hdcSrc, int xs, int ys, int cxs, int cys, DWORD dwRop)
{
    if (fStretch)
        return StretchBlt(hdc, x, y, cx, cy, 
                             hdcSrc, xs, ys, cxs, cys, dwRop);

    return BitBlt(hdc, x, y, cx, cy, hdcSrc, xs, ys, dwRop);
}

HRESULT CImageList::Draw(IMAGELISTDRAWPARAMS* pimldp) 
{
    RECT rcImage;
    RECT rc;
    HBRUSH  hbrT;

    BOOL fImage;
    HDC hdcMaskI;
    HDC hdcImageI;
    int xMask, yMask;
    int xImage, yImage;
    int cxSource, cySource;    
    DWORD dwOldStretchBltMode;
    BOOL fStretch;
    BOOL fDPIScale = FALSE;

    IMAGELISTDRAWPARAMS imldp = {0};


    if (pimldp->cbSize != sizeof(IMAGELISTDRAWPARAMS))
    {
        if (pimldp->cbSize == IMAGELISTDRAWPARAMS_V3_SIZE)
        {
            memcpy(&imldp, pimldp, IMAGELISTDRAWPARAMS_V3_SIZE);
            imldp.cbSize = sizeof(IMAGELISTDRAWPARAMS);
            pimldp = &imldp;
        }
        else
            return E_INVALIDARG;
    }
    
    if (!IsImageListIndex(pimldp->i))
        return E_INVALIDARG;

    //
    // If we need to use the mirrored imagelist, then let's set it.
    //
    if (_pimlMirror &&
        (IS_DC_RTL_MIRRORED(pimldp->hdcDst)))
    {
        return _pimlMirror->Draw(pimldp);
    }


    ENTERCRITICAL;

    dwOldStretchBltMode = SetStretchBltMode(pimldp->hdcDst, COLORONCOLOR);

    GetImageRect(pimldp->i, &rcImage);
    rcImage.left += pimldp->xBitmap;
    rcImage.top += pimldp->yBitmap;
        
    if (pimldp->rgbBk == CLR_DEFAULT)
        pimldp->rgbBk = _clrBk;

    if (pimldp->rgbBk == CLR_NONE)
        pimldp->fStyle |= ILD_TRANSPARENT;

    if (pimldp->cx == 0)
        pimldp->cx = RECTWIDTH(rcImage);

    if (pimldp->cy == 0)
        pimldp->cy = RECTHEIGHT(rcImage);

    BOOL    fImageHasAlpha = (_GetItemFlags(pimldp->i) & ILIF_ALPHA);
again:

    cxSource = RECTWIDTH(rcImage);
    cySource = RECTHEIGHT(rcImage);

    if (pimldp->cx <= 0 || pimldp->cy <= 0)
    {
        // caller asked to draw no (or negative) pixels; that's easy!
        // Early-out this case so other parts of the drawing
        // don't get confused.
        goto exit;
    }

    if (pimldp->fStyle & ILD_DPISCALE)
    {
        CCDPIScaleX(&pimldp->cx);
        CCDPIScaleY(&pimldp->cy);
        fDPIScale = TRUE;
    }

    fStretch = (pimldp->fStyle & ILD_SCALE) || (fDPIScale);

    if (fStretch)
    {
        dwOldStretchBltMode = SetStretchBltMode(pimldp->hdcDst, HALFTONE);
    }

    hdcMaskI = _hdcMask;
    xMask = rcImage.left;
    yMask = rcImage.top;

    hdcImageI = _hdcImage;
    xImage = rcImage.left;
    yImage = rcImage.top;

    if (pimldp->fStyle & ILD_BLENDMASK)
    {
        // make a copy of the image, because we will have to modify it
        HDC hdcT = ImageList_GetWorkDC(pimldp->hdcDst, (_flags & ILC_COLORMASK) == ILC_COLOR32, pimldp->cx, pimldp->cy);
        if (hdcT)
        {
            hdcImageI = hdcT;
            xImage = 0;
            yImage = 0;

            //
            //  blend with the destination
            //  by "oring" the mask with a 50% dither mask
            //
            if (pimldp->rgbFg == CLR_NONE && hdcMaskI)
            {
                fImageHasAlpha = FALSE;
                if ((_flags & ILC_COLORMASK) == ILC_COLOR32 &&
                    !(pimldp->fStyle & ILD_MASK))
                {
                    // copy dest to our work buffer
                    _StretchBlt(fStretch, hdcImageI, 0, 0, pimldp->cx, pimldp->cy, pimldp->hdcDst, pimldp->x, pimldp->y, cxSource, cySource, SRCCOPY);

                    Blend32(hdcImageI, 0, 0, pimldp->i, pimldp->cx, pimldp->cy, pimldp->rgbFg, pimldp->fStyle);
                }
                else if ((_flags & ILC_COLORMASK) == ILC_COLOR16 &&
                    !(pimldp->fStyle & ILD_MASK))
                {
                    // copy dest to our work buffer
                    _StretchBlt(fStretch, hdcImageI, 0, 0, pimldp->cx, pimldp->cy, pimldp->hdcDst, pimldp->x, pimldp->y, cxSource, cySource, SRCCOPY);

                    // blend source into our work buffer
                    Blend16(hdcImageI, 0, 0, pimldp->i, pimldp->cx, pimldp->cy, pimldp->rgbFg, pimldp->fStyle);
                    pimldp->fStyle |= ILD_TRANSPARENT;
                }
                else
                {
                    GetSpareImageRect(&rc);
                    xMask = rc.left;
                    yMask = rc.top;

                    // copy the source image
                    _StretchBlt(fStretch, hdcImageI, 0, 0, pimldp->cx, pimldp->cy,
                           _hdcImage, rcImage.left, rcImage.top, cxSource, cySource, SRCCOPY);

                    // make a dithered copy of the mask
                    hbrT = (HBRUSH)SelectObject(hdcMaskI, g_hbrMonoDither);
                    _StretchBlt(fStretch, hdcMaskI, rc.left, rc.top, pimldp->cx, pimldp->cy,
                           _hdcMask, rcImage.left, rcImage.top, cxSource, cySource, ROP_PSo);
                    SelectObject(hdcMaskI, hbrT);
                    pimldp->fStyle |= ILD_TRANSPARENT;
                }

            }
            else
            {
                // blend source into our work buffer
                if (Blend(hdcImageI, 0, 0, pimldp->i, pimldp->cx, pimldp->cy, pimldp->rgbFg, pimldp->fStyle))
                {
                    fImageHasAlpha = (_flags & ILC_COLORMASK) == ILC_COLOR32;
                }
            }
        }
    }

    // is the source image from the image list (not hdcWork)
    fImage = hdcImageI == _hdcImage;

    if (pimldp->cbSize >= sizeof(IMAGELISTDRAWPARAMS) &&
        pimldp->fState & ILS_GLOW       || 
        pimldp->fState & ILS_SHADOW     ||
        pimldp->fState & ILS_SATURATE   ||
        pimldp->fState & ILS_ALPHA)
    {
        int z;
        ULONG* pvBits;
        HDC hdcMem = CreateCompatibleDC(pimldp->hdcDst);
        HBITMAP hbmpOld;
        HBITMAP hbmp;
        BITMAPINFO bi = {0};
        BLENDFUNCTION bf = {0};
        DWORD dwAlphaAmount = 0x000000ff;
        COLORREF crAlphaColor = pimldp->crEffect;        // Need to make this a selectable color
        int x, y;
        int xOffset, yOffset;
        SIZE size = {cxSource, cySource};

        if (hdcMem)
        {
            if (pimldp->fState & ILS_SHADOW)
            {
                x = 5;      // This is a "Blur fudge Factor"
                y = 5;      //
                xOffset = -(DROP_SHADOW - x);
                yOffset = -(DROP_SHADOW - y);
                size.cx = pimldp->cx + 10;
                size.cy = pimldp->cy + 10;
                dwAlphaAmount = 0x00000050;
                crAlphaColor = RGB(0, 0, 0);
            }
            else if (pimldp->fState & ILS_GLOW)
            {
                xOffset = x = 10;
                yOffset = y = 10;
                size.cx = pimldp->cx + (GLOW_RADIUS * 2);
                size.cy = pimldp->cy + (GLOW_RADIUS * 2);
            }
            else if (pimldp->fState & ILS_ALPHA)
            {
                xOffset = x = 0;
                yOffset = y = 0;
                size.cx = pimldp->cx;
                size.cy = pimldp->cy;
            }

            bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
            bi.bmiHeader.biWidth = size.cx;
            bi.bmiHeader.biHeight = size.cy;
            bi.bmiHeader.biPlanes = 1;
            bi.bmiHeader.biBitCount = 32;
            bi.bmiHeader.biCompression = BI_RGB;

            hbmp = CreateDIBSection(hdcMem, &bi, DIB_RGB_COLORS, (VOID**)&pvBits, NULL, 0);
            if (hbmp)
            {
                hbmpOld = (HBITMAP)SelectObject(hdcMem, hbmp);

                ZeroMemory(pvBits, size.cx * size.cy);

                if (pimldp->fState & ILS_SHADOW || pimldp->fState & ILS_GLOW || pimldp->fState & ILS_ALPHA)
                {
                    if (_hbmMask)
                    {
                        MaskBlt(hdcMem, pimldp->x, pimldp->y, size.cx, size.cy, 
                            hdcImageI, xImage, yImage, _hbmMask, xMask, yMask, 0xCCAA0000);
                    }
                    else if (pimldp->fState & ILS_SHADOW)
                    {
                        RECT rc = {x, y, size.cx, size.cy};
                        FillRectClr(hdcMem, &rc, RGB(0x0F, 0x0F, 0x0F));        // White so that it gets inverted into a shadow
                    }
                    else
                    {
                        BitBlt(hdcMem, x, y, size.cx, size.cy, hdcImageI, xImage, yImage, SRCCOPY);
                    }

                    int iTotalSize = size.cx * size.cy;

                    if (pimldp->fState & ILS_ALPHA)
                    {
                        for (z = 0; z < iTotalSize; z++)
                        {
                            RGBQUAD* prgb = &((RGBQUAD*)pvBits)[z];
                            prgb->rgbReserved  = (BYTE)(pimldp->Frame & 0xFF);
                            prgb->rgbRed      = ((prgb->rgbRed   * prgb->rgbReserved) + 128) / 255;
                            prgb->rgbGreen    = ((prgb->rgbGreen * prgb->rgbReserved) + 128) / 255;
                            prgb->rgbBlue     = ((prgb->rgbBlue  * prgb->rgbReserved) + 128) / 255;
                        }
                    }
                    else
                    {
                        for (z = 0; z < iTotalSize; z++)
                        {
                            if (((PULONG)pvBits)[z] != 0)
                                ((PULONG)pvBits)[z] = dwAlphaAmount;
                        }

                        BlurBitmap(pvBits, size.cx, size.cy, crAlphaColor);

                        if (!(pimldp->fState & ILS_SHADOW))
                        {
                            for (z = 0; z < iTotalSize; z++)
                            {
                                if (((PULONG)pvBits)[z] > 0x09000000)
                                    ((PULONG)pvBits)[z] = dwAlphaAmount;
                            }
                            BlurBitmap(pvBits, size.cx, size.cy, crAlphaColor);
                            BlurBitmap(pvBits, size.cx, size.cy, crAlphaColor);
                        }
                    }

                    bf.BlendOp = AC_SRC_OVER;
                    bf.SourceConstantAlpha = 255;
                    bf.AlphaFormat = AC_SRC_ALPHA;
                    bf.BlendFlags = fDPIScale?AC_USE_HIGHQUALITYFILTER:0;
                    // Do not mirror the bitmap. By this point it is correctly mirrored
                    GdiAlphaBlend(pimldp->hdcDst, pimldp->x - xOffset, pimldp->y - yOffset, pimldp->cx, pimldp->cy, 
                               hdcMem, 0, 0, size.cx, size.cy, bf);
                }
                else
                {
                    BitBlt(hdcMem, 0, 0, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, SRCCOPY);

                    TrueSaturateBits(pvBits, pimldp->Frame, size.cx, size.cy);

                    if (fImageHasAlpha)
                    {
                        bf.BlendOp = AC_SRC_OVER;
                        bf.SourceConstantAlpha = 150;
                        bf.AlphaFormat = AC_SRC_ALPHA;
                        // Do not mirror the bitmap. By this point it is correctly mirrored
                        GdiAlphaBlend(pimldp->hdcDst,  pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcMem, 0, 0, cxSource, cySource, bf);
                    }
                    else if (_hbmMask)
                    {
                        _MaskStretchBlt(fStretch, -1, hdcMem, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, 
                            hdcMem, 0, 0, cxSource, cySource, xMask, yMask, 0xCCAA0000);
                    }
                    else
                    {
                        _StretchBlt(fStretch, pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcMem, 0, 0, cxSource,cySource, SRCCOPY);
                    }
                }

                SelectObject(hdcMem, hbmpOld);
                DeleteObject(hbmp);
                pimldp->fStyle |= ILD_TRANSPARENT;
            }
            DeleteDC(hdcMem);
        }

        if (pimldp->fState & ILS_SHADOW || pimldp->fState & ILS_GLOW)
        {
            if (pimldp->fState & ILS_SHADOW)
            {
                pimldp->fState &= ~ILS_SHADOW;
                //pimldp->x -= DROP_SHADOW;
                //pimldp->y -= DROP_SHADOW;
            }
            else
            {
                pimldp->fState &= ~ILS_GLOW;
            }
            goto again;
        }
    }
    else if ((pimldp->fStyle & ILD_MASK) && hdcMaskI)
    {
    //
    // ILD_MASK means draw the mask only
    //
        DWORD dwRop;
        
        ASSERT(GetTextColor(pimldp->hdcDst) == CLR_BLACK);
        ASSERT(::GetBkColor(pimldp->hdcDst) == CLR_WHITE);
        
        if (pimldp->fStyle & ILD_ROP)
            dwRop = pimldp->dwRop;
        else if (pimldp->fStyle & ILD_TRANSPARENT)
            dwRop = SRCAND;
        else 
            dwRop = SRCCOPY;
        
        _StretchBlt(fStretch, pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcMaskI, xMask, yMask, cxSource, cySource, dwRop);
    }
    else if (fImageHasAlpha &&                      // this image has alpha
             !(pimldp->fStyle & ILD_PRESERVEALPHA)) // But not if we're trying to preserve it.
    {
        if (!(pimldp->fStyle & ILD_TRANSPARENT))
        {
            COLORREF clr = pimldp->rgbBk;
            if (clr == CLR_DEFAULT) 
                clr = _clrBk;

            RECT rc = {pimldp->x, pimldp->y, pimldp->x + pimldp->cx, pimldp->y + pimldp->cy};
            FillRectClr(pimldp->hdcDst, &rc, clr);
        }

        BLENDFUNCTION bf = {0};
        bf.BlendOp = AC_SRC_OVER;
        bf.SourceConstantAlpha = 255;
        bf.AlphaFormat = AC_SRC_ALPHA;
        bf.BlendFlags = AC_MIRRORBITMAP | (fDPIScale?AC_USE_HIGHQUALITYFILTER:0);
        GdiAlphaBlend(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, cxSource, cySource, bf);
    }
    else if (pimldp->fStyle & ILD_IMAGE)
    {
        COLORREF clrBk = ::GetBkColor(hdcImageI);
        DWORD dwRop;
        
        if (pimldp->rgbBk != CLR_DEFAULT) 
        {
            ::SetBkColor(hdcImageI, pimldp->rgbBk);
        }
        
        if (pimldp->fStyle & ILD_ROP)
            dwRop = pimldp->dwRop;
        else
            dwRop = SRCCOPY;
        
        _StretchBlt(fStretch, pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, cxSource, cySource, dwRop);
        
        ::SetBkColor(hdcImageI, clrBk);
    }
    else if ((pimldp->fStyle & ILD_TRANSPARENT) && hdcMaskI)
    {
        _MaskStretchBlt(fStretch, fImage?pimldp->i:-1,pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, 
            hdcImageI, xImage, yImage, cxSource, cySource, xMask, yMask, 0xCCAA0000);
    }
    else if (fImage && pimldp->rgbBk == _clrBk && _fSolidBk)
    {
        _StretchBlt(fStretch, pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, cxSource, cySource, SRCCOPY);
    }
    else if (hdcMaskI && !fImageHasAlpha)
    {
        if (fImage && 
            ((pimldp->rgbBk == _clrBk && 
               !_fSolidBk) || 
              GetNearestColor32(hdcImageI, pimldp->rgbBk) != pimldp->rgbBk))
        {
            // make a copy of the image, because we will have to modify it
            hdcImageI = ImageList_GetWorkDC(pimldp->hdcDst, (_flags & ILC_COLORMASK) == ILC_COLOR32, pimldp->cx, pimldp->cy);
            xImage = 0;
            yImage = 0;
            fImage = FALSE;

            BitBlt(hdcImageI, 0, 0, pimldp->cx, pimldp->cy, _hdcImage, rcImage.left, rcImage.top, SRCCOPY);
        }

        SetBrushOrgEx(hdcImageI, xImage-pimldp->x, yImage-pimldp->y, NULL);
        hbrT = SelectBrush(hdcImageI, CreateSolidBrush(pimldp->rgbBk));
        BitBlt(hdcImageI, xImage, yImage, pimldp->cx, pimldp->cy, hdcMaskI, xMask, yMask, ROP_PatMask);
        DeleteObject(SelectBrush(hdcImageI, hbrT));
        SetBrushOrgEx(hdcImageI, 0, 0, NULL);

        _StretchBlt(fStretch, pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, cxSource, cySource, SRCCOPY);

        if (fImage)
            _ResetBkColor(pimldp->i, pimldp->i, _clrBk);
    }
    else
    {
        _StretchBlt(fStretch, pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, cxSource, cySource, SRCCOPY);
    }

    //
    // now deal with a overlay image, use the minimal bounding rect (and flags)
    // we computed in ImageList_SetOverlayImage()
    //
    if (pimldp->fStyle & ILD_OVERLAYMASK)
    {
        int n = OVERLAYMASKTOINDEX(pimldp->fStyle);

        if (n < NUM_OVERLAY_IMAGES) 
        {
            pimldp->i = _aOverlayIndexes[n];

            if (!fImageHasAlpha)
                pimldp->fStyle &= ~ILD_PRESERVEALPHA;

            if (pimldp->fStyle & ILD_PRESERVEALPHA &&
                !(_GetItemFlags(pimldp->i) & ILIF_ALPHA))
            {
                _GenerateAlphaForImageUsingMask(pimldp->i, FALSE);
            }

            fImageHasAlpha = (_GetItemFlags(pimldp->i) & ILIF_ALPHA);

            GetImageRect(pimldp->i, &rcImage);

            int xOverlay  = _aOverlayX[n];
            int yOverlay  = _aOverlayY[n];
            int cxOverlay = _aOverlayDX[n];
            int cyOverlay = _aOverlayDY[n];

            if (fDPIScale)
            {
                CCDPIScaleX(&xOverlay );
                CCDPIScaleY(&yOverlay );
            }


            pimldp->cx = cxOverlay;
            pimldp->cy = cyOverlay;
            pimldp->x += xOverlay;
            pimldp->y += yOverlay;

            rcImage.left += _aOverlayX[n] + pimldp->xBitmap;
            rcImage.top  += _aOverlayY[n] + pimldp->yBitmap;
            rcImage.right = rcImage.left + _aOverlayDX[n];
            rcImage.bottom = rcImage.top + _aOverlayDY[n];



            pimldp->fStyle &= ILD_MASK;
            pimldp->fStyle |= ILD_TRANSPARENT;
            pimldp->fStyle |= (fDPIScale?ILD_DPISCALE:0);
            pimldp->fStyle |= _aOverlayF[n];

            if (fImageHasAlpha)
                pimldp->fStyle &= ~(ILD_IMAGE);


            if (pimldp->cx > 0 && pimldp->cy > 0)
                goto again;
        }
    }

    if (!fImage)
    {
        ImageList_ReleaseWorkDC(hdcImageI);
    }

exit:
    SetStretchBltMode(pimldp->hdcDst, dwOldStretchBltMode);

    LEAVECRITICAL;

    return S_OK;
}


HRESULT CImageList::GetImageInfo(int i, IMAGEINFO * pImageInfo)
{
    RIPMSG(pImageInfo != NULL, "ImageList_GetImageInfo: Invalid NULL pointer");
    RIPMSG(IsImageListIndex(i), "ImageList_GetImageInfo: Invalid image index %d", i);
    if (!pImageInfo || !IsImageListIndex(i))
        return E_POINTER;

    pImageInfo->hbmImage      = _hbmImage;
    pImageInfo->hbmMask       = _hbmMask;

    return GetImageRect(i, &pImageInfo->rcImage);
}

//
// Parameter:
//  i -- -1 to add
//
HRESULT CImageList::_ReplaceIcon(int i, HICON hIcon, int* pi)
{
    HICON hIconT = hIcon;
    RECT rc;
    HRESULT hr = S_OK;

    TraceMsg(TF_IMAGELIST, "ImageList_ReplaceIcon");
    
    *pi = -1;
    
    // be win95 compatible
    if (i < -1)
        return E_INVALIDARG;
    

    //
    //  re-size the icon (iff needed) by calling CopyImage
    //
    hIcon = (HICON)CopyImage(hIconT, IMAGE_ICON, _cx, _cy, LR_COPYFROMRESOURCE | LR_COPYRETURNORG);

    if (hIcon == NULL)
        return E_OUTOFMEMORY;

    //
    //  alocate a slot for the icon
    //
    if (i == -1)
        hr = _Add(NULL,NULL,1,0,0,&i);

    if (i == -1)
        goto exit;

    ENTERCRITICAL;

    //
    //  now draw it into the image bitmaps
    //
    hr = GetImageRect(i, &rc);
    if (FAILED(hr))
        goto LeaveCritical;

    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {

        BOOL fSuccess = FALSE;
        ICONINFO io;
        if (GetIconInfo(hIcon, &io))
        {
            BITMAP bm;
            if (GetObject(io.hbmColor, sizeof(bm), &bm))
            {
                if (bm.bmBitsPixel == 32)
                {
                    HDC h = CreateCompatibleDC(_hdcImage);

                    if (h)
                    {
                        HBITMAP hbmpOld = (HBITMAP)SelectObject(h, io.hbmColor);

                        BitBlt(_hdcImage, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), h, 0, 0, SRCCOPY);

                        if (_HasAlpha(i))
                        {
                            SetItemFlags(i, ILIF_ALPHA);
                            _PreProcessImage(i);
                            fSuccess = TRUE;
                        }

                        SelectObject(h, hbmpOld);
                        DeleteDC(h);
                    }
                }
            }

            DeleteObject(io.hbmColor);
            DeleteObject(io.hbmMask);
        }

        if (!fSuccess)
        {
            // If it doesn't have alpha or we can't get info
            SetItemFlags(i, 0);
        }

    }

    if (_GetItemFlags(i) == 0)
    {
        FillRect(_hdcImage, &rc, _hbrBk);
        DrawIconEx(_hdcImage, rc.left, rc.top, hIcon, 0, 0, 0, NULL, DI_NORMAL);
    }

    if (_hdcMask)
        DrawIconEx(_hdcMask, rc.left, rc.top, hIcon, 0, 0, 0, NULL, DI_MASK);


    hr = S_OK;

    *pi = i;

LeaveCritical:
    LEAVECRITICAL;

exit:

    //
    // if we had user size a new icon, delete it.
    //
    if (hIcon != hIconT)
        DestroyIcon(hIcon);

    return hr;
}

HRESULT CImageList::ReplaceIcon(int i, HICON hIcon, int* pi)
{
    // Let's add it first to the mirrored image list, if one exists
    if (_pimlMirror)
    {
        HICON hIconT = CopyIcon(hIcon);
        if (hIconT)
        {
            MirrorIcon(&hIconT, NULL);
            _pimlMirror->_ReplaceIcon(i, hIconT, pi);
            DestroyIcon(hIconT);
        }
    }

    return _ReplaceIcon(i, hIcon,pi);
}

// make a dithered copy of the source image in the destination image.
// allows placing of the final image in the destination.

HRESULT CImageList::CopyDitherImage(WORD iDst, int xDst, int yDst, IUnknown* punkSrc, int iSrc, UINT fStyle)
{
    IImageList* pux;
    HRESULT hr = punkSrc->QueryInterface(IID_PPV_ARG(IImageList, &pux));

    if (FAILED(hr))
        return hr;

    RECT rc;
    int x, y;

    GetImageRect(iDst, &rc);

    // coordinates in destination image list
    x = xDst + rc.left;
    y = yDst + rc.top;

    fStyle &= ILD_OVERLAYMASK;
    WimpyDrawEx(pux, iSrc, _hdcImage, x, y, 0, 0, CLR_DEFAULT, CLR_NONE, ILD_IMAGE | fStyle);

    //
    // dont dither the mask on a hicolor device, we will draw the image
    // with blending while dragging.
    //
    if (_hdcMask && GetScreenDepth() > 8)
    {
        WimpyDrawEx(pux, iSrc, _hdcMask, x, y, 0, 0, CLR_NONE, CLR_NONE, ILD_MASK | fStyle);
    }
    else if (_hdcMask)
    {
        WimpyDrawEx(pux, iSrc, _hdcMask,  x, y, 0, 0, CLR_NONE, CLR_NONE, ILD_BLEND50|ILD_MASK | fStyle);
    }

    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        SetItemFlags(iDst, _HasAlpha(iDst)?ILIF_ALPHA:0);
    }


    _ResetBkColor(iDst, iDst+1, _clrBk);

    pux->Release();

    return hr;
}

//
// ImageList_CopyBitmap
//
// Worker function for ImageList_Duplicate.
//
// Given a bitmap and an hdc, creates and returns a copy of the passed in bitmap.
//
HBITMAP CImageList::_CopyBitmap(HBITMAP hbm, HDC hdc)
{
    ASSERT(hbm);

    BITMAP bm;
    HBITMAP hbmCopy = NULL;

    if (GetObject(hbm, sizeof(bm), &bm) == sizeof(bm))
    {
        ENTERCRITICAL;
        if (hbmCopy = CreateCompatibleBitmap(hdc, bm.bmWidth, bm.bmHeight))
        {
            CImageList::SelectDstBitmap(hbmCopy);

            BitBlt(g_hdcDst, 0, 0, bm.bmWidth, bm.bmHeight,
                    hdc, 0, 0, SRCCOPY);

            CImageList::SelectDstBitmap(NULL);
        }
        LEAVECRITICAL;
    }
    return hbmCopy;
}

HBITMAP CImageList::_CopyDIBBitmap(HBITMAP hbm, HDC hdc, RGBQUAD** ppargb)
{
    ASSERT(hbm);

    BITMAP bm;
    HBITMAP hbmCopy = NULL;

    if (GetObject(hbm, sizeof(bm), &bm) == sizeof(bm))
    {
        ENTERCRITICAL;
        hbmCopy = _CreateBitmap(bm.bmWidth, bm.bmHeight, ppargb);

        if (hbmCopy)
        {
            CImageList::SelectDstBitmap(hbmCopy);

            BitBlt(g_hdcDst, 0, 0, bm.bmWidth, bm.bmHeight,
                    hdc, 0, 0, SRCCOPY);

            CImageList::SelectDstBitmap(NULL);
        }
        LEAVECRITICAL;
    }
    return hbmCopy;
}


HRESULT CImageList::Clone(REFIID riid, void** ppv)
{
    HBITMAP hbmImageI;
    HBITMAP hbmMaskI = NULL;
    RGBQUAD* pargbImageI;
    HDSA dsaFlags = NULL;
    HRESULT hr = S_OK;
    CImageList* pimlCopy = NULL;

    *ppv = NULL;

    ENTERCRITICAL;

    hbmImageI = _CopyDIBBitmap(_hbmImage, _hdcImage, &pargbImageI);
    if (!hbmImageI)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {

        if (_hdcMask)
        {
            hbmMaskI = _CopyBitmap(_hbmMask, _hdcMask);
            if (!hbmMaskI)
                hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr) && (_flags & ILC_COLORMASK) == ILC_COLOR32)
        {
            dsaFlags = DSA_Create(sizeof(DWORD), _cGrow);
            if (dsaFlags)
            {
                DWORD dw;
                for (int i = 0; i < _cImage; i++)
                {
                    DSA_GetItem(_dsaFlags, i, &dw);
                    if (!DSA_SetItem(dsaFlags, i, &dw))
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            pimlCopy = CImageList::Create(_cx, _cy, _flags, 0, _cGrow);

            if (pimlCopy) 
            {
                // Slam in our bitmap copies and delete the old ones
                SelectObject(pimlCopy->_hdcImage, hbmImageI);
                CImageList::_DeleteBitmap(pimlCopy->_hbmImage);
                if (pimlCopy->_hdcMask) 
                {
                    SelectObject(pimlCopy->_hdcMask, hbmMaskI);
                    CImageList::_DeleteBitmap(pimlCopy->_hbmMask);
                }

                if (pimlCopy->_dsaFlags)
                    DSA_Destroy(pimlCopy->_dsaFlags);

                pimlCopy->_dsaFlags = dsaFlags;
                pimlCopy->_hbmImage = hbmImageI;
                pimlCopy->_pargbImage = pargbImageI;
                pimlCopy->_hbmMask = hbmMaskI;

                // Make sure other info is correct
                pimlCopy->_cImage = _cImage;
                pimlCopy->_cAlloc = _cAlloc;
                pimlCopy->_cStrip = _cStrip;
                pimlCopy->_clrBlend = _clrBlend;
                pimlCopy->_clrBk = _clrBk;

                // Delete the old brush and create the correct one
                if (pimlCopy->_hbrBk)
                    DeleteObject(pimlCopy->_hbrBk);
                if (pimlCopy->_clrBk == CLR_NONE)
                {
                    pimlCopy->_hbrBk = (HBRUSH)GetStockObject(BLACK_BRUSH);
                    pimlCopy->_fSolidBk = TRUE;
                }
                else
                {
                    pimlCopy->_hbrBk = CreateSolidBrush(pimlCopy->_clrBk);
                    pimlCopy->_fSolidBk = GetNearestColor32(pimlCopy->_hdcImage, pimlCopy->_clrBk) == pimlCopy->_clrBk;
                }
            } 
        }

        LEAVECRITICAL;
    }

    if (FAILED(hr))
    {
        if (hbmImageI)
            CImageList::_DeleteBitmap(hbmImageI);
        if (hbmMaskI)
            CImageList::_DeleteBitmap(hbmMaskI);
        if (dsaFlags)
            DSA_Destroy(dsaFlags);
    }

    if (pimlCopy)
    {
        hr = pimlCopy->QueryInterface(riid, ppv);
        pimlCopy->Release();
    }

    return hr;

}

void CImageList::_Merge(IImageList* pux, int i, int dx, int dy)
{
    if (_hdcMask)
    {
        IImageListPriv* puxp;
        if (SUCCEEDED(pux->QueryInterface(IID_PPV_ARG(IImageListPriv, &puxp))))
        {
            HDC hdcMaskI;
            if (SUCCEEDED(puxp->GetPrivateGoo(NULL, NULL, NULL, &hdcMaskI)) && hdcMaskI)
            {
                RECT rcMerge;
                int cxI, cyI;
                pux->GetIconSize(&cxI, &cyI);

                UINT uFlags = 0;
                puxp->GetFlags(&uFlags);
                pux->GetImageRect(i, &rcMerge);

                BitBlt(_hdcMask, dx, dy, cxI, cyI,
                       hdcMaskI, rcMerge.left, rcMerge.top, SRCAND);
            }
            puxp->Release();
        }
    }

    WimpyDraw(pux, i, _hdcImage, dx, dy, ILD_TRANSPARENT | ILD_PRESERVEALPHA);

    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
        SetItemFlags(i, _HasAlpha(i)? ILIF_ALPHA : 0);
}

HRESULT CImageList::_Merge(int i1, IUnknown* punk, int i2, int dx, int dy, CImageList** ppiml)
{
    CImageList* pimlNew = NULL;
    IImageListPriv* puxp;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IImageListPriv, &puxp));
    if (SUCCEEDED(hr))
    {
        IImageList* pux;
        hr = punk->QueryInterface(IID_PPV_ARG(IImageList, &pux));
        if (SUCCEEDED(hr))
        {
            RECT rcNew;
            RECT rc1;
            RECT rc2;
            int cxI, cyI;
            int c1, c2;
            UINT wFlags;
            UINT uSrcFlags;

            puxp->GetFlags(&uSrcFlags);
            pux->GetIconSize(&cxI, &cyI);

            ENTERCRITICAL;

            SetRect(&rc1, 0, 0, _cx, _cy);
            SetRect(&rc2, dx, dy, cxI + dx, cyI + dy);
            UnionRect(&rcNew, &rc1, &rc2);

            cxI = RECTWIDTH(rcNew);
            cyI = RECTHEIGHT(rcNew);

            //
            // If one of images are shared, create a shared image.
            //
            wFlags = (_flags | uSrcFlags) & ~ILC_COLORMASK;

            c1 = (_flags & ILC_COLORMASK);
            c2 = (uSrcFlags & ILC_COLORMASK);

            if ((c1 == 16 || c1 == 32) && c2 == ILC_COLORDDB)
            {
                c2 = c1;
            }

            wFlags |= max(c1,c2);

            pimlNew = CImageList::Create(cxI, cyI, ILC_MASK|wFlags, 1, 0);
            if (pimlNew)
            {
                pimlNew->_cImage++;

                if (pimlNew->_hdcMask) 
                    PatBlt(pimlNew->_hdcMask,  0, 0, cxI, cyI, WHITENESS);
                PatBlt(pimlNew->_hdcImage, 0, 0, cxI, cyI, BLACKNESS);

                pimlNew->_Merge(SAFECAST(this, IImageList*), i1, rc1.left - rcNew.left, rc1.top - rcNew.top);
                pimlNew->_Merge(pux, i2, rc2.left - rcNew.left, rc2.top - rcNew.top);
            }
            else
                hr = E_OUTOFMEMORY;

            LEAVECRITICAL;
            pux->Release();
        }
        puxp->Release();
    }

    *ppiml = pimlNew;

    return hr;
}

HRESULT CImageList::Merge(int i1, IUnknown* punk, int i2, int dx, int dy, REFIID riid, void** ppv)
{
    CImageList* piml;
    HRESULT hr = _Merge(i1, punk, i2, dx, dy, &piml);

    if (piml)
    {
        hr = piml->QueryInterface(riid, ppv);
        piml->Release();
    }

    return hr;
}

HRESULT CImageList::GetImageRectInverted(int i, RECT * prcImage)
{
    int x, y;
    ASSERT(prcImage);
    ASSERT(_cStrip == 1);   // If not, modify below to accomodate

    if (!prcImage || !IsImageListIndex(i))
        return E_FAIL;

    x = 0;
    y = (_cy * _cAlloc) - (_cy * i) - _cy;

    SetRect(prcImage, x, y, x + _cx, y + _cy);
    return S_OK;
}

HRESULT CImageList::GetImageRect(int i, RECT * prcImage)
{
    int x, y;
    ASSERT(prcImage);

    if (!prcImage || !IsImageListIndex(i))
        return E_FAIL;

    x = _cx * (i % _cStrip);
    y = _cy * (i / _cStrip);

    SetRect(prcImage, x, y, x + _cx, y + _cy);
    return S_OK;
}


BOOL CImageList::GetSpareImageRect(RECT * prcImage)
{
    BOOL fRet = FALSE;
    if (_cImage < _cAlloc)
    {
        // special hacking to use the one scratch image at tail of list :)
        _cImage++;
        fRet = (S_OK == GetImageRect(_cImage-1, prcImage));
        _cImage--;
    }

    return fRet;
}

BOOL CImageList::GetSpareImageRectInverted(RECT * prcImage)
{
    BOOL fRet = FALSE;
    if (_cImage < _cAlloc)
    {
        // special hacking to use the one scratch image at tail of list :)
        _cImage++;
        fRet = (S_OK == GetImageRectInverted(_cImage-1, prcImage));
        _cImage--;
    }

    return fRet;
}


// Drag Drop
// copy an image from one imagelist to another at x,y within iDst in pimlDst.
// pimlDst's image size should be larger than pimlSrc
void CImageList::_CopyOneImage(int iDst, int x, int y, CImageList* piml, int iSrc)
{
    RECT rcSrc, rcDst;


    piml->GetImageRect(iSrc, &rcSrc);
    GetImageRect(iDst, &rcDst);

    if (piml->_hdcMask && _hdcMask)
    {
        BitBlt(_hdcMask, rcDst.left + x, rcDst.top + y, piml->_cx, piml->_cy,
               piml->_hdcMask, rcSrc.left, rcSrc.top, SRCCOPY);

    }

    BitBlt(_hdcImage, rcDst.left + x, rcDst.top + y, piml->_cx, piml->_cy,
           piml->_hdcImage, rcSrc.left, rcSrc.top, SRCCOPY);


    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
        SetItemFlags(iDst, _HasAlpha(iDst)? ILIF_ALPHA : 0);
}


//
//  Cached bitmaps that we use during drag&drop. We re-use those bitmaps
// across multiple drag session as far as the image size is the same.
//
struct DRAGRESTOREBMP 
{
    int     BitsPixel;
    HBITMAP hbmOffScreen;
    HBITMAP hbmRestore;
    SIZE    sizeRestore;
} 
g_drb = 
{
    0, NULL, NULL, {-1,-1}
};

BOOL CImageList::CreateDragBitmaps()
{
    HDC hdc;

    hdc = GetDC(NULL);

    if (_cx != g_drb.sizeRestore.cx ||
        _cy != g_drb.sizeRestore.cy ||
        GetDeviceCaps(hdc, BITSPIXEL) != g_drb.BitsPixel)
    {
        ImageList_DeleteDragBitmaps();

        g_drb.BitsPixel      = GetDeviceCaps(hdc, BITSPIXEL);
        g_drb.sizeRestore.cx = _cx;
        g_drb.sizeRestore.cy = _cy;
        g_drb.hbmRestore   = CreateColorBitmap(g_drb.sizeRestore.cx, g_drb.sizeRestore.cy);
        g_drb.hbmOffScreen = CreateColorBitmap(g_drb.sizeRestore.cx * 2 - 1, g_drb.sizeRestore.cy * 2 - 1);


        if (!g_drb.hbmRestore || !g_drb.hbmOffScreen)
        {
            ImageList_DeleteDragBitmaps();
            ReleaseDC(NULL, hdc);
            return FALSE;
        }
    }
    ReleaseDC(NULL, hdc);
    return TRUE;
}

void ImageList_DeleteDragBitmaps()
{
    if (g_drb.hbmRestore)
    {
        CImageList::_DeleteBitmap(g_drb.hbmRestore);
        g_drb.hbmRestore = NULL;
    }
    if (g_drb.hbmOffScreen)
    {
        CImageList::_DeleteBitmap(g_drb.hbmOffScreen);
        g_drb.hbmOffScreen = NULL;
    }

    g_drb.sizeRestore.cx = -1;
    g_drb.sizeRestore.cy = -1;
}

//
//  Drag context. We don't reuse none of them across two different
// drag sessions. I'm planning to allocate it for each session
// to minimize critical sections.
//
struct DRAGCONTEXT 
{
    CImageList* pimlDrag;    // Image to be drawin while dragging
    IImageList* puxCursor;  // Overlap cursor image
    CImageList* pimlDither;  // Dithered image
    IImageList* puxDragImage; // The context of the drag.
    int        iCursor;     // Image index of the cursor
    POINT      ptDrag;      // current drag position (hwndDC coords)
    POINT      ptDragHotspot;
    POINT      ptCursor;
    BOOL       fDragShow;
    BOOL       fHiColor;
    HWND       hwndDC;
} 
g_dctx = 
{
    (CImageList*)NULL, (CImageList*)NULL, (CImageList*)NULL, (IImageList*)NULL,
    -1,
    {0, 0}, {0, 0}, {0, 0},
    FALSE,
    FALSE,
    (HWND)NULL
};

HDC ImageList_GetDragDC()
{
    HDC hdc = GetDCEx(g_dctx.hwndDC, NULL, DCX_WINDOW | DCX_CACHE | DCX_LOCKWINDOWUPDATE);
    //
    // If hdc is mirrored then mirror the 2 globals DCs.
    //
    if (IS_DC_RTL_MIRRORED(hdc)) 
    {
        SET_DC_RTL_MIRRORED(g_hdcDst);
        SET_DC_RTL_MIRRORED(g_hdcSrc);
    }
    return hdc;
}

void ImageList_ReleaseDragDC(HDC hdc)
{
    //
    // If the hdc is mirrored then unmirror the 2 globals DCs.
    //
    if (IS_DC_RTL_MIRRORED(hdc)) 
    {
        SET_DC_LAYOUT(g_hdcDst, 0);
        SET_DC_LAYOUT(g_hdcSrc, 0);
    }

    ReleaseDC(g_dctx.hwndDC, hdc);
}

//
//  x, y     -- Specifies the initial cursor position in the coords of hwndLock,
//              which is specified by the previous ImageList_StartDrag call.
//
HRESULT CImageList::DragMove(int x, int y)
{
    int IncOne = 0;
    ENTERCRITICAL;
    if (g_dctx.fDragShow)
    {
        RECT rcOld, rcNew, rcBounds;
        int dx, dy;

        dx = x - g_dctx.ptDrag.x;
        dy = y - g_dctx.ptDrag.y;
        rcOld.left = g_dctx.ptDrag.x - g_dctx.ptDragHotspot.x;
        rcOld.top = g_dctx.ptDrag.y - g_dctx.ptDragHotspot.y;
        rcOld.right = rcOld.left + g_drb.sizeRestore.cx;
        rcOld.bottom = rcOld.top + g_drb.sizeRestore.cy;
        rcNew = rcOld;
        OffsetRect(&rcNew, dx, dy);

        if (!IntersectRect(&rcBounds, &rcOld, &rcNew))
        {
            //
            // No intersection. Simply hide the old one and show the new one.
            //
            ImageList_DragShowNolock(FALSE);
            g_dctx.ptDrag.x = x;
            g_dctx.ptDrag.y = y;
            ImageList_DragShowNolock(TRUE);
        }
        else
        {
            //
            // Some intersection.
            //
            HDC hdcScreen;
            int cx, cy;

            UnionRect(&rcBounds, &rcOld, &rcNew);

            hdcScreen = ImageList_GetDragDC();
            if (hdcScreen)
            {
                //
                // If the DC is RTL mirrored, then restrict the
                // screen bitmap  not to go beyond the screen since 
                // we will end up copying the wrong bits from the
                // hdcScreen to the hbmOffScreen when the DC is mirrored.
                // GDI will skip invalid screen coord from the screen into
                // the destination bitmap. This will result in copying un-init
                // bits back to the screen (since the screen is mirrored).
                // [samera]
                //
                if (IS_DC_RTL_MIRRORED(hdcScreen))
                {
                    RECT rcWindow;
                    GetWindowRect(g_dctx.hwndDC, &rcWindow);
                    rcWindow.right -= rcWindow.left;

                    if (rcBounds.right > rcWindow.right)
                    {
                        rcBounds.right = rcWindow.right;
                    }

                    if (rcBounds.left < 0)
                    {
                        rcBounds.left = 0;
                    }
                }

                cx = rcBounds.right - rcBounds.left;
                cy = rcBounds.bottom - rcBounds.top;

                //
                // Copy the union rect from the screen to hbmOffScreen.
                //
                CImageList::SelectDstBitmap(g_drb.hbmOffScreen);
                BitBlt(g_hdcDst, 0, 0, cx, cy,
                        hdcScreen, rcBounds.left, rcBounds.top, SRCCOPY);

                //
                // Hide the cursor on the hbmOffScreen by copying hbmRestore.
                //
                CImageList::SelectSrcBitmap(g_drb.hbmRestore);
                BitBlt(g_hdcDst,
                        rcOld.left - rcBounds.left,
                        rcOld.top - rcBounds.top,
                        g_drb.sizeRestore.cx, g_drb.sizeRestore.cy,
                        g_hdcSrc, 0, 0, SRCCOPY);

                //
                // Copy the original screen bits to hbmRestore
                //
                BitBlt(g_hdcSrc, 0, 0, g_drb.sizeRestore.cx, g_drb.sizeRestore.cy,
                        g_hdcDst,
                        rcNew.left - rcBounds.left,
                        rcNew.top - rcBounds.top,
                        SRCCOPY);

                //
                // Draw the image on hbmOffScreen
                //
                if (g_dctx.fHiColor)
                {
                    WimpyDrawEx(SAFECAST(g_dctx.pimlDrag, IImageList*), 0, g_hdcDst,
                            rcNew.left - rcBounds.left + IncOne,
                            rcNew.top - rcBounds.top, 0, 0, CLR_NONE, CLR_NONE, ILD_BLEND50);

                    if (g_dctx.puxCursor)
                    {
                        WimpyDraw(g_dctx.puxCursor, g_dctx.iCursor, g_hdcDst,
                                rcNew.left - rcBounds.left + g_dctx.ptCursor.x + IncOne,
                                rcNew.top - rcBounds.top + g_dctx.ptCursor.y,
                                ILD_NORMAL);
                            
                    }
                }
                else
                {
                    WimpyDraw(SAFECAST(g_dctx.pimlDrag, IImageList*), 0, g_hdcDst,
                            rcNew.left - rcBounds.left + IncOne,
                            rcNew.top - rcBounds.top, ILD_NORMAL);
                }

                //
                // Copy the hbmOffScreen back to the screen.
                //
                BitBlt(hdcScreen, rcBounds.left, rcBounds.top, cx, cy,
                        g_hdcDst, 0, 0, SRCCOPY);

                ImageList_ReleaseDragDC(hdcScreen);
            }
            g_dctx.ptDrag.x = x;
            g_dctx.ptDrag.y = y;
        }
    }
    LEAVECRITICAL;
    return S_OK;
}

HRESULT CImageList::BeginDrag(int iTrack, int dxHotspot, int dyHotspot)
{
    HRESULT hr = E_ACCESSDENIED;
    ENTERCRITICAL;
    if (!g_dctx.pimlDrag)
    {
        UINT newflags;
        int cxI = 0, cyI = 0;

        g_dctx.fDragShow = FALSE;
        g_dctx.hwndDC = NULL;
        g_dctx.fHiColor = GetScreenDepth() > 8;

        newflags = _flags|ILC_SHARED;

        if (g_dctx.fHiColor)
        {
            UINT uColorFlag = ILC_COLOR16;
            if (GetScreenDepth() == 32 || GetScreenDepth() == 24)
            {
                uColorFlag = ILC_COLOR32;
            }

            newflags = (newflags & ~ILC_COLORMASK) | uColorFlag;
        }


        g_dctx.pimlDither = CImageList::Create(_cx, _cy, newflags, 1, 0);

        if (g_dctx.pimlDither)
        {
            g_dctx.pimlDither->_cImage++;
            g_dctx.ptDragHotspot.x = dxHotspot;
            g_dctx.ptDragHotspot.y = dyHotspot;

            g_dctx.pimlDither->_CopyOneImage(0, 0, 0, this, iTrack);

            hr = ImageList_SetDragImage(NULL, 0, dxHotspot, dyHotspot)? S_OK : E_FAIL;
        }
    }
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::DragEnter(HWND hwndLock, int x, int y)
{
    HRESULT hr = S_FALSE;

    hwndLock = hwndLock ? hwndLock : GetDesktopWindow();

    ENTERCRITICAL;
    if (!g_dctx.hwndDC)
    {
        g_dctx.hwndDC = hwndLock;

        g_dctx.ptDrag.x = x;
        g_dctx.ptDrag.y = y;

        ImageList_DragShowNolock(TRUE);
        hr = S_OK;
    }
    LEAVECRITICAL;

    return hr;
}


HRESULT CImageList::DragLeave(HWND hwndLock)
{
    HRESULT hr = S_FALSE;

    hwndLock = hwndLock ? hwndLock : GetDesktopWindow();

    ENTERCRITICAL;
    if (g_dctx.hwndDC == hwndLock)
    {
        ImageList_DragShowNolock(FALSE);
        g_dctx.hwndDC = NULL;
        hr = S_OK;
    }
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::DragShowNolock(BOOL fShow)
{
    HDC hdcScreen;
    int x, y;
    int IncOne = 0;

    x = g_dctx.ptDrag.x - g_dctx.ptDragHotspot.x;
    y = g_dctx.ptDrag.y - g_dctx.ptDragHotspot.y;

    if (!g_dctx.pimlDrag)
        return E_ACCESSDENIED;

    //
    // REVIEW: Why this block is in the critical section? We are supposed
    //  to have only one dragging at a time, aren't we?
    //
    ENTERCRITICAL;
    if (fShow && !g_dctx.fDragShow)
    {
        hdcScreen = ImageList_GetDragDC();

        CImageList::SelectSrcBitmap(g_drb.hbmRestore);

        BitBlt(g_hdcSrc, 0, 0, g_drb.sizeRestore.cx, g_drb.sizeRestore.cy,
                hdcScreen, x, y, SRCCOPY);

        if (g_dctx.fHiColor)
        {
            WimpyDrawEx(SAFECAST(g_dctx.pimlDrag, IImageList*), 0, hdcScreen, x + IncOne, y, 0, 0, CLR_NONE, CLR_NONE, ILD_BLEND50);
            
            if (g_dctx.puxCursor)
            {
                WimpyDraw(g_dctx.puxCursor, g_dctx.iCursor, hdcScreen,
                    x + g_dctx.ptCursor.x + IncOne, y + g_dctx.ptCursor.y, ILD_NORMAL);
            }
        }
        else
        {
            WimpyDraw(SAFECAST(g_dctx.pimlDrag, IImageList*), 0, hdcScreen, x + IncOne, y, ILD_NORMAL);
        }

        ImageList_ReleaseDragDC(hdcScreen);
    }
    else if (!fShow && g_dctx.fDragShow)
    {
        hdcScreen = ImageList_GetDragDC();

        CImageList::SelectSrcBitmap(g_drb.hbmRestore);

        BitBlt(hdcScreen, x, y, g_drb.sizeRestore.cx, g_drb.sizeRestore.cy,
                g_hdcSrc, 0, 0, SRCCOPY);

        ImageList_ReleaseDragDC(hdcScreen);
    }

    g_dctx.fDragShow = fShow;
    LEAVECRITICAL;

    return S_OK;
}

// this hotspot stuff is broken in design
BOOL ImageList_MergeDragImages(int dxHotspot, int dyHotspot)
{
    CImageList* pimlNew;
    BOOL fRet = FALSE;

    if (g_dctx.pimlDither)
    {
        if (g_dctx.puxCursor)
        {
            IImageList* pux = NULL;
            IImageListPriv* puxpCursor;
            if (SUCCEEDED(g_dctx.puxCursor->QueryInterface(IID_PPV_ARG(IImageListPriv, &puxpCursor))))
            {
                // If the cursor list has a mirrored list, let's use that.
                if (FAILED(puxpCursor->GetMirror(IID_PPV_ARG(IImageList, &pux))))
                {
                    pux = g_dctx.puxCursor;
                    if (pux)
                        pux->AddRef();
                }
                puxpCursor->Release();
            }
            g_dctx.pimlDither->_Merge(0, pux, g_dctx.iCursor, dxHotspot, dyHotspot, &pimlNew);

            if (pimlNew && pimlNew->CreateDragBitmaps())
            {
                // WARNING: Don't destroy pimlDrag if it is pimlDither.
                if (g_dctx.pimlDrag && (g_dctx.pimlDrag != g_dctx.pimlDither))
                {
                    g_dctx.pimlDrag->Release();
                }

                g_dctx.pimlDrag = pimlNew;
                fRet = TRUE;
            }

            pux->Release();
        }
        else
        {
            if (g_dctx.pimlDither->CreateDragBitmaps())
            {
                g_dctx.pimlDrag = g_dctx.pimlDither;
                fRet = TRUE;
            }
        }
    } 
    else 
    {
        // not an error case if both aren't set yet
        // only an error if we actually tried the merge and failed
        fRet = TRUE;
    }

    return fRet;
}

BOOL ImageList_SetDragImage(HIMAGELIST piml, int i, int dxHotspot, int dyHotspot)
{
    BOOL fVisible = g_dctx.fDragShow;
    BOOL fRet;

    ENTERCRITICAL;
    if (fVisible)
        ImageList_DragShowNolock(FALSE);

    // only do this last step if everything is there.
    fRet = ImageList_MergeDragImages(dxHotspot, dyHotspot);

    if (fVisible)
        ImageList_DragShowNolock(TRUE);

    LEAVECRITICAL;
    return fRet;
}

HRESULT CImageList::GetDragImage(POINT * ppt, POINT * pptHotspot, REFIID riid, void** ppv)
{
    if (ppt)
    {
        ppt->x = g_dctx.ptDrag.x;
        ppt->y = g_dctx.ptDrag.y;
    }
    if (pptHotspot)
    {
        pptHotspot->x = g_dctx.ptDragHotspot.x;
        pptHotspot->y = g_dctx.ptDragHotspot.y;
    }
    if (g_dctx.pimlDrag)
    {
        return g_dctx.pimlDrag->QueryInterface(riid, ppv);
    }

    return E_ACCESSDENIED;
}


HRESULT CImageList::GetItemFlags(int i, DWORD *dwFlags)
{
    if (IsImageListIndex(i) && _dsaFlags)
    {
        *dwFlags = _GetItemFlags(i);
        return S_OK;
    }

    return E_INVALIDARG;
}

HRESULT CImageList::GetOverlayImage(int iOverlay, int* piIndex)
{
    if (iOverlay <= 0 || iOverlay >= NUM_OVERLAY_IMAGES)
        return E_INVALIDARG;
        
    *piIndex = _aOverlayIndexes[iOverlay - 1];
    return S_OK;
}


HRESULT CImageList::SetDragCursorImage(IUnknown* punk, int i, int dxHotspot, int dyHotspot)
{
    HRESULT hr = E_INVALIDARG;
    BOOL fVisible = g_dctx.fDragShow;
    IImageList* pux;

    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IImageList, &pux))))
    {
        ENTERCRITICAL;

        // do work only if something has changed
        if ((g_dctx.puxCursor != pux) || (g_dctx.iCursor != i)) 
        {

            if (fVisible)
                ImageList_DragShowNolock(FALSE);

            IImageList* puxOld = g_dctx.puxCursor;
            g_dctx.puxCursor = pux;
            g_dctx.puxCursor->AddRef();

            if (puxOld)
                puxOld->Release();
            g_dctx.iCursor = i;
            g_dctx.ptCursor.x = dxHotspot;
            g_dctx.ptCursor.y = dyHotspot;

            hr = ImageList_MergeDragImages(dxHotspot, dyHotspot)? S_OK : E_FAIL;

            if (fVisible)
                ImageList_DragShowNolock(TRUE);
        }
        LEAVECRITICAL;

        pux->Release();
    }
    return hr;
}

HRESULT CImageList::EndDrag()
{
    ENTERCRITICAL;
    ImageList_DragShowNolock(FALSE);

    // WARNING: Don't destroy pimlDrag if it is pimlDither.
    if (g_dctx.pimlDrag && (g_dctx.pimlDrag != g_dctx.pimlDither))
    {
        g_dctx.pimlDrag->Release();
    }
    g_dctx.pimlDrag = NULL;

    if (g_dctx.pimlDither)
    {
        g_dctx.pimlDither->Release();
        g_dctx.pimlDither = NULL;
    }

    if (g_dctx.puxCursor)
    {
        g_dctx.puxCursor->Release();
        g_dctx.puxCursor = NULL;
    }

    g_dctx.iCursor = -1;
    g_dctx.hwndDC = NULL;
    LEAVECRITICAL;

    return S_OK;
}


// APIs

BOOL WINAPI ImageList_SetDragCursorImage(HIMAGELIST piml, int i, int dxHotspot, int dyHotspot)
{
    BOOL fRet = FALSE;
    IUnknown* punk;
    HRESULT hr = HIMAGELIST_QueryInterface(piml, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        if (g_dctx.puxDragImage)
        {
            fRet = (S_OK == g_dctx.puxDragImage->SetDragCursorImage(punk, i, dxHotspot, dyHotspot));
        }

        punk->Release();
    }

    return fRet;
}

HIMAGELIST WINAPI ImageList_GetDragImage(POINT * ppt, POINT * pptHotspot)
{
    if (g_dctx.puxDragImage)
    {
        IImageList* punk = NULL;
        if (SUCCEEDED(g_dctx.puxDragImage->GetDragImage(ppt, pptHotspot, IID_PPV_ARG(IImageList, &punk))))
        {
            punk->Release();
        }

        return reinterpret_cast<HIMAGELIST>(punk);
    }

    return NULL;
}



void WINAPI ImageList_EndDrag()
{
    ENTERCRITICAL;
    if (g_dctx.puxDragImage)
    {
        g_dctx.puxDragImage->EndDrag();
        g_dctx.puxDragImage->Release();
        g_dctx.puxDragImage = NULL;
    }
    LEAVECRITICAL;
}


BOOL WINAPI ImageList_BeginDrag(HIMAGELIST pimlTrack, int iTrack, int dxHotspot, int dyHotspot)
{
    IImageList* pux;

    if (SUCCEEDED(HIMAGELIST_QueryInterface(pimlTrack, IID_PPV_ARG(IImageList, &pux))))
    {
        if (SUCCEEDED(pux->BeginDrag(iTrack, dxHotspot, dyHotspot)))
        {
            g_dctx.puxDragImage = pux;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL WINAPI ImageList_DragEnter(HWND hwndLock, int x, int y)
{
    BOOL fRet = FALSE;
    if (g_dctx.puxDragImage)
    {
        fRet = (S_OK == g_dctx.puxDragImage->DragEnter(hwndLock, x, y));
    }

    return fRet;
}

BOOL WINAPI ImageList_DragMove(int x, int y)
{
    BOOL fRet = FALSE;
    if (g_dctx.puxDragImage)
    {
        fRet = (S_OK == g_dctx.puxDragImage->DragMove(x, y));
    }

    return fRet;
}

BOOL WINAPI ImageList_DragLeave(HWND hwndLock)
{
    BOOL fRet = FALSE;
    if (g_dctx.puxDragImage)
    {
        fRet = (S_OK == g_dctx.puxDragImage->DragLeave(hwndLock));
    }

    return fRet;
}

BOOL WINAPI ImageList_DragShowNolock(BOOL fShow)
{
    BOOL fRet = FALSE;
    if (g_dctx.puxDragImage)
    {
        fRet = (S_OK == g_dctx.puxDragImage->DragShowNolock(fShow));
    }

    return fRet;
}


//============================================================================
// ImageList_Clone - clone a image list
//
// create a new imagelist with the same properties as the given
// imagelist, except mabey a new icon size
//
//      piml    - imagelist to clone
//      cx,cy   - new icon size (0,0) to use clone icon size.
//      flags   - new flags (used if no clone)
//      cInitial- initial size
//      cGrow   - grow value (used if no clone)
//============================================================================

EXTERN_C HIMAGELIST WINAPI ImageList_Clone(HIMAGELIST himl, int cx, int cy, UINT flags, int cInitial, int cGrow)
{
    IImageListPriv* puxp;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPriv, &puxp))))
    {
        // always use the clone flags
        puxp->GetFlags(&flags);
        
        IUnknown* punkMirror;
        if (SUCCEEDED(puxp->GetMirror(IID_PPV_ARG(IUnknown, &punkMirror))))
        {
            flags |= ILC_MIRROR;
            punkMirror->Release();
        }

        IImageList* pux;
        if (SUCCEEDED(puxp->QueryInterface(IID_PPV_ARG(IImageList, &pux))))
        {
            int cxI, cyI;
            pux->GetIconSize(&cxI, &cyI);

            if (cx == 0)           
                cx = cxI;
            if (cy == 0)           
                cy = cyI;

            pux->Release();
        }

        puxp->Release();
    }

    return ImageList_Create(cx,cy,flags,cInitial,cGrow);
}


HRESULT WINAPI ImageList_CreateInstance(int cx, int cy, UINT flags, int cInitial, int cGrow, REFIID riid, void** ppv)
{
    CImageList* piml=NULL;
    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    piml = CImageList::Create(cx, cy, flags, cInitial, cGrow);

    if (piml)
    {
        //
        // Let's create a mirrored imagelist, if requested.
        //
        if (piml->_flags & ILC_MIRROR)
        {
            piml->_flags &= ~ILC_MIRROR;
            piml->_pimlMirror = CImageList::Create(cx, cy, flags, cInitial, cGrow);
            if (piml->_pimlMirror)
            {
                piml->_pimlMirror->_flags &= ~ILC_MIRROR;
            }
        }

        hr = piml->QueryInterface(riid, ppv);
        piml->Release();
    }

    return hr;

}

HIMAGELIST WINAPI ImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow)
{
    IImageList* pux;
    ImageList_CreateInstance(cx, cy, flags, cInitial, cGrow, IID_PPV_ARG(IImageList, &pux));
    return reinterpret_cast<HIMAGELIST>(pux);
}

//
// When this code is compiled Unicode, this implements the
// ANSI version of the ImageList_LoadImage api.
//

HIMAGELIST WINAPI ImageList_LoadImageA(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags)
{
   HIMAGELIST lpResult;
   LPWSTR   lpBmpW;

   if (!IS_INTRESOURCE(lpbmp)) 
   {
       lpBmpW = ProduceWFromA(CP_ACP, lpbmp);

       if (!lpBmpW) 
       {
           return NULL;
       }

   }  
   else 
   {
       lpBmpW = (LPWSTR)lpbmp;
   }

   lpResult = ImageList_LoadImageW(hi, lpBmpW, cx, cGrow, crMask, uType, uFlags);

   if (!IS_INTRESOURCE(lpbmp))
       FreeProducedString(lpBmpW);

   return lpResult;
}

HIMAGELIST WINAPI ImageList_LoadImageW(HINSTANCE hi, LPCTSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags)
{
    HBITMAP hbmImage;
    HIMAGELIST piml = NULL;
    BITMAP bm;
    int cy, cInitial;
    UINT flags;

    hbmImage = (HBITMAP)LoadImage(hi, lpbmp, uType, 0, 0, uFlags);
    if (hbmImage && (sizeof(bm) == GetObject(hbmImage, sizeof(bm), &bm)))
    {
        // If cx is not stated assume it is the same as cy.
        // ASSERT(cx);
        cy = bm.bmHeight;

        if (cx == 0)
            cx = cy;

        cInitial = bm.bmWidth / cx;

        ENTERCRITICAL;

        flags = 0;
        if (crMask != CLR_NONE)
            flags |= ILC_MASK;
        if (bm.bmBits)
            flags |= (bm.bmBitsPixel & ILC_COLORMASK);

        piml = ImageList_Create(cx, cy, flags, cInitial, cGrow);
        if (piml)
        {
            int added;

            if (crMask == CLR_NONE)
                added = ImageList_Add(piml, hbmImage, NULL);
            else
                added = ImageList_AddMasked(piml, hbmImage, crMask);

            if (added < 0)
            {
                ImageList_Destroy(piml);
                piml = NULL;
            }
        }
        LEAVECRITICAL;
    }

    if (hbmImage)
        DeleteObject(hbmImage);

    return reinterpret_cast<HIMAGELIST>((IImageList*)piml);
}

//
//
#undef ImageList_AddIcon
EXTERN_C int WINAPI ImageList_AddIcon(HIMAGELIST himl, HICON hIcon)
{
    return ImageList_ReplaceIcon(himl, -1, hIcon);
}

EXTERN_C void WINAPI ImageList_CopyDitherImage(HIMAGELIST himlDst, WORD iDst,
    int xDst, int yDst, HIMAGELIST himlSrc, int iSrc, UINT fStyle)
{
    IImageListPriv* puxp;

    if (SUCCEEDED(HIMAGELIST_QueryInterface(himlDst, IID_PPV_ARG(IImageListPriv, &puxp))))
    {
        IUnknown* punk;
        if (SUCCEEDED(HIMAGELIST_QueryInterface(himlSrc, IID_PPV_ARG(IUnknown, &punk))))
        {
            puxp->CopyDitherImage(iDst, xDst, yDst, punk, iSrc, fStyle);
            punk->Release();
        }
        puxp->Release();
    }
}

//
// ImageList_Duplicate
//
// Makes a copy of the passed in imagelist.
//
HIMAGELIST  WINAPI ImageList_Duplicate(HIMAGELIST himl)
{
    IImageList* pret = NULL;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->Clone(IID_PPV_ARG(IImageList, &pret));
        pux->Release();
    }

    return reinterpret_cast<HIMAGELIST>(pret);
}

BOOL WINAPI ImageList_Write(HIMAGELIST himl, LPSTREAM pstm)
{
    BOOL fRet = FALSE;
    IPersistStream* pps;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IPersistStream, &pps))))
    {
        if (SUCCEEDED(pps->Save(pstm, TRUE)))
        {
            fRet = TRUE;
        }
        pps->Release();
    }

    return fRet;
}

HIMAGELIST WINAPI ImageList_Read(LPSTREAM pstm)
{
    CImageList* piml = new CImageList();
    if (piml)
    {
        if (SUCCEEDED(piml->Load(pstm)))
        {
            return reinterpret_cast<HIMAGELIST>((IImageList*)piml);
        }

        piml->Release();
    }

    return NULL;

}

WINCOMMCTRLAPI HRESULT WINAPI ImageList_ReadEx(DWORD dwFlags, LPSTREAM pstm, REFIID riid, PVOID* ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CImageList* piml = new CImageList();
    if (piml)
    {
        hr = piml->LoadEx(dwFlags, pstm);
        if (SUCCEEDED(hr))
        {
            hr = piml->QueryInterface(riid, ppv);
        }

        piml->Release();
    }

    return hr;
}

WINCOMMCTRLAPI HRESULT WINAPI ImageList_WriteEx(HIMAGELIST himl, DWORD dwFlags, LPSTREAM pstm)
{
    IImageListPersistStream* pps;
    HRESULT hr = HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPersistStream, &pps));
    if (SUCCEEDED(hr))
    {
        hr = pps->SaveEx(dwFlags, pstm);
        pps->Release();
    }

    return hr;

}

BOOL WINAPI ImageList_GetImageRect(HIMAGELIST himl, int i, RECT * prcImage)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        if (SUCCEEDED(pux->GetImageRect(i, prcImage)))
        {
            fRet = TRUE;
        }
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_Destroy(HIMAGELIST himl)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    // Weirdness: We are doing a Query Interface first to verify that 
    // this is actually a valid imagelist, then we are calling release twice
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        // Release the interface we QI'd for
        pux->Release();

        // Release a second time to destroy the object
        pux->Release();

        fRet = TRUE;
    }

    return fRet;
}

int         WINAPI ImageList_GetImageCount(HIMAGELIST himl)
{
    int fRet = 0;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->GetImageCount(&fRet);
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_SetImageCount(HIMAGELIST himl, UINT uNewCount)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->SetImageCount(uNewCount));
        pux->Release();
    }

    return fRet;
}
int         WINAPI ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask)
{
    int fRet = -1;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->Add(hbmImage, hbmMask, &fRet);
        pux->Release();
    }

    return fRet;
}

int         WINAPI ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon)
{
    int fRet = -1;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->ReplaceIcon(i, hicon, &fRet);
        pux->Release();
    }

    return fRet;
}

COLORREF    WINAPI ImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk)
{
    COLORREF fRet = clrBk;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->SetBkColor(clrBk, &fRet);
        pux->Release();
    }

    return fRet;
}

COLORREF    WINAPI ImageList_GetBkColor(HIMAGELIST himl)
{
    COLORREF fRet = RGB(0,0,0);
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->GetBkColor(&fRet);
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->SetOverlayImage(iImage, iOverlay));
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_Replace(HIMAGELIST himl, int i, HBITMAP hbmImage, HBITMAP hbmMask)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->Replace(i, hbmImage, hbmMask));
        pux->Release();
    }

    return fRet;
}

int         WINAPI ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask)
{
    int fRet = -1;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->AddMasked(hbmImage, crMask, &fRet);
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        IMAGELISTDRAWPARAMS imldp = {0};
        imldp.cbSize = sizeof(imldp);
        imldp.himl   = himl;
        imldp.i      = i;
        imldp.hdcDst = hdcDst;
        imldp.x      = x;
        imldp.y      = y;
        imldp.cx     = dx;
        imldp.cy     = dy;
        imldp.rgbBk  = rgbBk;
        imldp.rgbFg  = rgbFg;
        imldp.fStyle = fStyle;

        fRet = (S_OK == pux->Draw(&imldp));
        pux->Release();
    }

    return fRet;
}

BOOL WINAPI ImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        IMAGELISTDRAWPARAMS imldp = {0};
        imldp.cbSize = sizeof(imldp);
        imldp.himl   = himl;
        imldp.i      = i;
        imldp.hdcDst = hdcDst;
        imldp.x      = x;
        imldp.y      = y;
        imldp.rgbBk  = CLR_DEFAULT;
        imldp.rgbFg  = CLR_DEFAULT;
        imldp.fStyle = fStyle;
    
        fRet = (S_OK == pux->Draw(&imldp));
        pux->Release();
    }

    return fRet;
}



// Note: no distinction between failure case (bad himl) and no flags set
DWORD      WINAPI ImageList_GetItemFlags(HIMAGELIST himl, int i)
{
    DWORD dwFlags = 0;

    if (himl)
    {
        IImageList* pux;
        if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
        {
            pux->GetItemFlags(i, &dwFlags);
            pux->Release();
        }
    }

    return dwFlags;
}



BOOL        WINAPI ImageList_DrawIndirect(IMAGELISTDRAWPARAMS* pimldp)
{
    BOOL fRet = FALSE;
    IImageList* pux;

    if (!pimldp)
        return fRet;

    if (SUCCEEDED(HIMAGELIST_QueryInterface(pimldp->himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->Draw(pimldp));
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_Remove(HIMAGELIST himl, int i)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->Remove(i));
        pux->Release();
    }

    return fRet;
}

HICON       WINAPI ImageList_GetIcon(HIMAGELIST himl, int i, UINT flags)
{
    HICON fRet = NULL;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->GetIcon(i, flags, &fRet);
        pux->Release();
    }

    return fRet;
}
BOOL        WINAPI ImageList_Copy(HIMAGELIST himlDst, int iDst, HIMAGELIST himlSrc, int iSrc, UINT uFlags)
{
    BOOL fRet = FALSE;

    if (himlDst == himlSrc)
    {
        IImageList* pux;
        if (SUCCEEDED(HIMAGELIST_QueryInterface(himlDst, IID_PPV_ARG(IImageList, &pux))))
        {
            fRet = (S_OK == pux->Copy(iDst,(IUnknown*)pux, iSrc, uFlags));
            pux->Release();
        }

    }

    return fRet;
}

BOOL        WINAPI ImageList_GetIconSize(HIMAGELIST himl, int *cx, int *cy)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->GetIconSize(cx, cy));
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_SetIconSize(HIMAGELIST himl, int cx, int cy)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->SetIconSize(cx, cy));
        pux->Release();
    }

    return fRet;
}
BOOL        WINAPI ImageList_GetImageInfo(HIMAGELIST himl, int i, IMAGEINFO* pImageInfo)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->GetImageInfo(i, pImageInfo));
        pux->Release();
    }

    return fRet;
}

HIMAGELIST  WINAPI ImageList_Merge(HIMAGELIST himl1, int i1, HIMAGELIST himl2, int i2, int dx, int dy)
{
    IImageList* fRet = NULL;
    IImageList* pux1;
    IImageList* pux2;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl1, IID_PPV_ARG(IImageList, &pux1))))
    {
        if (SUCCEEDED(HIMAGELIST_QueryInterface(himl2, IID_PPV_ARG(IImageList, &pux2))))
        {
            pux1->Merge(i1, (IUnknown*)pux2, i2, dx, dy, IID_PPV_ARG(IImageList, &fRet));
            pux2->Release();

        }
        pux1->Release();
    }

    return reinterpret_cast<HIMAGELIST>(fRet);
}

BOOL        WINAPI ImageList_SetFlags(HIMAGELIST himl, UINT flags)
{
    BOOL fRet = FALSE;
    IImageListPriv* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPriv, &pux))))
    {
        fRet = (S_OK == pux->SetFlags(flags));
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_SetFilter(HIMAGELIST himl, PFNIMLFILTER pfnFilter, LPARAM lParamFilter)
{
    return FALSE;
}

int         ImageList_SetColorTable(HIMAGELIST himl, int start, int len, RGBQUAD *prgb)
{
    int fRet = -1;
    IImageListPriv* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPriv, &pux))))
    {
        pux->SetColorTable(start, len, prgb, &fRet);
        pux->Release();
    }

    return fRet;
}

UINT        WINAPI ImageList_GetFlags(HIMAGELIST himl)
{
    UINT fRet = 0;
    IImageListPriv* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPriv, &pux))))
    {
        pux->GetFlags(&fRet);
        pux->Release();
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\ipaddr.c ===
/* Copyright (c) 1991, Microsoft Corporation, all rights reserved

 ipaddr.c - TCP/IP Address custom control

 November 9, 1992    Greg Strange
 */

#include "ctlspriv.h"


// The character that is displayed between address fields.
#define FILLER          TEXT('.')
#define SZFILLER        TEXT(".")
#define SPACE           TEXT(' ')
#define BACK_SPACE      8

/* Min, max values */
#define NUM_FIELDS      4
#define CHARS_PER_FIELD 3
#define HEAD_ROOM       1       // space at top of control
#define LEAD_ROOM       3       // space at front of control
#define MIN_FIELD_VALUE 0       // default minimum allowable field value
#define MAX_FIELD_VALUE 255     // default maximum allowable field value


// All the information unique to one control is stuffed in one of these
// structures in global memory and the handle to the memory is stored in the
// Windows extra space.

typedef struct tagFIELD {
    HANDLE      hWnd;
    WNDPROC     lpfnWndProc;
    BYTE        byLow;  // lowest allowed value for this field.
    BYTE        byHigh; // Highest allowed value for this field.
} FIELD;

typedef struct tagIPADDR
 {
    HWND        hwndParent;
    HWND        hwnd;
    UINT        uiFieldWidth;
    UINT        uiFillerWidth;
    BOOL        fEnabled : 1;
    BOOL        fPainted : 1;
    BOOL        bControlInFocus : 1;        // TRUE if the control is already in focus, dont't send another focus command
    BOOL        bCancelParentNotify : 1;    // Don't allow the edit controls to notify parent if TRUE
    BOOL        fInMessageBox : 1;  // Set when a message box is displayed so that
    BOOL        fFontCreated :1;
    HFONT       hfont;
    // we don't send a EN_KILLFOCUS message when
    // we receive the EN_KILLFOCUS message for the
    // current field.
    FIELD       Children[NUM_FIELDS];

    HTHEME      hTheme;
} IPADDR;


// The following macros extract and store the CONTROL structure for a control.
#define    IPADDRESS_EXTRA            sizeof(DWORD)

#define GET_IPADDR_HANDLE(hWnd)        ((HGLOBAL)(GetWindowLongPtr((hWnd), GWLP_USERDATA)))
#define SAVE_IPADDR_HANDLE(hWnd,x)     (SetWindowLongPtr((hWnd), GWLP_USERDATA, (LONG_PTR)(x)))


/* internal IPAddress function prototypes */
LRESULT IPAddressWndFn( HWND, UINT, WPARAM, LPARAM );
LRESULT IPAddressFieldProc(HWND, UINT, WPARAM, LPARAM);
BOOL SwitchFields(IPADDR *, int, int, WORD, WORD);
void EnterField(FIELD *, WORD, WORD);
BOOL ExitField(IPADDR *, int iField);
int GetFieldValue(FIELD *);
void SetFieldValue(IPADDR *pipa, int iField, int iValue);





/*
 IPAddrInit() - IPAddress custom control initialization
 call
 hInstance = library or application instance
 return
 TRUE on success, FALSE on failure.

 This function does all the one time initialization of IPAddress custom
 controls.  Specifically it creates the IPAddress window class.
 */
int InitIPAddr(HANDLE hInstance)
{
    WNDCLASS        wc;

    wc.lpszClassName = WC_IPADDRESS;
    wc.hCursor =       LoadCursor(NULL,IDC_IBEAM);
    wc.hIcon           = NULL;
    wc.lpszMenuName =  (LPCTSTR)NULL;
    wc.style =         CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS|CS_GLOBALCLASS;
    wc.lpfnWndProc =   IPAddressWndFn;
    wc.hInstance =     hInstance;
    wc.hIcon =         NULL;
    wc.cbWndExtra =    IPADDRESS_EXTRA;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1 );
    wc.cbClsExtra      = 0;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}


/*
 IPAddressWndFn() - Main window function for an IPAddress control.

 call
 hWnd    handle to IPAddress window
 wMsg    message number
 wParam  word parameter
 lParam  long parameter
 */

void FormatIPAddress(LPTSTR pszString, DWORD* dwValue)
{
    int nField, nPos;
    BOOL fFinish = FALSE;

    dwValue[0] = 0; dwValue[1] = 0; dwValue[2] = 0; dwValue[3] = 0;

    if (pszString[0] == 0)
        return;

    for( nField = 0, nPos = 0; !fFinish; nPos++)
    {
        if (( pszString[nPos]<TEXT('0')) || (pszString[nPos]>TEXT('9')))
        {
            // not a number
            nField++;
            fFinish = (nField == 4);
        }
        else
        {
            dwValue[nField] *= 10;
            dwValue[nField] += (pszString[nPos]-TEXT('0'));
        }
    }
}

void IP_OnSetFont(IPADDR* pipa, HFONT hfont, BOOL fRedraw)
{
    int i;
    RECT rect;
    HFONT OldFont;
    BOOL fNewFont = FALSE;
    UINT uiFieldStart;
    HDC hdc;
    
    if (hfont) {
        fNewFont = TRUE;
    } else {
        hfont = (HFONT)SendMessage(pipa->hwnd, WM_GETFONT, 0, 0);
    }
    
    hdc = GetDC(pipa->hwnd);
    OldFont = SelectObject(hdc, hfont);
    GetCharWidth(hdc, FILLER, FILLER,
                 (int *)(&pipa->uiFillerWidth));
    SelectObject(hdc, OldFont);
    ReleaseDC(pipa->hwnd, hdc);
    
    GetClientRect(pipa->hwnd, &rect);
    pipa->hfont = hfont;
    pipa->uiFieldWidth = (RECTWIDTH(rect)
                          - LEAD_ROOM
                          - pipa->uiFillerWidth
                          *(NUM_FIELDS-1))
        / NUM_FIELDS;


    uiFieldStart = LEAD_ROOM;

    for (i = 0; i < NUM_FIELDS; i++) {

        HWND hwnd = pipa->Children[i].hWnd;
        
        if (fNewFont)
            SendMessage(hwnd, WM_SETFONT, (WPARAM)hfont, (LPARAM)fRedraw);
        
        SetWindowPos(hwnd, NULL,
                     uiFieldStart,
                     HEAD_ROOM,
                     pipa->uiFieldWidth,
                     (rect.bottom-rect.top),
                     SWP_NOACTIVATE);

        uiFieldStart += pipa->uiFieldWidth
            + pipa->uiFillerWidth;

    }
    
}

LRESULT IPAddressWndFn( hWnd, wMsg, wParam, lParam )
    HWND            hWnd;
    UINT            wMsg;
    WPARAM            wParam;
    LPARAM            lParam;
{
    LRESULT lResult;
    IPADDR *pipa;
    int i;

    pipa = (IPADDR *)GET_IPADDR_HANDLE(hWnd);
    lResult = TRUE;

    switch( wMsg )
    {

        // use empty string (not NULL) to set to blank
        case WM_SETTEXT:
        {
            TCHAR szBuf[CHARS_PER_FIELD+1];
            DWORD dwValue[4];
            LPTSTR pszString = (LPTSTR)lParam;

            FormatIPAddress(pszString, &dwValue[0]);
            pipa->bCancelParentNotify = TRUE;

            for (i = 0; i < NUM_FIELDS; ++i)
            {
                if (pszString[0] == 0)
                {
                    szBuf[0] = 0;
                }
                else
                {
                    StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT("%d"), dwValue[i]);
                }
                SendMessage(pipa->Children[i].hWnd, WM_SETTEXT,
                            0, (LPARAM) (LPSTR) szBuf);
            }

            pipa->bCancelParentNotify = FALSE;

            SendMessage(pipa->hwndParent, WM_COMMAND,
                        MAKEWPARAM(GetDlgCtrlID(hWnd), EN_CHANGE), (LPARAM)hWnd);
        }
        break;

    case WM_GETTEXTLENGTH:
    case WM_GETTEXT:
    {
        int   iFieldValue;
        DWORD dwValue[4];
        TCHAR szResult[30];
        TCHAR *pszDest = (TCHAR *)lParam;

        lResult = 0;
        dwValue[0] = 0;
        dwValue[1] = 0;
        dwValue[2] = 0;
        dwValue[3] = 0;

        for (i = 0; i < NUM_FIELDS; ++i)
        {
            iFieldValue = GetFieldValue(&(pipa->Children[i]));
            if (iFieldValue == -1)
            {
                iFieldValue = 0;
            }
            else
            {
                ++lResult;
            }

            dwValue[i] = iFieldValue;
        }

        StringCchPrintf(szResult, ARRAYSIZE(szResult), TEXT("%d.%d.%d.%d"), dwValue[0], dwValue[1], dwValue[2], dwValue[3] );

        if (wMsg == WM_GETTEXT)
        {
            StringCchPrintf(pszDest, (int)wParam, szResult);
            lResult = lstrlen( pszDest );
        } 
        else 
        {
            lResult = lstrlen(szResult);
        }

        break;
    }
    case WM_GETDLGCODE :
        lResult = DLGC_WANTCHARS;
        break;

    case WM_NCCREATE:
        SetWindowBits(hWnd, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);
        SetWindowBits(hWnd, GWL_EXSTYLE, RTL_MIRRORED_WINDOW, 0);

        lResult = TRUE;
        break;

    case WM_THEMECHANGED:
        {
            if (pipa->hTheme)
                CloseThemeData(pipa->hTheme);
                
            pipa->hTheme = OpenThemeData(hWnd, L"Combobox");

            InvalidateRect(hWnd, NULL, TRUE);
        }
        break;


    case WM_CREATE : /* create pallette window */
    {
        LONG id;

        pipa = (IPADDR*)LocalAlloc(LPTR, sizeof(IPADDR));

        if (pipa)
        {
            CREATESTRUCT* pcs = ((CREATESTRUCT *)lParam);
            SAVE_IPADDR_HANDLE(hWnd, pipa);

            pipa->fEnabled = TRUE;
            pipa->hwndParent = pcs->hwndParent;
            pipa->hwnd = hWnd;
            pipa->hTheme = OpenThemeData(hWnd, L"Combobox");

            id = GetDlgCtrlID(hWnd);
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                pipa->Children[i].byLow = MIN_FIELD_VALUE;
                pipa->Children[i].byHigh = MAX_FIELD_VALUE;

                pipa->Children[i].hWnd = CreateWindowEx(0,
                                                        TEXT("Edit"),
                                                        NULL,
                                                        WS_CHILD |
                                                        ES_CENTER, 
                                                        0, 10, 100, 100,
                                                        hWnd,
                                                        (HMENU)(LONG_PTR)id,
                                                        pcs->hInstance,
                                                        (LPVOID)NULL);

                SAVE_IPADDR_HANDLE(pipa->Children[i].hWnd, i);
                SendMessage(pipa->Children[i].hWnd, EM_LIMITTEXT,
                            CHARS_PER_FIELD, 0L);

                pipa->Children[i].lpfnWndProc =
                    (WNDPROC) GetWindowLongPtr(pipa->Children[i].hWnd,
                                               GWLP_WNDPROC);

                SetWindowLongPtr(pipa->Children[i].hWnd,
                                 GWLP_WNDPROC, (LONG_PTR)IPAddressFieldProc);

            }

            IP_OnSetFont(pipa, NULL, FALSE);
            for (i = 0; i < NUM_FIELDS; ++i)
                ShowWindow(pipa->Children[i].hWnd, SW_SHOW);


#undef pcs
        }
        else
            DestroyWindow(hWnd);
    }
        lResult = 0;
        break;

    case WM_PAINT: /* paint IPADDR window */
    {
        PAINTSTRUCT Ps;
        RECT rect;
        COLORREF TextColor;
        COLORREF cRef;
        HFONT OldFont;

        BeginPaint(hWnd, (LPPAINTSTRUCT)&Ps);
        OldFont = SelectObject( Ps.hdc, pipa->hfont);
        GetClientRect(hWnd, &rect);
        if (pipa->fEnabled)
        {
            TextColor = GetSysColor(COLOR_WINDOWTEXT);
            cRef = GetSysColor(COLOR_WINDOW);
        }
        else
        {
            TextColor = GetSysColor(COLOR_GRAYTEXT);
            cRef = GetSysColor(COLOR_3DFACE);
        }

        FillRectClr(Ps.hdc, &rect, cRef);
        SetRect(&rect, 0, HEAD_ROOM, pipa->uiFillerWidth, (rect.bottom-rect.top));


        SetBkColor(Ps.hdc, cRef);
        SetTextColor(Ps.hdc, TextColor);

        for (i = 0; i < NUM_FIELDS-1; ++i)
        {
            rect.left += pipa->uiFieldWidth + pipa->uiFillerWidth;
            rect.right += rect.left + pipa->uiFillerWidth;
            ExtTextOut(Ps.hdc, rect.left, HEAD_ROOM, ETO_OPAQUE, &rect, SZFILLER, 1, NULL);
        }

        pipa->fPainted = TRUE;

        SelectObject(Ps.hdc, OldFont);
        EndPaint(hWnd, &Ps);
    }
        break;

    case WM_SETFOCUS : /* get focus - display caret */
        EnterField(&(pipa->Children[0]), 0, CHARS_PER_FIELD);
        break;
        
        HANDLE_MSG(pipa, WM_SETFONT, IP_OnSetFont);

    case WM_LBUTTONDOWN : /* left button depressed - fall through */
        SetFocus(hWnd);
        break;

    case WM_ENABLE:
    {
        pipa->fEnabled = (BOOL)wParam;
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            EnableWindow(pipa->Children[i].hWnd, (BOOL)wParam);
        }
        if (pipa->fPainted)    
            InvalidateRect(hWnd, NULL, FALSE);
    }
    break;

    case WM_NCPAINT:
        {
            if (pipa->hTheme)
            {
                HRGN hrgn = (wParam != 1) ? (HRGN)wParam : NULL;
                HBRUSH hbr = (HBRUSH)GetClassLongPtr(hWnd, GCLP_HBRBACKGROUND);

                if (CCDrawNonClientTheme(pipa->hTheme, hWnd, hrgn, hbr, 0, CBXS_NORMAL))
                {
                    return TRUE;
                }
            }
        }
        goto DoDefault;


    case WM_DESTROY :
        // Restore all the child window procedures before we delete our memory block.
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            SendMessage(pipa->Children[i].hWnd, WM_DESTROY, 0, 0);
            SetWindowLongPtr(pipa->Children[i].hWnd, GWLP_WNDPROC,
                             (LONG_PTR)pipa->Children[i].lpfnWndProc);
        }

        if (pipa->hTheme)
            CloseThemeData(pipa->hTheme);

        LocalFree(pipa);
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
            // One of the fields lost the focus, see if it lost the focus to another field
            // of if we've lost the focus altogether.  If its lost altogether, we must send
            // an EN_KILLFOCUS notification on up the ladder.
            case EN_KILLFOCUS:
            {
                HWND hFocus;

                if (!pipa->fInMessageBox)
                {
                    hFocus = GetFocus();
                    for (i = 0; i < NUM_FIELDS; ++i)
                        if (pipa->Children[i].hWnd == hFocus)
                            break;

                    if (i >= NUM_FIELDS)
                    {
                        SendMessage(pipa->hwndParent, WM_COMMAND,
                                    MAKEWPARAM(GetDlgCtrlID(hWnd),
                                               EN_KILLFOCUS), (LPARAM)hWnd);
                        pipa->bControlInFocus = FALSE;
                    }
                }
            }
            break;

        case EN_SETFOCUS:
        {
            HWND hFocus;

            if (!pipa->fInMessageBox)
            {
                hFocus = (HWND)lParam;

                for (i = 0; i < NUM_FIELDS; ++i)
                    if (pipa->Children[i].hWnd == hFocus)
                        break;

                // send a focus message when the
                if (i < NUM_FIELDS && pipa->bControlInFocus == FALSE)
                {
                    SendMessage(pipa->hwndParent, WM_COMMAND,
                                MAKEWPARAM(GetDlgCtrlID(hWnd),
                                           EN_SETFOCUS), (LPARAM)hWnd);

                    pipa->bControlInFocus = TRUE; // only set the focus once
                }
            }
        }
            break;

        case EN_CHANGE:
            if (pipa->bCancelParentNotify == FALSE)
            {
                SendMessage(pipa->hwndParent, WM_COMMAND,
                            MAKEWPARAM(GetDlgCtrlID(hWnd), EN_CHANGE), (LPARAM)hWnd);

            }
            break;
        }
        break;

        // Get the value of the IP Address.  The address is placed in the DWORD pointed
        // to by lParam and the number of non-blank fields is returned.
        case IPM_GETADDRESS:
        {
            int iFieldValue;
            DWORD dwValue;

            lResult = 0;
            dwValue = 0;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                iFieldValue = GetFieldValue(&(pipa->Children[i]));
                if (iFieldValue == -1)
                    iFieldValue = 0;
                else
                    ++lResult;
                dwValue = (dwValue << 8) + iFieldValue;
            }
            *((DWORD *)lParam) = dwValue;
        }
        break;

        // Clear all fields to blanks.
        case IPM_CLEARADDRESS:
        {
            pipa->bCancelParentNotify = TRUE;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                SendMessage(pipa->Children[i].hWnd, WM_SETTEXT,
                            0, (LPARAM) (LPSTR) TEXT(""));
            }
            pipa->bCancelParentNotify = FALSE;
            SendMessage(pipa->hwndParent, WM_COMMAND,
                        MAKEWPARAM(GetDlgCtrlID(hWnd), EN_CHANGE), (LPARAM)hWnd);
        }
        break;

        // Set the value of the IP Address.  The address is in the lParam with the
        // first address byte being the high byte, the second being the second byte,
        // and so on.  A lParam value of -1 removes the address.
        case IPM_SETADDRESS:
        {
            pipa->bCancelParentNotify = TRUE;

            for (i = 0; i < NUM_FIELDS; ++i)
            {
                BYTE bVal = HIBYTE(HIWORD(lParam));
                if (pipa->Children[i].byLow <= bVal &&
                    bVal <= pipa->Children[i].byHigh) {
                    SetFieldValue(pipa, i, bVal);

                } else {
                    lResult = FALSE;
                }

                lParam <<= 8;
            }

            pipa->bCancelParentNotify = FALSE;

            SendMessage(pipa->hwndParent, WM_COMMAND,
                        MAKEWPARAM(GetDlgCtrlID(hWnd), EN_CHANGE), (LPARAM)hWnd);
        }
        break;

    case IPM_SETRANGE:
        if (wParam < NUM_FIELDS && LOBYTE(LOWORD(lParam)) <= HIBYTE(LOWORD(lParam)))
        {
            lResult = MAKEIPRANGE(pipa->Children[wParam].byLow, pipa->Children[wParam].byHigh);
            pipa->Children[wParam].byLow = LOBYTE(LOWORD(lParam));
            pipa->Children[wParam].byHigh = HIBYTE(LOWORD(lParam));
            break;
        }
        lResult = 0;
        break;

        // Set the focus to this IPADDR.
        // wParam = the field number to set focus to, or -1 to set the focus to the
        // first non-blank field.
    case IPM_SETFOCUS:

        if (wParam >= NUM_FIELDS)
        {
            for (wParam = 0; wParam < NUM_FIELDS; ++wParam)
                if (GetFieldValue(&(pipa->Children[wParam])) == -1)   break;
            if (wParam >= NUM_FIELDS)    wParam = 0;
        }
        EnterField(&(pipa->Children[wParam]), 0, CHARS_PER_FIELD);
        break;

        // Determine whether all four subfields are blank
    case IPM_ISBLANK:

        lResult = TRUE;
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            if (GetFieldValue(&(pipa->Children[i])) != -1)
            {
                lResult = FALSE;
                break;
            }
        }
        break;

    default:
DoDefault:
        lResult = DefWindowProc( hWnd, wMsg, wParam, lParam );
        break;
    }
    return( lResult );
}




/*
 IPAddressFieldProc() - Edit field window procedure

 This function sub-classes each edit field.
 */
LRESULT IPAddressFieldProc(HWND hWnd,
                                   UINT wMsg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    IPADDR *pipa;
    FIELD *pField;
    HWND hIPADDRWindow;
    WORD wChildID;
    LRESULT lresult;

    if (!(hIPADDRWindow = GetParent(hWnd)))
        return 0;

    pipa = (IPADDR *)GET_IPADDR_HANDLE(hIPADDRWindow);
    if (!pipa)
        return 0;
    
    wChildID = (WORD)GET_IPADDR_HANDLE(hWnd);
    pField = &(pipa->Children[wChildID]);

    if (pField->hWnd != hWnd)    
        return 0;

    switch (wMsg)
    {
    case WM_DESTROY:
        DeleteObject((HGDIOBJ)SendMessage(hWnd, WM_GETFONT, 0, 0));
        return 0;

    case WM_CHAR:

        // Typing in the last digit in a field, skips to the next field.
        if (wParam >= TEXT('0') && wParam <= TEXT('9'))
        {
            LRESULT lResult;

            lResult = CallWindowProc(pipa->Children[wChildID].lpfnWndProc,
                                      hWnd, wMsg, wParam, lParam);
            lResult = SendMessage(hWnd, EM_GETSEL, 0, 0L);

            if (lResult == MAKELPARAM(CHARS_PER_FIELD, CHARS_PER_FIELD)
                && ExitField(pipa, wChildID)
                && wChildID < NUM_FIELDS-1)
            {
                EnterField(&(pipa->Children[wChildID+1]),
                           0, CHARS_PER_FIELD);
            }
            return lResult;
        }

        // spaces and periods fills out the current field and then if possible,
        // goes to the next field.
        else if (wParam == FILLER || wParam == SPACE )
        {
            LRESULT lResult;
            lResult = SendMessage(hWnd, EM_GETSEL, 0, 0L);
            if (lResult != 0L && HIWORD(lResult) == LOWORD(lResult)
                && ExitField(pipa, wChildID))
            {
                if (wChildID >= NUM_FIELDS-1)
                    MessageBeep((UINT)-1);
                else
                {
                    EnterField(&(pipa->Children[wChildID+1]),
                               0, CHARS_PER_FIELD);
                }
            }
            return 0;
        }

        // Backspaces go to the previous field if at the beginning of the current field.
        // Also, if the focus shifts to the previous field, the backspace must be
        // processed by that field.
        else if (wParam == BACK_SPACE)
        {
            if (wChildID > 0 && SendMessage(hWnd, EM_GETSEL, 0, 0L) == 0L)
            {
                if (SwitchFields(pipa, wChildID, wChildID-1,
                                 CHARS_PER_FIELD, CHARS_PER_FIELD)
                    && SendMessage(pipa->Children[wChildID-1].hWnd,
                                   EM_LINELENGTH, 0, 0L) != 0L)
                {
                    SendMessage(pipa->Children[wChildID-1].hWnd,
                                wMsg, wParam, lParam);
                }
                return 0;
            }
        }

        // Any other printable characters are not allowed.
        else if (wParam > SPACE)
        {
            MessageBeep((UINT)-1);
            return 0;
        }
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {

            // Arrow keys move between fields when the end of a field is reached.
            case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            if (GetKeyState(VK_CONTROL) < 0)
            {
                if ((wParam == VK_LEFT || wParam == VK_UP) && wChildID > 0)
                {
                    SwitchFields(pipa, wChildID, wChildID-1,
                                 0, CHARS_PER_FIELD);
                    return 0;
                }
                else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                         && wChildID < NUM_FIELDS-1)
                {
                    SwitchFields(pipa, wChildID, wChildID+1,
                                 0, CHARS_PER_FIELD);
                    return 0;
                }
            }
            else
            {
                DWORD dwResult;
                WORD wStart, wEnd;

                dwResult = (DWORD)SendMessage(hWnd, EM_GETSEL, 0, 0L);
                wStart = LOWORD(dwResult);
                wEnd = HIWORD(dwResult);
                if (wStart == wEnd)
                {
                    if ((wParam == VK_LEFT || wParam == VK_UP)
                        && wStart == 0
                        && wChildID > 0)
                    {
                        SwitchFields(pipa, wChildID, wChildID-1,
                                     CHARS_PER_FIELD, CHARS_PER_FIELD);
                        return 0;
                    }
                    else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                             && wChildID < NUM_FIELDS-1)
                    {
                        dwResult = (DWORD)SendMessage(hWnd, EM_LINELENGTH, 0, 0L);
                        if (wStart >= dwResult)
                        {
                            SwitchFields(pipa, wChildID, wChildID+1, 0, 0);
                            return 0;
                        }
                    }
                }
            }
            break;

            // Home jumps back to the beginning of the first field.
            case VK_HOME:
                if (wChildID > 0)
                {
                    SwitchFields(pipa, wChildID, 0, 0, 0);
                    return 0;
                }
            break;

            // End scoots to the end of the last field.
            case VK_END:
                if (wChildID < NUM_FIELDS-1)
                {
                    SwitchFields(pipa, wChildID, NUM_FIELDS-1,
                                 CHARS_PER_FIELD, CHARS_PER_FIELD);
                    return 0;
                }
            break;


        } // switch (wParam)

        break;

    case WM_KILLFOCUS:
        if ( !ExitField( pipa, wChildID ))
        {
            return 0;
        }

    } // switch (wMsg)

    lresult = CallWindowProc( pipa->Children[wChildID].lpfnWndProc,
                             hWnd, wMsg, wParam, lParam);
    return lresult;
}




/*
 Switch the focus from one field to another.
 call
 pipa = Pointer to the IPADDR structure.
 iOld = Field we're leaving.
 iNew = Field we're entering.
 hNew = Window of field to goto
 wStart = First character selected
 wEnd = Last character selected + 1
 returns
 TRUE on success, FALSE on failure.

 Only switches fields if the current field can be validated.
 */
BOOL SwitchFields(IPADDR *pipa, int iOld, int iNew, WORD wStart, WORD wEnd)
{
    if (!ExitField(pipa, iOld))    return FALSE;
    EnterField(&(pipa->Children[iNew]), wStart, wEnd);
    return TRUE;
}



/*
 Set the focus to a specific field's window.
 call
 pField = pointer to field structure for the field.
 wStart = First character selected
 wEnd = Last character selected + 1
 */
void EnterField(FIELD *pField, WORD wStart, WORD wEnd)
{
    SetFocus(pField->hWnd);
    SendMessage(pField->hWnd, EM_SETSEL, wStart, wEnd);
}

void SetFieldValue(IPADDR *pipa, int iField, int iValue)
{
    TCHAR szBuf[CHARS_PER_FIELD+1];
    FIELD* pField = &(pipa->Children[iField]);

    StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT("%d"), iValue);
    SendMessage(pField->hWnd, WM_SETTEXT, 0, (LPARAM) (LPSTR) szBuf);
}

/*
 Exit a field.
 call
 pipa = pointer to IPADDR structure.
 iField = field number being exited.
 returns
 TRUE if the user may exit the field.
 FALSE if he may not.
 */
BOOL ExitField(IPADDR  *pipa, int iField)
{
    FIELD *pField;
    int i;
    NMIPADDRESS nm;
    int iOldValue;

    pField = &(pipa->Children[iField]);
    i = GetFieldValue(pField);
    iOldValue = i;
    
    nm.iField = iField;
    nm.iValue = i;
    
    SendNotifyEx(pipa->hwndParent, pipa->hwnd, IPN_FIELDCHANGED, &nm.hdr, FALSE);
    i = nm.iValue;
    
    if (i != -1) {

        if (i < (int)(UINT)pField->byLow || i > (int)(UINT)pField->byHigh)
        {
            
            if ( i < (int)(UINT) pField->byLow )
            {
                /* too small */
                i = (int)(UINT)pField->byLow;
            }
            else
            {
                /* must be bigger */
                i = (int)(UINT)pField->byHigh;
            }
            SetFieldValue(pipa, iField, i);
            // FEATURE: send notify up
            return FALSE;
        }
    } 

    if (iOldValue != i) {
        SetFieldValue(pipa, iField, i);
    }
    return TRUE;
}


/*
 Get the value stored in a field.
 call
 pField = pointer to the FIELD structure for the field.
 returns
 The value (0..255) or -1 if the field has not value.
 */
int GetFieldValue(FIELD *pField)
{
    WORD wLength;
    TCHAR szBuf[CHARS_PER_FIELD+1];
    INT i;

    *(WORD *)szBuf = (sizeof(szBuf)/sizeof(TCHAR)) - 1;
    wLength = (WORD)SendMessage(pField->hWnd,EM_GETLINE,0,(LPARAM)(LPSTR)szBuf);
    if (wLength != 0)
    {
        szBuf[wLength] = TEXT('\0');
        i = StrToInt(szBuf);
        return i;
    }
    else
        return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v6\header.c ===
#include "ctlspriv.h"
#include "image.h"

#define CCHLABELMAX MAX_PATH            // borrowed from listview.h
#define HDDF_NOIMAGE  0x0001
#define HDDF_NOEDGE  0x0002

#define HDI_ALL95 0x001f

#define TF_HEADER TF_LISTVIEW

#define HD_EDITCHANGETIMER 0x100

#define c_cxFilterBarEdge (1)
#define c_cyFilterBarEdge (1)

#define c_cxFilterImage   (13)
#define c_cyFilterImage   (12)

typedef struct 
{
    int     x;              // this is the x position of the RIGHT side (divider) of this item
    int     cxy;
    int     fmt;
    LPTSTR  pszText;
    HBITMAP hbm;
    int     iImage;         // index of bitmap in imagelist
    LPARAM  lParam;
    int     xBm;            // cached values 
    int     xText;          // for implementing text and bitmap in header
    int     cxTextAndBm;    
    
    // information used for the filter contol
    UINT    idOperator;
    UINT    type;
    HD_TEXTFILTER textFilter;
    int     intFilter;

} HDI;

typedef struct 
{
    CCONTROLINFO ci;
    
    UINT flags;
    int cxEllipses;
    int cxDividerSlop;
    int cyChar;
    HFONT hfont;
    HFONT hfontSortArrow;

    HIMAGELIST hFilterImage;
    HDSA hdsaHDI;       // list of HDI's
    
    // tracking state info
    int iTrack;
    BITBOOL bTrackPress :1;		// is the button pressed?
    BITBOOL fTrackSet:1;
    BITBOOL fOwnerDraw:1;
    BITBOOL fFocus:1;
    BITBOOL fFilterChangePending:1;
    UINT flagsTrack;
    int dxTrack;                    // the distance from the divider that the user started tracking
    int xTrack;                     // the current track position (or starting track position on a button drag)
    int xMinTrack;                  // the x of the end of the previous item (left limit)
    int xTrackOldWidth;
    HIMAGELIST himl;            // handle to our image list

    HDSA hdsaOrder;     // this is an index array of the hdsaHDI items.
                        // this is the physical order of items
                        
    int iHot ;
    HIMAGELIST himlDrag;
    int iNewOrder;      // what's the new insertion point for a d/d?

    int iTextMargin; // The margin to place on either side of text or bitmaps
    int iBmMargin;   // Normally, 3 * g_cxLabelMargin

    int iFocus;         // focus object
    int iEdit;          // editing object
    int iButtonDown;
    int iFilterChangeTimeout;
    HWND hwndEdit;
    WNDPROC pfnEditWndProc;
    int typeOld;
    LPTSTR pszFilterOld;
    int intFilterOld;

    HTHEME hTheme;
} HD;


LRESULT CALLBACK Header_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Message handler functions

BOOL Header_OnCreate(HD* phd, CREATESTRUCT* lpCreateStruct);
void Header_OnNCDestroy(HD* phd);

HIMAGELIST Header_OnSetImageList(HD* phd, HIMAGELIST himl);
HIMAGELIST Header_OnGetImageList(HD* phd);

void Header_OnPaint(HD* phd, HDC hdcIn);
void Header_OnCommand(HD* phd, int id, HWND hwndCtl, UINT codeNotify);
void Header_OnEnable(HD* phd, BOOL fEnable);
UINT Header_OnGetDlgCode(HD* phd, MSG* lpmsg);
void Header_OnLButtonDown(HD* phd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
BOOL Header_IsTracking(HD* phd);
void Header_OnMouseMove(HD* phd, int x, int y, UINT keyFlags);
void Header_OnLButtonUp(HD* phd, int x, int y, UINT keyFlags);
void Header_OnSetFont(HD* plv, HFONT hfont, BOOL fRedraw);
int Header_OnHitTest(HD* phd, HD_HITTESTINFO *phdht);
HFONT Header_OnGetFont(HD* plv);
HIMAGELIST Header_OnCreateDragImage(HD* phd, int i);
BOOL Header_OnGetItemRect(HD* phd, int i, RECT* prc);
void Header_Draw(HD* phd, HDC hdc, RECT* prcClip);
void Header_InvalidateItem(HD* phd, int i, UINT uFlags );
void Header_GetDividerRect(HD* phd, int i, LPRECT prc);
LPARAM Header_OnSetHotDivider(HD* phd, BOOL fPos, LPARAM lParam);
void Header_GetFilterRects(LPRECT prcItem, LPRECT prcHeader, LPRECT prcEdit, LPRECT prcButton);
BOOL Header_BeginFilterEdit(HD* phd, int i);
VOID Header_StopFilterEdit(HD* phd, BOOL fDiscardChanges);
VOID Header_FilterChanged(HD* phd, BOOL fWait);
VOID Header_OnFilterButton(HD* phd, INT i);
LRESULT Header_OnClearFilter(HD* phd, INT i);

// HDM_* Message handler functions

int Header_OnInsertItem(HD* phd, int i, const HD_ITEM* pitem);
BOOL Header_OnDeleteItem(HD* phd, int i);
BOOL Header_OnGetItem(HD* phd, int i, HD_ITEM* pitem);
BOOL Header_OnSetItem(HD* phd, int i, const HD_ITEM* pitem);
BOOL Header_OnLayout(HD* phd, HD_LAYOUT* playout);
BOOL Header_OnSetCursor(HD* phd, HWND hwndCursor, UINT codeHitTest, UINT msg);
void Header_DrawDivider(HD* phd, int x);
int Header_OnInsertItemA(HD* phd, int i, HD_ITEMA* pitem);
BOOL Header_OnGetItemA(HD* phd, int i, HD_ITEMA* pitem);
BOOL Header_OnSetItemA(HD* phd, int i, HD_ITEMA* pitem);

void Header_EndDrag(HD* phd);
BOOL Header_SendChange(HD* phd, int i, int code, const HD_ITEM* pitem);
BOOL Header_Notify(HD* phd, int i, int iButton, int code);

#define Header_GetItemPtr(phd, i)   (HDI*)DSA_GetItemPtr((phd)->hdsaHDI, (i))
#define Header_GetCount(phd) (DSA_GetItemCount((phd)->hdsaHDI))
#define Header_IsFilter(phd) ((phd)->ci.style & HDS_FILTERBAR)

#pragma code_seg(CODESEG_INIT)

BOOL Header_Init(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = Header_WndProc;
    wc.hCursor         = NULL;	// we do WM_SETCURSOR handling
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = c_szHeaderClass;
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    wc.style           = CS_DBLCLKS | CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(HD*);
    wc.cbClsExtra      = 0;

    return (RegisterClass(&wc) || (GetLastError() == ERROR_CLASS_ALREADY_EXISTS));
}
#pragma code_seg()

// returns -1 if failed to find the item
int Header_OnGetItemOrder(HD* phd, int i)
{
    int iIndex;

    // if there's no hdsaOrder, then it's in index order
    if (phd->hdsaOrder) {
        int j;
        int iData;
        
        iIndex = -1;
        
        for (j = 0; j < DSA_GetItemCount(phd->hdsaOrder); j++) {
            DSA_GetItem(phd->hdsaOrder, j, &iData);
            if (iData == i) {
                iIndex = j;
                break;
            }
        }
        
    } else {
        iIndex = i;
    }
    
    return iIndex;
}


int Header_ItemOrderToIndex(HD* phd, int iOrder)
{
    RIPMSG(iOrder < DSA_GetItemCount(phd->hdsaHDI), "HDM_ORDERTOINDEX: Invalid order %d", iOrder);
    if (phd->hdsaOrder) {
        ASSERT(DSA_GetItemCount(phd->hdsaHDI) == DSA_GetItemCount(phd->hdsaOrder));
#ifdef DEBUG
        // DSA_GetItem will assert on an invalid index, so filter it out
        // so all we get is the RIP above.
        if (iOrder < DSA_GetItemCount(phd->hdsaOrder))
#endif
        DSA_GetItem(phd->hdsaOrder, iOrder, &iOrder);
    }
    
    return iOrder;
}

HDI* Header_GetItemPtrByOrder(HD* phd, int iOrder)
{
    int iIndex = Header_ItemOrderToIndex(phd, iOrder);
    return Header_GetItemPtr(phd, iIndex);
}

HDSA Header_InitOrderArray(HD* phd) 
{
    int i;
    
    if (!phd->hdsaOrder && !(phd->ci.style & HDS_OWNERDATA)) {

        // not initialized yet..
        // create an array with i to i mapping
        phd->hdsaOrder = DSA_Create(sizeof(int), 4);

        if (phd->hdsaOrder) {
            for (i = 0; i < Header_GetCount(phd); i++) {
                if (DSA_InsertItem(phd->hdsaOrder, i, &i) == -1) {
                    // faild to add... bail
                    DSA_Destroy(phd->hdsaOrder);
                    phd->hdsaOrder = NULL;
                }
            }
        }
    }
    return phd->hdsaOrder;
}

// this moves all items starting from iIndex over by dx
void Header_ShiftItems(HD* phd, int iOrder, int dx)
{
    for(; iOrder < Header_GetCount(phd); iOrder++) {
        HDI* phdi = Header_GetItemPtrByOrder(phd, iOrder);
        phdi->x += dx;
    }
}

void Header_OnSetItemOrder(HD* phd, int iIndex, int iOrder)
{
    if (iIndex < Header_GetCount(phd) &&
        iOrder < Header_GetCount(phd) &&
        Header_InitOrderArray(phd)) {
        int iCurOrder = Header_OnGetItemOrder(phd, iIndex);
        
        // only do work if the order is changing
        if (iOrder != iCurOrder) {
        
            // delete the current order location
            HDI* phdi = Header_GetItemPtr(phd, iIndex);
            HDI* phdiOld = Header_GetItemPtrByOrder(phd, iOrder);

            // stop editing the filter    
            Header_StopFilterEdit(phd, FALSE);

            // remove iIndex from the current order
            // (slide stuff to the right down by our width)
            Header_ShiftItems(phd, iCurOrder + 1, -phdi->cxy);
            DSA_DeleteItem(phd->hdsaOrder, iCurOrder);
            
            // insert it into the order and slide everything else over
            // (slide stuff to the right of the new position up by our width)
            DSA_InsertItem(phd->hdsaOrder, iOrder, &iIndex);
            // set our right edge to where their left edge was
            Header_ShiftItems(phd, iOrder + 1, phdi->cxy);

            if (iOrder == 0) {
                phdi->x = phdi->cxy;
            } else {
                phdiOld = Header_GetItemPtrByOrder(phd, iOrder - 1);
                phdi->x = phdiOld->x + phdi->cxy;
            }
            
            RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }
}

void Header_SetHotItem(HD* phd, int i)
{
    if (i != phd->iHot) {
        Header_InvalidateItem(phd, i, RDW_INVALIDATE);
        Header_InvalidateItem(phd, phd->iHot, RDW_INVALIDATE);
        phd->iHot = i;
    }
}

LRESULT Header_OnGetOrderArray(HD* phd, int iCount, LPINT lpi)
{
    int i;
    
    if (Header_GetCount(phd) != iCount)
        return FALSE;
    
    for (i = 0; i < Header_GetCount(phd) ; i++) {
        lpi[i] = Header_ItemOrderToIndex(phd, i);
    }
    return TRUE;
}

LRESULT Header_OnSetOrderArray(HD* phd, int iCount, LPINT lpi)
{
    int i;
    
    if (Header_GetCount(phd) != iCount)
        return FALSE;
    
    for (i = 0; i < Header_GetCount(phd); i++) {
        Header_OnSetItemOrder(phd, lpi[i], i);
    }

    NotifyWinEvent(EVENT_OBJECT_REORDER, phd->ci.hwnd, OBJID_CLIENT, 0);

    return TRUE;
}

BOOL HDDragFullWindows(HD* phd)
{
    return (g_fDragFullWindows && (phd->ci.style & HDS_FULLDRAG));
}

LRESULT CALLBACK Header_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HD* phd = (HD*)GetWindowPtr(hwnd, 0);
    
    if (phd == NULL)
    {
        if (uMsg == WM_NCCREATE)
        {
            phd = (HD*)NearAlloc(sizeof(HD));

            if (phd == NULL)
                return 0L;

            phd->ci.hwnd = hwnd;
            phd->ci.hwndParent = ((LPCREATESTRUCT)lParam)->hwndParent;
            SetWindowPtr(hwnd, 0, phd);

            // fall through to call DefWindowProc
        }

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    else
    {
        if (uMsg == WM_THEMECHANGED)
        {
            if (phd->hTheme)
                CloseThemeData(phd->hTheme);

            phd->hTheme = OpenThemeData(phd->ci.hwnd, L"Header");
            InvalidateRect(phd->ci.hwnd, NULL, TRUE);
            return 0;
        }
        
        if (uMsg == WM_NCDESTROY)
        {
            Header_OnNCDestroy(phd);
            NearFree(phd);
            SetWindowInt(hwnd, 0, 0);
    
            return 0;
        }

        // if we loose capture, or the r-button goes down, or the user hits esc, then we abort the drag/resize
        if (uMsg == WM_CAPTURECHANGED ||
            uMsg == WM_RBUTTONDOWN || (GetKeyState(VK_ESCAPE) & 0x8000)) {

            if (phd->himlDrag) {
                // if this is the end of a drag, 
                // notify the user.
                HDITEM item;
                
                item.mask = HDI_ORDER;
                item.iOrder = -1; // abort order changing
                Header_EndDrag(phd);
                
                Header_SendChange(phd, phd->iTrack, HDN_ENDDRAG, &item);
                
            } else if (phd->flagsTrack & (HHT_ONDIVIDER | HHT_ONDIVOPEN)) {
                HD_ITEM item;
                item.mask = HDI_WIDTH;
                item.cxy = phd->xTrackOldWidth;

                phd->flagsTrack = 0;
                KillTimer(phd->ci.hwnd, 1);
                CCReleaseCapture(&phd->ci);

                Header_SendChange(phd, phd->iTrack, HDN_ENDTRACK, &item);
                if (HDDragFullWindows(phd)) {

                    // incase they changed something
                    item.mask = HDI_WIDTH;
                    item.cxy = phd->xTrackOldWidth;
                    Header_OnSetItem(phd, phd->iTrack, &item);

                    RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);

                } else {
                    // Undraw the last divider we displayed
                    Header_DrawDivider(phd, phd->xTrack);
                }
            }
        }

        if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST) &&
            (phd->hTheme || phd->ci.style & HDS_HOTTRACK) && !phd->fTrackSet) {

            TRACKMOUSEEVENT tme;

            phd->fTrackSet = TRUE;

            tme.cbSize = sizeof(tme);
            tme.hwndTrack = phd->ci.hwnd;
            tme.dwFlags = TME_LEAVE;

            TrackMouseEvent(&tme);
        }

        // ROBUSTNESS: keep this switch within the if (phd) block
        //
        switch (uMsg)
        {
            HANDLE_MSG(phd, WM_CREATE, Header_OnCreate);
            HANDLE_MSG(phd, WM_SETCURSOR, Header_OnSetCursor);
            HANDLE_MSG(phd, WM_MOUSEMOVE, Header_OnMouseMove);
            HANDLE_MSG(phd, WM_LBUTTONDOWN, Header_OnLButtonDown);
            HANDLE_MSG(phd, WM_LBUTTONDBLCLK, Header_OnLButtonDown);
            HANDLE_MSG(phd, WM_LBUTTONUP, Header_OnLButtonUp);
            HANDLE_MSG(phd, WM_GETDLGCODE, Header_OnGetDlgCode);
            HANDLE_MSG(phd, WM_SETFONT, Header_OnSetFont);
            HANDLE_MSG(phd, WM_GETFONT, Header_OnGetFont);
        
        case WM_COMMAND:
            if ( (phd->iEdit>=0) && ((HWND)lParam == phd->hwndEdit) )
            {
                // when filtering we will receive notifications that the filter
                // has been edited, therefore lets send those down to the
                // parent.

                if ( HIWORD(wParam)==EN_CHANGE )
                {
                    Header_FilterChanged(phd, TRUE);
                    return(0);
                }
            }
            break;

        case WM_TIMER:
            if (wParam == HD_EDITCHANGETIMER)
            {
                Header_FilterChanged(phd, FALSE);
                return(0);
            }
            break;

        case WM_SETFOCUS:
        case WM_KILLFOCUS:
            // filter bar and not editing then take caret into edit first column
            if (Header_IsFilter(phd)) 
            {
                phd->fFocus = (uMsg==WM_SETFOCUS);
                Header_InvalidateItem(phd, Header_ItemOrderToIndex(phd, phd->iFocus), RDW_INVALIDATE);
                UpdateWindow(phd->ci.hwnd);
                return(0);
            }
            break;

        case WM_KEYDOWN:
            if ( phd->fFocus )
            {
                // handle the key events that the header control receives, when the filter
                // bar is displayed we then allow the user to enter filter mode and drop the
                // filter menu.
                //
                //  F2 = enter filter mode
                //  F4 = drop filter menu
                //  -> = next column
                //  <- = previous column

                if ( wParam == VK_F2 )
                {
                    // start editing the currently focused column
                    Header_BeginFilterEdit(phd, Header_ItemOrderToIndex(phd, phd->iFocus));
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(phd->ci), UISF_HIDEFOCUS);
                    return 0L;
                }                                                                   
                else if ( wParam == VK_F4 )
                {
                    // drop the filter menu (this exits edit mode)
                    Header_OnFilterButton(phd, Header_ItemOrderToIndex(phd, phd->iFocus));
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(phd->ci), UISF_HIDEFOCUS);
                    return 0L;
                }
                else if ( (wParam == VK_LEFT)||(wParam == VK_RIGHT) )
                {
                    INT iFocus = phd->iFocus;

                    // move to previous or next column
                    if ( wParam == VK_RIGHT )
                    {
                        phd->iFocus = (iFocus+1) % Header_GetCount(phd);
                    }
                    else
                    {
                        phd->iFocus = iFocus-1;
                        if ( phd->iFocus < 0 )
                            phd->iFocus = max(Header_GetCount(phd)-1, 0);
                    }

                    // did the focused column change? if so then update the control
                    // as required.
                    if ( iFocus != phd->iFocus )
                    {                
                        Header_InvalidateItem(phd, Header_ItemOrderToIndex(phd, iFocus), RDW_INVALIDATE);
                        Header_InvalidateItem(phd, Header_ItemOrderToIndex(phd, phd->iFocus), RDW_INVALIDATE);
                        UpdateWindow(phd->ci.hwnd);
                    }
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(phd->ci), UISF_HIDEFOCUS);
                    return 0L;
                }
            }
            break;

        case WM_MOUSELEAVE:
            Header_SetHotItem(phd, -1);
            phd->fTrackSet = FALSE;
            break;

        case WM_ERASEBKGND:
            return 1;
        
        case WM_PRINTCLIENT:
        case WM_PAINT:
            Header_OnPaint(phd, (HDC)wParam);
            return(0);
        
        case WM_RBUTTONUP:
            if (CCSendNotify(&phd->ci, NM_RCLICK, NULL))
                return(0);
            break;
        
        case WM_STYLECHANGED:
            if (wParam == GWL_STYLE) {
                LPSTYLESTRUCT pss = (LPSTYLESTRUCT)lParam;
                
                phd->ci.style = pss->styleNew;

                // if the filter is changing then discard it if its active
                if ((pss->styleOld & HDS_FILTERBAR) != (pss->styleNew & HDS_FILTERBAR))
                    Header_StopFilterEdit(phd, TRUE);

                // we don't cache our style so relay out and invaidate
                InvalidateRect(phd->ci.hwnd, NULL, TRUE);
            }
            return(0);

        case WM_UPDATEUISTATE:
        {
            DWORD dwUIStateMask = MAKEWPARAM(0xFFFF, UISF_HIDEFOCUS);

            if (CCOnUIState(&(phd->ci), WM_UPDATEUISTATE, wParam & dwUIStateMask, lParam) &&
                phd->iFocus < DSA_GetItemCount(phd->hdsaHDI))
            {
                Header_InvalidateItem(phd, Header_ItemOrderToIndex(phd, phd->iFocus), RDW_INVALIDATE);
            }
            break;
        }
        
        case WM_NOTIFYFORMAT:
            return CIHandleNotifyFormat(&phd->ci, lParam);
        
        case HDM_GETITEMCOUNT:
            return (LPARAM)(UINT)DSA_GetItemCount(phd->hdsaHDI);
        
        case HDM_INSERTITEM:
            return (LPARAM)Header_OnInsertItem(phd, (int)wParam, (const HD_ITEM*)lParam);
        
        case HDM_DELETEITEM:
            return (LPARAM)Header_OnDeleteItem(phd, (int)wParam);
        
        case HDM_GETITEM:
            return (LPARAM)Header_OnGetItem(phd, (int)wParam, (HD_ITEM*)lParam);
        
        case HDM_SETITEM:
            return (LPARAM)Header_OnSetItem(phd, (int)wParam, (const HD_ITEM*)lParam);
        
        case HDM_LAYOUT:
            return (LPARAM)Header_OnLayout(phd, (HD_LAYOUT*)lParam);
            
        case HDM_HITTEST:
            return (LPARAM)Header_OnHitTest(phd, (HD_HITTESTINFO *)lParam);
            
        case HDM_GETITEMRECT:
            return (LPARAM)Header_OnGetItemRect(phd, (int)wParam, (LPRECT)lParam);
            
        case HDM_SETIMAGELIST:
            return (LRESULT)(ULONG_PTR)Header_OnSetImageList(phd, (HIMAGELIST)lParam);
            
        case HDM_GETIMAGELIST:
            return (LRESULT)(ULONG_PTR)phd->himl;
            
        case HDM_INSERTITEMA:
            return (LPARAM)Header_OnInsertItemA(phd, (int)wParam, (HD_ITEMA*)lParam);
        
        case HDM_GETITEMA:
            return (LPARAM)Header_OnGetItemA(phd, (int)wParam, (HD_ITEMA*)lParam);
        
        case HDM_SETITEMA:
            return (LPARAM)Header_OnSetItemA(phd, (int)wParam, (HD_ITEMA*)lParam);
            
        case HDM_ORDERTOINDEX:
            return Header_ItemOrderToIndex(phd, (int)wParam);
            
        case HDM_CREATEDRAGIMAGE:
            return (LRESULT)Header_OnCreateDragImage(phd, Header_OnGetItemOrder(phd, (int)wParam));
            
        case HDM_SETORDERARRAY:
            return Header_OnSetOrderArray(phd, (int)wParam, (LPINT)lParam);
            
        case HDM_GETORDERARRAY:
            return Header_OnGetOrderArray(phd, (int)wParam, (LPINT)lParam);
            
        case HDM_SETHOTDIVIDER:
            return Header_OnSetHotDivider(phd, (int)wParam, lParam);

        case HDM_SETBITMAPMARGIN:
            phd->iBmMargin = (int)wParam;
            TraceMsg(TF_HEADER, "Setting bmMargin = %d",wParam);
            return TRUE;

        case HDM_GETBITMAPMARGIN:
            return phd->iBmMargin;

        case HDM_EDITFILTER:
            Header_StopFilterEdit(phd, (BOOL)LOWORD(lParam));
            return Header_BeginFilterEdit(phd, (int)wParam);

        case HDM_SETFILTERCHANGETIMEOUT:
            if ( lParam ) {
                int iOldTimeout = phd->iFilterChangeTimeout;
                phd->iFilterChangeTimeout = (int)lParam;
                return(iOldTimeout);
            }
            return(phd->iFilterChangeTimeout);

        case HDM_CLEARFILTER:
            return Header_OnClearFilter(phd, (int)wParam);

        case WM_GETOBJECT:
            if( lParam == OBJID_QUERYCLASSNAMEIDX )
                return MSAA_CLASSNAMEIDX_HEADER;
            break;
            
        default:
        {
            LRESULT lres;
            if (CCWndProc(&phd->ci, uMsg, wParam, lParam, &lres))
                return lres;
        }
        }
        
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

}


BOOL Header_SendChange(HD* phd, int i, int code, const HD_ITEM* pitem)
{
    NMHEADER nm;

    nm.iItem = i;
    nm.pitem = (HD_ITEM*)pitem;
    nm.iButton = 0;
    
    return !(BOOL)CCSendNotify(&phd->ci, code, &nm.hdr);
}

BOOL Header_Notify(HD* phd, int i, int iButton, int code)
{
    NMHEADER nm;
    nm.iItem = i;
    nm.iButton = iButton;
    nm.pitem = NULL;

    return !(BOOL)CCSendNotify(&phd->ci, code, &nm.hdr);
}


void Header_NewFont(HD* phd, HFONT hfont)
{
    HDC hdc;
    SIZE siz = {0};
    HRESULT hr = E_FAIL;
    HFONT hFontOld = NULL;
    int cy;
    TEXTMETRIC tm;
    HFONT hfontSortArrow = NULL;

    hdc = GetDC(HWND_DESKTOP);

    if (phd->hTheme)
    {
        RECT rc = {0};
        RECT rcBound = {0};
        hr = GetThemeTextExtent(phd->hTheme, hdc, HP_HEADERITEM, 0, TEXT("M"), -1, 0, &rcBound, &rc);
        siz.cx = RECTWIDTH(rc);
        siz.cy = RECTHEIGHT(rc);
    }

    if (FAILED(hr))
    {
        if (hfont)
            SelectFont(hdc, hfont);

        GetTextExtentPoint(hdc, c_szEllipses, CCHELLIPSES, &siz);
    }

    if (phd->hfont)
        hFontOld = (HFONT)SelectObject(hdc, phd->hfont);

    GetTextMetrics(hdc, &tm);

    if (hFontOld)
        SelectObject(hdc, hFontOld);

    // Set the font height (based on original USER code)
    cy = ((tm.tmHeight + tm.tmExternalLeading + GetSystemMetrics(SM_CYBORDER)) & 0xFFFE) - 1;

    // Create the marlett font, so we can paint the arrows.
    hfontSortArrow = CreateFont(cy, 0, 0, 0, 0, FALSE, FALSE, FALSE, DEFAULT_CHARSET, 0, 0, 0, 0, 
        TEXT("Marlett"));

    phd->cxEllipses = siz.cx;
    phd->cyChar = siz.cy;
    phd->hfont = hfont;

    if (hfontSortArrow)
    {
        if (phd->hfontSortArrow)    // Do we have one to free?
        {
            DeleteObject(phd->hfontSortArrow);
        }

        phd->hfontSortArrow = hfontSortArrow;
    }
    phd->ci.uiCodePage = GetCodePageForFont(hfont);

    ReleaseDC(HWND_DESKTOP, hdc);
}

BOOL Header_OnCreate(HD* phd, CREATESTRUCT* lpCreateStruct)
{
    ASSERT(phd); // we are only called if phd is valid

    CIInitialize(&phd->ci, phd->ci.hwnd, (LPCREATESTRUCT)lpCreateStruct);

    phd->flags = 0;
    phd->hfont = NULL;
    phd->hFilterImage = NULL;

    phd->iNewOrder = -1;
    phd->iHot = -1;
    
    phd->iFocus = 0;
    phd->iEdit = -1;
    phd->iButtonDown = -1;
    phd->iFilterChangeTimeout = GetDoubleClickTime()*2;
    phd->hwndEdit = NULL;

    phd->hdsaHDI = DSA_Create(sizeof(HDI), 4);

    if (!phd->hdsaHDI)
        return FALSE;

    phd->cxDividerSlop = 8 * g_cxBorder;

    phd->hTheme = OpenThemeData(phd->ci.hwnd, L"Header");

    // Warning!  ListView_RSetColumnWidth knows these values.
    phd->iTextMargin = 3 * g_cxLabelMargin;
    phd->iBmMargin = 3 * g_cxLabelMargin;

    
    // phd->himl = NULL;   
    Header_NewFont(phd, NULL);
    return TRUE;
}

int Header_DestroyItemCallback(LPVOID p, LPVOID d)
{
    HDI * phdi = (HDI*)p;
    if (phdi)
    {
        Str_Set(&phdi->pszText, NULL);

        if ( (phdi->type & HDFT_ISMASK)==HDFT_ISSTRING )
            Str_Set(&phdi->textFilter.pszText, NULL);
    }
    return 1;
}

void Header_OnNCDestroy(HD* phd)
{
    // stop editing the filter    
    if ( phd->hFilterImage )
        ImageList_Destroy(phd->hFilterImage);

    Header_StopFilterEdit(phd, TRUE);

    // We must walk through and destroy all of the string pointers that
    // are contained in the structures before we pass it off to the
    // DSA_Destroy function...

    DSA_DestroyCallback(phd->hdsaHDI, Header_DestroyItemCallback, 0);
    phd->hdsaHDI = NULL;
    if (phd->hdsaOrder)
    {
        DSA_Destroy(phd->hdsaOrder);
        phd->hdsaOrder = NULL;
    }

    if (phd->hTheme)
        CloseThemeData(phd->hTheme);

    if (phd->hfontSortArrow)
        DeleteObject(phd->hfontSortArrow);
}

HIMAGELIST Header_OnSetImageList(HD* phd, HIMAGELIST himl)
{
    HIMAGELIST hImageOld = phd->himl;
    phd->himl = himl;
    return hImageOld;
}
    
void Header_OnPaint(HD* phd, HDC hdc)
{
    PAINTSTRUCT ps;
    HDC hdcUse;
    CCDBUFFER cdd;

    if (!phd)
        return;

    if (hdc)
    {
        hdcUse = hdc;
        GetClientRect(phd->ci.hwnd, &ps.rcPaint);
    }
    else
    {
        hdcUse = BeginPaint(phd->ci.hwnd, &ps);
    }

    hdcUse = CCBeginDoubleBuffer(hdcUse, &ps.rcPaint, &cdd);

    Header_Draw(phd, hdcUse, &ps.rcPaint);

    CCEndDoubleBuffer(&cdd);

    if (!hdc) 
    {
        EndPaint(phd->ci.hwnd, &ps);
    }
}

UINT Header_OnGetDlgCode(HD* phd, MSG* lpmsg)
{    
    return DLGC_WANTTAB | DLGC_WANTARROWS;
}


int Header_HitTest(HD* phd, int x, int y, UINT* pflags)
{
    UINT flags = 0;
    POINT pt;
    RECT rc;
    HDI* phdi;
    int i;

    pt.x = x; pt.y = y;

    GetClientRect(phd->ci.hwnd, &rc);

    flags = 0;
    i = -1;
    if (x < rc.left)
        flags |= HHT_TOLEFT;
    else if (x >= rc.right)
        flags |= HHT_TORIGHT;
    if (y < rc.top)
        flags |= HHT_ABOVE;
    else if (y >= rc.bottom)
        flags |= HHT_BELOW;

    if (flags == 0)
    {
        int cItems = DSA_GetItemCount(phd->hdsaHDI);
        int xPrev = 0;
        BOOL fPrevZero = FALSE;
        int xItem;
        int cxSlop;

        //DebugMsg(DM_TRACE, "Hit Test begin");
        for (i = 0; i <= cItems; i++, phdi++, xPrev = xItem)
        {
            if (i == cItems) 
                xItem = rc.right;
            else {
                phdi = Header_GetItemPtrByOrder(phd, i);
                xItem = phdi->x;
            }

            // DebugMsg(DM_TRACE, "x = %d xItem = %d xPrev = %d fPrevZero = %d", x, xItem, xPrev, xPrev == xItem);
            if (xItem == xPrev)
            {
                // Skip zero width items...
                //
                fPrevZero = TRUE;
                continue;
            }

            cxSlop = min((xItem - xPrev) / 4, phd->cxDividerSlop);

            if (x >= xPrev && x < xItem)
            {
                if ( Header_IsFilter(phd) )
                {
                    RECT rcItem;
                    RECT rcHeader, rcFilter, rcButton;

                    rcItem.left   = xPrev;
                    rcItem.top    = rc.top;
                    rcItem.right  = xItem;
                    rcItem.bottom = rc.bottom ;

                    Header_GetFilterRects(&rcItem, &rcHeader, &rcFilter, &rcButton);

                    if ( y >= rcFilter.top )
                    {
                        if ( x >= rcFilter.right )
                        {
                            // hit check the entire button, forget about the divider
                            // when over the filter glyph
                            flags = HHT_ONFILTERBUTTON;
                            break;
                        }
                        else
                        {
                            flags = HHT_ONFILTER;
                        }
                    }
                    else if ( y < rcHeader.bottom )
                        flags = HHT_ONHEADER;
                }
                else
                {
                    flags = HHT_ONHEADER;
                }

                if (i > 0 && x < xPrev + cxSlop)
                {
                    i--;
                    flags = HHT_ONDIVIDER;

                    if (fPrevZero && x > xPrev)
                    {
                        flags = HHT_ONDIVOPEN;
                    }
                }
                else if (x >= xItem - cxSlop)
                {
                    flags = HHT_ONDIVIDER;
                }

                break;
            }
            fPrevZero = FALSE;
        }
        if (i == cItems)
        {
            i = -1;
            flags = HHT_NOWHERE;
        } else {
            // now convert order index to real index
            i = Header_ItemOrderToIndex(phd, i);
        }
            
    }
    *pflags = flags;
    return i;
}

int Header_OnHitTest(HD* phd, HD_HITTESTINFO *phdht)
{
    if (phdht && phd) {
        phdht->iItem = Header_HitTest(phd, phdht->pt.x, phdht->pt.y, &phdht->flags);
        return phdht->iItem;
    } else
        return -1;
}

BOOL Header_OnSetCursor(HD* phd, HWND hwndCursor, UINT codeHitTest, UINT msg)
{
    POINT pt;
    UINT flags;
    LPCTSTR lpCur = MAKEINTRESOURCE(IDC_SIZEWE);
    HINSTANCE hinst = NULL;
    int iItem;
    int iDPI = CCGetScreenDPI();

    if (!phd)
        return FALSE;

    if (phd->ci.hwnd != hwndCursor || codeHitTest >= 0x8000)
        return FALSE;

    GetMessagePosClient(hwndCursor, &pt);

    iItem = Header_HitTest(phd, pt.x, pt.y, &flags);

    switch (flags)
    {
    case HHT_ONDIVIDER:
        if (iDPI <= 96)
        {
            lpCur = MAKEINTRESOURCE(IDC_DIVIDER);
            hinst = HINST_THISDLL;
        }
        break;
    case HHT_ONDIVOPEN:
        if (iDPI <= 96)
        {
            lpCur = MAKEINTRESOURCE(IDC_DIVOPEN);
            hinst = HINST_THISDLL;
        }

        break;

    case HHT_ONFILTER:
    {
        HDI* phdi = Header_GetItemPtrByOrder(phd, iItem);
        ASSERT(phdi);

        lpCur = IDC_ARROW;              // default to the arrow

        switch ( phdi->type & HDFT_ISMASK )
        {
            case HDFT_ISSTRING:
            case HDFT_ISNUMBER:
                lpCur = IDC_IBEAM;
                break;

            default:
// FEATURE: handle custom filters
                break;
        }
        break;
    }

    default:
        lpCur = IDC_ARROW;
        break;
    }
    SetCursor(LoadCursor(hinst, lpCur));
    return TRUE;
}

void Header_DrawDivider(HD* phd, int x)
{
    RECT rc;
    HDC hdc = GetDC(phd->ci.hwnd);

    GetClientRect(phd->ci.hwnd, &rc);
    rc.left = x;
    rc.right = x + g_cxBorder;

    InvertRect(hdc, &rc);

    ReleaseDC(phd->ci.hwnd, hdc);
}

int Header_PinDividerPos(HD* phd, int x)
{
    x += phd->dxTrack;
    if (x < phd->xMinTrack)
        x = phd->xMinTrack;
    return x;
}

void Header_OnLButtonDown(HD* phd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    HD_ITEM hd;
    int i;
    UINT flags;

    if (!phd)
        return;

    Header_StopFilterEdit(phd, FALSE);

    i = Header_HitTest(phd, x, y, &flags);
    if (flags & (HHT_ONDIVIDER))
    {
        if (fDoubleClick) {
            Header_SendChange(phd, i, HDN_DIVIDERDBLCLICK, NULL);
        }  
    }
    
    if ((flags & (HHT_ONDIVIDER | HHT_ONHEADER | HHT_ONDIVOPEN))
        && !fDoubleClick)
    {
        phd->iTrack = i;
        phd->flagsTrack = flags;
        phd->xTrack = x;
        SetCapture(phd->ci.hwnd);

        // this is just to get messages so we can
        // check for the escape key being hit
        SetTimer(phd->ci.hwnd, 1, 100, NULL);
        GetAsyncKeyState(VK_ESCAPE);
    }
    
    if (flags & (HHT_ONDIVIDER | HHT_ONDIVOPEN) &&
        !fDoubleClick)
    {
        //
        // We should first send out the HDN_BEGINTRACK notification
        //
        HDI * phdi;
        
        int iOrder = Header_OnGetItemOrder(phd, i);
        phdi = Header_GetItemPtr(phd, i);
        phd->xMinTrack = phdi->x - phdi->cxy;
        phd->xTrack = phdi->x;
        phd->dxTrack = phd->xTrack - x;
        phd->xTrackOldWidth = phdi->cxy;

        hd.mask = HDI_WIDTH;
        hd.cxy = phd->xTrackOldWidth;
        if (!Header_SendChange(phd, i, HDN_BEGINTRACK, &hd))
        {
            // They said no!
            phd->flagsTrack = 0;
            CCReleaseCapture(&phd->ci);
            KillTimer(phd->ci.hwnd, 1);
            return;
        }

        if (!HDDragFullWindows(phd)) {
            x = Header_PinDividerPos(phd, x);
            Header_DrawDivider(phd, x);
        }
    }
    else if ((flags & HHT_ONHEADER) && (phd->ci.style & HDS_BUTTONS))
    {
        if (fDoubleClick) {
            Header_SendChange(phd, i, HDN_ITEMDBLCLICK, NULL);
        } else {
            phd->bTrackPress = TRUE;
            