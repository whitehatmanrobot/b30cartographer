mitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrResourceType, long dwFlags);
	void DeleteItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusGroupOwners wrapper class

class ClusGroupOwners : public COleDispatchDriver
{
public:
	ClusGroupOwners() {}		// Calls COleDispatchDriver default constructor
	ClusGroupOwners(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusGroupOwners(const ClusGroupOwners& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	void InsertItem(LPDISPATCH pClusNode, long nPosition);
	void RemoveItem(const VARIANT& varIndex);
	// method 'GetModified' not emitted because of invalid return type or parameter type
};
/////////////////////////////////////////////////////////////////////////////
// ClusResOwners wrapper class

class ClusResOwners : public COleDispatchDriver
{
public:
	ClusResOwners() {}		// Calls COleDispatchDriver default constructor
	ClusResOwners(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResOwners(const ClusResOwners& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	void AddItem(LPDISPATCH pNode);
	void RemoveItem(const VARIANT& varIndex);
	// method 'GetModified' not emitted because of invalid return type or parameter type
};
/////////////////////////////////////////////////////////////////////////////
// ClusResDependencies wrapper class

class ClusResDependencies : public COleDispatchDriver
{
public:
	ClusResDependencies() {}		// Calls COleDispatchDriver default constructor
	ClusResDependencies(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResDependencies(const ClusResDependencies& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrResourceType, LPCTSTR bstrGroupName, long dwFlags);
	void DeleteItem(const VARIANT& varIndex);
	void AddItem(LPDISPATCH pResource);
	void RemoveItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusNodes wrapper class

class ClusNodes : public COleDispatchDriver
{
public:
	ClusNodes() {}		// Calls COleDispatchDriver default constructor
	ClusNodes(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNodes(const ClusNodes& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusResources wrapper class

class ClusResources : public COleDispatchDriver
{
public:
	ClusResources() {}		// Calls COleDispatchDriver default constructor
	ClusResources(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResources(const ClusResources& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrResourceType, LPCTSTR bstrGroupName, long dwFlags);
	void DeleteItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusResTypes wrapper class

class ClusResTypes : public COleDispatchDriver
{
public:
	ClusResTypes() {}		// Calls COleDispatchDriver default constructor
	ClusResTypes(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResTypes(const ClusResTypes& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH CreateItem(LPCTSTR bstrResourceTypeName, LPCTSTR bstrDisplayName, LPCTSTR bstrResourceTypeDll, long dwLooksAlivePollInterval, long dwIsAlivePollInterval);
	void DeleteItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusResType wrapper class

class ClusResType : public COleDispatchDriver
{
public:
	ClusResType() {}		// Calls COleDispatchDriver default constructor
	ClusResType(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResType(const ClusResType& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	void Delete();
	LPDISPATCH GetCluster();
	LPDISPATCH GetResources();
};
/////////////////////////////////////////////////////////////////////////////
// ClusResTypeResources wrapper class

class ClusResTypeResources : public COleDispatchDriver
{
public:
	ClusResTypeResources() {}		// Calls COleDispatchDriver default constructor
	ClusResTypeResources(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResTypeResources(const ClusResTypeResources& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrGroupName, long dwFlags);
	void DeleteItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusNetworks wrapper class

class ClusNetworks : public COleDispatchDriver
{
public:
	ClusNetworks() {}		// Calls COleDispatchDriver default constructor
	ClusNetworks(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNetworks(const ClusNetworks& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusNetwork wrapper class

class ClusNetwork : public COleDispatchDriver
{
public:
	ClusNetwork() {}		// Calls COleDispatchDriver default constructor
	ClusNetwork(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNetwork(const ClusNetwork& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	long GetHandle();
	void SetName(LPCTSTR lpszNewValue);
	CString GetNetworkID();
	long GetState();
	LPDISPATCH GetNetInterfaces();
	LPDISPATCH GetCluster();
};
/////////////////////////////////////////////////////////////////////////////
// ClusNetworkNetInterfaces wrapper class

class ClusNetworkNetInterfaces : public COleDispatchDriver
{
public:
	ClusNetworkNetInterfaces() {}		// Calls COleDispatchDriver default constructor
	ClusNetworkNetInterfaces(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNetworkNetInterfaces(const ClusNetworkNetInterfaces& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusNetInterfaces wrapper class

class ClusNetInterfaces : public COleDispatchDriver
{
public:
	ClusNetInterfaces() {}		// Calls COleDispatchDriver default constructor
	ClusNetInterfaces(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNetInterfaces(const ClusNetInterfaces& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clnetcfg\clnetcfg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   clnetcfg.c

Abstract:

    System network configuration grovelling routines

Author:

    Mike Massa (mikemas)           May 19, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     05-19-97    created


--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <cluster.h>
#include <clusrpc.h>
#include <clnetcfg.h>
#include <wchar.h>


//
// Private constants
//
#define CLNET_DEFAULT_NETWORK_PRIORITY     0xffffffff


//
// Private Data
//
LPFN_CLNETPRINT       pClNetPrint = NULL;
LPFN_CLNETLOGEVENT    pClNetLogEvent = NULL;
LPFN_CLNETLOGEVENT1   pClNetLogEvent1 = NULL;
LPFN_CLNETLOGEVENT2   pClNetLogEvent2 = NULL;
LPFN_CLNETLOGEVENT3   pClNetLogEvent3 = NULL;
WCHAR                 ClNetpEmptyString[] = L"";


//
// Private Macros
//
#if DBG

#define ClNetDbgPrint(arg)   (*pClNetPrint) arg

#else

#define ClNetDbgPrint(arg)

#endif


//
// Private utility routines
//
VOID
ClNetpConsumeAdaptersOnNetwork(
    IN PCLRTL_NET_ADAPTER_ENUM   AdapterEnum,
    IN LPWSTR                    NetworkAddress,
    IN LPWSTR                    NetworkMask
    )
{
    PCLRTL_NET_ADAPTER_INFO    adapterInfo;
    PCLRTL_NET_INTERFACE_INFO  adapterIfInfo;


    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Consuming all adapters on IP network %1!ws!, mask %2!ws!.\n",
        NetworkAddress,
        NetworkMask
        ));

    //
    // Walk the adapter enum and consume all other adapters
    // attached to this network.
    //
    for (adapterInfo = AdapterEnum->AdapterList;
         adapterInfo != NULL;
         adapterInfo = adapterInfo->Next
        )
    {
        if (adapterInfo->Ignore == FALSE) {
            adapterIfInfo = ClRtlFindNetInterfaceByNetworkAddress(
                                adapterInfo,
                                NetworkAddress,
                                NetworkMask
                                );

            if (adapterIfInfo != NULL) {
                //
                // This is a duplicate adapter.
                //
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Consumed adapter '%1!ws!'.\n",
                    adapterInfo->DeviceName
                    ));
                adapterInfo->Ignore = TRUE;
            }
        }
    }

    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Finished consuming all adapters on IP network %1!ws!, mask %2!ws!.\n",
        NetworkAddress,
        NetworkMask
        ));

    return;

}  // ClNetpConsumeAdaptersOnNetwork


LPWSTR
ClNetpCloneString(
    LPWSTR   String
    )
{
    LPWSTR newString = LocalAlloc(
                           LMEM_FIXED,
                           (lstrlenW(String) + 1) * sizeof(UNICODE_NULL)
                           );

    if (newString != NULL) {
        lstrcpyW(newString, String);
    }

    return(newString);

} // ClNetpCloneString


BOOLEAN
ClNetpIsNetworkNameUnique(
    IN LPWSTR                    NetworkName,
    IN PCLNET_CONFIG_LISTS       ConfigLists,
    IN PLIST_ENTRY               UnchangedConfigList
    )
{
    PLIST_ENTRY              listEntry;
    PCLNET_CONFIG_ENTRY      configEntry;
    PLIST_ENTRY              listHead;


    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Checking uniqueness of net name '%1!ws!'\n",
        NetworkName
        ));

    //
    // Check the existing cluster network definitions for a duplicate
    //
    listHead = &(ConfigLists->InputConfigList);

    for (;;) {
        for (listEntry = listHead->Flink;
             listEntry != listHead;
             listEntry = listEntry->Flink
            )
        {
            configEntry = CONTAINING_RECORD(
                              listEntry,
                              CLNET_CONFIG_ENTRY,
                              Linkage
                              );

            if (lstrcmpiW(NetworkName, configEntry->NetworkInfo.Name) == 0) {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Net name '%1!ws!' is not unique\n",
                    NetworkName
                    ));
                return(FALSE);
            }
        }

        if (listHead == &(ConfigLists->InputConfigList)) {
            listHead = &(ConfigLists->DeletedInterfaceList);
        }
        else if (listHead == &(ConfigLists->DeletedInterfaceList)) {
            listHead = &(ConfigLists->UpdatedInterfaceList);
        }
        else if (listHead == &(ConfigLists->UpdatedInterfaceList)) {
            listHead = &(ConfigLists->CreatedNetworkList);
        }
        else if (listHead == &(ConfigLists->CreatedNetworkList)) {
            listHead = UnchangedConfigList;
        }
        else {
            break;
        }
    }

    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Net name '%1!ws!' is unique\n",
        NetworkName
        ));

    return(TRUE);


} // ClNetpIsNetworkNameUnique


LPWSTR
ClNetpMakeNetworkName(
    IN LPWSTR OldNetworkName,
    IN DWORD  InstanceNumber
    )
{
    LPWSTR   newName, endPtr, truncatePtr, ptr;
    DWORD    length, tempInstance, tempLength;


    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Attempt to make net name '%1!ws!' unique by appending (%2!u!)\n",
        OldNetworkName,
        InstanceNumber
        ));

    //
    // Append (InstanceNumber) to name string
    //

    for (endPtr = OldNetworkName, length = 0;
         *endPtr != UNICODE_NULL;
         endPtr++, length++
        );

    //
    // Check if there is already an instance number appended.
    //
    if ( (length > 3) && (*(endPtr - 1) == L')') ) {
        ClNetDbgPrint((
            LOG_NOISE,
            "[ClNet] There may already be an instance number appended to '%1!ws!'\n",
            OldNetworkName
            ));
        //
        // Scan backwards looking for '('
        //
        for (ptr = endPtr - 2, tempLength = 0;
             ptr != OldNetworkName;
             ptr--, tempLength++
            )
        {
            if (*ptr == L'(') {
                //
                // Looks promising. Check that all characters in between are
                // numbers and that the string size is reasonable.
                //
                if ((tempLength == 0) || (tempLength > 3)) {
                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] Unsure net name %'1!ws!' contains an instance number - ignore.\n",
                        OldNetworkName
                        ));
                    break;
                }

                truncatePtr = ptr;

                for (ptr++; *ptr != L')'; ptr++) {
                    if ( (*ptr < L'0') || (*ptr > L'9') ) {
                        ClNetDbgPrint((
                            LOG_NOISE,
                            "[ClNet] Tail of net name '%1!ws!' is not an instance number\n",
                            OldNetworkName
                            ));
                        break;
                    }
                }

                if (*ptr == L')') {
                    //
                    // This is an instance number. Truncate the string here.
                    //
                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] Replacing old instance number '%1!ws!' appended to name '%2!ws!'\n",
                        truncatePtr,
                        OldNetworkName
                        ));

                    *truncatePtr = UNICODE_NULL;
                    length -= tempLength + 2;
                }

                break;
            }
        }
    }

    //
    // Count number of digits in instance number
    //
    for (tempInstance = InstanceNumber;
         tempInstance > 0;
         tempInstance /= 10, length++
        );

    //
    // Account for '(', ')', and NULL
    //
    length += 3;

    newName = LocalAlloc(LMEM_FIXED, length * sizeof(WCHAR));

    if (newName == NULL) {
        return(NULL);
    }

    wsprintfW(newName, L"%ws(%u)", OldNetworkName, InstanceNumber);

    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] New net name is '%1!ws!'\n",
        newName
        ));

    return(newName);

} // ClNetpMakeNetworkName


LPWSTR
ClNetpMakeUniqueNetworkName(
    IN  LPWSTR                    ConnectoidName,
    IN  LPWSTR                    ConnectoidGuid,
    IN  PCLNET_CONFIG_LISTS       ConfigLists,
    IN  PLIST_ENTRY               UnchangedConfigList
    )
{
    BOOLEAN  unique;
    BOOLEAN  updateConnectoid = FALSE;
    LPWSTR   newNetworkName;
    DWORD    index = 1;


    newNetworkName = ClNetpCloneString(ConnectoidName);

    if (newNetworkName == NULL) {
        return(NULL);
    }

    do {
        unique = ClNetpIsNetworkNameUnique(
                     newNetworkName,
                     ConfigLists,
                     UnchangedConfigList
                     );

        if (!unique) {
            LPWSTR  oldNetworkName = newNetworkName;

            newNetworkName = ClNetpMakeNetworkName(
                                 oldNetworkName,
                                 index++
                                 );

            LocalFree(oldNetworkName);

            if (newNetworkName == NULL) {
                return(NULL);
            }

            updateConnectoid = TRUE;
        }
    } while (!unique);

    //
    // Update the local connectoid name if necessary.
    //
    if (updateConnectoid) {
        DWORD status;

        ClNetDbgPrint((LOG_UNUSUAL,
            "[ClNet] Changing name of connectoid '%1!ws!' to '%2!ws!' to "
            "guarantee cluster-wide uniqueness\n",
            ConnectoidName,
            newNetworkName
            ));

        status = ClRtlFindConnectoidByGuidAndSetName(
                     ConnectoidGuid,
                     newNetworkName
                     );

        if (status != ERROR_SUCCESS) {
            ClNetDbgPrint((LOG_UNUSUAL,
                "[ClNet] Failed to change name of connectoid '%1!ws!' to "
                "'%2!ws!', status %3!u!\n",
                ConnectoidName,
                newNetworkName,
                status
                ));
        }
    }

    return(newNetworkName);

} // ClNetpMakeUniqueNetworkName


DWORD
ClNetpUpdateConfigEntry(
    PCLNET_CONFIG_ENTRY  ConfigEntry,
    LPWSTR               Address,
    LPWSTR               AdapterId,
    LPWSTR               AdapterName,
    LPWSTR               NodeName,
    LPWSTR               NetworkName
    )
{
    LPWSTR    newAddress = NULL;
    LPWSTR    newInterfaceName = NULL;
    LPWSTR    newAdapterId = NULL;
    LPWSTR    newAdapterName = NULL;


    if (Address != NULL) {
        newAddress = ClNetpCloneString(Address);

        if (newAddress == NULL) {
            goto error_exit;
        }
    }

    if (AdapterId != NULL) {
        newAdapterId = ClNetpCloneString(AdapterId);

        if (newAdapterId == NULL) {
            goto error_exit;
        }
    }

    if (AdapterName != NULL) {
        newAdapterName = ClNetpCloneString(AdapterName);

        if (newAdapterName == NULL) {
            goto error_exit;
        }
    }

    if ( (NodeName != NULL) && (NetworkName != NULL) ) {
        newInterfaceName = ClNetMakeInterfaceName(
                               NULL,
                               NodeName,
                               NetworkName
                               );

        if (newInterfaceName == NULL) {
            goto error_exit;
        }
    }

    if (newAddress != NULL) {
        LocalFree(ConfigEntry->InterfaceInfo.Address);
        ConfigEntry->InterfaceInfo.Address = newAddress;
    }

    if (newAdapterId != NULL) {
        LocalFree(ConfigEntry->InterfaceInfo.AdapterId);
        ConfigEntry->InterfaceInfo.AdapterId = newAdapterId;
    }

    if (newAdapterName != NULL) {
        LocalFree(ConfigEntry->InterfaceInfo.AdapterName);
        ConfigEntry->InterfaceInfo.AdapterName = newAdapterName;
    }

    if (newInterfaceName != NULL) {
        LocalFree(ConfigEntry->InterfaceInfo.Name);
        ConfigEntry->InterfaceInfo.Name = newInterfaceName;
    }

    return(ERROR_SUCCESS);

error_exit:

    if (newAddress != NULL) {
        LocalFree(newAddress);
    }

    if (newAdapterId != NULL) {
        LocalFree(newAdapterId);
    }

    if (newAdapterName != NULL) {
        LocalFree(newAdapterName);
    }

    if (newInterfaceName != NULL) {
        LocalFree(newInterfaceName);
    }

    return(ERROR_NOT_ENOUGH_MEMORY);

} // ClNetpUpdateConfigEntry


DWORD
ClNetpAllocConfigEntryInterface(
    IN PCLNET_CONFIG_ENTRY   ConfigEntry,
    IN LPWSTR                InterfaceId,
    IN LPWSTR                InterfaceName,
    IN LPWSTR                InterfaceDescription,
    IN LPWSTR                NodeId,
    IN LPWSTR                AdapterId,
    IN LPWSTR                AdapterName,
    IN LPWSTR                InterfaceAddress,
    IN LPWSTR                ClusnetEndpoint,
    IN DWORD                 InterfaceState
    )
{
    PNM_INTERFACE_INFO2  interfaceInfo = &(ConfigEntry->InterfaceInfo);


    if (InterfaceId != NULL) {
        interfaceInfo->Id = ClNetpCloneString(InterfaceId);

        if (interfaceInfo->Id == NULL) {
            goto error_exit;
        }
    }

    ConfigEntry->IsInterfaceInfoValid = TRUE;

    if (InterfaceName != NULL) {
        interfaceInfo->Name = ClNetpCloneString(InterfaceName);

        if (interfaceInfo->Name == NULL) {
            goto error_exit;
        }
    }

    if (InterfaceDescription != NULL) {
        interfaceInfo->Description = ClNetpCloneString(InterfaceDescription);

        if (interfaceInfo->Description == NULL) {
            goto error_exit;
        }
    }

    if (NodeId != NULL) {
        interfaceInfo->NodeId = ClNetpCloneString(NodeId);

        if (interfaceInfo->NodeId == NULL) {
            goto error_exit;
        }
    }

    interfaceInfo->NetworkId = ClNetpCloneString(ConfigEntry->NetworkInfo.Id);

    if (interfaceInfo->NetworkId == NULL) {
        goto error_exit;
    }

    if (AdapterId != NULL) {
        interfaceInfo->AdapterId = ClNetpCloneString(AdapterId);

        if (interfaceInfo->AdapterId == NULL) {
            goto error_exit;
        }
    }

    if (AdapterName != NULL) {
        interfaceInfo->AdapterName = ClNetpCloneString(AdapterName);

        if (interfaceInfo->AdapterName == NULL) {
            goto error_exit;
        }
    }

    if (InterfaceAddress != NULL) {
        interfaceInfo->Address = ClNetpCloneString(InterfaceAddress);

        if (interfaceInfo->Address == NULL) {
            goto error_exit;
        }
    }

    if (ClusnetEndpoint != NULL) {
        interfaceInfo->ClusnetEndpoint = ClNetpCloneString(ClusnetEndpoint);

        if (interfaceInfo->ClusnetEndpoint == NULL) {
            goto error_exit;
        }
    }

    interfaceInfo->State = InterfaceState;
    interfaceInfo->NetIndex = NmInvalidInterfaceNetIndex;

    return(ERROR_SUCCESS);

error_exit:

    ClNetFreeInterfaceInfo(&(ConfigEntry->InterfaceInfo));
    ConfigEntry->IsInterfaceInfoValid = FALSE;

    return(ERROR_NOT_ENOUGH_MEMORY);

}  // ClNetpAllocConfigEntryInterface


DWORD
ClNetpAllocConfigEntryNetwork(
    IN PCLNET_CONFIG_ENTRY   ConfigEntry,
    IN LPWSTR                NetworkId,
    IN LPWSTR                NetworkName,
    IN LPWSTR                NetworkDescription,
    IN DWORD                 NetworkRole,
    IN DWORD                 NetworkPriority,
    IN LPWSTR                NetworkTransport,
    IN LPWSTR                NetworkAddress,
    IN LPWSTR                NetworkAddressMask
    )
{
    PNM_NETWORK_INFO      networkInfo;


    networkInfo = &(ConfigEntry->NetworkInfo);

    if (NetworkId != NULL) {
        networkInfo->Id = ClNetpCloneString(NetworkId);

        if (networkInfo->Id == NULL) {
            goto error_exit;
        }
    }

    if (NetworkName != NULL) {
        networkInfo->Name = ClNetpCloneString(NetworkName);

        if (networkInfo->Name == NULL) {
            goto error_exit;
        }
    }

    if (NetworkDescription != NULL) {
        networkInfo->Description = ClNetpCloneString(NetworkDescription);

        if (networkInfo->Description == NULL) {
            goto error_exit;
        }
    }

    networkInfo->Role = NetworkRole;
    networkInfo->Priority = NetworkPriority;

    if (NetworkTransport != NULL) {
        networkInfo->Transport = ClNetpCloneString(NetworkTransport);

        if (networkInfo->Transport == NULL) {
            goto error_exit;
        }
    }

    if (NetworkAddress != NULL) {
        networkInfo->Address = ClNetpCloneString(NetworkAddress);

        if (networkInfo->Address == NULL) {
            goto error_exit;
        }
    }

    if (NetworkAddressMask != NULL) {
        networkInfo->AddressMask = ClNetpCloneString(NetworkAddressMask);

        if (networkInfo->AddressMask == NULL) {
            goto error_exit;
        }
    }

    return(ERROR_SUCCESS);


error_exit:

    ClNetFreeConfigEntry(ConfigEntry);

    return(ERROR_NOT_ENOUGH_MEMORY);

} // ClNetpAllocConfigEntryNetwork


DWORD
ClNetpCreateConfigEntryInterface(
    PCLNET_CONFIG_ENTRY        ConfigEntry,
    LPWSTR                     NodeName,
    LPWSTR                     NodeId,
    PCLRTL_NET_ADAPTER_INFO    AdapterInfo,
    PCLRTL_NET_INTERFACE_INFO  AdapterIfInfo,
    LPWSTR                     ClusnetEndpoint
    )
{
    LPWSTR    id;
    LPWSTR    name;
    DWORD     status = ERROR_NOT_ENOUGH_MEMORY;


    id = ClRtlMakeGuid();

    if (id != NULL) {
        name = ClNetMakeInterfaceName(
                   NULL,
                   NodeName,
                   ConfigEntry->NetworkInfo.Name
                   );

        if (name != NULL) {
            status = ClNetpAllocConfigEntryInterface(
                         ConfigEntry,
                         NULL,                   // Id
                         NULL,                   // Name
                         ClNetpEmptyString,      // Description
                         NodeId,
                         AdapterInfo->DeviceGuid,
                         AdapterInfo->DeviceName,
                         AdapterIfInfo->InterfaceAddressString,
                         ClusnetEndpoint,
                         ClusterNetInterfaceUnavailable
                         );

            if (status == ERROR_SUCCESS) {
                ConfigEntry->InterfaceInfo.Id = id;
                ConfigEntry->InterfaceInfo.Name = name;

                return(ERROR_SUCCESS);
            }

            LocalFree(name);
        }

        LocalFree(id);
    }

    return(status);

} // ClNetpCreateInterface


PCLNET_CONFIG_ENTRY
ClNetpCreateConfigEntry(
    LPWSTR                     NodeName,
    LPWSTR                     NodeId,
    LPWSTR                     NetworkName,
    DWORD                      NetworkRole,
    DWORD                      NetworkPriority,
    PCLRTL_NET_ADAPTER_INFO    AdapterInfo,
    PCLRTL_NET_INTERFACE_INFO  AdapterIfInfo,
    LPWSTR                     ClusnetEndpoint
    )
{
    PCLNET_CONFIG_ENTRY      newEntry;
    DWORD                    status;


    newEntry = LocalAlloc(
                   (LMEM_FIXED | LMEM_ZEROINIT),
                   sizeof(CLNET_CONFIG_ENTRY)
                   );

    if (newEntry == NULL) {
        return(NULL);
    }

    newEntry->NetworkInfo.Id = ClRtlMakeGuid();

    if (newEntry->NetworkInfo.Id == NULL) {
        goto error_exit;
    }

    newEntry->NetworkInfo.Name = ClNetpCloneString(NetworkName);

    if (newEntry->NetworkInfo.Name == NULL) {
        goto error_exit;
    }

    status = ClNetpCreateConfigEntryInterface(
                 newEntry,
                 NodeName,
                 NodeId,
                 AdapterInfo,
                 AdapterIfInfo,
                 ClusnetEndpoint
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = ClNetpAllocConfigEntryNetwork(
                 newEntry,
                 NULL,                   // NetworkId
                 NULL,                   // NetworkName
                 ClNetpEmptyString,      // Description
                 NetworkRole,
                 NetworkPriority,
                 L"Tcpip",
                 AdapterIfInfo->NetworkAddressString,
                 AdapterIfInfo->NetworkMaskString
                 );

    if (status == ERROR_SUCCESS) {
        return(newEntry);
    }

error_exit:

    ClNetFreeConfigEntry(newEntry);
    LocalFree(newEntry);

    return(NULL);

} // ClNetpCreateConfigEntry


DWORD
ClNetpCopyNetworkInfo(
    IN PNM_NETWORK_INFO   DstInfo,
    IN PNM_NETWORK_INFO   SrcInfo
    )
{
    DWORD  status = ERROR_SUCCESS;


    try {
        DstInfo->Id = ClNetCopyString(SrcInfo->Id, TRUE);
        DstInfo->Name = ClNetCopyString(SrcInfo->Name, TRUE);
        DstInfo->Description = ClNetCopyString(SrcInfo->Description, TRUE);
        DstInfo->Role = SrcInfo->Role;
        DstInfo->Priority = SrcInfo->Priority;
        DstInfo->Transport = ClNetCopyString(SrcInfo->Transport, TRUE);
        DstInfo->Address = ClNetCopyString(SrcInfo->Address, TRUE);
        DstInfo->AddressMask = ClNetCopyString(SrcInfo->AddressMask, TRUE);
        DstInfo->Ignore = FALSE;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        ClNetFreeNetworkInfo(DstInfo);
    }

    return(status);

} // ClNetpCopyNetworkInfo


DWORD
ClNetpCopyInterfaceInfo(
    IN PNM_INTERFACE_INFO2   DstInfo,
    IN PNM_INTERFACE_INFO2   SrcInfo
    )
{
    DWORD  status = ERROR_SUCCESS;


    try {
        DstInfo->Id = ClNetCopyString(SrcInfo->Id, TRUE);
        DstInfo->Name = ClNetCopyString(SrcInfo->Name, TRUE);
        DstInfo->Description = ClNetCopyString(SrcInfo->Description, TRUE);
        DstInfo->NodeId = ClNetCopyString(SrcInfo->NodeId, TRUE);
        DstInfo->NetworkId = ClNetCopyString(SrcInfo->NetworkId, TRUE);
        DstInfo->AdapterName = ClNetCopyString(SrcInfo->AdapterName, TRUE);
        DstInfo->Address = ClNetCopyString(SrcInfo->Address, TRUE);
        DstInfo->ClusnetEndpoint = ClNetCopyString(
                                       SrcInfo->ClusnetEndpoint,
                                       TRUE
                                       );
        DstInfo->State = SrcInfo->State;
        DstInfo->Ignore = FALSE;
        DstInfo->AdapterId = ClNetCopyString(SrcInfo->AdapterId, TRUE);
        DstInfo->NetIndex = SrcInfo->NetIndex;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        ClNetFreeInterfaceInfo(DstInfo);
    }

    return(status);

} // ClNetpCopyInterfaceInfo


//////////////////////////////////////////////////////////////////////////////
//
// Public routines
//
//////////////////////////////////////////////////////////////////////////////
VOID
ClNetInitialize(
    IN LPFN_CLNETPRINT       pfnPrint,
    IN LPFN_CLNETLOGEVENT    pfnLogEvent,
    IN LPFN_CLNETLOGEVENT1   pfnLogEvent1,
    IN LPFN_CLNETLOGEVENT2   pfnLogEvent2,
    IN LPFN_CLNETLOGEVENT3   pfnLogEvent3
    )
{
    pClNetPrint = pfnPrint;
    pClNetLogEvent = pfnLogEvent;
    pClNetLogEvent1 = pfnLogEvent1;
    pClNetLogEvent2 = pfnLogEvent2;
    pClNetLogEvent3 = pfnLogEvent3;

} // ClNetInitialize


LPWSTR
ClNetCopyString(
    IN LPWSTR  SourceString,
    IN BOOL    RaiseExceptionOnError
    )
{
    LPWSTR  str;

    str = (LPWSTR) MIDL_user_allocate(
                       (lstrlenW(SourceString) + 1) * sizeof(WCHAR)
                       );

    if (str != NULL) {
        lstrcpyW(str, SourceString);
    }
    else if (RaiseExceptionOnError) {
        RaiseException(ERROR_NOT_ENOUGH_MEMORY, 0, 0, NULL);
    }

    return(str);

} // ClNetCopyString


VOID
ClNetInitializeConfigLists(
    PCLNET_CONFIG_LISTS  Lists
    )
{
    InitializeListHead(&(Lists->InputConfigList));
    InitializeListHead(&(Lists->DeletedInterfaceList));
    InitializeListHead(&(Lists->UpdatedInterfaceList));
    InitializeListHead(&(Lists->CreatedInterfaceList));
    InitializeListHead(&(Lists->CreatedNetworkList));

    return;

}  // ClNetInitializeConfigLists


DWORD
ClNetConvertEnumsToConfigList(
    IN     PNM_NETWORK_ENUM *     NetworkEnum,
    IN     PNM_INTERFACE_ENUM2 *  InterfaceEnum,
    IN     LPWSTR                 LocalNodeId,
    IN OUT PLIST_ENTRY            ConfigList,
    IN     BOOLEAN                DeleteEnums
    )
{
    DWORD                i, j;
    DWORD                status;
    PNM_NETWORK_INFO     network;
    PNM_INTERFACE_INFO2  netInterface;
    PCLNET_CONFIG_ENTRY  configEntry;


    InitializeListHead(ConfigList);

    for (i=0; i<(*NetworkEnum)->NetworkCount; i++) {
        network = &((*NetworkEnum)->NetworkList[i]);

        configEntry = LocalAlloc(
                          (LMEM_FIXED | LMEM_ZEROINIT),
                          sizeof(CLNET_CONFIG_ENTRY)
                          );

        if (configEntry == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        if (DeleteEnums) {
            CopyMemory(
                &(configEntry->NetworkInfo),
                network,
                sizeof(NM_NETWORK_INFO)
                );
        }
        else {
            status = ClNetpCopyNetworkInfo(
                         &(configEntry->NetworkInfo),
                         network
                         );

            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }
        }

        for (j=0; j<(*InterfaceEnum)->InterfaceCount; j++) {
            netInterface = &((*InterfaceEnum)->InterfaceList[j]);

            if ( (netInterface->Ignore == FALSE) &&
                 (lstrcmpiW(netInterface->NetworkId, network->Id) == 0) &&
                 (lstrcmpiW(netInterface->NodeId, LocalNodeId) == 0)
               )
            {
                if (DeleteEnums) {
                    CopyMemory(
                        &(configEntry->InterfaceInfo),
                        netInterface,
                        sizeof(NM_INTERFACE_INFO2)
                        );
                }
                else {
                    status = ClNetpCopyInterfaceInfo(
                                 &(configEntry->InterfaceInfo),
                                 netInterface
                                 );

                    if (status != ERROR_SUCCESS) {
                        goto error_exit;
                    }
                }

                configEntry->IsInterfaceInfoValid = TRUE;

                if ( DeleteEnums ) {
                    ZeroMemory(netInterface, sizeof(NM_INTERFACE_INFO2));
                }

                netInterface->Ignore = TRUE;

                break;
            }
        }

        InsertTailList(ConfigList, &(configEntry->Linkage));

        if ( DeleteEnums ) {
            ZeroMemory(network, sizeof(NM_NETWORK_INFO));
        }
    }

    status = ERROR_SUCCESS;

error_exit:

    if ( DeleteEnums ) {
        ClNetFreeNetworkEnum(*NetworkEnum); *NetworkEnum = NULL;
        ClNetFreeInterfaceEnum(*InterfaceEnum); *InterfaceEnum = NULL;
    }

    if (status != ERROR_SUCCESS) {
        ClNetFreeConfigList(ConfigList);
    }

    return(status);

}  // ClNetConvertEnumsToConfigList



VOID
ClNetFreeNetworkEnum(
    IN PNM_NETWORK_ENUM  NetworkEnum
    )
/*++

Routine Description:

    Frees a network enumeration structure.

Arguments:

    NetworkEnum - A pointer to the network enumeration structure to free.

Return Value:

    None.

--*/
{
    DWORD  i;


    for (i=0; i<NetworkEnum->NetworkCount; i++) {
        ClNetFreeNetworkInfo(&(NetworkEnum->NetworkList[i]));
    }

    MIDL_user_free(NetworkEnum);

    return;

}  // ClNetFreeNetworkEnum



VOID
ClNetFreeNetworkInfo(
    IN PNM_NETWORK_INFO  NetworkInfo
    )
/*++

Routine Description:

    Frees a network information structure or a linked list of network
    information structures.

Arguments:

    NetworkInfo - A pointer to the network information structure
                  to free.

Return Value:

    None.

--*/
{

    if (NetworkInfo->Id != NULL) {
        MIDL_user_free(NetworkInfo->Id);
        NetworkInfo->Id = NULL;
    }

    if (NetworkInfo->Name != NULL) {
        MIDL_user_free(NetworkInfo->Name);
        NetworkInfo->Name = NULL;
    }

    if (NetworkInfo->Description != NULL) {
        MIDL_user_free(NetworkInfo->Description);
        NetworkInfo->Description = NULL;
    }

    if (NetworkInfo->Transport != NULL) {
        MIDL_user_free(NetworkInfo->Transport);
        NetworkInfo->Transport = NULL;
    }

    if (NetworkInfo->Address != NULL) {
        MIDL_user_free(NetworkInfo->Address);
        NetworkInfo->Address = NULL;
    }

    if (NetworkInfo->AddressMask != NULL) {
        MIDL_user_free(NetworkInfo->AddressMask);
        NetworkInfo->AddressMask = NULL;
    }

    return;

}  // ClNetFreeNetworkInfo



VOID
ClNetFreeInterfaceEnum1(
    IN PNM_INTERFACE_ENUM  InterfaceEnum1
    )
/*++

Routine Description:

    Frees a interface enumeration structure.

Arguments:

    InterfaceEnum - A pointer to the interface enumeration structure
                    to free.

Return Value:

    None.

--*/
{
    DWORD  i;


    for (i=0; i<InterfaceEnum1->InterfaceCount; i++) {
        ClNetFreeInterfaceInfo(
            (PNM_INTERFACE_INFO2) &(InterfaceEnum1->InterfaceList[i])
            );
    }

    MIDL_user_free(InterfaceEnum1);

    return;

} // ClNetFreeInterfaceEnum



VOID
ClNetFreeInterfaceEnum(
    IN PNM_INTERFACE_ENUM2  InterfaceEnum
    )
/*++

Routine Description:

    Frees a interface enumeration structure.

Arguments:

    InterfaceEnum - A pointer to the interface enumeration structure
                    to free.

Return Value:

    None.

--*/
{
    DWORD  i;


    for (i=0; i<InterfaceEnum->InterfaceCount; i++) {
        ClNetFreeInterfaceInfo(&(InterfaceEnum->InterfaceList[i]));
    }

    MIDL_user_free(InterfaceEnum);

    return;

} // ClNetFreeInterfaceEnum



VOID
ClNetFreeInterfaceInfo(
    IN PNM_INTERFACE_INFO2  InterfaceInfo
    )
/*++

Routine Description:

    Frees a network interface information strucuture.

Arguments:

    InterfaceInfo - A pointer to the interface information
                    structure to free.

Return Value:

    None.

--*/
{

    if (InterfaceInfo->Id != NULL) {
        MIDL_user_free(InterfaceInfo->Id);
        InterfaceInfo->Id = NULL;
    }

    if (InterfaceInfo->Name != NULL) {
        MIDL_user_free(InterfaceInfo->Name);
        InterfaceInfo->Name = NULL;
    }

    if (InterfaceInfo->Description != NULL) {
        MIDL_user_free(InterfaceInfo->Description);
        InterfaceInfo->Description = NULL;
    }

    if (InterfaceInfo->NetworkId != NULL) {
        MIDL_user_free(InterfaceInfo->NetworkId);
        InterfaceInfo->NetworkId = NULL;
    }

    if (InterfaceInfo->NodeId != NULL) {
        MIDL_user_free(InterfaceInfo->NodeId);
        InterfaceInfo->NodeId = NULL;
    }

    if (InterfaceInfo->AdapterId != NULL) {
        MIDL_user_free(InterfaceInfo->AdapterId);
        InterfaceInfo->AdapterId = NULL;
    }

    if (InterfaceInfo->AdapterName != NULL) {
        MIDL_user_free(InterfaceInfo->AdapterName);
        InterfaceInfo->AdapterName = NULL;
    }

    if (InterfaceInfo->Address != NULL) {
        MIDL_user_free(InterfaceInfo->Address);
        InterfaceInfo->Address = NULL;
    }

    if (InterfaceInfo->ClusnetEndpoint != NULL) {
        MIDL_user_free(InterfaceInfo->ClusnetEndpoint);
        InterfaceInfo->ClusnetEndpoint = NULL;
    }

    return;

}  // ClNetFreeInterfaceInfo

VOID
ClNetFreeNodeEnum1(
    IN PNM_NODE_ENUM  NodeEnum1
    )
/*++

Routine Description:

    Frees a node enumeration structure.

Arguments:

    NodeEnum - A pointer to the node enumeration structure to free.

Return Value:

    None.

--*/
{
    DWORD  i;


    for (i=0; i<NodeEnum1->NodeCount; i++) {
        ClNetFreeNodeInfo(
            (PNM_NODE_INFO2) &(NodeEnum1->NodeList[i])
            );
    }

    MIDL_user_free(NodeEnum1);

    return;

}  // NmpFreeNodeEnum1



VOID
ClNetFreeNodeEnum(
    IN PNM_NODE_ENUM2  NodeEnum
    )
/*++

Routine Description:

    Frees a node enumeration structure.

Arguments:

    NodeEnum - A pointer to the node enumeration structure to free.

Return Value:

    None.

--*/
{
    DWORD  i;


    for (i=0; i<NodeEnum->NodeCount; i++) {
        ClNetFreeNodeInfo(&(NodeEnum->NodeList[i]));
    }

    MIDL_user_free(NodeEnum);

    return;

}  // NmpFreeNodeEnum



VOID
ClNetFreeNodeInfo(
    IN PNM_NODE_INFO2  NodeInfo
    )
/*++

Routine Description:

    Frees a node information structure.

Arguments:

    NodeInfo - A pointer to the node information structure to free.

Return Value:

    None.

--*/
{

    //
    // Currently nothing to free.
    //

    return;

}  // NmpFreeNodeInfo


VOID
ClNetFreeConfigEntry(
    PCLNET_CONFIG_ENTRY  ConfigEntry
    )
{
    ClNetFreeNetworkInfo(&(ConfigEntry->NetworkInfo));

    if (ConfigEntry->IsInterfaceInfoValid) {
        ClNetFreeInterfaceInfo(&(ConfigEntry->InterfaceInfo));
    }

    return;

}  // ClNetFreeConfigEntry


VOID
ClNetFreeConfigList(
    IN PLIST_ENTRY  ConfigList
    )
{
    PLIST_ENTRY           listEntry;
    PCLNET_CONFIG_ENTRY   configEntry;

    while (!IsListEmpty(ConfigList)) {
        listEntry = RemoveHeadList(ConfigList);

        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );

        ClNetFreeConfigEntry(configEntry);
    }

    return;

}  // ClNetFreeConfigList


VOID
ClNetFreeConfigLists(
    PCLNET_CONFIG_LISTS  ConfigLists
    )
{
    ClNetFreeConfigList(&(ConfigLists->InputConfigList));
    ClNetFreeConfigList(&(ConfigLists->DeletedInterfaceList));
    ClNetFreeConfigList(&(ConfigLists->UpdatedInterfaceList));
    ClNetFreeConfigList(&(ConfigLists->CreatedInterfaceList));
    ClNetFreeConfigList(&(ConfigLists->CreatedNetworkList));

    return;

}  // ClNetFreeConfigLists


LPWSTR
ClNetMakeInterfaceName(
    LPWSTR  Prefix,      OPTIONAL
    LPWSTR  NodeName,
    LPWSTR  NetworkName
    )

/*++

    Construct a name of the form "<network name> - <node name>".
    Code in cluscfg.exe depends on this form. If you change this,
    you need to change the code in setup\cluscfg\netadptr.cpp as
    well

--*/

{
    WCHAR    text[] = L" - ";
    LPWSTR   name;
    DWORD    nameLength = 0;


    if (Prefix != NULL) {
        nameLength += lstrlenW(Prefix);
    }

    nameLength += lstrlenW(text) + lstrlenW(NodeName) +
                  lstrlenW(NetworkName) + 1;

    nameLength *= sizeof(WCHAR);

    name = MIDL_user_allocate(nameLength);

    if (name != NULL) {
        name[0] = UNICODE_NULL;

        if (Prefix != NULL) {
            lstrcatW(name, Prefix);
        }

        lstrcatW(name, NetworkName);
        lstrcatW(name, text);
        lstrcatW(name, NodeName);

        return(name);
    }

    SetLastError(ERROR_NOT_ENOUGH_MEMORY);

    return(NULL);

}  // ClNetMakeInterfaceName


DWORD
ClNetConfigureNetworks(
    IN     LPWSTR                LocalNodeId,
    IN     LPWSTR                LocalNodeName,
    IN     LPWSTR                DefaultClusnetEndpoint,
    IN     CLUSTER_NETWORK_ROLE  DefaultNetworkRole,
    IN     BOOL                  NetNameHasPrecedence,
    IN OUT PCLNET_CONFIG_LISTS   ConfigLists,
    IN OUT LPDWORD               MatchedNetworkCount,
    IN OUT LPDWORD               NewNetworkCount
    )
/*++

Notes:

    NetNameHasPrecedence is TRUE if connectoid names should be changed to
    align with the name in the NM_NETWORK_INFO struct. Otherwise the name of
    network object is changed to match the connectoid name.

    Output interface lists must be processed in the following order to
    guarantee correctness:
        1 - DeletedInterfaceList
        2 - UpdatedInterfaceList
        3 - CreatedInterfaceList
        4 - CreatedNetworkList

--*/

{
    DWORD                      status = ERROR_SUCCESS;
    PCLRTL_NET_ADAPTER_ENUM    adapterEnum = NULL;
    PCLRTL_NET_ADAPTER_INFO    adapterInfo = NULL;
    PCLRTL_NET_INTERFACE_INFO  adapterIfInfo = NULL;
    WCHAR                      errorString[12];
    DWORD                      eventCode = 0;
    DWORD                      hiddenAdapterCount = 0;
    PLIST_ENTRY                listEntry;
    PCLNET_CONFIG_ENTRY        configEntry;
    PNM_NETWORK_INFO           networkInfo;
    PNM_INTERFACE_INFO2        interfaceInfo;
    LIST_ENTRY                 unchangedConfigList;
    DWORD                      matchedNetworkCount = 0;
    DWORD                      newNetworkCount = 0;
    BOOLEAN                    newAdapter;


    ClNetDbgPrint((LOG_NOISE, "[ClNet] Configuring networks...\n"));

    if (NetNameHasPrecedence) {
        ClNetDbgPrint((
            LOG_NOISE,
            "[ClNet] Cluster network names have precedence over "
            "local connection object names.\n"
            ));
    }
    else {
        ClNetDbgPrint((
            LOG_NOISE,
            "[ClNet] Local connection object names have precedence "
            "over cluster network names.\n"
            ));
    }

    InitializeListHead(&unchangedConfigList);

    //
    // Obtain the network configuration for the local system.
    //
    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Querying local network configuration.\n"
        ));

    adapterEnum = ClRtlEnumNetAdapters();

    if (adapterEnum == NULL) {
        status = GetLastError();
        wsprintfW(&(errorString[0]), L"%u", status);
        (*pClNetLogEvent1)(
            LOG_CRITICAL,
            CLNET_EVENT_QUERY_CONFIG_FAILED,
            errorString
            );
        ClNetDbgPrint((
            LOG_CRITICAL,
            "[ClNet] Failed to obtain local system network config, "
            "status %1!u!.\n",
            status
            ));
        return(status);
    }

    //
    // Ignore all adapters which are hidden or have an address of 0.0.0.0.
    //
    for (adapterInfo = adapterEnum->AdapterList;
         adapterInfo != NULL;
         adapterInfo = adapterInfo->Next
        )
    {
        if (adapterInfo->Flags & CLRTL_NET_ADAPTER_HIDDEN) {
            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] Ignoring hidden adapter '%1!ws!' (%2!ws!).\n",
                adapterInfo->DeviceName,
                adapterInfo->DeviceGuid
                ));
            adapterInfo->Ignore = TRUE;
            hiddenAdapterCount++;
        }
        else {
            adapterIfInfo = ClRtlGetPrimaryNetInterface(adapterInfo);

            if (adapterIfInfo != NULL) {
                if (adapterIfInfo->InterfaceAddress == 0) {
                    (*pClNetLogEvent1)(
                        LOG_UNUSUAL,
                        CLNET_EVENT_INVALID_ADAPTER_ADDRESS,
                        adapterInfo->DeviceName
                        );
                   ClNetDbgPrint((
                       LOG_NOISE,
                       "[ClNet] Ignoring adapter '%1!ws!' "
                       "(%2!ws!) because its"
                       "primary address is 0.0.0.0.\n",
                       adapterInfo->DeviceName,
                       adapterInfo->DeviceGuid
                       ));
                   adapterInfo->Ignore = TRUE;
                   hiddenAdapterCount++;
                }
            }
            else {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Ignoring adapter '%1!ws!' "
                    "(%2!ws!) because its primary net "
                    "interface could not be found.\n",
                    adapterInfo->DeviceName,
                    adapterInfo->DeviceGuid
                    ));
                adapterInfo->Ignore = TRUE;
                hiddenAdapterCount++;
            }
        }
    }

    if ((adapterEnum->AdapterCount - hiddenAdapterCount) == 0) {
        (*pClNetLogEvent)(
            LOG_UNUSUAL,
            CLNET_EVENT_NO_VALID_ADAPTER
            );
        ClNetDbgPrint((
            LOG_CRITICAL,
            "[ClNet] No usable network adapters are installed in this "
            "system.\n"
            ));
    }

    //
    // Phase 1
    //
    // Validate existing interface definitions for this node
    // and update as needed.
    //
    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Phase 1 - Examining previous network definitions.\n"
        ));

    //
    // Walk all of the network definitions and examine the corresponding
    // interface definitions for this node.
    //
    while (!IsListEmpty(&(ConfigLists->InputConfigList))) {

        configEntry = CONTAINING_RECORD(
                          ConfigLists->InputConfigList.Flink,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );

        networkInfo = &(configEntry->NetworkInfo);

        ClNetDbgPrint((
            LOG_NOISE,
            "[ClNet] Examining cluster network '%1!ws!' (%2!ws!).\n",
            networkInfo->Name,
            networkInfo->Id
            ));

        //
        // Check if there is an existing interface definition for
        // this node on this network.
        //
        if (configEntry->IsInterfaceInfoValid) {

            // An interface definition already exists for this node on
            // the network. We will either find an installed adapter for it
            // or delete the interface.
            //
            interfaceInfo = &(configEntry->InterfaceInfo);

            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] This node was attached to the network by "
                "adapter '%1!ws!', (%2!ws!).\n",
                interfaceInfo->AdapterName,
                interfaceInfo->AdapterId
                ));

            //
            // Try to find the adapter specified in the interface
            // definition. If it is still attached to the network,
            // then we want to reuse it.
            //
            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] Checking if adapter '%1!ws!' is still installed.\n",
                interfaceInfo->AdapterName
                ));

            adapterInfo = ClRtlFindNetAdapterById(
                              adapterEnum,
                              interfaceInfo->AdapterId
                              );

            if (adapterInfo != NULL) {
                //
                // Found the specified adapter. Check if this
                // adapter is still attached to the network by
                // comparing network address values.
                //
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Adapter '%1!ws!' is still installed, checking "
                    "if it is still attached to the same network.\n",
                    adapterInfo->DeviceName
                    ));

                adapterIfInfo = ClRtlFindNetInterfaceByNetworkAddress(
                                    adapterInfo,
                                    networkInfo->Address,
                                    networkInfo->AddressMask
                                    );

                if (adapterIfInfo != NULL) {
                    //
                    // The adapter is still attached to this network.
                    //
                    newAdapter = FALSE;

                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] Adapter '%1!ws!' is still attached to "
                        "network %2!ws!.\n",
                        interfaceInfo->AdapterName,
                        networkInfo->Name
                        ));
                }
                else {
                    //
                    // The adapter is no longer attached to this network.
                    //
                    adapterInfo = NULL;

                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] Adapter '%1!ws!' is no longer attached "
                        "to network %2!ws!.\n",
                        interfaceInfo->AdapterName,
                        networkInfo->Name
                        ));
                }
            }
            else {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Adapter '%1!ws!' is no longer available.\n",
                    interfaceInfo->AdapterName
                    ));
            }

            //
            // If the old adapter was removed or is now attached to a
            // different network, search for a new adapter that is
            // attached to the network.
            //
            if (adapterInfo == NULL) {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Searching for a new adapter which is attached "
                    "to network '%1!ws!'.\n",
                    networkInfo->Name
                    ));

                adapterIfInfo = NULL;
                adapterInfo = ClRtlFindNetAdapterByNetworkAddress(
                                  adapterEnum,
                                  networkInfo->Address,
                                  networkInfo->AddressMask,
                                  &adapterIfInfo
                                  );

                if (adapterInfo != NULL) {
                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] Adapter '%1!ws!' (%2!ws!) is attached to "
                        "network '%3!ws!'.\n",
                        interfaceInfo->AdapterName,
                        interfaceInfo->AdapterId,
                        networkInfo->Name
                        ));
                    newAdapter = TRUE;
                }
            }

            //
            // If we found an adapter, old or new, which is attached to this
            // network, update the interface definition, as needed.
            //
            if (adapterInfo != NULL) {
                BOOLEAN somethingChanged = FALSE;
                BOOL    netNameHasPrecedence = NetNameHasPrecedence;
                LPWSTR  address = NULL;
                LPWSTR  adapterName = NULL;
                LPWSTR  adapterId = NULL;
                LPWSTR  networkName = NULL;


                if (newAdapter) {
                    netNameHasPrecedence = TRUE;
                    adapterId = adapterInfo->DeviceGuid;
                    somethingChanged = TRUE;
                }

                //
                // If the address value has changed, update it
                //
                if (lstrcmpW(
                        interfaceInfo->Address,
                        adapterIfInfo->InterfaceAddressString
                        ) != 0
                   )
                {
                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] The address for the network interface has "
                        "changed to %1!ws!.\n",
                        adapterIfInfo->InterfaceAddressString
                        ));

                    address = adapterIfInfo->InterfaceAddressString;
                    somethingChanged = TRUE;
                }

                //
                // If the adapter name changed, update it.
                //
                if (lstrcmpW(
                        interfaceInfo->AdapterName,
                        adapterInfo->DeviceName
                        ) != 0
                   )
                {
                    if (!newAdapter) {
                        ClNetDbgPrint((
                            LOG_NOISE,
                            "[ClNet] The adapter name for the network "
                            "interface has changed to '%1!ws!'.\n",
                            adapterInfo->DeviceName
                            ));
                    }

                    adapterName = adapterInfo->DeviceName;
                    somethingChanged = TRUE;
                }

                //
                // If the connectoid name is different, choose the correct
                // name based on the name precedence and update the
                // network, connectoid, and interface names as
                // appropriate.
                //
                if (lstrcmpW(
                        networkInfo->Name,
                        adapterInfo->ConnectoidName
                        ) != 0
                   )
                {
                    if (netNameHasPrecedence) {
                        //
                        // Update the local connectoid name.
                        //
                        DWORD tempStatus;


                        ClNetDbgPrint((LOG_NOISE,
                            "[ClNet] Changing name of connectoid '%1!ws!' "
                            "(%2!ws!) to match name of cluster "
                            "network '%3!ws'\n",
                            adapterInfo->ConnectoidName,
                            adapterInfo->DeviceGuid,
                            networkInfo->Name
                            ));

                        tempStatus = ClRtlFindConnectoidByGuidAndSetName(
                                     adapterInfo->DeviceGuid,
                                     networkInfo->Name
                                     );

                        if ( tempStatus != ERROR_SUCCESS ) {
                            ClNetDbgPrint((LOG_UNUSUAL,
                                "[ClNet] Failed to change name of "
                                "connectoid from '%1!ws!' to '%2!ws!', "
                                "status %3!u!\n",
                                adapterInfo->ConnectoidName,
                                networkInfo->Name,
                                tempStatus
                                ));
                        }
                    }
                    else {
                        //
                        // Update the network name. The connectoid name
                        // may get tweaked for uniqueness as a side
                        // effect.
                        //
                        ClNetDbgPrint((LOG_UNUSUAL,
                            "[ClNet] Changing name of cluster "
                            "network '%1!ws!' (%2!ws!) to match name of "
                            "connectoid '%3!ws!'.\n",
                            networkInfo->Name,
                            networkInfo->Id,
                            adapterInfo->ConnectoidName
                            ));

                        networkName = ClNetpMakeUniqueNetworkName(
                                          adapterInfo->ConnectoidName,
                                          adapterInfo->DeviceGuid,
                                          ConfigLists,
                                          &unchangedConfigList
                                          );

                        if (networkName == NULL) {
                            status = ERROR_NOT_ENOUGH_MEMORY;
                            goto error_exit;
                        }

                        ClNetDbgPrint((
                            LOG_NOISE,
                            "[ClNet] Changed name of cluster "
                            "network '%1!ws!' (%2!ws!) to '%3!ws!'.\n",
                            networkInfo->Name,
                            networkInfo->Id,
                            networkName
                            ));

                        LocalFree(networkInfo->Name);
                        networkInfo->Name = networkName;
                        configEntry->UpdateNetworkName = TRUE;
                        somethingChanged = TRUE;
                    }
                }

                if (somethingChanged) {
                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] Updating configuration info for "
                        "interface '%1!ws!' (%2!ws!).\n",
                        interfaceInfo->Name,
                        interfaceInfo->Id
                        ));

                    status = ClNetpUpdateConfigEntry(
                                 configEntry,
                                 address,
                                 adapterId,
                                 adapterName,
                                 LocalNodeName,
                                 networkName
                                 );
                    
                    if (status != ERROR_SUCCESS) {
                        goto error_exit;
                    }
                    
                    //
                    // Move the entry to the updated interface list
                    //
                    RemoveEntryList(&(configEntry->Linkage));
                    InsertTailList(
                        &(ConfigLists->UpdatedInterfaceList),
                        &(configEntry->Linkage)
                        );
                }
                else {
                    //
                    // Move the entry to the unchanged list
                    //
                    RemoveEntryList(&(configEntry->Linkage));
                    InsertTailList(
                        &unchangedConfigList,
                        &(configEntry->Linkage)
                        );
                }
            }
            else {
                //
                // This node is no longer attached to this network.
                //
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] This node is no longer attached to "
                    "network '%1!ws!' (%2!ws!).\n",
                    networkInfo->Name,
                    networkInfo->Id
                    ));
                (*pClNetLogEvent3)(
                    LOG_NOISE,
                    CLNET_EVENT_DELETE_INTERFACE,
                    networkInfo->Name,
                    interfaceInfo->AdapterName,
                    interfaceInfo->Name
                    );
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Deleting interface '%1!ws!' (%2!ws!) from the "
                    "cluster configuration.\n",
                    interfaceInfo->Name,
                    interfaceInfo->Id
                    ));

                //
                // Move the entry to the deleted interface list.
                //
                RemoveEntryList(&(configEntry->Linkage));
                InsertTailList(
                    &(ConfigLists->DeletedInterfaceList),
                    &(configEntry->Linkage)
                    );
            }
        }
        else {
            //
            // This node was not previously attached to this network.
            // Search for a new attachment.
            //
            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] This node was not previously attached to "
                "network '%1!ws!' (%2!ws!).\n",
                networkInfo->Name,
                networkInfo->Id
                ));
            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] Searching for a new attachment...\n"
                ));

            adapterInfo = ClRtlFindNetAdapterByNetworkAddress(
                              adapterEnum,
                              networkInfo->Address,
                              networkInfo->AddressMask,
                              &adapterIfInfo
                              );

            if (adapterInfo != NULL) {
                //
                // Found a new adapter which is attached to this network.
                // Create a new interface definition for it.
                //
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Adapter '%1!ws!' (%2!ws!) is attached to "
                    "network %3!ws!.\n",
                    adapterInfo->DeviceName,
                    adapterInfo->DeviceGuid,
                    networkInfo->Name
                    ));

                //
                // Network name has precedence.
                // Update the local connectoid name if necessary.
                //
                if (lstrcmpW(
                        networkInfo->Name,
                        adapterInfo->ConnectoidName
                        ) != 0
                   )
                {
                    DWORD tempStatus;

                    ClNetDbgPrint((LOG_NOISE,
                        "[ClNet] Changing name of connectoid '%1!ws!' (%2!ws!) "
                        "to match name of cluster network '%3!ws!'\n",
                        adapterInfo->ConnectoidName,
                        adapterInfo->DeviceGuid,
                        networkInfo->Name
                        ));

                    tempStatus = ClRtlFindConnectoidByGuidAndSetName(
                                 adapterInfo->DeviceGuid,
                                 networkInfo->Name
                                 );

                    if ( tempStatus != ERROR_SUCCESS ) {
                        ClNetDbgPrint((
                            LOG_UNUSUAL,
                            "[ClNet] Failed to change name of connectoid "
                            "'%1!ws!' (%2!ws!) to '%3!ws!', status %4!u!.\n",
                            adapterInfo->ConnectoidName,
                            adapterInfo->DeviceGuid,
                            networkInfo->Name,
                            tempStatus
                            ));
                    }
                }

                status = ClNetpCreateConfigEntryInterface(
                             configEntry,
                             LocalNodeName,
                             LocalNodeId,
                             adapterInfo,
                             adapterIfInfo,
                             DefaultClusnetEndpoint
                             );

                if (status != ERROR_SUCCESS) {
                    goto error_exit;
                }

                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Created cluster interface '%1!ws!' (%2!ws!).\n",
                    configEntry->InterfaceInfo.Name,
                    configEntry->InterfaceInfo.Id
                    ));

                //
                // Put the entry on the created interface list
                //
                RemoveEntryList(&(configEntry->Linkage));
                InsertTailList(
                    &(ConfigLists->CreatedInterfaceList),
                    &(configEntry->Linkage)
                    );
            }
            else {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] This node is not attached to network '%1!ws!'.\n",
                    networkInfo->Name
                    ));

                //
                // Move the entry to the unchanged list
                //
                RemoveEntryList(&(configEntry->Linkage));
                InsertTailList(&unchangedConfigList, &(configEntry->Linkage));
            }
        }

        //
        // If we found an adapter on this network, then mark it as
        // consumed.
        //
        if (adapterInfo != NULL) {
            //
            // Consume the adapter
            adapterInfo->Ignore = TRUE;

            //
            //
            // Consume all other adapters that are attached to this
            // network
            //
            ClNetpConsumeAdaptersOnNetwork(
                adapterEnum,
                adapterIfInfo->NetworkAddressString,
                adapterIfInfo->NetworkMaskString
                );

            matchedNetworkCount++;
        }
    }

    //
    // Phase 2
    //
    // Create new networks for any remaining adapters.
    //
    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Phase 2 - Creating new networks for all remaining "
        "adapters.\n"
        ));

    for (adapterInfo = adapterEnum->AdapterList;
         adapterInfo != NULL;
         adapterInfo = adapterInfo->Next
        )
    {
        if ( !adapterInfo->Ignore && (adapterInfo->InterfaceCount > 0) ) {
            LPWSTR     newNetworkName;

            (*pClNetLogEvent1)(
                LOG_NOISE,
                CLNET_EVENT_CREATE_NETWORK,
                adapterInfo->ConnectoidName
                );

            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] Creating new network & interface for "
                "adapter '%1!ws!'.\n",
                adapterInfo->DeviceName
                ));

            //
            // Create a unique network name based on the connectoid name.
            // The connectoid name may get tweaked for uniqueness as a
            // side effect.
            //
            newNetworkName = ClNetpMakeUniqueNetworkName(
                                 adapterInfo->ConnectoidName,
                                 adapterInfo->DeviceGuid,
                                 ConfigLists,
                                 &unchangedConfigList
                                 );

            if (newNetworkName == NULL) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto error_exit;
            }

            adapterIfInfo = ClRtlGetPrimaryNetInterface(adapterInfo);

            if (adapterIfInfo == NULL) {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Not creating network for adapter "
                    " '%1!ws!' (%2!ws!) because its primary net "
                    "interface could not be found.\n",
                    adapterInfo->DeviceName,
                    adapterInfo->DeviceGuid
                    ));
                LocalFree(newNetworkName);
                continue;
            }

            configEntry = ClNetpCreateConfigEntry(
                              LocalNodeName,
                              LocalNodeId,
                              newNetworkName,
                              DefaultNetworkRole,
                              CLNET_DEFAULT_NETWORK_PRIORITY,
                              adapterInfo,
                              adapterIfInfo,
                              DefaultClusnetEndpoint
                              );

            //
            // LocalFree can call SetLastError so capture the real reason we
            // failed so it doesn't get obliterated.
            //
            if ( configEntry == NULL ) {
                status = GetLastError();
            }

            LocalFree(newNetworkName);

            if (configEntry == NULL) {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Failed to create new network & interface "
                    "for adapter '%1!ws!' (%2!ws!). status %3!u!\n",
                    adapterInfo->DeviceName,
                    adapterInfo->DeviceGuid,
                    status
                    ));
                goto error_exit;
            }

            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] Created interface '%1!ws!' (%2!ws!).\n",
                configEntry->InterfaceInfo.Name,
                configEntry->InterfaceInfo.Id
                ));

            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] Created network '%1!ws!' (%2!ws!).\n",
                configEntry->NetworkInfo.Name,
                configEntry->NetworkInfo.Id
                ));

            InsertTailList(
                &(ConfigLists->CreatedNetworkList),
                &(configEntry->Linkage)
                );

            //
            // Consume the adapter
            adapterInfo->Ignore = TRUE;

            //
            //
            // Consume all other adapters that are attached to this
            // network
            //
            ClNetpConsumeAdaptersOnNetwork(
                adapterEnum,
                adapterIfInfo->NetworkAddressString,
                adapterIfInfo->NetworkMaskString
                );

            newNetworkCount++;
        }
    }

    status = ERROR_SUCCESS;

    *MatchedNetworkCount = matchedNetworkCount;
    *NewNetworkCount = newNetworkCount;

error_exit:

    //
    // Move unchanged entries back to the input list.
    //
    while (!IsListEmpty(&unchangedConfigList)) {
        listEntry = RemoveHeadList(&(unchangedConfigList));
        InsertTailList(&(ConfigLists->InputConfigList), listEntry);
    }

    //
    // Free the adapter resources
    //
    if (adapterEnum != NULL) {
        ClRtlFreeNetAdapterEnum(adapterEnum);
    }

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        (*pClNetLogEvent1)(LOG_CRITICAL, eventCode, errorString);
    }

    if (status == ERROR_SUCCESS) {
        ClNetDbgPrint((LOG_NOISE,
            "[ClNet] Network configuration complete...\n"
            ));
    }

    return(status);

}  // ClNetConfigureNetworks


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clnetcfg\clnettst.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <objbase.h>
#include <wchar.h>
#include <cluster.h>
#include <clusrpc.h>
#include <clnetcfg.h>
#include <iphlpapi.h>
#include <winsock2.h>

#define NM_WCSLEN(_string)    ((lstrlenW(_string) + 1) * sizeof(WCHAR))

CLNET_CONFIG_LISTS  ConfigLists;
LPWSTR              NodeName = L"TestComputer";
LPWSTR              NodeId = L"1";

#if 0
#include <dm.h>
#include <dmp.h>

HKEY DmpRoot;
LIST_ENTRY KeyList;
CRITICAL_SECTION KeyLock;
HDMKEY DmClusterParametersKey;
HDMKEY DmResourcesKey;
HDMKEY DmResourceTypesKey;
HDMKEY DmGroupsKey;
HDMKEY DmNodesKey;
HDMKEY DmNetworksKey;
HDMKEY DmNetInterfacesKey;
HDMKEY DmQuorumKey;
HANDLE ghQuoLogOpenEvent=NULL;

typedef struct _DMP_KEY_DEF {
    HDMKEY *pKey;
    LPWSTR Name;
} DMP_KEY_DEF;

DMP_KEY_DEF DmpKeyTable[] = {
    {&DmResourcesKey, CLUSREG_KEYNAME_RESOURCES},
    {&DmResourceTypesKey, CLUSREG_KEYNAME_RESOURCE_TYPES},
    {&DmQuorumKey, CLUSREG_KEYNAME_QUORUM},
    {&DmGroupsKey, CLUSREG_KEYNAME_GROUPS},
    {&DmNodesKey, CLUSREG_KEYNAME_NODES},
    {&DmNetworksKey, CLUSREG_KEYNAME_NETWORKS},
    {&DmNetInterfacesKey, CLUSREG_KEYNAME_NETINTERFACES}};
#endif

VOID
ClNetPrint(
    IN ULONG  LogLevel,
    IN PCHAR  FormatString,
    ...
    )
{
    CHAR      buffer[256];
    DWORD     bytes;
    va_list   argList;

    va_start(argList, FormatString);

    bytes = FormatMessageA(
                FORMAT_MESSAGE_FROM_STRING,
                FormatString,
                0,
                0,
                buffer,
                sizeof(buffer),
                &argList
                );

    va_end(argList);

    if (bytes != 0) {
        printf("%s", buffer);
    }

    return;

} // ClNetPrint

VOID
ClNetLogEvent(
    IN DWORD    LogLevel,
    IN DWORD    MessageId
    )
{
    return;

}  // ClNetLogEvent

VOID
ClNetLogEvent1(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1
    )
{
    return;

}  // ClNetLogEvent1


VOID
ClNetLogEvent2(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2
    )
{
    return;

}  // ClNetLogEvent2


VOID
ClNetLogEvent3(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2,
    IN LPCWSTR  Arg3
    )
{
    return;

}  // ClNetLogEvent3


void
PrintConfigEntry(
    PCLNET_CONFIG_ENTRY   ConfigEntry
    )
{
    PNM_NETWORK_INFO  Network = &(ConfigEntry->NetworkInfo);
    PNM_INTERFACE_INFO   Interface = &(ConfigEntry->InterfaceInfo);

    printf("\t*************\n");
    printf("\tNet Id\t\t%ws\n", Network->Id);
    printf("\tName\t\t%ws\n", Network->Name);
    printf("\tDesc\t\t%ws\n", Network->Description);
    printf("\tRole\t\t%u\n", Network->Role);
    printf("\tPriority\t%u\n", Network->Priority);
    printf("\tTransport\t%ws\n", Network->Transport);
    printf("\tAddress\t\t%ws\n", Network->Address);
    printf("\tMask\t\t%ws\n", Network->AddressMask);
    printf("\tIf Id\t\t%ws\n", Interface->Id);
    printf("\tName\t\t%ws\n", Interface->Name);
    printf("\tDesc\t\t%ws\n", Interface->Description);
    printf("\tNodeId\t\t%ws\n", Interface->NodeId);
    printf("\tAdapter\t\t%ws\n", Interface->Adapter);
    printf("\tAddress\t\t%ws\n", Interface->Address);
    printf("\tEndpoint\t%ws\n", Interface->ClusnetEndpoint);
    printf("\tState\t\t%u\n\n", Interface->State);

    return;
}


void
PrintResults(void)
{
    PCLNET_CONFIG_ENTRY   configEntry;
    PLIST_ENTRY           listEntry;


    printf("Renamed interface list:\n");

    for ( listEntry = ConfigLists.RenamedInterfaceList.Flink;
          listEntry != &ConfigLists.RenamedInterfaceList;
          listEntry = listEntry->Flink
        )
    {
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );
        PrintConfigEntry(configEntry);
    }

    printf("Deleted interface list:\n");

    for ( listEntry = ConfigLists.DeletedInterfaceList.Flink;
          listEntry != &ConfigLists.DeletedInterfaceList;
          listEntry = listEntry->Flink
        )
    {
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );
        PrintConfigEntry(configEntry);
    }

    printf("Updated interface list:\n");

    for ( listEntry = ConfigLists.UpdatedInterfaceList.Flink;
          listEntry != &ConfigLists.UpdatedInterfaceList;
          listEntry = listEntry->Flink
        )
    {
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );
        PrintConfigEntry(configEntry);
    }

    printf("Created interface list:\n");

    for ( listEntry = ConfigLists.CreatedInterfaceList.Flink;
          listEntry != &ConfigLists.CreatedInterfaceList;
          listEntry = listEntry->Flink
        )
    {
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );
        PrintConfigEntry(configEntry);
    }

    printf("Created network list:\n");

    for ( listEntry = ConfigLists.CreatedNetworkList.Flink;
          listEntry != &ConfigLists.CreatedNetworkList;
          listEntry = listEntry->Flink
        )
    {
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );
        PrintConfigEntry(configEntry);
    }

    printf("Unchanged interface list:\n");

    for ( listEntry = ConfigLists.InputConfigList.Flink;
          listEntry != &ConfigLists.InputConfigList;
          listEntry = listEntry->Flink
        )
    {
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );
        PrintConfigEntry(configEntry);
    }

    return;
}


void
ConsolidateLists(
    PLIST_ENTRY  MasterList,
    PLIST_ENTRY  OtherList
    )
{
    PLIST_ENTRY  entry;

    while (!IsListEmpty(OtherList)) {
        entry = RemoveHeadList(OtherList);
        InsertTailList(MasterList, entry);
    }

    return;
}
#if 0
DWORD
DmpOpenKeys(
    IN REGSAM samDesired
    )
/*++

Routine Description:

    Opens all the standard cluster registry keys. If any of the
    keys are already opened, they will be closed and reopened.

Arguments:

    samDesired - Supplies the access that the keys will be opened with.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD i;
    DWORD status;

    status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                           L"Cluster",
                           0,
                           samDesired,
                           &ClusterRegKey);

    if ( status == ERROR_SUCCESS ) {
    for (i=0;
         i<sizeof(DmpKeyTable)/sizeof(DMP_KEY_DEF);
         i++) {

        *DmpKeyTable[i].pKey = DmOpenKey(DmClusterParametersKey,
                                         DmpKeyTable[i].Name,
                                         samDesired);
        if (*DmpKeyTable[i].pKey == NULL) {
            Status = GetLastError();
            CsDbgPrint(LOG_CRITICAL,
                       ("[DM]: Failed to open key %1!ws!, status %2!u!\n",
                       DmpKeyTable[i].Name,
                       Status));
            CL_UNEXPECTED_ERROR( Status );
            return(Status);
        }
    }
    }
    return status;
}

HDMKEY
DmOpenKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD samDesired
    )

/*++

Routine Description:

    Opens a key in the cluster registry. If the key exists, it
    is opened. If it does not exist, the call fails.

Arguments:

    hKey - Supplies the key that the open is relative to.

    lpSubKey - Supplies the key name relative to hKey

    samDesired - Supplies desired security access mask

Return Value:

    A handle to the specified key if successful

    NULL otherwise. LastError will be set to the specific error code.

--*/

{
    PDMKEY  Parent;
    PDMKEY  Key=NULL;
    DWORD   NameLength;
    DWORD   Status = ERROR_SUCCESS;

    Parent = (PDMKEY)hKey;

    //check if the key was deleted and invalidated
    if (ISKEYDELETED(Parent))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }
    //
    // Allocate the DMKEY structure.
    //
    NameLength = (lstrlenW(Parent->Name) + 1 + lstrlenW(lpSubKey) + 1)*sizeof(WCHAR);
    Key = LocalAlloc(LMEM_FIXED, sizeof(DMKEY)+NameLength);
    if (Key == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CL_UNEXPECTED_ERROR(Status);
        goto FnExit;
    }

    //
    // Open the key on the local machine.
    //
    Status = RegOpenKeyEx(Parent->hKey,
                          lpSubKey,
                          0,
                          samDesired,
                          &Key->hKey);
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }

    //
    // Create the key name
    //
    lstrcpyW(Key->Name, Parent->Name);
    if (Key->Name[0] != UNICODE_NULL) {
        lstrcatW(Key->Name, L"\\");
    }
    lstrcatW(Key->Name, lpSubKey);
    Key->GrantedAccess = samDesired;

    EnterCriticalSection(&KeyLock);
    InsertHeadList(&KeyList, &Key->ListEntry);
    InitializeListHead(&Key->NotifyList);
    LeaveCriticalSection(&KeyLock);

FnExit:
    if (Status != ERROR_SUCCESS)
    {
        if (Key) LocalFree(Key);
        SetLastError(Status);
        return(NULL);
    }
    else
        return((HDMKEY)Key);


}


DWORD
NmpQueryString(
    IN     HDMKEY   Key,
    IN     LPCWSTR  ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    )

/*++

Routine Description:

    Reads a REG_SZ or REG_MULTI_SZ registry value. If the StringBuffer is
    not large enough to hold the data, it is reallocated.

Arguments:

    Key              - Open key for the value to be read.

    ValueName        - Unicode name of the value to be read.

    ValueType        - REG_SZ or REG_MULTI_SZ.

    StringBuffer     - Buffer into which to place the value data.

    StringBufferSize - Pointer to the size of the StringBuffer. This parameter
                       is updated if StringBuffer is reallocated.

    StringSize       - The size of the data returned in StringBuffer, including
                       the terminating null character.

Return Value:

    The status of the registry query.

--*/
{
    DWORD    status;
    DWORD    valueType;
    WCHAR   *temp;
    DWORD    oldBufferSize = *StringBufferSize;
    BOOL     noBuffer = FALSE;


    if (*StringBufferSize == 0) {
        noBuffer = TRUE;
    }

    *StringSize = *StringBufferSize;

    status = DmQueryValue( Key,
                           ValueName,
                           &valueType,
                           (LPBYTE) *StringBuffer,
                           StringSize
                         );

    if (status == NO_ERROR) {
        if (!noBuffer ) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                return(ERROR_INVALID_PARAMETER);
            }
        }

        status = ERROR_MORE_DATA;
    }

    if (status == ERROR_MORE_DATA) {
        temp = MIDL_user_allocate(*StringSize);

        if (temp == NULL) {
            *StringSize = 0;
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (!noBuffer) {
            MIDL_user_free(*StringBuffer);
        }

        *StringBuffer = temp;
        *StringBufferSize = *StringSize;

        status = DmQueryValue( Key,
                               ValueName,
                               &valueType,
                               (LPBYTE) *StringBuffer,
                               StringSize
                             );

        if (status == NO_ERROR) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                *StringSize = 0;
                return(ERROR_INVALID_PARAMETER);
            }
        }
    }

    return(status);

} // NmpQueryString


DWORD
NmpGetNetworkDefinition(
    IN  LPWSTR            NetworkId,
    OUT PNM_NETWORK_INFO  NetworkInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster network from the cluster
    database and fills in a structure describing it.

Arguments:

    NetworkId   - A pointer to a unicode string containing the ID of the
                  network to query.

    NetworkInfo - A pointer to the network info structure to fill in.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD                    status;
    HDMKEY                   networkKey = NULL;
    DWORD                    valueLength, valueSize;
    DWORD                    i;
    PNM_INTERFACE_ENUM       interfaceEnum;


    ZeroMemory(NetworkInfo, sizeof(NM_NETWORK_INFO));

    //
    // Open the network's key.
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkId, KEY_READ);

    if (networkKey == NULL) {
        status = GetLastError();
        ClNetPrint(LOG_CRITICAL,
            "[NM] Failed to open network key, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Copy the ID value.
    //
    NetworkInfo->Id = MIDL_user_allocate(NM_WCSLEN(NetworkId));

    if (NetworkInfo->Id == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    wcscpy(NetworkInfo->Id, NetworkId);

    //
    // Read the network's name.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_NAME,
                 REG_SZ,
                 &(NetworkInfo->Name),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of name value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the description value.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_DESC,
                 REG_SZ,
                 &(NetworkInfo->Description),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of description value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the role value.
    //
    status = DmQueryDword(
                 networkKey,
                 CLUSREG_NAME_NET_ROLE,
                 &(NetworkInfo->Role),
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of role value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the priority value.
    //
    status = DmQueryDword(
                 networkKey,
                 CLUSREG_NAME_NET_PRIORITY,
                 &(NetworkInfo->Priority),
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of priority value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the address value.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_ADDRESS,
                 REG_SZ,
                 &(NetworkInfo->Address),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of address value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the address mask.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_ADDRESS_MASK,
                 REG_SZ,
                 &(NetworkInfo->AddressMask),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of address mask value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the transport name.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_TRANSPORT,
                 REG_SZ,
                 &(NetworkInfo->Transport),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of transport value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

error_exit:

    if (status != ERROR_SUCCESS) {
        ClNetFreeNetworkInfo(NetworkInfo);
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
    }

    return(status);

}  // NmpGetNetworkDefinition

DWORD
NmpEnumNetworkDefinitions(
    OUT PNM_NETWORK_ENUM *   NetworkEnum
    )
/*++

Routine Description:

    Reads information about defined cluster networks from the cluster
    database. and builds an enumeration structure to hold the information.

Arguments:

    NetworkEnum -  A pointer to the variable into which to place a pointer to
                   the allocated network enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD              status;
    PNM_NETWORK_ENUM   networkEnum = NULL;
    PNM_NETWORK_INFO   networkInfo;
    WCHAR              networkId[CS_NETWORK_ID_LENGTH + 1];
    DWORD              i;
    DWORD              valueLength;
    DWORD              numNetworks;
    DWORD              ignored;
    FILETIME           fileTime;


    *NetworkEnum = NULL;

    //
    // First count the number of networks.
    //
    status = DmQueryInfoKey(
                 DmNetworksKey,
                 &numNetworks,
                 &ignored,   // MaxSubKeyLen
                 &ignored,   // Values
                 &ignored,   // MaxValueNameLen
                 &ignored,   // MaxValueLen
                 &ignored,   // lpcbSecurityDescriptor
                 &fileTime
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Failed to query Networks key information, status %1!u!\n",
            status
            );
        return(status);
    }

    if (numNetworks == 0) {
        valueLength = sizeof(NM_NETWORK_ENUM);

    }
    else {
        valueLength = sizeof(NM_NETWORK_ENUM) +
                      (sizeof(NM_NETWORK_INFO) * (numNetworks-1));
    }

    valueLength = sizeof(NM_NETWORK_ENUM) +
                  (sizeof(NM_NETWORK_INFO) * (numNetworks-1));

    networkEnum = MIDL_user_allocate(valueLength);

    if (networkEnum == NULL) {
        ClNetPrint(LOG_CRITICAL, "[NM] Failed to allocate memory.\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(networkEnum, valueLength);

    for (i=0; i < numNetworks; i++) {
        networkInfo = &(networkEnum->NetworkList[i]);

        valueLength = sizeof(networkId);

        status = DmEnumKey(
                     DmNetworksKey,
                     i,
                     &(networkId[0]),
                     &valueLength,
                     NULL
                     );

        if (status != ERROR_SUCCESS) {
            ClNetPrint(LOG_CRITICAL,
                "[NM] Failed to enumerate network key, status %1!u!\n",
                status
                );
            goto error_exit;
        }

        status = NmpGetNetworkDefinition(networkId, networkInfo);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        networkEnum->NetworkCount++;
    }

    *NetworkEnum = networkEnum;

    return(ERROR_SUCCESS);


error_exit:

    if (networkEnum != NULL) {
        ClNetFreeNetworkEnum(networkEnum);
    }

    return(status);
}

DWORD
ReadRegData(
    IN PCLNET_CONFIG_LISTS Lists
    )

/*++

  Read the cluster registry data and bulid up an input list
  similar to what happens in the cluster service.

--*/

{
    DWORD                   status;
    PNM_NETWORK_ENUM *      networkEnum;
    PNM_INTERFACE_ENUM *    interfaceEnum;
    LPWSTR                  localNodeId;

    status = DmpOpenKeys(MAXIMUM_ALLOWED);
    if (status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( status );
        return(status);
    }

    status = ClNetConvertEnumsToConfigList(networkEnum,
                                           interfaceEnum,
                                           localNodeId,
                                           &Lists->InputConfigList);

    return status;
}
#endif

int _cdecl
main(
    int argc,
    char** argv
    )
{
    DWORD             status;
    DWORD             i;
    WSADATA           wsaData;
    WORD              versionRequested;
    int               err;
    SOCKET            s;
    DWORD             bytesReturned;
    DWORD             matchedNetworkCount;
    DWORD             newNetworkCount;


    ClNetInitialize(
        ClNetPrint,
        ClNetLogEvent,
        ClNetLogEvent1,
        ClNetLogEvent2,
        ClNetLogEvent3
        );

    ClNetInitializeConfigLists(&ConfigLists);

//    ReadRegData( &ConfigLists );

    versionRequested = MAKEWORD(2,0);

    err = WSAStartup(versionRequested, &wsaData);

    if (err != 0) {
        status = WSAGetLastError();
        printf("wsastartup failed, %u\n", status);
        return(1);
    }

    s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    if (s == INVALID_SOCKET) {
        status = WSAGetLastError();
        printf("socket failed, %u\n", status);
        return(1);
    }

    //
    // Init COM
    //

    status = CoInitializeEx( NULL, COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED );
    if ( !SUCCEEDED( status )) {
        printf("Couldn't init COM %08X\n", status );
        return 1;
    }

    for (i=0; ; i++) {
        printf("\nIteration #%u\n\n", i);

        status = ClNetConfigureNetworks(
                     NodeId,
                     NodeName,
                     L"4303",
                     TRUE,
                     &ConfigLists,
                     &matchedNetworkCount,
                     &newNetworkCount
                     );

        if (status != ERROR_SUCCESS) {
            printf("Config failed, status %u\n", status);
            return(1);
        }

        printf("Config succeeded - matched Networks = %u, new Networks = %u\n\n",
               matchedNetworkCount, newNetworkCount);

        PrintResults();

        ClNetFreeConfigList(&ConfigLists.RenamedInterfaceList);
        ClNetFreeConfigList(&ConfigLists.DeletedInterfaceList);

        ConsolidateLists(
            &ConfigLists.InputConfigList,
            &ConfigLists.UpdatedInterfaceList
            );
        ConsolidateLists(
            &ConfigLists.InputConfigList,
            &ConfigLists.CreatedInterfaceList
            );
        ConsolidateLists(
            &ConfigLists.InputConfigList,
            &ConfigLists.CreatedNetworkList
            );

        printf("Waiting for PnP event\n");

        err = WSAIoctl(
                  s,
                  SIO_ADDRESS_LIST_CHANGE,
                  NULL,
                  0,
                  NULL,
                  0,
                  &bytesReturned,
                  NULL,
                  NULL
                  );


        if (err != 0) {
            status = WSAGetLastError();
            printf("wsastartup failed, %u\n", status);
            return(1);
        }

        printf("PnP notification received\n");
    }

    CoUninitialize();
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\clusapip.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    clusapip.h

Abstract:

    Private header file for cluster api

Author:

    John Vert (jvert) 15-Jan-1996

Revision History:

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "cluster.h"
#include "api_rpc.h"

//
// Define CLUSTER structure. There is one cluster structure created
// for each OpenCluster API call. An HCLUSTER is really a pointer to
// this structure.
//

#define CLUS_SIGNATURE 'SULC'

typedef struct _RECONNECT_CANDIDATE {
    BOOL IsUp;
    BOOL IsCurrent;
    LPWSTR Name;
} RECONNECT_CANDIDATE, *PRECONNECT_CANDIDATE;

typedef struct _CLUSTER {
    DWORD Signature;
    DWORD ReferenceCount;
    DWORD FreedRpcHandleListLen;
    LPWSTR ClusterName;
    LPWSTR NodeName;                    // node name we are connected to
    DWORD Flags;
    RPC_BINDING_HANDLE RpcBinding;
    HCLUSTER_RPC hCluster;
    LIST_ENTRY KeyList;                 // open cluster registry keys
    LIST_ENTRY ResourceList;            // open resource handles
    LIST_ENTRY GroupList;               // open group handles
    LIST_ENTRY NodeList;                // open node handles
    LIST_ENTRY NetworkList;             // open network handles
    LIST_ENTRY NetInterfaceList;        // open net interface handles
    LIST_ENTRY NotifyList;              // outstanding notification event filters
    LIST_ENTRY SessionList;             // open notification sessions.
    unsigned long AuthnLevel;           // Level of authentication to be performed on remote procedure calls 
    HANDLE NotifyThread;
    CRITICAL_SECTION Lock;
    DWORD Generation;
    DWORD ReconnectCount;
    PRECONNECT_CANDIDATE Reconnect;
    LIST_ENTRY FreedBindingList;
    LIST_ENTRY FreedContextList;
} CLUSTER, *PCLUSTER;

// [GorN] Jan/13/1999
// This is a temporary fix for the race between the users
// of binding and context handles and reconnectThread
//
// The code assumes that RPC_BINDING_HANDLE == ContextHandle == void*

typedef struct _CTX_HANDLE {
    LIST_ENTRY HandleList;
    void * RpcHandle; // assumption RPC_BINDING_HANDLE == ContextHandle == void*
    ULONGLONG TimeStamp;
} CTX_HANDLE, *PCTX_HANDLE;

RPC_STATUS 
FreeRpcBindingOrContext(
    IN PCLUSTER Cluster,
    IN void **  RpcHandle,
    IN BOOL     IsBinding);

#define MyRpcBindingFree(Cluster, Binding) \
    FreeRpcBindingOrContext(Cluster, Binding, TRUE)

#define MyRpcSmDestroyClientContext(Cluster, Context) \
    FreeRpcBindingOrContext(Cluster, Context, FALSE)

VOID
FreeObsoleteRpcHandlesEx(
    IN PCLUSTER Cluster,
    IN BOOL     Cleanup,
    IN BOOL     IsBinding
    );

#define FreeObsoleteRpcHandles(Cluster, Cleanup) { \
    FreeObsoleteRpcHandlesEx(Cluster, Cleanup, TRUE); \
    FreeObsoleteRpcHandlesEx(Cluster, Cleanup, FALSE); \
    }
    
    
//
// Define CLUSTER.Flags
//
#define CLUS_DELETED 1
#define CLUS_DEAD    2
#define CLUS_LOCALCONNECT 4

//
// Cluster helper macros
//
#define GET_CLUSTER(hCluster) (PCLUSTER)((((PCLUSTER)(hCluster))->Flags & CLUS_DELETED) ? NULL : hCluster)

#define IS_CLUSTER_FREE(c) ((c->Flags & CLUS_DELETED) &&         \
                            (IsListEmpty(&(c)->KeyList)) &&      \
                            (IsListEmpty(&(c)->GroupList)) &&    \
                            (IsListEmpty(&(c)->NodeList)) &&     \
                            (IsListEmpty(&(c)->ResourceList)) && \
                            (IsListEmpty(&(c)->NetworkList)) &&  \
                            (IsListEmpty(&(c)->NetInterfaceList)))

//
// Cluster structure cleanup routine.
//
VOID
CleanupCluster(
    IN PCLUSTER Cluster
    );

VOID
RundownNotifyEvents(
    IN PLIST_ENTRY ListHead,
    IN LPCWSTR Name
    );

//
// Define CRESOURCE structure. There is one resource structure created
// for each OpenResource/CreateResource API call. An HRESOURCE is really
// a pointer to this structure. These are chained onto the CLUSTER that
// they were opened relative to.
//
typedef struct _CRESOURCE {
    LIST_ENTRY ListEntry;               // Links for chaining onto CLUSTER.ResourceList
    LIST_ENTRY NotifyList;              // Links for tracking outstanding notifies.
    PCLUSTER Cluster;                   // Parent cluster
    LPWSTR Name;
    HRES_RPC hResource;                 // RPC handle
} CRESOURCE, *PCRESOURCE;


//
// Define CGROUP structure. There is one group structure created
// for each OpenGroup/CreateGroup API call. An HGROUP is really
// a pointer to this structure. These are chained onto the CLUSTER that
// they were opened relative to.
//
typedef struct _CGROUP {
    LIST_ENTRY ListEntry;               // Links for chaining onto CLUSTER.Group
    LIST_ENTRY NotifyList;              // Links for tracking outstanding notifies.
    PCLUSTER Cluster;                   // Parent cluster
    LPWSTR Name;
    HRES_RPC hGroup;                    // RPC handle
} CGROUP, *PCGROUP;

//
// Define CNODE structure. There is one node structure created
// for each OpenClusterNode call. An HNODE is really a pointer
// to this structure. These are chained onto the CLUSTER that they
// were opened relative to.
//
typedef struct _CNODE {
    LIST_ENTRY ListEntry;               // Links for chaining onto CLUSTER.NodeList
    LIST_ENTRY NotifyList;              // Links for tracking outstanding notifies.
    PCLUSTER Cluster;                   // Parent cluster
    LPWSTR Name;
    HNODE_RPC hNode;                    // RPC handle
} CNODE, *PCNODE;

//
// Define CNETWORK structure. There is one network structure created
// for each OpenNetwork API call. An HNETWORK is really a pointer to
// this structure. These are chained onto the CLUSTER that they were
// opened relative to.
//
typedef struct _CNETWORK {
    LIST_ENTRY ListEntry;               // Links for chaining onto CLUSTER.NetworkList
    LIST_ENTRY NotifyList;              // Links for tracking outstanding notifies.
    PCLUSTER Cluster;                   // Parent cluster
    LPWSTR Name;
    HNETWORK_RPC hNetwork;                    // RPC handle
} CNETWORK, *PCNETWORK;

//
// Define CNETINTERFACE structure. There is one network interface structure
// created for each OpenNetInterface API call. An HNETINTERFACE is really a
// pointer to this structure. These are chained onto the CLUSTER that they
// were opened relative to.
//
typedef struct _CNETINTERFACE {
    LIST_ENTRY ListEntry;               // Links for chaining onto CLUSTER.NetInterfaceList
    LIST_ENTRY NotifyList;              // Links for tracking outstanding notifies.
    PCLUSTER Cluster;                   // Parent cluster
    LPWSTR Name;
    HNETINTERFACE_RPC hNetInterface;    // RPC handle
} CNETINTERFACE, *PCNETINTERFACE;

//
// Define cluster registry key handle structure.
//
// These are kept around in a tree to track all outstanding
// registry handles. This allows the handles to be re-opened
// transparently in the event that the cluster node we are
// communicating with crashes.
//
typedef struct _CKEY {
    LIST_ENTRY ParentList;
    LIST_ENTRY ChildList;
    LIST_ENTRY NotifyList;
    struct _CKEY *Parent;
    PCLUSTER Cluster;
    LPWSTR RelativeName;
    HKEY_RPC RemoteKey;
    REGSAM SamDesired;
} CKEY, *PCKEY;

//
// Define CNOTIFY structure.  There is one CNOTIFY structure for each
// notification port.  A notification port contains zero or more notify
// sessions. Each session is an RPC connection to a different cluster.
// Each session contains one or more notify events. Each event represents
// a a registered notification on a cluster object. Events are linked onto
// both the session structure and the cluster object structure. Events are
// removed from a notification session when the cluster object handle is
// closed, or the cluster notify port itself is closed. When the last event
// in a session is removed, the session is cleaned up. This closes the RPC
// connection.
//


typedef struct _CNOTIFY {
    LIST_ENTRY SessionList;
    CRITICAL_SECTION Lock;
    CL_QUEUE Queue;
    CL_HASH  NotifyKeyHash;
    LIST_ENTRY OrphanedEventList;       // CNOTIFY_EVENTs whose object has been closed
                                        // We cannot get rid of these as there may still
                                        // be some packets referencing the CNOTIFY_EVENT
                                        // structure in either the server or client-side
                                        // queues.
} CNOTIFY, *PCNOTIFY;

typedef struct _CNOTIFY_SESSION {
    LIST_ENTRY ListEntry;               // Linkage onto CNOTIFY.SessionList
    LIST_ENTRY ClusterList;             // Linkage onto CLUSTER.SessionList
    LIST_ENTRY EventList;               // List of CNOTIFY_EVENTs on this session
    PCLUSTER Cluster;
    HNOTIFY_RPC hNotify;
    HANDLE NotifyThread;
    PCNOTIFY ParentNotify;
    BOOL Destroyed;                     // Set by DestroySession so NotifyThread doesn't
                                        // try and reconnect
} CNOTIFY_SESSION, *PCNOTIFY_SESSION;

typedef struct _CNOTIFY_EVENT {
    LIST_ENTRY ListEntry;               // Linkage onto CNOTIFY_SESSION.EventList
    LIST_ENTRY ObjectList;              // Linkage onto cluster object's list.
    PCNOTIFY_SESSION Session;
    DWORD dwFilter;
    DWORD_PTR dwNotifyKey;
    DWORD StateSequence;
    DWORD EventId;
    PVOID Object;
} CNOTIFY_EVENT, *PCNOTIFY_EVENT;

typedef struct _CNOTIFY_PACKET {
    LIST_ENTRY ListEntry;
    DWORD     Status;
    DWORD     KeyId;
    DWORD     Filter;
    DWORD     StateSequence;
    LPWSTR    Name;
} CNOTIFY_PACKET, *PCNOTIFY_PACKET;

DWORD
RegisterNotifyEvent(
    IN PCNOTIFY_SESSION Session,
    IN PCNOTIFY_EVENT Event,
    OUT OPTIONAL PLIST_ENTRY *pNotifyList
    );

DWORD
ReRegisterNotifyEvent(
    IN PCNOTIFY_SESSION Session,
    IN PCNOTIFY_EVENT Event,
    OUT OPTIONAL PLIST_ENTRY *pNotifyList
    );

//
// Wrappers for RPC functions. These are equivalent to the raw RPC interface, except
// that they filter out connection errors and perform transparent reconnects.
//
DWORD
ReconnectCluster(
    IN PCLUSTER Cluster,
    IN DWORD Error,
    IN DWORD Generation
    );

DWORD
GetReconnectCandidates(
    IN PCLUSTER Cluster
    );

VOID
FreeReconnectCandidates(
    IN PCLUSTER Cluster
    );


#define WRAP(_outstatus_, _fn_,_clus_)                  \
{                                                       \
    DWORD _err_;                                        \
    DWORD _generation_;                                 \
                                                        \
    while (TRUE) {                                      \
        if ((_clus_)->Flags & CLUS_DEAD) {              \
            TIME_PRINT(("Failing "#_fn_ " due to dead cluster\n")); \
            _err_ = RPC_S_SERVER_UNAVAILABLE;           \
            break;                                      \
        }                                               \
        FreeObsoleteRpcHandles(_clus_, FALSE);          \
        _generation_ = (_clus_)->Generation;            \
        TIME_PRINT(("Calling " #_fn_ "\n"));            \
        _err_ = _fn_;                                   \
        if (_err_ != ERROR_SUCCESS) {                   \
            _err_ = ReconnectCluster(_clus_,            \
                                     _err_,             \
                                     _generation_);     \
            if (_err_ == ERROR_SUCCESS) {               \
                continue;                               \
            }                                           \
        }                                               \
        break;                                          \
    }                                                   \
    _outstatus_ = _err_;                                \
}


//
// This variation of WRAP only attempts to reconnect if _condition_ == TRUE.
// This is useful for threads such as the NotifyThread that can have their
// context handle closed out from under them by another thread.
//
#define WRAP_CHECK(_outstatus_, _fn_,_clus_,_condition_)   \
{                                                       \
    DWORD _err_;                                        \
    DWORD _generation_;                                 \
                                                        \
    while (TRUE) {                                      \
        if ((_clus_)->Flags & CLUS_DEAD) {              \
            TIME_PRINT(("Failing "#_fn_ " due to dead cluster\n")); \
            _err_ = RPC_S_SERVER_UNAVAILABLE;           \
            break;                                      \
        }                                               \
        FreeObsoleteRpcHandles(_clus_, FALSE);          \
        _generation_ = (_clus_)->Generation;            \
        TIME_PRINT(("Calling " #_fn_ "\n"));            \
        _err_ = _fn_;                                   \
        if ((_err_ != ERROR_SUCCESS) && (_condition_)) {  \
            _err_ = ReconnectCluster(_clus_,            \
                                     _err_,             \
                                     _generation_);     \
            if (_err_ == ERROR_SUCCESS) {               \
                continue;                               \
            }                                           \
        }                                               \
        break;                                          \
    }                                                   \
    _outstatus_ = _err_;                                \
}

#define WRAP_NULL(_outvar_, _fn_, _reterr_, _clus_)     \
{                                                       \
    DWORD _err_;                                        \
    DWORD _generation_;                                 \
                                                        \
    while (TRUE) {                                      \
        if ((_clus_)->Flags & CLUS_DEAD) {              \
            TIME_PRINT(("Failing "#_fn_ " due to dead cluster\n")); \
            *(_reterr_) = RPC_S_SERVER_UNAVAILABLE;     \
            _outvar_ = NULL;                            \
            break;                                      \
        }                                               \
        FreeObsoleteRpcHandles(_clus_, FALSE);          \
        _generation_ = (_clus_)->Generation;            \
        _outvar_ = _fn_;                                \
        if ((_outvar_ == NULL) ||                       \
            (*(_reterr_) != ERROR_SUCCESS)) {           \
            *(_reterr_) = ReconnectCluster(_clus_,      \
                                           *(_reterr_), \
                                           _generation_);  \
            if (*(_reterr_) == ERROR_SUCCESS) {         \
                continue;                               \
            }                                           \
        }                                               \
        break;                                          \
    }                                                   \
}

//
// A version of lstrcpynW that doesn't bother doing try/except so it doesn't
// quietly succeed if somebody passes in NULL.
//
VOID
APIENTRY
MylstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    DWORD iMaxLength
    );

//
// Increase the reference count on a cluster handle.
//
DWORD
WINAPI
AddRefToClusterHandle( 
    IN HCLUSTER hCluster
    );

#define _API_PRINT 0

#if _API_PRINT
ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

#define ApiPrint(_x_) {           \
    if (IsDebuggerPresent()) {    \
        DbgPrint _x_ ;            \
    }                             \
}

//
// Timing macro
//

#define TIME_PRINT(_x_) {                                \
    DWORD msec;                                          \
                                                         \
    msec = GetTickCount();                               \
    ApiPrint(("%d.%03d:%02x: ",                          \
              msec/1000,                                 \
              msec % 1000,                               \
              GetCurrentThreadId()));                    \
    ApiPrint(_x_);                                       \
}

#else

#define ApiPrint(_x_)
#define TIME_PRINT(_x_)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Implements resource and resource type IOCTL interfaces in
    the CLUSAPI.

Author:

    John Vert (jvert) 10/9/1996

Revision History:

--*/
#include "clusapip.h"


DWORD
WINAPI
ClusterResourceControl(
    IN HRESOURCE hResource,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource.

Arguments:

    hResource - Supplies a handle to the resource to be controlled.

    hHostNode - Supplies a handle to the node on which the resource
        control should be delivered. If this is NULL, the node where
        the resource is online is used.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCRESOURCE Resource;
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned;

    Buffer = lpOutBuffer;
    if ((Buffer == NULL) &&
        (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    Resource = (PCRESOURCE)hResource;
    if (ARGUMENT_PRESENT(hHostNode)) {
        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeResourceControl(Resource->hResource,
                                     hDestNode,
                                     dwControlCode,
                                     lpInBuffer,
                                     nInBufferSize,
                                     Buffer,
                                     nOutBufferSize,
                                     &BytesReturned,
                                     &Required)),
             Resource->Cluster);
    } else {

        WRAP(Status,
             (ApiResourceControl(Resource->hResource,
                                 dwControlCode,
                                 lpInBuffer,
                                 nInBufferSize,
                                 Buffer,
                                 nOutBufferSize,
                                 &BytesReturned,
                                 &Required)),
             Resource->Cluster);
    }
    if ( (Status == ERROR_SUCCESS) ||
         (Status == ERROR_MORE_DATA) ) {
        if ( (Status == ERROR_MORE_DATA) &&
             (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }
        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);

}


DWORD
WINAPI
ClusterResourceTypeControl(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource type.

Arguments:

    lpszResourceTypename - Supplies the name of the resource type to be
        controlled.

    hHostNode - Supplies a handle to the node on which the resource type
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource type control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the resource type.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource type.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource type.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCLUSTER Cluster;
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned;

    Buffer = lpOutBuffer;
    if ((Buffer == NULL) &&
        (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    Cluster = (PCLUSTER)hCluster;
    if (ARGUMENT_PRESENT(hHostNode)) {
        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeResourceTypeControl(Cluster->hCluster,
                                         lpszResourceTypeName,
                                         hDestNode,
                                         dwControlCode,
                                         lpInBuffer,
                                         nInBufferSize,
                                         Buffer,
                                         nOutBufferSize,
                                         &BytesReturned,
                                         &Required)),
             Cluster);
    } else {
        WRAP(Status,
             (ApiResourceTypeControl(Cluster->hCluster,
                                     lpszResourceTypeName,
                                     dwControlCode,
                                     lpInBuffer,
                                     nInBufferSize,
                                     Buffer,
                                     nOutBufferSize,
                                     &BytesReturned,
                                     &Required)),
             Cluster);
    }

    if ( (Status == ERROR_SUCCESS) ||
         (Status == ERROR_MORE_DATA) ) {
        if ( (Status == ERROR_MORE_DATA) &&
             (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }
        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);

}


DWORD
WINAPI
ClusterGroupControl(
    IN HGROUP hGroup,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a group.

Arguments:

    hGroup - Supplies a handle to the group to be controlled.

    hHostNode - Supplies a handle to the node on which the group
        control should be delivered. If this is NULL, the node where
        the group is owned is used.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the group.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the group.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCGROUP Group;
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned;

    Buffer = lpOutBuffer;
    if ((Buffer == NULL) &&
        (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    Group = (PCGROUP)hGroup;
    if (ARGUMENT_PRESENT(hHostNode)) {
        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeGroupControl(Group->hGroup,
                                  hDestNode,
                                  dwControlCode,
                                  lpInBuffer,
                                  nInBufferSize,
                                  Buffer,
                                  nOutBufferSize,
                                  &BytesReturned,
                                  &Required)),
             Group->Cluster);
    } else {

        WRAP(Status,
             (ApiGroupControl(Group->hGroup,
                              dwControlCode,
                              lpInBuffer,
                              nInBufferSize,
                              Buffer,
                              nOutBufferSize,
                              &BytesReturned,
                              &Required)),
             Group->Cluster);
    }
    if ( (Status == ERROR_SUCCESS) ||
         (Status == ERROR_MORE_DATA) ) {
        if ( (Status == ERROR_MORE_DATA) &&
             (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }
        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);

}


DWORD
WINAPI
ClusterNodeControl(
    IN HNODE hNode,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a node.

Arguments:

    hNode - Supplies a handle to the node to be controlled.

    hHostNode - Supplies a handle to the node on which the node
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the node.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the node.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCNODE Node;
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned;

    Buffer = lpOutBuffer;
    if ((Buffer == NULL) &&
        (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    Node = (PCNODE)hNode;
    if (ARGUMENT_PRESENT(hHostNode)) {
        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeNodeControl(Node->hNode,
                                 hDestNode,
                                 dwControlCode,
                                 lpInBuffer,
                                 nInBufferSize,
                                 Buffer,
                                 nOutBufferSize,
                                 &BytesReturned,
                                 &Required)),
             Node->Cluster);
    } else {

        WRAP(Status,
             (ApiNodeControl(Node->hNode,
                             dwControlCode,
                             lpInBuffer,
                             nInBufferSize,
                             Buffer,
                             nOutBufferSize,
                             &BytesReturned,
                             &Required)),
             Node->Cluster);
    }
    if ( (Status == ERROR_SUCCESS) ||
         (Status == ERROR_MORE_DATA) ) {
        if ( (Status == ERROR_MORE_DATA) &&
             (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }
        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);

}


DWORD
WINAPI
ClusterNetworkControl(
    IN HNETWORK hNetwork,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network.

Arguments:

    hNetwork - Supplies a handle to the network to be controlled.

    hHostNode - Supplies a handle to the node on which the node
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCNETWORK Network;
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned = 0;

    Buffer = lpOutBuffer;
    if ((Buffer == NULL) && (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    Network = (PCNETWORK)hNetwork;

    //
    // another node was specified so redirect the request to it
    //

    if (ARGUMENT_PRESENT(hHostNode)) {

        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeNetworkControl(Network->hNetwork,
                                    hDestNode,
                                    dwControlCode,
                                    lpInBuffer,
                                    nInBufferSize,
                                    Buffer,
                                    nOutBufferSize,
                                    &BytesReturned,
                                    &Required)),
             Network->Cluster);
    } else {

        WRAP(Status,
             (ApiNetworkControl(Network->hNetwork,
                                dwControlCode,
                                lpInBuffer,
                                nInBufferSize,
                                Buffer,
                                nOutBufferSize,
                                &BytesReturned,
                                &Required)),
             Network->Cluster);
    }

    if ( (Status == ERROR_SUCCESS) || (Status == ERROR_MORE_DATA) ) {

        if ( (Status == ERROR_MORE_DATA) && (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }

        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);
}


DWORD
WINAPI
ClusterNetInterfaceControl(
    IN HNETINTERFACE hNetInterface,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network interface.

Arguments:

    hNetInterface - Supplies a handle to the netinterface to be controlled.

    hHostNode - Supplies a handle to the node on which the node
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCNETINTERFACE NetInterface;
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned = 0;

    Buffer = lpOutBuffer;
    if ((Buffer == NULL) && (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    NetInterface = (PCNETINTERFACE)hNetInterface;

    //
    // another node was specified so redirect the request to it
    //

    if (ARGUMENT_PRESENT(hHostNode)) {

        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeNetInterfaceControl(NetInterface->hNetInterface,
                                    hDestNode,
                                    dwControlCode,
                                    lpInBuffer,
                                    nInBufferSize,
                                    Buffer,
                                    nOutBufferSize,
                                    &BytesReturned,
                                    &Required)),
             NetInterface->Cluster);
    } else {

        WRAP(Status,
             (ApiNetInterfaceControl(NetInterface->hNetInterface,
                                dwControlCode,
                                lpInBuffer,
                                nInBufferSize,
                                Buffer,
                                nOutBufferSize,
                                &BytesReturned,
                                &Required)),
             NetInterface->Cluster);
    }

    if ( (Status == ERROR_SUCCESS) || (Status == ERROR_MORE_DATA) ) {

        if ( (Status == ERROR_MORE_DATA) && (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }

        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);
}



DWORD
WINAPI
ClusterControl(
    IN HCLUSTER hCluster,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a cluster.

Arguments:

    hCluster - Supplies a handle to the cluster to be controlled.

    hHostNode - Supplies a handle to the node on which the cluster
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the cluster control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the cluster.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the cluster.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the cluster.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned;
    PCLUSTER pCluster;


    Buffer = lpOutBuffer;
    if ((Buffer == NULL) &&
        (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    pCluster = GET_CLUSTER(hCluster);

    if (ARGUMENT_PRESENT(hHostNode)) {
        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeClusterControl(pCluster->hCluster,
                                 hDestNode,
                                 dwControlCode,
                                 lpInBuffer,
                                 nInBufferSize,
                                 Buffer,
                                 nOutBufferSize,
                                 &BytesReturned,
                                 &Required)),
             pCluster);
    } else {

        WRAP(Status,
             (ApiClusterControl(pCluster->hCluster,
                             dwControlCode,
                             lpInBuffer,
                             nInBufferSize,
                             Buffer,
                             nOutBufferSize,
                             &BytesReturned,
                             &Required)),
             pCluster);
    }
    if ( (Status == ERROR_SUCCESS) ||
         (Status == ERROR_MORE_DATA) ) {
        if ( (Status == ERROR_MORE_DATA) &&
             (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }
        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\group.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    group.c

Abstract:

    Provides interface for managing cluster groups

Author:

    John Vert (jvert) 30-Jan-1996

Revision History:

--*/
#include "clusapip.h"


HGROUP
WINAPI
CreateClusterGroup(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszGroupName
    )

/*++

Routine Description:

    Creates a new cluster group.

Arguments:

    hCluster - Supplies a handle to a previously opened cluster.

    lpszGroupName - Supplies the name of the group. If the specified
        group already exists, it is opened.

Return Value:

    non-NULL - returns an open handle to the specified group.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    PCGROUP Group;
    error_status_t Status = ERROR_SUCCESS;

    Cluster = (PCLUSTER)hCluster;
    Group = LocalAlloc(LMEM_FIXED, sizeof(CGROUP));
    if (Group == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    Group->Name = LocalAlloc(LMEM_FIXED, (lstrlenW(lpszGroupName)+1)*sizeof(WCHAR));
    if (Group->Name == NULL) {
        LocalFree(Group);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    lstrcpyW(Group->Name, lpszGroupName);
    Group->Cluster = Cluster;
    InitializeListHead(&Group->NotifyList);
    WRAP_NULL(Group->hGroup,
              (ApiCreateGroup(Cluster->RpcBinding,
                              lpszGroupName,
                              &Status)),
              &Status,
              Cluster);
    if ((Group->hGroup == NULL) ||
        (Status != ERROR_SUCCESS)) {
        LocalFree(Group->Name);
        LocalFree(Group);
        SetLastError(Status);
        return(NULL);
    }

    //
    // Link newly opened group onto the cluster structure.
    //
    EnterCriticalSection(&Cluster->Lock);
    InsertHeadList(&Cluster->GroupList, &Group->ListEntry);
    LeaveCriticalSection(&Cluster->Lock);

    return ((HGROUP)Group);
}


HGROUP
WINAPI
OpenClusterGroup(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszGroupName
    )

/*++

Routine Description:

    Opens a handle to the specified group

Arguments:

    hCluster - Supplies a handle to the cluster

    lpszGroupName - Supplies the name of the group to be opened

Return Value:

    non-NULL - returns an open handle to the specified group.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    PCGROUP Group;
    error_status_t Status = ERROR_SUCCESS;

    Cluster = (PCLUSTER)hCluster;
    Group = LocalAlloc(LMEM_FIXED, sizeof(CGROUP));
    if (Group == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    Group->Name = LocalAlloc(LMEM_FIXED, (lstrlenW(lpszGroupName)+1)*sizeof(WCHAR));
    if (Group->Name == NULL) {
        LocalFree(Group);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    lstrcpyW(Group->Name, lpszGroupName);
    Group->Cluster = Cluster;
    InitializeListHead(&Group->NotifyList);
    WRAP_NULL(Group->hGroup,
              (ApiOpenGroup(Cluster->RpcBinding,
                            lpszGroupName,
                            &Status)),
              &Status,
              Cluster);
    if ((Group->hGroup == NULL) ||
        (Status != ERROR_SUCCESS)) {
        LocalFree(Group->Name);
        LocalFree(Group);
        SetLastError(Status);
        return(NULL);
    }

    //
    // Link newly opened group onto the cluster structure.
    //
    EnterCriticalSection(&Cluster->Lock);
    InsertHeadList(&Cluster->GroupList, &Group->ListEntry);
    LeaveCriticalSection(&Cluster->Lock);

    return ((HGROUP)Group);

}


BOOL
WINAPI
CloseClusterGroup(
    IN HGROUP hGroup
    )

/*++

Routine Description:

    Closes a group handle returned from OpenClusterGroup

Arguments:

    hGroup - Supplies the group handle

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCGROUP Group;
    PCLUSTER Cluster;

    Group = (PCGROUP)hGroup;
    Cluster = (PCLUSTER)Group->Cluster;

    //
    // Unlink group from cluster list.
    //
    EnterCriticalSection(&Cluster->Lock);
    RemoveEntryList(&Group->ListEntry);

    //
    // Remove any notifications posted against this group.
    //
    RundownNotifyEvents(&Group->NotifyList, Group->Name);

    //if the cluster is dead and the reconnect has failed,
    //the group->hgroup might be NULL if s_apiopengroup for
    //this group failed on a reconnect
    //the cluster may be dead and hgroup may be non null, say
    //if reconnectgroups succeeded but the reconnect networks
    //failed
    //At reconnect, the old context is saved in the obsolete 
    //list for deletion when the cluster handle is closed or
    //when the next api call is made
    if ((Cluster->Flags & CLUS_DEAD) && (Group->hGroup))
    {
        RpcSmDestroyClientContext(&Group->hGroup);
        LeaveCriticalSection(&Cluster->Lock);
        goto FnExit;
    }        
    LeaveCriticalSection(&Cluster->Lock);

    //SS :: If this fails, should we delete the client side context
    //there is a potential leak here since this client side context
    //will never get cleaned up since this context is not on the 
    //obsolete list and the error here is simply igonored
    //
    // Close RPC context handle
    // If the server dies, we still clean up the client side
    // and rely on the rundown mechanism to clean up server side state
    //
    ApiCloseGroup(&Group->hGroup);

FnExit:
    //
    // Free memory allocations
    //
    LocalFree(Group->Name);
    LocalFree(Group);

    //
    // Give the cluster a chance to clean up in case this
    // group was the only thing keeping it around.
    //
    CleanupCluster(Cluster);
    return(TRUE);
}


CLUSTER_GROUP_STATE
WINAPI
GetClusterGroupState(
    IN HGROUP hGroup,
    OUT LPWSTR lpszNodeName,
    IN OUT LPDWORD lpcchNodeName
    )

/*++

Routine Description:

    Returns the group's current state and the node where it is
    currently online.

Arguments:

    hGroup - Supplies a handle to a cluster group

    lpszNodeName - Returns the name of the node in the cluster where the
            given group is currently online

    lpcchNodeName - Supplies a pointer to a DWORD containing the number of
            characters available in the lpszNodeName buffer

            Returns the number of characters (not including the terminating
            NULL character) written to the lpszNodeName buffer

Return Value:

    Returns the current state of the group. Possible states are

        ClusterGroupOnline
        ClusterGroupOffline
        ClusterGroupFailed
        ClusterGroupPartialOnline
        ClusterGroupPending

    If the function fails, the return value is -1. Extended error
    status is available using GetLastError()

--*/

{
    PCGROUP Group;
    LPWSTR NodeName=NULL;
    CLUSTER_GROUP_STATE State;
    DWORD Status;
    DWORD Length;

    Group = (PCGROUP)hGroup;
    WRAP(Status,
         (ApiGetGroupState( Group->hGroup,
                            (LPDWORD)&State,  // cast for win64 warning
                            &NodeName )),
         Group->Cluster);

    if (Status == ERROR_SUCCESS) {
        if (ARGUMENT_PRESENT(lpszNodeName)) {
            MylstrcpynW(lpszNodeName, NodeName, *lpcchNodeName);
            Length = lstrlenW(NodeName);
            if (Length >= *lpcchNodeName) {
                Status = ERROR_MORE_DATA;
                State = ClusterGroupStateUnknown;  // -1
            }
            *lpcchNodeName = Length;
        }
        MIDL_user_free(NodeName);
        
    } else {
        State = ClusterGroupStateUnknown;
    }

    SetLastError(Status);
    return (State);

}


DWORD
WINAPI
SetClusterGroupName(
    IN HGROUP hGroup,
    IN LPCWSTR lpszGroupName
    )
/*++

Routine Description:

    Sets the friendly name of a cluster group

Arguments:

    hGroup - Supplies a handle to a cluster group

    lpszGroupName - Supplies the new name of the cluster group

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCGROUP Group;
    DWORD Status;

    Group = (PCGROUP)hGroup;
    WRAP(Status,
         (ApiSetGroupName(Group->hGroup, lpszGroupName)),
         Group->Cluster);

    return(Status);
}


DWORD
WINAPI
SetClusterGroupNodeList(
    IN HGROUP hGroup,
    IN DWORD NodeCount,
    IN HNODE NodeList[]
    )
/*++

Routine Description:

    Sets the preferred node list of the specified cluster group

Arguments:

    hGroup - Supplies the group whose preferred node list is to be set.

    NodeCount - Supplies the number of nodes in the preferred node list.

    NodeList - Supplies a pointer to an array of node handles. The number
        of nodes in the array is specified by the NodeCount parameter. The
        nodes in the array should be ordered by their preference. The first
        node in the array is the most preferred node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCGROUP Group = (PCGROUP)hGroup;
    DWORD i,j;
    LPWSTR *IdArray;
    DWORD Status;
    DWORD ListLength = sizeof(WCHAR);
    HKEY GroupKey = NULL;
    LPWSTR List = NULL;
    LPWSTR p;
    DWORD Length;
    PCNODE Node;

    //
    // First, iterate through all the nodes and obtain their IDs.
    //
    IdArray = LocalAlloc(LMEM_ZEROINIT, NodeCount*sizeof(LPWSTR));
    if (IdArray == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }
    for (i=0; i<NodeCount; i++) {
        Node = (PCNODE)NodeList[i];
        //
        // Make sure this isn't a handle to a node from a different
        // cluster
        //
        if (Node->Cluster != Group->Cluster) {
            Status = ERROR_INVALID_PARAMETER;
            goto error_exit;
        }
        WRAP(Status,
             (ApiGetNodeId(Node->hNode,
                           &IdArray[i])),
             Group->Cluster);
        if (Status != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // Make sure there are no duplicates
        //
        for (j=0; j<i; j++) {
            if (lstrcmpiW(IdArray[j],IdArray[i]) == 0) {

                //
                // A duplicate node is in the list
                //
                Status = ERROR_INVALID_PARAMETER;
                goto error_exit;
            }
        }
        ListLength += (lstrlenW(IdArray[i])+1)*sizeof(WCHAR);
    }

    GroupKey = GetClusterGroupKey(hGroup, KEY_READ | KEY_WRITE);
    if (GroupKey == NULL) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // Allocate a buffer to hold the REG_MULTI_SZ
    //
    List = LocalAlloc(LMEM_FIXED, ListLength);
    if (List == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Copy all the strings into the buffer.
    //
    p = List;
    for (i=0; i<NodeCount; i++) {
        lstrcpyW(p, IdArray[i]);
        p += lstrlenW(IdArray[i])+1;
    }

    *p = L'\0';         // add the final NULL terminator to the MULTI_SZ

    //
    // Finally, tell the backend
    //
    WRAP(Status,
         (ApiSetGroupNodeList(Group->hGroup, (UCHAR *)List, ListLength)),
         Group->Cluster);

error_exit:
    if (GroupKey != NULL) {
        ClusterRegCloseKey(GroupKey);
    }
    if (List != NULL) {
        LocalFree(List);
    }
    for (i=0; i<NodeCount; i++) {
        if (IdArray[i] != NULL) {
            MIDL_user_free(IdArray[i]);
        }
    }
    LocalFree(IdArray);
    return(Status);
}


DWORD
WINAPI
OnlineClusterGroup(
    IN HGROUP hGroup,
    IN OPTIONAL HNODE hDestinationNode
    )

/*++

Routine Description:

    Brings an offline group online.

    If hDestinationNode is specified, but the group is not capable
    of being brought online there, this API fails.

    If NULL is specified as the hDestinationNode, the best possible
    node is chosen by the cluster software.

    If NULL is specified but no node where this group
    can be brought online is currently available, this API fails.

Arguments:

    hGroup - Supplies a handle to the group to be failed over

    hDestinationNode - If present, supplies the node where this group
        should be brought back online.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value. If a suitable
    host node is not available, the error value is
    ERROR_HOST_NODE_NOT_AVAILABLE.

--*/

{
    PCNODE Node;
    PCGROUP Group;
    DWORD Status;

    Group = (PCGROUP)hGroup;
    Node = (PCNODE)hDestinationNode;
    if (Node != NULL) {
        WRAP(Status,
             (ApiMoveGroupToNode( Group->hGroup,
                                  Node->hNode)),
             Group->Cluster);
        if (Status != ERROR_SUCCESS) {
            return(Status);
        }
    }
    WRAP(Status,
         (ApiOnlineGroup( Group->hGroup )),
         Group->Cluster);
    return(Status);
}


DWORD
WINAPI
MoveClusterGroup(
    IN HGROUP hGroup,
    IN OPTIONAL HNODE hDestinationNode
    )

/*++

Routine Description:

    Moves an entire group from one node to another.

    If hDestinationNode is specified, but the group is not capable
    of being brought online there, this API fails.

    If NULL is specified as the hDestinationNode, the best possible
    node is chosen by the cluster software.

    If NULL is specified but no node where this group
    can be brought online is currently available, this API fails.

Arguments:

    hGroup - Supplies a handle to the group to be moved

    hDestinationNode - If present, supplies the node where this group
        should be brought back online.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value. If a suitable
    host node is not availabe, the error value is
    ERROR_HOST_NODE_NOT_AVAILABLE.

--*/

{
    PCGROUP Group;
    PCNODE  Node;
    DWORD   Status;
    DWORD   MoveStatus;
    DWORD   Generation;
    BOOL    bReconnected = FALSE;  

    Group = (PCGROUP)hGroup;
    Node  = (PCNODE)hDestinationNode;

    //
    // This API is not as simple as it should be because it is not idempotent.
    // In the case where hDestinationNode == NULL, we don't know where the group
    // will end up. And it will move each time we call it. So the normal mechanism
    // of failing over the API will not work in the case where the group to be
    // moved contains the cluster name we are connected to. The RPC call to move
    // the group will "fail" because the connection is dropped, but the call really
    // succeeded. So we will reconnect, retry, and fail again as the group moves again.
    //
    // So the approach taken here if hDestinationNode is not specified is to find out
    // where the group is currently, then move the group (somewhere else). If
    // ApiMoveGroup fails, and ReconnectCluster succeeds, then find out where the
    // group is again. If it is different, return success. If it is the same, try again.
    //
    if (hDestinationNode != NULL) {
        //
        //  Chittur Subbaraman (chitturs) - 10/13/99
        //
        //  If ApiMoveGroupToNode returns ERROR_INVALID_STATE due to the 
        //  reissue of the move upon a reconnect, then tell the caller
        //  that the move is pending.
        //
        Generation = Group->Cluster->Generation;
        WRAP(Status,
             (ApiMoveGroupToNode( Group->hGroup,
                                  Node->hNode)),
             Group->Cluster);
        if ((Status == ERROR_INVALID_STATE) &&
            (Generation < Group->Cluster->Generation)) {
            Status = ERROR_IO_PENDING;
        }
    } else {
        LPWSTR OldNodeName = NULL;
        CLUSTER_GROUP_STATE State;

        WRAP(Status,
             (ApiGetGroupState( Group->hGroup,
                                (LPDWORD)&State,      // cast for win64 warning
                                &OldNodeName)),
                                Group->Cluster);
        if (Status != ERROR_SUCCESS) {
            return(Status);
        }

        //
        //  Chittur Subbaraman (chitturs) - 5/5/99
        //
        //  Added logic to call ApiMoveGroup until it is successful or
        //  until all possible candidates have been tried.
        //
        do {
            Status = MoveStatus = ApiMoveGroup(Group->hGroup);

            //
            //  Get out if the move is successful
            //
            if ((Status == ERROR_IO_PENDING) || 
                (Status == ERROR_SUCCESS)) {
                break;
            }

            //
            //  Chittur Subbaraman (chitturs) - 7/8/99
            //
            //  If the group is not quiet and you have reconnected, then
            //  just tell the client that the group state is pending.
            //  This case happens if the node to which the client is
            //  connected to crashes and this function reissues the move
            //  "blindly" on a reconnect. In such a case, the group could
            //  be in pending state and there is no point in returning an
            //  error status. Note however that the group ownership may
            //  not change in such a case and then the client has to figure
            //  this out and reissue the move.
            //
            if ((Status == ERROR_INVALID_STATE) &&
                (bReconnected)) {
                Status = ERROR_IO_PENDING;
                break;
            }

            Generation = Group->Cluster->Generation;
            // 
            //  The above move attempt may have failed. So, try reconnecting.
            //
            Status = ReconnectCluster(Group->Cluster, Status, Generation);
            if (Status == ERROR_SUCCESS) {

                LPWSTR NewNodeName = NULL;

                //
                // Successfully reconnected, see where the group is now.
                //
                WRAP(Status,
                    (ApiGetGroupState(Group->hGroup,
                                        (LPDWORD)&State,  // cast for win64 warn
                                        &NewNodeName)),
                    Group->Cluster);
                if (Status == ERROR_SUCCESS) {
                    if (lstrcmpiW(NewNodeName, OldNodeName) != 0) {
                        //
                        // The group has already moved. Return ERROR_SUCCESS.
                        //
                        MIDL_user_free(NewNodeName);
                        break;
                    }
                    bReconnected = TRUE;
                    MIDL_user_free(NewNodeName);
                } else {
                    //
                    //  Return status of the failed move operation.
                    //
                    Status = MoveStatus;
                    break;
                }
            } else {
                //
                //  Return status of the failed move operation.
                //
                Status = MoveStatus;
                break;
            }
        } while ( TRUE );
        
        MIDL_user_free(OldNodeName);
    }

    return(Status);
}



DWORD
WINAPI
OfflineClusterGroup(
    IN HGROUP hGroup
    )

/*++

Routine Description:

    Brings an online group offline

Arguments:

    hGroup - Supplies a handle to the group to be taken offline

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCGROUP Group;
    DWORD Status;

    Group = (PCGROUP)hGroup;
    WRAP(Status,
         (ApiOfflineGroup( Group->hGroup )),
         Group->Cluster);

    return(Status);
}


DWORD
WINAPI
DeleteClusterGroup(
    IN HGROUP hGroup
    )

/*++

Routine Description:

    Deletes the specified cluster group from the cluster. The cluster
    group must contain no resources.

Arguments:

    hGroup - Specifies the cluster group to be deleted.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCGROUP Group;
    DWORD Status;

    Group = (PCGROUP)hGroup;
    WRAP(Status,
         (ApiDeleteGroup( Group->hGroup )),
         Group->Cluster);

    return(Status);
}


HCLUSTER
WINAPI
GetClusterFromGroup(
    IN HGROUP hGroup
    )
/*++

Routine Description:

    Returns the cluster handle from the associated group handle.

Arguments:

    hGroup - Supplies the group.

Return Value:

    Handle to the cluster associated with the group handle.

--*/

{
    DWORD       nStatus;
    PCGROUP     Group = (PCGROUP)hGroup;
    HCLUSTER    hCluster = (HCLUSTER)Group->Cluster;

    nStatus = AddRefToClusterHandle( hCluster );
    if ( nStatus != ERROR_SUCCESS ) {
        SetLastError( nStatus );
        hCluster = NULL;
    }
    return( hCluster );

} // GetClusterFromGroup()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\clusapi.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    clusapi.c

Abstract:

    Public interfaces for managing clusters.

Author:

    John Vert (jvert) 15-Jan-1996

Revision History:

--*/
#include "clusapip.h"
#include <strsafe.h>

HCLUSTER
WINAPI
OpenClusterAuthInfo(
    IN LPCWSTR lpszClusterName,
    IN unsigned long AuthnLevel
    );

//
// Local function prototype
//

static DWORD
GetOldClusterVersionInformation(
    IN HCLUSTER                 hCluster,
    IN OUT LPCLUSTERVERSIONINFO pClusterInfo
    );

static
DWORD
GetNodeServiceState(
    IN  LPCWSTR lpszNodeName,
    OUT DWORD * pdwClusterState
    );

DWORD
CopyCptFileToClusDirp(
    IN LPCWSTR  lpszPathName
    );

DWORD
UnloadClusterHivep(
    VOID
    );



//
// ClusApi as of Jan/26/2000 has a race
//
//   The usage of binding and context handles in PCLUSTER and
//   other structures is not synchronized with reconnect.
//
//   Reconnect frees the handles and stuffes new ones in,
//   while other threads maybe using those handles.
//
//   Trying to change as fewer lines as possible, the fix is implemented
//   that delays freeing binding and context handles for at least 40 seconds,
//   after the deletion was requested.
//
//   We put a context or binding handle in a queue when the deletion is requested.
//   Periodically queues are cleaned up of handles that are more than 40 seconds old.
//

#define STALE_RPC_HANDLE_THRESHOLD 40

RPC_STATUS
FreeRpcBindingOrContext(
    IN PCLUSTER Cluster,
    IN void **  RpcHandlePtr,
    IN BOOL     IsBinding)
/*++

Routine Description:

    Pushes an rpc handle to a tail of the queue

Arguments:

    Cluster - pointer to a cluster structure

    RpcHandlePtr - rpc binding or context handle

    IsBinding - TRUE if RPC_BINDING_HANDLE is passed and FALSE if the context handle is passed

Return Value:

    RPC_STATUS

--*/
{
    PCTX_HANDLE CtxHandle;
    PLIST_ENTRY ListHead = IsBinding ?
        &Cluster->FreedBindingList : &Cluster->FreedContextList;
    RPC_STATUS status;

    if (*RpcHandlePtr == NULL) {
        // If we tried more than one candidate,
        // some of the context handles can be NULL.
        // Don't need to free anything in this case
        return RPC_S_OK;
    }

    CtxHandle = LocalAlloc(LMEM_ZEROINIT, sizeof(CLUSTER));

    if (CtxHandle == NULL) {
        //
        // We ran out of memory.
        //   Option #1. Leak the handle, but fix the race
        //   Option #2. Free the handle and don't fix the race
        //
        // I vote for #2
        //
        if (IsBinding) {
            status = RpcBindingFree(RpcHandlePtr);
        } else {
            status = RpcSmDestroyClientContext(RpcHandlePtr);
        }
    } else {
        GetSystemTimeAsFileTime((LPFILETIME)&CtxHandle->TimeStamp);
        CtxHandle->TimeStamp += STALE_RPC_HANDLE_THRESHOLD * (ULONGLONG)10000000;
        CtxHandle->RpcHandle = *RpcHandlePtr;
        InsertTailList(ListHead, &CtxHandle->HandleList);
        ++Cluster->FreedRpcHandleListLen;
        status = RPC_S_OK;
    }
    return status;
}

VOID
FreeObsoleteRpcHandlesEx(
    IN PCLUSTER Cluster,
    IN BOOL     Cleanup,
    IN BOOL     IsBinding
    )
/*++

Routine Description:

    runs down a queue and cleans stale rpc handles

Arguments:

    Cluster - pointer to a cluster structure

    Cleanup - if TRUE all handles are freed regardless of the time stamp

    IsBinding - TRUE if we need to clean binding or context handle queue

--*/
{
    ULONGLONG CurrentTime;
    PLIST_ENTRY ListHead = IsBinding ?
        &Cluster->FreedBindingList : &Cluster->FreedContextList;

    EnterCriticalSection(&Cluster->Lock);
    GetSystemTimeAsFileTime((LPFILETIME)&CurrentTime);

    while (!IsListEmpty(ListHead))
    {
        PCTX_HANDLE Handle =
            CONTAINING_RECORD(
                ListHead->Flink,
                CTX_HANDLE,
                HandleList);
        if (!Cleanup && Handle->TimeStamp > CurrentTime) {
            // Not time yet
            break;
        }
        --Cluster->FreedRpcHandleListLen;
        if (IsBinding) {
            RpcBindingFree(&Handle->RpcHandle);
        } else {
            RpcSmDestroyClientContext(&Handle->RpcHandle);
        }
        RemoveHeadList(ListHead);
        LocalFree(Handle);
    }
    LeaveCriticalSection(&Cluster->Lock);
}

static DWORD
GetOldClusterVersionInformation(
    IN HCLUSTER                 hCluster,
    IN OUT LPCLUSTERVERSIONINFO pClusterInfo
    )

/*++

Routine Description:

    Fixes up the cluster version information for downlevel clusters by looking at
    all of the nodes and returning the completed version information if all nodes
    are up.  If a node is down and no up level nodes are found then we cannot say
    what version of Cluster that we have.

Arguments:
    hCluster - Supplies a handle to the cluster

    pClusterInfo - returns the cluster version information structure.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.


--*/

{
    DWORD                               dwError = ERROR_SUCCESS;
    DWORD                               dwType;
    HCLUSENUM                           hEnum = 0;
    WCHAR                               NameBuf[50];
    DWORD                               NameLen, i;
    HNODE                               Node;
    CLUSTER_NODE_STATE                  NodeState;
    HCLUSTER                            hClusNode;
    PCLUSTER                            pClus;
    WORD                                Major;
    WORD                                Minor;
    WORD                                Build;
    LPWSTR                              VendorId = NULL;
    LPWSTR                              CsdVersion = NULL;
    PCLUSTER_OPERATIONAL_VERSION_INFO   pClusterOpVerInfo = NULL;
    BOOL                                bNodeDown = FALSE;
    BOOL                                bFoundSp4OrHigherNode = FALSE;

    hEnum = ClusterOpenEnum(hCluster, CLUSTER_ENUM_NODE);
    if (hEnum == NULL) {
        dwError = GetLastError();
        fprintf(stderr, "ClusterOpenEnum failed %d\n",dwError);
        goto FnExit;
    }

    for (i=0; ; i++) {
        dwError = ERROR_SUCCESS;

        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        dwError = ClusterEnum(hEnum, i, &dwType, NameBuf, &NameLen);
        if (dwError == ERROR_NO_MORE_ITEMS) {
            dwError = ERROR_SUCCESS;
            break;
        } else if (dwError != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,dwError);
            goto FnExit;
        }

        if (dwType != CLUSTER_ENUM_NODE) {
            printf("Invalid Type %d returned from ClusterEnum\n", dwType);
            dwError = ERROR_INVALID_DATA;
            goto FnExit;
        }

        hClusNode = OpenCluster(NameBuf);
        if (hClusNode == NULL) {
            bNodeDown = TRUE;
            dwError = GetLastError();
            fprintf(stderr, "OpenCluster %ws failed %d\n", NameBuf, dwError);
            continue;
        }

        pClus = GET_CLUSTER(hClusNode);

        WRAP(dwError,
             (ApiGetClusterVersion2(pClus->RpcBinding,
                                   &Major,
                                   &Minor,
                                   &Build,
                                   &VendorId,
                                   &CsdVersion,
                                   &pClusterOpVerInfo)),
             pClus);

        if (!CloseCluster(hClusNode)) {
            fprintf(stderr, "CloseCluster %ws failed %d\n", NameBuf, GetLastError());
        }

        if (dwError == RPC_S_PROCNUM_OUT_OF_RANGE) {
            dwError = ERROR_SUCCESS;
            continue;
        }
        else if (dwError != ERROR_SUCCESS) {
            fprintf(stderr, "ApiGetClusterVersion2 failed %d\n",dwError);
            bNodeDown = TRUE;
            continue;
        }
        else {
            pClusterInfo->MajorVersion = Major;
            pClusterInfo->MinorVersion = Minor;
            pClusterInfo->BuildNumber = Build;
            ( void ) StringCchCopyW(pClusterInfo->szVendorId, RTL_NUMBER_OF (pClusterInfo->szVendorId), VendorId);
            MIDL_user_free(VendorId);

            if (CsdVersion != NULL) {
                ( void ) StringCchCopyW(pClusterInfo->szCSDVersion, RTL_NUMBER_OF (pClusterInfo->szCSDVersion), CsdVersion);
                MIDL_user_free(CsdVersion);
            }
            else {
                pClusterInfo->szCSDVersion[0] = '\0';
            }

            pClusterInfo->dwClusterHighestVersion = pClusterOpVerInfo->dwClusterHighestVersion;
            pClusterInfo->dwClusterLowestVersion = pClusterOpVerInfo->dwClusterLowestVersion;
            pClusterInfo->dwFlags = pClusterOpVerInfo->dwFlags;
            bFoundSp4OrHigherNode = TRUE;
            break;
        }
    }


    // did not find a node higher than NT4Sp3
    if (!bFoundSp4OrHigherNode) {
        // no nodes were down, we can assume all nodes are NT4Sp3
        if (!bNodeDown) {
            pClusterInfo->dwClusterHighestVersion = pClusterInfo->dwClusterLowestVersion = MAKELONG(NT4_MAJOR_VERSION,pClusterInfo->BuildNumber);
            pClusterInfo->dwFlags = 0;
        }
        else { // at least one node was unreachable...  punt and return unknown version...
            pClusterInfo->dwClusterHighestVersion = pClusterInfo->dwClusterLowestVersion = CLUSTER_VERSION_UNKNOWN;
            pClusterInfo->dwFlags = 0;
        }
    }

FnExit:
    if (hEnum) ClusterCloseEnum(hEnum);

    return dwError;
}


//
// General Cluster Management Routines.
//
DWORD
WINAPI
GetNodeClusterState(
    IN  LPCWSTR lpszNodeName,
    OUT DWORD * pdwClusterState
    )
/*++

Routine Description:

    Finds out if this node is clustered.

Arguments:

    lpszNodeName - The Name of the Node.  If NULL, the local node is queried.

    pdwClusterState - A pointer to a DWORD where the cluster state
        for this node is returned.   This is one of the enumerated types
        NODE_CLUSTER_STATE.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/
{
    DWORD                   dwStatus   = ERROR_SUCCESS;
    eClusterInstallState    eState     = eClusterInstallStateUnknown;

    *pdwClusterState = ClusterStateNotInstalled;

    // Get the cluster install state from the registry.
    dwStatus = ClRtlGetClusterInstallState( lpszNodeName, &eState );
    if ( dwStatus != ERROR_SUCCESS )
    {
        goto FnExit;
    }

    //  Translate the registry key setting into the external state value.

    switch ( eState )
    {
        case eClusterInstallStateUnknown:
            *pdwClusterState = ClusterStateNotInstalled;
            dwStatus = GetNodeServiceState( lpszNodeName, pdwClusterState );

            // If the service is not installed, map the error to success.
            if ( dwStatus == ERROR_SERVICE_DOES_NOT_EXIST )
            {
                dwStatus = ERROR_SUCCESS;
                *pdwClusterState = ClusterStateNotInstalled;
            }
            break;

        case eClusterInstallStateFilesCopied:
            *pdwClusterState = ClusterStateNotConfigured;
            break;

        case eClusterInstallStateConfigured:
        case eClusterInstallStateUpgraded:
            *pdwClusterState = ClusterStateNotRunning;
            dwStatus = GetNodeServiceState( lpszNodeName, pdwClusterState );
            break;

        default:
            *pdwClusterState = ClusterStateNotInstalled;
            break;
    } // switch:  eState

FnExit:
    return(dwStatus);

} //*** GetNodeClusterState()



static
DWORD
GetNodeServiceState(
    IN  LPCWSTR lpszNodeName,
    OUT DWORD * pdwClusterState
    )
/*++

Routine Description:

    Finds out if the cluster service is installed on the specified node
    and whether it is running or not.

Arguments:

    lpszNodeName - The name of the node.  If NULL, the local node is queried.

    pdwClusterState - A pointer to a DWORD where the cluster state
        for this node is returned.   This is one of the enumerated types
        NODE_CLUSTER_STATE.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/
{
    SC_HANDLE       hScManager = NULL;
    SC_HANDLE       hClusSvc   = NULL;
    DWORD           dwStatus   = ERROR_SUCCESS;
    WCHAR           szClusterServiceName[] = CLUSTER_SERVICE_NAME;
    SERVICE_STATUS  ServiceStatus;

    // Open the Service Control Manager.
    hScManager = OpenSCManagerW( lpszNodeName, NULL, GENERIC_READ );
    if ( hScManager == NULL )
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    // Open the Cluster service.
    hClusSvc = OpenServiceW( hScManager, szClusterServiceName, GENERIC_READ );
    if ( hClusSvc == NULL )
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    // Assume that the service is not running.
    *pdwClusterState = ClusterStateNotRunning;
    if ( ! QueryServiceStatus( hClusSvc, &ServiceStatus ) )
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    // If succeeded in opening the handle to the service
    // we assume that the service is installed.
    if ( ServiceStatus.dwCurrentState == SERVICE_RUNNING )
    {
        *pdwClusterState = ClusterStateRunning;
    }
    else
    {
        HCLUSTER    hCluster = NULL;

        hCluster = OpenCluster( lpszNodeName );
        if ( hCluster != NULL )
        {
            *pdwClusterState = ClusterStateRunning;
            CloseCluster( hCluster );
        }
    }

FnExit:
    if ( hScManager )
    {
        CloseServiceHandle( hScManager );
    }
    if ( hClusSvc )
    {
        CloseServiceHandle( hClusSvc );
    }
    return(dwStatus);

} //*** GetNodeServiceState()



HCLUSTER
WINAPI
OpenCluster(
    IN LPCWSTR lpszClusterName
    )

/*++

Routine Description:

    Initiates a communication session with the specified cluster.

Arguments:

    lpszClusterName - Supplies the name of the cluster to be opened.

Return Value:

    non-NULL - returns an open handle to the specified cluster.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    return (OpenClusterAuthInfo(lpszClusterName, RPC_C_AUTHN_LEVEL_CONNECT));
}


HCLUSTER
WINAPI
OpenClusterAuthInfo(
    IN LPCWSTR lpszClusterName,
    IN unsigned long AuthnLevel
    )

/*++

Routine Description:

    Initiates a communication session with the specified cluster.

Arguments:

    lpszClusterName - Supplies the name of the cluster to be opened.
    AuthnLevel - Level of authentication to be performed on remote procedure call.

Return Value:

    non-NULL - returns an open handle to the specified cluster.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    BOOL Success;
    DWORD Status;
    WCHAR *Binding = NULL;
    DWORD MaxLen, cRetries = 4;

    Cluster = LocalAlloc(LMEM_ZEROINIT, sizeof(CLUSTER));
    if (Cluster == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    Cluster->Signature = CLUS_SIGNATURE;
    Cluster->ReferenceCount = 1;
    InitializeListHead(&Cluster->ResourceList);
    InitializeListHead(&Cluster->GroupList);
    InitializeListHead(&Cluster->KeyList);
    InitializeListHead(&Cluster->NodeList);
    InitializeListHead(&Cluster->NotifyList);
    InitializeListHead(&Cluster->SessionList);
    InitializeListHead(&Cluster->NetworkList);
    InitializeListHead(&Cluster->NetInterfaceList);
    Cluster->NotifyThread = NULL;

    //
    //  Initialize the critsec. Catch low memory conditions and return error to caller.
    //
    try
    {
        InitializeCriticalSection(&Cluster->Lock);
    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError( GetExceptionCode() );
        LocalFree( Cluster );
        return( NULL );
    }
    
    InitializeListHead(&Cluster->FreedBindingList);
    InitializeListHead(&Cluster->FreedContextList);

    //
    // Determine which node we should connect to. If someone has
    // passed in NULL, we know we can connect to the cluster service
    // over LPC. Otherwise, use RPC.
    //
    if ((lpszClusterName == NULL) ||
        (lpszClusterName[0] == '\0')) {

        Status = RpcStringBindingComposeW(L"b97db8b2-4c63-11cf-bff6-08002be23f2f",
                                          L"ncalrpc",
                                          NULL,
                                          NULL,         // dynamic endpoint
                                          NULL,
                                          &Binding);
        if (Status != RPC_S_OK) {
            goto error_exit;
        }

        Cluster->Flags = CLUS_LOCALCONNECT;
        Status = RpcBindingFromStringBindingW(Binding, &Cluster->RpcBinding);
        RpcStringFreeW(&Binding);
        if (Status != RPC_S_OK) {
            goto error_exit;
        }
    } else {

        //
        // Try to connect directly to the cluster.
        //
        Status = RpcStringBindingComposeW(L"b97db8b2-4c63-11cf-bff6-08002be23f2f",
                                          L"ncadg_ip_udp",
                                          (LPWSTR)lpszClusterName,
                                          NULL,
                                          NULL,
                                          &Binding);
        if (Status != RPC_S_OK) {
            goto error_exit;
        }
        Status = RpcBindingFromStringBindingW(Binding, &Cluster->RpcBinding);
        RpcStringFreeW(&Binding);
        if (Status != RPC_S_OK) {
            goto error_exit;
        }

        //
        // Resolve the binding handle endpoint
        //
        Status = RpcEpResolveBinding(Cluster->RpcBinding,
                                     clusapi_v2_0_c_ifspec);
        if (Status != RPC_S_OK) {
            goto error_exit;
        }
        Cluster->Flags = 0;
    }

    //
    // no SPN required for NTLM. This will need to change if we decide to use
    // kerb in the future
    //
    Cluster->AuthnLevel=AuthnLevel;
    Status = RpcBindingSetAuthInfoW(Cluster->RpcBinding,
                                    NULL,
                                    AuthnLevel, 
                                    RPC_C_AUTHN_WINNT,
                                    NULL,
                                    RPC_C_AUTHZ_NAME);
    if (Status != RPC_S_OK) {
        goto error_exit;
    }

    do
    {
        //
        // Get the cluster and node name from the remote machine.
        // This is also a good check to make sure there is really
        // an RPC server on the other end of this binding.
        //
        WRAP(Status,
             (ApiGetClusterName(Cluster->RpcBinding,
                                &Cluster->ClusterName,
                                &Cluster->NodeName)),
             Cluster);

        //
        //  If the first RPC made to cluster service fails with RPC_S_CALL_FAILED_DNE, it is 
        //  possible that the RPC client made a call using the wrong dynamic endpoint name.
        //  This can happen due to RPC client side caching and it doesn't always contact the
        //  EP mapper to resolve the partially bound client binding handle. To mask this RPC
        //  phenomenon (bug ?), we need to reset the binding handle and retry the call. This
        //  will force the client side to re-resolve the endpoint using the services of the
        //  EP mapper.
        //
        if ( Status == RPC_S_CALL_FAILED_DNE )
        {
            Status = RpcBindingReset ( Cluster->RpcBinding );
            if ( Status != RPC_S_OK ) break;
            cRetries --;
            //
            //  Make sure the cluster is not marked as dead since we want to retry the RPC.
            //
            Cluster->Flags &= ~CLUS_DEAD;
        } else 
        {
            break;
        }
    } while ( cRetries > 0 );
    
    if (Status != RPC_S_OK) {
        goto error_exit;
    }
    WRAP_NULL(Cluster->hCluster,
              (ApiOpenCluster(Cluster->RpcBinding, &Status)),
              &Status,
              Cluster);
    if (Cluster->hCluster == NULL) {
        goto error_exit;
    }
    Status = GetReconnectCandidates(Cluster);
    if (Status != ERROR_SUCCESS) {
        goto error_exit;
    }
    return((HCLUSTER)Cluster);

error_exit:
    if (Cluster != NULL) {
        if (Cluster->RpcBinding != NULL) {
            RpcBindingFree(&Cluster->RpcBinding);
        }
        if (Cluster->ClusterName != NULL) {
            MIDL_user_free(Cluster->ClusterName);
        }
        if (Cluster->NodeName != NULL) {
            MIDL_user_free(Cluster->NodeName);
        }
        DeleteCriticalSection(&Cluster->Lock);
        LocalFree(Cluster);
    }
    SetLastError(Status);
    return(NULL);
}





BOOL
WINAPI
CloseCluster(
    IN HCLUSTER hCluster
    )

/*++

Routine Description:

    Closes a cluster handle returned from OpenCluster

Arguments:

    hCluster - Supplies the cluster handle

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    PCRITICAL_SECTION Lock;

    
    Cluster = GET_CLUSTER(hCluster);

    EnterCriticalSection(&Cluster->Lock);
    Cluster->ReferenceCount--;

    if ( Cluster->ReferenceCount == 0 ) {
        Cluster->Flags |= CLUS_DELETED;


        //
        // Free up any notifications posted on this cluster handle.
        //
        RundownNotifyEvents(&Cluster->NotifyList, Cluster->ClusterName);

        //
        //  Check if the context handle is valid. The context handle can become NULL
        //  if you fail in some parts of reconnect. E.g., ApiOpenCluster() in ReconnectCandidates
        //  fails with all candidates.
        //
        if ( Cluster->hCluster )
        {
            if (Cluster->Flags & CLUS_DEAD) {
                RpcSmDestroyClientContext(&Cluster->hCluster);
            } else {
                ApiCloseCluster(&Cluster->hCluster);
            }
        }

        LeaveCriticalSection(&Cluster->Lock);


 
        //
        // If this was the only thing keeping the cluster structure
        // around, clean it up now.
        //
        CleanupCluster(Cluster);

    } else {
        LeaveCriticalSection(&Cluster->Lock);
    }

    return(TRUE);
}


VOID
CleanupCluster(
    IN PCLUSTER Cluster
    )

/*++

Routine Description:

    Frees any system resources associated with a cluster.

    N.B. This routine will delete the Cluster->Lock critical
         section. Any thread waiting on this lock will hang.

Arguments:

    Cluster - Supplies the cluster structure to be cleaned up

Return Value:

    None.

--*/

{
    EnterCriticalSection(&Cluster->Lock);
    if (IS_CLUSTER_FREE(Cluster)) {

        RpcBindingFree(&Cluster->RpcBinding);


        Cluster->RpcBinding = NULL;


        FreeObsoleteRpcHandles(Cluster, TRUE);



        LeaveCriticalSection(&Cluster->Lock);


        DeleteCriticalSection(&Cluster->Lock);
        MIDL_user_free(Cluster->ClusterName);
        MIDL_user_free(Cluster->NodeName);
        FreeReconnectCandidates(Cluster);


        LocalFree(Cluster);
    } else {
        LeaveCriticalSection(&Cluster->Lock);
    }


}



DWORD
WINAPI
SetClusterName(
    IN HCLUSTER hCluster,
    IN LPCWSTR  lpszNewClusterName
    )

/*++

Routine Description:

    Sets the cluster name.

Arguments:

    hCluster - Supplies the cluster handle.

    lpszNewClusterName - Supplies a pointer to the new cluster name.

Return Value:

    ERROR_SUCCESS if the cluster information was returned successfully.

    If an error occurs, the Win32 error code is returned.

Notes:

    This API requires TBD privilege.

--*/

{
    LPWSTR NewName;
    DWORD NameLength;
    DWORD Status;
    PCLUSTER Cluster;

    Cluster = GET_CLUSTER(hCluster);
    NameLength = (lstrlenW(lpszNewClusterName)+1)*sizeof(WCHAR);
    NewName = MIDL_user_allocate(NameLength);
    if (NewName == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(NewName, lpszNewClusterName, NameLength);

    WRAP(Status, (ApiSetClusterName(Cluster->RpcBinding, lpszNewClusterName)), Cluster);
    if ((Status == ERROR_SUCCESS) || (Status == ERROR_RESOURCE_PROPERTIES_STORED)) {
        EnterCriticalSection(&Cluster->Lock);
        MIDL_user_free(Cluster->ClusterName);
        Cluster->ClusterName = NewName;
        LeaveCriticalSection(&Cluster->Lock);
    } else {
        MIDL_user_free(NewName);
    }

    return(Status);
}


DWORD
WINAPI
GetClusterInformation(
    IN HCLUSTER hCluster,
    OUT LPWSTR lpszClusterName,
    IN OUT LPDWORD lpcchClusterName,
    OUT OPTIONAL LPCLUSTERVERSIONINFO lpClusterInfo
    )

/*++

Routine Description:

    Gets the cluster's name

Arguments:

    hCluster - Supplies a handle to the cluster

    lpszClusterName - Points to a buffer that receives the name of the cluster,
            including the terminating null character.

    lpcchClusterName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszClusterName parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to by lpcchClusterName contains the number of
            characters stored in the buffer. The count returned does not include
            the terminating null character.

    lpClusterInfo - Optionally returns the cluster version information structure.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCLUSTER Cluster;
    DWORD Length;
    LPWSTR pszClusterName=NULL;
    LPWSTR pszNodeName = NULL;
    DWORD Status = ERROR_SUCCESS;
    DWORD Status2;
    PCLUSTER_OPERATIONAL_VERSION_INFO pClusterOpVerInfo = NULL;

    Cluster = GET_CLUSTER(hCluster);
    if ( Cluster == NULL ) {
        return(ERROR_INVALID_HANDLE);
    }

    WRAP(Status,
         (ApiGetClusterName(Cluster->RpcBinding,
                               &pszClusterName,
                               &pszNodeName)),
        Cluster);

    if (Status != ERROR_SUCCESS)
        goto FnExit;

    
    MylstrcpynW(lpszClusterName, pszClusterName, *lpcchClusterName);

    Length = lstrlenW(pszClusterName);
    if (Length >= *lpcchClusterName) {
        if (lpszClusterName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    }
    *lpcchClusterName = Length;

    if (lpClusterInfo != NULL)
    {
        WORD Major;
        WORD Minor;
        WORD Build;
        LPWSTR VendorId = NULL;
        LPWSTR CsdVersion = NULL;
        BOOL   bOldServer = FALSE;

        if (lpClusterInfo->dwVersionInfoSize < sizeof(CLUSTERVERSIONINFO_NT4))
        {
            Status = ERROR_INVALID_PARAMETER;
            goto FnExit;
        }
        WRAP(Status2,
             (ApiGetClusterVersion2(Cluster->RpcBinding,
                                   &Major,
                                   &Minor,
                                   &Build,
                                   &VendorId,
                                   &CsdVersion,
                                   &pClusterOpVerInfo)),
             Cluster);


        //if this was an older server, call the older call
        if (Status2 == RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            bOldServer = TRUE;
            WRAP(Status2,
                (ApiGetClusterVersion(Cluster->RpcBinding,
                               &Major,
                               &Minor,
                               &Build,
                               &VendorId,
                               &CsdVersion)),
            Cluster);

        }

        if (Status2 != ERROR_SUCCESS)
        {
            Status = Status2;
            goto FnExit;
        }

        lpClusterInfo->MajorVersion = Major;
        lpClusterInfo->MinorVersion = Minor;
        lpClusterInfo->BuildNumber = Build;
        ( void ) StringCchCopyW(lpClusterInfo->szVendorId, RTL_NUMBER_OF (lpClusterInfo->szVendorId), VendorId);
        MIDL_user_free(VendorId);
        if (CsdVersion != NULL)
        {
            ( void ) StringCchCopyW(lpClusterInfo->szCSDVersion, RTL_NUMBER_OF (lpClusterInfo->szCSDVersion), CsdVersion);
            MIDL_user_free(CsdVersion);
        }
        else
        {
            lpClusterInfo->szCSDVersion[0] = '\0';
        }
        
        //
        //  If the caller passed in an NT4 size structure CLUSTERVERSIONINFO_NT4, then we have all
        //  the information we need. So, exit with success.
        //
        if (lpClusterInfo->dwVersionInfoSize < sizeof(CLUSTERVERSIONINFO))
        {
            goto FnExit;
        }

        //
        //  If you got the version information from an NT4 server, then see if you can get more
        //  information from a newer server in the cluster. If you already got the information
        //  from an NT5 or higher server, merely return that info to the caller.
        //
        if (bOldServer)
        {
            Status = GetOldClusterVersionInformation(hCluster, lpClusterInfo);
        }
        else
        {
            lpClusterInfo->dwClusterHighestVersion = pClusterOpVerInfo->dwClusterHighestVersion;
            lpClusterInfo->dwClusterLowestVersion = pClusterOpVerInfo->dwClusterLowestVersion;
            lpClusterInfo->dwFlags = pClusterOpVerInfo->dwFlags;
        }

    }


FnExit:
    if (pszClusterName)
        MIDL_user_free(pszClusterName);
    if (pszNodeName)
        MIDL_user_free(pszNodeName);
    if (pClusterOpVerInfo)
        MIDL_user_free(pClusterOpVerInfo);

    return(Status);

}


DWORD
WINAPI
GetClusterQuorumResource(
    IN HCLUSTER     hCluster,
    OUT LPWSTR      lpszResourceName,
    IN OUT LPDWORD  lpcchResourceName,
    OUT LPWSTR      lpszDeviceName,
    IN OUT LPDWORD  lpcchDeviceName,
    OUT LPDWORD     lpdwMaxQuorumLogSize
    )

/*++

Routine Description:

    Gets the current cluster quorum resource

Arguments:

    hCluster - Supplies the cluster handle.

    lpszResourceName - Points to a buffer that receives the name of
        the cluster quorum resource, including the terminating NULL character.

    lpcchResourceName - Points to a variable that specifies the size,
        in characters, of the buffer pointed to by the lpszResourceName
        parameter. This size should include the terminating null character.
        When the function returns, the variable pointed to by lpcchResourceName
        contains the number of characters stored in the buffer. The count
        returned does not include the terminating null character.

    lpszDeviceName - Points to a buffer that receives the path name for
        the cluster quorum log file.

    lpcchDeviceName - Points to a variable that specifies the size,
        in characters, of the buffer pointed to by the lpszDeviceName
        parameter. This size should include the terminating null character.
        When the function returns, the variable pointed to by lpcchResourceName
        contains the number of characters stored in the buffer. The count
        returned does not include the terminating null character.

    pdwMaxQuorumLogSize - Points to a variable that receives the current maximum
        size of the quorum log files.

Return Value:

    ERROR_SUCCESS if the cluster information was returned successfully.

    If an error occurs, the Win32 error code is returned.


Notes:

    This API requires TBD privilege.

--*/

{
    PCLUSTER Cluster;
    LPWSTR ResourceName = NULL;
    LPWSTR DeviceName = NULL;
    DWORD Status;
    DWORD Length;

    Cluster = GET_CLUSTER(hCluster);

    WRAP(Status,
         (ApiGetQuorumResource(Cluster->RpcBinding,
                               &ResourceName, &DeviceName,
                               lpdwMaxQuorumLogSize)),
         Cluster);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    MylstrcpynW(lpszResourceName, ResourceName, *lpcchResourceName);
    Length = lstrlenW(ResourceName);
    if (Length >= *lpcchResourceName) {
        if (lpszResourceName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    }
    *lpcchResourceName = Length;
    MIDL_user_free(ResourceName);

    MylstrcpynW(lpszDeviceName, DeviceName, *lpcchDeviceName);
    Length = lstrlenW(DeviceName);
    if (Length >= *lpcchDeviceName) {
        if (Status == ERROR_SUCCESS) {
            if (lpszDeviceName == NULL) {
                Status = ERROR_SUCCESS;
            } else {
                Status = ERROR_MORE_DATA;
            }
        }
    }
    *lpcchDeviceName = Length;
    MIDL_user_free(DeviceName);

    return(Status);
}


DWORD
WINAPI
SetClusterQuorumResource(
    IN HRESOURCE hResource,
    IN LPCWSTR   lpszDeviceName,
    IN DWORD     dwMaxQuorumLogSize
    )

/*++

Routine Description:

    Sets the cluster quorum resource.

Arguments:

    hResource - Supplies the new clster quorum resource.

    lpszDeviceName - The path where the permanent cluster files like the
        quorum and check point files will be maintained.  If the drive
        letter is specified, it will be validated for the given resource. If
        no drive letter is specified in the path, the first drive letter will
        be chosen.  If NULL, the first drive letter will be chosen and the default
        path used.

    dwMaxQuorumLogSize - The maximum size of the quorum logs before they are
        reset by checkpointing.  If 0, the default is used.

Return Value:

    ERROR_SUCCESS if the cluster resource was set successfully

    If an error occurs, the Win32 error code is returned.


Notes:

    This API requires TBD privilege.

--*/

{
    DWORD Status;
    PCRESOURCE Resource = (PCRESOURCE)hResource;
    WCHAR szNull = L'\0';

    //
    //  Chittur Subbaraman (chitturs) - 1/6/99
    //
    //  Substitute a pointer to a NULL character for a NULL pointer.
    //  This is necessary since RPC refuses to accept a NULL pointer.
    //
    if( !ARGUMENT_PRESENT( lpszDeviceName ) )
    {
        lpszDeviceName = &szNull;
    }

    WRAP(Status,
         (ApiSetQuorumResource(Resource->hResource, lpszDeviceName, dwMaxQuorumLogSize)),
         Resource->Cluster);

    return(Status);
}


DWORD
WINAPI
SetClusterNetworkPriorityOrder(
    IN HCLUSTER hCluster,
    IN DWORD NetworkCount,
    IN HNETWORK NetworkList[]
    )
/*++

Routine Description:

    Sets the priority order for the set of cluster networks used for
    internal (node-to-node) cluster communication. Internal communication
    is always carried on the highest priority network that is available
    between two nodes.

Arguments:

    hCluster - Supplies the cluster handle.

    NetworkCount - The number of items in NetworkList.

    NetworkList - A prioritized array of network object handles.
                  The first handle in the array has the highest priority.
                  All of the networks that are eligible to carry internal
                  communication must be represented in the list. No networks
                  that are ineligible to carry internal communication may
                  appear in the list.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCLUSTER Cluster;
    DWORD i,j;
    LPWSTR *IdArray;
    DWORD Status;
    PCNETWORK Network;


    Cluster = GET_CLUSTER(hCluster);

    //
    // First, iterate through all the networks and obtain their IDs.
    //
    IdArray = LocalAlloc(LMEM_ZEROINIT, NetworkCount*sizeof(LPWSTR));

    if (IdArray == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    for (i=0; i<NetworkCount; i++) {
        Network = (PCNETWORK)NetworkList[i];
        //
        // Make sure this isn't a handle to a network from a different
        // cluster
        //
        if (Network->Cluster != Cluster) {
            Status = ERROR_INVALID_PARAMETER;
            goto error_exit;
        }

        WRAP(Status,
             (ApiGetNetworkId(Network->hNetwork,
                              &IdArray[i])),
             Cluster);

        if (Status != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // Make sure there are no duplicates
        //
        for (j=0; j<i; j++) {
            if (lstrcmpiW(IdArray[j],IdArray[i]) == 0) {

                //
                // A duplicate node is in the list
                //
                Status = ERROR_INVALID_PARAMETER;
                goto error_exit;
            }
        }
    }

    WRAP(Status,
         (ApiSetNetworkPriorityOrder(Cluster->RpcBinding,
                                     NetworkCount,
                                     IdArray)),
         Cluster);

error_exit:

    for (i=0; i<NetworkCount; i++) {
        if (IdArray[i] != NULL) {
            MIDL_user_free(IdArray[i]);
        }
    }

    LocalFree(IdArray);

    return(Status);
}


HCHANGE
WINAPI
FindFirstClusterChangeNotification(
    IN HCLUSTER hCluster,
    IN DWORD fdwFilter,
    IN DWORD Reserved,
    IN HANDLE hEvent
    )

/*++

Routine Description:

    Creates a change notification object that is associated with a
    specified cluster. The object permits the notification of
    cluster changes based on a specified filter.

Arguments:

    hCluster - Supplies a handle of a cluster.

    fdwFilter - A set of bit flags that specifies the conditions that will
                cause the notification to occur. Currently defined conditions
                include:

        CLUSTER_CHANGE_NODE_STATE
        CLUSTER_CHANGE_NODE_ADDED
        CLUSTER_CHANGE_NODE_DELETED
        CLUSTER_CHANGE_RESOURCE_STATE
        CLUSTER_CHANGE_RESOURCE_ADDED
        CLUSTER_CHANGE_RESOURCE_DELETED
        CLUSTER_CHANGE_RESOURCE_TYPE_ADDED
        CLUSTER_CHANGE_RESOURCE_TYPE_DELETED
        CLUSTER_CHANGE_QUORUM_STATE


    Reserved - Reserved, must be zero

    hEvent - Supplies a handle to a manual-reset event object that will enter
             the signaled state when one of the conditions specified in the
             filter occurs.

Return Value:

    If the function is successful, the return value is a handle of the
    change notification object.

    If the function fails, the return value is NULL. To get extended error
    information, call GetLastError.

Remarks:

    Applications may wait for notifications by using WaitForSingleObject or
    WaitForMultipleObjects on the specified event handle. When a cluster
    change occurs which passes the condition filter, the wait is satisfied.

    After the wait has been satisfied, applications may respond to the
    notification and continue monitoring the cluster by calling
    FindNextClusterChangeNotification and the appropriate wait function.
    When the notification handle is no longer needed, it can be closed
    by calling FindCloseClusterChangeNotification.

--*/

{
    if (Reserved != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(NULL);
}


DWORD
WINAPI
FindNextClusterChangeNotification(
    IN HCHANGE hChange,
    OUT OPTIONAL LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )

/*++

Routine Description:

    Retrieves information associated with a cluster change. Optionally returns
    the name of the cluster object that the notification is associated with.

    Resets the event object associated with the specified change notification
    handle. The event object will be signaled the next time a change
    meeting the change object condition filter occurs.

Arguments:

    hChange - Supplies a handle of a cluster change notification object.

    lpszName - if present, Returns the name of the cluster object that the
            notification is associated with.

    lpcchName - Only used if lpszName != NULL. Supplies a pointer to the length
            in characters of the buffer pointed to by lpszName. Returns the
            number of characters (not including the terminating NULL) written
            to the buffer.

Return Value:

    Returns the bit flag that indicates what the cluster event is.

    If the function fails, it returns 0. To get extended error information,
    call GetLastError.

Remarks:

    The function retrieves the next change notifications and
    resets the associated event object.

    If the associated event object is not signalled, this function
    blocks until a notification event occurs.

--*/

{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}


BOOL
WINAPI
FindCloseClusterChangeNotification(
    IN HCHANGE hChange
    )

/*++

Routine Description:

    Closes a handle of a change notification object.

Arguments:

    hChange - Supplies a handle of a cluster change notification object
              to close.

Return Value:

    If the function is successful, the return value is TRUE.

    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.

Remarks:

--*/

{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}


HCLUSENUM
WINAPI
ClusterOpenEnum(
    IN HCLUSTER hCluster,
    IN DWORD dwType
    )

/*++

Routine Description:

    Initiates an enumeration of the existing cluster objects.

Arguments:

    hCluster - Supplies a handle to a cluster.

    dwType - Supplies a bitmask of the type of objects to be
            enumerated. Currently defined types include

        CLUSTER_ENUM_NODE      - Cluster nodes
        CLUSTER_ENUM_RESTYPE   - Cluster resource types
        CLUSTER_ENUM_RESOURCE  - Cluster resources (except group resources)
        CLUSTER_ENUM_GROUPS    - Cluster group resources
        CLUSTER_ENUM_NETWORK   - Cluster networks
        CLUSTER_ENUM_NETWORK_INTERFACE - Cluster network interfaces
        CLUSTER_ENUM_INTERNAL_NETWORK - Networks used for internal
                                        communication in highest to
                                        lowest priority order. May not
                                        be used in conjunction with any
                                        other types.

Return Value:

    If successful, returns a handle suitable for use with ClusterEnum

    If unsuccessful, returns NULL and GetLastError() returns a more
        specific error code.

--*/

{
    PCLUSTER Cluster;
    PENUM_LIST Enum = NULL;
    DWORD Status;


    if (dwType & CLUSTER_ENUM_INTERNAL_NETWORK) {
        if ((dwType & ~CLUSTER_ENUM_INTERNAL_NETWORK) != 0) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(NULL);
        }
    }
    else {
        if ((dwType & CLUSTER_ENUM_ALL) == 0) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(NULL);
        }
        if ((dwType & ~CLUSTER_ENUM_ALL) != 0) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(NULL);
        }
    }

    Cluster = (PCLUSTER)hCluster;

    WRAP(Status,
         (ApiCreateEnum(Cluster->RpcBinding,
                        dwType,
                        &Enum)),
         Cluster);

    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }

    return((HCLUSENUM)Enum);
}


DWORD
WINAPI
ClusterGetEnumCount(
    IN HCLUSENUM hEnum
    )
/*++

Routine Description:

    Gets the number of items contained the the enumerator's collection.

Arguments:

    hEnum - a handle to an enumerator returned by ClusterOpenEnum.

Return Value:

    The number of items (possibly zero) in the enumerator's collection.
    
--*/
{
    PENUM_LIST Enum = (PENUM_LIST)hEnum;
    return Enum->EntryCount;
}


DWORD
WINAPI
ClusterEnum(
    IN HCLUSENUM hEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )

/*++

Routine Description:

    Returns the next enumerable object.

Arguments:

    hEnum - Supplies a handle to an open cluster enumeration returned by
            ClusterOpenEnum

    dwIndex - Supplies the index to enumerate. This parameter should be
            zero for the first call to the ClusterEnum function and then
            incremented for subsequent calls.

    dwType - Returns the type of object.

    lpszName - Points to a buffer that receives the name of the object,
            including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszName parameter. This size
            should include the terminating null character. When the function returns,
            the variable pointed to by lpcchName contains the number of
            characters stored in the buffer. The count returned does not include
            the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD NameLen;
    PENUM_LIST Enum = (PENUM_LIST)hEnum;

    if (dwIndex >= Enum->EntryCount) {
        return(ERROR_NO_MORE_ITEMS);
    }

    NameLen = lstrlenW(Enum->Entry[dwIndex].Name);
    MylstrcpynW(lpszName, Enum->Entry[dwIndex].Name, *lpcchName);
    if (*lpcchName < (NameLen + 1)) {
        if (lpszName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {
        Status = ERROR_SUCCESS;
    }

    *lpdwType = Enum->Entry[dwIndex].Type;
    *lpcchName = NameLen;

    return(Status);
}


DWORD
WINAPI
ClusterCloseEnum(
    IN HCLUSENUM hEnum
    )

/*++

Routine Description:

    Closes an open enumeration.

Arguments:

    hEnum - Supplies a handle to the enumeration to be closed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD i;
    PENUM_LIST Enum = (PENUM_LIST)hEnum;

    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
        Enum->Entry[i].Name = NULL;
    }
    //
    // Set this to a bogus value so people who are reusing closed stuff
    // will be unpleasantly surprised
    //
    Enum->EntryCount = (ULONG)-1;
    MIDL_user_free(Enum);
    return(ERROR_SUCCESS);
}


HNODEENUM
WINAPI
ClusterNodeOpenEnum(
    IN HNODE hNode,
    IN DWORD dwType
    )

/*++

Routine Description:

    Initiates an enumeration of the existing cluster node objects.

Arguments:

    hNode - Supplies a handle to the specific node.

    dwType - Supplies a bitmask of the type of properties to be
            enumerated. Currently defined types include

            CLUSTER_NODE_ENUM_NETINTERFACES - all net interfaces associated
                                              with this node

Return Value:

    If successful, returns a handle suitable for use with ClusterNodeEnum

    If unsuccessful, returns NULL and GetLastError() returns a more
        specific error code.

--*/

{
    PCNODE Node = (PCNODE)hNode;
    PENUM_LIST Enum = NULL;
    DWORD errorStatus;

    if ((dwType & CLUSTER_NODE_ENUM_ALL) == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }
    if ((dwType & ~CLUSTER_NODE_ENUM_ALL) != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    WRAP(errorStatus,
         (ApiCreateNodeEnum(Node->hNode, dwType, &Enum)),
         Node->Cluster);

    if (errorStatus != ERROR_SUCCESS) {
        SetLastError(errorStatus);
        return(NULL);
    }

    return((HNODEENUM)Enum);
}


DWORD
WINAPI
ClusterNodeGetEnumCount(
    IN HNODEENUM hNodeEnum
    )
/*++

Routine Description:

    Gets the number of items contained the the enumerator's collection.

Arguments:

    hEnum - a handle to an enumerator returned by ClusterNodeOpenEnum.

Return Value:

    The number of items (possibly zero) in the enumerator's collection.
    
--*/
{
    PENUM_LIST Enum = (PENUM_LIST)hNodeEnum;
    return Enum->EntryCount;
}



DWORD
WINAPI
ClusterNodeEnum(
    IN HNODEENUM hNodeEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )

/*++

Routine Description:

    Returns the next enumerable object.

Arguments:

    hNodeEnum - Supplies a handle to an open cluster node enumeration
            returned by ClusterNodeOpenEnum

    dwIndex - Supplies the index to enumerate. This parameter should be
            zero for the first call to the ClusterEnum function and then
            incremented for subsequent calls.

    lpdwType - Points to a DWORD that receives the type of the object
            being enumerated

    lpszName - Points to a buffer that receives the name of the object,
            including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszName parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to by lpcchName contains the
            number of characters stored in the buffer. The count returned
            does not include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD NameLen;
    PENUM_LIST Enum = (PENUM_LIST)hNodeEnum;

    if (dwIndex >= Enum->EntryCount) {
        return(ERROR_NO_MORE_ITEMS);
    }

    NameLen = lstrlenW(Enum->Entry[dwIndex].Name);
    MylstrcpynW(lpszName, Enum->Entry[dwIndex].Name, *lpcchName);
    if (*lpcchName < (NameLen + 1)) {
        if (lpszName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {
        Status = ERROR_SUCCESS;
    }

    *lpdwType = Enum->Entry[dwIndex].Type;
    *lpcchName = NameLen;

    return(Status);
}


DWORD
WINAPI
ClusterNodeCloseEnum(
    IN HNODEENUM hNodeEnum
    )

/*++

Routine Description:

    Closes an open enumeration for a node.

Arguments:

    hNodeEnum - Supplies a handle to the enumeration to be closed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD i;
    PENUM_LIST Enum = (PENUM_LIST)hNodeEnum;

    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
    }
    MIDL_user_free(Enum);
    return(ERROR_SUCCESS);
}


HGROUPENUM
WINAPI
ClusterGroupOpenEnum(
    IN HGROUP hGroup,
    IN DWORD dwType
    )

/*++

Routine Description:

    Initiates an enumeration of the existing cluster group objects.

Arguments:

    hGroup - Supplies a handle to the specific group.

    dwType - Supplies a bitmask of the type of properties to be
            enumerated. Currently defined types include

            CLUSTER_GROUP_ENUM_CONTAINS  - All resources contained in the specified
                                           group

            CLUSTER_GROUP_ENUM_NODES     - All nodes in the specified group's preferred
                                           owner list.

Return Value:

    If successful, returns a handle suitable for use with ClusterGroupEnum

    If unsuccessful, returns NULL and GetLastError() returns a more
        specific error code.

--*/

{
    PCGROUP Group = (PCGROUP)hGroup;
    PENUM_LIST Enum = NULL;
    DWORD errorStatus;

    if ((dwType & CLUSTER_GROUP_ENUM_ALL) == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }
    if ((dwType & ~CLUSTER_GROUP_ENUM_ALL) != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    WRAP(errorStatus,
         (ApiCreateGroupResourceEnum(Group->hGroup,
                                     dwType,
                                     &Enum)),
         Group->Cluster);
    if (errorStatus != ERROR_SUCCESS) {
        SetLastError(errorStatus);
        return(NULL);
    }

    return((HGROUPENUM)Enum);

}


DWORD
WINAPI
ClusterGroupGetEnumCount(
    IN HGROUPENUM hGroupEnum
    )
/*++

Routine Description:

    Gets the number of items contained the the enumerator's collection.

Arguments:

    hEnum - a handle to an enumerator returned by ClusterGroupOpenEnum.

Return Value:

    The number of items (possibly zero) in the enumerator's collection.
    
--*/
{
    PENUM_LIST Enum = (PENUM_LIST)hGroupEnum;
    return Enum->EntryCount;
}



DWORD
WINAPI
ClusterGroupEnum(
    IN HGROUPENUM hGroupEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )

/*++

Routine Description:

    Returns the next enumerable resource object.

Arguments:

    hGroupEnum - Supplies a handle to an open cluster group enumeration
            returned by ClusterGroupOpenEnum

    dwIndex - Supplies the index to enumerate. This parameter should be
            zero for the first call to the ClusterGroupEnum function and then
            incremented for subsequent calls.

    lpszName - Points to a buffer that receives the name of the object,
            including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszName parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to by lpcchName contains the
            number of characters stored in the buffer. The count returned
            does not include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD NameLen;
    PENUM_LIST Enum = (PENUM_LIST)hGroupEnum;

    if (dwIndex >= Enum->EntryCount) {
        return(ERROR_NO_MORE_ITEMS);
    }

    NameLen = lstrlenW(Enum->Entry[dwIndex].Name);
    MylstrcpynW(lpszName, Enum->Entry[dwIndex].Name, *lpcchName);
    if (*lpcchName < (NameLen + 1)) {
        if (lpszName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {
        Status = ERROR_SUCCESS;
    }

    *lpdwType = Enum->Entry[dwIndex].Type;
    *lpcchName = NameLen;

    return(Status);
}


DWORD
WINAPI
ClusterGroupCloseEnum(
    IN HGROUPENUM hGroupEnum
    )

/*++

Routine Description:

    Closes an open enumeration for a group.

Arguments:

    hGroupEnum - Supplies a handle to the enumeration to be closed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD i;
    PENUM_LIST Enum = (PENUM_LIST)hGroupEnum;

    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
    }
    MIDL_user_free(Enum);
    return(ERROR_SUCCESS);
}


VOID
APIENTRY
MylstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    DWORD iMaxLength
    )
{
    LPWSTR src,dst;

    src = (LPWSTR)lpString2;
    dst = lpString1;

    if ( iMaxLength ) {
        while(iMaxLength && *src){
            *dst++ = *src++;
            iMaxLength--;
        }
        if ( iMaxLength ) {
            *dst = L'\0';
        } else {
            dst--;
            *dst = L'\0';
        }
    }
}

/****
@func       DWORD | BackupClusterDatabase | Requests for backup
            of the cluster database files and resource registry
            checkpoint files to a specified directory path. This
            directory path must preferably be visible to all nodes
            in the cluster (such as a UNC path) or if it is not a UNC
            path it should at least be visible to the node on which the
            quorum resource is online.

@parm       IN HCLUSTER | hCluster | Supplies a handle to
            an open cluster.
@parm       IN LPCWSTR | lpszPathName | Supplies the directory path
            where the quorum log file and the checkpoint file must
            be backed up. This path must be visible to the node on
            which the quorum resource is online.

@comm       This function requests for backup of the quorum log file
            and the related checkpoint files for the cluster hive.
            This API backs up all the registry checkpoint files that
            resources have registered for replication. The API backend
            is responsible for directing the call to the owner node of
            the quorum resource  and for synchronizing this operation
            with state of the quorum resource.  If successful, the
            database files will be saved to the supplied directory path
            with the same name as in the quorum disk. Note that in case
            this API hits a cluster node while the quorum group is moving
            to another node, it is possible that the API will fail with
            an error code ERROR_HOST_NODE_NOT_RESOURCE_OWNER. In such a
            case, the client has to call the API again.

@rdesc      Returns a Win32 error code if the operation is
            unsuccessful. ERROR_SUCCESS on success.

@xref       <f RestoreClusterDatabase>
****/
DWORD
WINAPI
BackupClusterDatabase(
    IN HCLUSTER hCluster,
    IN LPCWSTR  lpszPathName
    )
{
    DWORD dwStatus;
    PCLUSTER pCluster;

    //
    //  Chittur Subbaraman (chitturs) - 10/20/98
    //
    pCluster = GET_CLUSTER(hCluster);

    WRAP( dwStatus,
        ( ApiBackupClusterDatabase( pCluster->RpcBinding, lpszPathName ) ),
          pCluster );

    return( dwStatus );
}

/****
@func       DWORD | RestoreClusterDatabase | Restores the cluster
            database from the supplied path to the quorum disk and
            restarts the cluster service on the restoring node.

@parm       IN LPCWSTR | lpszPathName | Supplies the path from where
            the cluster database has to be retrieved

@parm       IN BOOL | bForce | Should the restore operation be done
            by force performing fixups silently ?

@parm       IN BOOL | lpszQuorumDriveLetter | If the user has replaced
            the quorum drive since the time of backup, specifies the
            drive letter of the quorum device. This is an optional
            parameter.

@comm       This API can work under the following scenarios:
            (1) No cluster nodes are active.
            (2) One or more cluster nodes are active.
            (3) Quorum disk replaced since the time the backup was made.
                The replacement disk must have identical partition layout
                to the quorum disk at the time the backup was made. However,
                the new disk may have different drive letter(s) and/or
                signature from the original quorum disk.
            (4) User wants to get the cluster back to a previous state.

@rdesc      Returns a Win32 error code if the operation is unsuccessful.
            ERROR_SUCCESS on success.

@xref       <f BackupClusterDatabase>
****/
DWORD
WINAPI
RestoreClusterDatabase(
    IN LPCWSTR  lpszPathName,
    IN BOOL     bForce,
    IN LPCWSTR  lpszQuorumDriveLetter   OPTIONAL
    )
{
    SC_HANDLE       hService = NULL;
    SC_HANDLE       hSCManager = NULL;
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwRetryTime = 120*1000;  // wait 120 secs max for shutdown
    DWORD           dwRetryTick = 5000;      // 5 sec at a time
    SERVICE_STATUS  serviceStatus;
    BOOL            bStopCommandGiven = FALSE;
    DWORD           dwLen;
    HKEY            hClusSvcKey = NULL;
    DWORD           dwExitCode;

    //
    //  Chittur Subbaraman (chitturs) - 10/29/98
    //

    //
    //  Check the validity of parameters
    //
    if ( lpszQuorumDriveLetter != NULL )
    {
        dwLen = lstrlenW( lpszQuorumDriveLetter );
        if ( ( dwLen != 2 ) ||
             !iswalpha( lpszQuorumDriveLetter[0] ) ||
             ( lpszQuorumDriveLetter[1] != L':' ) )
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            TIME_PRINT(("Quorum drive letter '%ws' is invalid\n",
                         lpszQuorumDriveLetter));
            goto FnExit;
        }
    }

    hSCManager = OpenSCManager( NULL,        // assume local machine
                                NULL,        // ServicesActive database
                                SC_MANAGER_ALL_ACCESS ); // all access

    if ( hSCManager == NULL )
    {
        dwStatus = GetLastError();
        TIME_PRINT(("RestoreDatabase: Cannot access service controller! Error: %u.\n",
                   dwStatus));
        goto FnExit;
    }

    hService = OpenService( hSCManager,
                            "clussvc",
                            SERVICE_ALL_ACCESS );

    if ( hService == NULL )
    {
        dwStatus = GetLastError();
        CloseServiceHandle( hSCManager );
        TIME_PRINT(("RestoreClusterDatabase: Cannot open cluster service. Error: %u.\n",
                   dwStatus));
        goto FnExit;
    }

    CloseServiceHandle( hSCManager );

    //
    //  Check whether the service is already in the SERVICE_STOPPED
    //  state.
    //
    if ( QueryServiceStatus( hService,
                             &serviceStatus ) )
    {
        if ( serviceStatus.dwCurrentState == SERVICE_STOPPED )
        {
            TIME_PRINT(("RestoreClusterDatabase: Cluster service is already in stopped state\n"));
            goto bypass_stop_procedure;
        }
    }

    //
    //  Now attempt to stop the cluster service
    //
    while ( TRUE )
    {
        dwStatus = ERROR_SUCCESS;
        if ( bStopCommandGiven == TRUE )
        {
            if ( QueryServiceStatus( hService,
                                     &serviceStatus ) )
            {
                if ( serviceStatus.dwCurrentState == SERVICE_STOPPED )
                {
                    //
                    //  Succeeded in stopping the service
                    //
                    TIME_PRINT(("RestoreClusterDatabase: Clussvc stopped successfully\n"));
                    break;
                }
            } else
            {
                dwStatus = GetLastError();
                TIME_PRINT(("RestoreClusterDatabase: Error %d in querying clussvc status\n",
                            dwStatus));
            }
        } else
        {
            if ( ControlService( hService,
                                 SERVICE_CONTROL_STOP,
                                 &serviceStatus ) )
            {
                bStopCommandGiven = TRUE;
                dwStatus = ERROR_SUCCESS;
            } else
            {
                dwStatus = GetLastError();
                TIME_PRINT(("RestoreClusterDatabase: Error %d in sending control to stop clussvc\n",
                            dwStatus));
            }
        }

        if ( ( dwStatus == ERROR_EXCEPTION_IN_SERVICE ) ||
             ( dwStatus == ERROR_PROCESS_ABORTED ) ||
             ( dwStatus == ERROR_SERVICE_NOT_ACTIVE ) )
        {
            //
            //  The service is essentially in a terminated state
            //
            TIME_PRINT(("RestoreClusterDatabase: Clussvc in died/inactive state\n"));
            dwStatus = ERROR_SUCCESS;
            break;
        }

        if ( ( dwRetryTime -= dwRetryTick ) <= 0 )
        {
            //
            //  All tries to stop the service failed, exit from this
            //  function with an error code
            //
            TIME_PRINT(("RestoreClusterDatabase: Cluster service did not stop, giving up..."));
            dwStatus = ERROR_TIMEOUT;
            break;
        }

        TIME_PRINT(("RestoreClusterDatabase: Trying to stop cluster service\n"));
        //
        //  Sleep for a while and retry stopping the service
        //
        Sleep( dwRetryTick );
    } // while

    if ( dwStatus != ERROR_SUCCESS )
    {
        goto FnExit;
    }

bypass_stop_procedure:

    //
    // Open key to SYSTEM\CurrentControlSet\Services\ClusSvc\Parameters
    //
    if ( ( dwStatus = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                      CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                      &hClusSvcKey ) )  != ERROR_SUCCESS )
    {
        TIME_PRINT(("RestoreClusterDatabase: Unable to open clussvc parameters key\n"));
        goto FnExit;
    }

    dwLen = lstrlenW ( lpszPathName );
    //
    //  Set the RestoreDatabase value so that the cluster service
    //  will read it at startup time
    //
    if ( ( dwStatus = RegSetValueExW( hClusSvcKey,
                                      CLUSREG_NAME_SVC_PARAM_RESTORE_DB,
                                      0,
                                      REG_SZ,
                                      (BYTE * const) lpszPathName,
                                      ( dwLen + 1 ) * sizeof ( WCHAR ) ) ) != ERROR_SUCCESS )
    {
        TIME_PRINT(("RestoreClusterDatabase: Unable to set %ws value\n",
                    CLUSREG_NAME_SVC_PARAM_RESTORE_DB));
        goto FnExit;
    }

    if ( bForce == TRUE )
    {
        //
        //  Since the user is forcing a database restore operation, set
        //  the ForceDatabaseRestore value and the NewQuorumDriveLetter
        //  value, if any
        //
        dwLen = 0;
        if ( ( dwStatus = RegSetValueExW( hClusSvcKey,
                             CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB,
                             0,
                             REG_DWORD,
                             (BYTE * const) &dwLen,
                             sizeof ( DWORD ) ) ) != ERROR_SUCCESS )
        {
            TIME_PRINT(("RestoreClusterDatabase: Unable to set %ws value\n",
                        CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB));
            goto FnExit;
        }

        if ( lpszQuorumDriveLetter != NULL )
        {
            dwLen = lstrlenW( lpszQuorumDriveLetter );
            if ( ( dwStatus = RegSetValueExW( hClusSvcKey,
                                      CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER,
                                      0,
                                      REG_SZ,
                                      (BYTE * const) lpszQuorumDriveLetter,
                                      ( dwLen + 1 ) * sizeof ( WCHAR ) ) ) != ERROR_SUCCESS )
            {
                TIME_PRINT(("RestoreClusterDatabase: Unable to set %ws value\n",
                            CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER));
                goto FnExit;
            }
        }
    }

    //
    //  Copy the latest checkpoint file from the backup area to the
    //  cluster directory and rename it as CLUSDB
    //
    dwStatus = CopyCptFileToClusDirp ( lpszPathName );
    if ( dwStatus != ERROR_SUCCESS )
    {
        TIME_PRINT(("RestoreClusterDatabase: Unable to copy checkpoint file to CLUSDB\n"
                  ));
        goto FnExit;
    }

    //
    //  Sleep for some time before starting the service so that any UP nodes may cleanly finish
    //  their node down processing before the start of the service.
    //
    Sleep( 12 * 1000 );

    //
    //  Now, start the cluster service
    //
    if ( !StartService( hService,
                        0,
                        NULL ) )
    {
        dwStatus = GetLastError();
        TIME_PRINT(("RestoreClusterDatabase: Unable to start cluster service\n"
                  ));
        goto FnExit;
    }

    dwRetryTime = 5 * 60 * 1000;
    dwRetryTick = 1 * 1000;

    while ( TRUE )
    {
        if ( !QueryServiceStatus( hService,
                                  &serviceStatus ) )
        {
            dwStatus = GetLastError();
            TIME_PRINT(("RestoreClusterDatabase: Unable to get the status of cluster service to check liveness\n"
                      ));
            goto FnExit;
        }

        if ( serviceStatus.dwCurrentState == SERVICE_STOPPED )
        {
            //
            //  The service terminated after our start up. Exit with
            //  an error code.
            //
            dwStatus = serviceStatus.dwServiceSpecificExitCode;
            if ( dwStatus == ERROR_SUCCESS )
            {
                dwStatus = serviceStatus.dwWin32ExitCode;
            }
            TIME_PRINT(("RestoreClusterDatabase: Cluster service stopped after starting up\n"
                      ));
            goto FnExit;
        } else if ( serviceStatus.dwCurrentState == SERVICE_RUNNING )
        {
            //
            //  The service has fully started up and is running.
            //
            dwStatus = ERROR_SUCCESS;
            TIME_PRINT(("RestoreClusterDatabase: Cluster service started successfully\n"
                      ));
            break;
        }

        if ( ( dwRetryTime -= dwRetryTick ) <= 0 )
        {
            dwStatus = ERROR_TIMEOUT;
            TIME_PRINT(("RestoreClusterDatabase: Cluster service has not started even after %d minutes, giving up monitoring...\n",
                      dwRetryTime/(60*1000)));
            goto FnExit;
        }
        Sleep( dwRetryTick );
    }


FnExit:
    if ( hService != NULL )
    {
        CloseServiceHandle( hService );
    }

    if ( hClusSvcKey != NULL )
    {
        //
        //  Try to delete the values you set. You may fail in this step,
        //  beware !
        //
        RegDeleteValueW( hClusSvcKey,
                         CLUSREG_NAME_SVC_PARAM_RESTORE_DB );
        if ( bForce == TRUE )
        {
            RegDeleteValueW( hClusSvcKey,
                             CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB );
            if ( lpszQuorumDriveLetter != NULL )
            {
                RegDeleteValueW( hClusSvcKey,
                                 CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER );
            }
        }
        RegCloseKey( hClusSvcKey );
    }

    return( dwStatus );
}

/****
@func       DWORD | CopyCptFileToClusDirp | Copy the most recent checkpoint
            file from the backup path to the cluster directory overwriting
            the CLUSDB there.

@parm       IN LPCWSTR | lpszPathName | Supplies the path from where
            the checkpoint file has to be retrieved.

@rdesc      Returns a Win32 error code if the operation is
            unsuccessful. ERROR_SUCCESS on success.

@xref       <f RestoreClusterDatabase>
****/
DWORD
CopyCptFileToClusDirp(
    IN LPCWSTR  lpszPathName
    )
{
#define     CLUSAPI_EXTRA_LEN   25
    HANDLE                      hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW            FindData;
    DWORD                       dwStatus;
    WCHAR                       szDestFileName[MAX_PATH];
    LPWSTR                      szSourceFileName = NULL;
    LPWSTR                      szSourcePathName = NULL;
    DWORD                       dwLen;
    WIN32_FILE_ATTRIBUTE_DATA   FileAttributes;
    LARGE_INTEGER               liFileCreationTime;
    LARGE_INTEGER               liMaxFileCreationTime;
    WCHAR                       szCheckpointFileName[MAX_PATH];
    WCHAR                       szClusterDir[MAX_PATH];
    DWORD                       cchSourceFileName;

    //
    //  Chittur Subbaraman (chitturs) - 10/29/98
    //
    dwLen = lstrlenW ( lpszPathName );
    //
    //  It is safer to use dynamic memory allocation for user-supplied
    //  path since we don't want to put restrictions on the user
    //  on the length of the path that can be supplied. However, as
    //  far as our own destination path is concerned, it is system-dependent
    //  and static memory allocation for that would suffice.
    //
    szSourcePathName = (LPWSTR) LocalAlloc ( LMEM_FIXED,
                                 ( dwLen + CLUSAPI_EXTRA_LEN ) *
                                 sizeof ( WCHAR ) );

    if ( szSourcePathName == NULL )
    {
        dwStatus = GetLastError();
        TIME_PRINT(("CopyCptFileToClusDirp: Error %d in allocating memory for %ws\n",
                    dwStatus,
                    lpszPathName));
        goto FnExit;
    }

    ( void ) StringCchCopyW ( szSourcePathName,  dwLen + CLUSAPI_EXTRA_LEN, lpszPathName );

    //
    //  If the client-supplied path is not already terminated with '\',
    //  then add it.
    //
    if ( szSourcePathName [dwLen-1] != L'\\' )
    {
        szSourcePathName [dwLen++] = L'\\';
        szSourcePathName [dwLen] = L'\0';
    }

    ( void ) StringCchCatW ( szSourcePathName, dwLen + CLUSAPI_EXTRA_LEN, L"CLUSBACKUP.DAT" );

    //
    //  Try to find the CLUSBACKUP.DAT file in the directory
    //
    hFindFile = FindFirstFileW( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen] = L'\0';
    if ( hFindFile == INVALID_HANDLE_VALUE )
    {
        dwStatus = GetLastError();
        if ( dwStatus != ERROR_FILE_NOT_FOUND )
        {
            TIME_PRINT(("CopyCptFileToClusDirp: Path %ws unavailable, Error = %d\n",
                        szSourcePathName,
                        dwStatus));
        } else
        {
            dwStatus = ERROR_DATABASE_BACKUP_CORRUPT;
            TIME_PRINT(("CopyCptFileToClusDirp: Backup procedure not fully successful, can't restore checkpoint to CLUSDB, Error = %d !!!\n",
                        dwStatus));
        }
        goto FnExit;
    }
    FindClose ( hFindFile );

    ( void ) StringCchCatW( szSourcePathName, dwLen + CLUSAPI_EXTRA_LEN, L"chk*.tmp" );

    //
    //  Try to find the first chk*.tmp file in the directory
    //
    hFindFile = FindFirstFileW( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen] = L'\0';
    if ( hFindFile == INVALID_HANDLE_VALUE )
    {
        dwStatus = GetLastError();
        TIME_PRINT(("CopyCptFileToClusDirp: Error %d in trying to find chk*.tmp file in path %ws\r\n",
                    szSourcePathName,
                    dwStatus));
        goto FnExit;
    }

    cchSourceFileName = lstrlenW ( szSourcePathName ) + MAX_PATH;
    szSourceFileName = (LPWSTR) LocalAlloc ( LMEM_FIXED,
                                    cchSourceFileName * sizeof ( WCHAR ) );

    if ( szSourceFileName == NULL )
    {
        dwStatus = GetLastError();
        TIME_PRINT(("CopyCptFileToClusDirp: Error %d in allocating memory for source file name\n",
              dwStatus));
        goto FnExit;
    }

    dwStatus = ERROR_SUCCESS;
    liMaxFileCreationTime.QuadPart = 0;

    //
    //  Now, find the most recent chk*.tmp file from the source path
    //
    while ( dwStatus == ERROR_SUCCESS )
    {
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            goto skip;
        }

        ( void ) StringCchCopyW( szSourceFileName, cchSourceFileName, szSourcePathName );
        ( void ) StringCchCatW( szSourceFileName, cchSourceFileName, FindData.cFileName );
        if ( !GetFileAttributesExW( szSourceFileName,
                                    GetFileExInfoStandard,
                                    &FileAttributes ) )
        {
            dwStatus = GetLastError();
            TIME_PRINT(("CopyCptFileToClusDirp: Error %d in getting file attributes for %ws\n",
                         dwStatus,
                         szSourceFileName));
            goto FnExit;
        }

        liFileCreationTime.HighPart = FileAttributes.ftCreationTime.dwHighDateTime;
        liFileCreationTime.LowPart  = FileAttributes.ftCreationTime.dwLowDateTime;
        if ( liFileCreationTime.QuadPart > liMaxFileCreationTime.QuadPart )
        {
            liMaxFileCreationTime.QuadPart = liFileCreationTime.QuadPart;
            ( void ) StringCchCopyW( szCheckpointFileName, RTL_NUMBER_OF ( szCheckpointFileName ), FindData.cFileName );
        }
skip:
        if ( FindNextFileW( hFindFile, &FindData ) )
        {
            dwStatus = ERROR_SUCCESS;
        } else
        {
            dwStatus = GetLastError();
        }
    }

    if ( dwStatus == ERROR_NO_MORE_FILES )
    {
        dwStatus = ERROR_SUCCESS;
    } else
    {
        TIME_PRINT(("CopyCptFileToClusDirp: FindNextFile failed\n"));
        goto FnExit;
    }

    //
    //  Get the directory where the cluster is installed
    //
    if ( ( dwStatus = ClRtlGetClusterDirectory( szClusterDir, MAX_PATH ) )
                    != ERROR_SUCCESS )
    {
        TIME_PRINT(("CopyCptFileToClusDirp: Error %d in getting cluster dir !!!\n",
                    dwStatus));
        goto FnExit;
    }

    ( void ) StringCchCopyW( szSourceFileName, cchSourceFileName, szSourcePathName );
    ( void ) StringCchCatW( szSourceFileName, cchSourceFileName, szCheckpointFileName );

    ( void ) StringCchCopyW( szDestFileName, RTL_NUMBER_OF ( szDestFileName ), szClusterDir );
    dwLen = lstrlenW( szDestFileName );
    if ( szDestFileName[dwLen-1] != L'\\' )
    {
        szDestFileName[dwLen++] = L'\\';
        szDestFileName[dwLen] = L'\0';
    }

#ifdef   OLD_WAY
    ( void ) StringCchCatW ( szDestFileName, RTL_NUMBER_OF ( szDestFileName ), L"CLUSDB" );
#else    // OLD_WAY
    ( void ) StringCchCatW ( szDestFileName, RTL_NUMBER_OF ( szDestFileName ), CLUSTER_DATABASE_NAME );
#endif   // OLD_WAY

    //
    //  Set the destination file attribute to normal. Continue even
    //  if you fail in this step because you will fail in the
    //  copy if this error is fatal.
    //
    SetFileAttributesW( szDestFileName, FILE_ATTRIBUTE_NORMAL );

    //
    //  Now try to copy the checkpoint file to CLUSDB
    //
    dwStatus = CopyFileW( szSourceFileName, szDestFileName, FALSE );
    if ( !dwStatus )
    {
        //
        //  You failed in copying. Check whether you encountered a
        //  sharing violation. If so, try unloading the cluster hive and
        //  then retry.
        //
        dwStatus = GetLastError();
        if ( dwStatus == ERROR_SHARING_VIOLATION )
        {
            dwStatus = UnloadClusterHivep( );
            if ( dwStatus == ERROR_SUCCESS )
            {
                SetFileAttributesW( szDestFileName, FILE_ATTRIBUTE_NORMAL );
                dwStatus = CopyFileW( szSourceFileName, szDestFileName, FALSE );
                if ( !dwStatus )
                {
                    dwStatus = GetLastError();
                    TIME_PRINT(("CopyCptFileToClusDirp: Unable to copy file %ws to %ws for a second time, Error = %d\n",
                                szSourceFileName,
                                szDestFileName,
                                dwStatus));
                    goto FnExit;
                }
            } else
            {
                TIME_PRINT(("CopyCptFileToClusDirp: Unable to unload cluster hive, Error = %d\n",
                             dwStatus));
                goto FnExit;
            }
        } else
        {
            TIME_PRINT(("CopyCptFileToClusDirp: Unable to copy file %ws to %ws for the first time, Error = %d\n",
                         szSourceFileName,
                         szDestFileName,
                         dwStatus));
            goto FnExit;
        }
    }

    //
    //  Set the destination file attribute to normal.
    //
    if ( !SetFileAttributesW( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwStatus = GetLastError();
        TIME_PRINT(("CopyCptFileToClusDirp: Unable to change the %ws attributes to normal, Error = %d!\n",
                     szDestFileName,
                     dwStatus));
        goto FnExit;
    }

    dwStatus = ERROR_SUCCESS;
FnExit:
    if ( hFindFile != INVALID_HANDLE_VALUE )
    {
        FindClose( hFindFile );
    }

    LocalFree( szSourcePathName );
    LocalFree( szSourceFileName );

    return( dwStatus );
}

/****
@func       DWORD | UnloadClusterHivep | Unload the cluster hive

@rdesc      Returns a Win32 error code if the operation is
            unsuccessful. ERROR_SUCCESS on success.

@xref       <f CopyCptFileToClusDirp>
****/
DWORD
UnloadClusterHivep(
    VOID
    )
{
    BOOLEAN  bWasEnabled;
    DWORD    dwStatus;

    //
    //  Chittur Subbaraman (chitturs) - 10/29/98
    //
    dwStatus = ClRtlEnableThreadPrivilege( SE_RESTORE_PRIVILEGE,
                                           &bWasEnabled );

    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == STATUS_PRIVILEGE_NOT_HELD )
        {
            TIME_PRINT(("UnloadClusterHivep: Restore privilege not held by client\n"));
        } else
        {
            TIME_PRINT(("UnloadClusterHivep: Attempt to enable restore privilege failed, Error = %d\n",
                        dwStatus));
        }
        goto FnExit;
    }

    dwStatus = RegUnLoadKeyW( HKEY_LOCAL_MACHINE,
                              CLUSREG_KEYNAME_CLUSTER );

    ClRtlRestoreThreadPrivilege( SE_RESTORE_PRIVILEGE,
                                 bWasEnabled );
FnExit:
    return( dwStatus );
}




DWORD
WINAPI
AddRefToClusterHandle(
    IN HCLUSTER hCluster
    )

/*++

Routine Description:

    Increases the reference count on a cluster handle.  This is done by incrementing the reference
    count on the cluster handle.

Arguments:

    hCluster - Cluster handle.

Return Value:

    ERROR_SUCCESS if the operation succeeded.

    ERROR_INVALID_HANDLE if the operation failed.

--*/

{
    DWORD       nStatus     = ERROR_SUCCESS;
    PCLUSTER    pCluster    = GET_CLUSTER( hCluster );
    HCLUSTER    hCluster2   = NULL;

    //
    // If this is not a valid cluster handle, don't duplicate it.
    // Otherwise, increment the reference count.
    //
    if ( pCluster == NULL ) {
        nStatus = ERROR_INVALID_HANDLE;
    } else {
        EnterCriticalSection( &pCluster->Lock );
        pCluster->ReferenceCount++;
        LeaveCriticalSection( &pCluster->Lock );
        hCluster2 = hCluster;
    }


    return( nStatus );

} // AddRefToClusterHandle()




DWORD
WINAPI
SetClusterServiceAccountPassword(
    IN LPCWSTR lpszClusterName,
    IN LPCWSTR lpszNewPassword,
    IN DWORD dwFlags,
    OUT PCLUSTER_SET_PASSWORD_STATUS lpReturnStatusBuffer,
    IN OUT LPDWORD lpcbReturnStatusBufferSize
    )
/*++

Routine Description:

    Updates the password used to logon the Cluster Service to its user
    account. This routine updates the Service Control Manager (SCM) 
    Database and the Local Security Authority (LSA) password cache on 
    every active node of the target cluster. The execution status of the 
    update for each node in the cluster is returned. 

Argument:

    lpszClusterName 
        [IN] Pointer to a null-terminated Unicode string containing the 
            name of the cluster or one of the cluster nodes expressed 
            as a NetBIOS name, a fully-qualified DNS name, or an IP 
            address.
            
    lpszNewPassword
        [IN] Pointer to a null-terminated Unicode string containing the 
             new password.

    dwFlags
        [IN] Describing how the password update should be made to
             the cluster. The dwFlags parameter is optional. If set, the 
             following value is valid: 
             
                 CLUSTER_SET_PASSWORD_IGNORE_DOWN_NODES
                     Apply the update even if some nodes are not
                     actively participating in the cluster (i.e. not
                     ClusterNodeStateUp or ClusterNodeStatePaused).
                     By default, the update is only applied if all 
                     nodes are up. 

    lpReturnStatusBuffer
        [OUT] Pointer to an output buffer to receive an array containing 
              the execution status of the update for each node in the 
              cluster, or NULL if no output date is required.   If  
              lpReturnStatusBuffer is NULL, no error is returned, and 
              the function stores the size of the return data, in bytes, 
              in the DWORD value pointed to by lpcbReturnStatusBufferSize. 
              This lets an application unambiguously determine the correct 
              return buffer size.  


    lpcbReturnStatusBufferSize 
        [IN, OUT] Pointer to a variable that on input specifies the allocated 
        size, in bytes, of lpReturnStatusBuffer. On output, this variable
        recieves the count of bytes written to lpReturnStatusBuffer.
        
Return Value:

    ERROR_SUCCESS 
        The operation was successful. The lpcbReturnStatusBufferSize
        parameter points to the actual size of the data returned in the 
        output buffer. 
        
    ERROR_MORE_DATA 
        The output buffer pointed to by lpReturnStatusBuffer was not large 
        enough to hold the data resulting from the operation. The variable
        pointed to by the lpcbReturnStatusBufferSize parameter receives the 
        size required for the output buffer.  

    ERROR_CLUSTER_OLD_VERSION 
        One or more nodes in the cluster are running a version of Windows 
        that does not support this operation.
                
    ERROR_ALL_NODES_NOT_AVAILABLE. 
        Some nodes in the cluster are not available (i.e. not in the 
        ClusterNodeStateUp or ClusterNodeStatePaused states) and the 
        CLUSTER_SET_PASSWORD_IGNORE_DOWN_NODES flag is not set in dwFlags. 
        
    ERROR_FILE_CORRUPT
        The encrypted new password was modified during transmission 
        on the network.
        
    CRYPT_E_HASH_VALUE
        The keys used by two or more nodes to encrypt the new password for 
        transmission on the network do not match.
        
    ERROR_INVALID_PARAMETER.  
        The lpcbReturnStatusBufferSize parameter was set to NULL.
        
    Other Win32 Error 
        The operation was not successful. The value specified by 
        lpcbReturnStatusBufferSize is unreliable. 
    
Notes:

    This function does not update the password stored by the domain 
    controllers for the Cluster Service's user account. 
    
--*/
{
    PCLUSTER Cluster;
    DWORD Status;
    PIDL_CLUSTER_SET_PASSWORD_STATUS RetReturnStatusBuffer;
    DWORD RetReturnStatusBufferSize;
    DWORD RetSizeReturned = 0;
    DWORD RetExpectedBufferSize = 0;
    HCLUSTER hCluster;
    IDL_CLUSTER_SET_PASSWORD_STATUS Dummy;


    if (lpcbReturnStatusBufferSize == NULL) {
        return ERROR_INVALID_PARAMETER; 
    }

    hCluster = OpenClusterAuthInfo(
                   lpszClusterName, 
                   RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                   );

    if (hCluster == NULL)
    {
        TIME_PRINT((
            "Failed to open handle to cluster, status %d.\n", 
            lpszClusterName, 
            GetLastError()
            ));
        return GetLastError();
    }

    Cluster = GET_CLUSTER(hCluster); 
    if (Cluster == NULL)
    {
        CloseCluster(hCluster);
        return (ERROR_INVALID_HANDLE);
    }

    if (lpReturnStatusBuffer == NULL)
    {
        ZeroMemory(&Dummy, sizeof(Dummy));
        RetReturnStatusBuffer = &Dummy;
        RetReturnStatusBufferSize = 0;
    }
    else
    {
        RetReturnStatusBuffer = (PIDL_CLUSTER_SET_PASSWORD_STATUS) 
                                lpReturnStatusBuffer;
        RetReturnStatusBufferSize = *lpcbReturnStatusBufferSize;
    }

    WRAP(Status,
         (ApiSetServiceAccountPassword(
             Cluster->RpcBinding,
             (LPWSTR) lpszNewPassword,
             dwFlags,
             RetReturnStatusBuffer,
             ( RetReturnStatusBufferSize /     
               sizeof(IDL_CLUSTER_SET_PASSWORD_STATUS)
             ),                                // convert bytes to elements
             &RetSizeReturned,
             &RetExpectedBufferSize
             )
         ),
         Cluster);


    // Return status can not be ERROR_INVALID_HANDLE, since this will trigger the
    // re-try logic at the RPC client. So ERROR_INVALID_HANDLE is converted to some
    // value, which no Win32 function will ever set its return status to, before
    // it is sent back to RPC client.

    // Error codes are 32-bit values (bit 31 is the most significant bit). Bit 29 
    // is reserved for application-defined error codes; no system error code has 
    // this bit set. If you are defining an error code for your application, set this 
    // bit to one. That indicates that the error code has been defined by an application, 
    // and ensures that your error code does not conflict with any error codes defined 
    // by the system. 
    if ( Status == (ERROR_INVALID_HANDLE | 0x20000000) ) {
        Status = ERROR_INVALID_HANDLE;   // turn off Bit 29
    }

    if (Status == ERROR_SUCCESS) {
        //
        // Convert elements to bytes
        //
        *lpcbReturnStatusBufferSize = RetSizeReturned * 
                                      sizeof(CLUSTER_SET_PASSWORD_STATUS);
    }
    else if (Status == ERROR_MORE_DATA)
    {
        //
        // lpReturnStatusBuffer isn't big enough. Return the required size.
        // Convert from elements to bytes.
        //
        *lpcbReturnStatusBufferSize = RetExpectedBufferSize * 
                                      sizeof(CLUSTER_SET_PASSWORD_STATUS);

        if (lpReturnStatusBuffer == NULL)
        {
            //
            // This was a query for the required buffer size. 
            // Follow convention for return value.
            //
            Status = ERROR_SUCCESS;
        }
    }
    else if (Status == RPC_S_PROCNUM_OUT_OF_RANGE) {
        //
        // Trying to talk to a W2K or NT4 cluster. 
        // Return a more useful error code.
        //
        Status = ERROR_CLUSTER_OLD_VERSION; 
    }


    if (!CloseCluster(hCluster)) {
        TIME_PRINT((
            "Warning: Failed to close cluster handle, status %d.\n", 
            GetLastError()
            ));
    }

    
    return(Status);
    
} //SetClusterServiceAccountPassword()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\network.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    network.c

Abstract:

    Provides interface for managing cluster networks

Author:

    John Vert (jvert) 30-Jan-1996
    Charlie Wickham (charlwi) 5-Jun-1997

Revision History:
    copied from group.c

--*/

#include "clusapip.h"


HNETWORK
WINAPI
OpenClusterNetwork(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszNetworkName
    )

/*++

Routine Description:

    Opens a handle to the specified network

Arguments:

    hCluster - Supplies a handle to the cluster

    lpszNetworkName - Supplies the name of the network to be opened

Return Value:

    non-NULL - returns an open handle to the specified network.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    PCNETWORK Network;
    error_status_t Status = ERROR_SUCCESS;

    //
    // get a pointer to the cluster struct, alloocate space for the network
    // structure and the supplied name.
    //

    Cluster = (PCLUSTER)hCluster;

    Network = LocalAlloc(LMEM_FIXED, sizeof(CNETWORK));
    if (Network == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    Network->Name = LocalAlloc(LMEM_FIXED, (lstrlenW(lpszNetworkName)+1)*sizeof(WCHAR));
    if (Network->Name == NULL) {
        LocalFree(Network);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    // init the network struct and call clussvc to open the network
    //

    lstrcpyW(Network->Name, lpszNetworkName);
    Network->Cluster = Cluster;
    InitializeListHead(&Network->NotifyList);

    WRAP_NULL(Network->hNetwork,
              (ApiOpenNetwork(Cluster->RpcBinding,
                              lpszNetworkName,
                              &Status)),
              &Status,
              Cluster);

    if ((Network->hNetwork == NULL) || (Status != ERROR_SUCCESS)) {

        LocalFree(Network->Name);
        LocalFree(Network);
        SetLastError(Status);
        return(NULL);
    }

    //
    // Link newly opened network onto the cluster structure.
    //

    EnterCriticalSection(&Cluster->Lock);
    InsertHeadList(&Cluster->NetworkList, &Network->ListEntry);
    LeaveCriticalSection(&Cluster->Lock);

    return ((HNETWORK)Network);
}


BOOL
WINAPI
CloseClusterNetwork(
    IN HNETWORK hNetwork
    )

/*++

Routine Description:

    Closes a network handle returned from OpenClusterNetwork

Arguments:

    hNetwork - Supplies the network handle

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCNETWORK Network;
    PCLUSTER Cluster;

    Network = (PCNETWORK)hNetwork;
    Cluster = (PCLUSTER)Network->Cluster;

    //
    // Unlink network from cluster list.
    //
    EnterCriticalSection(&Cluster->Lock);
    RemoveEntryList(&Network->ListEntry);

    //
    // Remove any notifications posted against this network.
    //
    RundownNotifyEvents(&Network->NotifyList, Network->Name);

    //if the cluster is dead and the reconnect has failed,
    //the Network->hNetwork might be NULL if s_apiopennetinterface for
    //this network failed on a reconnect
    //the cluster may be dead and hinterface may be non null, say
    //if reconnectnetworks succeeded but say the reconnectgroups
    //failed
    // At reconnect, the old context is saved in the obsolete 
    // list for deletion when the cluster handle is closed or when 
    // the next call is made
    if ((Cluster->Flags & CLUS_DEAD) && (Network->hNetwork)) 
    {
        RpcSmDestroyClientContext(&Network->hNetwork);
        LeaveCriticalSection(&Cluster->Lock);
        goto FnExit;
    }  
    
    LeaveCriticalSection(&Cluster->Lock);

    //
    // Close RPC context handle
    //
    ApiCloseNetwork(&Network->hNetwork);

FnExit:
    //
    // Free memory allocations
    //
    LocalFree(Network->Name);
    LocalFree(Network);

    //
    // Give the cluster a chance to clean up in case this
    // network was the only thing keeping it around.
    //
    CleanupCluster(Cluster);
    return(TRUE);
}


CLUSTER_NETWORK_STATE
WINAPI
GetClusterNetworkState(
    IN HNETWORK hNetwork
    )

/*++

Routine Description:

    Returns the network's current state

Arguments:

    hNetwork - Supplies a handle to a cluster network

Return Value:

    Returns the current state of the network.
    If the function fails, the return value is -1. Extended error
    status is available using GetLastError()

--*/

{
    PCNETWORK Network;
    CLUSTER_NETWORK_STATE State;
    DWORD Status;

    Network = (PCNETWORK)hNetwork;

    WRAP(Status,
         (ApiGetNetworkState( Network->hNetwork,
                              (LPDWORD)&State )),  // cast for win64 warning
         Network->Cluster);

    if (Status == ERROR_SUCCESS) {

        return(State);
    } else {

        SetLastError(Status);
        return( ClusterNetworkStateUnknown );
    }
}


DWORD
WINAPI
SetClusterNetworkName(
    IN HNETWORK hNetwork,
    IN LPCWSTR lpszNetworkName
    )
/*++

Routine Description:

    Sets the friendly name of a cluster network

Arguments:

    hNetwork - Supplies a handle to a cluster network

    lpszNetworkName - Supplies the new name of the cluster network

    cchName - ?

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCNETWORK Network;
    DWORD Status;

    Network = (PCNETWORK)hNetwork;

    WRAP(Status,
         (ApiSetNetworkName(Network->hNetwork, lpszNetworkName)),
         Network->Cluster);

    return(Status);
}


DWORD
WINAPI
GetClusterNetworkId(
    IN HNETWORK hNetwork,
    OUT LPWSTR lpszNetworkId,
    IN OUT LPDWORD lpcchName
    )
/*++

Routine Description:

    Returns the unique identifier of the specified network

Arguments:

    hNetwork - Supplies the network whose unique ID is to be returned.

    lpszNetworkId - Points to a buffer that receives the unique ID of the object,
            including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters
            of the buffer pointed to by the lpszNetworkId parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to be lpcchName contains the number
            of characters stored in the buffer. The count returned does not
            include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD Length;
    PCNETWORK Network = (PCNETWORK)hNetwork;
    LPWSTR Guid=NULL;

    WRAP(Status,
         (ApiGetNetworkId(Network->hNetwork,
                          &Guid)),
         Network->Cluster);

    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    MylstrcpynW(lpszNetworkId, Guid, *lpcchName);
    Length = lstrlenW(Guid);

    if (Length >= *lpcchName) {
        if (lpszNetworkId == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    }

    *lpcchName = Length;
    MIDL_user_free(Guid);

    return(Status);
}


HNETWORKENUM
WINAPI
ClusterNetworkOpenEnum(
    IN HNETWORK hNetwork,
    IN DWORD dwType
    )

/*++

Routine Description:

    Initiates an enumeration of the existing cluster network objects.

Arguments:

    hNetwork - Supplies a handle to the specific network.

    dwType - Supplies a bitmask of the type of properties to be
             enumerated.

Return Value:

    If successful, returns a handle suitable for use with ClusterNetworkEnum

    If unsuccessful, returns NULL and GetLastError() returns a more
        specific error code.

--*/

{
    PCNETWORK Network = (PCNETWORK)hNetwork;
    PENUM_LIST Enum = NULL;
    DWORD errorStatus;

    //
    // validate bitmask
    //

    if ((dwType & CLUSTER_NETWORK_ENUM_ALL) == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    if ((dwType & ~CLUSTER_NETWORK_ENUM_ALL) != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    //
    // open connection to service for enum'ing
    //

    WRAP(errorStatus,
         (ApiCreateNetworkEnum(Network->hNetwork,
                               dwType,
                               &Enum)),
         Network->Cluster);

    if (errorStatus != ERROR_SUCCESS) {

        SetLastError(errorStatus);
        return(NULL);
    }

    return((HNETWORKENUM)Enum);
}


DWORD
WINAPI
ClusterNetworkGetEnumCount(
    IN HNETWORKENUM hNetworkEnum
    )
/*++

Routine Description:

    Gets the number of items contained the the enumerator's collection.

Arguments:

    hEnum - a handle to an enumerator returned by ClusterNetworkOpenEnum.

Return Value:

    The number of items (possibly zero) in the enumerator's collection.
    
--*/
{
    PENUM_LIST Enum = (PENUM_LIST)hNetworkEnum;
    return Enum->EntryCount;
}


DWORD
WINAPI
ClusterNetworkEnum(
    IN HNETWORKENUM hNetworkEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )

/*++

Routine Description:

    Returns the next enumerable resource object.

Arguments:

    hNetworkEnum - Supplies a handle to an open cluster network enumeration
            returned by ClusterNetworkOpenEnum

    dwIndex - Supplies the index to enumerate. This parameter should be
            zero for the first call to the ClusterEnum function and then
            incremented for subsequent calls.

    lpdwType - Returns the type of network.

    lpszName - Points to a buffer that receives the name of the network
            object, including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszName parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to by lpcchName contains the
            number of characters stored in the buffer. The count returned
            does not include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD NameLen;
    PENUM_LIST Enum = (PENUM_LIST)hNetworkEnum;

    if (dwIndex >= Enum->EntryCount) {
        return(ERROR_NO_MORE_ITEMS);
    }

    NameLen = lstrlenW( Enum->Entry[dwIndex].Name );

    MylstrcpynW(lpszName, Enum->Entry[dwIndex].Name, *lpcchName);

    if (*lpcchName < (NameLen + 1)) {
        if (lpszName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {
        Status = ERROR_SUCCESS;
    }

    *lpdwType = Enum->Entry[dwIndex].Type;
    *lpcchName = NameLen;

    return(Status);
}


DWORD
WINAPI
ClusterNetworkCloseEnum(
    IN HNETWORKENUM hNetworkEnum
    )

/*++

Routine Description:

    Closes an open enumeration for a network.

Arguments:

    hNetworkEnum - Supplies a handle to the enumeration to be closed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD i;
    PENUM_LIST Enum = (PENUM_LIST)hNetworkEnum;

    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
    }
    MIDL_user_free(Enum);
    return(ERROR_SUCCESS);
}


HCLUSTER
WINAPI
GetClusterFromNetwork(
    IN HNETWORK hNetwork
    )
/*++

Routine Description:

    Returns the cluster handle from the associated network handle.

Arguments:

    hNetwork - Supplies the network.

Return Value:

    Handle to the cluster associated with the network handle.

--*/

{
    DWORD       nStatus;
    PCNETWORK   Network = (PCNETWORK)hNetwork;
    HCLUSTER    hCluster = (HCLUSTER)Network->Cluster;

    nStatus = AddRefToClusterHandle( hCluster );
    if ( nStatus != ERROR_SUCCESS ) {
        SetLastError( nStatus );
        hCluster = NULL;
    }
    return( hCluster );

} // GetClusterFromNetwork()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\intrface.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    intrface.c

Abstract:

    Provides interface for managing cluster netinterfaces

Author:

    John Vert (jvert) 30-Jan-1996
    Charlie Wickham (charlwi) 5-Jun-1997
    Rod Gamache (rodga) 9-Jun-1997

Revision History:
    copied from network.c

--*/

#include "clusapip.h"


HNETINTERFACE
WINAPI
OpenClusterNetInterface(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszInterfaceName
    )

/*++

Routine Description:

    Opens a handle to the specified network interface

Arguments:

    hCluster - Supplies a handle to the cluster

    lpszInterfaceName - Supplies the name of the netinterface to be opened

Return Value:

    non-NULL - returns an open handle to the specified netinterface.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    PCNETINTERFACE NetInterface;
    error_status_t Status = ERROR_SUCCESS;

    //
    // get a pointer to the cluster struct, allocate space for the netinterface
    // structure and the supplied name.
    //

    Cluster = (PCLUSTER)hCluster;

    NetInterface = LocalAlloc(LMEM_FIXED, sizeof(CNETINTERFACE));
    if (NetInterface == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    NetInterface->Name = LocalAlloc(LMEM_FIXED, (lstrlenW(lpszInterfaceName)+1)*sizeof(WCHAR));
    if (NetInterface->Name == NULL) {
        LocalFree(NetInterface);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    // init the netinterface struct and call clussvc to open the netinterface
    //

    lstrcpyW(NetInterface->Name, lpszInterfaceName);
    NetInterface->Cluster = Cluster;
    InitializeListHead(&NetInterface->NotifyList);

    WRAP_NULL(NetInterface->hNetInterface,
              (ApiOpenNetInterface(Cluster->RpcBinding,
                                   lpszInterfaceName,
                                   &Status)),
              &Status,
              Cluster);

    if ((NetInterface->hNetInterface == NULL) || (Status != ERROR_SUCCESS)) {

        LocalFree(NetInterface->Name);
        LocalFree(NetInterface);
        SetLastError(Status);
        return(NULL);
    }

    //
    // Link newly opened netinterface onto the cluster structure.
    //

    EnterCriticalSection(&Cluster->Lock);
    InsertHeadList(&Cluster->NetInterfaceList, &NetInterface->ListEntry);
    LeaveCriticalSection(&Cluster->Lock);

    return ((HNETINTERFACE)NetInterface);
}


BOOL
WINAPI
CloseClusterNetInterface(
    IN HNETINTERFACE hNetInterface
    )

/*++

Routine Description:

    Closes a network interface handle returned from OpenClusterNetInterface

Arguments:

    hNetInterface - Supplies the netinterface handle

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCNETINTERFACE NetInterface;
    PCLUSTER Cluster;

    NetInterface = (PCNETINTERFACE)hNetInterface;
    Cluster = (PCLUSTER)NetInterface->Cluster;

    //
    // Unlink netinterface from cluster list.
    //
    EnterCriticalSection(&Cluster->Lock);
    RemoveEntryList(&NetInterface->ListEntry);

    //
    // Remove any notifications posted against this netinterface.
    //
    RundownNotifyEvents(&NetInterface->NotifyList, NetInterface->Name);

    //if the cluster is dead and the reconnect has failed,
    //the group->hnetinterface might be NULL if s_apiopennetinterface for
    //this group failed on a reconnect
    //the cluster may be dead and hinterface may be non null, say
    //if reconnectnetinterfaces succeeded but say the reconnect networks
    //failed
    // At reconnect, the old context is saved in the obsolete 
    // list for deletion when the cluster handle is closed or when 
    // the next call is made
    if ((Cluster->Flags & CLUS_DEAD) && (NetInterface->hNetInterface))
    {
        RpcSmDestroyClientContext(&NetInterface->hNetInterface);
        LeaveCriticalSection(&Cluster->Lock);
        goto FnExit;
    }        

    LeaveCriticalSection(&Cluster->Lock);

    //
    // Close RPC context handle
    //
    ApiCloseNetInterface(&NetInterface->hNetInterface);

FnExit:
    //
    // Free memory allocations
    //
    LocalFree(NetInterface->Name);
    LocalFree(NetInterface);

    //
    // Give the cluster a chance to clean up in case this
    // netinterface was the only thing keeping it around.
    //
    CleanupCluster(Cluster);
    return(TRUE);
}


CLUSTER_NETINTERFACE_STATE
WINAPI
GetClusterNetInterfaceState(
    IN HNETINTERFACE hNetInterface
    )

/*++

Routine Description:

    Returns the network interface's current state

Arguments:

    hNetInterface - Supplies a handle to a cluster netinterface

Return Value:

    Returns the current state of the network interface.
    If the function fails, the return value is -1. Extended error
    status is available using GetLastError()

--*/

{
    PCNETINTERFACE NetInterface;
    CLUSTER_NETINTERFACE_STATE State;
    DWORD Status;

    NetInterface = (PCNETINTERFACE)hNetInterface;

    WRAP(Status,
         (ApiGetNetInterfaceState( NetInterface->hNetInterface,
                              (LPDWORD)&State )),    // cast for win64 warning
         NetInterface->Cluster);

    if (Status == ERROR_SUCCESS) {

        return(State);
    } else {

        SetLastError(Status);
        return( ClusterNetInterfaceStateUnknown );
    }
}


DWORD
WINAPI
GetClusterNetInterface(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszNodeName,
    IN LPCWSTR lpszNetworkName,
    OUT LPWSTR lpszInterfaceName,
    IN OUT LPDWORD lpcchInterfaceName
    )
/*++

Routine Description:

    Gets the name of a node's interface to a network in the cluster.

Arguments:

    hCluster - Supplies a handle to the cluster

    lpszNodeName - Supplies the node name of the node in the cluster

    lpszNetworkName - Supplies the name of the cluster network

    lpszInterfaceName - Returns the name of the network interface

    lpcchInterfaceName - Points to a variable that specifies the size, in
            characters, of the buffer pointed to by the lpszInterfaceName
            parameter. This size should include the terminating null
            character. When the function returns, the variable pointed to
            by lpcchInterfaceName contains the number of characters that
            would be stored in the buffer if it were large enough. The count
            returned does not include the terminating null character.

Return Value:

     If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD Length;
    PCLUSTER Cluster;
    LPWSTR Name = NULL;

    Cluster = GET_CLUSTER(hCluster);

    WRAP(Status,
         (ApiGetNetInterface(Cluster->RpcBinding,
                             lpszNodeName,
                             lpszNetworkName,
                             &Name)),
         Cluster);

    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    MylstrcpynW(lpszInterfaceName, Name, *lpcchInterfaceName);
    Length = lstrlenW(Name);

    if (*lpcchInterfaceName < (Length + 1)) {
        if (lpszInterfaceName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    }

    *lpcchInterfaceName = Length;
    MIDL_user_free(Name);

    return(Status);
}


HCLUSTER
WINAPI
GetClusterFromNetInterface(
    IN HNETINTERFACE hNetInterface
    )
/*++

Routine Description:

    Returns the cluster handle from the associated network interface handle.

Arguments:

    hNetInterface - Supplies the network interface.

Return Value:

    Handle to the cluster associated with the network interface handle.

--*/

{
    DWORD           nStatus;
    PCNETINTERFACE  NetInterface = (PCNETINTERFACE)hNetInterface;
    HCLUSTER        hCluster = (HCLUSTER)NetInterface->Cluster;

    nStatus = AddRefToClusterHandle( hCluster );
    if ( nStatus != ERROR_SUCCESS ) {
        SetLastError( nStatus );
        hCluster = NULL;
    }
    return( hCluster );

} // GetClusterFromNetInterface()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\nodeapi.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    nodeapi.c

Abstract:

    Public interfaces for managing cluster nodes.

Author:

    John Vert (jvert) 15-Jan-1996

Revision History:

--*/
#include "clusapip.h"


//
// Cluster Node Management Routines.
//


HNODE
WINAPI
OpenClusterNode(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszNodeName
    )

/*++

Routine Description:

    Opens an individual node in the cluster.

Arguments:

    hCluster - Supplies a cluster handle returned from OpenCluster.

    lpszNodeName - Supplies the name of the individual node to open.

Return Value:

    non-NULL - returns an open handle to the specified cluster.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    PCNODE Node;
    error_status_t Status = ERROR_SUCCESS;

    Cluster = (PCLUSTER)hCluster;
    Node = LocalAlloc(LMEM_FIXED, sizeof(CNODE));
    if (Node == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    Node->Name = LocalAlloc(LMEM_FIXED, (lstrlenW(lpszNodeName)+1)*sizeof(WCHAR));
    if (Node->Name == NULL) {
        LocalFree(Node);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    lstrcpyW(Node->Name, lpszNodeName);
    Node->Cluster = Cluster;
    InitializeListHead(&Node->NotifyList);
    WRAP_NULL(Node->hNode,
              (ApiOpenNode(Cluster->RpcBinding,
                           lpszNodeName,
                           &Status)),
              &Status,
              Cluster);
    if ((Node->hNode == NULL) || (Status != ERROR_SUCCESS)) {
        LocalFree(Node->Name);
        LocalFree(Node);
        SetLastError(Status);
        return(NULL);
    }

    //
    // Link newly opened Node onto the cluster structure.
    //
    EnterCriticalSection(&Cluster->Lock);
    InsertHeadList(&Cluster->NodeList, &Node->ListEntry);
    LeaveCriticalSection(&Cluster->Lock);

    return((HNODE)Node);

}


BOOL
WINAPI
CloseClusterNode(
    IN HNODE hNode
    )

/*++

Routine Description:

    Closes a handle to an individual cluster node

Arguments:

    hNode - Supplies the cluster node to be closed

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError()

--*/

{

    PCNODE Node;
    PCLUSTER Cluster;

    Node = (PCNODE)hNode;
    Cluster = (PCLUSTER)Node->Cluster;

    //
    // Unlink node from cluster list.
    //
    EnterCriticalSection(&Cluster->Lock);
    RemoveEntryList(&Node->ListEntry);

    //
    // Remove any notifications posted against this resource.
    //
    RundownNotifyEvents(&Node->NotifyList, Node->Name);

    //if the cluster is dead and the reconnect has failed,
    //the Node->hNode might be NULL if s_apiopennode for
    //this node failed on a reconnect
    //the cluster may be dead and hNode may be non null, say
    //if reconnectnodes succeeded but the reconnectnetworks
    //failed
    // At reconnect, the old context is saved in the obsolete
    // list for deletion when the cluster handle is closed
    if ((Cluster->Flags & CLUS_DEAD) && (Node->hNode)) {
        RpcSmDestroyClientContext(&Node->hNode);
        LeaveCriticalSection(&Cluster->Lock);
        goto FnExit;
    }
    LeaveCriticalSection(&Cluster->Lock);

    //
    // Close RPC context handle
    //
    ApiCloseNode(&Node->hNode);

FnExit:
    //
    // Free memory allocations
    //
    LocalFree(Node->Name);
    LocalFree(Node);

    //
    // Give the cluster a chance to clean up in case this
    // node was the only thing keeping it around.
    //
    CleanupCluster(Cluster);
    return(TRUE);

}

#undef GetCurrentClusterNodeId


DWORD
GetCurrentClusterNodeId(
    OUT LPWSTR lpszNodeId,
    IN OUT LPDWORD lpcchName
    )
/*++

Routine Description:

    Returns the node identifier of the current node. This function
    is only available on a node that is currently online and a member
    of a cluster.

Arguments:

    lpszNodeId - Points to a buffer that receives the unique ID of the object,
            including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters
            of the buffer pointed to by the lpszNodeId parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to be lpcchName contains the number
            of characters stored in the buffer. The count returned does not
            include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/
{
    HCLUSTER Cluster;
    HNODE CurrentNode;
    DWORD Status;

    Cluster = OpenCluster(NULL);
    if (Cluster == NULL) {
        return(GetLastError());
    }

    CurrentNode = OpenClusterNode(Cluster,
                                  ((PCLUSTER)Cluster)->NodeName);
    if (CurrentNode != NULL) {

        Status = GetClusterNodeId(CurrentNode,
                                  lpszNodeId,
                                  lpcchName);
        CloseClusterNode(CurrentNode);
    }
    else
    {
        Status = GetLastError();
    }
    CloseCluster(Cluster);
    return(Status);
}


DWORD
WINAPI
GetClusterNodeId(
    IN HNODE hNode,
    OUT LPWSTR lpszNodeId,
    IN OUT LPDWORD lpcchName
    )
/*++

Routine Description:

    Returns the unique identifier of the specified node

Arguments:

    hNode - Supplies the node whose unique ID is to be returned.

    lpszNodeId - Points to a buffer that receives the unique ID of the object,
            including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters
            of the buffer pointed to by the lpszNodeId parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to be lpcchName contains the number
            of characters stored in the buffer. The count returned does not
            include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD Length;
    PCNODE Node = (PCNODE)hNode;
    LPWSTR Guid=NULL;

    if (Node == NULL) {
        return(GetCurrentClusterNodeId(lpszNodeId, lpcchName));
    }

    WRAP(Status,
         (ApiGetNodeId(Node->hNode,
                       &Guid)),
         Node->Cluster);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    MylstrcpynW(lpszNodeId, Guid, *lpcchName);
    Length = lstrlenW(Guid);
    if (Length >= *lpcchName) {
        if (lpszNodeId == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    }
    *lpcchName = Length;
    MIDL_user_free(Guid);
    return(Status);
}


CLUSTER_NODE_STATE
WINAPI
GetClusterNodeState(
    IN HNODE hNode
    )

/*++

Routine Description:

    Returns the current state of a cluster node.

Arguments:

    hNode - Supplies the cluster node whose current state is to be returned

Return Value:

    The current state of the cluster node. Currently defined node states
    include:

        ClusterNodeUp
        ClusterNodeDown
        ClusterNodePaused

--*/

{
    DWORD Status;
    CLUSTER_NODE_STATE State;
    PCNODE Node = (PCNODE)hNode;

    WRAP(Status,
         (ApiGetNodeState(Node->hNode, (LPDWORD)&State)),
         Node->Cluster);
    if (Status == ERROR_SUCCESS) {
        return(State);
    } else {
        SetLastError(Status);
        return(ClusterNodeStateUnknown);
    }
}



DWORD
WINAPI
PauseClusterNode(
    IN HNODE hNode
    )

/*++

Routine Description:

    Requests that a node pauses its cluster activity.

Arguments:

    hNode - Supplies a handle to the node to leave its cluster.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PCNODE Node = (PCNODE)hNode;

    WRAP(Status,
         (ApiPauseNode(Node->hNode)),
         Node->Cluster);
    return(Status);
}



DWORD
WINAPI
ResumeClusterNode(
    IN HNODE hNode
    )

/*++

Routine Description:

    Requests that a node resume cluster activity, after it had been paused.

Arguments:

    hNode - Supplies a handle to the node to resume its cluster activity.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PCNODE Node = (PCNODE)hNode;

    WRAP(Status,
         (ApiResumeNode(Node->hNode)),
         Node->Cluster);
    return(Status);
}



DWORD
WINAPI
EvictClusterNode(
    IN HNODE hNode
    )

/*++

Routine Description:

    Evict the specified Node from the list of nodes in the permanent cluster
    database (registry).

Arguments:

    hNode - Supplies a handle to the node to remove from the list of cluster
            nodes.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PCNODE Node = (PCNODE)hNode;

    WRAP(Status,
         (ApiEvictNode(Node->hNode)),
         Node->Cluster);
    return(Status);
}


DWORD
WINAPI
EvictClusterNodeEx(
    IN HNODE hNode,
    IN DWORD dwTimeout,
    OUT HRESULT* phrCleanupStatus
    )

/*++

Routine Description:

    Evict the specified node from the list of nodes in the permanent cluster
    database (registry) and initate the cleanup(unconfiguration) process on the
    cluster node.  Note that if the node is down, the clean up process will not
    occur.  However, when the node comes up, clustering will detect that the
    node was supposed to be evicted and it will unconfigure itself.


Arguments:

    IN HNODE hNode - Supplies a handle to the node to remove from the list of cluster
            nodes.

    IN DWORD dwTimeOut - Timeout in milliseconds for the cleanup(unconfiguration
        of clustering) to complete. If the cleanup doesnt complete
        in the given amount of time, the function will return.

    OUT phrCleanupStatus - The status of cleanup is returned.


Return Value:

    Returns the status of the eviction and not of cleanup.

    ERROR_SUCCESS if successful

    ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP if eviction succeeded but cleanup returned
        an error.  The phrCleanupStatus param will contain more information about
        the cleanup error. (Usually this will be RPC_S_CALL_FAILED.)

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PCNODE Node = (PCNODE)hNode;
    HRESULT hr = E_ABORT;

    WRAP(Status,
         (ApiEvictNode(Node->hNode)),
         Node->Cluster);

    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }

    //
    //  Any error after this is not "fatal".  The node has been evicted
    //  but the cleanup may fail for numerous reasons.
    //
    hr = ClRtlAsyncCleanupNode(Node->Name, 0, dwTimeout);
    if (FAILED(hr)) {
        Status = ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP;
    }

  FnExit:

    if (phrCleanupStatus != NULL) {
        *phrCleanupStatus = hr;
    }

    return(Status);

} // EvictClusterNodeEx()


HCLUSTER
WINAPI
GetClusterFromNode(
    IN HNODE hNode
    )
/*++

Routine Description:

    Returns the cluster handle from the associated node handle.

Arguments:

    hNode - Supplies the node.

Return Value:

    Handle to the cluster associated with the node handle.

--*/

{
    DWORD       nStatus;
    PCNODE      Node = (PCNODE)hNode;
    HCLUSTER    hCluster = (HCLUSTER)Node->Cluster;

    nStatus = AddRefToClusterHandle( hCluster );
    if ( nStatus != ERROR_SUCCESS ) {
        SetLastError( nStatus );
        hCluster = NULL;
    }
    return( hCluster );

} // GetClusterFromNode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\reconect.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    reconnect.c

Abstract:

    Implements the support to enable the cluster API to transparently reconnect
    to a cluster when the node that the connection was made to fails.

    This module contains wrappers for all the cluster RPC interfaces defined in
    api_rpc.idl. These wrappers filter out communication errors and attempt to
    reconnect to the cluster when a communication error occurs. This allows the
    caller to be completely ignorant of any node failures.

Author:

    John Vert (jvert) 9/24/1996

Revision History:

--*/
#include "clusapip.h"

//
// Local function prototypes
//

DWORD
ReconnectKeys(
    IN PCLUSTER Cluster
    );

DWORD
ReopenKeyWorker(
    IN PCKEY Key
    );

DWORD
ReconnectResources(
    IN PCLUSTER Cluster
    );

DWORD
ReconnectGroups(
    IN PCLUSTER Cluster
    );

DWORD
ReconnectNodes(
    IN PCLUSTER Cluster
    );

DWORD
ReconnectNetworks(
    IN PCLUSTER Cluster
    );

DWORD
ReconnectNetInterfaces(
    IN PCLUSTER Cluster
    );

DWORD
ReconnectNotifySessions(
    IN PCLUSTER Cluster
    );

DWORD
ReconnectCandidate(
    IN PCLUSTER Cluster,
    IN DWORD dwIndex,
    OUT PBOOL pIsContinue
);



DWORD
ReconnectCluster(
    IN PCLUSTER Cluster,
    IN DWORD Error,
    IN DWORD Generation
    )
/*++

Routine Description:

    Attempts to reconnect to the specified cluster. The supplied
    error code is checked against RPC errors that indicate the
    server on the other end is unavailable. If it matches, a
    reconnect is attempted.

Arguments:

    Cluster - Supplies the cluster.

    Error - Supplies the error returned from RPC.

    Generation - Supplies the cluster connection generation that
        was in effect when the error occurred.

Return Value:

    ERROR_SUCCESS if the reconnect was successful and the RPC should
                  be retried

    Win32 error code otherwise.

--*/

{
    //
    // filter out all RPC errors that might indicate the connection
    // has dropped.
    //
    switch (Error) {
        case RPC_S_CALL_FAILED:
        case ERROR_INVALID_HANDLE:
        case RPC_S_INVALID_BINDING:
        case RPC_S_SERVER_UNAVAILABLE:
        case RPC_S_SERVER_TOO_BUSY:
        case RPC_S_UNKNOWN_IF:
        case RPC_S_CALL_FAILED_DNE:
        case RPC_X_SS_IN_NULL_CONTEXT:
        case ERROR_CLUSTER_NODE_SHUTTING_DOWN:
        case EPT_S_NOT_REGISTERED:
        case ERROR_CLUSTER_NODE_NOT_READY:
        case RPC_S_UNKNOWN_AUTHN_SERVICE:
            TIME_PRINT(("Reconnect Cluster - reconnecting on Error %d\n",Error));
            break;

        default:

            //
            // Anything else we don't know how to deal with, so return
            // the error directly.
            //
            return(Error);
    }

    //
    // Attempt to reconnect the cluster.
    //
    if ((Cluster->Flags & CLUS_DEAD) ||
        (Cluster->Flags & CLUS_LOCALCONNECT)) {
        //
        // Don't bother trying to reconnect. Either we've already
        // declared the cluster dead, or the connection was over
        // LPC (to the local machine) and we do not necessarily want
        // to try to reconnect.
        //
        if (Cluster->Flags & CLUS_LOCALCONNECT)
            Cluster->Flags |= CLUS_DEAD;
        TIME_PRINT(("ReconnectCluster - Cluster dead or local, giving up - error %d\n",Error));
        return(Error);
    }
    if (Generation < Cluster->Generation) {
        //
        // We have already successfully reconnected since the error occurred,
        // so retry immediately.
        //
        TIME_PRINT(("ReconnectCluster - Generation %d < Current %d, retrying\n",
                  Generation,
                  Cluster->Generation));
        return(ERROR_SUCCESS);
    }
    EnterCriticalSection(&Cluster->Lock);

    //
    // Check again for cluster death, in case the previous owner
    // of the lock declared the cluster dead.
    //
    if (Cluster->Flags & CLUS_DEAD) {
        TIME_PRINT(("ReconnectCluster - Cluster dead or local, giving up - error %d\n",Error));
        LeaveCriticalSection(&Cluster->Lock);
        return(Error);
    }

    if (Generation < Cluster->Generation) {
        //
        // We have already reconnected since the error occurred,
        // so retry immediately.
        //
        Error = ERROR_SUCCESS;
        TIME_PRINT(("ReconnectCluster - Generation %d < Current %d, retrying\n",
                  Generation,
                  Cluster->Generation));
    } else {
        DWORD i, CurrentConnectionIndex = -1;
        BOOL  IsContinue = TRUE;
        
        for (i=0; i<Cluster->ReconnectCount; i++) {

            if (Cluster->Reconnect[i].IsCurrent) {
                //
                // This is something we've already connected to and
                // it's obviously gone, so skip this node.
                //
                TIME_PRINT(("ReconnectCluster - skipping current %ws\n",
                          Cluster->Reconnect[i].Name));
                CurrentConnectionIndex = i;
                continue;
            }
            if (!Cluster->Reconnect[i].IsUp) {
                //
                // skip this candidate, it is not up.
                //
                // BUGBUG John Vert (jvert) 11/14/1996
                //   We could do another pass through the list if all
                //   the nodes that we think are up fail.
                //
                TIME_PRINT(("ReconnectCluster - skipping down node %ws\n",
                          Cluster->Reconnect[i].Name));
                continue;
            }

            //
            // Chittur Subbaraman (chitturs) - 08/29/1998
            //
            // Try to reconnect to the cluster using a candidate
            //
            
            Error = ReconnectCandidate ( Cluster, i, &IsContinue );
            if (Error == ERROR_SUCCESS) {
                // 
                // Chittur Subbaraman (chitturs) - 08/29/1998
                //
                // Break out of the loop and return if you
                // succeed in reconnecting 
                //
                break;
            } 
            if (IsContinue == FALSE) {
                //
                // Chittur Subbaraman (chitturs) - 08/29/1998
                //
                // Exit immediately if you encounter an error
                // that will not let you proceed any further
                //
                TIME_PRINT(("ReconnectCluster unable to continue - Exiting with code %d\n", Error));
                goto error_exit;
            }
        }
        
        if (Error != ERROR_SUCCESS) {
            // 
            // Chittur Subbaraman (chitturs) - 08/29/98
            //
            // Try reconnecting with the current candidate (which
            // you skipped before), if the CurrentConnectionIndex 
            // is valid and the party is up. This is required
            // in the case of a 1 node cluster in which the
            // client takes the cluster group offline. In this
            // case, the current candidate (i.e., the node) is
            // valid and the client should be able to retry and
            // reconnect to the node.
            //
            if ((CurrentConnectionIndex != -1) &&
                (Cluster->Reconnect[CurrentConnectionIndex].IsUp)) {

                Error = ReconnectCandidate (Cluster, 
                                             CurrentConnectionIndex, 
                                             &IsContinue); 
                if ((Error != ERROR_SUCCESS) &&
                    (IsContinue == FALSE)) {
                       //
                    // Chittur Subbaraman (chitturs) - 08/29/1998
                    //
                    // Exit immediately if you encounter an error
                    // that will not let you proceed any further
                    //  
                    TIME_PRINT(("ReconnectCluster - unable to continue for current party %ws - Exiting with code %d\n", 
                                Cluster->Reconnect[CurrentConnectionIndex].Name, Error));
                    goto error_exit;
                }
            } else {
                TIME_PRINT(("ReconnectCluster - unable to retry for current party %ws - Error %d\n", 
                             Cluster->Reconnect[CurrentConnectionIndex].Name, Error));
            }
            
            if (Error != ERROR_SUCCESS) {
                TIME_PRINT(("ReconnectCluster - all reconnects failed, giving up - error %d\n", Error));     
                Cluster->Flags |= CLUS_DEAD;
            }
        }
    }
error_exit:
    LeaveCriticalSection(&Cluster->Lock);
    return(Error);
}


DWORD
ReconnectKeys(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster registry keys after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCKEY Key;
    DWORD Status;

    ListEntry = Cluster->KeyList.Flink;
    while (ListEntry != &Cluster->KeyList) {

        //
        // Each key in the cluster's list represents the
        // root of a registry tree.
        //
        Key = CONTAINING_RECORD(ListEntry,
                                CKEY,
                                ParentList);
        ListEntry = ListEntry->Flink;

        Status = ReopenKeyWorker(Key);
        if (Status != ERROR_SUCCESS) {
            return(Status);
        }
    }

    return(ERROR_SUCCESS);
}


DWORD
ReopenKeyWorker(
    IN PCKEY Key
    )
/*++

Routine Description:

    Recursive worker routine for opening a key and all its children.

Arguments:

    Key - Supplies the root key to reopen.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCKEY Child;
    DWORD Status = ERROR_GEN_FAILURE;
    BOOL CloseAfterOpen;

    if (Key->RemoteKey != NULL) {
        //
        // Destroy the old context
        //
        Status = MyRpcSmDestroyClientContext(Key->Cluster, &Key->RemoteKey);
        if (Status != ERROR_SUCCESS) {
            TIME_PRINT(("ReopenKeyWorker - RpcSmDestroyClientContext failed Error %d\n",Status));
        }
        CloseAfterOpen = FALSE;
    } else {
        CloseAfterOpen = TRUE;
    }

    //
    // Next, reopen this key.
    //
    if (Key->Parent == NULL) {
        Key->RemoteKey = ApiGetRootKey(Key->Cluster->RpcBinding,
                                       Key->SamDesired,
                                       &Status);
    } else {
        Key->RemoteKey = ApiOpenKey(Key->Parent->RemoteKey,
                                    Key->RelativeName,
                                    Key->SamDesired,
                                    &Status);
    }
    if (Key->RemoteKey == NULL) {
        return(Status);
    }

    //
    // Now open all this keys children recursively.
    //
    ListEntry = Key->ChildList.Flink;
    while (ListEntry != &Key->ChildList) {
        Child = CONTAINING_RECORD(ListEntry,
                                  CKEY,
                                  ParentList);
        ListEntry = ListEntry->Flink;

        Status = ReopenKeyWorker(Child);
        if (Status != ERROR_SUCCESS) {
            return(Status);
        }
    }

    //
    // If the key had been closed and was just kept around to do the reopens, close it
    // now as the reopens are done.
    //
    if (CloseAfterOpen) {
        ApiCloseKey(&Key->RemoteKey);
    }

    return(ERROR_SUCCESS);
}


DWORD
ReconnectResources(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster resources after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCRESOURCE Resource;
    DWORD Status;

    ListEntry = Cluster->ResourceList.Flink;
    while (ListEntry != &Cluster->ResourceList) {
        Resource = CONTAINING_RECORD(ListEntry,
                                     CRESOURCE,
                                     ListEntry);
        ListEntry = ListEntry->Flink;

        //
        // Close the current RPC handle.
        //
        TIME_PRINT(("ReconnectResources - destroying context %08lx\n",Resource->hResource));
        Status = MyRpcSmDestroyClientContext(Cluster, &Resource->hResource);
        if (Status != ERROR_SUCCESS) {
            TIME_PRINT(("ReconnectResources - RpcSmDestroyClientContext failed Error %d\n",Status));
        }

        //
        // Open a new RPC handle.
        //
        Resource->hResource = ApiOpenResource(Cluster->RpcBinding,
                                              Resource->Name,
                                              &Status);
        if (Resource->hResource == NULL) {
            TIME_PRINT(("ReconnectResources: failed to reopen resource %ws\n",Resource->Name));
            return(Status);
        }
    }

    return(ERROR_SUCCESS);
}

DWORD
ReconnectGroups(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster groups after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCGROUP Group;
    DWORD Status;

    ListEntry = Cluster->GroupList.Flink;
    while (ListEntry != &Cluster->GroupList) {
        Group = CONTAINING_RECORD(ListEntry,
                                  CGROUP,
                                  ListEntry);
        ListEntry = ListEntry->Flink;

        //
        // Close the old RPC handle
        //
        TIME_PRINT(("ReconnectGroups - destroying context %08lx\n",Group->hGroup));
        Status = MyRpcSmDestroyClientContext(Cluster, &Group->hGroup);
        if (Status != ERROR_SUCCESS) {
            TIME_PRINT(("ReconnectGroups - RpcSmDestroyClientContext failed Error %d\n",Status));
        }

        //
        // Open a new RPC handle.
        //
        Group->hGroup = ApiOpenGroup(Cluster->RpcBinding,
                                     Group->Name,
                                     &Status);
        if (Group->hGroup == NULL) {
            return(Status);
        }
    }

    return(ERROR_SUCCESS);
}

DWORD
ReconnectNodes(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster nodes after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCNODE Node;
    DWORD Status;

    ListEntry = Cluster->NodeList.Flink;
    while (ListEntry != &Cluster->NodeList) {
        Node = CONTAINING_RECORD(ListEntry,
                                 CNODE,
                                 ListEntry);
        ListEntry = ListEntry->Flink;

        //
        // Close the old RPC handle.
        //
        TIME_PRINT(("ReconnectNodes - destroying context %08lx\n",Node->hNode));
        Status = MyRpcSmDestroyClientContext(Cluster, &Node->hNode);
        if (Status != ERROR_SUCCESS) {
            TIME_PRINT(("ReconnectNodes - RpcSmDestroyClientContext failed Error %d\n",Status));
        }

        //
        // Open a new RPC handle.
        //
        Node->hNode = ApiOpenNode(Cluster->RpcBinding,
                                  Node->Name,
                                  &Status);
        if (Node->hNode == NULL) {
            return(Status);
        }
    }

    return(ERROR_SUCCESS);
}


DWORD
ReconnectNetworks(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster networks after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCNETWORK Network;
    DWORD Status;

    ListEntry = Cluster->NetworkList.Flink;
    while (ListEntry != &Cluster->NetworkList) {

        Network = CONTAINING_RECORD(ListEntry,
                                    CNETWORK,
                                    ListEntry);
        ListEntry = ListEntry->Flink;

        //
        // Close the old RPC handle.
        //
        TIME_PRINT(("ReconnectNetworks - destroying context %08lx\n",Network->hNetwork));
        Status = MyRpcSmDestroyClientContext(Cluster, &Network->hNetwork);

        if (Status != ERROR_SUCCESS) {
            TIME_PRINT(("ReconnectNetworks - RpcSmDestroyClientContext failed Error %d\n",Status));
        }

        //
        // Open a new RPC handle.
        //
        Network->hNetwork = ApiOpenNetwork(Cluster->RpcBinding,
                                           Network->Name,
                                           &Status);

        if (Network->hNetwork == NULL) {
            return(Status);
        }
    }

    return(ERROR_SUCCESS);
}


DWORD
ReconnectNetInterfaces(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster network interfaces after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCNETINTERFACE NetInterface;
    DWORD Status;

    ListEntry = Cluster->NetInterfaceList.Flink;
    while (ListEntry != &Cluster->NetInterfaceList) {

        NetInterface = CONTAINING_RECORD(ListEntry,
                                         CNETINTERFACE,
                                         ListEntry);
        ListEntry = ListEntry->Flink;

        //
        // Close the old RPC handle.
        //
        TIME_PRINT(("ReconnectNetInterfaces - destroying context %08lx\n",NetInterface->hNetInterface));
        Status = MyRpcSmDestroyClientContext(Cluster, &NetInterface->hNetInterface);

        if (Status != ERROR_SUCCESS) {
            TIME_PRINT(("ReconnectNetInterfaces - RpcSmDestroyClientContext failed Error %d\n",Status));
        }

        //
        // Open a new RPC handle.
        //
        NetInterface->hNetInterface = ApiOpenNetInterface(Cluster->RpcBinding,
                                                          NetInterface->Name,
                                                          &Status);

        if (NetInterface->hNetInterface == NULL) {
            return(Status);
        }
    }

    return(ERROR_SUCCESS);
}


DWORD
ReconnectNotifySessions(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster notify sessions after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry, NotifyListEntry;
    PCNOTIFY_SESSION Session;
    DWORD Status;
    PCNOTIFY_PACKET Packet = NULL;
    PLIST_ENTRY EventEntry;
    PCNOTIFY_EVENT NotifyEvent;
    LPCWSTR Name;

    
    ListEntry = Cluster->SessionList.Flink;
    while (ListEntry != &Cluster->SessionList) {
        Session = CONTAINING_RECORD(ListEntry,
                                    CNOTIFY_SESSION,
                                    ClusterList);
        ListEntry = ListEntry->Flink;

        //
        // Close the old RPC handle.
        //
        TIME_PRINT(("ReconnectNotifySessions - destroying context 0x%08lx\n",Session->hNotify));
        //close the old port, since the reconnect may connect to the same
        //node again
        Status = ApiCloseNotify(&Session->hNotify);
        if (Status != ERROR_SUCCESS)
        {
            TIME_PRINT(("ReconnectNotifySessions - ApiCloseNotify failed %d\n",
                Status));
            Status = MyRpcSmDestroyClientContext(Cluster, &Session->hNotify);
            if (Status != ERROR_SUCCESS) {
                TIME_PRINT(("ReconnectNotifySessions - RpcSmDestroyClientContext failed Error %d\n",Status));
            }
        }
        //
        // Open a new RPC handle.
        //
        TIME_PRINT(("ReconnectNotifySessions - Calling ApiCreateNotify\n"));
        Session->hNotify = ApiCreateNotify(Cluster->RpcBinding,
                                           &Status);
        if (Session->hNotify == NULL) {
            return(Status);
        }


        
        TIME_PRINT(("ReconnectNotifySessions - Session=0x%08lx Notify=0x%08x\n",
            Session, Session->hNotify));

        //
        // Now repost all the notifications
        //
        EventEntry = Session->EventList.Flink;
        while (EventEntry != &Session->EventList) {
            NotifyEvent = CONTAINING_RECORD(EventEntry,
                                            CNOTIFY_EVENT,
                                            ListEntry);
            EventEntry = EventEntry->Flink;

            TIME_PRINT(("ReconnectNotifySession: registering event type %lx\n",NotifyEvent->dwFilter));
            Status = ReRegisterNotifyEvent(Session,
                                           NotifyEvent,
                                           NULL);
            if (Status != ERROR_SUCCESS) {
                return(Status);
            }
        }

        // Run down the notify list for this cluster and post a packet for
        // each registered notify event for CLUSTER_CHANGE_RECONNECT_EVENT
        //
        Name = Cluster->ClusterName;
        NotifyListEntry = Cluster->NotifyList.Flink;
        while (NotifyListEntry != &Cluster->NotifyList) {
            NotifyEvent = CONTAINING_RECORD(NotifyListEntry,
                                      CNOTIFY_EVENT,
                                      ObjectList);
            if (NotifyEvent->dwFilter & CLUSTER_CHANGE_CLUSTER_RECONNECT) {
                if (Packet == NULL) {
                    Packet = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY_PACKET));
                    if (Packet == NULL) {
                        return(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                //SS: Dont know what the Status was meant for
                //It looks like it is not being used
                Packet->Status = ERROR_SUCCESS;
                Packet->Filter = CLUSTER_CHANGE_CLUSTER_RECONNECT;
                Packet->KeyId = NotifyEvent->EventId;
                Packet->Name = MIDL_user_allocate((lstrlenW(Name)+1)*sizeof(WCHAR));
                if (Packet->Name != NULL) {
                    lstrcpyW(Packet->Name, Name);
                }
                TIME_PRINT(("NotifyThread - posting CLUSTER_CHANGE_CLUSTER_RECONNECT to notify queue\n"));
                ClRtlInsertTailQueue(&Session->ParentNotify->Queue,
                                     &Packet->ListEntry);
                Packet = NULL;
            }
            NotifyListEntry = NotifyListEntry->Flink;
       }
    }

    return(ERROR_SUCCESS);
}


DWORD
GetReconnectCandidates(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Computes the list of reconnect candidates that will be used
    in case of a connection failure.

Arguments:

    Cluster - supplies the cluster

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PENUM_LIST EnumList = NULL;
    DWORD i;

    //
    // Real bad algorithm here, just get a list of all the nodes
    //
    Status = ApiCreateEnum(Cluster->RpcBinding,
                           CLUSTER_ENUM_NODE,
                           &EnumList);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    Cluster->ReconnectCount = EnumList->EntryCount + 1;
    Cluster->Reconnect = LocalAlloc(LMEM_FIXED, sizeof(RECONNECT_CANDIDATE)*Cluster->ReconnectCount);
    if (Cluster->Reconnect == NULL) {
        MIDL_user_free(EnumList);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    for (i=0; i<Cluster->ReconnectCount-1; i++) {
        Cluster->Reconnect[i].IsUp = TRUE;
        Cluster->Reconnect[i].Name = EnumList->Entry[i].Name;
        if (lstrcmpiW(Cluster->Reconnect[i].Name, Cluster->NodeName) == 0) {
            Cluster->Reconnect[i].IsCurrent = TRUE;
        } else {
            Cluster->Reconnect[i].IsCurrent = FALSE;
        }
    }
    MIDL_user_free(EnumList);

    //
    // Now add the cluster name.
    //
    Cluster->Reconnect[i].IsUp = TRUE;
    Cluster->Reconnect[i].Name = MIDL_user_allocate((lstrlenW(Cluster->ClusterName)+1)*sizeof(WCHAR));
    if (Cluster->Reconnect[i].Name == NULL) {
        //
        // Just forget about the cluster name.
        //
        --Cluster->ReconnectCount;
    } else {
        lstrcpyW(Cluster->Reconnect[i].Name, Cluster->ClusterName);
        Cluster->Reconnect[i].IsCurrent = FALSE;
    }

    return(ERROR_SUCCESS);
}


VOID
FreeReconnectCandidates(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Frees and cleans up any reconnect candidates

Arguments:

    Cluster - Supplies the cluster

Return Value:

    None.

--*/

{
    DWORD i;

    for (i=0; i<Cluster->ReconnectCount; i++) {
        MIDL_user_free(Cluster->Reconnect[i].Name);
    }
    LocalFree(Cluster->Reconnect);
    Cluster->Reconnect = NULL;
    Cluster->ReconnectCount = 0;
}


DWORD
ReconnectCandidate(
    IN PCLUSTER Cluster,
    IN DWORD dwIndex,
    OUT PBOOL pIsContinue
)
/*++

Routine Description:

    Try to reconnect to the cluster using a reconnection candidate.
    Called with lock held.
    

Arguments:

    Cluster - Supplies the cluster

    dwIndex - Supplies the index of the reconnection candidate in the 
              Cluster->Reconnect[] array

    pIsContinue - Helps decide whether to continue trying reconnection
                  with other candidates in case this try with the 
                  current candidate fails

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    LPWSTR NewClusterName;
    LPWSTR NewNodeName;
    WCHAR *Binding = NULL;
    RPC_BINDING_HANDLE NewBinding;
    RPC_BINDING_HANDLE OldBinding;
    DWORD Status, j;
    
    //
    // Go ahead and try the reconnect.
    //
    TIME_PRINT(("ReconnectCandidate - Binding to %ws\n",Cluster->Reconnect[dwIndex].Name));
    Status = RpcStringBindingComposeW(L"b97db8b2-4c63-11cf-bff6-08002be23f2f",
                                      L"ncadg_ip_udp",
                                      Cluster->Reconnect[dwIndex].Name,
                                      NULL,
                                      NULL,
                                      &Binding);
    if (Status != RPC_S_OK) {
        TIME_PRINT(("ReconnectCandidate - RpcStringBindingComposeW failed %d\n", Status));
        *pIsContinue = FALSE;
        return(Status);
    }
    Status = RpcBindingFromStringBindingW(Binding, &NewBinding);
    RpcStringFreeW(&Binding);
    if (Status != RPC_S_OK) {
        TIME_PRINT(("ReconnectCandidate - RpcBindingFromStringBindingW failed %d\n", Status));
        *pIsContinue = FALSE;
        return(Status);
    }

    //
    // Resolve the binding handle endpoint
    //
    TIME_PRINT(("ReconnectCluster - resolving binding endpoint\n"));
    Status = RpcEpResolveBinding(NewBinding,
                                     clusapi_v2_0_c_ifspec);
    if (Status != RPC_S_OK) {
        TIME_PRINT(("ReconnectCandidate - RpcEpResolveBinding failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }
    TIME_PRINT(("ReconnectCandidate - binding endpoint resolved\n"));
        
    //
    // Set authentication information
    //
    Status = RpcBindingSetAuthInfoW(NewBinding,
                                    NULL,
                                    Cluster->AuthnLevel, 
                                    RPC_C_AUTHN_WINNT,
                                    NULL,
                                    RPC_C_AUTHZ_NAME);
    if (Status != RPC_S_OK) {
        TIME_PRINT(("ReconnectCandidate - RpcBindingSetAuthInfoW failed %d\n", Status));
        *pIsContinue = FALSE;
        return(Status);
    }
    
    OldBinding = Cluster->RpcBinding;
    Cluster->RpcBinding = NewBinding;
    MyRpcBindingFree(Cluster, &OldBinding);

    //
    // Now that we have a binding, get the cluster name and node name.
    //

    NewClusterName = NewNodeName = NULL;
    Status = ApiGetClusterName(Cluster->RpcBinding,
                               &NewClusterName,
                               &NewNodeName);
    if (Status != RPC_S_OK) {
       //
       // Try the next candidate in our list.
       //
       TIME_PRINT(("ReconnectCandidate - ApiGetClusterName failed %d\n",Status));
       *pIsContinue = TRUE;
       return(Status);
    }
    TIME_PRINT(("ReconnectCandidate - ApiGetClusterName succeeded, reopening handles\n",Status));
    MIDL_user_free(Cluster->ClusterName);
    MIDL_user_free(Cluster->NodeName);
    Cluster->ClusterName = NewClusterName;
    Cluster->NodeName = NewNodeName;
    if (Cluster->hCluster != NULL) {
        MyRpcSmDestroyClientContext(Cluster, &Cluster->hCluster);
    }
    Cluster->hCluster = ApiOpenCluster(Cluster->RpcBinding, &Status);
    if (Cluster->hCluster == NULL) {
        TIME_PRINT(("ReconnectCandidate - ApiOpenCluster failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    //
    // We got this far, so assume we have a valid connection to a new server.
    // Reopen the cluster objects.
    //
    Status = ReconnectKeys(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectKeys failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    Status = ReconnectResources(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectResources failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    Status = ReconnectGroups(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectGroups failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    Status = ReconnectNodes(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectNodes failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    Status = ReconnectNetworks(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectNetworks failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    Status = ReconnectNetInterfaces(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectNetInterfaces failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    //
    // Finally, reissue clusterwide notification events.
    //

    Status = ReconnectNotifySessions(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectNotifySessions failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    //
    // We have successfully reconnected!
    //
    ++Cluster->Generation;

    //
    // Mark all the other reconnect candidates as not the current.
    // Mark the successful reconnect candidate as current.
    //
    for (j=0; j<Cluster->ReconnectCount; j++) {
        if (j != dwIndex) {
            Cluster->Reconnect[j].IsCurrent = FALSE;
        } else {
            Cluster->Reconnect[dwIndex].IsCurrent = TRUE;
        }
    }
    TIME_PRINT(("ReconnectCandidate - successful!\n", Status));
    
    return (ERROR_SUCCESS);  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tcontrol.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR ResourceName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -r resource -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  resource\tspecifies the name of the resource to control\n"
    "  access\tspecifies the access to the resource (read write or any)\n"
    "  ControlCode\ta number between 1 and 9\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'r':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    ResourceName = GetString(argv[i]);
                    fprintf(stdout, "Resource = %ws\n", ResourceName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) == 0 ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) == 0 ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) == 0 ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hResource = OpenClusterResource(  hClus, ResourceName );
    if ( hResource == NULL ) {
        fprintf(stderr,
                "OpenResource %ws failed %d\n", ResourceName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );
    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

try_again:
    controlCode = CLUSCTL_RESOURCE_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterResourceControl( hResource,
                                     hNode,
                                     controlCode,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     &ReturnSize );
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        retry = FALSE;
        goto try_again;
    }

    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterResourceControl( hResource,
                                     hNode,
                                     controlCode,
                                     NULL,
                                     0,
                                     buffer,
                                     bufSize,
                                     &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tcreate.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcreate.c

Abstract:

    Test for cluster object creation APIs

Author:

    John Vert (jvert) 3-May-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

LPWSTR ClusterName=NULL;
BOOL DoGroup=FALSE;
BOOL DoResource=FALSE;
int FirstParam=0;
LPWSTR Name=NULL;
LPWSTR GroupName=NULL;
LPWSTR ResourceType=NULL;

CHAR UsageText[] =
    "TCREATE [-c cluster] type name [resourcegroup resourcetype]\n"
    "        [-p paramkey:paramname \"paramvalue\"]\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  type\t\teither \"group\" or \"resource\"\n"
    "  name\t\tthe friendly name of the object\n"
    "  resourcegroup\tthe name of the group the resource should be created in.\n"
    "  resourcetype\tthe type of resource to be created\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}

void
SetParam(
    IN HRESOURCE hRes,
    IN LPSTR KeyName,
    IN LPSTR ValueName,
    IN LPSTR ValueData
    )
{
    HKEY Key;
    HKEY Key2;
    HKEY ParamKey;
    LONG Status;
    LPWSTR wKeyName, wValueName, wValueData;
    DWORD Disposition;
    DWORD IntCount;
    DWORD Number = FALSE;
    DWORD Value;
    CHAR  TestValue[16];

    //
    // See if we got a number, instead of a string.
    //
    IntCount = sscanf( ValueData, "%d", &Value );
    if ( IntCount == 1 ) {
        sprintf( TestValue, "%d\0", Value );
        if ( strcmp(TestValue, ValueData) == 0 ) {
            Number = TRUE;
        }
    }

    wKeyName = GetString(KeyName);
    wValueName = GetString(ValueName);
    wValueData = GetString(ValueData);
    Key = GetClusterResourceKey(hRes, KEY_READ | KEY_WRITE);
    if (Key == NULL) {
        fprintf(stderr, "GetResourceKey failed %d\n", GetLastError());
        return;
    }
    Status = ClusterRegOpenKey(Key, L"Parameters", KEY_WRITE, &Key2);
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "SetParam: Couldn't open Parameters key error %d\n", Status);
    } else {
        Status = ClusterRegCreateKey(Key2,
                                     wKeyName,
                                     0,
                                     KEY_WRITE,
                                     NULL,
                                     &ParamKey,
                                     &Disposition);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "SetParam:  Couldn't create key %ws error %d\n", wKeyName,Status);
        } else {
            if ( Number ) {
                Status = ClusterRegSetValue(ParamKey,
                                        wValueName,
                                        REG_DWORD,
                                        (CONST BYTE *)&Value,
                                        sizeof(Value));
            } else {
                Status = ClusterRegSetValue(ParamKey,
                                        wValueName,
                                        REG_SZ,
                                        (CONST BYTE *)wValueData,
                                        (lstrlenW(wValueData)+1)*sizeof(WCHAR));
            }
            if (Status != ERROR_SUCCESS) {
                fprintf(stderr, "SetParam: Couldn't set value %ws in key %ws, error %lx\n",
                        wValueName, wKeyName, Status);
            }
            ClusterRegCloseKey(ParamKey);
        }
        ClusterRegCloseKey(Key2);
    }

    ClusterRegCloseKey(Key);
    free(wKeyName);
    free(wValueName);
    free(wValueData);

}

void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD ArgsSeen=0;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'p':
                    if ((i+2) >= argc) {
                        Usage();
                    }
                    FirstParam = i+1;
                    return;
                default:
                    Usage();
                    break;
            }
        } else {
            switch (ArgsSeen) {
                case 0:
                    //
                    // type
                    //
                    if (_stricmp(argv[i], "group")==0) {
                        DoGroup = TRUE;
                    } else if (_stricmp(argv[i], "resource") == 0) {
                        DoResource = TRUE;
                    } else {
                        Usage();
                    }
                    ArgsSeen++;
                    break;
                case 1:
                    Name = GetString(argv[i]);
                    ArgsSeen++;
                    break;
                case 2:
                    if (DoGroup) {
                        Usage();
                    } else {
                        GroupName = GetString(argv[i]);
                    }
                    ArgsSeen++;
                    break;
                case 3:
                    ResourceType = GetString(argv[i]);
                    ArgsSeen++;
                    break;
                default:
                    Usage();
            }
        }
    }
    if (DoGroup) {
        if (ArgsSeen != 2) {
            Usage();
        }
    } else if (DoResource) {
        if (ArgsSeen != 4) {
            Usage();
        }
    } else {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP hGroup;
    HRESOURCE hResource;
    LPSTR KeyName, ParamName;
    LPSTR ParamValue;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    if (DoGroup) {
        hGroup = CreateClusterGroup(hClus, Name);
        if (hGroup == NULL) {
            fprintf(stderr,
                    "CreateGroup %ws failed %d\n", Name, GetLastError());
            return(0);
        }
    } else if (DoResource) {
        hGroup = OpenClusterGroup(hClus, GroupName);
        if (hGroup == NULL) {
            fprintf(stderr,
                    "OpenGroup %ws failed %d\n", GroupName, GetLastError());
            return(0);
        }
        hResource = CreateClusterResource(hGroup,
                                          Name,
                                          ResourceType,
                                          0);
        if (hResource == NULL) {
            fprintf(stderr,
                    "CreateResource %ws failed %d\n", Name, GetLastError());
            return(0);
        }
        while (FirstParam != 0) {
            //
            // FirstParam is the keyname:paramname.
            // FirstParam+1 is the paramvalue
            //
            KeyName = argv[FirstParam];
            ParamValue = argv[FirstParam+1];
            ParamName = strchr(KeyName,':');
            if (ParamName == NULL) {
                Usage();
            }
            *ParamName++ = '\0';

            SetParam(hResource, KeyName, ParamName, ParamValue);
            FirstParam += 2;

            if (FirstParam == argc) {
                break;
            }
            if (_stricmp(argv[FirstParam], "-p") != 0) {
                Usage();
            }
            if (FirstParam+2 >= argc) {
                fprintf(stderr, "firstparam %d, argc %d\n",FirstParam,argc);
                Usage();
            }
            FirstParam+=1;
        }
    } else {
        Usage();
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tdelete.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tdelete.c

Abstract:

    Test for cluster object creation APIs

Author:

    John Vert (jvert) 3-May-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

LPWSTR ClusterName=NULL;
BOOL DoGroup=FALSE;
BOOL DoResource=FALSE;
LPWSTR Name=NULL;

CHAR UsageText[] =
    "TDELETE [-c cluster] type name\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  type\t\teither \"group\" or \"resource\"\n"
    "  name\t\tthe friendly name of the object\n";

void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD ArgsSeen=0;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                default:
                    Usage();
                    break;
            }
        } else {
            switch (ArgsSeen) {
                case 0:
                    //
                    // type
                    //
                    if (_stricmp(argv[i], "group")==0) {
                        DoGroup = TRUE;
                    } else if (_stricmp(argv[i], "resource") == 0) {
                        DoResource = TRUE;
                    } else {
                        Usage();
                    }
                    ArgsSeen++;
                    break;
                case 1:
                    Name = GetString(argv[i]);
                    ArgsSeen++;
                    break;
                default:
                    Usage();
            }
        }
    }

}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP hGroup;
    HRESOURCE hResource;
    DWORD   status;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    if (DoGroup) {
        hGroup = OpenClusterGroup(hClus, Name);
        if (hGroup == NULL) {
            fprintf(stderr,
                    "OpenGroup %ws failed %d\n", Name, GetLastError());
            return(0);
        }
        status = DeleteClusterGroup( hGroup );
        if ( status != ERROR_SUCCESS ) {
            fprintf(stderr,
                    "DeleteGroup %ws failed %d\n", Name, GetLastError());
        }
        CloseClusterGroup( hGroup );
    } else if (DoResource) {
        hResource = OpenClusterResource(hClus,
                                        Name);
        if (hResource == NULL) {
            fprintf(stderr,
                    "OpenResource %ws failed %d\n", Name, GetLastError());
            return(0);
        }
        status = DeleteClusterResource( hResource );
        if ( status != ERROR_SUCCESS ) {
            fprintf(stderr,
                    "DeleteResource %ws failed %d\n", Name, GetLastError());
        }
        CloseClusterResource( hResource );
    } else {
        Usage();
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\notify.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Public interface for cluster notification API

Author:

    John Vert (jvert) 19-Mar-1996

Revision History:

--*/
#include "clusapip.h"

//
// Define some handy constants
//
#define FILTER_NODE (CLUSTER_CHANGE_NODE_STATE               | \
                     CLUSTER_CHANGE_NODE_DELETED             | \
                     CLUSTER_CHANGE_NODE_ADDED               | \
                     CLUSTER_CHANGE_NODE_PROPERTY)
#define NOT_FILTER_NODE (~(FILTER_NODE |CLUSTER_CHANGE_HANDLE_CLOSE))

#define FILTER_REGISTRY (CLUSTER_CHANGE_REGISTRY_NAME            | \
                         CLUSTER_CHANGE_REGISTRY_ATTRIBUTES      | \
                         CLUSTER_CHANGE_REGISTRY_VALUE           | \
                         CLUSTER_CHANGE_REGISTRY_SUBTREE)
#define NOT_FILTER_REGISTRY (~(FILTER_REGISTRY |CLUSTER_CHANGE_HANDLE_CLOSE))

#define FILTER_RESOURCE (CLUSTER_CHANGE_RESOURCE_STATE           | \
                         CLUSTER_CHANGE_RESOURCE_DELETED         | \
                         CLUSTER_CHANGE_RESOURCE_ADDED           | \
                         CLUSTER_CHANGE_RESOURCE_PROPERTY)
#define NOT_FILTER_RESOURCE (~(FILTER_RESOURCE | CLUSTER_CHANGE_HANDLE_CLOSE))

#define FILTER_GROUP (CLUSTER_CHANGE_GROUP_STATE              | \
                      CLUSTER_CHANGE_GROUP_DELETED            | \
                      CLUSTER_CHANGE_GROUP_ADDED              | \
                      CLUSTER_CHANGE_GROUP_PROPERTY)
#define NOT_FILTER_GROUP (~(FILTER_GROUP | CLUSTER_CHANGE_HANDLE_CLOSE))

#define FILTER_NETWORK (CLUSTER_CHANGE_NETWORK_STATE              | \
                        CLUSTER_CHANGE_NETWORK_DELETED            | \
                        CLUSTER_CHANGE_NETWORK_ADDED              | \
                        CLUSTER_CHANGE_NETWORK_PROPERTY)
#define NOT_FILTER_NETWORK (~(FILTER_NETWORK | CLUSTER_CHANGE_HANDLE_CLOSE))

#define FILTER_NETINTERFACE (CLUSTER_CHANGE_NETINTERFACE_STATE              | \
                             CLUSTER_CHANGE_NETINTERFACE_DELETED            | \
                             CLUSTER_CHANGE_NETINTERFACE_ADDED              | \
                             CLUSTER_CHANGE_NETINTERFACE_PROPERTY)
#define NOT_FILTER_NETINTERFACE (~(FILTER_NETINTERFACE | CLUSTER_CHANGE_HANDLE_CLOSE))

#define FILTER_CLUSTER (CLUSTER_CHANGE_CLUSTER_STATE | \
                        CLUSTER_CHANGE_CLUSTER_RECONNECT)

#define NOT_FILTER_CLUSTER (~(FILTER_CLUSTER | CLUSTER_CHANGE_HANDLE_CLOSE))                        
//
// Define prototypes for functions local to this module
//

VOID
DestroyNotify(
    IN PCNOTIFY Notify
    );

VOID
DestroySession(
    IN PCNOTIFY_SESSION Session
    );

PCNOTIFY_SESSION
CreateNotifySession(
    IN PCNOTIFY Notify,
    IN PCLUSTER Cluster
    );

DWORD
AddEventToSession(
    IN PCNOTIFY_SESSION Session,
    IN PVOID Object,
    IN DWORD dwFilter,
    IN DWORD_PTR dwNotifyKey
    );

DWORD
NotifyThread(
    IN LPVOID lpThreadParameter
    );

DWORD
GetClusterNotifyCallback(
    IN PLIST_ENTRY ListEntry,
    IN OUT PVOID Context
    );

HCHANGE
WINAPI
CreateClusterNotifyPort(
    IN OPTIONAL HCHANGE hChange,
    IN OPTIONAL HCLUSTER hCluster,
    IN DWORD dwFilter,
    IN DWORD_PTR dwNotifyKey
    )

/*++

Routine Description:

    Creates a cluster notification port to be used for notification of
    cluster state changes.

Arguments:

    hChange - Optionally supplies a handle to an existing cluster notification
              port. If present, the specified notification events will be added
              to the existing port.

    hCluster - Optionally supplies a handle to the cluster. If not present, an
              empty notification port will be created. CreateClusterNotifyPort
              and RegisterClusterNotify may be used later to add notification
              events to the notification port.

    dwFilter - Supplies the events that will be delivered to the
        notification port. Any events of the specified type will be
        delivered to the notification port. Currently defined event
        types are:

            CLUSTER_CHANGE_NODE_STATE
            CLUSTER_CHANGE_NODE_DELETED
            CLUSTER_CHANGE_NODE_ADDED
            CLUSTER_CHANGE_RESOURCE_STATE
            CLUSTER_CHANGE_RESOURCE_DELETED
            CLUSTER_CHANGE_RESOURCE_ADDED
            CLUSTER_CHANGE_GROUP_STATE
            CLUSTER_CHANGE_GROUP_DELETED
            CLUSTER_CHANGE_GROUP_ADDED
            CLUSTER_CHANGE_RESOURCE_TYPE_DELETED
            CLUSTER_CHANGE_RESOURCE_TYPE_ADDED
            CLUSTER_CHANGE_QUORUM_STATE

    dwNotifyKey - Supplies the notification key to be returned as
        part of the notification event.

Return Value:

    If the function is successful, the return value is a handle of the
    change notification object.

    If the function fails, the return value is NULL. To get extended error
    information, call GetLastError.

--*/

{
    PCNOTIFY Notify;
    PCLUSTER Cluster;
    DWORD Status;
    PCNOTIFY_SESSION Session;

    if (hChange == INVALID_HANDLE_VALUE) {

        //
        // This is a newly created notification session
        //

        Notify = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY));
        if (Notify == NULL) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }
        InitializeListHead(&Notify->SessionList);
        InitializeListHead(&Notify->OrphanedEventList);
        InitializeCriticalSection(&Notify->Lock);
        ClRtlInitializeQueue(&Notify->Queue);

#ifdef _WIN64
        ClRtlInitializeHash(&Notify->NotifyKeyHash);
#else
        ZeroMemory(&Notify->NotifyKeyHash,sizeof(CL_HASH));
#endif


        if (hCluster == INVALID_HANDLE_VALUE) {

            //
            // Caller has asked for an empty notification port.
            //
            return((HCHANGE)Notify);
        }
    } else {
        //
        // This is an existing notification port that the specified
        // cluster should be added to.
        //
        Notify = (PCNOTIFY)hChange;
        if ((hCluster == INVALID_HANDLE_VALUE) ||
            (hCluster == NULL)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(NULL);
        }
    }

    Cluster = (PCLUSTER)hCluster;

    //
    //  Chittur Subbaraman (chitturs) - 4/11/2000
    //
    //  Make sure the cluster lock is acquired before the notify lock.
    //  If this order is violated, it could be a potential source of
    //  hard-to-track deadlocks.
    //
    EnterCriticalSection(&Cluster->Lock);
    EnterCriticalSection(&Notify->Lock);
    Session = CreateNotifySession(Notify, Cluster);
    if (Session == NULL) {
        Status = GetLastError();
        LeaveCriticalSection(&Notify->Lock);
        LeaveCriticalSection(&Cluster->Lock);   
        if (hChange == INVALID_HANDLE_VALUE) {
            DestroyNotify(Notify);
        }
        SetLastError(Status);
        return(NULL);
    }
    Status = AddEventToSession(Session,
                               NULL,
                               dwFilter,
                               dwNotifyKey);
    LeaveCriticalSection(&Notify->Lock);
    LeaveCriticalSection(&Cluster->Lock);

    if (Status != ERROR_SUCCESS) {
        if (hChange == INVALID_HANDLE_VALUE) {
            DestroyNotify(Notify);
        }
        SetLastError(Status);
        return(NULL);
    }
    TIME_PRINT(("CreateClusterNotifyPort: Returning Notify=0x%08lx\n",
    Notify));

    return((HCHANGE)Notify);
}


PCNOTIFY_SESSION
CreateNotifySession(
    IN PCNOTIFY Notify,
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    This routine finds a notification session to the specified cluster.
    If a session already exists, it is found and used. If a session does
    not exist, a new one is created.

    The Notify lock must be held.

Arguments:

    Notify - Supplies the notification port.

    Cluster - Supplies the cluster that the session should be opened to.

Return Value:

    A pointer to the notification session.

    NULL on error, GetLastError() will return the specific error code.

--*/

{
    PLIST_ENTRY ListEntry;
    PCNOTIFY_SESSION Session;
    error_status_t Status = ERROR_SUCCESS;

    //
    // First, try to find an existing session.
    //
    ListEntry = Notify->SessionList.Flink;
    while (ListEntry != &Notify->SessionList) {
        Session = CONTAINING_RECORD(ListEntry,
                                    CNOTIFY_SESSION,
                                    ListEntry);
        if (Session->Cluster == Cluster) {
            TIME_PRINT(("CreateNotifySession: found a matching session\n"));

            //
            // Found a match, return it directly.
            //
            return(Session);
        }
        ListEntry = ListEntry->Flink;
    }

    //
    // There is no existing session. Go ahead and create a new one.
    //
    Session = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY_SESSION));
    if (Session == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(NULL);
    }
    TIME_PRINT(("CreateNotifySession: Calling ApiCreateNotify\n"));
    WRAP_NULL(Session->hNotify,
              (ApiCreateNotify(Cluster->RpcBinding, &Status)),
              &Status,
              Cluster);
    if ((Session->hNotify == NULL) || (Status != ERROR_SUCCESS)) {
        LocalFree(Session);
        SetLastError(Status);
        return(NULL);
    }
    InitializeListHead(&Session->EventList);
    Session->Cluster = Cluster;
    Session->ParentNotify = Notify;
    Session->Destroyed = FALSE;

    //
    // Spin up the notification thread for this session.
    //
    Session->NotifyThread = CreateThread(NULL,
                                         0,
                                         NotifyThread,
                                         Session,
                                         0,
                                         NULL);
    if (Session->NotifyThread == NULL) {
        Status = GetLastError();
        ApiCloseNotify(&Session->hNotify);
        LocalFree(Session);
        SetLastError(Status);
        return(NULL);
    }
    InsertHeadList(&Notify->SessionList, &Session->ListEntry);
    EnterCriticalSection(&Cluster->Lock);
    InsertHeadList(&Cluster->SessionList, &Session->ClusterList);
    LeaveCriticalSection(&Cluster->Lock);
    TIME_PRINT(("CreateNotifySession: Session=0x%08lx hNotifyRpc=0x%08lx Thread=0x%08lx\n",
    Session, Session->hNotify, NotifyThread));

    return(Session);

}


DWORD
NotifyThread(
    IN LPVOID lpThreadParameter
    )

/*++

Routine Description:

    Notification thread that gets notification messages from the cluster
    and reposts them to the client-side notify queue.

Arguments:

    lpThreadParameter - Supplies the CNOTIFY_SESSION structure to be monitored

Return Value:

    None.

--*/

{
    PCNOTIFY_SESSION Session = (PCNOTIFY_SESSION)lpThreadParameter;
    PCLUSTER Cluster = Session->Cluster;
    PLIST_ENTRY ListEntry;
    PCNOTIFY_EVENT Event;
    DWORD Status = ERROR_INVALID_HANDLE_STATE;
    error_status_t rpc_error;
    PCNOTIFY_PACKET Packet;
    LPWSTR Name;

    do {
        if (Session->Destroyed)
        {
            TIME_PRINT(("NotifyThread: Session 0x%08lx destroyed\n",
                Session));
            break;
        }
        Packet = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY_PACKET));
        if (Packet == NULL) {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        Packet->Status = ERROR_SUCCESS;
        Packet->Name = NULL;
        TIME_PRINT(("NotifyThread: Calling ApiGetNotify, hNotify=0x%08lx\n",
            Session->hNotify));
        WRAP_CHECK(Status,
                   (ApiGetNotify(Session->hNotify,
                                 INFINITE,
                                 &Packet->KeyId,
                                 &Packet->Filter,
                                 &Packet->StateSequence,
                                 &Packet->Name)),
                   Session->Cluster,
                   !Session->Destroyed);
        if (Status != ERROR_SUCCESS) 
        {
            TIME_PRINT(("NotifyThread : ApiGetNotify on hNotify=0x%08lx returns %u\n",
                Session->hNotify, Status));
            //if the error is due to a reconnect, hide it and map it to success                
            if ((Status == ERROR_NO_MORE_ITEMS) && (Session->hNotify != NULL))
            {
                //set the status to sucess again - this might happen on a 
                //reconnect and then we do want to continue
                //so we retry apigetnotify again 
                Status = ERROR_SUCCESS;
                LocalFree(Packet);
                TIME_PRINT(("NotifyThread : Reconnect map error to success\n"));
            }                    
            else
            {
                //when can we be sure that the cluster is dead?
                //If session is null(reconnect failed) OR
                //If the cluster is marked dead(reconnect failed after session was established) OR
                //If the cluster is dead, and wrap returns RPC_S_SERVER_UNAVAILABLE
                
                //if so, we can terminate this thread because the thread
                //maps to a cluster
                //what do we document, if this returns error, call closeclusternotifyport
                if ((Session->hNotify == NULL) || 
                    (Session->Cluster->Flags & CLUS_DEAD) ||
                    (Status == RPC_S_SERVER_UNAVAILABLE)) 
                {
                    //SS: it is not clear why we post this event
                    //multiple times??? Chittur, any ideas????
                    //Does this mean that if you register for the 
                    //same filter twice, you get the event twice?
                    // We should probably hold the cluster lock here
                    EnterCriticalSection(&Cluster->Lock);
                    //That seems bizarre.
                    //
                    // Something horrible has happened, probably the cluster has crashed.
                    //
                    // Run down the notify list for this cluster and post a packet for
                    // each registered notify event for CLUSTER_CHANGE_CLUSTER_STATE
                    //
                    Name = Cluster->ClusterName;
                    ListEntry = Cluster->NotifyList.Flink;
                    while (ListEntry != &Cluster->NotifyList) {
                        Event = CONTAINING_RECORD(ListEntry,
                                                  CNOTIFY_EVENT,
                                                  ObjectList);
                        if (Event->dwFilter & CLUSTER_CHANGE_CLUSTER_STATE) {
                            if (Packet == NULL) {
                                Packet = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY_PACKET));
                                if (Packet == NULL) {
                                    LeaveCriticalSection(&Cluster->Lock);
                                    return(ERROR_NOT_ENOUGH_MEMORY);
                                }
                            }
                            //SS: Dont know what the Status was meant for
                            //It looks like it is not being used
                            Packet->Status = ERROR_SUCCESS;
                            Packet->Filter = CLUSTER_CHANGE_CLUSTER_STATE;
                            Packet->KeyId = Event->EventId;
                            Packet->Name = MIDL_user_allocate((lstrlenW(Name)+1)*sizeof(WCHAR));
                            if (Packet->Name != NULL) {
                                lstrcpyW(Packet->Name, Name);
                            }
                            TIME_PRINT(("NotifyThread - posting CLUSTER_CHANGE_CLUSTER_STATE to notify queue\n"));
                            ClRtlInsertTailQueue(&Session->ParentNotify->Queue,
                                                 &Packet->ListEntry);
                            Packet = NULL;
                        }
                        ListEntry = ListEntry->Flink;
                    }
                    LeaveCriticalSection(&Cluster->Lock);
                    //cluster is dead, map the error to success
                    Status = ERROR_SUCCESS;
                    //break out of the loop to terminate this thread
                    TIME_PRINT(("NotifyThread : Cluster is dead, break to exit notify thread\n"));
                    LocalFree(Packet);
                    break;
                }
                else
                { 
                    //it is some other error, the user must
                    //call closeclusternotify port to clean up
                    //this thread
                    //free the packet
                    LocalFree(Packet);
                }
            }
        }
        else 
        {
            //
            // Post this onto the notification queue
            //
            ClRtlInsertTailQueue(&Session->ParentNotify->Queue,
                                 &Packet->ListEntry);
        }

    } while ( Status == ERROR_SUCCESS );

    return(Status);
}


DWORD
AddEventToSession(
    IN PCNOTIFY_SESSION Session,
    IN PVOID Object,
    IN DWORD dwFilter,
    IN DWORD_PTR dwNotifyKey
    )

/*++

Routine Description:

    Adds a specific event to a cluster notification session

Arguments:

    Notify - Supplies the notify object

    Object - Supplies the specific object, NULL if it is the cluster.

    dwFilter - Supplies the type of events

    dwNotifyKey - Supplies the notification key to be returned.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PCNOTIFY_EVENT NotifyEvent;
    PCLUSTER Cluster;
    PLIST_ENTRY NotifyList;
    DWORD Status;

    Cluster = Session->Cluster;
    NotifyEvent = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY_EVENT));
    if (NotifyEvent == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    NotifyEvent->Session = Session;
    NotifyEvent->dwFilter = dwFilter;
    NotifyEvent->dwNotifyKey = dwNotifyKey;
    NotifyEvent->Object = Object;

#ifdef _WIN64
    NotifyEvent->EventId = 0;
    
    Status = ClRtlInsertTailHash(&Session->ParentNotify->NotifyKeyHash,
                                 NotifyEvent, &NotifyEvent->EventId);

    if (ERROR_SUCCESS != Status) {
        LocalFree(NotifyEvent); 
        return(Status);
    }
#else
    NotifyEvent->EventId=(DWORD)NotifyEvent;
#endif

    WRAP(Status,
         (RegisterNotifyEvent(Session,
                              NotifyEvent,
                              &NotifyList)),
         Cluster);

    if (Status != ERROR_SUCCESS) {

#ifdef _WIN64
        ClRtlRemoveEntryHash(&Session->ParentNotify->NotifyKeyHash,
                             NotifyEvent->EventId);
#endif

        LocalFree(NotifyEvent);
        return(Status);
    }

    //
    // Add this notification event to the appropriate lists so it can be
    // recreated when the cluster node fails.
    //
    EnterCriticalSection(&Cluster->Lock);
    EnterCriticalSection(&Session->ParentNotify->Lock);

    InsertHeadList(&Session->EventList, &NotifyEvent->ListEntry);
    InsertHeadList(NotifyList, &NotifyEvent->ObjectList);

    LeaveCriticalSection(&Session->ParentNotify->Lock);
    LeaveCriticalSection(&Cluster->Lock);

    return(ERROR_SUCCESS);
}


DWORD
RegisterNotifyEvent(
    IN PCNOTIFY_SESSION Session,
    IN PCNOTIFY_EVENT Event,
    OUT OPTIONAL PLIST_ENTRY *pNotifyList
    )
/*++

Routine Description:

    Common routine for registering a notification event on
    a cluster session

Arguments:

    Session - Supplies the notification session the event
              should be added to.

    Event - Supplies the event to be added to the session.

    NotifyList - if present, returns the list that the notification
        event should be added to.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD Status;

    if (Event->Object == NULL) {
        TIME_PRINT(("RegisterNotifyEvent : Calling ApiAddNotifyCluster\n"));
        Status = ApiAddNotifyCluster(Session->hNotify,
                                     Session->Cluster->hCluster,
                                     Event->dwFilter,
                                     Event->EventId);

        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &Session->Cluster->NotifyList;
        }
    } else if (Event->dwFilter & FILTER_NODE) {
        Status = ApiAddNotifyNode(Session->hNotify,
                                  ((PCNODE)(Event->Object))->hNode,
                                  Event->dwFilter,
                                  Event->EventId,
                                  &Event->StateSequence);

        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCNODE)(Event->Object))->NotifyList;
        }
    } else if (Event->dwFilter & FILTER_RESOURCE) {
        Status = ApiAddNotifyResource(Session->hNotify,
                                      ((PCRESOURCE)(Event->Object))->hResource,
                                      Event->dwFilter,
                                      Event->EventId,
                                      &Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCRESOURCE)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_GROUP) {
        Status = ApiAddNotifyGroup(Session->hNotify,
                                   ((PCGROUP)(Event->Object))->hGroup,
                                   Event->dwFilter,
                                   Event->EventId,
                                   &Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCGROUP)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_NETWORK) {
        Status = ApiAddNotifyNetwork(Session->hNotify,
                                     ((PCNETWORK)(Event->Object))->hNetwork,
                                     Event->dwFilter,
                                     Event->EventId,
                                     &Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCNETWORK)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_NETINTERFACE) {
        Status = ApiAddNotifyNetInterface(Session->hNotify,
                                          ((PCNETINTERFACE)(Event->Object))->hNetInterface,
                                          Event->dwFilter,
                                          Event->EventId,
                                          &Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCNETINTERFACE)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_REGISTRY) {
        Status = ApiAddNotifyKey(Session->hNotify,
                                ((PCKEY)(Event->Object))->RemoteKey,
                                Event->EventId,
                                Event->dwFilter & ~CLUSTER_CHANGE_REGISTRY_SUBTREE,
                                (Event->dwFilter & CLUSTER_CHANGE_REGISTRY_SUBTREE) ? TRUE : FALSE);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCKEY)(Event->Object))->NotifyList;
        }
    } else if (Event->dwFilter & FILTER_CLUSTER) {
        Status = ERROR_SUCCESS;
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &Session->Cluster->NotifyList;
        }
    }
    else {        
        return(ERROR_INVALID_PARAMETER);
    }

    TIME_PRINT(("RegisterNotifyEvent :returned 0x%08lx\n",
        Status));
    return(Status);

}


DWORD
ReRegisterNotifyEvent(
    IN PCNOTIFY_SESSION Session,
    IN PCNOTIFY_EVENT Event,
    OUT OPTIONAL PLIST_ENTRY *pNotifyList
    )
/*++

Routine Description:

    Common routine for re-registering a notification event on
    a cluster session. The only difference between this and
    RegisterNotifyEvent is that this passes the SessionState
    DWORD to the server, which will cause an immediate notification
    trigger if it does not match.

Arguments:

    Session - Supplies the notification session the event
              should be added to.

    Event - Supplies the event to be added to the session.

    NotifyList - if present, returns the list that the notification
        event should be added to.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD Status;

    if (Event->Object == NULL) {
        Status = ApiAddNotifyCluster(Session->hNotify,
                                     Session->Cluster->hCluster,
                                     Event->dwFilter,
                                     Event->EventId);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &Session->Cluster->NotifyList;
        }
    } else if (Event->dwFilter & FILTER_NODE) {
        Status = ApiReAddNotifyNode(Session->hNotify,
                                    ((PCNODE)(Event->Object))->hNode,
                                    Event->dwFilter,
                                    Event->EventId,
                                    Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCNODE)(Event->Object))->NotifyList;
        }
    } else if (Event->dwFilter & FILTER_RESOURCE) {
        Status = ApiReAddNotifyResource(Session->hNotify,
                                        ((PCRESOURCE)(Event->Object))->hResource,
                                        Event->dwFilter,
                                        Event->EventId,
                                        Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCRESOURCE)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_GROUP) {
        Status = ApiReAddNotifyGroup(Session->hNotify,
                                     ((PCGROUP)(Event->Object))->hGroup,
                                     Event->dwFilter,
                                     Event->EventId,
                                     Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCGROUP)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_NETWORK) {
        Status = ApiReAddNotifyNetwork(Session->hNotify,
                                       ((PCNETWORK)(Event->Object))->hNetwork,
                                       Event->dwFilter,
                                       Event->EventId,
                                       Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCNETWORK)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_NETINTERFACE) {
        Status = ApiReAddNotifyNetInterface(Session->hNotify,
                                            ((PCNETINTERFACE)(Event->Object))->hNetInterface,
                                            Event->dwFilter,
                                            Event->EventId,
                                            Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCNETINTERFACE)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_REGISTRY) {
        Status = ApiAddNotifyKey(Session->hNotify,
                                ((PCKEY)(Event->Object))->RemoteKey,
                                Event->EventId,
                                Event->dwFilter & ~CLUSTER_CHANGE_REGISTRY_SUBTREE,
                                (Event->dwFilter & CLUSTER_CHANGE_REGISTRY_SUBTREE) ? TRUE : FALSE);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCKEY)(Event->Object))->NotifyList;
        }
    } else if (Event->dwFilter & FILTER_CLUSTER) {
        Status = ERROR_SUCCESS;
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &Session->Cluster->NotifyList;
        }
    }        
    else {
        return(ERROR_INVALID_PARAMETER);
    }

    return(Status);

}


VOID
DestroyNotify(
    IN PCNOTIFY Notify
    )

/*++

Routine Description:

    Cleans up and frees all allocations and references associated with
    a notification session.

Arguments:

    Notify - supplies the CNOTIFY structure to be destroyed

Return Value:

    None.

--*/

{
    PCNOTIFY_SESSION Session;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY EventList;
    PCRESOURCE Resource;
    PCGROUP Group;
    PCNODE Node;
    PCLUSTER Cluster;
    PCNOTIFY_EVENT Event;
    LIST_ENTRY QueueEntries;
    PCNOTIFY_PACKET Packet;

    //
    // Rundown each session associated with this notification session
    //
    while (!IsListEmpty(&Notify->SessionList)) {
        ListEntry = RemoveHeadList(&Notify->SessionList);
        Session = CONTAINING_RECORD(ListEntry,
                                    CNOTIFY_SESSION,
                                    ListEntry);
        Cluster = Session->Cluster;

        EnterCriticalSection(&Cluster->Lock);

        //
        // Rundown each event registered on this session.
        //
        while (!IsListEmpty(&Session->EventList)) {
            EventList = RemoveHeadList(&Session->EventList);
            Event = CONTAINING_RECORD(EventList,
                                      CNOTIFY_EVENT,
                                      ListEntry);
            RemoveEntryList(&Event->ObjectList);
            LocalFree(Event);
        }

        DestroySession(Session);

        LeaveCriticalSection(&Cluster->Lock);

    }

    //
    // Rundown any outstanding notifications remaining on the queue
    //
    ClRtlRundownQueue(&Notify->Queue, &QueueEntries);
    while (!IsListEmpty(&QueueEntries)) {
        ListEntry = RemoveHeadList(&QueueEntries);
        Packet = CONTAINING_RECORD(ListEntry,
                                   CNOTIFY_PACKET,
                                   ListEntry);
        MIDL_user_free(Packet->Name);
        LocalFree(Packet);
    }

    //
    // Now that we know there are no outstanding references to the orphaned
    // events, free up anything on that list.
    //
    while (!IsListEmpty(&Notify->OrphanedEventList)) {
        ListEntry = RemoveHeadList(&Notify->OrphanedEventList);
        Event = CONTAINING_RECORD(ListEntry,
                                  CNOTIFY_EVENT,
                                  ListEntry);
        LocalFree(Event);
    }

    DeleteCriticalSection(&Notify->Lock);
    ClRtlDeleteQueue(&Notify->Queue);

#ifdef _WIN64
    ClRtlDeleteHash(&Notify->NotifyKeyHash);
#endif

    LocalFree(Notify);
}


DWORD
WINAPI
RegisterClusterNotify(
    IN HCHANGE hChange,
    IN DWORD dwFilterType,
    IN HANDLE hObject,
    IN DWORD_PTR dwNotifyKey
    )

/*++

Routine Description:

    Adds a specific notification type to a cluster notification port. This allows
    an application to register for notification events that affect only a particular
    cluster object. The currently supported specific cluster objects are nodes,
    resources, and groups.

Arguments:

    hChange - Supplies the change notification object.

    dwFilterType - Supplies the type of object that the specific notification
        events should be delivered for. hObject is a handle to an object
        of this type. Currently supported specific filters include:

            CLUSTER_CHANGE_NODE_STATE       - hObject is an HNODE
            CLUSTER_CHANGE_RESOURCE_STATE   - hObject is an HRESOURCE
            CLUSTER_CHANGE_GROUP_STATE      - hObject is an HGROUP
            CLUSTER_CHANGE_REGISTRY_NAME      \
            CLUSTER_CHANGE_REGISTRY_ATTRIBUTES \ - hObject is an HKEY
            CLUSTER_CHANGE_REGISTRY_VALUE      /
            CLUSTER_CHANGE_REGISTRY_SUBTREE   /

    hObject - Supplies the handle to the specific object of the type specified
        by dwFilterType.

    dwNotifyKey - Supplies the notification key to be returned as
        part of the notification event.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PCNOTIFY Notify;
    PCLUSTER Cluster;
    PCNOTIFY_SESSION Session;
    DWORD    dwStatus;

    if (dwFilterType & FILTER_NODE) {
        if (dwFilterType & NOT_FILTER_NODE) {
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = ((PCNODE)hObject)->Cluster;
    } else if (dwFilterType & FILTER_RESOURCE) {
        if (dwFilterType & NOT_FILTER_RESOURCE) {
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = ((PCRESOURCE)hObject)->Cluster;
    } else if (dwFilterType & FILTER_GROUP) {
        if (dwFilterType & NOT_FILTER_GROUP) {
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = ((PCGROUP)hObject)->Cluster;
    } else if (dwFilterType & FILTER_NETWORK) {
        if (dwFilterType & NOT_FILTER_NETWORK) {
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = ((PCNETWORK)hObject)->Cluster;
    } else if (dwFilterType & FILTER_NETINTERFACE) {
        if (dwFilterType & NOT_FILTER_NETINTERFACE) {
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = ((PCNETINTERFACE)hObject)->Cluster;
    } else if (dwFilterType & FILTER_REGISTRY) {
        if (dwFilterType & NOT_FILTER_REGISTRY) {
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = ((PCKEY)hObject)->Cluster;
    } else if (dwFilterType & FILTER_CLUSTER){
        if (dwFilterType & NOT_FILTER_CLUSTER){
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = (PCLUSTER)hObject;
    } else {
        return(ERROR_INVALID_PARAMETER);
    }
    Notify = (PCNOTIFY)hChange;
    
    EnterCriticalSection(&Cluster->Lock);
    EnterCriticalSection(&Notify->Lock);

    Session = CreateNotifySession(Notify, Cluster);
    if (Session == NULL) {
        LeaveCriticalSection(&Notify->Lock);
        LeaveCriticalSection(&Cluster->Lock);   
        return(GetLastError());
    }

    dwStatus = AddEventToSession(Session,
                             hObject,
                             dwFilterType,
                             dwNotifyKey);

    LeaveCriticalSection(&Notify->Lock);
    LeaveCriticalSection(&Cluster->Lock);

    return( dwStatus );

}


DWORD
WINAPI
GetClusterNotify(
    IN HCHANGE hChange,
    OUT DWORD_PTR *lpdwNotifyKey,
    OUT LPDWORD lpdwFilterType,
    OUT OPTIONAL LPWSTR lpszName,
    IN OUT LPDWORD lpcchName,
    IN DWORD dwMilliseconds
    )

/*++

Routine Description:

    Returns the next event from a cluster notification port.

Arguments:

    hChange - Supplies the cluster notification port.

    lpdwNotifyKey - Returns the notification key for the notification event.
        This is the key passed to CreateClusterNotifyPort or RegisterClusterNotify.

    lpdwFilterType - Returns the type of the notification event.

    lpszName - Optionally returns the name of the object that triggered the notification
        event.

    lpcchName - Supplies the length (in characters) of the lpszName buffer. This length
        includes the space for any trailing NULL.

        Returns the length (in characters) of the name written into the lpszName
        buffer. This length does not include the trailing NULL.

    dwMilliseconds - Supplies an optional timeout value that specifies
        how long the caller is willing to wait for the cluster notification event.

Return Value:

    ERROR_SUCCESS if successful.  If lpszName is NULL we return success and fill in
        lpcchName with the size.  If lpcchName is NULL we return ERROR_MORE_DATA.

    ERROR_MORE_DATA if the buffer is too small.

    Win32 error code otherwise.

--*/

{
    PCNOTIFY_PACKET Packet;
    PLIST_ENTRY ListEntry;
    PCNOTIFY Notify = (PCNOTIFY)hChange;
    DWORD Length;
    DWORD Status;
    PCNOTIFY_EVENT Event;
    PVOID BufferArray[2];

    BufferArray[0] = lpszName;
    BufferArray[1] = lpcchName;

    //
    // ListEntry will be NULL under the following conditions (as determined by the ret value from
    // GetClusterNotifyCallback):
    // 
    // lpszName == NULL, lpcchName != NULL (looking for a buffer size) (ERROR_MORE_DATA)
    // lpszName != NULL, lpcchName != NULL, and *lpcchName <= Length (ERROR_MORE_DATA)
    //
    ListEntry = ClRtlRemoveHeadQueueTimeout(&Notify->Queue, dwMilliseconds, GetClusterNotifyCallback,BufferArray);

    if (ListEntry == NULL) {
        //
        // The queue has been rundown or a timeout has occurred, or the buffer isn't big enough.
        //
        Status = GetLastError();

        if (lpszName==NULL && lpcchName!=NULL) {
            //
            // We returned ERROR_MORE_DATA from GetClusterNotifyCallback to prevent a dequeueing,
            // but we want to return ERROR_SUCCESS because a buffer wasn't specified (maintains 
            // consistency with the other Cluster APIs)
            //
            Status = ERROR_SUCCESS;
        }
        return(Status);
    }

    Packet = CONTAINING_RECORD(ListEntry,
                               CNOTIFY_PACKET,
                               ListEntry);
#ifdef _WIN64
    Event = (PCNOTIFY_EVENT)ClRtlGetEntryHash(&Notify->NotifyKeyHash,
                                              Packet->KeyId);

    if (Event == NULL) {
        //
        // The entry is missing
        //
        MIDL_user_free(Packet->Name);
        LocalFree(Packet);
    
        //
        // should not happen unless the memory is corrupted
        //
        return(ERROR_NOT_FOUND);
    }
#else
    Event = (PCNOTIFY_EVENT)Packet->KeyId;
#endif

    Event->StateSequence = Packet->StateSequence;
    *lpdwNotifyKey = Event->dwNotifyKey;
    *lpdwFilterType = Packet->Filter;
    if (ARGUMENT_PRESENT(lpszName)) {
        MylstrcpynW(lpszName, Packet->Name, *lpcchName);
        Length = lstrlenW(Packet->Name);
        if (Length < *lpcchName) {
            *lpcchName = Length;
        }
    }
    MIDL_user_free(Packet->Name);
    LocalFree(Packet);
    return(ERROR_SUCCESS);

}


BOOL
WINAPI
CloseClusterNotifyPort(
    IN HCHANGE hChange
    )

/*++

Routine Description:

    Closes a handle of a change notification object.

Arguments:

    hChange - Supplies a handle of a cluster change notification object
              to close.

Return Value:

    If the function is successful, the return value is TRUE.

    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.

Remarks:

--*/

{
    PCNOTIFY Notify = (PCNOTIFY)hChange;

    DestroyNotify(Notify);
    return(TRUE);
}


VOID
RundownNotifyEvents(
    IN PLIST_ENTRY ListHead,
    IN LPCWSTR lpszName
    )
/*++

Routine Description:

    Cleans up any notification events on the specified list.

Arguments:

    ListHead - Supplies the head of the list of notification events.

    lpszName - Supplies the name that should be used to post the handle close
           event.

Return Value:

    None.

--*/

{
    PCNOTIFY_EVENT Event;
    PLIST_ENTRY ListEntry;
    PCRITICAL_SECTION Lock;
    PCNOTIFY_PACKET Packet;

    while (!IsListEmpty(ListHead)) {
        ListEntry = RemoveHeadList(ListHead);
        Event = CONTAINING_RECORD(ListEntry,
                                  CNOTIFY_EVENT,
                                  ObjectList);

        //
        // Allocate a notification packet for delivering the handle
        // close notification.
        //
        if (Event->dwFilter & CLUSTER_CHANGE_HANDLE_CLOSE) {
            Packet = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY_PACKET));
            if (Packet != NULL) {
                Packet->Status = ERROR_SUCCESS;
                Packet->KeyId = Event->EventId;
                Packet->Filter = (DWORD)CLUSTER_CHANGE_HANDLE_CLOSE;
                Packet->StateSequence = Event->StateSequence;
                Packet->Name = MIDL_user_allocate((lstrlenW(lpszName)+1)*sizeof(WCHAR));
                if (Packet->Name == NULL) {
                    LocalFree(Packet);
                    Packet = NULL;
                } else {
                    lstrcpyW(Packet->Name, lpszName);
                    ClRtlInsertTailQueue(&Event->Session->ParentNotify->Queue,
                                         &Packet->ListEntry);
                }
            }
        }

        Lock = &Event->Session->ParentNotify->Lock;
        EnterCriticalSection(Lock);
        RemoveEntryList(&Event->ListEntry);
        //
        // Note that we cannot just free the Event structure since there may be
        // notification packets that reference this event in either the server-side
        // or client-side queues. Instead we store it on the orphaned event list.
        // It will be cleaned up when the session is closed or when a reconnect
        // occurs. If we had some way to flush out the event queue we could use
        // that instead.
        //
        InsertTailList(&Event->Session->ParentNotify->OrphanedEventList, &Event->ListEntry);
        if (IsListEmpty(&Event->Session->EventList)) {
            DestroySession(Event->Session);
        }

        LeaveCriticalSection(Lock);
    }
}


VOID
DestroySession(
    IN PCNOTIFY_SESSION Session
    )
/*++

Routine Description:

    Destroys and cleans up an empty notification session. This
    means closing the RPC context handle and waiting for the
    notification thread to terminate itself. The session will
    be removed from the notification ports list. The session
    must be empty.

    N.B. The cluster lock must be held.

Arguments:

    Session - Supplies the session to be destroyed.

Return Value:

    None.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 4/19/2000
    //
    //  In order to prevent the NotifyThread from calling ApiGetNotify
    //  during or after the context handle is destroyed, we split
    //  the notification port close into two steps. In the first step,
    //  we merely unblock the ApiGetNotify call and then wait for
    //  the NotifyThread to terminate without freeing the context handle. 
    //  In the next step, after making sure that the NotifyThread has 
    //  terminated, we free the context handle. This avoids an AV in RPC
    //  code caused by the ApiGetNotify call being made during or soon after
    //  the context handle is freed.
    //
    Session->Destroyed = TRUE;
    TIME_PRINT(("Destroy session: Session 0x%08lx marked as destroyed\n",
                 Session));

    //
    //  If the cluster is not dead, try to unblock the ApiGetNotify call.
    //
    if ( !( Session->Cluster->Flags & CLUS_DEAD ) &&
          ( Session->hNotify != NULL ) ) 
    {
        TIME_PRINT(("Destroy session: Call ApiUnblockGetNotifyThread before NotifyThread termination, hNotify = 0x%08lx\n",
                    Session->hNotify));
        dwStatus = ApiUnblockGetNotifyCall( Session->hNotify );
    }

    //
    //  If the ApiUnblockGetNotifyThread returned RPC_S_PROCNUM_OUT_OF_RANGE,
    //  it means you are talking to a server that does not support that
    //  API. Revert to the old (buggy) behavior then.
    //
    if ( dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        TIME_PRINT(("Destroy session: Call ApiCloseNotify before NotifyThread termination, hNotify = 0x%08lx\n",
                    Session->hNotify));
    
        if ( ApiCloseNotify( &Session->hNotify ) != ERROR_SUCCESS ) 
        {
            TIME_PRINT(("Destroy session: Call RpcSmDestroyClientContext since ApiCloseNotify failed before terminating NotifyThread, hNotify = 0x%08lx\n",
                    Session->hNotify));
            RpcSmDestroyClientContext( &Session->hNotify );
        }
    }
    
    RemoveEntryList( &Session->ListEntry );
    RemoveEntryList( &Session->ClusterList );

    //
    // Drop the critical section as the notification thread might be
    // stuck waiting on it. Since the session has been removed from
    // the cluster list, nobody can get to it anymore.
    //
    LeaveCriticalSection( &Session->Cluster->Lock );

    WaitForSingleObject( Session->NotifyThread, INFINITE );
    CloseHandle( Session->NotifyThread );

    //
    // Reacquire the cluster lock.
    //
    EnterCriticalSection( &Session->Cluster->Lock );

    //
    //  If the ApiUnblockGetNotifyThread was successfully executed or
    //  it could not be made since the cluster was dead, then perform
    //  the context handle cleanup. Note that cleaning up the context
    //  handle here is safe since we know that the NotifyThread has
    //  terminated at this point and wouldn't use it any more.
    //
    if ( dwStatus != RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        if ( Session->Cluster->Flags & CLUS_DEAD ) 
        {
            TIME_PRINT(("Destroy session: Call RpcSmDestroyClientContext after terminating NotifyThread, hNotify = 0x%08lx\n",
                    Session->hNotify));
            if ( Session->hNotify != NULL ) 
            {
               RpcSmDestroyClientContext( &Session->hNotify );
            }
        } else 
        {
            TIME_PRINT(("Destroy session: Call ApiCloseNotify after terminating NotifyThread, hNotify = 0x%08lx\n",
                    Session->hNotify));

            dwStatus = ApiCloseNotify( &Session->hNotify );

            if ( dwStatus != ERROR_SUCCESS ) 
            {
                TIME_PRINT(("Destroy session: Call RpcSmDestroyClientContext since ApiCloseNotify failed after terminating NotifyThread, hNotify = 0x%08lx\n",
                    Session->hNotify));
                RpcSmDestroyClientContext( &Session->hNotify );
            }
        }
    }

    LocalFree( Session );
}

DWORD
GetClusterNotifyCallback(
    IN PLIST_ENTRY ListEntry,
    IN OUT PVOID pvContext
    )
/*++

Routine Description:

    Check ListEntry to determine whether the buffer is big enough to contain the Name

Arguments:

    ListEntry - Supplies the event to convert to a CNOTIFY_PACKET.

    Context - A len 2 PVOID array containing the buffer pointer and a DWORD ptr to the
             buffer length.  On output the buffer len ptr contains the number of chars
             needed.

Return Value:

    ERROR_SUCCESS - The buffer is large enough to put the Name into.  

    ERROR_MORE_DATA - The buffer is too small.

--*/

{
    PCNOTIFY_PACKET Packet;
    DWORD Length;

    LPWSTR pBuffer;
    DWORD* pBufferLength;

    PVOID *Context = (PVOID*)pvContext;

    DWORD Status;
    
    ASSERT( pvContext != NULL );

    pBuffer = (LPWSTR)(Context[0]);
    pBufferLength = (DWORD*)(Context[1]);
    
    //
    // Check the Name buffer size
    //
    Packet = CONTAINING_RECORD( ListEntry,
                                CNOTIFY_PACKET,
                                ListEntry );

    //
    // Nested if's to cover the four combinations of pBufferLength and pBuffer being
    // NULL and non-NULL values.
    //
    if ( pBufferLength == NULL) {
        if (pBuffer == NULL ) {
            //
            // We're not interested in filling a buffer, return ERROR_SUCCESS.  This will
            // cause an event to be dequeued.
            //
            Status = ERROR_SUCCESS;
            
        } else { // pBuffer != NULL
            //
            // AV to maintain pre-Whistler functionality (ugh)
            //
            *pBufferLength = 0;
            Status = ERROR_INVALID_PARAMETER;   
        } 
    } else {
        //
        // pBufferLength != NULL;
        //
        Length = wcslen( Packet->Name );
        
        if (pBuffer == NULL ) {
            //
            // We're only interested in getting a buffer size, return ERROR_MORE_DATA to 
            // signify that we're not to dequeue an event.  This will be re-interpreted in 
            // GetClusterNotify.
            //
            *pBufferLength = Length;
            Status = ERROR_MORE_DATA;
            
        } else { // pBuffer != NULL
           //
           // We need to determine whether the buffer is big enough - that determines
           // whether we return ERROR_SUCCESS (it is) or ERROR_MORE_DATA (it isn't)
           //
           if (Length < *pBufferLength) {
                //
                // Success - the buffer is large enough. 
                //
                Status = ERROR_SUCCESS;
            } else {
                //
                // Failure - the buffer was too small.  A buffer was specified, so we need to 
                // return ERROR_MORE_DATA.
                //
                *pBufferLength = Length;
                Status = ERROR_MORE_DATA;
            }
            
        } // if: pBuffer == NULL
        
    } // if: pBufferLength == NULL
    
    return Status;
    
} //*** GetClusterNotifyCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tdepend.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tdepend.c

Abstract:

    Test for cluster resource dependency APIs

Author:

    John Vert (jvert) 3-May-1996

Revision History:

--*/
#include "windows.h"
#include "clusapi.h"
#include "stdio.h"
#include "stdlib.h"

LPWSTR ClusterName=NULL;
BOOL Remove = FALSE;
LPWSTR ResName=NULL;
LPWSTR DependsName=NULL;

CHAR UsageText[] =
    "TDEPEND [-c cluster] [-r] resource dependson\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  -r\t\tdependency should be removed\n";

void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}

void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD ArgsSeen=0;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'r':
                    Remove = TRUE;
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            switch (ArgsSeen) {
                case 0:
                    //
                    // resource
                    //
                    ArgsSeen++;
                    ResName = GetString(argv[i]);
                    break;

                case 1:
                    DependsName = GetString(argv[i]);
                    ArgsSeen++;
                    break;

                default:
                    Usage();
            }
        }
    }
    if ((ResName == NULL) || (DependsName == NULL)) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HRESOURCE hDependsOn;
    DWORD Status;

    ParseArgs(argc, argv);

    //
    // Connect to the specified cluster.
    //
    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    //
    // Open the two resources.
    //
    hResource = OpenClusterResource(hClus, ResName);
    if (hResource == NULL) {
        fprintf(stderr,
                "OpenClusterResource Resource %ws failed %d\n",
                ResName,
                GetLastError());
        return(0);
    }
    hDependsOn = OpenClusterResource(hClus, DependsName);
    if (hDependsOn == NULL) {
        fprintf(stderr,
                "OpenClusterResource DependsOn %ws failed %d\n",
                DependsName,
                GetLastError());
        return(0);
    }

    //
    // Create or remove the dependency.
    //
    if (Remove) {
        Status = RemoveClusterResourceDependency(hResource, hDependsOn);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr,
                    "RemoveClusterResourceDependency failed %d\n",
                    Status);
        }
    } else {
        Status = AddClusterResourceDependency(hResource, hDependsOn);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr,
                    "AddClusterResourceDependency failed %d\n",
                    Status);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\registry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Provides interface for managing cluster registry

Author:

    John Vert (jvert) 19-Jan-1996

Revision History:

--*/
#include "clusapip.h"


//
// Function prototypes for routines local to this module
//
VOID
FreeKey(
    IN PCKEY Key
    );

HKEY
OpenClusterRelative(
    IN HCLUSTER hCluster,
    IN LPCWSTR RelativeName,
    IN LPCWSTR SpecificName,
    IN DWORD samDesired
    );


HKEY
WINAPI
GetClusterKey(
    IN HCLUSTER hCluster,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given cluster.

Arguments:

    hCluster - Supplies a handle to the cluster

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given cluster

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    PCLUSTER Cluster = (PCLUSTER)hCluster;
    PCKEY Key;
    error_status_t Status = ERROR_SUCCESS;

    //
    // Allocate new CKEY structure and connect to cluster registry.
    //
    Key = LocalAlloc(LMEM_FIXED, sizeof(CKEY));
    if (Key == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    Key->Parent = NULL;
    Key->RelativeName = NULL;
    Key->SamDesired = samDesired;
    Key->Cluster = Cluster;
    InitializeListHead(&Key->ChildList);
    InitializeListHead(&Key->NotifyList);
    WRAP_NULL(Key->RemoteKey,
              (ApiGetRootKey(Cluster->RpcBinding,
                             samDesired,
                             &Status)),
              &Status,
              Cluster);
    if ((Key->RemoteKey == NULL) ||
        (Status != ERROR_SUCCESS)) {

        LocalFree(Key);
        SetLastError(Status);
        return(NULL);
    }

    EnterCriticalSection(&Cluster->Lock);

    InsertHeadList(&Cluster->KeyList, &Key->ParentList);

    LeaveCriticalSection(&Cluster->Lock);

    return((HKEY)Key);
}


HKEY
WINAPI
GetClusterNodeKey(
    IN HNODE hNode,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given node

Arguments:

    hNode - Supplies a handle to the node

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given node

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    PCNODE Node = (PCNODE)hNode;
    HCLUSTER Cluster = (HCLUSTER)Node->Cluster;
    DWORD Status;
    LPWSTR Guid=NULL;
    HKEY NodeKey;

    WRAP(Status,
         (ApiGetNodeId(Node->hNode, &Guid)),
         Node->Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }
    NodeKey = OpenClusterRelative(Cluster,
                                  CLUSREG_KEYNAME_NODES,
                                  Guid,
                                  samDesired);
    if (NodeKey == NULL) {
        Status = GetLastError();
    }
    MIDL_user_free(Guid);
    if (NodeKey == NULL) {
        SetLastError(Status);
    }
    return(NodeKey);
}


HKEY
WINAPI
GetClusterGroupKey(
    IN HGROUP hGroup,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given group

Arguments:

    hResource - Supplies a handle to the group

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given group

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    PCGROUP Group = (PCGROUP)hGroup;
    HCLUSTER Cluster = (HCLUSTER)Group->Cluster;
    DWORD Status;
    LPWSTR Guid=NULL;
    HKEY GroupKey;

    WRAP(Status,
         (ApiGetGroupId(Group->hGroup, &Guid)),
         Group->Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }
    GroupKey = OpenClusterRelative(Cluster,
                                   CLUSREG_KEYNAME_GROUPS,
                                   Guid,
                                   samDesired);
    if (GroupKey == NULL) {
        Status = GetLastError();
    }
    MIDL_user_free(Guid);
    if (GroupKey == NULL) {
        SetLastError(Status);
    }
    return(GroupKey);

}


HKEY
WINAPI
GetClusterResourceKey(
    IN HRESOURCE hResource,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given resource.

Arguments:

    hResource - Supplies a handle to the resource

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given resource

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    PCRESOURCE Resource = (PCRESOURCE)hResource;
    HCLUSTER Cluster = (HCLUSTER)Resource->Cluster;
    DWORD Status;
    LPWSTR Guid=NULL;
    HKEY ResKey;

    WRAP(Status,
         (ApiGetResourceId(Resource->hResource, &Guid)),
         Resource->Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }
    ResKey = OpenClusterRelative(Cluster,
                                 CLUSREG_KEYNAME_RESOURCES,
                                 Guid,
                                 samDesired);
    if (ResKey == NULL) {
        Status = GetLastError();
    }
    MIDL_user_free(Guid);
    if (ResKey == NULL) {
        SetLastError(Status);
    }
    return(ResKey);
}


HKEY
WINAPI
GetClusterResourceTypeKey(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszTypeName,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given resource type.

Arguments:

    hCluster - Supplies the cluster the open is relative to.

    lpszTypeName - Supplies the resource type name.

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given resource type.

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    return(OpenClusterRelative(hCluster,
                               CLUSREG_KEYNAME_RESOURCE_TYPES,
                               lpszTypeName,
                               samDesired));
}


HKEY
WINAPI
GetClusterNetworkKey(
    IN HNETWORK hNetwork,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given network.

Arguments:

    hNetwork - Supplies a handle to the network.

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given network.

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    PCNETWORK Network = (PCNETWORK)hNetwork;
    HCLUSTER Cluster = (HCLUSTER)Network->Cluster;
    DWORD Status;
    LPWSTR Guid=NULL;
    HKEY NetworkKey;

    WRAP(Status,
         (ApiGetNetworkId(Network->hNetwork, &Guid)),
         Network->Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }
    NetworkKey = OpenClusterRelative(Cluster,
                                     CLUSREG_KEYNAME_NETWORKS,
                                     Guid,
                                     samDesired);
    if (NetworkKey == NULL) {
        Status = GetLastError();
    }
    MIDL_user_free(Guid);
    if (NetworkKey == NULL) {
        SetLastError(Status);
    }
    return(NetworkKey);
}


HKEY
WINAPI
GetClusterNetInterfaceKey(
    IN HNETINTERFACE hNetInterface,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given network interface.

Arguments:

    hNetInterface - Supplies a handle to the network interface.

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given network interface.

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    PCNETINTERFACE NetInterface = (PCNETINTERFACE)hNetInterface;
    HCLUSTER Cluster = (HCLUSTER)NetInterface->Cluster;
    DWORD Status;
    LPWSTR Guid=NULL;
    HKEY NetInterfaceKey;

    WRAP(Status,
         (ApiGetNetInterfaceId(NetInterface->hNetInterface, &Guid)),
         NetInterface->Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }
    NetInterfaceKey = OpenClusterRelative(Cluster,
                                          CLUSREG_KEYNAME_NETINTERFACES,
                                          Guid,
                                          samDesired);
    if (NetInterfaceKey == NULL) {
        Status = GetLastError();
    }
    MIDL_user_free(Guid);
    if (NetInterfaceKey == NULL) {
        SetLastError(Status);
    }
    return(NetInterfaceKey);
}


HKEY
OpenClusterRelative(
    IN HCLUSTER Cluster,
    IN LPCWSTR RelativeName,
    IN LPCWSTR SpecificName,
    IN DWORD samDesired
    )

/*++

Routine Description:

    Helper routine for the functions that open cluster object keys.
    (GetCluster*Key)

Arguments:

    Cluster - Supplies the cluster the key should be opened in.

    RelativeName - Supplies the first part of the relative name
        (i.e. L"Resources")

    SpecificName - Supplies the name of the object.

Return Value:

    An open registry key if successful

    NULL if unsuccessful. LastError will be set to a Win32 error code

--*/

{
    LPWSTR Buff;
    HKEY ClusterKey;
    HKEY Key;
    LONG Status;

    Buff = LocalAlloc(LMEM_FIXED, (lstrlenW(RelativeName)+lstrlenW(SpecificName)+2)*sizeof(WCHAR));
    if ( Buff == NULL ) {
        return(NULL);
    }
    lstrcpyW(Buff, RelativeName);
    lstrcatW(Buff, L"\\");
    lstrcatW(Buff, SpecificName);

    ClusterKey = GetClusterKey(Cluster, KEY_READ);
    if (ClusterKey == NULL) {
        Status = GetLastError();
        LocalFree(Buff);
        SetLastError(Status);
        return(NULL);
    }
    Status = ClusterRegOpenKey(ClusterKey,
                               Buff,
                               samDesired,
                               &Key);
    LocalFree(Buff);
    ClusterRegCloseKey(ClusterKey);
    if (Status == ERROR_SUCCESS) {
        return(Key);
    } else {
        SetLastError(Status);
        return(NULL);
    }
}


LONG
WINAPI
ClusterRegCreateKey(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT OPTIONAL LPDWORD lpdwDisposition
    )

/*++

Routine Description:

    Creates the specified key in the cluster registry. If the
    key already exists in the registry, the function opens it.

Arguments:

    hKey - Supplies a currently open key.

    lpSubKey - Points to a null-terminated string specifying the name
            of a subkey that this function opens or creates. The subkey
            specified must be a subkey of the key identified by the hKey
            parameter. This subkey must not begin with the backslash
            character ('\'). This parameter cannot be NULL.

    dwOptions - Specifies special options for this key. Valid options are:

            REG_OPTION_VOLATILE - This key is volatile; the information is
                                  stored in memory and is not preserved when
                                  the system is restarted.

    samDesired - Specifies an access mask that specifies the desired security
                 access for the new key

    lpSecurityAttributes - The lpSecurityDescriptor member of the structure
            specifies a security descriptor for the new key. If
            lpSecurityAttributes is NULL, the key gets a default security
            descriptor. Since cluster registry handles are not inheritable,
            the bInheritHandle field of the SECURITY_ATTRIBUTES structure
            must be FALSE.

    phkResult - Points to a variable that receives the handle of the opened
            or created key

    lpdwDisposition - Points to a variable that receives one of the following
            disposition values:
        Value                       Meaning
        REG_CREATED_NEW_KEY             The key did not exist and was created.
        REG_OPENED_EXISTING_KEY     The key existed and was simply opened
                                    without being changed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key;
    PCKEY ParentKey = (PCKEY)hKey;
    PCLUSTER Cluster = ParentKey->Cluster;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    error_status_t Status = ERROR_SUCCESS;
    DWORD Disposition;

    if (lpdwDisposition == NULL) {
        lpdwDisposition = &Disposition;
    }
    //
    // Allocate new CKEY structure and create cluster registry key
    //
    Key = LocalAlloc(LMEM_FIXED, sizeof(CKEY));
    if (Key == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    Key->Parent = ParentKey;
    Key->RelativeName = LocalAlloc(LMEM_FIXED, (lstrlenW(lpSubKey)+1)*sizeof(WCHAR));
    if (Key->RelativeName == NULL) {
        LocalFree(Key);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    lstrcpyW(Key->RelativeName, lpSubKey);
    Key->SamDesired = samDesired;
    Key->Cluster = Cluster;
    InitializeListHead(&Key->ChildList);
    InitializeListHead(&Key->NotifyList);
    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {
        DWORD Error;

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            LocalFree(Key->RelativeName);
            LocalFree(Key);
            return Error;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //

        pRpcSA = NULL;
    }
    WRAP_NULL(Key->RemoteKey,
              (ApiCreateKey(ParentKey->RemoteKey,
                                  lpSubKey,
                                  dwOptions,
                                  samDesired,
                                  pRpcSA,
                                  lpdwDisposition,
                                  &Status)),
              &Status,
              ParentKey->Cluster);

    //
    // Free the RPC_SECURITY_DESCRIPTOR buffer allocated by MapSAToRpcSA.
    //
    if ( pRpcSA  ) {
        //
        //  RtlFreeHeap accepts a NULL base address
        //
        RtlFreeHeap( RtlProcessHeap(), 
                     0,
                     pRpcSA->RpcSecurityDescriptor.lpSecurityDescriptor );
    }    

    if ((Key->RemoteKey == NULL) ||
        (Status != ERROR_SUCCESS)) {
        *phkResult = NULL;
        LocalFree(Key->RelativeName);
        LocalFree(Key);
        return(Status);
    }

    EnterCriticalSection(&Cluster->Lock);

    InsertHeadList(&ParentKey->ChildList, &Key->ParentList);

    LeaveCriticalSection(&Cluster->Lock);

    *phkResult = (HKEY)Key;
    return(ERROR_SUCCESS);

}


LONG
WINAPI
ClusterRegOpenKey(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )

/*++

Routine Description:

    Opens the specified key in the cluster registry.

Arguments:

    hKey - Supplies a currently open key.

    lpSubKey - Points to a null-terminated string specifying the name
            of a subkey that this function opens or creates. The subkey
            specified must be a subkey of the key identified by the hKey
            parameter. This subkey must not begin with the backslash
            character ('\'). This parameter cannot be NULL.

    samDesired - Specifies an access mask that specifies the desired security
                 access for the new key

    phkResult - Points to a variable that receives the handle of the opened
            or created key. Initialized to NULL on failure.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key;
    PCKEY ParentKey = (PCKEY)hKey;
    PCLUSTER Cluster = ParentKey->Cluster;
    error_status_t Status = ERROR_SUCCESS;

    //
    // Allocate new CKEY structure and create cluster registry key
    //
    Key = LocalAlloc(LMEM_FIXED, sizeof(CKEY));
    if (Key == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *phkResult = NULL;
    Key->Parent = ParentKey;
    Key->RelativeName = LocalAlloc(LMEM_FIXED, (lstrlenW(lpSubKey)+1)*sizeof(WCHAR));
    if (Key->RelativeName == NULL) {
        LocalFree(Key);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    lstrcpyW(Key->RelativeName, lpSubKey);
    Key->SamDesired = samDesired;
    Key->Cluster = Cluster;
    InitializeListHead(&Key->ChildList);
    InitializeListHead(&Key->NotifyList);
    WRAP_NULL(Key->RemoteKey,
              (ApiOpenKey(ParentKey->RemoteKey,
                                lpSubKey,
                                samDesired,
                                &Status)),
              &Status,
              ParentKey->Cluster);

    if (Status != ERROR_SUCCESS) {
        LocalFree(Key->RelativeName);
        LocalFree(Key);
        return(Status);
    }

    EnterCriticalSection(&Cluster->Lock);

    InsertHeadList(&ParentKey->ChildList, &Key->ParentList);

    LeaveCriticalSection(&Cluster->Lock);

    *phkResult = (HKEY)Key;
    return(ERROR_SUCCESS);

}


LONG
WINAPI
ClusterRegDeleteKey(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey
    )

/*++

Routine Description:

    Deletes the specified key. A key that has subkeys cannot
    be deleted.

Arguments:

    hKey - Supplies a handle to a currently open key.

    lpSubKey - Points to a null-terminated string specifying the
        name of the key to delete. This parameter cannot be NULL,
        and the specified key must not have subkeys.

Return Value:


    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key = (PCKEY)hKey;
    DWORD Status;

    WRAP(Status,
         (ApiDeleteKey(Key->RemoteKey, lpSubKey)),
         Key->Cluster);
    return(Status);
}


LONG
WINAPI
ClusterRegCloseKey(
    IN HKEY hKey
    )

/*++

Routine Description:

    Closes the handle of the specified cluster registry key

Arguments:

    hKey - Supplies the open key to close

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key = (PCKEY)hKey;
    PCLUSTER Cluster = Key->Cluster;

    //
    // If any keys have been opened relative to this key, we need to
    // keep this CKEY around so that we can reconstruct the key names
    // if we need to reopen the handles.
    //
    // If there are no children of this key, all the storage can be
    // freed. Note that freeing this key may also require us to free
    // up its parent if the parent has been closed but not freed because
    // it has children.
    //

    EnterCriticalSection(&Cluster->Lock);
    if (Cluster->Flags & CLUS_DEAD)
    {
        if (Key->RemoteKey) 
           RpcSmDestroyClientContext(&Key->RemoteKey);
    }        
    else 
    {
        ApiCloseKey(&Key->RemoteKey);
    }

    //
    // Remove any notifications posted against this key.
    //
    RundownNotifyEvents(&Key->NotifyList, L"");

    if (IsListEmpty(&Key->ChildList)) {
        FreeKey(Key);
    }

    LeaveCriticalSection(&Cluster->Lock);

    //
    // If this key was the last thing keeping the cluster structure
    // around, we can clean it up now.
    //
    CleanupCluster(Cluster);
    return(ERROR_SUCCESS);
}

VOID
FreeKey(
    IN PCKEY Key
    )

/*++

Routine Description:

    Frees up the storage for a key and removes it from its
    parent's ChildList. If this is the last key in its parent's
    ChildList, this routine calls itself recursively to free
    the parent storage.

Arguments:

    Key - Supplies the CKEY to be freed.

Return Value:

    None.

--*/

{
    RemoveEntryList(&Key->ParentList);
    if (Key->Parent != NULL) {
        //
        // This is not a root key, so see if we need to free the
        // parent.
        //
        if ((Key->Parent->RemoteKey == NULL) &&
            (IsListEmpty(&Key->Parent->ChildList))) {
            FreeKey(Key->Parent);
        }
        LocalFree(Key->RelativeName);
    }
    LocalFree(Key);
}


LONG
WINAPI
ClusterRegEnumKey(
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName,
    OUT PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    Enumerates subkeys of the specified open cluster registry key.
    The function retrieves information about one subkey each time it is called.

Arguments:

    hKey - Supplies a currently open key or NULL. If NULL is specified,
            the root of the cluster registry is enumerated.

    dwIndex - Supplies the index of the subkey to retrieve. This parameter
            should be zero for the first call to the RegEnumKeyEx function
            and then incremented for subsequent calls. Because subkeys are
            not ordered, any new subkey will have an arbitrary index. This
            means that the function may return subkeys in any order.

    lpszName - Points to a buffer that receives the name of the subkey,
            including the terminating null character. The function copies
            only the name of the subkey, not the full key hierarchy, to
            the buffer.

    lpcchName - Points to a variable that specifies the size, in characters,
            of the buffer specified by the lpszName parameter. This size should
            include the terminating null character. When the function returns,
            the variable pointed to by lpcchName contains the number of characters
            stored in the buffer. The count returned does not include the
            terminating null character.

    lpftLastWriteTime - Points to a variable that receives the time the
            enumerated subkey was last written to.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key = (PCKEY)hKey;
    LONG Status;
    FILETIME LastWriteTime;
    LPWSTR KeyName=NULL;
    DWORD  dwNameLen;

    WRAP(Status,
         (ApiEnumKey(Key->RemoteKey,
                     dwIndex,
                     &KeyName,
                     &LastWriteTime)),
         Key->Cluster);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    MylstrcpynW(lpszName, KeyName, *lpcchName);
    dwNameLen = lstrlenW(KeyName);
    if (*lpcchName < (dwNameLen + 1)) {
        if (lpszName != NULL) {
            Status = ERROR_MORE_DATA;
        }
    }    
    *lpcchName = dwNameLen;
    MIDL_user_free(KeyName);
    return(Status);
}


DWORD
WINAPI
ClusterRegSetValue(
    IN HKEY hKey,
    IN LPCWSTR lpszValueName,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    )

/*++

Routine Description:

    Sets the named value for the given resource.

Arguments:

    hKey - Supplies the handle of the cluster registry key.

    lpszValueName - Supplies a pointer to a string containing
            the name of the value to set. If a value with this
            name is not already present in the resource, the function
            adds it to the resource.

    dwType - Supplies the type of information to be stored as the
            value's data. This parameter can be one of the following values:
            Value               Meaning
            REG_BINARY          Binary data in any form.
            REG_DWORD           A 32-bit number.
            REG_EXPAND_SZ       A null-terminated Unicode string that contains unexpanded
                                references to environment variables (for example, "%PATH%").
            REG_MULTI_SZ        An array of null-terminated Unicode strings, terminated
                                by two null characters.
            REG_NONE            No defined value type.
            REG_SZ              A null-terminated Unicode string.

    lpData - Supplies a pointer to a buffer containing the data
            to be stored with the specified value name.

    cbData - Supplies the size, in bytes, of the information
             pointed to by the lpData parameter. If the data
             is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ,
             cbData must include the size of the terminating null character.

Return value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key = (PCKEY)hKey;
    DWORD Status;

    WRAP(Status,
         (ApiSetValue(Key->RemoteKey,
                         lpszValueName,
                         dwType,
                         lpData,
                         cbData)),
         Key->Cluster);

    return(Status);
}


DWORD
WINAPI
ClusterRegDeleteValue(
    IN HKEY hKey,
    IN LPCWSTR lpszValueName
    )

/*++

Routine Description:

    Removes the specified value from a given registry subkey

Arguments:

    hKey - Supplies the key whose value is to be deleted.

    lpszValueName - Supplies the name of the value to be removed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key = (PCKEY)hKey;
    DWORD Status;

    WRAP(Status,
         (ApiDeleteValue(Key->RemoteKey, lpszValueName)),
         Key->Cluster);

    return(Status);
}


LONG
WINAPI
ClusterRegQueryValue(
    IN HKEY hKey,
    IN LPCWSTR lpszValueName,
    OUT LPDWORD lpdwValueType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )

/*++

Routine Description:

    Retrieves the type and data for a specified value name associated with
    an open cluster registry key.

Arguments:

    hKey - Supplies the handle of the cluster registry key.

    lpszValueName - Supplies a pointer to a string containing the
            name of the value to be queried.

    lpdwValueType - Points to a variable that receives the key's value
            type. The value returned through this parameter will
            be one of the following:

            Value               Meaning
            REG_BINARY          Binary data in any form.
            REG_DWORD           A 32-bit number.
            REG_EXPAND_SZ       A null-terminated Unicode string that contains unexpanded
                                references to environment variables (for example, "%PATH%").
            REG_MULTI_SZ        An array of null-terminated Unicode strings, terminated
                                by two null characters.
            REG_NONE            No defined value type.
            REG_SZ              A null-terminated Unicode string.

            The lpdwValueType parameter can be NULL if the type is not required

    lpData - Points to a buffer that receives the value's data. This parameter
            can be NULL if the data is not required.

    lpcbData - Points to a variable that specifies the size, in bytes, of the buffer
               pointed to by the lpData parameter.  When the function returns, this
               variable contains the size of the data copied to lpData.

               If the buffer specified by lpData parameter is not large enough to hold
               the data, the function returns the value ERROR_MORE_DATA, and stores the
               required buffer size, in bytes, into the variable pointed to by
               lpcbData.

               If lpData is NULL, and lpcbData is non-NULL, the function returns
               ERROR_SUCCESS, and stores the size of the data, in bytes, in the variable
               pointed to by lpcbData.  This lets an application determine the best way
               to allocate a buffer for the value key's data.

               If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, then
               lpData will also include the size of the terminating null character.

               The lpcbData parameter can be NULL only if lpData is NULL.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Dummy1;
    DWORD Dummy2;
    DWORD Required;
    PCKEY Key = (PCKEY)hKey;
    DWORD Status;
    LPBYTE TempData;
    DWORD BufferSize;

    if (lpdwValueType == NULL) {
        lpdwValueType = &Dummy1;
    }
    if (lpData == NULL) {
        TempData = (LPBYTE)&Dummy2;
        BufferSize = 0;
    } else {
        TempData = lpData;
        BufferSize = *lpcbData;
    }
    WRAP(Status,
         (ApiQueryValue(Key->RemoteKey,
                        lpszValueName,
                        lpdwValueType,
                        TempData,
                        BufferSize,
                        &Required)),
         Key->Cluster);
    if ((Status == ERROR_SUCCESS) ||
        (Status == ERROR_MORE_DATA)) {
        if ((Status == ERROR_MORE_DATA) &&
            (lpData == NULL)) {
            //
            // Map this error to success to match the spec.
            //
            Status = ERROR_SUCCESS;
        }
        *lpcbData = Required;
    }
    return(Status);

}



DWORD
WINAPI
ClusterRegEnumValue(
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpszValueName,
    IN OUT LPDWORD lpcchValueName,
    IN LPDWORD lpdwType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )

/*++

Routine Description:

    Enumerates the properties of the given resource.

Arguments:

    hKey - Supplies the handle of the key

    dwIndex - Specifies the index of the value to retrieve.  This parameter
            should be zero for the first call to the EnumClusterResourceValue
            function and then be incremented for subsequent calls.  Because
            properties are not ordered, any new value will have an arbitrary
            index.  This means that the function may return properties in any
            order.

    lpszValueName - Points to a buffer that receives the name of the value,
            including the terminating null character.

    lpcchValueName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszValueName parameter. This size
            should include the terminating null character. When the function returns,
            the variable pointed to by lpcchValueName contains the number of
            characters stored in the buffer. The count returned does not include
            the terminating null character.

    lpdwType - Points to a variable that receives the type code for the value entry.
            The type code can be one of the following values:

            Value               Meaning
            REG_BINARY      Binary data in any form.
            REG_DWORD       A 32-bit number.
            REG_EXPAND_SZ       A null-terminated Unicode string that contains unexpanded
                            references to environment variables (for example, "%PATH%").
            REG_MULTI_SZ        An array of null-terminated Unicode strings, terminated
                            by two null characters.
            REG_NONE        No defined value type.
            REG_SZ              A null-terminated Unicode string.

            The lpdwType parameter can be NULL if the type code is not required.

    lpData - Points to a buffer that receives the data for the value entry.
            This parameter can be NULL if the data is not required.

    lpcbData - Points to a variable that specifies the size, in bytes, of the
            buffer pointed to by the lpData parameter. When the function
            returns, the variable pointed to by the lpcbData parameter contains
            the number of bytes stored in the buffer. This parameter can be NULL
            only if lpData is NULL.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key = (PCKEY)hKey;
    LONG Status;
    LPWSTR ValueName=NULL;
    DWORD TotalSize;
    DWORD DummyType;
    BYTE DummyData;
    DWORD DummycbData;
    DWORD dwNameLen;

    if (lpdwType == NULL) {
        lpdwType = &DummyType;
    }
    if (lpcbData == NULL) {
        if (lpData != NULL) {
            return(ERROR_INVALID_PARAMETER);
        }
        DummycbData = 0;
        lpcbData = &DummycbData;
    }
    if (lpData == NULL) {
        lpData = &DummyData;
    }

    WRAP(Status,
         (ApiEnumValue(Key->RemoteKey,
                       dwIndex,
                       &ValueName,
                       lpdwType,
                       lpData,
                       lpcbData,
                       &TotalSize)),
         Key->Cluster);
    if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_MORE_DATA)) {
        return(Status);
    }
    if (Status == ERROR_MORE_DATA) {
        *lpcbData = TotalSize;
        if (lpData == &DummyData) {
            Status = ERROR_SUCCESS;
        }
    }
   
    MylstrcpynW(lpszValueName, ValueName, *lpcchValueName);
    dwNameLen = lstrlenW(ValueName);
    if (*lpcchValueName < (dwNameLen + 1)) {
        if (lpszValueName != NULL) {
            Status = ERROR_MORE_DATA;
        }
    } 
    *lpcchValueName = dwNameLen;
    MIDL_user_free(ValueName);
    return(Status);
}


LONG
WINAPI
ClusterRegQueryInfoKey(
    HKEY hKey,
    LPDWORD lpcSubKeys,
    LPDWORD lpcchMaxSubKeyLen,
    LPDWORD lpcValues,
    LPDWORD lpcchMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )
/*++

Routine Description:

    Retrieves information about a specified cluster registry key.

Arguments:

    hKey - Supplies the handle of the key.

    lpcSubKeys - Points to a variable that receives the number of subkeys
        contained by the specified key. This parameter can be NULL.

    lpcchMaxSubKeyLen - Points to a variable that receives the length, in
        characters, of the key's subkey with the longest name. The count
        returned does not include the terminating null character. This parameter can be NULL.

    lpcValues - Points to a variable that receives the number of values
        associated with the key. This parameter can be NULL.

    lpcchMaxValueNameLen - Points to a variable that receives the length,
        in characters, of the key's longest value name. The count returned
        does not include the terminating null character. This parameter can be NULL.

    lpcbMaxValueLen - Points to a variable that receives the length, in
        bytes, of the longest data component among the key's values. This parameter can be NULL.

    lpcbSecurityDescriptor - Points to a variable that receives the length,
        in bytes, of the key's security descriptor. This parameter can be NULL.

    lpftLastWriteTime - Pointer to a FILETIME structure. This parameter can be NULL.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD SubKeys;
    DWORD MaxSubKeyLen;
    DWORD Values;
    DWORD MaxValueNameLen;
    DWORD MaxValueLen;
    DWORD SecurityDescriptor;
    DWORD Status;
    FILETIME LastWriteTime;
    PCKEY Key = (PCKEY)hKey;

    WRAP(Status,
         ApiQueryInfoKey(Key->RemoteKey,
                         &SubKeys,
                         &MaxSubKeyLen,
                         &Values,
                         &MaxValueNameLen,
                         &MaxValueLen,
                         &SecurityDescriptor,
                         &LastWriteTime),
         Key->Cluster);
    if (Status == ERROR_SUCCESS) {
        if (ARGUMENT_PRESENT(lpcSubKeys)) {
            *lpcSubKeys = SubKeys;
        }
        if (ARGUMENT_PRESENT(lpcchMaxSubKeyLen)) {
            *lpcchMaxSubKeyLen = MaxSubKeyLen;
        }
        if (ARGUMENT_PRESENT(lpcValues)) {
            *lpcValues = Values;
        }
        if (ARGUMENT_PRESENT(lpcchMaxValueNameLen)) {
            *lpcchMaxValueNameLen = MaxValueNameLen;
        }
        if (ARGUMENT_PRESENT(lpcbMaxValueLen)) {
            *lpcbMaxValueLen = MaxValueLen;
        }
        if (ARGUMENT_PRESENT(lpcbSecurityDescriptor)) {
            *lpcbSecurityDescriptor = SecurityDescriptor;
        }
        if (ARGUMENT_PRESENT(lpftLastWriteTime)) {
            *lpftLastWriteTime = LastWriteTime;
        }
    }

    return(Status);
}


LONG
WINAPI
ClusterRegGetKeySecurity(
    HKEY hKey,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpcbSecurityDescriptor
    )
/*++

Routine Description:

    Retrieves a copy of the security descriptor protecting
    the specified cluster registry key.

Arguments:

    hKey - Supplies the handle of the key

    RequestedInformation - Specifies a SECURITY_INFORMATION structure that
        indicates the requested security information.

    pSecurityDescriptor - Points to a buffer that receives a copy of the
        requested security descriptor.

    lpcbSecurityDescriptor - Points to a variable that specifies the size,
        in bytes, of the buffer pointed to by the pSecurityDescriptor parameter.
        When the function returns, the variable contains the number of bytes
        written to the buffer.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCKEY Key = (PCKEY)hKey;
    RPC_SECURITY_DESCRIPTOR     RpcSD;
    DWORD Status;

    //
    // Convert the supplied SECURITY_DESCRIPTOR to a RPCable version.
    //
    RpcSD.lpSecurityDescriptor    = pSecurityDescriptor;
    RpcSD.cbInSecurityDescriptor  = *lpcbSecurityDescriptor;
    RpcSD.cbOutSecurityDescriptor = 0;

    WRAP(Status,
         (ApiGetKeySecurity(Key->RemoteKey,
                            RequestedInformation,
                            &RpcSD)),
         Key->Cluster);

    //
    // Extract the size of the SECURITY_DESCRIPTOR from the RPCable version.
    //

    *lpcbSecurityDescriptor = RpcSD.cbOutSecurityDescriptor;

    return Status;
}


LONG
WINAPI
ClusterRegSetKeySecurity(
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

Routine Description:

    Sets the security of an open cluster registry key.


Arguments:

    hKey - Supplies the cluster registry key

    SecurityInformation - Specifies a SECURITY_INFORMATION structure that
        indicates the contents of the supplied security descriptor.

    pSecurityDescriptor - Points to a SECURITY_DESCRIPTOR structure that
        specifies the security attributes to set for the specified key.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCKEY Key = (PCKEY)hKey;
    RPC_SECURITY_DESCRIPTOR     RpcSD;
    DWORD Status;

    //
    // Convert the supplied SECURITY_DESCRIPTOR to a RPCable version.
    //
    RpcSD.lpSecurityDescriptor = NULL;

    Status = MapSDToRpcSD(pSecurityDescriptor,&RpcSD);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    WRAP(Status,
         (ApiSetKeySecurity(Key->RemoteKey,
                            SecurityInformation,
                            &RpcSD)),
         Key->Cluster);

    //
    // Free the buffer allocated by MapSDToRpcSD.
    //
    LocalFree(RpcSD.lpSecurityDescriptor);
    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\resrcapi.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    resrcapi.c

Abstract:

    Public interfaces for managing cluster resources.

Author:

    John Vert (jvert) 15-Jan-1996

Revision History:

--*/
#include "clusapip.h"

//
// Local function prototypes
//
HRESOURCE
InitClusterResource(
    IN HRES_RPC hResource,
    IN LPCWSTR lpszResourceName,
    IN PCLUSTER pCluster
    );

HRESTYPEENUM
ClusterResourceTypeOpenEnumFromCandidate(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN DWORD dwType
    );


BOOL
FindNetworkWorker(
    IN HRES_RPC hResource,
    IN PCLUSTER Cluster,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    );


/****
@func       DWORD | ClusterResourceTypeOpenEnumFromCandidate | Tries to
            enumerate the nodes that support a resource type
            using a candidate node in the cluster

@parm       IN HCLUSTER | hCluster | Handle to the cluster
@parm       IN LPCWSTR  | lpszResourceTypeName | Pointer to the name of the 
            resource type
@parm       IN DWORD | dwType | A bitmask of the type of properties 
            to be enumerated. Currently, the only defined type is
            CLUSTER_RESOURCE_TYPE_ENUM_NODES.

@rdesc      Returns NULL if the operation is unsuccessful. For
            detailed information about the error, call the Win32
            function GetLastError (). A handle to the enumeration
            on success.

@xref       <f ClusterResourceTypeOpenEnum>      
****/

HRESTYPEENUM
ClusterResourceTypeOpenEnumFromCandidate(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN DWORD dwType
    )
{
    DWORD                               dwError = ERROR_SUCCESS;
    DWORD                               dwEnumType;
    HCLUSENUM                           hNodeEnum = 0;
    WCHAR                               NameBuf[50];
    DWORD                               NameLen, i, j;
    HCLUSTER                            hClusNode;
    PCLUSTER                            pClus;
    BOOL                                bFoundSp5OrHigherNode = FALSE;
    PENUM_LIST                          Enum = NULL;
    BOOL                                bNodeDown = FALSE;

    //
    // Open node enumeration in the cluster
    //
    hNodeEnum = ClusterOpenEnum(hCluster, CLUSTER_ENUM_NODE);
    if (hNodeEnum == NULL) {
        dwError = GetLastError();
        TIME_PRINT(("ClusterResourceTypeOpenEnum - ClusterOpenEnum failed %d\n",
                    dwError));
        goto error_exit;
    }

    //
    // Enumerate the nodes in the cluster. If you find a live node 
    // that is NT4Sp5 or higher, try to enumerate the resource types
    // from that node
    //
    for (i=0; ; i++) {
        dwError = ERROR_SUCCESS;

        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        dwError = ClusterEnum(hNodeEnum, i, &dwEnumType, NameBuf, &NameLen);
        if (dwError == ERROR_NO_MORE_ITEMS) {
            dwError = ERROR_SUCCESS;
            break;
        } else if (dwError != ERROR_SUCCESS) {
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - ClusterEnum %d returned error %d\n",
                        i,dwError));
            goto error_exit;
        }

        if (dwEnumType != CLUSTER_ENUM_NODE) {
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - Invalid Type %d returned from ClusterEnum\n", 
                        dwEnumType));
            goto error_exit;
        }

        hClusNode = OpenCluster(NameBuf);
        if (hClusNode == NULL) {
            bNodeDown = TRUE;
            dwError = GetLastError();
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - OpenCluster %ws failed %d\n", 
                         NameBuf, dwError));
            continue;
        }

        pClus = GET_CLUSTER(hClusNode);

        dwError = ApiCreateResTypeEnum(pClus->RpcBinding,
                              lpszResourceTypeName,
                              dwType,
                              &Enum);

        if (!CloseCluster(hClusNode)) {
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - CloseCluster %ws failed %d\n", 
                        NameBuf, GetLastError()));
        }

        if (dwError == RPC_S_PROCNUM_OUT_OF_RANGE) {
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - Node %ws is also NT4Sp3/Sp4, skipping...\n", 
                         NameBuf));
            dwError = ERROR_SUCCESS;
            continue;
        } else if ((dwError == ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND) ||
                    (dwError == ERROR_INVALID_PARAMETER) ||
                    (dwError == ERROR_NOT_ENOUGH_MEMORY)) {
            //
            // The above three error codes returned by the RPC 
            // are fatal and so it is not wise to continue any further.
            //
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - ApiCreateResTypeEnum fatally failed %d at node %ws\n",
                        dwError,NameBuf));
            goto error_exit;
        }
        else if (dwError != ERROR_SUCCESS) {
            bNodeDown = TRUE;
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - ApiCreateResTypeEnum failed %d (Node %ws down possibly)\n",
                        dwError,NameBuf));
            continue;
        }
        else {
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - Found node %ws NT4Sp5 or higher\n",
                        NameBuf));
            bFoundSp5OrHigherNode = TRUE;
            break;
        }
    }

    if (!bFoundSp5OrHigherNode) {
        //
        // Did not find a node higher than NT4Sp4.
        //
        if (!bNodeDown) {
            //
            // Assume all nodes are NT4Sp3/Sp4. Send the open node enumeration
            // back to the client since we assume NT4Sp3/Sp4 supports 
            // all resource types. The client is responsible for closing 
            // the open node enumeration. Note that before a handle to 
            // the enumeration is returned back, we need to fake the type 
            // of enumeration.
            //
            // Chittur Subbaraman (chitturs) - 09/08/98
            //
            // How do we know that the resource type parameter 
            // in this case is a valid one ?
            //
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - Assuming all nodes are NT4Sp3 ...\n"));
            Enum = (PENUM_LIST)hNodeEnum;
            for (j=0; j<i; j++) {
                TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - Faking type ...\n"));
                Enum->Entry[j].Type = CLUSTER_RESOURCE_TYPE_ENUM_NODES;
            } 
        } else {  
            // 
            // Atleast 1 node was unreachable. Can't enumerate properly.
            //
            dwError = ERROR_NODE_NOT_AVAILABLE;
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - At least 1 node in this mixed mode/Sp3/Sp4 cluster is down ...\n"));
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - Can't enumerate properly !!!\n"));
            goto error_exit;
        }
    } else {
        ClusterCloseEnum(hNodeEnum);
    }   
    return((HRESTYPEENUM)Enum);
    
error_exit:
    if (hNodeEnum != NULL) {
        ClusterCloseEnum(hNodeEnum);
    }
    SetLastError(dwError);
    return(NULL);	 
}

HRESOURCE
InitClusterResource(
    IN HRES_RPC hResource,
    IN LPCWSTR lpszResourceName,
    IN PCLUSTER pCluster
    )
/*++

Routine Description:

    Allocates and initializes a CRESOURCE. The initialized CRESOURCE
    is linked onto the cluster structure.

Arguments:

    hResource - Supplies the RPC resource handle.

    lpszResourceName - Supplies the name of the resource.

    pCluster - Supplies the cluster

Return Value:

    A pointer to the initialized CRESOURCE structure.

    NULL on error.

--*/

{
    PCRESOURCE Resource;

    Resource = LocalAlloc(LMEM_FIXED, sizeof(CRESOURCE));
    if (Resource == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    Resource->Name = LocalAlloc(LMEM_FIXED, (lstrlenW(lpszResourceName)+1)*sizeof(WCHAR));
    if (Resource->Name == NULL) {
        LocalFree(Resource);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    lstrcpyW(Resource->Name, lpszResourceName);
    Resource->Cluster = pCluster;
    Resource->hResource = hResource;
    InitializeListHead(&Resource->NotifyList);

    //
    // Link new resource onto the cluster structure.
    //
    EnterCriticalSection(&pCluster->Lock);
    InsertHeadList(&pCluster->ResourceList, &Resource->ListEntry);
    LeaveCriticalSection(&pCluster->Lock);

    return ((HRESOURCE)Resource);

}



HRESOURCE
WINAPI
CreateClusterResource(
    IN HGROUP hGroup,
    IN LPCWSTR lpszResourceName,
    IN LPCWSTR lpszResourceType,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Creates a new resource in the cluster.

Arguments:
    hGroup - Supplies a handle to the group that the resource should be
        created in.

    lpszResourceName - Supplies the new resource's name. The specified name
        must be unique within the cluster.

    lpszResourceType - Supplies the new resources type. The specified
        resource type must be installed in the cluster.

    dwFlags - Supplies optional flags. Currently defined flags are:
        CLUSTER_RESOURCE_SEPARATE_MONITOR - This resource should be created
                in a separate resource monitor instead of the shared resource monitor.


Return Value:

    non-NULL - returns an open handle to the specified cluster.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    HRESOURCE Resource;
    HRES_RPC hRes;
    PCGROUP Group;
    error_status_t Status = ERROR_SUCCESS;

    Group = (PCGROUP)hGroup;
    WRAP_NULL(hRes,
              (ApiCreateResource(Group->hGroup,
                                 lpszResourceName,
                                 lpszResourceType,
                                 dwFlags,
                                 &Status)),
              &Status,
              Group->Cluster);

    if ((hRes == NULL) || (Status != ERROR_SUCCESS)) {
        SetLastError(Status);
        return(NULL);
    }

    //
    // Initialize the newly created resource and return
    // the HRESOURCE.
    //
    Resource = InitClusterResource(hRes, lpszResourceName, Group->Cluster);
    if (Resource == NULL) {
        Status = GetLastError();
        ApiCloseResource(&hRes);
        SetLastError(Status);
    }
    return(Resource);
}


HRESOURCE
WINAPI
OpenClusterResource(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceName
    )

/*++

Routine Description:

    Opens a handle to the specified resource

Arguments:

    hCluster - Supplies a handle to the cluster

    lpszResourceName - Supplies the name of the resource to be opened

Return Value:

    non-NULL - returns an open handle to the specified cluster.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    HRESOURCE Resource;
    HRES_RPC hRes;
    error_status_t Status = ERROR_SUCCESS;
    PCLUSTER Cluster = (PCLUSTER)hCluster;

    WRAP_NULL(hRes,
              (ApiOpenResource(Cluster->RpcBinding,
                               lpszResourceName,
                               &Status)),
              &Status,
              Cluster);

    if ((hRes == NULL) || (Status != ERROR_SUCCESS)) {
        SetLastError(Status);
        return(NULL);
    }

    //
    // Initialize the newly created resource and return
    // the HRESOURCE.
    //
    Resource = InitClusterResource(hRes, lpszResourceName, Cluster);
    if (Resource == NULL) {
        Status = GetLastError();
        ApiCloseResource(&hRes);
        SetLastError(Status);
    }
    return(Resource);
}


BOOL
WINAPI
CloseClusterResource(
    IN HRESOURCE hResource
    )

/*++

Routine Description:

    Closes a resource handle returned from OpenClusterResource

Arguments:

    hResource - Supplies the resource handle

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCRESOURCE Resource;
    PCLUSTER Cluster;

    Resource = (PCRESOURCE)hResource;
    Cluster = (PCLUSTER)Resource->Cluster;

    //
    // Unlink resource from cluster list.
    //
    EnterCriticalSection(&Cluster->Lock);
    RemoveEntryList(&Resource->ListEntry);

    //
    // Remove any notifications posted against this resource.
    //
    RundownNotifyEvents(&Resource->NotifyList, Resource->Name);

    //if the cluster is dead and the reconnect has failed,
    //the Resource->hResource might be NULL if s_apiopenresource for
    //this group failed on a reconnect
    //the cluster may be dead and hresource may be non null, say
    //if reconnectgroups succeeded but the reconnect resources
    //failed
    //At reconnect, the old context is saved in the obsolete 
    //list for deletion when the cluster handle is closed or
    //when the next api call is made
    if ((Cluster->Flags & CLUS_DEAD) && (Resource->hResource))
    {
        RpcSmDestroyClientContext(&Resource->hResource);
        LeaveCriticalSection(&Cluster->Lock);
        goto FnExit;
    }        

    LeaveCriticalSection(&Cluster->Lock);

    // Close RPC context handle
    //
    ApiCloseResource(&Resource->hResource);

FnExit:
    //
    // Free memory allocations
    //
    LocalFree(Resource->Name);
    LocalFree(Resource);

    //
    // Give the cluster a chance to clean up in case this
    // resource was the only thing keeping it around.
    //
    CleanupCluster(Cluster);
    return(TRUE);
}


DWORD
WINAPI
DeleteClusterResource(
    IN HRESOURCE hResource
    )

/*++

Routine Description:

    Permanently deletes a resource from the cluster.
    The specified resource must be offline.

Arguments:

    hResource - Supplies the resource to be deleted

Return Value:

    ERROR_SUCCESS if successful

    If the function fails, the return value is an error value.

    If the resource is not currently offline, the error value
        is ERROR_RESOURCE_NOT_OFFLINE.

--*/

{
    PCRESOURCE Resource;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;

    WRAP(Status,
         (ApiDeleteResource(Resource->hResource)),
         Resource->Cluster);

    return(Status);

}


CLUSTER_RESOURCE_STATE
WINAPI
GetClusterResourceState(
    IN HRESOURCE hResource,
    OUT OPTIONAL LPWSTR lpszNodeName,
    IN OUT LPDWORD lpcchNodeName,
    OUT OPTIONAL LPWSTR lpszGroupName,
    IN OUT LPDWORD lpcchGroupName
    )

/*++

Routine Description:

    Returns the resource's current state and the node where
    it is currently online.

Arguments:

    hResource - Supplies a handle to a cluster resource

    lpszNodeName - Returns the name of the node in the cluster where the
            given resource is currently online

    lpcchNodeName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszNodeName parameter. This size
            should include the terminating null character. When the function returns,
            the variable pointed to by lpcchNodeName contains the number of
            characters stored in the buffer. The count returned does not include
            the terminating null character.

    lpszGroupName - Returns the name of the group that the resource is a member of.

    lpcchGroupName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszGroupName parameter. This size
            should include the terminating null character. When the function returns,
            the variable pointed to by lpcchGroupName contains the number of
            characters stored in the buffer. The count returned does not include
            the terminating null character.

Return Value:

    Returns the resource's current state. Currently defined resource
    states include:

        ClusterResouceInitializing
        ClusterResouceOnline
        ClusterResouceOffline
        ClusterResouceFailed

--*/

{
    PCRESOURCE Resource;
    LPWSTR NodeName = NULL;
    LPWSTR GroupName = NULL;
    CLUSTER_RESOURCE_STATE State;
    DWORD Status;
    DWORD Length;

    Resource = (PCRESOURCE)hResource;
    WRAP(Status,
         (ApiGetResourceState(Resource->hResource,
                              (LPDWORD)&State,  // cast for win64 warning
                              &NodeName,
                              &GroupName)),
         Resource->Cluster);
    if (Status == ERROR_SUCCESS) {
        if (ARGUMENT_PRESENT(lpszNodeName)) {
            lstrcpynW(lpszNodeName, NodeName, *lpcchNodeName);
            Length = lstrlenW(NodeName);
            if (Length >= *lpcchNodeName) {
                Status = ERROR_MORE_DATA;
                State = ClusterResourceStateUnknown;
            }
            *lpcchNodeName = Length;
        }
        if (ARGUMENT_PRESENT(lpszGroupName)) {
            lstrcpynW(lpszGroupName, GroupName, *lpcchGroupName);
            Length = lstrlenW(GroupName);
            if (Length >= *lpcchGroupName) {
                Status = ERROR_MORE_DATA;
                State = ClusterResourceStateUnknown;
            }
            *lpcchGroupName = Length;
        }
        MIDL_user_free(NodeName);
        MIDL_user_free(GroupName);
    } else {
        State = ClusterResourceStateUnknown;
    }
    
    SetLastError( Status );
    return( State );
}


DWORD
WINAPI
SetClusterResourceName(
    IN HRESOURCE hResource,
    IN LPCWSTR lpszResourceName
    )
/*++

Routine Description:

    Sets the friendly name of a cluster resource

Arguments:

    hResource - Supplies a handle to a cluster resource

    lpszResourceName - Supplies the new name of the cluster resource

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCRESOURCE Resource;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;
    WRAP(Status,
         (ApiSetResourceName(Resource->hResource, lpszResourceName)),
         Resource->Cluster);

    return(Status);
}




DWORD
WINAPI
FailClusterResource(
    IN HRESOURCE hResource
    )

/*++

Routine Description:

    Initiates a resource failure. The specified resource is treated as failed.
    This causes the cluster to initiate the same failover process that would
    result if the resource actually failed.

Arguments:

    hResource - Supplies a handle to the resource to be failed over

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.


--*/

{
    PCRESOURCE Resource;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;
    WRAP(Status,
         (ApiFailResource(Resource->hResource)),
         Resource->Cluster);

    return(Status);
}


DWORD
WINAPI
OnlineClusterResource(
    IN HRESOURCE hResource
    )

/*++

Routine Description:

    Brings an offline resource online.

    If hDestinationNode is specified, but the resource is not capable
    of being brought online there, this API fails.

    If NULL is specified as the hDestinationNode, the best possible
    node is chosen by the cluster software.

    If NULL is specified but no node where this resource
    can be brought online is currently available, this API fails.

Arguments:

    hResource - Supplies a handle to the resource to be failed over

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value. If a suitable
    host node is not availabe, the error value is
    ERROR_HOST_NODE_NOT_AVAILABLE.

--*/

{
    PCRESOURCE Resource;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;
    WRAP(Status,
         (ApiOnlineResource(Resource->hResource)),
         Resource->Cluster);
    return(Status);
}


DWORD
WINAPI
OfflineClusterResource(
    IN HRESOURCE hResource
    )

/*++

Routine Description:

    Brings an online resource offline.

Arguments:

    hResource - Supplies a handle to the resource to be taken offline

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCRESOURCE Resource;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;
    WRAP(Status,
         (ApiOfflineResource(Resource->hResource)),
         Resource->Cluster);
    return(Status);
}

DWORD
WINAPI
ChangeClusterResourceGroup(
    IN HRESOURCE hResource,
    IN HGROUP hGroup
    )

/*++

Routine Description:

    Moves a resource from one group to another.

Arguments:

    hResource - Supplies the resource to be moved. If the resource
        depends on any other resources, those resources will also
        be moved. If other resources depend on the specified resource,
        those resources will also be moved.

    hGroup - Supplies the group that the resource should be moved into.
        If the resource is online, the specified group must be online
        on the same node.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCRESOURCE Resource;
    DWORD Status;
    PCGROUP Group;

    Resource = (PCRESOURCE)hResource;
    Group = (PCGROUP)hGroup;

    WRAP(Status,
         (ApiChangeResourceGroup(Resource->hResource,Group->hGroup)),
         Resource->Cluster);
    return(Status);
}

DWORD
WINAPI
AddClusterResourceNode(
    IN HRESOURCE hResource,
    IN HNODE hNode
    )

/*++

Routine Description:

    Adds a node to the list of possible nodes that the specified
    resource can run on.

Arguments:

    hResource - Supplies the resource whose list of potential host
        nodes is to be changed.

    hNode - Supplies the node which should be added to the resource's list of
        potential host nodes.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCRESOURCE Resource = (PCRESOURCE)hResource;
    PCNODE Node = (PCNODE)hNode;
    DWORD Status;

    WRAP(Status,
         (ApiAddResourceNode(Resource->hResource, Node->hNode)),
         Resource->Cluster);
    return(Status);
}

DWORD
WINAPI
RemoveClusterResourceNode(
    IN HRESOURCE hResource,
    IN HNODE hNode
    )

/*++

Routine Description:

    Removes a node from the list of possible nodes that the specified
    resource can run on.

Arguments:

    hResource - Supplies the resource whose list of potential host
        nodes is to be changed.

    hNode - Supplies the node which should be removed from the resource's
        list of potential host nodes.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCRESOURCE Resource = (PCRESOURCE)hResource;
    PCNODE Node = (PCNODE)hNode;
    DWORD Status;

    WRAP(Status,
         (ApiRemoveResourceNode(Resource->hResource, Node->hNode)),
         Resource->Cluster);
    return(Status);
}

DWORD
WINAPI
AddClusterResourceDependency(
    IN HRESOURCE hResource,
    IN HRESOURCE hDependsOn
    )

/*++

Routine Description:

    Adds a dependency relationship between two resources.

Arguments:

    hResource - Supplies the dependent resource.

    hDependsOn - Supplies the resource that hResource depends on.
        This resource must be in the same group as hResource. If
        hResource is currently online, this resource must also be
        currently online.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCRESOURCE Resource;
    PCRESOURCE DependsOn;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;
    DependsOn = (PCRESOURCE)hDependsOn;

    WRAP(Status,
         (ApiAddResourceDependency(Resource->hResource,DependsOn->hResource)),
         Resource->Cluster);
    return(Status);
}

DWORD
WINAPI
RemoveClusterResourceDependency(
    IN HRESOURCE hResource,
    IN HRESOURCE hDependsOn
    )

/*++

Routine Description:

    Removes a dependency relationship between two resources

Arguments:

    hResource - Supplies the dependent resource

    hDependsOn - Supplies the resource that hResource is currently
        dependent on.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCRESOURCE Resource;
    PCRESOURCE DependsOn;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;
    DependsOn = (PCRESOURCE)hDependsOn;

    WRAP(Status,
         (ApiRemoveResourceDependency(Resource->hResource,DependsOn->hResource)),
         Resource->Cluster);
    return(Status);
}


BOOL
WINAPI
CanResourceBeDependent(
    IN HRESOURCE hResource,
    IN HRESOURCE hResourceDependent
    )
/*++

Routine Description:

    Determines if the resource identified by hResource can depend on hResourceDependent.
    In order for this to be true, both resources must be members of the same group and
    the resource identified by hResourceDependent cannot depend on the resource identified
    by hResource, whether directly or indirectly.

Arguments:

    hResource - Supplies a handle to the resource to be dependent.

    hResourceDependent - Supplies a handle to the resource on which
        the resource identified by hResource can depend.

Return Value:

    If the resource identified by hResource can depend  on the resource
    identified by hResourceDependent, the return value is TRUE.  Otherwise,
    the return value is FALSE.

--*/

{
    DWORD Status;
    PCRESOURCE Resource1 = (PCRESOURCE)hResource;
    PCRESOURCE Resource2 = (PCRESOURCE)hResourceDependent;

    WRAP(Status,
         (ApiCanResourceBeDependent(Resource1->hResource,Resource2->hResource)),
         Resource1->Cluster);

    if (Status == ERROR_SUCCESS) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


HRESENUM
WINAPI
ClusterResourceOpenEnum(
    IN HRESOURCE hResource,
    IN DWORD dwType
    )
/*++

Routine Description:

    Initiates an enumeration of a cluster resource's properties

Arguments:

    hResource - Supplies a handle to the resource.

    dwType - Supplies a bitmask of the type of properties to be
            enumerated. Currently defined types include

            CLUSTER_RESOURCE_ENUM_DEPENDS  - All resources the specified resource
                                             depends on.
            CLUSTER_RESOURCE_ENUM_PROVIDES - All resources that depend on the
                                             specified resource.
            CLUSTER_RESOURCE_ENUM_NODES    - All nodes that this resource can run
                                             on.

Return Value:

    If successful, returns a handle suitable for use with ClusterResourceEnum

    If unsuccessful, returns NULL and GetLastError() returns a more
        specific error code.

--*/

{
    PCRESOURCE Resource;
    PENUM_LIST Enum = NULL;
    DWORD Status;

    if ((dwType & CLUSTER_RESOURCE_ENUM_ALL) == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }
    if ((dwType & ~CLUSTER_RESOURCE_ENUM_ALL) != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    Resource = (PCRESOURCE)hResource;

    WRAP(Status,
         (ApiCreateResEnum(Resource->hResource,
                           dwType,
                           &Enum)),
         Resource->Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }
    return((HRESENUM)Enum);
}


DWORD
WINAPI
ClusterResourceGetEnumCount(
    IN HRESENUM hResEnum
    )
/*++

Routine Description:

    Gets the number of items contained the the enumerator's collection.

Arguments:

    hEnum - a handle to an enumerator returned by ClusterResourceOpenEnum.

Return Value:

    The number of items (possibly zero) in the enumerator's collection.
    
--*/
{
    PENUM_LIST Enum = (PENUM_LIST)hResEnum;
    return Enum->EntryCount;
}


DWORD
WINAPI
ClusterResourceEnum(
    IN HRESENUM hResEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )
/*++

Routine Description:

    Returns the next enumerable resource property.

Arguments:

    hResEnum - Supplies a handle to an open cluster resource enumeration
            returned by ClusterResourceOpenEnum

    dwIndex - Supplies the index to enumerate. This parameter should be
            zero for the first call to the ClusterResourceEnum function and
            then incremented for subsequent calls.

    dwType - Returns the type of property.

    lpszName - Points to a buffer that receives the name of the resource
            property, including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszName parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to by lpcchName contains the
            number of characters stored in the buffer. The count returned
            does not include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD NameLen;
    PENUM_LIST Enum = (PENUM_LIST)hResEnum;

    if (dwIndex >= Enum->EntryCount) {
        return(ERROR_NO_MORE_ITEMS);
    }

    NameLen = lstrlenW(Enum->Entry[dwIndex].Name);
    lstrcpynW(lpszName, Enum->Entry[dwIndex].Name, *lpcchName);
    if (*lpcchName < (NameLen + 1)) {
        if (lpszName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {
        Status = ERROR_SUCCESS;
    }

    *lpdwType = Enum->Entry[dwIndex].Type;
    *lpcchName = NameLen;

    return(Status);

}


DWORD
WINAPI
ClusterResourceCloseEnum(
    IN HRESENUM hResEnum
    )
/*++

Routine Description:

    Closes an open enumeration for a resource.

Arguments:

    hResEnum - Supplies a handle to the enumeration to be closed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD i;
    PENUM_LIST Enum = (PENUM_LIST)hResEnum;

    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
    }
    MIDL_user_free(Enum);
    return(ERROR_SUCCESS);
}


DWORD
WINAPI
CreateClusterResourceType(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszDllName,
    IN DWORD dwLooksAlive,
    IN DWORD dwIsAlive
    )
/*++

Routine Description:

    Creates a new resource type in the cluster.  Note that this API only
    defines the resource type in the cluster registry and registers the
    resource type with the cluster service.  The calling program is
    responsible for installing the resource type DLL on each node in the
    cluster.

Arguments:

    hCluster - Supplies a handle to a previously opened cluster.

    lpszResourceTypeName - Supplies the new resource types name. The
        specified name must be unique within the cluster.

    lpszDisplayName - Supplies the display name for the new resource
        type. While lpszResourceTypeName should uniquely identify the
        resource type on all clusters, the lpszDisplayName should be
        a localized friendly name for the resource, suitable for displaying
        to administrators

    lpszResourceTypeDll - Supplies the name of the new resource types DLL.

    dwLooksAlivePollInterval - Supplies the default LooksAlive poll interval
        for the new resource type in milliseconds.

    dwIsAlivePollInterval - Supplies the default IsAlive poll interval for
        the new resource type in milliseconds.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCLUSTER Cluster;
    error_status_t Status = ERROR_SUCCESS;

    Cluster = (PCLUSTER)hCluster;

    WRAP(Status,
         (ApiCreateResourceType(Cluster->RpcBinding,
                                lpszTypeName,
                                lpszDisplayName,
                                lpszDllName,
                                dwLooksAlive,
                                dwIsAlive)),
         Cluster);

    return(Status);
}


DWORD
WINAPI
DeleteClusterResourceType(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszTypeName
    )
/*++

Routine Description:

    Deletes a resource type in the cluster.  Note that this API only
    deletes the resource type in the cluster registry and unregisters the
    resource type with the cluster service.  The calling program is
    responsible for deleting the resource type DLL on each node in the
    cluster.  If any resources of the specified type exist, this API
    fails.  The calling program is responsible for deleting any resources
    of this type before deleting the resource type.

Arguments:

    hCluster - Supplies a handle to a previously opened cluster.

    lpszResourceTypeName - Supplies the name of the resource type to
        be deleted.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCLUSTER Cluster;
    error_status_t Status = ERROR_SUCCESS;

    Cluster = (PCLUSTER)hCluster;

    WRAP(Status,
         (ApiDeleteResourceType(Cluster->RpcBinding,lpszTypeName)),
         Cluster);

    return(Status);


}

/****
@func       HRESTYPEENUM | ClusterResourceTypeOpenEnum | Initiates 
            an enumeration of a cluster resource type's properties.

@parm       IN HCLUSTER | hCluster | Handle to the cluster
@parm       IN LPCWSTR  | lpszResourceTypeName | Pointer to the name of the 
            resource type
@parm       IN DWORD | dwType | A bitmask of the type of properties 
            to be enumerated. Currently, the only defined type is
            CLUSTER_RESOURCE_TYPE_ENUM_NODES.
@comm       This function opens an enumerator for iterating through
            a resource type's nodes

@rdesc      Returns NULL if the operation is unsuccessful. For
            detailed information about the error, call the Win32
            function GetLastError (). A handle to the enumeration
            on success.

@xref       <f ClusterResourceTypeEnum> <f ClusterResourceTypeCloseEnum>     
****/
HRESTYPEENUM
WINAPI
ClusterResourceTypeOpenEnum(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN DWORD dwType
    )
{
    PCLUSTER   pCluster;
    PENUM_LIST Enum = NULL;
    DWORD Status;

    pCluster = (PCLUSTER)hCluster;

    if ((dwType & CLUSTER_RESOURCE_TYPE_ENUM_ALL) == 0) {
        Status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }
    if ((dwType & ~CLUSTER_RESOURCE_TYPE_ENUM_ALL) != 0) {
        Status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    WRAP(Status,
        (ApiCreateResTypeEnum(pCluster->RpcBinding,
                              lpszResourceTypeName,
                              dwType,
                              &Enum)),
        pCluster);

    if (Status == RPC_S_PROCNUM_OUT_OF_RANGE) {
        // 
        // The current node is NT4Sp4 or lower. Try
        // some other node in the cluster
        //
        TIME_PRINT(("ClusterResourceTypeOpenEnum - Current Cluster Node is NTSp4 or lower !!!\n"));
        TIME_PRINT(("ClusterResourceTypeOpenEnum - Trying some other candidate ...\n"));
        Enum = (PENUM_LIST)ClusterResourceTypeOpenEnumFromCandidate(hCluster,
                                                        lpszResourceTypeName,
                                                        dwType);
        if (Enum == NULL)                                   
        {
            //
            // Did not find a node NT4Sp5 or higher AND at least
            // one node is down. Can't enumerate.
            //
            TIME_PRINT(("ClusterResourceTypeOpenEnum - ClusterResourceTypeOpenEnumFromCandidate failed !!!\n"));
            Status = GetLastError ();
            goto error_exit;
        }
        Status = ERROR_SUCCESS;
    }
    
    if (Status != ERROR_SUCCESS) {
       goto error_exit;
    }
    return((HRESTYPEENUM)Enum);
    
error_exit:
    SetLastError(Status);
    return(NULL);
}


DWORD
WINAPI
ClusterResourceTypeGetEnumCount(
    IN HRESTYPEENUM hResTypeEnum
    )
/*++

Routine Description:

    Gets the number of items contained the the enumerator's collection.

Arguments:

    hEnum - a handle to an enumerator returned by ClusterResourceTypeOpenEnum.

Return Value:

    The number of items (possibly zero) in the enumerator's collection.
    
--*/
{
    PENUM_LIST Enum = (PENUM_LIST)hResTypeEnum;
    return Enum->EntryCount;
}


/****
@func       DWORD | ClusterResourceTypeEnum | Enumerates a resource
            type's nodes, returning the name of one object per call.

@parm       IN HRESTYPEENUM | hResTypeEnum | Supplies a handle to 
            an open cluster resource enumeration returned by 
            ClusterResourceTypeOpenEnum.
@parm       IN DWORD | dwIndex | Supplies the index to enumerate. 
            This parameter should be zero for the first call 
            to the ClusterResourceTypeEnum function and
            then incremented for subsequent calls.
@parm       OUT DWORD | lpdwType | Returns the type of property.
            Currently, the only defined type is 
            CLUSTER_RESOURCE_TYPE_ENUM_NODES.
@parm       OUT LPWSTR  | lpszName | Points to a buffer that 
            receives the name of the resource type.
@parm       IN OUT LPDWORD | lpcchName | Points to a variable that 
            specifies the size, in characters, of the buffer 
            pointed to by the lpszName parameter. This size
            should include the terminating null character. 
            When the function returns, the variable pointed 
            to by lpcchName contains the number of characters 
            stored in the buffer. The count returned
            does not include the terminating null character.
            property, including the terminating null character.
@comm       This function opens an enumerator for iterating through
            a resource type's nodes.
            
@rdesc      Returns a Win32 error code if the operation is 
            unsuccessful. ERROR_SUCCESS on success.

@xref       <f ClusterResourceTypeOpenEnum> <f ClusterResourceTypeCloseEnum>     
****/
DWORD
WINAPI
ClusterResourceTypeEnum(
    IN HRESTYPEENUM hResTypeEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )
{
    DWORD Status;
    DWORD NameLen;
    PENUM_LIST Enum = (PENUM_LIST)hResTypeEnum;

    if ((Enum == NULL) || 
        (lpcchName == NULL) ||
        (lpdwType == NULL)) {
        Status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }
    if (dwIndex >= Enum->EntryCount) {
        Status = ERROR_NO_MORE_ITEMS;
        goto error_exit;
    } 

    NameLen = lstrlenW(Enum->Entry[dwIndex].Name);
    lstrcpynW(lpszName, Enum->Entry[dwIndex].Name, *lpcchName);
    if (*lpcchName < (NameLen + 1)) {
        if (lpszName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {
        Status = ERROR_SUCCESS;
    }

    *lpdwType = Enum->Entry[dwIndex].Type;
    *lpcchName = NameLen;
    
error_exit:
    return(Status);
}

/****
@func       DWORD | ClusterResourceTypeCloseEnum | Closes an open 
            enumeration for a resource type.

@parm       IN HRESTYPEENUM | hResTypeEnum | Handle to the 
            enumeration to be closed.
@comm       This function closes an open enumeration.

@rdesc      Returns ERROR_SUCCESS on success. A Win32 error code otherwise.

@xref       <f ClusterResourceTypeEnum> <f ClusterResourceTypeOpenEnum>     
****/
DWORD
WINAPI
ClusterResourceTypeCloseEnum(
    IN HRESTYPEENUM hResTypeEnum
    )
{
    DWORD i;
    PENUM_LIST Enum = (PENUM_LIST)hResTypeEnum;
    DWORD Status;

    if (Enum == NULL) {
       Status = ERROR_INVALID_PARAMETER;
       goto error_exit;
    }
    
    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
    }
    MIDL_user_free(Enum);
    Status = ERROR_SUCCESS;
    
error_exit:
    return(Status);
}


BOOL
WINAPI
GetClusterResourceNetworkName(
    IN HRESOURCE hResource,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    )
/*++

Routine Description:

    Enumerates the dependencies of a resource in an attempt to find
    a network name that the resource depends on. If a network name
    is found, this function returns TRUE and fills in lpBuffer with
    the network name. If a network name is not found, this function
    returns FALSE.

Arguments:

    hResource - Supplies the resource.

    lpBuffer - Points to a buffer to receive the null-terminated character
               string containing the network name.

    nSize - Points to a variable that specifies the maximum size, in characters,
            of the buffer. This value should be large enough to contain
            MAX_COMPUTERNAME_LENGTH + 1 characters.

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
    BOOL Success;
    PCRESOURCE Resource = (PCRESOURCE)hResource;

    //
    // Call a recursive worker to do the search.
    //
    Success = FindNetworkWorker(Resource->hResource,
                                Resource->Cluster,
                                lpBuffer,
                                nSize);
    return(Success);
}


BOOL
FindNetworkWorker(
    IN HRES_RPC hResource,
    IN PCLUSTER Cluster,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    )
/*++

Routine Description:

    Recursive worker to search a resource's dependency tree
    for a network name resource.

Arguments:

    Resource - Supplies the resource.

    Cluster - Supplies the cluster.

    lpBuffer - Points to a buffer to receive the null-terminated character
               string containing the network name.

    nSize - Points to a variable that specifies the maximum size, in characters,
            of the buffer. This value should be large enough to contain
            MAX_COMPUTERNAME_LENGTH + 1 characters.

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
    BOOL Success = FALSE;
    DWORD i;
    PENUM_LIST Enum=NULL;
    DWORD Status;
    HRES_RPC hRes;
    LPWSTR TypeName;


    //
    // Create a dependency enumeration
    //
    WRAP(Status,
         (ApiCreateResEnum(hResource,
                           CLUSTER_RESOURCE_ENUM_DEPENDS,
                           &Enum)),
         Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(FALSE);
    }

    //
    // Open each resource in the dependency and see if it is a network name
    // resource.
    //
    for (i=0; i<Enum->EntryCount; i++) {
        WRAP_NULL(hRes,
                  (ApiOpenResource(Cluster->RpcBinding,
                                   Enum->Entry[i].Name,
                                   &Status)),
                  &Status,
                  Cluster);
        if (hRes != NULL) {
            TypeName = NULL;
            WRAP(Status,
                 (ApiGetResourceType(hRes,
                                     &TypeName)),
                 Cluster);
            if (Status == ERROR_SUCCESS) {
                //
                // See if this type name matches.
                //
                if (lstrcmpiW(TypeName, CLUS_RESTYPE_NAME_NETNAME) == 0) {
                    HRESOURCE NetResource;
                    HKEY NetKey;
                    HKEY NetParamKey;
                    //
                    // We have a match, pull out the Name parameter.
                    // Go ahead and really open the resource so we
                    // can use the registry functions on it.
                    //
                    NetResource = OpenClusterResource((HCLUSTER)Cluster,
                                                      Enum->Entry[i].Name);
                    if (NetResource != NULL) {
                        NetKey = GetClusterResourceKey(NetResource, KEY_READ);
                        CloseClusterResource(NetResource);
                        if (NetKey != NULL) {
                            Status = ClusterRegOpenKey(NetKey,
                                                       CLUSREG_KEYNAME_PARAMETERS,
                                                       KEY_READ,
                                                       &NetParamKey);
                            ClusterRegCloseKey(NetKey);
                            if (Status == ERROR_SUCCESS) {
                                DWORD cbData;


                                cbData = *nSize * sizeof(WCHAR);
                                Status = ClusterRegQueryValue(NetParamKey,
                                                              CLUSREG_NAME_RES_NAME,
                                                              NULL,
                                                              (LPBYTE)lpBuffer,
                                                              &cbData);
                                ClusterRegCloseKey(NetParamKey);
                                if (Status == ERROR_SUCCESS) {
                                    Success = TRUE;
                                    *nSize = wcslen(lpBuffer);
                                }
                            }
                        }
                    }

                } else {

                    //
                    // Try the dependents of this resource
                    //
                    Success = FindNetworkWorker(hRes,
                                                Cluster,
                                                lpBuffer,
                                                nSize);
                }
                MIDL_user_free(TypeName);
            }

            ApiCloseResource(&hRes);
            if (Success) {
                break;
            }
        }
    }

    if (!Success && (Status == ERROR_SUCCESS)) {
        Status = ERROR_DEPENDENCY_NOT_FOUND;
    }
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
    }

    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
    }
    
    MIDL_user_free(Enum);
    return(Success);
}


HCLUSTER
WINAPI
GetClusterFromResource(
    IN HRESOURCE hResource
    )
/*++

Routine Description:

    Returns the cluster handle from the associated resource handle.

Arguments:

    hResource - Supplies the resource.

Return Value:

    Handle to the cluster associated with the resource handle.

--*/

{
    DWORD       nStatus;
    PCRESOURCE  Resource = (PCRESOURCE)hResource;
    HCLUSTER    hCluster = (HCLUSTER)Resource->Cluster;

    nStatus = AddRefToClusterHandle( hCluster );
    if ( nStatus != ERROR_SUCCESS ) {
        SetLastError( nStatus );
        hCluster = NULL;
    }
    return( hCluster );

} // GetClusterFromResource()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tgroup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tgroup.c

Abstract:

    Test for cluster group API

Author:

    John Vert (jvert) 15-Mar-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER Cluster;
    HRESOURCE Resource;
    HGROUP Group;
    HNODE Node;
    HKEY ClusterRoot;
    HCLUSENUM ResEnum;
    DWORD ClusterCountBefore, ClusterCountAfter;
    HGROUPENUM hGroupEnum;
    DWORD GroupCountBefore, GroupCountAfter;
    DWORD i,j;
    DWORD Status;
    WCHAR NameBuf[50];
    DWORD NameLen;
    WCHAR NodeBuf[50];
    DWORD Type;
    CLUSTER_GROUP_STATE GroupState;

    //
    // Dump out group structure for current cluster.
    //
    Cluster = OpenCluster(NULL);
    if (Cluster == NULL) {
        fprintf(stderr, "OpenCluster(NULL) failed %d\n",GetLastError());
        return(0);
    }

    //
    // Dump groups
    //
    printf("\n\nENUMERATING GROUPS\n");
    ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_GROUP);
    if (ResEnum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
        return(0);
    }

  ClusterCountBefore = ClusterGetEnumCount(ResEnum);
  for(i=0; ; i++) {
        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = ClusterEnum(ResEnum,
                             i,
                             &Type,
                             NameBuf,
                             &NameLen);
        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }
        if (Type != CLUSTER_ENUM_GROUP) {
            printf("Invalid Type %d returned from ClusterEnum\n", Type);
            return(0);
        }

        Group = OpenClusterGroup(Cluster, NameBuf);
        if (Group == NULL) {
            fprintf(stderr, "OpenClusterGroup %ws failed %d\n",NameBuf, GetLastError());
            return(0);
        }

        NameLen = sizeof(NodeBuf)/sizeof(WCHAR);
        GroupState = GetClusterGroupState(Group, NodeBuf, &NameLen);
        if (GroupState == -1) {
            fprintf(stderr, "GetClusterGroupState failed %d\n",GetLastError());
            return(0);
        }
        if (GroupState == ClusterGroupOnline) {
            printf("Group %ws is ONLINE at node %ws\n",NameBuf, NodeBuf);
        } else if (GroupState == ClusterGroupOffline) {
            printf("Group %ws is OFFLINE at node %ws\n",NameBuf, NodeBuf);
        } else if (GroupState == ClusterGroupFailed) {
            printf("Group %ws is FAILED at node %ws\n",NameBuf, NodeBuf);
        } else {
            fprintf(stderr, "Group %ws is in unknown state %d on node %ws\n",NameBuf, GroupState, NodeBuf);
        }

        hGroupEnum = ClusterGroupOpenEnum(Group,
                                          CLUSTER_GROUP_ENUM_CONTAINS | CLUSTER_GROUP_ENUM_NODES);
        if (hGroupEnum == NULL) {
            fprintf(stderr, "Group %ws failed to open enum %d\n",NameBuf, GetLastError());
        } else {
            GroupCountBefore = ClusterGroupGetEnumCount(hGroupEnum);
            for (j=0; ; j++) {
                NameLen = sizeof(NameBuf)/sizeof(WCHAR);
                Status = ClusterGroupEnum(hGroupEnum,
                                          j,
                                          &Type,
                                          NameBuf,
                                          &NameLen);
                if (Status == ERROR_NO_MORE_ITEMS) {
                    break;
                } else if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "Failed to enum group item %d, error %d\n",j,Status);
                } else {
                    switch (Type) {
                        case CLUSTER_GROUP_ENUM_NODES:
                            printf("\tpreferred node %ws\n",NameBuf);
                            break;

                        case CLUSTER_GROUP_ENUM_CONTAINS:
                            printf("\tcontains resource %ws\n",NameBuf);
                            break;

                        default:
                            fprintf(stderr, "\tUnknown enum type %d\n",Type);
                            break;
                    }
                }
            }
            if (Status == ERROR_NO_MORE_ITEMS) {
                printf("\nGroup count: %d\n", j);
                GroupCountAfter = ClusterGroupGetEnumCount(hGroupEnum);
                if (GroupCountBefore != GroupCountAfter)
                    fprintf(stderr, "\nReported group count was %d before enumeration, and %d afterward\n", GroupCountBefore, GroupCountAfter);
                else if (j != GroupCountBefore)
                    fprintf(stderr, "\nReported group count: %d\n", GroupCountBefore);
            }
            ClusterGroupCloseEnum(hGroupEnum);
        }

        CloseClusterGroup(Group);

    }
    if (Status == ERROR_NO_MORE_ITEMS) {
        printf("\nCluster count: %d\n", i);
        ClusterCountAfter = ClusterGetEnumCount(ResEnum);
        if (ClusterCountBefore != ClusterCountAfter)
            fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
        else if (i != ClusterCountBefore)
            fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
    }
    ClusterCloseEnum(ResEnum);


    CloseCluster(Cluster);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tgctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster group controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR GroupName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -g group -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  group\tspecifies the name of the group to control\n"
    "  access\tspecifies the access to the group (read, write or any)\n"
    "  ControlCode\ta number between 1 and 99\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'g':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    GroupName = GetString(argv[i]);
                    fprintf(stdout, "Group = %ws\n", GroupName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP  hGroup;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hGroup = OpenClusterGroup(  hClus, GroupName );
    if ( hGroup == NULL ) {
        fprintf(stderr,
                "OpenGroup %ws failed %d\n", GroupName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );

    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

try_again:
    controlCode = CLUSCTL_GROUP_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  &ReturnSize );
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        retry = FALSE;
        goto try_again;
    }

    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  NULL,
                                  0,
                                  buffer,
                                  bufSize,
                                  &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tnet.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tgroup.c

Abstract:

    Test for cluster network API

Author:

    John Vert (jvert) 15-Mar-1996
    Charlie Wickham (charlwi) 6-Jun-1997

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER Cluster;
    HNETWORK Network;
    HNODE Node;
    HCLUSENUM ResEnum;
    DWORD ClusterCountBefore, ClusterCountAfter;
    HNETWORKENUM hNetworkEnum;
    DWORD NetCountBefore, NetCountAfter;
    HNODEENUM hNodeEnum;
    DWORD NodeCountBefore, NodeCountAfter;
    DWORD i,j;
    DWORD Status;
    WCHAR NameBuf[50];
    DWORD NameLen;
    DWORD Type;
    CLUSTER_NETWORK_STATE NetworkState;
    CLUSTER_NODE_STATE NodeState;
    DWORD Count;


    Cluster = OpenCluster(NULL);
    if (Cluster == NULL) {
        fprintf(stderr, "OpenCluster(NULL) failed %d\n",GetLastError());
        return(0);
    }

    //
    // Dump nodes
    //
    printf("\n\nENUMERATING NODES\n");
    ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_NODE);
    if (ResEnum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
        return(0);
    }

    ClusterCountBefore = ClusterGetEnumCount(ResEnum);
    for(i=0; ; i++) {
        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = ClusterEnum(ResEnum,
                             i,
                             &Type,
                             NameBuf,
                             &NameLen);
        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }
        if (Type != CLUSTER_ENUM_NODE) {
            printf("Invalid Type %d returned from ClusterEnum\n", Type);
            return(0);
        }

        fprintf(stderr, "\nOpening Node: %ws\n", NameBuf);

        Node = OpenClusterNode(Cluster, NameBuf);
        if (Node == NULL) {
            fprintf(stderr, "OpenClusterNode %ws failed %d\n",NameBuf, GetLastError());
            return(0);
        }

        NodeState = GetClusterNodeState(Node);
        if (NodeState == -1) {

            Status = GetLastError();
            if ( Status != ERROR_SUCCESS )
                fprintf(stderr, "GetClusterNodeState failed %d\n", Status);
        }

        if (NodeState == ClusterNodeUp) {
            printf("Node %ws is UP\n", NameBuf);
        } else if (NodeState == ClusterNodeDown) {
            printf("Node %ws is DOWN\n", NameBuf );
        }

        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = GetClusterNodeId( Node, NameBuf, &NameLen );

        if (Status == ERROR_SUCCESS) {
            fprintf(stderr, "Node ID: %ws\n", NameBuf );
        } else {
            Status = GetLastError();
            fprintf(stderr, "GetClusterNodeId failed %d\n", Status);
        }

        hNodeEnum = ClusterNodeOpenEnum(Node,
                                              CLUSTER_NODE_ENUM_NETINTERFACES);
        if (hNodeEnum == NULL) {
            fprintf(stderr, "Node %ws failed to open enum %d\n",NameBuf, GetLastError());
        } else {
            NodeCountBefore = ClusterNodeGetEnumCount(hNodeEnum);
            for (j=0; ; j++) {
                NameLen = sizeof(NameBuf)/sizeof(WCHAR);
                Status = ClusterNodeEnum(hNodeEnum,
                                            j,
                                            &Type,
                                            NameBuf,
                                            &NameLen);

                if (Status == ERROR_NO_MORE_ITEMS) {
                    break;
                } else if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "Failed to enum node item %d, error %d\n",j,Status);
                }
                if (Type != CLUSTER_NODE_ENUM_NETINTERFACES) {
                    printf("Invalid Type %d returned from ClusterNodeEnum\n", Type);
                    return(0);
                }

                printf("\tInterface %ws\n",NameBuf);
            }
            if (Status == ERROR_NO_MORE_ITEMS) {
                printf("\nNode count: %d\n", j);
                NodeCountAfter = ClusterNodeGetEnumCount(hNodeEnum);
                if (NodeCountBefore != NodeCountAfter)
                    fprintf(stderr, "\nReported node count was %d before enumeration, and %d afterward\n", NodeCountBefore, NodeCountAfter);
                else if (j != NodeCountBefore)
                    fprintf(stderr, "\nReported node count: %d\n", NodeCountBefore);
            }
            ClusterNodeCloseEnum(hNodeEnum);
        }

        CloseClusterNode(Node);

    }
    if (Status == ERROR_NO_MORE_ITEMS) {
        printf("\nCluster count: %d\n", i);
        ClusterCountAfter = ClusterGetEnumCount(ResEnum);
        if (ClusterCountBefore != ClusterCountAfter)
            fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
        else if (i != ClusterCountBefore)
            fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
    }

    ClusterCloseEnum(ResEnum);

    //
    // Dump networks
    //
    printf("\n\nENUMERATING NETWORKS\n");
    ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_NETWORK);
    if (ResEnum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
        return(0);
    }

    ClusterCountBefore = ClusterGetEnumCount(ResEnum);
    for(i=0; ; i++) {
        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = ClusterEnum(ResEnum,
                             i,
                             &Type,
                             NameBuf,
                             &NameLen);
        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }
        if (Type != CLUSTER_ENUM_NETWORK) {
            printf("Invalid Type %d returned from ClusterEnum\n", Type);
            return(0);
        }

        fprintf(stderr, "\nOpening Network: %ws\n", NameBuf);

        Network = OpenClusterNetwork(Cluster, NameBuf);
        if (Network == NULL) {
            fprintf(stderr, "OpenClusterNetwork %ws failed %d\n",NameBuf, GetLastError());
            return(0);
        }

        NetworkState = GetClusterNetworkState(Network);
        if (NetworkState == -1) {

            Status = GetLastError();
            if ( Status != ERROR_SUCCESS )
                fprintf(stderr, "GetClusterNetworkState failed %d\n", Status);
        }

        if (NetworkState == ClusterNetworkUp) {
            printf("Network %ws is UP\n", NameBuf);
        } else if (NetworkState == ClusterNetworkPartitioned) {
            printf("Network %ws is PARTITIONED\n", NameBuf );
        } else if (NetworkState == ClusterNetworkDown) {
            printf("Network %ws is DOWN\n", NameBuf );
        } else if (NetworkState == ClusterNetworkStateUnknown) {
            printf("Network %ws is UNKNOWN\n", NameBuf );
        } else if (NetworkState == ClusterNetworkUnavailable) {
            printf("Network %ws is UNAVAILABLE\n", NameBuf );
        }

        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = GetClusterNetworkId( Network, NameBuf, &NameLen );

        if (Status == ERROR_SUCCESS) {
            fprintf(stderr, "Network ID: %ws\n", NameBuf );
        } else {
            Status = GetLastError();
            fprintf(stderr, "GetClusterNetworkId failed %d\n", Status);
        }

        hNetworkEnum = ClusterNetworkOpenEnum(Network,
                                              CLUSTER_NETWORK_ENUM_NETINTERFACES);
        if (hNetworkEnum == NULL) {
            fprintf(stderr, "Network %ws failed to open enum %d\n",NameBuf, GetLastError());
        } else {
            NetCountBefore = ClusterNetworkGetEnumCount(hNetworkEnum);
            for (j=0; ; j++) {
                NameLen = sizeof(NameBuf)/sizeof(WCHAR);
                Status = ClusterNetworkEnum(hNetworkEnum,
                                            j,
                                            &Type,
                                            NameBuf,
                                            &NameLen);

                if (Status == ERROR_NO_MORE_ITEMS) {
                    break;
                } else if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "Failed to enum network item %d, error %d\n",j,Status);
                }
                if (Type != CLUSTER_NETWORK_ENUM_NETINTERFACES) {
                    printf("Invalid Type %d returned from ClusterNetworkEnum\n", Type);
                    return(0);
                }

                printf("\tInterface %ws\n",NameBuf);
            }
            if (Status == ERROR_NO_MORE_ITEMS) {
                printf("\nNetwork count: %d\n", j);
                NetCountAfter = ClusterNetworkGetEnumCount(hNetworkEnum);
                if (NetCountBefore != NetCountAfter)
                    fprintf(stderr, "\nReported network count was %d before enumeration, and %d afterward\n", NetCountBefore, NetCountAfter);
                else if (j != NetCountBefore)
                    fprintf(stderr, "\nReported network count: %d\n", NetCountBefore);
            }
            ClusterNetworkCloseEnum(hNetworkEnum);
        }

        CloseClusterNetwork(Network);

    }
    if (Status == ERROR_NO_MORE_ITEMS) {
        printf("\nCluster count: %d\n", i);
        ClusterCountAfter = ClusterGetEnumCount(ResEnum);
        if (ClusterCountBefore != ClusterCountAfter)
            fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
        else if (i != ClusterCountBefore)
            fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
    }

    ClusterCloseEnum(ResEnum);

    printf("\n\nCURRENT INTERNAL NETWORK PRIORITY ORDER\n");

    ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_INTERNAL_NETWORK);

    if (ResEnum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
        return(0);
    }

    ClusterCountBefore = ClusterGetEnumCount(ResEnum);
    for(i=0, Count=0; ; i++) {
        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = ClusterEnum(ResEnum,
                             i,
                             &Type,
                             NameBuf,
                             &NameLen);

        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }

        printf("%ws\n", NameBuf);
        Count++;
    }
    if (Status == ERROR_NO_MORE_ITEMS) {
        printf("\nCluster count: %d\n", i);
        ClusterCountAfter = ClusterGetEnumCount(ResEnum);
        if (ClusterCountBefore != ClusterCountAfter)
            fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
        else if (i != ClusterCountBefore)
            fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
    }

    ClusterCloseEnum(ResEnum);

    if (Count != 0) {
        DWORD       newIndex;
        HNETWORK *  NetworkList = LocalAlloc(
                                      LMEM_FIXED | LMEM_ZEROINIT,
                                      sizeof(HNETWORK) * Count
                                      );

        if (NetworkList == NULL) {
            fprintf(stderr, "Out of memory\n");
            return(0);
        }

        ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_INTERNAL_NETWORK);

        if (ResEnum == NULL) {
            fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
            return(0);
        }

        ClusterCountBefore = ClusterGetEnumCount(ResEnum);
        for(i=0; ; i++) {
            NameLen = sizeof(NameBuf)/sizeof(WCHAR);
            Status = ClusterEnum(ResEnum,
                                 i,
                                 &Type,
                                 NameBuf,
                                 &NameLen);

            if (Status == ERROR_NO_MORE_ITEMS) {
                break;
            } else if (Status != ERROR_SUCCESS) {
                fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
                return(0);
            }

            if (i == Count) {
                fprintf(stderr, "Another network was added after we counted.\n");
                return(0);
            }

            newIndex = (i+1) % Count;
            NetworkList[newIndex] = OpenClusterNetwork(Cluster, NameBuf);

            if (NetworkList[newIndex] == NULL) {
                fprintf(stderr, "OpenClusterNetwork %ws failed %d\n",NameBuf, GetLastError());
                return(0);
            }
        }
        if (Status == ERROR_NO_MORE_ITEMS) {
            printf("\nCluster count: %d\n", i);
            ClusterCountAfter = ClusterGetEnumCount(ResEnum);
            if (ClusterCountBefore != ClusterCountAfter)
                fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
            else if (i != ClusterCountBefore)
                fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
        }

        ClusterCloseEnum(ResEnum);

        Status = SetClusterNetworkPriorityOrder(
                     Cluster,
                     Count,
                     NetworkList
                     );

        if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "SetClusterNetworkPriorityOrder failed %d\n", Status);
            return(0);
        }

        for (i=0; i<Count; i++) {
            if (NetworkList[i] != NULL) {
                CloseClusterNetwork(NetworkList[i]);
            }
        }

        printf("\n\nNEW INTERNAL NETWORK PRIORITY ORDER\n");

        ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_INTERNAL_NETWORK);

        if (ResEnum == NULL) {
            fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
            return(0);
        }

        ClusterCountBefore = ClusterGetEnumCount(ResEnum);
        for(i=0; ; i++) {
            NameLen = sizeof(NameBuf)/sizeof(WCHAR);
            Status = ClusterEnum(ResEnum,
                                 i,
                                 &Type,
                                 NameBuf,
                                 &NameLen);

            if (Status == ERROR_NO_MORE_ITEMS) {
                break;
            } else if (Status != ERROR_SUCCESS) {
                fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
                return(0);
            }

            printf("%ws\n", NameBuf);
        }
        if (Status == ERROR_NO_MORE_ITEMS) {
            printf("\nCluster count: %d\n", i);
            ClusterCountAfter = ClusterGetEnumCount(ResEnum);
            if (ClusterCountBefore != ClusterCountAfter)
                fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
            else if (i != ClusterCountBefore)
                fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
        }

        ClusterCloseEnum(ResEnum);
    }

    CloseCluster(Cluster);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tgloop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster group controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR GroupName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -g group -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  group\tspecifies the name of the group to control\n"
    "  access\tspecifies the access to the group (read, write or any)\n"
    "  ControlCode\ta number between 1 and 99\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'g':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    GroupName = GetString(argv[i]);
                    fprintf(stdout, "Group = %ws\n", GroupName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP  hGroup;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;
    DWORD   inputSize;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hGroup = OpenClusterGroup(  hClus, GroupName );
    if ( hGroup == NULL ) {
        fprintf(stderr,
                "OpenGroup %ws failed %d\n", GroupName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );

    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

try_again:
    controlCode = CLUSCTL_GROUP_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  &ReturnSize );
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        retry = FALSE;
        goto try_again;
    }

    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  NULL,
                                  0,
                                  buffer,
                                  bufSize,
                                  &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        inputSize = ReturnSize;
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
        switch ( controlCode ) {

        case  CLUSCTL_GROUP_GET_COMMON_PROPERTIES:
            controlCode = CLUSCTL_GROUP_SET_COMMON_PROPERTIES;
            break;

        case CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES:
            controlCode = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;
            break;

        default:
            controlCode = 0;
            break;
        }
        if ( controlCode != 0 ) {
            status = ClusterGroupControl( hGroup,
                                          hNode,
                                          controlCode,
                                          buffer,
                                          inputSize,
                                          NULL,
                                          0,
                                          &ReturnSize );
        }
        fprintf(stdout, "Status of *INPUT* Control request = %d, size = %d\n",
            status, ReturnSize);
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tformat.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR ResourceName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -r resource -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  resource\tspecifies the name of the resource to control\n"
    "  access\tspecifies the access to the resource (read write or any)\n"
    "  ControlCode\ta number between 1 and 9\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'r':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    ResourceName = GetString(argv[i]);
                    fprintf(stdout, "Resource = %ws\n", ResourceName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) == 0 ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) == 0 ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) == 0 ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    return;
    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hResource = OpenClusterResource(  hClus, ResourceName );
    if ( hResource == NULL ) {
        fprintf(stderr,
                "OpenResource %ws failed %d\n", ResourceName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

#if 0
    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );
    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

    controlCode = CLUSCTL_RESOURCE_CODE( controlCode );

try_again:
#endif

    controlCode = CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS;

    ReturnSize = 0;
    status = ClusterResourceControl( hResource,
                                     hNode,
                                     controlCode,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     &ReturnSize );
#if 0
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        retry = FALSE;
        goto try_again;
    }
#endif

    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterResourceControl( hResource,
                                     hNode,
                                     controlCode,
                                     NULL,
                                     0,
                                     buffer,
                                     bufSize,
                                     &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tfmt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR ResourceTypeName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TFMT [-c cluster] -n node -r restypename -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  restypename\tspecifies the name of the resource type to control\n"
    "  access\tspecifies the access to the resource (read write or any)\n"
    "  ControlCode\ta number between 1 and 9\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'r':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    ResourceTypeName = GetString(argv[i]);
                    fprintf(stdout, "ResourceType = %ws\n", ResourceTypeName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) == 0 ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) == 0 ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) == 0 ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    return;
    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

#if 0
    hResource = OpenClusterResource(  hClus, ResourceTypeName );
    if ( hResource == NULL ) {
        fprintf(stderr,
                "OpenResource %ws failed %d\n", ResourceTypeName, GetLastError());
        return(0);
    }
#endif

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

#if 0
    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );
    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

    controlCode = CLUSCTL_RESOURCE_CODE( controlCode );

try_again:
#endif

    controlCode = CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS;

    ReturnSize = 0;
    status = ClusterResourceTypeControl( hClus,
                                     ResourceTypeName,
                                     hNode,
                                     controlCode,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     &ReturnSize );
#if 0
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        retry = FALSE;
        goto try_again;
    }
#endif

    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterResourceTypeControl( hClus,
                                     ResourceTypeName,
                                     hNode,
                                     controlCode,
                                     NULL,
                                     0,
                                     buffer,
                                     bufSize,
                                     &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tgin.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster group controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR GroupName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

#if 1
typedef struct _PROP_ITEM_16 {
    DWORD   NameType;
    DWORD   NameLength;
    WCHAR   PI[16];
} PROP_ITEM_16;

typedef struct _PROP_ITEM_18 {
    DWORD   NameType;
    DWORD   NameLength;
    WCHAR   PI[18];
} PROP_ITEM_18;

typedef struct _PROP_ITEM_20 {
    DWORD   NameType;
    DWORD   NameLength;
    WCHAR   PI[20];
} PROP_ITEM_20;

typedef struct _PROP_ITEM_ALIGN_15 {
    DWORD   NameType;
    DWORD   NameLength;
    WCHAR   PI[15];
    WCHAR   _align;
} PROP_ITEM_ALIGN_15;

typedef struct _PROP_ITEM_ALIGN_17 {
    DWORD   NameType;
    DWORD   NameLength;
    WCHAR   PI[17];
    WCHAR   _align;
} PROP_ITEM_ALIGN_17;

typedef struct _PROP_DWORD_VALUE {
    DWORD   ValueType;
    DWORD   ValueLength;
    DWORD   Value;
    DWORD   align;
} PROP_DWORD_VALUE;

typedef struct _PROP_LIST {
    DWORD   ItemCount;
    PROP_ITEM_16 PropItem1;         // PersistentState (16 chars)
    PROP_DWORD_VALUE PropValue1;
    PROP_ITEM_18 PropItem2;         // FailoverThreshold (18 chars)
    PROP_DWORD_VALUE PropValue2;
    PROP_ITEM_ALIGN_15 PropItem3;   // FailoverPeriod (15 chars)
    PROP_DWORD_VALUE PropValue3;
    PROP_ITEM_ALIGN_17 PropItem4;   // AutoFailbackType (17 chars)
    PROP_DWORD_VALUE PropValue4;
    PROP_ITEM_20 PropItem5;         // FailbackWindowStart (20 chars)
    PROP_DWORD_VALUE PropValue5;
    PROP_ITEM_18 PropItem6;         // FailbackWindowEnd (18 chars)
    PROP_DWORD_VALUE PropValue6;
    DWORD   EndValue2;
} PROP_LIST;
#pragma warning( default : 4200 )
#endif

#if 1
PROP_LIST PropList = {
    0x00000006, // # of parameters
    0x00040003,
    0x00000020,
    L"PersistentState",
    0x00010002,
    0x00000004,
    0x00000001, // State is on
    0x00000000,
    0x00040003, // Name
    0x00000024, // Name Length
    L"FailoverThreshold",
    0x00010002,
    0x00000004,
    0x0000000a, // Failover count is 10
    0x00000000,
    0x00040003, // Name
    0x0000001e, // Name Length
    L"FailoverPeriod", // Not a multiple of 4 bytes
    0x0,        // alignment needed
    0x00010002,
    0x00000004,
    0x00000006,
    0x00000000,
    0x00040003,
    0x00000022,
    L"AutoFailbackType", // Not a multiple of 4 bytes
    0x0,        // alignment needed
    0x00010002,
    0x00000004,
    0x00000000,
    0x00000000,
    0x00040003, // Name
    0x00000028, // Name Length
    L"FailbackWindowStart",
    0x00010002,
    0x00000004,
    0x2,
    0x00000000,
    0x00040003, // Name
    0x00000024, // Name Length
    L"FailbackWindowEnd",
    0x00010002,
    0x00000004,
    0x3,
    0x00000000,
    0x00000000 };
#else
DWORD PropList[] = {
   0x00000006, 0x00040003, 0x00000020, 0x00650050,
   0x00730072, 0x00730069, 0x00650074, 0x0074006e,
   0x00740053, 0x00740061, 0x00000065, 0x00010002,
   0x00000004, 0x00000001, 0x00000000, 0x00040003,
   0x00000024, 0x00610046, 0x006c0069, 0x0076006f,
   0x00720065, 0x00680054, 0x00650072, 0x00680073,
   0x006c006f, 0x00000064, 0x00010002, 0x00000004,
   0x0000000a, 0x00000000, 0x00040003, 0x0000001e,
   0x00610046, 0x006c0069, 0x0076006f, 0x00720065,
   0x00650050, 0x00690072, 0x0064006f, 0x00000000, // Alignment needed 4th dword
   0x00010002, 0x00000004, 0x00000006, 0x00000000,
   0x00040003, 0x00000022, 0x00750041, 0x006f0074,
   0x00610046, 0x006c0069, 0x00610062, 0x006b0063,
   0x00790054, 0x00650070, 0x00000000, 0x00010002, // Alignment needed 3rd dword
   0x00000004, 0x00000000, 0x00000000, 0x00040003,
   0x00000028, 0x00610046, 0x006c0069, 0x00610062,
   0x006b0063, 0x00690057, 0x0064006e, 0x0077006f,
   0x00740053, 0x00720061, 0x00000074, 0x00010002,
   0x00000004, 0x2, 0x00000000, 0x00040003,
   0x00000024, 0x00610046, 0x006c0069, 0x00610062,
   0x006b0063, 0x00690057, 0x0064006e, 0x0077006f,
   0x006e0045, 0x00000064, 0x00010002, 0x00000004,
   0x3, 0x00000000, 0x00000000 };
#endif

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -g group -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  group\tspecifies the name of the group to control\n"
    "  access\tspecifies the access to the group (read, write or any)\n"
    "  ControlCode\ta number between 1 and 99\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'g':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    GroupName = GetString(argv[i]);
                    fprintf(stdout, "Group = %ws\n", GroupName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP  hGroup;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;
    DWORD   inputSize;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hGroup = OpenClusterGroup(  hClus, GroupName );
    if ( hGroup == NULL ) {
        fprintf(stderr,
                "OpenGroup %ws failed %d\n", GroupName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );

    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

try_again:
    controlCode = CLUSCTL_GROUP_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  &ReturnSize );
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        retry = FALSE;
        goto try_again;
    }

    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  NULL,
                                  0,
                                  buffer,
                                  bufSize,
                                  &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        inputSize = ReturnSize;
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
        switch ( controlCode ) {

        case  CLUSCTL_GROUP_GET_COMMON_PROPERTIES:
            controlCode = CLUSCTL_GROUP_SET_COMMON_PROPERTIES;
            break;

        case CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES:
            controlCode = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;
            break;

        default:
            controlCode = 0;
            break;
        }
        if ( controlCode != 0 ) {
            status = ClusterGroupControl( hGroup,
                                          hNode,
                                          controlCode,
                                          &PropList,
                                          sizeof(PropList),
                                          NULL,
                                          0,
                                          &ReturnSize );
        }
        fprintf(stdout, "Status of *INPUT* Control request = %d, insize = %d, retsize = %d\n",
            status, sizeof(PropList), ReturnSize);
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tgtype.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster group controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR GroupName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

#pragma warning( disable : 4200 )       // zero length arrays

#define CLUS_VALUE_SPECIAL_SZ 0x10003

#define TYPE_NAME L"Type"
#define TYPE_SIZE ( (sizeof(TYPE_NAME)+1) / sizeof(WCHAR) )
#define TYPE_REMAINDER ( (TYPE_SIZE + sizeof(DWORD)) & 3)

#define VALUE_NAME L"Oracle"
#define VALUE_SIZE ( (sizeof(VALUE_NAME)+1) / sizeof(WCHAR) )
#define VALUE_REMAINDER ( (VALUE_SIZE + sizeof(DWORD)) & 3)

//
// Set the private property for a group to be "Type: REG_SZ: Oracle"
//
typedef struct _IN_BUFFER {
    DWORD   ItemCount;
    DWORD   Syntax;
    DWORD   TypeLength;
    WCHAR   Type[TYPE_SIZE];
    WCHAR   TypeRemainder[TYPE_REMAINDER];
    DWORD   ValueType;
    DWORD   ValueLength;
    WCHAR   Value[VALUE_SIZE];
    WCHAR   ValueRemainder[VALUE_REMAINDER];
    DWORD   Terminator;
} IN_BUFFER, *PIN_BUFFER;

IN_BUFFER InBuffer[] = {
    1,
    CLUSPROP_SYNTAX_NAME,
    TYPE_SIZE * sizeof(WCHAR),
    TYPE_NAME,
    0,
    CLUS_VALUE_SPECIAL_SZ,
    VALUE_SIZE * sizeof(WCHAR),
    VALUE_NAME,
    0,
    0 };

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -g group -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  group\tspecifies the name of the group to control\n"
    "  access\tspecifies the access to the group (read, write or any)\n"
    "  ControlCode\ta number between 1 and 99\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'g':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    GroupName = GetString(argv[i]);
                    fprintf(stdout, "Group = %ws\n", GroupName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP  hGroup;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;
    DWORD   inputSize;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hGroup = OpenClusterGroup(  hClus, GroupName );
    if ( hGroup == NULL ) {
        fprintf(stderr,
                "OpenGroup %ws failed %d\n", GroupName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    controlCode = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;

    ReturnSize = 0;
    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  InBuffer,
                                  sizeof(IN_BUFFER),
                                  NULL,
                                  0,
                                  &ReturnSize );
    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tnode.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TNODE [-c cluster] -n node ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  ControlCode\ta number between 1 and 9\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    fprintf(stdout, "Node = %ws\n", NodeName);
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hNode = OpenClusterNode( hClus, NodeName );
    if ( hNode == NULL ) {
        fprintf(stderr,
                "OpenNode %ws failed %d\n", NodeName, GetLastError());
        return(0);
    }

    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );
    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

try_again:
    controlCode = CLUSCTL_NODE_CODE( controlCode);

    ReturnSize = 0;
    status = ClusterNodeControl( hNode,
                                 NULL,
                                 controlCode,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &ReturnSize );
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        retry = FALSE;
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        goto try_again;
    }
    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterNodeControl( hNode,
                                 NULL,
                                 controlCode,
                                 NULL,
                                 0,
                                 buffer,
                                 bufSize,
                                 &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tset.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR ResourceName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TSET [-c cluster] -n node -r resource -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  resource\tspecifies the name of the resource to control\n"
    "  access\tspecifies the access mode (read write or any)\n"
    "  ControlCode\ta number between 1 and 9\n";


typedef struct _PROPERTY_MSG {
    DWORD   ItemCount;
    DWORD   Syntax1;
    DWORD   ParameterName1ByteCount;
    WCHAR   ParameterName1[20];
    DWORD   Syntax2;            // Dword Data Item to follow
    DWORD   Data;               // New value
    DWORD   Syntax3;
    DWORD   ParameterName2ByteCount;
    WCHAR   ParameterName2[12];
    DWORD   Syntax4;            // SZ string to follow
    DWORD   ParameterName3ByteCount;
    WCHAR   ParameterName3[8];
} PROPERTY_MSG, PPROPERTY_MSG;

PROPERTY_MSG
PropertyMsg = { 2, 0x40003, 40, L"IsAlivePollInterval", 0x10002, 0x2000, 0x40003, 24, L"Description", 0x10003, 16, L"Testing" };

    
void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'r':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    ResourceName = GetString(argv[i]);
                    fprintf(stdout, "Resource = %ws\n", ResourceName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    CHAR    InBuffer[64];
    CHAR    OutBuffer[512];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    DWORD   controlCode;
    DWORD   modify;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hResource = OpenClusterResource(  hClus, ResourceName );
    if ( hResource == NULL ) {
        fprintf(stderr,
                "OpenResource %ws failed %d\n", ResourceName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    switch ( Access ) {
    case CLUS_ACCESS_READ:
        modify = CLUS_NO_MODIFY;
        break;
    case CLUS_ACCESS_WRITE:
        modify = CLUS_MODIFY;
        break;
    case CLUS_ACCESS_ANY:
        modify = CLUS_NO_MODIFY;
        break;
    }

    controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, modify );
    controlCode = CLUSCTL_RESOURCE_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterResourceControl( hResource,
                                     hNode,
                                     controlCode,
                                     &PropertyMsg,
                                     sizeof(PROPERTY_MSG),
                                     OutBuffer,
                                     0,
                                     &ReturnSize );
    if (( status == ERROR_MORE_DATA ) || ( ReturnSize != 0 )) {
        fprintf(stdout, "Calling again due to buffer size too small (status = %d)\n", status);
        status = ClusterResourceControl( hResource,
                                         hNode,
                                         controlCode,
                                         &PropertyMsg,
                                         sizeof(PROPERTY_MSG),
                                         OutBuffer,
                                         ReturnSize,
                                         &ReturnSize );
    }

    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)OutBuffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            for ( i = 0; i < 4; i++ ) {
                if ( !ReturnSize )
                    fprintf(stdout, "         ");
                else {
                    fprintf(stdout, " %08lx", PrintData[i]);
                    ReturnSize -= 4;
                }
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                if ( j ) {
                    fprintf(stdout, "%c",
                     isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
                    j--;
                }
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tnotify.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tnotify.c

Abstract:

    Test for cluster notification API

Author:

    John Vert (jvert) 9-Apr-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "conio.h"

#define NOTIFY_KEY_ALL 27
#define NOTIFY_KEY_GROUP 38
#define NOTIFY_KEY_RESOURCE 42
#define NOTIFY_KEY_NODE 1032
#define NOTIFY_KEY_REGISTRY 0xabcdef
#define NOTIFY_KEY_REGISTRY_GROUP 0x1234
#define NOTIFY_KEY_REGISTRY_RESOURCE 0x5678
#define NOTIFY_KEY_CLUSTER_RECONNECT 0x89AB

#define MAX_HANDLES 64

HNODE NodeHandles[MAX_HANDLES];
HRESOURCE ResourceHandles[MAX_HANDLES];
HGROUP GroupHandles[MAX_HANDLES];
HKEY RegistryHandles[MAX_HANDLES];


DWORD NodeHandleCount=0;
DWORD ResourceHandleCount=0;
DWORD GroupHandleCount=0;
DWORD RegistryHandleCount=0;

int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER Cluster;
    HCHANGE hChange;
    DWORD NotifyKey;
    DWORD Filter;
    WCHAR Buffer[50];
    ULONG BufSize;
    DWORD Status;
    HCLUSENUM Enum;
    DWORD i;
    DWORD Type;
    HGROUP Group;
    HRESOURCE Resource;
    HNODE Node;
    HKEY ClusterKey;
	WCHAR	szClusterName[MAX_COMPUTERNAME_LENGTH + 1] ;
	LPWSTR  lpszClusterName = NULL ;

/*
Added by Karthikl
*/
	if(argc > 1)
	{
		if(_strnicmp(argv[1], "-?", 2) == 0 || _strnicmp(argv[1], "/?", 2) == 0)
		{
			printf("tnotify.exe <clustername>\n") ;
			printf("Test program to check the notification stuff\n") ;
			printf("Run with a cluster name if running from a client machine\n") ;
			return ERROR_SUCCESS ;
		}
		else
		{
			int result = MultiByteToWideChar(CP_ACP, 
											0, 
											argv[1], 
											-1, 
											szClusterName,
											MAX_COMPUTERNAME_LENGTH + 1) ;
			if(result)
			{
				lpszClusterName = szClusterName ;
			}
			else
			{
				Status = GetLastError() ;
				fprintf(stderr, "MultiByteToWideChar failed %d\n", Status);
				return Status ;
			}
		}
	}
// end karthikl
// CLUSTER_CHANGE_CLUSTER_RECONNECT

    //
    // Get notifications for current cluster.
    //
    Cluster = OpenCluster(lpszClusterName);
    if (Cluster == NULL) {
        fprintf(stderr, "OpenCluster failed %d\n",GetLastError());
        return(0);
    }

    hChange = CreateClusterNotifyPort(INVALID_HANDLE_VALUE,
                                      INVALID_HANDLE_VALUE,
                                      CLUSTER_CHANGE_ALL,
                                      NOTIFY_KEY_ALL);
    if (hChange == NULL) {
        fprintf(stderr, "First CreateClusterNotifyPort failed %d\n",GetLastError());
        return(0);
    }

    hChange = CreateClusterNotifyPort(hChange,
                                      Cluster,
                                      CLUSTER_CHANGE_ALL,
                                      NOTIFY_KEY_ALL);
    if (hChange == NULL) {
        fprintf(stderr, "Second CreateClusterNotifyPort failed %d\n",GetLastError());
        return(0);
    }

    //
    // Post a notification for the root of the cluster registry.
    //
    ClusterKey = GetClusterKey(Cluster, KEY_READ);
    if (ClusterKey == NULL) {
        fprintf(stderr, "GetClusterKey failed %d\n",GetLastError());
        return(0);
    }
    RegistryHandles[RegistryHandleCount++] = ClusterKey;
    Status = RegisterClusterNotify(hChange,
                                   CLUSTER_CHANGE_REGISTRY_NAME            |
                                   CLUSTER_CHANGE_REGISTRY_ATTRIBUTES      |
                                   CLUSTER_CHANGE_REGISTRY_VALUE           |
                                   CLUSTER_CHANGE_REGISTRY_SUBTREE         |
                                   CLUSTER_CHANGE_HANDLE_CLOSE,
                                   ClusterKey,
                                   NOTIFY_KEY_REGISTRY);
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "RegisterClusterNotify for key failed %d\n",Status);
    }

    //
    // Enumerate nodes, groups, and resources and post a specific
    // notification for each one.
    //
    Enum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_NODE |
                                    CLUSTER_ENUM_RESOURCE |
                                    CLUSTER_ENUM_GROUP);
    if (Enum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n", GetLastError());
        return(0);
    }
    for (i=0; ; i++) {
        BufSize = sizeof(Buffer) / sizeof(WCHAR);
        Status = ClusterEnum(Enum,
                             i,
                             &Type,
                             Buffer,
                             &BufSize);

        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }
        switch (Type) {
            case CLUSTER_ENUM_GROUP:
                Group = OpenClusterGroup(Cluster, Buffer);
                if (Group == NULL) {
                    fprintf(stderr, "OpenClusterGroup %ws failed %d\n",Buffer, GetLastError());
                    continue;
                }
                GroupHandles[GroupHandleCount++] = Group;
                Status = RegisterClusterNotify(hChange,
                                               CLUSTER_CHANGE_GROUP_STATE | CLUSTER_CHANGE_HANDLE_CLOSE,
                                               Group,
                                               NOTIFY_KEY_GROUP);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "RegisterClusterNotify for group %ws failed %d\n",Buffer,Status);
                    continue;
                }
                ClusterKey = GetClusterGroupKey(Group, KEY_READ);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "GetClusterGroupKey for group %ws failed %d\n",Buffer,GetLastError());
                    continue;
                }
                RegistryHandles[RegistryHandleCount++] = ClusterKey;

                Status = RegisterClusterNotify(hChange,
                                               CLUSTER_CHANGE_REGISTRY_NAME            |
                                               CLUSTER_CHANGE_REGISTRY_ATTRIBUTES      |
                                               CLUSTER_CHANGE_REGISTRY_VALUE           |
                                               CLUSTER_CHANGE_REGISTRY_SUBTREE         |
                                               CLUSTER_CHANGE_HANDLE_CLOSE,
                                               ClusterKey,
                                               NOTIFY_KEY_REGISTRY_GROUP);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr,
                            "RegisterClusterNotify for group %ws key failed %d\n",
                            Buffer,
                            Status);
                }
                break;

            case CLUSTER_ENUM_RESOURCE:
                Resource = OpenClusterResource(Cluster, Buffer);
                if (Resource == NULL) {
                    fprintf(stderr, "OpenClusterResource %ws failed %d\n",Buffer, GetLastError());
                    continue;
                }
                ResourceHandles[ResourceHandleCount++] = Resource;
                Status = RegisterClusterNotify(hChange,
                                               CLUSTER_CHANGE_RESOURCE_STATE | CLUSTER_CHANGE_HANDLE_CLOSE,
                                               Resource,
                                               NOTIFY_KEY_RESOURCE);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "RegisterClusterNotify for resource %ws failed %d\n",Buffer,Status);
                    continue;
                }
                ClusterKey = GetClusterResourceKey(Resource, KEY_READ);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "GetClusterResourceKey for resource %ws failed %d\n",Buffer,GetLastError());
                    continue;
                }
                RegistryHandles[RegistryHandleCount++] = ClusterKey;

                Status = RegisterClusterNotify(hChange,
                                               CLUSTER_CHANGE_REGISTRY_NAME            |
                                               CLUSTER_CHANGE_REGISTRY_ATTRIBUTES      |
                                               CLUSTER_CHANGE_REGISTRY_VALUE           |
                                               CLUSTER_CHANGE_REGISTRY_SUBTREE         |
                                               CLUSTER_CHANGE_HANDLE_CLOSE,
                                               ClusterKey,
                                               NOTIFY_KEY_REGISTRY_RESOURCE);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr,
                            "RegisterClusterNotify for resource %ws key failed %d\n",
                            Buffer,
                            Status);
                }
                break;

            case CLUSTER_ENUM_NODE:
                Node = OpenClusterNode(Cluster, Buffer);
                if (Node == NULL) {
                    fprintf(stderr, "OpenClusterNode %ws failed %d\n",Buffer, GetLastError());
                    continue;
                }
                NodeHandles[NodeHandleCount++] = Node;
                Status = RegisterClusterNotify(hChange,
                                               CLUSTER_CHANGE_NODE_STATE | CLUSTER_CHANGE_NODE_DELETED | CLUSTER_CHANGE_HANDLE_CLOSE,
                                               Node,
                                               NOTIFY_KEY_NODE);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "RegisterClusterNotify for node %ws failed %d\n",Buffer,Status);
                    continue;
                }
                break;

            default:
                fprintf(stderr, "Invalid Type %d returned from ClusterEnum\n", Type);
                return(0);
        }
    }



	// finally register the notification event for CLUSTER_CHANGE_CLUSTER_RECONNECT
	if(lpszClusterName != NULL) // implies we are connecting from a client
	{
		Status = RegisterClusterNotify(hChange,
									   CLUSTER_CHANGE_CLUSTER_RECONNECT|CLUSTER_CHANGE_CLUSTER_STATE,
									   Cluster,
									   NOTIFY_KEY_CLUSTER_RECONNECT);
		if (Status != ERROR_SUCCESS) 
		{
			fprintf(stderr, "RegisterClusterNotify for CLUSTER_CHANGE_CLUSTER_RECONNECT failed %d\n",Status);
		}
		else
		{
			fprintf(stderr, "Success registering CLUSTER_CHANGE_CLUSTER_RECONNECT\n");
		}
	}

    //
    // Just read out changes forever
    //
    printf("Waiting for notification events\n");

    while (!_kbhit()) {
        BufSize = sizeof(Buffer) / sizeof(WCHAR);

        Status = GetClusterNotify(hChange,
                                  &NotifyKey,
                                  &Filter,
                                  Buffer,
                                  &BufSize,
                                  INFINITE);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "GetClusterNotify failed %d\n", GetLastError());
            return(0);
        }
        switch (NotifyKey) {
            case NOTIFY_KEY_ALL:
                printf("Clusterwide notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
            case NOTIFY_KEY_GROUP:
                printf("Group notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
            case NOTIFY_KEY_RESOURCE:
                printf("Resource notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
            case NOTIFY_KEY_NODE:
                printf("Node notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
            case NOTIFY_KEY_REGISTRY:
                printf("Registry notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
            case NOTIFY_KEY_REGISTRY_GROUP:
                printf("Registry group notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
            case NOTIFY_KEY_REGISTRY_RESOURCE:
                printf("Registry resource notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
			case NOTIFY_KEY_CLUSTER_RECONNECT:
				printf("Cluster Reconnect notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
				break ;
            default:
                printf("UNKNOWN NOTIFY KEY %d, Filter %08lx, Name %ws\n",
                       NotifyKey, Filter, Buffer);
                break;
        }

    }

    //
    // Close all the open handles
    //
    for (i=0; i<NodeHandleCount; i++) {
        CloseClusterNode(NodeHandles[i]);
    }
    for (i=0; i<ResourceHandleCount; i++) {
        CloseClusterResource(ResourceHandles[i]);
    }
    for (i=0; i<GroupHandleCount; i++) {
        CloseClusterGroup(GroupHandles[i]);
    }
    for (i=0; i<RegistryHandleCount; i++) {
        ClusterRegCloseKey(RegistryHandles[i]);
    }

    CloseCluster(Cluster);

    //
    // Drain out all the handle close events.
    //
    Sleep(5000);
    do {
        BufSize = sizeof(Buffer) / sizeof(WCHAR);
        Status = GetClusterNotify(hChange,
                                  &NotifyKey,
                                  &Filter,
                                  Buffer,
                                  &BufSize,
                                  0);
        if (Status == ERROR_SUCCESS) {
            printf("Draining notification NotifyKey = %08lx\n", NotifyKey);
            printf("                      Filter    = %08lx\n", Filter);
            printf("                      Name      = %ws\n", Buffer);
        } else {
            printf("Draining notifies returned %d\n",Status);
        }

    } while ( Status == ERROR_SUCCESS );

    CloseClusterNotifyPort(hChange);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\ttype.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR ResourceTypeName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -r resourcetype -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  resource\tspecifies the name of the resource to control\n"
    "  access\tspecifies the access to the resource type (read, write or any)\n"
    "  ControlCode\ta number between 1 and 9\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'r':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    ResourceTypeName = GetString(argv[i]);
                    fprintf(stdout, "Resource = %ws\n", ResourceTypeName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    controlCode = CLUSCTL_RESOURCE_TYPE_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterResourceTypeControl( hClus,
                                         ResourceTypeName,
                                         hNode,
                                         controlCode,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         &ReturnSize );
    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterResourceTypeControl( hClus,
                                         ResourceTypeName,
                                         hNode,
                                         controlCode,
                                         NULL,
                                         0,
                                         buffer,
                                         bufSize,
                                         &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tsset.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR ResourceName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TSET [-c cluster] -n node -r resource -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  resource\tspecifies the name of the resource to control\n"
    "  access\tspecifies the access to the resource (read, write or any)\n"
    "  ControlCode\ta number between 1 and 9\n";


typedef struct _PROPERTY_MSG1 {
    DWORD   ItemCount;
    DWORD   Syntax1;
    DWORD   ParameterName1ByteCount;
    WCHAR   ParameterName1[20];
    DWORD   Syntax2;            // Dword Data Item to follow
    DWORD   Data;               // New value
    DWORD   Syntax3;
    DWORD   ParameterName2ByteCount;
    WCHAR   ParameterName2[12];
    DWORD   Syntax4;            // SZ string to follow
    DWORD   ParameterName3ByteCount;
    WCHAR   ParameterName3[8];
    DWORD   End;
} PROPERTY_MSG1, PPROPERTY_MSG1;

typedef struct _PROPERTY_MSG2 {
    DWORD   ItemCount;
    DWORD   Syntax1;
    DWORD   ParameterName1ByteCount;
    WCHAR   ParameterName1[7];
    DWORD   Syntax2;            // Dword Data Item to follow
    DWORD   Data;               // New value
    DWORD   End;
} PROPERTY_MSG2, PPROPERTY_MSG2;

PROPERTY_MSG1
PropertyMsg = { 3, 0x40003, 40, L"IsAlivePollInterval", 0x10002, 0x2000, 0x40003, 24, L"Description", 0x10003, 16, L"Testing", 0 };

    
PROPERTY_MSG2
PropertyMsg2 = { 1, 0x40003, 16, L"Foobar", 0x10002, 0x200, 0 };

void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'r':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    ResourceName = GetString(argv[i]);
                    fprintf(stdout, "Resource = %ws\n", ResourceName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    CHAR    InBuffer[64];
    CHAR    OutBuffer[512];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    DWORD   controlCode;
    DWORD   modify;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hResource = OpenClusterResource(  hClus, ResourceName );
    if ( hResource == NULL ) {
        fprintf(stderr,
                "OpenResource %ws failed %d\n", ResourceName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    switch ( Access ) {
    case CLUS_ACCESS_READ:
        modify = CLUS_NO_MODIFY;
        break;
    case CLUS_ACCESS_WRITE:
        modify = CLUS_MODIFY;
        break;
    case CLUS_ACCESS_ANY:
        modify = CLUS_NO_MODIFY;
        break;
    }

    controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, modify );
    controlCode = CLUSCTL_RESOURCE_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterResourceControl( hResource,
                                     hNode,
                                     controlCode,
                                     &PropertyMsg2,
                                     sizeof(PROPERTY_MSG2),
                                     OutBuffer,
                                     0,
                                     &ReturnSize );
    if (( status == ERROR_MORE_DATA ) || ( ReturnSize != 0 )) {
        fprintf(stdout, "Calling again due to buffer size too small (status = %d)\n", status);
        status = ClusterResourceControl( hResource,
                                         hNode,
                                         controlCode,
                                         &PropertyMsg2,
                                         sizeof(PROPERTY_MSG2),
                                         OutBuffer,
                                         ReturnSize,
                                         &ReturnSize );
    }

    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)OutBuffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            for ( i = 0; i < 4; i++ ) {
                if ( !ReturnSize )
                    fprintf(stdout, "         ");
                else {
                    fprintf(stdout, " %08lx", PrintData[i]);
                    ReturnSize -= 4;
                }
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                if ( j ) {
                    fprintf(stdout, "%c",
                     isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
                    j--;
                }
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\treg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    treg.c

Abstract:

    Test for cluster registry API

Author:

    John Vert (jvert) 15-Mar-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "conio.h"

#define INDENT_LEVEL 4

WCHAR Value1Data[] = L"This is data for value 1";
WCHAR Value2Data[] = L"This is data for value 2";
WCHAR Value3Data[] = L"This is data for value 3";

VOID
DumpKeyWorker(
    IN HKEY Key,
    IN DWORD Indent
    );

VOID
DumpValues(
    IN HKEY Key,
    IN DWORD Indent
    );

int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER Cluster;
    HRESOURCE Resource;
    HGROUP Group;
    HNODE Node;
    HNETWORK Network;
    HNETINTERFACE NetInterface;
    HKEY ClusterRoot;
    HKEY TestKey;
    HCLUSENUM ResEnum;
    DWORD ClusterCountBefore, ClusterCountAfter;
    DWORD i;
    DWORD Status;
    WCHAR NameBuf[50];
    DWORD NameLen;
    DWORD Type;
    DWORD Disposition;

    //
    // Dump out registry structure for current cluster.
    //
    Cluster = OpenCluster(NULL);
    if (Cluster == NULL) {
        fprintf(stderr, "OpenCluster(NULL) failed %d\n",GetLastError());
        return(0);
    }

    ClusterRoot = GetClusterKey(Cluster, KEY_READ);
    if (ClusterRoot == NULL) {
        fprintf(stderr, "GetClusterKey failed %d\n", GetLastError());
        return(0);
    }

    printf("CLUSTERROOT\n");
    DumpKeyWorker(ClusterRoot, 4);

    //
    // Dump by object
    //
    printf("\n\nENUMERATING OBJECTS\n");
    ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_ALL);
    if (ResEnum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
        return(0);
    }

    ClusterCountBefore = ClusterGetEnumCount(ResEnum);
    for(i=0; ; i++) {
        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = ClusterEnum(ResEnum,
                             i,
                             &Type,
                             NameBuf,
                             &NameLen);
        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }
        switch (Type) {
            case CLUSTER_ENUM_NODE:
                printf("NODE %ws\n",NameBuf);
                break;

            case CLUSTER_ENUM_RESTYPE:
                printf("RESOURCETYPE %ws\n",NameBuf);
                break;

            case CLUSTER_ENUM_RESOURCE:
                printf("RESOURCE %ws\n",NameBuf);
                Resource = OpenClusterResource(Cluster, NameBuf);
                if (Resource == NULL) {
                    fprintf(stderr, "OpenClusterResource returned error %d\n",GetLastError());
                    break;
                }
                ClusterRoot = GetClusterResourceKey(Resource,
                                                    KEY_READ);
                if (ClusterRoot == NULL) {
                    fprintf(stderr, "GetClusterResourceKey returned error %d\n",GetLastError());
                    break;
                }
                CloseClusterResource(Resource);
                DumpKeyWorker(ClusterRoot, 4);
                break;

            case CLUSTER_ENUM_GROUP:
                printf("GROUP %ws\n",NameBuf);
                Group = OpenClusterGroup(Cluster, NameBuf);
                if (Group == NULL) {
                    fprintf(stderr, "OpenClusterGroup returned error %d\n",GetLastError());
                    break;
                }
                ClusterRoot = GetClusterGroupKey(Group,
                                                 KEY_READ);
                if (ClusterRoot == NULL) {
                    fprintf(stderr, "GetClusterGroupKey returned error %d\n",GetLastError());
                    break;
                }
                CloseClusterGroup(Group);
                DumpKeyWorker(ClusterRoot, 4);
                break;

            case CLUSTER_ENUM_NETWORK:
                printf("NETWORK %ws\n",NameBuf);
                Network = OpenClusterNetwork(Cluster, NameBuf);
                if (Network == NULL) {
                    fprintf(stderr, "OpenClusterNetwork returned error %d\n",GetLastError());
                    break;
                }
                ClusterRoot = GetClusterNetworkKey(Network,
                                                   KEY_READ);
                if (ClusterRoot == NULL) {
                    fprintf(stderr, "GetClusterNetworkKey returned error %d\n",GetLastError());
                    break;
                }
                CloseClusterNetwork(Network);
                DumpKeyWorker(ClusterRoot, 4);
                break;

            case CLUSTER_ENUM_NETINTERFACE:
                printf("NETINTERFACE %ws\n",NameBuf);
                NetInterface = OpenClusterNetInterface(Cluster, NameBuf);
                if (NetInterface == NULL) {
                    fprintf(stderr, "OpenClusterNetInterface returned error %d\n",GetLastError());
                    break;
                }
                ClusterRoot = GetClusterNetInterfaceKey(NetInterface,
                                                        KEY_READ);
                if (ClusterRoot == NULL) {
                    fprintf(stderr, "GetClusterNetInterfaceKey returned error %d\n",GetLastError());
                    break;
                }
                CloseClusterNetInterface(NetInterface);
                DumpKeyWorker(ClusterRoot, 4);
                break;

            default:
                fprintf(stderr, "ClusterEnum returned unknown type %d\n",Type);
                break;
        }
    }
    if (Status == ERROR_NO_MORE_ITEMS) {
        printf("\nCluster count: %d\n", i);
        ClusterCountAfter = ClusterGetEnumCount(ResEnum);
        if (ClusterCountBefore != ClusterCountAfter)
            fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
        else if (i != ClusterCountBefore)
            fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
    }
    ClusterCloseEnum(ResEnum);

    //
    // Test the create/delete apis
    //
    printf("\nTesting Creation APIs\n");
    ClusterRoot = GetClusterKey(Cluster, KEY_READ | KEY_WRITE);

    if (ClusterRoot == NULL) {
        fprintf(stderr, "GetClusterKey failed %d\n", GetLastError());
        return(0);
    }
    Status = ClusterRegCreateKey(ClusterRoot,
                                 L"TestKey",
                                 0,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &TestKey,
                                 &Disposition);
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "ClusterRegCreateKey failed %d\n", Status);
        return(0);
    }
    if (Disposition == REG_CREATED_NEW_KEY) {
        printf("TestKey successfully created\n");
    } else if (Disposition == REG_OPENED_EXISTING_KEY) {
        printf("TestKey successfully opened\n");
    } else {
        fprintf(stderr,"CreateKey of TestKey returned unknown Disposition %d\n", Disposition);
    }

    Status = ClusterRegSetValue(TestKey,
                                L"Value1",
                                REG_SZ,
                                (CONST BYTE*)Value1Data,
                                (lstrlenW(Value1Data)+1)*sizeof(WCHAR));
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "SetValue for Value1 failed %d\n", Status);
    }

    Status = ClusterRegSetValue(TestKey,
                                L"Value2",
                                REG_SZ,
                                (CONST BYTE*)Value2Data,
                                (lstrlenW(Value2Data)+1)*sizeof(WCHAR));
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "SetValue for Value2 failed %d\n", Status);
    }

    Status = ClusterRegSetValue(TestKey,
                                L"Value3",
                                REG_SZ,
                                (CONST BYTE*)Value3Data,
                                (lstrlenW(Value3Data)+1)*sizeof(WCHAR));
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "SetValue for Value3 failed %d\n", Status);
    }

    printf("Press a key to delete values\n");
    _getch();
    printf("Deleting values...\n");
    Status = ClusterRegDeleteValue(TestKey, L"Value1");
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "DeleteValue for Value1 failed %d\n", Status);
    }
    Status = ClusterRegDeleteValue(TestKey, L"Value2");
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "DeleteValue for Value2 failed %d\n", Status);
    }
    Status = ClusterRegDeleteValue(TestKey, L"Value3");
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "DeleteValue for Value3 failed %d\n", Status);
    }

    printf("Press a key to delete TestKey\n");
    _getch();
    printf("Deleting TestKey");
    ClusterRegCloseKey(TestKey);
    Status = ClusterRegDeleteKey(ClusterRoot, L"TestKey");
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "DeleteKey failed %d\n", Status);
    }



    ClusterRegCloseKey(ClusterRoot);


    CloseCluster(Cluster);
}


VOID
DumpKeyWorker(
    IN HKEY Key,
    IN DWORD Indent
    )

/*++

Routine Description:

    Recursively dumps out the specified cluster registry key

Arguments:

    Key - Supplies the root of the subtree to dump

    Indent - Supplies the current indent level

Return Value:

    None.

--*/

{
    DWORD i;
    DWORD j;
    HKEY Subkey;
    DWORD CurrentLength=80;
    DWORD Length;
    LPWSTR Buffer;
    FILETIME FileTime;
    LONG Status;

    //
    // Enumerate our values
    //
    DumpValues(Key, Indent);

    //
    // Enumerate the subkeys and dump each one.
    //
    Buffer = malloc(CurrentLength*sizeof(WCHAR));
    if (Buffer == NULL) {
        fprintf(stderr, "DumpKeyWorker: out of memory\n");
        return;
    }
    for (i=0; ; i++) {
retry:
        Length = CurrentLength;
        Status = ClusterRegEnumKey(Key,
                                   i,
                                   Buffer,
                                   &Length,
                                   &FileTime);
        if (Status == ERROR_MORE_DATA) {
            CurrentLength = Length+1;
            free(Buffer);
            Buffer = malloc(CurrentLength*sizeof(WCHAR));
            if (Buffer == NULL) {
                fprintf(stderr, "DumpKeyWorker: out of memory\n");
            }
            goto retry;
        } else if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "DumpKeyWorker, ClusterRegEnumKey returned %d\n",Status);
            return;
        }
        //
        // print out name
        //
        for (j=0;j<Indent;j++) {
            printf(" ");
        }
        printf("%ws\n",Buffer);

        //
        // Open the key and call ourself recursively
        //
        Status = ClusterRegOpenKey(Key,
                                   Buffer,
                                   KEY_READ,
                                   &Subkey);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "DumpKeyWorker, ClusterRegOpenKey returned %d\n",Status);
            return;
        }
        DumpKeyWorker(Subkey, Indent+INDENT_LEVEL);
        Status = ClusterRegCloseKey(Subkey);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "DumpKeyWorker, ClusterRegCloseKey returned %d\n",Status);
        }
    }
    free(Buffer);
}


VOID
DumpValues(
    IN HKEY Key,
    IN DWORD Indent
    )

/*++

Routine Description:

    Dumps the values of the specified key.

Arguments:

    Key - Supplies the key to dump.

    Indent - Supplies the indentation level to use.

Return Value:

    None.

--*/

{
    DWORD i;
    DWORD j;
    HKEY Subkey;
    DWORD CurrentNameLength=80;
    DWORD NameLength;
    LPWSTR Name;
    DWORD CurrentDataLength=80;
    DWORD DataLength;
    PUCHAR Data ;
    LONG Status;
    DWORD Type;

    //
    // Enumerate the values and dump each one.
    //
    Name = malloc(CurrentNameLength*sizeof(WCHAR));
    if (Name==NULL) {
        fprintf(stderr, "DumpValues: out of memory\n");
        return;
    }
    Data = malloc(CurrentDataLength);
    if (Data==NULL) {
        fprintf(stderr, "DumpValues: out of memory\n");
        return;
    }
    for (i=0; ;i++) {
retry:
        NameLength = CurrentNameLength;
        DataLength = CurrentDataLength;
        Status = ClusterRegEnumValue(Key,
                                     i,
                                     Name,
                                     &NameLength,
                                     &Type,
                                     Data,
                                     &DataLength);
        if (Status == ERROR_MORE_DATA) {
            if (NameLength+1 > CurrentNameLength) {
                CurrentNameLength = NameLength+1;
                free(Name);
                Name = malloc(CurrentNameLength);
                if (Name == NULL) {
                    fprintf(stderr, "DumpValues: out of memory\n");
                    return;
                }
            }
            if (DataLength > CurrentDataLength) {
                CurrentDataLength = DataLength;
                free(Data);
                Data = malloc(CurrentDataLength);
                if (Data == NULL) {
                    fprintf(stderr, "DumpValues: out of memory\n");
                    return;
                }
            }
            goto retry;
        } else if (Status == ERROR_NO_MORE_ITEMS) {
            return;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "DumpValues: out of memory\n");
            return;
        }

        //
        // print out value
        //
        for (j=0;j<Indent;j++) {
            printf(" ");
        }
        printf("%ws = ",Name);
        switch (Type) {
            case REG_SZ:
                printf("REG_SZ %ws\n",Data);
                break;
            case REG_EXPAND_SZ:
                printf("REG_EXPAND_SZ %ws\n",Data);
                break;
            case REG_DWORD:
                printf("REG_DWORD 0x%08lx\n",*(PDWORD)Data);
                break;
            case REG_BINARY:
                printf("REG_BINARY 0x%08lx\n",Data);
                break;
            case REG_DWORD_BIG_ENDIAN:
                printf("REG_DWORD_BIG_ENDIAN 0x%08lx\n",Data);
                break;
            case REG_MULTI_SZ:
                printf("REG_MULTI_SZ %ws\n",Data);
                break;
            case REG_QWORD:
                printf("REG_QWORD 0x%I6416lx\n",Data);
                break;
            default:
                printf("UNKNOWN TYPE %d\n",Type);
                break;
        }

    }

    free(Name);
    free(Data);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\trename.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    trename.c

Abstract:

    Test for cluster object rename APIs

Author:

    John Vert (jvert) 5/10/1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

LPWSTR ClusterName=NULL;
BOOL DoGroup=FALSE;
BOOL DoResource=FALSE;
BOOL DoCluster=FALSE;
LPWSTR OldName=NULL;
LPWSTR NewName=NULL;

CHAR UsageText[] =
    "TRENAME [-c cluster] type [oldname] newname\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  type\t\teither \"cluster\" or \"group\" or \"resource\"\n"
    "  oldname\t\tthe current friendly name of the object\n"
    "         \t\t(required for group or resource)\n"
    "  newname\t\tthe new friendly name of the object\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}

void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD ArgsSeen=0;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            switch (ArgsSeen) {
                case 0:
                    //
                    // type
                    //
                    if (_stricmp(argv[i], "group")==0) {
                        DoGroup = TRUE;
                    } else if (_stricmp(argv[i], "resource") == 0) {
                        DoResource = TRUE;
                    } else if (_stricmp(argv[i], "cluster") == 0) {
                        DoCluster = TRUE;
                        ArgsSeen++;
                    } else {
                        Usage();
                    }
                    ArgsSeen++;
                    break;
                case 1:
                    OldName = GetString(argv[i]);
                    ArgsSeen++;
                    break;
                case 2:
                    NewName = GetString(argv[i]);
                    ArgsSeen++;
                    break;
                default:
                    Usage();
            }
        }
    }

    if (ArgsSeen != 3) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP hGroup;
    HRESOURCE hResource;
    LPSTR KeyName, ParamName;
    LPSTR ParamValue;
    DWORD Status;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    if (DoGroup) {
        hGroup = OpenClusterGroup(hClus, OldName);
        if (hGroup == NULL) {
            fprintf(stderr,
                    "OpenGroup %ws failed %d\n", OldName, GetLastError());
            return(0);
        }
        Status = SetClusterGroupName(hGroup, NewName);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr,
                    "SetClusterGroupName from %ws to %ws failed %d\n",
                    OldName,
                    NewName,
                    Status);
        }
    } else if (DoResource) {
        hResource = OpenClusterResource(hClus, OldName);
        if (hResource == NULL) {
            fprintf(stderr,
                    "OpenResource %ws failed %d\n", OldName, GetLastError());
            return(0);
        }
        Status = SetClusterResourceName(hResource, NewName);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr,
                    "SetClusterResourceName from %ws to %ws failed %d\n",
                    OldName,
                    NewName,
                    Status);
        }
    } else if (DoCluster) {
        Status = SetClusterName(hClus, NewName);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr,
                    "SetClusterName to %ws failed %d\n",
                    NewName,
                    Status);
        }
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusapi\tres.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tres.c

Abstract:

    Test for cluster group API

Author:

    John Vert (jvert) 5/23/1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER Cluster;
    HRESOURCE Resource;
    HGROUP Group;
    HCLUSENUM Enum;
    HRESENUM ResEnum;
    DWORD i,j;
    DWORD Status;
    WCHAR NameBuf[50];
    DWORD NameLen;
    DWORD GroupNameLen;
    WCHAR NodeBuf[50];
    WCHAR GroupBuf[50];
    CLUSTER_RESOURCE_STATE ResourceState;
    DWORD Type;
    DWORD ResCountBefore, ResCountAfter;
    DWORD ClusterCountBefore, ClusterCountAfter;

    //
    // Dump out resources for current cluster.
    //
    Cluster = OpenCluster(NULL);
    if (Cluster == NULL) {
        fprintf(stderr, "OpenCluster(NULL) failed %d\n",GetLastError());
        return(0);
    }

    //
    // Dump resources
    //
    printf("\n\nENUMERATING RESOURCES\n");
    Enum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_RESOURCE);
    if (Enum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
        return(0);
    }
    ClusterCountBefore = ClusterGetEnumCount(Enum);
    for(i=0; ; i++) {
        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = ClusterEnum(Enum,
                             i,
                             &Type,
                             NameBuf,
                             &NameLen);
        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }
        if (Type != CLUSTER_ENUM_RESOURCE) {
            printf("Invalid Type %d returned from ClusterEnum\n", Type);
            return(0);
        }

        Resource = OpenClusterResource(Cluster, NameBuf);
        if (Resource == NULL) {
            fprintf(stderr, "OpenClusterResource %ws failed %d\n",NameBuf, GetLastError());
            return(0);
        }

        NameLen = sizeof(NodeBuf)/sizeof(WCHAR);
        GroupNameLen = sizeof(GroupBuf)/sizeof(WCHAR);
        ResourceState = GetClusterResourceState(Resource, NodeBuf, &NameLen, GroupBuf, &GroupNameLen);
        if (ResourceState == -1) {
            fprintf(stderr, "GetClusterResourceState2 failed %d\n",GetLastError());
            return(0);
        }
        switch (ResourceState) {
            case ClusterResourceInherited:
                printf("Resource %ws is INHERITED",NameBuf);
                break;
            case ClusterResourceInitializing:
                printf("Resource %ws is INITIALIZING",NameBuf);
                break;
            case ClusterResourceOnline:
                printf("Resource %ws is ONLINE",NameBuf);
                break;
            case ClusterResourceOffline:
                printf("Resource %ws is OFFLINE",NameBuf);
                break;
            case ClusterResourceFailed:
                printf("Resource %ws is FAILED",NameBuf);
                break;
            default:
                fprintf(stderr, "Group %ws is in unknown state %d", NameBuf, ResourceState);
                break;
        }
        printf(" on node %ws in group %ws\n",NodeBuf, GroupBuf);
        //
        // Dump out resource dependencies:
        //
        ResEnum = ClusterResourceOpenEnum(Resource, CLUSTER_RESOURCE_ENUM_DEPENDS);
        if (ResEnum == NULL) {
            fprintf(stderr,
                    "ClusterResourceOpenEnum CLUSTER_RESOURCE_ENUM_DEPENDS failed %d\n",
                    GetLastError());
            return(0);

        }
        ResCountBefore = ClusterResourceGetEnumCount(ResEnum);
        printf("\tDEPENDS ON:\t");
        for (j=0; ; j++) {
            NameLen = sizeof(NameBuf)/sizeof(WCHAR);
            Status = ClusterResourceEnum(ResEnum,
                                         j,
                                         &Type,
                                         NameBuf,
                                         &NameLen);
            if (Status == ERROR_NO_MORE_ITEMS) {
                break;
            } else if (Status != ERROR_SUCCESS) {
                fprintf(stderr, "ClusterResourceEnum %d returned error %d\n",i,Status);
                break;
            } else {
                printf("%ws ",NameBuf);
            }
        }
        if (Status == ERROR_NO_MORE_ITEMS) {
            printf("\nResource count: %d\n", j);
            ResCountAfter = ClusterResourceGetEnumCount(ResEnum);
            if (ResCountBefore != ResCountAfter)
                fprintf(stderr, "\nReported resource count was %d before enumeration, and %d afterward\n", ResCountBefore, ResCountAfter);
            else if (j != ResCountBefore)
                fprintf(stderr, "\nReported resource count: %d\n", ResCountBefore);
        }
        ClusterResourceCloseEnum(ResEnum);
        //
        // Dump out resource dependencies:
        //
        ResEnum = ClusterResourceOpenEnum(Resource, CLUSTER_RESOURCE_ENUM_PROVIDES);
        if (ResEnum == NULL) {
            fprintf(stderr,
                    "ClusterResourceOpenEnum CLUSTER_RESOURCE_ENUM_PROVIDES failed %d\n",
                    GetLastError());
            return(0);

        }
        ResCountBefore = ClusterResourceGetEnumCount(ResEnum);
        printf("\n\tPROVIDES FOR:\t");
        for (j=0; ; j++) {
            NameLen = sizeof(NameBuf)/sizeof(WCHAR);
            Status = ClusterResourceEnum(ResEnum,
                                         j,
                                         &Type,
                                         NameBuf,
                                         &NameLen);
            if (Status == ERROR_NO_MORE_ITEMS) {
                break;
            } else if (Status != ERROR_SUCCESS) {
                fprintf(stderr, "ClusterResourceEnum %d returned error %d\n",i,Status);
                break;
            } else {
                printf("%ws ",NameBuf);
            }
        }
        if (Status == ERROR_NO_MORE_ITEMS) {
            printf("\nResource count: %d\n", j);
            ResCountAfter = ClusterResourceGetEnumCount(ResEnum);
            if (ResCountBefore != ResCountAfter)
                fprintf(stderr, "\nReported resource count was %d before enumeration, and %d afterward\n", ResCountBefore, ResCountAfter);
            else if (j != ResCountBefore)
                fprintf(stderr, "\nReported resource count: %d\n", ResCountBefore);
        }
        printf("\n");
        ClusterResourceCloseEnum(ResEnum);
        CloseClusterResource(Resource);
    }
    if (Status == ERROR_NO_MORE_ITEMS) {
        printf("\nCluster count: %d\n", i);
        ClusterCountAfter = ClusterGetEnumCount(Enum);
        if (ClusterCountBefore != ClusterCountAfter)
            fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
        else if (i != ClusterCountBefore)
            fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
    }
    ClusterCloseEnum(Enum);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusdisk\clusdisk.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    clusdisk.c

Abstract:

    This driver controls access to disks in an NT cluster environment.
    Initially this driver will support SCSI, but other controller types
    should be supported in the future.

Authors:

    Rod Gamache     13-Feb-1996

Environment:

    kernel mode only

Notes:

Revision History:


--*/

#define _NTDDK_

#include "initguid.h"
#include "clusdskp.h"
#include "ntddk.h"
#include "diskarbp.h"
#include "ntddft.h"
#include "clusdisk.h"
#include "scsi.h"
#include "ntddcnet.h"
#include "mountdev.h"
#include "ntddvol.h" // IOCTL_VOLUME_ONLINE
#include "wdmguid.h"
#include "clusverp.h"
#include "clusvmsg.h"
#include <ntddsnap.h>   // IOCTL_VOLSNAP_QUERY_OFFLINE
#include <windef.h>
#include <partmgrp.h>   // PartMgr IOCTLs
#include <strsafe.h>    // Should be included last.

#if !defined(WMI_TRACING)

#define CDLOG0(Dummy)
#define CDLOG(Dummy1,Dummy2)
#define CDLOGFLG(Dummy0,Dummy1,Dummy2)
#define LOGENABLED(Dummy) FALSE

#else

#include "clusdisk.tmh"

#endif // !defined(WMI_TRACING)


extern POBJECT_TYPE *IoFileObjectType;

//
// format string for old style partition names. 10 extra chars are added
// for enough space for the disk and partition numbers
//

#define DEVICE_PARTITION_NAME        L"\\Device\\Harddisk%d\\Partition%d"
#define MAX_PARTITION_NAME_LENGTH    (( sizeof(DEVICE_PARTITION_NAME) / sizeof(WCHAR)) + 10 )

//
// format string for a clusdisk non-zero partition device
//
#define CLUSDISK_DEVICE_NAME            L"\\Device\\ClusDisk%uPart%u"
#define MAX_CLUSDISK_DEVICE_NAME_LENGTH (( sizeof(CLUSDISK_DEVICE_NAME) / sizeof(WCHAR)) + 10 )

#define RESET_SLEEP  1      // Sleep for 1 second after bus resets.

// max # of partition entries we can handle that are returned
// by IOCTL_DISK_GET_DRIVE_LAYOUT

#define MAX_PARTITIONS  128

#define SKIP_COUNT_MAX  50

#ifndef max
#define max( a, b ) ((a) >= (b) ? (a) : (b))
#endif

#define CLUSDISK_ALLOC_TAG  'kdSC'

#ifndef ASSERT_RESERVES_STARTED
#define ASSERT_RESERVES_STARTED( _de )  \
        ASSERT( _de->PerformReserves == TRUE  && _de->ReserveTimer != 0 );
#endif

#ifndef ASSERT_RESERVES_STOPPED
#define ASSERT_RESERVES_STOPPED( _de )  \
        ASSERT( _de->PerformReserves == FALSE || _de->ReserveTimer == 0 );
#endif

#define OFFLINE_DISK_PDO( _physDisk )       \
    _physDisk->DiskState = DiskOffline;     \
    SendOfflineDirect( _physDisk );

#define OFFLINE_DISK( _physDisk )           \
    _physDisk->DiskState = DiskOffline;     \
    if ( !HaltOfflineBusy ) {                       \
        SetVolumeState( _physDisk, DiskOffline );   \
    } else {                                        \
        ClusDiskPrint(( 1, "[ClusDisk] HaltOfflineBusy set, skipping DiskOffline request \n" ));       \
    }

#define ONLINE_DISK( _physDisk )            \
    _physDisk->DiskState = DiskOnline;      \
    SetVolumeState( _physDisk, DiskOnline );

#define DEREFERENCE_OBJECT( _obj )          \
    if ( _obj ) {                           \
        ObDereferenceObject( _obj );        \
        _obj = NULL;                        \
    }

#define FREE_DEVICE_NAME_BUFFER( _devName ) \
    if ( _devName.Buffer ) {                \
        ExFreePool( _devName.Buffer );      \
        _devName.Buffer = NULL;             \
    }

#define FREE_AND_NULL_PTR( _poolPtr )       \
    if ( _poolPtr ) {                       \
        ExFreePool( _poolPtr );             \
        _poolPtr = NULL;                    \
    }


#define ACCESS_FROM_CTL_CODE(ctrlCode)     (((ULONG)(ctrlCode & 0xc000)) >> 14)

#define MAX_WAIT_SECONDS_ALLOWED    3600    // Max wait is one hour

//
// Global Data
//

UNICODE_STRING ClusDiskRegistryPath;

#if DBG
ULONG ClusDiskPrintLevel = 0;
#endif

#define CLUSDISK_DEBUG 1
#if CLUSDISK_DEBUG
ULONG           ClusDiskGood = TRUE;
#endif

//
// Spinlock for protecting global data.
//
KSPIN_LOCK     ClusDiskSpinLock;

//
// Resource to protect the list of the device objects
// associated with the DriverObject
//
// We also use this resource to synchronize
//   HoldIo and users of the OpenFileHandles function,
//
// Lock order is
//    ClusDiskDeviceListLock
//    CancelSpinLock
//    ClusDiskSpinLock
//

ERESOURCE      ClusDiskDeviceListLock;

//
// System disk signature and (SCSI?) port number
//
ULONG           SystemDiskSignature = 0;
UCHAR           SystemDiskPort = 0xff; // Hopefully -1 for both fields is unused
UCHAR           SystemDiskPath = 0xff;

//
// The Root Device Object (clusdisk0)
//
PDEVICE_OBJECT  RootDeviceObject = NULL;

//
// List of devices (signatures) that clusdisk should control.
//
PDEVICE_LIST_ENTRY ClusDiskDeviceList = NULL;

//
// Clusdisk is started at boot time vs run time (ie loaded).
//
BOOLEAN         ClusDiskBootTime = TRUE;

//
// Clusdisk should rescan and previous disk count
//
BOOLEAN         ClusDiskRescan = FALSE;
BOOLEAN         ClusDiskRescanBusy = FALSE;
ULONG           ClusDiskRescanRetry = 0;
PVOID           ClusDiskNextDisk = 0;
WORK_QUEUE_ITEM ClusDiskRescanWorkItem;
#define MAX_RESCAN_RETRIES 30

PKPROCESS       ClusDiskSystemProcess = NULL;

//
// Handle to ClusNet device driver.
//
HANDLE          ClusNetHandle = NULL;

//
// Count of references to ClusNet.
//
ULONG           ClusNetRefCount = 0;

LPCGUID         ClusDiskOfflineOnlineGuid = (LPCGUID)&GUID_CLUSTER_CONTROL;

//
// Work queue item context for halt processing.
//
WORK_QUEUE_ITEM HaltWorkItem = {0};
BOOLEAN         HaltBusy = FALSE;           // TRUE if halt work item is busy
BOOLEAN         HaltOfflineBusy = FALSE;    // TRUE if offline IOCTL to volume PDOs in progress

//
// List to hold items before sent to worker routine
//
LONG            ReplaceRoutineCount = 0;
LIST_ENTRY      ReplaceRoutineListHead;
KSPIN_LOCK      ReplaceRoutineSpinLock;

#define MAX_REPLACE_HANDLE_ROUTINES     2

#if CLUSTER_FREE_ASSERTS

LONG    ClusDiskDebugVolumeNotificationQueued   = 0;
LONG    ClusDiskDebugVolumeNotificationEnded    = 0;
LONG    ClusDiskDebugVolumeNotificationSkipped  = 0;
LONG    ClusDiskDebugDiskNotificationQueued     = 0;
LONG    ClusDiskDebugDiskNotificationEnded      = 0;
LONG    ClusDiskDebugDiskNotificationSkipped    = 0;

#endif

#if CLUSTER_FREE_ASSERTS

// 10,000,000  100 nanosecond units = 1 second

#define DBG_STALL_THREAD( _seconds )    \
    {                                   \
    LARGE_INTEGER _dbgWaitTime;         \
    _dbgWaitTime.QuadPart = (ULONGLONG)(-_seconds * 10000 * 1000);  \
    KeDelayExecutionThread( KernelMode,         \
                            FALSE,              \
                            &_dbgWaitTime );    \
    }

#else

#define DBG_STALL_THREAD( _seconds )

#endif

//
// RemoveLock tracing
//

#if DBG

ULONG TrackRemoveLocks = 0;
ULONG TrackRemoveLocksEnableChecks = 1;
PIO_REMOVE_LOCK TrackRemoveLockSpecific = 0;

#endif

extern PARBITRATION_ID    gArbitrationBuffer;

//
// Forward routines
//


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, ClusDiskInitialize)
#pragma alloc_text(INIT, GetSystemRootPort)
#pragma alloc_text(INIT, GetBootTimeSystemRoot)
#pragma alloc_text(INIT, GetRunTimeSystemRoot)
#pragma alloc_text(INIT, RegistryQueryValue)
//#pragma alloc_text(INIT, ResetScsiBusses)

// 2000/02/05: stevedz - Pageable code cannot acquire spinlocks (or call routines that do).
// ClusDiskScsiInitialize calls ClusDiskDeleteDevice which acquires a spinlock.
// #pragma alloc_text(PAGE, ClusDiskScsiInitialize)
#pragma alloc_text(PAGE, ClusDiskUnload)

#endif // ALLOC_PRAGMA



//
// INIT routines
//


NTSTATUS
RegistryQueryValue(
    PVOID hKey,
    LPWSTR pValueName,
    PULONG pulType,
    PVOID pData,
    PULONG pulDataSize
    )

/*++

Routine Description:

    Queries a value from the registry

Arguments:
    hKey         - Key with value to query
    pValueName   - Name of value to query
    pulType      - Returned type of data
    pData        - Pointer to the data buffer to store result
    pulDataSize  - On entry, number of bytes in data buffer.
                 - On exit, number of bytes placed into buffer

Return Value:
    NTSTATUS
        - STATUS_BUFFER_OVERFLOW if buffer can't be allocated

--*/

{
    KEY_VALUE_PARTIAL_INFORMATION *pValInfo;
    UNICODE_STRING valName;
    NTSTATUS ntStatus;
    ULONG ulSize;

    // Size of query buffer
    ulSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + *pulDataSize;

    pValInfo = ExAllocatePool(NonPagedPool, ulSize );

    if (pValInfo == NULL)
        return(STATUS_BUFFER_OVERFLOW);

    RtlInitUnicodeString(&valName, pValueName);

    pValInfo->DataLength = *pulDataSize;

    ntStatus = ZwQueryValueKey(hKey,
                               &valName,
                               KeyValuePartialInformation,
                               pValInfo,
                               ulSize,
                               &ulSize);

    if ( NT_SUCCESS(ntStatus) &&
         *pulDataSize >= pValInfo->DataLength ) {
        // Copy the data queried into buffer
        RtlCopyMemory(pData, pValInfo->Data, pValInfo->DataLength);

        *pulType = pValInfo->Type;
        *pulDataSize = pValInfo->DataLength;
    } else {
#if 0
        ClusDiskPrint((
                1,
                "[ClusDisk] Failed to read key %ws\n",
                pValueName ));
#endif
    }

    ExFreePool(pValInfo);

    return ntStatus;

} // RegistryQueryValue



NTSTATUS
GetBootTimeSystemRoot(
    IN OUT PWCHAR        Path
    )

/*++

Routine Description:

    Find "Partition" string in the partition name, then truncate the
    string just after the "Partition" string.

Arguments:

    Path - the path for the system disk.

Return Value:

    NTSTATUS

--*/

{
    PWCHAR  ptrPartition;

    //
    // At boot time, systemroot is init'ed using the Arcname of the
    // system device. In this form, "partition" is in lower case.
    //
    ptrPartition = wcsstr( Path, L"partition" );
    if ( ptrPartition == NULL ) {
        return(STATUS_INVALID_PARAMETER);
    }

    ptrPartition = wcsstr( ptrPartition, L")" );
    if ( ptrPartition == NULL ) {
        return(STATUS_INVALID_PARAMETER);
    }

    ptrPartition++;
    *ptrPartition = UNICODE_NULL;

    return(STATUS_SUCCESS);

} // GetBootTimeSystemRoot


NTSTATUS
GetRunTimeSystemRoot(
    IN OUT PWCHAR        Path
    )

/*++

Routine Description:

    Find "Partition" string in the partition name, then truncate the
    string just after the "Partition" string.

Arguments:

    Path - the path for the system disk.

Return Value:

    NTSTATUS

--*/

{
    PWCHAR  ptrPartition;

    //
    // Once the system has booted, systemroot is changed to point to
    // a string of the form \Device\HarddiskX\PartitionY\<win dir>. Note
    // that "partition" is now capitalized.
    //
    ptrPartition = wcsstr( Path, L"Partition" );
    if ( ptrPartition == NULL ) {
        return(STATUS_INVALID_PARAMETER);
    }

    ptrPartition = wcsstr( ptrPartition, L"\\" );
    if ( ptrPartition == NULL ) {
        return(STATUS_INVALID_PARAMETER);
    }

    --ptrPartition;
    *ptrPartition++ = L'0';
    *ptrPartition = UNICODE_NULL;

    return(STATUS_SUCCESS);

} // GetRunTimeSystemRoot



NTSTATUS
GetSystemRootPort(
    VOID
    )

/*++

Routine Description:

    Get the port number and signature for the system disk.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{
    WCHAR                       path[MAX_PATH] = L"SystemRoot";
    WCHAR                       clussvcKey[] = L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\SERVICES\\ClusSvc\\Parameters";
    UNICODE_STRING              ntUnicodeString;
    NTSTATUS                    status;
    HANDLE                      ntFileHandle;
    IO_STATUS_BLOCK             ioStatus;
    OBJECT_ATTRIBUTES           objectAttributes;
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayout;
    ULONG                       driveLayoutSize;
    ULONG                       singleBus;
    SCSI_ADDRESS                scsiAddress;
    HANDLE                      eventHandle;

    //
    // Find the bus on which the system disk is loaded.
    //

    GetSymbolicLink( L"\\", path );
    if ( wcslen(path) == 0 ) {
        ClusDiskPrint((1, "[ClusDisk] GetSystemRootPort: couldn't find symbolic link for SystemRoot.\n"));

        return(STATUS_FILE_INVALID);
    }

    status = GetBootTimeSystemRoot( path );

    if ( !NT_SUCCESS(status) ) {
        status = GetRunTimeSystemRoot( path );
        ClusDiskBootTime = FALSE;
    } // else - default is TRUE

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((1,
                       "[ClusDisk] GetSystemRootPort: unable to get system disk name ->%ws<-\n",
                       path));
        //continue
        //return(status);
    }

    //
    // Open the device.
    //
    RtlInitUnicodeString( &ntUnicodeString, path );

    InitializeObjectAttributes( &objectAttributes,
                                &ntUnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = ZwCreateFile( &ntFileHandle,
                           FILE_READ_DATA,
                           &objectAttributes,
                           &ioStatus,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to open device for [%ws]. Error %08X.\n",
                    path,
                    status));

        return(status);
    }

    //
    // Allocate a drive layout buffer.
    //
    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
        (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION_EX));
    driveLayout = ExAllocatePool( NonPagedPoolCacheAligned,
                                  driveLayoutSize );
    if ( driveLayout == NULL ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to allocate root drive layout structure.\n"
                    ));
        ZwClose( ntFileHandle );
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Create event for notification.
    //
    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] Failed to create event. %08X\n",
                status));

        ExFreePool( driveLayout );
        ZwClose( ntFileHandle );
        return(status);
    }

    //
    // Get the port number for the SystemRoot disk device.
    //
    status = ZwDeviceIoControlFile( ntFileHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &ioStatus,
                                    IOCTL_SCSI_GET_ADDRESS,
                                    NULL,
                                    0,
                                    &scsiAddress,
                                    sizeof(SCSI_ADDRESS) );

    if ( status == STATUS_PENDING ) {
        status = ZwWaitForSingleObject(eventHandle,
                                       FALSE,
                                       NULL);
        ASSERT( NT_SUCCESS(status) );
        status = ioStatus.Status;
    }

    if ( NT_SUCCESS(status) ) {

        status = ZwDeviceIoControlFile( ntFileHandle,
                                        eventHandle,
                                        NULL,
                                        NULL,
                                        &ioStatus,
                                        IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                        NULL,
                                        0,
                                        driveLayout,
                                        driveLayoutSize );

        if ( status == STATUS_PENDING ) {
            status = ZwWaitForSingleObject(eventHandle,
                                           FALSE,
                                           NULL);
            ASSERT( NT_SUCCESS(status) );
            status = ioStatus.Status;
        }
    }

    ZwClose( ntFileHandle );
    ZwClose( eventHandle );

    if ( NT_SUCCESS(status) ) {

        if ( PARTITION_STYLE_MBR == driveLayout->PartitionStyle ) {
            SystemDiskSignature = driveLayout->Mbr.Signature;
        }

        SystemDiskPort = scsiAddress.PortNumber;
        SystemDiskPath = scsiAddress.PathId;

        //
        // Check if we are allowed to have a single bus on the system.
        // If disks on system bus are allowed, reset the Port and Path
        // to uninitialized values.  Leave the signature set so we don't
        // pick the system disk.
        //

        singleBus = 0;
        status = GetRegistryValue( &ClusDiskRegistryPath,
                                   CLUSDISK_SINGLE_BUS_KEYNAME,
                                   &singleBus );

        if ( NT_SUCCESS(status) && singleBus ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] ClusDiskInitialize: %ws parm found, allow use of system bus\n",
                             CLUSDISK_SINGLE_BUS_KEYNAME ));

            SystemDiskPort = 0xff;
            SystemDiskPath = 0xff;
        }
        status = STATUS_SUCCESS;
        singleBus = 0;

        RtlInitUnicodeString( &ntUnicodeString, clussvcKey );
        status = GetRegistryValue( &ntUnicodeString,
                                   CLUSSVC_VALUENAME_MANAGEDISKSONSYSTEMBUSES,
                                   &singleBus );

        if ( NT_SUCCESS(status) && singleBus ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] ClusDiskInitialize: %ws parm found, allow use of system bus\n",
                            CLUSSVC_VALUENAME_MANAGEDISKSONSYSTEMBUSES ));

            SystemDiskPort = 0xff;
            SystemDiskPath = 0xff;
        }
        status = STATUS_SUCCESS;

    } else {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to get boot device drive layout info. Error %08X.\n",
                    status
                    ));
        status = STATUS_SUCCESS;    // Use default Port/Path of -1
    }

    ExFreePool( driveLayout );

    return(status);

} // GetSystemRootPort


NTSTATUS
GetRegistryValue(
    PUNICODE_STRING KeyName,
    PWSTR ValueName,
    PULONG ReturnValue
    )
/*++

Routine Description:

    Returns the ULONG registry value for the Value and Key specified.

Arguments:

    KeyName - Unicode string indicating the registry key to use.

    ValueName - String indicating the value name to return.

    ReturnValue - Pointer to ULONG buffer.

Return Value:

    NTSTATUS

--*/
{
    HANDLE                      parametersKey;

    NTSTATUS                    status = STATUS_UNSUCCESSFUL;

    ULONG                       length;
    ULONG                       type;

    OBJECT_ATTRIBUTES           objectAttributes;

    UNICODE_STRING              keyName;

    *ReturnValue = 0;

    //
    // Setup the object attributes for the Parameters\SingleBus key.
    //

    InitializeObjectAttributes(
            &objectAttributes,
            KeyName,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

    //
    // Open Parameters key.
    //

    status = ZwOpenKey(
                    &parametersKey,
                    KEY_READ,
                    &objectAttributes
                    );
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] GetRegistryValue: Failed to open registry key: %ws. Status: %lx\n",
                        KeyName->Buffer,
                        status
                        ));

        goto FnExit;
    }

    RtlInitUnicodeString( &keyName, ValueName );
    type = REG_DWORD;
    length = sizeof(ULONG);

    status = RegistryQueryValue( parametersKey,
                                 ValueName,
                                 &type,
                                 ReturnValue,
                                 &length );

    ZwClose( parametersKey );

    if ( !NT_SUCCESS(status) ||
         (length != 4) ) {

        *ReturnValue = 0;
        ClusDiskPrint(( 3,
                        "[ClusDisk] GetRegistryValue: Failed to read registry value, status %08LX, length %u\n",
                        status,
                        length ));
        goto FnExit;
    }

    if ( *ReturnValue ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] GetRegistryValue: Allow use of system bus\n" ));
    }

FnExit:

    return status;

}   // GetRegistryValue



VOID
ResetScsiBusses(
    VOID
    )

/*++

Routine Description:

    Reset all SCSI busses at once on the system.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PCONFIGURATION_INFORMATION  configurationInformation;
    ULONG                       i;
    ULONG                       idx;
    NTSTATUS                    status;
    SCSI_ADDRESS                scsiAddress;
    HANDLE                      fileHandle;
    IO_STATUS_BLOCK             ioStatusBlock;
    WCHAR                       portDeviceBuffer[64];
    UNICODE_STRING              portDevice;
    PDEVICE_OBJECT              deviceObject;
    PFILE_OBJECT                fileObject;
    OBJECT_ATTRIBUTES           objectAttributes;
    LARGE_INTEGER               waitTime;

    RtlZeroMemory( &scsiAddress, sizeof(SCSI_ADDRESS) );
    scsiAddress.Length = sizeof(SCSI_ADDRESS);

    CDLOG( "ResetScsiBusses: Entry" );

    //
    // Get the system configuration information.
    //

    configurationInformation = IoGetConfigurationInformation();

    //
    // Reset each scsi bus
    //

    for ( i = 0; i < configurationInformation->ScsiPortCount; i++ ) {

        if ( SystemDiskPort == i ) {
            continue;
        }

        //
        // Create device name for the physical disk.
        //

        if ( FAILED( StringCchPrintfW( portDeviceBuffer,
                                       RTL_NUMBER_OF(portDeviceBuffer),
                                       L"\\Device\\ScsiPort%d",
                                       i ) ) ) {
            continue;
        }

        WCSLEN_ASSERT( portDeviceBuffer );

        RtlInitUnicodeString( &portDevice, portDeviceBuffer );

        //
        // Try to open this device to get its scsi info
        //

        InitializeObjectAttributes( &objectAttributes,
                                    &portDevice,
                                    OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL );

        status = ZwOpenFile( &fileHandle,
                             FILE_ALL_ACCESS,
                             &objectAttributes,
                             &ioStatusBlock,
                             0,
                             FILE_NON_DIRECTORY_FILE );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1,
                           "[ClusDisk] ResetScsiBusses, failed to open file %wZ. Error %08X.\n",
                           &portDevice, status ));

            continue;
        }

        status = ObReferenceObjectByHandle( fileHandle,
                                            0,
                                            NULL,
                                            KernelMode,
                                            (PVOID *) &fileObject,
                                            NULL );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1,
                           "[ClusDisk] Failed to reference object for file %wZ. Error %08X.\n",
                           &portDevice,
                           status ));

            ZwClose( fileHandle );
            continue;
        }

        //
        // Get the address of the target device object.  If this file represents
        // a device that was opened directly, then simply use the device or its
        // attached device(s) directly.  Also get the address of the Fast Io
        // dispatch structure.
        //

        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            deviceObject = IoGetRelatedDeviceObject( fileObject );

            // Add a reference to the object so we can dereference it later.
            ObReferenceObject( deviceObject );
        } else {
            deviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );
        }

        //
        // If we get a file system device object... go back and get the
        // device object.
        //
        if ( deviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM ) {
            ObDereferenceObject( deviceObject );
            deviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );
        }
        ASSERT( deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM );

        //
        // We don't know all the paths on this HBA.  Try to reset all paths.
        //

        for ( idx = 0; idx < 2; idx++ ) {
            scsiAddress.PathId = (UCHAR)idx;

            ClusDiskLogError( RootDeviceObject->DriverObject,   // Use RootDeviceObject not DevObj
                              RootDeviceObject,
                              scsiAddress.PathId,           // Sequence number
                              0,                            // Major function code
                              0,                            // Retry count
                              ID_RESET_BUSSES,              // Unique error
                              STATUS_SUCCESS,
                              CLUSDISK_RESET_BUS_REQUESTED,
                              0,
                              NULL );

            ResetScsiDevice( fileHandle, &scsiAddress );
        }

        //
        // Close the scsiport handle after the break reserve IOCTL is sent.
        //

        ZwClose( fileHandle );
        ObDereferenceObject( fileObject );

        DEREFERENCE_OBJECT( deviceObject );
    }

    //
    // Now sleep for a few seconds
    //
    waitTime.QuadPart = (ULONGLONG)(RESET_SLEEP * -(10000*1000));
    KeDelayExecutionThread( KernelMode, FALSE, &waitTime );
    CDLOG( "ResetScsiBusses: Exit" );

    return;

} // ResetScsiBusses


NTSTATUS
ClusDiskGetDeviceObject(
    IN PWCHAR DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    Get the device object pointer given a symbolic device name.
    The device object will have reference count incremented and the
    caller must decrement the count when done with the object.

Arguments:

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_OBJECT      targetDevice;
    PFILE_OBJECT        fileObject;
    UNICODE_STRING      deviceName;
    WCHAR               path[MAX_PATH] = L"";

    WCSLEN_ASSERT( DeviceName );

//DbgBreakPoint();

    if ( FAILED( StringCchCopyW( path,
                                 RTL_NUMBER_OF(path),
                                 DeviceName ) ) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    GetSymbolicLink( L"", path );
    if ( wcslen(path) == 0 ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] GetDeviceObject: Failed find symbolic link for %ws\n",
                DeviceName ));
        return(STATUS_FILE_INVALID);
    }

    RtlInitUnicodeString( &deviceName, path );
    //DbgBreakPoint();
    status = IoGetDeviceObjectPointer( &deviceName,
                                       FILE_READ_ATTRIBUTES,
                                       &fileObject,
                                       &targetDevice );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] GetDeviceObject: Failed to get target devobj, %LX\n",
                status ));

        CDLOG( "ClusDiskGetDeviceObject: GetDevObj failed, status %!status!",
               status );

    } else {
        if ( !(fileObject->Flags & FO_DIRECT_DEVICE_OPEN) ) {
            deviceObject = IoGetRelatedDeviceObject( fileObject );

            // Add a reference to the object so we can dereference it later.
            ObReferenceObject( deviceObject );

            //
            // If we get a file system device object... go back and get the
            // device object.
            //
            if ( deviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM ) {
                ObDereferenceObject( deviceObject );
                deviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );
            }
            ClusDiskPrint((
                    3,
                    "[ClusDisk] GetDevObj: (DIRECT_OPEN) fileObj = %p, devObj= %p \n",
                    fileObject, deviceObject ));
        } else {
            deviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );
            ClusDiskPrint((
                    3,
                    "[ClusDisk] GetDevObj: fileObj = %p, devObj= %p \n",
                    fileObject, deviceObject ));
        }
        *DeviceObject = deviceObject;
        ObDereferenceObject( fileObject );
    }

    ClusDiskPrint((
            3,
            "[ClusDisk] GetDeviceObject: target devobj = %p, status = %LX\n",
            targetDevice,
            status ));

    return(status);

} // ClusDiskGetDeviceObject



NTSTATUS
ClusDiskDeviceChangeNotification(
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION DeviceChangeNotification,
    IN PCLUS_DEVICE_EXTENSION      DeviceExtension
    )
{
/*++

Routine Description:

    Handle the arrival of new disk spindles. We only want to add the signature
    to the available list if it is not already a known signature.

    If the signature matches one we should be controlling, we also need to
    try to attach to the disk.

Arguments:

    DeviceChangeNotification - the device change notification structure

    DeviceExtension - the device extension for the root device

Return Value:

    NTSTATUS for this request.

--*/

    CDLOG( "DeviceChangeNotification: Entry DO %p", DeviceExtension->DeviceObject );

    //
    // Process device arrivals only.
    //
    if ( IsEqualGUID( &DeviceChangeNotification->Event,
                      &GUID_DEVICE_INTERFACE_ARRIVAL ) ) {

        ClusDiskPrint(( 3,
                        "[ClusDisk] Disk arrival: %ws \n",
                        DeviceChangeNotification->SymbolicLinkName->Buffer ));

#if CLUSTER_FREE_ASSERTS
        DbgPrint("[ClusDisk] Disk arrival: %ws \n", DeviceChangeNotification->SymbolicLinkName->Buffer );
#endif

        ProcessDeviceArrival( DeviceChangeNotification,
                              DeviceExtension,
                              FALSE );                  // Disk arrival

    }

    CDLOG( "DeviceChangeNotification: Exit DO %p", DeviceExtension->DeviceObject );

    return STATUS_SUCCESS;

}   // ClusDiskDeviceChangeNotification



NTSTATUS
ClusDiskVolumeChangeNotification(
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION DeviceChangeNotification,
    IN PCLUS_DEVICE_EXTENSION      DeviceExtension
    )
{
/*++

Routine Description:

    Handle the arrival of new volumes. We only want to attach to the
    volume if the signature is already in the signature list.

Arguments:

    DeviceChangeNotification - the device change notification structure

    DeviceExtension - the device extension for the root device

Return Value:

    NTSTATUS for this request.

--*/

    CDLOG( "VolumeChangeNotification: Entry DO %p", DeviceExtension->DeviceObject );

    //
    // Process device arrivals only.
    //
    if ( IsEqualGUID( &DeviceChangeNotification->Event,
                      &GUID_DEVICE_INTERFACE_ARRIVAL ) ) {

        ClusDiskPrint(( 3,
                        "[ClusDisk] Volume arrival: %ws \n",
                        DeviceChangeNotification->SymbolicLinkName->Buffer ));

#if CLUSTER_FREE_ASSERTS
        DbgPrint("[ClusDisk] Volume arrival: %ws \n", DeviceChangeNotification->SymbolicLinkName->Buffer );
#endif

        ProcessDeviceArrival( DeviceChangeNotification,
                              DeviceExtension,
                              TRUE );                  // Volume arrival
    }

    CDLOG( "VolumeChangeNotification: Exit DO %p", DeviceExtension->DeviceObject );

    return STATUS_SUCCESS;

}   // ClusDiskVolumeChangeNotification



NTSTATUS
ProcessDeviceArrival(
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION DeviceChangeNotification,
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN VolumeArrival
    )
{
/*++

Routine Description:

    Handle the arrival of new disks or volumes.  Queues a work-item to
    process either a disk arrival or volume arrival.

    WARNING: don't do anything that will result in PnP notification in
    this thread or deadlock will occur.  For example, locking or dismounting
    a volume causes PnP notification to occur, which cause a deadlock waiting
    for this pnp thread to continue.

Arguments:

    DeviceChangeNotification - the device change notification structure

    DeviceExtension - the device extension for the root device

    VolumeArrival - TRUE if processing a volume arrival.  FALSE for disk
                    arrival.

Return Value:

    NTSTATUS for this request.

--*/

    PIO_WORKITEM                workItem = NULL;
    PDEVICE_CHANGE_CONTEXT      workContext = NULL;
    PWSTR                       symLinkBuffer = NULL;
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo = NULL;

    NTSTATUS                    status;
    ULONG                       driveLayoutSize;

    OBJECT_ATTRIBUTES           objectAttributes;
    HANDLE                      fileHandle = NULL;
    HANDLE                      eventHandle= NULL;
    HANDLE                      deviceHandle = NULL;
    IO_STATUS_BLOCK             ioStatusBlock;
    STORAGE_DEVICE_NUMBER       deviceNumber;
    SCSI_ADDRESS                scsiAddress;

    UNICODE_STRING              availableName;
    UNICODE_STRING              deviceName;

    BOOLEAN                     cleanupRequired = TRUE;

    WCHAR                       deviceNameBuffer[MAX_PARTITION_NAME_LENGTH];

    CDLOG( "DeviceArrival: Entry DO %p", DeviceExtension->DeviceObject );

    CDLOG( "DeviceArrival: Arrival %ws ",
            DeviceChangeNotification->SymbolicLinkName->Buffer );

    //
    // Create event for notification.
    //
    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] DeviceArrival: Failed to create event, status %08X\n",
                        status ));

        goto FnExit;
    }

    //
    // Setup object attributes for the file to open.
    //
    InitializeObjectAttributes(&objectAttributes,
                               DeviceChangeNotification->SymbolicLinkName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    status = ZwCreateFile(&fileHandle,
                          SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                          &objectAttributes,
                          &ioStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0 );
    ASSERT( status != STATUS_PENDING );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                       "[ClusDisk] DeviceArrival, failed to open file %ws. Error %08X.\n",
                       DeviceChangeNotification->SymbolicLinkName->Buffer,
                       status ));
        CDLOG( "DeviceArrival: failed to open file %ws.  Error %08X ",
                DeviceChangeNotification->SymbolicLinkName->Buffer,
                status );

        goto FnExit;
    }

    driveLayoutSize =  sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
        (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION_EX));

    driveLayoutInfo = ExAllocatePool( NonPagedPoolCacheAligned, driveLayoutSize );

    if ( NULL == driveLayoutInfo ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        ClusDiskPrint(( 1,
                       "[ClusDisk] DeviceArrival, failed to allocate drive layout structure \n" ));
        CDLOG( "DeviceArrival: Unable to allocate drive layout structure " );
        goto FnExit;
    }

    //
    // Get the Signature.
    //
    status = ZwDeviceIoControlFile( fileHandle,
                                    eventHandle,
                                    NULL,
                                    NULL,
                                    &ioStatusBlock,
                                    IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                    NULL,
                                    0,
                                    driveLayoutInfo,
                                    driveLayoutSize );

    if ( status == STATUS_PENDING ) {
        status = ZwWaitForSingleObject(eventHandle,
                                       FALSE,
                                       NULL);
        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                       "[ClusDisk] DeviceArrival, IOCTL_DISK_GET_DRIVE_LAYOUT_EX failed %08X \n",
                        status ));
        CDLOG( "DeviceArrival: IOCTL_DISK_GET_DRIVE_LAYOUT_EX failed %08X ",
                status );
        goto FnExit;
    }

    //
    // Only process MBR disks.
    //

    if ( PARTITION_STYLE_MBR != driveLayoutInfo->PartitionStyle ) {
        ClusDiskPrint(( 3,
                       "[ClusDisk] DeviceArrival, Skipping non-MBR disk \n" ));
        CDLOG( "DeviceArrival: Skipping non-MBR disk " );
        goto FnExit;
    }

    //
    // No signature or system disk signature, don't add it.
    //

    if ( ( 0 == driveLayoutInfo->Mbr.Signature ) ||
         SystemDiskSignature == driveLayoutInfo->Mbr.Signature ) {

        ClusDiskPrint(( 1,
                        "[ClusDisk] DeviceArrival, invalid signature %08X \n",
                        driveLayoutInfo->Mbr.Signature ));
        CDLOG( "DeviceArrival: invalid signature %08X ",
                driveLayoutInfo->Mbr.Signature );

        status = STATUS_SUCCESS;
        goto FnExit;
    }

    //
    // Get the SCSI address.
    //

    status = ZwDeviceIoControlFile( fileHandle,
                                    eventHandle,
                                    NULL,
                                    NULL,
                                    &ioStatusBlock,
                                    IOCTL_SCSI_GET_ADDRESS,
                                    NULL,
                                    0,
                                    &scsiAddress,
                                    sizeof(SCSI_ADDRESS) );
    if ( status == STATUS_PENDING ) {
        status = ZwWaitForSingleObject(eventHandle,
                                       FALSE,
                                       NULL);
        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                       "[ClusDisk] DeviceArrival, IOCTL_SCSI_GET_ADDRESS failed %08X \n",
                        status ));
        CDLOG( "DeviceArrival: IOCTL_SCSI_GET_ADDRESS failed %08X ",
                status );
        goto FnExit;
    }

    //
    // Get the device and partition number.
    //
    status = ZwDeviceIoControlFile( fileHandle,
                                    eventHandle,
                                    NULL,
                                    NULL,
                                    &ioStatusBlock,
                                    IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                    NULL,
                                    0,
                                    &deviceNumber,
                                    sizeof(deviceNumber) );
    if ( status == STATUS_PENDING ) {
        status = ZwWaitForSingleObject(eventHandle,
                                       FALSE,
                                       NULL);
        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                       "[ClusDisk] DeviceArrival, IOCTL_STORAGE_GET_DEVICE_NUMBER failed %08X \n",
                        status ));
        CDLOG( "DeviceArrival: IOCTL_STORAGE_GET_DEVICE_NUMBER failed %08X ",
                status );
        goto FnExit;
    }

    //
    // If not a disk type device, we are done.  For example, CD-ROM devices
    // show up as volumes.
    //

    if ( FILE_DEVICE_DISK != deviceNumber.DeviceType ) {
        status = STATUS_SUCCESS;
        ClusDiskPrint(( 1,
                       "[ClusDisk] DeviceArrival, device is not disk type, skipping \n" ));
        CDLOG( "DeviceArrival: Device is not disk type, skipping" );
        goto FnExit;
    }

    //
    // Check if signature is one we should control.  If not, exit.
    //

    if ( !ClusDiskIsSignatureDisk( driveLayoutInfo->Mbr.Signature ) ) {

        ClusDiskPrint(( 1,
                       "[ClusDisk] DeviceArrival, Signature %08X not in list, skipping \n",
                        driveLayoutInfo->Mbr.Signature ));
        CDLOG( "DeviceArrival: Signature %08X not in list, skipping",
                driveLayoutInfo->Mbr.Signature );

        //
        // Signature was not in the signature list.  Add signature to the list
        // if acceptable.
        //

        if ( (SystemDiskPort != scsiAddress.PortNumber) ||
             (SystemDiskPath != scsiAddress.PathId) ) {
            //
            // Allocate buffer for Signatures registry key. So we can add
            // the signature to the available list.
            //
            status = ClusDiskInitRegistryString( &availableName,
                                                 CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                                 wcslen(CLUSDISK_AVAILABLE_DISKS_KEYNAME)
                                                 );

            if ( NT_SUCCESS(status) ) {
                //
                // Create the signature key under \Parameters\AvailableDisks
                //
                status = ClusDiskAddSignature( &availableName,
                                               driveLayoutInfo->Mbr.Signature,
                                               TRUE
                                               );

                FREE_DEVICE_NAME_BUFFER( availableName )
            }
            if ( NT_SUCCESS(status) ) {
                ClusDiskPrint(( 3,
                                "[ClusDisk] DeviceArrival, added signature %08LX to available list \n",
                                driveLayoutInfo->Mbr.Signature ));
            } else {
                ClusDiskPrint(( 1,
                                "[ClusDisk] DeviceArrival, failed to add signature %08LX.  Error %08X.\n",
                                driveLayoutInfo->Mbr.Signature,
                                status ));
            }
        }

        goto FnExit;
    }

    //
    // Try to open the clusdisk object.  If it already exists, then we don't
    // need to do anything.
    //

    if ( FAILED( StringCchPrintfW( deviceNameBuffer,
                                   RTL_NUMBER_OF(deviceNameBuffer),
                                   CLUSDISK_DEVICE_NAME,
                                   deviceNumber.DeviceNumber,
                                   deviceNumber.PartitionNumber ) ) ) {
        goto FnExit;
    }

    WCSLEN_ASSERT( deviceNameBuffer );

    RtlInitUnicodeString( &deviceName, deviceNameBuffer );

    InitializeObjectAttributes( &objectAttributes,
                                &deviceName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = ZwOpenFile( &deviceHandle,
                         FILE_READ_ATTRIBUTES,
                         &objectAttributes,
                         &ioStatusBlock,
                         0,
                         FILE_NON_DIRECTORY_FILE );

    if ( NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                       "[ClusDisk] DeviceArrival, skipping existing clusdisk device \n" ));
        CDLOG( "DeviceArrival: skipping existing clusdisk device " );
        goto FnExit;
    }

    //
    // Allocate and prepare a work item to finish the processing.
    //

    workItem = IoAllocateWorkItem( DeviceExtension->DeviceObject );

    if ( NULL == workItem ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] DeviceArrival: Failed to allocate WorkItem \n" ));
        goto FnExit;
    }

    workContext = ExAllocatePool( NonPagedPool, sizeof( DEVICE_CHANGE_CONTEXT ) );

    if ( !workContext ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] DeviceArrival: Failed to allocate context \n" ));
        goto FnExit;
    }

    RtlZeroMemory( workContext, sizeof( DEVICE_CHANGE_CONTEXT ) );
    workContext->WorkItem = workItem;
    workContext->DeviceExtension = DeviceExtension;

    //
    // We have to copy the symbolic link info as pnp thread may free the
    // structures on return.
    //

    workContext->SymbolicLinkName.Length = 0;
    workContext->SymbolicLinkName.MaximumLength = DeviceChangeNotification->SymbolicLinkName->MaximumLength +
                                                  sizeof(UNICODE_NULL);

    symLinkBuffer = ExAllocatePool( PagedPool,
                                    workContext->SymbolicLinkName.MaximumLength );

    if ( !symLinkBuffer ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] DeviceArrival: Failed to allocate symlink buffer \n" ));
        goto FnExit;
    }

    workContext->SymbolicLinkName.Buffer = symLinkBuffer;

    RtlCopyUnicodeString( &workContext->SymbolicLinkName, DeviceChangeNotification->SymbolicLinkName );

    workContext->Signature = driveLayoutInfo->Mbr.Signature;
    workContext->DeviceNumber = deviceNumber.DeviceNumber;
    workContext->PartitionNumber = deviceNumber.PartitionNumber;
    workContext->ScsiAddress = scsiAddress;

    if ( VolumeArrival ) {

        PDEVICE_OBJECT          part0Device = NULL;
        PFILE_OBJECT            part0FileObject = NULL;

        PCLUS_DEVICE_EXTENSION  zeroExtension;

        WCHAR                   part0Name[MAX_CLUSDISK_DEVICE_NAME_LENGTH];

        UNICODE_STRING          part0UnicodeString;

        //
        // WARNING!
        // Don't use AttachedDevice() or deadlock might occur acquiring
        // ClusDiskDeviceLock.
        //

        //
        // It is possible that the Partition0 device is online: disk marked online
        // then partition manager poked to bring the new volumes online.  In this
        // case, we should leave the volume online and create the new clusdisk volume
        // object.  Now we try to find out if the Partition0 device is online.
        // If online, we don't need to do anything as default state is online.
        // If offline, set this new volume device to offline.
        //

        //
        // Get Partition0 device and look at the state in the device extension.
        // If Partition0 online, leave the volume online.
        // If we can't get the Partition0 device, then set the volume state to offline.
        //

        //
        // Open ClusDiskXPart0 directly.
        //

        if ( FAILED( StringCchPrintfW( part0Name,
                                       RTL_NUMBER_OF(part0Name),
                                       CLUSDISK_DEVICE_NAME,
                                       deviceNumber.DeviceNumber,
                                       0 ) ) ) {
            goto FnExit;
        }

        RtlInitUnicodeString( &part0UnicodeString, part0Name );

        status = IoGetDeviceObjectPointer( &part0UnicodeString,
                                           FILE_READ_ATTRIBUTES,
                                           &part0FileObject,
                                           &part0Device );

        if ( NT_SUCCESS(status) ) {

            zeroExtension = part0Device->DeviceExtension;

            if ( zeroExtension ) {

#if CLUSTER_FREE_ASSERTS
                DbgPrint("[ClusDisk] Part0 state: %d \n", zeroExtension->DiskState );
#endif

                if ( DiskOffline == zeroExtension->DiskState ) {

                    ClusDiskPrint(( 3,
                                    "[ClusDisk] DeviceArrival: DevExt for disk %d / part 0 indicates offline. \n",
                                    deviceNumber.DeviceNumber ));
                    CDLOG( "DeviceArrival: DevExt disk %d / part 0 indicates offline",
                            deviceNumber.DeviceNumber );

                    //
                    // Mark the volume offline and we'll reset correct volume state in the worker
                    // routine.
                    //

                    SendFtdiskIoctlSync( NULL,
                                         deviceNumber.DeviceNumber,
                                         deviceNumber.PartitionNumber,
                                         IOCTL_VOLUME_OFFLINE );
                }

            }

            ObDereferenceObject( part0FileObject );

        } else {

            ClusDiskPrint(( 1,
                            "[ClusDisk] DeviceArrival: Failed to get devobj %ws for signature %08X  status %08X \n",
                            part0Name,
                            driveLayoutInfo->Mbr.Signature,
                            status ));
            CDLOG( "DeviceArrival: Failed to get devobj %ws for signature %08X  status %08X ",
                   part0Name,
                   driveLayoutInfo->Mbr.Signature,
                   status );

        }

        status = STATUS_SUCCESS;

#if CLUSTER_FREE_ASSERTS
        DbgPrint("[ClusDisk] Queuing volume: %ws \n", DeviceChangeNotification->SymbolicLinkName->Buffer );
        InterlockedIncrement( &ClusDiskDebugVolumeNotificationQueued );
#endif

        ClusDiskPrint(( 3,
                        "[ClusDisk] DeviceArrival: Queuing work item \n" ));

        //
        // Queue the workitem.  IoQueueWorkItem will insure that the device object is
        // referenced while the work-item progresses.
        //

        cleanupRequired = FALSE;

        IoQueueWorkItem( workItem,
                         ClusDiskVolumeChangeNotificationWorker,
                         DelayedWorkQueue,
                         workContext );

    } else {

        PPARTITION_INFORMATION_EX   partitionInfo;
        ULONG partIndex;

        // Offline all volumes on this device.

        for ( partIndex = 0;
              partIndex < driveLayoutInfo->PartitionCount;
              partIndex++ ) {

            partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

            if ( 0 ==  partitionInfo->PartitionNumber ) {
                continue;
            }

            status = SendFtdiskIoctlSync( NULL,
                                          deviceNumber.DeviceNumber,
                                          partitionInfo->PartitionNumber,
                                          IOCTL_VOLUME_OFFLINE );

            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint(( 1,
                                "[ClusDisk] DeviceArrival: Failed to set state disk%d part%d , status %08X \n",
                                deviceNumber.DeviceNumber,
                                partitionInfo->PartitionNumber,
                                status
                                ));
            }

        }
        status = STATUS_SUCCESS;

#if CLUSTER_FREE_ASSERTS
        DbgPrint("[ClusDisk] Queuing disk: %ws \n", DeviceChangeNotification->SymbolicLinkName->Buffer );
        InterlockedIncrement( &ClusDiskDebugDiskNotificationQueued );
#endif

        ClusDiskPrint(( 3,
                        "[ClusDisk] DeviceArrival: Queuing work item \n" ));

        //
        // Queue the workitem.  IoQueueWorkItem will insure that the device object is
        // referenced while the work-item progresses.
        //

        cleanupRequired = FALSE;

        IoQueueWorkItem( workItem,
                         ClusDiskDeviceChangeNotificationWorker,
                         DelayedWorkQueue,
                         workContext );

    }

FnExit:

    if ( cleanupRequired ) {
        if ( workItem ) {
            IoFreeWorkItem( workItem );
        }

        if ( workContext ) {
            ExFreePool( workContext );
        }

        if ( symLinkBuffer ) {
            ExFreePool( symLinkBuffer );
        }

#if CLUSTER_FREE_ASSERTS
        if ( VolumeArrival ) {
            DbgPrint("[ClusDisk] Skipping volume: %ws \n", DeviceChangeNotification->SymbolicLinkName->Buffer );
            InterlockedIncrement( &ClusDiskDebugVolumeNotificationSkipped );
        } else {
            DbgPrint("[ClusDisk] Skipping disk: %ws \n", DeviceChangeNotification->SymbolicLinkName->Buffer );
            InterlockedIncrement( &ClusDiskDebugDiskNotificationSkipped );
        }
#endif

    }

    if ( driveLayoutInfo ) {
        ExFreePool( driveLayoutInfo );
    }

    if ( eventHandle ) {
        ZwClose( eventHandle );
    }

    if ( fileHandle ) {
        ZwClose( fileHandle );
    }

    if ( deviceHandle ) {
        ZwClose( deviceHandle );
    }

    CDLOG( "DeviceArrival: Exit, DO %p", DeviceExtension->DeviceObject );

    return STATUS_SUCCESS;

}   // ProcessDeviceArrival



NTSTATUS
ClusDiskDeviceChangeNotificationWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    Handle the arrival of new disk spindles. We only want to add the signature
    to the available list if it is not already a known signature.

    If the signature matches one we should be controlling, we also need to
    try to attach to the disk.

    This routine must free the workitem structure.

Arguments:

    DeviceObject - the root device object

    Context - information relevant to processing this device change.


Return Value:

    NTSTATUS for this request.

--*/
{
    PDEVICE_CHANGE_CONTEXT      deviceChange = Context;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    PIO_WORKITEM                workItem;
    PUNICODE_STRING             symbolicLinkName;
    NTSTATUS                    status;
    ULONG                       signature;
    BOOLEAN                     stopProcessing = FALSE;

    CDLOG( "DeviceChangeWorker: Entry DO %p", DeviceObject );

    deviceExtension = deviceChange->DeviceExtension;
    workItem = deviceChange->WorkItem;
    symbolicLinkName = &deviceChange->SymbolicLinkName;
    signature = deviceChange->Signature;

    ClusDiskPrint(( 3,
                    "[ClusDisk] DeviceChangeWorker, A new disk device arrived  signature %08X \n   %ws\n",
                    signature,
                    symbolicLinkName->Buffer ));

    //
    // Check if signature is already in signature list.  If in the signature
    // list, try to attach again.  If we are already attached, nothing will
    // happen.  If we are not attached, we will attach and make sure the disk
    // is offline.
    //

    if ( ClusDiskIsSignatureDisk( signature ) ) {

        //
        // Try to attach, but don't generate a reset.
        //

        ClusDiskAttachDevice( signature,
                              0,
                              deviceExtension->DriverObject,
                              FALSE,                                // No reset
                              &stopProcessing,
                              FALSE );                              // Offline, then dismount

        status = STATUS_SUCCESS;
        goto FnExit;
    }

FnExit:

#if CLUSTER_FREE_ASSERTS
    DbgPrint("[ClusDisk] Completed disk: %ws \n", symbolicLinkName->Buffer );
    InterlockedIncrement( &ClusDiskDebugDiskNotificationEnded );
#endif

    ClusDiskPrint(( 3,
                    "[ClusDisk] DeviceChangeWorker, Exit  signature %08X \n",
                    signature ));

    CDLOG( "DeviceChangeWorker: Exit, DO %p", deviceExtension->DeviceObject );

    //
    // Free the work item.
    //

    IoFreeWorkItem( workItem );
    if ( symbolicLinkName->Buffer ) {
        ExFreePool( symbolicLinkName->Buffer );
    }
    if ( Context ) {
        ExFreePool( Context );
    }

    return(STATUS_SUCCESS);

} // ClusDiskDeviceChangeNotificationWorker



NTSTATUS
ClusDiskVolumeChangeNotificationWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    Handle the arrival of new volumes. We only want to attach to the
    volume if the signature is already in the signature list.

    This routine must free the workitem structure.

Arguments:

    DeviceObject - the root device object

    Context - information relevant to processing this device change.


Return Value:

    NTSTATUS for this request.

--*/
{
    PDEVICE_CHANGE_CONTEXT      deviceChange = Context;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    PCLUS_DEVICE_EXTENSION      zeroExtension = NULL;
    PIO_WORKITEM                workItem;
    PUNICODE_STRING             symbolicLinkName;
    PDEVICE_OBJECT              part0Device = NULL;
    PDEVICE_OBJECT              targetDevice = NULL;
    PDEVICE_OBJECT              dummyDeviceObj;
    PFILE_OBJECT                fileObject;

    NTSTATUS                    status;

    ULONG                       signature;

    deviceExtension = deviceChange->DeviceExtension;
    workItem = deviceChange->WorkItem;
    symbolicLinkName = &deviceChange->SymbolicLinkName;
    signature = deviceChange->Signature;

    CDLOG( "VolumeChangeWorker: Entry DO %p  context %p  signature %08X  DevExt %p ",
           DeviceObject,
           Context,
           signature,
           deviceExtension );
    ClusDiskPrint(( 3,
                    "[ClusDisk] VolumeChangeWorker: Entry DO %p  context %p  signature %08X  DevExt %p \n",
                    DeviceObject,
                    Context,
                    signature,
                    deviceExtension ));

    //
    // Make sure the disk object is attached.  If not, we are done.
    //

    if ( !AttachedDevice( signature,
                          &part0Device ) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] VolumeChangeWorker, partition0 not attached for signature %08X \n",
                        signature ));
        CDLOG( "VolumeChangeWorker: partition0 not attached for signature %08X ",
                signature );

        status = STATUS_SUCCESS;
        goto FnExit;
    }

    //
    // Make sure the disk object doesn't go away until we are done.
    //
    ObReferenceObject( part0Device );
    zeroExtension = part0Device->DeviceExtension;

    if ( !zeroExtension ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] VolumeChangeWorker, partition0 DE does not exist for signature %08X \n",
                        signature ));
        CDLOG( "VolumeChangeWorker: partition0 DE does not exist for signature %08X ",
                signature );

        status = STATUS_SUCCESS;
        goto FnExit;
    }

    //
    // Get the target device we should attach to.
    //

    status = IoGetDeviceObjectPointer( symbolicLinkName,
                                       FILE_READ_ATTRIBUTES,
                                       &fileObject,
                                       &dummyDeviceObj );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] VolumeChangeWorker: Failed to get target devobj.  Error %08X \n",
                        status ));
        CDLOG( "VolumeChangeWorker: GetDevObj failed, status %!status!",
               status );
        goto FnExit;
    }

    if ( !(fileObject->Flags & FO_DIRECT_DEVICE_OPEN) ) {
        targetDevice = IoGetRelatedDeviceObject( fileObject );

        // Add a reference to the object so we can dereference it later.
        ObReferenceObject( targetDevice );

        //
        // If we get a file system device object... go back and get the
        // device object.
        //
        if ( targetDevice->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM ) {
            ObDereferenceObject( targetDevice );
            targetDevice = IoGetAttachedDeviceReference( fileObject->DeviceObject );
        }
        ClusDiskPrint(( 3,
                        "[ClusDisk] VolumeChangeWorker (DIRECT_OPEN) fileObj = %p, devObj= %p \n",
                        fileObject,
                        targetDevice ));
    } else {
        targetDevice = IoGetAttachedDeviceReference( fileObject->DeviceObject );
        ClusDiskPrint(( 3,
                        "[ClusDisk] VolumeChangeWorker: fileObj = %p, devObj= %p \n",
                        fileObject,
                        targetDevice ));
    }
    ObDereferenceObject( fileObject );

    //
    // At this point, the target object will have a reference to it.
    // Now we can create the volume object.
    //

    status = CreateVolumeObject( zeroExtension,
                                 deviceChange->DeviceNumber,
                                 deviceChange->PartitionNumber,
                                 targetDevice );

#if 0
    // Ignore returned status and reset the volume offline/online status.

    //
    // The only acceptable failure is name collision, which means the clusdisk
    // volume already exists.  For any other errors, we leave the volume state
    // offline.
    //
    // Seen this error also returned: c000000e STATUS_NO_SUCH_DEVICE
    //

    if ( STATUS_OBJECT_NAME_COLLISION != status ) {
        goto FnExit;
    }
#endif

FnExit:

#if CLUSTER_FREE_ASSERTS
    if ( !NT_SUCCESS(status) ) {
        DbgPrint("[ClusDisk] Failed volume addition %08X \n", status );
        if ( STATUS_OBJECT_NAME_COLLISION != status ) {
            DbgBreakPoint();
        }
    }
#endif

    //
    // Reset volume state according to partition0 state.
    //

    if ( zeroExtension ) {

        if ( DiskOffline == zeroExtension->DiskState ) {

            SendFtdiskIoctlSync( targetDevice,
                                 deviceChange->DeviceNumber,
                                 deviceChange->PartitionNumber,
                                 IOCTL_VOLUME_OFFLINE );
        } else {

            SendFtdiskIoctlSync( targetDevice,
                                 deviceChange->DeviceNumber,
                                 deviceChange->PartitionNumber,
                                 IOCTL_VOLUME_ONLINE );
        }
    }

    if ( part0Device ) {
        ObDereferenceObject( part0Device );
    }

    if ( targetDevice ) {
        ObDereferenceObject( targetDevice );
    }

#if CLUSTER_FREE_ASSERTS
    DbgPrint("[ClusDisk] Completed volume: %ws \n", symbolicLinkName->Buffer );
    InterlockedIncrement( &ClusDiskDebugVolumeNotificationEnded );
#endif

    CDLOG( "VolumeChangeWorker: Exit, DO %p  context %p",
           DeviceObject,
           Context );
    ClusDiskPrint(( 3,
                    "[ClusDisk] VolumeChangeWorker: Exit DO %p  context %p \n",
                    DeviceObject,
                    Context ));

    //
    // Free the work item.
    //

    IoFreeWorkItem( workItem );
    if ( symbolicLinkName->Buffer ) {
        ExFreePool( symbolicLinkName->Buffer );
    }
    if ( Context ) {
        ExFreePool( Context );
    }

    return(STATUS_SUCCESS);

} // ClusDiskVolumeChangeNotificationWorker



NTSTATUS
ClusDiskInitialize(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Common intialization for ClusDisk

Arguments:

    DriverObject - The Cluster Disk driver object.

Return Value:

    NTSTATUS for this request.

--*/

{
    ULONG                       status;
    PDEVICE_OBJECT              rootDevice;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    UNICODE_STRING              uniNameString;

    //
    // Find the bus on which the system disk is loaded.
    //
    status = GetSystemRootPort();
    if ( !NT_SUCCESS( status )) {
        return status;
    }

    //
    // Initialize the global locks.
    //
    KeInitializeSpinLock(&ClusDiskSpinLock);
    ExInitializeResourceLite(&ClusDiskDeviceListLock);

    //
    // Init halt processing work item
    //

    ExInitializeWorkItem( &HaltWorkItem,
                          (PWORKER_THREAD_ROUTINE)ClusDiskHaltProcessingWorker,
                          NULL );

    //
    // Init rescan processing work item
    //

    ExInitializeWorkItem( &ClusDiskRescanWorkItem,
                          (PWORKER_THREAD_ROUTINE)ClusDiskRescanWorker,
                          NULL );

    //
    // Reset all SCSI busses.
    //
    //ResetScsiBusses();

    //
    // Create device object for \Device\ClusDisk0
    //

    RtlInitUnicodeString( &uniNameString, CLUSDISK_ROOT_DEVICE );

    status = IoCreateDevice(DriverObject,
                            sizeof(CLUS_DEVICE_EXTENSION),
                            &uniNameString,
                            FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &rootDevice);

    if ( !NT_SUCCESS(status) ) {
        return(status);
    }

    rootDevice->Flags |= DO_DIRECT_IO;

    deviceExtension = rootDevice->DeviceExtension;
    deviceExtension->DeviceObject = rootDevice;
    deviceExtension->DiskNumber = UNINITIALIZED_DISK_NUMBER;
    deviceExtension->LastPartitionNumber = 0;
    deviceExtension->DriverObject = DriverObject;
    deviceExtension->BusType = RootBus;
    deviceExtension->DiskState = DiskOffline;
    deviceExtension->AttachValid = FALSE;
    deviceExtension->PerformReserves = FALSE;
    deviceExtension->ReserveFailure = 0;
    deviceExtension->Signature = 0xffffffff;
    deviceExtension->Detached = TRUE;
    deviceExtension->OfflinePending = FALSE;
    InitializeListHead( &deviceExtension->WaitingIoctls );
    deviceExtension->SectorSize = 0;
    deviceExtension->ArbitrationSector = 12;

    IoInitializeRemoveLock( &deviceExtension->RemoveLock, CLUSDISK_ALLOC_TAG, 0, 0 );

    //
    // Signal the worker thread running event.
    //
    KeInitializeEvent( &deviceExtension->Event, NotificationEvent, TRUE );

    KeInitializeEvent( &deviceExtension->PagingPathCountEvent,
                       NotificationEvent, TRUE );
    deviceExtension->PagingPathCount = 0;
    deviceExtension->HibernationPathCount = 0;
    deviceExtension->DumpPathCount = 0;

    ExInitializeResourceLite( &deviceExtension->DriveLayoutLock );
    ExInitializeResourceLite( &deviceExtension->ReserveInfoLock );

    //
    // Init the tick handler timer
    //
    IoInitializeTimer( rootDevice, ClusDiskTickHandler, NULL );

    //
    // This is the physical device object for \Device\ClusDisk0.
    //
    ObReferenceObject( rootDevice );
    deviceExtension->PhysicalDevice = rootDevice;

    RootDeviceObject = rootDevice;

    //
    // Call the initialize routine (for each bus type) for the first time.
    //
    // With the new PNP stuff, we should be able to remove the following call.
    // It's been tried and it seems to work correctly. rodga.
    //
    ClusDiskScsiInitialize(DriverObject, 0, 0);

    //
    // Register for disk device notifications
    // If we called ClusDiskScsiInitialize just above, we don't have to register for notification
    // with PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES flag set (second parameter).
    //
    // Try setting second parm to see if we missed notifications.

    status = IoRegisterPlugPlayNotification(EventCategoryDeviceInterfaceChange,
                                            PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
                                            (PVOID)&DiskClassGuid,
                                            DriverObject,
                                            ClusDiskDeviceChangeNotification,
                                            deviceExtension,
                                            &deviceExtension->DiskNotificationEntry);
    if (!NT_SUCCESS(status)) {
        RootDeviceObject = NULL;
        ExDeleteResourceLite( &deviceExtension->DriveLayoutLock );
        ExDeleteResourceLite( &deviceExtension->ReserveInfoLock );
        IoDeleteDevice( rootDevice );
        return status;
    }

    //
    // Register for volume notifications
    // If we called ClusDiskScsiInitialize just above, we don't have to register for notification
    // with PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES flag set (second parameter).
    //
    // Try setting second parm to see if we missed notifications.

    status = IoRegisterPlugPlayNotification(EventCategoryDeviceInterfaceChange,
                                            PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
                                            (PVOID)&VolumeClassGuid,
                                            DriverObject,
                                            ClusDiskVolumeChangeNotification,
                                            deviceExtension,
                                            &deviceExtension->VolumeNotificationEntry);
    if (!NT_SUCCESS(status)) {
        IoUnregisterPlugPlayNotification( &deviceExtension->DiskNotificationEntry );
        RootDeviceObject = NULL;
        ExDeleteResourceLite( &deviceExtension->DriveLayoutLock );
        ExDeleteResourceLite( &deviceExtension->ReserveInfoLock );
        IoDeleteDevice( rootDevice );
        return status;
    }

    //
    // Start the tick handler.
    //
    IoStartTimer( rootDevice );

#if defined(WMI_TRACING)

    status = IoWMIRegistrationControl (rootDevice, WMIREG_ACTION_REGISTER);
    if (!NT_SUCCESS(status)) {
        ClusDiskPrint((1, "[ClusDisk] Failed to register with WMI %x.\n",status));
    }

#endif // WMI_TRACING

    return( STATUS_SUCCESS );

} // ClusDiskInitialize



NTSTATUS
ClusDiskPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is a generic dispatch for all unsupported
    major IRP types

    Note that we don't have to worry about the RemoveLock as
    we are simply passing I/O's to the next driver.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION deviceExtension =
        (PCLUS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS    status;

    if ( deviceExtension->BusType == RootBus ) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    //
    // Make sure the device attach completed.
    //
    status = WaitForAttachCompletion( deviceExtension,
                                      TRUE,             // Wait
                                      TRUE );           // Also check physical device
    if ( !NT_SUCCESS( status ) ) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);
}


NTSTATUS
ClusDiskPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for the IRP_MJ_PNP_POWER.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension =
        (PCLUS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDisk =
                               deviceExtension->PhysicalDevice->DeviceExtension;
    NTSTATUS    status;

    ClusDiskPrint(( 3,
                    "[ClusDisk] Processing Power IRP %p for device %p \n",
                    Irp,
                    DeviceObject ));

    //
    // Always call PoStartnextPowerIrp, even if we couldn't get the RemoveLock.
    //

    PoStartNextPowerIrp( Irp );

    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Make sure the device attach completed.
    //
    status = WaitForAttachCompletion( deviceExtension,
                                      TRUE,             // Wait
                                      TRUE );           // Also check physical device
    if ( !NT_SUCCESS( status ) ) {
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Always send IRP_MJ_POWER request down the stack.
    //

    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(deviceExtension->TargetDeviceObject, Irp);


} // ClusDiskPowerDispatch


NTSTATUS
ClusDiskIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Forwarded IRP completion routine. Set an event and return
    STATUS_MORE_PROCESSING_REQUIRED. Irp forwarder will wait on this
    event and then re-complete the irp after cleaning up.

Arguments:

    DeviceObject is the device object of the WMI driver
    Irp is the WMI irp that was just completed
    Context is a PKEVENT that forwarder will wait on

Return Value:

    STATUS_MORE_PORCESSING_REQUIRED

--*/

{
    PKEVENT event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    //
    // Don't need to release the RemoveLock as it is still held by the routine
    // that set this completion routine and will be released after we set the
    // event.
    //

    KeSetEvent( event, IO_NO_INCREMENT, FALSE );

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // ClusDiskIrpCompletion



NTSTATUS
ClusDiskPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for the IRP_MJ_PNP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION deviceExtension =
        (PCLUS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp;
    PDEVICE_OBJECT      targetObject;
    PDEVICE_LIST_ENTRY  deviceEntry;
    KIRQL               irql;

    // PAGED_CODE();

    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    CDLOG( "ClusDiskPnpDispatch_Entry(%p): IrpMn %!pnpmn!", DeviceObject, irpSp->MinorFunction );

    ClusDiskPrint(( 3,
                    "[ClusDisk] PNP IRP for devobj %p MinorFunction: %s (%lx) \n",
                    DeviceObject,
                    PnPMinorFunctionString( irpSp->MinorFunction ),
                    irpSp->MinorFunction ));


    //
    // If the driver unloads, the clusdisk0 control device could be removed.
    //
    if ( deviceExtension->BusType == RootBus ) {
        ClusDiskPrint(( 1, "[ClusDisk] PNP IRP for root bus - failing \n" ));
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_DEVICE_BUSY);
    }

    //
    // Make sure the device attach completed.
    //
    status = WaitForAttachCompletion( deviceExtension,
                                      TRUE,             // Wait
                                      FALSE );          // Don't check physical device
    if ( !NT_SUCCESS( status ) ) {
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // We should the following order on a remove request.
    //
    // 1. IRP_MN_QUERY_REMOVE_DEVICE
    //      Don't accept any new operations
    // 2. IRP_MN_REMOVE_DEVICE if success on all drivers in stack
    //      Remove the device
    // 3. IRP_MN_CANCEL_REMOVE_DEVICE if remove fails
    //      Resume activity
    //

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_QUERY_REMOVE_DEVICE:
        ClusDiskPrint((1,
                    "[ClusDisk] QueryRemoveDevice PNP IRP on devobj %p \n",
                    DeviceObject));
        break;  // just pass it on

    case IRP_MN_SURPRISE_REMOVAL: {

        //
        // For physical device, dismount everything.
        //

        if ( DeviceObject != deviceExtension->PhysicalDevice ||
             DeviceObject == RootDeviceObject ) {
            break;
        }

#if 0
        //
        // Holding the RemoveLock here will result in deadlock.  Referencing the
        // device object will keep the device object and extension in place
        // until the dismount completes.
        //

        //
        // Acquire remove lock one more time so dismount code can run.
        // If we can't get the lock, we won't dismount.  The dismount code
        // will release the lock.
        //

        status = AcquireRemoveLock( &deviceExtension->RemoveLock, deviceExtension );
        if ( !NT_SUCCESS(status) ) {
            // If we can't get the RemoveLock, skip this device.
            break;
        }
#endif

#if CLUSTER_FREE_ASSERTS
        DbgPrint("[ClusDisk] IRP_MN_SURPRISE_REMOVAL for %p \n", DeviceObject );
#endif

        //
        // Capture all file handles for this device.
        //

        ProcessDelayedWorkSynchronous( DeviceObject, ClusDiskpOpenFileHandles, NULL );

        // Keep the device object around
        ObReferenceObject( DeviceObject );
        ClusDiskDismountVolumes( DeviceObject,
                                 FALSE );           // Don't release RemoveLock (it is not held).

        break;  // pass it to the next driver
    }

    case IRP_MN_REMOVE_DEVICE: {

        REPLACE_CONTEXT context;

        ClusDiskPrint((1,
                    "[ClusDisk] RemoveDevice PNP IRP on devobj %p \n",
                    DeviceObject));

#if CLUSTER_FREE_ASSERTS
        DbgPrint("[ClusDisk] IRP_MN_REMOVE_DEVICE for %p \n", DeviceObject );
#endif

        //
        // Flush all queued I/O.
        //

        ClusDiskCompletePendedIrps(deviceExtension,
                                   NULL,               // Will complete all IRPs
                                   FALSE               // Don't set the device state
                                   );

        //
        // Wait for I/O to complete before removing the device.
        //

        ReleaseRemoveLockAndWait(&deviceExtension->RemoveLock, Irp);

        // 2000/02/05: stevedz - Moved this code from the legacy unload routine.

        if ( DeviceObject == RootDeviceObject ) {

            IoStopTimer( DeviceObject );

            IoUnregisterPlugPlayNotification( deviceExtension->DiskNotificationEntry );
            IoUnregisterPlugPlayNotification( deviceExtension->VolumeNotificationEntry );

            RootDeviceObject = NULL;
        }

        ACQUIRE_SHARED( &ClusDiskDeviceListLock );

        // Release the device list entry for this device object

        deviceEntry = ClusDiskDeviceList;
        while ( deviceEntry ) {
            if ( deviceEntry->DeviceObject == DeviceObject ) {
                deviceEntry->FreePool = TRUE;
                CleanupDeviceList( DeviceObject );
                break;
            }
            deviceEntry = deviceEntry->Next;
        }

        targetObject = deviceExtension->TargetDeviceObject;
        KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
        deviceExtension->Detached = TRUE;
        deviceExtension->TargetDeviceObject = NULL;
        KeReleaseSpinLock(&ClusDiskSpinLock, irql);
        RELEASE_SHARED( &ClusDiskDeviceListLock );

        context.DeviceExtension = deviceExtension;
        context.NewValue        = NULL;     // clear the field
        context.Flags           = 0;        // don't dismount

        ProcessDelayedWorkSynchronous( DeviceObject, ClusDiskpReplaceHandleArray, &context );

        //
        // Free the cached drive layout (if any).
        //

        ACQUIRE_EXCLUSIVE( &deviceExtension->DriveLayoutLock );

        if ( deviceExtension->DriveLayout ) {
            ExFreePool( deviceExtension->DriveLayout );
            deviceExtension->DriveLayout = NULL;
        }
        deviceExtension->DriveLayoutSize = 0;

        RELEASE_EXCLUSIVE( &deviceExtension->DriveLayoutLock );

        //
        // [GorN] 10/05/1999
        //
        // The following lock acquisition is causing a deadlock as follows:
        //
        //    Disk is being removed. Clustering detects that and starts dismounting of
        //    cluster disks, while it is doing that it acquires ClusDiskDeviceListLock in
        //    the shared mode. Processing a dismount request, FS reports Dismount PnP event,
        //    this gets blocked on PnP lock.
        //
        //    At the same time, PnP is trying to deliver RemoveDevice, which gets blocked
        //    in clusdisk, when clusdisk is trying to acquire ClusDiskDeviceListLock in
        //    exclusive mode.
        //
        // [HACKHACK] It is better to defer the detaching / deletion to the worker thread
        //    which will be properly protected by exclusive lock

        // ACQUIRE_EXCLUSIVE( &ClusDiskDeviceListLock );

        ExDeleteResourceLite( &deviceExtension->DriveLayoutLock );
        ExDeleteResourceLite( &deviceExtension->ReserveInfoLock );
        IoDetachDevice( targetObject );
        IoDeleteDevice( DeviceObject );

        // RELEASE_EXCLUSIVE( &ClusDiskDeviceListLock );

        CDLOG( "ClusDiskPnpDispatch: IoDeleteDevice DO %p  refCount %d ", DeviceObject, DeviceObject->ReferenceCount );

        // Don't release the RemoveLock as it was done just above.

        IoSkipCurrentIrpStackLocation( Irp );
        return( IoCallDriver( targetObject, Irp ) );


    }

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        ClusDiskPrint((1,
                    "[ClusDisk] CancelRemoveDevice PNP IRP on devobj %p \n",
                    DeviceObject));
        break;


    case IRP_MN_DEVICE_USAGE_NOTIFICATION: {

        UNICODE_STRING              availableName;

        ClusDiskPrint((1,
                    "[ClusDisk] DeviceUsageNotification DevObj %p  Type %08x  InPath %08x \n",
                    DeviceObject,
                    irpSp->Parameters.UsageNotification.Type,
                    irpSp->Parameters.UsageNotification.InPath
                    ));

        //
        // If we are adding one of the special files and the disk is clustered,
        // then fail the request.  We can't have these files on clustered disks.
        // We will allow removal of the special files at any time (online or offline).
        //

        if ( irpSp->Parameters.UsageNotification.InPath &&
             !deviceExtension->Detached ) {

            ClusDiskPrint((1,
                        "[ClusDisk] DeviceUsageNotification - specified device is in cluster - failing request \n"
                        ));
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return (STATUS_INVALID_DEVICE_REQUEST);
        }

        switch ( irpSp->Parameters.UsageNotification.Type ) {

            case DeviceUsageTypePaging: {

                BOOLEAN setPagable;

                //
                // We need this event to synchonize access to the paging count.
                //

                status = KeWaitForSingleObject( &deviceExtension->PagingPathCountEvent,
                                                Executive, KernelMode,
                                                FALSE, NULL );

                //
                // If we are removing the last paging device, we need to set DO_POWER_PAGABLE
                // bit here, and possible re-set it below on failure.
                //

                setPagable = FALSE;

                if ( !irpSp->Parameters.UsageNotification.InPath &&
                     deviceExtension->PagingPathCount == 1 ) {

                    //
                    // We are removing the last paging file.  We must have DO_POWER_PAGABLE bit
                    // set, but only if no one set the DO_POWER_INRUSH bit
                    //


                    if ( DeviceObject->Flags & DO_POWER_INRUSH ) {
                        ClusDiskPrint(( 2,
                                        "[ClusDisk] Last paging file removed, but DO_POWER_INRUSH was already set, devobj %p \n",
                                        DeviceObject ));
                    } else {
                        ClusDiskPrint(( 2,
                                        "[ClusDisk] Last paging file removed, setting DO_POWER_INRUSH, devobj %p \n",
                                        DeviceObject ));
                        DeviceObject->Flags |= DO_POWER_PAGABLE;
                        setPagable = TRUE;
                    }

                }

                //
                // Forward the IRP to the drivers below before finishing handling the
                // special cases.
                //

                status = ClusDiskForwardIrpSynchronous( DeviceObject, Irp );

                //
                // Now deal with the failure and success cases.  Note that we are not allowed
                // to fail the IRP once it is sent to the lower drivers.
                //

                if ( NT_SUCCESS(status) ) {

                    IoAdjustPagingPathCount(
                        &deviceExtension->PagingPathCount,
                        irpSp->Parameters.UsageNotification.InPath);

                    if ( irpSp->Parameters.UsageNotification.InPath ) {
                        if ( deviceExtension->PagingPathCount == 1 ) {
                            ClusDiskPrint(( 2,
                                            "[ClusDisk] Clearing DO_POWER_PAGABLE, devobj %p \n",
                                            DeviceObject ));
                            DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                        }
                    }

                } else {

                    //
                    // Clean up the changes done above.
                    //

                    if ( TRUE == setPagable ) {
                        ClusDiskPrint(( 2,
                                        "[ClusDisk] Clearing DO_POWER_PAGABLE due to IRP failure, devobj %p status %08x \n",
                                        DeviceObject,
                                        status ));
                        DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                        setPagable = FALSE;
                    }

                }

                //
                // Set the event so the next paging request can occur.
                //

                KeSetEvent( &deviceExtension->PagingPathCountEvent,
                            IO_NO_INCREMENT, FALSE );
                break;
            }

            case DeviceUsageTypeHibernation: {

                IoAdjustPagingPathCount( &deviceExtension->HibernationPathCount,
                                         irpSp->Parameters.UsageNotification.InPath );

                status = ClusDiskForwardIrpSynchronous( DeviceObject, Irp );
                if ( !NT_SUCCESS(status) ) {

                    IoAdjustPagingPathCount( &deviceExtension->HibernationPathCount,
                                             !irpSp->Parameters.UsageNotification.InPath );
                }

                break;
            }

            case DeviceUsageTypeDumpFile: {

                IoAdjustPagingPathCount( &deviceExtension->DumpPathCount,
                                         irpSp->Parameters.UsageNotification.InPath );

                status = ClusDiskForwardIrpSynchronous( DeviceObject, Irp );
                if ( !NT_SUCCESS(status) ) {

                    IoAdjustPagingPathCount( &deviceExtension->DumpPathCount,
                                             !irpSp->Parameters.UsageNotification.InPath );
                }

                break;
            }

            default: {
                ClusDiskPrint(( 2,
                                "[ClusDisk] Unrecognized notification type, devobj %p  notification %08x \n",
                                DeviceObject,
                                irpSp->Parameters.UsageNotification.Type ));
                status = STATUS_INVALID_PARAMETER;
                break;
            }


        }

        //
        // This debug print is outside of the synchonization, but that's OK.
        //

        ClusDiskPrint(( 3,
                        "[ClusDisk] PagingCount %08lx  HibernationCount %08x  DumpCount %08x\n",
                        deviceExtension->PagingPathCount,
                        deviceExtension->HibernationPathCount,
                        deviceExtension->DumpPathCount ));

        //
        // We need this event to synchonize access to the paging count.
        //

        status = KeWaitForSingleObject( &deviceExtension->PagingPathCountEvent,
                                        Executive, KernelMode,
                                        FALSE, NULL );

        //
        // If the device is not currently clustered and the paging count is zero,
        // add the disk to Parameters\AvailableDisks list.  Otherwise, remove this
        // disk from the list.  We can only get to this code if we already know
        // the disk is not clustered (i.e. Detached is TRUE).
        //

        ASSERT( deviceExtension->Detached );

        //
        // Allocate buffer for AvailableDisks registry key.
        //

        status = ClusDiskInitRegistryString( &availableName,
                                             CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                             wcslen(CLUSDISK_AVAILABLE_DISKS_KEYNAME) );

        if ( NT_SUCCESS(status) ) {

            if ( 0 == deviceExtension->PagingPathCount &&
                 0 == deviceExtension->HibernationPathCount &&
                 0 == deviceExtension->DumpPathCount ) {

                //
                // Create the signature key under Parameters\AvailableDisks
                //

                ClusDiskAddSignature( &availableName,
                                      deviceExtension->Signature,
                                      TRUE );

            } else {

                //
                // Delete the signature key under Parameters\AvailableDisks.
                //

                ClusDiskDeleteSignature( &availableName,
                                         deviceExtension->Signature );

            }

            FREE_DEVICE_NAME_BUFFER( availableName );

            status = STATUS_SUCCESS;
        }

        //
        // Set the event so the next paging request can occur.
        //

        KeSetEvent( &deviceExtension->PagingPathCountEvent,
                    IO_NO_INCREMENT, FALSE );


        //
        // Complete the IRP.  This IRP was already sent to the lower drivers.
        //

        Irp->IoStatus.Status = status;
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
        break;

    }   // IRP_MN_DEVICE_USAGE_NOTIFICATION

    default:
        break;
    }

    CDLOG( "ClusDiskPnpDispatch: Exit, DO %p", DeviceObject );
    //
    // We don't recognize this IRP - simply pass it on to next guy.
    //

    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    IoSkipCurrentIrpStackLocation(Irp);
    return (IoCallDriver( deviceExtension->TargetDeviceObject,
                          Irp ) );

} // ClusDiskPnpDispatch



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the routine called by the system to initialize the disk
    performance driver. The driver object is set up and then the
    driver calls ClusDiskxxxInitialize to attach to the boot devices.

Arguments:

    DriverObject - The Cluster Disk driver object.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS        status;
    ULONG           i;

    ClusDiskRegistryPath.Buffer = NULL;

#if CLUSDISK_DEBUG
    if ( !ClusDiskGood ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }
#endif

#if ( CLUSTER_FREE_ASSERTS )
    DbgPrint( "[Clusdisk]: CLUSTER_FREE_ASSERTS defined \n");
#endif

    WPP_INIT_TRACING(DriverObject, RegistryPath);

    ClusDiskSystemProcess = (PKPROCESS) IoGetCurrentProcess();

    //
    // Set up the device driver entry points.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = ClusDiskPassThrough;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = ClusDiskCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = ClusDiskClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = ClusDiskCleanup;
    DriverObject->MajorFunction[IRP_MJ_READ] = ClusDiskRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = ClusDiskWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ClusDiskDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = ClusDiskShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = ClusDiskShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_POWER] = ClusDiskPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP] = ClusDiskPnpDispatch;

    //
    // Driver is unloadable. (Not for now... the problem is that the driver
    // can be called at the unload entrypoint even with open file handles.
    // Until this is fixed, disable the unload.)
    //
    // NTRAID#72826-2000/02/05-stevedz ClusDisk.sys Unload routine not supported.
    //
    // This was the closest bug to this problem I could find.  Until this driver
    // is fully PnP or until the reference count bug is fixed, this driver cannot
    // support unload.
    //
    //   DriverObject->DriverUnload = ClusDiskUnload;

    //
    // make a copy of RegistryPath, appending the Parameters subkey
    //

    ClusDiskRegistryPath.MaximumLength = RegistryPath->MaximumLength +
        sizeof( CLUSDISK_PARAMETERS_KEYNAME ) +
        sizeof( UNICODE_NULL );
    ClusDiskRegistryPath.Buffer = ExAllocatePool( NonPagedPool,
                                                  ClusDiskRegistryPath.MaximumLength );

    if ( ClusDiskRegistryPath.Buffer == NULL ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    RtlCopyUnicodeString( &ClusDiskRegistryPath, RegistryPath );
    RtlAppendUnicodeToString( &ClusDiskRegistryPath, CLUSDISK_PARAMETERS_KEYNAME );
    ClusDiskRegistryPath.Buffer[ ClusDiskRegistryPath.Length / sizeof( WCHAR )] = UNICODE_NULL;

    InitializeListHead( &ReplaceRoutineListHead );
    KeInitializeSpinLock( &ReplaceRoutineSpinLock );

    status = ArbitrationInitialize();
    if( !NT_SUCCESS(status) ) {
       ClusDiskPrint((1,
                      "[ClusDisk] ArbitrationInitialize failed, error: %08X\n",
                      status));

       goto FnExit;
    }

    //
    // Find the bus on which the system disk is loaded.
    //

    status = ClusDiskInitialize( DriverObject );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((1,
                       "[ClusDisk] Failed to initialize! %08X\n",
                       status));
    }

FnExit:

    if ( !NT_SUCCESS(status) ) {

        if ( ClusDiskRegistryPath.Buffer ) {
            ExFreePool( ClusDiskRegistryPath.Buffer );
            ClusDiskRegistryPath.Buffer = NULL;
        }

        if ( gArbitrationBuffer ) {
            ExFreePool( gArbitrationBuffer );
            gArbitrationBuffer = NULL;
        }
    }

    return(status);

} // DriverEntry



VOID
ClusDiskTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    Timer routine that handles reservations. Walk all device objects, looking
    for active timers.

Arguments:

    DeviceObject - Supplies a pointer to the root device object.

    Context      - Not used.

Return Value:

    None.

Notes:

    We can't process the reservations at DPC level because reservation
    IOCTL's invoke paged code in the SCSI subsystem.

--*/

{
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    KIRQL                       irql;
    PDEVICE_OBJECT              deviceObject = DeviceObject->DriverObject->DeviceObject;
    LARGE_INTEGER               currentTime;
    LARGE_INTEGER               deltaTime;
    BOOLEAN                     arbitrationTickIsCalled = FALSE;
    NTSTATUS                    status;

    CDLOGF(TICK,"ClusDiskTickHandler: Entry DO %p", DeviceObject );

    //
    // Globally Synchronize
    //
    KeAcquireSpinLock(&ClusDiskSpinLock, &irql);

    if ( ClusDiskRescan && !ClusDiskRescanBusy && ClusDiskRescanRetry ) {
        --ClusDiskRescanRetry;
        ClusDiskRescanBusy = TRUE;
        ExQueueWorkItem(&ClusDiskRescanWorkItem,
                        CriticalWorkQueue );
    }

    CDLOGF(TICK,"ClusDiskTickHandler: SpinLockAcquired DO %p", DeviceObject );

    //
    // Loop through all device objects looking for timeouts...
    //
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;

        //
        // If we have an attached partition0 device object (with a
        // reserve irp) that is is online and has a timer going.
        //
        if ( !deviceExtension->Detached &&
             deviceExtension->PerformReserves &&
             (deviceExtension->ReserveTimer != 0) ) {

            //
            // Countdown to next reservation.
            //

            KeQuerySystemTime( &currentTime );
            deltaTime.QuadPart = ( currentTime.QuadPart - deviceExtension->LastReserveStart.QuadPart ) / 10000;

#if 0
            ClusDiskPrint((
                1,
                "[ClusDisk] Signature %08X, msec since last reserve = %u\n",
                deviceExtension->Signature,
                deltaTime.LowPart ));
#endif

            if ( deltaTime.LowPart >= ((RESERVE_TIMER * 1000) - 500) ) {

#if 0   // we no longer rely strictly on the timer.
            if ( --deviceExtension->ReserveTimer == 0 )
                //
                // Reset next timeout
                //
                deviceExtension->ReserveTimer = RESERVE_TIMER;
#endif
                if (!arbitrationTickIsCalled) {
                   ArbitrationTick();
                   arbitrationTickIsCalled = TRUE;
                }

                CDLOGF(TICK,"ClusDiskTickHandler: DeltaTime DO %p %!delta!",
                        deviceObject,        // LOGPTR
                        deltaTime.QuadPart ); // LOGULONG

                //
                // Check if worker thread still busy from last timeout.
                //
                if ( !deviceExtension->TimerBusy ) {

                    //
                    // Acquire the RemoveLock here and free it when the reserve code completes.
                    //

                    status = AcquireRemoveLock(&deviceExtension->RemoveLock, ClusDiskReservationWorker);
                    if ( !NT_SUCCESS(status) ) {

                        //
                        // Failed to get the RemoveLock for this device, go on to the next one.
                        //
                        deviceObject = deviceObject->NextDevice;
                        continue;
                    }

                    if ( deviceExtension->ReserveCount > 1 ) {
                        ClusDiskPrint(( 1,
                                        "[ClusDisk] DO %p  Signature %08X ReserveCount = %u \n",
                                        deviceObject,
                                        deviceExtension->Signature,
                                        deviceExtension->ReserveCount ));
                    }

                    //
                    // Reset time since last reserve.
                    //
                    deviceExtension->LastReserveStart.QuadPart = currentTime.QuadPart;
                    deviceExtension->TimerBusy = TRUE;

                    ClusDiskPrint(( 4,
                                    "[ClusDisk] DO %p  Signature %08X, QueueWorkItem \n",
                                    deviceObject,
                                    deviceExtension->Signature ));


                    CDLOGF(TICK,"ClusDiskTickHandler: QueueWorkItem DO %p",
                            deviceObject );

                    ExQueueWorkItem(&deviceExtension->WorkItem,
                                    CriticalWorkQueue );
                } else {

                    CDLOGF(TICK,"ClusDiskTickHandler: TimerBusy set, skip QueueWorkItem DO %p  DiskNo %u ",
                            deviceObject,
                            deviceExtension->DiskNumber );
                }

            }
        }

        //
        // Walk all device objects.
        //
        deviceObject = deviceObject->NextDevice;
    }

    KeReleaseSpinLock(&ClusDiskSpinLock, irql);

} // ClusDiskTickHandler



VOID
ClusDiskReservationWorker(
    IN PCLUS_DEVICE_EXTENSION  DeviceExtension
    )

/*++

Routine Description:

    Reservation timeout worker routine. This worker queue routine
    attempts a reservation on a cluster device.

    The RemoveLock for this device (the one owning the device extension)
    must be acquired before this routine runs.

Arguments:

    DeviceExtension - The device extension for the device to reserve.

Return Value:

    None

Notes:

    The reservations must be handled here, because we can't handle them
    at DPC level.

--*/

{
    NTSTATUS            status;
    KIRQL               irql;
    PLIST_ENTRY         listEntry;
    PIRP                irp;
    LARGE_INTEGER       currentTime;
    LARGE_INTEGER       timeDelta;
    LARGE_INTEGER       startReserveTime;

    CDLOGF(TICK,"ClusDiskReservationWorker: Entry DO %p", DeviceExtension->DeviceObject );

    //
    // If ReserveTimer is cleared, we should not do reservation on the device.
    //

    if ( RootDeviceObject == NULL || DeviceExtension->ReserveTimer == 0 ) {

        goto FnExit;
    }

#if 0   // Very noisy...
        // Use only for really intense debugging....

    ClusDiskPrint(( 3,
                    "[ClusDisk] Reserving: Sig %08X  DevObj %p  \n",
                    DeviceExtension->Signature,
                    DeviceExtension->DeviceObject ));
#endif

    //
    // The reserve and arbitration write are asynchronous now - don't wait for them
    // to complete.
    //

    status = ReserveScsiDevice( DeviceExtension, NULL );

    if ( !NT_SUCCESS(status) ) {

        KeQuerySystemTime( &currentTime );
        ClusDiskPrint((
                    1,
                    "[ClusDisk] We lost our reservation for Signature %08X\n",
                    DeviceExtension->Signature));
        timeDelta.QuadPart = ( currentTime.QuadPart - DeviceExtension->LastReserveEnd.QuadPart ) / 10000;

        CDLOGF(RESERVE,"ClusDiskReservationWorker: LostReserve DO %p delta %!u! ms status %!status!",
                DeviceExtension->DeviceObject,
                timeDelta.LowPart,
                status);

        ClusDiskPrint((
                    1,
                    "[ClusDisk] Milliseconds since last reserve = %u, on Signature %08X\n",
                    timeDelta.LowPart,
                    DeviceExtension->Signature ));

        OFFLINE_DISK( DeviceExtension );

        IoAcquireCancelSpinLock( &irql );
        KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);
        DeviceExtension->ReserveTimer = 0;
        DeviceExtension->ReserveFailure = status;

        //
        // Signal all waiting Irp's
        //
        while ( !IsListEmpty(&DeviceExtension->WaitingIoctls) ) {
            listEntry = RemoveHeadList(&DeviceExtension->WaitingIoctls);
            irp = CONTAINING_RECORD( listEntry,
                                     IRP,
                                     Tail.Overlay.ListEntry );
            //irp->IoStatus.Status = status;
            //IoCompleteRequest(irp, IO_NO_INCREMENT);
            ClusDiskCompletePendingRequest(irp, status, DeviceExtension);
        }

        KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
        IoReleaseCancelSpinLock( irql );
    } else {
        //
        // Arbitration write is now done after successful reservation.  The reserve won't be
        // stalled by a write (and a request sense).
        //

        ArbitrationWrite( DeviceExtension );
    }

FnExit:

    //
    // Make sure TimerBusy is cleared.  Otherwise, we will never send periodic
    // reserves again!
    //

    DeviceExtension->TimerBusy = FALSE;

    ReleaseRemoveLock(&DeviceExtension->RemoveLock, ClusDiskReservationWorker);

    CDLOGF(TICK,"ClusDiskReservationWorker: Exit DO %p", DeviceExtension->DeviceObject );

    return;

} // ClusDiskReservationWorker



NTSTATUS
ClusDiskRescanWorker(
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    Context - input context - not used.

Return Value:

    None

--*/

{
    if ( !RootDeviceObject ) {
        return(STATUS_SUCCESS);
    }
    ClusDiskRescanBusy = FALSE;
    ClusDiskScsiInitialize(RootDeviceObject->DriverObject, ClusDiskNextDisk, 1);

    return(STATUS_SUCCESS);

} // ClusDiskRescanWorker


NTSTATUS
OfflineVolume(
    IN ULONG DiskNumber,
    IN ULONG PartitionNumber,
    IN BOOLEAN ForceOffline
    )
/*++

Routine Description:

    Send offline IOCTL to the volume indicated by the disk number and
    partition number.

    If ForceOffline = TRUE
      Send offline IOCTL without checking whether snapshot will be deleted.

    If ForceOffline = FALSE
      Check whether snapshot will be deleted when offline is sent.  If
      snapshot will be deleted, do not send the offline IOCTL.

    Note that if there is no snapshot on the volume, IOCTL_VOLSNAP_QUERY_OFFLINE
    will fail.  The routine needs to be called again with ForceOffline
    set to TRUE to send the volume offline.

Arguments:

    DiskNumber - disk number for the volume to be offlined.

    PartitionNumber - partition number for the volume to be offlined.

    ForceOffline - controls whether snapshot deletion check will be made.
                   TRUE - don't check for snapshot deletion.

Return Value:

    STATUS_SUCCESS - one or more volumes offlined.

--*/
{
    PDEVICE_OBJECT      deviceObject;
    PFILE_OBJECT        fileObject;
    PIRP                irp;

    NTSTATUS            status = STATUS_UNSUCCESSFUL;

    KEVENT              event;
    IO_STATUS_BLOCK     ioStatus;

    UNICODE_STRING      ntUnicodeString;

    PWCHAR              ntDeviceName = NULL;

    if ( PASSIVE_LEVEL != KeGetCurrentIrql() ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] OfflineVolume: Running at invalid IRQL \n" ));
        CDLOG( "OfflineVolume: Running at invalid IRQL \n" );
        ASSERT(FALSE);
        goto FnExit;
    }

    //
    // Get the device object represented by the disk and partition numbers.
    //

    ntDeviceName = ExAllocatePool( NonPagedPool, MAX_PARTITION_NAME_LENGTH * sizeof(WCHAR) );

    if ( !ntDeviceName ) {
        CDLOG( "OfflineVolume: Failed to allocate device name buffer \n" );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    if ( FAILED( StringCchPrintfW( ntDeviceName,
                                   MAX_PARTITION_NAME_LENGTH,
                                   DEVICE_PARTITION_NAME,
                                   DiskNumber,
                                   PartitionNumber ) ) ) {
        CDLOG( "OfflineVolume: Failed to create device name for disk %u partition %u \n",
               DiskNumber,
               PartitionNumber );
        goto FnExit;
    }

    RtlInitUnicodeString( &ntUnicodeString, ntDeviceName );

    status = IoGetDeviceObjectPointer( &ntUnicodeString,
                                       FILE_READ_ATTRIBUTES,
                                       &fileObject,
                                       &deviceObject );
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] OfflineVolume: Get devobj pointer failed for %ws, status %08X \n",
                        ntDeviceName,
                        status ));
        CDLOG( "OfflineVolume: Get devobj pointer failed for %ws, status %08X \n",
               ntDeviceName,
               status );

        goto FnExit;
    }

    deviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );

    //
    // If caller did not specify to force the offline request, we have to
    // check whether the offline will cause a snapshot deletion.
    //
    // If IOCTL_VOLSNAP_QUERY_OFFLINE succeeds, we can safely offline the
    // volume.
    //
    // If IOCTL_VOLSNAP_QUERY_OFFLINE fails, then one of these conditions
    // exists:
    //   - a snapshot will be deleted when the offline occurs
    //   - the IOCTL is not supported by third party driver
    //   - some unexpected error occured
    //
    // In the failure case, if ForceOffline = FALSE, we don't offline the
    // volume now because this routine can be called again with ForceVolume = TRUE
    // to make the offline work without the snapshot query.
    //

    if ( !ForceOffline ) {

        KeInitializeEvent( &event, NotificationEvent, FALSE );

        //
        // If this IOCTL succeeds, then we can safely offline this volume.
        //

        irp = IoBuildDeviceIoControlRequest( IOCTL_VOLSNAP_QUERY_OFFLINE,
                                             deviceObject,
                                             NULL,
                                             0,
                                             NULL,
                                             0,
                                             FALSE,
                                             &event,
                                             &ioStatus );

        if ( !irp ) {
            ObDereferenceObject( deviceObject );
            ObDereferenceObject( fileObject );

            ClusDiskPrint(( 1,
                            "[ClusDisk] OfflineVolume: Build QueryOffline IRP failed for disk %u partition %u, status %08X \n",
                            DiskNumber,
                            PartitionNumber,
                            status ));
            CDLOG( "OfflineVolume: Build QueryOffline IRP failed for disk %u partition %u, status %08X \n",
                    DiskNumber,
                    PartitionNumber,
                   status );
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto FnExit;
        }

        status = IoCallDriver( deviceObject, irp );

        if ( STATUS_PENDING == status ) {
            KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
            status = ioStatus.Status;
        }

        if ( !NT_SUCCESS(status) ) {

            ObDereferenceObject( deviceObject );
            ObDereferenceObject( fileObject );

            ClusDiskPrint(( 1,
                            "[ClusDisk] OfflineVolume: QueryOffline IRP failed for disk %u partition %u, status %08X - skip offline \n",
                            DiskNumber,
                            PartitionNumber,
                            status ));
            CDLOG( "OfflineVolume: QueryOffline IRP failed for disk %u partition %u, status %08X - skip offline \n",
                   DiskNumber,
                   PartitionNumber,
                   status );
            goto FnExit;
        }

        //
        // Fall through if the IOCTL worked.  This means it is safe to offline this
        // volume without snapshot deletion.
        //
    }

    status = SendFtdiskIoctlSync( deviceObject,
                                  DiskNumber,
                                  PartitionNumber,
                                  IOCTL_VOLUME_OFFLINE );

    ObDereferenceObject( deviceObject );
    ObDereferenceObject( fileObject );

FnExit:

    if ( ntDeviceName ) {
        ExFreePool( ntDeviceName );
    }

    return status;

}   // OfflineVolume


NTSTATUS
OfflineVolumeList(
    IN POFFLINE_ENTRY OfflineList
    )
/*++

Routine Description:

    Send volume IOCTL to all volumes in the list.  Try to preserve snapshots
    by first checking whether offline would cause a snapshot deletion.  If
    volume can be offlined without snapshot deletion, then do it.  If offline
    will cause snapshot deletion, skip this volume and try others in the list.

    Multiple passes through the offline list will be made.  When a pass through
    the list occurs and no volumes are offlined, we stop processing the list.
    At that point, we make one more pass through the list and force a volume
    offline to any volume not yet offline.

Arguments:

    OfflineList - Linked list representing all volumes to be offlined.

Return Value:

    STATUS_SUCCESS - one or more volumes offlined.

--*/
{
    POFFLINE_ENTRY entry;

    ULONG       volumeOfflineCount;
    ULONG       totalOfflined = 0;

    NTSTATUS    status = STATUS_UNSUCCESSFUL;

    if ( !OfflineList ) {
        status = STATUS_SUCCESS;
        goto FnExit;
    }

    ClusDiskPrint(( 3,
                    "[ClusDisk] OfflineVolumeList: First pass through offline list started \n" ));
    CDLOG( "OfflineVolumeList: First pass through offline list started \n" );

    entry = OfflineList;

    //
    // Keep walking through the offline list and checking
    // whether we can offline a volume without causing snapshot
    // deletion.  If we walk through the entire list without
    // offlining at least one volume, we are finished.
    //

    while ( TRUE ) {

        entry = OfflineList;
        volumeOfflineCount = 0;

        while ( entry ) {

            if ( !entry->OfflineSent ) {

                status = OfflineVolume( entry->DiskNumber,
                                        entry->PartitionNumber,
                                        FALSE );                    // Offline only if safe

                if ( NT_SUCCESS(status) ) {
                    entry->OfflineSent = TRUE;
                    volumeOfflineCount++;
                }
            }

            entry = entry->Next;
        }

        totalOfflined += volumeOfflineCount;

        //
        // If we didn't offline any volumes, then we need to stop
        // processing.
        //

        if ( 0 == volumeOfflineCount ) {
            ClusDiskPrint(( 3,
                            "[ClusDisk] OfflineVolumeList: First pass through offline list completed \n" ));
            CDLOG( "OfflineVolumeList: First pass through offline list completed \n" );
            break;
        }
    }

    //
    // Walk through the list one more time and force offline anything not yet
    // offlined.
    //

    ClusDiskPrint(( 3,
                    "[ClusDisk] OfflineVolumeList: Second pass through offline list started \n" ));
    CDLOG( "OfflineVolumeList: Second pass through offline list started \n" );

    entry = OfflineList;

    while ( entry ) {

        if ( !entry->OfflineSent ) {

            status = OfflineVolume( entry->DiskNumber,
                                    entry->PartitionNumber,
                                    TRUE );                     // Force offline

            if ( NT_SUCCESS(status) ) {
                entry->OfflineSent = TRUE;
                totalOfflined++;
            }
        }

        entry = entry->Next;
    }

    ClusDiskPrint(( 3,
                    "[ClusDisk] OfflineVolumeList: Second pass through offline list completed, %u volumes offlined \n",
                    totalOfflined ));
    CDLOG( "OfflineVolumeList: Second pass through offline list completed, %u volumes offlined \n",
           totalOfflined );

    if ( totalOfflined ) {
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_UNSUCCESSFUL;
    }

FnExit:

    return status;

}   // OfflineVolumeList


NTSTATUS
AddVolumesToOfflineList(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN OUT POFFLINE_ENTRY *OfflineList
    )
/*++

Routine Description:

    Add all volumes for the specified physical disk to the offline
    list.  Updates the OfflineList with all volumes for this disk.

    Caller is responsible to free this storage.

Arguments:

    DeviceExtension - Device extension for a physical disk (partition 0).

    OfflineList - Linked list representing all volumes to be offlined.
                  This list is for the current disk as well as others.

Return Value:

    STATUS_SUCCESS - one or more volumes added to the master list.

--*/
{
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo = NULL;
    PPARTITION_INFORMATION_EX       partitionInfo;

    POFFLINE_ENTRY                  list = *OfflineList;
    POFFLINE_ENTRY                  nextEntry;

    ULONG               partIndex;

    NTSTATUS            status;

    status = GetDriveLayout( DeviceExtension->PhysicalDevice,
                             &driveLayoutInfo,
                             FALSE,
                             FALSE );

    if ( !NT_SUCCESS(status) || !driveLayoutInfo ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] AddVolumesToOfflineList: Failed to read partition info, status %08X \n",
                        status ));
        CDLOG( "AddVolumesToOfflineList: Failed to read partition info, status %08X \n",
               status );

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    for ( partIndex = 0;
          partIndex < driveLayoutInfo->PartitionCount;
          partIndex++ ) {

        partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

        //
        // First make sure this is a valid partition.
        //

        if ( 0 == partitionInfo->PartitionNumber ) {
            continue;
        }

        //
        // Allocate offline list entry, fill it in, and link it to the master
        // list.
        //

        nextEntry = ExAllocatePool( NonPagedPool, sizeof(OFFLINE_ENTRY) );

        if ( !nextEntry ) {
            continue;
        }

        ClusDiskPrint(( 1,
                        "[ClusDisk] AddVolumesToOfflineList: Add disk %u partition %u to offline list \n",
                        DeviceExtension->DiskNumber,
                        partitionInfo->PartitionNumber ));
        CDLOG( "AddVolumesToOfflineList: Add disk %u partition %u to offline list \n",
               DeviceExtension->DiskNumber,
               partitionInfo->PartitionNumber );

        nextEntry->DiskNumber = DeviceExtension->DiskNumber;
        nextEntry->PartitionNumber = partitionInfo->PartitionNumber;
        nextEntry->OfflineSent = FALSE;
        nextEntry->Next = NULL;

        if ( list ) {
            nextEntry->Next = list;
        }

        list = nextEntry;
    }

    //
    // Update the caller's master list.
    //

    *OfflineList = list;

    status = STATUS_SUCCESS;

FnExit:

    if ( driveLayoutInfo ) {
        ExFreePool( driveLayoutInfo );
    }

    return status;

}   // AddVolumesToOfflineList



NTSTATUS
ClusDiskHaltProcessingWorker(
    IN PVOID Context
    )

/*++

Routine Description:

    This worker thread processes halt notifications from the Cluster Network
    driver.

Arguments:

    Context - input context - not used.

Return Value:

    NTSTATUS for this request.

Notes:

    Halt processing must be done via a worker thread because it cannot
    be done at DPC since the disks are dismounted.

--*/

{
    PDEVICE_OBJECT              deviceObject;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    POFFLINE_ENTRY              offlineList = NULL;
    POFFLINE_ENTRY              nextEntry;

    NTSTATUS                    status;

    CDLOG("HaltProcessingWorker: Entry(%p)", Context );

    if ( RootDeviceObject == NULL ) {
        HaltBusy = FALSE;
        HaltOfflineBusy = FALSE;
        return(STATUS_DEVICE_OFF_LINE);
    }

    ACQUIRE_SHARED( &ClusDiskDeviceListLock );

    //
    // First, capture file handles for all P0 devices
    //
    deviceObject = RootDeviceObject->DriverObject->DeviceObject;
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;

        // Keep the online check.  OpenFile should now work with FILE_WRITE_ATTRIBUTES.

        if ( !deviceExtension->Detached &&
              deviceExtension->PhysicalDevice == deviceObject &&
              deviceExtension->DiskState == DiskOnline )
        {
            //
            // Disk has to be online,
            // If it is offline, OpenFile will fail - not if FILE_WRITE_ATTRIBUTES used...
            // It it is stalled OpenFile may stall
            //
            ProcessDelayedWorkSynchronous( deviceObject, ClusDiskpOpenFileHandles, NULL );

            //
            // Allocate storage to keep info for this disk.  If allocated, link
            // it to the offline list and offline all disks correctly to preserve
            // snapshots.  If we can't allocate the storage, then send offline
            // directly to the volume PDO to block I/O.
            //

            status = AddVolumesToOfflineList( deviceExtension, &offlineList );

            if ( !NT_SUCCESS(status) ) {

                //
                // We couldn't add this entry to the list, so send an offline IOCTL to
                // the volume PDO, not all devices in the stack.
                //

                OFFLINE_DISK_PDO( deviceExtension );
            }
        }

        deviceObject = deviceObject->NextDevice;
    }

    //
    // Offline the list, preserving snapshots if possible.
    //

    OfflineVolumeList( offlineList );

    while ( offlineList ) {
        ASSERT( offlineList->OfflineSent );
        nextEntry = offlineList->Next;
        ExFreePool( offlineList );
        offlineList = nextEntry;
    }

    //
    // Clear the flag to indicate that normal offlines can occur now.
    //

    HaltOfflineBusy = FALSE;

    deviceObject = RootDeviceObject->DriverObject->DeviceObject;

    //
    // Then, release all pended irps on all devices
    // (Otherwise FSCTL_DISMOUNT will stall and cause a deadlock)
    //
    deviceObject = RootDeviceObject->DriverObject->DeviceObject;
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        if ( !deviceExtension->Detached )
        {
            ClusDiskCompletePendedIrps(
                deviceExtension,
                /* FileObject => */ NULL, // Will complete all irps           //
                /* Offline =>    */ TRUE);// will set device state to offline //
        }

        deviceObject = deviceObject->NextDevice;
    }

    //
    // For each ClusDisk device, if we have a persistent reservation, then
    // stop it.
    //
    deviceObject = RootDeviceObject->DriverObject->DeviceObject;
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        if ( !deviceExtension->Detached &&
              deviceExtension->PhysicalDevice == deviceObject)
        {
#if 0
            status = AcquireRemoveLock( &deviceExtension->RemoveLock, deviceExtension );
            if ( !NT_SUCCESS(status) ) {

                // If we can't get the RemoveLock, skip this device.
                deviceObject = deviceObject->NextDevice;
                continue;
            }
#endif
            // Keep the device object around
            ObReferenceObject( deviceObject);
            ClusDiskDismountVolumes( deviceObject,
                                     FALSE);            // Don't release the RemoveLock
        }

        deviceObject = deviceObject->NextDevice;
    }
    RELEASE_SHARED( &ClusDiskDeviceListLock );

    HaltBusy = FALSE;
    CDLOG( "HaltProcessingWorker: Exit(%p)", Context );

    return(STATUS_SUCCESS);

} // ClusDiskHaltProcessingWorker


VOID
SendOfflineDirect(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Send IOCTL_VOLUME_OFFLINE to the PDO at the bottom of the volume stack.
    This IOCTL will bypass all drivers on the stack.

    To preserve volume snapshots, we have to send offline IOCTL only to PDO
    at bottom of the volume stack.  This prevents volsnap from inadventantly
    deleting the snapshots in the "emergency offline" case.  During normal
    offline, disk dependency insures snapshoted volumes and the volumes with
    the diff areas are offlined correctly.  In the "emergency offline" case,
    clusnet tells clusdisk that clussvc has terminated, and the disk dependency
    is not maintained as clusdisk does not manage dependnecies.

    This routine must be called at PASSIVE_LEVEL.

Arguments:

    DeviceExtension - Device extension of the physical device.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT      deviceObject;
    PFILE_OBJECT        fileObject;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    PDEVICE_RELATIONS   deviceRelations;

    PDRIVE_LAYOUT_INFORMATION_EX   driveLayoutInfo = NULL;
    PPARTITION_INFORMATION_EX      partitionInfo;

    NTSTATUS            status;
    ULONG               partIndex;

    KEVENT              event;
    IO_STATUS_BLOCK     ioStatus;

    UNICODE_STRING      ntUnicodeString;

    PWCHAR              ntDeviceName = NULL;

    if ( PASSIVE_LEVEL != KeGetCurrentIrql() ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] SendOfflineDirect: Running at invalid IRQL \n" ));
        CDLOG( "SendOfflineDirect: Running at invalid IRQL \n" );
        ASSERT(FALSE);
        goto FnExit;
    }

    status = GetDriveLayout( DeviceExtension->PhysicalDevice,
                             &driveLayoutInfo,
                             FALSE,
                             FALSE );

    if ( !NT_SUCCESS(status) || !driveLayoutInfo ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] SendOfflineDirect: Failed to read partition info, status %08X \n",
                        status ));
        CDLOG( "SendOfflineDirect: Failed to read partition info, status %08X \n",
               status );

        goto FnExit;
    }

    ntDeviceName = ExAllocatePool( NonPagedPool, MAX_PARTITION_NAME_LENGTH * sizeof(WCHAR) );

    if ( !ntDeviceName ) {
        CDLOG( "SendOfflineDirect: Failed to allocate device name buffer \n" );
        goto FnExit;
    }

    //
    // For each volume on the disk, send offline IOCTL to the bottom of the volume
    // driver stack.
    //

    for ( partIndex = 0;
          partIndex < driveLayoutInfo->PartitionCount;
          partIndex++ ) {

        partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

        //
        // First make sure this is a valid partition.
        //
        if ( 0 == partitionInfo->PartitionNumber ) {
            continue;
        }

        if ( FAILED( StringCchPrintfW( ntDeviceName,
                                       MAX_PARTITION_NAME_LENGTH,
                                       DEVICE_PARTITION_NAME,
                                       DeviceExtension->DiskNumber,
                                       partitionInfo->PartitionNumber ) ) ) {
            CDLOG( "SendOfflineDirect: Failed to create device name for disk %u partition %u \n",
                   DeviceExtension->DiskNumber,
                   partitionInfo->PartitionNumber );
            continue;
        }

        RtlInitUnicodeString( &ntUnicodeString, ntDeviceName );

        status = IoGetDeviceObjectPointer( &ntUnicodeString,
                                           FILE_READ_ATTRIBUTES,
                                           &fileObject,
                                           &deviceObject );
        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] SendOfflineDirect: Get devobj pointer failed for %ws, status %08X \n",
                            ntDeviceName,
                            status ));
            CDLOG( "SendOfflineDirect: Get devobj pointer failed for %ws, status %08X \n",
                   ntDeviceName,
                   status );

            continue;
        }

        deviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );

        KeInitializeEvent( &event, NotificationEvent, FALSE );

        irp = IoBuildDeviceIoControlRequest( 0,
                                             deviceObject,
                                             NULL,
                                             0,
                                             NULL,
                                             0,
                                             FALSE,
                                             &event,
                                             &ioStatus );

        if ( !irp ) {
            ObDereferenceObject( deviceObject );
            ObDereferenceObject( fileObject );

            ClusDiskPrint(( 1,
                            "[ClusDisk] SendOfflineDirect: Build PNP IRP failed for %ws, status %08X \n",
                            ntDeviceName,
                            status ));
            CDLOG( "SendOfflineDirect: Build PNP IRP failed for %ws, status %08X \n",
                   ntDeviceName,
                   status );
            continue;
        }

        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        irp->IoStatus.Information = 0;
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->MajorFunction = IRP_MJ_PNP;
        irpSp->MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
        irpSp->Parameters.QueryDeviceRelations.Type = TargetDeviceRelation;
        irpSp->FileObject = fileObject;

        status = IoCallDriver( deviceObject, irp );

        if ( STATUS_PENDING == status ) {
            KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
            status = ioStatus.Status;
        }

        ObDereferenceObject(deviceObject);
        ObDereferenceObject(fileObject);

        if ( !NT_SUCCESS(status) ) {

            ClusDiskPrint(( 1,
                            "[ClusDisk] SendOfflineDirect: PNP IRP failed for %ws, status %08X \n",
                            ntDeviceName,
                            status ));
            CDLOG( "SendOfflineDirect: PNP IRP failed for %ws, status %08X \n",
                   ntDeviceName,
                   status );
            continue;
        }

        deviceRelations = (PDEVICE_RELATIONS) ioStatus.Information;
        if ( deviceRelations->Count < 1 ) {
            ExFreePool(deviceRelations);

            ClusDiskPrint(( 1,
                            "[ClusDisk] SendOfflineDirect: DeviceRelations->Count for %ws incorrect value %u \n",
                            ntDeviceName,
                            deviceRelations->Count ));
            CDLOG( "SendOfflineDirect: DeviceRelations->Count for %ws incorrect value %u \n",
                   ntDeviceName,
                   deviceRelations->Count );
            continue;
        }

        //
        // The bottom of the volume stack is represented by this PDO.  Send
        // volume offline IOCTL to the bottom of the stack, bypassing volsnap.
        //

        deviceObject = deviceRelations->Objects[0];
        ExFreePool( deviceRelations );

        ClusDiskPrint(( 3,
                        "[ClusDisk] SendOfflineDirect: Device %ws PDO %p \n",
                        ntDeviceName,
                        deviceObject ));
        CDLOG( "SendOfflineDirect: Device %ws PDO %p \n",
               ntDeviceName,
               deviceObject );

        SendFtdiskIoctlSync( deviceObject,
                             DeviceExtension->DiskNumber,
                             partitionInfo->PartitionNumber,
                             IOCTL_VOLUME_OFFLINE );

        ObDereferenceObject( deviceObject );
    }

FnExit:

    if ( driveLayoutInfo ) {
        ExFreePool( driveLayoutInfo );
    }

    if ( ntDeviceName ) {
        ExFreePool( ntDeviceName );
    }

}   // SendOfflineDirect



VOID
ClusDiskCleanupDevice(
    IN HANDLE FileHandle,
    IN BOOLEAN Reset
    )

/*++

Routine Description:

    Cleanup the device by resetting the bus, and forcing a read of the
    disk geometry.

Arguments:

    FileHandle - the file handle to perform the operations.

    Reset - TRUE if we should attempt resets to fix problems. FALSE otherwise.

Return Value:

    None.

--*/

{
    NTSTATUS                status;
    HANDLE                  eventHandle;
    IO_STATUS_BLOCK         ioStatusBlock;
    DISK_GEOMETRY           diskGeometry;
    SCSI_ADDRESS            scsiAddress;
    BOOLEAN                 busReset = FALSE;

    CDLOG( "CleanupDevice: Entry fh %p, reset=%!bool!", FileHandle, Reset );
    ClusDiskPrint(( 3,
                    "[ClusDisk] CleanupDevice: FileHandle %p, Reset %s \n",
                    FileHandle,
                    BoolToString( Reset ) ));

    //
    // Create event for notification.
    //
    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] CleanupDevice: Failed to create event, status %08X\n",
                status ));
        return;
    }

    if ( Reset ) {
        //
        // Start off by getting the SCSI address.
        //
        status = ZwDeviceIoControlFile( FileHandle,
                                        eventHandle,
                                        NULL,
                                        NULL,
                                        &ioStatusBlock,
                                        IOCTL_SCSI_GET_ADDRESS,
                                        NULL,
                                        0,
                                        &scsiAddress,
                                        sizeof(SCSI_ADDRESS) );

        if ( status == STATUS_PENDING ) {
            status = ZwWaitForSingleObject(eventHandle,
                                           FALSE,
                                           NULL);
            ASSERT( NT_SUCCESS(status) );
            status = ioStatusBlock.Status;
        }

        if ( NT_SUCCESS(status) ) {

            CDLOG( "CleanupDevice: BusReset fh %p", FileHandle );

            ClusDiskPrint(( 3,
                            "[ClusDisk] CleanupDevice: Bus Reset \n"
                            ));

            //
            // Now reset the bus!
            //

            ClusDiskLogError( RootDeviceObject->DriverObject,   // Use RootDeviceObject not DevObj
                              RootDeviceObject,
                              scsiAddress.PathId,           // Sequence number
                              IRP_MJ_CLEANUP,               // Major function code
                              0,                            // Retry count
                              ID_CLEANUP,                   // Unique error
                              STATUS_SUCCESS,
                              CLUSDISK_RESET_BUS_REQUESTED,
                              0,
                              NULL );

            status = ResetScsiDevice( NULL, &scsiAddress );

            if ( NT_SUCCESS(status) ) {
                busReset = TRUE;
            }
        }
    }

    //
    // Next try to read the disk geometry.
    //
    status = ZwDeviceIoControlFile( FileHandle,
                                    eventHandle,
                                    NULL,
                                    NULL,
                                    &ioStatusBlock,
                                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                    NULL,
                                    0,
                                    &diskGeometry,
                                    sizeof(DISK_GEOMETRY) );

    if ( status == STATUS_PENDING ) {
        status = ZwWaitForSingleObject(eventHandle,
                                       FALSE,
                                       NULL);
        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    ZwClose( eventHandle );

    //
    // If we had to reset the bus, then wait for a few seconds.
    //
    if ( busReset ) {
        LARGE_INTEGER   waitTime;

        waitTime.QuadPart = (ULONGLONG)(RESET_SLEEP * -(10000*1000));
        KeDelayExecutionThread( KernelMode, FALSE, &waitTime );
    }

    CDLOG( "CleanupDevice: Exit fh %p", FileHandle );

    return;

} // ClusDiskCleanupDevice



VOID
ClusDiskCleanupDeviceObject(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Reset
    )

/*++

Routine Description:

    Cleanup the device object by resetting the bus, and forcing a read of the
    disk geometry.

Arguments:

    DeviceObject - the device to perform the operations.

    Reset - TRUE if we should attempt resets to fix problems. FALSE otherwise.

Return Value:

    None.

--*/

{
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatusBlock;
    DISK_GEOMETRY           diskGeometry;
    SCSI_ADDRESS            scsiAddress;
    BOOLEAN                 busReset = FALSE;
    PKEVENT                 event;
    PIRP                    irp;

    CDLOG( "CleanupDeviceObject: Entry DO %p reset=%!bool!", DeviceObject, Reset );

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( event == NULL ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] CleanupDeviceObject: Failed to allocate event\n" ));
        return;
    }

    if ( Reset ) {
        //
        // Start off by getting the SCSI address.
        //

        //
        // Find out if this is on a SCSI bus. Note, that if this device
        // is not a SCSI device, it is expected that the following
        // IOCTL will fail!
        //
        irp = IoBuildDeviceIoControlRequest(IOCTL_SCSI_GET_ADDRESS,
                                            DeviceObject,
                                            NULL,
                                            0,
                                            &scsiAddress,
                                            sizeof(SCSI_ADDRESS),
                                            FALSE,
                                            event,
                                            &ioStatusBlock);

        if ( !irp ) {
            ExFreePool( event );
            ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to build IRP to read SCSI ADDRESS.\n"
                    ));
            return;
        }

        //
        // Set the event object to the unsignaled state.
        // It will be used to signal request completion.
        //

        KeInitializeEvent(event,
                          NotificationEvent,
                          FALSE);

        status = IoCallDriver(DeviceObject,
                              irp);

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(event,
                                  Suspended,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            status = ioStatusBlock.Status;
        }

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                        1,
                        "[ClusDisk] Failed to read SCSI ADDRESS. %08X\n",
                        status
                        ));
        } else {
            CDLOG( "CleanupDeviceObject: BusReset DO %p", DeviceObject );

            ClusDiskLogError( RootDeviceObject->DriverObject,   // Use RootDeviceObject not DevObj parm
                              RootDeviceObject,
                              scsiAddress.PathId,           // Sequence number
                              0,                            // Major function code
                              0,                            // Retry count
                              ID_CLEANUP_DEV_OBJ,           // Unique error
                              STATUS_SUCCESS,
                              CLUSDISK_RESET_BUS_REQUESTED,
                              0,
                              NULL );

            status = ResetScsiDevice( NULL, &scsiAddress );

            if ( NT_SUCCESS(status) ) {
                busReset = TRUE;
            }
        }
    }

    //
    // Next try to read the disk geometry.
    //
    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        &diskGeometry,
                                        sizeof(DISK_GEOMETRY),
                                        FALSE,
                                        event,
                                        &ioStatusBlock);
    if ( !irp ) {
        ClusDiskPrint((
               1,
                "[ClusDisk] Failed to build IRP to read DISK GEOMETRY.\n"
                ));
    } else {

        //
        // Set the event object to the unsignaled state.
        // It will be used to signal request completion.
        //
        KeInitializeEvent(event,
                          NotificationEvent,
                          FALSE);

        status = IoCallDriver(DeviceObject,
                              irp);

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(event,
                                  Suspended,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            status = ioStatusBlock.Status;
        }

        if ( !NT_SUCCESS(status) ) {
            busReset = FALSE;
            ClusDiskPrint((
                        1,
                        "[ClusDisk] Failed to read DISK GEOMETRY. %08X\n",
                        status
                        ));
        }

        //
        // If we had to reset the bus, then wait for a few seconds.
        //
        if ( busReset ) {
            LARGE_INTEGER   waitTime;

            waitTime.QuadPart = (ULONGLONG)(RESET_SLEEP * -(10000*1000));
            KeDelayExecutionThread( KernelMode, FALSE, &waitTime );
        }
    }

    ExFreePool( event );
    CDLOG( "CleanupDeviceObject: Exit DO %p", DeviceObject );

    return;

} // ClusDiskCleanupDeviceObject



NTSTATUS
ClusDiskGetP0TargetDevice(
    OUT PDEVICE_OBJECT              * DeviceObject OPTIONAL,
    IN PUNICODE_STRING              DeviceName,
    OUT PDRIVE_LAYOUT_INFORMATION_EX    * DriveLayoutInfo OPTIONAL,
    OUT PSCSI_ADDRESS               ScsiAddress OPTIONAL,
    IN BOOLEAN                      Reset
    )

/*++

Routine Description:

    Find the target device object given the disk/partition numbers.
    The device object will have reference count incremented and the
    caller must decrement the count when done with the object.

Arguments:

    DeviceObject - returns the device object if successful.

    DeviceName - the unicode name for the device requested.

    DriveLayoutInfo - returns the partition info if needed.

    ScsiAddress - returns the scsi address info if needed.

    Reset - TRUE if we should attempt resets to fix problems. FALSE otherwise.

Return Value:

    NTSTATUS for this request.

--*/

{
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           objectAttributes;
    HANDLE                      fileHandle;
    PFILE_OBJECT                fileObject;
    IO_STATUS_BLOCK             ioStatusBlock;
    ULONG                       driveLayoutSize;
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo = NULL;
    HANDLE                      eventHandle;
    ULONG                       retry;

    if ( DriveLayoutInfo != NULL ) {
        *DriveLayoutInfo = NULL;
        driveLayoutSize =  sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
            (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION_EX));

        driveLayoutInfo = ExAllocatePool(NonPagedPoolCacheAligned,
                                       driveLayoutSize);

        if ( driveLayoutInfo == NULL ) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    //
    // Setup object attributes for the file to open.
    //
    InitializeObjectAttributes(&objectAttributes,
                               DeviceName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    status = ZwCreateFile(&fileHandle,
                          FILE_READ_ATTRIBUTES,
                          &objectAttributes,
                          &ioStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0 );
    ASSERT( status != STATUS_PENDING );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((1,
                       "[ClusDisk] GetP0TargetDevice, failed to open file %ws. Error %08X.\n",
                       DeviceName->Buffer,
                       status ));

        CDLOG( "ClusDiskGetP0TargetDevice: Open %wZ failed %!status!",
               DeviceName,
               status );

        if ( driveLayoutInfo ) {
            ExFreePool( driveLayoutInfo );
        }
        return(status);
    }

    //
    // get device object if requested
    //
    if ( DeviceObject ) {

        status = ObReferenceObjectByHandle(fileHandle,
                                           0,
                                           NULL,
                                           KernelMode,
                                           (PVOID *) &fileObject,
                                           NULL );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1,
                           "[ClusDisk] GetP0TargetDevice Failed to reference object for file <%ws>. Error %08X.\n",
                           DeviceName->Buffer,
                           status ));

            CDLOG( "ClusDiskGetP0TargetDevice: ObRef(%wZ) failed %!status!",
                   DeviceName,
                   status );

            ZwClose( fileHandle );
            if ( driveLayoutInfo ) {
                ExFreePool( driveLayoutInfo );
            }
            return(status);
        }

        //
        // Get the address of the target device object.  If this file represents
        // a device that was opened directly, then simply use the device or its
        // attached device(s) directly.  Also get the address of the Fast Io
        // dispatch structure.
        //
        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            *DeviceObject = IoGetRelatedDeviceObject( fileObject );
            // Add a reference to the object so we can dereference it later.
            ObReferenceObject( *DeviceObject );
        } else {
            *DeviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );
        }

        //
        // If we get a file system device object... go back and get the
        // device object.
        //
        if ( (*DeviceObject)->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM ) {
            ObDereferenceObject( *DeviceObject );
            *DeviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );
        }
        ASSERT( (*DeviceObject)->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM );

        ObDereferenceObject( fileObject );
    }

    //
    // If we need to return scsi address information, do that now.
    //
    retry = 2;
    while ( ScsiAddress &&
            retry-- ) {
        //
        // Create event for notification.
        //
        status = ZwCreateEvent( &eventHandle,
                                EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1,
                           "[ClusDisk] GetP0TargetDevice: Failed to create event, status %lx\n",
                           status ));
        } else {
            // Should this routine be called GetScsiTargetDevice?
            status = ZwDeviceIoControlFile( fileHandle,
                                            eventHandle,
                                            NULL,
                                            NULL,
                                            &ioStatusBlock,
                                            IOCTL_SCSI_GET_ADDRESS,
                                            NULL,
                                            0,
                                            ScsiAddress,
                                            sizeof(SCSI_ADDRESS) );

            if ( status == STATUS_PENDING ) {
                status = ZwWaitForSingleObject(eventHandle,
                                               FALSE,
                                               NULL);
                ASSERT( NT_SUCCESS(status) );
                status = ioStatusBlock.Status;
            }

            ZwClose( eventHandle );
            if ( NT_SUCCESS(status) ) {
                break;
            } else {
                ClusDiskPrint((3,
                               "[ClusDisk] GetP0TargetDevice failed to read scsi address info for <%ws>, error %lx.\n",
                               DeviceName->Buffer,
                               status ));
                CDLOG( "ClusDiskGetP0TargetDevice: GetScsiAddr(%wZ), failed %!status!",
                       DeviceName,
                       status );

                ClusDiskCleanupDevice( fileHandle, Reset );
            }
        }
    }
    //
    // If we need to return partition information, do that now.
    //
    status = STATUS_SUCCESS;
    retry = 2;
    while ( driveLayoutInfo &&
            retry-- ) {
        //
        // Create event for notification.
        //
        status = ZwCreateEvent( &eventHandle,
                                EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                           1,
                           "[ClusDisk] GetP0TargetDevice: Failed to create event, status %08X\n",
                           status ));
        } else {
            //
            // Force storage drivers to flush cached drive layout.  Get the
            // drive layout even if the flush fails.
            //

            status = ZwDeviceIoControlFile( fileHandle,
                                            eventHandle,
                                            NULL,
                                            NULL,
                                            &ioStatusBlock,
                                            IOCTL_DISK_UPDATE_PROPERTIES,
                                            NULL,
                                            0,
                                            NULL,
                                            0 );
            if ( status == STATUS_PENDING ) {
                status = ZwWaitForSingleObject(eventHandle,
                                               FALSE,
                                               NULL);
                ASSERT( NT_SUCCESS(status) );
                status = ioStatusBlock.Status;
            }

            status = ZwDeviceIoControlFile( fileHandle,
                                            eventHandle,
                                            NULL,
                                            NULL,
                                            &ioStatusBlock,
                                            IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                            NULL,
                                            0,
                                            driveLayoutInfo,
                                            driveLayoutSize );

            if ( status == STATUS_PENDING ) {
                status = ZwWaitForSingleObject(eventHandle,
                                               FALSE,
                                               NULL);
                ASSERT( NT_SUCCESS(status) );
                status = ioStatusBlock.Status;
            }

            ZwClose( eventHandle );
            if ( NT_SUCCESS(status) ) {
                *DriveLayoutInfo = driveLayoutInfo;
                break;
            } else {
                ClusDiskPrint((( status == STATUS_DEVICE_BUSY ? 3 : 1 ),
                               "[ClusDisk] GetP0TargetDevice failed to read partition info for <%ws>, error %lx.\n",
                               DeviceName->Buffer,
                               status ));
                CDLOG( "ClusDiskGetP0TargetDevice: GetDriveLayout(%wZ) failed %!status!",
                       DeviceName,
                       status);

                ClusDiskCleanupDevice( fileHandle, Reset );
            }
        }
    }

    if ( !NT_SUCCESS(status) ) {
        ZwClose( fileHandle );
        if ( driveLayoutInfo ) {
            ExFreePool( driveLayoutInfo );
        }
        return(status);
    }

    ZwClose( fileHandle );

    return(status);

} // ClusDiskGetP0TargetDevice



NTSTATUS
ClusDiskGetTargetDevice(
    IN ULONG                        DiskNumber,
    IN ULONG                        PartitionNumber,
    OUT PDEVICE_OBJECT              * DeviceObject OPTIONAL,
    OUT PUNICODE_STRING             DeviceName,
    OUT PDRIVE_LAYOUT_INFORMATION_EX    * DriveLayoutInfo OPTIONAL,
    OUT PSCSI_ADDRESS               ScsiAddress OPTIONAL,
    IN BOOLEAN                      Reset
    )

/*++

Routine Description:

    Find the target device object given the disk/partition numbers.

Arguments:

    DiskNumber - the disk number for the requested device.

    PartitionNumber - the partition number for the requested device.

    DeviceObject - returns a pointer to the device object if needed.

    DeviceName - returns the unicode string for the device if successful.

    DriveLayoutInfo - returns the partition info if needed.

    ScsiAddress - returns the scsi address info if needed.

    Reset - TRUE if we should attempt resets to fix problems. FALSE otherwise.

Return Value:

    NTSTATUS for this request.

--*/

{
    NTSTATUS                    status;
    NTSTATUS                    retStatus = STATUS_SUCCESS;
    PWCHAR                      deviceNameBuffer;
    PDEVICE_OBJECT              deviceObject;
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo = NULL;
    ULONG                       retry;

    const ULONG                 deviceNameBufferChars = MAX_PARTITION_NAME_LENGTH;

    DeviceName->Buffer = NULL;

    //
    // allocate enough space for a harddiskX partitionY string
    //
    deviceNameBuffer = ExAllocatePool(NonPagedPool,
                                      deviceNameBufferChars * sizeof(WCHAR));

    if ( deviceNameBuffer == NULL ) {
        DeviceName->Buffer = NULL;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Create device name for the physical disk.
    //

    if ( FAILED( StringCchPrintfW( deviceNameBuffer,
                                   deviceNameBufferChars - 1,
                                   DEVICE_PARTITION_NAME,
                                   DiskNumber,
                                   PartitionNumber ) ) ) {

        FREE_AND_NULL_PTR( deviceNameBuffer );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    WCSLEN_ASSERT( deviceNameBuffer );

    RtlInitUnicodeString( DeviceName, deviceNameBuffer );

    if ( !PartitionNumber ) {
        status = ClusDiskGetP0TargetDevice(
                        DeviceObject,
                        DeviceName,
                        DriveLayoutInfo,
                        ScsiAddress,
                        Reset );
        if ( NT_SUCCESS(status) ) {
            return(status);
        }

        ClusDiskPrint((
                1,
                "[ClusDisk] GetTargetDevice: try for just the device object.\n"
                ));
        retStatus = status;
    }

    //
    // Get the device object.
    //
    deviceObject = NULL;
    status = ClusDiskGetDeviceObject( deviceNameBuffer,
                                      &deviceObject );
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] GetDeviceObject failed for %ws, status %08LX\n",
                deviceNameBuffer,
                status ));
        DeviceName->Buffer = NULL;
        ExFreePool( deviceNameBuffer );
        return(status);
    }

    if ( DeviceObject ) {
        *DeviceObject = deviceObject;
    }

    ClusDiskPrint((
            3,
            "[ClusDisk] GetTargetDevice, Found Device Object = %p \n",
            deviceObject
            ));

    //
    // If we failed to get the P0 information, then return now with just
    // the DeviceObject;
    //
    if ( !NT_SUCCESS(retStatus) ) {
        ClusDiskPrint(( 3,
                        "[ClusDisk] GetTargetDevice, returning status %08LX (before ScsiAddress and DriveLayout) \n",
                        retStatus
                        ));
        return(retStatus);
    }

    //
    // Try twice to get the SCSI ADDRESS or Drive Layout if requested.
    //
    retry = 2;
    while ( (ScsiAddress || DriveLayoutInfo) &&
            retry-- ) {
        status = STATUS_SUCCESS;
        if ( ScsiAddress ) {
            status = GetScsiAddress(  deviceObject,
                                      ScsiAddress );
        }

        if ( NT_SUCCESS(status) &&
            DriveLayoutInfo &&
            !driveLayoutInfo ) {
            ClusDiskPrint(( 3,
                            "[ClusDisk] GetTargetDevice, GetScsiAddress was successful \n"
                            ));
            status = GetDriveLayout( deviceObject,
                                     &driveLayoutInfo,                          // If part0, this will be physical disk
                                     FALSE,                                     // Don't update cached drive layout
                                     0 == PartitionNumber ? TRUE : FALSE );     // If part0, flush storage cached drive layout
            if ( NT_SUCCESS(status) ) {
                ClusDiskPrint(( 3,
                                "[ClusDisk] GetTargetDevice, GetDriveLayout was successful \n"
                                ));
            }
        }

        //
        // If we have what we need, then break out now.
        //
        if ( NT_SUCCESS(status) ) {
            break;
        }

        ClusDiskCleanupDeviceObject( deviceObject, Reset );
    }

    if ( !NT_SUCCESS(status) ) {
        ExFreePool( deviceNameBuffer );
        DeviceName->Buffer = NULL;
        if ( driveLayoutInfo ) {
            ExFreePool( driveLayoutInfo );
        }
    } else {
        if ( DriveLayoutInfo ) {
            *DriveLayoutInfo = driveLayoutInfo;
        }
    }

    ClusDiskPrint(( 3,
                    "[ClusDisk] GetTargetDevice, returning status %08LX \n",
                    status
                    ));

    return(status);

} // ClusDiskGetTargetDevice



NTSTATUS
ClusDiskInitRegistryString(
    OUT PUNICODE_STRING UnicodeString,
    IN  LPWSTR          KeyName,
    IN  ULONG           KeyNameChars
    )

/*++

Routine Description:

    Initialize a Unicode registry key string.

Arguments:

    UnicodeString - pointer to the registry string to initialize.

    KeyName - the key name.

    KeyNameChars - the key name WCHAR count.

Return Value:

    NTSTATUS for this request.

Notes:

    The UnicodeString buffer is allocated from paged pool.

--*/

{
    ULONG keyNameSize = KeyNameChars * sizeof(WCHAR);

    //
    // Allocate buffer for signatures registry keys.
    //
    UnicodeString->Length = 0;
    UnicodeString->MaximumLength = (USHORT)(ClusDiskRegistryPath.MaximumLength +
                                            keyNameSize +
                                            sizeof(CLUSDISK_SIGNATURE_FIELD) +
                                            sizeof(UNICODE_NULL));

    UnicodeString->Buffer = ExAllocatePool(
                                            PagedPool,
                                            UnicodeString->MaximumLength
                                            );

    if ( !UnicodeString->Buffer ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] InitRegistryString, failed to allocate a KeyName buffer\n"
                ));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Zero the key name buffer.
    //
    RtlZeroMemory(
                  UnicodeString->Buffer,
                  UnicodeString->MaximumLength
                 );

    //
    // Initialize the string to the registry name for clusdisk.
    //
    RtlAppendUnicodeToString(
            UnicodeString,
            ClusDiskRegistryPath.Buffer
            );

    //
    // Append the keyname.
    //
    RtlAppendUnicodeToString(
            UnicodeString,
            KeyName
            );

    UnicodeString->Buffer[ UnicodeString->Length / sizeof(WCHAR) ] = UNICODE_NULL;

    return(STATUS_SUCCESS);

} // ClusDiskInitRegistryString



ULONG
ClusDiskIsSignatureDisk(
    IN ULONG Signature
    )

/*++

Routine Description:

    Determine if the specified signature is in the signature list.

Arguments:

    Signature - the signature for the disk of interest.

Return Value:

    NTSTATUS for this request.

--*/

{
    WCHAR                       buffer[128];
    HANDLE                      regHandle;
    OBJECT_ATTRIBUTES           objectAttributes;
    NTSTATUS                    status;
    UNICODE_STRING              regString;

    if ( FAILED( StringCchPrintfW( buffer,
                                   RTL_NUMBER_OF(buffer),
                                   L"%ws\\%08lX",
                                   CLUSDISK_SIGNATURE_KEYNAME,
                                   Signature ) ) ) {
        return FALSE;
    }

    status = ClusDiskInitRegistryString(
                                        &regString,
                                        buffer,
                                        wcslen(buffer)
                                        );
    if ( !NT_SUCCESS(status) ) {
        return(FALSE);
    }

    InitializeObjectAttributes(
            &objectAttributes,
            &regString,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

    status = ZwOpenKey(
                    &regHandle,
                    KEY_ALL_ACCESS,
                    &objectAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
#if 0
        ClusDiskPrint((
                1,
                "[ClusDisk] IsSignatureDisk: Error opening registry key <%wZ> for delete. Status %lx.\n",
                &regString,
                status));
#endif
        ExFreePool( regString.Buffer );
        return(FALSE);
    } else {
        ExFreePool( regString.Buffer );
        ZwClose( regHandle );
        return(TRUE);
    }

    return(STATUS_SUCCESS);

} // ClusDiskIsSignatureDisk



NTSTATUS
ClusDiskDeleteSignatureKey(
    IN PUNICODE_STRING  UnicodeString,
    IN LPWSTR  Name
    )

/*++

Routine Description:

    Delete the signature from the specified list.

Arguments:

    UnicodeString - pointer to the Unicode base keyname for deleting.

    Name - the keyname to delete.

Return Value:

    NTSTATUS for this request.

--*/

{
    WCHAR                       buffer[128];
    UNICODE_STRING              nameString;
    HANDLE                      deleteHandle;
    OBJECT_ATTRIBUTES           objectAttributes;
    NTSTATUS                    status;

    nameString.Length = 0;
    nameString.MaximumLength = sizeof(buffer);
    nameString.Buffer = buffer;

    RtlCopyUnicodeString( &nameString, UnicodeString );

    RtlAppendUnicodeToString(
            &nameString,
            L"\\"
            );

    RtlAppendUnicodeToString(
            &nameString,
            Name
            );
    nameString.Buffer[ nameString.Length / sizeof(WCHAR) ] = UNICODE_NULL;

    InitializeObjectAttributes(
            &objectAttributes,
            &nameString,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

    status = ZwOpenKey(
                    &deleteHandle,
                    KEY_ALL_ACCESS,
                    &objectAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] DeleteSignatureKey: Error opening registry key <%wZ> for delete. Status %lx.\n",
                &nameString,
                status));


        return(status);
    }

    status = ZwDeleteKey( deleteHandle );
    if ( !NT_SUCCESS(status)  &&
         (status != STATUS_OBJECT_NAME_NOT_FOUND) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] DeleteSignatureKey Error deleting <%ws> registry key from <%wZ>. Status: %lx\n",
                Name,
                &nameString,
                status));
    }

    ZwClose( deleteHandle );

    return(STATUS_SUCCESS);

} // ClusDiskDeleteSignatureKey



NTSTATUS
ClusDiskAddSignature(
    IN PUNICODE_STRING  UnicodeString,
    IN ULONG   Signature,
    IN BOOLEAN Volatile
    )

/*++

Routine Description:

    Add the signature to the specified list.

Arguments:

    UnicodeString - pointer to the Unicode base keyname for adding.

    Signature - signature to add.

    Volatile - TRUE if volatile key should be created.

Return Value:

    NTSTATUS for this request.

--*/

{
    NTSTATUS                    status;
    WCHAR                       buffer[MAXIMUM_FILENAME_LENGTH];
    UNICODE_STRING              nameString;
    HANDLE                      addHandle;
    OBJECT_ATTRIBUTES           objectAttributes;
    OBJECT_ATTRIBUTES           keyObjectAttributes;
    ULONG                       options = 0;
    UCHAR                       ntNameBuffer[64];
    STRING                      ntNameString;
    UNICODE_STRING              ntUnicodeString;

    ClusDiskPrint(( 3,
                    "[ClusDisk] ClusDiskAddSignature: adding signature %08X to %ws \n",
                    Signature,
                    UnicodeString->Buffer
                    ));

    if ( SystemDiskSignature == Signature ) {
        ClusDiskPrint(( 3,
                        "[ClusDisk] ClusDiskAddSignature: skipping system disk signature %08X \n",
                        Signature
                        ));
        return STATUS_INVALID_PARAMETER;
    }

    if ( Volatile ) {
        options = REG_OPTION_VOLATILE;
    }

    nameString.Length = 0;
    nameString.MaximumLength = sizeof( buffer );
    nameString.Buffer = buffer;

    //
    // Create the name of the key to add.
    //
    RtlCopyUnicodeString( &nameString, UnicodeString );

    //
    // Create device name for the physical disk.
    //

    if ( FAILED( StringCchPrintf( ntNameBuffer,
                                  RTL_NUMBER_OF( ntNameBuffer),
                                  "\\%08lX",
                                  Signature ) ) ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT( strlen(ntNameBuffer) < 64 );

    RtlInitAnsiString(&ntNameString,
                      ntNameBuffer);

    status = RtlAnsiStringToUnicodeString(&ntUnicodeString,
                                 &ntNameString,
                                 TRUE);

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    RtlAppendUnicodeToString(
                    &nameString,
                    ntUnicodeString.Buffer
                    );
    nameString.Buffer[ nameString.Length / sizeof(WCHAR) ] = UNICODE_NULL;

    RtlFreeUnicodeString( &ntUnicodeString );

    //
    // For opening the passed in registry key name.
    //
    InitializeObjectAttributes(
            &keyObjectAttributes,
            UnicodeString,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

    //
    // Attempt to open the passed in key.
    //
    status = ZwOpenKey(
                    &addHandle,
                    KEY_ALL_ACCESS,
                    &keyObjectAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        //
        // Assume the key doesn't exist.
        //
        status = ZwCreateKey(
                        &addHandle,
                        KEY_ALL_ACCESS,
                        &keyObjectAttributes,
                        0,
                        NULL,
                        options,
                        NULL
                        );
        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] AddSignature: Error creating registry key <%wZ>. Status: %lx\n",
                    UnicodeString,
                    status
                    ));
            return(status);
        }
    }

    ZwClose( addHandle );

    //
    // For opening the new registry key name.
    //
    InitializeObjectAttributes(
            &objectAttributes,
            &nameString,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

    status = ZwCreateKey(
                    &addHandle,
                    KEY_ALL_ACCESS,
                    &objectAttributes,
                    0,
                    NULL,
                    options,
                    NULL
                    );
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] AddSignature: Error creating registry key <%wZ> under <%wZ>. Status: %lx\n",
                &nameString,
                UnicodeString,
                status
                ));
        return(status);
    }

    ZwClose( addHandle );

    return(STATUS_SUCCESS);

} // ClusDiskAddSignature



NTSTATUS
ClusDiskDeleteSignature(
    IN PUNICODE_STRING  UnicodeString,
    IN ULONG   Signature
    )

/*++

Routine Description:

    Delete the signature from the specified list.

Arguments:

    UnicodeString - pointer to the Unicode base keyname for deleting.

    Signature - signature to delete.

Return Value:

    NTSTATUS for this request.

--*/

{
    NTSTATUS                    status;
    WCHAR                       buffer[128];
    UNICODE_STRING              nameString;
    HANDLE                      deleteHandle;
    OBJECT_ATTRIBUTES           objectAttributes;
    UCHAR                       ntNameBuffer[64];
    STRING                      ntNameString;
    UNICODE_STRING              ntUnicodeString;

    ClusDiskPrint(( 3,
                    "[ClusDisk] ClusDiskDeleteSignature: removing signature %08X \n",
                    Signature
                    ));

    nameString.Length = 0;
    nameString.MaximumLength = sizeof(buffer);
    nameString.Buffer = buffer;

    //
    // Create the name of the key to delete.
    //
    RtlCopyUnicodeString( &nameString, UnicodeString );

    //
    // Create device name for the physical disk.
    //

    if ( FAILED( StringCchPrintf( ntNameBuffer,
                                  RTL_NUMBER_OF(ntNameBuffer),
                                  "\\%08lX",
                                  Signature ) ) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitAnsiString(&ntNameString,
                      ntNameBuffer);

    status = RtlAnsiStringToUnicodeString(&ntUnicodeString,
                                 &ntNameString,
                                 TRUE);
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    RtlAppendUnicodeToString(
                    &nameString,
                    ntUnicodeString.Buffer
                    );
    nameString.Buffer[ nameString.Length / sizeof(WCHAR) ] = UNICODE_NULL;

    RtlFreeUnicodeString( &ntUnicodeString );

    //
    // Use generated name for opening.
    //
    InitializeObjectAttributes(
            &objectAttributes,
            &nameString,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

    //
    // Open the key for deleting.
    //
    status = ZwOpenKey(
                    &deleteHandle,
                    KEY_ALL_ACCESS,
                    &objectAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] DeleteSignature: Error opening registry key <%wZ> for delete. Status %lx.\n",
                &nameString,
                status
                ));
        return(status);
    }

    status = ZwDeleteKey( deleteHandle );
    if ( !NT_SUCCESS(status)  &&
         (status != STATUS_OBJECT_NAME_NOT_FOUND) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] DeleteSignature: Error deleting <%s> registry key from <%wZ>. Status: %lx\n",
                ntNameBuffer,
                &nameString,
                status
                ));

    }

    ZwClose( deleteHandle );

    return(STATUS_SUCCESS);

} // ClusDiskDeleteSignature



NTSTATUS
ClusDiskAddDiskName(
    IN HANDLE SignatureHandle,
    IN ULONG  DiskNumber
    )

/*++

Routine Description:

    Set the DiskName for a given signature handle.

Arguments:

    SignatureHandle - the handle for the signature to write.

    DiskNumber - the disk number for this signature.

Return Value:

    NTSTATUS for this request.

--*/

{
    NTSTATUS                status;
    UNICODE_STRING          name;
    UCHAR                   ntNameBuffer[64];
    STRING                  ntNameString;
    UNICODE_STRING          ntUnicodeString;

    //
    // Write the disk name.
    //

    RtlInitUnicodeString( &name, CLUSDISK_SIGNATURE_DISK_NAME );

    if ( FAILED( StringCchPrintf( ntNameBuffer,
                                  RTL_NUMBER_OF(ntNameBuffer),
                                  "\\Device\\Harddisk%d",
                                  DiskNumber ) ) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitAnsiString(&ntNameString,
                      ntNameBuffer);

    status = RtlAnsiStringToUnicodeString(&ntUnicodeString,
                                 &ntNameString,
                                 TRUE);

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    status = ZwSetValueKey(
                           SignatureHandle,
                           &name,
                           0,
                           REG_SZ,
                           ntUnicodeString.Buffer,
                           ntUnicodeString.Length + sizeof(UNICODE_NULL) );  // Length for this call must include the trailing NULL.

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((1,
                       "[ClusDisk] AddDiskName: Failed to set diskname for signature %wZ status: %08X\n",
                       &ntUnicodeString,
                       status));
    }

    RtlFreeUnicodeString( &ntUnicodeString );

    return(status);

} // ClusDiskAddDiskName



NTSTATUS
ClusDiskDeleteDiskName(
    IN PUNICODE_STRING  KeyName,
    IN LPWSTR  Name
    )

/*++

Routine Description:

    Delete the DiskName for the given key.

Arguments:

    KeyName - pointer to the Unicode base keyname for deleting.

    Name - the signature key to delete the diskname.

Return Value:

    NTSTATUS for this request.

--*/

{
    NTSTATUS                    status;
    WCHAR                       buffer[128];
    UNICODE_STRING              nameString;
    HANDLE                      deleteHandle;
    OBJECT_ATTRIBUTES           objectAttributes;

    nameString.Length = 0;
    nameString.MaximumLength = sizeof(buffer);
    nameString.Buffer = buffer;

    RtlCopyUnicodeString( &nameString, KeyName );

    RtlAppendUnicodeToString(
            &nameString,
            L"\\"
            );

    RtlAppendUnicodeToString(
            &nameString,
            Name
            );

    nameString.Buffer[ nameString.Length / sizeof(WCHAR) ] = UNICODE_NULL;

    InitializeObjectAttributes(
            &objectAttributes,
            &nameString,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

    status = ZwOpenKey(
                    &deleteHandle,
                    KEY_ALL_ACCESS,
                    &objectAttributes
                    );

    if ( status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        return(STATUS_SUCCESS);
    }

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] DeleteDiskName: Error opening registry key <%wZ> to delete DiskName. Status %lx.\n",
                &nameString,
                status
                ));

        return(status);
    }

    RtlInitUnicodeString( &nameString, CLUSDISK_SIGNATURE_DISK_NAME );

    status = ZwDeleteValueKey(
                             deleteHandle,
                             &nameString
                             );
    if ( !NT_SUCCESS(status)  &&
         (status != STATUS_OBJECT_NAME_NOT_FOUND) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] DeleteDiskName: Error deleting DiskName value key from <%ws\\%wZ>. Status: %lx\n",
                Name,
                &nameString,
                status
                ));
    }

    ZwClose( deleteHandle );

    return(STATUS_SUCCESS);

} // ClusDiskDeleteDiskName


VOID
ClusDiskDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
)
{
    KIRQL   irql;
    PCLUS_DEVICE_EXTENSION      deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;
    KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
    deviceExtension->Detached = TRUE;
    if ( deviceExtension->PhysicalDevice ) {
        ObDereferenceObject( deviceExtension->PhysicalDevice );
    }
    KeReleaseSpinLock(&ClusDiskSpinLock, irql);
    ExDeleteResourceLite( &deviceExtension->DriveLayoutLock );
    ExDeleteResourceLite( &deviceExtension->ReserveInfoLock );
    IoDeleteDevice( DeviceObject );
    return;
}


VOID
ClusDiskScsiInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID          NextDisk,
    IN ULONG          Count
    )

/*++

Routine Description:

    Attach to new disk devices and partitions for busses defined in registry.
    If this is the first time this routine is called,
    then register with the IO system to be called
    after all other disk device drivers have initiated.

Arguments:

    DriverObject - Disk performance driver object.

    NextDisk - Starting disk for this part of the initialization.

    Count - Not used. Number of times this routine has been called.

Return Value:

    NTSTATUS

--*/

{
    PCONFIGURATION_INFORMATION  configurationInformation;
    UNICODE_STRING              targetDeviceName;
    UNICODE_STRING              clusdiskDeviceName;
    WCHAR                       clusdiskDeviceBuffer[MAX_CLUSDISK_DEVICE_NAME_LENGTH];
    PDEVICE_OBJECT              deviceObject;
    PDEVICE_OBJECT              physicalDevice;
    PDEVICE_OBJECT              targetDevice = NULL;
    PDEVICE_OBJECT              attachedTargetDevice;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    PCLUS_DEVICE_EXTENSION      zeroExtension;
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo;
    PPARTITION_INFORMATION_EX       partitionInfo;
    NTSTATUS                    status;
    ULONG                       diskNumber;
    ULONG                       partIndex;
    ULONG                       enumIndex;
    ULONG                       returnedLength;
    ULONG                       signature;
    ULONG                       diskCount;
    ULONG                       skipCount;
    HANDLE                      signatureHandle;
    HANDLE                      availableHandle;
    WCHAR                       signatureBuffer[64];
    UNICODE_STRING              signatureKeyName;
    UNICODE_STRING              keyName;
    UNICODE_STRING              availableName;
    UNICODE_STRING              numberString;
    OBJECT_ATTRIBUTES           objectAttributes;
    OBJECT_ATTRIBUTES           availableObjectAttributes;
    UCHAR                       basicBuffer[MAX_BUFFER_SIZE];
    PKEY_BASIC_INFORMATION      keyBasicInformation;
    WCHAR                       signatureKeyBuffer[128];
    SCSI_ADDRESS                scsiAddress;

    // PAGED_CODE();        // 2000/02/05: stevedz - Paged code cannot grab spinlocks.

    ClusDiskRescan = FALSE;

    keyBasicInformation = (PKEY_BASIC_INFORMATION)basicBuffer;

    RtlZeroMemory(
                basicBuffer,
                MAX_BUFFER_SIZE
                );

    //
    // Get registry parameters for our device.
    //

    //
    // Allocate buffer for signatures registry key.
    //
    status = ClusDiskInitRegistryString(
                                        &keyName,
                                        CLUSDISK_SIGNATURE_KEYNAME,
                                        wcslen(CLUSDISK_SIGNATURE_KEYNAME)
                                        );
    if ( !NT_SUCCESS(status) ) {
        return;
    }

    //
    // Allocate buffer for our list of available signatures,
    // and form the subkey string name.
    //
    status = ClusDiskInitRegistryString(
                                        &availableName,
                                        CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                        wcslen(CLUSDISK_AVAILABLE_DISKS_KEYNAME)
                                        );
    if ( !NT_SUCCESS(status) ) {
        ExFreePool( keyName.Buffer );
        return;
    }

    //
    // Setup the object attributes for the Parameters\Signatures key.
    //

    InitializeObjectAttributes(
            &objectAttributes,
            &keyName,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

    //
    // Open Parameters\Signatures Key.
    //

    status = ZwOpenKey(
                    &signatureHandle,
                    KEY_READ,
                    &objectAttributes
                    );
    if ( status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        status = ZwCreateKey(
                        &signatureHandle,
                        KEY_ALL_ACCESS,
                        &objectAttributes,
                        0,
                        NULL,
                        0,
                        NULL
                        );
    }
    if ( !NT_SUCCESS(status) ) {
        ExFreePool( keyName.Buffer );
        ExFreePool( availableName.Buffer );
        ClusDiskPrint((
                    1,
                    "[ClusDisk] ScsiInit: Failed to open Signatures registry key. Status: %lx\n",
                    status
                    ));
        return;
    }

    //
    // Setup the object attributes for the Parameters\AvailableDisks key.
    //

    InitializeObjectAttributes(
            &availableObjectAttributes,
            &availableName,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

    //
    // Open Parameters\AvailableDisks Key.
    //

    status = ZwOpenKey(
                    &availableHandle,
                    KEY_ALL_ACCESS,
                    &availableObjectAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        if ( status != STATUS_OBJECT_NAME_NOT_FOUND ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] ScsiInit: Failed to open AvailableDisks registry key. Status: %lx. Continuing.\n",
                    status
                    ));
        }
    } else {

        //
        // Delete the previous list of available devices.
        //
        enumIndex = 0;
        while ( TRUE ) {
            status = ZwEnumerateKey(
                            availableHandle,
                            enumIndex,
                            KeyBasicInformation,
                            keyBasicInformation,
                            MAX_BUFFER_SIZE,
                            &returnedLength
                            );

            enumIndex++;

            if ( !NT_SUCCESS(status) ) {
                if ( status == STATUS_NO_MORE_ENTRIES ) {
                    break;
                } else {
                    continue;
                }
            }

            status = ClusDiskDeleteSignatureKey(
                                             &availableName,
                                             keyBasicInformation->Name
                                             );
            if ( !NT_SUCCESS(status) ) {
                continue;
            }
        }

        status = ZwDeleteKey( availableHandle );
        if ( !NT_SUCCESS(status)  &&
             (status != STATUS_OBJECT_NAME_NOT_FOUND) &&
             (status != STATUS_CANNOT_DELETE) ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] ScsiInit: Failed to delete AvailableDisks registry key. Status: %lx\n",
                    status
                    ));
        }

        ZwClose( availableHandle );
    }

    //
    // Find out which Scsi Devices to control by enumerating all of the
    // Signature keys. If we find a device that we cannot read the signature
    // for, we will attach to it anyway.
    //

    enumIndex = 0;
    while ( TRUE ) {
        status = ZwEnumerateKey(
                        signatureHandle,
                        enumIndex,
                        KeyBasicInformation,
                        keyBasicInformation,
                        MAX_BUFFER_SIZE,
                        &returnedLength
                        );

        enumIndex++;

        if ( !NT_SUCCESS(status) ) {
            if ( status == STATUS_NO_MORE_ENTRIES ) {
                break;
            } else {
                continue;
            }
        }

        //
        // Check that the value is reasonable. We're only looking for
        // signatures (ie keys that are hex numbers).
        //

        //
        // Check the signature. Make sure it's a number.
        //

        numberString.Buffer = keyBasicInformation->Name;
        numberString.MaximumLength = (USHORT)keyBasicInformation->NameLength +
                                sizeof(UNICODE_NULL);
        numberString.Length = (USHORT)keyBasicInformation->NameLength;

        status = RtlUnicodeStringToInteger(
                                &numberString,
                                16,
                                &signature
                                );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1,
                    "[ClusDisk] ScsiInit: Failed to get a good signature for %.*ws status: %08X\n",
                    keyBasicInformation->NameLength/sizeof(WCHAR),
                    keyBasicInformation->Name,
                    status));
            continue;
        }

        //
        // If this device is not in our list of attached devices, then add it!
        //
        if ( !MatchDevice( signature, NULL ) ) {

            if ( !AddAttachedDevice( signature, NULL ) ) {
                continue;
            }
        }

        //
        // Delete the DiskName for this signature key. We do this here in
        // case any of the rest of this fails.
        //

        // Don't delete entries for disks that we've already processed.

        if ( (ULONG_PTR)NextDisk != 0 ) {
            continue;
        }

        //
        // Delete the DiskName for the signature.
        //
        status = ClusDiskDeleteDiskName(
                                        &keyName,
                                        keyBasicInformation->Name
                                        );
    }

    ZwClose( signatureHandle );

    //
    // Get the system configuration information.
    //

    configurationInformation = IoGetConfigurationInformation();
    diskCount = configurationInformation->DiskCount;

    //
    // Find ALL disk devices.  There may be holes in the disk numbering,
    // so skipCount will be used.
    //
    for ( diskNumber = (ULONG)((ULONG_PTR)NextDisk), skipCount = 0;
          ( diskNumber < diskCount &&  skipCount < SKIP_COUNT_MAX );
          diskNumber++ ) {

        //
        // Create device name for the physical disk.
        //

        DEREFERENCE_OBJECT( targetDevice );
        status = ClusDiskGetTargetDevice( diskNumber,
                                          0,
                                          &targetDevice,
                                          &targetDeviceName,
                                          &driveLayoutInfo,
                                          &scsiAddress,
                                          FALSE );
        if ( !NT_SUCCESS(status) ) {

            //
            // If the device doesn't exist, this is likely a hole in the
            // disk numbering.
            //

            if ( !targetDevice &&
                 ( STATUS_FILE_INVALID == status ||
                   STATUS_DEVICE_DOES_NOT_EXIST == status ||
                   STATUS_OBJECT_PATH_NOT_FOUND == status ) ) {
                skipCount++;
                diskCount++;
                ClusDiskPrint(( 3,
                                "[ClusDisk] Adjust: skipCount %d   diskCount %d \n",
                                skipCount,
                                diskCount ));
                CDLOG( "ClusDiskScsiInitialize: Adjust: skipCount %d  diskCount %d ",
                       skipCount,
                       diskCount );
            }

            //
            // If we didn't get a target device or we're already attached
            // then skip this device.
            //
            if ( !targetDevice || ( targetDevice &&
                 ClusDiskAttached( targetDevice, diskNumber ) )  ) {

                FREE_DEVICE_NAME_BUFFER( targetDeviceName );

                FREE_AND_NULL_PTR( driveLayoutInfo );
                continue;
            }

            //
            // If this device is on the system bus... then skip it.
            // Also... if the media type is not FixedMedia, skip it.
            //
            if ( ((SystemDiskPort == scsiAddress.PortNumber) &&
                 (SystemDiskPath == scsiAddress.PathId)) ||
                 (GetMediaType( targetDevice ) != FixedMedia) ) {

                FREE_DEVICE_NAME_BUFFER( targetDeviceName );

                FREE_AND_NULL_PTR( driveLayoutInfo );
                continue;
            }

            //
            // Only process MBR disks.
            //

            if ( driveLayoutInfo &&
                 PARTITION_STYLE_MBR != driveLayoutInfo->PartitionStyle ) {
                ClusDiskPrint(( 3,
                                "[ClusDisk] Skipping non-MBR disk device %ws \n",
                                targetDeviceName.Buffer ));
                CDLOG( "ClusDiskScsiInitialize: Skipping non-MBR disk device %ws ",
                       targetDeviceName.Buffer );

                FREE_DEVICE_NAME_BUFFER( targetDeviceName );
                FREE_AND_NULL_PTR( driveLayoutInfo );
                continue;
            }

            if ( Count &&
                 (status == STATUS_DEVICE_NOT_READY) ) {
                ClusDiskRescan = TRUE;
                ClusDiskRescanRetry = MAX_RESCAN_RETRIES;
            }

            //
            // On failures, where we got a target device, always attach.
            // Use a signature of zero.
            //
            signature = 0;
            ClusDiskPrint((
                    1,
                    "[ClusDisk] Attach to device %ws anyway.\n",
                    targetDeviceName.Buffer ));
            CDLOG( "ClusDiskScsiInitialize: Attach to device %ws using signature = 0 ",
                   targetDeviceName.Buffer );

            goto Attach_Anyway;
        }

        if ( driveLayoutInfo == NULL ) {
            FREE_DEVICE_NAME_BUFFER( targetDeviceName );
            continue;
        }

        skipCount = 0;      // Device found, reset skipCount

        //
        // Only process MBR disks.
        //

        if ( PARTITION_STYLE_MBR != driveLayoutInfo->PartitionStyle ) {
            ClusDiskPrint(( 3,
                            "[ClusDisk] Skipping non-MBR disk device %ws \n",
                            targetDeviceName.Buffer ));
            CDLOG( "ClusDiskScsiInitialize: Skipping non-MBR disk device %ws ",
                   targetDeviceName.Buffer );

            FREE_DEVICE_NAME_BUFFER( targetDeviceName );
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

        //
        // Don't control disks that have no signature.
        //
        if ( 0 == driveLayoutInfo->Mbr.Signature ) {
            FREE_DEVICE_NAME_BUFFER( targetDeviceName );
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

        //
        // If this device is on the system bus... then skip it.
        // Also... skip any device we're already attached to.
        //
        if ( ((SystemDiskPort == scsiAddress.PortNumber) &&
             (SystemDiskPath == scsiAddress.PathId)) ||
            (GetMediaType( targetDevice ) != FixedMedia) ||
            ClusDiskAttached( targetDevice, diskNumber) ) {
            FREE_DEVICE_NAME_BUFFER( targetDeviceName );
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

        //
        // Skip system disk.
        //

        if ( SystemDiskSignature == driveLayoutInfo->Mbr.Signature ) {
            FREE_DEVICE_NAME_BUFFER( targetDeviceName );
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

#if 0
        // Don't check for NTFS partitions.

        //
        // Look through the partition table and determine if all
        // the partitions are NTFS. If not all NTFS, then we won't
        // attach to this volume.
        //
        attachVolume = TRUE;
        for (partIndex = 0;
             partIndex < driveLayoutInfo->PartitionCount;
             partIndex++)
        {

            partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];


            if (!partitionInfo->Mbr.RecognizedPartition ||
                partitionInfo->PartitionNumber == 0)
            {
                continue;
            }

            if ( (partitionInfo->PartitionType & ~PARTITION_NTFT) != PARTITION_IFS ) {
                attachVolume = FALSE;
                break;
            }
        }

        if ( !attachVolume ) {
            FREE_DEVICE_NAME_BUFFER( targetDeviceName );
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }
#endif

        signature = driveLayoutInfo->Mbr.Signature;

Attach_Anyway:

        skipCount = 0;      // Device found, reset skipCount

        //
        // Create device object for partition 0.
        //

        if ( FAILED( StringCchPrintfW( clusdiskDeviceBuffer,
                                       RTL_NUMBER_OF(clusdiskDeviceBuffer),
                                       CLUSDISK_DEVICE_NAME,
                                       diskNumber,
                                       0 ) ) ) {
            FREE_DEVICE_NAME_BUFFER( targetDeviceName );
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

        RtlInitUnicodeString( &clusdiskDeviceName, clusdiskDeviceBuffer );

        status = IoCreateDevice(DriverObject,
                                sizeof(CLUS_DEVICE_EXTENSION),
                                &clusdiskDeviceName,
                                FILE_DEVICE_DISK,
                                FILE_DEVICE_SECURE_OPEN,
                                FALSE,
                                &physicalDevice);

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1, "[ClusDisk] ScsiInit: Failed to create device for Drive%u %08X\n",
                           diskNumber, status));

            FREE_DEVICE_NAME_BUFFER( targetDeviceName );
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

        CDLOG( "ClusDiskScsiInitialize: Created new device %p for disk %d  partition 0  signature %08X ",
               physicalDevice,
               diskNumber,
               signature );

        physicalDevice->Flags |= DO_DIRECT_IO;

        //
        // Point device extension back at device object and remember
        // the disk number.
        //
        deviceExtension = physicalDevice->DeviceExtension;
        zeroExtension = deviceExtension;
        deviceExtension->DeviceObject = physicalDevice;
        deviceExtension->DiskNumber = diskNumber;
        deviceExtension->LastPartitionNumber = 0;
        deviceExtension->DriverObject = DriverObject;
        deviceExtension->AttachValid = TRUE;
        deviceExtension->ReserveTimer = 0;
        deviceExtension->PerformReserves = TRUE;
        deviceExtension->ReserveFailure = 0;
        deviceExtension->Signature = signature;
        deviceExtension->Detached = TRUE;
        deviceExtension->OfflinePending = FALSE;
        deviceExtension->ScsiAddress = scsiAddress;
        deviceExtension->BusType = ScsiBus;
        InitializeListHead( &deviceExtension->WaitingIoctls );

        IoInitializeRemoveLock( &deviceExtension->RemoveLock, CLUSDISK_ALLOC_TAG, 0, 0 );

        //
        // Signal the worker thread running event.
        //
        KeInitializeEvent( &deviceExtension->Event, NotificationEvent, TRUE );

        ExInitializeWorkItem(&deviceExtension->WorkItem,
                             (PWORKER_THREAD_ROUTINE)ClusDiskReservationWorker,
                             (PVOID)deviceExtension );

        // Always mark disk offline.  If disk is one we shouldn't control, then
        // we will mark it online before exiting.
        //
        // We offline all the volumes later.  For now, just mark the disk offline.
        //

        deviceExtension->DiskState = DiskOffline;

        KeInitializeEvent( &deviceExtension->PagingPathCountEvent,
                           NotificationEvent, TRUE );
        deviceExtension->PagingPathCount = 0;
        deviceExtension->HibernationPathCount = 0;
        deviceExtension->DumpPathCount = 0;

        ExInitializeResourceLite( &deviceExtension->DriveLayoutLock );
        ExInitializeResourceLite( &deviceExtension->ReserveInfoLock );

        //
        // This is the physical device object.
        //
        ObReferenceObject( physicalDevice );
        deviceExtension->PhysicalDevice = physicalDevice;

#if 0   // Can't have a FS on partition 0
        //
        // Dismount any file system that might be hanging around
        //
        if ( targetDevice->Vpb &&
             (targetDevice->Vpb->Flags & VPB_MOUNTED) ) {

            status = DismountPartition( targetDevice, diskNumber, 0 );

            if ( !NT_SUCCESS( status )) {
                ClusDiskPrint((1,
                               "[ClusDisk] ScsiInit: dismount of %u/0 failed, %08X\n",
                               diskNumber, status));
            }
        }
#endif

        //
        // Attach to partition0. This call links the newly created
        // device to the target device, returning the target device object.
        // We may not want to stay attached for long... depending on
        // whether this is a device we're interested in.
        //

        attachedTargetDevice = IoAttachDeviceToDeviceStack(physicalDevice,
                                                           targetDevice);

#if CLUSTER_FREE_ASSERTS && CLUSTER_STALL_THREAD
        DBG_STALL_THREAD( 2 );   // Defined only for debugging.
#endif

        FREE_DEVICE_NAME_BUFFER( targetDeviceName );

        deviceExtension->TargetDeviceObject = attachedTargetDevice;
        deviceExtension->Detached = FALSE;
        physicalDevice->Flags &= ~DO_DEVICE_INITIALIZING;

        //
        // Once attached, we always need to set this information.
        //

        if ( attachedTargetDevice ) {

            //
            // Propagate driver's alignment requirements and power flags
            //

            physicalDevice->AlignmentRequirement =
                deviceExtension->TargetDeviceObject->AlignmentRequirement;

            physicalDevice->SectorSize =
                deviceExtension->TargetDeviceObject->SectorSize;

            //
            // The storage stack explicitly requires DO_POWER_PAGABLE to be
            // set in all filter drivers *unless* DO_POWER_INRUSH is set.
            // this is true even if the attached device doesn't set DO_POWER_PAGABLE.
            //
            if ( deviceExtension->TargetDeviceObject->Flags & DO_POWER_INRUSH) {
                physicalDevice->Flags |= DO_POWER_INRUSH;
            } else {
                physicalDevice->Flags |= DO_POWER_PAGABLE;
            }

        }

        if ( signature == 0 ) {
            FREE_AND_NULL_PTR( driveLayoutInfo );

            ClusDiskDismountDevice( diskNumber, FALSE );

            //
            // Tell partmgr to eject volumes to remove volumes for this disk.  This
            // should prevent I/O from bypassing the partition0 device when we couldn't
            // get the drive layout.
            //

            EjectVolumes( deviceExtension->DeviceObject );

            continue;
        }

        if ( attachedTargetDevice == NULL ) {
            ClusDiskPrint((1,
                           "[ClusDisk] ScsiInit: Failed to attach to device Drive%u\n",
                           diskNumber));

            ClusDiskDeleteDevice(physicalDevice);
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }
        ASSERT( attachedTargetDevice == targetDevice );

        //
        // If we're attaching to a file system device, then return
        // now. We must do this check after the dismount!
        //
        if (deviceExtension->TargetDeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {
            goto skip_this_physical_device_with_info;
        }

        //
        // Add this this device and bus to our list of devices/busses.
        //
        // This still isn't the correct place to do this. The
        // available disk list is built at the end of this function by
        // looking at the signatures and noting which ones are NOT in
        // the device list. If so, then that signature is added to the
        // available device registry key. By call AddAttachedDevice at
        // this point, the signature is always present on the list. If
        // we add the call after the following if clause, then the code
        // at the end of the function will still fail. This should probably
        // be changed to add the device to the available device list when
        // the following if fails.
        //
//        AddAttachedDevice( deviceExtension->Signature, physicalDevice );

        //
        // If the signature does not match one that we should really attach
        // to, then just mark it as not attached.
        //
        if ( !MatchDevice( deviceExtension->Signature, NULL ) ) {

            ClusDiskPrint((3,
                           "[ClusDisk] ScsiInit: adding disk %u (%08X) to available disks list\n",
                           diskNumber, driveLayoutInfo->Mbr.Signature));

            //
            // Create the signature key using the available name.
            //
            status = ClusDiskAddSignature(&availableName,
                                          driveLayoutInfo->Mbr.Signature,
                                          TRUE);

            //
            // Detach from the target device. This only requires marking
            // the device object as detached!
            //
            deviceExtension->Detached = TRUE;

            //
            // Make this device available again.
            // Don't need to stop reserves because reserves not yet started.
            //
            // deviceExtension->DiskState = DiskOnline;
            ONLINE_DISK( deviceExtension );

            FREE_AND_NULL_PTR( driveLayoutInfo );

            continue;
            //goto skip_this_physical_device_with_info;
        }

        //
        // add this disk to devices we're controlling
        //
        AddAttachedDevice( deviceExtension->Signature, physicalDevice );

        //
        // Now open the actual signature key. Using original key name.
        //

        signatureKeyName.Length = 0;
        signatureKeyName.MaximumLength = sizeof(signatureKeyBuffer);
        signatureKeyName.Buffer = signatureKeyBuffer;

        RtlCopyUnicodeString( &signatureKeyName, &keyName );

        //
        // Create device name for the physical disk we just attached.
        //

        if ( FAILED( StringCchPrintfW( signatureBuffer,
                                       RTL_NUMBER_OF(signatureBuffer),
                                       L"\\%08lX",
                                       deviceExtension->Signature ) ) ) {
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

        WCSLEN_ASSERT( signatureBuffer );

        RtlAppendUnicodeToString( &signatureKeyName, signatureBuffer );
        signatureKeyName.Buffer[ signatureKeyName.Length / sizeof(WCHAR) ] = UNICODE_NULL;

        //
        // Setup the object attributes for the Parameters\Signatures\xyz key.
        //

        InitializeObjectAttributes(
                &objectAttributes,
                &signatureKeyName,
                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                NULL,
                NULL
                );

        //
        // Open Parameters\Signatures\xyz Key.
        //

        status = ZwOpenKey(
                        &signatureHandle,
                        KEY_READ | KEY_WRITE,
                        &objectAttributes
                        );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                        1,
                        "[ClusDisk] ScsiInit: Failed to open %wZ registry key. Status: %lx\n",
                        &signatureKeyName,
                        status
                        ));
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

        //
        // Write the disk name.
        //
        status = ClusDiskAddDiskName( signatureHandle, diskNumber );

        ZwClose( signatureHandle );

        //
        // Offline all volumes for this disk.
        // First, send offline directly to the PDO of the volume stack to block I/O.
        // Before we bring the volume online, we always send an offline to all
        // the volumes in the stack, so volsnap can clean up.
        //

        OFFLINE_DISK_PDO( deviceExtension );

        //
        // Dismount all volumes on this disk.
        //

        ClusDiskDismountDevice( diskNumber, TRUE );

#if 0   // Removed 2/27/2001
        //
        // Called only for physical devices (partition0).
        //

        EjectVolumes( deviceExtension->DeviceObject );
        ReclaimVolumes( deviceExtension->DeviceObject );
#endif

        //
        // Now enumerate the partitions on this device in order to
        // attach a ClusDisk device object to each partition device object.
        //

        for (partIndex = 0;
             partIndex < driveLayoutInfo->PartitionCount;
             partIndex++)
        {

            partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

            //
            // Make sure that there really is a partition here.
            //

            if (!partitionInfo->Mbr.RecognizedPartition ||
                partitionInfo->PartitionNumber == 0)
            {
                continue;
            }

            CreateVolumeObject( zeroExtension,
                                diskNumber,
                                partitionInfo->PartitionNumber,
                                NULL );

        }

        FREE_AND_NULL_PTR( driveLayoutInfo );
        continue;

skip_this_physical_device_with_info:

        FREE_AND_NULL_PTR( driveLayoutInfo );

//skip_this_physical_device:

        deviceExtension->Detached = TRUE;
        IoDetachDevice( deviceExtension->TargetDeviceObject );
        ClusDiskDeleteDevice( physicalDevice );

    }

    ExFreePool( keyName.Buffer );

    //
    // Find all available disk devices. These are devices that do not reside
    // on the system bus and the signature is not part of the Signatures list.
    //

    for (diskNumber = 0;
         diskNumber < configurationInformation->DiskCount;
         diskNumber++) {

        //
        // Create device name for the physical disk.
        //
        DEREFERENCE_OBJECT( targetDevice );
        status = ClusDiskGetTargetDevice( diskNumber,
                                          0,
                                          NULL,
                                          &targetDeviceName,
                                          &driveLayoutInfo,
                                          &scsiAddress,
                                          FALSE );
        if ( !NT_SUCCESS(status) ) {
            FREE_DEVICE_NAME_BUFFER( targetDeviceName );
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

        if ( driveLayoutInfo == NULL ) {
            FREE_DEVICE_NAME_BUFFER( targetDeviceName );
            continue;
        }

        //
        // Don't control disks that have no signature or system disk.
        //
        if ( ( 0 == driveLayoutInfo->Mbr.Signature )  ||
             ( SystemDiskSignature == driveLayoutInfo->Mbr.Signature ) ) {
            FREE_DEVICE_NAME_BUFFER( targetDeviceName );
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

        //
        // Now write the signature to the list of available disks,
        // if the signature does not match one we already have and
        // the device is not on the system bus.
        //
        if ( !MatchDevice(driveLayoutInfo->Mbr.Signature, &deviceObject) &&
             ((SystemDiskPort != scsiAddress.PortNumber) ||
              (SystemDiskPath != scsiAddress.PathId)) ) {

            ClusDiskPrint((3,
                           "[ClusDisk] ScsiInit: adding disk %u (%08X) to available disks list\n",
                           diskNumber, driveLayoutInfo->Mbr.Signature));

            //
            // Create the signature key. Using the available name.
            //
            status = ClusDiskAddSignature(&availableName,
                                          driveLayoutInfo->Mbr.Signature,
                                          TRUE);

            //
            // Make sure this device comes online.
            //
            if ( deviceObject ) {
                deviceExtension = deviceObject->DeviceExtension;
                deviceExtension->Detached = TRUE;
                // deviceExtension->DiskState = DiskOnline;
                ONLINE_DISK( deviceExtension );
            }
        }
        FREE_DEVICE_NAME_BUFFER( targetDeviceName );
        FREE_AND_NULL_PTR( driveLayoutInfo );
    }

    ExFreePool( availableName.Buffer );

    DEREFERENCE_OBJECT( targetDevice );

} // ClusDiskScsiInitialize


NTSTATUS
CreateVolumeObject(
    PCLUS_DEVICE_EXTENSION ZeroExtension,
    ULONG DiskNumber,
    ULONG PartitionNumber,
    PDEVICE_OBJECT TargetDev
    )
{
    PDEVICE_OBJECT              targetDevice = NULL;
    PDEVICE_OBJECT              deviceObject;
    PDEVICE_OBJECT              attachedTargetDevice;

    PCLUS_DEVICE_EXTENSION      deviceExtension;

    NTSTATUS                    status = STATUS_UNSUCCESSFUL;

    UNICODE_STRING              targetDeviceName;
    UNICODE_STRING              clusdiskDeviceName;

    WCHAR                       clusdiskDeviceBuffer[MAX_CLUSDISK_DEVICE_NAME_LENGTH];

    CDLOG( "CreateVolumeObject: Entry  ZeroExt %p  disk %d/%d  TargetDev %p",
           ZeroExtension,
           DiskNumber,
           PartitionNumber,
           TargetDev );

    targetDeviceName.Buffer = NULL;

    //
    // If caller specified a target device, use it.  The caller is responsible
    // for taking a reference and releasing the reference when the caller is done.
    //

    if ( TargetDev ) {

        targetDevice = TargetDev;

    } else {

        //
        // Create device name for partition.
        //
        status = ClusDiskGetTargetDevice( DiskNumber,
                                          PartitionNumber,
                                          &targetDevice,
                                          &targetDeviceName,
                                          NULL,
                                          NULL,
                                          FALSE );
        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1,
                           "[ClusDisk] CreateVolumeObject: couldn't attach to disk %u/%u, status %08X\n",
                           DiskNumber,
                           PartitionNumber,
                           status));

            CDLOG( "CreateVolumeObject: Couldn't attach to disk %d/%d, status %08X",
                   DiskNumber,
                   PartitionNumber,
                   status );
            goto FnExit;
        }
    }

    //
    // The device name string won't be created if caller passed in the target
    // device object.  Don't use device name string in following logging statements.
    //

#if 0
    // Don't care if we are already attached.  When we try to create the disk
    // object, if it already exists, then we know we are already attached.
    // The call to ClusDiskAttached doesn't work anyway, because the clusdisk
    // disk object responds even if the clusdisk volume objects don't exist.

    //
    // Make sure we're not attached here!
    //
    if ( ClusDiskAttached( targetDevice, DiskNumber ) ) {
        // really hosed!

        ClusDiskPrint(( 1,
                        "[ClusDisk] CreateVolumeObject: Previously attached to disk %u/%u \n",
                        DiskNumber,
                        PartitionNumber ));
        CDLOG( "CreateVolumeObject: Previously attached to disk %u/%u ",
               DiskNumber,
               PartitionNumber );

        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }
#endif

    //
    // Check if this device is a file system device.
    //
    if ( targetDevice->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM ) {

        //
        // Can't attach to a device that is already mounted.
        //
        ClusDiskPrint(( 1,
                        "[ClusDisk] CreateVolumeObject: Attempted to attach to FS disk %u/%u \n",
                        DiskNumber,
                        PartitionNumber ));
        CDLOG( "CreateVolumeObject: Attempted to attach to FS disk %u/%u ",
               DiskNumber,
               PartitionNumber );

        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    //
    // Create device object for this partition.
    //

    if ( FAILED( StringCchPrintfW( clusdiskDeviceBuffer,
                                   RTL_NUMBER_OF(clusdiskDeviceBuffer),
                                   CLUSDISK_DEVICE_NAME,
                                   DiskNumber,
                                   PartitionNumber ) ) ) {
        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    WCSLEN_ASSERT( clusdiskDeviceBuffer );

    RtlInitUnicodeString( &clusdiskDeviceName, clusdiskDeviceBuffer );

    status = IoCreateDevice(ZeroExtension->DriverObject,
                            sizeof(CLUS_DEVICE_EXTENSION),
                            &clusdiskDeviceName,
                            FILE_DEVICE_DISK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &deviceObject);

    if ( !NT_SUCCESS(status) ) {

        //
        // If the previous clusdisk volume object existed, this should correctly
        // fail with c0000035 STATUS_OBJECT_NAME_COLLISION.
        //
        goto FnExit;
    }

    CDLOG( "CreateVolumeObject: Created new device %p for disk %d partition %d  signature %08X ",
           deviceObject,
           DiskNumber,
           PartitionNumber,
           ZeroExtension->Signature );

    deviceObject->Flags |= DO_DIRECT_IO;

    //
    // Point device extension back at device object and
    // remember the disk number.
    //

    deviceExtension = deviceObject->DeviceExtension;
    deviceExtension->DeviceObject = deviceObject;
    deviceExtension->DiskNumber = DiskNumber;
    deviceExtension->DriverObject = ZeroExtension->DriverObject;
    deviceExtension->AttachValid = TRUE;
    deviceExtension->BusType = ScsiBus;
    deviceExtension->PerformReserves = FALSE;
    deviceExtension->ReserveFailure = 0;
    deviceExtension->Signature = ZeroExtension->Signature;
    deviceExtension->ScsiAddress = ZeroExtension->ScsiAddress;
    deviceExtension->Detached = TRUE;
    deviceExtension->OfflinePending = FALSE;
    deviceExtension->DiskState = ZeroExtension->DiskState;
    InitializeListHead( &deviceExtension->WaitingIoctls );

    IoInitializeRemoveLock( &deviceExtension->RemoveLock, CLUSDISK_ALLOC_TAG, 0, 0 );

    //
    // Signal the worker thread running event.
    //
    KeInitializeEvent( &deviceExtension->Event, NotificationEvent, TRUE );

    //
    // Maintain the last partition number created.  Put it in
    // each extension just to initialize the field.
    //

    deviceExtension->LastPartitionNumber = max(deviceExtension->LastPartitionNumber,
                                               PartitionNumber);

    ZeroExtension->LastPartitionNumber = deviceExtension->LastPartitionNumber;

    KeInitializeEvent( &deviceExtension->PagingPathCountEvent,
                       NotificationEvent, TRUE );
    deviceExtension->PagingPathCount = 0;
    deviceExtension->HibernationPathCount = 0;
    deviceExtension->DumpPathCount = 0;

    ExInitializeResourceLite( &deviceExtension->DriveLayoutLock );
    ExInitializeResourceLite( &deviceExtension->ReserveInfoLock );

    //
    // Store pointer to physical device.
    //
    ObReferenceObject( ZeroExtension->PhysicalDevice );
    deviceExtension->PhysicalDevice = ZeroExtension->PhysicalDevice;

    CDLOG( "ClusDiskInfo *** Phys DO %p  DevExt %p  DiskNum %d  Signature %08X  RemLock %p ***",
            deviceObject,
            deviceExtension,
            deviceExtension->DiskNumber,
            deviceExtension->Signature,
            &deviceExtension->RemoveLock );

    //
    // First dismount any mounted file systems.
    //
    if ( targetDevice->Vpb &&
         (targetDevice->Vpb->Flags & VPB_MOUNTED) ) {

        status = DismountPartition( targetDevice,
                                    DiskNumber,
                                    PartitionNumber);

        if ( !NT_SUCCESS( status )) {
            ClusDiskPrint((1,
                          "[ClusDisk] CreateVolumeObject: dismount of disk %u/%u failed %08X\n",
                          DiskNumber, PartitionNumber, status));
            status = STATUS_SUCCESS;
        }
    }

    //
    // Attach to the partition. This call links the newly created
    // device to the target device, returning the target device object.
    //
    ClusDiskPrint(( 3,
                    "[ClusDisk] CreateVolumeObject: attaching to disk %u/%u \n",
                    DiskNumber,
                    PartitionNumber ));

    attachedTargetDevice = IoAttachDeviceToDeviceStack(deviceObject,
                                                       targetDevice );

#if CLUSTER_FREE_ASSERTS && CLUSTER_STALL_THREAD
    DBG_STALL_THREAD( 2 );   // Defined only for debugging.
#endif

    deviceExtension->Detached = ZeroExtension->Detached;
    ASSERT( attachedTargetDevice == targetDevice );

    if ( attachedTargetDevice == NULL ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] CreateVolumeObject: Failed to attach to disk %u/%u \n",
                        DiskNumber,
                        PartitionNumber ));

        ClusDiskDeleteDevice(deviceObject);
        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    deviceExtension->TargetDeviceObject = attachedTargetDevice;
    deviceExtension->Detached = FALSE;

    //
    // Propagate driver's alignment requirements and power flags.
    //

    deviceObject->AlignmentRequirement =
        deviceExtension->TargetDeviceObject->AlignmentRequirement;

    deviceObject->SectorSize =
        deviceExtension->TargetDeviceObject->SectorSize;

    //
    // The storage stack explicitly requires DO_POWER_PAGABLE to be
    // set in all filter drivers *unless* DO_POWER_INRUSH is set.
    // this is true even if the attached device doesn't set DO_POWER_PAGABLE.
    //
    if ( deviceExtension->TargetDeviceObject->Flags & DO_POWER_INRUSH) {
        deviceObject->Flags |= DO_POWER_INRUSH;
    } else {
        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

    //
    // Safe to dismount now that we're attached. This should cause
    // the next IO to attach the FS to our device.
    //

    // Why do we dismount twice?

    if ( targetDevice->Vpb ) {
        if ( targetDevice->Vpb->Flags & VPB_MOUNTED ) {

            ClusDiskPrint((1,
                           "[ClusDisk] CreateVolumeObject: disk %u/%u is Mounted!\n",
                           DiskNumber, PartitionNumber));

            status = DismountPartition( targetDevice,
                                        DiskNumber,
                                        PartitionNumber);

            if ( !NT_SUCCESS( status )) {
                ClusDiskPrint((1,
                               "[ClusDisk] CreateVolumeObject: dismount of disk %u/%u failed %08X\n",
                               DiskNumber, PartitionNumber, status));
                status = STATUS_SUCCESS;
            }
        }
    }

    // Clear the flag so the device can be used.

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

FnExit:

    //
    // Only dereference the target device if the caller didn't specify it.
    // The target device name is only created if caller didn't specify the
    // target device.
    //

    if ( !TargetDev ) {
        DEREFERENCE_OBJECT( targetDevice );
    }

    FREE_DEVICE_NAME_BUFFER( targetDeviceName );


#if CLUSTER_FREE_ASSERTS
    if ( !NT_SUCCESS( status ) ) {
        DbgPrint( "[ClusDisk] CreateVolumeObject failed: %08X \n", status );

        //
        // If we are in the volume notification thread, the TargetDev parameter
        // will be non-zero.  In this case, the only "acceptable" failure is
        // STATUS_OBJECT_NAME_COLLISION.
        //

        if ( TargetDev && STATUS_OBJECT_NAME_COLLISION != status ) {
            DbgBreakPoint();
        }
    }
#endif

    CDLOG( "CreateVolumeObject: Exit  ZeroExt %p  disk %d/%d  TargetDev %p  status %08X",
           ZeroExtension,
           DiskNumber,
           PartitionNumber,
           TargetDev,
           status );

    ClusDiskPrint(( 3,
                    "[ClusDisk] CreateVolumeObject: Exit  disk %d/%d  status %08X \n",
                    DiskNumber,
                    PartitionNumber,
                    status ));

    return status;

}   // CreateVolumeObject


#if 0  // This code cannot be used!

VOID
ClusDiskUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine cleans up all memmory allocations and detaches from each
    target device.

Arguments:

    DriverObject - a pointer to the driver object to unload.

Return Value:

    None.

Note - we should acquire the ClusDiskSpinLock, but then this code is NOT
       pageable!

--*/

{
    PCONFIGURATION_INFORMATION configurationInformation;
    PDEVICE_OBJECT            deviceObject = DriverObject->DeviceObject;
    PCLUS_DEVICE_EXTENSION    deviceExtension;
    PDEVICE_LIST_ENTRY        deviceEntry;
    PSCSI_BUS_ENTRY           scsiBusEntry;
    PVOID                     freeBlock;
    PLIST_ENTRY               listEntry;
    PIRP                      irp;
    ULONG                     diskNumber;
    NTSTATUS                  status;

    PAGED_CODE();

#if 0   // Moved to IRP_PNP_MN_REMOVE handler

    if ( RootDeviceObject ) {
        deviceExtension = RootDeviceObject->DeviceExtension;
        status = IoUnregisterPlugPlayNotification(
                                     deviceExtension->DiskNotificationEntry);

        RootDeviceObject = NULL;
    }

    //
    // Free all device entries..
    //

    deviceEntry = ClusDiskDeviceList;
    while ( deviceEntry ) {
        freeBlock = deviceEntry;
        deviceEntry = deviceEntry->Next;
        ExFreePool( freeBlock );
    }
    ClusDiskDeviceList = NULL;

#endif

    //
    // 2000/02/04: stevedz - With PnP, the following loop is not required.
    // When we get unload working, it will be removed.
    //

#if 0
    //
    // Loop through all device objects detaching...
    //
    // On NT4 - Need SpinLocks!  The DriverObject->DeviceObject list is not synchronized!
    // On Win2000, PnP will already have cleaned this up
    //
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        //
        // Signal all waiting Irp's on the physical device extension.
        //
        while ( !IsListEmpty(&deviceExtension->WaitingIoctls) ) {
            listEntry = RemoveHeadList(&deviceExtension->WaitingIoctls);
            irp = CONTAINING_RECORD( listEntry,
                                     IRP,
                                     Tail.Overlay.ListEntry );
            ClusDiskCompletePendingRequest(irp, STATUS_SUCCESS, deviceExtension);
        }

        if ( deviceExtension->BusType != RootBus ) {
            IoDetachDevice( deviceExtension->TargetDeviceObject );
        }

        if ( deviceExtension->BusType == RootBus ) {
            IoStopTimer( deviceObject );
        }

        ExDeleteResourceLite( &deviceExtension->DriveLayoutLock );
        ExDeleteResourceLite( &deviceExtension->ReserveInfoLock );
        IoDeleteDevice( deviceObject );
        deviceObject = DriverObject->DeviceObject;
    }
#endif

#if 0
    //
    // dismount all FS so we can free up references to our dev objs
    //

    configurationInformation = IoGetConfigurationInformation();

    for (diskNumber = 0;
         diskNumber < configurationInformation->DiskCount;
         diskNumber++)
    {
        ClusDiskDismountDevice( diskNumber, TRUE );
    }
#endif

    ArbitrationDone();
    ExDeleteResourceLite(&ClusDiskDeviceListLock);

    if ( ClusDiskRegistryPath.Buffer ) {
        ExFreePool( ClusDiskRegistryPath.Buffer );
        ClusDiskRegistryPath.Buffer = NULL;
    }

    if ( gArbitrationBuffer ) {
        ExFreePool( gArbitrationBuffer );
        gArbitrationBuffer = NULL;
    }

    WPP_CLEANUP(DriverObject);

} // ClusDiskUnload
#endif



NTSTATUS
ClusDiskCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine services open requests. It establishes
    the driver's existance by returning status success.

Arguments:

    DeviceObject - Context for the activity.
    Irp          - The device control argument block.

Return Value:

    NT Status

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalExtension =
                               deviceExtension->PhysicalDevice->DeviceExtension;
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status;

    CDLOGF(CREATE,"ClusDiskCreate: Entry DO %p", DeviceObject);

    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    status = AcquireRemoveLock(&physicalExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Make sure that the user is not attempting to sneak around the
    // security checks. Make sure that FileObject->RelatedFileObject is
    // NULL and that the FileName length is zero!
    //
    if ( irpStack->FileObject->RelatedFileObject ||
         irpStack->FileObject->FileName.Length ) {
        ReleaseRemoveLock(&physicalExtension->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_ACCESS_DENIED;
    }

    //
    // if our dev object for partition 0 is offline, clear the
    // FS context. If we've been asked to create a directory file,
    // fail the request.
    //
    if ( physicalExtension->DiskState == DiskOffline ) {

        //
        // [GORN] Why do we do this here?
        //    ClusDiskCreate is called when FileObject is created,
        //    so nobody has been able to put anything into FsContext field yet.
        //
        CDLOGF(CREATE,"ClusDiskCreate: RefTrack(%p)", irpStack->FileObject->FsContext );
        irpStack->FileObject->FsContext = NULL;
        if ( irpStack->Parameters.Create.Options & FILE_DIRECTORY_FILE ) {
            ReleaseRemoveLock(&physicalExtension->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock,  Irp);
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(STATUS_INVALID_DEVICE_REQUEST);
        }
    }

    CDLOGF(CREATE,"ClusDiskCreate: Exit DO %p", DeviceObject );

    ReleaseRemoveLock(&physicalExtension->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock,  Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;

} // ClusDiskCreate



NTSTATUS
ClusDiskClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine services close commands. It destroys the file object
    context.

Arguments:

    DeviceObject - Pointer to the device object on which the irp was received.
    Irp          - The IRP.

Return Value:

    NT Status

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalExtension =
                               deviceExtension->PhysicalDevice->DeviceExtension;
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS status;

    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    status = AcquireRemoveLock(&physicalExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if ( physicalExtension->DiskState == DiskOffline ) {
        //
        // [GORN] Cleanup cleans the FsContext, by the time
        //   we will get here, FsContext should be already NULL
        //
        CDLOGF(CLOSE,"ClusDiskClose: RefTrack %p", irpStack->FileObject->FsContext );
        irpStack->FileObject->FsContext = NULL;
    }

    CDLOGF(CLOSE,"ClusDiskClose DO %p", DeviceObject );

    //
    // Release the RemoveLocks with the FileObject tag, not the IRP.
    //

    ReleaseRemoveLock(&physicalExtension->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;

} // ClusDiskClose


VOID
ClusDiskCompletePendedIrps(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN ULONG        Offline
    )

/*++

Routine Description:

    This routine completes all pended irps belonging
    to a FileObject specified. If FileObject is 0, all
    irps pended on the DeviceExtension are completed.

Arguments:

    DeviceExtension -
    FileObject      -
    Offline         - if TRUE, set DiskState to Offline

--*/
{
    KIRQL                   irql;
    PIRP                    irp;
    PLIST_ENTRY             listEntry;
    PLIST_ENTRY             nextEntry, head;

    CDLOGF(UNPEND, "CompletePendedIrps: Entry DevExt %p FileObject %p",
             DeviceExtension, FileObject );

    if (Offline) {

        PCLUS_DEVICE_EXTENSION  physicalDisk = DeviceExtension->PhysicalDevice->DeviceExtension;

        CDLOG( "CompletePendedIrps: StateOffline PhysDevObj %p",
            physicalDisk->DeviceObject);

        ClusDiskPrint(( 3,
                        "[ClusDisk] Pending IRPS: Offline device %p \n",
                        physicalDisk->DeviceObject ));

        DeviceExtension->DiskState = DiskOffline;
        DeviceExtension->ReserveTimer = 0;
        // physicalDisk->DiskState = DiskOffline;
        OFFLINE_DISK( physicalDisk );
        physicalDisk->ReserveTimer = 0;

    }

    IoAcquireCancelSpinLock( &irql );
    KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);

    head = &DeviceExtension->WaitingIoctls;

    for (listEntry = head->Flink; listEntry != head; listEntry = nextEntry) {
        nextEntry = listEntry->Flink;

        irp = CONTAINING_RECORD( listEntry,
                                 IRP,
                                 Tail.Overlay.ListEntry );

        if ( FileObject == NULL ||
             IoGetCurrentIrpStackLocation(irp)->FileObject == FileObject )
        {
            CDLOG( "CompletePendedIrps: CompleteIrp %p", irp );
            RemoveEntryList( listEntry );
            ClusDiskCompletePendingRequest(irp, STATUS_SUCCESS, DeviceExtension);
        }
    }

    KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
    IoReleaseCancelSpinLock( irql );

    CDLOGF(UNPEND, "CompletePendedIrps: Exit DevExt %p FileObj %p",
            DeviceExtension, FileObject );
}



NTSTATUS
ClusDiskCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine services cleanup commands. It deactivates the reservation
    threads on the device object, and takes the device offline.

Arguments:

    DeviceObject - Pointer to the device object on which the irp was received.
    Irp          - The IRP.

Return Value:

    NT Status

Notes:

    We don't release the reservations here, since the process may have
    failed and might be restarted. Make the remote system go through full
    arbitration if needed.

--*/

{
    NTSTATUS                status;
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDisk;
    PDEVICE_OBJECT          targetDeviceObject;
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation(Irp);
    KIRQL                   irql;

    BOOLEAN                 phyDiskRemLockAvail = FALSE;

    CDLOGF(CLEANUP,"ClusDiskCleanup: Entry DO %p", DeviceObject );

    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Make sure the device attach completed.
    //
    status = WaitForAttachCompletion( deviceExtension,
                                      TRUE,              // Wait
                                      TRUE );            // Also check physical device
    if ( !NT_SUCCESS( status ) ) {
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Signal all waiting Irp's on the physical device extension.
    //
    ClusDiskCompletePendedIrps(
        deviceExtension,
        irpStack->FileObject,
        /* offline => */ FALSE);

    if ( (deviceExtension->BusType == RootBus) &&
         (irpStack->FileObject->FsContext) ) {

        CDLOG("ClusDiskCleanup: StopReserve DO %p", DeviceObject );

        targetDeviceObject = (PDEVICE_OBJECT)irpStack->FileObject->FsContext;
        irpStack->FileObject->FsContext = NULL;
        physicalDisk = targetDeviceObject->DeviceExtension;

        status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
        if ( !NT_SUCCESS(status) ) {
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
        }

        phyDiskRemLockAvail = TRUE;

        //
        // 2000/02/05: stevedz - RemoveLocks should resolve this problem.
        //
        // The following "if" only reduces the chances of AV to occur, not
        // eliminates it completely. TargetDeviceObject is zeroed out by our PnP
        // handler when the device is removed
        //
        if (physicalDisk->TargetDeviceObject == NULL) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] Part0 object %p got deleted. Skip the dismount\n", targetDeviceObject));

            KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
            DisableHaltProcessing( &irql );
            KeReleaseSpinLock(&ClusDiskSpinLock, irql);
            goto skip_it;
        }

        ACQUIRE_SHARED( &ClusDiskDeviceListLock );

#if 0   // Always get volume handles...
        //
        // Capture handles for the volumes before offlining the device
        //
        if ( physicalDisk->DiskState == DiskOnline ) {
#endif
            ProcessDelayedWorkSynchronous( targetDeviceObject, ClusDiskpOpenFileHandles, NULL );
#if 0   // Always get volume handles...
        }
#endif

        ASSERT_RESERVES_STOPPED( physicalDisk );
        // physicalDisk->DiskState = DiskOffline;
        OFFLINE_DISK( physicalDisk );

        KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
        physicalDisk->ReserveTimer = 0;
        DisableHaltProcessing( &irql );
        KeReleaseSpinLock(&ClusDiskSpinLock, irql);

        RELEASE_SHARED( &ClusDiskDeviceListLock );

        ClusDiskPrint(( 3,
                        "[ClusDisk] Cleanup: Signature %08X (device %p) now marked offline \n",
                        physicalDisk->Signature,
                        physicalDisk->DeviceObject ));

        CDLOG( "ClusDiskCleanup: LastWrite %!datetime!",
           physicalDisk->LastWriteTime.QuadPart );

        physicalDisk->ReserveTimer = 0;
        ReleaseScsiDevice( physicalDisk );

        ClusDiskPrint((3,
                       "[ClusDisk] Cleanup, stop reservations on signature %lx, disk state %s \n",
                       physicalDisk->Signature,
                       DiskStateToString(physicalDisk->DiskState) ));

        //
        // We need to release all pended irps immediately,
        // w/o relying on worker thread to do it for us.
        //
        ClusDiskOfflineEntireDisk( targetDeviceObject );

        //
        // We must use a worker item to do this work.
        //
        //status = ClusDiskOfflineDevice( targetDeviceObject );

        if ( !KeReadStateEvent( &physicalDisk->Event ) ) {

            CDLOG("ClusDiskCleanup: WorkerIsStillRunning DO %p", DeviceObject );

        } else {

#if 0
            //
            // Acquire the RemoveLock for the target device object one more time.  Since
            // we are queuing a work item, we don't know when the ClusDiskDismountVolumes will
            // run.  When it does run, the RemoveLock will be released.
            //

            status = AcquireRemoveLock( &physicalDisk->RemoveLock, physicalDisk);
            if ( !NT_SUCCESS(status) ) {

                // Skip this device.
                goto skip_it;
            }
#endif

            KeClearEvent( &physicalDisk->Event );
            ClusDiskPrint(( 3,
                            "[ClusDisk] Cleanup: ClearEvent (%p)\n", &physicalDisk->Event));

            //
            // Keep the device object around
            //
            ObReferenceObject( targetDeviceObject );

            //
            // ClusDiskDismountVolumes will always run as a worker thread.
            //

            ClusDiskDismountVolumes( targetDeviceObject,
                                     FALSE );                   // Don't release the RemoveLock

        }

skip_it:

        CDLOG( "RootCtl: DecRef DO %p", targetDeviceObject );
        ObDereferenceObject( targetDeviceObject );
    }

    CDLOGF(CLEANUP,"ClusDiskCleanup: Exit DO %p", DeviceObject );

    if (phyDiskRemLockAvail) {
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
    }

    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);

} // ClusDiskCleanup


NTSTATUS
ClusDiskOfflineEntireDisk(
    IN PDEVICE_OBJECT Part0DeviceObject
    )
/*++

Routine Description:

    Complete all pended irps on the disk and all its volumes and
    sets the state to offline.

Arguments:

    Part0DeviceObject - the device to take offline.

Return Value:

    NTSTATUS for the request.

--*/
{
    PCLUS_DEVICE_EXTENSION  Part0Extension = Part0DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  deviceExtension;
    PDEVICE_OBJECT          deviceObject;

    CDLOG( "OfflineEntireDisk: Entry DO %p", Part0DeviceObject );

    ASSERT(Part0DeviceObject == Part0Extension->PhysicalDevice);
    //
    // Signal all waiting Irp's on the physical device extension.
    //
    ClusDiskCompletePendedIrps(
        Part0Extension,
        /* FileObject => */ NULL,
        /* offline => */ TRUE);

    //
    // We also need to complete all the irps on all the volumes belonging to this disk
    //
    ACQUIRE_SHARED( &ClusDiskDeviceListLock );

    //
    // Get the first DeviceObject in the driver list
    //
    deviceObject = Part0DeviceObject->DriverObject->DeviceObject;

    // First release all pended irps and set the volume state to offline

    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        if ( deviceExtension->PhysicalDevice == Part0DeviceObject &&
             deviceObject != Part0DeviceObject) // not P0
        {
            ClusDiskCompletePendedIrps(
                deviceExtension,
                /* FileObject => */ NULL,
                /* Offline =>    */ TRUE);

        }
        deviceObject = deviceObject->NextDevice;
    }

    RELEASE_SHARED( &ClusDiskDeviceListLock );
    CDLOG( "OfflineEntireDisk: Exit DO %p", Part0DeviceObject );

    return STATUS_SUCCESS;
} // ClusDiskOfflineEntireDisk //



NTSTATUS
ClusDiskDismountVolumes(
    IN PDEVICE_OBJECT Part0DeviceObject,
    IN BOOLEAN RelRemLock
    )

/*++

Routine Description:

    Dismount the file systems on a all volumes belonging to Part0DO.

    The RemoveLock for Part0DeviceObject must be acquired before this
    routine runs.

    The routine that does the lock and dismount must ALWAYS run as a work item
    to prevent deadlock with pnp threads.

Arguments:

    Part0DeviceObject - the device to take offline.

Return Value:

    NTSTATUS for the request.

--*/

{
    PCLUS_DEVICE_EXTENSION  Part0Extension = Part0DeviceObject->DeviceExtension;
    PVOID                   oldArray;
    PREPLACE_CONTEXT        context = NULL;

    NTSTATUS    status;

    CDLOG( "ClusDiskDismountVolumes: Entry %p", Part0DeviceObject );

    //
    // We assume that DeviceObject is P0
    //

    ASSERT(Part0DeviceObject == Part0Extension->PhysicalDevice);

    //
    // If the current volume handle array is NULL, we don't need to do anything.
    //

    oldArray = InterlockedCompareExchangePointer( (VOID*)&Part0Extension->VolumeHandles,
                                                  NULL,
                                                  NULL );

    if ( NULL == oldArray ) {
        CDLOG( "ClusDiskDismountVolumes: HandleArray is NULL, exiting" );

        KeSetEvent( &Part0Extension->Event, 0, FALSE );
        if ( RelRemLock ) {
            ReleaseRemoveLock(&Part0Extension->RemoveLock, Part0Extension);
        }
        ObDereferenceObject( Part0DeviceObject );

        goto FnExit;
    }

    //
    // Since this thread is going away, we have to allocate the replace context
    // and let the worker routine free it.
    //

    context = ExAllocatePool( NonPagedPool, sizeof(REPLACE_CONTEXT) );

    if ( !context ) {
        CDLOG( "ClusDiskDismountVolumes: Unable to allocate REPLACE_CONTEXT struture" );

        KeSetEvent( &Part0Extension->Event, 0, FALSE );
        if ( RelRemLock ) {
            ReleaseRemoveLock(&Part0Extension->RemoveLock, Part0Extension);
        }
        ObDereferenceObject( Part0DeviceObject );

        goto FnExit;
    }

    RtlZeroMemory( context, sizeof(REPLACE_CONTEXT) );

    context->DeviceExtension    = Part0Extension;
    context->NewValue           = NULL;     // clear the field
    context->Flags              = DO_DISMOUNT | CLEANUP_STORAGE | SET_PART0_EVENT ;

    if ( RelRemLock ) {
        context->Flags |= RELEASE_REMOVE_LOCK;
    }

    status = ProcessDelayedWorkAsynchronous( Part0DeviceObject, ClusDiskpReplaceHandleArray, context );

    if ( !NT_SUCCESS(status) ) {

        //
        // Context is freed in async routine whether it ran or not.
        //

        KeSetEvent( &Part0Extension->Event, 0, FALSE );
        if ( RelRemLock ) {
            ReleaseRemoveLock(&Part0Extension->RemoveLock, Part0Extension);
        }
        ObDereferenceObject( Part0DeviceObject );
    }

    //
    // We released the RemoveLock in ClusDiskpReplaceHandleArray.
    //
    //  ReleaseRemoveLock(&Part0Extension->RemoveLock, Part0Extension);

FnExit:

    CDLOG( "ClusDiskDismountVolumes: Exit DO %p", Part0DeviceObject );

    return STATUS_SUCCESS;

} // ClusDiskDismountVolumes



NTSTATUS
ClusDiskDismountDevice(
    IN ULONG    DiskNumber,
    IN BOOLEAN  ForceDismount
    )

/*++

Routine Description:

    Dismount the file systems on the specified disk

Arguments:

    DiskNumber - number of the disk on which to dismount all FSs.

    ForceDismount - TRUE if dismount should always take place (ignore VPB)

Return Value:

    NTSTATUS for the request.

--*/

{
    NTSTATUS                    status;
    ULONG                       partIndex;
    WCHAR                       partitionNameBuffer[MAX_PARTITION_NAME_LENGTH];
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo;
    PPARTITION_INFORMATION_EX       partitionInfo;
    UNICODE_STRING              targetDeviceName;
    PDEVICE_OBJECT              targetDevice = NULL;
    KIRQL                       irql;

    CDLOG( "ClusDiskDismountDevice: Entry DiskNumber %d", DiskNumber );

    ClusDiskPrint(( 3,
                    "[ClusDisk] DismountDevice: disknum %08X \n",
                    DiskNumber ));

    irql = KeGetCurrentIrql();
    if ( PASSIVE_LEVEL != irql ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] ClusDiskDismountDevice: Invalid IRQL %d \n", irql ));
        CDLOG( "DismountDevice: Invalid IRQL %d ", irql );
        ASSERT( FALSE );
        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    //
    // Dismount the file system on each partition.
    //
    status = ClusDiskGetTargetDevice(DiskNumber,
                                     0,
                                     &targetDevice,
                                     &targetDeviceName,
                                     &driveLayoutInfo,
                                     NULL,
                                     FALSE );

    FREE_DEVICE_NAME_BUFFER( targetDeviceName );

    if ( !NT_SUCCESS(status) ) {
        goto FnExit;
    }

    //
    // Dismount the partition zero device object.
    //
    //status = DismountPartition( DiskNumber, 0 );

    if ( driveLayoutInfo != NULL ) {

        if ( PARTITION_STYLE_MBR != driveLayoutInfo->PartitionStyle ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] DismountDevice: skipping non-MBR disk \n" ));
            CDLOG( "ClusDiskDismountDevice: skipping non-MBR disk" );
            status = STATUS_DEVICE_OFF_LINE;

            FREE_AND_NULL_PTR( driveLayoutInfo );
            goto FnExit;
        }

        for ( partIndex = 0;
              partIndex < driveLayoutInfo->PartitionCount;
              partIndex++ )
        {

            partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

            //
            // Make sure this is a valid partition.
            //
            if ( !partitionInfo->Mbr.RecognizedPartition ||
                 partitionInfo->PartitionNumber == 0 )
            {
                continue;
            }

            //
            // Create device name for the physical disk.
            //

            if ( FAILED( StringCchPrintfW( partitionNameBuffer,
                                           RTL_NUMBER_OF(partitionNameBuffer),
                                           DEVICE_PARTITION_NAME,
                                           DiskNumber,
                                           partitionInfo->PartitionNumber ) ) ) {
                continue;
            }

            WCSLEN_ASSERT( partitionNameBuffer );

            DEREFERENCE_OBJECT( targetDevice );

            status = ClusDiskGetTargetDevice( DiskNumber,
                                              partitionInfo->PartitionNumber,
                                              &targetDevice,
                                              &targetDeviceName,
                                              NULL,
                                              NULL,
                                              FALSE );

            FREE_DEVICE_NAME_BUFFER( targetDeviceName );

            if ( ForceDismount || ( targetDevice && targetDevice->Vpb &&
                 (targetDevice->Vpb->Flags & VPB_MOUNTED) ) ) {

                status = DismountPartition( targetDevice,
                                            DiskNumber,
                                            partitionInfo->PartitionNumber);
            }
        }

        FREE_AND_NULL_PTR( driveLayoutInfo );
        status = STATUS_SUCCESS;

    } else {
        //
        // This should not have failed!
        //
        ClusDiskPrint((1,
                       "[ClusDisk] DismountDevice: Failed to read partition info for \\Device\\Harddisk%u.\n",
                       DiskNumber));
        status = STATUS_DEVICE_OFF_LINE;
    }

FnExit:

    DEREFERENCE_OBJECT( targetDevice );

    CDLOG( "ClusDiskDismountDevice: Exit DiskNumber %d status %!status!",
           DiskNumber,
           status );

    //
    // The target device should not have any reservations.
    //
    return(status);

} // ClusDiskDismountDevice



NTSTATUS
ClusDiskReAttachDevice(
    PDEVICE_OBJECT  DeviceObject
    )

/*++

Routine Description:

    Re-attach to a disk device with the signature specified if it is detached.

Arguments:

    DeviceObject - the device object for Partition0.

Return Value:

    NT Status

Notes:

    Dismount the file system if we do perform an attach.

--*/

{
    NTSTATUS                    status;
    PCLUS_DEVICE_EXTENSION      physicalExtension;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    UNICODE_STRING              signatureName;
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo;
    PPARTITION_INFORMATION_EX      partitionInfo;
    PDEVICE_OBJECT              deviceObject;

    POFFLINE_DISK_ENTRY         offlineList = NULL;
    POFFLINE_DISK_ENTRY         nextEntry;

    OBJECT_ATTRIBUTES           objectAttributes;
    IO_STATUS_BLOCK             ioStatus;

    ULONG                       partIndex;
    HANDLE                      fileHandle;

    WCHAR                       deviceNameBuffer[MAX_PARTITION_NAME_LENGTH];
    UNICODE_STRING              deviceName;

    KIRQL                       irql;

    CDLOG( "ClusDiskReAttachDevice: Entry DO %p", DeviceObject );

    physicalExtension = DeviceObject->DeviceExtension;

    ClusDiskPrint((3,
                   "[ClusDisk] ReAttach entry: signature %08X, disk state %s \n",
                   physicalExtension->Signature,
                   DiskStateToString( physicalExtension->DiskState ) ));

    if ( !physicalExtension->Detached ) {
        CDLOG( "ClusDiskReAttachDevice_Exit2 Detached == FALSE" );
        ClusDiskPrint((3,
                       "[ClusDisk] ReAttach: signature %08X, PerformReserves = %s, ReserveTimer = %u \n",
                       physicalExtension->Signature,
                       BoolToString( physicalExtension->PerformReserves ),
                       physicalExtension->ReserveTimer ));
        return(STATUS_SUCCESS);
    }

    //
    // Dismount the file systems!
    //
    status = ClusDiskDismountDevice( physicalExtension->DiskNumber, TRUE );

    //
    // Now add the signature to the signatures list!
    //

    //
    // Allocate buffer for Signatures registry key. So we can add
    // the signature.
    //
    status = ClusDiskInitRegistryString(
                                        &signatureName,
                                        CLUSDISK_SIGNATURE_KEYNAME,
                                        wcslen(CLUSDISK_SIGNATURE_KEYNAME)
                                        );
    if ( NT_SUCCESS(status) ) {
        //
        // Create the signature key under \Parameters\Signatures.
        //
        status = ClusDiskAddSignature(
                                      &signatureName,
                                      physicalExtension->Signature,
                                      FALSE
                                     );

        //
        // Now write the disk name.
        //
        ClusDiskWriteDiskInfo( physicalExtension->Signature,
                               physicalExtension->DiskNumber,
                               CLUSDISK_SIGNATURE_KEYNAME
                              );

        ExFreePool( signatureName.Buffer );
    }

    //
    // Now remove the signature from the available list!
    //

    //
    // Allocate buffer for AvailableDisks registry key. So we can
    // delete the disk signature.
    //
    status = ClusDiskInitRegistryString(
                                        &signatureName,
                                        CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                        wcslen(CLUSDISK_AVAILABLE_DISKS_KEYNAME)
                                        );
    if ( NT_SUCCESS(status) ) {
        //
        // Delete the signature key under \Parameters\AvailableDisks.
        //
        status = ClusDiskDeleteSignature(
                                      &signatureName,
                                      physicalExtension->Signature
                                     );
        ExFreePool( signatureName.Buffer );
    }

    //
    // Find all related device objects and mark them as being attached now,
    // and offline.
    //
    KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
    deviceObject = DeviceObject->DriverObject->DeviceObject;
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        if ( deviceExtension->Signature == physicalExtension->Signature ) {

            ClusDiskPrint((3,
                           "[ClusDisk] ReAttach, marking signature %08X offline, old state %s \n",
                           deviceExtension->Signature,
                           DiskStateToString( deviceExtension->DiskState ) ));

            deviceExtension->Detached = FALSE;
            deviceExtension->ReserveTimer = 0;
            deviceExtension->ReserveFailure = 0;

            // [stevedz 11/06/2000]  Fix NTFS corruption.
            // Change to mark disk offline, rather than online (as the comments above
            // originally indicated).  Marking the disk offline was commented out and
            // the code marked the disk online here.  Don't understand why we would
            // want to mark it online with no reserves running.

            //
            // Try to offline in sync thread after we drop the locks.
            //

            nextEntry = ExAllocatePool( NonPagedPool, sizeof( OFFLINE_DISK_ENTRY ) );

            if ( !nextEntry ) {
                // deviceExtension->DiskState = DiskOffline;
                OFFLINE_DISK( deviceExtension );
            } else {

                nextEntry->DeviceExtension = deviceExtension;
                ObReferenceObject( deviceExtension->DeviceObject );

                nextEntry->Next = offlineList;
                offlineList = nextEntry;
            }
        }
        CDLOG( "ClusDiskReAttachDevice: RelatedObject %p diskstate %!diskstate!",
               deviceObject,
               deviceExtension->DiskState );

        deviceObject = deviceObject->NextDevice;
    }
    KeReleaseSpinLock(&ClusDiskSpinLock, irql);

    while ( offlineList ) {
        nextEntry = offlineList->Next;
        deviceExtension = offlineList->DeviceExtension;
        OFFLINE_DISK( deviceExtension );
        ObDereferenceObject( deviceExtension->DeviceObject );
        ExFreePool( offlineList );
        offlineList = nextEntry;
    }
    //
    // Make sure we have clusdisk volume object attached to each partition.
    //

    SimpleDeviceIoControl( physicalExtension->TargetDeviceObject,
                           IOCTL_DISK_UPDATE_PROPERTIES,
                           NULL,
                           0,
                           NULL,
                           0 );

    driveLayoutInfo = ClusDiskGetPartitionInfo( physicalExtension );

    if ( driveLayoutInfo != NULL ) {

        ASSERT( driveLayoutInfo->Mbr.Signature == physicalExtension->Signature );

        for ( partIndex = 0;
              partIndex < driveLayoutInfo->PartitionCount;
              partIndex++ )
        {
            partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

            //
            // First make sure this is a valid partition.
            //
            if ( !partitionInfo->Mbr.RecognizedPartition ||
                 partitionInfo->PartitionNumber == 0 )
            {
                continue;
            }

            //
            // Try to open the clusdisk volume object.  If it exists,
            // continue checking partitions.  If it doesn't exist,
            // then create the clusdisk volume object.
            //

            if ( FAILED( StringCchPrintfW( deviceNameBuffer,
                                           RTL_NUMBER_OF(deviceNameBuffer),
                                           CLUSDISK_DEVICE_NAME,
                                           physicalExtension->DiskNumber,
                                           partitionInfo->PartitionNumber ) ) ) {
                continue;
            }

            WCSLEN_ASSERT( deviceNameBuffer );

            RtlInitUnicodeString( &deviceName, deviceNameBuffer );

            InitializeObjectAttributes( &objectAttributes,
                                        &deviceName,
                                        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                        NULL,
                                        NULL );

            fileHandle = NULL;
            status = ZwOpenFile( &fileHandle,
                                 FILE_READ_ATTRIBUTES,
                                 &objectAttributes,
                                 &ioStatus,
                                 0,
                                 FILE_NON_DIRECTORY_FILE );

            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint(( 3,
                                "[ClusDisk] ReAttach, open of device %ws failed %08X \n",
                                deviceNameBuffer,
                                status ));

                CreateVolumeObject( physicalExtension,
                                    physicalExtension->DiskNumber,
                                    partitionInfo->PartitionNumber,
                                    NULL );
                status = STATUS_SUCCESS;
            }

            if ( fileHandle ) {
                ZwClose( fileHandle );
            }

        }
        FREE_AND_NULL_PTR( driveLayoutInfo );
    } else {
        CDLOG( "ClusDiskReAttachDevice: FailedToReadPartitionInfo" );
    }

    CDLOG( "ClusDiskReAttachDevice: Exit status %!status!", status );
    return(status);

} // ClusDiskReAttachDevice



NTSTATUS
ClusDiskTryAttachDevice(
    ULONG          Signature,
    ULONG          NextDisk,
    PDRIVER_OBJECT DriverObject,
    BOOLEAN        InstallMode
    )

/*++

Routine Description:

    Attach to a disk device with the signature specified.

Arguments:

    Signature - the signature for the device to attach to.

    NextDisk - the start disk number.

    DriverObject - the driver object for our driver.

    InstallMode - Indicates whether the disk is being added as a disk
                  resource.

Return Value:

    NT Status

Notes:

    Dismount the file system for the given device - if it is mounted.

--*/

{
    NTSTATUS ntStatus;

    BOOLEAN stopProcessing = FALSE;

    CDLOG( "TryAttachDevice: Entry Sig %08x NextDisk %d",
           Signature,
           NextDisk );

    //
    // First just try to attach to the device with no bus resets.
    //
    ntStatus = ClusDiskAttachDevice(
                        Signature,
                        NextDisk,
                        DriverObject,
                        FALSE,
                        &stopProcessing,
                        InstallMode );

    if ( NT_SUCCESS(ntStatus) || stopProcessing ) {
        CDLOG( "TryAttachDevice: FirstTrySuccess" );
        goto exit_gracefully;
    }

    //
    // Second, try to attach after reset all busses at once.
    //
    ResetScsiBusses();

    ntStatus = ClusDiskAttachDevice(
                        Signature,
                        NextDisk,
                        DriverObject,
                        FALSE,
                        &stopProcessing,
                        InstallMode );

    if ( NT_SUCCESS(ntStatus) || stopProcessing ) {
        CDLOG( "TryAttachDevice: SecondTrySuccess" );
        goto exit_gracefully;
    }

    //
    // Lastly, try to attach with a bus reset after each failure.
    //
    ntStatus = ClusDiskAttachDevice(
                        Signature,
                        NextDisk,
                        DriverObject,
                        TRUE,
                        &stopProcessing,
                        InstallMode );

exit_gracefully:

    CDLOG( "TryAttachDevice: Exit sig %08x => %!status!",
           Signature,
           ntStatus );

    return ntStatus;

} // ClusDiskTryAttachDevice



NTSTATUS
ClusDiskAttachDevice(
    ULONG          Signature,
    ULONG          NextDisk,
    PDRIVER_OBJECT DriverObject,
    BOOLEAN        Reset,
    BOOLEAN        *StopProcessing,
    BOOLEAN        InstallMode
    )

/*++

Routine Description:

    Attach to a disk device with the signature specified.

Arguments:

    Signature - the signature for the device to attach to.

    NextDisk - the start disk number.

    DriverObject - the driver object for our driver.

    Reset - Indicates whether bus reset should be performed on each I/O

    StopProcessing - Indicates whether to stop trying to attach.  If FALSE,
                     we will try a bus reset between attach attempts.

    InstallMode - Indicates whether the disk is being added as a disk
                  resource.

Return Value:

    NT Status

Notes:

    Dismount the file system for the given device - if it is mounted.

--*/

{
    NTSTATUS                    status;
    NTSTATUS                    finalStatus = STATUS_NO_SUCH_DEVICE;
    UNICODE_STRING              targetDeviceName;
    ULONG                       diskNumber;
    ULONG                       partIndex;
    PCONFIGURATION_INFORMATION  configurationInformation;
    PDEVICE_OBJECT              attachedTargetDevice;
    PDEVICE_OBJECT              physicalDevice;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    PCLUS_DEVICE_EXTENSION      zeroExtension;
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo;
    PPARTITION_INFORMATION_EX       partitionInfo;
    UNICODE_STRING              signatureName;
    SCSI_ADDRESS                scsiAddress;
    ULONG                       busType;
    ULONG                       diskCount;
    ULONG                       skipCount;
    PDEVICE_OBJECT              targetDevice = NULL;
    UNICODE_STRING              clusdiskDeviceName;
    WCHAR                       clusdiskDeviceBuffer[MAX_CLUSDISK_DEVICE_NAME_LENGTH];
    KIRQL                       irql;

    CDLOG( "ClusDiskAttachDevice: Entry sig %08x  nextdisk %d  reset %!bool!  install %!bool!",
           Signature,
           NextDisk,
           Reset,
           InstallMode );

    ClusDiskPrint(( 3,
                    "[ClusDisk] AttachDevice: Trying to attach to signature %08X  reset = %u  install = %u \n",
                    Signature,
                    Reset,
                    InstallMode ));

    *StopProcessing = FALSE;

    //
    // If we're already attached, then return success.
    //
    if ( AttachedDevice( Signature, &physicalDevice ) ) {

        CDLOG( "ClusDiskAttachDevice: AlreadyAttached DO %p", physicalDevice );

        deviceExtension = physicalDevice->DeviceExtension;

        if ( !deviceExtension ) {
            *StopProcessing = TRUE;
            return STATUS_DEVICE_REMOVED;
        }

#if CLUSTER_FREE_ASSERTS
        // This tells us whether there are volume objects created.
        if ( 0 == deviceExtension->LastPartitionNumber ) {
            DbgPrint( "[ClusDisk] ClusDiskAttachDevice: Reattach with LastPartitionNumber == 0 \n");
            // DbgBreakPoint();
        }
#endif

        status = AcquireRemoveLock( &deviceExtension->RemoveLock, deviceExtension );

        if ( !NT_SUCCESS(status) ) {
            *StopProcessing = TRUE;
            return status;
        }

        //
        // If any of the special file counts are nonzero, don't allow the attach.
        //

        if ( deviceExtension->PagingPathCount ||
             deviceExtension->HibernationPathCount ||
             deviceExtension->DumpPathCount ) {

            CDLOG( "ClusDiskAttachDevice: Exit, special file count nonzero %08X %08X %08X",
                    deviceExtension->PagingPathCount,
                    deviceExtension->HibernationPathCount,
                    deviceExtension->DumpPathCount );

            ClusDiskPrint(( 1,
                            "[ClusDisk] AttachDevice: Exit, special file count nonzero %08X %08X %08X \n",
                            deviceExtension->PagingPathCount,
                            deviceExtension->HibernationPathCount,
                            deviceExtension->DumpPathCount ));

            *StopProcessing = TRUE;
            ReleaseRemoveLock( &deviceExtension->RemoveLock, deviceExtension );
            return STATUS_INVALID_DEVICE_REQUEST;
        }


        status = ClusDiskReAttachDevice( physicalDevice );
        CDLOG( "ClusDiskAttachDevice: Exit1 %!status!", status );

        CDLOG( "ClusDiskInfo *** Phys DO %p  DevExt %p  DiskNum %d  Signature %08X  RemLock %p ***",
                physicalDevice,
                deviceExtension,
                deviceExtension->DiskNumber,
                deviceExtension->Signature,
                &deviceExtension->RemoveLock );

        ReleaseRemoveLock( &deviceExtension->RemoveLock, deviceExtension );
        return status;
    }

    //
    // Make sure the signature is NOT for the system device!
    //
    if ( SystemDiskSignature == Signature ) {
        CDLOG( "ClusDiskAttachDevice: Exit2 SystemDiskSig %08x",
               SystemDiskSignature );
        *StopProcessing = TRUE;
        return(STATUS_INVALID_PARAMETER);
    }

    //
    //
    // Get the configuration information.
    //

    configurationInformation = IoGetConfigurationInformation();
    diskCount = configurationInformation->DiskCount;

    CDLOG( "ClusDiskAttachDevice: diskCount %d ",
           diskCount );

    //
    // Find ALL disk devices. We will attempt to read the partition info
    // without attaching. We might already be attached and not know it.
    // So once we've performed a successful read, if the device is attached
    // we will know it by checking again.
    //

    for ( diskNumber = NextDisk, skipCount = 0;
          ( diskNumber < diskCount && skipCount < SKIP_COUNT_MAX );
          diskNumber++ ) {

        DEREFERENCE_OBJECT( targetDevice );

        //
        // Create device name for the physical disk.
        //
        status = ClusDiskGetTargetDevice( diskNumber,
                                          0,
                                          &targetDevice,
                                          &targetDeviceName,
                                          &driveLayoutInfo,
                                          &scsiAddress,
                                          Reset );

        FREE_DEVICE_NAME_BUFFER( targetDeviceName );

        if ( !NT_SUCCESS(status) ) {

            //
            // If the device doesn't exist, this is likely a hole in the
            // disk numbering.
            //

            if ( !targetDevice &&
                 ( STATUS_FILE_INVALID == status ||
                   STATUS_DEVICE_DOES_NOT_EXIST == status ||
                   STATUS_OBJECT_PATH_NOT_FOUND == status ) ) {
                skipCount++;
                diskCount++;
                ClusDiskPrint(( 3,
                                "[ClusDisk] ClusDiskAttachDevice: Adjust: skipCount %d   diskCount %d \n",
                                skipCount,
                                diskCount ));
                CDLOG( "ClusDiskAttachDevice: Adjust: skipCount %d   diskCount %d ",
                       skipCount,
                       diskCount );
            }

            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

        if ( driveLayoutInfo == NULL ) {
            continue;
        }

        if ( PARTITION_STYLE_MBR != driveLayoutInfo->PartitionStyle ) {
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

        if ( Signature != driveLayoutInfo->Mbr.Signature ) {
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

        skipCount = 0;      // Device found, reset skipCount

        busType = ScsiBus; // because of GetTargetDevice above!

        //
        // Create ClusDisk device object for partition 0, if we are not
        // already attached!
        //

        if ( ClusDiskAttached( targetDevice, diskNumber ) ) {
            physicalDevice = targetDevice;
            deviceExtension = physicalDevice->DeviceExtension;
            zeroExtension = deviceExtension;
            deviceExtension->Detached = FALSE;

            ClusDiskPrint((3,
                        "[ClusDisk] AttachDevice: We were already attached to device %p (disk %u), simply mark as attached.\n",
                        physicalDevice,
                        diskNumber));

            CDLOG( "ClusDiskAttachDevice: Previously attached to device %p (disk %u) signature %08X ",
                   physicalDevice,
                   diskNumber,
                   Signature );

            //
            // We offline all the volumes later.  For now, just mark the disk offline.
            //

            deviceExtension->DiskState = DiskOffline;

            //
            // Seen instances where the device extension signature is zero, but the entry
            // in the ClusDiskDeviceList contains a valid signature.  This causes a problem
            // if there is a detach and then we try to attach to the same device later.
            //
            // The issue is that the devExt->Sig can be zero if the drive layout couldn't
            // be read.  When we attach and the device object was previously created,
            // we don't update the devExt->Sig.  When we detach, ClusDiskDetachDevice
            // tries to find all the devices with devExt->Sig matching the detached
            // device.  When a matching signature is found, devExt->Detached is set
            // to TRUE.  Since some devExt->Sigs are zero (if drive layout couldn't be read
            // at the time the device object was created), they don't match the detaching
            // signature, and the devExt->Detached flag is still set to FALSE.
            //
            // Then when trying to attach to the same device later, ClusDiskAttachDevice
            // can see that we still have an entry in ClusDiskDeviceList, and then
            // ClusDiskReAttachDevice is called.  However, since the devExt->Detached flag
            // is still FALSE, ClusDiskReAttachDevice assumes we are still attached and
            // doesn't do anything except return success.
            //

            //
            // If Signature we are attaching to does not equal the devExt->Sig, write an
            // error to the WMI log, and update the devExt->Sig with the attaching Signature.
            //

            if ( Signature != deviceExtension->Signature ) {

                CDLOG( "ClusDiskAttachDevice: PreviouslyAttachedSignatureMismatch sig %08x devExtSig %08x",
                       Signature,
                       deviceExtension->Signature );

                ASSERT( deviceExtension->Signature == 0 );
                deviceExtension->Signature = Signature;
            }

        } else {

            //
            // Now create a Partition zero device object to attach to
            //

            if ( FAILED( StringCchPrintfW( clusdiskDeviceBuffer,
                                           RTL_NUMBER_OF(clusdiskDeviceBuffer),
                                           CLUSDISK_DEVICE_NAME,
                                           diskNumber,
                                           0 ) ) ) {
                FREE_AND_NULL_PTR( driveLayoutInfo );
                continue;
            }

            RtlInitUnicodeString( &clusdiskDeviceName, clusdiskDeviceBuffer );
            status = IoCreateDevice(DriverObject,
                                    sizeof(CLUS_DEVICE_EXTENSION),
                                    &clusdiskDeviceName,
                                    FILE_DEVICE_DISK,
                                    FILE_DEVICE_SECURE_OPEN,
                                    FALSE,
                                    &physicalDevice);

            if ( !NT_SUCCESS(status) ) {
                FREE_AND_NULL_PTR( driveLayoutInfo );
                ClusDiskPrint((
                        1,
                        "[ClusDisk] AttachDevice: Failed to create device for Drive%u. %08X\n",
                        diskNumber,
                        status));

                continue;
            }

            CDLOG( "ClusDiskAttachDevice: IoCreateDeviceP0 DO %p DiskNumber %d",
                   physicalDevice, diskNumber );

            physicalDevice->Flags |= DO_DIRECT_IO;

            //
            // Point device extension back at device object and remember
            // the disk number.
            //

            deviceExtension = physicalDevice->DeviceExtension;
            zeroExtension = deviceExtension;
            deviceExtension->DeviceObject = physicalDevice;
            deviceExtension->DiskNumber = diskNumber;
            deviceExtension->LastPartitionNumber = 0;
            deviceExtension->DriverObject = DriverObject;
            deviceExtension->Signature = Signature;
            deviceExtension->AttachValid = TRUE;
            deviceExtension->ReserveTimer = 0;
            deviceExtension->PerformReserves = TRUE;
            deviceExtension->ReserveFailure = 0;
            deviceExtension->Detached = TRUE;
            deviceExtension->OfflinePending = FALSE;
            deviceExtension->ScsiAddress = scsiAddress;
            deviceExtension->BusType = busType;
            InitializeListHead( &deviceExtension->WaitingIoctls );

            IoInitializeRemoveLock( &deviceExtension->RemoveLock, CLUSDISK_ALLOC_TAG, 0, 0 );

            //
            // Signal the worker thread running event.
            //
            KeInitializeEvent( &deviceExtension->Event, NotificationEvent, TRUE );

            ExInitializeWorkItem(&deviceExtension->WorkItem,
                              (PWORKER_THREAD_ROUTINE)ClusDiskReservationWorker,
                              (PVOID)deviceExtension );

            // Always set state to offline.
            //
            // We offline all the volumes later.  For now, just mark the disk offline.
            //
            deviceExtension->DiskState = DiskOffline;

            KeInitializeEvent( &deviceExtension->PagingPathCountEvent,
                               NotificationEvent, TRUE );
            deviceExtension->PagingPathCount = 0;
            deviceExtension->HibernationPathCount = 0;
            deviceExtension->DumpPathCount = 0;

            ExInitializeResourceLite( &deviceExtension->DriveLayoutLock );
            ExInitializeResourceLite( &deviceExtension->ReserveInfoLock );

            //
            // This is the physical device object.
            //
            ObReferenceObject( physicalDevice );
            deviceExtension->PhysicalDevice = physicalDevice;

            //
            // Attach to partition0. This call links the newly created
            // device to the target device, returning the target device object.
            // We may not want to stay attached for long... depending on
            // whether this is a device we're interested in.
            //

#if 0   // Why is this here?
            //
            // 2000/02/05: stevedz - Bug in FTDISK [note that we currently don't support FTDISK].
            // There seems to be a bug in FTDISK, where the DO_DEVICE_INITIALIZING gets
            // stuck when a new device is found during a RESCAN. We will unconditionally
            // clear this bit for any device we are about to attach to. We could check
            // if the device is an FTDISK device... but that might be work.
            //
            targetDevice->Flags &= ~DO_DEVICE_INITIALIZING;
#endif

            attachedTargetDevice = IoAttachDeviceToDeviceStack(physicalDevice,
                                                               targetDevice);
            ASSERT( attachedTargetDevice == targetDevice );

#if CLUSTER_FREE_ASSERTS && CLUSTER_STALL_THREAD
            DBG_STALL_THREAD( 2 );   // Defined only for debugging.
#endif

            if ( attachedTargetDevice == NULL ) {
                ClusDiskPrint((1,
                               "[ClusDisk] AttachDevice: Failed to attach to device Drive%u.\n",
                               diskNumber));

                FREE_AND_NULL_PTR( driveLayoutInfo );
                ExDeleteResourceLite( &deviceExtension->DriveLayoutLock );
                ExDeleteResourceLite( &deviceExtension->ReserveInfoLock );
                IoDeleteDevice(physicalDevice);
                continue;
            }

            deviceExtension->TargetDeviceObject = attachedTargetDevice;
            deviceExtension->Detached = FALSE;
            physicalDevice->Flags &= ~DO_DEVICE_INITIALIZING;

#if 0   // Can't have a FS on partition 0
            if ( targetDevice->Vpb ) {
                if ( targetDevice->Vpb->Flags & VPB_MOUNTED ) {

                    status = DismountPartition( targetDevice, diskNumber, 0 );

                    if ( !NT_SUCCESS( status )) {
                        ClusDiskPrint((1,
                                       "[ClusDisk] AttachDevice: dismount of %u/0 failed %08X\n",
                                       diskNumber, status));
                    }
                }
            }
#endif
        }

        CDLOG( "ClusDiskInfo *** Phys DO %p  DevExt %p  DiskNum %d  Signature %08X  RemLock %p ***",
                physicalDevice,
                deviceExtension,
                deviceExtension->DiskNumber,
                deviceExtension->Signature,
                &deviceExtension->RemoveLock );

        //
        // make sure we haven't attached to a file system. if so, something
        // whacky has occurred and consequently, we back what we just did
        //

        if (deviceExtension->TargetDeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {
            ClusDiskPrint((3,
                        "[ClusDisk] AttachDevice: We incorrectly attached our device %p to file system device %p \n",
                        physicalDevice,
                        deviceExtension->TargetDeviceObject));
            status = STATUS_INSUFFICIENT_RESOURCES;
            KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
            deviceExtension->Detached = TRUE;
            KeReleaseSpinLock(&ClusDiskSpinLock, irql);
            ExDeleteResourceLite( &deviceExtension->DriveLayoutLock );
            ExDeleteResourceLite( &deviceExtension->ReserveInfoLock );
            IoDetachDevice( deviceExtension->TargetDeviceObject );
            IoDeleteDevice( physicalDevice );
            FREE_AND_NULL_PTR( driveLayoutInfo );
            continue;
        }

        //
        // Propagate driver's alignment requirements and power flags.
        //

        physicalDevice->AlignmentRequirement =
            deviceExtension->TargetDeviceObject->AlignmentRequirement;

        physicalDevice->SectorSize =
            deviceExtension->TargetDeviceObject->SectorSize;

        //
        // The storage stack explicitly requires DO_POWER_PAGABLE to be
        // set in all filter drivers *unless* DO_POWER_INRUSH is set.
        // this is true even if the attached device doesn't set DO_POWER_PAGABLE.
        //
        if ( deviceExtension->TargetDeviceObject->Flags & DO_POWER_INRUSH) {
            physicalDevice->Flags |= DO_POWER_INRUSH;
        } else {
            physicalDevice->Flags |= DO_POWER_PAGABLE;
        }

        //
        // Add this device to our list of attached devices.
        //
        AddAttachedDevice( Signature, physicalDevice );

        //
        // Add the signature to the signatures list!
        //

        //
        // Allocate buffer for Signatures registry key. So we can add
        // the signature.
        //
        status = ClusDiskInitRegistryString(
                                            &signatureName,
                                            CLUSDISK_SIGNATURE_KEYNAME,
                                            wcslen(CLUSDISK_SIGNATURE_KEYNAME)
                                            );
        if ( NT_SUCCESS(status) ) {
            //
            // Create the signature key under \Parameters\Signatures.
            //
            status = ClusDiskAddSignature(
                                          &signatureName,
                                          Signature,
                                          FALSE
                                         );

            //
            // Now write the disk name.
            //
            ClusDiskWriteDiskInfo( Signature,
                                   deviceExtension->DiskNumber,
                                   CLUSDISK_SIGNATURE_KEYNAME
                                  );

            ExFreePool( signatureName.Buffer );
        }

        //
        // Remove the signature from the available list!
        //

        //
        // Allocate buffer for AvailableDisks registry key. So we can
        // delete the disk signature.
        //
        status = ClusDiskInitRegistryString(
                                        &signatureName,
                                        CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                        wcslen(CLUSDISK_AVAILABLE_DISKS_KEYNAME)
                                        );
        if ( NT_SUCCESS(status) ) {
            //
            // Delete the signature key under \Parameters\AvailableDisks.
            //
            status = ClusDiskDeleteSignature(
                                          &signatureName,
                                          Signature
                                         );
            ExFreePool( signatureName.Buffer );
        }

        //
        // During installation, we want to dismount and then mark the disk
        // offline.  The disk may have been in use before it was added
        // to the cluster, and if we offline first, we see "delayed
        // write" error messages.  During normal attach (not install), we
        // offline first, then dismount, to make sure no data is actually
        // written to the disk.
        //

        if ( InstallMode ) {

            //
            // Dismount all volumes on this disk.
            //

            ClusDiskDismountDevice( diskNumber, TRUE );

            //
            // Offline all volumes on this disk.
            //

            OFFLINE_DISK( zeroExtension );

        } else {

            //
            // Offline all volumes on this disk.
            //

            OFFLINE_DISK_PDO( zeroExtension );
            OFFLINE_DISK( zeroExtension );

            //
            // Dismount all volumes on this disk.
            //

            ClusDiskDismountDevice( diskNumber, TRUE );
        }

        //
        // Now enumerate the partitions on this device.
        //

        for (partIndex = 0;
             partIndex < driveLayoutInfo->PartitionCount;
             partIndex++)
        {

            partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

            //
            // Make sure that there really is a partition here.
            //

            if ( !partitionInfo->Mbr.RecognizedPartition ||
                 partitionInfo->PartitionNumber == 0 )
            {
                continue;
            }

            CreateVolumeObject( zeroExtension,
                                diskNumber,
                                partitionInfo->PartitionNumber,
                                NULL );
        }

        FREE_AND_NULL_PTR( driveLayoutInfo );
        finalStatus = STATUS_SUCCESS;
        break;
    }

    DEREFERENCE_OBJECT( targetDevice );

    CDLOG( "ClusDiskAttachDevice: Exit status %!status!", finalStatus );

    return(finalStatus);

} // ClusDiskAttachDevice



NTSTATUS
ClusDiskDetachDevice(
    ULONG          Signature,
    PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Detach from a disk device with the signature specified.

Arguments:

    Signature - the signature for the device to detach from.

    DriverObject - the driver object for our device.

Return Value:

    NT Status

Notes:

    We have to be careful with the partition0 devices. RAW doesn't support
    dismount, so it is not clear that we can actually delete those device
    objects, since they could be cached by FileSystems like RAW!

--*/

{
    NTSTATUS                status;
    PDEVICE_LIST_ENTRY      deviceEntry;
    PCLUS_DEVICE_EXTENSION  deviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDeviceExtension;
    PDEVICE_OBJECT          deviceObject = DriverObject->DeviceObject;
    UNICODE_STRING          signatureName;
    UNICODE_STRING          availableName;
    KIRQL                   irql;
    PCLUS_DEVICE_EXTENSION  foundExtension = NULL;
    PLIST_ENTRY             listEntry;
    PIRP                    irp;

    //
    // Find our device entry.
    //

    // 2000/02/05: stevedz - added synchronization.

    ACQUIRE_SHARED( &ClusDiskDeviceListLock );

    deviceEntry = ClusDiskDeviceList;
    while ( deviceEntry ) {
        if ( deviceEntry->Signature == Signature ) {
            break;
        }
        deviceEntry = deviceEntry->Next;
    }

    if ( (deviceEntry == NULL) ||
         !deviceEntry->Attached ) {
        if ( deviceEntry ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] DetachDevice: Failed to detach signature = %lx, attached = %lx\n",
                    Signature, deviceEntry->Attached ));
        } else {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] DetachDevice: Failed to detach signature = %lx\n",
                    Signature ));

        }

        RELEASE_SHARED( &ClusDiskDeviceListLock );

        goto DeleteDiskSignature;
    }

    //
    // Now find all devices that we are attached to with this signature.
    //
    KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        //
        // Only disable devices with our signature, but
        // Don't remove the root device...
        //
        if ( (deviceExtension->Signature == Signature) ) {
            //
            // Remember one found extension - it doesn't matter which one.
            //
            foundExtension = deviceExtension;

            //
            // Detach from the target device. This only requires marking
            // the device object as detached!
            //
            deviceExtension->Detached = TRUE;

            //
            // We want to make sure reserves are stopped because the disk is
            // not going to be controlled by the cluster any longer.
            //
            ASSERT_RESERVES_STOPPED( deviceExtension );

            //
            // Make this device available again.
            //
            // deviceExtension->DiskState = DiskOnline;
            ONLINE_DISK( deviceExtension );

            ClusDiskPrint(( 3,
                            "[ClusDisk] DetachDevice: Marking signature = %lx online \n",
                            Signature ));

        }
        deviceObject = deviceObject->NextDevice;
    }
    KeReleaseSpinLock(&ClusDiskSpinLock, irql);
    RELEASE_SHARED( &ClusDiskDeviceListLock );

    //
    // Delete all drive letters for this disk signature, and assign letters
    // to the correct device name.
    //
    if ( foundExtension ) {

        physicalDeviceExtension = foundExtension->PhysicalDevice->DeviceExtension;

        //
        // Signal all waiting Irp's on the physical device extension.
        //
        IoAcquireCancelSpinLock( &irql );
        KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);
        while ( !IsListEmpty(&physicalDeviceExtension->WaitingIoctls) ) {
            listEntry = RemoveHeadList(&physicalDeviceExtension->WaitingIoctls);
            irp = CONTAINING_RECORD( listEntry,
                                     IRP,
                                     Tail.Overlay.ListEntry );
            ClusDiskCompletePendingRequest(irp, STATUS_SUCCESS, physicalDeviceExtension);
        }
        KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
        IoReleaseCancelSpinLock( irql );
    }

DeleteDiskSignature:

    //
    // Allocate buffer for signatures registry key.
    //
    status = ClusDiskInitRegistryString(
                                        &signatureName,
                                        CLUSDISK_SIGNATURE_KEYNAME,
                                        wcslen(CLUSDISK_SIGNATURE_KEYNAME)
                                       );
    if ( !NT_SUCCESS(status) ) {
        return(status);
    }

    //
    // Allocate buffer for our list of available signatures,
    // and form the subkey string name.
    //
    status = ClusDiskInitRegistryString(
                                        &availableName,
                                        CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                        wcslen(CLUSDISK_AVAILABLE_DISKS_KEYNAME)
                                       );
    if ( !NT_SUCCESS(status) ) {
        ExFreePool( signatureName.Buffer );
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Always - remove signature from signature list.
    //
    status = ClusDiskDeleteSignature(
                                     &signatureName,
                                     Signature
                                    );

    //
    // always add signature to available list. This will handle the case
    // where the disk signature was not found by this system in a previous
    // scan of the disks.
    //

    ClusDiskPrint((3,
                   "[ClusDisk] DetachDevice: adding disk %08X to available disks list\n",
                   Signature));

    status = ClusDiskAddSignature(
                                  &availableName,
                                  Signature,
                                  TRUE
                                 );

    ExFreePool( signatureName.Buffer );
    ExFreePool( availableName.Buffer );

    return(STATUS_SUCCESS);

} // ClusDiskDetachDevice



NTSTATUS
ClusDiskRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the driver entry point for read and write requests
    to disks to which the clusdisk driver has attached.
    This driver collects statistics and then sets a completion
    routine so that it can collect additional information when
    the request completes. Then it calls the next driver below
    it.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDisk =
                               deviceExtension->PhysicalDevice->DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS            status;

    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Return error if device is our root device.
    //
    if ( deviceExtension->BusType == RootBus ) {
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    //
    // Make sure the device attach completed.
    //
    status = WaitForAttachCompletion( deviceExtension,
                                      FALSE,            // No wait
                                      TRUE );           // Also check physical device
    if ( !NT_SUCCESS( status ) ) {
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Return error if disk is not Online.
    // ReclaimInProgress means we are trying to create the volume objects
    // and reads should pass through (but not writes).
    //

    if ( physicalDisk->DiskState != DiskOnline )
    {
        CDLOG( "ClusDiskRead(%p): Irp %p Reject len %d offset %I64x",
               DeviceObject,
               Irp,
               currentIrpStack->Parameters.Read.Length,
               currentIrpStack->Parameters.Read.ByteOffset.QuadPart
               );

        ClusDiskPrint((
                3,
                "[ClusDisk] ClusDiskRead: ReadReject IRP %p for signature %p (%p) (PD) \n",
                Irp,
                physicalDisk->Signature,
                physicalDisk));

        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_OFF_LINE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_DEVICE_OFF_LINE);
    }

    CDLOGF(READ,"ClusDiskRead(%p): Irp %p Read len %d offset %I64x",
              DeviceObject,
              Irp,
              currentIrpStack->Parameters.Read.Length,
              currentIrpStack->Parameters.Read.ByteOffset.QuadPart );

//
// Until we start doing something in the completion routine, just
// skip this driver. In the future, we might want to report errors
// back to the cluster software... but that could get tricky, since some
// requests should fail, but that is expected.
//
#if 0
    //
    // Copy current stack to next stack.
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // Set completion routine callback.
    //

    IoSetCompletionRoutine(Irp,
                           ClusDiskIoCompletion,
                           NULL,    // Completion context
                           TRUE,    // Invoke on success
                           TRUE,    // Invoke on error
                           TRUE);   // Invoke on cancel
#else
    //
    // Set current stack back one.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

#endif

    //
    // Return the results of the call to the disk driver.
    //

    return IoCallDriver(deviceExtension->TargetDeviceObject,
                        Irp);

} // ClusDiskRead



NTSTATUS
ClusDiskWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the driver entry point for read and write requests
    to disks to which the clusdisk driver has attached.
    This driver collects statistics and then sets a completion
    routine so that it can collect additional information when
    the request completes. Then it calls the next driver below
    it.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDisk =
                               deviceExtension->PhysicalDevice->DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    KIRQL              irql;

    NTSTATUS            status;

    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Return error if device is our root device.
    //
    if ( deviceExtension->BusType == RootBus ) {
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    //
    // Make sure the device attach completed.
    //
    status = WaitForAttachCompletion( deviceExtension,
                                      FALSE,            // No wait
                                      TRUE );           // Also check physical device
    if ( !NT_SUCCESS( status ) ) {
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Return error if disk is not Online.
    //

    if ( physicalDisk->DiskState != DiskOnline ) {
        CDLOG( "ClusDiskWrite(%p) Reject irp %p", DeviceObject, Irp );
        ClusDiskPrint((
                3,
                "[ClusDisk] ClusDiskWrite: WriteReject IRP %p for signature %p (%p) (PD) \n",
                Irp,
                physicalDisk->Signature,
                physicalDisk));
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_OFF_LINE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_DEVICE_OFF_LINE);
    }

    //
    // Trace writes to the first few sectors
    //
    CDLOGF(WRITE, "ClusDiskWrite(%p) Irp %p Write len %d offset %I64x",
              DeviceObject,
              Irp,
              currentIrpStack->Parameters.Write.Length,
              currentIrpStack->Parameters.Write.ByteOffset.QuadPart );

    KeQuerySystemTime( &physicalDisk->LastWriteTime );

//
// Until we start doing something in the completion routine, just
// skip this driver. In the future, we might want to report errors
// back to the cluster software... but that could get tricky, since some
// requests should fail, but that is expected.
//
#if 0
    //
    // Copy current stack to next stack.
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // Set completion routine callback.
    //

    IoSetCompletionRoutine(Irp,
                           ClusDiskIoCompletion,
                           NULL,    // Completion context
                           TRUE,    // Invoke on success
                           TRUE,    // Invoke on error
                           TRUE);   // Invoke on cancel
#else
    //
    // Set current stack back one.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

#endif

    //
    // Return the results of the call to the disk driver.
    //

    return IoCallDriver(deviceExtension->TargetDeviceObject,
                        Irp);

} // ClusDiskWrite



NTSTATUS
ClusDiskIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )

/*++

Routine Description:

    This routine will get control from the system at the completion of an IRP.
    It will calculate the difference between the time the IRP was started
    and the current time, and decrement the queue depth.

Arguments:

    DeviceObject - for the IRP.
    Irp          - The I/O request that just completed.
    Context      - Not used.

Return Value:

    The IRP status.

--*/

{
    PCLUS_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION physicalDisk = deviceExtension->PhysicalDevice->DeviceExtension;

    UNREFERENCED_PARAMETER(Context);

    CDLOGF(WRITE, "ClusDiskIoCompletion: CompletedIrp DevObj %p Irp %p",
              DeviceObject,
              Irp );

    if ( physicalDisk->DiskState != DiskOnline ) {
        CDLOGF(WRITE,"ClusDiskIoCompletion: CompletedIrpNotOnline DevObj %p Irp %p %!diskstate!",
                  DeviceObject,
                  Irp,
                  physicalDisk->DiskState );
        CDLOG( "ClusDiskIoCompletion: CompletedIrpNotOnline2 DevObj %p Irp %p %!diskstate!",
                DeviceObject,
                Irp,
                physicalDisk->DiskState );
    }

    ReleaseRemoveLock( &deviceExtension->RemoveLock, Irp );
    ReleaseRemoveLock( &physicalDisk->RemoveLock, Irp );

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }
    return STATUS_SUCCESS;


} // ClusDiskIoCompletion

#if 0

NTSTATUS
ClusDiskUpdateDriveLayout(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called after an IOCTL to set drive layout completes.
    It attempts to attach to each partition in the system. If it fails
    then it is assumed that clusdisk has already attached.  After
    the attach the new device extension is set up to point to the
    device extension representing the physical disk.  There are no
    data items or other pointers that need to be cleaned up on a
    per partition basis.

Arguments:

    PhysicalDeviceObject - Pointer to device object for the disk just changed.
    Irp          - IRP involved.

Return Value:

    NT Status

--*/

{
    PCLUS_DEVICE_EXTENSION physicalExtension = PhysicalDeviceObject->DeviceExtension;
    ULONG             partitionNumber = physicalExtension->LastPartitionNumber;
    PDEVICE_OBJECT    targetObject;
    PDEVICE_OBJECT    deviceObject;
    PCLUS_DEVICE_EXTENSION deviceExtension;
    WCHAR             ntDeviceName[MAX_PARTITION_NAME_LENGTH];
    STRING            ntString;
    UNICODE_STRING    ntUnicodeString;
    PFILE_OBJECT      fileObject;
    NTSTATUS          status;
    KIRQL             irql;

    //
    // Attach to any new partitions created by the set layout call.
    //

    do {

        //
        // Get first/next partition.  Already attached to the disk,
        // otherwise control would not have been passed to this driver
        // on the device I/O control.
        //

        partitionNumber++;

        //
        // Create unicode NT device name.
        //

        if ( FAILED( StringCchPrintfW( ntDeviceName,
                                       RTL_NUMBER_OF(ntDeviceName),
                                       DEVICE_PARTITION_NAME,
                                       physicalExtension->DiskNumber,
                                       partitionNumber ) ) ) {
            continue;
        }
        WCSLEN_ASSERT( ntDeviceName );

        RtlInitUnicodeString(&ntUnicodeString, ntDeviceName);

        //
        // Get target device object.
        //

        status = IoGetDeviceObjectPointer(&ntUnicodeString,
                                          FILE_READ_ATTRIBUTES,
                                          &fileObject,
                                          &targetObject);

        //
        // If this fails then it is because there is no such device
        // which signals completion.
        //

        if ( !NT_SUCCESS(status) ) {
            break;
        }

        //
        // Dereference file object as these are the rules.
        //

        ObDereferenceObject(fileObject);

        //
        // Check if this device is already mounted.
        //

        if ( (targetObject->Vpb &&
             (targetObject->Vpb->Flags & VPB_MOUNTED)) ) {

            //
            // Assume this device has already been attached.
            //

            continue;
        }

        //
        // Create device object for this partition.
        //

        status = IoCreateDevice(physicalExtension->DriverObject,
                                sizeof(CLUS_DEVICE_EXTENSION),
                                NULL, // XXXX
                                FILE_DEVICE_DISK,
                                FILE_DEVICE_SECURE_OPEN,
                                FALSE,
                                &deviceObject);

        if ( !NT_SUCCESS(status) ) {
            continue;
        }

        deviceObject->Flags |= DO_DIRECT_IO;

        //
        // Point device extension back at device object.
        //

        deviceExtension = deviceObject->DeviceExtension;
        deviceExtension->DeviceObject = deviceObject;

        //
        // Store pointer to physical device and disk/driver information.
        //
        ObReferenceObject( PhysicalDeviceObject );
        deviceExtension->PhysicalDevice = PhysicalDeviceObject;
        deviceExtension->DiskNumber = physicalExtension->DiskNumber;
        deviceExtension->DriverObject = physicalExtension->DriverObject;
        deviceExtension->BusType = physicalExtension->BusType;
        deviceExtension->ReserveTimer = 0;
        deviceExtension->PerformReserves = FALSE;
        deviceExtension->ReserveFailure = 0;
        deviceExtension->Signature = physicalExtension->Signature;
        deviceExtension->Detached = TRUE;
        deviceExtension->OfflinePending = FALSE;
        InitializeListHead( &deviceExtension->WaitingIoctls );
        InitializeListHead( &deviceExtension->HoldIO );

        IoInitializeRemoveLock( &deviceExtension->RemoveLock, CLUSDISK_ALLOC_TAG, 0, 0 );

        //
        // Signal the worker thread running event.
        //
        KeInitializeEvent( &deviceExtension->Event, NotificationEvent, TRUE );

        KeInitializeEvent( &deviceExtension->PagingPathCountEvent,
                           NotificationEvent, TRUE );
        deviceExtension->PagingPathCount = 0;
        deviceExtension->HibernationPathCount = 0;
        deviceExtension->DumpPathCount = 0;

        ExInitializeResourceLite( &deviceExtension->DriveLayoutLock );
        ExInitializeResourceList( &deviceExtension->ReserveInfoLock );

        //
        // Update the highest partition number in partition zero
        // and store the same value in this new extension just to initialize
        // the field.
        //

        physicalExtension->LastPartitionNumber =
            deviceExtension->LastPartitionNumber = partitionNumber;

        //
        // Attach to the partition. This call links the newly created
        // device to the target device, returning the target device object.
        //
        status = IoAttachDevice(deviceObject,
                                &ntUnicodeString,
                                &deviceExtension->TargetDeviceObject);

        if ( (!NT_SUCCESS(status)) || (status == STATUS_OBJECT_NAME_EXISTS) ) {

            //
            // Assume this device is already attached.
            //
            ExDeleteResourceLite( &deviceExtension->DriveLayoutLock );
            ExDeleteResourceList( &deviceExtension->ReserveInfoLock );
            IoDeleteDevice(deviceObject);
        } else {

            //
            // Propagate driver's alignment requirements and power flags.
            //
            deviceExtension->Detached = FALSE;

            deviceObject->AlignmentRequirement =
                deviceExtension->TargetDeviceObject->AlignmentRequirement;

            deviceObject->SectorSize =
                deviceExtension->TargetDeviceObject->SectorSize;

            //
            // The storage stack explicitly requires DO_POWER_PAGABLE to be
            // set in all filter drivers *unless* DO_POWER_INRUSH is set.
            // this is true even if the attached device doesn't set DO_POWER_PAGABLE.
            //
            if ( deviceExtension->TargetDeviceObject->Flags & DO_POWER_INRUSH) {
                deviceObject->Flags |= DO_POWER_INRUSH;
            } else {
                deviceObject->Flags |= DO_POWER_PAGABLE;
            }

            deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        }
    } while (TRUE);

    return Irp->IoStatus.Status;

} // ClusDiskUpdateDriveLayout
#endif


NTSTATUS
ClusDiskGetRunningDevices(
    IN PVOID Buffer,
    IN ULONG BufferSize
    )

/*++

Routine Description:

    Find out the list of signatures for devices with active reservations.

Arguments:

Return Value:

--*/

{
    ULONG           bufferSize = BufferSize;
    PULONG          itemCount = (PULONG)Buffer;
    PULONG          nextSignature;
    PDEVICE_OBJECT  deviceObject;
    PCLUS_DEVICE_EXTENSION deviceExtension;
    NTSTATUS        status = STATUS_SUCCESS;
    KIRQL           irql;

    if ( bufferSize < sizeof(ULONG) ) {
        status = STATUS_BUFFER_TOO_SMALL;
        goto FnExit;
    }

    bufferSize -= sizeof(ULONG);

    *itemCount = 0;
    nextSignature = itemCount+1;

    KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
    deviceObject = RootDeviceObject->DriverObject->DeviceObject;

    //
    // For each ClusDisk device, if we have a persistent reservation, then
    // add it.
    //
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        if ( (deviceExtension->BusType != RootBus) &&
             deviceExtension->ReserveTimer &&
             (deviceExtension->PhysicalDevice == deviceObject) ) {
            if ( bufferSize < sizeof(ULONG) ) {
                break;
            }
            bufferSize -= sizeof(ULONG);
            *itemCount = *itemCount + 1;
            *nextSignature++ = deviceExtension->Signature;
        }
        deviceObject = deviceObject->NextDevice;
    }
    KeReleaseSpinLock(&ClusDiskSpinLock, irql);

    //
    // If there are more objects then room in the buffer, return error.
    //
    if ( deviceObject ) {
        status = STATUS_BUFFER_TOO_SMALL;
    }

FnExit:

    return status;

} // ClusDiskGetRunningDevices



NTSTATUS
GetScsiPortNumber(
    IN ULONG DiskSignature,
    IN PUCHAR DiskPortNumber
    )

/*--

Routine Description:

    Find the Scsi Port Number for the given device signature.

Arguments:

    DiskSignature - supplies the disk signature for the requested device.

    DiskPortNumber - returns the corresponding Scsi Port Number if found.

Return Value:

    NTSTATUS

--*/

{
    ULONG                       driveLayoutSize;
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayout = NULL;
    ULONG                       diskCount;
    ULONG                       diskNumber;
    ULONG                       skipCount;
    WCHAR                       deviceNameBuffer[MAX_PARTITION_NAME_LENGTH];
    UNICODE_STRING              unicodeString;
    NTSTATUS                    status = STATUS_UNSUCCESSFUL;
    OBJECT_ATTRIBUTES           objectAttributes;
    IO_STATUS_BLOCK             ioStatus;
    HANDLE                      ntFileHandle = NULL;
    SCSI_ADDRESS                scsiAddress;
    HANDLE                      eventHandle;


    //
    // Get the system configuration information to get number of disks.
    //
    diskCount = IoGetConfigurationInformation()->DiskCount;

    // Allocate a drive layout buffer.
    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
        (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION_EX));
    driveLayout = ExAllocatePool( NonPagedPoolCacheAligned,
                                  driveLayoutSize );
    if ( driveLayout == NULL ) {
        ClusDiskPrint((
                  1,
                  "[ClusDisk] GetScsiPortNumber: Failed to allocate root drive layout structure.\n"
                  ));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    *DiskPortNumber = 0xff;

    // Find the disk with the right signature
    for ( diskNumber = 0, skipCount = 0;
          ( diskNumber < diskCount && skipCount < SKIP_COUNT_MAX );
          diskNumber++ ) {

         if ( ntFileHandle ) {
            ZwClose( ntFileHandle );
            ntFileHandle = NULL;
         }

         if ( FAILED( StringCchPrintfW( deviceNameBuffer,
                                        RTL_NUMBER_OF(deviceNameBuffer),
                                        DEVICE_PARTITION_NAME,
                                        diskNumber,
                                        0 ) ) ) {
            continue;
         }

         WCSLEN_ASSERT( deviceNameBuffer );

         // Create device name for the physical disk.
         RtlInitUnicodeString(&unicodeString, deviceNameBuffer);

         // Setup object attributes for the file to open.
         InitializeObjectAttributes(&objectAttributes,
                                    &unicodeString,
                                    OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL);

         // Open the device.
         status = ZwCreateFile( &ntFileHandle,
                           FILE_READ_DATA,
                           &objectAttributes,
                           &ioStatus,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

         if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] GetScsiPortNumber: Failed to open device [%ws]. Error %lx.\n",
                    deviceNameBuffer,
                    status ));

            //
            // If the device doesn't exist, this is likely a hole in the
            // disk numbering.
            //

            if ( STATUS_FILE_INVALID == status ||
                 STATUS_DEVICE_DOES_NOT_EXIST == status ||
                 STATUS_OBJECT_PATH_NOT_FOUND == status ) {
                skipCount++;
                diskCount++;
                ClusDiskPrint(( 3,
                                "[ClusDisk] GetScsiPortNumber: Adjust: skipCount %d   diskCount %d \n",
                                skipCount,
                                diskCount ));
                CDLOG( "GetScsiPortNumber: Adjust: skipCount %d   diskCount %d ",
                       skipCount,
                       diskCount );
            }

            continue;
         }

        skipCount = 0;      // Device found, reset skipCount

        ClusDiskPrint(( 3,
                        "[ClusDisk] GetScsiPortNumber: Open device [%ws] succeeded.\n",
                        deviceNameBuffer ));
        CDLOG( "GetScsiPortNumber: GetScsiPortNumber: Open device [%ws] succeeded. ",
               deviceNameBuffer );

         // Create event for notification.
        status = ZwCreateEvent( &eventHandle,
                                EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

         if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                        1,
                        "[ClusDisk] GetScsiPortNumber: Failed to create event. %08X\n",
                        status));

            ExFreePool( driveLayout );
            ZwClose( ntFileHandle );
            return(status);
         }

         //
         // Force storage drivers to flush cached drive layout.  Get the
         // drive layout even if the flush fails.
         //

         status = ZwDeviceIoControlFile( ntFileHandle,
                                         eventHandle,
                                         NULL,
                                         NULL,
                                         &ioStatus,
                                         IOCTL_DISK_UPDATE_PROPERTIES,
                                         NULL,
                                         0,
                                         NULL,
                                         0 );
         if ( status == STATUS_PENDING ) {
             status = ZwWaitForSingleObject(eventHandle,
                                            FALSE,
                                            NULL);
             ASSERT( NT_SUCCESS(status) );
             status = ioStatus.Status;
         }

         status = ZwDeviceIoControlFile( ntFileHandle,
                                        eventHandle,
                                        NULL,
                                        NULL,
                                        &ioStatus,
                                        IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                        NULL,
                                        0,
                                        driveLayout,
                                        driveLayoutSize );

         if ( status == STATUS_PENDING ) {
             status = ZwWaitForSingleObject(eventHandle,
                                            FALSE,
                                            NULL);
             ASSERT( NT_SUCCESS(status) );
             status = ioStatus.Status;
         }

         ZwClose( eventHandle );

         if ( NT_SUCCESS(status) ) {

            if ( PARTITION_STYLE_MBR != driveLayout->PartitionStyle ) {
                ClusDiskPrint(( 3,
                                "[ClusDisk] GetScsiPortNumber: skipping non-MBR disk \n" ));
                CDLOG( "GetScsiPortNumber: GetScsiPortNumber: skipping non-MBR disk " );
                continue;
            }

            if ( DiskSignature == driveLayout->Mbr.Signature ) {

                ClusDiskPrint(( 3,
                                "[ClusDisk] GetScsiPortNumber: Signature match %08X \n",
                                DiskSignature ));
                CDLOG( "GetScsiPortNumber: GetScsiPortNumber: Signature match %08X ",
                       DiskSignature );

               // Create event for notification.
               status = ZwCreateEvent( &eventHandle,
                                EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

               if ( !NT_SUCCESS(status) ) {
                  ClusDiskPrint((
                                1,
                                "[ClusDisk] GetScsiPortNumber: Failed to create event. %08X\n",
                                status));

                  ExFreePool( driveLayout );
                  ZwClose( ntFileHandle );
                  return(status);
               }

               // Get the port number for the SystemRoot disk device.
               status = ZwDeviceIoControlFile( ntFileHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &ioStatus,
                                    IOCTL_SCSI_GET_ADDRESS,
                                    NULL,
                                    0,
                                    &scsiAddress,
                                    sizeof(SCSI_ADDRESS) );

               if ( status == STATUS_PENDING ) {
                   status = ZwWaitForSingleObject(eventHandle,
                                                  FALSE,
                                                  NULL);
                   ASSERT( NT_SUCCESS(status) );
                   status = ioStatus.Status;
               }

               if ( NT_SUCCESS(status) ) {
                  *DiskPortNumber = scsiAddress.PortNumber;
                  break;
               } else {
                  ClusDiskPrint((
                                1,
                                "[ClusDisk] GetScsiAddress FAILED. Error %lx\n",
                                 status));
               }

            } else {

                ClusDiskPrint(( 3,
                                "[ClusDisk] GetScsiPortNumber: Signature mismatch %08X \n",
                                DiskSignature ));
                CDLOG( "GetScsiPortNumber: GetScsiPortNumber: Signature mismatch %08X ",
                       DiskSignature );

               continue;
            }
         } else {
            ClusDiskPrint((
                          1,
                          "[ClusDisk] GetScsiAddress, GetDriveLayout FAILED. Error %lx.\n",
                          status));
         }
    }

    if ( ntFileHandle ) {
        ZwClose( ntFileHandle );
    }

    ExFreePool( driveLayout );

    return(status);

} // GetScsiPortNumber



NTSTATUS
IsDiskClusterCapable(
    IN UCHAR PortNumber,
    OUT PBOOLEAN IsCapable
    )

/*++

Routine Description:

    Check if a given SCSI port device supports cluster manageable SCSI devices.

Arguments:

    PortNumber - the port number for the SCSI device.

    IsCapable - returns whether the SCSI device is cluster capable. That is,
            supports, RESERVE/RELEASE/BUS RESET, etc.

Return Value:

--*/

{
    WCHAR               deviceNameBuffer[64];
    UNICODE_STRING      deviceNameString;
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     ioStatus;
    HANDLE              ntFileHandle;
    HANDLE              eventHandle;
    SRB_IO_CONTROL      srbControl;


   *IsCapable = TRUE;       // Err on the side of being usable.

   if ( FAILED( StringCchPrintfW( deviceNameBuffer,
                                  RTL_NUMBER_OF(deviceNameBuffer),
                                  L"\\Device\\Scsiport%d",
                                  PortNumber) ) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
   }

   WCSLEN_ASSERT( deviceNameBuffer );

   // Create device name for the scsiport driver
   RtlInitUnicodeString(&deviceNameString, deviceNameBuffer);

   // Setup object attributes for the file to open.
   InitializeObjectAttributes(&objectAttributes,
                              &deviceNameString,
                              OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                              NULL,
                              NULL);

   // Open the device.
   status = ZwCreateFile( &ntFileHandle,
                           FILE_READ_DATA,
                           &objectAttributes,
                           &ioStatus,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

   if ( !NT_SUCCESS(status) ) {
      ClusDiskPrint((1,
                     "[ClusDisk] IsDiskClusterCapable: Failed to open device [%ws]. Error %08X.\n",
                     deviceNameString, status ));
      return(status);
   }

   // Create event for notification.
   status = ZwCreateEvent( &eventHandle,
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           FALSE );

   if ( !NT_SUCCESS(status) ) {
      ClusDiskPrint((1, "[ClusDisk] IsDiskClusterCapable: Failed to create event. %08X\n",
                     status));

      ZwClose( ntFileHandle );
      return(status);
   }

   srbControl.HeaderLength = sizeof(SRB_IO_CONTROL);
   RtlMoveMemory( srbControl.Signature, "CLUSDISK", 8 );
   srbControl.Timeout = 3;
   srbControl.Length = 0;
   srbControl.ControlCode = IOCTL_SCSI_MINIPORT_NOT_QUORUM_CAPABLE;

   status = ZwDeviceIoControlFile(ntFileHandle,
                                  eventHandle,
                                  NULL,
                                  NULL,
                                  &ioStatus,
                                  IOCTL_SCSI_MINIPORT,
                                  &srbControl,
                                  sizeof(SRB_IO_CONTROL),
                                  NULL,
                                  0 );

   if ( status == STATUS_PENDING ) {
       status = ZwWaitForSingleObject(eventHandle,
                                      FALSE,
                                      NULL);
       ASSERT( NT_SUCCESS(status) );
       status = ioStatus.Status;
   }

   if ( NT_SUCCESS(status) ) {
      *IsCapable = TRUE;
   } else {
      ClusDiskPrint((3,
                     "[ClusDisk] IsDiskClusterCapable: NOT_QUORUM_CAPABLE IOCTL FAILED. Error %08X.\n",
                     status));
   }

   ZwClose( eventHandle );
   ZwClose( ntFileHandle );

   return(status);

}  // IsDiskClusterCapable


NTSTATUS
ClusDiskCreateHandle(
    OUT PHANDLE     pHandle,
    IN  ULONG       DiskNumber,
    IN  ULONG       PartitionNumber,
    IN  ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    Open a file handle to self

Arguments:

    DeviceObject -
    DesiredAccess - access mask to be passed to create file

Return Value:

    Status is returned.

--*/
{
    WCHAR                   deviceNameBuffer[ MAX_PARTITION_NAME_LENGTH ];
    UNICODE_STRING          deviceName;
    IO_STATUS_BLOCK         ioStatus;
    OBJECT_ATTRIBUTES       objectAttributes;
    NTSTATUS                status;

    *pHandle = 0;

    if ( FAILED( StringCchPrintfW( deviceNameBuffer,
                                   RTL_NUMBER_OF(deviceNameBuffer),
                                   DEVICE_PARTITION_NAME,
                                   DiskNumber,
                                   PartitionNumber ) ) ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    RtlInitUnicodeString( &deviceName, deviceNameBuffer );

    CDLOG( "CreateHandle(%wZ): Entry", &deviceName );

    InitializeObjectAttributes( &objectAttributes,
                                &deviceName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = ZwCreateFile( pHandle,
                           DesiredAccess,
                           &objectAttributes,
                           &ioStatus,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

FnExit:

    CDLOG( "CreateHandle: Exit status %!status! handle %p", status, *pHandle );
    return status;
}


VOID
ClusDiskpReplaceHandleArray(
    PDEVICE_OBJECT DeviceObject,
    PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Replaces handle array stored in the device extension with a new one.
    Use NULL as a NewValue to clean up the field.

    It will close all the handles stored in the array and free up the memory block.

    If DO_DISMOUNT is specified, it will call FSCTL_DISMOUNT for every handle

Arguments:

    DeviceObject - Partition0 Device Object

    WorkContext - General context info and routine specific context info.

Return Value:

    Status is returned.

--*/
{
    PREPLACE_CONTEXT        Context = WorkContext->Context;
    PCLUS_DEVICE_EXTENSION  deviceExtension;
    PHANDLE                 OldArray;
    LONG                    oldCount;
    LONG                    loopCount = 0;
    BOOLEAN                 runAsync = ( Context->Flags & CLEANUP_STORAGE ? TRUE : FALSE );

    do {

        Context = WorkContext->Context;
        deviceExtension = Context->DeviceExtension;
        OldArray = NULL;

        CDLOG( "ClusDiskpReplaceHandleArray: Entry NewValue %p  Flags %x  loopCount = %d",
               Context->NewValue,
               Context->Flags,
               loopCount );

        ClusDiskPrint(( 3,
                        "[ClusDisk] ClusDiskpReplaceHandleArray: Entry NewValue %p  Flags %x  loopCount = %d \n",
                        Context->NewValue,
                        Context->Flags,
                        loopCount++ ));

        OldArray =
            InterlockedExchangePointer(
                (VOID*)&deviceExtension->VolumeHandles, Context->NewValue);

        //
        // We can release the remove lock now (in some instances).  This prevents a deadlock
        // between the DismountDevice routine and the Remove PnP IRP.  During dismount, we
        // have saved a copy of the handle array, and we no longer refer to the device object
        // or extension.
        //

        if ( Context->Flags & RELEASE_REMOVE_LOCK ) {
            ReleaseRemoveLock(&deviceExtension->RemoveLock, deviceExtension);
        }

        if (OldArray) {
            ULONG i;
            ULONG Count = PtrToUlong( OldArray[0] );

            //
            // We should already be running in the system process.  If not, then there
            // is an error and we need to exit.
            //

            if ( ClusDiskSystemProcess != (PKPROCESS) IoGetCurrentProcess() ) {
                CDLOG( "ClusDiskpReplaceHandleArray: Not running in system process" );
                ExFreePool( OldArray );
                OldArray = NULL;
                goto FnExit;
            }

            for(i = 1; i <= Count; ++i) {
                if (OldArray[i]) {

#if CLUSTER_FREE_ASSERTS
                    // Check if device remove occurs before we release the handles.
                    DbgPrint("[ClusDisk] Stall before dismounting handle %x \n", OldArray[i] );
                    DBG_STALL_THREAD( 10 );
#endif
                    ClusDiskPrint(( 3,
                                    "[ClusDisk] ClusDiskpReplaceHandleArray: Handle %x \n",
                                    OldArray[i] ));

                    if (Context->Flags & DO_DISMOUNT) {
                        DismountDevice(OldArray[i]);
                    }
                    ZwClose(OldArray[i]);
                }
            }

            CDLOG("ClusDiskpReplaceHandleArray: Freed oldArray %p", OldArray );
            ExFreePool( OldArray );
            OldArray = NULL;
        }

FnExit:

        CDLOG( "ClusDiskpReplaceHandleArray: Exit" );

        ClusDiskPrint(( 3,
                        "[ClusDisk] ClusDiskpReplaceHandleArray: Returns \n" ));

        //
        // Set cleanup event if requested.
        //

        if ( Context->Flags & SET_PART0_EVENT ) {

            KeSetEvent( &deviceExtension->Event, 0, FALSE );
            ClusDiskPrint(( 3,
                            "[ClusDisk] ClusDiskpReplaceHandleArray: SetEvent (%p)\n", deviceExtension->Event ));

        }

        //
        // If we are running asynchronously, clean up any storage that was allocated.
        // This includes the work item, WorkContext, and Context.  Also remove the object
        // reference.  The original thread did not wait for this routine to complete.
        //

        if ( Context->Flags & CLEANUP_STORAGE ) {

            if ( WorkContext->WorkItem ) {
                IoFreeWorkItem( WorkContext->WorkItem );
            }

            ExFreePool( Context );
            Context = NULL;

            ExFreePool( WorkContext );
            WorkContext = NULL;

            //
            // Now the device object/device extension can go away
            //
            ObDereferenceObject( deviceExtension->DeviceObject );

        } else {

            //
            // Release the original thread that was waiting for this work item to complete.
            //

            KeSetEvent( &WorkContext->CompletionEvent, IO_NO_INCREMENT, FALSE );
        }

        //
        // Keep running only if we are in async mode and there are other
        // routines queued on our private queue.
        //

    } while ( runAsync &&
              ( WorkContext = (PWORK_CONTEXT)ExInterlockedRemoveHeadList( &ReplaceRoutineListHead,
                                                                          &ReplaceRoutineSpinLock  ) ) );

    //
    // This worker routine is about to end, so we need to decrement the
    // count if running asynchronously.
    //

    if ( runAsync ) {
        oldCount = InterlockedDecrement( &ReplaceRoutineCount );
        if ( oldCount < 0 ) {

            CDLOG( "ClusDiskpReplaceHandleArray: Invalid ReplaceRoutineCount = %d",
                   oldCount );

            ClusDiskPrint(( 3,
                            "[ClusDisk] ClusDiskpReplaceHandleArray: Invalid ReplaceRoutineCount = %d \n",
                            oldCount ));

        }
    }

}   // ClusDiskpReplaceHandleArray


NTSTATUS
ProcessDelayedWorkSynchronous(
    PDEVICE_OBJECT DeviceObject,
    PVOID WorkerRoutine,
    PVOID Context
    )
/*++

Routine Description:

    Call the WorkerRoutine directly if we are running in the system process.  If
    we are not running in the system process, check the IRQL.  If the IRQL is
    PASSIVE_LEVEL, queue the WorkerRoutine as a work item and wait for it to complete.
    When the work item completes, it will set an event.

    If the IRQL is not PASSIVE_LEVEL, then this routine will return an error.

Arguments:

    DeviceObject

    WorkerRoutine - Routine to run.

    Context - Context information for the WorkerRoutine.

Return Value:

    Status is returned.

--*/
{
    PIO_WORKITEM            workItem = NULL;
    PWORK_CONTEXT           workContext = NULL;

    NTSTATUS                status = STATUS_UNSUCCESSFUL;

    __try {

        ClusDiskPrint(( 3,
                        "[ClusDisk] DelayedWorkSync: Entry \n" ));

        //
        // Prepare a context structure.
        //

        workContext = ExAllocatePool( NonPagedPool, sizeof(WORK_CONTEXT) );

        if ( !workContext ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] DelayedWorkSync: Failed to allocate WorkContext \n" ));
            __leave;
        }

        KeInitializeEvent( &workContext->CompletionEvent, SynchronizationEvent, FALSE );

        workContext->DeviceObject = DeviceObject;
        workContext->FinalStatus = STATUS_SUCCESS;
        workContext->Context = Context;

        //
        // If we are in the system process, we can call the worker routine directly.
        //

        if ( (PKPROCESS)IoGetCurrentProcess() == ClusDiskSystemProcess ) {

            ClusDiskPrint(( 3,
                            "[ClusDisk] DelayedWorkSync: Calling WorkerRoutine directly \n" ));

            ((PIO_WORKITEM_ROUTINE)WorkerRoutine)( DeviceObject, workContext );
            __leave;
        }

        //
        // If we are not running at passive level, we cannot continue.
        //

        if ( PASSIVE_LEVEL != KeGetCurrentIrql() ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] DelayedWorkSync: IRQL not PASSIVE_LEVEL \n" ));
            __leave;
        }

        workItem = IoAllocateWorkItem( DeviceObject );

        if ( NULL == workItem ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] DelayedWorkSync: Failed to allocate WorkItem \n" ));
            __leave;
        }

        //
        // Queue the workitem.  IoQueueWorkItem will insure that the device object is
        // referenced while the work-item progresses.
        //

        CDLOG( "ProcessDelayedWorkSynchronous: Queuing work item " );

        ClusDiskPrint(( 3,
                        "[ClusDisk] DelayedWorkSync: Queuing work item \n" ));

        IoQueueWorkItem( workItem,
                         WorkerRoutine,
                         DelayedWorkQueue,
                         workContext );

        KeWaitForSingleObject( &workContext->CompletionEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        CDLOG( "ProcessDelayedWorkSynchronous: Work item completed" );

        ClusDiskPrint(( 3,
                        "[ClusDisk] DelayedWorkSync: Work item completed \n" ));


    } __finally {

        if ( workItem) {
            IoFreeWorkItem( workItem );
        }

        if ( workContext ) {
            status = workContext->FinalStatus;

            ExFreePool( workContext );
        }

    }

    ClusDiskPrint(( 3,
                    "[ClusDisk] DelayedWorkSync: Returning status %08X \n", status ));

    return status;

}   // ProcessDelayedWorkSynchronous


NTSTATUS
ProcessDelayedWorkAsynchronous(
    PDEVICE_OBJECT DeviceObject,
    PVOID WorkerRoutine,
    PVOID Context
    )
/*++

Routine Description:

    Queue a work item to do some work.  Check the IRQL.  If the IRQL is PASSIVE_LEVEL,
    queue the WorkerRoutine as a work item - don't wait for it to complete.

    If the IRQL is not PASSIVE_LEVEL, then this routine will return an error.

Arguments:

    DeviceObject

    WorkerRoutine - Routine to run.

    Context - Context information for the WorkerRoutine.
              NOTE: this context must be allocated from nonpaged pool.

Return Value:

    Status is returned.

--*/
{
    PIO_WORKITEM            workItem = NULL;
    PWORK_CONTEXT           workContext = NULL;

    NTSTATUS                status = STATUS_UNSUCCESSFUL;

    BOOLEAN                 cleanupRequired = TRUE;
    BOOLEAN                 useIoQueue;

    ClusDiskPrint(( 3,
                    "[ClusDisk] DelayedWorkAsync: Entry \n" ));

    //
    // Prepare a context structure.
    //

    workContext = ExAllocatePool( NonPagedPool, sizeof(WORK_CONTEXT) );

    if ( !workContext ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] DelayedWorkAsync: Failed to allocate WorkContext \n" ));
        goto FnExit;
    }

    RtlZeroMemory( workContext, sizeof(WORK_CONTEXT) );
    workContext->DeviceObject = DeviceObject;
    workContext->FinalStatus = STATUS_SUCCESS;
    workContext->Context = Context;

    //
    // If we are not running at passive level, we cannot continue.
    //

    if ( PASSIVE_LEVEL != KeGetCurrentIrql() ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] DelayedWorkAsync: IRQL not PASSIVE_LEVEL \n" ));
        goto FnExit;
    }

    workItem = IoAllocateWorkItem( DeviceObject );

    if ( NULL == workItem ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] DelayedWorkAsync: Failed to allocate WorkItem \n" ));
        goto FnExit;
    }

    cleanupRequired = FALSE;

    workContext->WorkItem = workItem;

    //
    // Bug 466526.  On systems with large number of disks, when system is
    // dismounting all disks at same time, the work queues can become blocked
    // trying to process ClusDiskpReplaceHandleArray requests.  When these
    // requests try to dismount disks, the dismount causes a call to
    // IoReportTargetDeviceChange, which then blocks.  The problem is that
    // the pnp routine to handle device change also needs to run as a work
    // item, but it cannot as all worker threads are blocked.
    //
    // Only queue some number of ClusDiskpReplaceHandleArray requests.
    // Save the other requests in private queue and the routine(s) running
    // will process the private queue.
    //

    useIoQueue = TRUE;

    if ( ClusDiskpReplaceHandleArray == WorkerRoutine ) {

        //
        // Check how many replace routines are currently running.
        //

        if ( ReplaceRoutineCount >= MAX_REPLACE_HANDLE_ROUTINES ) {

            //
            // Too many worker threads may be running and blocked,
            // queue this request in the private queue.
            //
            // The device object was referenced before this routine
            // was called, so we just need to save the info on the
            // private queue.
            //

            CDLOG( "ProcessDelayedWorkAsynchronous: Queuing work item on private list " );

            ClusDiskPrint(( 3,
                            "[ClusDisk] DelayedWorkAsync: Queuing work item on private list \n" ));

            ExInterlockedInsertTailList( &ReplaceRoutineListHead,
                                         &workContext->ListEntry,
                                         &ReplaceRoutineSpinLock );

            useIoQueue = FALSE;

        } else {

            //
            // We don't have too many replace routines running - this
            // replace routine can be queued as a work item.
            // Bump the count of replace routines running.
            //

            InterlockedIncrement( &ReplaceRoutineCount );
            useIoQueue = TRUE;
        }
    }

    if ( useIoQueue ) {

        //
        // Queue the workitem.  IoQueueWorkItem will insure that the device object is
        // referenced while the work-item progresses.
        //

        CDLOG( "ProcessDelayedWorkAsynchronous: Queuing work item " );

        ClusDiskPrint(( 3,
                        "[ClusDisk] DelayedWorkSync: Queuing work item \n" ));

        IoQueueWorkItem( workItem,
                         WorkerRoutine,
                         DelayedWorkQueue,
                         workContext );

    }

    status = STATUS_SUCCESS;

FnExit:

    if ( cleanupRequired ) {
        if ( workItem) {
            IoFreeWorkItem( workItem );
        }
        if ( workContext ) {
            ExFreePool( workContext );
        }

        if ( Context ) {
            ExFreePool( Context );
        }
    }

    ClusDiskPrint(( 3,
                    "[ClusDisk] DelayedWorkAsync: Returning status %08X \n", status ));

    return status;

}   // ProcessDelayedWorkAsynchronous


VOID
ClusDiskpOpenFileHandles(
    PDEVICE_OBJECT Part0DeviceObject,
    PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Creates file handles for all partitions on the disk.

Arguments:

    DeviceObject - Partition0 Device Object

    WorkContext - General context info and routine specific context info.

Return Value:

    Status is returned.

--*/

{
    NTSTATUS                  status;
    NTSTATUS                  returnStatus = STATUS_SUCCESS;
    PCLUS_DEVICE_EXTENSION    deviceExtension =
                                Part0DeviceObject->DeviceExtension;
    PDRIVE_LAYOUT_INFORMATION_EX    pDriveLayout = NULL;
    ULONG                     partitionCount;
    ULONG                     i;
    HANDLE*                   HandleArray = NULL;
    ULONG                     ArraySize;
    REPLACE_CONTEXT           context;
    BOOLEAN                   validHandles;

    CDLOG( "OpenFileHandles(%p): Entry", Part0DeviceObject );

    ASSERT( (deviceExtension->PhysicalDevice == Part0DeviceObject)
         && (Part0DeviceObject != RootDeviceObject) );

    //
    // Get the cached drive layout info if possible.  If not,
    // go out to the device and get the drive layout.
    //

    GetDriveLayout( Part0DeviceObject,
                    &pDriveLayout,
                    FALSE,              // Don't update cached drive layout
                    FALSE );            // Don't flush storage drivers cached drive layout

    if (NULL == pDriveLayout) {
        returnStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit_gracefully;
    }
    partitionCount = pDriveLayout->PartitionCount;

    ExFreePool( pDriveLayout );
    pDriveLayout = NULL;

    ArraySize = (partitionCount + 1) * sizeof(HANDLE);

    //
    // If we are not running in the system process, we can't continue.
    //

    if ( ClusDiskSystemProcess != (PKPROCESS) IoGetCurrentProcess() ) {
        CDLOG("OpenFileHandles: Not running in system process" );
        returnStatus = STATUS_UNSUCCESSFUL;
        goto exit_gracefully;
    }

    HandleArray =
        ExAllocatePool(PagedPool, ArraySize );

    if (!HandleArray) {
        CDLOG("OpenFileHandles: AllocFailed ArraySize %d", ArraySize );
        returnStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit_gracefully;
    }

    //
    // Store the size of the array in the first element
    //

    HandleArray[0] = (HANDLE)( UlongToPtr(partitionCount) );

    validHandles = FALSE;
    for(i = 1; i <= partitionCount; ++i) {
        HANDLE FileHandle;

        status = ClusDiskCreateHandle(
                    &FileHandle,
                    deviceExtension->DiskNumber,
                    i,
                    FILE_WRITE_ATTRIBUTES);     // Use FILE_WRITE_ATTRIBUTES for dismount

        if (NT_SUCCESS(status)) {
            HandleArray[i] = FileHandle;
            validHandles = TRUE;
        } else {
            HandleArray[i] = 0;
            returnStatus = status;
        }
    }

    if ( !validHandles ) {
        ExFreePool( HandleArray );
        HandleArray = NULL;
    }

    context.DeviceExtension = deviceExtension;
    context.NewValue        = HandleArray;
    context.Flags           = 0;        // don't dismount

    ProcessDelayedWorkSynchronous( Part0DeviceObject, ClusDiskpReplaceHandleArray, &context );

exit_gracefully:
    CDLOG( "OpenFileHandles: Exit => %!status!", returnStatus );

    ClusDiskPrint(( 3,
                    "[ClusDisk] ClusDiskpOpenFileHandles: Returning status %08X \n", returnStatus ));

    WorkContext->FinalStatus = returnStatus;

    KeSetEvent( &WorkContext->CompletionEvent, IO_NO_INCREMENT, FALSE );

}   // ClusDiskpOpenFileHandles


NTSTATUS
ClusDiskDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This device control dispatcher handles only the cluster disk
    device control. All others are passed down to the disk drivers.

Arguments:

    DeviceObject - Context for the activity.
    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/

{
    PCLUS_DEVICE_EXTENSION      deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION      physicalDisk =
                                    deviceExtension->PhysicalDevice->DeviceExtension;
    PIO_STACK_LOCATION          currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                    status = STATUS_SUCCESS;

    //
    // Note that we are going to acquire two RemoveLocks here: one for the original DO and one
    // for the physical device (pointed to this DO's device extension).  Whenever an IRP is
    // queued, we release one RemoveLock in this routine - release the RemoveLock in the device
    // extension NOT containing the queued IRP.  The routine that processes the queued IRP will
    // release the RemoveLock as it has the proper device extension.
    //
    // This should work correctly even if the DO and the physical device point to the same DO, since
    // the RemoveLock is really just a counter, we will increment the counter for the DO twice and
    // decrement it once here, and once when the IRP is completed.

    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
         Irp->IoStatus.Status = status;
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
         return status;
    }

    status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
         ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
         Irp->IoStatus.Status = status;
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
         return status;
    }

    //
    // Make sure the device attach completed.
    //
    status = WaitForAttachCompletion( deviceExtension,
                                      TRUE,             // Wait
                                      TRUE );           // Also check physical device
    if ( !NT_SUCCESS( status ) ) {
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Find out if this is directed at the root device. If so, we only
    // support ATTACH and DETACH.
    //
    if ( deviceExtension->BusType == RootBus ) {
        return(ClusDiskRootDeviceControl( DeviceObject, Irp ));
    }

    switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

        //
        // We can only get (not set) the current state from this code path.
        // Use clusdisk0 and disk signature to set the disk state.
        // To get the current disk state, send the "set state" IOCTL
        // to the disk/volume object directly with output parameters only
        // (no input paramters) or use the "get state" IOCTL.
        //

        case IOCTL_DISK_CLUSTER_SET_STATE:
        case IOCTL_DISK_CLUSTER_GET_STATE:
        {
            PUCHAR      ioDiskState = Irp->AssociatedIrp.SystemBuffer;
            ULONG       returnLength = 0;

            ClusDiskPrint((3, "[ClusDisk] DeviceControl: PD DiskState %s,  devObj DiskState %s \n",
                           DiskStateToString( physicalDisk->DiskState ),
                           DiskStateToString( deviceExtension->DiskState ) ));

            //
            // Check if input buffer supplied. If present, then this is a request to
            // set the new disk state.  Fail the request.
            //

            if ( ARGUMENT_PRESENT( ioDiskState) &&
                 currentIrpStack->Parameters.DeviceIoControl.InputBufferLength >= sizeof(UCHAR) ) {

                ClusDiskPrint((3, "[ClusDisk] DeviceControl: Can't set state on disk %u (%p) \n",
                               physicalDisk->DiskNumber,
                               DeviceObject ));

                status = STATUS_INVALID_DEVICE_REQUEST;

            } else if ( ARGUMENT_PRESENT( ioDiskState ) &&
                        currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(UCHAR) ) {

                ioDiskState[0] = (UCHAR)physicalDisk->DiskState;
                returnLength = sizeof(UCHAR);

            } else {

                status = STATUS_INVALID_PARAMETER;
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = returnLength;

            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
            return(status);
        }

        // Check if low-level miniport driver support cluster devices.

        case IOCTL_DISK_CLUSTER_NOT_CLUSTER_CAPABLE:
        {
            BOOLEAN     isCapable;

            //
            // Make sure there is no input/output data buffer.
            //
            if ( Irp->AssociatedIrp.SystemBuffer != NULL ) {
                ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return(STATUS_INVALID_PARAMETER);
            }

            //
            // Verifier found a problem with the original code.  The status returned
            // wasn't the same as Irp->IoStatus.Status.  The IRP status was always
            // success, but the dispatch routine sometimes returned an error.  This
            // seems to work but verifier says this is invalid.  When I changed the code
            // to update the IRP status with the same returned status, new drives
            // couldn't be seen.  This is because the user mode component uses this
            // IOCTL to indicate the disk is NOT cluster capable, so the user mode
            // code looked for a failure to incidate a cluster disk.
            //

            //
            // IsDiskClusterCapable always returns TRUE ???
            //

            status = IsDiskClusterCapable ( deviceExtension->ScsiAddress.PortNumber,
                                            &isCapable);

            //
            // Fix for IBM.  The Win2000 2195 code returned from this IOCTL the status
            // of the SCSI miniport IOCTL.  This was returned to DeviceIoControl rather
            // than the status in the IRP.  Changed to make the behavior the same as
            // Win20000 2195.
            //

            //
            // If the SCSI miniport IOCTL succeeds, we return success -- meaning we should
            // *not* use this disk.  If any of the routines failed while trying to issue
            // the SCSI miniport IOCTL (including issuing the SCSI miniport IOCTL itself),
            // then we return failure -- meaning we *should* use this disk.
            //

            Irp->IoStatus.Status = status;
            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

            return(status);
        }

        case IOCTL_DISK_CLUSTER_WAIT_FOR_CLEANUP:
        {
            LARGE_INTEGER   waitTime;
            ULONG           waitTimeInSeconds;

            if ( currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG) ||
                 Irp->AssociatedIrp.SystemBuffer == NULL) {

                ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return(STATUS_INVALID_PARAMETER);
            }

            //
            // Get wait time from caller, and limit it to max.
            //

            waitTimeInSeconds = *(PULONG)Irp->AssociatedIrp.SystemBuffer;
            if ( waitTimeInSeconds > MAX_WAIT_SECONDS_ALLOWED ) {
                waitTimeInSeconds = MAX_WAIT_SECONDS_ALLOWED;
            }

            CDLOG( "IoctlWaitForCleanup(%p): Entry waitTime %d second(s)",
                      DeviceObject,
                      waitTimeInSeconds );

            waitTime.QuadPart = (LONGLONG)waitTimeInSeconds * -(10000*1000);
            status = KeWaitForSingleObject(
                                  &physicalDisk->Event,
                                  Suspended,
                                  KernelMode,
                                  FALSE,
                                  &waitTime);
            //
            // Reset the event in case of timeout.
            // [HACKHACK] should we do this?
            // No. If Offline worker is stuck somewhere, we better
            // go and debug the problem, rather then return success
            // and wait for the offline worker to do nasty things
            // behind our backs
            //
            //  KeSetEvent( &physicalExtension->Event, 0, FALSE );

            if (status == STATUS_TIMEOUT) {
                //
                // NT_SUCCESS considers STATUS_TIMEOUT as a success code
                // we need something stronger
                //
                status = STATUS_IO_TIMEOUT;
            }

            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            CDLOG( "IoctlWaitForCleanup(%p): Exit => %!status!",
                        DeviceObject,
                        status );

            return(status);
        }

        case IOCTL_DISK_CLUSTER_TEST:
        {
            CDLOG( "IoctlDiskClusterTest(%p)", DeviceObject );

            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(STATUS_SUCCESS);
        }

        case IOCTL_VOLUME_IS_CLUSTERED:
        {
            //
            // Look at the reserve timer.  If reserved, this is a clustered disk.
            //

            if ( physicalDisk->ReserveTimer != 0 ) {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_UNSUCCESSFUL;
            }

            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }

        // **************************
        // The following IOCTL's should not be blocked by stalled disks
        // **************************

        case IOCTL_SCSI_GET_ADDRESS:
        case IOCTL_STORAGE_GET_HOTPLUG_INFO:
        case IOCTL_STORAGE_RESET_BUS:
        case IOCTL_STORAGE_BREAK_RESERVATION:
        case IOCTL_STORAGE_QUERY_PROPERTY:
        case IOCTL_STORAGE_GET_MEDIA_TYPES:
        case IOCTL_STORAGE_GET_MEDIA_TYPES_EX:
        case IOCTL_STORAGE_FIND_NEW_DEVICES:
        case IOCTL_STORAGE_GET_DEVICE_NUMBER:
        case IOCTL_STORAGE_MEDIA_REMOVAL:
        case IOCTL_STORAGE_CHECK_VERIFY:
        case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
        case IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY:
        case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
        case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
        case IOCTL_MOUNTDEV_LINK_CREATED:
        case IOCTL_MOUNTDEV_LINK_DELETED:
        case IOCTL_DISK_GET_DRIVE_LAYOUT:
        case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:
        case IOCTL_DISK_CHECK_VERIFY:
        case IOCTL_DISK_MEDIA_REMOVAL:
        case IOCTL_DISK_GET_DRIVE_GEOMETRY:
        case IOCTL_DISK_GET_DRIVE_GEOMETRY_EX:
        case IOCTL_DISK_GET_PARTITION_INFO:
        case IOCTL_DISK_GET_PARTITION_INFO_EX:
        case IOCTL_DISK_IS_WRITABLE:
        case IOCTL_DISK_UPDATE_PROPERTIES:
        case IOCTL_VOLUME_ONLINE:
        case IOCTL_VOLUME_OFFLINE:
        case IOCTL_VOLUME_IS_OFFLINE:
        case IOCTL_DISK_GET_LENGTH_INFO:
        case IOCTL_MOUNTDEV_QUERY_STABLE_GUID:
        case IOCTL_PARTMGR_QUERY_DISK_SIGNATURE:
        {
            IoSkipCurrentIrpStackLocation( Irp );

            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

            return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);
        }

        default:
        {

            //
            // For all other requests, we must be online to process the request.
            //
            //
            // Before returning failure, first verify device attachment. This
            // means that if the device is attached check if it should be detached.
            // If the device does get detached, then allow IO to go through.
            //
            if ( !deviceExtension->AttachValid ) {

                PDEVICE_OBJECT targetDeviceObject;

                targetDeviceObject = deviceExtension->TargetDeviceObject;
                ClusDiskPrint((
                    1,
                    "[ClusDisk] Attach is not valid. IOCTL = %lx, check if we need to detach.\n",
                    currentIrpStack->Parameters.DeviceIoControl.IoControlCode));
                if ( !ClusDiskVerifyAttach( DeviceObject ) ) {
                    ClusDiskPrint((
                        1,
                        "[ClusDisk] We detached.\n"));
                    IoSkipCurrentIrpStackLocation( Irp );

                    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

                    return IoCallDriver(targetDeviceObject,
                                        Irp);
                }
                if ( deviceExtension->AttachValid ) {
                    ClusDiskPrint((
                        1,
                        "[ClusDisk] Attach is now valid, Signature = %08lX .\n",
                        deviceExtension->Signature));
                }
            }

            if ( physicalDisk->DiskState != DiskOnline ) {

#if 0
                ULONG  access;

                // This seems like a good idea, but needs more testing.  We might miss
                // setting up irp completion routine.

                //
                // Try cracking the control code and letting any IOCTLs through that
                // do not have write access set.
                //

                access = ACCESS_FROM_CTL_CODE(currentIrpStack->Parameters.DeviceIoControl.IoControlCode);

                if ( !(access & FILE_WRITE_ACCESS) ) {

                    ClusDiskPrint((
                        3,
                        "[ClusDisk] Sending IOCTL = %08lX based on access %02X, Signature = %08lX \n",
                        currentIrpStack->Parameters.DeviceIoControl.IoControlCode,
                        access,
                        deviceExtension->Signature));

                    IoSkipCurrentIrpStackLocation( Irp );

                    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

                    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

                }
#endif

                // All other IOCTL's fall through and are failed because disk is offline.

                ClusDiskPrint((
                    1,
                    "[ClusDisk] Disk not online: Rejected IOCTL = %08lX, Signature = %08lX \n",
                    currentIrpStack->Parameters.DeviceIoControl.IoControlCode,
                    deviceExtension->Signature));

                CDLOG( "[ClusDisk] DeviceControl, Failing IOCTL %lx for offline device, signature %lx \n",
                       currentIrpStack->Parameters.DeviceIoControl.IoControlCode,
                       deviceExtension->Signature );

                ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
                Irp->IoStatus.Status = STATUS_DEVICE_OFF_LINE;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return(STATUS_DEVICE_OFF_LINE);
            }

            switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

                case IOCTL_DISK_FIND_NEW_DEVICES:

                    //
                    // Copy current stack to next stack.
                    //

                    IoCopyCurrentIrpStackLocationToNext( Irp );

                    //
                    // Ask to be called back during request completion.
                    // Pass current disk count as context.
                    //
                    //

                    IoSetCompletionRoutine(Irp,
                                           ClusDiskNewDiskCompletion,
                                           (PVOID)( UlongToPtr( IoGetConfigurationInformation()->DiskCount ) ),
                                           TRUE,    // Invoke on success
                                           TRUE,    // Invoke on error
                                           TRUE);   // Invoke on cancel

                    //
                    // Call target driver.
                    //

                    // The completion routine will release the RemoveLocks.

                    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

                case IOCTL_DISK_SET_DRIVE_LAYOUT:
                case IOCTL_DISK_SET_DRIVE_LAYOUT_EX:

                    CDLOG( "IoctlDiskSetDriveLayout(%p)", DeviceObject );

                    //
                    // Copy current stack to next stack.
                    //

                    IoCopyCurrentIrpStackLocationToNext( Irp );

                    //
                    // Ask to be called back during request completion.
                    //

                    IoSetCompletionRoutine(Irp,
                                           ClusDiskSetLayoutCompletion,
                                           DeviceObject,
                                           TRUE,    // Invoke on success
                                           TRUE,    // Invoke on error
                                           TRUE);   // Invoke on cancel

                    //
                    // Call target driver.
                    //

                    // The completion routine will release the RemoveLocks.

                    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

                default:

                    //
                    // Set current stack back one.
                    //
                    IoSkipCurrentIrpStackLocation( Irp );

                    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

                    //
                    // Pass unrecognized device control requests
                    // down to next driver layer.
                    //

                    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

            } // switch

        }   // default case

    }   // switch

} // ClusDiskDeviceControl



NTSTATUS
ClusDiskRootDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This device control dispatcher handles only the cluster disk IOCTLs
    for the root device. This is ATTACH and DETACH.

    Important:  Two RemoveLocks will be held on entry to this function.
    One RemoveLock for the original DO and one for the associated physical
    device.

Arguments:

    DeviceObject - Context for the activity.
    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDisk =
                               deviceExtension->PhysicalDevice->DeviceExtension;

    // Save pointers to the original RemoveLocks as the device extensions
    // may change in this routine.
    PCLUS_DEVICE_EXTENSION lockedDeviceExtension = deviceExtension;
    PCLUS_DEVICE_EXTENSION lockedPhysicalDisk = physicalDisk;

    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_OBJECT targetDeviceObject;
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       signature;
    PULONG      inputData = Irp->AssociatedIrp.SystemBuffer;
    ULONG       inputSize = currentIrpStack->Parameters.DeviceIoControl.InputBufferLength;
    ULONG       outputSize = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    KIRQL       irql;
    BOOLEAN     newPhysLockAcquired;

    switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_DISK_CLUSTER_ARBITRATION_ESCAPE:
        {
            if ( ARGUMENT_PRESENT( inputData ) &&
                 inputSize >= sizeof(ARBITRATION_READ_WRITE_PARAMS) )
            {
                BOOLEAN success;
                PDEVICE_OBJECT physicalDevice;
                PARBITRATION_READ_WRITE_PARAMS params =
                    (PARBITRATION_READ_WRITE_PARAMS)inputData;

                // Can't hold the spinlock and then try to acquire the resource lock or the system
                // might deadlock.
                // KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
                success = AttachedDevice( params->Signature, &physicalDevice );
                // KeReleaseSpinLock(&ClusDiskSpinLock, irql);

                if( success ) {

                    PCLUS_DEVICE_EXTENSION tempDeviceExtension = physicalDevice->DeviceExtension;

                    // We have a new device here, acquire the RemoveLock if possible.

                    status = AcquireRemoveLock(&tempDeviceExtension->RemoveLock, Irp);
                    if ( NT_SUCCESS(status) ) {

                        status = ProcessArbitrationEscape(
                                    physicalDevice->DeviceExtension,
                                    inputData,
                                    inputSize,
                                    &outputSize);
                        if ( NT_SUCCESS(status) ) {
                            Irp->IoStatus.Information = outputSize;
                        }

                        ReleaseRemoveLock(&tempDeviceExtension->RemoveLock, Irp);
                    }
                } else {
                    status = STATUS_NOT_FOUND;
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }

        //
        // Always sets new state and optionally return the old state.
        // To just get the current disk state, send the "set state" IOCTL
        // to the disk/volume object directly with output parameters only
        // (no input paramters), or use the "get state" IOCTL.
        //

        case IOCTL_DISK_CLUSTER_SET_STATE:
        {
            ULONG       returnLength = 0;

            //
            // Called routine will validate all parameters.
            //

            status = SetDiskState( Irp->AssociatedIrp.SystemBuffer,                                 // Input/output buffer
                                   currentIrpStack->Parameters.DeviceIoControl.InputBufferLength,   // Input buffer length
                                   currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength,  // Output buffer length
                                   &returnLength );

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = returnLength;

            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
            return(status);
        }

        // Perform an attach to a device object, for a given signature.
        case IOCTL_DISK_CLUSTER_ATTACH:
        {
            if ( ARGUMENT_PRESENT( inputData ) &&
                 inputSize >= sizeof(ULONG) ) {

                signature = inputData[0];

                ClusDiskPrint((1,
                               "[ClusDisk] RootDeviceControl: attaching signature %08X  installMode TRUE \n",
                               signature));

                CDLOG( "RootClusterAttach: sig %08x  installMode TRUE ", signature );

                status = ClusDiskTryAttachDevice( signature,
                                                  0,
                                                  DeviceObject->DriverObject,
                                                  TRUE );       // Dismount, then offline
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }

        // Perform an attach to a device object, for a given signature.
        // In this case, offline the disk first, then dismount.
        case IOCTL_DISK_CLUSTER_ATTACH_OFFLINE:
        {
            if ( ARGUMENT_PRESENT( inputData ) &&
                 inputSize >= sizeof(ULONG) ) {

                signature = inputData[0];

                ClusDiskPrint((1,
                               "[ClusDisk] RootDeviceControl: attaching signature %08X  installMode FALSE \n",
                               signature));

                CDLOG( "RootClusterAttach: sig %08x  installMode FALSE ", signature );

                status = ClusDiskTryAttachDevice( signature,
                                                  0,
                                                  DeviceObject->DriverObject,
                                                  FALSE );      // Offline, then dismount
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }

        // Perform a detach from a device object, for a given signature

        case IOCTL_DISK_CLUSTER_DETACH:
        {
            if ( ARGUMENT_PRESENT( inputData ) &&
                 inputSize >= sizeof(ULONG) ) {

                signature = inputData[0];

                CDLOG( "RootClusterDetach: sig %08x", signature );

                ClusDiskPrint((3,
                               "[ClusDisk] RootDeviceControl: detaching signature %08X\n",
                               signature));

                status = ClusDiskDetachDevice( signature,
                                               DeviceObject->DriverObject );
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }

        case IOCTL_DISK_CLUSTER_ATTACH_LIST:
        {
            // The called routine will validate the input buffers.

            //
            // Attaches a signature list to the system.  NO resets will occur.  If we
            // really need to make sure the device attaches, then use the normal
            // attach IOCTL.  This IOCTL is mainly used by cluster setup.
            //

            status = AttachSignatureList( DeviceObject,
                                          inputData,
                                          inputSize
                                          );

            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);

        }

        // Detach from all the signatures in the list.

        case IOCTL_DISK_CLUSTER_DETACH_LIST:
        {
            // The called routine will validate the input buffers.

            status = DetachSignatureList( DeviceObject,
                                          inputData,
                                          inputSize
                                          );

            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);

        }

        // Start the reservation timer

        case IOCTL_DISK_CLUSTER_START_RESERVE:
        {
            CDLOG( "RootStartReserve(%p)", DeviceObject );

            if ( RootDeviceObject == NULL ) {
                ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
                ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
                Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
                IoCompleteRequest( Irp, IO_NO_INCREMENT );
                return(STATUS_INVALID_DEVICE_REQUEST);
            }

            if ( currentIrpStack->FileObject->FsContext ) {
                status = STATUS_DUPLICATE_OBJECTID;
            } else if ( ARGUMENT_PRESENT(inputData) &&
                        inputSize >= sizeof(ULONG) ) {

                status = VerifyArbitrationArgumentsIfAny(
                            inputData,
                            inputSize );
                if (!NT_SUCCESS(status) ) {
                   ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
                   ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
                   Irp->IoStatus.Status = status;
                   IoCompleteRequest(Irp, IO_NO_INCREMENT);
                   return(status);
                }

                signature = inputData[0];


                // Acquire the device list lock first, then the spinlock.  This will prevent deadlock.
                ACQUIRE_SHARED( &ClusDiskDeviceListLock );
                KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
                if ( MatchDevice(signature, &targetDeviceObject) &&
                     targetDeviceObject ) {
                    status = EnableHaltProcessing( &irql );
                    if ( NT_SUCCESS(status) ) {

                        physicalDisk = targetDeviceObject->DeviceExtension;

                        status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
                        if ( !NT_SUCCESS(status) ) {

                            status = STATUS_NO_SUCH_FILE;

                        } else {

                            ProcessArbitrationArgumentsIfAny(
                                 physicalDisk,
                                 inputData,
                                 inputSize );

                            ClusDiskPrint((3,
                                           "[ClusDisk] Start reservations on signature %lx.\n",
                                           physicalDisk->Signature ));

                            currentIrpStack->FileObject->FsContext = targetDeviceObject;
                            CDLOG("RootCtl: IncRef(%p)", targetDeviceObject );
                            ObReferenceObject( targetDeviceObject );
                            physicalDisk->ReserveTimer = RESERVE_TIMER;
                            physicalDisk->ReserveFailure = 0;
                            physicalDisk->PerformReserves = TRUE;
                            status = STATUS_SUCCESS;

                            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                        }
                    }
                } else {
                    status = STATUS_NO_SUCH_FILE;
                }
                KeReleaseSpinLock(&ClusDiskSpinLock, irql);
                RELEASE_SHARED( &ClusDiskDeviceListLock );
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);

        }

        // Stop the reservation timer

        case IOCTL_DISK_CLUSTER_STOP_RESERVE:
        {
            PIRP        irp;
            PLIST_ENTRY listEntry;

            CDLOG( "RootStopReserve(%p)", DeviceObject );

            if ( (RootDeviceObject == NULL) ||
                 (deviceExtension->BusType != RootBus) ) {
                ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
                ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
                Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
                IoCompleteRequest( Irp, IO_NO_INCREMENT );
                return(STATUS_INVALID_DEVICE_REQUEST);
            }

            newPhysLockAcquired = FALSE;

            if ( currentIrpStack->FileObject->FsContext ) {

                //
                // GorN Oct/13/1999. PnP can come and rip out the device object
                // we stored in the FsContext. It doesn't delete it, since we have a reference
                // to it, but we will not be able to use it, since the objects underneath this one
                // are destroyed.
                //
                // Our PnpRemoveDevice handler will zero out targetDevice field of the device
                // extension, this will not eliminate the race completely, but will reduces the
                // chance of this happening, since, usually, device removal comes first,
                // we notify resmon and then it calls stop reserve.
                //
                // Chances that PnpRemoveDevice will come at exact moment resmon called ClusterStopReserve
                // are smaller
                //

                targetDeviceObject = (PDEVICE_OBJECT)currentIrpStack->FileObject->FsContext;
                physicalDisk = targetDeviceObject->DeviceExtension;

                CDLOG( "RootStopReserve: FsContext targetDO %p RemoveLock.IoCount %d",
                        targetDeviceObject,
                        physicalDisk->RemoveLock.Common.IoCount );

                // We have a new device here, acquire the RemoveLock if possible.

                status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
                if ( !NT_SUCCESS(status) ) {

                    status = STATUS_INVALID_HANDLE;

                } else {

                    ClusDiskPrint((3,
                                   "[ClusDisk] IOCTL, stop reservations on signature %lx, disk state %s \n",
                                   physicalDisk->Signature,
                                   DiskStateToString( physicalDisk->DiskState ) ));

                    newPhysLockAcquired = TRUE;

                    IoAcquireCancelSpinLock( &irql );
                    KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);
                    physicalDisk->ReserveTimer = 0;

                    //
                    // Signal all waiting Irp's on the physical device extension.
                    //
                    while ( !IsListEmpty(&physicalDisk->WaitingIoctls) ) {
                        listEntry = RemoveHeadList(&physicalDisk->WaitingIoctls);
                        irp = CONTAINING_RECORD( listEntry,
                                                 IRP,
                                                 Tail.Overlay.ListEntry );
                        ClusDiskCompletePendingRequest(irp, STATUS_SUCCESS, physicalDisk);
                    }

                    KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
                    IoReleaseCancelSpinLock( irql );

                    //
                    // This should not be done here.
                    // Cleaning FsContext here, will prevent ClusDiskCleanup
                    // from doing its work
                    //
                    // ObDereferenceObject(targetDeviceObject);
                    // CDLOG("RootCtl_DecRef(%p)", targetDeviceObject );
                    // currentIrpStack->FileObject->FsContext = NULL;

                    //
                    // Release the scsi device.
                    //
                    // [GorN] 10/04/1999. Why this release was commented out?
                    // [GorN] 10/13/1999. It was commented out, because it was causing an AV,
                    //                    if the device was removed by PnP

                    //
                    // 2000/02/05: stevedz - RemoveLocks should resolve this problem.
                    //
                    // The following "if" only reduces the chances of AV to occur, not
                    // eliminates it completely. TargetDeviceObject is zeroed out by our PnP
                    // handler when the device is removed
                    //
                    if (physicalDisk->TargetDeviceObject) {
                        ReleaseScsiDevice( physicalDisk );
                    }

                    ClusDiskPrint((3,
                                   "[ClusDisk] IOCTL, stop reservations on signature %lx.\n",
                                   physicalDisk->Signature ));

                    status = STATUS_SUCCESS;
                }

            } else {
                status = STATUS_INVALID_HANDLE;
            }

            if (newPhysLockAcquired) {
                ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            }

            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);

        }

        // Aliveness check
        case IOCTL_DISK_CLUSTER_ALIVE_CHECK:
        {
            CDLOG( "RootAliveCheck(%p)", DeviceObject );

            if ( (RootDeviceObject == NULL) ||
                 (deviceExtension->BusType != RootBus) ) {
                ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
                ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
                Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
                IoCompleteRequest( Irp, IO_NO_INCREMENT );
                return(STATUS_INVALID_DEVICE_REQUEST);
            }

            IoAcquireCancelSpinLock( &irql );
            KeAcquireSpinLockAtDpcLevel( &ClusDiskSpinLock );

            // Indicate that we didn't acquire a third RemoveLock for the new physical device.

            newPhysLockAcquired = FALSE;

            if ( currentIrpStack->FileObject->FsContext ) {
                targetDeviceObject = (PDEVICE_OBJECT)currentIrpStack->FileObject->FsContext;
                physicalDisk = targetDeviceObject->DeviceExtension;

                // We have a new device here, acquire the RemoveLock if possible.

                status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
                if ( !NT_SUCCESS(status) ) {

                    status = STATUS_FILE_DELETED;

                } else {

                    newPhysLockAcquired = TRUE;

                    if ( physicalDisk->TargetDeviceObject == NULL ) {
                        status = STATUS_FILE_DELETED;
                    } else
                    if ( physicalDisk->ReserveFailure &&
                         (!NT_SUCCESS(physicalDisk->ReserveFailure)) ) {
                        status = physicalDisk->ReserveFailure;
                    } else {
                        //
                        // The device does not have to be 'online' to have been
                        // successfully arbitrated and being defended. However,
                        // the quorum device really should be 'online'...
                        //
                        if ( physicalDisk->ReserveTimer == 0 ) {
#if 0
                            ClusDiskPrint((
                                    1,
                                    "[ClusDisk] RootDeviceControl, AliveCheck failed, signature %lx, state = %s, ReserveTimer = %lx.\n",
                                    physicalDisk->Signature,
                                    DiskStateToString( physicalDisk->DiskState ),
                                    physicalDisk->ReserveTimer ));
#endif
                            status = STATUS_CANCELLED;
                        } else {
                            status = STATUS_SUCCESS;
                        }
                    }
                }

            } else {
                status = STATUS_INVALID_HANDLE;
            }

            if ( status == STATUS_SUCCESS ) {
                NTSTATUS    newStatus;

                newStatus = ClusDiskMarkIrpPending( Irp, ClusDiskIrpCancel );
                if ( NT_SUCCESS( newStatus ) ) {
                    InsertTailList( &physicalDisk->WaitingIoctls,
                                    &Irp->Tail.Overlay.ListEntry );
                    status = STATUS_PENDING;

                    // Release all the RemoveLocks.

                    if (newPhysLockAcquired) {
                        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                    }

                    ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
                    ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);

                } else {
                    status = newStatus;

                    if (newPhysLockAcquired) {
                        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                    }
                    ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
                    ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);

                    Irp->IoStatus.Status = status;
                    IoCompleteRequest(Irp, IO_NO_INCREMENT);
                }

                KeReleaseSpinLockFromDpcLevel( &ClusDiskSpinLock );
                IoReleaseCancelSpinLock( irql );
            } else {
                KeReleaseSpinLockFromDpcLevel( &ClusDiskSpinLock );
                IoReleaseCancelSpinLock( irql );

                if (newPhysLockAcquired) {
                    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                }
                ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
                ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);

                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }

            return(status);
        }

        // Check out what's happening
        case IOCTL_DISK_CLUSTER_ACTIVE:
        {
            // The called routine will validate the input buffers.

            if ( (RootDeviceObject == NULL) ||
                 (deviceExtension->BusType != RootBus) ) {
                ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
                ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
                Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
                IoCompleteRequest( Irp, IO_NO_INCREMENT );
                return(STATUS_INVALID_DEVICE_REQUEST);
            }

            status = ClusDiskGetRunningDevices(
                      inputData,
                      outputSize
                      );

            Irp->IoStatus.Status = status;
            if ( NT_SUCCESS(status) ) {
                Irp->IoStatus.Information = (inputData[0] + 1) * sizeof(ULONG);
            } else {
                Irp->IoStatus.Information = 0;
            }

            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return(status);
        }

        // Check if device is Cluster Capable (performs normal SCSI operations)
        // NB:  Non-SCSI device must return success on this call!
        case IOCTL_DISK_CLUSTER_NOT_CLUSTER_CAPABLE:
        {
            UCHAR       portNumber;
            BOOLEAN     isCapable;

            //
            // Get the passed in device signature.
            //
            isCapable = TRUE;       // Err on the side of being usable.
            if ( ARGUMENT_PRESENT( inputData ) &&
                 inputSize  >= sizeof(ULONG) ) {

                signature = inputData[0];
                status = GetScsiPortNumber( signature, &portNumber );
                if ( NT_SUCCESS(status) ) {

                    if ( portNumber != 0xff ) {
                        status = IsDiskClusterCapable( portNumber,
                                                       &isCapable);

                    } else {
                        status = STATUS_UNSUCCESSFUL;
                    }
                }

            } else {
                //
                // Default is to fail this IOCTL, which allows us to use the device.
                //
                status = STATUS_UNSUCCESSFUL;
            }
            //
            // Verifier found a problem with the original code.  The status returned
            // wasn't the same as Irp->IoStatus.Status.  The IRP status was always
            // success, but the dispatch routine sometimes returned an error.  This
            // seems to work but verifier says this is invalid.  When I changed the code
            // to update the IRP status with the same returned status, new drives
            // couldn't be seen.  This is because the user mode component uses this
            // IOCTL to indicate the disk is NOT cluster capable, so the user mode
            // code looked for a failure to incidate a cluster disk.
            //

            //
            // Fix for IBM.  The Win2000 2195 code returned from this IOCTL the status
            // of the SCSI miniport IOCTL.  This was returned to DeviceIoControl rather
            // than the status in the IRP.  Changed to make the behavior the same as
            // Win20000 2195.
            //

            //
            // If the SCSI miniport IOCTL succeeds, we return success.  If any of the
            // routines failed while trying to issue the SCSI miniport IOCTL (including
            // issuing the SCSI miniport IOCTL itself), then we return failure.
            //

            Irp->IoStatus.Status = status;
            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

            return(status);
        }

        case IOCTL_DISK_CLUSTER_RESERVE_INFO:
        {
            CDLOG( "IoctlDiskClusterReserveInfo(%p)", DeviceObject );

            status = GetReserveInfo( inputData,
                                     inputSize,
                                     &outputSize );

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = outputSize;

            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

            return status;
        }

        default:
        {
            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_ILLEGAL_FUNCTION;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(STATUS_ILLEGAL_FUNCTION);
        }


    }   // switch

} // ClusDiskRootDeviceControl


NTSTATUS
GetReserveInfo(
    PVOID   InOutBuffer,
    ULONG   InSize,
    ULONG*  OutSize
    )
{
    PRESERVE_INFO           reserveInfo;
    PDEVICE_OBJECT          targetDevice;
    PCLUS_DEVICE_EXTENSION  targetExt;

    NTSTATUS                status;

    ULONG                   signature;

    *OutSize = 0;

    if ( InSize < sizeof(RESERVE_INFO) ||
         InOutBuffer == NULL ) {

        status = STATUS_INVALID_PARAMETER;
        goto FnExit;
    }

    //
    // Make sure the user specified a signature for a valid device.
    //

    signature = *(PULONG)InOutBuffer;
    if ( !AttachedDevice( signature, &targetDevice ) ) {
        status = STATUS_NOT_FOUND;
        goto FnExit;
    }

    targetExt = targetDevice->DeviceExtension;

    //
    // We have a new device here, acquire the RemoveLock if possible.
    //

    status = AcquireRemoveLock(&targetExt->RemoveLock, GetReserveInfo);

    if ( !NT_SUCCESS(status) ) {
        goto FnExit;
    }

    //
    // Return the information about reserves.
    //

    reserveInfo = (PRESERVE_INFO)InOutBuffer;

    reserveInfo->Signature      = targetExt->Signature;
    reserveInfo->ReserveFailure = targetExt->ReserveFailure;

    ACQUIRE_SHARED( &targetExt->ReserveInfoLock );
    reserveInfo->LastReserveEnd = targetExt->LastReserveEnd;
    RELEASE_SHARED( &targetExt->ReserveInfoLock );

    reserveInfo->ArbWriteCount  = targetExt->ArbWriteCount;
    reserveInfo->ReserveCount   = targetExt->ReserveCount;

    KeQuerySystemTime( &reserveInfo->CurrentTime );

    ReleaseRemoveLock(&targetExt->RemoveLock, GetReserveInfo);

    *OutSize = sizeof(RESERVE_INFO);

FnExit:

    return status;

}   // GetReserveInfo


NTSTATUS
SetDiskState(
    PVOID InBuffer,
    ULONG InBufferLength,
    ULONG OutBufferLength,
    ULONG *BytesReturned
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PSET_DISK_STATE_PARAMS  params = (PSET_DISK_STATE_PARAMS)InBuffer;
    PUCHAR                  outBuffer = (PUCHAR)InBuffer;
    PDEVICE_OBJECT          targetDevice;
    PCLUS_DEVICE_EXTENSION  physicalDisk;

    NTSTATUS    status;

    UCHAR       oldDiskState;
    UCHAR       newDiskState;

    BOOLEAN     success;
    BOOLEAN     removeLockAcquired = FALSE;

    *BytesReturned = 0;

    if ( !ARGUMENT_PRESENT(params) ||
         InBufferLength < sizeof(SET_DISK_STATE_PARAMS) ) {

        status = STATUS_INVALID_PARAMETER;
        goto FnExit;
    }

    //
    // Make sure the user specified a signature for a valid device.
    //

    success = AttachedDevice( params->Signature, &targetDevice );

    if ( !success ) {
        status = STATUS_NOT_FOUND;
        goto FnExit;
    }

    physicalDisk = targetDevice->DeviceExtension;

    // We have a new device here, acquire the RemoveLock if possible.

    status = AcquireRemoveLock(&physicalDisk->RemoveLock, SetDiskState);

    if ( !NT_SUCCESS(status) ) {
        goto FnExit;
    }

    removeLockAcquired = TRUE;

    //
    // Save the old disk state.
    //

    oldDiskState = (UCHAR)physicalDisk->DiskState;

    newDiskState = params->NewState;

    ClusDiskPrint((3, "[ClusDisk] RootDeviceControl: Setting state on disk %u (%p), state %s \n",
                   physicalDisk->DiskNumber,
                   targetDevice,
                   DiskStateToString( newDiskState ) ));

    if ( newDiskState > DiskStateMaximum ) {
        status = STATUS_INVALID_PARAMETER;
        goto FnExit;
    }

    if ( DiskOnline == newDiskState ) {
        ASSERT_RESERVES_STARTED( physicalDisk );

        //
        // If current state is offline, then before bringing the disk
        // online, we want to dismount the file systems if they are mounted.
        //

        if ( DiskOffline == physicalDisk->DiskState ) {
            ClusDiskDismountDevice( physicalDisk->DiskNumber, TRUE );
        }
        ONLINE_DISK( physicalDisk );
    } else if ( DiskOffline == newDiskState ) {
        OFFLINE_DISK( physicalDisk );
    } else {

        // There aren't really any other valid states, but this code remains...

        physicalDisk->DiskState = newDiskState;
    }

    CDLOG( "IoctlClusterSetState(%p): old %!diskstate! => new %!diskstate!",
           targetDevice,
           oldDiskState,
           newDiskState );

    ClusDiskPrint((1, "[ClusDisk] RootDeviceControl: disk %u (%p), old %s => new %s \n",
                   physicalDisk->DiskNumber,
                   targetDevice,
                   DiskStateToString( oldDiskState ),
                   DiskStateToString( newDiskState ) ));

    //
    // Optionally return the old state.
    //

    if ( sizeof(SET_DISK_STATE_PARAMS) == OutBufferLength ) {

        // Return the old state in the structure.

        params->OldState = oldDiskState;
        *BytesReturned = sizeof(SET_DISK_STATE_PARAMS);

    } else if ( OutBufferLength >= sizeof(UCHAR) ) {

        // Return the old state as a single UCHAR.

        *outBuffer = (UCHAR)oldDiskState;
        *BytesReturned = sizeof(UCHAR);
    }

FnExit:

    if ( removeLockAcquired ) {
        ReleaseRemoveLock(&physicalDisk->RemoveLock, SetDiskState);
    }

    return status;

}   // SetDiskState






NTSTATUS
ClusDiskShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called for a shutdown and flush IRPs.  These are sent by the
    system before it actually shuts down or when the file system does a flush.

Arguments:

    DriverObject - Pointer to device object to being shutdown by system.
    Irp          - IRP involved.

Return Value:

    NT Status

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDisk =
                               deviceExtension->PhysicalDevice->DeviceExtension;
    NTSTATUS    status;

    status = AcquireRemoveLock( &deviceExtension->RemoveLock, Irp);

    if ( !NT_SUCCESS(status) ) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Return error if device is our root device.
    //
    if ( deviceExtension->BusType == RootBus ) {
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    if ( physicalDisk->DiskState != DiskOnline ) {
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_OFF_LINE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_DEVICE_OFF_LINE);
    }

    //
    // Make sure the device attach completed.
    //
    status = WaitForAttachCompletion( deviceExtension,
                                      TRUE,             // Wait
                                      TRUE );           // Also check physical device
    if ( !NT_SUCCESS( status ) ) {
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Set current stack back one.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

} // ClusDiskShutdownFlush()



NTSTATUS
ClusDiskNewDiskCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )

/*++

Routine Description:

    This is the completion routine for IOCTL_DISK_FIND_NEW_DEVICES.

Arguments:

    DeviceObject - Pointer to device object to being shutdown by system.
    Irp          - IRP involved.
    Context      - Previous disk count.

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension =
        (PCLUS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION      physicalDisk =
                                    deviceExtension->PhysicalDevice->DeviceExtension;

    //
    // Find new disk devices and attach to disk and all of its partitions.
    //

    ClusDiskNextDisk = Context;
    ClusDiskScsiInitialize(DeviceObject->DriverObject, Context, 1);

    // There are two RemoveLocks held.  Release them both.

    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }
    return Irp->IoStatus.Status;

} // ClusDiskNewDiskCompletion



NTSTATUS
ClusDiskSetLayoutCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )

/*++

Routine Description:

    This is the completion routine for IOCTL_SET_DRIVE_LAYOUT and
    IOCTL_DISK_SET_DRIVE_LAYOUT_EX.  This will routine will make sure
    the cached drive layout info structure is updated.

Arguments:

    DeviceObject - Pointer to device object
    Irp          - IRP involved.
    Context      - Not used

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension =
        (PCLUS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION      physicalDisk =
                                    deviceExtension->PhysicalDevice->DeviceExtension;
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo = NULL;

    //
    // Update the cached drive layout.
    //

    GetDriveLayout( physicalDisk->DeviceObject,
                    &driveLayoutInfo,
                    TRUE,                           // Update cached drive layout
                    FALSE );                        // Don't flush storage drivers cached drive layout

    if ( driveLayoutInfo ) {
        ExFreePool( driveLayoutInfo );
    }

    // There are two RemoveLocks held.  Release them both.

    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }
    return Irp->IoStatus.Status;

} // ClusDiskSetLayoutCompletion


BOOLEAN
ClusDiskAttached(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG        DiskNumber
    )

/*++

Routine Description:

    This routine checks if clusdisk in in the path.

Arguments:

    DeviceObject - pointer the device object to check if ClusDisk is present.

    DiskNumber - the disk number for this device object.

Return Value:

    TRUE - if ClusDisk is attached.

    FALSE - if ClusDisk is not attached.

--*/

{
    PIRP                    irp;
    PKEVENT                 event;
    IO_STATUS_BLOCK         ioStatusBlock;
    NTSTATUS                status;
    WCHAR                   deviceNameBuffer[MAX_PARTITION_NAME_LENGTH];
    UNICODE_STRING          deviceNameString;
    OBJECT_ATTRIBUTES       objectAttributes;
    HANDLE                  fileHandle;
    HANDLE                  eventHandle;

    if ( DeviceObject->DeviceType  == FILE_DEVICE_DISK_FILE_SYSTEM ) {
        //
        // Create event for notification.
        //
        status = ZwCreateEvent( &eventHandle,
                                EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to create event, status %lx\n",
                    status ));
            return(TRUE);
        }
        //
        // Open a file handle and perform the request
        //

        if ( FAILED( StringCchPrintfW( deviceNameBuffer,
                                       RTL_NUMBER_OF(deviceNameBuffer),
                                       DEVICE_PARTITION_NAME,
                                       DiskNumber,
                                       0 ) ) ) {
            ZwClose(eventHandle);
            return TRUE;
        }

        WCSLEN_ASSERT( deviceNameBuffer );

        RtlInitUnicodeString(&deviceNameString,
                             deviceNameBuffer);

        //
        // Setup object attributes for the file to open.
        //
        InitializeObjectAttributes(
                    &objectAttributes,
                    &deviceNameString,
                    OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                    NULL,
                    NULL
                    );

        status = ZwCreateFile( &fileHandle,
                               FILE_READ_DATA,
                               &objectAttributes,
                               &ioStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0 );
        ASSERT( status != STATUS_PENDING );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                1,
                "[ClusDisk] DiskAttached, failed to open file %ws. Error %lx.\n",
                deviceNameBuffer,
                status ));
            ZwClose(eventHandle);
            return(TRUE);
        }

        status = ZwDeviceIoControlFile( fileHandle,
                                        eventHandle,
                                        NULL,
                                        NULL,
                                        &ioStatusBlock,
                                        IOCTL_DISK_CLUSTER_TEST,
                                        NULL,
                                        0,
                                        NULL,
                                        0 );

        if ( status == STATUS_PENDING ) {
            status = ZwWaitForSingleObject(eventHandle,
                                           FALSE,
                                           NULL);
            ASSERT( NT_SUCCESS(status) );
            status = ioStatusBlock.Status;
        }

        ZwClose( fileHandle );
        ZwClose( eventHandle );
        return((BOOLEAN)status == STATUS_SUCCESS);
    }

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( event == NULL ) {
        return(FALSE);
    }

    //
    // Find out if ClusDisk is already in device stack.
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_CLUSTER_TEST,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        FALSE,
                                        event,
                                        &ioStatusBlock);

    if (!irp) {
        ExFreePool( event );
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to build IRP to test for ClusDisk.\n"
                    ));
        return(FALSE);
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(event,
                      NotificationEvent,
                      FALSE);

    status = IoCallDriver(DeviceObject,
                          irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);

        status = ioStatusBlock.Status;
    }
    ExFreePool( event );

    if ( NT_SUCCESS(status) ) {
        return(TRUE);
    }

    return(FALSE);

} // ClusDiskAttached



BOOLEAN
ClusDiskVerifyAttach(
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine verifies if ClusDisk is attached, and whether it should be
    detached.

Arguments:

    DeviceObject - pointer to a ClusDisk device object to verify if it is
            and should remain attached.

Return Value:

    TRUE - if device is still attached.

    FALSE - if device was detached.

--*/

{
    NTSTATUS                    status;
    PDEVICE_OBJECT              deviceObject;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo;
    UNICODE_STRING              signatureName;

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // The following call really can't fail!
    //
    if ( !ClusDiskAttached( DeviceObject, deviceExtension->DiskNumber ) ) {
        return(FALSE);
    }

    //
    // Check if this device is a valid attachment.
    //
    if ( deviceExtension->AttachValid ) {
        return(TRUE);
    }

    //
    // Get device object for the physical (partition0) device.
    //
    deviceObject = deviceExtension->PhysicalDevice;

    //
    // Otherwise, we're not sure... verify it.
    //

    //
    // Read the partition info to get the signature. If this device is
    // a valid attachment then update the ClusDisk DeviceObject. Otherwise,
    // detach or leave attached but in the UNKNOWN state.
    //

    driveLayoutInfo = ClusDiskGetPartitionInfo( deviceExtension );
    if ( driveLayoutInfo != NULL ) {

        deviceExtension->Signature = driveLayoutInfo->Mbr.Signature;
        if ( MatchDevice( driveLayoutInfo->Mbr.Signature, NULL ) ) {
            //
            // We assume that the device object we have is for the partition0
            // device object.
            //
#if 0
            ClusDiskPrint((
                1,
                "[ClusDisk] We are going to attach signature %08lx to DevObj %p \n",
                driveLayoutInfo->Mbr.Signature,
                DeviceObject ));
#endif
            AddAttachedDevice( driveLayoutInfo->Mbr.Signature,
                               deviceObject );

            //
            // Need to write disk info into the signatures list.
            //
            status = ClusDiskInitRegistryString(
                                              &signatureName,
                                              CLUSDISK_SIGNATURE_KEYNAME,
                                              wcslen(CLUSDISK_SIGNATURE_KEYNAME)
                                             );
            if ( NT_SUCCESS(status) ) {
                ClusDiskWriteDiskInfo( driveLayoutInfo->Mbr.Signature,
                                       deviceExtension->DiskNumber,
                                       CLUSDISK_SIGNATURE_KEYNAME
                                     );
                ExFreePool( signatureName.Buffer );
            }
        } else {
            ClusDiskDetachDevice( driveLayoutInfo->Mbr.Signature,
                                  DeviceObject->DriverObject
                                 );
        }
        ExFreePool( driveLayoutInfo );
    }

    return(TRUE);

} // ClusDiskVerifyAttach



VOID
ClusDiskWriteDiskInfo(
    IN ULONG Signature,
    IN ULONG DiskNumber,
    IN LPWSTR SubKeyName
    )

/*++

Routine Description:

    Write the disk name for the given signature.

Arguments:

    Signature - the signature key to store the disk name under.

    DiskNumber - the disk number to assign to the given signature. It is
            assumed that this is always describing partition0 on the disk.

    SubKeyName - the clusdisk parameters subkey name in which to write
            this information.

Return Value:

    None.

--*/

{
    UNICODE_STRING          keyName;
    WCHAR                   keyNameBuffer[MAXIMUM_FILENAME_LENGTH];
    WCHAR                   signatureBuffer[64];
    HANDLE                  signatureHandle;
    OBJECT_ATTRIBUTES       objectAttributes;
    NTSTATUS                status;

    keyName.Length = 0;
    keyName.MaximumLength = sizeof( keyNameBuffer );
    keyName.Buffer = keyNameBuffer;

    RtlAppendUnicodeToString( &keyName, ClusDiskRegistryPath.Buffer );

    RtlAppendUnicodeToString( &keyName, SubKeyName );

    if ( FAILED( StringCchPrintfW( signatureBuffer,
                                   RTL_NUMBER_OF(signatureBuffer),
                                   L"\\%08lX",
                                   Signature ) ) ) {
        return;
    }

    WCSLEN_ASSERT( signatureBuffer );

    RtlAppendUnicodeToString( &keyName, signatureBuffer );
    keyName.Buffer[ keyName.Length / sizeof(WCHAR) ] = UNICODE_NULL;

    //
    // Setup the object attributes for the Parameters\SubKeyName\xyz key.
    //

    InitializeObjectAttributes(
            &objectAttributes,
            &keyName,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

    //
    // Open Parameters\SubKeyName\xyz Key.
    //

    status = ZwOpenKey(
                    &signatureHandle,
                    KEY_READ | KEY_WRITE,
                    &objectAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] WriteDiskInfo: Failed to open %wZ registry key. Status: %lx\n",
                    &keyName,
                    status
                    ));
        return;
    }

    //
    // Write the disk name.
    //
    status = ClusDiskAddDiskName( signatureHandle, DiskNumber );

    ZwClose( signatureHandle );

    return;

} // ClusDiskWriteDiskInfo



NTSTATUS
GetDriveLayout(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PDRIVE_LAYOUT_INFORMATION_EX *DriveLayout,
    BOOLEAN UpdateCachedLayout,
    BOOLEAN FlushStorageDrivers
    )

/*++

Routine Description:

    Return the DRIVE_LAYOUT_INFORMATION_EX for a given device object.
    Caller is responsible for freeing this drive layout buffer.

    Note on PhysicalDiskObject parameter: this should only be set to TRUE
    when the DeviceObject parameter is for physical disk (partition 0 device)
    AND we want to tell storage drivers to flush their cached drive layout.
    If should never be set to TRUE if the device object isn't a physical disk.

    We could have a physical disk but still want to use the storage drivers
    cached layout when we know it is current.  For example, if the drive layout
    was just set, we don't need to set this flag.  Or we may be in a code path
    that already told the storage drivers to set the drive layout, so we don't
    need to do it again.

Arguments:

    DeviceObject - The specific device object to return info about

    BytesPerSector - The number of bytes per sector on this disk

    DriveLayout - Pointer to a DRIVE_LAYOUT_INFORMATION_EX structure to return the info

    UpdateCachedLayout - Update the drive layout stored in the device extension (if any)
                         with a fresh copy.

    FlushStorageDrivers - Indicates whether storage drivers should flush their cached
                          drive layout data.  This should only be set to true when the
                          DeviceObject is a physical disk (partition 0 device).

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION      deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION      physicalDisk = deviceExtension->PhysicalDevice->DeviceExtension;
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo = NULL;
    PDRIVE_LAYOUT_INFORMATION_EX    cachedDriveLayoutInfo = NULL;

    NTSTATUS                    status = STATUS_SUCCESS;
    ULONG                       driveLayoutSize;

    BOOLEAN                     cachedCopy = FALSE;
    BOOLEAN                     freeLayouts = FALSE;

    *DriveLayout = NULL;

    //
    // Allocate a drive layout buffer.
    //

    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
        (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION_EX));

    driveLayoutInfo = ExAllocatePool(NonPagedPoolCacheAligned,
                                     driveLayoutSize
                                     );

    if ( !driveLayoutInfo ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] GetDriveLayout: Failed to allocate drive layout structure. \n"
                        ));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    if ( UpdateCachedLayout ) {

        //
        // If cached buffer needs to be updated, free the existing buffer.
        //

        ACQUIRE_EXCLUSIVE( &physicalDisk->DriveLayoutLock );

        if ( physicalDisk->DriveLayout ) {
            ExFreePool( physicalDisk->DriveLayout );
            physicalDisk->DriveLayout = NULL;
        }
        physicalDisk->DriveLayoutSize = 0;

        RELEASE_EXCLUSIVE( &physicalDisk->DriveLayoutLock );

    } else {

        //
        // If cached copy exists, use that instead of getting a new version.
        //

        ACQUIRE_SHARED( &physicalDisk->DriveLayoutLock );

        if ( physicalDisk->DriveLayout ) {

            ClusDiskPrint(( 3,
                            "[ClusDisk] GetDriveLayout: using cached drive layout information for DE %p \n",
                            physicalDisk
                            ));

            RtlCopyMemory( driveLayoutInfo,
                           physicalDisk->DriveLayout,
                           physicalDisk->DriveLayoutSize );

            *DriveLayout = driveLayoutInfo;
            cachedCopy = TRUE;
        }

        RELEASE_SHARED( &physicalDisk->DriveLayoutLock );

        if ( cachedCopy ) {
            goto FnExit;
        }
    }

    freeLayouts = TRUE;

    //
    // Allocate a drive layout buffer for saving in device extension.
    //

    cachedDriveLayoutInfo = ExAllocatePool(NonPagedPoolCacheAligned,
                                           driveLayoutSize
                                           );

    if ( !cachedDriveLayoutInfo ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] GetDriveLayout: Failed to allocate cached drive layout structure. \n"
                        ));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    //
    // If the device is disk (partition 0), tell the storage drivers to flush their
    // cached drive layout.  Sometimes we don't need to tell the storage drivers to
    // flush their cache, even when we have a physical disk.  For example, we may know
    // that we previously told them to flush, so we don't need to do so now.
    //

    if ( FlushStorageDrivers ) {
        SimpleDeviceIoControl( DeviceObject,
                               IOCTL_DISK_UPDATE_PROPERTIES,
                               NULL,
                               0,
                               NULL,
                               0 );
    }

    status = SimpleDeviceIoControl(DeviceObject,
                                   IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                   NULL,
                                   0,
                                   cachedDriveLayoutInfo,
                                   driveLayoutSize
                                   );

    if ( !NT_SUCCESS(status) ) {

        //
        // Couldn't get the drive layout.  Free the temporary buffer, set the caller's
        // drive layout pointer to NULL, and return the error status to the caller.
        //

        ClusDiskPrint(( 1,
                        "[ClusDisk] GetDriveLayout: Failed to issue IoctlDiskGetDriveLayout. %08X\n",
                        status
                        ));

        CDLOG( "GetDriveLayout(%p): failed %!status!",
               DeviceObject,
               status );

        *DriveLayout = NULL;
        freeLayouts = TRUE;

        goto FnExit;

    }

    //
    // Successfully retrieved drive layout.  Save the new layout in the device
    // extension.  Copy the layout into the user's buffer.
    //

    ClusDiskPrint(( 3,
                    "[ClusDisk] GetDriveLayout: updating drive layout for DE %p \n",
                    physicalDisk
                    ));

    CDLOG( "GetDriveLayout(%p): updating drive layout for DE %p ",
           DeviceObject,
           physicalDisk );

    freeLayouts = FALSE;

    ACQUIRE_EXCLUSIVE( &physicalDisk->DriveLayoutLock );

    if ( physicalDisk->DriveLayout ) {
        ExFreePool( physicalDisk->DriveLayout );
        physicalDisk->DriveLayout = NULL;
    }
    physicalDisk->DriveLayout = cachedDriveLayoutInfo;
    physicalDisk->DriveLayoutSize = driveLayoutSize;

    RELEASE_EXCLUSIVE( &physicalDisk->DriveLayoutLock );

    RtlCopyMemory( driveLayoutInfo,
                   cachedDriveLayoutInfo,
                   driveLayoutSize );

    //
    // Point the user to the drive layout buffer and return success.  Caller is
    // responsible for freeing the buffer when they are done with it.
    //

    *DriveLayout = driveLayoutInfo;

FnExit:

    if ( freeLayouts ) {

        if ( driveLayoutInfo ) {
            ExFreePool( driveLayoutInfo );
        }

        if ( cachedDriveLayoutInfo ) {
            ExFreePool( cachedDriveLayoutInfo );
        }
    }

    return status;

} // GetDriveLayout



MEDIA_TYPE
GetMediaType(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Return the MediaType for a given device object.

Arguments:

    DeviceObject - The specific device object to return info about

Return Value:

    Media Type or Unknown if not known.

--*/

{
    NTSTATUS        status;
    MEDIA_TYPE      mediaType = Unknown;

    status = GetDiskGeometry( DeviceObject, &mediaType );

    if ( !NT_SUCCESS( status ) ) {
        mediaType = Unknown;
    }

    return mediaType;

} // GetMediaType



NTSTATUS
GetScsiAddress(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_ADDRESS ScsiAddress
    )

/*++

Routine Description:

    Return the SCSI_ADDRESS for a given device object.

Arguments:

    DeviceObject - The specific device object to return info about

    ScsiAddress - Pointer to a SCSI_ADDRESS structure to return the info

Return Value:

    NTSTATUS

--*/

{
    PIRP                irp;
    PKEVENT             event;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( event == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    // Find out if this is on a SCSI bus. Note, that if this device
    // is not a SCSI device, it is expected that the following
    // IOCTL will fail!
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_SCSI_GET_ADDRESS,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        ScsiAddress,
                                        sizeof(SCSI_ADDRESS),
                                        FALSE,
                                        event,
                                        &ioStatusBlock);

    if (!irp) {
        ExFreePool( event );
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to build IRP to read SCSI ADDRESS.\n"
                    ));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(event,
                      NotificationEvent,
                      FALSE);

    status = IoCallDriver(DeviceObject,
                          irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);

        status = ioStatusBlock.Status;
    }
    ExFreePool( event );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to read SCSI_ADDRESS. %08X\n",
                    status
                    ));

        CDLOG( "GetScsiAddress(%p): failed %!status!",
               DeviceObject,
               status );
    }

    return(status);

} // GetScsiAddress



PDRIVE_LAYOUT_INFORMATION_EX
ClusDiskGetPartitionInfo(
    PCLUS_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Return the Partition Layout Information for particular device extension.

    Only return a valid partition layout for MBR disks - NULL for any other
    kind of disk.

Arguments:

    DeviceExtension - The specific device extension to return information.

Return Value:

    Pointer to an allocated partition layout information structure for MBR disk.
    NULL on failure.

Notes:

    The caller is responsible for freeing the allocated buffer.

--*/

{
    PIRP                        irp;
    NTSTATUS                    status = STATUS_IO_TIMEOUT;
    ULONG                       driveLayoutInfoSize;
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo;
    ULONG                       retryCount = MAX_RETRIES;

    driveLayoutInfoSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
        (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION_EX));

    driveLayoutInfo = ExAllocatePool(NonPagedPoolCacheAligned,
                                   driveLayoutInfoSize);

    if ( !driveLayoutInfo ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to allocate PartitionInfo structure to read drive layout.\n"
                    ));
        return(NULL);
    }

    while ( retryCount-- ) {

        if ( (retryCount != (MAX_RETRIES-1)) &&
             (status != STATUS_DEVICE_BUSY) ) {

            ClusDiskLogError( RootDeviceObject->DriverObject,   // Use RootDeviceObject not DevObj
                              RootDeviceObject,
                              DeviceExtension->ScsiAddress.PathId,           // Sequence number
                              0,                            // Major function code
                              0,                            // Retry count
                              ID_GET_PARTITION,             // Unique error
                              STATUS_SUCCESS,
                              CLUSDISK_RESET_BUS_REQUESTED,
                              0,
                              NULL );

            ResetScsiDevice( NULL, &DeviceExtension->ScsiAddress );
        }

        status = SimpleDeviceIoControl( DeviceExtension->TargetDeviceObject,
                                        IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                        NULL,
                                        0,
                                        driveLayoutInfo,
                                        driveLayoutInfoSize );

        if ( !NT_SUCCESS(status) ) {
            if ( (status != STATUS_DEVICE_OFF_LINE) &&
                 (status != STATUS_DATA_OVERRUN) ) {
                ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to read PartitionInfo. Status %lx\n",
                    status
                        ));
            }
            ClusDiskGetDiskGeometry( DeviceExtension->TargetDeviceObject );
            continue;
        } else {

            // Return valid partition only for MBR disks.  For any other
            // type of partition, set an error which causes NULL to return
            // from this function.

            if ( PARTITION_STYLE_MBR == driveLayoutInfo->PartitionStyle ) {
                DeviceExtension->Signature = driveLayoutInfo->Mbr.Signature;
            } else {
                ClusDiskPrint(( 1,
                                "[ClusDisk] GetPartitionInfo: skipping non-MBR disk \n" ));
                CDLOG( "ClusDiskGetPartitionInfo: skipping non-MBR disk" );
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;
        }
    }

    if ( NT_SUCCESS(status) ) {
        return(driveLayoutInfo);
    } else {
        ExFreePool(driveLayoutInfo);
        return(NULL);
    }

} // ClusDiskGetPartitionInfo



BOOLEAN
AddAttachedDevice(
    IN ULONG Signature,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Indicate that this device is now attached.

Arguments:

    Signature - The signature for the device we just attached.

    DeviceObject - The device object for the partition0 device object.

Return Value:

    TRUE - Signature is already on the device list or has been added.
           successfully.

    FALSE - Signature was not on the device list and we failed to add it.

--*/

{
    PDEVICE_LIST_ENTRY          deviceEntry;
    PCLUS_DEVICE_EXTENSION      deviceExtension;

    // 2000/02/05: stevedz - added synchronization.

    ACQUIRE_EXCLUSIVE( &ClusDiskDeviceListLock );

    deviceEntry = ClusDiskDeviceList;

    while ( deviceEntry != NULL ) {
        if ( Signature == deviceEntry->Signature ) {
            if ( deviceEntry->Attached ) {
                ClusDiskPrint((
                        1,
                        "[ClusDisk] Attaching to %lx more than once!\n",
                        Signature ));
            }
            if ( DeviceObject ) {
                deviceExtension = DeviceObject->DeviceExtension;
                ASSERT(deviceExtension->PhysicalDevice == DeviceObject);
                deviceEntry->Attached = TRUE;
                deviceEntry->DeviceObject = DeviceObject;
                deviceExtension->AttachValid = TRUE;
                deviceExtension->Signature = Signature;
            }
            RELEASE_EXCLUSIVE( &ClusDiskDeviceListLock );
            return(TRUE);
        }
        deviceEntry = deviceEntry->Next;
    }

    deviceEntry = ExAllocatePool(
                                NonPagedPool,
                                sizeof(DEVICE_LIST_ENTRY) );
    if ( deviceEntry == NULL ) {
        ClusDiskPrint((1,
                    "[ClusDisk] Failed to allocate device entry structure for signature %08lX\n",
                    Signature));
        RELEASE_EXCLUSIVE( &ClusDiskDeviceListLock );
        return(FALSE);
    }

    RtlZeroMemory( deviceEntry, sizeof(DEVICE_LIST_ENTRY) );

    deviceEntry->Signature = Signature;
    deviceEntry->LettersAssigned = FALSE;
    deviceEntry->DeviceObject = DeviceObject;

    if ( DeviceObject == NULL ) {
        deviceEntry->Attached = FALSE;
    } else {
        deviceEntry->Attached = TRUE;
    }

    //
    // Link new entry into list.
    //
    deviceEntry->Next = ClusDiskDeviceList;
    ClusDiskDeviceList = deviceEntry;

    RELEASE_EXCLUSIVE( &ClusDiskDeviceListLock );
    return(TRUE);

} // AddAttachedDevice


BOOLEAN
MatchDevice(
    IN ULONG Signature,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    Check to see if the Signature of the specified device is one
    that we should control.

Arguments:

    Signature - The signature for the device we are checking.

    DeviceObject - Pointer to a return value for the device object.

Return Value:

    TRUE - if this Signature is for a device we should control.

    FALSE - if this Signature is NOT for a device we should control.

--*/

{
    PDEVICE_LIST_ENTRY deviceEntry;

    if ( SystemDiskSignature == Signature ) {
        if ( ARGUMENT_PRESENT(DeviceObject) ) {
            *DeviceObject = NULL;
        }
        return(FALSE);
    }

    // 2000/02/05: stevedz - added synchronization.

    ACQUIRE_SHARED( &ClusDiskDeviceListLock );

    deviceEntry = ClusDiskDeviceList;

    while ( deviceEntry != NULL ) {
        if ( Signature == deviceEntry->Signature ) {
            if ( ARGUMENT_PRESENT(DeviceObject) ) {
                *DeviceObject = deviceEntry->DeviceObject;
            }
            RELEASE_SHARED( &ClusDiskDeviceListLock );
            return(TRUE);
        }
        deviceEntry = deviceEntry->Next;
    }

    if ( ARGUMENT_PRESENT(DeviceObject) ) {
        *DeviceObject = NULL;
    }
    RELEASE_SHARED( &ClusDiskDeviceListLock );
    return(FALSE);

} // MatchDevice



NTSTATUS
ClusDiskGetDiskGeometry(
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Retry getting disk geometry.

Arguments:

    DeviceObject - the target device object.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS    status;
    NTSTATUS    tmpStatus;
    ULONG       retryCount = 2;
    SCSI_ADDRESS scsiAddress;

    if ( DeviceObject->DeviceType  == FILE_DEVICE_DISK_FILE_SYSTEM ) {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    do {
        status = GetDiskGeometry( DeviceObject, NULL );
        if ( status == STATUS_DATA_OVERRUN ) {
            tmpStatus = GetScsiAddress( DeviceObject, &scsiAddress );
            if ( NT_SUCCESS(tmpStatus) &&
                 (status != STATUS_DEVICE_BUSY) &&
                 (retryCount > 1) ) {

                ClusDiskLogError( RootDeviceObject->DriverObject,   // Use RootDeviceObject not DevObj
                                  RootDeviceObject,
                                  scsiAddress.PathId,           // Sequence number
                                  0,                            // Major function code
                                  0,                            // Retry count
                                  ID_GET_GEOMETRY,              // Unique error
                                  STATUS_SUCCESS,
                                  CLUSDISK_RESET_BUS_REQUESTED,
                                  0,
                                  NULL );
                ResetScsiDevice( NULL, &scsiAddress );
            }
        }
    } while ( --retryCount &&
              (status == STATUS_DATA_OVERRUN) );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] Failed to read disk geometry, error %lx.\n",
                        status ));
    }

    return(status);

} // ClusDiskGetDiskGeometry



NTSTATUS
GetDiskGeometry(
    PDEVICE_OBJECT DeviceObject,
    PMEDIA_TYPE MediaType
    )

/*++

Routine Description:

    Get the disk geometry for a target device.
    Returned data is thrown away.

Arguments:

    DeviceObject - the target device object.

    MediaType - Pointer to return device MediaType.  Optional.

Return Value:

    NTSTATUS

--*/

{
    PDISK_GEOMETRY      diskGeometryBuffer;
    NTSTATUS            status;
    PKEVENT             event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatusBlock;

    if ( MediaType ) {
        *MediaType = Unknown;
    }

    //
    // Allocate DISK_GEOMETRY buffer from nonpaged pool.
    //

    diskGeometryBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                        sizeof(DISK_GEOMETRY));

    if (!diskGeometryBuffer) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( !event ) {
        ExFreePool(diskGeometryBuffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Perform the get drive geometry synchronously.
    //

    KeInitializeEvent(event,
                      NotificationEvent,
                      FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        diskGeometryBuffer,
                                        sizeof(DISK_GEOMETRY),
                                        FALSE,
                                        event,
                                        &ioStatusBlock);

    if ( !irp ) {
        ExFreePool(diskGeometryBuffer);
        ExFreePool(event);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(DeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
        status = ioStatusBlock.Status;
    }

    ExFreePool(event);

    //
    // Return MediaType info if the caller requests.
    //

    if ( MediaType ) {
        *MediaType = diskGeometryBuffer->MediaType;
    }

    //
    // Deallocate buffer.
    //
    ExFreePool(diskGeometryBuffer);

    return(status);

} // GetDiskGeometry



NTSTATUS
ReserveScsiDevice(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PVOID Context
    )

/*++

Routine Description:

    Reserve a SCSI device using asynchronous I/O.

Arguments:

    DeviceExtension - The device extension for the device to reserve.

    Context - Optional pointer to ARB_RESERVE_COMPLETION struture.
              If NULL, a new Reserve is being sent.  If non-NULL,
              a Reserve is being retried.  In either case, a new
              IRP is allocated.

Return Value:

    NTSTATUS

--*/

{
    PIRP                        irp = NULL;
    PIO_STACK_LOCATION          irpSp;
    PARB_RESERVE_COMPLETION     arbContext = NULL;

    NTSTATUS            status;

    CDLOGF( RESERVE,"ReserveScsiDevice(%p): Entry DiskNo %d Sig %08x Context %p",
            DeviceExtension->DeviceObject,
            DeviceExtension->DiskNumber,
            DeviceExtension->Signature,
            Context );

    //
    // Acquire remove lock for this device.  If the IRP is sent, it will be
    // released in the completion routine.
    //

    status = AcquireRemoveLock( &DeviceExtension->RemoveLock, ReserveScsiDevice );
    if ( !NT_SUCCESS(status) ) {
        goto FnExit;
    }

    //
    // If context is non-null, then we are retrying this I/O.  If null,
    // we need to allocate a context structure for the write.
    //

    if ( Context ) {

        ClusDiskPrint(( 1,
                        "[ClusDisk] Retry Reserve  IRP %p for DO %p  DiskNo %u  Sig %08X \n",
                        irp,
                        DeviceExtension->DeviceObject,
                        DeviceExtension->DiskNumber,
                        DeviceExtension->Signature ));

        arbContext = Context;
        arbContext->IoEndTime.QuadPart = (ULONGLONG) 0;

    } else {

        arbContext = ExAllocatePool( NonPagedPool, sizeof(ARB_RESERVE_COMPLETION) );

        if ( !arbContext ) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            ReleaseRemoveLock( &DeviceExtension->RemoveLock, ReserveScsiDevice );
            goto FnExit;
        }

        RtlZeroMemory( arbContext, sizeof(ARB_RESERVE_COMPLETION) );

        arbContext->RetriesLeft = 1;
        arbContext->LockTag = ReserveScsiDevice;
        arbContext->DeviceObject = DeviceExtension->DeviceObject;
        arbContext->DeviceExtension = DeviceExtension;
        arbContext->Type = ArbIoReserve;
        arbContext->FailureRoutine = HandleReserveFailure;
        arbContext->RetryRoutine = ReserveScsiDevice;
        arbContext->PostCompletionRoutine = CheckReserveTiming;
    }

    KeQuerySystemTime( &arbContext->IoStartTime );

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp( DeviceExtension->TargetDeviceObject->StackSize, FALSE );
    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        ExFreePool( arbContext );
        ReleaseRemoveLock( &DeviceExtension->RemoveLock, ReserveScsiDevice );
        goto FnExit;
    }

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_STORAGE_RESERVE;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    IoSetCompletionRoutine( irp,
                            ArbReserveCompletion,
                            arbContext,
                            TRUE,
                            TRUE,
                            TRUE );

    InterlockedIncrement( &DeviceExtension->ReserveCount );

    ClusDiskPrint(( 4,
                    "[ClusDisk] Reserve  IRP %p for DO %p  DiskNo %u  Sig %08X \n",
                    irp,
                    DeviceExtension->DeviceObject,
                    DeviceExtension->DiskNumber,
                    DeviceExtension->Signature ));

    status = IoCallDriver( DeviceExtension->TargetDeviceObject,
                           irp );

    //
    // If pending is returned, we need to return success so the caller
    // will do the right thing.
    //

    if ( STATUS_PENDING == status ) {
        status = STATUS_SUCCESS;
    }

FnExit:

    CDLOGF(RESERVE,"ReserveScsiDevice(%p): Exit => %!status!",
            DeviceExtension->DeviceObject,
            status );

    return status;

}   // ReserveScsiDevice


NTSTATUS
CheckReserveTiming(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PVOID Context
    )
/*++

Routine Description:

    Routine called when reserve completes successfully.

    Gets the current time, logs some info to tracing file, and
    saves the reserve completion time in device extension.

Arguments:

    DeviceExtension - The device extension for the device to reserve.

    Context - Pointer to ARB_RESERVE_COMPLETION struture.

Return Value:

    STATUS_SUCCESS

--*/
{
    PARB_RESERVE_COMPLETION     arbContext = Context;

    KIRQL               irql;
    PLIST_ENTRY         listEntry;
    PIRP                irp;
    LARGE_INTEGER       currentTime;
    LARGE_INTEGER       timeDelta;

    KeQuerySystemTime( &currentTime );

    timeDelta.QuadPart = ( currentTime.QuadPart - arbContext->IoStartTime.QuadPart );
    if (timeDelta.QuadPart > 500 * 10000) {
       timeDelta.QuadPart /= 10000;
       ClusDiskPrint(( 1,
                       "[ClusDisk] DiskNo %u Sig %08X, %u ms spent in ReserveScsiDevice\n",
                       DeviceExtension->DiskNumber,
                       DeviceExtension->Signature,
                       timeDelta.LowPart ));
       CDLOGF( RESERVE, "ClusDiskReservationWorker: LongTimeInThisReserve DevObj %p DiskNo %u timeDelta %d ms",
               DeviceExtension->DeviceObject,
               DeviceExtension->DiskNumber,
               timeDelta.LowPart );
    }
    timeDelta.QuadPart = ( currentTime.QuadPart - DeviceExtension->LastReserveStart.QuadPart );
    if (timeDelta.QuadPart > 3500 * 10000) {
       timeDelta.QuadPart /= 10000;
       ClusDiskPrint(( 1,
                       "[ClusDisk] DiskNo %u  Sig %08X, %u ms since last reserve\n",
                       DeviceExtension->DiskNumber,
                       DeviceExtension->Signature,
                       timeDelta.LowPart ));
       CDLOGF( RESERVE, "ClusDiskReservationWorker: LongTimeBetweenReserves DevObj %p DiskNo %u timeDelta %d ms",
               DeviceExtension->DeviceObject,
               DeviceExtension->DiskNumber,
               timeDelta.LowPart );
    }

    ACQUIRE_EXCLUSIVE( &DeviceExtension->ReserveInfoLock );
    KeQuerySystemTime( &DeviceExtension->LastReserveEnd );
    RELEASE_EXCLUSIVE( &DeviceExtension->ReserveInfoLock );

    return STATUS_SUCCESS;

}   // CheckReserveTiming


NTSTATUS
HandleReserveFailure(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PVOID Context
    )
/*++

Routine Description:

    Routine called when reserve fails.  Another routine handled
    retrying the reserve if it qualified for a retry.

    Save the failure status in the device extension.
    Complete any pending I/O requests so cluster software knows
    the reservation was lost.

Arguments:

    DeviceExtension - The device extension for the device to reserve.

    Context - Pointer to ARB_RESERVE_COMPLETION struture.

Return Value:

    STATUS_SUCCESS

--*/
{
    PARB_RESERVE_COMPLETION     arbContext = Context;
    PIRP                        irp;
    PLIST_ENTRY                 listEntry;

    KIRQL                       irql;

    ClusDiskPrint(( 1,
                    "[ClusDisk] Lost reservation for DiskNo %u Sig %08lx, status %lx.\n",
                    DeviceExtension->DiskNumber,
                    DeviceExtension->Signature,
                    arbContext->FinalStatus ));

    CDLOGF( RESERVE, "ClusDiskReservationWorker: LostReserve DO %p DiskNo %u status %!status!",
            DeviceExtension->DeviceObject,
            DeviceExtension->DiskNumber,
            arbContext->FinalStatus );

    IoAcquireCancelSpinLock( &irql );
    KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);
    DeviceExtension->ReserveTimer = 0;
    DeviceExtension->ReserveFailure = arbContext->FinalStatus;

    //
    // Signal all waiting Irp's
    //
    while ( !IsListEmpty( &DeviceExtension->WaitingIoctls ) ) {
        listEntry = RemoveHeadList( &DeviceExtension->WaitingIoctls );
        irp = CONTAINING_RECORD( listEntry,
                                 IRP,
                                 Tail.Overlay.ListEntry );
        ClusDiskCompletePendingRequest(irp, arbContext->FinalStatus, DeviceExtension);
    }

    KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
    IoReleaseCancelSpinLock( irql );

    return ( arbContext->FinalStatus );

} // HandleReserveFailure



VOID
ReleaseScsiDevice(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Release a SCSI device (release from reservation).

Arguments:

    DeviceExtension - the device extension of the device to release.
                      This must be the physical device (partition0).

Return Value:

    None.

--*/

{
    PIRP                        irp;
    SCSI_PASS_THROUGH           spt;
    PKEVENT                     event;
    IO_STATUS_BLOCK             ioStatusBlock;
    NTSTATUS                    status = STATUS_INSUFFICIENT_RESOURCES;

    CDLOG( "ReleaseScsiDevice(%p): Entry DiskNo %d Sig %08x",
           DeviceExtension->DeviceObject,
           DeviceExtension->DiskNumber,
           DeviceExtension->Signature );

    ClusDiskPrint((3,
                   "[ClusDisk] Release disk number %u (sig: %08X), disk state %s \n",
                   DeviceExtension->DiskNumber,
                   DeviceExtension->Signature,
                   DiskStateToString( DeviceExtension->DiskState ) ));

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( !event ) {
        return;
    }

    irp = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_RELEASE,
                                        DeviceExtension->TargetDeviceObject,
                                        &spt,
                                        sizeof(SCSI_PASS_THROUGH),
                                        &spt,
                                        sizeof(SCSI_PASS_THROUGH),
                                        FALSE,
                                        event,
                                        &ioStatusBlock);

    if (!irp) {
        ExFreePool(event);
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to Init IRP to perform a release.\n"
                    ));
        return;
    }

    //
    // Before release, mark disk as offline.
    //

    ASSERT( DeviceExtension == DeviceExtension->PhysicalDevice->DeviceExtension );

    // stevedz - disable this assertion for now.
    // ASSERT( DiskOffline == DeviceExtension->DiskState );

    // Disk should already be offline.  Only mark it offline.
    DeviceExtension->DiskState = DiskOffline;
    // OFFLINE_DISK( DeviceExtension );

    ClusDiskPrint(( 3,
                    "[ClusDisk] Release %p, marking disk offline \n",
                    DeviceExtension->PhysicalDevice
                    ));

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(event,
                      NotificationEvent,
                      FALSE);

    status = IoCallDriver(DeviceExtension->TargetDeviceObject,
                          irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);

        status = ioStatusBlock.Status;
    }

    ExFreePool(event);

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to perform release. Status %lx\n",
                    status
                    ));
    }

    CDLOG( "ReleaseScsiDevice(%p): Exit => %!status!",
           DeviceExtension->DeviceObject,
           status );
} // ReleaseScsiDevice



NTSTATUS
ResetScsiDevice(
    IN HANDLE ScsiportHandle,
    IN PSCSI_ADDRESS ScsiAddress
    )
/*++

Routine Description:

    Break the reservation for the device specified in SCSI address.

    If the bus/device is reset, what a few seconds before returning.

Arguments:

    ScsiportHandle - If specified, will use this handle to send break reservation
                     IOCTL.  Caller is responsible for closing this handle.
                     If not specified, scsiport device will be opened based on the
                     SCSI address information port number.

    ScsiAddress - Pointer to SCSI_ADDRESS structure which is for the target device.

Return Value:

    NTSTATUS

--*/
{
    HANDLE                  scsiHandle = NULL;
    HANDLE                  eventHandle = NULL;
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatusBlock;
    UNICODE_STRING          portDevice;
    OBJECT_ATTRIBUTES       objectAttributes;
    WCHAR                   portDeviceBuffer[64];

    CDLOG( "BreakReserve: Entry Scsiport fh %p, Port %d  Path %d  TID %d  LUN %d ",
           ScsiportHandle,
           ScsiAddress->PortNumber,
           ScsiAddress->PathId,
           ScsiAddress->TargetId,
           ScsiAddress->Lun );

    //
    // Create event for notification.
    //
    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] BreakReserve: Failed to create event, status %08X\n",
                        status ));
        goto FnExit;
    }

    //
    // If caller specified a scsiport handle, use it.  Otherwise
    // we have to open scsiport to send the break reservation IOCTL.
    //

    if ( ScsiportHandle ) {
        scsiHandle = ScsiportHandle;

    } else {

        //
        // Open the scsiport device to send the break reservation.
        //

        (VOID) StringCchPrintfW( portDeviceBuffer,
                                 RTL_NUMBER_OF(portDeviceBuffer),
                                 L"\\Device\\ScsiPort%d",
                                 ScsiAddress->PortNumber );

        WCSLEN_ASSERT( portDeviceBuffer );

        RtlInitUnicodeString( &portDevice, portDeviceBuffer );

        InitializeObjectAttributes( &objectAttributes,
                                    &portDevice,
                                    OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL );

        status = ZwOpenFile( &scsiHandle,
                             FILE_ALL_ACCESS,
                             &objectAttributes,
                             &ioStatusBlock,
                             0,
                             FILE_NON_DIRECTORY_FILE );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] BreakReserve: failed to open file %wZ. Error %08X.\n",
                            &portDevice, status ));
            goto FnExit;
        }

    }

    //
    // Break reservation IOCTL uses the SCSI address to determine which
    // device to reset.
    //

    status = ZwDeviceIoControlFile( scsiHandle,
                                    eventHandle,
                                    NULL,
                                    NULL,
                                    &ioStatusBlock,
                                    IOCTL_STORAGE_BREAK_RESERVATION,
                                    ScsiAddress,
                                    sizeof(SCSI_ADDRESS),
                                    NULL,
                                    0 );

    if ( STATUS_PENDING == status ) {
        status = ZwWaitForSingleObject(eventHandle,
                                       FALSE,
                                       NULL);
        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] BreakReserve: Failed to reset device, error %08X.\n",
                        status ));
    }

FnExit:

    //
    // Close the handle only if the caller didn't pass it in.
    //

    if ( !ScsiportHandle && scsiHandle ) {
        ZwClose( scsiHandle );
    }

    if ( eventHandle ) {
        ZwClose( eventHandle );
    }

    CDLOG( "BreakReserve: Exit  Scsiport fh %p, Port %d  Path %d  TID %d  LUN %d  status %!status!",
           ScsiportHandle,
           ScsiAddress->PortNumber,
           ScsiAddress->PathId,
           ScsiAddress->TargetId,
           ScsiAddress->Lun,
           status );

    return status;

} // ResetScsiDevice


#if 0

NTSTATUS
LockVolumes(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Lock all volumes for this Disk.

Arguments:

    DiskNumber - the disk number for the disk to lock volumes.

Return Value:

    NT Status for request.

--*/

{
    NTSTATUS                status;
    OBJECT_ATTRIBUTES       objectAttributes;
    UNICODE_STRING          ntUnicodeString;
    HANDLE                  fileHandle;
    WCHAR                   deviceNameBuffer[MAX_PARTITION_NAME_LENGTH];
    IO_STATUS_BLOCK         ioStatusBlock;
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo;
    PPARTITION_INFORMATION_EX       partitionInfo;
    ULONG                   partIndex;
    HANDLE                  eventHandle;
    PFILE_OBJECT            fileObject;
    PDEVICE_OBJECT          deviceObject;
    PKEVENT                 event;
    PIRP                    irp;

    //
    // Allocate an event structure
    //
    event = ExAllocatePool(
                NonPagedPool,
                sizeof(KEVENT)
                );

    status = STATUS_INSUFFICIENT_RESOURCES;
    if (!event) {
        return(status);
    }

    driveLayoutInfo = ClusDiskGetPartitionInfo( DeviceExtension );

    if ( driveLayoutInfo != NULL ) {
        //
        // Create event for notification.
        //
        status = ZwCreateEvent( &eventHandle,
                                EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

        if ( !NT_SUCCESS(status) ) {
            ExFreePool( driveLayoutInfo );
            ExFreePool( event );
            return(status);
        }

        for ( partIndex = 0;
              partIndex < driveLayoutInfo->PartitionCount;
              partIndex++ )
            {

            partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

            //
            // First make sure this is a valid partition.
            //
            if ( !partitionInfo->Mbr.RecognizedPartition ||
                  partitionInfo->PartitionNumber == 0 ) {
                continue;
            }

            //
            // Create the device name for the device.
            //

            if ( FAILED( StringCchPrintfW( deviceNameBuffer,
                                           RTL_NUMBER_OF(deviceNameBuffer),
                                           DEVICE_PARTITION_NAME,
                                           DeviceExtension->DiskNumber,
                                           partitionInfo->PartitionNumber ) ) ) {
                continue;
            }
            WCSLEN_ASSERT( deviceNameBuffer );

            //
            // Get Unicode name
            //
            RtlInitUnicodeString( &ntUnicodeString, deviceNameBuffer );

            //
            // Try to open this device to perform a dismount
            //
            InitializeObjectAttributes( &objectAttributes,
                                        &ntUnicodeString,
                                        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                        NULL,
                                        NULL );

            ClusDiskPrint((
                    3,
                    "[ClusDisk] Locking Partition %ws.\n",
                    deviceNameBuffer ));

            status = ZwCreateFile( &fileHandle,
                                   SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                   &objectAttributes,
                                   &ioStatusBlock,
                                   NULL,
                                   FILE_ATTRIBUTE_NORMAL,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   FILE_OPEN,
                                   FILE_SYNCHRONOUS_IO_NONALERT,
                                   NULL,
                                   0 );

            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint((
                        1,
                        "[ClusDisk] LockVolumes failed to open file %wZ. Error %lx.\n",
                        &ntUnicodeString,
                        status ));
                continue;
            }

            status = ZwClearEvent( eventHandle );

#if 0
            status = ObReferenceObjectByHandle(
                                fileHandle,
                                FILE_WRITE_DATA,
                                *IoFileObjectType,
                                KernelMode,
                                &fileObject,
                                NULL );
            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint((
                        1,
                        "[ClusDisk] LockVolumes: failed to reference object %ws, status %lx\n",
                        deviceNameBuffer,
                        status ));
                continue;
            }
            deviceObject = IoGetRelatedDeviceObject( fileObject );
            ObDereferenceObject( fileObject );
            ClusDiskPrint((
                        1,
                        "[ClusDisk] LockVolumes - found file/device object %p \n",
                        deviceObject ));
            if ( !deviceObject ) {
                continue;
            }

            KeInitializeEvent(event,
                              NotificationEvent,
                              FALSE);


            irp = IoBuildSynchronousFsdRequest(
                            IRP_MJ_FLUSH_BUFFERS,
                            deviceObject,
                            NULL,
                            0,
                            NULL,
                            event,
                            &ioStatusBlock );
            if (!irp) {
                continue;
            }

            if (IoCallDriver( deviceObject,
                              irp ) == STATUS_PENDING) {

                KeWaitForSingleObject(
                    event,
                    Suspended,
                    KernelMode,
                    FALSE,
                    NULL
                    );
            }

#else
            status = ZwFsControlFile(
                                fileHandle,
                                eventHandle,        // Event Handle
                                NULL,               // APC Routine
                                NULL,               // APC Context
                                &ioStatusBlock,
                                FSCTL_LOCK_VOLUME,
                                NULL,               // InputBuffer
                                0,                  // InputBufferLength
                                NULL,               // OutputBuffer
                                0                   // OutputBufferLength
                                );
            if ( status == STATUS_PENDING ) {
                status = ZwWaitForSingleObject(eventHandle,
                                               FALSE,
                                               NULL);
                ASSERT( NT_SUCCESS(status) );
                status = ioStatusBlock.Status;
            }
#endif
            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint((
                        1,
                        "[ClusDisk] Failed to flush buffers for %wZ. Error %lx.\n",
                        &ntUnicodeString,
                        status ));
            } else {
                ClusDiskPrint((
                        3,
                        "[ClusDisk] Flushed buffers for %wZ.\n",
                        &ntUnicodeString ));
            }

            ZwClose( fileHandle );

        } // for

        ExFreePool( driveLayoutInfo );
        ZwClose( eventHandle );

    } // if

    ExFreePool( event );

    return(status);

} // LockVolumes
#endif


NTSTATUS
IsVolumeMounted(
    IN ULONG DiskNumber,
    IN ULONG PartNumber,
    OUT BOOLEAN *IsMounted
    )
{
    HANDLE      fileHandle = NULL;
    NTSTATUS    status;
    FILE_FS_DEVICE_INFORMATION deviceInfo;
    IO_STATUS_BLOCK ioStatusBlock;

    if ( PASSIVE_LEVEL != KeGetCurrentIrql() ) {
        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    //
    // Open the device so we can query if a volume is mounted without
    // causing it to be mounted.  Note that we can only specify
    // FILE_READ_ATTRIBUTES | SYNCHRONIZE or a mount will occur.
    //

    status = ClusDiskCreateHandle( &fileHandle,
                                   DiskNumber,
                                   PartNumber,
                                   FILE_READ_ATTRIBUTES | SYNCHRONIZE );

    if ( !NT_SUCCESS(status) ) {
        goto FnExit;
    }

    //
    // Make the device info query.
    //

    status = ZwQueryVolumeInformationFile( fileHandle,
                                           &ioStatusBlock,
                                           &deviceInfo,
                                           sizeof(deviceInfo),
                                           FileFsDeviceInformation );

    if ( !NT_SUCCESS(status) ) {
        goto FnExit;
    }

    *IsMounted = (deviceInfo.Characteristics & FILE_DEVICE_IS_MOUNTED) ?  TRUE : FALSE;

FnExit:

    if ( fileHandle ) {
        ZwClose( fileHandle );
    }

    return status;

}   // IsVolumeMounted



NTSTATUS
DismountPartition(
    IN PDEVICE_OBJECT TargetDevice,
    IN ULONG DiskNumber,
    IN ULONG PartNumber
    )

/*++

Routine Description:

    Dismount the device, given the disk and partition numbers

Arguments:

    TargetDevice - the target device to send volume IOCTLs to.

    DiskNumber - the disk number for the disk to dismount

    PartNumber - the parition number for the disk to dismount

Return Value:

    NT Status for request.

--*/

{
    NTSTATUS                status;
    HANDLE                  fileHandle = NULL;
    KIRQL                   irql;
    BOOLEAN                 isMounted;

    CDLOG( "DismountPartition: Entry DiskNo %d PartNo %d", DiskNumber, PartNumber );

    ClusDiskPrint(( 3,
                    "[ClusDisk] DismountPartition: Dismounting disk %d  partition %d \n",
                    DiskNumber,
                    PartNumber ));

    status = IsVolumeMounted( DiskNumber, PartNumber, &isMounted );
    if ( NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] DismountPartition: Volume is mounted returns: %s \n",
                        isMounted ? "TRUE" : "FALSE" ));

        if ( FALSE == isMounted) {

            // Volume not mounted, we are done.  Return success.

            status = STATUS_SUCCESS;
            goto FnExit;
        }
    }

    irql = KeGetCurrentIrql();
    if ( PASSIVE_LEVEL != irql ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] DismountPartition: Invalid IRQL %d \n", irql ));
        CDLOG( "DismountPartition: Invalid IRQL %d ", irql );
        ASSERT( FALSE );
        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

#if DBG
    //
    // Find out if FTDISK thinks this disk is currently online or offline.
    // If offline, success is returned.
    // If online, c0000001 STATUS_UNSUCCESSFUL is returned.
    //

    status = SendFtdiskIoctlSync( TargetDevice,
                                  DiskNumber,
                                  PartNumber,
                                  IOCTL_VOLUME_IS_OFFLINE );


    if ( NT_SUCCESS(status) ) {
        ClusDiskPrint(( 3,
                        "[ClusDisk] DismountPartition: IOCTL_VOLUME_IS_OFFLINE indicates volume is offline. \n" ));
        CDLOG( "DismountPartition: IOCTL_VOLUME_IS_OFFLINE indicates volume is offline" );

    } else {
        ClusDiskPrint(( 3,
                        "[ClusDisk] DismountPartition: IOCTL_VOLUME_IS_OFFLINE returns %08X \n",
                        status ));
        CDLOG( "DismountPartition: IOCTL_VOLUME_IS_OFFLINE returns %08X", status );
    }
#endif

    // If the disk is offline:
    //      if access is: FILE_READ_ATTRIBUTES | SYNCHRONIZE
    //
    //          - DismountDevice fails with: c0000010 STATUS_INVALID_DEVICE_REQUEST
    //
    //      if access is: FILE_READ_DATA | SYNCHRONIZE
    //
    //          - ClusDiskCreateHandle fails with:  C000000E STATUS_NO_SUCH_DEVICE
    //
    //      if access is: FILE_WRITE_ATTRIBUTES | SYNCHRONIZE
    //
    //          - DismountDevice works!

    status = ClusDiskCreateHandle( &fileHandle,
                                   DiskNumber,
                                   PartNumber,
                                   FILE_WRITE_ATTRIBUTES | SYNCHRONIZE );

    //
    // Check status of getting the device handle.
    //

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] DismountPartition: Unable to get device handle \n" ));
        CDLOG( "DismountPartition: Unable to get device handle" );
        goto FnExit;
    }

    status = DismountDevice( fileHandle );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] Failed to dismount disk %d partition %d. Error %08X.\n",
                        DiskNumber,
                        PartNumber,
                        status ));
    } else {
        ClusDiskPrint(( 3,
                        "[ClusDisk] Dismounted disk %d partition %d \n",
                        DiskNumber,
                        PartNumber ));
    }

FnExit:

    if ( fileHandle ) {
        ZwClose( fileHandle );
    }

    CDLOG( "DismountPartition: Exit DiskNo %d PartNo %d => %!status!",
           DiskNumber,
           PartNumber,
           status );

    ClusDiskPrint(( 3,
                    "[ClusDisk] DismountPartition: Dismounting disk %d  partition %d  status %08X \n",
                    DiskNumber,
                    PartNumber,
                    status ));

    return(status);

} // DismountPartition



NTSTATUS
DismountDevice(
    IN HANDLE FileHandle
    )

/*++

Routine Description:

    Dismounts a device.

Arguments:

    FileHandle - file handle to use for performing dismount.

Return Value:

    NT Status for request.

--*/

{
    IO_STATUS_BLOCK             ioStatusBlock;
    NTSTATUS                    status;
    HANDLE                      eventHandle;

    CDLOG( "DismountDevice: Entry handle %p", FileHandle );

    ClusDiskPrint(( 3,
                    "[ClusDisk] DismountDevice: Entry handle %p \n",
                    FileHandle ));

    //
    // Create event for notification.
    //
    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

    if ( !NT_SUCCESS(status) ) {
        CDLOG( "DismountDevice: Failed to create event" );
        goto FnExit;
    }

    //
    // Lock first.
    //
    // If raw FS mounted, dismount will fail if lock was not done first.
    // By doing the lock, we insure we don't see dismount failures on
    // disks with raw mounted.
    //

    CDLOG( "DismountDevice: FSCTL_LOCK_VOLUME called" );

    status = ZwFsControlFile(
                        FileHandle,
                        eventHandle,        // Event Handle
                        NULL,               // APC Routine
                        NULL,               // APC Context
                        &ioStatusBlock,
                        FSCTL_LOCK_VOLUME,
                        NULL,               // InputBuffer
                        0,                  // InputBufferLength
                        NULL,               // OutputBuffer
                        0                   // OutputBufferLength
                        );
    if ( status == STATUS_PENDING ) {
        status = ZwWaitForSingleObject(eventHandle,
                                       FALSE,
                                       NULL);
        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    //
    // Now dismount.  We don't care if the lock failed.
    //

    CDLOG( "DismountDevice: FSCTL_DISMOUNT_VOLUME called" );

    status = ZwFsControlFile(
                        FileHandle,
                        eventHandle,        // Event Handle
                        NULL,               // APC Routine
                        NULL,               // APC Context
                        &ioStatusBlock,
                        FSCTL_DISMOUNT_VOLUME,
                        NULL,               // InputBuffer
                        0,                  // InputBufferLength
                        NULL,               // OutputBuffer
                        0                   // OutputBufferLength
                        );
    if ( status == STATUS_PENDING ) {
        status = ZwWaitForSingleObject(eventHandle,
                                       FALSE,
                                       NULL);
        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    ZwClose( eventHandle );
    if ( !NT_SUCCESS(status) && status != STATUS_VOLUME_DISMOUNTED) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] DismountDevice: Failed to dismount the volume. Status %08X.\n",
                    status
                    ));
    }

FnExit:

    CDLOG( "DismountDevice: Handle %p Exit => %!status!", FileHandle, status );

    ClusDiskPrint(( 3,
                    "[ClusDisk] DismountDevice: Exit handle %p, status %08X \n",
                    FileHandle,
                    status ));

    return(status);

} // DismountDevice



BOOLEAN
AttachedDevice(
    IN ULONG Signature,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    Find out whether we're supposed to attach to a given disk signature.

Arguments:

    Signature - The signature to decide whether to attach or not.

    DeviceObject - The DeviceObject for Partition0 if it is attached.

Return Value:

    TRUE - if we're supposed to attach to this signature.
    FALSE - if not.

--*/

{
    PDEVICE_LIST_ENTRY  deviceEntry;

    // 2000/02/05: stevedz - added synchronization.

    ACQUIRE_SHARED( &ClusDiskDeviceListLock );

    deviceEntry = ClusDiskDeviceList;
    while ( deviceEntry ) {
        if ( deviceEntry->Signature == Signature ) {
            if ( deviceEntry->Attached ) {
                *DeviceObject = deviceEntry->DeviceObject;
                RELEASE_SHARED( &ClusDiskDeviceListLock );
                return(TRUE);
            } else {
                RELEASE_SHARED( &ClusDiskDeviceListLock );
                return(FALSE);
            }
        }
        deviceEntry = deviceEntry->Next;
    }

    RELEASE_SHARED( &ClusDiskDeviceListLock );
    return(FALSE);

} // AttachedDevice



NTSTATUS
EnableHaltProcessing(
    IN KIRQL *Irql
    )

/*++

Routine Description:

    Enable halt processing. This routine is called every time we create
    an open reference to the ClusDisk control channel. The reference count
    is bumped and if it transitions from zero to non-zero, we register
    for a halt notification callback with the ClusterNetwork driver.

    If we do open a handle to ClusterNetwork, we must leave it open until
    we're all done.

Arguments:

    None.

Return Value:

    NTSTATUS for the request.

Notes:

    This routine must be called with the ClusDiskSpinLock held.

--*/

{
    NTSTATUS                    status;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    ULONG                       haltEnabled;
    HALTPROC_CONTEXT            context;

    CDLOG( "EnableHaltProcessing: Entry Irql %!irql!", *Irql );

    haltEnabled = ClusNetRefCount;
    ClusNetRefCount++;

    //
    // If halt processing is already enabled, then leave now if ClusNetHandle
    // is set.  Otherwise, fall through, open clusnet driver, and try to save
    // the handle.  If multiple threads are saving the handle at the same time,
    // only one will succeed - the other threads will release their handles.
    // Note: the ClusNetHandle might still be null even if the reference
    // count is non-zero. We might be in the process of performing the
    // open on another thread.  In this case, we no longer return an error.
    // Instead, we fall through, and try to save the ClusNetHandle later.
    //
    if ( haltEnabled ) {
        if ( ClusNetHandle != NULL ) {
            CDLOG( "EnableHaltProcessing: ClusNetHandle already saved" );
            return(STATUS_SUCCESS);
        }
    }

    deviceExtension = RootDeviceObject->DeviceExtension;
    KeReleaseSpinLock(&ClusDiskSpinLock, *Irql);

    context.FileHandle = NULL;
    context.DeviceExtension = deviceExtension;

    status = ProcessDelayedWorkSynchronous( RootDeviceObject, EnableHaltProcessingWorker, &context );

    KeAcquireSpinLock(&ClusDiskSpinLock, Irql);

    if ( NT_SUCCESS(status) ) {

        //
        // If another thread is running concurrently and managed to save the handle, we need to close
        // the one we just opened.
        //

        if ( ClusNetHandle != NULL ) {

            //
            // Don't close the handle directly - use the work queue.  Release the spinlock before
            // closing the handle.  The context filehandle is already set.
            //

            KeReleaseSpinLock(&ClusDiskSpinLock, *Irql);
            ProcessDelayedWorkSynchronous( RootDeviceObject, DisableHaltProcessingWorker, &context );
            KeAcquireSpinLock(&ClusDiskSpinLock, Irql);

        } else {

            ClusNetHandle = context.FileHandle;

        }

    } else {
        // Backout refcount
        --ClusNetRefCount;
    }
    CDLOG( "EnableHaltProcessing: Exit Irql %!irql! => %!status!", *Irql, status );

    return(status);

} // EnableHaltProcessing


VOID
EnableHaltProcessingWorker(
    PDEVICE_OBJECT DeviceObject,
    PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    This routine runs in the system process and registers a callback with the
    clusnet driver.

Arguments:

    DeviceObject - Unused.

    WorkContext - General context info and routine specific context info.

Return Value:

    Status returned in WorkContext structure.

--*/
{

    PHALTPROC_CONTEXT           context = WorkContext->Context;
    NTSTATUS                    status;
    HANDLE                      fileHandle;
    IO_STATUS_BLOCK             ioStatusBlock;
    UNICODE_STRING              ntUnicodeString;
    OBJECT_ATTRIBUTES           objectAttributes;
    HANDLE                      eventHandle;
    CLUSNET_SET_EVENT_MASK_REQUEST eventCallback;

    //
    // Create event for notification.
    //
    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] Failed to create event, status %lx\n",
                status ));
        goto FnExit;
    }

    //
    // Setup event mask structure.
    //
    eventCallback.EventMask = ClusnetEventHalt |
                              ClusnetEventPoisonPacketReceived;
    eventCallback.KmodeEventCallback = ClusDiskEventCallback;

    //
    // Create device name for the ClusterNetwork device.
    //

    RtlInitUnicodeString(&ntUnicodeString,
                         DD_CLUSNET_DEVICE_NAME);

    //
    // Try to open ClusterNetwork device.
    //
    InitializeObjectAttributes( &objectAttributes,
                                &ntUnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = ZwCreateFile( &fileHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                           &objectAttributes,
                           &ioStatusBlock,
                           0,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0 );

    ASSERT( status != STATUS_PENDING );

    if ( NT_SUCCESS(status) ) {
        status = ZwDeviceIoControlFile( fileHandle,
                                        eventHandle,
                                        NULL,
                                        NULL,
                                        &ioStatusBlock,
                                        IOCTL_CLUSNET_SET_EVENT_MASK,
                                        &eventCallback,
                                        sizeof(eventCallback),
                                        NULL,
                                        0 );

        if ( status == STATUS_PENDING ) {
            status = ZwWaitForSingleObject(eventHandle,
                                           FALSE,
                                           NULL);
            ASSERT( NT_SUCCESS(status) );
            status = ioStatusBlock.Status;
        }

    } else {
        fileHandle = NULL;
    }

    ZwClose( eventHandle );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
            1,
            "[ClusDisk] Failed to register for halt processing. Error %lx.\n",
            status ));
        if ( fileHandle ) {
            ZwClose( fileHandle );
        }
    } else {

        context->FileHandle = fileHandle;
    }

FnExit:

    ClusDiskPrint(( 3,
                    "[ClusDisk] EnableHaltProcessingWorker: Returning status %08X \n", status ));

    WorkContext->FinalStatus = status;

    KeSetEvent( &WorkContext->CompletionEvent, IO_NO_INCREMENT, FALSE );

}   // EnableHaltProcessingWorker



NTSTATUS
DisableHaltProcessing(
    IN KIRQL *Irql
    )

/*++

Routine Description:

    This routine disables halt processing as needed.

Arguments:

    Irql - pointer to the irql that we were previously running.

Return Value:

    NTSTATUS of request.

Note:

    The ClusDiskSpinLock must be held on entry.

--*/

{
    HANDLE                  clusNetHandle;
    PCLUS_DEVICE_EXTENSION  deviceExtension;
    HALTPROC_CONTEXT        context;

    CDLOG( "DisableHaltProcessing: Entry Irql %!irql!", *Irql );


    if ( ClusNetRefCount == 0 ) {
        return(STATUS_INVALID_DEVICE_STATE);
    }

    ASSERT( ClusNetHandle != NULL );

    if ( --ClusNetRefCount == 0 ) {
        clusNetHandle = ClusNetHandle;
        ClusNetHandle = NULL;
        deviceExtension = RootDeviceObject->DeviceExtension;

        //
        // We must close the ClusterNetwork handle. But first leave
        // the handle null, so we can release the spinlock and
        // perform the decrement syncrhonized. This is just like
        // the enable case when we release the spinlock.
        //

        KeReleaseSpinLock(&ClusDiskSpinLock, *Irql);
        context.FileHandle = clusNetHandle;
        ProcessDelayedWorkSynchronous( RootDeviceObject, DisableHaltProcessingWorker, &context );
        KeAcquireSpinLock(&ClusDiskSpinLock, Irql);

        // [GorN 12/09/99] We can get here if EnableHaltProcessing
        // occurs while we are doing ZwClose( clusNetHandle );
        // Don't need this assert:
        //
        // ASSERT( ClusNetRefCount == 0 );
    }

    CDLOG( "DisableHaltProcessing: Exit Irql %!irql!", *Irql );

    return(STATUS_SUCCESS);

} // DisableHaltProcessing

VOID
DisableHaltProcessingWorker(
    PDEVICE_OBJECT DeviceObject,
    PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    This routine runs in the system process and simply closes the clusnet
    file handle.

Arguments:

    DeviceObject - Unused.

    WorkContext - General context info and routine specific context info.

Return Value:

    None.

--*/
{
    PHALTPROC_CONTEXT   context = WorkContext->Context;

    ZwClose( context->FileHandle );

    ClusDiskPrint(( 3,
                    "[ClusDisk] DisableHaltProcessingWorker: Returns \n" ));

    KeSetEvent( &WorkContext->CompletionEvent, IO_NO_INCREMENT, FALSE );

}   // DisableHaltProcessingWorker


VOID
ClusDiskEventCallback(
    IN CLUSNET_EVENT_TYPE   EventType,
    IN CL_NODE_ID           NodeId,
    IN CL_NETWORK_ID        NetworkId
    )

/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT  deviceObject;
    PCLUS_DEVICE_EXTENSION deviceExtension;
    KIRQL           irql;

    CDLOG( "ClusDiskEventCallback: Entry EventType %d NodeId %d NetworkId %d" ,
           EventType,
           NodeId,
           NetworkId );

    ClusDiskPrint((
            3,
            "[ClusDisk] Halt Processing routine was called with event %lx.\n",
            EventType ));

    if ( RootDeviceObject == NULL ) {
        return;
    }

    deviceObject = RootDeviceObject->DriverObject->DeviceObject;

    // We need to stop reservations right now so another node can arbitrate and
    // take ownership of the disks.

    // We later call ClusDiskCompletePendedIrps (inside ClusDiskHaltProcessingWorker),
    // to mark disk offline and complete IRPs.  ClusDiskCompletePendedIrps will
    // also clear the reserve flags.

    //
    // For each ClusDisk device, if we have a persistent reservation, then
    // stop it.
    //
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        if ( deviceExtension->BusType != RootBus ) {
            deviceExtension->ReserveTimer = 0;
            // Don't offline the device so that dismount can possibly work!
        }
        deviceObject = deviceObject->NextDevice;
    }

    //
    // Now schedule a worker queue item to fully take the devices offline.
    //
    //
    // Globally Synchronize
    //
    KeAcquireSpinLock(&ClusDiskSpinLock, &irql);

    if ( !HaltBusy ) {
        HaltBusy = TRUE;
        HaltOfflineBusy = TRUE;
        ExQueueWorkItem(&HaltWorkItem,
                        CriticalWorkQueue );
    }
    KeReleaseSpinLock(&ClusDiskSpinLock, irql);

    CDLOG( "ClusDiskEventCallback: Exit EventType %d NodeId %d NetworkId %d" ,
           EventType,
           NodeId,
           NetworkId );

    return;

} // ClusDiskEventCallback



VOID
ClusDiskLogError(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN ULONG SequenceNumber,
    IN UCHAR MajorFunctionCode,
    IN UCHAR RetryCount,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfText,
    IN PWCHAR Text
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject - A pointer to the driver object for the device.

    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.

    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.

    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.

    RetryCount - The number of times a particular operation has been
    retried.

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfText - The length in bytes (including the terminating NULL)
                   of the text insertion string.

    Text - the text to dump.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    PVOID objectToUse;
    PUCHAR ptrToText;
    ULONG  maxTextLength = 104;


    if (ARGUMENT_PRESENT(DeviceObject)) {

        objectToUse = DeviceObject;

    } else {

        objectToUse = DriverObject;

    }

    if ( LengthOfText < maxTextLength ) {
        maxTextLength = LengthOfText;
    }

    errorLogEntry = IoAllocateErrorLogEntry(
                        objectToUse,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + maxTextLength)
                        );

    if ( errorLogEntry != NULL ) {

        errorLogEntry->ErrorCode = SpecificIOStatus;
        errorLogEntry->SequenceNumber = SequenceNumber;
        errorLogEntry->MajorFunctionCode = MajorFunctionCode;
        errorLogEntry->RetryCount = RetryCount;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        errorLogEntry->DumpDataSize = 0;
        ptrToText = (PUCHAR)&errorLogEntry->DumpData[0];

        if (maxTextLength) {

            errorLogEntry->NumberOfStrings = 1;
            errorLogEntry->StringOffset = (USHORT)(ptrToText-
                                                   (PUCHAR)errorLogEntry);
            RtlCopyMemory(
                ptrToText,
                Text,
                maxTextLength
                );

        }

        IoWriteErrorLogEntry(errorLogEntry);

    } else {
        ClusDiskPrint((1,
                "[ClusDisk] Failed to allocate system buffer of size %u.\n",
                sizeof(IO_ERROR_LOG_PACKET) + maxTextLength ));
    }

} // ClusDiskLogError



NTSTATUS
ClusDiskMarkIrpPending(
    PIRP                Irp,
    PDRIVER_CANCEL      CancelRoutine
    )
/*++

Notes:

    Called with IoCancelSpinLock held.

--*/
{
    //
    // Set up for cancellation
    //
    ASSERT(Irp->CancelRoutine == NULL);

    if (!Irp->Cancel) {

        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, CancelRoutine);
#if 0
        ClusDiskPrint((
                1,
                "[ClusDisk] Pending Irp %p \n",
                Irp
                ));
#endif
        return(STATUS_SUCCESS);
    }

    //
    // The IRP has already been cancelled.
    //

    ClusDiskPrint((
        1,
        "[ClusDisk] Irp %lx already cancelled.\n", Irp));

    return(STATUS_CANCELLED);

}  // ClusDiskMarkIrpPending



VOID
ClusDiskCompletePendingRequest(
    IN PIRP                 Irp,
    IN NTSTATUS             Status,
    PCLUS_DEVICE_EXTENSION  DeviceExtension
    )
/*++

Routine Description:

    Completes a pending request.

Arguments:

    Irp           - A pointer to the IRP for this request.
    Status        - The final status of the request.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION  irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

#if DBG

    if (Irp->Cancel) {
        ASSERT(Irp->CancelRoutine == NULL);
    }

#endif  // DBG

    IoSetCancelRoutine(Irp, NULL);

    ClusDiskPrint((
            1,
            "[ClusDisk] Completed waiting Irp %p \n",
            Irp
            ));

    if (Irp->Cancel) {
#if 0
        ClusDiskPrint((
            1,
            "[ClusDisk] Completed irp %p was cancelled\n", Irp));
#endif

        Status = STATUS_CANCELLED;
    }

    Irp->IoStatus.Status = (NTSTATUS) Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return;

}  // ClusDiskCompletePendingRequest



VOID
ClusDiskIrpCancel(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )

/*++

Routine Description:

    Cancellation handler pending Irps.

Return Value:

    None.

Notes:

    Called with cancel spinlock held.
    Returns with cancel spinlock released.

--*/

{
    CDLOG( "IrpCancel: Entry DO %p irp %p", DeviceObject, Irp );

    ClusDiskPrint((
            1,
            "[ClusDisk] Cancel Irp %p, DevObj %p \n",
            Irp,
            DeviceObject ));

    //
    // If this Irp is associated with the control device object, then make
    // sure the Irp is removed from the WaitingIoctls list first.
    //

    KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);
    RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
    KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);

    IoSetCancelRoutine(Irp, NULL);

    //
    // Release the cancel spinlock here, so that we are not holding the
    // spinlock when we complete the Irp.
    //
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    CDLOG( "IrpCancel: Exit DO %p irp %p", DeviceObject, Irp );

    return;

} // ClusDiskIrpCancel



NTSTATUS
ClusDiskForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp needs to be processed by the lower drivers
    prior to being processed by this one.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION   deviceExtension;
    KEVENT event;
    NTSTATUS status;

    KeInitializeEvent( &event, NotificationEvent, FALSE );
    deviceExtension = (PCLUS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // copy the irpstack for the next device
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // set a completion routine
    //

    IoSetCompletionRoutine( Irp, ClusDiskIrpCompletion,
                            &event, TRUE, TRUE, TRUE );

    //
    // call the next lower device
    //

    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // wait for the actual completion
    //

    if ( status == STATUS_PENDING ) {
        KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
        status = Irp->IoStatus.Status;
    }

    return status;

}   // ClusDiskForwardIrpSynchronous()


NTSTATUS
EjectVolumes(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine tells the partmgr to eject all volumes.  For the volume manager
    to re-attach to the volumes, IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS is used.
    The cluster service calls IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS when bringing
    the disk online, so it is not necessary to make this call in the driver.

    Note that this routine should only be called for physical devices (partition0)
    and that no one should be using the volumes.

Arguments:


Return Value:

    NTSTATUS

--*/
{
    PIRP                    irp;
    PKEVENT                 event = NULL;
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    IO_STATUS_BLOCK         ioStatusBlock;
    NTSTATUS                status = STATUS_SUCCESS;

    // Looks like the IO request will bypass clusdisk at the physical disk level
    // because clusdisk attached after FTDISK went looking for the top of the disk
    // stack and cached the pointer.
    //
    // PnP race condition: occasionally, the device stack was incorrect and clustered
    // disks weren't being protected properly.  Since we are using PnP notification
    // instead of an AddDevice routine, there was a small window where we would
    // attach to the device stack correctly, but another driver was also attaching
    // at the same time.  So I/O bound for the device would go like this:
    //      NTFS -> Volsnap -> Ftdisk -> Disk
    //
    // even though the device stack looked like this:
    //      82171a50  \Driver\ClusDisk   82171b08  ClusDisk1Part0
    //      822be720  \Driver\PartMgr    822be7d8
    //      822bd030  \Driver\Disk       822bd0e8  DR1
    //      822c0990  \Driver\aic78xx    822c0a48  aic78xx1Port2Path0Target0Lun0
    //
    // So we have to tell partmgr to eject all the volume managers and then
    // let the volume managers attach again.  This has the effect of removing the
    // cached pointer
    //
    // To tell the volume managers to stop using this disk:
    //      IOCTL_PARTMGR_EJECT_VOLUME_MANAGERS
    //
    // To tell the volume managers they can start using the disk:
    //      IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS


    CDLOG( "EjectVolumes: Entry DO %p", DeviceObject );

    if ( !deviceExtension->TargetDeviceObject ) {
        status = STATUS_INVALID_PARAMETER;
        goto FnExit;
    }

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( NULL == event ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    //
    // Eject the volume managers.
    //

    irp = IoBuildDeviceIoControlRequest( IOCTL_PARTMGR_EJECT_VOLUME_MANAGERS,
                                         deviceExtension->TargetDeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         FALSE,
                                         event,
                                         &ioStatusBlock );

    if ( !irp ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] EjectVolumes: Failed to build IRP to eject volume managers. \n"
                    ));

        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent( event,
                       NotificationEvent,
                       FALSE );

    status = IoCallDriver( deviceExtension->TargetDeviceObject,
                           irp );

    if ( STATUS_PENDING == status ) {

        KeWaitForSingleObject( event,
                               Suspended,
                               KernelMode,
                               FALSE,
                               NULL );

        status = ioStatusBlock.Status;
    }

    ClusDiskPrint((3,
                   "[ClusDisk] EjectVolumes: Eject IOCTL returns %08X \n",
                   status
                   ));

FnExit:

    if ( event ) {
        ExFreePool( event );
    }

    ClusDiskPrint((1,
                   "[ClusDisk] EjectVolumes: Target devobj %p   Final status %08X \n",
                   DeviceObject,
                   status
                   ));

    CDLOG( "EjectVolumes: Exit DO %p, status %08X", DeviceObject, status );

    return status;

}   // EjectVolumes


#if 0   // Removed 2/27/2001


NTSTATUS
ReclaimVolumes(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine tells the partmgr to reclaim all volumes.

    Note that this routine should only be called for physical devices (partition0)
    and that no one should be using the volumes.

Arguments:


Return Value:

    NTSTATUS

--*/
{
    PCLUS_DEVICE_EXTENSION  deviceExtension =  DeviceObject->DeviceExtension;
    PIRP                    irp = NULL;
    PKEVENT                 event = NULL;
    IO_STATUS_BLOCK         ioStatusBlock;
    NTSTATUS                status = STATUS_SUCCESS;

    CDLOG( "ReclaimVolumes: Entry DO %p", DeviceObject );

    InterlockedIncrement( &deviceExtension->ReclaimInProgress );

    if ( !deviceExtension->TargetDeviceObject ) {
        status = STATUS_INVALID_PARAMETER;
        goto FnExit;
    }

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( NULL == event ) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    //
    // Allow the volume managers to reclaim partitions.
    //

    irp = IoBuildDeviceIoControlRequest( IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS,
                                         deviceExtension->TargetDeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         FALSE,
                                         event,
                                         &ioStatusBlock );

    if ( !irp ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to build IRP to check unclaimed partitions. \n"
                    ));

        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent( event,
                       NotificationEvent,
                       FALSE );


    status = IoCallDriver( deviceExtension->TargetDeviceObject,
                           irp );

    if ( status == STATUS_PENDING ) {

        KeWaitForSingleObject( event,
                               Suspended,
                               KernelMode,
                               FALSE,
                               NULL );

        status = ioStatusBlock.Status;
    }

FnExit:

    if ( event ) {
        ExFreePool( event );
    }

    ClusDiskPrint((1,
                   "[ClusDisk] ReclaimVolumes: Target devobj %p   Final status %08X \n",
                   DeviceObject,
                   status
                   ));

    CDLOG( "ReclaimVolumes: Exit DO %p, status %08X", DeviceObject, status );

    InterlockedDecrement( &deviceExtension->ReclaimInProgress );

    return status;

}   // ReclaimVolumes
#endif


NTSTATUS
SetVolumeState(
    PCLUS_DEVICE_EXTENSION PhysicalDisk,
    ULONG NewDiskState
    )
{
    PVOL_STATE_INFO volStateInfo = NULL;

    NTSTATUS        status = STATUS_SUCCESS;

    //
    // If this isn't the physical disk (i.e. partition 0), then exit.
    //

    if ( PhysicalDisk != PhysicalDisk->PhysicalDevice->DeviceExtension ) {
        status = STATUS_INVALID_PARAMETER;
        goto FnExit;
    }

#if 0
    // Don't use this...
    // Optimization?  If new state is equal to old state, we are done.
    // Should work as long as this device extension is set AFTER the
    // call to SetVolumeState.  Currently the macros set the device extension
    // state BEFORE calling this routine.  Also, some routines set DE state
    // well before calling this routine.
    // More testing...

    if ( NewDiskState == DeviceExtension->DiskState ) {
        goto FnExit;
    }
#endif

    volStateInfo = ExAllocatePool( NonPagedPool, sizeof( VOL_STATE_INFO ) );

    if ( !volStateInfo ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    volStateInfo->NewDiskState = NewDiskState;
    volStateInfo->WorkItem = NULL;

    //
    // If IRQL is PASSIVE_LEVEL, call the routine directly.
    // We know the call is direct because the WorkItem portion will
    // be NULL.
    //

    if ( PASSIVE_LEVEL == KeGetCurrentIrql() ) {
        SetVolumeStateWorker( PhysicalDisk->DeviceObject,
                              volStateInfo );
        goto FnExit;
    }

    volStateInfo->WorkItem = IoAllocateWorkItem( PhysicalDisk->DeviceObject );

    if ( !volStateInfo->WorkItem ) {
        ExFreePool( volStateInfo );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    IoQueueWorkItem( volStateInfo->WorkItem,
                     SetVolumeStateWorker,
                     DelayedWorkQueue,
                     volStateInfo );

FnExit:

    return status;

}   // SetVolumeState


VOID
SetVolumeStateWorker(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context
    )
/*++

Routine Description:

    Call volume manager to mark all volumes for this disk offline or online.

    If the IRQL is not PASSIVE_LEVEL, then this routine will return an error.

Arguments:

    DeviceObject - Clustered disk to set state.

    Context - Contains information whether this routine has been called directly
              or via a work item.  Also indicates whether this is an online or
              offline request.

Return Value:

    None.

--*/
{
    PDRIVE_LAYOUT_INFORMATION_EX   driveLayoutInfo = NULL;
    PPARTITION_INFORMATION_EX      partitionInfo;
    PIO_WORKITEM                workItem =  ((PVOL_STATE_INFO)Context)->WorkItem;
    PCLUS_DEVICE_EXTENSION      PhysicalDisk = DeviceObject->DeviceExtension;

    NTSTATUS                    status = STATUS_UNSUCCESSFUL;

    ULONG                       ioctl;
    ULONG                       partIndex;
    ULONG                       newDiskState = ((PVOL_STATE_INFO)Context)->NewDiskState;

    KIRQL                       irql;

    CDLOG( "SetVolumeState: Entry DevObj %p  newstate: %s  workItem: %p ",
           PhysicalDisk->DeviceObject,
           ( DiskOnline == newDiskState ? "DiskOnline" : "DiskOffline" ),
           workItem );

    ClusDiskPrint(( 3,
                    "[ClusDisk] SetVolumeState: DevObj %p  newstate: %s   workItem: %p \n",
                    PhysicalDisk->DeviceObject,
                    DiskStateToString( newDiskState ),
                    workItem ));

    irql = KeGetCurrentIrql();
    if ( PASSIVE_LEVEL != irql ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] SetVolumeState: Current IRQL %d not PASSIVE_LEVEL  - skipping state change \n",
                        irql ));
        ASSERT( FALSE );
        goto FnExit;
    }

    //
    // This should never happen as it was checked earlier.
    //

    if ( PhysicalDisk != PhysicalDisk->PhysicalDevice->DeviceExtension ) {
        ASSERT( FALSE );
        PhysicalDisk = PhysicalDisk->PhysicalDevice->DeviceExtension;
        ClusDiskPrint(( 1,
                        "[ClusDisk] SetVolumeState: Resetting physical disk pointer: DevObj %p  \n",
                        PhysicalDisk->DeviceObject ));
        CDLOG( "SetVolumeState: Resetting physical disk pointer: DevObj %p \n",
               PhysicalDisk->DeviceObject );
    }

    if ( DiskOnline == newDiskState ) {
        ioctl = IOCTL_VOLUME_ONLINE;
    } else {
        ioctl = IOCTL_VOLUME_OFFLINE;
    }

    //
    // Get the drive layout for the disk.
    //
    // If we are bringing the disk online, get a new drive layout in
    // case the drive layout changed while the disk was on another node.
    //

    status = GetDriveLayout( PhysicalDisk->DeviceObject,
                             &driveLayoutInfo,
                             ( IOCTL_VOLUME_ONLINE == ioctl) ? TRUE : FALSE ,   // If online, update cached drive layout
                             ( IOCTL_VOLUME_ONLINE == ioctl) ? TRUE : FALSE );  // If online, flush storage drivers cached drive layout

    if ( !NT_SUCCESS(status) || !driveLayoutInfo ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] SetVolumeState: Failed to read partition info, status %08X \n",
                        status ));
        CDLOG( "SetVolumeState: Failed to read partition info, status %08X \n",
               status );
        goto FnExit;
    }

    for ( partIndex = 0;
          partIndex < driveLayoutInfo->PartitionCount;
          partIndex++ ) {

        partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

        if ( 0 ==  partitionInfo->PartitionNumber ) {
            continue;
        }

        // Online/Offline the volume.

        status = SendFtdiskIoctlSync( NULL,
                                      PhysicalDisk->DiskNumber,
                                      partitionInfo->PartitionNumber,
                                      ioctl );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] SetVolumeState: Failed to set state disk%d part%d , status %08X \n",
                            PhysicalDisk->DiskNumber,
                            partitionInfo->PartitionNumber,
                            status
                            ));
            CDLOG( "SetVolumeState: Failed to set state disk%d part%d , status %08X \n",
                   PhysicalDisk->DiskNumber,
                   partitionInfo->PartitionNumber,
                   status );
        }

    }

FnExit:

    CDLOG( "SetVolumeState: Exit DevObj %p DiskNumber %d  newstate: %s  status %x ",
           PhysicalDisk->DeviceObject,
           PhysicalDisk->DiskNumber,
           ( DiskOnline == newDiskState ? "DiskOnline" : "DiskOffline" ),
           status );

    ClusDiskPrint(( 3,
                    "[ClusDisk] SetVolumeState: DiskNumber %d  newstate: %s  final status %08X \n",
                    PhysicalDisk->DiskNumber,
                    ( DiskOnline == newDiskState ? "DiskOnline" : "DiskOffline" ),
                    status
                    ));

#if CLUSTER_FREE_ASSERTS
    if ( !NT_SUCCESS(status) ) {
        DbgPrint("[ClusDisk] SetVolumeState failed: DiskNumber %d  newstate: %s  final status %08X \n",
                   PhysicalDisk->DiskNumber,
                   ( DiskOnline == newDiskState ? "DiskOnline" : "DiskOffline" ),
                   status
                  );
        // DbgBreakPoint();
    }
#endif


    if ( driveLayoutInfo ) {
        ExFreePool( driveLayoutInfo );
    }

    if ( workItem ) {
        IoFreeWorkItem( workItem );
    }

    if ( Context ) {
        ExFreePool( Context );
    }

    return;

}   // SetVolumeStateWorker


PCHAR
VolumeIoctlToString(
    ULONG Ioctl
    )
{
    switch ( Ioctl ) {

    case IOCTL_VOLUME_ONLINE:
        return "IOCTL_VOLUME_ONLINE";

    case IOCTL_VOLUME_OFFLINE:
        return "IOCTL_VOLUME_OFFLINE";

    case IOCTL_VOLUME_IS_OFFLINE:
        return "IOCTL_VOLUME_IS_OFFLINE";

    default:
        return "Unknown volume IOCTL";
    }

}   // VolumeIoctlToString


NTSTATUS
SendFtdiskIoctlSync(
    PDEVICE_OBJECT TargetObject,
    ULONG DiskNumber,
    ULONG PartNumber,
    ULONG Ioctl
    )
{
    PIRP                irp;
    PDEVICE_OBJECT      targetDevice = NULL;
    KEVENT              event;
    NTSTATUS            status;
    IO_STATUS_BLOCK     ioStatusBlock;

    WCHAR               partitionNameBuffer[MAX_PARTITION_NAME_LENGTH];
    UNICODE_STRING      targetDeviceName;

    if ( TargetObject ) {

        targetDevice = TargetObject;

    } else {

        //
        // Create device name for the physical disk.
        //

        if ( FAILED( StringCchPrintfW( partitionNameBuffer,
                                       RTL_NUMBER_OF(partitionNameBuffer),
                                       DEVICE_PARTITION_NAME,
                                       DiskNumber,
                                       PartNumber ) ) ) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto FnExit;
        }
        WCSLEN_ASSERT( partitionNameBuffer );

        ClusDiskPrint(( 3,
                        "[ClusDisk] SendFtdiskIoctlSync: Device %ws \n",
                        partitionNameBuffer
                        ));

        status = ClusDiskGetTargetDevice( DiskNumber,
                                          PartNumber,
                                          &targetDevice,
                                          &targetDeviceName,
                                          NULL,
                                          NULL,
                                          FALSE );

        FREE_DEVICE_NAME_BUFFER( targetDeviceName );
    }

    if ( !targetDevice ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] SendFtdiskIoctlSync: Failed to get devobj for disk %d partition %d \n",
                        DiskNumber,
                        PartNumber
                        ));
        status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto FnExit;
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //
    KeInitializeEvent( &event,
                       NotificationEvent,
                       FALSE );

    irp = IoBuildDeviceIoControlRequest( Ioctl,
                                         targetDevice,
                                         (LPVOID)ClusDiskOfflineOnlineGuid,
                                         sizeof(GUID),
                                         NULL,
                                         0,
                                         FALSE,
                                         &event,
                                         &ioStatusBlock );
    if ( !irp ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] SendFtdiskIoctlSync: Failed to build IRP for IOCTL %X  \n", Ioctl ));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    status = IoCallDriver( targetDevice,
                           irp );

    if ( STATUS_PENDING == status ) {

        KeWaitForSingleObject( &event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        status = ioStatusBlock.Status;
    }

FnExit:

    if ( !TargetObject ) {
        DEREFERENCE_OBJECT( targetDevice );
    }

    CDLOG( "SendFtDiskIoctlSync: Exit disk %d part %d  status %X  IOCTL %X  %s ",
           DiskNumber,
           PartNumber,
           status,
           Ioctl,
           VolumeIoctlToString( Ioctl ) );

    ClusDiskPrint(( 3,
                    "[ClusDisk] SendFtDiskIoctlSync: disk %d part %d  status %08X  IOCTL %X  %s \n",
                    DiskNumber,
                    PartNumber,
                    status,
                    Ioctl,
                    VolumeIoctlToString( Ioctl ) ));

    return status;

}    // SendFtdiskIoctlSync


NTSTATUS
AttachSignatureList(
    PDEVICE_OBJECT DeviceObject,
    PULONG InBuffer,
    ULONG InBufferLen
    )
{

    ULONG   idx;
    ULONG   signature;

    NTSTATUS    status = STATUS_INVALID_PARAMETER;
    NTSTATUS    retVal;

    BOOLEAN     stopProcessing = FALSE;

    UNICODE_STRING signatureName;
    UNICODE_STRING availableName;

    signatureName.Buffer = NULL;
    availableName.Buffer = NULL;

    ClusDiskPrint(( 3,
                    "[ClusDisk] AttachSignatureList: list at %p, length %d \n",
                    InBuffer,
                    InBufferLen ));

    CDLOG( "AttachSignatureList: siglist %p, length %d ", InBuffer, InBufferLen );

    if ( !InBufferLen ) {
        status = STATUS_SUCCESS;
        goto FnExit;
    }

    if ( InBuffer &&
         InBufferLen &&
         InBufferLen >= sizeof(ULONG) &&
         ( InBufferLen % sizeof(ULONG) == 0 ) ) {

        //
        // Allocate buffer for Signatures registry key. So we can add
        // the signature.
        //
        status = ClusDiskInitRegistryString( &signatureName,
                                             CLUSDISK_SIGNATURE_KEYNAME,
                                             wcslen(CLUSDISK_SIGNATURE_KEYNAME)
                                             );

        if ( !NT_SUCCESS(status) ) {
            goto FnExit;
        }

        //
        // Allocate buffer for AvailableDisks registry key.
        //

        status = ClusDiskInitRegistryString( &availableName,
                                             CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                             wcslen(CLUSDISK_AVAILABLE_DISKS_KEYNAME) );

        if ( !NT_SUCCESS(status) ) {
            goto FnExit;
        }

        for ( idx = 0; idx < InBufferLen / sizeof(ULONG); idx++ ) {

            signature = InBuffer[idx];

            ClusDiskPrint((1,
                           "[ClusDisk] AttachSignatureList: attaching signature %08X\n",
                           signature));

            CDLOG( "AttachSignatureList: sig %08x", signature );

            //
            // No signature or system disk signature, don't add it.
            //

            if ( ( 0 == signature ) || SystemDiskSignature == signature ) {
                ClusDiskPrint((2,
                               "[ClusDisk] AttachSignatureList: skipping signature %08X\n",
                               signature));
                CDLOG( "AttachSignatureList: skipping sig %08x", signature );
                continue;
            }

            // We have to force the signature under \Parameters\Signatures because
            // the disk might not be accessible (i.e. reserved by another node) and
            // ClusDiskAttachDevice will only put the signature there if the
            // disk can really be attached.

            //
            // Create the signature key under \Parameters\Signatures.
            //

            retVal = ClusDiskAddSignature( &signatureName,
                                           signature,
                                           FALSE
                                           );

            //
            // Error adding this signature, save the error for return and continue
            // with the signature list.
            //

            if ( !NT_SUCCESS(retVal) ) {

                status = retVal;
                continue;
            }

            //
            // Delete the signature key under Parameters\AvailableDisks.
            //

            ClusDiskDeleteSignature( &availableName,
                                     signature );

            //
            // Just try to attach to the device with no bus resets.
            //

            ClusDiskAttachDevice( signature,
                                  0,
                                  DeviceObject->DriverObject,
                                  FALSE,
                                  &stopProcessing,
                                  TRUE );           // Installing disk resource - dismount, then offline

        }

    }

FnExit:

    if ( signatureName.Buffer ) {
        ExFreePool( signatureName.Buffer );
    }

    if ( availableName.Buffer ) {
        ExFreePool( availableName.Buffer );
    }

    ClusDiskPrint(( 3,
                    "[ClusDisk] AttachSignatureList: returning final status %08X \n",
                    status ));

    CDLOG( "AttachSignatureList: returning final status %x ", status );

    return status;

}   // AttachSignatureList


NTSTATUS
DetachSignatureList(
    PDEVICE_OBJECT DeviceObject,
    PULONG InBuffer,
    ULONG InBufferLen
    )
{

    ULONG   idx;
    ULONG   signature;

    NTSTATUS    status = STATUS_SUCCESS;
    NTSTATUS    retVal;

    ClusDiskPrint(( 3,
                    "[ClusDisk] DetachSignatureList: list at %p, length %d \n",
                    InBuffer,
                    InBufferLen ));

    CDLOG( "DetachSignatureList: list %p, length %d ", InBuffer, InBufferLen );

    if ( !InBufferLen ) {
        status = STATUS_SUCCESS;
        goto FnExit;
    }

    if ( InBuffer &&
         InBufferLen &&
         InBufferLen >= sizeof(ULONG) &&
         ( InBufferLen % sizeof(ULONG) == 0 ) ) {


        for ( idx = 0; idx < InBufferLen / sizeof(ULONG); idx++ ) {

            signature = InBuffer[idx];

            ClusDiskPrint((1,
                           "[ClusDisk] DetachSignatureList: detaching signature %08X\n",
                           signature));

            CDLOG( "DetachSignatureList: sig %08x", signature );

            // Skip zero signature.
            if ( !signature ) {
                ClusDiskPrint((2,
                               "[ClusDisk] DetachSignatureList: skipping signature %08X\n",
                               signature));

                CDLOG( "DetachSignatureList: skipping sig %08x", signature );
                continue;
            }

            retVal = ClusDiskDetachDevice( signature, DeviceObject->DriverObject );

            //
            // If any detach fails, return an error.  If multiple detachs fail, there
            // is no way to pass back information on which specific signature failed,
            // so simply indicate one of the failures back to the caller.
            // On failure, we still want to continue detaching, so don't break out
            // of the loop.
            //

            if ( !NT_SUCCESS(retVal) ) {
                status = retVal;
            }

        }
    }

FnExit:

    ClusDiskPrint(( 3,
                    "[ClusDisk] DetachSignatureList: returning final status %08X \n",
                    status ));

    CDLOG( "DetachSignatureList: returning final status %x ", status );

    // Always return success.
    // Cluster setup will send a NULL buffer with zero length when rejoining a node.

    return status;

}   // DetachSignatureList


NTSTATUS
CleanupDeviceList(
    PDEVICE_OBJECT DeviceObject
    )
{
/*++

Routine Description:

    Queue a work item to remove entries from the ClusDiskDeviceList.

Arguments:

    DeviceObject - Device that is being removed by the system.

Return Value:

    NTSTATUS

--*/

    PIO_WORKITEM  workItem = NULL;

    CDLOG( "CleanupDeviceList: Entry DO %p", DeviceObject );

    workItem = IoAllocateWorkItem( DeviceObject );

    if ( NULL == workItem ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] CleanupDeviceList: Failed to allocate WorkItem \n" ));
        goto FnExit;
    }

    //
    // Queue the workitem.  IoQueueWorkItem will insure that the device object is
    // referenced while the work-item progresses.
    //

    ClusDiskPrint(( 3,
                    "[ClusDisk] CleanupDeviceList: Queuing work item \n" ));

    IoQueueWorkItem( workItem,
                     CleanupDeviceListWorker,
                     DelayedWorkQueue,
                     workItem );

FnExit:

    CDLOG( "CleanupDeviceList: Exit, DO %p", DeviceObject );

    return STATUS_SUCCESS;

}   //  CleanupDeviceList


VOID
CleanupDeviceListWorker(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context
    )
/*++

Routine Description:

    Work item that will walk ClusDiskDeviceList and remove any entries
    that are marked as free.

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_LIST_ENTRY  deviceEntry;
    PDEVICE_LIST_ENTRY  lastEntry;
    PDEVICE_LIST_ENTRY  nextEntry;

    ACQUIRE_EXCLUSIVE( &ClusDiskDeviceListLock );

    deviceEntry = ClusDiskDeviceList;
    lastEntry = NULL;
    while ( deviceEntry ) {

        if ( deviceEntry->FreePool ) {
            if ( lastEntry == NULL ) {
                ClusDiskDeviceList = deviceEntry->Next;
            } else {
                lastEntry->Next = deviceEntry->Next;
            }
            nextEntry = deviceEntry->Next;
            ExFreePool( deviceEntry );
            deviceEntry = nextEntry;
            continue;
        }
        lastEntry = deviceEntry;
        deviceEntry = deviceEntry->Next;
    }

    RELEASE_EXCLUSIVE( &ClusDiskDeviceListLock );

    IoFreeWorkItem( (PIO_WORKITEM)Context );

}   // CleanupDeviceListWorker


NTSTATUS
WaitForAttachCompletion(
    PCLUS_DEVICE_EXTENSION DeviceExtension,
    BOOLEAN WaitForInit,
    BOOLEAN CheckPhysDev
    )
{
    PCLUS_DEVICE_EXTENSION  physicalDisk;
    LARGE_INTEGER           waitTime;
    NTSTATUS                status = STATUS_NO_SUCH_DEVICE;
    ULONG                   retryCount;
    KIRQL                   irql;

    if ( !DeviceExtension ) {
        CDLOG( "WaitForAttachCompletion: DevExt %p  zero DevExt ",
               DeviceExtension );
        goto FnExit;
    }

    //
    // Root device is not layered above anything.  Return success.
    //

    if ( RootBus == DeviceExtension->BusType ) {
        status = STATUS_SUCCESS;
        goto FnExit;
    }

    //
    // Determine if we are checking both this device and the physical
    // device, or just this device.
    //

    if ( CheckPhysDev ) {

        //
        // Check both this device and the physical device.
        //

        if ( !DeviceExtension->PhysicalDevice ) {
            CDLOG( "WaitForAttachCompletion: DevExt %p  no PhysicalDevice ",
                   DeviceExtension );
            goto FnExit;
        }

        physicalDisk = DeviceExtension->PhysicalDevice->DeviceExtension;
        if ( !physicalDisk ) {
            CDLOG( "WaitForAttachCompletion: DevExt %p  no PhysicalDevice DevExt",
                   DeviceExtension );
            goto FnExit;
        }

        //
        // If both this device and the physical device have a target device, return
        // success.
        //

        if ( DeviceExtension->TargetDeviceObject && physicalDisk->TargetDeviceObject ) {
            status = STATUS_SUCCESS;
            goto FnExit;
        }

    } else {

        //
        // If this device has a target device, return success.
        //

        if ( DeviceExtension->TargetDeviceObject ) {
            status = STATUS_SUCCESS;
            goto FnExit;
        }

    }

    if ( !WaitForInit ) {
        CDLOG( "WaitForAttachCompletion: DevExt %p  skipping wait",
               DeviceExtension );
        goto FnExit;
    }

    irql = KeGetCurrentIrql();

    if ( PASSIVE_LEVEL != irql ) {
        CDLOG( "WaitForAttachCompletion: DevExt %p  bad IRQL %d ",
               DeviceExtension,
               irql );
        goto FnExit;
    }

    //
    // Wait for 1/2 second between checking intialization completion.
    // Total wait time will be 5 seconds.
    //

    waitTime.QuadPart = (ULONGLONG)(-5 * 1000 * 1000);  // 5,000,000  100 nanosecond units = .5
    retryCount = 10;                                    // 10 * .5 = 5 seconds

#if CLUSTER_FREE_ASSERTS
    DbgPrint( "[ClusDisk] WaitForAttachCompletion: DevExt %p waiting... \n", DeviceExtension );
#endif

    while ( retryCount-- ) {
        KeDelayExecutionThread( KernelMode,
                                FALSE,
                                &waitTime );

        CDLOG( "WaitForAttachCompletion: DevExt %p  retryCount %d ",
               DeviceExtension,
               retryCount );

#if CLUSTER_FREE_ASSERTS
        DbgPrint( "[ClusDisk] WaitForAttachCompletion: DevExt %p retryCount %d \n",
                  DeviceExtension,
                  retryCount );
#endif

        if ( CheckPhysDev ) {

            if ( DeviceExtension->TargetDeviceObject && physicalDisk->TargetDeviceObject ) {
                status = STATUS_SUCCESS;
                goto FnExit;
            }

        } else {

            if ( DeviceExtension->TargetDeviceObject ) {
                status = STATUS_SUCCESS;
                goto FnExit;
            }

        }

    }   // while

    //
    // One more check outside of the wait loop.  This should succeed.
    //

    if ( CheckPhysDev ) {

        if ( DeviceExtension->TargetDeviceObject && physicalDisk->TargetDeviceObject ) {
            status = STATUS_SUCCESS;
            goto FnExit;
        }

    } else {

        if ( DeviceExtension->TargetDeviceObject ) {
            status = STATUS_SUCCESS;
            goto FnExit;
        }

    }

FnExit:

    // Log message only on error.

    if ( !NT_SUCCESS(status) ) {
        CDLOG( "WaitForAttachCompletion: DevExt %p returns %08X ",
               DeviceExtension,
               status );

        ClusDiskPrint(( 3,
                "[ClusDisk] WaitForAttachCompletion: DevExt %p returns %08X \n",
                DeviceExtension,
                status ));

#if CLUSTER_FREE_ASSERTS
        DbgPrint("[ClusDisk] Failed wait for attach %08X \n", status );
        DbgBreakPoint();
#endif

    }

    return status;

}   // WaitForAttachCompletion


VOID
ReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID Tag
    )
{
    // Don't expect the displayed RemoveLock values to be correct on a heavily utilized system.

    ClusDiskPrint(( 1,
                    "RELWAIT: RemoveLock %p  Tag %p  Removed %02X  IoCount %08X \n ",
                    RemoveLock,
                    Tag,
                    RemoveLock->Common.Removed,
                    RemoveLock->Common.IoCount ));

    CDLOG( "RELWAIT: RemoveLock %p  Tag %p  Removed %02X  IoCount %08X \n ",
           RemoveLock,
           Tag,
           RemoveLock->Common.Removed,
           RemoveLock->Common.IoCount );

#if CLUSTER_FREE_ASSERTS && !DBG
    DbgPrint( "RELWAIT: RemoveLock %p  Tag %p  Removed %02X  IoCount %08X \n ",
              RemoveLock,
              Tag,
              RemoveLock->Common.Removed,
              RemoveLock->Common.IoCount );
#endif

    IoReleaseRemoveLockAndWait( RemoveLock, Tag );

    CDLOG( "RELWAIT: Wait complete: RemoveLock %p \n ",
           RemoveLock );

    ClusDiskPrint(( 1,
                    "RELWAIT: Wait Complete:  RemoveLock %p  Removed %02X  IoCount %08X \n",
                    RemoveLock,
                    RemoveLock->Common.Removed,
                    RemoveLock->Common.IoCount ));

#if CLUSTER_FREE_ASSERTS && !DBG
    DbgPrint( "RELWAIT: Wait Complete:  RemoveLock %p  Removed %02X  IoCount %08X \n",
              RemoveLock,
              RemoveLock->Common.Removed,
              RemoveLock->Common.IoCount );
#endif

}   // ReleaseRemoveLockAndWait


NTSTATUS
AcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN OPTIONAL PVOID Tag
    )
{
    NTSTATUS status;

    // Don't expect the displayed RemoveLock values to be correct on a heavily utilized system.

    status = IoAcquireRemoveLock(RemoveLock, Tag);

#if DBG
    if ( TrackRemoveLocks || (TrackRemoveLockSpecific == RemoveLock) ) {

        ClusDiskPrint(( 1,
                        "ACQ: RemoveLock %p  Tag %p  Status %08X \n",
                        RemoveLock,
                        Tag,
                        status ));

        ClusDiskPrint(( 1,
                        "ACQ: Removed %02X  IoCount %08X \n",
                        RemoveLock->Common.Removed,
                        RemoveLock->Common.IoCount ));
    }
#endif

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] AcquireRemoveLock for lock %p tag %p failed %08X \n",
                RemoveLock,
                Tag,
                status ));
        CDLOG( "AcquireRemoveLock for lock %p tag %p failed %08X ",
                RemoveLock,
                Tag,
                status );
    }

    return status;

}   // AcquireRemoveLock



#if DBG
VOID
ClusDiskDebugPrint(
    ULONG PrintLevel,
    PCHAR   DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print routine.

Arguments:

    PrintLevel - The Debug Print Level.

    DebugMessage - The Debug Message Format String, plus additional args.

Return:

    None.

--*/

{
    va_list args;

    va_start( args, DebugMessage);

#if !defined(WMI_TRACING)
    if ( PrintLevel <= ClusDiskPrintLevel ) {
        CHAR buffer[256];

        if ( SUCCEEDED( StringCchVPrintf( buffer,
                                          RTL_NUMBER_OF(buffer),
                                          DebugMessage,
                                          args ) ) ) {
            DbgPrint( buffer );
        }
    }
#else
    if ( PrintLevel <= ClusDiskPrintLevel || WPP_LEVEL_ENABLED(LEGACY) ) {
        CHAR buffer[256];

        if ( SUCCEEDED( StringCchVPrintf( buffer,
                                          RTL_NUMBER_OF(buffer),
                                          DebugMessage,
                                          args ) ) ) {

            if (PrintLevel <= ClusDiskPrintLevel) {
                DbgPrint( buffer );
            }
            CDLOGF(LEGACY,"LegacyLogging %!ARSTR!", buffer );

        }
    }
#endif

    va_end( args );
}
#endif // DBG


#if DBG

VOID
ReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID Tag
    )
{
    // Don't expect the displayed RemoveLock values to be correct on a heavily utilized system.

    IoReleaseRemoveLock(RemoveLock, Tag);

    if ( TrackRemoveLocks || (TrackRemoveLockSpecific == RemoveLock) ) {
        ClusDiskPrint(( 1,
                        "REL: RemoveLock %p  Tag %p \n ",
                        RemoveLock,
                        Tag ));

        ClusDiskPrint(( 1,
                        "REL: Removed %02X  IoCount %08X \n",
                        RemoveLock->Common.Removed,
                        RemoveLock->Common.IoCount ));
    }

    if (TrackRemoveLocksEnableChecks) {

        //
        // The IoCount should never be less than 1 (especially never a negative value).
        // Is it possible that a race condition could occur because we are printing the
        // value from the RemoveLock and the remove could have just occurred.  RemoveLock
        // IoCount should never be less than zero.
        //

        if ( !RemoveLock->Common.Removed ) {
            ASSERTMSG( "REL: RemoveLock IoCount possibly corrupt (less than 1) ",
                       (RemoveLock->Common.IoCount >= 1 ) );
        }

        //
        // IoCount == 1 is OK, it just means there is no I/O outstanding on the device.
        //

        // ASSERTMSG("REL: IoCount == 1 - check stack ", (RemoveLock->Common.IoCount != 1 ));
    }

}   // ReleaseRemoveLock


PCHAR
PnPMinorFunctionString(
    UCHAR MinorFunction
    )
{
    switch (MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
            return "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";
        default:
            return "Unknown PNP IRP";
    }

}   // PnPMinorFunctionString


PCHAR
BoolToString(
    BOOLEAN Value
    )
{
    if ( Value ) {
        return "TRUE";
    }
    return "FALSE";

}   // BoolToString


PCHAR
DiskStateToString(
    ULONG DiskState
    )
{
    switch ( DiskState ) {

    case DiskOffline:
        return "DiskOffline (0)";

    case DiskOnline:
        return "DiskOnline  (1)";

    case DiskFailed:
        return "DiskFailed  (2)";

    case DiskStalled:
        return "DiskStalled (3)";

    case DiskOfflinePending:
        return "DiskOfflinePending (4)";

    default:
        return "Unknown DiskState";
    }

}   // DiskStateToString

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusdisk\makefile.inc ===
RunWpp:
	wpp01 trace.wpp clusdisk.c ezwrite.c

cldskwmi.c: cdwpp.h

clusdisk.rc: cdwpp.mof

clean:
	del cdwpp.mof cdwpp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusdisk\kdcd\precomp.h ===
#if DBG
#define DEBUG 1
#endif

#define NT 1
#define _PNP_POWER  1
#define SECFLTR 1

#include <ntverp.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Prevent hal.h, included in ntos.h from overriding _BUS_DATA_TYPE
// enum found in ntioapi.h, included from nt.h.
//
#define _HAL_
#include <ntos.h>

#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

//#define _NTIFS_
#undef Ioctl
#include "clusdskp.h"
#include "clusdisk.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusdisk\object.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    object.c

Abstract:

    Resource DLL for disks.

Author:

    Rod Gamache (rodga) 18-Dec-1995

Revision History:

--*/

#include "ntos.h"
#include "zwapi.h"
#include "windef.h"
#include "stdio.h"
#include "stdlib.h"
#include "clusdskp.h"
#include <strsafe.h>    // Should be included last.

extern POBJECT_TYPE IoDeviceObjectType;


#ifdef ALLOC_PRAGMA

//#pragma alloc_text(INIT, GetSymbolicLink)

#endif // ALLOC_PRAGMA



VOID
GetSymbolicLink(
    IN PWCHAR RootName,
    IN OUT PWCHAR ObjectName   // Assume this points at a MAX_PATH len buffer
    )
{
    PWCHAR      destEnd;
    NTSTATUS    Status;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE      LinkHandle;
    WCHAR       Buffer[MAX_PATH];
    UNICODE_STRING UnicodeString;

    size_t      charRemaining;

    if ( FAILED( StringCchCopyExW( Buffer,
                                   RTL_NUMBER_OF(Buffer) - 1,
                                   RootName,
                                   &destEnd,
                                   &charRemaining,
                                   0 ) ) ) {
        return;
    }

    if ( !destEnd || !charRemaining ||
         FAILED( StringCchCatW( destEnd,
                                charRemaining,
                                ObjectName ) ) ) {
        return;
    }

    //
    // Make the output buffer empty in case we fail.
    //
    *ObjectName = '\0';


    RtlInitUnicodeString(&UnicodeString, Buffer);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL
                               );

    // Open the given symbolic link object
    Status = ZwOpenSymbolicLinkObject(&LinkHandle,
                                      GENERIC_READ,
                                      &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        ClusDiskPrint((1,
                       "[ClusDisk] GetSymbolicLink: ZwOpenSymbolicLink "
                       "failed, status = %08X., Name = [%ws]\n",
                       Status, UnicodeString.Buffer));
        return;
    }

    // Go get the target of the symbolic link

    UnicodeString.Length = 0;
    UnicodeString.Buffer = ObjectName;
    UnicodeString.MaximumLength = (USHORT)(MAX_PATH);

    Status = ZwQuerySymbolicLinkObject(LinkHandle, &UnicodeString, NULL);

    ZwClose(LinkHandle);

    if (!NT_SUCCESS(Status)) {
        ClusDiskPrint((1,
                       "[ClusDisk] GetSymbolicLink: ZwQuerySymbolicLink failed, status = %08X.\n",
                       Status));
        return;
    }

    // Add NULL terminator
    UnicodeString.Buffer[UnicodeString.Length/sizeof(WCHAR)] = '\0';

    return;

} // GetSymbolicLink
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusdisk\kdcd\kdcd.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcd.c

Abstract:

    Cluster Disk driver KD extension - based on Vert's skeleton

Author:

    John Vert (jvert) 6-Aug-1992

Revision History:

--*/

#include "precomp.h"

PCHAR DiskStateTitles[] = {
    "Offline",
    "Online",
    " *** Failed *** ",
    " *** Stalled *** "
};

PCHAR BusTypeTitles[] = {
    "Root",
    "SCSI",
    "Unknown"
};

#define IRP_LIST_MAX    20

//
// globals
//

EXT_API_VERSION        ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;

#define TrueOrFalse( _x )  ( _x ? "True" : "False" )

/* forwards */

BOOL
ReadTargetMemory(
    PVOID TargetAddress,
    PVOID LocalBuffer,
    ULONG BytesToRead
    );

__inline PCHAR
ListInUse(
    PLIST_ENTRY,
    PLIST_ENTRY
    );

__inline PCHAR
TrueFalse(
    BOOLEAN Value
    );

/* end forwards */

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( cdversion )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("%s Extension dll for Build %d debugging %s kernel for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            SavedMajorVersion == 0x0c ? "Checked" : "Free",
            SavedMinorVersion
            );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}


VOID
Dump_DrvObj(
    IN PDRIVER_OBJECT DriverObject
    )
/*
 *   dump all the devobjs and devexts
 */
{
    PCLUS_DEVICE_EXTENSION DevExtension;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT TargetDevObject;
    DRIVER_OBJECT LocalDriverObject;
    DEVICE_OBJECT LocalDeviceObject;
    CLUS_DEVICE_EXTENSION LocalDevExtension;

    //
    // read memory from target machine
    //

    if ( !ReadTargetMemory((PVOID)DriverObject,
                           (PVOID)&LocalDriverObject,
                           sizeof(DRIVER_OBJECT))) {
        return;
    }

    dprintf( "DriverObject @ %08X\n", DriverObject );

    DeviceObject = LocalDriverObject.DeviceObject;

    while ( DeviceObject ) {
        if ( !ReadTargetMemory((PVOID)DeviceObject,
                               (PVOID)&LocalDeviceObject,
                               sizeof(DEVICE_OBJECT))) {
            return;
        }

        TargetDevObject = NULL;
        DevExtension = LocalDeviceObject.DeviceExtension;

        if ( DevExtension ) {
            if ( !ReadTargetMemory((PVOID)DevExtension,
                                   (PVOID)&LocalDevExtension,
                                   sizeof(CLUS_DEVICE_EXTENSION))) {
                return;
            }
            TargetDevObject = LocalDevExtension.TargetDeviceObject;
        }

        dprintf( "    DevObj/DevExt/TargetDev: %08X, %08X, %08X\n",
                 DeviceObject,
                 DevExtension,
                 TargetDevObject );
        DeviceObject = LocalDeviceObject.NextDevice;

    } // while

    return;

} // Dump_DrvObj


DECLARE_API( cddrvobj )
/*
 *   dump all the devobjs and devexts
 */
{
    PDRIVER_OBJECT DriverObject;
    PCLUS_DEVICE_EXTENSION DevExtension;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT TargetDevObject;
    DRIVER_OBJECT LocalDriverObject;
    DEVICE_OBJECT LocalDeviceObject;
    CLUS_DEVICE_EXTENSION LocalDevExtension;

    DriverObject = (PDRIVER_OBJECT)GetExpression( args );

    if ( !DriverObject ) {

        dprintf("bad string conversion (%s) \n", args );
        dprintf("try !object \\device\\clusdisk0 \n");
        return;
    }

    Dump_DrvObj( DriverObject );

    return;

} // drvobj


VOID
Dump_DevExt(
    IN  PCLUS_DEVICE_EXTENSION TargetExt
    )
/*
 *   dump the clusdisk extension structure
 */
{
    CLUS_DEVICE_EXTENSION LocalExt;
    BOOL success;
    LONG BytesRead;
    WCHAR LocalDeviceName[512];

    //
    // read memory from target machine
    //

    if ( !ReadTargetMemory((PVOID)TargetExt,
                           (PVOID)&LocalExt,
                           sizeof(CLUS_DEVICE_EXTENSION))) {
        return;
    }

    dprintf( "    Extension                @ %08X\n", TargetExt );
    dprintf( "    This extension's DevObj  = %08X\n", LocalExt.DeviceObject );
    dprintf( "    Target DevObj            = %08X\n", LocalExt.TargetDeviceObject );
    dprintf( "    Physical (Part0) DevObj  = %08X", LocalExt.PhysicalDevice );

    if ( LocalExt.DeviceObject == LocalExt.PhysicalDevice ) {
        dprintf( " [ This device is the physical device ] \n" );
    } else {
        dprintf( " \n" );
    }

    dprintf( "    Scsi Address             = Port %u Path %u Target %u Lun %u\n",
             LocalExt.ScsiAddress.PortNumber,
             LocalExt.ScsiAddress.PathId,
             LocalExt.ScsiAddress.TargetId,
             LocalExt.ScsiAddress.Lun);

    dprintf( "    Signature                = %08X\n", LocalExt.Signature );
    dprintf( "    Disk number              = %08X (%u)\n", LocalExt.DiskNumber, LocalExt.DiskNumber );

    dprintf( "    Disk State               = %s  **** \n", ( LocalExt.DiskState <= DiskStateMaximum ?
                                        DiskStateTitles[LocalExt.DiskState] :
                                        "Out of Range"));

    dprintf( "    Reservation Timer        = %08X\n", LocalExt.ReserveTimer );
    dprintf( "    Last reserve time        = %I64X\n", LocalExt.LastReserve );
    dprintf( "    Event                    @ %08X\n", &TargetExt->Event );
    dprintf( "    Cluster Bus Type         = %s\n", (LocalExt.BusType <= UnknownBus ?
                                        BusTypeTitles[LocalExt.BusType] :
                                        "Out of Range"));

    dprintf( "    Last Reserve Status      = %08X\n", LocalExt.ReserveFailure );
    dprintf( "    WaitingIoctls            @ %08X\n", &TargetExt->WaitingIoctls );
    dprintf( "        %s\n",
             ListInUse( &LocalExt.WaitingIoctls, (PLIST_ENTRY)&TargetExt->WaitingIoctls ));

    dprintf( "    WorkItem                 @ %08X\n", &TargetExt->WorkItem );

    dprintf( "    Perform Reserves         = %s\n", TrueOrFalse( LocalExt.PerformReserves ));
    dprintf( "    Timer Busy               = %s\n", TrueOrFalse( LocalExt.TimerBusy ));

    dprintf( "    AttachValid              = %s\n", TrueOrFalse( LocalExt.AttachValid ));
    dprintf( "    Detached                 = %s\n", TrueOrFalse( LocalExt.Detached ));

    dprintf( "    Driver Object            = %08X\n", LocalExt.DriverObject );

    dprintf( "    Last Partition Number    = %u\n", LocalExt.LastPartitionNumber );
    dprintf( "    Disk Notification Entry  = %08X\n", LocalExt.DiskNotificationEntry );
    dprintf( "    Vol  Notification Entry  = %08X\n", LocalExt.VolumeNotificationEntry );

    dprintf( "    Sector Size              = %u\n", LocalExt.SectorSize );
    dprintf( "    Arbitration Sector       = %u\n", LocalExt.ArbitrationSector );

    dprintf( "    Last Write Time (approx) = %I64X \n", LocalExt.LastWriteTime );
    dprintf( "    VolumeHandles            @ %08X \n", &TargetExt->VolumeHandles );

    dprintf( "    RemoveLock               @ %08X  [use !remlock] \n",  &TargetExt->RemoveLock );

#if 0
    if ( ReadTargetMemory((PVOID)LocalExt.DeviceName,
                          (PVOID)&LocalDeviceName,
                          sizeof(LocalDeviceName))) {

        dprintf( "    DeviceName = %ws\n", LocalDeviceName );
    } else {
        dprintf( "    DeviceName @ %08X\n", LocalExt.DeviceName );
    }
#endif

    dprintf( "    Paging event             @ %08X \n", &TargetExt->PagingPathCountEvent );
    dprintf( "    Paging path count        = %08X \n", LocalExt.PagingPathCount );
    dprintf( "    Hibernation path count   = %08X \n", LocalExt.HibernationPathCount );
    dprintf( "    Dump path count          = %08X \n", LocalExt.DumpPathCount );

    dprintf(" \n");

    return;
}

VOID
Dump_All(
    IN PDRIVER_OBJECT DriverObject
    )
/*
 *   dump all the devobjs and devexts fully
 */
{
    PCLUS_DEVICE_EXTENSION DevExtension;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT TargetDevObject;
    DRIVER_OBJECT LocalDriverObject;
    DEVICE_OBJECT LocalDeviceObject;
    CLUS_DEVICE_EXTENSION LocalDevExtension;

    //
    // read memory from target machine
    //

    if ( !ReadTargetMemory((PVOID)DriverObject,
                           (PVOID)&LocalDriverObject,
                           sizeof(DRIVER_OBJECT))) {
        return;
    }

    dprintf( "DriverObject                 @ %08X\n\n", DriverObject );

    DeviceObject = LocalDriverObject.DeviceObject;

    while ( DeviceObject ) {
        if ( !ReadTargetMemory((PVOID)DeviceObject,
                               (PVOID)&LocalDeviceObject,
                               sizeof(DEVICE_OBJECT))) {
            return;
        }

        TargetDevObject = NULL;
        DevExtension = LocalDeviceObject.DeviceExtension;

        if ( DevExtension ) {
            if ( !ReadTargetMemory((PVOID)DevExtension,
                                   (PVOID)&LocalDevExtension,
                                   sizeof(CLUS_DEVICE_EXTENSION))) {
                return;
            }
            TargetDevObject = LocalDevExtension.TargetDeviceObject;
        }

        dprintf( "--- \n");
        dprintf( "    DevObj/DevExt/TargetDev  @ %08X, %08X, %08X\n",
                 DeviceObject,
                 DevExtension,
                 TargetDevObject );
        if ( DevExtension ) {
            Dump_DevExt( DevExtension );
        }
        DeviceObject = LocalDeviceObject.NextDevice;

    } // while

    return;

} // Dump_All


DECLARE_API( cddevext )
/*
 *   dump the clusdisk extension structure
 */
{
    PCLUS_DEVICE_EXTENSION TargetExt;
    CLUS_DEVICE_EXTENSION LocalExt;
    BOOL success;
    LONG BytesRead;
    WCHAR LocalDeviceName[512];
    //
    // get address of RGP symbol
    //

    TargetExt = (PCLUS_DEVICE_EXTENSION)GetExpression( args );

    if ( !TargetExt ) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    Dump_DevExt( TargetExt );

    return;
}


DECLARE_API( cddevobj )
/*
 *   dump the clusdisk extension structure for the specfied device object
 */
{
    PDEVICE_OBJECT  deviceAddr;
    DEVICE_OBJECT   deviceObject;
    ULONG           result;

    //
    // get address of RGP symbol
    //

    deviceAddr = (PDEVICE_OBJECT)GetExpression( args );

    if ( !deviceAddr ) {

        dprintf("bad string conversion (%s) \n", args );
        return;

    }

    if ((!ReadMemory( (ULONG_PTR)deviceAddr,
                     &deviceObject,
                     sizeof(deviceObject),
                     &result)) || result < sizeof(deviceObject)) {
        return;
    }

    dprintf( "Device Object @ %08X \n", deviceAddr );
    dprintf( "  Driver Object @ %08X\n", deviceObject.DriverObject );

    Dump_DevExt( deviceObject.DeviceExtension );

    return;
}


DECLARE_API( cddumpall )
/*
 *   dump all the devobjs and devexts
 */
{
    PDEVICE_OBJECT      deviceAddr;

    PDEVICE_OBJECT      deviceObject;
    DEVICE_OBJECT       localDeviceObject;

    ULONG               result;

    //
    // Get clusdisk0 device object.
    //

    deviceAddr = (PDEVICE_OBJECT)GetExpression( "clusdisk!RootDeviceObject" );

    if ( !deviceAddr ) {

        dprintf( "Can't get \\device\\clusdisk0 expression \n" );
        return;
    }

    //
    // Get a copy of clusdisk0 device object.
    //

    if ((!ReadMemory( (ULONG_PTR) deviceAddr,
                     &deviceObject,
                     sizeof(deviceObject),
                     &result)) || result < sizeof(deviceObject)) {

        dprintf( "Unable to read \\device\\clusdisk0 device object \n" );
        return;
    }

    dprintf( "ClusDisk0 DevObj @ %08X \n", deviceObject );

    if ((!ReadMemory( (ULONG_PTR) deviceObject,
                     &localDeviceObject,
                     sizeof(localDeviceObject),
                     &result)) || result < sizeof(localDeviceObject)) {

        dprintf( "Unable to read \\device\\clusdisk0 device object \n" );
        return;
    }

//    dprintf( "  Driver Object @ %08X \n", localDeviceObject.DriverObject );

    Dump_All( localDeviceObject.DriverObject );

    return;

} // dumpall


DECLARE_API( cddevlist )
/*
 *   run down the device list dumping out the contents
 */
{
    PDEVICE_LIST_ENTRY  targetDevList;

    PDEVICE_OBJECT      deviceAddr;

    DEVICE_LIST_ENTRY   localDevList;

    PDEVICE_OBJECT      deviceObject;
    DEVICE_OBJECT       localDeviceObject;

    ULONG               result;

    targetDevList = (PDEVICE_LIST_ENTRY)GetExpression( "clusdisk!ClusDiskDeviceList" );

    if ( !targetDevList ) {

        dprintf("Can't convert clusdisk!ClusDiskDeviceList symbol\n");
        return;
    }

    //
    // Get clusdisk0 device object.

    deviceAddr = (PDEVICE_OBJECT)GetExpression( "clusdisk!RootDeviceObject" );

    if ( !deviceAddr ) {

        dprintf( "Can't get \\device\\clusdisk0 expression \n" );
        return;
    }

    //
    // Get a copy of clusdisk0 device object.
    //

    if ((!ReadMemory( (ULONG_PTR) deviceAddr,
                     &deviceObject,
                     sizeof(deviceObject),
                     &result)) || result < sizeof(deviceObject)) {

        dprintf( "Unable to read \\device\\clusdisk0 device object \n" );
        return;
    }

    dprintf( "ClusDisk0 Device Object @ %08X \n", deviceObject );

    if ((!ReadMemory( (ULONG_PTR) deviceObject,
                     &localDeviceObject,
                     sizeof(localDeviceObject),
                     &result)) || result < sizeof(localDeviceObject)) {

        dprintf( "Unable to read \\device\\clusdisk0 device object \n" );
        return;
    }

    dprintf( "  Driver Object @ %08X \n", localDeviceObject.DriverObject );

    //
    // read head of device list's contents from other machine
    //

    if ( !ReadTargetMemory( targetDevList, &targetDevList, sizeof( PDEVICE_LIST_ENTRY ))) {

        dprintf("Can't get ClusDiskDeviceList data\n");
        return;
    }

    while ( targetDevList != NULL ) {

        if (CheckControlC()) {
            return;
        }

        //
        // read device list entry out of target's memory
        //

        if ( !ReadTargetMemory( targetDevList, &localDevList, sizeof( DEVICE_LIST_ENTRY ))) {

            dprintf("Problem reading device list at %x\n", targetDevList );
            return;

        }

        dprintf( "\nDeviceList @ %08X\n", targetDevList );

#if 0   // Not needed...
        dprintf( "    Next DeviceList @ %08X\n", localDevList.Next );
#endif

        dprintf( "    Signature       = %08X\n", localDevList.Signature );
        dprintf( "    DeviceObject    = %08X\n", localDevList.DeviceObject );

        dprintf( "    Attached        = %s\n", TrueOrFalse( localDevList.Attached ));
        dprintf( "    LettersAssigned = %s\n", TrueOrFalse( localDevList.LettersAssigned ));

        targetDevList = (PDEVICE_LIST_ENTRY)localDevList.Next;
    }

    dprintf("\n");

} // devlist

BOOL
ReadTargetMemory(
    PVOID TargetAddress,
    PVOID LocalBuffer,
    ULONG BytesToRead
    )
{
    BOOL success;
    ULONG BytesRead;

    success = ReadMemory((ULONG_PTR)TargetAddress, LocalBuffer, BytesToRead, &BytesRead);

    if (success) {

        if (BytesRead != BytesToRead) {

            dprintf("wrong byte count. expected=%d, read =%d\n", BytesToRead, BytesRead);
        }

    } else {
        dprintf("Problem reading memory at %08X for %u bytes\n",
                TargetAddress, BytesToRead);

        success = FALSE;
    }

    return success;
}

PCHAR
ListInUse(
    PLIST_ENTRY ListToCheck,
    PLIST_ENTRY RealListAddress
    )
/*
 *  The Lists only hold IRPs!
 */
{
    PIRP Irp;
    IRP  LocalIrp;
    PLIST_ENTRY Next;
    USHORT irpCount = 0;

    if ( ListToCheck->Flink == RealListAddress ) {
        return( "(empty)" );
    } else {
        dprintf( "\n" );
        Next = ListToCheck->Flink;
        while ( Next != RealListAddress ) {
            Irp = CONTAINING_RECORD( Next,
                                     IRP,
                                     Tail.Overlay.ListEntry );
            if ( !ReadTargetMemory((PVOID)Irp,
                               (PVOID)&LocalIrp,
                               sizeof(IRP))) {
                dprintf( "Failed to read irp @ %08X \n", Irp );
                return("");
            }
            dprintf( "     ++ IRP: %08X\n", Irp );
            Next = LocalIrp.Tail.Overlay.ListEntry.Flink;

            if ( irpCount++ > IRP_LIST_MAX ) {
                dprintf( "     ++ Exceeded IRP max (possibly corrupt list) - stopping \n" );
                break;
            }
        }
        return ("");
    }
}

DECLARE_API( help )
{
    dprintf("Clusdisk kd extensions\n\n");
    dprintf("  cddevlist -           dump the clusdisk device list\n");
    dprintf("  cddevext <address> -  dump a devobj's extension structure\n");
    dprintf("  cddrvobj <address> -  dump the driver object\n");
    dprintf("  cddevobj <address> -  dump the devobj's extension\n");
    dprintf("  cddumpall          -  dump all devobj extensions, given a drvobj address\n\n");

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusdisk\ezwrite.c ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    ezwrite.c

Abstract:

    Arbitration Support routines for clusdisk.c

Authors:

    Gor Nishanov     11-June-1998

Revision History:

--*/

#include "clusdskp.h"
#include "clusvmsg.h"
#include "diskarbp.h"
#include <strsafe.h>    // Should be included last.

#if !defined(WMI_TRACING)

#define CDLOG0(Dummy)
#define CDLOG(Dummy1,Dummy2)
#define CDLOGFLG(Dummy0,Dummy1,Dummy2)
#define LOGENABLED(Dummy) FALSE

#else

#include "ezwrite.tmh"

#endif // !defined(WMI_TRACING)

#define ARBITRATION_BUFFER_SIZE PAGE_SIZE

PARBITRATION_ID  gArbitrationBuffer = 0;

NTSTATUS
ArbitrationInitialize(
    VOID
    )
{
    gArbitrationBuffer = ExAllocatePool(NonPagedPool, ARBITRATION_BUFFER_SIZE);
    if( gArbitrationBuffer == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(gArbitrationBuffer, ARBITRATION_BUFFER_SIZE);
    KeQuerySystemTime( &gArbitrationBuffer->SystemTime );
    gArbitrationBuffer->SeqNo.QuadPart = 2; // UserMode arbitration uses 0 and 1 //

    return STATUS_SUCCESS;
}

VOID
ArbitrationDone(
    VOID
    )
{
    if(gArbitrationBuffer != 0) {
        ExFreePool(gArbitrationBuffer);
        gArbitrationBuffer = 0;
    }
}

VOID
ArbitrationTick(
    VOID
    )
{
//   InterlockedIncrement(&gArbitrationBuffer->SeqNo.LowPart);
    ++gArbitrationBuffer->SeqNo.QuadPart;
}

BOOLEAN
ValidSectorSize(
    IN ULONG SectorSize)
{
    // too big //
    if (SectorSize > ARBITRATION_BUFFER_SIZE) {
        return FALSE;
    }

    // too small //
    if (SectorSize < sizeof(ARBITRATION_ID)) {
        return FALSE;
    }

    // not a power of two //
    if (SectorSize & (SectorSize - 1) ) {
        return FALSE;
    }

    return TRUE;
}

NTSTATUS
VerifyArbitrationArgumentsIfAny(
    IN PULONG                 InputData,
    IN LONG                   InputSize
    )
/*++

Routine Description:

    Process Parameters Passed to IOCTL_DISK_CLUSTER_START_RESERVE.

Arguments:

    DeviceExtension - The target device extension
    InputData       - InputData array from Irp
    InputSize       - its size

Return Value:

    NTSTATUS

Notes:

--*/
{
    PSTART_RESERVE_DATA params = (PSTART_RESERVE_DATA)InputData;

    // Old style StartReserve //
    if( InputSize == sizeof(ULONG) ) {
       return STATUS_SUCCESS;
    }

    // We have less arguments than we need //
    if( InputSize < sizeof(START_RESERVE_DATA) ) {
       return STATUS_INVALID_PARAMETER;
    }
    // Wrong Version //
    if(params->Version != START_RESERVE_DATA_V1_SIG) {
       return STATUS_INVALID_PARAMETER;
    }
    // Signature size is invalid //
    if (params->NodeSignatureSize > sizeof(params->NodeSignature)) {
       return STATUS_INVALID_PARAMETER;
    }

    if( !ValidSectorSize(params->SectorSize) ) {
       return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

VOID
ProcessArbitrationArgumentsIfAny(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PULONG                 InputData,
    IN LONG                   InputSize
    )
/*++

Routine Description:

    Process Parameters Passed to IOCTL_DISK_CLUSTER_START_RESERVE.

Arguments:

    DeviceExtension - The target device extension
    InputData       - InputData array from Irp
    InputSize       - its size

Return Value:

    NTSTATUS

Notes:

    Assumes that parameters are valid.
    Use VerifyArbitrationArgumentsIfAny to verify parameters

--*/
{
    PSTART_RESERVE_DATA params = (PSTART_RESERVE_DATA)InputData;

    DeviceExtension->SectorSize = 0; // Invalidate Sector Size //

    // old style StartReserve //
    if( InputSize == sizeof(ULONG) ) {
       return;
    }

    RtlCopyMemory(gArbitrationBuffer->NodeSignature,
                  params->NodeSignature, params->NodeSignatureSize);

    DeviceExtension->ArbitrationSector = params->ArbitrationSector;
    DeviceExtension->SectorSize        = params->SectorSize;
}

NTSTATUS
DoUncheckedReadWrite(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PARBITRATION_READ_WRITE_PARAMS params
)
/*++

Routine Description:

    Prepares read/write IRP and executes it synchronously

Arguments:

    DeviceExtension - The target device extension
    params          - Describes offset, operation, buffer, etc
                      This structure is defined in cluster\inc\diskarbp.h

Return Value:

    NTSTATUS

--*/
{
   PIRP                        irp;
   NTSTATUS                    status;
   PKEVENT                     event;
   IO_STATUS_BLOCK             ioStatusBlock;
   LARGE_INTEGER               offset;
   ULONG                       function = (params->Operation == AE_READ)?IRP_MJ_READ:IRP_MJ_WRITE;
   ULONG                       retryCount = 1;

     event = ExAllocatePool( NonPagedPool,
                             sizeof(KEVENT) );
     if ( !event ) {
         return(STATUS_INSUFFICIENT_RESOURCES);
     }

retry:

   KeInitializeEvent(event,
                     NotificationEvent,
                     FALSE);

   offset.QuadPart = (ULONGLONG) (params->SectorSize * params->SectorNo);

   irp = IoBuildSynchronousFsdRequest(function,
                                      DeviceExtension->TargetDeviceObject,
                                      params->Buffer,
                                      params->SectorSize,
                                      &offset,
                                      event,
                                      &ioStatusBlock);

   if ( irp == NULL ) {
       ExFreePool( event );
       return(STATUS_INSUFFICIENT_RESOURCES);
   }

   status = IoCallDriver(DeviceExtension->TargetDeviceObject,
                         irp);

   if (status == STATUS_PENDING) {
       KeWaitForSingleObject(event,
                             Suspended,
                             KernelMode,
                             FALSE,
                             NULL);
       status = ioStatusBlock.Status;
   }

   if ( !NT_SUCCESS(status) ) {
       if ( retryCount-- &&
            (status == STATUS_IO_DEVICE_ERROR) ) {
           goto retry;
       }
       ClusDiskPrint((
                   1,
                   "[ClusDisk] Failed read/write for Signature %08X, status %lx.\n",
                   DeviceExtension->Signature,
                   status
                   ));
   }

   ExFreePool(event);

   return(status);

} // DoUncheckedReadWrite //


NTSTATUS
WriteToArbitrationSector(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PARB_RESERVE_COMPLETION  Context
    )
/*++

Routine Description:

    Writes to an Arbitration Sector asynchronously.

Arguments:

    DeviceExtension - The device extension for the physical device to reserve.

Return Value:

    NTSTATUS

--*/
{
    LARGE_INTEGER       offset;

    PIRP                        irp = NULL;
    PIO_STACK_LOCATION          irpStack;
    PARB_RESERVE_COMPLETION     arbContext;

    NTSTATUS            status = STATUS_UNSUCCESSFUL;

    if (0 == gArbitrationBuffer || 0 == DeviceExtension->SectorSize) {
        status = STATUS_SUCCESS;
        goto FnExit;
    }

    //
    // Acquire remove lock for this device.  If the IRP is sent, it will be
    // released in the completion routine.
    //

    status = AcquireRemoveLock( &DeviceExtension->RemoveLock, WriteToArbitrationSector );
    if ( !NT_SUCCESS(status) ) {
        goto FnExit;
    }

    //
    // If context is non-null, then we are retrying this I/O.  If null,
    // we need to allocate a context structure for the write.
    //

    if ( Context ) {
        arbContext = Context;
        arbContext->IoEndTime.QuadPart = (ULONGLONG) 0;

    } else {

        arbContext = ExAllocatePool( NonPagedPool, sizeof(ARB_RESERVE_COMPLETION) );

        if ( !arbContext ) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            ReleaseRemoveLock( &DeviceExtension->RemoveLock, WriteToArbitrationSector );
            goto FnExit;
        }

        RtlZeroMemory( arbContext, sizeof(ARB_RESERVE_COMPLETION) );

        //
        // Fill in context structure.  Note we do not specify the optional
        // routines as the write failure is not critical.
        //

        arbContext->RetriesLeft = 1;
        arbContext->LockTag = WriteToArbitrationSector;
        arbContext->DeviceObject = DeviceExtension->DeviceObject;
        arbContext->DeviceExtension = DeviceExtension;
        arbContext->Type = ArbIoWrite;
    }

    KeQuerySystemTime( &arbContext->IoStartTime );

    offset.QuadPart = (ULONGLONG) (DeviceExtension->SectorSize * DeviceExtension->ArbitrationSector);

    irp = IoBuildAsynchronousFsdRequest( IRP_MJ_WRITE,
                                         DeviceExtension->TargetDeviceObject,
                                         gArbitrationBuffer,
                                         DeviceExtension->SectorSize,
                                         &offset,
                                         NULL );

    if ( NULL == irp ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        ExFreePool( arbContext );
        ReleaseRemoveLock( &DeviceExtension->RemoveLock, WriteToArbitrationSector );
        goto FnExit;
    }

    InterlockedIncrement( &DeviceExtension->ArbWriteCount );

    IoSetCompletionRoutine( irp,
                            ArbReserveCompletion,
                            arbContext,
                            TRUE,
                            TRUE,
                            TRUE );

    ClusDiskPrint(( 4,
                    "[ClusDisk] ArbWrite IRP %p for DO %p  DiskNo %u  Sig %08X \n",
                    irp,
                    DeviceExtension->DeviceObject,
                    DeviceExtension->DiskNumber,
                    DeviceExtension->Signature ));

    status = IoCallDriver( DeviceExtension->TargetDeviceObject,
                           irp );

FnExit:

    return status;

} // WriteToArbitrationSector


NTSTATUS
ArbReserveCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine for the asynchronous arbitration write.

Arguments:

    DeviceObject

    Irp - Asynchoronous arbitration write.

    Context - Pointer to ARB_RESERVE_COMPLETION structure.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - must be returned or system will fail!

--*/
{
    PARB_RESERVE_COMPLETION     arbContext = Context;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    PIO_WORKITEM                workItem = NULL;

    PVOID                       lockTag;

    if ( NULL == DeviceObject ) {
        DeviceObject = arbContext->DeviceObject;
    }

    deviceExtension = arbContext->DeviceExtension;

    arbContext->FinalStatus = Irp->IoStatus.Status;

    //
    // Save lock tag here because the context may be freed by the time
    // we need to release remove lock.
    //

    lockTag = arbContext->LockTag;

    KeQuerySystemTime( &arbContext->IoEndTime );

    //
    // Decrement the correct counter based on this I/O type.
    //

    if ( ArbIoReserve == arbContext->Type ) {
        InterlockedDecrement( &deviceExtension->ReserveCount );
    } else if ( ArbIoWrite == arbContext->Type ) {
        InterlockedDecrement( &deviceExtension->ArbWriteCount );
    }

    ClusDiskPrint(( 4,
                    "[ClusDisk] %s IRP %p for DO %p  DiskNo %u  Sig %08X  status %08X \n",
                    ArbIoReserve == arbContext->Type ? "Reserve " : "ArbWrite",
                    Irp,
                    deviceExtension->DeviceObject,
                    deviceExtension->DiskNumber,
                    deviceExtension->Signature,
                    arbContext->FinalStatus ));

    //
    // Retry this request (at least once) for specific failures.
    //

    if ( arbContext->RetriesLeft-- &&
         STATUS_IO_DEVICE_ERROR == arbContext->FinalStatus &&
         arbContext->RetryRoutine ) {

        ClusDiskPrint(( 1,
                        "[ClusDisk] Retrying %s for DO %p  DiskNo %u  Sig %08X \n",
                        ArbIoReserve == arbContext->Type ? "Reserve " : "ArbWrite",
                        deviceExtension->DeviceObject,
                        deviceExtension->DiskNumber,
                        deviceExtension->Signature ));

        //
        // Since we are running in an I/O completion routine, this routine
        // could be running at any IRQL up to DISPATCH_LEVEL.  It would be
        // bad to call back into the driver stack at this level, so queue
        // a work item to retry the I/O.
        //
        // Queue the workitem.  IoQueueWorkItem will insure that the device object
        // referenced while the work-item progresses.
        //

        workItem = IoAllocateWorkItem( DeviceObject );

        if ( workItem ) {

            arbContext->WorkItem = workItem;

            IoQueueWorkItem( workItem,
                             RequeueArbReserveIo,
                             DelayedWorkQueue,
                             Context );
        }

    } else if ( !NT_SUCCESS(arbContext->FinalStatus) ) {

        //
        // If not successful, call the optional failure routine.
        //

        if ( arbContext->FailureRoutine ) {

            (arbContext->FailureRoutine)( arbContext->DeviceExtension,
                                          arbContext );
        }

    } else {

        //
        // On success, call the optional post completion routine.
        //

        if ( arbContext->PostCompletionRoutine ) {

            (arbContext->PostCompletionRoutine)( arbContext->DeviceExtension,
                                                 arbContext );
        }
    }

    ReleaseRemoveLock( &deviceExtension->RemoveLock, lockTag );

    //
    // If we did not allocate a work item, the I/O was not retried and we
    // have to free the context.
    //

    if ( !workItem ) {

        ExFreePool( Context );
    }

    //
    // Unlock and free the MDL.  Then free the IRP.
    //

    if (Irp->MdlAddress != NULL) {

        MmUnlockPages( Irp->MdlAddress );
        IoFreeMdl( Irp->MdlAddress );
        Irp->MdlAddress = NULL;
    }

    IoFreeIrp( Irp );

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // ArbReserveCompletion


RequeueArbReserveIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine runs in a system worker thread.  It will call
    the specified retry routine to requeue a new I/O.

Arguments:

    DeviceObject

    Context - Pointer to ARB_RESERVE_COMPLETION structure.

Return Value:

    None

--*/
{
    PARB_RESERVE_COMPLETION     arbContext = Context;

    BOOLEAN     freeArbContext = FALSE;

    //
    // Call the real routines to rebuild and re-issue the I/O request.
    //

    if ( arbContext->RetryRoutine ) {
        (arbContext->RetryRoutine)( DeviceObject->DeviceExtension,
                                    Context );
    } else {
        freeArbContext = TRUE;
    }

    IoFreeWorkItem( arbContext->WorkItem );

    if ( freeArbContext ) {
        ExFreePool( Context );
    }

}   //  RequeueArbReserveIo



VOID
ArbitrationWrite(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    )
{
   NTSTATUS status;
   status = WriteToArbitrationSector( DeviceExtension, NULL );
   if ( !NT_SUCCESS(status) ) {

      CDLOGF(RESERVE,"ArbitrationWrite(%p) => %!status!",
              DeviceExtension->DeviceObject,
              status );

      ClusDiskPrint((
                  1,
                  "[ClusDisk] Failed to write to arb sector on DiskNo %d Sig %08X  status %08X \n",
                  DeviceExtension->DiskNumber,
                  DeviceExtension->Signature,
                  status ));
   }
}

NTSTATUS
SimpleDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG          Ioctl,
    IN PVOID          InBuffer,
    IN ULONG          InBufferSize,
    IN PVOID          OutBuffer,
    IN ULONG          OutBufferSize)
{
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatusBlock;

    PKEVENT                 event = 0;
    PIRP                    irp   = 0;

    CDLOG( "SimpleDeviceIoControl(%p): Entry Ioctl %x", DeviceObject, Ioctl );

    event = ExAllocatePool( NonPagedPool, sizeof(KEVENT) );
    if ( event == NULL ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        ClusDiskPrint((
                1,
                "[ClusDisk] SimpleDeviceIoControl: Failed to allocate event\n" ));
        goto exit_gracefully;
    }

    irp = IoBuildDeviceIoControlRequest(
              Ioctl,
              DeviceObject,
              InBuffer, InBufferSize,
              OutBuffer, OutBufferSize,
              FALSE,
              event,
              &ioStatusBlock);
    if ( !irp ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        ClusDiskPrint((
            1,
            "[ClusDisk] SimpleDeviceIoControl. Failed to build IRP %x.\n",
            Ioctl
            ));
        goto exit_gracefully;
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(event, NotificationEvent, FALSE);

    status = IoCallDriver(DeviceObject, irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);

        status = ioStatusBlock.Status;
    }

exit_gracefully:

    if ( event ) {
        ExFreePool( event );
    }

    CDLOG( "SimpleDeviceIoControl(%p): Exit Ioctl %x => %x",
           DeviceObject, Ioctl, status );

    return status;

} // SimpleDeviceIoControl



/*++

Routine Description:

    Arbitration support routine. Currently provides ability to read/write
    physical sectors on the disk while the device is offline

Arguments:

    SectorSize:  requred sector size
                    (Assumes that the SectorSize is a power of two)

Return Value:

    STATUS_INVALID_PARAMETER
    STATUS_SUCCESS

Notes:

--*/
NTSTATUS
ProcessArbitrationEscape(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PULONG                 InputData,
    IN LONG                   InputSize,
    IN PULONG                 OutputSize
    )
{
    NTSTATUS status = STATUS_INVALID_PARAMETER;
    PARBITRATION_READ_WRITE_PARAMS params;

    if( InputData[0] != AE_SECTORSIZE ) {
        *OutputSize = 0;
    }

    switch(InputData[0]) {

    // Users can query whether ARBITRATION_ESCAPE is present by calling //
    // AE_TEST subfunction                                              //

    case AE_TEST:
        status = STATUS_SUCCESS;
        break;

    case AE_WRITE:
    case AE_READ:
        if(InputSize < ARBITRATION_READ_WRITE_PARAMS_SIZE) {
            break;
        }
        params = (PARBITRATION_READ_WRITE_PARAMS)InputData;
        if ( !ValidSectorSize(params->SectorSize) ) {
            break;
        }

        //
        // This IOCTL is method buffered and the user data buffer is a pointer within
        // this buffered structure.  The user buffer is checked now for read/write
        // access, and will be probed and locked in IoBuildSynchronousFsdRequest.
        //

        try {
            ProbeForWrite( params->Buffer, params->SectorSize, sizeof( UCHAR ) );
            ProbeForRead ( params->Buffer, params->SectorSize, sizeof( UCHAR ) );
            status = DoUncheckedReadWrite(DeviceExtension, params);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
        break;

    case AE_POKE:
        {
            PARTITION_INFORMATION partInfo;

            status = SimpleDeviceIoControl(
                        DeviceExtension->TargetDeviceObject,
                        IOCTL_DISK_GET_PARTITION_INFO,
                        NULL, 0,
                        &partInfo, sizeof(PARTITION_INFORMATION) );
            break;
        }
    case AE_RESET:
        {
            ClusDiskLogError( DeviceExtension->DriverObject,        // OK - DevObj is cluster DevObj
                              DeviceExtension->DeviceObject,
                              DeviceExtension->ScsiAddress.PathId,  // Sequence number
                              IRP_MJ_DEVICE_CONTROL,                // Major function code
                              0,                                    // Retry count
                              ID_CLUSTER_ARB_RESET,                 // Unique error
                              STATUS_SUCCESS,
                              CLUSDISK_RESET_BUS_REQUESTED,
                              0,
                              NULL );

            status = ResetScsiDevice( NULL, &DeviceExtension->ScsiAddress );
            break;
        }
    case AE_RESERVE:
        {
            status = SimpleDeviceIoControl(
                        DeviceExtension->TargetDeviceObject,
                        IOCTL_STORAGE_RESERVE,
                        NULL, 0, NULL, 0 );
            break;
        }
    case AE_RELEASE:
        {
            status = SimpleDeviceIoControl(
                        DeviceExtension->TargetDeviceObject,
                        IOCTL_STORAGE_RELEASE,
                        NULL, 0, NULL, 0 );
            break;
        }
    case AE_SECTORSIZE:
        {
            DISK_GEOMETRY diskGeometry;
            if (*OutputSize < sizeof(ULONG)) {
                status =  STATUS_BUFFER_TOO_SMALL;
                *OutputSize = 0;
                break;
            }
            status = SimpleDeviceIoControl(
                        DeviceExtension->TargetDeviceObject,
                        IOCTL_DISK_GET_DRIVE_GEOMETRY,
                        NULL, 0,
                        &diskGeometry, sizeof(diskGeometry) );

            if ( NT_SUCCESS(status) ) {
                *InputData = diskGeometry.BytesPerSector;
                *OutputSize = sizeof(ULONG);
            } else {
                *OutputSize = 0;
            }
            break;
        }
    }

    return(status);
} // ProcessArbitrationEscape //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusdisk\clusdskp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    clusdskp.h

Abstract:

    Private header file for the cluster disk driver.

Authors:

    Rod Gamache     30-Mar-1997

Environment:

    kernel mode only

Notes:

Revision History:


--*/

#define _NTDDK_ // [HACKHACK] to make ProbeForRead work. Better to include ntddk instead of ntos //

#include "ntos.h"
#include "zwapi.h"
#include "stdarg.h"
#include "stdio.h"
#include "ntddscsi.h"
#include "ntdddisk.h"
#include "clusdef.h"

#if 1                // turn on tagging all the time
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'kdSC')
#endif


//
// Global definitions
//

#define CLUSDISK_ROOT_DEVICE                L"\\Device\\ClusDisk0"
#define CLUSDISK_SIGNATURE_DISK_NAME        L"DiskName"
#define CLUSDISK_SIGNATURE_FIELD            L"\\12345678"
#define CLUSDISK_PARAMETERS_KEYNAME         L"\\Parameters"
#define CLUSDISK_SIGNATURE_KEYNAME          L"\\Signatures"
#define CLUSDISK_AVAILABLE_DISKS_KEYNAME    L"\\AvailableDisks"
#define CLUSDISK_SINGLE_BUS_KEYNAME         L"SingleBus"

#define CLUSSVC_VALUENAME_MANAGEDISKSONSYSTEMBUSES L"ManageDisksOnSystemBuses"

#define ID_CLEANUP              ' nlC'
#define ID_CLEANUP_DEV_OBJ      'OnlC'
#define ID_CLUSTER_RESET_IOCTL  'tsRI'
#define ID_RESET                ' tsR'
#define ID_CLUSTER_ARB_RESET    'tsRA'
#define ID_RESET_BUSSES         'BtsR'
#define ID_GET_PARTITION        'traP'
#define ID_GET_GEOMETRY         'moeG'

#define UNINITIALIZED_DISK_NUMBER           (ULONG)-1

#define MAX_BUSSES          20              // Maximum number of shared busses

#define MAX_BUFFER_SIZE     256             // Maximum buffer size

#define MAX_RETRIES 2

//
// KeEnterCriticalRegion is required if resource
// acquisition is done at a PASSIVE level in the context
// of non-kernel thread.
//
// KeEnterCriticalRegion() == KeGetCurrentThread()->KernelApcDisable -= 1;
//
// guarantees that the thread in which we execute cannot get
// suspeneded in APC while we own the global resource.
//

#define ACQUIRE_EXCLUSIVE( _lock ) \
    do { KeEnterCriticalRegion();ExAcquireResourceExclusiveLite(_lock, TRUE); } while(0)

#define ACQUIRE_SHARED( _lock ) \
    do { KeEnterCriticalRegion();ExAcquireResourceSharedLite(_lock, TRUE); } while(0)

#define RELEASE_EXCLUSIVE( _lock ) \
    do { ExReleaseResourceLite( _lock );KeLeaveCriticalRegion(); } while(0)

#define RELEASE_SHARED( _lock ) \
    do { ExReleaseResourceLite( _lock );KeLeaveCriticalRegion(); } while(0)


// #define RESERVE_TIMER   3 // [GN] moved to cluster\inc\diskarbp.h

#if DBG
#define ClusDiskPrint(x)  ClusDiskDebugPrint x
#define WCSLEN_ASSERT( _buf )   ( wcslen( _buf ) < (sizeof( _buf ) / sizeof( WCHAR )))
#else
#define ClusDiskPrint(x)
#define WCSLEN_ASSERT( _buf )
#endif  // DBG


//
// Error log messages
//
#define CLUSDISK_BAD_DEVICE L"Skipping device. Possible filter driver installed!"


//
// Macros

#define IsAlpha( c ) \
    ( ((c) >= 'a' && (c) <= 'z') || ((c) >='A' && (c) <= 'Z') )

//
// Device Extension
//

typedef struct _CLUS_DEVICE_EXTENSION {

    //
    // Back pointer to this extension's device object
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // device object to which clusdisk's device obj is attached
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    // back ptr to clusdisk Partition0 Device Object
    //

    PDEVICE_OBJECT PhysicalDevice;

    //
    // The SCSI_ADDRESS for this device
    //

    SCSI_ADDRESS    ScsiAddress;

    //
    // Disk signature
    //

    ULONG           Signature;

    //
    // Disk number for reference on verifying attach
    //

    ULONG          DiskNumber;

    //
    // Disk State. This is only maintained in the physical or partition
    // zero extension.
    //

    ULONG          DiskState;

    //
    // Reservation timer - valid on the physical (partition0) extension
    //

    ULONG          ReserveTimer;

    //
    // Time last reserve started.  Not protected by a lock as only one
    // routine ever updates this value.
    //

    LARGE_INTEGER   LastReserveStart;

    //
    // Event flag for use with reservation IRP.
    // Use is controlled by the TimerBusy flag.
    //

    KEVENT          Event;

    //
    // The bus type.  E.G. Scsi, SSA, etc.
    //

    ULONG           BusType;

    //
    // Last reserve failure.
    //

    NTSTATUS        ReserveFailure;

    //
    // Waiting IOCTL's looking for Reserve Failure notification.
    //

    LIST_ENTRY      WaitingIoctls;

    //
    // Work queue item context.
    //

    WORK_QUEUE_ITEM WorkItem;

    //
    // Reservation time IRP
    //

    BOOLEAN         PerformReserves;

    //
    // Work queue item busy.
    //

    BOOLEAN         TimerBusy;

    //
    // Attached state. True if this device object is supposed to be
    // attached. False if not sure.
    //

    BOOLEAN         AttachValid;

    //
    // Device is detached.
    //

    BOOLEAN         Detached;

    //
    // Flag to indicate offline/terminate is in process.
    //

    BOOLEAN         OfflinePending;

    //
    // The driver object for use on repartitioning. RNGFIX -???
    //

    PDRIVER_OBJECT DriverObject;

    //
    // The partition number for the last extension created
    // only maintained in the physical or partition zero extension.
    //

    ULONG          LastPartitionNumber;

    //
    // context value for when we deregister from disk device
    // notifications
    //

    PVOID          DiskNotificationEntry;

    //
    // context value for when we deregister from mounted device
    // notifications
    //

    PVOID          VolumeNotificationEntry;

    // [GN]
    //      Physical Sector Size of the device
    //      If SectorSize == 0 then
    //      persistent writing is disabled

    ULONG          SectorSize;

    //
    //      Physical Sector which is used
    //      for persistent reservations.

    ULONG          ArbitrationSector;

    //
    //      For tracing purposes:
    //      Approximate time of the last write to
    //      the disk. (Approximate, because we
    //      update this field without holding any locks)
    //

    LARGE_INTEGER  LastWriteTime;

    //
    // P0 object stores an array of handles to all volumes on
    // this disk to be dismounted when offline happens
    // First entry in this array is a number of handles in the array
    //

    PHANDLE VolumeHandles;

    //
    // Lock to prevent removal while I/O in progress.
    //

    IO_REMOVE_LOCK  RemoveLock;

    //
    // Keep track of paging files, crash dump files, and hibernation files.
    //

    KEVENT          PagingPathCountEvent;
    ULONG           PagingPathCount;
    ULONG           HibernationPathCount;
    ULONG           DumpPathCount;

    //
    // Cache partition info when possible.
    //

    PDRIVE_LAYOUT_INFORMATION_EX    DriveLayout;
    ULONG                       DriveLayoutSize;
    ERESOURCE                   DriveLayoutLock;

    //
    // Number of arbitration writes and reserves in progress.
    //

    LONG    ArbWriteCount;
    LONG    ReserveCount;

    //
    // Time when the last reserve successfully completed.
    // Protected by ReserveInfoLock as this value could be updated
    // by multiple threads.
    //

    LARGE_INTEGER   LastReserveEnd;

    //
    // Lock to control access to LastReserveEnd
    //

    ERESOURCE       ReserveInfoLock;

} CLUS_DEVICE_EXTENSION, *PCLUS_DEVICE_EXTENSION;

#define DEVICE_EXTENSION_SIZE sizeof(CLUS_DEVICE_EXTENSION)

//
// Device list entry
//

typedef struct _DEVICE_LIST_ENTRY {
    struct _DEVICE_LIST_ENTRY *Next;
    ULONG   Signature;
    PDEVICE_OBJECT DeviceObject;
    BOOLEAN Attached;
    BOOLEAN LettersAssigned;
    BOOLEAN FreePool;
} DEVICE_LIST_ENTRY, *PDEVICE_LIST_ENTRY;

typedef struct _SCSI_BUS_ENTRY {
    struct _SCSI_BUS_ENTRY *Next;
    UCHAR   Port;
    UCHAR   Path;
    USHORT  Reserved;
} SCSI_BUS_ENTRY, *PSCSI_BUS_ENTRY;

typedef enum _ClusterBusType {
    RootBus,
    ScsiBus,
    UnknownBus
} ClusterBusType;


typedef struct _WORK_CONTEXT {
    LIST_ENTRY      ListEntry;
    PDEVICE_OBJECT  DeviceObject;
    KEVENT          CompletionEvent;
    NTSTATUS        FinalStatus;
    PVOID           Context;
    PIO_WORKITEM    WorkItem;
} WORK_CONTEXT, *PWORK_CONTEXT;

//
// Flags for ClusDiskpReplaceHandleArray
//

enum {
    DO_DISMOUNT         = 0x00000001,
    RELEASE_REMOVE_LOCK = 0x00000002,
    CLEANUP_STORAGE     = 0x00000004,
    SET_PART0_EVENT     = 0x00000008,
};

typedef struct _REPLACE_CONTEXT {
    PCLUS_DEVICE_EXTENSION  DeviceExtension;
    PHANDLE                 NewValue;           // OPTIONAL
    PHANDLE                 OldValue;
    PKEVENT                 Part0Event;
    ULONG                   Flags;
} REPLACE_CONTEXT, *PREPLACE_CONTEXT;

typedef struct _HALTPROC_CONTEXT {
    PCLUS_DEVICE_EXTENSION  DeviceExtension;
    PHANDLE                 FileHandle;
} HALTPROC_CONTEXT, *PHALTPROC_CONTEXT;

typedef struct _VOL_STATE_INFO {
    PIO_WORKITEM    WorkItem;
    ULONG           NewDiskState;
} VOL_STATE_INFO, *PVOL_STATE_INFO;

typedef struct _DEVICE_CHANGE_CONTEXT {
    PIO_WORKITEM    WorkItem;
    PCLUS_DEVICE_EXTENSION  DeviceExtension;
    UNICODE_STRING          SymbolicLinkName;
    ULONG                   Signature;
    ULONG                   DeviceNumber;
    ULONG                   PartitionNumber;
    SCSI_ADDRESS            ScsiAddress;
} DEVICE_CHANGE_CONTEXT, *PDEVICE_CHANGE_CONTEXT;

//
// Structure for offline to preserve snapshots.
//

typedef struct _OFFLINE_ENTRY {
    ULONG DiskNumber;
    ULONG PartitionNumber;
    BOOLEAN OfflineSent;
    struct _OFFLINE_ENTRY * Next;
} OFFLINE_ENTRY, *POFFLINE_ENTRY;

//
// Structure to offline disk in sync thread instead of using
// worker thread (async).
//

typedef struct _OFFLINE_DISK_ENTRY {
    PCLUS_DEVICE_EXTENSION DeviceExtension;
    struct _OFFLINE_DISK_ENTRY * Next;
} OFFLINE_DISK_ENTRY, *POFFLINE_DISK_ENTRY;

//
// Info for synchronous reserves and arbitration
//

typedef NTSTATUS ( * ArbFunction)( IN PCLUS_DEVICE_EXTENSION DeviceExtenion,
                                   IN PVOID Context );

typedef enum _ArbIoType {
    ArbIoWrite,
    ArbIoReserve,
    ArbIoInvalid
} ArbIoType;

typedef struct _ARB_RESERVE_COMPLETION {
    LARGE_INTEGER   IoStartTime;
    LARGE_INTEGER   IoEndTime;
    ULONG           RetriesLeft;
    ArbIoType       Type;
    PVOID           LockTag;
    PDEVICE_OBJECT  DeviceObject;
    PCLUS_DEVICE_EXTENSION  DeviceExtension;
    PIO_WORKITEM    WorkItem;
    NTSTATUS        FinalStatus;
    ArbFunction     RetryRoutine;           // Optional routine called if I/O fails & RetriesLeft > 0
    ArbFunction     FailureRoutine;         // Optional routine called if I/O fails & RetriesLeft == 0
    ArbFunction     PostCompletionRoutine;  // Optional routine called if I/O succeeds
} ARB_RESERVE_COMPLETION, *PARB_RESERVE_COMPLETION;


//
// Function declarations
//


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
ClusDiskScsiInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID NextDisk,
    IN ULONG Count
    );

VOID
ClusDiskUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
ClusDiskCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
ClusDiskDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskRootDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
ClusDiskShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskNewDiskCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
ClusDiskSetLayoutCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
ClusDiskDismountDevice(
    IN ULONG    DiskNumber,
    IN BOOLEAN  ForceDismount
    );

BOOLEAN
ClusDiskAttached(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG    DiskNumber
    );

BOOLEAN
ClusDiskVerifyAttach(
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
AddAttachedDevice(
    IN ULONG Signature,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
MatchDevice(
    IN ULONG Signature,
    OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
GetScsiAddress(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_ADDRESS ScsiAddress
    );

VOID
ClusDiskWriteDiskInfo(
    IN ULONG Signature,
    IN ULONG DiskNumber,
    IN LPWSTR KeyName
    );

PDRIVE_LAYOUT_INFORMATION_EX
ClusDiskGetPartitionInfo(
    PCLUS_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
ClusDiskTryAttachDevice(
    ULONG          Signature,
    ULONG          NextDisk,
    PDRIVER_OBJECT DriverObject,
    BOOLEAN        InstallMode
    );

NTSTATUS
ClusDiskAttachDevice(
    ULONG          Signature,
    ULONG          NextDisk,
    PDRIVER_OBJECT DriverObject,
    BOOLEAN        Reset,
    BOOLEAN        *StopProcessing,
    BOOLEAN        InstallMode
    );

NTSTATUS
ClusDiskDetachDevice(
    ULONG          Signature,
    PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DismountDevice(
    IN HANDLE FileHandle
    );

NTSTATUS
ClusDiskGetDiskGeometry(
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
GetDiskGeometry(
    PDEVICE_OBJECT DeviceObject,
    PMEDIA_TYPE MediaType
    );

PDRIVE_LAYOUT_INFORMATION_EX
GetPartitionInfo(
    PDEVICE_OBJECT DeviceObject,
    NTSTATUS       *Status
    );

NTSTATUS
ResetScsiDevice(
    IN HANDLE ScsiportHandle,
    IN PSCSI_ADDRESS ScsiAddress
    );

NTSTATUS
ReserveScsiDevice(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PVOID Context
    );

VOID
ReleaseScsiDevice(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
AttachedDevice(
    IN ULONG Signature,
    OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
EnableHaltProcessing(
    IN KIRQL *Irql
    );

NTSTATUS
DisableHaltProcessing(
    IN KIRQL *Irql
    );

VOID
ClusDiskEventCallback(
    IN CLUSNET_EVENT_TYPE   EventType,
    IN CL_NODE_ID           NodeId,
    IN CL_NETWORK_ID        NetworkId
    );

VOID
ClusDiskLogError(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN ULONG SequenceNumber,
    IN UCHAR MajorFunctionCode,
    IN UCHAR RetryCount,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfText,
    IN PWCHAR Text
    );

NTSTATUS
DismountPartition(
    IN PDEVICE_OBJECT TargetDevice,
    IN ULONG DiskNumber,
    IN ULONG PartNumber
    );


#if DBG
VOID
ClusDiskDebugPrint(
    IN ULONG Level,
    IN PCHAR DebugMessage,
    ...
    );
#endif


VOID
GetSymbolicLink(
    IN PWCHAR Root,
    IN OUT PWCHAR Path
    );

NTSTATUS
ClusDiskGetTargetDevice(
    IN ULONG                        DiskNumber,
    IN ULONG                        PartitionNumber,
    OUT PDEVICE_OBJECT              * DeviceObject OPTIONAL,
    IN OUT PUNICODE_STRING          UnicodeString,
    OUT PDRIVE_LAYOUT_INFORMATION_EX   * PartitionInfo OPTIONAL,
    OUT PSCSI_ADDRESS               ScsiAddress OPTIONAL,
    IN BOOLEAN                      Reset
    );

//[GN]
NTSTATUS
ArbitrationInitialize(
    VOID
    );

VOID
ArbitrationDone(
    VOID
    );

VOID
ArbitrationTick(
    VOID
    );

VOID
ArbitrationWrite(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
VerifyArbitrationArgumentsIfAny(
    IN PULONG                 InputData,
    IN LONG                   InputSize
    );

VOID
ProcessArbitrationArgumentsIfAny(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PULONG                 InputData,
    IN LONG                   InputSize
    );

NTSTATUS
ProcessArbitrationEscape(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PULONG                 InputData,
    IN LONG                   InputSize,
    IN OUT PULONG             OutputSize
    );

NTSTATUS
SimpleDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG          Ioctl,
    IN PVOID          InBuffer,
    IN ULONG          InBufferSize,
    IN PVOID          OutBuffer,
    IN ULONG          OutBufferSize);

NTSTATUS
ClusDiskInitRegistryString(
    OUT PUNICODE_STRING UnicodeString,
    IN  LPWSTR          KeyName,
    IN  ULONG           KeyNameChars
    );

NTSTATUS
ClusDiskAddSignature(
    IN PUNICODE_STRING  UnicodeString,
    IN ULONG   Signature,
    IN BOOLEAN Volatile
    );

NTSTATUS
ClusDiskDeleteSignature(
    IN PUNICODE_STRING  UnicodeString,
    IN ULONG   Signature
    );

ULONG
ClusDiskIsSignatureDisk(
    IN ULONG Signature
    );

NTSTATUS
ClusDiskMarkIrpPending(
    PIRP                Irp,
    PDRIVER_CANCEL      CancelRoutine
    );

VOID
ClusDiskCompletePendingRequest(
    IN PIRP                 Irp,
    IN NTSTATUS             Status,
    PCLUS_DEVICE_EXTENSION  DeviceExtension
    );

VOID
ClusDiskIrpCancel(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

MEDIA_TYPE
GetMediaType(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
GetScsiPortNumber(
    IN ULONG DiskSignature,
    IN PUCHAR DiskPortNumber
    );

NTSTATUS
IsDiskClusterCapable(
   IN UCHAR PortNumber,
   OUT PBOOLEAN IsCapable
   );

NTSTATUS
GetBootTimeSystemRoot(
    IN OUT PWCHAR        Path
    );

NTSTATUS
GetRunTimeSystemRoot(
    IN OUT PWCHAR        Path
    );

NTSTATUS
GetSystemRootPort(
    VOID
    );

VOID
ResetScsiBusses(
    VOID
    );

NTSTATUS
GetDriveLayout(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PDRIVE_LAYOUT_INFORMATION_EX *DriveLayout,
    BOOLEAN UpdateCachedLayout,
    BOOLEAN FlushStorageDrivers
    );

NTSTATUS
ClusDiskInitialize(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
LockVolumes(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
ClusDiskHaltProcessingWorker(
    IN PVOID Context
    );

VOID
SendOfflineDirect(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
ClusDiskRescanWorker(
    IN PVOID Context
    );

VOID
ClusDiskTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
RegistryQueryValue(
    PVOID hKey,
    LPWSTR pValueName,
    PULONG pulType,
    PVOID pData,
    PULONG pulDataSize
    );

NTSTATUS
ClusDiskCreateHandle(
    OUT PHANDLE     pHandle,
    IN  ULONG       DiskNumber,
    IN  ULONG       PartitionNumber,
    IN  ACCESS_MASK DesiredAccess
    );

VOID
ClusDiskCompletePendedIrps(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN ULONG        Offline
    );

NTSTATUS
ClusDiskOfflineEntireDisk(
    IN PDEVICE_OBJECT Part0DeviceObject
    );

NTSTATUS
ClusDiskDismountVolumes(
    IN PDEVICE_OBJECT Part0DeviceObject,
    IN BOOLEAN RelRemLock
    );

NTSTATUS
ClusDiskForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ClusDiskReservationWorker(
    IN PCLUS_DEVICE_EXTENSION  DeviceExtension
    );

VOID
ClusDiskpReplaceHandleArray(
    PDEVICE_OBJECT DeviceObject,
    PWORK_CONTEXT WorkContext
    );

VOID
ClusDiskpOpenFileHandles(
    PDEVICE_OBJECT Part0DeviceObject,
    PWORK_CONTEXT WorkContext
    );

NTSTATUS
EjectVolumes(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ReclaimVolumes(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ProcessDelayedWorkAsynchronous(
    PDEVICE_OBJECT DeviceObject,
    PVOID WorkerRoutine,
    PVOID Context
    );

NTSTATUS
ProcessDelayedWorkSynchronous(
    PDEVICE_OBJECT DeviceObject,
    PVOID WorkerRoutine,
    PVOID Context
    );

VOID
EnableHaltProcessingWorker(
    PDEVICE_OBJECT DeviceObject,
    PWORK_CONTEXT WorkContext
    );

VOID
DisableHaltProcessingWorker(
    PDEVICE_OBJECT DeviceObject,
    PWORK_CONTEXT WorkContext
    );

NTSTATUS
GetRegistryValue(
    PUNICODE_STRING KeyName,
    PWSTR ValueName,
    PULONG ReturnValue
    );

NTSTATUS
SetVolumeState(
    PCLUS_DEVICE_EXTENSION PhysicalDisk,
    ULONG NewDiskState
    );

VOID
SetVolumeStateWorker(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context
    );

NTSTATUS
AttachSignatureList(
    PDEVICE_OBJECT DeviceObject,
    PULONG InBuffer,
    ULONG InBufferLen
    );

NTSTATUS
DetachSignatureList(
    PDEVICE_OBJECT DeviceObject,
    PULONG InBuffer,
    ULONG InBufferLen
    );

NTSTATUS
IsVolumeMounted(
    IN ULONG DiskNumber,
    IN ULONG PartNumber,
    OUT BOOLEAN *IsMounted
    );

NTSTATUS
SendFtdiskIoctlSync(
    PDEVICE_OBJECT TargetObject,
    IN ULONG DiskNumber,
    IN ULONG PartNumber,
    ULONG Ioctl
    );

NTSTATUS
ClusDiskDeviceChangeNotification(
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION DeviceChangeNotification,
    IN PCLUS_DEVICE_EXTENSION      DeviceExtension
    );

NTSTATUS
ClusDiskDeviceChangeNotificationWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
ClusDiskVolumeChangeNotification(
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION DeviceChangeNotification,
    IN PCLUS_DEVICE_EXTENSION      DeviceExtension
    );

NTSTATUS
ClusDiskVolumeChangeNotificationWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
ProcessDeviceArrival(
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION DeviceChangeNotification,
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN VolumeArrival
    );

NTSTATUS
CleanupDeviceList(
    PDEVICE_OBJECT DeviceObject
    );

VOID
CleanupDeviceListWorker(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context
    );

NTSTATUS
CreateVolumeObject(
    PCLUS_DEVICE_EXTENSION ZeroExtension,
    ULONG DiskNumber,
    ULONG PartitionNumber,
    PDEVICE_OBJECT TargetDev
    );

NTSTATUS
WaitForAttachCompletion(
    PCLUS_DEVICE_EXTENSION DeviceExtension,
    BOOLEAN WaitForInit,
    BOOLEAN CheckPhysDev
    );

NTSTATUS
GetReserveInfo(
    PVOID   InOutBuffer,
    ULONG   InSize,
    ULONG*  OutSize
    );

NTSTATUS
SetDiskState(
    PVOID InBuffer,
    ULONG InBufferLength,
    ULONG OutBufferLength,
    ULONG *BytesReturned
    );

NTSTATUS
ArbReserveCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

RequeueArbReserveIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
CheckReserveTiming(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PVOID Context
    );

NTSTATUS
HandleReserveFailure(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PVOID Context
    );

#if DBG

//
// RemoveLock tracing functions.
//

NTSTATUS
AcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN OPTIONAL PVOID Tag
    );

VOID
ReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID Tag
    );

VOID
ReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID Tag
    );

//
// Debug print helper routines
//

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
    );

PCHAR
BoolToString(
    BOOLEAN Value
    );

PCHAR
DiskStateToString(
    ULONG DiskState
    );


#else

#define ReleaseRemoveLock(RemoveLock, Tag)          IoReleaseRemoveLock(RemoveLock, Tag)

NTSTATUS
AcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN OPTIONAL PVOID Tag
    );

VOID
ReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID Tag
    );

#endif

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(ClusdiskLH,(b25a9257,9a39,43df,9f35,b0976e28e843), \
      WPP_DEFINE_BIT(DEFAULT) \
      WPP_DEFINE_BIT(CREATE)  \
      WPP_DEFINE_BIT(CLOSE)   \
      WPP_DEFINE_BIT(CLEANUP) \
      WPP_DEFINE_BIT(UNPEND)  \
      WPP_DEFINE_BIT(LEGACY)  \
   )                          \
   WPP_DEFINE_CONTROL_GUID(ClusdiskHB,(7f827e76,1a10,11d3,ba86,00c04f8eed00), \
      WPP_DEFINE_BIT(RESERVE) \
      WPP_DEFINE_BIT(READ)    \
      WPP_DEFINE_BIT(WRITE)   \
      WPP_DEFINE_BIT(TICK)    \
   )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusdisk\test\mountie.h ===
DWORD
DevfileOpen(
    OUT HANDLE *Handle,
    IN  wchar_t *Pathname
    );

VOID
DevfileClose(
    IN HANDLE Handle
    );

DWORD
DevfileIoctl(
    HANDLE Handle,
    DWORD Ioctl,
    PVOID Inbuf,
    ULONG Inbufsize,
    PVOID OutBuf,
    DWORD OutBufSize,
    LPDWORD ReturnedBufsize
    );


DWORD
DisksAssignDosDevice(
    PCHAR   MountName,
    PWCHAR  VolumeDevName
    );

DWORD
DisksRemoveDosDevice(
    PCHAR   MountName
    );

DWORD
FindFirstVolumeForSignature(
    IN  HANDLE MountMgrHandle,
    IN  DWORD Signature,
    OUT LPSTR VolumeName,
    IN  DWORD BufferLength,
    OUT LPHANDLE Handle,
    OUT PVOID UniqueId OPTIONAL,
    IN OUT LPDWORD IdLength,
    OUT PUCHAR DriveLetter OPTIONAL
    );

DWORD
FindNextVolumeForSignature(
    IN  HANDLE MountMgrHandle,
    IN  DWORD Signature,
    IN  HANDLE Handle,
    OUT LPSTR VolumeName,
    IN  DWORD BufferLength,
    OUT PVOID UniqueId OPTIONAL,
    IN OUT LPDWORD IdLength,
    OUT PUCHAR DriveLetter OPTIONAL
    );

DWORD
DisksSetDiskInfo(
    IN HKEY RegistryKey,
    IN DWORD Signature
    );

DWORD
DisksSetMountMgr(
    IN HKEY RegistryKey,
    IN DWORD Signature
    );

BOOL
DisksDoesDiskInfoMatch(
    IN HKEY RegistryKey,
    IN DWORD Signature
    );

BOOL
DisksIsDiskInfoValid(
    IN HKEY RegistryKey,
    IN DWORD Signature
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusexts\clusexts\clusexts.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    clusexts.c

Abstract:

    This function contains the default cluster debugger extensions

Author:

    Sunita Shrivastava (sunitas) 19-May-1997

Revision History:

--*/

#include "clusextp.h"
#include "omextp.h"
//#include "resextp.h"

NTSD_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;



DECLARE_API( version )
{
    OSVERSIONINFOA VersionInformation;
    HKEY hkey;
    DWORD cb, dwType;
    CHAR szCurrentType[128];
    CHAR szCSDString[3+128];

    INIT_API();

    VersionInformation.dwOSVersionInfoSize = sizeof(VersionInformation);
    if (!GetVersionEx( &VersionInformation )) {
        dprintf("GetVersionEx failed - %u\n", GetLastError());
        return;
        }

    szCurrentType[0] = '\0';
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "Software\\Microsoft\\Windows NT\\CurrentVersion",
                     0,
                     KEY_READ,
                     &hkey
                    ) == NO_ERROR
       )
    {
        cb = sizeof(szCurrentType);
        if (RegQueryValueEx(hkey, "CurrentType", NULL, &dwType, szCurrentType, &cb ) != 0) {
            szCurrentType[0] = '\0';
            }
        RegCloseKey(hkey);
    }

    if (VersionInformation.szCSDVersion[0]) {
        sprintf(szCSDString, ": %s", VersionInformation.szCSDVersion);
        }
    else {
        szCSDString[0] = '\0';
        }

    dprintf("Version %d.%d (Build %d%s) %s\n",
          VersionInformation.dwMajorVersion,
          VersionInformation.dwMinorVersion,
          VersionInformation.dwBuildNumber,
          szCSDString,
          szCurrentType
         );
    return;
}

void VersionHelp()
{
    dprintf("!ver : Dump cluster version\n");
}

DECLARE_API( help )
{
    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if (*lpArgumentString == '\0') {
        dprintf("clusexts help:\n\n");
        dprintf("!help [!cmd]          - Show the supported commands\n");
        dprintf("!clusobj              - Dump the cluster service objects\n");
        dprintf("!resobj               - Dump the resource monitor objects\n");
        dprintf("!version              - Dump cluster version and build number\n");
        dprintf("!leaks                - Dump leaks.dll info\n");
        dprintf("!dblink               - Dump a list via its Blinks\n");
        dprintf("!dflink               - Dump a list via its Flinks\n");
        dprintf("!dumpsid              - Dump the domain account associated with a SID\n");
        dprintf("!proplist addr        - Dump a property list at the specified address\n");

    } else {
        if (*lpArgumentString == '!')
            lpArgumentString++;
        if (strcmp(lpArgumentString, "clusobj") == 0) {
            ClusObjHelp();
        } else if (strcmp(lpArgumentString, "resobj") == 0) {
            ResObjHelp();
        } else if (strcmp( lpArgumentString, "version") == 0) {
            VersionHelp();
        } else if (strcmp( lpArgumentString, "leaks") == 0) {
            LeaksHelp();
        } else {
            dprintf("Invalid command.  No help available\n");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusdisk\test\disksp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    disksp.h

Abstract:

    Disks Resource DLL private definitions.

Author:

    Rod Gamache (rodga) 29-Mar-1996

Revision History:

--*/


#define MAX_PARTITIONS  128

//
// The following structure in inserted into a table (based on disk number).
// The letters are indexed by order of their partitions in the registry.
//

typedef struct _DISK_INFO {
    DWORD   PhysicalDrive;
    HANDLE  FileHandle;
    UCHAR   Letters[MAX_PARTITIONS];
} DISK_INFO, *PDISK_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusdisk\test\mountie.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mountie.c

Abstract:

    Abstract

Author:

    Rod Gamache (rodga) 4-Mar-1998

Environment:

    User Mode

Revision History:


--*/

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <devioctl.h>
//#include <ntdddisk.h>
//#include <ntddscsi.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <cfgmgr32.h>
#include <mountmgr.h>

#include "disksp.h"
#include "mountie.h"
#include <strsafe.h>    // Should be included last.

#define OUTPUT_BUFFER_LEN 1024


/*
 * DevfileOpen - open a device file given a pathname
 *
 * Return a non-zero code for error.
 */
DWORD
DevfileOpen(
    OUT HANDLE *Handle,
    IN wchar_t *pathname
    )
{
    HANDLE      fh;
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;
    NTSTATUS        status;
    IO_STATUS_BLOCK iostatus;

    RtlInitUnicodeString(&cwspath, pathname);
    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               NULL, NULL);
    fh = NULL;
    status = NtOpenFile(&fh,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &objattrs, &iostatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    if (status != STATUS_SUCCESS) {
        return status;
    }

    if (iostatus.Status != STATUS_SUCCESS) {
        if (fh) {
            NtClose(fh);
        }
        return iostatus.Status;
    }

    *Handle = fh;
    return STATUS_SUCCESS;

} // DevfileOpen


/*
 * DevfileClose - close a file
 */
VOID
DevfileClose(
    IN HANDLE Handle
    )
{

    NtClose(Handle);

} // DevFileClose


/*
 * DevfileIoctl - issue an ioctl to a device
 */
DWORD
DevfileIoctl(
    IN HANDLE Handle,
    IN DWORD Ioctl,
    IN PVOID InBuf,
    IN ULONG InBufSize,
    IN OUT PVOID OutBuf,
    IN DWORD OutBufSize,
    OUT LPDWORD returnLength
    )
{
    NTSTATUS        status;
    IO_STATUS_BLOCK ioStatus;

    status = NtDeviceIoControlFile(Handle,
                                   (HANDLE) NULL,
                                   (PIO_APC_ROUTINE) NULL,
                                   NULL,
                                   &ioStatus,
                                   Ioctl,
                                   InBuf, InBufSize,
                                   OutBuf, OutBufSize);
    if ( status == STATUS_PENDING ) {
        status = NtWaitForSingleObject( Handle, FALSE, NULL );
    }

    if ( NT_SUCCESS(status) ) {
        status = ioStatus.Status;
    }

    if ( ARGUMENT_PRESENT(returnLength) ) {
        *returnLength = (DWORD)ioStatus.Information;
    }

    return status;

} // DevfileIoctl



DWORD
DisksAssignDosDevice(
    PCHAR   MountName,
    PWCHAR  VolumeDevName
    )

/*++

Routine Description:

Inputs:
    MountName -
    VolumeDevName -

Return value:

    A Win32 error code.

--*/

{
    WCHAR mount_device[MAX_PATH];
    USHORT mount_point_len;
    USHORT dev_name_len;
    HANDLE   handle;
    DWORD   status;
    USHORT inputlength;
    PMOUNTMGR_CREATE_POINT_INPUT input;

    status = DevfileOpen(&handle, MOUNTMGR_DEVICE_NAME);
    if (status) {
        return status;
    }

    if ( FAILED( StringCchPrintfW( mount_device,
                                   RTL_NUMBER_OF(mount_device) - 1,
                                   L"\\DosDevices\\%S",
                                   MountName ) ) ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    mount_point_len = wcslen(mount_device) * sizeof(WCHAR);
    dev_name_len = wcslen(VolumeDevName) * sizeof(WCHAR);
    inputlength = sizeof(MOUNTMGR_CREATE_POINT_INPUT) +
                  mount_point_len + dev_name_len;

    input = (PMOUNTMGR_CREATE_POINT_INPUT)malloc(inputlength);
    if (!input) {
        DevfileClose(handle);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    input->SymbolicLinkNameLength = mount_point_len;
    input->DeviceNameOffset = input->SymbolicLinkNameOffset +
                              input->SymbolicLinkNameLength;
    input->DeviceNameLength = dev_name_len;
    RtlCopyMemory((PCHAR)input + input->SymbolicLinkNameOffset,
                  mount_device, mount_point_len);
    RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                  VolumeDevName, dev_name_len);
    status = DevfileIoctl(handle, IOCTL_MOUNTMGR_CREATE_POINT,
                          input, inputlength, NULL, 0, NULL);
    free(input);
    DevfileClose(handle);
    return status;

} // DisksAssignDosDevice



DWORD
DisksRemoveDosDevice(
    PCHAR   MountName
    )

/*++

Routine Description:

Inputs:
    MountName -

Return value:


--*/

{
    WCHAR mount_device[MAX_PATH];
    USHORT mount_point_len;
    USHORT dev_name_len;
    HANDLE handle;
    DWORD  status;
    USHORT inputlength;
    PMOUNTMGR_MOUNT_POINT input;

    UCHAR bogusBuffer[128];

    status = DevfileOpen(&handle, MOUNTMGR_DEVICE_NAME);
    if (status) {
        return status;
    }

    if ( FAILED( StringCchPrintfW( mount_device,
                                   RTL_NUMBER_OF(mount_device) - 1,
                                   L"\\DosDevices\\%S",
                                   MountName ) ) ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    mount_point_len = wcslen(mount_device) * sizeof(WCHAR);
    inputlength = sizeof(MOUNTMGR_MOUNT_POINT) + mount_point_len;

    input = (PMOUNTMGR_MOUNT_POINT)malloc(inputlength);
    if (!input) {
        DevfileClose(handle);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    input->UniqueIdOffset = 0;
    input->UniqueIdLength = 0;
    input->DeviceNameOffset = 0;
    input->DeviceNameLength = 0;
    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    input->SymbolicLinkNameLength = mount_point_len;
    RtlCopyMemory((PCHAR)input + input->SymbolicLinkNameOffset,
                  mount_device, mount_point_len);
    status = DevfileIoctl(handle, IOCTL_MOUNTMGR_DELETE_POINTS,
                          input, inputlength, bogusBuffer, 128, NULL);
    free(input);
    DevfileClose(handle);
    return status;

} // DisksRemoveDosDevice




DWORD
FindFirstVolumeForSignature(
    IN  HANDLE MountMgrHandle,
    IN  DWORD Signature,
    OUT LPSTR VolumeName,
    IN  DWORD BufferLength,
    OUT LPHANDLE Handle,
    OUT PVOID UniqueId OPTIONAL,
    IN OUT LPDWORD IdLength,
    OUT PUCHAR DriveLetter OPTIONAL
    )

/*++

Inputs:

    MountMgrHandle - a handle to the mount manager.

    Signature - the signature we are looking for.

    VolumeName - must be a valid buffer of at least MAX_PATH characters.

    BufferLength - the length of VolumeName.

    Handle - pointer to receive the FindFirstVolume/FindNextVolume enum handle.

    UniqueId - optional pointer to buffer to receive the UniqueId.

    IdLength - pointer to length of the UniqueId buffer. Must be valid if
               UniqueId is present.

    DriveLetter - returns the drive letter if present.

Return Value:

    Win32 error code

--*/

{
    HANDLE  handle;
    BOOL    success;
    DWORD   status;
    LPDWORD idSignature;
    DWORD   bufLength;
    LPWSTR  wVolumeName;
    DWORD   inputlength;
    DWORD   outputlength;
    DWORD   returnlength;
    UCHAR   outputBuffer[OUTPUT_BUFFER_LEN];
    PMOUNTMGR_MOUNT_POINT input;
    PMOUNTMGR_MOUNT_POINTS output;
    PUCHAR byteBuffer;
    DWORD mountPoints;

    if ( !ARGUMENT_PRESENT( VolumeName ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    handle = FindFirstVolume( VolumeName, BufferLength );

    if ( handle == INVALID_HANDLE_VALUE ) {
        return(ERROR_FILE_NOT_FOUND);
    }

    do {
        bufLength = strlen( VolumeName );
        VolumeName[bufLength-1] = '\0';
        if ( VolumeName[1] != '\\' ) {
            status = ERROR_INVALID_NAME;
            break;
        } else {
            VolumeName[1] = '?';
            wVolumeName = malloc( bufLength * sizeof(WCHAR) );
            if (!wVolumeName) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            mbstowcs( wVolumeName, VolumeName, bufLength );
            bufLength--;
            printf( "\nFound volume %ws\n", wVolumeName );
            inputlength = sizeof(MOUNTMGR_MOUNT_POINT) +
                          (bufLength*sizeof(WCHAR)) + (2*sizeof(WCHAR));

            input = (PMOUNTMGR_MOUNT_POINT)malloc(inputlength);
            if (!input) {
                free( wVolumeName );
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            input->SymbolicLinkNameOffset = 0;
            input->SymbolicLinkNameLength = 0;
            input->UniqueIdOffset = 0;
            input->UniqueIdLength = 0;
            input->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
            input->DeviceNameLength = (USHORT)(bufLength * sizeof(WCHAR));
            RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                          wVolumeName, bufLength * sizeof(WCHAR) );
            outputlength = OUTPUT_BUFFER_LEN;

            status = DevfileIoctl(MountMgrHandle, IOCTL_MOUNTMGR_QUERY_POINTS,
                         input, inputlength, outputBuffer, outputlength, &returnlength);

            if ( status != ERROR_SUCCESS ) {
                // Cast as the data is actually a wide string.
                printf( "Query points for %ws failed, error %u\n",
                         (PWCHAR)((PCHAR)input + input->DeviceNameOffset),
                         status );
                free( wVolumeName );
                free(input);
                wVolumeName = NULL;
                input = NULL;
                break;
            } else {
                output = (PMOUNTMGR_MOUNT_POINTS)outputBuffer;
                mountPoints = output->NumberOfMountPoints;
                if ( !mountPoints ) {
                    return ERROR_INVALID_DATA;
                }
                byteBuffer = outputBuffer + output->MountPoints[0].UniqueIdOffset;
                idSignature = (LPDWORD)byteBuffer;
                if ( !Signature ||
                     (Signature == *idSignature) ) {
                    NTSTATUS   ntStatus;
                    UNICODE_STRING unicodeString;
                    OEM_STRING  oemString;
                    DWORD  count;
                    UCHAR  driveLetter;
                    UCHAR  devName[ MAX_PATH ];
                    PWCHAR wideBuffer;
                    LPDWORD dwordBuffer;

                    free( wVolumeName );
                    free(input);
                    input = NULL;
                    wVolumeName = NULL;
                    *Handle = handle;
                    if ( ARGUMENT_PRESENT(UniqueId) ) {
                        if ( *IdLength > output->MountPoints[0].UniqueIdLength ) {
                            *IdLength = output->MountPoints[0].UniqueIdLength;
                        }
                        RtlCopyMemory( UniqueId, byteBuffer, *IdLength );
                    }

                    //
                    // Print the ID
                    //
                    count =  output->MountPoints[0].UniqueIdLength;
                    count = (count + 3) / 4;
                    dwordBuffer = (LPDWORD)(outputBuffer + output->MountPoints[0].UniqueIdOffset);
                    printf( "Id = " );
                    while ( count-- ) {
                        printf( "%08lx ", *(dwordBuffer++) );
                    }
                    printf( "\n" );

                    if ( ARGUMENT_PRESENT(DriveLetter) ) {
                        *DriveLetter = 0;
                        while ( mountPoints-- ) {
                            byteBuffer = outputBuffer +
                                output->MountPoints[mountPoints].SymbolicLinkNameOffset;
                            //
                            // Covert UNICODE name to OEM string upper case
                            //
                            unicodeString.Buffer = (PWCHAR)byteBuffer;
                            unicodeString.MaximumLength = output->MountPoints[mountPoints].SymbolicLinkNameLength + sizeof(WCHAR);
                            unicodeString.Length = output->MountPoints[mountPoints].SymbolicLinkNameLength;
                            oemString.Buffer = devName;
                            oemString.MaximumLength = sizeof(devName);
                            ntStatus = RtlUpcaseUnicodeStringToOemString(
                                            &oemString,
                                            &unicodeString,
                                            FALSE );
                            if ( ntStatus != STATUS_SUCCESS ) {
                                status = RtlNtStatusToDosError( ntStatus );
                                return status;
                            }
                            devName[oemString.Length] = '\0';
                            count = sscanf( devName, "\\DOSDEVICES\\%c:", &driveLetter );
                            wideBuffer = (PWCHAR)byteBuffer;
                            wideBuffer[(output->MountPoints[mountPoints].SymbolicLinkNameLength)/2] = L'\0';
                            if ( count ) {
                                *DriveLetter = driveLetter;
                                // Cast as the data is actually a wide string.
                                printf( "Symbolic name = %ws, letter = %c:\\\n",
                                         (PWCHAR)byteBuffer,
                                         driveLetter );
                                if ( Signature ) {
                                    break;
                                }
                            } else {
                                // Cast as the data is actually a wide string.
                                printf( "Symbolic name = %ws\n",
                                         (PWCHAR)byteBuffer );
                            }
                        }
                    }
                    if ( Signature ) {
                        return ERROR_SUCCESS;
                    }
                }
            }

            free(wVolumeName);
            free(input);
        }

        success = FindNextVolume( handle,
                                  VolumeName,
                                  BufferLength );
        if ( !success ) {
            status = GetLastError();
        }

    } while ( status == ERROR_SUCCESS );

    FindVolumeClose( handle );
    return status;

} // FindFirstVolumeForSignature



DWORD
FindNextVolumeForSignature(
    IN  HANDLE MountMgrHandle,
    IN  DWORD Signature,
    IN  HANDLE Handle,
    OUT LPSTR VolumeName,
    IN  DWORD BufferLength,
    OUT PVOID UniqueId OPTIONAL,
    IN OUT LPDWORD IdLength,
    OUT PUCHAR DriveLetter OPTIONAL
    )

/*++

Inputs:

    MountMgrHandle - a handle to the mount manager.

    Signature - the signature we are looking for.

    Handle - the FindFirstVolume/FindNextVolume enum handle.

    VolumeName - must be a valid buffer of at least MAX_PATH characters.

    BufferLength - the length of VolumeName.

    UniqueId - optional pointer to buffer to receive the UniqueId.

    IdLength - point to the length of the UniqueId buffer.

    DriveLetter - returns the drive letter if present.

Return Value:

    Win32 error code

--*/

{
    BOOL    success;
    DWORD   status;
    LPDWORD idSignature;
    DWORD bufLength;
    LPWSTR wVolumeName;
    DWORD inputlength;
    DWORD outputlength;
    DWORD returnlength;
    UCHAR outputBuffer[OUTPUT_BUFFER_LEN];
    PMOUNTMGR_MOUNT_POINT input;
    PMOUNTMGR_MOUNT_POINTS output;
    PUCHAR byteBuffer;
    DWORD mountPoints;


    if ( !ARGUMENT_PRESENT( VolumeName ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    do {
        success = FindNextVolume( Handle, VolumeName, BufferLength );

        if ( !success ) {
            status = GetLastError();
            break;
        }

        bufLength = strlen( VolumeName );

        VolumeName[bufLength-1] = '\0';
        if ( VolumeName[1] != '\\' ) {
            status = ERROR_INVALID_NAME;
            break;
        } else {
            VolumeName[1] = '?';
            bufLength--;
            wVolumeName = malloc( bufLength * sizeof(WCHAR) );
            if (!wVolumeName) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            mbstowcs( wVolumeName, VolumeName, bufLength );
            inputlength = sizeof(MOUNTMGR_MOUNT_POINT) +
                          (bufLength*sizeof(WCHAR)) + (2*sizeof(WCHAR));

            input = (PMOUNTMGR_MOUNT_POINT)malloc(inputlength);
            if (!input) {
                free( wVolumeName );
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            input->SymbolicLinkNameOffset = 0;
            input->SymbolicLinkNameLength = 0;
            input->UniqueIdOffset = 0;
            input->UniqueIdLength = 0;
            input->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
            input->DeviceNameLength = (USHORT)(bufLength * sizeof(WCHAR));
            RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                          wVolumeName, bufLength * sizeof(WCHAR) );
            outputlength = OUTPUT_BUFFER_LEN;

            status = DevfileIoctl(MountMgrHandle, IOCTL_MOUNTMGR_QUERY_POINTS,
                         input, inputlength, outputBuffer, outputlength, &returnlength);

            if ( status != ERROR_SUCCESS ) {
                free( wVolumeName );
                free(input);
                break;
            } else {
                output = (PMOUNTMGR_MOUNT_POINTS)outputBuffer;
                mountPoints = output->NumberOfMountPoints;
                if ( !mountPoints ) {
                    return ERROR_INVALID_DATA;
                }
                byteBuffer = outputBuffer + output->MountPoints[0].UniqueIdOffset;
                idSignature = (LPDWORD)byteBuffer;
                if ( Signature ==  *idSignature ) {
                    NTSTATUS   ntStatus;
                    UNICODE_STRING unicodeString;
                    OEM_STRING  oemString;
                    DWORD  count;
                    UCHAR  driveLetter;
                    UCHAR  devName[ MAX_PATH ];

                    free( wVolumeName );
                    free(input);
                    if ( ARGUMENT_PRESENT(UniqueId) ) {
                        if ( *IdLength > output->MountPoints[0].UniqueIdLength ) {
                            *IdLength = output->MountPoints[0].UniqueIdLength;
                        }
                        RtlCopyMemory( UniqueId, byteBuffer, *IdLength );
                    }

                    if ( ARGUMENT_PRESENT(DriveLetter) ) {
                        *DriveLetter = 0;
                        while ( mountPoints-- ) {
                            byteBuffer = outputBuffer +
                                output->MountPoints[mountPoints].SymbolicLinkNameOffset;
                            //
                            // Covert UNICODE name to OEM string upper case
                            //
                            unicodeString.Buffer = (PWCHAR)byteBuffer;
                            unicodeString.MaximumLength = output->MountPoints[mountPoints].SymbolicLinkNameLength + sizeof(WCHAR);
                            unicodeString.Length = output->MountPoints[mountPoints].SymbolicLinkNameLength;
                            oemString.Buffer = devName;
                            oemString.MaximumLength = sizeof(devName);
                            ntStatus = RtlUpcaseUnicodeStringToOemString(
                                            &oemString,
                                            &unicodeString,
                                            FALSE );
                            if ( ntStatus != STATUS_SUCCESS ) {
                                status = RtlNtStatusToDosError( ntStatus );
                                return status;
                            }
                            devName[oemString.Length] = '\0';
                            count = sscanf( devName, "\\DOSDEVICES\\%c:", &driveLetter );
                            if ( count ) {
                                *DriveLetter = driveLetter;
                                break;
                            }
                        }
                    }
                    return ERROR_SUCCESS;
                }
            }

            free(wVolumeName);
            free(input);
        }

        success = FindNextVolume( Handle,
                                  VolumeName,
                                  BufferLength );
        if ( !success ) {
            status = GetLastError();
        }

    } while ( status == ERROR_SUCCESS );

    return status;

} // FindNextVolumeForSignature


#if 0

DWORD
DisksSetDiskInfo(
    IN HKEY RegistryKey,
    IN DWORD Signature
    )

/*++

Inputs:

Return Value:

    A Win32 error code.

--*/

{
    DWORD   status;
    UCHAR   driveLetter;
    UCHAR   volumeName[MAX_PATH];
    HANDLE  handle;
    HANDLE  mHandle;
    UCHAR   uniqueId[MAX_PATH];
    UCHAR   smashedId[MAX_PATH+1];
    DWORD   idLength;
    DWORD   i;
    WCHAR   indexName[16];
    HKEY    registryKey;
    DWORD   disposition;

    status = DevfileOpen( &mHandle, MOUNTMGR_DEVICE_NAME );
    if ( status != ERROR_SUCCESS ) {
        printf( "SetDiskInfo: DevfileOpen failed, status = %u\n", status);
        return status;
    }

    status = ClusterRegDeleteKey( RegistryKey, L"MountMgr" );
    if ( (status != ERROR_SUCCESS) && (status != ERROR_FILE_NOT_FOUND) ) {
        DevfileClose( mHandle );
        printf( "DiskInfo: ClusterRegDeleteKey failed, status = %1!u!\n", status);
        return status;
    }

    status = ClusterRegCreateKey( RegistryKey,
                                  L"MountMgr",
                                  0,
                                  KEY_READ | KEY_WRITE,
                                  NULL,
                                  &registryKey,
                                  &disposition );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetDiskInfo: ClusterRegCreateKey failed, status = %1!u!\n", status);
        return status;
    }

    idLength = MAX_PATH;
    status = FindFirstVolumeForSignature( ResourceHandle,
                                          mHandle,
                                          Signature,
                                          volumeName,
                                          MAX_PATH,
                                          &handle,
                                          uniqueId,
                                          &idLength,
                                          &driveLetter );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        ClusterRegCloseKey( registryKey );
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetDiskInfo: FindFirstVolume failed, status = %1!u!\n", status);
        return status;
    }

    i = 0;
    while ( status == ERROR_SUCCESS ) {
        wsprintfW( indexName, L"%0.5u", i++ );

        smashedId[0] = driveLetter;
        RtlCopyMemory( &smashedId[1], uniqueId, idLength );
        status = ClusterRegSetValue( registryKey,
                                     indexName,
                                     REG_BINARY,
                                     (CONST BYTE *)smashedId,
                                     idLength + 1);
        if ( status != ERROR_SUCCESS ) {
            //printf("DiskSetDiskInfo, error setting value %s\n", indexName );
        }

        idLength = MAX_PATH;
        status = FindNextVolumeForSignature( mHandle,
                                             Signature,
                                             handle,
                                             volumeName,
                                             MAX_PATH,
                                             uniqueId,
                                             &idLength,
                                             &driveLetter );
    }

    FindVolumeClose( handle );
    DevfileClose( mHandle );
    ClusterRegCloseKey( registryKey );

    return ERROR_SUCCESS;

} // DisksSetDiskInfo



DWORD
DisksSetMountMgr(
    IN HKEY RegistryKey,
    IN DWORD Signature
    )

/*++

Inputs:

Return Value:

    A Win32 error code.

--*/

{
    DWORD   status;
    UCHAR   volumeName[MAX_PATH];
    LPWSTR  wVolumeName;
    HANDLE  mHandle;
    HANDLE  handle = NULL;
    UCHAR   storedId[MAX_PATH+1];
    DWORD   storedIdSize;
    DWORD   i;
    WCHAR   indexName[16];
    HKEY    registryKey;
    DWORD   type;
    DWORD   bufLength;
    UCHAR   driveLetter[4];
    NTSTATUS ntStatus;

    status = DevfileOpen( &mHandle, MOUNTMGR_DEVICE_NAME );
    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: DevfileOpen failed, status = %1!u!\n", status);
        return status;
    }

    status = ClusterRegOpenKey( RegistryKey,
                                L"MountMgr",
                                KEY_READ | KEY_WRITE,
                                &registryKey );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        return status;
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: ClusterRegOpenKey failed, status = %1!u!\n", status);
    }

    i = 0;
    do {
        wsprintfW( indexName, L"%0.5u", i++ );
        storedIdSize = MAX_PATH;
        status = ClusterRegQueryValue( registryKey,
                                       indexName,
                                       &type,
                                       (PUCHAR)storedId,
                                       &storedIdSize);

        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: ClusterRegQueryValue returned status = %1!u!\n", status);
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        storedId[1] = ':';
        storedId[2] = '\0';
        ntStatus = DisksRemoveDosDevice( storedId );
        status = RtlNtStatusToDosError( ntStatus );
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: RemoveDosDevice for %1!x! returned status = %2!u!\n", *storedId, status);
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }

    } while ( status == ERROR_SUCCESS );

    status = FindFirstVolumeForSignature( ResourceHandle,
                                          mHandle,
                                          Signature,
                                          volumeName,
                                          MAX_PATH,
                                          &handle,
                                          NULL,
                                          NULL,
                                          &driveLetter[0] );

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: FindFirstVolume failed for Signature %1!08lx!, status = %2!u!\n", Signature, status);
    }

    i = 0;
    while ( status == ERROR_SUCCESS ) {
        wsprintfW( indexName, L"%0.5u", i++ );
        storedIdSize = MAX_PATH;
        status = ClusterRegQueryValue( registryKey,
                                       indexName,
                                       &type,
                                       (PUCHAR)storedId,
                                       &storedIdSize );
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Remove current drive letter
        //
        driveLetter[1] = ':';
        driveLetter[2] = '\0';
        ntStatus = DisksRemoveDosDevice( driveLetter );
        status = RtlNtStatusToDosError( ntStatus );
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: RemoveDosDevice for %1!x! returned status = %2!u!\n", driveLetter[0], status);

        bufLength = strlen( volumeName );
        wVolumeName = malloc( (bufLength + 1) * sizeof(WCHAR) );
        if (!wVolumeName) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        mbstowcs( wVolumeName, volumeName, bufLength + 1 );

        storedId[1] = ':';
        storedId[2] = '\0';
        status = DisksAssignDosDevice( storedId, wVolumeName );
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: AssignDosDevice for %1!x! (%2!ws!) returned status = %3!u!\n", *storedId, wVolumeName, status);
        free( wVolumeName );
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        status = FindNextVolumeForSignature( mHandle,
                                             Signature,
                                             handle,
                                             volumeName,
                                             MAX_PATH,
                                             NULL,
                                             NULL,
                                             &driveLetter[0] );

        if ( status != ERROR_SUCCESS ) {
            (DiskpLogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"SetMountMgr: FindNextVolume failed, status = %1!u!\n", status);
        }
        if ( status == ERROR_NO_MORE_FILES ) {
            status = ERROR_SUCCESS;
            break;
        }

    }

    DevfileClose( mHandle );
    ClusterRegCloseKey( registryKey );
    if ( handle ) {
        FindVolumeClose( handle );
    }

    return status;

} // DisksSetMountMgr



BOOL
DisksDoesDiskInfoMatch(
    IN HKEY RegistryKey,
    IN DWORD Signature
    )

/*++

Inputs:

Return Value:

    A Win32 error code.

--*/

{
    DWORD   status;
    UCHAR   driveLetter;
    UCHAR   volumeName[MAX_PATH];
    HANDLE  handle;
    HANDLE  mHandle;
    UCHAR   uniqueId[MAX_PATH];
    UCHAR   smashedId[MAX_PATH+1];
    UCHAR   storedId[MAX_PATH+1];
    DWORD   idLength;
    DWORD   storedIdSize;
    DWORD   i;
    WCHAR   indexName[16];
    HKEY    registryKey;
    DWORD   type;


    status = DevfileOpen( &mHandle, MOUNTMGR_DEVICE_NAME );
    if ( status != ERROR_SUCCESS ) {
        return FALSE;
    }

    status = ClusterRegOpenKey( RegistryKey,
                                L"MountMgr",
                                KEY_READ | KEY_WRITE,
                                &registryKey );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        return FALSE;
    }

    idLength = MAX_PATH;
    status = FindFirstVolumeForSignature( ResourceHandle,
                                          mHandle,
                                          Signature,
                                          volumeName,
                                          MAX_PATH,
                                          &handle,
                                          uniqueId,
                                          &idLength,
                                          &driveLetter );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        ClusterRegCloseKey( registryKey );
        return FALSE;
    }

    i = 0;
    while ( status == ERROR_SUCCESS ) {
        wsprintfW( indexName, L"%0.5u", i++ );

        smashedId[0] = driveLetter;
        RtlCopyMemory( &smashedId[1], uniqueId, idLength );
        storedIdSize = MAX_PATH;
        status = ClusterRegQueryValue( registryKey,
                                       indexName,
                                       &type,
                                       (PUCHAR)storedId,
                                       &storedIdSize);

        if ( (status != ERROR_SUCCESS) ||
             (type != REG_BINARY) ||
             (storedIdSize != (idLength+1)) ||
             (RtlCompareMemory( smashedId, storedId, idLength ) != idLength) ) {
            FindVolumeClose( handle );
            DevfileClose( mHandle );
            ClusterRegCloseKey( registryKey );
            return FALSE;
        }

        idLength = MAX_PATH;
        status = FindNextVolumeForSignature( mHandle,
                                             Signature,
                                             handle,
                                             volumeName,
                                             MAX_PATH,
                                             uniqueId,
                                             &idLength,
                                             &driveLetter );
    }

    FindVolumeClose( handle );
    DevfileClose( mHandle );
    ClusterRegCloseKey( registryKey );

    if ( status != ERROR_NO_MORE_FILES ) {
        return FALSE;
    }

    return TRUE;

} // DisksDoesDiskInfoMatch



BOOL
DisksIsDiskInfoValid(
    IN HKEY RegistryKey,
    IN DWORD Signature
    )

/*++

Inputs:

Return Value:

    A Win32 error code.

--*/

{
    DWORD   status;
    UCHAR   volumeName[MAX_PATH];
    UCHAR   storedId[MAX_PATH+1];
    DWORD   storedIdSize;
    WCHAR   indexName[16];
    HKEY    registryKey;
    DWORD   i;
    DWORD   type;
    HANDLE  handle;
    HANDLE  mHandle;


    status = DevfileOpen( &mHandle, MOUNTMGR_DEVICE_NAME );
    if ( status != ERROR_SUCCESS ) {
        return FALSE;
    }

    status = ClusterRegOpenKey( RegistryKey,
                                L"MountMgr",
                                KEY_READ | KEY_WRITE,
                                &registryKey );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        return FALSE;
    }

    status = FindFirstVolumeForSignature( ResourceHandle,
                                          mHandle,
                                          Signature,
                                          volumeName,
                                          MAX_PATH,
                                          &handle,
                                          NULL,
                                          NULL,
                                          NULL );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        ClusterRegCloseKey( registryKey );
        return TRUE;
    }

    i = 0;
    while ( status == ERROR_SUCCESS ) {
        wsprintfW( indexName, L"%0.5u", i++ );

        storedIdSize = MAX_PATH;
        status = ClusterRegQueryValue( registryKey,
                                       indexName,
                                       &type,
                                       (PUCHAR)storedId,
                                       &storedIdSize);
        if ( (status != ERROR_SUCCESS) ||
             (type != REG_BINARY) ) {
            FindVolumeClose( handle );
            DevfileClose( mHandle );
            ClusterRegCloseKey( registryKey );
            if ( status == ERROR_FILE_NOT_FOUND ) {
                return TRUE;
            } else {
                return FALSE;
            }
        }

        status = FindNextVolumeForSignature( mHandle,
                                             Signature,
                                             handle,
                                             volumeName,
                                             MAX_PATH,
                                             NULL,
                                             NULL,
                                             NULL );
    }

    FindVolumeClose( handle );
    DevfileClose( mHandle );
    ClusterRegCloseKey( registryKey );

    return TRUE;

} // DisksIsDiskInfoValid

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusdisk\test\disktest.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    disktest.c

Abstract:

    Abstract

Author:

    Rod Gamache (rodga) 4-Mar-1996

Environment:

    User Mode

Revision History:


--*/

#define INITGUID 1

//#include <windows.h>
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <clusapi.h>
#include <ntddvol.h>

#include <mountie.h>
#include <mountmgr.h>
#include <partmgrp.h>

#include <devioctl.h>
#include <ntdddisk.h>
#include <ntddscsi.h>

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

//#include <initguid.h>
#include <devguid.h>

#include <setupapi.h>
#include <cfgmgr32.h>

#include "clusdisk.h"
#include "disksp.h"
#include "diskarbp.h"
#include <clstrcmp.h>

#define _NTSRB_     // to keep srb.h from being included
#include <scsi.h>


#include <strsafe.h>    // Should be included last.

#ifndef ClusterHashGuid
#define ClusterHashGuid(Guid) (((PULONG) &Guid)[0] ^ ((PULONG) &Guid)[1] ^ ((PULONG) &Guid)[2] ^ ((PULONG) &Guid)[3])
#endif

#define DEVICE_CLUSDISK0    TEXT("\\Device\\ClusDisk0")
#define CLUSDISK_SRB_SIGNATURE "CLUSDISK"


//
// Routine to get drive layout table
//
BOOL
ClRtlGetDriveLayoutTable(
    IN  HANDLE hDisk,
    OUT PDRIVE_LAYOUT_INFORMATION * DriveLayout,
    OUT PDWORD InfoSize OPTIONAL
    );


NTSTATUS
GetAssignedLetter (
    PWCHAR deviceName,
    PCHAR driveLetter
    );

PVOID
DoIoctlAndAllocate(
    IN HANDLE FileHandle,
    IN DWORD  IoControlCode,
    IN PVOID  InBuf,
    IN ULONG  InBufSize,
    OUT PDWORD BytesReturned
    );

PSTR PartitionName = "\\Device\\Harddisk%d\\Partition%d";


int __cdecl
main(
     int argc,
     char *argv[]
     );

static DWORD
Reset(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
BreakReservation(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

static DWORD
Reserve(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

static DWORD
Release(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

static DWORD
Online(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

static DWORD
Offline(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
CheckUnclaimedPartitions(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
EjectVolumes(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
PokeMountMgr (
    VOID
    );

DWORD
EnumMounts(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
EnumExtents(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
EnumNodes(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
EnumDisks(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
GetDiskGeometry(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
GetScsiAddress(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
GetDriveLayout(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

DWORD
GetDriveLayoutEx(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

LPTSTR
BooleanToString(
    BOOLEAN Value
    );

void
FormatGuid(
    GUID*   Guid,
    char*   Str,
    int     StrCharMax
    );

DWORD
GetVolumeInfo(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

DWORD
SetDriveLayout(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

DWORD
Attach(
        HANDLE fileHandle,
        int argc,
        char *argv[]
        );

DWORD
Detach(
        HANDLE fileHandle,
        int argc,
        char *argv[]
        );

static DWORD
GetPartitionInfo(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

DWORD
ReadSector(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
ReadSectorViaIoctl(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

#if 0

DWORD
FixDisk(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

static DWORD
FixDriveLayout(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );
#endif

static DWORD
StartReserve(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

static DWORD
StopReserve(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

static DWORD
Active(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

DWORD
Capable(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

BOOL
IsClusDiskLoaded(
    );

BOOL
IsClusterCapable(
    HANDLE Scsi
    );

static DWORD
Test(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

static DWORD
GetDriveLetter(
         PUCHAR deviceNameString
         );

NTSTATUS
GetVolumeInformationFromHandle(
   HANDLE Handle
   );


VOID
PrintError(
    IN DWORD ErrorCode
    );

DWORD
GetSerialNumber(
    HANDLE FileHandle
    );

PCHAR
DiskStateToString(
    UCHAR DiskState
    );

DWORD
UpdateDiskProperties(
    HANDLE fileHandle
    );

DWORD
SetState(
    HANDLE FileHandle,
    UCHAR NewState
    );

static DWORD
GetState(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

static void
usage(
      char *programName
      );

BOOL
IsDeviceClustered(
    HANDLE Device
    );

DWORD
GetReserveInfo(
    HANDLE FileHandle
    );

int
ExecuteCommand(
    IN PSTR    Command,
    IN int     argc,
    IN char *argv[]
    );

//
// Global data
//

PSTR    DeviceName;
PSTR    ProgramName;


int __cdecl
main(
     int argc,
     char *argv[]
     )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
#define MAX_DEVICES 99

    DWORD   logicalDrives;
    DWORD   letter;
    DWORD   index;
    PSTR    command;
    UCHAR   buffer[128];
    DWORD   status;
    HANDLE  handle;

    if (argc < 3)
    {
        usage( argv[0] );
        return -1;
    }
    argc--;
    ProgramName = *argv++;  // skip program name
    argc--;
    DeviceName = *argv++;
    argc--;
    command = *argv++;

    if ( ( CompareString( LOCALE_INVARIANT,
                          NORM_IGNORECASE,
                          DeviceName,
                          -1,
                          "*",
                          -1 ) == CSTR_EQUAL ) ||
         ( CompareString( LOCALE_INVARIANT,
                          NORM_IGNORECASE,
                          DeviceName,
                          -1,
                          "l*",
                          -1 ) == CSTR_EQUAL ) ) {

        // this is a wildcard request for logical drives.
        logicalDrives = GetLogicalDrives();

        for ( index = 0; index < 27; index++ ) {
            letter = 'A' + index;
            if ( (logicalDrives & 1) ) {

                (VOID) StringCchPrintf( buffer, RTL_NUMBER_OF(buffer), "%c:", letter );
                printf( "\n ** For device ** %s\n", buffer );
                DeviceName =  buffer;
                status = ExecuteCommand(
                    command,
                    argc,
                    argv );

                // Stop only for invalid option...
                if ( -1 == status ) {
                    break;
                }
            }
            logicalDrives = logicalDrives >> 1;
        } // for
    } else if ( CompareString( LOCALE_INVARIANT,
                               NORM_IGNORECASE,
                               DeviceName,
                               -1,
                               "p*",
                               -1 ) == CSTR_EQUAL ) {

        for ( index = 0; index < MAX_DEVICES; index++ ) {
            DWORD accessMode = GENERIC_READ;
            DWORD shareMode = FILE_SHARE_READ;

            (VOID) StringCchPrintf( buffer, RTL_NUMBER_OF(buffer), "\\\\.\\PhysicalDrive%u", index );
            handle = CreateFile(
                    buffer,
                    shareMode,
                    shareMode,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL );
            status = ERROR_INVALID_HANDLE;
            if ( handle != INVALID_HANDLE_VALUE ) {
                CloseHandle( handle );
                status = ERROR_SUCCESS;
                printf( "\n ** For device ** %s\n", buffer );
                DeviceName =  (PSTR)buffer;
                status = ExecuteCommand(
                    command,
                    argc,
                    argv );

                // Stop only for invalid option...
                if ( -1 == status ) {
                    break;
                }
            }
        }
    } else {
        status = ExecuteCommand(
            command,
            argc,
            argv );
    }

    return(status);
}

int
ExecuteCommand(
    IN PSTR Command,
    IN int     argc,
    IN char *argv[]
    )

{
    PSTR device;
    HANDLE fileHandle;
    DWORD accessMode, shareMode;
    DWORD errorCode;
    BOOL  failed = FALSE;
    UCHAR deviceNameString[128];
    DWORD logicalDrives;
    DWORD letter;
    DWORD index;

    NTSTATUS       ntStatus;
    ANSI_STRING    objName;
    UNICODE_STRING unicodeName;
    OBJECT_ATTRIBUTES objAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // Note it is important to access the device with 0 access mode so that
    // the file open code won't do extra I/O to the device
    //
    shareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    accessMode = GENERIC_READ | GENERIC_WRITE;

    if ( FAILED( StringCchCopy( deviceNameString,
                                RTL_NUMBER_OF(deviceNameString),
                                "\\\\.\\" ) ) ) {
        return -1;
    }

    if ( FAILED( StringCchCat( deviceNameString,
                               RTL_NUMBER_OF(deviceNameString),
                               DeviceName ) ) ) {
        return -1;
    }

    fileHandle = CreateFile(deviceNameString,
       accessMode,
       shareMode,
       NULL,
       OPEN_EXISTING,
       0,
       NULL);

    if ( fileHandle == INVALID_HANDLE_VALUE ) {
        errorCode = GetLastError();
        if ( (errorCode == ERROR_PATH_NOT_FOUND) ||
             (errorCode == ERROR_FILE_NOT_FOUND) ) {

            if ( FAILED( StringCchCopy( deviceNameString,
                                        RTL_NUMBER_OF(deviceNameString),
                                        "\\Device\\" ) ) ) {
                return -1;
            }

            if ( FAILED( StringCchCat( deviceNameString,
                                       RTL_NUMBER_OF(deviceNameString),
                                       DeviceName ) ) ) {
                return -1;
            }

            RtlInitString(&objName, deviceNameString);
            ntStatus = RtlAnsiStringToUnicodeString( &unicodeName,
                                                     &objName,
                                                     TRUE );
            if ( !NT_SUCCESS(ntStatus) ) {
                printf("Error converting device name %s to unicode. Error: %lx \n",
                      deviceNameString, ntStatus);
                return -1;
            }
            InitializeObjectAttributes( &objAttributes,
                                        &unicodeName,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL );
            ntStatus = NtCreateFile( &fileHandle,
                                     SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                     &objAttributes,
                                     &ioStatusBlock,
                                     NULL,
                                     FILE_ATTRIBUTE_NORMAL,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                     FILE_OPEN,
                                     0,
                                     NULL,
                                     0 );
            if ( !NT_SUCCESS(ntStatus) ) {
                failed = TRUE;
            }
            RtlFreeUnicodeString( &unicodeName );
        } else {
           printf("Error opening %s. Error: %d \n",
              deviceNameString, errorCode = GetLastError());
           PrintError(errorCode);
           return -1;
        }
    }

    if ( failed ) {

        if ( FAILED( StringCchCopy( deviceNameString,
                                    RTL_NUMBER_OF(deviceNameString),
                                    "\\Device\\" ) ) ) {
            return -1;
        }

        if ( FAILED( StringCchCat( deviceNameString,
                                   RTL_NUMBER_OF(deviceNameString),
                                   DeviceName ) ) ) {
            return -1;
        }

        RtlInitString(&objName, deviceNameString);
        ntStatus = RtlAnsiStringToUnicodeString( &unicodeName,
                                                 &objName,
                                                 TRUE );
        if ( !NT_SUCCESS(ntStatus) ) {
            printf("Error converting device name %s to unicode. Error: %lx \n",
                  deviceNameString, ntStatus);
            return -1;
        }
        InitializeObjectAttributes( &objAttributes,
                                    &unicodeName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );
        ntStatus = NtCreateFile( &fileHandle,
                                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                 &objAttributes,
                                 &ioStatusBlock,
                                 NULL,
                                 FILE_ATTRIBUTE_NORMAL,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 FILE_OPEN,
                                 0,
                                 NULL,
                                 0 );
        if ( !NT_SUCCESS(ntStatus) ) {
            printf("Error opening device %ws. Error: %lx \n",
                   unicodeName.Buffer, ntStatus );
            return -1;
        }
        RtlFreeUnicodeString( &unicodeName );
    }
    //printf("Accessing %s ... \n", deviceNameString);

    if (!_stricmp( Command, "Reset" ))
        errorCode = Reset( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Reserve" ))
        errorCode = Reserve( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Release" ))
        errorCode = Release( fileHandle, argc, argv );
    else if (!_stricmp( Command, "BreakReserve" ))
        errorCode = BreakReservation( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Online" ))
        errorCode = Online( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Offline" ))
        errorCode = Offline( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetState" ))
        errorCode = GetState( fileHandle, argc, argv );
    else if (!_stricmp( Command, "CheckUnclaimedPartitions" ))
        errorCode = CheckUnclaimedPartitions( fileHandle, argc, argv );
    else if (!_stricmp( Command, "EjectVolumes" ))
        errorCode = EjectVolumes( fileHandle, argc, argv );
    else if (!_stricmp( Command, "PokeMountMgr" ))
        errorCode = PokeMountMgr();
    else if (!_stricmp( Command, "EnumMounts" ))
        errorCode = EnumMounts( fileHandle, argc, argv );
    else if (!_stricmp( Command, "EnumExtents" ))
        errorCode = EnumExtents( fileHandle, argc, argv );
    else if (!_stricmp( Command, "EnumNodes" ))
        errorCode = EnumNodes( fileHandle, argc, argv );
    else if (!_stricmp( Command, "EnumDisks" ))
        errorCode = EnumDisks( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetDiskGeometry" ))
        errorCode = GetDiskGeometry( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetScsiAddress" ))
        errorCode = GetScsiAddress( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetDriveLayout" ))
        errorCode = GetDriveLayout( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetDriveLayoutEx" ))
        errorCode = GetDriveLayoutEx( fileHandle, argc, argv );
    else if (!_stricmp( Command, "SetDriveLayout" ))
        errorCode = SetDriveLayout( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetPartitionInfo" ))
        errorCode = GetPartitionInfo( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetVolumeInfo" ))
        errorCode = GetVolumeInfo( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetDriveLetter"))
        errorCode = GetDriveLetter( deviceNameString );
    else if (!_stricmp( Command, "GetSerialNumber"))
        errorCode = GetSerialNumber( fileHandle );
    else if (!_stricmp( Command, "GetReserveInfo"))
        errorCode = GetReserveInfo( fileHandle );
    else if (!_stricmp( Command, "ReadSector" ))
        errorCode = ReadSector( fileHandle, argc, argv );
    else if (!_stricmp( Command, "ReadSectorIoctl" ))
        errorCode = ReadSectorViaIoctl( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Test" ))
        errorCode = Test( fileHandle, argc, argv );
    else if (!_stricmp( Command, "UpdateDiskProperties"))
        errorCode = UpdateDiskProperties( fileHandle );
    else if (!_stricmp( Command, "IsClustered" ))
        errorCode = IsDeviceClustered( fileHandle );
    else if (!_stricmp( Command, "Capable"))
        errorCode = Capable( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Attach" ))
        errorCode = Attach( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Detach" ))
        errorCode = Detach( fileHandle, argc, argv );

#if 0
    else if (!_stricmp( Command, "FixDisk" ))
        errorCode = FixDisk( fileHandle, argc, argv );
    else if (!_stricmp( Command, "FixDriveLayout" ))
        errorCode = FixDriveLayout( fileHandle, argc, argv );
#endif

    else if (!_stricmp( Command, "StartReserve" ))
        errorCode = StartReserve( fileHandle, argc, argv );
    else if (!_stricmp( Command, "StopReserve" ))
        errorCode = StopReserve( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Active"))
        errorCode = Active( fileHandle, argc, argv );
    else
    {
        printf( "Invalid command.\n" );
        CloseHandle( fileHandle );
        usage( ProgramName );
        return(-1);
    }

    CloseHandle( fileHandle );

    if (errorCode != ERROR_SUCCESS) {
        printf( "Error performing %s:, error %u.\n", Command, errorCode );
        PrintError(errorCode);
        printf( "%s: failed.\n", ProgramName );
    }

    return errorCode;
}


static DWORD
Reset(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE  hScsi = INVALID_HANDLE_VALUE;
    DWORD   dwError = NO_ERROR;
    DWORD   bytesReturned;
    SCSI_ADDRESS                scsiAddress;
    STORAGE_BUS_RESET_REQUEST   storageReset;
    BOOL    success;

    UCHAR   hbaName[64];

    if (argc != 0)
    {
        printf( "usage: <device> Reset\n" );
        dwError = ERROR_INVALID_NAME;
        goto FnExit;
    }

    success = DeviceIoControl(fileHandle,
                              IOCTL_SCSI_GET_ADDRESS,
                              NULL,
                              0,
                              &scsiAddress,
                              sizeof(SCSI_ADDRESS),
                              &bytesReturned,
                              FALSE );
    if ( !success ||
          bytesReturned < sizeof(DWORD) ) {
        dwError = GetLastError();
        printf( "Error reading SCSI address, error = %u \n", dwError );
        PrintError( dwError );
        goto FnExit;
    }

    storageReset.PathId = scsiAddress.PathId;
    success = DeviceIoControl( fileHandle,
                               IOCTL_STORAGE_RESET_BUS,
                               &storageReset,
                               sizeof(STORAGE_BUS_RESET_REQUEST),
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );

    if ( !success ) {

        dwError = GetLastError();
        printf( "Error performing bus reset, error was %u \n", dwError );
        PrintError( dwError );

        printf( "Try sending reset IOCTL to HBA \n");

        (VOID) StringCchPrintf( hbaName,
                                RTL_NUMBER_OF(hbaName),
                                "\\\\.\\Scsi%d:",
                                scsiAddress.PortNumber );

        hScsi = CreateFile( hbaName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL );

        if ( INVALID_HANDLE_VALUE == hScsi ) {
            dwError = GetLastError();
            printf( "Error opening %s, error = %u \n", hbaName, dwError );
            PrintError( dwError );
            goto FnExit;
        }

        success = DeviceIoControl( hScsi,
                                   IOCTL_STORAGE_RESET_BUS,
                                   &storageReset,
                                   sizeof(STORAGE_BUS_RESET_REQUEST),
                                   NULL,
                                   0,
                                   &bytesReturned,
                                   FALSE );

        if ( !success ) {

            dwError = GetLastError();
            printf( "Error sending bus reset IOCTL, error was %u \n", dwError );
            PrintError( dwError );
            goto FnExit;
        }

        printf( "Bus reset successful \n" );
        dwError = NO_ERROR;

        // Fall through...
    }

FnExit:

    if ( INVALID_HANDLE_VALUE != hScsi ) {
        CloseHandle( hScsi );
    }

    return dwError;

}   // Reset


DWORD
BreakReservation(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE  hScsi = INVALID_HANDLE_VALUE;
    DWORD   dwError = NO_ERROR;
    DWORD   bytesReturned;
    SCSI_ADDRESS                scsiAddress;
    BOOL    success;

    UCHAR   hbaName[64];

    if (argc != 0)
    {
        printf( "usage: <device> BreakReserve \n" );
        dwError = ERROR_INVALID_NAME;
        goto FnExit;
    }

    success = DeviceIoControl(fileHandle,
                              IOCTL_SCSI_GET_ADDRESS,
                              NULL,
                              0,
                              &scsiAddress,
                              sizeof(SCSI_ADDRESS),
                              &bytesReturned,
                              FALSE );
    if ( !success ||
          bytesReturned < sizeof(DWORD) ) {
        dwError = GetLastError();
        printf( "Error reading SCSI address, error = %u \n", dwError );
        PrintError( dwError );
        goto FnExit;
    }

    (VOID) StringCchPrintf( hbaName,
                            RTL_NUMBER_OF(hbaName),
                            "\\\\.\\Scsi%d:",
                            scsiAddress.PortNumber );

    hScsi = CreateFile( hbaName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if ( INVALID_HANDLE_VALUE == hScsi ) {
        dwError = GetLastError();
        printf( "Error opening %s, error = %u \n", hbaName, dwError );
        PrintError( dwError );
        goto FnExit;
    }

    success = DeviceIoControl( hScsi,
                               IOCTL_STORAGE_BREAK_RESERVATION,
                               &scsiAddress,
                               sizeof(SCSI_ADDRESS),
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );

    if ( !success ) {

        dwError = GetLastError();
        printf( "Error sending break reservation IOCTL, error was %u \n", dwError );
        PrintError( dwError );
        goto FnExit;
    }

    printf( "Break reservation successful \n" );
    dwError = NO_ERROR;

    // Fall through...

FnExit:

    if ( INVALID_HANDLE_VALUE != hScsi ) {
        CloseHandle( hScsi );
    }

    return dwError;

}   // BreakReservation


static DWORD
Test(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;

    if (argc != 0)
    {
        printf( "usage: <device> Test\n" );
        return ERROR_INVALID_NAME;
    }

    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_CLUSTER_TEST,
                             NULL,
                             0,
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing test; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;
}



DWORD
Capable(
    HANDLE Device,
    int argc,
    char *argv[]
    )
/*++

Routine Description:

    Determine if the disk is cluster capable.

    Disks that are controlled by a miniport that supports
    IOCTL_SCSI_MINIPORT_NOT_QUORUM_CAPABLE are NOT cluster
    capable.

Arguments:

    Device - physical disk, logical volume, or scsi adapter.

Return Value:

    Win32 error value

--*/
{
    DWORD           dwError = ERROR_SUCCESS;
    DWORD           bytesReturned;

    HANDLE          scsiAdapter = INVALID_HANDLE_VALUE;

    SCSI_ADDRESS    scsiAddress;

    CHAR            scsiName[MAX_PATH];

    if ( argc != 0 ) {
        printf( "usage: <device> Capable \n" );
        dwError = ERROR_INVALID_NAME;
        goto FnExit;
    }

    //
    // Open the scsi device hosting this device.
    //

    if ( !DeviceIoControl( Device,
                           IOCTL_SCSI_GET_ADDRESS,
                           NULL,
                           0,
                           &scsiAddress,
                           sizeof(SCSI_ADDRESS),
                           &bytesReturned,
                           FALSE ) ) {

        dwError = GetLastError();
        printf("Capable: IOCTL_SCSI_GET_ADDRESS failed, error %d \n", dwError );
        PrintError( dwError );
        goto FnExit;
    }

    (VOID) StringCchPrintf( scsiName,
                             RTL_NUMBER_OF(scsiName),
                             "\\\\.\\Scsi%d:",
                             scsiAddress.PortNumber );

    scsiAdapter = CreateFile( scsiName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL );

    if ( INVALID_HANDLE_VALUE == scsiAdapter ) {
        dwError = GetLastError();
        printf("Capable: Error opening device %s, error %d \n", scsiName, dwError );
        PrintError( dwError );
        goto FnExit;
    }

    //
    // If clusdisk is loaded and the device is clustered, send the clusdisk
    // IOCTL to the device.
    //
    // Make sure the target is controlled by clusdisk.
    // If not, then fail.  If the IOCTL is sent to non-clustered
    // device, the IOCTL will fail and give invalid capable value.
    //

    if ( IsClusDiskLoaded() && IsDeviceClustered( Device ) ) {

        //
        // Try using the clusdisk IOCTL.
        //

        if ( !DeviceIoControl( Device,
                               IOCTL_DISK_CLUSTER_NOT_CLUSTER_CAPABLE,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE ) ) {

            printf("ClusDisk IOCTL: Disks are cluster capable (failed with error %d) \n\n", GetLastError() );

        } else {
            printf("ClusDisk IOCTL: Disks are NOT cluster capable \n\n");
        }
    }

    //
    // Now try sending the request via IOCTL_SCSI_MINIPORT to the scsi adapter.
    //

    if ( IsClusterCapable( scsiAdapter ) ) {
        printf("IOCTL_SCSI_MINIPORT: Disks are cluster capable \n\n");
    } else {
        printf("IOCTL_SCSI_MINIPORT: Disks are NOT cluster capable \n\n");
    }

FnExit:

    if ( INVALID_HANDLE_VALUE != scsiAdapter ) {
        CloseHandle( scsiAdapter );
    }

    return dwError;

}   // Capable


BOOL
IsClusDiskLoaded(
    )
/*++

Routine Description:

    Determine whether clusdisk driver is loaded.

Arguments:

    None

Return Value:

    TRUE - clusdisk driver loaded.
    FALSE - clusdisk driver not loaded or cannot determine driver status.

--*/
{
    NTSTATUS    ntStatus;

    HANDLE      hClusDisk0;

    DWORD       dwError;

    UNICODE_STRING  unicodeName;
    ANSI_STRING     objName;

    OBJECT_ATTRIBUTES       objAttributes;
    IO_STATUS_BLOCK         ioStatusBlock;

    BOOL                    loaded = FALSE;     // Assume clusdisk is not loaded

    RtlInitString( &objName, DEVICE_CLUSDISK0 );

    ntStatus = RtlAnsiStringToUnicodeString( &unicodeName,
                                             &objName,
                                             TRUE );

    if ( !NT_SUCCESS(ntStatus) ) {

        dwError = RtlNtStatusToDosError( ntStatus );
        printf( "Error converting string to unicode; error was %d \n", dwError);
        PrintError( dwError );
        goto FnExit;
    }

    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtCreateFile( &hClusDisk0,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );

    RtlFreeUnicodeString( &unicodeName );

    if ( !NT_SUCCESS(ntStatus) ) {

        dwError = RtlNtStatusToDosError(ntStatus);
        printf( "Error opening ClusDisk0 device; error was %d \n", dwError);
        PrintError( dwError );
        goto FnExit;
    }

    loaded = TRUE;

    NtClose( hClusDisk0 );

FnExit:

    return loaded;

}   // IsClusDiskLoaded


BOOL
IsClusterCapable(
    HANDLE Scsi
    )
{
    DWORD           dwSize;
    BOOL            capable;
    SRB_IO_CONTROL  srb;


    ZeroMemory( &srb, sizeof( srb ) );

    srb.HeaderLength = sizeof( srb );

    CopyMemory( srb.Signature, CLUSDISK_SRB_SIGNATURE, sizeof( srb.Signature ) );

    srb.ControlCode = IOCTL_SCSI_MINIPORT_NOT_QUORUM_CAPABLE;

    //
    // Issue miniport IOCTL to determine whether the disk is cluster capable.
    // If the IOCTL fails, the disk is cluster capable.
    // If the IOCTL succeeds, the disk is NOT cluster capable.
    //

    if ( !DeviceIoControl( Scsi,
                           IOCTL_SCSI_MINIPORT,
                           &srb,
                           sizeof(SRB_IO_CONTROL),
                           NULL,
                           0,
                           &dwSize,
                           NULL
                           ) ) {
        capable = TRUE;
    } else {
        capable = FALSE;
    }

    return capable;

}   // IsClusterCapable




static DWORD
StartReserve(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;
    DWORD signature;
    STRING ansiString;
    UNICODE_STRING numberString;

    if (argc != 1)
    {
        printf( "usage: <device> StartReserve <device signature>\n" );
        return ERROR_INVALID_NAME;
    }

    RtlInitAnsiString( &ansiString, *argv );

    printf(" Ansi string for signature is %s\n",
             ansiString.Buffer );

    RtlAnsiStringToUnicodeString(
                            &numberString,
                            &ansiString,
                            TRUE );

    errorCode = RtlUnicodeStringToInteger(
                            &numberString,
                            16,
                            &signature );

    RtlFreeUnicodeString( &numberString );

    if ( !NT_SUCCESS(errorCode) ) {
        printf( "Error converting signature to hex number, NT status %u.\n",
                errorCode );
        return(errorCode);
    }

    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_CLUSTER_START_RESERVE,
                             &signature,
                             sizeof(DWORD),
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing StartReserve; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;
}


static DWORD
StopReserve(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;

    if (argc != 0)
    {
        printf( "usage: <device> StopReserve\n" );
        return ERROR_INVALID_NAME;
    }

    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_CLUSTER_STOP_RESERVE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing StopReserve; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;
}


static DWORD
Active(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD   errorCode, bytesReturned;
    DWORD   signatures[100];
    DWORD   number;
    DWORD   i;

    if (argc != 0)
    {
        printf( "usage: <device> Active\n" );
        return ERROR_INVALID_NAME;
    }

    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_CLUSTER_ACTIVE,
                             NULL,
                             0,
                             signatures,
                             sizeof(signatures),
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing active; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    printf("   List of signatures:\n\n");

    number = signatures[0];
    for ( i = 1; i <= number; i++ ) {
        printf("\t%08lX\n", signatures[i]);
    }
    printf("\n");

    return ERROR_SUCCESS;
}


static DWORD
Reserve(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;
    SCSI_PASS_THROUGH scsiBlock;

    if (argc != 0)
    {
        printf( "usage: <device> Reserve\n" );
        return ERROR_INVALID_NAME;
    }

    scsiBlock.PathId = 1;
    scsiBlock.TargetId = 3;
    scsiBlock.Lun = 0;
    scsiBlock.Length = sizeof(SCSI_PASS_THROUGH);

    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_RESERVE,
                             &scsiBlock,
                             sizeof(SCSI_PASS_THROUGH),
                             &scsiBlock,
                             sizeof(SCSI_PASS_THROUGH),
                             &bytesReturned,
                             FALSE);

    errorCode = GetLastError();
    if ( errorCode == ERROR_NOT_READY ) {
        success = DeviceIoControl(fileHandle,
                                  IOCTL_DISK_CLUSTER_RESERVE,
                                  &scsiBlock,
                                  sizeof(SCSI_PASS_THROUGH),
                                  &scsiBlock,
                                  sizeof(SCSI_PASS_THROUGH),
                                  &bytesReturned,
                                  FALSE);
    }
    if (!success) {
       errorCode = GetLastError();
       printf( "Error performing reserve; error was %d\n",
          errorCode);
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;

} // Reserve


static DWORD
Release(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;
    SCSI_PASS_THROUGH scsiBlock;

    if (argc != 0)
    {
        printf( "usage: <device> Release\n" );
        return ERROR_INVALID_NAME;
    }

    scsiBlock.PathId = 1;
    scsiBlock.TargetId = 3;
    scsiBlock.Lun = 0;
    scsiBlock.Length = sizeof(SCSI_PASS_THROUGH);

    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_RELEASE,
                             &scsiBlock,
                             sizeof(SCSI_PASS_THROUGH),
                             &scsiBlock,
                             sizeof(SCSI_PASS_THROUGH),
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing release; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;

} // Release


static DWORD
Online(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD   dwError = NO_ERROR;

    if (argc != 0)
    {
        printf( "usage: <device> Online\n" );
        dwError = ERROR_INVALID_NAME;
        goto FnExit;
    }

    dwError = SetState( fileHandle, DiskOnline );

FnExit:

    return dwError;

} // Online



static DWORD
Offline(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD dwError = NO_ERROR;

    if (argc != 0)
    {
        printf( "usage: <device> Offline\n" );
        dwError = ERROR_INVALID_NAME;
        goto FnExit;
    }

    dwError = SetState( fileHandle, DiskOffline );

FnExit:

    return dwError;

} // Offline


DWORD
SetState(
    HANDLE FileHandle,
    UCHAR NewState
    )
{
    PDRIVE_LAYOUT_INFORMATION   driveLayout = NULL;

    NTSTATUS    ntStatus;

    DWORD       dwError;
    DWORD       bytesReturned;

    HANDLE      hClusDisk0;

    UNICODE_STRING  unicodeName;
    ANSI_STRING     objName;

    OBJECT_ATTRIBUTES       objAttributes;
    IO_STATUS_BLOCK         ioStatusBlock;
    SET_DISK_STATE_PARAMS   params;

    BOOL        success;

    printf( "Setting disk state to %s \n", DiskStateToString( NewState ) );

    //
    // Get the signature.
    //

    success = ClRtlGetDriveLayoutTable( FileHandle, &driveLayout, NULL );

    if ( !success || !driveLayout ) {
        printf(" Unable to read drive layout \n");
        dwError = ERROR_GEN_FAILURE;
        goto FnExit;
    }

    RtlInitString( &objName, DEVICE_CLUSDISK0 );

    ntStatus = RtlAnsiStringToUnicodeString( &unicodeName,
                                             &objName,
                                             TRUE );

    if ( !NT_SUCCESS(ntStatus) ) {

        dwError = RtlNtStatusToDosError(ntStatus);
        printf( "Error converting string to unicode; error was %d \n", dwError);
        PrintError(dwError);
        goto FnExit;
    }

    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtCreateFile( &hClusDisk0,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );

    RtlFreeUnicodeString( &unicodeName );

    if ( !NT_SUCCESS(ntStatus) ) {

        dwError = RtlNtStatusToDosError(ntStatus);
        printf( "Error opening ClusDisk0 device; error was %d \n", dwError);
        PrintError(dwError);
        goto FnExit;
    }

    params.Signature = driveLayout->Signature;
    params.NewState = NewState;
    params.OldState = DiskStateInvalid;

    success = DeviceIoControl( hClusDisk0,
                               IOCTL_DISK_CLUSTER_SET_STATE,
                               &params,
                               sizeof(params),
                               &params,             // OldState can be returned in either structure or UCHAR
                               sizeof(params),      // ...with appropriate size here
                               &bytesReturned,
                               FALSE);
    NtClose( hClusDisk0 );

    if ( !success ) {
        printf( "Error performing %s; error was %d\n",
                DiskStateToString( NewState ),
                dwError = GetLastError() );
        PrintError(dwError);

    } else {
        printf( "Disk state set %s, old state %s  [bytes returned = %d] \n",
                DiskStateToString( NewState ),
                DiskStateToString( params.OldState ),
                bytesReturned );
        dwError = NO_ERROR;

    }

FnExit:

    LocalFree( driveLayout );

    return dwError;

}   // SetState



static DWORD
GetState(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL    success;
    DWORD   errorCode = NO_ERROR;
    DWORD   bytesReturned;
    UCHAR   oldState;

    if (argc != 0) {
        printf( "usage: <device> GetState\n" );
        errorCode = ERROR_INVALID_NAME;
        goto FnExit;
    }

    //
    // Try the new "get state" IOCTL.
    //

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_GET_STATE,
                               NULL,
                               0,
                               &oldState,
                               sizeof(oldState),
                               &bytesReturned,
                               FALSE );

    if ( !success ) {

       printf( "IOCTL_DISK_CLUSTER_GET_STATE failed; error was %d \n",
               errorCode = GetLastError());
       PrintError( errorCode );

       if ( ERROR_INVALID_FUNCTION != errorCode ) {
           goto FnExit;
       }

       printf( "Using old IOCTL to get disk state... \n");

       // Try the old "set state" IOCTL.
       // To get current disk state, don't specify input buffer.
       // Current disk state returned in output buffer.

       success = DeviceIoControl( fileHandle,
                                  IOCTL_DISK_CLUSTER_SET_STATE,
                                  NULL,
                                  0,
                                  &oldState,
                                  sizeof(oldState),
                                  &bytesReturned,
                                  FALSE );

       if ( !success ) {

          printf( "IOCTL_DISK_CLUSTER_SET_STATE failed; error was %d\n",
                  errorCode = GetLastError());
          PrintError( errorCode );
          goto FnExit;
       }
    }

    if ( bytesReturned != sizeof(oldState) ) {
        printf( "Invalid data retrieving cluster state: bytes returned = %d \n",
                bytesReturned );
        errorCode = ERROR_INVALID_DATA;
        goto FnExit;
    }

    printf( "Current cluster disk state: %s \n",
            DiskStateToString( oldState ) );

FnExit:

    return errorCode;

} // GetState


PCHAR
DiskStateToString(
    UCHAR DiskState
    )
{
    switch ( DiskState ) {

    case DiskOffline:
        return "DiskOffline (0)";

    case DiskOnline:
        return "DiskOnline  (1)";

    case DiskFailed:
        return "DiskFailed  (2)";

    case DiskStalled:
        return "DiskStalled (3)";

    case DiskOfflinePending:
        return "DiskOfflinePending (4)";

    default:
        return "Unknown DiskState";
    }

}   // DiskStateToString


DWORD
CheckUnclaimedPartitions(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;

    if (argc != 0)
    {
        printf( "usage: <device> Claim \n" );
        return ERROR_INVALID_NAME;
    }

    success = DeviceIoControl(fileHandle,
                             IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS,
                             NULL,
                             0,
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing Claim; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;

} // CheckUnclaimedPartitions


DWORD
EjectVolumes(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;

    if (argc != 0)
    {
        printf( "usage: <PhysicalDriveX> EjectVolumes \n" );
        return ERROR_INVALID_NAME;
    }

    success = DeviceIoControl(fileHandle,
                             IOCTL_PARTMGR_EJECT_VOLUME_MANAGERS,
                             NULL,
                             0,
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing EjectVolumes; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;

} // EjectVolumes


DWORD
EnumMounts(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL  success;
    DWORD status;
    DWORD bytesReturned;
    HANDLE handle;
    HANDLE mHandle;
    DWORD i;
    DWORD signature;
    UCHAR uniqueId[MAX_PATH];
    DWORD idLength;
    STRING ansiString;
    UNICODE_STRING numberString;
    UCHAR volumeName[MAX_PATH];
    UCHAR driveLetter;

    if (argc > 1)
    {
        printf( "usage: <any_device> EnumMounts [signature]\n" );
        return ERROR_INVALID_NAME;
    }

    if ( argc == 1 ) {
        RtlInitAnsiString( &ansiString, *argv );

        printf(" Ansi string for signature is %s\n",
                 ansiString.Buffer );

        RtlAnsiStringToUnicodeString(
                            &numberString,
                            &ansiString,
                            TRUE );

        status = RtlUnicodeStringToInteger(
                        &numberString,
                        16,
                        &signature );

        RtlFreeUnicodeString( &numberString );

        if ( !NT_SUCCESS(status) ) {
            printf( "Error converting signature to hex number, NT status %u.\n",
                    status );
            return(status);
        }
    } else {
        signature = 0;
    }

    status = DevfileOpen( &mHandle, MOUNTMGR_DEVICE_NAME );
    if ( status != ERROR_SUCCESS ) {
        printf( "DevfileOpen failed for %ws, status = %u\n",
            MOUNTMGR_DEVICE_NAME, status );
        return status;
    }

    idLength = MAX_PATH;
    status = FindFirstVolumeForSignature( mHandle,
                                          signature,
                                          volumeName,
                                          MAX_PATH,
                                          &handle,
                                          uniqueId,
                                          &idLength,
                                          &driveLetter );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        if ( status == ERROR_NO_MORE_FILES ) {
            status = ERROR_SUCCESS;
        } else {
            printf( "FindFirstVolume failed, status = %u\n", status );
        }
        return status;
    }

    i = 1;
    while ( status == ERROR_SUCCESS ) {

        printf( "Found match for volume %s\n", volumeName );

        i++;
        idLength = MAX_PATH;
        status = FindNextVolumeForSignature( mHandle,
                                             signature,
                                             handle,
                                             volumeName,
                                             MAX_PATH,
                                             uniqueId,
                                             &idLength,
                                             &driveLetter );
    }

    FindVolumeClose( handle );
    DevfileClose( mHandle );

    return ERROR_SUCCESS;

} // EnumMounts


DWORD
EnumExtents(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL    success;
    DWORD   status;
    DWORD   bytesReturned;
    DWORD   diskExtentSize;
    PVOLUME_DISK_EXTENTS diskExtents;
    DWORD   i;

    if (argc != 0)
    {
        printf( "usage: <device> EnumExtents\n" );
        return ERROR_INVALID_NAME;
    }

    diskExtentSize = sizeof(VOLUME_DISK_EXTENTS);
    diskExtents = LocalAlloc( LMEM_FIXED, diskExtentSize);
    if ( !diskExtents ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Get volume information for disk extents.
    //
    success = DeviceIoControl( fileHandle,
                               IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                               NULL,
                               0,
                               diskExtents,
                               diskExtentSize,
                               &bytesReturned,
                               FALSE );
    status = GetLastError();

    if ( !success ) {
        if ( status == ERROR_MORE_DATA ) {
            diskExtentSize = sizeof(VOLUME_DISK_EXTENTS) +
                             (sizeof(DISK_EXTENT) * diskExtents->NumberOfDiskExtents);
            LocalFree( diskExtents );
            diskExtents = LocalAlloc( LMEM_FIXED, diskExtentSize);
            if ( !diskExtents ) {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            status = ERROR_SUCCESS;
            success = DeviceIoControl( fileHandle,
                                   IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                                   NULL,
                                   0,
                                   diskExtents,
                                   diskExtentSize,
                                   &bytesReturned,
                                   FALSE );
            if ( !success ) {
                status = GetLastError();
            }
        }
    }

    if ( NO_ERROR == status ) {
        printf( "\n  Starting offset                Length             DiskNumber\n");
        printf( "  ---------------                ------             ----------\n");
        for ( i = 0; i < diskExtents->NumberOfDiskExtents; i++ ) {
            printf( " %08lx %08lx\t\t%08lx\t\t%u\n",
                     diskExtents->Extents[i].StartingOffset.HighPart,
                     diskExtents->Extents[i].StartingOffset.LowPart,
                     diskExtents->Extents[i].ExtentLength.LowPart,
                     diskExtents->Extents[i].DiskNumber );
        }
    }

    return status;

} // EnumExtents



DWORD
EnumNodes(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL        success;
    DWORD       status;
    HDEVINFO    hDevInfo;
    SP_DEVINFO_DATA devInfoData;
    DWORD       index;
    DWORD       size;
    LPDWORD     dwGuid;
    UCHAR       devDesc[MAX_PATH];
    UCHAR       devID[MAX_PATH];


    hDevInfo = SetupDiGetClassDevs( NULL,
                                    NULL,
                                    NULL,
                                    DIGCF_ALLCLASSES | DIGCF_PRESENT );

    if ( hDevInfo == INVALID_HANDLE_VALUE ) {
        status = GetLastError();
        printf( "SetupDiGetClassDevs failed with error %u\n", status );
        return status;
    }

    memset( &devInfoData, 0, sizeof(SP_DEVINFO_DATA));
    devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    //
    // First see if anything works...
    //
    success = SetupDiEnumDeviceInfo( hDevInfo, 0, &devInfoData );
    if ( !success ) {
        status = GetLastError();
        printf( "SetupDiEnumDeviceInfo failed, status = %u\n", status );
        return status;
    }

    index = 0;
    while ( SetupDiEnumDeviceInfo( hDevInfo, index, &devInfoData ) ) {
        devDesc[0] = '\0';
        size = sizeof(devDesc);
        printf( "Index = %u\n", index );
        if ( CM_Get_DevNode_Registry_Property( devInfoData.DevInst,
                                               CM_DRP_DEVICEDESC,
                                               NULL,
                                               devDesc,
                                               &size,
                                               0 ) == 0 ) {
            printf( "Device description = %s\n", devDesc );
            dwGuid = (LPDWORD)&devInfoData.ClassGuid;
            printf( "   GUID = %lx, %lx, %lx, %lx\n", dwGuid[0], dwGuid[1], dwGuid[2], dwGuid[3] );
            devID[0] = '\0';
            CM_Get_Device_ID( devInfoData.DevInst,
                              devID,
                              sizeof(devID),
                              0 );
            if ( devID[0] ) {
                printf( "   Device Id = %s\n", devID );
            }
        }

        index++;
    }

    return ERROR_SUCCESS;

} // EnumNodes



DWORD
EnumDisks(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;
    BOOL  success;
    HDEVINFO DeviceInfoSet;
    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
    DWORD i;
    PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData = NULL;
    DWORD DeviceInterfaceDetailDataSize = 0;
    DWORD RequiredSize;
    SP_DEVINFO_DATA DeviceInfoData;
    SP_PROPCHANGE_PARAMS PropChangeParams;
    BOOL disable = FALSE;
    BOOL parent = FALSE;
    //GUID mountDevGuid;
    GUID diskDevGuid;
    HANDLE devHandle;
    UCHAR driveLayoutBuf[sizeof(DRIVE_LAYOUT_INFORMATION) +
                        (sizeof(PARTITION_INFORMATION) * 64 )];
    PDRIVE_LAYOUT_INFORMATION driveLayout = (PDRIVE_LAYOUT_INFORMATION)driveLayoutBuf;

    if (argc > 1)
    {
        printf( "usage: <any_device> EnumDisks [DISABLE | PARENT]\n" );
        return ERROR_INVALID_NAME;
    }

    if ( argc == 1 ) {
        if (!_stricmp( *argv, "Disable" ))
            disable = TRUE;
        else if (!_stricmp( *argv, "Parent" ))
            parent = TRUE;
        else {
            printf( "usage: <any_device> EnumDisks [DISABLE | PARENT]\n" );
            return ERROR_INVALID_NAME;
        }
    }

    memcpy( &diskDevGuid, &DiskClassGuid, sizeof(GUID) );
    //memcpy( &mountDevGuid, &MOUNTDEV_MOUNTED_DEVICE_GUID, sizeof(GUID) );

    DeviceInfoSet = SetupDiGetClassDevs(&diskDevGuid,
                                        NULL,
                                        NULL,
                                        DIGCF_DEVICEINTERFACE | DIGCF_PRESENT
                                       );

    if ( INVALID_HANDLE_VALUE == DeviceInfoSet ) {
        status = GetLastError();
        printf("SetupDiGetClassDevs failed, error %u \n", status );
        return status;
    }

    DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    for(i = 0;
        SetupDiEnumDeviceInterfaces(DeviceInfoSet,
                                    NULL,
                                    &diskDevGuid,
                                    i,
                                    &DeviceInterfaceData);
        i++) {

        //
        // To retrieve the device interface name (e.g., that you can call
        // CreateFile() on...
        //
        while(!SetupDiGetDeviceInterfaceDetailW(DeviceInfoSet,
                                               &DeviceInterfaceData,
                                               DeviceInterfaceDetailData,
                                               DeviceInterfaceDetailDataSize,
                                               &RequiredSize,
                                               &DeviceInfoData) ) {
            //
            // We failed to get the device interface detail data--was it because
            // our buffer was too small? (Hopefully so!)
            //
            status = GetLastError();
            //printf("Call to SetupDiGetDeviceInterfaceData failed status = %u, required size = %u\n",
            //    status, RequiredSize);

            // Free our current buffer since we failed anyway.
            free(DeviceInterfaceDetailData);
            DeviceInterfaceDetailData = NULL;

            if(status != ERROR_INSUFFICIENT_BUFFER) {
                //
                // Failure!
                //
                break;
            }

            DeviceInterfaceDetailData = malloc(RequiredSize);
            if(DeviceInterfaceDetailData) {
                DeviceInterfaceDetailDataSize = RequiredSize;
                DeviceInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);
            } else {
                //
                // Failure!
                //
                DeviceInterfaceDetailDataSize = 0;
                break;
            }
        }

        if(!DeviceInterfaceDetailData) {
            //
            // We encountered a failure above--abort.
            //
            break;
        }

        //
        // Now we may use the device interface name contained in the
        // DeviceInterfaceDetailData->DevicePath field (e.g., in a call to
        // CreateFile).
        //

        printf("DevicePath = %ws\n", DeviceInterfaceDetailData->DevicePath );
        devHandle = CreateFileW( DeviceInterfaceDetailData->DevicePath,
                                 GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL );

        if ( devHandle != INVALID_HANDLE_VALUE ) {
            // Get signature
            success = DeviceIoControl( devHandle,
                            IOCTL_DISK_GET_DRIVE_LAYOUT,
                            NULL,
                            0,
                            driveLayout,
                            sizeof(driveLayoutBuf),
                            &RequiredSize,
                            FALSE );
            if ( success ) {
                printf( " Signature for device = %08lx\n", driveLayout->Signature );
            }
            CloseHandle( devHandle );
        }

        //
        // To open up the persistent storage registry key associated with this
        // device interface (e.g., to retrieve it's FriendlyName value entry),
        // use SetupDiCreateDeviceInterfaceRegKey or
        // SetupDiOpenDeviceInterfaceRegKey.
        //

        //
        // Notice that we retrieved the associated device information element
        // in the above call to SetupDiGetDeviceInterfaceDetail.  We can thus
        // use this element in setupapi calls to effect changes to the devnode
        // (including invoking the class installer and any co-installers that
        // may be involved).
        //
        // For example, here's how we'd disable the device...
        //

        if ( disable ) {
            // Perform following only if we are supposed to disable

#ifdef PERSISTENT
        PropChangeParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
        PropChangeParams.StateChange = DICS_DISABLE;
        PropChangeParams.Scope = DICS_FLAG_GLOBAL;
        //
        // No need to set PropChangeParams.HwProfile since we're doing global
        // property change.
        //
        if( !SetupDiSetClassInstallParamsW(DeviceInfoSet,
                                     &DeviceInfoData,
                                     (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                     sizeof(PropChangeParams)
                                    ) ) {
            status = GetLastError();
            printf( "SetupDiSetClassInstallParams failed with %u\n", status );
            continue;
        }

        if ( !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                  DeviceInfoSet,
                                  &DeviceInfoData
                                 ) ) {
            status = GetLastError();
            printf( "SetupDiCallClassInstaller failed with %u\n", status );
            continue;
        }

        printf("Disabled!\n");
        getchar();

        //
        // ...and here's how we'd re-enable it...
        //
        PropChangeParams.StateChange = DICS_ENABLE;
        if ( !SetupDiSetClassInstallParamsW(DeviceInfoSet,
                                     &DeviceInfoData,
                                     (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                     sizeof(PropChangeParams)
                                    ) ) {
            status = GetLastError();
            printf( "SetupDiSetClassInstallParams failed with %u\n", status );
            continue;
        }

        if ( !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                  DeviceInfoSet,
                                  &DeviceInfoData
                                 ) ) {
            status = GetLastError();
            printf( "SetupDiCallClassInstaller failed with %u\n", status );
       }
#else
#if 0 // we don't support multiple switches together - this would need disable
      // and parent set together!
        //
        // Try to find parent
        //
        if ( parent ) {
            status = CM_Get_Parent( parentDev,
                                    DeviceInfoData.DevInst,
                                    0 );
            if ( status != ERROR_SUCCESS ) {
                printf( "CM_Get_Parent failed with %u\n", status );
                continue;
            }
        }
#endif
        //
        // NOTE:  The code above does a persistent disable/enable.  If you only
        // wanted this to be temporary (i.e., in effect till reboot), then you
        // could retrieve the devnode handle from the DeviceInfoData.DevInst
        // field and call CM_Disable_DevNode and CM_Enable_DevNode directly.
        //
        status = CM_Disable_DevNode( DeviceInfoData.DevInst, 0 );
        if ( status != ERROR_SUCCESS ) {
            printf( "CM_Disable_DevNode failed with %u\n", status );
            continue;
        }

        printf("Disabled!\n");
        getchar();

        status = CM_Enable_DevNode( DeviceInfoData.DevInst, 0 );
        if ( status != ERROR_SUCCESS ) {
            printf( "CM_Enable_DevNode failed with %u\n", status );
        }
#endif //PERSISTENT

        } else { // If we are supposed to disable the disk
          //
          // Try to find parent
          //
          if ( parent ) {
            DEVINST parentDev;
            DEVINST pParentDev = 0;
            WCHAR   outBuffer[MAX_PATH];
            HDEVINFO devInfoSet;
            SP_DEVINFO_DATA devInfoData;
            SP_DEVICE_INTERFACE_DATA devInterfaceData;

          do {
            status = CM_Get_Parent( &parentDev,
                                    DeviceInfoData.DevInst,
                                    0 );
            if ( status != ERROR_SUCCESS ) {
                printf( "CM_Get_Parent failed with %u\n", status );
                break;
            }

            if ( pParentDev == parentDev ) {
                break;
            }

            pParentDev = parentDev;
            status = CM_Get_Device_IDW( parentDev,
                                        outBuffer,
                                        sizeof(outBuffer)/sizeof(WCHAR),
                                        0 );

            if ( status != ERROR_SUCCESS ) {
                printf( "CM_Get_Parent failed with %u\n", status );
                //status = ERROR_SUCCESS;
            } else {
                printf( "    ParentDev = %ws\n", outBuffer );
            }
          } while ( status == ERROR_SUCCESS );
          }

        }
    }

    SetupDiDestroyDeviceInfoList(DeviceInfoSet);

    return ERROR_SUCCESS;

} // EnumDisks



DWORD
GetDiskGeometry(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    DISK_GEOMETRY diskGeometry;

    if (argc != 0)
    {
        printf( "usage: <device> GetDiskGeometry\n" );
        return ERROR_INVALID_NAME;
    }

    ZeroMemory( &diskGeometry, sizeof(DISK_GEOMETRY) );

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_GEOMETRY,
                               NULL,
                               0,
                               &diskGeometry,
                               sizeof(DISK_GEOMETRY),
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing GetDiskGeometry, error %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    if ( bytesReturned < sizeof(DISK_GEOMETRY) ) {
        printf("Error reading DiskGeometry information. Expected %u bytes, got %u bytes.\n",
            sizeof(DISK_GEOMETRY),
            bytesReturned);
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    printf("GetDiskGeometry was successful, we got %d bytes returned.\n",
            bytesReturned);

    printf("Cylinders = %lx%lx, TracksPerCylinder = %lx, SectorsPerTrack = %lx, BytesPerSector = %lx\n",

        diskGeometry.Cylinders.HighPart, diskGeometry.Cylinders.LowPart,
        diskGeometry.TracksPerCylinder, diskGeometry.SectorsPerTrack,
        diskGeometry.BytesPerSector);

    return ERROR_SUCCESS;

} // GetDiskGeometry


DWORD
GetScsiAddress(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    SCSI_ADDRESS scsiAddress;

    if (argc != 0)
    {
        printf( "usage: <device> GetScsiAddress\n" );
        return ERROR_INVALID_NAME;
    }

    ZeroMemory( &scsiAddress, sizeof(scsiAddress) );

    success = DeviceIoControl( fileHandle,
                               IOCTL_SCSI_GET_ADDRESS,
                               NULL,
                               0,
                               &scsiAddress,
                               sizeof(SCSI_ADDRESS),
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing GetScsiAddress, error %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    if ( bytesReturned < sizeof(scsiAddress) ) {
        printf("Error reading ScsiAddress information. Expected %u bytes, got %u bytes.\n",
            sizeof(scsiAddress),
            bytesReturned);
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    printf("GetScsiAddress was successful, we got %d bytes returned.\n",
            bytesReturned);

    printf("PortNumber = %x, PathId = %x, TargetId = %x, Lun = %x\n",

        scsiAddress.PortNumber, scsiAddress.PathId,
        scsiAddress.TargetId, scsiAddress.Lun);

    return ERROR_SUCCESS;

} // GetScsiAddress


DWORD
GetDriveLayout(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    DWORD harddiskNo;
    DWORD i;
    PDRIVE_LAYOUT_INFORMATION driveLayout;
    PPARTITION_INFORMATION partInfo;

    if (argc != 0)
    {
        printf( "usage: <device> GetDriveLayout\n" );
        return ERROR_INVALID_NAME;
    }

    driveLayout = DoIoctlAndAllocate(fileHandle,
                                     IOCTL_DISK_GET_DRIVE_LAYOUT,
                                     NULL, 0, &bytesReturned);
    if (!driveLayout) {
        return GetLastError();
    }

    printf("GetDriveLayout was successful, %d bytes returned.\n",
            bytesReturned);

    printf("Partition Count = %u \n", driveLayout->PartitionCount);
    printf("Signature = %lx\n", driveLayout->Signature);

    printf("\n");
    printf("Part# Type Recog BootInd    PartOff      PartLeng    HidSect  Rewrite \n");
    printf("===== ==== ===== ======= ============  ============  =======  ======= \n");

    for (i = 0; i < driveLayout->PartitionCount; i++ ) {
        partInfo = &driveLayout->PartitionEntry[i];

        printf("  %2u   %2X    %1u      %1u    %12I64X  %12I64X  %7u   %s \n",
            partInfo->PartitionNumber,
            partInfo->PartitionType,
            partInfo->RecognizedPartition,
            partInfo->BootIndicator,
            partInfo->StartingOffset.QuadPart,
            partInfo->PartitionLength.QuadPart,
            partInfo->HiddenSectors,
            BooleanToString( partInfo->RewritePartition )
            );
    }

    free( driveLayout );

    return ERROR_SUCCESS;

} // GetDriveLayout


DWORD
GetDriveLayoutEx(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayout = NULL;
    PPARTITION_INFORMATION_EX       partInfo;
    DWORD                           errorCode = NO_ERROR;
    DWORD                           bytesReturned;
    DWORD                           harddiskNo;
    DWORD                           idx;
    DWORD                           nameIdx;
    BOOL                            success;

    TCHAR                           strGuid[MAX_PATH];
    TCHAR                           strType[MAX_PATH];

    if ( argc != 0 ) {
        printf( "usage: <device> GetDriveLayoutEx \n" );
        errorCode = ERROR_INVALID_NAME;
        goto FnExit;
    }

    driveLayout = DoIoctlAndAllocate( fileHandle,
                                      IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                      NULL, 0, &bytesReturned );
    if ( !driveLayout ) {
        errorCode = GetLastError();
        printf("IOCTL_DISK_GET_DRIVE_LAYOUT_EX failed: %u \n", errorCode);
        PrintError( errorCode );
        goto FnExit;
    }

    printf("GetDriveLayoutEx was successful: %d bytes returned.\n",
            bytesReturned);

    printf("Partition style = ");

    if ( PARTITION_STYLE_MBR == driveLayout->PartitionStyle ) {
        printf("MBR \n");
    } else if ( PARTITION_STYLE_GPT == driveLayout->PartitionStyle ) {
        printf("GPT \n");
    } else if ( PARTITION_STYLE_RAW == driveLayout->PartitionStyle ) {
        printf("RAW \n");
        goto FnExit;
    } else {
        printf("Unknown \n");
        goto FnExit;
    }

    printf("Partition Count = %u \n", driveLayout->PartitionCount);

    if ( PARTITION_STYLE_MBR == driveLayout->PartitionStyle ) {

        printf("Signature = %lx \n", driveLayout->Mbr.Signature);

        printf("\n");
        printf("Part# Type Recog BootInd    PartOff      PartLeng    HidSect  Rewrite \n");
        printf("===== ==== ===== ======= ============  ============  =======  ======= \n");

        for ( idx = 0; idx < driveLayout->PartitionCount; idx++ ) {
            partInfo = &driveLayout->PartitionEntry[idx];

            if ( PARTITION_STYLE_MBR != partInfo->PartitionStyle ) {
                printf("Skipping partition: style is not MBR (%u) \n", partInfo->PartitionStyle);
                continue;
            }

            printf("  %2u   %2X    %1u      %1u    %12I64X  %12I64X  %7u   %s \n",
                   partInfo->PartitionNumber,
                   partInfo->Mbr.PartitionType,
                   partInfo->Mbr.RecognizedPartition,
                   partInfo->Mbr.BootIndicator,
                   partInfo->StartingOffset.QuadPart,
                   partInfo->PartitionLength.QuadPart,
                   partInfo->Mbr.HiddenSectors,
                   BooleanToString( partInfo->RewritePartition )
                   );
        }

    } else {

        FormatGuid( &(driveLayout->Gpt.DiskId), strGuid, RTL_NUMBER_OF(strGuid) );
        printf("Signature (GUID)   = %s \n", strGuid );
        printf("Signature (hashed) = %08x \n", ClusterHashGuid( driveLayout->Gpt.DiskId ) );

        printf("\n");
        printf("Part#       PartOff          PartLeng       Rewrite \n");
        printf("=====  ================  ================   ======= \n");

        for ( idx = 0; idx < driveLayout->PartitionCount; idx++ ) {
            partInfo = &driveLayout->PartitionEntry[idx];

            if ( idx ) {
                printf("\n");
            }

            if ( PARTITION_STYLE_GPT != partInfo->PartitionStyle ) {
                printf("Skipping partition: style is not GPT (%u) \n", partInfo->PartitionStyle);
                continue;
            }

            printf("  %2u   %16I64X  %16I64X   %s \n",
                   partInfo->PartitionNumber,
                   partInfo->StartingOffset.QuadPart,
                   partInfo->PartitionLength.QuadPart,
                   BooleanToString( partInfo->RewritePartition )
                   );

            FormatGuid( &(partInfo->Gpt.PartitionType), strGuid, RTL_NUMBER_OF(strGuid) );
            if ( !memcmp( &(partInfo->Gpt.PartitionType), &PARTITION_SYSTEM_GUID, sizeof(GUID) ) ) {
                (VOID) StringCchPrintf(strType, RTL_NUMBER_OF(strType), "System");
            } else if ( !memcmp( &(partInfo->Gpt.PartitionType), &PARTITION_MSFT_RESERVED_GUID, sizeof(GUID) ) ) {
                (VOID) StringCchPrintf(strType, RTL_NUMBER_OF(strType), "Microsoft Reserved");
            } else if ( !memcmp( &(partInfo->Gpt.PartitionType), &PARTITION_BASIC_DATA_GUID, sizeof(GUID) ) ) {
                (VOID) StringCchPrintf(strType, RTL_NUMBER_OF(strType), "Basic Data");
            } else if ( !memcmp( &(partInfo->Gpt.PartitionType), &PARTITION_LDM_METADATA_GUID, sizeof(GUID) ) ) {
                (VOID) StringCchPrintf(strType, RTL_NUMBER_OF(strType), "LDM Metadata");
            } else if ( !memcmp( &(partInfo->Gpt.PartitionType), &PARTITION_LDM_DATA_GUID, sizeof(GUID) ) ) {
                (VOID) StringCchPrintf(strType, RTL_NUMBER_OF(strType), "LDM Data");
#if PARTITION_CLUSTER_GUID
            } else if ( !memcmp( &(partInfo->Gpt.PartitionType), &PARTITION_CLUSTER_GUID, sizeof(GUID) ) ) {
                (VOID) StringCchPrintf(strType, RTL_NUMBER_OF(strType), "Cluster Data");
#endif
            } else {
                (VOID) StringCchPrintf(strType, RTL_NUMBER_OF(strType), "Unknown partition type");
            }

            printf("\n");
            printf("     PartitionType = %s \n", strGuid);
            printf("                     %s \n", strType);

            FormatGuid(&(partInfo->Gpt.PartitionId), strGuid, RTL_NUMBER_OF(strGuid) );
            printf("     PartitionId   = %s \n", strGuid);

            printf("     Attributes    = %I64X \n", partInfo->Gpt.Attributes);

            printf("     Name: ");
            for ( nameIdx = 0; nameIdx < 36; nameIdx++ ) {

                printf("%c", partInfo->Gpt.Name[nameIdx]);
            }
            printf("\n");

        }

    }


FnExit:

    free( driveLayout );

    return ERROR_SUCCESS;

}   // GetDriveLayoutEx


LPTSTR
BooleanToString(
    BOOLEAN Value
    )
{
    if ( Value ) {
        return "TRUE ";
    }

    return "FALSE";

}   // BooleanToString



void
FormatGuid(
    GUID*   Guid,
    char*   Str,
    int     StrCharMax
    )
{
    //
    //  Code from guidgen
    //

    (VOID) StringCchPrintf( Str,
                            StrCharMax,
                            "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                            // first copy...
                            Guid->Data1, Guid->Data2, Guid->Data3,
                            Guid->Data4[0], Guid->Data4[1], Guid->Data4[2], Guid->Data4[3],
                            Guid->Data4[4], Guid->Data4[5], Guid->Data4[6], Guid->Data4[7] );
}


DWORD
GetVolumeInfo(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    PCLUSPROP_PARTITION_INFO partInfo;
    ANSI_STRING ansiName;
    UNICODE_STRING unicodeName;
    NTSTATUS ntStatus;

    if (argc != 0) {
        printf( "usage: <device> GetVolumeInfo\n" );
        return ERROR_INVALID_NAME;
    }

    ntStatus = GetVolumeInformationFromHandle(fileHandle);
    if ( !NT_SUCCESS(ntStatus) ) {
       errorCode = RtlNtStatusToDosError( ntStatus );
       printf( "GetVolumeInformationFromHandle failed with status %X, %u\n",
               ntStatus, errorCode );
    }

    partInfo = LocalAlloc( LMEM_FIXED, sizeof(CLUSPROP_PARTITION_INFO) );

    if ( !partInfo ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory( partInfo, sizeof(CLUSPROP_PARTITION_INFO) );

    RtlInitString(&ansiName, DeviceName);
    errorCode = RtlAnsiStringToUnicodeString( &unicodeName,
                                              &ansiName,
                                              TRUE );
    if ( !NT_SUCCESS(errorCode) ) {
        return(errorCode);
    }

    // The following assumes a drive letter is used.
    // wsprintfW( partInfo->szDeviceName, L"%c:\\", unicodeName.Buffer[0] );

    wcsncpy( partInfo->szDeviceName, unicodeName.Buffer, unicodeName.Length );

    RtlFreeUnicodeString( &unicodeName );

    if ( !GetVolumeInformationW( partInfo->szDeviceName,
                                partInfo->szVolumeLabel,
                                RTL_NUMBER_OF(partInfo->szVolumeLabel),
                                &partInfo->dwSerialNumber,
                                &partInfo->rgdwMaximumComponentLength,
                                &partInfo->dwFileSystemFlags,
                                partInfo->szFileSystem,
                                RTL_NUMBER_OF(partInfo->szFileSystem) ) ) {
        partInfo->szVolumeLabel[0] = L'\0';
        errorCode = GetLastError();
        printf("Error reading volume information for %ws. Error %u.\n",
                partInfo->szDeviceName,
                errorCode);
        LocalFree( partInfo );
        return( errorCode );
    }

    printf("DeviceName = %ws\n", partInfo->szDeviceName);
    printf("VolumeLabel = %ws\n", partInfo->szVolumeLabel);
    printf("FileSystemFlags = %lx, FileSystem = %ws\n",
            partInfo->dwFileSystemFlags, partInfo->szFileSystem);

    LocalFree( partInfo );

    return ERROR_SUCCESS;

} // GetVolumeInfo


DWORD
SetDriveLayout(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    DWORD driveLayoutSize;
    PDRIVE_LAYOUT_INFORMATION driveLayout;
    PPARTITION_INFORMATION partInfo;
    DWORD index;
    DWORD partShift = 0;

    if (argc != 0)
    {
        printf( "usage: <device> SetDriveLayout\n" );
        return ERROR_INVALID_NAME;
    }

    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                      (sizeof(PARTITION_INFORMATION) * MAX_PARTITIONS);

    driveLayout = LocalAlloc( LMEM_FIXED, driveLayoutSize );

    if ( !driveLayout ) {
        return(ERROR_OUTOFMEMORY);
    }

    ZeroMemory( driveLayout, driveLayoutSize );

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_LAYOUT,
                               NULL,
                               0,
                               driveLayout,
                               driveLayoutSize,
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing GetDriveLayout; error was %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        LocalFree( driveLayout );
        return errorCode;
    }

    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                      (sizeof(PARTITION_INFORMATION) *
                      (driveLayout->PartitionCount - 1));

    if ( bytesReturned < driveLayoutSize ) {
        printf("Error reading DriveLayout information. Expected %u bytes, got %u bytes.\n",
            sizeof(DRIVE_LAYOUT_INFORMATION) + (sizeof(PARTITION_INFORMATION) *
            (driveLayout->PartitionCount - 1)), bytesReturned);
        LocalFree( driveLayout );
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    if ( driveLayout->PartitionCount > MAX_PARTITIONS ) {
        printf("SetDriveLayout, exiting - too many partitions!\n");
        LocalFree( driveLayout );
        return(ERROR_TOO_MANY_LINKS);
    }

    for ( index = 0;
          (index < driveLayout->PartitionCount) &&
          (index < MAX_PARTITIONS );
          index++ ) {
        partInfo = &driveLayout->PartitionEntry[index];
        if ( (partInfo->PartitionType == PARTITION_ENTRY_UNUSED) ||
             !partInfo->RecognizedPartition ) {
            continue;
        }

        if ( (index == 0) &&
             (partInfo->PartitionNumber == 0) ) {
            partShift = 1;
        }
        printf("Partition %u was %s\n", partInfo->PartitionNumber, (partShift? "incremented" : "left alone"));
        partInfo->PartitionNumber += partShift;
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_SET_DRIVE_LAYOUT,
                               driveLayout,
                               driveLayoutSize,
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );

    if ( !success ) {
        printf("Error performing SetDriveLayout, error %u.\n",
            errorCode = GetLastError());
        PrintError(errorCode);
        LocalFree( driveLayout );
        return(errorCode);
    }

    LocalFree( driveLayout );

    printf("SetDriveLayout was successful. Set %d bytes.\n", driveLayoutSize);

    return ERROR_SUCCESS;

} // SetDriveLayout



static DWORD
Attach(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    DWORD signature;
    STRING ansiString;
    UNICODE_STRING numberString;

    if (argc != 1)
    {
        printf( "usage: <device> Attach <device signature>\n" );
        return ERROR_INVALID_NAME;
    }

    RtlInitAnsiString( &ansiString, *argv );

    printf(" Ansi string for signature is %s\n",
             ansiString.Buffer );

    RtlAnsiStringToUnicodeString(
                            &numberString,
                            &ansiString,
                            TRUE );

    errorCode = RtlUnicodeStringToInteger(
                            &numberString,
                            16,
                            &signature );

    RtlFreeUnicodeString( &numberString );

    if ( !NT_SUCCESS(errorCode) ) {
        printf( "Error converting signature to hex number, NT status %u.\n",
                errorCode );
        return(errorCode);
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_ATTACH,
                               &signature,
                               sizeof(DWORD),
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing ATTACH, error was %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    return ERROR_SUCCESS;

} // Attach



static DWORD
Detach(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    DWORD signature;
    STRING ansiString;
    UNICODE_STRING numberString;

    if (argc != 1)
    {
        printf( "usage: <device> Detach <device signature>\n" );
        return ERROR_INVALID_NAME;
    }

    RtlInitAnsiString( &ansiString, *argv );

    printf(" Ansi string for signature is %s\n",
             ansiString.Buffer );

    RtlAnsiStringToUnicodeString(
                            &numberString,
                            &ansiString,
                            TRUE );

    errorCode = RtlUnicodeStringToInteger(
                            &numberString,
                            16,
                            &signature );

    RtlFreeUnicodeString( &numberString );

    if ( !NT_SUCCESS(errorCode) ) {
        printf( "Error converting signature to hex number, NT status %u.\n",
                errorCode );
        return(errorCode);
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_DETACH,
                               &signature,
                               sizeof(DWORD),
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing DETACH, error was %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    return ERROR_SUCCESS;

} // Detach



static DWORD
GetPartitionInfo(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    PARTITION_INFORMATION partInfo;

    if (argc != 0)
    {
        printf( "usage: <device> GetPartitionInfo\n" );
        return ERROR_INVALID_NAME;
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_PARTITION_INFO,
                               NULL,
                               0,
                               &partInfo,
                               sizeof(PARTITION_INFORMATION),
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing GetPartitionInfo; error was %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    printf("GetPartitionInfo was successful, we got %d bytes returned.\n\n",
            bytesReturned);

    printf("Part# Type Recog BootInd      PartOff      PartLeng   HidSect\n");

#if 0
Part# Type Recog BootInd      PartOff      PartLeng   HidSect
  xx   xx    x      x    xxxxxxxxxxxx  xxxxxxxxxxxx   xxxxxxx
#endif
    printf("  %2u   %2X    %1u      %1u    %12I64X  %12I64X   %7u\n",
        partInfo.PartitionNumber,
        partInfo.PartitionType,
        partInfo.RecognizedPartition,
        partInfo.BootIndicator,
        partInfo.StartingOffset.QuadPart,
        partInfo.PartitionLength.QuadPart,
        partInfo.HiddenSectors);

    return ERROR_SUCCESS;

} // GetPartitionInfo



DWORD
ReadSector(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD status;
    DWORD bytesReturned;
    DWORD bytesRead;
    DWORD x,y;

    DISK_GEOMETRY diskGeometry;
    LPBYTE buf = 0;
    INT   sectorNo;

    if (argc != 1)
    {
        printf( "usage: <device> ReadSector No\n" );
        return ERROR_INVALID_NAME;
    }

    status = sscanf(argv[0], "%d", &sectorNo);

    if ( 0 == status ) {
        printf("Unable to get sector number from input \n");
        return ERROR_INVALID_PARAMETER;
    }

    ZeroMemory( &diskGeometry, sizeof(DISK_GEOMETRY) );

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_GEOMETRY,
                               NULL,
                               0,
                               &diskGeometry,
                               sizeof(DISK_GEOMETRY),
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing GetDiskGeometry, error %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    if ( bytesReturned < sizeof(DISK_GEOMETRY) ) {
        printf("Error reading DiskGeometry information. Expected %u bytes, got %u bytes.\n",
            sizeof(DISK_GEOMETRY),
            bytesReturned);
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    printf("GetDiskGeometry was successful, we got %d bytes returned.\n",
            bytesReturned);

    printf("Cylinders = %lx%lx, TracksPerCylinder = %lx, SectorsPerTrack = %lx, BytesPerSector = %lx\n",

        diskGeometry.Cylinders.HighPart, diskGeometry.Cylinders.LowPart,
        diskGeometry.TracksPerCylinder, diskGeometry.SectorsPerTrack,
        diskGeometry.BytesPerSector);

    errorCode = ERROR_SUCCESS;

    __try {

       buf = VirtualAlloc(0, diskGeometry.BytesPerSector, MEM_COMMIT, PAGE_READWRITE);
       if(buf == 0) {
          printf("Virtual Alloc failed\n");
          errorCode = GetLastError();
          __leave;
       }
       printf("Sector %d\n", sectorNo);
       status = SetFilePointer(fileHandle,
                               diskGeometry.BytesPerSector * sectorNo,
                               NULL,
                               FILE_BEGIN);

       if( 0xFFFFFFFF == status ) {
          printf("Error setting file pointer to %lx \n", diskGeometry.BytesPerSector * sectorNo);
          errorCode = GetLastError();
          __leave;
       }

       status = ReadFile(fileHandle,
                         buf,
                         diskGeometry.BytesPerSector,
                         &bytesRead,
                         NULL);
       if( status == 0 ) {
          printf("Error reading sector %lx \n.", sectorNo);
          errorCode = GetLastError();
          __leave;
       }

       if ( bytesRead != diskGeometry.BytesPerSector ) {
           printf("Error reading sector. Expected %ul bytes, got %ul bytes.\n",
               diskGeometry.BytesPerSector,
               bytesRead);
           errorCode = ERROR_INSUFFICIENT_BUFFER;
           __leave;
       }

       for(x = 0; x < diskGeometry.BytesPerSector; x += 16) {
          for(y = 0; y < 16; ++y) {
             BYTE ch = buf[x+y];
             if (ch >= ' ' && ch <= '~') {
                printf("  %c", ch);
             } else {
                printf(" %02x", ch);
             }
          }
          printf("\n");
       }
       errorCode = ERROR_SUCCESS;
    }
    __finally {
       if(buf) {
          VirtualFree(buf, 0, MEM_RELEASE);
       }
    }


    return errorCode;

} // ReadSector


DWORD
ReadSectorViaIoctl(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    DISK_GEOMETRY diskGeometry;
    DWORD bytesRead;
    DWORD status;
    DWORD x,y;
    ARBITRATION_READ_WRITE_PARAMS params;

    LPBYTE buf = 0;
    INT   sectorNo;

    if (argc != 1)
    {
        printf( "usage: <device> rs No\n" );
        return ERROR_INVALID_NAME;
    }
    status = sscanf(argv[0], "%d", &sectorNo);

    if ( 0 == status ) {
        printf("Unable to get sector number from input \n");
        return ERROR_INVALID_PARAMETER;
    }

    ZeroMemory( &diskGeometry, sizeof(DISK_GEOMETRY) );

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_GEOMETRY,
                               NULL,
                               0,
                               &diskGeometry,
                               sizeof(DISK_GEOMETRY),
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing GetDiskGeometry, error %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    if ( bytesReturned < sizeof(DISK_GEOMETRY) ) {
        printf("Error reading DiskGeometry information. Expected %u bytes, got %u bytes.\n",
            sizeof(DISK_GEOMETRY),
            bytesReturned);
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    printf("GetDiskGeometry was successful, we got %d bytes returned.\n",
            bytesReturned);

    printf("Cylinders = %lx%lx, TracksPerCylinder = %lx, SectorsPerTrack = %lx, BytesPerSector = %lx\n",

        diskGeometry.Cylinders.HighPart, diskGeometry.Cylinders.LowPart,
        diskGeometry.TracksPerCylinder, diskGeometry.SectorsPerTrack,
        diskGeometry.BytesPerSector);

    errorCode = ERROR_SUCCESS;
    __try {

       buf = VirtualAlloc(0, diskGeometry.BytesPerSector, MEM_COMMIT, PAGE_READWRITE);
       if(buf == 0) {
          printf("Virtual Alloc failed\n");
          errorCode = GetLastError();
          __leave;
       }
       printf("Sector %d\n", sectorNo);

       params.Operation = AE_READ;
       params.SectorSize = diskGeometry.BytesPerSector;
       params.SectorNo = sectorNo;
       params.Buffer = buf;

       success = DeviceIoControl( fileHandle,
                                  IOCTL_DISK_CLUSTER_ARBITRATION_ESCAPE,
                                  &params,
                                  sizeof(params),
                                  NULL,
                                  0,
                                  &bytesReturned,
                                  FALSE );
       if(!success) {
          printf("Error reading sector %lx\n.", sectorNo);
          errorCode = GetLastError();
          __leave;
       }

       for(x = 0; x < diskGeometry.BytesPerSector; x += 16) {
          for(y = 0; y < 16; ++y) {
             BYTE ch = buf[x+y];
             if (ch >= ' ' && ch <= '~') {
                printf("  %c", ch);
             } else {
                printf(" %02x", ch);
             }
          }
          printf("\n");
       }
       errorCode = ERROR_SUCCESS;
    }
    __finally {
       if(buf) {
          VirtualFree(buf, 0, MEM_RELEASE);
       }
    }


    return errorCode;

} // ReadSectorViaIoctl


#if 0

DWORD
FixDisk(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Fix the drive layout for the disk.

Arguments:



Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                       status;
    DWORD                       index;
    DWORD                       driveLayoutSize;
    DWORD                       bytesPerTrack;
    DWORD                       bytesPerCylinder;
    PDRIVE_LAYOUT_INFORMATION   driveLayout;
    PPARTITION_INFORMATION      partInfo;
    BOOL                     success;
    BOOL                     reset = FALSE;
    DWORD                       returnLength;
    DISK_GEOMETRY               diskGeometry;
    LARGE_INTEGER               partOffset;
    LARGE_INTEGER               partLength;
    LARGE_INTEGER               partSize;
    LARGE_INTEGER               modulo;

    if (argc > 1)
    {
        printf( "usage: <device> FixDisk [RESET]\n" );
        return ERROR_INVALID_NAME;
    }

    if ( argc != 0 ) {
        if ( !_stricmp( *argv, "reset" ) ) {
            reset = TRUE;
        }
    }

    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                      (sizeof(PARTITION_INFORMATION) * (1 + MAX_PARTITIONS));

    driveLayout = LocalAlloc( LMEM_FIXED, driveLayoutSize );

    if ( !driveLayout ) {
        printf("FixDisk, failed to allocate drive layout info.\n");
        return(ERROR_OUTOFMEMORY);
    }

    //
    // Read the drive capacity to get bytesPerSector and bytesPerCylinder.
    //
    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_GEOMETRY,
                               NULL,
                               0,
                               &diskGeometry,
                               sizeof(DISK_GEOMETRY),
                               &returnLength,
                               FALSE );
    if ( !success ) {
        printf("FixDriveLayout, error reading drive capacity. Error: %u \n",
            status = GetLastError());
        LocalFree( driveLayout );
        return(status);
    }
    printf("FixDriveLayout, bps = %u, spt = %u, tpc = %u.\n",
        diskGeometry.BytesPerSector, diskGeometry.SectorsPerTrack,
        diskGeometry.TracksPerCylinder);

    //
    // If read of the partition table originally failed, then we rebuild
    // it!
    //
    if ( reset ) {
        driveLayout->PartitionCount = MAX_PARTITIONS;
        driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                          (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION));
        driveLayout->Signature = 2196277081;

        bytesPerTrack = diskGeometry.SectorsPerTrack *
                        diskGeometry.BytesPerSector;

        bytesPerCylinder = diskGeometry.TracksPerCylinder *
                           bytesPerTrack;


        partInfo = &driveLayout->PartitionEntry[0];
        partLength.QuadPart = bytesPerCylinder * diskGeometry.Cylinders.QuadPart;

        //
        // The partition offset is 1 track (in bytes).
        // Size is media_size - offset, rounded down to cylinder boundary.
        //
        partOffset.QuadPart = bytesPerTrack;
        partSize.QuadPart = partLength.QuadPart - partOffset.QuadPart;

        modulo.QuadPart = (partOffset.QuadPart + partSize.QuadPart) %
                          bytesPerCylinder;
        partSize.QuadPart -= modulo.QuadPart;

        partInfo = driveLayout->PartitionEntry;

        //
        // Initialize first partition entry.
        //
        partInfo->RewritePartition = TRUE;
        partInfo->PartitionType = PARTITION_IFS;
        partInfo->BootIndicator = FALSE;
        partInfo->StartingOffset.QuadPart = partOffset.QuadPart;
        partInfo->PartitionLength.QuadPart = partSize.QuadPart;
        partInfo->HiddenSectors = 0;
        partInfo->PartitionNumber = 1;

        //
        // For now the remaining partition entries are unused.
        //
        for ( index = 1; index < driveLayout->PartitionCount; index++ ) {
            partInfo = &driveLayout->PartitionEntry[index];
            partInfo->PartitionType = PARTITION_ENTRY_UNUSED;
            partInfo->RewritePartition = TRUE;
            partInfo->BootIndicator = FALSE;
            partInfo->StartingOffset.QuadPart = 0;
            partInfo->PartitionLength.QuadPart = 0;
            partInfo->HiddenSectors = 0;
            partInfo->PartitionNumber = 0;
        }

    } else {
        //
        // For now, the remaining partition entries are unused.
        //
        for ( index = 0; index < driveLayout->PartitionCount; index++ ) {
            partInfo = &driveLayout->PartitionEntry[index];
            partInfo->RewritePartition = TRUE;
            partInfo->PartitionNumber = index+1;
        }
#if 0
        //
        // Recalculate the starting offset for the extended partitions.
        //
        for ( index = 0; index < driveLayout->PartitionCount; index++ ) {
            LARGE_INTEGER   extendedOffset;
            LARGE_INTEGER   bytesPerSector;

            bytesPerSector.QuadPart = diskGeometry.BytesPerSector;
            extendedOffset.QuadPart = 0;

            partInfo = &driveLayout->PartitionEntry[index];
            partInfo->RewritePartition = TRUE;
            if ( IsContainerPartition(partInfo->PartitionType) ) {
                //
                // If this is the first extended partition, then remember
                // the offset to added to the next partition.
                //
                if ( extendedOffset.QuadPart == 0 ) {
                    extendedOffset.QuadPart = bytesPerSector.QuadPart *
                                              (LONGLONG)partInfo->HiddenSectors;
                } else {
                    //
                    // We need to recalculate this extended partition's starting
                    // offset based on the current 'HiddenSectors' field and
                    // the first extended partition's offset.
                    //
                    partInfo->StartingOffset.QuadPart = extendedOffset.QuadPart
                                 + (bytesPerSector.QuadPart *
                                    (LONGLONG)partInfo->HiddenSectors);
                    partInfo->HiddenSectors = 0;
                }
            }
        }
#endif
    }

    //
    // Now set the new partition information.
    //
    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_SET_DRIVE_LAYOUT,
                               driveLayout,
                               driveLayoutSize,
                               NULL,
                               0,
                               &returnLength,
                               FALSE );

    if ( !success ) {
        printf("FixDisk, error setting partition information. Error: %u \n",
            status = GetLastError() );
        LocalFree( driveLayout );
        return(status);
    }

    LocalFree( driveLayout );
    return(ERROR_SUCCESS);

} // FixDisk


static DWORD
FixDriveLayout(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Fix the (broken) disk.

Arguments:



Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                       status;
    DWORD                       index;
    DWORD                       driveLayoutSize;
    DWORD                       bytesPerTrack;
    DWORD                       bytesPerCylinder;
    PDRIVE_LAYOUT_INFORMATION   driveLayout;
    PPARTITION_INFORMATION      partInfo;
    BOOL                     success;
    DWORD                       returnLength;
    DISK_GEOMETRY               diskGeometry;
    LARGE_INTEGER               partOffset;
    LARGE_INTEGER               partLength;
    LARGE_INTEGER               partSize;
    LARGE_INTEGER               modulo;

    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                      (sizeof(PARTITION_INFORMATION) * 2 * MAX_PARTITIONS);

    driveLayout = LocalAlloc( LMEM_FIXED, driveLayoutSize );

    if ( !driveLayout ) {
        printf("FixDriveLayout, failed to allocate drive layout info.\n");
        return(ERROR_OUTOFMEMORY);
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_LAYOUT,
                               NULL,
                               0,
                               driveLayout,
                               driveLayoutSize,
                               &returnLength,
                               FALSE );

    if ( !success ) {
        printf("FixDriveLayout, error getting partition information. Error: %u \n",
            status = GetLastError() );
        LocalFree( driveLayout );
        return(status);
    }

    printf("FixDriveLayout, disk signature is %u, partition count is %u.\n",
        driveLayout->Signature, driveLayout->PartitionCount);

    //
    // Read the drive capacity to get bytesPerSector and bytesPerCylinder.
    //
    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_GEOMETRY,
                               NULL,
                               0,
                               &diskGeometry,
                               sizeof(DISK_GEOMETRY),
                               &returnLength,
                               FALSE );
    if ( !success ) {
        printf("FixDriveLayout, error reading drive capacity. Error: %u \n",
            status = GetLastError());
        LocalFree( driveLayout );
        return(status);
    }
    printf("FixDriveLayout, bps = %u, spt = %u, tpc = %u.\n",
        diskGeometry.BytesPerSector, diskGeometry.SectorsPerTrack,
        diskGeometry.TracksPerCylinder);

    //
    // If read of the partition table originally failed, then we rebuild
    // it!
    //
    if ( !driveLayout->PartitionCount ) {
        driveLayout->PartitionCount = MAX_PARTITIONS;

        bytesPerTrack = diskGeometry.SectorsPerTrack *
                        diskGeometry.BytesPerSector;

        bytesPerCylinder = diskGeometry.TracksPerCylinder *
                           bytesPerTrack;


        partInfo = &driveLayout->PartitionEntry[0];
        partLength.QuadPart = partInfo->PartitionLength.QuadPart;

        //
        // The partition offset is 1 track (in bytes).
        // Size is media_size - offset, rounded down to cylinder boundary.
        //
        partOffset.QuadPart = bytesPerTrack;
        partSize.QuadPart = partLength.QuadPart - partOffset.QuadPart;

        modulo.QuadPart = (partOffset.QuadPart + partSize.QuadPart) %
                          bytesPerCylinder;
        partSize.QuadPart -= modulo.QuadPart;

        partInfo = driveLayout->PartitionEntry;

        //
        // Initialize first partition entry.
        //
        partInfo->RewritePartition = TRUE;
        partInfo->PartitionType = PARTITION_HUGE;
        partInfo->BootIndicator = FALSE;
        partInfo->StartingOffset.QuadPart = partOffset.QuadPart;
        partInfo->PartitionLength.QuadPart = partSize.QuadPart;
        partInfo->HiddenSectors = 0;
        partInfo->PartitionNumber = 0;

        //
        // For now, the remaining partition entries are unused.
        //
        for ( index = 1; index < MAX_PARTITIONS; index++ ) {
            partInfo->RewritePartition = TRUE;
            partInfo->PartitionType = PARTITION_ENTRY_UNUSED;
            partInfo->BootIndicator = FALSE;
            partInfo->StartingOffset.QuadPart = 0;
            partInfo->PartitionLength.QuadPart = 0;
            partInfo->HiddenSectors = 0;
            partInfo->PartitionNumber = 0;
        }

    } else {
        //
        // Recalculate the starting offset for the extended partitions.
        //
        for ( index = 0; index < driveLayout->PartitionCount; index++ ) {
            LARGE_INTEGER   extendedOffset;
            LARGE_INTEGER   bytesPerSector;

            bytesPerSector.QuadPart = diskGeometry.BytesPerSector;
            extendedOffset.QuadPart = 0;

            partInfo = &driveLayout->PartitionEntry[index];
            partInfo->RewritePartition = TRUE;
            if ( IsContainerPartition(partInfo->PartitionType) ) {
                //
                // If this is the first extended partition, then remember
                // the offset to added to the next partition.
                //
                if ( extendedOffset.QuadPart == 0 ) {
                    extendedOffset.QuadPart = bytesPerSector.QuadPart *
                                              (LONGLONG)partInfo->HiddenSectors;
                } else {
                    //
                    // We need to recalculate this extended partition's starting
                    // offset based on the current 'HiddenSectors' field and
                    // the first extended partition's offset.
                    //
                    partInfo->StartingOffset.QuadPart = extendedOffset.QuadPart
                                 + (bytesPerSector.QuadPart *
                                    (LONGLONG)partInfo->HiddenSectors);
                    partInfo->HiddenSectors = 0;
                }
            }
        }
    }
    //
    // Now set the new partition information.
    //
    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_SET_DRIVE_LAYOUT,
                               driveLayout,
                               driveLayoutSize,
                               NULL,
                               0,
                               &returnLength,
                               FALSE );

    if ( !success ) {
        printf("FixDriveLayout, error setting partition information. Error: %u \n",
            status = GetLastError() );
        LocalFree( driveLayout );
        return(status);
    }

    LocalFree( driveLayout );
    return(ERROR_SUCCESS);

} // FixDriveLayout

#endif

static DWORD
GetDriveLetter(
         PUCHAR deviceNameString
         )
{
   UCHAR driveLetter;
   WCHAR deviceName[MAX_PATH];
   NTSTATUS status;
   mbstowcs( deviceName, deviceNameString, strlen(deviceNameString) );
   status = GetAssignedLetter(deviceName, &driveLetter);
   if ( NT_SUCCESS(status) ) {
      if (driveLetter) {
         wprintf(L"%ws ----> %c:\n", deviceName, driveLetter);
      } else {
         wprintf(L"%ws has no drive letter\n", deviceName);
      }
   }
   return RtlNtStatusToDosError( status );
}



NTSTATUS
GetVolumeInformationFromHandle(
   HANDLE Handle
   )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    UCHAR VolumeInfoBuffer[ sizeof(FILE_FS_VOLUME_INFORMATION) + sizeof(WCHAR) * MAX_PATH ];
    UCHAR AttrInfoBuffer[ sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + sizeof(WCHAR) * MAX_PATH ];

    ULONG VolumeInfoLength = sizeof(VolumeInfoBuffer);
    ULONG AttributeInfoLength = sizeof(AttrInfoBuffer);
    PFILE_FS_VOLUME_INFORMATION VolumeInfo = (PFILE_FS_VOLUME_INFORMATION)VolumeInfoBuffer;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)AttrInfoBuffer;

    ZeroMemory(VolumeInfoBuffer, (sizeof(FILE_FS_VOLUME_INFORMATION) + sizeof(WCHAR) * MAX_PATH));
    ZeroMemory(AttrInfoBuffer, (sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + sizeof(WCHAR) * MAX_PATH));

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                VolumeInfo,
                VolumeInfoLength,
                FileFsVolumeInformation
                );
    if ( !NT_SUCCESS(Status) ) {
       return Status;
    }

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                AttributeInfo,
                AttributeInfoLength,
                FileFsAttributeInformation
                );
    if ( !NT_SUCCESS(Status) ) {
       return Status;
    }

    AttributeInfo->FileSystemName[AttributeInfo->FileSystemNameLength] = 0;
    VolumeInfo->VolumeLabel[VolumeInfo->VolumeLabelLength] = 0;

    printf("\nGetVolumeInformationFromHandle data: \n");

    printf("Volume information: \n");
    printf("  VolumeCreationTime           0x%lx : %lx \n",
           VolumeInfo->VolumeCreationTime.HighPart,
           VolumeInfo->VolumeCreationTime.LowPart);
    printf("  VolumeSerialNumber           0x%lx \n", VolumeInfo->VolumeSerialNumber);
    printf("  VolumeLabelLength            0x%lx \n", VolumeInfo->VolumeLabelLength);
    printf("  SupportsObjects (BOOL)       0x%lx \n", VolumeInfo->SupportsObjects);
    printf("  VolumeLabel                  %ws   \n", VolumeInfo->VolumeLabel);

    printf("Attribute Information: \n");
    printf("  FileSystemAttributes (Flags) 0x%lx \n", AttributeInfo->FileSystemAttributes);
    printf("  MaximumComponentNameLength   0x%lx \n", AttributeInfo->MaximumComponentNameLength);
    printf("  FileSystemNameLength         0x%lx \n", AttributeInfo->FileSystemNameLength);
    printf("  FileSystemName               %ws \n\n", AttributeInfo->FileSystemName);

    return STATUS_SUCCESS;
}

#define FIRST_SHOT_SIZE 512
PVOID
DoIoctlAndAllocate(
    IN HANDLE FileHandle,
    IN DWORD  IoControlCode,
    IN PVOID  InBuf,
    IN ULONG  InBufSize,

    OUT PDWORD BytesReturned
    )
{
   UCHAR firstShot[ FIRST_SHOT_SIZE ];

   DWORD status = ERROR_SUCCESS;
   BOOL success;

   DWORD outBufSize;
   PVOID outBuf = 0;
   DWORD bytesReturned;

   success = DeviceIoControl( FileHandle,
                      IoControlCode,
                      InBuf,
                      InBufSize,
                      firstShot,
                      sizeof(firstShot),
                      &bytesReturned,
                      (LPOVERLAPPED) NULL );

   if ( success ) {
      outBufSize = bytesReturned;
      outBuf     = malloc( outBufSize );
      if (!outBuf) {
         status = ERROR_OUTOFMEMORY;
      } else {
         RtlCopyMemory(outBuf, firstShot, outBufSize);
         status = ERROR_SUCCESS;
      }
   } else {
      outBufSize = sizeof(firstShot);
      for(;;) {
         status = GetLastError();
         //
         // If it is not a buffer size related error, then we cannot do much
         //
         if ( status != ERROR_INSUFFICIENT_BUFFER && status != ERROR_MORE_DATA) {
            break;
         }
         //
         // Otherwise, try an outbut buffer twice the previous size
         //
         outBufSize *= 2;
         outBuf = malloc( outBufSize );
         if ( !outBuf ) {
            status = ERROR_OUTOFMEMORY;
            break;
         }

         success = DeviceIoControl( FileHandle,
                                    IoControlCode,
                                    InBuf,
                                    InBufSize,
                                    outBuf,
                                    outBufSize,
                                    &bytesReturned,
                                    (LPOVERLAPPED) NULL );
         if (success) {
            status = ERROR_SUCCESS;
            break;
         }
         free( outBuf );
      }
   }

   if (status != ERROR_SUCCESS) {
      free( outBuf ); // free( 0 ) is legal //
      outBuf = 0;
      bytesReturned = 0;
   }

   SetLastError( status );
   *BytesReturned = bytesReturned;
   return outBuf;
}

#define OUTPUT_BUFFER_LEN (1024)
#define INPUT_BUFFER_LEN  (sizeof(MOUNTMGR_MOUNT_POINT) + 2 * MAX_PATH * sizeof(WCHAR))

static
NTSTATUS
GetAssignedLetterM (
    IN HANDLE MountMgrHandle,
    IN PWCHAR deviceName,
    OUT PCHAR driveLetter )
/*++

Routine Description:

    Get an assigned drive letter from MountMgr, if any

Inputs:
    MountMgrHandle -
    deviceName -
    driveLetter - receives drive letter

Return value:

    STATUS_SUCCESS - on success
    NTSTATUS code  - on failure

--*/

{
   DWORD status = STATUS_SUCCESS;

   PMOUNTMGR_MOUNT_POINT  input  = NULL;
   PMOUNTMGR_MOUNT_POINTS output = NULL;
   PMOUNTMGR_MOUNT_POINT out;

   DWORD len = wcslen( deviceName ) * sizeof(WCHAR);
   DWORD bytesReturned;
   DWORD idx;

   DWORD outputLen;
   DWORD inputLen;

   WCHAR wc;


   inputLen = INPUT_BUFFER_LEN;
   input = LocalAlloc( LPTR, inputLen );

   if ( !input ) {
       goto FnExit;
   }

   input->SymbolicLinkNameOffset = 0;
   input->SymbolicLinkNameLength = 0;
   input->UniqueIdOffset = 0;
   input->UniqueIdLength = 0;
   input->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
   input->DeviceNameLength = (USHORT) len;
   RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                 deviceName, len );
   if (len > sizeof(WCHAR) && deviceName[1] == L'\\') {
       // convert Dos name to NT name
       ((PWCHAR)(input + input->DeviceNameOffset))[1] = L'?';
   }

   outputLen = OUTPUT_BUFFER_LEN;
   output = LocalAlloc( LPTR, outputLen );

   if ( !output ) {
       goto FnExit;
   }

   status = DevfileIoctl(MountMgrHandle, IOCTL_MOUNTMGR_QUERY_POINTS,
                input, inputLen, output, outputLen, &bytesReturned);

   if ( STATUS_BUFFER_OVERFLOW == status ) {

       outputLen = output->Size;
       LocalFree( output );

       output = LocalAlloc( LPTR, outputLen );

       if ( !output ) {
           goto FnExit;
       }

       status = DevfileIoctl(MountMgrHandle, IOCTL_MOUNTMGR_QUERY_POINTS,
                    input, inputLen, output, outputLen, &bytesReturned);
   }

   if ( !NT_SUCCESS(status) ) {
       goto FnExit;
   }

   if (driveLetter) {
       *driveLetter = 0;
   }
   for ( idx = 0; idx < output->NumberOfMountPoints; ++idx ) {
       out = &output->MountPoints[idx];
       if (out->SymbolicLinkNameLength/sizeof(WCHAR) == 14 &&
           (ClRtlStrNICmp((PWCHAR)((PCHAR)output + out->SymbolicLinkNameOffset), L"\\DosDevices\\", 12) == 0) &&
           L':' == *((PCHAR)output + out->SymbolicLinkNameOffset + 13*sizeof(WCHAR)) )
       {
           wc = *((PCHAR)output + out->SymbolicLinkNameOffset + 12*sizeof(WCHAR));
           if (driveLetter && out->UniqueIdLength) {
              *driveLetter = (CHAR)toupper((UCHAR)wc);
              break;
           }
       }
   }

FnExit:

   if ( output ) {
       LocalFree( output );
   }

   if ( input ) {
       LocalFree( input );
   }

   return status;
}


NTSTATUS
GetAssignedLetter (
    PWCHAR deviceName,
    PCHAR driveLetter )
{
   HANDLE MountMgrHandle;
   DWORD status = DevfileOpen( &MountMgrHandle, MOUNTMGR_DEVICE_NAME );

   if (driveLetter) {
      *driveLetter = 0;
   }

   if ( NT_SUCCESS(status) ) {
      status = GetAssignedLetterM(MountMgrHandle, deviceName, driveLetter);
      DevfileClose(MountMgrHandle);
   }

   return status;
}

DWORD
PokeMountMgr (
    VOID
    )
{
   HANDLE MountMgrHandle;
   NTSTATUS ntStatus = DevfileOpen( &MountMgrHandle, MOUNTMGR_DEVICE_NAME );
   DWORD status = ERROR_SUCCESS;

   if ( NT_SUCCESS(ntStatus) ) {
      BOOL success;
      DWORD bytesReturned;
      printf("About to call MOUNTMGR_CHECK_UNPROCESSED_VOLUMES...");
      success = DeviceIoControl( MountMgrHandle,
                                 IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &bytesReturned,
                                 FALSE );
      printf("complete.\n");
      if (!success) {
          status = GetLastError();
      }
      DevfileClose(MountMgrHandle);
   } else {
      status = RtlNtStatusToDosError(ntStatus);
   }

   return status;
}


VOID
PrintError(
    IN DWORD ErrorCode
    )
{
    LPVOID lpMsgBuf;
    ULONG count;

    count = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          ErrorCode,
                          0,
                          (LPTSTR) &lpMsgBuf,
                          0,
                          NULL
                          );

    if (count != 0) {
        printf("  (%d) %s\n", ErrorCode, (LPCTSTR) lpMsgBuf);
        LocalFree( lpMsgBuf );
    } else {
        printf("Format message failed.  Error: %d \n", GetLastError());
    }

}   // PrintError


DWORD
GetSerialNumber(
    HANDLE FileHandle
    )
{
    PSTORAGE_DEVICE_DESCRIPTOR descriptor = NULL;

    PCHAR   sigString;

    DWORD   dwError = NO_ERROR;
    DWORD   descriptorSize;
    DWORD   bytesReturned;

    STORAGE_PROPERTY_QUERY propQuery;

    descriptorSize = sizeof( STORAGE_DEVICE_DESCRIPTOR) + 2048;

    descriptor = LocalAlloc( LPTR, descriptorSize );

    if ( !descriptor ) {
        dwError = GetLastError();
        printf("Unable to allocate output buffer: %d \n", dwError);
        PrintError( dwError );
        goto FnExit;
    }

    ZeroMemory( &propQuery, sizeof( propQuery ) );

    propQuery.PropertyId = StorageDeviceProperty;
    propQuery.QueryType  = PropertyStandardQuery;

    if ( !DeviceIoControl( FileHandle,
                           IOCTL_STORAGE_QUERY_PROPERTY,
                           &propQuery,
                           sizeof(propQuery),
                           descriptor,
                           descriptorSize,
                           &bytesReturned,
                           NULL ) ) {

        dwError = GetLastError();
        printf("IOCTL_STORAGE_QUERY_PROPERTY failed: %d \n", dwError);
        PrintError( dwError );
        goto FnExit;
    }

    if ( !bytesReturned || bytesReturned < sizeof( STORAGE_DEVICE_DESCRIPTOR ) ) {
        printf("Invalid byte length returned: %d \n", bytesReturned);
        goto FnExit;
    }

    //
    // IA64 sometimes returns -1 for SerialNumberOffset.
    //

    if ( 0 == descriptor->SerialNumberOffset ||
         descriptor->SerialNumberOffset > descriptor->Size ) {
        printf("No serial number information available \n");
        goto FnExit;
    }

    //
    // Serial number string is a zero terminated ASCII string.

    //
    // The header ntddstor.h says the for devices with no serial number,
    // the offset will be zero.  This doesn't seem to be true.
    //
    // For devices with no serial number, it looks like a string with a single
    // null character '\0' is returned.
    //

    sigString = (PCHAR)descriptor + (DWORD)descriptor->SerialNumberOffset;

    if ( strlen(sigString) == 0) {
        printf("Serial number: NULL string returned \n");
    } else {
        printf("Serial number: %s \n", sigString);
    }


FnExit:

    if ( descriptor ) {
        LocalFree( descriptor );
    }

    return dwError;

}   // GetSerialNumber


DWORD
UpdateDiskProperties(
    HANDLE fileHandle
    )
/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   bytesReturned;
    BOOL    success;

    if ( INVALID_HANDLE_VALUE == fileHandle ) {
        printf( "usage: <device> UpdateDiskProperties \n" );
        dwError = ERROR_INVALID_NAME;
        goto FnExit;
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_UPDATE_PROPERTIES,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );

    if ( !success ) {
        dwError = GetLastError();
        printf( "IOCTL_DISK_UPDATE_PROPERTIES failed, error %d \n", dwError);
        PrintError( dwError );
        goto FnExit;
    }

    printf("IOCTL_DISK_UPDATE_PROPERTIES succeeded \n");

FnExit:

    return dwError;

}   // UpdateDiskProperties


BOOL
IsDeviceClustered(
    HANDLE Device
    )
/*++

Routine Description:

    Determine if the specified device is on a clustered disk.

Arguments:

    Device - physical disk (partition0) or any disk volume.

Return Value:

    TRUE if disk is clustered.
    FALSE if disk is not clustered, or cannot determine state.

--*/
{
    DWORD   bytesReturned;
    DWORD   dwError;

    BOOL    retValue;

    if ( !DeviceIoControl( Device,
                           IOCTL_VOLUME_IS_CLUSTERED,
                           NULL,
                           0,
                           NULL,
                           0,
                           &bytesReturned,
                           NULL )) {

        dwError = GetLastError();

        printf("IOCTL_VOLUME_IS_CLUSTERED failed (%d) - ", dwError);

        if ( ERROR_INVALID_FUNCTION == dwError ) {
            printf("device is not clustered \n");
        } else if ( ERROR_GEN_FAILURE == dwError ) {
            printf("clustered device is possibly offline \n");
        } else {
            printf("expected error returned \n");
        }
        retValue = FALSE;
    } else {
        printf("IOCTL_VOLUME_IS_CLUSTERED succeeded - device is clustered \n");
        retValue = TRUE;
    }

    return retValue;

}   // IsDeviceClustered


DWORD
GetReserveInfo(
    HANDLE FileHandle
    )
{
    PDRIVE_LAYOUT_INFORMATION   driveLayout = NULL;

    NTSTATUS    ntStatus;

    DWORD       dwError;
    DWORD       bytesReturned;

    HANDLE      hClusDisk0;

    UNICODE_STRING  unicodeName;
    ANSI_STRING     objName;

    OBJECT_ATTRIBUTES       objAttributes;
    IO_STATUS_BLOCK         ioStatusBlock;
    RESERVE_INFO            params;

    BOOL        success;

    //
    // Get the signature.
    //

    success = ClRtlGetDriveLayoutTable( FileHandle, &driveLayout, NULL );

    if ( !success || !driveLayout ) {
        printf(" Unable to read drive layout \n");
        dwError = ERROR_GEN_FAILURE;
        goto FnExit;
    }

    RtlInitString( &objName, DEVICE_CLUSDISK0 );

    ntStatus = RtlAnsiStringToUnicodeString( &unicodeName,
                                             &objName,
                                             TRUE );

    if ( !NT_SUCCESS(ntStatus) ) {

        dwError = RtlNtStatusToDosError(ntStatus);
        printf( "Error converting string to unicode; error was %d \n", dwError);
        PrintError(dwError);
        goto FnExit;
    }

    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtCreateFile( &hClusDisk0,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );

    RtlFreeUnicodeString( &unicodeName );

    if ( !NT_SUCCESS(ntStatus) ) {

        dwError = RtlNtStatusToDosError(ntStatus);
        printf( "Error opening ClusDisk0 device; error was %d \n", dwError);
        PrintError(dwError);
        goto FnExit;
    }

    params.Signature = driveLayout->Signature;

    success = DeviceIoControl( hClusDisk0,
                               IOCTL_DISK_CLUSTER_RESERVE_INFO,
                               &params,
                               sizeof(params),
                               &params,
                               sizeof(params),
                               &bytesReturned,
                               FALSE);
    NtClose( hClusDisk0 );

    if ( !success ) {
        printf( "Error retrieving ReserveInfo; error was %d\n",
                dwError = GetLastError() );
        PrintError(dwError);

    } else {

        printf( "Signature: %08x     ReserveFailure: %08x \n",
                params.Signature,
                params.ReserveFailure );
        printf( "LastReserveEnd: %x:%x     CurrentTime: %x:%x \n",
                params.LastReserveEnd.HighPart,
                params.LastReserveEnd.LowPart,
                params.CurrentTime.HighPart,
                params.CurrentTime.LowPart );

        printf( "*** Last reserve completed %d milliseconds ago *** \n",
                ( params.CurrentTime.QuadPart - params.LastReserveEnd.QuadPart ) / 10000 );

        printf( "ArbWriteCount: %x     ReserveCount: %x \n",
                params.ArbWriteCount,
                params.ReserveCount);
        printf("\n");
        dwError = NO_ERROR;

    }

FnExit:

    LocalFree( driveLayout );

    return dwError;

}   // GetReserveInfo



static void
usage(
      char *programName
      )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    printf( "usage: %s target_device command\n", programName );
    printf( "commands:\n" );
    printf( "\tReset\n" );
    printf( "\tReserve\n" );
    printf( "\tRelease\n" );
    printf( "\tBreakReserve\n" );
    printf( "\tOnline\n" );
    printf( "\tOffline\n" );
    printf( "\tGetState \n");
    printf( "\tCheckUnclaimedPartitions\n" );
    printf( "\tEjectVolumes\n");
    printf( "\tPokeMountMgr\n" );
    printf( "\tEnumMounts\n" );
    printf( "\tEnumExtents\n" );
    printf( "\tEnumNodes\n" );
    printf( "\tEnumDisks\n" );
    printf( "\tGetDiskGeometry\n" );
    printf( "\tGetScsiAddress\n" );
    printf( "\tGetDriveLayout\n" );
    printf( "\tGetDriveLayoutEx\n");
    printf( "\tSetDriveLayout\n" );
    printf( "\tGetPartitionInfo\n" );
    printf( "\tGetVolumeInfo\n" );
    printf( "\tGetDriveLetter\n" );
    printf( "\tGetSerialNumber\n");
    printf( "\tGetReserveInfo\n");
    printf( "\tReadSector\n" );
    printf( "\tReadSectorIoctl\n" );
    printf( "\tTest\n" );
    printf( "\tUpdateDiskProperties\n");
    printf( "\tIsClustered \n");
    printf( "\tCapable\n" );
    printf( "\tAttach       [ClusDisk0 device] \n" );
    printf( "\tDetach       [ClusDisk0 device] \n" );
    printf( "\tStartReserve [ClusDisk0 device] \n" );
    printf( "\tStopReserve  [ClusDisk0 device] \n" );
    printf( "\tActive       [ClusDisk0 device] \n" );
    printf( "\ntarget_device wildcards: \n" );
    printf( "\tAll physical devices: use p* \n" );
    printf( "\tAll logical devices:  use l* or * \n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusexts\clusexts\clusextp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsdextp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>
#include <stdio.h>
#include <stdlib.h>
#include "dbgextp.h"

//prototypes for help functions
void ClusObjHelp(void);
void ResObjHelp(void);
void VersionHelp(void);
void LeaksHelp(void);
void LinkHelp(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusexts\clusexts\leaksext.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    leaksext.c

Abstract:

    dbg extension for use with leaks.dll

Author:

    Charlie Wickham (charlwi) 28-Sep-1998

Revision History:

--*/

#include "clusextp.h"
#include "leaksext.h"

#define FIND_WHITE_SPACE( _ptr_ )                   \
        while ( *_ptr_ != ' ' && *_ptr_ != '\0' )   \
            _ptr_++;

#define SKIP_WHITE_SPACE( _ptr_ )   \
        while ( *_ptr_ == ' ' )     \
            _ptr_++;

#define IS_DWORD_ADDR( _num_ )    !(( (ULONG_PTR)( _num_ )) & 3 )

PCHAR LeaksHandleTypes[] = {
    "Unknown",
    "Event",
    "Registry",
    "Token"
};

DWORD       NumberOfFilters;
ULONG_PTR   FilterAddrs[ 512 ];

BOOL
FilteredAddress(
    ULONG_PTR   Address
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD       numberOfFilters = NumberOfFilters;
    ULONG_PTR * filteredAddr = FilterAddrs;

    while ( numberOfFilters-- ) {
        if ( *filteredAddr == Address ) {
            return TRUE;
        }
        ++filteredAddr;
    }

    return FALSE;
}

VOID
GetSymbolInfo(
    ULONG_PTR   Address,
    LPSTR       Buffer,
    ULONG_PTR * Offset
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    GetSymbol( Address, Buffer, Offset );
    if ( strlen( Buffer ) == 0 ) {
        sprintf(Buffer, "0x%p", Address );
        *Offset = 0;
    }
}

VOID
DumpMemoryInfo(
    BOOL Verbose,
    LPSTR ArgString
    )
{
    DWORD * startingAddr;
    DWORD * endingAddr;
    int     scanResult;
    LPSTR   p;
    DWORD   memBuffer[ 1024 ];  // some pages are not mapped in the middle of the heap
    SIZE_T  bytesRead;
    DWORD   dwordsToRead;
    ULONG   success;
    SIZE_T  bytesToScan;
    DWORD * pDword;
    DWORD * targetAddr;
    PMEM_HDR    memHdr;
    DWORD * filterAddrs[ 512 ];
    DWORD   numberOfFilters = 0;

    //
    // parse args for range
    //
    if ( *ArgString == '\0' ) {
        dprintf("missing args\n");
        return;
    }

    p = ArgString;
    SKIP_WHITE_SPACE( p );

    scanResult = sscanf( p, "%x %x", &startingAddr, &endingAddr );

    if ( scanResult == EOF ) {
        dprintf("missing args\n");
        return;
    }

    if ( scanResult < 2 ) {
        dprintf("can't convert %s to starting address (is it hex?)\n", p);
        return;
    }

    if ( startingAddr >= endingAddr ) {
        dprintf("starting address must be less than ending addr!\n");
        return;
    }

    if ( !IS_DWORD_ADDR( startingAddr ) || !IS_DWORD_ADDR( endingAddr )) {
        dprintf("Use DWORDS for addresses\n");
        return;
    }

    FIND_WHITE_SPACE( p );      // skip over starting addr
    SKIP_WHITE_SPACE( p );
    FIND_WHITE_SPACE( p );      // skip over ending addr
    SKIP_WHITE_SPACE( p );

    //
    // see if any filter args are present
    //
    while ( *p != '\0' ) {
        sscanf( p, "%x", &FilterAddrs[ NumberOfFilters++ ]);
        FIND_WHITE_SPACE( p );
        SKIP_WHITE_SPACE( p );
    }

    //
    // read in hunks of memory looking for our leaks allocator tags
    //
    dwordsToRead = (DWORD)__min(( endingAddr - startingAddr ), ( sizeof( memBuffer ) / sizeof( DWORD )));

    while ( startingAddr < endingAddr ) {
        success = ReadMemory(startingAddr,
                             memBuffer,
                             dwordsToRead * sizeof(DWORD),
                             &bytesRead);

        if ( success ) {

            pDword = memBuffer;
            bytesToScan = bytesRead;
            targetAddr = startingAddr;

            while( bytesToScan > 0 ) {
                CHAR        routineName[ 512 ];
                ULONG_PTR   offset;

                if (*pDword == (DWORD)HEAP_SIGNATURE_ALLOC ) {
                    memHdr = (PMEM_HDR)( pDword - 1 );
                    if ( !FilteredAddress( (ULONG_PTR)memHdr->CallersAddress ) &&
                         !FilteredAddress( (ULONG_PTR)memHdr->CallersCaller )) {

                        dprintf("ALOC @ %p\n", targetAddr - 3 ); // get to beginning of heap data
                        GetSymbolInfo((ULONG_PTR)memHdr->CallersAddress,
                                      routineName,
                                      &offset);

                        dprintf("    Caller:          %s+0x%X (%p)\n",
                                routineName,
                                offset,
                                (ULONG_PTR)memHdr->CallersAddress);

                        if ( memHdr->CallersCaller != NULL ) {
                            GetSymbolInfo((ULONG_PTR) memHdr->CallersCaller, routineName, &offset );
                            dprintf("    Caller's Caller: %s+0x%X (%p)\n",
                                    routineName,
                                    offset,
                                    (ULONG_PTR) memHdr->CallersCaller);
                        }
                    }
                }

                if (Verbose && *pDword == (DWORD)HEAP_SIGNATURE_FREE ) {
                    memHdr = (PMEM_HDR)( targetAddr - 1 );
                    if ( !FilteredAddress( (ULONG_PTR)memHdr->CallersAddress ) &&
                         !FilteredAddress( (ULONG_PTR)memHdr->CallersCaller )) {

                        dprintf("FREE @ %p\n", targetAddr - 3 ); // get to beginning of heap data
                        GetSymbolInfo((ULONG_PTR)memHdr->CallersAddress,
                                      routineName,
                                      &offset);

                        dprintf("    Caller:          %s+0x%X\n", routineName, offset );

                        if ( memHdr->CallersCaller != NULL ) {
                            GetSymbolInfo((ULONG_PTR) memHdr->CallersCaller, routineName, &offset );
                            dprintf("    Caller's Caller: %s+0x%X\n", routineName, offset );
                        }
                    }
                }

                bytesToScan -= sizeof( DWORD );
                ++pDword;
                ++targetAddr;
            }
        } else {
            dprintf("\n\nProblem reading memory @ %08X for %u DWORDS\n\n",
                    startingAddr,
                    dwordsToRead);
        }

        startingAddr = __min( startingAddr + ( sizeof( memBuffer ) / sizeof( DWORD )), endingAddr );
        dwordsToRead = (DWORD)__min(( endingAddr - startingAddr ), ( sizeof( memBuffer ) / sizeof( DWORD )));
    }
}


VOID
DumpHandleInfo(
    BOOL Verbose,
    LPSTR ArgString
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PHANDLE_TABLE       targetHandleTable, hTable;
    HANDLE_TABLE        localHandleTable[ MAX_HANDLE / HANDLE_DELTA ];
    DWORD               i;
    LEAKS_HANDLE_TYPE   handleType;
    CHAR                routineName[ 512 ];

    //
    // determine handle type
    //
    if ( *ArgString == '\0' ) {
        handleType = 0;
    } else if ( _strnicmp( ArgString, "ev", 2 ) == 0 ) {
        handleType = LeaksEvent;
    } else if ( _strnicmp( ArgString, "reg", 3 ) == 0 ) {
        handleType = LeaksRegistry;
    } else if ( _strnicmp( ArgString, "tok", 3 ) == 0 ) {
        handleType = LeaksToken;
    } else {
        dprintf("Unrecognized handle type: event, registry, or token is needed\n");
        return;
    }

    targetHandleTable = (PHANDLE_TABLE)GetExpression( "leaks!HandleTable" );

    if ( !targetHandleTable ) {
        dprintf("Can't convert leaks!HandleTable symbol\n");
        return;
    }

    if ( !ReadMemory(targetHandleTable,
                     localHandleTable,
                     sizeof(localHandleTable),
                     NULL))
    {
        dprintf("Can't read HandleTable data from debug process memory\n");
        return;
    }

    i = MAX_HANDLE / HANDLE_DELTA;
    hTable = localHandleTable;

    for ( i = 0; i < MAX_HANDLE / HANDLE_DELTA; ++ i ) {
        ULONG_PTR offset;

        //
        // if caller is non-null, then our stuff is tracking this handle
        // AND
        //     we're in verbose AND
        //         the handle type is not specified OR
        //         the handle type is one we're interested in
        //     OR
        //     we're not in verbose and the handle is in use AND
        //         the handle type is not specified OR
        //         the handle type is one we're interested in
        // then we print it out.
        //
        if (hTable[i].Caller != NULL
            &&
            (
             ( Verbose
               &&
               ( handleType == 0
                 ||
                 hTable[i].HandleType == handleType
               )
             )
             ||
             ( hTable[i].InUse
               &&
               ( handleType == 0
                 ||
                 hTable[i].HandleType == handleType
               )
             )
            )
           )
        {
            GetSymbolInfo((ULONG_PTR)hTable[i].Caller,
                          routineName,
                          &offset);

            dprintf("Handle %3X: %s %s\n",
                    i * HANDLE_DELTA,
                    hTable[i].InUse ? "IN USE" : "FREE",
                    LeaksHandleTypes[ hTable[i].HandleType ]);

            dprintf("    Caller:          %s+0x%X\n", routineName, offset );

            if ( hTable[i].CallersCaller != NULL ) {
                GetSymbolInfo((ULONG_PTR) hTable[i].CallersCaller, routineName, &offset );
                dprintf("    Caller's Caller: %s+0x%X\n", routineName, offset );
            }
        }

        if (CheckControlC()) {
            break;
        }
    }
}

DECLARE_API( leaks )

/*++

Routine Description:

    dump the appropriate info collected by leaks.dll

Arguments:

    usual

Return Value:

    None

--*/

{
    LPSTR               p = NULL;
    VOID                (* function)( BOOL, LPSTR ) = NULL;
    BOOL                verbose = FALSE;

    INIT_API();

    //
    // get args
    //
    p = lpArgumentString;
    while ( *p ) {

        if ( *p == '-' ) {
            p++;

            switch ( *p ) {
            case 'h':
            case 'H':
                function = DumpHandleInfo;
                break;

            case 'm':
            case 'M':
                function = DumpMemoryInfo;
                break;

            case 'v':
            case 'V':
                verbose = TRUE;
                break;

            default:
                dprintf( "clusexts: !leaks invalid option flag '-%c'\n", *p );
                break;
            }
        } else {
            break;
        }

        //
        // skip to end of arg then to end of white space
        //
        FIND_WHITE_SPACE( p );
        SKIP_WHITE_SPACE( p );
    }

    if ( function == NULL ) {
        dprintf("clusexts: -h [-v] [event, reg, token]\n");
        return;
    }

    (*function)( verbose, p );
}


VOID
LeaksHelp(
    VOID
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    dprintf("!leaks -h [-v] [event, reg, token] : dump handle info out of leaks.dll\n");
    dprintf("!leaks -m [-v] startaddr endaddr   : dump memory allocation info out of leaks.dll\n");
}

/* end leaksext.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusexts\clusexts\dbgextp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsdextp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#define move(dst, src)\
try {\
    ReadMemory((LPVOID) (src), &(dst), sizeof(dst), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}
#define moveBlock(dst, src, size)\
try {\
    ReadMemory((LPVOID) (src), &(dst), (size), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

CHAR igrepLastPattern[256];
DWORD igrepSearchStartAddress;
DWORD igrepLastPc;

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PNTSD_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disassm                 (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )

#ifndef malloc
#define malloc( n ) HeapAlloc( GetProcessHeap(), 0, (n) )
#endif
#ifndef free
#define free( p ) HeapFree( GetProcessHeap(), 0, (p) )
#endif

extern NTSD_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusexts\clusexts\leaksext.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    leaksext.h

Abstract:

    header for leaks.dll extension

Author:

    Charlie Wickham (charlwi) 28-Sep-1998

Revision History:

--*/

#include <leaks.h>

/* end leaksext.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusexts\clusexts\omextp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    omextp.h

Abstract:

    Private header for cluster object manager debugger extensions.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#include <clusapi.h>
#include <service.h>
#include "..\service\nm\nmp.h"

#define OBJECT_TYPE_RESOURCE    "Resource"
#define OBJECT_TYPE_RESOURCE_TYPE "ResourceType"
#define OBJECT_TYPE_GROUP       "Group"
#define OBJECT_TYPE_NODE        "Node"
#define OBJECT_TYPE_NETWORK     "Network"
#define OBJECT_TYPE_NETINTERFACE "NetInterface"
#define OBJECT_TYPE_CLUSTER     "Cluster"
#define OBJECT_TYPE_UNKNOWN     "UNKNOWN"

#define RESOURCE_STATE_ONLINE   "Online"
#define RESOURCE_STATE_OFFLINE  "Offline"
#define RESOURCE_STATE_FAILED   "Failed"
#define RESOURCE_STATE_ONLINE_PENDING   "OnlinePending"
#define RESOURCE_STATE_OFFLINE_PENDING  "OfflinePending"

#define GROUP_STATE_PARTIAL_ONLINE "PartialOnline"

#define NODE_STATE_UNKNOWN   "Unknown"
#define NODE_STATE_UP        "Up"
#define NODE_STATE_DOWN      "Down"
#define NODE_STATE_PAUSED    "Paused"    
#define NODE_STATE_JOINING   "Joining"


void DumpClusObjList(
    IN PVOID AddrObjTypeTable,
    IN OBJECT_TYPE ObjType, 
    IN BOOL Verbose
    );


void
DumpClusObjAtAddr(
    IN PVOID Body
    );

PLIST_ENTRY
DumpClusObj(
    IN POM_HEADER pOmHeader,
    IN PVOID   Body,
    IN OBJECT_TYPE ObjectType,
    IN BOOL    Verbose
    );


VOID
DumpObject(
    IN OBJECT_TYPE    ObjectType,
    IN PVOID          Body
    );

VOID
DumpResourceObject(
    IN PVOID Body
    );

VOID
DumpResourceTypeObject(
    IN PVOID Body
    );

VOID
DumpGroupObject(
    IN PVOID Body
    );

VOID
DumpNodeObject(
    IN PVOID Body
    );

#if OM_TRACE_REF
void
DumpDeadObjList(
    PVOID AddrDeadList
    );

PLIST_ENTRY
DumpDeadListObj(
    IN POM_HEADER pOmHeader
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusexts\clusexts\proplist.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    proplist.c

Abstract:

    dump a cluster property list

Author:

    Charlie Wickham (charlwi) 13-Jun-2001

Revision History:

--*/

#include "clusextp.h"
#include <clusapi.h>

PCHAR TypeNames[] = {
    "UNKNOWN",
    "ENDMARK",
    "LIST_VALUE",
    "RESCLASS",
    "RESERVED1",
    "NAME",
    "SIGNATURE",
    "SCSI_ADDRESS",
    "DISK_NUMBER",
    "PARTITION_INFO",
    "FTSET_INFO",
    "DISK_SERIALNUMBER"
};

//
// Cluster Control Property Data - Formats (a WORD)
//
PCHAR FormatNames[] = {
    "UNKNOWN",
    "BINARY",
    "DWORD",
    "SZ",
    "EXPAND_SZ",
    "MULTI_SZ",
    "ULARGE_INTEGER",
    "LONG",
    "EXPANDED_SZ",
    "SECURITY_DESCRIPTOR",
    "LARGE_INTEGER",
    "WORD",
};

VOID
DumpPropertyName(
    PWCHAR  dbgPName,
    DWORD   ByteLength
    )
{
    PWCHAR  nameBuf;
    BOOL    success;

    nameBuf = LocalAlloc( LMEM_FIXED, ByteLength );
    if ( nameBuf ) {

        success = ReadMemory(dbgPName,
                             nameBuf,
                             ByteLength,
                             NULL);
        if ( success ) {
            dprintf( "Name: %ws\n", nameBuf );
        } else {
            dprintf( "Name: failed to readmemory @ %p \n", dbgPName);
        }
        
        LocalFree( nameBuf );
    } else {
        dprintf("clusexts: can't allocate buffer for property name\n");
    }
} // DumpPropertyName

VOID
DumpMultiSz(
    PWCHAR  MultiSz,
    DWORD   ByteLength
    )
{
    DWORD   count = 1;

    while ( *MultiSz != UNICODE_NULL ) {
        dprintf("%d:\"%ws\"\n", count++, MultiSz );
        MultiSz += ( wcslen( MultiSz ) + 1 );
    }
} // DumpMultiSz

VOID
DumpBytes(
    PUCHAR  Bytes,
    DWORD   ByteLength
    )
{
    DWORD   bytesThisLine;
    DWORD   byteCount;
    PUCHAR  bytes;

    while ( ByteLength > 0 ) {
        bytesThisLine = ByteLength < 16 ? ByteLength : 16;
        byteCount = bytesThisLine;
        bytes = Bytes;

        while ( byteCount-- ) {
            dprintf("%02X", *bytes++ );
            if ( ( bytesThisLine - 8 ) == byteCount ) {
                dprintf( "-" );
            } else {
                dprintf( " " );
            }
        }

        byteCount = 16 - bytesThisLine;
        while ( byteCount-- ) {
            dprintf("   ");
        }

        dprintf(" ");

        byteCount = bytesThisLine;
        bytes = Bytes;
        while ( byteCount-- ) {
            if ( isprint( *bytes )) {
                dprintf("%c", *bytes );
            } else {
                dprintf(".");
            }
            ++bytes;
        }

        dprintf("\n");

        Bytes += bytesThisLine;
        ByteLength -= bytesThisLine;
    }

} // DumpBytes


DECLARE_API( proplist )

/*++

Routine Description:

    This function is called as an NTSD extension to display a cluster property
    list

Arguments:

    address in memory of start of proplist

Return Value:

    None.

--*/

{
    CLUSPROP_VALUE  propValue;

    PCHAR   dbgAddr;
    PCHAR   addrArg;
    BOOL    success;
    DWORD   propCount;
    BOOL    verbose = FALSE;
    PCHAR   buffer = NULL;
    DWORD   bufferSize = 0;

    INIT_API();

    //get the arguments
    if ( _strnicmp( lpArgumentString, "-v", 2 ) == 0 ) {
        verbose = TRUE;
        addrArg = lpArgumentString + 2;
        while ( *++addrArg == ' ' ) ;
    } else {
        addrArg = lpArgumentString;
    }

    dbgAddr = (PVOID)GetExpression( addrArg );
    if ( !dbgAddr ) 
    {
        dprintf( "clusexts: !proplist failed to resolve %s\n", addrArg);
        return;
    }

    success = ReadMemory(dbgAddr,
                         &propCount,
                         sizeof(DWORD),
                         NULL);
    if ( !success ) 
    {
        dprintf( "clusexts: !proplist failed to readmemory @ %p \n", dbgAddr);
        return;
    }

    dprintf( "Number of properties: %u\n", propCount );
    dbgAddr += sizeof( DWORD );

    while ( propCount-- ) {

        success = ReadMemory(dbgAddr,
                             &propValue,
                             sizeof(CLUSPROP_VALUE),
                             NULL);
        if ( !success ) {
            dprintf( "clusexts: !proplist failed to readmemory @ %p \n", dbgAddr);
            return;
        }

        if ( verbose ) {
            dprintf("Prop Type: ");
            if (propValue.Syntax.wType == CLUSPROP_TYPE_USER ) {
                dprintf("USER\t");
            } else if ( propValue.Syntax.wType <= CLUSPROP_TYPE_DISK_SERIALNUMBER ) {
                dprintf("%s\t", TypeNames[ propValue.Syntax.wType + 1 ]);
            } else {
                dprintf("%d\t", propValue.Syntax.wType );
            }

            dprintf("Format: ");
            if ( propValue.Syntax.wFormat == CLUSPROP_FORMAT_USER ) {
                dprintf("USER\t");
            } else if ( propValue.Syntax.wFormat <= CLUSPROP_FORMAT_WORD ) {
                dprintf("%s\t", FormatNames[ propValue.Syntax.wFormat ]);
            } else {
                dprintf("%d\t", propValue.Syntax.wFormat );
            }

            dprintf("Length: %u\n", propValue.cbLength);
        }

        dbgAddr += sizeof( CLUSPROP_VALUE );
        DumpPropertyName( (PWCHAR)dbgAddr, propValue.cbLength );

        dbgAddr += ALIGN_CLUSPROP( propValue.cbLength );

        //
        // a name property can have one or more value properties. cycle
        // through them until we find an endmark to signify the beginning of a
        // new name property.
        do {
            //
            // read the clusprop value for the data
            //
            success = ReadMemory(dbgAddr,
                                 &propValue,
                                 sizeof(CLUSPROP_VALUE),
                                 NULL);
            if ( !success ) {
                dprintf( "clusexts: !proplist failed to readmemory @ %p \n", dbgAddr);
                return;
            }

            //
            // found an endmark instead of another list; skip over the endmark
            // and bail out of the list dump loop.
            //
            if ( propValue.Syntax.dw == CLUSPROP_SYNTAX_ENDMARK ) {
                dbgAddr += sizeof( CLUSPROP_SYNTAX_ENDMARK );
                break;
            }

            if ( verbose ) {
                dprintf("Prop Type: ");
                if (propValue.Syntax.wType == CLUSPROP_TYPE_USER ) {
                    dprintf("USER\t");
                } else if ( propValue.Syntax.wType <= CLUSPROP_TYPE_DISK_SERIALNUMBER ) {
                    dprintf("%s\t", TypeNames[ propValue.Syntax.wType + 1 ]);
                } else {
                    dprintf("%d\t", propValue.Syntax.wType );
                }
            }

            dprintf("Format: ");
            if ( propValue.Syntax.wFormat == CLUSPROP_FORMAT_USER ) {
                dprintf("USER\t");
            } else if ( propValue.Syntax.wFormat <= CLUSPROP_FORMAT_WORD ) {
                dprintf("%s\t", FormatNames[ propValue.Syntax.wFormat ]);
            } else {
                dprintf("%d\t", propValue.Syntax.wFormat );
            }

            dprintf("Length: %u\n", propValue.cbLength);

            dbgAddr += sizeof( CLUSPROP_VALUE );

            if ( propValue.cbLength > 0 ) {
                //
                // allocate mem for the data and read it in
                //
                if ( bufferSize < propValue.cbLength ) {
                    if ( buffer ) {
                        LocalFree( buffer );
                        buffer = NULL;
                    }

                    buffer = LocalAlloc(LMEM_FIXED, propValue.cbLength );
                    if ( buffer ) {
                        bufferSize = propValue.cbLength;
                    }
                }

                if ( buffer ) {
                    success = ReadMemory(dbgAddr,
                                         buffer,
                                         propValue.cbLength,
                                         NULL);
                    if ( !success ) {
                        dprintf( "clusexts: !proplist failed to readmemory @ %p \n", dbgAddr);
                        return;
                    }

                    switch ( propValue.Syntax.wFormat ) {
                    case CLUSPROP_FORMAT_UNKNOWN:
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_USER:
                        DumpBytes( buffer, propValue.cbLength );
                        break;

                    case CLUSPROP_FORMAT_LONG:
                        dprintf("%d (0x%08X)\n", *(PLONG)buffer, *(PLONG)buffer );
                        break;

                    case CLUSPROP_FORMAT_DWORD:
                        dprintf("%u (0x%08X)\n", *(PDWORD)buffer, *(PDWORD)buffer );
                        break;

                    case CLUSPROP_FORMAT_SZ:
                    case CLUSPROP_FORMAT_EXPAND_SZ:
                    case CLUSPROP_FORMAT_EXPANDED_SZ:
                        dprintf("\"%ws\"\n", buffer );
                        break;

                    case CLUSPROP_FORMAT_MULTI_SZ:
                        DumpMultiSz( (PWCHAR)buffer, propValue.cbLength );
                        break;

                    case CLUSPROP_FORMAT_ULARGE_INTEGER:
                        dprintf("%I64u (0x%16I64X)\n",
                                ((PULARGE_INTEGER)buffer)->QuadPart,
                                ((PULARGE_INTEGER)buffer)->QuadPart);
                        break;

                    case CLUSPROP_FORMAT_LARGE_INTEGER:
                        dprintf("%I64d (0x%16I64X)\n",
                                ((PLARGE_INTEGER)buffer)->QuadPart,
                                ((PLARGE_INTEGER)buffer)->QuadPart);
                        break;

                    case CLUSPROP_FORMAT_SECURITY_DESCRIPTOR:
                        //                    DumpSecDesc( buffer, propValue.cbLength );
                        break;

                    case CLUSPROP_FORMAT_WORD:
                        dprintf( "%hu (%04hX)\n", *(PWORD)buffer, *(PWORD)buffer );
                        break;
                    }
                } else {
                    dprintf("clusexts: Can't allocate buffer for data\n");
                }
            }

            dbgAddr += ALIGN_CLUSPROP( propValue.cbLength );

        } while ( TRUE );

        dprintf( "\n" );
    }

    if ( buffer ) {
        LocalFree( buffer );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusexts\clusexts\resext.c ===
#include "clusextp.h"
#include "resextp.h"

LPSTR ObjectName[] = {
    OBJECT_TYPE_BUCKET,
    OBJECT_TYPE_RESOURCE
};


DECLARE_API( resobj )

/*++

Routine Description:

    This function is called as an NTSD extension to display all
    resource object in the target resrcmon process.

Arguments:


Return Value:

    None.

--*/

{
    RES_OBJ_TYPE ObjType,i;
    BOOL        Verbose;
    BOOL        DumpAll=TRUE;
    LPSTR       p;
    PVOID       ObjToDump;
    PVOID       RmpEventListHead;

    INIT_API();

    //get the arguments
    Verbose = FALSE;
    p = lpArgumentString;
    while ( p != NULL && *p ) {
        if ( *p == '-' ) {
            p++;
            switch ( *p ) {
                case 'b':
                case 'B':
                    ObjType = ResObjectTypeBucket;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'r':
                case 'R':
                    ObjType = ResObjectTypeResource;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'v':
                case 'V':
                    Verbose = TRUE;
                    break;

                case 'h':
                case 'H':
                    ResObjHelp();
                    return;

                case ' ':
                    goto gotBlank;

                default:
                    dprintf( "clusexts: !resobj invalid option flag '-%c'\n", *p );
                    break;

                }
            }
        else if (*p != ' ') {
            sscanf(p,"%lx",&ObjToDump);
            p = strpbrk( p, " " );
            }
        else {
gotBlank:
            p++;
            }
        }

    //
    // Locate the address of the list head.
    //

    RmpEventListHead = (PVOID)GetExpression("&resrcmon!RmpEventListHead");
    if ( !RmpEventListHead ) 
    {
        dprintf( "clusexts: !resobj failed to get RmpEventListHead\n");
        return;
    }

    dprintf( "\n" );

    if (DumpAll)
    {
        for (i=0; i<ResObjectTypeMax; i++)
            ResDumpResObjList(RmpEventListHead, i, Verbose);
    }
    else
    {
        ResDumpResObjList(RmpEventListHead, ObjType, Verbose);
    }    

    dprintf( "\n" );

    return;
}

void
ResDumpResObjList(
    PVOID RmpEventListHead,
    RES_OBJ_TYPE ObjType, 
    BOOL Verbose
    )
{
    BOOL            b;
    LIST_ENTRY      ListHead;
    PLIST_ENTRY     Next;
    POLL_EVENT_LIST PollList;
    PUCHAR          ObjectType;
    DWORD           Count = 0;
    PPOLL_EVENT_LIST pPollList;

    //
    // Read the list head
    //

    b = ReadMemory(
            RmpEventListHead,
            &ListHead,
            sizeof(LIST_ENTRY),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !resobj failed to readmemory for ListHead\n");
        return;
    }

    Next = ListHead.Flink;

    ObjectType = ObjectName[ObjType];

    //
    // Walk the list of poll event lists
    //
    while ( Next != RmpEventListHead ) 
    {
        pPollList = CONTAINING_RECORD( Next,
                                       POLL_EVENT_LIST,
                                       Next );
        b = ReadMemory( pPollList,
                        &PollList,
                        sizeof(POLL_EVENT_LIST),
                        NULL
                      );
        if ( !b ) 
        {
            dprintf( "clusexts: !resobj read poll list entry failed\n");
            return;
        }

        dprintf( "\nDumping %s Objects for list entry %d (%lx)\n\n",
                 ObjectType, ++Count, Next );

        Next = ResDumpResObj(&PollList,
                             pPollList,
                             ObjType,
                             Verbose);
        if (Next == NULL) 
            break;

        if ((CheckControlC)()) 
            break;

     }
}



void
ResObjHelp()
{
    dprintf("!resobj -[r|g|n|x] -v : Dump the resource monitor objects\n");
    dprintf("!resobj : Dumps all objects\n");
    dprintf("  -r : Dump the resource objects\n");
    dprintf("  -l : Dump the event list objects\n");
    dprintf("  -v : Dump the object in verbose mode\n");

}


PLIST_ENTRY
ResDumpResObj(
    IN PVOID        Object,
    IN PVOID        ObjectAddress,
    IN RES_OBJ_TYPE ObjectType,
    IN BOOL         Verbose
    )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the contents of the specified cluster object.

Arguments:


Return Value:

    Pointer to the next critical section in the list for the process or
    NULL if no more critical sections.

--*/

{
    MONITOR_BUCKET Bucket;
    LIST_ENTRY  ListEntry;
    PLIST_ENTRY Next;
    PPOLL_EVENT_LIST pObject = ObjectAddress;
    PPOLL_EVENT_LIST object = Object;
    LPDWORD     lpDword = (LPDWORD)Object;
    BOOL        b;
    DWORD       i;
    PMONITOR_BUCKET pBucket;

    b = ReadMemory(
            (LPVOID)&(pObject->BucketListHead),
            &ListEntry,
            sizeof(LIST_ENTRY),
            NULL
            );
    if (!b) {
        goto FnExit;
    }

    dprintf(
        "Lock Address = %lx, Owning thread = %lx\n",
        &(pObject->ListLock),
        object->ListLock.OwningThread );

    dprintf(
        "Lock History:    Acquires                Releases\n"
        "           -------------------       -------------------\n" );
    dprintf(
        "          %3.2u    %3.2lx    %6.5u      %3.2u    %3.2lx    %6.5u\n",
        object->PPrevPrevListLock.Module,
        object->PPrevPrevListLock.ThreadId,
        object->PPrevPrevListLock.LineNumber,
        object->LastListUnlock.Module,
        object->LastListUnlock.ThreadId,
        object->LastListUnlock.LineNumber );

    dprintf(
        "          %3.2u    %3.2lx    %6.5u      %3.2u    %3.2lx    %6.5u\n",
        object->PrevPrevListLock.Module,
        object->PrevPrevListLock.ThreadId,
        object->PrevPrevListLock.LineNumber,
        object->PrevListUnlock.Module,
        object->PrevListUnlock.ThreadId,
        object->PrevListUnlock.LineNumber );

    dprintf(
        "          %3.2u    %3.2lx    %6.5u      %3.2u    %3.2lx    %6.5u\n",
        object->PrevListLock.Module,
        object->PrevListLock.ThreadId,
        object->PrevListLock.LineNumber,
        object->PrevPrevListUnlock.Module,
        object->PrevPrevListUnlock.ThreadId,
        object->PrevPrevListUnlock.LineNumber );

    dprintf(
        "          %3.2u    %3.2lx    %6.5u      %3.2u    %3.2lx    %6.5u\n",
        object->LastListLock.Module,
        object->LastListLock.ThreadId,
        object->LastListLock.LineNumber,
        object->PPrevPrevListUnlock.Module,
        object->PPrevPrevListUnlock.ThreadId,
        object->PPrevPrevListUnlock.LineNumber );

    dprintf( "\n" );

    switch ( ObjectType ) {

    case ResObjectTypeBucket:
        dprintf( "    BucketListHead = %lx\n", &(pObject->BucketListHead) );
        dprintf( "    NumberOfBuckets = %u\n", object->NumberOfBuckets );
        break;

    case ResObjectTypeResource:

        dprintf( "ResourceCount = %u, EventCount = %u\n",
            object->NumberOfResources,
            object->EventCount );

        if ( Verbose ) {
            for ( i = 1; i <= object->EventCount; i++ ) {
                dprintf("EventHandle[%u] = %lx\n", i, object->Handle[i-1] );
            }
            dprintf("\n");
            for ( i = 1; i <= object->EventCount; i++ ) {
                if ( object->Resource[i] != 0 ) {
                    dprintf( "    Resource %u address = %lx\n", i, object->Resource[i-1] );
                }
            }
        }
        break;

    default:
        break;

    }

    Next = ListEntry.Flink;
    i = 0;

    //
    // Now follow the list of buckets.
    //
    while ( Next != &(pObject->BucketListHead) ) {
        pBucket = CONTAINING_RECORD( Next,
                                     MONITOR_BUCKET,
                                     BucketList );
        b = ReadMemory( (LPVOID)pBucket,
                        &Bucket,
                        sizeof(MONITOR_BUCKET),
                        NULL );
        if ( !b ) 
        {
            dprintf( "clusexts: !resobj read bucket failed\n");
            goto FnExit;
        }

        if ( Verbose ||
             (ObjectType == ResObjectTypeBucket) ) {
            ResDumpObject( ObjectType,
                           &Bucket,
                           pBucket );
        }

        Next = Bucket.BucketList.Flink;
    }

FnExit:
    return (object->Next.Flink);

    return NULL;
}



VOID
ResDumpObject(
    IN RES_OBJ_TYPE    ObjectType,
    IN PMONITOR_BUCKET Bucket,
    IN PVOID           ObjectAddress
    )

/*++

Routine Description:

    Dump information specific to the given object.

Arguments:

    ObjectType - the type of object to dump.

    Object - the adress for the body of the object.

Return Value:

    None.

--*/

{

    switch ( ObjectType ) {

    case ResObjectTypeResource:
        ResDumpResourceObjects( Bucket, ObjectAddress );
        break;

    case ResObjectTypeBucket:
        ResDumpBucketObject( Bucket, ObjectAddress );
        break;

    default:
        break;

    }

    return;

} // ResDumpObject



VOID
ResDumpResourceObjects(
    IN PMONITOR_BUCKET Bucket,
    IN PVOID           ObjectAddress
    )

/*++

Routine Description:

    Dump information about a list of resources in a bucket.

Arguments:

    Object - pointer to the resource object to dump.

Return Value:

    None.

--*/

{
    RESOURCE    Resource;
    PMONITOR_BUCKET bucket = ObjectAddress;
    BOOL        b;
    LIST_ENTRY  ListEntry;
    PLIST_ENTRY Next;
    PRESOURCE   pResource;

    b = ReadMemory(
            (LPVOID)&(bucket->ResourceList),
            &ListEntry,
            sizeof(LIST_ENTRY),
            NULL
            );
    if (!b) {
        dprintf( "clusexts: !resobj failed to bucket resource list\n");
        return;
    }

    Next = ListEntry.Flink;

    while ( Next != &(bucket->ResourceList) ) {
        pResource = CONTAINING_RECORD( Next,
                                       RESOURCE,
                                       ListEntry );

        b = ReadMemory( pResource,
                        &Resource,
                        sizeof(RESOURCE),
                        NULL
                      );
        if ( !b ) 
        {
            dprintf( "clusexts: !resobj read resource failed\n");
            return;
        }

        dprintf( "    Resource Address = %lx\n", pResource );
        ResDumpResourceInfo( &Resource,
                             pResource );

        Next = Resource.ListEntry.Flink;
    }

    return;

} // ResDumpResourceObject


VOID
ResDumpResourceInfo(
    IN PRESOURCE    Resource,
    IN PVOID        ObjectAddress
    )

/*++

Routine Description:

    Dump information about a resource.

Arguments:

    Object - pointer to the resource object to dump.

Return Value:

    None.

--*/

{
    PUCHAR      State;
    PRESOURCE   pResource = ObjectAddress;
    WCHAR       DllName[MAX_PATH];
    WCHAR       ResourceName[MAX_PATH];
    WCHAR       ResourceType[MAX_PATH];
    BOOL        b;

    //
    // Get the resource's current state.
    //
    switch ( Resource->State ) {
    case ClusterResourceOnline: 
        State = RESOURCE_STATE_ONLINE;
        break;

    case ClusterResourceOffline: 
        State = RESOURCE_STATE_OFFLINE;
        break;

    case ClusterResourceFailed:
        State = RESOURCE_STATE_FAILED;
        break;

    case ClusterResourceOnlinePending: 
        State = RESOURCE_STATE_ONLINE_PENDING;
        break;

    case ClusterResourceOfflinePending: 
        State = RESOURCE_STATE_OFFLINE_PENDING;
        break;

    default:
        State = OBJECT_TYPE_UNKNOWN;
        break;
    }


    b = ReadMemory(
            Resource->ResourceName,
            ResourceName,
            sizeof(ResourceName),
            NULL
            );
    if ( !b )  {
        dprintf( "clusexts: !resobj failed to readmemory for resource name\n");
        return;
    }

    b = ReadMemory(
            Resource->ResourceType,
            ResourceType,
            sizeof(ResourceType),
            NULL
            );
    if ( !b )  {
        dprintf( "clusexts: !resobj failed to readmemory for resource type\n");
        return;
    }

    b = ReadMemory(
            Resource->DllName,
            DllName,
            sizeof(DllName),
            NULL
            );
    if ( !b )  {
        dprintf( "clusexts: !resobj failed to readmemory for dll name\n");
        return;
    }

    dprintf( "    ResourceName = %ws\n", ResourceName );
    dprintf( "    ResourceType = %ws\n", ResourceType );
    dprintf( "    DllName = %ws\n", DllName );
    dprintf( "    Id = %lx, State = %s, EventHandle = %lx, OnlineHandle = %lx\n",
            Resource->Id, State, Resource->EventHandle, Resource->OnlineEvent );
    dprintf( "    TimerEvent = %lx, PendingTimeout = %u, %sArbitrated\n",
            Resource->TimerEvent, Resource->PendingTimeout,
            (Resource->IsArbitrated ? "" : "NOT ") );

    dprintf( "\n" );

    return;

} // ResDumpResourceObject



VOID
ResDumpBucketObject(
    IN PMONITOR_BUCKET Bucket,
    IN PVOID           ObjectAddress
    )

/*++

Routine Description:

    Dump information about a resource type.

Arguments:

    Body - pointer to the resource object to dump.

Return Value:

    None.

--*/

{
    LARGE_INTEGER DueTime;
    RESOURCE    Resource;
    PMONITOR_BUCKET bucket = ObjectAddress;
    BOOL        b;
    LIST_ENTRY  ListEntry;
    PLIST_ENTRY Next;
    DWORD       i = 0;
    PRESOURCE   pResource;

    DueTime.QuadPart = Bucket->DueTime;

    b = ReadMemory(
            (LPVOID)&(bucket->ResourceList),
            &ListEntry,
            sizeof(LIST_ENTRY),
            NULL
            );
    if (!b) {
        dprintf( "clusexts: !resobj failed to bucket resource list\n");
        return;
    }

    Next = ListEntry.Flink;

    while ( Next != &(bucket->ResourceList) ) {
        pResource = CONTAINING_RECORD( Next,
                                       RESOURCE,
                                       ListEntry );

        b = ReadMemory( pResource,
                        &Resource,
                        sizeof(RESOURCE),
                        NULL
                      );
        if ( !b ) 
        {
            dprintf( "clusexts: !resobj read resource failed\n");
            return;
        }

        ++i;
        Next = Resource.ListEntry.Flink;
    }

    dprintf( "    Address = %lx, DueTime = %lx%lx, %u resources\n", bucket, DueTime.HighPart, DueTime.LowPart, i );

    return;

} // ResDumpBucketObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusexts\clusexts\omext.c ===
#include "clusextp.h"
#include "omextp.h"


DECLARE_API( clusobj )

/*++

Routine Description:

    This function is called as an NTSD extension to display all
    critical sections in the target process.

Arguments:


Return Value:

    None.

--*/

{
    OBJECT_TYPE ObjType = ObjectTypeMax;
    OBJECT_TYPE i;
    BOOL        Verbose;
    BOOL        DumpAll=TRUE;
    LPSTR       p = NULL;
    PVOID       ObjToDump = NULL;
    PVOID       AddrObjTypeTable;
    PVOID       AddrDeadList;
    BOOL        DumpDeadList = FALSE;
    
    INIT_API();

    //get the arguments
    Verbose = FALSE;
    p = lpArgumentString;
    while ( p != NULL && *p ) {
        if ( *p == '-' ) {
            p++;
            switch ( *p ) {
                case 't':
                case 'T':
                    ObjType = ObjectTypeResType;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'r':
                case 'R':
                    ObjType = ObjectTypeResource;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'g':
                case 'G':
                    ObjType = ObjectTypeGroup;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'n':
                case 'N':
                    ObjType = ObjectTypeNode;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'x':
                case 'X':
                    ObjType = ObjectTypeNetwork;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'i':
                case 'I':
                    ObjType = ObjectTypeNetInterface;
                    p++;
                    DumpAll = FALSE;
                    break;
#if OM_TRACE_REF
                case 'd':
                case 'D':
                    p++;
                    DumpDeadList = TRUE;
                    break;
#endif

                case 'v':
                case 'V':
                    Verbose = TRUE;
                    break;

                case 'h':
                case 'H':
                    ClusObjHelp();
                    return;

                case 'o':
                case 'O':
                    ObjType = ObjectTypeMax;
                    p++;
                    break;
                    
                case ' ':
                    goto gotBlank;

                default:
                    dprintf( "clusexts: !clusobj invalid option flag '-%c'\n", *p );
                    break;

                }
            }
        else if (*p != ' ') {
            sscanf(p,"%lx",&ObjToDump);
            p = strpbrk( p, " " );
            }
        else {
gotBlank:
            p++;
            }
        }

#if OM_TRACE_REF
    if (DumpDeadList)
    {
        AddrDeadList = (PVOID)GetExpression("&clussvc!gDeadListHead");
        if ( !AddrDeadList ) 
        {
            dprintf( "clusexts: !clusobj failed to addres of gDeadListHead\n");
            return;
        }

        DumpDeadObjList(AddrDeadList);
    }
    else 
#endif    
    {
        //if the object type is zero, then an address must be specified
        if (ObjType == ObjectTypeMax)
        {
            if (!ObjToDump)
                dprintf( "clusexts: need to specify an address with the -o option\n");
            else
                DumpClusObjAtAddr(ObjToDump);
            return;                
        }
        //
        // Locate the address of the list head.
        //

        AddrObjTypeTable = (PVOID)GetExpression("&clussvc!OmpObjectTypeTable");
        if ( !AddrObjTypeTable ) 
        {
            dprintf( "clusexts: !clusobj failed to get OmpObjectTypeTable\n");
            return;
        }

        if (DumpAll)
        {
            for (i=ObjectTypeResource; i<ObjectTypeMax; i++)
                DumpClusObjList(AddrObjTypeTable, i, Verbose);
        }
        else
        {
            DumpClusObjList(AddrObjTypeTable, ObjType, Verbose);
        }    
    }
    dprintf( "\n" );

    return;
}

void
DumpClusObjList(
    PVOID AddrObjTypeTable,
    OBJECT_TYPE ObjType, 
    BOOL Verbose)
{
    BOOL            b;
    OM_OBJECT_TYPE  OmObjType;
    POM_OBJECT_TYPE pOmObjType;
    OM_HEADER       OmHeader;
    LIST_ENTRY      ListHead;
    PLIST_ENTRY     Next;
    PUCHAR          ObjectType;

    //
    // Read the object_type header
    //

    b = ReadMemory(
            (LPVOID)((LPBYTE)AddrObjTypeTable + (sizeof(POM_OBJECT_TYPE) * ObjType)),
            &pOmObjType,
            sizeof(POM_OBJECT_TYPE),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for pom_object_type\n");
        return;
    }


    b = ReadMemory(
            (LPVOID)(pOmObjType),
            &OmObjType,
            sizeof(OM_OBJECT_TYPE),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for om_object_type\n");
        return;
    }

    Next = OmObjType.ListHead.Flink;

    switch ( OmObjType.Type ) {
    case ObjectTypeResource:
        ObjectType = OBJECT_TYPE_RESOURCE;
        break;

    case ObjectTypeResType:
        ObjectType = OBJECT_TYPE_RESOURCE_TYPE;
        break;

    case ObjectTypeGroup:
        ObjectType = OBJECT_TYPE_GROUP;
        break;

    case ObjectTypeNode:
        ObjectType = OBJECT_TYPE_NODE;
        break;

    case ObjectTypeNetwork:
        ObjectType = OBJECT_TYPE_NETWORK;
        break;

    case ObjectTypeNetInterface:
        ObjectType = OBJECT_TYPE_NETINTERFACE;
        break;

    case ObjectTypeCluster:
        ObjectType = OBJECT_TYPE_CLUSTER;
        break;

    default:
        ObjectType = OBJECT_TYPE_UNKNOWN;
        break;
    }

    dprintf( "\n***** Dumping %s Objects *****\n", ObjectType);

    if ( OmObjType.Type == ObjectTypeResource ) {
        PVOID       blockingQuorum;
        DWORD       blockingQuorumCount;
        PVOID       quoLockAddr;
        RTL_RESOURCE quoLock;
    
        blockingQuorum = (PVOID)GetExpression("&clussvc!gdwQuoBlockingResources");
        b = ReadMemory(
            (LPVOID)(blockingQuorum),
            &blockingQuorumCount,
            sizeof(DWORD),
            NULL
        );
        if (!b) {
            dprintf("Failed to read gdwQuoBlockingResources\n");
            goto SkipPrint;
        }

        quoLockAddr = (PVOID)GetExpression("&clussvc!gQuoLock");
        b = ReadMemory(
            (LPVOID)(quoLockAddr),
            &quoLock,
            sizeof(RTL_RESOURCE),
            NULL
            );
        if (!b) {
            goto SkipPrint;
        }
        dprintf("\nResources Blocking Quorum = %d\n",
                blockingQuorumCount );
        if ( quoLock.CriticalSection.OwningThread != NULL ) {
            dprintf("Global Quorum Lock critical section owned by %lx\n",
                    quoLock.CriticalSection.OwningThread );
        }
        dprintf("Quorum Lock shared semaphore = %lx, exclusive semaphore = %lx\n",
                quoLock.SharedSemaphore, quoLock.ExclusiveSemaphore );
        if ( quoLock.NumberOfWaitingShared ||
             quoLock.NumberOfWaitingExclusive ) {
            dprintf("Quorum Lock shared waiters = %d, exclusive waiters = %d\n",
                quoLock.NumberOfWaitingShared, quoLock.NumberOfWaitingExclusive );
        }
        if ( quoLock.NumberOfActive == 0 ) {
            dprintf("Quorum Lock is unowned\n");
        } else if ( quoLock.NumberOfActive < 0 ) {
            dprintf("Quorum Lock is owned exclusive by %lx, count = %d\n",
                quoLock.ExclusiveOwnerThread, 0-quoLock.NumberOfActive);
        } else {
            dprintf("Quorum Lock is owned shared, count = %d\n",
                quoLock.NumberOfActive);
        }
        dprintf("\n");
    }
SkipPrint:

    if ( Verbose ) {
        dprintf( "\nRefCnt Address  ObjId                            Name\n\n");
    } else {
        dprintf( "\nRefCnt ObjId                            Name\n\n");
    }

    //
    // Walk the list of cluster objects
    // this assumes that the list head is the first field in
    // OM_OBJECT_TYPE structure
    //
    while ( Next != (PLIST_ENTRY)pOmObjType ) 
    {

        b = ReadMemory( (LPVOID)CONTAINING_RECORD( Next,
                                                   OM_HEADER,
                                                   ListEntry
                                                 ),
                        &OmHeader,
                        sizeof(OM_HEADER),
                        NULL
                      );
        if ( !b ) 
        {
            dprintf( "clusexts: !clusobj read obj header failed, error=%u\n",
                GetLastError());
            return;
        }

        Next = DumpClusObj(&OmHeader,
                           &(((POM_HEADER)Next)->Body),
                           OmObjType.Type,
                           Verbose);
        if (Next == NULL) 
            break;

        if ((CheckControlC)()) 
            break;

     }
}

#if OM_TRACE_REF
void
DumpDeadObjList(
    PVOID AddrDeadList
    )
/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the objects on dead list for the cluster object manager.

Arguments:
    AddrDeadList - pointer to the gDeadListHead.

Return Value:

--*/
{
    BOOL            b;
    LIST_ENTRY      ListHead;
    OM_HEADER       OmHeader;
    PLIST_ENTRY     Next;

    //
    // Read the object_type header
    //

    b = ReadMemory(
            (LPVOID)((LPBYTE)AddrDeadList),
            &ListHead,
            sizeof(LIST_ENTRY),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for deadlist\n");
        return;
    }


    Next = ListHead.Flink;

    //
    // Walk the list of cluster objects
    // this assumes that the list head is the first field in
    // OM_OBJECT_TYPE structure
    //
    while ( Next != (PLIST_ENTRY)AddrDeadList ) 
    {

        b = ReadMemory( (LPVOID)CONTAINING_RECORD( Next,
                                                   OM_HEADER,
                                                   DeadListEntry
                                                 ),
                        &OmHeader,
                        sizeof(OM_HEADER),
                        NULL
                      );
        if ( !b ) 
        {
            dprintf( "clusexts: !clusobj read obj header failed\n");
            return;
        }

        Next = DumpDeadListObj(&OmHeader);
        
        if (Next == NULL) 
            break;

        if ((CheckControlC)()) 
            break;

     }
}



PLIST_ENTRY
DumpDeadListObj(
    IN POM_HEADER pOmHeader
    )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the contents of an object on the dead list for the cluster object 
    manager.

Arguments:


Return Value:

    Pointer to the next object in the deadlist of om objects.

--*/

{
    WCHAR       Name[32];
    WCHAR       Id[128];
    BOOLEAN     b;
    
    b = ReadMemory(
        (LPVOID)(pOmHeader->Name),
        Name,
        sizeof(Name),
        NULL
        );
    if (!b)
    {
        goto FnExit;
    }
    b = ReadMemory(
        (LPVOID)(pOmHeader->Id),
        Id,
        sizeof(Id),
        NULL
        );
    if (!b)
    {
        goto FnExit;
    }

    dprintf(
        "%3.3ld    %-8.8lx %-32.32ws %-32.32ws\n",
        pOmHeader->RefCount,
        &(pOmHeader->Body),
        Id,
        Name
        );

FnExit:
    return (pOmHeader->DeadListEntry.Flink);
}

#endif
    
void ClusObjHelp()
{
    dprintf("!clusobj -[r|g|n|x] -v : Dump the cluster objects\n");
    dprintf("!clusobj : Dumps all objects\n");
    dprintf("  -r : Dump the resource objects\n");
    dprintf("  -g : Dump the group objects\n");
    dprintf("  -n : Dump the node objects\n");
    dprintf("  -x : Dump the network objects\n");
    dprintf("  -i : Dump the network interface objects\n");
    dprintf("  -v : Dump the object in verbose mode\n");
    dprintf("  -o addr : Dump the objects at address\n");
    dprintf("  -d : Dump the objects on the deadlist(objs whose refcount is not zero!)\n");
    

}

void
DumpClusObjAtAddr(PVOID Body)
{
    POM_HEADER      pOmHeader = NULL;
    BOOL            b;
    OM_HEADER       OmHeader;
    
    dprintf("clusexts : Dumping object at address %lx\n",
        Body);
    
    pOmHeader = OmpObjectToHeader(Body);

    b = ReadMemory( pOmHeader,
                    &OmHeader,
                    sizeof(OM_HEADER),
                    NULL
                  );
    if ( !b ) 
    {
        dprintf("DumpClusObjAtAddr: !clusobj read obj header failed, error=%u\n",
            GetLastError());
        return;
    }

    DumpClusObj(&OmHeader, Body, ObjectTypeMax, TRUE);

}

PLIST_ENTRY
DumpClusObj(
    IN POM_HEADER pOmHeader,
    IN PVOID      Body,
    IN OBJECT_TYPE ObjectType,
    IN BOOL       Verbose
    )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the contents of the specified cluster object.

Arguments:


Return Value:

    Pointer to the next critical section in the list for the process or
    NULL if no more critical sections.

--*/

{
    WCHAR       Name[64];
    WCHAR       Id[37]; //guids are 16(32 characters) byte values + 4 dashes + 1 null
    BOOL        b;
    PLIST_ENTRY pNextEntry = NULL;
    DWORD       dwLength=sizeof(Name);
    DWORD       dwRetryCount;

    dwRetryCount = 6;        
    dwLength=sizeof(Id);
ReadId:
    b = ReadMemory(
        (LPVOID)(pOmHeader->Id),
        Id,
        dwLength,
        NULL
        );
    if (!b)
    {
        //since we dont know the length of the id, we may not be able to
        //read the given size
        //retry with a smaller length
        if (GetLastError() == ERROR_NOACCESS)
        {
            if (dwRetryCount)
            {
                dwLength = dwLength/2;
                dwRetryCount--;
                goto ReadId;
            }                
        }
        //if there is another error, exit now
        dwRetryCount = 0;
    }

    if (!dwRetryCount)
    {
        //unsuccessful in reading id
        dprintf(
            "DumpClusObj: Readmemory failed to read  pOmHeader->Id %u\n",
            GetLastError()
            );
        goto FnExit;
    }
    else
    {
        //the id may be partially read
        //null terminate it
        Id[((dwLength)/sizeof(WCHAR))-1]=L'\0';
    }

    dwRetryCount = 6;
    dwLength=sizeof(Name);
ReadName:
    b = ReadMemory(
        (LPVOID)(pOmHeader->Name),
        Name,
        dwLength,
        NULL
        );
    if (!b)
    {
        //since we dont know the length of the name, we may not be able to
        //read the given size
        //retry with a smaller length
        if (GetLastError() == ERROR_NOACCESS)
        {
            if (dwRetryCount)
            {
                dwLength = dwLength/2;
                dwRetryCount--;
                goto ReadName;
            }                
        }
        //if there is another error, exit now
        dwRetryCount = 0;
        
    }

    if (!dwRetryCount)
    {
        //unsuccessful in reading name
        dprintf(
            "DumpClusObj: Readmemory failed to read  pOmHeader->Name %u\n",
            GetLastError()
            );
        goto FnExit;
    }
    else
    {
        //the name may be partially read
        //null terminate it
        Name[((dwLength)/sizeof(WCHAR))-1]=L'\0';
    }
    
    if ( Verbose ) {
        dprintf(
            "%3.3ld    %-8.8lx %-32.32ws %-32.32ws\n",
            pOmHeader->RefCount,
            Body,
            Id,
            Name
            );
        if (ObjectType == ObjectTypeMax)
        {
            OM_OBJECT_TYPE OmObjectType;
            
            //use the type specified in the header
            b = ReadMemory(
                (LPVOID)(pOmHeader->ObjectType),
                &OmObjectType,
                sizeof(OM_OBJECT_TYPE),
                NULL
                );
            if (!b)
            {
                dprintf(
                    "DumpClusObj: Readmemory failed to read  pOmHeader->ObjectType,err=%u\n",
                    GetLastError()
                    );
                goto FnExit;
            }
            ObjectType = OmObjectType.Type;            
        }
        DumpObject( ObjectType, Body );
    } else {
        dprintf(
            "%3.3ld    %-32.32ws %-32.32ws\n",
            pOmHeader->RefCount,
            Id,
            Name
            );
    }

    pNextEntry = pOmHeader->ListEntry.Flink;
FnExit:
    return (pNextEntry);
}




VOID
DumpObject(
    IN OBJECT_TYPE    ObjectType,
    IN PVOID          Body
    )

/*++

Routine Description:

    Dump information specific to the given object.

Arguments:

    ObjectType - the type of object to dump.

    Body - the adress for the body of the object.

Return Value:

    None.

--*/

{

    switch ( ObjectType ) {

    case ObjectTypeResource:
        DumpResourceObject( Body );
        break;

    case ObjectTypeGroup:
        DumpGroupObject( Body );
        break;

    case ObjectTypeResType:
        DumpResourceTypeObject( Body );
        break;

    case ObjectTypeNode:
        DumpNodeObject( Body );
        break;
        
    default:
        break;

    }

    return;

} // DumpObject



VOID
DumpResourceObject(
    IN PVOID Body
    )

/*++

Routine Description:

    Dump information about a resource.

Arguments:

    Body - pointer to the resource object to dump.

Return Value:

    None.

--*/

{
    FM_RESOURCE Resource;
    PFM_RESOURCE pResource = Body;
    BOOL        b;
    PUCHAR      State;
    PUCHAR      PersistentState;
    DWORD       PossibleOwners = 0;
    LIST_ENTRY  ListEntry;

    b = ReadMemory(
            Body,
            &Resource,
            sizeof(FM_RESOURCE),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for resource object\n");
        return;
    }

    //
    // Get the resource's current state.
    //
    switch ( Resource.State ) {
    case ClusterResourceOnline: 
        State = RESOURCE_STATE_ONLINE;
        break;

    case ClusterResourceOffline: 
        State = RESOURCE_STATE_OFFLINE;
        break;

    case ClusterResourceFailed:
        State = RESOURCE_STATE_FAILED;
        break;

    case ClusterResourceOnlinePending: 
        State = RESOURCE_STATE_ONLINE_PENDING;
        break;

    case ClusterResourceOfflinePending: 
        State = RESOURCE_STATE_OFFLINE_PENDING;
        break;

    default:
        State = OBJECT_TYPE_UNKNOWN;
        break;
    }

    //
    // Get the resource's persistent state.
    //
    switch ( Resource.PersistentState ) {
    case ClusterResourceOnline: 
        PersistentState = RESOURCE_STATE_ONLINE;
        break;

    case ClusterResourceOffline: 
        PersistentState = RESOURCE_STATE_OFFLINE;
        break;

    case ClusterResourceFailed:
        PersistentState = RESOURCE_STATE_FAILED;
        break;

    case ClusterResourceOnlinePending: 
        PersistentState = RESOURCE_STATE_ONLINE_PENDING;
        break;

    case ClusterResourceOfflinePending: 
        PersistentState = RESOURCE_STATE_OFFLINE_PENDING;
        break;

    default:
        PersistentState = OBJECT_TYPE_UNKNOWN;
        break;
    }

    b = ReadMemory(
            (LPVOID)&(pResource->PossibleOwners),
            &ListEntry,
            sizeof(LIST_ENTRY),
            NULL
            );
    if ( !b )  {
        dprintf( "clusexts: !clusobj failed to readmemory for resource list entry\n");
        return;
    }

    while ( (PVOID)&(pResource->PossibleOwners) != (PVOID)(ListEntry.Flink) ) {
        PossibleOwners++;
        b = ReadMemory(
                (LPVOID)(ListEntry.Flink),
                &ListEntry,
                sizeof(LIST_ENTRY),
                NULL
                );
        if ( !b )  {
            dprintf( "clusexts: !clusobj failed to readmemory for resource list entry\n");
            return;
        }
    }

    dprintf(
        "%s State, %sQuroum Resource, Group %lx, %s PersistentState\n",
        State,
        Resource.QuorumResource ? "" : "NOT ",
        Resource.Group,
        PersistentState );
    dprintf(
        "DependOn %lx, ProvideFor %lx, (%u)PossibleOwners %lx, Contains %lx\n",
        &(pResource->DependsOn),
        &(pResource->ProvidesFor),
        PossibleOwners,
        &(pResource->PossibleOwners),
        &(pResource->ContainsLinkage) );
    dprintf( "%s\n",
        Resource.BlockingQuorum ? "Blocking Quorum " : "");

    dprintf( "\n" );

    return;

} // DumpResourceObject



VOID
DumpResourceTypeObject(
    IN PVOID Body
    )

/*++

Routine Description:

    Dump information about a resource type.

Arguments:

    Body - pointer to the resource object to dump.

Return Value:

    None.

--*/

{
    FM_RESTYPE ResType;
    BOOL       b;
    WCHAR      DllName[64];

    b = ReadMemory(
            Body,
            &ResType,
            sizeof(FM_RESTYPE),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for resource type object\n");
        return;
    }

    b = ReadMemory(
            ResType.DllName,
            DllName,
            sizeof(DllName),
            NULL );

    if ( b ) {
        dprintf(
            "DllName = %ws\n\n",
            DllName );
    }

    return;

} // DumpResourceObject


VOID
DumpGroupObject(
    IN PVOID Body
    )

/*++

Routine Description:

    Dump information about a group.

Arguments:

    Body - pointer to the group object to dump.

Return Value:

    None.

--*/

{
    FM_GROUP    Group;
    PFM_GROUP   pGroup = Body;
    BOOL        b;
    PUCHAR      State;
    PUCHAR      PersistentState;
    DWORD       i;
    DWORD       lockIndex;
    LOCK_INFO   lockInfo;
    DWORD       unlockIndex;
    LOCK_INFO   unlockInfo;

    b = ReadMemory(
            Body,
            &Group,
            sizeof(FM_GROUP),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for group object\n");
        return;
    }

    //
    // Get the group's current state.
    //
    switch ( Group.State ) {
    case ClusterGroupOnline: 
        State = RESOURCE_STATE_ONLINE;
        break;

    case ClusterGroupOffline: 
        State = RESOURCE_STATE_OFFLINE;
        break;

    case ClusterGroupFailed:
        State = RESOURCE_STATE_FAILED;
        break;

    case ClusterGroupPartialOnline: 
        State = GROUP_STATE_PARTIAL_ONLINE;
        break;

    default:
        State = OBJECT_TYPE_UNKNOWN;
        break;
    }

    //
    // Get the group's persistent state.
    //
    switch ( Group.PersistentState ) {
    case ClusterGroupOnline: 
        PersistentState = RESOURCE_STATE_ONLINE;
        break;

    case ClusterGroupOffline: 
        PersistentState = RESOURCE_STATE_OFFLINE;
        break;

    case ClusterGroupFailed:
        PersistentState = RESOURCE_STATE_FAILED;
        break;

    case ClusterGroupPartialOnline: 
        PersistentState = GROUP_STATE_PARTIAL_ONLINE;
        break;

    default:
        PersistentState = OBJECT_TYPE_UNKNOWN;
        break;
    }

    dprintf(
        "%s State, %s PermState, OrderOwners %u, OwnNode %lx, %s Moving\n",
        State,
        PersistentState,
        Group.OrderedOwners,
        Group.OwnerNode,
        Group.MovingList ? "" : "NOT" );
    dprintf(
        "Contains %lx, PreferredOwners %lx, FailbackType %u, Failures %u\n",
        &(pGroup->Contains),
        &(pGroup->PreferredOwners),
        Group.FailbackType,
        Group.NumberOfFailures );

    dprintf(
        "Lock Address = %lx, Owning thread = %lx, MovingList = %lx\n",
        &(pGroup->Lock),
        Group.Lock.OwningThread,
        Group.MovingList );
    dprintf(
        "Lock History:    Acquires                Releases\n" );
    dprintf(
        "           -------------------       -------------------\n" );
    lockIndex = Group.LockIndex;
    unlockIndex = Group.UnlockIndex;
    for ( i = 0; i < FM_MAX_LOCK_ENTRIES; i++ ) {
      lockInfo = Group.LockTable[lockIndex++];
      unlockInfo = Group.UnlockTable[unlockIndex++];

      lockIndex &= (FM_MAX_LOCK_ENTRIES - 1);
      unlockIndex &= (FM_MAX_LOCK_ENTRIES - 1);
      dprintf(
        "          %3.2u    %3.2lx    %6.5u      %3.2u    %3.2lx    %6.5u\n",
        lockInfo.Module,
        lockInfo.ThreadId,
        lockInfo.LineNumber,
        unlockInfo.Module,
        unlockInfo.ThreadId,
        unlockInfo.LineNumber );
    }

    dprintf( "\n" );

    return;

} // DumpResourceObject


VOID
DumpNodeObject(
    IN PVOID Body
    )
/*++

Routine Description:

    Dump information about a node.

Arguments:

    Body - pointer to the node object to dump.

Return Value:

    None.

--*/

{
    NM_NODE     Node;
    PNM_NODE    pNode=Body;
    BOOL        b;
    PUCHAR      State;

    b = ReadMemory(
            Body,
            &Node,
            sizeof(NM_NODE),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for group object\n");
        return;
    }

    if (Node.State == (UCHAR)ClusterNodeStateUnknown)
    {
        dprintf(
            "State NODE_STATE_UNKNOWN\n");
    }
    else if (Node.State == ClusterNodeUp)
    {
        dprintf(
            "State NODE_STATE_UP\n");
    }
    else if (Node.State == ClusterNodeDown)
    {
        dprintf(
            "State NODE_STATE_DOWN\n");
    }
    else if (Node.State == ClusterNodePaused)
    {
        dprintf(
            "State NODE_STATE_PAUSED\n");
    }
    else if (Node.State == ClusterNodeJoining)
    {
        dprintf(
            "State NODE_STATE_JOINING\n");
    }
    else
    {
        dprintf( 
            "State %u\n",
            Node.State);                
    }

    dprintf(
        "Flags 0x%08lx\n",
        Node.Flags);

    dprintf(
        "InterfaceCount %u  InterfaceList %lx\n",
        Node.InterfaceCount, &(pNode->InterfaceList));

    dprintf(
        "NodeHighestVersion 0x%08lx  NodeLowestVersion 0x%08lx\n",
        Node.HighestVersion, Node.LowestVersion);

    dprintf( "\n" );
    dprintf( "\n" );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusexts\leaks\leaks.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    leaks.h

Abstract:

    header for leak filter dll

Author:

    Charlie Wickham (charlwi) 28-Sep-1998

Environment:

    User Mode

Revision History:

--*/

//
// keep a table of caller and caller's caller for open handles. indexed by
// handle value divided by 4.  !leaks in clusexts will display this info.
//

typedef enum _LEAKS_HANDLE_TYPE {
    LeaksEvent = 1,
    LeaksRegistry,
    LeaksToken
} LEAKS_HANDLE_TYPE;


typedef struct _HANDLE_TABLE {
    PVOID Caller;
    PVOID CallersCaller;
    LEAKS_HANDLE_TYPE HandleType;
    BOOL InUse;
} HANDLE_TABLE, *PHANDLE_TABLE;

#define MAX_HANDLE      4096
#define HANDLE_DELTA    4
#define HINDEX( _h )    (((DWORD_PTR) _h ) / HANDLE_DELTA )

#define SetHandleTable( _h, _inuse, _htype )                        \
    {                                                               \
        RtlGetCallersAddress(&callersAddress,                       \
                             &callersCaller );                      \
        HandleTable[ HINDEX( _h )].InUse = _inuse;                  \
        HandleTable[ HINDEX( _h )].HandleType = _htype;             \
        HandleTable[ HINDEX( _h )].Caller = callersAddress;         \
        HandleTable[ HINDEX( _h )].CallersCaller = callersCaller;   \
    }

//
// leaks memory header. This structure is at the front of the allocated area
// and the area behind it is returned to the caller. PlaceHolder holds the
// heap free list pointer. Signature holds ALOC or FREE.
//

#define HEAP_SIGNATURE_ALLOC 'COLA'
#define HEAP_SIGNATURE_FREE 'EERF'

typedef struct _MEM_HDR {
    PVOID   PlaceHolder;
    DWORD   Signature;
    PVOID   CallersAddress;
    PVOID   CallersCaller;
} MEM_HDR, *PMEM_HDR;

/* end leaks.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusexts\clusexts\resextp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    resextp.h

Abstract:

    Private header for resmon object debugger extensions.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#include <clusapi.h>
#include <resmonp.h>

#define OBJECT_TYPE_BUCKET      "Poll Bucket"
#define OBJECT_TYPE_RESOURCE    "Resource"
#define OBJECT_TYPE_UNKNOWN     "UNKNOWN"

#define RESOURCE_STATE_ONLINE   "Online"
#define RESOURCE_STATE_OFFLINE  "Offline"
#define RESOURCE_STATE_FAILED   "Failed"
#define RESOURCE_STATE_ONLINE_PENDING   "OnlinePending"
#define RESOURCE_STATE_OFFLINE_PENDING  "OfflinePending"


typedef enum _ResObjectType {
    ResObjectTypeBucket = 0,
    ResObjectTypeResource = 1,
    ResObjectTypeMax = 2
} RES_OBJ_TYPE;


void
ResDumpResObjList(
    IN PVOID RmpEventListHead,
    IN RES_OBJ_TYPE ObjType, 
    IN BOOL Verbose
    );


PLIST_ENTRY
ResDumpResObj(
    IN PVOID        Object,
    IN PVOID        ObjectAddress,
    IN RES_OBJ_TYPE ObjectType,
    IN BOOL         Verbose
    );

VOID
ResDumpObject(
    IN RES_OBJ_TYPE    ObjectType,
    IN PMONITOR_BUCKET Bucket,
    IN PVOID           ObjectAddress
    );

VOID
ResDumpBucketObject(
    IN PMONITOR_BUCKET Bucket,
    IN PVOID           ObjectAddress
    );

VOID
ResDumpResourceObjects(
    IN PMONITOR_BUCKET Bucket,
    IN PVOID           ObjectAddress
    );

VOID
ResDumpResourceInfo(
    IN PRESOURCE    Resource,
    IN PVOID        ObjectAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusexts\leaks\leaks.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    leaks.c

Abstract:

    A filter DLL for trying to detect memory, event, registry, and
    token handle leaks.

Author:

    Charlie Wickham/Rod Gamache

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _ADVAPI32_
#define _KERNEL32_
#include <windows.h>
#include <stdio.h>

#include "clusrtl.h"
#include "leaks.h"

HINSTANCE Kernel32Handle;
HINSTANCE Advapi32Handle;

FARPROC SystemLocalAlloc;
FARPROC SystemLocalFree;

FARPROC SystemCreateEventA;
FARPROC SystemCreateEventW;

FARPROC SystemRegOpenKeyA;
FARPROC SystemRegOpenKeyW;
FARPROC SystemRegOpenKeyExA;
FARPROC SystemRegOpenKeyExW;
FARPROC SystemRegCreateKeyA;
FARPROC SystemRegCreateKeyW;
FARPROC SystemRegCreateKeyExA;
FARPROC SystemRegCreateKeyExW;
FARPROC SystemRegCloseKey;

FARPROC SystemOpenProcessToken;
FARPROC SystemOpenThreadToken;
FARPROC SystemDuplicateToken;
FARPROC SystemDuplicateTokenEx;

FARPROC SystemCloseHandle;

#define SetSystemPointer( _h, _n ) \
    System##_n = GetProcAddress( _h, #_n );

BOOL LeaksVerbose = FALSE;

HANDLE_TABLE HandleTable[ MAX_HANDLE / HANDLE_DELTA ];


BOOLEAN
WINAPI
LeaksDllEntry(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
/*++

Routine Description:

    Main DLL entrypoint

Arguments:

    DllHandle - Supplies the DLL handle.

    Reason - Supplies the call reason

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(DllHandle);
        ClRtlInitialize( TRUE, NULL );

        //
        // get pointers to the real functions
        //

        Kernel32Handle = LoadLibrary( "kernel32.dll" );
        Advapi32Handle = LoadLibrary( "advapi32.dll" );

        SetSystemPointer( Kernel32Handle, LocalAlloc );
        SetSystemPointer( Kernel32Handle, LocalFree );

        SetSystemPointer( Kernel32Handle, CreateEventA );
        SetSystemPointer( Kernel32Handle, CreateEventW );

        SetSystemPointer( Advapi32Handle, RegOpenKeyA );
        SetSystemPointer( Advapi32Handle, RegOpenKeyW );
        SetSystemPointer( Advapi32Handle, RegOpenKeyExA );
        SetSystemPointer( Advapi32Handle, RegOpenKeyExW );
        SetSystemPointer( Advapi32Handle, RegCreateKeyA );
        SetSystemPointer( Advapi32Handle, RegCreateKeyW );
        SetSystemPointer( Advapi32Handle, RegCreateKeyExA );
        SetSystemPointer( Advapi32Handle, RegCreateKeyExW );
        SetSystemPointer( Advapi32Handle, RegCloseKey );

        SetSystemPointer( Advapi32Handle, OpenProcessToken );
        SetSystemPointer( Advapi32Handle, OpenThreadToken );
        SetSystemPointer( Advapi32Handle, DuplicateToken );
        SetSystemPointer( Advapi32Handle, DuplicateTokenEx );

        SetSystemPointer( Kernel32Handle, CloseHandle );
    }

    return(TRUE);
}

HLOCAL
WINAPI
LEAKS_LocalAlloc(
    UINT    uFlags,
    SIZE_T  uBytes
    )
{
    HLOCAL  memory;
    PMEM_HDR memHdr;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );


    memHdr = (PVOID)(*SystemLocalAlloc)( uFlags, uBytes + sizeof(MEM_HDR) );
    if ( !memHdr ) {
        return NULL;
    }

    memHdr->Signature = HEAP_SIGNATURE_ALLOC;
    memHdr->CallersAddress = callersAddress;
    memHdr->CallersCaller = callersCaller;

    return(memHdr+1);
}

HLOCAL
WINAPI
LEAKS_LocalFree(
    HLOCAL  hMem
    )
{
    PMEM_HDR memHdr = hMem;
    PVOID   callersAddress;
    PVOID   callersCaller;
    CHAR    buf[128];

    if ( memHdr ) {
        --memHdr;
        if ( memHdr->Signature == HEAP_SIGNATURE_FREE ) {

            sprintf( buf, "Freeing %p a 2nd time!\n", memHdr );
            OutputDebugString( buf );
            DebugBreak();
        } else if ( memHdr->Signature == HEAP_SIGNATURE_ALLOC ) {

            RtlGetCallersAddress(&callersAddress,
                                 &callersCaller );

            memHdr->Signature = HEAP_SIGNATURE_FREE;
            memHdr->CallersAddress = callersAddress;
            memHdr->CallersCaller = callersCaller;
        } else {
            memHdr++;
        }
    } else {
#if 0
        sprintf( buf, "Passing NULL to LocalFree, tsk, tsk, tsk!!\n" );
        OutputDebugString( buf );
        DebugBreak();
#endif
    }

    return( (HLOCAL)(*SystemLocalFree)(memHdr) );
}

HANDLE
WINAPI
LEAKS_CreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    )
{
    HANDLE  handle;
    PVOID   callersAddress;
    PVOID   callersCaller;

    handle = (HANDLE)(*SystemCreateEventA)(
                         lpEventAttributes,
                         bManualReset,
                         bInitialState,
                         lpName
                         );

    if ( handle != NULL ) {
        SetHandleTable( handle, TRUE, LeaksEvent );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] CreateEventA returns handle %1!X!, called from %2!X! and %3!X!\n",
                      handle,
                      callersAddress,
                      callersCaller );
    }

    return(handle);

} // CreateEventA


HANDLE
WINAPI
LEAKS_CreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )
{
    HANDLE  handle;
    PVOID   callersAddress;
    PVOID   callersCaller;

    handle = (HANDLE)(*SystemCreateEventW)(
                         lpEventAttributes,
                         bManualReset,
                         bInitialState,
                         lpName
                         );

    if ( handle != NULL ) {
        SetHandleTable( handle, TRUE, LeaksEvent );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE,"[LEAKS] CreateEventW returns handle %1!X!, called from %2!X! and %3!X!\n",
                      handle,
                      callersAddress,
                      callersCaller );
    }

    return(handle);

} // CreateEventW

LONG
APIENTRY
LEAKS_RegOpenKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegOpenKeyA)(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE,"[LEAKS] RegOpenKeyA returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegOpenKeyA

LONG
APIENTRY
LEAKS_RegOpenKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegOpenKeyW)(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegOpenKeyW returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegOpenKeyW

LONG
APIENTRY
LEAKS_RegOpenKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegOpenKeyExA)(
                    hKey,
                    lpSubKey,
                    ulOptions,
                    samDesired,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegOpenKeyExA returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegOpenKeyExA

LONG
APIENTRY
LEAKS_RegOpenKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegOpenKeyExW)(
                    hKey,
                    lpSubKey,
                    ulOptions,
                    samDesired,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegOpenKeyExW returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegOpenKeyExW


LONG
APIENTRY
LEAKS_RegCreateKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegCreateKeyA)(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegCreateKeyA returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCreateKeyA


LONG
APIENTRY
LEAKS_RegCreateKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegCreateKeyW)(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegCreateKeyW returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCreateKeyW


LONG
APIENTRY
LEAKS_RegCreateKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD  Reserved,
    LPSTR  lpClass,
    DWORD  dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegCreateKeyExA)(hKey,
                                      lpSubKey,
                                      Reserved,
                                      lpClass,
                                      dwOptions,
                                      samDesired,
                                      lpSecurityAttributes,
                                      phkResult,
                                      lpdwDisposition
                                      );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegCreateKeyExA returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCreateKeyExA

LONG
APIENTRY
LEAKS_RegCreateKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD  Reserved,
    LPWSTR lpClass,
    DWORD  dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegCreateKeyExW)(
                    hKey,
                    lpSubKey,
                    Reserved,
                    lpClass,
                    dwOptions,
                    samDesired,
                    lpSecurityAttributes,
                    phkResult,
                    lpdwDisposition
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegCreateKeyExW returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCreateKeyExW


LONG
APIENTRY
LEAKS_RegCloseKey(
    HKEY hKey
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegCloseKey)( hKey );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( hKey, FALSE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegCloseKey for key %1!X! returns status %2!u!, called from %3!X! and %4!X!\n",
                      hKey,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCloseKey

BOOL
WINAPI
LEAKS_CloseHandle(
    IN OUT HANDLE hObject
    )
{
    PVOID   callersAddress;
    PVOID   callersCaller;

    if ( HandleTable[ HINDEX( hObject )].InUse ) {

        RtlGetCallersAddress(&callersAddress,
                             &callersCaller );

        HandleTable[ HINDEX( hObject )].InUse = FALSE;
        HandleTable[ HINDEX( hObject )].Caller = callersAddress;
        HandleTable[ HINDEX( hObject )].CallersCaller = callersCaller;

        if ( LeaksVerbose ) {
            ClRtlLogPrint(LOG_NOISE, "[LEAKS] CloseHandle for handle %1!X!, called from %2!X! and %3!X!\n",
                          hObject,
                          callersAddress,
                          callersCaller );
        }
    }

    return (BOOL)(*SystemCloseHandle)( hObject );
}

BOOL
WINAPI
LEAKS_OpenProcessToken (
    IN HANDLE ProcessHandle,
    IN DWORD DesiredAccess,
    OUT PHANDLE TokenHandle
    )
{
    BOOL status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (BOOL)(*SystemOpenProcessToken)(ProcessHandle,
                                       DesiredAccess,
                                       TokenHandle);

    if ( status ) {
        SetHandleTable( *TokenHandle, TRUE, LeaksToken );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] OpenProcessToken returns handle %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *TokenHandle,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);
}


BOOL
WINAPI
LEAKS_OpenThreadToken (
    IN HANDLE ThreadHandle,
    IN DWORD DesiredAccess,
    IN BOOL OpenAsSelf,
    OUT PHANDLE TokenHandle
    )
{
    BOOL status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (BOOL)(*SystemOpenThreadToken)(ThreadHandle,
                                      DesiredAccess,
                                      OpenAsSelf,
                                      TokenHandle);

    if ( status ) {
        SetHandleTable( *TokenHandle, TRUE, LeaksToken );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] OpenThreadToken returns handle %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *TokenHandle,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);
}

BOOL
WINAPI
LEAKS_DuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE DuplicateTokenHandle
    )
{
    BOOL status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (BOOL)(*SystemDuplicateToken)(ExistingTokenHandle,
                                     ImpersonationLevel,
                                     DuplicateTokenHandle);

    if ( status ) {
        SetHandleTable( *DuplicateTokenHandle, TRUE, LeaksToken );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] DuplicateToken returns handle %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *DuplicateTokenHandle,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);
}

BOOL
WINAPI
LEAKS_DuplicateTokenEx(
    IN HANDLE hExistingToken,
    IN DWORD dwDesiredAccess,
    IN LPSECURITY_ATTRIBUTES lpTokenAttributes,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE phNewToken)
{
    BOOL status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (BOOL)(*SystemDuplicateTokenEx)(hExistingToken,
                                       dwDesiredAccess,
                                       lpTokenAttributes,
                                       ImpersonationLevel,
                                       TokenType,
                                       phNewToken);

    if ( status ) {
        SetHandleTable( *phNewToken, TRUE, LeaksToken );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] DuplicateTokenEx returns handle %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phNewToken,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusexts\clusexts\security.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    security.c

Abstract:

    security related debugger extensions

Author:

    Charlie Wickham (charlwi) 17-Mar-2000

Revision History:

--*/

#include "clusextp.h"
#include <sddl.h>

#define FIND_WHITE_SPACE( _ptr_ )                                   \
    while ( *_ptr_ != '\0' && *_ptr_ != ' ' && *_ptr_ != '\t' ) {   \
        ++_ptr_;                                                    \
    }                                                               \

#define SKIP_WHITE_SPACE( _ptr_ )                                       \
    while ( *_ptr_ != '\0' && ( *_ptr_ == ' ' || *_ptr_ == '\t' )) {    \
        ++_ptr_;                                                        \
    }                                                                   \


LPWSTR SidTypeNames[] = {
    L"SidTypeUser",
    L"SidTypeGroup",
    L"SidTypeDomain",
    L"SidTypeAlias",
    L"SidTypeWellKnownGroup",
    L"SidTypeDeletedAccount",
    L"SidTypeInvalid",
    L"SidTypeUnknown",
    L"SidTypeComputer"
};

DECLARE_API( dumpsid )

/*++

Routine Description:

    Look up the account associated with the passed in SID

--*/

{
    PCHAR   p;
	BOOL    success;
    LPSTR   nodeName = NULL;
    LPSTR   stringSid;
    DWORD   status;
    PSID    Sid;
    CHAR    nameBuf[ 512 ];
    CHAR    domainName[ 512 ];
    DWORD   nameSize = sizeof( nameBuf );
    DWORD   domainNameSize = sizeof( domainName );
    SID_NAME_USE    sidType;

	if ( lpArgumentString == NULL || *lpArgumentString == '\0' ) {
        dprintf("siddump [nodename] SID\n");
        return;
    }

    //
    // run down the arg string, finding the args
    //
    p = lpArgumentString;
    dprintf("args: ->%s<-\n", p );

    SKIP_WHITE_SPACE( p );              // skip over leading white space
    if ( *p == '\0' ) {
        dprintf("siddump [nodename] SID\n");
        return;
    }

    stringSid = p;

    FIND_WHITE_SPACE( p );              // find end of 1st arg
    if ( *p != '\0' ) {
        *p++ = 0;                       // terminate the first arg string

        SKIP_WHITE_SPACE( p );          // see if there is another arg
        if ( *p != '\0' ) {
            nodeName = stringSid;
            stringSid = p;
            FIND_WHITE_SPACE( p );      // find the end of the 2nd string
            if ( *p != '\0' ) {
                *p = 0;
            }

            dprintf("node: >%s< sid: >%s<,\n", nodeName, stringSid);
        } else {
            dprintf("sid = >%s<\n", stringSid);
        }
    }

    success = ConvertStringSidToSid( stringSid, &Sid );
    if ( !success ) {
        dprintf("Can't convert SID: error %u\n", status = GetLastError());
        return;
    }

    success = LookupAccountSid(nodeName,
                               Sid,
                               nameBuf,
                               &nameSize,
                               domainName,
                               &domainNameSize,
                               &sidType);

    if ( success ) {
        dprintf("\n%s\\%s\n", domainName, nameBuf );
        dprintf("Sid Type: %ws\n", SidTypeNames[ sidType - 1 ]);
    } else {
        dprintf("Can't lookup SID: error %u\n", status = GetLastError());
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\driver\dispatch.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    Dispatch routines for the Cluster Network Driver.

Author:

    Mike Massa (mikemas)           January 3, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-03-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "dispatch.tmh"

#include <strsafe.h>

//
// Data
//
PCN_FSCONTEXT               CnExclusiveChannel = NULL;

//
// Un-exported Prototypes
//
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );

//
// Local Prototypes
//
FILE_FULL_EA_INFORMATION UNALIGNED *
CnFindEA(
    PFILE_FULL_EA_INFORMATION  StartEA,
    CHAR                      *TargetName,
    USHORT                     TargetNameLength
    );

NTSTATUS
CnCreate(
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CnCleanup(
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CnClose(
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CnEnableShutdownOnClose(
    IN PIRP   Irp
    );

BOOLEAN
CnPerformSecurityCheck(
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpSp,
    OUT PNTSTATUS           Status
    );

//
// Mark pageable code.
//
#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, CnDispatchDeviceControl)
#pragma alloc_text(PAGE, CnFindEA)
#pragma alloc_text(PAGE, CnCreate)
#pragma alloc_text(PAGE, CnEnableShutdownOnClose)
#pragma alloc_text(PAGE, CnPerformSecurityCheck)

#endif // ALLOC_PRAGMA



//
// Function definitions
//
VOID
CnDereferenceFsContext(
    PCN_FSCONTEXT   FsContext
    )
{
    LONG  newValue = InterlockedDecrement(&(FsContext->ReferenceCount));


    CnAssert(newValue >= 0);

    if (newValue != 0) {
        return;
    }

    //
    // Set the cleanup event.
    //
    KeSetEvent(&(FsContext->CleanupEvent), 0, FALSE);

    return;

}  // CnDereferenceFsContext


NTSTATUS
CnMarkRequestPending(
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PDRIVER_CANCEL      CancelRoutine
    )
/*++

Notes:

    Called with IoCancelSpinLock held.

--*/
{
    PCN_FSCONTEXT   fsContext = (PCN_FSCONTEXT) IrpSp->FileObject->FsContext;
    CN_IRQL         oldIrql;

    //
    // Set up for cancellation
    //
    CnAssert(Irp->CancelRoutine == NULL);

    if (!Irp->Cancel) {

        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, CancelRoutine);

        CnReferenceFsContext(fsContext);

        IF_CNDBG(CN_DEBUG_IRP) {
            CNPRINT((
                "[Clusnet] Pending irp %p fileobj %p.\n",
                Irp,
                IrpSp->FileObject
                ));
        }

        return(STATUS_SUCCESS);
    }

    //
    // The IRP has already been cancelled.
    //

    IF_CNDBG(CN_DEBUG_IRP) {
        CNPRINT(("[Clusnet] irp %p already cancelled.\n", Irp));
    }

    return(STATUS_CANCELLED);

}  // CnPrepareIrpForCancel



VOID
CnCompletePendingRequest(
    IN PIRP      Irp,
    IN NTSTATUS  Status,
    IN ULONG     BytesReturned
    )
/*++

Routine Description:

    Completes a pending request.

Arguments:

    Irp           - A pointer to the IRP for this request.
    Status        - The final status of the request.
    BytesReturned - Bytes sent/received information.

Return Value:

    None.

Notes:

    Called with IoCancelSpinLock held. Lock Irql is stored in Irp->CancelIrql.
    Releases IoCancelSpinLock before returning.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    PCN_FSCONTEXT       fsContext;


    irpSp = IoGetCurrentIrpStackLocation(Irp);
    fsContext = (PCN_FSCONTEXT) irpSp->FileObject->FsContext;

    
    IoSetCancelRoutine(Irp, NULL);

    CnDereferenceFsContext(fsContext);

    IF_CNDBG(CN_DEBUG_IRP) {
        CNPRINT((
            "[Clusnet] Completing irp %p fileobj %p, status %lx\n",
            Irp,
            irpSp->FileObject,
            Status
            ));
    }

    if (Irp->Cancel || fsContext->CancelIrps) {

        IF_CNDBG(CN_DEBUG_IRP) {
            CNPRINT(("[Clusnet] Completed irp %p was cancelled\n", Irp));
        }

        Status = (NTSTATUS) STATUS_CANCELLED;
        BytesReturned = 0;
    }

    CnReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = (NTSTATUS) Status;
    Irp->IoStatus.Information = BytesReturned;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return;

}  // CnCompletePendingRequest



PFILE_OBJECT
CnBeginCancelRoutine(
    IN  PIRP     Irp
    )

/*++

Routine Description:

    Performs common bookkeeping for irp cancellation.

Arguments:

    Irp          - Pointer to I/O request packet

Return Value:

    A pointer to the file object on which the irp was submitted.
    This value must be passed to CnEndCancelRequest().

Notes:

    Called with cancel spinlock held.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    PCN_FSCONTEXT       fsContext;
    NTSTATUS            status = STATUS_SUCCESS;
    PFILE_OBJECT        fileObject;


    CnAssert(Irp->Cancel);

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpSp->FileObject;
    fsContext = (PCN_FSCONTEXT) fileObject->FsContext;

    IoSetCancelRoutine(Irp, NULL);

    //
    // Add a reference so the object can't be closed while the cancel routine
    // is executing.
    //
    CnReferenceFsContext(fsContext);

    IF_CNDBG(CN_DEBUG_IRP) {
        CNPRINT((
            "[Clusnet] Cancelling irp %p fileobj %p\n",
            Irp,
            fileObject
            ));
    }

    return(fileObject);

}  // CnBeginCancelRoutine



VOID
CnEndCancelRoutine(
    PFILE_OBJECT    FileObject
    )
/*++

Routine Description:

    Performs common bookkeeping for irp cancellation.

Arguments:


Return Value:


Notes:

    Called with cancel spinlock held.

--*/
{

    PCN_FSCONTEXT   fsContext = (PCN_FSCONTEXT) FileObject->FsContext;


    //
    // Remove the reference placed on the endpoint by the cancel routine.
    //
    CnDereferenceFsContext(fsContext);

    IF_CNDBG(CN_DEBUG_IRP) {
        CNPRINT((
            "[Clusnet] Finished cancelling, fileobj %p\n",
            FileObject
            ));
    }

    return;

} // CnEndCancelRoutine



NTSTATUS
CnDispatchInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )

/*++

Routine Description:

    This is the dispatch routine for Internal Device Control IRPs.
    This is the hot path for kernel-mode TDI clients.

Arguments:

    DeviceObject - Pointer to device object for target device
    Irp          - Pointer to I/O request packet

Return Value:

    An NT status code.

--*/

{
    PIO_STACK_LOCATION   irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG          fileType = (ULONG)((ULONG_PTR)irpSp->FileObject->FsContext2);
#if DBG
    KIRQL            entryIrql = KeGetCurrentIrql();
#endif // DBG


    Irp->IoStatus.Information = 0;

    if (DeviceObject == CdpDeviceObject) {
        if (fileType == TDI_TRANSPORT_ADDRESS_FILE) {
            if (irpSp->MinorFunction == TDI_SEND_DATAGRAM) {
                status = CxSendDatagram(Irp, irpSp);

#if DBG
                CnAssert(entryIrql == KeGetCurrentIrql());
#endif // DBG
                return(status);
            }
            else if (irpSp->MinorFunction == TDI_RECEIVE_DATAGRAM) {
                status = CxReceiveDatagram(Irp, irpSp);
#if DBG
                CnAssert(entryIrql == KeGetCurrentIrql());
#endif // DBG
                return(status);
            }
            else if (irpSp->MinorFunction ==  TDI_SET_EVENT_HANDLER) {
                status = CxSetEventHandler(Irp, irpSp);

#if DBG
                CnAssert(entryIrql == KeGetCurrentIrql());
#endif // DBG

                return(status);
            }

            //
            // Fall through to common code.
            //
        }

        //
        // These functions are common to all endpoint types.
        //
        switch(irpSp->MinorFunction) {

        case TDI_QUERY_INFORMATION:
            status = CxQueryInformation(Irp, irpSp);
            break;

        case TDI_SET_INFORMATION:
        case TDI_ACTION:
            CNPRINT((
                "[Clusnet] Call to unimplemented TDI function 0x%x\n",
                irpSp->MinorFunction
                ));
            status = STATUS_NOT_IMPLEMENTED;
            break;

        default:
            CNPRINT((
                "[Clusnet] Call to invalid TDI function 0x%x\n",
                irpSp->MinorFunction
                ));
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
    }
    else {
        CNPRINT((
            "[Clusnet] Invalid internal device control function 0x%x on device %ws\n",
            irpSp->MinorFunction,
            DD_CLUSNET_DEVICE_NAME
            ));

        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    #if DBG
        CnAssert(entryIrql == KeGetCurrentIrql());
    #endif // DBG

    return(status);

} // CnDispatchInternalDeviceControl



NTSTATUS
CnDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )

/*++

Routine Description:

    This is the top-level dispatch routine for Device Control IRPs.

Arguments:

    DeviceObject - Pointer to device object for target device
    Irp          - Pointer to I/O request packet

Return Value:

    An NT status code.

Notes:

    This routine completes any IRPs for which the return code is not
    STATUS_PENDING.

--*/

{
    NTSTATUS              status;
    CCHAR                 ioIncrement = IO_NO_INCREMENT;
    BOOLEAN               resourceAcquired = FALSE;
    PIO_STACK_LOCATION    irpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG                 ioControlCode =
                              irpSp->Parameters.DeviceIoControl.IoControlCode;
    ULONG                 fileType = 
                          (ULONG) ((ULONG_PTR) irpSp->FileObject->FsContext2);


    PAGED_CODE();

    //
    // Set this in advance. Any subsequent dispatch routine that cares
    // about it will modify it itself.
    //
    Irp->IoStatus.Information = 0;

    //
    // The following commands are valid on only TDI address objects.
    //
    if (ioControlCode == IOCTL_CX_IGNORE_NODE_STATE) {
        if (fileType == TDI_TRANSPORT_ADDRESS_FILE) {
            status = CxDispatchDeviceControl(Irp, irpSp);
        }
        else {
            //
            // Not handled. Return an error.
            //
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        goto complete_request;
    }

    //
    // No other commands are valid on TDI address objects.
    //
    if (fileType == TDI_TRANSPORT_ADDRESS_FILE) {
        //
        // Not handled. Return an error.
        //
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto complete_request;
    }
    
    //
    // The remaining commands are valid for control channels.
    //
    CnAssert(fileType == TDI_CONTROL_CHANNEL_FILE);
    
    //
    // The following set of commands affect only this file object and
    // can be issued at any time. We do not need to hold the CnResource
    // in order to process them. Nor do we need to be in the initialized.
    // state.
    //
    switch(ioControlCode) {
    
    case IOCTL_CLUSNET_SET_EVENT_MASK:
        {
            PCN_FSCONTEXT fsContext = irpSp->FileObject->FsContext;
            PCLUSNET_SET_EVENT_MASK_REQUEST request;
            ULONG                           requestSize;
    
    
            request = (PCLUSNET_SET_EVENT_MASK_REQUEST)
                      Irp->AssociatedIrp.SystemBuffer;
    
            requestSize =
                irpSp->Parameters.DeviceIoControl.InputBufferLength;
    
            if (requestSize >= sizeof(CLUSNET_SET_EVENT_MASK_REQUEST))
            {
                //
                // Kernel mode callers must supply a callback.
                // User mode callers must not.
                //
                if ( !( (Irp->RequestorMode == KernelMode) &&
                        (request->KmodeEventCallback == NULL)
                      )
                     &&
                     !( (Irp->RequestorMode == UserMode) &&
                        (request->KmodeEventCallback != NULL)
                      )
                   )
                {
                    status = CnSetEventMask( fsContext, request );
                }
                else {
                    status = STATUS_INVALID_PARAMETER;
                }
            }
            else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        goto complete_request;
    
    case IOCTL_CLUSNET_GET_NEXT_EVENT:
        {
            PCLUSNET_EVENT_RESPONSE response;
            ULONG                   responseSize;
    
    
            responseSize =
                irpSp->Parameters.DeviceIoControl.OutputBufferLength;
    
            if ( (responseSize < sizeof(CLUSNET_EVENT_RESPONSE))) {
    
                status = STATUS_INVALID_PARAMETER;
            }
            else {
                status = CnGetNextEvent( Irp, irpSp );
                ioIncrement = IO_NETWORK_INCREMENT;
            }
        }
        goto complete_request;
    case IOCTL_CLUSNET_SET_IAMALIVE_PARAM:
        {
            PCLUSNET_SET_IAMALIVE_PARAM_REQUEST request;
            ULONG                              requestSize;

            request = (PCLUSNET_SET_IAMALIVE_PARAM_REQUEST)
                        Irp->AssociatedIrp.SystemBuffer;
            requestSize = irpSp->Parameters.DeviceIoControl.InputBufferLength;

            if ((requestSize < sizeof(CLUSNET_SET_IAMALIVE_PARAM_REQUEST)) ||
                (request->Action >= ClussvcHangActionMax)) {
                status = STATUS_INVALID_PARAMETER;
            }
            else {

                PEPROCESS process = PsGetCurrentProcess();
                
                IF_CNDBG(CN_DEBUG_INIT) {
                    CNPRINT((
                        "[ClusNet] Set Clussvc to Clusnet Hb params: Timeout=%u(s) Action=%u\n",
                        request->Timeout,
                        (ULONG)request->Action
                        ));
                }
                CnTrace(HBEAT_EVENT, HbTraceSetIamaliveParam,
                    "[ClusNet] Set Clussvc to Clusnet Hb params: Timeout=%u(s) Action=%u\n",
                    request->Timeout,
                    (ULONG)request->Action
                    );
                ClussvcClusnetHbTimeoutTicks = (request->Timeout * 1000)/HEART_BEAT_PERIOD;
                ClussvcClusnetHbTimeoutAction = request->Action;
                InterlockedExchange(&ClussvcClusnetHbTickCount, 0);

                // Save the timeout in seconds for the bugcheck parameter.
                ClussvcClusnetHbTimeoutSeconds = request->Timeout;

                //
                // Log a warning if the current process doesn't match the monitored 
                // process (clussvc should set its own params).
                //
                if (process != ClussvcProcessObject) {
                    IF_CNDBG(CN_DEBUG_INIT) {
                        CNPRINT((
                            "[ClusNet] Warning: process configuring hang detection "
                            "parameters (%p) is not clussvc (%p).\n",
                            process, ClussvcProcessObject
                            ));
                    }
                    CnTrace(HBEAT_ERROR, HbTraceSetIamaliveParamProcMismatch,
                        "[ClusNet] Warning: process  configuring hang detection "
                        "parameters (%p) is not clussvc (%p).\n",
                        process, ClussvcProcessObject
                        );
                }

                status = STATUS_SUCCESS;
            }
        }   
        goto complete_request;

    case IOCTL_CLUSNET_IAMALIVE:
        {
            InterlockedExchange(&ClussvcClusnetHbTickCount, ClussvcClusnetHbTimeoutTicks);
            status = STATUS_SUCCESS;
        }
        goto complete_request;
    } // end of switch

    //
    // Not handled yet. Fall through.
    //

    if (ClusnetIsGeneralIoctl(ioControlCode)) {

        if (!ClusnetIsNTEIoctl(ioControlCode)) {

            //
            // The following commands require exclusive access to CnResource.
            //
            resourceAcquired = CnAcquireResourceExclusive(
                                   CnResource,
                                   TRUE
                                   );

            if (!resourceAcquired) {
                CnAssert(resourceAcquired == TRUE);
                status = STATUS_UNSUCCESSFUL;
                goto complete_request;
            }

            switch(ioControlCode) {

            case IOCTL_CLUSNET_INITIALIZE:

                if (CnState == CnStateShutdown) {
                    PCLUSNET_INITIALIZE_REQUEST   request;
                    ULONG                         requestSize;

                    request = (PCLUSNET_INITIALIZE_REQUEST)
                              Irp->AssociatedIrp.SystemBuffer;

                    requestSize = 
                        irpSp->Parameters.DeviceIoControl.InputBufferLength;

                    if (requestSize < sizeof(CLUSNET_INITIALIZE_REQUEST)) {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else {
                        status = CnInitialize(
                                     request->LocalNodeId,
                                     request->MaxNodes
                                     );
                    }
                }
                else {
                    status = STATUS_INVALID_DEVICE_REQUEST;
                }

                goto complete_request;

            case IOCTL_CLUSNET_ENABLE_SHUTDOWN_ON_CLOSE:
                status = CnEnableShutdownOnClose(Irp);
                goto complete_request;

            case IOCTL_CLUSNET_DISABLE_SHUTDOWN_ON_CLOSE:
                {
                    PCN_FSCONTEXT  fsContext = irpSp->FileObject->FsContext;

                    fsContext->ShutdownOnClose = FALSE;

                    if ( ClussvcProcessHandle ) {

                        CnCloseProcessHandle( &ClussvcProcessHandle );
                        ClussvcProcessHandle = NULL;
                    }

                    status = STATUS_SUCCESS;
                }
                goto complete_request;

            case IOCTL_CLUSNET_HALT:
                status = CnShutdown();

                CnReleaseResourceForThread(
                    CnResource,
                    (ERESOURCE_THREAD) PsGetCurrentThread()
                    );

                resourceAcquired = FALSE;

                //
                // Issue a Halt event. If clusdisk still has a handle
                // to clusnet, then it will release its reservations.
                //
                CnIssueEvent( ClusnetEventHalt, 0, 0 );

                goto complete_request;

            case IOCTL_CLUSNET_SHUTDOWN:
                status = CnShutdown();
                goto complete_request;

            case IOCTL_CLUSNET_SET_MEMORY_LOGGING:
                {
                    PCLUSNET_SET_MEM_LOGGING_REQUEST request;
                    ULONG                           requestSize;

                    request = (PCLUSNET_SET_MEM_LOGGING_REQUEST)
                              Irp->AssociatedIrp.SystemBuffer;

                    requestSize =
                        irpSp->Parameters.DeviceIoControl.InputBufferLength;

                    if ( (requestSize < sizeof(CLUSNET_SET_MEM_LOGGING_REQUEST))) {

                        status = STATUS_INVALID_PARAMETER;
                    }
                    else {

                        status = CnSetMemLogging( request );
                    }
                }
                goto complete_request;
    #if DBG
            case IOCTL_CLUSNET_SET_DEBUG_MASK:
                {
                    PCLUSNET_SET_DEBUG_MASK_REQUEST   request;
                    ULONG                             requestSize;

                    request = (PCLUSNET_SET_DEBUG_MASK_REQUEST)
                              Irp->AssociatedIrp.SystemBuffer;

                    requestSize =
                        irpSp->Parameters.DeviceIoControl.InputBufferLength;

                    if (requestSize < sizeof(CLUSNET_SET_DEBUG_MASK_REQUEST)) {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else {
                        CnDebug = request->DebugMask;
                        status = STATUS_SUCCESS;
                    }
                }
                goto complete_request;
    #endif // DBG
            
            } // end switch

        } else {

            //
            // The following commands are only valid if we are
            // in the initialized state. The resource is 
            // acquired to start the operation in the proper
            // state; however, the dispatched routines are 
            // reentrant, so the resource can be released before
            // the IRPs complete.
            //
        
            resourceAcquired = CnAcquireResourceShared(
                                   CnResource,
                                   TRUE
                                   );

            if (!resourceAcquired) {
                CnAssert(resourceAcquired == TRUE);
                status = STATUS_UNSUCCESSFUL;
                goto complete_request;
            }

            if (CnState != CnStateInitialized) {
                status = STATUS_DEVICE_NOT_READY;
                goto complete_request;
            }

            switch(ioControlCode) {

            case IOCTL_CLUSNET_ADD_NTE:
                
                status = IpaAddNTE(Irp, irpSp);

                goto complete_request;

            case IOCTL_CLUSNET_DELETE_NTE:
                
                status = IpaDeleteNTE(Irp, irpSp);

                goto complete_request;

            case IOCTL_CLUSNET_SET_NTE_ADDRESS:
                
                status = IpaSetNTEAddress(Irp, irpSp);

                goto complete_request;

            case IOCTL_CLUSNET_ADD_NBT_INTERFACE:
                {
                    PNETBT_ADD_DEL_IF  request;
                    ULONG              requestSize;
                    PNETBT_ADD_DEL_IF  response;
                    ULONG              responseSize;


                    request = (PNETBT_ADD_DEL_IF)
                              Irp->AssociatedIrp.SystemBuffer;

                    response = (PNETBT_ADD_DEL_IF) request;

                    requestSize =
                        irpSp->Parameters.DeviceIoControl.InputBufferLength;

                    responseSize =
                        irpSp->Parameters.DeviceIoControl.OutputBufferLength;

                    //
                    // Validate the request and response buffers.
                    //
                    if ( 
                         // request data structure
                         (requestSize < sizeof(NETBT_ADD_DEL_IF)) ||

                         // request device name must fit in request buffer
                         (requestSize <
                          (FIELD_OFFSET(NETBT_ADD_DEL_IF, IfName[0]) +
                           request->Length)) ||

                         // request device name must be null-terminated
                         // StringCchLengthW will probe for NULL termination
                         // up to the character count in the second
                         // parameter. If there is no NULL termination 
                         // within that count, an error is returned.
                         (StringCchLengthW(
                              (LPCWSTR)&(request->IfName[0]),
                              request->Length / sizeof(WCHAR),
                              NULL
                              ) != S_OK) ||

                         // response data structure
                         (responseSize < sizeof(NETBT_ADD_DEL_IF)) 
                         
                        )
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else {
                        status = NbtAddIf(
                                     request,
                                     requestSize,
                                     response,
                                     &responseSize
                                     );

                        CnAssert(status != STATUS_PENDING);

                        if (NT_SUCCESS(status)) {
                            Irp->IoStatus.Information = responseSize;
                        }
                    }
                }
                goto complete_request;

            case IOCTL_CLUSNET_DEL_NBT_INTERFACE:
                {
                    PNETBT_ADD_DEL_IF   request;
                    ULONG               requestSize;


                    request = (PNETBT_ADD_DEL_IF)
                              Irp->AssociatedIrp.SystemBuffer;

                    requestSize =
                        irpSp->Parameters.DeviceIoControl.InputBufferLength;

                    //
                    // Validate the request buffer. There is no response
                    // buffer.
                    //
                    if (
                         // request data structure
                         (requestSize < sizeof(NETBT_ADD_DEL_IF)) ||

                         // request device name must fit in request buffer
                         (requestSize <
                          (FIELD_OFFSET(NETBT_ADD_DEL_IF, IfName[0]) +
                           request->Length)) ||

                         // request device name must be null-terminated
                         // StringCchLengthW will probe for NULL termination
                         // up to the character count in the second
                         // parameter. If there is no NULL termination 
                         // within that count, an error is returned.
                         (StringCchLengthW(
                              (LPCWSTR)&(request->IfName[0]),
                              request->Length / sizeof(WCHAR),
                              NULL
                              ) != S_OK) 
                        ) 
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else {
                        status = NbtDeleteIf(request, requestSize);

                        CnAssert(status != STATUS_PENDING);
                    }
                }
                goto complete_request;

            } // end switch
        }
        
        //
        // Not handled. Return an error.
        //
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto complete_request;
    }
    else {
        //
        // The following commands require shared access to CnResource.
        // They are only valid in the initialized state.
        //
        resourceAcquired = CnAcquireResourceShared(CnResource, TRUE);
       
        if (!resourceAcquired) {
            CnAssert(resourceAcquired == TRUE);
            status = STATUS_UNSUCCESSFUL;
            goto complete_request;
        }
       
        if (CnState == CnStateInitialized) {
            if (ClusnetIsTransportIoctl(ioControlCode)) {
                status = CxDispatchDeviceControl(Irp, irpSp);
            }
            else {
                //
                // Not handled. Return an error.
                //
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
        }
        else {
            //
            // We haven't been initialized yet. Return an error.
            //
            status = STATUS_DEVICE_NOT_READY;
        }
    }
    
complete_request:

    if (resourceAcquired) {
        CnReleaseResourceForThread(
            CnResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, ioIncrement);
    }

    return(status);

} // CnDispatchDeviceControl



NTSTATUS
CnDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )

/*++

Routine Description:

    This is the generic dispatch routine for the driver.

Arguments:

    DeviceObject - Pointer to device object for target device
    Irp          - Pointer to I/O request packet

Return Value:

    An NT status code.

--*/

{
    PIO_STACK_LOCATION    irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS              status = STATUS_SUCCESS;
#if DBG
    KIRQL                 entryIrql = KeGetCurrentIrql();
#endif // DBG


    PAGED_CODE();

    CnAssert(irpSp->MajorFunction != IRP_MJ_INTERNAL_DEVICE_CONTROL);

    switch (irpSp->MajorFunction) {

    case IRP_MJ_CREATE:
        status = CnCreate(DeviceObject, Irp, irpSp);
        break;

    case IRP_MJ_CLEANUP:
        status = CnCleanup(DeviceObject, Irp, irpSp);
        break;

    case IRP_MJ_CLOSE:
        status = CnClose(DeviceObject, Irp, irpSp);
        break;

    case IRP_MJ_SHUTDOWN:
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[ClusNet] Processing shutdown notification...\n"));
        }

        {
            BOOLEAN acquired = CnAcquireResourceExclusive(
                                   CnResource,
                                   TRUE
                                   );

            CnAssert(acquired == TRUE);

            (VOID) CnShutdown();

            if (acquired) {
                CnReleaseResourceForThread(
                    CnResource,
                    (ERESOURCE_THREAD) PsGetCurrentThread()
                    );
            }

            //
            // Issue a Halt event. If clusdisk still has a handle
            // to clusnet, then it will release its reservations
            //
            CnIssueEvent( ClusnetEventHalt, 0, 0 );

            status = STATUS_SUCCESS;
        }

        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[ClusNet] Shutdown processing complete.\n"));
        }

        break;

    default:
        IF_CNDBG(CN_DEBUG_IRP) {
            CNPRINT((
                "[ClusNet] Received IRP with unsupported "
                "major function 0x%lx\n",
                irpSp->MajorFunction
                ));
        }
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    CnAssert(status != STATUS_PENDING);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

#if DBG
    CnAssert(entryIrql == KeGetCurrentIrql());
#endif // DBG

    return(status);

} // CnDispatch



NTSTATUS
CnCreate(
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Handler for create IRPs.

Arguments:

    DeviceObject - Pointer to the device object for this request.
    Irp          - Pointer to I/O request packet

Return Value:

    An NT status code.

Notes:

    This routine never returns STATUS_PENDING.
    The calling routine must complete the IRP.

--*/

{
    PCN_FSCONTEXT                        fsContext;
    FILE_FULL_EA_INFORMATION            *ea;
    FILE_FULL_EA_INFORMATION UNALIGNED  *targetEA;
    NTSTATUS                             status;

    PAGED_CODE();

    //
    // Reject unathorized opens
    //
    if ( (IrpSp->FileObject->RelatedFileObject != NULL) ||
         (IrpSp->FileObject->FileName.Length != 0)
       )
    {
        return(STATUS_ACCESS_DENIED);
    }

    ea = (PFILE_FULL_EA_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

    if ((DeviceObject == CdpDeviceObject) && (ea != NULL)) {

        IF_CNDBG(CN_DEBUG_OPEN) {
            CNPRINT((
                "[ClusNet] Opening address object, file object %p\n",
                IrpSp->FileObject
                ));
        }

        //
        // Verify that the caller has access to open CDP sockets.
        //
        if (!CnPerformSecurityCheck(Irp, IrpSp, &status)) {
            IF_CNDBG(CN_DEBUG_OPEN) {
                CNPRINT((
                    "[ClusNet] Failed CDP security check, error %lx\n",
                    status
                    ));
            }
            return(STATUS_ACCESS_DENIED);
        }

        //
        // This is the CDP device. This should be an address object open.
        //
        targetEA = CnFindEA(
                       ea,
                       TdiTransportAddress,
                       TDI_TRANSPORT_ADDRESS_LENGTH
                       );

        if (targetEA != NULL) {
            IrpSp->FileObject->FsContext2 = (PVOID)
                                            TDI_TRANSPORT_ADDRESS_FILE;

            //
            // Open an address object. This will also allocate the common
            // file object context structure.
            //
            status = CxOpenAddress(
                         &fsContext,
                         (TRANSPORT_ADDRESS UNALIGNED *)
                             &(targetEA->EaName[targetEA->EaNameLength + 1]),
                         targetEA->EaValueLength
                         );
        }
        else {
            IF_CNDBG(CN_DEBUG_OPEN) {
                CNPRINT((
                    "[ClusNet] No transport address in EA!\n"
                    ));
            }
            status = STATUS_INVALID_PARAMETER;
        }
    }
    else {
        //
        // This is a control channel open.
        //
        IF_CNDBG(CN_DEBUG_OPEN) {
            IF_CNDBG(CN_DEBUG_OPEN) {
                CNPRINT((
                    "[ClusNet] Opening control channel, file object %p\n",
                    IrpSp->FileObject
                    ));
            }
        }

        //
        // Allocate our common file object context structure.
        //
        fsContext = CnAllocatePool(sizeof(CN_FSCONTEXT));

        if (fsContext != NULL) {
            IrpSp->FileObject->FsContext2 = (PVOID) TDI_CONTROL_CHANNEL_FILE;
            CN_INIT_SIGNATURE(fsContext, CN_CONTROL_CHANNEL_SIG);

            //
            // Check the sharing flags. If this is an exclusive open, check
            // to make sure there isn't already an exclusive open outstanding.
            //
            if (IrpSp->Parameters.Create.ShareAccess == 0) {
                BOOLEAN acquired = CnAcquireResourceExclusive(
                                       CnResource,
                                       TRUE
                                       );

                CnAssert(acquired == TRUE);

                if (CnExclusiveChannel == NULL) {
                    CnExclusiveChannel = fsContext;
                    
                    //
                    // (Re)enable the halt processing mechanism.
                    //
                    CnEnableHaltProcessing();

                    status = STATUS_SUCCESS;
                }
                else {
                    CnFreePool(fsContext);
                    status = STATUS_SHARING_VIOLATION;
                }

                if (acquired) {
                    CnReleaseResourceForThread(
                        CnResource,
                        (ERESOURCE_THREAD) PsGetCurrentThread()
                        );
                }
            }
            else {
                status = STATUS_SUCCESS;
            }
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (status == STATUS_SUCCESS) {
        IrpSp->FileObject->FsContext = fsContext;

        fsContext->FileObject = IrpSp->FileObject;
        fsContext->ReferenceCount = 1;
        fsContext->CancelIrps = FALSE;
        fsContext->ShutdownOnClose = FALSE;

        KeInitializeEvent(
            &(fsContext->CleanupEvent),
            SynchronizationEvent,
            FALSE
            );

        //
        // init the Event list stuff. We use the empty list test on the
        // Linkage field to see if this context block is already been linked
        // to the event file object list
        //
        fsContext->EventMask = 0;
        InitializeListHead( &fsContext->EventList );
        InitializeListHead( &fsContext->Linkage );
        fsContext->EventIrp = NULL;
    }

    return(status);

} // CnCreate



NTSTATUS
CnCleanup(
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Cancels all outstanding Irps on a device object and waits for them to be
    completed before returning.

Arguments:

    DeviceObject - Pointer to the device object on which the Irp was received.
    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    An NT status code.

Notes:

    This routine may block.
    This routine never returns STATUS_PENDING.
    The calling routine must complete the IRP.

--*/

{
    CN_IRQL        oldIrql;
    NTSTATUS       status;
    ULONG          fileType = 
                       (ULONG)((ULONG_PTR)IrpSp->FileObject->FsContext2);
    PCN_FSCONTEXT  fsContext = (PCN_FSCONTEXT) IrpSp->FileObject->FsContext;
    PLIST_ENTRY    EventEntry;
    PIRP           eventIrp;


    if (fileType == TDI_TRANSPORT_ADDRESS_FILE) {
        //
        // This is an address object.
        //
        CnAssert(DeviceObject == CdpDeviceObject);

        status = CxCloseAddress(fsContext);
    }
    else {
        //
        // This is a control channel.
        //
        CnAssert(fileType == TDI_CONTROL_CHANNEL_FILE);

        //
        // If this channel has a shutdown trigger enabled,
        // shutdown the driver.
        //
        if (fsContext->ShutdownOnClose) {

            BOOLEAN  shutdownScheduled;

            //
            // Bug 303422: CnShutdown closes handles that were opened
            // in the context of the system process. However, attaching
            // to the system process during shutdown can cause a
            // bugcheck under certain conditions. The only alternative
            // is to defer executing of CnShutdown to a system worker
            // thread.
            //
            // Rather than creating a new event object, leverage the 
            // cleanup event in the fscontext. It is reset before use
            // below.
            //
            KeClearEvent(&(fsContext->CleanupEvent));

            shutdownScheduled = CnHaltOperation(&(fsContext->CleanupEvent));

            if (shutdownScheduled) {
                status = KeWaitForSingleObject(
                             &(fsContext->CleanupEvent),
                             (Irp->RequestorMode == KernelMode 
                              ? Executive : UserRequest),
                             KernelMode,
                             FALSE,
                             NULL
                             );

                CnAssert(NT_SUCCESS(status));

                status = STATUS_SUCCESS;
            }

            //
            // issue a Halt event. If clusdisk still has a handle
            // to clusnet, then it will release its reservations
            //
            CnIssueEvent( ClusnetEventHalt, 0, 0 );
        }

        //
        // if this guy forgot to clear the event mask before
        // closing the handle, do the appropriate cleanup
        // now.
        //

        if ( fsContext->EventMask ) {
            CLUSNET_SET_EVENT_MASK_REQUEST EventRequest;

            EventRequest.EventMask = 0;

            //
            // cannot proceed if CnSetEventMask returns a timeout
            // error. this indicates that the fsContext has not
            // been removed from the EventFileHandles list because
            // of lock starvation.
            do {
                status = CnSetEventMask( fsContext, &EventRequest );
            } while ( status == STATUS_TIMEOUT );
            CnAssert( status == STATUS_SUCCESS );
        }

        CnAcquireCancelSpinLock( &oldIrql );
        CnAcquireLockAtDpc( &EventLock );

        if ( fsContext->EventIrp != NULL ) {

            eventIrp = fsContext->EventIrp;
            fsContext->EventIrp = NULL;

            CnReleaseLockFromDpc( &EventLock );
            eventIrp->CancelIrql = oldIrql;
            CnCompletePendingRequest(eventIrp, STATUS_CANCELLED, 0);
        } else {
            CnReleaseLockFromDpc( &EventLock );
            CnReleaseCancelSpinLock( oldIrql );
        }
    }

    //
    // Remove the initial reference and wait for all pending work
    // to complete.
    //
    fsContext->CancelIrps = TRUE;
    KeResetEvent(&(fsContext->CleanupEvent));

    CnDereferenceFsContext(fsContext);

    IF_CNDBG(CN_DEBUG_CLEANUP) {
        CNPRINT((
            "[ClusNet] Waiting for completion of Irps on file object %p\n",
            IrpSp->FileObject
            ));
    }

    status = KeWaitForSingleObject(
                 &(fsContext->CleanupEvent),
                 (Irp->RequestorMode == KernelMode ? Executive : UserRequest),
                 KernelMode,
                 FALSE,
                 NULL
                 );

    CnAssert(NT_SUCCESS(status));

    status = STATUS_SUCCESS;

    IF_CNDBG(CN_DEBUG_CLEANUP) {
        CNPRINT((
            "[Clusnet] Wait on file object %p finished\n",
            IrpSp->FileObject
            ));
    }

    return(status);

} // CnCleanup



NTSTATUS
CnClose(
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Dispatch routine for MJ_CLOSE IRPs. Performs final cleanup of the
    open file object.

Arguments:

    DeviceObject - Pointer to the device object on which the Irp was received.
    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    An NT status code.

Notes:

    This routine never returns STATUS_PENDING.
    The calling routine must complete the IRP.

--*/

{
    BOOLEAN        acquired;
    PCN_FSCONTEXT  fsContext = (PCN_FSCONTEXT) IrpSp->FileObject->FsContext;
    ULONG          fileType = 
                       (ULONG)((ULONG_PTR)IrpSp->FileObject->FsContext2);


    CnAssert(fsContext->ReferenceCount == 0);
    CnAssert(IsListEmpty(&(fsContext->EventList)));

    if (fileType == TDI_CONTROL_CHANNEL_FILE) {
        acquired = CnAcquireResourceExclusive(
                       CnResource,
                       TRUE
                       );

        CnAssert(acquired == TRUE);

        if (CnExclusiveChannel == fsContext) {
            CnExclusiveChannel = NULL;
        }

        if (acquired) {
            CnReleaseResourceForThread(
                CnResource,
                (ERESOURCE_THREAD) PsGetCurrentThread()
                );
        }
    }

    IF_CNDBG(CN_DEBUG_CLOSE) {
        CNPRINT((
            "[ClusNet] Close on file object %p\n",
            IrpSp->FileObject
            ));
    }

    CnFreePool(fsContext);

    return(STATUS_SUCCESS);

} // CnClose



FILE_FULL_EA_INFORMATION UNALIGNED *
CnFindEA(
    PFILE_FULL_EA_INFORMATION  StartEA,
    CHAR                      *TargetName,
    USHORT                     TargetNameLength
    )
/*++

Routine Description:

    Parses and extended attribute list for a given target attribute.

Arguments:

    StartEA           - the first extended attribute in the list.
        TargetName        - the name of the target attribute.
        TargetNameLength  - the length of the name of the target attribute.

Return Value:

    A pointer to the requested attribute or NULL if the target wasn't found.

--*/
{
    USHORT                                i;
    BOOLEAN                               found;
    FILE_FULL_EA_INFORMATION UNALIGNED *  CurrentEA;
    FILE_FULL_EA_INFORMATION UNALIGNED *  NextEA;


    PAGED_CODE();

    NextEA = (FILE_FULL_EA_INFORMATION UNALIGNED *) StartEA;

    do {
        found = TRUE;

        CurrentEA = NextEA;
        NextEA = (FILE_FULL_EA_INFORMATION UNALIGNED *)
                  ( ((PUCHAR) StartEA) + CurrentEA->NextEntryOffset);

        if (CurrentEA->EaNameLength != TargetNameLength) {
            continue;
        }

        for (i=0; i < CurrentEA->EaNameLength; i++) {
            if (CurrentEA->EaName[i] == TargetName[i]) {
                continue;
            }
            found = FALSE;
            break;
        }

        if (found) {
            return(CurrentEA);
        }

    } while(CurrentEA->NextEntryOffset != 0);

    return(NULL);

}  // CnFindEA


NTSTATUS
CnEnableShutdownOnClose(
    PIRP   Irp
    )
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PCN_FSCONTEXT       fsContext = irpSp->FileObject->FsContext;
    ULONG               requestSize;
    CLIENT_ID           ClientId;
    OBJECT_ATTRIBUTES   ObjAttributes;
    PCLUSNET_SHUTDOWN_ON_CLOSE_REQUEST request;


    PAGED_CODE();
    
    request = (PCLUSNET_SHUTDOWN_ON_CLOSE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;

    requestSize = irpSp->Parameters.DeviceIoControl.InputBufferLength;

    if ( requestSize >= sizeof(CLUSNET_SHUTDOWN_ON_CLOSE_REQUEST)
       )
    {
        //
        // illegal for kernel mode
        //
        if ( Irp->RequestorMode != KernelMode ) {
            //
            // Get a handle to the cluster service process.
            // This is used to kill the service if a poison
            // pkt is received. Since a kernel worker thread
            // is used to kill the cluster service, we need
            // to acquire the handle in the system process.
            //
            IF_CNDBG(CN_DEBUG_INIT) {
                CNPRINT(("[Clusnet] Acquiring process handle\n"));
            }

            if (ClussvcProcessHandle == NULL) {
                KeAttachProcess( CnSystemProcess );

                ClientId.UniqueThread = (HANDLE)NULL;
                ClientId.UniqueProcess = UlongToHandle(request->ProcessId);

                InitializeObjectAttributes(
                    &ObjAttributes,
                    NULL,
                    0,
                    (HANDLE) NULL,
                    (PSECURITY_DESCRIPTOR) NULL
                    );

                status = ZwOpenProcess(
                             &ClussvcProcessHandle,
                             0,
                             &ObjAttributes,
                             &ClientId
                             );

                if ( NT_SUCCESS( status )) {

                    NTSTATUS subStatus;

                    fsContext->ShutdownOnClose = TRUE;
                
                    //
                    // Get the clussvc process pointer. This is
                    // used only as an informational parameter 
                    // in the hang detection bugcheck, so a 
                    // failure is non-fatal.
                    //
                    subStatus = ObReferenceObjectByHandle(
                                    ClussvcProcessHandle,
                                    0, 
                                    NULL, 
                                    KernelMode,
                                    &ClussvcProcessObject,
                                    NULL
                                    );
                    
                    if (NT_SUCCESS(subStatus)) {
                        //
                        // Immediately drop the reference so that we
                        // don't need to drop it later. Since the 
                        // process object is only used for informational
                        // purposes, we are not concerned with its
                        // reference count. We save the pointer and
                        // assume it is good as long as we hold a
                        // handle to the process.
                        //
                        ObDereferenceObject(ClussvcProcessObject);
                    } else {
                        IF_CNDBG(CN_DEBUG_INIT) {
                            CNPRINT((
                                "[Clusnet] Failed to reference "
                                "clussvc process object by handle, "
                                "status %08X.\n",
                                subStatus
                                ));
                        }
                        CnTrace(HBEAT_ERROR, HbTraceClussvcProcessObj,
                            "[Clusnet] Failed to reference "
                            "clussvc process object by handle, "
                            "status %!status!.\n",
                            subStatus
                            );
                        ClussvcProcessObject = NULL;
                    }
                } else {
                    IF_CNDBG(CN_DEBUG_INIT) {
                        CNPRINT((
                            "[Clusnet] ZwOpenProcess failed. status = %08X\n",
                            status
                            ));
                    }
                }

                KeDetachProcess();

            }
            else {
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
        }
        else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }
    else {
        status = STATUS_INVALID_PARAMETER;
    }

    return(status);

} // CnEnableShutdownOnClose


BOOLEAN
CnPerformSecurityCheck(
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PNTSTATUS           Status
    )
/*++

Routine Description:

    Compares security context of the endpoint creator to that
    of the administrator and local system.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

    Status - returns status generated by access check on failure.

Return Value:

    TRUE    - the socket creator has admin or local system privilige
    FALSE    - the socket creator is just a plain user

Notes:

    This code was lifted from AFD.

--*/

{
    BOOLEAN               accessGranted;
    PACCESS_STATE         accessState;
    PIO_SECURITY_CONTEXT  securityContext;
    PPRIVILEGE_SET        privileges = NULL;
    ACCESS_MASK           grantedAccess;
    PGENERIC_MAPPING      genericMapping;
    ACCESS_MASK           accessMask = GENERIC_ALL;

    //
    // Enable access to all the globally defined SIDs
    //

    genericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask(&accessMask, genericMapping);


    securityContext = IrpSp->Parameters.Create.SecurityContext;
    accessState = securityContext->AccessState;

    SeLockSubjectContext(&accessState->SubjectSecurityContext);

    accessGranted = SeAccessCheck(
                        CdpAdminSecurityDescriptor,
                        &accessState->SubjectSecurityContext,
                        TRUE,
                        accessMask,
                        0,
                        &privileges,
                        IoGetFileObjectGenericMapping(),
                        (KPROCESSOR_MODE)((IrpSp->Flags & SL_FORCE_ACCESS_CHECK)
                            ? UserMode
                            : Irp->RequestorMode),
                        &grantedAccess,
                        Status
                        );

    if (privileges) {
        (VOID) SeAppendPrivileges(
                   accessState,
                   privileges
                   );
        SeFreePrivileges(privileges);
    }

    if (accessGranted) {
        accessState->PreviouslyGrantedAccess |= grantedAccess;
        accessState->RemainingDesiredAccess &= ~( grantedAccess | MAXIMUM_ALLOWED );
        CnAssert(NT_SUCCESS(*Status));
    }
    else {
        CnAssert(!NT_SUCCESS(*Status));
    }
    
    SeUnlockSubjectContext(&accessState->SubjectSecurityContext);

    return (accessGranted);
    
} // CnPerformSecurityCheck
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\driver\memlog.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    memlog.c

Abstract:

    general purpose in-memory logging facility

Author:

    Charlie Wickham (charlwi) 31-May-1997

Environment:

    Kernel Mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */
/* End Forward */

#ifdef MEMLOGGING

//
// in-memory event logging facility. This is used to determine
// subtle timing problems that can't be observed via printfs.
//

#define MAX_MEMLOG_ENTRIES 2000
ULONG MemLogEntries = MAX_MEMLOG_ENTRIES;
ULONG MemLogNextLogEntry = 0;

PMEMLOG_ENTRY MemLog;
KSPIN_LOCK MemLogLock;

VOID
CnInitializeMemoryLog(
    VOID
    )
{
    KeInitializeSpinLock( &MemLogLock );

    if ( MemLogEntries > 0 ) {
        MemLog = CnAllocatePool( MemLogEntries * sizeof( MEMLOG_ENTRY ));

        if ( MemLog == NULL ) {
            MemLogEntries = 0;
        }

        MEMLOG( MemLogInitLog, 0, 0 );
    }
}

NTSTATUS
CnSetMemLogging(
    PCLUSNET_SET_MEM_LOGGING_REQUEST request
    )
{
    KIRQL OldIrql;
    NTSTATUS Status = STATUS_SUCCESS;

    if ( request->NumberOfEntries != MemLogEntries ) {

        KeAcquireSpinLock( &MemLogLock, &OldIrql );

        if ( MemLog != NULL ) {

            CnFreePool( MemLog );
            MemLogEntries = 0;
            MemLog = NULL;
        }

        if ( request->NumberOfEntries != 0 ) {

            MemLogEntries = request->NumberOfEntries;

            MemLog = CnAllocatePool( MemLogEntries * sizeof( MEMLOG_ENTRY ));

            if ( MemLog == NULL ) {

                MemLogEntries = 0;
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {

                MemLogNextLogEntry = 0;
            }
        }
        KeReleaseSpinLock( &MemLogLock, OldIrql );
    }

    return Status;
}

VOID
CnFreeMemoryLog(
    VOID
    )
{
    if ( MemLog )
        CnFreePool( MemLog );
}

#else // MEMLOGGING

NTSTATUS
CnSetMemLogging(
    PCLUSNET_SET_MEM_LOGGING_REQUEST request
    )
{
    return STATUS_INVALID_DEVICE_REQUEST;
}

#endif // MEMLOGGING

/* end memlog.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\driver\event.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    event.c

Abstract:

    general kernel to user event facility. Maintains a list of events that have
    occurred and delivers them to Umode via the completion of an IOCTL IRP.

    How this works:

    The consumer opens a handle to clusnet and issues an
    IOCTL_CLUSNET_SET_EVENT_MASK IRP indicating a mask of the events in which it
    is interested. A kernel consumer must also supply a callback routine through
    which it is notified about the event, i.e, they don't need to drop an
    IOCTL_CLUSNET_GET_NEXT_EVENT IRP to receive notifications. The consumer is
    linked onto the EventFileHandles list through the Linkage field in the
    CN_FSCONTEXT structure. All synchronization is provided through one lock
    called EventLock.

    Umode consumers issue an IOCTL_CLUSNET_GET_NEXT_EVENT IRP to reap the next
    interesting event. If no events are queued, the IRP is marked pending and a
    pointer to it is stored in the FS context. CnEventIrpCancel is set as the
    cancel routine. Note that only one IRP can be pending at a time; if an IRP
    is already queued, this one is completed with STATUS_UNSUCCESSFUL.

    If an event is waiting, it is removed from the FS context's list, the data
    copied to the IRP's buffer and completed with success.

    Posters call CnIssueEvent to post the event of interest. This obtains the
    event lock, walks the file object list, and for consumers that are
    interested in this event, allocates an Event context block (maintained as a
    nonpaged lookaside list) and queues it to that file object's list of
    events. It then posts a work queue item to run CnpDeliverEvents. We can't do
    IRP processing directly since that would violate lock ordering within
    clusnet.

    CnDeliverEvents obtains the IO cancel and event locks, then runs the file
    context list to see if there are events queued for any pending IRPs. If so,
    the event data is copied to the systembuffer and the IRP is completed.

Author:

    Charlie Wickham (charlwi) 17-Feb-1997

Environment:

    Kernel Mode

Revision History:

    Charlie Wickham (charlwi) 25-Oct-1999

        Split CnIssueEvent into two routines: CnIssueEvent which strictly looks
        up the apporpriate consumers of the event and CnpDeliverEvents which
        runs at IRQL 0 to complete any IRPs that are waiting for new
        events. This was done to prevent out of order event delivery; since the
        event lock was near the top of locks to acquire first, the net IF down
        events had to be queued to a worker thread which was bad. Now the event
        lock is lowest which doesn't require a worker thread to post. The worker
        thread still runs when it detects that there is an IRP waiting for an
        event.
        
    David Dion (daviddio) 29-Nov-2000
    
        Disallow modification of the EventFileHandles list while event
        deliveries are in process. Because CnpDeliverEvents and CnIssueEvent
        drop their locks to deliver (via IRP completion and kmode callback,
        respectively), a race condition can occur where an FS context event
        mask is cleared and the FS context linkage fields are reset.
        Modification of the EventFileHandles list is prevented using a count
        of currently delivering threads that is protected by the EventLock.
        
    David Dion (daviddio) 13-Nov-2001
    
        In order to preserve ordering of event delivery and to avoid calling
        out of clusnet while holding locks, all events are queued for delivery
        by a system worker thread. The only exceptions are those events whose
        types are in the mask CN_EVENT_TYPE_KMODE_FASTTRACK. These events are
        delivered in-line to kernel-mode callbacks, since immediate delivery
        is required (e.g. to stop disk reservations) and an imminent service
        termination means ordering is not important.

 --*/

#include "precomp.h"
#pragma hdrstop
#include "event.tmh"

#define CN_EVENT_TYPE_KMODE_FASTTRACK ( ClusnetEventHalt |                \
                                        ClusnetEventPoisonPacketReceived  \
                                        )

/* Forward */

NTSTATUS
CnSetEventMask(
    IN  PCN_FSCONTEXT                   FsContext,
    IN  PCLUSNET_SET_EVENT_MASK_REQUEST EventRequest
    );

NTSTATUS
CnGetNextEvent(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CnIssueEvent(
    CLUSNET_EVENT_TYPE Event,
    CL_NODE_ID NodeId OPTIONAL,
    CL_NETWORK_ID NetworkId OPTIONAL
    );

VOID
CnEventIrpCancel(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    );

/* End Forward */


VOID
CnStartEventDelivery(
    VOID
    )
/*++

Routine Description:

    Synchronizes iteration through EventFileHandles list with respect
    to the EventDeliveryInProgress counter and the EventDeliveryComplete
    KEVENT.
    
Arguments:

    None.
    
Return value:

    None.
    
Notes:

    Called with and returns with EventLock held.
    
--*/
{
    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        0,                                 // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

    CnAssert(EventDeliveryInProgress >= 0);
 
    if (++EventDeliveryInProgress == 1) {
#if DBG
        if (KeResetEvent(&EventDeliveryComplete) == 0) {
            CnAssert(FALSE);
        }
#else // DBG
        KeClearEvent(&EventDeliveryComplete);
#endif // DBG
    }
    
    EventRevisitRequired = FALSE;

    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        0,                                 // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

} // CnStartEventDelivery


BOOLEAN
CnStopEventDelivery(
    VOID
    )
/**    
Routine Description:

    Synchronizes iteration through EventFileHandles list with respect
    to the EventDeliveryInProgress counter and the EventDeliveryComplete
    KEVENT. Checks the EventRevisitRequired flag to determine if an
    event IRP arrived during the preceding delivery.
    
    When signalling EventDeliveryComplete, IO_NETWORK_INCREMENT is used
    to try to avoid starvation of waiters versus other event-delivering
    threads.
    
Arguments:

    None.
    
Return value:

    TRUE if a new event or event IRP may have been added to the 
    EventFileHandles list, and it is necessary to rescan.    
    
Notes:

    Called with and returns with EventLock held.
    
--*/
{
    BOOLEAN eventRevisitRequired = EventRevisitRequired;

    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        0,                                 // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

    EventRevisitRequired = FALSE;

    CnAssert(EventDeliveryInProgress >= 1);
    if (--EventDeliveryInProgress == 0) {
        if (KeSetEvent(
                &EventDeliveryComplete,
                IO_NETWORK_INCREMENT,
                FALSE
                ) != 0) {
            CnAssert(FALSE);
        }
    }

    if (eventRevisitRequired) {
        CnTrace(
            EVENT_DETAIL, StopDeliveryRevisitRequired,
            "[CN] CnStopEventDelivery: revisit required."
            );
    }

    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        0,                                 // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

    return(eventRevisitRequired);

} // CnStopEventDelivery


BOOLEAN
CnIsEventDeliveryInProgress(
    VOID
    )
/*++
    
Routine Description:

    Checks the EventDeliveryInProgress counter to determine if
    an event delivery is in progress. If so, sets the 
    EventRevisitRequired flag.
    
Arguments:

    None.
    
Return value:

    TRUE if event delivery in progress.
    
Notes:

    Called with and returns with EventLock held.
    
--*/
{
    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        0,                                 // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

    if (EventDeliveryInProgress > 0) {
        return(EventRevisitRequired = TRUE);
    } else {
        return(FALSE);
    }

    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        0,                                 // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

} // CnIsEventDeliveryInProgress


BOOLEAN
CnWaitForEventDelivery(
    IN PKIRQL EventLockIrql
    )    
/*++

Routine Description:

    Waits for EventDeliveryComplete event to be signalled as long
    as EventDeliveryInProgress counter is greater than zero.
    
    Maintains a starvation counter to avoid looping forever.
    Starvation threshold of 100 was chosen arbitrarily.
    
Arguments:

    EventLockIrql - irql at which EventLock was acquired
    
Return value:

    TRUE if returning with no deliveries in progress
    FALSE if starvation threshold is exceeded and returning with 
        deliveries in progress

Notes:

    Called with and returns with EventLock held; however, EventLock
    may be dropped and reacquired during execution.
    
    This call blocks, so no other spinlocks may be held at 
    invocation.
    
--*/
{
    NTSTATUS status;
    ULONG    starvationCounter;

    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        (ULONG) ~(CNP_EVENT_LOCK),         // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

    starvationCounter = 100;

    while (starvationCounter-- > 0) {

        if (EventDeliveryInProgress == 0) {
            return(TRUE);
        }

        CnReleaseLock(&EventLock, *EventLockIrql);

        status = KeWaitForSingleObject(
                     &EventDeliveryComplete,
                     Executive,
                     KernelMode,
                     FALSE,
                     NULL
                     );
        CnAssert(status == STATUS_SUCCESS);

        CnAcquireLock(&EventLock, EventLockIrql);
    }

    CnTrace(
        EVENT_DETAIL, EventWaitStarvation,
        "[CN] CnWaitForEventDelivery: starvation threshold %u "
        "exceeded.",
        starvationCounter
        );

    IF_CNDBG( CN_DEBUG_EVENT ) {
        CNPRINT(("[CN] CnWaitForEventDelivery: starvation threshold "
                 "expired.\n"));
    }    

    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        (ULONG) ~(CNP_EVENT_LOCK),         // Forbidden
        CNP_EVENT_LOCK                     // Maximum
        );

    return(FALSE);

} // CnWaitForEventDelivery


NTSTATUS
CnSetEventMask(
    IN  PCN_FSCONTEXT                   FsContext,
    IN  PCLUSNET_SET_EVENT_MASK_REQUEST EventRequest
    )

/*++

Routine Description:

    For a given file handle context, set the event mask associated
    with it

Arguments:

    FsContext - pointer to the clusnet file handle context block
    EventMask - mask of interested events

Return Value:

    STATUS_TIMEOUT if unable to modify EventFileHandles list.
    STATUS_INVALID_PARAMETER_MIX if providing NULL event mask on
        first call
    STATUS_SUCCESS on success.
    
Notes:

    This call may block.

--*/

{
    CN_IRQL     OldIrql;
    NTSTATUS    Status = STATUS_SUCCESS;
    PLIST_ENTRY NextEntry;

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

    CnAcquireLock( &EventLock, &OldIrql );

#if 0
    PCN_FSCONTEXT ListFsContext;

    NextEntry = EventFileHandles.Flink;
    while ( NextEntry != &EventFileHandles ) {

        ListFsContext = CONTAINING_RECORD( NextEntry, CN_FSCONTEXT, Linkage );
        if ( ListFsContext == FsContext ) {

            break;
        }

        NextEntry = ListFsContext->Linkage.Flink;
    }
#endif

    if ( EventRequest->EventMask != 0 ) {

        //
        // adding or updating a handle. If not in the list then add them.
        // Remember the events and, if appropriate, the callback func to use
        // when an event occurs.
        //
        if ( IsListEmpty( &FsContext->Linkage )) {

            //
            // Do not modify the EventFileHandles list if an event
            // delivery is in progress.
            //
            if (CnWaitForEventDelivery(&OldIrql)) {
                InsertHeadList( &EventFileHandles, &FsContext->Linkage );
            } else {
                Status = STATUS_TIMEOUT;
            }
        }

        if (NT_SUCCESS(Status)) {
            FsContext->EventMask = EventRequest->EventMask;
            FsContext->KmodeEventCallback = EventRequest->KmodeEventCallback;
        }

    } else if ( !IsListEmpty( &FsContext->Linkage )) {

        //
        // Null event mask and the fileobj on the event file obj list means
        // remove this guy from the list. Zap any events that may been queued
        // waiting for an IRP. Re-init the linkage to empty so we'll add them
        // back on if they re-init the mask.
        //
        FsContext->EventMask = 0;

        //
        // Do not modify the EventFileHandles list if an event 
        // delivery is in progress. It is okay to modify this
        // FsContext structure since the EventLock is held.
        //
        if (CnWaitForEventDelivery(&OldIrql)) {
            RemoveEntryList( &FsContext->Linkage );
            InitializeListHead( &FsContext->Linkage );
        } else {
            Status = STATUS_TIMEOUT;
        }

        while ( !IsListEmpty( &FsContext->EventList )) {

            NextEntry = RemoveHeadList( &FsContext->EventList );
            ExFreeToNPagedLookasideList( EventLookasideList, NextEntry );
        }
    } else {

        //
        // can't provide NULL event mask first time in
        //
        Status = STATUS_INVALID_PARAMETER_MIX;
    }

    CnReleaseLock( &EventLock, OldIrql );

    if (Status != STATUS_SUCCESS) {
        CnTrace(
            EVENT_DETAIL, SetEventMaskFailed,
            "[CN] CnSetEventMask failed, status %!status!.",
            Status
            );
    }

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

    return Status;
} // CnSetEventMask

VOID
CnpDeliverEvents(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Parameter
    )

/*++

Routine Description:

    Deliver any queued events to those who are waiting. If an IRP is already
    queued, complete it with the info supplied.

Arguments:

    DeviceObject - clusnet device object, not used
    Parameter - PIO_WORKITEM that must be freed

Return Value:

    None

--*/

{
    CN_IRQL                 OldIrql;
    PCLUSNET_EVENT_ENTRY    Event;
    PCLUSNET_EVENT_RESPONSE UserEventData;
    PCN_FSCONTEXT           FsContext;
    PLIST_ENTRY             NextFsHandleEntry;
    PIRP                    EventIrp;
    PLIST_ENTRY             Entry;
    ULONG                   eventsDelivered = 0;
    BOOLEAN                 revisitRequired;

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

    //
    // free the workitem
    //
    IoFreeWorkItem( (PIO_WORKITEM) Parameter );

    //
    // grab the cancel and event locks and loop through the file handles,
    // looking to see which file objs have events queued and IRPs pending.
    //
    CnAcquireCancelSpinLock ( &OldIrql );
    CnAcquireLockAtDpc( &EventLock );

    do {

        //
        // Indicate that a thread is iterating through the EventFileHandles
        // list to deliver events.
        //
        CnTrace(
            EVENT_DETAIL, DeliverEventsStartIteration,
            "[CN] CnpDeliverEvents: starting file handles list iteration."
            );

        CnStartEventDelivery();

        NextFsHandleEntry = EventFileHandles.Flink;
        while ( NextFsHandleEntry != &EventFileHandles ) {

            FsContext = CONTAINING_RECORD( NextFsHandleEntry, CN_FSCONTEXT, Linkage );

            if ( FsContext->EventIrp != NULL ) {

                //
                // Deliver the first event, if it exists. Any other queued events
                // will be delivered when subsequent Event IRPs are submitted.
                //
                if ( !IsListEmpty( &FsContext->EventList ) ) {
                
                    Entry = RemoveHeadList( &FsContext->EventList );
                    Event = CONTAINING_RECORD( Entry, CLUSNET_EVENT_ENTRY, Linkage );

                    //
                    // clear the pointer to the pended IRP and remove the entry from the
                    // event list while synchronized.
                    //
                    EventIrp = FsContext->EventIrp;
                    FsContext->EventIrp = NULL;

                    CnReleaseLockFromDpc( &EventLock );

                    IF_CNDBG( CN_DEBUG_EVENT ) {
                        CNPRINT(("[CN] CnDeliverEvents: completing IRP %p with event %d\n",
                                 EventIrp, Event->EventData.EventType));
                    }

                    EventIrp->CancelIrql = OldIrql;

                    UserEventData = (PCLUSNET_EVENT_RESPONSE)EventIrp->AssociatedIrp.SystemBuffer;

                    UserEventData->Epoch = Event->EventData.Epoch;
                    UserEventData->EventType = Event->EventData.EventType;
                    UserEventData->NodeId = Event->EventData.NodeId;
                    UserEventData->NetworkId = Event->EventData.NetworkId;

                    ExFreeToNPagedLookasideList( EventLookasideList, Entry );
                    
                    CnTrace(
                        EVENT_DETAIL, DeliverEventsCompletingIrp,
                        "[CN] CnpDeliverEvents: Completing IRP %p "
                        "to deliver event: "
                        "Epoch %u, Type %x, NodeId %x, NetworkId %x.",
                        EventIrp,
                        UserEventData->Epoch,
                        UserEventData->EventType,
                        UserEventData->NodeId,
                        UserEventData->NetworkId
                        );

                    //
                    // IO Cancel lock is released in this routine
                    //
                    CnCompletePendingRequest(EventIrp,
                                             STATUS_SUCCESS,
                                             sizeof( CLUSNET_EVENT_RESPONSE ));

                    CnAcquireCancelSpinLock ( &OldIrql );
                    CnAcquireLockAtDpc( &EventLock );

                    ++eventsDelivered;
                }

            } else if ( FsContext->KmodeEventCallback ) {
            
                //
                // Deliver all queued events.
                //
                while ( !IsListEmpty( &FsContext->EventList ) ) {
                
                    Entry = RemoveHeadList( &FsContext->EventList );
                    Event = CONTAINING_RECORD( Entry, CLUSNET_EVENT_ENTRY, Linkage );
                
                    CnReleaseLockFromDpc( &EventLock );
                    CnReleaseCancelSpinLock(OldIrql);

                    CnTrace(
                        EVENT_DETAIL, IssueEventKmodeCallback,
                        "[CN] CnpDeliverEvents: invoking kernel-mode callback %p "
                        "for Event Type %x NodeId %x NetworkId %x.",
                        FsContext->KmodeEventCallback,
                        Event->EventData.EventType,
                        Event->EventData.NodeId,
                        Event->EventData.NetworkId
                        );

                    (*FsContext->KmodeEventCallback)( 
                        Event->EventData.EventType,
                        Event->EventData.NodeId,
                        Event->EventData.NetworkId
                        );

                    ExFreeToNPagedLookasideList( EventLookasideList, Entry );
                    
                    CnAcquireCancelSpinLock ( &OldIrql );
                    CnAcquireLockAtDpc( &EventLock );

                    ++eventsDelivered;
                }
            }

            NextFsHandleEntry = FsContext->Linkage.Flink;
        }

        CnTrace(
            EVENT_DETAIL, DeliverEventsStopIteration,
            "[CN] CnpDeliverEvents: file handle list iteration complete."
            );

    } while ( CnStopEventDelivery() );

    CnReleaseLockFromDpc( &EventLock );
    CnReleaseCancelSpinLock( OldIrql );

    CnTrace(
        EVENT_DETAIL, DeliverEventsSummary,
        "[CN] CnpDeliverEvents: delivered %u events.",
        eventsDelivered
        );

    IF_CNDBG( CN_DEBUG_EVENT ) {
        CNPRINT(("[CN] CnDeliverEvents: events delivered %d\n", eventsDelivered ));
    }

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

} // CnDeliverEvents

NTSTATUS
CnIssueEvent(
    CLUSNET_EVENT_TYPE EventType,
    CL_NODE_ID NodeId OPTIONAL,
    CL_NETWORK_ID NetworkId OPTIONAL
    )

/*++

Routine Description:

    Post an event to each file object's event queue that is interested in this
    type of event. Schedule a work queue item to run down the file objs to
    deliver the events. We can't complete the IRPs directly since we might
    violate the locking order inside clusnet.

Arguments:

    EventType - type of event

    NodeId - optional node Id associated with event

    NetworkId - optional network Id associated with event

Return Value:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOUCES

--*/

{
    CN_IRQL                 OldIrql;
    PCLUSNET_EVENT_ENTRY    Event;
    PCLUSNET_EVENT_RESPONSE UserData;
    PCN_FSCONTEXT           FsContext;
    PLIST_ENTRY             NextFsHandleEntry;
    PIRP                    EventIrp;
    PIO_WORKITEM            EventWorkItem;
    BOOLEAN                 startupWorkerThread = FALSE;
    BOOLEAN                 eventHandled = FALSE;

    CnVerifyCpuLockMask(
        0,                                 // Required
        CNP_EVENT_LOCK,                    // Forbidden
        CNP_EVENT_LOCK_PRECEEDING          // Maximum
        );

    CnTrace(
        EVENT_DETAIL, CnIssueEvent,
        "[CN] CnIssueEvent: Event Type %x, NodeId %x, NetworkId %x.",
        EventType, NodeId, NetworkId
        );

    IF_CNDBG( CN_DEBUG_EVENT ) {
        CNPRINT(( "[CN] CnIssueEvent: Event type 0x%lx Node: %d Network: %d\n",
                  EventType, NodeId, NetworkId ));
    }

    //
    // grab the event lock and loop through the file handles, looking to see
    // which ones are interested in this event
    //
    CnAcquireLock( &EventLock, &OldIrql );

    //
    // Indicate that a thread is iterating through the EventFileHandles
    // list to deliver events (kernel-mode callback counts as a delivery).
    //
    CnTrace(
        EVENT_DETAIL, IssueEventStartIteration,
        "[CN] CnIssueEvent: starting file handles list iteration."
        );

    CnStartEventDelivery();

    NextFsHandleEntry = EventFileHandles.Flink;

    if ( NextFsHandleEntry == &EventFileHandles ) {
        IF_CNDBG( CN_DEBUG_EVENT ) {
            CNPRINT(( "[CN] CnIssueEvent: No file objs on event file handle list\n"));
        }
    }

    while ( NextFsHandleEntry != &EventFileHandles ) {

        FsContext = CONTAINING_RECORD( NextFsHandleEntry, CN_FSCONTEXT, Linkage );

        if ( FsContext->EventMask & EventType ) {

            //
            // If this FsContext has a kernel-mode callback and the event type
            // is one which would cause clusdisk reservations to be stopped
            // (PoisonPacketReceived or Halt), fast-track it rather than
            // queueing to a system worker thread. Ordering is not important,
            // since a Halt is imminent.
            //
            if (FsContext->KmodeEventCallback &&
                (EventType & CN_EVENT_TYPE_KMODE_FASTTRACK)) {

                CnReleaseLock( &EventLock, OldIrql );

                CnTrace(
                    EVENT_DETAIL, FastTrackEventKmodeCallback,
                    "[CN] CnpDeliverEvents: fast-tracking kernel-mode callback %p "
                    "for Event Type %x NodeId %x NetworkId %x.",
                    FsContext->KmodeEventCallback,
                    EventType,
                    NodeId,
                    NetworkId
                    );

                (*FsContext->KmodeEventCallback)( 
                    EventType,
                    NodeId,
                    NetworkId
                    );

                CnAcquireLock( &EventLock, &OldIrql );

            } else {

                //
                // post a copy of this event on the handle's list.
                //
                Event = ExAllocateFromNPagedLookasideList( EventLookasideList );

                if ( Event == NULL ) {

                    IF_CNDBG( CN_DEBUG_EVENT ) {
                        CNPRINT(( "[CN] CnIssueEvent: No more Event buffers!\n"));
                    }

                    CnStopEventDelivery();
                    CnReleaseLock( &EventLock, OldIrql );
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                Event->EventData.Epoch = EventEpoch;
                Event->EventData.EventType = EventType;
                Event->EventData.NodeId = NodeId;
                Event->EventData.NetworkId = NetworkId;

                InsertTailList( &FsContext->EventList, &Event->Linkage );

                //
                // run the worker thread if there is an IRP already queued or
                // if there is a kernel-mode callback
                //
                if ( FsContext->EventIrp || FsContext->KmodeEventCallback ) {
                    startupWorkerThread = TRUE;
                }

                CnTrace(
                    EVENT_DETAIL, IssueEventQueued,
                    "[CN] CnIssueEvent: queued event to FsContext %p, "
                    "Event Type %x NodeId %x NetworkId %x, "
                    "kernel-mode callback %p, event IRP %p ",
                    FsContext,
                    EventType,
                    NodeId,
                    NetworkId,
                    FsContext->KmodeEventCallback,
                    FsContext->EventIrp
                    );
            }

            eventHandled = TRUE;
        }

        NextFsHandleEntry = FsContext->Linkage.Flink;
    }

    //
    // Indicate that iteration through the EventFileHandles list
    // is complete.
    //
    CnTrace(
        EVENT_DETAIL, IssueEventStartIteration,
        "[CN] CnIssueEvent: file handles list iteration complete."
        );

    startupWorkerThread |= CnStopEventDelivery();

    CnReleaseLock( &EventLock, OldIrql );

    if ( startupWorkerThread ) {
        //
        // schedule deliver event routine to run
        //
        
        CnTrace(
            EVENT_DETAIL, IssueEventScheduleWorker,
            "[CN] CnIssueEvent: scheduling worker thread."
            );

        EventWorkItem = IoAllocateWorkItem( CnDeviceObject );
        if ( EventWorkItem != NULL ) {

            IoQueueWorkItem(
                EventWorkItem, 
                CnpDeliverEvents, 
                DelayedWorkQueue,
                EventWorkItem
                );
        }
    }

    if ( !eventHandled ) {
        CnTrace(
            EVENT_DETAIL, IssueEventNoConsumers,
            "[CN] CnIssueEvent: No consumers for Event Type %x Node %u Network %u.",
            EventType, NodeId, NetworkId
            );

        IF_CNDBG( CN_DEBUG_EVENT ) {
            CNPRINT(( "[CN] CnIssueEvent: No consumers for Event type 0x%lx Node: %d Network: %d\n",
                      EventType, NodeId, NetworkId ));
        }
    }

    CnVerifyCpuLockMask(
        0,                                 // Required
        CNP_EVENT_LOCK,                    // Forbidden
        CNP_EVENT_LOCK_PRECEEDING          // Maximum
        );

    return STATUS_SUCCESS;

} // CnIssueEvent

VOID
CnEventIrpCancel(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )

/*++

Routine Description:

    Cancellation handler for CnGetNextEvent requests.

Return Value:

    None

Notes:

    Called with cancel spinlock held.
    Returns with cancel spinlock released.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT fileObject;
    CN_IRQL cancelIrql = Irp->CancelIrql;
    PCN_FSCONTEXT FsContext = (PCN_FSCONTEXT) IrpSp->FileObject->FsContext;

    CnMarkIoCancelLockAcquired();

    fileObject = CnBeginCancelRoutine(Irp);

    CnAcquireLockAtDpc( &EventLock );

    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

    CnTrace(
        EVENT_DETAIL, EventIrpCancel,
        "[CN] Cancelling event IRP %p.",
        Irp
        );

    IF_CNDBG( CN_DEBUG_EVENT ) {
        CNPRINT(("[CN] CnEventIrpCancel: canceling %p\n", Irp ));
    }

    CnAssert(DeviceObject == CnDeviceObject);

    //
    // We can only complete the irp if it really belongs to the Event code. The
    // IRP could have been completed before we acquired the Event lock.
    //
    if ( FsContext->EventIrp == Irp ) {

        FsContext->EventIrp = NULL;

        CnReleaseLock( &EventLock, cancelIrql );

        CnAcquireCancelSpinLock(&(Irp->CancelIrql));

        CnEndCancelRoutine(fileObject);

        CnCompletePendingRequest(Irp, STATUS_CANCELLED, 0);

        return;
    }

    CnReleaseLock( &EventLock, cancelIrql );

    CnAcquireCancelSpinLock( &cancelIrql );

    CnEndCancelRoutine(fileObject);

    CnReleaseCancelSpinLock(cancelIrql);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CnEventIrpCancel

NTSTATUS
CnGetNextEvent(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine obtains the next event from the event list for
    this file handle. If an event is queued, it completes this IRP
    with the event data. Otherwise, the IRP is pended, waiting for
    an event to be posted.

Return Value:

   STATUS_PENDING         if IRP successfully captured
   STATUS_UNSUCCESSFUL    if no more room in the list or IRP couldn't be

Notes:

    Returns with cancel spinlock released.

--*/

{
    NTSTATUS                Status;
    KIRQL                   OldIrql;
    PLIST_ENTRY             Entry;
    PCLUSNET_EVENT_ENTRY    Event;
    PCN_FSCONTEXT           FsContext = IrpSp->FileObject->FsContext;
    PCLUSNET_EVENT_RESPONSE UserEventData = (PCLUSNET_EVENT_RESPONSE)
                                                Irp->AssociatedIrp.SystemBuffer;
    BOOLEAN                 DeliveryInProgress = FALSE;

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

    //
    // acquire the IO cancel lock, then our event lock so we're synch'ed
    // with regards to the state of the IRP and the event list
    //
    CnAcquireCancelSpinLock( &OldIrql );
    CnAcquireLockAtDpc( &EventLock );

    //
    // check first if we have an event queued. if we have an event queued 
    // and there is no delivery in progress we can complete the IRP now.
    // otherwise, we need to pend the IRP to avoid out-of-order delivery.
    //
    if ( !IsListEmpty( &FsContext->EventList )
         && !(DeliveryInProgress = CnIsEventDeliveryInProgress())
         ) {

        //
        // complete the IRP now
        //
        CnReleaseCancelSpinLock(DISPATCH_LEVEL);

        Entry = RemoveHeadList( &FsContext->EventList );

        CnReleaseLock( &EventLock, OldIrql );

        Event = CONTAINING_RECORD( Entry, CLUSNET_EVENT_ENTRY, Linkage );
        *UserEventData = Event->EventData;

        CnTrace(
            EVENT_DETAIL, GetNextEventCompletingIrp,
            "[CN] Completing IRP %p to deliver event: "
            "Epoch %u, Type %x, NodeId %x, NetworkId %x.",
            Irp,
            UserEventData->Epoch,
            UserEventData->EventType,
            UserEventData->NodeId,
            UserEventData->NetworkId
            );

        IF_CNDBG( CN_DEBUG_EVENT ) {
            CNPRINT(("[CN] CnGetNextEvent: completing IRP %p with event %d\n",
                     Irp, Event->EventData.EventType));
        }

        ExFreeToNPagedLookasideList( EventLookasideList, Entry );

        Irp->IoStatus.Information = sizeof(CLUSNET_EVENT_RESPONSE);

        Status = STATUS_SUCCESS;

    } else {

        //
        // make sure we have room for the new IRP
        //
        if ( FsContext->EventIrp ) {

            CnReleaseCancelSpinLock( DISPATCH_LEVEL );

            CnTrace(
                EVENT_DETAIL, GetNextIrpAlreadyPending,
                "[CN] CnGetNextEvent: IRP %p is already pending.",
                FsContext->EventIrp
                );

            IF_CNDBG( CN_DEBUG_EVENT ) {
                CNPRINT(("[CN] CnGetNextEvent: IRP %p is already pending\n",
                         FsContext->EventIrp));
            }

            Status = STATUS_UNSUCCESSFUL;
        } else {

            Status = CnMarkRequestPending( Irp, IrpSp, CnEventIrpCancel );
            CnAssert( NT_SUCCESS( Status ));

            CnReleaseCancelSpinLock( DISPATCH_LEVEL );

            if ( NT_SUCCESS( Status )) {

                //
                // remember this IRP in our open file context block
                //
                FsContext->EventIrp = Irp;

                CnTrace(
                    EVENT_DETAIL, GetNextEventDeliveryInProgress,
                    "[CN] CnGetNextEvent: pending IRP %p, "
                    "delivery in progress: %!bool!",
                    Irp, DeliveryInProgress
                    );
                
                IF_CNDBG( CN_DEBUG_EVENT ) {
                    CNPRINT(("[CN] CnGetNextEvent: pending IRP %p\n", Irp));
                }

                Status = STATUS_PENDING;
            }
        }

        CnReleaseLock(&EventLock, OldIrql);
    }

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

    return Status;

} // CnGetNextEvent

/* end event.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\api\cnetapi.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    cnapi.c

Abstract:

    Cluster Network configuration APIs

Author:

    Mike Massa (mikemas)  18-Mar-1996

Environment:

    User Mode - Win32

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <clusapi.h>
#include <clusdef.h>
#include <ntddcnet.h>
#include <cnettest.h>
#include <cnetapi.h>
#include <clusrtl.h>
#include <winsock2.h>
#include <tdi.h>
#include <align.h>


//
// Private Support Routines.
//
static NTSTATUS
OpenDevice(
    HANDLE *Handle,
    LPWSTR DeviceName,
    ULONG ShareAccess
    )
/*++

Routine Description:

    This function opens a specified IO device.

Arguments:

    Handle - pointer to location where the opened device Handle is
        returned.

    DriverName - name of the device to be opened.

Return Value:

    Windows Error Code.

--*/
{
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     ioStatusBlock;
    UNICODE_STRING      nameString;
    NTSTATUS            status;

    *Handle = NULL;

    //
    // Open a Handle to the device.
    //

    RtlInitUnicodeString(&nameString, DeviceName);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );


    status = NtCreateFile(
                 Handle,
                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 ShareAccess,
                 FILE_OPEN_IF,
                 0,
                 NULL,
                 0
                 );

    return(status);

}  // OpenDevice


NTSTATUS
DoIoctl(
    IN     HANDLE        Handle,
    IN     DWORD         IoctlCode,
    IN     PVOID         Request,
    IN     DWORD         RequestSize,
    IN     PVOID         Response,
    IN OUT PDWORD        ResponseSize,
    IN     LPOVERLAPPED  Overlapped
    )
/*++

Routine Description:

    Packages and issues an ioctl.

Arguments:

    Handle - An open file Handle on which to issue the request.

    IoctlCode - The IOCTL opcode.

    Request - A pointer to the input buffer.

    RequestSize - Size of the input buffer.

    Response - A pointer to the output buffer.

    ResponseSize - On input, the size in bytes of the output buffer.
                   On output, the number of bytes returned in the output buffer.

Return Value:

    NT Status Code.

--*/
{
    NTSTATUS           status;


    if (ARGUMENT_PRESENT(Overlapped)) {
        Overlapped->Internal = (ULONG_PTR) STATUS_PENDING;

        status = NtDeviceIoControlFile(
                     Handle,
                     Overlapped->hEvent,
                     NULL,
                     (((DWORD_PTR) Overlapped->hEvent) & 1) ? NULL : Overlapped,
                     (PIO_STATUS_BLOCK) &(Overlapped->Internal),
                     IoctlCode,
                     Request,
                     RequestSize,
                     Response,
                     *ResponseSize
                     );

    }
    else {
        IO_STATUS_BLOCK    ioStatusBlock = {0, 0};
        HANDLE             event = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (event != NULL) {

            //
            // Prevent operation from completing to a completion port.
            //
            event = (HANDLE) (((ULONG_PTR) event) | 1);

            status = NtDeviceIoControlFile(
                         Handle,
                         event,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         IoctlCode,
                         Request,
                         RequestSize,
                         Response,
                         *ResponseSize
                         );

            if (status == STATUS_PENDING) {
                status = NtWaitForSingleObject(
                             event,
                             TRUE,
                             NULL
                             );
            }

            if (status == STATUS_SUCCESS) {
                status = ioStatusBlock.Status;

                // NOTENOTE: on 64 bit this truncates might want to add > code

                *ResponseSize = (ULONG)ioStatusBlock.Information;
            }
            else {
                *ResponseSize = 0;
            }

            CloseHandle(event);
        }
        else {
            status = GetLastError();
        }
    }

    return(status);

}  // DoIoctl


#define FACILITY_CODE_MASK  0x0FFF0000
#define FACILITY_CODE_SHIFT 16
#define SHIFTED_FACILITY_CLUSTER  (FACILITY_CLUSTER_ERROR_CODE << FACILITY_CODE_SHIFT)


DWORD
NtStatusToClusnetError(
    NTSTATUS  Status
    )
{
    DWORD dosStatus;

    if ( !((Status & FACILITY_CODE_MASK) == SHIFTED_FACILITY_CLUSTER) ) {
        dosStatus = RtlNtStatusToDosError(Status);
    }
    else {
        //dosStatus = (DWORD) Status;
        switch ( Status ) {

        case STATUS_CLUSTER_INVALID_NODE:
            dosStatus = ERROR_CLUSTER_INVALID_NODE;
            break;

        case STATUS_CLUSTER_NODE_EXISTS:
            dosStatus = ERROR_CLUSTER_NODE_EXISTS;
            break;

        case STATUS_CLUSTER_JOIN_IN_PROGRESS:
            dosStatus = ERROR_CLUSTER_JOIN_IN_PROGRESS;
            break;

        case STATUS_CLUSTER_NODE_NOT_FOUND:
            dosStatus = ERROR_CLUSTER_NODE_NOT_FOUND;
            break;

        case STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND:
            dosStatus = ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND;
            break;

        case STATUS_CLUSTER_NETWORK_EXISTS:
            dosStatus = ERROR_CLUSTER_NETWORK_EXISTS;
            break;

        case STATUS_CLUSTER_NETWORK_NOT_FOUND:
            dosStatus = ERROR_CLUSTER_NETWORK_NOT_FOUND;
            break;

        case STATUS_CLUSTER_NETINTERFACE_EXISTS:
            dosStatus = ERROR_CLUSTER_NETINTERFACE_EXISTS;
            break;

        case STATUS_CLUSTER_NETINTERFACE_NOT_FOUND:
            dosStatus =ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            break;

        case STATUS_CLUSTER_INVALID_REQUEST:
            dosStatus = ERROR_CLUSTER_INVALID_REQUEST;
            break;

        case STATUS_CLUSTER_INVALID_NETWORK_PROVIDER:
            dosStatus = ERROR_CLUSTER_INVALID_NETWORK_PROVIDER;
            break;

        case STATUS_CLUSTER_NODE_DOWN:
            dosStatus = ERROR_CLUSTER_NODE_DOWN;
            break;

        case STATUS_CLUSTER_NODE_UNREACHABLE:
            dosStatus = ERROR_CLUSTER_NODE_UNREACHABLE;
            break;

        case STATUS_CLUSTER_NODE_NOT_MEMBER:
            dosStatus = ERROR_CLUSTER_NODE_NOT_MEMBER;
            break;

        case STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS:
            dosStatus = ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS;
            break;

        case STATUS_CLUSTER_INVALID_NETWORK:
            dosStatus = ERROR_CLUSTER_INVALID_NETWORK;
            break;

        case STATUS_CLUSTER_NODE_UP:
            dosStatus = ERROR_CLUSTER_NODE_UP;
            break;

        case STATUS_CLUSTER_NODE_NOT_PAUSED:
            dosStatus = ERROR_CLUSTER_NODE_NOT_PAUSED;
            break;

        case STATUS_CLUSTER_NO_SECURITY_CONTEXT:
            dosStatus = ERROR_CLUSTER_NO_SECURITY_CONTEXT;
            break;

        case STATUS_CLUSTER_NETWORK_NOT_INTERNAL:
            dosStatus = ERROR_CLUSTER_NETWORK_NOT_INTERNAL;
            break;

        case STATUS_CLUSTER_NODE_ALREADY_UP:
            dosStatus = ERROR_CLUSTER_NODE_ALREADY_UP;
            break;

        case STATUS_CLUSTER_NODE_ALREADY_DOWN:
            dosStatus = ERROR_CLUSTER_NODE_ALREADY_DOWN;
            break;

        case STATUS_CLUSTER_NETWORK_ALREADY_ONLINE:
            dosStatus = ERROR_CLUSTER_NETWORK_ALREADY_ONLINE;
            break;

        case STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE:
            dosStatus = ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE;
            break;

        case STATUS_CLUSTER_NODE_ALREADY_MEMBER:
            dosStatus = ERROR_CLUSTER_NODE_ALREADY_MEMBER;
            break;

        default:
            dosStatus = (DWORD)Status;
            break;
        }
    }

    return(dosStatus);
}


//
// Public Routines
//
HANDLE
ClusnetOpenControlChannel(
    IN ULONG ShareAccess
    )
{
    HANDLE    handle = NULL;
    DWORD     status;

    status = OpenDevice(&handle, L"\\Device\\ClusterNetwork", ShareAccess);

    if (status != ERROR_SUCCESS) {
        SetLastError(NtStatusToClusnetError(status));
    }

    return(handle);

}  // ClusnetOpenControlChannel


DWORD
ClusnetEnableShutdownOnClose(
    IN HANDLE  ControlChannel
    )
{
    NTSTATUS  status;
    ULONG  responseSize = 0;
    CLUSNET_SHUTDOWN_ON_CLOSE_REQUEST  request;
    DWORD  requestSize = sizeof(request);

    request.ProcessId = GetCurrentProcessId();

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_ENABLE_SHUTDOWN_ON_CLOSE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

} // ClusnetEnableShutdownOnClose


DWORD
ClusnetDisableShutdownOnClose(
    IN HANDLE  ControlChannel
    )
{
    NTSTATUS  status;
    ULONG     responseSize = 0;


    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_DISABLE_SHUTDOWN_ON_CLOSE,
                 NULL,
                 0,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

} // ClusnetEnableShutdownOnClose


DWORD
ClusnetInitialize(
    IN HANDLE                             ControlChannel,
    IN CL_NODE_ID                         LocalNodeId,
    IN ULONG                              MaxNodes,
    IN CLUSNET_NODE_UP_ROUTINE            NodeUpRoutine,
    IN CLUSNET_NODE_DOWN_ROUTINE          NodeDownRoutine,
    IN CLUSNET_CHECK_QUORUM_ROUTINE       CheckQuorumRoutine,
    IN CLUSNET_HOLD_IO_ROUTINE            HoldIoRoutine,
    IN CLUSNET_RESUME_IO_ROUTINE          ResumeIoRoutine,
    IN CLUSNET_HALT_ROUTINE               HaltRoutine
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    CLUSNET_INITIALIZE_REQUEST   request;
    DWORD                        requestSize = sizeof(request);
    DWORD                        responseSize = 0;


    request.LocalNodeId = LocalNodeId;
    request.MaxNodes = MaxNodes;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_INITIALIZE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetInitialize


DWORD
ClusnetShutdown(
    IN HANDLE       ControlChannel
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    DWORD                        requestSize = 0;
    DWORD                        responseSize = 0;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_SHUTDOWN,
                 NULL,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetShutdown


DWORD
ClusnetRegisterNode(
    IN HANDLE       ControlChannel,
    IN CL_NODE_ID   NodeId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS              status;
    CX_NODE_REG_REQUEST   request;
    DWORD                 requestSize = sizeof(request);
    DWORD                 responseSize = 0;


    request.Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_REGISTER_NODE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetRegisterNode


DWORD
ClusnetDeregisterNode(
    IN HANDLE       ControlChannel,
    IN CL_NODE_ID   NodeId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                status;
    CX_NODE_DEREG_REQUEST   request;
    DWORD                   requestSize = sizeof(request);
    DWORD                   responseSize = 0;


    request.Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_DEREGISTER_NODE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetDeregisterNode


DWORD
ClusnetRegisterNetwork(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                Priority,
    IN BOOLEAN              Restricted
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                   status;
    CX_NETWORK_REG_REQUEST     request;
    DWORD                      requestSize = sizeof(request);
    DWORD                      responseSize = 0;


    request.Id = NetworkId;
    request.Priority = Priority;
    request.Restricted = Restricted;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_REGISTER_NETWORK,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetRegisterNetwork


DWORD
ClusnetDeregisterNetwork(
    IN HANDLE         ControlChannel,
    IN CL_NETWORK_ID  NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                   status;
    CX_NETWORK_DEREG_REQUEST   request;
    DWORD                      requestSize = sizeof(request);
    DWORD                      responseSize = 0;


    request.Id = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_DEREGISTER_NETWORK,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetDeregisterNetwork


DWORD
ClusnetRegisterInterface(
    IN  HANDLE              ControlChannel,
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId,
    IN  ULONG               Priority,
    IN  PWSTR               AdapterId,
    IN  ULONG               AdapterIdLength,
    IN  PVOID               TdiAddress,
    IN  ULONG               TdiAddressLength,
    OUT PULONG              MediaStatus
    )
/*++

Routine Description:

    Registers a node's interface on a network.

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

    NodeId - The ID of the node for which to register the interface.

    NetworkId - The ID of the network for which to register the interface.

    Priority - The priority value assigned to the interface. If a value of
               zero is specified, the interface will inherit its priority
               from the network.

    AdapterId - ID of adapter associated with interface
    
    AdapterIdLength - Length of buffer holding adapter ID, not including
                        terminating UNICODE_NULL character

    TdiAddress - A pointer to a TDI TRANSPORT_ADDRESS structure containing
                 the transport address of the interface.

    TdiAddressLength - The length, in bytes, of the TdiAddress buffer.
    
    MediaStatus - returned current status of media (e.g. cable disconnected)
    
Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                   status;
    PCX_INTERFACE_REG_REQUEST  request;
    DWORD                      requestSize;
    CX_INTERFACE_REG_RESPONSE  response;
    DWORD                      responseSize 
                               = sizeof(CX_INTERFACE_REG_RESPONSE);
    DWORD                      adapterIdOffset;


    // calculate the size of the request structure without the adapter
    // id string.
    requestSize = FIELD_OFFSET(CX_INTERFACE_REG_REQUEST, TdiAddress) +
                  TdiAddressLength;

    // round request to type alignment for adapter id string
    requestSize = ROUND_UP_COUNT(requestSize, TYPE_ALIGNMENT(PWSTR));

    // add buffer for interface name. null-terminate to be safe.
    if (AdapterId == NULL) {
        AdapterIdLength = 0;
    }
    adapterIdOffset = requestSize;
    requestSize += AdapterIdLength + sizeof(UNICODE_NULL);

    if (requestSize < sizeof(CX_INTERFACE_REG_REQUEST)) {
        requestSize = sizeof(CX_INTERFACE_REG_REQUEST);
    }

    request = LocalAlloc(LMEM_FIXED, requestSize);

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(request, requestSize);

    request->NodeId = NodeId;
    request->NetworkId = NetworkId;
    request->Priority = Priority;
    request->TdiAddressLength = TdiAddressLength;

    MoveMemory(
        &(request->TdiAddress[0]),
        TdiAddress,
        TdiAddressLength
        );

    request->AdapterIdLength = AdapterIdLength;
    request->AdapterIdOffset = adapterIdOffset;

    if (AdapterId != NULL) {
        CopyMemory(
            (PUWSTR)((PUCHAR)request + adapterIdOffset),
            AdapterId,
            AdapterIdLength
            );
    }

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_REGISTER_INTERFACE,
                 request,
                 requestSize,
                 &response,
                 &responseSize,
                 NULL
                 );

    LocalFree(request);

    if (MediaStatus != NULL) {
        *MediaStatus = response.MediaStatus;
    }

    return(NtStatusToClusnetError(status));

}  // ClusnetRegisterInterface


DWORD
ClusnetDeregisterInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    CX_INTERFACE_DEREG_REQUEST   request;
    DWORD                        requestSize = sizeof(request);
    DWORD                        responseSize = 0;


    request.NodeId = NodeId;
    request.NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_DEREGISTER_INTERFACE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetDeregisterInterface


DWORD
ClusnetOnlineNodeComm(
    IN HANDLE      ControlChannel,
    IN CL_NODE_ID  NodeId
    )
/*++

Routine Description:

    Enables communication to the specified node.

Arguments:

    ControlChannel -  An open control channel handle to the Cluster Network
                      driver.

    NodeId - The ID of the node to which to enable communication.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                    status;
    CX_ONLINE_NODE_COMM_REQUEST      request;
    DWORD                       requestSize = sizeof(request);
    DWORD                       responseSize = 0;


    request.Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_ONLINE_NODE_COMM,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetOnlineNodeCommunication


DWORD
ClusnetOfflineNodeComm(
    IN HANDLE      ControlChannel,
    IN CL_NODE_ID  NodeId
    )
/*++

Routine Description:

    Disable communication to the specified node.

Arguments:

    ControlChannel -  An open control channel handle to the Cluster Network
                      driver.

    NodeId - The ID of the node to which to disable communication.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    CX_OFFLINE_NODE_COMM_REQUEST      request;
    DWORD                        requestSize = sizeof(request);
    DWORD                        responseSize = 0;


    request.Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_OFFLINE_NODE_COMM,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetOfflineNodeCommunication


DWORD
ClusnetOnlineNetwork(
    IN  HANDLE          ControlChannel,
    IN  CL_NETWORK_ID   NetworkId,
    IN  PWCHAR          TdiProviderName,
    IN  PVOID           TdiBindAddress,
    IN  ULONG           TdiBindAddressLength,
    IN  LPWSTR          AdapterName,
    OUT PVOID           TdiBindAddressInfo,
    IN  PULONG          TdiBindAddressInfoLength
    )
/*++

Routine Description:

    Brings a cluster network online using the specified TDI transport
    provider and local TDI transport address.

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

    NetworkId - The ID of the network to bring online.

    TdiProviderName - The name of the transport provider device that
                      this network should open (e.g. \Device\Udp).

    TdiAddress - A pointer to a TDI TRANSPORT_ADDRESS structure containing
                 the transport address of the local interface to which
                 the network should be bound.

    TdiAddressLength - The length, in bytes, of the TdiAddress buffer.

    AdapterName - name of the adapter on which this network is associated

    TdiBindAddressInfo - A pointer to a TDI_ADDRESS_INFO structure. On output,
                         this structure contains the actual address that
                         the provider opened.

    TdiBindAddressInfoLength - On input, a pointer to the size, in bytes,
                               of the TdiBindAddressInfo parameter. On
                               output, the variable is updated to the
                               amount of date returned in the
                               TdiBindAddressInfo structure.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                    status;
    PCX_ONLINE_NETWORK_REQUEST  request;
    DWORD                       requestSize;
    PVOID                       response;
    ULONG                       tdiProviderNameLength;
    ULONG                       adapterNameLength;


    tdiProviderNameLength = (wcslen(TdiProviderName) + 1) * sizeof(WCHAR);
    adapterNameLength = (wcslen(AdapterName) + 1) * sizeof(WCHAR);

    //
    // The request size is based on the size and required alignment
    // of each field of data following the structure.
    //
    requestSize = sizeof(CX_ONLINE_NETWORK_REQUEST);

    // Provider Name
    requestSize = ROUND_UP_COUNT(requestSize, TYPE_ALIGNMENT(PWSTR))
                  + tdiProviderNameLength;

    // Bind Address
    requestSize = ROUND_UP_COUNT(requestSize, TYPE_ALIGNMENT(PWSTR))
                  + TdiBindAddressLength;

    // Adapter Name
    requestSize = ROUND_UP_COUNT(requestSize, TYPE_ALIGNMENT(PWSTR))
                  + adapterNameLength;

    request = LocalAlloc(LMEM_FIXED, requestSize);

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->Id = NetworkId;
    request->TdiProviderNameLength = tdiProviderNameLength;
    request->TdiProviderNameOffset = 
        ROUND_UP_COUNT(sizeof(CX_ONLINE_NETWORK_REQUEST),
                       TYPE_ALIGNMENT(PWSTR));

    MoveMemory(
        (((PUCHAR) request) + request->TdiProviderNameOffset),
        TdiProviderName,
        tdiProviderNameLength
        );

    request->TdiBindAddressLength = TdiBindAddressLength;
    request->TdiBindAddressOffset = 
        ROUND_UP_COUNT((request->TdiProviderNameOffset +
                        tdiProviderNameLength),
                       TYPE_ALIGNMENT(TRANSPORT_ADDRESS));
                         

    MoveMemory(
        (((PUCHAR) request) + request->TdiBindAddressOffset),
        TdiBindAddress,
        TdiBindAddressLength
        );

    request->AdapterNameLength = adapterNameLength;
    request->AdapterNameOffset = 
        ROUND_UP_COUNT((request->TdiBindAddressOffset +
                        TdiBindAddressLength),
                       TYPE_ALIGNMENT(PWSTR));

    MoveMemory(
        (((PUCHAR) request) + request->AdapterNameOffset),
        AdapterName,
        adapterNameLength
        );

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_ONLINE_NETWORK,
                 request,
                 requestSize,
                 TdiBindAddressInfo,
                 TdiBindAddressInfoLength,
                 NULL
                 );

    LocalFree(request);

    return(NtStatusToClusnetError(status));

}  // ClusnetOnlineNetwork


DWORD
ClusnetOfflineNetwork(
    IN HANDLE         ControlChannel,
    IN CL_NETWORK_ID  NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    CX_OFFLINE_NETWORK_REQUEST   request;
    DWORD                        requestSize = sizeof(request);
    DWORD                        responseSize = 0;


    request.Id = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_OFFLINE_NETWORK,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetOfflineNetwork


DWORD
ClusnetSetNetworkRestriction(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN BOOLEAN              Restricted,
    IN ULONG                NewPriority
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                             status;
    CX_SET_NETWORK_RESTRICTION_REQUEST   request;
    DWORD                                responseSize = 0;


    request.Id = NetworkId;
    request.Restricted = Restricted;
    request.NewPriority = NewPriority;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SET_NETWORK_RESTRICTION,
                 &request,
                 sizeof(CX_SET_NETWORK_RESTRICTION_REQUEST),
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

} // ClusnetSetNetworkRestriction


DWORD
ClusnetGetNetworkPriority(
    IN HANDLE               ControlChannel,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              Priority
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                          status;
    PCX_GET_NETWORK_PRIORITY_REQUEST  request;
    PCX_GET_NETWORK_PRIORITY_RESPONSE response;
    DWORD                             requestSize;
    DWORD                             responseSize;


    requestSize = sizeof(CX_GET_NETWORK_PRIORITY_REQUEST);
    responseSize = sizeof(CX_GET_NETWORK_PRIORITY_RESPONSE);

    if (requestSize > responseSize) {
        request = LocalAlloc(LMEM_FIXED, requestSize);
        response = (PCX_GET_NETWORK_PRIORITY_RESPONSE) request;
    }
    else {
        response = LocalAlloc(LMEM_FIXED, responseSize);
        request = (PCX_GET_NETWORK_PRIORITY_REQUEST) response;
    }

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->Id = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_NETWORK_PRIORITY,
                 request,
                 requestSize,
                 response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {
        if (responseSize != sizeof(CX_GET_NETWORK_PRIORITY_RESPONSE)) {
            status = STATUS_UNSUCCESSFUL;
        }
        else {
            *Priority = response->Priority;
        }
    }

    LocalFree(request);

    return(NtStatusToClusnetError(status));

}  // ClusnetGetNetworkPriority


DWORD
ClusnetSetNetworkPriority(
    IN HANDLE               ControlChannel,
    IN  CL_NETWORK_ID       NetworkId,
    IN  ULONG               Priority
    )
/*++

Routine Description:

    ControlChannel - An open handle to the Cluster Network control device.


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                          status;
    CX_SET_NETWORK_PRIORITY_REQUEST   request;
    DWORD                             responseSize = 0;


    request.Id = NetworkId;
    request.Priority = Priority;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SET_NETWORK_PRIORITY,
                 &request,
                 sizeof(CX_SET_NETWORK_PRIORITY_REQUEST),
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}   // ClusnetSetNetworkPriority


DWORD
ClusnetGetInterfacePriority(
    IN HANDLE               ControlChannel,
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              InterfacePriority,
    OUT PULONG              NetworkPriority

    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                            status;
    PCX_GET_INTERFACE_PRIORITY_REQUEST  request;
    PCX_GET_INTERFACE_PRIORITY_RESPONSE response;
    DWORD                               requestSize;
    DWORD                               responseSize;


    requestSize = sizeof(CX_GET_INTERFACE_PRIORITY_REQUEST);
    responseSize = sizeof(CX_GET_INTERFACE_PRIORITY_RESPONSE);

    if (requestSize > responseSize) {
        request = LocalAlloc(LMEM_FIXED, requestSize);
        response = (PCX_GET_INTERFACE_PRIORITY_RESPONSE) request;
    }
    else {
        response = LocalAlloc(LMEM_FIXED, responseSize);
        request = (PCX_GET_INTERFACE_PRIORITY_REQUEST) response;
    }

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->NodeId = NodeId;
    request->NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_INTERFACE_PRIORITY,
                 request,
                 requestSize,
                 response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {
        if (responseSize != sizeof(CX_GET_INTERFACE_PRIORITY_RESPONSE)) {
            status = STATUS_UNSUCCESSFUL;
        }
        else {
            *InterfacePriority = response->InterfacePriority;
            *NetworkPriority = response->NetworkPriority;
        }
    }

    LocalFree(request);

    return(NtStatusToClusnetError(status));

}   // ClusnetGetInterfacePriority


DWORD
ClusnetSetInterfacePriority(
    IN HANDLE               ControlChannel,
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId,
    IN  ULONG               Priority
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                            status;
    CX_SET_INTERFACE_PRIORITY_REQUEST   request;
    DWORD                               responseSize = 0;


    request.NodeId = NodeId;
    request.NetworkId = NetworkId;
    request.Priority = Priority;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SET_INTERFACE_PRIORITY,
                 &request,
                 sizeof(CX_SET_INTERFACE_PRIORITY_REQUEST),
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetGetInterfacePriority


DWORD
ClusnetGetNodeCommState(
    IN  HANDLE                     ControlChannel,
    IN  CL_NODE_ID                 NodeId,
    OUT PCLUSNET_NODE_COMM_STATE   State
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                            status;
    PCX_GET_NODE_STATE_REQUEST          request;
    PCX_GET_NODE_STATE_RESPONSE         response;
    DWORD                               requestSize;
    DWORD                               responseSize;


    requestSize = sizeof(CX_GET_NODE_STATE_REQUEST);
    responseSize = sizeof(CX_GET_NODE_STATE_RESPONSE);

    if (requestSize > responseSize) {
        request = LocalAlloc(LMEM_FIXED, requestSize);
        response = (PCX_GET_NODE_STATE_RESPONSE) request;
    }
    else {
        response = LocalAlloc(LMEM_FIXED, responseSize);
        request = (PCX_GET_NODE_STATE_REQUEST) response;
    }

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_NODE_STATE,
                 request,
                 requestSize,
                 response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {
        if (responseSize != sizeof(CX_GET_NODE_STATE_RESPONSE)) {
            status = STATUS_UNSUCCESSFUL;
        }
        else {
            *State = response->State;
        }
    }

    LocalFree(request);

    return(NtStatusToClusnetError(status));

}  // ClusnetGetNodeState


DWORD
ClusnetGetNetworkState(
    IN  HANDLE                    ControlChannel,
    IN  CL_NETWORK_ID             NetworkId,
    OUT PCLUSNET_NETWORK_STATE    State
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                            status;
    PCX_GET_NETWORK_STATE_REQUEST       request;
    PCX_GET_NETWORK_STATE_RESPONSE      response;
    DWORD                               requestSize;
    DWORD                               responseSize;


    requestSize = sizeof(CX_GET_NETWORK_STATE_REQUEST);
    responseSize = sizeof(CX_GET_NETWORK_STATE_RESPONSE);

    if (requestSize > responseSize) {
        request = LocalAlloc(LMEM_FIXED, requestSize);
        response = (PCX_GET_NETWORK_STATE_RESPONSE) request;
    }
    else {
        response = LocalAlloc(LMEM_FIXED, responseSize);
        request = (PCX_GET_NETWORK_STATE_REQUEST) response;
    }

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->Id = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_NETWORK_STATE,
                 request,
                 requestSize,
                 response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {
        if (responseSize != sizeof(CX_GET_NETWORK_STATE_RESPONSE)) {
            status = STATUS_UNSUCCESSFUL;
        }
        else {
            *State = response->State;
        }
    }

    LocalFree(request);

    return(NtStatusToClusnetError(status));

}  // ClusnetGetNetworkState


DWORD
ClusnetGetInterfaceState(
    IN  HANDLE                    ControlChannel,
    IN  CL_NODE_ID                NodeId,
    IN  CL_NETWORK_ID             NetworkId,
    OUT PCLUSNET_INTERFACE_STATE  State
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                            status;
    PCX_GET_INTERFACE_STATE_REQUEST     request;
    PCX_GET_INTERFACE_STATE_RESPONSE    response;
    DWORD                               requestSize;
    DWORD                               responseSize;


    requestSize = sizeof(CX_GET_INTERFACE_STATE_REQUEST);
    responseSize = sizeof(CX_GET_INTERFACE_STATE_RESPONSE);

    if (requestSize > responseSize) {
        request = LocalAlloc(LMEM_FIXED, requestSize);
        response = (PCX_GET_INTERFACE_STATE_RESPONSE) request;
    }
    else {
        response = LocalAlloc(LMEM_FIXED, responseSize);
        request = (PCX_GET_INTERFACE_STATE_REQUEST) response;
    }

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->NodeId = NodeId;
    request->NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_INTERFACE_STATE,
                 request,
                 requestSize,
                 response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {
        if (responseSize != sizeof(CX_GET_INTERFACE_STATE_RESPONSE)) {
            status = STATUS_UNSUCCESSFUL;
        }
        else {
            *State = response->State;
        }
    }

    LocalFree(request);

    return(NtStatusToClusnetError(status));

}  // ClusnetGetInterfaceState


#ifdef MM_IN_CLUSNSET

DWORD
ClusnetFormCluster(
    IN HANDLE       ControlChannel,
    IN ULONG        ClockPeriod,
    IN ULONG        SendHBRate,
    IN ULONG        RecvHBRate
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    CMM_FORM_CLUSTER_REQUEST     request;
    DWORD                        requestSize = sizeof(request);
    DWORD                        responseSize = 0;


    request.ClockPeriod = ClockPeriod;
    request.SendHBRate = SendHBRate;
    request.RecvHBRate = RecvHBRate;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CMM_FORM_CLUSTER,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetFormCluster


DWORD
ClusnetJoinCluster(
    IN     HANDLE              ControlChannel,
    IN     CL_NODE_ID          JoiningNodeId,
    IN     CLUSNET_JOIN_PHASE  Phase,
    IN     ULONG               JoinTimeout,
    IN OUT PVOID *             MessageToSend,
    OUT    PULONG              MessageLength,
    OUT    PULONG              DestNodeMask
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    CMM_JOIN_CLUSTER_REQUEST     request;
    DWORD                        requestSize = sizeof(request);
    PCMM_JOIN_CLUSTER_RESPONSE   response;
    ULONG                        IoctlCode;
    DWORD                        responseSize;


    //
    // Parse the input parameters
    //
    if ( Phase == ClusnetJoinPhase1 )
        IoctlCode = IOCTL_CMM_JOIN_CLUSTER_PHASE1;
    else if ( Phase == ClusnetJoinPhase2 )
        IoctlCode = IOCTL_CMM_JOIN_CLUSTER_PHASE2;
    else if ( Phase == ClusnetJoinPhase3 )
        IoctlCode = IOCTL_CMM_JOIN_CLUSTER_PHASE3;
    else if ( Phase == ClusnetJoinPhase4 )
        IoctlCode = IOCTL_CMM_JOIN_CLUSTER_PHASE4;
    else if ( Phase == ClusnetJoinPhaseAbort )
        IoctlCode = IOCTL_CMM_JOIN_CLUSTER_ABORT;
    else
        return(ERROR_INVALID_PARAMETER);


    request.JoiningNode = JoiningNodeId;
    request.JoinTimeout = JoinTimeout;

    //
    // allocate space for the response buffer and a message space at the back
    // of the struct. Current RGP message requirements are 80 bytes
    // (sizeof(rgp_msgbuf)).
    //

    responseSize = sizeof(*response) + 200;

    if (*MessageToSend != NULL) {
        //
        // recycle old message buffer
        //
        response = CONTAINING_RECORD(
                       *MessageToSend,
                       CMM_JOIN_CLUSTER_RESPONSE,
                       SendData
                       );
    }
    else {
        response = LocalAlloc(LMEM_FIXED, responseSize);
    }

    if ( response == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    status = DoIoctl(
                 ControlChannel,
                 IoctlCode,
                 &request,
                 requestSize,
                 response,
                 &responseSize,
                 NULL
                 );

    if (NT_SUCCESS(status)) {
        *MessageToSend = &(response->SendData[0]);
        *MessageLength = response->SizeOfSendData;
        *DestNodeMask = response->SendNodeMask;

        return(ERROR_SUCCESS);
    }

    LocalFree( response );
    *MessageToSend = NULL;

    return(NtStatusToClusnetError(status));

}  // ClusnetJoinCluster


VOID
ClusnetEndJoinCluster(
    IN HANDLE  ControlChannel,
    IN PVOID   LastSentMessage
    )
{
    ULONG                        responseSize = 0;
    PCMM_JOIN_CLUSTER_RESPONSE   response;


    if (LastSentMessage != NULL) {
        response = CONTAINING_RECORD(
                       LastSentMessage,
                       CMM_JOIN_CLUSTER_RESPONSE,
                       SendData
                       );

        LocalFree(response);
    }

    (VOID) DoIoctl(
               ControlChannel,
               IOCTL_CMM_JOIN_CLUSTER_END,
               NULL,
               0,
               NULL,
               &responseSize,
               NULL
               );

    return;

}  // ClusnetEndJoinCluster


DWORD
ClusnetDeliverJoinMessage(
    IN HANDLE  ControlChannel,
    IN PVOID   Message,
    IN ULONG   MessageLength
    )
{
    NTSTATUS   status;
    DWORD      responseSize = 0;


    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CMM_DELIVER_JOIN_MESSAGE,
                 Message,
                 MessageLength,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

} // ClusnetDeliverJoinMessage

DWORD
ClusnetLeaveCluster(
    IN HANDLE       ControlChannel
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS    status;
    DWORD       responseSize = 0;


    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CMM_LEAVE_CLUSTER,
                 NULL,
                 0,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetLeaveCluster


DWORD
ClusnetEvictNode(
    IN HANDLE       ControlChannel,
    IN ULONG        NodeId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                    status;
    CMM_EJECT_CLUSTER_REQUEST   request;
    DWORD                       requestSize = sizeof(request);
    DWORD                       responseSize = 0;

    request.Node = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CMM_EJECT_CLUSTER,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetEvictNode


#endif // MM_IN_CLUSNSET

DWORD
ClusnetGetNodeMembershipState(
    IN  HANDLE                      ControlChannel,
    IN  ULONG                       NodeId,
    OUT CLUSNET_NODE_STATE * State
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                    status;
    CX_GET_NODE_MMSTATE_REQUEST   request;
    DWORD                       requestSize = sizeof(request);
    CX_GET_NODE_MMSTATE_RESPONSE  response;
    DWORD                       responseSize = sizeof(response);

    request.Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_NODE_MMSTATE,
                 &request,
                 requestSize,
                 &response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {

        *State = response.State;
    }

    return(NtStatusToClusnetError(status));

}  // ClusnetGetNodeMembershipState

DWORD
ClusnetSetNodeMembershipState(
    IN  HANDLE                      ControlChannel,
    IN  ULONG                       NodeId,
    IN  CLUSNET_NODE_STATE   State
    )
/*++

Routine Description:

    Set the internal node membership state to the indicated value

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS status;
    CX_SET_NODE_MMSTATE_REQUEST request;
    DWORD requestSize = sizeof(request);
    DWORD responseSize;

    request.NodeId = NodeId;
    request.State = State;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SET_NODE_MMSTATE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetSetNodeMembershipState

DWORD
ClusnetSetEventMask(
    IN  HANDLE              ControlChannel,
    IN  CLUSNET_EVENT_TYPE  EventMask
    )

/*++

Routine Description:

    Based on the supplied callback pointers, set the mask of events
    generated in kernel mode in which this file handle is interested

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.
    EventMask - bit mask of interested events

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                        status;
    CLUSNET_SET_EVENT_MASK_REQUEST  request;
    DWORD                           requestSize = sizeof(request);
    DWORD                           responseSize = 0;

    request.EventMask = EventMask;
    request.KmodeEventCallback = NULL;

    status = DoIoctl(
        ControlChannel,
        IOCTL_CLUSNET_SET_EVENT_MASK,
        &request,
        requestSize,
        NULL,
        &responseSize,
        NULL
        );

    return(NtStatusToClusnetError(status));

}  // ClusnetSetEventMask


DWORD
ClusnetGetNextEvent(
    IN  HANDLE          ControlChannel,
    OUT PCLUSNET_EVENT  Event,
    IN  LPOVERLAPPED    Overlapped  OPTIONAL
    )

/*++

Routine Description:

    Wait for the next event to be completed.

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.
    Event - handle to event that is set when IO is complete
    Response - pointer to structure that is filled in when IRP completes

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS status;
    ULONG ResponseSize = sizeof( CLUSNET_EVENT );

    //
    // if no event passed in, then assume the caller wants to block.
    // we still need an event to block on while waiting...
    //

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_GET_NEXT_EVENT,
                 NULL,
                 0,
                 Event,
                 &ResponseSize,
                 Overlapped
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetGetNextEvent

DWORD
ClusnetHalt(
    IN  HANDLE  ControlChannel
    )

/*++

Routine Description:

    Tell clusnet that we need to halt immediately

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS status;
    DWORD responseSize;

    status = DoIoctl(
        ControlChannel,
        IOCTL_CLUSNET_HALT,
        NULL,
        0,
        NULL,
        &responseSize,
        NULL
        );

    return(NtStatusToClusnetError(status));

}  // ClusnetHalt

DWORD
ClusnetSetMemLogging(
    IN  HANDLE  ControlChannel,
    IN  ULONG   NumberOfEntries
    )

/*++

Routine Description:

    Turn in-memory logging in clusnet on or off.

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.
    NumberOfEntires - # of entries to allocate for the log. Zero turns off logging

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS status;
    CLUSNET_SET_MEM_LOGGING_REQUEST request;
    DWORD requestSize = sizeof( request );
    DWORD responseSize;

    request.NumberOfEntries = NumberOfEntries;

    status = DoIoctl(
        ControlChannel,
        IOCTL_CLUSNET_SET_MEMORY_LOGGING,
        &request,
        requestSize,
        NULL,
        &responseSize,
        NULL
        );

    return(NtStatusToClusnetError(status));

}  // ClusnetSetMemLogging

DWORD
ClusnetSendPoisonPacket(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId
    )

/*++

Routine Description:

    Send a poison packet to the indicated node

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_SEND_POISON_PKT_REQUEST            request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;

    request.Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SEND_POISON_PACKET,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}

DWORD
ClusnetSetOuterscreen(
    IN HANDLE          ControlChannel,
    IN ULONG           Outerscreen
    )

/*++

Routine Description:

    set the cluster member outerscreen

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_SET_OUTERSCREEN_REQUEST            request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;

    request.Outerscreen = Outerscreen;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SET_OUTERSCREEN,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}

DWORD
ClusnetRegroupFinished(
    IN HANDLE          ControlChannel,
    IN ULONG           EventEpoch,
    IN ULONG           RegroupEpoch
    )

/*++

Routine Description:

    inform clusnet that regroup has finished

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.
    NewEpoch - new event epoch used to detect stale events

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_REGROUP_FINISHED_REQUEST           request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;

    request.EventEpoch = EventEpoch;
    request.RegroupEpoch = RegroupEpoch;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_REGROUP_FINISHED,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}

DWORD
ClusnetImportSecurityContexts(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      JoiningNodeId,
    IN PWCHAR          PackageName,
    IN ULONG           SignatureSize,
    IN PVOID           ServerContext,
    IN PVOID           ClientContext
    )

/*++

Routine Description:

    inform clusnet that regroup has finished

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.
    NewEpoch - new event epoch used to detect stale events

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/

{
    NTSTATUS                              status;
    CX_IMPORT_SECURITY_CONTEXT_REQUEST    request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;

    request.JoiningNodeId = JoiningNodeId;
    request.PackageName = PackageName;
    request.PackageNameSize = sizeof(WCHAR) * ( wcslen( PackageName ) + 1 );
    request.SignatureSize = SignatureSize;
    request.ServerContext = ServerContext;
    request.ClientContext = ClientContext;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_IMPORT_SECURITY_CONTEXTS,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}

DWORD
ClusnetReserveEndpoint(
    IN HANDLE   ControlChannel,
    IN PWSTR    EndpointString
    )
/*++

Routine Description:

    Tell clusnet to tell TCP/IP to reserve the port number in 
    EndpointString.
    
Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

    
    EndpointString - string containing port number assigned to clusnet
    
Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    USHORT port;
    DWORD err;
    DWORD responseSize = 0;
    NTSTATUS status;

    err = ClRtlTcpipStringToEndpoint(EndpointString, &port);

    if (err == ERROR_SUCCESS) {

        // TCP/IP needs the port in host byte-order format.
        // ClRtlTcpipStringToEndpoint returns it in network
        // byte-order format.
        port = ntohs(port);

        status = DoIoctl(
                     ControlChannel,
                     IOCTL_CX_RESERVE_ENDPOINT,
                     &port,
                     sizeof(port),
                     NULL,
                     &responseSize,
                     NULL
                     );
    
        err = NtStatusToClusnetError(status);
    }

    return err;
}

DWORD
ClusnetConfigureMulticast(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                MulticastNetworkBrand,
    IN PVOID                MulticastAddress,
    IN ULONG                MulticastAddressLength,
    IN PVOID                Key,
    IN ULONG                KeyLength
    )
/*++

Routine Description:

    Configures multicast parameters for the specified network.
    
--*/
{
    NTSTATUS                          status;
    PCX_CONFIGURE_MULTICAST_REQUEST   request;
    DWORD                             requestSize;
    DWORD                             requestDataOffset = 0;
    DWORD                             responseSize = 0;

    //
    // The request size is based on the size and required alignment
    // of each field of data following the structure. If there is no
    // data following the structure, only the structure is required.
    //
    requestSize = sizeof(CX_CONFIGURE_MULTICAST_REQUEST);
    requestDataOffset = requestSize;

    if (MulticastAddressLength != 0) {
        requestSize = ROUND_UP_COUNT(requestSize,
                                     TYPE_ALIGNMENT(TRANSPORT_ADDRESS)
                                     ) +
                      MulticastAddressLength;
    }

    if (KeyLength != 0) {
        requestSize = ROUND_UP_COUNT(requestSize,
                                     TYPE_ALIGNMENT(PVOID)
                                     ) +
                      KeyLength;
    }

    //
    // Allocate the request buffer.
    //
    request = LocalAlloc(LMEM_FIXED, requestSize);

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->NetworkId = NetworkId;
    request->MulticastNetworkBrand = MulticastNetworkBrand;

    if (MulticastAddress != NULL) {
        request->MulticastAddress = ROUND_UP_COUNT(
                                        requestDataOffset,
                                        TYPE_ALIGNMENT(TRANSPORT_ADDRESS)
                                        );
        MoveMemory(
            (((PUCHAR) request) + request->MulticastAddress),
            MulticastAddress,
            MulticastAddressLength
            );
        request->MulticastAddressLength = MulticastAddressLength;
        requestDataOffset = request->MulticastAddress + 
                            request->MulticastAddressLength;
    } else {
        request->MulticastAddress = 0;
        request->MulticastAddressLength = 0;
    }

    if (Key != NULL) {
        request->Key = ROUND_UP_COUNT(
                           requestDataOffset, 
                           TYPE_ALIGNMENT(PVOID)
                           );
        MoveMemory(
            (((PUCHAR) request) + request->Key),
            Key,
            KeyLength
            );
        request->KeyLength = KeyLength;
        requestDataOffset = request->Key + request->KeyLength;
    } else {
        request->Key = 0;
        request->KeyLength = 0;
    }

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_CONFIGURE_MULTICAST,
                 request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    LocalFree(request);

    return(NtStatusToClusnetError(status));

} // ClusnetConfigureMulticast


DWORD
ClusnetGetMulticastReachableSet(
    IN  HANDLE               ControlChannel,
    IN  CL_NETWORK_ID        NetworkId,
    OUT ULONG              * NodeScreen
    )
/*++

Routine Description:

    Queries the current set of nodes considered reachable by
    a multicast on the specified network.
    
Arguments:

    ControlChannel - open clusnet control channel
    
    NetworkId - multicast network
    
    NodeScreen - mask of nodes
    
Return value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                                   status;
    CX_GET_MULTICAST_REACHABLE_SET_REQUEST     request;
    CX_GET_MULTICAST_REACHABLE_SET_RESPONSE    response;
    DWORD                                      responseSize = sizeof(response);

    request.Id = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_MULTICAST_REACHABLE_SET,
                 &request,
                 sizeof(request),
                 &response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {

        *NodeScreen = response.NodeScreen;
    }

    return(NtStatusToClusnetError(status));

} // ClusnetGetMulticastReachableSet

DWORD
ClusnetSetIamaliveParam(
    IN HANDLE               ControlChannel,
    IN ULONG                Timeout,
    IN ClussvcHangAction    Action
    )
/*++

Routine Description:

    Sets the Timeout and Action to be taken by clusnet in case of clusnet hang.

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.
    Timeout - Timeout in Secs.
    Action - Action to be taken by Clusnet in case of clussvc hang.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS  status;
    DWORD  responseSize = 0;
    CLUSNET_SET_IAMALIVE_PARAM_REQUEST  request;

    request.Timeout = Timeout;
    request.Action = Action;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_SET_IAMALIVE_PARAM,
                 &request,
                 sizeof(CLUSNET_SET_IAMALIVE_PARAM_REQUEST),
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

} // ClusnetSetIamaliveParam

DWORD
ClusnetIamalive(
    IN HANDLE  ControlChannel
    )
/*++

Routine Description:

    Clussvc to Clusnet Heartbeat Ioctl

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/    
{
    NTSTATUS  status;
    DWORD     requestSize = 0;
    DWORD     responseSize = 0;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_IAMALIVE,
                 NULL,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

} // ClusnetIamalive

#if DBG

DWORD
ClusnetSetDebugMask(
    IN HANDLE   ControlChannel,
    IN ULONG    Mask
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                        status;
    CLUSNET_SET_DEBUG_MASK_REQUEST  request;
    DWORD                           responseSize = 0;


    request.DebugMask = Mask;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_SET_DEBUG_MASK,
                 &request,
                 sizeof(CLUSNET_SET_DEBUG_MASK_REQUEST),
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}


DWORD
ClusnetOnlinePendingInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_ONLINE_PENDING_INTERFACE_REQUEST   request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;


    request.NodeId = NodeId;
    request.NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_ONLINE_PENDING_INTERFACE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}


DWORD
ClusnetOnlineInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_ONLINE_INTERFACE_REQUEST           request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;


    request.NodeId = NodeId;
    request.NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_ONLINE_INTERFACE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}


DWORD
ClusnetOfflineInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_OFFLINE_INTERFACE_REQUEST          request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;


    request.NodeId = NodeId;
    request.NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_OFFLINE_INTERFACE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}


DWORD
ClusnetFailInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_FAIL_INTERFACE_REQUEST             request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;


    request.NodeId = NodeId;
    request.NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_FAIL_INTERFACE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}


DWORD
ClusnetSendMmMsg(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN ULONG           Pattern
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_SEND_MM_MSG_REQUEST                request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;
    DWORD                                 i;


    request.DestNodeId = NodeId;

    for (i=0; i < CX_MM_MSG_DATA_LEN; i++) {
        request.MessageData[i] = Pattern;
    }

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SEND_MM_MSG,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\driver\clusnet.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusnet.c

Abstract:

    Intialization and dispatch routines for the Cluster Network Driver.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "clusnet.tmh"

#include <sspi.h>

//
// Global Data
//
PDRIVER_OBJECT        CnDriverObject = NULL;
PDEVICE_OBJECT        CnDeviceObject = NULL;
KSPIN_LOCK            CnDeviceObjectStackSizeLock = 0;
PDEVICE_OBJECT        CdpDeviceObject = NULL;
PKPROCESS             CnSystemProcess = NULL;
CN_STATE              CnState = CnStateShutdown;
PERESOURCE            CnResource = NULL;
CL_NODE_ID            CnMinValidNodeId = ClusterInvalidNodeId;
CL_NODE_ID            CnMaxValidNodeId = ClusterInvalidNodeId;
CL_NODE_ID            CnLocalNodeId = ClusterInvalidNodeId;
KSPIN_LOCK            CnShutdownLock = 0;
BOOLEAN               CnShutdownScheduled = FALSE;
PKEVENT               CnShutdownEvent = NULL;
WORK_QUEUE_ITEM       CnShutdownWorkItem = {{NULL, NULL}, NULL, NULL};
HANDLE                ClussvcProcessHandle = NULL;
PSECURITY_DESCRIPTOR  CdpAdminSecurityDescriptor = NULL;


//
// vars for managing Events. The lookaside list generates Event data structs
// that are used to carry the data back to user mode. EventLock is the only
// lock and synchronizes all access to any event structure (both here and in
// CN_FSCONTEXT). EventFileHandles is a list of CN_FSCONTEXT structs that
// are interested in receiving event notifications. To avoid synchronization
// problems between clusnet and mm in clussvc, events have an epoch associated
// with them. MM increments the epoch at the beginning of regroup event and
// updates clusnet at the end of regroup. Any events still pending in the
// event queue with a stale epoch are ignored by MM.
//
// EventDeliveryInProgress is a count of threads that are currently 
// iterating through the EventFileHandles list and delivering events. 
// The EventFileHandles list cannot be modified while EventDeliveryInProgress
// is greater than zero. EventDeliveryComplete is a notification event
// that is signalled when the EventDeliveryInProgress count reaches zero.
// EventRevisitRequired indicates whether a new event IRP arrived during
// event delivery. To avoid delivering events out of order, the IRP cannot
// be completed immediately.
//

PNPAGED_LOOKASIDE_LIST  EventLookasideList = NULL;
LIST_ENTRY              EventFileHandles = {0,0};
#if DBG
CN_LOCK                 EventLock = {0,0};
#else
CN_LOCK                 EventLock = 0;
#endif
ULONG                   EventEpoch;
LONG                    EventDeliveryInProgress = 0;
KEVENT                  EventDeliveryComplete;
BOOLEAN                 EventRevisitRequired = FALSE;

#if DBG
ULONG            CnDebug = 0;
#endif // DBG

//
// Private Types
//

//
// Private Data
//

SECURITY_STATUS
SEC_ENTRY
SecSetPagingMode(
	BOOLEAN Pageable
	);

BOOLEAN SecurityPagingModeSet = FALSE;

//
// Local Prototypes
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
CnCreateDeviceObjects(
    IN PDRIVER_OBJECT   DriverObject
    );

VOID
CnDeleteDeviceObjects(
    VOID
    );

VOID
CnAdjustDeviceObjectStackSize(
    PDEVICE_OBJECT ClusnetDeviceObject,
    PDEVICE_OBJECT TargetDeviceObject
    );

NTSTATUS
CnBuildDeviceAcl(
    OUT PACL *DeviceAcl
    );

NTSTATUS
CnCreateSecurityDescriptor(
    VOID
    );

//
// Mark init code as discardable.
//
#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, CnCreateDeviceObjects)
#pragma alloc_text(INIT, CnCreateSecurityDescriptor)
#pragma alloc_text(INIT, CnBuildDeviceAcl)

#pragma alloc_text(PAGE, DriverUnload)
#pragma alloc_text(PAGE, CnDeleteDeviceObjects)

#endif // ALLOC_PRAGMA

//
// Function definitions
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    Initialization routine for the driver.

Arguments:

    DriverObject   - Pointer to the driver object created by the system.
    RegistryPath   - The driver's registry key.

Return Value:

    An NT status code.

--*/
{
    NTSTATUS        status;
    USHORT          i;

#if DBG
    volatile BOOLEAN DontLoad = FALSE;

    if ( DontLoad )
        return STATUS_UNSUCCESSFUL;
#endif


    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[ClusNet] Loading...\n"));
    }

    WPP_INIT_TRACING(DriverObject, RegistryPath);

    //
    // Save a pointer to the system process so that we can open
    // handles in the context of this process later.
    //
    CnSystemProcess = (PKPROCESS) IoGetCurrentProcess();

    //
    // Allocate a synchronization resource.
    //
    CnResource = CnAllocatePool(sizeof(ERESOURCE));

    if (CnResource == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = ExInitializeResourceLite(CnResource);

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

    //
    // initialize the mechanisms used to deliver event callbacks
    // to user mode
    //
    EventLookasideList = CnAllocatePool(sizeof(NPAGED_LOOKASIDE_LIST));

    if (EventLookasideList == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ExInitializeNPagedLookasideList(EventLookasideList,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof( CLUSNET_EVENT_ENTRY ),
                                    CN_EVENT_SIGNATURE,
                                    0);

    CnInitializeLock( &EventLock, CNP_EVENT_LOCK );
    InitializeListHead( &EventFileHandles );
    KeInitializeEvent( &EventDeliveryComplete, NotificationEvent, TRUE );

    //
    // Initialize miscellaneous other items.
    //
    KeInitializeSpinLock(&CnShutdownLock);
    KeInitializeSpinLock(&CnDeviceObjectStackSizeLock);

    //
    // Initialize the driver object
    //
    CnDriverObject = DriverObject;

    DriverObject->DriverUnload = DriverUnload;
    DriverObject->FastIoDispatch = NULL;

    for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = CnDispatch;
    }

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
        CnDispatchDeviceControl;

    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
        CnDispatchInternalDeviceControl;

    //
    // Create all the devices exported by this driver.
    //
    status = CnCreateDeviceObjects(DriverObject);

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

    //
    // Initialize the CDP security descriptor.
    //
    status = CnCreateSecurityDescriptor();
    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

#ifdef MEMLOGGING
    //
    // initialize the in-memory log
    //

    CnInitializeMemoryLog();
#endif // MEMLOGGING

    //
    // Load the IP Address and NetBT support.
    // This must be done before the transport registers for PnP events.
    //
    status = IpaLoad();

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

    status = NbtIfLoad();
    
    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

    //
    // Load the transport component
    //
    status = CxLoad(RegistryPath);

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

#ifdef MM_IN_CLUSNET

    //
    // Load the membership component
    //
    status = CmmLoad(RegistryPath);

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

#endif // MM_IN_CLUSNET

    //
    // make ksecdd non-pagable so we can sign and verify
    // signatures at raised IRQL
    //

    status = SecSetPagingMode( FALSE );
    
    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

    SecurityPagingModeSet = TRUE;

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[ClusNet] Loaded.\n"));
    }

    return(STATUS_SUCCESS);


error_exit:

    DriverUnload(CnDriverObject);

    return(status);
}


VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Unloads the driver.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

Return Value:

    None

--*/
{
    PAGED_CODE();

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[ClusNet] Unloading...\n"));
    }

    CnTrace(HBEAT_ERROR,0, "[ClusNet] Unloading...\n");

    //
    // First, force a shutdown.
    //
    CnShutdown();

    //
    // Now unload the components.
    //
#ifdef MM_IN_CLUSNET

    CmmUnload();

#endif // MM_IN_CLUSNET

    CxUnload();

#ifdef MEMLOGGING
    //
    // initialize the in-memory log
    //

    CnFreeMemoryLog();
#endif // MEMLOGGING

    if (CdpAdminSecurityDescriptor != NULL) {
        ExFreePool(CdpAdminSecurityDescriptor);
        CdpAdminSecurityDescriptor = NULL;
    }
    
    CnDeleteDeviceObjects();

    if (CnResource != NULL) {
        ExDeleteResourceLite(CnResource);
        CnFreePool(CnResource); CnResource = NULL;
    }

    CnDriverObject = NULL;

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[ClusNet] Unloaded.\n"));
    }

    if (EventLookasideList != NULL) {
        ExDeleteNPagedLookasideList( EventLookasideList );
        CnFreePool( EventLookasideList ); EventLookasideList = NULL;
    }

    //
    // finally, allow the security driver to return to nonpaged mode
    //

    if ( SecurityPagingModeSet ) {
        SecSetPagingMode( TRUE );
    }

    WPP_CLEANUP(DriverObject);

    return;

} // DriverUnload


NTSTATUS
CnCreateDeviceObjects(
    IN PDRIVER_OBJECT   DriverObject
    )
/*++

Routine Description:

    Creates the device objects exported by the driver.

Arguments:

    DriverObject   - Pointer to the driver object created by the system.

Return Value:

    An NT status code.

--*/
{
    NTSTATUS        status;
    UNICODE_STRING  deviceName;


    //
    // Create the driver control device
    //
    RtlInitUnicodeString(&deviceName, DD_CLUSNET_DEVICE_NAME);

    status = IoCreateDevice(
                 DriverObject,
                 0,
                 &deviceName,
                 FILE_DEVICE_NETWORK,
                 0,
                 FALSE,
                 &CnDeviceObject
                 );

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[ClusNet] Failed to create %ws device object, status %lx\n",
            deviceName.Buffer,
            status
            ));
        return(status);
    }

    CnDeviceObject->Flags |= DO_DIRECT_IO;
    CnDeviceObject->StackSize = CN_DEFAULT_IRP_STACK_SIZE;

    status = IoRegisterShutdownNotification(CnDeviceObject);

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[ClusNet] Failed to register for shutdown notification, status %lx\n",
            status
            ));
    }

#if defined(WMI_TRACING)
    status = IoWMIRegistrationControl (CnDeviceObject, WMIREG_ACTION_REGISTER);
    if (!NT_SUCCESS(status)) {
        CNPRINT(("[ClusNet] Failed to register for WMI Support, %lx\n", status) );
    }
#endif

    //
    // Create the datagram transport device
    //
    RtlInitUnicodeString(&deviceName, DD_CDP_DEVICE_NAME);

    status = IoCreateDevice(
                 DriverObject,
                 0,
                 &deviceName,
                 FILE_DEVICE_NETWORK,
                 0,
                 FALSE,
                 &CdpDeviceObject
                 );

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[ClusNet] Failed to create %ws device object, status %lx\n",
            deviceName.Buffer,
            status
            ));
        return(status);
    }

    CdpDeviceObject->Flags |= DO_DIRECT_IO;
    CdpDeviceObject->StackSize = CDP_DEFAULT_IRP_STACK_SIZE;

    return(STATUS_SUCCESS);
}


VOID
CnDeleteDeviceObjects(
    VOID
    )
/*++

Routine Description:

    Deletes the device objects exported by the driver.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    if (CnDeviceObject != NULL) {
#if defined(WMI_TRACING)
        IoWMIRegistrationControl(CnDeviceObject, WMIREG_ACTION_DEREGISTER);
#endif
        IoDeleteDevice(CnDeviceObject);
        CnDeviceObject = NULL;
    }

    if (CdpDeviceObject != NULL) {
        IoDeleteDevice(CdpDeviceObject);
        CdpDeviceObject = NULL;
    }

    return;
}

NTSTATUS
CnInitialize(
    IN CL_NODE_ID  LocalNodeId,
    IN ULONG       MaxNodes
    )
/*++

Routine Description:

    Initialization routine for the Cluster Network Driver.
    Called when an initialize request is received.

Arguments:

    LocalNodeId - The ID of the local node.

    MaxNodes - The maximum number of valid cluster nodes.

Return Value:

    An NT status code.

--*/
{
    NTSTATUS   status;

    if ( (MaxNodes == 0) ||
         (LocalNodeId < ClusterMinNodeId) ||
         (LocalNodeId > (ClusterMinNodeId + MaxNodes - 1))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] Initializing...\n"));
    }

    CnState = CnStateInitializePending;

    //
    // Reset global values
    //
    CnAssert(CnLocalNodeId == ClusterInvalidNodeId);
    CnAssert(CnMinValidNodeId == ClusterInvalidNodeId);
    CnAssert(CnMaxValidNodeId == ClusterInvalidNodeId);

    CnMinValidNodeId = ClusterMinNodeId;
    CnMaxValidNodeId = ClusterMinNodeId + MaxNodes - 1;
    CnLocalNodeId = LocalNodeId;

    //
    // Initialize the IP Address support
    //
    status = IpaInitialize();

    if (status != STATUS_SUCCESS) {
        goto error_exit;
    }

#ifdef MM_IN_CLUSNET

    //
    // Call the Membership Manager's init routine. This will in turn call
    // the Transport's init routine.
    //
    status = CmmInitialize();

#else  // MM_IN_CLUSNET

    status = CxInitialize();

#endif  // MM_IN_CLUSNET

    if (status == STATUS_SUCCESS) {
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] Initialized.\n"));
        }

        CnState = CnStateInitialized;
    }
    else {
        goto error_exit;
    }

    return(STATUS_SUCCESS);

error_exit:

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] Initialization failed, Shutting down. Status = %08X\n",
                 status));
    }

    CnShutdown();

    return(status);

} // CnInitialize

NTSTATUS
CnShutdown(
    VOID
    )
/*++

Routine Description:

    Terminates operation of the Cluster Membership Manager.
    Called when the Cluster Service is shutting down.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS   status;


    if ( (CnState == CnStateInitialized) ||
         (CnState == CnStateInitializePending)
       )
    {
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] Shutting down...\n"));
        }

        CnState = CnStateShutdownPending;

        //
        // Shutdown the NetBT and IP Address support.
        //
        NbtIfShutdown();
        IpaShutdown();

#ifdef MM_IN_CLUSNET

        //
        // Shutdown the Membership Manager. This will shutdown the
        // Transport as a side-effect.
        //
        CmmShutdown();

#else  // MM_IN_CLUSNET

        CxShutdown();

#endif  // MM_IN_CLUSNET

        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] Shutdown complete.\n"));
        }

        CnAssert(CnLocalNodeId != ClusterInvalidNodeId);

        CnMinValidNodeId = ClusterInvalidNodeId;
        CnMaxValidNodeId = ClusterInvalidNodeId;
        CnLocalNodeId = ClusterInvalidNodeId;

        CnState = CnStateShutdown;

        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_DEVICE_NOT_READY;
    }

    //
    // always test if we have a handle to this process
    // and remove it
    //

    if ( ClussvcProcessHandle ) {

        CnCloseProcessHandle( ClussvcProcessHandle );
        ClussvcProcessHandle = NULL;
    }

    return(status);

} // CnShutdown


VOID
CnShutdownWorkRoutine(
    IN PVOID WorkItem
    )
{
    BOOLEAN acquired;
    NTSTATUS Status;

    acquired = CnAcquireResourceExclusive(CnResource, TRUE);

    if (!acquired) {
        KIRQL  irql;

        CNPRINT(("[Clusnet] Failed to acquire CnResource\n"));

        KeAcquireSpinLock(&CnShutdownLock, &irql);
        CnShutdownScheduled = FALSE;
        if (CnShutdownEvent != NULL) {
            KeSetEvent(CnShutdownEvent, IO_NO_INCREMENT, FALSE);
        }
        KeReleaseSpinLock(&CnShutdownLock, irql);

        return;
    }

    (VOID) CnShutdown();

    if (CnShutdownEvent != NULL) {
        KeSetEvent(CnShutdownEvent, IO_NO_INCREMENT, FALSE);
    }

    if (acquired) {
        CnReleaseResourceForThread(
            CnResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }

    //
    // Leave CnShutdownScheduled = TRUE until we are reinitialized to
    // prevent scheduling unnecessary work items.
    //

    return;

} // CnShutdownWorkRoutine


BOOLEAN
CnHaltOperation(
    IN PKEVENT     ShutdownEvent    OPTIONAL
    )
/*++

Routine Description:

    Schedules a critical worker thread to perform clusnet shutdown,
    if a thread is not already scheduled.
    
Arguments:

    ShutdownEvent - if provided, event to be signalled after 
                    shutdown is complete
                    
Return value:

    TRUE if shutdown was scheduled. FALSE if shutdown was already
    scheduled (in which case ShutdownEvent will not be signalled).
    
--*/
{
    KIRQL             irql;

    // Disable further processing of Clussvc to Clusnet Hbs.
    ClussvcClusnetHbTimeoutAction = ClussvcHangActionDisable;
    InterlockedExchange(&ClussvcClusnetHbTickCount, 0);
    ClussvcClusnetHbTimeoutTicks = 0; 

    KeAcquireSpinLock(&CnShutdownLock, &irql);

    if (CnShutdownScheduled) {
        KeReleaseSpinLock(&CnShutdownLock, irql);

        return(FALSE);
    }

    CnShutdownScheduled = TRUE;
    CnShutdownEvent = ShutdownEvent;

    KeReleaseSpinLock(&CnShutdownLock, irql);

    //
    // Schedule a critical worker thread to do the shutdown work.
    //
    ExInitializeWorkItem(
        &CnShutdownWorkItem,
        CnShutdownWorkRoutine,
        &CnShutdownWorkItem
        );

    ExQueueWorkItem(&CnShutdownWorkItem, CriticalWorkQueue);

    return(TRUE);

} // CnHaltOperation


//
// ExResource wrappers that disable APCs.
//
BOOLEAN
CnAcquireResourceExclusive(
    IN PERESOURCE  Resource,
    IN BOOLEAN     Wait
    )
{
    BOOLEAN  acquired;


    KeEnterCriticalRegion();

    acquired = ExAcquireResourceExclusiveLite(Resource, Wait);

    if (!acquired) {
        KeLeaveCriticalRegion();
    }

    return(acquired);

} // CnAcquireResourceExclusive


BOOLEAN
CnAcquireResourceShared(
    IN PERESOURCE  Resource,
    IN BOOLEAN     Wait
    )
{
    BOOLEAN  acquired;


    KeEnterCriticalRegion();

    acquired = ExAcquireResourceSharedLite(Resource, Wait);

    if (!acquired) {
        KeLeaveCriticalRegion();
    }

    return(acquired);

} // CnAcquireResourceShared


VOID
CnReleaseResourceForThread(
    IN PERESOURCE         Resource,
    IN ERESOURCE_THREAD   ResourceThreadId
    )
{
    ExReleaseResourceForThreadLite(Resource, ResourceThreadId);

    KeLeaveCriticalRegion();

    return;

} // CnReleaseResourceForThread



NTSTATUS
CnCloseProcessHandle(
    HANDLE Handle
    )

/*++

Routine Description:

    Close the cluster service process handle

Arguments:

    None

Return Value:

    None

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    CnAssert( Handle != NULL );

    KeAttachProcess( CnSystemProcess );
    Status = ZwClose( Handle );
    KeDetachProcess();

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] Process handle released. status = %08X\n", Status));
    }

    return Status;
}



VOID
CnEnableHaltProcessing(
    VOID
    )
/*++

Routine Description:

    Initializes global data for halt processing.
    
Arguments:

    None
    
Return Value:

    None
    
--*/
{
    KIRQL               irql;

    KeAcquireSpinLock(&CnShutdownLock, &irql);
    CnShutdownScheduled = FALSE;
    CnShutdownEvent = NULL;
    KeReleaseSpinLock(&CnShutdownLock, irql);

    return;

} // CnEnableHaltProcessing


VOID
CnAdjustDeviceObjectStackSize(
    PDEVICE_OBJECT ClusnetDeviceObject,
    PDEVICE_OBJECT TargetDeviceObject
    )
/*++

Routine Description

    Adjust the StackSize of ClusnetDeviceObject so that we
    can pass client IRPs down to TargetDeviceObject.
    
    The StackSize of clusnet device objects is initialized to
    a default that allows for some leeway for attached drivers.
    
Arguments
    
    ClusnetDeviceObject - clusnet device object whose StackSize
        should be adjusted
        
    TargetDeviceObject - device object clusnet IRPs, originally
        issued to clusnet, will be forwarded to
        
Return value

    None
    
--*/
{
    CCHAR defaultStackSize, newStackSize = 0;
    KIRQL irql;

    if (ClusnetDeviceObject == CnDeviceObject) {
        defaultStackSize = CN_DEFAULT_IRP_STACK_SIZE;
    }
    else if (ClusnetDeviceObject == CdpDeviceObject) {
        defaultStackSize = CDP_DEFAULT_IRP_STACK_SIZE;
    }
    else {
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] CnAdjustDeviceObjectStackSize: "
                     "unknown clusnet device object %p.\n",
                     ClusnetDeviceObject
                     ));
        }
        return;
    }

    KeAcquireSpinLock(&CnDeviceObjectStackSizeLock, &irql);

    if (ClusnetDeviceObject->StackSize < 
        TargetDeviceObject->StackSize + defaultStackSize) {

        ClusnetDeviceObject->StackSize = 
            TargetDeviceObject->StackSize + defaultStackSize;
        
        IF_CNDBG(CN_DEBUG_INIT) {
            newStackSize = ClusnetDeviceObject->StackSize;
        }
    }

    KeReleaseSpinLock(&CnDeviceObjectStackSizeLock, irql);

    IF_CNDBG(CN_DEBUG_INIT) {
        if (newStackSize != 0) {
            CNPRINT(("[Clusnet] Set StackSize of clusnet device "
                     "object %p to %d "
                     "based on target device object %p.\n",
                     ClusnetDeviceObject,
                     newStackSize,
                     TargetDeviceObject
                     ));
        }
    }

    return;

} // CnAdjustDeviceObjectStackSize


NTSTATUS
CnBuildDeviceAcl(
    OUT PACL *DeviceAcl
    )

/*++

Routine Description:

    This routine builds an ACL which gives Administrators, 
    LocalSystem, and NetworkService principals full access. 
    All other principals have no access.

Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

Notes:

    This code was lifted from AFD.

--*/
{
    PGENERIC_MAPPING genericMapping;
    ULONG            aclLength;
    NTSTATUS         status;
    ACCESS_MASK      accessMask = GENERIC_ALL;
    PACL             newAcl;

    PAGED_CODE();

    //
    // Enable access to all the globally defined SIDs
    //

    genericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask( &accessMask, genericMapping );

    aclLength = sizeof( ACL )                    +
                3 * FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                RtlLengthSid( SeExports->SeAliasAdminsSid ) +
                RtlLengthSid( SeExports->SeLocalSystemSid ) +
                RtlLengthSid( SeExports->SeNetworkServiceSid );

    newAcl = ExAllocatePoolWithTag(
                 PagedPool,
                 aclLength,
                 CN_POOL_TAG
                 );

    if (newAcl == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    status = RtlCreateAcl (newAcl, aclLength, ACL_REVISION );

    if (!NT_SUCCESS(status)) {
        ExFreePoolWithTag(
            newAcl,
            CN_POOL_TAG
            );
        return (status);
    }

    status = RtlAddAccessAllowedAce (
                 newAcl,
                 ACL_REVISION2,
                 accessMask,
                 SeExports->SeAliasAdminsSid
                 );

    CnAssert(NT_SUCCESS(status));

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[ClusNet] Failed to add Admin to ACL, error: %lx\n", 
            status
            ));
        return(status);
    }

    status = RtlAddAccessAllowedAce (
                 newAcl,
                 ACL_REVISION2,
                 accessMask,
                 SeExports->SeLocalSystemSid
                 );

    CnAssert(NT_SUCCESS(status));

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[ClusNet] Failed to add LocalSystem to ACL, error: %lx\n",
            status
            ));
        return(status);
    }

    status = RtlAddAccessAllowedAce (
                 newAcl,
                 ACL_REVISION2,
                 accessMask,
                 SeExports->SeNetworkServiceSid
                 );

    CnAssert(NT_SUCCESS(status));

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[ClusNet] Failed to add NetworkService to ACL, error: %lx. "
            "(Non-fatal error)\n",
            status
            ));
    }

    *DeviceAcl = newAcl;

    return (STATUS_SUCCESS);

} // CnBuildDeviceAcl


NTSTATUS
CnCreateSecurityDescriptor(
    VOID
    )

/*++

Routine Description:

    This routine creates a security descriptor which gives access
    only to certain priviliged accounts. This descriptor is used
    to access check CDP socket opens.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

Notes:

    This code was lifted from AFD.

--*/
{
    PACL                  devAcl = NULL;
    NTSTATUS              status;
    BOOLEAN               memoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR  cdpSecurityDescriptor;
    ULONG                 cdpSecurityDescriptorLength;
    CHAR                  buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR  localSecurityDescriptor =
                              (PSECURITY_DESCRIPTOR)buffer;
    PSECURITY_DESCRIPTOR  localCdpAdminSecurityDescriptor;
    SECURITY_INFORMATION  securityInformation = DACL_SECURITY_INFORMATION;


    PAGED_CODE();

    //
    // Get a pointer to the security descriptor from the CDP device object.
    //
    status = ObGetObjectSecurity(
                 CdpDeviceObject,
                 &cdpSecurityDescriptor,
                 &memoryAllocated
                 );

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[ClusNet] Failed to get CDP device object security descriptor, "
            "status %lx\n",
            status
            ));
        return(status);
    }

    //
    // Build a local security descriptor with an ACL giving only
    // certain priviliged accounts.
    //
    status = CnBuildDeviceAcl(&devAcl);

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[ClusNet] Failed to create Raw ACL, error: %lx\n", 
            status
            ));
        goto error_exit;
    }

    (VOID) RtlCreateSecurityDescriptor(
               localSecurityDescriptor,
               SECURITY_DESCRIPTOR_REVISION
               );

    (VOID) RtlSetDaclSecurityDescriptor(
               localSecurityDescriptor,
               TRUE,
               devAcl,
               FALSE
               );

    //
    // Make a copy of the CDP descriptor. This copy will be 
    // the raw descriptor.
    //
    cdpSecurityDescriptorLength = RtlLengthSecurityDescriptor(
                                      cdpSecurityDescriptor
                                      );

    localCdpAdminSecurityDescriptor = ExAllocatePoolWithTag (
                                          PagedPool,
                                          cdpSecurityDescriptorLength,
                                          CN_POOL_TAG
                                          );

    if (localCdpAdminSecurityDescriptor == NULL) {
        CNPRINT((
            "[ClusNet]: failed to allocate security descriptor "
            "of size %d.\n",
            cdpSecurityDescriptorLength
            ));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error_exit;
    }

    RtlMoveMemory(
        localCdpAdminSecurityDescriptor,
        cdpSecurityDescriptor,
        cdpSecurityDescriptorLength
        );

    CdpAdminSecurityDescriptor = localCdpAdminSecurityDescriptor;

    //
    // Now apply the local descriptor to the raw descriptor.
    //
    status = SeSetSecurityDescriptorInfo(
                 NULL,
                 &securityInformation,
                 localSecurityDescriptor,
                 &CdpAdminSecurityDescriptor,
                 PagedPool,
                 IoGetFileObjectGenericMapping()
                 );

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[ClusNet]: SeSetSecurity failed for CDP admin "
            "security descriptor, %lx\n",
            status
            ));
        CnAssert(CdpAdminSecurityDescriptor == localCdpAdminSecurityDescriptor);
        ExFreePool(CdpAdminSecurityDescriptor);
        CdpAdminSecurityDescriptor = NULL;
        goto error_exit;
    }

    if (CdpAdminSecurityDescriptor != localCdpAdminSecurityDescriptor) {
        ExFreePool(localCdpAdminSecurityDescriptor);
    }

    status = STATUS_SUCCESS;

error_exit:

    ObReleaseObjectSecurity(
        cdpSecurityDescriptor,
        memoryAllocated
        );

    if (devAcl != NULL) {
        ExFreePoolWithTag(
            devAcl,
            CN_POOL_TAG
            );
    }

    return(status);
    
} // CnCreateSecurityDescriptor



#if DBG

//
// Debug code.
//

ULONG         CnCpuLockMask[MAXIMUM_PROCESSORS];

VOID
CnAssertBreak(
    PCHAR FailedStatement,
    PCHAR FileName,
    ULONG LineNumber
    )
{
    DbgPrint(
        "[Clusnet] Assertion \"%s\" failed in %s line %u\n",
        FailedStatement,
        FileName,
        LineNumber
        );
    DbgBreakPoint();

    return;

}  // CnAssertBreak


ULONG
CnGetCpuLockMask(
    VOID
    )
{
    ULONG   mask;

    if (KeGetCurrentIrql() != DISPATCH_LEVEL) {
        CnAssert(CnCpuLockMask[KeGetCurrentProcessorNumber()] == 0);
        mask = 0;
    }
    else {
        mask = CnCpuLockMask[KeGetCurrentProcessorNumber()];
    }

    return(mask);
}


VOID
CnVerifyCpuLockMask(
    IN ULONG RequiredLockMask,
    IN ULONG ForbiddenLockMask,
    IN ULONG MaximumLockMask
    )
{
    ULONG   mask;


    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        mask = 0;
    }
    else {
        mask = CnCpuLockMask[KeGetCurrentProcessorNumber()];
    }

    if ((mask & RequiredLockMask) != RequiredLockMask) {
        CNPRINT((
            "[Clusnet] Locking bug: Req'd lock mask %lx, actual mask %lx\n",
            RequiredLockMask,
            mask
            ));
        DbgBreakPoint();
    }

    if (mask & ForbiddenLockMask) {
        CNPRINT((
            "[Clusnet] Locking bug: Forbidden mask %lx, actual mask %lx\n",
            ForbiddenLockMask,
            mask
            ));
        DbgBreakPoint();
    }

    if (mask > MaximumLockMask) {
        CNPRINT((
            "[Clusnet] Locking bug: Max lock mask %lx, actual mask %lx\n",
            MaximumLockMask,
            mask
            ));
        DbgBreakPoint();
    }

    return;
}

VOID
CnInitializeLock(
    PCN_LOCK  Lock,
    ULONG     Rank
    )
{
    KeInitializeSpinLock(&(Lock->SpinLock));
    Lock->Rank = Rank;

    return;
}


VOID
CnAcquireLock(
    IN  PCN_LOCK   Lock,
    OUT PCN_IRQL   Irql
    )
{
    KIRQL   irql;
    ULONG   currentCpu;



    if (KeGetCurrentIrql() != DISPATCH_LEVEL) {
        KeRaiseIrql(DISPATCH_LEVEL, &irql);
    }
    else {
        irql = DISPATCH_LEVEL;
    }

    currentCpu = KeGetCurrentProcessorNumber();

    if (CnCpuLockMask[currentCpu] >= Lock->Rank) {
        CNPRINT((
            "[Clusnet] CPU %u trying to acquire lock %lx out of order, mask %lx\n",
            currentCpu,
            Lock->Rank,
            CnCpuLockMask[currentCpu]
            ));

        DbgBreakPoint();
    }

    KeAcquireSpinLockAtDpcLevel(&(Lock->SpinLock));
    *Irql = irql;

    CnCpuLockMask[currentCpu] |= Lock->Rank;

    return;
}


VOID
CnAcquireLockAtDpc(
    IN  PCN_LOCK   Lock
    )
{
    ULONG   currentCpu = KeGetCurrentProcessorNumber();


    if (KeGetCurrentIrql() !=  DISPATCH_LEVEL) {
        CNPRINT((
            "[Clusnet] CPU %u trying to acquire DPC lock at passive level.\n",
            currentCpu
            ));

        DbgBreakPoint();
    }

    if (CnCpuLockMask[currentCpu] >= Lock->Rank) {
        CNPRINT((
            "[Clusnet] CPU %u trying to acquire lock %lx out of order, mask %lx\n",
            currentCpu,
            Lock->Rank,
            CnCpuLockMask[currentCpu]
            ));

        DbgBreakPoint();
    }

    KeAcquireSpinLockAtDpcLevel(&(Lock->SpinLock));

    CnCpuLockMask[currentCpu] |= Lock->Rank;

    return;
}


VOID
CnReleaseLock(
    IN  PCN_LOCK   Lock,
    IN  CN_IRQL    Irql
    )
{
    ULONG currentCpu = KeGetCurrentProcessorNumber();

    if (KeGetCurrentIrql() !=  DISPATCH_LEVEL) {
        CNPRINT((
            "[Clusnet] CPU %u trying to release lock from passive level.\n",
            currentCpu
            ));

        DbgBreakPoint();
    }

    if ( !(CnCpuLockMask[currentCpu] & Lock->Rank) ) {
        CNPRINT((
            "[Clusnet] CPU %u trying to release lock %lx, which it doesn't hold, mask %lx\n",
            currentCpu,
            Lock->Rank,
            CnCpuLockMask[currentCpu]
            ));

        DbgBreakPoint();
    }

    CnCpuLockMask[currentCpu] &= ~(Lock->Rank);

    KeReleaseSpinLock(&(Lock->SpinLock), Irql);

    return;
}


VOID
CnReleaseLockFromDpc(
    IN  PCN_LOCK   Lock
    )
{
    ULONG currentCpu = KeGetCurrentProcessorNumber();


    if (KeGetCurrentIrql() !=  DISPATCH_LEVEL) {
        CNPRINT((
            "[Clusnet] CPU %u trying to release lock from passive level.\n",
            currentCpu
            ));

        DbgBreakPoint();
    }

    if ( !(CnCpuLockMask[currentCpu] & Lock->Rank) ) {
        CNPRINT((
            "[Clusnet] CPU %u trying to release lock %lx, which it doesn't hold, mask %lx\n",
            currentCpu,
            Lock->Rank,
            CnCpuLockMask[currentCpu]
            ));

        DbgBreakPoint();
    }

    CnCpuLockMask[currentCpu] &= ~(Lock->Rank);

    KeReleaseSpinLockFromDpcLevel(&(Lock->SpinLock));

    return;
}


VOID
CnMarkIoCancelLockAcquired(
    VOID
    )
{
    ULONG currentCpu = KeGetCurrentProcessorNumber();

    CnAssert(KeGetCurrentIrql() == DISPATCH_LEVEL);

    CnAssert(!(CnCpuLockMask[currentCpu] & CN_IOCANCEL_LOCK));
    CnAssert(CnCpuLockMask[currentCpu] < CN_IOCANCEL_LOCK_MAX);

    CnCpuLockMask[currentCpu] |= CN_IOCANCEL_LOCK;

    return;
}


VOID
CnAcquireCancelSpinLock(
    OUT PCN_IRQL   Irql
    )
{

    KIRQL   irql;
    KIRQL   tempIrql;
    ULONG   currentCpu;


    if (KeGetCurrentIrql() != DISPATCH_LEVEL) {
        KeRaiseIrql(DISPATCH_LEVEL, &irql);
    }
    else {
        irql = DISPATCH_LEVEL;
    }

    currentCpu = KeGetCurrentProcessorNumber();

    if (CnCpuLockMask[currentCpu] >= CN_IOCANCEL_LOCK) {
        CNPRINT((
            "[Clusnet] CPU %u trying to acquire IoCancel lock out of order, mask %lx\n",
            currentCpu,
            CnCpuLockMask[currentCpu]
            ));

        DbgBreakPoint();
    }

    IoAcquireCancelSpinLock(&tempIrql);

    CnAssert(tempIrql == DISPATCH_LEVEL);

    *Irql = irql;

    CnCpuLockMask[currentCpu] |= CN_IOCANCEL_LOCK;

    return;
}


VOID
CnReleaseCancelSpinLock(
    IN CN_IRQL     Irql
    )
{
    ULONG currentCpu = KeGetCurrentProcessorNumber();


    if (KeGetCurrentIrql() !=  DISPATCH_LEVEL) {
        CNPRINT((
            "[Clusnet] CPU %u trying to release lock from passive level.\n",
            currentCpu
            ));

        DbgBreakPoint();
    }

    if ( !(CnCpuLockMask[currentCpu] & CN_IOCANCEL_LOCK) ) {
        CNPRINT((
            "[Clusnet] CPU %u trying to release IoCancel lock, which it doesn't hold, mask %lx\n",
            currentCpu,
            CnCpuLockMask[currentCpu]
            ));

        DbgBreakPoint();
    }

    CnCpuLockMask[currentCpu] &= ~(CN_IOCANCEL_LOCK);

    IoReleaseCancelSpinLock(Irql);

    return;

}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\driver\precomp.h ===
#include "clusnet.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\driver\errorlog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    errorlog.c

Abstract:

    This module implements the error logging in the server.

    !!! This module must be nonpageable.

Author:

    Manny Weiser (mannyw)    11-Feb-92

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <windef.h>
#include <align.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, CnWriteErrorLogEntry)
#endif

ULONG CnSequenceNumber = 0;

//#pragma optimize("",off)

VOID
_cdecl
CnWriteErrorLogEntry(
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID ExtraInformationBuffer,
    IN USHORT ExtraInformationLength,
    IN USHORT NumberOfInsertionStrings,
    ...
    )

#define LAST_NAMED_ARGUMENT NumberOfInsertionStrings

/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:



Return Value:

    None.


--*/
{

    PIO_ERROR_LOG_PACKET ErrorLogEntry;
    int TotalErrorLogEntryLength;
    ULONG SizeOfStringData = 0;
    va_list ParmPtr;                    // Pointer to stack parms.
    ULONG Length;

    PAGED_CODE();

    if (NumberOfInsertionStrings != 0) {
        ULONG i;

        va_start(ParmPtr, LAST_NAMED_ARGUMENT);

        for (i = 0; i < NumberOfInsertionStrings; i += 1) {

            PWSTR String = va_arg(ParmPtr, PWSTR);

            Length = wcslen(String);
            while ( (Length > 0) && (String[Length-1] == L' ') ) {
                Length--;
            }

            SizeOfStringData += (Length + 1) * sizeof(WCHAR);
        }
    }

    //
    //  Ideally we want the packet to hold the servername and ExtraInformation.
    //  Usually the ExtraInformation gets truncated.
    //

    TotalErrorLogEntryLength =
         min( ExtraInformationLength + sizeof(IO_ERROR_LOG_PACKET) + 1 + SizeOfStringData,
              ERROR_LOG_MAXIMUM_SIZE );

    ErrorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        (PDEVICE_OBJECT)CnDeviceObject,
        (UCHAR)TotalErrorLogEntryLength
        );

    if (ErrorLogEntry != NULL) {
        PCHAR DumpData;
        ULONG RemainingSpace = TotalErrorLogEntryLength -
            FIELD_OFFSET( IO_ERROR_LOG_PACKET, DumpData );
        ULONG i;
        ULONG SizeOfRawData;

        if (RemainingSpace > SizeOfStringData) {
            SizeOfRawData = RemainingSpace - SizeOfStringData;
        } else {
            SizeOfStringData = RemainingSpace;

            SizeOfRawData = 0;
        }

        //
        // Fill in the error log entry
        //

        ErrorLogEntry->ErrorCode = UniqueErrorCode;
        ErrorLogEntry->MajorFunctionCode = 0;
        ErrorLogEntry->RetryCount = 0;
        ErrorLogEntry->UniqueErrorValue = 0;
        ErrorLogEntry->FinalStatus = NtStatusCode;
        ErrorLogEntry->IoControlCode = 0;
        ErrorLogEntry->DeviceOffset.LowPart = 0;
        ErrorLogEntry->DeviceOffset.HighPart = 0;
        ErrorLogEntry->SequenceNumber = (ULONG)CnSequenceNumber ++;
        ErrorLogEntry->StringOffset = (USHORT)(ROUND_UP_COUNT(
                    FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) + SizeOfRawData,
                    ALIGN_WORD));

        DumpData = (PCHAR)ErrorLogEntry->DumpData;

        //
        // Append the extra information.  This information is typically
        // an SMB header.
        //

        if (( ARGUMENT_PRESENT( ExtraInformationBuffer )) &&
            ( SizeOfRawData != 0 )) {

            Length = min(ExtraInformationLength, (USHORT)SizeOfRawData);
            RtlCopyMemory(
                DumpData,
                ExtraInformationBuffer,
                Length);
            ErrorLogEntry->DumpDataSize = (USHORT)Length;
        } else {
            ErrorLogEntry->DumpDataSize = 0;
        }

        ErrorLogEntry->NumberOfStrings = 0;

        if (NumberOfInsertionStrings != 0) {
            PWSTR StringOffset = (PWSTR)((PCHAR)ErrorLogEntry + ErrorLogEntry->StringOffset);
            PWSTR InsertionString;

            //
            // Set up ParmPtr to point to first of the caller's parameters.
            //

            va_start(ParmPtr, LAST_NAMED_ARGUMENT);

            for (i = 0 ; i < NumberOfInsertionStrings ; i+= 1) {
                InsertionString = va_arg(ParmPtr, PWSTR);
                Length = wcslen(InsertionString);
                while ( (Length > 0) && (InsertionString[Length-1] == L' ') ) {
                    Length--;
                }

                if ( ((Length + 1) * sizeof(WCHAR)) > SizeOfStringData ) {
                    Length = ( SizeOfStringData / sizeof( WCHAR )) - 1;
                }

                if ( Length > 0 ) {
                    RtlCopyMemory(StringOffset, InsertionString, Length*sizeof(WCHAR));
                    StringOffset += Length;
                    *StringOffset++ = L'\0';

                    SizeOfStringData -= (Length + 1) * sizeof(WCHAR);

                    ErrorLogEntry->NumberOfStrings += 1;
                }
            }

        }

        IoWriteErrorLogEntry(ErrorLogEntry);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\driver\resource.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Generic resource management routines for the Cluster Network driver.

Author:

    Mike Massa (mikemas)           February 12, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-12-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop


PCN_RESOURCE
CnAllocateResource(
    IN PCN_RESOURCE_POOL   Pool
    )
/*++

Routine Description:

    Allocates a resource from a resource pool.

Arguments:

    Pool - A pointer to the pool from which to allocate a resource.

Return Value:

    A pointer to the allocated resource if successful.
    NULL if unsuccessful.

--*/
{
    PCN_RESOURCE        resource;
    PSLIST_ENTRY  entry = ExInterlockedPopEntrySList(
                              &(Pool->ResourceList),
                              &(Pool->ResourceListLock)
                              );

    if (entry != NULL) {
        resource = CONTAINING_RECORD(entry, CN_RESOURCE, Linkage);
    }
    else {
        resource = (*(Pool->CreateRoutine))(Pool->CreateContext);

        if (resource != NULL) {
            CN_INIT_SIGNATURE(resource, CN_RESOURCE_SIG);
            resource->Pool = Pool;
        }
    }

    return(resource);

}  // CnAllocateResource


VOID
CnFreeResource(
    PCN_RESOURCE   Resource
    )
/*++

Routine Description:

    Frees a resource back to a resource pool.

Arguments:

    Resource - A pointer to the resource to free.

Return Value:

    None.

--*/
{
    PCN_RESOURCE_POOL  pool = Resource->Pool;


    if (ExQueryDepthSList(&(pool->ResourceList)) < pool->Depth) {
        ExInterlockedPushEntrySList(
            &(pool->ResourceList),
            &(Resource->Linkage),
            &(pool->ResourceListLock)
            );
    }
    else {
        (*(pool->DeleteRoutine))(Resource);
    }

    return;

} // CnpFreeResource


VOID
CnDrainResourcePool(
    PCN_RESOURCE_POOL   Pool
    )
/*++

Routine Description:

    Frees all cached resources in a resource pool in preparation for the
    pool to be destroyed. This routine does not free the memory containing
    the pool.

Arguments:

    Pool - A pointer to the pool to drain.

Return Value:

    None.

--*/
{
    PSLIST_ENTRY  entry;
    PCN_RESOURCE  resource;


    while ( (entry = ExInterlockedPopEntrySList(
                         &(Pool->ResourceList),
                         &(Pool->ResourceListLock)
                         )
            ) != NULL
          )
    {
        resource = CONTAINING_RECORD(entry, CN_RESOURCE, Linkage);

        (*(Pool->DeleteRoutine))(resource);
    }

    return;

}  // CnDrainResourcePool
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\inc\clusnet.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    clusnet.h

Abstract:

    Top-level, common header file for the Cluster Network Driver.
    Defines common driver structures.

Author:

    Mike Massa (mikemas)           January 3, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-03-97    created

Notes:

--*/

#ifndef _CLUSNET_INCLUDED_
#define _CLUSNET_INCLUDED_

#define _NTDDK_ // [HACKHACK] to make ProbeForRead work. Better to include ntddk instead of ntos //

#define WMI_TRACING 1

#include <ntos.h>
#include <zwapi.h>
#include <clusdef.h>
#include <ntddcnet.h>
#include <cnettest.h>
#include <ntemgmt.h>
#include <nbtmgmt.h>
#include <memlog.h>

#if defined(WMI_TRACING) 
# include "cnwmi.h"
#endif

//
// Constants
//
#define CN_POOL_TAG         'tnSC'

#define CDP_DEFAULT_IRP_STACK_SIZE  4
#define CN_DEFAULT_IRP_STACK_SIZE   4

//
// Pool Macros
//
#define CnAllocatePool(_bufsize)  \
            ExAllocatePoolWithTag(NonPagedPool, (_bufsize), CN_POOL_TAG);

#define CnAllocatePoolWithQuota(_bufsize)  \
            ExAllocatePoolWithQuotaTag(NonPagedPool, (_bufsize), CN_POOL_TAG);

#define CnFreePool(_ptr)  \
            ExFreePool((_ptr))

#define ROUND32(_value)  ( ((_value) + 3) & ~(0x3) )

//
// Init/Cleanup synchronization
//
typedef enum {
    CnStateShutdown = 0,
    CnStateShutdownPending = 1,
    CnStateInitializePending = 2,
    CnStateInitialized = 3
} CN_STATE;

// Clusnet Heart Beat Period definintion Removed from clusnet\xport\Chbeat.c
// This is it's proper place.
//
// heart beat period in millisecs
//
#define HEART_BEAT_PERIOD 600

//
// Node ID validation macro
//
#define CnIsValidNodeId(_id)  ( ((_id) >= CnMinValidNodeId) && \
                                ((_id) <= CnMaxValidNodeId) )


//
// Lock acquisition ranking. Locks must be acquired in this order to
// prevent deadlocks. Components really should avoid calling outside
// of themselves while holding locks.
//
#define CN_IOCANCEL_LOCK             0x00000001
#define CN_IOCANCEL_LOCK_MAX         0x00000001

// MM locks
#define MM_RGP_LOCK                  0x00000010
#define MM_CALLBACK_LOCK             0x00000020

// CX Locks
#define CX_PRECEEDING_LOCK_RANGE     0x0000FFFF
#define CX_LOCK_RANGE                0xFFFF0000
#define CX_ADDROBJ_TABLE_LOCK        0x00010000
#define CX_ADDROBJ_TABLE_LOCK_MAX    0x0001FFFF
#define CX_ADDROBJ_LOCK              0x00020000
#define CX_ADDROBJ_LOCK_MAX          0x0003FFFF

#define CNP_PRECEEDING_LOCK_RANGE    0x00FFFFFF
#define CNP_LOCK_RANGE               0xFF000000
#define CNP_NODE_TABLE_LOCK          0x01000000
#define CNP_NODE_TABLE_LOCK_MAX      0x01FFFFFF
#define CNP_NODE_OBJECT_LOCK         0x02000000
#define CNP_NODE_OBJECT_LOCK_MAX     0x03FFFFFF
#define CNP_NETWORK_LIST_LOCK        0x04000000
#define CNP_NETWORK_LIST_LOCK_MAX    0x07FFFFFF
#define CNP_NETWORK_OBJECT_LOCK      0x08000000
#define CNP_NETWORK_OBJECT_LOCK_MAX  0x0FFFFFFF
#define CNP_HBEAT_LOCK               0x10000000
#define CNP_EVENT_LOCK_PRECEEDING    0x1FFFFFFF
#define CNP_EVENT_LOCK               0x20000000
#define CNP_EVENT_LOCK_MAX           0x3FFFFFFF
#define CNP_SEC_CTXT_LOCK            0x20000000


//
// Debugging Definitions
//
#if DBG

#define CNPRINT(many_args) DbgPrint many_args

extern ULONG CnDebug;

#define CN_DEBUG_INIT           0x00000001
#define CN_DEBUG_OPEN           0x00000002
#define CN_DEBUG_CLEANUP        0x00000004
#define CN_DEBUG_CLOSE          0x00000008

#define CN_DEBUG_IRP            0x00000010
#define CN_DEBUG_NODEOBJ        0x00000020
#define CN_DEBUG_NETOBJ         0x00000040
#define CN_DEBUG_IFOBJ          0x00000080

#define CN_DEBUG_CONFIG         0x00000100
#define CN_DEBUG_CNPSEND        0x00000200
#define CN_DEBUG_CNPRECV        0x00000400
#define CN_DEBUG_CNPREF         0x00000800

#define CN_DEBUG_EVENT          0x00001000
#define CN_DEBUG_MMSTATE        0x00002000
#define CN_DEBUG_HBEATS         0x00004000
#define CN_DEBUG_POISON         0x00008000

#define CN_DEBUG_CDPSEND        0x00010000
#define CN_DEBUG_CDPRECV        0x00020000
#define CN_DEBUG_CCMPSEND       0x00040000
#define CN_DEBUG_CCMPRECV       0x00080000

#define CN_DEBUG_ADDROBJ        0x00100000
#define CN_DEBUG_INFO           0x00200000
#define CN_DEBUG_NTE            0x00400000
#define CN_DEBUG_NDIS           0x00800000

#define CN_DEBUG_RGP            0x10000000
#define CN_DEBUG_CMM            0x20000000
#define CN_DEBUG_CMMMSG         0x40000000
#define CN_DEBUG_CMMTIMERQ      0x80000000

#define IF_CNDBG(flag)  if (CnDebug & flag)

VOID
CnAssertBreak(
    PCHAR FailedStatement,
    PCHAR FileName,
    ULONG LineNumber
    );

#define CnAssert(_statement)  \
            if (!(_statement)) CnAssertBreak(#_statement, __FILE__, __LINE__)

#define CN_SIGNATURE_FIELD                  ULONG   Signature;
#define CN_INIT_SIGNATURE(pstruct, sig)     ((pstruct)->Signature = (sig))
#define CN_ASSERT_SIGNATURE(pstruct, sig)   CnAssert( (pstruct)->Signature == \
                                                    (sig) )

#define CN_DBGCHECK  DbgBreakPoint()

typedef struct {
    KSPIN_LOCK   SpinLock;
    ULONG        Rank;
}  CN_LOCK, *PCN_LOCK;

typedef KIRQL       CN_IRQL, *PCN_IRQL;

ULONG
CnGetCpuLockMask(
    VOID
    );

VOID
CnVerifyCpuLockMask(
    IN ULONG RequiredLockMask,
    IN ULONG ForbiddenLockMask,
    IN ULONG MaximumLockMask
    );

VOID
CnInitializeLock(
    PCN_LOCK  Lock,
    ULONG     Rank
    );

VOID
CnAcquireLock(
    IN  PCN_LOCK   Lock,
    OUT PCN_IRQL   Irql
    );

VOID
CnReleaseLock(
    IN  PCN_LOCK   Lock,
    IN  CN_IRQL    Irql
    );

VOID
CnAcquireLockAtDpc(
    IN  PCN_LOCK   Lock
    );

VOID
CnReleaseLockFromDpc(
    IN  PCN_LOCK   Lock
    );

VOID
CnMarkIoCancelLockAcquired(
    VOID
    );

VOID
CnAcquireCancelSpinLock(
    OUT PCN_IRQL   Irql
    );

VOID
CnReleaseCancelSpinLock(
    IN CN_IRQL     Irql
    );


#else // DBG


#define CNPRINT(many_args)
#define IF_CNDBG(flag)   if (0)

#define CnAssert(_statement)

#define CN_SIGNATURE_FIELD
#define CN_INIT_SIGNATURE(pstruct, sig)
#define CN_ASSERT_SIGNATURE(pstruct, sig)

#define CN_DBGCHECK

typedef KSPIN_LOCK  CN_LOCK, *PCN_LOCK;
typedef KIRQL       CN_IRQL, *PCN_IRQL;

#define CnVerifyCpuLockMask(p1, p2, p3)

#define CnInitializeLock(_plock, _rank)   KeInitializeSpinLock((_plock))
#define CnAcquireLock(_plock, _pirql)     KeAcquireSpinLock((_plock), (_pirql))
#define CnReleaseLock(_plock, _irql)      KeReleaseSpinLock((_plock), (_irql))

#define CnAcquireLockAtDpc(_plock)      KeAcquireSpinLockAtDpcLevel((_plock))
#define CnReleaseLockFromDpc(_plock)    KeReleaseSpinLockFromDpcLevel((_plock))

#define CnMarkIoCancelLockAcquired()

#define CnAcquireCancelSpinLock(_pirql)  IoAcquireCancelSpinLock((_pirql))
#define CnReleaseCancelSpinLock(_irql)   IoReleaseCancelSpinLock((_irql))

#endif // DBG


//
// File Object Context Structure
//
// A pointer to this structure is stored in FileObject->FsContext.
// It maintains context information about open file objects.
//
typedef struct {

    //
    // used by event mechanism to find interested consumers when a new event
    // is posted.
    //
    LIST_ENTRY     Linkage;

    CN_SIGNATURE_FIELD
    PFILE_OBJECT   FileObject;
    LONG           ReferenceCount;
    UCHAR          CancelIrps;
    UCHAR          ShutdownOnClose;
    UCHAR          Pad[2];
    KEVENT         CleanupEvent;

    //
    // list of event context blocks representing events to be delivered to
    // consumer
    //
    LIST_ENTRY     EventList;

    //
    // pending IRP that is completed when a new event is issued
    //
    PIRP           EventIrp; 

    //
    // event types in which this consumer is interested
    //
    ULONG          EventMask;

    //
    // routine used to notify kernel consumers of new events
    //
    CLUSNET_EVENT_CALLBACK_ROUTINE KmodeEventCallback;
} CN_FSCONTEXT, *PCN_FSCONTEXT;

#define CN_CONTROL_CHANNEL_SIG   'lrtc'


//
// Generic Resource Management Package
//

//
// Forward Declarations
//
typedef struct _CN_RESOURCE *PCN_RESOURCE;
typedef struct _CN_RESOURCE_POOL *PCN_RESOURCE_POOL;

/*++

PCN_RESOURCE
CnCreateResourceRoutine(
    IN PVOID  Context
    );

Routine Description:

    Creates a new instance of a resource to be managed by a resource pool.

Arguments:

    Context - The context value specified when the pool was initialized.

Return Value:

    A pointer to the newly created resource if successful.
    NULL if unsuccessful.

--*/
typedef
PCN_RESOURCE
(*PCN_CREATE_RESOURCE_ROUTINE)(
    IN PVOID  PoolContext
    );


/*++

PCN_RESOURCE
CnDeleteResourceRoutine(
    IN PCN_RESOURCE  Resource
    );

Routine Description:

    Destroys an instance of a resource allocated by
    CnCreateResourceRoutine().

Arguments:

    Resource - A pointer to the resource to destroy.

Return Value:

    None.

--*/
typedef
VOID
(*PCN_DELETE_RESOURCE_ROUTINE) (
    IN PCN_RESOURCE   Resource
    );

//
// Resource Pool Structure
//
typedef struct _CN_RESOURCE_POOL {
    CN_SIGNATURE_FIELD
    SLIST_HEADER                  ResourceList;
    KSPIN_LOCK                    ResourceListLock;
    USHORT                        Depth;
    USHORT                        Pad;
    PCN_CREATE_RESOURCE_ROUTINE   CreateRoutine;
    PVOID                         CreateContext;
    PCN_DELETE_RESOURCE_ROUTINE   DeleteRoutine;
} CN_RESOURCE_POOL;

#define CN_RESOURCE_POOL_SIG    'lpnc'


//
// Resource Structure
//
typedef struct _CN_RESOURCE {
    SLIST_ENTRY                  Linkage;
    CN_SIGNATURE_FIELD
    PCN_RESOURCE_POOL            Pool;
    PVOID                        Context;
} CN_RESOURCE;

#define CN_RESOURCE_SIG    'ernc'


//
// Routines for operating on Resource Pools
//

/*++

VOID
CnInitializeResourcePool(
    IN PCN_RESOURCE_POOL            Pool,
    IN USHORT                       Depth,
    IN PCN_CREATE_RESOURCE_ROUTINE  CreateRoutine,
    IN PVOID                        CreateContext,
    IN PCN_DELETE_RESOURCE_ROUTINE  DeleteRoutine,
    );

Routine Description:

    Initializes a resource pool structure.

Arguments:

    Pool - A pointer to the pool structure to initialize.

    Depth - The maximum number of items to cache in the pool.

    CreateRoutine - A pointer to the routine to call to create a new
                    instance of a resource.

    CreateContext - A context value to pass as an argument to
                    the CreateRoutine.

    DeleteRoutine - A pointer to the routine to call to destroy an instance
                    of a resource created by CreateRoutine.

Return Value

    None.

--*/
#define CnInitializeResourcePool(_pool, _depth, _creatertn, _createctx, _deletertn) \
            { \
                CN_INIT_SIGNATURE(_pool, CN_RESOURCE_POOL_SIG);       \
                ExInitializeSListHead(&((_pool)->ResourceList));      \
                KeInitializeSpinLock(&((_pool)->ResourceListLock));   \
                (_pool)->Depth = _depth;                              \
                (_pool)->CreateRoutine = _creatertn;                  \
                (_pool)->CreateContext = _createctx;                  \
                (_pool)->DeleteRoutine = _deletertn;                  \
            }

VOID
CnDrainResourcePool(
    IN PCN_RESOURCE_POOL   Pool
    );

PCN_RESOURCE
CnAllocateResource(
    IN PCN_RESOURCE_POOL   Pool
    );

VOID
CnFreeResource(
    PCN_RESOURCE   Resource
    );

/*++

VOID
CnSetResourceContext(
    IN PCN_RESOURCE  Resource,
    IN PVOID         ContextValue
    );

Routine Description:

    Sets the context value for a Resource.

Arguments:

    Resource - A pointer to the resource on which to operate.

Return Value:

    A pointer to the context value associated with the resource.

--*/
#define CnSetResourceContext(_res, _value)  ((_res)->Context = (_value))


/*++

PVOID
CnGetResourceContext(
    IN PCN_RESOURCE  Resource
    );

Routine Description:

    Retrieves the context value from a Resource.

Arguments:

    Resource - A pointer to the resource on which to operate.

Return Value:

    A pointer to the context value associated with the resource.

--*/
#define CnGetResourceContext(_res)          ((_res)->Context)





//
// Init/Cleanup Function Prototypes
//
NTSTATUS
CnInitialize(
    IN CL_NODE_ID  LocalNodeId,
    IN ULONG       MaxNodes
    );

NTSTATUS
CnShutdown(
    VOID
    );

BOOLEAN
CnHaltOperation(
    IN PKEVENT     ShutdownEvent    OPTIONAL
    );

NTSTATUS
CnCloseProcessHandle(
    HANDLE Handle
    );

VOID
CnEnableHaltProcessing(
    VOID
    );

//
// Irp Handling Routines
//
NTSTATUS
CnDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
CnDispatchInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
CnDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

#if DBG
#define CnReferenceFsContext(_fsc) \
          {  \
            LONG newValue = InterlockedIncrement(&((_fsc)->ReferenceCount)); \
            CnAssert(newValue > 1); \
          }
#else // DBG

#define CnReferenceFsContext(_fsc) \
          (VOID) InterlockedIncrement( &((_fsc)->ReferenceCount) )

#endif // DBG

VOID
CnDereferenceFsContext(
    PCN_FSCONTEXT   FsContext
    );

NTSTATUS
CnMarkRequestPending(
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PDRIVER_CANCEL      CancelRoutine
    );

VOID
CnCompletePendingRequest(
    IN PIRP      Irp,
    IN NTSTATUS  Status,
    IN ULONG     BytesReturned
    );

PFILE_OBJECT
CnBeginCancelRoutine(
    IN  PIRP     Irp
    );

VOID
CnEndCancelRoutine(
    PFILE_OBJECT    FileObject
    );

VOID
CnAdjustDeviceObjectStackSize(
    PDEVICE_OBJECT ClusnetDeviceObject,
    PDEVICE_OBJECT TargetDeviceObject
    );

//
// ExResource wrappers
//
BOOLEAN
CnAcquireResourceExclusive(
    IN PERESOURCE  Resource,
    IN BOOLEAN     Wait
    );

BOOLEAN
CnAcquireResourceShared(
    IN PERESOURCE  Resource,
    IN BOOLEAN     Wait
    );

VOID
CnReleaseResourceForThread(
    IN PERESOURCE         Resource,
    IN ERESOURCE_THREAD   ResourceThreadId
    );


//
// routines for in-memory logging facility
//

#ifdef MEMLOGGING
VOID
CnInitializeMemoryLog(
    VOID
    );

VOID
CnFreeMemoryLog(
    VOID
    );
#endif // MEMLOGGING

NTSTATUS
CnSetMemLogging(
    PCLUSNET_SET_MEM_LOGGING_REQUEST request
    );

#if 0
//
// NDIS related stuff
//

NDIS_STATUS
CnRegisterNDISProtocolHandlers(
    VOID
    );

NDIS_STATUS
CnDeregisterNDISProtocolHandlers(
    VOID
    );

VOID
CnOpenAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status,
    IN  NDIS_STATUS OpenErrorStatus
    );

VOID
CnCloseAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    );

VOID
CnStatusIndication(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

VOID
CnStatusIndicationComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    );

#endif

//
// error logging support
//

VOID _cdecl
CnWriteErrorLogEntry(
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID ExtraInformationBuffer,
    IN USHORT ExtraInformationLength,
    IN USHORT NumberOfInsertionStrings,
    ...
    );

//
// Global Data
//
extern PDRIVER_OBJECT   CnDriverObject;
extern PDEVICE_OBJECT   CnDeviceObject;;
extern PDEVICE_OBJECT   CdpDeviceObject;
extern PKPROCESS        CnSystemProcess;
extern CN_STATE         CnState;
extern PERESOURCE       CnResource;
extern CL_NODE_ID       CnMinValidNodeId;
extern CL_NODE_ID       CnMaxValidNodeId;
extern CL_NODE_ID       CnLocalNodeId;
extern HANDLE           ClussvcProcessHandle;

//
// vars for managing Events. The lookaside list generates Event data structs
// that are used to carry the event data back to user mode. EventLock is
// acquired when ANY Event operation takes place. Events are not generated
// at a high rate, hence the gross level of locking. EventFileHandles is a list
// of CN_FSCONTEXT blocks. These contain the acutal list of Events to be delivered
// to that file handle when clussvc makes an IRP available.
//

extern PNPAGED_LOOKASIDE_LIST   EventLookasideList;
extern CN_LOCK                  EventLock;
extern LIST_ENTRY               EventFileHandles;
extern ULONG                    EventEpoch;
extern LONG                     EventDeliveryInProgress;
extern KEVENT                   EventDeliveryComplete;
extern BOOLEAN                  EventRevisitRequired;

//
// Exports for Clussvc to Clusnet Heartbeating.
//
extern ULONG             ClussvcClusnetHbTimeoutTicks;
extern ClussvcHangAction ClussvcClusnetHbTimeoutAction;
extern ULONG             ClussvcClusnetHbTickCount;
extern PEPROCESS         ClussvcProcessObject;
extern ULONG             ClussvcClusnetHbTimeoutSeconds;

//
// ClusNet security descriptor
//
extern PSECURITY_DESCRIPTOR     CdpAdminSecurityDescriptor;

#include <cluxport.h>
#include <event.h>

#ifdef MM_IN_CLUSNET

#include <clusmem.h>

#endif // MM_IN_CLUSNET


#endif // ifndef _CLUSNET_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\inc\cnettest.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cnettest.h

Abstract:

    Test IOCTL definitions for Cluster Network Driver.

Author:

    Mike Massa (mikemas)           February 3, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-03-97    created

Notes:

--*/

#ifndef _CNETTEST_INCLUDED_
#define _CNETTEST_INCLUDED_


#if DBG

//
// General test ioctls. Codes 25-49.
//
#define IOCTL_CLUSNET_SET_DEBUG_MASK  \
            _NTDDCNET_CTL_CODE(25, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// General test ioctl structures.
//
typedef struct {
    ULONG  DebugMask;
} CLUSNET_SET_DEBUG_MASK_REQUEST, *PCLUSNET_SET_DEBUG_MASK_REQUEST;


//
// Transport test ioctls. Codes 150-199.
//

#define IOCTL_CX_ONLINE_PENDING_INTERFACE  \
            _NTDDCNET_CTL_CODE(150, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_ONLINE_INTERFACE  \
            _NTDDCNET_CTL_CODE(151, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_OFFLINE_INTERFACE  \
            _NTDDCNET_CTL_CODE(152, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_FAIL_INTERFACE  \
            _NTDDCNET_CTL_CODE(153, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_SEND_MM_MSG  \
            _NTDDCNET_CTL_CODE(154, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// IOCTL structure definitions
//
typedef CX_INTERFACE_COMMON_REQUEST CX_ONLINE_PENDING_INTERFACE_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_ONLINE_PENDING_INTERFACE_REQUEST;

typedef CX_INTERFACE_COMMON_REQUEST CX_ONLINE_INTERFACE_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_ONLINE_INTERFACE_REQUEST;

typedef CX_INTERFACE_COMMON_REQUEST CX_OFFLINE_INTERFACE_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_OFFLINE_INTERFACE_REQUEST;

typedef CX_INTERFACE_COMMON_REQUEST CX_FAIL_INTERFACE_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_FAIL_INTERFACE_REQUEST;

#define CX_MM_MSG_DATA_LEN   64

typedef struct {
    CL_NODE_ID  DestNodeId;
    ULONG       MessageData[CX_MM_MSG_DATA_LEN];
} CX_SEND_MM_MSG_REQUEST, *PCX_SEND_MM_MSG_REQUEST;

//
// IOCTL status codes
//
// Codes 0x1000 - 1999 are reserved for test values.
//


#endif // DBG


#endif  // _CNETTEST_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\inc\clusmem.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    clusmem.h

Abstract:

    Cluster Membership Manager definitions exposed within the
    Cluster Network Driver.

Author:

    Mike Massa (mikemas)           February 10, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-10-97    created

Notes:

--*/

#ifndef _CLUSMEM_INCLUDED
#define _CLUSMEM_INCLUDED


//
//
// Function Prototypes
//
//

//
// Init/Shutdown
//
NTSTATUS
CmmLoad(
    IN PUNICODE_STRING RegistryPath
    );

VOID
CmmUnload(
    VOID
    );

NTSTATUS
CmmInitialize(
    IN CL_NODE_ID LocalNodeId
    );

VOID
CmmShutdown(
    VOID
    );


//
// Irp Dispatch
//
NTSTATUS
CmmDispatchDeviceControl(
    IN PIRP                Irp,
    IN PIO_STACK_LOCATION  IrpSp
    );


//
// Messaging Interface
//
VOID
CmmReceiveMessageHandler(
    IN  CL_NODE_ID   SourceNodeId,
    IN  PVOID        MessageData,
    IN  ULONG        MessageLength
    );


#endif // ndef _CLUSMEM_INCLUDED


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\inc\event.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    event.h

Abstract:

    Event definitions

Author:

    Charlie Wickham (charlwi) 17-Feb-1997

Revision History:

--*/

#ifndef _EVENT_H_
#define _EVENT_H_

/* Prototypes */

NTSTATUS
CnSetEventMask(
    IN  PCN_FSCONTEXT                   FsContext,
    IN  PCLUSNET_SET_EVENT_MASK_REQUEST EventRequest
    );

NTSTATUS
CnGetNextEvent(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CnIssueEvent(
    CLUSNET_EVENT_TYPE Event,
    CL_NODE_ID NodeId OPTIONAL,
    CL_NETWORK_ID NetworkId OPTIONAL
    );

/* End Prototypes */

#endif /* _EVENT_H_ */

/* end event.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\inc\cluxport.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cluxport.h

Abstract:

    Cluster Transport definitions exposed within the Cluster Network Driver.

Author:

    Mike Massa (mikemas)           January 3, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-03-97    created

Notes:

--*/

#ifndef _CLUXPORT_INCLUDED
#define _CLUXPORT_INCLUDED

#include <tdi.h>
#include <tdikrnl.h>
#include <clustdi.h>

//
//
// Function Prototypes
//
//

//
// Initialization/Shutdown
//
NTSTATUS
CxLoad(
    IN PUNICODE_STRING RegistryPath
    );

VOID
CxUnload(
    VOID
    );

NTSTATUS
CxInitialize(
    VOID
    );

VOID
CxShutdown(
    VOID
    );

//
// Irp Dispatch
//
NTSTATUS
CxDispatchDeviceControl(
    IN PIRP                Irp,
    IN PIO_STACK_LOCATION  IrpSp
    );


//
// Nodes
//
NTSTATUS
CxRegisterNode(
    CL_NODE_ID    NodeId
    );

NTSTATUS
CxDeregisterNode(
    CL_NODE_ID           NodeId,
    PIRP                 Irp,
    PIO_STACK_LOCATION   IrpSp
    );

NTSTATUS
CxOnlineNodeComm(
    CL_NODE_ID     NodeId
    );

NTSTATUS
CxOfflineNodeComm(
    IN CL_NODE_ID          NodeId,
    IN PIRP                Irp,
    IN PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
CxGetNodeCommState(
    IN  CL_NODE_ID                NodeId,
    OUT PCLUSNET_NODE_COMM_STATE  State
    );


//
// Networks
//
NTSTATUS
CxRegisterNetwork(
    CL_NETWORK_ID       NetworkId,
    ULONG               Priority,
    BOOLEAN             Restricted
    );

NTSTATUS
CxDeregisterNetwork(
    CL_NETWORK_ID       NetworkId,
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
CxOnlineNetwork(
    IN  CL_NETWORK_ID       NetworkId,
    IN  PWCHAR              TdiProviderName,
    IN  ULONG               TdiProviderNameLength,
    IN  PTRANSPORT_ADDRESS  TdiBindAddress,
    IN  ULONG               TdiBindAddressLength,
    IN  PWCHAR              AdapterName,
    IN  ULONG               AdapterNameLength,
    OUT PTDI_ADDRESS_INFO   TdiBindAddressInfo,
    IN  ULONG               TdiBindAddressInfoLength,
    IN  PIRP                Irp                       OPTIONAL
    );

NTSTATUS
CxOfflineNetwork(
    CL_NETWORK_ID       NetworkId,
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
CxGetNetworkState(
    IN  CL_NETWORK_ID           NetworkId,
    OUT PCLUSNET_NETWORK_STATE  State
    );

NTSTATUS
CxSetNetworkRestriction(
    IN CL_NETWORK_ID  NetworkId,
    IN BOOLEAN        Restricted,
    IN ULONG          NewPriority
    );

NTSTATUS
CxSetNetworkPriority(
    IN CL_NETWORK_ID  NetworkId,
    IN ULONG          Priority
    );

NTSTATUS
CxGetNetworkPriority(
    IN  CL_NETWORK_ID   NetworkId,
    OUT PULONG          Priority
    );


//
// Interfaces
//
NTSTATUS
CxRegisterInterface(
    CL_NODE_ID          NodeId,
    CL_NETWORK_ID       NetworkId,
    ULONG               Priority,
    PUWSTR              AdapterId,
    ULONG               AdapterIdLength,
    ULONG               TdiAddressLength,
    PTRANSPORT_ADDRESS  TdiAddress,
    PULONG              MediaStatus
    );

NTSTATUS
CxDeregisterInterface(
    CL_NODE_ID          NodeId,
    CL_NETWORK_ID       NetworkId
    );

NTSTATUS
CxSetInterfacePriority(
    IN CL_NODE_ID          NodeId,
    IN CL_NETWORK_ID       NetworkId,
    IN ULONG               Priority
    );

NTSTATUS
CxGetInterfacePriority(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              InterfacePriority,
    OUT PULONG              NetworkPriority
    );

NTSTATUS
CxGetInterfaceState(
    IN  CL_NODE_ID                NodeId,
    IN  CL_NETWORK_ID             NetworkId,
    OUT PCLUSNET_INTERFACE_STATE  State
    );

//
// Misc. stuff
//
NTSTATUS
CxGetNodeMembershipState(
    IN  CL_NODE_ID NodeId,
    OUT PCLUSNET_NODE_STATE State
    );

NTSTATUS
CxSetNodeMembershipState(
    IN  CL_NODE_ID NodeId,
    IN  CLUSNET_NODE_STATE State
    );

NTSTATUS
CxSetOuterscreen(
    IN  ULONG Outerscreen
    );

VOID
CxRegroupFinished(
    IN  ULONG NewEventEpoch,
    IN  ULONG NewRegroupEpoch
    );

NTSTATUS
CxImportSecurityContext(
    IN  CL_NODE_ID NodeId,
    IN  PWCHAR PackageName,
    IN  ULONG PackageNameSize,
    IN  ULONG SignatureSize,
    IN  PVOID InboundContext,
    IN  PVOID OutboundContext
    );

VOID
CxDeleteSecurityContext(
    IN  CL_NODE_ID NodeId
    );

//
// Membership Message Interface
//
typedef
VOID
(*PCX_SEND_COMPLETE_ROUTINE) (
    IN NTSTATUS  Status,
    IN ULONG     BytesSent,
    IN PVOID     Context,
    IN PVOID     Buffer
    );

NTSTATUS
CxSendMembershipMessage(
    IN CL_NODE_ID                  DestinationNodeId,
    IN PVOID                       MessageData,
    IN USHORT                      MessageDataLength,
    IN PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,
    IN PVOID                       CompletionContext   OPTIONAL
    );

VOID
CxSendPoisonPacket(
    IN CL_NODE_ID                  DestinationNodeId,
    IN PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine   OPTIONAL,
    IN PVOID                       CompletionContext   OPTIONAL,
    IN PIRP                        Irp                 OPTIONAL
    );

NTSTATUS
CxSendHeartBeatMessage(
    IN CL_NODE_ID                  DestinationNodeId,
    IN ULONG                       SeqNumber,
    IN ULONG                       AckNumber,
    IN CL_NETWORK_ID               NetworkId
    );


//
// Top-edge TDI Routines
//
NTSTATUS
CxOpenAddress(
    OUT PCN_FSCONTEXT *                CnFsContext,
    IN  TRANSPORT_ADDRESS UNALIGNED *  TransportAddress,
    IN  ULONG                          TransportAddressLength
    );

NTSTATUS
CxCloseAddress(
    IN PCN_FSCONTEXT CnFsContext
    );

NTSTATUS
CxSetEventHandler(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    );

NTSTATUS
CxQueryInformation(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    );

NTSTATUS
CxSendDatagram(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    );

NTSTATUS
CxReceiveDatagram(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    );

//
// Test APIs
//
#if DBG

NTSTATUS
CxOnlinePendingInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    );

NTSTATUS
CxOnlineInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    );

NTSTATUS
CxOfflineInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    );

NTSTATUS
CxFailInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    );

#endif // DBG


#endif // ndef _CLUXPORT_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\inc\hblog.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hblog.h

Abstract:

    in memory logging for heart beat debugging

Author:

    Charlie Wickham (charlwi) 17-Mar-1997

Revision History:

--*/

#ifndef _HBLOG_
#define _HBLOG_

/* Prototypes */
/* End Prototypes */

#ifdef HBLOGGING

typedef struct _HBLOG_ENTRY {
    LARGE_INTEGER SysTime;
    USHORT Type;
    USHORT LineNo;
    ULONG Arg1;
    ULONG Arg2;
} HBLOG_ENTRY, *PHBLOG_ENTRY;

typedef enum _HBLOG_TYPES {
    HBLogInitHB = 1,
    HBLogHBStarted,
    HBLogHBStopped,
    HBLogHBDpcRunning,
    HBLogWaitForDpcFinish,
    HBLogMissedIfHB,
    HBLogMissedIfHB1,
    HBLogFailingIf,
    HBLogFailingIf1,
    HBLogSendHBWalkNode,
    HBLogCheckHBWalkNode,
    HBLogCheckHBNodeReachable,
    HBLogCheckHBMissedHB,
    HBLogSendingHB,
    HBLogNodeDown,
    HBLogSetDpcEvent,
    HBLogNoNetID,
    HBLogOnlineIf,
    HBLogSeqAckMismatch,
    HBLogNodeUp,
    HBLogReceivedPacket,
    HBLogReceivedPacket1,
    HBLogDpcTimeSkew,
    HBLogHBPacketSend,
    HBLogHBPacketSendComplete,
    HBLogPoisonPktReceived,
    HBLogOuterscreen,
    HBLogNodeDownIssued,
    HBLogRegroupFinished,
    HBLogInconsistentStates
} HBLOG_TYPES;

#endif // HBLOGGING

#endif /* _HBLOG_ */

/* end hblog.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\inc\cnwmi.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cnwmi.h

Abstract:

    clusnet specific wmi tracing declarations

Authors:

    GorN     10-Aug-1999

Environment:

    kernel mode only

Notes:

Revision History:


--*/

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(Clusnet,(8e707979,0c45,4f9b,bb17,a1124d54bbfe), \
      WPP_DEFINE_BIT(HBEAT_EVENT)     \
      WPP_DEFINE_BIT(HBEAT_ERROR)     \
      WPP_DEFINE_BIT(HBEAT_DETAIL)    \
                                      \
      WPP_DEFINE_BIT(CNP_SEND_ERROR)  \
      WPP_DEFINE_BIT(CNP_RECV_ERROR)  \
      WPP_DEFINE_BIT(CNP_SEND_DETAIL) \
      WPP_DEFINE_BIT(CNP_RECV_DETAIL) \
                                      \
      WPP_DEFINE_BIT(CCMP_SEND_ERROR) \
      WPP_DEFINE_BIT(CCMP_RECV_ERROR) \
      WPP_DEFINE_BIT(CCMP_SEND_DETAIL)\
      WPP_DEFINE_BIT(CCMP_RECV_DETAIL)\
                                      \
      WPP_DEFINE_BIT(CDP_SEND_ERROR)  \
      WPP_DEFINE_BIT(CDP_RECV_ERROR)  \
      WPP_DEFINE_BIT(CDP_SEND_DETAIL) \
      WPP_DEFINE_BIT(CDP_RECV_DETAIL) \
                                      \
      WPP_DEFINE_BIT(CXPNP)           \
      WPP_DEFINE_BIT(CNP_NET_DETAIL)  \
      WPP_DEFINE_BIT(NTEMGMT_DETAIL)  \
      WPP_DEFINE_BIT(CNP_NODE_DETAIL) \
                                      \
      WPP_DEFINE_BIT(CDP_ADDR_DETAIL) \
      WPP_DEFINE_BIT(EVENT_DETAIL)    \
      WPP_DEFINE_BIT(CNP_IF_DETAIL)   \
   )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\inc\nbtmgmt.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    nbtmgmt.h

Abstract:

    Declarations for NBT interface management routines.

Author:

    David Dion (daviddio)           December 14, 1999

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    daviddio    12-14-99    created

Notes:

--*/

#ifndef _NBTMGMT_INCLUDED
#define _NBTMGMT_INCLUDED

#include <nbtioctl.h>

//
// Function Prototypes
//

NTSTATUS
NbtIfLoad(
    VOID
    );

VOID
NbtIfShutdown(
    VOID
    );

NTSTATUS
NbtAddIf(
    IN     PNETBT_ADD_DEL_IF    Request,
    IN     ULONG                RequestSize,
    OUT    PNETBT_ADD_DEL_IF    Response,
    IN OUT PULONG               ResponseSize
    );

NTSTATUS
NbtDeleteIf(
    IN PNETBT_ADD_DEL_IF    Request,
    IN ULONG                RequestSize
    );

#endif // ndef _NBTMGMT_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\kdcn\precomp.h ===
#if DBG
#define DEBUG 1
#endif

#define NT 1
#define _PNP_POWER  1
#define SECFLTR 1

#include <ntverp.h>

#include <ntos.h>
#include <nturtl.h>

#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

#define _NTIFS_
#include <clusnet.h>
#include "cxp.h"
#include "cnpdef.h"
#include "memlog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\inc\memlog.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    memlog.h

Abstract:

    in memory logging facility

Author:

    Charlie Wickham (charlwi) 17-Mar-1997

Revision History:

--*/

#ifndef _MEMLOG_
#define _MEMLOG_

/* Prototypes */
/* End Prototypes */

#ifdef MEMLOGGING

typedef struct _MEMLOG_ENTRY {
    LARGE_INTEGER SysTime;
    USHORT Type;
    USHORT LineNo;
    ULONG_PTR Arg1;
    ULONG_PTR Arg2;
} MEMLOG_ENTRY, *PMEMLOG_ENTRY;

// 
//  Do not change the order of
//
//    MemLogReceivedPacket,
//    MemLogReceivedPacket1,
//
//    MemLogMissedIfHB,
//    MemLogMissedIfHB1,
//   
//    MemLogFailingIf,
//    MemLogFailingIf1,
//
//  MEMLOG4 relies on MemLogFailingIf1 = MemLogFailingIf + 1, etc
// 

typedef enum _MEMLOG_TYPES {
    MemLogInitLog = 1,
    MemLogInitHB,
    MemLogHBStarted,
    MemLogHBStopped,
    MemLogHBDpcRunning,
    MemLogWaitForDpcFinish,
    MemLogMissedIfHB,
    MemLogMissedIfHB1,
    MemLogFailingIf,
    MemLogFailingIf1,
    MemLogSendHBWalkNode,
    MemLogCheckHBWalkNode,
    MemLogCheckHBNodeReachable,
    MemLogCheckHBMissedHB,
    MemLogSendingHB,
    MemLogNodeDown,
    MemLogSetDpcEvent,
    MemLogNoNetID,
    MemLogOnlineIf,
    MemLogSeqAckMismatch,
    MemLogNodeUp,
    MemLogReceivedPacket,
    MemLogReceivedPacket1,
    MemLogDpcTimeSkew,
    MemLogHBPacketSend,
    MemLogHBPacketSendComplete,
    MemLogPoisonPktReceived,
    MemLogOuterscreen,
    MemLogNodeDownIssued,
    MemLogRegroupFinished,
    MemLogInconsistentStates,
    MemLogOutOfSequence,
    MemLogInvalidSignature,
    MemLogSignatureSize,
    MemLogNoSecurityContext,
    MemLogPacketSendFailed
} MEMLOG_TYPES;

extern ULONG MemLogEntries;
extern ULONG MemLogNextLogEntry;

extern PMEMLOG_ENTRY MemLog;
extern KSPIN_LOCK MemLogLock;

#define _MEMLOG( _type, _arg1, _arg2 )                                      \
    {                                                                       \
        KIRQL MemLogIrql;                                                   \
        if ( MemLogEntries ) {                                              \
            KeAcquireSpinLock( &MemLogLock, &MemLogIrql );                  \
            KeQuerySystemTime( &MemLog[ MemLogNextLogEntry ].SysTime );     \
            MemLog[ MemLogNextLogEntry ].Type = _type;                      \
            MemLog[ MemLogNextLogEntry ].LineNo = __LINE__;                 \
            MemLog[ MemLogNextLogEntry ].Arg1 = _arg1;                      \
            MemLog[ MemLogNextLogEntry ].Arg2 = _arg2;                      \
            if ( ++MemLogNextLogEntry == MemLogEntries )                    \
                MemLogNextLogEntry = 0;                                     \
            MemLog[ MemLogNextLogEntry ].Type = 0;                          \
            KeReleaseSpinLock( &MemLogLock, MemLogIrql );                   \
        }                                                                   \
    }

#else // MEMLOGGING

#define _MEMLOG( _type, _arg1, _arg2 )

#endif // MEMLOGGING

#define MEMLOG( _type, _arg1, _arg2 )       \
    {                                       \
        _MEMLOG( _type, _arg1, _arg2 );     \
    }

#define MEMLOG4( _type, _arg3, _arg4 , _arg1, _arg2 )  \
    {                                                  \
        _MEMLOG( _type + 1, _arg3, _arg4 );            \
        _MEMLOG( _type, _arg1, _arg2 );                \
    }

#endif /* _MEMLOG_ */

/* end memlog.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\inc\ntemgmt.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ntemgmt.h

Abstract:

    Declartions for IP Network Table Entry management routines.

Author:

    Mike Massa (mikemas)           April 16, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     04-16-97    created

Notes:

--*/

#ifndef _NTEMGMT_INCLUDED
#define _NTEMGMT_INCLUDED

#include <ntddip.h>

//
// Function Prototypes
//


NTSTATUS
IpaLoad(
    VOID
    );

NTSTATUS
IpaInitialize(
    VOID
    );

VOID
IpaShutdown(
    VOID
    );

NTSTATUS
IpaAddNTE(
    IN PIRP                     Irp,
    IN PIO_STACK_LOCATION       IrpSp
    );

NTSTATUS
IpaDeleteNTE(
    IN PIRP                     Irp,
    IN PIO_STACK_LOCATION       IrpSp
    );

NTSTATUS
IpaSetNTEAddress(
    IN PIRP                     Irp,
    IN PIO_STACK_LOCATION       IrpSp
    );

BOOLEAN
IpaIsAddressRegistered(
    ULONG  Address
    );

#endif // ndef _NTEMGMT_INCLUDED



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\inc\ntddcnet.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ntddcnet.h

Abstract:

    Public header file for the Cluster Network Driver. Defines all
    control IOCTLs.

Author:

    Mike Massa (mikemas)           January 3, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-03-97    created

Notes:

--*/

#ifndef _NTDDCNET_INCLUDED_
#define _NTDDCNET_INCLUDED_


//
// Device Names.
//
// ClusterNetwork is the control device. All control IOCTLs are issued
// on this device. ClusterDatagramProtocol is the datagram transport device.
// This device supports TDI IOCTLs.
//
#define DD_CLUSNET_DEVICE_NAME   L"\\Device\\ClusterNetwork"
#define DD_CDP_DEVICE_NAME       L"\\Device\\ClusterDatagramProtocol"


//
// General Types
//

//
// Control IOCTL definitions.
//

#define FSCTL_NTDDCNET_BASE     FILE_DEVICE_NETWORK

#define _NTDDCNET_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_NTDDCNET_BASE, function, method, access)

#define ClusnetIoctlCode(_ioctl)    (((_ioctl) >> 2) & 0x00000FFF)


//
// General driver management IOCTLs. Codes 0-49
//
#define CLUSNET_MINIMUM_GENERAL_IOCTL   0
#define CLUSNET_MAXIMUM_GENERAL_IOCTL  49

/* #define ClusnetIsGeneralIoctl(_ioctl) \
            ( (ClusnetIoctlCode(_ioctl) >= CLUSNET_MINIMUM_GENERAL_IOCTL) && \
              (ClusnetIoctlCode(_ioctl) <= CLUSNET_MAXIMUM_GENERAL_IOCTL) ) */
// Check for CLUSNET_MINIMUM_GENERAL_IOCTL removed since ioctl is a ULONG
// and always greater than zero. Reinstate if CLUSNET_MINIMUM_GENERAL_IOCTL
// is made nonzero.
#define ClusnetIsGeneralIoctl(_ioctl) \
            (ClusnetIoctlCode(_ioctl) <= CLUSNET_MAXIMUM_GENERAL_IOCTL)

#define IOCTL_CLUSNET_INITIALIZE  \
            _NTDDCNET_CTL_CODE(0, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_SHUTDOWN  \
            _NTDDCNET_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_ENABLE_SHUTDOWN_ON_CLOSE  \
            _NTDDCNET_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_DISABLE_SHUTDOWN_ON_CLOSE  \
            _NTDDCNET_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_SET_EVENT_MASK  \
            _NTDDCNET_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_GET_NEXT_EVENT  \
            _NTDDCNET_CTL_CODE(5, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_HALT  \
            _NTDDCNET_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_SET_MEMORY_LOGGING  \
            _NTDDCNET_CTL_CODE(7, METHOD_BUFFERED, FILE_WRITE_ACCESS)
            
//
// NTE IOCTLs are a special class of general driver management IOCTLs.
// Codes are 8-12.
//
#define CLUSNET_MINIMUM_NTE_IOCTL  8
#define CLUSNET_MAXIMUM_NTE_IOCTL 12

#define ClusnetIsNTEIoctl(_ioctl) \
            ( (ClusnetIoctlCode(_ioctl) >= CLUSNET_MINIMUM_NTE_IOCTL) && \
              (ClusnetIoctlCode(_ioctl) <= CLUSNET_MAXIMUM_NTE_IOCTL) )

#define IOCTL_CLUSNET_ADD_NTE  \
            _NTDDCNET_CTL_CODE(8, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_DELETE_NTE  \
            _NTDDCNET_CTL_CODE(9, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_SET_NTE_ADDRESS  \
            _NTDDCNET_CTL_CODE(10, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_ADD_NBT_INTERFACE  \
            _NTDDCNET_CTL_CODE(11, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_DEL_NBT_INTERFACE  \
            _NTDDCNET_CTL_CODE(12, METHOD_BUFFERED, FILE_WRITE_ACCESS)
//
// Clussvc to Clusnet Heartbeating Ioctls
//
#define IOCTL_CLUSNET_SET_IAMALIVE_PARAM \
            _NTDDCNET_CTL_CODE(13, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_IAMALIVE \
            _NTDDCNET_CTL_CODE(14, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// Codes 25-49 are reserved for general test ioctls
//

//
// General driver IOCTL structure definitions
//

//
// Initialize request. This must be issued before any other request.
//
typedef struct {
    CL_NODE_ID   LocalNodeId;
    ULONG        MaxNodes;
} CLUSNET_INITIALIZE_REQUEST, *PCLUSNET_INITIALIZE_REQUEST;

//
// Shutdown request. Deletes all registered nodes and interfaces.
//
typedef struct {
    CL_NODE_ID   LocalNodeId;
} CLUSNET_SHUTDOWN_REQUEST, *PCLUSNET_SHUTDOWN_REQUEST;

//
// shutdown on close request
//
typedef struct {
    ULONG        ProcessId;
} CLUSNET_SHUTDOWN_ON_CLOSE_REQUEST, *PCLUSNET_SHUTDOWN_ON_CLOSE_REQUEST;

//
// Set event mask request. Hands a bit mask and a function (kernel mode
// only) to the driver indicating which events the thread wishes to
// be notified about. The IRP is pended for user mode. Kernel mode
// events are delivered via the callback.
//

typedef VOID (*CLUSNET_EVENT_CALLBACK_ROUTINE)(CLUSNET_EVENT_TYPE,
                                               CL_NODE_ID,
                                               CL_NETWORK_ID);

typedef struct {
    ULONG EventMask;
    CLUSNET_EVENT_CALLBACK_ROUTINE KmodeEventCallback;
} CLUSNET_SET_EVENT_MASK_REQUEST, *PCLUSNET_SET_EVENT_MASK_REQUEST;

typedef CLUSNET_EVENT CLUSNET_EVENT_RESPONSE;
typedef PCLUSNET_EVENT PCLUSNET_EVENT_RESPONSE;

typedef struct _CLUSNET_EVENT_ENTRY {
    LIST_ENTRY Linkage;
    CLUSNET_EVENT EventData;
} CLUSNET_EVENT_ENTRY, *PCLUSNET_EVENT_ENTRY;

#define CN_EVENT_SIGNATURE      'tvec'

//
// in-memory logging. conveys the number of entries to allocate
// (zero if turning off) for logging events
//

typedef struct _CLUSNET_SET_MEM_LOGGING_REQUEST {
    ULONG NumberOfEntries;
} CLUSNET_SET_MEM_LOGGING_REQUEST, *PCLUSNET_SET_MEM_LOGGING_REQUEST;

#ifdef MM_IN_CLUSNET
//
// Membership management IOCTLs. Codes 50-99
//

#define CLUSNET_MINIMUM_CMM_IOCTL  50
#define CLUSNET_MAXIMUM_CMM_IOCTL  99

#define ClusnetIsMembershipIoctl(_ioctl) \
            ( (ClusnetIoctlCode(_ioctl) >= CLUSNET_MINIMUM_CMM_IOCTL) && \
              (ClusnetIoctlCode(_ioctl) <= CLUSNET_MAXIMUM_CMM_IOCTL) )


//
// NOTE: currently (3/3/97) CMM Ioctl codes 50 through 62 are not used.
// These were defined during an initial attempt to get the membership
// manager into kernel mode (which didn't succeed).
//

//
// first guy in cluster forms one...
//

#define IOCTL_CMM_FORM_CLUSTER \
            _NTDDCNET_CTL_CODE(50, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// MMJoin phases. Basically correspond to the 4 messages that are sent as part
// of the Join process. End must be submitted to terminate the process.
//

#define IOCTL_CMM_JOIN_CLUSTER_PHASE1  \
            _NTDDCNET_CTL_CODE(51, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_JOIN_CLUSTER_PHASE2  \
            _NTDDCNET_CTL_CODE(52, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_JOIN_CLUSTER_PHASE3  \
            _NTDDCNET_CTL_CODE(53, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_JOIN_CLUSTER_PHASE4  \
            _NTDDCNET_CTL_CODE(54, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_JOIN_CLUSTER_ABORT  \
            _NTDDCNET_CTL_CODE(55, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_JOIN_CLUSTER_END  \
            _NTDDCNET_CTL_CODE(56, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl is used to deliver a join message on an active node.
//
#define IOCTL_CMM_DELIVER_JOIN_MESSAGE  \
            _NTDDCNET_CTL_CODE(57, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_SHUTDOWN_CLUSTER  \
            _NTDDCNET_CTL_CODE(58, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_LEAVE_CLUSTER  \
            _NTDDCNET_CTL_CODE(59, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_EJECT_CLUSTER  \
            _NTDDCNET_CTL_CODE(60, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_GET_NODE_STATE  \
            _NTDDCNET_CTL_CODE(61, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// callbacks are done by completing an (usually) outstanding IRP. The type
// of callback as well as required parameters are passed back to clussvc
// by completing this IRP.
//

#define IOCTL_CMM_REGISTER_CALLBACK  \
            _NTDDCNET_CTL_CODE(62, METHOD_BUFFERED, FILE_WRITE_ACCESS)



//
// Membership IOCTL structure definitions
//

//
// Common request structure
//
// This structure shared among a number of requests. The Node field may not be
// used; see the appropriate MM* routine to determine what is used.
//
typedef struct _CMM_COMMON_CLUSTER_REQUEST {
    ULONG  Node;
} CMM_COMMON_CLUSTER_REQUEST, *PCMM_COMMON_CLUSTER_REQUEST;

//
// Form cluster request
//
typedef struct _CMM_FORM_CLUSTER_REQUEST {
    ULONG  ClockPeriod;
    ULONG  SendHBRate;
    ULONG  RecvHBRate;
} CMM_FORM_CLUSTER_REQUEST, *PCMM_FORM_CLUSTER_REQUEST;

//
// Join cluster request
//
// Used for all four join phases. This structure is variable in length. Clussvc
// must allocate enough space in which the MM writes a packet to be sent by
// Clussvc. MM sets SizeOfSendData on output to indicate how much data is in
// SendData after a join phase has been called. SendNodeMask indicates which
// nodes should receive the packet.
//

typedef struct _CMM_JOIN_CLUSTER_REQUEST {
    ULONG  JoiningNode;
    ULONG  JoinTimeout;
} CMM_JOIN_CLUSTER_REQUEST, *PCMM_JOIN_CLUSTER_REQUEST;

//
// Join cluster response
//
typedef struct _CMM_JOIN_CLUSTER_RESPONSE {
    ULONG     SizeOfSendData;
    ULONG     SendNodeMask;
    UCHAR     SendData[0];
} CMM_JOIN_CLUSTER_RESPONSE, *PCMM_JOIN_CLUSTER_RESPONSE;

//
// Deliver join message request
//
typedef struct _CMM_DELIVER_JOIN_CLUSTER_REQUEST {
    UCHAR     MessageData[0];
} CMM_DELIVER_JION_MESSAGE_REQUEST, *PCMM_DELIVER_JION_MESSAGE_REQUEST;

//
// Eject node request
//
typedef CMM_COMMON_CLUSTER_REQUEST CMM_EJECT_CLUSTER_REQUEST;
typedef PCMM_COMMON_CLUSTER_REQUEST PCMM_EJECT_CLUSTER_REQUEST;

//
// Get node membership state request
//
typedef CMM_COMMON_CLUSTER_REQUEST CMM_GET_NODE_STATE_REQUEST;
typedef PCMM_COMMON_CLUSTER_REQUEST PCMM_GET_NODE_STATE_REQUEST;

//
// Get node membership state response
//
typedef struct _CMM_GET_NODE_STATE_RESPONSE {
    CLUSNET_NODE_STATE  State;
} CMM_GET_NODE_STATE_RESPONSE, *PCMM_GET_NODE_STATE_RESPONSE;

//
// struct used to notfiy clussvc of callback events. All callbacks have a DWORD as their
// first param. MMNodeChange is the only callback with a 2nd param. CallbackType is one
// of RGP_CALLBACK_*. These structs are linked off of the main RGP struct
//

typedef struct _CMM_CALLBACK_DATA {
    ULONG CallbackType;
    ULONG Arg1;
    ULONG Arg2;
} CMM_CALLBACK_DATA, *PCMM_CALLBACK_DATA;

typedef struct _CMM_CALLBACK_EVENT {
    LIST_ENTRY Linkage;
    CMM_CALLBACK_DATA EventData;
} CMM_CALLBACK_EVENT, *PCMM_CALLBACK_EVENT;

#endif // MM_IN_CLUSNET

//
// Transport management IOCTLs. Codes 100-199
//
#define CLUSNET_MINIMUM_CX_IOCTL  100
#define CLUSNET_MAXIMUM_CX_IOCTL  199

#define ClusnetIsTransportIoctl(_ioctl) \
            ( (ClusnetIoctlCode(_ioctl) >= CLUSNET_MINIMUM_CX_IOCTL) && \
              (ClusnetIoctlCode(_ioctl) <= CLUSNET_MAXIMUM_CX_IOCTL) )

#define IOCTL_CX_MINIMUM_IOCTL  \
            _NTDDCNET_CTL_CODE(100, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_REGISTER_NODE  \
            _NTDDCNET_CTL_CODE(100, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_DEREGISTER_NODE  \
            _NTDDCNET_CTL_CODE(101, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_REGISTER_NETWORK  \
            _NTDDCNET_CTL_CODE(102, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_DEREGISTER_NETWORK  \
            _NTDDCNET_CTL_CODE(103, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_REGISTER_INTERFACE  \
            _NTDDCNET_CTL_CODE(104, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_DEREGISTER_INTERFACE  \
            _NTDDCNET_CTL_CODE(105, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_ONLINE_NODE_COMM  \
            _NTDDCNET_CTL_CODE(106, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_OFFLINE_NODE_COMM  \
            _NTDDCNET_CTL_CODE(107, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_ONLINE_NETWORK  \
            _NTDDCNET_CTL_CODE(108, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_OFFLINE_NETWORK  \
            _NTDDCNET_CTL_CODE(109, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_NETWORK_PRIORITY  \
            _NTDDCNET_CTL_CODE(110, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_SET_NETWORK_PRIORITY  \
            _NTDDCNET_CTL_CODE(111, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_INTERFACE_PRIORITY  \
            _NTDDCNET_CTL_CODE(112, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_SET_INTERFACE_PRIORITY  \
            _NTDDCNET_CTL_CODE(113, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_NODE_STATE  \
            _NTDDCNET_CTL_CODE(114, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_NETWORK_STATE  \
            _NTDDCNET_CTL_CODE(115, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_INTERFACE_STATE  \
            _NTDDCNET_CTL_CODE(116, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_IGNORE_NODE_STATE  \
            _NTDDCNET_CTL_CODE(117, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_CX_SET_NODE_MMSTATE  \
            _NTDDCNET_CTL_CODE(118, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_NODE_MMSTATE  \
            _NTDDCNET_CTL_CODE(119, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_SEND_POISON_PACKET  \
            _NTDDCNET_CTL_CODE(120, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_SET_OUTERSCREEN  \
            _NTDDCNET_CTL_CODE(121, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_REGROUP_FINISHED  \
            _NTDDCNET_CTL_CODE(122, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_IMPORT_SECURITY_CONTEXTS  \
            _NTDDCNET_CTL_CODE(123, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_SET_NETWORK_RESTRICTION  \
            _NTDDCNET_CTL_CODE(124, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_RESERVE_ENDPOINT \
            _NTDDCNET_CTL_CODE(125, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_CONFIGURE_MULTICAST \
            _NTDDCNET_CTL_CODE(126, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_MULTICAST_REACHABLE_SET \
            _NTDDCNET_CTL_CODE(127, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// Codes 150-199 are reserved for test ioctls and are defined in cnettest.h
//

#define IOCTL_CX_MAXIMUM_IOCTL  \
            _NTDDCNET_CTL_CODE(199, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// Transport IOCTL structure definitions
//

//
// Common request definitions
//
typedef struct {
    CL_NODE_ID     Id;
} CX_NODE_COMMON_REQUEST, *PCX_NODE_COMMON_REQUEST;

typedef struct {
    CL_NETWORK_ID  Id;
} CX_NETWORK_COMMON_REQUEST, *PCX_NETWORK_COMMON_REQUEST;

typedef struct {
    CL_NODE_ID     NodeId;
    CL_NETWORK_ID  NetworkId;
} CX_INTERFACE_COMMON_REQUEST, *PCX_INTERFACE_COMMON_REQUEST;

//
// Node registration request.
//
typedef CX_NODE_COMMON_REQUEST CX_NODE_REG_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_NODE_REG_REQUEST;

//
// Node deregistration request.
//
typedef CX_NODE_COMMON_REQUEST CX_NODE_DEREG_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_NODE_DEREG_REQUEST;

//
// Network registration request
//
// The Priority indicates the order in which networks will be chosen to
// carry packets. Valid values are 0x1-0xFFFFFFFF. Numerically lower values
// are higher priority.
//
// The TdiProviderName and TdiBindAddress structures follow the registration
// strucuture in the IRP. The TdiProviderName is the device name
// (e.g \Device\Udp) which must be opened to access the underlying
// transport provider. The TdiBindAddress is the provider's local address to
// which the network should bind.
//
typedef struct {
    CL_NETWORK_ID     Id;
    ULONG             Priority;
    BOOLEAN           Restricted;
} CX_NETWORK_REG_REQUEST, *PCX_NETWORK_REG_REQUEST;

//
// Network deregistration request.
//
typedef CX_NETWORK_COMMON_REQUEST CX_NETWORK_DEREG_REQUEST;
typedef PCX_NETWORK_COMMON_REQUEST PCX_NETWORK_DEREG_REQUEST;

//
// Interface registration request.
//
// The Priority indicates the order in which interfaces will be chosen to
// carry packets. Valid values are 0x1-0xFFFFFFFF. Numerically lower values
// are higher priority. A value of zero indicates that the interface
// should inherit its priority from the associated network.
//
// AdapterIdOffset is the offset in bytes from the beginning of the
// CX_INTERFACE_REG_REQUEST structure to a buffer containing the adapter
// id as a string of UNICODE characters. AdapterIdLength is the length,
// in bytes, of the UNICODE string, not including terminating UNICODE_NULL.
// AdapterIdOffset is 64-bit aligned.
//
// The TdiAddress field is a placeholder for a TDI TRANSPORT_ADDRESS
// structure which is embedded in the registration structure. This
// structure contains the transport address at which the cluster transport
// on the specified node is listening on the specified network. For the
// local node, this is the address used in the network registration (unless
// a wildcard address was used).
//
typedef struct {
    CL_NODE_ID         NodeId;
    CL_NETWORK_ID      NetworkId;
    ULONG              Priority;
    ULONG              AdapterIdOffset;
    ULONG              AdapterIdLength;
    ULONG              TdiAddressLength;
    ULONG              TdiAddress[1];                                         // TDI TRANSPORT_ADDRESS struct
} CX_INTERFACE_REG_REQUEST, *PCX_INTERFACE_REG_REQUEST;

typedef struct {
    ULONG              MediaStatus; // NDIS_MEDIA_STATUS
} CX_INTERFACE_REG_RESPONSE, *PCX_INTERFACE_REG_RESPONSE;

//
// Interface deregistration request.
//
typedef CX_INTERFACE_COMMON_REQUEST CX_INTERFACE_DEREG_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_INTERFACE_DEREG_REQUEST;

//
//
// Online node request
//
typedef CX_NODE_COMMON_REQUEST CX_ONLINE_NODE_COMM_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_ONLINE_NODE_COMM_REQUEST;

//
// Offline node request
//
typedef CX_NODE_COMMON_REQUEST CX_OFFLINE_NODE_COMM_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_OFFLINE_NODE_COMM_REQUEST;

// Online network request
//
// The TdiProviderName and TdiBindAddress structures follow the registration
// strucuture in the IRP. The TdiProviderName is the device name
// (e.g \Device\Udp) which must be opened to access the underlying
// transport provider. The TdiBindAddress is the provider's local address to
// which the network should bind.
//
// The output buffer for this request contains a TDI_ADDRESS_INFO structure,
// which contains the local address that the provider actually opened.
//
typedef struct {
    CL_NETWORK_ID     Id;
    ULONG             TdiProviderNameOffset;   // offset from start of struct
    ULONG             TdiProviderNameLength;   // in bytes, including NUL
    ULONG             TdiBindAddressOffset;    // offset from start of struct
    ULONG             TdiBindAddressLength;
    ULONG             AdapterNameOffset;    // offset from start of struct
    ULONG             AdapterNameLength;
} CX_ONLINE_NETWORK_REQUEST, *PCX_ONLINE_NETWORK_REQUEST;

//
// Offline network request
//
typedef CX_NETWORK_COMMON_REQUEST CX_OFFLINE_NETWORK_REQUEST;
typedef PCX_NETWORK_COMMON_REQUEST PCX_OFFLINE_NETWORK_REQUEST;

//
// Set network restriction request
//
typedef struct {
    CL_NETWORK_ID      Id;
    BOOLEAN            Restricted;
    ULONG              NewPriority;
} CX_SET_NETWORK_RESTRICTION_REQUEST, *PCX_SET_NETWORK_RESTRICTION_REQUEST;

//
// Get network priority request
//
typedef CX_NETWORK_COMMON_REQUEST CX_GET_NETWORK_PRIORITY_REQUEST;
typedef PCX_NETWORK_COMMON_REQUEST PCX_GET_NETWORK_PRIORITY_REQUEST;

//
// Get network priority response
//
typedef struct {
    ULONG              Priority;
} CX_GET_NETWORK_PRIORITY_RESPONSE, *PCX_GET_NETWORK_PRIORITY_RESPONSE;

//
// Set network priority request
//
typedef struct {
    CL_NETWORK_ID      Id;
    ULONG              Priority;
} CX_SET_NETWORK_PRIORITY_REQUEST, *PCX_SET_NETWORK_PRIORITY_REQUEST;

//
// Get interface priority request
//
typedef CX_INTERFACE_COMMON_REQUEST CX_GET_INTERFACE_PRIORITY_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_GET_INTERFACE_PRIORITY_REQUEST;

//
// Get interface priority response
//
typedef struct {
    ULONG              InterfacePriority;
    ULONG              NetworkPriority;
} CX_GET_INTERFACE_PRIORITY_RESPONSE, *PCX_GET_INTERFACE_PRIORITY_RESPONSE;

//
// Set interface priority request
//
typedef struct {
    CL_NODE_ID         NodeId;
    CL_NETWORK_ID      NetworkId;
    ULONG              Priority;
} CX_SET_INTERFACE_PRIORITY_REQUEST, *PCX_SET_INTERFACE_PRIORITY_REQUEST;

//
// Get node state request
//
typedef CX_NODE_COMMON_REQUEST CX_GET_NODE_STATE_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_GET_NODE_STATE_REQUEST;

//
// Get node state response
//
typedef struct {
    CLUSNET_NODE_COMM_STATE   State;
} CX_GET_NODE_STATE_RESPONSE, *PCX_GET_NODE_STATE_RESPONSE;

//
// Get network state request
//
typedef CX_NETWORK_COMMON_REQUEST CX_GET_NETWORK_STATE_REQUEST;
typedef PCX_NETWORK_COMMON_REQUEST PCX_GET_NETWORK_STATE_REQUEST;

//
// Get network state response
//
typedef struct {
    CLUSNET_NETWORK_STATE   State;
} CX_GET_NETWORK_STATE_RESPONSE, *PCX_GET_NETWORK_STATE_RESPONSE;

//
// Get interface state request
//
typedef CX_INTERFACE_COMMON_REQUEST CX_GET_INTERFACE_STATE_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_GET_INTERFACE_STATE_REQUEST;

//
// Get interface state response
//
typedef struct {
    CLUSNET_INTERFACE_STATE   State;
} CX_GET_INTERFACE_STATE_RESPONSE, *PCX_GET_INTERFACE_STATE_RESPONSE;

//
// Get node membership state request
//
typedef CX_NODE_COMMON_REQUEST CX_GET_NODE_MMSTATE_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_GET_NODE_MMSTATE_REQUEST;

//
// Get node membership state response
//
typedef struct {
    CLUSNET_NODE_STATE State;
} CX_GET_NODE_MMSTATE_RESPONSE, *PCX_GET_NODE_MMSTATE_RESPONSE;

//
// Set node membership state request
//
typedef struct _CX_SET_NODE_MMSTATE_REQUEST {
    CL_NODE_ID NodeId;
    CLUSNET_NODE_STATE State;
} CX_SET_NODE_MMSTATE_REQUEST, *PCX_SET_NODE_MMSTATE_REQUEST;

//
// Send Poison Packet request
//
typedef CX_NODE_COMMON_REQUEST CX_SEND_POISON_PKT_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_SEND_POISON_PKT_REQUEST;

//
// Set Outerscreen request. sets clusnet's notion of which nodes
// are in the cluster. used to filter poison packets from non-cluster
// members.
//
typedef struct _CX_SET_OUTERSCREEN_REQUEST {
    ULONG Outerscreen;
} CX_SET_OUTERSCREEN_REQUEST, *PCX_SET_OUTERSCREEN_REQUEST;

//
// Regroup Finished request. tell clusnet the new event epoch
//
typedef struct _CX_REGROUP_FINISHED_REQUEST {
    ULONG EventEpoch;
    ULONG RegroupEpoch;
} CX_REGROUP_FINISHED_REQUEST, *PCX_REGROUP_FINISHED_REQUEST;

//
// Import Security Context. used to ship pointers to security blobs
// from user to kernel mode so clusnet can sign its poison and
// heartbeat pkts.
//
typedef struct _CX_IMPORT_SECURITY_CONTEXT_REQUEST {
    CL_NODE_ID  JoiningNodeId;
    PVOID       PackageName;
    ULONG       PackageNameSize;
    ULONG       SignatureSize;
    PVOID       ServerContext;
    PVOID       ClientContext;
} CX_IMPORT_SECURITY_CONTEXT_REQUEST, *PCX_IMPORT_SECURITY_CONTEXT_REQUEST;

//
// Configure Multicast plumbs a network's multicast parameters into
// clusnet.
//
typedef struct _CX_CONFIGURE_MULTICAST_REQUEST {
    CL_NETWORK_ID    NetworkId;
    ULONG            MulticastNetworkBrand;
    ULONG            MulticastAddress;   // offset from start of struct
    ULONG            MulticastAddressLength;
    ULONG            Key;                // offset from start of struct
    ULONG            KeyLength;
} CX_CONFIGURE_MULTICAST_REQUEST, *PCX_CONFIGURE_MULTICAST_REQUEST;

//
// Request and response to query a network's multicast reachable set.
//
typedef CX_NETWORK_COMMON_REQUEST CX_GET_MULTICAST_REACHABLE_SET_REQUEST;
typedef PCX_NETWORK_COMMON_REQUEST PCX_GET_MULTICAST_REACHABLE_SET_REQUEST;

typedef struct _CX_GET_MULTICAST_REACHABLE_SET_RESPONSE {
    ULONG            NodeScreen;
} CX_GET_MULTICAST_REACHABLE_SET_RESPONSE, 
*PCX_GET_MULTICAST_REACHABLE_SET_RESPONSE;

//
// Add the defines for clussvc clusnet Heartbeating.
//
typedef struct _CLUSNET_SET_IAMALIVE_PARAM_REQUEST {
    ULONG               Timeout;
    ClussvcHangAction   Action;
} CLUSNET_SET_IAMALIVE_PARAM_REQUEST, *PCLUSNET_SET_IAMALIVE_PARAM_REQUEST;

#endif   //ifndef _NTDDCNET_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\kdcn\kdcn.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcn.c

Abstract:

    Clustner Xport KD extension - based on Vert's skeleton

Author:

    John Vert (jvert) 6-Aug-1992

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// globals
//

EXT_API_VERSION        ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;

CHAR igrepLastPattern[256];
DWORD igrepSearchStartAddress;
DWORD igrepLastPc;

PCHAR EventTypes[] = {
    "",                 // used if the number is out of range
    "Node Up",
    "Node Down",
    "Poison Packet Received",
    "Halt",
    "Net IF Up",
    "Net IF Unreachable",
    "Net IF Failed",
    "(not used)",
    "Add Address",
    "Delete Address"
};

PCHAR NetObjState[] = {
    "Offline",
    "OfflinePending",
    "Partitioned",
    "OnlinePending",
    "Online"
};

PCHAR NodeObjCommState[] = {
    "Offline",
    "OfflinePending",
    "Unreachable",
    "OnlinePending",
    "Online"
};

PCHAR NodeObjMemberState[] = {
    "Alive",
    "Joining",
    "Dead",
    "Not Configured"
};

PCHAR InterfaceState[] = {
    "Offline",
    "OfflinePending",
    "Unreachable",
    "OnlinePending",
    "Online"
};

PCHAR CcmpMessageTypes[] = {
    "Invalid",
    "Heartbeat",
    "Poison",
    "Membership"
};

#define TrueOrFalse( _x )  ( _x ? "True" : "False" )

/* forwards */

VOID
DumpEventData(
    PCLUSNET_EVENT_ENTRY EventAddress,
    PCLUSNET_EVENT_ENTRY EventEntry
    );

VOID
DumpInterfaceObj(
    PCNP_INTERFACE TargetIfObj,
    PCNP_INTERFACE LocalIfObj
    );

BOOL
ReadNodeTable(
    PCNP_NODE **LocalNodeTable,
    CL_NODE_ID *MaxNodeId,
    CL_NODE_ID *MinNodeId
    );

VOID
DumpNodeObjFlags(
    ULONG Flags
    );

VOID
DumpNetObjFlags(
    ULONG Flag
    );

BOOL
ReadTargetMemory(
    PVOID TargetAddress,
    PVOID LocalBuffer,
    ULONG BytesToRead
    );

__inline PCHAR
ListInUse(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY ListToCheck
    );

__inline PCHAR
TrueFalse(
    BOOLEAN Value
    );

VOID
DprintUnicodeString(
    PUNICODE_STRING String,
    DWORD_PTR       AddrString,
    PCHAR           Symbol       OPTIONAL,
    DWORD_PTR       Displacement OPTIONAL
    );

#if 0
VOID
DumpRGPCounters(
    rgp_counter_t *counters
    );

VOID
DumpClusterMask(
    PCHAR Title,
    cluster_t *
    );

VOID
DumpRGPOSSpecific(
    OS_specific_rgp_control_t *Target_rgpos,
    OS_specific_rgp_control_t *Local_rgpos
    );
#endif

/* end forwards */

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("%s Extension dll for Build %d debugging %s clusnet for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            SavedMajorVersion == 0x0c ? "Checked" : "Free",
            SavedMinorVersion
            );
}

VOID
CheckVersion(
    VOID
    )
{
    PVOID   cnDebugAddr;

    cnDebugAddr = (PVOID)GetExpression( "clusnet!cndebug" );

#if DBG
    if ( cnDebugAddr == NULL ) {
        dprintf("\r\nYou MUST use the checked built KDCN with the checked built driver!!!\n\n");
    }

    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ( cnDebugAddr != NULL ) {
        dprintf("\r\nYou MUST use the free built KDCN with the free built driver!!!\n\n");
    }
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

DECLARE_API( ustr )

/*++

Routine Description:

    This function is called as a KD extension to format and dump
    counted unicode string.

Arguments:

    see wdbgexts.h

Return Value:

    None.

--*/

{
    UNICODE_STRING UnicodeString;
    DWORD_PTR dwAddrString;
    CHAR Symbol[64];
    DWORD_PTR Displacement;
    BOOL b;

    //
    // Evaluate the argument string to get the address of
    // the string to dump.
    //

    dwAddrString = GetExpression(args);
    if ( !dwAddrString ) {
        return;
    }

    //
    // Get the symbolic name of the string
    //

    GetSymbol((LPVOID)dwAddrString,Symbol,&Displacement);

    //
    // Read the string from the debuggees address space into our
    // own.

    b = ReadMemory(dwAddrString, &UnicodeString, sizeof(UnicodeString), NULL);

    if ( !b ) {
        return;
    }

    DprintUnicodeString(&UnicodeString, dwAddrString, Symbol, Displacement);

} // ustr

DECLARE_API( netobj )
/*
 *   dump the specified clusnet network object structure or all if no
 *   arg is specified
 */
{
    PCNP_NETWORK TargetNetObj;
    CNP_NETWORK LocalNetObj;
    PCNP_NETWORK LastNetObj;
    LIST_ENTRY LocalListHead;
    PLIST_ENTRY TargetListHead;
    BOOLEAN DumpAllNetObjs = FALSE;

    if ( *args == '\0' ) {

        //
        // run down the network object list, dumping the contents of each one
        //
        TargetListHead = (PLIST_ENTRY)GetExpression( "clusnet!cnpnetworklist" );
        if ( !TargetListHead ) {
            dprintf("Can't convert clusnet!cnpnetworklist symbol\n");
            return;
        }

        //
        // read network object listhead out of target's memory
        //
        if ( !ReadTargetMemory( TargetListHead, &LocalListHead, sizeof(LIST_ENTRY))) {

            dprintf("Can't get CnpNetworkList data\n");
            return;
        }

        TargetNetObj = (PCNP_NETWORK)LocalListHead.Flink;
        LastNetObj = (PCNP_NETWORK)TargetListHead;
        DumpAllNetObjs = TRUE;

    } else {

        TargetNetObj =  (PCNP_NETWORK)GetExpression( args );
        if ( !TargetNetObj ) {
            dprintf("bad string conversion (%s) \n", args );
            return;
        }

        LastNetObj = 0;
    }

    while ( TargetNetObj != LastNetObj ) {

        if (CheckControlC()) {
            return;
        }

        //
        // read network object struct out of target's memory
        //
        TargetNetObj = CONTAINING_RECORD( TargetNetObj, CNP_NETWORK, Linkage );
        if ( !ReadTargetMemory( TargetNetObj, &LocalNetObj, sizeof( CNP_NETWORK ))) {
            dprintf("Problem reading net obj at %p\n", TargetNetObj );
            return;
        }

#if DBG
        if ( LocalNetObj.Signature != CNP_NETWORK_SIG ) {
            dprintf( "CNP_NETWORK @ %p has the wrong signature\n", TargetNetObj );
        }
#endif

        dprintf( "\nNetObj @ %p\n\n", TargetNetObj );
        dprintf( "    Next NetObj @ %p\n", LocalNetObj.Linkage.Flink );

        dprintf( "    ID = %d\n", LocalNetObj.Id );
        dprintf( "    Lock @ %p\n", &TargetNetObj->Lock );
        dprintf( "    Irql = %d\n", LocalNetObj.Irql );
        dprintf( "    RefCount = %d\n", LocalNetObj.RefCount );
        dprintf( "    Active RefCount = %d\n", LocalNetObj.ActiveRefCount );
        dprintf( "    State = %s\n", NetObjState [ LocalNetObj.State ]);
        DumpNetObjFlags( LocalNetObj.Flags );
        dprintf( "    Priority = %d\n", LocalNetObj.Priority );
        dprintf( "    DatagramHandle @ %p\n", LocalNetObj.DatagramHandle );
        dprintf( "    Datagram File Obj @ %p\n", LocalNetObj.DatagramFileObject );
        dprintf( "    Datagram Device Obj @ %p\n", LocalNetObj.DatagramDeviceObject );
        dprintf( "    TDI provider info @ %p\n", &TargetNetObj->ProviderInfo );
        dprintf( "    Current mcast group @ %p\n", LocalNetObj.CurrentMcastGroup );
        dprintf( "    Previous mcast group @ %p\n", LocalNetObj.PreviousMcastGroup );
        dprintf( "    Multicast reachable node set = %lx\n", LocalNetObj.McastReachableNodes);
        dprintf( "    Multicast reachable node count = %d\n", LocalNetObj.McastReachableCount);
        dprintf( "    Pending Delete IRP @ %p\n", LocalNetObj.PendingDeleteIrp );
        dprintf( "    Pending Offline IRP @ %p\n", LocalNetObj.PendingOfflineIrp );
        dprintf( "    Work Q Item @ %p\n", &TargetNetObj->ExWorkItem );

        if ( !DumpAllNetObjs ) {
            break;
        } else {
            TargetNetObj = (PCNP_NETWORK)LocalNetObj.Linkage.Flink;
        }
    }
} // netobj

VOID
DumpNetObjFlags(
    ULONG Flags
    )
{
    dprintf("    Flags = %08X (", Flags );
    if ( Flags & CNP_NET_FLAG_DELETING )
        dprintf(" Deleting" );
    if ( Flags & CNP_NET_FLAG_PARTITIONED )
        dprintf(" Partitioned" );
    if ( Flags & CNP_NET_FLAG_RESTRICTED )
        dprintf(" Restricted" );
    if ( Flags & CNP_NET_FLAG_LOCALDISCONN ) {
        dprintf(" Local-Disconnect" );
    }
    if ( Flags & CNP_NET_FLAG_MULTICAST ) {
        dprintf(" Multicast-Enabled" );
    }
    dprintf(")\n");
}

DECLARE_API( nodeobj )
/*
 *   if no arg, run down the node table, dumping each clusnet node object
 *   structure. otherwise, dump the indicated node obj
 */
{
    PCNP_NODE TargetNodeObj;
    CNP_NODE LocalNodeObj;
    PCNP_NODE *LocalNodeTable = NULL;
    CL_NODE_ID MaxNodeId, MinNodeId;
    ULONG StartNode, EndNode, Node;

    //
    // read in the node table
    //
    if ( !ReadNodeTable( &LocalNodeTable, &MaxNodeId, &MinNodeId )) {
        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;
    }
    
    if ( *args == '\0' ) {

        StartNode = MinNodeId;
        EndNode = MaxNodeId;
    } else {

        StartNode = EndNode = (ULONG)GetExpression( args );

        if ( StartNode > MaxNodeId ) {
            dprintf("Node ID out of Range: 0 to %d\n", MaxNodeId );

            if ( LocalNodeTable )
                free( LocalNodeTable );
            return;
        }
    }

    dprintf("Min, Max Node ID = ( %u, %d )\n", MinNodeId, MaxNodeId );

    for ( Node = StartNode; Node <= EndNode; ++Node ) {

        if (CheckControlC()) {
            break;
        }

        //
        // read node object struct out of target's memory
        //
        TargetNodeObj = *(LocalNodeTable + Node);
        if ( TargetNodeObj == NULL ) {

            continue;
        } else if ( !ReadTargetMemory( TargetNodeObj, &LocalNodeObj, sizeof( CNP_NODE ))) {

            dprintf("Problem reading node obj at %p (Node %d)\n", TargetNodeObj, Node );
            break;
        }

#if DBG
        if ( LocalNodeObj.Signature != CNP_NODE_SIG ) {
            dprintf( "CNP_NODE @ %p has the wrong signature\n", TargetNodeObj );
        }
#endif

        dprintf( "\nNodeObj @ %p\n\n", TargetNodeObj );
        dprintf( "    Linkage.Flink @ %p\n", LocalNodeObj.Linkage.Flink );

        dprintf( "    ID = %d\n", LocalNodeObj.Id );
        dprintf( "    Lock @ %p\n", &TargetNodeObj->Lock );
        dprintf( "    Irql = %d\n", LocalNodeObj.Irql );
        dprintf( "    RefCount = %d\n", LocalNodeObj.RefCount );
        dprintf( "    Comm State = %s\n", NodeObjCommState [ LocalNodeObj.CommState ]);
        dprintf( "    MMState = %s\n", NodeObjMemberState [ LocalNodeObj.MMState ]);
        DumpNodeObjFlags( LocalNodeObj.Flags );
        dprintf( "    Interface List @ %p", &TargetNodeObj->InterfaceList );
        if ( &TargetNodeObj->InterfaceList == LocalNodeObj.InterfaceList.Flink ) {
            dprintf( " (empty)" );
        }
        dprintf( "\n" );

        dprintf( "    Current Interface @ %p\n", LocalNodeObj.CurrentInterface );
        dprintf( "    Pending Delete IRP @ %p\n", LocalNodeObj.PendingDeleteIrp );

        dprintf( "    HBWasMissed = %s\n", TrueOrFalse( LocalNodeObj.HBWasMissed ));
        dprintf( "    Node Down Issued = %s\n", TrueOrFalse( LocalNodeObj.NodeDownIssued ));
        dprintf( "    MissedHBs = %u\n", LocalNodeObj.MissedHBs );
    }

    if ( LocalNodeTable ) {
        free( LocalNodeTable );
    }
} // nodeobj

VOID
DumpNodeObjFlags(
    ULONG Flags
    )
{
    dprintf("    Flags = %08X (", Flags );
    if ( Flags & CNP_NODE_FLAG_DELETING )
        dprintf(" Deleting" );
    if ( Flags & CNP_NODE_FLAG_UNREACHABLE )
        dprintf(" Unreachable" );
    if ( Flags & CNP_NODE_FLAG_LOCAL )
        dprintf(" Local" );
    dprintf(")\n");
}

DECLARE_API( nodeifs )
/*
 *   dump the interface list for the indicated node obj
 */
{
    PCNP_NODE TargetNodeObj;
    CNP_NODE LocalNodeObj;
    PCNP_NODE *LocalNodeTable = NULL;
    PCNP_INTERFACE NextTargetIfObj;
    CNP_INTERFACE LocalIfObj;
    CL_NODE_ID MaxNodeId, MinNodeId;
    ULONG Node;

    if ( *args == '\0' ) {
        dprintf("Node ID must be specified\n");
        return;
    }

    if ( !ReadNodeTable( &LocalNodeTable, &MaxNodeId, &MinNodeId )) {

        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;
    }

    Node = (ULONG)GetExpression( args );

    if ( Node > MaxNodeId || Node < MinNodeId ) {
        dprintf("Node ID is out of range: %u to %u\n", MinNodeId, MaxNodeId );

        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;
    }

    //
    // read node object struct out of target's memory
    //

    TargetNodeObj = *(LocalNodeTable + Node);
    if ( !ReadTargetMemory( TargetNodeObj, &LocalNodeObj, sizeof( CNP_NODE ))) {
        dprintf("Problem reading node obj at %p (Node %d)\n", TargetNodeObj, Node );

        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;

    }

#if DBG
    if ( LocalNodeObj.Signature != CNP_NODE_SIG ) {
        dprintf( "CNP_NODE @ %p has the wrong signature\n", TargetNodeObj );
    }
#endif

    dprintf( "\nNodeObj @ %p Interface List @ %p", TargetNodeObj, &TargetNodeObj->InterfaceList );
    if ( &TargetNodeObj->InterfaceList == LocalNodeObj.InterfaceList.Flink ) {
        dprintf( " (empty)" );
    }
    dprintf( "\n\n" );

    NextTargetIfObj = (PCNP_INTERFACE)LocalNodeObj.InterfaceList.Flink;

    while ( &TargetNodeObj->InterfaceList != (PLIST_ENTRY)NextTargetIfObj ) {

        if (CheckControlC()) {
            break;
        }

        NextTargetIfObj = CONTAINING_RECORD( NextTargetIfObj, CNP_INTERFACE, NodeLinkage );
        if ( !ReadTargetMemory( 
                  NextTargetIfObj, 
                  &LocalIfObj, 
                  FIELD_OFFSET( CNP_INTERFACE, TdiAddress ) + sizeof(TA_IP_ADDRESS)
                  )
             ) {
            break;
        }

        DumpInterfaceObj( NextTargetIfObj, &LocalIfObj );

        NextTargetIfObj = (PCNP_INTERFACE)LocalIfObj.NodeLinkage.Flink;
    }

    if ( LocalNodeTable ) {
        free( LocalNodeTable );
    }
} // nodeifs

DECLARE_API( currif )
/*
 *   for the specified node, dump the current interface obj
 */
{
    PCNP_NODE TargetNodeObj;
    CNP_NODE LocalNodeObj;
    PCNP_NODE *LocalNodeTable = NULL;
    CL_NODE_ID MaxNodeId, MinNodeId;
    CNP_INTERFACE LocalIfObj;
    ULONG Node;
    
    if ( *args == '\0' ) {
        dprintf("Node ID must be specified\n");
        return;
    }

    //
    // read in the node table
    //
    if ( !ReadNodeTable( &LocalNodeTable, &MaxNodeId, &MinNodeId )) {

        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;
    }

    Node = (ULONG)GetExpression( args );

    if ( Node > MaxNodeId || Node < MinNodeId ) {
        dprintf("Node ID is out of range: %u to %u\n", MinNodeId, MaxNodeId );

        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;
    }

    //
    // read node object struct out of target's memory
    //
    TargetNodeObj = *(LocalNodeTable + Node);

    if ( !ReadTargetMemory( TargetNodeObj, &LocalNodeObj, sizeof( CNP_NODE ))) {

        dprintf("Problem reading node obj at %p (Node %d)\n", TargetNodeObj, Node );
        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;
    }

#if DBG
    if ( LocalNodeObj.Signature != CNP_NODE_SIG ) {
        dprintf( "CNP_NODE @ %p has the wrong signature\n", TargetNodeObj );
    }
#endif

    dprintf( "\nNodeObj @ %p Current Interface @ %p\n\n", TargetNodeObj, LocalNodeObj.CurrentInterface );

    if ( LocalNodeObj.CurrentInterface ) {

        if ( ReadTargetMemory( LocalNodeObj.CurrentInterface, &LocalIfObj, sizeof( CNP_INTERFACE ))) {
            DumpInterfaceObj( LocalNodeObj.CurrentInterface, &LocalIfObj );
        }
    }
                          
    if ( LocalNodeTable ) {
        free( LocalNodeTable );
    }
} // currif

VOID
DumpInterfaceObj(
    PCNP_INTERFACE TargetIfObj,
    PCNP_INTERFACE IfObj
    )
{
    LONG i, j;
    TA_ADDRESS *TA;
    TDI_ADDRESS_IP UNALIGNED *TAIp;

#if DBG
    if ( IfObj->Signature != CNP_INTERFACE_SIG ) {
        dprintf( "CNP_INTERFACE @ %p has the wrong signature\n", TargetIfObj );
    }
#endif

    dprintf("Interface Obj @ %p\n", TargetIfObj );
    dprintf("    Node Obj @ %p\n", IfObj->Node );
    dprintf("    Net Obj @ %p\n", IfObj->Network );
    dprintf("    State = %s\n", InterfaceState[ IfObj->State ]);
    dprintf("    Priority = %d\n", IfObj->Priority );
    dprintf("    Flags = %08X\n", IfObj->Flags );
    dprintf("    MissedHBs = %u\n", IfObj->MissedHBs );
    dprintf("    Seq to send = %u\n", IfObj->SequenceToSend );
    dprintf("    Last Seq Recv'd = %u\n", IfObj->LastSequenceReceived );
    dprintf("    Multicast discovery count = %u\n", IfObj->McastDiscoverCount );
    dprintf("    AdapterWMIProviderId = %08X\n", IfObj->AdapterWMIProviderId );
    
    dprintf("    TDI Addr Len = %d\n", IfObj->TdiAddressLength );
    dprintf("    TDI Addr Count = %d\n", IfObj->TdiAddress.TAAddressCount );

    TA = IfObj->TdiAddress.Address;
    for (i=0; i < IfObj->TdiAddress.TAAddressCount; ++i ) {
        dprintf("    [%d] Addr Length = %d\n", i, TA->AddressLength );
        dprintf("    [%d] Addr Type = %d", i, TA->AddressType );

        switch ( TA->AddressType ) {
        case TDI_ADDRESS_TYPE_IP:
            TAIp = (TDI_ADDRESS_IP UNALIGNED *)TA->Address;
//            dprintf("%08X %08X\n", TAIp->in_addr,ntohl(TAIp->in_addr));
            dprintf(" (IP)\n    [%d] Port: %d Addr: %d.%d.%d.%d\n",
                    i, ntohs(TAIp->sin_port), (ntohl(TAIp->in_addr) >> 24 ) & 0xFF,
                    (ntohl(TAIp->in_addr) >> 16 ) & 0xFF,
                    (ntohl(TAIp->in_addr) >> 8 ) & 0xFF,
                    ntohl(TAIp->in_addr) & 0xFF);
            break;

        default:
            dprintf("\n    [%d] Addr:", i );
            for( j = 0; j < TA->AddressLength; ++j )
                dprintf(" %02X", TA->Address[j]);
            dprintf("\n");
        }
        TA = (TA_ADDRESS *)((CHAR UNALIGNED *)TA + TA->AddressLength);
    }
}

DECLARE_API( memlog )
/*
 *   dump the heart beat log. can optionally specify starting entry number
 */
{
    PMEMLOG_ENTRY TargetMemLog;
    PMEMLOG_ENTRY TargetLogEntry;
    MEMLOG_ENTRY LogEntry;
    PULONG TargetLogEntries;
    ULONG LogEntries;
    PULONG TargetNextLogEntry;
    ULONG NextLogEntry;
    LONG NumEntries;
    ULONG Pass;
    ULONG LineCount = 0;
    ULONG StartingEntry;
    LARGE_INTEGER LastSysTime;
    DOUBLE LastTimeDelta;
    DOUBLE FirstTimeDelta;
    BOOLEAN PrintTime = TRUE;
    LARGE_INTEGER FirstEntryTime;

    //
    // get address of MemLog and read its contents to get the real start
    // of the log
    //

    TargetMemLog = (PMEMLOG_ENTRY)GetExpression( "clusnet!memlog" );
    if ( !TargetMemLog ) {

        dprintf( "Can't find symbol clusnet!memlog\n" );
        return;
    }

    if ( !ReadTargetMemory( TargetMemLog, &TargetMemLog, sizeof( PMEMLOG_ENTRY ))) {

        return;
    }

    //
    // repeat this process, getting the size of the log and the next entry index
    //

    TargetLogEntries = (PULONG)GetExpression( "clusnet!memlogentries" );
    if ( !TargetLogEntries ) {

        dprintf( "Can't find symbol clusnet!memlogentries\n" );
        return;
    }

    if ( !ReadTargetMemory( TargetLogEntries, &LogEntries, sizeof( ULONG ))) {

        return;
    }

    TargetNextLogEntry = (PULONG)GetExpression( "clusnet!memlognextlogentry" );
    if ( !TargetNextLogEntry ) {

        dprintf( "Can't find symbol clusnet!memlognextlogentry\n" );
        return;
    }

    if ( !ReadTargetMemory( TargetNextLogEntry, &NextLogEntry, sizeof( ULONG ))) {

        return;
    }

    //
    // get optional starting entry number
    //

    if ( *args != '\0' ) {

        StartingEntry = (ULONG)GetExpression( args );
        if ( StartingEntry >= LogEntries ) {

            dprintf("Starting entry out of range (0 to %d)\n", LogEntries - 1);
            return;
        }

        if ( StartingEntry <= NextLogEntry ) {

            //
            // adjust starting number if on significant boundry
            //

            if ( StartingEntry == NextLogEntry ) {
                if ( NextLogEntry == 0 )
                    StartingEntry = LogEntries - 1;
                else
                    StartingEntry = NextLogEntry - 1;
            }

            Pass = 0;
            NumEntries = StartingEntry + 1;
        } else {

            Pass = 1;
            NumEntries = StartingEntry - NextLogEntry;
        }

        TargetLogEntry = TargetMemLog + StartingEntry;
    } else {

        Pass = 0;

        if ( NextLogEntry == 0 )
            NumEntries = LogEntries - 1;
        else
            NumEntries = NextLogEntry - 1;

        TargetLogEntry = TargetMemLog + NumEntries;
    }

    //
    // read in the most current entry to get its time. We calc the first time
    // delta from this value
    //

    if ( !ReadTargetMemory(TargetMemLog + NextLogEntry - 1, &LogEntry, sizeof( MEMLOG_ENTRY ))) {

        dprintf("can't read current log entry (%p) from memory\n\n", TargetLogEntry);
        return;
    }

    LastSysTime.QuadPart = LogEntry.SysTime.QuadPart;
    FirstEntryTime.QuadPart = LogEntry.SysTime.QuadPart;

    dprintf("MemLog @ %p, Log Entries = %d, Next Entry = %d (%p)\n\n",
            TargetMemLog, LogEntries, NextLogEntry, TargetMemLog + NextLogEntry);

    //
    // depending on our starting entry, look through the log twice.
    // next entry might have wrapped so first time we
    // dump all the entries down to the base. Next time we start at the end and 
    // dump out the remaining entries

    dprintf("First     Last\n");
    dprintf("Entry     Entry   Line  Log\n");
    dprintf("Delta     Delta   No    Type  Desc\n");

    while ( Pass < 2 ) {

        while ( NumEntries-- ) {

            if (CheckControlC()) {
                return;
            }

            if ( !ReadTargetMemory(TargetLogEntry, &LogEntry, sizeof( MEMLOG_ENTRY ))) {

                dprintf("can't read log entry (%p) from memory\n\n", TargetLogEntry);
                return;
            }

            if ( LogEntry.Type == 0 )
                break;

            LastTimeDelta = ( LastSysTime.QuadPart - LogEntry.SysTime.QuadPart ) / 10000000.0;
            FirstTimeDelta = ( FirstEntryTime.QuadPart - LogEntry.SysTime.QuadPart ) / 10000000.0;

            if ( PrintTime ) {
                dprintf("%8.3f %6.3f: (%4hu, 0x%02X) ", FirstTimeDelta, LastTimeDelta,
                        LogEntry.LineNo, LogEntry.Type );
            }

            PrintTime = TRUE;

            switch ( LogEntry.Type ) {
            case MemLogInitLog:
                dprintf("Memory Log Init'ed\n");
                break;

            case MemLogInitHB:
                dprintf("Heartbeats Init'ed\n");
                break;

            case MemLogHBStarted:
                dprintf("START: Period = %u ms\n", LogEntry.Arg1);
                break;

            case MemLogHBStopped:
                dprintf("STOPPED\n");
                break;

            case MemLogHBDpcRunning:
                dprintf("DPC not removed. HeartBeatDpcRunning = %s\n",
                        TrueOrFalse( LogEntry.Arg1 ));
                break;

            case MemLogWaitForDpcFinish:
                dprintf("DPC: Waiting to finish running\n");
                break;

            case MemLogMissedIfHB:
                dprintf("HB MISSED on interface. Node = %u net = %u",
                        LogEntry.Arg1, LogEntry.Arg2);
                PrintTime = FALSE;
                break;

            case MemLogMissedIfHB1:
                dprintf(" (IF @ %p) MissedHBCount = %d\n", LogEntry.Arg1, LogEntry.Arg2);
                break;

            case MemLogFailingIf:
                dprintf("IF FAILED. Node = %d, net = %d",
                        LogEntry.Arg1, LogEntry.Arg2);
                PrintTime = FALSE;
                break;

            case MemLogFailingIf1:
                dprintf(" (IF @ %p) IF State = %s\n", LogEntry.Arg1, InterfaceState[LogEntry.Arg2]);
                break;

            case MemLogSendHBWalkNode:
                dprintf("Walking node %d to send HB. MMState = %s\n",
                        LogEntry.Arg1, NodeObjMemberState[LogEntry.Arg2]);
                break;

            case MemLogCheckHBWalkNode:
                dprintf("Walking node %d to check for HB. MMState = %s.\n",
                        LogEntry.Arg1, NodeObjMemberState[LogEntry.Arg2]);
                break;

            case MemLogCheckHBNodeReachable:
                dprintf("Node %d is currently %sreachable\n", LogEntry.Arg1,
                        (LogEntry.Arg2 ? "" : "NOT "));
                break;

            case MemLogCheckHBMissedHB:
                dprintf("NODE MISSED HB on all IFs. MissedHBCount = %u MMState = %s\n",
                        LogEntry.Arg1, NodeObjMemberState[LogEntry.Arg2]);
                break;

            case MemLogSendingHB:
                dprintf("Sending HB to Node %d on net %d\n", LogEntry.Arg1, LogEntry.Arg2);
                break;

            case MemLogNodeDown:
                dprintf("NODE DOWN EVENT for node %d\n", LogEntry.Arg1);
                break;

            case MemLogSetDpcEvent:
                dprintf("DPC: setting finished event\n");
                break;

            case MemLogNoNetID:
                dprintf("BAD NET POINTER: Recv'd packet from node %d (%p)\n",
                        LogEntry.Arg1, LogEntry.Arg2);
                break;

            case MemLogOnlineIf:
                dprintf("NODE %d ONLINE. IF State = %s\n", LogEntry.Arg1,
                        InterfaceState[LogEntry.Arg2]);
                break;

            case MemLogSeqAckMismatch:
                dprintf("Recv'ed ack off with seq on IF %p. IF State = %s\n",
                        LogEntry.Arg1, InterfaceState[LogEntry.Arg2]);
                break;

            case MemLogNodeUp:
                dprintf("NODE UP EVENT for node %d\n", LogEntry.Arg1);
                break;

            case MemLogReceivedPacket:
                dprintf("Recv'ed HB from Node %d, net %d", LogEntry.Arg1, LogEntry.Arg2);
                PrintTime = FALSE;
                break;

            case MemLogReceivedPacket1:
                dprintf(" (S: %u A: %u)\n", LogEntry.Arg1, LogEntry.Arg2);
                break;

            case MemLogDpcTimeSkew:
                dprintf("HB DPC fired %8.3f ms late\n", (double)(LogEntry.Arg1/10000.0));
                break;

            case MemLogHBPacketSend:
                dprintf("%s Packet handed to CNP", CcmpMessageTypes[ LogEntry.Arg1 ]);
                if ( LogEntry.Arg1 == CcmpHeartbeatMsgType )
                    dprintf(" (S:%u)", LogEntry.Arg2);
                else if ( LogEntry.Arg1 == CcmpPoisonMsgType )
                    dprintf(" by %s", LogEntry.Arg2 == 1 ? "Heartbeat DPC" : "clussvc" );
                dprintf("\n");
                break;

            case MemLogHBPacketSendComplete:
                dprintf("%s Packet Send completed", CcmpMessageTypes[ LogEntry.Arg1 ]);
                if ( LogEntry.Arg1 == CcmpHeartbeatMsgType )
                    dprintf(" (S:%u)", LogEntry.Arg2);
                else if ( LogEntry.Arg1 == CcmpPoisonMsgType )
                    dprintf(" by %s", LogEntry.Arg2 == 1 ? "Heartbeat DPC" : "clussvc" );
                dprintf("\n");
                break;

            case MemLogPoisonPktReceived:
                dprintf("Poison Packet received from node %u\n", LogEntry.Arg1);
                break;

            case MemLogOuterscreen:
                dprintf("Outerscreen changed to %04X\n",
                        ((LogEntry.Arg1 & 0xFF ) << 8) | ((LogEntry.Arg1 >> 8 ) & 0xFF ));
                break;

            case MemLogNodeDownIssued:
                dprintf("Node %u NodeDownIssued set to %s\n",
                        LogEntry.Arg1, TrueOrFalse( LogEntry.Arg2 ));
                break;

            case MemLogRegroupFinished:
                dprintf("REGROUP FINISHED. New Epoch = %u\n", LogEntry.Arg1 );
                break;

            case MemLogInconsistentStates:
                dprintf("INCONSISTENT STATES. STARTING NEW REGROUP. Node = %u, MMState = %s\n",
                        LogEntry.Arg1, NodeObjMemberState[ LogEntry.Arg2 ]);
                break;

            case MemLogOutOfSequence:
                dprintf("Out Of Sequence Packet from Node = %u, SeqNo = %u\n",
                        LogEntry.Arg1, LogEntry.Arg2 );
                break;

            case MemLogInvalidSignature:
                dprintf("Packet with bad Signature from Node = %u, type = %s\n",
                        LogEntry.Arg1, CcmpMessageTypes[ LogEntry.Arg2 ]);
                break;

            case MemLogSignatureSize:
                dprintf("Invalid Signature buffer size from Node = %u, size = %u\n",
                        LogEntry.Arg1, LogEntry.Arg2 );
                break;

            case MemLogNoSecurityContext:
                dprintf("No context to verify signature for Node = %u\n",
                        LogEntry.Arg1 );
                break;

            case MemLogPacketSendFailed:
                dprintf("Packet not sent to Node %d, status = %08X\n",
                        LogEntry.Arg1, LogEntry.Arg2 );
                break;

            default:
                dprintf(" unknown event, Arg1 = %p Arg2 = %p\n",
                        LogEntry.Arg1, LogEntry.Arg2);
            }

            LastSysTime.QuadPart = LogEntry.SysTime.QuadPart;

            --TargetLogEntry;
        }

        if ( ++Pass < 2 ) {

            NumEntries = LogEntries - NextLogEntry - 1;
            TargetLogEntry = TargetMemLog + LogEntries - 1;
        }
    }
} // memlog

DECLARE_API( mlfind )
/*
 *   list the entry nums of the specified events in the memory log
 */
{
    PMEMLOG_ENTRY TargetMemLog;
    PMEMLOG_ENTRY TargetLogEntry;
    MEMLOG_ENTRY LogEntry;
    PULONG TargetLogEntries;
    ULONG LogEntries;
    PULONG TargetNextLogEntry;
    ULONG NextLogEntry;
    LONG NumEntries;
    ULONG i;
    DOUBLE FirstTimeDelta;
    LARGE_INTEGER FirstEntryTime;
    MEMLOG_TYPES LogType;
    ULONG EntryDelta;

    if ( *args == '\0' ) {

        dprintf("Event type must be specified\n");
        return;
    }

    LogType = (MEMLOG_TYPES)GetExpression( args );

    //
    // get address of MemLog and read its contents to get the real start
    // of the log
    //

    TargetMemLog = (PMEMLOG_ENTRY)GetExpression( "clusnet!memlog" );
    if ( !TargetMemLog ) {

        dprintf( "Can't find symbol clusnet!memlog\n" );
        return;
    }

    if ( !ReadTargetMemory( TargetMemLog, &TargetMemLog, sizeof( PMEMLOG_ENTRY ))) {

        return;
    }

    //
    // repeat this process, getting the size of the log and the next entry index
    //

    TargetLogEntries = (PULONG)GetExpression( "clusnet!memlogentries" );
    if ( !TargetLogEntries ) {

        dprintf( "Can't find symbol clusnet!memlogentries\n" );
        return;
    }

    if ( !ReadTargetMemory( TargetLogEntries, &LogEntries, sizeof( ULONG ))) {

        return;
    }

    TargetNextLogEntry = (PULONG)GetExpression( "clusnet!memlognextlogentry" );
    if ( !TargetNextLogEntry ) {

        dprintf( "Can't find symbol clusnet!memlognextlogentry\n" );
        return;
    }

    if ( !ReadTargetMemory( TargetNextLogEntry, &NextLogEntry, sizeof( ULONG ))) {

        return;
    }

    dprintf("MemLog @ %p, Log Entries = %d, Next Entry = %d (%p)\n",
            TargetMemLog, LogEntries, NextLogEntry, TargetMemLog + NextLogEntry);

    FirstEntryTime.QuadPart = 0;

    //
    // look through the log twice. next entry might have wrapped so first time we
    // dump all the entries down to the base. Next time we start at the end and 
    // dump out the remaining entries

    for ( i = 0; i < 2; ++i ) {

        if ( i == 0 ) {

            NumEntries =  NextLogEntry;
            TargetLogEntry = TargetMemLog + NumEntries;
        } else {

            NumEntries = LogEntries - NextLogEntry - 1;
            TargetLogEntry = TargetMemLog + LogEntries;
        }

        while ( --TargetLogEntry, NumEntries-- ) {

            if (CheckControlC()) {
                return;
            }

            if ( !ReadTargetMemory(TargetLogEntry, &LogEntry, sizeof( MEMLOG_ENTRY ))) {

                dprintf("can't read log entry (%p) from memory\n\n", TargetLogEntry);
                return;
            }

            if ( LogEntry.Type == 0 )
                break;

            if ( FirstEntryTime.QuadPart == 0 ) {
                FirstEntryTime.QuadPart = LogEntry.SysTime.QuadPart;
            }

            if ( LogEntry.Type != LogType )
                continue;

            FirstTimeDelta = ( FirstEntryTime.QuadPart - LogEntry.SysTime.QuadPart ) / 10000000.0;

            EntryDelta = (DWORD)(TargetLogEntry - TargetMemLog);
            dprintf("%8.3f: (%5hu) Entry at %d (0x%X)\n", FirstTimeDelta, LogEntry.LineNo,
                    EntryDelta, EntryDelta);
        }
    }
} // mlfind

DECLARE_API( events )

//
// run down the event file handle list, dumping interesting info for each one
//

{
    PCN_FSCONTEXT           targetFSContext;
    PCN_FSCONTEXT           lastFSContext;
    CN_FSCONTEXT            localFSContext;
    LIST_ENTRY              localListHead;
    PLIST_ENTRY             targetListHead;
    PCLUSNET_EVENT_ENTRY    nextEvent;
    CLUSNET_EVENT_ENTRY     localEvent;

    //
    // get the event file handle list head 
    //
    targetListHead = (PLIST_ENTRY)GetExpression( "clusnet!eventfilehandles" );
    if ( !targetListHead ) {

        dprintf("Can't convert clusnet!eventfilehandles symbol\n");
        return;
    }

    //
    // read CN FS context object listhead out of target's memory
    //
    if ( !ReadTargetMemory( targetListHead, &localListHead, sizeof(LIST_ENTRY))) {
        dprintf("Can't get EventFileHandles data\n");
        return;
    }

    targetFSContext = (PCN_FSCONTEXT)localListHead.Flink;
    lastFSContext = (PCN_FSCONTEXT)targetListHead;

    if ( targetFSContext == lastFSContext ) {
        dprintf("No file objects in EventFileHandles\n");
        return;
    }

    while ( targetFSContext != lastFSContext ) {

        if (CheckControlC()) {
            return;
        }

        //
        // read FS context struct out of target's memory
        //
        targetFSContext = CONTAINING_RECORD( targetFSContext, CN_FSCONTEXT, Linkage );
        if ( !ReadTargetMemory( targetFSContext, &localFSContext, sizeof( CN_FSCONTEXT ))) {
            dprintf("Problem reading FS context at %p\n", targetFSContext );
            return;
        }

#if DBG
        if ( localFSContext.Signature != CN_CONTROL_CHANNEL_SIG ) {
            dprintf( "CN_FSCONTEXT @ %p has the wrong signature\n", targetFSContext );
        }
#endif

        dprintf( "\nFSContext @ %p\n\n", targetFSContext );
        dprintf( "    Next FSContext @ %p\n", localFSContext.Linkage.Flink );

        dprintf( "    Event Mask %08X\n", localFSContext.EventMask );
        dprintf( "    Event IRP @ %p\n", localFSContext.EventIrp );
        dprintf( "    Event list @ %p %s\n", &targetFSContext->EventList,
                 ListInUse( &targetFSContext->EventList, &localFSContext.EventList ));

        nextEvent = (PCLUSNET_EVENT_ENTRY)localFSContext.EventList.Flink;
        while ( &targetFSContext->EventList != (PLIST_ENTRY)nextEvent ) {

            if (CheckControlC()) {
                break;
            }

            nextEvent = CONTAINING_RECORD( nextEvent, CLUSNET_EVENT_ENTRY, Linkage );
            if ( !ReadTargetMemory( nextEvent, &localEvent, sizeof( CLUSNET_EVENT_ENTRY ))) {
                break;
            }

            DumpEventData( nextEvent, &localEvent );

            nextEvent = (PCLUSNET_EVENT_ENTRY)localEvent.Linkage.Flink;
        }

        targetFSContext = (PCN_FSCONTEXT)localFSContext.Linkage.Flink;
    }
} // events

DWORD
GetEventTypeIndex(
    CLUSNET_EVENT_TYPE EventType
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD index;

    for ( index = 0; index < 10; ++index ) {
        if ( ( 1 << index ) & EventType ) {
            return index + 1;
        }
    }

    return 0;
}

VOID
DumpEventData(
    PCLUSNET_EVENT_ENTRY EventAddress,
    PCLUSNET_EVENT_ENTRY EventEntry
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    dprintf("    Event @ %p\n", EventAddress );
    dprintf("        Epoch  %u\n", EventEntry->EventData.Epoch );
    dprintf("        Type   0x%03X (%s)\n",
            EventEntry->EventData.EventType,
            EventTypes[ GetEventTypeIndex( EventEntry->EventData.EventType )]);
    dprintf("        NodeId %u\n", EventEntry->EventData.NodeId );
    dprintf("        NetId  %u (%08X)\n", EventEntry->EventData.NetworkId,
            EventEntry->EventData.NetworkId);
}

DECLARE_API( fsctxt )
/*
 *   dump the specified clusnet file object context struct
 */
{
    PCN_FSCONTEXT targetFSContext;
    CN_FSCONTEXT localFSContext;

    if ( *args == '\0' ) {
        dprintf("Address must be specified\n");
        return;
    }

    targetFSContext =  (PCN_FSCONTEXT)GetExpression( args );
    if ( !targetFSContext ) {
        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read network object struct out of target's memory
    //
    if ( !ReadTargetMemory( targetFSContext, &localFSContext, sizeof( CN_FSCONTEXT ))) {
        dprintf("Problem reading FS Context obj at %p\n", targetFSContext );
        return;
    }

#if DBG
    if ( localFSContext.Signature != CN_CONTROL_CHANNEL_SIG ) {
        dprintf( "CN_FSCONTEXT @ %p has the wrong signature\n", targetFSContext );
    }
#endif

    dprintf( "\nFS Context @ %p\n\n", targetFSContext );
    dprintf( "    Next FS Ctxt on EventFileHandles @ %p\n", localFSContext.Linkage.Flink );

    dprintf( "    File Obj @ %p\n", localFSContext.FileObject );
    dprintf( "    RefCount = %d\n", localFSContext.ReferenceCount );
    dprintf( "    CancelIrps = %s\n", TrueOrFalse( localFSContext.CancelIrps ));
    dprintf( "    ShutdownOnClose = %s\n", TrueOrFalse( localFSContext.ShutdownOnClose ));
    dprintf( "    CleanupEvent @ %p\n", &targetFSContext->CleanupEvent );
    dprintf( "    Event List @ %p %s\n",
             &targetFSContext->EventList,
             ListInUse( &targetFSContext->EventList, &localFSContext.EventList ));
    dprintf( "    EventIrp @ %p\n", localFSContext.EventIrp );
    dprintf( "    EventMask = %08X\n", localFSContext.EventMask );
    dprintf( "    Krn Event Callback @ %p\n", localFSContext.KmodeEventCallback );
} // fsctxt

DECLARE_API( sendreq )
/*
 *   dump the specified CNP send request struct
 */
{
    PCNP_SEND_REQUEST targetCnpSendReq;
    CNP_SEND_REQUEST localCnpSendReq;

    if ( *args == '\0' ) {
        dprintf("Address must be specified\n");
        return;
    }

    targetCnpSendReq =  (PCNP_SEND_REQUEST)GetExpression( args );
    if ( !targetCnpSendReq ) {
        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read send request struct out of target's memory
    //
    if ( !ReadTargetMemory( targetCnpSendReq, &localCnpSendReq, sizeof( CNP_SEND_REQUEST ))) {
        dprintf("Problem reading CNP send request at %p\n", targetCnpSendReq );
        return;
    }

    dprintf( "\nCNP Send Request @ %p\n\n", targetCnpSendReq );
    dprintf( "    CnResource @ %p\n", &targetCnpSendReq->CnResource );
    dprintf( "    HeaderMdl @ %p\n", localCnpSendReq.HeaderMdl );
    dprintf( "    CnpHeader @ %p\n", localCnpSendReq.CnpHeader );
    dprintf( "    UpperProtocolIrp @ %p\n", localCnpSendReq.UpperProtocolIrp );
    dprintf( "    UpperProtocolHeader @ %p\n", localCnpSendReq.UpperProtocolHeader );
    dprintf( "    UpperProtocolHeaderLength %d\n", localCnpSendReq.UpperProtocolHeaderLength );
    dprintf( "    UpperProtocolIrpMode %d\n", localCnpSendReq.UpperProtocolIrpMode );
    dprintf( "    UpperProtocolMdl @ %p\n", localCnpSendReq.UpperProtocolMdl );
    dprintf( "    UpperProtocolContext @ %p\n", localCnpSendReq.UpperProtocolContext );
    dprintf( "    CompletionRoutine @ %p\n", localCnpSendReq.CompletionRoutine );
    dprintf( "    Network @ %p\n", localCnpSendReq.Network );
    dprintf( "    DestAddress @ %p\n", localCnpSendReq.TdiSendDatagramInfo.RemoteAddress );
    dprintf( "    Multicast Group @ %p\n", localCnpSendReq.McastGroup );

} // fsctxt

#if 0
// from when regroup was in the kernel
DECLARE_API( rgpdump )
/*
 *   dump the regroup struct
 */
{
    rgp_control_t **TargetRGPAddress;
    rgp_control_t *TargetRGP;
    rgp_control_t LocalRGP;
    OS_specific_rgp_control_t *Local_rgpos;     // points to local memory
    OS_specific_rgp_control_t *Target_rgpos;    // points to target memory
    BOOL success;
    LONG BytesRead;

    //
    // get address of RGP symbol
    //

    TargetRGPAddress = (rgp_control_t **)GetExpression( "Clusnet!rgp" );

    if ( !TargetRGPAddress ) {

        dprintf("Can't convert Clusnet!rgp symbol\n");
        return;
    }

    //
    // read address of RGP block
    //

    if ( !ReadTargetMemory((PVOID)TargetRGPAddress,
                           (PVOID)&TargetRGP,
                           sizeof(rgp_control_t *))) {
        return;
    }

    //
    // read actual RGP block into our local buffer
    //

    if ( !ReadTargetMemory((PVOID)TargetRGP,
                           (PVOID)&LocalRGP,
                           sizeof( rgp_control_t ))) {
        return;
    }

    Target_rgpos = &TargetRGP->OS_specific_control;
    Local_rgpos = &LocalRGP.OS_specific_control;

    dprintf( "RGP @ %p\n\n", TargetRGP );

    dprintf( "info:\n" );
    dprintf( "    Version = %u\n", LocalRGP.rgpinfo.version );
    dprintf( "    Seq number = %u\n", LocalRGP.rgpinfo.seqnum );
    dprintf( "    Clock Period = %hu ms\n", LocalRGP.rgpinfo.a_tick );
    dprintf( "    I Am Alive ticks = %hu\n", LocalRGP.rgpinfo.iamalive_ticks );
    dprintf( "    Check ticks = %hu\n", LocalRGP.rgpinfo.check_ticks );
    dprintf( "    Min stage1 ticks = %hu\n", LocalRGP.rgpinfo.Min_Stage1_ticks );
    DumpClusterMask( "    Cluster mask = ", &LocalRGP.rgpinfo.cluster );

    dprintf( "    My node = %hu\n", LocalRGP.mynode );
    dprintf( "    Tiebreaker node = %hu\n", LocalRGP.tiebreaker );
    dprintf( "    Number of nodes in cluster = %u\n", LocalRGP.num_nodes );
    dprintf( "    Clock tick counter = %hu\n", LocalRGP.clock_ticks );
    dprintf( "    RGP counter = %hu\n", LocalRGP.rgpcounter );
    dprintf( "    Restart counter = %hu\n", LocalRGP.restartcount );
    dprintf( "    Pruning ticks = %hu\n", LocalRGP.pruning_ticks );
    dprintf( "    PFail State = %hu\n", LocalRGP.pfail_state );

    dprintf( "    Cautious Mode = %u\n", LocalRGP.cautiousmode );
    dprintf( "    Send Stage = %u\n", LocalRGP.sendstage );
    dprintf( "    Tie Breaker Selected = %u\n", LocalRGP.tiebreaker_selected );
    dprintf( "    Has Unreachable Nodes = %u\n", LocalRGP.has_unreachable_nodes );

    DumpClusterMask( "    Outer Screen      = ", &LocalRGP.outerscreen );
    DumpClusterMask( "    Inner Screen      = ", &LocalRGP.innerscreen );
    DumpClusterMask( "    Status Targets    = ", &LocalRGP.status_targets );
    DumpClusterMask( "    Poison Targets    = ", &LocalRGP.poison_targets );
    DumpClusterMask( "    Init Nodes        = ", &LocalRGP.initnodes );
    DumpClusterMask( "    End Nodes         = ", &LocalRGP.endnodes );
    DumpClusterMask( "    Unreachable Nodes = ", &LocalRGP.unreachable_nodes );

    DumpRGPOSSpecific( &TargetRGP->OS_specific_control, &LocalRGP.OS_specific_control );
}

DECLARE_API( rgposdump )
/*
 *   dump just the OS specific portion of the regroup struct
 */
{
    rgp_control_t **TargetRGPAddress;
    rgp_control_t *TargetRGP;
    rgp_control_t LocalRGP;
    OS_specific_rgp_control_t *Local_rgpos;     // points to local memory
    OS_specific_rgp_control_t *Target_rgpos;    // points to target memory
    BOOL success;
    LONG BytesRead;

    //
    // get address of RGP symbol
    //

    TargetRGPAddress = (rgp_control_t **)GetExpression( "Clusnet!rgp" );

    if ( !TargetRGPAddress ) {

        dprintf("Can't convert Clusnet!rgp symbol\n");
        return;
    }

    //
    // read address of RGP block
    //

    if ( !ReadTargetMemory((PVOID)TargetRGPAddress,
                           (PVOID)&TargetRGP,
                           sizeof(rgp_control_t *))) {
        return;
    }

    //
    // read actual RGP block into our local buffer
    //

    if ( !ReadTargetMemory((PVOID)TargetRGP,
                           (PVOID)&LocalRGP,
                           sizeof( rgp_control_t ))) {
        return;
    }

    Target_rgpos = &TargetRGP->OS_specific_control;
    Local_rgpos = &LocalRGP.OS_specific_control;

    dprintf( "RGP @ %p\n\n", TargetRGP );

    DumpRGPOSSpecific( &TargetRGP->OS_specific_control, &LocalRGP.OS_specific_control );
}

VOID
DumpRGPOSSpecific(
    OS_specific_rgp_control_t *Target_rgpos,
    OS_specific_rgp_control_t *Local_rgpos
    )
{
    dprintf( "OS specific\n" );

    dprintf( "RGP Counters:\n" );
    DumpRGPCounters( &Local_rgpos->counter );

    DumpClusterMask( "    CPUUPMASK = ", &Local_rgpos->CPUUPMASK );

    dprintf( "    RgpLock @ %p\n", &Target_rgpos->RgpLock );
    dprintf( "    RGPTimer @ %p\n", &Target_rgpos->RGPTimer );
    dprintf( "    PeriodicCheckDPC @ %p\n", &Target_rgpos->PeriodicCheckDPC );
    dprintf( "    TimerDPCFinished @ %p\n", &Target_rgpos->TimerDPCFinished );
    dprintf( "    CallbackLock @ %p\n", &Target_rgpos->CallbackLock );
    dprintf( "    CallbackIRP @ %p\n", &Target_rgpos->CallbackIrp );

    dprintf( "    CallbackEvents @ %p %s\n", &Target_rgpos->CallbackEvents,
                                               ListInUse( &Local_rgpos->CallbackEvents ));

    dprintf( "    SendMsgQLock @ %p\n", &Target_rgpos->SendMsgQLock );
    dprintf( "    SendMsgQDPC @ %p\n", &Target_rgpos->SendMsgQDPC );
    dprintf( "    SendMsgQ @ %p %s\n", &Target_rgpos->SendMsgQ,
                                         ListInUse( &Local_rgpos->SendMsgQ ));
    dprintf( "    MsgShutdown: %s\n", TrueFalse( Local_rgpos->MsgShutdown ));
    dprintf( "    MsgDPCQueued: %s\n", TrueFalse( Local_rgpos->MsgDPCQueued ));
    dprintf( "    MsgDPCFinished @ %p\n", &Target_rgpos->MsgDPCFinished );

    DumpClusterMask( "    NeedsNodeDownCallback = ", &Local_rgpos->NeedsNodeDownCallback );

} // rgpdump

VOID
DumpRGPCounters(
    rgp_counter_t *counters
    )
{
    dprintf( "    QueuedIAmAlive = %u\n", counters->QueuedIAmAlive );
    dprintf( "    RcvdLocalIAmAlive = %u\n", counters->RcvdLocalIAmAlive );
    dprintf( "    RcvdRemoteIAmAlive = %u\n", counters->RcvdRemoteIAmAlive );
    dprintf( "    RcvdRegroup = %u\n", counters->RcvdRegroup );
}

VOID
DumpClusterMask(
    PCHAR Title,
    cluster_t *nodemask
    )
{
    UINT i;

    dprintf( Title );

    for ( i = 0; i < BYTES_IN_CLUSTER; ++i ) {

        dprintf("%02X", (ULONG)(*nodemask[i]) );
    }
    dprintf("\n");
}
#endif

BOOL
ReadNodeTable(
    PCNP_NODE **LocalNodeTable,
    CL_NODE_ID *MaxNodeId,
    CL_NODE_ID *MinNodeId
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PCNP_NODE TargetNodeTable;
    CL_NODE_ID *TargetMaxNodeId;
    CL_NODE_ID *TargetMinNodeId;
    ULONG NumberOfValidNodes;

    //
    // get the address of the node table symbol on the target machine
    //

    TargetNodeTable = (PCNP_NODE)GetExpression( "clusnet!cnpnodetable" );

    if ( !TargetNodeTable ) {

        dprintf("Can't convert clusnet!cnpnnodetable symbol\n");
        return FALSE;
    }

    if ( !ReadTargetMemory( TargetNodeTable, &TargetNodeTable, sizeof(PCNP_NODE))) {

        dprintf("Can't get pointer to target node table\n");
        return FALSE;
    }

    if ( TargetNodeTable == NULL ) {

        dprintf("Node Table hasn't been allocated.\n");
        return FALSE;
    }

    //
    // get lowest and highest valid node in the cluster
    //

    TargetMaxNodeId = (CL_NODE_ID *)GetExpression( "clusnet!cnmaxvalidnodeid" );

    if ( !TargetMaxNodeId ) {

        dprintf("Can't convert clusnet!cnmaxvalidnodeid symbol\n");
        return FALSE;
    }

    if ( !ReadTargetMemory( TargetMaxNodeId, MaxNodeId, sizeof(CL_NODE_ID))) {

        dprintf("Can't get Max Node ID data\n");
        return FALSE;
    }

    TargetMinNodeId = (CL_NODE_ID *)GetExpression( "clusnet!cnminvalidnodeid" );

    if ( !TargetMinNodeId ) {

        dprintf("Can't convert clusnet!cnMinvalidnodeid symbol\n");
        return FALSE;
    }

    if ( !ReadTargetMemory( TargetMinNodeId, MinNodeId, sizeof(CL_NODE_ID))) {

        dprintf("Can't get Min Node ID data\n");
        return FALSE;
    }

    //
    // allocate space for local copy of node table. The max and min are added
    // together since Node Ids may not be zero based while the node table is
    // zero based.
    //

    NumberOfValidNodes = *MaxNodeId + *MinNodeId;
    *LocalNodeTable = malloc( NumberOfValidNodes * sizeof( PCNP_NODE ));

    if ( !*LocalNodeTable ) {

        dprintf("Can't get local mem for node table\n");
        return FALSE;
    }

    //
    // read node table from target memory
    //

    if ( !ReadTargetMemory(TargetNodeTable,
                           *LocalNodeTable,
                           ClusterDefaultMaxNodes * sizeof(PCNP_NODE))) {

        dprintf("Can't get local copy of node table data\n");
        return FALSE;
    }

    return TRUE;
}

BOOL
ReadTargetMemory(
    PVOID TargetAddress,
    PVOID LocalBuffer,
    ULONG BytesToRead
    )
{
    BOOL success;
    ULONG BytesRead;

    success = ReadMemory((ULONG_PTR)TargetAddress, LocalBuffer, BytesToRead, &BytesRead);

    if (success) {

        if (BytesRead != BytesToRead) {

            dprintf("wrong byte count. expected=%d, read =%d\n", BytesToRead, BytesRead);
        }

    } else {
        dprintf("Problem reading memory at %p for %u bytes\n",
                TargetAddress, BytesToRead);

        success = FALSE;
    }

    return success;
}

__inline PCHAR
ListInUse(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY ListToCheck
    )
{
    return ListToCheck->Flink == ListHead ? "(empty)" : "";
}

__inline PCHAR
TrueFalse(
    BOOLEAN Value
    )
{
    return Value ? "TRUE" : "FALSE";
}

VOID
DprintUnicodeString(
    PUNICODE_STRING UnicodeString,
    DWORD_PTR       AddrString,
    PCHAR           Symbol       OPTIONAL,
    DWORD_PTR       Displacement OPTIONAL
    )
{
    ANSI_STRING AnsiString;
    LPSTR StringData;
    BOOL b;
    
    StringData = malloc(UnicodeString->Length+sizeof(UNICODE_NULL));
    if ( StringData == NULL ) {
        dprintf("Unable to allocate memory for string buffer\n");
        return;
    }

    b = ReadMemory((ULONG_PTR)UnicodeString->Buffer,
                   StringData,
                   UnicodeString->Length,
                   NULL);
    if ( !b ) {
        free(StringData);
        return;
    }

    UnicodeString->Buffer = (PWSTR)StringData;
    UnicodeString->MaximumLength = UnicodeString->Length+(USHORT)sizeof(UNICODE_NULL);

    RtlUnicodeStringToAnsiString(&AnsiString,UnicodeString,TRUE);
    free(StringData);

    if (Symbol == NULL || Displacement == (DWORD_PTR) NULL) {
        dprintf("String(%d,%d) at %p: %s\n",
                UnicodeString->Length,
                UnicodeString->MaximumLength,
                AddrString,
                AnsiString.Buffer
                );
    }
    else {
        dprintf("String(%d,%d) %s+%p at %p: %s\n",
                UnicodeString->Length,
                UnicodeString->MaximumLength,
                Symbol,
                Displacement,
                AddrString,
                AnsiString.Buffer
                );
    }

    RtlFreeAnsiString(&AnsiString);

} // DprintUnicodeString

DECLARE_API( help )
{
    dprintf("Clusnet kd extensions\n\n");
    dprintf("netobj [address]               - dump a network object\n");
    dprintf("nodeobj [node ID]              - dump a node object\n");
    dprintf("nodeifs <node ID>              - dump the interface objects of a node object\n");
    dprintf("currif <node ID>               - dump the current interface object of a node object\n");
    dprintf("memlog [starting entry number] - dump the in-memory log\n");
    dprintf("mlfind <entry type>            - find all specified entry types in the memory log\n");
    dprintf("events                         - dump the FS context structs on the EventFileHandles list\n");
    dprintf("fsctxt <address>               - dump a CN_FSCONTEXT struct\n");
    dprintf("sendreq <address>              - dump a CNP send request struct\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\ntemgmt\nbtmgmt.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    nbtmgmt.c

Abstract:

    Routines for managing NBT interfaces.

Author:

    David Dion (daviddio)           December 9, 1999

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    daviddio    12-09-99    created

Notes:

--*/

#include "clusnet.h"
#include "nbtmgmt.tmh"

//
// Types
//
typedef struct _NBT_IF {
    LIST_ENTRY   Linkage;
    ULONG        InstanceNumber;
    PFILE_OBJECT FileObject;
    WCHAR        IfName[1];
} NBT_IF, *PNBT_IF;


//
// Data
//
LIST_ENTRY       NbtIfList = {NULL,NULL};
KSPIN_LOCK       NbtIfListLock = 0;


//
// Local function prototypes
//
NTSTATUS
NbtIfOpenDevice(
    IN      LPWSTR          DeviceName,
    OUT     PFILE_OBJECT    *FileObject
    );

NTSTATUS
NbtIfIssueDeviceControl(
    IN PFILE_OBJECT     FileObject,
    IN ULONG            IoControlCode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    IN PVOID            OutputBuffer,
    IN ULONG            OutputBufferLength
    );

PNBT_IF
NbtFindIf(
    IN LPWSTR  DeviceName,
    IN ULONG   Length
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, NbtIfLoad)
#pragma alloc_text(PAGE, NbtIfOpenDevice)
#pragma alloc_text(PAGE, NbtIfIssueDeviceControl)

#endif // ALLOC_PRAGMA



NTSTATUS
NbtIfIssueDeviceControl(
    IN PFILE_OBJECT FileObject,
    IN ULONG        IoControlCode,
    IN PVOID        InputBuffer,
    IN ULONG        InputBufferLength,
    IN PVOID        OutputBuffer,
    IN ULONG        OutputBufferLength
    )

/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS             status = STATUS_SUCCESS;
    IO_STATUS_BLOCK      iosb;
    KEVENT               event;
    PIRP                 irp;


    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
              IoControlCode,
              IoGetRelatedDeviceObject(FileObject),
              InputBuffer,
              InputBufferLength,
              OutputBuffer,
              OutputBufferLength,
              FALSE,
              &event,
              &iosb
              );

    if (irp != NULL) {

        status = IoCallDriver(
                     IoGetRelatedDeviceObject(FileObject),
                     irp
                     );

        if (status == STATUS_PENDING) {

            status = KeWaitForSingleObject(
                         &event,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL
                         );
            CnAssert(status == STATUS_SUCCESS);

            status = iosb.Status;
        }
    
    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Failed to build NBT request irp, status %lx\n",
                status
                ));
        }
        CnTrace(NTEMGMT_DETAIL, NbtIfIrpAllocFailed,
            "[Clusnet] Failed to build NBT request irp, status %!status!.",
            status // LOGSTATUS
            );                
    }

    return(status);

} // NbtIfIssueDeviceControl


NTSTATUS
NbtIfOpenDevice(
    IN      LPWSTR          DeviceName,
    OUT     PFILE_OBJECT    *FileObject
    )

{
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    HANDLE handle;
    NTSTATUS status;

    *FileObject = (PFILE_OBJECT) NULL;

    //
    // Open the NBT device.
    //
    RtlInitUnicodeString(&nameString, DeviceName);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = ZwCreateFile(
                 &handle,
                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                 &objectAttributes,
                 &iosb,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN_IF,
                 0,
                 NULL,
                 0
                 );

    if (NT_SUCCESS(status)) {

        // Get a pointer to the corresponding file object. The file
        // object pointer is used to issue ioctls to the device.
        status = ObReferenceObjectByHandle(
                     handle,
                     0,
                     NULL,
                     KernelMode,
                     FileObject,
                     NULL
                     );

        if (!NT_SUCCESS(status)) {
            *FileObject = (PFILE_OBJECT) NULL;
            CnTrace(NTEMGMT_DETAIL, NbtIfObDerefFailed,
                "[Clusnet] Failed to deref NBT device handle %p "
                "for device %ls, status %!status!.",
                handle,
                DeviceName, // LOGWSTR
                status // LOGSTATUS
                );                
            IF_CNDBG(CN_DEBUG_INIT) {
                CNPRINT(("[Clusnet] Failed to deref NBT device handle %p "
                         "for device %S, status %lx\n", 
                         handle, DeviceName, status));
            }
        }

        ZwClose(handle);

    } else {
        CnTrace(NTEMGMT_DETAIL, NbtIfOpenDeviceFailed,
            "[Clusnet] Failed to open NBT device %ls, status %!status!.",
            DeviceName, // LOGWSTR
            status // LOGSTATUS
            );                
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] Failed to open NBT device %S, status %lx\n", 
                     DeviceName, status));
        }
    }

    return(status);

}   // NbtIfOpenDevice


PNBT_IF
NbtFindIf(
    LPWSTR DeviceName,
    ULONG Length
    )
{
    PNBT_IF     nbtif;
    PLIST_ENTRY entry;


    for ( entry = NbtIfList.Flink;
          entry != &NbtIfList;
          entry = entry->Flink
        )
    {
        nbtif = CONTAINING_RECORD(entry, NBT_IF, Linkage);

        if (RtlCompareMemory( 
                &nbtif->IfName[0], 
                DeviceName,
                Length - sizeof(UNICODE_NULL)
                ) == Length - sizeof(UNICODE_NULL)) {
            return(nbtif);
        }
    }

    return(NULL);

} // NbtFindIf


//
// Public Routines
//
NTSTATUS
NbtIfLoad(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] NBT support loading.\n"));
    }

    KeInitializeSpinLock(&NbtIfListLock);
    InitializeListHead(&NbtIfList);

    return(STATUS_SUCCESS);

}  // NbtIfLoad


VOID
NbtIfShutdown(
    VOID
    )
{
    NTSTATUS                status;
    KIRQL                   irql;
    PLIST_ENTRY             entry;
    PNBT_IF                 nbtif;
    LIST_ENTRY              deletelist;


    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] Destroying all cluster NBT interfaces...\n"));
    }

    KeAcquireSpinLock( &NbtIfListLock, &irql );

    //
    // Move the contents of NbtIfList to the delete list
    //
    if (!IsListEmpty( &NbtIfList )) {
        RtlCopyMemory( &deletelist, &NbtIfList, sizeof(NbtIfList) );
        deletelist.Flink->Blink = &deletelist;
        deletelist.Blink->Flink = &deletelist;
        InitializeListHead( &NbtIfList );
    } else {
        InitializeListHead( &deletelist );
    }

    KeReleaseSpinLock( &NbtIfListLock, irql );

    while (!IsListEmpty( &deletelist )) {

        entry = RemoveHeadList( &deletelist );

        nbtif = CONTAINING_RECORD( entry, NBT_IF, Linkage );

        status = NbtIfIssueDeviceControl(
                     nbtif->FileObject,
                     IOCTL_NETBT_DELETE_INTERFACE,
                     NULL, // request
                     0,    // request size
                     NULL, // response
                     0     // response size
                     );

        if (status != STATUS_SUCCESS) {
            
            LPWSTR deviceName = (LPWSTR) &nbtif->IfName[0];

            CnTrace(NTEMGMT_DETAIL, NbtIfDeleteFailed,
                "[Clusnet] Failed to delete NBT interface %ls "
                "file object %p, status %!status!.",
                deviceName, // LOGWSTR
                nbtif->FileObject,
                status // LOGSTATUS
                );                

            IF_CNDBG(CN_DEBUG_NTE) {
                CNPRINT(("[Clusnet] Failed to delete NBT interface %S "
                         "file object %p, status %lx\n",
                         deviceName,
                         nbtif->FileObject,
                         status
                         ));
            }
        
        } else {

            LPWSTR deviceName = (LPWSTR) &nbtif->IfName[0];

            CnTrace(NTEMGMT_DETAIL, NbtIfDeleted,
                "[Clusnet] Delete NBT interface %ls.",
                deviceName // LOGWSTR
                );                

            IF_CNDBG(CN_DEBUG_NTE) {
                CNPRINT(("[Clusnet] Deleted NBT interface %S.\n",
                         deviceName
                         ));
            }
        }

        // Release the reference that was taken when the NBT device
        // was created.
        ObDereferenceObject(nbtif->FileObject);

        CnFreePool(nbtif);
    }

    CnTrace(NTEMGMT_DETAIL, NbtIfShutdownIfsDeleted,
        "[Clusnet] All cluster NBT interfaces destroyed."
        );                

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] All cluster NBT interfaces destroyed.\n"));
    }

    return;

} // NbtIfShutdown


NTSTATUS
NbtAddIf(
    IN     PNETBT_ADD_DEL_IF    Request,
    IN     ULONG                RequestSize,
    OUT    PNETBT_ADD_DEL_IF    Response,
    IN OUT PULONG               ResponseSize
    )
{
    NTSTATUS        status;
    PFILE_OBJECT    requestFileObject;
    PFILE_OBJECT    responseFileObject;
    PNBT_IF         nbtif;
    KIRQL           irql;


    CnTrace(NTEMGMT_DETAIL, NbtIfAdding,
        "[Clusnet] Creating new NBT interface for NBT device %ls.",
        Request->IfName // LOGWSTR
        );                

    IF_CNDBG(CN_DEBUG_NTE) {
        CNPRINT((
            "[Clusnet] Creating new NBT interface for NBT device %S...\n",
            Request->IfName
            ));
    }

    //
    // Open the NBT device specified in the request. This corresponds
    // to a particular TCP/IP interface.
    //
    status = NbtIfOpenDevice( Request->IfName, &requestFileObject );

    if (NT_SUCCESS(status)) {

        //
        // Allocate a record for the NBT interface
        //
        nbtif = CnAllocatePool(
                    FIELD_OFFSET( NBT_IF, IfName[0] )
                    + Response->Length
                    );
    
        if (nbtif != NULL) {

            //
            // Issue an ioctl to create a new NBT interface.
            // The response contains the name of the new NBT
            // interface device object.
            //
            status = NbtIfIssueDeviceControl(
                         requestFileObject,
                         IOCTL_NETBT_ADD_INTERFACE,
                         NULL,
                         0,
                         Response,
                         *ResponseSize
                         );
        
            if (NT_SUCCESS(status)
                && NT_SUCCESS(Response->Status)) {

                //
                // Open the new NBT interface device object.
                //
                status = NbtIfOpenDevice(
                             (LPWSTR) Response->IfName,
                             &responseFileObject
                             );

                if (NT_SUCCESS(status)) {

                    LPWSTR deviceName = (LPWSTR) &Response->IfName[0];
                    
                    //
                    // Store the interface name, instance, and
                    // file object corresponding to the new NBT
                    // interface device object.
                    //
                    RtlZeroMemory( 
                        nbtif,
                        FIELD_OFFSET( NBT_IF, IfName[0] ) + Response->Length
                        );

                    RtlCopyMemory(
                        &nbtif->IfName[0],
                        deviceName,
                        Response->Length
                        );

                    nbtif->InstanceNumber = Response->InstanceNumber;
                    nbtif->FileObject = responseFileObject;

                    KeAcquireSpinLock(&NbtIfListLock, &irql);

                    InsertTailList(&NbtIfList, &(nbtif->Linkage));

                    KeReleaseSpinLock(&NbtIfListLock, irql);
                
                    CnTrace(NTEMGMT_DETAIL, NbtIfAdded,
                        "[Clusnet] Created new NBT interface device %ls.",
                        deviceName // LOGWSTR
                        );                

                    IF_CNDBG(CN_DEBUG_NTE) {
                        CNPRINT((
                            "[Clusnet] Created new NBT interface "
                            "device %S.\n",
                            deviceName
                            ));
                    }

                } else {

                    CnTrace(NTEMGMT_DETAIL, NbtIfAddOpenNewFailed,
                        "[Clusnet] Failed to open NBT device for new "
                        "interface %ls, status %!status!.",
                        Request->IfName, // LOGWSTR
                        status // LOGSTATUS
                        );                

                    IF_CNDBG(CN_DEBUG_NTE) {
                        CNPRINT((
                            "[Clusnet] Failed to open NBT device for "
                            "new interface %S: %x\n",
                            Request->IfName,
                            status
                            ));
                    }

                    CnFreePool(nbtif);
                }
            } else {
                
                CnTrace(NTEMGMT_DETAIL, NbtIfAddFailed,
                    "[Clusnet] Failed to add NBT interface for "
                    "NBT device %ls, status %!status!, %!status!.",
                    Request->IfName, // LOGWSTR
                    status, // LOGSTATUS
                    Response->Status // LOGSTATUS
                    );                

                IF_CNDBG(CN_DEBUG_NTE) {
                    CNPRINT((
                        "[Clusnet] Failed to add NBT interface "
                        "for NBT device %S: %x, %x\n",
                        Request->IfName,
                        status,
                        Response->Status
                        ));
                }

                CnFreePool(nbtif);
            }
        } else {
            
            status = STATUS_INSUFFICIENT_RESOURCES;
            CnTrace(NTEMGMT_DETAIL, NbtIfAddAllocFailed,
                "[Clusnet] Failed to allocate record for NBT "
                "interface %ls, status %!status!.",
                Request->IfName, // LOGWSTR
                status // LOGSTATUS
                );                
        }

        //
        // Release reference on NBT device object corresponding
        // to TCP/IP interface.
        //
        ObDereferenceObject(requestFileObject);

    } else {
        
        CnTrace(NTEMGMT_DETAIL, NbtIfAddOpenFailed,
            "[Clusnet] Failed to open NBT device %ls for add, "
            "status %!status!.",
            Request->IfName, // LOGWSTR
            status // LOGSTATUS
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Failed to open NBT device %S: %x\n",
                Request->IfName,
                status
                ));
        }
    }

    return(status);

} // NbtAddIf


NTSTATUS
NbtDeleteIf(
    IN PNETBT_ADD_DEL_IF    Request,
    IN ULONG                RequestSize
    )
{
    NTSTATUS    status;
    PNBT_IF     nbtif;
    KIRQL       irql;
    ULONG       responseSize = 0;


    CnTrace(NTEMGMT_DETAIL, NbtIfDeleting,
        "[Clusnet] Deleting NBT interface %ls.",
        Request->IfName // LOGWSTR
        );                

    IF_CNDBG(CN_DEBUG_NTE) {
        CNPRINT((
            "[Clusnet] Attempting to delete NBT interface %S...\n",
            (LPWSTR) &Request->IfName[0]
            ));
    }

    KeAcquireSpinLock(&NbtIfListLock, &irql);

    nbtif = NbtFindIf( (LPWSTR) &Request->IfName[0], Request->Length );

    if (nbtif != NULL) {
        
        RemoveEntryList(&(nbtif->Linkage));

        KeReleaseSpinLock(&NbtIfListLock, irql);

        status = NbtIfIssueDeviceControl(
                     nbtif->FileObject,
                     IOCTL_NETBT_DELETE_INTERFACE,
                     NULL, // request
                     0,    // request size
                     NULL, // response
                     0     // response size
                     );

        if (status != STATUS_SUCCESS) {
            
            LPWSTR deviceName = (LPWSTR) &nbtif->IfName[0];

            CnTrace(NTEMGMT_DETAIL, NbtIfDeleteFailed,
                "[Clusnet] Failed to delete NBT interface %ls "
                "file object %p, status %!status!.",
                deviceName, // LOGWSTR
                nbtif->FileObject,
                status // LOGSTATUS
                );                

            IF_CNDBG(CN_DEBUG_NTE) {
                CNPRINT(("[Clusnet] Failed to delete NBT interface %S "
                         "file object %p, status %lx\n",
                         deviceName,
                         nbtif->FileObject,
                         status
                         ));
            }
        
        } else {

            LPWSTR deviceName = (LPWSTR) &nbtif->IfName[0];

            CnTrace(NTEMGMT_DETAIL, NbtIfDeleted,
                "[Clusnet] Delete NBT interface %ls.",
                deviceName // LOGWSTR
                );                

            IF_CNDBG(CN_DEBUG_NTE) {
                CNPRINT(("[Clusnet] Deleted NBT interface %S.\n",
                         deviceName
                         ));
            }
        }

        // Release the reference that was taken when the NBT device
        // was created.
        ObDereferenceObject(nbtif->FileObject);

        CnFreePool(nbtif);

    } else {
        KeReleaseSpinLock(&NbtIfListLock, irql);
    
        CnTrace(NTEMGMT_DETAIL, NbtIfDeleteNotFound,
            "[Clusnet] NBT interface %ls does not exist.",
            Request->IfName // LOGWSTR
            );                

        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT(("[Clusnet] NBT interface %S does not exist.\n", 
                     (LPWSTR) &Request->IfName[0]));
        }
    
        status = STATUS_UNSUCCESSFUL;
    }

    return (status);

} // NbtDeleteIf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cdp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cdp.h

Abstract:

    Main private header file for the Cluster Network Protocol.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#ifndef _CDP_INCLUDED_
#define _CDP_INCLUDED_


NTSTATUS
CdpInitializeSend(
    VOID
    );

VOID
CdpCleanupSend(
    VOID
    );

NTSTATUS
CdpInitializeReceive(
    VOID
    );

VOID
CdpCleanupReceive(
    VOID
    );

#endif // ifndef _CDP_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\wshclus\wshclus.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wshclus.c

Abstract:

    This module contains necessary routines for the Cluster Transport
    Windows Sockets Helper DLL.  This DLL provides the transport-specific
    support necessary for the Windows Sockets DLL to use the Cluster
    Transport.

    This file is largely a clone of the TCP/IP helper code.

Author:

    Mike Massa (mikemas)    21-Feb-1997

Revision History:

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <wchar.h>
#include <tdi.h>
#include <winsock2.h>
#include <wsahelp.h>
#include <ws2spi.h>
#include <basetyps.h>
#include <nspapi.h>
#include <nspapip.h>
#include <wsclus.h>
#include <clustdi.h>
#include <clusdef.h>
#include <ntddcnet.h>

#include "clstrcmp.h"

#define CDP_NAME L"CDP"

#define IS_DGRAM_SOCK(type)  ((type) == SOCK_DGRAM)

//
// Define valid flags for WSHOpenSocket2().
//

#define VALID_CDP_FLAGS         (WSA_FLAG_OVERLAPPED)

//
// Structure and variables to define the triples supported by the
// Cluster Transport. The first entry of each array is considered
// the canonical triple for that socket type; the other entries are
// synonyms for the first.
//

typedef struct _MAPPING_TRIPLE {
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;

MAPPING_TRIPLE CdpMappingTriples[] =
                   { AF_CLUSTER,   SOCK_DGRAM,  CLUSPROTO_CDP,
                     AF_CLUSTER,   SOCK_DGRAM,  0,
                     AF_CLUSTER,   0,           CLUSPROTO_CDP,
                     AF_UNSPEC,    0,           CLUSPROTO_CDP,
                     AF_UNSPEC,    SOCK_DGRAM,  CLUSPROTO_CDP
                   };

//
// Winsock 2 WSAPROTOCOL_INFO structures for all supported protocols.
//

#define WINSOCK_SPI_VERSION 2
#define CDP_MESSAGE_SIZE    (65535-20-68)

WSAPROTOCOL_INFOW Winsock2Protocols[] =
    {
        //
        // CDP
        //

        {
            XP1_CONNECTIONLESS                      // dwServiceFlags1
                | XP1_MESSAGE_ORIENTED
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO               // dwProviderFlags
                | PFL_HIDDEN,
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_CLUSTER,                             // iAddressFamily
            sizeof(SOCKADDR_CLUSTER),               // iMaxSockAddr
            sizeof(SOCKADDR_CLUSTER),               // iMinSockAddr
            SOCK_DGRAM,                             // iSocketType
            CLUSPROTO_CDP,                          // iProtocol
            0,                                      // iProtocolMaxOffset
            LITTLEENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            CDP_MESSAGE_SIZE,                       // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Cluster Datagram Protocol"      // szProtocol
        }

    };

#define NUM_WINSOCK2_PROTOCOLS  \
            ( sizeof(Winsock2Protocols) / sizeof(Winsock2Protocols[0]) )

//
// The GUID identifying this provider.
//

GUID ClusnetProviderGuid = { /* 03614682-8c42-11d0-a8fc-00a0c9062993 */
    0x03614682,
    0x8c42,
    0x11d0,
    {0x00, 0xa0, 0xc9, 0x06, 0x29, 0x93, 0x8c}
    };

LPWSTR ClusnetProviderName = L"ClusNet";

//
// Forward declarations of internal routines.
//

BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    );

NTSTATUS
DoNtIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    );


//
// The socket context structure for this DLL.  Each open ClusNet socket
// will have one of these context structures, which is used to maintain
// information about the socket.
//

typedef struct _WSHSOCKET_CONTEXT {
    INT     AddressFamily;
    INT     SocketType;
    INT     Protocol;
    INT     ReceiveBufferSize;
    DWORD   Flags;
    BOOLEAN IgnoreNodeState;
} WSHSOCKET_CONTEXT, *PWSHSOCKET_CONTEXT;

#define DEFAULT_RECEIVE_BUFFER_SIZE 8192



BOOLEAN
DllInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL
    )
{

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        //
        // We don't need to receive thread attach and detach
        // notifications, so disable them to help application
        // performance.
        //

        DisableThreadLibraryCalls( DllHandle );

        return TRUE;

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;

} // DllInitialize



INT
WSHGetSockaddrType (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    )

/*++

Routine Description:

    This routine parses a sockaddr to determine the type of the
    machine address and endpoint address portions of the sockaddr.
    This is called by the winsock DLL whenever it needs to interpret
    a sockaddr.

Arguments:

    Sockaddr - a pointer to the sockaddr structure to evaluate.

    SockaddrLength - the number of bytes in the sockaddr structure.

    SockaddrInfo - a pointer to a structure that will receive information
        about the specified sockaddr.


Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    UNALIGNED SOCKADDR_CLUSTER *sockaddr = (PSOCKADDR_CLUSTER)Sockaddr;
    ULONG i;


    //
    // Make sure that the address family is correct.
    //

    if ( sockaddr->sac_family != AF_CLUSTER ) {
        return WSAEAFNOSUPPORT;
    }

    //
    // Make sure that the length is correct.
    //

    if ( SockaddrLength < sizeof(SOCKADDR_CLUSTER) ) {
        return WSAEFAULT;
    }

    //
    // The address passed the tests, looks like a good address.
    // Determine the type of the address portion of the sockaddr.
    //

    if ( sockaddr->sac_node == CLUSADDR_ANY ) {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoWildcard;
    } else {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoNormal;
    }

    //
    // Determine the type of the port (endpoint) in the sockaddr.
    //

    if ( sockaddr->sac_port == 0 ) {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;
    } else {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoNormal;
    }

    //
    // Zero out the sin_reserved_mbz part of the address.  We silently allow
    // nonzero values in this field.
    //

    sockaddr->sac_zero = 0;

    return NO_ERROR;

} // WSHGetSockaddrType


INT
WSHGetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    )

/*++

Routine Description:

    This routine retrieves information about a socket for those socket
    options supported in this helper DLL.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to getsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to getsockopt().

    OptionName - the optname parameter passed to getsockopt().

    OptionValue - the optval parameter passed to getsockopt().

    OptionLength - the optlen parameter passed to getsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHSOCKET_CONTEXT context = HelperDllSocketContext;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );


    return WSAENOPROTOOPT;

} // WSHGetSocketInformation


INT
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a wildcard socket address.  A wildcard address
    is one which will bind the socket to an endpoint of the transport's
    choosing.  For the Cluster Network, a wildcard address has
    node ID == 0 and port = 0.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a wildcard
        address.

    Sockaddr - points to a buffer which will receive the wildcard socket
        address.

    SockaddrLength - receives the length of the wioldcard sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PSOCKADDR_CLUSTER   ClusAddr = (PSOCKADDR_CLUSTER) Sockaddr;


    if ( *SockaddrLength < sizeof(SOCKADDR_CLUSTER) ) {
        return WSAEFAULT;
    }

    *SockaddrLength = sizeof(SOCKADDR_CLUSTER);

    ClusAddr->sac_family = AF_CLUSTER;
    ClusAddr->sac_port = 0;
    ClusAddr->sac_node = CLUSADDR_ANY;
    ClusAddr->sac_zero = 0;

    return NO_ERROR;

} // WSAGetWildcardSockaddr


DWORD
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    )

/*++

Routine Description:

    Returns the list of address family/socket type/protocol triples
    supported by this helper DLL.

Arguments:

    Mapping - receives a pointer to a WINSOCK_MAPPING structure that
        describes the triples supported here.

    MappingLength - the length, in bytes, of the passed-in Mapping buffer.

Return Value:

    DWORD - the length, in bytes, of a WINSOCK_MAPPING structure for this
        helper DLL.  If the passed-in buffer is too small, the return
        value will indicate the size of a buffer needed to contain
        the WINSOCK_MAPPING structure.

--*/

{
    DWORD mappingLength;


    mappingLength = FIELD_OFFSET(WINSOCK_MAPPING, Mapping[0])
                        + sizeof(CdpMappingTriples);

    //
    // If the passed-in buffer is too small, return the length needed
    // now without writing to the buffer.  The caller should allocate
    // enough memory and call this routine again.
    //

    if ( mappingLength > MappingLength ) {
        return mappingLength;
    }

    //
    // Fill in the output mapping buffer with the list of triples
    // supported in this helper DLL.
    //

    Mapping->Rows = sizeof(CdpMappingTriples) / sizeof(CdpMappingTriples[0]);
    Mapping->Columns = sizeof(MAPPING_TRIPLE) / sizeof(DWORD);

    RtlMoveMemory(
        Mapping->Mapping,
        CdpMappingTriples,
        sizeof(CdpMappingTriples)
        );

    //
    // Return the number of bytes we wrote.
    //

    return mappingLength;

} // WSHGetWinsockMapping


INT
WSHOpenSocket (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )
{

    return WSHOpenSocket2(
               AddressFamily,
               SocketType,
               Protocol,
               0,           // Group
               0,           // Flags
               TransportDeviceName,
               HelperDllSocketContext,
               NotificationEvents
               );

} // WSHOpenSocket


INT
WSHOpenSocket2 (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    IN GROUP Group,
    IN DWORD Flags,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )

/*++

Routine Description:

    Does the necessary work for this helper DLL to open a socket and is
    called by the winsock DLL in the socket() routine.  This routine
    verifies that the specified triple is valid, determines the NT
    device name of the TDI provider that will support that triple,
    allocates space to hold the socket's context block, and
    canonicalizes the triple.

Arguments:

    AddressFamily - on input, the address family specified in the
        socket() call.  On output, the canonicalized value for the
        address family.

    SocketType - on input, the socket type specified in the socket()
        call.  On output, the canonicalized value for the socket type.

    Protocol - on input, the protocol specified in the socket() call.
        On output, the canonicalized value for the protocol.

    Group - Identifies the group for the new socket.

    Flags - Zero or more WSA_FLAG_* flags as passed into WSASocket().

    TransportDeviceName - receives the name of the TDI provider that
        will support the specified triple.

    HelperDllSocketContext - receives a context pointer that the winsock
        DLL will return to this helper DLL on future calls involving
        this socket.

    NotificationEvents - receives a bitmask of those state transitions
        this helper DLL should be notified on.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHSOCKET_CONTEXT context;


    if ( IsTripleInList(
             CdpMappingTriples,
             sizeof(CdpMappingTriples) / sizeof(CdpMappingTriples[0]),
             *AddressFamily,
             *SocketType,
             *Protocol ) ) {

        //
        // It's a CDP socket. Check the flags.
        //

        if( (Flags & ~VALID_CDP_FLAGS ) != 0) {

            return WSAEINVAL;

        }

        //
        // Return the canonical form of a CDP socket triple.
        //

        *AddressFamily = CdpMappingTriples[0].AddressFamily;
        *SocketType = CdpMappingTriples[0].SocketType;
        *Protocol = CdpMappingTriples[0].Protocol;

        //
        // Indicate the name of the TDI device that will service
        // SOCK_DGRAM sockets in the cluster address family.
        //

        RtlInitUnicodeString( TransportDeviceName, DD_CDP_DEVICE_NAME );

    } else {

        //
        // This should never happen if the registry information about this
        // helper DLL is correct.  If somehow this did happen, just return
        // an error.
        //

        return WSAEINVAL;
    }

    //
    // Allocate context for this socket.  The Windows Sockets DLL will
    // return this value to us when it asks us to get/set socket options.
    //

    context = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*context) );

    if ( context == NULL ) {
        return WSAENOBUFS;
    }

    //
    // Initialize the context for the socket.
    //

    context->AddressFamily = *AddressFamily;
    context->SocketType = *SocketType;
    context->Protocol = *Protocol;
    context->ReceiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;
    context->Flags = Flags;
    context->IgnoreNodeState = FALSE;

    //
    // Tell the Windows Sockets DLL which state transitions we're
    // interested in being notified of.

    if (*SocketType == SOCK_DGRAM) {

        *NotificationEvents = WSH_NOTIFY_CLOSE | WSH_NOTIFY_BIND;
    }

    //
    // Everything worked, return success.
    //

    *HelperDllSocketContext = context;
    return NO_ERROR;

} // WSHOpenSocket2


INT
WSHNotify (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    )

/*++

Routine Description:

    This routine is called by the winsock DLL after a state transition
    of the socket.  Only state transitions returned in the
    NotificationEvents parameter of WSHOpenSocket() are notified here.
    This routine allows a winsock helper DLL to track the state of
    socket and perform necessary actions corresponding to state
    transitions.

Arguments:

    HelperDllSocketContext - the context pointer given to the winsock
        DLL by WSHOpenSocket().

    SocketHandle - the handle for the socket.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    NotifyEvent - indicates the state transition for which we're being
        called.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHSOCKET_CONTEXT context = HelperDllSocketContext;
    INT err;


    if ( NotifyEvent == WSH_NOTIFY_CLOSE ) {

        //
        // Free the socket context.
        //
        RtlFreeHeap( RtlProcessHeap( ), 0, context );

    } else if ( NotifyEvent == WSH_NOTIFY_BIND ) {
        ULONG true = TRUE;

        if ( context->IgnoreNodeState ) {
            ULONG     responseSize = 0;
            NTSTATUS  status;


            status = DoNtIoctl(
                         TdiAddressObjectHandle,
                         IOCTL_CX_IGNORE_NODE_STATE,
                         NULL,
                         0,
                         NULL,
                         &responseSize
                         );

            if( !NT_SUCCESS(status)) {
                return(WSAENOPROTOOPT);   // SWAG
            }
        }
    }
    else {
        return WSAEINVAL;
    }

    return NO_ERROR;

} // WSHNotify


INT
WSHSetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    )

/*++

Routine Description:

    This routine sets information about a socket for those socket
    options supported in this helper DLL.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to setsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to setsockopt().

    OptionName - the optname parameter passed to setsockopt().

    OptionValue - the optval parameter passed to setsockopt().

    OptionLength - the optlen parameter passed to setsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHSOCKET_CONTEXT context = HelperDllSocketContext;
    INT error;
    INT optionValue;


    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( OptionLength < sizeof(*context) ) {
            return WSAEINVAL;
        }

        if ( HelperDllSocketContext == NULL ) {

            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            context = RtlAllocateHeap(
                          RtlProcessHeap( ),
                          0,
                          sizeof(*context)
                          );

            if ( context == NULL ) {
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //

            RtlCopyMemory( context, OptionValue, sizeof(*context) );

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHSOCKET_CONTEXT *)OptionValue = context;

            return NO_ERROR;

        }
    }

    return WSAENOPROTOOPT;

} // WSHSetSocketInformation


INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPWSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Enumerates the protocols supported by this helper.

Arguments:

    lpiProtocols - Pointer to a NULL-terminated array of protocol
        identifiers. Only protocols specified in this array will
        be returned by this function. If this pointer is NULL,
        all protocols are returned.

    lpTransportKeyName -

    lpProtocolBuffer - Pointer to a buffer to fill with PROTOCOL_INFO
        structures.

    lpdwBufferLength - Pointer to a variable that, on input, contains
        the size of lpProtocolBuffer. On output, this value will be
        updated with the size of the data actually written to the buffer.

Return Value:

    INT - The number of protocols returned if successful, -1 if not.

--*/

{
    DWORD bytesRequired;
    PPROTOCOL_INFO CdpProtocolInfo;
    BOOL useCdp = FALSE;
    DWORD i;


    UNREFERENCED_PARAMETER(lpTransportKeyName);


    //
    // Make sure that the caller cares about CDP.
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) ) {

        for ( i = 0; lpiProtocols[i] != 0; i++ ) {
            if ( lpiProtocols[i] == CLUSPROTO_CDP ) {
                useCdp = TRUE;
            }
        }

    } else {

        useCdp = TRUE;
    }

    if ( !useCdp ) {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = (DWORD)((sizeof(PROTOCOL_INFO) * 1) +
                        ( (wcslen( CDP_NAME ) + 1) * sizeof(WCHAR)));

    if ( bytesRequired > *lpdwBufferLength ) {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    //
    // Fill in CDP info, if requested.
    //

    if ( useCdp ) {

        CdpProtocolInfo = lpProtocolBuffer;
        CdpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)lpProtocolBuffer + *lpdwBufferLength -
                ( (wcslen( CDP_NAME ) + 1) * sizeof(WCHAR) ) );
        CdpProtocolInfo->dwServiceFlags = XP_CONNECTIONLESS |
                                              XP_MESSAGE_ORIENTED;
        CdpProtocolInfo->iAddressFamily = AF_CLUSTER;
        CdpProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_CLUSTER);
        CdpProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_CLUSTER);
        CdpProtocolInfo->iSocketType = SOCK_DGRAM;
        CdpProtocolInfo->iProtocol = CLUSPROTO_CDP;
        CdpProtocolInfo->dwMessageSize = CDP_MESSAGE_SIZE;
        wcscpy( CdpProtocolInfo->lpProtocol, CDP_NAME );
    }

    *lpdwBufferLength = bytesRequired;

    return 1;

} // WSHEnumProtocols



BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    )

/*++

Routine Description:

    Determines whether the specified triple has an exact match in the
    list of triples.

Arguments:

    List - a list of triples (address family/socket type/protocol) to
        search.

    ListLength - the number of triples in the list.

    AddressFamily - the address family to look for in the list.

    SocketType - the socket type to look for in the list.

    Protocol - the protocol to look for in the list.

Return Value:

    BOOLEAN - TRUE if the triple was found in the list, false if not.

--*/

{
    ULONG i;


    //
    // Walk through the list searching for an exact match.
    //

    for ( i = 0; i < ListLength; i++ ) {

        //
        // If all three elements of the triple match, return indicating
        // that the triple did exist in the list.
        //

        if ( AddressFamily == List[i].AddressFamily &&
             SocketType == List[i].SocketType &&
             Protocol == List[i].Protocol
           ) {
            return TRUE;
        }
    }

    //
    // The triple was not found in the list.
    //

    return FALSE;

} // IsTripleInList


#if 0



INT
WINAPI
WSHGetBroadcastSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a broadcast socket address.  A broadcast address
    may be used as a destination for the sendto() API to send a datagram
    to all interested clients.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a broadcast
        address.

    Sockaddr - points to a buffer which will receive the broadcast socket
        address.

    SockaddrLength - receives the length of the broadcast sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{

    LPSOCKADDR_CLUSTER addr;

    if( *SockaddrLength < sizeof(SOCKADDR_CLUSTER) ) {

        return WSAEFAULT;

    }

    *SockaddrLength = sizeof(SOCKADDR_CLUSTER);

    //
    // Build the broadcast address.
    //

    addr = (LPSOCKADDR_CLUSTER)Sockaddr;

    RtlZeroMemory( addr, sizeof(*addr));

    addr->sac_family = AF_CLUSTER;
    addr->sac_node = CLUSADDR_BROADCAST;

    return NO_ERROR;

} // WSAGetBroadcastSockaddr

#endif // 0


INT
WINAPI
WSHGetWSAProtocolInfo (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    )

/*++

Routine Description:

    Retrieves a pointer to the WSAPROTOCOL_INFOW structure(s) describing
    the protocol(s) supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProtocolInfo - Receives a pointer to the WSAPROTOCOL_INFOW array.

    ProtocolInfoEntries - Receives the number of entries in the array.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProtocolInfo == NULL ||
        ProtocolInfoEntries == NULL ) {

        return WSAEFAULT;

    }

    if( ClRtlStrICmp( ProviderName, ClusnetProviderName ) == 0 ) {

        *ProtocolInfo = Winsock2Protocols;
        *ProtocolInfoEntries = NUM_WINSOCK2_PROTOCOLS;

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetWSAProtocolInfo


INT
WINAPI
WSHAddressToString (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    )

/*++

Routine Description:

    Converts a SOCKADDR to a human-readable form.

Arguments:

    Address - The SOCKADDR to convert.

    AddressLength - The length of Address.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    AddressString - Receives the formatted address string.

    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    WCHAR string[32];
    INT length;
    LPSOCKADDR_CLUSTER addr;

    //
    // Quick sanity checks.
    //

    if( Address == NULL ||
        AddressLength < sizeof(SOCKADDR_CLUSTER) ||
        AddressString == NULL ||
        AddressStringLength == NULL ) {

        return WSAEFAULT;

    }

    addr = (LPSOCKADDR_CLUSTER)Address;

    if( addr->sac_family != AF_CLUSTER ) {

        return WSAEINVAL;

    }

    //
    // Do the converstion.
    //

    length = wsprintfW(string, L"%u", addr->sac_node);
    length += wsprintfW(string + length, L":%u", addr->sac_port);

    length++;   // account for terminator

    if( *AddressStringLength < (DWORD)length ) {

        return WSAEFAULT;

    }

    *AddressStringLength = (DWORD)length;

    RtlCopyMemory(
        AddressString,
        string,
        length * sizeof(WCHAR)
        );

    return NO_ERROR;

} // WSHAddressToString


INT
WINAPI
WSHStringToAddress (
    IN LPWSTR AddressString,
    IN DWORD AddressFamily,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPSOCKADDR Address,
    IN OUT LPINT AddressLength
    )

/*++

Routine Description:

    Fills in a SOCKADDR structure by parsing a human-readable string.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    AddressFamily - The address family to which the string belongs.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    Address - Receives the SOCKADDR structure.

    AddressLength - On input, contains the length of Address. On output,
        contains the number of bytes actually written to Address.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
    LPWSTR terminator;
    WCHAR ch;
    USHORT base;
    USHORT port;
    ULONG node;
    LPSOCKADDR_CLUSTER addr;

    //
    // Quick sanity checks.
    //

    if( AddressString == NULL ||
        *AddressString == UNICODE_NULL ||
        Address == NULL ||
        AddressLength == NULL ||
        *AddressLength < sizeof(SOCKADDR_CLUSTER) ) {

        return WSAEFAULT;

    }

    if( AddressFamily != AF_CLUSTER ) {

        return WSAEINVAL;

    }

    //
    // Convert it. The format is node:port
    //

    node = 0;
    base = 10;
    terminator = AddressString;

    if( *terminator == L'0' ) {
        base = 8;
        terminator++;

        if( *terminator == UNICODE_NULL ) {
            return(WSAEINVAL);
        }

        if ( *terminator == L'x' ) {
            base = 16;
            terminator++;
        }
    }

    while( (ch = *terminator++) != L':' ) {
        if( iswdigit(ch) ) {
            node = ( node * base ) + ( ch - L'0' );
        } else if( base == 16 && iswxdigit(ch) ) {
            node = ( node << 4 );
            node += ch + 10 - ( iswlower(ch) ? L'a' : L'A' );
        } else {
            return WSAEINVAL;
        }
    }

    port = 0;
    base = 10;

    if( *terminator == L'0' ) {
        base = 8;
        terminator++;

        if( *terminator == UNICODE_NULL ) {
            return(WSAEINVAL);
        }

        if( *terminator == L'x' ) {
            base = 16;
            terminator++;
        }
    }

    while( (ch = *terminator++) != UNICODE_NULL ) {
        if( iswdigit(ch) ) {
            port = ( port * base ) + ( ch - L'0' );
        } else if( base == 16 && iswxdigit(ch) ) {
            port = ( port << 4 );
            port += ch + 10 - ( iswlower(ch) ? L'a' : L'A' );
        } else {
            return WSAEINVAL;
        }
    }

    //
    // Build the address.
    //

    RtlZeroMemory(
        Address,
        sizeof(SOCKADDR_CLUSTER)
        );

    addr = (LPSOCKADDR_CLUSTER)Address;
    *AddressLength = sizeof(SOCKADDR_CLUSTER);

    addr->sac_family = AF_CLUSTER;
    addr->sac_port = port;
    addr->sac_node = node;

    return NO_ERROR;

} // WSHStringToAddress


INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )

/*++

Routine Description:

    Returns the GUID identifying the protocols supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProviderGuid - Points to a buffer that receives the provider's GUID.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProviderGuid == NULL ) {

        return WSAEFAULT;

    }

    if( ClRtlStrICmp( ProviderName, ClusnetProviderName ) == 0 ) {

        RtlCopyMemory(
            ProviderGuid,
            &ClusnetProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetProviderGuid

INT
WINAPI
WSHIoctl (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    OUT LPBOOL NeedsCompletion
    )

/*++

Routine Description:

    Performs queries & controls on the socket. This is basically an
    "escape hatch" for IOCTLs not supported by MSAFD.DLL. Any unknown
    IOCTLs are routed to the socket's helper DLL for protocol-specific
    processing.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're controlling.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    IoControlCode - Control code of the operation to perform.

    InputBuffer - Address of the input buffer.

    InputBufferLength - The length of InputBuffer.

    OutputBuffer - Address of the output buffer.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - Receives the number of bytes actually written
        to the output buffer.

    Overlapped - Pointer to a WSAOVERLAPPED structure for overlapped
        operations.

    CompletionRoutine - Pointer to a completion routine to call when
        the operation is completed.

    NeedsCompletion - WSAIoctl() can be overlapped, with all the gory
        details that involves, such as setting events, queuing completion
        routines, and posting to IO completion ports. Since the majority
        of the IOCTL codes can be completed quickly "in-line", MSAFD.DLL
        can optionally perform the overlapped completion of the operation.

        Setting *NeedsCompletion to TRUE (the default) causes MSAFD.DLL
        to handle all of the IO completion details iff this is an
        overlapped operation on an overlapped socket.

        Setting *NeedsCompletion to FALSE tells MSAFD.DLL to take no
        further action because the helper DLL will perform any necessary
        IO completion.

        Note that if a helper performs its own IO completion, the helper
        is responsible for maintaining the "overlapped" mode of the socket
        at socket creation time and NOT performing overlapped IO completion
        on non-overlapped sockets.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    PWSHSOCKET_CONTEXT context = HelperDllSocketContext;
    INT err;


    //
    // Quick sanity checks.
    //

    if( HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        NeedsCompletion == NULL ) {

        return WSAEINVAL;

    }

    *NeedsCompletion = TRUE;

    switch( IoControlCode ) {

    case SIO_CLUS_IGNORE_NODE_STATE :
        //
        // This option is only valid for datagram sockets.
        //
        if ( !IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        if( TdiAddressObjectHandle != NULL ) {
            ULONG     responseSize = 0;
            NTSTATUS  status;


            status = DoNtIoctl(
                         TdiAddressObjectHandle,
                         IOCTL_CX_IGNORE_NODE_STATE,
                         NULL,
                         0,
                         NULL,
                         &responseSize
                         );

            if( NT_SUCCESS(status) ) {
                err = NO_ERROR;
            } else {
                err = WSAENOPROTOOPT;   // SWAG
            }
        }
        else {
            err = NO_ERROR;
        }

        context->IgnoreNodeState = TRUE;

        break;

    default :
        err = WSAEINVAL;
        break;
    }

    return err;

}   // WSHIoctl



NTSTATUS
DoNtIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    )
/*++

Routine Description:

    Packages and issues an ioctl.

Arguments:

    Handle - An open file Handle on which to issue the request.

    IoctlCode - The IOCTL opcode.

    Request - A pointer to the input buffer.

    RequestSize - Size of the input buffer.

    Response - A pointer to the output buffer.

    ResponseSize - On input, the size in bytes of the output buffer.
                   On output, the number of bytes returned in the output buffer.

Return Value:

    NT Status Code.

--*/
{
    IO_STATUS_BLOCK    ioStatusBlock;
    NTSTATUS           status = 0xaabbccdd;
    HANDLE             event;


    event = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (event == NULL) {
        return(GetLastError());
    }

    ioStatusBlock.Information = 0;

    status = NtDeviceIoControlFile(
                 Handle,                          // Driver Handle
                 event,                           // Event
                 NULL,                            // APC Routine
                 NULL,                            // APC context
                 &ioStatusBlock,                  // Status block
                 IoctlCode,                       // Control code
                 Request,                         // Input buffer
                 RequestSize,                     // Input buffer size
                 Response,                        // Output buffer
                 *ResponseSize                    // Output buffer size
                 );

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                     event,
                     TRUE,
                     NULL
                     );
    }

    if (status == STATUS_SUCCESS) {
        status = ioStatusBlock.Status;
        
        // NOTENOTE: on 64 bit this truncates, might want to add > check code

        *ResponseSize = (ULONG)ioStatusBlock.Information;
    }
    else {
        *ResponseSize = 0;
    }

    CloseHandle(event);

    return(status);

}  // DoIoctl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cdpinit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cdpinit.c

Abstract:

    Initialization and Cleanup code for the Cluster Datagram Protocol.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cdpinit.tmh"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CdpLoad)
#pragma alloc_text(PAGE, CdpUnload)

#endif // ALLOC_PRAGMA


BOOLEAN  CdpInitialized = FALSE;


//
// Initialization/cleanup routines
//
NTSTATUS
CdpLoad(
    VOID
    )
{
    NTSTATUS  status;
    ULONG     i;


    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CDP] Loading...\n"));
    }

    for (i=0; i<CX_ADDROBJ_TABLE_SIZE; i++) {
        InitializeListHead(&(CxAddrObjTable[i]));
    }

    CnInitializeLock(&CxAddrObjTableLock, CX_ADDROBJ_TABLE_LOCK);

    CdpInitialized = TRUE;

    status = CdpInitializeSend();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CdpInitializeReceive();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CDP] Loaded.\n"));
    }

    return(STATUS_SUCCESS);

}  // CdpLoad


VOID
CdpUnload(
    VOID
    )
{
    PAGED_CODE();

    if (CdpInitialized) {
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CDP] Unloading...\n"));
        }

        CdpCleanupReceive();

        CdpCleanupSend();

        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CDP] Unloaded.\n"));
        }

        CdpInitialized = FALSE;
    }

    return;

}  // CdpUnload
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\ntemgmt\ntemgmt.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ntemgmt.c

Abstract:

    Routines for managing IP Network Table Entries.

Author:

    Mike Massa (mikemas)           April 16, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     04-16-97    created

Notes:

--*/

#include "clusnet.h"
#include "ntemgmt.tmh"


//
// Types
//
typedef struct {
    LIST_ENTRY   Linkage;
    ULONG        Address;
    USHORT       Context;
    ULONG        Instance;
} IPA_NTE, *PIPA_NTE;


//
// Data
//
LIST_ENTRY       IpaNteList = {NULL,NULL};
KSPIN_LOCK       IpaNteListLock = 0;
HANDLE           IpaIpHandle = NULL;
PDEVICE_OBJECT   IpaIpDeviceObject = NULL;
PFILE_OBJECT     IpaIpFileObject = NULL;


//
// Local function prototypes
//
NTSTATUS
IpaIssueDeviceControl (
    IN ULONG            IoControlCode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    IN PVOID            OutputBuffer,
    IN PULONG           OutputBufferLength
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, IpaLoad)
#pragma alloc_text(PAGE, IpaIssueDeviceControl)
#pragma alloc_text(PAGE, IpaInitialize)


#endif // ALLOC_PRAGMA



NTSTATUS
IpaIssueDeviceControl(
    IN ULONG    IoControlCode,
    IN PVOID    InputBuffer,
    IN ULONG    InputBufferLength,
    IN PVOID    OutputBuffer,
    IN PULONG   OutputBufferLength
    )

/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS -- Indicates the status of the request.

Notes:

    Called in the context of the system process.

--*/

{
    NTSTATUS             status = STATUS_SUCCESS;
    IO_STATUS_BLOCK      ioStatusBlock;
    PIRP                 irp;
    PKEVENT              event;


    PAGED_CODE();

    CnAssert(IpaIpHandle != NULL);
    CnAssert(IpaIpFileObject != NULL);
    CnAssert(IpaIpDeviceObject != NULL);
    CnAssert(CnSystemProcess == (PKPROCESS) IoGetCurrentProcess());

    //
    // Reference the file object. This reference will be removed by the I/O
    // completion code.
    //
    status = ObReferenceObjectByPointer(
                 IpaIpFileObject,
                 0,
                 NULL,
                 KernelMode
                 );

    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Failed to reference IP device file handle, status %lx\n",
                status
                ));
        }
        CnTrace(NTEMGMT_DETAIL, IpaNteObRefFailed,
            "[Clusnet] Failed to reference IP device file handle, status %!status!.",
            status // LOGSTATUS
            );                
        return(status);
    }

    event = CnAllocatePool(sizeof(KEVENT));

    if (event != NULL) {
        KeInitializeEvent(event, NotificationEvent, FALSE);

        irp = IoBuildDeviceIoControlRequest(
                  IoControlCode,
                  IpaIpDeviceObject,
                  InputBuffer,
                  InputBufferLength,
                  OutputBuffer,
                  *OutputBufferLength,
                  FALSE,
                  event,
                  &ioStatusBlock
                  );

        if (irp != NULL) {
            status = IoCallDriver(IpaIpDeviceObject, irp);

            //
            // If necessary, wait for the I/O to complete.
            //
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(
                    event,
                    UserRequest,
                    KernelMode,
                    FALSE,
                    NULL
                    );
            }

            if (NT_SUCCESS(status)) {
                status = ioStatusBlock.Status;

                // NOTENOTE: on 64 bit this is a truncation might
                // want > check code

                *OutputBufferLength = (ULONG)ioStatusBlock.Information;
            }
            else {
                IF_CNDBG(CN_DEBUG_NTE) {
                    CNPRINT((
                        "[Clusnet] NTE request failed, status %lx\n",
                        status
                        ));
                }
                CnTrace(NTEMGMT_DETAIL, IpaNteRequestFailed,
                    "[Clusnet] NTE request failed, status %!status!.",
                    status // LOGSTATUS
                    );                
                *OutputBufferLength = 0;
            }

            CnFreePool(event);

            return(status);
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            IF_CNDBG(CN_DEBUG_NTE) {
                CNPRINT((
                    "[Clusnet] Failed to build NTE request irp, status %lx\n",
                    status
                    ));
            }
            CnTrace(NTEMGMT_DETAIL, IpaNteIrpAllocFailed,
                "[Clusnet] Failed to build NTE request irp, status %!status!.",
                status // LOGSTATUS
                );                
        }

        CnFreePool(event);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Failed to allocate memory for event object.\n"
                ));
        }
        CnTrace(NTEMGMT_DETAIL, IpaNteEventAllocFailed,
            "[Clusnet] Failed to allocate event object, status %!status!.",
            status // LOGSTATUS
            );                
    }

    ObDereferenceObject(IpaIpFileObject);

    return(status);

} // IpaDeviceControl


PIPA_NTE
IpaFindNTE(
    USHORT  Context
    )
{
    PIPA_NTE      nte;
    PLIST_ENTRY   entry;


    for ( entry = IpaNteList.Flink;
          entry != &IpaNteList;
          entry = entry->Flink
        )
    {
        nte = CONTAINING_RECORD(entry, IPA_NTE, Linkage);

        if (Context == nte->Context) {
            return(nte);
        }
    }

    return(NULL);

} // IpaFindNTE


NTSTATUS
IpaAddNTECompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++

Routine Description:

    IpaAddNTECompletion is the completion routine for an
    IOCTL_IP_ADD_NTE IRP. It completes the processing for
    an IOCTL_CLUSNET_ADD_NTE request and releases CnResource.
    
Arguments:

    DeviceObject - not used
    Irp - completed IRP
    Context - local NTE data structure
        
Return value

    Must not be STATUS_MORE_PROCESSING_REQUIRED
    
--*/
{
    PIP_ADD_NTE_RESPONSE     response;
    PIPA_NTE                 nte;
    NTSTATUS                 status;
    KIRQL                    irql;

    nte = (PIPA_NTE) Context;

    status = Irp->IoStatus.Status;

    if (status == STATUS_SUCCESS) {

        response = 
            (PIP_ADD_NTE_RESPONSE) Irp->AssociatedIrp.SystemBuffer;

        nte->Context = response->Context;
        nte->Instance = response->Instance;

        CnTrace(NTEMGMT_DETAIL, IpaNteCreatedNte,
            "[Clusnet] Created new NTE, context %u, instance %u.",
            nte->Context, // LOGUSHORT
            nte->Instance // LOGULONG
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Created new NTE %lu, instance %u\n",
                nte->Context,
                nte->Instance
                ));
        }

        KeAcquireSpinLock(&IpaNteListLock, &irql);

        InsertTailList(&IpaNteList, &(nte->Linkage));

        KeReleaseSpinLock(&IpaNteListLock, irql);
    }
    else {

        CnTrace(NTEMGMT_DETAIL, IpaNteCreateNteFailed,
            "[Clusnet] Failed to create new NTE, status %!status!.",
            status // LOGSTATUS
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Failed to create new NTE, status %lx\n",
                status
                ));
        }

        CnFreePool(nte);
    }

    //
    // Irp was already marked pending in our dispatch routine, but leave
    // this code in case the dispatch routine is ever changed.
    //
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    return(status);

} // IpaAddNTECompletion


NTSTATUS
IpaDeleteNTECompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++

Routine Description:

    IpaDeleteNTECompletion is the completion routine for an
    IOCTL_IP_DELETE_NTE IRP. It completes the processing for
    an IOCTL_CLUSNET_ADD_NTE request and releases CnResource.
    
Arguments:

    DeviceObject - not used
    Irp - completed IRP
    Context - local NTE data structure
        
Return value

    Must not be STATUS_MORE_PROCESSING_REQUIRED
    
--*/
{
    PIPA_NTE                 nte;
    NTSTATUS                 status;

    nte = (PIPA_NTE) Context;

    status = Irp->IoStatus.Status;

    if (status != STATUS_SUCCESS) {
        CnTrace(NTEMGMT_DETAIL, IpaNteDeleteNteFailed,
            "[Clusnet] Failed to delete NTE context %u, status %!status!.",
            nte->Context, // LOGUSHORT
            status // LOGSTATUS
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT(("[Clusnet] Failed to delete NTE %u, status %lx\n",
                     nte->Context,
                     status
                     ));
        }
        CnAssert(status == STATUS_SUCCESS);
    }
    else {
        CnTrace(NTEMGMT_DETAIL, IpaNteNteDeleted,
            "[Clusnet] Deleted NTE %u.",
            nte->Context // LOGUSHORT
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT(("[Clusnet] Deleted NTE %u\n", nte->Context));
        }
    }

    CnFreePool(nte);

    //
    // Irp was already marked pending in our dispatch routine, but leave
    // this code in case the dispatch routine is ever changed.
    //
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    return(status);

} // IpaDeleteNTECompletion


NTSTATUS
IpaSetNTEAddressCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++

Routine Description

    IpaSetNTEAddressCompletion is the completion routine for an
    IOCTL_IP_SET_ADDRESS IRP. It completes the processing for
    an IOCTL_CLUSNET_SET_NTE_ADDRESS request and releases
    CnResource.
    
Arguments

    DeviceObject - not used
    Irp - completed IRP
    Context - former IP address of NTE, must be restored in
        IpaNteList if IOCTL failed
        
Return value

    Must not be STATUS_MORE_PROCESSING_REQUIRED
    
--*/
{
    PIP_SET_ADDRESS_REQUEST request;
    NTSTATUS                status; 
    KIRQL                   irql;
    PIPA_NTE                nte;

    request = (PIP_SET_ADDRESS_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    
    status = Irp->IoStatus.Status;

    if (status != STATUS_SUCCESS) {
        CnTrace(NTEMGMT_DETAIL, IpaNteSetNteFailed,
            "[Clusnet] Failed to set address for NTE %u, status %!status!.",
            request->Context, // LOGUSHORT
            status // LOGSTATUS
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Failed to set NTE %u, status %lx\n",
                request->Context,
                status
                ));
        }

        KeAcquireSpinLock(&IpaNteListLock, &irql);

        nte = IpaFindNTE(request->Context);

        if ((nte != NULL) && (nte->Address == request->Address)) {
            nte->Address = PtrToUlong(Context);
        }

        KeReleaseSpinLock(&IpaNteListLock, irql);
    }
    else {
        CnTrace(NTEMGMT_DETAIL, IpaNteSetNteAddress,
            "[Clusnet] Set NTE %u to address %x.",
            request->Context, // LOGUSHORT
            request->Address // LOGXLONG
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Set NTE %u to address %lx\n",
                request->Context,
                request->Address
                ));
        }
    }

    //
    // Irp was already marked pending in our dispatch routine, but leave
    // this code in case the dispatch routine is ever changed.
    //
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    return(status);

} // IpaSetNTEAddressCompletion

//
// Public Routines
//
NTSTATUS
IpaLoad(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] NTE support loading.\n"));
    }

    KeInitializeSpinLock(&IpaNteListLock);
    InitializeListHead(&IpaNteList);

    return(STATUS_SUCCESS);

}  // IpaLoad


NTSTATUS
IpaInitialize(
    VOID
    )
{
    NTSTATUS             status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES    objectAttributes;
    UNICODE_STRING       nameString;
    IO_STATUS_BLOCK      ioStatusBlock;


    PAGED_CODE( );

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] NTE support initializing.\n"));
    }

    CnAssert(IsListEmpty(&IpaNteList));
    CnAssert(IpaIpHandle == NULL);
    CnAssert(CnSystemProcess != NULL);

    //
    // Open handles in the context of the system process
    //
    KeAttachProcess(CnSystemProcess);

    //
    // Open the IP device.
    //
    RtlInitUnicodeString(&nameString, DD_IP_DEVICE_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = ZwCreateFile(
                 &IpaIpHandle,
                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN_IF,
                 0,
                 NULL,
                 0
                 );

    if (!NT_SUCCESS(status)) {
        CnTrace(NTEMGMT_DETAIL, IpaNteOpenIpFailed,
            "[Clusnet] Failed to open IP device, status %!status!.",
            status // LOGSTATUS
            );                
        
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] Failed to open IP device, status %lx\n", status));
        }
        goto error_exit;
    }

    status = ObReferenceObjectByHandle(
                 IpaIpHandle,
                 0,
                 NULL,
                 KernelMode,
                 &IpaIpFileObject,
                 NULL
                 );

    if (!NT_SUCCESS(status)) {
        CnTrace(NTEMGMT_DETAIL, IpaNteRefIpFailed,
            "[Clusnet] Failed to reference IP device, status %!status!.",
            status // LOGSTATUS
            );                
        
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] Failed to reference IP device file handle, status %lx\n", status));
        }
        ZwClose(IpaIpHandle); IpaIpHandle = NULL;
        goto error_exit;
    }

    IpaIpDeviceObject = IoGetRelatedDeviceObject(IpaIpFileObject);

    CnAdjustDeviceObjectStackSize(CnDeviceObject, IpaIpDeviceObject);

    status = STATUS_SUCCESS;

error_exit:

    KeDetachProcess();

    return(status);

}  // IpaInitialize


VOID
IpaShutdown(
    VOID
    )
{
    NTSTATUS                status;
    KIRQL                   irql;
    PLIST_ENTRY             entry;
    PIPA_NTE                nte;
    IP_DELETE_NTE_REQUEST   request;
    ULONG                   responseSize = 0;


    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] Destroying all cluster NTEs...\n"));
    }

    if (IpaIpHandle != NULL) {
        //
        // Handles was opened in the context of the system process.
        //
        CnAssert(CnSystemProcess != NULL);
        KeAttachProcess(CnSystemProcess);

        KeAcquireSpinLock(&IpaNteListLock, &irql);

        while (!IsListEmpty(&IpaNteList)) {
            entry = RemoveHeadList(&IpaNteList);

            KeReleaseSpinLock(&IpaNteListLock, irql);

            nte = CONTAINING_RECORD(entry, IPA_NTE, Linkage);

            request.Context = nte->Context;

            status = IpaIssueDeviceControl(
                         IOCTL_IP_DELETE_NTE,
                         &request,
                         sizeof(request),
                         NULL,
                         &responseSize
                         );

            if (status != STATUS_SUCCESS) {
                CnTrace(NTEMGMT_DETAIL, IpaNteShutdownDeleteNteFailed,
                    "[Clusnet] Shutdown: failed to delete NTE %u, status %!status!.",
                    nte->Context, // LOGUSHORT
                    status // LOGSTATUS
                    );                

                IF_CNDBG(CN_DEBUG_INIT) {
                    CNPRINT(("[Clusnet] Failed to delete NTE %u, status %lx\n",
                             nte->Context,
                             status
                             ));
                }
            }
            else {
                CnTrace(NTEMGMT_DETAIL, IpaNteShutdownDeletedNte,
                    "[Clusnet] Shutdown: deleted NTE context %u, instance %u.",
                    nte->Context, // LOGUSHORT
                    nte->Instance // LOGULONG
                    );                

                IF_CNDBG(CN_DEBUG_INIT) {
                    CNPRINT(("[Clusnet] Deleted NTE %u\n", request.Context));
                }
            }

            CnFreePool(nte);

            KeAcquireSpinLock(&IpaNteListLock, &irql);
        }

        KeReleaseSpinLock(&IpaNteListLock, irql);

        CnTrace(NTEMGMT_DETAIL, IpaNteShutdownNtesDeleted,
            "[Clusnet] All cluster NTEs destroyed."
            );                
        
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] All cluster NTEs destroyed.\n"));
        }

        ObDereferenceObject(IpaIpFileObject);
        ZwClose(IpaIpHandle);
        IpaIpHandle = NULL;
        IpaIpFileObject = NULL;
        IpaIpDeviceObject = NULL;

        KeDetachProcess();
    }

    return;

} // IpaShutdown


NTSTATUS
IpaAddNTE(
    IN PIRP                     Irp,
    IN PIO_STACK_LOCATION       IrpSp
    )
/*++

Routine Description

    IpaAddNTE issues an IOCTL_IP_ADD_NTE to IP to add an NTE. 
    Irp is reused. It must be allocated with sufficient stack
    locations, as determined when IpaIpDeviceObject was opened
    in IpaInitialize.
    
Arguments

    Irp - IRP from I/O manager to clusnet
    IrpSp - current IRP stack location
    
Return Value

    STATUS_PENDING, or error status if request is not submitted
    to IP.
    
--*/
{
    NTSTATUS                 status;
    PIP_ADD_NTE_REQUEST      request;
    ULONG                    requestSize;
    ULONG                    responseSize;
    PIPA_NTE                 nte;
    PIO_STACK_LOCATION       nextIrpSp;


    //
    // Verify input parameters
    //
    requestSize =
        IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    responseSize =
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (requestSize < sizeof(IP_ADD_NTE_REQUEST)) {
        ULONG correctSize = sizeof(IP_ADD_NTE_REQUEST);
        CnTrace(NTEMGMT_DETAIL, IpaNteAddInvalidReqSize,
            "[Clusnet] Add NTE request size %u invalid, "
            "should be %u.",
            requestSize, // LOGULONG
            correctSize // LOGULONG
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Add NTE request size %d invalid, should be %d.\n",
                requestSize,
                sizeof(IP_ADD_NTE_REQUEST)
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    } else if (responseSize < sizeof(IP_ADD_NTE_RESPONSE)) {
        ULONG correctSize = sizeof(IP_ADD_NTE_RESPONSE);
        CnTrace(NTEMGMT_DETAIL, IpaNteAddInvalidResponseSize,
            "[Clusnet] Add NTE response size %u invalid, "
            "should be %u.",
            responseSize, // LOGULONG
            correctSize // LOGULONG
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Add NTE response size %d invalid, should be %d.\n",
                responseSize,
                sizeof(IP_ADD_NTE_RESPONSE)
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Verify that Irp has sufficient stack locations
    //
    if (Irp->CurrentLocation - IpaIpDeviceObject->StackSize < 1) {
        UCHAR correctSize = IpaIpDeviceObject->StackSize+1;
        CnTrace(NTEMGMT_DETAIL, IpaNteAddNoIrpStack,
            "[Clusnet] Add NTE IRP has %u remaining stack locations, "
            "need %u.",
            Irp->CurrentLocation, // LOGUCHAR
            correctSize // LOGUCHAR
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Add NTE IRP has %d stack locations, need %d.\n",
                Irp->CurrentLocation,
                IpaIpDeviceObject->StackSize
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    }

    request = (PIP_ADD_NTE_REQUEST) Irp->AssociatedIrp.SystemBuffer;

    CnTrace(NTEMGMT_DETAIL, IpaNteCreatingNte,
        "[Clusnet] Creating new NTE for address %x.",
        request->Address // LOGXLONG
        );                

    IF_CNDBG(CN_DEBUG_NTE) {
        CNPRINT((
            "[Clusnet] Creating new NTE for address %lx...\n",
            request->Address
            ));
    }

    //
    // Allocate a local NTE data structure.
    //
    nte = CnAllocatePool(sizeof(IPA_NTE));

    if (nte == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    nte->Address = request->Address;

    //
    // Set up the next IRP stack location for IP.
    // IOCTL_CLUSNET_ADD_NTE uses the same request
    // and response buffer, so there is no need to
    // alter the IRP system buffer.
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    nextIrpSp = IoGetNextIrpStackLocation(Irp);
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode 
        = IOCTL_IP_ADD_NTE;
    nextIrpSp->FileObject = IpaIpFileObject;

    IoSetCompletionRoutine(
        Irp,
        IpaAddNTECompletion,
        (PVOID) nte,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Mark the IRP pending, since we return STATUS_PENDING
    // regardless of the result of IoCallDriver.
    //
    IoMarkIrpPending(Irp);

    //
    // Issue the request
    //
    IoCallDriver(IpaIpDeviceObject, Irp);

    //
    // At this point we must return STATUS_PENDING so that
    // the clusnet dispatch routine will not try to complete
    // the IRP. The lower-level driver is required to complete
    // the IRP, and errors will be handled in the completion
    // routine.
    //
    return (STATUS_PENDING);

} // IpaAddNTE


NTSTATUS
IpaDeleteNTE(
    IN PIRP                     Irp,
    IN PIO_STACK_LOCATION       IrpSp
    )
/*++

Routine Description

    IpaDeleteNTE issues an IOCTL_IP_DELETE_NTE to IP to delete
    an NTE. Irp is reused. It must be allocated with sufficient
    stack locations, as determined when IpaIpDeviceObject was
    opened in IpaInitialize.
    
Arguments

    Irp - IRP from I/O manager to clusnet
    IrpSp - current IRP stack location
    
Return Value

    STATUS_PENDING, or error status if request is not submitted
    to IP.
    
--*/
{
    NTSTATUS                 status;
    PIP_DELETE_NTE_REQUEST   request;
    ULONG                    requestSize;
    PIPA_NTE                 nte;
    KIRQL                    irql;
    PIO_STACK_LOCATION       nextIrpSp;


    //
    // Verify input parameters
    //
    requestSize =
        IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(IP_DELETE_NTE_REQUEST)) {
        ULONG correctSize = sizeof(IP_DELETE_NTE_REQUEST);
        CnTrace(NTEMGMT_DETAIL, IpaNteDelInvalidReqSize,
            "[Clusnet] Delete NTE request size %u invalid, "
            "should be %u.",
            requestSize, // LOGULONG
            correctSize // LOGULONG
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Delete NTE request size %d invalid, "
                "should be %d.\n",
                requestSize,
                sizeof(IP_DELETE_NTE_REQUEST)
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Verify that Irp has sufficient stack locations
    //
    if (Irp->CurrentLocation - IpaIpDeviceObject->StackSize < 1) {
        UCHAR correctSize = IpaIpDeviceObject->StackSize+1;
        CnTrace(NTEMGMT_DETAIL, IpaNteDeleteNoIrpStack,
            "[Clusnet] Delete NTE IRP has %u remaining stack locations, "
            "need %u.",
            Irp->CurrentLocation, // LOGUCHAR
            correctSize // LOGUCHAR
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Delete NTE IRP has %d stack locations, "
                "need %d.\n",
                Irp->CurrentLocation,
                IpaIpDeviceObject->StackSize
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    }

    request = (PIP_DELETE_NTE_REQUEST) Irp->AssociatedIrp.SystemBuffer;

    //
    // Find the NTE in local NTE list and remove.
    //
    KeAcquireSpinLock(&IpaNteListLock, &irql);

    nte = IpaFindNTE(request->Context);

    if (nte == NULL) {
        KeReleaseSpinLock(&IpaNteListLock, irql);

        CnTrace(NTEMGMT_DETAIL, IpaNteDeleteNteUnknown,
            "[Clusnet] NTE %u does not exist.",
            request->Context // LOGUSHORT
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] NTE %u does not exist.\n", 
                request->Context
                ));
        }

        return(STATUS_UNSUCCESSFUL);
    }

    RemoveEntryList(&(nte->Linkage));

    KeReleaseSpinLock(&IpaNteListLock, irql);

    //
    // Set up the next IRP stack location for IP.
    // IOCTL_CLUSNET_ADD_NTE uses the same request
    // and response buffer, so there is no need to
    // alter the IRP system buffer.
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    nextIrpSp = IoGetNextIrpStackLocation(Irp);
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode 
        = IOCTL_IP_DELETE_NTE;
    nextIrpSp->FileObject = IpaIpFileObject;

    IoSetCompletionRoutine(
        Irp,
        IpaDeleteNTECompletion,
        (PVOID) nte,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Mark the IRP pending, since we return STATUS_PENDING
    // regardless of the result of IoCallDriver.
    //
    IoMarkIrpPending(Irp);

    //
    // Issue the request
    //
    IoCallDriver(IpaIpDeviceObject, Irp);

    //
    // At this point we must return STATUS_PENDING so that
    // the clusnet dispatch routine will not try to complete
    // the IRP. The lower-level driver is required to complete
    // the IRP, and errors will be handled in the completion
    // routine.
    //
    return (STATUS_PENDING);

} // IpaDeleteNTE


NTSTATUS
IpaSetNTEAddress(
    IN PIRP                     Irp,
    IN PIO_STACK_LOCATION       IrpSp
    )
/*++

Routine Description

    IpaSetNTEAddress issues an IOCTL_IP_SET_ADDRESS to IP in order
    to set the IP address for an NTE. Irp is reused. It must be
    allocated with sufficient stack locations, as determined when
    IpaIpDeviceObject was opened in IpaInitialize.
    
Arguments

    Irp - IRP from I/O manager to clusnet
    IrpSp - current IRP stack location
    
Return Value

    STATUS_PENDING, or error status if request is not submitted
    to IP.
    
--*/
{
    NTSTATUS                    status;
    PIP_SET_ADDRESS_REQUEST_EX  request;
    ULONG                       requestSize;
    PIPA_NTE                    nte;
    KIRQL                       irql;
    PIO_STACK_LOCATION          nextIrpSp;
    ULONG                       oldAddress;


    //
    // Verify input parameters
    //
    requestSize =
        IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(IP_SET_ADDRESS_REQUEST_EX)) {
        ULONG correctSize = sizeof(IP_SET_ADDRESS_REQUEST_EX);
        CnTrace(NTEMGMT_DETAIL, IpaNteSetInvalidReqSize,
            "[Clusnet] Set NTE request size %u invalid, "
            "should be %u.",
            requestSize, // LOGULONG
            correctSize // LOGULONG
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Set NTE request size %d invalid, should be %d.\n",
                requestSize,
                sizeof(IP_SET_ADDRESS_REQUEST_EX)
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Verify that Irp has sufficient stack locations
    //
    if (Irp->CurrentLocation - IpaIpDeviceObject->StackSize < 1) {
        UCHAR correctSize = IpaIpDeviceObject->StackSize+1;
        CnTrace(NTEMGMT_DETAIL, IpaNteSetNoIrpStack,
            "[Clusnet] Set NTE IRP has %u remaining stack locations, "
            "need %u.",
            Irp->CurrentLocation, // LOGUCHAR
            correctSize // LOGUCHAR
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Set NTE IRP has %d stack locations, need %d.\n",
                Irp->CurrentLocation,
                IpaIpDeviceObject->StackSize
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    }

    request = (PIP_SET_ADDRESS_REQUEST_EX)
              Irp->AssociatedIrp.SystemBuffer;

    IF_CNDBG(CN_DEBUG_NTE) {
        CNPRINT((
            "[Clusnet] Attempting to set NTE %u to address %lx...\n",
            request->Context,
            request->Address
            ));
    }

    KeAcquireSpinLock(&IpaNteListLock, &irql);

    nte = IpaFindNTE(request->Context);

    if (nte != NULL) {
        oldAddress = nte->Address;
        nte->Address = request->Address;

        KeReleaseSpinLock(&IpaNteListLock, irql);

        //
        // Set up the next IRP stack location for IP.
        // IOCTL_CLUSNET_SET_NTE_ADDRESS uses the same request
        // and response buffer, so there is no need to alter the
        // IRP system buffer.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        
        nextIrpSp = IoGetNextIrpStackLocation(Irp);
        nextIrpSp->Parameters.DeviceIoControl.IoControlCode 
            = IOCTL_IP_SET_ADDRESS_EX;
        nextIrpSp->FileObject = IpaIpFileObject;

        IoSetCompletionRoutine(
            Irp,
            IpaSetNTEAddressCompletion,
            UlongToPtr(oldAddress),
            TRUE,
            TRUE,
            TRUE
            );

        //
        // Mark the IRP pending, since we return STATUS_PENDING
        // regardless of the result of IoCallDriver.
        //
        IoMarkIrpPending(Irp);

        //
        // Issue the request
        //
        IoCallDriver(IpaIpDeviceObject, Irp);

        //
        // At this point we must return STATUS_PENDING so that
        // the clusnet dispatch routine will not try to complete
        // the IRP. The lower-level driver is required to complete
        // the IRP, and errors will be handled in the completion
        // routine.
        //
        status = STATUS_PENDING;

    } else {
        
        KeReleaseSpinLock(&IpaNteListLock, irql);

        CnTrace(NTEMGMT_DETAIL, IpaNteSetNteUnknown,
            "[Clusnet] NTE %u does not exist.",
            request->Context // LOGUSHORT
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT(("[Clusnet] NTE %u does not exist.\n", 
                     request->Context
                     ));
        }

        status = STATUS_UNSUCCESSFUL;
    }

    return(status);

} // IpaSetNTEAddress


BOOLEAN
IpaIsAddressRegistered(
    ULONG  Address
    )
{
    PIPA_NTE      nte;
    KIRQL         irql;
    PLIST_ENTRY   entry;
    BOOLEAN       isAddressRegistered = FALSE;


    KeAcquireSpinLock(&IpaNteListLock, &irql);

    for ( entry = IpaNteList.Flink;
          entry != &IpaNteList;
          entry = entry->Flink
        )
    {
        nte = CONTAINING_RECORD(entry, IPA_NTE, Linkage);

        if (nte->Address == Address) {
            isAddressRegistered = TRUE;
            break;
        }
    }

    KeReleaseSpinLock(&IpaNteListLock, irql);

    return(isAddressRegistered);

} // IpaIsAddressRegistered
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cdpsend.c ===
/*++                            

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cdpsend.c

Abstract:

    TDI Send datagram routines.

Author:

    Mike Massa (mikemas)           February 20, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-20-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cdpsend.tmh"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CdpInitializeSend)

#endif // ALLOC_PRAGMA


//
// Local Types
//

// CDP_SEND_CONTEXT is currently empty
// typedef struct {
// } CDP_SEND_CONTEXT, *PCDP_SEND_CONTEXT;
typedef PVOID PCDP_SEND_CONTEXT;

#define CDP_SEND_REQUEST_POOL_DEPTH   5

//
// Local Data
//
PCN_RESOURCE_POOL  CdpSendRequestPool = NULL;
PCN_RESOURCE_POOL  CdpMcastSendRequestPool = NULL;


//
// Routines
//
NTSTATUS
CdpInitializeSend(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CDP] Initializing send...\n"));
    }

    CdpSendRequestPool = CnpCreateSendRequestPool(
                             CNP_VERSION_UNICAST,
                             PROTOCOL_CDP,
                             sizeof(CDP_HEADER),
                             0, // sizeof(CDP_SEND_CONTEXT),
                             CDP_SEND_REQUEST_POOL_DEPTH
                             );

    if (CdpSendRequestPool == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    CdpMcastSendRequestPool = CnpCreateSendRequestPool(
                                  CNP_VERSION_MULTICAST,
                                  PROTOCOL_CDP,
                                  sizeof(CDP_HEADER),
                                  0, // sizeof(CDP_SEND_CONTEXT)
                                  CDP_SEND_REQUEST_POOL_DEPTH
                                  );

    if (CdpMcastSendRequestPool == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CDP] Send initialized.\n"));
    }

    return(STATUS_SUCCESS);

}  // CdpInitializeSend


VOID
CdpCleanupSend(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CDP] Cleaning up send...\n"));
    }

    if (CdpSendRequestPool != NULL) {
        CnpDeleteSendRequestPool(CdpSendRequestPool);
    }

    if (CdpMcastSendRequestPool != NULL) {
        CnpDeleteSendRequestPool(CdpMcastSendRequestPool);
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CDP] Send cleanup complete.\n"));
    }

    return;

}  // CdpCleanupSend


VOID
CdpCompleteSendDatagram(
    IN     NTSTATUS           Status,
    IN OUT PULONG             BytesSent,
    IN     PCNP_SEND_REQUEST  SendRequest,
    IN     PMDL               DataMdl
    )
{
    PCDP_SEND_CONTEXT  sendContext = SendRequest->UpperProtocolContext;
    PCNP_HEADER        cnpHeader = SendRequest->CnpHeader;
    PCDP_HEADER        cdpHeader = SendRequest->UpperProtocolHeader;


    if (NT_SUCCESS(Status)) {
        if (*BytesSent >= sizeof(CDP_HEADER)) {
            *BytesSent -= sizeof(CDP_HEADER);
        }
        else {
            *BytesSent = 0;
            CnAssert(FALSE);
        }

        CnTrace(CDP_SEND_DETAIL, CdpTraceSendComplete,
            "[CDP] Send of dgram to node %u port %u complete, bytes sent %u.",
            cnpHeader->DestinationAddress, // LOGULONG
            cdpHeader->DestinationPort, // LOGUSHORT
            *BytesSent // LOGULONG
            );        
    }
    else {
        CnTrace(CDP_SEND_ERROR, CdpTraceSendFailedBelow,
            "[CDP] Transport failed to send dgram to node %u port %u, "
            "data len %u, status %!status!",
            cnpHeader->DestinationAddress, // LOGULONG
            cdpHeader->DestinationPort, // LOGUSHORT
            cdpHeader->PayloadLength, // LOGUSHORT
            Status // LOGSTATUS
            );

        CnAssert(*BytesSent == 0);
    }

    CnAssert(sendContext == NULL);

    if (cnpHeader->DestinationAddress == ClusterAnyNodeId) {
        //
        // Dereference the network multicast group data structure.
        //
        if (SendRequest->McastGroup != NULL) {
            CnpDereferenceMulticastGroup(SendRequest->McastGroup);
            SendRequest->McastGroup = NULL;
        }
    }

    CnFreeResource((PCN_RESOURCE) SendRequest);

    return;

}  // CdpCompleteSendDatagram


NTSTATUS
CxSendDatagram(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    )
{
    NTSTATUS                    status = STATUS_NOT_IMPLEMENTED;
    PCX_ADDROBJ                 addrObj;
    PTDI_REQUEST_KERNEL_SENDDG  request;
    ULONG                       bytesSent = 0;
    CN_IRQL                     cancelIrql;
    USHORT                      destPort = 0;
    CL_NODE_ID                  destNode = ClusterInvalidNodeId;


    addrObj = (PCX_ADDROBJ) IrpSp->FileObject->FsContext;
    request = (PTDI_REQUEST_KERNEL_SENDDG) &(IrpSp->Parameters);

    if (request->SendLength <= CDP_MAX_SEND_SIZE(CX_SIGNATURE_LENGTH)) {
        if ( request->SendDatagramInformation->RemoteAddressLength >=
             sizeof(TA_CLUSTER_ADDRESS)
           )
        {
            status = CxParseTransportAddress(
                         request->SendDatagramInformation->RemoteAddress,
                         request->SendDatagramInformation->RemoteAddressLength,
                         &destNode,
                         &destPort
                         );

            if (status == STATUS_SUCCESS) {
                if (destPort != 0) {
                    PCNP_SEND_REQUEST   sendRequest;

                    if (destNode == ClusterAnyNodeId) {

                        //
                        // This is a CNP multicast.
                        //
                        sendRequest = 
                            (PCNP_SEND_REQUEST) CnAllocateResource(
                                                    CdpMcastSendRequestPool
                                                    );
                    } else {

                        //
                        // This is a normal unicast.
                        //
                        sendRequest = 
                            (PCNP_SEND_REQUEST) CnAllocateResource(
                                                    CdpSendRequestPool
                                                    );
                    }

                    if (sendRequest != NULL) {
                        PCDP_HEADER             cdpHeader;
                        PCDP_SEND_CONTEXT       sendContext;
                        BOOLEAN                 checkState;
                        CL_NETWORK_ID           destNet = ClusterAnyNetworkId;

                        checkState = (addrObj->Flags &
                                      CX_AO_FLAG_CHECKSTATE) ?
                                      TRUE : FALSE;
                        
                        //
                        // Fill in the CDP header.
                        //
                        cdpHeader = sendRequest->UpperProtocolHeader;
                        RtlZeroMemory(cdpHeader, sizeof(CDP_HEADER));
                        cdpHeader->SourcePort = addrObj->LocalPort;
                        cdpHeader->DestinationPort = destPort;
                        cdpHeader->PayloadLength = (USHORT)request->SendLength;

                        //
                        // Fill in the caller portion of the CNP
                        // send request.
                        //
                        sendRequest->UpperProtocolIrp = Irp;
                        sendRequest->CompletionRoutine =
                            CdpCompleteSendDatagram;

                        //
                        // Fill in our own send context
                        // (currently nothing).
                        //
                        sendContext = sendRequest->UpperProtocolContext;
                        CnAssert(sendContext == NULL);

                        CnVerifyCpuLockMask(
                            0,                           // Required
                            CNP_LOCK_RANGE,              // Forbidden
                            CNP_PRECEEDING_LOCK_RANGE    // Maximum
                            );

                        //
                        // Send the message.
                        //

                        CnTrace(CDP_SEND_DETAIL, CdpTraceSend,
                            "[CDP] Sending dgram to node %u port %u, "
                            "data len %u.",
                            destNode, // LOGULONG
                            destPort, // LOGUSHORT
                            request->SendLength // LOGULONG
                            );

                        status = CnpSendPacket(
                                     sendRequest,
                                     destNode,
                                     Irp->MdlAddress,
                                     (USHORT) request->SendLength,
                                     checkState,
                                     destNet
                                     );

                        CnVerifyCpuLockMask(
                            0,                           // Required
                            CNP_LOCK_RANGE,              // Forbidden
                            CNP_PRECEEDING_LOCK_RANGE    // Maximum
                            );

                        return(status);
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                else {
                    status = STATUS_INVALID_ADDRESS_COMPONENT;
                }
            }
        }
        else {
            status = STATUS_INVALID_ADDRESS_COMPONENT;
        }
    }
    else {
        status = STATUS_INVALID_BUFFER_SIZE;
    }
    
    CnTrace(CDP_SEND_ERROR, CdpTraceSendFailedInternal,
        "[CDP] Failed to send dgram to node %u port %u, data len %u, "
        "status %!status!",
        destNode, // LOGULONG
        destPort, // LOGUSHORT
        request->SendLength, // LOGULONG
        status // LOGSTATUS
        );
    
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    return(status);

}  // CxSendDatagram
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\ccmp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ccmp.c

Abstract:

    Cluster Control Message Protocol code.

Author:

    Mike Massa (mikemas)           January 24, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-24-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ccmp.tmh"

#include <sspi.h>

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CcmpLoad)
#pragma alloc_text(PAGE, CcmpUnload)

#endif // ALLOC_PRAGMA

//
// Local Data
//
PCN_RESOURCE_POOL  CcmpSendRequestPool = NULL;
PCN_RESOURCE_POOL  CcmpMcastHBSendRequestPool = NULL;
PCN_RESOURCE_POOL  CcmpReceiveRequestPool = NULL;


#define CCMP_SEND_REQUEST_POOL_DEPTH      5
#define CCMP_RECEIVE_REQUEST_POOL_DEPTH   2

typedef enum {
    CcmpInvalidMsgCode = 0
} CCMP_MSG_CODE;

//
// Packet header structures must be packed.
//
#include <packon.h>

typedef struct {
    ULONG     SeqNumber;
    ULONG     AckNumber;
} CCMP_HEARTBEAT_MSG, *PCCMP_HEARTBEAT_MSG;

typedef struct {
    ULONG     SeqNumber;
} CCMP_POISON_MSG, *PCCMP_POISON_MSG;

typedef struct {
    ULONG             Epoch;
    CX_CLUSTERSCREEN  McastTargetNodes;
} CCMP_MCAST_HEARTBEAT_HEADER, *PCCMP_MCAST_HEARTBEAT_MSG;

typedef struct {
    UCHAR     Type;
    UCHAR     Code;

    union {
        USHORT Checksum;
        USHORT NodeCount;          // multicast heartbeats
    };

    union {
        CCMP_HEARTBEAT_MSG          Heartbeat;
        CCMP_POISON_MSG             Poison;
        CCMP_MCAST_HEARTBEAT_HEADER McastHeartbeat;
    } Message;

} CCMP_HEADER, *PCCMP_HEADER;

#include <packoff.h>


typedef struct {
    PCX_SEND_COMPLETE_ROUTINE     CompletionRoutine;
    PVOID                         CompletionContext;
    PVOID                         MessageData;
} CCMP_SEND_CONTEXT, *PCCMP_SEND_CONTEXT;

typedef struct {
    PCNP_NETWORK  Network;
    CL_NODE_ID    SourceNodeId;
    ULONG         TsduSize;
    ULONG         CnpReceiveFlags;
} CCMP_RECEIVE_CONTEXT, *PCCMP_RECEIVE_CONTEXT;

//
// Size of pre-allocated buffers for CCMP multicast heartbeats.
//
#define CCMP_MCAST_HEARTBEAT_PAYLOAD_PREALLOC(_NodeCount) \
    ((_NodeCount) * sizeof(CX_HB_NODE_INFO))
     
#define CCMP_MCAST_HEARTBEAT_PREALLOC(_NodeCount)         \
    (sizeof(CCMP_HEADER)                                  \
     + CCMP_MCAST_HEARTBEAT_PAYLOAD_PREALLOC(_NodeCount)  \
     )


//
// Security contexts.
//
// The heartbeat and poison packets are signed to detect tampering or
// spoofing.  The context is first established in user mode, then passed to
// clusnet and imported into the kernel security package.
//
// A node maintains an inbound and outbound based context with each node in
// the cluster. Hence, an array, indexed by Node Id, holds the data used to
// represent a context between this node and the specified node.
//
// The use of multiple, simultaneous security packages is supported on NT5. As
// of right now, the signature size can't be determined until the context has
// been generated. It's possible for the signature buffer size for the initial
// context to be smaller than the buffer size for subsequent
// contexts. RichardW is going to provide the ability to determine the
// signature size for a given package without having to generate a context.
//
// There are two scenarios where changing signature buffer size has an effect:
// 1) a mixed mode (SP4/NT5), 2 node cluster is using NTLM with a signature
// buffer size of 16 bytes. The SP4 node is upgraded to NT5. When the two
// nodes join, they will use kerberos which has a larger signature buffer size
// than NTLM but the 1st node has already allocated 16 b. signature
// buffers. This could be fixed by noting the change in buffer size and
// reallocating the lookaside list for the new size. This doesn't solve the
// problem with more than 2 nodes: 2) with > 2 node, mixed mode clusters, it's
// possible to have some nodes using NTLM and others using kerberos. If the
// max signature buffer can be determined before any contexts are generated
// then we'll allocated the largest buffer needed. If not, either multiple
// sets of signature buffers have to be maintained or the old, smaller buffer
// list is deallocated while a new, larger list is generated (in a
// synchronized fashion of course).
//

typedef struct _CLUSNET_SECURITY_DATA {
    CtxtHandle  Inbound;
    CtxtHandle  Outbound;
    ULONG       SignatureBufferSize;
} CLUSNET_SECURITY_DATA, * PCLUSNET_SECURITY_DATA;

//
// this array of structs holds the in/outbound contexts and the signature
// buffer size needed for communicating with the node indexed at this
// location. The index is based on internal (zero based) numbering.
//
CLUSNET_SECURITY_DATA SecurityContexts[ ClusterMinNodeId + ClusterDefaultMaxNodes ];

//
// the size of the signature buffers in the sig buffer lookaside list
//
ULONG AllocatedSignatureBufferSize = 0;

//
// the largest size of the signature buffers imported
//
ULONG MaxSignatureSize = 0;

CN_LOCK SecCtxtLock;

#define VALID_SSPI_HANDLE( _x )     ((_x).dwUpper != (ULONG_PTR)-1 && \
                                     (_x).dwLower != (ULONG_PTR)-1 )

#define INVALIDATE_SSPI_HANDLE( _x ) { \
        (_x).dwUpper = (ULONG_PTR)-1; \
        (_x).dwLower = (ULONG_PTR)-1; \
    }

//
// Lookaside list of signature data and its MDL
//

typedef struct _SIGNATURE_DATA {
    SINGLE_LIST_ENTRY Next;
    CN_SIGNATURE_FIELD
    PMDL SigMDL;
    UCHAR PacketSignature[0];
} SIGNATURE_DATA, *PSIGNATURE_DATA;

PNPAGED_LOOKASIDE_LIST SignatureLL;
#define CN_SIGNATURE_TAG    CN_POOL_TAG

//
// Routines exported within the Cluster Transport.
//
NTSTATUS
CcmpLoad(
    VOID
    )
{
    NTSTATUS   status;
    ULONG      i;

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CCMP] Loading...\n"));
    }

    CcmpSendRequestPool = CnpCreateSendRequestPool(
                              CNP_VERSION_UNICAST,
                              PROTOCOL_CCMP,
                              sizeof(CCMP_HEADER),
                              sizeof(CCMP_SEND_CONTEXT),
                              CCMP_SEND_REQUEST_POOL_DEPTH
                              );

    if (CcmpSendRequestPool == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    CcmpReceiveRequestPool = CnpCreateReceiveRequestPool(
                                 sizeof(CCMP_RECEIVE_CONTEXT),
                                 CCMP_RECEIVE_REQUEST_POOL_DEPTH
                                 );

    if (CcmpSendRequestPool == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    CcmpMcastHBSendRequestPool = 
        CnpCreateSendRequestPool(
            CNP_VERSION_MULTICAST,
            PROTOCOL_CCMP,
            (USHORT)CCMP_MCAST_HEARTBEAT_PREALLOC(ClusterDefaultMaxNodes),
            (USHORT)sizeof(CCMP_SEND_CONTEXT),
            CCMP_SEND_REQUEST_POOL_DEPTH
            );
    if (CcmpMcastHBSendRequestPool == NULL) {
        IF_CNDBG( CN_DEBUG_INIT )
            CNPRINT(("[CCMP]: no memory for mcast heartbeat "
                     "send request pool\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // initialize the individual client and server side security contexts
    //

    for ( i = ClusterMinNodeId; i <= ClusterDefaultMaxNodes; ++i ) {
        INVALIDATE_SSPI_HANDLE( SecurityContexts[ i ].Outbound );
        INVALIDATE_SSPI_HANDLE( SecurityContexts[ i ].Inbound );
        SecurityContexts[ i ].SignatureBufferSize = 0;
    }

    CnInitializeLock( &SecCtxtLock, CNP_SEC_CTXT_LOCK );

    SignatureLL = NULL;

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CCMP] Loaded.\n"));
    }

    return(STATUS_SUCCESS);

} // CcmpLoad


VOID
CcmpUnload(
    VOID
    )
{
    ULONG i;

    PAGED_CODE();


    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CCMP] Unloading...\n"));
    }

    if (CcmpSendRequestPool != NULL) {
        CnpDeleteSendRequestPool(CcmpSendRequestPool);
        CcmpSendRequestPool = NULL;
    }

    if (CcmpMcastHBSendRequestPool != NULL) {
        CnpDeleteSendRequestPool(CcmpMcastHBSendRequestPool);
        CcmpMcastHBSendRequestPool = NULL;
    }

    if (CcmpReceiveRequestPool != NULL) {
        CnpDeleteReceiveRequestPool(CcmpReceiveRequestPool);
        CcmpReceiveRequestPool = NULL;
    }

    //
    // free Signature buffers and delete security contexts
    //

    if ( SignatureLL != NULL ) {

        ExDeleteNPagedLookasideList( SignatureLL );
        CnFreePool( SignatureLL );
        SignatureLL = NULL;
        AllocatedSignatureBufferSize = 0;
    }

    for ( i = ClusterMinNodeId; i <= ClusterDefaultMaxNodes; ++i ) {

        CxDeleteSecurityContext( i );
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CCMP] Unload complete.\n"));
    }

    return;

}  // CcmpUnload

#ifdef MM_IN_CLUSNET
VOID
CcmpCompleteSendMembershipMsg(
    IN NTSTATUS           Status,
    IN ULONG              BytesSent,
    IN PCNP_SEND_REQUEST  SendRequest,
    IN PMDL               DataMdl,
    IN PIRP               Irp
    )
{
    PCCMP_SEND_CONTEXT  sendContext = SendRequest->UpperProtocolContext;

    CnAssert(DataMdl != NULL);

    if (NT_SUCCESS(Status)) {
        if (BytesSent >= sizeof(CCMP_HEADER)) {
            BytesSent -= sizeof(CCMP_HEADER);
        }
        else {
            BytesSent = 0;
            CnAssert(FALSE);
        }
        
        //
        // Update the Information field of the completed IRP to
        // reflect the actual bytes sent (adjusted for the CCMP
        // header).
        //
        Irp->IoStatus.Information = BytesSent;
    }
    else {
        CnAssert(BytesSent == 0);
    }

    //
    // Call the completion routine.
    //
    (*(sendContext->CompletionRoutine))(
        Status,
        BytesSent,
        sendContext->CompletionContext,
        sendContext->MessageData
        );

    //
    // Free the stuff we allocated.
    //
    IoFreeMdl(DataMdl);

    CnFreeResource((PCN_RESOURCE) SendRequest);

    return;

}  // CcmpCompleteSendMembershipMsg


NTSTATUS
CxSendMembershipMessage(
    IN CL_NODE_ID                  DestinationNodeId,
    IN PVOID                       MessageData,
    IN USHORT                      MessageDataLength,
    IN PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,
    IN PVOID                       CompletionContext   OPTIONAL
    )
{
    NTSTATUS            status;
    PCNP_SEND_REQUEST   sendRequest;
    PCCMP_HEADER        ccmpHeader;
    PMDL                dataMdl;
    PCCMP_SEND_CONTEXT  sendContext;


    CnAssert(MessageData != NULL);
    CnAssert(MessageDataLength > 0);

    dataMdl = IoAllocateMdl(
                  MessageData,
                  MessageDataLength,
                  FALSE,
                  FALSE,
                  NULL
                  );

    if (dataMdl != NULL) {
        MmBuildMdlForNonPagedPool(dataMdl);

        sendRequest = (PCNP_SEND_REQUEST) CnAllocateResource(
                                              CcmpSendRequestPool
                                              );

        if (sendRequest != NULL) {

            //
            // Fill in the CCMP header.
            //
            ccmpHeader = sendRequest->UpperProtocolHeader;
            RtlZeroMemory(ccmpHeader, sizeof(CCMP_HEADER));
            ccmpHeader->Type = CcmpMembershipMsgType;

            //
            // Fill in the caller portion of the CNP send request.
            //
            sendRequest->UpperProtocolIrp = NULL;
            sendRequest->CompletionRoutine = CcmpCompleteSendMembershipMsg;

            //
            // Fill in our own send context.
            //
            sendContext = sendRequest->UpperProtocolContext;
            sendContext->CompletionRoutine = CompletionRoutine;
            sendContext->CompletionContext = CompletionContext;
            sendContext->MessageData = MessageData;

            //
            // Send the message.
            //
            status = CnpSendPacket(
                         sendRequest,
                         DestinationNodeId,
                         dataMdl,
                         MessageDataLength,
                         FALSE,
                         ClusterAnyNetworkId
                         );

            return(status);
        }

        IoFreeMdl(dataMdl);
    }

    status = STATUS_INSUFFICIENT_RESOURCES;

    return(status);

}  // CxSendMembershipMessage
#endif // MM_IN_CLUSNET
 
VOID
CcmpCompleteSendHeartbeatMsg(
    IN     NTSTATUS           Status,
    IN OUT PULONG             BytesSent,
    IN     PCNP_SEND_REQUEST  SendRequest,
    IN     PMDL               DataMdl
    )
{
    PCCMP_HEADER        ccmpHeader = SendRequest->UpperProtocolHeader;
    PCNP_HEADER         cnpHeader = SendRequest->CnpHeader;
    PSIGNATURE_DATA     SigData;

    
    if (NT_SUCCESS(Status)) {
        MEMLOG(MemLogHBPacketSendComplete,
               CcmpHeartbeatMsgType,
               ccmpHeader->Message.Heartbeat.SeqNumber);
        
        CnTrace(CCMP_SEND_DETAIL, CcmpTraceSendHBComplete,
            "[CCMP] Send of heartbeat to node %u completed, seqno %u.",
            cnpHeader->DestinationAddress, // LOGULONG
            ccmpHeader->Message.Heartbeat.SeqNumber // LOGULONG
            );
    
        //
        // Strip the CCMP header off of the byte count
        //
        if (*BytesSent >= sizeof(CCMP_HEADER)) {
            *BytesSent -= sizeof(CCMP_HEADER);
        }
        else {
            *BytesSent = 0;
            CnAssert(FALSE);
        }
    }
    else {
        MEMLOG(MemLogPacketSendFailed,
               cnpHeader->DestinationAddress,
               Status);
        
        CnTrace(CCMP_SEND_ERROR, CcmpTraceSendHBFailedBelow,
            "[CCMP] Transport failed to send heartbeat to node %u, "
            "seqno %u, status %!status!.",
            cnpHeader->DestinationAddress, // LOGULONG
            ccmpHeader->Message.Heartbeat.SeqNumber, // LOGULONG
            Status // LOGSTATUS
            );

        CnAssert(*BytesSent == 0);
    }

    //
    // Strip the sig data off of the byte count and free it
    //
    CnAssert(DataMdl != NULL);

    SigData = CONTAINING_RECORD(
                  DataMdl->MappedSystemVa,
                  SIGNATURE_DATA,
                  PacketSignature
                  );

    if (NT_SUCCESS(Status)) {
        if (*BytesSent >= SigData->SigMDL->ByteCount) {
            *BytesSent -= SigData->SigMDL->ByteCount;
        } else {
            *BytesSent = 0;
            CnAssert(FALSE);
        }
    }

    // XXX: restore the original buffer size
    SigData->SigMDL->ByteCount = AllocatedSignatureBufferSize;

    ExFreeToNPagedLookasideList( SignatureLL, SigData );

    //
    // At this point BytesSent should be zero.
    //
    CnAssert(*BytesSent == 0);

    //
    // Free the send request.
    //
    CnFreeResource((PCN_RESOURCE) SendRequest);

    return;

}  // CcmpCompleteSendHeartbeatMsg


NTSTATUS
CxSendHeartBeatMessage(
    IN CL_NODE_ID                  DestinationNodeId,
    IN ULONG                       SeqNumber,
    IN ULONG                       AckNumber,
    IN CL_NETWORK_ID               NetworkId
    )
{
    NTSTATUS            status;
    PCNP_SEND_REQUEST   sendRequest;
    PCCMP_HEADER        ccmpHeader;
    SecBufferDesc       SignatureDescriptor;
    SecBuffer           SignatureSecBuffer[2];
    PSIGNATURE_DATA     SigData;
    CN_IRQL             SecContextIrql;
    PCLUSNET_SECURITY_DATA contextData = &SecurityContexts[ DestinationNodeId ];

    
    sendRequest = (PCNP_SEND_REQUEST) CnAllocateResource( CcmpSendRequestPool );

    if (sendRequest != NULL) {

        //
        // Fill in the CCMP header.
        //
        ccmpHeader = sendRequest->UpperProtocolHeader;
        RtlZeroMemory(ccmpHeader, sizeof(CCMP_HEADER));
        ccmpHeader->Type = CcmpHeartbeatMsgType;
        ccmpHeader->Message.Heartbeat.SeqNumber = SeqNumber;
        ccmpHeader->Message.Heartbeat.AckNumber = AckNumber;

        //
        // allocate a buffer and generate a signature. SignatureLL
        // will be NULL if security contexts have not yet been
        // imported.
        //

        if (SignatureLL != NULL) {
        
            SigData = ExAllocateFromNPagedLookasideList( SignatureLL );

            if (SigData != NULL) {

                //
                // acquire the lock on the security contexts and see if
                // we have a valid one with which to send this packet
                //

                CnAcquireLock( &SecCtxtLock, &SecContextIrql );

                if ( VALID_SSPI_HANDLE( contextData->Outbound )) {

                    //
                    // build a descriptor for the message and signature
                    //

                    SignatureDescriptor.cBuffers = 2;
                    SignatureDescriptor.pBuffers = SignatureSecBuffer;
                    SignatureDescriptor.ulVersion = SECBUFFER_VERSION;

                    SignatureSecBuffer[0].BufferType = SECBUFFER_DATA;
                    SignatureSecBuffer[0].cbBuffer = sizeof(CCMP_HEADER);
                    SignatureSecBuffer[0].pvBuffer = (PVOID)ccmpHeader;

                    SignatureSecBuffer[1].BufferType = SECBUFFER_TOKEN;
                    SignatureSecBuffer[1].cbBuffer = 
                        contextData->SignatureBufferSize;
                    SignatureSecBuffer[1].pvBuffer = 
                        SigData->PacketSignature;

                    status = MakeSignature(&contextData->Outbound,
                                           0,
                                           &SignatureDescriptor,
                                           0);
                    CnAssert( status == STATUS_SUCCESS );

                    CnReleaseLock( &SecCtxtLock, SecContextIrql );

                    if ( status == STATUS_SUCCESS ) {

                        //
                        // Fill in the caller portion of the CNP send request.
                        //
                        sendRequest->UpperProtocolIrp = NULL;
                        sendRequest->CompletionRoutine = 
                            CcmpCompleteSendHeartbeatMsg;

                        //
                        // Send the message.
                        //

                        MEMLOG( 
                            MemLogHBPacketSend, 
                            CcmpHeartbeatMsgType, 
                            SeqNumber
                            );

                        CnTrace(CCMP_SEND_DETAIL, CcmpTraceSendHB,
                            "[CCMP] Sending heartbeat to node %u "
                            "on network %u, seqno %u, ackno %u.",
                            DestinationNodeId, // LOGULONG
                            NetworkId, // LOGULONG
                            SeqNumber, // LOGULONG
                            AckNumber // LOGULONG
                            );

                        //
                        // XXX: adjust the MDL to reflect the true
                        // number of bytes in the signature buffer. This
                        // will go away when the max sig buffer size can
                        // be determined in user mode
                        //
                        SigData->SigMDL->ByteCount = 
                            contextData->SignatureBufferSize;

                        status = CnpSendPacket(
                                     sendRequest,
                                     DestinationNodeId,
                                     SigData->SigMDL,
                                     (USHORT)contextData->SignatureBufferSize,
                                     FALSE,
                                     NetworkId);

                        //
                        // CnpSendPacket is responsible for ensuring 
                        // that CcmpCompleteSendHeartbeatMsg is called (it 
                        // is stored in the send request data structure).
                        //
                    }
                } else {

                    CnReleaseLock( &SecCtxtLock, SecContextIrql );
                    ExFreeToNPagedLookasideList( SignatureLL, SigData );
                    CnFreeResource((PCN_RESOURCE) sendRequest);

                    status = STATUS_CLUSTER_NO_SECURITY_CONTEXT;
                }
            } else {

                CnFreeResource((PCN_RESOURCE) sendRequest);
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        
        } else {

            CnFreeResource((PCN_RESOURCE) sendRequest);
            status = STATUS_CLUSTER_NO_SECURITY_CONTEXT;
        }

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(status)) {
        CnTrace(CCMP_SEND_ERROR, CcmpTraceSendHBFailedInternal,
            "[CCMP] Failed to send heartbeat to node %u on net %u, "
            "seqno %u, status %!status!.",
            DestinationNodeId, // LOGULONG
            NetworkId, // LOGULONG
            SeqNumber, // LOGULONG
            status // LOGSTATUS
            );
    }

    return(status);

}  // CxSendHeartbeatMessage


VOID
CcmpCompleteSendMcastHeartbeatMsg(
    IN     NTSTATUS           Status,
    IN OUT PULONG             BytesSent,
    IN     PCNP_SEND_REQUEST  SendRequest,
    IN     PMDL               DataMdl
    )
{
    PCCMP_HEADER        ccmpHeader = SendRequest->UpperProtocolHeader;
    PCNP_HEADER         cnpHeader = SendRequest->CnpHeader;
    PCCMP_SEND_CONTEXT  sendContext = SendRequest->UpperProtocolContext;

    
    if (NT_SUCCESS(Status)) {

        MEMLOG(MemLogHBPacketSendComplete,
               CcmpMcastHeartbeatMsgType,
               0xFFFFFFFF);
        
        CnTrace(
            CCMP_SEND_DETAIL, CcmpTraceSendMcastHBComplete,
            "[CCMP] Send of multicast heartbeat "
            "on network id %u completed.",
            SendRequest->Network->Id // LOGULONG
            );
    
        //
        // Strip the CCMP header and multicast heartbeat payload 
        // off of the byte count. The size of the message sent was
        // saved in the send request data structure.
        //
        if (*BytesSent >= SendRequest->UpperProtocolHeaderLength) {
            *BytesSent -= SendRequest->UpperProtocolHeaderLength;
        }
        else {
            *BytesSent = 0;
            CnAssert(FALSE);
        }
    }
    else {
        MEMLOG(MemLogPacketSendFailed,
               cnpHeader->DestinationAddress,
               Status);
        
        CnTrace(
            CCMP_SEND_ERROR, CcmpTraceSendHBFailedBelow,
            "[CCMP] Transport failed to send multicast "
            "heartbeat on network id %u, status %!status!.",
            SendRequest->Network->Id, // LOGULONG
            Status // LOGSTATUS
            );

        CnAssert(*BytesSent == 0);
    }

    //
    // At this point BytesSent should be zero.
    //
    CnAssert(*BytesSent == 0);

    //
    // Call the completion routine if one was specified
    //
    if (sendContext->CompletionRoutine) {
        (*(sendContext->CompletionRoutine))(
            Status,
            *BytesSent,
            sendContext->CompletionContext,
            NULL
            );
    }

    //
    // Free the send request.
    //
    CnFreeResource((PCN_RESOURCE) SendRequest);

    return;

}  // CcmpCompleteSendHeartbeatMsg


NTSTATUS
CxSendMcastHeartBeatMessage(
    IN     CL_NETWORK_ID               NetworkId,
    IN     PVOID                       McastGroup,
    IN     CX_CLUSTERSCREEN            McastTargetNodes,
    IN     ULONG                       McastEpoch,
    IN     CX_HB_NODE_INFO             NodeInfo[],
    IN     PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,  OPTIONAL
    IN     PVOID                       CompletionContext   OPTIONAL
    )
/*++

Routine Description:

    Send a multicast heartbeat message. The mcast heartbeat is
    structured as follows:
    
        CCMP_HEADER
        
        CNP_MCAST_SIGNATURE (including signature buffer)
        
        CCMP_MCAST_HEARTBEAT_MESSAGE
        
Arguments:

    NetworkId - network to send mcast heartbeat

    McastGroup - contains data for the multicast group to
        which the message is to be sent
    
    McastTargetNodes - screen that indicates whether the 
        (internal) node id is a target of this multicast heartbeat.

    McastEpoch - cluster multicast epoch number
    
    NodeInfo - vector, of size ClusterDefaultMaxNodes+ClusterMinNodeId, 
        of node info data structures indexed by dest node id
    
    CompletionRoutine - called in this routine if the request is
        not passed down to a lower level (in which case it will be
        called by this routine's completion routine)
        
    CompletionContext - context for CompletionRoutine
    
Return value:

    NTSTATUS
    
--*/
{
    NTSTATUS                        status = STATUS_HOST_UNREACHABLE;
    PCNP_SEND_REQUEST               sendRequest;
    PCCMP_HEADER                    ccmpHeader;
    PCCMP_SEND_CONTEXT              sendContext;
    CX_HB_NODE_INFO UNALIGNED     * payload;
    PVOID                           signHeaders[2];
    ULONG                           signHeaderLengths[2];
    ULONG                           sigLen;
    PCNP_MULTICAST_GROUP            mcastGroup;
    BOOLEAN                         pushedPacket = FALSE;


    mcastGroup = (PCNP_MULTICAST_GROUP) McastGroup;
    CnAssert(mcastGroup != NULL);

    sendRequest = (PCNP_SEND_REQUEST) CnAllocateResource( 
                                          CcmpMcastHBSendRequestPool
                                          );

    if (sendRequest != NULL) {

        //
        // Fill in the caller portion of the CNP send request.
        //
        sendRequest->UpperProtocolIrp = NULL;
        sendRequest->CompletionRoutine = CcmpCompleteSendMcastHeartbeatMsg;
        sendRequest->McastGroup = mcastGroup;

        //
        // Fill in our own send context.
        //
        sendContext = sendRequest->UpperProtocolContext;
        sendContext->CompletionRoutine = CompletionRoutine;
        sendContext->CompletionContext = CompletionContext;

        //
        // Fill in the CCMP header. 
        //
        ccmpHeader = sendRequest->UpperProtocolHeader;
        RtlZeroMemory(ccmpHeader, sizeof(CCMP_HEADER));
        ccmpHeader->Type = CcmpMcastHeartbeatMsgType;
        ccmpHeader->NodeCount= (USHORT) ClusterDefaultMaxNodes;
        ccmpHeader->Message.McastHeartbeat.Epoch = McastEpoch;
        ccmpHeader->Message.McastHeartbeat.McastTargetNodes = McastTargetNodes;

        //
        // Fill in the heartbeat data.
        //
        payload = (CX_HB_NODE_INFO UNALIGNED *)(ccmpHeader + 1);
        RtlCopyMemory(
            payload,
            &(NodeInfo[ClusterMinNodeId]),
            sizeof(*NodeInfo) * ClusterDefaultMaxNodes
            );

        //
        // Send the message.
        //

        MEMLOG( 
            MemLogHBPacketSend, 
            CcmpMcastHeartbeatMsgType, 
            0xFFFFFFFF
            );

        CnTrace(
            CCMP_SEND_DETAIL, CcmpTraceSendMcastHB,
            "[CCMP] Sending multicast heartbeat on network %u, "
            "node count %u, target mask %04X",
            NetworkId, // LOGULONG
            ClusterDefaultMaxNodes,  // LOGUSHORT
            McastTargetNodes.UlongScreen
            );

        status = CnpSendPacket(
                     sendRequest,
                     ClusterAnyNodeId,
                     NULL,
                     0,
                     FALSE,
                     NetworkId
                     );

        //
        // CnpSendPacket is responsible for ensuring 
        // that CcmpCompleteSendMcastHeartbeatMsg is called
        // (it is stored in the send request data structure).
        //

        pushedPacket = TRUE;


    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(status)) {
        CnTrace(CCMP_SEND_ERROR, CcmpTraceSendMcastHBFailedInternal,
            "[CCMP] Failed to send multicast heartbeat on net %u, "
            "status %!status!, pushedPacket = %!bool!.",
            NetworkId, // LOGULONG
            status, // LOGSTATUS
            pushedPacket
            );
    }

    //
    // If the request wasn't submitted to the next lower layer and
    // a completion routine was provided, call the completion
    // routine.
    //
    if (!pushedPacket && CompletionRoutine) {
        (*CompletionRoutine)(
            status,
            0,
            CompletionContext,
            NULL
            );
    }

    return(status);

} // CxSendMcastHeartBeatMessage


VOID
CcmpCompleteSendPoisonPkt(
    IN     NTSTATUS           Status,
    IN OUT PULONG             BytesSent,
    IN     PCNP_SEND_REQUEST  SendRequest,
    IN     PMDL               DataMdl
    )
{
    PCCMP_SEND_CONTEXT  sendContext = SendRequest->UpperProtocolContext;
    PSIGNATURE_DATA     SigData;
    PCNP_HEADER         cnpHeader = (PCNP_HEADER) SendRequest->CnpHeader;


    MEMLOG(MemLogHBPacketSendComplete,
           CcmpPoisonMsgType,
           ( sendContext->CompletionRoutine == NULL ));

    IF_CNDBG( CN_DEBUG_POISON | CN_DEBUG_CCMPSEND )
        CNPRINT(("[CCMP] Send of poison packet to node %u completed "
                 "with status %08x\n",
                 cnpHeader->DestinationAddress, Status));

    if (NT_SUCCESS(Status)) {
        
        CnTrace(CCMP_SEND_DETAIL, CcmpTraceSendPoisonComplete, 
            "[CCMP] Send of poison packet to node %u completed.",
            cnpHeader->DestinationAddress // LOGULONG
            );
    
        //
        // Strip the CCMP header off of the byte count
        //
        if (*BytesSent >= sizeof(CCMP_HEADER)) {
            *BytesSent -= sizeof(CCMP_HEADER);
        }
        else {
            *BytesSent = 0;
            CnAssert(FALSE);
        }

    } else {
        CnTrace(CCMP_SEND_ERROR, CcmpTraceSendPoisonFailedBelow, 
            "[CCMP] Transport failed to send poison packet to node %u, "
            "status %!status!.",
            cnpHeader->DestinationAddress, // LOGULONG
            Status // LOGSTATUS
            );
        
        CnAssert(*BytesSent == 0);
    }

    //
    // Strip the sig data off of the byte count and free it
    //
    CnAssert(DataMdl != NULL);

    SigData = CONTAINING_RECORD(
                  DataMdl->MappedSystemVa,
                  SIGNATURE_DATA,
                  PacketSignature
                  );

    if (NT_SUCCESS(Status)) {
        if (*BytesSent >= SigData->SigMDL->ByteCount) {
            *BytesSent -= SigData->SigMDL->ByteCount;
        } else {
            *BytesSent = 0;
            CnAssert(FALSE);
        }
    }

    // XXX: restore the original buffer size
    SigData->SigMDL->ByteCount = AllocatedSignatureBufferSize;

    ExFreeToNPagedLookasideList( SignatureLL, SigData );

    //
    // At this point BytesSent should be zero.
    //
    CnAssert(*BytesSent == 0);

    //
    // Call the completion routine if one was specified
    //
    if (sendContext->CompletionRoutine) {
        (*(sendContext->CompletionRoutine))(
            Status,
            *BytesSent,
            sendContext->CompletionContext,
            sendContext->MessageData
            );
    }

    //
    // Free the send request.
    //
    CnFreeResource((PCN_RESOURCE) SendRequest);

    return;

}  // CcmpCompleteSendPoisonPkt


VOID
CxSendPoisonPacket(
    IN CL_NODE_ID                  DestinationNodeId,
    IN PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,  OPTIONAL
    IN PVOID                       CompletionContext,  OPTIONAL
    IN PIRP                        Irp                 OPTIONAL
    )
{
    NTSTATUS     status;
    PCNP_NODE    node;


    node = CnpFindNode(DestinationNodeId);

    if (node == NULL) {
        if (CompletionRoutine) {
            (*CompletionRoutine)(
                STATUS_CLUSTER_NODE_NOT_FOUND,
                0,
                CompletionContext,
                NULL
                );
        }

        if (Irp) {
            Irp->IoStatus.Status = STATUS_CLUSTER_NODE_NOT_FOUND;
            Irp->IoStatus.Information = 0;
            
            IF_CNDBG( CN_DEBUG_POISON | CN_DEBUG_CCMPSEND )
                CNPRINT(("[CCMP] CxSendPoisonPacket completing IRP "
                         "%p with status %08x\n",
                         Irp, Irp->IoStatus.Status));

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
    }
    else {
        CcmpSendPoisonPacket(
            node,
            CompletionRoutine,
            CompletionContext,
            NULL,
            Irp
            );
    }

    return;

} // CxSendPoisonPacket


VOID
CcmpSendPoisonPacket(
    IN PCNP_NODE                   Node,
    IN PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,  OPTIONAL
    IN PVOID                       CompletionContext,  OPTIONAL
    IN PCNP_NETWORK                Network,            OPTIONAL
    IN PIRP                        Irp                 OPTIONAL
    )
/*++

Notes:

  Called with the node lock held. Returns with the node lock released.
  
  If this send request is not submitted to the next lower layer, 
  CompletionRoutine must be called (if it is not NULL).

--*/
{
    NTSTATUS                status;
    PCNP_SEND_REQUEST       sendRequest;
    PCCMP_HEADER            ccmpHeader;
    PCCMP_SEND_CONTEXT      sendContext;
    SecBufferDesc           SignatureDescriptor;
    SecBuffer               SignatureSecBuffer[2];
    PSIGNATURE_DATA         SigData;
    CN_IRQL                 SecContextIrql;
    SECURITY_STATUS         secStatus;
    PCNP_INTERFACE          interface;
    PCLUSNET_SECURITY_DATA  contextData = &SecurityContexts[Node->Id];
    CL_NETWORK_ID           networkId;
    CL_NODE_ID              nodeId = Node->Id;


    sendRequest = (PCNP_SEND_REQUEST) CnAllocateResource(CcmpSendRequestPool);

    if (sendRequest != NULL) {
        //
        // make sure we have an interface to send this on. We
        // could be shutting down and have dropped info out of
        // the database
        //
        if ( Network != NULL ) {
            PLIST_ENTRY  entry;

            //
            // we really want to send this packet over the indicated
            // network. walk the node's interface list matching the
            // supplied network id to the interface's network ID and
            // send the packet on that interface
            //

            for (entry = Node->InterfaceList.Flink;
                 entry != &(Node->InterfaceList);
                 entry = entry->Flink
                 )
                {
                    interface = CONTAINING_RECORD(entry,
                                                  CNP_INTERFACE,
                                                  NodeLinkage);

                    if ( interface->Network == Network ) {
                        break;
                    }
                }

            if ( entry == &Node->InterfaceList ) {
                interface = Node->CurrentInterface;
            }
        }
        else {
            interface = Node->CurrentInterface;
        }

        if ( interface != NULL ) {
            networkId = interface->Network->Id;

            //
            // Fill in the CCMP header.
            //
            ccmpHeader = sendRequest->UpperProtocolHeader;
            RtlZeroMemory(ccmpHeader, sizeof(CCMP_HEADER));
            ccmpHeader->Type = CcmpPoisonMsgType;
            ccmpHeader->Message.Poison.SeqNumber =
                ++(interface->SequenceToSend);

            CnReleaseLock( &Node->Lock, Node->Irql );

            //
            // Fill in the caller portion of the CNP send request.
            //
            sendRequest->UpperProtocolIrp = Irp;
            sendRequest->CompletionRoutine = CcmpCompleteSendPoisonPkt;

            //
            // Fill in our own send context.
            //
            sendContext = sendRequest->UpperProtocolContext;
            sendContext->CompletionRoutine = CompletionRoutine;
            sendContext->CompletionContext = CompletionContext;

            //
            // allocate a signature buffer and generate one. SignatureLL
            // will be NULL if security contexts have not yet been
            // imported.
            //

            if (SignatureLL != NULL) {

                SigData = ExAllocateFromNPagedLookasideList( SignatureLL );
                
                if (SigData != NULL) {

                    //
                    // acquire the lock on the security contexts and see if
                    // we have a valid one with which to send this packet
                    //

                    CnAcquireLock( &SecCtxtLock, &SecContextIrql );

                    if ( VALID_SSPI_HANDLE( contextData->Outbound )) {

                        //
                        // build a descriptor for the message and signature
                        //

                        SignatureDescriptor.cBuffers = 2;
                        SignatureDescriptor.pBuffers = SignatureSecBuffer;
                        SignatureDescriptor.ulVersion = SECBUFFER_VERSION;

                        SignatureSecBuffer[0].BufferType = SECBUFFER_DATA;
                        SignatureSecBuffer[0].cbBuffer = sizeof(CCMP_HEADER);
                        SignatureSecBuffer[0].pvBuffer = (PVOID)ccmpHeader;

                        SignatureSecBuffer[1].BufferType = SECBUFFER_TOKEN;
                        SignatureSecBuffer[1].cbBuffer =
                            contextData->SignatureBufferSize;
                        SignatureSecBuffer[1].pvBuffer = 
                            SigData->PacketSignature;

                        secStatus = MakeSignature(
                                        &contextData->Outbound,
                                        0,
                                        &SignatureDescriptor,
                                        0);
                        CnAssert( secStatus == STATUS_SUCCESS );

                        CnReleaseLock( &SecCtxtLock, SecContextIrql );

                        //
                        // no completion routine means this routine was called
                        // from the heartbeat dpc. We'll use that to 
                        // distinguish between that and clussvc calling for a 
                        // poison packet to be sent.
                        //

                        //
                        // WMI tracing prints the thread id,
                        // can figure out DPC or not on our own
                        //
                        CnTrace(CCMP_SEND_DETAIL, CcmpTraceSendPoison,
                            "[CCMP] Sending poison packet to node %u "
                            "on net %u.",
                            nodeId, // LOGULONG
                            networkId // LOGULONG
                            );

                        MEMLOG(MemLogHBPacketSend,
                               CcmpPoisonMsgType,
                               ( CompletionRoutine == NULL ));

                        //
                        // Send the message.
                        //
                        //
                        // XXX: adjust the MDL to reflect the true number of
                        // bytes in the signature buffer. This will go away 
                        // when the max sig buffer size can be determined in
                        // user mode
                        //
                        SigData->SigMDL->ByteCount =
                            contextData->SignatureBufferSize;

                        CnpSendPacket(
                            sendRequest,
                            nodeId,
                            SigData->SigMDL,
                            (USHORT)contextData->SignatureBufferSize,
                            FALSE,
                            networkId
                            );

                        //
                        // CnpSendPacket is responsible for ensuring 
                        // that CcmpCompleteSendPoisonPkt is called.
                        // CcmpCompleteSendPoisonPkt calls CompletionRoutine,
                        // which was a parameter to this routine.
                        //
                        return;

                    } else {

                        CnReleaseLock( &SecCtxtLock, SecContextIrql );
                        ExFreeToNPagedLookasideList( SignatureLL, SigData );
                        CnFreeResource((PCN_RESOURCE) sendRequest);

                        status = STATUS_CLUSTER_NO_SECURITY_CONTEXT;
                    }
                
                } else {

                    CnFreeResource((PCN_RESOURCE) sendRequest);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {

                CnFreeResource((PCN_RESOURCE) sendRequest);
                status = STATUS_CLUSTER_NO_SECURITY_CONTEXT;
            }
        } else {
            CnReleaseLock( &Node->Lock, Node->Irql );
            CnFreeResource((PCN_RESOURCE) sendRequest);
            status = STATUS_CLUSTER_NETINTERFACE_NOT_FOUND;
        }
    } else {
        CnReleaseLock( &Node->Lock, Node->Irql );
        IF_CNDBG( CN_DEBUG_POISON )
            CNPRINT(("[CCMP] No send resources for SendPoisonPacket\n"));

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    CnTrace(CCMP_SEND_ERROR, CcmpTraceSendPoisonFailedInternal,
        "[CCMP] Failed to send poison packet to node %u, status %!status!.",
        nodeId, // LOGULONG
        status // LOGSTATUS
        );

    //
    // The request to send a poison packet did not make it to the
    // next lower layer. If a completion routine was provided, 
    // call it now.
    //
    if (CompletionRoutine) {

        (*CompletionRoutine)(
            status,
            0,
            CompletionContext,
            NULL
            );
    }

    //
    // If an upper protocol IRP was provided, complete it now.
    //
    if (Irp) {

        IF_CNDBG( CN_DEBUG_POISON | CN_DEBUG_CCMPSEND )
            CNPRINT(("[CCMP] CcmpSendPoisonPacket completing IRP "
                     "%p with status %08x\n",
                     Irp, status));
        
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return;

}  // CcmpSendPoisonPacket


VOID
CcmpProcessReceivePacket(
    IN  PCNP_NETWORK   Network,
    IN  CL_NODE_ID     SourceNodeId,
    IN  ULONG          CnpReceiveFlags,
    IN  ULONG          TsduSize,
    IN  PVOID          Tsdu
    )
{
    CCMP_HEADER UNALIGNED     * header = Tsdu;
    SECURITY_STATUS             SecStatus;
    CX_HB_NODE_INFO UNALIGNED * nodeInfo;


    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    CnAssert(TsduSize >= sizeof(CCMP_HEADER));

    //
    // adjust to point past CCMP header to message payload.
    //
    // For unicasts, the message payload is the Signature data.
    //
    // For multicasts, the signature was verified at the CNP level.
    //

    if (header->Type == CcmpMcastHeartbeatMsgType) {

        IF_CNDBG(CN_DEBUG_CCMPRECV) {
            CNPRINT(("[CCMP] Recv'd mcast packet from node %u "
                     "on network %u, node count %u, target "
                     "mask %04x, CNP flags %x.\n",
                     SourceNodeId, 
                     Network->Id,
                     header->NodeCount,
                     header->Message.McastHeartbeat.McastTargetNodes.UlongScreen,
                     CnpReceiveFlags
                     ));
        }

        //
        // Verify that the message was identified as a CNP multicast
        // and that the signature was verified.
        //
        if ((CnpReceiveFlags & 
             (CNP_RECV_FLAG_MULTICAST | CNP_RECV_FLAG_SIGNATURE_VERIFIED)
            ) != 
            (CNP_RECV_FLAG_MULTICAST | CNP_RECV_FLAG_SIGNATURE_VERIFIED)
           ) {
        
            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Dropping mcast packet from node %u "
                         "that was not identified as CNP multicast, "
                         "CNP flags %x.\n",
                         SourceNodeId, CnpReceiveFlags
                         ));
            }

            CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveNotVerified,
                "[CCMP] Dropping mcast packet from node %u "
                "that was not identified as CNP multicast, "
                "CNP flags %x.",
                SourceNodeId, CnpReceiveFlags
                );

            //
            // Drop it.
            //
            goto error_exit;            
        }

        //
        // Verify that the node count reported in the header is reasonable.
        // It must be compatible with our assumption that the entire 
        // cluster screen fits in one ULONG.
        //
        if (header->NodeCount >
            (sizeof(header->Message.McastHeartbeat.McastTargetNodes) * BYTEL)
            ) {
        
            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Recv'd mcast packet from node %u "
                         "with invalid node count %u, CNP flags %x.\n",
                         SourceNodeId,
                         header->NodeCount,
                         CnpReceiveFlags
                         ));
            }

            CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveNotTarget,
                "[CCMP] Recv'd mcast packet from node %u "
                "with invalid node count %u, CNP flags %x.",
                SourceNodeId,
                header->NodeCount,
                CnpReceiveFlags
                );

            //
            // Drop it.
            //
            goto error_exit;            
        }
        
        //
        // Verify that the packet contains data for this node.
        //
        if (!CnpClusterScreenMember(
                 header->Message.McastHeartbeat.McastTargetNodes.ClusterScreen,
                 INT_NODE(CnLocalNodeId)
                 )) {
            
            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Recv'd mcast packet from node %u "
                         "but node %u is not a target, CNP flags %x.\n",
                         SourceNodeId, CnLocalNodeId, CnpReceiveFlags
                         ));
            }

            CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveNotTarget,
                "[CCMP] Recv'd mcast packet from node %u "
                "but node %u is not a target, CNP flags %x.",
                SourceNodeId, CnLocalNodeId, CnpReceiveFlags
                );

            //
            // Drop it.
            //
            goto error_exit;            
        }

        nodeInfo = (CX_HB_NODE_INFO UNALIGNED *)((PUCHAR)Tsdu +
                                                 sizeof(CCMP_HEADER));

        SecStatus = SEC_E_OK;

    } else {

        SecBufferDesc            PacketDataDescriptor;
        SecBuffer                PacketData[3];
        ULONG                    fQOP;
        CN_IRQL                  SecContextIrql;
        PCLUSNET_SECURITY_DATA   contextData = &SecurityContexts[SourceNodeId];

        CnAssert(!(CnpReceiveFlags & CNP_RECV_FLAG_MULTICAST));
        CnAssert(!(CnpReceiveFlags & CNP_RECV_FLAG_SIGNATURE_VERIFIED));
        
        Tsdu = header + 1;
        TsduSize -= sizeof(CCMP_HEADER);

        //
        // Acquire the security context lock.
        //
        CnAcquireLock( &SecCtxtLock, &SecContextIrql );

        //
        // Verify that we have a valid context data.
        //
        if ( !VALID_SSPI_HANDLE( contextData->Inbound )) {

            CnReleaseLock( &SecCtxtLock, SecContextIrql );

            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Dropping packet - no security context "
                         "available for src node %u.\n",
                         SourceNodeId // LOGULONG
                         ));
            }

            CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveNoSecurityContext, 
                "[CCMP] Dropping packet - no security context available for "
                "src node %u.",
                SourceNodeId // LOGULONG
                );

            MEMLOG( MemLogNoSecurityContext, SourceNodeId, 0 );

            //
            // Drop it.
            //
            goto error_exit;
        } 
            
        //
        // Validate that the received signature size is expected.
        //
        if ( TsduSize < contextData->SignatureBufferSize ) {

            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Recv'd packet from node %u with "
                         "invalid signature buffer size %u.\n",
                         SourceNodeId,
                         TsduSize
                         ));
            }

            CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveBadSignatureSize,
                "[CCMP] Recv'd packet from node %u with invalid signature "
                "buffer size %u.",
                SourceNodeId, // LOGULONG
                TsduSize // LOGULONG
                );

            MEMLOG( MemLogSignatureSize, SourceNodeId, TsduSize );

            CnReleaseLock( &SecCtxtLock, SecContextIrql );

            //
            // Drop it.
            //
            goto error_exit;
        }

        //
        // Build the descriptors for the message and the
        // signature buffer
        //
        PacketDataDescriptor.cBuffers = 2;
        PacketDataDescriptor.pBuffers = PacketData;
        PacketDataDescriptor.ulVersion = SECBUFFER_VERSION;

        PacketData[0].BufferType = SECBUFFER_DATA;
        PacketData[0].cbBuffer = sizeof(CCMP_HEADER);
        PacketData[0].pvBuffer = (PVOID)header;

        PacketData[1].BufferType = SECBUFFER_TOKEN;
        PacketData[1].cbBuffer = contextData->SignatureBufferSize;
        PacketData[1].pvBuffer = (PVOID)Tsdu;

        //
        // Verify the signature of the packet.
        //
        SecStatus = VerifySignature(&contextData->Inbound,
                                    &PacketDataDescriptor,
                                    0,          // no sequence number
                                    &fQOP);     // Quality of protection

        //
        // Release the security context lock.
        //
        CnReleaseLock( &SecCtxtLock, SecContextIrql );
    }
    
    //
    // If the signature was verified, deliver the message.
    //
    if ( SecStatus == SEC_E_OK ) {

        if (header->Type == CcmpHeartbeatMsgType) {
            CnpReceiveHeartBeatMessage(Network,
                                       SourceNodeId,
                                       header->Message.Heartbeat.SeqNumber,
                                       header->Message.Heartbeat.AckNumber,
                                       FALSE,
                                       0);
        }
        else if (header->Type == CcmpMcastHeartbeatMsgType) {
            CnpReceiveHeartBeatMessage(
                Network,
                SourceNodeId,
                nodeInfo[INT_NODE(CnLocalNodeId)].SeqNumber,
                nodeInfo[INT_NODE(CnLocalNodeId)].AckNumber,
                ((CnpReceiveFlags & CNP_RECV_FLAG_CURRENT_MULTICAST_GROUP) ?
                 TRUE : FALSE),
                header->Message.McastHeartbeat.Epoch
                );
        }
        else if (header->Type == CcmpPoisonMsgType) {
            CnpReceivePoisonPacket(Network,
                                   SourceNodeId,
                                   header->Message.Heartbeat.SeqNumber);
        }
#ifdef MM_IN_CLUSNET
        else if (header->Type == CcmpMembershipMsgType) {
            if (TsduSize > 0) {
                PVOID  messageBuffer = Tsdu;

                //
                // Copy the data if it is unaligned.
                //
                if ( (((ULONG) Tsdu) & 0x3) != 0 ) {
                    IF_CNDBG(CN_DEBUG_CCMPRECV) {
                        CNPRINT(("[CCMP] Copying misaligned membership packet\n"));
                    }

                    messageBuffer = CnAllocatePool(TsduSize);

                    if (messageBuffer != NULL) {
                        RtlMoveMemory(messageBuffer, Tsdu, TsduSize);
                    }
                }

                if (messageBuffer != NULL) {

                    CmmReceiveMessageHandler(SourceNodeId,
                                             messageBuffer,
                                             TsduSize);
                }

                if (messageBuffer != Tsdu) {
                    CnFreePool(messageBuffer);
                }
            }
        }
#endif // MM_IN_CLUSNET
        else {
            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Received packet with unknown "
                         "type %u from node %u, CNP flags %x.\n",
                         header->Type, 
                         SourceNodeId,
                         CnpReceiveFlags
                         ));
            }

            CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveInvalidType,
                "[CCMP] Received packet with unknown type %u from "
                "node %u, CNP flags %x.",
                header->Type, // LOGUCHAR
                SourceNodeId, // LOGULONG
                CnpReceiveFlags // LOGXLONG
                );
            CnAssert(FALSE);
        }
    } else {
        IF_CNDBG(CN_DEBUG_CCMPRECV) {
            CNPRINT(("[CCMP] Recv'd packet type %u with bad "
                     "signature from node %d, security status %08x, "
                     "CNP flags %x.\n",
                     header->Type, 
                     SourceNodeId, 
                     SecStatus,
                     CnpReceiveFlags
                     ));
        }

        CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveInvalidSignature,
            "[CCMP] Recv'd %!msgtype! packet with bad signature from node %d, "
            "security status %08x, CNP flags %x.",
            header->Type, // LOGMsgType
            SourceNodeId, // LOGULONG
            SecStatus, // LOGXLONG
            CnpReceiveFlags // LOGXLONG
            );

        MEMLOG( MemLogInvalidSignature, SourceNodeId, header->Type );
    }

error_exit:

    CnVerifyCpuLockMask(
                        0,                // Required
                        0xFFFFFFFF,       // Forbidden
                        0                 // Maximum
                        );

    return;

} // CcmpProcessReceivePacket


NTSTATUS
CcmpCompleteReceivePacket(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
{
    PCNP_RECEIVE_REQUEST   request = Context;
    PCCMP_RECEIVE_CONTEXT  context = request->UpperProtocolContext;


    if (Irp->IoStatus.Status == STATUS_SUCCESS) {
        CnAssert(Irp->IoStatus.Information == context->TsduSize);

        CcmpProcessReceivePacket(
            context->Network,
            context->SourceNodeId,
            context->CnpReceiveFlags,
            (ULONG)Irp->IoStatus.Information,
            request->DataBuffer
            );
    }
    else {
        CnTrace(CCMP_RECV_ERROR, CcmpTraceCompleteReceiveFailed,
            "[CDP] Failed to fetch packet data, src node %u, "
            "CNP flags %x, status %!status!.",
            context->SourceNodeId, // LOGULONG
            context->CnpReceiveFlags, // LOGXLONG
            Irp->IoStatus.Status // LOGSTATUS
            );        
    }

    CnpFreeReceiveRequest(request);

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // CcmpCompleteReceivePacket


NTSTATUS
CcmpReceivePacketHandler(
    IN  PCNP_NETWORK   Network,
    IN  CL_NODE_ID     SourceNodeId,
    IN  ULONG          CnpReceiveFlags,
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    )
{
    NTSTATUS                 status;
    CCMP_HEADER UNALIGNED *  header = Tsdu;
    PCNP_RECEIVE_REQUEST     request;


    CnAssert(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (BytesIndicated >= sizeof(CCMP_HEADER)) {
        if (BytesIndicated == BytesAvailable) {

            CcmpProcessReceivePacket(
                Network,
                SourceNodeId,
                CnpReceiveFlags,
                BytesAvailable,
                Tsdu
                );

            *BytesTaken += BytesAvailable;
            *Irp = NULL;

            CnVerifyCpuLockMask(
                0,                // Required
                0xFFFFFFFF,       // Forbidden
                0                 // Maximum
                );

            return(STATUS_SUCCESS);
        }

        //
        // We need to fetch the rest of the packet before we
        // can process it.
        //
        // This message cannot be a CNP multicast, because 
        // the CNP layer could not have verified an incomplete 
        // message.
        //
        CnAssert(!(CnpReceiveFlags & CNP_RECV_FLAG_MULTICAST));
        CnAssert(!(CnpReceiveFlags & CNP_RECV_FLAG_SIGNATURE_VERIFIED));
        CnAssert(header->Type != CcmpMcastHeartbeatMsgType);

        request = CnpAllocateReceiveRequest(
                      CcmpReceiveRequestPool,
                      Network,
                      BytesAvailable,
                      CcmpCompleteReceivePacket
                      );

        if (request != NULL) {
            PCCMP_RECEIVE_CONTEXT  context = request->UpperProtocolContext;

            context->Network = Network;
            context->SourceNodeId = SourceNodeId;
            context->TsduSize = BytesAvailable;
            context->CnpReceiveFlags = CnpReceiveFlags;

            *Irp = request->Irp;

            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Fetching packet data, src node %u, "
                         "BI %u, BA %u, CNP flags %x.\n",
                         SourceNodeId, BytesIndicated, 
                         BytesAvailable, CnpReceiveFlags));

            }
            
            CnTrace(CCMP_RECV_DETAIL, CcmpTraceCompleteReceive,
                "[CCMP] Fetching packet data, src node %u, "
                "BI %u, BA %u, CNP flags %x.",
                SourceNodeId, // LOGULONG
                BytesIndicated, // LOGULONG
                BytesAvailable, // LOGULONG
                CnpReceiveFlags // LOGXLONG
                );        
            
            CnVerifyCpuLockMask(
                0,                // Required
                0xFFFFFFFF,       // Forbidden
                0                 // Maximum
                );

            return(STATUS_MORE_PROCESSING_REQUIRED);
        }
        else {
            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Dropped incoming packet - "
                         "out of resources, src node %u.\n",
                         SourceNodeId));

            }
            CnTrace(CCMP_RECV_ERROR, CcmpTraceDropReceiveOOR,
                "[CCMP] Dropped incoming packet - out of resources, "
                "src node %u.",
                SourceNodeId // LOGULONG
                );        
        }
    }
    else {
        IF_CNDBG(CN_DEBUG_CCMPRECV) {
            CNPRINT(("[CCMP] Dropped incoming runt packet, "
                     "src node %u, BI %u, BA %u, CNP flags %x.\n",
                     SourceNodeId, BytesIndicated, BytesAvailable,
                     CnpReceiveFlags));

        }
        CnTrace(CCMP_RECV_ERROR, CcmpTraceDropReceiveRunt,
            "[CCMP] Dropped incoming runt packet, src node %u, "
            "BI %u, BA %u, CNP flags %x.",
            SourceNodeId, // LOGULONG
            BytesIndicated, // LOGULONG
            BytesAvailable, // LOGULONG
            CnpReceiveFlags // LOGXLONG
            );        
    }

    //
    // Something went wrong. Drop the packet.
    //
    *BytesTaken += BytesAvailable;

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_SUCCESS);

}  // CcmpReceivePacketHandler

PVOID
SignatureAllocate(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
{
    PSIGNATURE_DATA SignatureData;

    CnAssert( NumberOfBytes == ( sizeof(SIGNATURE_DATA) + AllocatedSignatureBufferSize ));

    //
    // allocate the space and then construct an MDL describing it
    //

    SignatureData = ExAllocatePoolWithTag( PoolType, NumberOfBytes, Tag );

    if ( SignatureData != NULL ) {

        SignatureData->SigMDL = IoAllocateMdl(SignatureData->PacketSignature,
                                              AllocatedSignatureBufferSize,
                                              FALSE,
                                              FALSE,
                                              NULL);

        if ( SignatureData->SigMDL != NULL ) {

            MmBuildMdlForNonPagedPool(SignatureData->SigMDL);
            CN_INIT_SIGNATURE( SignatureData, CN_SIGNATURE_TAG );
        } else {

            ExFreePool( SignatureData );
            SignatureData = NULL;
        }
    }

    return SignatureData;
}

VOID
SignatureFree(
    IN PVOID Buffer
    )
{
    PSIGNATURE_DATA SignatureData = (PSIGNATURE_DATA)Buffer;

    CN_ASSERT_SIGNATURE( SignatureData, CN_SIGNATURE_TAG );
    IoFreeMdl( SignatureData->SigMDL );

    ExFreePool( SignatureData );
}

VOID
CxDeleteSecurityContext(
    IN  CL_NODE_ID NodeId
    )

/*++

Routine Description:

    Delete the security context associated with the specified node

Arguments:

    NodeId - Id of the node blah blah blah

Return Value:

    None

--*/

{
    PCLUSNET_SECURITY_DATA contextData = &SecurityContexts[ NodeId ];

    if ( VALID_SSPI_HANDLE( contextData->Inbound )) {

        DeleteSecurityContext( &contextData->Inbound );
        INVALIDATE_SSPI_HANDLE( contextData->Inbound );
    }

    if ( VALID_SSPI_HANDLE( contextData->Outbound )) {

        DeleteSecurityContext( &contextData->Outbound );
        INVALIDATE_SSPI_HANDLE( contextData->Outbound );
    }
}


NTSTATUS
CxImportSecurityContext(
    IN  CL_NODE_ID NodeId,
    IN  PWCHAR PackageName,
    IN  ULONG PackageNameSize,
    IN  ULONG SignatureSize,
    IN  PVOID ServerContext,
    IN  PVOID ClientContext
    )

/*++

Routine Description:

    import a security context that was established in user mode into
    the kernel SSP. We are passed pointers to the structures in user
    mode, so they have be probed and used within try/except blocks.

Arguments:

    NodeId - # of node with which a security context was established

    PackageName - user process pointer to security package name

    PackageNameSize - length, in bytes, of PackageName

    SignatureSize - size, in bytes, needed for a Signature Buffer

    ServerContext - user process pointer to area that contains the
        SecBuffer for an inbound security context

    ClientContext - same as ServerContext, but for outbound security
        context

Return Value:

    STATUS_SUCCESS if everything worked ok, otherwise some error in issperr.h

--*/

{
    PSecBuffer      InboundSecBuffer = (PSecBuffer)ServerContext;
    PSecBuffer      OutboundSecBuffer = (PSecBuffer)ClientContext;

    PVOID           CapturedInboundSecData;
    ULONG           CapturedInboundSecDataSize;
    PVOID           CapturedOutboundSecData;
    ULONG           CapturedOutboundSecDataSize;

    CtxtHandle      InboundContext;
    CtxtHandle      OutboundContext;
    NTSTATUS        Status;

    PWCHAR          KPackageName = NULL;
    PSecBuffer      KInboundSecBuffer = NULL;
    PSecBuffer      KOutboundSecBuffer = NULL;
    PVOID           KInboundData = NULL;
    PVOID           KOutboundData = NULL;
    CN_IRQL         SecContextIrql;
    SECURITY_STRING PackageNameDesc;

    //
    // even though this routine is not marked pagable, make sure that we're
    // not running at raised IRQL since DeleteSecurityContext will puke.
    //
    PAGED_CODE();

    IF_CNDBG( CN_DEBUG_INIT )
        CNPRINT(("[CCMP]: Importing security contexts from %ws\n",
                 PackageName));

    if ( AllocatedSignatureBufferSize == 0 ) {
        //
        // first time in this routine, so create a lookaside list pool for
        // signature buffers and their MDLs
        //

        CnAssert( SignatureLL == NULL );
        SignatureLL = CnAllocatePool( sizeof( NPAGED_LOOKASIDE_LIST ));

        if ( SignatureLL != NULL ) {
            //
            // with the support of multiple packages, the only way to
            // determine the sig buffer size was after a context had been
            // generated. Knowing the max size of all sig buffers used by the
            // service before this routine is called will prevent having to
            // add a bunch of synchronization code that would allocate new
            // buffers and phase out the old buffer pool. on NT5, NTLM uses 16
            // bytes while kerberos uses 37b. We've asked security for a call
            // that will give us the max sig size for a set of packages but
            // that hasn't materialized, hence we force the sig buffer size to
            // something that will work for both NTLM and kerberos. But this
            // discussion is kinda moot since we don't use kerberos anyway on
            // NT5.
            //

//            AllocatedSignatureBufferSize = SignatureSize;
            AllocatedSignatureBufferSize = 64;

#if 0
            ExInitializeNPagedLookasideList(SignatureLL,
                                            SignatureAllocate,
                                            SignatureFree,
                                            0,
                                            sizeof( SIGNATURE_DATA ) + SignatureSize,
                                            CN_POOL_TAG,
                                            4);
#endif
            ExInitializeNPagedLookasideList(SignatureLL,
                                            SignatureAllocate,
                                            SignatureFree,
                                            0,
                                            sizeof( SIGNATURE_DATA ) + AllocatedSignatureBufferSize,
                                            CN_POOL_TAG,
                                            4);
        } else {
            IF_CNDBG( CN_DEBUG_INIT )
                CNPRINT(("[CCMP]: no memory for signature LL\n"));

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto error_exit;
        }

    } else if ( SignatureSize > AllocatedSignatureBufferSize ) {

        //
        // the signature buffer is growing. the problem is that the lookaside
        // list is already in use by other nodes.
        //
        Status = STATUS_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // validate the pointers passed in as the SecBuffers
    //

    try {
        ProbeForRead( PackageName,
                      PackageNameSize,
                      sizeof( UCHAR ) );

        ProbeForRead( InboundSecBuffer,
                      sizeof( SecBuffer ),
                      sizeof( UCHAR ) );

        ProbeForRead( OutboundSecBuffer,
                      sizeof( SecBuffer ),
                      sizeof( UCHAR ) );

        //
        // made it this far; now capture the internal pointers and their
        // lengths. Probe the embedded pointers in the SecBuffers using the
        // captured data
        //
        CapturedInboundSecData = InboundSecBuffer->pvBuffer;
        CapturedInboundSecDataSize = InboundSecBuffer->cbBuffer;

        CapturedOutboundSecData = OutboundSecBuffer->pvBuffer;
        CapturedOutboundSecDataSize = OutboundSecBuffer->cbBuffer;

        ProbeForRead( CapturedInboundSecData,
                      CapturedInboundSecDataSize,
                      sizeof( UCHAR ) );

        ProbeForRead( CapturedOutboundSecData,
                      CapturedOutboundSecDataSize,
                      sizeof( UCHAR ) );

        //
        // make local copies of everything since security doesn't
        // handle accvios very well
        //

        KPackageName = CnAllocatePoolWithQuota( PackageNameSize );
        if ( KPackageName == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        RtlCopyMemory( KPackageName, PackageName, PackageNameSize );

        KInboundSecBuffer = CnAllocatePoolWithQuota( sizeof( SecBuffer ));
        if ( KInboundSecBuffer == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }
        *KInboundSecBuffer = *InboundSecBuffer;
        KInboundSecBuffer->cbBuffer = CapturedInboundSecDataSize;

        KOutboundSecBuffer = CnAllocatePoolWithQuota( sizeof( SecBuffer ));
        if ( KOutboundSecBuffer == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }
        *KOutboundSecBuffer = *OutboundSecBuffer;
        KOutboundSecBuffer->cbBuffer = CapturedOutboundSecDataSize;

        KInboundData = CnAllocatePoolWithQuota( KInboundSecBuffer->cbBuffer );
        if ( KInboundData == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }
        RtlCopyMemory( KInboundData, CapturedInboundSecData, CapturedInboundSecDataSize );
        KInboundSecBuffer->pvBuffer = KInboundData;

        KOutboundData = CnAllocatePoolWithQuota( KOutboundSecBuffer->cbBuffer );
        if ( KOutboundData == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }
        RtlCopyMemory( KOutboundData, CapturedOutboundSecData, CapturedOutboundSecDataSize );
        KOutboundSecBuffer->pvBuffer = KOutboundData;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred while attempting to probe or copy
        // from one of the caller's parameters. Simply return an
        // appropriate error status code.
        //

        Status = GetExceptionCode();
        IF_CNDBG( CN_DEBUG_INIT )
            CNPRINT(("[CCMP]: Buffer probe failed %08X", Status ));

        goto error_exit;
    }

    //
    // import the data we were handed
    //

    RtlInitUnicodeString( &PackageNameDesc, KPackageName );

    Status = ImportSecurityContext(&PackageNameDesc,
                                   KInboundSecBuffer,
                                   NULL,
                                   &InboundContext);

    if ( NT_SUCCESS( Status )) {

        Status = ImportSecurityContext(&PackageNameDesc,
                                       KOutboundSecBuffer,
                                       NULL,
                                       &OutboundContext);

        if ( NT_SUCCESS( Status )) {
            CtxtHandle oldInbound;
            CtxtHandle oldOutbound;
            PCLUSNET_SECURITY_DATA contextData = &SecurityContexts[ NodeId ];

            INVALIDATE_SSPI_HANDLE( oldInbound );
            INVALIDATE_SSPI_HANDLE( oldOutbound );

            //
            // DeleteSecurityContext can't be called at raised IRQL so make
            // copies of the contexts to be deleted under the lock. After
            // releasing the lock, we can delete the old contexts.
            //

            CnAcquireLock( &SecCtxtLock, &SecContextIrql );

            if ( VALID_SSPI_HANDLE( contextData->Inbound )) {
                oldInbound = contextData->Inbound;
            }

            if ( VALID_SSPI_HANDLE( contextData->Outbound )) {
                oldOutbound = contextData->Outbound;
            }

            contextData->Inbound = InboundContext;
            contextData->Outbound = OutboundContext;
            contextData->SignatureBufferSize = SignatureSize;

            //
            // Update MaxSignatureSize -- the largest signature imported
            // so far.
            //
            if (SignatureSize > MaxSignatureSize) {
                MaxSignatureSize = SignatureSize;
            }

            CnReleaseLock( &SecCtxtLock, SecContextIrql );

            if ( VALID_SSPI_HANDLE( oldInbound )) {
                DeleteSecurityContext( &oldInbound );
            }

            if ( VALID_SSPI_HANDLE( oldOutbound )) {
                DeleteSecurityContext( &oldOutbound );
            }
        } else {
            IF_CNDBG( CN_DEBUG_INIT )
                CNPRINT(("[CCMP]: import of outbound security context failed  %08X\n", Status ));

            DeleteSecurityContext( &InboundContext );

            goto error_exit;
        }
    } else {
        IF_CNDBG( CN_DEBUG_INIT )
            CNPRINT(("[CCMP]: import of inbound security context failed %08X\n", Status ));
        goto error_exit;
    }

error_exit:

    //
    // Clean up allocations.
    //

    if ( KPackageName ) {
        CnFreePool( KPackageName );
    }

    if ( KInboundSecBuffer ) {
        CnFreePool( KInboundSecBuffer );
    }

    if ( KOutboundSecBuffer ) {
        CnFreePool( KOutboundSecBuffer );
    }

    if ( KInboundData ) {
        CnFreePool( KInboundData );
    }

    if ( KOutboundData ) {
        CnFreePool( KOutboundData );
    }

    if (NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // The following is only executed in an error situation.
    //

    IF_CNDBG( CN_DEBUG_INIT ) {
        CNPRINT(("[CCMP]: CxImportSecurityContext returning %08X%\n", Status));
    }
    
    if (CcmpMcastHBSendRequestPool != NULL) {
        CnpDeleteSendRequestPool(CcmpMcastHBSendRequestPool);
        CcmpMcastHBSendRequestPool = NULL;
    }
    if (SignatureLL != NULL) {
        ExDeleteNPagedLookasideList(SignatureLL);
        CnFreePool(SignatureLL);
        SignatureLL = NULL;
    }

    return Status;

} // CxImportSecurityContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\chbeat.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    chbeat.c

Abstract:

    membership state heart beat code. Tracks node availability through
    exchanging heart beat messages with nodes that are marked as alive.

Author:

    Charlie Wickham (charlwi) 05-Mar-1997

Environment:

    Kernel Mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "chbeat.tmh"

#include "clusvmsg.h"
#include "stdio.h"

/* External */

/* Static */

//
// heart beat structures - heart beats are driven by a timer and DPC
// routine. In order to synchronize the shutdown of the DPC, we also need two
// flags, an event and a spin lock.
//

KTIMER HeartBeatTimer;
KDPC HeartBeatDpc;
KEVENT HeartBeatDpcFinished;
BOOLEAN HeartBeatEnabled = FALSE;
BOOLEAN HeartBeatDpcRunning = FALSE;
CN_LOCK HeartBeatLock;

#if 0

Heart Beating Explained

ClockTicks are incremented every HEART_BEAT_PERIOD millisecs. SendTicks are the
number of ticks that go by before sending HBs.

The check for received HB msgs is done in the tick just before HB msgs are
sent. Interface Lost HB ticks are in terms of heart beat check periods and
therefore are incremented only during the check period. An interface is failed
when the number of Interface Lost HB ticks have passed and no HB message has
been received on that interface.

Likewise, Node Lost HB Ticks are in terms of heart beat check periods and are
incremented during the check period. After all interfaces have failed on a
node, Node Lost HB ticks must pass without an interface going back online
before a node down event is issued.  Note that a node's comm state is set to
offline when all interfaces have failed.

#endif

#define CLUSNET_HEART_BEAT_SEND_TICKS           2       // every 1.2 secs
#define CLUSNET_INTERFACE_LOST_HEART_BEAT_TICKS 3       // after 3 secs
#define CLUSNET_NODE_LOST_HEART_BEAT_TICKS      6       // after 6.6 secs

ULONG HeartBeatClockTicks;
ULONG HeartBeatSendTicks = CLUSNET_HEART_BEAT_SEND_TICKS;
ULONG HBInterfaceLostHBTicks = CLUSNET_INTERFACE_LOST_HEART_BEAT_TICKS;
ULONG HBNodeLostHBTicks = CLUSNET_NODE_LOST_HEART_BEAT_TICKS;

//
// Unicast Heartbeat Data
//
// Even with multicast heartbeats, unicast heartbeats must be supported
// for backwards compatibility.
//

//
// This array records all the nodes that need to have a HB sent to another
// node. This array is not protected by a lock since it is only used with the
// heartbeat DPC routine.
//

typedef struct _INTERFACE_HEARTBEAT_INFO {
    CL_NODE_ID NodeId;